Title: LPC2018 - Real Time MC
Publication date: 2018-12-04
Playlist: LPC2018 - MicroConferences
Description: 
	https://linuxplumbersconf.org/event/2/sessions/27/#20181113

Since 2004 a project has been going on trying to make the Linux kernel into a true hard Real-Time operating system. This project has become know as PREEMPT_RT (formally the "real-time patch"). Over the past decade, there was a running joke that this year PREEMPT_RT would be merged into the mainline kernel, but that has never happened. In actuality, it has been merged in pieces. Examples of what came from PREEMPT_RT include: mutexes, high resolution timers, lockdep, ftrace, RT scheduling, SCHED_DEADLINE, RCU_PREEMPT, generic interrupts, priority inheritance futexes, threaded interrupt handlers and more. The only thing left is turning spin_locks into mutexes, and that is now mature enough to make its way into mainline Linux. This year could possibly be the year PREEMPT_RT is merged!

Getting PREEMPT_RT into the kernel was a battle, but it is not the end of the war. Once PREEMPT_RT is in mainline, there's still much more work to be done. The RT developers have been so focused on getting RT into mainline, that little has been thought about what to do when it is finally merged. There is a lot to discuss about what to do after RT is in mainline. The game is not over yet.
Captions: 
	00:00:06,830 --> 00:00:13,110
okay so also if you go to if everyone

00:00:11,070 --> 00:00:15,120
goes or whoever will feels like they

00:00:13,110 --> 00:00:18,650
want to help out here and if you go to

00:00:15,120 --> 00:00:21,450
the Linux plumbers comp org website

00:00:18,650 --> 00:00:23,369
you'll see a little note on the left

00:00:21,450 --> 00:00:25,890
side and wanted menu options this would

00:00:23,369 --> 00:00:26,820
be ether pads click on ether pad so list

00:00:25,890 --> 00:00:28,439
all the ether pads for all the micro

00:00:26,820 --> 00:00:30,689
conferences there's gonna be a real-time

00:00:28,439 --> 00:00:33,420
one I'm gonna soon have it up on that

00:00:30,689 --> 00:00:34,829
monitor well I'm not gonna be taking the

00:00:33,420 --> 00:00:37,440
notes so I'm hoping someone else will

00:00:34,829 --> 00:00:39,539
take notes so it's more people anyone

00:00:37,440 --> 00:00:41,039
could login and take notes and it'll be

00:00:39,539 --> 00:00:45,719
very useful if we have more than one

00:00:41,039 --> 00:00:50,909
person doing it but with that said Julia

00:00:45,719 --> 00:01:01,199
and Darrin or do I start off with leh

00:00:50,909 --> 00:01:07,080
bar TPA so can everybody hear us okay

00:01:01,199 --> 00:01:08,970
Mic Check oh cool

00:01:07,080 --> 00:01:12,390
so Julie and I are gonna talk a little

00:01:08,970 --> 00:01:14,760
bit about the history of pthread cond

00:01:12,390 --> 00:01:16,680
VARs what the problems were how we got

00:01:14,760 --> 00:01:18,300
them fixed how they got unfixed how

00:01:16,680 --> 00:01:20,270
weary fixing them and where we're gonna

00:01:18,300 --> 00:01:24,690
go from there

00:01:20,270 --> 00:01:28,590
so a little bit of background the the

00:01:24,690 --> 00:01:31,140
conv ours back in 2009 had the potential

00:01:28,590 --> 00:01:33,360
for a unbounded priority inversion on

00:01:31,140 --> 00:01:35,820
what was an internal non priority

00:01:33,360 --> 00:01:37,590
inheritance data lock so the convar

00:01:35,820 --> 00:01:39,870
structure itself had an internal lock

00:01:37,590 --> 00:01:42,270
that protected some of its internal

00:01:39,870 --> 00:01:44,430
state and that lock itself was not

00:01:42,270 --> 00:01:47,460
priority inheritance aware so even if

00:01:44,430 --> 00:01:49,950
you paired the convar with a p i-- mutex

00:01:47,460 --> 00:01:53,100
you could still end up in a priority

00:01:49,950 --> 00:01:57,960
inversion on that data lock so we

00:01:53,100 --> 00:02:00,360
prepared changes to G Lib C and we

00:01:57,960 --> 00:02:04,250
implemented the kernel side futex riku

00:02:00,360 --> 00:02:07,860
pi mechanisms which solved this problem

00:02:04,250 --> 00:02:09,989
and we were socializing that with G web

00:02:07,860 --> 00:02:11,610
see there's the bug reference here you

00:02:09,989 --> 00:02:15,090
can read through it in all of its gory

00:02:11,610 --> 00:02:16,799
detail as well as the paper that we

00:02:15,090 --> 00:02:18,460
submitted to the real-time Linux

00:02:16,799 --> 00:02:20,970
workshop 11

00:02:18,460 --> 00:02:24,880
all that detail is there unfortunately

00:02:20,970 --> 00:02:26,200
oh and what I should say is a lot of

00:02:24,880 --> 00:02:27,730
folks that care about real-time and our

00:02:26,200 --> 00:02:30,130
shipping real-time Linux distributions

00:02:27,730 --> 00:02:36,280
have been using this out of tree patch

00:02:30,130 --> 00:02:40,450
to GMC since 2009 but the fix is still

00:02:36,280 --> 00:02:45,900
not upstream now in 2011 somebody raised

00:02:40,450 --> 00:02:45,900
a bug about ordering with respect to

00:02:46,350 --> 00:02:53,710
getting there so in 2011 someone opened

00:02:50,860 --> 00:02:55,930
a bug against UMC about the ordering

00:02:53,710 --> 00:02:59,380
constraints of the POSIX standard and

00:02:55,930 --> 00:03:03,370
the implementation in Lib C part of that

00:02:59,380 --> 00:03:05,500
was around spurious wake ups and how GMC

00:03:03,370 --> 00:03:07,720
tried to mitigate them but the end

00:03:05,500 --> 00:03:09,730
result was a change in the

00:03:07,720 --> 00:03:11,860
interpretation well a change to the

00:03:09,730 --> 00:03:13,420
standard and an interpretation of the

00:03:11,860 --> 00:03:16,750
standard which is summarized in this

00:03:13,420 --> 00:03:19,570
quote up here which basically provides

00:03:16,750 --> 00:03:22,120
some stricter ordering with respect to

00:03:19,570 --> 00:03:24,460
which waiters can wake when relative to

00:03:22,120 --> 00:03:29,350
signals what does it mean to be waiting

00:03:24,460 --> 00:03:33,040
before versus waiting after the the race

00:03:29,350 --> 00:03:35,590
condition that was raised is when if you

00:03:33,040 --> 00:03:39,250
have a bunch of waiters that have gone

00:03:35,590 --> 00:03:40,870
to wait on a on a convar as they're

00:03:39,250 --> 00:03:42,880
starting to wake back up and they take

00:03:40,870 --> 00:03:44,920
an internal lock something after the

00:03:42,880 --> 00:03:46,930
signal can start to wait get hung up on

00:03:44,920 --> 00:03:48,970
that same lock and end up stealing one

00:03:46,930 --> 00:03:54,220
of the signals meant for the old ones so

00:03:48,970 --> 00:03:57,010
this led to a five year conversation on

00:03:54,220 --> 00:03:59,950
Lib C alpha and the Austin group with

00:03:57,010 --> 00:04:03,120
respect to converse and the end result

00:03:59,950 --> 00:04:05,680
is that the current since 2.25

00:04:03,120 --> 00:04:08,530
implementation of conv ARS and Lib C no

00:04:05,680 --> 00:04:12,010
longer make use of futex riku so what

00:04:08,530 --> 00:04:13,990
that means is the old fix is no longer

00:04:12,010 --> 00:04:16,570
viable it doesn't apply and it can't

00:04:13,990 --> 00:04:19,000
apply because it's dependent upon the

00:04:16,570 --> 00:04:20,799
few tech structures and system calls and

00:04:19,000 --> 00:04:22,900
that vicarious locking that all happens

00:04:20,799 --> 00:04:25,480
inside the kernel so it no longer

00:04:22,900 --> 00:04:27,100
applies but that leaves us in the

00:04:25,480 --> 00:04:28,690
situation where the folks that have been

00:04:27,100 --> 00:04:30,050
shipping this out of tree patch since

00:04:28,690 --> 00:04:32,599
00:04:30,050 --> 00:04:35,629
can now no longer upgrade their lib see

00:04:32,599 --> 00:04:37,970
past version 2.25 which for something as

00:04:35,629 --> 00:04:39,530
Cora's Lib C is kind of a nasty place to

00:04:37,970 --> 00:04:42,460
be in with respect to security

00:04:39,530 --> 00:04:45,710
vulnerabilities and things like that so

00:04:42,460 --> 00:04:47,810
we we've been at this for nine years we

00:04:45,710 --> 00:04:49,099
figured maybe it's time to take a step

00:04:47,810 --> 00:04:51,530
back how do we solve the immediate

00:04:49,099 --> 00:05:00,080
problem what people upgrade their C

00:04:51,530 --> 00:05:03,500
libraries so years ago yeah so about a

00:05:00,080 --> 00:05:07,330
year ago we met in Prague and we decided

00:05:03,500 --> 00:05:10,159
to come up with the idea of a simple

00:05:07,330 --> 00:05:13,610
narrow in scope implementation of

00:05:10,159 --> 00:05:16,669
priority inheritance aware condition

00:05:13,610 --> 00:05:18,169
variables the idea here being let's

00:05:16,669 --> 00:05:20,960
address what we believe to be the

00:05:18,169 --> 00:05:23,090
specific real-time use case of conv ours

00:05:20,960 --> 00:05:25,759
in a way that people can use them

00:05:23,090 --> 00:05:28,789
independently from Lib C which decouples

00:05:25,759 --> 00:05:34,520
their dependency on Lib C versioning and

00:05:28,789 --> 00:05:38,169
so this project is as well after today

00:05:34,520 --> 00:05:40,009
soon as we merge the counters branch

00:05:38,169 --> 00:05:42,830
should be considered basically

00:05:40,009 --> 00:05:45,919
functional but what we'd like to do

00:05:42,830 --> 00:05:51,979
today is verify our assumptions use

00:05:45,919 --> 00:05:56,060
cases with input from you users of with

00:05:51,979 --> 00:05:58,430
real-time what can I talk real real-time

00:05:56,060 --> 00:06:01,610
use cases workloads help us make sure

00:05:58,430 --> 00:06:04,520
we're not misunderstanding your needs or

00:06:01,610 --> 00:06:09,020
the expectations so really quickly with

00:06:04,520 --> 00:06:11,659
respect to live arty PI it does not

00:06:09,020 --> 00:06:14,210
reuse pthread condition variables or

00:06:11,659 --> 00:06:17,860
mutex structures so we reimplemented

00:06:14,210 --> 00:06:22,759
these initially using system calls and

00:06:17,860 --> 00:06:24,500
counters so Sebastian is here so most of

00:06:22,759 --> 00:06:27,620
this work in terms of the implementation

00:06:24,500 --> 00:06:29,659
of conv ours and mutexes Sebastian and

00:06:27,620 --> 00:06:37,219
Julia were doing that on a mountain

00:06:29,659 --> 00:06:38,899
someplace and but we integrated that

00:06:37,219 --> 00:06:41,659
work into the counters branch which we

00:06:38,899 --> 00:06:44,250
can merge after today

00:06:41,659 --> 00:06:45,960
what this does is it enforces some of

00:06:44,250 --> 00:06:48,569
those use cases rules real time use

00:06:45,960 --> 00:06:50,849
cases pthreads allow you to not

00:06:48,569 --> 00:06:53,189
necessarily be - not necessarily

00:06:50,849 --> 00:06:55,050
associated mutex with a convar we

00:06:53,189 --> 00:06:57,240
disallow that it's part of the structure

00:06:55,050 --> 00:06:59,759
now you have to pare them when you

00:06:57,240 --> 00:07:02,580
create them they are only prey inherit

00:06:59,759 --> 00:07:03,719
there's no opportunity to be nun or

00:07:02,580 --> 00:07:06,930
sealing

00:07:03,719 --> 00:07:09,870
there's no robust there's no error check

00:07:06,930 --> 00:07:13,650
there's no recursion there's no

00:07:09,870 --> 00:07:15,990
cancellation so those are many of the

00:07:13,650 --> 00:07:18,990
ways in which we limited the the use

00:07:15,990 --> 00:07:21,479
case that were concerned with and the

00:07:18,990 --> 00:07:26,780
waiters will wake up in highest priority

00:07:21,479 --> 00:07:33,419
FIFO order and the github link is there

00:07:26,780 --> 00:07:35,190
and with that I'd like to have Julia

00:07:33,419 --> 00:07:40,020
lead us in a discussion about expected

00:07:35,190 --> 00:07:42,000
behavior so first of all I want to talk

00:07:40,020 --> 00:07:44,990
a little bit about how gilepsy currently

00:07:42,000 --> 00:07:48,539
implements convar so this is after

00:07:44,990 --> 00:07:51,719
Torvalds rewrite he changed out the

00:07:48,539 --> 00:07:55,560
Condors are implemented to satisfy the

00:07:51,719 --> 00:07:57,029
the new POSIX interpretation so here's

00:07:55,560 --> 00:07:58,139
how it functions and I'll walk through

00:07:57,029 --> 00:08:01,710
this example this is actually his

00:07:58,139 --> 00:08:05,250
example so the credit goes to him so the

00:08:01,710 --> 00:08:06,750
top row indicates that the W is the two

00:08:05,250 --> 00:08:09,419
boxes the double uses are two waiters

00:08:06,750 --> 00:08:11,250
that are queued on a conditional and

00:08:09,419 --> 00:08:13,979
conditional variable and they're

00:08:11,250 --> 00:08:17,069
assigned a group now by default when a

00:08:13,979 --> 00:08:21,330
task goes to wait on a convar they are

00:08:17,069 --> 00:08:23,099
put into what is here G - but that is a

00:08:21,330 --> 00:08:26,219
group that indicates that they're not

00:08:23,099 --> 00:08:28,529
eligible to be woken up by a signal and

00:08:26,219 --> 00:08:32,180
then at some point later in the second

00:08:28,529 --> 00:08:35,279
row we have our first signal s1 that is

00:08:32,180 --> 00:08:37,320
that occurs and at that point during the

00:08:35,279 --> 00:08:38,849
signal delivery path we move all the

00:08:37,320 --> 00:08:42,029
tasks that are in the currently

00:08:38,849 --> 00:08:44,790
ineligible group we move those into an

00:08:42,029 --> 00:08:47,130
eligible group and then one of the tasks

00:08:44,790 --> 00:08:49,589
has chosen from the current the now

00:08:47,130 --> 00:08:51,680
eligible group so in this case s1 this

00:08:49,589 --> 00:08:54,660
indicate this arrow that I have here

00:08:51,680 --> 00:08:56,100
indicates they that w1 is the

00:08:54,660 --> 00:09:02,699
threat that actually is chosen to be

00:08:56,100 --> 00:09:05,009
awoken and so now on the bottom row at

00:09:02,699 --> 00:09:06,899
some point later we have a third waiter

00:09:05,009 --> 00:09:10,889
that comes along and the third waiter

00:09:06,899 --> 00:09:13,649
sees that the current eligible group is

00:09:10,889 --> 00:09:16,379
not completely depleted and so what it

00:09:13,649 --> 00:09:18,509
does is it queues itself on g2 which is

00:09:16,379 --> 00:09:21,149
I Misha and g2 just means that it's a

00:09:18,509 --> 00:09:25,319
none eligible analogy before being woken

00:09:21,149 --> 00:09:27,120
up and so when the s2 is delivered it

00:09:25,319 --> 00:09:28,980
will actually go and look and deliver

00:09:27,120 --> 00:09:31,350
the signal to the list of eligible

00:09:28,980 --> 00:09:34,379
waiters in g1 and so at this point it

00:09:31,350 --> 00:09:36,120
would choose W - hopefully that's clear

00:09:34,379 --> 00:09:39,089
if not I can answer questions about that

00:09:36,120 --> 00:09:40,860
I want to talk about the inversion case

00:09:39,089 --> 00:09:45,000
that's problematic for RT in this

00:09:40,860 --> 00:09:47,279
implementation so in the the inversion

00:09:45,000 --> 00:09:50,670
case that's problematic for RT is in the

00:09:47,279 --> 00:09:53,670
case where the w3 here that actually

00:09:50,670 --> 00:09:55,529
gets queued in the UH knowledgeable list

00:09:53,670 --> 00:09:58,769
is a high priority waiter

00:09:55,529 --> 00:10:01,769
and so therefore s2 should actually wake

00:09:58,769 --> 00:10:04,980
up w3 because it happens to be the

00:10:01,769 --> 00:10:06,870
highest priority waiter and as it exists

00:10:04,980 --> 00:10:08,100
now in the implementation this just

00:10:06,870 --> 00:10:10,290
doesn't happen so there's an inversion

00:10:08,100 --> 00:10:12,870
scenario as it exists now in the

00:10:10,290 --> 00:10:15,360
implementation ng Lipsy and that's

00:10:12,870 --> 00:10:18,029
something that we want to yeah yeah a

00:10:15,360 --> 00:10:19,829
question has there been complaints about

00:10:18,029 --> 00:10:21,000
this in the real-time community or is

00:10:19,829 --> 00:10:29,370
there something we just noticed I mean

00:10:21,000 --> 00:10:31,639
where was the notice of this issue watch

00:10:29,370 --> 00:10:31,639
heads

00:10:35,510 --> 00:10:43,590
yeah so Torvalds came to the real-time

00:10:39,330 --> 00:10:47,010
Linux workshop in Berlin where we

00:10:43,590 --> 00:10:50,480
discussed the entire situation around

00:10:47,010 --> 00:10:54,090
priority inheritance and coneflowers and

00:10:50,480 --> 00:10:59,220
when he described his new scheme that

00:10:54,090 --> 00:11:03,240
was posix-compliant I already told him

00:10:59,220 --> 00:11:05,100
that this was broken for a real time at

00:11:03,240 --> 00:11:08,760
the time so he knew this before it

00:11:05,100 --> 00:11:10,530
landed in India Lipsy it's in the bug

00:11:08,760 --> 00:11:12,570
stated that way as well it basically

00:11:10,530 --> 00:11:15,030
says there's no known solution to

00:11:12,570 --> 00:11:17,010
achieve this with the requirements of

00:11:15,030 --> 00:11:20,310
the semantics and the existing futex

00:11:17,010 --> 00:11:22,410
operations as part of the my question is

00:11:20,310 --> 00:11:24,270
did anyone in the real-time community

00:11:22,410 --> 00:11:27,390
complain about this or is this so we

00:11:24,270 --> 00:11:28,590
complained them to him right this was

00:11:27,390 --> 00:11:34,110
not good for us

00:11:28,590 --> 00:11:41,850
he was like man well my is was there any

00:11:34,110 --> 00:11:44,400
who's the users of Khan bars so I mean I

00:11:41,850 --> 00:11:46,340
presented with Torvalds at that time we

00:11:44,400 --> 00:11:48,810
were active on the discussion on the

00:11:46,340 --> 00:11:52,020
bugs ill and things but their priority

00:11:48,810 --> 00:11:56,630
is POSIX compliant and basically what

00:11:52,020 --> 00:11:56,630
we're talking about here is non POSIX

00:12:04,460 --> 00:12:26,340
it may be this how it's gonna ask are

00:12:22,140 --> 00:12:27,660
you dependent on a on a Priam party for

00:12:26,340 --> 00:12:33,240
either these you know you're you're

00:12:27,660 --> 00:12:35,220
liberal or told you know okay so so so

00:12:33,240 --> 00:12:37,650
to be speaking from a district

00:12:35,220 --> 00:12:39,900
perspective I mean I'm an RT guy but I

00:12:37,650 --> 00:12:42,110
also have to think about drill we

00:12:39,900 --> 00:12:45,810
probably need to add a live RTP i

00:12:42,110 --> 00:12:49,400
package I guess I would say that depends

00:12:45,810 --> 00:12:49,400
on the output of this discussion okay

00:13:06,790 --> 00:13:12,950
yeah so one question that I have is in

00:13:11,240 --> 00:13:15,980
reading the posix interpretation I do

00:13:12,950 --> 00:13:18,830
actually in this case believe that w3 is

00:13:15,980 --> 00:13:22,250
ineligible it is eligible to be woken up

00:13:18,830 --> 00:13:24,200
according to the spec but not as it's

00:13:22,250 --> 00:13:25,850
currently implemented ng loob C so that

00:13:24,200 --> 00:13:27,890
might be one potential Avenue we go down

00:13:25,850 --> 00:13:29,140
is is is it possible to implement a

00:13:27,890 --> 00:13:33,620
different scheme at Lavar TPI

00:13:29,140 --> 00:13:35,810
they can support that properly the

00:13:33,620 --> 00:13:37,220
answer yet my thought on that because

00:13:35,810 --> 00:13:39,830
since Julie and I met last I spent the

00:13:37,220 --> 00:13:44,530
last two hours reading the links up here

00:13:39,830 --> 00:13:50,450
I I think that the clarifying statement

00:13:44,530 --> 00:13:53,360
here is is intending to limit that

00:13:50,450 --> 00:13:57,230
interpretation to a specific ordering

00:13:53,360 --> 00:13:59,540
relative to signal whether it's pthread

00:13:57,230 --> 00:14:03,940
cond signal or pthread cond broadcast i

00:13:59,540 --> 00:14:03,940
would not say that this is cut and dry

00:14:04,450 --> 00:14:07,450
interpretation

00:14:11,240 --> 00:14:16,730
so I think a question is about expected

00:14:14,420 --> 00:14:20,629
behavior so if this was your real-time

00:14:16,730 --> 00:14:22,759
application at the time oh actually I

00:14:20,629 --> 00:14:24,970
take that back I'm sorry with respect to

00:14:22,759 --> 00:14:29,149
Julia's comment that s2 could wake up

00:14:24,970 --> 00:14:35,209
ww3 I agree it would be only whether or

00:14:29,149 --> 00:14:37,850
not s-1 could wake up w3 in the race

00:14:35,209 --> 00:14:40,459
condition that I specified earlier that

00:14:37,850 --> 00:14:41,389
I that's a violation so actually I take

00:14:40,459 --> 00:14:44,389
it back we're in agreement

00:14:41,389 --> 00:14:47,540
sorry so the question to the to the room

00:14:44,389 --> 00:14:50,269
is for a real-time application in which

00:14:47,540 --> 00:14:54,339
w3 is the highest priority task which

00:14:50,269 --> 00:14:54,339
waiter should s2 wake

00:15:00,570 --> 00:15:05,020
so Clark says w3 I would have picked the

00:15:03,910 --> 00:15:07,060
highest priority and I would have

00:15:05,020 --> 00:15:09,040
inserted it because it was higher than

00:15:07,060 --> 00:15:10,570
anybody in the waiting group I would

00:15:09,040 --> 00:15:13,270
have thought you'd have said Oh insert

00:15:10,570 --> 00:15:15,310
it in the waiting room because it is the

00:15:13,270 --> 00:15:17,230
highest higher priority than anybody

00:15:15,310 --> 00:15:27,490
that's eligible over there but it's just

00:15:17,230 --> 00:15:32,170
me what is what is it about group two

00:15:27,490 --> 00:15:37,570
that made it w3 ineligible because it it

00:15:32,170 --> 00:15:39,940
came after s1 s1 transitioned the the I

00:15:37,570 --> 00:15:42,640
don't the unendurable group into now

00:15:39,940 --> 00:15:44,589
become an eligible group right meaning

00:15:42,640 --> 00:15:46,330
that all the waiters after s1 are now

00:15:44,589 --> 00:15:48,010
being queued and the eligible is the

00:15:46,330 --> 00:15:49,750
state does that make sense

00:15:48,010 --> 00:15:52,570
it's an implementation detail with

00:15:49,750 --> 00:15:54,820
respect to the wake to the wake ordering

00:15:52,570 --> 00:15:56,740
of few Texas so they chose to use two

00:15:54,820 --> 00:16:00,420
different few text words and they use

00:15:56,740 --> 00:16:04,300
signal to break that grouping correct

00:16:00,420 --> 00:16:09,520
okay so let me reverse the question is

00:16:04,300 --> 00:16:15,160
there any reason why w2 would be or

00:16:09,520 --> 00:16:18,839
should be wait by s2 right so that's

00:16:15,160 --> 00:16:21,370
that that is also the the question I

00:16:18,839 --> 00:16:23,589
don't believe that the POSIX

00:16:21,370 --> 00:16:26,560
specification requires you to do so and

00:16:23,589 --> 00:16:28,990
our thinking is that from a real-time

00:16:26,560 --> 00:16:31,390
perspective we are all very comfortable

00:16:28,990 --> 00:16:33,400
with starving lower-priority things so

00:16:31,390 --> 00:16:35,620
there's not a fairness question here

00:16:33,400 --> 00:16:37,570
that we're really worried about this is

00:16:35,620 --> 00:16:39,670
what you know the FIFO scheduler is all

00:16:37,570 --> 00:16:41,980
about you schedule something at 5.99

00:16:39,670 --> 00:16:44,770
you're gonna starve things if you queue

00:16:41,980 --> 00:16:46,000
high priority tasks on con VARs all day

00:16:44,770 --> 00:16:49,690
long you're gonna starve the low

00:16:46,000 --> 00:16:50,589
priority ones and our our assertion is

00:16:49,690 --> 00:16:53,860
that that's okay

00:16:50,589 --> 00:16:57,430
so I think that the you know concerned

00:16:53,860 --> 00:17:01,950
here with waking up w2 first would be

00:16:57,430 --> 00:17:01,950
that it could introduce latency for

00:17:09,250 --> 00:17:18,430
because okay so what you're talking

00:17:14,770 --> 00:17:22,660
about is changing the rules for where

00:17:18,430 --> 00:17:24,040
are you cue the waiter correct you're

00:17:22,660 --> 00:17:27,579
talking about consulting the priority

00:17:24,040 --> 00:17:30,820
and we're mentioning that that this

00:17:27,579 --> 00:17:33,490
Liberty bi implementation is going to to

00:17:30,820 --> 00:17:34,870
order the waiters differently at least

00:17:33,490 --> 00:17:37,150
we're asserting that this was what Lib

00:17:34,870 --> 00:17:39,370
RTP I should do and we're checking with

00:17:37,150 --> 00:17:44,760
the room to ensure that you all feel the

00:17:39,370 --> 00:17:49,360
same way so basically if you link your

00:17:44,760 --> 00:17:51,910
code with Lib RTP I then do it changes

00:17:49,360 --> 00:17:54,400
the rules does it use the same interface

00:17:51,910 --> 00:17:57,880
basically or no we did end up changing

00:17:54,400 --> 00:18:00,160
the interface wrapper and we thought

00:17:57,880 --> 00:18:02,020
about trying to use LD preload we opted

00:18:00,160 --> 00:18:03,940
for this instead and one of the reasons

00:18:02,020 --> 00:18:06,010
is it's a great way to ensure that

00:18:03,940 --> 00:18:09,100
you've made the change because it won't

00:18:06,010 --> 00:18:10,960
compile otherwise so that's a good way

00:18:09,100 --> 00:18:12,880
to make sure you've caught everything it

00:18:10,960 --> 00:18:15,790
also eliminates the corner cases where

00:18:12,880 --> 00:18:19,540
you can do weird things with a beaut and

00:18:15,790 --> 00:18:26,650
so it narrows the specific use case

00:18:19,540 --> 00:18:36,820
which I think further specifies what

00:18:26,650 --> 00:18:39,460
we're trying to solve maybe from a

00:18:36,820 --> 00:18:44,170
system designer point of view looking

00:18:39,460 --> 00:18:46,210
into the real-time system say that why

00:18:44,170 --> 00:18:47,950
do we have two different threads

00:18:46,210 --> 00:18:50,710
different power everything on the same

00:18:47,950 --> 00:18:54,550
con Warren the carnival normally is

00:18:50,710 --> 00:18:55,990
notified by some server which means

00:18:54,550 --> 00:18:57,400
something is ready so the service

00:18:55,990 --> 00:19:00,810
provided something to them

00:18:57,400 --> 00:19:04,420
so if look into another place that

00:19:00,810 --> 00:19:06,400
shouldn't the different stress block are

00:19:04,420 --> 00:19:08,020
different the different threads with

00:19:06,400 --> 00:19:11,500
different priority plot on different

00:19:08,020 --> 00:19:13,660
cars so that we can have association of

00:19:11,500 --> 00:19:16,090
the server thread which will have

00:19:13,660 --> 00:19:18,600
several priority as the priority while

00:19:16,090 --> 00:19:22,740
at the sweater while waiting on calamari

00:19:18,600 --> 00:19:25,440
yeah otherwise because say a you have a

00:19:22,740 --> 00:19:28,289
three different priority threat waiting

00:19:25,440 --> 00:19:30,529
on the same car Navarre and what will be

00:19:28,289 --> 00:19:32,999
the priority of the silver thread I

00:19:30,529 --> 00:19:34,529
think it's a student desires item

00:19:32,999 --> 00:19:37,710
because it's different from a mutex

00:19:34,529 --> 00:19:40,559
Prada cartons which we wish you have a

00:19:37,710 --> 00:19:43,259
hierarchy but calm myself it's you to

00:19:40,559 --> 00:19:46,169
not hold anything the association

00:19:43,259 --> 00:19:49,470
between the waiter and the provider a

00:19:46,169 --> 00:19:56,789
kind of in the right I think it's a

00:19:49,470 --> 00:19:58,649
really good but I think from core sort

00:19:56,789 --> 00:20:01,289
of locking infrastructure and mechanism

00:19:58,649 --> 00:20:02,940
it's not the kind of thing if we were to

00:20:01,289 --> 00:20:04,950
make a statement about that we would be

00:20:02,940 --> 00:20:06,509
over specifying in addition to the POSIX

00:20:04,950 --> 00:20:08,249
standard and our goal here was to

00:20:06,509 --> 00:20:10,440
provide an underlying mechanism that you

00:20:08,249 --> 00:20:12,779
could use for whatever you choose to be

00:20:10,440 --> 00:20:15,269
your architecture yes so my point is not

00:20:12,779 --> 00:20:17,249
just say because I heard you guys to

00:20:15,269 --> 00:20:19,559
provide something which is not a

00:20:17,249 --> 00:20:21,480
positive compliant right now so the

00:20:19,559 --> 00:20:24,720
question would be that do we want to do

00:20:21,480 --> 00:20:28,279
that or do we want to a so we're in the

00:20:24,720 --> 00:20:28,279
Sicilian desire level

00:20:30,230 --> 00:20:37,110
yeah I think there's a like what Darren

00:20:33,030 --> 00:20:38,580
said I think there is a perhaps a

00:20:37,110 --> 00:20:39,960
reevaluation should be done at the

00:20:38,580 --> 00:20:41,640
application level to see whether or not

00:20:39,960 --> 00:20:43,350
con VARs is actually a suitable

00:20:41,640 --> 00:20:45,690
mechanism for synchronization and

00:20:43,350 --> 00:20:47,790
whether or not that can be avoided but

00:20:45,690 --> 00:20:49,860
there are applications in production

00:20:47,790 --> 00:20:52,740
right now that make use of conv ours and

00:20:49,860 --> 00:20:58,080
maybe unknowingly broken or maybe

00:20:52,740 --> 00:20:59,460
knowingly so but they need a way to you

00:20:58,080 --> 00:21:02,400
know be released from the Virgen

00:20:59,460 --> 00:21:04,020
constraint of the ogee Lipsy so we are

00:21:02,400 --> 00:21:07,440
running shy on time so I'm just gonna

00:21:04,020 --> 00:21:10,530
advance us to the last slide which maybe

00:21:07,440 --> 00:21:13,320
we'll just leave here wants to pull us

00:21:10,530 --> 00:21:15,510
off the stage but this is a little bit

00:21:13,320 --> 00:21:19,170
about future work the question marks are

00:21:15,510 --> 00:21:20,910
things where we're interested in input

00:21:19,170 --> 00:21:25,290
so feel free to type it into the ether

00:21:20,910 --> 00:21:26,850
pad or let us know and then the bottom

00:21:25,290 --> 00:21:31,310
two items are just things we know we

00:21:26,850 --> 00:21:31,310
need to implement and work on

00:21:36,900 --> 00:21:43,089
[Applause]

00:22:29,910 --> 00:22:40,180
okay so I'm have a small side project

00:22:36,070 --> 00:22:42,520
and I have a couple of questions on that

00:22:40,180 --> 00:22:45,070
and just present what the problem is so

00:22:42,520 --> 00:22:48,340
the background is we have application or

00:22:45,070 --> 00:22:51,790
one application which is using same

00:22:48,340 --> 00:22:54,490
almighty's at this moment and the reason

00:22:51,790 --> 00:22:56,680
is or the composition of the the project

00:22:54,490 --> 00:22:58,810
is you have an application and inside

00:22:56,680 --> 00:23:02,470
application there's fret one or two

00:22:58,810 --> 00:23:05,470
frets with real-time priority and the

00:23:02,470 --> 00:23:10,060
main problem we have is there those guys

00:23:05,470 --> 00:23:13,210
are using a few libraries and they're

00:23:10,060 --> 00:23:15,270
stacked and they don't know the internal

00:23:13,210 --> 00:23:19,150
details of those libraries which means

00:23:15,270 --> 00:23:20,980
if they call some function they might do

00:23:19,150 --> 00:23:25,690
something which is not really good for

00:23:20,980 --> 00:23:29,890
real time so and mixing on my case it's

00:23:25,690 --> 00:23:31,980
the system is working in this way that

00:23:29,890 --> 00:23:35,440
you have two schedulers basically and

00:23:31,980 --> 00:23:38,560
your real time thread is running in the

00:23:35,440 --> 00:23:40,750
real time domain and as soon as you do

00:23:38,560 --> 00:23:43,720
something calling something which this

00:23:40,750 --> 00:23:45,430
real time domain can't provide it will

00:23:43,720 --> 00:23:48,190
be transferred to the other schedule is

00:23:45,430 --> 00:23:49,930
that a normal linux ID and this transfer

00:23:48,190 --> 00:23:53,770
if you transfer this fret from one

00:23:49,930 --> 00:23:57,490
context to another one you get an a

00:23:53,770 --> 00:23:59,770
signal and or you can configure you get

00:23:57,490 --> 00:24:02,680
a signal associated my first stack trace

00:23:59,770 --> 00:24:05,320
and this is a very very useful debug

00:24:02,680 --> 00:24:08,920
tool for those guys because they find

00:24:05,320 --> 00:24:11,470
out basically okay I'm doing stuff and

00:24:08,920 --> 00:24:12,370
I'm calling this function and okay this

00:24:11,470 --> 00:24:16,600
is not okay

00:24:12,370 --> 00:24:19,480
and so the thing is they would like to

00:24:16,600 --> 00:24:23,140
transfer port the application to preempt

00:24:19,480 --> 00:24:25,870
RT but at this point they really like

00:24:23,140 --> 00:24:29,470
this feature they really want that and I

00:24:25,870 --> 00:24:31,390
was thinking about how how to emulate

00:24:29,470 --> 00:24:32,590
this with the current means we have in

00:24:31,390 --> 00:24:46,309
the current

00:24:32,590 --> 00:24:50,720
it's purely debugging so it's purely

00:24:46,309 --> 00:24:54,470
debugging you might use the tracer and

00:24:50,720 --> 00:25:00,770
never actually do some there's some some

00:24:54,470 --> 00:25:06,860
better conditionals BPF yeah that's the

00:25:00,770 --> 00:25:25,940
title of a segue yeah okay okay let's

00:25:06,860 --> 00:25:41,419
skip that one that's your purpose you

00:25:25,940 --> 00:25:43,370
proposed that title you know that yeah

00:25:41,419 --> 00:25:48,980
so what I did was basically I attached

00:25:43,370 --> 00:25:52,640
the sis call trace point and added a

00:25:48,980 --> 00:25:54,890
small PPF which checks the fret ID and

00:25:52,640 --> 00:25:57,289
if it's the one I'm interested in I do

00:25:54,890 --> 00:26:03,260
like looking at the resources and the

00:25:57,289 --> 00:26:06,679
thing is the previous slide was it's the

00:26:03,260 --> 00:26:09,110
sis calls are not black white thing to

00:26:06,679 --> 00:26:12,350
decide sometimes it's okay to call one

00:26:09,110 --> 00:26:14,390
which might sleep and sometimes not you

00:26:12,350 --> 00:26:16,580
can't decide that basically just on the

00:26:14,390 --> 00:26:19,750
Sisqo level and obviously there are

00:26:16,580 --> 00:26:22,690
resources where you might

00:26:19,750 --> 00:26:24,520
can access during setup face very easily

00:26:22,690 --> 00:26:26,710
and then later you shouldn't do anything

00:26:24,520 --> 00:26:28,210
else of just one file script is okay to

00:26:26,710 --> 00:26:31,000
read and write but the other one don't

00:26:28,210 --> 00:26:33,070
do that that might be something so it's

00:26:31,000 --> 00:26:35,830
it's the thing is what that means you

00:26:33,070 --> 00:26:39,130
can't which brings me to that slide

00:26:35,830 --> 00:26:43,180
basically with PPF currently at this

00:26:39,130 --> 00:26:46,570
point you have to write items with

00:26:43,180 --> 00:26:49,480
really low level means program which

00:26:46,570 --> 00:26:51,610
likes no fun at all or you use the tool

00:26:49,480 --> 00:26:53,980
chain to build your program and then

00:26:51,610 --> 00:26:59,040
load it to the kernel but currently the

00:26:53,980 --> 00:27:04,680
tool chain is working for x86 and I'm 64

00:26:59,040 --> 00:27:08,640
any device like I'm 32 bits won't work

00:27:04,680 --> 00:27:10,900
at this point yes I don't know

00:27:08,640 --> 00:27:20,190
architecture I mean I don't care about

00:27:10,900 --> 00:27:23,590
them right now but but thing you said

00:27:20,190 --> 00:27:28,000
you know whether they read or write

00:27:23,590 --> 00:27:28,690
operation is actually safe or not so

00:27:28,000 --> 00:27:34,420
Howard

00:27:28,690 --> 00:27:36,640
how the hell does same I know that yeah

00:27:34,420 --> 00:27:43,240
so there's it's not perfectly that as

00:27:36,640 --> 00:27:46,240
well so they do not catch all cases but

00:27:43,240 --> 00:27:49,960
what they can they know basically when

00:27:46,240 --> 00:27:52,120
they need help access basically outside

00:27:49,960 --> 00:27:53,950
of their domain so they have some

00:27:52,120 --> 00:27:57,130
internal stuff down I don't know the

00:27:53,950 --> 00:27:58,960
details okay and as soon as they they

00:27:57,130 --> 00:28:01,240
know okay we need to properly UNIX

00:27:58,960 --> 00:28:06,520
environment to do something and they

00:28:01,240 --> 00:28:08,530
switch out well we could do is if we

00:28:06,520 --> 00:28:11,950
have tracer points I mean one thing is

00:28:08,530 --> 00:28:15,280
or we could hook into what we talked at

00:28:11,950 --> 00:28:18,490
in Edinburgh about things like the right

00:28:15,280 --> 00:28:20,950
if you grab a writer lock which we said

00:28:18,490 --> 00:28:22,780
a writer lock has no pie I mean well I

00:28:20,950 --> 00:28:26,530
mean the API among writer locks but they

00:28:22,780 --> 00:28:28,120
could be stuck unbounded for us from

00:28:26,530 --> 00:28:29,110
readers so that's something you never

00:28:28,120 --> 00:28:30,370
want to do you never want to call a

00:28:29,110 --> 00:28:32,380
writer talk well if we could put in a

00:28:30,370 --> 00:28:32,960
trace point or something or a Facebook

00:28:32,380 --> 00:28:35,059
impact

00:28:32,960 --> 00:28:37,039
that if it's you know you hook it there

00:28:35,059 --> 00:28:38,149
so and then actually have a module so

00:28:37,039 --> 00:28:40,820
you don't have to worry about this will

00:28:38,149 --> 00:28:43,850
work on my own across all architectures

00:28:40,820 --> 00:28:45,740
you hit write write lock key check see

00:28:43,850 --> 00:28:46,490
is this task a real-time task and

00:28:45,740 --> 00:28:48,350
doesn't want to do this

00:28:46,490 --> 00:28:51,020
boom send a signal right so sort of

00:28:48,350 --> 00:28:54,260
thing the main problem I currently see

00:28:51,020 --> 00:28:56,090
with all this war PPF solves right now

00:28:54,260 --> 00:28:59,649
is that you can have this kind of

00:28:56,090 --> 00:29:03,140
condition when you want to send a signal

00:28:59,649 --> 00:29:05,539
built depending on your application so

00:29:03,140 --> 00:29:07,610
if you have F trace or anything running

00:29:05,539 --> 00:29:12,020
either you consume all the data and have

00:29:07,610 --> 00:29:13,669
to do the processing know exactly you

00:29:12,020 --> 00:29:16,820
can actually inject also you have a

00:29:13,669 --> 00:29:20,179
trigger so the trigger on a condition

00:29:16,820 --> 00:29:24,399
yeah but how how complex can you make

00:29:20,179 --> 00:29:24,399
that condition pretty complex okay

00:29:27,490 --> 00:29:34,250
that's purely a mechanism problem don't

00:29:31,640 --> 00:29:37,880
worry about the mechanism or more worry

00:29:34,250 --> 00:29:44,779
about the semantics okay so where do you

00:29:37,880 --> 00:29:48,289
put your your trace points in or can you

00:29:44,779 --> 00:29:50,990
reuse existing ones and sufficiently in

00:29:48,289 --> 00:29:53,990
the cover of the cases you care about

00:29:50,990 --> 00:29:57,529
yeah I think at the very end whether you

00:29:53,990 --> 00:30:01,520
need whether you use BPF for whatever

00:29:57,529 --> 00:30:04,640
other random mechanism that's pure

00:30:01,520 --> 00:30:05,360
implementation detail that's all about

00:30:04,640 --> 00:30:08,059
you

00:30:05,360 --> 00:30:11,620
also the to chain thing is solvable so

00:30:08,059 --> 00:30:16,549
the the main problem is that you want to

00:30:11,620 --> 00:30:20,270
have a well-defined semantical list of

00:30:16,549 --> 00:30:24,649
conditions where you say this should

00:30:20,270 --> 00:30:26,980
trigger yeah that's if you want to

00:30:24,649 --> 00:30:30,590
extend it is something like read write

00:30:26,980 --> 00:30:35,110
and then differentiate between actually

00:30:30,590 --> 00:30:35,110
dangerous rate and safe read

00:30:35,600 --> 00:30:43,970
yeah that's going to be tough grabbing

00:30:41,570 --> 00:30:46,340
the reader lock is that dangerous I mean

00:30:43,970 --> 00:30:48,650
is it it's the reader block or the

00:30:46,340 --> 00:30:50,090
readers it's they could starve a writer

00:30:48,650 --> 00:30:51,620
it's not fair

00:30:50,090 --> 00:30:56,900
so if a writer is waiting do readers

00:30:51,620 --> 00:31:02,110
block write problematic side is to write

00:30:56,900 --> 00:31:05,660
aside if you're a reader and the writer

00:31:02,110 --> 00:31:08,300
is holding the lock then you boost the

00:31:05,660 --> 00:31:11,390
writer yeah and get it out of the way I

00:31:08,300 --> 00:31:12,950
mean they still can be problematic if

00:31:11,390 --> 00:31:22,340
the right eye is actually sleeping on

00:31:12,950 --> 00:31:37,370
something else which might happen yeah

00:31:22,340 --> 00:31:51,320
that's that's bad luck you always can

00:31:37,370 --> 00:31:54,680
say so so if there's doubt you know this

00:31:51,320 --> 00:31:56,570
is a fuzzy system call are we going to

00:31:54,680 --> 00:32:00,350
be overwhelmed with false positives if

00:31:56,570 --> 00:32:02,150
we just send the signal one thing is you

00:32:00,350 --> 00:32:04,400
probably what you can do or what we can

00:32:02,150 --> 00:32:06,380
do right now is you have a set up phase

00:32:04,400 --> 00:32:08,240
where you allocate your resources and

00:32:06,380 --> 00:32:11,780
you know which one you want to talk to

00:32:08,240 --> 00:32:14,810
you and then you basically tell okay

00:32:11,780 --> 00:32:17,570
these file descriptors are safe to to

00:32:14,810 --> 00:32:19,490
read and write you and if you call read

00:32:17,570 --> 00:32:22,120
to anything else and all the did file

00:32:19,490 --> 00:32:25,640
script you just say oh that's not good

00:32:22,120 --> 00:32:27,560
yeah but it's then you need need

00:32:25,640 --> 00:32:30,410
application indirection

00:32:27,560 --> 00:32:33,640
yeah that's because you have to figure

00:32:30,410 --> 00:32:33,640
out the file descriptors

00:32:37,039 --> 00:32:45,239
because the file descriptors very

00:32:40,440 --> 00:32:49,799
actually think they are safe or usually

00:32:45,239 --> 00:32:53,820
specialty buys files well for your magic

00:32:49,799 --> 00:32:58,889
custom driver or something like that so

00:32:53,820 --> 00:33:05,879
you could do it the other way around and

00:32:58,889 --> 00:33:10,070
say you trace the whole thing and you

00:33:05,879 --> 00:33:17,239
just get events for into the into your

00:33:10,070 --> 00:33:21,239
magic supervisor application yeah on

00:33:17,239 --> 00:33:23,909
open because without me you get the pass

00:33:21,239 --> 00:33:26,100
and on the return from you get the file

00:33:23,909 --> 00:33:31,259
descriptor number so you can do the

00:33:26,100 --> 00:33:35,429
Association based on the on the path and

00:33:31,259 --> 00:33:37,379
and then you get whatever for deaf magic

00:33:35,429 --> 00:33:40,409
you get file descriptor seven and they

00:33:37,379 --> 00:33:44,159
say everything except seven is going to

00:33:40,409 --> 00:33:46,019
throw a signal okay so that might be but

00:33:44,159 --> 00:33:47,549
how do you pass that information I mean

00:33:46,019 --> 00:33:49,259
the applications running how do you like

00:33:47,549 --> 00:33:53,299
to open that means this BPF or

00:33:49,259 --> 00:33:53,299
mechanisms have a thing of transferring

00:33:58,730 --> 00:34:10,619
so BPF has internal storage right so for

00:34:09,270 --> 00:34:12,929
example we can use the filesystem

00:34:10,619 --> 00:34:14,369
backing device right and if you know you

00:34:12,929 --> 00:34:15,990
are accessing a particular file system

00:34:14,369 --> 00:34:18,929
and it is not a tempest or something

00:34:15,990 --> 00:34:21,149
you're obviously going to block yeah but

00:34:18,929 --> 00:34:28,500
you can't you don't have that

00:34:21,149 --> 00:34:31,020
information at the Cisco level but

00:34:28,500 --> 00:34:34,350
basically the file system open can

00:34:31,020 --> 00:34:35,520
probably check that right so it doesn't

00:34:34,350 --> 00:34:37,109
have to be at this is called level right

00:34:35,520 --> 00:34:38,909
I mean I don't know about beefier don't

00:34:37,109 --> 00:34:40,950
look at from the BPF perspective or

00:34:38,909 --> 00:34:42,570
generic perspective today we have a lot

00:34:40,950 --> 00:34:45,030
of warnings in the kernel right

00:34:42,570 --> 00:34:47,070
similarly like for example if it's a RT

00:34:45,030 --> 00:34:50,040
task and if it is going to block we can

00:34:47,070 --> 00:34:52,440
have some some yeah but then you have to

00:34:50,040 --> 00:34:53,010
spring click that debug stuff all over

00:34:52,440 --> 00:34:57,780
the place

00:34:53,010 --> 00:34:59,880
it's I think you can actually do it at

00:34:57,780 --> 00:35:02,010
the Cisco level because you can n BPF

00:34:59,880 --> 00:35:03,840
translate a file descriptor to the

00:35:02,010 --> 00:35:08,510
struct file and store files all that

00:35:03,840 --> 00:35:08,510
crap in right

00:35:08,820 --> 00:35:13,390
yeah don't just look at the debugging

00:35:11,530 --> 00:35:16,600
perspective also if this is useful in

00:35:13,390 --> 00:35:47,680
other applications also right you catch

00:35:16,600 --> 00:35:49,570
the points I feel like we like we're

00:35:47,680 --> 00:35:52,030
gonna suck up on the the file IO portion

00:35:49,570 --> 00:35:53,620
of this call space but there are other

00:35:52,030 --> 00:35:55,750
system calls that are that might also be

00:35:53,620 --> 00:35:57,280
problematic for RT like the positive CPU

00:35:55,750 --> 00:36:01,000
timers and like all sorts of other and

00:35:57,280 --> 00:36:03,610
say things yeah of course I mean if you

00:36:01,000 --> 00:36:06,310
start the whole debugging thing you have

00:36:03,610 --> 00:36:08,910
to define which system cause you

00:36:06,310 --> 00:36:14,830
couldn't see the safe sure and

00:36:08,910 --> 00:36:19,840
everything else is unsafe like the point

00:36:14,830 --> 00:36:26,890
everything is unsafe that's gonna be a

00:36:19,840 --> 00:36:28,420
lot of warnings not just basically

00:36:26,890 --> 00:36:30,340
finding a way to say okay if you've come

00:36:28,420 --> 00:36:35,860
up with a new thing how easy is it to

00:36:30,340 --> 00:36:37,810
add a new test case I guess that's where

00:36:35,860 --> 00:36:41,340
you've had trouble is like the

00:36:37,810 --> 00:36:41,340
simplicity of basically adding

00:36:43,670 --> 00:36:46,950
maybe just say oh it's just a

00:36:45,450 --> 00:36:49,440
fermentation detail but it can be done

00:36:46,950 --> 00:36:53,370
but having the mechanism that can easily

00:36:49,440 --> 00:36:55,650
add new test cases right and that's why

00:36:53,370 --> 00:36:57,840
I think you know I'm not sure Elizabeth

00:36:55,650 --> 00:36:59,310
a life where we just look into the cold

00:36:57,840 --> 00:37:01,410
gas and there's trace points that we get

00:36:59,310 --> 00:37:03,210
attached to and say this is triggered by

00:37:01,410 --> 00:37:04,520
this guy she might be able to trade it

00:37:03,210 --> 00:37:06,780
right away

00:37:04,520 --> 00:37:08,790
Donna Depot is called why are we stuck

00:37:06,780 --> 00:37:10,310
at just looking at system calls since

00:37:08,790 --> 00:37:12,690
there's trace points all over the car

00:37:10,310 --> 00:37:22,230
yeah the question is are they in the

00:37:12,690 --> 00:37:30,300
right places they might every guys find

00:37:22,230 --> 00:37:34,860
a patch of code okay

00:37:30,300 --> 00:37:37,800
that's basically all and I mean that's

00:37:34,860 --> 00:37:40,220
obviously just for syscalls eventually

00:37:37,800 --> 00:37:46,530
want to do also like chillip see

00:37:40,220 --> 00:37:51,660
interfaces like malloc and so on you

00:37:46,530 --> 00:37:53,670
probably put just in yeah but you can do

00:37:51,660 --> 00:37:55,880
you probes on that yeah that's what's

00:37:53,670 --> 00:37:59,390
the idea that's why I would like to go

00:37:55,880 --> 00:37:59,390
further with that

00:38:05,500 --> 00:38:15,200
yeah you can do you probes with EVPs so

00:38:11,980 --> 00:38:17,680
one thing which was a case is kind of

00:38:15,200 --> 00:38:22,690
because it's a very fast-moving target

00:38:17,680 --> 00:38:26,119
documentation is far behind the co-pays

00:38:22,690 --> 00:38:28,250
Daniel portmanteau has written up a lot

00:38:26,119 --> 00:38:30,829
of the documentation side so it should

00:38:28,250 --> 00:38:33,020
be get better I had a hard time to get

00:38:30,829 --> 00:38:35,750
the signals are out

00:38:33,020 --> 00:38:41,329
we are perf it was very interesting

00:38:35,750 --> 00:38:43,460
problem and then I I did some

00:38:41,329 --> 00:38:46,299
measurements on my machine I mean can

00:38:43,460 --> 00:38:46,299
show that maybe

00:38:49,770 --> 00:38:58,170
so what you see here is histogram the

00:38:54,540 --> 00:39:02,460
the blue one left is just a system call

00:38:58,170 --> 00:39:05,369
I think it's get timer ID and you see it

00:39:02,460 --> 00:39:07,980
takes I don't know 270 micro nano

00:39:05,369 --> 00:39:11,910
seconds and the distribution as you can

00:39:07,980 --> 00:39:14,400
see it's very tight so it's I really had

00:39:11,910 --> 00:39:18,650
very fast access and then it just

00:39:14,400 --> 00:39:24,080
enabled the trace point this is the

00:39:18,650 --> 00:39:28,890
yellow one or orange one and it was 200

00:39:24,080 --> 00:39:31,200
and I'm 349 a seconds per call so this

00:39:28,890 --> 00:39:36,690
is just the overhead you get if you

00:39:31,200 --> 00:39:38,520
enable the trace point and if this is

00:39:36,690 --> 00:39:41,850
all in a tight loop everything and

00:39:38,520 --> 00:39:44,490
disable it and and you know if you have

00:39:41,850 --> 00:39:47,400
a normal system running its way over the

00:39:44,490 --> 00:39:49,530
distribution is you can't really read

00:39:47,400 --> 00:39:53,430
anything from that anymore and then when

00:39:49,530 --> 00:39:57,720
a date is the red one was attaching

00:39:53,430 --> 00:40:02,580
basically to desist call entry so this

00:39:57,720 --> 00:40:06,150
was just reading with F trace stuff out

00:40:02,580 --> 00:40:11,310
and and then I compared what happens if

00:40:06,150 --> 00:40:14,310
I have a big big larger BPF this is the

00:40:11,310 --> 00:40:17,760
green the last one this was with 390

00:40:14,310 --> 00:40:21,240
instructions and you can do the math and

00:40:17,760 --> 00:40:24,180
you figure out it's about one cycle in

00:40:21,240 --> 00:40:25,830
per se per instruction i you need four

00:40:24,180 --> 00:40:32,070
for PBF which makes kind of sense

00:40:25,830 --> 00:40:33,510
because I try not to hook calls because

00:40:32,070 --> 00:40:35,730
the system calls when you enable

00:40:33,510 --> 00:40:37,950
assisting well event it goes to slow

00:40:35,730 --> 00:40:41,130
path that I mean system calls aren't

00:40:37,950 --> 00:40:42,960
traced they have the P trace trampoline

00:40:41,130 --> 00:40:44,820
that you know when it goes when you

00:40:42,960 --> 00:40:46,560
enter from its system call or exit it

00:40:44,820 --> 00:40:48,450
says oh we have work will jump and do

00:40:46,560 --> 00:40:49,920
this all extra work before so there's an

00:40:48,450 --> 00:40:51,150
overhead I mean that first yellow thing

00:40:49,920 --> 00:40:53,760
is probably just the overhead of the P

00:40:51,150 --> 00:40:55,800
trace yeah jump enabling yeah exactly

00:40:53,760 --> 00:40:57,780
this yes you see the slow path here yeah

00:40:55,800 --> 00:41:00,590
yeah so that's why I'm seeing if we are

00:40:57,780 --> 00:41:00,590
injecting inside

00:41:00,680 --> 00:41:13,609
you at least lose that large jump and

00:41:04,790 --> 00:41:24,980
maybe a little speed noise of the extra

00:41:13,609 --> 00:41:30,260
trampoline industries coal is just the

00:41:24,980 --> 00:41:32,510
PPF was attached at the green yes yeah

00:41:30,260 --> 00:41:36,140
the Greens the green is with the 300 the

00:41:32,510 --> 00:41:38,809
instruction of 400 instruction and the

00:41:36,140 --> 00:41:43,220
yellow one was with two instructions are

00:41:38,809 --> 00:41:46,369
and the red one is if I'm using F trace

00:41:43,220 --> 00:41:52,190
to print into the buffer so after a

00:41:46,369 --> 00:41:56,150
string buffer yeah this so at one use

00:41:52,190 --> 00:41:59,270
you get basically the printf overhead in

00:41:56,150 --> 00:42:07,250
you see creating the string which is

00:41:59,270 --> 00:42:09,230
expensive string so this is this is

00:42:07,250 --> 00:42:11,030
basically choose the BPF enabling

00:42:09,230 --> 00:42:15,910
without and doing anything this was just

00:42:11,030 --> 00:42:20,869
returned so go into the BPF and return

00:42:15,910 --> 00:42:25,880
the blue one is just the anymore just

00:42:20,869 --> 00:42:27,980
without anything but you neither really

00:42:25,880 --> 00:42:32,410
need are using the signal to err

00:42:27,980 --> 00:42:37,369
signaling that user space or just was a

00:42:32,410 --> 00:42:39,880
tracing and check the data afterwards so

00:42:37,369 --> 00:42:43,250
at that point it's not important to be

00:42:39,880 --> 00:42:45,140
fast reporting I mean if it comes a bit

00:42:43,250 --> 00:42:46,849
later delayed it doesn't matter I mean

00:42:45,140 --> 00:42:49,040
you just need to get information okay

00:42:46,849 --> 00:42:51,980
you did this is the trace you get tell

00:42:49,040 --> 00:42:53,869
them something which is not correct so I

00:42:51,980 --> 00:42:57,410
don't care that point if it's a signal

00:42:53,869 --> 00:43:00,950
or in that case you can maybe you can

00:42:57,410 --> 00:43:04,400
put the trace point or some events in

00:43:00,950 --> 00:43:09,110
there broking found function and just

00:43:04,400 --> 00:43:11,900
dump their stuff you know

00:43:09,110 --> 00:43:15,710
Colonel Stark and the user stuck in a

00:43:11,900 --> 00:43:17,630
tracing buffer yeah that would be enough

00:43:15,710 --> 00:43:20,060
yeah you're checking yeah basically

00:43:17,630 --> 00:43:23,930
that's what you get if you have the PPF

00:43:20,060 --> 00:43:27,350
and you can call Fink can't remember the

00:43:23,930 --> 00:43:30,470
function anyway it just dumps that stack

00:43:27,350 --> 00:43:34,160
trace into the ring buffer which is very

00:43:30,470 --> 00:43:35,960
handy I mean from from the interface and

00:43:34,160 --> 00:43:38,300
everything it's it's the thing I want to

00:43:35,960 --> 00:43:41,080
have but I really got annoyed by this

00:43:38,300 --> 00:43:44,420
tooling situation for userland

00:43:41,080 --> 00:43:47,330
but if but if it's if it's the right

00:43:44,420 --> 00:43:51,580
decision right the way to go okay I

00:43:47,330 --> 00:43:54,500
gonna fix that thing basically the

00:43:51,580 --> 00:44:08,480
result of this discussion years continue

00:43:54,500 --> 00:44:15,680
yeah that's I wanted to to check if fix

00:44:08,480 --> 00:44:18,370
that fix the tooling you've got a word

00:44:15,680 --> 00:44:18,370
package now

00:44:21,520 --> 00:44:28,929
[Applause]

00:44:31,120 --> 00:44:50,930
you win with the smallest computer now

00:44:49,580 --> 00:44:54,520
we're working now we're changing the

00:44:50,930 --> 00:44:54,520
conference speed data analyses

00:45:03,819 --> 00:45:06,819
right

00:45:07,520 --> 00:45:12,750
yeah but by the way Julie by the way

00:45:10,380 --> 00:45:14,580
just I have trouble I can't really right

00:45:12,750 --> 00:45:16,380
thing because my computer's being used

00:45:14,580 --> 00:45:18,720
to feature pads so anyone else could

00:45:16,380 --> 00:45:27,050
write notes because well I was writing

00:45:18,720 --> 00:45:27,050
notes and now I eat the pads right there

00:45:36,740 --> 00:45:41,670
okay so I'm on the hook to talk about

00:45:39,599 --> 00:45:43,080
some data analysis I've done on jitter

00:45:41,670 --> 00:45:46,770
so I guess I should give you some

00:45:43,080 --> 00:45:48,240
background about a year ago I had an

00:45:46,770 --> 00:45:51,590
issue that I was running into at our

00:45:48,240 --> 00:45:54,930
company that many practitioners use of

00:45:51,590 --> 00:45:57,990
premium tarty and and in general and

00:45:54,930 --> 00:46:00,390
peer achill real-time have an issue

00:45:57,990 --> 00:46:05,369
where it's like how much testing do I

00:46:00,390 --> 00:46:07,680
have to do before I can say with some

00:46:05,369 --> 00:46:09,960
degree of satisfaction or certainty that

00:46:07,680 --> 00:46:14,160
we only observe worst case execution

00:46:09,960 --> 00:46:16,200
latency is above a certain value and so

00:46:14,160 --> 00:46:17,790
you could run a test you can like give

00:46:16,200 --> 00:46:19,589
it all the loads give it pathological

00:46:17,790 --> 00:46:21,869
load scenarios run a cyclic test for

00:46:19,589 --> 00:46:23,580
like you know days but is that is that

00:46:21,869 --> 00:46:24,859
good enough you'll get a result out of

00:46:23,580 --> 00:46:27,060
that you'll get a map and maximum

00:46:24,859 --> 00:46:30,180
latency is that gonna be is that gonna

00:46:27,060 --> 00:46:33,450
be good enough so what I set out to do

00:46:30,180 --> 00:46:34,800
is to explore in the statistical area

00:46:33,450 --> 00:46:37,440
are there tools out there that could be

00:46:34,800 --> 00:46:41,520
used such that I could make stronger

00:46:37,440 --> 00:46:43,470
guarantees using some some formal

00:46:41,520 --> 00:46:46,380
statistical methods so how many of you

00:46:43,470 --> 00:46:48,680
were in Daniel bris Todd's talk okay

00:46:46,380 --> 00:46:51,420
well I imagine a lot of you so he

00:46:48,680 --> 00:46:54,150
mentioned a form of analysis called

00:46:51,420 --> 00:46:58,800
extreme value analysis so extreme value

00:46:54,150 --> 00:47:01,310
analysis in a nutshell is if it is an

00:46:58,800 --> 00:47:03,720
ALICE aswer by if you are taking a

00:47:01,310 --> 00:47:06,480
collection of samples from a

00:47:03,720 --> 00:47:09,180
distribution of unknown shape and size

00:47:06,480 --> 00:47:10,650
and those samples are independent from

00:47:09,180 --> 00:47:13,830
one another and identically distributed

00:47:10,650 --> 00:47:18,310
and you take a collection of those in

00:47:13,830 --> 00:47:20,140
samples and then you look at the extrema

00:47:18,310 --> 00:47:21,430
and you capture that and you do that

00:47:20,140 --> 00:47:23,530
over and over again you collect in

00:47:21,430 --> 00:47:24,700
samples and you look at the the extrema

00:47:23,530 --> 00:47:27,280
value so in this case you would look

00:47:24,700 --> 00:47:29,110
like the worst case execution latency so

00:47:27,280 --> 00:47:31,390
commonly in cyclic test this would be

00:47:29,110 --> 00:47:33,520
like I run cyclic test for an hour it

00:47:31,390 --> 00:47:34,650
collects a lot of samples and then I

00:47:33,520 --> 00:47:37,150
look at them worst case execution

00:47:34,650 --> 00:47:39,160
latency so what if extreme value

00:47:37,150 --> 00:47:42,910
analysis allows you to do is actually

00:47:39,160 --> 00:47:45,160
describe the distribution of those

00:47:42,910 --> 00:47:47,470
extremists and there's a there's a

00:47:45,160 --> 00:47:50,350
central notion in statistics that like

00:47:47,470 --> 00:47:52,300
says that regardless of the original the

00:47:50,350 --> 00:47:54,100
originating distribution that you are

00:47:52,300 --> 00:47:56,140
sampling from there are three

00:47:54,100 --> 00:47:58,270
well-defined distributions of the

00:47:56,140 --> 00:48:00,610
extremists collected by a collection of

00:47:58,270 --> 00:48:02,950
samples from that so it's kind of a

00:48:00,610 --> 00:48:04,240
compelling about this and I was like

00:48:02,950 --> 00:48:07,210
this is like super compelling this is

00:48:04,240 --> 00:48:09,010
kind of what I want and so I wanted to

00:48:07,210 --> 00:48:11,830
show you a little bit about where this

00:48:09,010 --> 00:48:13,900
kind of analysis has been used so one

00:48:11,830 --> 00:48:16,150
way that this is actually used as for

00:48:13,900 --> 00:48:18,010
City Planning and particularly like

00:48:16,150 --> 00:48:20,740
disrupted describing infrastructure for

00:48:18,010 --> 00:48:22,690
flooding so you know we have all this

00:48:20,740 --> 00:48:24,370
historical record about how often it

00:48:22,690 --> 00:48:26,410
rains of what the peak flow of rain is

00:48:24,370 --> 00:48:28,450
and so you can take all that data that

00:48:26,410 --> 00:48:31,120
you've collected over the many years you

00:48:28,450 --> 00:48:32,500
can fit it to a one of these three

00:48:31,120 --> 00:48:35,350
classes of distributions

00:48:32,500 --> 00:48:37,300
according to extreme value analysis and

00:48:35,350 --> 00:48:39,340
then so that's kind of what this shows

00:48:37,300 --> 00:48:41,740
here so this is called a return level

00:48:39,340 --> 00:48:43,870
plot so how many of you ever heard of

00:48:41,740 --> 00:48:45,820
like a hundred year flood it kind of

00:48:43,870 --> 00:48:47,980
comes from from this notion right you

00:48:45,820 --> 00:48:49,300
can fit to this distribution and you can

00:48:47,980 --> 00:48:51,370
actually look out in the future and see

00:48:49,300 --> 00:48:54,100
okay how often would I expect to see a

00:48:51,370 --> 00:48:56,230
flood of this magnitude and so this is

00:48:54,100 --> 00:49:00,070
some example data I pull to the Y the y

00:48:56,230 --> 00:49:01,780
axis is like a peak a peak observed flow

00:49:00,070 --> 00:49:04,150
rate of water maybe in the channel or

00:49:01,780 --> 00:49:06,010
something and on the x-axis you have a

00:49:04,150 --> 00:49:08,590
number of years you can see like okay

00:49:06,010 --> 00:49:10,990
after about a hundred years the point

00:49:08,590 --> 00:49:12,640
estimate would show that you would

00:49:10,990 --> 00:49:15,820
expect to see over a course of a hundred

00:49:12,640 --> 00:49:17,800
years you should see a max of 350 I

00:49:15,820 --> 00:49:19,150
think it's like cubic meters per second

00:49:17,800 --> 00:49:20,920
or something

00:49:19,150 --> 00:49:22,600
so this looked really compelling to me

00:49:20,920 --> 00:49:24,130
for a variety of reasons one of which is

00:49:22,600 --> 00:49:25,270
I would like to see a similar plot when

00:49:24,130 --> 00:49:27,460
it comes to like worst case execution

00:49:25,270 --> 00:49:31,630
later latency is priam to RT and

00:49:27,460 --> 00:49:34,270
secondly there is a confidence in a

00:49:31,630 --> 00:49:36,430
in this built into the model the model

00:49:34,270 --> 00:49:38,140
fitting gives you an estimation of the

00:49:36,430 --> 00:49:40,450
parameters of this fifth distribution

00:49:38,140 --> 00:49:42,400
and and so I want to be able to

00:49:40,450 --> 00:49:43,869
confidently say maybe it was like a 95%

00:49:42,400 --> 00:49:47,650
confidence interval that in a hundred

00:49:43,869 --> 00:49:52,059
years you will see anywhere between 250

00:49:47,650 --> 00:49:55,960
to you know 450 cubic meters per second

00:49:52,059 --> 00:49:58,180
so how the dots could actually be lower

00:49:55,960 --> 00:49:59,799
later the longer it is because if you

00:49:58,180 --> 00:50:01,690
think of it we didn't click 200 years is

00:49:59,799 --> 00:50:04,210
lower than the 100 years you would think

00:50:01,690 --> 00:50:05,349
that hey yeah that's a good question I

00:50:04,210 --> 00:50:08,530
don't know that I'm prepared to answer

00:50:05,349 --> 00:50:10,510
that but I yeah I don't know that's a

00:50:08,530 --> 00:50:13,150
good question

00:50:10,510 --> 00:50:14,619
so I looked at this and I said wow this

00:50:13,150 --> 00:50:17,140
is this is like a really compelling

00:50:14,619 --> 00:50:18,730
thing and you know it would be really

00:50:17,140 --> 00:50:20,619
nice if I could tell our customers who

00:50:18,730 --> 00:50:22,210
are largely controlled control system

00:50:20,619 --> 00:50:25,210
people that like to go crazy in their

00:50:22,210 --> 00:50:27,039
control engineering side that I could

00:50:25,210 --> 00:50:29,109
like give them here's the the

00:50:27,039 --> 00:50:31,030
distribution that we fit and here's what

00:50:29,109 --> 00:50:32,319
you can expect and so therefore you can

00:50:31,030 --> 00:50:37,210
design your control algorithm

00:50:32,319 --> 00:50:39,369
accordingly so here's here's what I did

00:50:37,210 --> 00:50:41,410
so I have I have a test rack and I

00:50:39,369 --> 00:50:44,289
collected like I think I collected like

00:50:41,410 --> 00:50:46,839
75 hours worth of data and for each of

00:50:44,289 --> 00:50:49,119
those hours I collected the observed

00:50:46,839 --> 00:50:53,020
worst case execution latency on a

00:50:49,119 --> 00:50:54,099
specific CPU and I fit it and you know I

00:50:53,020 --> 00:50:55,930
said you know what I'm not a

00:50:54,099 --> 00:51:01,119
statistician that looks that looks good

00:50:55,930 --> 00:51:02,770
right and I continued on run and so I

00:51:01,119 --> 00:51:05,859
was able to actually construct a very

00:51:02,770 --> 00:51:09,130
compelling story so down here is the the

00:51:05,859 --> 00:51:11,140
x-axis is the it's a multiple of the

00:51:09,130 --> 00:51:13,660
period in this case it's an hour so you

00:51:11,140 --> 00:51:14,559
can see like one hour I can say given

00:51:13,660 --> 00:51:16,779
the number of samples that I've

00:51:14,559 --> 00:51:19,539
collected I could see I would expect to

00:51:16,779 --> 00:51:22,119
see latency is around 70 microseconds

00:51:19,539 --> 00:51:24,099
within a given range now my intuition

00:51:22,119 --> 00:51:26,230
tells me that I should be able to do

00:51:24,099 --> 00:51:31,020
more testing and actually further

00:51:26,230 --> 00:51:33,910
constrain that range in that prediction

00:51:31,020 --> 00:51:35,559
and so therefore I could conceivably

00:51:33,910 --> 00:51:37,569
have some marketing person come to me

00:51:35,559 --> 00:51:38,280
and say like here's the guarantee I want

00:51:37,569 --> 00:51:39,570
to make

00:51:38,280 --> 00:51:41,640
I can say okay here's out how much it's

00:51:39,570 --> 00:51:44,520
gonna cost in terms of the testing the

00:51:41,640 --> 00:51:49,140
number of testing hours right yeah I can

00:51:44,520 --> 00:51:52,110
dream so this is like I really like this

00:51:49,140 --> 00:51:58,400
and I'd open and talk to Daniel because

00:51:52,110 --> 00:52:02,280
he's a academic kind of he pointed me

00:51:58,400 --> 00:52:05,130
has a foot in both worlds so he was a

00:52:02,280 --> 00:52:09,390
helpful yeah sorry I never stop sorry I

00:52:05,130 --> 00:52:11,340
should always clarify okay all right I

00:52:09,390 --> 00:52:16,950
could say Daniel 1 & 2 but that implies

00:52:11,340 --> 00:52:19,320
an order that I'm not happy defining so

00:52:16,950 --> 00:52:22,260
so one of the one of the challenges in

00:52:19,320 --> 00:52:25,200
this in this is that it doesn't actually

00:52:22,260 --> 00:52:29,790
work so I'm up here kind of presenting

00:52:25,200 --> 00:52:31,410
kind of a no result thank you

00:52:29,790 --> 00:52:32,490
actually I'm here because I wanted to

00:52:31,410 --> 00:52:34,410
share this because this is actually

00:52:32,490 --> 00:52:35,850
really interesting to me is that it

00:52:34,410 --> 00:52:38,700
doesn't work because the assumptions

00:52:35,850 --> 00:52:40,880
that are necessarily put in place to for

00:52:38,700 --> 00:52:43,830
an extreme value analysis to proceed

00:52:40,880 --> 00:52:46,620
successfully and actually be useful is

00:52:43,830 --> 00:52:48,510
that you need to be able to collect

00:52:46,620 --> 00:52:49,820
samples that are independent from one

00:52:48,510 --> 00:52:52,470
another and identically distributed

00:52:49,820 --> 00:52:54,750
which actually if you look at like a

00:52:52,470 --> 00:52:57,510
latency plot as a time series like

00:52:54,750 --> 00:52:59,400
there's clearly Auto correlations the

00:52:57,510 --> 00:53:01,710
sample there is not it's not an

00:52:59,400 --> 00:53:03,180
independent distribution so in fact you

00:53:01,710 --> 00:53:05,850
can do and I started going down this

00:53:03,180 --> 00:53:07,410
path and and kind of ended because I was

00:53:05,850 --> 00:53:08,730
kind of saddened but you there's a

00:53:07,410 --> 00:53:09,900
series of independence tests that you

00:53:08,730 --> 00:53:10,920
can actually perform on they down the

00:53:09,900 --> 00:53:12,090
sample as you collect and you can

00:53:10,920 --> 00:53:13,950
clearly see that like we're not

00:53:12,090 --> 00:53:15,480
independent of one another so I feel

00:53:13,950 --> 00:53:17,070
like there was like this academic world

00:53:15,480 --> 00:53:19,350
like someone in academia was reaching

00:53:17,070 --> 00:53:20,670
their hand down to me and saying oh this

00:53:19,350 --> 00:53:22,110
is gonna be really good for you and I

00:53:20,670 --> 00:53:24,210
just fell short because you know the

00:53:22,110 --> 00:53:25,170
real world and stuff so anyway I wanted

00:53:24,210 --> 00:53:26,910
to share this because I thought you

00:53:25,170 --> 00:53:28,290
might find this interesting and if

00:53:26,910 --> 00:53:30,150
anyone has any questions or further

00:53:28,290 --> 00:53:33,570
analysis the weekend that might be of

00:53:30,150 --> 00:53:34,890
interest I'd love to hear it I think

00:53:33,570 --> 00:53:36,300
this is gonna segue pretty well into

00:53:34,890 --> 00:53:38,040
what Daniels going to talk about Dan

00:53:36,300 --> 00:53:40,470
overstock sorry

00:53:38,040 --> 00:53:42,180
actually the question I mean does this

00:53:40,470 --> 00:53:51,720
sound like it's useful information that

00:53:42,180 --> 00:53:55,410
have okay

00:53:51,720 --> 00:53:57,690
I know perhaps it's unwarranted optimism

00:53:55,410 --> 00:53:59,160
but I think choking out the entire

00:53:57,690 --> 00:54:01,140
approach this because of the

00:53:59,160 --> 00:54:02,790
independence of distributions it

00:54:01,140 --> 00:54:04,350
probably was more of priam tortilla

00:54:02,790 --> 00:54:06,540
because of the level of hard guarantees

00:54:04,350 --> 00:54:08,220
did you have to get yeah but the lack of

00:54:06,540 --> 00:54:09,510
Independence is something that has

00:54:08,220 --> 00:54:10,890
always been there for example when

00:54:09,510 --> 00:54:14,070
looking at things that I all eight and

00:54:10,890 --> 00:54:15,570
see and it's often by our trimodal

00:54:14,070 --> 00:54:16,890
that is the distribution and it's still

00:54:15,570 --> 00:54:20,820
interesting to know what the frequency

00:54:16,890 --> 00:54:22,860
of doors are so I I think this would

00:54:20,820 --> 00:54:25,740
have applications in other areas where

00:54:22,860 --> 00:54:30,870
being absolutely correct is not

00:54:25,740 --> 00:54:32,220
necessarily like I've seen plenty of

00:54:30,870 --> 00:54:35,640
cases over the course last couple years

00:54:32,220 --> 00:54:38,070
where in the trying to deal with extreme

00:54:35,640 --> 00:54:40,020
values I trying to figure out how often

00:54:38,070 --> 00:54:42,150
they occur do they occur every like five

00:54:40,020 --> 00:54:43,890
minutes every five hours every 15 hours

00:54:42,150 --> 00:54:45,270
think had known something like this my

00:54:43,890 --> 00:54:47,310
life do it a lot easier but I was it

00:54:45,270 --> 00:54:48,660
turned into control couple of darts at

00:54:47,310 --> 00:54:51,990
the wall and hope yeah

00:54:48,660 --> 00:54:53,580
so I thanks for this yeah I actually

00:54:51,990 --> 00:54:56,870
went down the route of like trying to

00:54:53,580 --> 00:54:59,760
figure out how I could correct like I

00:54:56,870 --> 00:55:01,470
could look at doing time series analysis

00:54:59,760 --> 00:55:02,940
and kind of do some filter filtering of

00:55:01,470 --> 00:55:04,260
the latency values that are coming out

00:55:02,940 --> 00:55:06,780
of the time series analysis to try to

00:55:04,260 --> 00:55:08,580
eliminate some of the effects of like

00:55:06,780 --> 00:55:10,440
dependence for example like if you have

00:55:08,580 --> 00:55:12,900
a latency spike the next sample you take

00:55:10,440 --> 00:55:14,430
is likely to be another high latency

00:55:12,900 --> 00:55:15,930
spike maybe not at the same same

00:55:14,430 --> 00:55:18,360
capacity and just kind of like breakdown

00:55:15,930 --> 00:55:21,930
from a time series perspective but kind

00:55:18,360 --> 00:55:22,380
of haven't come with any that way so

00:55:21,930 --> 00:55:25,980
yeah

00:55:22,380 --> 00:55:28,080
can this data analysis then show maybe

00:55:25,980 --> 00:55:30,420
causes maybe say if there's a maybe you

00:55:28,080 --> 00:55:36,180
don't know what the relationship is do

00:55:30,420 --> 00:55:38,550
this wait to see how like patterns in

00:55:36,180 --> 00:55:40,350
say and then try to figure out why I

00:55:38,550 --> 00:55:43,170
guess I guess you're asking whether or

00:55:40,350 --> 00:55:45,560
not like we could clearly show some kind

00:55:43,170 --> 00:55:45,560
of outlier

00:55:45,910 --> 00:55:50,779
yeah whether or not because like a lot

00:55:48,829 --> 00:55:52,640
in a live manner say it's a whether or

00:55:50,779 --> 00:55:55,579
not you're witnessing some out outlier

00:55:52,640 --> 00:56:00,679
like in my fighting system no anywhere

00:55:55,579 --> 00:56:02,059
cause I made sure I don't it's not

00:56:00,679 --> 00:56:05,119
obvious to me how we would do that but I

00:56:02,059 --> 00:56:07,039
suppose it's possible I guess I would

00:56:05,119 --> 00:56:09,319
suggest that I would like to see that

00:56:07,039 --> 00:56:11,749
you continue it because of just the fact

00:56:09,319 --> 00:56:15,349
that it is a trending I mean it shows

00:56:11,749 --> 00:56:17,900
trends as opposed to hard and fast yeah

00:56:15,349 --> 00:56:23,179
yeah I'm gonna lean on some academic

00:56:17,900 --> 00:56:26,779
people I can get if I can find them just

00:56:23,179 --> 00:56:31,160
one addition we try to use extreme value

00:56:26,779 --> 00:56:38,150
analysis in the latency for Linux but

00:56:31,160 --> 00:56:40,819
the problem is that the worst education

00:56:38,150 --> 00:56:43,630
time when we have one application in

00:56:40,819 --> 00:56:46,069
this application has one control path

00:56:43,630 --> 00:56:48,410
the problem is that when we have a

00:56:46,069 --> 00:56:51,679
latency we don't have one control path

00:56:48,410 --> 00:56:54,380
but the latest is the result of many

00:56:51,679 --> 00:56:57,409
paths that we take from the wakeup and

00:56:54,380 --> 00:56:59,989
to the starting of the task so now we

00:56:57,409 --> 00:57:02,869
have the latency because the system was

00:56:59,989 --> 00:57:05,739
idle then we get the latency because we

00:57:02,869 --> 00:57:08,839
run the code of a regular preemption or

00:57:05,739 --> 00:57:11,689
because we take a section with a very

00:57:08,839 --> 00:57:14,119
long preemption disabled so we are

00:57:11,689 --> 00:57:17,689
analyzing very different code paths and

00:57:14,119 --> 00:57:19,009
we are having some outputs that are they

00:57:17,689 --> 00:57:21,829
are different they are not related to

00:57:19,009 --> 00:57:24,380
each other and in like we have like in

00:57:21,829 --> 00:57:26,659
this start to have a distribution very

00:57:24,380 --> 00:57:29,269
close where we have a many occurrence of

00:57:26,659 --> 00:57:31,579
that latency but then we have a very far

00:57:29,269 --> 00:57:33,949
tail and this very far tail is the

00:57:31,579 --> 00:57:37,669
problem when we are trying to measure so

00:57:33,949 --> 00:57:41,059
one good way would be to separate each

00:57:37,669 --> 00:57:43,309
execution each latency and compare that

00:57:41,059 --> 00:57:46,609
latency with the other occurrence of

00:57:43,309 --> 00:57:48,210
that latency and then or we get the

00:57:46,609 --> 00:57:50,670
worst latency and try to

00:57:48,210 --> 00:57:52,920
all the times that we get that path and

00:57:50,670 --> 00:57:55,020
usually extreme value analysis on that

00:57:52,920 --> 00:57:58,109
path so yeah

00:57:55,020 --> 00:58:00,809
the points that it this is more complex

00:57:58,109 --> 00:58:03,150
and we need to we will need to break

00:58:00,809 --> 00:58:06,569
down the latency into different metrics

00:58:03,150 --> 00:58:08,339
and apply these yeah I hear someone is

00:58:06,569 --> 00:58:11,220
working on some tooling that would help

00:58:08,339 --> 00:58:13,890
do that I know a guy who's working to

00:58:11,220 --> 00:58:16,140
breaking these metrics okay he's helping

00:58:13,890 --> 00:58:18,240
guys with extreme value but he doesn't

00:58:16,140 --> 00:58:22,400
know about extremists you know the

00:58:18,240 --> 00:58:24,510
requirements but doesn't know the the

00:58:22,400 --> 00:58:27,569
probabilistic in the statistical part

00:58:24,510 --> 00:58:28,890
yeah because he I'm up here pretending

00:58:27,569 --> 00:58:32,099
that I do but I don't

00:58:28,890 --> 00:58:51,119
so yeah exactly

00:58:32,099 --> 00:58:53,780
okay that's all I had yeah he's like

00:58:51,119 --> 00:58:53,780
wait it's me

00:58:54,829 --> 00:59:05,970
breakers after you it's after you it's

00:58:59,670 --> 00:59:08,750
at 3:30 yeah I've always waited for you

00:59:05,970 --> 00:59:08,750
to go out for the break

00:59:15,450 --> 00:59:20,410
[Laughter]

00:59:25,880 --> 00:59:28,880
like

00:59:43,720 --> 01:00:11,380
okay not only very fast are you that

01:00:01,790 --> 01:00:11,380
that's intentional it's my nephew

01:00:17,190 --> 01:00:24,300
sorry let's show my family that's it

01:00:24,660 --> 01:00:33,579
yet I didn't change the first one so

01:00:28,660 --> 01:00:35,859
here I am again with that story about

01:00:33,579 --> 01:00:40,829
the logical sequence and logical

01:00:35,859 --> 01:00:40,829
correctness and timing correctness so

01:00:41,609 --> 01:00:48,040
back with that theory like in the theory

01:00:45,609 --> 01:00:50,950
real-time systems we analyze the system

01:00:48,040 --> 01:00:55,210
as a set of variables of independent

01:00:50,950 --> 01:00:59,980
variables and we do use these variables

01:00:55,210 --> 01:01:02,710
for example the the period of the task

01:00:59,980 --> 01:01:05,710
the execution time of the task and the

01:01:02,710 --> 01:01:08,050
deadlines of tasks which are abstract

01:01:05,710 --> 01:01:09,970
that we are now using on scat deadlines

01:01:08,050 --> 01:01:13,030
and they are already present on kernel

01:01:09,970 --> 01:01:15,339
right but there are some other variables

01:01:13,030 --> 01:01:17,290
that are used there like the blocking

01:01:15,339 --> 01:01:22,690
time of a task how long does the task

01:01:17,290 --> 01:01:24,940
block on lock on the idea of law and

01:01:22,690 --> 01:01:28,420
then they use these these variables to

01:01:24,940 --> 01:01:33,099
say that if the system is scalable or

01:01:28,420 --> 01:01:35,440
not and then they do that may have

01:01:33,099 --> 01:01:37,780
saying that okay knowing that my worst

01:01:35,440 --> 01:01:40,510
case equation time is easy my blocking

01:01:37,780 --> 01:01:44,800
time is B and interference of other

01:01:40,510 --> 01:01:47,560
tasks with a higher priority is this my

01:01:44,800 --> 01:01:49,720
response time is that and so for all the

01:01:47,560 --> 01:01:52,569
tasks of the system I compute the

01:01:49,720 --> 01:01:54,819
response time and then I can say okay if

01:01:52,569 --> 01:01:57,010
all the tasks complete before the

01:01:54,819 --> 01:02:01,900
deadline the system is scheduled able

01:01:57,010 --> 01:02:03,700
and that's how they do analysis so okay

01:02:01,900 --> 01:02:06,069
this is a little bit complicated to see

01:02:03,700 --> 01:02:11,079
the things but we can draw the picture

01:02:06,069 --> 01:02:14,940
and I forgot to does anyone have I

01:02:11,079 --> 01:02:14,940
thought it was after the break

01:02:15,250 --> 01:02:23,960
that's a real-time real-time

01:02:17,390 --> 01:02:26,450
presentation and I and I am now getting

01:02:23,960 --> 01:02:31,280
this Steven style like in lefting things

01:02:26,450 --> 01:02:33,080
to the last minute yeah that's no that's

01:02:31,280 --> 01:02:39,260
a blocking time I was waiting for a

01:02:33,080 --> 01:02:46,450
resource I was already running so we

01:02:39,260 --> 01:02:46,450
have the in sorry yeah and you as well

01:02:47,470 --> 01:02:53,150
so we have in the academic side you say

01:02:51,410 --> 01:02:54,860
that we can have a release jitter which

01:02:53,150 --> 01:02:57,350
is the time between the activation and

01:02:54,860 --> 01:03:01,190
the starting of the time starting of the

01:02:57,350 --> 01:03:03,260
execution we have the task execution

01:03:01,190 --> 01:03:05,300
itself which is the execution timer

01:03:03,260 --> 01:03:07,700
worst case equation time we have a

01:03:05,300 --> 01:03:10,340
blocking time of tasks and we have

01:03:07,700 --> 01:03:13,160
interference from this cloud and from no

01:03:10,340 --> 01:03:15,350
I mean for motor tasks and what really

01:03:13,160 --> 01:03:17,869
matters for them they use all these

01:03:15,350 --> 01:03:20,630
abstractions to in the end know if the

01:03:17,869 --> 01:03:22,910
response time is before the deadline

01:03:20,630 --> 01:03:25,369
like a deadline in equals to period for

01:03:22,910 --> 01:03:28,400
example and they care about these

01:03:25,369 --> 01:03:30,740
variables the response time that's what

01:03:28,400 --> 01:03:37,070
really matter the other metric is are

01:03:30,740 --> 01:03:39,740
used to compose the response time so on

01:03:37,070 --> 01:03:42,560
the parameter T we measure our timing

01:03:39,740 --> 01:03:45,950
correctness using the latency and the

01:03:42,560 --> 01:03:50,330
latest is good I mean I don't want to

01:03:45,950 --> 01:03:52,400
say it's bad it brings ok we are all

01:03:50,330 --> 01:03:54,410
here because we have a new prime 30 and

01:03:52,400 --> 01:03:56,290
the latest is the main motor of the

01:03:54,410 --> 01:03:59,630
innovation era for example to keep

01:03:56,290 --> 01:04:01,520
things work so it's good but we can go

01:03:59,630 --> 01:04:05,180
further we can go beyond that

01:04:01,520 --> 01:04:07,580
so now let's criticize but criticizing a

01:04:05,180 --> 01:04:13,450
good way to try to find better solutions

01:04:07,580 --> 01:04:13,450
right sorry

01:04:14,319 --> 01:04:24,049
now I'm general kinda okay the idea of

01:04:21,920 --> 01:04:28,130
latency we all know what is the latency

01:04:24,049 --> 01:04:30,049
but it's actually composed of many other

01:04:28,130 --> 01:04:32,569
things that happen on car no it's Erik

01:04:30,049 --> 01:04:35,839
use no car keys disable preemption

01:04:32,569 --> 01:04:38,059
disable and a higher priority task that

01:04:35,839 --> 01:04:42,170
we are not analyzing like stop machine

01:04:38,059 --> 01:04:45,230
so we actually end up seeing the kernel

01:04:42,170 --> 01:04:49,760
as a black box and we measure it using

01:04:45,230 --> 01:04:50,960
cyclic test then but as we use the

01:04:49,760 --> 01:04:53,960
kernel as a black box

01:04:50,960 --> 01:04:56,059
we have no guarantee that okay I hit the

01:04:53,960 --> 01:04:57,950
latest and now and we will continue the

01:04:56,059 --> 01:04:59,839
bugging and now I will enable trace I

01:04:57,950 --> 01:05:02,900
have no guarantee that that situation

01:04:59,839 --> 01:05:05,720
will take place again and if something

01:05:02,900 --> 01:05:07,220
happens and it's similar we have no

01:05:05,720 --> 01:05:10,849
guarantee that we are reproducing the

01:05:07,220 --> 01:05:14,750
same problem and then sometimes you wind

01:05:10,849 --> 01:05:18,770
up having latencies that happen once a

01:05:14,750 --> 01:05:21,099
week and and it's hard to find it out

01:05:18,770 --> 01:05:24,200
again

01:05:21,099 --> 01:05:27,260
because the shame it doesn't means also

01:05:24,200 --> 01:05:29,569
that the chain of events didn't take

01:05:27,260 --> 01:05:31,280
place they might be taking place we are

01:05:29,569 --> 01:05:37,270
just not catching them in the correct

01:05:31,280 --> 01:05:40,640
order to cause the latency so moreover

01:05:37,270 --> 01:05:42,980
it's very hard if not impossible to give

01:05:40,640 --> 01:05:45,170
guarantee on the worst case latency and

01:05:42,980 --> 01:05:48,290
that's the case that Julia was talking

01:05:45,170 --> 01:05:52,880
about like the the variance in the

01:05:48,290 --> 01:05:56,750
latency is so like unconnected one data

01:05:52,880 --> 01:05:58,990
with order that the probabilistic

01:05:56,750 --> 01:06:01,549
methods to define worst case for

01:05:58,990 --> 01:06:03,650
supports keys action time they doesn't

01:06:01,549 --> 01:06:06,920
fit in the latency we tried

01:06:03,650 --> 01:06:08,599
not I I I helped with the measurements

01:06:06,920 --> 01:06:10,700
with a friend that works with

01:06:08,599 --> 01:06:13,130
probabilistic she's a specialist on the

01:06:10,700 --> 01:06:16,760
probabilistic part and she just said

01:06:13,130 --> 01:06:18,920
okay never the way that the data is the

01:06:16,760 --> 01:06:21,430
tell you is so long that we cannot make

01:06:18,920 --> 01:06:23,779
any relation with the rest of the data

01:06:21,430 --> 01:06:27,119
so

01:06:23,779 --> 01:06:29,490
we found that we could not use extreme

01:06:27,119 --> 01:06:38,400
valuing alexej is a hot topic on this

01:06:29,490 --> 01:06:40,829
matter on the latency but other than the

01:06:38,400 --> 01:06:43,890
latest we have other things that one

01:06:40,829 --> 01:06:46,200
real-time task may depends on like and

01:06:43,890 --> 01:06:48,150
we have a solution for it for example we

01:06:46,200 --> 01:06:53,480
have test is depending on lot and we

01:06:48,150 --> 01:06:57,329
have priority inheritance for log but we

01:06:53,480 --> 01:06:59,670
generally how many how many times we see

01:06:57,329 --> 01:07:02,759
people complaining of one version or the

01:06:59,670 --> 01:07:04,829
other that this lock is starting to take

01:07:02,759 --> 01:07:08,849
more time to be held

01:07:04,829 --> 01:07:11,960
we don't do analysis on the locking time

01:07:08,849 --> 01:07:15,359
of the locks that we have on kernel and

01:07:11,960 --> 01:07:17,640
moreover tasks depends on other tasks

01:07:15,359 --> 01:07:20,940
for example the latency itself depends

01:07:17,640 --> 01:07:24,740
on my Eric you and the irq if we see it

01:07:20,940 --> 01:07:27,869
as a thread it's a tasks or it has some

01:07:24,740 --> 01:07:29,579
some causes of the delay for the

01:07:27,869 --> 01:07:32,220
interrupt and then the thread again

01:07:29,579 --> 01:07:34,769
there is another sir of course so we

01:07:32,220 --> 01:07:38,460
have the penis' among tasks that we

01:07:34,769 --> 01:07:41,489
usually don't analyze and interference

01:07:38,460 --> 01:07:44,609
like interferes of tasks on another

01:07:41,489 --> 01:07:49,710
tasks and interference of our cues on

01:07:44,609 --> 01:07:52,980
tasks we don't know for example if the

01:07:49,710 --> 01:07:55,230
execution time of a interrupt handler

01:07:52,980 --> 01:07:58,019
attracted interrupt handler in the

01:07:55,230 --> 01:08:00,950
real-time kernel it increases because

01:07:58,019 --> 01:08:05,009
the driver changed we don't measure this

01:08:00,950 --> 01:08:08,759
so it's hard to say to catch such kind

01:08:05,009 --> 01:08:11,730
of change that might change the schedule

01:08:08,759 --> 01:08:14,849
ability of my system in practice if I

01:08:11,730 --> 01:08:20,159
have a change on the way on the timing

01:08:14,849 --> 01:08:22,139
that I that I have held a lock it will

01:08:20,159 --> 01:08:25,380
be influence on the response time if I

01:08:22,139 --> 01:08:27,480
have a driver even a treaded driver that

01:08:25,380 --> 01:08:29,730
is taking more let's take a longer to

01:08:27,480 --> 01:08:31,380
execute it's also influencing the

01:08:29,730 --> 01:08:34,530
execution time of the threads with lower

01:08:31,380 --> 01:08:38,030
priority but we don't do this kind

01:08:34,530 --> 01:08:41,730
so check or this measurement in the

01:08:38,030 --> 01:08:49,140
day-by-day test and refrain 30 do I do

01:08:41,730 --> 01:08:51,690
we so we have the latency it's good but

01:08:49,140 --> 01:08:56,690
we also have other problems to care that

01:08:51,690 --> 01:08:59,250
we are actually not doing extensive

01:08:56,690 --> 01:09:02,420
testing and trying to figure out if

01:08:59,250 --> 01:09:06,540
things get worse or better over the time

01:09:02,420 --> 01:09:09,720
so this is the topic of discussion this

01:09:06,540 --> 01:09:11,880
is the problem so how can we improve the

01:09:09,720 --> 01:09:15,300
situation of testing on the parameter T

01:09:11,880 --> 01:09:17,610
to catch the variation of this blocking

01:09:15,300 --> 01:09:20,190
time execution time of other things that

01:09:17,610 --> 01:09:24,840
are part of the system like irq handlers

01:09:20,190 --> 01:09:27,870
and okay in the end we had a discussion

01:09:24,840 --> 01:09:32,520
last week talking about throttling and

01:09:27,870 --> 01:09:34,200
even some ideas of what is a task on

01:09:32,520 --> 01:09:39,320
linux should because there are accuser

01:09:34,200 --> 01:09:39,320
argues as a sort of tasks on linux and

01:09:40,370 --> 01:09:45,450
what are the other possible metrics that

01:09:43,050 --> 01:09:48,030
we can use how can we measure the

01:09:45,450 --> 01:09:50,730
execution time of tasks that's that's a

01:09:48,030 --> 01:09:52,650
barrier to using the scattered line for

01:09:50,730 --> 01:09:54,690
example because we need to inform the

01:09:52,650 --> 01:09:57,690
execution time of tasks how do we

01:09:54,690 --> 01:10:01,260
measure it and how measuring it how do

01:09:57,690 --> 01:10:03,390
we isolate it from the other things that

01:10:01,260 --> 01:10:05,370
are not part of the tasks like I are

01:10:03,390 --> 01:10:09,570
accuse blocking time is scheduling

01:10:05,370 --> 01:10:12,450
overhead how do we catch only the

01:10:09,570 --> 01:10:14,790
execution time of the tasks that's why

01:10:12,450 --> 01:10:16,560
just one thing about the execution time

01:10:14,790 --> 01:10:19,980
of tasks is extremely difficult because

01:10:16,560 --> 01:10:22,560
you also have hardware that you never

01:10:19,980 --> 01:10:24,330
write get the same write one thing could

01:10:22,560 --> 01:10:26,580
run very very quickly depending on how

01:10:24,330 --> 01:10:28,770
it's got the cache house and there's so

01:10:26,580 --> 01:10:31,320
many variables with that in the hardware

01:10:28,770 --> 01:10:33,180
let alone DOS operating system yeah yeah

01:10:31,320 --> 01:10:37,320
almost impossible to find out the

01:10:33,180 --> 01:10:38,820
execution time yeah yeah I agree but we

01:10:37,320 --> 01:10:41,670
need to know the execution time for

01:10:38,820 --> 01:10:43,620
example to use care deadlines yeah and

01:10:41,670 --> 01:10:45,330
then we are more or less locking up I'm

01:10:43,620 --> 01:10:46,130
not saying that we have a solution I say

01:10:45,330 --> 01:10:51,860
that these are

01:10:46,130 --> 01:10:54,889
things that you need to think only

01:10:51,860 --> 01:10:57,110
domain I mean for kind of soft real-time

01:10:54,889 --> 01:10:59,750
cyber workloads you're probably probably

01:10:57,110 --> 01:11:02,449
steep and is your execution time

01:10:59,750 --> 01:11:04,489
probably okay if you have of course not

01:11:02,449 --> 01:11:07,100
your time type of system the system be

01:11:04,489 --> 01:11:10,070
here the thing is different so depends

01:11:07,100 --> 01:11:13,000
also on what you're planning to apply

01:11:10,070 --> 01:11:15,590
your analogy

01:11:13,000 --> 01:11:17,630
yeah actually I find out it's more of a

01:11:15,590 --> 01:11:19,219
percentage wise percentage of CPU is

01:11:17,630 --> 01:11:20,960
probably a better chance of what you get

01:11:19,219 --> 01:11:22,610
that actual execution time is saying I

01:11:20,960 --> 01:11:24,889
just want this guy to make sure it it's

01:11:22,610 --> 01:11:27,440
guaranteed a percentage of the CPU then

01:11:24,889 --> 01:11:28,790
you know portion of it but so really

01:11:27,440 --> 01:11:34,429
trying to say how much the execution

01:11:28,790 --> 01:11:38,659
time per period is kinda lost cause I

01:11:34,429 --> 01:11:41,929
mean I don't see these are lost cause I

01:11:38,659 --> 01:11:44,120
think we have been using the for example

01:11:41,929 --> 01:11:51,560
extreme value analysis to measure the

01:11:44,120 --> 01:11:54,949
execution time of tasks and sorry okay

01:11:51,560 --> 01:11:56,929
we have the okay we use extreme value

01:11:54,949 --> 01:12:00,139
analysis to measure the execution time

01:11:56,929 --> 01:12:02,409
of tasks on Linux and it works fine as

01:12:00,139 --> 01:12:05,090
long as we remove the things like

01:12:02,409 --> 01:12:08,000
interference of other tasks interference

01:12:05,090 --> 01:12:09,830
of fiery cues and we were able to fit it

01:12:08,000 --> 01:12:13,969
in the model of extreme value analysis

01:12:09,830 --> 01:12:14,949
so it might be less difficult than we

01:12:13,969 --> 01:12:18,409
think

01:12:14,949 --> 01:12:21,050
but we need to start to looking at these

01:12:18,409 --> 01:12:24,520
values and start to catch some values

01:12:21,050 --> 01:12:26,810
and measure the DS over the time if they

01:12:24,520 --> 01:12:29,300
dramatically change from one version to

01:12:26,810 --> 01:12:31,639
another and to look at okay what caused

01:12:29,300 --> 01:12:34,250
this change I was seeing this blocking

01:12:31,639 --> 01:12:36,800
time in maximum on the RQ lock and then

01:12:34,250 --> 01:12:40,090
on this next version we catch these

01:12:36,800 --> 01:12:43,489
higher value on the RQ log what changed

01:12:40,090 --> 01:12:45,590
my question is some of these things are

01:12:43,489 --> 01:12:50,510
easier or some of the components are

01:12:45,590 --> 01:12:52,139
easier to measure but even those can you

01:12:50,510 --> 01:13:01,969
ignore the

01:12:52,139 --> 01:13:05,460
the cost of measuring them okay yeah

01:13:01,969 --> 01:13:07,440
well that's that's another point and

01:13:05,460 --> 01:13:10,080
this is about how can how would we

01:13:07,440 --> 01:13:13,170
measure these values what method we will

01:13:10,080 --> 01:13:17,250
use to reduce the interference of the

01:13:13,170 --> 01:13:19,909
trace I am more a raising question than

01:13:17,250 --> 01:13:22,350
giving solutions here that's the idea

01:13:19,909 --> 01:13:24,420
what are the other metric is we need to

01:13:22,350 --> 01:13:26,520
use what are the other what are the

01:13:24,420 --> 01:13:28,920
tools that we need to use them should we

01:13:26,520 --> 01:13:32,369
continue using tools in the user space

01:13:28,920 --> 01:13:33,960
looking kernel as a black box or should

01:13:32,369 --> 01:13:36,210
we move these measurements for the

01:13:33,960 --> 01:13:38,909
kernel using trace like a trace plug-in

01:13:36,210 --> 01:13:40,889
on their trace I mean and one thing I've

01:13:38,909 --> 01:13:42,600
learned from trying to trace things to

01:13:40,889 --> 01:13:44,219
try to have a least amount overhead is

01:13:42,600 --> 01:13:45,570
you could measure one thing at a time

01:13:44,219 --> 01:13:47,429
you've trying to measure more than one

01:13:45,570 --> 01:13:48,540
things the other measurements will then

01:13:47,429 --> 01:13:51,119
interfere with dementia other

01:13:48,540 --> 01:13:52,770
measurements and I've actually seen

01:13:51,119 --> 01:13:54,750
people like use function graph tracer

01:13:52,770 --> 01:13:56,880
and look at the results of you know how

01:13:54,750 --> 01:13:58,590
long every function executed I said well

01:13:56,880 --> 01:14:00,420
you know when you look at this function

01:13:58,590 --> 01:14:02,070
it called 20 different functions the

01:14:00,420 --> 01:14:05,520
function graph tracer itself just slowed

01:14:02,070 --> 01:14:07,380
it down tremendously right yeah so I

01:14:05,520 --> 01:14:09,179
always say measure would wonder what's

01:14:07,380 --> 01:14:11,070
one function is measure one function cuz

01:14:09,179 --> 01:14:13,440
yeah it's off by a few nanoseconds since

01:14:11,070 --> 01:14:15,420
it's not that big of a deal yeah sure so

01:14:13,440 --> 01:14:17,940
in this case it would translate for

01:14:15,420 --> 01:14:20,639
something like okay we will now do

01:14:17,940 --> 01:14:23,400
regression tests for example just for

01:14:20,639 --> 01:14:26,929
locks and using this tool and then we

01:14:23,400 --> 01:14:30,060
separate it okay just measure the

01:14:26,929 --> 01:14:32,310
execution times of I are accuse and just

01:14:30,060 --> 01:14:33,810
measure it separated and one thing would

01:14:32,310 --> 01:14:35,219
be interesting to do is maybe we should

01:14:33,810 --> 01:14:37,170
well one thing I am rewriting function

01:14:35,219 --> 01:14:39,179
graph tracer now to hopefully make it a

01:14:37,170 --> 01:14:41,400
little like lighter weight and other

01:14:39,179 --> 01:14:42,690
things but to be able to instead of

01:14:41,400 --> 01:14:44,760
doing the recording into the ring buffer

01:14:42,690 --> 01:14:46,230
because we may not care about you know

01:14:44,760 --> 01:14:48,750
everything all that we just want a

01:14:46,230 --> 01:14:50,580
metric histogram so baby may be

01:14:48,750 --> 01:14:52,199
attaching histogram to the function

01:14:50,580 --> 01:14:54,570
graph tracer just to give me the numbers

01:14:52,199 --> 01:14:55,560
that will drop the overhead so all these

01:14:54,570 --> 01:14:56,820
things you might just you just care

01:14:55,560 --> 01:14:58,560
about numbers you don't care about the

01:14:56,820 --> 01:14:59,909
actual pass so right

01:14:58,560 --> 01:15:03,420
you don't want tracing you want just

01:14:59,909 --> 01:15:04,619
like to get quarters right so we should

01:15:03,420 --> 01:15:08,099
change the infrastructure to do that

01:15:04,619 --> 01:15:09,840
so for example no note let's try to

01:15:08,099 --> 01:15:13,860
apply this to one thing that we have

01:15:09,840 --> 01:15:14,489
something more or less distorted he's my

01:15:13,860 --> 01:15:22,860
manager

01:15:14,489 --> 01:15:27,060
he's the highest priority you get a

01:15:22,860 --> 01:15:29,429
raise so like for blocking time or we

01:15:27,060 --> 01:15:31,440
that's mainly lock whole time

01:15:29,429 --> 01:15:33,060
yeah for example we have a lock in

01:15:31,440 --> 01:15:35,670
sketch stats that's what I was wondering

01:15:33,060 --> 01:15:37,500
is it don't we have that aren't most of

01:15:35,670 --> 01:15:39,540
our mutual exclusion primitives

01:15:37,500 --> 01:15:45,830
instrumented in some way so we could say

01:15:39,540 --> 01:15:45,830
this one was held for you know lakhs 10

01:15:47,540 --> 01:15:51,840
lakhs 10 knots gets to know calculate

01:15:50,280 --> 01:15:54,869
for a particular task

01:15:51,840 --> 01:15:57,360
I wouldn't call it a heart value better

01:15:54,869 --> 01:15:59,489
an average blocking yeah but for example

01:15:57,360 --> 01:16:02,460
yeah it just gets data it's wrong here

01:15:59,489 --> 01:16:06,739
so it locks that but locks that only

01:16:02,460 --> 01:16:09,989
works with locked upon right

01:16:06,739 --> 01:16:11,820
yeah and that's I try to unconnect one

01:16:09,989 --> 01:16:14,580
from the other but I didn't have time

01:16:11,820 --> 01:16:16,889
so should we what would be the better

01:16:14,580 --> 01:16:21,360
approach for someone trying to implement

01:16:16,889 --> 01:16:24,590
these should do something like yeah but

01:16:21,360 --> 01:16:27,060
trace lock also depends on lock them

01:16:24,590 --> 01:16:29,869
yeah those trace points are enabled only

01:16:27,060 --> 01:16:29,869
we've locked up

01:16:31,039 --> 01:16:36,469
we're function yeah what one can use

01:16:33,800 --> 01:16:39,139
functional graph as well so we have a

01:16:36,469 --> 01:16:41,179
lot of tools and ways to do this what

01:16:39,139 --> 01:16:44,269
would be the best way for one guy that

01:16:41,179 --> 01:16:52,599
will try to do this should try to do in

01:16:44,269 --> 01:16:52,599
a in a way more no oh yeah Clark has one

01:16:55,809 --> 01:17:04,940
very nice we are small so asking Paul

01:17:02,960 --> 01:17:09,650
McKinney is asking IBM as far as I'm

01:17:04,940 --> 01:17:12,860
concerned yeah so should we use like

01:17:09,650 --> 01:17:15,469
something using Tracy trace plugin

01:17:12,860 --> 01:17:17,360
should we use trace points and export

01:17:15,469 --> 01:17:20,989
the data to user space and process on

01:17:17,360 --> 01:17:24,170
earth should we use a sketch lock stat

01:17:20,989 --> 01:17:26,389
like analysis grabbing the data in the

01:17:24,170 --> 01:17:29,389
numbers in storing as functions on

01:17:26,389 --> 01:17:33,440
kernel what what would be the point

01:17:29,389 --> 01:17:35,300
because just I mean I could see us yep

01:17:33,440 --> 01:17:38,239
go back to that other one which shows

01:17:35,300 --> 01:17:39,530
the components for blocking time we have

01:17:38,239 --> 01:17:43,909
a we have a starting point

01:17:39,530 --> 01:17:46,190
yeah but I'm lost on interference I mean

01:17:43,909 --> 01:17:49,880
is that is because you're talking about

01:17:46,190 --> 01:17:53,389
interrupts occurring in preemptions okay

01:17:49,880 --> 01:17:56,389
in the theory interference is any kind

01:17:53,389 --> 01:17:59,809
of highest priority task that preempts

01:17:56,389 --> 01:18:01,309
the current execution so so what are we

01:17:59,809 --> 01:18:03,440
asking there is we've got to put

01:18:01,309 --> 01:18:06,139
something in this task structure that

01:18:03,440 --> 01:18:08,480
says that tracks how many times I've

01:18:06,139 --> 01:18:14,380
been preempted

01:18:08,480 --> 01:18:14,380
yeah and how long right yeah

01:18:16,239 --> 01:18:21,499
yeah I mean and I mean wanna just have

01:18:18,679 --> 01:18:26,090
like the the sketch a point and you have

01:18:21,499 --> 01:18:28,039
Thompson who sees mr. Graham code and

01:18:26,090 --> 01:18:30,260
you could do histograms and actually

01:18:28,039 --> 01:18:33,820
show you like what and do it off of like

01:18:30,260 --> 01:18:36,469
who is pre-empting me yeah yeah yeah

01:18:33,820 --> 01:18:40,489
there yeah yeah that's the point we have

01:18:36,469 --> 01:18:45,679
many kinds of ways to do the same thing

01:18:40,489 --> 01:18:49,329
but what would be the what would be the

01:18:45,679 --> 01:18:52,999
best method sir

01:18:49,329 --> 01:18:54,499
what today the university today the

01:18:52,999 --> 01:19:04,659
universal answer to all these questions

01:18:54,499 --> 01:19:07,670
is BPF of course yeah that simulated 42

01:19:04,659 --> 01:19:09,170
do you plan to use this measurement for

01:19:07,670 --> 01:19:12,139
something that will totally change the

01:19:09,170 --> 01:19:13,610
value of the measurement I'm sorry any

01:19:12,139 --> 01:19:15,679
actions you take as a result of

01:19:13,610 --> 01:19:22,969
measuring this one day totally changed

01:19:15,679 --> 01:19:25,940
the value of the measurement yeah yeah

01:19:22,969 --> 01:19:28,969
but it depends on the order of these

01:19:25,940 --> 01:19:31,010
measurement if takes like milliseconds

01:19:28,969 --> 01:19:32,929
in your measure on nanoseconds it it's

01:19:31,010 --> 01:19:36,110
negligible so I think one of the first

01:19:32,929 --> 01:19:37,760
things you might want to do is so so we

01:19:36,110 --> 01:19:39,829
know blocking we know interference but

01:19:37,760 --> 01:19:43,190
don't you have to others up there or at

01:19:39,829 --> 01:19:48,999
least one sorry you get jittery up there

01:19:43,190 --> 01:19:51,619
right yeah this year so enumerate the

01:19:48,999 --> 01:19:53,179
things we're trying to find just just so

01:19:51,619 --> 01:19:55,760
that we all can see it without having to

01:19:53,179 --> 01:19:56,960
like all right confused me by throwing

01:19:55,760 --> 01:20:01,039
an equation up there and I just can't

01:19:56,960 --> 01:20:03,469
wait yeah but you know if you would just

01:20:01,039 --> 01:20:06,630
give us a list to say okay this jitter

01:20:03,469 --> 01:20:08,670
and point to the diagram say that's

01:20:06,630 --> 01:20:11,489
started interference over here while

01:20:08,670 --> 01:20:16,110
execution is running blocking trying to

01:20:11,489 --> 01:20:18,300
attain a lock that actually looks like

01:20:16,110 --> 01:20:20,250
at all but then an explanation of it and

01:20:18,300 --> 01:20:22,380
then how do we figure it out or is the

01:20:20,250 --> 01:20:25,080
data already there it looks like I'm not

01:20:22,380 --> 01:20:26,429
sure for for activation jitter but it

01:20:25,080 --> 01:20:28,409
looks like for blocking in for

01:20:26,429 --> 01:20:30,960
interference we might have some numbers

01:20:28,409 --> 01:20:32,880
to start with it's just a matter of how

01:20:30,960 --> 01:20:36,690
do we collect it I guess it's not just

01:20:32,880 --> 01:20:41,580
how we collected what are we selected

01:20:36,690 --> 01:20:43,889
yes yeah we could how would we collect

01:20:41,580 --> 01:20:46,739
numbers how would we show you a bunch of

01:20:43,889 --> 01:20:48,420
answers I mean I could tell you a bunch

01:20:46,739 --> 01:20:49,980
of things to do in tracing to get those

01:20:48,420 --> 01:20:51,690
numbers I and to me I'm working out

01:20:49,980 --> 01:20:52,980
trying to get the overhead down I mean

01:20:51,690 --> 01:20:54,360
you don't need I said you don't need

01:20:52,980 --> 01:20:55,860
actual Tracey you just want the

01:20:54,360 --> 01:20:58,260
histograms you know you just want the

01:20:55,860 --> 01:21:01,080
numbers and that actually drops off a

01:20:58,260 --> 01:21:01,860
lot of the overhead and we just make it

01:21:01,080 --> 01:21:03,239
a minimum

01:21:01,860 --> 01:21:05,010
I mean function graphic tracer should be

01:21:03,239 --> 01:21:06,420
able to you do that and you get the

01:21:05,010 --> 01:21:08,730
entry and exit of a function and you

01:21:06,420 --> 01:21:10,260
trace like I said the walk function the

01:21:08,730 --> 01:21:12,090
mutex functions the spin lock function

01:21:10,260 --> 01:21:14,159
is if you just put them to be traced you

01:21:12,090 --> 01:21:15,989
get to enter you exit and that way you

01:21:14,159 --> 01:21:18,389
actually that's one thing I use is he

01:21:15,989 --> 01:21:20,520
okay where how long if these things been

01:21:18,389 --> 01:21:22,230
held like why am i blocked for so long

01:21:20,520 --> 01:21:24,540
and then you use the sketch race points

01:21:22,230 --> 01:21:27,030
to do I said the pseudo events to get to

01:21:24,540 --> 01:21:28,469
that just doesn't recall it does it does

01:21:27,030 --> 01:21:30,719
the histograms it doesn't do any

01:21:28,469 --> 01:21:33,540
recording of the events itself you just

01:21:30,719 --> 01:21:35,940
get a nice histogram of so then looking

01:21:33,540 --> 01:21:38,850
at what preempted you so your your

01:21:35,940 --> 01:21:41,909
suggestion would be using the doing the

01:21:38,850 --> 01:21:44,880
processing in the kernel using the F

01:21:41,909 --> 01:21:46,800
crease interface not tracing but yet in

01:21:44,880 --> 01:21:48,889
the numbers and store in there and put

01:21:46,800 --> 01:21:51,570
in the interface there yes

01:21:48,889 --> 01:21:55,110
that's something I also agree it's a

01:21:51,570 --> 01:21:57,739
good a good way to proceed but is there

01:21:55,110 --> 01:22:02,300
any other way that people would suggest

01:21:57,739 --> 01:22:04,830
you want people that suggest BPF right

01:22:02,300 --> 01:22:06,420
are you asking that anything else people

01:22:04,830 --> 01:22:10,530
don't know but the problem is that I I

01:22:06,420 --> 01:22:12,600
agree with you if okay when I was doing

01:22:10,530 --> 01:22:15,030
this thing now what do we do okay

01:22:12,600 --> 01:22:16,320
connecting with the the previous

01:22:15,030 --> 01:22:19,660
presentation

01:22:16,320 --> 01:22:23,920
here I will collected very fine granite

01:22:19,660 --> 01:22:27,850
events what 10 seconds of tracing

01:22:23,920 --> 01:22:30,370
collects me 1 gig of data so I was

01:22:27,850 --> 01:22:33,010
picking out these traces with trace

01:22:30,370 --> 01:22:36,370
points and then grabbing then in

01:22:33,010 --> 01:22:38,620
userspace and processing with perf it

01:22:36,370 --> 01:22:42,100
works fine but I need to allocate all my

01:22:38,620 --> 01:22:44,350
memory to the tracing so I was planning

01:22:42,100 --> 01:22:46,590
to bring it work it fine to validated

01:22:44,350 --> 01:22:49,960
model but now that I want to extract

01:22:46,590 --> 01:22:53,890
metrics like a copying data to user

01:22:49,960 --> 01:22:56,740
space it's it's costly and I cannot do

01:22:53,890 --> 01:22:58,900
longer analysis I need to do like every

01:22:56,740 --> 01:23:00,760
30 seconds they stopped doing analysis

01:22:58,900 --> 01:23:04,210
every 30 seconds trace and I was again

01:23:00,760 --> 01:23:06,310
so my idea is to continue you don't want

01:23:04,210 --> 01:23:09,160
all of that data right all you want is

01:23:06,310 --> 01:23:10,770
just know that ok now that's what that's

01:23:09,160 --> 01:23:13,750
what I'm doing now to validate the model

01:23:10,770 --> 01:23:16,030
now what I was thinking is that ok I

01:23:13,750 --> 01:23:18,910
don't need to collect all the trace I

01:23:16,030 --> 01:23:21,370
just need after setting the matrix I

01:23:18,910 --> 01:23:23,110
will need to catch information on these

01:23:21,370 --> 01:23:28,060
trace points but I don't need the trace

01:23:23,110 --> 01:23:30,670
point the trace data I need the hooks on

01:23:28,060 --> 01:23:33,040
that that points but I don't need to the

01:23:30,670 --> 01:23:36,790
trace information I just need to process

01:23:33,040 --> 01:23:40,360
that information on on the matrix is the

01:23:36,790 --> 01:23:43,260
method II that Steven mentioned the way

01:23:40,360 --> 01:23:43,260
that I should go

01:23:50,990 --> 01:23:59,120
would be to register to the trace point

01:23:59,540 --> 01:24:06,570
I think I'll repair things I make sure I

01:24:05,400 --> 01:24:08,340
get right you say just write a kernel

01:24:06,570 --> 01:24:09,630
module that hooks into the trace points

01:24:08,340 --> 01:24:12,000
that you want or the function graph

01:24:09,630 --> 01:24:14,640
tracer just put a hook in there and get

01:24:12,000 --> 01:24:16,290
the bare minimum tracing so that could

01:24:14,640 --> 01:24:18,480
drop to overhead and I said it I would

01:24:16,290 --> 01:24:21,750
suggest that if the normal tooling

01:24:18,480 --> 01:24:23,070
proves to be too much of overhead and

01:24:21,750 --> 01:24:27,090
maybe you could do that just to try it

01:24:23,070 --> 01:24:32,490
and see if it does already output of

01:24:27,090 --> 01:24:34,860
tools so I have this generate code yeah

01:24:32,490 --> 01:24:36,690
actually when you do a module you can do

01:24:34,860 --> 01:24:40,530
even correlation on it

01:24:36,690 --> 01:24:43,350
per task level and then store that data

01:24:40,530 --> 01:24:48,650
and yet that separately out so you're

01:24:43,350 --> 01:24:52,590
not limited on on the restrictions were

01:24:48,650 --> 01:24:56,250
thing is which is which are in F trace

01:24:52,590 --> 01:24:58,920
or proof of whatever so you can just do

01:24:56,250 --> 01:25:01,110
more flexible analysis but you can reuse

01:24:58,920 --> 01:25:03,450
all that existing price points for that

01:25:01,110 --> 01:25:06,060
okay just by hooking into it and you

01:25:03,450 --> 01:25:11,070
have most of the information you need is

01:25:06,060 --> 01:25:13,230
already dear yeah so okay so we the idea

01:25:11,070 --> 01:25:16,410
was the consensus that we need to hook

01:25:13,230 --> 01:25:21,240
on these places and then we can either

01:25:16,410 --> 01:25:25,170
or store this data on per CPU or per

01:25:21,240 --> 01:25:28,800
task information or to you or to write a

01:25:25,170 --> 01:25:31,040
plug-in on F trace to use it or load a

01:25:28,800 --> 01:25:31,040
module

01:25:34,730 --> 01:25:41,429
yeah but the one question now I'm using

01:25:39,480 --> 01:25:47,329
trace points here that are not present

01:25:41,429 --> 01:25:50,460
on colonel and but we might not add

01:25:47,329 --> 01:25:55,500
someone might not want to edit it more

01:25:50,460 --> 01:26:00,690
trace points on the schedule okay before

01:25:55,500 --> 01:26:03,539
in this lamp so so I don't like trace

01:26:00,690 --> 01:26:08,960
events thingies but I I don't mind just

01:26:03,539 --> 01:26:12,090
adding to draw hooks okay okay that's

01:26:08,960 --> 01:26:16,940
versus we can't add the trace okay so

01:26:12,090 --> 01:26:20,010
the row looks we used to be able to know

01:26:16,940 --> 01:26:21,719
okay terminology is trace points are

01:26:20,010 --> 01:26:26,369
actually the hooks trace events is the

01:26:21,719 --> 01:26:27,840
what you see in the right now right the

01:26:26,369 --> 01:26:30,270
only way to add a trace point I try to

01:26:27,840 --> 01:26:32,489
avoid it but if we do at the trace look

01:26:30,270 --> 01:26:34,770
what happens if the only thing that the

01:26:32,489 --> 01:26:36,119
trace man gives you is a value of a

01:26:34,770 --> 01:26:38,369
pointer that doesn't even give you the

01:26:36,119 --> 01:26:41,849
actual it's an encrypted pointer so it's

01:26:38,369 --> 01:26:43,770
basically a useless trace event that no

01:26:41,849 --> 01:26:48,599
one could build off of but anyone can

01:26:43,770 --> 01:26:50,400
hook to but reasonable okay the reason

01:26:48,599 --> 01:26:51,750
why I say that is because I really don't

01:26:50,400 --> 01:26:53,429
want to open up the can of worms so

01:26:51,750 --> 01:26:54,780
people injecting trace of that trace

01:26:53,429 --> 01:26:56,909
points all over the place too because

01:26:54,780 --> 01:26:58,440
right now those because we used to be

01:26:56,909 --> 01:27:02,389
able to do that that's how much I

01:26:58,440 --> 01:27:04,409
started all that it's it started with

01:27:02,389 --> 01:27:07,050
actually ever year made it to a version

01:27:04,409 --> 01:27:08,849
I think we did that in a release cycle

01:27:07,050 --> 01:27:09,389
and actually changed before actually was

01:27:08,849 --> 01:27:12,750
released

01:27:09,389 --> 01:27:14,639
possibly but yeah I mean original code

01:27:12,750 --> 01:27:15,869
was added to make the trace event the

01:27:14,639 --> 01:27:18,570
trace points were added to these events

01:27:15,869 --> 01:27:22,199
because we were one much Oh first the

01:27:18,570 --> 01:27:28,050
trace hooks and then you did events of

01:27:22,199 --> 01:27:30,420
it yeah we can only do with them therese

01:27:28,050 --> 01:27:32,429
marker but just have a way of just

01:27:30,420 --> 01:27:33,869
saying here's a trace point but i said

01:27:32,429 --> 01:27:35,489
right now we get away back just say it

01:27:33,869 --> 01:27:36,179
tracing that with just the pointer

01:27:35,489 --> 01:27:38,610
values

01:27:36,179 --> 01:27:41,190
and really you can't build any user

01:27:38,610 --> 01:27:42,480
space tools on top of that because you

01:27:41,190 --> 01:27:44,250
all you're getting is a pointer value

01:27:42,480 --> 01:27:48,420
it's kind of useless and it's encrypted

01:27:44,250 --> 01:27:50,969
by today's randomness so so so but

01:27:48,420 --> 01:27:56,610
ideally so ideally we're not even expose

01:27:50,969 --> 01:27:57,840
it to user space at all not ideally you

01:27:56,610 --> 01:27:59,040
want that you might get it still there

01:27:57,840 --> 01:28:00,150
you'll still see him there and that well

01:27:59,040 --> 01:28:06,810
I'd being useful because then you be

01:28:00,150 --> 01:28:12,540
able to hook PPF to it can can we can we

01:28:06,810 --> 01:28:15,390
put hooks in there I scare deadline I'm

01:28:12,540 --> 01:28:17,400
in for first get that line we need one

01:28:15,390 --> 01:28:20,219
or two more hooks because most of the

01:28:17,400 --> 01:28:22,290
existing ones are sufficient if you use

01:28:20,219 --> 01:28:25,140
them as hooks they're not sufficient if

01:28:22,290 --> 01:28:29,100
you use them as events because the

01:28:25,140 --> 01:28:30,570
actual event code doesn't know they're

01:28:29,100 --> 01:28:33,780
in the right location they have the

01:28:30,570 --> 01:28:36,630
information available but yeah I mean

01:28:33,780 --> 01:28:38,850
actually if it's there you get

01:28:36,630 --> 01:28:40,620
everything you want some BBS - if the

01:28:38,850 --> 01:28:43,530
hook is there all the event orchestra

01:28:40,620 --> 01:28:49,080
module or a custom module anything that

01:28:43,530 --> 01:28:50,400
yes it won't be that normal

01:28:49,080 --> 01:28:55,199
it won't have information there that's

01:28:50,400 --> 01:28:58,050
you know you get from the trace point so

01:28:55,199 --> 01:28:58,800
am I free to suggest hooks okay okay

01:28:58,050 --> 01:29:01,159
okay

01:28:58,800 --> 01:29:01,159
thank you

01:29:02,570 --> 01:29:07,820
one thing that the Daniels and that

01:29:05,420 --> 01:29:12,320
caught my attention is to characterize

01:29:07,820 --> 01:29:14,990
the the latency so to the the order of

01:29:12,320 --> 01:29:18,590
the events the order of the components

01:29:14,990 --> 01:29:21,560
of the latency we already have ways to

01:29:18,590 --> 01:29:24,800
to measure the latency maybe it would be

01:29:21,560 --> 01:29:25,670
nice to also have these disorder oh so

01:29:24,800 --> 01:29:29,480
happen

01:29:25,670 --> 01:29:31,370
I our key irq it was brokered and then I

01:29:29,480 --> 01:29:34,190
got this latency well then you need a

01:29:31,370 --> 01:29:35,090
full trace yeah but with the hooks

01:29:34,190 --> 01:29:39,260
that's easy

01:29:35,090 --> 01:29:40,880
yeah and I just need the order saying

01:29:39,260 --> 01:29:44,840
okay so this seems like a stack trace

01:29:40,880 --> 01:29:47,180
type of thing just recording yeah so we

01:29:44,840 --> 01:29:48,800
can put dynamic and and you can put

01:29:47,180 --> 01:29:53,630
dynamic trace events like with your

01:29:48,800 --> 01:29:56,660
hooks to editor to do that here the

01:29:53,630 --> 01:29:58,190
synthetic events yeah yeah you actually

01:29:56,660 --> 01:30:00,500
make synthetic events built on top of

01:29:58,190 --> 01:30:02,420
them yeah and the hooks simplify

01:30:00,500 --> 01:30:04,250
everything like having the hook we can

01:30:02,420 --> 01:30:06,530
use other techniques and then we can

01:30:04,250 --> 01:30:08,060
okay even develop a trace to measure

01:30:06,530 --> 01:30:12,850
this and now we're just doing a

01:30:08,060 --> 01:30:12,850
scheduling switch okay for break time

01:30:14,610 --> 01:30:22,610
[Applause]

01:30:20,000 --> 01:30:25,210
so yeah but basically this is a

01:30:22,610 --> 01:30:28,190
continuation of the this morning a

01:30:25,210 --> 01:30:30,260
presentation about basically coming next

01:30:28,190 --> 01:30:34,370
in skedaddling we just thought that

01:30:30,260 --> 01:30:36,410
since there are lot of points up for

01:30:34,370 --> 01:30:39,350
discussion and interesting to implement

01:30:36,410 --> 01:30:43,640
I guess the purpose with this is to just

01:30:39,350 --> 01:30:46,910
peek a few one to three items that we

01:30:43,640 --> 01:30:47,900
think award implement in looking at like

01:30:46,910 --> 01:30:50,600
in the near future

01:30:47,900 --> 01:30:52,520
I kind of already made my choice but

01:30:50,600 --> 01:30:54,500
then it's up for discussion if I should

01:30:52,520 --> 01:30:56,840
continue doing that or maybe move to

01:30:54,500 --> 01:31:00,500
something else and s3 happens for Danny

01:30:56,840 --> 01:31:02,180
and if anyone actually wants to work on

01:31:00,500 --> 01:31:04,490
something after this is more than

01:31:02,180 --> 01:31:09,680
welcome because there's a lot of work to

01:31:04,490 --> 01:31:11,480
be done so I well that's up for

01:31:09,680 --> 01:31:13,460
discussion I can either basically I have

01:31:11,480 --> 01:31:16,100
the list of points that I discussed

01:31:13,460 --> 01:31:20,900
discussed this morning but I have also

01:31:16,100 --> 01:31:27,020
there are basic decision rights of

01:31:20,900 --> 01:31:30,650
course yeah maybe yeah okay yeah we do

01:31:27,020 --> 01:31:31,520
that but first of all there is this

01:31:30,650 --> 01:31:33,980
light right

01:31:31,520 --> 01:31:38,810
are you actually putting this on your

01:31:33,980 --> 01:31:43,340
slides yeah because basically when this

01:31:38,810 --> 01:31:46,460
guy he told us on IRC that he's using

01:31:43,340 --> 01:31:48,950
scheduling own products then we kind of

01:31:46,460 --> 01:31:50,570
agree that I mean my my thing was

01:31:48,950 --> 01:31:52,580
actually I'm gonna put these lights on

01:31:50,570 --> 01:31:54,170
every presentation I'm doing about

01:31:52,580 --> 01:31:58,520
scattering because there was kind of

01:31:54,170 --> 01:32:00,590
good thing for me because so anyway and

01:31:58,520 --> 01:32:05,330
when that happen klarka came to me on

01:32:00,590 --> 01:32:06,650
our scene who did you see there are us a

01:32:05,330 --> 01:32:10,150
always want to read these for a long

01:32:06,650 --> 01:32:12,620
time okay that's good thing anyway

01:32:10,150 --> 01:32:17,780
that's basically what I presented this

01:32:12,620 --> 01:32:19,790
morning apart from this first point

01:32:17,780 --> 01:32:21,650
rather than touch this morning that's up

01:32:19,790 --> 01:32:24,380
for discussion actually currently only

01:32:21,650 --> 01:32:27,350
only meaning least I don't have slides

01:32:24,380 --> 01:32:31,250
for the first point and just basically

01:32:27,350 --> 01:32:33,230
this is the point a problem pointed out

01:32:31,250 --> 01:32:36,440
by a and that's you

01:32:33,230 --> 01:32:38,660
split that happen like a month ago on

01:32:36,440 --> 01:32:40,160
the corner and we visit I started

01:32:38,660 --> 01:32:41,989
discussing this thing and actually

01:32:40,160 --> 01:32:44,270
trying to understand what was going on

01:32:41,989 --> 01:32:47,830
and in the particular case the

01:32:44,270 --> 01:32:50,960
reproducer was a simple deadline task

01:32:47,830 --> 01:32:54,410
which was using per phone itself so Jen

01:32:50,960 --> 01:32:57,140
basically auto-generating IQ load on

01:32:54,410 --> 01:32:59,210
itself the point with the problem with

01:32:57,140 --> 01:33:02,050
that well the problem how deadly works

01:32:59,210 --> 01:33:07,160
today is that we do run some enforcement

01:33:02,050 --> 01:33:11,260
using our cue clock task which on system

01:33:07,160 --> 01:33:14,120
configure without queue accounting

01:33:11,260 --> 01:33:16,310
basically you have a skew between the

01:33:14,120 --> 01:33:18,500
clock that we're using to perform

01:33:16,310 --> 01:33:21,200
runtime enforcement and the clock were

01:33:18,500 --> 01:33:23,450
using to actually reset the deadline so

01:33:21,200 --> 01:33:27,380
it is possible for basically tasks that

01:33:23,450 --> 01:33:29,750
actually has a high EQ load to barely be

01:33:27,380 --> 01:33:32,030
outside the runtime enforcement in the

01:33:29,750 --> 01:33:35,480
particular case that task will would

01:33:32,030 --> 01:33:38,870
actually do a kind of wild one loop and

01:33:35,480 --> 01:33:41,420
was causing starvation to the others so

01:33:38,870 --> 01:33:43,220
that's something we had to discuss and

01:33:41,420 --> 01:33:44,900
fix it there are but we already

01:33:43,220 --> 01:33:48,440
discussed the thing on a minute is quite

01:33:44,900 --> 01:33:50,210
quite a lot but let me first I guess go

01:33:48,440 --> 01:33:53,570
to the other points quickly so that

01:33:50,210 --> 01:33:54,230
everybody is on the same page non real

01:33:53,570 --> 01:33:56,870
usage

01:33:54,230 --> 01:34:00,440
so today Aska deadlines usage is

01:33:56,870 --> 01:34:03,860
reserved only for YouTube users this guy

01:34:00,440 --> 01:34:06,170
was wondering why and I was kind of

01:34:03,860 --> 01:34:09,020
trying to use deadline for a user space

01:34:06,170 --> 01:34:12,710
audio application so you wonder why I'm

01:34:09,020 --> 01:34:16,000
not supposed to be able to use that from

01:34:12,710 --> 01:34:19,760
user space and there are a couple of

01:34:16,000 --> 01:34:21,739
reasons why we don't allow that yet one

01:34:19,760 --> 01:34:22,970
is because we don't have the same

01:34:21,739 --> 01:34:25,370
priority inheritance mechanism

01:34:22,970 --> 01:34:27,950
implemented right now which is dangerous

01:34:25,370 --> 01:34:34,010
potentially dangerous for not you root

01:34:27,950 --> 01:34:37,100
usage and we don't have a seen interface

01:34:34,010 --> 01:34:41,840
to manage potentially managed binary for

01:34:37,100 --> 01:34:44,180
not root users the first point the

01:34:41,840 --> 01:34:46,959
parrot inheritance point might be cure

01:34:44,180 --> 01:34:49,599
with the what basically called

01:34:46,959 --> 01:34:52,389
proxy execution so basically I started

01:34:49,599 --> 01:34:54,070
working on Peters batches and I posted

01:34:52,389 --> 01:34:57,400
the first version of this thing what it

01:34:54,070 --> 01:34:59,439
is about I guess everybody's Alinea with

01:34:57,400 --> 01:35:02,110
the priority inversion and how

01:34:59,439 --> 01:35:05,199
inheritance fixes the problem

01:35:02,110 --> 01:35:09,189
currently we inherit only the deadlines

01:35:05,199 --> 01:35:15,880
of the blocked task for deadlines that

01:35:09,189 --> 01:35:18,280
has a problem that we are actually music

01:35:15,880 --> 01:35:20,530
relaxing the I mean removing me runtime

01:35:18,280 --> 01:35:22,749
enforcement for the Oscar are boosted so

01:35:20,530 --> 01:35:26,409
for example this case the low priority

01:35:22,749 --> 01:35:29,409
guy here inherits the deadline of this

01:35:26,409 --> 01:35:31,420
guy and is actually outside the runtime

01:35:29,409 --> 01:35:33,249
enforcement so you can actually drop on

01:35:31,420 --> 01:35:35,260
eyes whatever else is not that easy so

01:35:33,249 --> 01:35:39,760
that's really bad for especially for not

01:35:35,260 --> 01:35:42,729
root users we props execution so the

01:35:39,760 --> 01:35:46,179
idea would be to use the scheduling

01:35:42,729 --> 01:35:49,090
information of the donor

01:35:46,179 --> 01:35:51,880
so whoever blocks on the mutex to

01:35:49,090 --> 01:35:55,360
actually use this information on the on

01:35:51,880 --> 01:35:58,030
the owner and inside for example the

01:35:55,360 --> 01:35:59,920
schedule and entity you have a runtime

01:35:58,030 --> 01:36:04,329
and Peter the deadline of the daughter

01:35:59,920 --> 01:36:06,820
so you can actually use that and without

01:36:04,329 --> 01:36:09,969
the need for disabling random

01:36:06,820 --> 01:36:13,150
enforcement that's one of the things

01:36:09,969 --> 01:36:16,119
that's basically as being kind of my

01:36:13,150 --> 01:36:18,909
call on what seems highest priority to

01:36:16,119 --> 01:36:22,599
work on because if we manage to

01:36:18,909 --> 01:36:25,300
implement and fix this problem then one

01:36:22,599 --> 01:36:28,780
of the biggest two points that we want

01:36:25,300 --> 01:36:32,110
to solve to be able to give no root

01:36:28,780 --> 01:36:35,530
access to scheduling is gonna fix so

01:36:32,110 --> 01:36:39,820
that's what I'm working on and the other

01:36:35,530 --> 01:36:41,889
point is about this is the process

01:36:39,820 --> 01:36:43,689
usually might be actually more general

01:36:41,889 --> 01:36:46,599
than just ask a data and stuff but

01:36:43,689 --> 01:36:48,880
that's yeah the other point is a C group

01:36:46,599 --> 01:36:51,489
support so currently we don't have at

01:36:48,880 --> 01:36:52,630
all group support the just the squared

01:36:51,489 --> 01:36:56,170
set rot

01:36:52,630 --> 01:36:59,060
sis call that a user can ask to

01:36:56,170 --> 01:37:02,870
associate a runtime

01:36:59,060 --> 01:37:05,630
period to a single thread it might be

01:37:02,870 --> 01:37:10,300
handy to have group support there are

01:37:05,630 --> 01:37:13,880
two ways more to let's say level of

01:37:10,300 --> 01:37:17,620
implementing this one could be and

01:37:13,880 --> 01:37:20,960
actually already proposed an RFC of this

01:37:17,620 --> 01:37:24,710
to just extend the interface we already

01:37:20,960 --> 01:37:29,650
have on the CPU controller for scale

01:37:24,710 --> 01:37:34,730
five or so fix priority RT to also

01:37:29,650 --> 01:37:37,580
basically manage the been read we can

01:37:34,730 --> 01:37:39,590
assign to two deadlines so extending

01:37:37,580 --> 01:37:44,210
basically the interface with these two

01:37:39,590 --> 01:37:46,580
parameters and in that way the system

01:37:44,210 --> 01:37:49,630
owner so whoever has root access can

01:37:46,580 --> 01:37:52,940
distribute the available bandwidth among

01:37:49,630 --> 01:37:55,760
normal users they might be wanting first

01:37:52,940 --> 01:37:57,740
thing we want to to have and the second

01:37:55,760 --> 01:38:00,410
one which is more tricky to to implement

01:37:57,740 --> 01:38:03,350
and to handle in general because there

01:38:00,410 --> 01:38:07,460
are like points that are not clear yet

01:38:03,350 --> 01:38:10,490
how to be handle implemented he is

01:38:07,460 --> 01:38:13,520
complete in full hierarchical scheduling

01:38:10,490 --> 01:38:17,300
where you have to route a two-level

01:38:13,520 --> 01:38:19,460
scheduler at the root level you have you

01:38:17,300 --> 01:38:22,580
can have a single entities like these

01:38:19,460 --> 01:38:25,960
three and an entity which is actually a

01:38:22,580 --> 01:38:28,280
group which is the same thing as CFS and

01:38:25,960 --> 01:38:30,500
they are doing so at the first level you

01:38:28,280 --> 01:38:33,350
select considering the the deadlines of

01:38:30,500 --> 01:38:35,900
those and then inside here you rerun

01:38:33,350 --> 01:38:39,290
basically a scheduler the peaks the FIFO

01:38:35,900 --> 01:38:42,290
tasks right inside here it would be kind

01:38:39,290 --> 01:38:44,960
of might be helpful in situation where

01:38:42,290 --> 01:38:47,720
you have let's say a set of tasks that

01:38:44,960 --> 01:38:51,380
they share common let's say go in this

01:38:47,720 --> 01:38:55,730
case I made it a sec an example of a

01:38:51,380 --> 01:38:57,740
pipeline of tasks if you don't have the

01:38:55,730 --> 01:38:59,480
group support I mean the hierarchy calls

01:38:57,740 --> 01:39:01,490
group support and that's the situation

01:38:59,480 --> 01:39:04,520
of today you have to go there and

01:39:01,490 --> 01:39:06,920
specify deadlines runtime for each one

01:39:04,520 --> 01:39:09,560
of those which might be tricky because

01:39:06,920 --> 01:39:12,560
you don't really probably know how they

01:39:09,560 --> 01:39:16,670
they fit together if you have the

01:39:12,560 --> 01:39:18,500
Rico mechanism implemented you are left

01:39:16,670 --> 01:39:21,230
with just two parameters you have the

01:39:18,500 --> 01:39:23,420
deadline imputed for the whole pipeline

01:39:21,230 --> 01:39:25,610
and the runtime for the whole thing

01:39:23,420 --> 01:39:34,910
so it might be simpler to get it right

01:39:25,610 --> 01:39:37,970
yes yes there is RT analysis you can

01:39:34,910 --> 01:39:41,140
perform to say that whatever you put

01:39:37,970 --> 01:39:43,940
inside here has some guarantees

01:39:41,140 --> 01:39:47,150
theoretical guarantees so there is some

01:39:43,940 --> 01:39:49,220
analysis but fortunately the theory

01:39:47,150 --> 01:39:51,560
should be already covered as far as I

01:39:49,220 --> 01:39:53,830
know so yeah we just need to implement

01:39:51,560 --> 01:39:53,830
this thing

01:39:55,510 --> 01:40:03,170
yeah the for example one of the problems

01:39:58,460 --> 01:40:05,540
that although this idea has is at least

01:40:03,170 --> 01:40:09,200
how its implemented right now that was

01:40:05,540 --> 01:40:10,760
an IFC kind of a year ago posted and

01:40:09,200 --> 01:40:12,230
that's the it's a reference

01:40:10,760 --> 01:40:15,830
implementation of course we can change

01:40:12,230 --> 01:40:19,250
that is the way we implement is once we

01:40:15,830 --> 01:40:21,500
have the runtime so the bandwidth it

01:40:19,250 --> 01:40:24,700
associated with the group that bandwidth

01:40:21,500 --> 01:40:28,040
in this case is this red big red block

01:40:24,700 --> 01:40:31,670
here is actually replicated on each CPU

01:40:28,040 --> 01:40:35,240
and you might have for example a case

01:40:31,670 --> 01:40:38,270
where one the CPU is actually not

01:40:35,240 --> 01:40:42,170
consuming the bandwidth and there might

01:40:38,270 --> 01:40:46,130
be a basic waste of bandwidth in this

01:40:42,170 --> 01:40:47,780
case one way to fix that we as I

01:40:46,130 --> 01:40:50,750
mentioned this morning might be to

01:40:47,780 --> 01:40:52,640
reclaim the ANU spend it and that's

01:40:50,750 --> 01:40:54,880
already something that we have in the

01:40:52,640 --> 01:40:54,880
kernel

01:41:03,730 --> 01:41:07,720
suppose you have a machine

01:41:08,950 --> 01:41:22,040
and you have won one of these groups

01:41:14,450 --> 01:41:25,040
that requires say 70% of two CPUs then

01:41:22,040 --> 01:41:26,960
you make a C group and you're lost 70%

01:41:25,040 --> 01:41:29,720
of all 200 of your CPUs

01:41:26,960 --> 01:41:33,260
I guess you referred to affected Mission

01:41:29,720 --> 01:41:35,540
Control already basically checks that so

01:41:33,260 --> 01:41:37,520
even though we might cope we'd be in the

01:41:35,540 --> 01:41:48,800
problem run sign that's already too late

01:41:37,520 --> 01:41:50,960
right so so the only question is whether

01:41:48,800 --> 01:41:53,330
you're going to have as an extra

01:41:50,960 --> 01:41:55,130
parameter for the C group because you

01:41:53,330 --> 01:41:58,220
know up front that you're going to need

01:41:55,130 --> 01:42:03,290
two or four CPUs in the worst case if

01:41:58,220 --> 01:42:05,120
you limit it to that yes I guess you

01:42:03,290 --> 01:42:06,860
also need to know the affinities or

01:42:05,120 --> 01:42:11,140
those tasks or at least this if you ask

01:42:06,860 --> 01:42:14,300
I mean the CPUs they might be running on

01:42:11,140 --> 01:42:18,230
so you can restrict that you can require

01:42:14,300 --> 01:42:21,710
to be to that to be known up front and

01:42:18,230 --> 01:42:24,350
if it's not known just reject it I mean

01:42:21,710 --> 01:42:27,320
I think like what Thomas is saying is

01:42:24,350 --> 01:42:28,730
the fact that what you need is I think a

01:42:27,320 --> 01:42:30,710
partition you need to see groups a

01:42:28,730 --> 01:42:35,150
partition it and say you know you can

01:42:30,710 --> 01:42:36,950
say I need these two CPUs to run so you

01:42:35,150 --> 01:42:38,360
pick two CPUs you have it so it may have

01:42:36,950 --> 01:42:40,160
to be a penalty maybe just like you have

01:42:38,360 --> 01:42:42,200
to as part of the C groups to say that

01:42:40,160 --> 01:42:43,730
these two and then you could do whatever

01:42:42,200 --> 01:42:45,650
you want there it doesn't have to rest

01:42:43,730 --> 01:42:48,410
of the machine so partition it nicely

01:42:45,650 --> 01:42:50,720
and then you could do a lot of a lot

01:42:48,410 --> 01:42:53,240
more easier scheduling actually this

01:42:50,720 --> 01:42:55,340
fits all so well with what Daniel I

01:42:53,240 --> 01:42:58,910
guess is gonna say in a beta I just

01:42:55,340 --> 01:43:01,220
wondering if since I mean I'm basically

01:42:58,910 --> 01:43:03,020
jumping and the next thing but the axiom

01:43:01,220 --> 01:43:05,390
will be actually to replace potentially

01:43:03,020 --> 01:43:08,540
place the RT throatily mechanism using

01:43:05,390 --> 01:43:11,210
the deadlines the very same thing what I

01:43:08,540 --> 01:43:13,490
was wondering if sorry just finished was

01:43:11,210 --> 01:43:15,200
wondering if we actually impose this

01:43:13,490 --> 01:43:18,980
restriction is actually a change of

01:43:15,200 --> 01:43:20,080
paradigm to what RT throttling is

01:43:18,980 --> 01:43:21,550
actually doing

01:43:20,080 --> 01:43:23,260
well actually one thing I was just

01:43:21,550 --> 01:43:25,030
talking to someone else earlier and I

01:43:23,260 --> 01:43:26,920
said you know there's there's two things

01:43:25,030 --> 01:43:28,900
you have deadline scheduling which is I

01:43:26,920 --> 01:43:31,030
think very very strict as strict rules

01:43:28,900 --> 01:43:32,890
but then there's also cpu bandwidth

01:43:31,030 --> 01:43:34,660
which is not as strict and you just

01:43:32,890 --> 01:43:37,420
basically don't worry about you just

01:43:34,660 --> 01:43:40,060
percentage wise and then allow you know

01:43:37,420 --> 01:43:42,520
no guarantees now if I would say have a

01:43:40,060 --> 01:43:44,830
CPU bandwidth that controls the are team

01:43:42,520 --> 01:43:46,360
tasks everything else I mean why can't

01:43:44,830 --> 01:43:48,940
you like do it like they build the

01:43:46,360 --> 01:43:50,890
actual more the stricter deadlines

01:43:48,940 --> 01:43:54,720
scheduler on top of that so you mean

01:43:50,890 --> 01:43:59,380
moving the RT tasks you to use these he

01:43:54,720 --> 01:44:00,760
CPU Basel II memory and then because we

01:43:59,380 --> 01:44:02,080
don't really care if we miss it's just

01:44:00,760 --> 01:44:03,730
basically we don't want to starve the

01:44:02,080 --> 01:44:05,560
whole idea of the RT throttling is that

01:44:03,730 --> 01:44:07,060
you don't starve the system so you don't

01:44:05,560 --> 01:44:08,050
care about missing deadlines or not

01:44:07,060 --> 01:44:10,420
you're just saying I just want a

01:44:08,050 --> 01:44:11,830
percentage as one CP bandwidth but but I

01:44:10,420 --> 01:44:14,290
think that we are dealing with two

01:44:11,830 --> 01:44:16,780
problems one is traveling that is for

01:44:14,290 --> 01:44:21,310
this case and another is when we have a

01:44:16,780 --> 01:44:23,830
chain of I'd say jobs that are done by

01:44:21,310 --> 01:44:27,700
different threads but they are part of

01:44:23,830 --> 01:44:30,310
the same task for example the audio

01:44:27,700 --> 01:44:32,350
pipeline we have just one task which is

01:44:30,310 --> 01:44:35,260
produced the audio pipeline but it's

01:44:32,350 --> 01:44:39,610
composed of many threads and then we use

01:44:35,260 --> 01:44:42,780
the hierarchical for this case and but

01:44:39,610 --> 01:44:42,780
it's different of the track

01:44:45,770 --> 01:44:53,120
no just a percentage of time it doesn't

01:44:51,600 --> 01:44:57,090
mean anything

01:44:53,120 --> 01:44:59,610
yeah but it I mean I say like you don't

01:44:57,090 --> 01:45:00,330
I can give you hundred fifty percent of

01:44:59,610 --> 01:45:04,290
my time

01:45:00,330 --> 01:45:06,330
it doesn't mean doesn't it by when I

01:45:04,290 --> 01:45:07,620
mean I can I can spend some time with

01:45:06,330 --> 01:45:09,540
you in a hundred years

01:45:07,620 --> 01:45:12,000
yeah I know that would still be 50

01:45:09,540 --> 01:45:13,710
percent yeah I know I'm saying well my

01:45:12,000 --> 01:45:18,480
question is if the problem is with the

01:45:13,710 --> 01:45:20,190
it's impossible to do a true what's

01:45:18,480 --> 01:45:21,360
called a deadline scheduler among

01:45:20,190 --> 01:45:23,790
multiple CPU and a lot of different

01:45:21,360 --> 01:45:32,990
affinities and all that but if you were

01:45:23,790 --> 01:45:37,020
to say okay very close to something that

01:45:32,990 --> 01:45:41,430
relates to this or maybe you can just

01:45:37,020 --> 01:45:44,340
talk about this I mean will that solve

01:45:41,430 --> 01:45:45,810
the ideas like can we put RT tasks which

01:45:44,340 --> 01:45:52,110
could have any type of affinities we

01:45:45,810 --> 01:45:55,560
want into that so we need to look good

01:45:52,110 --> 01:45:58,830
so missing on that list so the number of

01:45:55,560 --> 01:46:01,230
users needs proxy execution but it also

01:45:58,830 --> 01:46:04,710
needs some other limits but that's

01:46:01,230 --> 01:46:06,450
mostly sort of after that I would very

01:46:04,710 --> 01:46:09,960
strongly suggest we look at the same

01:46:06,450 --> 01:46:11,690
partition stuff before doing any of the

01:46:09,960 --> 01:46:14,910
other things

01:46:11,690 --> 01:46:16,650
so you've seen basically well this is

01:46:14,910 --> 01:46:19,260
the highest priority and that's what I'm

01:46:16,650 --> 01:46:24,480
working on the proxy execution might

01:46:19,260 --> 01:46:28,860
take a while but then instead of

01:46:24,480 --> 01:46:31,110
lamenting the area code thing moving to

01:46:28,860 --> 01:46:33,650
maybe what Daniel is working on because

01:46:31,110 --> 01:46:33,650
it yeah

01:46:41,190 --> 01:46:46,100
I just oh okay

01:46:44,220 --> 01:46:51,270
these topics are related but they are

01:46:46,100 --> 01:46:56,340
okay just explain something again same

01:46:51,270 --> 01:47:00,840
thing okay I'm tired that's the fourth

01:46:56,340 --> 01:47:03,930
presentation they currently Judy was

01:47:00,840 --> 01:47:07,620
talking about hierarchical scheduling in

01:47:03,930 --> 01:47:10,080
which inside what is a do tasks now

01:47:07,620 --> 01:47:12,990
nowadays we would be able to put more

01:47:10,080 --> 01:47:15,390
tasks inside and use that bandwidth be

01:47:12,990 --> 01:47:18,570
scheduled using the deadline parameters

01:47:15,390 --> 01:47:20,730
that's one thing we have another thing

01:47:18,570 --> 01:47:23,670
that seems to be related which is the

01:47:20,730 --> 01:47:28,530
real time traveling the real time

01:47:23,670 --> 01:47:30,780
traveling is one way to safeguard normal

01:47:28,530 --> 01:47:35,570
tasks CFS tasks from misbehaving

01:47:30,780 --> 01:47:40,260
real-time tasks and so the idea is that

01:47:35,570 --> 01:47:43,170
we assume some on a period of default

01:47:40,260 --> 01:47:47,160
values we can switch them we in a one

01:47:43,170 --> 01:47:51,570
second we can left like 50 milliseconds

01:47:47,160 --> 01:47:55,350
for normal tasks to run and so even if

01:47:51,570 --> 01:47:58,020
my five-o task misbehaves the run queue

01:47:55,350 --> 01:48:01,740
will be proud and then my regular thread

01:47:58,020 --> 01:48:04,230
will be able to run when we have

01:48:01,740 --> 01:48:06,270
multiple cores we also have another

01:48:04,230 --> 01:48:10,050
mechanism which is a are different I'm

01:48:06,270 --> 01:48:13,200
sure so so we disabled that for RT and I

01:48:10,050 --> 01:48:16,140
think we should also to tui yeah I'm

01:48:13,200 --> 01:48:20,400
pretty sure Artie has a disabled oh now

01:48:16,140 --> 01:48:22,410
I I suggested disabling it on that patch

01:48:20,400 --> 01:48:25,290
with the Artie runtime grid

01:48:22,410 --> 01:48:29,460
I suggest that also disabling but it's

01:48:25,290 --> 01:48:34,590
not currently disabled okay so switching

01:48:29,460 --> 01:48:38,240
the options RT groups are disabled I

01:48:34,590 --> 01:48:38,240
thought we also killed this one

01:48:40,090 --> 01:48:47,400
it used to be disable for a while and we

01:48:44,739 --> 01:48:55,000
should just kill the entire thing but

01:48:47,400 --> 01:48:57,250
four minutes but for the the the

01:48:55,000 --> 01:49:00,880
throttling we should basically do to

01:48:57,250 --> 01:49:05,530
explicit select I'm scheduling too many

01:49:00,880 --> 01:49:07,239
people talking yeah and so I would do a

01:49:05,530 --> 01:49:18,719
simple per sheep you select I'm

01:49:07,239 --> 01:49:22,480
scheduling okay so okay let's broke so

01:49:18,719 --> 01:49:26,050
okay okay I will jump this part of

01:49:22,480 --> 01:49:30,099
traveling because this seems to be a

01:49:26,050 --> 01:49:32,650
more a more important problem to be

01:49:30,099 --> 01:49:36,159
resolved which is the scalability

01:49:32,650 --> 01:49:38,860
improvement there are some use cases in

01:49:36,159 --> 01:49:41,290
which we cannot okay the current

01:49:38,860 --> 01:49:43,780
scheduler except global scheduler or

01:49:41,290 --> 01:49:46,869
partition schedule global we have one

01:49:43,780 --> 01:49:51,790
scheduler for all CPUs partition we have

01:49:46,869 --> 01:49:54,070
one scheduled for one CPU and there are

01:49:51,790 --> 01:49:58,179
some music cases in which we cannot

01:49:54,070 --> 01:50:02,619
schedule one task set that doesn't

01:49:58,179 --> 01:50:05,739
occupies all the CPU time using the CAD

01:50:02,619 --> 01:50:09,520
global or partition for example here I

01:50:05,739 --> 01:50:11,650
have 6 over 9 and I still have a 3 units

01:50:09,520 --> 01:50:13,929
of time available here at the same time

01:50:11,650 --> 01:50:15,639
here same anything here like 6 over 9

01:50:13,929 --> 01:50:18,610
and I'm still have 3 times available

01:50:15,639 --> 01:50:21,969
here so I have 6 times available but I

01:50:18,610 --> 01:50:28,630
cannot fit this for that this task that

01:50:21,969 --> 01:50:32,380
needs 4 units of time and so what do we

01:50:28,630 --> 01:50:35,710
have in the in the academic side it's a

01:50:32,380 --> 01:50:39,670
trending topic on this is that we rather

01:50:35,710 --> 01:50:42,429
than using just global or partition we

01:50:39,670 --> 01:50:43,780
use a same partition approach and we

01:50:42,429 --> 01:50:45,849
have numbers that show that we can

01:50:43,780 --> 01:50:48,250
schedule way more using this semi

01:50:45,849 --> 01:50:52,360
partition approach just a comparison

01:50:48,250 --> 01:50:56,890
this is the global EF and these 3 here

01:50:52,360 --> 01:50:59,740
our partitioned methods like first feet

01:50:56,890 --> 01:51:02,860
worst field best fit and here is the

01:50:59,740 --> 01:51:04,810
same partition approach we on the same

01:51:02,860 --> 01:51:11,350
partition approach we are always better

01:51:04,810 --> 01:51:15,850
than the others like we are 40 45 44

01:51:11,350 --> 01:51:20,700
percent better than global EDF and we

01:51:15,850 --> 01:51:24,340
are like 30 to 20 percent better than

01:51:20,700 --> 01:51:26,290
partition so the same partition scatter

01:51:24,340 --> 01:51:29,920
help helps to improve the schedule

01:51:26,290 --> 01:51:32,230
ability but not only but just given one

01:51:29,920 --> 01:51:36,370
example let's say that we have that task

01:51:32,230 --> 01:51:39,100
set that we that I present before in the

01:51:36,370 --> 01:51:42,070
same partition I would put these two

01:51:39,100 --> 01:51:44,950
tasks pin it to each CPU these will all

01:51:42,070 --> 01:51:47,320
run here this will run here and then I

01:51:44,950 --> 01:51:50,470
would split that other CPU give entry

01:51:47,320 --> 01:51:52,900
that other task even three units of time

01:51:50,470 --> 01:51:56,050
here but with a constrained deadline and

01:51:52,900 --> 01:51:58,690
the other one unit of time I would put

01:51:56,050 --> 01:52:01,630
here with a very constraining deadline

01:51:58,690 --> 01:52:03,880
which I need one unit of time to run and

01:52:01,630 --> 01:52:07,840
I have a constraint that line of one so

01:52:03,880 --> 01:52:10,780
it will run start running with this

01:52:07,840 --> 01:52:13,120
approach we can schedule more tasks this

01:52:10,780 --> 01:52:15,810
is one example of the scalability that

01:52:13,120 --> 01:52:15,810
we can do more

01:52:19,320 --> 01:52:25,320
that's one eristic this heuristic that c

01:52:22,680 --> 01:52:28,800
equals to d is one that performs very

01:52:25,320 --> 01:52:31,110
very good now this one eristic one can

01:52:28,800 --> 01:52:33,150
change we will even try to move this

01:52:31,110 --> 01:52:35,730
part to the beginning of the execution

01:52:33,150 --> 01:52:39,770
and do more tests but yeah this is one

01:52:35,730 --> 01:52:39,770
eristic in the partitioning part

01:52:42,530 --> 01:52:51,510
admission control so it change how this

01:52:48,360 --> 01:52:52,830
que deadlines do the scheduling but to

01:52:51,510 --> 01:52:59,520
use this cat deadline we are not

01:52:52,830 --> 01:53:02,010
implementing another scheduler and d

01:52:59,520 --> 01:53:09,000
eristic is that put a task on the

01:53:02,010 --> 01:53:11,580
processors ok we use a risk to to make

01:53:09,000 --> 01:53:13,560
it to split the tasks and we have

01:53:11,580 --> 01:53:16,530
different kinds of reservations we don't

01:53:13,560 --> 01:53:20,400
have one reservation per task we have a

01:53:16,530 --> 01:53:22,980
multiple reservation for tasks and these

01:53:20,400 --> 01:53:25,560
reservations are assigned to CPUs they

01:53:22,980 --> 01:53:36,540
are pin these reservation runs only on

01:53:25,560 --> 01:53:39,090
the CPU well why is this good ok the

01:53:36,540 --> 01:53:46,620
main point is you affinities we can do

01:53:39,090 --> 01:53:49,140
affinities yes it might reduce the

01:53:46,620 --> 01:53:51,000
scalability of system but we can we can

01:53:49,140 --> 01:53:52,890
pin tests here some things so if you're

01:53:51,000 --> 01:53:55,520
using the RT tasks are going to be put

01:53:52,890 --> 01:53:58,500
in to replace this with the RT

01:53:55,520 --> 01:53:59,790
throttling how much overhead is that I

01:53:58,500 --> 01:54:01,290
mean if you every time we created our

01:53:59,790 --> 01:54:03,420
day tasks are gonna have to go through

01:54:01,290 --> 01:54:04,260
and do a new partitioning I mean how

01:54:03,420 --> 01:54:07,260
does that work

01:54:04,260 --> 01:54:09,960
ok when we receive one task will do the

01:54:07,260 --> 01:54:12,750
risk is to split the tasks over the CPUs

01:54:09,960 --> 01:54:15,330
this has one cost but it only takes

01:54:12,750 --> 01:54:17,760
place when we are setting the attributes

01:54:15,330 --> 01:54:21,090
of a task which is an operation that we

01:54:17,760 --> 01:54:23,100
don't expect it to be fast or when we

01:54:21,090 --> 01:54:24,780
changing the affinity which is another

01:54:23,100 --> 01:54:26,700
operation that we don't expect it to

01:54:24,780 --> 01:54:28,530
confess sounds it will be about forking

01:54:26,700 --> 01:54:30,830
tasks or something I don't know how much

01:54:28,530 --> 01:54:34,070
RT tasks are created and destroyed

01:54:30,830 --> 01:54:38,380
is a issue for usually our t-tests are

01:54:34,070 --> 01:54:44,930
not created and destroyed quite a bit so

01:54:38,380 --> 01:54:46,280
yes okay so our t-test or not and unless

01:54:44,930 --> 01:54:54,980
you get some person that runs hack bench

01:54:46,280 --> 01:54:58,220
under RT tasks wait oh and fork fails so

01:54:54,980 --> 01:55:00,590
I needs RT tasks to no longer fork won't

01:54:58,220 --> 01:55:03,040
that break user space I mean that sounds

01:55:00,590 --> 01:55:03,040
like a break-in

01:55:04,210 --> 01:55:09,890
there was no existing user space wait

01:55:07,880 --> 01:55:11,600
did not exist it's a new scheduling

01:55:09,890 --> 01:55:14,840
class so we could do whatever we wanted

01:55:11,600 --> 01:55:19,430
and we decided no for we're going to

01:55:14,840 --> 01:55:21,830
have our T tests the RT throttling is

01:55:19,430 --> 01:55:27,700
going to be under this a but no but then

01:55:21,830 --> 01:55:30,680
it'll be a FIFO FIFO scan can do but the

01:55:27,700 --> 01:55:33,380
constraint to the inside the group you

01:55:30,680 --> 01:55:35,570
can do whatever you want oh you place

01:55:33,380 --> 01:55:37,790
the group oh this is because we're doing

01:55:35,570 --> 01:55:40,490
two things the hierarchy yes and then

01:55:37,790 --> 01:55:43,040
inside of the group you have five four

01:55:40,490 --> 01:55:47,560
and you can fork as many files as you

01:55:43,040 --> 01:55:53,720
want but then if you run out of out of

01:55:47,560 --> 01:55:55,550
bandwidth so in other words actually

01:55:53,720 --> 01:55:57,050
this is even involved with the RT

01:55:55,550 --> 01:55:59,390
throttling that because we don't care

01:55:57,050 --> 01:56:01,670
about affinities because we just going

01:55:59,390 --> 01:56:03,830
sounds like it's a global task that one

01:56:01,670 --> 01:56:05,480
group of that and then each task within

01:56:03,830 --> 01:56:16,310
the group could have its own affinities

01:56:05,480 --> 01:56:20,500
correct with with the RT group if we

01:56:16,310 --> 01:56:24,800
have a group and and fifl inside and you

01:56:20,500 --> 01:56:28,100
relay a rely on being scheduled in

01:56:24,800 --> 01:56:31,460
parallel if you have this this audio

01:56:28,100 --> 01:56:35,860
example where we have produce two

01:56:31,460 --> 01:56:35,860
filters and the consumer at the end

01:56:36,300 --> 01:56:44,610
and this might be tricky because how do

01:56:40,860 --> 01:56:47,970
you reserve the bandwidth on the second

01:56:44,610 --> 01:56:50,130
CPU yeah that's one of the points of

01:56:47,970 --> 01:56:52,110
discussion so how its implemented today

01:56:50,130 --> 01:56:58,740
is that you actually serve the same

01:56:52,110 --> 01:57:02,400
amount on all CPUs yeah but because this

01:56:58,740 --> 01:57:06,860
is a new thing you can say hey we need

01:57:02,400 --> 01:57:06,860
to tell the two thing what maximum

01:57:06,920 --> 01:57:15,780
parallelism we can say if if the doesn't

01:57:14,130 --> 01:57:18,630
really care about which particular CPU

01:57:15,780 --> 01:57:21,030
it wants to run on then you can say ok I

01:57:18,630 --> 01:57:24,210
need to know 200 percent of bandwidth

01:57:21,030 --> 01:57:26,130
means two CPUs right never those are and

01:57:24,210 --> 01:57:28,830
then you can reserve just a and force 2

01:57:26,130 --> 01:57:30,510
CPUs to a particular application and if

01:57:28,830 --> 01:57:34,230
you have more you can reserve the others

01:57:30,510 --> 01:57:36,570
so if the minimum amount of let's say

01:57:34,230 --> 01:57:41,250
CPUs you need to actually fulfill your

01:57:36,570 --> 01:57:45,120
application requirements then it could

01:57:41,250 --> 01:57:48,710
say you make the if you if you really

01:57:45,120 --> 01:57:54,930
want to do affinity partitioning things

01:57:48,710 --> 01:57:58,290
then you could require that the affinity

01:57:54,930 --> 01:58:01,410
is only set up on the group itself and

01:57:58,290 --> 01:58:07,290
then inside the group allow knows no no

01:58:01,410 --> 01:58:10,830
affinity manipulation because that's yes

01:58:07,290 --> 01:58:14,300
but then if you if you want to have it

01:58:10,830 --> 01:58:17,550
on a particular set of CPUs you have to

01:58:14,300 --> 01:58:20,400
do their reservation for that particular

01:58:17,550 --> 01:58:24,410
set of CPUs and this will work right

01:58:20,400 --> 01:58:29,160
until the moment you walk into the

01:58:24,410 --> 01:58:32,600
secret controller people but so the name

01:58:29,160 --> 01:58:32,600
space people don't like this

01:58:34,559 --> 01:58:43,030
thank you hey Peter and Artie runtime

01:58:39,880 --> 01:58:45,369
share is on and our current one yeah so

01:58:43,030 --> 01:58:49,829
basically what the answer this is we

01:58:45,369 --> 01:58:49,829
need a new scheduling class called sched

01:59:03,250 --> 01:59:07,090
yeah this should go away

01:59:09,119 --> 01:59:14,489
Peter Peter that's easy to solve they

01:59:12,270 --> 01:59:16,739
one time namespaces I know I only give

01:59:14,489 --> 01:59:20,060
them time namespaces if we get proper

01:59:16,739 --> 01:59:20,060
semantics for the containers

02:00:08,530 --> 02:00:11,190
did you

02:02:19,330 --> 02:02:27,050
hi my name is Prakash sorry about the

02:02:22,969 --> 02:02:30,650
glitch so yeah I'm here to talk about a

02:02:27,050 --> 02:02:32,060
specific issue we're running into the DB

02:02:30,650 --> 02:02:36,590
use case that's what I'm gonna describe

02:02:32,060 --> 02:02:38,690
and then basically looking for what

02:02:36,590 --> 02:02:42,130
direction we should take or maybe even

02:02:38,690 --> 02:02:51,250
avoid RT what would be an alternative

02:02:42,130 --> 02:02:55,280
can you all hear me all right basically

02:02:51,250 --> 02:02:57,260
they tryna run RT process inside user

02:02:55,280 --> 02:02:59,510
name space and like from previous

02:02:57,260 --> 02:03:01,850
discussion it was mentioned you can't

02:02:59,510 --> 02:03:06,679
run an RT which any user name space that

02:03:01,850 --> 02:03:08,570
is quite defined by design so what are

02:03:06,679 --> 02:03:11,060
user names like I guess most of you know

02:03:08,570 --> 02:03:12,739
what it is to run through it so it

02:03:11,060 --> 02:03:17,030
allows any normal user to go and create

02:03:12,739 --> 02:03:18,889
namespaces and using user name so you

02:03:17,030 --> 02:03:22,670
can create other using the namespaces

02:03:18,889 --> 02:03:25,580
and so with that what you get is you can

02:03:22,670 --> 02:03:28,489
map a normal user to be UID 0 inside the

02:03:25,580 --> 02:03:30,830
user name space which means they get all

02:03:28,489 --> 02:03:33,580
the capabilities including caps is nice

02:03:30,830 --> 02:03:36,500
but it is not effective and you know

02:03:33,580 --> 02:03:39,489
letting a user to set RT priority and

02:03:36,500 --> 02:03:39,489
run RT processes

02:03:41,550 --> 02:03:46,650
and the capabilities are basically

02:03:44,010 --> 02:03:50,160
applicable to resources local within the

02:03:46,650 --> 02:03:52,440
username space that is by definition so

02:03:50,160 --> 02:03:55,350
the similar restriction exists for other

02:03:52,440 --> 02:03:57,720
capabilities like IPC lock system time

02:03:55,350 --> 02:04:01,460
you know it won't allow the user inside

02:03:57,720 --> 02:04:05,340
username Chase to go change system time

02:04:01,460 --> 02:04:08,700
nor make devices the restriction exists

02:04:05,340 --> 02:04:10,320
even for a root user in the init

02:04:08,700 --> 02:04:12,720
namespace if he gets mapped into user

02:04:10,320 --> 02:04:15,660
name space even that user will not be

02:04:12,720 --> 02:04:18,990
allowed to you know get these

02:04:15,660 --> 02:04:21,180
capabilities so now the question is do

02:04:18,990 --> 02:04:23,670
we deal with these case-by-case basis

02:04:21,180 --> 02:04:27,120
you know if there are any use case where

02:04:23,670 --> 02:04:28,410
a user wants to be able to do some of

02:04:27,120 --> 02:04:32,970
these operations within the user

02:04:28,410 --> 02:04:35,100
namespace so like for example for system

02:04:32,970 --> 02:04:36,300
time there is the proposal for time

02:04:35,100 --> 02:04:38,760
namespace they're talking about

02:04:36,300 --> 02:04:40,740
hopefully that can address this

02:04:38,760 --> 02:04:43,140
particular requirement if somebody wants

02:04:40,740 --> 02:04:46,020
to set up a container with the user name

02:04:43,140 --> 02:04:51,300
space and he may be able to set the time

02:04:46,020 --> 02:04:53,430
within the namespace with that I don't

02:04:51,300 --> 02:04:55,620
know where that is going yeah we we

02:04:53,430 --> 02:04:57,380
still have to talk about that and we're

02:04:55,620 --> 02:05:02,220
going to do to have a session on

02:04:57,380 --> 02:05:04,920
Thursday afternoon okay so whether the

02:05:02,220 --> 02:05:06,870
user is going to be allowed to do set

02:05:04,920 --> 02:05:10,830
time of day I doubt it

02:05:06,870 --> 02:05:12,810
but I mean it would make it would be

02:05:10,830 --> 02:05:15,960
possible but it would make a lot of

02:05:12,810 --> 02:05:18,060
things more complex well so with time

02:05:15,960 --> 02:05:23,400
names - the idea is to give local time

02:05:18,060 --> 02:05:25,140
within the namespace so I know but the

02:05:23,400 --> 02:05:27,300
mess you're creating in the kernel for

02:05:25,140 --> 02:05:30,480
doing that that's a totally different

02:05:27,300 --> 02:05:33,960
question so I know what you want but I

02:05:30,480 --> 02:05:41,130
mean namespace people usually want a lot

02:05:33,960 --> 02:05:43,860
of ponies and yeah well anyway so the

02:05:41,130 --> 02:05:47,490
discussion here is over RT so on let's

02:05:43,860 --> 02:05:49,350
talk about RT right so basically the use

02:05:47,490 --> 02:05:50,880
case basically here is you know we want

02:05:49,350 --> 02:05:53,070
to be able to run RT inside that user

02:05:50,880 --> 02:05:54,120
namespace so I'll go through the Oracle

02:05:53,070 --> 02:05:57,120
DB use case

02:05:54,120 --> 02:05:59,970
specifically here so in the multi-tenant

02:05:57,120 --> 02:06:03,060
architecture so they're going to start

02:05:59,970 --> 02:06:05,340
using usernames face to isolate a

02:06:03,060 --> 02:06:11,460
database instance on a particular system

02:06:05,340 --> 02:06:13,170
there can be multiple instances so

02:06:11,460 --> 02:06:15,300
apparently there are similar restriction

02:06:13,170 --> 02:06:17,670
there was very little discussion around

02:06:15,300 --> 02:06:19,830
I know Linux containers they now support

02:06:17,670 --> 02:06:21,770
unprivileged containers where basically

02:06:19,830 --> 02:06:25,020
you can you are allowed to create

02:06:21,770 --> 02:06:27,420
namespaces using user name space all

02:06:25,020 --> 02:06:28,980
right I didn't see any conclusion or

02:06:27,420 --> 02:06:32,520
suggestions on how to deal with this

02:06:28,980 --> 02:06:35,160
particular problem so talking about the

02:06:32,520 --> 02:06:38,250
DB use case so what is multi-tenant

02:06:35,160 --> 02:06:39,660
architecture so it basically allows the

02:06:38,250 --> 02:06:43,020
Oracle database to be a multi-tenant

02:06:39,660 --> 02:06:47,760
container database and so I'll show a

02:06:43,020 --> 02:06:50,730
diagram next slide so where you can put

02:06:47,760 --> 02:06:54,120
multiple they call a pluggable databases

02:06:50,730 --> 02:06:56,250
inside the container database and that's

02:06:54,120 --> 02:06:58,110
how you can do consolidation so with

02:06:56,250 --> 02:06:59,970
that you can you can have multiple CD

02:06:58,110 --> 02:07:02,220
bees or container database running on

02:06:59,970 --> 02:07:04,440
the same system so now the question of

02:07:02,220 --> 02:07:08,430
isolation so this is the architecture

02:07:04,440 --> 02:07:11,400
before the consolidation where basically

02:07:08,430 --> 02:07:13,230
the customers used to run these each

02:07:11,400 --> 02:07:15,390
instant these are each instance is

02:07:13,230 --> 02:07:16,830
running separately on different machines

02:07:15,390 --> 02:07:21,000
just because you want to keep them

02:07:16,830 --> 02:07:23,370
isolated so with the the new

02:07:21,000 --> 02:07:24,840
architecture the idea is you create a

02:07:23,370 --> 02:07:26,670
container database which is a bigger

02:07:24,840 --> 02:07:28,950
database and then you put all them

02:07:26,670 --> 02:07:32,760
actually the customer database inside

02:07:28,950 --> 02:07:35,000
that and that basically helps you you

02:07:32,760 --> 02:07:39,440
know save costs and run multiple

02:07:35,000 --> 02:07:39,440
actually be instances on the same system

02:07:40,490 --> 02:07:45,840
yeah so because there will be multiple

02:07:43,020 --> 02:07:48,510
CD bees running on the same system now

02:07:45,840 --> 02:07:52,230
we need to be able to isolate each of

02:07:48,510 --> 02:07:55,380
them and the solutions are looking at is

02:07:52,230 --> 02:07:59,850
to be able to use user namespaces plus

02:07:55,380 --> 02:08:01,500
other namespaces but now the CD be the

02:07:59,850 --> 02:08:04,050
container database has some critical

02:08:01,500 --> 02:08:05,400
processes that have to run at a higher

02:08:04,050 --> 02:08:13,739
priority

02:08:05,400 --> 02:08:18,150
and yeah and son HPD bees are put in

02:08:13,739 --> 02:08:19,710
nested namespaces they are correct so

02:08:18,150 --> 02:08:21,630
the critical processes have to render

02:08:19,710 --> 02:08:25,980
much higher priority than other

02:08:21,630 --> 02:08:29,040
processes in the system so the the

02:08:25,980 --> 02:08:33,750
current uses the septum to run a tardy

02:08:29,040 --> 02:08:35,550
priority but since now with use of

02:08:33,750 --> 02:08:38,730
usernames they're not able to set the Rd

02:08:35,550 --> 02:08:41,730
priority on these processes so either

02:08:38,730 --> 02:08:43,469
you know the only solution that is

02:08:41,730 --> 02:08:45,780
available right now is to have a daemon

02:08:43,469 --> 02:08:47,940
running outside the namespace as a root

02:08:45,780 --> 02:08:49,199
and then send a message and that would

02:08:47,940 --> 02:08:54,929
probably set the priority on these

02:08:49,199 --> 02:08:58,890
processes which is not so convenient so

02:08:54,929 --> 02:09:00,420
what are the approaches we can take so

02:08:58,890 --> 02:09:03,000
basically if you were to map the route

02:09:00,420 --> 02:09:03,870
user from init namespace into the user

02:09:03,000 --> 02:09:06,270
namespace

02:09:03,870 --> 02:09:09,980
the question is can we allow that user

02:09:06,270 --> 02:09:13,800
at least to be able to set r/t priority

02:09:09,980 --> 02:09:16,650
or can we set allow caps it's nice

02:09:13,800 --> 02:09:18,929
capability if we were to tag or you know

02:09:16,650 --> 02:09:24,719
indicate that a particular user name

02:09:18,929 --> 02:09:26,310
just have the ability to do this or if

02:09:24,719 --> 02:09:29,790
there's any way we can do it with the

02:09:26,310 --> 02:09:31,350
help of C groups if not RT then what

02:09:29,790 --> 02:09:32,909
would be an alternative solution for

02:09:31,350 --> 02:09:35,070
this particular use case where you have

02:09:32,909 --> 02:09:39,330
critical processes that need to run

02:09:35,070 --> 02:09:41,909
inside the user instance yeah so

02:09:39,330 --> 02:09:44,120
basically you know that's what I had

02:09:41,909 --> 02:09:44,120
asked

02:09:49,320 --> 02:09:58,750
in seditions in principle yes we surely

02:09:54,730 --> 02:10:02,350
can have some mechanism to allow that

02:09:58,750 --> 02:10:07,590
but I would only ever go there if we

02:10:02,350 --> 02:10:15,270
have something like we discussed before

02:10:07,590 --> 02:10:20,050
the C group control in place in order to

02:10:15,270 --> 02:10:25,060
just prevent or non privileged users

02:10:20,050 --> 02:10:28,090
from eating up 40 bandwidth right I mean

02:10:25,060 --> 02:10:29,890
it has to come wire the the secret

02:10:28,090 --> 02:10:33,880
bandwidth controller anyway right

02:10:29,890 --> 02:10:35,860
because that's you don't know what user

02:10:33,880 --> 02:10:41,880
is going to get mapped inside to use the

02:10:35,860 --> 02:10:45,400
namespace the whole point behind I mean

02:10:41,880 --> 02:10:47,679
I don't know when you did that I think

02:10:45,400 --> 02:10:53,320
it was to prevent runaway RT processes

02:10:47,679 --> 02:10:56,530
from taking over now when you did there

02:10:53,320 --> 02:10:57,940
were times CPC group stuff yeah it was

02:10:56,530 --> 02:11:00,840
just to prevent the real-time stuff from

02:10:57,940 --> 02:11:00,840
running away right

02:11:06,080 --> 02:11:13,739
so so any containerization of real-time

02:11:10,440 --> 02:11:16,170
needs limits on on the runtime because

02:11:13,739 --> 02:11:18,690
Scott Phi Phi was fundamentally buried

02:11:16,170 --> 02:11:26,909
it's it's absolute train wreck of an

02:11:18,690 --> 02:11:31,560
interface and a deadline server or CVS

02:11:26,909 --> 02:11:33,710
server for FIFO per namespace or C group

02:11:31,560 --> 02:11:38,699
whatever you have there is required

02:11:33,710 --> 02:11:45,570
before we can allow any five-o task to

02:11:38,699 --> 02:11:52,110
run inside of a container yeah oops I

02:11:45,570 --> 02:11:57,449
got Peters okay here's the thing I the

02:11:52,110 --> 02:12:01,920
question I want to ask is the right

02:11:57,449 --> 02:12:07,110
answer do this as an they want to use

02:12:01,920 --> 02:12:09,060
real time the real question is or using

02:12:07,110 --> 02:12:11,250
namespaces to write a right answer to

02:12:09,060 --> 02:12:16,469
the problem well I mean the reason they

02:12:11,250 --> 02:12:18,810
using use namespaces is for isolation if

02:12:16,469 --> 02:12:21,000
not username sir then the trouble is you

02:12:18,810 --> 02:12:22,889
need to have root privileges to even

02:12:21,000 --> 02:12:24,210
create namespaces that was one big

02:12:22,889 --> 02:12:26,760
advantage you would get with username

02:12:24,210 --> 02:12:28,739
stays there any user can just go create

02:12:26,760 --> 02:12:31,889
his own sort of main space and

02:12:28,739 --> 02:12:34,530
containers I mean that's why the

02:12:31,889 --> 02:12:39,150
question is I mean what can we do to

02:12:34,530 --> 02:12:42,889
avoid using real time you should not

02:12:39,150 --> 02:12:42,889
really need real time to run

02:12:46,670 --> 02:12:58,200
but but you have some same tasks which

02:12:52,410 --> 02:13:00,720
actually have higher priority whatever

02:12:58,200 --> 02:13:05,360
you define it whether that's you name

02:13:00,720 --> 02:13:22,530
that real-time or whatever I don't care

02:13:05,360 --> 02:13:25,110
so yes oh right no it's not the most

02:13:22,530 --> 02:13:27,000
advantageous interface with CFS right

02:13:25,110 --> 02:13:30,690
now I mean all it does is you get to run

02:13:27,000 --> 02:13:33,530
for longer right as opposed to to get

02:13:30,690 --> 02:13:33,530
run No

02:13:35,060 --> 02:13:44,180
so if we were to do a bandwidth server

02:13:40,280 --> 02:13:47,340
the real-time thing couldn't always run

02:13:44,180 --> 02:13:54,570
anyway there will be limits on how much

02:13:47,340 --> 02:13:57,780
it can run so what are the requirements

02:13:54,570 --> 02:14:01,500
for this thing always running is not

02:13:57,780 --> 02:14:04,380
good no no it's not always running it's

02:14:01,500 --> 02:14:08,210
basically that the thing what they need

02:14:04,380 --> 02:14:14,040
to do is to run it immediately yes and

02:14:08,210 --> 02:14:15,900
for it you can you can put a run time

02:14:14,040 --> 02:14:18,630
limit on it because it's going to be

02:14:15,900 --> 02:14:20,850
finite so what what do you want you

02:14:18,630 --> 02:14:24,770
actually want to run time limit in case

02:14:20,850 --> 02:14:24,770
that thing goes bonkers and runs forever

02:14:26,390 --> 02:14:30,360
it's going goes back to what I was

02:14:28,680 --> 02:14:32,580
trying to kind of say before I guess the

02:14:30,360 --> 02:14:35,040
issue is not having guaranteed run time

02:14:32,580 --> 02:14:37,050
but basically a limited run time so if

02:14:35,040 --> 02:14:40,050
we say if once it goes in you don't have

02:14:37,050 --> 02:14:42,990
to reserve time to make sure it has that

02:14:40,050 --> 02:14:44,940
available as soon as it gets scheduled

02:14:42,990 --> 02:14:47,490
in then say ok make sure like now we

02:14:44,940 --> 02:14:49,350
want to add it to let it run and just

02:14:47,490 --> 02:14:51,270
limit it so basically like a man with

02:14:49,350 --> 02:14:52,580
scheduler you have you have a sporadic

02:14:51,270 --> 02:14:55,740
server with

02:14:52,580 --> 02:14:57,210
with runtime limitation yeah I think

02:14:55,740 --> 02:14:58,680
that's more maybe I should describe that

02:14:57,210 --> 02:15:00,450
way having more of a bandwidth scheduler

02:14:58,680 --> 02:15:07,200
that limits things sort of guaranteeing

02:15:00,450 --> 02:15:08,640
Thanks yes it has to run none

02:15:07,200 --> 02:15:11,220
interpreter does the other thing it's

02:15:08,640 --> 02:15:12,870
not like there's gonna be a fixed time

02:15:11,220 --> 02:15:15,420
it has to be done at a higher priority

02:15:12,870 --> 02:15:18,660
because it's a critical operation you

02:15:15,420 --> 02:15:19,890
don't want to block that because if that

02:15:18,660 --> 02:15:23,490
blocks then a lot of other processes

02:15:19,890 --> 02:15:25,380
behind it yeah well I mean you can't run

02:15:23,490 --> 02:15:27,450
it forever yes

02:15:25,380 --> 02:15:31,050
that doesn't non thing so I mean if if

02:15:27,450 --> 02:15:36,120
there's a the point is that we when we

02:15:31,050 --> 02:15:38,880
want to allow real-time of any form

02:15:36,120 --> 02:15:45,020
inside of user name spaces then we have

02:15:38,880 --> 02:15:47,730
to put RT run time limitation on that

02:15:45,020 --> 02:15:52,350
and that's something you have to define

02:15:47,730 --> 02:15:55,350
and say okay yes I can do or that thing

02:15:52,350 --> 02:15:57,210
or the sysadmin can grant it that's the

02:15:55,350 --> 02:16:03,030
person who grants it he says okay you

02:15:57,210 --> 02:16:08,180
can't consume whatever 20% CPU 40 but no

02:16:03,030 --> 02:16:08,180
your cutoff for if you try more

02:16:10,850 --> 02:16:16,910
where are the current limitations with

02:16:13,530 --> 02:16:20,070
the the RT bandwidth limiter right now

02:16:16,910 --> 02:16:22,520
that we can't plug it into user name

02:16:20,070 --> 02:16:22,520
spaces

02:16:26,710 --> 02:16:31,099
I've never seen a namespace of clothes I

02:16:29,510 --> 02:16:33,229
don't know okay

02:16:31,099 --> 02:16:39,740
also we really want to get rid of that

02:16:33,229 --> 02:16:46,269
interface because it you've seen

02:16:39,740 --> 02:16:50,960
the presentation server well no but we

02:16:46,269 --> 02:17:00,769
actually know there are users which is -

02:16:50,960 --> 02:17:04,399
I don't know how its plumbed with with

02:17:00,769 --> 02:17:06,620
all the yeah thing is can there be

02:17:04,399 --> 02:17:08,570
something else we probably have to avoid

02:17:06,620 --> 02:17:10,070
Artie here in this particular use case

02:17:08,570 --> 02:17:12,290
you'll have multiple of these running on

02:17:10,070 --> 02:17:13,939
the system even if you were the car over

02:17:12,290 --> 02:17:17,300
time how much can you give each of these

02:17:13,939 --> 02:17:19,370
extra Marty points so that's a good

02:17:17,300 --> 02:17:24,679
point here right with the whole idea of

02:17:19,370 --> 02:17:25,969
running multiple pdbs and CD B's you

02:17:24,679 --> 02:17:28,010
have a lot of these log writer

02:17:25,969 --> 02:17:31,370
processors and so you probably don't

02:17:28,010 --> 02:17:35,439
have enough real time in a real time

02:17:31,370 --> 02:17:35,439
time around to share

02:17:49,630 --> 02:17:55,370
what you say is impossible if there is

02:17:53,360 --> 02:18:07,700
not enough time there is not enough time

02:17:55,370 --> 02:18:09,530
and it's broken the end there has to be

02:18:07,700 --> 02:18:11,660
some sizing obviously you can't flood

02:18:09,530 --> 02:18:15,490
the system it's someone you have to say

02:18:11,660 --> 02:18:15,490
okay max 10 or X

02:18:36,559 --> 02:18:45,340
all right yeah but that's not my problem

02:18:43,010 --> 02:18:45,340
is it

02:18:48,969 --> 02:18:55,670
but I mean would yes what do you I mean

02:18:53,059 --> 02:18:59,469
you really want this paretic sir with a

02:18:55,670 --> 02:19:04,059
bandwidth limitation yeah period and

02:18:59,469 --> 02:19:06,519
sysadmin can say okay you get at max

02:19:04,059 --> 02:19:10,729
bandwidth for that crap

02:19:06,519 --> 02:19:14,719
whatever he defines and then if you're

02:19:10,729 --> 02:19:16,819
stupid database Locker needs more then

02:19:14,719 --> 02:19:19,550
you need either to talk to the sysadmin

02:19:16,819 --> 02:19:23,269
or you need to look at why it's needing

02:19:19,550 --> 02:19:27,079
more time and that's pretty much the end

02:19:23,269 --> 02:19:30,309
of the story then everything else you

02:19:27,079 --> 02:19:32,779
try the alternative thing if you try to

02:19:30,309 --> 02:19:37,880
basically do a new scheduling class

02:19:32,779 --> 02:19:45,829
which is kind of fear but a little bit

02:19:37,880 --> 02:19:49,149
more unfair then you run into the same

02:19:45,829 --> 02:19:54,439
issue because everybody user will use

02:19:49,149 --> 02:19:55,850
scared ponies because his task is

02:19:54,439 --> 02:20:02,000
obviously the most important in your

02:19:55,850 --> 02:20:04,880
system yeah we all know that and I

02:20:02,000 --> 02:20:07,579
actually talk to database people who run

02:20:04,880 --> 02:20:12,310
even the other database fred in RT

02:20:07,579 --> 02:20:12,310
because it's more important

02:20:17,750 --> 02:20:36,271
yeah something like attic service okay

02:20:29,900 --> 02:20:39,150
yes no no I am not working on it

02:20:36,271 --> 02:20:42,180
their work is being done for what you

02:20:39,150 --> 02:20:48,900
need but it's not there yet what does

02:20:42,180 --> 02:20:53,370
the work it's the hierarchical

02:20:48,900 --> 02:20:55,130
scheduling thing and Daniel first we

02:20:53,370 --> 02:20:58,590
need all the other stuff done it depends

02:20:55,130 --> 02:21:03,620
but but to have that we need all the

02:20:58,590 --> 02:21:15,990
other thing is no the ponies come lost

02:21:03,620 --> 02:21:20,480
you cannot go into your room and lock

02:21:15,990 --> 02:21:20,480
the door and think about the pony

02:21:35,780 --> 02:21:38,960
[Laughter]

02:21:42,170 --> 02:22:10,370
so there is no slide okay so the next

02:22:07,729 --> 02:22:14,840
one here I guess it's officially Daniel

02:22:10,370 --> 02:22:24,550
proposed it but since he was already the

02:22:14,840 --> 02:22:28,220
tall Daniel not short Daniel

02:22:24,550 --> 02:22:28,670
so basically from there people one

02:22:28,220 --> 02:22:31,100
second

02:22:28,670 --> 02:22:38,870
since I'm not in charge here but so

02:22:31,100 --> 02:22:41,270
people can see so basically it's about

02:22:38,870 --> 02:22:46,250
what to do after preempt RT is accepted

02:22:41,270 --> 02:22:56,990
because what's the ETA now last I heard

02:22:46,250 --> 02:23:04,010
was 42 real time the real time

02:22:56,990 --> 02:23:06,529
galaxy time units from now just to give

02:23:04,010 --> 02:23:07,850
a thing I people he's always been a run

02:23:06,529 --> 02:23:11,960
on joke day you know this year would be

02:23:07,850 --> 02:23:15,439
the year that RT is accepted and it's

02:23:11,960 --> 02:23:17,630
roughly the same thing like the year of

02:23:15,439 --> 02:23:25,130
the Linux desktop yeah they've been

02:23:17,630 --> 02:23:28,520
seeing this since what 2009 2007 11

02:23:25,130 --> 02:23:30,620
years have we been this year is it the

02:23:28,520 --> 02:23:33,140
difference is actually trying to from

02:23:30,620 --> 02:23:35,800
gave up on that yeah John because okay

02:23:33,140 --> 02:23:38,000
yeah he realized that he's not a prophet

02:23:35,800 --> 02:23:41,779
but the funny part is he actually was

02:23:38,000 --> 02:23:44,750
true because every year a large part of

02:23:41,779 --> 02:23:47,779
real time made it into a Mayan kernel it

02:23:44,750 --> 02:23:49,130
was a constant feed it wasn't it's every

02:23:47,779 --> 02:23:50,840
year we actually got in it was just

02:23:49,130 --> 02:23:53,410
actually we started going in it just is

02:23:50,840 --> 02:23:55,630
just taking a long time to finish it

02:23:53,410 --> 02:23:57,820
so you know there's a lot of history

02:23:55,630 --> 02:23:59,290
we've actually the mutex code is

02:23:57,820 --> 02:24:00,790
actually from real time patch believe it

02:23:59,290 --> 02:24:03,340
or not locked up came from the real time

02:24:00,790 --> 02:24:04,660
patch timers HR timers came from the

02:24:03,340 --> 02:24:06,640
real time patch F trace came from the

02:24:04,660 --> 02:24:07,930
real time patch so all this stuff

02:24:06,640 --> 02:24:10,660
actually was in the real time patch

02:24:07,930 --> 02:24:12,610
first and it was all pulled in and now

02:24:10,660 --> 02:24:14,460
we're down to basically one or two

02:24:12,610 --> 02:24:16,660
things well I know they're well we got

02:24:14,460 --> 02:24:17,830
software accused I guess is still being

02:24:16,660 --> 02:24:20,920
worked on there's like another little

02:24:17,830 --> 02:24:24,280
things I rewrote it the tenth time and I

02:24:20,920 --> 02:24:26,560
still hated the last one it's been

02:24:24,280 --> 02:24:27,880
pretty stable I mean it's been rewritten

02:24:26,560 --> 02:24:29,470
several several times I think the last

02:24:27,880 --> 02:24:31,510
one hasn't modified very much although

02:24:29,470 --> 02:24:34,240
there's Frederic vise Becker has his

02:24:31,510 --> 02:24:36,939
work for the starvation of soft i

02:24:34,240 --> 02:24:38,649
recused yes and i was talking to him

02:24:36,939 --> 02:24:46,030
recently about that and it actually

02:24:38,649 --> 02:24:50,680
makes it easier because we can't do that

02:24:46,030 --> 02:24:52,960
without Frederick something but or is it

02:24:50,680 --> 02:24:55,360
to lose something I know yeah that

02:24:52,960 --> 02:24:57,670
depends when Frederick's universe will

02:24:55,360 --> 02:25:00,780
actually collide with our universe again

02:24:57,670 --> 02:25:04,300
yeah Frederick doesn't live in real time

02:25:00,780 --> 02:25:06,250
so and then and then after I think the

02:25:04,300 --> 02:25:09,939
software accusin and the sleeping spin

02:25:06,250 --> 02:25:11,530
locks that's it yeah but that's the

02:25:09,939 --> 02:25:15,130
least of the worries because that's

02:25:11,530 --> 02:25:20,970
completely self-contained self-contained

02:25:15,130 --> 02:25:24,520
code self-contained self-contained yes

02:25:20,970 --> 02:25:26,590
so this is this is the part which I'm

02:25:24,520 --> 02:25:29,439
not worried about because that's the big

02:25:26,590 --> 02:25:34,360
chunk I throw it limits and say hey take

02:25:29,439 --> 02:25:36,490
this it's cool which is preparatory work

02:25:34,360 --> 02:25:40,960
that's that's the the thing which

02:25:36,490 --> 02:25:42,910
changes existing code right what's the

02:25:40,960 --> 02:25:44,380
way but preempt Artie but to get the

02:25:42,910 --> 02:25:46,090
sequence pin locks don't you need the

02:25:44,380 --> 02:25:48,160
well not to same internal I put the

02:25:46,090 --> 02:25:49,660
prior yeah to get to sleep in spin locks

02:25:48,160 --> 02:25:51,820
I thought you need all the other changes

02:25:49,660 --> 02:25:56,170
yeah yeah those little things that it

02:25:51,820 --> 02:25:59,350
touches and causes and but we've always

02:25:56,170 --> 02:26:01,510
been looking at up until last year maybe

02:25:59,350 --> 02:26:02,681
all these talks for the real-time micro

02:26:01,510 --> 02:26:04,931
conferences

02:26:02,681 --> 02:26:06,400
the real-time summits but basically I've

02:26:04,931 --> 02:26:08,980
always had a talk focused on what we

02:26:06,400 --> 02:26:11,171
need to do to fix X Y & Z so we can get

02:26:08,980 --> 02:26:16,061
real-time preempt RT into the real-time

02:26:11,171 --> 02:26:18,251
or get preempt RT into the kernel those

02:26:16,061 --> 02:26:20,261
conversations are over we have a few

02:26:18,251 --> 02:26:21,820
things like locked Abe we basically have

02:26:20,261 --> 02:26:24,641
ideas on how to get things there's a few

02:26:21,820 --> 02:26:27,391
little nuggets but for the last year or

02:26:24,641 --> 02:26:29,141
so we've turned around said oh crap

02:26:27,391 --> 02:26:31,391
we're almost there

02:26:29,141 --> 02:26:34,150
we're ready the conversation has turned

02:26:31,391 --> 02:26:38,801
to what do we do when the preempt RT

02:26:34,150 --> 02:26:40,811
patch is in the kernel because hey we

02:26:38,801 --> 02:26:43,990
drink beer and they run away and lots of

02:26:40,811 --> 02:26:46,150
beer money that's the point where I'm

02:26:43,990 --> 02:26:55,990
going to collect all the peers people

02:26:46,150 --> 02:26:58,631
only going to be a big party there's so

02:26:55,990 --> 02:27:00,971
the thing is once it's in it's actually

02:26:58,631 --> 02:27:04,001
not over it's actually just the problems

02:27:00,971 --> 02:27:05,080
just change to something else a few of

02:27:04,001 --> 02:27:06,730
the things we have to worry about is we

02:27:05,080 --> 02:27:08,671
have to teach people not to break

02:27:06,730 --> 02:27:12,940
real-time because once it's in there

02:27:08,671 --> 02:27:15,280
developers will still are very creative

02:27:12,940 --> 02:27:17,471
in breaking the kernel and it's always

02:27:15,280 --> 02:27:20,711
it still works for me but too bad for

02:27:17,471 --> 02:27:22,240
you so we need ways to do there's a few

02:27:20,711 --> 02:27:23,830
things that we want to do and one thing

02:27:22,240 --> 02:27:25,690
is I didn't bring this up in your micro

02:27:23,830 --> 02:27:28,721
conference Daniel was I should have done

02:27:25,690 --> 02:27:31,811
it it was okay we need testing we need a

02:27:28,721 --> 02:27:33,671
way to add to the K self tests to add

02:27:31,811 --> 02:27:37,271
everything else that you know when you

02:27:33,671 --> 02:27:38,891
run like every Linux NEX merge they

02:27:37,271 --> 02:27:41,561
could run to make sure that real time

02:27:38,891 --> 02:27:44,131
still works and we test drivers we test

02:27:41,561 --> 02:27:47,381
everything though and maybe even

02:27:44,131 --> 02:27:49,570
aesthetic analysis tools to analyze the

02:27:47,381 --> 02:27:52,001
kernel looking for things where you have

02:27:49,570 --> 02:27:54,431
something that's a local irq save thrown

02:27:52,001 --> 02:27:55,721
around that shouldn't always be done

02:27:54,431 --> 02:27:57,431
make sure it's done properly and maybe

02:27:55,721 --> 02:28:00,030
we should have rules about doing local

02:27:57,431 --> 02:28:02,051
you know disabling preemption disabling

02:28:00,030 --> 02:28:03,280
interrupts so the main thing is if you

02:28:02,051 --> 02:28:05,320
disable interrupts and then call spin

02:28:03,280 --> 02:28:07,001
lock that will break on the preempt RT

02:28:05,320 --> 02:28:08,801
kernel because the spin lock is now a

02:28:07,001 --> 02:28:11,980
mutex and you can't disable preemption

02:28:08,801 --> 02:28:13,301
and schedule out which mutex is do so

02:28:11,980 --> 02:28:14,921
there's a list of things that we need to

02:28:13,301 --> 02:28:15,561
do now so this is kind of a discussion

02:28:14,921 --> 02:28:18,860
of

02:28:15,561 --> 02:28:21,380
you know what can we do yes how much of

02:28:18,860 --> 02:28:23,660
this can be caught by stuff like because

02:28:21,380 --> 02:28:25,761
I think have you locked up that's a good

02:28:23,660 --> 02:28:27,440
question how much okay what you do if

02:28:25,761 --> 02:28:31,601
you throw the mic back to Peter

02:28:27,440 --> 02:28:31,601
he thought he asleep during this one huh

02:28:32,540 --> 02:28:39,230
so I have some looked at batches

02:28:35,771 --> 02:28:41,931
ordering things like make sure that you

02:28:39,230 --> 02:28:46,670
don't take spin looks under a raw spin

02:28:41,931 --> 02:28:48,920
look and and silly things like that but

02:28:46,670 --> 02:28:50,780
for timing looked up cannot help look

02:28:48,920 --> 02:28:56,000
that will destroy your timing anyway

02:28:50,780 --> 02:28:59,090
because so it can help with some

02:28:56,000 --> 02:29:00,530
patterns but it cannot I don't think we

02:28:59,090 --> 02:29:04,040
care about like you know locked up

02:29:00,530 --> 02:29:06,351
helping us with the pattern so I think

02:29:04,040 --> 02:29:10,040
what we worry about is that lock depth

02:29:06,351 --> 02:29:16,221
will catch for example spin lock

02:29:10,040 --> 02:29:17,990
followed by locked up yeah like like it

02:29:16,221 --> 02:29:20,450
was like a Ross pin lock file by spin

02:29:17,990 --> 02:29:21,740
lock or local Eric use if you call like

02:29:20,450 --> 02:29:23,570
you know it's got to keep track of how a

02:29:21,740 --> 02:29:26,780
interrupts were disabled was interrupts

02:29:23,570 --> 02:29:28,940
disabled by a just local Eric you save

02:29:26,780 --> 02:29:31,000
and then you had a spin lock which would

02:29:28,940 --> 02:29:43,851
be something rock tip could easily catch

02:29:31,000 --> 02:29:47,290
yeah okay it's early are you saying like

02:29:43,851 --> 02:29:47,290
somewhere over the rainbow or something

02:29:48,280 --> 02:29:51,620
[Music]

02:29:52,740 --> 02:29:59,601
[Laughter]

02:29:55,690 --> 02:30:01,490
so your best side okay that's not my

02:29:59,601 --> 02:30:03,810
best side I'm not fitting in the camera

02:30:01,490 --> 02:30:10,509
with this

02:30:03,810 --> 02:30:15,779
okay I get shy so with that model I'm

02:30:10,509 --> 02:30:18,369
modeling also locks like I'm modeling

02:30:15,779 --> 02:30:23,020
mutexes which can be out so real time

02:30:18,369 --> 02:30:26,140
new Texas and I say that I cannot take a

02:30:23,020 --> 02:30:30,609
row I cannot take a real time mutex

02:30:26,140 --> 02:30:32,649
after taking a eros pin law in such

02:30:30,609 --> 02:30:34,959
kinds of thing like I cannot take okay I

02:30:32,649 --> 02:30:37,060
cannot take a real time mutex with

02:30:34,959 --> 02:30:39,129
preemption disabled and preemption are

02:30:37,060 --> 02:30:41,890
disabled because Russ pin locks disable

02:30:39,129 --> 02:30:44,619
preemption on that section right yeah we

02:30:41,890 --> 02:30:46,689
can catch these problems and this is the

02:30:44,619 --> 02:30:50,529
topic of the next presentation but Stu's

02:30:46,689 --> 02:30:52,629
it I I would catch now with trace I

02:30:50,529 --> 02:30:54,459
would have to migrate these things to

02:30:52,629 --> 02:30:56,829
the kernel and things like that this is

02:30:54,459 --> 02:31:00,759
one way to catch problems but stills are

02:30:56,829 --> 02:31:03,609
very very like a it's too early to say

02:31:00,759 --> 02:31:05,939
that it's useful yeah yeah it's one way

02:31:03,609 --> 02:31:05,939
but

02:31:09,000 --> 02:31:13,990
well I guess my question then is Peter

02:31:12,210 --> 02:31:15,910
you know one of the things that we're

02:31:13,990 --> 02:31:18,580
talking about is is doing a print

02:31:15,910 --> 02:31:20,890
disabled and then trying to do a locking

02:31:18,580 --> 02:31:23,649
operation that's illegal can lock dip

02:31:20,890 --> 02:31:29,850
catch preamp disabled because that's

02:31:23,649 --> 02:31:32,439
that's not a lot yeah so look that

02:31:29,850 --> 02:31:36,240
currently doesn't do that I mean we can

02:31:32,439 --> 02:31:39,790
teach it but we we have neutral annual

02:31:36,240 --> 02:31:42,189
we also my sleeping and we also have

02:31:39,790 --> 02:31:43,750
what's called the new trace points that

02:31:42,189 --> 02:31:46,479
are in preemptive sable and preempt

02:31:43,750 --> 02:31:47,830
enable and we could maybe get locked up

02:31:46,479 --> 02:31:49,330
to hook to the trace well though they

02:31:47,830 --> 02:31:53,070
actually his work to try to get locked

02:31:49,330 --> 02:31:53,070
up to actually touch or be part of those

02:31:54,540 --> 02:31:59,380
well he I mean he's at the conference

02:31:56,950 --> 02:32:03,220
I've seen him yet I'm sorry today Joel

02:31:59,380 --> 02:32:04,720
Fernandes Google yeah he's doing he's

02:32:03,220 --> 02:32:07,750
trying to get it so we get rid of the

02:32:04,720 --> 02:32:11,170
latency tracers and have them be have

02:32:07,750 --> 02:32:13,180
basically the histogram code Thomson new

02:32:11,170 --> 02:32:16,149
C's code hook into that and be able to

02:32:13,180 --> 02:32:20,610
do more dynamic latency tracing so I

02:32:16,149 --> 02:32:20,610
think the was it

02:32:21,439 --> 02:32:27,090
there Mike Mike Mike Mike Mike Mike slow

02:32:24,859 --> 02:32:29,069
right now we don't have those turned on

02:32:27,090 --> 02:32:31,890
by default you know just because the

02:32:29,069 --> 02:32:33,300
wait yeah those guys yeah oh that's

02:32:31,890 --> 02:32:36,180
nothing is I'm wondering if it's a pasta

02:32:33,300 --> 02:32:45,119
that's how hard would be to be able to

02:32:36,180 --> 02:32:48,420
do hooks into BPF to get the hooks into

02:32:45,119 --> 02:32:49,560
local Eric you save and I know there's

02:32:48,420 --> 02:32:50,520
probably will never be production-wise

02:32:49,560 --> 02:32:56,970
yeah

02:32:50,520 --> 02:32:59,100
with a single instructions yeah there's

02:32:56,970 --> 02:33:05,159
single instructions there's really no

02:32:59,100 --> 02:33:07,800
way but oh we could blow up your eye

02:33:05,159 --> 02:33:11,250
gosh I know I was just thinking about

02:33:07,800 --> 02:33:13,289
you know we do have the new static calls

02:33:11,250 --> 02:33:15,210
that are going in now here we can

02:33:13,289 --> 02:33:17,670
Bachelet but we need space to fetch and

02:33:15,210 --> 02:33:19,649
they'll blow up your eye - yeah yeah but

02:33:17,670 --> 02:33:21,779
I'm saying so we can actually find a way

02:33:19,649 --> 02:33:23,460
to know where all the local Eric you say

02:33:21,779 --> 02:33:24,560
like you know alternatives work but

02:33:23,460 --> 02:33:28,550
they'll do that at runtime

02:33:24,560 --> 02:33:28,550
Amy normal after boot up

02:33:30,240 --> 02:33:37,380
well no it will be what I either dad or

02:33:33,600 --> 02:33:40,440
that you're STI and CLI with in three

02:33:37,380 --> 02:33:42,090
and oh that's right this here are those

02:33:40,440 --> 02:33:45,240
things yeah are they're probably like

02:33:42,090 --> 02:33:49,250
single yeah you're probably gonna do

02:33:45,240 --> 02:33:49,250
that you have to extend the yeah the CLI

02:33:53,330 --> 02:34:02,700
but the thing is we don't need so but

02:34:01,110 --> 02:34:04,380
I'm saying is do we need to be care if

02:34:02,700 --> 02:34:11,370
it can't be run on production it's just

02:34:04,380 --> 02:34:13,200
something that we could but yeah

02:34:11,370 --> 02:34:14,970
debugging tool so if we turn on a

02:34:13,200 --> 02:34:16,860
preempt enable the trace points I mean

02:34:14,970 --> 02:34:18,450
it does add overhead but that's a debug

02:34:16,860 --> 02:34:19,800
kernel that you just run it cuz this is

02:34:18,450 --> 02:34:22,800
all about making sure it well then again

02:34:19,800 --> 02:34:25,590
the idea is to make this has to be run

02:34:22,800 --> 02:34:27,350
on every like Linux nest next update to

02:34:25,590 --> 02:34:45,990
make sure that we don't have something

02:34:27,350 --> 02:34:47,430
added okay my fear is this is that you

02:34:45,990 --> 02:34:50,580
get someone who spent a lot of time

02:34:47,430 --> 02:34:52,610
designing something and ended up you

02:34:50,580 --> 02:34:55,290
know with this code in there and then

02:34:52,610 --> 02:34:59,340
that point determine nuts next is

02:34:55,290 --> 02:35:02,190
already too late you won't catch

02:34:59,340 --> 02:35:04,979
anything because they design yes

02:35:02,190 --> 02:35:07,110
magic new facility and you're never ever

02:35:04,979 --> 02:35:11,370
going to run it because you don't even

02:35:07,110 --> 02:35:14,360
know that it exists zero day by that

02:35:11,370 --> 02:35:17,370
does everyone's get tree on kernel.org

02:35:14,360 --> 02:35:20,840
zero date but will not find it because

02:35:17,370 --> 02:35:25,020
you have your new magic newfangled

02:35:20,840 --> 02:35:27,360
crypto whatever did thingy and you do

02:35:25,020 --> 02:35:30,210
not even have a user space which

02:35:27,360 --> 02:35:34,470
exercises that or it's something you

02:35:30,210 --> 02:35:37,020
need network setup to actually use it so

02:35:34,470 --> 02:35:38,370
it's it's just not going to happen so

02:35:37,020 --> 02:35:39,870
basically it's just going to be Trina as

02:35:38,370 --> 02:35:42,590
a bug and say hey guys you guys gotta

02:35:39,870 --> 02:35:47,939
fix this yes

02:35:42,590 --> 02:35:50,460
yep yep yep okay so as Peter just said

02:35:47,939 --> 02:35:54,090
Sheamus might sleep locked up spots and

02:35:50,460 --> 02:35:56,579
etc for a lot of the new stuff which

02:35:54,090 --> 02:36:01,079
people bring in and even if you if

02:35:56,579 --> 02:36:03,689
somebody fixed or enhanced the driver

02:36:01,079 --> 02:36:08,699
interrupt handler by doing magic crap

02:36:03,689 --> 02:36:11,810
then you won't hit it in the in the in

02:36:08,699 --> 02:36:14,789
the CI because you don't have to device

02:36:11,810 --> 02:36:18,539
so the probability death you have to

02:36:14,789 --> 02:36:21,960
device is pretty low right sure I mean

02:36:18,539 --> 02:36:24,720
that's it's something we discussed back

02:36:21,960 --> 02:36:27,840
and forth over the years even in the in

02:36:24,720 --> 02:36:30,539
the regular kernel we do not have to the

02:36:27,840 --> 02:36:32,699
coverage of all the gazillion of devices

02:36:30,539 --> 02:36:34,710
out there because we don't have the

02:36:32,699 --> 02:36:35,850
machines so it's not really locked up

02:36:34,710 --> 02:36:51,630
that we really need but if we get likes

02:36:35,850 --> 02:36:53,850
match and so our documentation states

02:36:51,630 --> 02:36:57,050
that the developer should have

02:36:53,850 --> 02:36:59,430
preemptive looked upon all the other

02:36:57,050 --> 02:37:02,310
fancy-schmancy stuff on one he writes

02:36:59,430 --> 02:37:04,859
new code of course nobody does this

02:37:02,310 --> 02:37:05,880
right well the thing is you could if you

02:37:04,859 --> 02:37:08,130
have all that on there you're not

02:37:05,880 --> 02:37:10,039
testing the other cases either you have

02:37:08,130 --> 02:37:15,510
to like compile it in different aces

02:37:10,039 --> 02:37:17,880
that's normal so in for currency I we've

02:37:15,510 --> 02:37:20,130
talked about adding more debug options

02:37:17,880 --> 02:37:21,779
test I couldn't actually find a list of

02:37:20,130 --> 02:37:22,800
the options that we should turn on so

02:37:21,779 --> 02:37:26,579
locked up is one of the more obvious

02:37:22,800 --> 02:37:28,710
ones but what what I think we should

02:37:26,579 --> 02:37:30,749
really have is a config fragment that

02:37:28,710 --> 02:37:32,579
turns on all the options that you would

02:37:30,749 --> 02:37:36,989
expect people to run and then make it

02:37:32,579 --> 02:37:41,279
very clear type make test conflict test

02:37:36,989 --> 02:37:42,749
start config if when you to do we have a

02:37:41,279 --> 02:37:44,430
kazoo something's come up

02:37:42,749 --> 02:37:46,949
previously on different topics other

02:37:44,430 --> 02:37:49,369
than Artie is do we have a way of like

02:37:46,949 --> 02:37:50,640
Pro like I don't like all profiles but

02:37:49,369 --> 02:37:53,130
config

02:37:50,640 --> 02:37:55,000
I want this type I want to debug config

02:37:53,130 --> 02:37:58,930
give me a debug config

02:37:55,000 --> 02:38:02,170
I want this type of config okay VM

02:37:58,930 --> 02:38:04,510
config yet yet you can use merge there's

02:38:02,170 --> 02:38:05,860
a directory in the kernel tree the name

02:38:04,510 --> 02:38:07,780
of which escapes me right now

02:38:05,860 --> 02:38:11,700
we've config fragments and in which you

02:38:07,780 --> 02:38:15,420
can merge in with merge config CUC make

02:38:11,700 --> 02:38:18,850
def config blah and then you merge in

02:38:15,420 --> 02:38:21,120
like KVM config or there's there's a

02:38:18,850 --> 02:38:24,070
conflict that I put in there for

02:38:21,120 --> 02:38:26,370
disabling power management so you could

02:38:24,070 --> 02:38:29,260
do like make disable power management

02:38:26,370 --> 02:38:30,670
it's not mate disabled but it's you you

02:38:29,260 --> 02:38:32,980
get a def config and then you merge in

02:38:30,670 --> 02:38:34,900
another what we should make it apart to

02:38:32,980 --> 02:38:37,630
make config so we should say like make

02:38:34,900 --> 02:38:41,110
KVM config well yeah the truck they're

02:38:37,630 --> 02:38:42,780
troubling on x86 that's you only have

02:38:41,110 --> 02:38:44,910
def config and that but on other

02:38:42,780 --> 02:38:47,350
architectures you may have multiple

02:38:44,910 --> 02:38:50,350
configure beast configurations you want

02:38:47,350 --> 02:38:53,260
to use so maybe on x86 and make sense to

02:38:50,350 --> 02:38:55,960
do that but for we all we do do you need

02:38:53,260 --> 02:38:57,880
people to know how to do the merging in

02:38:55,960 --> 02:39:00,040
of a config fragment directly as well

02:38:57,880 --> 02:39:03,160
and you might also want to do for

02:39:00,040 --> 02:39:06,490
example k vm + debug yeah like that

02:39:03,160 --> 02:39:08,370
a vm config it's a direct make target

02:39:06,490 --> 02:39:10,780
and it will merge the k vm guest

02:39:08,370 --> 02:39:13,270
fragment into whatever convict you have

02:39:10,780 --> 02:39:23,080
at that moment and we can do something

02:39:13,270 --> 02:39:26,370
similar for debug config RT config RT

02:39:23,080 --> 02:39:26,370
config Evo config and then

02:39:32,260 --> 02:39:35,460
is that okay

02:39:36,301 --> 02:39:40,000
but is there before I know just want

02:39:38,771 --> 02:39:42,311
make sure is there anything else that we

02:39:40,000 --> 02:39:45,250
should be aware of you know that we need

02:39:42,311 --> 02:39:48,221
to when if when preempt RT is in the

02:39:45,250 --> 02:39:50,320
kernel what else do we need to do um is

02:39:48,221 --> 02:39:52,210
there anything that we would have to be

02:39:50,320 --> 02:39:53,740
aware of to make sure like stable back

02:39:52,210 --> 02:39:55,811
ports and stuff like that we are still

02:39:53,740 --> 02:40:06,040
going to have the stable trees available

02:39:55,811 --> 02:40:09,790
for the real time stuff I was about to

02:40:06,040 --> 02:40:12,580
say that because when parity is in the

02:40:09,790 --> 02:40:14,740
upswing kernel we need to advise people

02:40:12,580 --> 02:40:18,250
to avoid lock-in this way or that way

02:40:14,740 --> 02:40:20,860
avoid doing this or that documentation

02:40:18,250 --> 02:40:26,051
but no more try back loops do we get rid

02:40:20,860 --> 02:40:28,240
of a long we should make a Trilok loop

02:40:26,051 --> 02:40:30,660
like crash the kernel I mean just get

02:40:28,240 --> 02:40:30,660
rid of them all

02:40:32,300 --> 02:40:43,980
yeah yeah you're waiting for that magic

02:40:38,310 --> 02:40:48,050
proxy execution stuff I mean come on I I

02:40:43,980 --> 02:40:50,880
really have to mimic Andrew Morton here

02:40:48,050 --> 02:40:53,100
we're talking about the thing for more

02:40:50,880 --> 02:41:05,790
than 10 years now can you please get it

02:40:53,100 --> 02:41:09,920
done I wasn't as mean as Andrew Andrew

02:41:05,790 --> 02:41:09,920
would have said it can't be that hard

02:41:13,400 --> 02:41:18,570
you're the one in charge of this one now

02:41:15,270 --> 02:41:19,260
right oh so you don't wanna talk he's

02:41:18,570 --> 02:41:23,210
tired

02:41:19,260 --> 02:41:27,960
oh no no a big save we only have to

02:41:23,210 --> 02:41:29,760
another 16 minutes so we all want

02:41:27,960 --> 02:41:34,970
because by the way tab elections are

02:41:29,760 --> 02:41:41,130
today so did you want to go up here and

02:41:34,970 --> 02:41:43,080
continue how to catch problems that

02:41:41,130 --> 02:41:45,930
break preempt Artie so this is kind of

02:41:43,080 --> 02:41:53,100
like a segue into it

02:41:45,930 --> 02:42:00,420
I would never propose so many topics

02:41:53,100 --> 02:42:02,689
next time yeah it was Steven sport where

02:42:00,420 --> 02:42:02,689
is the

02:42:31,190 --> 02:42:40,300
Hey here again those red slides again so

02:42:42,010 --> 02:42:47,170
my rent my t-shirt steals right so and

02:42:45,440 --> 02:42:50,360
I'm proud of it

02:42:47,170 --> 02:42:52,460
so how do we catch how can we catch

02:42:50,360 --> 02:42:55,641
problems that can break the pram 30

02:42:52,460 --> 02:43:01,760
premium model and here comes Daniel

02:42:55,641 --> 02:43:03,800
again with his theories and so what is

02:43:01,760 --> 02:43:05,540
the main prematurity feature is the

02:43:03,800 --> 02:43:07,360
premature model is that option that we

02:43:05,540 --> 02:43:12,320
enabled it to fully pre-emptive kernel

02:43:07,360 --> 02:43:16,970
and our prime Shimada tries to make the

02:43:12,320 --> 02:43:19,311
kernel as as primitive as possible but

02:43:16,970 --> 02:43:24,410
still we can disable an enable

02:43:19,311 --> 02:43:26,391
preemption on demand and ok depends on

02:43:24,410 --> 02:43:29,090
what is we can enable table preemption

02:43:26,391 --> 02:43:36,141
on demand and we have some code with if

02:43:29,090 --> 02:43:39,320
they're free and we have a we have a

02:43:36,141 --> 02:43:41,150
more or less the same lock assumptions

02:43:39,320 --> 02:43:43,641
for the no RT kernel but we have

02:43:41,150 --> 02:43:49,760
different locks and the position of the

02:43:43,641 --> 02:43:52,960
locks change so how do we catch problems

02:43:49,760 --> 02:43:56,720
on the RT nowadays like we have this

02:43:52,960 --> 02:43:58,641
scheduling wiring atomic alarm we have a

02:43:56,720 --> 02:44:01,790
lock that telling us that we have a

02:43:58,641 --> 02:44:06,650
problems so we have a lot of fragments

02:44:01,790 --> 02:44:08,990
of checking but they are not a a single

02:44:06,650 --> 02:44:16,000
to that check if the parameter T model

02:44:08,990 --> 02:44:20,230
is being respected so well how can we

02:44:16,000 --> 02:44:23,000
change these fragments of a check into a

02:44:20,230 --> 02:44:25,160
something that tells us that we have a

02:44:23,000 --> 02:44:29,330
problem or that we are breaking a

02:44:25,160 --> 02:44:31,700
parameter T model so we need a formal

02:44:29,330 --> 02:44:36,771
medow form a model that checks the

02:44:31,700 --> 02:44:39,860
parameter T hey and something I I would

02:44:36,771 --> 02:44:41,480
like I will pursue it easier it's not

02:44:39,860 --> 02:44:43,271
something that I have done but something

02:44:41,480 --> 02:44:47,500
that I will work on

02:44:43,271 --> 02:44:52,840
it's using that model that I present try

02:44:47,500 --> 02:44:54,521
to make a way to catch if I changing the

02:44:52,840 --> 02:44:57,880
kernel or a new version of the kernel

02:44:54,521 --> 02:44:59,530
breaks that model because while I was

02:44:57,880 --> 02:45:01,690
developing the model I was trying to

02:44:59,530 --> 02:45:03,641
catch problems in the model right

02:45:01,690 --> 02:45:06,010
because my modeling was wrong because

02:45:03,641 --> 02:45:09,880
the kernel I assumed the kernel is is

02:45:06,010 --> 02:45:12,101
right but us we have a problems on

02:45:09,880 --> 02:45:14,920
kernel we will have a difference between

02:45:12,101 --> 02:45:17,380
the kernel and the model the problem can

02:45:14,920 --> 02:45:18,730
be in the model but after some time the

02:45:17,380 --> 02:45:23,110
problem we start to show up in the

02:45:18,730 --> 02:45:24,820
kernel when we break something and the

02:45:23,110 --> 02:45:28,570
model that I have now it's for a single

02:45:24,820 --> 02:45:31,950
core I will work for SMB this year but

02:45:28,570 --> 02:45:34,090
it also works for most of the problems

02:45:31,950 --> 02:45:36,061
ignoring just the fact of migrated

02:45:34,090 --> 02:45:41,920
disabled in the raw spinlock but still

02:45:36,061 --> 02:45:45,340
it works fine even for SMB already so

02:45:41,920 --> 02:45:47,710
just give one example this is the model

02:45:45,340 --> 02:45:51,010
that explains when we can call this

02:45:47,710 --> 02:45:52,300
scheduler in the sufficient and

02:45:51,010 --> 02:45:56,200
necessary conditions to call the

02:45:52,300 --> 02:46:02,440
scheduler after I'm switch in I start to

02:45:56,200 --> 02:46:05,351
running right I can set my I can set my

02:46:02,440 --> 02:46:08,530
States with Li Po and be asleep about if

02:46:05,351 --> 02:46:11,590
I receive need risk at for example I'll

02:46:08,530 --> 02:46:16,391
be asleep oh but have him being

02:46:11,590 --> 02:46:18,690
preempted and so these are these states

02:46:16,391 --> 02:46:21,670
in which we can have the

02:46:18,690 --> 02:46:25,380
in which we can cow or not call the

02:46:21,670 --> 02:46:28,480
scheduler and the state that brings me

02:46:25,380 --> 02:46:31,960
so some time ago I was why was was

02:46:28,480 --> 02:46:37,510
modeling I catch this tree I got this

02:46:31,960 --> 02:46:41,681
trace so the key worker was switch it in

02:46:37,510 --> 02:46:46,120
it starts run so the task was set to

02:46:41,681 --> 02:46:49,120
sleep about itself while it was in the

02:46:46,120 --> 02:46:51,930
sleepable state while calling on the way

02:46:49,120 --> 02:46:54,790
to call the scheduler

02:46:51,930 --> 02:46:57,220
sad need risk-adverse at it was about to

02:46:54,790 --> 02:47:00,850
be preempted and then it called the

02:46:57,220 --> 02:47:03,220
scheduler by county scheduler it was

02:47:00,850 --> 02:47:06,600
preempted because need risk ed was said

02:47:03,220 --> 02:47:09,850
and another key work started to run

02:47:06,600 --> 02:47:11,860
after sometime this the previous key

02:47:09,850 --> 02:47:16,450
worked this one I'm tracing here

02:47:11,860 --> 02:47:19,600
it was awakened and then it returned to

02:47:16,450 --> 02:47:21,520
the execution but right after returned

02:47:19,600 --> 02:47:26,260
the execution it called the scheduler

02:47:21,520 --> 02:47:28,420
again and then it the scheduler was

02:47:26,260 --> 02:47:31,030
caught but there was no sched switch

02:47:28,420 --> 02:47:34,180
because the trade that was living in the

02:47:31,030 --> 02:47:39,130
trade that was entering was the same so

02:47:34,180 --> 02:47:43,390
this was wait that sounds odd following

02:47:39,130 --> 02:47:46,290
the my model we get we have these this

02:47:43,390 --> 02:47:51,720
state changes like I was set to run

02:47:46,290 --> 02:47:54,430
running and then scared I read here

02:47:51,720 --> 02:47:57,610
sketch which II I was running state

02:47:54,430 --> 02:48:02,530
running then said sleepable state is

02:47:57,610 --> 02:48:05,500
livable and then need were scared okay I

02:48:02,530 --> 02:48:08,650
was going to be preempted in this leap

02:48:05,500 --> 02:48:11,680
above state then this scheduler was

02:48:08,650 --> 02:48:14,800
called Steven the same need risk a

02:48:11,680 --> 02:48:20,080
nearly scared the same scared entry in

02:48:14,800 --> 02:48:23,500
the same to but while I was out of the

02:48:20,080 --> 02:48:26,140
CPU this CAD awakened arrived and so I'm

02:48:23,500 --> 02:48:30,250
preemption to rainbow and then I scared

02:48:26,140 --> 02:48:33,640
switch in and I am running while running

02:48:30,250 --> 02:48:36,070
I called this scheduler and so wait I'm

02:48:33,640 --> 02:48:39,460
calling when I have this I'm calling the

02:48:36,070 --> 02:48:41,740
scheduler in vain so why am i calling

02:48:39,460 --> 02:48:44,410
the scheduler in vain I can be colored

02:48:41,740 --> 02:48:48,130
the scheduling vain if this transition

02:48:44,410 --> 02:48:52,240
here they need risk at takes place into

02:48:48,130 --> 02:48:55,750
a interrupt if I'm going to I'm leaving

02:48:52,240 --> 02:48:57,220
the CPU by myself like the said is the

02:48:55,750 --> 02:49:00,939
task is leaving the CPU because it's

02:48:57,220 --> 02:49:03,610
going to sleep and while going to sleep

02:49:00,939 --> 02:49:04,600
before I call the scheduler I interrupt

02:49:03,610 --> 02:49:07,840
calm

02:49:04,600 --> 02:49:10,930
and it causes a preemption and this and

02:49:07,840 --> 02:49:14,590
then we can arrive here and call the

02:49:10,930 --> 02:49:18,130
schedule in vain but it is okay the

02:49:14,590 --> 02:49:19,680
problem is that in the case that I've I

02:49:18,130 --> 02:49:24,489
was running here

02:49:19,680 --> 02:49:28,330
it was the problem of dispatch while

02:49:24,489 --> 02:49:33,760
while going to call the scheduler I was

02:49:28,330 --> 02:49:37,000
running this cat submit work and during

02:49:33,760 --> 02:49:40,330
these I do I wake up and I suffer I do I

02:49:37,000 --> 02:49:44,350
wake up set it risk at when returning to

02:49:40,330 --> 02:49:47,350
preempt enable I I would check that need

02:49:44,350 --> 02:49:49,989
risk at ease was set and the scheduler

02:49:47,350 --> 02:49:52,630
was caught but the scheduler here was

02:49:49,989 --> 02:49:57,069
caught while was I read was on the way

02:49:52,630 --> 02:49:59,100
to call the scheduler and so these this

02:49:57,069 --> 02:50:02,140
bring me to that case in which I was

02:49:59,100 --> 02:50:04,359
here I suffered the context switch and

02:50:02,140 --> 02:50:07,930
then when I return this tack I would

02:50:04,359 --> 02:50:09,699
call the scheduler again so and this is

02:50:07,930 --> 02:50:11,979
an inefficiency I don't need to call

02:50:09,699 --> 02:50:13,869
this back again all right

02:50:11,979 --> 02:50:15,550
our I would not need to call here

02:50:13,869 --> 02:50:21,840
because I know I'm going to call the

02:50:15,550 --> 02:50:21,840
scheduler so in this

02:50:26,390 --> 02:50:32,850
in this case here the scheduling be

02:50:29,459 --> 02:50:35,699
called in the vein was a problem and the

02:50:32,850 --> 02:50:42,029
model helped me to catch it and it

02:50:35,699 --> 02:50:44,909
turned us and turned out that this

02:50:42,029 --> 02:50:47,789
dispatch was bring me to this

02:50:44,909 --> 02:50:50,489
inefficiency problem and I suggested the

02:50:47,789 --> 02:50:52,020
fix is just ok as I know that I'm going

02:50:50,489 --> 02:50:56,399
to call the scheduler I don't need to

02:50:52,020 --> 02:50:58,350
call the scheduler here and this was one

02:50:56,399 --> 02:51:05,189
case in which the model helped me to

02:50:58,350 --> 02:51:07,560
catch the did ok just to finish there

02:51:05,189 --> 02:51:09,539
the model helped me to catch one problem

02:51:07,560 --> 02:51:10,859
yeah but there's still a problems that I

02:51:09,539 --> 02:51:13,709
just wanna make sure I got this so you

02:51:10,859 --> 02:51:17,010
ran the model here and how did the worry

02:51:13,709 --> 02:51:20,520
that the model point out that issue in

02:51:17,010 --> 02:51:23,159
this trace or okay I was using here I

02:51:20,520 --> 02:51:26,489
was using trace points the trace points

02:51:23,159 --> 02:51:28,380
were being captured using birth and the

02:51:26,489 --> 02:51:30,930
perfume user space was loading the

02:51:28,380 --> 02:51:33,959
automata and comparing the trace with

02:51:30,930 --> 02:51:37,949
the automata when one not one event that

02:51:33,959 --> 02:51:40,260
is not expected takes place it so

02:51:37,949 --> 02:51:43,499
basically that your model didn't have

02:51:40,260 --> 02:51:44,609
that weird thing and then pointed out

02:51:43,499 --> 02:51:46,619
that they actually have something

02:51:44,609 --> 02:51:49,229
happened where you equate that my model

02:51:46,619 --> 02:51:50,789
doesn't have us doing us yeah and so in

02:51:49,229 --> 02:51:52,919
this case the model was pointing that

02:51:50,789 --> 02:51:55,529
and all the case was happening which is

02:51:52,919 --> 02:51:59,939
calling the scheduler when I am in the

02:51:55,529 --> 02:52:02,579
Runa Bo state I guess the point maybe is

02:51:59,939 --> 02:52:05,159
that you saw it we didn't have an

02:52:02,579 --> 02:52:06,989
automated tool don't birth solve it

02:52:05,159 --> 02:52:08,609
no I'm saying oh yeah something I mean

02:52:06,989 --> 02:52:09,989
it came out and said oh there mi saying

02:52:08,609 --> 02:52:11,760
you had you ran through your model and

02:52:09,989 --> 02:52:14,669
something came out and said hey I found

02:52:11,760 --> 02:52:16,890
an anomaly I mean that was know what I'm

02:52:14,669 --> 02:52:20,489
doing now is that I have a perf plugin

02:52:16,890 --> 02:52:25,340
which is the birth desk model and it

02:52:20,489 --> 02:52:25,340
enables the trace points and load

02:52:27,470 --> 02:52:35,760
yeah so basically the thing you're doing

02:52:34,140 --> 02:52:37,979
is you're modeling modeling what you

02:52:35,760 --> 02:52:39,540
expect then running a bunch of traces

02:52:37,979 --> 02:52:41,430
and then see if there's anything that

02:52:39,540 --> 02:52:43,080
breaks what you expect and then you

02:52:41,430 --> 02:52:45,840
analyze it to make sure hey

02:52:43,080 --> 02:52:47,700
that oh I just didn't know this case

02:52:45,840 --> 02:52:49,200
which is a legitimate case or wait a

02:52:47,700 --> 02:52:50,760
minute this is actually something it's

02:52:49,200 --> 02:52:52,770
not broken but it shouldn't really

02:52:50,760 --> 02:52:53,729
happen and like in this case it wasn't

02:52:52,770 --> 02:52:57,780
really broken it was just an

02:52:53,729 --> 02:53:01,710
inefficiency what I'm doing now like on

02:52:57,780 --> 02:53:04,320
the modeling what I'm doing now is that

02:53:01,710 --> 02:53:07,439
I have the model here and I have the

02:53:04,320 --> 02:53:10,530
tracing I have a validation tool which

02:53:07,439 --> 02:53:13,439
is perf that loads the automaton in the

02:53:10,530 --> 02:53:15,960
graphics format and gets the proof data

02:53:13,439 --> 02:53:19,680
tracing and tries to run the automaton

02:53:15,960 --> 02:53:22,860
with the perf data when one unexpected

02:53:19,680 --> 02:53:25,410
event takes place it prints me okay I

02:53:22,860 --> 02:53:27,750
have this on this state I received this

02:53:25,410 --> 02:53:30,000
event and this is not expected and it

02:53:27,750 --> 02:53:32,100
shows me the trace of events that brings

02:53:30,000 --> 02:53:37,410
me to that state and so I can analyze

02:53:32,100 --> 02:53:50,601
the code that that's how its automated

02:53:37,410 --> 02:53:53,301
and but now I'm using this on using okay

02:53:50,601 --> 02:53:56,840
it's not Morris or abettor sister

02:53:53,301 --> 02:53:59,240
because he already knows now I'm doing

02:53:56,840 --> 02:54:01,490
this using birth with phrase point I

02:53:59,240 --> 02:54:05,030
collect all the data put it to user

02:54:01,490 --> 02:54:07,221
space load the model and compare the

02:54:05,030 --> 02:54:10,521
model against the execution and it

02:54:07,221 --> 02:54:12,980
starts Prince me de output saying okay I

02:54:10,521 --> 02:54:15,110
received on this event on this date I

02:54:12,980 --> 02:54:18,021
received this event it put me on this

02:54:15,110 --> 02:54:20,271
other event and so on when one event

02:54:18,021 --> 02:54:23,391
takes place on a state in which it's not

02:54:20,271 --> 02:54:26,061
recognized it brings me the out the

02:54:23,391 --> 02:54:30,620
error and so it points me the cause of

02:54:26,061 --> 02:54:34,311
the error I'm the problem is that like

02:54:30,620 --> 02:54:37,370
on 30 seconds of trace on a single core

02:54:34,311 --> 02:54:39,351
I was generating 2.5 gigs of data in

02:54:37,370 --> 02:54:41,000
that some huge amount of data because

02:54:39,351 --> 02:54:43,851
I'm tracing the all prompted disable all

02:54:41,000 --> 02:54:44,780
print enable autocorrect you enable all

02:54:43,851 --> 02:54:49,910
occur q0

02:54:44,780 --> 02:54:53,420
it's a large amount of trace so just

02:54:49,910 --> 02:54:55,521
just to finish up even though it's a

02:54:53,420 --> 02:54:58,761
large amount of trace I was being able

02:54:55,521 --> 02:55:01,700
to analyze it well because with the

02:54:58,761 --> 02:55:06,141
model all the events from the kernel are

02:55:01,700 --> 02:55:08,870
analyzed in all of one so it's it's

02:55:06,141 --> 02:55:12,530
linear time it's efficient so I could

02:55:08,870 --> 02:55:16,101
analyze 2.5 gigs of data in less than 8

02:55:12,530 --> 02:55:19,130
seconds while analyzing the e while

02:55:16,101 --> 02:55:21,620
running the model so the complete model

02:55:19,130 --> 02:55:24,620
integrated those more than 10,000 states

02:55:21,620 --> 02:55:27,380
or analyze it in all o of one for each

02:55:24,620 --> 02:55:30,410
event it each event of the kernel

02:55:27,380 --> 02:55:32,480
generates just one move in the in the

02:55:30,410 --> 02:55:38,181
automata and that's why it's efficient

02:55:32,480 --> 02:55:39,471
for checking and but yeah this this is

02:55:38,181 --> 02:55:41,690
not OK

02:55:39,471 --> 02:55:44,090
I was doing everything in user space but

02:55:41,690 --> 02:55:46,221
my question here was a red response it

02:55:44,090 --> 02:55:48,891
where should I move because doing this

02:55:46,221 --> 02:55:51,080
in user space it's it's caused me to

02:55:48,891 --> 02:55:54,801
take a lot of data extracting a lot of

02:55:51,080 --> 02:55:57,491
data from the kernel but now that we we

02:55:54,801 --> 02:56:00,491
can use trace hooks

02:55:57,491 --> 02:56:02,891
yeah we can use trace hooks and then I

02:56:00,491 --> 02:56:05,971
can work in the kernel not collecting

02:56:02,891 --> 02:56:09,011
all the data but just recording the last

02:56:05,971 --> 02:56:11,051
from the initial state until the problem

02:56:09,011 --> 02:56:13,571
I will record because I would be able to

02:56:11,051 --> 02:56:15,491
trace from like it when our accusers are

02:56:13,571 --> 02:56:16,061
enabled printer are enabled everything

02:56:15,491 --> 02:56:17,861
is fine

02:56:16,061 --> 02:56:20,531
on to the problem I will start the trace

02:56:17,861 --> 02:56:23,321
and then the other problems are we start

02:56:20,531 --> 02:56:28,511
to throw away and do things inside the

02:56:23,321 --> 02:56:30,730
kernel and that's something I will work

02:56:28,511 --> 02:56:32,980
on my first time in the next year

02:56:30,730 --> 02:56:38,141
it's part of my PhD so I need to do it

02:56:32,980 --> 02:56:42,881
anyway Thomas just wanted to know where

02:56:38,141 --> 02:56:47,771
the ebps plugin is pay me a beer that I

02:56:42,881 --> 02:56:50,831
will show no I'm yeah I don't know if I

02:56:47,771 --> 02:56:53,081
really need to use vpf but with hooks we

02:56:50,831 --> 02:56:54,911
can use BPF we can use a perf we can use

02:56:53,081 --> 02:57:00,011
everything that's why I'm happy with

02:56:54,911 --> 02:57:07,230
hope and what do you guys think I don't

02:57:00,011 --> 02:57:07,230
know in bigger in the States

02:57:10,531 --> 02:57:16,991
okay the size of the dot file like in

02:57:14,711 --> 02:57:21,341
the text wall format it's around 2

02:57:16,991 --> 02:57:23,531
megabytes but it's in textual format if

02:57:21,341 --> 02:57:25,480
we remove these strings and put in a

02:57:23,531 --> 02:57:28,181
binary formative it will be reduced but

02:57:25,480 --> 02:57:32,051
I never reduce still is some some mega

02:57:28,181 --> 02:57:36,011
bytes in the very verbose format I need

02:57:32,051 --> 02:57:38,081
to we can get I load this model in the

02:57:36,011 --> 02:57:40,331
dot format using the graph piece which

02:57:38,081 --> 02:57:42,341
is an open source tool so they already

02:57:40,331 --> 02:57:44,501
have this representation in a data

02:57:42,341 --> 02:57:47,161
structure I need to check the size of

02:57:44,501 --> 02:57:47,161
data structure

02:57:51,620 --> 02:57:58,290
question how can you reduce your search

02:57:54,480 --> 02:58:01,260
space the amount of data you're

02:57:58,290 --> 02:58:05,430
collecting the amount of data I collect

02:58:01,260 --> 02:58:08,521
or the number of states but the trace

02:58:05,430 --> 02:58:11,940
point picking up right now I mean now if

02:58:08,521 --> 02:58:16,740
we do the I collect all the data in the

02:58:11,940 --> 02:58:18,601
data is a lot of oh thanks and then now

02:58:16,740 --> 02:58:20,400
I'm collecting everything input into

02:58:18,601 --> 02:58:22,351
user space but I don't use all that

02:58:20,400 --> 02:58:24,360
information right so if we're doing

02:58:22,351 --> 02:58:29,580
kernel space I will reduce the amount of

02:58:24,360 --> 02:58:34,641
data I will need to do but the number of

02:58:29,580 --> 02:58:34,641
the states of the model it is what it is

02:58:38,750 --> 02:58:44,790
we can make I think that you use the

02:58:42,090 --> 02:58:50,790
beta to make it inside the kernel

02:58:44,790 --> 02:58:52,351
like look I'm sorry like locked up make

02:58:50,790 --> 02:58:54,271
it inside the kernel like locked up you

02:58:52,351 --> 02:58:57,330
said yeah well I mean we could add some

02:58:54,271 --> 02:59:00,021
functionality in there oh that's what's

02:58:57,330 --> 02:59:03,800
take this offline because it's time for

02:59:00,021 --> 02:59:08,000
it's over so thank you everyone

02:59:03,800 --> 02:59:08,000

YouTube URL: https://www.youtube.com/watch?v=GhXZw_TsEzA


