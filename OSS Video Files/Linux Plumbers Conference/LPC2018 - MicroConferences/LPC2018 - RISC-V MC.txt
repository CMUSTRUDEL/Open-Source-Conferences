Title: LPC2018 - RISC-V MC
Publication date: 2018-12-04
Playlist: LPC2018 - MicroConferences
Description: 
	https://linuxplumbersconf.org/event/2/sessions/34/#20181115


The momentum behind RISC-V ecosystem is really commendable and its open nature has a large role in its growth. It allowed contributions from both academic and industry community leading to an unprecedented number of hardware designs proposals in a very short span of time. Soon, a wider variety of RISC-V based hardware boards and extensions 
will be available, allowing a larger choice of applications not limited to embedded micro-controllers. RISC-V software ecosystem also need to grow across the stack so that RISC-V can be a true alternative to existing ISA. Linux kernel support holds the key in this.

The primary objective of the RISC-V track at Plumbers to initiate a community wide discussion about the design problems/ideas for different Linux kernel features implemented or to be implemented. We believe that this will also result in significant increase in active developer participation in code review/patch submissions which will definitely lead to a better & stable kernel for RISC-V.
Captions: 
	00:00:06,380 --> 00:00:12,340
okay so

00:00:10,030 --> 00:00:15,340
you're talking on

00:00:12,340 --> 00:00:19,210
platform specification so this is meant

00:00:15,340 --> 00:00:21,970
to be it's meant to be sort of a

00:00:19,210 --> 00:00:23,650
discussion sort of thing or like it's a

00:00:21,970 --> 00:00:27,880
talk but I do have a handful of slides

00:00:23,650 --> 00:00:35,440
just to kind of you're on the last

00:00:27,880 --> 00:00:37,989
question so we have right now respite

00:00:35,440 --> 00:00:40,000
lands sort of the pack of a platform

00:00:37,989 --> 00:00:42,760
which is something that arose that we

00:00:40,000 --> 00:00:45,850
were doing chips at 13 and then aside by

00:00:42,760 --> 00:00:47,350
our objects we have basically a small

00:00:45,850 --> 00:00:50,079
amount will be flow

00:00:47,350 --> 00:00:52,000
it's based on some internal food staff

00:00:50,079 --> 00:00:54,160
psyche alive and then CEO it's the

00:00:52,000 --> 00:00:57,100
perfect quarter that was really mad it's

00:00:54,160 --> 00:00:59,050
like a tethering test ship rocks eternal

00:00:57,100 --> 00:01:01,090
sort of thing not really meant to be

00:00:59,050 --> 00:01:03,430
people over B Japan after the - Googler

00:01:01,090 --> 00:01:05,410
so we use now those boot and it works

00:01:03,430 --> 00:01:05,770
excessively but it's not really what you

00:01:05,410 --> 00:01:07,270
want

00:01:05,770 --> 00:01:11,950
they don't have any things likely to

00:01:07,270 --> 00:01:14,590
express to them what we've done stuff we

00:01:11,950 --> 00:01:16,030
do now ports of you do core group but

00:01:14,590 --> 00:01:17,709
they're gonna spackle write them too so

00:01:16,030 --> 00:01:20,380
the kinase written to the existing

00:01:17,709 --> 00:01:22,119
platforms and as a result thrown at one

00:01:20,380 --> 00:01:24,130
another we've got two or three companies

00:01:22,119 --> 00:01:27,190
doing two ports people are not straining

00:01:24,130 --> 00:01:30,130
things I'm working so I think that there

00:01:27,190 --> 00:01:31,750
are people are familiar with then the

00:01:30,130 --> 00:01:36,690
next landing we have something called

00:01:31,750 --> 00:01:41,940
the FBI supervisor binary interface what

00:01:36,690 --> 00:01:41,940
I think was I think that we actually

00:01:56,299 --> 00:02:00,979
a disturbing instead of bugs perspire

00:01:58,369 --> 00:02:09,769
spats we had the recent with damos where

00:02:00,979 --> 00:02:12,590
they described as like logical labels we

00:02:09,769 --> 00:02:14,840
have that's basically a set of the buyer

00:02:12,590 --> 00:02:19,310
pitfalls that supervisor is Linux can

00:02:14,840 --> 00:02:24,950
make some sort of this is beo or I think

00:02:19,310 --> 00:02:26,900
corporate because its own spi sir and we

00:02:24,950 --> 00:02:29,299
did this because we ended up with some

00:02:26,900 --> 00:02:30,920
hardware that we don't really like and

00:02:29,299 --> 00:02:33,590
didn't walk with drivers for McDonald's

00:02:30,920 --> 00:02:36,739
primarily didn't quit which is our local

00:02:33,590 --> 00:02:39,890
in our controller that handles IP is a

00:02:36,739 --> 00:02:42,319
mess of timer stuff as well and the

00:02:39,890 --> 00:02:44,360
expected quite a line with the hardware

00:02:42,319 --> 00:02:46,940
really do a quick one in oops we cited

00:02:44,360 --> 00:02:48,260
well hide behind the interface and it

00:02:46,940 --> 00:02:51,110
was inspired by some of the existing

00:02:48,260 --> 00:02:54,319
popular faces like how code it's not

00:02:51,110 --> 00:02:57,470
generally good idea to write portability

00:02:54,319 --> 00:02:59,870
between implementations first lots of

00:02:57,470 --> 00:03:00,709
parts so we have a couple things in

00:02:59,870 --> 00:03:04,250
there that are really meant for

00:03:00,709 --> 00:03:07,880
virtualized environments we do IP is

00:03:04,250 --> 00:03:10,040
remote fences so this is the amount of

00:03:07,880 --> 00:03:12,319
pet project er body if you were running

00:03:10,040 --> 00:03:14,410
on the first line staff and then it's

00:03:12,319 --> 00:03:17,080
also

00:03:14,410 --> 00:03:19,990
this is kinda what we have today the

00:03:17,080 --> 00:03:22,360
plan here is to do a prescribed waffle

00:03:19,990 --> 00:03:29,760
presentation so that this can be

00:03:22,360 --> 00:03:32,920
compatible across stations so how

00:03:29,760 --> 00:03:34,150
responsive patient has done we still

00:03:32,920 --> 00:03:37,140
know if we're going to do the clocks

00:03:34,150 --> 00:03:39,190
back as a inside there's five group

00:03:37,140 --> 00:03:42,940
insiders that foundation for Jabbar's

00:03:39,190 --> 00:03:46,240
membership OpenStack but we do it inside

00:03:42,940 --> 00:03:52,120
the respite services process so there's

00:03:46,240 --> 00:03:55,060
a committee you proposed the Charter to

00:03:52,120 --> 00:03:56,050
the committee and then they the Charter

00:03:55,060 --> 00:03:58,600
specs out let's go over the working

00:03:56,050 --> 00:03:59,590
group and then some sort of time bomb on

00:03:58,600 --> 00:04:06,130
it where you don't get the thing done

00:03:59,590 --> 00:04:07,240
then there's always that me that accepts

00:04:06,130 --> 00:04:10,150
the working group I suppose they could

00:04:07,240 --> 00:04:13,690
reject it don't they sweat on a chair in

00:04:10,150 --> 00:04:16,000
a nice chair members of the response

00:04:13,690 --> 00:04:20,950
should join that working group monthly

00:04:16,000 --> 00:04:24,300
meetings workouts backdrafts eventually

00:04:20,950 --> 00:04:24,300
we use the specification

00:04:49,490 --> 00:04:56,850
so can anybody be part of the Working

00:04:52,620 --> 00:04:59,370
Committee or it has to be yeah once

00:04:56,850 --> 00:05:29,100
you're part of the describe foundation

00:04:59,370 --> 00:05:30,600
and how are going corporations being you

00:05:29,100 --> 00:05:35,760
know sort of represented or not

00:05:30,600 --> 00:05:37,350
represented in those groups yeah I guess

00:05:35,760 --> 00:05:40,940
that the you know the membership to the

00:05:37,350 --> 00:05:40,940
foundation is personal right

00:06:03,330 --> 00:06:08,169
okay so then their participation in

00:06:06,039 --> 00:06:11,139
those groups in those working groups

00:06:08,169 --> 00:06:14,919
they can be like corporate as well or

00:06:11,139 --> 00:06:16,990
only personal I mean my question is how

00:06:14,919 --> 00:06:32,490
are the interest of corporates going to

00:06:16,990 --> 00:06:32,490
be played you know in those groups okay

00:06:52,439 --> 00:06:55,949
okay

00:06:53,559 --> 00:06:55,949
makes sense

00:07:03,450 --> 00:07:24,790
it's mostly the same fall standard

00:07:06,880 --> 00:07:27,100
committees around you wanna make sure

00:07:24,790 --> 00:07:37,840
that the workers actually do produce us

00:07:27,100 --> 00:07:41,610
and so this case what we're gonna do is

00:07:37,840 --> 00:07:44,590
create a respite use class specification

00:07:41,610 --> 00:07:52,240
so it's targeted at kind of the modern

00:07:44,590 --> 00:07:54,610
operating system pro work staff UNIX

00:07:52,240 --> 00:08:00,910
isn't a great name

00:07:54,610 --> 00:08:02,290
it's just kind of the best but the

00:08:00,910 --> 00:08:03,970
attack here is that we're not really

00:08:02,290 --> 00:08:13,420
targeting to a bare metal better

00:08:03,970 --> 00:08:17,040
programmers larger class system is where

00:08:13,420 --> 00:08:17,040
you can afford the cost

00:08:20,300 --> 00:08:26,640
yeah the the inclusive of three stacks

00:08:24,120 --> 00:08:29,040
might actually be restrictive if you put

00:08:26,640 --> 00:08:32,430
Linux in there because you really remove

00:08:29,040 --> 00:09:25,980
Linux and it's still valid on those on

00:08:32,430 --> 00:09:28,770
the spot it seems to me that the word

00:09:25,980 --> 00:09:31,290
that that you're looking to portray here

00:09:28,770 --> 00:09:34,940
through jargon that should be added

00:09:31,290 --> 00:09:38,550
specifically as open you want options

00:09:34,940 --> 00:09:41,390
having you fee and coreboot on the same

00:09:38,550 --> 00:09:44,730
list as each other can make a point

00:09:41,390 --> 00:09:47,070
right the the fact that you want to

00:09:44,730 --> 00:09:50,210
choose which OS you use is the essential

00:09:47,070 --> 00:09:50,210
aspect of this

00:09:55,920 --> 00:10:00,970
now it may seem obvious to anybody who

00:09:58,630 --> 00:10:04,110
understands the whole point of risky but

00:10:00,970 --> 00:10:04,110
it's good to say open

00:11:04,770 --> 00:11:20,170
thank you it's not okay now people

00:11:15,700 --> 00:11:21,670
actually hear me the problem is and if I

00:11:20,170 --> 00:11:23,320
give the same talk twice back-to-back

00:11:21,670 --> 00:11:24,970
you realize how little I plan the talks

00:11:23,320 --> 00:11:32,800
out because they're completely different

00:11:24,970 --> 00:11:35,260
every time anyway yeah so yeah basic

00:11:32,800 --> 00:11:37,660
plan of you class platform specification

00:11:35,260 --> 00:11:39,070
is to allow you know larger operating

00:11:37,660 --> 00:11:40,720
systems you're not the smaller itas

00:11:39,070 --> 00:11:42,160
stuff the larger operating systems to be

00:11:40,720 --> 00:11:43,840
compatible between different vendors

00:11:42,160 --> 00:11:46,240
implementations they also allow for

00:11:43,840 --> 00:11:48,310
multiple firmers to be compatible so you

00:11:46,240 --> 00:11:52,300
can switch out the OS the firmware and

00:11:48,310 --> 00:11:53,500
the implementation okay so the way I

00:11:52,300 --> 00:11:55,060
want to get the ball rolling because

00:11:53,500 --> 00:11:58,030
we've been kicking around this idea for

00:11:55,060 --> 00:12:01,630
a long time an issue is that a platform

00:11:58,030 --> 00:12:03,970
specs really too large to to kind of get

00:12:01,630 --> 00:12:06,730
get going as an entire monolithic

00:12:03,970 --> 00:12:08,560
platform specification and particularly

00:12:06,730 --> 00:12:10,600
in the wrist in wrist five'll and we've

00:12:08,560 --> 00:12:12,310
tried to do a few large specs and you

00:12:10,600 --> 00:12:15,070
know they don't progress and everybody

00:12:12,310 --> 00:12:17,290
argues and then nothing actually gets

00:12:15,070 --> 00:12:19,120
produced so the way I want to do this is

00:12:17,290 --> 00:12:22,240
to split this up into smaller

00:12:19,120 --> 00:12:24,670
specifications where we can kind of take

00:12:22,240 --> 00:12:26,440
on one concrete thing that we know how

00:12:24,670 --> 00:12:28,360
to do get that into a platform

00:12:26,440 --> 00:12:30,670
specification and then go form another

00:12:28,360 --> 00:12:32,410
working group next month or whatever to

00:12:30,670 --> 00:12:35,590
do another one I think the first thing

00:12:32,410 --> 00:12:37,420
we need here is basically a base for the

00:12:35,590 --> 00:12:40,180
platform specification which is to

00:12:37,420 --> 00:12:42,690
specify what we currently have a sort of

00:12:40,180 --> 00:12:45,580
a legacy version with a way to detect

00:12:42,690 --> 00:12:47,320
versions of you know which SPI you have

00:12:45,580 --> 00:12:50,980
so what's the minimum I have predicted

00:12:47,320 --> 00:12:55,600
really support our V 64 GC yeah so I

00:12:50,980 --> 00:12:59,290
think for architectures to support I

00:12:55,600 --> 00:13:01,000
mean is a VM I said that has to be

00:12:59,290 --> 00:13:06,360
supported yeah so I think here we want

00:13:01,000 --> 00:13:12,640
to allow for 32 64 and then ima C and GC

00:13:06,360 --> 00:13:13,660
and just restrict any of the like if

00:13:12,640 --> 00:13:14,080
you're gonna run Linux so you can

00:13:13,660 --> 00:13:16,060
probably for

00:13:14,080 --> 00:13:17,620
to have a multiplier right so just kind

00:13:16,060 --> 00:13:21,070
of don't don't worry about that kind of

00:13:17,620 --> 00:13:22,540
stuff right and at that point I think

00:13:21,070 --> 00:13:23,830
that'll restrict the fragmentation

00:13:22,540 --> 00:13:25,540
that's what we've done in the in

00:13:23,830 --> 00:13:29,200
toolchain land at GCC land those are the

00:13:25,540 --> 00:13:30,640
multi libs in G Lipsy so I think we

00:13:29,200 --> 00:13:38,760
should be kind of safe there yeah what's

00:13:30,640 --> 00:13:42,880
up floating-point so I I G is ima F D

00:13:38,760 --> 00:13:45,070
yeah so ima C has no floating-point and

00:13:42,880 --> 00:13:47,980
then ima FDC is single and double

00:13:45,070 --> 00:13:49,000
precision floating point so I don't yeah

00:13:47,980 --> 00:13:50,380
I think if you have single precision

00:13:49,000 --> 00:13:52,210
floating point we say you have to have

00:13:50,380 --> 00:13:54,190
double precision floating point not in

00:13:52,210 --> 00:13:55,840
at least in Linux land don't mess around

00:13:54,190 --> 00:13:57,940
at that kind of stuff just to avoid

00:13:55,840 --> 00:14:00,100
avoid fragmentation right a

00:13:57,940 --> 00:14:01,450
proliferation of ISA is then they all

00:14:00,100 --> 00:14:03,730
come with a B is right because there's

00:14:01,450 --> 00:14:05,530
an F ABI in a da bi and it just seems

00:14:03,730 --> 00:14:07,810
like it's not really worth the headaches

00:14:05,530 --> 00:14:09,520
just limit the amount of stuff in the

00:14:07,810 --> 00:14:10,780
bare metal of metal and yo the new Lib

00:14:09,520 --> 00:14:13,600
tool chains and that sort of stuff we do

00:14:10,780 --> 00:14:15,190
support f versus D and the whole thing

00:14:13,600 --> 00:14:16,300
because that's important in the deeply

00:14:15,190 --> 00:14:18,370
embedded space where you really care

00:14:16,300 --> 00:14:19,420
about these sort of things I think if

00:14:18,370 --> 00:14:36,400
you can run Linux and you want

00:14:19,420 --> 00:14:38,950
floating-point then just have both yeah

00:14:36,400 --> 00:14:41,740
so this is not an S this is not

00:14:38,950 --> 00:14:44,770
specifically part of the SPI we just got

00:14:41,740 --> 00:14:46,980
derailed by asking a question I guess so

00:14:44,770 --> 00:14:49,660
the SPI spec doesn't need to mandate

00:14:46,980 --> 00:14:52,120
like the fnd part of it because there'll

00:14:49,660 --> 00:15:00,490
be no no that's not part of the SPI

00:14:52,120 --> 00:15:02,710
interface no no no my question so yeah I

00:15:00,490 --> 00:15:05,970
think there's another microphone here if

00:15:02,710 --> 00:15:05,970
you guys want to pass around two of them

00:15:06,730 --> 00:15:30,199
yeah so my question was what's the is it

00:15:12,500 --> 00:15:32,000
on fancy butter is it audible yeah so my

00:15:30,199 --> 00:15:36,139
question was what is the minimum I say

00:15:32,000 --> 00:15:38,420
required for or any kind of UNIX

00:15:36,139 --> 00:15:42,850
operating system that doesn't necessary

00:15:38,420 --> 00:15:48,139
like come with the SP I think so

00:15:42,850 --> 00:15:50,660
understood but I am kind of it's it's

00:15:48,139 --> 00:15:52,850
not I think super relevant to this

00:15:50,660 --> 00:15:55,189
because we want to be operating system

00:15:52,850 --> 00:15:58,220
independent with the SBI so what would

00:15:55,189 --> 00:15:59,509
be the minimum is it run this back so in

00:15:58,220 --> 00:16:02,029
this case the minute I say it would just

00:15:59,509 --> 00:16:03,170
be I that's all you need to do an SPI ok

00:16:02,029 --> 00:16:05,300
because it really doesn't

00:16:03,170 --> 00:16:06,800
the is a extensions don't factor in and

00:16:05,300 --> 00:16:08,660
I don't think people are going to be

00:16:06,800 --> 00:16:12,379
passing floating point arguments and SBI

00:16:08,660 --> 00:16:15,019
calls right in in in current kernel ABI

00:16:12,379 --> 00:16:16,129
yes it's called a bi we don't we don't

00:16:15,019 --> 00:16:18,050
do those so we don't have to have the

00:16:16,129 --> 00:16:20,500
cooperation of kernel a B is i think the

00:16:18,050 --> 00:16:25,720
same point don't have a proliferation of

00:16:20,500 --> 00:16:28,730
SBI maybe ice I guess there's SP ice

00:16:25,720 --> 00:16:30,040
yeah so there will be different calling

00:16:28,730 --> 00:16:32,750
conventions for the 32-bit and 64-bit

00:16:30,040 --> 00:16:34,279
ports the 64-bit Linux won't run on the

00:16:32,750 --> 00:16:36,319
32-bit hardware the 32-bit Linux don't

00:16:34,279 --> 00:16:37,399
run on the 64-bit hardware that's

00:16:36,319 --> 00:16:39,529
because they're different base is a is

00:16:37,399 --> 00:16:43,250
that's kind of a risk five overarching

00:16:39,529 --> 00:16:45,410
thing that we're not gonna change there

00:16:43,250 --> 00:16:47,120
are some proposals to allow for

00:16:45,410 --> 00:16:52,970
configurability of base I say but they

00:16:47,120 --> 00:16:55,819
be two different ones okay yeah so yes

00:16:52,970 --> 00:16:57,350
the plan is to start out by backing what

00:16:55,819 --> 00:16:59,209
we have now in terms of interfaces and

00:16:57,350 --> 00:17:00,290
really a way to version them and a way

00:16:59,209 --> 00:17:02,990
to deal with things like error handling

00:17:00,290 --> 00:17:04,039
and whatnot right so I think the most

00:17:02,990 --> 00:17:05,419
important thing is to figure out like a

00:17:04,039 --> 00:17:07,970
versioning scheme for the platform spec

00:17:05,419 --> 00:17:09,020
so we can figure out how to determine

00:17:07,970 --> 00:17:10,250
whether or not implementation is

00:17:09,020 --> 00:17:11,780
compatible with software and what

00:17:10,250 --> 00:17:14,809
software can rely on is versions of

00:17:11,780 --> 00:17:18,020
hotma respect move forward I and then a

00:17:14,809 --> 00:17:19,160
way to manage those versions like the

00:17:18,020 --> 00:17:21,770
tech different

00:17:19,160 --> 00:17:25,280
from us a a supervisor that got launched

00:17:21,770 --> 00:17:28,189
in an SBI and then we can spec out just

00:17:25,280 --> 00:17:29,780
the legacy SBI is the first module which

00:17:28,189 --> 00:17:32,270
is a set of calls that kind of just

00:17:29,780 --> 00:17:35,000
arose but can at least boot Linux and

00:17:32,270 --> 00:17:38,059
whatnot and then the hope here is this

00:17:35,000 --> 00:17:40,309
is a fairly fast process so we can get

00:17:38,059 --> 00:17:41,990
the core of a platform specification

00:17:40,309 --> 00:17:44,660
ironed out and we can start adding

00:17:41,990 --> 00:17:46,190
different things to it and then I'm

00:17:44,660 --> 00:17:48,740
gonna go through some of the different

00:17:46,190 --> 00:17:50,330
things I think we want to add so it's

00:17:48,740 --> 00:17:52,550
also supervisor more boot

00:17:50,330 --> 00:17:54,590
so are we standardizing what kind of

00:17:52,550 --> 00:17:56,809
good flow which the bootloader has to be

00:17:54,590 --> 00:17:58,190
M more s more so in this case by

00:17:56,809 --> 00:18:01,550
supervisor mode boot I mean basically

00:17:58,190 --> 00:18:03,740
what we have now right like heart ID and

00:18:01,550 --> 00:18:06,710
device tree are in those two registers

00:18:03,740 --> 00:18:08,480
okay so it doesn't mandate wetsuit the

00:18:06,710 --> 00:18:10,280
bootloader run bootloader can run in

00:18:08,480 --> 00:18:12,320
anymore yeah because I want to keep this

00:18:10,280 --> 00:18:23,510
small so we can actually get it done

00:18:12,320 --> 00:18:24,740
okay how about that arm guys in are in

00:18:23,510 --> 00:18:29,000
the room but they're not gonna be very

00:18:24,740 --> 00:18:31,370
talkative one thing that they did really

00:18:29,000 --> 00:18:33,410
right I think on 64-bit arm is that they

00:18:31,370 --> 00:18:36,020
sat down and inspect it out and these

00:18:33,410 --> 00:18:38,360
are the expectations of the bootloader

00:18:36,020 --> 00:18:41,120
and it's actually documented in the

00:18:38,360 --> 00:18:43,010
kernel tree they pick things like we're

00:18:41,120 --> 00:18:44,690
not gonna support compressed image there

00:18:43,010 --> 00:18:46,220
we expect the bootloader to decompress

00:18:44,690 --> 00:18:49,040
the kernel image for you because it has

00:18:46,220 --> 00:18:50,750
more knowledge of where memory should be

00:18:49,040 --> 00:18:52,520
we're suffering on this on 32-bit

00:18:50,750 --> 00:18:56,620
literally last week we had an issue with

00:18:52,520 --> 00:18:59,240
that and a bunch of things like that and

00:18:56,620 --> 00:19:01,070
their practices at this point we should

00:18:59,240 --> 00:19:02,600
look at it and unless there's something

00:19:01,070 --> 00:19:05,360
seriously wrong with it it makes sense

00:19:02,600 --> 00:19:07,460
to do similar things yeah so one I do

00:19:05,360 --> 00:19:09,440
have on the list as one of the working

00:19:07,460 --> 00:19:11,470
groups to be a boot working group

00:19:09,440 --> 00:19:13,640
basically yeah and I think I think that

00:19:11,470 --> 00:19:15,230
that should feed into the platform spec

00:19:13,640 --> 00:19:16,820
because it's part of the platform yes I

00:19:15,230 --> 00:19:18,740
agree so but the plan here is not to

00:19:16,820 --> 00:19:21,050
have this be the entire platform spec

00:19:18,740 --> 00:19:22,340
this is to be like you know 0.10

00:19:21,050 --> 00:19:24,950
platform spec and then the working

00:19:22,340 --> 00:19:26,570
groups can start add to it with one of

00:19:24,950 --> 00:19:29,970
them being a boot working group I also

00:19:26,570 --> 00:19:32,370
like stealing other people's specs

00:19:29,970 --> 00:19:33,420
they're good so yeah no reason to

00:19:32,370 --> 00:19:35,700
reinvent the wheel of something already

00:19:33,420 --> 00:19:38,160
makes sense so from some experience with

00:19:35,700 --> 00:19:40,260
this BSA having a speck and having the

00:19:38,160 --> 00:19:40,830
OEMs audience following it's two

00:19:40,260 --> 00:19:45,480
different things

00:19:40,830 --> 00:19:47,510
yes right now I think and you end up

00:19:45,480 --> 00:19:50,490
sometimes putting in the spec we

00:19:47,510 --> 00:19:53,400
practically stuffed at the odium sorry I

00:19:50,490 --> 00:19:55,820
can hear you end up putting in the spec

00:19:53,400 --> 00:19:59,400
stuff that the odium dudes

00:19:55,820 --> 00:20:01,620
yeah we're the spec was yeah so one of

00:19:59,400 --> 00:20:05,880
the goals here is because we're starting

00:20:01,620 --> 00:20:07,320
on the earlier side that we can get the

00:20:05,880 --> 00:20:08,580
various vendors in the same room and

00:20:07,320 --> 00:20:11,490
actually talk about the stuff that we're

00:20:08,580 --> 00:20:14,850
gonna spec out and make sure it's useful

00:20:11,490 --> 00:20:17,300
and implementable but at a certain point

00:20:14,850 --> 00:20:19,890
I don't know all you can do is try and

00:20:17,300 --> 00:20:22,140
it tends to be that way to everybody

00:20:19,890 --> 00:20:23,880
will want some extensions everybody will

00:20:22,140 --> 00:20:26,790
have vendor-specific extensions to

00:20:23,880 --> 00:20:28,890
experiment with and once it's shown that

00:20:26,790 --> 00:20:31,260
it's a proper good idea you put in the

00:20:28,890 --> 00:20:34,800
spec somewhere right yes you come in and

00:20:31,260 --> 00:20:37,470
that is there like there is a process

00:20:34,800 --> 00:20:40,050
for this in risk v land like we did this

00:20:37,470 --> 00:20:40,590
with our preemptable interrupt

00:20:40,050 --> 00:20:43,440
controller

00:20:40,590 --> 00:20:45,300
yeah it's i-5 where we played around

00:20:43,440 --> 00:20:47,970
with it for a while and then donated the

00:20:45,300 --> 00:20:49,890
spec yes and I mean we did that back

00:20:47,970 --> 00:20:52,230
with power to everybody implemented in

00:20:49,890 --> 00:20:53,910
hardware specific registers and then it

00:20:52,230 --> 00:20:57,360
is beckoning to find a register yeah

00:20:53,910 --> 00:20:59,460
yeah yeah I think that's one of the big

00:20:57,360 --> 00:21:00,720
philosophies behind the horse 5 thing

00:20:59,460 --> 00:21:02,550
with the extensions and like the

00:21:00,720 --> 00:21:04,290
non-standard expansion sanction space

00:21:02,550 --> 00:21:06,000
and had them make them all play to get

00:21:04,290 --> 00:21:14,820
nicely together and we can use the same

00:21:06,000 --> 00:21:16,380
philosophy doing parsec stuff yeah when

00:21:14,820 --> 00:21:19,440
you when you write something like that

00:21:16,380 --> 00:21:23,370
make sure you're going to state the

00:21:19,440 --> 00:21:25,350
obvious I mean define each GPR what it's

00:21:23,370 --> 00:21:27,210
supposed to be when you enter your

00:21:25,350 --> 00:21:32,130
payload whatever kernel

00:21:27,210 --> 00:21:35,310
ok ready people will will mess up with

00:21:32,130 --> 00:21:37,530
that and try to sneak in some new stuff

00:21:35,310 --> 00:21:39,220
because it's been it's been loosely

00:21:37,530 --> 00:21:41,200
defined

00:21:39,220 --> 00:21:44,650
and after you've specified that

00:21:41,200 --> 00:21:47,710
explicitly check in the kernel yes only

00:21:44,650 --> 00:21:49,690
is possible this is another thing with

00:21:47,710 --> 00:21:52,450
the whole and fools absolutely

00:21:49,690 --> 00:21:52,840
everything and force it yeah refused to

00:21:52,450 --> 00:21:56,340
boot

00:21:52,840 --> 00:21:59,169
if your bootloader is a tiny bit crap

00:21:56,340 --> 00:22:01,600
really yeah so we've been trying to do

00:21:59,169 --> 00:22:03,130
this with the user ABI as well right

00:22:01,600 --> 00:22:05,320
where we've got zeros that we do

00:22:03,130 --> 00:22:06,850
actually check in places before again we

00:22:05,320 --> 00:22:08,530
have zeros left around for extension

00:22:06,850 --> 00:22:10,950
basically and we do attempt to check

00:22:08,530 --> 00:22:12,580
them every time we can do it it's

00:22:10,950 --> 00:22:14,409
there's a whole nother thing with a

00:22:12,580 --> 00:22:18,760
compliance suite for this which is

00:22:14,409 --> 00:22:20,620
another pile of work to do so someone in

00:22:18,760 --> 00:22:23,830
the chat room says did you consider

00:22:20,620 --> 00:22:25,240
petty boot I'm not sure what that is if

00:22:23,830 --> 00:22:27,070
there's a question in the chat room so I

00:22:25,240 --> 00:22:29,559
guess no we didn't consider it because I

00:22:27,070 --> 00:22:34,450
don't know what it is okay I don't know

00:22:29,559 --> 00:22:37,750
a exact base we killed up okay it has

00:22:34,450 --> 00:22:39,039
excuses but it's suppose you can boot at

00:22:37,750 --> 00:22:40,539
least once but did but there's a

00:22:39,039 --> 00:22:43,450
circular layer on top of all this anyway

00:22:40,539 --> 00:22:44,980
so yeah yeah so if it's okay exact thing

00:22:43,450 --> 00:22:46,480
and I don't think anything we're doing

00:22:44,980 --> 00:22:56,409
would stop people from doing that kind

00:22:46,480 --> 00:22:59,020
of stuff it would be good to specify the

00:22:56,409 --> 00:23:01,179
boot protocol in a way that definitely

00:22:59,020 --> 00:23:02,590
does not prevent you from using key

00:23:01,179 --> 00:23:04,659
exact because it's easy to make a

00:23:02,590 --> 00:23:06,610
mistake and put something in there that

00:23:04,659 --> 00:23:08,320
makes it impossible to use yeah yeah be

00:23:06,610 --> 00:23:10,600
a little bit careful so with our current

00:23:08,320 --> 00:23:13,419
setup I have sat down and thought about

00:23:10,600 --> 00:23:15,309
how this would work but then people told

00:23:13,419 --> 00:23:19,030
me that it's gonna be a big nightmare so

00:23:15,309 --> 00:23:19,330
I think we we do probably need something

00:23:19,030 --> 00:23:22,169
better

00:23:19,330 --> 00:23:25,720
I just don't know quite what it is yet

00:23:22,169 --> 00:23:27,010
now we do so there are more slides to

00:23:25,720 --> 00:23:28,510
give working groups to go through I

00:23:27,010 --> 00:23:29,770
guess and for the boot working group the

00:23:28,510 --> 00:23:31,630
goal would be to make sure we have a

00:23:29,770 --> 00:23:35,049
boot flow that does make a little more

00:23:31,630 --> 00:23:37,240
sense right now we have this kind of big

00:23:35,049 --> 00:23:39,850
race to enter the kernel boot flow which

00:23:37,240 --> 00:23:42,250
is I've been told it'll be hard for K

00:23:39,850 --> 00:23:43,990
exact style boots yeah on that from

00:23:42,250 --> 00:23:45,970
there isn't just one boot flow you look

00:23:43,990 --> 00:23:47,740
like I'm 64 we have several different

00:23:45,970 --> 00:23:50,460
ways you might boot an enter the kernel

00:23:47,740 --> 00:23:55,120
like EFI non efi

00:23:50,460 --> 00:23:56,200
just yeah so all we need to specify here

00:23:55,120 --> 00:23:57,940
is it really only bitten might have a

00:23:56,200 --> 00:23:59,170
shim in between that and the linux

00:23:57,940 --> 00:24:02,790
pacific blue flow that you might need

00:23:59,170 --> 00:24:02,790
for k exact whatever and that's fine

00:24:03,180 --> 00:24:07,840
should we try to implement something

00:24:05,590 --> 00:24:09,700
like spin table or we just go do no

00:24:07,840 --> 00:24:11,470
implement spin table get rid of it as

00:24:09,700 --> 00:24:14,560
soon as you possibly can it is only a

00:24:11,470 --> 00:24:17,200
nightmare for us since day one she is

00:24:14,560 --> 00:24:20,620
really kill that as early as you

00:24:17,200 --> 00:24:22,300
can do not accept this really okay i

00:24:20,620 --> 00:24:24,700
mean that's that there's no good reason

00:24:22,300 --> 00:24:27,580
for having to implement that you put

00:24:24,700 --> 00:24:30,730
anything like you know we are PSC i on

00:24:27,580 --> 00:24:34,630
the arm side have something if possible

00:24:30,730 --> 00:24:37,900
similar so that we can share stuff but

00:24:34,630 --> 00:24:42,190
do not accept any form of kernel only

00:24:37,900 --> 00:24:44,080
boot and rely on an external piece of

00:24:42,190 --> 00:24:45,670
firmware that will allow you contribute

00:24:44,080 --> 00:24:47,350
that will simplify things like

00:24:45,670 --> 00:24:48,520
virtualization as well because you want

00:24:47,350 --> 00:24:51,520
your hypervisor to follow the same

00:24:48,520 --> 00:24:56,110
scheme so that no compromise on that

00:24:51,520 --> 00:25:02,380
really if you can okay just to take the

00:24:56,110 --> 00:25:04,300
counter approach i mean yeah i suspected

00:25:02,380 --> 00:25:05,920
there going to be some embedded users in

00:25:04,300 --> 00:25:08,050
fact i've talked to quite a few of them

00:25:05,920 --> 00:25:12,670
that do not want any platform firmware

00:25:08,050 --> 00:25:14,770
running other than the kernel the

00:25:12,670 --> 00:25:18,280
question is is it what we're talking

00:25:14,770 --> 00:25:22,540
about here is it does this spec apply to

00:25:18,280 --> 00:25:25,630
this really deeply embedded only simple

00:25:22,540 --> 00:25:28,990
linux payload no firmware type of

00:25:25,630 --> 00:25:31,950
application or we actually looking at at

00:25:28,990 --> 00:25:34,150
something that is a bit more upscale

00:25:31,950 --> 00:25:36,280
well you're right i suspect that those

00:25:34,150 --> 00:25:40,120
folks won't be using SBI at all so in

00:25:36,280 --> 00:25:42,820
the context of SBI is specific SBI spec

00:25:40,120 --> 00:25:44,050
it would be it would have farmers this

00:25:42,820 --> 00:25:47,860
is the first version and that's how we

00:25:44,050 --> 00:25:48,850
design the flow but the boot so one

00:25:47,860 --> 00:25:50,770
thing I also want to do with the bare

00:25:48,850 --> 00:25:52,420
metal compatibility for boot loaders is

00:25:50,770 --> 00:25:54,100
make sure that we can route a bare metal

00:25:52,420 --> 00:25:58,090
Linux for people want to do the embedded

00:25:54,100 --> 00:26:01,060
stuff yes but the the moment you want a

00:25:58,090 --> 00:26:03,700
secondary CPU to enter the kernel you're

00:26:01,060 --> 00:26:06,909
going to require either it's been

00:26:03,700 --> 00:26:09,880
tables which is dreadful or some form of

00:26:06,909 --> 00:26:11,350
firmware interface to drop them the

00:26:09,880 --> 00:26:13,960
second receipt be using your colonel yes

00:26:11,350 --> 00:26:16,960
so in this case for the yeah the the

00:26:13,960 --> 00:26:18,490
boot floor we do for the virtualized

00:26:16,960 --> 00:26:21,279
boot flow the SBI boot flow you'd bring

00:26:18,490 --> 00:26:24,760
up the other heart's threads cores

00:26:21,279 --> 00:26:26,289
whatever by an SBI call I'm and then for

00:26:24,760 --> 00:26:29,289
the bare metal version you do it by

00:26:26,289 --> 00:26:32,440
plugging some registers on the device to

00:26:29,289 --> 00:26:35,260
spend anything up once you have the SBI

00:26:32,440 --> 00:26:36,519
spec also you have a you have one place

00:26:35,260 --> 00:26:37,809
where people could plug in native

00:26:36,519 --> 00:26:39,610
implementations if they wanted to

00:26:37,809 --> 00:26:40,679
underneath and you you still have one

00:26:39,610 --> 00:26:44,980
API

00:26:40,679 --> 00:26:46,480
ideally in one behavior you could even

00:26:44,980 --> 00:26:51,610
instantiate your own SBI if you need to

00:26:46,480 --> 00:26:52,870
do from the kernel right so yes but if

00:26:51,610 --> 00:26:56,080
we get to the point where you need a

00:26:52,870 --> 00:26:58,029
hardware interface it might also be

00:26:56,080 --> 00:27:00,039
necessary to specify that hardware

00:26:58,029 --> 00:27:02,380
interface that was so that was the goal

00:27:00,039 --> 00:27:04,659
of this kind of boot working group I

00:27:02,380 --> 00:27:06,490
have a at least a couple short slide

00:27:04,659 --> 00:27:08,380
short bullets on it it's but make sure

00:27:06,490 --> 00:27:09,669
that for the low-level boot stuff which

00:27:08,380 --> 00:27:13,769
would be either be a bare metal Linux

00:27:09,669 --> 00:27:16,299
boot or a boot loader that that has a

00:27:13,769 --> 00:27:17,980
compatible hardware interface right so

00:27:16,299 --> 00:27:21,250
it doesn't make sense to support both

00:27:17,980 --> 00:27:23,289
SPI for bringing up the second CPU and a

00:27:21,250 --> 00:27:26,230
hardware interface for bringin so that

00:27:23,289 --> 00:27:27,789
and should avoid is having twelve

00:27:26,230 --> 00:27:29,260
different versions of hardware

00:27:27,789 --> 00:27:33,610
interfaces for bringing up the second

00:27:29,260 --> 00:27:35,799
CPU of specifying one is that we can

00:27:33,610 --> 00:27:37,840
have one at least for the simple stuff

00:27:35,799 --> 00:27:39,159
and avoid having because this is one of

00:27:37,840 --> 00:27:41,470
those things that tends to be different

00:27:39,159 --> 00:27:43,090
but not really better or worse it's just

00:27:41,470 --> 00:27:48,580
kind of different I guess that makes

00:27:43,090 --> 00:27:51,340
sense do we add we allow we allow a

00:27:48,580 --> 00:27:54,190
Linux platform to boot without SPI are

00:27:51,340 --> 00:27:57,220
some for my interface yes my intent of

00:27:54,190 --> 00:27:59,080
specking the you know bare metal boot

00:27:57,220 --> 00:28:01,330
version out is that it can be used for

00:27:59,080 --> 00:28:03,970
both firmware and for a bend metal Linux

00:28:01,330 --> 00:28:06,580
the same kernel image can detect if it's

00:28:03,970 --> 00:28:09,130
booted in bare metal mode or SPI mode

00:28:06,580 --> 00:28:11,950
right which we have we walked through on

00:28:09,130 --> 00:28:14,260
a mailing list at some point so you can

00:28:11,950 --> 00:28:15,760
have compatibility between yeah one

00:28:14,260 --> 00:28:16,400
kernel image boots the bare metal mode

00:28:15,760 --> 00:28:19,130
or

00:28:16,400 --> 00:28:20,960
and as we I'm out but in that case then

00:28:19,130 --> 00:28:23,720
the boot protocol will change because

00:28:20,960 --> 00:28:26,360
let's say protocol will clearly say that

00:28:23,720 --> 00:28:28,820
okay here is my first boot CPU then yeah

00:28:26,360 --> 00:28:30,830
all CPU on CP of sequentially 0 1 2 3

00:28:28,820 --> 00:28:32,420
let's say yeah yeah sort of bare metal

00:28:30,830 --> 00:28:34,340
Linux it will completely change and it's

00:28:32,420 --> 00:28:35,590
yeah yeah and there'd be no SPI in the

00:28:34,340 --> 00:28:38,000
bare metal blanks

00:28:35,590 --> 00:28:41,320
would that change the code a lot between

00:28:38,000 --> 00:28:44,120
the two because if you have a lot of ifs

00:28:41,320 --> 00:28:46,820
because of different branches everywhere

00:28:44,120 --> 00:28:49,429
for the two cases being environmental

00:28:46,820 --> 00:28:52,070
you better off probably with a different

00:28:49,429 --> 00:28:54,020
platform for the kernel side for the

00:28:52,070 --> 00:28:57,410
bare metal and just go for the SPI at

00:28:54,020 --> 00:29:00,320
the beginning only we solve this years

00:28:57,410 --> 00:29:02,179
ago on PowerPC and other platforms by

00:29:00,320 --> 00:29:04,640
having machine descriptor structs where

00:29:02,179 --> 00:29:06,679
you plug in function pointers if that's

00:29:04,640 --> 00:29:10,970
too slow to take indirect branches well

00:29:06,679 --> 00:29:13,280
we patch in direct calls instead yeah

00:29:10,970 --> 00:29:18,559
the thing that can be done in a

00:29:13,280 --> 00:29:20,630
reasonable fashion does it have to be

00:29:18,559 --> 00:29:22,160
one spec or can it be UNIX platforms

00:29:20,630 --> 00:29:23,960
back with SP a and then something else

00:29:22,160 --> 00:29:26,510
which is deeply embedded bare metal

00:29:23,960 --> 00:29:30,020
Linux or anything every anything else

00:29:26,510 --> 00:29:32,240
let's try not to go there now yeah yeah

00:29:30,020 --> 00:29:34,460
so I've been back and forth on this as

00:29:32,240 --> 00:29:37,580
to whether it's one Spectre two specs I

00:29:34,460 --> 00:29:39,830
think it's easier if it's one spec okay

00:29:37,580 --> 00:29:41,480
I also strongly believe that embedded is

00:29:39,830 --> 00:29:44,240
the space we'll have most activity in

00:29:41,480 --> 00:29:46,780
the first place so doing the big

00:29:44,240 --> 00:29:52,730
elaborate one leave room for it but I

00:29:46,780 --> 00:29:54,830
mean nobody's gonna build 64 core you

00:29:52,730 --> 00:29:58,610
know server class enterprise hardware

00:29:54,830 --> 00:30:02,000
yet yeah I mean I I say independent

00:29:58,610 --> 00:30:05,540
that's a lot of work to build one right

00:30:02,000 --> 00:30:07,520
so yeah I think making sure that the the

00:30:05,540 --> 00:30:09,830
you know bare metal side the bare metal

00:30:07,520 --> 00:30:11,630
side of spec and the SPI links I suspect

00:30:09,830 --> 00:30:13,070
play well play nicely together I think

00:30:11,630 --> 00:30:15,559
will be easier to do if we have them in

00:30:13,070 --> 00:30:17,870
one spec all right and then it's really

00:30:15,559 --> 00:30:20,030
one spec and where you kind of split the

00:30:17,870 --> 00:30:21,800
software that's running on whether you

00:30:20,030 --> 00:30:23,809
have bootloader bootloader kernel or

00:30:21,800 --> 00:30:26,120
kernel bare metal and I know you're

00:30:23,809 --> 00:30:28,190
still on the under SPI slide there's

00:30:26,120 --> 00:30:28,950
been a lot of did if you read the public

00:30:28,190 --> 00:30:30,809
ministers

00:30:28,950 --> 00:30:32,100
a lot of discussion and yeah whenever

00:30:30,809 --> 00:30:33,809
somebody mentioned you know the

00:30:32,100 --> 00:30:35,940
two-letter Deaton word that starts with

00:30:33,809 --> 00:30:37,679
D and ends with T somebody comes with a

00:30:35,940 --> 00:30:43,950
four-letter word that starts with a and

00:30:37,679 --> 00:30:45,299
then I yeah and it's you know I my

00:30:43,950 --> 00:30:48,090
stands and it doesn't really matter what

00:30:45,299 --> 00:30:49,649
my stance here is but sure they'll

00:30:48,090 --> 00:30:51,570
probably be AC para platforms in the

00:30:49,649 --> 00:30:52,919
future we don't need to architect for

00:30:51,570 --> 00:30:54,870
them now we need to leave space for them

00:30:52,919 --> 00:30:58,169
when it's time look that landmark has a

00:30:54,870 --> 00:30:59,909
comment I just say I'm not from from the

00:30:58,169 --> 00:31:02,669
arm side I mean SBI is effectively the

00:30:59,909 --> 00:31:05,130
equivalent of arms SMCC cpr CI and that

00:31:02,669 --> 00:31:07,649
kind of thing those do not mention dt or

00:31:05,130 --> 00:31:10,950
a CPI at all what we're looking for is

00:31:07,649 --> 00:31:13,440
more to SPCA SPSA equivalent not the SBB

00:31:10,950 --> 00:31:16,019
are necessarily an auto shop I mean the

00:31:13,440 --> 00:31:17,519
SBI specifically the supervisor binary

00:31:16,019 --> 00:31:19,260
interface or assistant bar near each

00:31:17,519 --> 00:31:21,450
place whatever binary interface it is is

00:31:19,260 --> 00:31:23,340
more than coolant of SMCC cpr CI and

00:31:21,450 --> 00:31:25,529
none of that part if that part is

00:31:23,340 --> 00:31:27,990
specifying DTR a CPI something has

00:31:25,529 --> 00:31:30,269
already gone wrong yeah yeah one of the

00:31:27,990 --> 00:31:32,190
goals here is to avoid mentioning a

00:31:30,269 --> 00:31:34,380
device tree and just call it

00:31:32,190 --> 00:31:35,970
yes I'm sort of firmware probing

00:31:34,380 --> 00:31:37,740
mechanism or something like that you got

00:31:35,970 --> 00:31:41,700
to have one and then but then the issue

00:31:37,740 --> 00:31:44,250
is that sometimes if you try to specify

00:31:41,700 --> 00:31:46,260
something that's not fully specified

00:31:44,250 --> 00:31:48,779
then you get issues yeah I'd like to

00:31:46,260 --> 00:31:50,730
think that in your SBI standard you will

00:31:48,779 --> 00:31:53,429
either need a mechanism for the hardware

00:31:50,730 --> 00:31:55,620
to tell you you have SBI or you say your

00:31:53,429 --> 00:31:57,179
foot or whatever your firmware is tells

00:31:55,620 --> 00:31:58,740
you and then each of your firmwares has

00:31:57,179 --> 00:32:01,230
to have its own mechanism for doing that

00:31:58,740 --> 00:32:04,289
yeah yeah certainly the SBI will not

00:32:01,230 --> 00:32:07,200
mention device to your I mean I guess

00:32:04,289 --> 00:32:09,450
there might be a yeah SBI call that's

00:32:07,200 --> 00:32:11,370
you know get me is this a device tree or

00:32:09,450 --> 00:32:14,519
something I don't think you want that at

00:32:11,370 --> 00:32:16,500
all like what you want is you you boot

00:32:14,519 --> 00:32:18,240
your operating system it gets some data

00:32:16,500 --> 00:32:20,789
structure or it can probe the hardware

00:32:18,240 --> 00:32:22,799
and finds like it has SBI that might be

00:32:20,789 --> 00:32:24,240
it gets given a DT and it finds a DT

00:32:22,799 --> 00:32:25,980
note it says hey you have SBI it might

00:32:24,240 --> 00:32:27,299
be that it gets given some ACPI tables

00:32:25,980 --> 00:32:29,070
it looks in there and finds oh you've

00:32:27,299 --> 00:32:30,659
got SBI it might be there is some

00:32:29,070 --> 00:32:34,080
architected register that you have will

00:32:30,659 --> 00:32:38,350
yes right now now the way you determine

00:32:34,080 --> 00:32:40,360
if you have SBI or not is via looking at

00:32:38,350 --> 00:32:43,090
a register on the architecture if you

00:32:40,360 --> 00:32:45,250
boot in s mode then you have SBI because

00:32:43,090 --> 00:32:46,990
you had there are M mode things that

00:32:45,250 --> 00:32:49,630
must be done in order to so M mode is

00:32:46,990 --> 00:32:51,940
the platform former mode and SBI is

00:32:49,630 --> 00:32:53,950
super motor supervisor mode alright so

00:32:51,940 --> 00:32:56,080
if you boot if linux gets booted up in s

00:32:53,950 --> 00:32:57,669
mode then there must be an SPI because

00:32:56,080 --> 00:32:59,260
that's the only way to get to the M mode

00:32:57,669 --> 00:33:01,750
functionality so that's currently the

00:32:59,260 --> 00:33:04,990
plan for probing whether or not you have

00:33:01,750 --> 00:33:08,350
an SPI and if you boot an M mode there

00:33:04,990 --> 00:33:10,720
must not be an SPI because I think we're

00:33:08,350 --> 00:33:16,630
saying here we probably should never

00:33:10,720 --> 00:33:18,400
boot in M mode right so again I went so

00:33:16,630 --> 00:33:21,850
that I think the bare metal boot flow is

00:33:18,400 --> 00:33:23,200
an M mode boots even environmental you

00:33:21,850 --> 00:33:24,669
tend to have a very very early

00:33:23,200 --> 00:33:26,950
bootloader no matter what you're doing

00:33:24,669 --> 00:33:28,450
it today pretty much everybody needs at

00:33:26,950 --> 00:33:29,950
least signature verify what they're

00:33:28,450 --> 00:33:31,840
gonna boot most people have started

00:33:29,950 --> 00:33:32,950
getting so I think you'll have a little

00:33:31,840 --> 00:33:34,600
bit of software running before the

00:33:32,950 --> 00:33:36,280
kernel yeah yeah so I think a boot boot

00:33:34,600 --> 00:33:37,480
loader is fine alright the issue is is

00:33:36,280 --> 00:33:39,580
there anything resident while the

00:33:37,480 --> 00:33:40,750
kernels running and if there's an SPI

00:33:39,580 --> 00:33:42,520
then there's something there has to be

00:33:40,750 --> 00:33:45,070
something resident in M mode while the

00:33:42,520 --> 00:33:47,770
kernel is running because the ask guys

00:33:45,070 --> 00:33:50,080
in blinded by trapping into M mode or

00:33:47,770 --> 00:33:52,059
you could have a way of on those

00:33:50,080 --> 00:33:53,890
platforms allowing the kernel to take

00:33:52,059 --> 00:33:56,650
over a mode and install its own right

00:33:53,890 --> 00:33:58,960
yeah and that's but the only way to take

00:33:56,650 --> 00:34:00,880
over M mode is to start in M mode it's

00:33:58,960 --> 00:34:04,539
currently how it's set up

00:34:00,880 --> 00:34:06,760
basically I don't think it'd be I don't

00:34:04,539 --> 00:34:08,500
think it'd be any easier if we had the

00:34:06,760 --> 00:34:10,240
boot loader go into S mode and then have

00:34:08,500 --> 00:34:12,220
an SPI call that dropped you back into M

00:34:10,240 --> 00:34:13,419
mode because then the burglar would have

00:34:12,220 --> 00:34:15,909
to be resident at least for some amount

00:34:13,419 --> 00:34:18,490
of time we should have some headaches

00:34:15,909 --> 00:34:20,619
and you know Lisa still needs know about

00:34:18,490 --> 00:34:21,909
M mode staccato you can't assume that

00:34:20,619 --> 00:34:24,520
the bootloader provides you with a

00:34:21,909 --> 00:34:26,260
default SPI implementation that will get

00:34:24,520 --> 00:34:28,060
you off the ground and you don't have to

00:34:26,260 --> 00:34:31,840
do that does help and there are some

00:34:28,060 --> 00:34:34,210
early debug sort of things in SPI land

00:34:31,840 --> 00:34:36,669
that would be convenient to have in

00:34:34,210 --> 00:34:38,800
super early boot but I think it's gonna

00:34:36,669 --> 00:34:41,109
be more of a headache to go up and down

00:34:38,800 --> 00:34:43,960
you can also have a boot loader that

00:34:41,109 --> 00:34:48,010
only leaves the resident the way of

00:34:43,960 --> 00:34:49,670
installing hooks into a mode yeah so

00:34:48,010 --> 00:34:55,230
unfortunately right now

00:34:49,670 --> 00:34:59,250
yeah the the the way the specification

00:34:55,230 --> 00:35:01,680
is written you kind of can't do that if

00:34:59,250 --> 00:35:04,320
that makes sense so you can you know

00:35:01,680 --> 00:35:07,920
start in M mode leave resident just they

00:35:04,320 --> 00:35:10,290
installed hooks code and then change in

00:35:07,920 --> 00:35:11,490
test mode and book the colonel yeah yeah

00:35:10,290 --> 00:35:14,070
but at that point then you have to have

00:35:11,490 --> 00:35:18,330
something I mean something's resident in

00:35:14,070 --> 00:35:20,430
M mode at that point just to channel it

00:35:18,330 --> 00:35:23,120
can be not a lot of stuff resident in M

00:35:20,430 --> 00:35:26,580
mode right but I don't see how that

00:35:23,120 --> 00:35:28,680
helps I guess yeah just to channel the

00:35:26,580 --> 00:35:31,290
coreboot guys I think what they're I

00:35:28,680 --> 00:35:34,230
think concerned mostly about is not so

00:35:31,290 --> 00:35:36,300
much the technical aspects of it but the

00:35:34,230 --> 00:35:37,830
actual what actually gets built so

00:35:36,300 --> 00:35:39,830
they're looking at a bunch of x86

00:35:37,830 --> 00:35:42,450
systems that have non-replaceable

00:35:39,830 --> 00:35:45,660
platform firmware and they want to avoid

00:35:42,450 --> 00:35:47,190
that if they can so you know who knows

00:35:45,660 --> 00:35:48,510
how that's actually going to come out in

00:35:47,190 --> 00:35:58,710
practice but I think that's what they're

00:35:48,510 --> 00:36:02,210
concerned about how many slides I have I

00:35:58,710 --> 00:36:04,800
don't know like 30

00:36:02,210 --> 00:36:11,070
this is the exact opposite of the time T

00:36:04,800 --> 00:36:12,120
talk yeah well okay so I gave the time T

00:36:11,070 --> 00:36:14,280
talk where it was told I would be

00:36:12,120 --> 00:36:16,050
heckled if I had more than three slides

00:36:14,280 --> 00:36:18,090
but then I didn't have anything to talk

00:36:16,050 --> 00:36:22,650
about now you guys are asking all these

00:36:18,090 --> 00:36:27,660
questions yeah I'm totally cool just we

00:36:22,650 --> 00:36:29,550
can move on sorry I can't hear you have

00:36:27,660 --> 00:36:34,260
you thought about adopting petite boat

00:36:29,550 --> 00:36:36,690
or what petite boat but it'd be Betty

00:36:34,260 --> 00:36:37,490
please yeah yeah somebody asked that on

00:36:36,690 --> 00:36:40,170
the Internet

00:36:37,490 --> 00:36:46,790
okay and the answer is that we thought

00:36:40,170 --> 00:36:46,790
about it a little bit what

00:36:47,100 --> 00:36:56,580
yeah yeah okay so I guess on to the next

00:36:52,080 --> 00:36:58,320
talk right no no I don't I have really

00:36:56,580 --> 00:37:00,030
generally when I'm giving a talk I don't

00:36:58,320 --> 00:37:04,560
really have like a vested interest in

00:37:00,030 --> 00:37:07,080
getting through all of my slides I give

00:37:04,560 --> 00:37:09,840
the talk then mostly so we can talk

00:37:07,080 --> 00:37:13,730
about stuff so I'm totally cool coming

00:37:09,840 --> 00:37:13,730
on to the next talk takes a little time

00:38:03,990 --> 00:38:13,890
hi so so what basically explains why it

00:38:10,770 --> 00:38:16,230
is important and why we need to do it

00:38:13,890 --> 00:38:18,480
good speaking on SPI so I'll go into

00:38:16,230 --> 00:38:20,520
more details on what's currently there

00:38:18,480 --> 00:38:22,859
how are planning to or what's the

00:38:20,520 --> 00:38:25,320
proposal being discussed just before

00:38:22,859 --> 00:38:27,720
that I just wanted to mention that we

00:38:25,320 --> 00:38:31,109
have just wanted to in case anybody in

00:38:27,720 --> 00:38:33,780
the room doesn't know we have a demo

00:38:31,109 --> 00:38:37,200
running with the RISC Phibes i fiber

00:38:33,780 --> 00:38:39,630
board which is a four core and it runs

00:38:37,200 --> 00:38:43,320
Fedora 29 we have a media server running

00:38:39,630 --> 00:38:46,410
on streaming 4k videos from the risk v

00:38:43,320 --> 00:38:49,260
media server which runs federer 29 to

00:38:46,410 --> 00:38:51,300
the x86 laptop so if anybody during the

00:38:49,260 --> 00:38:53,010
break or after the after the session

00:38:51,300 --> 00:38:56,339
want to talk about what you want to say

00:38:53,010 --> 00:38:59,730
that's they're coming back to the SPI so

00:38:56,339 --> 00:39:02,550
we had a lot of talk on SPI so what

00:38:59,730 --> 00:39:04,380
exactly is SPI since probably everybody

00:39:02,550 --> 00:39:06,390
in the room already has an idea I'll

00:39:04,380 --> 00:39:09,089
quickly go through the slide it's just

00:39:06,390 --> 00:39:11,670
an interface between supervisor more and

00:39:09,089 --> 00:39:14,790
M more that's the calling convention

00:39:11,670 --> 00:39:16,830
it's a trap that goes from supervisor

00:39:14,790 --> 00:39:18,780
mode we call he call and it goes into

00:39:16,830 --> 00:39:21,060
the M mode and then there we figure out

00:39:18,780 --> 00:39:23,099
what kind of SPI call it and then we

00:39:21,060 --> 00:39:26,030
take appropriate access the M mode take

00:39:23,099 --> 00:39:29,030
appropriate action so currently it's

00:39:26,030 --> 00:39:32,640
Palmer said it's provided by the BBL

00:39:29,030 --> 00:39:35,160
which in future when we have more

00:39:32,640 --> 00:39:36,089
respect will probably replace it or

00:39:35,160 --> 00:39:39,030
modify it

00:39:36,089 --> 00:39:41,550
that's a talk about the future so this

00:39:39,030 --> 00:39:44,490
is what the current status of SBI is so

00:39:41,550 --> 00:39:48,240
we have something called time off but so

00:39:44,490 --> 00:39:49,890
in risk 5 the timer register the one the

00:39:48,240 --> 00:39:51,510
timer compare register which you modify

00:39:49,890 --> 00:39:53,609
to get the periodic timer is in the M

00:39:51,510 --> 00:39:56,940
mode access only so you make an sba call

00:39:53,609 --> 00:39:59,880
to get it similarly we have the IP I to

00:39:56,940 --> 00:40:02,280
the console characters to access the sba

00:39:59,880 --> 00:40:05,790
control for the early print k and then

00:40:02,280 --> 00:40:07,560
the memory racing for the TLB flush and

00:40:05,790 --> 00:40:11,130
then we have the shutdown so these are

00:40:07,560 --> 00:40:13,440
the standard the legacy s because what

00:40:11,130 --> 00:40:15,390
mohammad mentioned the problem with it

00:40:13,440 --> 00:40:17,640
the or the problem with the current

00:40:15,390 --> 00:40:19,559
implementation is it's fixed so

00:40:17,640 --> 00:40:22,740
there is no way we could have a with

00:40:19,559 --> 00:40:25,230
item or boot protocol sort we are two

00:40:22,740 --> 00:40:26,819
more power management functions there is

00:40:25,230 --> 00:40:29,490
no way we could change it change

00:40:26,819 --> 00:40:32,010
anything without breaking the backward

00:40:29,490 --> 00:40:35,190
compiler compatibility it's not yet

00:40:32,010 --> 00:40:37,319
standard documentation that just

00:40:35,190 --> 00:40:39,150
mentioned what are all these and what

00:40:37,319 --> 00:40:41,430
are the calling convention but it's not

00:40:39,150 --> 00:40:43,799
discussed through the community and then

00:40:41,430 --> 00:40:46,260
it's not standard and then the return

00:40:43,799 --> 00:40:48,420
value every function has a standard

00:40:46,260 --> 00:40:51,480
different return or error value which is

00:40:48,420 --> 00:40:53,700
also problem as coreboot guys who have

00:40:51,480 --> 00:40:55,470
implemented already mentioned it another

00:40:53,700 --> 00:40:57,589
problem since it's not standardized

00:40:55,470 --> 00:41:01,279
there is no reference implementation

00:40:57,589 --> 00:41:04,109
there now there is a trend to

00:41:01,279 --> 00:41:06,779
fragmentation off the SPI implementation

00:41:04,109 --> 00:41:08,910
so coreboot has a different one the BBL

00:41:06,779 --> 00:41:10,500
which is the berkeley boot rotor has a

00:41:08,910 --> 00:41:14,760
different one they're completely

00:41:10,500 --> 00:41:18,210
separately different in future we'd like

00:41:14,760 --> 00:41:20,369
to have one standard spec with one

00:41:18,210 --> 00:41:22,529
standard implementation and then anybody

00:41:20,369 --> 00:41:24,569
who wants to fork it change it they're

00:41:22,529 --> 00:41:26,220
welcome to do it but at least we have a

00:41:24,569 --> 00:41:28,529
reference implementation that boots

00:41:26,220 --> 00:41:32,609
almost all the platforms unless somebody

00:41:28,529 --> 00:41:35,670
customized something really good so the

00:41:32,609 --> 00:41:37,829
idea is to make it a backward compatible

00:41:35,670 --> 00:41:39,690
and extendable at the same time it

00:41:37,829 --> 00:41:41,579
should not be like a from a hardware

00:41:39,690 --> 00:41:43,589
interface where we dump everything it

00:41:41,579 --> 00:41:44,579
should not be an like completely if I

00:41:43,589 --> 00:41:46,740
implement its own it should be

00:41:44,579 --> 00:41:49,079
minimalistic like minimum required

00:41:46,740 --> 00:41:51,930
function that are required that are

00:41:49,079 --> 00:41:55,619
needed for the supervisor mode to boot

00:41:51,930 --> 00:41:57,869
but we the primary objective right now

00:41:55,619 --> 00:42:01,170
is to get the worsening and featuring

00:41:57,869 --> 00:42:02,940
correct and that's what basically we are

00:42:01,170 --> 00:42:04,710
planning to discuss you're saying what's

00:42:02,940 --> 00:42:06,960
the best way to do it there are

00:42:04,710 --> 00:42:09,269
discussions happening on this list if

00:42:06,960 --> 00:42:10,920
you want some Sunday afternoon popcorn

00:42:09,269 --> 00:42:13,500
there's pretty good discussions

00:42:10,920 --> 00:42:15,839
happening there so just go and take a

00:42:13,500 --> 00:42:19,759
look if you want to I don't know like

00:42:15,839 --> 00:42:19,759
don't have anything else to do on

00:42:21,930 --> 00:42:29,830
yes yes so if you want to come so the

00:42:28,090 --> 00:42:31,510
proposal the updated proposal is v2

00:42:29,830 --> 00:42:33,520
there is a github link if you want to

00:42:31,510 --> 00:42:34,540
give any video please provide the

00:42:33,520 --> 00:42:35,980
feedback in getup

00:42:34,540 --> 00:42:39,700
this is just for Sunday afternoon

00:42:35,980 --> 00:42:40,450
popcorn so at least one good thing is

00:42:39,700 --> 00:42:43,600
that source

00:42:40,450 --> 00:42:45,820
how important is SBI and all spectrum of

00:42:43,600 --> 00:42:50,320
people want it even somebody wants to

00:42:45,820 --> 00:42:52,360
rename it as FBI so I didn't I didn't

00:42:50,320 --> 00:42:54,550
want to answer anything saying what's

00:42:52,360 --> 00:43:01,750
the problem with renaming from SBI to

00:42:54,550 --> 00:43:04,900
FBI anyways so this is proposal that we

00:43:01,750 --> 00:43:08,440
are we have as of now so the biggest

00:43:04,900 --> 00:43:14,260
part to get the base SBI what Obama said

00:43:08,440 --> 00:43:17,410
is to have the correct column so one way

00:43:14,260 --> 00:43:21,040
of doing it is to do a static binding

00:43:17,410 --> 00:43:23,080
where we'll have 8 bits that gives you

00:43:21,040 --> 00:43:24,460
the what type of function it is whether

00:43:23,080 --> 00:43:26,620
it's a base function whether it's a

00:43:24,460 --> 00:43:30,490
power management whether it's a system

00:43:26,620 --> 00:43:33,850
power management our friend our API so

00:43:30,490 --> 00:43:35,440
and the next 24 bits will be the

00:43:33,850 --> 00:43:40,660
function number within that function

00:43:35,440 --> 00:43:43,330
type so that is one static binding where

00:43:40,660 --> 00:43:46,090
we all define in the spec supervisor

00:43:43,330 --> 00:43:49,150
knows what it is SBI implement that it

00:43:46,090 --> 00:43:52,870
simple enough and we just query for the

00:43:49,150 --> 00:43:55,510
worsen and the feature the other comment

00:43:52,870 --> 00:43:59,140
that we received on the proposal to have

00:43:55,510 --> 00:44:02,440
a dynamic binding where DT will

00:43:59,140 --> 00:44:04,330
basically mention everything sorry DT

00:44:02,440 --> 00:44:08,110
will have those function numbers and

00:44:04,330 --> 00:44:11,400
then both side of supervisor and the SP

00:44:08,110 --> 00:44:13,660
implementation will vary from the DT and

00:44:11,400 --> 00:44:17,130
negotiate saying what function is there

00:44:13,660 --> 00:44:19,810
or not I am not in favor of it and given

00:44:17,130 --> 00:44:23,910
what we discussed earlier nobody wants

00:44:19,810 --> 00:44:23,910
to specify DT in the SBI

00:44:27,820 --> 00:44:36,740
so so early on with some of the DT

00:44:34,190 --> 00:44:38,690
bindings for arm for things like PS CI

00:44:36,740 --> 00:44:41,570
we had to specify things in the DT and

00:44:38,690 --> 00:44:44,120
that became a mess real quickly so these

00:44:41,570 --> 00:44:46,190
days of SMC CC which is the supervisor

00:44:44,120 --> 00:44:49,630
mode calling Convention which is what

00:44:46,190 --> 00:44:51,830
our PRC IR power state thing is based on

00:44:49,630 --> 00:44:53,840
everything is meant to be probable from

00:44:51,830 --> 00:44:55,880
the firmware so you do a call up to the

00:44:53,840 --> 00:45:00,020
film and you can find the implementation

00:44:55,880 --> 00:45:02,210
gooood a version from that based on that

00:45:00,020 --> 00:45:04,520
you know that you have a minimal set of

00:45:02,210 --> 00:45:06,440
functions present and you can call those

00:45:04,520 --> 00:45:08,240
to query whether other functions are

00:45:06,440 --> 00:45:10,850
present what features they support and

00:45:08,240 --> 00:45:13,370
so on so forth and that makes things

00:45:10,850 --> 00:45:15,800
much simpler from the US side because

00:45:13,370 --> 00:45:17,390
regardless of what firmware description

00:45:15,800 --> 00:45:19,400
you have we'd be that DTAC Kai or

00:45:17,390 --> 00:45:22,400
something else that works and if the

00:45:19,400 --> 00:45:24,980
firmware is updated independently of

00:45:22,400 --> 00:45:27,590
that description you can still probe new

00:45:24,980 --> 00:45:29,360
features and things like that so I'd

00:45:27,590 --> 00:45:30,860
strongly recommend having a dynamic

00:45:29,360 --> 00:45:32,990
scheme where you can probe from the

00:45:30,860 --> 00:45:36,080
firmware what features are present what

00:45:32,990 --> 00:45:37,580
what is supported after however you've

00:45:36,080 --> 00:45:40,370
initially discovered that you have that

00:45:37,580 --> 00:45:44,240
initial baseline yeah I think we really

00:45:40,370 --> 00:45:46,130
want that I I am I've been pushing for

00:45:44,240 --> 00:45:47,690
that I also probably didn't push back

00:45:46,130 --> 00:45:49,760
quite hard enough for like hey we can

00:45:47,690 --> 00:45:51,590
also have it in DT if needed but I think

00:45:49,760 --> 00:45:53,270
self discovering we can just probe what

00:45:51,590 --> 00:45:57,520
you have that's what we should aim for

00:45:53,270 --> 00:45:57,520
in the whole platform in in all levels

00:45:57,790 --> 00:46:04,250
if if only all the firmware interfaces

00:46:01,160 --> 00:46:08,030
did that well we have a chance to do

00:46:04,250 --> 00:46:09,590
right here I know firmware bindings yeah

00:46:08,030 --> 00:46:11,000
and actually think about this very

00:46:09,590 --> 00:46:12,920
recently there were lots of firmware

00:46:11,000 --> 00:46:16,160
interfaces that we had to add in a hurry

00:46:12,920 --> 00:46:17,860
for interesting reasons and having that

00:46:16,160 --> 00:46:20,750
functionality made it possible for us to

00:46:17,860 --> 00:46:21,740
do this and make use of those interfaces

00:46:20,750 --> 00:46:24,010
we would not have been able to do that

00:46:21,740 --> 00:46:26,270
if we had to update every single

00:46:24,010 --> 00:46:28,310
firmware binding yeah I think the only

00:46:26,270 --> 00:46:30,260
thing like if you want to have a cached

00:46:28,310 --> 00:46:31,430
set of the known functions you have zero

00:46:30,260 --> 00:46:33,200
and have to probe them but if you

00:46:31,430 --> 00:46:34,580
actually look at it the time it takes to

00:46:33,200 --> 00:46:37,400
do a call and see if you have the

00:46:34,580 --> 00:46:40,069
function it's very clean in our thing a

00:46:37,400 --> 00:46:42,619
string problem I mean on 64 Linux

00:46:40,069 --> 00:46:44,630
buuut time we make a load of calls the

00:46:42,619 --> 00:46:46,880
film where we read and cache every

00:46:44,630 --> 00:46:48,170
single ID register because those trapped

00:46:46,880 --> 00:46:50,959
might trap inside Verizon other things

00:46:48,170 --> 00:46:56,749
and it has never been a problem for

00:46:50,959 --> 00:46:59,029
performance yeah so when you say dynamic

00:46:56,749 --> 00:47:00,890
probing via firmware it doesn't have to

00:46:59,029 --> 00:47:02,900
go through the DT so the probing

00:47:00,890 --> 00:47:06,229
directly calls and then figure out what

00:47:02,900 --> 00:47:07,819
function that there so presently for a

00:47:06,229 --> 00:47:11,509
number of interesting reasons the way we

00:47:07,819 --> 00:47:13,489
discover what we have is we read

00:47:11,509 --> 00:47:16,309
something from the DTR a CPI that tells

00:47:13,489 --> 00:47:18,170
us if we have PSC I from PSC I we can do

00:47:16,309 --> 00:47:19,699
a PSC I version call to determine if we

00:47:18,170 --> 00:47:22,130
have a feature that allows us to detect

00:47:19,699 --> 00:47:23,479
if we have s/m CCC from SM CCC we can

00:47:22,130 --> 00:47:25,729
then go in front of what a version of SM

00:47:23,479 --> 00:47:28,009
CCC and what features SM CCC provides

00:47:25,729 --> 00:47:31,069
you can vastly simplify that to just

00:47:28,009 --> 00:47:32,869
have do I have this baseline spi from

00:47:31,069 --> 00:47:46,519
the base of an SPI probe which features

00:47:32,869 --> 00:47:50,420
I have yes so okay thanks

00:47:46,519 --> 00:47:52,400
the other part is return values so as of

00:47:50,420 --> 00:47:56,329
now it some of the functions return I

00:47:52,400 --> 00:47:59,420
think console care returns some even 64

00:47:56,329 --> 00:48:02,299
but then other Samar coil then we

00:47:59,420 --> 00:48:03,799
probably if SBI is not implemented like

00:48:02,299 --> 00:48:08,749
a particular function is not implemented

00:48:03,799 --> 00:48:10,579
it turns -38 so which translate to good

00:48:08,749 --> 00:48:12,289
into the Linux land but it's different

00:48:10,579 --> 00:48:14,869
it might be different in the different

00:48:12,289 --> 00:48:19,160
platforms so wanted to standardize the

00:48:14,869 --> 00:48:23,449
error codes so one is just to say that

00:48:19,160 --> 00:48:25,719
return a single event 32 with greater

00:48:23,449 --> 00:48:35,869
than value greater than zero is less

00:48:25,719 --> 00:48:37,849
than 0 is error simple enough both a

00:48:35,869 --> 00:48:40,219
zero and a one can be used as a return

00:48:37,849 --> 00:48:42,259
value so we can do that somebody also

00:48:40,219 --> 00:48:45,769
suggested to have something like error

00:48:42,259 --> 00:48:47,390
strings so we get an error and call and

00:48:45,769 --> 00:48:48,619
I really won't error codes in no error

00:48:47,390 --> 00:48:50,959
strings okay

00:48:48,619 --> 00:48:53,240
some people argue very hard for that

00:48:50,959 --> 00:48:54,950
away I think maybe if

00:48:53,240 --> 00:48:56,599
if we want another layer of it that you

00:48:54,950 --> 00:48:57,890
can look up an error code to a string or

00:48:56,599 --> 00:49:01,309
something like that that could be a good

00:48:57,890 --> 00:49:03,170
extension but yes with SMCC see we have

00:49:01,309 --> 00:49:05,420
error code when we map into a string

00:49:03,170 --> 00:49:07,550
within Linux if if we really need to if

00:49:05,420 --> 00:49:09,079
people really want a magic error string

00:49:07,550 --> 00:49:11,270
that says specifically what's wrong

00:49:09,079 --> 00:49:13,309
it becomes a nightmare real quickly

00:49:11,270 --> 00:49:15,859
because then people try and use that as

00:49:13,309 --> 00:49:18,650
API to say oh the firmware returned this

00:49:15,859 --> 00:49:21,710
specific string will do this magic thing

00:49:18,650 --> 00:49:23,630
and it's not just human readable it

00:49:21,710 --> 00:49:27,349
might might make more sense to allow for

00:49:23,630 --> 00:49:29,450
some sort of console log of you know

00:49:27,349 --> 00:49:30,890
generic but yeah people can do the same

00:49:29,450 --> 00:49:32,030
thing there unfortunately you don't want

00:49:30,890 --> 00:49:34,130
it to be used as the programmatic

00:49:32,030 --> 00:49:38,690
interface between the firmware and the

00:49:34,130 --> 00:49:41,170
OS it's a big thing okay so singular ton

00:49:38,690 --> 00:49:44,450
value or a returning a struct does it

00:49:41,170 --> 00:49:45,829
complicate anything because we can just

00:49:44,450 --> 00:49:49,220
assign those two value in the register

00:49:45,829 --> 00:49:50,450
and then get it having having a richer

00:49:49,220 --> 00:49:53,210
environment where you can return two

00:49:50,450 --> 00:49:56,420
values I think I think it's an

00:49:53,210 --> 00:49:59,480
interesting idea to consider that way

00:49:56,420 --> 00:50:02,059
you can have more first of all you

00:49:59,480 --> 00:50:05,599
release all 32 bits for success returns

00:50:02,059 --> 00:50:07,250
or minus one I guess and you can have

00:50:05,599 --> 00:50:08,780
one that indicates error and then the

00:50:07,250 --> 00:50:11,930
rest you can have more detail in there

00:50:08,780 --> 00:50:14,089
if you need to or I want to so the next

00:50:11,930 --> 00:50:16,160
question would be then if we a return a

00:50:14,089 --> 00:50:17,750
structure do we change all the legacy

00:50:16,160 --> 00:50:19,880
functions or we leave legacy and then

00:50:17,750 --> 00:50:21,950
create another version of all everything

00:50:19,880 --> 00:50:23,960
with this return value legacy means

00:50:21,950 --> 00:50:28,329
legacy for reason we cannot do like

00:50:23,960 --> 00:50:28,329
legacy v2 that that's not like I say I

00:50:31,059 --> 00:50:48,880
like legacy v2 heading for the future

00:50:36,819 --> 00:50:51,549
legacy one thing we do okay that's

00:50:48,880 --> 00:50:55,190
calling convention next is basically

00:50:51,549 --> 00:50:57,950
scope so as mentioned we'll have a base

00:50:55,190 --> 00:51:00,559
pack which will have legacy and only

00:50:57,950 --> 00:51:02,990
these functions which will give you the

00:51:00,559 --> 00:51:05,839
version and what kind of feature is

00:51:02,990 --> 00:51:06,750
implemented that this what mandatory so

00:51:05,839 --> 00:51:09,940
the legacy

00:51:06,750 --> 00:51:11,950
to only will be mandatory anything else

00:51:09,940 --> 00:51:14,470
we'll all of the will be optional it's

00:51:11,950 --> 00:51:17,230
up to the the reference implementation

00:51:14,470 --> 00:51:20,170
can we'll have it but it's up to the

00:51:17,230 --> 00:51:22,180
vendor or the whoever is producing it

00:51:20,170 --> 00:51:24,580
will make it yeah I would not make the

00:51:22,180 --> 00:51:30,400
legacy things man your mandatory so

00:51:24,580 --> 00:51:35,640
you're gonna keep sir so we'll remove

00:51:30,400 --> 00:51:40,180
the legacy also will not make a mess

00:51:35,640 --> 00:51:42,010
okay so that will get it from the worsen

00:51:40,180 --> 00:52:02,170
so only two we can have and it will get

00:51:42,010 --> 00:52:03,970
worsen and APA yeah so so instead I'm

00:52:02,170 --> 00:52:05,800
guys so is there any reason PS I had so

00:52:03,970 --> 00:52:13,050
many mandatory calls I think you're hard

00:52:05,800 --> 00:52:16,180
power and on off arm and legacy legacy

00:52:13,050 --> 00:52:17,890
yeah legacy and we were optimistic about

00:52:16,180 --> 00:52:22,030
what we could convince people to

00:52:17,890 --> 00:52:27,580
implement really that you absolutely

00:52:22,030 --> 00:52:32,710
need you get feature style API where you

00:52:27,580 --> 00:52:34,240
can say for this call what like what

00:52:32,710 --> 00:52:38,260
optional extensions are supported on

00:52:34,240 --> 00:52:41,760
that you definitely want up down and get

00:52:38,260 --> 00:52:43,980
state for the hot PM api's if you're

00:52:41,760 --> 00:52:46,780
doing that kind of management for SBI

00:52:43,980 --> 00:52:49,060
you need to get state one to actually be

00:52:46,780 --> 00:52:51,790
able to detect when a CPU is off or has

00:52:49,060 --> 00:52:56,260
got into SBI for races on K exact and

00:52:51,790 --> 00:52:58,720
some other things system shutdown system

00:52:56,260 --> 00:53:01,120
spends all that we really wanted a

00:52:58,720 --> 00:53:04,030
standard interface for that and given

00:53:01,120 --> 00:53:07,050
that the way people were building those

00:53:04,030 --> 00:53:09,580
interfaces for the CPU power management

00:53:07,050 --> 00:53:11,710
required a certain amount in firmware it

00:53:09,580 --> 00:53:13,990
was not we didn't expect that to be a

00:53:11,710 --> 00:53:15,430
significant burden to implement in

00:53:13,990 --> 00:53:17,110
firmware as well and in many cases it

00:53:15,430 --> 00:53:19,660
wasn't the big problem was that people

00:53:17,110 --> 00:53:20,140
had designed their hardware such that

00:53:19,660 --> 00:53:24,850
the block

00:53:20,140 --> 00:53:26,950
you had to poke to reset the system was

00:53:24,850 --> 00:53:28,540
also also had to be poked by the OS in

00:53:26,950 --> 00:53:30,160
certain cases and then there was a hole

00:53:28,540 --> 00:53:31,450
it was just a horrible race where if

00:53:30,160 --> 00:53:34,840
firm where and the OS were poking it

00:53:31,450 --> 00:53:38,680
simultaneously then it made it difficult

00:53:34,840 --> 00:53:40,660
to implement in firmware but if you can

00:53:38,680 --> 00:53:43,630
convince people to design the hardware

00:53:40,660 --> 00:53:48,130
for the API that's not a problem

00:53:43,630 --> 00:53:49,240
so it's I have bad news nobody will

00:53:48,130 --> 00:53:50,350
really want to do that right and the

00:53:49,240 --> 00:53:52,570
other thing enough regulators on I

00:53:50,350 --> 00:53:54,250
Square C and stuff like this and that's

00:53:52,570 --> 00:53:55,930
when it gets really super messy when you

00:53:54,250 --> 00:53:58,330
have shared ownership of external

00:53:55,930 --> 00:54:00,430
peripherals and doesn't grab the

00:53:58,330 --> 00:54:06,070
microphone the whole system pmap isar

00:54:00,430 --> 00:54:17,350
it's a can of worms and yeah it kind of

00:54:06,070 --> 00:54:19,750
works the other part was how do we

00:54:17,350 --> 00:54:22,840
return the feature like is it fine

00:54:19,750 --> 00:54:24,910
because I think you also mentioned so we

00:54:22,840 --> 00:54:26,680
can have like just say whether this

00:54:24,910 --> 00:54:28,300
feature is enabled not enabled anyways

00:54:26,680 --> 00:54:31,840
all these are will be queried during

00:54:28,300 --> 00:54:33,370
boot time so it's not a big it's not in

00:54:31,840 --> 00:54:35,680
the fast powerful fast path or in the

00:54:33,370 --> 00:54:40,570
performance path so or come up with a

00:54:35,680 --> 00:54:42,880
complicated scheme where so my personal

00:54:40,570 --> 00:54:46,030
opinion on this based on experience were

00:54:42,880 --> 00:54:47,710
some CCC and PRC I is it having it per

00:54:46,030 --> 00:54:51,100
function is absolutely fine

00:54:47,710 --> 00:54:52,720
having a batch call makes things more

00:54:51,100 --> 00:54:55,120
complicated when things change in future

00:54:52,720 --> 00:54:57,700
and it and then that becomes the new

00:54:55,120 --> 00:55:00,580
legacy you have to support for what is

00:54:57,700 --> 00:55:06,730
realistically a minimal gain in

00:55:00,580 --> 00:55:08,920
performance in the boot path yeah and

00:55:06,730 --> 00:55:10,840
specifically I think the ABI you want is

00:55:08,920 --> 00:55:12,280
what we have with PR CI features or SMCC

00:55:10,840 --> 00:55:14,590
features where you call the firmware

00:55:12,280 --> 00:55:16,330
with a particular call ID with features

00:55:14,590 --> 00:55:18,220
called the call ID and it returns a bit

00:55:16,330 --> 00:55:21,070
mask of the supported features for that

00:55:18,220 --> 00:55:24,280
call or magic error code so it's not

00:55:21,070 --> 00:55:27,010
implemented yeah but so you think having

00:55:24,280 --> 00:55:28,810
a bit mask is good or bad bad so for

00:55:27,010 --> 00:55:31,870
each particular function you would do

00:55:28,810 --> 00:55:33,610
the call and and like the features call

00:55:31,870 --> 00:55:34,060
and you'd give it the idea of the

00:55:33,610 --> 00:55:36,100
feature you want

00:55:34,060 --> 00:55:38,950
to know about and the firm we would

00:55:36,100 --> 00:55:55,740
return a mask of feature supported for

00:55:38,950 --> 00:55:57,730
that call yep yeah so were the worst

00:55:55,740 --> 00:56:00,820
yeah so that was one of the reasons we

00:55:57,730 --> 00:56:06,880
had this because having to call PRC I

00:56:00,820 --> 00:56:08,890
CPU yeah yeah because we had horrible

00:56:06,880 --> 00:56:10,420
things like calling PRC ICP off to

00:56:08,890 --> 00:56:13,050
determine if you could turn the CPU off

00:56:10,420 --> 00:56:15,880
and by the time you know it's too late

00:56:13,050 --> 00:56:18,070
and and upper-bound a number of things

00:56:15,880 --> 00:56:19,720
you need to pro for i mean it's not

00:56:18,070 --> 00:56:21,640
gonna be in the hundreds it's gonna be

00:56:19,720 --> 00:56:23,260
in the dozens probably and yeah it's not

00:56:21,640 --> 00:56:24,070
kind of significantly at boot time it's

00:56:23,260 --> 00:56:28,750
gonna be in the thousands of

00:56:24,070 --> 00:56:31,480
instructions to do this okay another

00:56:28,750 --> 00:56:35,200
thing is do we care should we like as

00:56:31,480 --> 00:56:37,750
PACA spec says we have every return or

00:56:35,200 --> 00:56:41,440
some of their ten valuers UN 32 for a

00:56:37,750 --> 00:56:44,170
70/30 - even 64 for sm64 should we take

00:56:41,440 --> 00:56:45,550
that out like are we 30 to 32 or just

00:56:44,170 --> 00:56:47,920
return 32 for everything

00:56:45,550 --> 00:56:52,720
Audrey you would design an API that

00:56:47,920 --> 00:56:55,060
works for both in one go I mean we were

00:56:52,720 --> 00:56:58,750
in the unfortunate situation where we we

00:56:55,060 --> 00:57:03,940
had the SMC CC on a 32-bit core long

00:56:58,750 --> 00:57:06,250
before we had 64-bit architecture so we

00:57:03,940 --> 00:57:09,250
took that as a legacy you don't have

00:57:06,250 --> 00:57:13,510
that legacy you can design today an API

00:57:09,250 --> 00:57:18,640
that is that works for both 32 and 64 do

00:57:13,510 --> 00:57:20,590
that okay and that maybe I which works

00:57:18,640 --> 00:57:23,440
for both might just be the return values

00:57:20,590 --> 00:57:24,940
are in the native word size however you

00:57:23,440 --> 00:57:27,820
call it well there might be situations

00:57:24,940 --> 00:57:29,950
where people will want to run a 32-bit

00:57:27,820 --> 00:57:32,950
kernel on C's for a bit hardware so yeah

00:57:29,950 --> 00:57:35,760
there might be 64-bit and so you'll have

00:57:32,950 --> 00:57:35,760
you have fun things

00:57:39,700 --> 00:57:45,140
so if you have separate 64-bit and

00:57:42,320 --> 00:57:47,090
32-bit modes then ya falls out and watch

00:57:45,140 --> 00:57:48,860
the big deals if you have to call with

00:57:47,090 --> 00:57:51,560
the different caller size you have all

00:57:48,860 --> 00:57:55,600
sorts of fun around sign extension or

00:57:51,560 --> 00:57:55,600
zero extension of registers and things

00:57:56,650 --> 00:58:02,690
but can we have hypervisors running 64

00:57:59,930 --> 00:58:04,940
on bare metal running you could but then

00:58:02,690 --> 00:58:07,280
the hypervisor would know what the is a

00:58:04,940 --> 00:58:13,330
of the guest is and so we just provide

00:58:07,280 --> 00:58:13,330
the corresponding SBI to it okay right

00:58:16,150 --> 00:58:25,520
where do we stop it like how much do we

00:58:18,590 --> 00:58:27,920
support in spi should be there I mean

00:58:25,520 --> 00:58:30,260
it's optional I'm just saying how much

00:58:27,920 --> 00:58:32,780
should sba include RS be a spec you

00:58:30,260 --> 00:58:36,070
include going forward once we finalize

00:58:32,780 --> 00:58:39,230
this once we finalize the base versus

00:58:36,070 --> 00:58:41,900
there is vendor thing all the vendor

00:58:39,230 --> 00:58:45,020
extensions can go into a section with

00:58:41,900 --> 00:58:48,500
their specific API idea function ID

00:58:45,020 --> 00:58:50,240
whatever which still I check API or we

00:58:48,500 --> 00:58:52,850
can have something like vendor check API

00:58:50,240 --> 00:58:54,710
I check it that you have a separate ID

00:58:52,850 --> 00:58:57,890
space for the vendor api's and the

00:58:54,710 --> 00:58:59,600
architected API so I take it you've

00:58:57,890 --> 00:59:03,170
called the function ID space you have a

00:58:59,600 --> 00:59:05,030
separate yes so that's why we suspect

00:59:03,170 --> 00:59:07,570
out saying vendor will resolve that

00:59:05,030 --> 00:59:10,310
range and vendor will call the

00:59:07,570 --> 00:59:12,170
discussion that was happening so the one

00:59:10,310 --> 00:59:14,510
thing that you will need for that is get

00:59:12,170 --> 00:59:16,700
vendor ok implement or some things you

00:59:14,510 --> 00:59:19,280
know so you can do some big you a

00:59:16,700 --> 00:59:20,870
different vendor api's yeah yeah so I

00:59:19,280 --> 00:59:22,850
was I was thinking that should be part

00:59:20,870 --> 00:59:24,950
of the base because the vendors are

00:59:22,850 --> 00:59:28,130
gonna screw stuff up yep so I want to

00:59:24,950 --> 00:59:30,440
make sure that yes I get a good the

00:59:28,130 --> 00:59:32,720
implementation yeah yeah yeah we have a

00:59:30,440 --> 00:59:35,360
scheme in risk 5 land for doing vendor

00:59:32,720 --> 00:59:37,940
and implementation IDs so we'll just use

00:59:35,360 --> 00:59:39,500
a similar scheme yep there are two

00:59:37,940 --> 00:59:41,450
things that you'll one there there's the

00:59:39,500 --> 00:59:43,820
vendor and there's the particular

00:59:41,450 --> 00:59:45,080
implementation that yeah yeah so there's

00:59:43,820 --> 00:59:47,840
the vendor ID and everything so the

00:59:45,080 --> 00:59:49,310
vendor ID is you know it's managed like

00:59:47,840 --> 00:59:50,810
jtech or whatever right handed out and

00:59:49,310 --> 00:59:51,290
then the implementation idea has to be

00:59:50,810 --> 00:59:53,330
different

00:59:51,290 --> 00:59:55,070
every chip basically every

00:59:53,330 --> 00:59:57,320
implementation I don't think out super

00:59:55,070 --> 00:59:59,450
strictly defines but the idea is that

00:59:57,320 --> 01:00:00,440
yeah you've got chips they're all

00:59:59,450 --> 01:00:01,640
different they'll screw different stuff

01:00:00,440 --> 01:00:03,500
up and you want to at least be able to

01:00:01,640 --> 01:00:05,990
work around it if they'll if the whole

01:00:03,500 --> 01:00:10,310
the interface is what what actual chip

01:00:05,990 --> 01:00:14,300
my running on sounds good and going

01:00:10,310 --> 01:00:17,090
forward do we support those crazy SBI

01:00:14,300 --> 01:00:20,440
support like not crazy but something

01:00:17,090 --> 01:00:24,080
like cash or PNP or anything

01:00:20,440 --> 01:00:26,450
cross the bridge when it comes yeah and

01:00:24,080 --> 01:00:28,400
my big list of things was to have all of

01:00:26,450 --> 01:00:30,620
those as an individual working group

01:00:28,400 --> 01:00:33,290
that does one thing if that makes them

01:00:30,620 --> 01:00:34,670
no my question was whether they should

01:00:33,290 --> 01:00:37,190
support it or it should be supported

01:00:34,670 --> 01:00:39,650
somehow either put it in the privileged

01:00:37,190 --> 01:00:41,390
spec so I think that is a question

01:00:39,650 --> 01:00:42,830
that's answered by the working group if

01:00:41,390 --> 01:00:44,240
that makes sense right because it's

01:00:42,830 --> 01:00:46,790
gonna depend on exactly what the thing

01:00:44,240 --> 01:00:49,250
is and a lot of its gonna depend on you

01:00:46,790 --> 01:00:50,750
know for say cash management right do we

01:00:49,250 --> 01:00:53,360
end up with standard cash management

01:00:50,750 --> 01:00:55,070
instructions before we end up with lots

01:00:53,360 --> 01:01:00,710
of vendor specific implementations of it

01:00:55,070 --> 01:01:03,260
yes what I do - what I mean everything

01:01:00,710 --> 01:01:05,030
we like to have minimum functions here

01:01:03,260 --> 01:01:07,580
possible like if there is an alternate

01:01:05,030 --> 01:01:09,650
way to do it probably that would be the

01:01:07,580 --> 01:01:12,110
best way instead of putting it into

01:01:09,650 --> 01:01:15,800
everything in SBA I think if you end up

01:01:12,110 --> 01:01:19,270
we without the cash the standardized

01:01:15,800 --> 01:01:22,460
cash management cash management fund

01:01:19,270 --> 01:01:24,430
instructions first you'll end up with a

01:01:22,460 --> 01:01:26,480
lot of different vendor implementation

01:01:24,430 --> 01:01:28,640
it's gonna happen here is that people

01:01:26,480 --> 01:01:29,930
need to build things that do the stuff

01:01:28,640 --> 01:01:32,900
they need it to do so they're gonna

01:01:29,930 --> 01:01:34,400
build them right so the question is can

01:01:32,900 --> 01:01:35,660
we get the standard out this is you know

01:01:34,400 --> 01:01:36,890
specific to cash management we're

01:01:35,660 --> 01:01:38,720
talking about but it's true for kind of

01:01:36,890 --> 01:01:39,980
any of these extensions can we eat that

01:01:38,720 --> 01:01:41,750
stand it out before people build this

01:01:39,980 --> 01:01:43,100
stuff if we get the standard out before

01:01:41,750 --> 01:01:45,080
people build stuff and then there's no

01:01:43,100 --> 01:01:46,820
you know fundamental reason it's better

01:01:45,080 --> 01:01:48,050
to do it in a VM so it makes sense to do

01:01:46,820 --> 01:01:49,850
an SPI I call them there's no reason

01:01:48,050 --> 01:01:51,500
that an SPI call for cash management if

01:01:49,850 --> 01:01:53,360
people go build a bunch of incompatible

01:01:51,500 --> 01:01:55,850
cash management extensions then we did

01:01:53,360 --> 01:01:58,190
an SPI call and then we need a fast SBI

01:01:55,850 --> 01:02:00,800
call or there all sorts of stuff so it's

01:01:58,190 --> 01:02:02,180
it's it's better to get this back but we

01:02:00,800 --> 01:02:05,110
can't count on getting this back because

01:02:02,180 --> 01:02:05,110
people old stuff

01:02:17,810 --> 01:02:24,030
[Applause]

01:02:29,150 --> 01:02:37,769
so we can talk about this the risk five

01:02:34,650 --> 01:02:40,140
I say does not mention cash I think

01:02:37,769 --> 01:02:41,809
that's actually a feature of ISA so this

01:02:40,140 --> 01:02:49,619
is why it's not specked out is because

01:02:41,809 --> 01:02:51,779
we don't like so we have mechanisms for

01:02:49,619 --> 01:02:53,549
doing synchronization right or magnetic

01:02:51,779 --> 01:02:55,470
we have ordering mechanisms yeah but the

01:02:53,549 --> 01:02:58,859
ordering mechanism do not explicit cash

01:02:55,470 --> 01:03:00,839
management I think we can use that

01:02:58,859 --> 01:03:06,109
philosophy to do what people want to do

01:03:00,839 --> 01:03:06,109
from exposed to catch management but

01:03:08,830 --> 01:03:13,380
[Laughter]

01:03:21,900 --> 01:03:27,980
something's wrong with the predictor

01:03:23,580 --> 01:03:27,980
here is it my laptop

01:04:27,380 --> 01:04:41,540
I okay so I've been dealing with the HPC

01:04:38,900 --> 01:04:45,530
stuff and Linux for the last 15 years or

01:04:41,540 --> 01:04:46,940
so and I thought it may be good to give

01:04:45,530 --> 01:04:48,980
some tips at the beginning before you

01:04:46,940 --> 01:04:52,400
get all into all of this we can avoid

01:04:48,980 --> 01:04:54,440
some things where I see some major

01:04:52,400 --> 01:04:57,800
problems that we may go into given the

01:04:54,440 --> 01:05:02,000
current spec maybe it's too early to

01:04:57,800 --> 01:05:03,170
talk about this I met you and I just see

01:05:02,000 --> 01:05:04,850
that you're working on the basic spec

01:05:03,170 --> 01:05:07,100
first but maybe this is the right time

01:05:04,850 --> 01:05:09,290
to do that because maybe I can influence

01:05:07,100 --> 01:05:11,540
some aspects of this so that we don't do

01:05:09,290 --> 01:05:14,180
the same mistakes that I've seen done

01:05:11,540 --> 01:05:17,950
elsewhere my company it has an interest

01:05:14,180 --> 01:05:19,790
in that because we use risk five four

01:05:17,950 --> 01:05:22,340
four first eighty that we have

01:05:19,790 --> 01:05:24,080
manufactured for special for special

01:05:22,340 --> 01:05:28,910
give small that's various essential to

01:05:24,080 --> 01:05:32,330
or trading environments it's very basic

01:05:28,910 --> 01:05:33,830
at this point no real OS on this but it

01:05:32,330 --> 01:05:39,170
does the trick and you did your

01:05:33,830 --> 01:05:40,940
architecture yes so we hope that this is

01:05:39,170 --> 01:05:43,520
gonna be more mature as time progressed

01:05:40,940 --> 01:05:45,050
and or and girls stuff up and also we've

01:05:43,520 --> 01:05:46,850
looked at the vector specification for

01:05:45,050 --> 01:05:49,310
risk five and we think we can use that

01:05:46,850 --> 01:05:51,530
also for a very high performance

01:05:49,310 --> 01:05:53,690
floating-point operations and we're

01:05:51,530 --> 01:05:56,000
looking at possible way to develop an

01:05:53,690 --> 01:05:57,170
in-house risk 5 for that purpose these

01:05:56,000 --> 01:06:02,450
are all in-house versions that will

01:05:57,170 --> 01:06:06,740
never be publicly available sorry basic

01:06:02,450 --> 01:06:08,660
thing for our company but since so we

01:06:06,740 --> 01:06:10,790
have it at the very low end where where

01:06:08,660 --> 01:06:12,140
the network stuff is going on very high

01:06:10,790 --> 01:06:14,000
and where we've made use falling point

01:06:12,140 --> 01:06:16,310
stuff going on maybe we could show use

01:06:14,000 --> 01:06:18,410
this everywhere because right now I have

01:06:16,310 --> 01:06:20,750
a problem that we have a device

01:06:18,410 --> 01:06:23,600
architectures overall the company we

01:06:20,750 --> 01:06:26,630
have intelligent various grids we have

01:06:23,600 --> 01:06:29,420
GPUs floating around then there's some

01:06:26,630 --> 01:06:32,720
arm stuff coming with with the sidings

01:06:29,420 --> 01:06:34,760
and FPGAs and this is all where's the

01:06:32,720 --> 01:06:37,880
different go change different tools and

01:06:34,760 --> 01:06:39,620
stuff like that so maybe glorious view

01:06:37,880 --> 01:06:40,100
of the future would be that risk 5-4 to

01:06:39,620 --> 01:06:41,810
be

01:06:40,100 --> 01:06:43,490
we can use the same build giant room

01:06:41,810 --> 01:06:46,580
from the smallest embedded to the

01:06:43,490 --> 01:06:49,460
largest thing right and so maybe that's

01:06:46,580 --> 01:06:51,140
such a tough call right now but I think

01:06:49,460 --> 01:06:52,820
that may be something that could

01:06:51,140 --> 01:06:54,830
significantly simplify the maintenance

01:06:52,820 --> 01:06:56,810
of our infrastructure and can happen

01:06:54,830 --> 01:06:58,820
debugging ease of debugging and have

01:06:56,810 --> 01:07:02,150
McMichaels all much easier then to have

01:06:58,820 --> 01:07:03,860
this diverse mess of various will change

01:07:02,150 --> 01:07:05,600
at the base and the early stages have

01:07:03,860 --> 01:07:34,310
any various people the likes but he's on

01:07:05,600 --> 01:07:37,670
each platform so some of the issues here

01:07:34,310 --> 01:07:40,310
that I of the instructions as well as

01:07:37,670 --> 01:07:45,020
the supervisor mode and some of the key

01:07:40,310 --> 01:07:48,200
things that I found here that I would

01:07:45,020 --> 01:07:50,200
like to mention this view so the page

01:07:48,200 --> 01:07:52,700
size issues large memory management

01:07:50,200 --> 01:07:57,070
piece of you Atomics and then i/o

01:07:52,700 --> 01:08:00,500
performance so instruction set issues

01:07:57,070 --> 01:08:03,200
per semester team so on the inter

01:08:00,500 --> 01:08:04,730
platform you'll have the ability to have

01:08:03,200 --> 01:08:07,430
a single instruction that would

01:08:04,730 --> 01:08:12,380
increment a statistics variable relative

01:08:07,430 --> 01:08:14,300
to a base register and we use that for a

01:08:12,380 --> 01:08:16,870
very lightweight accounting as this is

01:08:14,300 --> 01:08:19,760
the basis of all the statistics in the

01:08:16,870 --> 01:08:22,850
and the VM and in the kernel we don't I

01:08:19,760 --> 01:08:26,690
don't see that at all on in the and the

01:08:22,850 --> 01:08:29,150
instruction set of risk 5 what I can do

01:08:26,690 --> 01:08:32,300
there is I can either use an atomic

01:08:29,150 --> 01:08:34,609
instruction or I can use a large store

01:08:32,300 --> 01:08:36,380
thing the problem it was load store is

01:08:34,609 --> 01:08:38,630
then I would have to interrupt so make

01:08:36,380 --> 01:08:40,250
sure that the context is not be switched

01:08:38,630 --> 01:08:42,770
to another processor while that's going

01:08:40,250 --> 01:08:45,220
on so what I really need is a single

01:08:42,770 --> 01:08:50,670
instruction that increments

01:08:45,220 --> 01:08:53,140
a register dependent offset of a

01:08:50,670 --> 01:08:54,630
variable and that is not atomic it

01:08:53,140 --> 01:08:57,460
should be very light with operation that

01:08:54,630 --> 01:08:59,380
it can rely on accessing memory that's

01:08:57,460 --> 01:09:00,460
only available for this processor not

01:08:59,380 --> 01:09:03,250
for other processor so that's going to

01:09:00,460 --> 01:09:06,610
be no contention that is the only way we

01:09:03,250 --> 01:09:08,680
could they were able to do very memory

01:09:06,610 --> 01:09:12,330
statistics for very large systems we had

01:09:08,680 --> 01:09:14,680
contention was these counters on large

01:09:12,330 --> 01:09:15,700
clusters that they couldn't solve until

01:09:14,680 --> 01:09:19,450
we get to the scheme we have a

01:09:15,700 --> 01:09:21,280
distributed point counting scheme for VM

01:09:19,450 --> 01:09:24,100
statistics that enable us to have full

01:09:21,280 --> 01:09:26,470
performance of a VM and that feature is

01:09:24,100 --> 01:09:28,720
not available on the hardware level of

01:09:26,470 --> 01:09:31,390
the instruction set maybe you think

01:09:28,720 --> 01:09:34,900
about how you can do this because this

01:09:31,390 --> 01:09:36,430
is key to ever scaling this at the mo

01:09:34,900 --> 01:09:38,590
instructions and I miss it and see the

01:09:36,430 --> 01:09:40,800
couple exchanged the couple changes used

01:09:38,590 --> 01:09:43,510
in various places of the kernel for

01:09:40,800 --> 01:09:46,660
various things so I wish that would be

01:09:43,510 --> 01:09:50,860
in there there's also a copy exchange

01:09:46,660 --> 01:09:53,560
local on x86 that is used to access per

01:09:50,860 --> 01:09:55,900
CPU data that's specific to only a

01:09:53,560 --> 01:09:57,910
certain processor and you make in manage

01:09:55,900 --> 01:10:00,460
with that for example is a specific

01:09:57,910 --> 01:10:03,160
queue in a way that's protected from

01:10:00,460 --> 01:10:05,410
interrupts and from swap allocator

01:10:03,160 --> 01:10:06,670
relies on this for scaling and if you

01:10:05,410 --> 01:10:08,170
don't wouldn't have the stuff allocator

01:10:06,670 --> 01:10:10,000
there but this technique then we would

01:10:08,170 --> 01:10:11,590
have to disturb interrupts and that

01:10:10,000 --> 01:10:13,990
causes issues for example members of

01:10:11,590 --> 01:10:15,820
your time and another thing so you

01:10:13,990 --> 01:10:17,650
really need to have something like comp

01:10:15,820 --> 01:10:19,660
exchange they're both in for atomic

01:10:17,650 --> 01:10:22,450
version as well as never static

01:10:19,660 --> 01:10:29,380
electricity and cannot rely on CPU local

01:10:22,450 --> 01:10:32,050
accesses and the page size this is a key

01:10:29,380 --> 01:10:33,280
issue of the entire platform constantly

01:10:32,050 --> 01:10:34,990
working around these days and spending

01:10:33,280 --> 01:10:38,080
every year more effort to deal with this

01:10:34,990 --> 01:10:39,760
stuff and I looked at the layout of the

01:10:38,080 --> 01:10:44,950
page tables and they're all based on 4k

01:10:39,760 --> 01:10:47,140
page sizes if you go ahead and save in

01:10:44,950 --> 01:10:48,610
five years right so that's when there's

01:10:47,140 --> 01:10:50,590
probably stuff is gonna be boomin image

01:10:48,610 --> 01:10:52,780
you hopefully and we all can enjoy risk

01:10:50,590 --> 01:10:55,120
5 everywhere but at that time you

01:10:52,780 --> 01:10:57,070
probably have a memory size of the

01:10:55,120 --> 01:10:57,789
servers in the tens of terabytes of

01:10:57,070 --> 01:11:00,699
memory

01:10:57,789 --> 01:11:03,250
this means if you have fortune a bit of

01:11:00,699 --> 01:11:05,260
memory you need one billion of these for

01:11:03,250 --> 01:11:07,119
cave pages to be managed by the

01:11:05,260 --> 01:11:08,469
operating system you don't add multiple

01:11:07,119 --> 01:11:10,000
billions of pages that you want to

01:11:08,469 --> 01:11:12,429
manage now and this is going to be a

01:11:10,000 --> 01:11:14,699
severe impact on the performance of your

01:11:12,429 --> 01:11:19,119
system you need to have an ability to

01:11:14,699 --> 01:11:21,460
support larger page sizes and I saw this

01:11:19,119 --> 01:11:23,469
if this SAT feed register there maybe

01:11:21,460 --> 01:11:26,710
you want to add something via text

01:11:23,469 --> 01:11:28,269
support 64 K and 256 K page size I think

01:11:26,710 --> 01:11:30,489
there are some bits available there yet

01:11:28,269 --> 01:11:32,110
and maybe come up with some kind of a

01:11:30,489 --> 01:11:36,309
more to the specification to allow that

01:11:32,110 --> 01:11:38,530
also the the issue is well-known on x86

01:11:36,309 --> 01:11:41,199
to such an extent that the binary format

01:11:38,530 --> 01:11:43,269
was reworked on x86 to have all segments

01:11:41,199 --> 01:11:45,820
aligned to a to make boundary so that we

01:11:43,269 --> 01:11:47,949
can theoretically able be able to use

01:11:45,820 --> 01:11:50,380
larger patches on xe6 if the interview

01:11:47,949 --> 01:11:52,929
will just fill then and do that then all

01:11:50,380 --> 01:11:54,909
the binaries will be able to run on with

01:11:52,929 --> 01:11:56,559
larger page sizes so I wish you would

01:11:54,909 --> 01:11:58,059
also consider that for your binary form

01:11:56,559 --> 01:11:59,469
to make sure that the alignment is in

01:11:58,059 --> 01:12:04,420
such a way that you can use larger page

01:11:59,469 --> 01:12:06,760
size in the future and the menu mentions

01:12:04,420 --> 01:12:07,059
that TLB reach is a problem yes that is

01:12:06,760 --> 01:12:08,949
true

01:12:07,059 --> 01:12:10,570
on the other hand it's also the overhead

01:12:08,949 --> 01:12:12,070
that the US has to put in there to

01:12:10,570 --> 01:12:13,690
manage all these billions of entries

01:12:12,070 --> 01:12:17,769
that you are shoveling around if you

01:12:13,690 --> 01:12:20,949
have larger memory sizes so that is a

01:12:17,769 --> 01:12:26,800
key issue so there needs to be some way

01:12:20,949 --> 01:12:28,420
to address that and then there the key

01:12:26,800 --> 01:12:30,250
performance issue on all HPC

01:12:28,420 --> 01:12:33,519
applications is the speed of your time

01:12:30,250 --> 01:12:35,320
of day numerous times benchmark that

01:12:33,519 --> 01:12:37,539
they get team-ups a function call is

01:12:35,320 --> 01:12:38,949
always the key thing because most of the

01:12:37,539 --> 01:12:40,480
applications run in a loop to figure out

01:12:38,949 --> 01:12:45,250
what to do next and they call get time

01:12:40,480 --> 01:12:46,929
of day so specific time registers so it

01:12:45,250 --> 01:12:49,659
could do the same as on x86 when you

01:12:46,929 --> 01:12:52,179
meet you make sure that this function

01:12:49,659 --> 01:12:54,909
call is not entering the kernel and it

01:12:52,179 --> 01:12:57,309
is not modifying any cache lines and it

01:12:54,909 --> 01:12:58,719
is just to be able to do a clean walk

01:12:57,309 --> 01:13:00,460
through and get the time there that is

01:12:58,719 --> 01:13:03,190
key to of the important key to the

01:13:00,460 --> 01:13:07,980
performance that you will have on HPC if

01:13:03,190 --> 01:13:07,980
you ever if you ever get there so

01:13:08,020 --> 01:13:12,450
that's what I want to say any questions

01:13:12,880 --> 01:13:19,510
[Laughter]

01:13:20,970 --> 01:13:24,160
yeah there we go

01:13:22,420 --> 01:13:25,270
so Christophe you mentioned HBC's using

01:13:24,160 --> 01:13:27,220
a camera date I mean that was also true

01:13:25,270 --> 01:13:28,720
for data processing transactions I mean

01:13:27,220 --> 01:13:29,050
I say the databases also use get time a

01:13:28,720 --> 01:13:30,670
date

01:13:29,050 --> 01:13:33,070
continuously so if you have anything

01:13:30,670 --> 01:13:35,590
that's distributed across all fours

01:13:33,070 --> 01:13:37,060
yeah that you have to get it from user

01:13:35,590 --> 01:13:39,040
space and a hat cannot conflict

01:13:37,060 --> 01:13:40,240
the only issue there that I ran into in

01:13:39,040 --> 01:13:42,250
the past is when you're using get time

01:13:40,240 --> 01:13:44,140
of day to measure things you have to be

01:13:42,250 --> 01:13:48,700
very careful about memory ordering and

01:13:44,140 --> 01:13:51,460
how that is the get time of day is not

01:13:48,700 --> 01:13:52,900
bound by memory ordering right so you

01:13:51,460 --> 01:13:54,340
can have timings that are just

01:13:52,900 --> 01:13:55,330
completely wrong because they're not

01:13:54,340 --> 01:13:56,980
measuring what you think they're

01:13:55,330 --> 01:14:00,220
measuring yes if you look at the I

01:13:56,980 --> 01:14:03,130
suspect there's a bug out now about how

01:14:00,220 --> 01:14:05,320
read time relates to memory ordering

01:14:03,130 --> 01:14:06,370
well you need to remember to put a fence

01:14:05,320 --> 01:14:08,470
in front of the to get time of data

01:14:06,370 --> 01:14:11,470
right now in the spec even with a fence

01:14:08,470 --> 01:14:13,450
there's no well this I mean it does work

01:14:11,470 --> 01:14:19,090
it's just that the spec doesn't say it

01:14:13,450 --> 01:14:22,030
works right so all I want to say is

01:14:19,090 --> 01:14:24,310
think about this now and can you talk

01:14:22,030 --> 01:14:25,570
one more moment about the TLB because we

01:14:24,310 --> 01:14:26,890
had this conversation before and I think

01:14:25,570 --> 01:14:28,570
there was an important part of that is

01:14:26,890 --> 01:14:31,570
that you talked about the overhead of

01:14:28,570 --> 01:14:33,130
processing and this was not for TLB

01:14:31,570 --> 01:14:34,420
shoot-down rather being expensive but

01:14:33,130 --> 01:14:35,710
rather it was rather the actual

01:14:34,420 --> 01:14:39,040
processing of pges

01:14:35,710 --> 01:14:42,730
right the page table entries yes if you

01:14:39,040 --> 01:14:46,090
have 4k page okay pages and the OS runs

01:14:42,730 --> 01:14:48,040
allow you to expire the least-used pages

01:14:46,090 --> 01:14:51,100
then you walk into a potentially

01:14:48,040 --> 01:14:52,540
billions of these 4k patient descriptors

01:14:51,100 --> 01:14:55,900
training out which one is the oldest to

01:14:52,540 --> 01:14:57,940
kick out yes we have bigger pages right

01:14:55,900 --> 01:15:00,310
so I think two meg is the smallest

01:14:57,940 --> 01:15:03,280
bigger page right on side four but

01:15:00,310 --> 01:15:04,960
that's too big no it's not supported its

01:15:03,280 --> 01:15:07,680
to Mexican page is the only supported

01:15:04,960 --> 01:15:10,300
for anonymous memory enough for the file

01:15:07,680 --> 01:15:13,030
has significant limitations usually

01:15:10,300 --> 01:15:14,590
pre-configure these huge pages on boot

01:15:13,030 --> 01:15:16,150
up and when a lot changes we you know

01:15:14,590 --> 01:15:17,530
have to reboot our systems we are

01:15:16,150 --> 01:15:19,030
creating special configurations gives to

01:15:17,530 --> 01:15:19,590
reconfigure the machines based on the

01:15:19,030 --> 01:15:21,750
run

01:15:19,590 --> 01:15:24,540
okay okay they're saying this is just

01:15:21,750 --> 01:15:26,670
generic clinics doesn't work the larger

01:15:24,540 --> 01:15:28,440
page sizes double the anime is huge

01:15:26,670 --> 01:15:30,090
problems that haven't been solved right

01:15:28,440 --> 01:15:35,130
yeah and they haven't been solved for

01:15:30,090 --> 01:15:37,889
more than a decade Christophe you that

01:15:35,130 --> 01:15:40,409
you have like several people maybe here

01:15:37,889 --> 01:15:41,460
some experience with titanium and can

01:15:40,409 --> 01:15:42,780
you have any opinion about the

01:15:41,460 --> 01:15:46,530
implementation there that maybe they

01:15:42,780 --> 01:15:48,840
want to look at I tell you - yes

01:15:46,530 --> 01:15:52,679
actually I Cheney has a 64 K page size

01:15:48,840 --> 01:15:55,530
so has arm by the way the Pope you see

01:15:52,679 --> 01:15:57,510
everybody has 16 okay page size the only

01:15:55,530 --> 01:15:59,010
one is Intel and Intel can't do it

01:15:57,510 --> 01:16:01,409
because of the others the structure of

01:15:59,010 --> 01:16:02,760
the silicon and we've been bugging them

01:16:01,409 --> 01:16:04,290
for you for more than a decade in order

01:16:02,760 --> 01:16:07,349
to change that and it has never happened

01:16:04,290 --> 01:16:08,790
and the huge page issues increasing

01:16:07,349 --> 01:16:11,869
increase yes now people are using which

01:16:08,790 --> 01:16:14,670
pages for the instruction segments of

01:16:11,869 --> 01:16:18,000
code to run the code faster so they have

01:16:14,670 --> 01:16:20,909
some manual code on start of the app it

01:16:18,000 --> 01:16:22,469
moves the stuff into a to make a second

01:16:20,909 --> 01:16:25,170
order to increase the destruction speed

01:16:22,469 --> 01:16:26,580
and these these things I just get way

01:16:25,170 --> 01:16:29,040
out of control at this point

01:16:26,580 --> 01:16:30,719
and so it's may be much easier and much

01:16:29,040 --> 01:16:33,449
simpler for everybody involved if we

01:16:30,719 --> 01:16:35,820
just had a lot of page size okay

01:16:33,449 --> 01:16:40,020
presumably you'd need a new kernel for

01:16:35,820 --> 01:16:42,030
that page size right it that depends

01:16:40,020 --> 01:16:44,310
there are kernels who can dynamically

01:16:42,030 --> 01:16:45,599
configure that and for attaining you

01:16:44,310 --> 01:16:47,880
could able you can compile the corn was

01:16:45,599 --> 01:16:52,250
various page sizes yes same things on

01:16:47,880 --> 01:16:55,199
PowerPC right the second page size

01:16:52,250 --> 01:16:58,290
sometimes family configurable on PowerPC

01:16:55,199 --> 01:16:59,790
and on a titanium for example yeah the

01:16:58,290 --> 01:17:02,219
face page size is definitely not

01:16:59,790 --> 01:17:03,719
dynamically configurable we always have

01:17:02,219 --> 01:17:06,840
to build different ones it has a

01:17:03,719 --> 01:17:10,409
horrendous number of impacts on ABI even

01:17:06,840 --> 01:17:13,080
for like boot flow stuff so if you were

01:17:10,409 --> 01:17:15,330
to add numerous page sizes you're gonna

01:17:13,080 --> 01:17:18,630
need to reconsider every stage of your

01:17:15,330 --> 01:17:20,880
boot flow every ABI things like efi

01:17:18,630 --> 01:17:23,400
mandates 4k pages yeah yeah so we

01:17:20,880 --> 01:17:25,320
actually did 2 Meg for all of that you

01:17:23,400 --> 01:17:27,210
know just because doesn't seem like it's

01:17:25,320 --> 01:17:30,119
that much overhead to 2 Meg alignment

01:17:27,210 --> 01:17:32,159
for boot stuff and that's our bigger

01:17:30,119 --> 01:17:32,940
page size we figured no one would care

01:17:32,159 --> 01:17:35,760
about 2

01:17:32,940 --> 01:17:37,920
gig pages and though yeah so on 64 we

01:17:35,760 --> 01:17:41,699
have 4k to make one gig if you're using

01:17:37,920 --> 01:17:45,420
4k is your base page size 64 K and 512

01:17:41,699 --> 01:17:47,160
Meg okay if you're using 64 K pages and

01:17:45,420 --> 01:17:49,770
then it becomes very difficult to use

01:17:47,160 --> 01:17:52,370
those 512 it becomes very difficult to

01:17:49,770 --> 01:17:54,570
use those 512 Meg huge pages yeah yeah

01:17:52,370 --> 01:17:56,520
unless you could actually have used the

01:17:54,570 --> 01:17:58,770
one gig huge page in using 4k was it

01:17:56,520 --> 01:18:00,870
easier for us in those cases yeah and

01:17:58,770 --> 01:18:03,719
this significantly affects the really

01:18:00,870 --> 01:18:06,690
common use case of smaller memory

01:18:03,719 --> 01:18:08,160
systems so it's whether or not you want

01:18:06,690 --> 01:18:11,150
to support a distinction between the

01:18:08,160 --> 01:18:14,880
huge systems and everything else

01:18:11,150 --> 01:18:16,880
well the issue is right now with the 64

01:18:14,880 --> 01:18:19,590
K paycheck is actually used for all

01:18:16,880 --> 01:18:21,630
64-bit systems right no no deaf

01:18:19,590 --> 01:18:24,360
configures 4k the vast majority of

01:18:21,630 --> 01:18:27,210
people using 4k RedHat use 64 K but nice

01:18:24,360 --> 01:18:29,370
about it my main experience was a red

01:18:27,210 --> 01:18:31,890
hat enterprise class this drawer that's

01:18:29,370 --> 01:18:33,090
a 64 K there are awful lot more Android

01:18:31,890 --> 01:18:46,620
phones out there than there are Red

01:18:33,090 --> 01:18:48,239
Hat's perspective yeah so I think 64

01:18:46,620 --> 01:18:50,880
keys at this point a good size and maybe

01:18:48,239 --> 01:18:52,560
in five yes 256 will so that's why I

01:18:50,880 --> 01:18:55,320
thought maybe these two things may be

01:18:52,560 --> 01:18:58,140
useful so from the pro stuff it sounds

01:18:55,320 --> 01:18:59,460
like the big issue here is that we've

01:18:58,140 --> 01:19:01,320
got a lot of stuff in the kernel that

01:18:59,460 --> 01:19:02,910
you say hasn't been sold over ten years

01:19:01,320 --> 01:19:05,280
and it sounds like we need to invest

01:19:02,910 --> 01:19:06,480
more effort in that trying to see if it

01:19:05,280 --> 01:19:09,560
can be solved with smaller page sizes

01:19:06,480 --> 01:19:09,560
regardless so yes

01:19:20,820 --> 01:19:25,470
I think this is good input it's also

01:19:23,940 --> 01:19:28,950
just sitting here reflecting a little

01:19:25,470 --> 01:19:31,680
bit this is I think a lot of risk fatty

01:19:28,950 --> 01:19:35,340
is has a mindset of we're approaching to

01:19:31,680 --> 01:19:37,440
a buzzword the post more law era right

01:19:35,340 --> 01:19:40,560
where generic compute to solve these

01:19:37,440 --> 01:19:42,920
problems are gonna be harder and harder

01:19:40,560 --> 01:19:45,330
and they focus more and more on

01:19:42,920 --> 01:19:47,310
extending the ISIS and optimizing the

01:19:45,330 --> 01:19:51,180
workload by customizing your hardware

01:19:47,310 --> 01:19:53,760
yeah well this is I read this much less

01:19:51,180 --> 01:19:57,540
input on if you wanted to build generic

01:19:53,760 --> 01:19:58,080
compute more law you know type systems

01:19:57,540 --> 01:19:59,070
with it

01:19:58,080 --> 01:20:01,050
these are things you need to think about

01:19:59,070 --> 01:20:03,660
and yeah I mean it's a good set of input

01:20:01,050 --> 01:20:05,760
for sure well the general compute is the

01:20:03,660 --> 01:20:06,810
basis for the accelerators but usually

01:20:05,760 --> 01:20:07,770
you have generic compute and then you

01:20:06,810 --> 01:20:12,780
have the side unit where you do

01:20:07,770 --> 01:20:14,430
specialize high speed yeah interact you

01:20:12,780 --> 01:20:16,140
can end up having a large system with

01:20:14,430 --> 01:20:18,180
accelerators but they're gonna have you

01:20:16,140 --> 01:20:20,700
know large memory they might not do as

01:20:18,180 --> 01:20:25,800
much compute on the CPUs but they still

01:20:20,700 --> 01:20:27,990
need to manage it if it you'll usually

01:20:25,800 --> 01:20:29,940
have a very large data set as well that

01:20:27,990 --> 01:20:31,980
need to operate on yeah exactly I can't

01:20:29,940 --> 01:20:33,270
get the floating point to the point in

01:20:31,980 --> 01:20:35,190
is fast enough because you have the 4k

01:20:33,270 --> 01:20:38,100
picture size there was a TV entries then

01:20:35,190 --> 01:20:39,600
that is an issue so of all the problems

01:20:38,100 --> 01:20:43,230
we've looked at here you have four

01:20:39,600 --> 01:20:46,740
classes how much you think can be simply

01:20:43,230 --> 01:20:51,380
solved by adding a new extension or

01:20:46,740 --> 01:20:51,380
several new extensions to the data

01:20:52,310 --> 01:21:00,420
clearly yes that one yes just new

01:20:55,170 --> 01:21:06,000
extension arm already did right LLC and

01:21:00,420 --> 01:21:07,920
all that yeah this one is a tough one I

01:21:06,000 --> 01:21:10,800
think it's Macy well it's mostly an

01:21:07,920 --> 01:21:15,720
engineer right right the correct code

01:21:10,800 --> 01:21:17,040
and keep in mind yes this is a software

01:21:15,720 --> 01:21:19,140
problem so we can fix this

01:21:17,040 --> 01:21:21,300
30p atomic saying Elysee doesn't solve

01:21:19,140 --> 01:21:24,780
it on on 64 but you can implement per

01:21:21,300 --> 01:21:28,460
CPU Atomics with LLS see if you have a

01:21:24,780 --> 01:21:28,460
general purpose register you can spare

01:21:28,750 --> 01:21:33,590
but not the per CPU thing but the per

01:21:31,580 --> 01:21:35,450
CPU thing you can solve with lol SC

01:21:33,590 --> 01:21:37,250
Atomics I've got patches around 64 that

01:21:35,450 --> 01:21:39,290
do that but we didn't merge them because

01:21:37,250 --> 01:21:40,940
of maintenance didn't like them it's

01:21:39,290 --> 01:21:42,440
possible to do it with the existing

01:21:40,940 --> 01:21:43,670
Atomics without having a single

01:21:42,440 --> 01:21:47,420
instruction a know that it takes the

01:21:43,670 --> 01:21:49,130
offset you just have to do a tiny bit

01:21:47,420 --> 01:21:50,630
more work within the critical section to

01:21:49,130 --> 01:21:52,760
check if you're being preempted since

01:21:50,630 --> 01:21:53,900
the load link okay but these

01:21:52,760 --> 01:21:55,310
instructions are very frequent

01:21:53,900 --> 01:21:57,050
interspersed throughout all the VM you

01:21:55,310 --> 01:21:59,660
don't want them to have large sizes

01:21:57,050 --> 01:22:02,270
they're simply instruction will be the

01:21:59,660 --> 01:22:07,010
best benchmark it benchmark it before

01:22:02,270 --> 01:22:10,610
you make any state exchange is going to

01:22:07,010 --> 01:22:13,010
have a huge upfront cost anyway yeah so

01:22:10,610 --> 01:22:15,080
I mean whether you have to really

01:22:13,010 --> 01:22:17,210
investigate whether for a given

01:22:15,080 --> 01:22:19,010
implementation it's actually beneficial

01:22:17,210 --> 01:22:21,560
to you have this complex change that

01:22:19,010 --> 01:22:23,360
will hide all the complexity beyond a

01:22:21,560 --> 01:22:25,430
single instruction yes it's a single

01:22:23,360 --> 01:22:27,290
instruction is it actually faster than

01:22:25,430 --> 01:22:29,210
you know the four instruction you would

01:22:27,290 --> 01:22:31,570
need which are the same cache line that

01:22:29,210 --> 01:22:35,540
are pre decoded by your by your

01:22:31,570 --> 01:22:37,070
prefetcher they on x86 is one or two

01:22:35,540 --> 01:22:40,150
instruction cycles Wow

01:22:37,070 --> 01:22:44,530
check it on the real implementation yes

01:22:40,150 --> 01:22:44,530
examination by now on x86 so that you

01:22:53,740 --> 01:22:59,649
[Applause]

01:23:00,050 --> 01:23:04,980
so my name is Paul Walmsley I've been

01:23:03,210 --> 01:23:06,480
working on power management related

01:23:04,980 --> 01:23:08,670
stuff both

01:23:06,480 --> 01:23:11,010
mostly at the software level but also at

01:23:08,670 --> 01:23:14,099
the hardware level for gosh I guess

01:23:11,010 --> 01:23:16,469
about eleven twelve thirteen years

01:23:14,099 --> 01:23:18,619
something like that I've lost track and

01:23:16,469 --> 01:23:23,250
what I'd like to talk about today is

01:23:18,619 --> 01:23:25,560
what if any portable power management

01:23:23,250 --> 01:23:28,440
interfaces we should have on risk five

01:23:25,560 --> 01:23:31,050
and this is mostly a software construct

01:23:28,440 --> 01:23:33,780
the goal is is for folks who want to run

01:23:31,050 --> 01:23:36,770
and want to create and run portable

01:23:33,780 --> 01:23:40,560
binaries like Linux distributions and

01:23:36,770 --> 01:23:42,119
folks like that that there is a coherent

01:23:40,560 --> 01:23:44,099
interface to do so

01:23:42,119 --> 01:23:46,590
where we can ideally it's one part of

01:23:44,099 --> 01:23:49,139
being able to take for example an SD

01:23:46,590 --> 01:23:50,429
card with Debian or fedora or one

01:23:49,139 --> 01:23:54,000
distribution on it and boot it on

01:23:50,429 --> 01:23:56,820
different hardware and before I start

01:23:54,000 --> 01:23:59,280
I'd just like to acknowledge and I'll do

01:23:56,820 --> 01:24:02,460
this a little bit later in the

01:23:59,280 --> 01:24:05,909
presentation but as we've discussed some

01:24:02,460 --> 01:24:08,489
of these issues like issues on the Linux

01:24:05,909 --> 01:24:12,239
risk fives list and the broader Linux

01:24:08,489 --> 01:24:17,070
lists that Mark Rutland's contributions

01:24:12,239 --> 01:24:18,750
have been an invaluable for this so what

01:24:17,070 --> 01:24:21,469
about power management is CPU

01:24:18,750 --> 01:24:25,170
architecture specific almost nothing

01:24:21,469 --> 01:24:27,150
except in recent years folks who define

01:24:25,170 --> 01:24:30,960
CPU architectures are also able to

01:24:27,150 --> 01:24:32,429
define recommended methods for binaries

01:24:30,960 --> 01:24:34,530
there at that architecture that are

01:24:32,429 --> 01:24:36,900
based on that architecture to interact

01:24:34,530 --> 01:24:39,300
with platforms I'm calling that this

01:24:36,900 --> 01:24:41,400
part the interface method and then

01:24:39,300 --> 01:24:45,300
usually when they do that they then go

01:24:41,400 --> 01:24:47,909
ahead and define a set of operations to

01:24:45,300 --> 01:24:51,300
implement via that interface method I'm

01:24:47,909 --> 01:24:53,520
just calling the operations so again why

01:24:51,300 --> 01:24:57,239
have standard operations for portable

01:24:53,520 --> 01:24:59,099
binaries running on different hardware

01:24:57,239 --> 01:25:04,860
from different vendors also the emulator

01:24:59,099 --> 01:25:07,170
and simulator folks want this and the

01:25:04,860 --> 01:25:10,949
goal is to push at least some platform

01:25:07,170 --> 01:25:12,480
variation behind the SPI so I won't

01:25:10,949 --> 01:25:13,110
spend too much time on this what are

01:25:12,480 --> 01:25:14,730
some common

01:25:13,110 --> 01:25:17,510
interface methods that folks have used

01:25:14,730 --> 01:25:20,610
in the past memory mapped i/o devices

01:25:17,510 --> 01:25:24,150
special instructions like MSRs on Intel

01:25:20,610 --> 01:25:26,940
or coprocessor moves triggering

01:25:24,150 --> 01:25:28,949
exceptions and trapping into a higher

01:25:26,940 --> 01:25:31,830
privilege level or various kinds of

01:25:28,949 --> 01:25:33,570
jumps almost nothing about these

01:25:31,830 --> 01:25:35,340
interface methods has anything to do

01:25:33,570 --> 01:25:39,719
with power management at all it's just

01:25:35,340 --> 01:25:41,100
how you get there the operations of the

01:25:39,719 --> 01:25:43,560
important part they define the

01:25:41,100 --> 01:25:46,260
functionality and so what should we

01:25:43,560 --> 01:25:47,820
define and I'm hope hopefully we can all

01:25:46,260 --> 01:25:50,460
have a discussion about this and you can

01:25:47,820 --> 01:25:51,869
contribute what should be there I want

01:25:50,460 --> 01:25:53,429
to start with the stakeholders I think

01:25:51,869 --> 01:25:57,210
that makes sense and who are the

01:25:53,429 --> 01:26:00,540
stakeholders all of us is developers and

01:25:57,210 --> 01:26:02,369
users Hardware power management

01:26:00,540 --> 01:26:05,639
engineers of whom there are probably

01:26:02,369 --> 01:26:07,560
very few in this room and also software

01:26:05,639 --> 01:26:11,719
power management engineers which I can

01:26:07,560 --> 01:26:14,909
see at least some folks in this room so

01:26:11,719 --> 01:26:17,969
why define new p.m. operations I mean in

01:26:14,909 --> 01:26:21,330
theory if the method by which the the

01:26:17,969 --> 01:26:24,449
interface is the only part that's CPU

01:26:21,330 --> 01:26:26,760
specific oh did you have a question yeah

01:26:24,449 --> 01:26:29,969
I did actually have a question I don't

01:26:26,760 --> 01:26:33,750
know if this is on you talked about a

01:26:29,969 --> 01:26:36,469
coprocessor register did you intend to

01:26:33,750 --> 01:26:40,040
also say something about explicitly

01:26:36,469 --> 01:26:42,290
special purpose hardware registers

01:26:40,040 --> 01:26:45,480
special purpose hardware registers

01:26:42,290 --> 01:26:47,520
registers specifically for the purpose

01:26:45,480 --> 01:26:50,040
of power management is another paradigm

01:26:47,520 --> 01:26:52,800
I don't know whether you and intended to

01:26:50,040 --> 01:26:55,739
imply that yeah that was what was kind

01:26:52,800 --> 01:26:57,960
of intended there special instructions a

01:26:55,739 --> 01:26:59,280
lot of times those special registers are

01:26:57,960 --> 01:27:01,320
actually accessed with special

01:26:59,280 --> 01:27:03,270
instructions not all right I think it's

01:27:01,320 --> 01:27:05,130
an important paradigm couldn't even

01:27:03,270 --> 01:27:07,889
reserve its own bullet in my opinion

01:27:05,130 --> 01:27:09,810
because it's important if you're asking

01:27:07,889 --> 01:27:12,389
about risk 5 as an architecture do you

01:27:09,810 --> 01:27:15,020
want to say this architecture likes to

01:27:12,389 --> 01:27:17,250
do power management by dedicated

01:27:15,020 --> 01:27:18,389
registers or do you want to do it

01:27:17,250 --> 01:27:20,909
through a software interface

01:27:18,389 --> 01:27:23,460
I think it's intimate ah opposite

01:27:20,909 --> 01:27:25,230
paradigms so when you're talking about

01:27:23,460 --> 01:27:26,929
registers are you talking about

01:27:25,230 --> 01:27:30,079
CPU specific

01:27:26,929 --> 01:27:32,570
jester's or say like endpoint IP devices

01:27:30,079 --> 01:27:34,610
that manage yeah CPU is obviously the

01:27:32,570 --> 01:27:36,199
starting point right if everything if

01:27:34,610 --> 01:27:38,719
you want to manage the CPU power state

01:27:36,199 --> 01:27:40,400
it better to be more efficient to have

01:27:38,719 --> 01:27:42,800
it be something that's very close to it

01:27:40,400 --> 01:27:44,599
but in designing things it's good to be

01:27:42,800 --> 01:27:46,369
general-purpose to say you know does it

01:27:44,599 --> 01:27:48,079
make sense to have a register which

01:27:46,369 --> 01:27:51,079
talks about the whole platform state

01:27:48,079 --> 01:27:54,019
right so having a special power register

01:27:51,079 --> 01:27:55,939
is an idea I'm not saying it's good or a

01:27:54,019 --> 01:27:58,489
bad idea I'm just saying that to me I

01:27:55,939 --> 01:28:00,380
didn't read the dot dot dot to include

01:27:58,489 --> 01:28:02,209
that and my suggestion to you would be

01:28:00,380 --> 01:28:04,369
to make it more explicit as another

01:28:02,209 --> 01:28:07,150
design alternative thank you very much

01:28:04,369 --> 01:28:07,150
I'll take that as a newt

01:28:07,449 --> 01:28:11,739
okay you got it all right thanks

01:28:14,340 --> 01:28:22,560
so if the interface is really not

01:28:18,680 --> 01:28:24,420
specific to just general power

01:28:22,560 --> 01:28:25,830
management topics if it's an artifact of

01:28:24,420 --> 01:28:29,700
the architecture I mean could we

01:28:25,830 --> 01:28:32,340
potentially just take arm something very

01:28:29,700 --> 01:28:34,950
similar to arm PSC is for example and

01:28:32,340 --> 01:28:37,110
reuse it just with their risk five

01:28:34,950 --> 01:28:41,010
specific mechanism like the SPI

01:28:37,110 --> 01:28:42,600
the answer is we absolutely could there

01:28:41,010 --> 01:28:44,750
are some reasons why we might want to do

01:28:42,600 --> 01:28:47,100
things just a little bit differently

01:28:44,750 --> 01:28:48,900
these days the hardware is more

01:28:47,100 --> 01:28:52,380
sophisticated than it was when some of

01:28:48,900 --> 01:28:54,620
the original PSC I work was done the

01:28:52,380 --> 01:28:57,830
software is becoming more sophisticated

01:28:54,620 --> 01:29:01,080
we have the energyaware scheduler and

01:28:57,830 --> 01:29:05,700
just more thought and energy put into

01:29:01,080 --> 01:29:09,570
how to create these kinds of interfaces

01:29:05,700 --> 01:29:12,330
and use them inside software and it's

01:29:09,570 --> 01:29:15,720
tough to really bring everybody in on on

01:29:12,330 --> 01:29:17,990
these things oftentimes the the folks

01:29:15,720 --> 01:29:20,400
who do some of the initial

01:29:17,990 --> 01:29:22,380
implementations of these they they may

01:29:20,400 --> 01:29:24,240
have a really good sense of what should

01:29:22,380 --> 01:29:25,920
be done from the OS point of view or the

01:29:24,240 --> 01:29:28,470
platform from our point of view but

01:29:25,920 --> 01:29:30,960
maybe a little less aware of what the

01:29:28,470 --> 01:29:33,150
hardware actually can do and vice versa

01:29:30,960 --> 01:29:36,660
so the goal is to try and bring

01:29:33,150 --> 01:29:39,870
everybody in we have this philosophy in

01:29:36,660 --> 01:29:42,900
RISC 5 that comes directly from the RISC

01:29:39,870 --> 01:29:45,510
5 inventors themselves which is this

01:29:42,900 --> 01:29:47,700
idea of a big tent philosophy which is

01:29:45,510 --> 01:29:50,880
we don't necessarily like to force

01:29:47,700 --> 01:29:52,530
people to do things we like to to put

01:29:50,880 --> 01:29:55,110
together specs that seem to make sense

01:29:52,530 --> 01:30:00,780
and we encourage people to use them but

01:29:55,110 --> 01:30:02,730
we try not to compel anyone the goal is

01:30:00,780 --> 01:30:06,600
to learn and borrow from the past that

01:30:02,730 --> 01:30:09,450
includes everything Intel what Intel is

01:30:06,600 --> 01:30:11,400
done what arm has done what a lot of the

01:30:09,450 --> 01:30:12,840
individual SOC vendors have done in the

01:30:11,400 --> 01:30:17,550
past and hopefully build something

01:30:12,840 --> 01:30:18,930
better so just briefly I want to talk a

01:30:17,550 --> 01:30:22,320
little bit about some of the

01:30:18,930 --> 01:30:24,150
implications of the RISC 5 philosophy

01:30:22,320 --> 01:30:26,430
this big tent idea and again the goal is

01:30:24,150 --> 01:30:28,380
to create recommendations so we're not

01:30:26,430 --> 01:30:32,880
trying to compel

01:30:28,380 --> 01:30:35,670
users to use SBI or the SBI based power

01:30:32,880 --> 01:30:37,980
management specification the goal is to

01:30:35,670 --> 01:30:41,010
create recommendations and reference

01:30:37,980 --> 01:30:45,060
platform specifications so when folks

01:30:41,010 --> 01:30:47,430
develop software or sell hardware

01:30:45,060 --> 01:30:50,370
platforms they can say you know we've

01:30:47,430 --> 01:30:52,410
designed this to be compliant with

01:30:50,370 --> 01:30:55,020
such-and-such reference specification

01:30:52,410 --> 01:30:57,720
and that's how we'd like to encourage

01:30:55,020 --> 01:31:02,430
these portable like the portable binary

01:30:57,720 --> 01:31:04,620
use cases so just as an example of what

01:31:02,430 --> 01:31:07,200
this implies let's say someone wants to

01:31:04,620 --> 01:31:10,860
take a twenty ten era SOC something like

01:31:07,200 --> 01:31:14,100
an ohm app that uses an MMO based

01:31:10,860 --> 01:31:18,240
platform interface which is all through

01:31:14,100 --> 01:31:21,990
registers and replace the proprietary

01:31:18,240 --> 01:31:24,720
CPU cores and whatever that SOC is with

01:31:21,990 --> 01:31:28,020
RISC five cores we don't want to force

01:31:24,720 --> 01:31:30,030
them to also change their software to

01:31:28,020 --> 01:31:31,500
use SBI if they don't want to they

01:31:30,030 --> 01:31:33,660
should be able to continue to use

01:31:31,500 --> 01:31:37,050
whatever existing mechanisms that

01:31:33,660 --> 01:31:40,110
platform provides so I mention OMAP just

01:31:37,050 --> 01:31:41,790
because one of the examples in the past

01:31:40,110 --> 01:31:43,730
has been CPU hot-plug

01:31:41,790 --> 01:31:50,430
there's been a lot of concern about

01:31:43,730 --> 01:31:53,340
being able to set the reset vector that

01:31:50,430 --> 01:31:57,060
a newly brought up CPU starts executing

01:31:53,340 --> 01:32:00,660
at via some kind of mechanism and an arm

01:31:57,060 --> 01:32:02,910
PSC I for example that's done with a PSC

01:32:00,660 --> 01:32:06,120
I call but another way to do it back

01:32:02,910 --> 01:32:08,790
before PSC I existed was that the OMAP

01:32:06,120 --> 01:32:10,860
actually had ROM code that all the CPUs

01:32:08,790 --> 01:32:12,780
entered and there were two special

01:32:10,860 --> 01:32:17,280
registers and one of the IP blocks that

01:32:12,780 --> 01:32:20,370
could be used to set the initial PC for

01:32:17,280 --> 01:32:22,830
those newly brought up CPUs so I bring

01:32:20,370 --> 01:32:24,420
that up not necessarily because it's a

01:32:22,830 --> 01:32:27,240
great idea I don't really have any

01:32:24,420 --> 01:32:29,040
opinion up about it but it is just an

01:32:27,240 --> 01:32:31,520
example of another way to accomplish the

01:32:29,040 --> 01:32:31,520
same goal

01:32:31,800 --> 01:32:35,520
similarly if someone wants to build a

01:32:33,630 --> 01:32:37,650
system with no platform firmware and

01:32:35,520 --> 01:32:38,940
just boot on bare metal that's fine too

01:32:37,650 --> 01:32:41,450
we want we don't want to force anyone to

01:32:38,940 --> 01:32:41,450
use SPI

01:32:41,620 --> 01:32:45,830
so here's where we really get into the

01:32:43,730 --> 01:32:48,860
meat of the talk and I think where it'd

01:32:45,830 --> 01:32:53,150
be fun to have just see what folks want

01:32:48,860 --> 01:32:56,510
to do what should we define for power

01:32:53,150 --> 01:32:59,000
management and SPI a platform and power

01:32:56,510 --> 01:33:02,540
management mechanism some folks think it

01:32:59,000 --> 01:33:04,340
should be very minimal hot plug and not

01:33:02,540 --> 01:33:06,050
much else

01:33:04,340 --> 01:33:09,260
some I've talked to some people who

01:33:06,050 --> 01:33:11,120
think ideally SBI should be very maximal

01:33:09,260 --> 01:33:13,699
that there essentially should be no

01:33:11,120 --> 01:33:15,770
memory mapped i/o devices on the system

01:33:13,699 --> 01:33:18,170
at all and that all drivers would

01:33:15,770 --> 01:33:21,860
interact through - with the hardware

01:33:18,170 --> 01:33:24,670
through SPI calls I would like to

01:33:21,860 --> 01:33:27,650
propose that we start small and build up

01:33:24,670 --> 01:33:30,679
similar to what was done what we're

01:33:27,650 --> 01:33:34,219
planning to do with the RISC 5 base SBI

01:33:30,679 --> 01:33:36,949
spec which is to define a core and then

01:33:34,219 --> 01:33:40,449
layer on pieces on top of that that can

01:33:36,949 --> 01:33:43,880
be tested for at run time by software

01:33:40,449 --> 01:33:48,140
and the goal would be yeah just to

01:33:43,880 --> 01:33:50,000
support querying the features and here's

01:33:48,140 --> 01:33:52,640
some starting points and this is more or

01:33:50,000 --> 01:33:55,340
less my last slide so we're kind of

01:33:52,640 --> 01:33:57,980
transitioning into the discussion side

01:33:55,340 --> 01:34:00,350
of it so there's p.m. feature queries

01:33:57,980 --> 01:34:04,820
which is essentially that base layer as

01:34:00,350 --> 01:34:07,640
in what what methods does the SBI

01:34:04,820 --> 01:34:11,540
provide for power management that can be

01:34:07,640 --> 01:34:14,179
used we're pretty sure that CPU hot plug

01:34:11,540 --> 01:34:15,890
is core functionality that we want to

01:34:14,179 --> 01:34:18,530
define although I suppose that can be

01:34:15,890 --> 01:34:22,400
open for discussion as well

01:34:18,530 --> 01:34:25,340
CPU hot plug and unplug and query the

01:34:22,400 --> 01:34:28,190
CPU hot plug state if you were at the

01:34:25,340 --> 01:34:29,840
earlier presentations today here in the

01:34:28,190 --> 01:34:33,170
RISC 5 micro conference you heard mark

01:34:29,840 --> 01:34:34,699
talking about some of those obviously

01:34:33,170 --> 01:34:38,510
those are key for a lot of use cases

01:34:34,699 --> 01:34:44,870
like Kay exec and then we start building

01:34:38,510 --> 01:34:46,880
on top of that into into features that

01:34:44,870 --> 01:34:48,320
may be a little bit more questionable as

01:34:46,880 --> 01:34:51,770
to whether someone is implemented than

01:34:48,320 --> 01:34:53,139
or not for example platform reset that

01:34:51,770 --> 01:34:56,619
one might be

01:34:53,139 --> 01:34:59,350
fairly innocuous but shutdown might be

01:34:56,619 --> 01:35:01,330
something that actually needs to send a

01:34:59,350 --> 01:35:03,489
command over an I squared C bus to an

01:35:01,330 --> 01:35:05,830
external PM ik and the colonel for

01:35:03,489 --> 01:35:08,500
example may already be managing that I

01:35:05,830 --> 01:35:10,239
squared C bus so it gets problematic and

01:35:08,500 --> 01:35:13,270
that you can have these conflicts

01:35:10,239 --> 01:35:16,510
between layers so it's possible that not

01:35:13,270 --> 01:35:20,980
all platforms may support that call and

01:35:16,510 --> 01:35:25,210
then we go from there and two features

01:35:20,980 --> 01:35:27,010
like CPU idle if we want to put a CPU

01:35:25,210 --> 01:35:30,340
into idle via some kind of platform

01:35:27,010 --> 01:35:32,800
independent independent mechanism or

01:35:30,340 --> 01:35:35,619
Hardware independent mechanism there are

01:35:32,800 --> 01:35:37,090
a lot of different ways to do that there

01:35:35,619 --> 01:35:41,260
could we could try and implement

01:35:37,090 --> 01:35:43,000
something very Hardware independent in

01:35:41,260 --> 01:35:45,580
terms of the actual underlying

01:35:43,000 --> 01:35:48,550
implementation where we just pass

01:35:45,580 --> 01:35:50,530
information like the maximum wake-up

01:35:48,550 --> 01:35:55,510
latency that we wish to tolerate for

01:35:50,530 --> 01:35:59,230
that CPU and for example the expected

01:35:55,510 --> 01:36:01,179
sleep residency that that the amount of

01:35:59,230 --> 01:36:05,139
time essentially that we expect that CPU

01:36:01,179 --> 01:36:06,250
to be asleep for but and of course

01:36:05,139 --> 01:36:08,469
there's nothing that says that we

01:36:06,250 --> 01:36:10,510
couldn't do several of these we could

01:36:08,469 --> 01:36:12,670
also have an explicit state interface

01:36:10,510 --> 01:36:14,050
which for a long time was the

01:36:12,670 --> 01:36:16,840
traditional way that this was

01:36:14,050 --> 01:36:19,900
implemented if you look at something

01:36:16,840 --> 01:36:23,320
like maybe a CPI you have a list of

01:36:19,900 --> 01:36:25,780
different power states that the CPU

01:36:23,320 --> 01:36:28,900
could go into and you don't necessarily

01:36:25,780 --> 01:36:31,540
need to know what each one of those does

01:36:28,900 --> 01:36:34,300
you just need to order them and

01:36:31,540 --> 01:36:37,179
different essentially by wakeup latency

01:36:34,300 --> 01:36:41,050
and possibly provide a bit more

01:36:37,179 --> 01:36:44,020
information there back to the OS and

01:36:41,050 --> 01:36:48,010
then there's kind of a special case of

01:36:44,020 --> 01:36:51,580
that of CPU idle effectively which is

01:36:48,010 --> 01:36:53,710
CPU suspend when you would force a CPU

01:36:51,580 --> 01:36:55,960
to go down and go to sleep

01:36:53,710 --> 01:36:59,770
but without expecting it to actually

01:36:55,960 --> 01:37:02,340
wake up so with that I just like to open

01:36:59,770 --> 01:37:05,109
the floor I hope we have folks here from

01:37:02,340 --> 01:37:07,599
distributions and hardware vendors and

01:37:05,109 --> 01:37:10,719
folks who have done power management

01:37:07,599 --> 01:37:12,280
work before and just see maybe some

01:37:10,719 --> 01:37:16,320
hopefully we have some folks here from

01:37:12,280 --> 01:37:20,260
the simulator qmu communities and just

01:37:16,320 --> 01:37:25,229
talk about what folks opinions are so

01:37:20,260 --> 01:37:25,229
with that please discuss

01:37:33,750 --> 01:37:38,659
my catching ability is somewhat limited

01:37:35,190 --> 01:37:38,659
because I don't have binocular vision

01:37:39,139 --> 01:37:45,780
okay so I'm looking at this and from my

01:37:42,119 --> 01:37:51,449
Kiley more embedded world I do like the

01:37:45,780 --> 01:37:52,920
multiple I call power levels and in in

01:37:51,449 --> 01:37:55,530
in the description of what can be done

01:37:52,920 --> 01:37:59,309
in different power levels because this

01:37:55,530 --> 01:38:01,260
can be very very useful too I call let's

01:37:59,309 --> 01:38:03,210
say we have a CPU which is normal which

01:38:01,260 --> 01:38:05,880
is effectively off as far as the

01:38:03,210 --> 01:38:08,099
computation goes but it still has some

01:38:05,880 --> 01:38:10,980
sort of bus interface and is populating

01:38:08,099 --> 01:38:12,840
memory so we can use it to talk to so we

01:38:10,980 --> 01:38:15,840
have a peripheral device let's say which

01:38:12,840 --> 01:38:18,119
is running doing some sort of data

01:38:15,840 --> 01:38:20,159
gathering but and we don't need to run

01:38:18,119 --> 01:38:21,719
the CPU continuously to actually process

01:38:20,159 --> 01:38:24,750
the data we can process the data in a

01:38:21,719 --> 01:38:28,829
bursty manner so if we can operate this

01:38:24,750 --> 01:38:30,540
such as keeping some boss alive to

01:38:28,829 --> 01:38:32,730
collect some memory interface and stuff

01:38:30,540 --> 01:38:34,770
like that these kind of low-level modes

01:38:32,730 --> 01:38:37,770
which affected the computation unit is

01:38:34,770 --> 01:38:40,469
off but it's got DMA and so you can just

01:38:37,770 --> 01:38:42,719
snap up and then the very fast snap up

01:38:40,469 --> 01:38:46,429
source startup from these faces can be

01:38:42,719 --> 01:38:46,429
very very useful and things like that

01:38:47,420 --> 01:38:56,699
yeah I agree yeah so I think that's an

01:38:53,969 --> 01:38:59,639
interesting use case it's it's a the

01:38:56,699 --> 01:39:02,670
general case of where the CPU and Linux

01:38:59,639 --> 01:39:04,619
might be off but you have other chunks

01:39:02,670 --> 01:39:08,250
of the hardware that are autonomously

01:39:04,619 --> 01:39:12,360
coming up and down to process sensor

01:39:08,250 --> 01:39:15,059
data for example and I think that we

01:39:12,360 --> 01:39:17,639
definitely want to encourage people to

01:39:15,059 --> 01:39:21,270
develop things like that I suppose the

01:39:17,639 --> 01:39:23,159
question that I would have is and then

01:39:21,270 --> 01:39:26,400
this is just in the very specific

01:39:23,159 --> 01:39:29,579
context of the software interface

01:39:26,400 --> 01:39:32,309
between say the OS kernel and whatever

01:39:29,579 --> 01:39:36,770
platform firmware that a vendor might

01:39:32,309 --> 01:39:40,860
provide should we have should we try and

01:39:36,770 --> 01:39:42,270
add methods to control that in in that

01:39:40,860 --> 01:39:45,630
interface to

01:39:42,270 --> 01:39:47,910
to allow that specific use case yes or

01:39:45,630 --> 01:39:50,760
does it make sense does it make sense to

01:39:47,910 --> 01:39:54,660
have those outside the SBI and just

01:39:50,760 --> 01:39:57,440
handled via MMI oh well I think that

01:39:54,660 --> 01:40:01,500
that's the back to the implementation

01:39:57,440 --> 01:40:03,030
discussion with SB is we could have that

01:40:01,500 --> 01:40:05,070
definitely I think it's a good idea to

01:40:03,030 --> 01:40:07,500
have an SPI but at the same time you

01:40:05,070 --> 01:40:10,920
also want to although that will permit

01:40:07,500 --> 01:40:13,910
or boot and mode so in that case that

01:40:10,920 --> 01:40:17,250
would be maybe platform dependent and

01:40:13,910 --> 01:40:19,560
your West level CPI adult driver would

01:40:17,250 --> 01:40:24,330
be different which is fine I mean you

01:40:19,560 --> 01:40:27,500
just need a driver fight for SBI if you

01:40:24,330 --> 01:40:30,540
want some kind of a standard for that I

01:40:27,500 --> 01:40:36,720
definitely want that explicit state

01:40:30,540 --> 01:40:39,140
removed yeah that's horrible the reason

01:40:36,720 --> 01:40:41,610
for that it's that doesn't mean anything

01:40:39,140 --> 01:40:44,760
because from generation to generation of

01:40:41,610 --> 01:40:47,130
your cpu implementation you will have

01:40:44,760 --> 01:40:49,050
such huge differences for example in the

01:40:47,130 --> 01:40:50,940
wake up time from that particular state

01:40:49,050 --> 01:40:52,410
that the state in itself doesn't mean

01:40:50,940 --> 01:40:54,720
anything anymore because you don't know

01:40:52,410 --> 01:40:56,970
which one is going to be adapted to what

01:40:54,720 --> 01:41:00,170
we want to do for example you're waiting

01:40:56,970 --> 01:41:03,480
for an i/o on a super fast super fast

01:41:00,170 --> 01:41:06,030
device polling doing an OP bloop if you

01:41:03,480 --> 01:41:08,550
go on super deep sleep because of that

01:41:06,030 --> 01:41:12,060
and it takes 10 micro second to wake up

01:41:08,550 --> 01:41:15,210
the CPU then you lost IO performance you

01:41:12,060 --> 01:41:18,150
where after so I do like the maximum

01:41:15,210 --> 01:41:20,220
wakeup latency for example because then

01:41:18,150 --> 01:41:23,660
you become completely independent of the

01:41:20,220 --> 01:41:26,910
actual CPU using and the the the

01:41:23,660 --> 01:41:29,490
firmware or the SPI or internally some

01:41:26,910 --> 01:41:32,250
something can determine for you the best

01:41:29,490 --> 01:41:34,170
state to go there to meet that maximum

01:41:32,250 --> 01:41:37,410
wake up Lindsey for example super

01:41:34,170 --> 01:41:39,150
flexible I think they CPIC something and

01:41:37,410 --> 01:41:40,040
P something states just forget about it

01:41:39,150 --> 01:41:43,650
please

01:41:40,040 --> 01:41:45,750
it's horrible yeah yeah I've had that

01:41:43,650 --> 01:41:48,390
reaction myself then the nice thing

01:41:45,750 --> 01:41:52,440
about something like an explicit state

01:41:48,390 --> 01:41:54,360
interface at least is an option and and

01:41:52,440 --> 01:41:55,860
maybe something also where some of the

01:41:54,360 --> 01:41:57,810
latency data could be

01:41:55,860 --> 01:42:00,630
eventually queried dynamically when the

01:41:57,810 --> 01:42:02,489
system boots where there could be a SBI

01:42:00,630 --> 01:42:05,520
method where you say hey okay this state

01:42:02,489 --> 01:42:08,210
p1 what's the wakeup latency for state

01:42:05,520 --> 01:42:11,070
p1 and what's the wake of but again I

01:42:08,210 --> 01:42:13,350
make sure I put out a new car and it's

01:42:11,070 --> 01:42:15,659
doing better job at the audit and p1 is

01:42:13,350 --> 01:42:18,360
now faster so what does p1 mean now for

01:42:15,659 --> 01:42:20,670
the US doesn't know oh yeah so the idea

01:42:18,360 --> 01:42:24,000
in that case would be when the system

01:42:20,670 --> 01:42:27,090
boots and the cpu idle driver starts one

01:42:24,000 --> 01:42:29,699
could query through the SBI say ok I

01:42:27,090 --> 01:42:33,000
have these different state options p0

01:42:29,699 --> 01:42:35,010
through p6 or what have you then it

01:42:33,000 --> 01:42:37,350
could also get back potentially a wake

01:42:35,010 --> 01:42:39,800
up a max of the maximum wakeup latency

01:42:37,350 --> 01:42:42,030
freaks are we just arguing here that

01:42:39,800 --> 01:42:43,980
basically we don't want to name these

01:42:42,030 --> 01:42:47,429
states what you have is a list of

01:42:43,980 --> 01:42:50,909
potential states with expected wakeup

01:42:47,429 --> 01:42:53,040
latencies and then you can say oh I

01:42:50,909 --> 01:42:56,250
don't want you to get to a latency that

01:42:53,040 --> 01:42:58,230
that would be more than this and your

01:42:56,250 --> 01:43:05,130
objection is looks to me it looks like I

01:42:58,230 --> 01:43:08,340
don't want to give them a name so the

01:43:05,130 --> 01:43:09,389
question is you know how do we encode so

01:43:08,340 --> 01:43:11,340
you know the colonel says I want to go

01:43:09,389 --> 01:43:12,719
to this lower power state where those

01:43:11,340 --> 01:43:14,610
particular wake up latency so how do we

01:43:12,719 --> 01:43:16,830
encode that so as the colonel just say

01:43:14,610 --> 01:43:19,139
here are my requirements right I need to

01:43:16,830 --> 01:43:21,179
be able to wake up in 10 milliseconds

01:43:19,139 --> 01:43:22,409
right or does the colonel know all of

01:43:21,179 --> 01:43:23,760
the different things the hardware can

01:43:22,409 --> 01:43:26,190
provide and then pick one of them I

01:43:23,760 --> 01:43:28,409
don't think anyone saying we should

01:43:26,190 --> 01:43:31,260
write in the spec there's p1 p2 p3 and

01:43:28,409 --> 01:43:33,210
you go into them that's no that's a mess

01:43:31,260 --> 01:43:34,949
but people have known oh I agree and

01:43:33,210 --> 01:43:39,119
then I think the reason we all know it's

01:43:34,949 --> 01:43:41,780
a mess is because everybody's done it so

01:43:39,119 --> 01:43:41,780
it's all the mike

01:43:43,300 --> 01:43:47,810
yeah all right so um not just latency is

01:43:46,850 --> 01:43:50,780
important but ice called

01:43:47,810 --> 01:43:53,510
what functional operations we can do in

01:43:50,780 --> 01:43:55,460
it you need in a call a state or I mean

01:43:53,510 --> 01:43:57,440
it's worth state because we there so

01:43:55,460 --> 01:43:59,510
it's not just latency an important but

01:43:57,440 --> 01:44:01,820
what kind of operations I can do within

01:43:59,510 --> 01:44:03,770
that state so let's say I can I can do

01:44:01,820 --> 01:44:06,890
clocking so I can maintain a timing or I

01:44:03,770 --> 01:44:15,140
can do I owe communication that kind of

01:44:06,890 --> 01:44:19,219
I mean standardization tends to be

01:44:15,140 --> 01:44:21,440
coupled to a bunch of other stuff like

01:44:19,219 --> 01:44:23,179
broader yeah and the problem is that you

01:44:21,440 --> 01:44:25,550
know you bring the CPU into a state that

01:44:23,179 --> 01:44:26,750
affects a bunch of other things that may

01:44:25,550 --> 01:44:28,610
not smell like they really have anything

01:44:26,750 --> 01:44:30,320
to do to the CPU but are in the same

01:44:28,610 --> 01:44:33,170
power domain or whatever and encoding

01:44:30,320 --> 01:44:34,400
those in a way that doesn't end up just

01:44:33,170 --> 01:44:37,400
having a spec that's written for your

01:44:34,400 --> 01:44:39,860
particular platform is the headache so I

01:44:37,400 --> 01:44:42,080
think so a couple of points I noticed

01:44:39,860 --> 01:44:44,030
that you don't have anything related to

01:44:42,080 --> 01:44:46,219
clock and regulator management here and

01:44:44,030 --> 01:44:47,900
it's it's funny because in the other

01:44:46,219 --> 01:44:49,969
track in the energy management track

01:44:47,900 --> 01:44:50,960
that's exactly that's it's a parallel

01:44:49,969 --> 01:44:55,820
talk where they are trying to

01:44:50,960 --> 01:44:57,409
standardize that as well yeah so a CMI

01:44:55,820 --> 01:44:58,730
it says it's the microcontroller the

01:44:57,409 --> 01:45:02,330
interface to the microcontroller that

01:44:58,730 --> 01:45:05,199
does the the power handling the clock

01:45:02,330 --> 01:45:08,810
regulators and move that all over the

01:45:05,199 --> 01:45:10,340
the microcontrollers away from Linux so

01:45:08,810 --> 01:45:14,570
what do you think I mean do you think we

01:45:10,340 --> 01:45:16,760
should try and so so as a developer as a

01:45:14,570 --> 01:45:18,890
developer I think it's nice to be able

01:45:16,760 --> 01:45:23,270
to access all of that we've worked on

01:45:18,890 --> 01:45:25,310
some of that over the years but I've

01:45:23,270 --> 01:45:28,219
also worked at a distro for a few years

01:45:25,310 --> 01:45:30,409
and it's a bloody pain in the ass to

01:45:28,219 --> 01:45:39,770
just just get all that to work across

01:45:30,409 --> 01:45:42,620
platforms so this solution being able so

01:45:39,770 --> 01:45:45,500
being able so being able to encode some

01:45:42,620 --> 01:45:47,570
of these numbers into the platform I

01:45:45,500 --> 01:45:49,429
mean that would be nice and then Linux

01:45:47,570 --> 01:45:52,100
actually be able to take the actual

01:45:49,429 --> 01:45:55,280
decision the policy should be on the

01:45:52,100 --> 01:45:59,449
Linux side of things but

01:45:55,280 --> 01:46:03,130
but the actual but the the data I mean I

01:45:59,449 --> 01:46:06,829
think that should directly be exposed is

01:46:03,130 --> 01:46:09,079
is what I feel I mean a lot of the I

01:46:06,829 --> 01:46:11,179
think we're a CPI sort of goes to the

01:46:09,079 --> 01:46:14,480
completely opposite end of the spectrum

01:46:11,179 --> 01:46:17,000
where you just poke a register it's done

01:46:14,480 --> 01:46:21,230
for you it's all done but then you lose

01:46:17,000 --> 01:46:25,130
a lot in terms of policy I mean there's

01:46:21,230 --> 01:46:26,989
this you can do much better yeah it's

01:46:25,130 --> 01:46:29,840
interesting I was chatting with Bjorn

01:46:26,989 --> 01:46:31,760
from Linares something you might recall

01:46:29,840 --> 01:46:33,440
he's I think the technical lead of the

01:46:31,760 --> 01:46:35,690
Qualcomm landing team and one of the

01:46:33,440 --> 01:46:39,829
cases that they have to deal with just

01:46:35,690 --> 01:46:42,289
as an example of a complex SOC that can

01:46:39,829 --> 01:46:44,840
create some issues with this is that the

01:46:42,289 --> 01:46:47,599
CPU the Linux running CPU is just one

01:46:44,840 --> 01:46:50,320
entity on an SOC and there are other

01:46:47,599 --> 01:46:53,510
autonomous processors like the modem

01:46:50,320 --> 01:46:56,360
processor that need to be able to go up

01:46:53,510 --> 01:46:59,420
and down and sometimes even share system

01:46:56,360 --> 01:47:04,460
bus resources that the CPU would also

01:46:59,420 --> 01:47:07,929
share but all while Linux is asleep so

01:47:04,460 --> 01:47:11,960
it creates challenges in some ways for

01:47:07,929 --> 01:47:13,699
on some systems to give Linux complete

01:47:11,960 --> 01:47:16,280
control over the hardware resources

01:47:13,699 --> 01:47:18,770
because the SSA use cases just

01:47:16,280 --> 01:47:20,090
anticipate something larger and in some

01:47:18,770 --> 01:47:21,650
cases you can't even access those

01:47:20,090 --> 01:47:26,210
resources I mean they're they're behind

01:47:21,650 --> 01:47:27,980
some secure software barrier right the

01:47:26,210 --> 01:47:29,989
one thing that we didn't talk about too

01:47:27,980 --> 01:47:32,659
is that on a lot of modern SSDs they

01:47:29,989 --> 01:47:34,400
have system management coprocessors of

01:47:32,659 --> 01:47:38,150
some kind that actually do all the heavy

01:47:34,400 --> 01:47:39,650
lifting of course each SOC probably is

01:47:38,150 --> 01:47:42,710
going to have a different system

01:47:39,650 --> 01:47:44,179
coprocessor interface so from the point

01:47:42,710 --> 01:47:46,849
of view of the software interface that

01:47:44,179 --> 01:47:49,760
then becomes what standard software

01:47:46,849 --> 01:47:52,579
interface can we define in linux that

01:47:49,760 --> 01:47:55,489
the platform firmware can use to talk to

01:47:52,579 --> 01:47:57,260
the system management coprocessor in

01:47:55,489 --> 01:48:00,980
some platform dependent way that we

01:47:57,260 --> 01:48:03,049
don't really care about I was going to

01:48:00,980 --> 01:48:05,359
make a comment sorry on

01:48:03,049 --> 01:48:07,609
exactly so what you're talking about

01:48:05,359 --> 01:48:10,249
this coprocessor is actually becoming

01:48:07,609 --> 01:48:11,989
the typical not the atypical actually

01:48:10,249 --> 01:48:15,289
particularly in the embedded world like

01:48:11,989 --> 01:48:18,559
for Guam or other you know devices for

01:48:15,289 --> 01:48:21,919
for phones where you have your GPU your

01:48:18,559 --> 01:48:27,529
DSP all which are doing really heavy

01:48:21,919 --> 01:48:30,760
lifting and and it's what actually

01:48:27,529 --> 01:48:34,969
happens is is from the current from the

01:48:30,760 --> 01:48:37,939
operating support of view is we we

01:48:34,969 --> 01:48:39,499
actually have a pipeline which which

01:48:37,939 --> 01:48:42,049
actually designed to run through these

01:48:39,499 --> 01:48:44,439
cope these accelerated process like we

01:48:42,049 --> 01:48:46,969
actually are designing it such that

01:48:44,439 --> 01:48:49,219
image will come in for example and go

01:48:46,969 --> 01:48:52,489
into our DSP will do some processing

01:48:49,219 --> 01:48:54,619
into use P will go back to GPU and then

01:48:52,489 --> 01:48:57,279
we made me do some ML on it whatever and

01:48:54,619 --> 01:48:59,869
then finally it gets to a point where

01:48:57,279 --> 01:49:01,909
based upon the ML results we can say

01:48:59,869 --> 01:49:03,799
look okay right I want to do something

01:49:01,909 --> 01:49:07,399
with it and actually it's actually now

01:49:03,799 --> 01:49:09,889
handled by the CPU so our size CP by the

01:49:07,399 --> 01:49:14,809
operating system so what we really need

01:49:09,889 --> 01:49:18,229
is a lot of hooks and and basically

01:49:14,809 --> 01:49:20,389
these are gonna like load code and wave

01:49:18,229 --> 01:49:21,889
dispatching code and hooks to receipt

01:49:20,389 --> 01:49:26,839
results and stuff like that like a

01:49:21,889 --> 01:49:28,729
dispatcher system so I guess the

01:49:26,839 --> 01:49:30,849
question that I would have is given the

01:49:28,729 --> 01:49:32,959
variety of different hardware

01:49:30,849 --> 01:49:35,029
implementations and even different use

01:49:32,959 --> 01:49:37,760
cases that are out there do you think

01:49:35,029 --> 01:49:41,419
it's possible to actually develop

01:49:37,760 --> 01:49:43,999
something fairly standard that we could

01:49:41,419 --> 01:49:45,799
put into an SPI like power management

01:49:43,999 --> 01:49:48,229
like layer that would handle all those I

01:49:45,799 --> 01:49:49,969
I think we need to consider it is almost

01:49:48,229 --> 01:49:51,799
like a multiprocessor on a problem like

01:49:49,969 --> 01:49:54,379
we have these Sox's oxi multiple

01:49:51,799 --> 01:49:59,629
processors actually and and it's in is

01:49:54,379 --> 01:50:01,749
communicating to other devices now go

01:49:59,629 --> 01:50:01,749
ahead

01:50:01,980 --> 01:50:05,949
it's actually going to make a comment

01:50:04,119 --> 01:50:09,309
related to that is that so you have

01:50:05,949 --> 01:50:11,050
these slides as a starting point but I

01:50:09,309 --> 01:50:13,900
think from from the discussion we are

01:50:11,050 --> 01:50:17,800
having right now that that fine grain

01:50:13,900 --> 01:50:19,480
control for for power states maybe

01:50:17,800 --> 01:50:22,570
that's not our starting point that's not

01:50:19,480 --> 01:50:24,340
like the the power management base you

01:50:22,570 --> 01:50:30,749
want in the SPI and you want that as an

01:50:24,340 --> 01:50:34,420
extension power management extension so

01:50:30,749 --> 01:50:36,340
CPU on off the hot plug is an obvious

01:50:34,420 --> 01:50:39,730
one for sure that's a starting point the

01:50:36,340 --> 01:50:42,130
research on down is no-brainer CPU

01:50:39,730 --> 01:50:45,429
saucepan not sure but definitely maybe

01:50:42,130 --> 01:50:47,289
the the CPU idle because we entered this

01:50:45,429 --> 01:50:49,179
realm where it becomes so much dependent

01:50:47,289 --> 01:50:51,489
on the actual platform structure if you

01:50:49,179 --> 01:50:53,650
say a scuzzy or something else and all

01:50:51,489 --> 01:50:56,349
this this copper core processor you have

01:50:53,650 --> 01:50:58,630
to also consider maybe that's an

01:50:56,349 --> 01:51:01,179
extension to a second extension for

01:50:58,630 --> 01:51:03,429
power management yeah that makes a lot

01:51:01,179 --> 01:51:06,039
of sense I mean to my mind really only

01:51:03,429 --> 01:51:07,989
the first two bullet points were what I

01:51:06,039 --> 01:51:11,170
was thinking of is the initial base and

01:51:07,989 --> 01:51:16,420
maybe the third the third platform reset

01:51:11,170 --> 01:51:22,329
and shut down yes maybe shut down as you

01:51:16,420 --> 01:51:25,150
said might be tricky yeah but that

01:51:22,329 --> 01:51:27,269
that's kind of a mandatory you want most

01:51:25,150 --> 01:51:30,059
of the time you want a way to turn off

01:51:27,269 --> 01:51:33,670
your thing

01:51:30,059 --> 01:51:35,260
so I guess I would just say is if

01:51:33,670 --> 01:51:37,269
something isn't on this list it doesn't

01:51:35,260 --> 01:51:40,210
mean that it's forbidden it just means

01:51:37,269 --> 01:51:43,119
that there's no portable way of doing it

01:51:40,210 --> 01:51:46,059
effectively or finding the portable way

01:51:43,119 --> 01:51:47,949
will takes more time and we we still

01:51:46,059 --> 01:51:51,820
want to make progress from having that

01:51:47,949 --> 01:51:58,510
as a another level to extension for

01:51:51,820 --> 01:51:59,889
parmesan might make sense yeah I think

01:51:58,510 --> 01:52:01,300
kind of what we're dancing around here

01:51:59,889 --> 01:52:03,400
is that we're we're talking about doing

01:52:01,300 --> 01:52:06,099
a platform spec for CPUs but what's

01:52:03,400 --> 01:52:07,869
really important is the SOC level power

01:52:06,099 --> 01:52:09,820
management right and so this is just a

01:52:07,869 --> 01:52:12,010
tiny little piece and we've already run

01:52:09,820 --> 01:52:13,960
into this in the Linux kernel power

01:52:12,010 --> 01:52:17,050
management when you have when you have

01:52:13,960 --> 01:52:19,480
firmware specs that define how things

01:52:17,050 --> 01:52:21,100
happen for CPUs but you want to override

01:52:19,480 --> 01:52:22,480
that for some reasons because the

01:52:21,100 --> 01:52:24,640
operating system might actually know

01:52:22,480 --> 01:52:28,030
about shared power rails or other

01:52:24,640 --> 01:52:30,850
resources besides CPUs and so I think

01:52:28,030 --> 01:52:33,040
that's where the the minimalist side of

01:52:30,850 --> 01:52:35,200
a spec like this is important because in

01:52:33,040 --> 01:52:36,790
some ways that the operating system or

01:52:35,200 --> 01:52:38,500
operating systems because there's

01:52:36,790 --> 01:52:40,000
multiple cores running potentially

01:52:38,500 --> 01:52:42,010
different OSS and different things going

01:52:40,000 --> 01:52:45,280
on they have to coordinate and so then

01:52:42,010 --> 01:52:47,740
like you said Paula this the CPU or CPUs

01:52:45,280 --> 01:52:49,150
are just a tiny piece of the puzzle and

01:52:47,740 --> 01:52:50,770
so they should focus on what they know

01:52:49,150 --> 01:52:52,900
about but also acknowledge that there's

01:52:50,770 --> 01:52:58,540
a lot that they don't know about and so

01:52:52,900 --> 01:53:01,720
not try to do it all and back to the way

01:52:58,540 --> 01:53:05,880
the for the SPI specs are I'm in this VI

01:53:01,720 --> 01:53:08,650
case power burma tor will be another but

01:53:05,880 --> 01:53:11,830
it's possible to have vendor specific

01:53:08,650 --> 01:53:14,110
extensions and so for those SOC cases

01:53:11,830 --> 01:53:15,880
where you can do much more intelligent

01:53:14,110 --> 01:53:18,060
thing with power management you can have

01:53:15,880 --> 01:53:21,760
that extension for that that particular

01:53:18,060 --> 01:53:23,890
implementation and the OS instead of

01:53:21,760 --> 01:53:27,550
using the the base power management that

01:53:23,890 --> 01:53:29,290
just yell with DP cores instead used the

01:53:27,550 --> 01:53:31,240
vendor specific ones that that would be

01:53:29,290 --> 01:53:33,310
also an option I think yeah so that's

01:53:31,240 --> 01:53:35,680
actually happened in arm 64 lands so the

01:53:33,310 --> 01:53:38,350
arm 64 PCI spec has what they call

01:53:35,680 --> 01:53:39,760
platform coordinated mode where the you

01:53:38,350 --> 01:53:41,830
kind of trust the firmware to do

01:53:39,760 --> 01:53:43,690
everything and then they have this other

01:53:41,830 --> 01:53:45,340
mode called OS initiated mode where the

01:53:43,690 --> 01:53:46,390
theory was that you'd let the OS kind of

01:53:45,340 --> 01:53:48,580
make and override some of these

01:53:46,390 --> 01:53:50,170
decisions but what's happening in that

01:53:48,580 --> 01:53:52,000
and maybe you guys can address this but

01:53:50,170 --> 01:53:54,430
what's happening in that area now is

01:53:52,000 --> 01:53:57,790
it's it's it's it's frowned upon to

01:53:54,430 --> 01:54:08,650
implement the OS initiated mode right so

01:53:57,790 --> 01:54:09,700
the way yeah go ahead mark sorry I was

01:54:08,650 --> 01:54:12,910
dealing with something else and was

01:54:09,700 --> 01:54:15,100
broken yeah so it's not so much that we

01:54:12,910 --> 01:54:18,160
frown on those initiated mode it's that

01:54:15,100 --> 01:54:19,870
we've never seen good numbers for it

01:54:18,160 --> 01:54:22,510
we've repeatedly asked for numbers

01:54:19,870 --> 01:54:24,160
showing it before OSI performs better

01:54:22,510 --> 01:54:25,530
than platform coordinated and we haven't

01:54:24,160 --> 01:54:27,270
never had them

01:54:25,530 --> 01:54:29,159
and the only implementations or

01:54:27,270 --> 01:54:32,520
Versailles that we have seen have

01:54:29,159 --> 01:54:34,710
performed worse so far at which point we

01:54:32,520 --> 01:54:36,780
don't take that into mainline because it

01:54:34,710 --> 01:54:39,630
had a huge amount of complexity I think

01:54:36,780 --> 01:54:46,920
that was only added to the spec after

01:54:39,630 --> 01:54:49,429
quite a lot of back and forth so I'm not

01:54:46,920 --> 01:54:52,050
sure OSI is bat is good or bad

01:54:49,429 --> 01:54:53,579
we just don't know and for the other

01:54:52,050 --> 01:54:55,530
parts where we're sharing state with

01:54:53,579 --> 01:54:57,570
like other devices like clocks

01:54:55,530 --> 01:54:58,980
regulators all those other things the

01:54:57,570 --> 01:55:02,699
expectation was that that kind of thing

01:54:58,980 --> 01:55:04,860
would be solved by SCM I so to another

01:55:02,699 --> 01:55:08,429
yet another firmware interface with four

01:55:04,860 --> 01:55:10,800
letters with I at the end but the idea

01:55:08,429 --> 01:55:13,559
of that was that you could still have

01:55:10,800 --> 01:55:14,849
that knowledge in the firmware which is

01:55:13,559 --> 01:55:17,190
having to manage that for CPU power

01:55:14,849 --> 01:55:19,679
management and the OS can still request

01:55:17,190 --> 01:55:23,059
the firmware to do the management of the

01:55:19,679 --> 01:55:23,059
other devices that are sharing up

01:55:24,910 --> 01:55:29,990
yeah there you go

01:55:28,400 --> 01:55:32,240
does anyone else have any last-minute

01:55:29,990 --> 01:55:46,490
comments I think it's time for the time

01:55:32,240 --> 01:55:49,060
for you okay thank you very much next is

01:55:46,490 --> 01:55:49,060
hypervisor

01:57:36,890 --> 01:57:44,430
is that long

01:57:39,280 --> 01:57:47,770
thumbs up okay so the hypervisor set us

01:57:44,430 --> 01:57:49,060
so I talked about this a little bit with

01:57:47,770 --> 01:57:51,310
some people and they everyone kind of

01:57:49,060 --> 01:57:55,270
asked why does anyone want a hypervisor

01:57:51,310 --> 01:57:57,190
in there's five it's maybe one day when

01:57:55,270 --> 01:57:59,410
we get cloud computing and bubble up but

01:57:57,190 --> 01:58:02,640
but so I wanted to start with that

01:57:59,410 --> 01:58:05,140
hypervisor is our common it's not just

01:58:02,640 --> 01:58:07,180
the big cloud companies that are using

01:58:05,140 --> 01:58:09,810
them for their cloud services and

01:58:07,180 --> 01:58:13,420
everything so

01:58:09,810 --> 01:58:15,970
so they used in in obviously that but

01:58:13,420 --> 01:58:17,830
then also consumer applications so the

01:58:15,970 --> 01:58:20,020
Xbox one I don't know people know is is

01:58:17,830 --> 01:58:23,740
based on a hypervisor and and that and

01:58:20,020 --> 01:58:26,020
then in a on 64 world which is kind of

01:58:23,740 --> 01:58:28,510
where respired is competitive comparable

01:58:26,020 --> 01:58:31,480
now they're also used in in critical

01:58:28,510 --> 01:58:34,120
applications people companies are

01:58:31,480 --> 01:58:35,770
looking at taking you can debate this

01:58:34,120 --> 01:58:37,150
this is a good idea or not but companies

01:58:35,770 --> 01:58:41,170
are doing this and they're looking at

01:58:37,150 --> 01:58:44,080
taking say five old SOCC used to have

01:58:41,170 --> 01:58:46,390
condensing them down to one bigger chip

01:58:44,080 --> 01:58:49,870
putting a hypervisor on and pinning each

01:58:46,390 --> 01:58:52,780
old legacy application to a cpu I see

01:58:49,870 --> 01:58:54,760
some weird faces but you can you can

01:58:52,780 --> 01:58:58,240
think what you want about that but it is

01:58:54,760 --> 01:59:00,520
happening so and then just Zanon ki mu k

01:58:58,240 --> 01:59:04,960
vm are well-known open source hypervisor

01:59:00,520 --> 01:59:08,320
so risk v does have a hypervisor spec

01:59:04,960 --> 01:59:10,930
it's been worked on by sci-fi pretty

01:59:08,320 --> 01:59:13,480
much other guys behind it

01:59:10,930 --> 01:59:16,300
and they released a version 0.2 draft

01:59:13,480 --> 01:59:21,220
recently which took some feedback from

01:59:16,300 --> 01:59:24,520
the KTM guys so comparable to some other

01:59:21,220 --> 01:59:27,820
RISC architectures it's not kind of

01:59:24,520 --> 01:59:31,030
stepped up the way other ones do it it's

01:59:27,820 --> 01:59:32,680
more like a side split and so you can

01:59:31,030 --> 01:59:34,630
see here in this picture it's basically

01:59:32,680 --> 01:59:37,930
V mode and which is virtualization mode

01:59:34,630 --> 01:59:41,220
and not virtualization mode always it's

01:59:37,930 --> 01:59:43,360
happening but so the zoom mode

01:59:41,220 --> 01:59:45,460
hypervisor supervisor mode which is

01:59:43,360 --> 01:59:47,019
where your hypervisor around so Zen or

01:59:45,460 --> 01:59:49,809
KTM

01:59:47,019 --> 01:59:52,149
and then vs mode which is your virtual

01:59:49,809 --> 01:59:56,109
supervisor and virtual you which should

01:59:52,149 --> 01:59:59,919
be vehicles one so the point of this is

01:59:56,109 --> 02:00:03,519
that you can start your Linux guest in

01:59:59,919 --> 02:00:05,769
up and then later start KVM without

02:00:03,519 --> 02:00:07,599
having a deal with some of the hassles

02:00:05,769 --> 02:00:09,939
that that arm has where you have to kind

02:00:07,599 --> 02:00:16,899
of breach back into a previous exception

02:00:09,939 --> 02:00:18,719
level so this was the case yeah that was

02:00:16,899 --> 02:00:22,269
the case and until I got one from them

02:00:18,719 --> 02:00:24,010
have improved it since yes but maybe

02:00:22,269 --> 02:00:27,459
we're trying to start without that

02:00:24,010 --> 02:00:30,489
problem based out of it in a dollar and

02:00:27,459 --> 02:00:32,469
so then M mode is always not virtualized

02:00:30,489 --> 02:00:37,119
and motors always expect it to be your

02:00:32,469 --> 02:00:39,159
firmware so the risk five high fives

02:00:37,119 --> 02:00:42,399
extension is part of this adds some

02:00:39,159 --> 02:00:44,949
hypervisor CSR's it's pretty standard

02:00:42,399 --> 02:00:48,309
it's things to control the traps and

02:00:44,949 --> 02:00:52,059
stuff like that but only the hypervisor

02:00:48,309 --> 02:00:55,239
can access which makes sense add

02:00:52,059 --> 02:00:58,989
background CSRs so when you swap between

02:00:55,239 --> 02:01:01,239
virtual and not virtual your background

02:00:58,989 --> 02:01:03,309
in your foreground CSRs swap that's

02:01:01,239 --> 02:01:05,829
handled by the hardware and the

02:01:03,309 --> 02:01:08,469
hypervisor can edit its own and its

02:01:05,829 --> 02:01:12,159
guests so the hypervisor can set

02:01:08,469 --> 02:01:14,219
everything up some extra fence

02:01:12,159 --> 02:01:18,489
instructions to stage address the

02:01:14,219 --> 02:01:20,799
address translation and it's pretty much

02:01:18,489 --> 02:01:23,379
it and the M mode gets more information

02:01:20,799 --> 02:01:29,439
about what the virtualization state was

02:01:23,379 --> 02:01:32,769
when it's trapped too and so that's why

02:01:29,439 --> 02:01:35,289
it's my last slide so all the traps door

02:01:32,769 --> 02:01:36,579
to machine mode so kind of like

02:01:35,289 --> 02:01:38,649
everyone's talking about the SBI stuff

02:01:36,579 --> 02:01:41,049
whatever is in the firmware is gonna

02:01:38,649 --> 02:01:44,139
have to understand what's going on here

02:01:41,049 --> 02:01:45,459
because in risk five traps will always

02:01:44,139 --> 02:01:47,769
go to machine mode unless has been

02:01:45,459 --> 02:01:50,709
delegated up to a higher mode so you

02:01:47,769 --> 02:01:55,510
don't look at people looking confused

02:01:50,709 --> 02:01:57,669
but yeah so so you can it doesn't have

02:01:55,510 --> 02:01:59,859
to go to mo but mo you can set up the

02:01:57,669 --> 02:02:03,359
trap to delegate up the Emer has to be

02:01:59,859 --> 02:02:03,359
aware to have done that already

02:02:03,510 --> 02:02:07,149
so make sense and then and then the

02:02:05,769 --> 02:02:09,369
hypervisor I can do the same thing and

02:02:07,149 --> 02:02:11,169
so you don't have to trap through the

02:02:09,369 --> 02:02:14,979
hypervisor but the hypervisor has to

02:02:11,169 --> 02:02:16,659
have already set up not to trap right

02:02:14,979 --> 02:02:19,510
does does it mean that if you switch

02:02:16,659 --> 02:02:25,169
between host and guest modes you need to

02:02:19,510 --> 02:02:28,389
change that delegation as well so you

02:02:25,169 --> 02:02:32,260
imagine a breeze five k vm set up yeah

02:02:28,389 --> 02:02:35,789
so you run some stuff on the host the

02:02:32,260 --> 02:02:39,849
host can call into the firmware using

02:02:35,789 --> 02:02:42,669
ecole yeah now you start running a guest

02:02:39,849 --> 02:02:45,249
and you want the hypervisor to now be in

02:02:42,669 --> 02:02:47,589
charge of the same course it means you

02:02:45,249 --> 02:02:52,779
need to go to your firmware and to ask

02:02:47,589 --> 02:02:54,239
it to delegate the tribe exception to

02:02:52,779 --> 02:02:57,329
your hypervisor

02:02:54,239 --> 02:03:02,289
yes I think it's not fun that's all I

02:02:57,329 --> 02:03:05,619
think it's really not fun so it's

02:03:02,289 --> 02:03:08,079
anything yeah so but generally emerge

02:03:05,619 --> 02:03:11,919
will propagate up anything that it

02:03:08,079 --> 02:03:14,769
already doesn't want to deal with so

02:03:11,919 --> 02:03:20,919
think of something like we have on PS CI

02:03:14,769 --> 02:03:22,599
where we can bring on and off a CPU you

02:03:20,919 --> 02:03:27,389
want the same interface for your guest

02:03:22,599 --> 02:03:27,389
it brings on and and offer virtual CPU

02:03:27,599 --> 02:03:33,010
yeah it means if you if you consider

02:03:30,669 --> 02:03:35,139
that it's the same interface I mean M

02:03:33,010 --> 02:03:36,909
mode in your case will want to see that

02:03:35,139 --> 02:03:38,499
except when you run the guest when you

02:03:36,909 --> 02:03:40,719
want the hypervisor to destroy mode

02:03:38,499 --> 02:03:43,149
knows if the trap came from virtual or

02:03:40,719 --> 02:03:49,209
not perform right so you know as if it

02:03:43,149 --> 02:03:51,699
was a guest or not a guest okay so that

02:03:49,209 --> 02:03:55,209
was my last slide so I wanted to see

02:03:51,699 --> 02:03:58,559
what people thought comments and then

02:03:55,209 --> 02:03:58,559
what the next steps would be

02:04:08,420 --> 02:04:14,850
so for example how do you visualize

02:04:10,680 --> 02:04:18,540
interruptus it's a it's pretty when you

02:04:14,850 --> 02:04:22,460
say user-mode in drugs is that you mean

02:04:18,540 --> 02:04:26,100
emulating interrupts from user space or

02:04:22,460 --> 02:04:27,570
how are you going to to virtualize or

02:04:26,100 --> 02:04:29,480
interrupts because i haven't seen any

02:04:27,570 --> 02:04:34,260
anything that looked like

02:04:29,480 --> 02:04:38,160
intellectualization so in the risk v

02:04:34,260 --> 02:04:39,870
spec and is a land there are not there

02:04:38,160 --> 02:04:44,219
what interrupts are not extensively

02:04:39,870 --> 02:04:46,230
coupled to the I say so there are three

02:04:44,219 --> 02:04:47,670
interrupts defined by that I say right

02:04:46,230 --> 02:04:49,770
there's a timer up to software owner up

02:04:47,670 --> 02:04:51,930
and then an external interrupts and all

02:04:49,770 --> 02:04:54,450
other interrupts are shimmed through the

02:04:51,930 --> 02:04:56,390
external interrupts line basically at

02:04:54,450 --> 02:04:58,739
the first level the cpu so

02:04:56,390 --> 02:05:00,390
virtualization of interrupts is really

02:04:58,739 --> 02:05:02,310
something that requires doing a better

02:05:00,390 --> 02:05:06,989
platform level interrupt controller

02:05:02,310 --> 02:05:09,210
design then the is a mandated interrupt

02:05:06,989 --> 02:05:11,100
controller stuff if that makes sense

02:05:09,210 --> 02:05:13,650
virtualizing the is a interrupts doesn't

02:05:11,100 --> 02:05:16,080
get you very far the hypervisor

02:05:13,650 --> 02:05:18,300
extension doesn't talk about them at all

02:05:16,080 --> 02:05:21,300
yeah we're trying to decouple the inner

02:05:18,300 --> 02:05:22,739
controller from the is a basically see

02:05:21,300 --> 02:05:24,239
you mentioned just there you had three

02:05:22,739 --> 02:05:26,520
in tropes that whatever at the timer

02:05:24,239 --> 02:05:28,230
interrupts and get one right so the

02:05:26,520 --> 02:05:29,760
timer interrupts is defined by that so

02:05:28,230 --> 02:05:34,260
you know how do you visualize the timer

02:05:29,760 --> 02:05:37,410
interrupts and the timer so the timer

02:05:34,260 --> 02:05:38,880
interrupts is set on by a comparator and

02:05:37,410 --> 02:05:40,830
so there's a time of the tics and a

02:05:38,880 --> 02:05:42,510
comparator to just one shot all right so

02:05:40,830 --> 02:05:45,000
how does the hypervisor use the time of

02:05:42,510 --> 02:05:47,160
all the guest is using the timer so

02:05:45,000 --> 02:05:49,140
there are separate timer registers for

02:05:47,160 --> 02:05:50,640
each privilege level okay and therefore

02:05:49,140 --> 02:05:52,080
separate timer interrupts reach

02:05:50,640 --> 02:05:54,930
privilege level now unfortunately in the

02:05:52,080 --> 02:06:00,630
current implementations there's a trick

02:05:54,930 --> 02:06:03,390
and they're all yeah mixed up but that

02:06:00,630 --> 02:06:04,590
is an implementation problem yeah

02:06:03,390 --> 02:06:06,480
basically any right to any the timer

02:06:04,590 --> 02:06:08,489
registers or any read or write traps to

02:06:06,480 --> 02:06:10,650
machine mode and then there's a but

02:06:08,489 --> 02:06:11,880
that's an implantation problem and

02:06:10,650 --> 02:06:13,650
basically cuz we don't have the systems

02:06:11,880 --> 02:06:15,939
with you know there's no hypervisor spec

02:06:13,650 --> 02:06:17,679
so there's no hypervisor running so

02:06:15,939 --> 02:06:21,059
who cares how fast virtual addition of

02:06:17,679 --> 02:06:21,059
timers goes that can be fixed

02:06:21,900 --> 02:06:26,409
sounds like maybe the cross core

02:06:24,400 --> 02:06:28,209
interrupts are not standardized in a

02:06:26,409 --> 02:06:29,349
platform if you leave in the

02:06:28,209 --> 02:06:30,880
architecture if you leave that to

02:06:29,349 --> 02:06:32,439
platform dependent stuff you're going to

02:06:30,880 --> 02:06:33,999
have to hide down behind drivers or

02:06:32,439 --> 02:06:36,369
firmware and that's not good for an

02:06:33,999 --> 02:06:38,530
operating system so you know multi-core

02:06:36,369 --> 02:06:42,099
ways to until these shutdowns or other

02:06:38,530 --> 02:06:43,900
things wants to be able to talk to crowd

02:06:42,099 --> 02:06:46,349
CPU interrupts very efficiently that

02:06:43,900 --> 02:06:49,860
should be in the architecture somewhere

02:06:46,349 --> 02:06:54,550
yeah yeah so right now SBI has IP eyes

02:06:49,860 --> 02:06:56,499
TLB shoot downs we don't quite like the

02:06:54,550 --> 02:07:00,639
interface so it's going in the legacy

02:06:56,499 --> 02:07:02,709
pile and the plan is to do a better

02:07:00,639 --> 02:07:04,900
platform level interrupt controller as

02:07:02,709 --> 02:07:06,489
part of the platform specification that

02:07:04,900 --> 02:07:07,360
it's something we can actually help get

02:07:06,489 --> 02:07:09,429
behind in sports

02:07:07,360 --> 02:07:11,349
virtualization basically and then

02:07:09,429 --> 02:07:12,550
efficient delivery of things like

02:07:11,349 --> 02:07:15,999
software interrupts to do remote the

02:07:12,550 --> 02:07:18,340
stuff they requires sitting down and

02:07:15,999 --> 02:07:20,019
thinking about it because it's we have

02:07:18,340 --> 02:07:22,559
one that we screwed up so we want to not

02:07:20,019 --> 02:07:22,559
screw up a second

02:07:27,539 --> 02:07:37,829
no one else is super worried that we're

02:07:30,360 --> 02:07:39,780
done something really wrong no sir

02:07:37,829 --> 02:07:40,949
so that's the other problem so we're

02:07:39,780 --> 02:07:42,989
kind of stuck in this problem where no

02:07:40,949 --> 02:07:44,969
one wants to ratify the spec until you

02:07:42,989 --> 02:07:48,300
get an invitation to make sure it kind

02:07:44,969 --> 02:07:50,329
of works so it looks like we'll have to

02:07:48,300 --> 02:07:53,659
do something Kim you it's probably

02:07:50,329 --> 02:07:55,980
unless the silicon company wants to make

02:07:53,659 --> 02:08:02,579
make a board with yeah I think we should

02:07:55,980 --> 02:08:04,619
do it in Kim yeah yeah and then see how

02:08:02,579 --> 02:08:08,010
cuz that was the problem say I'm happy

02:08:04,619 --> 02:08:10,199
is with $8 is then people started using

02:08:08,010 --> 02:08:12,659
it and keeping them realize it wasn't

02:08:10,199 --> 02:08:15,570
great for them and that can be fixed but

02:08:12,659 --> 02:08:18,179
I mean it's not that bad actually I mean

02:08:15,570 --> 02:08:20,039
if you look at the way KVM only eight

02:08:18,179 --> 02:08:23,059
old zero performs they put it's obvious

02:08:20,039 --> 02:08:25,349
in right yeah so we we go back we go we

02:08:23,059 --> 02:08:27,840
basically we delegate the number of

02:08:25,349 --> 02:08:30,059
things to two year - yeah - the

02:08:27,840 --> 02:08:33,630
hypervisor mode and and we switch over

02:08:30,059 --> 02:08:36,630
there in terms of performance yes it's

02:08:33,630 --> 02:08:37,769
it has some of ahead and it would have

02:08:36,630 --> 02:08:40,980
been better if we didn't have to do that

02:08:37,769 --> 02:08:43,170
on the other hand when you look

02:08:40,980 --> 02:08:48,840
performance wise it's not that bad at

02:08:43,170 --> 02:08:50,460
all it's actually quite good some some

02:08:48,840 --> 02:08:53,369
other exercises are done for the

02:08:50,460 --> 02:08:56,550
architectures is it just virtualizer

02:08:53,369 --> 02:08:58,769
will be a software without an excessive

02:08:56,550 --> 02:09:01,170
overhead so any architecture is virtual

02:08:58,769 --> 02:09:02,969
I suppose in software without great cost

02:09:01,170 --> 02:09:04,619
is a good start if there's anything in

02:09:02,969 --> 02:09:06,239
the architecture that is hard to to

02:09:04,619 --> 02:09:09,059
virtualize your software then that's

02:09:06,239 --> 02:09:11,190
maybe an area to improve as well so the

02:09:09,059 --> 02:09:15,719
user I say is classically virtualized

02:09:11,190 --> 02:09:16,710
basically no no holes as far as I know I

02:09:15,719 --> 02:09:19,289
think I don't think anyone's actually

02:09:16,710 --> 02:09:22,099
sat down it like proved that but it was

02:09:19,289 --> 02:09:22,099
intended to be that way

02:09:26,150 --> 02:09:29,600
okay

02:09:27,710 --> 02:09:31,940
also one other thing which is kind of

02:09:29,600 --> 02:09:34,550
nice is that when you enable this say if

02:09:31,940 --> 02:09:37,040
you do your USOC have a hypervisor

02:09:34,550 --> 02:09:39,590
extension you can bruton unmodeled

02:09:37,040 --> 02:09:41,930
should be out of an unmodified guest in

02:09:39,590 --> 02:09:45,110
in the hypervisor mode and so then later

02:09:41,930 --> 02:09:46,940
if you if you updated it and had KPM it

02:09:45,110 --> 02:09:49,790
was all it all ready in the same mode it

02:09:46,940 --> 02:09:52,630
doesn't have to run in in not

02:09:49,790 --> 02:09:52,630
virtualization with

02:09:57,850 --> 02:10:09,430
this one day that one day this is this

02:10:04,270 --> 02:10:14,140
way tangental BMC or IPM I are these

02:10:09,430 --> 02:10:16,420
interesting to risk five platform IP

02:10:14,140 --> 02:10:19,350
mine what was the puzzle is about BMC

02:10:16,420 --> 02:10:22,210
I'm going to connect a few dots

02:10:19,350 --> 02:10:25,810
something which is above and outside the

02:10:22,210 --> 02:10:29,880
CPU is a hypervisor in the same way the

02:10:25,810 --> 02:10:32,190
BMC is above and and around the platform

02:10:29,880 --> 02:10:36,430
so I'm interested have you thought about

02:10:32,190 --> 02:10:38,440
how BMC interacts with the system I

02:10:36,430 --> 02:10:43,150
don't know if that's you but I'm asking

02:10:38,440 --> 02:10:46,950
a general question that would be a mode

02:10:43,150 --> 02:10:46,950
B doing that right or not

02:10:53,269 --> 02:11:02,999
so I think you're asking does the

02:10:57,059 --> 02:11:06,479
hypervisor need the BMC I'm again trying

02:11:02,999 --> 02:11:08,519
to talk about a meta level that the

02:11:06,479 --> 02:11:11,760
hypervisors function is to allow

02:11:08,519 --> 02:11:16,559
multiple OSS to run in the same way you

02:11:11,760 --> 02:11:19,229
have multiple sockets then you want the

02:11:16,559 --> 02:11:21,630
whole system to community communicate so

02:11:19,229 --> 02:11:26,459
virtualizing the interface to the board

02:11:21,630 --> 02:11:28,199
the IPMI is an idea that I think could

02:11:26,459 --> 02:11:30,869
deserve some thought I don't know

02:11:28,199 --> 02:11:33,409
whether it's an interesting application

02:11:30,869 --> 02:11:35,880
use case that people are thinking about

02:11:33,409 --> 02:11:37,439
but I think you know we were talking

02:11:35,880 --> 02:11:39,360
about things that are all the way down

02:11:37,439 --> 02:11:41,309
to microcontroller land and we had a

02:11:39,360 --> 02:11:44,729
very interesting talk about high

02:11:41,309 --> 02:11:46,709
performance compute so the implication

02:11:44,729 --> 02:11:50,039
that someone had made about thinking

02:11:46,709 --> 02:11:53,699
about at risk five new architecture as a

02:11:50,039 --> 02:11:55,409
way of thinking like universal

02:11:53,699 --> 02:11:57,899
intermediate representation kind of the

02:11:55,409 --> 02:12:00,510
way of the world if you can design a new

02:11:57,899 --> 02:12:03,809
system such that it is able to

02:12:00,510 --> 02:12:08,309
characterize all old systems it makes it

02:12:03,809 --> 02:12:11,789
much more useful going forward to leave

02:12:08,309 --> 02:12:16,010
out the whole idea of BMC into finding a

02:12:11,789 --> 02:12:20,030
new platform I think would be not wise

02:12:16,010 --> 02:12:28,520
so somebody should be thinking about her

02:12:20,030 --> 02:12:30,679
I think I was just gonna say one trivial

02:12:28,520 --> 02:12:32,630
thing obviously in your boot

02:12:30,679 --> 02:12:35,360
specification you will absolutely need

02:12:32,630 --> 02:12:38,420
to specify entering this hypervisor mode

02:12:35,360 --> 02:12:41,270
and all the architected state that it's

02:12:38,420 --> 02:12:42,829
necessary for that to operate as if you

02:12:41,270 --> 02:12:45,099
didn't have hypervisor mode if you have

02:12:42,829 --> 02:12:48,949
older software that was not targeting it

02:12:45,099 --> 02:12:50,510
and you need to consider what so you

02:12:48,949 --> 02:12:52,429
mentioned you can run software which was

02:12:50,510 --> 02:12:55,969
not aware of running in this hypervisor

02:12:52,429 --> 02:12:57,349
mode in the hypervisor mode yeah but

02:12:55,969 --> 02:13:01,699
there is some state that it will not

02:12:57,349 --> 02:13:03,739
know about there's one there's some

02:13:01,699 --> 02:13:07,909
states they will not know about like the

02:13:03,739 --> 02:13:10,010
new trap controls and whatever yeah so

02:13:07,909 --> 02:13:12,619
any when you add this you will need to

02:13:10,010 --> 02:13:14,329
add bits to your boot protocol it's

02:13:12,619 --> 02:13:16,400
about your specification how you boop to

02:13:14,329 --> 02:13:18,199
say how those are initialized out of

02:13:16,400 --> 02:13:20,659
reset that you apps that you boot into

02:13:18,199 --> 02:13:27,770
this mode rather than the mode below it

02:13:20,659 --> 02:13:32,230
and so on okay so it sounds like we need

02:13:27,770 --> 02:13:32,230
to queue implantation I think

02:13:37,090 --> 02:13:48,450
all right that's it thank ya speaker

02:13:46,090 --> 02:13:48,450
gifts

02:17:34,530 --> 02:17:39,900
and I think especially

02:18:10,530 --> 02:18:17,469
okay hello everyone I am Ellen and this

02:18:15,219 --> 02:18:18,880
is my colleague song and we are from

02:18:17,469 --> 02:18:21,760
Andy's technology

02:18:18,880 --> 02:18:25,689
and sorry for the I'm apologize for the

02:18:21,760 --> 02:18:28,899
vague title because it seems to not

02:18:25,689 --> 02:18:32,080
precise in but actually we do this on

02:18:28,899 --> 02:18:35,830
purpose because we have several small

02:18:32,080 --> 02:18:38,830
topics rather than previous discussions

02:18:35,830 --> 02:18:42,569
you present it like you focus on some

02:18:38,830 --> 02:18:47,349
fundamental problems and requires many

02:18:42,569 --> 02:18:51,849
details and aspects and we here we have

02:18:47,349 --> 02:18:56,099
some feature oriented topics so but but

02:18:51,849 --> 02:18:58,769
there is a few of them and okay anyway

02:18:56,099 --> 02:19:02,319
first of all please allow me to

02:18:58,769 --> 02:19:08,019
introduce our company to you we are a

02:19:02,319 --> 02:19:12,219
company in Taiwan and we since 2005 and

02:19:08,019 --> 02:19:16,380
we went public last year and also as we

02:19:12,219 --> 02:19:22,090
went public we also announced our our

02:19:16,380 --> 02:19:25,300
project to to support risk 5 bass CPU IP

02:19:22,090 --> 02:19:30,130
and we are a pure play IP vendor and we

02:19:25,300 --> 02:19:34,870
have about over 140 I census and we now

02:19:30,130 --> 02:19:38,639
support it over 2.5 billion and these

02:19:34,870 --> 02:19:44,139
embedded SOC we support various

02:19:38,639 --> 02:19:49,030
applications and and and needs basically

02:19:44,139 --> 02:19:53,590
the those reading written in a slide and

02:19:49,030 --> 02:19:57,490
we have call name called nd star p5 this

02:19:53,590 --> 02:20:03,300
is our risk 5 coin and we this is

02:19:57,490 --> 02:20:06,430
basically with 5 32-bit and 64-bit and

02:20:03,300 --> 02:20:09,250
either floating point or not those

02:20:06,430 --> 02:20:11,590
combinations with our own specific and

02:20:09,250 --> 02:20:15,790
these extensions and support

02:20:11,590 --> 02:20:24,250
the device is shown in this the this

02:20:15,790 --> 02:20:29,290
figures and okay let's go into all I

02:20:24,250 --> 02:20:32,320
hear so there will be a few topics here

02:20:29,290 --> 02:20:38,170
and I will go through them and each of

02:20:32,320 --> 02:20:44,710
them contains three or four slices and I

02:20:38,170 --> 02:20:46,990
will pause after each completed okay so

02:20:44,710 --> 02:20:50,530
the first one is the performance counter

02:20:46,990 --> 02:20:55,270
that that is basically for been exposed

02:20:50,530 --> 02:20:58,420
to work two fundamental mechanisms so

02:20:55,270 --> 02:21:03,010
what we have now we have we now have a

02:20:58,420 --> 02:21:06,550
preliminary perf support by preliminary

02:21:03,010 --> 02:21:10,120
I mean if you want to just counting you

02:21:06,550 --> 02:21:12,220
just want to count a program and when a

02:21:10,120 --> 02:21:15,910
program runs and you want to count how

02:21:12,220 --> 02:21:19,690
much cycles it was it is okay but if you

02:21:15,910 --> 02:21:24,250
want to do the sampling it is currently

02:21:19,690 --> 02:21:28,150
not able you are not able to do this let

02:21:24,250 --> 02:21:31,510
me explain why so for example if you

02:21:28,150 --> 02:21:35,710
want to profile this program the OS and

02:21:31,510 --> 02:21:40,810
this perfect record means that you want

02:21:35,710 --> 02:21:43,360
to see every 1000 cycles which

02:21:40,810 --> 02:21:45,820
instruction it runs into so this is

02:21:43,360 --> 02:21:48,550
basically sampling yep

02:21:45,820 --> 02:21:53,290
for firing things and this is the flow

02:21:48,550 --> 02:21:59,290
chart so first you will you want to set

02:21:53,290 --> 02:22:01,990
a psycho register to a specific value in

02:21:59,290 --> 02:22:06,930
this case it is the maximum value of

02:22:01,990 --> 02:22:09,940
this register minus 100 because so that

02:22:06,930 --> 02:22:13,570
once you start this program and you

02:22:09,940 --> 02:22:17,020
always start this counter to two ROM and

02:22:13,570 --> 02:22:19,990
then once the register overflow it

02:22:17,020 --> 02:22:22,660
trigger a interrupt the interrupt you

02:22:19,990 --> 02:22:24,761
can catch that intervene in the handler

02:22:22,660 --> 02:22:29,980
you can stop the

02:22:24,761 --> 02:22:32,561
and record related data such as that at

02:22:29,980 --> 02:22:35,620
the time the the instruction instruction

02:22:32,561 --> 02:22:39,521
pointer and something like that so

02:22:35,620 --> 02:22:43,330
basically this loop goes and until until

02:22:39,521 --> 02:22:48,511
the program ends and there are some

02:22:43,330 --> 02:22:53,891
limitations here in this five we want to

02:22:48,511 --> 02:22:58,271
fight if we are sure that we have we

02:22:53,891 --> 02:23:03,341
only want to support one Linux 101 OS

02:22:58,271 --> 02:23:08,110
then we hope that we can directly write

02:23:03,341 --> 02:23:12,000
to this register but currently we cannot

02:23:08,110 --> 02:23:15,221
just write to these performance counters

02:23:12,000 --> 02:23:18,881
without SBI code because they are all

02:23:15,221 --> 02:23:21,190
and mode registers and this is this is

02:23:18,881 --> 02:23:25,601
the first limitation and of course you

02:23:21,190 --> 02:23:29,261
can add a spi call but we we argue that

02:23:25,601 --> 02:23:35,771
this my introduced too much overhead and

02:23:29,261 --> 02:23:38,711
we have a solution we want to add a new

02:23:35,771 --> 02:23:43,990
register called encounter write enable

02:23:38,711 --> 02:23:47,820
so that once this is this is enabled in

02:23:43,990 --> 02:23:51,971
the end mode so and then the a small

02:23:47,820 --> 02:23:55,290
that is Linux you can directly write the

02:23:51,971 --> 02:24:02,801
counters and perform encountered related

02:23:55,290 --> 02:24:05,200
those control registers sorry you cannot

02:24:02,801 --> 02:24:07,990
fast me here because in your flow chart

02:24:05,200 --> 02:24:09,761
you said when you counter overflows you

02:24:07,990 --> 02:24:12,221
get an interrupt and you handle that in

02:24:09,761 --> 02:24:14,711
the interrupt handler which means that

02:24:12,221 --> 02:24:18,221
you have a driver for your thing for the

02:24:14,711 --> 02:24:20,500
counter so why need a new register you

02:24:18,221 --> 02:24:27,730
only need an API into your kernel driver

02:24:20,500 --> 02:24:31,601
to set your Mac cycle and that's it I am

02:24:27,730 --> 02:24:34,750
kind of lost the state for the device

02:24:31,601 --> 02:24:36,881
lives in a mode CSR and a mode CSR's

02:24:34,750 --> 02:24:39,710
cannot be written from ass mode

02:24:36,881 --> 02:24:41,750
if it was memory-mapped it would be

02:24:39,710 --> 02:24:43,040
fixed but that's not how the like

02:24:41,750 --> 02:24:47,511
there's already a spot for it in the

02:24:43,040 --> 02:24:52,221
spec so it's just kind of yeah thanks

02:24:47,511 --> 02:24:55,940
and then the the second limitation is

02:24:52,221 --> 02:25:05,061
the the ability to pause and resume a

02:24:55,940 --> 02:25:08,841
counter we currently cannot a sorry for

02:25:05,061 --> 02:25:12,290
title I I want to add let's forget the

02:25:08,841 --> 02:25:15,681
title I here I want to say is perfect as

02:25:12,290 --> 02:25:18,410
a ability that you can you can profile

02:25:15,681 --> 02:25:23,301
certain levels for example you can just

02:25:18,410 --> 02:25:26,960
profile user level or or in kernel level

02:25:23,301 --> 02:25:30,381
or posts and for now we don't have such

02:25:26,960 --> 02:25:35,960
mechanism to select the these levels so

02:25:30,381 --> 02:25:36,710
and here there is no no solutions we can

02:25:35,960 --> 02:25:40,400
come up with

02:25:36,710 --> 02:25:43,311
so we basically also introduced new

02:25:40,400 --> 02:25:47,230
registers and here it is

02:25:43,311 --> 02:25:50,750
a skeleton mask we want a mask to to

02:25:47,230 --> 02:25:53,660
guide the performance counter how it

02:25:50,750 --> 02:26:01,881
should count in different privilege

02:25:53,660 --> 02:26:04,910
levels yes the privilege spec already

02:26:01,881 --> 02:26:07,910
have bunch of hardware specific register

02:26:04,910 --> 02:26:10,030
are they only read only bobbin a

02:26:07,910 --> 02:26:12,740
privilege spec already have a bunch of

02:26:10,030 --> 02:26:14,780
hardware dependent like a platform

02:26:12,740 --> 02:26:17,240
dependent or Hardware dependent register

02:26:14,780 --> 02:26:19,940
which the vendor can use are they only

02:26:17,240 --> 02:26:23,440
read are they read only like can we not

02:26:19,940 --> 02:26:23,440
use them to do this thing

02:26:26,450 --> 02:26:33,470
we don't have such CSRs we want to only

02:26:30,260 --> 02:26:39,260
count for further for example you want

02:26:33,470 --> 02:26:42,200
to count user space activity and then so

02:26:39,260 --> 02:26:44,720
but but at the counter the Pavan calls

02:26:42,200 --> 02:26:48,229
that just keep running so you have to

02:26:44,720 --> 02:26:51,439
there must be some switch to decide or

02:26:48,229 --> 02:26:53,420
or mask to desire which level to so we

02:26:51,439 --> 02:26:54,680
have now profound cycle count

02:26:53,420 --> 02:27:01,270
instruction count and then there are

02:26:54,680 --> 02:27:01,270
like 10 or 20 yeah so can we just be

02:27:03,189 --> 02:27:12,950
okay actually we would like to suggest

02:27:09,530 --> 02:27:15,710
these features to be added into generic

02:27:12,950 --> 02:27:32,240
ones ok so that the perf will be more

02:27:15,710 --> 02:27:35,450
usable ok ok this is the second

02:27:32,240 --> 02:27:37,430
limitation and the sir one is what what

02:27:35,450 --> 02:27:40,370
title says is a pause and resume because

02:27:37,430 --> 02:27:44,540
we currently we have specific counters

02:27:40,370 --> 02:27:46,939
which is building one in psycho and and

02:27:44,540 --> 02:27:48,770
the instruction retired and these

02:27:46,939 --> 02:27:51,350
counters just free wrong all the time

02:27:48,770 --> 02:27:54,200
so there are two drawbacks one is that

02:27:51,350 --> 02:27:57,400
you cannot for power saving purpose you

02:27:54,200 --> 02:28:00,979
cannot post it if you don't want it and

02:27:57,400 --> 02:28:06,860
the other the other drawback is is in

02:28:00,979 --> 02:28:09,710
this normal perf workflow we we actually

02:28:06,860 --> 02:28:12,470
need just as other architectures need

02:28:09,710 --> 02:28:15,650
they they need to start a counter or

02:28:12,470 --> 02:28:20,080
stop a counter to remain precise of

02:28:15,650 --> 02:28:23,870
these profiling process so this is a

02:28:20,080 --> 02:28:26,960
third limitation and it we currently do

02:28:23,870 --> 02:28:29,840
some hack with just mask so basically

02:28:26,960 --> 02:28:34,640
you can just mask how all the privilege

02:28:29,840 --> 02:28:37,090
level to indicate a stop or you can you

02:28:34,640 --> 02:28:41,561
have to say the state or whatever things

02:28:37,090 --> 02:28:44,410
anyway there should be a

02:28:41,561 --> 02:28:48,170
specific register for this desk to

02:28:44,410 --> 02:28:52,900
enable to pass or to resume okay

02:28:48,170 --> 02:28:54,640
and the fourth limitation is the

02:28:52,900 --> 02:28:59,030
interrupts

02:28:54,640 --> 02:29:04,190
we don't have according to this back we

02:28:59,030 --> 02:29:07,521
don't know how to do do this - and they

02:29:04,190 --> 02:29:13,700
interrupt for the counter overflow event

02:29:07,521 --> 02:29:18,021
so we must need that and and except for

02:29:13,700 --> 02:29:21,561
that we still need other mechanisms such

02:29:18,021 --> 02:29:26,200
as you have to there should be a mask to

02:29:21,561 --> 02:29:29,180
indicate which counter has already

02:29:26,200 --> 02:29:36,580
overflow so here are some creative

02:29:29,180 --> 02:29:41,210
registers and in summary this perf part

02:29:36,580 --> 02:29:45,470
we have some phasers call this will be

02:29:41,210 --> 02:29:50,030
with list limitations and possible

02:29:45,470 --> 02:29:54,230
solutions we yet just as you see and we

02:29:50,030 --> 02:29:56,840
propose some useful solutions we hope

02:29:54,230 --> 02:30:00,190
that this is not only a and this

02:29:56,840 --> 02:30:03,530
extension but we hope that this can be

02:30:00,190 --> 02:30:08,680
generic enable the baseline PN you

02:30:03,530 --> 02:30:12,440
enable things okay so any comment

02:30:08,680 --> 02:30:14,360
so have you proposed that to the

02:30:12,440 --> 02:30:18,170
foundation to this describe to the

02:30:14,360 --> 02:30:22,430
specification is it work ongoing not yet

02:30:18,170 --> 02:30:24,021
we just propose here and see how yeah I

02:30:22,430 --> 02:30:27,800
think you should propose it I know the

02:30:24,021 --> 02:30:30,860
counter mask specifically that is in the

02:30:27,800 --> 02:30:32,720
debug spec so there is ad counter mask

02:30:30,860 --> 02:30:34,640
though the exact semantics of the CSM

02:30:32,720 --> 02:30:35,390
are slightly different but the data path

02:30:34,640 --> 02:30:37,820
is already there

02:30:35,390 --> 02:30:39,110
so that seems like an admission from the

02:30:37,820 --> 02:30:41,960
privileged spec that it just kind of

02:30:39,110 --> 02:30:43,490
didn't suck up the debug spec okay right

02:30:41,960 --> 02:30:45,320
and then the other two seem like

02:30:43,490 --> 02:30:48,710
reasonable things exactly how to make it

02:30:45,320 --> 02:30:50,601
yeah okay that's all the groups are for

02:30:48,710 --> 02:30:52,190
right it seems like reasonable things to

02:30:50,601 --> 02:30:53,560
propose certainly there holes in the

02:30:52,190 --> 02:30:59,569
spec

02:30:53,560 --> 02:31:02,629
okay so let's get into the second part

02:30:59,569 --> 02:31:05,659
this elf attribute this turn must be a

02:31:02,629 --> 02:31:11,029
little bit maybe strange two years old

02:31:05,659 --> 02:31:14,899
let me explain this let me explain the

02:31:11,029 --> 02:31:18,499
need first as in the foreseeable future

02:31:14,899 --> 02:31:21,259
these five platforms with number of risk

02:31:18,499 --> 02:31:25,100
five platforms increases and the elf

02:31:21,259 --> 02:31:31,279
objects libraries executables increases

02:31:25,100 --> 02:31:33,609
as well so how should a how how should

02:31:31,279 --> 02:31:38,539
tools between these two kinds of things

02:31:33,609 --> 02:31:43,279
to decide how to use those objects for

02:31:38,539 --> 02:31:50,989
example for this assembler for example

02:31:43,279 --> 02:31:53,569
just like objdump minus D this it we

02:31:50,989 --> 02:31:57,859
want to know that how how should it

02:31:53,569 --> 02:32:00,589
interpret if it gets a elf object how

02:31:57,859 --> 02:32:03,379
can it interpret it because if there are

02:32:00,589 --> 02:32:06,409
many different extensions and include

02:32:03,379 --> 02:32:10,989
many different constants CSR's or custom

02:32:06,409 --> 02:32:13,959
instructions it is a problem how to

02:32:10,989 --> 02:32:17,449
interpret those things correctly and

02:32:13,959 --> 02:32:20,209
linker and loader is much of our

02:32:17,449 --> 02:32:24,829
interest because loader decides how

02:32:20,209 --> 02:32:30,589
those executables to be issued is good

02:32:24,829 --> 02:32:36,919
so they are basically two loaders is we

02:32:30,589 --> 02:32:40,249
are our interest the loader in Linux do

02:32:36,919 --> 02:32:44,299
is the target executable and if it is

02:32:40,249 --> 02:32:47,329
dynamic linked then the dynamic linker

02:32:44,299 --> 02:32:51,020
as well and the time I pick the dynamic

02:32:47,329 --> 02:32:54,589
linker resides in the C library so it

02:32:51,020 --> 02:33:01,699
deal with libraries that need it by that

02:32:54,589 --> 02:33:06,710
target executable so let me show you two

02:33:01,699 --> 02:33:13,640
scenarios here for example if you have a

02:33:06,710 --> 02:33:18,140
with five 32-bit platform and and you

02:33:13,640 --> 02:33:22,490
want to load a 64-bit executable this is

02:33:18,140 --> 02:33:26,420
a actually you can do this by existing

02:33:22,490 --> 02:33:28,670
elf header to decide to load it or not

02:33:26,420 --> 02:33:32,000
but this is just to indicate a kind of

02:33:28,670 --> 02:33:37,450
situation and the other one is if you

02:33:32,000 --> 02:33:43,190
have a platform it has a non-standard

02:33:37,450 --> 02:33:47,780
extension AAA and somehow the target

02:33:43,190 --> 02:33:50,230
executable it also it was also compiled

02:33:47,780 --> 02:33:54,740
as say it's the same

02:33:50,230 --> 02:33:58,700
eisah but it somehow links to a wrong

02:33:54,740 --> 02:34:01,220
library and then at this time daughter

02:33:58,700 --> 02:34:04,730
can that the dynamic linker loader you

02:34:01,220 --> 02:34:09,650
can decide not to load this so to

02:34:04,730 --> 02:34:18,140
prevent to prevent further further parks

02:34:09,650 --> 02:34:22,760
or something so there are pre a here is

02:34:18,140 --> 02:34:25,970
a brief lock here kiddo is our compiler

02:34:22,760 --> 02:34:29,990
guy he raises this this proposal in

02:34:25,970 --> 02:34:34,640
March this year and he what he proposes

02:34:29,990 --> 02:34:41,440
that we should add a section a process a

02:34:34,640 --> 02:34:46,880
specific section in each elf files and

02:34:41,440 --> 02:34:48,470
any comment I'm thinking at the same

02:34:46,880 --> 02:34:52,940
time you're talking you know I'm seeing

02:34:48,470 --> 02:34:57,280
problems that's all and what this

02:34:52,940 --> 02:35:00,590
section should record should basically

02:34:57,280 --> 02:35:02,960
the the most important one is for either

02:35:00,590 --> 02:35:07,550
string the Augmented either string and

02:35:02,960 --> 02:35:10,700
and privileged suspect version and some

02:35:07,550 --> 02:35:16,120
other attributes and there has been some

02:35:10,700 --> 02:35:20,210
discussions on the forum and github

02:35:16,120 --> 02:35:26,479
about this 5l processor specific

02:35:20,210 --> 02:35:30,470
KBI documentation and some components P

02:35:26,479 --> 02:35:37,190
noodles and and GCC this is nearly done

02:35:30,470 --> 02:35:40,850
but this is currently in under ketose we

02:35:37,190 --> 02:35:45,080
our internal repository and then extent

02:35:40,850 --> 02:35:48,580
you'll ever see I will propose a big

02:35:45,080 --> 02:35:53,350
picture and we would need your feedback

02:35:48,580 --> 02:35:59,180
okay so I hope this is clear enough

02:35:53,350 --> 02:36:03,050
basically we want to pass the the

02:35:59,180 --> 02:36:07,150
compatible elf attribute in the from

02:36:03,050 --> 02:36:07,150
font device tree to the kernel so

02:36:07,210 --> 02:36:15,130
assuming this one I just mentioned that

02:36:11,410 --> 02:36:20,540
augmented as a string by which I mean

02:36:15,130 --> 02:36:26,600
sometimes you just say this 5 6 64 and I

02:36:20,540 --> 02:36:29,350
am afdc but too precise to be precise

02:36:26,600 --> 02:36:33,590
you have to also mention the version of

02:36:29,350 --> 02:36:37,760
each extensions because some of them may

02:36:33,590 --> 02:36:41,300
change over time of course the IMA FTC

02:36:37,760 --> 02:36:45,380
has been freeze has been frozen but some

02:36:41,300 --> 02:36:48,770
some may not for example L or Q or any

02:36:45,380 --> 02:36:54,440
further official extensions non official

02:36:48,770 --> 02:36:58,060
extensions so anyway kernel can get

02:36:54,440 --> 02:37:03,110
these informations from front EDS and

02:36:58,060 --> 02:37:06,350
the loader in kernel can then you can

02:37:03,110 --> 02:37:09,920
then it has to there has to be some

02:37:06,350 --> 02:37:14,479
there has to be a puzzle inside that

02:37:09,920 --> 02:37:16,760
loader and it can parse the section thus

02:37:14,479 --> 02:37:19,640
with the the elf attribute section from

02:37:16,760 --> 02:37:22,479
Target elf and compare that section the

02:37:19,640 --> 02:37:25,850
compare the content of that section with

02:37:22,479 --> 02:37:29,030
the information from the years then this

02:37:25,850 --> 02:37:33,980
is the first the first

02:37:29,030 --> 02:37:38,551
the first stage and the second stage is

02:37:33,980 --> 02:37:43,921
okay the second stage is it for take

02:37:38,551 --> 02:37:47,910
take the new JDBC as the example the L

02:37:43,921 --> 02:37:52,171
da da da so there is also a similar

02:37:47,910 --> 02:37:55,490
passer which which parts the require

02:37:52,171 --> 02:37:59,160
libraries elf attribute section and

02:37:55,490 --> 02:38:03,360
compare it with say the information

02:37:59,160 --> 02:38:06,091
passed from Colonel and how should

02:38:03,360 --> 02:38:09,511
Colonel pass this information we

02:38:06,091 --> 02:38:15,751
currently utilize the existing framework

02:38:09,511 --> 02:38:19,381
from auxiliary vector so this is the the

02:38:15,751 --> 02:38:22,320
big picture okay question okay

02:38:19,381 --> 02:38:23,730
how would that interact with things we

02:38:22,320 --> 02:38:29,070
this application for example that we

02:38:23,730 --> 02:38:31,740
explicitly open it is a more complicated

02:38:29,070 --> 02:38:34,381
scenario but it can be no it's it's

02:38:31,740 --> 02:38:36,721
actually a very common scenario and the

02:38:34,381 --> 02:38:39,181
problem is that since the application is

02:38:36,721 --> 02:38:41,221
really explicitly open knows what string

02:38:39,181 --> 02:38:44,700
is going to search for specific symbol

02:38:41,221 --> 02:38:46,831
in your library and with the application

02:38:44,700 --> 02:38:48,240
knowing what extension are actually

02:38:46,831 --> 02:38:51,030
available and your halwa is running on

02:38:48,240 --> 02:38:52,980
can choose to basically call different

02:38:51,030 --> 02:38:56,101
symbols so it means that your library

02:38:52,980 --> 02:38:59,610
may have things are extensions

02:38:56,101 --> 02:39:02,521
instructions from extensions compiled in

02:38:59,610 --> 02:39:04,530
that will not run on the hardware on the

02:39:02,521 --> 02:39:06,181
on the platform you're running on but

02:39:04,530 --> 02:39:08,610
the application being aware of that it's

02:39:06,181 --> 02:39:11,730
not going to use them so it's perfectly

02:39:08,610 --> 02:39:14,251
fine so limiting loading of libraries to

02:39:11,730 --> 02:39:15,450
only things that were compiled exactly

02:39:14,251 --> 02:39:19,681
for the extensions that you are running

02:39:15,450 --> 02:39:22,501
on is in my opinion a very very limiting

02:39:19,681 --> 02:39:25,530
factor and the other thing I see what

02:39:22,501 --> 02:39:28,110
prevents me from hacking and health

02:39:25,530 --> 02:39:32,671
library changing that string and making

02:39:28,110 --> 02:39:35,971
the fing doing weird things so there are

02:39:32,671 --> 02:39:39,301
two challenges right the first one the T

02:39:35,971 --> 02:39:41,510
open thing I don't know other see ivory

02:39:39,301 --> 02:39:44,000
so I just talked about good

02:39:41,510 --> 02:39:46,640
deep sea but that yellow plane is a

02:39:44,000 --> 02:39:49,910
system call that that'll not system call

02:39:46,640 --> 02:39:52,819
but library thing that manually load the

02:39:49,910 --> 02:39:54,800
library here if your application he has

02:39:52,819 --> 02:39:57,140
plugins for example the application can

02:39:54,800 --> 02:39:58,760
go have the plugins implement each

02:39:57,140 --> 02:40:02,750
different one in the library and you

02:39:58,760 --> 02:40:06,080
just simply load explicitly that library

02:40:02,750 --> 02:40:08,569
and the application knowing the format

02:40:06,080 --> 02:40:14,600
or the names of the symbols define

02:40:08,569 --> 02:40:16,670
library can explicitly call those the

02:40:14,600 --> 02:40:19,729
issue is that the presence of an

02:40:16,670 --> 02:40:22,550
instruction in a binary does not mean

02:40:19,729 --> 02:40:30,770
that it's necessary to have that is a in

02:40:22,550 --> 02:40:33,740
order to run the binary and so that's

02:40:30,770 --> 02:40:37,130
why I as an application programmer I

02:40:33,740 --> 02:40:39,080
wouldn't want my yellow panco being

02:40:37,130 --> 02:40:41,240
kicked out because the library for that

02:40:39,080 --> 02:40:45,140
buggy was compiled with all possible

02:40:41,240 --> 02:40:46,729
extensions out there and the elephants

02:40:45,140 --> 02:40:49,460
are at hearing gain or all dynamic

02:40:46,729 --> 02:40:52,189
liking static binary right it's the same

02:40:49,460 --> 02:40:54,740
problem the presence of an instruction

02:40:52,189 --> 02:40:57,260
doesn't mean it's necessary to have that

02:40:54,740 --> 02:40:58,430
instruction in order to like that the

02:40:57,260 --> 02:40:59,870
static presence of instruction is not

02:40:58,430 --> 02:41:02,569
the dynamic presence of an instruction

02:40:59,870 --> 02:41:06,229
right that's a that's a common

02:41:02,569 --> 02:41:08,180
occurrence sure and so back to this

02:41:06,229 --> 02:41:09,620
entire thing what's wrong with the

02:41:08,180 --> 02:41:13,340
application crashing with an invalid

02:41:09,620 --> 02:41:16,220
opcode what's wrong with the application

02:41:13,340 --> 02:41:18,950
crashing with an invalid opcode the

02:41:16,220 --> 02:41:22,310
system designer or the distro maintainer

02:41:18,950 --> 02:41:25,220
or whoever put together that thing did

02:41:22,310 --> 02:41:28,040
something wrong basically is what

02:41:25,220 --> 02:41:30,229
happens on current systems and Intel

02:41:28,040 --> 02:41:32,510
machine I get invalid opcodes

02:41:30,229 --> 02:41:35,359
occasionally right and the other day I

02:41:32,510 --> 02:41:37,550
compiled an application on my Intel

02:41:35,359 --> 02:41:39,170
machine and put it on that demo there

02:41:37,550 --> 02:41:42,140
and wasn't working because it was all

02:41:39,170 --> 02:41:44,689
x86 instructions yeah yeah and that's

02:41:42,140 --> 02:41:48,950
that's fine I mean I made a mistake yeah

02:41:44,689 --> 02:41:50,779
so do we really need that that's that's

02:41:48,950 --> 02:41:53,149
just my question yeah so I think the key

02:41:50,779 --> 02:41:54,450
here is that there's really two

02:41:53,149 --> 02:41:57,420
different things

02:41:54,450 --> 02:41:59,130
this one is when you ask the compiler to

02:41:57,420 --> 02:42:01,950
generate code which things can it

02:41:59,130 --> 02:42:04,340
generate and then the other one is what

02:42:01,950 --> 02:42:07,680
must I have in order to run this binary

02:42:04,340 --> 02:42:10,050
those are different things yes and then

02:42:07,680 --> 02:42:13,830
the question becomes can we just say

02:42:10,050 --> 02:42:15,570
what must you have is our be 64 GC or

02:42:13,830 --> 02:42:17,460
whatever whatever the base is a is and

02:42:15,570 --> 02:42:19,620
then if you're gonna add more stuff in

02:42:17,460 --> 02:42:22,620
you got to just make sure that you do

02:42:19,620 --> 02:42:25,950
dynamic probing of it that make sense

02:42:22,620 --> 02:42:26,370
yeah and then base base there's more

02:42:25,950 --> 02:42:32,640
stuff

02:42:26,370 --> 02:42:36,060
it's your gear problem instead of adding

02:42:32,640 --> 02:42:39,120
things to the elf format isn't that a

02:42:36,060 --> 02:42:41,550
problem of the the more the compiler and

02:42:39,120 --> 02:42:46,170
how it puts together the code for the

02:42:41,550 --> 02:42:47,670
library yeah the loader yes yeah that's

02:42:46,170 --> 02:42:51,080
kind of my point here right is don't

02:42:47,670 --> 02:42:53,670
kick out the miner yeah right say oh

02:42:51,080 --> 02:42:55,500
yeah if you're if you're running in

02:42:53,670 --> 02:42:58,110
standard Linux lands you got to be able

02:42:55,500 --> 02:43:00,530
to run on our V 64 GC systems or RV 32

02:42:58,110 --> 02:43:04,260
ima systems or whatever the base is and

02:43:00,530 --> 02:43:05,910
then you know if you've got custom

02:43:04,260 --> 02:43:07,950
instructions then you have to do when I

02:43:05,910 --> 02:43:11,640
funk or whatever it is to figure out how

02:43:07,950 --> 02:43:14,060
to deal with it don't don't don't put it

02:43:11,640 --> 02:43:19,189
in the kernel loader to boot it out

02:43:14,060 --> 02:43:19,189
that's it's a little too much policy

02:43:19,610 --> 02:43:54,750
okay so so then I think you don't like

02:43:29,820 --> 02:43:57,090
these things if you have to have a ton

02:43:54,750 --> 02:43:59,370
of conditions on the loading that that

02:43:57,090 --> 02:44:01,260
seems weird that's going to be a hard

02:43:59,370 --> 02:44:03,390
sell thing so one thing we can do is at

02:44:01,260 --> 02:44:04,380
least four standard extensions prevent

02:44:03,390 --> 02:44:06,390
people from shooting themselves in the

02:44:04,380 --> 02:44:07,290
foot and if you have multi Lib systems

02:44:06,390 --> 02:44:09,750
that are trying to run

02:44:07,290 --> 02:44:11,640
you know the hard floor code on the

02:44:09,750 --> 02:44:13,770
machines that don't have heart flow you

02:44:11,640 --> 02:44:16,890
can deal deal with that that was

02:44:13,770 --> 02:44:17,790
discussed already I think yeah was it

02:44:16,890 --> 02:44:20,490
yeah

02:44:17,790 --> 02:44:22,560
Christophe and others discussed that

02:44:20,490 --> 02:44:26,090
about to compile as Yuki did the stuff

02:44:22,560 --> 02:44:33,149
yeah if you have or have not extensions

02:44:26,090 --> 02:44:40,439
yeah so that seems reasonable hmm

02:44:33,149 --> 02:44:43,529
oh okay okay then I still want to state

02:44:40,439 --> 02:44:45,420
our motivations a little bit yeah

02:44:43,529 --> 02:44:46,979
because and I think having the strings

02:44:45,420 --> 02:44:48,899
and the elf to me actually does make

02:44:46,979 --> 02:44:51,240
sense because you might want to go find

02:44:48,899 --> 02:44:58,020
them later right but I don't think

02:44:51,240 --> 02:45:03,330
you're kicking out at load time okay so

02:44:58,020 --> 02:45:11,660
next one so next one is a recent

02:45:03,330 --> 02:45:16,109
proposal the story is that we on some

02:45:11,660 --> 02:45:19,560
and East rv5 core we don't have a we

02:45:16,109 --> 02:45:22,319
don't have cash coherent agent so in

02:45:19,560 --> 02:45:27,779
order to add this support to

02:45:22,319 --> 02:45:33,660
kernel-space we we also need a clean way

02:45:27,779 --> 02:45:38,399
to add these code so it it's then become

02:45:33,660 --> 02:45:41,310
it became patch set the first one is to

02:45:38,399 --> 02:45:44,390
introduce a infrastructure for vendor

02:45:41,310 --> 02:45:47,970
specific code and the second one is the

02:45:44,390 --> 02:45:52,490
the real thing we want and it can serve

02:45:47,970 --> 02:45:59,100
as a example of how to how to use these

02:45:52,490 --> 02:46:02,340
infrastructure so it turns out that

02:45:59,100 --> 02:46:05,609
there has been two version of these two

02:46:02,340 --> 02:46:09,689
versions of this proposal and there were

02:46:05,609 --> 02:46:14,580
there were some misunderstandings so I

02:46:09,689 --> 02:46:17,460
first want to clarify that actually we

02:46:14,580 --> 02:46:20,350
don't have custom instructions for this

02:46:17,460 --> 02:46:25,180
patch set and we don't have

02:46:20,350 --> 02:46:28,649
it's stateful extensions in this too to

02:46:25,180 --> 02:46:29,949
this functionality we only have a few

02:46:28,649 --> 02:46:35,739
customs

02:46:29,949 --> 02:46:37,810
CSR's so according just a little bit in

02:46:35,739 --> 02:46:41,800
respond that custom csr is actually a

02:46:37,810 --> 02:46:47,729
custom instruction unfortunately or

02:46:41,800 --> 02:46:47,729
maybe fortunately but that they're still

02:46:48,869 --> 02:46:54,100
doing a load or whatever on the stand

02:46:52,479 --> 02:46:57,369
register and on the customer is just

02:46:54,100 --> 02:46:58,720
ends up being custom code so it doesn't

02:46:57,369 --> 02:47:00,310
matter if you differentiate the

02:46:58,720 --> 02:47:06,220
instruction and register it's just

02:47:00,310 --> 02:47:09,010
custom ok ok let me go on first so I

02:47:06,220 --> 02:47:12,689
think they they have they they can be

02:47:09,010 --> 02:47:17,439
the same from the the point the specific

02:47:12,689 --> 02:47:20,079
so this vacation point of view but for

02:47:17,439 --> 02:47:21,729
technical details they may be some walk

02:47:20,079 --> 02:47:28,270
around yeah I don't want to derail your

02:47:21,729 --> 02:47:31,239
talk so so I think I think in conclusion

02:47:28,270 --> 02:47:34,390
of the previous discussions on Manning

02:47:31,239 --> 02:47:36,520
this there are three principles here the

02:47:34,390 --> 02:47:39,760
first one is that when the features

02:47:36,520 --> 02:47:44,850
should be long time probable and the

02:47:39,760 --> 02:47:48,699
second one is we don't want customize

02:47:44,850 --> 02:47:53,560
custom instructions or maybe custom CSRs

02:47:48,699 --> 02:47:58,300
in the kernel and the final one is don't

02:47:53,560 --> 02:48:02,649
we we proposed a directory structure

02:47:58,300 --> 02:48:06,310
which is based on vendor which is vendor

02:48:02,649 --> 02:48:10,510
wise but it seems that extension wise is

02:48:06,310 --> 02:48:15,839
a better approach okay so according to

02:48:10,510 --> 02:48:24,850
these three principles the first one is

02:48:15,839 --> 02:48:31,239
about wrong eye probing we to me how to

02:48:24,850 --> 02:48:33,669
pull this we have a version 3 yeah we

02:48:31,239 --> 02:48:36,051
have a version 3 proposal for this and

02:48:33,669 --> 02:48:40,250
we want

02:48:36,051 --> 02:48:44,721
as much as accommodate to these three

02:48:40,250 --> 02:48:49,160
principal and the first one is to

02:48:44,721 --> 02:48:52,820
utilize our chin it code just like kind

02:48:49,160 --> 02:48:57,021
of device driver but combined in a temp

02:48:52,820 --> 02:49:01,900
probe function in this case so during

02:48:57,021 --> 02:49:06,440
the the kernel setup it can somewhere

02:49:01,900 --> 02:49:10,250
though this variable is our sx this is

02:49:06,440 --> 02:49:14,990
from I believe CPU features that see it

02:49:10,250 --> 02:49:21,490
can query this information from the Isis

02:49:14,990 --> 02:49:29,320
ring in pts and then it can scan this

02:49:21,490 --> 02:49:35,240
string which has a prefix of SX so then

02:49:29,320 --> 02:49:44,320
if we match then we can do some hook to

02:49:35,240 --> 02:49:51,710
hook the function function pointers yes

02:49:44,320 --> 02:49:54,440
so here I want to ask you for feedback

02:49:51,710 --> 02:49:58,101
according to these three these three

02:49:54,440 --> 02:50:01,011
principles what happens if you have a

02:49:58,101 --> 02:50:04,631
custom instructions in this code then

02:50:01,011 --> 02:50:04,631
and your compiler doesn't understand it

02:50:07,811 --> 02:50:13,870
we have our own tool chain to support

02:50:14,620 --> 02:50:19,400
your chain your tool chain supports it

02:50:17,061 --> 02:50:21,171
but my tool chain doesn't put your stuff

02:50:19,400 --> 02:50:25,160
in it that I can tell the colonel but

02:50:21,171 --> 02:50:28,971
it's so far so far so far in order to

02:50:25,160 --> 02:50:35,091
support these these Co snip you just

02:50:28,971 --> 02:50:38,120
need parse DDS and loaded as a string

02:50:35,091 --> 02:50:40,881
and I mean so that part is fine actually

02:50:38,120 --> 02:50:44,601
yeah because that you can standardize

02:50:40,881 --> 02:50:46,881
the for example the string there as the

02:50:44,601 --> 02:50:47,720
ID for the extension whatever that's

02:50:46,881 --> 02:50:49,939
fine

02:50:47,720 --> 02:50:52,399
poems or back to Alistair what said is

02:50:49,939 --> 02:50:54,859
what if you need something really custom

02:50:52,399 --> 02:50:56,149
in those NDS something functions yeah

02:50:54,859 --> 02:50:58,689
yeah what's the government so those

02:50:56,149 --> 02:51:01,399
those need to be all standard eisah

02:50:58,689 --> 02:51:03,290
instructions there okay okay so I will

02:51:01,399 --> 02:51:06,109
and the other the other problem and that

02:51:03,290 --> 02:51:08,239
was rate raised recently on the list I

02:51:06,109 --> 02:51:10,399
can't remember who was in directions for

02:51:08,239 --> 02:51:13,279
sure Christoph we were there and shut

02:51:10,399 --> 02:51:15,439
down the the idea of having very

02:51:13,279 --> 02:51:18,500
specific instructional yes or anything

02:51:15,439 --> 02:51:20,569
like that in the kernel and the

02:51:18,500 --> 02:51:22,729
discussion that followed that was what

02:51:20,569 --> 02:51:25,100
about extensions how do we deal with

02:51:22,729 --> 02:51:29,359
that because the kernel only has a need

02:51:25,100 --> 02:51:32,090
for these space extensions yes but if we

02:51:29,359 --> 02:51:34,189
get other extensions making a better job

02:51:32,090 --> 02:51:37,489
at some tasks how do we actually use

02:51:34,189 --> 02:51:40,160
those and I think the output from that

02:51:37,489 --> 02:51:42,439
is that yes it's possible but that can

02:51:40,160 --> 02:51:46,010
only be modules basically say you have

02:51:42,439 --> 02:51:48,680
some vector instructions that can speed

02:51:46,010 --> 02:51:52,160
up whatever crypto or compression or

02:51:48,680 --> 02:51:54,380
whatnot you can have a modules like you

02:51:52,160 --> 02:51:56,630
already have now a tons of module freed

02:51:54,380 --> 02:51:58,489
for doing crypto and just basically plug

02:51:56,630 --> 02:52:00,680
the API in there instead of the generic

02:51:58,489 --> 02:52:03,109
one and that's fine

02:52:00,680 --> 02:52:08,600
that cannot be a module because that's

02:52:03,109 --> 02:52:11,960
any call so I don't know about that

02:52:08,600 --> 02:52:13,489
because most architecture have correctly

02:52:11,960 --> 02:52:16,399
grown their instruction sets that

02:52:13,489 --> 02:52:19,279
feature set and they can most of them

02:52:16,399 --> 02:52:23,300
can put a single kernel you can compile

02:52:19,279 --> 02:52:26,290
that kernel with most compilers so if

02:52:23,300 --> 02:52:28,939
it's just a matter of having some hacks

02:52:26,290 --> 02:52:31,279
in the kernel to generate the encoding

02:52:28,939 --> 02:52:34,250
of the instruction I think that's fine

02:52:31,279 --> 02:52:37,609
the problem is you cannot execute that

02:52:34,250 --> 02:52:39,800
on anything that doesn't have the

02:52:37,609 --> 02:52:42,770
extension and that's absolutely fine as

02:52:39,800 --> 02:52:47,590
long as you can discover what you have

02:52:42,770 --> 02:52:47,590
on your platform before executing this

02:52:50,290 --> 02:52:57,921
sure sure that's all but but so it all

02:52:54,080 --> 02:53:00,650
gets very specific it's out if it's in

02:52:57,921 --> 02:53:01,131
the speech standardized you have it or

02:53:00,650 --> 02:53:10,900
not

02:53:01,131 --> 02:53:13,190
yes agree no problem there now you can

02:53:10,900 --> 02:53:16,610
but not vendor-specific

02:53:13,190 --> 02:53:19,341
but if we take a closer look to these

02:53:16,610 --> 02:53:22,971
two to this function you you can see

02:53:19,341 --> 02:53:26,150
that although it is called from arch in

02:53:22,971 --> 02:53:29,001
need call but once you once this

02:53:26,150 --> 02:53:38,570
condition once this condition fails you

02:53:29,001 --> 02:53:40,641
you won't xq any of them standard ISO or

02:53:38,570 --> 02:53:43,851
is it a venir space okay so so this is

02:53:40,641 --> 02:53:45,290
principal to okay that's the thing

02:53:43,851 --> 02:53:47,330
that's where you you need to put all

02:53:45,290 --> 02:53:48,950
those cones in there you cannot have

02:53:47,330 --> 02:53:51,381
anything than your specific in there in

02:53:48,950 --> 02:53:54,051
terms of instruction even though that

02:53:51,381 --> 02:53:56,540
that code how things are done maybe then

02:53:54,051 --> 02:53:59,450
especially none of the distraction you

02:53:56,540 --> 02:54:03,160
have to be able to compile any work okay

02:53:59,450 --> 02:54:07,580
so so let me explain this in a in

02:54:03,160 --> 02:54:12,171
principle too so yeah now I understand

02:54:07,580 --> 02:54:17,181
that custom CSR is seen as custom

02:54:12,171 --> 02:54:21,641
instruction but if we can here actually

02:54:17,181 --> 02:54:25,160
we now have a not yet clean up but a

02:54:21,641 --> 02:54:27,620
patch that can work that suitable for

02:54:25,160 --> 02:54:37,311
our needs and still it can be compiled

02:54:27,620 --> 02:54:39,021
using official tool chain you'll always

02:54:37,311 --> 02:54:40,521
have that even if you grow your it when

02:54:39,021 --> 02:54:43,280
you grow your a certain set even if it's

02:54:40,521 --> 02:54:44,841
you know perfectly standardized you

02:54:43,280 --> 02:54:46,940
still want to compile with your old

02:54:44,841 --> 02:54:48,891
compiler for ten years ago that still

02:54:46,940 --> 02:54:50,780
has to work so you will always have to

02:54:48,891 --> 02:54:54,620
resort to that kind of where you

02:54:50,780 --> 02:54:56,841
have to encode basically the instruction

02:54:54,620 --> 02:54:58,431
that you want to generate in a compiler

02:54:56,841 --> 02:55:00,051
independent way because you can't

02:54:58,431 --> 02:55:02,330
retroactively Lee regenerate your

02:55:00,051 --> 02:55:04,399
compiler and we actually we do it now

02:55:02,330 --> 02:55:06,560
for some of the standard CSRs because

02:55:04,399 --> 02:55:09,380
yeah we don't a couple ourselves to the

02:55:06,560 --> 02:55:11,530
latest GCC release the issue is keeping

02:55:09,380 --> 02:55:13,580
track of all the vendor specific ones

02:55:11,530 --> 02:55:16,340
specific is something else yeah I mean I

02:55:13,580 --> 02:55:19,640
appreciate that it's a problem but

02:55:16,340 --> 02:55:22,069
saying everything has to compile with

02:55:19,640 --> 02:55:24,530
the standard tool chain that that

02:55:22,069 --> 02:55:27,229
doesn't hold any water you know there's

02:55:24,530 --> 02:55:28,850
no standard to chain since there's a

02:55:27,229 --> 02:55:35,390
standard tool chain as a given point in

02:55:28,850 --> 02:55:37,580
time but that changes yeah a tool chain

02:55:35,390 --> 02:55:39,500
I can actually find if it makes sense

02:55:37,580 --> 02:55:42,590
right so with this is right now we set

02:55:39,500 --> 02:55:43,609
our baseline GCC to whatever 7.2 or

02:55:42,590 --> 02:55:45,229
something because that's the first one

02:55:43,609 --> 02:55:46,490
that was likely to be able to compile

02:55:45,229 --> 02:55:47,840
the whole kernel without screwing

02:55:46,490 --> 02:55:52,330
something up and like a relaxation right

02:55:47,840 --> 02:55:54,350
so we have some things in their new CSRs

02:55:52,330 --> 02:55:58,069
that we need to be able access in order

02:55:54,350 --> 02:55:59,270
to correctly do stuff right but GCC

02:55:58,069 --> 02:56:01,939
seven appoints you did not understand

02:55:59,270 --> 02:56:02,450
those so we use some other stuff to make

02:56:01,939 --> 02:56:04,340
it work

02:56:02,450 --> 02:56:07,399
so that's a that's a thing and we do it

02:56:04,340 --> 02:56:08,540
and that's code that's totally cool

02:56:07,399 --> 02:56:14,540
right

02:56:08,540 --> 02:56:16,939
the issue is if those what those CF SARS

02:56:14,540 --> 02:56:30,080
do is not respect out in the standards

02:56:16,939 --> 02:56:31,910
back the kind of compile thing is like a

02:56:30,080 --> 02:56:34,790
this is meeting the letter of the law

02:56:31,910 --> 02:56:38,330
but not the not the spirit I guess about

02:56:34,790 --> 02:56:40,130
make sense but at some point you also

02:56:38,330 --> 02:56:41,870
have to face the reality that people

02:56:40,130 --> 02:56:43,939
will need to do something like that and

02:56:41,870 --> 02:56:45,770
it's the question is is this better than

02:56:43,939 --> 02:56:49,040
people doing assam dot long and just

02:56:45,770 --> 02:56:50,240
hard coding a hex value are we are we

02:56:49,040 --> 02:56:52,640
making it too easy for them to do the

02:56:50,240 --> 02:56:55,069
right thing or the wrong thing but at at

02:56:52,640 --> 02:56:57,910
some point this will something like this

02:56:55,069 --> 02:56:57,910
will be needed

02:56:58,460 --> 02:57:03,060
even the assembler where you can do it's

02:57:01,470 --> 02:57:06,270
called dot ensign and you can construct

02:57:03,060 --> 02:57:08,700
your own instructions out of bit fields

02:57:06,270 --> 02:57:09,960
basically so this can be done right and

02:57:08,700 --> 02:57:24,840
that would that can compile anything

02:57:09,960 --> 02:57:26,729
with us and our children so I think if

02:57:24,840 --> 02:57:28,470
it's for a standard extension and it's

02:57:26,729 --> 02:57:30,420
done because there's maybe one of these

02:57:28,470 --> 02:57:32,040
in the kernel somewhere and we don't

02:57:30,420 --> 02:57:35,460
want to make everybody update to GCC

02:57:32,040 --> 02:57:37,439
twelve it's probably okay and we do this

02:57:35,460 --> 02:57:39,660
for now with some csr numbers where the

02:57:37,439 --> 02:57:41,489
csr number as it is listed in the kernel

02:57:39,660 --> 02:57:43,290
does not correspond with is a manual

02:57:41,489 --> 02:57:44,370
because the tool chain wasn't right at

02:57:43,290 --> 02:57:46,319
that time and we have backwards

02:57:44,370 --> 02:57:48,930
compatible stuff in the assembler that

02:57:46,319 --> 02:57:51,960
i'm all ok with because it's it's very

02:57:48,930 --> 02:57:53,520
small instances right my issue is the

02:57:51,960 --> 02:57:55,260
the vendor specific things that's where

02:57:53,520 --> 02:57:59,340
i don't don't know what they do yeah I

02:57:55,260 --> 02:58:03,420
think we're all violently agreeing and

02:57:59,340 --> 02:58:05,399
and in some in some cases by not

02:58:03,420 --> 02:58:08,130
allowing an upstream you will also get a

02:58:05,399 --> 02:58:10,170
more deep-rooted out of tree fork at

02:58:08,130 --> 02:58:12,569
some point it's a balance it's not black

02:58:10,170 --> 02:58:14,250
and white it's it's complicated but also

02:58:12,569 --> 02:58:16,319
by making it harder maybe people will

02:58:14,250 --> 02:58:17,790
make the right decision so yeah yeah

02:58:16,319 --> 02:58:21,029
like I'd much prefer if we use this as a

02:58:17,790 --> 02:58:23,729
way to say hey let's go spec out an SBI

02:58:21,029 --> 02:58:25,890
cash management scheme alright drop

02:58:23,729 --> 02:58:28,620
something into the platform detection

02:58:25,890 --> 02:58:30,779
mechanism that says I have noncoherent

02:58:28,620 --> 02:58:32,939
for this device for that device and we

02:58:30,779 --> 02:58:35,489
have a standard you know SBI noncoherent

02:58:32,939 --> 02:58:38,880
thing and then you guys can implement

02:58:35,489 --> 02:58:40,260
that in the platform for more yeah does

02:58:38,880 --> 02:58:47,250
that make sense then we can use this as

02:58:40,260 --> 02:58:50,270
we go yeah yeah yeah and that might be

02:58:47,250 --> 02:58:52,319
too slow and then we already have a

02:58:50,270 --> 02:58:53,760
potential scheme for doing faster SBI

02:58:52,319 --> 02:58:56,250
stuff which we can then use this you

02:58:53,760 --> 02:58:59,100
know it's like we use this issue where

02:58:56,250 --> 02:59:00,870
we didn't spec out cat the way the risk

02:58:59,100 --> 02:59:02,279
Bobby I said can't deal with unco

02:59:00,870 --> 02:59:04,920
hearing devices right now in cleanroom

02:59:02,279 --> 02:59:07,890
devices so we use this as a way to kind

02:59:04,920 --> 02:59:10,050
of move the ecosystem forward as opposed

02:59:07,890 --> 02:59:10,980
to just adding this in because if we do

02:59:10,050 --> 02:59:13,760
this then

02:59:10,980 --> 02:59:16,530
we're gonna have 50 of them next year

02:59:13,760 --> 02:59:18,420
and I keep hearing that getting a

02:59:16,530 --> 02:59:22,460
lightweight SB ice backup is gonna be

02:59:18,420 --> 02:59:22,460
very very critical very shortly so yeah

02:59:22,790 --> 02:59:28,170
the problem is at one point someone will

02:59:25,830 --> 02:59:29,670
have something that we can't today

02:59:28,170 --> 02:59:31,080
vendors will have things to keep wanting

02:59:29,670 --> 02:59:33,420
like you said we're just gonna end up

02:59:31,080 --> 02:59:36,690
with forks of everything everywhere and

02:59:33,420 --> 02:59:38,910
that's I I think so you said you said

02:59:36,690 --> 02:59:41,160
you said hard rules and you communicate

02:59:38,910 --> 02:59:42,480
those rules and you stick to them and

02:59:41,160 --> 02:59:44,160
you don't talk about the times when

02:59:42,480 --> 02:59:46,830
you're not gonna stick to them but there

02:59:44,160 --> 02:59:49,740
will maybe be some times right in rally

02:59:46,830 --> 02:59:51,720
that's how it works start talking about

02:59:49,740 --> 02:59:58,650
exceptions from day one everybody will

02:59:51,720 --> 02:59:59,880
be an exception so let's not let's let's

02:59:58,650 --> 03:00:00,271
not add an exception for something we

02:59:59,880 --> 03:00:02,130
can do

03:00:00,271 --> 03:00:04,290
also no matter what you do they're all

03:00:02,130 --> 03:00:07,050
gonna be Colonel folks there are Colonel

03:00:04,290 --> 03:00:11,181
folks of x86 every Linux distro is I

03:00:07,050 --> 03:00:14,760
mean I have 30 Colonel Forks right

03:00:11,181 --> 03:00:16,980
can I just to be fully transparent I

03:00:14,760 --> 03:00:18,811
really don't want a Qualcomm situation

03:00:16,980 --> 03:00:21,030
on the risk 5 we can avoid it where one

03:00:18,811 --> 03:00:30,090
vendor has a very very big fork that is

03:00:21,030 --> 03:00:32,070
not converging point I was making is we

03:00:30,090 --> 03:00:34,290
want to minimize the likelihood of folks

03:00:32,070 --> 03:00:50,030
not whatever you do you can't rule it

03:00:34,290 --> 03:00:50,030
out entirely yeah so so ok

03:00:50,931 --> 03:01:00,410
then I don't think I should like now

03:00:58,160 --> 03:01:02,301
this means we should start the so I had

03:01:00,410 --> 03:01:05,750
all in my talk I had a list of like 15

03:01:02,301 --> 03:01:07,070
or so task groups related the platform

03:01:05,750 --> 03:01:11,480
specifications so this means we should

03:01:07,070 --> 03:01:13,971
start the incoherent system SBI task

03:01:11,480 --> 03:01:16,221
group basically okay that make sense

03:01:13,971 --> 03:01:20,360
which can maybe spec out three or four

03:01:16,221 --> 03:01:27,011
calls well hopefully we'll find out we

03:01:20,360 --> 03:01:27,011
have it okay then

03:01:27,971 --> 03:01:46,341
should we keep introducing our language

03:01:32,480 --> 03:01:49,551
agent okay then I think there will be a

03:01:46,341 --> 03:01:51,650
final issue which is about address space

03:01:49,551 --> 03:01:58,030
identifier a seat

03:01:51,650 --> 03:02:03,320
this part is for my colleagues also so I

03:01:58,030 --> 03:02:09,740
will be consoled topic non-core agent so

03:02:03,320 --> 03:02:14,301
I just saw a seat in SAT be a CSR and

03:02:09,740 --> 03:02:17,931
there's a estate field in a TV riches

03:02:14,301 --> 03:02:21,801
and but actually it's not be used for

03:02:17,931 --> 03:02:27,561
now so we plan to support is in Venice

03:02:21,801 --> 03:02:32,120
Kronos we can we have the LCD we can

03:02:27,561 --> 03:02:36,230
custom Tiffany's so such like Kop we

03:02:32,120 --> 03:02:40,341
don't we don't have to invert the Kop

03:02:36,230 --> 03:02:46,931
uncon this week so but I we still need

03:02:40,341 --> 03:02:51,080
frosty up even on your face a seat and

03:02:46,931 --> 03:02:54,381
our point is a trick modules in my

03:02:51,080 --> 03:02:57,471
current implementation because we I I

03:02:54,381 --> 03:03:01,311
don't have acid so I need to sell

03:02:57,471 --> 03:03:04,819
trigger uncommon switch for example I

03:03:01,311 --> 03:03:11,079
want if we want to debug use

03:03:04,819 --> 03:03:14,629
hogan i call in tax to attest to and

03:03:11,079 --> 03:03:18,140
went s to is kinase which to test to and

03:03:14,629 --> 03:03:22,479
we need to stack a trigger to enable

03:03:18,140 --> 03:03:28,550
single stable and return to user space

03:03:22,479 --> 03:03:31,579
so in concert if it has to is not to be

03:03:28,550 --> 03:03:34,699
buggin so we need to set the trigger to

03:03:31,579 --> 03:03:38,810
TC disables single step before return to

03:03:34,699 --> 03:03:44,839
user space so i need cell trigger every

03:03:38,810 --> 03:03:48,489
time and condense which if we have acid

03:03:44,839 --> 03:03:51,800
and maybe how we can measure as it

03:03:48,489 --> 03:03:56,020
triggers reaches and SAT be reached so

03:03:51,800 --> 03:03:59,419
let's do the program can stop correctly

03:03:56,020 --> 03:04:02,689
but the problem is the trigger which

03:03:59,419 --> 03:04:06,369
will let us know a state field in sugar

03:04:02,689 --> 03:04:13,550
register for now so maybe we can use the

03:04:06,369 --> 03:04:18,319
reserve the pit for Storer acid but the

03:04:13,550 --> 03:04:23,749
problem is as we study to the risk of

03:04:18,319 --> 03:04:29,859
pit is only to Pete so maybe we we need

03:04:23,749 --> 03:04:39,579
new one which to store assist value yeah

03:04:29,859 --> 03:04:39,579
this any questions

03:04:45,109 --> 03:04:48,919
yeah so you're suggesting putting this

03:04:46,639 --> 03:04:57,799
in the like that trigger stuff in the

03:04:48,919 --> 03:04:59,929
debug its back yeah maybe okay yeah so I

03:04:57,799 --> 03:05:03,199
think somebody already added some of

03:04:59,929 --> 03:05:06,589
that in there but maybe I'm

03:05:03,199 --> 03:05:11,899
misunderstanding what you're asking um

03:05:06,589 --> 03:05:14,619
I'm mailing least or no again in the

03:05:11,899 --> 03:05:19,909
spec in the PDI you in this back yeah

03:05:14,619 --> 03:05:21,199
okay okay but I also I am not very good

03:05:19,909 --> 03:05:23,629
at reading the DB I expect I might be

03:05:21,199 --> 03:05:27,979
wrong but but here we are talking about

03:05:23,629 --> 03:05:30,919
the the implementation in kernel the AC

03:05:27,979 --> 03:05:32,060
okay yeah yeah so there's okay so I

03:05:30,919 --> 03:05:33,649
thought you're talking about adding us

03:05:32,060 --> 03:05:36,949
to the spec so the reason this isn't not

03:05:33,649 --> 03:05:39,379
implemented in the kernel is because I'm

03:05:36,949 --> 03:05:41,689
not confident that I can implement it

03:05:39,379 --> 03:05:43,399
without testing it and without reducing

03:05:41,689 --> 03:05:45,229
any bugs they don't have any

03:05:43,399 --> 03:05:48,020
implementations that take advantage of a

03:05:45,229 --> 03:05:51,279
sits there for can't actually test that

03:05:48,020 --> 03:05:55,209
I got them right okay

03:05:51,279 --> 03:05:57,529
based on our previous experience in

03:05:55,209 --> 03:06:00,699
kernel porting we have another

03:05:57,529 --> 03:06:04,009
architecture called nd 32 right anyway

03:06:00,699 --> 03:06:07,849
based on those previous six experiments

03:06:04,009 --> 03:06:10,429
we found that on single core system AC

03:06:07,849 --> 03:06:12,829
it can help a lot yeah I agree

03:06:10,429 --> 03:06:14,989
it's just that our Hardware ignored the

03:06:12,829 --> 03:06:18,469
ignores the asset field which is legal

03:06:14,989 --> 03:06:21,319
according to the spec so if I simplify

03:06:18,469 --> 03:06:24,049
this and screw up the a CID tracking I

03:06:21,319 --> 03:06:25,759
will never notice so I have no way to

03:06:24,049 --> 03:06:26,899
test it like I totally agree this is a

03:06:25,759 --> 03:06:29,329
good thing to do that's why it's in the

03:06:26,899 --> 03:06:31,789
spec the only reason we have implemented

03:06:29,329 --> 03:06:33,979
it is just you know no time to do an

03:06:31,789 --> 03:06:35,209
implementation that I'm confident we'll

03:06:33,979 --> 03:06:37,849
have no bugs without testing it

03:06:35,209 --> 03:06:41,719
basically so at least you won't reject

03:06:37,849 --> 03:06:44,299
this idea as your if you yeah if you if

03:06:41,719 --> 03:06:47,119
if you are confident that you won't

03:06:44,299 --> 03:06:48,319
introduce any bugs then I would be very

03:06:47,119 --> 03:06:49,429
happy to have it because otherwise I'll

03:06:48,319 --> 03:06:51,829
have to do it as soon as one of our

03:06:49,429 --> 03:06:56,209
hardware guys out Jason's I believe we

03:06:51,829 --> 03:06:58,040
have don't have started this work yeah

03:06:56,209 --> 03:07:02,110
so maybe yeah I don't think

03:06:58,040 --> 03:07:05,330
can detect the bugs in qmu okay so I

03:07:02,110 --> 03:07:15,890
think that's that's all so thank you

03:07:05,330 --> 03:07:18,740
very much yeah I guess we are over time

03:07:15,890 --> 03:07:22,310
as well yeah I mean it's a lot for

03:07:18,740 --> 03:07:27,250
everybody for coming on views and

03:07:22,310 --> 03:07:27,250
comments and speaker gifts

03:07:29,510 --> 03:07:32,690

YouTube URL: https://www.youtube.com/watch?v=4OKkHCg7El0


