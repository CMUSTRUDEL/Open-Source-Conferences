Title: LPC2018 - Toolchain MC
Publication date: 2018-12-04
Playlist: LPC2018 - MicroConferences
Description: 
	https://linuxplumbersconf.org/event/2/sessions/33/#20181114

The GNU Toolchain and Clang/LLVM play a critical role at the nexus of the Linux Kernel, the Open Source Software ecosystem, and computer hardware. The rapid innovation and progress in each of these components requires greater cooperation and coordination. This Toolchain Microconference will explore recent developments in the toolchain projects, the roadmaps, and how to address the challenges and opportunities ahead as the pace of change continues to accelerate.
Captions: 
	00:00:05,650 --> 00:00:10,120
so thanks very much welcome to the claim

00:00:08,500 --> 00:00:15,219
GCC binutils

00:00:10,120 --> 00:00:17,320
the new linker L LD session in many

00:00:15,219 --> 00:00:18,759
conference here we're gonna have a

00:00:17,320 --> 00:00:22,119
couple of interesting presentations

00:00:18,759 --> 00:00:24,460
about the new tool chain and the LLVM

00:00:22,119 --> 00:00:27,669
tool chain and the interaction with the

00:00:24,460 --> 00:00:30,369
linux kernel so the first talk is by me

00:00:27,669 --> 00:00:32,050
my name is David Edelson I'm on the GCC

00:00:30,369 --> 00:00:32,739
steering committee and I'm also work at

00:00:32,050 --> 00:00:36,120
IBM Research

00:00:32,739 --> 00:00:39,339
I'm the power PC port maintainer and so

00:00:36,120 --> 00:00:41,559
just dive right into it

00:00:39,339 --> 00:00:44,410
everybody knows we'll talk about that

00:00:41,559 --> 00:00:46,329
this is a tribute to the ganoub and I

00:00:44,410 --> 00:00:48,879
mean it started out in the 1960s as you

00:00:46,329 --> 00:00:51,879
remember as a hootenanny band and then

00:00:48,879 --> 00:00:54,760
in the turned into a rock band in the

00:00:51,879 --> 00:00:56,199
1970s this was the the the rough raise

00:00:54,760 --> 00:00:58,300
that's Richard Stallman on the left

00:00:56,199 --> 00:01:01,690
there and then after going to Rishikesh

00:00:58,300 --> 00:01:04,089
he then went returned to MIT and founded

00:01:01,690 --> 00:01:06,460
the canoe tool chain movement and the

00:01:04,089 --> 00:01:08,110
new project in general so that's the

00:01:06,460 --> 00:01:11,440
brief history of beginners but seriously

00:01:08,110 --> 00:01:13,690
the canoe tool chain is the tool chain

00:01:11,440 --> 00:01:16,270
of the Linux kernel I mean it's it's the

00:01:13,690 --> 00:01:18,880
tool chain that for the compiled Linux

00:01:16,270 --> 00:01:21,940
kernel it compiles the user space for

00:01:18,880 --> 00:01:23,890
the Linux distributions and it's the

00:01:21,940 --> 00:01:25,990
tool chain that most of the major

00:01:23,890 --> 00:01:28,180
distributions are using to build the

00:01:25,990 --> 00:01:30,100
entire infrastructure so it's quite

00:01:28,180 --> 00:01:33,670
important to the Linux community we want

00:01:30,100 --> 00:01:35,530
to discuss and remind everybody how GCC

00:01:33,670 --> 00:01:37,930
and Ben utils and all of the tool chain

00:01:35,530 --> 00:01:40,810
interacts with Linux and what are the

00:01:37,930 --> 00:01:42,640
dependencies of Linux on the new tool

00:01:40,810 --> 00:01:44,680
chain the dependencies of the knut tool

00:01:42,640 --> 00:01:48,910
chain on Linux

00:01:44,680 --> 00:01:53,530
so basically Linux distro a be eyes are

00:01:48,910 --> 00:01:57,550
defined by GCC and G Lipsy Lib GCC lip

00:01:53,530 --> 00:02:01,120
standard C++ this is what is locked in

00:01:57,550 --> 00:02:06,040
in most Linux distributions as that that

00:02:01,120 --> 00:02:07,960
sets again the ABI that defines and is

00:02:06,040 --> 00:02:10,539
reason that that provides the forward

00:02:07,960 --> 00:02:13,739
compatibility of Linux distributions

00:02:10,539 --> 00:02:16,180
within a particular release a long-term

00:02:13,739 --> 00:02:17,590
supported release of Linux basically

00:02:16,180 --> 00:02:19,360
doesn't change these components you'll

00:02:17,590 --> 00:02:21,940
they'll be add-ons they'll be additional

00:02:19,360 --> 00:02:24,160
will sets but this is basic level that

00:02:21,940 --> 00:02:25,930
we don't change that Linux distributions

00:02:24,160 --> 00:02:29,920
don't change in order to provide that

00:02:25,930 --> 00:02:31,600
level of stability for all the projects

00:02:29,920 --> 00:02:36,280
all the packages that are running on the

00:02:31,600 --> 00:02:40,660
system and as you know for a Linux

00:02:36,280 --> 00:02:42,730
distribution 99% or more of the packages

00:02:40,660 --> 00:02:45,100
and distribution the executables that's

00:02:42,730 --> 00:02:48,580
over 5,000 packages and for instance

00:02:45,100 --> 00:02:52,180
redhead Enterprise Linux or sousei are

00:02:48,580 --> 00:02:53,950
built with GCC so GCC and binutils are

00:02:52,180 --> 00:02:57,280
really defining what a Linux

00:02:53,950 --> 00:02:58,900
distribution is here is an ni chart but

00:02:57,280 --> 00:03:02,620
just describing to remind people of how

00:02:58,900 --> 00:03:04,750
much these tools are the foundation of

00:03:02,620 --> 00:03:05,800
the Linux distribution I mean everything

00:03:04,750 --> 00:03:09,940
from the kernel itself

00:03:05,800 --> 00:03:14,920
KVM Zanjeer Lib C obviously but bash in

00:03:09,940 --> 00:03:16,450
it tech Emacs Python and all the

00:03:14,920 --> 00:03:20,140
different applications that are built on

00:03:16,450 --> 00:03:24,610
Python from OpenStack to tensorflow

00:03:20,140 --> 00:03:26,350
Kerris pi torch perl diff get all these

00:03:24,610 --> 00:03:28,620
pieces are built with GCC all these

00:03:26,350 --> 00:03:31,870
libraries that are very fundamental

00:03:28,620 --> 00:03:37,959
international libraries the B zip

00:03:31,870 --> 00:03:40,239
libraries gdb em open blas atlas for

00:03:37,959 --> 00:03:42,549
math libraries all of this is built with

00:03:40,239 --> 00:03:46,180
the canoe toll chain and so this is very

00:03:42,549 --> 00:03:47,950
important to the current cloud and

00:03:46,180 --> 00:03:51,010
machine learning i a deep learning

00:03:47,950 --> 00:03:52,930
infrastructure and this is what the new

00:03:51,010 --> 00:03:54,970
tool chain is contributing to the

00:03:52,930 --> 00:04:00,340
environment and the ecosystem that that

00:03:54,970 --> 00:04:02,830
Linux provides so GCC is you know has a

00:04:00,340 --> 00:04:04,630
lot of really great resources a lot of

00:04:02,830 --> 00:04:07,690
really great capabilities it produces

00:04:04,630 --> 00:04:09,970
very fast executables now it produces

00:04:07,690 --> 00:04:12,610
small executables I mean it produces

00:04:09,970 --> 00:04:14,230
good debugging information to be able to

00:04:12,610 --> 00:04:15,670
really understand what's going on under

00:04:14,230 --> 00:04:18,459
the application what it's not working

00:04:15,670 --> 00:04:21,040
the Diagnostics are now very very good

00:04:18,459 --> 00:04:22,900
with a lot of improvements that a lot of

00:04:21,040 --> 00:04:25,690
competition from other tool chains

00:04:22,900 --> 00:04:27,940
I mean clang has really stepped up its

00:04:25,690 --> 00:04:30,330
game and stepped up the the game of the

00:04:27,940 --> 00:04:31,940
canoe tool chain as well and GCC's

00:04:30,330 --> 00:04:34,340
compilation is

00:04:31,940 --> 00:04:38,860
again been driven to be to improve a lot

00:04:34,340 --> 00:04:41,960
so it's really a very good robust fast

00:04:38,860 --> 00:04:44,930
flexible tool chain that is providing

00:04:41,960 --> 00:04:47,680
the basis for all of this you know use

00:04:44,930 --> 00:04:50,660
in the enterprise in the cloud in

00:04:47,680 --> 00:04:53,150
on-premises in hybrid cloud and public

00:04:50,660 --> 00:04:55,790
clouds it's really the basis for a lot

00:04:53,150 --> 00:05:00,830
of what is happening in the the use of

00:04:55,790 --> 00:05:02,750
Linux GCC has a wide variety of support

00:05:00,830 --> 00:05:06,170
I mean to remind people the languages

00:05:02,750 --> 00:05:09,320
obviously C and C++ Fortran Objective C

00:05:06,170 --> 00:05:12,830
Objective C plus plus go A to D language

00:05:09,320 --> 00:05:14,840
was just added a few months ago it's now

00:05:12,830 --> 00:05:16,580
available I mean there's other sort of

00:05:14,840 --> 00:05:18,850
secondary languages that are in public

00:05:16,580 --> 00:05:20,780
but COBOL PL

00:05:18,850 --> 00:05:24,620
architectures are supported again

00:05:20,780 --> 00:05:26,560
obviously x86 arm PowerPC a lot of you

00:05:24,620 --> 00:05:29,300
know other architectures from frv

00:05:26,560 --> 00:05:32,510
epiphany mentioning there at the end

00:05:29,300 --> 00:05:35,030
this NDS 32 and sea sky which were just

00:05:32,510 --> 00:05:36,620
added to the Linux kernel they're now

00:05:35,030 --> 00:05:38,570
just available in Linux and they are

00:05:36,620 --> 00:05:40,220
Linux is able to provide those

00:05:38,570 --> 00:05:42,260
architectures because the good new

00:05:40,220 --> 00:05:45,680
toolchain provides those architectures

00:05:42,260 --> 00:05:48,650
so it's the basis for all of the breadth

00:05:45,680 --> 00:05:50,540
and depth and portability of it OS is

00:05:48,650 --> 00:05:53,419
obviously it supports many additional

00:05:50,540 --> 00:05:55,190
os's embedded in addition to to Linux

00:05:53,419 --> 00:05:56,870
but the primary focus of this conference

00:05:55,190 --> 00:06:00,020
is Linux I'll just sort of leave that

00:05:56,870 --> 00:06:02,590
but you know z/os TPF you know all of

00:06:00,020 --> 00:06:05,510
the BSD s it's a very very you know

00:06:02,590 --> 00:06:07,510
general productive portable tool chain

00:06:05,510 --> 00:06:10,419
that you know provides a lot of

00:06:07,510 --> 00:06:14,480
robustness for everybody who's using it

00:06:10,419 --> 00:06:16,910
what is GCC is a very actively developed

00:06:14,480 --> 00:06:19,250
actively maintained infrastructure they

00:06:16,910 --> 00:06:22,400
have the recent work in in a JIT now is

00:06:19,250 --> 00:06:24,770
available with Lib GCC JIT again

00:06:22,400 --> 00:06:26,720
debugging improvements are excellent

00:06:24,770 --> 00:06:28,970
unit testing infrastructure that has

00:06:26,720 --> 00:06:33,380
gone in it's excellent for cross

00:06:28,970 --> 00:06:35,360
compiling and GCC releases themselves

00:06:33,380 --> 00:06:38,150
from the FSF the canoe tool chain

00:06:35,360 --> 00:06:40,220
community are supported for two years so

00:06:38,150 --> 00:06:43,280
it provides a lot of stability for

00:06:40,220 --> 00:06:44,660
people utilizing the tool chain I mean

00:06:43,280 --> 00:06:46,550
in addition to the

00:06:44,660 --> 00:06:48,890
further support of the districts

00:06:46,550 --> 00:06:51,290
themselves but that one is able to

00:06:48,890 --> 00:06:54,500
install this tool chain from the public

00:06:51,290 --> 00:06:55,790
FSF's GC seeing binutils sources and

00:06:54,500 --> 00:06:59,000
ensure that this is going to be

00:06:55,790 --> 00:07:01,250
available and stable and maintained for

00:06:59,000 --> 00:07:04,130
an extended period of time

00:07:01,250 --> 00:07:06,560
for uses in in the kernel and that any

00:07:04,130 --> 00:07:08,090
you know optimizations any details that

00:07:06,560 --> 00:07:09,320
are that are needed are going to be

00:07:08,090 --> 00:07:11,720
available and maintained by the

00:07:09,320 --> 00:07:13,400
community as a whole

00:07:11,720 --> 00:07:15,470
highlights that some people will be

00:07:13,400 --> 00:07:17,600
talking about other topics as

00:07:15,470 --> 00:07:21,310
conferences you know recent improvements

00:07:17,600 --> 00:07:24,440
of the the Intel CET infrastructure arm

00:07:21,310 --> 00:07:27,140
with their new sve architecture going in

00:07:24,440 --> 00:07:30,920
the RISC five port was just back-end was

00:07:27,140 --> 00:07:34,510
just added in open risk open mp5 was

00:07:30,920 --> 00:07:38,030
just added last week as the that

00:07:34,510 --> 00:07:41,150
standard was was finally approved there

00:07:38,030 --> 00:07:43,220
is ongoing support for the C++ 2x

00:07:41,150 --> 00:07:44,720
lots of optimization improvements from

00:07:43,220 --> 00:07:48,760
link time optimization register

00:07:44,720 --> 00:07:50,870
allocator the inline assembler

00:07:48,760 --> 00:07:53,900
clarifications and the definitions of

00:07:50,870 --> 00:07:56,390
that work on register pressure work on

00:07:53,900 --> 00:07:58,100
loop optimizations for the application

00:07:56,390 --> 00:07:59,510
support so it's a very actively

00:07:58,100 --> 00:08:01,670
maintained

00:07:59,510 --> 00:08:04,610
you know infrastructure that's also

00:08:01,670 --> 00:08:06,800
responding to all the CBE's all security

00:08:04,610 --> 00:08:10,010
concerns and this is a you know very

00:08:06,800 --> 00:08:12,920
reliable robust and highly performant

00:08:10,010 --> 00:08:15,200
system that people are using now in

00:08:12,920 --> 00:08:18,560
production in a lot of places and a lot

00:08:15,200 --> 00:08:20,930
of businesses I mean listen to you know

00:08:18,560 --> 00:08:23,300
you know many different major websites

00:08:20,930 --> 00:08:25,250
that one would go to are all you know

00:08:23,300 --> 00:08:27,200
banks I mean lots of infrastructure that

00:08:25,250 --> 00:08:30,200
depends you know financial systems

00:08:27,200 --> 00:08:32,570
insurance systems financial markets that

00:08:30,200 --> 00:08:34,190
depend upon this infrastructure that all

00:08:32,570 --> 00:08:35,870
of you all the people in the audience

00:08:34,190 --> 00:08:38,719
working on Linux and all the people work

00:08:35,870 --> 00:08:41,240
in the tool chain are providing for the

00:08:38,719 --> 00:08:45,260
economy of the world talking about G Lib

00:08:41,240 --> 00:08:47,390
C I mean again G Lib C Linux 3.2 is now

00:08:45,260 --> 00:08:49,190
the minimum requirement for G Lib C

00:08:47,390 --> 00:08:52,010
there's again been you know great work

00:08:49,190 --> 00:08:53,480
by Intel on the CT infrastructure there

00:08:52,010 --> 00:08:55,430
which which HJ and others will be

00:08:53,480 --> 00:08:56,610
talking about later new infrastructure

00:08:55,430 --> 00:08:59,779
for

00:08:56,610 --> 00:09:02,850
the quad precision floating point of

00:08:59,779 --> 00:09:05,910
PowerPC this has been added support for

00:09:02,850 --> 00:09:08,700
risk 5 recently went in a lot of great

00:09:05,910 --> 00:09:11,130
work on optimizations of malloc to make

00:09:08,700 --> 00:09:14,130
that more you know competitive with with

00:09:11,130 --> 00:09:16,829
TC malloc again a work in and a lot of

00:09:14,130 --> 00:09:20,310
collaboration with other C libraries out

00:09:16,829 --> 00:09:24,709
there Unicode support thread support for

00:09:20,310 --> 00:09:28,079
C 11 threads the allocations support

00:09:24,709 --> 00:09:30,149
static position independent code support

00:09:28,079 --> 00:09:33,510
you know this is a very actively again

00:09:30,149 --> 00:09:35,820
developed infrastructures a lot of you

00:09:33,510 --> 00:09:37,890
know challenges to how this works with

00:09:35,820 --> 00:09:40,200
Linux how it works with Linux kernels

00:09:37,890 --> 00:09:41,399
little extenders Linux system calls but

00:09:40,200 --> 00:09:43,019
there's a lot of work that's going on

00:09:41,399 --> 00:09:45,300
both collaborating with the Linux

00:09:43,019 --> 00:09:48,120
community and collaborating with all the

00:09:45,300 --> 00:09:50,370
standards out there and improving the

00:09:48,120 --> 00:09:51,720
performance of the infrastructure a lot

00:09:50,370 --> 00:09:54,480
of work that's been done especially by

00:09:51,720 --> 00:09:56,820
arm and Lennar o on the math libraries

00:09:54,480 --> 00:09:59,459
making those much faster for the generic

00:09:56,820 --> 00:10:03,870
code optimizing a lot of important math

00:09:59,459 --> 00:10:06,480
functions support now from code sorcery

00:10:03,870 --> 00:10:08,279
Mentor Graphics and the floating point

00:10:06,480 --> 00:10:13,350
conformance to new floating-point

00:10:08,279 --> 00:10:15,930
standards a lot of work by on string and

00:10:13,350 --> 00:10:19,529
memory optimizations copying them copy

00:10:15,930 --> 00:10:21,570
how can in arm in Intel and PowerPC so a

00:10:19,529 --> 00:10:22,860
lot of work on on architectures and it's

00:10:21,570 --> 00:10:25,500
very open for people who want to

00:10:22,860 --> 00:10:26,760
contribute but these you know server

00:10:25,500 --> 00:10:29,220
high-performing architectures are

00:10:26,760 --> 00:10:32,250
investing a lot of effort the developers

00:10:29,220 --> 00:10:34,500
and the chip vendors are investing a lot

00:10:32,250 --> 00:10:37,260
of effort to make G Lipsy better on all

00:10:34,500 --> 00:10:39,120
the major platforms and as some people

00:10:37,260 --> 00:10:41,130
probably aware a lot of discussions

00:10:39,120 --> 00:10:43,079
recently about G Lib C and Linux n

00:10:41,130 --> 00:10:45,089
reason were you know open to having more

00:10:43,079 --> 00:10:47,850
conversations about that how to make

00:10:45,089 --> 00:10:50,670
this interdependence work more smoothly

00:10:47,850 --> 00:10:52,920
and how we can ensure that that GCC G

00:10:50,670 --> 00:10:55,140
Lib C been utils all this continues to

00:10:52,920 --> 00:11:02,970
be a really great infrastructure on

00:10:55,140 --> 00:11:04,430
which now back to our regularly

00:11:02,970 --> 00:11:08,310
scheduled programming

00:11:04,430 --> 00:11:10,350
so gdb there's been a lot of work there

00:11:08,310 --> 00:11:23,910
again it's over 50 architectures

00:11:10,350 --> 00:11:26,030
supported with on gdb and again gdb

00:11:23,910 --> 00:11:28,980
provides you know great opportunity for

00:11:26,030 --> 00:11:33,150
Linux on embedded systems with remote

00:11:28,980 --> 00:11:36,210
debugging there's it now uses C++ 11 as

00:11:33,150 --> 00:11:40,530
the basis for the implementation of GEB

00:11:36,210 --> 00:11:43,410
a lot of great work on C++ on floating

00:11:40,530 --> 00:11:46,260
point emulation so it really provides a

00:11:43,410 --> 00:11:48,660
very good robust effort the new work

00:11:46,260 --> 00:11:51,330
from an external developer providing a

00:11:48,660 --> 00:11:53,850
great user interface for gdb and in

00:11:51,330 --> 00:11:56,490
Python there's now rust language support

00:11:53,850 --> 00:11:59,370
in gdb there's risk 5 support so again

00:11:56,490 --> 00:12:02,070
it's a very actively developed improving

00:11:59,370 --> 00:12:04,500
and and and you know important

00:12:02,070 --> 00:12:07,200
infrastructure for debugging of user

00:12:04,500 --> 00:12:09,870
applications and the kernel as well been

00:12:07,200 --> 00:12:11,970
utils a lot more effort on again just

00:12:09,870 --> 00:12:15,450
you know portability on conformance on

00:12:11,970 --> 00:12:18,210
you know compatibility between gold and

00:12:15,450 --> 00:12:20,970
new LD it's a very robust environment I

00:12:18,210 --> 00:12:25,020
mean security again working in the Intel

00:12:20,970 --> 00:12:29,070
CT support the the the other security

00:12:25,020 --> 00:12:33,510
work for specter mitigation in the tool

00:12:29,070 --> 00:12:37,980
chain and so you know future issues

00:12:33,510 --> 00:12:40,770
again it was in GCC you know rust is

00:12:37,980 --> 00:12:42,390
supported in GDP patches are welcome if

00:12:40,770 --> 00:12:44,580
anybody wants to work on that we very

00:12:42,390 --> 00:12:47,390
much like to have rust support in the

00:12:44,580 --> 00:12:53,250
new tool chain and in the new compiler

00:12:47,390 --> 00:12:56,310
oh sorry that's Swift supposed to be I

00:12:53,250 --> 00:13:00,750
guess it did they somebody did automatic

00:12:56,310 --> 00:13:04,440
spelling correction webassembly back-end

00:13:00,750 --> 00:13:07,200
would be wonderful you know questions in

00:13:04,440 --> 00:13:09,450
in GCC is discussing some people here

00:13:07,200 --> 00:13:10,590
this question of what exactly is the

00:13:09,450 --> 00:13:12,690
language and people were discussing

00:13:10,590 --> 00:13:15,450
again with the O compatibility with

00:13:12,690 --> 00:13:18,600
clang for building the kernel there is

00:13:15,450 --> 00:13:22,050
new C with extensions that are formally

00:13:18,600 --> 00:13:23,939
defined in the canoe in GCC to the

00:13:22,050 --> 00:13:26,729
language there's ISO C

00:13:23,939 --> 00:13:28,739
or ANSI C there's Linux kernel C which

00:13:26,729 --> 00:13:30,689
again has been providing interesting

00:13:28,739 --> 00:13:33,059
challenges to clang and and provides

00:13:30,689 --> 00:13:37,079
interesting challenges to GCC as well

00:13:33,059 --> 00:13:38,959
and there's the Dwemer do what i mean c

00:13:37,079 --> 00:13:42,470
which is what people are writing a

00:13:38,959 --> 00:13:44,759
language that has a syntax of c and

00:13:42,470 --> 00:13:47,249
semantics that are similar to but not

00:13:44,759 --> 00:13:49,319
exactly the same as ISO C and how to

00:13:47,249 --> 00:13:51,269
provide that balance between what

00:13:49,319 --> 00:13:53,359
people's expectations the behavior

00:13:51,269 --> 00:13:56,369
versus what the standard and how much

00:13:53,359 --> 00:13:58,709
GCC and then clang should be conforming

00:13:56,369 --> 00:14:01,259
to standards versus especially with

00:13:58,709 --> 00:14:04,349
undefined behavior it's an open

00:14:01,259 --> 00:14:07,799
challenge there's work on the year 2038

00:14:04,349 --> 00:14:11,220
in G Lipsy you know questions about

00:14:07,799 --> 00:14:15,209
future using link time optimization in

00:14:11,220 --> 00:14:18,659
GCC or LLVM for compiling the kernel

00:14:15,209 --> 00:14:21,649
similar for unique kernels life patching

00:14:18,659 --> 00:14:23,689
is an open question area that how do

00:14:21,649 --> 00:14:26,909
recent patches to make that

00:14:23,689 --> 00:14:29,399
infrastructure better for the kernel in

00:14:26,909 --> 00:14:30,720
the compiler Linux system call wrappers

00:14:29,399 --> 00:14:32,849
again has been a lot of discussions

00:14:30,720 --> 00:14:34,949
about exactly how fast how soon that

00:14:32,849 --> 00:14:36,929
should be defined which ones should go

00:14:34,949 --> 00:14:38,699
in there the best way to provide that

00:14:36,929 --> 00:14:41,909
and and there's we need a lot more

00:14:38,699 --> 00:14:45,059
discussion between the Linux kernel

00:14:41,909 --> 00:14:47,099
community and the GCC and G Lib C

00:14:45,059 --> 00:14:50,459
communities about how to ensure that

00:14:47,099 --> 00:14:52,349
this is this this infrastructure gets

00:14:50,459 --> 00:14:55,199
developed in a way that that everybody

00:14:52,349 --> 00:14:58,079
can can be comfortable with if not

00:14:55,199 --> 00:15:00,059
completely happy and you know and and

00:14:58,079 --> 00:15:02,519
another issue with processors and

00:15:00,059 --> 00:15:05,459
releases that new infrastructure goes

00:15:02,519 --> 00:15:07,739
into a processor how soon does that get

00:15:05,459 --> 00:15:09,659
a veil is that available in the compiler

00:15:07,739 --> 00:15:13,259
for supporting a kernel how soon is that

00:15:09,659 --> 00:15:15,659
available in the C library again with

00:15:13,259 --> 00:15:17,720
the the long term support and yet the

00:15:15,659 --> 00:15:19,649
processors have many many different

00:15:17,720 --> 00:15:22,489
optimizations and trade-offs and their

00:15:19,649 --> 00:15:25,529
pipelines how to provide the best

00:15:22,489 --> 00:15:28,049
stability to developers and to users

00:15:25,529 --> 00:15:29,819
while also providing the the most

00:15:28,049 --> 00:15:31,769
performance system that is available

00:15:29,819 --> 00:15:33,809
with the latest improvements and chips

00:15:31,769 --> 00:15:36,659
so that's the old questions that we have

00:15:33,809 --> 00:15:37,720
for issues and again you know free

00:15:36,659 --> 00:15:39,430
software is

00:15:37,720 --> 00:15:42,370
and everyone that that's the new

00:15:39,430 --> 00:15:45,220
toolchain it has all architectures and

00:15:42,370 --> 00:15:47,199
is ASR welcome and a huge number over 50

00:15:45,220 --> 00:15:50,529
are supported programming languages

00:15:47,199 --> 00:15:52,240
welcome to all a be eyes operating

00:15:50,529 --> 00:15:55,269
system and again all developers that the

00:15:52,240 --> 00:15:57,670
new tool chain provides a very you know

00:15:55,269 --> 00:16:00,610
welcoming environment and doesn't

00:15:57,670 --> 00:16:02,050
prioritize any particular group any

00:16:00,610 --> 00:16:04,360
particular set of developers a

00:16:02,050 --> 00:16:06,459
particular process or vendors or any

00:16:04,360 --> 00:16:08,819
particular operating system vendors it's

00:16:06,459 --> 00:16:11,410
an open environment that we welcome

00:16:08,819 --> 00:16:13,959
everybody to contribute to and look for

00:16:11,410 --> 00:16:16,839
discussion and then how to improve this

00:16:13,959 --> 00:16:19,029
collaboration given the you know great

00:16:16,839 --> 00:16:22,240
amount of interdependency that exists

00:16:19,029 --> 00:16:26,139
between the Linux community and the

00:16:22,240 --> 00:16:27,970
Linux kernel developers and the the tool

00:16:26,139 --> 00:16:30,160
chain for providing this environment

00:16:27,970 --> 00:16:31,480
that the the rest of the world knows

00:16:30,160 --> 00:16:33,850
about but doesn't necessarily know all

00:16:31,480 --> 00:16:37,170
the the bits and pieces and plumbing so

00:16:33,850 --> 00:16:37,170
that's it thanks very much

00:16:37,180 --> 00:16:41,900
[Applause]

00:16:42,000 --> 00:16:45,449
any question

00:16:51,210 --> 00:16:57,500
okay great so want to move on to the

00:16:54,210 --> 00:17:00,450
next speaker so we don't fall behind on

00:16:57,500 --> 00:17:01,310
okay so no question we can move to the

00:17:00,450 --> 00:17:04,550
next speaker

00:17:01,310 --> 00:17:04,550
thank you David

00:17:55,910 --> 00:18:00,280
first is the sample right yes

00:18:33,040 --> 00:18:38,060
use the feature in upcoming Intel

00:18:36,470 --> 00:18:42,820
processors

00:18:38,060 --> 00:18:52,670
it's called control flow enhancement

00:18:42,820 --> 00:18:56,510
technology so seed he has two components

00:18:52,670 --> 00:19:00,620
and was called shadow stack the other

00:18:56,510 --> 00:19:05,480
one is cut IB T stand for indirect

00:19:00,620 --> 00:19:09,650
branch cracking and I would describe

00:19:05,480 --> 00:19:16,130
those two features in upcoming slide so

00:19:09,650 --> 00:19:21,320
here is control flow it's in the use by

00:19:16,130 --> 00:19:26,800
CG and when is a return instruction and

00:19:21,320 --> 00:19:32,140
the other one is interact call or jump

00:19:26,800 --> 00:19:32,140
either through memory also register for

00:19:35,410 --> 00:19:44,140
shadow stack in xe6

00:19:40,040 --> 00:19:46,850
for the return address on the stack

00:19:44,140 --> 00:19:50,210
together with other informations of the

00:19:46,850 --> 00:19:55,370
of the function local variables insider

00:19:50,210 --> 00:20:00,140
and the shadows tag is we in the

00:19:55,370 --> 00:20:04,880
hardware maintain a separate stack the

00:20:00,140 --> 00:20:09,980
only thing in the shadow stack is the

00:20:04,880 --> 00:20:14,450
return address so when you do a function

00:20:09,980 --> 00:20:17,630
return the harder would check to see if

00:20:14,450 --> 00:20:21,230
the return address our shelter matches

00:20:17,630 --> 00:20:24,200
the return rates and the normal stack if

00:20:21,230 --> 00:20:31,490
you do not if they do met to not match

00:20:24,200 --> 00:20:36,730
you got fault that will present a

00:20:31,490 --> 00:20:42,490
challenge for the exception handling

00:20:36,730 --> 00:20:49,460
Satyam launch arm also the you context

00:20:42,490 --> 00:20:52,700
and basically you had to make sure when

00:20:49,460 --> 00:20:56,030
you adjust you are KOSDAQ you have to

00:20:52,700 --> 00:21:03,370
adjust your shadow stack by the same

00:20:56,030 --> 00:21:06,620
amount and this is basically how we are

00:21:03,370 --> 00:21:10,580
impressed supporting the accept handling

00:21:06,620 --> 00:21:14,330
and also in this ATM lounger we have to

00:21:10,580 --> 00:21:18,770
save and restore the year the first a

00:21:14,330 --> 00:21:21,020
pointer in the you contacts that is we

00:21:18,770 --> 00:21:23,990
are using the year we store token is

00:21:21,020 --> 00:21:26,900
part of the CDT featured foolish to

00:21:23,990 --> 00:21:34,490
switch to step between different new

00:21:26,900 --> 00:21:40,790
contacts let's talk about in the

00:21:34,490 --> 00:21:43,340
reference City with the

00:21:40,790 --> 00:21:47,420
interrupted branch cracking requires all

00:21:43,340 --> 00:21:51,080
the interact branch targets the must

00:21:47,420 --> 00:21:56,210
start with and branch instruction and

00:21:51,080 --> 00:22:01,520
that instruction is the know up the

00:21:56,210 --> 00:22:05,230
legacy processors and also we will have

00:22:01,520 --> 00:22:11,540
a no pre no tracked prefix to disable

00:22:05,230 --> 00:22:16,100
IPT and another way we can enabled

00:22:11,540 --> 00:22:22,240
legacy libraries we we can have a legacy

00:22:16,100 --> 00:22:27,260
bitmap to disabled I beat here per pound

00:22:22,240 --> 00:22:30,860
page between different branch basically

00:22:27,260 --> 00:22:34,510
the page the one page represent up one

00:22:30,860 --> 00:22:34,510
page in the Alexa bitmap

00:22:37,919 --> 00:22:47,860
so we have CG in the new processors we

00:22:43,539 --> 00:22:51,760
have existing software's either they can

00:22:47,860 --> 00:22:57,720
be total file in archive or they can be

00:22:51,760 --> 00:23:01,510
shared libraries so we have to make sure

00:22:57,720 --> 00:23:06,400
the one requirement is the Sidhe

00:23:01,510 --> 00:23:09,700
software it has to be backward

00:23:06,400 --> 00:23:13,000
compatible and forward compatible but

00:23:09,700 --> 00:23:17,980
there it means if you have an existing

00:23:13,000 --> 00:23:22,210
total file if you have existing share

00:23:17,980 --> 00:23:27,280
libraries you can still use them with

00:23:22,210 --> 00:23:31,740
other components which has it enabled of

00:23:27,280 --> 00:23:35,980
course you won't get protection but the

00:23:31,740 --> 00:23:39,070
resulting excuse or share library will

00:23:35,980 --> 00:23:42,340
still run correctly even on today's hard

00:23:39,070 --> 00:23:49,240
work today's processors and CD nibble

00:23:42,340 --> 00:23:55,360
processors so the way we do this we are

00:23:49,240 --> 00:23:57,809
saying if I come if a file can be a

00:23:55,360 --> 00:24:02,830
total file or share library if they are

00:23:57,809 --> 00:24:07,299
seat enabled they have to be marked so

00:24:02,830 --> 00:24:09,880
we introduce the new section in the

00:24:07,299 --> 00:24:13,960
Alpha it's a no section they are

00:24:09,880 --> 00:24:16,570
optional it will even see it he enabled

00:24:13,960 --> 00:24:19,330
we have two bits one for a bit heat the

00:24:16,570 --> 00:24:26,730
other one for Cheryl stack they will be

00:24:19,330 --> 00:24:34,120
marked so then the linker at what loader

00:24:26,730 --> 00:24:37,150
will make sure a file is seat enabled

00:24:34,120 --> 00:24:41,380
only if all the components are seat

00:24:37,150 --> 00:24:44,679
enabled so that's how we support mixer

00:24:41,380 --> 00:24:49,120
makes a match of different see it

00:24:44,679 --> 00:24:54,910
enabled Toto file share a breeze

00:24:49,120 --> 00:25:01,090
with other CDT legacy inputs and also

00:24:54,910 --> 00:25:05,160
the CDT neighbor programs binary

00:25:01,090 --> 00:25:08,710
compatible with legacy processors we are

00:25:05,160 --> 00:25:11,680
we have a kernel support and the loader

00:25:08,710 --> 00:25:13,840
support to check to see if you are

00:25:11,680 --> 00:25:17,350
running on the seed he can go so

00:25:13,840 --> 00:25:26,110
processors as well if the binary we are

00:25:17,350 --> 00:25:30,240
loading is enabled or not and yeah so

00:25:26,110 --> 00:25:35,580
this basically it's all the requirement

00:25:30,240 --> 00:25:37,780
we are putting together to support the

00:25:35,580 --> 00:25:40,420
compatibility between the older

00:25:37,780 --> 00:25:46,420
processor a new one and as well as all

00:25:40,420 --> 00:25:52,720
the new binaries so that how this is how

00:25:46,420 --> 00:25:57,370
we enable see it in GCC we place the end

00:25:52,720 --> 00:26:02,200
branch instruction in every potential in

00:25:57,370 --> 00:26:06,570
reference targets like global functions

00:26:02,200 --> 00:26:11,800
and or the static functions which are

00:26:06,570 --> 00:26:14,740
whose addresses are taken and we

00:26:11,800 --> 00:26:18,760
generally marker the no section say they

00:26:14,740 --> 00:26:22,360
are City enabled and also we provide a

00:26:18,760 --> 00:26:24,880
header file you can include you assembly

00:26:22,360 --> 00:26:31,140
code when you compile your assembly code

00:26:24,880 --> 00:26:35,320
with GCC when you say I've just enable

00:26:31,140 --> 00:26:38,820
CET with automatic place the marker in

00:26:35,320 --> 00:26:38,820
you our assembly output

00:26:41,440 --> 00:26:53,290
one time so this that went ham covers

00:26:48,850 --> 00:26:58,230
all enhance competitive see leave DCC

00:26:53,290 --> 00:27:03,820
lib at CDC plus any other ham libraries

00:26:58,230 --> 00:27:06,040
same thing if you have a function can be

00:27:03,820 --> 00:27:10,840
reached through the ear function pointer

00:27:06,040 --> 00:27:14,770
it has to start with an branch and also

00:27:10,840 --> 00:27:20,350
when you own one shadow stack and make

00:27:14,770 --> 00:27:23,530
sure you also on one deer you only the

00:27:20,350 --> 00:27:25,960
cost I also don't wanna shadows that and

00:27:23,530 --> 00:27:30,010
said yeah mount iam we all talk about

00:27:25,960 --> 00:27:33,400
this and also the new context we use

00:27:30,010 --> 00:27:42,910
restore token to switch between

00:27:33,400 --> 00:27:48,010
different shadow stacks so what takes to

00:27:42,910 --> 00:27:53,520
enable seed he in the application if you

00:27:48,010 --> 00:27:56,950
are writing C and C++ code they are no

00:27:53,520 --> 00:28:00,790
assembly code only seeing you neediest

00:27:56,950 --> 00:28:03,310
just compile with some color option

00:28:00,790 --> 00:28:06,190
that's the - you have seed heat

00:28:03,310 --> 00:28:11,230
protection icy air protection you will

00:28:06,190 --> 00:28:15,460
get CT protection automatically however

00:28:11,230 --> 00:28:17,800
if you have assembly code if just normal

00:28:15,460 --> 00:28:20,230
assembly code the honest you need is an

00:28:17,800 --> 00:28:25,240
branch on potential interrupt branch

00:28:20,230 --> 00:28:31,180
targets but if you are managing stacks

00:28:25,240 --> 00:28:33,960
yourselves then you need to also on one

00:28:31,180 --> 00:28:36,880
the shadow stack when you change stack

00:28:33,960 --> 00:28:42,130
of course it'll mark everything the CD

00:28:36,880 --> 00:28:46,080
enabled otherwise the combined the

00:28:42,130 --> 00:28:46,080
output will not be seeking able

00:28:48,210 --> 00:28:59,460
so this is the current status the city's

00:28:55,390 --> 00:29:05,049
back is available by doing Google search

00:28:59,460 --> 00:29:09,940
and in the process to put this it his

00:29:05,049 --> 00:29:13,630
back in the upcoming future eyes

00:29:09,940 --> 00:29:17,559
extensions they will be available in the

00:29:13,630 --> 00:29:21,700
part of the future Isis so see it he has

00:29:17,559 --> 00:29:27,639
been enabled in CCC eight and Beauty out

00:29:21,700 --> 00:29:32,320
2001 and he lives he 2.28 and we also

00:29:27,639 --> 00:29:36,610
have some our VM and our D changes we

00:29:32,320 --> 00:29:41,260
are working on to enable them in the sea

00:29:36,610 --> 00:29:43,510
lion as well the one thing about CD is

00:29:41,260 --> 00:29:44,649
because it is backward compatible and a

00:29:43,510 --> 00:29:47,409
for compatible

00:29:44,649 --> 00:29:49,840
you can enable CD you are always piece

00:29:47,409 --> 00:29:53,230
by piece you don't have to enable City

00:29:49,840 --> 00:29:57,490
in one shot of course your start with

00:29:53,230 --> 00:29:58,389
the GCC and T deep sea and then you can

00:29:57,490 --> 00:30:01,929
go from there

00:29:58,389 --> 00:30:06,190
and once you compile everything with -

00:30:01,929 --> 00:30:12,700
FC protection your whole as will be C

00:30:06,190 --> 00:30:15,760
enabled and we have kernel patch we are

00:30:12,700 --> 00:30:23,490
trying for upstream and the whole free

00:30:15,760 --> 00:30:24,669
soul we are working on that and that's

00:30:23,490 --> 00:30:32,460
separate

00:30:24,669 --> 00:30:32,460
Basia t any questions

00:30:37,149 --> 00:30:45,159
I have one question which is the plan

00:30:40,350 --> 00:30:48,700
for this CIT extension regarding new

00:30:45,159 --> 00:30:52,240
processors will be a baseline extension

00:30:48,700 --> 00:30:58,019
or will be something just for small

00:30:52,240 --> 00:31:04,990
status of chips that particular feature

00:30:58,019 --> 00:31:09,360
will be available in Tiger Lake and I

00:31:04,990 --> 00:31:13,809
have I I do not know when it'll be

00:31:09,360 --> 00:31:17,019
available mana standing this is a

00:31:13,809 --> 00:31:18,309
security feature we take security very

00:31:17,019 --> 00:31:22,059
seriously

00:31:18,309 --> 00:31:27,090
I believe starting from Tiger Li you

00:31:22,059 --> 00:31:31,889
will see sitting in orange of processors

00:31:27,090 --> 00:31:36,610
so the idea is you have the enable a

00:31:31,889 --> 00:31:42,399
distribution in the future so that is

00:31:36,610 --> 00:31:47,110
our hope we will right now we are

00:31:42,399 --> 00:31:51,010
working with well honda and started with

00:31:47,110 --> 00:31:55,179
federal 28 and if you are download

00:31:51,010 --> 00:31:59,799
things for atoning and today the GCC and

00:31:55,179 --> 00:32:04,210
gypsy has it enabled and if they are all

00:31:59,799 --> 00:32:07,240
properly marked they are I didn't count

00:32:04,210 --> 00:32:09,940
how many packages has been C it enabled

00:32:07,240 --> 00:32:13,120
back quite a lot as I said you do not

00:32:09,940 --> 00:32:16,450
need to enable CD you one shot you can

00:32:13,120 --> 00:32:19,090
enable piece by piece and you when you

00:32:16,450 --> 00:32:24,309
do a recompile make sure you come how

00:32:19,090 --> 00:32:27,700
with sheer protection then after you

00:32:24,309 --> 00:32:33,340
recover everything you are whole as you

00:32:27,700 --> 00:32:37,659
see it enabled and the thing is we

00:32:33,340 --> 00:32:43,690
measure the concise impact is minimum

00:32:37,659 --> 00:32:46,809
and because the shadow stack to compiler

00:32:43,690 --> 00:32:50,470
does not do anything special partial

00:32:46,809 --> 00:32:53,169
stack mostly and for the

00:32:50,470 --> 00:32:55,240
IBG you only need to put that four part

00:32:53,169 --> 00:32:58,900
no up at the beginning of a function

00:32:55,240 --> 00:33:02,909
global function so the overall cosine

00:32:58,900 --> 00:33:08,169
increase for most applications less than

00:33:02,909 --> 00:33:10,030
1% in some extreme case you have many

00:33:08,169 --> 00:33:16,900
many small functions you can get up to

00:33:10,030 --> 00:33:21,159
2% cause I increased for in terms of the

00:33:16,900 --> 00:33:23,380
performance we don't have a CG processor

00:33:21,159 --> 00:33:27,010
yet so we do not have CDT performance

00:33:23,380 --> 00:33:31,929
our CD processors but Sidhe enabled the

00:33:27,010 --> 00:33:34,000
application and legacy processors most

00:33:31,929 --> 00:33:37,919
of the performance difference are just

00:33:34,000 --> 00:33:42,220
within north range and but certain

00:33:37,919 --> 00:33:44,429
management may you may see up to 2% slow

00:33:42,220 --> 00:33:44,429
down

00:33:49,650 --> 00:33:59,550
I wanted to ask when you have a CT

00:33:54,980 --> 00:34:02,880
enabled application so it's been built

00:33:59,550 --> 00:34:06,750
linked does the operating system need to

00:34:02,880 --> 00:34:11,000
do something special to start in CT mode

00:34:06,750 --> 00:34:11,000
or does that happen automatically okay

00:34:11,450 --> 00:34:19,260
of course the always has to enables it

00:34:14,970 --> 00:34:23,159
if you are always not CDA enabled CT

00:34:19,260 --> 00:34:26,159
would not be enabled to enable dev OCD

00:34:23,159 --> 00:34:28,770
you need minimal enable I mean minimal

00:34:26,159 --> 00:34:33,990
effort swing at me two to three things

00:34:28,770 --> 00:34:36,510
in the car enable TCC when you configure

00:34:33,990 --> 00:34:39,540
TCC you had to do a stash their it

00:34:36,510 --> 00:34:42,990
neighbor said he they were enable seat

00:34:39,540 --> 00:34:46,230
here in GCC one time when you build

00:34:42,990 --> 00:34:49,500
tipsy you have to do conflict ellipse

00:34:46,230 --> 00:34:53,580
here with - that enables it here you

00:34:49,500 --> 00:34:56,790
will enable CD in you are tipsy once you

00:34:53,580 --> 00:35:01,110
do that when if you have a sequence

00:34:56,790 --> 00:35:02,850
Colonel changes upstream is done you

00:35:01,110 --> 00:35:05,220
will get automatic protection

00:35:02,850 --> 00:35:06,720
it's everything automatic you do not

00:35:05,220 --> 00:35:11,070
need to do anything

00:35:06,720 --> 00:35:13,890
yeah so the Fedora 20 I will say enable

00:35:11,070 --> 00:35:15,930
does that include the colonel changes no

00:35:13,890 --> 00:35:19,860
yes I can so it's just the user space

00:35:15,930 --> 00:35:23,700
has been compiled so in order to you can

00:35:19,860 --> 00:35:30,470
try you can get the colonel from the

00:35:23,700 --> 00:35:33,270
link there and 28:29 is as I said I mean

00:35:30,470 --> 00:35:37,920
probably it's a forty percent maybe

00:35:33,270 --> 00:35:40,310
Harvey lower I I didn't check really it

00:35:37,920 --> 00:35:43,050
being exactly how the percentage-wise

00:35:40,310 --> 00:35:45,810
that's fine I was just interested in how

00:35:43,050 --> 00:35:47,190
it got started so I now understand it

00:35:45,810 --> 00:35:50,810
needs the colonel changes and they're

00:35:47,190 --> 00:35:50,810
waiting to go slack thank you

00:35:50,820 --> 00:35:54,960
could you summarize what is the purpose

00:35:52,680 --> 00:35:56,910
of the end branch instruction I mean how

00:35:54,960 --> 00:36:00,300
is the processor using that information

00:35:56,910 --> 00:36:03,150
to mitigate what security problem

00:36:00,300 --> 00:36:05,309
exactly okay

00:36:03,150 --> 00:36:08,940
I have some backup slides so I don't

00:36:05,309 --> 00:36:13,099
know if I can go through that okay so

00:36:08,940 --> 00:36:16,619
basically this CG try to prevent the

00:36:13,099 --> 00:36:18,089
attack like this euros through stack

00:36:16,619 --> 00:36:21,930
Warped stack overflow

00:36:18,089 --> 00:36:24,779
and you see you have we have stack

00:36:21,930 --> 00:36:28,910
overflow the return address call what

00:36:24,779 --> 00:36:32,789
God overridden liked in this case and

00:36:28,910 --> 00:36:37,819
also the exodus six instruction can

00:36:32,789 --> 00:36:40,349
start from anywhere so then you call

00:36:37,819 --> 00:36:41,910
this normally this is the move

00:36:40,349 --> 00:36:45,239
instruction are you got something

00:36:41,910 --> 00:36:49,349
different and the shadows that will

00:36:45,239 --> 00:36:51,869
prevent when you return to something is

00:36:49,349 --> 00:36:54,900
not supposed to so that's that's one and

00:36:51,869 --> 00:36:59,160
also IBG will make sure when you do what

00:36:54,900 --> 00:37:03,710
jump if if you change somehow you are a

00:36:59,160 --> 00:37:08,969
pointer ad word the burial got changed

00:37:03,710 --> 00:37:12,329
may point to some wild place the end

00:37:08,969 --> 00:37:17,039
branch without and branch depth decoder

00:37:12,329 --> 00:37:18,719
place will be invalid target so then

00:37:17,039 --> 00:37:21,059
when the end branch instruction gets

00:37:18,719 --> 00:37:23,309
executed for the first time from an

00:37:21,059 --> 00:37:27,690
integrated branch somehow the processor

00:37:23,309 --> 00:37:30,420
can record it it records the know my

00:37:27,690 --> 00:37:34,289
understanding years in the Reverend

00:37:30,420 --> 00:37:37,049
target has to start with an branch if

00:37:34,289 --> 00:37:40,789
the first infra is not unbranched you

00:37:37,049 --> 00:37:47,700
got a fault okay yeah simply knows I

00:37:40,789 --> 00:37:50,630
think we are right now yeah yeah so we

00:37:47,700 --> 00:37:50,630
have next slide

00:38:19,460 --> 00:38:22,460
okay

00:38:35,850 --> 00:38:48,420
yeah so I can so

00:39:01,810 --> 00:39:10,930
so this talk is about the CPU Winningham

00:39:07,840 --> 00:39:14,470
and David already mentioned briefly

00:39:10,930 --> 00:39:18,550
about long the time between the support

00:39:14,470 --> 00:39:22,300
we put into open source project can be

00:39:18,550 --> 00:39:25,360
GCC or D deep sea and the time it

00:39:22,300 --> 00:39:29,680
reaches the end user it's can be several

00:39:25,360 --> 00:39:37,300
years so that's the issue work fun to

00:39:29,680 --> 00:39:43,450
address with this proposal today in hell

00:39:37,300 --> 00:39:46,750
IBM and different vendors they whip lot

00:39:43,450 --> 00:39:50,650
of efforts to oft mighty lips even hands

00:39:46,750 --> 00:39:55,120
specially the stream memory function for

00:39:50,650 --> 00:39:59,080
today's processor in case of India with

00:39:55,120 --> 00:40:03,120
Buddhism often edition with a BA X ages

00:39:59,080 --> 00:40:07,210
5-12 in her massive AFM FM a

00:40:03,120 --> 00:40:10,870
IDI all sounds great him car speed up in

00:40:07,210 --> 00:40:14,620
the 2x 4x whatever they are sound

00:40:10,870 --> 00:40:18,880
wonderful and however takes years to

00:40:14,620 --> 00:40:21,160
care to the end user and in the cloud in

00:40:18,880 --> 00:40:24,100
the enterprise environment the people

00:40:21,160 --> 00:40:28,840
are still using Enterprise Linux Red Hat

00:40:24,100 --> 00:40:35,560
like seven the arguing key deep sea 2000

00:40:28,840 --> 00:40:37,780
in there it is five years ago and now

00:40:35,560 --> 00:40:41,430
even we have to take a wonderful of

00:40:37,780 --> 00:40:44,470
meditation nobody really is using them

00:40:41,430 --> 00:40:47,470
and same thing will happen over and over

00:40:44,470 --> 00:40:51,670
again I with ham we put optimization in

00:40:47,470 --> 00:40:58,420
today you take five years to get to them

00:40:51,670 --> 00:41:06,130
to the end-user so I this is proposal to

00:40:58,420 --> 00:41:10,810
to address this particular issue so CP

00:41:06,130 --> 00:41:15,079
urban ham library and they get a subset

00:41:10,810 --> 00:41:19,789
of GDP see right now

00:41:15,079 --> 00:41:24,499
only optimized for Exodus in 64 I called

00:41:19,789 --> 00:41:28,119
a CPU at hit - Z potentially can be a -

00:41:24,499 --> 00:41:28,119
M for math library

00:41:28,489 --> 00:41:34,420
it is only contain memory stream

00:41:30,769 --> 00:41:39,890
functions nothing else it's binary

00:41:34,420 --> 00:41:43,099
compatible with any x86 you for sure

00:41:39,890 --> 00:41:49,940
libraries OSS by the compatible with

00:41:43,099 --> 00:41:55,239
CentOS 7 valve or even well 3 still

00:41:49,940 --> 00:41:58,969
people are still using them and so if

00:41:55,239 --> 00:42:02,180
anyone can use that it's very comparable

00:41:58,969 --> 00:42:05,209
just build the ones at part of the GDC

00:42:02,180 --> 00:42:10,670
build the same binary could be placed

00:42:05,209 --> 00:42:14,559
anywhere is just there are no dependency

00:42:10,670 --> 00:42:21,079
whatsoever it's totally self-contained

00:42:14,559 --> 00:42:24,769
to user you can use LD preload you and

00:42:21,079 --> 00:42:27,079
they whatever provided in the ellipse if

00:42:24,769 --> 00:42:30,039
you arty will override the system one

00:42:27,079 --> 00:42:33,680
and of course you can also link them

00:42:30,039 --> 00:42:40,029
directly in your application you will of

00:42:33,680 --> 00:42:40,029
course get the latest optimization

00:42:42,770 --> 00:42:51,589
we'd run some tests so this is a heart

00:42:48,589 --> 00:42:55,240
it's a dual circuit Haswell processor

00:42:51,589 --> 00:43:03,680
this year we pick the sandal s old one

00:42:55,240 --> 00:43:06,650
and well in GCC a and the this is we use

00:43:03,680 --> 00:43:09,500
the yeah the thing is this library only

00:43:06,650 --> 00:43:15,380
contain memories in functions so we pick

00:43:09,500 --> 00:43:16,430
the my secret test data because there's

00:43:15,380 --> 00:43:20,119
this database

00:43:16,430 --> 00:43:25,210
there are many string copy compare what

00:43:20,119 --> 00:43:25,210
are memory functions so this is

00:43:25,510 --> 00:43:40,250
basically the improvement we have seen

00:43:30,040 --> 00:43:50,140
and yeah it's a it's available and the

00:43:40,250 --> 00:44:03,800
other data so they are and I think yeah

00:43:50,140 --> 00:44:08,140
this yes so this library is very not

00:44:03,800 --> 00:44:13,000
very intrusive and is comparable

00:44:08,140 --> 00:44:16,220
everybody can use we are using existing

00:44:13,000 --> 00:44:17,060
tests we are not wearing anything from

00:44:16,220 --> 00:44:20,150
scratch

00:44:17,060 --> 00:44:25,790
we are we putting some infrastructure in

00:44:20,150 --> 00:44:29,390
the GD p-- sees three we take existing

00:44:25,790 --> 00:44:33,619
tests free framework we take existing

00:44:29,390 --> 00:44:41,300
well tested library the functions just

00:44:33,619 --> 00:44:46,640
make them available to everyone and yeah

00:44:41,300 --> 00:44:50,690
it's all this they up within deliver the

00:44:46,640 --> 00:44:53,690
best performance to anyone who want them

00:44:50,690 --> 00:44:56,240
they do not have to wait five years to

00:44:53,690 --> 00:45:00,320
get the gdb 22.1 day and they are

00:44:56,240 --> 00:45:02,750
today's connect server five years from

00:45:00,320 --> 00:45:11,320
now the ordering they are probably very

00:45:02,750 --> 00:45:18,849
different processors yeah that's

00:45:11,320 --> 00:45:22,700
basically what was what we found

00:45:18,849 --> 00:45:32,089
anything else and that's the standard in

00:45:22,700 --> 00:45:36,260
TLC yes okay so the first question would

00:45:32,089 --> 00:45:38,960
be regarding iPhones so big video video

00:45:36,260 --> 00:45:41,930
making this package so I have like three

00:45:38,960 --> 00:45:43,940
four different so when you're making the

00:45:41,930 --> 00:45:46,010
package are you actually building in the

00:45:43,940 --> 00:45:46,220
I funk resolver and everything else with

00:45:46,010 --> 00:45:49,310
it

00:45:46,220 --> 00:45:52,220
or just below okay our Punk

00:45:49,310 --> 00:45:56,420
everything is in there self-contained

00:45:52,220 --> 00:46:01,280
okay I found yes I found it is used so

00:45:56,420 --> 00:46:06,680
the second question is why not just have

00:46:01,280 --> 00:46:09,890
those things back port it already have

00:46:06,680 --> 00:46:10,410
you try there's there's no API break

00:46:09,890 --> 00:46:12,750
there

00:46:10,410 --> 00:46:16,080
which i've husband it's not going to

00:46:12,750 --> 00:46:18,360
happen they they they don't so I'm not

00:46:16,080 --> 00:46:24,330
gonna speak for Carlos I'm just saying

00:46:18,360 --> 00:46:27,180
no I if if you look at the changes we

00:46:24,330 --> 00:46:31,110
put in fun before I function what I

00:46:27,180 --> 00:46:38,760
receive I don't even want to ask two bad

00:46:31,110 --> 00:46:40,680
boys because they'll be there there's a

00:46:38,760 --> 00:46:43,740
technical issue and then there is the

00:46:40,680 --> 00:46:46,410
the safety the robustness issue because

00:46:43,740 --> 00:46:49,410
clearly you know it it's technically

00:46:46,410 --> 00:46:51,810
feasible to backports do it but

00:46:49,410 --> 00:46:53,970
especially in the enterprise I mean even

00:46:51,810 --> 00:46:56,910
if RedHat were willing to do it the

00:46:53,970 --> 00:46:59,580
question is then that that Intel and IBM

00:46:56,910 --> 00:47:01,790
and arm all want this out to enterprise

00:46:59,580 --> 00:47:05,640
class customers and those customers are

00:47:01,790 --> 00:47:07,560
not going to accept this type of place

00:47:05,640 --> 00:47:09,390
you know we've tested we verified the

00:47:07,560 --> 00:47:11,580
code we've gone through whatever with

00:47:09,390 --> 00:47:12,300
you know the banking you know regulators

00:47:11,580 --> 00:47:13,980
and everybody else

00:47:12,300 --> 00:47:19,470
oh we're just gonna throw in some new

00:47:13,980 --> 00:47:24,420
pieces of code I don't think so okay as

00:47:19,470 --> 00:47:26,090
a past maintainer it's not that we

00:47:24,420 --> 00:47:29,880
haven't done this in the past right

00:47:26,090 --> 00:47:32,820
maybe rel 7 is far too ahead because of

00:47:29,880 --> 00:47:35,070
which do that which leads me to the

00:47:32,820 --> 00:47:37,140
third question yes how do you package

00:47:35,070 --> 00:47:42,020
this and how do you deliver this to

00:47:37,140 --> 00:47:42,020
customers yes good question and

00:47:43,940 --> 00:47:52,590
originally okay

00:47:48,480 --> 00:47:55,410
it's other said it's part of right now

00:47:52,590 --> 00:47:57,780
it's part of GDP at a patch okay it's

00:47:55,410 --> 00:48:01,080
it's a branch you sitting on a branch

00:47:57,780 --> 00:48:04,470
party the third of GDP see the all right

00:48:01,080 --> 00:48:06,900
now the only way you can build is you

00:48:04,470 --> 00:48:12,450
build it as a separate library when you

00:48:06,900 --> 00:48:16,800
built it you see so how do we package it

00:48:12,450 --> 00:48:22,560
so and with about six months maybe more

00:48:16,800 --> 00:48:24,000
ago I try to patch and I don't think

00:48:22,560 --> 00:48:27,290
that the eyes agreement

00:48:24,000 --> 00:48:32,010
if we if we wonder in GDP or not

00:48:27,290 --> 00:48:35,610
but I too believe at least for the Intel

00:48:32,010 --> 00:48:38,720
customers because I almost got an email

00:48:35,610 --> 00:48:42,600
either external internal email asking

00:48:38,720 --> 00:48:45,420
why the mem copy mem says so slow ask

00:48:42,600 --> 00:48:48,840
Alec server you know things like that

00:48:45,420 --> 00:48:54,900
performance-wise so there clearly

00:48:48,840 --> 00:48:58,440
there's customer interest so the one way

00:48:54,900 --> 00:49:01,850
to edit because this is a binary

00:48:58,440 --> 00:49:07,920
compatible with every single available

00:49:01,850 --> 00:49:11,520
Exodus X OSS we were we were thinking

00:49:07,920 --> 00:49:14,300
with just built binary of course every

00:49:11,520 --> 00:49:18,230
service forest on github is not question

00:49:14,300 --> 00:49:21,930
if you do know if you are os you are

00:49:18,230 --> 00:49:24,120
compiler you are linkers are too old to

00:49:21,930 --> 00:49:27,920
build that so yourself

00:49:24,120 --> 00:49:32,130
we make the pre-built binary available

00:49:27,920 --> 00:49:35,910
say uncle Howard you just download right

00:49:32,130 --> 00:49:38,220
so which which brings me to the previous

00:49:35,910 --> 00:49:39,990
point where you're not actually

00:49:38,220 --> 00:49:42,750
providing something that is supportable

00:49:39,990 --> 00:49:46,050
in the wrong long term it's something

00:49:42,750 --> 00:49:52,440
that you're providing as a stopgap until

00:49:46,050 --> 00:49:56,070
it's a next yeah so which is which is

00:49:52,440 --> 00:49:58,650
the reason why I would have like a mild

00:49:56,070 --> 00:50:01,080
objection to having something like that

00:49:58,650 --> 00:50:05,310
in the gilepsy sources because it's it's

00:50:01,080 --> 00:50:08,000
kind of like a stopgap for now and we

00:50:05,310 --> 00:50:10,140
probably won't need it ahead

00:50:08,000 --> 00:50:14,580
well that's that's the only reservation

00:50:10,140 --> 00:50:18,990
okay okay maybe the current one is stock

00:50:14,580 --> 00:50:21,800
up for today but the same thing will

00:50:18,990 --> 00:50:21,800
happen in five years

00:50:28,060 --> 00:50:34,700
some of these key routines to go into

00:50:30,920 --> 00:50:37,790
Lib CP u RT and become something like

00:50:34,700 --> 00:50:40,880
lippy thread that falls out from lip C

00:50:37,790 --> 00:50:43,369
or Libin yeah for example certainly

00:50:40,880 --> 00:50:45,440
certainly that that's that is that is

00:50:43,369 --> 00:50:47,810
where this should probably be good I

00:50:45,440 --> 00:50:52,190
think but it's me it's more

00:50:47,810 --> 00:50:55,550
controversial I would say no so I mean a

00:50:52,190 --> 00:50:58,670
better a better option in my opinion

00:50:55,550 --> 00:51:01,460
would be to kind of reduce the footprint

00:50:58,670 --> 00:51:03,740
of each of those routines like so all of

00:51:01,460 --> 00:51:05,390
these iPhone routines are essentially

00:51:03,740 --> 00:51:07,880
like so there's this one routine that

00:51:05,390 --> 00:51:10,130
you want a back port for skylake and the

00:51:07,880 --> 00:51:12,470
impact for that routine is basically

00:51:10,130 --> 00:51:16,310
going to be just skylight processes so

00:51:12,470 --> 00:51:19,550
it's it's not going to have as wide an

00:51:16,310 --> 00:51:23,180
impact as everyone fears it to be

00:51:19,550 --> 00:51:25,970
alright so so which is the reason why my

00:51:23,180 --> 00:51:30,550
first question was that it's an iPhone

00:51:25,970 --> 00:51:33,140
or so okay so there are there are two

00:51:30,550 --> 00:51:38,089
aspects to this there's there's the x86

00:51:33,140 --> 00:51:42,140
i func and then there's my funk right so

00:51:38,089 --> 00:51:45,020
for x86 a lot of the iPhone facility is

00:51:42,140 --> 00:51:47,329
there as in what what you probably need

00:51:45,020 --> 00:51:50,060
to do is back put the routine and you're

00:51:47,329 --> 00:51:51,920
done with it arm is a lot more complex

00:51:50,060 --> 00:51:53,540
which is the reason why I'm not even

00:51:51,920 --> 00:51:55,640
getting arm into the picture because um

00:51:53,540 --> 00:51:57,530
you'll have to get all of the MIT our

00:51:55,640 --> 00:52:00,200
stuff in you have to get all of the

00:51:57,530 --> 00:52:05,380
tunable stuff in and then yeah exactly

00:52:00,200 --> 00:52:05,380
that's future

00:52:13,670 --> 00:52:21,890
the string routines inside lip CPU our

00:52:19,160 --> 00:52:24,589
team and then you know five years from

00:52:21,890 --> 00:52:26,170
now it's no longer an issue it will be a

00:52:24,589 --> 00:52:29,089
problem for the next new architecture

00:52:26,170 --> 00:52:33,160
probably because they may have issues

00:52:29,089 --> 00:52:33,160
with backporting their eye funk stuff

00:52:39,549 --> 00:52:44,839
okay maybe we are monopolizing the Sun

00:52:42,440 --> 00:52:47,630
maybe we should let other people ask

00:52:44,839 --> 00:52:48,950
questions on this I just want to clarify

00:52:47,630 --> 00:52:52,309
one thing

00:52:48,950 --> 00:52:56,450
okay and probably what you mention is

00:52:52,309 --> 00:52:59,329
arm kind of arms passive issue for x86

00:52:56,450 --> 00:53:05,329
is not a real big issue in terms

00:52:59,329 --> 00:53:09,650
I found instrumentation and before did

00:53:05,329 --> 00:53:11,750
it sit to the 28th waylaid groundwork to

00:53:09,650 --> 00:53:16,119
make that possible that's why I'm the

00:53:11,750 --> 00:53:21,079
backporting made so we laid groundwork

00:53:16,119 --> 00:53:24,740
in such a way what we what really

00:53:21,079 --> 00:53:28,789
happened in the cprt is we have an init

00:53:24,740 --> 00:53:34,670
function it call it clack all the CPU

00:53:28,789 --> 00:53:36,920
data and it store somewhere and we use

00:53:34,670 --> 00:53:40,400
that piece of information to in hand I

00:53:36,920 --> 00:53:43,009
find it's straightforward very I won't

00:53:40,400 --> 00:53:45,500
say simple but it's very straightforward

00:53:43,009 --> 00:53:47,599
that over has minimal of core to play

00:53:45,500 --> 00:53:51,980
some cosines include that's that's a

00:53:47,599 --> 00:53:55,970
given other than that I equity 6i to now

00:53:51,980 --> 00:53:59,480
see a maintenance issue as I said we do

00:53:55,970 --> 00:54:02,000
not buy any three memory functions we

00:53:59,480 --> 00:54:04,849
just take whatever is in GD p-- see

00:54:02,000 --> 00:54:10,420
we're putting today make her available

00:54:04,849 --> 00:54:10,420
to our customers not five years from now

00:54:11,200 --> 00:54:17,020
but two novels have been mentioned right

00:54:14,740 --> 00:54:19,299
for example and then you say that the

00:54:17,020 --> 00:54:21,880
the a Frank functionality that you rely

00:54:19,299 --> 00:54:23,440
on in the in this library self-contained

00:54:21,880 --> 00:54:26,880
in temporary libraries right

00:54:23,440 --> 00:54:30,309
but for what with architectures were

00:54:26,880 --> 00:54:32,799
political for example in rel we don't

00:54:30,309 --> 00:54:38,819
have tunable supporting deliver z170a

00:54:32,799 --> 00:54:41,260
217 for example so I mean what other

00:54:38,819 --> 00:54:43,420
than their string routines that you

00:54:41,260 --> 00:54:45,309
already have in your library what else

00:54:43,420 --> 00:54:50,680
do you plan to move there or to make it

00:54:45,309 --> 00:54:53,680
available yeah yeah so because what

00:54:50,680 --> 00:54:59,470
nothing for example relying on tuna

00:54:53,680 --> 00:55:01,720
balls will work in all versions of

00:54:59,470 --> 00:55:05,440
delivery depending on for example on

00:55:01,720 --> 00:55:10,809
tuna balls I believe I didn't mention

00:55:05,440 --> 00:55:16,210
that I believe they are to GD to Naboo

00:55:10,809 --> 00:55:19,869
is all supported I think I would say yes

00:55:16,210 --> 00:55:24,670
I think so yeah inside yes that's the

00:55:19,869 --> 00:55:28,150
way we increment okay okay so you are

00:55:24,670 --> 00:55:34,450
providing for a complete compatibility

00:55:28,150 --> 00:55:36,369
library then yeah we are how its kind of

00:55:34,450 --> 00:55:38,170
complete if so then I will s top

00:55:36,369 --> 00:55:41,049
backpack porting and just preload your

00:55:38,170 --> 00:55:42,540
library yes do that that's the whole

00:55:41,049 --> 00:55:44,740
idea

00:55:42,540 --> 00:55:49,480
okay so that means that you do the work

00:55:44,740 --> 00:55:58,569
instead of us we make that available and

00:55:49,480 --> 00:55:59,920
CPU RT back to your customers yes that's

00:55:58,569 --> 00:56:03,490
the fundamental question here

00:55:59,920 --> 00:56:05,290
it's sorry the fund that's the fund I

00:56:03,490 --> 00:56:07,240
keep going back to that like a broken

00:56:05,290 --> 00:56:09,880
record but that's really the fundamental

00:56:07,240 --> 00:56:11,470
question here because whatever we say

00:56:09,880 --> 00:56:13,750
about you know bills and whatnot

00:56:11,470 --> 00:56:16,119
today it's today's problem tomorrow we

00:56:13,750 --> 00:56:16,869
may have something else so how do we

00:56:16,119 --> 00:56:18,700
keep this going

00:56:16,869 --> 00:56:21,990
it is the problem of new features going

00:56:18,700 --> 00:56:26,280
back or wanting a time machine

00:56:21,990 --> 00:56:28,619
yeah well this is too good to give it

00:56:26,280 --> 00:56:31,530
fire though I was on our links to where

00:56:28,619 --> 00:56:34,230
you can guess it and regarding to to

00:56:31,530 --> 00:56:36,630
that point about rel we have been facing

00:56:34,230 --> 00:56:38,609
this with even Carlos about some of the

00:56:36,630 --> 00:56:40,619
features that are already implemented in

00:56:38,609 --> 00:56:43,320
gilepsy they're not being used very

00:56:40,619 --> 00:56:45,810
often like in theses example it has been

00:56:43,320 --> 00:56:48,260
proposed to the patch since when since -

00:56:45,810 --> 00:56:51,450
what two months ago like a month ago

00:56:48,260 --> 00:56:53,760
more than two months ago so it's going

00:56:51,450 --> 00:56:58,200
to be at some point maybe merge it into

00:56:53,760 --> 00:56:59,730
gypsy master me and the point is these

00:56:58,200 --> 00:57:01,740
were this was a panel about to do the

00:56:59,730 --> 00:57:03,810
call-out to the distribution - you

00:57:01,740 --> 00:57:05,670
actually use these kind of features that

00:57:03,810 --> 00:57:07,830
has been enabled not only really

00:57:05,670 --> 00:57:10,250
receivables he also on compiler section

00:57:07,830 --> 00:57:15,270
and so on to provide out to customers

00:57:10,250 --> 00:57:18,420
yeah so there are two aspects first out

00:57:15,270 --> 00:57:20,730
to address so I named it defunct that

00:57:18,420 --> 00:57:24,180
library cause if you are a cheater see

00:57:20,730 --> 00:57:28,040
so I implied potentially can be - em

00:57:24,180 --> 00:57:30,720
like arm has continued a lot of new

00:57:28,040 --> 00:57:35,609
optimization form attribute potentially

00:57:30,720 --> 00:57:38,280
can be added if someone wants and again

00:57:35,609 --> 00:57:40,619
we've got to decide what this looks like

00:57:38,280 --> 00:57:43,650
that's that's the question we can't have

00:57:40,619 --> 00:57:45,420
practical backwards into this we've got

00:57:43,650 --> 00:57:47,010
to give a structure to this are we

00:57:45,420 --> 00:57:49,980
saying that it's going to just replace

00:57:47,010 --> 00:57:52,740
all of you know you just back put

00:57:49,980 --> 00:57:56,510
anything you want into that if you have

00:57:52,740 --> 00:57:59,220
to be careful about this around this

00:57:56,510 --> 00:58:03,570
there's no back talk at all in my in

00:57:59,220 --> 00:58:12,410
this proposal that no back porno but can

00:58:03,570 --> 00:58:14,910
we take any last question for this okay

00:58:12,410 --> 00:58:21,489
great thank you thank you

00:58:14,910 --> 00:58:21,489
[Applause]

00:59:36,490 --> 00:59:39,119
okay

00:59:57,300 --> 01:00:00,620
hello testing

01:00:12,310 --> 01:00:15,790
is it working now

01:00:17,110 --> 01:00:31,370
okay it's working okay so hello my name

01:00:23,630 --> 01:00:32,810
is speak louder speak louder is it work

01:00:31,370 --> 01:00:39,230
now it's better

01:00:32,810 --> 01:00:41,180
okay so my presentation now is it's more

01:00:39,230 --> 01:00:43,460
than requests for comments how we're

01:00:41,180 --> 01:00:46,430
gonna improve the kernel and jenissi

01:00:43,460 --> 01:00:49,640
relationship to solve some long-standing

01:00:46,430 --> 01:00:54,020
issues that come up on the mail list

01:00:49,640 --> 01:00:56,330
recently and often and often how it will

01:00:54,020 --> 01:00:58,760
not implement the features that gdb

01:00:56,330 --> 01:00:59,480
selects that kind of support for a long

01:00:58,760 --> 01:01:04,580
time

01:00:59,480 --> 01:01:07,790
for instance the Tamayo to how we

01:01:04,580 --> 01:01:10,160
organize and synchronize the kernel

01:01:07,790 --> 01:01:14,210
headers and kind of features with do you

01:01:10,160 --> 01:01:18,740
see and how we solve this communication

01:01:14,210 --> 01:01:20,990
problems that seems to have between the

01:01:18,740 --> 01:01:22,820
can developers and Anu to change

01:01:20,990 --> 01:01:25,610
developers that sometimes we see that

01:01:22,820 --> 01:01:29,000
they are working separately and not

01:01:25,610 --> 01:01:31,160
communicate correctly and my

01:01:29,000 --> 01:01:33,800
presentation is we have are going to

01:01:31,160 --> 01:01:37,340
show various issues that we have and

01:01:33,800 --> 01:01:41,210
very discussions and I would like some

01:01:37,340 --> 01:01:43,160
candle input because we need that input

01:01:41,210 --> 01:01:46,490
otherwise we're going to talk with each

01:01:43,160 --> 01:01:50,390
other and let's start with the first one

01:01:46,490 --> 01:01:56,420
which is Cisco's robbers it kind came

01:01:50,390 --> 01:02:00,020
recently on our gypsy mailing list and

01:01:56,420 --> 01:02:06,410
how we gonna provide the latest minutes

01:02:00,020 --> 01:02:09,560
to skulls on JDBC so the idea is should

01:02:06,410 --> 01:02:12,290
we provide a team wrapper with any

01:02:09,560 --> 01:02:16,700
delete see or any lips interaction

01:02:12,290 --> 01:02:17,880
should be what about the others sis

01:02:16,700 --> 01:02:20,440
calls

01:02:17,880 --> 01:02:25,660
posix and the standards requirements

01:02:20,440 --> 01:02:28,059
like for our no pthread consolation kind

01:02:25,660 --> 01:02:31,240
of optional flags that we set you avoid

01:02:28,059 --> 01:02:36,040
old a be eyes or in some deceased sees

01:02:31,240 --> 01:02:38,619
the IP see how we're gonna handle cisco

01:02:36,040 --> 01:02:42,790
fallback implementation for instance by

01:02:38,619 --> 01:02:48,579
using here so by provided distinct

01:02:42,790 --> 01:02:51,280
wrapper how can I handle this of T Colin

01:02:48,579 --> 01:02:53,829
collation differences which is for now

01:02:51,280 --> 01:02:58,359
now we're gonna have the time and time T

01:02:53,829 --> 01:03:00,609
so the question I'll ask you from the

01:02:58,359 --> 01:03:03,339
kernel point of view should we provide

01:03:00,609 --> 01:03:05,380
this team wrapper is it something that

01:03:03,339 --> 01:03:12,700
delete this issue should provide or

01:03:05,380 --> 01:03:15,309
something that can or should provide so

01:03:12,700 --> 01:03:18,579
I have initiated this particular

01:03:15,309 --> 01:03:24,309
discussion at least twice I believe I'm

01:03:18,579 --> 01:03:28,390
H Peter and then I believe that this

01:03:24,309 --> 01:03:31,119
most sensible thing to do is for these

01:03:28,390 --> 01:03:33,730
is for the things that don't have Lib C

01:03:31,119 --> 01:03:37,660
dependencies I believe that this should

01:03:33,730 --> 01:03:43,329
be in the kernel tree and the reason for

01:03:37,660 --> 01:03:46,329
that is that a lot of these things don't

01:03:43,329 --> 01:03:51,809
aren't dependent on any particular

01:03:46,329 --> 01:03:59,490
Lindsay and the other reason is that

01:03:51,809 --> 01:04:04,089
just the tie tying them together it

01:03:59,490 --> 01:04:07,140
inevitably causes delay and not only

01:04:04,089 --> 01:04:09,430
does it cause delay but it causes

01:04:07,140 --> 01:04:14,829
distributions to be a lot more nervous

01:04:09,430 --> 01:04:17,940
about release about releasing them so I

01:04:14,829 --> 01:04:24,089
think we are I think we're able to do a

01:04:17,940 --> 01:04:27,430
much better job at keeping a Lib kernel

01:04:24,089 --> 01:04:30,440
cloak cloak more more closely aligned

01:04:27,430 --> 01:04:33,079
with the kernel in practice

01:04:30,440 --> 01:04:36,950
and it would be even possible to do in

01:04:33,079 --> 01:04:41,150
gypsy do you mean by provide a library

01:04:36,950 --> 01:04:46,670
itself or a VDS so like interface but

01:04:41,150 --> 01:04:53,000
someone suggested on the mail list I

01:04:46,670 --> 01:04:57,260
mean a library video sells video so

01:04:53,000 --> 01:05:00,260
entries are highly useful when they are

01:04:57,260 --> 01:05:03,099
you know when they're necessary whether

01:05:00,260 --> 01:05:06,470
or not you want to do video so

01:05:03,099 --> 01:05:12,010
specifically for this or for things that

01:05:06,470 --> 01:05:16,030
aren't necessarily going to be used

01:05:12,010 --> 01:05:17,869
that's another that's another matter

01:05:16,030 --> 01:05:23,650
entirely

01:05:17,869 --> 01:05:23,650
I need to think about that

01:05:28,510 --> 01:05:31,809
so I think it could even just be a what

01:05:30,550 --> 01:05:35,680
a single header file with inline

01:05:31,809 --> 01:05:37,359
functions and we can probably come up

01:05:35,680 --> 01:05:40,599
with a way to generate those in that

01:05:37,359 --> 01:05:45,970
function soon I'm working with mono my

01:05:40,599 --> 01:05:48,520
colleagues on a way to generate the Uni

01:05:45,970 --> 01:05:51,609
STD dot H header files from an

01:05:48,520 --> 01:05:53,920
architecture independent description

01:05:51,609 --> 01:05:56,050
file that we already have on x86 and

01:05:53,920 --> 01:05:57,579
some other architectures and we want to

01:05:56,050 --> 01:06:00,069
have it and all the architectures will

01:05:57,579 --> 01:06:01,720
soon have that and at that point should

01:06:00,069 --> 01:06:03,550
become a lot easier to generate

01:06:01,720 --> 01:06:05,410
something from the descriptions we

01:06:03,550 --> 01:06:08,260
already have in the kernel and one of

01:06:05,410 --> 01:06:11,319
those outputs could be a library or a

01:06:08,260 --> 01:06:14,589
header file and they had a file would be

01:06:11,319 --> 01:06:16,900
kind of strange because if we put it in

01:06:14,589 --> 01:06:20,800
the kernel head us it would still have a

01:06:16,900 --> 01:06:22,569
dependency on the C library for calling

01:06:20,800 --> 01:06:23,890
the syscall function because every

01:06:22,569 --> 01:06:25,720
architecture is a different way of

01:06:23,890 --> 01:06:29,800
passing the arguments back into the

01:06:25,720 --> 01:06:31,180
kernel but we could have that as DX plus

01:06:29,800 --> 01:06:34,660
one of the exported kernel that had us

01:06:31,180 --> 01:06:37,150
just a set of functions where each

01:06:34,660 --> 01:06:38,589
function goes back to this call to

01:06:37,150 --> 01:06:41,920
employed one of the Eternals just calls

01:06:38,589 --> 01:06:46,930
that we have so I already have that

01:06:41,920 --> 01:06:49,690
mechanism built from from Caleb C and

01:06:46,930 --> 01:06:53,559
that's part of why I believe that it

01:06:49,690 --> 01:07:00,030
would be better to do it as a as an

01:06:53,559 --> 01:07:04,930
actual library because it gets kind of

01:07:00,030 --> 01:07:07,180
it does get kind of excessive to do that

01:07:04,930 --> 01:07:09,520
sort of stuff in the video so it will

01:07:07,180 --> 01:07:11,829
grow the video so considerably I

01:07:09,520 --> 01:07:14,440
wouldn't do it in video so I was just no

01:07:11,829 --> 01:07:17,260
but this stuff can be done in a library

01:07:14,440 --> 01:07:20,530
in a way that is not dependent on

01:07:17,260 --> 01:07:24,280
calling Cisco syscall 3 which by the way

01:07:20,530 --> 01:07:26,859
is inherently broken on certain

01:07:24,280 --> 01:07:32,260
architectures we could also put this is

01:07:26,859 --> 01:07:37,470
called 3 into a video so equivalent of

01:07:32,260 --> 01:07:37,470
that no it's not that simple

01:07:37,970 --> 01:07:46,290
syscall three on some architectures can

01:07:42,330 --> 01:07:53,160
only be implemented by having a per

01:07:46,290 --> 01:07:57,540
system call stub my next question is do

01:07:53,160 --> 01:07:59,430
we have six calls now that if she does

01:07:57,540 --> 01:08:05,970
not do not provide that are actually

01:07:59,430 --> 01:08:08,210
useful and what prevent us to provide

01:08:05,970 --> 01:08:08,210
them

01:08:13,430 --> 01:08:18,680
it's an open question the mount API

01:08:16,790 --> 01:08:26,360
maybe that would be the first thing that

01:08:18,680 --> 01:08:29,270
comes to mind we just added okay so the

01:08:26,360 --> 01:08:32,060
reason why this call 3 is is

01:08:29,270 --> 01:08:36,190
fundamentally broken is that well first

01:08:32,060 --> 01:08:38,240
of all it is it is a bi dependent and

01:08:36,190 --> 01:08:39,410
different architectures will have

01:08:38,240 --> 01:08:42,400
different a BIS

01:08:39,410 --> 01:08:49,300
the second problem is that on

01:08:42,400 --> 01:08:52,960
architectures that do alignment of of

01:08:49,300 --> 01:08:57,470
argument that are 64 bits on 32 bits

01:08:52,960 --> 01:09:01,880
architectures the insertion of the

01:08:57,470 --> 01:09:04,280
syscall number in cisco 3 will be

01:09:01,880 --> 01:09:06,830
aligned the rest of them so you have the

01:09:04,280 --> 01:09:09,230
wrong alignment and you now will have

01:09:06,830 --> 01:09:13,820
the ABI insert padding's in the wrong

01:09:09,230 --> 01:09:16,870
places you could sort of fix that by

01:09:13,820 --> 01:09:20,870
making the Rd syscall argument

01:09:16,870 --> 01:09:28,160
excessively large that has its own

01:09:20,870 --> 01:09:30,710
issues obviously okay so aligned with

01:09:28,160 --> 01:09:33,310
the current discussion is do we need

01:09:30,710 --> 01:09:37,400
formal description for this is calls

01:09:33,310 --> 01:09:39,110
just an argument for using the video so

01:09:37,400 --> 01:09:41,420
it makes it really easy to check out

01:09:39,110 --> 01:09:44,840
runtime what that exact kernel supports

01:09:41,420 --> 01:09:47,890
right it's like is this Cisco variable

01:09:44,840 --> 01:09:47,890
now becomes a Gaussian

01:09:51,620 --> 01:09:58,170
okay so we need the form of this

01:09:55,920 --> 01:10:02,670
equation for the cisco's is it something

01:09:58,170 --> 01:10:05,010
that the candle would provide because

01:10:02,670 --> 01:10:07,910
from the DC standpoint if we have this

01:10:05,010 --> 01:10:11,310
kind of information it might simplify

01:10:07,910 --> 01:10:13,830
our new inclusions and our internal

01:10:11,310 --> 01:10:16,650
machinery to discover what the Sisko is

01:10:13,830 --> 01:10:23,550
provided by the kind of Heather's yeah

01:10:16,650 --> 01:10:27,810
we are already working on that it's a we

01:10:23,550 --> 01:10:30,750
if you need additional information it

01:10:27,810 --> 01:10:32,400
would be good to work with you to make

01:10:30,750 --> 01:10:36,290
sure that that information actually is

01:10:32,400 --> 01:10:36,290
there okay thank you

01:10:37,940 --> 01:10:45,600
so the next thing with it was also

01:10:41,910 --> 01:10:48,210
discussed on the mail list is it be it

01:10:45,600 --> 01:10:50,370
will be good to have consistent can you

01:10:48,210 --> 01:10:54,000
support for other cheap independent sis

01:10:50,370 --> 01:10:56,700
calls for instance when the kernel

01:10:54,000 --> 01:10:58,770
defines a nuisance call it should be

01:10:56,700 --> 01:11:02,790
included on all the architectures at the

01:10:58,770 --> 01:11:05,370
same time this issue is to bite us on

01:11:02,790 --> 01:11:07,200
the recent releases we just find out for

01:11:05,370 --> 01:11:10,350
me so that this park has some issues

01:11:07,200 --> 01:11:14,700
with the sub not optimize these calls

01:11:10,350 --> 01:11:19,350
right up and I think arm has has

01:11:14,700 --> 01:11:21,270
discussed this about what kind of work

01:11:19,350 --> 01:11:23,580
you are doing - yeah I haven't really

01:11:21,270 --> 01:11:25,830
gotten a lot of feedback about this but

01:11:23,580 --> 01:11:28,560
the the idea that I brought up is that

01:11:25,830 --> 01:11:30,480
when we add the new 20 system calls for

01:11:28,560 --> 01:11:34,830
2038 at the same time we also make sure

01:11:30,480 --> 01:11:37,080
that all the architectures support a

01:11:34,830 --> 01:11:39,570
common subset of system concept they

01:11:37,080 --> 01:11:41,640
currently don't basically everything

01:11:39,570 --> 01:11:43,170
that's in the Asthma generic file would

01:11:41,640 --> 01:11:45,360
also be available on every single

01:11:43,170 --> 01:11:47,400
architecture they might have additional

01:11:45,360 --> 01:11:48,720
ones that are duplicates of those and

01:11:47,400 --> 01:11:52,250
the additional ones that architecture is

01:11:48,720 --> 01:11:55,620
specific and make no sense everywhere

01:11:52,250 --> 01:11:57,900
but what about the other with Cisco's we

01:11:55,620 --> 01:12:00,300
will be something that the kernel would

01:11:57,900 --> 01:12:03,860
pursue so they yeah

01:12:00,300 --> 01:12:06,510
my ideal idea for the

01:12:03,860 --> 01:12:09,750
for any future system calls would be

01:12:06,510 --> 01:12:12,450
that we add at least the system call

01:12:09,750 --> 01:12:15,510
numbers at the same time for everyone

01:12:12,450 --> 01:12:17,840
but probably that also implies we add we

01:12:15,510 --> 01:12:20,540
hook them up at the same time right

01:12:17,840 --> 01:12:25,140
there's an interesting question about

01:12:20,540 --> 01:12:26,940
whether we keep doing what we've done

01:12:25,140 --> 01:12:30,090
forever which is to define an

01:12:26,940 --> 01:12:32,960
architecture independent number for each

01:12:30,090 --> 01:12:38,910
system call all we decide at this point

01:12:32,960 --> 01:12:42,090
to take may make a break in the and the

01:12:38,910 --> 01:12:44,330
way we handle it and make all the future

01:12:42,090 --> 01:12:51,360
numbers the same across architectures

01:12:44,330 --> 01:12:54,090
which would not be a big issue I think

01:12:51,360 --> 01:12:56,790
it could just when you already

01:12:54,090 --> 01:12:59,010
synchronize everything we have around

01:12:56,790 --> 01:13:01,410
300 system calls on all of them so if

01:12:59,010 --> 01:13:03,420
you just pick whichever architecture has

01:13:01,410 --> 01:13:05,640
the most and assign numbers from there

01:13:03,420 --> 01:13:07,980
on that would be very easy

01:13:05,640 --> 01:13:09,150
we still would probably have two

01:13:07,980 --> 01:13:11,970
different ones we have to add some

01:13:09,150 --> 01:13:15,020
generic which has 100 fewer system calls

01:13:11,970 --> 01:13:17,700
then the the ones that came before it

01:13:15,020 --> 01:13:21,240
but we would still have only two

01:13:17,700 --> 01:13:24,330
different numbers that are possible it's

01:13:21,240 --> 01:13:26,550
not a problem the problem is you have to

01:13:24,330 --> 01:13:29,030
handle different architectures that has

01:13:26,550 --> 01:13:32,670
different syscalls

01:13:29,030 --> 01:13:35,670
wired up in different versions yeah I

01:13:32,670 --> 01:13:38,580
don't think you can use the same syscall

01:13:35,670 --> 01:13:41,840
number for some architectures it won't

01:13:38,580 --> 01:13:45,030
work for example permits let's have like

01:13:41,840 --> 01:13:47,970
you know what you had for me but it

01:13:45,030 --> 01:13:50,070
would have to be the the offset from the

01:13:47,970 --> 01:13:53,070
starting number don't you have the 3,000

01:13:50,070 --> 01:13:54,750
or 4,000 as the number of the first

01:13:53,070 --> 01:13:56,790
system call forgiven ABI and then

01:13:54,750 --> 01:13:58,800
instead of using system call number 300

01:13:56,790 --> 01:14:01,800
or 4 we used four thousand three hundred

01:13:58,800 --> 01:14:04,560
and four but we would make it consistent

01:14:01,800 --> 01:14:07,850
yeah but this way you would impose a

01:14:04,560 --> 01:14:10,560
limitation because of this offset gap

01:14:07,850 --> 01:14:13,710
you would impose a limitation the

01:14:10,560 --> 01:14:26,820
highest call number

01:14:13,710 --> 01:14:29,430
oh okay next topic here no and you see

01:14:26,820 --> 01:14:33,270
Heather coordination this is a

01:14:29,430 --> 01:14:37,460
long-standing issue where sometimes it

01:14:33,270 --> 01:14:41,820
broke sometime it works we do not have

01:14:37,460 --> 01:14:44,040
direct way to actually tested it depends

01:14:41,820 --> 01:14:46,320
off someone's to bring this up either to

01:14:44,040 --> 01:14:50,489
Dipsy or to the kind of developers that

01:14:46,320 --> 01:14:54,690
something has broken so my question is

01:14:50,489 --> 01:14:57,180
how can I prove that we have some

01:14:54,690 --> 01:14:59,640
scripts on gdb C which actually install

01:14:57,180 --> 01:15:03,420
a kernel like I cannot header and we

01:14:59,640 --> 01:15:06,710
compile all the tool chain and one

01:15:03,420 --> 01:15:09,900
option would be to hook up some

01:15:06,710 --> 01:15:14,040
permutation to actually test this the

01:15:09,900 --> 01:15:16,680
kernel headers is working but I'm open

01:15:14,040 --> 01:15:19,080
to suggestions because comment we do not

01:15:16,680 --> 01:15:20,700
have any mechanism to actually test it I

01:15:19,080 --> 01:15:24,239
think specifically if we could have

01:15:20,700 --> 01:15:26,700
something in kernel CI and that actually

01:15:24,239 --> 01:15:29,160
on every command kind of tries to

01:15:26,700 --> 01:15:31,320
rebuild chillip see master we have to

01:15:29,160 --> 01:15:33,630
make head as a check target which is

01:15:31,320 --> 01:15:35,489
probably being called in kernel CI I

01:15:33,630 --> 01:15:37,500
would put it in there so that anybody

01:15:35,489 --> 01:15:39,780
who runs make headers check gets the

01:15:37,500 --> 01:15:42,390
same output and right now we do a couple

01:15:39,780 --> 01:15:45,540
of checks but not a lot we could add

01:15:42,390 --> 01:15:47,700
additional checks in there that we think

01:15:45,540 --> 01:15:49,800
are useful for this another question

01:15:47,700 --> 01:15:51,719
will be which kind of permutations we're

01:15:49,800 --> 01:15:53,460
going to support we're going to support

01:15:51,719 --> 01:15:57,180
you include all the headers in all the

01:15:53,460 --> 01:15:59,370
manors Wow we need us just a subset of

01:15:57,180 --> 01:15:59,790
the kind of headers that is actually

01:15:59,370 --> 01:16:03,239
useful

01:15:59,790 --> 01:16:05,730
I would say every kernel header should

01:16:03,239 --> 01:16:08,190
be included by itself

01:16:05,730 --> 01:16:09,780
as the first step so if there's any

01:16:08,190 --> 01:16:11,670
kernel header you included you get a

01:16:09,780 --> 01:16:14,540
compile error that is a bug in the

01:16:11,670 --> 01:16:14,540
kernel that we should fix

01:16:15,750 --> 01:16:23,610
and we should have at least one way to

01:16:19,150 --> 01:16:24,940
combine each kernel header with any

01:16:23,610 --> 01:16:27,040
gypsy header

01:16:24,940 --> 01:16:30,460
even if they define the same structure

01:16:27,040 --> 01:16:33,250
we should find a way to to make them

01:16:30,460 --> 01:16:35,440
coexist I'm not sure if we can get to

01:16:33,250 --> 01:16:39,639
the way that you can make it work in all

01:16:35,440 --> 01:16:45,550
combinations but that would be the

01:16:39,639 --> 01:16:49,989
minimum I think some as a person who

01:16:45,550 --> 01:16:54,429
submit fixes for after each release to

01:16:49,989 --> 01:16:57,900
fix Europe each others that stop self

01:16:54,429 --> 01:17:00,909
compiling what I can say some

01:16:57,900 --> 01:17:03,820
simultaneous except dispatches but some

01:17:00,909 --> 01:17:05,800
just some headers to done or maintenance

01:17:03,820 --> 01:17:07,989
at all and they are completely ignored I

01:17:05,800 --> 01:17:10,449
mean the patches submitter for them and

01:17:07,989 --> 01:17:13,960
some are like considered too old to be

01:17:10,449 --> 01:17:16,090
fixed or so I have all kinds of

01:17:13,960 --> 01:17:18,880
responses and for some subsistence they

01:17:16,090 --> 01:17:22,000
don't like the idea of the self self

01:17:18,880 --> 01:17:25,000
compiled header because it like it uses

01:17:22,000 --> 01:17:27,280
it's it's used not just for the kernel

01:17:25,000 --> 01:17:31,889
but for user space I don't remember

01:17:27,280 --> 01:17:36,520
exactly I just stop stop watching these

01:17:31,889 --> 01:17:40,300
headers so unless you integrate this

01:17:36,520 --> 01:17:43,570
make check headers or whatever into the

01:17:40,300 --> 01:17:48,090
process people like me would have to

01:17:43,570 --> 01:17:51,699
patch the headers for each Shirley's

01:17:48,090 --> 01:17:53,619
which is not good yeah I think we have

01:17:51,699 --> 01:17:56,409
to we have to find a way to get the

01:17:53,619 --> 01:17:57,760
baseline done so basically when we if we

01:17:56,409 --> 01:18:01,119
ever get to the point where it's less

01:17:57,760 --> 01:18:03,460
than 10 touches missing we should have

01:18:01,119 --> 01:18:07,270
those 10 edges and the script changes to

01:18:03,460 --> 01:18:08,559
make it work and then we can bypass the

01:18:07,270 --> 01:18:13,090
maintenance getting that getting that

01:18:08,559 --> 01:18:15,389
done yeah to to to make it clear this is

01:18:13,090 --> 01:18:18,599
integrated in the process it's just not

01:18:15,389 --> 01:18:18,599
complete yet

01:18:19,580 --> 01:18:28,600
okay this next one is a something that

01:18:24,740 --> 01:18:32,330
we think might be useful which is have a

01:18:28,600 --> 01:18:36,020
point of contact should discuss a bi

01:18:32,330 --> 01:18:36,350
issues or Joseph's calls how to handle

01:18:36,020 --> 01:18:40,670
it

01:18:36,350 --> 01:18:42,140
is it an good addition is it not the

01:18:40,670 --> 01:18:45,860
question is do we have this kind of

01:18:42,140 --> 01:18:52,580
point of contacts for the candle I would

01:18:45,860 --> 01:18:54,530
say earned and myself you agree yarn and

01:18:52,580 --> 01:18:59,180
Linux API I can always put it on so you

01:18:54,530 --> 01:19:00,950
see there's people subscribe to it I am

01:18:59,180 --> 01:19:02,990
I have yet to get an answer to anything

01:19:00,950 --> 01:19:14,780
I posted on Linux ABI but it's good to

01:19:02,990 --> 01:19:17,630
see see ok the next ones are more can

01:19:14,780 --> 01:19:20,330
you go back one page sure so I actually

01:19:17,630 --> 01:19:24,410
have the reverse problem I for the 2038

01:19:20,330 --> 01:19:27,080
work that I've been doing I've had lots

01:19:24,410 --> 01:19:31,070
of patches that have sent with CC to the

01:19:27,080 --> 01:19:33,020
gilepsy mailing list and I also see I I

01:19:31,070 --> 01:19:35,300
have trouble getting replies on it

01:19:33,020 --> 01:19:37,010
because I have decisions to make and I

01:19:35,300 --> 01:19:40,430
was I'm always hoping that people have

01:19:37,010 --> 01:19:42,230
an opinion on C on things but when I get

01:19:40,430 --> 01:19:44,330
no feedback I don't even know people

01:19:42,230 --> 01:19:47,000
that just don't have an opinion or if

01:19:44,330 --> 01:19:48,500
they don't think it would be the right

01:19:47,000 --> 01:19:51,020
apply for them at the time

01:19:48,500 --> 01:19:53,270
so I'm lacking feedback from that

01:19:51,020 --> 01:19:55,610
perspective too okay my from a point of

01:19:53,270 --> 01:19:58,310
view what I see is genie be seed takes

01:19:55,610 --> 01:20:02,150
the kind of for granted and what they

01:19:58,310 --> 01:20:05,450
can implement we're gonna set up on that

01:20:02,150 --> 01:20:08,270
so that's a problem we should interact

01:20:05,450 --> 01:20:12,200
more we should provide more feedback but

01:20:08,270 --> 01:20:14,090
if you see that current a review it

01:20:12,200 --> 01:20:17,210
because since the with the academies are

01:20:14,090 --> 01:20:20,870
at defined now we can work with instead

01:20:17,210 --> 01:20:24,290
of doing an interaction you to get the

01:20:20,870 --> 01:20:26,179
better architecture so yeah it's

01:20:24,290 --> 01:20:28,550
something that we can

01:20:26,179 --> 01:20:36,440
I think in general you're kind of short

01:20:28,550 --> 01:20:39,530
of reviewers so we're kind of short on

01:20:36,440 --> 01:20:43,040
reviewers in general the situation is

01:20:39,530 --> 01:20:45,260
kind of improving but people still

01:20:43,040 --> 01:20:48,140
appreciate help from people who have

01:20:45,260 --> 01:21:02,590
been involved in the Linux know to

01:20:48,140 --> 01:21:07,640
change community to kind of pitch in so

01:21:02,590 --> 01:21:10,429
this is a old interface that mimics

01:21:07,640 --> 01:21:14,780
provide that it was brought to our our

01:21:10,429 --> 01:21:17,730
tensions recently which is a Landsat

01:21:14,780 --> 01:21:19,300
support for this for 12 years

01:21:17,730 --> 01:21:21,980
[Music]

01:21:19,300 --> 01:21:27,320
it works on poppy see right sorry

01:21:21,980 --> 01:21:32,140
it works on PowerPC as far as I know any

01:21:27,320 --> 01:21:37,810
of the others to try to make it happen

01:21:32,140 --> 01:21:37,810
we need to extend the terminal interface

01:21:38,980 --> 01:21:44,960
so we are working that but this is an

01:21:42,380 --> 01:21:48,679
example where Linux provides something

01:21:44,960 --> 01:21:50,420
that G deep sea legs and only become a

01:21:48,679 --> 01:21:54,469
problem when someone tried to actually

01:21:50,420 --> 01:21:56,900
use it so I'm going to ask you if you

01:21:54,469 --> 01:21:59,840
have that kind of interaction problem

01:21:56,900 --> 01:22:02,989
for instance oh the Linux I need to

01:21:59,840 --> 01:22:05,300
actually write down a library to use a

01:22:02,989 --> 01:22:08,179
Linux interface where it could be

01:22:05,300 --> 01:22:12,830
provided by the Lipsy please come up to

01:22:08,179 --> 01:22:15,310
us and expose the problem sometimes it

01:22:12,830 --> 01:22:20,210
requires a lot of cleanup for our part

01:22:15,310 --> 01:22:22,550
we are doing that planes or requires

01:22:20,210 --> 01:22:26,440
extensions to actually provided but we

01:22:22,550 --> 01:22:29,929
are open to to work on that problem so

01:22:26,440 --> 01:22:31,400
it's I don't know it's going to be on

01:22:29,929 --> 01:22:34,800
the next release but it will be

01:22:31,400 --> 01:22:37,830
eventually we hope so

01:22:34,800 --> 01:22:40,390
so this is another longest an issue

01:22:37,830 --> 01:22:45,190
which could be sought which could be

01:22:40,390 --> 01:22:46,960
solved home by userland but if the

01:22:45,190 --> 01:22:51,300
colonel could provide us a bit a better

01:22:46,960 --> 01:22:55,510
way especially for x86 32-bit will be

01:22:51,300 --> 01:22:58,300
very nice performance wise so the

01:22:55,510 --> 01:23:00,850
problem was broadband muscle need to see

01:22:58,300 --> 01:23:03,370
some time ago because they they create a

01:23:00,850 --> 01:23:06,600
wage up to actually check if the bit red

01:23:03,370 --> 01:23:10,480
constellation has some side effects

01:23:06,600 --> 01:23:13,110
regardless Cisco and the way there they

01:23:10,480 --> 01:23:16,870
end up resolving this is using the old

01:23:13,110 --> 01:23:21,280
x86 32-bit intake eight instead of the

01:23:16,870 --> 01:23:23,020
VDS oh yeah the probably there's another

01:23:21,280 --> 01:23:26,020
question do we care for that we care

01:23:23,020 --> 01:23:34,660
that do you care try to use the video so

01:23:26,020 --> 01:23:37,510
for x86 32-bit I mean it's this is it's

01:23:34,660 --> 01:23:39,280
a I say absolutely architecture I know I

01:23:37,510 --> 01:23:43,480
know there's still people that care

01:23:39,280 --> 01:23:46,180
about it but I don't know I'm sorry to

01:23:43,480 --> 01:23:50,200
say that we they shouldn't or who they

01:23:46,180 --> 01:24:01,890
should move on ten you have the same

01:23:50,200 --> 01:24:05,080
issue we need to use our old cisco so

01:24:01,890 --> 01:24:07,270
this is a long-standing issue with vc

01:24:05,080 --> 01:24:12,720
which is we need to provide fork with

01:24:07,270 --> 01:24:12,720
sceen signal size and that question is

01:24:13,680 --> 01:24:23,730
can can help us because what we need is

01:24:20,340 --> 01:24:27,640
we need to save and restore some state

01:24:23,730 --> 01:24:30,190
when the signal handler is executed we

01:24:27,640 --> 01:24:33,700
can do this by wrapper all the signal

01:24:30,190 --> 01:24:35,890
handling or we can get some kernel help

01:24:33,700 --> 01:24:39,180
but you actually do this work for us in

01:24:35,890 --> 01:24:39,180
a non raise convey

01:24:39,840 --> 01:24:49,540
so for instance can the candle get gives

01:24:46,630 --> 01:24:54,790
us an option to Satan we start a memory

01:24:49,540 --> 01:24:58,380
operation a memory a memory space when

01:24:54,790 --> 01:24:58,380
the signal handle is executed

01:25:03,570 --> 01:25:11,010
or is it something that we should

01:25:06,930 --> 01:25:14,490
provide only by the user space so what

01:25:11,010 --> 01:25:17,520
exactly do you need one thing is we need

01:25:14,490 --> 01:25:20,850
to say we store our know when a signal

01:25:17,520 --> 01:25:23,070
handler it's executed so one thing we

01:25:20,850 --> 01:25:25,320
can do that is by wrapping the signal

01:25:23,070 --> 01:25:27,330
handling in user space and handling all

01:25:25,320 --> 01:25:30,660
the waste conditions that it might have

01:25:27,330 --> 01:25:31,410
occur or we can ask for the candle to do

01:25:30,660 --> 01:25:35,790
this job for us

01:25:31,410 --> 01:25:37,440
I would almost say you probably would

01:25:35,790 --> 01:25:38,970
maybe send something I want to the

01:25:37,440 --> 01:25:42,720
mailing list so asking like here this is

01:25:38,970 --> 01:25:44,160
the API I'd like to have ok yeah that

01:25:42,720 --> 01:25:45,810
probably better it serve like say this

01:25:44,160 --> 01:25:48,210
is our problem space this is our API

01:25:45,810 --> 01:25:50,250
we'd like to have would it be or should

01:25:48,210 --> 01:25:52,260
we just keep it in a user space I'm ok

01:25:50,250 --> 01:25:55,350
that's something definitely sent who do

01:25:52,260 --> 01:26:01,740
you see see for that for single handling

01:25:55,350 --> 01:26:03,450
I know like does a lot of Nesterov yeah

01:26:01,740 --> 01:26:05,250
if you're looking yeah anything that

01:26:03,450 --> 01:26:06,690
deals signals and stuff like that

01:26:05,250 --> 01:26:09,990
Oleg nester Ralph is the person you want

01:26:06,690 --> 01:26:12,960
to see see and sent to oh he's a good

01:26:09,990 --> 01:26:14,070
guy to talk to he's a smart and okay

01:26:12,960 --> 01:26:17,750
it's very easy to work with

01:26:14,070 --> 01:26:17,750
I think earth time is done right yeah

01:26:21,480 --> 01:26:26,790
[Applause]

01:26:31,060 --> 01:26:46,280
well you're really over selling it yeah

01:26:44,270 --> 01:26:48,650
so I thought these were like discussions

01:26:46,280 --> 01:26:51,560
not talks so I basically didn't come

01:26:48,650 --> 01:26:52,940
with any slides so I have to I was told

01:26:51,560 --> 01:26:56,150
if I had more than three slides I would

01:26:52,940 --> 01:26:58,780
be heckled loudly but I clearly read the

01:26:56,150 --> 01:27:00,679
wrong email so I have to slip two slides

01:26:58,780 --> 01:27:01,969
that's what I heard right I was gonna

01:27:00,679 --> 01:27:06,170
have things thrown at me so I have two

01:27:01,969 --> 01:27:10,699
slides so we're here to talk about the

01:27:06,170 --> 01:27:12,140
time T in the 32-bit risc v linux user

01:27:10,699 --> 01:27:14,030
space ABI

01:27:12,140 --> 01:27:17,620
so I hope you guys all went to arns talk

01:27:14,030 --> 01:27:19,670
yesterday about generic good yeah

01:27:17,620 --> 01:27:23,659
because that's about the extent of what

01:27:19,670 --> 01:27:28,070
I know about 32-bit time ta be ice right

01:27:23,659 --> 01:27:31,400
so vague summary of what's going on in

01:27:28,070 --> 01:27:33,380
risk v land all right so we have to base

01:27:31,400 --> 01:27:36,110
ices that are sort of Linux base ISAs

01:27:33,380 --> 01:27:38,420
there's our B 32 NRV 64 I our theory

01:27:36,110 --> 01:27:42,770
about 2i is 32 32 bit registers are me

01:27:38,420 --> 01:27:45,110
64 I is 32 64-bit registers right so our

01:27:42,770 --> 01:27:47,060
V 32 I was submitted upstream along with

01:27:45,110 --> 01:27:49,850
our V 64 I into Linux and they got

01:27:47,060 --> 01:27:52,610
accepted but our veto - I ports super

01:27:49,850 --> 01:27:54,800
broken so for about a year like it

01:27:52,610 --> 01:27:58,120
didn't build and as a result we missed

01:27:54,800 --> 01:28:00,290
the GMC submission for 32 bit because

01:27:58,120 --> 01:28:03,739
cousin build can't run any tests all

01:28:00,290 --> 01:28:06,830
that sort of stuff so Zhang has done a

01:28:03,739 --> 01:28:09,679
ton of work getting it back alive and

01:28:06,830 --> 01:28:12,590
has fixed it a couple of times and so

01:28:09,679 --> 01:28:15,890
now what we want to do is get into the

01:28:12,590 --> 01:28:18,860
next GOP release because 32-bit kernels

01:28:15,890 --> 01:28:20,929
in decent shape and the 32-bit G

01:28:18,860 --> 01:28:24,140
Lipsey's in decent shape and in G lip

01:28:20,929 --> 01:28:25,730
seal and the code moves around a lot and

01:28:24,140 --> 01:28:28,520
I find the build system very hard to

01:28:25,730 --> 01:28:30,469
navigate so I don't want to have to go

01:28:28,520 --> 01:28:31,699
do it again you know now that

01:28:30,469 --> 01:28:33,500
everything's working let's kind of get

01:28:31,699 --> 01:28:36,949
it in sort of thing I think people are

01:28:33,500 --> 01:28:38,840
pretty much aligned to getting the 32

01:28:36,949 --> 01:28:39,860
bit julep seaport in the last big

01:28:38,840 --> 01:28:41,870
blocker with the group

01:28:39,860 --> 01:28:44,000
a ton of floating-point stuff and that

01:28:41,870 --> 01:28:45,080
seems to have all been sorted out so I

01:28:44,000 --> 01:28:48,200
think we're in pretty good shape there

01:28:45,080 --> 01:28:49,820
the kernel builds you know songs testing

01:28:48,200 --> 01:28:51,260
it and all that sort of stuff so I think

01:28:49,820 --> 01:28:54,470
we all lined up there so now the big

01:28:51,260 --> 01:28:57,830
question left is basically are we gonna

01:28:54,470 --> 01:29:01,160
have a 32-bit time T or a 64-bit time T

01:28:57,830 --> 01:29:05,330
in the RV 32 I you know user ABI so the

01:29:01,160 --> 01:29:08,540
kernel port energy Lib C port so this

01:29:05,330 --> 01:29:10,820
this is the plan so the plan is to go my

01:29:08,540 --> 01:29:13,340
plan is to go with a 64 bit I think it's

01:29:10,820 --> 01:29:17,300
worth it because I think we don't want

01:29:13,340 --> 01:29:18,650
to deal with 32-bit ABI long term if we

01:29:17,300 --> 01:29:21,110
do this we're gonna have to switch over

01:29:18,650 --> 01:29:23,240
have another ABI we'll end up with this

01:29:21,110 --> 01:29:24,800
in one or two GFC releases it'll get

01:29:23,240 --> 01:29:26,150
deprecated no one will use it they're

01:29:24,800 --> 01:29:29,450
probably open a user space is a little

01:29:26,150 --> 01:29:31,250
big pain alright so the hope here is

01:29:29,450 --> 01:29:33,890
that the GFC side of this is fairly

01:29:31,250 --> 01:29:35,300
straightforward because we don't need to

01:29:33,890 --> 01:29:38,870
have backwards compatibility with an

01:29:35,300 --> 01:29:41,270
existing 32-bit times the ABI so we can

01:29:38,870 --> 01:29:42,560
figure out how to make that work and

01:29:41,270 --> 01:29:44,060
then the kernel side is a little

01:29:42,560 --> 01:29:45,980
trickier if you want to orange talked

01:29:44,060 --> 01:29:49,040
yesterday there will not be all the

01:29:45,980 --> 01:29:50,720
interfaces converted so I think we're

01:29:49,040 --> 01:29:53,870
just gonna kind of deal with the fallout

01:29:50,720 --> 01:29:57,860
for a couple of release cycles distros

01:29:53,870 --> 01:29:59,570
don't plan on doing RV 32 i super soon

01:29:57,860 --> 01:30:01,880
so it's not like there's gonna be a huge

01:29:59,570 --> 01:30:04,730
pile of users I don't think there's any

01:30:01,880 --> 01:30:06,230
hardware out there we should be okay you

01:30:04,730 --> 01:30:09,560
know most of the tests pass and things

01:30:06,230 --> 01:30:12,050
like sound might not work for release so

01:30:09,560 --> 01:30:16,190
that's effectively all I have to talk

01:30:12,050 --> 01:30:19,670
about so the issue here is that julep C

01:30:16,190 --> 01:30:21,950
is targeted to release February first

01:30:19,670 --> 01:30:23,330
and then the kernel merge window where

01:30:21,950 --> 01:30:25,940
we might be able to get the system calls

01:30:23,330 --> 01:30:27,350
done in time and something like the day

01:30:25,940 --> 01:30:31,010
before that maybe that's a Monday in the

01:30:27,350 --> 01:30:37,400
merge windows and zhanna sunday so how

01:30:31,010 --> 01:30:38,810
much trouble am I gonna get in the

01:30:37,400 --> 01:30:41,360
freeze would be December 31st but I

01:30:38,810 --> 01:30:45,560
thought that was so the plan is to get

01:30:41,360 --> 01:30:47,450
the port in earlier like really soon now

01:30:45,560 --> 01:30:50,360
because I think it's ready to go right

01:30:47,450 --> 01:30:52,249
and then change the ABI if we can get it

01:30:50,360 --> 01:30:57,380
done at the last minute

01:30:52,249 --> 01:30:59,389
I would recommend that you do that at

01:30:57,380 --> 01:31:02,179
least like by the end of December or

01:30:59,389 --> 01:31:07,880
okay I could probably give you like an

01:31:02,179 --> 01:31:11,059
extra week okay yeah no that's okay yeah

01:31:07,880 --> 01:31:14,420
the issue is just lining everything up

01:31:11,059 --> 01:31:16,519
if that makes sense right because so

01:31:14,420 --> 01:31:17,030
then the question becomes can we run the

01:31:16,519 --> 01:31:29,300
test

01:31:17,030 --> 01:31:30,559
yeah coincide also you cannot count on

01:31:29,300 --> 01:31:32,900
the merge window just closing and

01:31:30,559 --> 01:31:34,999
getting your fix in just the one day

01:31:32,900 --> 01:31:37,130
before that or what yeah no I understand

01:31:34,999 --> 01:31:38,929
yeah huge terrible way to do things

01:31:37,130 --> 01:31:40,400
yeah and also the version numbers

01:31:38,929 --> 01:31:41,869
mismatch you cannot count on

01:31:40,400 --> 01:31:43,789
distributions to always ship the

01:31:41,869 --> 01:31:47,179
combination you want so you will have to

01:31:43,789 --> 01:31:48,440
think about compatibility with kernel

01:31:47,179 --> 01:31:50,840
that doesn't have the feature and GDP

01:31:48,440 --> 01:31:53,239
that has the feature and all those

01:31:50,840 --> 01:31:55,849
combinations we now they will not be

01:31:53,239 --> 01:31:59,139
shipping all our notes because they are

01:31:55,849 --> 01:32:04,849
no older kernels don't build okay so

01:31:59,139 --> 01:32:06,769
most one yeah so at least we're safe

01:32:04,849 --> 01:32:08,690
there and that's why it seemed like it

01:32:06,769 --> 01:32:10,610
was kind of worth getting in because

01:32:08,690 --> 01:32:14,900
then we could basically avoid having the

01:32:10,610 --> 01:32:18,139
old ABI right if we do 32-bit time to

01:32:14,900 --> 01:32:20,179
AVI and GMC then we have to go throw it

01:32:18,139 --> 01:32:24,789
away probably at the next release which

01:32:20,179 --> 01:32:24,789
seems kind of silly if that makes sense

01:32:28,700 --> 01:32:34,140
so I wanna have actually delivery is

01:32:31,350 --> 01:32:38,040
harder than the corner okay because we

01:32:34,140 --> 01:32:40,560
do not have any G Lipsy part for 32-bit

01:32:38,040 --> 01:32:41,420
that uses a 64-bit time well we do have

01:32:40,560 --> 01:32:45,540
x32

01:32:41,420 --> 01:32:47,070
um but still it's going to be different

01:32:45,540 --> 01:32:50,580
from all the other process the last few

01:32:47,070 --> 01:32:53,700
parts have all just been able to use the

01:32:50,580 --> 01:32:55,860
generic api's yeah 64-bit by port was

01:32:53,700 --> 01:32:57,330
super easy right there's no API stuff in

01:32:55,860 --> 01:32:59,670
there basically so if you if you have

01:32:57,330 --> 01:33:02,490
the first new architecture with a 32-bit

01:32:59,670 --> 01:33:05,040
time T the 64-bit time T on a 32-bit

01:33:02,490 --> 01:33:07,860
architecture and you don't have any of

01:33:05,040 --> 01:33:09,870
the other special cases that extra to to

01:33:07,860 --> 01:33:11,220
has then that means you are different

01:33:09,870 --> 01:33:14,910
from the other ones you need special

01:33:11,220 --> 01:33:18,240
code in gilepsy okay um so I think that

01:33:14,910 --> 01:33:21,120
we will run into problems that need to

01:33:18,240 --> 01:33:22,680
be resolved after the basic kernel

01:33:21,120 --> 01:33:24,060
support was there okay but I was

01:33:22,680 --> 01:33:27,840
thinking with the breadth of syscalls

01:33:24,060 --> 01:33:28,860
that are supported now in Linux land we

01:33:27,840 --> 01:33:31,140
could at least get most of that work

01:33:28,860 --> 01:33:34,110
done sooner rather than later if that

01:33:31,140 --> 01:33:36,150
makes sense well we have not assigned

01:33:34,110 --> 01:33:37,610
any system calling numbers to them so we

01:33:36,150 --> 01:33:39,840
have most of the system calls

01:33:37,610 --> 01:33:41,430
implemented okay but there's no if not

01:33:39,840 --> 01:33:43,140
assigned in number to them so you can't

01:33:41,430 --> 01:33:44,910
actually called them yeah so there's

01:33:43,140 --> 01:33:47,010
gonna be a lot of machinery then yeah

01:33:44,910 --> 01:33:48,780
the system clone almost is trivial so

01:33:47,010 --> 01:33:52,560
that's that's I can give you a patch for

01:33:48,780 --> 01:33:58,790
that yeah the problem is just it's if no

01:33:52,560 --> 01:34:01,560
one's calling them then yeah yeah okay

01:33:58,790 --> 01:34:03,330
so now what I'm thinking is it smells

01:34:01,560 --> 01:34:07,100
like we're trying to go too fast which

01:34:03,330 --> 01:34:10,020
is a it is certainly cutting yeah good

01:34:07,100 --> 01:34:13,050
all right now then the problem is do we

01:34:10,020 --> 01:34:13,320
do with 32-bit time T ABI if that makes

01:34:13,050 --> 01:34:15,420
sense

01:34:13,320 --> 01:34:18,510
yep so that's basically what we've done

01:34:15,420 --> 01:34:20,100
in the past few years in the kernel so

01:34:18,510 --> 01:34:23,430
at some point a few years ago we made

01:34:20,100 --> 01:34:26,730
the decision about what we do about new

01:34:23,430 --> 01:34:29,490
32-bit architectures being parted after

01:34:26,730 --> 01:34:31,560
we had the president of X 32 where we

01:34:29,490 --> 01:34:33,510
went with a 64-bit time T yeah it

01:34:31,560 --> 01:34:36,360
happened to not work out well at all

01:34:33,510 --> 01:34:38,190
because it caused problems lessen drive

01:34:36,360 --> 01:34:39,630
because it was the colonel was just not

01:34:38,190 --> 01:34:42,030
prepared for that

01:34:39,630 --> 01:34:46,400
so we the decision that was made in the

01:34:42,030 --> 01:34:49,200
kernel is that we continue to build all

01:34:46,400 --> 01:34:51,450
new architectures the same way

01:34:49,200 --> 01:34:53,760
meaning we stay with the 32-bit time T

01:34:51,450 --> 01:34:57,000
and then we fix them at the same time

01:34:53,760 --> 01:35:00,180
all in the same way by going to a 64-bit

01:34:57,000 --> 01:35:01,830
time T because the most important the

01:35:00,180 --> 01:35:05,160
the two most important architectures for

01:35:01,830 --> 01:35:07,500
32-bit user space at the moment are x86

01:35:05,160 --> 01:35:10,560
and arm those have the most users yeah

01:35:07,500 --> 01:35:13,920
and we have to fix those anyway so when

01:35:10,560 --> 01:35:15,600
we fix those we can also fix risk v yeah

01:35:13,920 --> 01:35:17,220
and the risk v 32-bit port is not

01:35:15,600 --> 01:35:19,290
something that people are clamoring for

01:35:17,220 --> 01:35:24,150
right that's why it was broken for so

01:35:19,290 --> 01:35:27,530
long so it would be easy enough to do

01:35:24,150 --> 01:35:30,300
the same thing in G Lipsey and make it

01:35:27,530 --> 01:35:31,800
Bank the G Lib C port do the same thing

01:35:30,300 --> 01:35:33,990
on risk v that we do and all the other

01:35:31,800 --> 01:35:36,060
32 architectures and then fix it at the

01:35:33,990 --> 01:35:39,000
same time yeah that's fine I just hoping

01:35:36,060 --> 01:35:41,430
to avoid basically you know at this

01:35:39,000 --> 01:35:43,700
point if we do the 32-bit time T ABI on

01:35:41,430 --> 01:35:45,740
our view 32 we'll have whole ABI

01:35:43,700 --> 01:35:48,510
probably no district that's built for

01:35:45,740 --> 01:35:51,690
probably isn't really ever used if that

01:35:48,510 --> 01:35:53,730
kind of makes sense yes the advantage is

01:35:51,690 --> 01:35:55,980
that you don't have any special code you

01:35:53,730 --> 01:35:59,430
don't tell if they're risk 5 you just

01:35:55,980 --> 01:36:01,530
have the if we're using 32-bit time T

01:35:59,430 --> 01:36:03,630
you are using 64-bit times e yeah which

01:36:01,530 --> 01:36:05,700
is fine it's and it's it's in right it's

01:36:03,630 --> 01:36:08,400
in G loop C which helps management stuff

01:36:05,700 --> 01:36:12,840
we can test the kernel right it's just

01:36:08,400 --> 01:36:15,450
uh if no one's really using it it seems

01:36:12,840 --> 01:36:17,730
kind of yes it would be nice to have a G

01:36:15,450 --> 01:36:20,100
live see that does not have to do this

01:36:17,730 --> 01:36:22,470
but we don't have the support for 64-bit

01:36:20,100 --> 01:36:25,020
I know ing Lipsey yet so the patch that

01:36:22,470 --> 01:36:27,360
that exists for gilepsy implements

01:36:25,020 --> 01:36:29,640
64-bit time T on all architectures and

01:36:27,360 --> 01:36:33,150
then implements the fallbacks

01:36:29,640 --> 01:36:34,770
for running on older kernels yeah and I

01:36:33,150 --> 01:36:36,560
thought the most of the extra mechanism

01:36:34,770 --> 01:36:40,050
there was in the fallback side of things

01:36:36,560 --> 01:36:42,210
right right but that part doesn't even

01:36:40,050 --> 01:36:45,780
have the native case yet because it may

01:36:42,210 --> 01:36:48,930
not and I don't know what what else it

01:36:45,780 --> 01:36:50,990
has that you might still need so our

01:36:48,930 --> 01:36:53,490
kinds of interfaces change in some way

01:36:50,990 --> 01:36:55,380
that yeah that's my big worry here

01:36:53,490 --> 01:36:57,960
that has no ones on it before I don't

01:36:55,380 --> 01:36:59,820
really know what I'm doing here G

01:36:57,960 --> 01:37:02,880
Liberty exports some interfaces that

01:36:59,820 --> 01:37:04,440
contain a time T that do not correspond

01:37:02,880 --> 01:37:07,590
directly to a kernel interface so I

01:37:04,440 --> 01:37:09,480
talked to someone in gypsy land and they

01:37:07,590 --> 01:37:12,720
were convinced that it was possible to

01:37:09,480 --> 01:37:15,000
get rid of all of this okay like with

01:37:12,720 --> 01:37:16,350
very little work today okay I make sense

01:37:15,000 --> 01:37:18,210
which is part of the reason that swung

01:37:16,350 --> 01:37:21,300
me towards the hey let's try to do it

01:37:18,210 --> 01:37:23,480
because then if we could do the like the

01:37:21,300 --> 01:37:27,150
whole user side of the gypsy ABI

01:37:23,480 --> 01:37:29,670
matching up but it sounds like it's just

01:37:27,150 --> 01:37:36,090
going too fast if that makes any sense

01:37:29,670 --> 01:37:42,630
all right so okay so maybe the right

01:37:36,090 --> 01:37:44,190
answer so just do a 32-bit time te well

01:37:42,630 --> 01:37:45,930
the other eternity of would be to miss

01:37:44,190 --> 01:37:48,030
the delivery well that's what I'm

01:37:45,930 --> 01:37:50,880
thinking now right mr. G let's see cut

01:37:48,030 --> 01:37:52,950
off you could still have a fork of the

01:37:50,880 --> 01:37:55,770
release you can still put it out there

01:37:52,950 --> 01:37:56,910
and then merge it a month or two later

01:37:55,770 --> 01:37:58,260
when we have it all done for the

01:37:56,910 --> 01:38:00,840
following mode so you think it will be

01:37:58,260 --> 01:38:03,840
done for the next like it'd be done in

01:38:00,840 --> 01:38:06,270
time for the next G loop C release it

01:38:03,840 --> 01:38:08,820
would be possible to have a I mean if we

01:38:06,270 --> 01:38:10,650
if we don't like you're barely waiting

01:38:08,820 --> 01:38:12,750
for me for the kernel side right and I

01:38:10,650 --> 01:38:15,420
I'm not completely sure I can make it if

01:38:12,750 --> 01:38:17,340
I don't make it and you missed the gypsy

01:38:15,420 --> 01:38:19,770
merge like then you have to decide

01:38:17,340 --> 01:38:21,930
whether you merged with the 32-bit time

01:38:19,770 --> 01:38:23,910
T or you don't merge it and you release

01:38:21,930 --> 01:38:26,970
you could still miss the G Lipsy release

01:38:23,910 --> 01:38:28,260
merge it a month later for the next I

01:38:26,970 --> 01:38:29,430
agree and that's kind of what I was and

01:38:28,260 --> 01:38:30,900
then we wouldn't have to merge a port

01:38:29,430 --> 01:38:33,000
late in the early cycle which is a

01:38:30,900 --> 01:38:35,610
headache right we'd be able to merge it

01:38:33,000 --> 01:38:37,320
early in the release cycle now this is

01:38:35,610 --> 01:38:40,560
the same thing we said last release

01:38:37,320 --> 01:38:42,600
cycle is hey let's skip 32-bit prescribe

01:38:40,560 --> 01:38:47,340
and GMC and just merge it super early

01:38:42,600 --> 01:38:49,050
next time and now it's late again so I'm

01:38:47,340 --> 01:38:51,360
a little bit worried that this this will

01:38:49,050 --> 01:38:56,310
persist so maybe maybe what you should

01:38:51,360 --> 01:38:58,830
try and do is target to 29 maybe start

01:38:56,310 --> 01:39:00,480
pushing patches or posting patches

01:38:58,830 --> 01:39:01,920
around January which is what you're

01:39:00,480 --> 01:39:03,690
comfortable yeah right

01:39:01,920 --> 01:39:06,590
well we can post the patches for the

01:39:03,690 --> 01:39:09,500
32-bit time T ABI basically right

01:39:06,590 --> 01:39:13,700
and we don't necessarily need to merge

01:39:09,500 --> 01:39:16,970
it for 2:29 just get it out yeah

01:39:13,700 --> 01:39:19,730
the moment we cut the release I'm gonna

01:39:16,970 --> 01:39:21,710
be open Master you can yeah and there's

01:39:19,730 --> 01:39:25,280
there's no sort of staging mechanism in

01:39:21,710 --> 01:39:27,050
gypsy yeah yeah cuz that'd be really an

01:39:25,280 --> 01:39:29,870
ideal case for this right where we keep

01:39:27,050 --> 01:39:31,220
it near everything so my thing with the

01:39:29,870 --> 01:39:33,860
reason I want to merge in GOC land is

01:39:31,220 --> 01:39:36,350
that I find it really hard to maintain

01:39:33,860 --> 01:39:38,120
an outer true gypsy ports because when

01:39:36,350 --> 01:39:40,010
the code base changes around I find it

01:39:38,120 --> 01:39:41,810
really hard to figure out like what

01:39:40,010 --> 01:39:42,980
changed and what I need to reflect into

01:39:41,810 --> 01:39:44,390
my stuff there's a reasonable mount of

01:39:42,980 --> 01:39:47,150
code copied in the build system moves

01:39:44,390 --> 01:39:50,540
and it's like you can always create your

01:39:47,150 --> 01:39:54,170
own namespace branch in the rebel yeah

01:39:50,540 --> 01:39:57,230
yeah and then just rebase to master so

01:39:54,170 --> 01:40:00,140
the thing about the freeze is that with

01:39:57,230 --> 01:40:01,970
the gilepsy post freeze there aren't a

01:40:00,140 --> 01:40:05,090
lot of patches that go in so the the

01:40:01,970 --> 01:40:06,620
month that we yeah and there's not gonna

01:40:05,090 --> 01:40:08,860
be any major refactoring so that month

01:40:06,620 --> 01:40:12,350
doesn't really hurt us any of them yeah

01:40:08,860 --> 01:40:15,800
yeah so that make sense the other thing

01:40:12,350 --> 01:40:17,750
to consider is that for 32-bit G Lib C

01:40:15,800 --> 01:40:21,560
might not if might not even be the most

01:40:17,750 --> 01:40:23,180
important C library because you might

01:40:21,560 --> 01:40:25,370
only you might run on a system that only

01:40:23,180 --> 01:40:26,750
has 32 megabytes of RAM this is another

01:40:25,370 --> 01:40:29,560
issue and one thing we've been doing is

01:40:26,750 --> 01:40:32,990
creating yeah so we've been gating

01:40:29,560 --> 01:40:35,390
marking any of the a bi-stable on G

01:40:32,990 --> 01:40:36,590
Lipsy being in basically and that's

01:40:35,390 --> 01:40:38,240
what's been gating all the other C

01:40:36,590 --> 01:40:41,210
libraries from being kind of official

01:40:38,240 --> 01:40:42,770
like muscle and a stable newly baby IP I

01:40:41,210 --> 01:40:44,720
think people early a little less worried

01:40:42,770 --> 01:40:47,210
about stable new and a B ice butt

01:40:44,720 --> 01:40:49,010
muscles the kind of target for this sort

01:40:47,210 --> 01:40:51,320
of space and we have a muscle patch set

01:40:49,010 --> 01:40:54,790
out now that is just gated on us kind of

01:40:51,320 --> 01:40:57,110
pulling the trigger on a bi-stability

01:40:54,790 --> 01:40:59,870
and muscle I think we'll have a much

01:40:57,110 --> 01:41:01,700
harder time in muscle 100s you will have

01:40:59,870 --> 01:41:03,560
a much harder time doing the 64 bit time

01:41:01,700 --> 01:41:04,880
T on top of that because it's different

01:41:03,560 --> 01:41:07,670
from yeah we haven't looked to the other

01:41:04,880 --> 01:41:09,380
that's 32 bit side of stuff there so I

01:41:07,670 --> 01:41:12,620
have a muscle port as I said in my talk

01:41:09,380 --> 01:41:15,200
I saw that it's arm where to change all

01:41:12,620 --> 01:41:16,910
that code because they use a common

01:41:15,200 --> 01:41:19,850
implementation and they have one

01:41:16,910 --> 01:41:23,000
definition of time T which is yeah

01:41:19,850 --> 01:41:26,780
it's long yeah yeah which is so that's

01:41:23,000 --> 01:41:28,340
another issue but we have been at least

01:41:26,780 --> 01:41:31,490
for the avi stability issue we have been

01:41:28,340 --> 01:41:35,210
saying hey we're G Lib C is the ABI

01:41:31,490 --> 01:41:36,380
stability point for verse five colonel

01:41:35,210 --> 01:41:37,790
maybe Isis right if that makes sense

01:41:36,380 --> 01:41:39,500
when we get in and that's why we're a

01:41:37,790 --> 01:41:40,910
little bit slushy with this stat X and

01:41:39,500 --> 01:41:43,190
the time T stuff I don't want to change

01:41:40,910 --> 01:41:44,720
car lady eyes but what's the status of

01:41:43,190 --> 01:41:46,310
stead x and g Lipsy do we have

01:41:44,720 --> 01:41:49,010
implementation of stat based on

01:41:46,310 --> 01:41:51,200
aesthetics I thought there was am I

01:41:49,010 --> 01:41:51,860
wrong about that no I'm just crazy no

01:41:51,200 --> 01:41:53,390
idea okay

01:41:51,860 --> 01:41:54,860
I left a loop yeah I thought there was

01:41:53,390 --> 01:41:56,210
because I thought at some point statics

01:41:54,860 --> 01:41:59,390
disappeared from our kernel and code

01:41:56,210 --> 01:42:02,420
started breaking but there was a

01:41:59,390 --> 01:42:04,310
different octave everybody um there was

01:42:02,420 --> 01:42:07,180
not statics that disappeared was one of

01:42:04,310 --> 01:42:10,220
the old we accidentally removed the the

01:42:07,180 --> 01:42:12,140
old stat so the G lipsky is not using

01:42:10,220 --> 01:42:13,730
stacks yeah I think I think of a

01:42:12,140 --> 01:42:15,760
different different book does that make

01:42:13,730 --> 01:42:15,760
sense

01:42:18,520 --> 01:42:23,390
yeah I think at some point I do remember

01:42:21,500 --> 01:42:23,660
chasing down something - I'm sorry about

01:42:23,390 --> 01:42:29,300
that

01:42:23,660 --> 01:42:30,590
no no that's baby I isn't stable so I

01:42:29,300 --> 01:42:33,410
think it's the right thing to do

01:42:30,590 --> 01:42:37,870
okay so I guess it sounds like we're

01:42:33,410 --> 01:42:37,870
just gonna skip glab see this round okay

01:42:39,550 --> 01:42:49,660
[Laughter]

01:42:43,880 --> 01:42:51,800
[Applause]

01:42:49,660 --> 01:42:54,560
all right yeah sorry if that wasn't the

01:42:51,800 --> 01:42:57,220
most interesting talk to attempt but it

01:42:54,560 --> 01:42:57,220
was useful for me

01:46:29,560 --> 01:47:34,510
this is that we have instructions

01:47:47,050 --> 01:47:54,140
there will be small skin enhancements

01:47:49,940 --> 01:47:57,110
for virtualizations virtualization so we

01:47:54,140 --> 01:48:01,600
we have some new crafts on cache and TLB

01:47:57,110 --> 01:48:05,240
maintenance instructions and there's

01:48:01,600 --> 01:48:09,200
stuff around support for exception entry

01:48:05,240 --> 01:48:11,180
without context equalization and there's

01:48:09,200 --> 01:48:15,380
a trash bin instruction to a point of

01:48:11,180 --> 01:48:19,760
deep persistence as if persistence was

01:48:15,380 --> 01:48:21,830
including of unique ecosystems however

01:48:19,760 --> 01:48:23,990
I'm not going to give you I'm not going

01:48:21,830 --> 01:48:25,910
to try and cover all of this in the next

01:48:23,990 --> 01:48:28,720
20 minutes I'm going to fundamentally

01:48:25,910 --> 01:48:28,720
focus on

01:48:49,610 --> 01:48:54,780
so let me start with I'm going to cover

01:48:52,890 --> 01:48:59,220
some of the new security extensions that

01:48:54,780 --> 01:49:02,730
we have in 3.5 what if this starts

01:48:59,220 --> 01:49:07,620
around what I'm trying to cover is

01:49:02,730 --> 01:49:09,480
basically a simplified history of memory

01:49:07,620 --> 01:49:12,350
safety errors that have existed in C

01:49:09,480 --> 01:49:15,650
programs for a while

01:49:12,350 --> 01:49:19,200
at first you put stick code on the stack

01:49:15,650 --> 01:49:23,940
VDP put a stop to that now the attacker

01:49:19,200 --> 01:49:28,230
needs a new way to of getting to a point

01:49:23,940 --> 01:49:33,990
of privilege X escalation so that he can

01:49:28,230 --> 01:49:38,460
turn off DT which is essentially data

01:49:33,990 --> 01:49:39,000
execution protection prevention Rafat

01:49:38,460 --> 01:49:41,360
job

01:49:39,000 --> 01:49:45,960
potentially during complete ways of

01:49:41,360 --> 01:49:49,800
doing that by programming by breaking

01:49:45,960 --> 01:49:52,410
program but also integrity what I mean

01:49:49,800 --> 01:49:54,330
by that is when somebody writes a

01:49:52,410 --> 01:49:57,810
program they expect control flow to be

01:49:54,330 --> 01:49:59,370
in a particular manner drop and drop or

01:49:57,810 --> 01:50:02,700
techniques that try and break that

01:49:59,370 --> 01:50:09,540
control flow integrity because people

01:50:02,700 --> 01:50:11,700
end up with essentially generating

01:50:09,540 --> 01:50:14,210
gadgets that they are able to use to

01:50:11,700 --> 01:50:14,210
exploit

01:50:16,820 --> 01:50:23,940
what we've been in what we ended up with

01:50:20,340 --> 01:50:28,440
in 8.5 is some new architectural support

01:50:23,940 --> 01:50:31,410
for limiting control flow exploits and

01:50:28,440 --> 01:50:34,400
we also try to add some architectural

01:50:31,410 --> 01:50:36,720
support for detecting vulnerabilities

01:50:34,400 --> 01:50:39,270
the main thing here that we are looking

01:50:36,720 --> 01:50:43,320
for is for help with detection of use

01:50:39,270 --> 01:50:46,200
after three type errors in programs for

01:50:43,320 --> 01:50:50,040
today I'm only good I'm going to try and

01:50:46,200 --> 01:50:52,350
cover mostly the techniques that the

01:50:50,040 --> 01:50:56,240
architecture extensions that we have put

01:50:52,350 --> 01:50:59,010
in for limiting control flow x1 exposure

01:50:56,240 --> 01:51:00,630
as part of that I'm going to go back a

01:50:59,010 --> 01:51:02,550
little bit even though I say I'm going

01:51:00,630 --> 01:51:06,380
to talk about 8.5 I'm going to go back a

01:51:02,550 --> 01:51:09,630
bit a couple of years and talk about 8.3

01:51:06,380 --> 01:51:12,120
which is where we added something known

01:51:09,630 --> 01:51:14,130
as pointer authentication one of the

01:51:12,120 --> 01:51:20,000
applications of pointer authentication

01:51:14,130 --> 01:51:22,380
is protecting your return address most

01:51:20,000 --> 01:51:25,680
return-oriented programming attacks

01:51:22,380 --> 01:51:29,360
usually work by damaging the return

01:51:25,680 --> 01:51:29,360
address that is sitting on the stack

01:51:29,450 --> 01:51:36,840
what what we have is basically the use

01:51:34,350 --> 01:51:38,690
of the return instruction to transfer

01:51:36,840 --> 01:51:41,700
control from somewhere other than

01:51:38,690 --> 01:51:47,300
poaching by damaging the return address

01:51:41,700 --> 01:51:49,860
that's present on the stack the the

01:51:47,300 --> 01:51:52,800
fundamental idea is that Rob attacks

01:51:49,860 --> 01:51:55,200
trig functions to return to the wrong

01:51:52,800 --> 01:51:58,260
place with pointer authentication

01:51:55,200 --> 01:52:00,240
Hardware ensures that return actually

01:51:58,260 --> 01:52:03,960
happens to the correct place or rather

01:52:00,240 --> 01:52:08,150
it prevents programs from returning to

01:52:03,960 --> 01:52:12,270
the wrong place what we end up doing is

01:52:08,150 --> 01:52:15,710
essentially using the upper bits of 64

01:52:12,270 --> 01:52:19,610
bit pointer to fold a pointer off then

01:52:15,710 --> 01:52:22,870
Oh what this is is essentially a

01:52:19,610 --> 01:52:28,550
signature of the return address text

01:52:22,870 --> 01:52:33,380
that stored in the upper bits of the

01:52:28,550 --> 01:52:36,680
address this is added and checked by

01:52:33,380 --> 01:52:40,040
some dedicated instructions the

01:52:36,680 --> 01:52:43,070
instructions we've added so let's go and

01:52:40,040 --> 01:52:49,220
take an example here the conventional

01:52:43,070 --> 01:52:51,760
program that combined is very pointer

01:52:49,220 --> 01:52:54,980
authentication turned on essentially

01:52:51,760 --> 01:53:00,140
introduces a couple of new instructions

01:52:54,980 --> 01:53:02,900
one is a pack I ASP which is the first

01:53:00,140 --> 01:53:06,920
instruction in the prologue and then

01:53:02,900 --> 01:53:10,360
we've saved the frame pointer and the

01:53:06,920 --> 01:53:14,510
link register on the stack and

01:53:10,360 --> 01:53:17,120
furthermore we then checked just after

01:53:14,510 --> 01:53:19,100
we've loaded the value what we are

01:53:17,120 --> 01:53:24,190
trying to do is check that the signature

01:53:19,100 --> 01:53:28,310
of the link register matches with what

01:53:24,190 --> 01:53:32,380
we signed in the prologue it matches

01:53:28,310 --> 01:53:32,380
with what we get in the afternoon

01:53:33,460 --> 01:53:39,350
so the IASP andata ASP are a couple of

01:53:37,670 --> 01:53:41,120
instructions which we've added in the

01:53:39,350 --> 01:53:43,520
north's case this means that the

01:53:41,120 --> 01:53:45,920
instructions are backwards compatible

01:53:43,520 --> 01:53:49,880
and therefore you can deploy these and

01:53:45,920 --> 01:53:51,800
older architectures 1rv 8.3 and beyond

01:53:49,880 --> 01:53:54,290
we've got some of these fused

01:53:51,800 --> 01:53:57,230
instructions which try and reduce some

01:53:54,290 --> 01:53:59,780
of the code size below they would end up

01:53:57,230 --> 01:54:01,700
doing the return as well as do an

01:53:59,780 --> 01:54:05,800
authentication they would authenticate

01:54:01,700 --> 01:54:05,800
and then return in

01:54:06,980 --> 01:54:18,750
so this this extension allows us to help

01:54:12,960 --> 01:54:20,790
prevent against rock attacks the the

01:54:18,750 --> 01:54:23,910
other extension that we've got that's

01:54:20,790 --> 01:54:27,060
come up in V 8.5 is the whole thing

01:54:23,910 --> 01:54:35,010
around branch target identifier one of

01:54:27,060 --> 01:54:37,170
the things the this this extension is

01:54:35,010 --> 01:54:39,810
really to help prevent against jump

01:54:37,170 --> 01:54:41,580
oriented programming at PAX we've seen

01:54:39,810 --> 01:54:46,610
some of these examples taken in the

01:54:41,580 --> 01:54:49,610
earlier presentation the idea is that

01:54:46,610 --> 01:54:53,190
pages can be marked as containing

01:54:49,610 --> 01:54:55,250
BTI instructions this under there is an

01:54:53,190 --> 01:54:59,490
additional bit in the page table that

01:54:55,250 --> 01:55:06,000
indicates whether the BEI instruction

01:54:59,490 --> 01:55:08,370
should behave as a norm or as that or

01:55:06,000 --> 01:55:10,530
whether it should behave as a place very

01:55:08,370 --> 01:55:14,790
indirect branch or an indirect polish'

01:55:10,530 --> 01:55:18,750
plaque branching to an indirect branch

01:55:14,790 --> 01:55:21,720
to any place other than well what is

01:55:18,750 --> 01:55:24,030
marked as what is marked with the BTI

01:55:21,720 --> 01:55:29,850
instruction will result in an exception

01:55:24,030 --> 01:55:31,410
now the BDI instruction behaves as a BTI

01:55:29,850 --> 01:55:33,180
instruction only if the corresponding

01:55:31,410 --> 01:55:35,340
page table fittest on earth

01:55:33,180 --> 01:55:37,260
now that's something that will be

01:55:35,340 --> 01:55:40,170
produced in the page table format for be

01:55:37,260 --> 01:55:45,360
8.5 and therefore this is backwards

01:55:40,170 --> 01:55:48,750
compatible so the deployment the BDI

01:55:45,360 --> 01:55:51,120
instruction is enough unless the the

01:55:48,750 --> 01:55:57,540
page table entry for the page containing

01:55:51,120 --> 01:56:00,200
the vdi instruction enables the

01:55:57,540 --> 01:56:00,200
instruction

01:56:01,520 --> 01:56:07,230
what we've what we are looking to do is

01:56:05,280 --> 01:56:10,920
essentially and this is an

01:56:07,230 --> 01:56:13,830
all-or-nothing solution where in terms

01:56:10,920 --> 01:56:15,480
of an elf module and when I speak of a

01:56:13,830 --> 01:56:18,300
next module I am referring to a shared

01:56:15,480 --> 01:56:21,090
object or an executable all the objects

01:56:18,300 --> 01:56:27,270
in the shared object for the executables

01:56:21,090 --> 01:56:30,000
must have a marker that says that PGI is

01:56:27,270 --> 01:56:32,510
enabled on all of these objects and in

01:56:30,000 --> 01:56:38,520
the end the and more you will have a

01:56:32,510 --> 01:56:39,870
marker that states that this is this is

01:56:38,520 --> 01:56:42,360
something this is a module that's

01:56:39,870 --> 01:56:47,910
enabled me here and so it's it's an

01:56:42,360 --> 01:56:55,140
opt-in feature even if you had even if

01:56:47,910 --> 01:56:57,270
you ran this shadow object on on and on

01:56:55,140 --> 01:57:00,570
a version of the architecture that did

01:56:57,270 --> 01:57:03,150
not contain the feature there would be

01:57:00,570 --> 01:57:06,090
no problem because the BTI instruction

01:57:03,150 --> 01:57:12,960
would behave as an orb instruction as it

01:57:06,090 --> 01:57:17,820
is in the nostrils and that's sort of

01:57:12,960 --> 01:57:20,100
what we've done now if you combine the

01:57:17,820 --> 01:57:22,070
return address of tent occation and VPI

01:57:20,100 --> 01:57:26,580
and you are able to protect yourself

01:57:22,070 --> 01:57:30,780
against rock and job attacks on the AR

01:57:26,580 --> 01:57:33,110
64 architecture the going back to the

01:57:30,780 --> 01:57:36,390
example that i had in the earlier slide

01:57:33,110 --> 01:57:38,670
we if you had DDI and pointer

01:57:36,390 --> 01:57:41,880
authentication through together what you

01:57:38,670 --> 01:57:43,860
end up seeing is a bt AIC instruction as

01:57:41,880 --> 01:57:46,530
the first instruction in the function

01:57:43,860 --> 01:57:50,910
followed by something that protects your

01:57:46,530 --> 01:57:55,170
return address and whatever the function

01:57:50,910 --> 01:57:58,820
does is fine and then you return and

01:57:55,170 --> 01:57:58,820
before you return from the

01:57:59,940 --> 01:58:07,619
function you authenticate the stuff the

01:58:03,570 --> 01:58:09,920
value of Ni if an attacker had changed

01:58:07,619 --> 01:58:15,330
the value of a lot anywhere in between

01:58:09,920 --> 01:58:18,510
the author ASP guarantees that the value

01:58:15,330 --> 01:58:23,429
of a lot would be suitably manually so

01:58:18,510 --> 01:58:25,940
that the so that the program would trap

01:58:23,429 --> 01:58:28,380
at the point of time you have to return

01:58:25,940 --> 01:58:31,199
this is how we are managing to achieve

01:58:28,380 --> 01:58:35,280
protection against rock and job attacks

01:58:31,199 --> 01:58:36,929
together it sort of helps us raise the

01:58:35,280 --> 01:58:40,170
bar in that regard

01:58:36,929 --> 01:58:42,119
now the observant among you might notice

01:58:40,170 --> 01:58:48,210
that we've got two instructions here

01:58:42,119 --> 01:58:49,679
which are sort of you you have two

01:58:48,210 --> 01:58:52,530
instructions in the prologue of the

01:58:49,679 --> 01:58:56,040
function you have an instruction which

01:58:52,530 --> 01:59:01,230
is a bTW I see you also have a pact IAS

01:58:56,040 --> 01:59:04,800
P over there now you would think that

01:59:01,230 --> 01:59:07,790
two instruction size that's essentially

01:59:04,800 --> 01:59:11,070
a bite that's not going to cost much but

01:59:07,790 --> 01:59:13,800
why do we want to blow so one of the

01:59:11,070 --> 01:59:17,909
things we may ended up doing is saying

01:59:13,800 --> 01:59:21,060
that the fact is P can also act as a

01:59:17,909 --> 01:59:26,130
valid instruction where an indirect

01:59:21,060 --> 01:59:29,820
branch can land that that way we are

01:59:26,130 --> 01:59:32,130
able to protect variable two we have

01:59:29,820 --> 01:59:35,670
enhanced the meaning of the package ASP

01:59:32,130 --> 01:59:42,349
instruction and B 8.5 to say that in

01:59:35,670 --> 01:59:46,349
addition to saving in addition to

01:59:42,349 --> 01:59:50,969
signing the return address with the a

01:59:46,349 --> 01:59:52,820
key and the stack pointer you're acting

01:59:50,969 --> 01:59:55,940
as a

01:59:52,820 --> 01:59:59,219
you are effectively acting as a PDI

01:59:55,940 --> 02:00:04,110
instructional therefore an indirect call

01:59:59,219 --> 02:00:07,710
or good land at the pocke ASP

02:00:04,110 --> 02:00:10,909
instruction now when we did this there

02:00:07,710 --> 02:00:14,519
were a couple of challenges when we

02:00:10,909 --> 02:00:18,420
implemented support for return address

02:00:14,519 --> 02:00:19,710
signing as well as BTI one of the main

02:00:18,420 --> 02:00:22,230
challenges with return address

02:00:19,710 --> 02:00:26,789
authentication is the fact that your LR

02:00:22,230 --> 02:00:30,769
is now fundament is has been changed in

02:00:26,789 --> 02:00:38,420
a way because the top bits of the fellas

02:00:30,769 --> 02:00:40,739
have been modified so the so the back hi

02:00:38,420 --> 02:00:43,590
so if you look at the operation of the

02:00:40,739 --> 02:00:45,840
FATCA ast instruction what what it does

02:00:43,590 --> 02:00:50,280
as the path is essentially pointer

02:00:45,840 --> 02:00:54,480
authenticated with the ie with I which

02:00:50,280 --> 02:00:56,999
is an instruction pointer what we call

02:00:54,480 --> 02:00:59,210
b18 there are a number of e's that we've

02:00:56,999 --> 02:01:06,869
added we brought an equal hand a pinky

02:00:59,210 --> 02:01:10,559
and with the we are taking the value

02:01:06,869 --> 02:01:13,079
from xn which is a source register that

02:01:10,559 --> 02:01:18,059
happens to be the SP register the stack

02:01:13,079 --> 02:01:22,579
pointer and we provide a signature in

02:01:18,059 --> 02:01:22,579
the top bits of the address

02:01:23,929 --> 02:01:32,040
this is how the LR is being changed now

02:01:28,469 --> 02:01:35,510
what this results in is an issue with

02:01:32,040 --> 02:01:39,630
exception handling in the sense that

02:01:35,510 --> 02:01:44,219
we've now got C++ friend exception

02:01:39,630 --> 02:01:46,099
things that have LR which has been

02:01:44,219 --> 02:01:49,530
changed in a particular way

02:01:46,099 --> 02:01:53,280
so what we now end up doing is we've

02:01:49,530 --> 02:01:56,099
added both annotations in the dwarf API

02:01:53,280 --> 02:01:59,130
infer arms that allows us to mark such

02:01:56,099 --> 02:02:01,639
Springs and then we go and check in the

02:01:59,130 --> 02:02:06,780
unwind oven

02:02:01,639 --> 02:02:09,840
whether the the frame that's being alone

02:02:06,780 --> 02:02:12,119
is correct there better be a lot that's

02:02:09,840 --> 02:02:15,260
being used for unwinding is correct by

02:02:12,119 --> 02:02:18,329
checking against the canonical SP value

02:02:15,260 --> 02:02:20,550
so that way we are also protecting

02:02:18,329 --> 02:02:23,540
ourselves with attacks on the exception

02:02:20,550 --> 02:02:23,540
frame and winders

02:02:29,270 --> 02:02:33,220
where are you putting the documentation

02:02:33,310 --> 02:02:42,400
we have we put the dwarf annotations as

02:02:41,080 --> 02:02:45,050
[Music]

02:02:42,400 --> 02:02:49,520
warframe annotations here I think we are

02:02:45,050 --> 02:02:56,739
overriding one of the spark the New

02:02:49,520 --> 02:03:00,260
Marais state value for the gate we have

02:02:56,739 --> 02:03:04,130
for the BTB are indicating be keyframes

02:03:00,260 --> 02:03:08,030
by adding another CI e augmentation

02:03:04,130 --> 02:03:11,720
character within the FV so we are able

02:03:08,030 --> 02:03:20,239
to mark that with another augmentation

02:03:11,720 --> 02:03:21,640
cap in the each frame yeah so a

02:03:20,239 --> 02:03:24,739
different question

02:03:21,640 --> 02:03:29,090
lower jet actually uses the upper bits

02:03:24,739 --> 02:03:30,530
of the address for some optimizations

02:03:29,090 --> 02:03:36,040
are not sure exactly what the details

02:03:30,530 --> 02:03:36,040
are but then wouldn't that conflict with

02:03:50,739 --> 02:03:58,910
okay so it won't conflict I don't I

02:03:56,660 --> 02:04:04,220
don't think I don't know the use case of

02:03:58,910 --> 02:04:07,100
no budget but usually Judas believes we

02:04:04,220 --> 02:04:09,470
will away information training data

02:04:07,100 --> 02:04:12,030
pointers the point to remember here

02:04:09,470 --> 02:04:16,380
because this is an instruction pointer

02:04:12,030 --> 02:04:22,610
and it's essentially we are trying to

02:04:16,380 --> 02:04:22,610
protect the return address and therefore

02:04:25,220 --> 02:04:31,680
couple things first I take it this is

02:04:30,000 --> 02:04:33,810
something you have to do in your

02:04:31,680 --> 02:04:37,950
compiling I don't do you expect to do

02:04:33,810 --> 02:04:40,710
this for the colonel because you just

02:04:37,950 --> 02:04:45,780
destroyed Kay Brett probes and function

02:04:40,710 --> 02:04:49,080
graph guess what we're working on right

02:04:45,780 --> 02:04:50,400
now yeah so yeah because we basically

02:04:49,080 --> 02:04:55,890
have to disable it was the enable

02:04:50,400 --> 02:04:57,480
function graph tracer or okay we we can

02:04:55,890 --> 02:04:59,010
put the appropriate D mangling and

02:04:57,480 --> 02:05:00,630
mangling in this was why I wanted to

02:04:59,010 --> 02:05:02,550
talk to you about F trace with rags so

02:05:00,630 --> 02:05:05,010
we can get the appropriate salt value

02:05:02,550 --> 02:05:17,730
for the pakka ASP or tspa pairs we have

02:05:05,010 --> 02:05:19,800
a plan and also as acting as a Linux

02:05:17,730 --> 02:05:21,480
Plummer Shepherd we wanted more of a

02:05:19,800 --> 02:05:23,010
discussion base right now it seems more

02:05:21,480 --> 02:05:25,980
presentation based so I'm wondering if

02:05:23,010 --> 02:05:28,640
you have more of like something that

02:05:25,980 --> 02:05:30,600
they're all more of a discussion to

02:05:28,640 --> 02:05:33,090
write well the question is one thing but

02:05:30,600 --> 02:05:34,290
I'm saying what the point of plumbers is

02:05:33,090 --> 02:05:36,840
basically not just showing what you've

02:05:34,290 --> 02:05:40,710
done but basically saying hey how do I

02:05:36,840 --> 02:05:42,630
you know try to get more of like where

02:05:40,710 --> 02:05:45,600
could we go in the future and like that

02:05:42,630 --> 02:05:52,110
focus space yes okay we're getting

02:05:45,600 --> 02:05:54,620
tinnitus why make sure but yeah I want

02:05:52,110 --> 02:05:54,620
this yes

02:06:02,420 --> 02:06:08,400
so one of the things that we've been

02:06:06,270 --> 02:06:11,280
talking about is that apparently God

02:06:08,400 --> 02:06:14,130
appears to be a favorite target for a

02:06:11,280 --> 02:06:16,380
number of attacks quite a few but not

02:06:14,130 --> 02:06:18,920
all distributions mandate full read row

02:06:16,380 --> 02:06:18,920
and bind now

02:06:20,480 --> 02:06:27,480
however full row I don't believe this on

02:06:24,270 --> 02:06:29,699
by default on all the stores there are

02:06:27,480 --> 02:06:32,280
some disclose that mandated I believe

02:06:29,699 --> 02:06:37,409
there are some issues with X and

02:06:32,280 --> 02:06:39,449
correctness and there are some people

02:06:37,409 --> 02:06:42,539
who are one who are concerned about

02:06:39,449 --> 02:06:46,340
performance issues because full read row

02:06:42,539 --> 02:06:49,920
and by now implies that we need to load

02:06:46,340 --> 02:06:52,739
we need to do all the we cannot have any

02:06:49,920 --> 02:06:55,860
lazy binding for dynamic shared objects

02:06:52,739 --> 02:07:00,869
if you've got a large dynamic shared

02:06:55,860 --> 02:07:02,460
object you you've got to do all the

02:07:00,869 --> 02:07:12,510
simple resolution on the front even if

02:07:02,460 --> 02:07:15,780
you think use the function special so so

02:07:12,510 --> 02:07:19,409
the current LD sequence for yacht 64

02:07:15,780 --> 02:07:25,949
looks something like this you could in

02:07:19,409 --> 02:07:31,559
theory have a new p LT got a new BLT

02:07:25,949 --> 02:07:34,739
sequence that that essentially used Auto

02:07:31,559 --> 02:07:38,699
a X 17 X 16 which is again in the knob

02:07:34,739 --> 02:07:41,210
space to try to save in the store or to

02:07:38,699 --> 02:07:41,210
try and

02:07:42,250 --> 02:07:50,200
to try and provide a signature for what

02:07:44,710 --> 02:07:54,990
PLT entry is this something that would

02:07:50,200 --> 02:07:57,700
be interesting for distros to look at

02:07:54,990 --> 02:08:01,630
there are other areas where this would

02:07:57,700 --> 02:08:05,200
be used virtual tables is a problem and

02:08:01,630 --> 02:08:08,170
I don't know how to solve that

02:08:05,200 --> 02:08:12,340
particular problem when you know people

02:08:08,170 --> 02:08:14,380
would like to attack virtual tables but

02:08:12,340 --> 02:08:33,940
it runs into the problem that pointers

02:08:14,380 --> 02:08:38,730
are a bi hello

02:08:33,940 --> 02:08:59,830
you want this like P table should be

02:08:38,730 --> 02:09:01,990
railroad right like there should be so

02:08:59,830 --> 02:09:05,350
if you pointers that are getting passed

02:09:01,990 --> 02:09:07,270
from one DSO to another do you have a

02:09:05,350 --> 02:09:11,350
situation where some point those are

02:09:07,270 --> 02:09:13,570
mine when others are more yep the

02:09:11,350 --> 02:09:16,920
problem is really in a hybrid or a mixed

02:09:13,570 --> 02:09:16,920
system fight that's

02:09:17,730 --> 02:09:28,440
I think the question is more like why is

02:09:26,280 --> 02:09:30,570
that a problem to begin with like how is

02:09:28,440 --> 02:09:35,270
someone modifying the V table at runtime

02:09:30,570 --> 02:09:35,270
for exploit how

02:09:46,550 --> 02:09:54,650
you know when somebody has got an object

02:09:50,809 --> 02:10:13,809
it's essentially use of the free on an

02:09:54,650 --> 02:10:13,809
object so just to come back

02:10:14,230 --> 02:10:20,210
the return address signing with the a

02:10:16,340 --> 02:10:22,670
key is in GCC seven on which the return

02:10:20,210 --> 02:10:25,269
address signing with the B II patches

02:10:22,670 --> 02:10:27,800
around the review of targeting GCC nine

02:10:25,269 --> 02:10:30,499
LLVM changes are also being reviewed of

02:10:27,800 --> 02:10:33,400
straining right now the patches for

02:10:30,499 --> 02:10:36,409
point assigning are under review and

02:10:33,400 --> 02:10:38,110
there's some JV work that needs to

02:10:36,409 --> 02:10:44,389
happen for point assigning that external

02:10:38,110 --> 02:10:50,239
that will probably happen in terms of

02:10:44,389 --> 02:10:52,369
the rest of be 8.58 we've got basic

02:10:50,239 --> 02:10:55,099
vineyard L support for all of V eight

02:10:52,369 --> 02:10:57,440
point five a in the latest vineyard and

02:10:55,099 --> 02:10:59,900
strong for the branch target

02:10:57,440 --> 02:11:01,579
identification stuff we've got some

02:10:59,900 --> 02:11:04,579
compiler patches that are being reviewed

02:11:01,579 --> 02:11:07,159
upstream the link there are some linker

02:11:04,579 --> 02:11:09,440
patches that are being worked on in

02:11:07,159 --> 02:11:14,420
conjunction with you know some of the

02:11:09,440 --> 02:11:18,789
changes that we have to do and then the

02:11:14,420 --> 02:11:18,789
dynamically matches are still paying

02:11:19,600 --> 02:11:23,949
in terms of another feature as I said

02:11:21,520 --> 02:11:27,239
respect to memory packing the assembler

02:11:23,949 --> 02:11:32,429
disassembler support is now upstream

02:11:27,239 --> 02:11:32,429
some GCC eg let's see well for that is

02:11:32,940 --> 02:11:36,330
any questions

02:11:41,390 --> 02:11:49,140
so as far as gilepsy work is concerned

02:11:45,660 --> 02:11:52,890
for memory tagging do you have any plans

02:11:49,140 --> 02:11:55,920
to like add support to malloc maybe put

02:11:52,890 --> 02:12:01,250
in some scaffolding in four to twenty

02:11:55,920 --> 02:12:08,010
nine so that we can have that only one

02:12:01,250 --> 02:12:34,800
okay so okay so I'm not gonna block on

02:12:08,010 --> 02:12:36,980
your four to twenty nine yeah yeah DCC

02:12:34,800 --> 02:12:36,980
and

02:12:57,070 --> 02:13:03,040
explain the pgic instruction how does it

02:13:05,870 --> 02:13:09,090
[Music]

02:13:32,110 --> 02:13:44,060
so the the point is the one attack is

02:13:41,540 --> 02:13:49,250
basically that an indirect branch is

02:13:44,060 --> 02:13:53,240
being made and a label or program

02:13:49,250 --> 02:14:00,380
location that it was not so how did you

02:13:53,240 --> 02:14:02,120
generate the memory map tagging so I'm

02:14:00,380 --> 02:14:05,630
thinking of like a CFI which already

02:14:02,120 --> 02:14:09,200
exists in the corner where the link time

02:14:05,630 --> 02:14:12,920
optimization instrument all the branches

02:14:09,200 --> 02:14:14,930
right so the colors actually checked so

02:14:12,920 --> 02:14:20,530
do you have any idea how to use those

02:14:14,930 --> 02:14:20,530
like together with the existing ones

02:14:21,570 --> 02:14:25,949
I was gonna answer the prior question

02:14:23,219 --> 02:14:27,570
which was that this does not check that

02:14:25,949 --> 02:14:29,489
at all this only checks the class of

02:14:27,570 --> 02:14:31,619
branches to get there so it could be

02:14:29,489 --> 02:14:35,030
used in conjunction with existing

02:14:31,619 --> 02:14:37,050
software CFI techniques it does it's not

02:14:35,030 --> 02:14:38,579
it doesn't rule those out

02:14:37,050 --> 02:14:40,710
you could have additional checks all

02:14:38,579 --> 02:14:42,000
this prevents is branching into an

02:14:40,710 --> 02:14:44,810
arbitrary instruction in the middle of

02:14:42,000 --> 02:14:44,810
an instruction stream

02:15:17,619 --> 02:15:24,360
if you need to find out more what

02:15:21,310 --> 02:15:24,360
fillings and slice

02:15:25,540 --> 02:15:32,630
[Applause]

02:16:02,040 --> 02:16:07,170
initialization is speculative yeah it

02:16:04,720 --> 02:16:07,170
was really

02:16:37,170 --> 02:16:44,849
you have this this was mostly a question

02:16:41,439 --> 02:16:46,660
about were started looking at

02:16:44,849 --> 02:16:48,639
initializing stack variables all the

02:16:46,660 --> 02:16:52,030
time this is something that's come up a

02:16:48,639 --> 02:16:55,059
little bit in the kernel and part of

02:16:52,030 --> 02:16:58,650
this process was you know looking at the

02:16:55,059 --> 02:17:01,809
C spec padding bytes in a structure are

02:16:58,650 --> 02:17:03,580
undefined as far as clearing them goes

02:17:01,809 --> 02:17:05,439
you know you can have an initializer and

02:17:03,580 --> 02:17:06,460
say I want this and that initialize you

02:17:05,439 --> 02:17:08,439
can have an empty you know an empty

02:17:06,460 --> 02:17:10,719
initializer that says that implies

02:17:08,439 --> 02:17:12,160
everything should be zeroed but the

02:17:10,719 --> 02:17:14,250
padding bytes aren't actually part of

02:17:12,160 --> 02:17:16,599
that specification and they may

02:17:14,250 --> 02:17:19,689
depending on how the machine language

02:17:16,599 --> 02:17:21,790
gets laid out not get touched during

02:17:19,689 --> 02:17:24,010
initialization and it'll be really nice

02:17:21,790 --> 02:17:26,769
to have that be deterministic to not

02:17:24,010 --> 02:17:29,019
have that be undefined behavior because

02:17:26,769 --> 02:17:31,510
then we can build additional constructs

02:17:29,019 --> 02:17:32,830
on top of that we can we can ask for you

02:17:31,510 --> 02:17:34,059
know full initialization all the time

02:17:32,830 --> 02:17:36,519
and you don't have to worry about the

02:17:34,059 --> 02:17:39,400
padding bytes and existing surprises and

02:17:36,519 --> 02:17:41,260
kernel another source the padding bytes

02:17:39,400 --> 02:17:44,260
we know are initialized if there was an

02:17:41,260 --> 02:17:45,870
initializer of that variable ever things

02:17:44,260 --> 02:17:48,099
like that so it was mostly a question of

02:17:45,870 --> 02:17:51,670
what's the right approach to take to

02:17:48,099 --> 02:17:54,939
getting padding bytes not made undefined

02:17:51,670 --> 02:18:00,250
for for initialization since I have no

02:17:54,939 --> 02:18:01,389
idea where to start looking at that my

02:18:00,250 --> 02:18:03,929
understanding is it is considered

02:18:01,389 --> 02:18:03,929
undefined behavior

02:18:10,590 --> 02:18:16,529
right I haven't encountered anyone

02:18:13,359 --> 02:18:19,899
saying that it was guaranteed to be

02:18:16,529 --> 02:18:22,420
initialized correctly so that's sort of

02:18:19,899 --> 02:18:26,620
what I was looking at is are there test

02:18:22,420 --> 02:18:29,889
cases so you want a memory sanitizer for

02:18:26,620 --> 02:18:33,099
the car no that will be down the road a

02:18:29,889 --> 02:18:35,529
bit but not having a lot of that can

02:18:33,099 --> 02:18:37,330
already be done just by specifying oh I

02:18:35,529 --> 02:18:40,599
have a partial initializer here and

02:18:37,330 --> 02:18:42,130
everything else gets zeroed but the

02:18:40,599 --> 02:18:44,949
specification and some of the behavior

02:18:42,130 --> 02:18:46,989
says only fields of a structure were

02:18:44,949 --> 02:18:49,029
guaranteed to be zero and the padding

02:18:46,989 --> 02:18:51,130
bytes are might be taken along for the

02:18:49,029 --> 02:18:53,529
ride in case they're you know but you

02:18:51,130 --> 02:18:55,330
know the bit width was the right size

02:18:53,529 --> 02:18:58,569
that the neighboring ones as well we'll

02:18:55,330 --> 02:19:01,630
just do a zero extension on a whatever

02:18:58,569 --> 02:19:04,389
yeah because I think you have this kind

02:19:01,630 --> 02:19:08,410
of analysis on memory sanitizers that

02:19:04,389 --> 02:19:10,599
incremental LLVM it check if the memory

02:19:08,410 --> 02:19:12,489
is not in the sanitizers will do this

02:19:10,599 --> 02:19:15,399
but I would like it as a runtime feature

02:19:12,489 --> 02:19:16,960
of just it's no longer I defined all

02:19:15,399 --> 02:19:19,739
padding bytes are zero if there is an

02:19:16,960 --> 02:19:19,739
initializer at all

02:19:20,080 --> 02:19:26,830
what is the sanitizer warning on exactly

02:19:24,160 --> 02:19:27,429
that you're using another life yeah

02:19:26,830 --> 02:19:30,939
exactly

02:19:27,429 --> 02:19:32,199
okay anyway it's just a question of is

02:19:30,939 --> 02:19:35,819
there anyone who can look at this what

02:19:32,199 --> 02:19:35,819
is the right place to start I don't know

02:19:35,910 --> 02:19:42,029
could that be a compiler option I would

02:19:39,790 --> 02:19:42,029
love that

02:19:42,450 --> 02:19:46,380
right so I think so there are a number

02:19:44,760 --> 02:19:49,680
of questions in there right so one of

02:19:46,380 --> 02:19:56,070
them is initialization of padding bytes

02:19:49,680 --> 02:19:58,320
alongside your local variables I don't

02:19:56,070 --> 02:20:02,520
know is it possible to like have a late

02:19:58,320 --> 02:20:04,280
pass which does not mask warnings that

02:20:02,520 --> 02:20:06,300
that actually does initialization

02:20:04,280 --> 02:20:07,920
something that is like just before

02:20:06,300 --> 02:20:17,130
lowering to RTLS a minute

02:20:07,920 --> 02:20:19,590
I don't know offhand but this is

02:20:17,130 --> 02:20:20,670
probably something that's best discussed

02:20:19,590 --> 02:20:23,370
on the list okay

02:20:20,670 --> 02:20:26,880
and I'm sure Joseph will have an opinion

02:20:23,370 --> 02:20:32,010
on this and he'll probably be the right

02:20:26,880 --> 02:20:33,810
person oh yeah yeah yeah and he is the

02:20:32,010 --> 02:20:37,770
seafront and maintainer okay he'd

02:20:33,810 --> 02:20:39,840
probably be the right person to related

02:20:37,770 --> 02:20:42,530
monsignor that had to like people asked

02:20:39,840 --> 02:20:45,420
me before for like especially if you're

02:20:42,530 --> 02:20:48,600
attending cryptography have an ability

02:20:45,420 --> 02:20:50,430
to like have a bad store stay because

02:20:48,600 --> 02:20:51,630
you want this veil to be destructed it's

02:20:50,430 --> 02:20:53,130
not the same thing as volatile right

02:20:51,630 --> 02:20:55,620
like I mean the compiler can Co optimize

02:20:53,130 --> 02:20:57,439
this as budget it wants it can be on the

02:20:55,620 --> 02:21:01,080
registers but like have them the last

02:20:57,439 --> 02:21:05,040
assignment that's for signing 0 like no

02:21:01,080 --> 02:21:07,050
that's not bad like you really do 0 this

02:21:05,040 --> 02:21:09,780
value like when things are going out of

02:21:07,050 --> 02:21:11,340
scope yeah like it's old it's not just

02:21:09,780 --> 02:21:14,160
out of scope like you own the Seco do

02:21:11,340 --> 02:21:16,910
you write like T equals zero right we

02:21:14,160 --> 02:21:19,670
are deleting the very of this key and

02:21:16,910 --> 02:21:22,670
the compiler so that's a dead stork

02:21:19,670 --> 02:21:22,670
right

02:21:22,851 --> 02:21:32,000
right yep yes exactly and then yeah like

02:21:27,960 --> 02:21:32,000
the upon its head that's that's dad yeah

02:21:32,960 --> 02:21:39,030
yeah like have like hey yeah have a look

02:21:36,120 --> 02:21:41,130
out some way to like like this store is

02:21:39,030 --> 02:21:43,110
not really dead right and deleting this

02:21:41,130 --> 02:21:44,880
because if someone has I'd exploit

02:21:43,110 --> 02:21:48,000
somewhere at least they can't go read

02:21:44,880 --> 02:21:50,750
Mikey off the red trousers or like the

02:21:48,000 --> 02:21:50,750
stock or whatever

02:21:56,260 --> 02:22:00,940
but but that's still just memory right

02:22:04,540 --> 02:22:20,180
way to do it yeah so it's just only the

02:22:17,720 --> 02:22:22,641
same idea of like there's according to

02:22:20,180 --> 02:22:26,391
the see specs this value it doesn't

02:22:22,641 --> 02:22:32,650
matter but just in case can you please

02:22:26,391 --> 02:22:32,650
make it zero yeah that's all I had

02:22:46,170 --> 02:22:52,390
the end result of that is that memories

02:22:48,610 --> 02:22:55,000
hand sanitizer no longer sees that that

02:22:52,390 --> 02:22:56,710
should have been a problem so you're

02:22:55,000 --> 02:22:57,880
essentially masking that in right that

02:22:56,710 --> 02:23:00,640
was a problem

02:22:57,880 --> 02:23:02,200
I think fluorine wiemer sent a version

02:23:00,640 --> 02:23:04,420
of this but it didn't cover padding

02:23:02,200 --> 02:23:06,030
bytes but basically it said was there an

02:23:04,420 --> 02:23:08,830
initializer for this variable at all

02:23:06,030 --> 02:23:12,330
okay now I'll perform an initialization

02:23:08,830 --> 02:23:14,950
and then move on and that masks the the

02:23:12,330 --> 02:23:17,230
uninitialized variable warning but

02:23:14,950 --> 02:23:18,940
padding bytes were still not included

02:23:17,230 --> 02:23:21,400
because it was just using a regular

02:23:18,940 --> 02:23:24,070
initializer it wasn't like a full member

02:23:21,400 --> 02:23:27,310
of the entire area so my understanding

02:23:24,070 --> 02:23:28,930
of Florian's of objection was what was

02:23:27,310 --> 02:23:31,240
with respect to the compiler and not

02:23:28,930 --> 02:23:33,670
memory sanitizer so the compiler we can

02:23:31,240 --> 02:23:35,680
we can probably juggle around with the

02:23:33,670 --> 02:23:37,840
passes a bit and try to make sure that

02:23:35,680 --> 02:23:40,570
we have the warning right and then zero

02:23:37,840 --> 02:23:42,120
it out right but then with the memory

02:23:40,570 --> 02:23:48,520
sanitizer which is running at runtime

02:23:42,120 --> 02:23:50,470
that is already too late if that sort of

02:23:48,520 --> 02:23:52,810
undefined behavior goes away then the

02:23:50,470 --> 02:23:54,070
memory sanitizer does doesn't have

02:23:52,810 --> 02:23:57,100
anything to worry about and that's sort

02:23:54,070 --> 02:24:07,680
of okay because it got initialized so

02:23:57,100 --> 02:24:07,680
it's okay right

02:24:08,300 --> 02:24:14,999
well yeah my my hope would be then you

02:24:11,729 --> 02:24:16,800
know the store optimization would go oh

02:24:14,999 --> 02:24:18,659
I don't actually have to write a zero to

02:24:16,800 --> 02:24:21,180
this one because I'm gonna write a five

02:24:18,659 --> 02:24:22,739
here and you would get the optimization

02:24:21,180 --> 02:24:25,550
and most the initializations would go

02:24:22,739 --> 02:24:28,590
away which I think was flourines

02:24:25,550 --> 02:24:30,840
approach for just if I don't see an

02:24:28,590 --> 02:24:35,460
existing initializer add 1 and then i'll

02:24:30,840 --> 02:24:38,189
get optimized away or whatever well I

02:24:35,460 --> 02:24:40,710
was probably thinking of more for force

02:24:38,189 --> 02:24:46,159
approach here yeah real sensitive about

02:24:40,710 --> 02:24:46,159
performance I thought that would happen

02:24:49,909 --> 02:24:55,470
yeah I I'd love to find a good

02:24:52,710 --> 02:24:57,569
performance approach I'm fine now do

02:24:55,470 --> 02:25:02,539
whatever no but it's a still performance

02:24:57,569 --> 02:25:02,539
still does when you do that

02:25:10,570 --> 02:25:27,431
just zero on the cash flow yeah zeros

02:25:23,830 --> 02:25:29,320
fine Zero's easiest it's mostly I just

02:25:27,431 --> 02:25:36,181
don't want ever what was there to be

02:25:29,320 --> 02:25:36,181
there anymore unless it's zero it's just

02:25:40,070 --> 02:25:45,660
how is going to interact with C++ when

02:25:42,931 --> 02:25:49,801
you have automatic object that cannot be

02:25:45,660 --> 02:25:53,160
0 in each use the default constructor

02:25:49,801 --> 02:26:03,141
which is different than just 0 the

02:25:53,160 --> 02:26:03,141
memory should we call the constructor

02:26:04,670 --> 02:26:11,780
and the destructor on the a block

02:26:07,530 --> 02:26:18,410
I mean for instance you have a c-class

02:26:11,780 --> 02:26:18,410
that become the compiler we just create

02:26:31,290 --> 02:26:39,040
so I guess what I'm saying is you do the

02:26:35,560 --> 02:26:42,810
zeroing when you're allocating space in

02:26:39,040 --> 02:26:45,880
the prologue and technically the

02:26:42,810 --> 02:26:48,520
constructor should be called after that

02:26:45,880 --> 02:26:51,460
it should be called up technically after

02:26:48,520 --> 02:26:57,970
you've allocated the space in the

02:26:51,460 --> 02:27:01,660
prologue and that way it there should

02:26:57,970 --> 02:27:03,729
not be an issue but that's what I'm

02:27:01,660 --> 02:27:05,820
thinking right now okay yeah I don't

02:27:03,729 --> 02:27:12,670
think that you might make sense yeah

02:27:05,820 --> 02:27:15,450
it's just throwing out ideas so I'll

02:27:12,670 --> 02:27:25,870
send some questions the list I guess

02:27:15,450 --> 02:27:32,050
all right cool well thanks that's why

02:27:25,870 --> 02:27:36,220
I'm here if I knew how to solve no I can

02:27:32,050 --> 02:27:36,640
okay I'll send a package like this for

02:27:36,220 --> 02:27:38,170
coming

02:27:36,640 --> 02:27:40,590
delete a line I don't know it doesn't

02:27:38,170 --> 02:27:40,590
compile

02:27:52,091 --> 02:27:59,631
the topics people want to discuss any

02:27:55,851 --> 02:28:07,551
other way other top topics that we

02:27:59,631 --> 02:28:09,141
publicly want to discuss so yes thank

02:28:07,551 --> 02:28:12,620
you very much for everybody attending

02:28:09,141 --> 02:28:15,230
this inaugural mini conference on the

02:28:12,620 --> 02:28:17,540
tool chain and I want to thank the

02:28:15,230 --> 02:28:22,881
organizers again Victor and HJ Romana

02:28:17,540 --> 02:28:24,830
and so - and AJ and Carlos for helping

02:28:22,881 --> 02:28:26,900
to organize this and thanks everybody

02:28:24,830 --> 02:28:28,551
for attending and participating the

02:28:26,900 --> 02:28:30,771
discussion and hopefully we can make

02:28:28,551 --> 02:28:33,921
this a regular event so thank you very

02:28:30,771 --> 02:28:36,341
much have a good afternoon and enjoy the

02:28:33,921 --> 02:28:36,341
rest of the conference

02:28:37,070 --> 02:28:40,760

YouTube URL: https://www.youtube.com/watch?v=-9oTH0TPXOE


