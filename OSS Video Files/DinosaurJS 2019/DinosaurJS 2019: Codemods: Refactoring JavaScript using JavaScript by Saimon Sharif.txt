Title: DinosaurJS 2019: Codemods: Refactoring JavaScript using JavaScript by Saimon Sharif
Publication date: 2019-08-19
Playlist: DinosaurJS 2019
Description: 
	DinosaurJS 2019: Codemods: Refactoring JavaScript using JavaScript by Saimon Sharif
Captions: 
	00:00:01,550 --> 00:00:06,490
[Applause]

00:00:04,100 --> 00:00:08,880
[Music]

00:00:06,490 --> 00:00:10,230
[Applause]

00:00:08,880 --> 00:00:14,240
[Music]

00:00:10,230 --> 00:00:17,100
[Applause]

00:00:14,240 --> 00:00:19,230
cool sorry folks I'm Simon thanks for

00:00:17,100 --> 00:00:20,850
having me I know on the last talk before

00:00:19,230 --> 00:00:22,740
lunch so I'll make it worth your while

00:00:20,850 --> 00:00:25,680
I'm here to talk about using code mods

00:00:22,740 --> 00:00:28,349
to refactor your JavaScript using

00:00:25,680 --> 00:00:30,450
javascript so so real quick there's some

00:00:28,349 --> 00:00:32,040
quick background on me I'm a senior

00:00:30,450 --> 00:00:34,680
engineer I run the road Rent the Runway

00:00:32,040 --> 00:00:35,880
based out of New York City I'm on RTR

00:00:34,680 --> 00:00:37,380
psych performance team and was

00:00:35,880 --> 00:00:39,810
previously the tech lead on a new

00:00:37,380 --> 00:00:41,370
consumer facing teams RT R is a

00:00:39,810 --> 00:00:43,410
ecommerce platform where you can rent

00:00:41,370 --> 00:00:44,640
your dream outfit having a chat about RT

00:00:43,410 --> 00:00:45,680
R afterwards if you folks have any

00:00:44,640 --> 00:00:48,150
questions

00:00:45,680 --> 00:00:50,370
PS we're also hiring so come talk to me

00:00:48,150 --> 00:00:52,320
afterwards if you're interested I'm also

00:00:50,370 --> 00:00:53,760
a part-time instructor at General

00:00:52,320 --> 00:00:55,160
Assembly in New York I've taught evening

00:00:53,760 --> 00:00:57,450
courses in front-end web development

00:00:55,160 --> 00:01:00,990
JavaScript and Python as well as many

00:00:57,450 --> 00:01:02,910
short workshops so let's get started I'm

00:01:00,990 --> 00:01:07,920
sure some of you folks are thinking code

00:01:02,910 --> 00:01:09,900
once so what exactly is a code bot code

00:01:07,920 --> 00:01:12,390
mods are scripts used to help with the

00:01:09,900 --> 00:01:15,000
refactoring code the term originated

00:01:12,390 --> 00:01:17,159
from a tool named code mod that was open

00:01:15,000 --> 00:01:19,140
source by Facebook this first tool uses

00:01:17,159 --> 00:01:21,509
regular expressions in Python for the

00:01:19,140 --> 00:01:23,280
refactoring scripts Facebook also open

00:01:21,509 --> 00:01:26,549
source J's code shipped the tool we're

00:01:23,280 --> 00:01:28,649
gonna see in today's talk essentially we

00:01:26,549 --> 00:01:30,749
can programmatically refactor the Java

00:01:28,649 --> 00:01:34,859
files in our code base by writing

00:01:30,749 --> 00:01:39,030
transformers in JavaScript that sounds

00:01:34,859 --> 00:01:41,929
pretty wild right actually if we think

00:01:39,030 --> 00:01:44,759
about it code mods are pretty mainstream

00:01:41,929 --> 00:01:46,229
you ever had to upgrade react there's a

00:01:44,759 --> 00:01:48,030
good chance that your scene code mods

00:01:46,229 --> 00:01:51,329
mentioned in the blog post and the

00:01:48,030 --> 00:01:53,549
documentation so personal opinion alert

00:01:51,329 --> 00:01:56,100
but I think mainstream check are great

00:01:53,549 --> 00:01:57,509
there's a lot of risk with using

00:01:56,100 --> 00:01:58,950
bleeding edge or not fully baked

00:01:57,509 --> 00:02:01,109
libraries especially with production

00:01:58,950 --> 00:02:04,039
code bases when writing code at work i'd

00:02:01,109 --> 00:02:06,060
much rather use a mainstream library

00:02:04,039 --> 00:02:08,190
okay now that we're done with my

00:02:06,060 --> 00:02:08,819
personal opinions or what it actually

00:02:08,190 --> 00:02:10,619
look like

00:02:08,819 --> 00:02:14,130
we ran the code by mentioned in that

00:02:10,619 --> 00:02:16,430
blog post from before so here is an

00:02:14,130 --> 00:02:16,430
action

00:02:19,910 --> 00:02:25,740
so if we take a look at each of the

00:02:23,610 --> 00:02:27,990
individual parts this is what the

00:02:25,740 --> 00:02:30,960
command I just ran look like J s code

00:02:27,990 --> 00:02:32,370
shift is a NPM package it's all globally

00:02:30,960 --> 00:02:34,380
all I could stuff we're gonna see later

00:02:32,370 --> 00:02:36,600
on in today's talk it's a tool that

00:02:34,380 --> 00:02:39,600
we'll use to actually run the code mods

00:02:36,600 --> 00:02:41,640
and here's a quickened before here's a

00:02:39,600 --> 00:02:43,520
quick before and after of what a react

00:02:41,640 --> 00:02:46,890
component might look like

00:02:43,520 --> 00:02:49,020
notice how react create class was

00:02:46,890 --> 00:02:50,940
changed to an es6 class this is what the

00:02:49,020 --> 00:02:52,410
code model ah does to do and we didn't

00:02:50,940 --> 00:02:54,030
have to write any code ourselves to make

00:02:52,410 --> 00:02:55,890
this change there are a few other

00:02:54,030 --> 00:02:59,580
changes too such as the property

00:02:55,890 --> 00:03:01,170
initializers that you might notice okay

00:02:59,580 --> 00:03:02,459
I'm sure some of you are not yet

00:03:01,170 --> 00:03:05,910
convinced that code mods are worth the

00:03:02,459 --> 00:03:08,010
hassle why bother with them you might be

00:03:05,910 --> 00:03:11,100
thinking hey I have regular expressions

00:03:08,010 --> 00:03:13,110
right you can make complex behind and

00:03:11,100 --> 00:03:16,890
replace changes with even more complex

00:03:13,110 --> 00:03:18,930
regular expressions but code mods allow

00:03:16,890 --> 00:03:20,880
for changes are actually infeasible with

00:03:18,930 --> 00:03:22,980
the regular expressions JavaScript the

00:03:20,880 --> 00:03:25,019
language itself is a first-class citizen

00:03:22,980 --> 00:03:26,340
when writing code mods regular

00:03:25,019 --> 00:03:27,959
expressions however it can only

00:03:26,340 --> 00:03:31,380
understand the text content of a piece

00:03:27,959 --> 00:03:33,450
of code for the more code mods actually

00:03:31,380 --> 00:03:35,880
unblock application while you're factors

00:03:33,450 --> 00:03:37,140
by making them easier to perform these

00:03:35,880 --> 00:03:39,120
changes might be required guys the

00:03:37,140 --> 00:03:41,430
library like to react as we celebrate it

00:03:39,120 --> 00:03:43,560
has updated its API we could also have

00:03:41,430 --> 00:03:44,910
updates to an internal API on our code

00:03:43,560 --> 00:03:47,130
base you might want to adopt a new

00:03:44,910 --> 00:03:48,630
pattern or a new standard these are

00:03:47,130 --> 00:03:52,739
changes we'd have to make manually if we

00:03:48,630 --> 00:03:54,900
didn't use code mots also the JavaScript

00:03:52,739 --> 00:03:56,910
ecosystem as a whole just evolves at a

00:03:54,900 --> 00:03:58,950
lightning pace with language and library

00:03:56,910 --> 00:04:00,720
updates your code base will have to

00:03:58,950 --> 00:04:02,280
evolve our time as well you might have

00:04:00,720 --> 00:04:04,709
files that haven't been touched in years

00:04:02,280 --> 00:04:06,720
and this usually results in tech debt

00:04:04,709 --> 00:04:08,549
but code mods helped us reduce that tech

00:04:06,720 --> 00:04:11,090
debt by performing programmatically

00:04:08,549 --> 00:04:14,340
factors to modernize our code bases

00:04:11,090 --> 00:04:15,750
lastly code mods when used properly will

00:04:14,340 --> 00:04:18,169
save significant amounts of Delaware

00:04:15,750 --> 00:04:20,910
office and refactoring application

00:04:18,169 --> 00:04:22,470
around the runway we've seen hundreds of

00:04:20,910 --> 00:04:24,590
developer hours by using code mods from

00:04:22,470 --> 00:04:26,970
on rice thousands of jobs files and

00:04:24,590 --> 00:04:28,449
that's great and all but honestly

00:04:26,970 --> 00:04:32,050
there's really fun to use

00:04:28,449 --> 00:04:33,279
well sue why don't we talk there's

00:04:32,050 --> 00:04:36,309
impossible reef actors are gonna perform

00:04:33,279 --> 00:04:37,749
on our code bases so let's go walk

00:04:36,309 --> 00:04:40,809
through some of them we can use code ma

00:04:37,749 --> 00:04:43,449
it's refactor older es5 syntax in CES

00:04:40,809 --> 00:04:46,659
2015 plus there are a bunch of ones out

00:04:43,449 --> 00:04:48,580
there there are ones for changing from

00:04:46,659 --> 00:04:50,800
required statements to import statements

00:04:48,580 --> 00:04:52,569
we're gonna take function expressions

00:04:50,800 --> 00:04:54,370
and transfer them into arrow functions

00:04:52,569 --> 00:04:57,069
we see that later on today and so much

00:04:54,370 --> 00:04:59,439
more as we saw previously their code

00:04:57,069 --> 00:05:00,879
mods to make upgrading react easier you

00:04:59,439 --> 00:05:03,729
can use them to refactor components to

00:05:00,879 --> 00:05:07,479
unblock upgrades as reacts API changes

00:05:03,729 --> 00:05:09,069
and evolves if you currently have prompt

00:05:07,479 --> 00:05:10,810
types there are actually code mods to

00:05:09,069 --> 00:05:12,939
convert them into da into type script

00:05:10,810 --> 00:05:14,529
types this is super exciting and should

00:05:12,939 --> 00:05:17,529
make adopting types work much much

00:05:14,529 --> 00:05:19,599
easier if you folks aren't that so

00:05:17,529 --> 00:05:21,879
hopefully by now you're all convinced

00:05:19,599 --> 00:05:24,099
that code mods are worthwhile so let's

00:05:21,879 --> 00:05:26,409
review how code not using Jesco should

00:05:24,099 --> 00:05:27,999
actually work internally and we'll see

00:05:26,409 --> 00:05:31,270
the concepts we'll need to implement our

00:05:27,999 --> 00:05:33,009
own code mots here's the github repo for

00:05:31,270 --> 00:05:36,009
Jess code shipped it was open source by

00:05:33,009 --> 00:05:38,139
Facebook will use J's code ship to run

00:05:36,009 --> 00:05:41,409
code mod scripts on our files all the

00:05:38,139 --> 00:05:44,289
tooling is already set up here's their

00:05:41,409 --> 00:05:46,029
official description from the readme I'm

00:05:44,289 --> 00:05:50,529
really glad that bill is passing it's a

00:05:46,029 --> 00:05:50,979
good time so this first part is the easy

00:05:50,529 --> 00:05:52,689
part

00:05:50,979 --> 00:05:54,219
Jesus code ship will run our

00:05:52,689 --> 00:05:56,469
transformation scripts against the files

00:05:54,219 --> 00:05:59,620
we want to refactor it'll also provide a

00:05:56,469 --> 00:06:01,360
nice summary in the end as well you saw

00:05:59,620 --> 00:06:03,339
this before so here's an example of

00:06:01,360 --> 00:06:05,529
using Jesus coaches along this summary

00:06:03,339 --> 00:06:08,050
of the output we're passing in the

00:06:05,529 --> 00:06:11,979
transform file class J s from the react

00:06:08,050 --> 00:06:13,360
code mods repo the input is this to do

00:06:11,979 --> 00:06:15,300
folder that I have it's in the same

00:06:13,360 --> 00:06:17,800
directory and all that good stuff

00:06:15,300 --> 00:06:19,479
GS coach it also has wonderful handy

00:06:17,800 --> 00:06:22,060
options for adjusting number of CPUs

00:06:19,479 --> 00:06:23,709
that the package uses performing dry

00:06:22,060 --> 00:06:25,659
runs without making any changes itself

00:06:23,709 --> 00:06:30,339
ignoring files and we'd also provide our

00:06:25,659 --> 00:06:32,289
own as we have here okay so we saw the

00:06:30,339 --> 00:06:34,360
first part that was fun the second part

00:06:32,289 --> 00:06:37,180
is also fun but a little bit more

00:06:34,360 --> 00:06:39,610
difficult this code ship uses the recast

00:06:37,180 --> 00:06:41,500
package internally as one of our methods

00:06:39,610 --> 00:06:42,040
recast has what provides a more

00:06:41,500 --> 00:06:47,790
convenient

00:06:42,040 --> 00:06:50,590
API for those methods so what's recast

00:06:47,790 --> 00:06:52,420
there's a github repo furry cows recast

00:06:50,590 --> 00:06:55,540
as a package we're gonna use to parse a

00:06:52,420 --> 00:06:57,340
piece of JavaScript code manipulated I

00:06:55,540 --> 00:06:59,470
hope that is I should transform the code

00:06:57,340 --> 00:07:01,930
itself and then finally return it back

00:06:59,470 --> 00:07:03,610
out it's great because if we use recast

00:07:01,930 --> 00:07:05,530
properly it'll actually maintain the

00:07:03,610 --> 00:07:08,920
same style as the original code before

00:07:05,530 --> 00:07:11,620
any of our automatic refactoring let's

00:07:08,920 --> 00:07:13,030
focus in on that parsing step recast

00:07:11,620 --> 00:07:15,490
supports different parsers like

00:07:13,030 --> 00:07:16,630
typescript flow and Babylon that's the

00:07:15,490 --> 00:07:18,520
parser behind Babel

00:07:16,630 --> 00:07:21,850
this means that J's code ship itself

00:07:18,520 --> 00:07:24,460
also supports these parsers that does

00:07:21,850 --> 00:07:29,320
raise a question of what exactly happens

00:07:24,460 --> 00:07:32,410
when recast parses our JavaScript Rica

00:07:29,320 --> 00:07:35,640
ATS recasts generates an abstract syntax

00:07:32,410 --> 00:07:37,540
tree or ast for sure from our JavaScript

00:07:35,640 --> 00:07:38,950
don't worry if that's how you feel right

00:07:37,540 --> 00:07:41,920
now let's actually take a look at

00:07:38,950 --> 00:07:43,900
extracting jacksters real quick an

00:07:41,920 --> 00:07:45,610
abstract syntax tree is a data structure

00:07:43,900 --> 00:07:47,470
which represents a piece of code

00:07:45,610 --> 00:07:49,930
includes all the relevant language

00:07:47,470 --> 00:07:52,270
constructs abstract syntax trees all

00:07:49,930 --> 00:07:54,280
widely used in compilers plenty of tools

00:07:52,270 --> 00:07:56,230
that we all use today today like web

00:07:54,280 --> 00:07:59,620
pack eeeh Slynt babel make use of

00:07:56,230 --> 00:08:01,000
abstract syntax trees so it's not quite

00:07:59,620 --> 00:08:03,720
like the hot tree right there but it's

00:08:01,000 --> 00:08:06,730
close let's talk about this tree aspect

00:08:03,720 --> 00:08:08,710
so trees are data structures that

00:08:06,730 --> 00:08:12,490
consists of nodes that are linked to one

00:08:08,710 --> 00:08:14,620
another here's an example of a trick at

00:08:12,490 --> 00:08:17,590
the top we have node 1 which is our root

00:08:14,620 --> 00:08:20,530
node we can also see that node 1 is the

00:08:17,590 --> 00:08:22,870
parent node of node 2 and 3 also notice

00:08:20,530 --> 00:08:24,700
how node 2 also has two children as well

00:08:22,870 --> 00:08:26,230
if you're not familiar with the tree

00:08:24,700 --> 00:08:28,290
data structure I highly encourage your

00:08:26,230 --> 00:08:31,200
digging them or they're pretty neat

00:08:28,290 --> 00:08:34,060
going back to our abstract syntax trees

00:08:31,200 --> 00:08:36,040
the nodes in the abstract syntax tree

00:08:34,060 --> 00:08:39,400
describe the structure of our programs

00:08:36,040 --> 00:08:41,530
so let's take a look at a node here's an

00:08:39,400 --> 00:08:44,320
example of the ast node for this string

00:08:41,530 --> 00:08:46,330
hello world with Gia Scotia the nodes

00:08:44,320 --> 00:08:48,130
are plain Java sort objects there's no

00:08:46,330 --> 00:08:50,590
magic going on here we're gonna identify

00:08:48,130 --> 00:08:53,820
nodes by their type we take a look here

00:08:50,590 --> 00:08:56,620
this note it has the type literal

00:08:53,820 --> 00:08:59,800
for a more complex example let's take a

00:08:56,620 --> 00:09:01,360
look at this function declaration we can

00:08:59,800 --> 00:09:01,930
see that that type is function

00:09:01,360 --> 00:09:04,180
declaration

00:09:01,930 --> 00:09:07,450
spoiler alert and we even have access to

00:09:04,180 --> 00:09:09,700
its name and it's so much more what's

00:09:07,450 --> 00:09:11,320
great is that we can use this tool asu

00:09:09,700 --> 00:09:13,360
explorer to actually inspect the

00:09:11,320 --> 00:09:15,790
abstract syntax tree for a piece of code

00:09:13,360 --> 00:09:18,190
we just plop it in there and see the

00:09:15,790 --> 00:09:20,230
actual tree itself we need to manipulate

00:09:18,190 --> 00:09:21,820
the ast in our code not so this will be

00:09:20,230 --> 00:09:23,590
extremely helpful figuring out the

00:09:21,820 --> 00:09:28,840
structure of our current code as well as

00:09:23,590 --> 00:09:31,090
what types we want in the end so cuz

00:09:28,840 --> 00:09:33,010
even for it we can go in further recasts

00:09:31,090 --> 00:09:35,470
uses this ast ties package entirely

00:09:33,010 --> 00:09:37,510
which actually wraps the nodes in our

00:09:35,470 --> 00:09:40,090
abstract syntax tree into these half

00:09:37,510 --> 00:09:42,280
objects pathologists are great because

00:09:40,090 --> 00:09:45,970
they let us do tree traversal iteration

00:09:42,280 --> 00:09:47,830
node modification so much more and the

00:09:45,970 --> 00:09:50,290
package itself also includes builder

00:09:47,830 --> 00:09:53,260
methods that are also exposed NGS code

00:09:50,290 --> 00:09:54,580
ship for creating nodes in our ast so

00:09:53,260 --> 00:09:57,480
let's take a look out with this just for

00:09:54,580 --> 00:10:00,760
us so we have our tree from before

00:09:57,480 --> 00:10:03,540
because of the ast ties package we can

00:10:00,760 --> 00:10:06,730
traverse our tree from node four to two

00:10:03,540 --> 00:10:08,170
we can also modify notes let's say we're

00:10:06,730 --> 00:10:11,730
done with no two want to make it better

00:10:08,170 --> 00:10:14,290
we can change that into node six and

00:10:11,730 --> 00:10:16,750
going even further we can actually start

00:10:14,290 --> 00:10:21,700
to add new notes here we're gonna add a

00:10:16,750 --> 00:10:24,280
child node to node 3 so we start to

00:10:21,700 --> 00:10:26,860
combine these concepts together you can

00:10:24,280 --> 00:10:31,690
begin to actually write code mods so

00:10:26,860 --> 00:10:34,990
let's dive into that portion here's a

00:10:31,690 --> 00:10:37,210
general overview process first we'll

00:10:34,990 --> 00:10:39,190
need to parse or sort our source code to

00:10:37,210 --> 00:10:42,700
actually generate the abstract syntax

00:10:39,190 --> 00:10:45,460
tree after that we've to modify the

00:10:42,700 --> 00:10:47,680
abscess abstract syntax tree as required

00:10:45,460 --> 00:10:49,150
for are we factoring goals this means

00:10:47,680 --> 00:10:51,250
we'll probably have to traverse the tree

00:10:49,150 --> 00:10:53,410
with to figure out with which nodes we

00:10:51,250 --> 00:10:55,530
care about access them and then we have

00:10:53,410 --> 00:10:59,050
to update those nodes as well and

00:10:55,530 --> 00:11:00,790
finally using our modified abstract

00:10:59,050 --> 00:11:02,320
syntax tree we actually regenerate our

00:11:00,790 --> 00:11:05,640
source code and our files have been

00:11:02,320 --> 00:11:08,760
modified our refactoring is done

00:11:05,640 --> 00:11:10,350
so we can perform this process in a

00:11:08,760 --> 00:11:13,170
transformation file it's just like any

00:11:10,350 --> 00:11:15,560
other Java file and we'll pass this

00:11:13,170 --> 00:11:18,360
transformation file to J's code shipped

00:11:15,560 --> 00:11:20,579
the transformation file itself is just a

00:11:18,360 --> 00:11:22,560
Java sir module and it exports a

00:11:20,579 --> 00:11:24,630
function that returns our modified

00:11:22,560 --> 00:11:26,310
source code so we have to do those

00:11:24,630 --> 00:11:28,800
through substring for the parse our

00:11:26,310 --> 00:11:30,870
source code in this file we're going to

00:11:28,800 --> 00:11:32,399
update our source code as required and

00:11:30,870 --> 00:11:35,910
then we'll return our updated source

00:11:32,399 --> 00:11:37,410
code so it's a good step by step if we

00:11:35,910 --> 00:11:40,890
take a look at the parameters of this

00:11:37,410 --> 00:11:45,120
function we have 3 up there first

00:11:40,890 --> 00:11:47,190
parameter file gives us access to the

00:11:45,120 --> 00:11:48,990
files path and the source view the first

00:11:47,190 --> 00:11:52,140
argument this is the file that we want

00:11:48,990 --> 00:11:55,829
to refactor programmatically second

00:11:52,140 --> 00:11:59,430
argument has methods that actually alias

00:11:55,829 --> 00:12:01,950
two Gs co-chef along with action and

00:11:59,430 --> 00:12:04,500
they also allows us to collect

00:12:01,950 --> 00:12:08,130
statistics and generate reports all that

00:12:04,500 --> 00:12:10,199
good stuff the last argument is an

00:12:08,130 --> 00:12:11,940
object that contains all the options we

00:12:10,199 --> 00:12:13,740
actually passed to the GS coach of

00:12:11,940 --> 00:12:15,630
command so this includes any

00:12:13,740 --> 00:12:21,570
user-defined ones which means our code

00:12:15,630 --> 00:12:23,040
mods can be extremely flexible so if we

00:12:21,570 --> 00:12:27,420
take a look at the basic setup for our

00:12:23,040 --> 00:12:29,339
function usually have the GS code shift

00:12:27,420 --> 00:12:31,079
library itself alias as J it's a very

00:12:29,339 --> 00:12:35,760
convenient variable its lies in typing

00:12:31,079 --> 00:12:38,459
everything out and then we can use J s

00:12:35,760 --> 00:12:40,140
code shift with that J alias to actually

00:12:38,459 --> 00:12:43,260
parse or source code of the provided

00:12:40,140 --> 00:12:44,730
file just comfortable handle passing at

00:12:43,260 --> 00:12:47,160
each file one after another we have to

00:12:44,730 --> 00:12:48,899
worry about that aspect and here we're

00:12:47,160 --> 00:12:52,290
gonna return the root node from our

00:12:48,899 --> 00:12:53,940
abstract syntax tree usually folks like

00:12:52,290 --> 00:12:54,930
to chain these methods together we'll

00:12:53,940 --> 00:12:56,310
talk more about that in a second I

00:12:54,930 --> 00:12:58,529
separate them out just so that we can

00:12:56,310 --> 00:13:00,420
see them easily after that we have to

00:12:58,529 --> 00:13:02,130
modify the abstract syntax tree a little

00:13:00,420 --> 00:13:05,699
bit more involved and in the end we can

00:13:02,130 --> 00:13:09,930
generate this the source code by calling

00:13:05,699 --> 00:13:11,970
the to source method so here's where

00:13:09,930 --> 00:13:13,770
things get interesting at the very

00:13:11,970 --> 00:13:16,020
bottom we're returning some value right

00:13:13,770 --> 00:13:17,110
it's just a string and if a string is

00:13:16,020 --> 00:13:18,610
returned and its

00:13:17,110 --> 00:13:20,680
different from the original source file

00:13:18,610 --> 00:13:23,320
and the transformation was successful go

00:13:20,680 --> 00:13:25,600
us if the string is the string is

00:13:23,320 --> 00:13:27,970
returned but it's the same then it was

00:13:25,600 --> 00:13:30,760
unsuccessful something went wrong in our

00:13:27,970 --> 00:13:32,950
transformation and if nothing is

00:13:30,760 --> 00:13:34,480
returned at all and that is okay that

00:13:32,950 --> 00:13:35,860
just means that that file wasn't

00:13:34,480 --> 00:13:39,070
supposed to be transferred we're still

00:13:35,860 --> 00:13:41,950
good to go so let's talk about this root

00:13:39,070 --> 00:13:44,740
node real quick that root node variable

00:13:41,950 --> 00:13:46,870
it's an example of a collection in je s

00:13:44,740 --> 00:13:49,870
code shipped these collections coz

00:13:46,870 --> 00:13:51,550
consists of recasts path objects so that

00:13:49,870 --> 00:13:54,220
path objects that we have from recast

00:13:51,550 --> 00:13:55,930
they need grouper bunch of them together

00:13:54,220 --> 00:13:58,150
and then we have this collection in

00:13:55,930 --> 00:13:59,980
Jesco shift and those path objects

00:13:58,150 --> 00:14:03,790
they're just the nodes in our abstract

00:13:59,980 --> 00:14:05,920
syntax tree these collections are pretty

00:14:03,790 --> 00:14:07,660
great Jesco chips collections add

00:14:05,920 --> 00:14:09,460
methods exposure finding traversing and

00:14:07,660 --> 00:14:12,760
updating those notes but the API is

00:14:09,460 --> 00:14:14,410
extremely convenient and it's convenient

00:14:12,760 --> 00:14:16,540
because these methods tend to return

00:14:14,410 --> 00:14:18,400
collections it's a lot like how we would

00:14:16,540 --> 00:14:20,470
write jQuery back in the day when we

00:14:18,400 --> 00:14:22,120
used jQuery we usually have a collection

00:14:20,470 --> 00:14:23,920
of Dom notes at a return and we sort of

00:14:22,120 --> 00:14:27,550
chain methods it's the same principle

00:14:23,920 --> 00:14:29,530
here so Jia's coach if actually

00:14:27,550 --> 00:14:31,930
influenced a fluent interface and relies

00:14:29,530 --> 00:14:33,340
heavily on method chaining we have this

00:14:31,930 --> 00:14:35,410
collection you can start to call methods

00:14:33,340 --> 00:14:37,410
upon methods on that collection until

00:14:35,410 --> 00:14:41,200
we're done we're gonna return the source

00:14:37,410 --> 00:14:43,300
so you can actually write these

00:14:41,200 --> 00:14:45,460
transformations in the ASE Explorer tool

00:14:43,300 --> 00:14:46,660
itself it is extremely convenient if

00:14:45,460 --> 00:14:49,180
you're writing your own code mods i

00:14:46,660 --> 00:14:51,640
highly recommend starting here all you

00:14:49,180 --> 00:14:53,590
have to do is specify that you want to

00:14:51,640 --> 00:14:57,640
enable the transform option then choose

00:14:53,590 --> 00:14:59,890
J's code shift as the option there we

00:14:57,640 --> 00:15:02,140
can see the transformation here and what

00:14:59,890 --> 00:15:04,660
the output is this one is a little bit

00:15:02,140 --> 00:15:06,850
silly because all it does is reverse the

00:15:04,660 --> 00:15:10,270
characters so maybe not the best code

00:15:06,850 --> 00:15:13,750
mod out there what's cool so let's take

00:15:10,270 --> 00:15:16,120
a look a more realistic example let's

00:15:13,750 --> 00:15:18,340
write a codemod together to transform

00:15:16,120 --> 00:15:20,530
function expressions into our functions

00:15:18,340 --> 00:15:25,330
our functions are very hip so let's go

00:15:20,530 --> 00:15:27,040
with that so it lets define what our use

00:15:25,330 --> 00:15:29,050
cases are first place thing we want to

00:15:27,040 --> 00:15:30,010
start is determining what we want to

00:15:29,050 --> 00:15:34,090
support

00:15:30,010 --> 00:15:36,520
our transformation so at the very top we

00:15:34,090 --> 00:15:38,050
have function one it's like any other

00:15:36,520 --> 00:15:40,180
function expression it just returns the

00:15:38,050 --> 00:15:43,210
sum of those two parameters

00:15:40,180 --> 00:15:44,800
looks pretty benign benign and we should

00:15:43,210 --> 00:15:46,900
be able to transform more easily into

00:15:44,800 --> 00:15:49,750
this error function right here notice

00:15:46,900 --> 00:15:51,820
that it is super fancy right there are

00:15:49,750 --> 00:15:52,900
no curly braces it's super clean so we

00:15:51,820 --> 00:15:55,300
have to handle that in our

00:15:52,900 --> 00:15:59,290
transformation somehow we'll see that

00:15:55,300 --> 00:16:01,300
later on for function two we want to add

00:15:59,290 --> 00:16:03,910
in an additional case right for function

00:16:01,300 --> 00:16:05,170
one there's nothing else in the body of

00:16:03,910 --> 00:16:07,390
our function we'll make sure that if

00:16:05,170 --> 00:16:09,010
there are any variable declarations or

00:16:07,390 --> 00:16:10,330
any other work that's happening the body

00:16:09,010 --> 00:16:12,430
of our function that we support that as

00:16:10,330 --> 00:16:14,410
well it's good to build out these test

00:16:12,430 --> 00:16:17,800
cases it's almost like writing unit

00:16:14,410 --> 00:16:19,060
tests so here we'll have a number three

00:16:17,800 --> 00:16:20,680
in there we're set to zero it's not

00:16:19,060 --> 00:16:22,390
gonna do much for us but we'll make sure

00:16:20,680 --> 00:16:26,260
that that is preserved after we

00:16:22,390 --> 00:16:28,660
transform it into a error function the

00:16:26,260 --> 00:16:31,870
last one function three is a case that

00:16:28,660 --> 00:16:33,370
should not be transformed so if we take

00:16:31,870 --> 00:16:36,340
a look at it we're using the this

00:16:33,370 --> 00:16:38,140
keyword inside of that function and the

00:16:36,340 --> 00:16:40,060
this keyword is handled differently with

00:16:38,140 --> 00:16:41,980
our functions when we show that we don't

00:16:40,060 --> 00:16:44,110
change the actual functionality in our

00:16:41,980 --> 00:16:45,940
code so we don't want to automatically

00:16:44,110 --> 00:16:47,170
transform that function into an our

00:16:45,940 --> 00:16:48,160
function because the value that this

00:16:47,170 --> 00:16:49,690
cube could change

00:16:48,160 --> 00:16:52,270
we need to a different value than the

00:16:49,690 --> 00:16:54,070
original function expression so we just

00:16:52,270 --> 00:16:56,590
want to avoid functions like function

00:16:54,070 --> 00:16:58,390
three we're to actually write logic in

00:16:56,590 --> 00:17:02,080
our transformation to make sure that we

00:16:58,390 --> 00:17:02,770
avoid those kinds of functions all right

00:17:02,080 --> 00:17:07,270
let's do it

00:17:02,770 --> 00:17:09,670
so first thing we need to do is actually

00:17:07,270 --> 00:17:13,720
grab all the function expressions in our

00:17:09,670 --> 00:17:15,730
file so we're going to find all the

00:17:13,720 --> 00:17:17,890
function expressions find is a method

00:17:15,730 --> 00:17:20,890
that's exposed by J's code shift on

00:17:17,890 --> 00:17:23,680
collections and we can figure out the

00:17:20,890 --> 00:17:26,020
name of that type by using the ASU

00:17:23,680 --> 00:17:27,970
Explorer tool from before so we're gonna

00:17:26,020 --> 00:17:30,010
find all the matching notes that are

00:17:27,970 --> 00:17:31,960
function expressions and we'll access

00:17:30,010 --> 00:17:33,670
them through this I find expressions or

00:17:31,960 --> 00:17:38,200
function expressions very well here it's

00:17:33,670 --> 00:17:40,780
a collection of path objects and once we

00:17:38,200 --> 00:17:43,190
have that collection we're in sort a or

00:17:40,780 --> 00:17:46,310
you can start to actually provide

00:17:43,190 --> 00:17:48,230
Haagen it sir one thing that I want to

00:17:46,310 --> 00:17:50,180
do is we want to avoid the this keyword

00:17:48,230 --> 00:17:52,160
we saw that before it's a lot of trouble

00:17:50,180 --> 00:17:53,420
we're just gonna avoid those cases we

00:17:52,160 --> 00:17:55,700
don't want to accidentally break any of

00:17:53,420 --> 00:17:58,640
our other code so we write some code to

00:17:55,700 --> 00:18:00,710
filter out of this keyword so here we

00:17:58,640 --> 00:18:03,050
have a filter method that's exposed by

00:18:00,710 --> 00:18:05,000
JS code shipped on our collection we're

00:18:03,050 --> 00:18:06,740
gonna pass in this callback action let's

00:18:05,000 --> 00:18:08,630
call a pushin it's not too bad what it's

00:18:06,740 --> 00:18:10,340
doing is it's searching for each of the

00:18:08,630 --> 00:18:12,560
individual function expressions and it's

00:18:10,340 --> 00:18:14,390
making sure that this this expression

00:18:12,560 --> 00:18:17,660
isn't there we want to avoid this

00:18:14,390 --> 00:18:19,400
keyword in our transformations so when

00:18:17,660 --> 00:18:23,510
you exclude any functions that have this

00:18:19,400 --> 00:18:28,460
keyword size and related methods are

00:18:23,510 --> 00:18:30,890
just exposed by J's code shift okay so

00:18:28,460 --> 00:18:34,180
this last portion is a little bit hairy

00:18:30,890 --> 00:18:36,470
but let's talk through it so essentially

00:18:34,180 --> 00:18:40,310
FN expressions know this right this

00:18:36,470 --> 00:18:41,600
collection right here it has all of the

00:18:40,310 --> 00:18:45,950
function expressions we want to change

00:18:41,600 --> 00:18:48,530
in that file and now we actually make

00:18:45,950 --> 00:18:51,290
the changes so we're using the replace

00:18:48,530 --> 00:18:53,540
with method that's exposed by a J's code

00:18:51,290 --> 00:18:55,010
shift and what we're doing is we're

00:18:53,540 --> 00:18:56,960
going through all the function

00:18:55,010 --> 00:18:59,090
expressions in that collection we're

00:18:56,960 --> 00:19:00,770
going to the one by one or each of them

00:18:59,090 --> 00:19:03,970
were crabbing the body content or

00:19:00,770 --> 00:19:06,500
grabbing any parameters we need and

00:19:03,970 --> 00:19:08,960
we're going to do something a little bit

00:19:06,500 --> 00:19:11,480
interesting we're gonna check to see we

00:19:08,960 --> 00:19:13,490
have to transform those into one line or

00:19:11,480 --> 00:19:15,590
arrow functions it was very clean very

00:19:13,490 --> 00:19:17,000
pretty one line or arrow functions so

00:19:15,590 --> 00:19:18,650
we're in do some work in here to double

00:19:17,000 --> 00:19:21,290
check that we actually make those

00:19:18,650 --> 00:19:23,060
changes all these values are from the

00:19:21,290 --> 00:19:25,250
ASU Explorer you know to memorize them

00:19:23,060 --> 00:19:27,980
or show them offhand nobody is born

00:19:25,250 --> 00:19:29,750
knowing those values so you use that

00:19:27,980 --> 00:19:32,180
tool Tory out what you care about and

00:19:29,750 --> 00:19:34,940
once we verified that this one-liner is

00:19:32,180 --> 00:19:36,470
safe you make any changes required so

00:19:34,940 --> 00:19:38,810
one thing that we have to do with these

00:19:36,470 --> 00:19:40,160
one-liners is verify that rather when we

00:19:38,810 --> 00:19:42,680
make these one-liners we have to get rid

00:19:40,160 --> 00:19:43,960
of return keyword and use the first

00:19:42,680 --> 00:19:47,300
arguments Det

00:19:43,960 --> 00:19:49,280
so at the very end once we've done all

00:19:47,300 --> 00:19:50,630
that work right we've changed our

00:19:49,280 --> 00:19:52,820
function expressions into arrow

00:19:50,630 --> 00:19:55,070
functions we have to regenerate our

00:19:52,820 --> 00:19:57,110
source code and return it back out so in

00:19:55,070 --> 00:19:58,910
the end we get back a nice string s code

00:19:57,110 --> 00:20:00,730
Jeff handles updating our original files

00:19:58,910 --> 00:20:05,780
and we're good to go

00:20:00,730 --> 00:20:06,920
so we're just sawing this example of how

00:20:05,780 --> 00:20:09,170
to write a codemod

00:20:06,920 --> 00:20:10,580
but let's talk through since hipsterish

00:20:09,170 --> 00:20:13,220
we were working with code mods and your

00:20:10,580 --> 00:20:15,440
actual code bases that was a very small

00:20:13,220 --> 00:20:17,059
example but we all probably have

00:20:15,440 --> 00:20:18,710
hundreds or thousands of jobs files

00:20:17,059 --> 00:20:20,299
we've developed a so let's go through

00:20:18,710 --> 00:20:23,120
some tips to handle those cases I

00:20:20,299 --> 00:20:25,730
learned most of these tips the hard way

00:20:23,120 --> 00:20:29,360
so you folks can benefit from my past

00:20:25,730 --> 00:20:31,820
frustrations and mistakes so first thing

00:20:29,360 --> 00:20:33,950
is I highly recommend having a safety

00:20:31,820 --> 00:20:36,470
net in place before even attempting to

00:20:33,950 --> 00:20:38,270
use code mods or enthrone Rent the

00:20:36,470 --> 00:20:40,730
Runway we've only used code mods in the

00:20:38,270 --> 00:20:42,919
applications that had extensive unit and

00:20:40,730 --> 00:20:45,410
integration testing anything that didn't

00:20:42,919 --> 00:20:47,360
have that was not applicable we don't

00:20:45,410 --> 00:20:49,100
treat pull requests with code mods and

00:20:47,360 --> 00:20:51,290
you differ from regular changes meaning

00:20:49,100 --> 00:20:52,490
we still do things like the usual code

00:20:51,290 --> 00:20:54,860
view process and things of that nature

00:20:52,490 --> 00:20:59,000
we shouldn't treat code not changes any

00:20:54,860 --> 00:21:01,700
different than regular changes the other

00:20:59,000 --> 00:21:05,059
thing I recommend is when merging in any

00:21:01,700 --> 00:21:06,590
code mod modified files don't make any

00:21:05,059 --> 00:21:08,960
other changes in that branch don't

00:21:06,590 --> 00:21:10,429
change anything yourself so don't rename

00:21:08,960 --> 00:21:13,090
in it and identify or don't adjust

00:21:10,429 --> 00:21:16,280
whitespace just do not do anything else

00:21:13,090 --> 00:21:18,169
so modifying the code manually actually

00:21:16,280 --> 00:21:20,900
makes it harder to undo and redo any

00:21:18,169 --> 00:21:23,179
transformations if you absolutely need

00:21:20,900 --> 00:21:24,590
to make manual changes in that file then

00:21:23,179 --> 00:21:27,410
you should explicitly point them out in

00:21:24,590 --> 00:21:29,120
your portal quests but otherwise I would

00:21:27,410 --> 00:21:31,400
say avoid making any changes yourself

00:21:29,120 --> 00:21:35,830
but the code mod do that work for that

00:21:31,400 --> 00:21:38,000
pull request the last part if possible

00:21:35,830 --> 00:21:39,740
split up these large code boundary

00:21:38,000 --> 00:21:41,570
factors into multiple smaller pull

00:21:39,740 --> 00:21:44,540
requests it'll make it much easier to

00:21:41,570 --> 00:21:45,890
diagnose any bugs after a deploy and if

00:21:44,540 --> 00:21:47,660
it's possible I would even just deploy

00:21:45,890 --> 00:21:49,520
these all separately so this way you can

00:21:47,660 --> 00:21:54,200
roll back very easily if there is a bug

00:21:49,520 --> 00:21:56,570
in your code much change and as you'll

00:21:54,200 --> 00:21:58,580
long write documentation this could be

00:21:56,570 --> 00:22:01,460
internal documentation for any code mods

00:21:58,580 --> 00:22:02,540
they use even if it's from Facebook or

00:22:01,460 --> 00:22:04,549
some other company just write

00:22:02,540 --> 00:22:07,280
documentation yourself in your company

00:22:04,549 --> 00:22:09,740
because eventually somebody will get

00:22:07,280 --> 00:22:11,720
blame that automatically refactor code

00:22:09,740 --> 00:22:13,640
and if they see an empty poor class

00:22:11,720 --> 00:22:15,830
description for a thousand line change

00:22:13,640 --> 00:22:17,420
that is not a good thing so try to read

00:22:15,830 --> 00:22:18,740
documentation I recommend putting links

00:22:17,420 --> 00:22:21,559
to documentation in your pull request

00:22:18,740 --> 00:22:22,850
descriptions and if it's an extra mod

00:22:21,559 --> 00:22:25,730
make sure you refer to the version

00:22:22,850 --> 00:22:27,260
itself in the flow requests the version

00:22:25,730 --> 00:22:28,640
might update the actual code mod itself

00:22:27,260 --> 00:22:30,650
might update so make sure that you can

00:22:28,640 --> 00:22:32,240
refer to a specific version somebody

00:22:30,650 --> 00:22:34,160
else has to refer your code they should

00:22:32,240 --> 00:22:38,300
have enough information to reapply that

00:22:34,160 --> 00:22:40,130
transformation later on also I highly

00:22:38,300 --> 00:22:43,010
recommend treating any code mods marina

00:22:40,130 --> 00:22:44,450
internally as actual code you want them

00:22:43,010 --> 00:22:46,190
in a repository of their own and you

00:22:44,450 --> 00:22:47,660
should version them as well this will

00:22:46,190 --> 00:22:49,700
make it much easier if any of your code

00:22:47,660 --> 00:22:51,950
much changes are reverted you could do

00:22:49,700 --> 00:22:53,420
apply those transformations again also

00:22:51,950 --> 00:22:55,250
it helps if there are new bugs and your

00:22:53,420 --> 00:22:57,170
personal code mod scripts is that way

00:22:55,250 --> 00:22:58,190
you can remove those versions or just

00:22:57,170 --> 00:23:02,780
highlight to people that they should not

00:22:58,190 --> 00:23:04,850
use those versions when writing your own

00:23:02,780 --> 00:23:07,670
code mods don't try to worry about

00:23:04,850 --> 00:23:09,230
handling every single case if there's

00:23:07,670 --> 00:23:10,760
hard to reason about edge cases just

00:23:09,230 --> 00:23:12,590
exclude them from your transformation

00:23:10,760 --> 00:23:14,780
script you don't have to modify every

00:23:12,590 --> 00:23:16,700
single file in one go you can have to

00:23:14,780 --> 00:23:19,070
update those files manually later on in

00:23:16,700 --> 00:23:21,080
separate pull requests and it's ah it's

00:23:19,070 --> 00:23:22,910
ok you know you can't handle every

00:23:21,080 --> 00:23:24,530
single case and one go you'll notice

00:23:22,910 --> 00:23:28,040
that a lot of the code mods are released

00:23:24,530 --> 00:23:29,510
and on are on github state which cases

00:23:28,040 --> 00:23:31,790
they don't handle we saw the same thing

00:23:29,510 --> 00:23:33,440
for the our function code my code mod

00:23:31,790 --> 00:23:35,360
that we just wrote there's definitely a

00:23:33,440 --> 00:23:37,520
time trade-off so you see yourself

00:23:35,360 --> 00:23:41,540
spending too much time writing a code

00:23:37,520 --> 00:23:43,370
mod just do the changes manually that's

00:23:41,540 --> 00:23:44,870
all that said thank you folks so much I

00:23:43,370 --> 00:23:46,900
hope you all have fun using code mods

00:23:44,870 --> 00:23:55,570
next week at work

00:23:46,900 --> 00:24:00,900
or right now okay so we have a question

00:23:55,570 --> 00:24:05,880
came in from Fred so how do you manage

00:24:00,900 --> 00:24:08,380
CSS and non JavaScript resources oh

00:24:05,880 --> 00:24:10,510
great so the question was when using

00:24:08,380 --> 00:24:12,160
code mods how do you manage CSS and non

00:24:10,510 --> 00:24:14,590
JavaScript resources mhm

00:24:12,160 --> 00:24:17,500
so the GS coach of package itself will

00:24:14,590 --> 00:24:19,480
filter down to Java search files

00:24:17,500 --> 00:24:21,700
you actually pass initial parameters by

00:24:19,480 --> 00:24:23,679
which files you want to consider which

00:24:21,700 --> 00:24:25,420
files you want to ignore and one thing

00:24:23,679 --> 00:24:27,640
that I've done before is actually I've

00:24:25,420 --> 00:24:29,080
written bash scripts also use Java suit

00:24:27,640 --> 00:24:31,980
but you didn't write a script to wrap

00:24:29,080 --> 00:24:38,170
your just code shift execution as well

00:24:31,980 --> 00:24:40,420
okay gotcha that was not the question I

00:24:38,170 --> 00:24:42,190
supposed to ask another question someone

00:24:40,420 --> 00:24:45,990
someone sent in a question for another

00:24:42,190 --> 00:24:45,990
for another talk is coming in the future

00:24:48,929 --> 00:24:56,410
okay so um so I actually kind of want

00:24:54,730 --> 00:24:58,720
your take on something so you probably

00:24:56,410 --> 00:25:01,210
as we've all seen a lot of these talks

00:24:58,720 --> 00:25:03,970
and since this morning have been about

00:25:01,210 --> 00:25:05,770
taking preventative measures and now

00:25:03,970 --> 00:25:07,870
like we're talking about refactoring and

00:25:05,770 --> 00:25:10,210
you know thinking about like just the

00:25:07,870 --> 00:25:11,590
long-term effects of our software and

00:25:10,210 --> 00:25:13,750
like how far it will go in the future

00:25:11,590 --> 00:25:14,980
and like whenever you know we go on from

00:25:13,750 --> 00:25:16,960
somewhere else and someone comes on

00:25:14,980 --> 00:25:22,780
takes on over our project like you know

00:25:16,960 --> 00:25:24,790
how they're able to like get get a so

00:25:22,780 --> 00:25:27,340
kind of do you have any like kind of

00:25:24,790 --> 00:25:29,350
thoughts so ends on just like long-term

00:25:27,340 --> 00:25:31,450
maintenance and just like really just

00:25:29,350 --> 00:25:34,179
giving given your codebase to love it

00:25:31,450 --> 00:25:37,870
needs that is a great question

00:25:34,179 --> 00:25:40,030
long-term maintenance is very hard so I

00:25:37,870 --> 00:25:42,309
started out run the runway as like the

00:25:40,030 --> 00:25:44,200
lowest level on the totem pole and over

00:25:42,309 --> 00:25:46,660
the years somehow I became the service

00:25:44,200 --> 00:25:49,300
owner for our website and there's a lot

00:25:46,660 --> 00:25:50,620
of code that I did not write and now the

00:25:49,300 --> 00:25:53,200
employees that work there right now

00:25:50,620 --> 00:25:55,510
wrote and I think one thing I would say

00:25:53,200 --> 00:25:57,610
is if you can document anything that is

00:25:55,510 --> 00:25:59,650
weird just please do it like write a

00:25:57,610 --> 00:26:00,050
single line comment you don't have to

00:25:59,650 --> 00:26:01,730
make

00:26:00,050 --> 00:26:04,010
fancy just this thing is weird don't

00:26:01,730 --> 00:26:06,770
change it don't look at it just move on

00:26:04,010 --> 00:26:08,630
to the next file but otherwise I would

00:26:06,770 --> 00:26:11,930
say try to write your code assuming that

00:26:08,630 --> 00:26:14,810
someday it will be deleted we saw with

00:26:11,930 --> 00:26:16,130
Dario's talk that you can write wrappers

00:26:14,810 --> 00:26:17,600
we can make it easier for people to

00:26:16,130 --> 00:26:21,950
remove stuff in the future and that's

00:26:17,600 --> 00:26:24,080
awesome mm-hmm okay so what are some of

00:26:21,950 --> 00:26:28,060
the most ambitious code mods you've seen

00:26:24,080 --> 00:26:30,530
in the wild that is a good question so

00:26:28,060 --> 00:26:33,530
honestly I thought that react like

00:26:30,530 --> 00:26:36,290
change from create class to like exs

00:26:33,530 --> 00:26:38,060
classes is insane if you folks have time

00:26:36,290 --> 00:26:39,920
I know later tonight sometime the future

00:26:38,060 --> 00:26:43,160
just read through that code not file

00:26:39,920 --> 00:26:45,470
because it is insane and it handles so

00:26:43,160 --> 00:26:48,320
many special cases I just read there I

00:26:45,470 --> 00:26:49,430
was like wow like I don't know how

00:26:48,320 --> 00:26:52,880
somebody like I don't know how these

00:26:49,430 --> 00:26:55,730
girls like to handle all those cases so

00:26:52,880 --> 00:26:58,670
one thing that we the second time that

00:26:55,730 --> 00:27:00,740
the topic of AST s have come as tracks

00:26:58,670 --> 00:27:02,930
and tech streams has come up do you

00:27:00,740 --> 00:27:05,150
think that in like you you know as your

00:27:02,930 --> 00:27:07,160
career or liking your time as the you

00:27:05,150 --> 00:27:08,600
know developer adoptive developer do you

00:27:07,160 --> 00:27:10,340
think that like it's something that you

00:27:08,600 --> 00:27:13,180
just cannot avoid something you will

00:27:10,340 --> 00:27:16,340
come across at some point in your career

00:27:13,180 --> 00:27:18,590
nice yeah so I think it's it's

00:27:16,340 --> 00:27:21,770
interesting because like the tooling has

00:27:18,590 --> 00:27:25,460
changed so much over the last four or

00:27:21,770 --> 00:27:26,900
five years and somebody tweeted this out

00:27:25,460 --> 00:27:29,300
and I don't know the name but he's like

00:27:26,900 --> 00:27:30,950
a famous JavaScript person and it was

00:27:29,300 --> 00:27:33,080
like eventually like will all become

00:27:30,950 --> 00:27:34,760
compiler engineers and I saw that tweet

00:27:33,080 --> 00:27:36,680
and it like shook me like a few years

00:27:34,760 --> 00:27:38,570
ago that's when I started investing the

00:27:36,680 --> 00:27:40,160
time and this is like what I don't want

00:27:38,570 --> 00:27:42,710
to this I like want to make buttons

00:27:40,160 --> 00:27:44,930
clickable and stuff but honestly it's

00:27:42,710 --> 00:27:46,850
super cool and it is super approachable

00:27:44,930 --> 00:27:49,280
with all of the great resources we have

00:27:46,850 --> 00:27:51,020
now like even things like abstract

00:27:49,280 --> 00:27:52,580
syntax trees they're not Jawas who climb

00:27:51,020 --> 00:27:54,590
so right there a computer science

00:27:52,580 --> 00:27:57,500
concept and there's some resources like

00:27:54,590 --> 00:28:01,160
Khan Academy and Coursera and all that

00:27:57,500 --> 00:28:03,230
mm-hmm okay so one more question here is

00:28:01,160 --> 00:28:08,390
there a particularly good place to find

00:28:03,230 --> 00:28:10,240
pre-existing code mods nice so there is

00:28:08,390 --> 00:28:12,980
this awesome

00:28:10,240 --> 00:28:13,320
code mods repo on github so I would

00:28:12,980 --> 00:28:15,810
start

00:28:13,320 --> 00:28:19,680
there and honestly like the strategy

00:28:15,810 --> 00:28:21,540
I've taken is I've googled like thing I

00:28:19,680 --> 00:28:24,090
want to do codemod I taking a look at

00:28:21,540 --> 00:28:25,950
implementations by engineering teams out

00:28:24,090 --> 00:28:28,290
larger companies we saw the one for a

00:28:25,950 --> 00:28:30,300
lift where they took the react crowd

00:28:28,290 --> 00:28:31,860
types and covered them into actual types

00:28:30,300 --> 00:28:34,530
group types and that's always a good

00:28:31,860 --> 00:28:36,540
starting place it is very hard to write

00:28:34,530 --> 00:28:38,550
in code mop and scratch so I would say

00:28:36,540 --> 00:28:42,090
find a reference example and use that

00:28:38,550 --> 00:28:44,010
reference example to meet your cases ok

00:28:42,090 --> 00:28:46,700
thank you so much Simon let's giving one

00:28:44,010 --> 00:28:46,700
more round of applause

00:28:47,440 --> 00:29:01,279
[Applause]

00:28:48,120 --> 00:29:01,279

YouTube URL: https://www.youtube.com/watch?v=OaB_S6Kw3os


