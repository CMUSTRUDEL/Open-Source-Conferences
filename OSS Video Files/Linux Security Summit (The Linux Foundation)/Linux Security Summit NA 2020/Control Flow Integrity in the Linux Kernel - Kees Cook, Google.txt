Title: Control Flow Integrity in the Linux Kernel - Kees Cook, Google
Publication date: 2020-09-08
Playlist: Linux Security Summit NA 2020
Description: 
	Control Flow Integrity in the Linux Kernel - Kees Cook, Google
Captions: 
	00:00:03,199 --> 00:00:17,920
howdy everybody

00:00:05,920 --> 00:00:17,920
i'm just getting started up here

00:00:18,080 --> 00:00:25,760
all right um my name is case cook

00:00:22,400 --> 00:00:27,199
uh this presentation is on uh the state

00:00:25,760 --> 00:00:29,439
of

00:00:27,199 --> 00:00:31,679
cfi and linux kernel control flow

00:00:29,439 --> 00:00:36,160
integrity

00:00:31,679 --> 00:00:38,559
i've got my uh my slides going

00:00:36,160 --> 00:00:40,879
in the screen share which i think is a

00:00:38,559 --> 00:00:42,399
button at the bottom on your screens

00:00:40,879 --> 00:00:45,600
and if you can't see that for whatever

00:00:42,399 --> 00:00:46,160
reason you can look at the schedule and

00:00:45,600 --> 00:00:49,039
get

00:00:46,160 --> 00:00:51,680
a pdf of these slides from there and

00:00:49,039 --> 00:00:51,680
follow along

00:00:52,399 --> 00:00:56,640
anyway i'm going to go ahead and get

00:00:56,840 --> 00:01:01,760
started

00:00:58,160 --> 00:01:03,680
um so this is basically the

00:01:01,760 --> 00:01:06,320
agenda for the talk uh so we're getting

00:01:03,680 --> 00:01:07,920
into what is cfi and why we want it

00:01:06,320 --> 00:01:09,760
looking at the implementations that

00:01:07,920 --> 00:01:12,080
klein provides

00:01:09,760 --> 00:01:13,600
and talking a little bit about what's

00:01:12,080 --> 00:01:16,960
happening with

00:01:13,600 --> 00:01:17,840
the pixel phones and the android

00:01:16,960 --> 00:01:21,759
ecosystem

00:01:17,840 --> 00:01:24,159
generally sort of gotchas we ran into

00:01:21,759 --> 00:01:25,360
the upstreaming process and a little bit

00:01:24,159 --> 00:01:28,720
of an example about

00:01:25,360 --> 00:01:28,720
how you can do it yourself

00:01:31,520 --> 00:01:36,560
so uh main question is sort of why

00:01:34,479 --> 00:01:41,840
should anyone care about this at all

00:01:36,560 --> 00:01:41,840
um so

00:01:41,920 --> 00:01:47,600
actually uh and a lot of memory

00:01:44,640 --> 00:01:51,920
corruption attacks tends to be

00:01:47,600 --> 00:01:55,759
running code uh attacker chosen code

00:01:51,920 --> 00:01:58,479
and cfi is one of the ways we make sure

00:01:55,759 --> 00:01:59,280
that the order in which things are

00:01:58,479 --> 00:02:03,200
expected to run

00:01:59,280 --> 00:02:05,040
it doesn't get violated um and

00:02:03,200 --> 00:02:08,399
you know flaws come in a lot of

00:02:05,040 --> 00:02:11,760
different ways a lot of different

00:02:08,399 --> 00:02:15,200
situations that we end up

00:02:11,760 --> 00:02:17,440
able to manipulate the control flow

00:02:15,200 --> 00:02:18,480
so being able to actually block what's

00:02:17,440 --> 00:02:21,680
runnable

00:02:18,480 --> 00:02:24,879
has quite a bit of value um

00:02:21,680 --> 00:02:27,280
so looking back long ago

00:02:24,879 --> 00:02:28,640
there was you know actually writing

00:02:27,280 --> 00:02:30,959
directly to

00:02:28,640 --> 00:02:32,239
kernel code um you could just as an

00:02:30,959 --> 00:02:33,360
attacker if you have memory corruption

00:02:32,239 --> 00:02:35,280
and control over

00:02:33,360 --> 00:02:37,120
where you're writing you could just

00:02:35,280 --> 00:02:38,800
write directly to kernel code and change

00:02:37,120 --> 00:02:40,560
how it operates

00:02:38,800 --> 00:02:41,840
in that situation the target has to be

00:02:40,560 --> 00:02:44,640
executable and writable

00:02:41,840 --> 00:02:46,319
that is kind of ancient history

00:02:44,640 --> 00:02:48,480
protections existed

00:02:46,319 --> 00:02:51,120
for this of course if you are trying to

00:02:48,480 --> 00:02:53,040
write to memory from user space

00:02:51,120 --> 00:02:55,120
what's writable and executable well user

00:02:53,040 --> 00:02:57,840
space is writable and executable

00:02:55,120 --> 00:02:59,040
it's under control of the user but not

00:02:57,840 --> 00:03:01,680
the kernel because

00:02:59,040 --> 00:03:02,720
of memory protections but if you end up

00:03:01,680 --> 00:03:05,840
with

00:03:02,720 --> 00:03:06,560
a an exploit where you can start writing

00:03:05,840 --> 00:03:08,800
to

00:03:06,560 --> 00:03:09,840
kernel memory suddenly you can write to

00:03:08,800 --> 00:03:12,879
everything from

00:03:09,840 --> 00:03:15,599
you know in the long ago days

00:03:12,879 --> 00:03:16,879
and this is obviously simplified view

00:03:15,599 --> 00:03:19,680
there's a lot of kernel data

00:03:16,879 --> 00:03:22,000
and there's the text and modules which

00:03:19,680 --> 00:03:24,400
has the executable code in it

00:03:22,000 --> 00:03:26,720
um so forever ago there was just no

00:03:24,400 --> 00:03:28,879
permissions at all

00:03:26,720 --> 00:03:29,840
and then finally we got sort of the

00:03:28,879 --> 00:03:32,400
non-executable

00:03:29,840 --> 00:03:33,519
stuff changed so you couldn't run data

00:03:32,400 --> 00:03:35,440
you know you could

00:03:33,519 --> 00:03:36,799
you know dump stuff into keeper stack

00:03:35,440 --> 00:03:39,120
and then just run it

00:03:36,799 --> 00:03:40,640
um so with the add of the addition of

00:03:39,120 --> 00:03:43,200
the nx bit

00:03:40,640 --> 00:03:45,040
or similar mitigations that entire

00:03:43,200 --> 00:03:47,840
section of what went away is what as far

00:03:45,040 --> 00:03:50,879
as what you target as an attacker

00:03:47,840 --> 00:03:53,519
um and finally uh we got

00:03:50,879 --> 00:03:54,400
you know read only as well which says

00:03:53,519 --> 00:03:56,879
okay

00:03:54,400 --> 00:03:59,120
it's not writable and executable anymore

00:03:56,879 --> 00:04:01,599
so the kernel code is

00:03:59,120 --> 00:04:04,879
not writable so even if you can target

00:04:01,599 --> 00:04:04,879
it you can't change it

00:04:06,720 --> 00:04:10,239
and then but that left user space you

00:04:09,599 --> 00:04:12,000
could

00:04:10,239 --> 00:04:13,599
you know dump your code into user space

00:04:12,000 --> 00:04:16,560
and run it from the kernel

00:04:13,599 --> 00:04:17,280
and so with that separation suddenly you

00:04:16,560 --> 00:04:20,959
couldn't

00:04:17,280 --> 00:04:24,560
write and execute from anywhere anymore

00:04:20,959 --> 00:04:26,479
but this opens the door to the

00:04:24,560 --> 00:04:28,479
main the current attack method which is

00:04:26,479 --> 00:04:29,840
call into kernel code

00:04:28,479 --> 00:04:31,600
the kernel has all the functions you

00:04:29,840 --> 00:04:32,560
want as an attacker so those

00:04:31,600 --> 00:04:34,880
those are the ones you're going to go

00:04:32,560 --> 00:04:36,720
after so you can write two

00:04:34,880 --> 00:04:38,880
stored function pointers on the heap or

00:04:36,720 --> 00:04:40,720
on the stack

00:04:38,880 --> 00:04:42,639
and then manipulate what's going to be

00:04:40,720 --> 00:04:46,800
called in what order and

00:04:42,639 --> 00:04:48,479
just hijack indirect function calls now

00:04:46,800 --> 00:04:49,680
this begs the question what do i mean

00:04:48,479 --> 00:04:51,040
indirect function calls so direct

00:04:49,680 --> 00:04:53,120
function calls are the ones that

00:04:51,040 --> 00:04:55,199
in the assembly call one thing they have

00:04:53,120 --> 00:04:58,560
a hard-coded target

00:04:55,199 --> 00:05:00,320
so the example here is there's some some

00:04:58,560 --> 00:05:01,919
program you know some function that

00:05:00,320 --> 00:05:04,400
calls do simple but it is

00:05:01,919 --> 00:05:06,080
always calling it it can't change

00:05:04,400 --> 00:05:06,560
without rewriting the actual memory

00:05:06,080 --> 00:05:09,280
there

00:05:06,560 --> 00:05:11,039
of the code and if you look at the the

00:05:09,280 --> 00:05:12,160
intel assembly of that you can just see

00:05:11,039 --> 00:05:16,000
that it is calling

00:05:12,160 --> 00:05:18,080
specifically a hard-coded value

00:05:16,000 --> 00:05:19,120
an indirect function call is where

00:05:18,080 --> 00:05:20,800
you've loaded

00:05:19,120 --> 00:05:23,840
a value into a register and you're

00:05:20,800 --> 00:05:25,360
calling the register value

00:05:23,840 --> 00:05:27,440
on the left here you can see sort of an

00:05:25,360 --> 00:05:29,280
example of a function

00:05:27,440 --> 00:05:31,199
table do something simple do something

00:05:29,280 --> 00:05:35,360
fancy and then where you

00:05:31,199 --> 00:05:38,080
save that you want to call into it

00:05:35,360 --> 00:05:40,160
so if you're able to manipulate that

00:05:38,080 --> 00:05:42,639
saved actions list

00:05:40,160 --> 00:05:43,520
or otherwise corrupt memory there you

00:05:42,639 --> 00:05:48,160
can call

00:05:43,520 --> 00:05:48,160
basically anywhere in the entire kernel

00:05:48,639 --> 00:05:52,320
and this for the purpose of

00:05:51,120 --> 00:05:54,639
identification considered

00:05:52,320 --> 00:05:55,759
forward edge so this is the control flow

00:05:54,639 --> 00:05:58,800
forward as you're going

00:05:55,759 --> 00:06:00,240
towards the new function um

00:05:58,800 --> 00:06:01,120
and just to show you there's a couple

00:06:00,240 --> 00:06:02,639
different places where you can

00:06:01,120 --> 00:06:03,440
manipulate this with function pointer

00:06:02,639 --> 00:06:06,240
overwrites

00:06:03,440 --> 00:06:07,199
you can by overriding the heap memory or

00:06:06,240 --> 00:06:11,360
you can be

00:06:07,199 --> 00:06:11,360
overwriting the stack memory

00:06:11,390 --> 00:06:16,880
[Music]

00:06:12,960 --> 00:06:20,000
and we'll move on to

00:06:16,880 --> 00:06:21,600
backward edge is a stored function

00:06:20,000 --> 00:06:23,680
pointer on the stack right we're

00:06:21,600 --> 00:06:25,039
returning from this sub this leaf

00:06:23,680 --> 00:06:27,680
function do simple

00:06:25,039 --> 00:06:28,639
and that's the backward edge control

00:06:27,680 --> 00:06:30,240
flow where we return

00:06:28,639 --> 00:06:32,639
to where we came from and that can also

00:06:30,240 --> 00:06:35,600
be manipulated on the stack

00:06:32,639 --> 00:06:37,199
this is the the core of the the

00:06:35,600 --> 00:06:39,919
well-known return rng programming

00:06:37,199 --> 00:06:42,160
and rob attacks so the question is all

00:06:39,919 --> 00:06:43,680
right so we've got

00:06:42,160 --> 00:06:45,759
all these stored function pointers

00:06:43,680 --> 00:06:48,080
scattered throughout heap and stack

00:06:45,759 --> 00:06:49,520
um what are we looking at so from user

00:06:48,080 --> 00:06:51,520
space again obviously we can't write to

00:06:49,520 --> 00:06:54,479
the kernel so no problem

00:06:51,520 --> 00:06:56,319
um but then what do we got uh all right

00:06:54,479 --> 00:06:57,039
we've got the heap and the stack and the

00:06:56,319 --> 00:07:00,319
kernel

00:06:57,039 --> 00:07:02,560
is writable that's no good

00:07:00,319 --> 00:07:04,000
and we can also get to user space from

00:07:02,560 --> 00:07:05,440
here as well if we're calling from the

00:07:04,000 --> 00:07:08,560
kernel

00:07:05,440 --> 00:07:10,720
so s map and pam uh turn that off so

00:07:08,560 --> 00:07:12,880
we're left only with the heap and stack

00:07:10,720 --> 00:07:16,720
again in the kernel as being a

00:07:12,880 --> 00:07:19,440
targetable area

00:07:16,720 --> 00:07:20,240
so to break that down we've got writable

00:07:19,440 --> 00:07:22,160
memory and

00:07:20,240 --> 00:07:23,599
even stack and we have some kind of

00:07:22,160 --> 00:07:25,360
memory uh

00:07:23,599 --> 00:07:27,120
memory corruption that overwrites a

00:07:25,360 --> 00:07:29,120
stored function pointer

00:07:27,120 --> 00:07:30,880
and our forward edge looks sort of like

00:07:29,120 --> 00:07:31,840
that in assembly and our backward edge

00:07:30,880 --> 00:07:35,280
is just a return

00:07:31,840 --> 00:07:37,520
and we can write to sorry we can execute

00:07:35,280 --> 00:07:38,800
basically any executable range in the

00:07:37,520 --> 00:07:42,240
entire kernel

00:07:38,800 --> 00:07:45,280
any byte we want including for

00:07:42,240 --> 00:07:48,240
variable length assembly

00:07:45,280 --> 00:07:51,120
we can call into off off byte array

00:07:48,240 --> 00:07:51,120
addresses as well

00:07:51,280 --> 00:07:56,080
so the goal of cfi is to ensure that the

00:07:54,240 --> 00:07:58,960
forward and backward edges

00:07:56,080 --> 00:08:01,280
are actually going to expected places uh

00:07:58,960 --> 00:08:04,560
that they are effectively a subset of

00:08:01,280 --> 00:08:04,560
all of the possible

00:08:04,720 --> 00:08:10,240
kernel code in the entire uh all

00:08:07,599 --> 00:08:12,080
possible entry points into kernel code

00:08:10,240 --> 00:08:13,759
um but that's kind of a lot of entry

00:08:12,080 --> 00:08:17,120
points which we'll get into

00:08:13,759 --> 00:08:17,120
and the back of edge as well

00:08:18,240 --> 00:08:22,400
so if we validate indirect function

00:08:21,680 --> 00:08:27,599
pointers at call

00:08:22,400 --> 00:08:30,879
time one of the ways that this has

00:08:27,599 --> 00:08:35,200
a way to chop down what

00:08:30,879 --> 00:08:38,000
can be called into is to look at

00:08:35,200 --> 00:08:39,599
the classes of functions and to look at

00:08:38,000 --> 00:08:43,120
the prototype of the function

00:08:39,599 --> 00:08:45,680
to say okay this is returning int

00:08:43,120 --> 00:08:46,399
it takes an unsigned long and a struct

00:08:45,680 --> 00:08:48,240
file

00:08:46,399 --> 00:08:50,000
and you can sort of generate this this

00:08:48,240 --> 00:08:53,120
uniqueness this hash

00:08:50,000 --> 00:08:55,120
of of those prototypes and therefore

00:08:53,120 --> 00:08:57,519
different prototypes can't be mixed you

00:08:55,120 --> 00:09:00,560
know in the the fupar example here

00:08:57,519 --> 00:09:02,399
one returns void one returns int so

00:09:00,560 --> 00:09:04,800
in all places that is expecting to call

00:09:02,399 --> 00:09:08,480
a function that looks like foo

00:09:04,800 --> 00:09:11,279
you cannot instead call bar um

00:09:08,480 --> 00:09:11,839
the help from hardware here because this

00:09:11,279 --> 00:09:13,200
is all or

00:09:11,839 --> 00:09:15,519
i'm going to be mostly talking about

00:09:13,200 --> 00:09:19,200
software emulation help from hardware is

00:09:15,519 --> 00:09:21,760
not great so bti

00:09:19,200 --> 00:09:22,640
and and some of the other you know like

00:09:21,760 --> 00:09:26,160
n branch

00:09:22,640 --> 00:09:28,240
things in in the existing and the cpu

00:09:26,160 --> 00:09:31,680
instruction sets that are coming

00:09:28,240 --> 00:09:33,680
um they just mark an entry point at all

00:09:31,680 --> 00:09:35,279
um so instead of being able to call any

00:09:33,680 --> 00:09:37,279
byte in the kernel

00:09:35,279 --> 00:09:38,320
you can call any function in the kernel

00:09:37,279 --> 00:09:41,760
which for

00:09:38,320 --> 00:09:44,720
most uh purposes doesn't really change

00:09:41,760 --> 00:09:46,240
an attacker's situation they're not

00:09:44,720 --> 00:09:47,680
going to do gadget attacks they're just

00:09:46,240 --> 00:09:49,360
going to call directly to

00:09:47,680 --> 00:09:51,120
a full function and probably they were

00:09:49,360 --> 00:09:54,240
going to do that to begin with

00:09:51,120 --> 00:09:54,720
so having having you know calling any

00:09:54,240 --> 00:09:57,040
function

00:09:54,720 --> 00:09:59,040
as a limit is not much of a limit but

00:09:57,040 --> 00:10:01,920
being able to only call

00:09:59,040 --> 00:10:03,440
matching function prototypes narrows the

00:10:01,920 --> 00:10:05,760
attack surface of what you can call

00:10:03,440 --> 00:10:08,560
pretty pretty strongly

00:10:05,760 --> 00:10:09,040
and um so what do i mean by that so

00:10:08,560 --> 00:10:11,360
again

00:10:09,040 --> 00:10:12,880
compared to that prior slide it's a

00:10:11,360 --> 00:10:14,000
question of all right we have all of

00:10:12,880 --> 00:10:16,839
executable memory but

00:10:14,000 --> 00:10:19,600
from this one position this one bit of

00:10:16,839 --> 00:10:22,160
code no matter what you can write

00:10:19,600 --> 00:10:22,880
you can only call into the subset of

00:10:22,160 --> 00:10:24,800
functions

00:10:22,880 --> 00:10:26,959
that the compiler identified as being

00:10:24,800 --> 00:10:30,079
callable from that position

00:10:26,959 --> 00:10:34,640
so it hugely narrows what is

00:10:30,079 --> 00:10:37,519
what is reachable from a given location

00:10:34,640 --> 00:10:38,160
um now implementing this uh with clangs

00:10:37,519 --> 00:10:40,399
cfi

00:10:38,160 --> 00:10:41,600
is interesting it requires a link time

00:10:40,399 --> 00:10:43,040
optimization

00:10:41,600 --> 00:10:46,000
the idea is that it needs to be able to

00:10:43,040 --> 00:10:48,560
see the cfi code needs to be able to see

00:10:46,000 --> 00:10:50,000
the entire program at once to figure out

00:10:48,560 --> 00:10:51,519
all the prototypes and all the

00:10:50,000 --> 00:10:53,680
destinations

00:10:51,519 --> 00:10:55,360
and that's that's actually a pretty

00:10:53,680 --> 00:10:58,640
pretty large bit of work

00:10:55,360 --> 00:11:01,120
to get lto working um

00:10:58,640 --> 00:11:02,720
and with that uh what clang does is it

00:11:01,120 --> 00:11:04,640
it collects all the

00:11:02,720 --> 00:11:06,399
same all the functions that have the

00:11:04,640 --> 00:11:09,600
matching prototypes

00:11:06,399 --> 00:11:10,959
into jump tables and then verifies at

00:11:09,600 --> 00:11:13,760
indirect call sites

00:11:10,959 --> 00:11:15,200
uh through that junk table that it's

00:11:13,760 --> 00:11:17,839
that it's okay to

00:11:15,200 --> 00:11:19,120
call that function um and i can i'm

00:11:17,839 --> 00:11:19,839
gonna get into that because this is the

00:11:19,120 --> 00:11:21,440
piece

00:11:19,839 --> 00:11:22,880
i had wanted to see a while back it's

00:11:21,440 --> 00:11:26,480
like how is this piece

00:11:22,880 --> 00:11:29,040
actually implemented so we're gonna take

00:11:26,480 --> 00:11:31,040
a little bit of time to go look at the

00:11:29,040 --> 00:11:35,839
assembly

00:11:31,040 --> 00:11:40,880
without any without fangs forwarded cfi

00:11:35,839 --> 00:11:43,040
so from my prior trivial example

00:11:40,880 --> 00:11:44,160
there are these these two functions do

00:11:43,040 --> 00:11:47,279
simple through fancy

00:11:44,160 --> 00:11:48,720
uh that we're calling from action launch

00:11:47,279 --> 00:11:51,120
and normally we're gonna take our

00:11:48,720 --> 00:11:53,200
arguments um

00:11:51,120 --> 00:11:54,720
and calculate what we need and call

00:11:53,200 --> 00:11:57,839
directly into those functions

00:11:54,720 --> 00:11:57,839
and off we go

00:11:58,000 --> 00:12:04,880
now if we add bank cfi and those are

00:12:02,800 --> 00:12:06,320
give you the command line options for

00:12:04,880 --> 00:12:08,720
enabling that

00:12:06,320 --> 00:12:10,000
what happens is a jump table is is

00:12:08,720 --> 00:12:11,440
created for these two

00:12:10,000 --> 00:12:14,000
functions because they share the same

00:12:11,440 --> 00:12:16,079
prototype um

00:12:14,000 --> 00:12:17,760
and you can see that it's it's literally

00:12:16,079 --> 00:12:21,120
a jump to the functions

00:12:17,760 --> 00:12:23,440
that are targeted from there as well as

00:12:21,120 --> 00:12:25,040
interrupts in between to catch anything

00:12:23,440 --> 00:12:26,399
that jumps into the wrong place

00:12:25,040 --> 00:12:29,360
and i'll walk through what the added

00:12:26,399 --> 00:12:31,680
assembly here does

00:12:29,360 --> 00:12:33,040
so the first thing is we're going to

00:12:31,680 --> 00:12:35,680
load this

00:12:33,040 --> 00:12:37,600
the start of the jump table so we can

00:12:35,680 --> 00:12:39,040
start the verification this is before

00:12:37,600 --> 00:12:42,240
we've made our

00:12:39,040 --> 00:12:42,240
our call

00:12:42,720 --> 00:12:46,560
we're going to subtract the address

00:12:45,200 --> 00:12:48,160
we're trying to jump to

00:12:46,560 --> 00:12:50,160
so we're subtracting this from the copy

00:12:48,160 --> 00:12:53,600
of the function pointer

00:12:50,160 --> 00:12:56,000
and then rotate it right by three um

00:12:53,600 --> 00:12:58,000
and now this is not a shift this is

00:12:56,000 --> 00:13:00,399
actually rotate so if there is anything

00:12:58,000 --> 00:13:02,959
above it it'll end up in anything in the

00:13:00,399 --> 00:13:06,000
top bits that went up in the low bits

00:13:02,959 --> 00:13:07,279
uh and so we have to have an exact the

00:13:06,000 --> 00:13:09,200
address needs to be

00:13:07,279 --> 00:13:11,279
exactly correct for this to work and

00:13:09,200 --> 00:13:13,920
this uh this hex three means we're

00:13:11,279 --> 00:13:15,360
looking at eight byte uh chunks so

00:13:13,920 --> 00:13:17,360
that's that's why the three on the

00:13:15,360 --> 00:13:20,560
rotate exists

00:13:17,360 --> 00:13:21,279
um and so our index into this table must

00:13:20,560 --> 00:13:24,880
be

00:13:21,279 --> 00:13:26,959
zero or one so if we are above that

00:13:24,880 --> 00:13:28,079
uh again with any of those bits that got

00:13:26,959 --> 00:13:31,200
rotated around

00:13:28,079 --> 00:13:31,519
um then we're going to fail and go to

00:13:31,200 --> 00:13:34,800
this

00:13:31,519 --> 00:13:37,760
uh the d2 which will trap

00:13:34,800 --> 00:13:39,040
otherwise we continue on and we call

00:13:37,760 --> 00:13:40,320
into

00:13:39,040 --> 00:13:42,800
call into that table and jump to the

00:13:40,320 --> 00:13:46,800
correct function

00:13:42,800 --> 00:13:50,079
and as a bit of an aside here um

00:13:46,800 --> 00:13:53,120
the the type names in here are actually

00:13:50,079 --> 00:13:55,600
the embedded uh function

00:13:53,120 --> 00:13:57,600
prototype uh so it's a type mangling

00:13:55,600 --> 00:14:00,079
from like c plus plus

00:13:57,600 --> 00:14:01,360
uh you can actually see what each of

00:14:00,079 --> 00:14:03,120
these tables

00:14:01,360 --> 00:14:05,600
what function prototype the table

00:14:03,120 --> 00:14:07,839
represents

00:14:05,600 --> 00:14:07,839
um

00:14:10,079 --> 00:14:14,720
so the question is are there better

00:14:12,399 --> 00:14:17,600
implementations than this

00:14:14,720 --> 00:14:19,440
there's i think two worth mentioning um

00:14:17,600 --> 00:14:22,000
so

00:14:19,440 --> 00:14:23,360
for uh improved speed instead of jump

00:14:22,000 --> 00:14:23,920
tables and dsl checks and everything you

00:14:23,360 --> 00:14:26,079
actually

00:14:23,920 --> 00:14:27,519
can do hash bytes before function

00:14:26,079 --> 00:14:30,560
certain return destinations

00:14:27,519 --> 00:14:32,639
um this is what pax teams wrap does

00:14:30,560 --> 00:14:34,320
but this isn't ultimately compatible

00:14:32,639 --> 00:14:36,880
execute only memory

00:14:34,320 --> 00:14:38,639
uh so because that code stream is

00:14:36,880 --> 00:14:40,160
actually trying to read the hashes out

00:14:38,639 --> 00:14:42,560
of

00:14:40,160 --> 00:14:44,160
the text segment so once we get to the

00:14:42,560 --> 00:14:44,800
point where we've got cpus where we can

00:14:44,160 --> 00:14:47,040
do

00:14:44,800 --> 00:14:48,880
execute only memory where attackers are

00:14:47,040 --> 00:14:52,399
not reading back the kernel

00:14:48,880 --> 00:14:55,600
to find gadgets and things like that

00:14:52,399 --> 00:14:58,959
this approach doesn't really work

00:14:55,600 --> 00:15:00,399
so we don't get as strong an overlap

00:14:58,959 --> 00:15:01,360
once we get execute only memory won't be

00:15:00,399 --> 00:15:04,240
able to read

00:15:01,360 --> 00:15:05,279
gadgets and then if things are you know

00:15:04,240 --> 00:15:06,800
aslr

00:15:05,279 --> 00:15:08,880
you can't see where you need to jump

00:15:06,800 --> 00:15:09,519
anyway combining these mitigations makes

00:15:08,880 --> 00:15:13,600
them

00:15:09,519 --> 00:15:17,600
quite a bit more powerful another

00:15:13,600 --> 00:15:20,079
change that would be nice to have is

00:15:17,600 --> 00:15:21,600
sort of chopping up the existing

00:15:20,079 --> 00:15:24,000
prototype

00:15:21,600 --> 00:15:26,480
analysis that's been going on there was

00:15:24,000 --> 00:15:29,920
a kcfi that was done

00:15:26,480 --> 00:15:32,000
to look at call sites try to further

00:15:29,920 --> 00:15:33,040
narrow the scope of what was a valid

00:15:32,000 --> 00:15:35,759
call

00:15:33,040 --> 00:15:36,639
since the kernel already has a lot of

00:15:35,759 --> 00:15:39,759
void return

00:15:36,639 --> 00:15:40,639
void argument functions there's a huge

00:15:39,759 --> 00:15:43,040
chunk

00:15:40,639 --> 00:15:45,279
that can be called from from any place

00:15:43,040 --> 00:15:48,639
that calls a void void

00:15:45,279 --> 00:15:51,680
and to sort of take a look

00:15:48,639 --> 00:15:52,399
at this more closely android did an

00:15:51,680 --> 00:15:55,519
analysis

00:15:52,399 --> 00:15:56,720
of you know the the targets at indirect

00:15:55,519 --> 00:15:59,839
call sites

00:15:56,720 --> 00:16:03,120
so you see you know about 55

00:15:59,839 --> 00:16:04,560
of of any of the indirect calls that are

00:16:03,120 --> 00:16:08,160
made in the kernel

00:16:04,560 --> 00:16:09,759
they allow less you know five or fewer

00:16:08,160 --> 00:16:11,519
different functions can be called from

00:16:09,759 --> 00:16:14,399
there uh which is a

00:16:11,519 --> 00:16:16,079
a huge rejection in in the sort of

00:16:14,399 --> 00:16:18,000
attack surface or the

00:16:16,079 --> 00:16:20,000
function call surface that an attacker

00:16:18,000 --> 00:16:22,000
can make um

00:16:20,000 --> 00:16:23,759
and this sort of spreads out but then

00:16:22,000 --> 00:16:24,959
there's a there's another small peak at

00:16:23,759 --> 00:16:28,160
the end

00:16:24,959 --> 00:16:29,360
um where you know a fairly large you

00:16:28,160 --> 00:16:31,759
know seven percent have

00:16:29,360 --> 00:16:32,880
more than 100 allowed targets which is

00:16:31,759 --> 00:16:36,320
kind of huge so

00:16:32,880 --> 00:16:38,399
if there's vulnerability near those

00:16:36,320 --> 00:16:39,680
you haven't limited what functions you

00:16:38,399 --> 00:16:43,040
can call into

00:16:39,680 --> 00:16:44,000
particularly well so trying to bucketize

00:16:43,040 --> 00:16:47,759
that and say

00:16:44,000 --> 00:16:49,360
well just because i call avoid void

00:16:47,759 --> 00:16:51,759
function here

00:16:49,360 --> 00:16:52,480
i am only expecting to call any of these

00:16:51,759 --> 00:16:54,800
you know

00:16:52,480 --> 00:16:55,519
five different ones um so there is a

00:16:54,800 --> 00:16:58,399
stronger

00:16:55,519 --> 00:16:59,440
bucket eyes that can go on there so this

00:16:58,399 --> 00:17:01,360
is

00:16:59,440 --> 00:17:03,440
this is mostly been about forward edge

00:17:01,360 --> 00:17:04,959
here but we also have

00:17:03,440 --> 00:17:06,640
the backward edge protection which is

00:17:04,959 --> 00:17:10,160
returning um

00:17:06,640 --> 00:17:12,240
so we want to make sure that the stack

00:17:10,160 --> 00:17:14,480
address that got saved there the saved

00:17:12,240 --> 00:17:16,400
function pointer on the stack

00:17:14,480 --> 00:17:18,000
didn't change or we're going to where

00:17:16,400 --> 00:17:21,039
we're expecting

00:17:18,000 --> 00:17:24,160
so we can handle this with a

00:17:21,039 --> 00:17:25,679
separate stack this is called a shadow

00:17:24,160 --> 00:17:28,720
call stack

00:17:25,679 --> 00:17:30,160
and this piece actually is best done in

00:17:28,720 --> 00:17:33,120
hardware right now

00:17:30,160 --> 00:17:34,799
um we're looking at intel cet and arms

00:17:33,120 --> 00:17:37,679
pointer authentication

00:17:34,799 --> 00:17:39,760
for this that provides actually a much

00:17:37,679 --> 00:17:42,799
faster way to do this but there is

00:17:39,760 --> 00:17:46,160
a software emulated version for

00:17:42,799 --> 00:17:50,320
for clang um and sort of

00:17:46,160 --> 00:17:52,160
uh looking at this um there's an idea of

00:17:50,320 --> 00:17:53,600
uh well first note i should make is this

00:17:52,160 --> 00:17:55,919
is this is all arm

00:17:53,600 --> 00:17:57,520
examples right now because the x86

00:17:55,919 --> 00:18:00,160
implementation of this and clang

00:17:57,520 --> 00:18:01,520
turned out to be pretty slow and have

00:18:00,160 --> 00:18:04,559
race conditions

00:18:01,520 --> 00:18:07,120
but the idea here is that

00:18:04,559 --> 00:18:08,799
you can split from the compiler the

00:18:07,120 --> 00:18:09,280
local variables and register spills that

00:18:08,799 --> 00:18:11,760
you need

00:18:09,280 --> 00:18:14,160
into sort of the traditional stack and

00:18:11,760 --> 00:18:17,360
then your return address goes into

00:18:14,160 --> 00:18:18,320
what should be a secret stack now this

00:18:17,360 --> 00:18:20,640
is obviously

00:18:18,320 --> 00:18:21,760
a problem because if you are if an

00:18:20,640 --> 00:18:23,440
attacker is able to expose the

00:18:21,760 --> 00:18:25,360
destination

00:18:23,440 --> 00:18:26,720
you know where these the secret stack is

00:18:25,360 --> 00:18:29,039
held then obviously they can start

00:18:26,720 --> 00:18:30,720
overriding return addresses again but

00:18:29,039 --> 00:18:32,880
the idea would be to reserve

00:18:30,720 --> 00:18:33,840
a single register to be sort of a second

00:18:32,880 --> 00:18:36,880
stack

00:18:33,840 --> 00:18:38,960
register stack pointer

00:18:36,880 --> 00:18:40,160
and i note also in here that the return

00:18:38,960 --> 00:18:43,200
address is actually

00:18:40,160 --> 00:18:45,120
still saved to the traditional stack

00:18:43,200 --> 00:18:47,520
and that's so that back traces and

00:18:45,120 --> 00:18:50,400
unwinders can still do their job without

00:18:47,520 --> 00:18:51,760
knowing anything about the shadow stack

00:18:50,400 --> 00:18:52,799
just the question is what does this look

00:18:51,760 --> 00:18:55,760
like

00:18:52,799 --> 00:18:58,080
um so if you dedicate a single register

00:18:55,760 --> 00:19:01,280
and turn on the shadow call stack

00:18:58,080 --> 00:19:03,039
um you end up storing in here you can

00:19:01,280 --> 00:19:06,640
see the

00:19:03,039 --> 00:19:09,760
the store of the stack pointer

00:19:06,640 --> 00:19:10,960
so x30 is getting stored to location of

00:19:09,760 --> 00:19:13,039
x18 and

00:19:10,960 --> 00:19:14,080
stack pointer so we end up with a copy

00:19:13,039 --> 00:19:15,840
of this

00:19:14,080 --> 00:19:17,360
restore it and load it back out on

00:19:15,840 --> 00:19:20,320
return so

00:19:17,360 --> 00:19:22,000
we left the old code the old right of it

00:19:20,320 --> 00:19:23,600
and we just overwrite so whatever got

00:19:22,000 --> 00:19:25,919
overwritten

00:19:23,600 --> 00:19:27,520
here just gets restored from the shadow

00:19:25,919 --> 00:19:30,320
stack

00:19:27,520 --> 00:19:32,480
now what's kind of amusing here is that

00:19:30,320 --> 00:19:35,280
this means

00:19:32,480 --> 00:19:35,919
if you end up with a stack return

00:19:35,280 --> 00:19:39,200
pointer

00:19:35,919 --> 00:19:42,000
overwrite on the traditional stack

00:19:39,200 --> 00:19:43,600
you have no there was currently no check

00:19:42,000 --> 00:19:45,919
that it got changed

00:19:43,600 --> 00:19:49,360
so you could add a check in between here

00:19:45,919 --> 00:19:51,760
before you return and say hey did

00:19:49,360 --> 00:19:54,160
the x30 you know did we get the wrong

00:19:51,760 --> 00:19:56,640
value into x30 on our second load

00:19:54,160 --> 00:19:58,000
but that adds a bit of overhead um so we

00:19:56,640 --> 00:20:02,080
haven't done it

00:19:58,000 --> 00:20:05,840
in hardware this looks very similar

00:20:02,080 --> 00:20:09,039
and you have instead the the

00:20:05,840 --> 00:20:11,600
sign pointers on arm where we

00:20:09,039 --> 00:20:12,080
sign what we store and when we pull it

00:20:11,600 --> 00:20:15,520
back out

00:20:12,080 --> 00:20:19,039
we validate uh the bits that are there

00:20:15,520 --> 00:20:20,000
and we fault on that and end up uh if if

00:20:19,039 --> 00:20:24,400
the

00:20:20,000 --> 00:20:28,000
if the validation fails um

00:20:24,400 --> 00:20:30,159
what what got written uh ends up

00:20:28,000 --> 00:20:31,039
landing in the non-canonical zone so

00:20:30,159 --> 00:20:35,840
when we return

00:20:31,039 --> 00:20:35,840
we end up jumping into the void

00:20:37,280 --> 00:20:43,200
so what is happening right now on pixel

00:20:40,559 --> 00:20:45,440
phones which use

00:20:43,200 --> 00:20:47,520
a choose clang for their for everything

00:20:45,440 --> 00:20:49,200
for their builds

00:20:47,520 --> 00:20:50,799
sami tolbin and a lot of other people

00:20:49,200 --> 00:20:51,760
are doing a giant amount of work to

00:20:50,799 --> 00:20:55,440
enable

00:20:51,760 --> 00:20:57,679
lto cfi and scs

00:20:55,440 --> 00:20:59,600
in android and the upstream kernels

00:20:57,679 --> 00:21:01,520
pixel 3 and later

00:20:59,600 --> 00:21:03,520
have all this enabled both forward and

00:21:01,520 --> 00:21:07,039
backward protection

00:21:03,520 --> 00:21:09,520
and there is now a documentation

00:21:07,039 --> 00:21:11,120
well recommendation i should say in the

00:21:09,520 --> 00:21:14,000
android

00:21:11,120 --> 00:21:16,559
compatibility definition that says cfi

00:21:14,000 --> 00:21:18,080
is strongly recommended in both

00:21:16,559 --> 00:21:20,000
directions for

00:21:18,080 --> 00:21:22,000
for the kernel as well as i think of

00:21:20,000 --> 00:21:22,799
user space but i'm quoting the kernel

00:21:22,000 --> 00:21:26,559
bits here

00:21:22,799 --> 00:21:30,799
on this page and the idea would be

00:21:26,559 --> 00:21:32,880
that as this progresses

00:21:30,799 --> 00:21:34,480
um this will switch from strongly

00:21:32,880 --> 00:21:37,679
recommended to required

00:21:34,480 --> 00:21:41,520
so this will be a standard mitigation

00:21:37,679 --> 00:21:41,520
for the entire android ecosystem

00:21:43,280 --> 00:21:49,360
so what problems have we encountered

00:21:46,559 --> 00:21:50,720
uh as far as getting this upstream and

00:21:49,360 --> 00:21:54,159
getting the supported

00:21:50,720 --> 00:21:58,080
uh implementation ported to the kernel

00:21:54,159 --> 00:22:01,600
um so the probably the biggest one was

00:21:58,080 --> 00:22:05,840
lto default lto and clang was

00:22:01,600 --> 00:22:07,360
massively slow it like added

00:22:05,840 --> 00:22:09,200
something like 20 minutes to the link

00:22:07,360 --> 00:22:11,760
stage or possibly hours when you're

00:22:09,200 --> 00:22:15,280
doing a really large kernel

00:22:11,760 --> 00:22:18,400
luckily uh thin lto

00:22:15,280 --> 00:22:18,960
in clang does a much much better job of

00:22:18,400 --> 00:22:21,360
this

00:22:18,960 --> 00:22:22,000
it had it had a lot of corner cases that

00:22:21,360 --> 00:22:24,480
needed to be

00:22:22,000 --> 00:22:27,039
fixed that it missed and the kernel had

00:22:24,480 --> 00:22:29,120
a lot of weird linker aliases and other

00:22:27,039 --> 00:22:32,000
strange behaviors that uh any

00:22:29,120 --> 00:22:33,039
saying linker would be reasonable not to

00:22:32,000 --> 00:22:35,360
expect

00:22:33,039 --> 00:22:37,039
um and the kernel another piece of the

00:22:35,360 --> 00:22:38,240
kernel has is a ton of assembly code

00:22:37,039 --> 00:22:39,760
obviously you know

00:22:38,240 --> 00:22:41,600
most of the kernels can see but a lot of

00:22:39,760 --> 00:22:42,880
it is an assembly especially things like

00:22:41,600 --> 00:22:45,039
crypto and

00:22:42,880 --> 00:22:47,039
you know the low-level low-level

00:22:45,039 --> 00:22:50,240
architecture functions

00:22:47,039 --> 00:22:51,760
um and at the time clang really had no

00:22:50,240 --> 00:22:55,440
visibility into that

00:22:51,760 --> 00:22:58,400
and we asked around and found

00:22:55,440 --> 00:22:59,919
uh peter collinburn was kind enough to

00:22:58,400 --> 00:23:00,880
fix this up for us so we could actually

00:22:59,919 --> 00:23:03,120
generate

00:23:00,880 --> 00:23:04,240
tables for all extern functions without

00:23:03,120 --> 00:23:07,679
regard to whether or not

00:23:04,240 --> 00:23:09,200
it was in c or assembly another gotcha

00:23:07,679 --> 00:23:12,080
was relative addresses

00:23:09,200 --> 00:23:13,520
um we'd calculate the actual destination

00:23:12,080 --> 00:23:16,240
function

00:23:13,520 --> 00:23:18,000
as opposed to the junk table and then

00:23:16,240 --> 00:23:20,000
try to recalculate it later

00:23:18,000 --> 00:23:22,480
and it would fail this is true in the

00:23:20,000 --> 00:23:24,240
excess exception tables

00:23:22,480 --> 00:23:26,080
the simple thing here which was nice is

00:23:24,240 --> 00:23:28,080
that the exception tables are already

00:23:26,080 --> 00:23:31,520
hard-coded data in the kernel

00:23:28,080 --> 00:23:33,840
um so they are in effect their own cfi

00:23:31,520 --> 00:23:36,559
term tables so we could just turn off

00:23:33,840 --> 00:23:39,280
the cfi checks for those

00:23:36,559 --> 00:23:40,960
um linker aliases i sort of mentioned

00:23:39,280 --> 00:23:43,520
earlier

00:23:40,960 --> 00:23:44,880
there's very strange tricks that are

00:23:43,520 --> 00:23:47,440
happening

00:23:44,880 --> 00:23:49,679
kpti was interesting because what it was

00:23:47,440 --> 00:23:51,600
doing

00:23:49,679 --> 00:23:53,679
you know for for dealing with meltdown

00:23:51,600 --> 00:23:55,120
is it switches out the page tables and

00:23:53,679 --> 00:23:57,440
has a very minimal

00:23:55,120 --> 00:23:58,320
kernel page table visible from user

00:23:57,440 --> 00:24:01,600
space so

00:23:58,320 --> 00:24:04,240
on syscall entry into the kernel

00:24:01,600 --> 00:24:05,679
the idea was that you then swap around

00:24:04,240 --> 00:24:07,120
the page tables and then suddenly the

00:24:05,679 --> 00:24:10,000
entire kernel was visible

00:24:07,120 --> 00:24:10,799
however there were enough indirect calls

00:24:10,000 --> 00:24:15,039
in

00:24:10,799 --> 00:24:16,880
the syscall entry stub

00:24:15,039 --> 00:24:18,720
that it also needed to be able to see

00:24:16,880 --> 00:24:22,000
the jump tables

00:24:18,720 --> 00:24:23,440
which was awkward so right now the best

00:24:22,000 --> 00:24:26,400
solution

00:24:23,440 --> 00:24:27,520
is to map those jump tables back into

00:24:26,400 --> 00:24:31,039
the common thing

00:24:27,520 --> 00:24:33,760
this results in some meltdown

00:24:31,039 --> 00:24:36,240
kslr leaks but it's not like we didn't

00:24:33,760 --> 00:24:37,840
have those already

00:24:36,240 --> 00:24:40,400
what i'd like to do is either eliminate

00:24:37,840 --> 00:24:42,559
the indirect jumps on syscall entry

00:24:40,400 --> 00:24:43,760
or limit the jump tables to only the

00:24:42,559 --> 00:24:47,279
ones that we need for

00:24:43,760 --> 00:24:49,840
cisco entry um

00:24:47,279 --> 00:24:51,840
then we've got sort of upstreaming

00:24:49,840 --> 00:24:53,730
status where are we um

00:24:51,840 --> 00:24:56,080
clang uh

00:24:53,730 --> 00:24:58,400
[Music]

00:24:56,080 --> 00:25:00,400
as as this moves we always think we're

00:24:58,400 --> 00:25:04,240
done and then we hit some other new

00:25:00,400 --> 00:25:07,200
bug uh so i'm gonna say clang is done as

00:25:04,240 --> 00:25:08,640
of the unreleased llvm11

00:25:07,200 --> 00:25:10,240
but we keep tripping on things every

00:25:08,640 --> 00:25:12,559
once in a while usually it's in corner

00:25:10,240 --> 00:25:12,880
cases or really specialized configs but

00:25:12,559 --> 00:25:15,679
for

00:25:12,880 --> 00:25:17,200
for general purpose stuff now this works

00:25:15,679 --> 00:25:23,120
and this works even

00:25:17,200 --> 00:25:23,120
in client excuse me incline 10 as well

00:25:24,559 --> 00:25:28,480
on the kernel side there's been a lot of

00:25:27,120 --> 00:25:31,840
consistent progress

00:25:28,480 --> 00:25:35,360
the shadow callsack support for arm

00:25:31,840 --> 00:25:36,159
is in linus's tree now so unless it gets

00:25:35,360 --> 00:25:39,760
ripped out

00:25:36,159 --> 00:25:42,640
suddenly uh it should be in um

00:25:39,760 --> 00:25:43,600
sorry 5.8 this is a typo this will be in

00:25:42,640 --> 00:25:46,799
5.8

00:25:43,600 --> 00:25:49,440
um there's an ongoing work to fix

00:25:46,799 --> 00:25:51,440
fix the function function pointer

00:25:49,440 --> 00:25:54,880
prototype

00:25:51,440 --> 00:25:55,520
because if you you can do casting in the

00:25:54,880 --> 00:25:58,159
kernel

00:25:55,520 --> 00:25:59,039
in a number of ways i'm just say oh yeah

00:25:58,159 --> 00:26:00,640
yeah i'm totally

00:25:59,039 --> 00:26:02,240
calling this function here and then when

00:26:00,640 --> 00:26:03,520
you actually look at the function that's

00:26:02,240 --> 00:26:04,720
being targeted it has a completely

00:26:03,520 --> 00:26:06,880
different prototype

00:26:04,720 --> 00:26:08,640
now c sort of doesn't really care about

00:26:06,880 --> 00:26:10,000
that too much you can trick it in a lot

00:26:08,640 --> 00:26:12,000
of different ways the colonel has

00:26:10,000 --> 00:26:13,279
found many novel ways to trick the

00:26:12,000 --> 00:26:16,880
kernel or

00:26:13,279 --> 00:26:20,640
c into being happy with that um

00:26:16,880 --> 00:26:22,080
but cfi is way way more careful so

00:26:20,640 --> 00:26:23,520
we keep encountering those there's a

00:26:22,080 --> 00:26:24,640
bunch of different ways we can look for

00:26:23,520 --> 00:26:26,480
those

00:26:24,640 --> 00:26:27,919
and i expect that to continue for some

00:26:26,480 --> 00:26:30,480
time as cfi

00:26:27,919 --> 00:26:32,480
gets used more widely because right now

00:26:30,480 --> 00:26:33,440
most of the focus has been on android

00:26:32,480 --> 00:26:36,559
and arm

00:26:33,440 --> 00:26:39,600
so the what's getting

00:26:36,559 --> 00:26:42,080
exercised by cfi is relatively narrow

00:26:39,600 --> 00:26:43,279
but it does work for a desktop system as

00:26:42,080 --> 00:26:47,520
well

00:26:43,279 --> 00:26:50,720
um the the lto patches

00:26:47,520 --> 00:26:51,279
are it's pretty large it's mostly i

00:26:50,720 --> 00:26:52,799
would say

00:26:51,279 --> 00:26:54,640
i've been calling it tricky mechanical

00:26:52,799 --> 00:26:58,240
build script changes

00:26:54,640 --> 00:27:01,200
in that the the the issue with lto is

00:26:58,240 --> 00:27:02,320
normally what happens when you build is

00:27:01,200 --> 00:27:04,159
you take your c file

00:27:02,320 --> 00:27:05,679
and you generate an object file out of

00:27:04,159 --> 00:27:06,960
it which is the actual

00:27:05,679 --> 00:27:08,720
you know assembly code that's going to

00:27:06,960 --> 00:27:10,080
be run the machine code

00:27:08,720 --> 00:27:12,159
and then the linker just squishes it all

00:27:10,080 --> 00:27:14,159
together with

00:27:12,159 --> 00:27:16,400
lto what happens is you actually get an

00:27:14,159 --> 00:27:18,080
intermediate you get a different

00:27:16,400 --> 00:27:21,120
language it gets converted from

00:27:18,080 --> 00:27:22,720
c into llvm's ir the intermediate

00:27:21,120 --> 00:27:25,520
representation

00:27:22,720 --> 00:27:25,919
so what was an object file is now this

00:27:25,520 --> 00:27:29,120
you know

00:27:25,919 --> 00:27:29,600
this ir file so in a lot of places the

00:27:29,120 --> 00:27:32,080
kernel

00:27:29,600 --> 00:27:34,559
is expecting to find an object file to

00:27:32,080 --> 00:27:36,720
do checks on it or to merge it or to

00:27:34,559 --> 00:27:37,919
make it part of an archive or do various

00:27:36,720 --> 00:27:41,440
things like that

00:27:37,919 --> 00:27:44,320
um so we need to either delay

00:27:41,440 --> 00:27:44,960
those checks until later once the object

00:27:44,320 --> 00:27:49,200
once the

00:27:44,960 --> 00:27:51,840
actual assembly has been produced um or

00:27:49,200 --> 00:27:53,600
not you know to build things not uh with

00:27:51,840 --> 00:27:54,240
the ir like there's a bunch of sort of

00:27:53,600 --> 00:27:56,159
little

00:27:54,240 --> 00:27:58,159
test modules and other things that get

00:27:56,159 --> 00:28:00,159
built that expect to be just an object

00:27:58,159 --> 00:28:03,039
file so we can

00:28:00,159 --> 00:28:03,600
we can say that those aren't um those

00:28:03,039 --> 00:28:05,760
aren't built

00:28:03,600 --> 00:28:07,520
being built with the ir those can just

00:28:05,760 --> 00:28:10,880
be built normally

00:28:07,520 --> 00:28:12,640
um and then there's some questions about

00:28:10,880 --> 00:28:15,600
memory ordering and visibility

00:28:12,640 --> 00:28:16,000
uh and those those seem to be settled uh

00:28:15,600 --> 00:28:19,120
the

00:28:16,000 --> 00:28:20,559
the concern was the compiler may do

00:28:19,120 --> 00:28:23,600
optimizations

00:28:20,559 --> 00:28:26,799
now that it can see the entire kernel

00:28:23,600 --> 00:28:28,799
um you know all at once it might

00:28:26,799 --> 00:28:31,679
do weird inlining or do other things

00:28:28,799 --> 00:28:34,480
like that and cause a problem

00:28:31,679 --> 00:28:36,480
but the belief is that if there are bugs

00:28:34,480 --> 00:28:39,760
in the compiler about that

00:28:36,480 --> 00:28:42,960
they exist even in a non-lto build

00:28:39,760 --> 00:28:46,000
so we're just going to move forward

00:28:42,960 --> 00:28:48,480
um and then there's cfi proper um

00:28:46,000 --> 00:28:49,360
this is pretty big but uh hopefully it

00:28:48,480 --> 00:28:51,919
should be

00:28:49,360 --> 00:28:53,360
relatively uncontroversial and land

00:28:51,919 --> 00:28:56,559
quickly after lto

00:28:53,360 --> 00:28:58,720
um most of the most

00:28:56,559 --> 00:29:00,480
ongoing work on that is with the

00:28:58,720 --> 00:29:04,320
prototype fixes

00:29:00,480 --> 00:29:06,480
um but it should be i'm

00:29:04,320 --> 00:29:09,200
predicting uh perhaps natively but it

00:29:06,480 --> 00:29:09,200
will go smoothly

00:29:10,559 --> 00:29:13,760
so if you want to try any of this stuff

00:29:12,559 --> 00:29:16,960
out yourself

00:29:13,760 --> 00:29:20,159
uh i have

00:29:16,960 --> 00:29:21,760
back in november i put up a blog post on

00:29:20,159 --> 00:29:24,000
actually doing this for yourself in the

00:29:21,760 --> 00:29:26,240
upstream uh

00:29:24,000 --> 00:29:27,679
option kernel um the main chunk of that

00:29:26,240 --> 00:29:28,640
i updated recently for getting the

00:29:27,679 --> 00:29:32,640
latest

00:29:28,640 --> 00:29:35,279
version of clang built uh and then

00:29:32,640 --> 00:29:36,080
in there i was uh in that blog post i

00:29:35,279 --> 00:29:38,159
had talked about

00:29:36,080 --> 00:29:39,520
a specific tree for me that i had

00:29:38,159 --> 00:29:42,320
published for

00:29:39,520 --> 00:29:44,720
it was basically sami's tree plus more

00:29:42,320 --> 00:29:46,880
x86 fixes that i've been working on

00:29:44,720 --> 00:29:48,240
but all my fixes are now on sammy's tree

00:29:46,880 --> 00:29:51,919
so you can just go pull

00:29:48,240 --> 00:29:54,399
directly from from sammy's tree

00:29:51,919 --> 00:29:56,000
and uh when you're building you want to

00:29:54,399 --> 00:29:59,279
make sure you've redirected to clang

00:29:56,000 --> 00:30:00,159
and klein's linker sorry the l the llvm

00:29:59,279 --> 00:30:02,960
linker

00:30:00,159 --> 00:30:03,520
uh let me just turn on lto within lto

00:30:02,960 --> 00:30:06,720
turn off

00:30:03,520 --> 00:30:08,799
lto none turn on lto clang turn on

00:30:06,720 --> 00:30:12,799
client cfi

00:30:08,799 --> 00:30:16,799
and the shadow and then if you want

00:30:12,799 --> 00:30:19,279
um if you want the cfi violations to be

00:30:16,799 --> 00:30:21,039
non-fatal in other words to not you know

00:30:19,279 --> 00:30:22,159
stop that kernel thread you can actually

00:30:21,039 --> 00:30:24,399
set them to be

00:30:22,159 --> 00:30:26,240
cfi permissive and you'll just get a

00:30:24,399 --> 00:30:29,760
warning instead of a bug

00:30:26,240 --> 00:30:31,360
and i'll show that here in one second um

00:30:29,760 --> 00:30:33,120
and then if you're on arm you can turn

00:30:31,360 --> 00:30:34,480
on the shadow call stack as well to get

00:30:33,120 --> 00:30:36,320
the

00:30:34,480 --> 00:30:38,720
backward edge protection as well and

00:30:36,320 --> 00:30:41,919
then build your kernel like normal

00:30:38,720 --> 00:30:45,440
and enjoy uh

00:30:41,919 --> 00:30:48,159
so it's a little tricky to to do a live

00:30:45,440 --> 00:30:50,880
demo of this i tried to capture

00:30:48,159 --> 00:30:51,760
um just sort of what this what you can

00:30:50,880 --> 00:30:55,279
expect

00:30:51,760 --> 00:30:58,960
to see when uh when you fail there is

00:30:55,279 --> 00:31:02,720
a module the lkdtm module has a test

00:30:58,960 --> 00:31:05,519
for um you know doing a

00:31:02,720 --> 00:31:06,880
protocol mismatched call so you can test

00:31:05,519 --> 00:31:09,600
using lpdtm

00:31:06,880 --> 00:31:11,120
over if you have exploit handy you can

00:31:09,600 --> 00:31:13,279
try it with this

00:31:11,120 --> 00:31:14,159
but basically you get if permissive is

00:31:13,279 --> 00:31:16,399
not set you

00:31:14,159 --> 00:31:18,480
end up panicking the kernel and you get

00:31:16,399 --> 00:31:20,399
the trace back and you see the cfi check

00:31:18,480 --> 00:31:23,200
that happened and it failed

00:31:20,399 --> 00:31:24,080
that was the ud2 that i had shown

00:31:23,200 --> 00:31:25,760
earlier

00:31:24,080 --> 00:31:27,279
and if you've got permissive set on

00:31:25,760 --> 00:31:27,840
you'll just get a warning and i'll tell

00:31:27,279 --> 00:31:30,799
you

00:31:27,840 --> 00:31:31,519
precisely where it happened and get the

00:31:30,799 --> 00:31:34,559
standard

00:31:31,519 --> 00:31:36,159
call trace and as i mentioned earlier uh

00:31:34,559 --> 00:31:37,200
the shadow call stack failures are

00:31:36,159 --> 00:31:40,720
currently

00:31:37,200 --> 00:31:42,159
uh totally unreported so if you corrupt

00:31:40,720 --> 00:31:45,360
the return address on the stack it is

00:31:42,159 --> 00:31:48,159
just silently ignored

00:31:45,360 --> 00:31:49,760
so that would be perhaps nice to add but

00:31:48,159 --> 00:31:53,679
perhaps we'll end up with

00:31:49,760 --> 00:31:58,000
hardware support for for these things

00:31:53,679 --> 00:31:58,000
and we can just get rid of scs entirely

00:31:58,840 --> 00:32:03,039
um anyway i

00:32:01,039 --> 00:32:04,240
went through that pretty quick but uh if

00:32:03,039 --> 00:32:07,039
you have thoughts please

00:32:04,240 --> 00:32:08,159
reach out to me um there's another link

00:32:07,039 --> 00:32:11,760
for

00:32:08,159 --> 00:32:14,720
the slides unless you can look at

00:32:11,760 --> 00:32:16,799
skype.org and links to the kernel self

00:32:14,720 --> 00:32:19,120
protection project where we try to

00:32:16,799 --> 00:32:19,919
sort of herd cats and and get

00:32:19,120 --> 00:32:23,919
mitigations

00:32:19,919 --> 00:32:26,720
into upstream and our mailing list

00:32:23,919 --> 00:32:27,840
um anyway that's it for me i'm gonna go

00:32:26,720 --> 00:32:30,880
look at

00:32:27,840 --> 00:32:30,880
questions here for a second

00:32:36,960 --> 00:32:44,559
so i'll just do them in order

00:32:42,000 --> 00:32:44,559
kind of a lot

00:32:48,880 --> 00:32:52,399
okay so the first question is uh how to

00:32:51,120 --> 00:32:55,360
see if i deal with cases where

00:32:52,399 --> 00:32:56,240
generic function pointers are used uh

00:32:55,360 --> 00:32:59,600
sort of you know the

00:32:56,240 --> 00:33:00,720
void pointer void um so i'm

00:32:59,600 --> 00:33:02,399
if i'm understanding a question

00:33:00,720 --> 00:33:04,320
correctly it's mostly about sort of

00:33:02,399 --> 00:33:06,960
casting and passing functions

00:33:04,320 --> 00:33:08,320
uh by a void pointer and the answer is

00:33:06,960 --> 00:33:10,640
well that's

00:33:08,320 --> 00:33:11,840
that does not work with cfi and the idea

00:33:10,640 --> 00:33:14,480
is to

00:33:11,840 --> 00:33:16,880
make sure that type safety is you know

00:33:14,480 --> 00:33:19,919
being strictly adhered to

00:33:16,880 --> 00:33:21,440
on on those kinds of situations um this

00:33:19,919 --> 00:33:24,720
is what a lot of the

00:33:21,440 --> 00:33:28,000
prototype fixes are about um

00:33:24,720 --> 00:33:28,799
if you look at um probably one of the

00:33:28,000 --> 00:33:31,840
most

00:33:28,799 --> 00:33:33,519
egregious versions of this uh this is

00:33:31,840 --> 00:33:37,039
probably from about a year or so ago

00:33:33,519 --> 00:33:39,279
i did a conversion of struct timer

00:33:37,039 --> 00:33:40,480
in the kernel and it actually passed

00:33:39,279 --> 00:33:43,600
arbitrary data

00:33:40,480 --> 00:33:45,120
as an argument to a function and as an

00:33:43,600 --> 00:33:46,000
unsigned long and then would cast it

00:33:45,120 --> 00:33:48,880
back to

00:33:46,000 --> 00:33:50,320
whatever it needed at the call site um

00:33:48,880 --> 00:33:51,039
and while that's this is about argument

00:33:50,320 --> 00:33:53,600
casting

00:33:51,039 --> 00:33:55,679
the the same approach applies which is

00:33:53,600 --> 00:33:57,679
normally our callbacks are going to be

00:33:55,679 --> 00:33:59,039
typed at any given location the question

00:33:57,679 --> 00:34:01,120
is how do we

00:33:59,039 --> 00:34:03,919
verify our type all the way back to

00:34:01,120 --> 00:34:04,880
where we need to make the call

00:34:03,919 --> 00:34:09,039
hopefully that makes sense and i

00:34:04,880 --> 00:34:09,039
understood the question correctly um

00:34:12,079 --> 00:34:14,480
let's see

00:34:17,599 --> 00:34:21,040
the question is do you think that

00:34:19,679 --> 00:34:23,040
information on possible car

00:34:21,040 --> 00:34:24,800
call targets will be sufficiently good

00:34:23,040 --> 00:34:29,280
that we could statically determine

00:34:24,800 --> 00:34:33,359
maximum kernel stack usage um

00:34:29,280 --> 00:34:34,560
i don't think we can always get it but i

00:34:33,359 --> 00:34:38,960
think we could probably get

00:34:34,560 --> 00:34:42,560
pretty close uh there i mean

00:34:38,960 --> 00:34:44,240
i'm not sure uh cfi in particular gets

00:34:42,560 --> 00:34:45,440
us closer to that lto might get us

00:34:44,240 --> 00:34:48,480
closer to that

00:34:45,440 --> 00:34:50,159
um just because we get the visibility i

00:34:48,480 --> 00:34:53,119
think there's already quite a bit of

00:34:50,159 --> 00:34:53,919
research being done on the stack depth

00:34:53,119 --> 00:34:56,960
already with

00:34:53,919 --> 00:34:58,480
things like

00:34:56,960 --> 00:35:00,640
smash and other stuff that are actually

00:34:58,480 --> 00:35:02,720
doing a static analysis of

00:35:00,640 --> 00:35:04,480
of the codebase to look at call call

00:35:02,720 --> 00:35:06,800
graphs

00:35:04,480 --> 00:35:08,160
so lto might be able to assist on that

00:35:06,800 --> 00:35:10,480
but i think it's sort of a separate

00:35:08,160 --> 00:35:10,480
issue

00:35:11,040 --> 00:35:16,079
are there any plans to port some or all

00:35:13,359 --> 00:35:16,960
these options to gcc as well i would

00:35:16,079 --> 00:35:22,480
love to see it

00:35:16,960 --> 00:35:26,160
gcc does have the beginning of

00:35:22,480 --> 00:35:28,079
lto support i think um it was

00:35:26,160 --> 00:35:30,079
i know there were some patches a while

00:35:28,079 --> 00:35:32,000
back that were working on it

00:35:30,079 --> 00:35:34,480
i have not gone to look at what's

00:35:32,000 --> 00:35:38,400
happening in gcc's lto

00:35:34,480 --> 00:35:41,440
i think that if lto

00:35:38,400 --> 00:35:42,079
were in were well supported by gcc i

00:35:41,440 --> 00:35:44,560
don't think

00:35:42,079 --> 00:35:46,240
adding cfi would be too much work on top

00:35:44,560 --> 00:35:48,800
of that uh i have

00:35:46,240 --> 00:35:49,440
asked uh sort of the last couple

00:35:48,800 --> 00:35:51,920
plumbers

00:35:49,440 --> 00:35:53,200
i've sort of waved my arms uh with the

00:35:51,920 --> 00:35:55,520
gcc folks

00:35:53,200 --> 00:35:57,200
saying hey here's some stuff i'd love to

00:35:55,520 --> 00:35:58,079
see that's in clang but i don't see it

00:35:57,200 --> 00:36:01,250
yet in

00:35:58,079 --> 00:36:02,400
in gcc and vice versa um

00:36:01,250 --> 00:36:05,599
[Music]

00:36:02,400 --> 00:36:07,040
and uh yeah that's so right now there

00:36:05,599 --> 00:36:08,880
isn't but um

00:36:07,040 --> 00:36:10,839
that's okay because i can build stuff

00:36:08,880 --> 00:36:13,839
and find

00:36:10,839 --> 00:36:16,079
um question is uh

00:36:13,839 --> 00:36:17,119
how would cfi affect dynamic tracing

00:36:16,079 --> 00:36:20,880
instrumenting

00:36:17,119 --> 00:36:26,960
debugging um right now

00:36:20,880 --> 00:36:30,000
uh it's it's an interesting problem

00:36:26,960 --> 00:36:34,640
it should be entirely solvable

00:36:30,000 --> 00:36:37,280
the idea is that the

00:36:34,640 --> 00:36:40,400
the way that dynamic tracing tends to

00:36:37,280 --> 00:36:43,520
work right now is it is actually

00:36:40,400 --> 00:36:45,040
directly updating kernel text so it uses

00:36:43,520 --> 00:36:49,440
a separate page table

00:36:45,040 --> 00:36:52,480
to change the preamble on a function

00:36:49,440 --> 00:36:55,040
so those things end up being direct

00:36:52,480 --> 00:36:56,720
function calls to get out into the

00:36:55,040 --> 00:37:00,079
tracing and other things

00:36:56,720 --> 00:37:03,040
so a lot of that is

00:37:00,079 --> 00:37:05,200
should be unaffected i have not spent a

00:37:03,040 --> 00:37:07,280
lot of time looking at it though so

00:37:05,200 --> 00:37:08,720
i work work trying to play with it play

00:37:07,280 --> 00:37:10,640
with those things in combination

00:37:08,720 --> 00:37:12,000
but i do not expect there to be too much

00:37:10,640 --> 00:37:15,520
trouble with it

00:37:12,000 --> 00:37:16,960
um yeah i think that's all i can

00:37:15,520 --> 00:37:18,960
reasonably say about that there have

00:37:16,960 --> 00:37:19,920
been issues with just getting things to

00:37:18,960 --> 00:37:22,240
work together

00:37:19,920 --> 00:37:24,560
and through the know the history of cfi

00:37:22,240 --> 00:37:26,800
work i know it turned off like f trace

00:37:24,560 --> 00:37:27,760
and then turn it back on as as bugs got

00:37:26,800 --> 00:37:29,119
solved

00:37:27,760 --> 00:37:32,640
but fundamentally i don't think there's

00:37:29,119 --> 00:37:37,839
any conflict uh because of how

00:37:32,640 --> 00:37:37,839
tracing works in the kernel right now um

00:37:38,240 --> 00:37:43,440
see the next question

00:37:41,520 --> 00:37:44,640
is uh how does cfi work with the kernel

00:37:43,440 --> 00:37:46,640
module uh

00:37:44,640 --> 00:37:48,160
so i i sort of skipped that uh in the

00:37:46,640 --> 00:37:51,520
interest of time

00:37:48,160 --> 00:37:55,280
um but there is effectively

00:37:51,520 --> 00:37:58,640
every module exports a cfi check

00:37:55,280 --> 00:38:00,960
uh function so when attempting to

00:37:58,640 --> 00:38:02,160
execute code that's in a module memory

00:38:00,960 --> 00:38:04,960
area

00:38:02,160 --> 00:38:05,839
it sort of offloads it to that so

00:38:04,960 --> 00:38:07,440
there's

00:38:05,839 --> 00:38:09,760
a bit of a greater performance hit in

00:38:07,440 --> 00:38:13,280
dealing with cfi through modules

00:38:09,760 --> 00:38:15,599
um and the sort of the assembly

00:38:13,280 --> 00:38:16,400
example i gave is a little bit more

00:38:15,599 --> 00:38:19,680
complex

00:38:16,400 --> 00:38:21,440
um but as long as the other

00:38:19,680 --> 00:38:23,119
part of the question was is possible for

00:38:21,440 --> 00:38:25,760
a kernel to call a function and out of

00:38:23,119 --> 00:38:28,960
tree kernel module

00:38:25,760 --> 00:38:32,079
and it is as long as

00:38:28,960 --> 00:38:33,280
the as long as the kernel module is

00:38:32,079 --> 00:38:34,880
built with

00:38:33,280 --> 00:38:36,640
knowledge of cfi like you're building it

00:38:34,880 --> 00:38:37,520
with clang let's see if i mean you're

00:38:36,640 --> 00:38:40,240
building the same

00:38:37,520 --> 00:38:41,440
kernel configuration um that out of tree

00:38:40,240 --> 00:38:42,720
module should have all the same

00:38:41,440 --> 00:38:46,000
instrumentation

00:38:42,720 --> 00:38:47,760
um so it's it's not really any different

00:38:46,000 --> 00:38:49,359
than anything else it's it's an api like

00:38:47,760 --> 00:38:50,320
anything else in the kernel it's just a

00:38:49,359 --> 00:38:53,839
really internal

00:38:50,320 --> 00:38:53,839
api um

00:38:54,079 --> 00:38:57,440
and uh i think the other the last

00:38:56,720 --> 00:39:00,880
question

00:38:57,440 --> 00:39:04,560
was the same about uh gcc and cfi

00:39:00,880 --> 00:39:06,960
and i i would love to see some more

00:39:04,560 --> 00:39:08,800
cfi work done for gcc i think that'd be

00:39:06,960 --> 00:39:13,359
very exciting

00:39:08,800 --> 00:39:15,599
um but that's uh that's it for questions

00:39:13,359 --> 00:39:18,560
and that i've got here i think oh wait

00:39:15,599 --> 00:39:18,560
maybe there's

00:39:18,720 --> 00:39:24,400
page two of two oh no that's not it hey

00:39:21,280 --> 00:39:24,400
look more questions okay

00:39:26,839 --> 00:39:29,839
um

00:39:30,560 --> 00:39:34,480
see would it be possible to implement

00:39:32,320 --> 00:39:35,760
similar cfi without lto by emitting

00:39:34,480 --> 00:39:37,520
direct calls

00:39:35,760 --> 00:39:39,280
to an indirect call to specific type

00:39:37,520 --> 00:39:41,040
helper that is generated after the rest

00:39:39,280 --> 00:39:42,720
of the build is done

00:39:41,040 --> 00:39:44,320
probably i think it would basically be

00:39:42,720 --> 00:39:47,680
treating the entire kernel

00:39:44,320 --> 00:39:50,720
like how modules are done

00:39:47,680 --> 00:39:52,400
it i think would probably be

00:39:50,720 --> 00:39:55,520
a performance issue that the question

00:39:52,400 --> 00:39:57,599
was from jan and i know he likes to

00:39:55,520 --> 00:39:59,200
lower security problems into performance

00:39:57,599 --> 00:39:59,839
problems so perhaps that would be a way

00:39:59,200 --> 00:40:02,079
to go

00:39:59,839 --> 00:40:02,079
um

00:40:03,280 --> 00:40:06,640
the question is apart from compiler

00:40:04,640 --> 00:40:08,000
options and build options let's see if i

00:40:06,640 --> 00:40:09,680
record any of the code modifications the

00:40:08,000 --> 00:40:11,359
kernel and the answer that one is

00:40:09,680 --> 00:40:12,800
yes very much all the prototype changes

00:40:11,359 --> 00:40:13,520
that have been landing are basically

00:40:12,800 --> 00:40:17,280
about

00:40:13,520 --> 00:40:19,839
places where uh the kernel code has

00:40:17,280 --> 00:40:20,319
uh effectively tricked c into being

00:40:19,839 --> 00:40:22,079
happy

00:40:20,319 --> 00:40:23,839
with and building and then just sort of

00:40:22,079 --> 00:40:26,160
call in two functions

00:40:23,839 --> 00:40:28,480
so a lot of prototype changes have been

00:40:26,160 --> 00:40:30,000
been needed but most that is just

00:40:28,480 --> 00:40:33,760
most of that is mechanical it is

00:40:30,000 --> 00:40:33,760
refactoring code to do the right thing

00:40:35,200 --> 00:40:40,720
do i think a linux kernel can move to

00:40:37,760 --> 00:40:43,440
use clang in general due to cfi benefits

00:40:40,720 --> 00:40:43,440
already there

00:40:44,480 --> 00:40:48,480
i think i'm going to try to interpret

00:40:47,920 --> 00:40:51,599
that

00:40:48,480 --> 00:40:52,079
question as is it a good idea to move to

00:40:51,599 --> 00:40:55,520
clang

00:40:52,079 --> 00:40:58,480
in general um

00:40:55,520 --> 00:40:59,440
i think lto gives some performance

00:40:58,480 --> 00:41:02,720
benefit already

00:40:59,440 --> 00:41:05,440
um and clang already works uh

00:41:02,720 --> 00:41:07,359
with for building the kernel the the

00:41:05,440 --> 00:41:09,680
klein built linux project has been

00:41:07,359 --> 00:41:10,720
doing a ton of work to make that happen

00:41:09,680 --> 00:41:12,079
uh so

00:41:10,720 --> 00:41:15,200
i mean it's worth trying even even

00:41:12,079 --> 00:41:17,839
without cfi um

00:41:15,200 --> 00:41:19,119
question about static key entries uh

00:41:17,839 --> 00:41:20,319
there's

00:41:19,119 --> 00:41:22,319
there's basically no problem with the

00:41:20,319 --> 00:41:24,079
static key entries because

00:41:22,319 --> 00:41:25,680
what you're how that happens in the

00:41:24,079 --> 00:41:28,640
kernel is through this

00:41:25,680 --> 00:41:30,480
you know writing to kernel text and

00:41:28,640 --> 00:41:32,720
that's

00:41:30,480 --> 00:41:34,240
a completely separate function that will

00:41:32,720 --> 00:41:35,200
actually swap the permissions and write

00:41:34,240 --> 00:41:37,440
directly

00:41:35,200 --> 00:41:38,880
to the kernel text itself so there's not

00:41:37,440 --> 00:41:41,440
really any problem with

00:41:38,880 --> 00:41:43,920
static keys and those kinds of those

00:41:41,440 --> 00:41:47,040
kinds of things

00:41:43,920 --> 00:41:48,560
um question is uh

00:41:47,040 --> 00:41:50,480
what is the status and how do you see

00:41:48,560 --> 00:41:54,079
the introduction of cet in the kernel

00:41:50,480 --> 00:41:57,200
um i i think the most

00:41:54,079 --> 00:42:00,960
recent patch set i saw was for cet

00:41:57,200 --> 00:42:02,079
and user space support um that's ongoing

00:42:00,960 --> 00:42:04,400
and i think after that

00:42:02,079 --> 00:42:05,200
will be cet in the kernel that's to get

00:42:04,400 --> 00:42:09,200
the

00:42:05,200 --> 00:42:11,920
intel hardware support for the return

00:42:09,200 --> 00:42:13,119
uh the backward edge cfi protections in

00:42:11,920 --> 00:42:16,720
hardware

00:42:13,119 --> 00:42:18,319
uh i would need to to double check the

00:42:16,720 --> 00:42:19,359
status on that but i know that the user

00:42:18,319 --> 00:42:22,400
space side of that is

00:42:19,359 --> 00:42:24,560
is written and uh i

00:42:22,400 --> 00:42:26,160
think there will not be too much trouble

00:42:24,560 --> 00:42:28,640
with this in the kernel

00:42:26,160 --> 00:42:30,240
we do end up butting heads a little bit

00:42:28,640 --> 00:42:32,400
with

00:42:30,240 --> 00:42:33,730
some of the other like specter and

00:42:32,400 --> 00:42:35,599
meltdown mitigations

00:42:33,730 --> 00:42:38,960
[Music]

00:42:35,599 --> 00:42:41,040
um there's a clarification about the

00:42:38,960 --> 00:42:42,839
static key entries changing offsets uh

00:42:41,040 --> 00:42:45,119
so

00:42:42,839 --> 00:42:48,160
the changing offsets

00:42:45,119 --> 00:42:49,280
uh so trying to interpret what you're

00:42:48,160 --> 00:42:52,480
what you're asking about

00:42:49,280 --> 00:42:56,160
on that one um right now

00:42:52,480 --> 00:42:59,200
what happens in uh when cfi is

00:42:56,160 --> 00:43:02,480
like the cfi pass is basically replacing

00:42:59,200 --> 00:43:05,599
all the function pointers uh

00:43:02,480 --> 00:43:09,440
to to the to the jump table

00:43:05,599 --> 00:43:10,640
entry points um so there's in most cases

00:43:09,440 --> 00:43:13,040
this is invisible to

00:43:10,640 --> 00:43:14,960
the implementation and see all function

00:43:13,040 --> 00:43:18,000
pointers end up being

00:43:14,960 --> 00:43:19,280
pointers to the table and so for static

00:43:18,000 --> 00:43:21,839
key entries and things like that there's

00:43:19,280 --> 00:43:23,599
no issue there are exceptions

00:43:21,839 --> 00:43:25,440
where things are a little weird and

00:43:23,599 --> 00:43:26,000
those we need to take care of and a lot

00:43:25,440 --> 00:43:30,560
of that is

00:43:26,000 --> 00:43:34,160
in the cfi series that sammy's got

00:43:30,560 --> 00:43:36,160
and i have a minute and a half left

00:43:34,160 --> 00:43:38,800
i do not have a third page of questions

00:43:36,160 --> 00:43:42,079
so i'm

00:43:38,800 --> 00:43:44,800
i think i am done there

00:43:42,079 --> 00:43:46,480
thanks everyone for coming and asking

00:43:44,800 --> 00:43:55,839
questions

00:43:46,480 --> 00:43:55,839
and uh that's it for me thanks

00:44:45,359 --> 00:44:47,440

YouTube URL: https://www.youtube.com/watch?v=IMMlpVUGD5M


