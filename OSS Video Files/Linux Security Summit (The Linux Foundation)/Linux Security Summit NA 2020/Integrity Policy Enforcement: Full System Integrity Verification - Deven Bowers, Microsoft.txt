Title: Integrity Policy Enforcement: Full System Integrity Verification - Deven Bowers, Microsoft
Publication date: 2020-09-08
Playlist: Linux Security Summit NA 2020
Description: 
	Integrity Policy Enforcement: Full System Integrity Verification - Deven Bowers, Microsoft
Captions: 
	00:00:05,279 --> 00:00:09,280
hello my name is devin bowers

00:00:07,120 --> 00:00:11,120
i'm a software engineer at microsoft and

00:00:09,280 --> 00:00:14,480
i've worked on code integrity systems

00:00:11,120 --> 00:00:16,400
and windows since i graduated in 2017

00:00:14,480 --> 00:00:18,480
and started linux kernel development

00:00:16,400 --> 00:00:20,720
since this past october

00:00:18,480 --> 00:00:21,520
i am here to present on integrity policy

00:00:20,720 --> 00:00:24,080
enforcement

00:00:21,520 --> 00:00:25,439
otherwise known as ipe an upcoming lsm

00:00:24,080 --> 00:00:26,240
which seeks to solve the problem of code

00:00:25,439 --> 00:00:29,199
integrity

00:00:26,240 --> 00:00:30,000
i'll also be explaining how ipe can be

00:00:29,199 --> 00:00:32,160
used to achieve

00:00:30,000 --> 00:00:34,640
full system verification for lockdown

00:00:32,160 --> 00:00:34,640
systems

00:00:34,800 --> 00:00:38,000
initially i'm going to talk about the

00:00:36,399 --> 00:00:40,480
motivation for ipe

00:00:38,000 --> 00:00:41,280
why we thought a new osm was necessary

00:00:40,480 --> 00:00:44,079
why existing

00:00:41,280 --> 00:00:45,840
implementations cannot be extended this

00:00:44,079 --> 00:00:47,440
will be followed by a brief introduction

00:00:45,840 --> 00:00:49,120
to the design of ipe

00:00:47,440 --> 00:00:50,559
as well as complications that came up

00:00:49,120 --> 00:00:52,719
during the development and have some of

00:00:50,559 --> 00:00:54,640
these complications were addressed

00:00:52,719 --> 00:00:56,320
i'll finish up with the 20 minute demo

00:00:54,640 --> 00:01:00,160
and a few comments on our

00:00:56,320 --> 00:01:02,000
plans for future work on ipe

00:01:00,160 --> 00:01:03,440
before we get started i just wanted to

00:01:02,000 --> 00:01:05,439
give a shout out to these people who

00:01:03,440 --> 00:01:07,280
participated in the design of ip

00:01:05,439 --> 00:01:08,960
from the beginning or gave a large

00:01:07,280 --> 00:01:10,799
portion of their time to review the

00:01:08,960 --> 00:01:12,560
early drafts of ite

00:01:10,799 --> 00:01:14,479
as well as teach me some of the nuances

00:01:12,560 --> 00:01:16,560
of linux kernel development

00:01:14,479 --> 00:01:18,479
also a special shout out to josh garan

00:01:16,560 --> 00:01:21,360
karana otherwise known as jk

00:01:18,479 --> 00:01:22,400
who pioneered the initial versions of

00:01:21,360 --> 00:01:24,479
ipe

00:01:22,400 --> 00:01:27,040
as well as laid much of the groundwork

00:01:24,479 --> 00:01:29,119
for what we have today

00:01:27,040 --> 00:01:31,439
so quickly going over the basics of code

00:01:29,119 --> 00:01:33,119
integrity code integrity is the concept

00:01:31,439 --> 00:01:36,000
that code hasn't been tampered with

00:01:33,119 --> 00:01:37,280
and transition between its source be it

00:01:36,000 --> 00:01:39,680
a build machine or

00:01:37,280 --> 00:01:41,439
distributed by an application developer

00:01:39,680 --> 00:01:43,360
and it's execution

00:01:41,439 --> 00:01:44,479
in other words files are guaranteed to

00:01:43,360 --> 00:01:46,479
be identical to

00:01:44,479 --> 00:01:48,240
where those files are built this is a

00:01:46,479 --> 00:01:49,600
wonderful property of defeating a lot of

00:01:48,240 --> 00:01:53,280
low effort attacks like

00:01:49,600 --> 00:01:55,759
power being directly executed ld preload

00:01:53,280 --> 00:01:57,119
tampering with a binary or even p trace

00:01:55,759 --> 00:01:58,560
attacks

00:01:57,119 --> 00:02:00,399
additionally this concept can be

00:01:58,560 --> 00:02:00,880
generalized to more than just executable

00:02:00,399 --> 00:02:02,560
code

00:02:00,880 --> 00:02:04,640
it can be applied to high value files

00:02:02,560 --> 00:02:06,840
like configuration files

00:02:04,640 --> 00:02:08,640
that could be vulnerable to file system

00:02:06,840 --> 00:02:11,200
attacks

00:02:08,640 --> 00:02:11,920
so how do ci and mac interact with each

00:02:11,200 --> 00:02:14,239
other

00:02:11,920 --> 00:02:15,680
well ci performs a complementary

00:02:14,239 --> 00:02:18,239
function to mac

00:02:15,680 --> 00:02:19,280
mac systems require file metadata to

00:02:18,239 --> 00:02:21,280
make their decisions

00:02:19,280 --> 00:02:22,480
this implies that they have a dependency

00:02:21,280 --> 00:02:25,599
on that file's

00:02:22,480 --> 00:02:27,680
metadata not being altered ci

00:02:25,599 --> 00:02:29,360
in theory fulfills this dependency by

00:02:27,680 --> 00:02:31,519
enforcing file integrity

00:02:29,360 --> 00:02:33,280
encompassing the entirety of the file

00:02:31,519 --> 00:02:35,680
including metadata

00:02:33,280 --> 00:02:36,400
in other words ci provides the integrity

00:02:35,680 --> 00:02:39,680
that mac

00:02:36,400 --> 00:02:40,319
assumes so let's design a lock down

00:02:39,680 --> 00:02:42,000
system

00:02:40,319 --> 00:02:43,680
starting at the bottom layer we're going

00:02:42,000 --> 00:02:45,680
to protect the kernel and the boot

00:02:43,680 --> 00:02:48,400
loader through a verified boot solution

00:02:45,680 --> 00:02:49,360
something like ubu verify boot or secure

00:02:48,400 --> 00:02:51,360
boot

00:02:49,360 --> 00:02:54,080
we can also add in the kernel lockdown

00:02:51,360 --> 00:02:54,879
osm as well as lkrg for some additional

00:02:54,080 --> 00:02:57,120
hardening

00:02:54,879 --> 00:02:58,879
after that we move a bit up the stack

00:02:57,120 --> 00:03:01,599
and we'll select a way to measure and

00:02:58,879 --> 00:03:02,319
test the state of the device the natural

00:03:01,599 --> 00:03:05,599
choice here

00:03:02,319 --> 00:03:07,680
is ima now at our final layer

00:03:05,599 --> 00:03:09,360
we need to select a mac system to

00:03:07,680 --> 00:03:10,159
encompass the security policy for the

00:03:09,360 --> 00:03:12,720
whole device

00:03:10,159 --> 00:03:13,760
in a ci system to ensure that mac

00:03:12,720 --> 00:03:16,400
functions

00:03:13,760 --> 00:03:17,200
correctly we have many options for mac

00:03:16,400 --> 00:03:20,640
we have

00:03:17,200 --> 00:03:23,920
app armor sc linux etc for ci

00:03:20,640 --> 00:03:24,879
all we have is ima additionally we could

00:03:23,920 --> 00:03:26,560
lock out the

00:03:24,879 --> 00:03:28,879
lock down the file system a bit more at

00:03:26,560 --> 00:03:30,000
the file system layer through fs verity

00:03:28,879 --> 00:03:32,239
dm very or

00:03:30,000 --> 00:03:33,519
authenticated brtfs which provide a

00:03:32,239 --> 00:03:36,640
measure of their

00:03:33,519 --> 00:03:40,000
integrity verification

00:03:36,640 --> 00:03:41,760
so why not use ima ima selects its files

00:03:40,000 --> 00:03:42,640
through metadata and verifies the

00:03:41,760 --> 00:03:45,200
content

00:03:42,640 --> 00:03:47,120
not the metadata of the file if we're

00:03:45,200 --> 00:03:50,080
trying to get around the ci block

00:03:47,120 --> 00:03:51,840
easy solution we offline mount the file

00:03:50,080 --> 00:03:52,400
changed the metadata to bypass the

00:03:51,840 --> 00:03:55,519
policy

00:03:52,400 --> 00:03:57,120
and we've now pwned the ci system ima

00:03:55,519 --> 00:03:58,400
solved this problem through extended

00:03:57,120 --> 00:04:01,439
verification module

00:03:58,400 --> 00:04:03,200
otherwise known as evm avm introduces

00:04:01,439 --> 00:04:05,439
additional metadata to secure the

00:04:03,200 --> 00:04:07,439
metadata of that file

00:04:05,439 --> 00:04:08,879
the issue here is what happens when we

00:04:07,439 --> 00:04:11,280
offline mount the file

00:04:08,879 --> 00:04:12,159
change the evm metadata and then change

00:04:11,280 --> 00:04:14,720
the ima

00:04:12,159 --> 00:04:15,519
metadata the obvious solution here is we

00:04:14,720 --> 00:04:17,359
just appraise

00:04:15,519 --> 00:04:19,440
everything assuming we care about

00:04:17,359 --> 00:04:21,199
enforcing integrity checking and reads

00:04:19,440 --> 00:04:22,720
that isn't realistic there's going to be

00:04:21,199 --> 00:04:24,720
some subset of files that are not

00:04:22,720 --> 00:04:26,479
integrity checked to the very nature

00:04:24,720 --> 00:04:28,000
of those files making it impossible to

00:04:26,479 --> 00:04:30,800
fix values do

00:04:28,000 --> 00:04:31,680
logs for example the more glaring

00:04:30,800 --> 00:04:33,040
problem here

00:04:31,680 --> 00:04:35,040
is that it introduces a circular

00:04:33,040 --> 00:04:37,680
dependency with the mac system

00:04:35,040 --> 00:04:40,400
ci is assuming metadata from mac and mac

00:04:37,680 --> 00:04:43,680
is assuming file integrity from ci

00:04:40,400 --> 00:04:44,160
this falls apart quickly on top of

00:04:43,680 --> 00:04:46,320
direct

00:04:44,160 --> 00:04:48,000
metadata attacks can we really predict

00:04:46,320 --> 00:04:50,080
the number of ways an attacker can

00:04:48,000 --> 00:04:51,440
manipulate the file system to change the

00:04:50,080 --> 00:04:53,199
metadata

00:04:51,440 --> 00:04:55,040
bind mounts over files with the required

00:04:53,199 --> 00:04:57,840
metadata to skip policy

00:04:55,040 --> 00:04:59,759
hard links in general the file system is

00:04:57,840 --> 00:05:00,320
a very fragile thing controlled by user

00:04:59,759 --> 00:05:02,000
land

00:05:00,320 --> 00:05:04,479
we really can't trust it to make any

00:05:02,000 --> 00:05:05,919
decisions and also what about memory

00:05:04,479 --> 00:05:08,479
attacks

00:05:05,919 --> 00:05:10,320
and map read write and protect execute

00:05:08,479 --> 00:05:12,400
would be completely uncaught by ma

00:05:10,320 --> 00:05:14,320
you do that fairly easily what about

00:05:12,400 --> 00:05:15,840
anonymous memory

00:05:14,320 --> 00:05:18,880
these kinds of attacks have been

00:05:15,840 --> 00:05:21,440
completely untested

00:05:18,880 --> 00:05:23,840
so can we do better the file system is

00:05:21,440 --> 00:05:26,000
scary so can we remove it as a factor in

00:05:23,840 --> 00:05:27,919
evaluating what's allowed to run

00:05:26,000 --> 00:05:29,199
can we remove control from userland to

00:05:27,919 --> 00:05:32,160
manipulate the output

00:05:29,199 --> 00:05:34,160
of the policy finally there's so much

00:05:32,160 --> 00:05:35,280
existing work with integrity systems in

00:05:34,160 --> 00:05:37,919
the kernel already

00:05:35,280 --> 00:05:38,639
can we just use one or all of them for

00:05:37,919 --> 00:05:42,479
the way we

00:05:38,639 --> 00:05:42,479
check the integrity of the system

00:05:42,639 --> 00:05:47,280
this leads us to the core design goals

00:05:44,639 --> 00:05:49,919
of ip enforcing user-defined

00:05:47,280 --> 00:05:52,000
system integrity requirements separating

00:05:49,919 --> 00:05:54,720
integrity mechanisms from the policy

00:05:52,000 --> 00:05:56,319
mechanism removing the dependency on

00:05:54,720 --> 00:05:58,800
file system metadata

00:05:56,319 --> 00:06:02,319
and enforcing a hard security boundary

00:05:58,800 --> 00:06:05,199
between user space and kernel space

00:06:02,319 --> 00:06:07,360
the goal of the customizable integrity

00:06:05,199 --> 00:06:10,080
requirements leads us to a policy

00:06:07,360 --> 00:06:11,759
someone makes a good policy ideally a

00:06:10,080 --> 00:06:13,360
policy is intuitive

00:06:11,759 --> 00:06:15,520
people should be able to understand it

00:06:13,360 --> 00:06:16,000
without looking up technical terms or

00:06:15,520 --> 00:06:18,400
being

00:06:16,000 --> 00:06:19,520
extremely nuanced about a specific

00:06:18,400 --> 00:06:21,520
system

00:06:19,520 --> 00:06:22,960
the second requirement is that a policy

00:06:21,520 --> 00:06:25,600
should be diagnosable

00:06:22,960 --> 00:06:26,479
when a policy goes wrong a lay person

00:06:25,600 --> 00:06:28,240
should be able to

00:06:26,479 --> 00:06:30,479
diagnose the issue without requiring a

00:06:28,240 --> 00:06:31,440
developer or an expert in the system

00:06:30,479 --> 00:06:33,600
itself

00:06:31,440 --> 00:06:35,360
in simple terms it shouldn't require a

00:06:33,600 --> 00:06:37,840
phd or a specialization

00:06:35,360 --> 00:06:41,520
to understand and utilize a policy

00:06:37,840 --> 00:06:41,520
unlike web development and assembly

00:06:41,759 --> 00:06:45,360
to achieve an intuitive policy there

00:06:43,759 --> 00:06:46,560
needs to be a few obvious

00:06:45,360 --> 00:06:48,000
characteristics

00:06:46,560 --> 00:06:49,680
the policy language needed to be

00:06:48,000 --> 00:06:51,440
simplistic and easy to read

00:06:49,680 --> 00:06:53,440
so we decided pretty quickly that the

00:06:51,440 --> 00:06:54,319
policy should be interpreted from top to

00:06:53,440 --> 00:06:56,400
bottom

00:06:54,319 --> 00:06:57,360
use the new line to delimit roles in the

00:06:56,400 --> 00:06:59,360
policy

00:06:57,360 --> 00:07:01,520
and use key equal value syntax for the

00:06:59,360 --> 00:07:04,560
individual items within our rules

00:07:01,520 --> 00:07:06,960
the next choice was how to abstract

00:07:04,560 --> 00:07:08,880
the policy rules for the end user to

00:07:06,960 --> 00:07:10,319
establish control over the kernel in a

00:07:08,880 --> 00:07:13,280
simple way

00:07:10,319 --> 00:07:15,360
initially we considered using the lsm

00:07:13,280 --> 00:07:17,440
hooks as the operation to be controlled

00:07:15,360 --> 00:07:19,440
however we discarded this for fear that

00:07:17,440 --> 00:07:22,560
it would become too complicated

00:07:19,440 --> 00:07:23,680
for an average admin to understand with

00:07:22,560 --> 00:07:25,680
all the nuances

00:07:23,680 --> 00:07:27,360
within the kernel it also had the

00:07:25,680 --> 00:07:29,759
drawbacks for the future

00:07:27,360 --> 00:07:31,360
if some system call that allowed

00:07:29,759 --> 00:07:32,160
execution in a different hook than we

00:07:31,360 --> 00:07:33,840
expect

00:07:32,160 --> 00:07:36,080
then policies would need to be updated

00:07:33,840 --> 00:07:38,000
to handle the new kernel functionality

00:07:36,080 --> 00:07:39,520
to this end we decided to go with the

00:07:38,000 --> 00:07:42,240
logical mapping

00:07:39,520 --> 00:07:44,319
what we intuitively expect to control in

00:07:42,240 --> 00:07:45,840
this case execution which could

00:07:44,319 --> 00:07:48,800
potentially come through

00:07:45,840 --> 00:07:49,120
and map with execute permissions exec ve

00:07:48,800 --> 00:07:51,840
or

00:07:49,120 --> 00:07:54,720
and protect with execute permissions or

00:07:51,840 --> 00:07:56,800
whatever comes to the future

00:07:54,720 --> 00:07:58,000
the next choice for the policy was what

00:07:56,800 --> 00:08:00,479
should it do if no

00:07:58,000 --> 00:08:01,440
rules match it's nearly impossible to

00:08:00,479 --> 00:08:03,360
write a policy

00:08:01,440 --> 00:08:05,599
so exhaustive that it covers the whole

00:08:03,360 --> 00:08:07,440
system so this is important

00:08:05,599 --> 00:08:09,440
we did a draft for a deny by default

00:08:07,440 --> 00:08:12,240
which was great for execution rules

00:08:09,440 --> 00:08:14,160
as this encompasses the entire system

00:08:12,240 --> 00:08:15,360
but the rules were confusing to author

00:08:14,160 --> 00:08:17,520
for other scenarios

00:08:15,360 --> 00:08:20,000
like enforcing reads of verified files

00:08:17,520 --> 00:08:22,000
for specific cases

00:08:20,000 --> 00:08:23,039
the next attempt we had was the inverse

00:08:22,000 --> 00:08:24,720
allowed by default

00:08:23,039 --> 00:08:26,879
this was great for the verified read

00:08:24,720 --> 00:08:29,840
scenario but it felt a bit

00:08:26,879 --> 00:08:30,960
short in the execution space so from

00:08:29,840 --> 00:08:33,839
there we decided

00:08:30,960 --> 00:08:36,080
i decided to borrow a bit from pep20

00:08:33,839 --> 00:08:38,719
explicit is better than implicit

00:08:36,080 --> 00:08:40,479
and have a user specified default based

00:08:38,719 --> 00:08:42,800
on logical mapping

00:08:40,479 --> 00:08:43,760
this made intuitive sense based on what

00:08:42,800 --> 00:08:47,680
the policy was

00:08:43,760 --> 00:08:49,680
trying to achieve so our next

00:08:47,680 --> 00:08:51,600
requirement the ability to diagnose

00:08:49,680 --> 00:08:52,399
policies we had plenty of experience to

00:08:51,600 --> 00:08:54,720
draw from

00:08:52,399 --> 00:08:56,320
the other members of my team i microsoft

00:08:54,720 --> 00:08:57,680
work on the windows side of ci

00:08:56,320 --> 00:08:59,360
and we have had plenty of problems

00:08:57,680 --> 00:09:02,080
because windows ci problem

00:08:59,360 --> 00:09:04,080
policy is not diagnosable the reason why

00:09:02,080 --> 00:09:05,360
it's not diagnosable tends to track

00:09:04,080 --> 00:09:07,519
back to the decision to use the

00:09:05,360 --> 00:09:09,279
intermediary binary format

00:09:07,519 --> 00:09:11,279
was cut down on the parsing code in the

00:09:09,279 --> 00:09:12,800
kernel this decision

00:09:11,279 --> 00:09:14,640
led to several things requiring the

00:09:12,800 --> 00:09:16,800
maintenance of a serializer

00:09:14,640 --> 00:09:17,760
the binary format could change between

00:09:16,800 --> 00:09:19,760
versions

00:09:17,760 --> 00:09:21,040
additionally there is no deserializer

00:09:19,760 --> 00:09:22,320
because some of the information is

00:09:21,040 --> 00:09:24,480
stripped away

00:09:22,320 --> 00:09:26,000
what's serialized may not match the

00:09:24,480 --> 00:09:28,000
original policy

00:09:26,000 --> 00:09:30,160
all of this leads to the ability for

00:09:28,000 --> 00:09:32,480
people to perform self-service diagnosis

00:09:30,160 --> 00:09:34,160
of policies

00:09:32,480 --> 00:09:36,240
so learning from our past mistakes we

00:09:34,160 --> 00:09:38,160
chose to pursue a plain text policy

00:09:36,240 --> 00:09:38,800
removing an intermediary format this

00:09:38,160 --> 00:09:41,200
addresses

00:09:38,800 --> 00:09:43,279
all of the larger issues found in our

00:09:41,200 --> 00:09:44,959
study of windows ci policy but has a few

00:09:43,279 --> 00:09:46,800
drawbacks

00:09:44,959 --> 00:09:48,880
authoring has less guardrails as the

00:09:46,800 --> 00:09:50,560
serializer can catch some mistakes and

00:09:48,880 --> 00:09:52,320
output them to the enemy user

00:09:50,560 --> 00:09:55,360
and ultimately because it is a giant

00:09:52,320 --> 00:09:56,720
string it has a larger memory footprint

00:09:55,360 --> 00:09:58,959
the other thing we considered from a

00:09:56,720 --> 00:10:00,880
diagnosis standpoint is the actual

00:09:58,959 --> 00:10:02,839
evaluation of a policy

00:10:00,880 --> 00:10:04,000
one choice would be to read in the full

00:10:02,839 --> 00:10:05,920
policy

00:10:04,000 --> 00:10:07,360
optimize the policy and then evaluate

00:10:05,920 --> 00:10:09,600
against the optimized policy

00:10:07,360 --> 00:10:11,279
this was not chosen because it results

00:10:09,600 --> 00:10:13,440
in difficult debugging

00:10:11,279 --> 00:10:14,480
rules may not be evaluated consistently

00:10:13,440 --> 00:10:16,800
and it could be

00:10:14,480 --> 00:10:18,240
a victim of optimization logic which is

00:10:16,800 --> 00:10:21,360
its own class of bugs

00:10:18,240 --> 00:10:22,720
in code today instead we decided to

00:10:21,360 --> 00:10:25,040
evaluate as is

00:10:22,720 --> 00:10:26,160
it prevents a certain order of opera

00:10:25,040 --> 00:10:28,640
optimizations

00:10:26,160 --> 00:10:30,399
as we cannot reorder rules but it's easy

00:10:28,640 --> 00:10:31,440
for a human to understand and debug the

00:10:30,399 --> 00:10:33,279
policies

00:10:31,440 --> 00:10:36,160
as authoring policies tends to be the

00:10:33,279 --> 00:10:38,320
optimizing factor

00:10:36,160 --> 00:10:40,399
so when we put all of our design

00:10:38,320 --> 00:10:42,240
decisions together we get a policy that

00:10:40,399 --> 00:10:44,399
looks a bit like this

00:10:42,240 --> 00:10:46,320
this is a theoretical example policy

00:10:44,399 --> 00:10:46,880
that may be typical for a lockdown

00:10:46,320 --> 00:10:48,399
system

00:10:46,880 --> 00:10:50,560
that wants to control all of its

00:10:48,399 --> 00:10:54,480
execution and a subset of reads that

00:10:50,560 --> 00:10:54,480
must resolve to a verified file

00:10:56,560 --> 00:11:01,279
our second goal for ipe was to divorce

00:10:59,040 --> 00:11:03,120
mechanism from policy

00:11:01,279 --> 00:11:04,800
there are several good systems within

00:11:03,120 --> 00:11:06,880
the kernel that can be extended

00:11:04,800 --> 00:11:10,240
with minimal effort to provide some

00:11:06,880 --> 00:11:12,720
assurances of integrity

00:11:10,240 --> 00:11:14,079
so what makes a good integrity mechanism

00:11:12,720 --> 00:11:16,079
well it's not controllable

00:11:14,079 --> 00:11:17,680
by user land if that's possible then

00:11:16,079 --> 00:11:18,959
what's the actual security value in the

00:11:17,680 --> 00:11:20,720
first place

00:11:18,959 --> 00:11:22,240
secondly the mechanism should be

00:11:20,720 --> 00:11:23,920
deterministic

00:11:22,240 --> 00:11:25,360
the value resolved by the integrity

00:11:23,920 --> 00:11:28,160
mechanism should not change

00:11:25,360 --> 00:11:28,959
between different evaluations finally as

00:11:28,160 --> 00:11:30,880
a stretch

00:11:28,959 --> 00:11:33,279
it ideally captures the life of an

00:11:30,880 --> 00:11:35,360
application while an application runs it

00:11:33,279 --> 00:11:37,760
can do a lot of sketchy things

00:11:35,360 --> 00:11:39,279
i've seen binaries download an arbitrary

00:11:37,760 --> 00:11:41,680
shared library off the internet and try

00:11:39,279 --> 00:11:43,519
to use dll open or execute it

00:11:41,680 --> 00:11:45,200
i've seen a shared library being

00:11:43,519 --> 00:11:47,440
executed from a data section

00:11:45,200 --> 00:11:49,320
in fact this is the solution is the

00:11:47,440 --> 00:11:51,440
highest upvoted response to a

00:11:49,320 --> 00:11:54,079
cross-platform.net assembly that calls a

00:11:51,440 --> 00:11:56,639
native binary on stack overflow

00:11:54,079 --> 00:11:58,000
i've also seen a library that sprays an

00:11:56,639 --> 00:11:59,920
executable code fragment

00:11:58,000 --> 00:12:01,680
and attempt to map it into an executable

00:11:59,920 --> 00:12:03,920
page and execute it

00:12:01,680 --> 00:12:05,920
the point is if your integrity mechanism

00:12:03,920 --> 00:12:08,399
can capture a lifetime of

00:12:05,920 --> 00:12:10,240
normal usage of the application then all

00:12:08,399 --> 00:12:11,760
of these should be caught

00:12:10,240 --> 00:12:13,839
some examples of good integrity

00:12:11,760 --> 00:12:17,360
mechanisms are gm verity

00:12:13,839 --> 00:12:19,600
fsverity authenticated brtfs

00:12:17,360 --> 00:12:22,560
as all of these would at least fulfill

00:12:19,600 --> 00:12:25,040
the first two bullets

00:12:22,560 --> 00:12:25,600
in ip's first patch set we support dm

00:12:25,040 --> 00:12:28,480
verity

00:12:25,600 --> 00:12:29,440
as an integrity mechanism the tl dr of

00:12:28,480 --> 00:12:31,760
dm verity

00:12:29,440 --> 00:12:33,839
is that files are verified by a merkle

00:12:31,760 --> 00:12:34,560
tree corruption or tampering will cause

00:12:33,839 --> 00:12:37,680
the block to

00:12:34,560 --> 00:12:39,920
fail to be read for ips purposes dm

00:12:37,680 --> 00:12:42,639
verity creates a block device

00:12:39,920 --> 00:12:44,639
structure that's resident in the kernel

00:12:42,639 --> 00:12:47,120
integration with ip is simple

00:12:44,639 --> 00:12:48,880
we store some info and a security blob

00:12:47,120 --> 00:12:50,959
on the block device structure

00:12:48,880 --> 00:12:53,600
and we check it later with ip in the

00:12:50,959 --> 00:12:54,959
correct hook

00:12:53,600 --> 00:12:58,079
now that we're done with all the

00:12:54,959 --> 00:12:59,600
supporting factors of ipe

00:12:58,079 --> 00:13:01,120
i'm going to go into the two major

00:12:59,600 --> 00:13:04,320
aspects of ip

00:13:01,120 --> 00:13:08,560
itself the policy loading mechanism and

00:13:04,320 --> 00:13:10,880
the evaluate policy evaluation mechanism

00:13:08,560 --> 00:13:12,079
policy loading is an ipe is

00:13:10,880 --> 00:13:14,000
straightforward

00:13:12,079 --> 00:13:16,000
the policy must be signed to establish

00:13:14,000 --> 00:13:17,920
the root of trust to the system trusted

00:13:16,000 --> 00:13:19,760
key ring or else it would be trivial for

00:13:17,920 --> 00:13:22,160
an attacker to deploy a policy to

00:13:19,760 --> 00:13:24,880
undermine the security of the device

00:13:22,160 --> 00:13:26,800
this key ring is special as a key ring

00:13:24,880 --> 00:13:28,160
that is compiled into the kernel

00:13:26,800 --> 00:13:30,880
and cannot be modified without

00:13:28,160 --> 00:13:34,160
rebuilding the entirety of the kernel

00:13:30,880 --> 00:13:36,160
ipe uses the pkcs7 assigned a data

00:13:34,160 --> 00:13:38,480
format which encompasses both the policy

00:13:36,160 --> 00:13:40,560
and the signature in one convenient blob

00:13:38,480 --> 00:13:43,279
this blob is written to security fs

00:13:40,560 --> 00:13:45,839
which causes ip to polish the policy

00:13:43,279 --> 00:13:48,639
ife parses the policy line by line

00:13:45,839 --> 00:13:50,639
tokenizing it to key equals value pairs

00:13:48,639 --> 00:13:52,480
ip looks up the key against the red

00:13:50,639 --> 00:13:55,519
black tree registered mechanisms

00:13:52,480 --> 00:13:58,000
also known as properties this key entry

00:13:55,519 --> 00:13:58,560
is a structure of function pointers a

00:13:58,000 --> 00:14:00,560
version

00:13:58,560 --> 00:14:02,160
and a name one of those function

00:14:00,560 --> 00:14:04,240
pointers is a parse function which

00:14:02,160 --> 00:14:05,360
accepts the value half of the key equals

00:14:04,240 --> 00:14:08,880
value pair

00:14:05,360 --> 00:14:09,680
and stores that in an opaque void start

00:14:08,880 --> 00:14:12,079
pointer

00:14:09,680 --> 00:14:12,800
if the parse function returns success ip

00:14:12,079 --> 00:14:15,360
continues

00:14:12,800 --> 00:14:16,880
or else it exits early and terminates

00:14:15,360 --> 00:14:19,440
the parsing

00:14:16,880 --> 00:14:21,600
on success ipe stores the policy in the

00:14:19,440 --> 00:14:23,600
private section of the inode of the new

00:14:21,600 --> 00:14:25,440
security fs entry for the policy where

00:14:23,600 --> 00:14:27,760
it lies in kernel space

00:14:25,440 --> 00:14:31,760
inactive until the policy is activated

00:14:27,760 --> 00:14:33,920
as the active policy through sysfs

00:14:31,760 --> 00:14:35,839
evaluation is very similar to the

00:14:33,920 --> 00:14:38,160
parsing function

00:14:35,839 --> 00:14:39,040
all of these calls funnel into the lsm

00:14:38,160 --> 00:14:42,000
hook which i

00:14:39,040 --> 00:14:43,920
calls ipe process event this iterates

00:14:42,000 --> 00:14:46,160
over the policy where a reference to

00:14:43,920 --> 00:14:49,680
each mechanism's registry

00:14:46,160 --> 00:14:50,720
is stored ip calls the mechanisms

00:14:49,680 --> 00:14:52,720
evaluate function

00:14:50,720 --> 00:14:54,000
passing the file pointer to its

00:14:52,720 --> 00:14:56,240
mechanism

00:14:54,000 --> 00:14:58,480
if all the mechanisms of a rule match

00:14:56,240 --> 00:14:59,040
then it short circuits and returns the

00:14:58,480 --> 00:15:01,519
action

00:14:59,040 --> 00:15:02,399
property otherwise it continues on to

00:15:01,519 --> 00:15:04,399
the next role

00:15:02,399 --> 00:15:06,240
until a match occurs or until runs out

00:15:04,399 --> 00:15:08,720
of rules at which point it falls back to

00:15:06,240 --> 00:15:08,720
the default

00:15:09,600 --> 00:15:13,839
we came into a bunch of challenges with

00:15:11,519 --> 00:15:15,680
ip across its development

00:15:13,839 --> 00:15:18,240
the first issue we came across was the

00:15:15,680 --> 00:15:20,639
authorization of internet ram fs

00:15:18,240 --> 00:15:21,519
initiative fs is obviously not at the

00:15:20,639 --> 00:15:23,600
enverity volume

00:15:21,519 --> 00:15:25,360
but it is typically verified as part of

00:15:23,600 --> 00:15:28,160
a verified boot stack

00:15:25,360 --> 00:15:30,000
to that end we created our own mechanism

00:15:28,160 --> 00:15:31,600
based on the tested implementation of

00:15:30,000 --> 00:15:33,680
the load pin lsm

00:15:31,600 --> 00:15:35,759
which caused the first mounted super

00:15:33,680 --> 00:15:37,519
block that executed something to be

00:15:35,759 --> 00:15:39,279
authorized

00:15:37,519 --> 00:15:41,199
and then when this superblock is

00:15:39,279 --> 00:15:43,120
unmounted then nothing else can be

00:15:41,199 --> 00:15:45,680
authorized by the logic

00:15:43,120 --> 00:15:48,000
as enablemfs is the first mounted super

00:15:45,680 --> 00:15:50,639
block this all works out the system just

00:15:48,000 --> 00:15:51,360
needs to remember to unmount in a ram fs

00:15:50,639 --> 00:15:54,480
to prevent

00:15:51,360 --> 00:15:55,360
writing to that authorized location the

00:15:54,480 --> 00:15:58,079
second problem

00:15:55,360 --> 00:15:59,839
that came up was map anonymous anonymous

00:15:58,079 --> 00:16:02,079
memory is inherently incapable of being

00:15:59,839 --> 00:16:03,920
integrity verified

00:16:02,079 --> 00:16:05,759
because it cannot trace back to anything

00:16:03,920 --> 00:16:07,040
with a backing that could be used to

00:16:05,759 --> 00:16:08,880
establish

00:16:07,040 --> 00:16:10,639
the trust of its data but there are

00:16:08,880 --> 00:16:12,399
valid uses of it

00:16:10,639 --> 00:16:14,880
one such valid use is dynamic code

00:16:12,399 --> 00:16:16,000
generation used primarily in two places

00:16:14,880 --> 00:16:17,600
we were concerned about

00:16:16,000 --> 00:16:19,759
the first was foreign function

00:16:17,600 --> 00:16:21,440
invocation which is used in almost every

00:16:19,759 --> 00:16:23,120
language in today's systems

00:16:21,440 --> 00:16:25,040
when calling from one language to

00:16:23,120 --> 00:16:27,040
another lib ffi

00:16:25,040 --> 00:16:29,759
accomplishes this by creating a

00:16:27,040 --> 00:16:32,000
trampoline to the destination library

00:16:29,759 --> 00:16:32,880
which it first attempts to do by mapping

00:16:32,000 --> 00:16:34,880
the region

00:16:32,880 --> 00:16:36,240
of anonymous memory with write

00:16:34,880 --> 00:16:39,199
permissions and then filling in the

00:16:36,240 --> 00:16:41,120
trampoline and then marking it execute

00:16:39,199 --> 00:16:42,720
if we have our mac system with no exact

00:16:41,120 --> 00:16:45,680
mem this will fail because

00:16:42,720 --> 00:16:46,399
right memory can never be marked execute

00:16:45,680 --> 00:16:48,160
additionally

00:16:46,399 --> 00:16:49,440
it'd fail an ipe because there'd be no

00:16:48,160 --> 00:16:51,680
file backing

00:16:49,440 --> 00:16:53,519
when that fails the ffi attempts to

00:16:51,680 --> 00:16:54,480
write an executal code fragment to the

00:16:53,519 --> 00:16:57,600
system

00:16:54,480 --> 00:16:59,279
then map the file as execute this fails

00:16:57,600 --> 00:17:00,800
an ip as it doesn't trace back to

00:16:59,279 --> 00:17:02,800
anything verified

00:17:00,800 --> 00:17:04,000
as cross language calling is a pretty

00:17:02,800 --> 00:17:06,400
desirable feature to

00:17:04,000 --> 00:17:07,600
any developer we're looking at

00:17:06,400 --> 00:17:10,799
addressing this problem through a

00:17:07,600 --> 00:17:13,280
separate series of patches to the kernel

00:17:10,799 --> 00:17:14,559
another point of mention is gcc closures

00:17:13,280 --> 00:17:16,839
which require the same form of

00:17:14,559 --> 00:17:19,280
trampoline to function

00:17:16,839 --> 00:17:21,360
appropriately script interpreters

00:17:19,280 --> 00:17:22,799
also represent another challenge as

00:17:21,360 --> 00:17:26,319
these files are opened with

00:17:22,799 --> 00:17:28,480
not plus x but in fact read

00:17:26,319 --> 00:17:30,000
so they are not subject to ip's

00:17:28,480 --> 00:17:31,520
execution rule set

00:17:30,000 --> 00:17:33,039
fortunately the community has already

00:17:31,520 --> 00:17:35,120
realized this issue

00:17:33,039 --> 00:17:39,440
and has started the process of creating

00:17:35,120 --> 00:17:39,440
a potential solution through oma exec

00:17:45,200 --> 00:17:48,320
the first thing we're going to do is

00:17:46,559 --> 00:17:50,000
generate a self-signed certificate to

00:17:48,320 --> 00:17:52,080
establish ip's root of trust

00:17:50,000 --> 00:17:54,000
and use openness file just to quickly

00:17:52,080 --> 00:17:55,120
create a self-signed certificate

00:17:54,000 --> 00:17:57,760
with a private key that we're going to

00:17:55,120 --> 00:17:59,200
use to sign things later

00:17:57,760 --> 00:18:00,880
after that's done we're going to move on

00:17:59,200 --> 00:18:03,039
to kernel setup

00:18:00,880 --> 00:18:05,039
so we're just going to open up our

00:18:03,039 --> 00:18:08,880
kernel repository

00:18:05,039 --> 00:18:11,280
set the default configuration for x8664

00:18:08,880 --> 00:18:14,000
and let's edit it slightly so from here

00:18:11,280 --> 00:18:15,760
we're going to enable kernel configs the

00:18:14,000 --> 00:18:18,320
first kernel config will enable

00:18:15,760 --> 00:18:20,480
is the unverity the option is under

00:18:18,320 --> 00:18:23,280
device drivers multiple driver

00:18:20,480 --> 00:18:25,520
device driver support rate and lvm

00:18:23,280 --> 00:18:27,280
device mapper support should be enabled

00:18:25,520 --> 00:18:29,679
as well as verity target support

00:18:27,280 --> 00:18:31,280
and we're going to also enable verity

00:18:29,679 --> 00:18:33,520
data device root hash signature

00:18:31,280 --> 00:18:35,120
verification support

00:18:33,520 --> 00:18:37,440
after that we're going to make a quick

00:18:35,120 --> 00:18:40,240
stop in file systems we're going to

00:18:37,440 --> 00:18:42,320
enable fuse as a module this will use

00:18:40,240 --> 00:18:45,600
later in order to demonstrate

00:18:42,320 --> 00:18:48,000
uh how to block or allow kernel module

00:18:45,600 --> 00:18:50,080
loads and we're also going to enable the

00:18:48,000 --> 00:18:52,400
squashfest file system driver to allow

00:18:50,080 --> 00:18:54,559
us to mount our squashfest

00:18:52,400 --> 00:18:57,600
we can now enable ipe we're going to

00:18:54,559 --> 00:19:00,400
enable fs as a dependency of ipe

00:18:57,600 --> 00:19:00,960
we're also going to disable se linux in

00:19:00,400 --> 00:19:03,440
ima

00:19:00,960 --> 00:19:04,960
just for the purposes of this demo so

00:19:03,440 --> 00:19:06,160
we're going to navigate to the integrity

00:19:04,960 --> 00:19:07,760
policy enforcement menu

00:19:06,160 --> 00:19:10,160
enable that we're going to go into the

00:19:07,760 --> 00:19:12,160
sub menu enable all the properties

00:19:10,160 --> 00:19:13,600
the policy to be applied at system

00:19:12,160 --> 00:19:15,440
startup is going to be left blank we'll

00:19:13,600 --> 00:19:17,679
come back to that later

00:19:15,440 --> 00:19:18,720
our final option is in the cryptography

00:19:17,679 --> 00:19:21,280
menu

00:19:18,720 --> 00:19:21,919
we're going to go down all the way to

00:19:21,280 --> 00:19:24,080
the bottom

00:19:21,919 --> 00:19:25,600
and compile in our certificate to the

00:19:24,080 --> 00:19:28,080
system trusted keyring

00:19:25,600 --> 00:19:29,600
this will establish ip's root of trust

00:19:28,080 --> 00:19:31,039
for all of its cryptographic

00:19:29,600 --> 00:19:32,799
verifications

00:19:31,039 --> 00:19:35,520
with our config complete we're going to

00:19:32,799 --> 00:19:37,039
now start our kernel compile

00:19:35,520 --> 00:19:38,960
we're going to wait a couple seconds

00:19:37,039 --> 00:19:42,080
before we continue just to ensure that

00:19:38,960 --> 00:19:43,360
everything is going to work out

00:19:42,080 --> 00:19:45,039
looks like everything's going to work

00:19:43,360 --> 00:19:46,160
out so we're going to split off a pane

00:19:45,039 --> 00:19:48,080
and we're going to

00:19:46,160 --> 00:19:49,919
create a dmv volume that we're going to

00:19:48,080 --> 00:19:51,360
use in the demo

00:19:49,919 --> 00:19:53,760
so the first thing we're going to do is

00:19:51,360 --> 00:19:54,640
create a squash fest of our demos folder

00:19:53,760 --> 00:19:56,720
it's pretty easy

00:19:54,640 --> 00:19:57,679
the package is squash fest tools on most

00:19:56,720 --> 00:19:59,440
distros

00:19:57,679 --> 00:20:00,960
and you just type in make squash fest

00:19:59,440 --> 00:20:04,159
the folder you're trying to compress

00:20:00,960 --> 00:20:06,000
and then the output file we now need to

00:20:04,159 --> 00:20:08,080
set up our squash fest volume

00:20:06,000 --> 00:20:10,080
with dm verities we're going to run

00:20:08,080 --> 00:20:11,760
verity setup format on our squash test

00:20:10,080 --> 00:20:13,200
volume this will generate the hash tree

00:20:11,760 --> 00:20:15,039
used by dm verity

00:20:13,200 --> 00:20:16,799
as well as output the root patch to

00:20:15,039 --> 00:20:18,880
standard out

00:20:16,799 --> 00:20:20,080
we're going to save the root hash by

00:20:18,880 --> 00:20:22,880
copying that

00:20:20,080 --> 00:20:24,159
root hash and echoing it with the dash n

00:20:22,880 --> 00:20:26,320
parameter to a

00:20:24,159 --> 00:20:27,520
file uh the dash end parameter is very

00:20:26,320 --> 00:20:30,080
important because

00:20:27,520 --> 00:20:31,360
it strips the new line from the output

00:20:30,080 --> 00:20:31,840
and then we're going to assign it using

00:20:31,360 --> 00:20:34,320
opens

00:20:31,840 --> 00:20:35,360
the cell s mime pointing in at the key

00:20:34,320 --> 00:20:37,280
in the certificate that we

00:20:35,360 --> 00:20:39,360
created way back when we're just going

00:20:37,280 --> 00:20:41,200
to do this twice so that we have two

00:20:39,360 --> 00:20:42,880
separate hash trees and two separate

00:20:41,200 --> 00:20:45,600
root hashes so that

00:20:42,880 --> 00:20:47,200
we can show authorization and denial by

00:20:45,600 --> 00:20:49,600
root hash

00:20:47,200 --> 00:20:51,440
it's now time to create our ipe policies

00:20:49,600 --> 00:20:52,320
uh we're first going to create a policy

00:20:51,440 --> 00:20:54,080
name boot we're going to give it a

00:20:52,320 --> 00:20:55,520
policy version of zero

00:20:54,080 --> 00:20:58,320
we're going to allow everything that we

00:20:55,520 --> 00:21:00,559
haven't considered to be allowed

00:20:58,320 --> 00:21:02,480
our executes are all going to be forced

00:21:00,559 --> 00:21:04,240
to come from the initial super block on

00:21:02,480 --> 00:21:07,600
the device that's the property

00:21:04,240 --> 00:21:09,360
verified and our kernel modules will

00:21:07,600 --> 00:21:12,720
also be required to come from the first

00:21:09,360 --> 00:21:12,720
super block on the device

00:21:14,159 --> 00:21:17,760
our next policy will be continuation of

00:21:16,000 --> 00:21:20,240
the first we're going to

00:21:17,760 --> 00:21:20,799
use it as a template and add another

00:21:20,240 --> 00:21:22,880
rule

00:21:20,799 --> 00:21:25,440
uh this rule is going to be the verdi

00:21:22,880 --> 00:21:29,039
root hash which will allow us to

00:21:25,440 --> 00:21:31,120
specify an individual dmv volume to

00:21:29,039 --> 00:21:32,320
either execute binaries from or load

00:21:31,120 --> 00:21:33,840
kernel modules from

00:21:32,320 --> 00:21:35,919
the root hash in this case that we're

00:21:33,840 --> 00:21:39,360
going to be using is the root hash that

00:21:35,919 --> 00:21:41,360
we saved from an earlier step

00:21:39,360 --> 00:21:44,159
our third policy will be a continuation

00:21:41,360 --> 00:21:46,799
of the second we're going to allow uh

00:21:44,159 --> 00:21:48,799
any dmv sign volume so anything that was

00:21:46,799 --> 00:21:50,960
mounted with the root hash signature

00:21:48,799 --> 00:21:53,280
argument provided by verity set up and

00:21:50,960 --> 00:21:55,520
passed successfully and we're also going

00:21:53,280 --> 00:21:57,919
to set up a revocation

00:21:55,520 --> 00:21:58,880
of the previous root hash so what that

00:21:57,919 --> 00:22:00,880
means is

00:21:58,880 --> 00:22:02,799
anything being executed or kernel

00:22:00,880 --> 00:22:04,960
modules being loaded from a volume

00:22:02,799 --> 00:22:06,159
our previous root hash volume will no

00:22:04,960 --> 00:22:08,400
longer be allowed

00:22:06,159 --> 00:22:09,600
whether it's signed or not we set up

00:22:08,400 --> 00:22:12,400
this revocation

00:22:09,600 --> 00:22:12,720
by moving our root hash rule up to the

00:22:12,400 --> 00:22:15,440
top

00:22:12,720 --> 00:22:16,320
his ip properties are executed from top

00:22:15,440 --> 00:22:17,919
to bottom

00:22:16,320 --> 00:22:19,760
and then we switch that action goes

00:22:17,919 --> 00:22:22,000
aloud action equals denied

00:22:19,760 --> 00:22:23,840
so this deny will act as a short circuit

00:22:22,000 --> 00:22:26,240
it will prevent evaluation of any other

00:22:23,840 --> 00:22:29,440
rules and as a result we will just deny

00:22:26,240 --> 00:22:31,600
execution from that volume wholesale as

00:22:29,440 --> 00:22:33,200
the scenario driving this policy is that

00:22:31,600 --> 00:22:35,760
we sign something incorrectly

00:22:33,200 --> 00:22:36,480
and want to uh revoke trust for that

00:22:35,760 --> 00:22:38,400
volume

00:22:36,480 --> 00:22:40,960
we're also going to bump the version

00:22:38,400 --> 00:22:42,799
number up to 0.0.1

00:22:40,960 --> 00:22:44,159
so that none of the existing policies

00:22:42,799 --> 00:22:45,840
can be rolled back to

00:22:44,159 --> 00:22:47,760
the fourth and final policy we're going

00:22:45,840 --> 00:22:51,200
to be making is very simple

00:22:47,760 --> 00:22:53,200
it's going to be a policy comprised of

00:22:51,200 --> 00:22:54,880
two rules for our execute two rules for

00:22:53,200 --> 00:22:56,400
a kernel module it's going to be

00:22:54,880 --> 00:22:57,919
boot verified equals true so anything

00:22:56,400 --> 00:23:00,000
from the initial super block

00:22:57,919 --> 00:23:00,960
and dmvarity signature equals true so

00:23:00,000 --> 00:23:03,600
this is any

00:23:00,960 --> 00:23:05,840
uh dmv volume that has a signed root

00:23:03,600 --> 00:23:08,000
hash or mounted with a signed root hash

00:23:05,840 --> 00:23:09,679
will be allowed to execute or load

00:23:08,000 --> 00:23:11,280
kernel modules

00:23:09,679 --> 00:23:13,360
with all of our policies written we're

00:23:11,280 --> 00:23:15,360
now going to sign all the policies we do

00:23:13,360 --> 00:23:17,679
this once again through openssl

00:23:15,360 --> 00:23:19,600
s mime this is almost identical to the

00:23:17,679 --> 00:23:22,480
way we sign our root hashes

00:23:19,600 --> 00:23:25,360
however it's important to notice the

00:23:22,480 --> 00:23:28,080
inclusion of the node attach

00:23:25,360 --> 00:23:29,840
signature flag which specifies that it

00:23:28,080 --> 00:23:33,280
is not a detached signature it is in

00:23:29,840 --> 00:23:33,280
fact an envelope signature

00:23:33,840 --> 00:23:37,919
so i'm going to do now is i'm going to

00:23:35,679 --> 00:23:40,799
mount my root file system under mount

00:23:37,919 --> 00:23:41,760
and i'm going to copy all of our

00:23:40,799 --> 00:23:44,640
artifacts our

00:23:41,760 --> 00:23:46,720
squash fs or hash trees or root hashes

00:23:44,640 --> 00:23:48,960
or signatures and our policies into

00:23:46,720 --> 00:23:51,679
my root file system so that we can have

00:23:48,960 --> 00:23:54,400
access to it in kimo later

00:23:51,679 --> 00:23:55,039
and it also looks like our kernel is

00:23:54,400 --> 00:23:57,679
done so

00:23:55,039 --> 00:23:59,120
we can start getting ready on our demo

00:23:57,679 --> 00:24:00,880
so as kimo starts up

00:23:59,120 --> 00:24:02,799
uh the first thing we're gonna do is

00:24:00,880 --> 00:24:04,320
we're going to load all the policies

00:24:02,799 --> 00:24:08,000
into the kernel

00:24:04,320 --> 00:24:08,000
this is done simply through

00:24:08,320 --> 00:24:13,039
writing the content to a certain file on

00:24:10,320 --> 00:24:14,159
the file system in security fs

00:24:13,039 --> 00:24:16,320
and then we're going to mark one of

00:24:14,159 --> 00:24:17,760
those policies as active and then we're

00:24:16,320 --> 00:24:19,440
going to

00:24:17,760 --> 00:24:20,880
run through some binaries that show

00:24:19,440 --> 00:24:23,919
various ways that

00:24:20,880 --> 00:24:27,279
ipe catches potentially

00:24:23,919 --> 00:24:28,559
unverified binary loads so as i just

00:24:27,279 --> 00:24:30,080
said we're going to load all the

00:24:28,559 --> 00:24:33,120
policies into the kernel

00:24:30,080 --> 00:24:36,880
we do this by writing the signed message

00:24:33,120 --> 00:24:39,600
into security of s ipe new policy

00:24:36,880 --> 00:24:41,520
um and we do this four times just to

00:24:39,600 --> 00:24:43,520
load all the individual policies

00:24:41,520 --> 00:24:45,200
this does not mean any of the policies

00:24:43,520 --> 00:24:46,000
are currently forced in fact they are

00:24:45,200 --> 00:24:48,799
just waiting to be

00:24:46,000 --> 00:24:49,760
activated before they are enforced in

00:24:48,799 --> 00:24:52,240
addition

00:24:49,760 --> 00:24:53,039
when we activate or load a policy into

00:24:52,240 --> 00:24:56,000
the kernel we

00:24:53,039 --> 00:24:57,760
have a audit record that shows the

00:24:56,000 --> 00:25:00,400
policy name policy version

00:24:57,760 --> 00:25:02,640
and the flat sha-1 hash of the file that

00:25:00,400 --> 00:25:04,880
was loaded this includes the uh

00:25:02,640 --> 00:25:05,679
the signature and so on and so forth

00:25:04,880 --> 00:25:07,360
once ip

00:25:05,679 --> 00:25:10,000
policies are loaded into the kernel they

00:25:07,360 --> 00:25:13,120
get their own node under security fs ip

00:25:10,000 --> 00:25:15,279
policies and the policy name

00:25:13,120 --> 00:25:16,159
there are two files inside that

00:25:15,279 --> 00:25:18,400
directory

00:25:16,159 --> 00:25:19,200
and it is raw which contains the

00:25:18,400 --> 00:25:20,960
original

00:25:19,200 --> 00:25:22,720
signed message that was uploaded to new

00:25:20,960 --> 00:25:24,080
policy or whatever stored in the kernel

00:25:22,720 --> 00:25:25,120
at the current time in the case of

00:25:24,080 --> 00:25:27,919
updates

00:25:25,120 --> 00:25:28,400
as well as content which is the other

00:25:27,919 --> 00:25:31,120
file

00:25:28,400 --> 00:25:33,039
which is the plain text content of the

00:25:31,120 --> 00:25:35,200
policy in the signed message

00:25:33,039 --> 00:25:36,400
with our policy loading out of the way

00:25:35,200 --> 00:25:38,799
we're now going to

00:25:36,400 --> 00:25:40,480
open our dmvarity volumes in the way

00:25:38,799 --> 00:25:40,799
that dmverity expects and then mount

00:25:40,480 --> 00:25:44,080
them

00:25:40,799 --> 00:25:45,679
on the file system to get the binaries

00:25:44,080 --> 00:25:48,240
that we're trying to execute

00:25:45,679 --> 00:25:49,760
so the way we do that is through verity

00:25:48,240 --> 00:25:52,080
setup which we've already set up

00:25:49,760 --> 00:25:53,360
open the name of the block device in our

00:25:52,080 --> 00:25:56,559
case demo that squash

00:25:53,360 --> 00:25:57,919
pass then we have the hash tree so demo

00:25:56,559 --> 00:26:01,760
dot hash tree

00:25:57,919 --> 00:26:04,000
and then we have the you echo the uh

00:26:01,760 --> 00:26:05,760
the root hash so without the new line so

00:26:04,000 --> 00:26:07,840
that's we just cat

00:26:05,760 --> 00:26:08,880
demo dot root hatch and then the

00:26:07,840 --> 00:26:11,360
optional uh

00:26:08,880 --> 00:26:12,080
parameter root hash signature and then

00:26:11,360 --> 00:26:14,720
the the

00:26:12,080 --> 00:26:16,480
file name which our case is demo p7s

00:26:14,720 --> 00:26:18,320
once again we do this two times

00:26:16,480 --> 00:26:19,679
because we want two separate volumes

00:26:18,320 --> 00:26:20,240
with two separate hash trees and two

00:26:19,679 --> 00:26:23,039
separate

00:26:20,240 --> 00:26:24,159
hashes for the purposes of our demo

00:26:23,039 --> 00:26:26,080
after that it creates a

00:26:24,159 --> 00:26:27,440
redirect device under devmapper and

00:26:26,080 --> 00:26:30,080
whatever we put as our name

00:26:27,440 --> 00:26:31,120
so we put demo as our name and demo too

00:26:30,080 --> 00:26:34,320
so we just mount

00:26:31,120 --> 00:26:36,720
a devmapper demo on any particular

00:26:34,320 --> 00:26:38,240
directory with all the test files out of

00:26:36,720 --> 00:26:41,120
the way we're going to

00:26:38,240 --> 00:26:41,600
show the demo files that we're going to

00:26:41,120 --> 00:26:43,919
be

00:26:41,600 --> 00:26:45,760
running as part of this experiment so

00:26:43,919 --> 00:26:47,679
the first step we have exec

00:26:45,760 --> 00:26:49,200
it's a simple binary all it does is

00:26:47,679 --> 00:26:50,159
essentially the equivalent of hello

00:26:49,200 --> 00:26:52,720
world

00:26:50,159 --> 00:26:54,559
um and then we have k module which

00:26:52,720 --> 00:26:57,200
contains fuse which we compiled

00:26:54,559 --> 00:26:58,799
um earlier in the kernel compilation

00:26:57,200 --> 00:27:01,520
we're just going to try inserting that

00:26:58,799 --> 00:27:03,360
with ld preload so this is a binary that

00:27:01,520 --> 00:27:06,799
overwrites the rand function

00:27:03,360 --> 00:27:09,279
to always return four and

00:27:06,799 --> 00:27:10,159
we're going to see if we can block that

00:27:09,279 --> 00:27:13,039
from being loaded

00:27:10,159 --> 00:27:14,799
the final one is a lib so this is just a

00:27:13,039 --> 00:27:15,679
simple binary that's linked to another

00:27:14,799 --> 00:27:17,840
library

00:27:15,679 --> 00:27:20,000
and we're going to demonstrate that if

00:27:17,840 --> 00:27:22,080
that library is unverified

00:27:20,000 --> 00:27:23,679
it won't be allowed to load and the

00:27:22,080 --> 00:27:26,080
program will terminate

00:27:23,679 --> 00:27:26,799
uh and protect so this does one of two

00:27:26,080 --> 00:27:29,679
things uh

00:27:26,799 --> 00:27:32,080
if we don't have the first argument uh

00:27:29,679 --> 00:27:34,000
then it does an anonymous memory mapping

00:27:32,080 --> 00:27:36,000
uh this will always be rejected by all

00:27:34,000 --> 00:27:36,720
of our policies and we'll see why in a

00:27:36,000 --> 00:27:39,600
minute

00:27:36,720 --> 00:27:40,159
um if we include a file to first map

00:27:39,600 --> 00:27:43,279
that mem

00:27:40,159 --> 00:27:45,679
file uh read write and then

00:27:43,279 --> 00:27:47,360
it will and protect it to execute

00:27:45,679 --> 00:27:48,000
finally we have a script which is just a

00:27:47,360 --> 00:27:49,840
simple python

00:27:48,000 --> 00:27:51,919
script that we're going to show one way

00:27:49,840 --> 00:27:53,360
that it's subject ip policy and another

00:27:51,919 --> 00:27:54,720
way where it's completely circumvents

00:27:53,360 --> 00:27:57,840
ipa policy

00:27:54,720 --> 00:27:59,600
we're just going to show now because ip

00:27:57,840 --> 00:28:01,440
has no active policy it's allowing

00:27:59,600 --> 00:28:02,559
everything to load

00:28:01,440 --> 00:28:04,960
so we're just going to run through a

00:28:02,559 --> 00:28:08,880
couple test cases and show that all

00:28:04,960 --> 00:28:08,880
these binaries can successfully execute

00:28:10,559 --> 00:28:13,919
now we're going to activate the policy

00:28:12,320 --> 00:28:16,159
boot

00:28:13,919 --> 00:28:17,760
as you remember this is the boot

00:28:16,159 --> 00:28:19,520
verified equals true meaning anything

00:28:17,760 --> 00:28:23,679
that belongs to the initial super block

00:28:19,520 --> 00:28:23,679
will be allowed to execute on the device

00:28:23,919 --> 00:28:28,000
so right here we're going to execute our

00:28:26,559 --> 00:28:29,360
hello world binary

00:28:28,000 --> 00:28:31,440
and we're going to see that it's going

00:28:29,360 --> 00:28:34,640
to be blocked uh because

00:28:31,440 --> 00:28:37,840
it is not boot verified so checking the

00:28:34,640 --> 00:28:38,720
audit log ipe created an audit event and

00:28:37,840 --> 00:28:42,320
the operation was

00:28:38,720 --> 00:28:43,279
executed under pid 272 the process was

00:28:42,320 --> 00:28:46,000
shell

00:28:43,279 --> 00:28:46,720
it tried to launch execute the second

00:28:46,000 --> 00:28:48,799
inode

00:28:46,720 --> 00:28:50,080
device dm0 we're going to check the rest

00:28:48,799 --> 00:28:53,200
of it uh

00:28:50,080 --> 00:28:55,440
it was d and verity signed

00:28:53,200 --> 00:28:56,559
right there yes it was from doom

00:28:55,440 --> 00:29:00,080
scientific verity volume

00:28:56,559 --> 00:29:02,080
it had a root hash that's the root hash

00:29:00,080 --> 00:29:03,760
it was not boot verified because it was

00:29:02,080 --> 00:29:05,679
not the initial super block so it

00:29:03,760 --> 00:29:07,919
blocked the it matched the rule

00:29:05,679 --> 00:29:08,880
default off equals execute action equals

00:29:07,919 --> 00:29:12,159
deny

00:29:08,880 --> 00:29:13,760
so this time going through our kernel um

00:29:12,159 --> 00:29:15,760
module we're going to try to insert the

00:29:13,760 --> 00:29:17,760
kernel module using insmod and we're

00:29:15,760 --> 00:29:20,399
going to say permission denied

00:29:17,760 --> 00:29:21,600
let's check the audit event the audit

00:29:20,399 --> 00:29:24,880
event says

00:29:21,600 --> 00:29:26,799
284 pid the operations k module the hook

00:29:24,880 --> 00:29:29,600
was kernel read

00:29:26,799 --> 00:29:31,279
the process was enzmod tried inserting

00:29:29,600 --> 00:29:34,640
fuse.ko

00:29:31,279 --> 00:29:36,559
and as we can see all the properties are

00:29:34,640 --> 00:29:39,440
consistent with what we had before

00:29:36,559 --> 00:29:40,000
and the rule that matched was default

00:29:39,440 --> 00:29:44,000
operation

00:29:40,000 --> 00:29:44,000
equals k module action equals deny

00:29:44,240 --> 00:29:48,080
so now we're trying to do ld preload

00:29:46,880 --> 00:29:50,640
we're gonna

00:29:48,080 --> 00:29:52,399
use the binary on the boot verify volume

00:29:50,640 --> 00:29:54,480
run ld preload

00:29:52,399 --> 00:29:57,919
where it's forcing the prelude of

00:29:54,480 --> 00:30:00,640
share.so from the dnrd volume

00:29:57,919 --> 00:30:01,520
and we're going to see that ld denies

00:30:00,640 --> 00:30:04,080
loading that

00:30:01,520 --> 00:30:04,799
volume we're going to check the audit

00:30:04,080 --> 00:30:08,159
log

00:30:04,799 --> 00:30:11,520
and we're going to see that it was

00:30:08,159 --> 00:30:12,720
uh execute trying to nmap the coms

00:30:11,520 --> 00:30:16,080
preload

00:30:12,720 --> 00:30:16,880
and the audit block was shared.so as we

00:30:16,080 --> 00:30:18,880
expected

00:30:16,880 --> 00:30:22,480
everything else is consistent with our

00:30:18,880 --> 00:30:26,080
operation before

00:30:22,480 --> 00:30:26,480
here i am just uh screwing up a little

00:30:26,080 --> 00:30:28,640
bit

00:30:26,480 --> 00:30:30,720
uh and protect is denied because it's

00:30:28,640 --> 00:30:33,440
only verified volume

00:30:30,720 --> 00:30:35,679
which uh totally makes sense because we

00:30:33,440 --> 00:30:35,919
can't execute that so we're gonna copy

00:30:35,679 --> 00:30:38,559
it

00:30:35,919 --> 00:30:39,279
to our boot verified volume and then

00:30:38,559 --> 00:30:40,799
we're gonna run it

00:30:39,279 --> 00:30:43,039
and we're gonna see that the uh

00:30:40,799 --> 00:30:43,679
anonymous failed uh permission was

00:30:43,039 --> 00:30:46,159
denied

00:30:43,679 --> 00:30:47,520
so checking the auto record we notice

00:30:46,159 --> 00:30:49,120
that uh

00:30:47,520 --> 00:30:51,200
immediately that there's no auto path

00:30:49,120 --> 00:30:53,279
name there's a

00:30:51,200 --> 00:30:55,440
it's just completely empty it's because

00:30:53,279 --> 00:30:56,480
there is no file object when it comes to

00:30:55,440 --> 00:30:58,399
anonymous

00:30:56,480 --> 00:30:59,519
memory so we can't evaluate any of our

00:30:58,399 --> 00:31:02,000
properties

00:30:59,519 --> 00:31:02,799
and so it matches the default rule so

00:31:02,000 --> 00:31:04,399
now let's try

00:31:02,799 --> 00:31:06,399
and protect the file we're going to try

00:31:04,399 --> 00:31:08,000
with itself from the boot verify volume

00:31:06,399 --> 00:31:09,360
it's going to work because both the

00:31:08,000 --> 00:31:11,120
subject and the target

00:31:09,360 --> 00:31:12,480
are absolutely verified therefore it

00:31:11,120 --> 00:31:14,799
matches our rules

00:31:12,480 --> 00:31:16,840
now let's move on to scripts so i'm

00:31:14,799 --> 00:31:20,559
going to first try to execute the script

00:31:16,840 --> 00:31:21,039
through dot slash and that's going to

00:31:20,559 --> 00:31:24,799
deny

00:31:21,039 --> 00:31:27,200
this is because the shell runs exec ve

00:31:24,799 --> 00:31:30,799
on that strip my script and that

00:31:27,200 --> 00:31:32,480
subjects it to the hook that we use

00:31:30,799 --> 00:31:33,919
to check for whether something can

00:31:32,480 --> 00:31:35,919
execute

00:31:33,919 --> 00:31:37,279
the next thing i'm going to do is i'm

00:31:35,919 --> 00:31:38,159
going to try to invoke it through the

00:31:37,279 --> 00:31:41,360
interpreter

00:31:38,159 --> 00:31:42,720
this does not uh get blocked because

00:31:41,360 --> 00:31:45,039
the interpreter is verified the

00:31:42,720 --> 00:31:47,440
interpreter opens the python script with

00:31:45,039 --> 00:31:49,360
read permissions not execute permissions

00:31:47,440 --> 00:31:51,200
and there is no equivalent execute

00:31:49,360 --> 00:31:54,640
permissions for open

00:31:51,200 --> 00:31:57,600
so it just completely executes the file

00:31:54,640 --> 00:31:59,279
this is an obvious gap around ipe and if

00:31:57,600 --> 00:32:01,519
you're interested in helping us

00:31:59,279 --> 00:32:03,200
close the gap i recommend that you look

00:32:01,519 --> 00:32:06,320
at lkml for the

00:32:03,200 --> 00:32:08,240
oma exec patch series which is capable

00:32:06,320 --> 00:32:10,720
of addressing this problem

00:32:08,240 --> 00:32:12,880
now let's switch policies we're gonna

00:32:10,720 --> 00:32:15,840
switch to the root hash policy that we

00:32:12,880 --> 00:32:18,399
built before so this will allow anything

00:32:15,840 --> 00:32:20,159
from a very specific dmv volume

00:32:18,399 --> 00:32:21,679
uh i believe we have mounted that

00:32:20,159 --> 00:32:23,360
undersigned

00:32:21,679 --> 00:32:25,279
and so we're just going to run through

00:32:23,360 --> 00:32:27,600
the same things

00:32:25,279 --> 00:32:29,679
execs now allowed to run because it's

00:32:27,600 --> 00:32:32,720
launched that root hash

00:32:29,679 --> 00:32:34,000
the kernel module can be inserted i have

00:32:32,720 --> 00:32:35,760
to remove that kernel module because

00:32:34,000 --> 00:32:38,159
we're going to use it later again

00:32:35,760 --> 00:32:39,360
i'm going to use r and mod dash f please

00:32:38,159 --> 00:32:42,080
don't do this in kernel

00:32:39,360 --> 00:32:43,519
on actual kernels because obviously it

00:32:42,080 --> 00:32:45,919
retains the kernel as the

00:32:43,519 --> 00:32:47,760
warning says now we're going to ld

00:32:45,919 --> 00:32:49,919
preload with the root hash we're going

00:32:47,760 --> 00:32:51,200
to notice that it now succeeds we get

00:32:49,919 --> 00:32:54,240
that statistically

00:32:51,200 --> 00:32:55,120
unlikely outcome because it loaded the

00:32:54,240 --> 00:32:58,320
overland

00:32:55,120 --> 00:33:00,240
overridden brand function uh

00:32:58,320 --> 00:33:01,440
let's try m protect and protect

00:33:00,240 --> 00:33:04,240
anonymous memory still

00:33:01,440 --> 00:33:05,760
fails as expected because if we look at

00:33:04,240 --> 00:33:09,760
the audit event

00:33:05,760 --> 00:33:12,799
um as i am scrolling up here

00:33:09,760 --> 00:33:13,360
we can see that it still has no file and

00:33:12,799 --> 00:33:15,919
so

00:33:13,360 --> 00:33:17,840
uh no file means it can't be traced to a

00:33:15,919 --> 00:33:19,440
boot verified volume can't be traced to

00:33:17,840 --> 00:33:22,080
a dmv volume

00:33:19,440 --> 00:33:22,880
so it matches the default rule but if we

00:33:22,080 --> 00:33:26,240
and protect

00:33:22,880 --> 00:33:29,519
the file itself it works because that

00:33:26,240 --> 00:33:32,159
subject is being merely verified scripts

00:33:29,519 --> 00:33:33,200
still work the same way uh we're gonna

00:33:32,159 --> 00:33:35,679
quickly switch

00:33:33,200 --> 00:33:36,320
policies to the policy that trusts

00:33:35,679 --> 00:33:40,080
everything by

00:33:36,320 --> 00:33:43,039
signature which is called signature

00:33:40,080 --> 00:33:44,880
um so we're gonna see tlip active policy

00:33:43,039 --> 00:33:47,200
equals signature

00:33:44,880 --> 00:33:48,320
oh wait no i want to switch back to the

00:33:47,200 --> 00:33:51,440
root hash to

00:33:48,320 --> 00:33:53,039
demonstrate that it was just authorizing

00:33:51,440 --> 00:33:54,799
that individual root hash

00:33:53,039 --> 00:33:56,240
so we're gonna go to sign two which has

00:33:54,799 --> 00:33:57,600
a different root hash we're gonna try to

00:33:56,240 --> 00:34:00,080
execute something

00:33:57,600 --> 00:34:01,360
it's gonna be denied uh we're gonna try

00:34:00,080 --> 00:34:02,320
to execute something on the original

00:34:01,360 --> 00:34:04,320
side volume

00:34:02,320 --> 00:34:05,519
it's gonna be allowed we're gonna check

00:34:04,320 --> 00:34:09,119
the audit events

00:34:05,519 --> 00:34:12,399
of our denial and it's going to show

00:34:09,119 --> 00:34:15,760
that um

00:34:12,399 --> 00:34:20,240
it's going to belong to sign two exec

00:34:15,760 --> 00:34:20,240
uh the root hash in it is

00:34:21,280 --> 00:34:25,200
different from what we had before before

00:34:23,359 --> 00:34:27,119
we started with the seven and the starts

00:34:25,200 --> 00:34:27,919
of the five here so we match our default

00:34:27,119 --> 00:34:29,440
rule

00:34:27,919 --> 00:34:31,359
all right so now let's activate our

00:34:29,440 --> 00:34:32,800
signature policy um

00:34:31,359 --> 00:34:33,839
both of the volumes will be trusted with

00:34:32,800 --> 00:34:34,639
this policy so we're going to go to

00:34:33,839 --> 00:34:36,879
signed let's

00:34:34,639 --> 00:34:37,839
execute something off of signed exec

00:34:36,879 --> 00:34:41,599
works

00:34:37,839 --> 00:34:44,000
sign two exec now works previously

00:34:41,599 --> 00:34:46,159
it did not work because we were trusting

00:34:44,000 --> 00:34:46,720
one single root hash but now we are

00:34:46,159 --> 00:34:49,200
trusting

00:34:46,720 --> 00:34:51,040
every signed root hash both volumes are

00:34:49,200 --> 00:34:54,240
allowed to execute and insert kernel

00:34:51,040 --> 00:34:54,240
modules with one rule

00:34:56,079 --> 00:34:59,599
now for the final part of our demo we're

00:34:58,000 --> 00:35:01,839
going to activate

00:34:59,599 --> 00:35:03,280
the signature with the revoked policy so

00:35:01,839 --> 00:35:06,240
this is everything signed

00:35:03,280 --> 00:35:07,680
except we explicitly deny that first the

00:35:06,240 --> 00:35:09,680
unverity volume

00:35:07,680 --> 00:35:12,079
uh so if we go to signed we're gonna

00:35:09,680 --> 00:35:13,920
execute execute fails as rightfully so

00:35:12,079 --> 00:35:16,640
if we check the audit log

00:35:13,920 --> 00:35:18,960
we're gonna see that the d the rule that

00:35:16,640 --> 00:35:22,079
was matched was our denial rule

00:35:18,960 --> 00:35:23,119
and uh we have to go all the way to the

00:35:22,079 --> 00:35:27,599
right for this

00:35:23,119 --> 00:35:29,920
and let's see here and

00:35:27,599 --> 00:35:29,920
bam

00:35:31,970 --> 00:35:37,520
[Music]

00:35:34,800 --> 00:35:39,280
so now let's try uh preloading something

00:35:37,520 --> 00:35:42,960
off of that revoked volume

00:35:39,280 --> 00:35:44,079
so we're gonna do preload ld preload

00:35:42,960 --> 00:35:49,200
equals

00:35:44,079 --> 00:35:49,200
that signed shared dot so

00:35:49,280 --> 00:35:53,599
and it's going to fail it's going to be

00:35:52,720 --> 00:35:54,800
ignored

00:35:53,599 --> 00:35:57,359
and we're going to try to unprotect

00:35:54,800 --> 00:35:58,960
something off of that volume

00:35:57,359 --> 00:36:01,520
and it's gonna fail because the subject

00:35:58,960 --> 00:36:04,079
is also not matching policy

00:36:01,520 --> 00:36:05,200
uh if we look at the journal cto the

00:36:04,079 --> 00:36:06,960
audit logs

00:36:05,200 --> 00:36:09,520
we're gonna see both of them showed up

00:36:06,960 --> 00:36:12,960
hook map hook and protect

00:36:09,520 --> 00:36:16,000
and we're gonna try to insert the

00:36:12,960 --> 00:36:17,920
kernel module it'll fail same reason

00:36:16,000 --> 00:36:19,200
we look at it it's going to be kernel

00:36:17,920 --> 00:36:22,720
read optical

00:36:19,200 --> 00:36:23,280
kernel module if we go to sign 2 we can

00:36:22,720 --> 00:36:25,200
insert

00:36:23,280 --> 00:36:26,960
views just fine because that's signed

00:36:25,200 --> 00:36:30,640
and it's not revoked and we can also

00:36:26,960 --> 00:36:30,640
execute things off of sign two

00:36:31,680 --> 00:36:34,880
so now that we've patched our security

00:36:33,359 --> 00:36:36,480
vulnerability with our

00:36:34,880 --> 00:36:37,760
newly updated policy let's make sure

00:36:36,480 --> 00:36:40,000
that we can't roll back so we're going

00:36:37,760 --> 00:36:41,680
to try to activate a prior policy

00:36:40,000 --> 00:36:43,440
signature it's going to fail within

00:36:41,680 --> 00:36:44,320
valid argument and we're going to check

00:36:43,440 --> 00:36:46,160
y

00:36:44,320 --> 00:36:48,960
so if you remember when we created this

00:36:46,160 --> 00:36:51,200
policy we bumped the version to 0.0.1

00:36:48,960 --> 00:36:53,520
but if we look at this policy version of

00:36:51,200 --> 00:36:55,680
signature it's 0.0.0

00:36:53,520 --> 00:36:57,119
this is because ipe does a version check

00:36:55,680 --> 00:36:59,440
when you try to activate

00:36:57,119 --> 00:37:01,520
a policy this prevents rollback attacks

00:36:59,440 --> 00:37:03,200
so now that our policies or older

00:37:01,520 --> 00:37:05,599
policies are completely useless to us

00:37:03,200 --> 00:37:08,000
let's delete them so all we do is echo

00:37:05,599 --> 00:37:09,920
the name of the policy into security of

00:37:08,000 --> 00:37:12,000
sip delete policy

00:37:09,920 --> 00:37:13,359
and the policies are unloaded from the

00:37:12,000 --> 00:37:15,359
kernel and freed

00:37:13,359 --> 00:37:17,200
um there are requirements around this

00:37:15,359 --> 00:37:19,040
can't be the active policy and it can't

00:37:17,200 --> 00:37:20,640
be what's known as the boot policy which

00:37:19,040 --> 00:37:22,560
we'll go into very shortly

00:37:20,640 --> 00:37:24,079
but as you can see policies are cleared

00:37:22,560 --> 00:37:25,760
and can no longer be queried through the

00:37:24,079 --> 00:37:27,200
security fs interface

00:37:25,760 --> 00:37:29,359
now we'll go into some of the assist

00:37:27,200 --> 00:37:30,880
ctls that ip gives the first one is the

00:37:29,359 --> 00:37:33,760
ctl ipv.enforce

00:37:30,880 --> 00:37:34,720
this switches ip between permissive mode

00:37:33,760 --> 00:37:37,359
and a force mode

00:37:34,720 --> 00:37:39,920
this is very similar to sc linux where

00:37:37,359 --> 00:37:42,480
ultimately the policy is not enforced

00:37:39,920 --> 00:37:44,240
at the uh end evaluation however the

00:37:42,480 --> 00:37:47,359
audit records are still generated for

00:37:44,240 --> 00:37:49,200
allow you to test policies uh in

00:37:47,359 --> 00:37:51,119
a relatively unobtrusive manner to

00:37:49,200 --> 00:37:52,079
normal operation while you refine your

00:37:51,119 --> 00:37:54,480
policies

00:37:52,079 --> 00:37:56,400
there are minutes of ctos you can show

00:37:54,480 --> 00:37:59,040
by cecio a group ip

00:37:56,400 --> 00:38:00,240
it's active policy enforce strict parts

00:37:59,040 --> 00:38:01,680
and success audit

00:38:00,240 --> 00:38:03,760
the description of these can be found in

00:38:01,680 --> 00:38:05,520
ip's documentation so a little while ago

00:38:03,760 --> 00:38:07,280
i talked about a boot policy a boot

00:38:05,520 --> 00:38:09,200
policy is a policy that is applied at

00:38:07,280 --> 00:38:10,640
startup and to walk you through how to

00:38:09,200 --> 00:38:12,720
create a boot policy

00:38:10,640 --> 00:38:14,000
we're just going to go back to our linux

00:38:12,720 --> 00:38:17,040
kernel

00:38:14,000 --> 00:38:18,560
compilation process we're going to go

00:38:17,040 --> 00:38:21,119
back to security

00:38:18,560 --> 00:38:22,880
integrity policy enforcement menu and we

00:38:21,119 --> 00:38:25,520
have that option we skipped integrity

00:38:22,880 --> 00:38:27,599
policy to apply at system startup

00:38:25,520 --> 00:38:29,280
that's going to be pointed to our your

00:38:27,599 --> 00:38:30,400
plaintext policy you wish to apply in

00:38:29,280 --> 00:38:32,000
our enforcement

00:38:30,400 --> 00:38:34,000
uh in our case we're going to do the

00:38:32,000 --> 00:38:35,040
boot policy so we only trust the boot

00:38:34,000 --> 00:38:37,920
verified

00:38:35,040 --> 00:38:39,599
items when we spring the system up you

00:38:37,920 --> 00:38:42,000
start the kernel compile

00:38:39,599 --> 00:38:43,440
uh wait for that to complete then start

00:38:42,000 --> 00:38:46,160
chemo with our new command

00:38:43,440 --> 00:38:47,520
our new kernel and when we bring the

00:38:46,160 --> 00:38:49,680
system up we see that

00:38:47,520 --> 00:38:52,800
active policy is now boot and the

00:38:49,680 --> 00:38:53,920
content of the security fss node of our

00:38:52,800 --> 00:38:55,680
active policy

00:38:53,920 --> 00:39:00,640
matches the plaintext policy that we

00:38:55,680 --> 00:39:02,320
compiled into the kernel

00:39:00,640 --> 00:39:03,920
for the future we're looking at the

00:39:02,320 --> 00:39:07,280
ability to support the

00:39:03,920 --> 00:39:09,280
ability to indicate specific keys

00:39:07,280 --> 00:39:11,599
and a quantification mechanism should

00:39:09,280 --> 00:39:13,599
result to as opposed to if it's valid

00:39:11,599 --> 00:39:15,359
let it through

00:39:13,599 --> 00:39:17,839
we also want to support integrity

00:39:15,359 --> 00:39:19,440
verification for specific file reads

00:39:17,839 --> 00:39:22,160
we're looking at accomplishing this

00:39:19,440 --> 00:39:24,079
through an original user land passed in

00:39:22,160 --> 00:39:24,960
path to establish the intent of user

00:39:24,079 --> 00:39:27,359
space

00:39:24,960 --> 00:39:29,520
as well as a new flag for open at 2

00:39:27,359 --> 00:39:31,920
similar to omay exec

00:39:29,520 --> 00:39:33,839
we also want to incorporate the omega

00:39:31,920 --> 00:39:34,960
patch series into ipe to address the

00:39:33,839 --> 00:39:38,000
script interpreter

00:39:34,960 --> 00:39:38,560
gap indicated previously and the final

00:39:38,000 --> 00:39:41,520
thing

00:39:38,560 --> 00:39:43,280
on our immediate list is resistance

00:39:41,520 --> 00:39:46,400
against rollback attacks right now

00:39:43,280 --> 00:39:47,119
ip has the option to compile an ideally

00:39:46,400 --> 00:39:49,040
minimal

00:39:47,119 --> 00:39:50,160
policy into the kernel to protect early

00:39:49,040 --> 00:39:53,359
user space

00:39:50,160 --> 00:39:55,839
there exists a possible avenue of attack

00:39:53,359 --> 00:39:57,119
where before the policy is deployed in

00:39:55,839 --> 00:39:59,599
late user space

00:39:57,119 --> 00:40:00,400
a previously deployed insecure policy is

00:39:59,599 --> 00:40:02,079
deployed

00:40:00,400 --> 00:40:04,560
and leveraged to gain a foothold on the

00:40:02,079 --> 00:40:05,520
device we've noticed this that has the

00:40:04,560 --> 00:40:07,760
potential to

00:40:05,520 --> 00:40:09,599
be affect several policy-based security

00:40:07,760 --> 00:40:10,160
systems and are looking trying to

00:40:09,599 --> 00:40:11,920
implement

00:40:10,160 --> 00:40:13,760
a generic interface for all these

00:40:11,920 --> 00:40:16,319
systems to leverage protections from

00:40:13,760 --> 00:40:16,319
this attack

00:40:23,119 --> 00:40:28,319
um so someone asked

00:40:26,240 --> 00:40:30,160
what was the name of the patch series on

00:40:28,319 --> 00:40:33,520
lkml that i referenced

00:40:30,160 --> 00:40:36,400
uh that is oh may exact and

00:40:33,520 --> 00:40:36,880
proposed by mikael some and forgive me

00:40:36,400 --> 00:40:40,079
if i

00:40:36,880 --> 00:40:42,319
butchered that name um

00:40:40,079 --> 00:40:43,359
another person asked what the upstream

00:40:42,319 --> 00:40:46,720
status is

00:40:43,359 --> 00:40:48,640
of this policy mechanism the unverity

00:40:46,720 --> 00:40:50,160
uh signatures have been in the kernel

00:40:48,640 --> 00:40:53,599
for a while if you meant ip

00:40:50,160 --> 00:40:56,800
in general we're proposed we're awaiting

00:40:53,599 --> 00:40:56,800
more review currently

00:40:57,119 --> 00:41:00,000
and that's about it

00:41:01,839 --> 00:41:06,880
and then someone else asked

00:41:04,960 --> 00:41:08,560
all kernel modules have to be loaded

00:41:06,880 --> 00:41:09,920
from the first super block i.e from the

00:41:08,560 --> 00:41:14,480
inner mfs

00:41:09,920 --> 00:41:17,920
uh this is all controlled by policy um

00:41:14,480 --> 00:41:20,560
this is because uh so you can also

00:41:17,920 --> 00:41:22,079
extend your policy to allow kernel

00:41:20,560 --> 00:41:23,200
modules to be loaded from d and verity

00:41:22,079 --> 00:41:26,640
volumes

00:41:23,200 --> 00:41:29,680
um and

00:41:26,640 --> 00:41:32,319
that's the last question i got was

00:41:29,680 --> 00:41:33,359
do you know about the state of ima

00:41:32,319 --> 00:41:36,480
directory appraisal

00:41:33,359 --> 00:41:38,000
unfortunately i don't uh the last i

00:41:36,480 --> 00:41:41,520
heard was

00:41:38,000 --> 00:41:43,680
uh in 2019 there was

00:41:41,520 --> 00:41:45,040
some to-do status regarding the

00:41:43,680 --> 00:41:48,240
directory appraisal but

00:41:45,040 --> 00:41:52,960
ah i'm not an ima developer

00:41:48,240 --> 00:41:55,520
so sorry uh

00:41:52,960 --> 00:41:56,319
yeah sorry uh my video is also down so i

00:41:55,520 --> 00:41:57,760
can't

00:41:56,319 --> 00:42:02,079
in case anybody's wondering why you're

00:41:57,760 --> 00:42:07,599
looking at a black screen

00:42:02,079 --> 00:42:07,599
all right any more questions anybody

00:42:10,960 --> 00:42:31,359
okay well i guess we can call it here

00:42:16,480 --> 00:42:31,359

YouTube URL: https://www.youtube.com/watch?v=wLSREpGQBPI


