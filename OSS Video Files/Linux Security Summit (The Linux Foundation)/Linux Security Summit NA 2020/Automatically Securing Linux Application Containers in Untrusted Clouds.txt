Title: Automatically Securing Linux Application Containers in Untrusted Clouds
Publication date: 2020-09-08
Playlist: Linux Security Summit NA 2020
Description: 
	Automatically Securing Linux Application Containers in Untrusted Clouds - Anjo Vahldiek-Oberwagner, Intel & Dmitrii Kuvaiskii, Intel Labs
Captions: 
	00:00:04,960 --> 00:00:08,639
hello and thank you for the opportunity

00:00:06,720 --> 00:00:10,719
to talk to you today

00:00:08,639 --> 00:00:12,320
dimitri and i will share our recent work

00:00:10,719 --> 00:00:13,519
on shielding linux application

00:00:12,320 --> 00:00:16,960
containers

00:00:13,519 --> 00:00:18,800
in an untrusted cloud recently

00:00:16,960 --> 00:00:21,039
these untrusted clouds have seen a surge

00:00:18,800 --> 00:00:22,240
in applications computing on sensitive

00:00:21,039 --> 00:00:23,840
and private data

00:00:22,240 --> 00:00:25,760
and when sensitive and private data is

00:00:23,840 --> 00:00:30,160
involved the risks of

00:00:25,760 --> 00:00:32,160
their exposure is even higher

00:00:30,160 --> 00:00:33,520
i start with the presentation it's

00:00:32,160 --> 00:00:37,040
important to note

00:00:33,520 --> 00:00:39,120
this legal disclaimer this talk is about

00:00:37,040 --> 00:00:40,640
the data protection gap that exists in

00:00:39,120 --> 00:00:43,440
untrusted clouds

00:00:40,640 --> 00:00:44,399
sensitive data is encrypted while it is

00:00:43,440 --> 00:00:47,440
in transit

00:00:44,399 --> 00:00:48,879
and at rest but it is not while it is in

00:00:47,440 --> 00:00:51,120
use

00:00:48,879 --> 00:00:52,079
as a result sensitive data may be

00:00:51,120 --> 00:00:54,000
exposed

00:00:52,079 --> 00:00:56,960
to the cloud's infrastructure system

00:00:54,000 --> 00:00:59,280
software while it is in use

00:00:56,960 --> 00:01:01,920
this creates a strong desire to compute

00:00:59,280 --> 00:01:04,080
on encrypted data

00:01:01,920 --> 00:01:06,000
this new form of computing is called

00:01:04,080 --> 00:01:08,960
confidential computing

00:01:06,000 --> 00:01:10,080
it protects your data against data

00:01:08,960 --> 00:01:12,320
confidentiality

00:01:10,080 --> 00:01:13,360
and integrity violations while

00:01:12,320 --> 00:01:17,119
protecting against

00:01:13,360 --> 00:01:19,200
replace it mainly relies on encryption

00:01:17,119 --> 00:01:21,119
of the main memory

00:01:19,200 --> 00:01:22,479
form of computing relies on trusted

00:01:21,119 --> 00:01:26,240
execution environments

00:01:22,479 --> 00:01:28,479
or tees a t typically

00:01:26,240 --> 00:01:30,640
is implemented in hardware in this case

00:01:28,479 --> 00:01:32,479
shown here in the cpu

00:01:30,640 --> 00:01:34,880
the hardware is trusted to isolate the

00:01:32,479 --> 00:01:37,600
te from the remaining system

00:01:34,880 --> 00:01:39,360
it does so by mapping the te's memory in

00:01:37,600 --> 00:01:42,079
a secure portion

00:01:39,360 --> 00:01:43,360
hence denying access from any non-te

00:01:42,079 --> 00:01:45,920
execution

00:01:43,360 --> 00:01:48,320
in addition the cpu attests the state of

00:01:45,920 --> 00:01:51,119
the te to third parties that ask for

00:01:48,320 --> 00:01:52,079
an attestation this allows an external

00:01:51,119 --> 00:01:55,600
verifier

00:01:52,079 --> 00:01:59,119
to provision secrets to the te

00:01:55,600 --> 00:02:01,200
today's te of choice is intel's sgx

00:01:59,119 --> 00:02:03,200
software guard extensions but before

00:02:01,200 --> 00:02:05,759
looking at sgx

00:02:03,200 --> 00:02:08,000
let's consider the attack surface of a

00:02:05,759 --> 00:02:09,759
regular application

00:02:08,000 --> 00:02:11,360
the attack surface typically includes

00:02:09,759 --> 00:02:15,599
the entire system

00:02:11,360 --> 00:02:18,640
software os and hardware

00:02:15,599 --> 00:02:21,120
intellect gx changes this attack surface

00:02:18,640 --> 00:02:23,440
it is implemented as an isa extension

00:02:21,120 --> 00:02:25,440
that allows an application to be split

00:02:23,440 --> 00:02:27,599
into an untrusted component and a

00:02:25,440 --> 00:02:29,840
trusted enclave

00:02:27,599 --> 00:02:32,560
these trusted enclaves are shown here as

00:02:29,840 --> 00:02:35,280
screen squares

00:02:32,560 --> 00:02:37,040
after the split the hardware ensures

00:02:35,280 --> 00:02:38,239
that neither the untrusted component of

00:02:37,040 --> 00:02:41,680
the application

00:02:38,239 --> 00:02:44,959
or any of the system software can access

00:02:41,680 --> 00:02:47,040
the trusted enclave's memory

00:02:44,959 --> 00:02:50,239
in the sgx model an untrusted

00:02:47,040 --> 00:02:53,360
application builds the trusted enclave

00:02:50,239 --> 00:02:56,160
given its initial state including some

00:02:53,360 --> 00:02:58,239
well-defined entry points

00:02:56,160 --> 00:02:59,440
before provisioning secrets to such an

00:02:58,239 --> 00:03:02,159
untrusted enclave

00:02:59,440 --> 00:03:04,000
a third party verifies an attestation

00:03:02,159 --> 00:03:05,200
evidence that is produced by the

00:03:04,000 --> 00:03:06,959
hardware

00:03:05,200 --> 00:03:08,480
that typically includes the memory

00:03:06,959 --> 00:03:12,000
fingerprint

00:03:08,480 --> 00:03:14,319
as well as the defined entry points

00:03:12,000 --> 00:03:16,000
this allows the third party to now trust

00:03:14,319 --> 00:03:19,760
the enclave

00:03:16,000 --> 00:03:22,800
and ship the private

00:03:19,760 --> 00:03:22,800
keys for example

00:03:23,360 --> 00:03:27,760
application into an untrusted component

00:03:25,360 --> 00:03:28,480
an entrusted enclave ensures very small

00:03:27,760 --> 00:03:30,640
tcp

00:03:28,480 --> 00:03:32,560
and strong security guarantees it

00:03:30,640 --> 00:03:34,959
increases the effort to build and

00:03:32,560 --> 00:03:36,640
maintain such a split

00:03:34,959 --> 00:03:39,360
in an interested cloud environment

00:03:36,640 --> 00:03:41,040
though we're using sgx not necessarily

00:03:39,360 --> 00:03:43,920
to split the application

00:03:41,040 --> 00:03:45,280
but rather to shield against the cloud's

00:03:43,920 --> 00:03:47,680
system software

00:03:45,280 --> 00:03:48,959
from gaining access to our valuable

00:03:47,680 --> 00:03:52,080
sensitive

00:03:48,959 --> 00:03:53,920
data of our application

00:03:52,080 --> 00:03:55,840
this results in a design where the

00:03:53,920 --> 00:03:57,760
entire application runs inside

00:03:55,840 --> 00:04:00,080
a trusted enclave shielded against

00:03:57,760 --> 00:04:01,599
access from the system software

00:04:00,080 --> 00:04:03,920
unfortunately the restrictive

00:04:01,599 --> 00:04:05,439
programming model of intellect gx denies

00:04:03,920 --> 00:04:08,560
system calls

00:04:05,439 --> 00:04:10,480
from an application

00:04:08,560 --> 00:04:11,760
to overcome this limitation either

00:04:10,480 --> 00:04:14,799
requires

00:04:11,760 --> 00:04:18,720
modifying the application or using

00:04:14,799 --> 00:04:21,519
a library os a library os provides

00:04:18,720 --> 00:04:22,320
a generic linux system called api to the

00:04:21,519 --> 00:04:24,960
application

00:04:22,320 --> 00:04:26,880
while securely translating these system

00:04:24,960 --> 00:04:29,600
calls that application does

00:04:26,880 --> 00:04:31,680
through the sgx boundary into the host

00:04:29,600 --> 00:04:33,759
os

00:04:31,680 --> 00:04:35,199
the library os we have been involved

00:04:33,759 --> 00:04:38,240
with is called graphene

00:04:35,199 --> 00:04:39,919
it has been adopted to intellect gx

00:04:38,240 --> 00:04:42,080
providing the interface to run

00:04:39,919 --> 00:04:44,320
unmodified linux applications within

00:04:42,080 --> 00:04:46,720
intellectualx enclaves

00:04:44,320 --> 00:04:48,880
let me introduce dimitri who is one of

00:04:46,720 --> 00:04:50,720
the core maintainers of great fiend

00:04:48,880 --> 00:04:53,199
he will provide the details on graphene

00:04:50,720 --> 00:04:55,360
before we apply graphene to application

00:04:53,199 --> 00:04:57,600
containers

00:04:55,360 --> 00:04:58,720
thank you anya for the kind introduction

00:04:57,600 --> 00:05:00,800
as already mentioned

00:04:58,720 --> 00:05:02,560
graphene is a library operating system

00:05:00,800 --> 00:05:05,039
that allows to run an unmodified

00:05:02,560 --> 00:05:06,720
application inside an sjx enclave

00:05:05,039 --> 00:05:08,080
graphene is an open source community

00:05:06,720 --> 00:05:09,600
supported project

00:05:08,080 --> 00:05:11,120
and it is currently in the process of

00:05:09,600 --> 00:05:13,759
transitioning from a research proof of

00:05:11,120 --> 00:05:15,840
concept to production-ready software

00:05:13,759 --> 00:05:17,039
graphene serves as a minimal bootloader

00:05:15,840 --> 00:05:18,720
and an emulation layer

00:05:17,039 --> 00:05:20,639
seeded between the application and the

00:05:18,720 --> 00:05:22,160
underlying host os

00:05:20,639 --> 00:05:23,840
you can think of graphene as a minimal

00:05:22,160 --> 00:05:25,440
re-implementation of a linux kernel

00:05:23,840 --> 00:05:26,560
which strives to resolve most

00:05:25,440 --> 00:05:28,400
application requests

00:05:26,560 --> 00:05:30,320
in the form of system calls and opensuit

00:05:28,400 --> 00:05:32,560
files in user space

00:05:30,320 --> 00:05:34,000
and occasionally resorting to hosto has

00:05:32,560 --> 00:05:36,240
provided resources like

00:05:34,000 --> 00:05:39,280
network io file system io thread

00:05:36,240 --> 00:05:40,800
scheduling process creation and so on

00:05:39,280 --> 00:05:42,400
graphene additionally implements

00:05:40,800 --> 00:05:44,080
extensive checks on system call

00:05:42,400 --> 00:05:45,840
arguments and return values

00:05:44,080 --> 00:05:47,680
helping to protect against maliciously

00:05:45,840 --> 00:05:49,600
crafted values

00:05:47,680 --> 00:05:52,000
and by design graphene consists of two

00:05:49,600 --> 00:05:53,759
layers the stateful library os

00:05:52,000 --> 00:05:55,759
layer that intercepts system call

00:05:53,759 --> 00:05:58,479
requests from the user application

00:05:55,759 --> 00:05:59,919
verifies inputs processes these requests

00:05:58,479 --> 00:06:01,680
verifies outputs

00:05:59,919 --> 00:06:03,280
updates the internal state of graphene

00:06:01,680 --> 00:06:04,479
and then gives the results back to the

00:06:03,280 --> 00:06:06,960
application

00:06:04,479 --> 00:06:07,600
and the stateless platform adaptation

00:06:06,960 --> 00:06:09,840
layer or

00:06:07,600 --> 00:06:10,800
pal for short which is invoked by the

00:06:09,840 --> 00:06:12,960
libos layer

00:06:10,800 --> 00:06:14,960
only when the host os must be involved

00:06:12,960 --> 00:06:16,319
in request processing

00:06:14,960 --> 00:06:18,479
as you can see graphene currently

00:06:16,319 --> 00:06:22,000
supports more than 300 system calls

00:06:18,479 --> 00:06:24,400
maps them to around 40 pal api functions

00:06:22,000 --> 00:06:27,520
and pile uses around 50 actual system

00:06:24,400 --> 00:06:29,520
calls to communicate with the host os

00:06:27,520 --> 00:06:30,720
now this picture shows the non-sjx

00:06:29,520 --> 00:06:33,919
version of graphene

00:06:30,720 --> 00:06:35,840
let us move to the sgx version when

00:06:33,919 --> 00:06:37,840
graphene is running into sgx mode

00:06:35,840 --> 00:06:40,080
it loads itself and the application

00:06:37,840 --> 00:06:42,160
inside of the sjx enclave

00:06:40,080 --> 00:06:43,840
the major parts of graphene move inside

00:06:42,160 --> 00:06:46,319
the enclave in particular

00:06:43,840 --> 00:06:48,319
the libos layer and most of a pal

00:06:46,319 --> 00:06:50,319
however pal is now divided into two

00:06:48,319 --> 00:06:51,520
separate binaries the untrusted pile and

00:06:50,319 --> 00:06:54,000
the trusted one

00:06:51,520 --> 00:06:56,479
the untrusted file is used to load and

00:06:54,000 --> 00:06:57,360
initialize vsjx enclave in the wrapper

00:06:56,479 --> 00:07:00,080
process

00:06:57,360 --> 00:07:02,160
and to issue system calls to the host os

00:07:00,080 --> 00:07:04,639
on behalf of the enclave

00:07:02,160 --> 00:07:05,680
it also serves as glue code to enter

00:07:04,639 --> 00:07:08,160
enclave mode and then

00:07:05,680 --> 00:07:09,840
exit it similarly to other layers the

00:07:08,160 --> 00:07:11,599
interface between the trusted ball

00:07:09,840 --> 00:07:14,000
executed inside the enclave and the

00:07:11,599 --> 00:07:16,800
entrusted pile executing outside

00:07:14,000 --> 00:07:17,520
is kept minimal with around 40 so called

00:07:16,800 --> 00:07:20,560
sgx

00:07:17,520 --> 00:07:22,639
out calls or alcohols in total

00:07:20,560 --> 00:07:24,479
graphene takes additional precautions to

00:07:22,639 --> 00:07:25,120
harden this boundary between the trusted

00:07:24,479 --> 00:07:28,319
enclave

00:07:25,120 --> 00:07:30,000
and the untrusted environment

00:07:28,319 --> 00:07:31,520
as typical in security critical

00:07:30,000 --> 00:07:33,840
environments the application running

00:07:31,520 --> 00:07:36,560
inside graphene and an sjx enclave must

00:07:33,840 --> 00:07:38,639
be accompanied by a security manifest

00:07:36,560 --> 00:07:40,400
in fact it is this security manifest and

00:07:38,639 --> 00:07:42,639
not the application binary but is given

00:07:40,400 --> 00:07:44,720
to graffina's input

00:07:42,639 --> 00:07:46,560
this security manifest is a plain text

00:07:44,720 --> 00:07:48,879
file in a simple format

00:07:46,560 --> 00:07:50,639
here is a small example first the

00:07:48,879 --> 00:07:52,479
manifest must specify the actual

00:07:50,639 --> 00:07:54,960
executable to load and run

00:07:52,479 --> 00:07:57,120
in this case the python 3 executable

00:07:54,960 --> 00:07:59,759
next the manifest may overwrite

00:07:57,120 --> 00:08:01,280
the required environment variables the

00:07:59,759 --> 00:08:03,919
manifest should also

00:08:01,280 --> 00:08:05,039
specify a subset of hostwa's directories

00:08:03,919 --> 00:08:07,120
to be mounted

00:08:05,039 --> 00:08:08,560
so that only they are visible to the

00:08:07,120 --> 00:08:11,120
enclosed application

00:08:08,560 --> 00:08:12,160
possibly under a different name as shown

00:08:11,120 --> 00:08:14,160
in this example

00:08:12,160 --> 00:08:16,160
here the glibc libraries are silently

00:08:14,160 --> 00:08:18,160
replaced with graphene patched glypc

00:08:16,160 --> 00:08:20,319
libraries

00:08:18,160 --> 00:08:22,080
next the manifest contains some sjx

00:08:20,319 --> 00:08:24,080
architecture specific variables like the

00:08:22,080 --> 00:08:26,080
maximum enclave size and the maximum

00:08:24,080 --> 00:08:28,160
number of simultaneous enclave threads

00:08:26,080 --> 00:08:29,520
these are the limitations of sgx version

00:08:28,160 --> 00:08:31,919
1.

00:08:29,520 --> 00:08:33,839
finally this example shows how files to

00:08:31,919 --> 00:08:34,560
be consumed by the enclave must be

00:08:33,839 --> 00:08:37,120
marked as

00:08:34,560 --> 00:08:38,560
trusted in this case graphene calculates

00:08:37,120 --> 00:08:40,560
a secure hashes during

00:08:38,560 --> 00:08:42,399
build time appends this hashes to the

00:08:40,560 --> 00:08:44,240
manifest and then during runtime

00:08:42,399 --> 00:08:45,760
graphene will verify that the files were

00:08:44,240 --> 00:08:47,519
not modified

00:08:45,760 --> 00:08:48,800
there are several more manifest options

00:08:47,519 --> 00:08:51,839
to graphene

00:08:48,800 --> 00:08:53,519
to enable additional functionality

00:08:51,839 --> 00:08:54,880
so this manifest is the single most

00:08:53,519 --> 00:08:57,440
important file when importing

00:08:54,880 --> 00:08:59,360
applications to graphene and intel sgx

00:08:57,440 --> 00:09:00,800
ultimately the security and correct

00:08:59,360 --> 00:09:03,200
functioning of the application

00:09:00,800 --> 00:09:05,519
depends on how its manifest file is

00:09:03,200 --> 00:09:05,519
written

00:09:05,680 --> 00:09:09,120
a very important aspect of any trusted

00:09:07,760 --> 00:09:11,839
execution environment is

00:09:09,120 --> 00:09:13,600
at the station how can a remote user

00:09:11,839 --> 00:09:14,080
verify that your application actually

00:09:13,600 --> 00:09:16,560
runs

00:09:14,080 --> 00:09:18,399
in a correct up-to-date te and that the

00:09:16,560 --> 00:09:20,320
code that runs inside the te is the

00:09:18,399 --> 00:09:22,160
actual user application

00:09:20,320 --> 00:09:24,000
moreover how can the remote user

00:09:22,160 --> 00:09:25,920
provision any secret inputs to the

00:09:24,000 --> 00:09:26,800
application remotely and in a secure

00:09:25,920 --> 00:09:28,640
fashion

00:09:26,800 --> 00:09:31,760
and then get the results of execution

00:09:28,640 --> 00:09:34,080
also in a secure fashion back

00:09:31,760 --> 00:09:36,000
intel sjx similarly to other keys

00:09:34,080 --> 00:09:38,560
provides a way for the sjx enclave to

00:09:36,000 --> 00:09:40,800
attest itself to the remote user

00:09:38,560 --> 00:09:42,480
this way the user gains trust in the sjx

00:09:40,800 --> 00:09:43,600
enclave running in an untrusted

00:09:42,480 --> 00:09:45,600
environment

00:09:43,600 --> 00:09:47,360
cheap application code and data and be

00:09:45,600 --> 00:09:50,480
sure that the results were executed

00:09:47,360 --> 00:09:52,640
inside a genuine sgx enclave

00:09:50,480 --> 00:09:56,240
we will show a complete though slightly

00:09:52,640 --> 00:09:58,320
simplified flow of remote addition

00:09:56,240 --> 00:09:59,839
every sgx enabled processor contains a

00:09:58,320 --> 00:10:01,680
key burnt into its fuses

00:09:59,839 --> 00:10:03,279
the processor uses a secret key to

00:10:01,680 --> 00:10:04,959
encrypt all memory traffic live in the

00:10:03,279 --> 00:10:07,200
cpu package

00:10:04,959 --> 00:10:09,120
so all manufactured sgx processors are

00:10:07,200 --> 00:10:09,920
listed in the web service maintained by

00:10:09,120 --> 00:10:13,040
intel called

00:10:09,920 --> 00:10:15,680
intel provisioning certification service

00:10:13,040 --> 00:10:17,279
at deployment time when usgx machine is

00:10:15,680 --> 00:10:18,800
supposed to be registered with this

00:10:17,279 --> 00:10:20,640
service

00:10:18,800 --> 00:10:22,160
there is a special sjx enclave called

00:10:20,640 --> 00:10:23,360
provisioning certification enclave

00:10:22,160 --> 00:10:25,360
developed by intel

00:10:23,360 --> 00:10:27,360
this enclave is used to connect to the

00:10:25,360 --> 00:10:30,079
intel provisioning certification service

00:10:27,360 --> 00:10:32,000
send the id of sjx processor and other

00:10:30,079 --> 00:10:35,120
identifying information

00:10:32,000 --> 00:10:35,920
and receive the normal x509 certificate

00:10:35,120 --> 00:10:38,240
for this machine

00:10:35,920 --> 00:10:40,000
signed with the intel public key this

00:10:38,240 --> 00:10:44,640
certificate is used to prove that the

00:10:40,000 --> 00:10:44,640
sjx processor is genuine and up-to-date

00:10:45,040 --> 00:10:48,720
now the user wants to run an enclavized

00:10:46,959 --> 00:10:49,839
application with a security sensitive

00:10:48,720 --> 00:10:52,480
workload

00:10:49,839 --> 00:10:54,560
the user possesses a trusted machine and

00:10:52,480 --> 00:10:56,240
not needed to be sjx enabled

00:10:54,560 --> 00:10:58,320
and the first thing the user must do

00:10:56,240 --> 00:11:00,000
before outsourcing your secure workload

00:10:58,320 --> 00:11:02,240
is to contact the intel provision

00:11:00,000 --> 00:11:04,240
and certification service to retrieve

00:11:02,240 --> 00:11:06,000
the required certificates certificate

00:11:04,240 --> 00:11:08,720
revocation lists and our

00:11:06,000 --> 00:11:10,720
sjx identified information this

00:11:08,720 --> 00:11:11,760
information can be cached in a local

00:11:10,720 --> 00:11:12,959
database

00:11:11,760 --> 00:11:15,040
so that the user doesn't have to

00:11:12,959 --> 00:11:16,880
establish internet connection to the

00:11:15,040 --> 00:11:18,880
provisioning certification service every

00:11:16,880 --> 00:11:20,880
time she runs a workload on a remote

00:11:18,880 --> 00:11:22,640
untrusted machine

00:11:20,880 --> 00:11:24,560
the user also installs the quote

00:11:22,640 --> 00:11:26,839
verification software that runs

00:11:24,560 --> 00:11:29,839
all the required checks during remote ad

00:11:26,839 --> 00:11:29,839
station

00:11:30,000 --> 00:11:33,440
now the user shifts the application

00:11:31,600 --> 00:11:36,000
binary and the graphene runtime to the

00:11:33,440 --> 00:11:37,920
remote untrusted machine

00:11:36,000 --> 00:11:40,240
note that no sensitive inputs are

00:11:37,920 --> 00:11:42,079
shipped to a remote machine just yet

00:11:40,240 --> 00:11:43,760
so the remote machine starts graphene

00:11:42,079 --> 00:11:46,800
which starts the application binary

00:11:43,760 --> 00:11:47,279
inside of the sjx enclave the user also

00:11:46,800 --> 00:11:49,360
starts

00:11:47,279 --> 00:11:50,320
a secret provider application on your

00:11:49,360 --> 00:11:52,000
own machine

00:11:50,320 --> 00:11:53,600
this application will connect to the

00:11:52,000 --> 00:11:54,959
remote machine establish a secure

00:11:53,600 --> 00:11:56,720
communication channel

00:11:54,959 --> 00:11:58,639
verify that the remote machine is a

00:11:56,720 --> 00:12:00,639
genuine sjx enabled machine

00:11:58,639 --> 00:12:03,200
and that the application and graphene

00:12:00,639 --> 00:12:05,360
run in a genuine sjx enclave

00:12:03,200 --> 00:12:07,279
and after that release secret inputs to

00:12:05,360 --> 00:12:09,040
this remote machine

00:12:07,279 --> 00:12:11,120
so secret inputs are represented as a

00:12:09,040 --> 00:12:12,480
key ring on this diagram

00:12:11,120 --> 00:12:14,480
note that since the user shipped

00:12:12,480 --> 00:12:16,399
graphene and binary to a remote machine

00:12:14,480 --> 00:12:19,519
the user knows their corresponding

00:12:16,399 --> 00:12:19,519
expected measurements

00:12:20,720 --> 00:12:24,079
intel sgx software infrastructure has

00:12:22,560 --> 00:12:26,480
another special enclave

00:12:24,079 --> 00:12:28,160
called quoting enclave this enclave with

00:12:26,480 --> 00:12:29,760
a reference implementation written by

00:12:28,160 --> 00:12:32,240
intel is used to create a special

00:12:29,760 --> 00:12:34,240
structure called the sjx code

00:12:32,240 --> 00:12:36,000
this sgx code contains all the

00:12:34,240 --> 00:12:37,440
information about the particular enclave

00:12:36,000 --> 00:12:38,560
including its hardware generated

00:12:37,440 --> 00:12:40,560
measurements

00:12:38,560 --> 00:12:42,079
you can think of asgx code as a second

00:12:40,560 --> 00:12:44,959
level certificate that proves the

00:12:42,079 --> 00:12:46,639
authenticity of the enclave

00:12:44,959 --> 00:12:48,480
graphene contains two libraries that

00:12:46,639 --> 00:12:49,279
transparently add remote attestation to

00:12:48,480 --> 00:12:52,639
the application

00:12:49,279 --> 00:12:54,800
the arraytls library augments normal ssl

00:12:52,639 --> 00:12:56,800
tls sessions with an sgx specific

00:12:54,800 --> 00:12:58,880
handshake callback

00:12:56,800 --> 00:13:00,240
the secret provisioning library builds

00:12:58,880 --> 00:13:02,800
on top of our atls

00:13:00,240 --> 00:13:04,320
and runs before the application first

00:13:02,800 --> 00:13:06,959
the secret provisioning library

00:13:04,320 --> 00:13:09,279
instructs our atls to collect all sjx

00:13:06,959 --> 00:13:11,440
related certificates and create a normal

00:13:09,279 --> 00:13:14,639
x 509 certificate chain

00:13:11,440 --> 00:13:16,079
out of them then

00:13:14,639 --> 00:13:18,320
a secret provisioning library

00:13:16,079 --> 00:13:20,000
establishes a secure tls channel with

00:13:18,320 --> 00:13:22,560
the user's machine

00:13:20,000 --> 00:13:24,639
during tls handshake array tls library

00:13:22,560 --> 00:13:26,639
installs a special verification callback

00:13:24,639 --> 00:13:27,680
that receives the certificate chain with

00:13:26,639 --> 00:13:29,839
free certificates

00:13:27,680 --> 00:13:32,000
the leaf array tls certificate the

00:13:29,839 --> 00:13:33,839
second level sgx quote identifying the

00:13:32,000 --> 00:13:36,320
enclave and the top level certificate

00:13:33,839 --> 00:13:37,920
identifying the sjx platform

00:13:36,320 --> 00:13:40,320
since the free certificates in the chain

00:13:37,920 --> 00:13:42,240
contain all sgx related information the

00:13:40,320 --> 00:13:43,920
user compares the retrieved measurements

00:13:42,240 --> 00:13:46,160
against the expected ones

00:13:43,920 --> 00:13:48,720
and decides whether to trust the remote

00:13:46,160 --> 00:13:50,720
enclave or not

00:13:48,720 --> 00:13:52,800
if a user side verification finishes

00:13:50,720 --> 00:13:54,880
successfully the user then gains

00:13:52,800 --> 00:13:56,480
trust in the remote enclave and now

00:13:54,880 --> 00:13:57,120
using the same secret provisioning

00:13:56,480 --> 00:13:59,920
library

00:13:57,120 --> 00:14:01,199
sends the secret inputs into the sgx

00:13:59,920 --> 00:14:02,480
enclave

00:14:01,199 --> 00:14:04,240
after this point the secrets are

00:14:02,480 --> 00:14:06,959
injected in the application and the

00:14:04,240 --> 00:14:08,800
application finally starts its execution

00:14:06,959 --> 00:14:10,880
the same secure channel may be reused to

00:14:08,800 --> 00:14:14,399
securely send applications results

00:14:10,880 --> 00:14:15,920
back to the user graphene also

00:14:14,399 --> 00:14:16,720
implements the feature of protected

00:14:15,920 --> 00:14:18,560
files

00:14:16,720 --> 00:14:20,720
since the user application runs on an

00:14:18,560 --> 00:14:23,440
untrusted machine all input files

00:14:20,720 --> 00:14:25,440
as well as produced output files must be

00:14:23,440 --> 00:14:27,120
at least integrity protected

00:14:25,440 --> 00:14:28,880
and if user files contain sensitive

00:14:27,120 --> 00:14:32,000
information they must also be

00:14:28,880 --> 00:14:33,440
encrypted with the protected file system

00:14:32,000 --> 00:14:35,600
implemented in graphene

00:14:33,440 --> 00:14:36,959
all required files to run the workload

00:14:35,600 --> 00:14:40,320
are created by the user

00:14:36,959 --> 00:14:41,920
on her trusted premises first

00:14:40,320 --> 00:14:43,519
the files are then encrypted with a

00:14:41,920 --> 00:14:45,199
symmetric key

00:14:43,519 --> 00:14:46,800
after that the files may be shipped to

00:14:45,199 --> 00:14:49,040
then trusted machine together with the

00:14:46,800 --> 00:14:50,880
application binary and graphene

00:14:49,040 --> 00:14:52,880
after the sjx enclave is created

00:14:50,880 --> 00:14:54,240
graphene needs to obtain the key used to

00:14:52,880 --> 00:14:55,760
encrypt the files

00:14:54,240 --> 00:14:57,360
as explained previously this key

00:14:55,760 --> 00:15:00,320
provisioning can be accomplished via

00:14:57,360 --> 00:15:02,320
secret provisioning with remoted station

00:15:00,320 --> 00:15:04,240
so once a key is securely provisioned

00:15:02,320 --> 00:15:06,079
inside the enclave protected the fsub

00:15:04,240 --> 00:15:07,440
system of graphene uses this key to

00:15:06,079 --> 00:15:11,360
decrypt the input files

00:15:07,440 --> 00:15:13,279
and run the workload after the enclave

00:15:11,360 --> 00:15:15,040
is finished with a secure computation

00:15:13,279 --> 00:15:16,320
the application typically produces an

00:15:15,040 --> 00:15:17,920
output file

00:15:16,320 --> 00:15:19,920
this file is also transparently

00:15:17,920 --> 00:15:21,519
encrypted by the protected fs with the

00:15:19,920 --> 00:15:23,519
same encryption key

00:15:21,519 --> 00:15:27,040
finally the output file may be moved to

00:15:23,519 --> 00:15:29,120
a remote user where it will be decrypted

00:15:27,040 --> 00:15:30,480
graphene implements protected files as

00:15:29,120 --> 00:15:32,800
transparently encrypted

00:15:30,480 --> 00:15:34,720
and integrity protected files the

00:15:32,800 --> 00:15:36,240
specific files or whole directories to

00:15:34,720 --> 00:15:38,000
be treated as protected must be

00:15:36,240 --> 00:15:39,839
specified in the manifest

00:15:38,000 --> 00:15:41,519
the encryption format used in the

00:15:39,839 --> 00:15:43,360
protected fs implementation

00:15:41,519 --> 00:15:46,800
is borrowed from a similar feature of

00:15:43,360 --> 00:15:48,399
intel sgx sdk

00:15:46,800 --> 00:15:50,240
we would like to stress that graphene is

00:15:48,399 --> 00:15:52,320
an open source project maintained by a

00:15:50,240 --> 00:15:52,639
dedicated community with contributors

00:15:52,320 --> 00:15:55,440
from

00:15:52,639 --> 00:15:57,519
several companies and universities we

00:15:55,440 --> 00:15:59,199
successfully enabled several widely used

00:15:57,519 --> 00:15:59,759
applications in graphene across several

00:15:59,199 --> 00:16:02,079
domains

00:15:59,759 --> 00:16:03,199
and hope to support more use cases as we

00:16:02,079 --> 00:16:04,880
grow

00:16:03,199 --> 00:16:08,399
and at this point i would like to give

00:16:04,880 --> 00:16:09,600
the mic back to anya

00:16:08,399 --> 00:16:12,240
thank you for the introduction of

00:16:09,600 --> 00:16:14,880
graphene we will now switch gears

00:16:12,240 --> 00:16:17,199
and look at how to use graphene for

00:16:14,880 --> 00:16:18,800
application containers

00:16:17,199 --> 00:16:20,639
containers have become the de facto

00:16:18,800 --> 00:16:22,079
deployment model for the cloud besides

00:16:20,639 --> 00:16:24,399
virtual machines

00:16:22,079 --> 00:16:26,320
they provide a small memory footprint

00:16:24,399 --> 00:16:28,959
and a fast startup time

00:16:26,320 --> 00:16:30,639
we cannot directly apply graphene to

00:16:28,959 --> 00:16:32,560
container frameworks we first have to

00:16:30,639 --> 00:16:34,480
overcome two obstacles

00:16:32,560 --> 00:16:36,800
the first one is that graphene does not

00:16:34,480 --> 00:16:40,160
provide an interface to create

00:16:36,800 --> 00:16:42,480
images or containers second

00:16:40,160 --> 00:16:43,680
while providing handcrafted manifests as

00:16:42,480 --> 00:16:46,320
dmitry explained

00:16:43,680 --> 00:16:48,959
is possible it's a huge burgeon on the

00:16:46,320 --> 00:16:52,240
application developer or

00:16:48,959 --> 00:16:54,399
engineer to encourage the users of

00:16:52,240 --> 00:16:55,440
usage of our container integration we

00:16:54,399 --> 00:16:58,639
have to simplify

00:16:55,440 --> 00:17:01,120
the manifest drastically

00:16:58,639 --> 00:17:02,639
for this purpose we have created

00:17:01,120 --> 00:17:05,760
graphene shielded containers

00:17:02,639 --> 00:17:08,079
or gsc it takes as an input the

00:17:05,760 --> 00:17:10,480
irregular docker image with an

00:17:08,079 --> 00:17:13,199
application as a dependencies

00:17:10,480 --> 00:17:13,919
and optionally a minimal application

00:17:13,199 --> 00:17:16,839
manifest

00:17:13,919 --> 00:17:18,559
detailing its memory and parallelism

00:17:16,839 --> 00:17:21,039
requirements

00:17:18,559 --> 00:17:23,199
these two are given to gst to build a

00:17:21,039 --> 00:17:25,199
graphinized docker image

00:17:23,199 --> 00:17:26,640
this image includes the application the

00:17:25,199 --> 00:17:29,360
graphene runtime

00:17:26,640 --> 00:17:31,120
and a generated manifest file based on

00:17:29,360 --> 00:17:32,400
the user's inputs as well as some

00:17:31,120 --> 00:17:35,520
configurations

00:17:32,400 --> 00:17:37,600
of the docker image all sgx

00:17:35,520 --> 00:17:39,360
applications have to be signed by the

00:17:37,600 --> 00:17:42,720
developer's key

00:17:39,360 --> 00:17:45,440
do you see science applications in

00:17:42,720 --> 00:17:46,000
the runtime and the manifest in a second

00:17:45,440 --> 00:17:48,640
step

00:17:46,000 --> 00:17:49,760
to ensure that the user's signing key is

00:17:48,640 --> 00:17:53,120
never part of

00:17:49,760 --> 00:17:54,720
the persistent image the signed image

00:17:53,120 --> 00:17:57,039
can then be started

00:17:54,720 --> 00:17:58,559
by a regular docker run command which

00:17:57,039 --> 00:18:01,120
starts the graphene runtime

00:17:58,559 --> 00:18:02,480
the runtime loads the manifest which

00:18:01,120 --> 00:18:04,559
then starts building the enclave

00:18:02,480 --> 00:18:07,679
according to the manifest specification

00:18:04,559 --> 00:18:08,720
and starts running the application on

00:18:07,679 --> 00:18:10,880
the previous slide

00:18:08,720 --> 00:18:12,799
i simplified the manifest file

00:18:10,880 --> 00:18:15,200
generation substantially

00:18:12,799 --> 00:18:17,039
let me explain how we semi-automatically

00:18:15,200 --> 00:18:19,760
generate a manifest file

00:18:17,039 --> 00:18:21,840
from a docker image we base our

00:18:19,760 --> 00:18:22,720
automation on the observation that a

00:18:21,840 --> 00:18:24,799
container

00:18:22,720 --> 00:18:26,799
defines the minimum runtime environment

00:18:24,799 --> 00:18:29,120
of an application

00:18:26,799 --> 00:18:30,480
this means that files included inside

00:18:29,120 --> 00:18:32,880
the container

00:18:30,480 --> 00:18:33,520
are dependent libraries required script

00:18:32,880 --> 00:18:36,080
files

00:18:33,520 --> 00:18:38,799
static inputs or a particular

00:18:36,080 --> 00:18:41,039
configuration argument

00:18:38,799 --> 00:18:43,360
using this observation we can generate a

00:18:41,039 --> 00:18:44,559
majority of the fields that constitute a

00:18:43,360 --> 00:18:47,600
manifest file

00:18:44,559 --> 00:18:49,840
i've listed here only a few examples and

00:18:47,600 --> 00:18:52,000
we'll go through them one by one

00:18:49,840 --> 00:18:53,760
the executable and its arguments are

00:18:52,000 --> 00:18:56,240
specified typically

00:18:53,760 --> 00:18:56,799
inside the docker's image configuration

00:18:56,240 --> 00:18:59,919
via an

00:18:56,799 --> 00:19:02,000
entry point or a command we repurpose

00:18:59,919 --> 00:19:02,960
these configuration fields to generate

00:19:02,000 --> 00:19:06,160
the executable

00:19:02,960 --> 00:19:08,400
and its arguments in the manifest file

00:19:06,160 --> 00:19:10,880
in addition each manifest file includes

00:19:08,400 --> 00:19:13,039
a description of the file system layout

00:19:10,880 --> 00:19:14,080
since we consider the entire file system

00:19:13,039 --> 00:19:15,760
of the container

00:19:14,080 --> 00:19:18,320
to be a dependency of the application

00:19:15,760 --> 00:19:19,360
that runs we simply set the file system

00:19:18,320 --> 00:19:22,799
to the root

00:19:19,360 --> 00:19:25,039
of the container lastly each application

00:19:22,799 --> 00:19:27,600
will open files in particular any

00:19:25,039 --> 00:19:30,160
dependent shared libraries

00:19:27,600 --> 00:19:31,200
without specifying any dependencies as

00:19:30,160 --> 00:19:33,280
trusted files

00:19:31,200 --> 00:19:35,919
graphene will simply deny access to

00:19:33,280 --> 00:19:35,919
these files

00:19:36,799 --> 00:19:44,080
this is to ensure that any open file

00:19:40,880 --> 00:19:46,559
has a pre-recorded sha-256 hash

00:19:44,080 --> 00:19:49,120
and ensuring its integrity and hence

00:19:46,559 --> 00:19:52,400
that nobody tampered with it

00:19:49,120 --> 00:19:56,320
we overestimate this set of files to be

00:19:52,400 --> 00:19:57,200
all files in the container using gsc we

00:19:56,320 --> 00:19:59,520
have developed

00:19:57,200 --> 00:20:00,320
three deployment scenarios in the first

00:19:59,520 --> 00:20:02,320
scenario

00:20:00,320 --> 00:20:04,000
the client builds the graphinized docker

00:20:02,320 --> 00:20:07,679
image on premise

00:20:04,000 --> 00:20:10,720
and then ships it to the csps registry

00:20:07,679 --> 00:20:12,559
afterwards he can rely on docker's run

00:20:10,720 --> 00:20:14,000
command infrastructure to create

00:20:12,559 --> 00:20:17,120
graphinized docker image

00:20:14,000 --> 00:20:18,640
images as usual

00:20:17,120 --> 00:20:20,159
in the second scenario the client

00:20:18,640 --> 00:20:23,600
uploads the application

00:20:20,159 --> 00:20:27,039
docker image subsequently

00:20:23,600 --> 00:20:29,520
she graphinizes the image via a csp's

00:20:27,039 --> 00:20:32,480
infrastructure interface

00:20:29,520 --> 00:20:32,960
and again afterwards may use a docker

00:20:32,480 --> 00:20:35,919
run

00:20:32,960 --> 00:20:37,360
command to deploy a graphinized docker

00:20:35,919 --> 00:20:40,320
image

00:20:37,360 --> 00:20:42,880
in this third scenario a client uploads

00:20:40,320 --> 00:20:45,840
his image again to the cloud's registry

00:20:42,880 --> 00:20:48,720
but instead the image is not translated

00:20:45,840 --> 00:20:51,679
via an api call to the csp

00:20:48,720 --> 00:20:53,919
the client directly runs the image

00:20:51,679 --> 00:20:56,799
specifying a runtime

00:20:53,919 --> 00:20:58,720
this runtime uses gsc to translate a

00:20:56,799 --> 00:21:00,400
regular image into a graphingized docker

00:20:58,720 --> 00:21:02,400
image on the fly

00:21:00,400 --> 00:21:04,480
this approach lowers the required

00:21:02,400 --> 00:21:07,760
changes in the client software

00:21:04,480 --> 00:21:10,159
to a minimal change to run the correct

00:21:07,760 --> 00:21:12,960
runtime

00:21:10,159 --> 00:21:14,960
before i show you a demo of gsc i'd like

00:21:12,960 --> 00:21:17,679
to provide an end-to-end use case

00:21:14,960 --> 00:21:18,320
that makes use of attestation protect fs

00:21:17,679 --> 00:21:21,039
and

00:21:18,320 --> 00:21:21,840
graphene shielded containers in this use

00:21:21,039 --> 00:21:24,960
case we use

00:21:21,840 --> 00:21:27,360
gsc to package and deploy graphene

00:21:24,960 --> 00:21:28,000
with an application in particular a pi

00:21:27,360 --> 00:21:31,360
towards

00:21:28,000 --> 00:21:32,880
object detection we assume the model the

00:21:31,360 --> 00:21:35,200
input and the output

00:21:32,880 --> 00:21:36,720
of the pi touch object detection to be

00:21:35,200 --> 00:21:38,640
secrets

00:21:36,720 --> 00:21:41,440
therefore the runtime has to first

00:21:38,640 --> 00:21:41,840
obtain a provision key to access the

00:21:41,440 --> 00:21:44,720
model

00:21:41,840 --> 00:21:45,919
and the input we do so by generating an

00:21:44,720 --> 00:21:48,799
attestation

00:21:45,919 --> 00:21:49,600
and sending it to the verifier after

00:21:48,799 --> 00:21:52,240
validating

00:21:49,600 --> 00:21:53,520
that station the verifier releases the

00:21:52,240 --> 00:21:56,400
provision key

00:21:53,520 --> 00:21:56,400
to the runtime

00:21:56,799 --> 00:22:00,640
we then use the provision keys to access

00:21:59,039 --> 00:22:03,679
the model and the input

00:22:00,640 --> 00:22:05,760
from the protected file system this

00:22:03,679 --> 00:22:06,400
allows graphene to transparently decrypt

00:22:05,760 --> 00:22:09,840
the inputs

00:22:06,400 --> 00:22:13,600
without a single application change

00:22:09,840 --> 00:22:16,480
pytorch then detects the objects within

00:22:13,600 --> 00:22:17,280
the input and generates an output or a

00:22:16,480 --> 00:22:20,000
decision

00:22:17,280 --> 00:22:20,559
the decision is then stored securely

00:22:20,000 --> 00:22:23,760
within

00:22:20,559 --> 00:22:25,760
the encrypted file system this use case

00:22:23,760 --> 00:22:27,679
combined various techniques to protect

00:22:25,760 --> 00:22:30,080
the confidentiality and integrity

00:22:27,679 --> 00:22:31,120
of the model the input data such as

00:22:30,080 --> 00:22:34,880
images

00:22:31,120 --> 00:22:38,240
and the inferred output from the

00:22:34,880 --> 00:22:40,080
model so now i will show a demonstration

00:22:38,240 --> 00:22:41,120
of graphene shielded containers we are

00:22:40,080 --> 00:22:44,240
graphinating

00:22:41,120 --> 00:22:45,520
the public dockrob image of python for

00:22:44,240 --> 00:22:50,000
the purpose of that

00:22:45,520 --> 00:22:52,640
we are specifying the gsc build command

00:22:50,000 --> 00:22:54,000
in this demonstration we are using

00:22:52,640 --> 00:22:56,320
insecure arguments but

00:22:54,000 --> 00:22:57,600
in technically you can specify trusted

00:22:56,320 --> 00:22:59,520
arguments as well

00:22:57,600 --> 00:23:02,320
we're graphing the python image and

00:22:59,520 --> 00:23:03,919
we're specifying a python manifest file

00:23:02,320 --> 00:23:06,000
in this manifest we're adding a single

00:23:03,919 --> 00:23:08,000
line to allow file creations which is

00:23:06,000 --> 00:23:10,559
required for pi cache to work

00:23:08,000 --> 00:23:11,520
we're then following the gse docker

00:23:10,559 --> 00:23:13,840
build

00:23:11,520 --> 00:23:14,960
process it first builds graphene and

00:23:13,840 --> 00:23:17,280
then copies over

00:23:14,960 --> 00:23:18,480
into the application image the required

00:23:17,280 --> 00:23:20,799
runtime arguments

00:23:18,480 --> 00:23:22,240
we are then copying over the docker run

00:23:20,799 --> 00:23:25,280
command that specifies the

00:23:22,240 --> 00:23:27,360
required sgx devices we're

00:23:25,280 --> 00:23:29,120
specifying the image gsc dash python

00:23:27,360 --> 00:23:31,200
which is the graphingized version

00:23:29,120 --> 00:23:32,799
in addition to a python arguments again

00:23:31,200 --> 00:23:34,799
those are insecure

00:23:32,799 --> 00:23:37,679
and we're basically printing hello linux

00:23:34,799 --> 00:23:41,600
security summit from an enclave

00:23:37,679 --> 00:23:44,320
we then start the container we specify

00:23:41,600 --> 00:23:45,120
where we see that the token was

00:23:44,320 --> 00:23:48,080
generated

00:23:45,120 --> 00:23:50,000
the fingerprint of the enclave and the

00:23:48,080 --> 00:23:52,559
fingerprint of the signer as shown

00:23:50,000 --> 00:23:53,520
and then graffina started with a

00:23:52,559 --> 00:23:56,080
manifest that was

00:23:53,520 --> 00:23:58,159
produced by gsc and they insecure

00:23:56,080 --> 00:24:00,159
arguments again

00:23:58,159 --> 00:24:02,320
you can use trusted arguments if that's

00:24:00,159 --> 00:24:04,000
required for your production environment

00:24:02,320 --> 00:24:06,400
now we should wait a couple of seconds

00:24:04,000 --> 00:24:09,760
and see that hello linux security summit

00:24:06,400 --> 00:24:09,760
was successfully printed

00:24:16,720 --> 00:24:20,559
i'd like to highlight the current and

00:24:18,320 --> 00:24:22,960
future directions of graphene

00:24:20,559 --> 00:24:24,559
graphene had its first major release

00:24:22,960 --> 00:24:25,120
last year and we are currently in the

00:24:24,559 --> 00:24:26,880
process

00:24:25,120 --> 00:24:29,200
of finishing our next release this

00:24:26,880 --> 00:24:33,279
release includes remote attestation

00:24:29,200 --> 00:24:36,080
exit lists system calls protected for fs

00:24:33,279 --> 00:24:38,640
machine shielded containers and secure

00:24:36,080 --> 00:24:41,760
multi-process support using encrypted

00:24:38,640 --> 00:24:44,159
ipc in addition graphene has been

00:24:41,760 --> 00:24:45,360
accepted to the confidential computing

00:24:44,159 --> 00:24:48,720
consortium

00:24:45,360 --> 00:24:50,240
which is part of the linux foundation

00:24:48,720 --> 00:24:52,400
thank you very much i would like to

00:24:50,240 --> 00:24:53,600
invite you to ask questions and i've put

00:24:52,400 --> 00:24:55,120
up a couple of links

00:24:53,600 --> 00:25:01,840
in case you want to know more about

00:24:55,120 --> 00:25:01,840
graphene thank you

00:25:03,200 --> 00:25:09,279
okay hello um well

00:25:06,640 --> 00:25:12,080
thank you for listening to the talk um

00:25:09,279 --> 00:25:14,559
i'm ano and beside me is dimitri

00:25:12,080 --> 00:25:15,200
um we'll go through your questions i

00:25:14,559 --> 00:25:17,600
will

00:25:15,200 --> 00:25:18,240
read the questions and then we will tag

00:25:17,600 --> 00:25:21,120
team on

00:25:18,240 --> 00:25:21,520
on answering them um so i think we the

00:25:21,120 --> 00:25:23,279
first

00:25:21,520 --> 00:25:24,640
uh elephant we need to address in the

00:25:23,279 --> 00:25:26,080
room is that and

00:25:24,640 --> 00:25:28,559
there was at least one question that i

00:25:26,080 --> 00:25:31,679
saw immediately is that um

00:25:28,559 --> 00:25:35,120
what do we do about recent flaws

00:25:31,679 --> 00:25:35,440
or um basically security vulnerabilities

00:25:35,120 --> 00:25:38,880
uh

00:25:35,440 --> 00:25:42,159
that were exposed to in intellect gx

00:25:38,880 --> 00:25:43,520
um and of course uh we and intel are

00:25:42,159 --> 00:25:44,720
very concerned about these security

00:25:43,520 --> 00:25:47,360
issues

00:25:44,720 --> 00:25:48,640
um but both of us are not the experts

00:25:47,360 --> 00:25:50,080
either in these attacks and the

00:25:48,640 --> 00:25:53,120
mitigations so i would

00:25:50,080 --> 00:25:56,000
um ask you to look at the security

00:25:53,120 --> 00:25:59,120
advisories that intel gives out

00:25:56,000 --> 00:26:01,679
to address those those issues

00:25:59,120 --> 00:26:02,480
okay so let's start with the first uh

00:26:01,679 --> 00:26:04,080
question

00:26:02,480 --> 00:26:06,480
i think is very interesting what are the

00:26:04,080 --> 00:26:08,159
open steps that still remain

00:26:06,480 --> 00:26:09,520
uh to transform it from a research

00:26:08,159 --> 00:26:13,360
project

00:26:09,520 --> 00:26:14,400
um to a production product um dimitri do

00:26:13,360 --> 00:26:18,640
you want to

00:26:14,400 --> 00:26:21,840
to take this one uh yes sure thanks

00:26:18,640 --> 00:26:22,480
uh so graphene is not yet production

00:26:21,840 --> 00:26:24,400
ready

00:26:22,480 --> 00:26:25,600
it's in the process of moving from a

00:26:24,400 --> 00:26:29,120
research artifact

00:26:25,600 --> 00:26:32,240
to an actual product uh one

00:26:29,120 --> 00:26:34,320
uh important thing to mention is on

00:26:32,240 --> 00:26:35,679
our github page where we do all our

00:26:34,320 --> 00:26:39,360
graphene development

00:26:35,679 --> 00:26:39,919
uh in the issues page we have some paint

00:26:39,360 --> 00:26:41,919
issues

00:26:39,919 --> 00:26:43,760
in particular there are production

00:26:41,919 --> 00:26:45,679
blockers they list

00:26:43,760 --> 00:26:48,480
all the things that we need to do prior

00:26:45,679 --> 00:26:52,400
to going into production

00:26:48,480 --> 00:26:53,760
uh some of the things that we still need

00:26:52,400 --> 00:26:56,960
to merge

00:26:53,760 --> 00:27:00,320
our uh uh

00:26:56,960 --> 00:27:01,600
protected file system so all all of the

00:27:00,320 --> 00:27:04,640
features that we mentioned

00:27:01,600 --> 00:27:05,520
they are almost ready and they will be

00:27:04,640 --> 00:27:08,080
there

00:27:05,520 --> 00:27:08,799
in several weeks in the mainline

00:27:08,080 --> 00:27:11,039
graphene

00:27:08,799 --> 00:27:12,000
like the protected file system the

00:27:11,039 --> 00:27:13,679
graphene

00:27:12,000 --> 00:27:16,320
shielded containers the integration with

00:27:13,679 --> 00:27:18,640
docker and we also need to add

00:27:16,320 --> 00:27:19,440
more examples and more end-to-end

00:27:18,640 --> 00:27:22,559
examples

00:27:19,440 --> 00:27:23,600
for graphene and we hope to finish this

00:27:22,559 --> 00:27:26,799
work in

00:27:23,600 --> 00:27:26,799
in the next couple months

00:27:27,120 --> 00:27:31,600
but you can always check the current

00:27:29,520 --> 00:27:36,640
status of graphene productization

00:27:31,600 --> 00:27:36,640
on our github page yes

00:27:36,720 --> 00:27:40,320
okay um next question how does graphene

00:27:39,440 --> 00:27:42,960
a certain

00:27:40,320 --> 00:27:43,679
detect malicious system calls i think

00:27:42,960 --> 00:27:46,320
that's also

00:27:43,679 --> 00:27:47,120
something dimitri can answer very well

00:27:46,320 --> 00:27:49,679
yes

00:27:47,120 --> 00:27:51,520
so first of all graphene is a kind of

00:27:49,679 --> 00:27:54,559
one-way sandbox

00:27:51,520 --> 00:27:55,600
uh and uh if i understand the question

00:27:54,559 --> 00:27:57,600
right it's more about

00:27:55,600 --> 00:27:58,880
jago attacks so first thing to

00:27:57,600 --> 00:28:00,880
understand is that

00:27:58,880 --> 00:28:02,960
when you load an application inside

00:28:00,880 --> 00:28:05,679
graphene inside an sgx enclave

00:28:02,960 --> 00:28:07,279
the application can do whatever it wants

00:28:05,679 --> 00:28:09,279
technically

00:28:07,279 --> 00:28:10,559
so if the application is buggy or

00:28:09,279 --> 00:28:14,000
somehow malicious

00:28:10,559 --> 00:28:16,480
and it creates it

00:28:14,000 --> 00:28:18,320
issues malicious system call requests to

00:28:16,480 --> 00:28:20,720
a host operating system

00:28:18,320 --> 00:28:22,960
then uh this is something that graphene

00:28:20,720 --> 00:28:26,000
and indeed sgx does not protect

00:28:22,960 --> 00:28:28,480
at all so the assumption is that

00:28:26,000 --> 00:28:30,880
the application that you run inside

00:28:28,480 --> 00:28:33,440
graphene and inside of an enclave

00:28:30,880 --> 00:28:34,320
is bug free and correct and you check it

00:28:33,440 --> 00:28:36,960
via remote

00:28:34,320 --> 00:28:37,679
station so and then there is another

00:28:36,960 --> 00:28:41,200
problem

00:28:37,679 --> 00:28:43,600
what happens if the application issues a

00:28:41,200 --> 00:28:45,919
correct system call

00:28:43,600 --> 00:28:48,320
but the host operating system is

00:28:45,919 --> 00:28:49,919
malicious and it returns some incorrect

00:28:48,320 --> 00:28:53,039
return values

00:28:49,919 --> 00:28:54,799
and this is what the graphene library

00:28:53,039 --> 00:28:58,000
operating system does

00:28:54,799 --> 00:29:01,360
it kind of shadows all uh system

00:28:58,000 --> 00:29:04,880
resources it manages its own uh

00:29:01,360 --> 00:29:06,080
memory vmas uh it verifies all network

00:29:04,880 --> 00:29:09,360
connections

00:29:06,080 --> 00:29:10,720
uh and all files uh created and used by

00:29:09,360 --> 00:29:13,919
graphene

00:29:10,720 --> 00:29:14,640
so yes we have this additional layer of

00:29:13,919 --> 00:29:17,600
protection

00:29:14,640 --> 00:29:19,279
against malicious return values from

00:29:17,600 --> 00:29:21,919
system calls

00:29:19,279 --> 00:29:27,279
that's kind of the whole purpose of the

00:29:21,919 --> 00:29:29,200
library os layer

00:29:27,279 --> 00:29:30,480
okay i was looking through more

00:29:29,200 --> 00:29:34,240
questions

00:29:30,480 --> 00:29:38,240
um the next question is can we use

00:29:34,240 --> 00:29:41,120
sgx or elaborate if intel me is disabled

00:29:38,240 --> 00:29:42,159
and i think the the simple answer is yes

00:29:41,120 --> 00:29:44,640
but

00:29:42,159 --> 00:29:46,159
there are a couple of um features like

00:29:44,640 --> 00:29:50,159
the monotony counters

00:29:46,159 --> 00:29:53,520
which are supported only through the me

00:29:50,159 --> 00:29:54,880
um and if whatever

00:29:53,520 --> 00:29:56,880
application you're building is using

00:29:54,880 --> 00:29:58,399
those features you would not be able to

00:29:56,880 --> 00:30:00,480
make use of them

00:29:58,399 --> 00:30:02,000
um as far as i know graphene does not

00:30:00,480 --> 00:30:05,279
rely on any of those

00:30:02,000 --> 00:30:07,039
but i'm sure that dimitri has maybe has

00:30:05,279 --> 00:30:09,679
another comment

00:30:07,039 --> 00:30:10,399
yeah this is correct uh graphene does

00:30:09,679 --> 00:30:14,000
not rely

00:30:10,399 --> 00:30:16,720
on intel me in any way and none of the

00:30:14,000 --> 00:30:19,120
additional libraries and like sgx

00:30:16,720 --> 00:30:23,360
infrastructure that graphene relies on

00:30:19,120 --> 00:30:25,760
it does not use intel me

00:30:23,360 --> 00:30:27,279
okay um next question would be can

00:30:25,760 --> 00:30:30,640
graphene load executables

00:30:27,279 --> 00:30:32,559
from uh the network or more specifically

00:30:30,640 --> 00:30:35,120
why are pass specified with

00:30:32,559 --> 00:30:38,320
file colon slash in the i think this is

00:30:35,120 --> 00:30:38,320
related to the manifest

00:30:38,399 --> 00:30:41,919
um i think dimitri do you want to to

00:30:41,200 --> 00:30:45,039
answer this one

00:30:41,919 --> 00:30:47,520
as well yes sure um

00:30:45,039 --> 00:30:48,640
so yes this is a manifest syntax all

00:30:47,520 --> 00:30:51,760
paths

00:30:48,640 --> 00:30:54,320
are prefix with either file or def

00:30:51,760 --> 00:30:55,679
at the moment uh the idea is that

00:30:54,320 --> 00:30:59,279
graphene works

00:30:55,679 --> 00:31:03,039
the graphene manifest uh uh specifies

00:30:59,279 --> 00:31:05,200
uris uh so universal resource like kind

00:31:03,039 --> 00:31:08,399
of descriptors identifiers

00:31:05,200 --> 00:31:11,440
so technically it can be not only

00:31:08,399 --> 00:31:12,399
a regular file on your file system it

00:31:11,440 --> 00:31:15,440
can also be

00:31:12,399 --> 00:31:16,080
a url for example from the network or a

00:31:15,440 --> 00:31:20,320
device

00:31:16,080 --> 00:31:23,440
so network uh urls are not supported yet

00:31:20,320 --> 00:31:26,480
uh but we have files and uh

00:31:23,440 --> 00:31:29,600
devices supported and devices it's a

00:31:26,480 --> 00:31:32,080
it's another story um uh

00:31:29,600 --> 00:31:35,200
it's it's not a complete support for now

00:31:32,080 --> 00:31:35,200
but we're working on this

00:31:36,559 --> 00:31:44,559
okay and i guess i should say that

00:31:41,200 --> 00:31:46,799
99 of the time currently uh

00:31:44,559 --> 00:31:50,000
you just need to use this file prefix

00:31:46,799 --> 00:31:50,000
and use regular files

00:31:58,960 --> 00:32:02,960
um i'm not sure dimitri do you want to

00:32:02,159 --> 00:32:06,960
say anything else

00:32:02,960 --> 00:32:10,399
i i guess the answer is just no

00:32:06,960 --> 00:32:11,360
uh just now yeah this is something we're

00:32:10,399 --> 00:32:14,720
actually looking

00:32:11,360 --> 00:32:18,480
for towards the path of production

00:32:14,720 --> 00:32:18,480
or production readiness right

00:32:18,640 --> 00:32:26,880
um this question we can ignore

00:32:23,120 --> 00:32:28,480
um what are the most common obstacles

00:32:26,880 --> 00:32:32,080
when porting applications to

00:32:28,480 --> 00:32:35,279
graphene um

00:32:32,080 --> 00:32:35,840
that's a very interesting question i

00:32:35,279 --> 00:32:37,440
have

00:32:35,840 --> 00:32:39,279
when i joined the project graphene was

00:32:37,440 --> 00:32:42,480
already in a relatively good state

00:32:39,279 --> 00:32:45,360
um since then i personally have not

00:32:42,480 --> 00:32:48,720
really found big obstacles

00:32:45,360 --> 00:32:51,760
um i think one maybe to mention is that

00:32:48,720 --> 00:32:55,039
some um runtime languages like

00:32:51,760 --> 00:32:55,600
go they require a different memory

00:32:55,039 --> 00:32:58,480
layout

00:32:55,600 --> 00:33:00,880
or more freedomness in the memory layout

00:32:58,480 --> 00:33:01,519
and have specific addresses in in their

00:33:00,880 --> 00:33:04,320
um

00:33:01,519 --> 00:33:06,880
in their runtime environment um at which

00:33:04,320 --> 00:33:09,360
point enclave sizes just become too big

00:33:06,880 --> 00:33:10,399
um to be able to allocate such an

00:33:09,360 --> 00:33:13,840
address

00:33:10,399 --> 00:33:14,960
um which is i guess a current um

00:33:13,840 --> 00:33:17,519
a current limitation of the

00:33:14,960 --> 00:33:19,440
implementation of graphene um

00:33:17,519 --> 00:33:20,559
since it does not have this dynamic

00:33:19,440 --> 00:33:24,240
memory allocation that

00:33:20,559 --> 00:33:25,679
newer sgx versions allow um i don't know

00:33:24,240 --> 00:33:26,320
dimitri do you want to make any more

00:33:25,679 --> 00:33:30,640
specific

00:33:26,320 --> 00:33:34,480
comments uh a couple more comments yes

00:33:30,640 --> 00:33:37,519
uh first on our github page again

00:33:34,480 --> 00:33:40,000
we have the examples directory

00:33:37,519 --> 00:33:41,519
where we have a kind of curated uh set

00:33:40,000 --> 00:33:44,559
of applications so you can

00:33:41,519 --> 00:33:45,440
uh check this list uh and it also

00:33:44,559 --> 00:33:47,919
explains

00:33:45,440 --> 00:33:49,360
uh these are good examples to understand

00:33:47,919 --> 00:33:50,240
how graphene works and how to port

00:33:49,360 --> 00:33:53,840
applications

00:33:50,240 --> 00:33:56,880
to graphene and um

00:33:53,840 --> 00:34:00,960
one general observation

00:33:56,880 --> 00:34:03,519
is that um some applications

00:34:00,960 --> 00:34:04,880
that kind of abuse multi-processing

00:34:03,519 --> 00:34:08,560
paradigm

00:34:04,880 --> 00:34:11,599
uh can be either very slow

00:34:08,560 --> 00:34:14,560
uh because there is no such thing as

00:34:11,599 --> 00:34:15,440
a copy on write in sgx so whenever you

00:34:14,560 --> 00:34:18,879
do a fork

00:34:15,440 --> 00:34:21,200
or a clone you have to copy the whole

00:34:18,879 --> 00:34:23,200
sjx enclave memory state from one

00:34:21,200 --> 00:34:26,079
graphene instance to another

00:34:23,200 --> 00:34:27,359
so you can't see significant performance

00:34:26,079 --> 00:34:30,639
overheads when you

00:34:27,359 --> 00:34:33,119
use something like bash scripts uh

00:34:30,639 --> 00:34:34,800
and another interesting point is that

00:34:33,119 --> 00:34:38,159
graphene

00:34:34,800 --> 00:34:41,679
has to encrypt all communication

00:34:38,159 --> 00:34:44,800
uh for example on pi on pipes and fifos

00:34:41,679 --> 00:34:46,399
and unix domain sockets so in some

00:34:44,800 --> 00:34:49,919
applications for example in

00:34:46,399 --> 00:34:53,200
erlang they actually use like several

00:34:49,919 --> 00:34:55,679
processes trying to write on one pipe

00:34:53,200 --> 00:34:57,599
and of course uh like tls encryption

00:34:55,679 --> 00:35:00,800
which we use to encrypt pipes

00:34:57,599 --> 00:35:02,640
cannot work on many writers

00:35:00,800 --> 00:35:04,560
so this is another interesting

00:35:02,640 --> 00:35:07,680
observation luckily

00:35:04,560 --> 00:35:09,280
that was only one erlang example

00:35:07,680 --> 00:35:10,480
we haven't seen any other applications

00:35:09,280 --> 00:35:14,000
that have used the kind of

00:35:10,480 --> 00:35:14,000
multi-processing paradigm

00:35:15,520 --> 00:35:20,240
other than that it's just a matter of

00:35:17,760 --> 00:35:21,280
box and some unimplemented functionality

00:35:20,240 --> 00:35:25,920
in graphene

00:35:21,280 --> 00:35:25,920
but we're slowly fixing them one by one

00:35:28,079 --> 00:35:32,480
um next question would be how does it

00:35:30,000 --> 00:35:36,000
integrate with kubernetes

00:35:32,480 --> 00:35:36,480
um so most of these docker images they

00:35:36,000 --> 00:35:39,440
would

00:35:36,480 --> 00:35:40,160
integrate nicely with with kubernetes um

00:35:39,440 --> 00:35:41,760
one of the

00:35:40,160 --> 00:35:44,240
issues that you have with kubernetes

00:35:41,760 --> 00:35:47,440
currently is that it does not provide

00:35:44,240 --> 00:35:49,839
the sjx devices to the container itself

00:35:47,440 --> 00:35:51,440
um as you saw in my docker run command i

00:35:49,839 --> 00:35:52,640
actually specified the devices to be

00:35:51,440 --> 00:35:54,800
handed to the container

00:35:52,640 --> 00:35:56,839
otherwise the sdx devices are not

00:35:54,800 --> 00:35:59,440
available

00:35:56,839 --> 00:36:01,680
um and

00:35:59,440 --> 00:36:04,000
that is a requirement that you have to

00:36:01,680 --> 00:36:06,640
add via an extension a device extension

00:36:04,000 --> 00:36:08,640
currently um which is not upstreamed so

00:36:06,640 --> 00:36:10,880
if you wanted to run anything like this

00:36:08,640 --> 00:36:12,160
in a kubernetes cluster you would have

00:36:10,880 --> 00:36:15,119
to get an out of tree

00:36:12,160 --> 00:36:16,320
uh device extension i know that there

00:36:15,119 --> 00:36:19,200
are people working on this

00:36:16,320 --> 00:36:20,720
um to improve upon this situation but um

00:36:19,200 --> 00:36:22,720
i think that's the situation right now

00:36:20,720 --> 00:36:26,320
so we'll have to wait

00:36:22,720 --> 00:36:28,640
um for this to resolve

00:36:26,320 --> 00:36:29,440
um next question is how does graphene

00:36:28,640 --> 00:36:31,839
work

00:36:29,440 --> 00:36:32,960
with limitations that can be used in

00:36:31,839 --> 00:36:35,440
containers

00:36:32,960 --> 00:36:36,480
like resource limitations device

00:36:35,440 --> 00:36:39,520
limitations

00:36:36,480 --> 00:36:44,160
c groups syscall limitations via second

00:36:39,520 --> 00:36:44,160
or other limitations um

00:36:45,520 --> 00:36:50,640
so i'm not 100 sure that i fully

00:36:48,320 --> 00:36:53,040
understand the question

00:36:50,640 --> 00:36:54,720
graphene itself only sees what is

00:36:53,040 --> 00:36:57,680
available to that container

00:36:54,720 --> 00:36:59,119
so if you have um external resource

00:36:57,680 --> 00:37:03,040
limitations like

00:36:59,119 --> 00:37:06,079
using less cpu cores or um

00:37:03,040 --> 00:37:08,000
memory limitations then graphene

00:37:06,079 --> 00:37:10,240
would basically take that from whatever

00:37:08,000 --> 00:37:13,680
the container saw

00:37:10,240 --> 00:37:15,680
um i'm

00:37:13,680 --> 00:37:17,440
cisco limitations would apply similarly

00:37:15,680 --> 00:37:17,920
right if you have a second filter for

00:37:17,440 --> 00:37:22,000
your

00:37:17,920 --> 00:37:25,200
um docker container then that applies to

00:37:22,000 --> 00:37:27,440
graphene itself um

00:37:25,200 --> 00:37:28,640
so yeah i since we're running sort of

00:37:27,440 --> 00:37:30,720
inside the container

00:37:28,640 --> 00:37:32,560
we're not bypassing any of these

00:37:30,720 --> 00:37:36,000
limitations

00:37:32,560 --> 00:37:36,960
let me try do you want to add i i don't

00:37:36,000 --> 00:37:38,560
know

00:37:36,960 --> 00:37:41,599
i think we have not particularly played

00:37:38,560 --> 00:37:44,160
around with these things so it's

00:37:41,599 --> 00:37:44,800
yeah i just want to stress again that

00:37:44,160 --> 00:37:48,000
graphene

00:37:44,800 --> 00:37:48,880
and sjx enclaves in general they work as

00:37:48,000 --> 00:37:52,400
a

00:37:48,880 --> 00:37:56,000
one-way sandbox so they protect only the

00:37:52,400 --> 00:37:59,119
enclave that from the underlying

00:37:56,000 --> 00:38:02,000
host operating system

00:37:59,119 --> 00:38:03,040
and whatever the host provides or

00:38:02,000 --> 00:38:04,800
restricts

00:38:03,040 --> 00:38:06,320
that will be seen by the application

00:38:04,800 --> 00:38:07,839
running inside graphene inside the

00:38:06,320 --> 00:38:09,760
enclave

00:38:07,839 --> 00:38:12,079
so if for example the host operating

00:38:09,760 --> 00:38:13,920
system restricts a system call or some

00:38:12,079 --> 00:38:16,480
arguments of system calls

00:38:13,920 --> 00:38:18,400
the asset comp then graphene will simply

00:38:16,480 --> 00:38:22,320
see okay this system call

00:38:18,400 --> 00:38:22,320
is not available in the system

00:38:24,480 --> 00:38:29,359
thanks do you have any numbers

00:38:27,760 --> 00:38:31,280
of performance overhead when running

00:38:29,359 --> 00:38:34,440
graphing containers

00:38:31,280 --> 00:38:35,920
any other restrictions like image size

00:38:34,440 --> 00:38:38,960
[Music]

00:38:35,920 --> 00:38:41,190
so i think i don't have any performance

00:38:38,960 --> 00:38:43,520
overheads out of the top of my head

00:38:41,190 --> 00:38:46,880
[Music]

00:38:43,520 --> 00:38:49,200
especially for graphinized containers

00:38:46,880 --> 00:38:51,280
i'm not sure we can cite some something

00:38:49,200 --> 00:38:54,720
for sgx

00:38:51,280 --> 00:38:55,520
restrictions for image size there is not

00:38:54,720 --> 00:38:58,160
really one

00:38:55,520 --> 00:38:59,040
um it i mean the performance highly

00:38:58,160 --> 00:39:02,160
depends on

00:38:59,040 --> 00:39:04,240
your working set size because

00:39:02,160 --> 00:39:05,680
like existing machines today have a

00:39:04,240 --> 00:39:07,920
limitation on

00:39:05,680 --> 00:39:09,440
available cached memory secure cache

00:39:07,920 --> 00:39:12,960
memory

00:39:09,440 --> 00:39:14,560
so the moment you have bigger let's say

00:39:12,960 --> 00:39:16,560
machine learning models of course the

00:39:14,560 --> 00:39:19,760
performance is going to decrease

00:39:16,560 --> 00:39:20,960
um yes i don't know if dimitri do you

00:39:19,760 --> 00:39:22,720
want to

00:39:20,960 --> 00:39:24,000
say anything about performance overheads

00:39:22,720 --> 00:39:29,839
with graphene

00:39:24,000 --> 00:39:29,839
i think it's regular sgx based

00:39:30,960 --> 00:39:34,960
exactly yeah the main bottleneck will be

00:39:33,040 --> 00:39:38,240
the sjx performance

00:39:34,960 --> 00:39:40,640
and we cannot comment on the performance

00:39:38,240 --> 00:39:40,640
right now

00:39:44,960 --> 00:39:48,880
what mitigations does graphene provide

00:39:47,040 --> 00:39:52,400
against side channels

00:39:48,880 --> 00:39:56,400
maybe that's a question we can um

00:39:52,400 --> 00:39:59,520
yeah and attack sandbox application yeah

00:39:56,400 --> 00:40:00,560
okay so i i think we're not doing

00:39:59,520 --> 00:40:03,839
anything

00:40:00,560 --> 00:40:06,240
um specific in graphene against these

00:40:03,839 --> 00:40:07,280
side channels so again i would refer you

00:40:06,240 --> 00:40:10,319
to the

00:40:07,280 --> 00:40:12,800
intel advisories um against these side

00:40:10,319 --> 00:40:12,800
channels

00:40:13,119 --> 00:40:18,240
um how does graphene compare to anarchs

00:40:18,480 --> 00:40:23,200
dimitri any comments on comparisons to

00:40:21,280 --> 00:40:26,400
anarchs

00:40:23,200 --> 00:40:27,040
uh to be honest we didn't look into an

00:40:26,400 --> 00:40:30,960
arcs

00:40:27,040 --> 00:40:33,040
we are not aware of its current state so

00:40:30,960 --> 00:40:35,040
no comments i guess yes but so i think

00:40:33,040 --> 00:40:36,079
one one part to mention is that anarchs

00:40:35,040 --> 00:40:39,200
works on

00:40:36,079 --> 00:40:43,200
um wasm um binaries right

00:40:39,200 --> 00:40:46,880
so there is a huge huge difference in

00:40:43,200 --> 00:40:48,240
um legacy compatibility i guess because

00:40:46,880 --> 00:40:52,400
you have to recompile two

00:40:48,240 --> 00:40:56,000
wasn't binaries other than that i'm i'm

00:40:52,400 --> 00:40:56,000
not aware of their feature set as well

00:40:56,960 --> 00:41:00,240
um sgx hasn't yet landed in lynx

00:40:59,280 --> 00:41:02,800
upstream

00:41:00,240 --> 00:41:04,480
is this at all being done using out of

00:41:02,800 --> 00:41:06,640
three drivers

00:41:04,480 --> 00:41:08,079
i think the simple answer is yes that's

00:41:06,640 --> 00:41:12,800
currently the only way to

00:41:08,079 --> 00:41:17,280
to use graphene to use either the um

00:41:12,800 --> 00:41:19,359
the client driver or the d-cap driver um

00:41:17,280 --> 00:41:22,960
yes and our hope of course is that this

00:41:19,359 --> 00:41:22,960
driver will eventually be upstreamed

00:41:24,240 --> 00:41:29,599
yes any more comments from your side

00:41:25,760 --> 00:41:33,119
dimitri i don't think okay i guess

00:41:29,599 --> 00:41:37,680
no no comments yes all the work is done

00:41:33,119 --> 00:41:40,720
with out of three drivers yes

00:41:37,680 --> 00:41:43,119
is it possible to publish

00:41:40,720 --> 00:41:45,119
in docker hub a secure image created by

00:41:43,119 --> 00:41:48,319
graphene

00:41:45,119 --> 00:41:49,839
um so in its current form such a secure

00:41:48,319 --> 00:41:50,640
image what you're saying would only

00:41:49,839 --> 00:41:52,240
protect the

00:41:50,640 --> 00:41:54,079
integrity not necessarily the

00:41:52,240 --> 00:41:58,000
confidentiality of the image

00:41:54,079 --> 00:42:00,480
so you may or may not want to do that um

00:41:58,000 --> 00:42:01,359
but you could publish whatever gse

00:42:00,480 --> 00:42:04,720
produces

00:42:01,359 --> 00:42:07,860
on on docker hub there is no restriction

00:42:04,720 --> 00:42:11,019
on not doing so um

00:42:07,860 --> 00:42:11,019
[Music]

00:42:15,359 --> 00:42:19,599
um if your host is compromised in any

00:42:18,560 --> 00:42:21,599
way

00:42:19,599 --> 00:42:23,599
like the kernels compromise or docker

00:42:21,599 --> 00:42:26,720
has a security hole would graphene with

00:42:23,599 --> 00:42:28,560
sgx be able to protect the data

00:42:26,720 --> 00:42:31,200
i think that's sort of an interesting

00:42:28,560 --> 00:42:33,200
question because it relates to the sgx

00:42:31,200 --> 00:42:35,680
threat model

00:42:33,200 --> 00:42:36,400
um the basic idea is that the data

00:42:35,680 --> 00:42:38,720
inside

00:42:36,400 --> 00:42:39,920
your your enclave would be protected

00:42:38,720 --> 00:42:42,240
against uh

00:42:39,920 --> 00:42:43,440
access accesses by outside components

00:42:42,240 --> 00:42:47,200
right that's the entire

00:42:43,440 --> 00:42:51,040
purpose of of intel sgx

00:42:47,200 --> 00:42:53,440
um yes i'm

00:42:51,040 --> 00:42:54,640
yeah limited do you want to say

00:42:53,440 --> 00:42:58,400
additional

00:42:54,640 --> 00:43:01,359
comments on that well the whole

00:42:58,400 --> 00:43:02,079
idea of intellect gx and graphene is to

00:43:01,359 --> 00:43:04,720
protect

00:43:02,079 --> 00:43:06,000
from the untrusted possibly malicious

00:43:04,720 --> 00:43:08,880
operating system

00:43:06,000 --> 00:43:13,040
the kernel and any other compromised

00:43:08,880 --> 00:43:15,119
applications running on the same system

00:43:13,040 --> 00:43:18,240
yes so i'm not sure about time i think

00:43:15,119 --> 00:43:20,240
we're probably running out of time

00:43:18,240 --> 00:43:21,920
um so we will be available on slack

00:43:20,240 --> 00:43:23,760
definitely afterwards

00:43:21,920 --> 00:43:25,200
but maybe there is one minute question

00:43:23,760 --> 00:43:28,640
left

00:43:25,200 --> 00:43:31,119
yeah one last question

00:43:28,640 --> 00:43:31,119
um

00:43:33,359 --> 00:43:37,760
oh maybe what uh what all oss container

00:43:37,200 --> 00:43:40,400
software

00:43:37,760 --> 00:43:45,280
has been tested on graphene redis cache

00:43:40,400 --> 00:43:48,720
nginx memcache.net core runtime

00:43:45,280 --> 00:43:51,680
so with gsc in particular we have tested

00:43:48,720 --> 00:43:53,760
nginx python public images they work out

00:43:51,680 --> 00:43:56,400
of the box

00:43:53,760 --> 00:43:58,160
we have tested the pytorch example from

00:43:56,400 --> 00:44:02,079
graphene

00:43:58,160 --> 00:44:04,480
um the numpy example that's for gsc

00:44:02,079 --> 00:44:05,599
the list for graphene is much much

00:44:04,480 --> 00:44:08,880
bigger

00:44:05,599 --> 00:44:11,440
and i guess the best thing is to go to

00:44:08,880 --> 00:44:13,119
the examples uh folder in the github

00:44:11,440 --> 00:44:16,560
repo

00:44:13,119 --> 00:44:20,560
those are the ones that are actively

00:44:16,560 --> 00:44:21,920
tested most of the time um

00:44:20,560 --> 00:44:24,079
yes i don't know the imagery do we want

00:44:21,920 --> 00:44:25,040
to highlight uh i mean out of the list

00:44:24,079 --> 00:44:29,319
that you specify

00:44:25,040 --> 00:44:31,280
redis works and the next works

00:44:29,319 --> 00:44:35,680
memcacheworks.net core runtime

00:44:31,280 --> 00:44:35,680
i'm not sure we have tried

00:44:37,359 --> 00:44:41,440
i'm not sure graphene is currently

00:44:39,119 --> 00:44:44,400
running only on linux

00:44:41,440 --> 00:44:46,560
only on linux yeah um do you want to

00:44:44,400 --> 00:44:51,119
mention any other

00:44:46,560 --> 00:44:54,720
application maybe uh

00:44:51,119 --> 00:44:56,480
uh one of his strong like one of the

00:44:54,720 --> 00:44:58,880
advantages of graphene is that it

00:44:56,480 --> 00:44:59,760
works with multi-processing applications

00:44:58,880 --> 00:45:01,680
most of them

00:44:59,760 --> 00:45:03,760
so you can easily run python scripts

00:45:01,680 --> 00:45:05,359
bash scripts gcc

00:45:03,760 --> 00:45:07,760
for example which does a lot of

00:45:05,359 --> 00:45:10,880
multi-processing stuff underneath

00:45:07,760 --> 00:45:11,760
so we also just tested these kinds of

00:45:10,880 --> 00:45:14,400
applications

00:45:11,760 --> 00:45:14,400
they work

00:45:16,400 --> 00:45:19,920
okay yes i'm not sure if we're going to

00:45:18,640 --> 00:45:22,720
be thrown out

00:45:19,920 --> 00:45:24,720
otherwise we'll just continue uh

00:45:22,720 --> 00:45:28,880
answering questions

00:45:24,720 --> 00:45:32,000
um no i think we're done

00:45:28,880 --> 00:45:34,880
we're done oh yeah no time time

00:45:32,000 --> 00:45:35,599
to wrap up okay um yeah so well thanks

00:45:34,880 --> 00:45:38,880
again

00:45:35,599 --> 00:45:39,839
um we will answer questions that you

00:45:38,880 --> 00:45:41,680
have on slack

00:45:39,839 --> 00:45:43,680
i will probably post the remaining

00:45:41,680 --> 00:45:44,800
questions um there as well and a couple

00:45:43,680 --> 00:45:46,560
of answers

00:45:44,800 --> 00:45:48,800
um just ping us on slack if you have

00:45:46,560 --> 00:45:52,000
anything else

00:45:48,800 --> 00:45:52,000
yeah so thanks again

00:45:52,079 --> 00:46:01,520

YouTube URL: https://www.youtube.com/watch?v=I8p9sLFr-GI


