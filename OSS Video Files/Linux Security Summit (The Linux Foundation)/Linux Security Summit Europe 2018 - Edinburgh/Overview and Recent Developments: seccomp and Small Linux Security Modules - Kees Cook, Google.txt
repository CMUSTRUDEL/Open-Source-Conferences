Title: Overview and Recent Developments: seccomp and Small Linux Security Modules - Kees Cook, Google
Publication date: 2018-10-27
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Overview and Recent Developments: seccomp and Small Linux Security Modules - Kees Cook, GoogleÂ 

This will give a crash course in the history and usage of three areas of Linux kernel security: the seccomp syscall filtering subsystem, the Yama ptrace-restriction LSM, and the LoadPin kernel-file-reading restriction LSM. 

About Kees Cook
Kees Cook has been working with Free Software since 1994, and has been a Debian Developer since 2007. He is currently employed as a Linux kernel security engineer by Google, working on Android and and Chrome OS. From 2006 through 2011 he worked for Canonical as the Ubuntu Security Team's Tech Lead, and remains on the Ubuntu Technical Board. Before that, he worked as the lead sysadmin at OSDL, before it was the Linux Foundation. He has written various utilities including GOPchop and Sendpage, and contributes randomly to other projects including fun chunks of code in OpenSSH, Inkscape, Wine, MPlayer, and Wireshark. He's been spending most of his time lately focused on security features in the Linux Kernel.
Captions: 
	00:00:00,750 --> 00:00:07,410
howdy my name's case so as mentioned

00:00:04,589 --> 00:00:14,309
this is about SEC comp which is not an

00:00:07,410 --> 00:00:15,269
LS M and all the small Ellison's there's

00:00:14,309 --> 00:00:18,420
going to be a little bit of background

00:00:15,269 --> 00:00:20,730
to distinguish these the the two then

00:00:18,420 --> 00:00:24,750
I'll get into a quick overview of load

00:00:20,730 --> 00:00:27,869
pin and Yama and finally set comp

00:00:24,750 --> 00:00:32,759
which is a bit more complex than the

00:00:27,869 --> 00:00:36,180
others so as you've already seen there's

00:00:32,759 --> 00:00:39,960
a bunch of the larger LSMs it exists in

00:00:36,180 --> 00:00:42,780
the kernel and the way I sort of look at

00:00:39,960 --> 00:00:45,030
it is they have you know a comprehensive

00:00:42,780 --> 00:00:48,420
policy their full-blown mandatory access

00:00:45,030 --> 00:00:51,020
control systems they mediate all kinds

00:00:48,420 --> 00:00:54,570
of different things files networks etc

00:00:51,020 --> 00:00:58,469
and the the small or minor LSMs have a

00:00:54,570 --> 00:01:05,250
really really narrow policy and they're

00:00:58,469 --> 00:01:11,130
usually a fixed policy so the first of

00:01:05,250 --> 00:01:14,909
these is is load pit easy to turn on so

00:01:11,130 --> 00:01:19,380
the main the main use for load pin is if

00:01:14,909 --> 00:01:23,670
you have if you think module cig force

00:01:19,380 --> 00:01:25,049
which is your resulting kernel will only

00:01:23,670 --> 00:01:28,320
load modules that have been

00:01:25,049 --> 00:01:31,290
cryptographically signed it will refuse

00:01:28,320 --> 00:01:33,229
to load anything else if you feel that

00:01:31,290 --> 00:01:36,450
that is redundant in your environment

00:01:33,229 --> 00:01:38,520
load pin is for you the idea being that

00:01:36,450 --> 00:01:41,220
if you already have a trusted file

00:01:38,520 --> 00:01:42,930
system that you cryptographically signed

00:01:41,220 --> 00:01:45,630
all the way down from your you know

00:01:42,930 --> 00:01:48,030
River trust you have all the bells and

00:01:45,630 --> 00:01:51,899
whistles that you've heard about in in

00:01:48,030 --> 00:01:53,780
some of the other presentations you know

00:01:51,899 --> 00:01:56,310
with various signing and other things

00:01:53,780 --> 00:01:58,829
but you probably don't need the kernel

00:01:56,310 --> 00:02:01,140
to have you know you don't need to waste

00:01:58,829 --> 00:02:04,189
the storage space of signatures on the

00:02:01,140 --> 00:02:06,479
modules and waste the CPU space of

00:02:04,189 --> 00:02:08,369
checking the signature on the thing you

00:02:06,479 --> 00:02:12,629
already checked that a file system level

00:02:08,369 --> 00:02:13,430
is correct and so load pins simply make

00:02:12,629 --> 00:02:16,129
sure

00:02:13,430 --> 00:02:18,170
that what you're loading from on the

00:02:16,129 --> 00:02:20,599
kernel side actually came from the file

00:02:18,170 --> 00:02:24,709
system you have cryptographically been

00:02:20,599 --> 00:02:26,750
checking in some way Chrome OS uses us

00:02:24,709 --> 00:02:28,849
with DM Verity because the embarras

00:02:26,750 --> 00:02:33,109
already done the block level analysis to

00:02:28,849 --> 00:02:35,090
say that everything is okay and benefit

00:02:33,109 --> 00:02:37,459
of having this as an LS m hook these you

00:02:35,090 --> 00:02:39,200
actually load pin can check things

00:02:37,459 --> 00:02:41,000
beyond just modules there's a lot of

00:02:39,200 --> 00:02:42,829
other stuff that the kernel reads out of

00:02:41,000 --> 00:02:45,799
file systems that it uses it's for users

00:02:42,829 --> 00:02:49,340
for its own purpose for example you know

00:02:45,799 --> 00:02:51,590
k executive the other kernel loading

00:02:49,340 --> 00:02:53,750
firmware into various things security

00:02:51,590 --> 00:02:55,939
policies certificates there's a whole

00:02:53,750 --> 00:02:58,030
bunch of stuff that the curl uses for

00:02:55,939 --> 00:03:01,280
itself that it gets off of a file system

00:02:58,030 --> 00:03:04,189
there's no reason to do a verification

00:03:01,280 --> 00:03:05,689
oh do a sedition 'el signature check

00:03:04,189 --> 00:03:09,799
when you may have already done that in

00:03:05,689 --> 00:03:10,419
the past already load pin is pretty

00:03:09,799 --> 00:03:12,889
stable

00:03:10,419 --> 00:03:15,409
perhaps because only chrome OS is using

00:03:12,889 --> 00:03:19,639
it I'm not sure I haven't heard from any

00:03:15,409 --> 00:03:22,729
other people having been pretty stable I

00:03:19,639 --> 00:03:25,370
poked a couple things into four four

00:03:22,729 --> 00:03:29,750
four twenty as part of some of the

00:03:25,370 --> 00:03:31,340
stacking work that Kacie talked about it

00:03:29,750 --> 00:03:33,859
became obvious that there was some

00:03:31,340 --> 00:03:36,530
terminology confusion in load pin his

00:03:33,859 --> 00:03:38,780
load pin was always enabled it just

00:03:36,530 --> 00:03:40,879
wasn't paying attention so it was doing

00:03:38,780 --> 00:03:42,949
some tracking in the background it's the

00:03:40,879 --> 00:03:46,000
idea of enforcement versus enabling so I

00:03:42,949 --> 00:03:48,829
borrowed the enforced terminology and

00:03:46,000 --> 00:03:50,269
then I finally got frustrated enough

00:03:48,829 --> 00:03:52,549
with some of the error reporting on it

00:03:50,269 --> 00:03:55,310
that I went made sure to figure out how

00:03:52,549 --> 00:04:01,099
to get readable you know human readable

00:03:55,310 --> 00:04:03,829
device names out of the reporting so a

00:04:01,099 --> 00:04:11,439
quick demo that has lost all of its

00:04:03,829 --> 00:04:11,439
colors what in the world one second

00:04:12,109 --> 00:04:16,459
No they're here

00:04:20,289 --> 00:04:27,259
it's in the preview and now it's gone

00:04:24,699 --> 00:04:29,870
that sucks a lot

00:04:27,259 --> 00:04:32,810
hold on one second I'm gonna see if I

00:04:29,870 --> 00:04:37,280
can figure out how to fix this in a

00:04:32,810 --> 00:04:43,810
different way like I'm not crazy right

00:04:37,280 --> 00:04:43,810
you can see ya those colors are there

00:04:45,669 --> 00:04:58,900
this is great

00:04:50,330 --> 00:05:12,129
I know what I'm gonna do

00:04:58,900 --> 00:05:12,129
yep I'll use my own link sorry

00:05:15,170 --> 00:05:18,290
[Music]

00:05:27,160 --> 00:05:30,780
is there a present mode

00:05:32,320 --> 00:05:42,460
I get to do this blind is gonna be

00:05:34,420 --> 00:05:50,760
awesome yeah I know them but that's

00:05:42,460 --> 00:05:50,760
really small and far away don't want you

00:06:06,750 --> 00:06:16,260
yeah I'm sort of there okay is really

00:06:12,510 --> 00:06:19,710
helpful to be able to see okay load pin

00:06:16,260 --> 00:06:22,350
demo back this this quick view of say

00:06:19,710 --> 00:06:24,210
slash temp in red and slash trusted

00:06:22,350 --> 00:06:27,210
which let's say you've been cryptic I

00:06:24,210 --> 00:06:30,360
should be checking and you go and do an

00:06:27,210 --> 00:06:32,430
in smog on some module out of trusted if

00:06:30,360 --> 00:06:34,980
you look at the message output this one

00:06:32,430 --> 00:06:37,500
happened to say hey you you turns out

00:06:34,980 --> 00:06:40,260
you're the backing device for this file

00:06:37,500 --> 00:06:41,850
system is in fact writable so I'm not

00:06:40,260 --> 00:06:43,890
even gonna pretend that this is an

00:06:41,850 --> 00:06:46,380
enforceable situation but for testing

00:06:43,890 --> 00:06:48,600
sure we'll pretend that it's loadable

00:06:46,380 --> 00:06:51,660
but you can turn this on and off the day

00:06:48,600 --> 00:06:53,910
the idea being that you can do a testing

00:06:51,660 --> 00:06:55,800
of your load pin stuff in an environment

00:06:53,910 --> 00:06:59,310
that's writable but once you actually

00:06:55,800 --> 00:07:01,890
have a read-only backing block device it

00:06:59,310 --> 00:07:04,380
will not print that out so then it

00:07:01,890 --> 00:07:07,410
reports in yellow what type of thing

00:07:04,380 --> 00:07:09,750
it's trying to load and says yeah I have

00:07:07,410 --> 00:07:12,930
I have pinned this module I'm now gonna

00:07:09,750 --> 00:07:13,950
trust trusted and then you can unload

00:07:12,930 --> 00:07:15,870
the module and then you're gonna

00:07:13,950 --> 00:07:16,320
reinsert another module out of slash

00:07:15,870 --> 00:07:18,960
temp

00:07:16,320 --> 00:07:21,360
and it says that kernel module has been

00:07:18,960 --> 00:07:24,990
denied out of temp I don't like you and

00:07:21,360 --> 00:07:27,720
then if you unmount whatever file system

00:07:24,990 --> 00:07:29,580
you had been trusting load pin says hey

00:07:27,720 --> 00:07:31,470
you took the filesystem away I have no

00:07:29,580 --> 00:07:33,979
idea how to find it again so I'm never

00:07:31,470 --> 00:07:37,350
gonna let you load anything else again I

00:07:33,979 --> 00:07:38,550
mean that's sort of the rundown on easy

00:07:37,350 --> 00:07:42,840
load pimp things

00:07:38,550 --> 00:07:48,150
yama this this was the first of the

00:07:42,840 --> 00:07:53,220
stacked LSMs so sorry not sorry and it

00:07:48,150 --> 00:07:55,740
narrows the scope of the the petrous p

00:07:53,220 --> 00:07:58,169
trace access checks that were in the

00:07:55,740 --> 00:08:00,240
kernel because it used to be quite a

00:07:58,169 --> 00:08:03,030
wide open thing you could just p trace

00:08:00,240 --> 00:08:07,050
anything as your user ID

00:08:03,030 --> 00:08:08,940
the basic goal here was to increase the

00:08:07,050 --> 00:08:10,950
amount of time it would be necessary for

00:08:08,940 --> 00:08:14,580
someone who has broken into your device

00:08:10,950 --> 00:08:16,470
to steal all your stuff because if you

00:08:14,580 --> 00:08:18,420
have password-protected things someone's

00:08:16,470 --> 00:08:19,980
going to try to

00:08:18,420 --> 00:08:21,510
you know drop malware so that you would

00:08:19,980 --> 00:08:23,880
run you know you're gonna write you're

00:08:21,510 --> 00:08:26,250
gonna run GPG or something and they'd

00:08:23,880 --> 00:08:28,470
replaced your GPG but they have to wait

00:08:26,250 --> 00:08:31,860
for you to actually do those things to

00:08:28,470 --> 00:08:33,420
get at your credentials whereas if they

00:08:31,860 --> 00:08:34,950
can break in and pee trace everything on

00:08:33,420 --> 00:08:37,260
your system they can pull credentials

00:08:34,950 --> 00:08:39,390
out of running programs they can attach

00:08:37,260 --> 00:08:41,160
to your SSH tunnels and jump down to the

00:08:39,390 --> 00:08:44,280
next machine that you happen to be on I

00:08:41,160 --> 00:08:45,750
mean it thought the pee trace was kind

00:08:44,280 --> 00:08:48,240
of scary and that you could just do

00:08:45,750 --> 00:08:50,400
anything as that user and expand the

00:08:48,240 --> 00:08:53,010
scope of your attack immediately without

00:08:50,400 --> 00:08:54,690
having to wait for a moment when you

00:08:53,010 --> 00:08:55,890
would take advantage of some user action

00:08:54,690 --> 00:09:02,010
you would trick someone into doing

00:08:55,890 --> 00:09:05,100
something so it's certainly not a silver

00:09:02,010 --> 00:09:06,810
bullet but it does change the the access

00:09:05,100 --> 00:09:10,230
controls on how that's supposed to look

00:09:06,810 --> 00:09:13,290
this is also pretty stable and almost

00:09:10,230 --> 00:09:15,690
distros are using it and of course I had

00:09:13,290 --> 00:09:17,400
to write that and sis caller who has

00:09:15,690 --> 00:09:18,810
been running for I don't know how many

00:09:17,400 --> 00:09:22,710
hundreds of thousands of hours and

00:09:18,810 --> 00:09:24,480
various places just sent one bug that it

00:09:22,710 --> 00:09:27,450
hasn't been able to reproduce in four

00:09:24,480 --> 00:09:29,370
days so there may be an RC u bug in here

00:09:27,450 --> 00:09:32,070
that a couple people are helping me look

00:09:29,370 --> 00:09:33,840
at it and I may have some future work

00:09:32,070 --> 00:09:36,810
cut out for me because yawn horn who

00:09:33,840 --> 00:09:43,050
likes breaking the world has started a

00:09:36,810 --> 00:09:45,960
comma so demo here again colors are very

00:09:43,050 --> 00:09:48,570
important so as I said before before

00:09:45,960 --> 00:09:51,000
Yama with standard DAC access checks on

00:09:48,570 --> 00:09:53,910
P trace if you are the blue evil

00:09:51,000 --> 00:09:56,880
attacker you can get at anything that is

00:09:53,910 --> 00:09:57,390
the same user ID this is sort of an

00:09:56,880 --> 00:10:01,140
example

00:09:57,390 --> 00:10:04,490
LS tree output so the first two are UID

00:10:01,140 --> 00:10:07,950
root and then everything else is is me

00:10:04,490 --> 00:10:11,520
so as that attacking process it could P

00:10:07,950 --> 00:10:13,830
trace into anything owned by me short of

00:10:11,520 --> 00:10:15,810
things that had explicitly made

00:10:13,830 --> 00:10:18,360
themselves I'm dumb people but very few

00:10:15,810 --> 00:10:20,220
things do that

00:10:18,360 --> 00:10:21,900
this doesn't great because it can go

00:10:20,220 --> 00:10:25,080
jump around and pull things out of

00:10:21,900 --> 00:10:27,030
secret and not not so great now of

00:10:25,080 --> 00:10:29,370
course with daca can't go read system D

00:10:27,030 --> 00:10:32,440
or some other users stuff

00:10:29,370 --> 00:10:35,110
so with the EMA all that goes away can't

00:10:32,440 --> 00:10:37,540
get into anything because the check that

00:10:35,110 --> 00:10:39,640
the P Tracey Emin will do now as it says

00:10:37,540 --> 00:10:42,010
alright let's look at secret and I'll

00:10:39,640 --> 00:10:44,980
walk up the ancestry tree I'll say okay

00:10:42,010 --> 00:10:46,930
is bosch trying to be traced me no the

00:10:44,980 --> 00:10:48,960
systemd trying to pee trace me no okay

00:10:46,930 --> 00:10:51,970
I'm not gonna let this happen

00:10:48,960 --> 00:10:53,140
however this so this this continues to

00:10:51,970 --> 00:10:54,940
work in situations where you're

00:10:53,140 --> 00:10:57,640
debugging stuff

00:10:54,940 --> 00:10:59,140
gdb launches some program and says I

00:10:57,640 --> 00:11:00,730
want to pee trace that program and Yama

00:10:59,140 --> 00:11:03,790
starts walking up the ancestry tree and

00:11:00,730 --> 00:11:08,320
says is gdb my parent oh yes I am okay

00:11:03,790 --> 00:11:10,420
this is allowed but this situation would

00:11:08,320 --> 00:11:14,650
break crash handlers because you'd start

00:11:10,420 --> 00:11:16,270
some program say chrome and it would it

00:11:14,650 --> 00:11:19,900
would crash and then the crash handler

00:11:16,270 --> 00:11:23,380
would actually fork an exec a handler to

00:11:19,900 --> 00:11:25,780
deal with it and connect back which

00:11:23,380 --> 00:11:27,130
would break because it you know it would

00:11:25,780 --> 00:11:28,840
this yeah imma would walk up the

00:11:27,130 --> 00:11:30,490
ancestry tree and say is the crash

00:11:28,840 --> 00:11:32,590
handler part you know an ancestor of

00:11:30,490 --> 00:11:35,680
mine no it's not bashed it's not systemd

00:11:32,590 --> 00:11:38,590
in this example so that wasn't great so

00:11:35,680 --> 00:11:40,120
we had to add some white listing that

00:11:38,590 --> 00:11:42,700
with the crashing program could declare

00:11:40,120 --> 00:11:46,180
just as it's beginning to die wait wait

00:11:42,700 --> 00:11:48,310
this guy just forked I want that to be

00:11:46,180 --> 00:11:50,860
able to P trace me so you declare a

00:11:48,310 --> 00:11:52,870
white list and then the crash handler

00:11:50,860 --> 00:11:54,370
would sort of be implicitly part of your

00:11:52,870 --> 00:12:00,670
ancestry tree that was doing the

00:11:54,370 --> 00:12:04,690
checking and there's a set count so this

00:12:00,670 --> 00:12:07,090
is not an Alice own LSM is you know as

00:12:04,690 --> 00:12:09,670
discussed earlier or sort of hooks into

00:12:07,090 --> 00:12:10,930
the kernel in lots of stable places

00:12:09,670 --> 00:12:13,080
where you have access to all the

00:12:10,930 --> 00:12:16,450
resources you want to be checking

00:12:13,080 --> 00:12:17,800
doesn't cover all doesn't call also

00:12:16,450 --> 00:12:20,740
cover can all Sisk

00:12:17,800 --> 00:12:22,960
calls because not all the things you

00:12:20,740 --> 00:12:24,940
want to mediate from an LS M are

00:12:22,960 --> 00:12:26,020
available there but there's a lot of

00:12:24,940 --> 00:12:28,390
things you don't necessarily want

00:12:26,020 --> 00:12:30,370
programs to be running so there needed

00:12:28,390 --> 00:12:34,120
to be a way to filter at the system call

00:12:30,370 --> 00:12:38,530
level one problem with this of course is

00:12:34,120 --> 00:12:40,690
you kid you know if as a malicious

00:12:38,530 --> 00:12:42,769
person trying to trick a set you ad

00:12:40,690 --> 00:12:45,920
program into doing something dumb

00:12:42,769 --> 00:12:47,689
you could for example convince it that

00:12:45,920 --> 00:12:50,600
had some program had in fact

00:12:47,689 --> 00:12:53,239
successfully dropped its privileges when

00:12:50,600 --> 00:12:57,079
it didn't so if you were able to filter

00:12:53,239 --> 00:12:59,869
a set UID program you could convince it

00:12:57,079 --> 00:13:03,379
to do bad things so known who proves the

00:12:59,869 --> 00:13:06,049
no news bit was invented to say well if

00:13:03,379 --> 00:13:08,449
you try to exact something with a filter

00:13:06,049 --> 00:13:10,309
you know with no new cribs setup you

00:13:08,449 --> 00:13:12,799
can't actually get it to be set UID so

00:13:10,309 --> 00:13:14,509
you have to either be an admin or set no

00:13:12,799 --> 00:13:16,639
new proves so you can't actually trick

00:13:14,509 --> 00:13:18,350
anything into doing this so that that

00:13:16,639 --> 00:13:20,239
was a problem with set comp very early

00:13:18,350 --> 00:13:24,350
out of the design that got added that's

00:13:20,239 --> 00:13:26,749
usually a pretty pretty widely with a

00:13:24,350 --> 00:13:28,639
second so this isn't all kinds of things

00:13:26,749 --> 00:13:30,549
I went and looked at another list and

00:13:28,639 --> 00:13:34,160
was terrified to see how much stuff is

00:13:30,549 --> 00:13:37,519
using set comp a lot but it's pretty

00:13:34,160 --> 00:13:40,429
easy to add so the example that I'll be

00:13:37,519 --> 00:13:42,709
using or with mini jail which was built

00:13:40,429 --> 00:13:44,660
for Chrome OS but we use an Android now

00:13:42,709 --> 00:13:45,799
on a lot of things it's sort of a

00:13:44,660 --> 00:13:47,329
collection of all the different

00:13:45,799 --> 00:13:49,100
container options you can pick and

00:13:47,329 --> 00:13:51,740
choose but if you're gonna do normal

00:13:49,100 --> 00:13:54,709
filtering I strongly recommend Lib set

00:13:51,740 --> 00:13:55,910
cop makes things a lot easier and if you

00:13:54,709 --> 00:13:58,160
want to do really special things you

00:13:55,910 --> 00:14:00,139
probably need to learn BPF and I note

00:13:58,160 --> 00:14:02,689
that this is actually a subset of

00:14:00,139 --> 00:14:07,939
classic BPF it's the sec comp portion

00:14:02,689 --> 00:14:12,619
and it's definitely not EBP F yet but uh

00:14:07,939 --> 00:14:15,470
there's the link off here is for Michael

00:14:12,619 --> 00:14:17,509
Karras great presentation he did a

00:14:15,470 --> 00:14:23,209
couple days ago he gets really into a

00:14:17,509 --> 00:14:25,339
lot of the details so there the basic

00:14:23,209 --> 00:14:27,439
bit of set comp is the BPF is a

00:14:25,339 --> 00:14:29,839
Burkitt's berkeley packet filter that

00:14:27,439 --> 00:14:33,470
was trying to sort of have a way to look

00:14:29,839 --> 00:14:40,279
at packets in memory in the kernel so

00:14:33,470 --> 00:14:44,839
there was this idea of okay that's get

00:14:40,279 --> 00:14:46,579
it was looking at a linear bit of memory

00:14:44,839 --> 00:14:48,259
so instead of looking at a packet you

00:14:46,579 --> 00:14:51,350
can instead look at the details for a

00:14:48,259 --> 00:14:52,579
Cisco so the which which system call

00:14:51,350 --> 00:14:54,230
number it is what architecture it is

00:14:52,579 --> 00:14:55,280
instruction pointer and the basic

00:14:54,230 --> 00:14:57,860
arguments

00:14:55,280 --> 00:14:59,570
and you can't actually read user space

00:14:57,860 --> 00:15:00,950
you can't read the memory that any of

00:14:59,570 --> 00:15:03,200
these arguments might be pointing to

00:15:00,950 --> 00:15:04,910
because you would be later racing the

00:15:03,200 --> 00:15:07,550
colonel who would try to copy that same

00:15:04,910 --> 00:15:09,440
memory out so there's sort of a standing

00:15:07,550 --> 00:15:14,090
problem with that so SEC comp only looks

00:15:09,440 --> 00:15:15,650
at the actual pointer values once you

00:15:14,090 --> 00:15:17,890
make the matches you want you can

00:15:15,650 --> 00:15:22,010
actually spit out a lot of different

00:15:17,890 --> 00:15:24,320
things for the filter to do the the most

00:15:22,010 --> 00:15:26,240
severe thing lower on the list is what

00:15:24,320 --> 00:15:28,760
will win if there's multiple filters

00:15:26,240 --> 00:15:31,160
running against the syscall so either

00:15:28,760 --> 00:15:33,440
you can allow it you can log it you can

00:15:31,160 --> 00:15:36,200
trace it if you have a P Trace manager

00:15:33,440 --> 00:15:38,930
for the process you can have the syscall

00:15:36,200 --> 00:15:40,850
get skipped and fake an error for it

00:15:38,930 --> 00:15:43,370
you could use that on open instead of

00:15:40,850 --> 00:15:45,650
killing the process you would say oh

00:15:43,370 --> 00:15:48,950
that file is just not available and the

00:15:45,650 --> 00:15:51,260
program will continue running trap is to

00:15:48,950 --> 00:15:54,890
actually deliver a catchable

00:15:51,260 --> 00:15:56,210
sexists signal if you want something if

00:15:54,890 --> 00:15:58,760
you want the program to deal with it in

00:15:56,210 --> 00:16:00,230
some way and if you say kill thread

00:15:58,760 --> 00:16:02,060
it'll kill that specific thread of

00:16:00,230 --> 00:16:07,430
execution if you say kill process it'll

00:16:02,060 --> 00:16:09,560
take out the entire thread group recent

00:16:07,430 --> 00:16:12,530
developments Tyco has been working

00:16:09,560 --> 00:16:16,040
tirelessly to get user notification in

00:16:12,530 --> 00:16:18,560
there's sort of a problem with the trace

00:16:16,040 --> 00:16:22,370
return here and that you may have a

00:16:18,560 --> 00:16:23,930
manager say inside you know say

00:16:22,370 --> 00:16:26,360
someone's running GD P or you're running

00:16:23,930 --> 00:16:28,610
a different Annette or something that's

00:16:26,360 --> 00:16:31,280
using P trace to do normal operations

00:16:28,610 --> 00:16:33,320
and you're you want to use this for a

00:16:31,280 --> 00:16:35,450
container or some other situation you

00:16:33,320 --> 00:16:37,700
can't really do a trace because it would

00:16:35,450 --> 00:16:39,140
be already being traced but you still

00:16:37,700 --> 00:16:41,600
want to get information out of filters

00:16:39,140 --> 00:16:44,120
and sort of block and do things so

00:16:41,600 --> 00:16:45,590
trying to get away from using P trace to

00:16:44,120 --> 00:16:48,470
get notifications about when things are

00:16:45,590 --> 00:16:50,680
happening at a set comp at the very

00:16:48,470 --> 00:16:52,940
least we know the things it won't be um

00:16:50,680 --> 00:16:55,760
that's that's what we've got out of the

00:16:52,940 --> 00:16:58,550
description out of the discussions but I

00:16:55,760 --> 00:17:02,030
think there's there's more to happen

00:16:58,550 --> 00:17:05,750
there and for a quick demo across a

00:17:02,030 --> 00:17:09,140
couple pages I'm gonna try to get this

00:17:05,750 --> 00:17:13,970
no never mind so I'm using mini jail as

00:17:09,140 --> 00:17:15,890
a demo quickly what what it's got here

00:17:13,970 --> 00:17:18,680
is - s I mentioned earlier is for

00:17:15,890 --> 00:17:20,510
specifying a second policy and that's in

00:17:18,680 --> 00:17:22,939
some file called cat policy and we're

00:17:20,510 --> 00:17:25,010
gonna just run the program cat to print

00:17:22,939 --> 00:17:27,530
out the policy so I can have a self

00:17:25,010 --> 00:17:30,290
documenting demo and this fails

00:17:27,530 --> 00:17:32,750
immediately okay I got a cig abort out

00:17:30,290 --> 00:17:34,490
of it why you go look at syslog because

00:17:32,750 --> 00:17:36,080
that's where mini GL puts its

00:17:34,490 --> 00:17:38,930
information and says okay some

00:17:36,080 --> 00:17:40,790
permission denied what access is you

00:17:38,930 --> 00:17:43,280
know what error code is that let's go

00:17:40,790 --> 00:17:46,220
look at the man page for SEC comp Oh air

00:17:43,280 --> 00:17:46,790
access says either I need to be cap

00:17:46,220 --> 00:17:50,030
sysadmin

00:17:46,790 --> 00:17:53,780
or use or set noted prison on cap

00:17:50,030 --> 00:17:55,970
sysadmin here is their way minion jail

00:17:53,780 --> 00:17:59,480
to get to noon set no new proves oh yes

00:17:55,970 --> 00:18:02,450
it's minus n so okay I need to add minus

00:17:59,480 --> 00:18:04,790
n now it'll run and this is a basic

00:18:02,450 --> 00:18:07,850
policy of the minimum set of syscalls

00:18:04,790 --> 00:18:11,150
needed to have cat actually run you need

00:18:07,850 --> 00:18:12,350
to open at an F stat and map you can

00:18:11,150 --> 00:18:14,710
read all those but I mean they're a

00:18:12,350 --> 00:18:18,170
relatively basic set of sis calls to

00:18:14,710 --> 00:18:23,180
look at a file open it print it out and

00:18:18,170 --> 00:18:26,000
close stuff and clean up now if I change

00:18:23,180 --> 00:18:28,550
a little piece of this and I and for the

00:18:26,000 --> 00:18:30,260
open at instead of saying it's allowed

00:18:28,550 --> 00:18:33,290
with the one that's on here I can

00:18:30,260 --> 00:18:35,660
actually say say have it returned e'en

00:18:33,290 --> 00:18:37,820
valve so this is the return air no peace

00:18:35,660 --> 00:18:39,830
and I run it with that policy and you

00:18:37,820 --> 00:18:41,930
can see immediately that it tries to go

00:18:39,830 --> 00:18:43,640
along and do its job hits the open and

00:18:41,930 --> 00:18:46,420
the second policy and gets in the way

00:18:43,640 --> 00:18:49,190
and says you know no that's invalid

00:18:46,420 --> 00:18:51,710
matching what I asked it to reply return

00:18:49,190 --> 00:18:53,450
with so okay what if we want to change

00:18:51,710 --> 00:18:57,740
what we're running what if I want to run

00:18:53,450 --> 00:18:59,810
LS on this file what happens okay so I

00:18:57,740 --> 00:19:01,970
get another error and I got a look in

00:18:59,810 --> 00:19:04,790
syslog again and it says okay I died

00:19:01,970 --> 00:19:07,220
with signal 31 okay yes that's exists it

00:19:04,790 --> 00:19:08,870
was killed because it ran some other new

00:19:07,220 --> 00:19:11,240
thing how do I figure out what system

00:19:08,870 --> 00:19:14,720
call it was actually using let's use s

00:19:11,240 --> 00:19:17,630
trace and I see it starts to try to run

00:19:14,720 --> 00:19:18,790
IO control and is immediately killed by

00:19:17,630 --> 00:19:22,180
sexists like

00:19:18,790 --> 00:19:23,560
okay I'll just add IO control and I can

00:19:22,180 --> 00:19:25,660
get fancy now and actually check

00:19:23,560 --> 00:19:29,200
arguments and I say I want the first

00:19:25,660 --> 00:19:34,450
argument to be you know matching what's

00:19:29,200 --> 00:19:36,640
here for my standard and out-out and you

00:19:34,450 --> 00:19:38,860
just sort of repeat this cycle until you

00:19:36,640 --> 00:19:40,150
get all the syscalls of that you think

00:19:38,860 --> 00:19:44,190
you're going to need for your program

00:19:40,150 --> 00:19:44,190
this is the basic way to go through it

00:19:44,310 --> 00:19:51,930
that's it those are the three so catch

00:19:49,480 --> 00:19:57,820
us up on time a little bit questions

00:19:51,930 --> 00:20:00,760
it's a question could you say something

00:19:57,820 --> 00:20:08,410
again about the race that you said about

00:20:00,760 --> 00:20:12,160
the reference things or pointers yes so

00:20:08,410 --> 00:20:14,380
what you get in this so for example

00:20:12,160 --> 00:20:18,940
let's say you're you've got a management

00:20:14,380 --> 00:20:22,570
process that's watching some some SEC

00:20:18,940 --> 00:20:25,090
program and you get a pea tray strap out

00:20:22,570 --> 00:20:26,980
of it you're like okay I want to look at

00:20:25,090 --> 00:20:29,530
this open and I want to figure out what

00:20:26,980 --> 00:20:34,060
file it's actually asking to be open so

00:20:29,530 --> 00:20:35,560
you look at the the argument for it and

00:20:34,060 --> 00:20:38,620
you say okay the first argument is the

00:20:35,560 --> 00:20:40,180
pointer into the user space memory of

00:20:38,620 --> 00:20:41,800
this process and I'm gonna go look at

00:20:40,180 --> 00:20:46,170
what file it is and says oh I want to

00:20:41,800 --> 00:20:50,800
open I don't know if our logs this log

00:20:46,170 --> 00:20:52,660
you say okay yes I approve of that let's

00:20:50,800 --> 00:20:54,460
go ahead and let it continue and you

00:20:52,660 --> 00:20:56,500
release the process and right after you

00:20:54,460 --> 00:20:58,030
release it you know some other thread of

00:20:56,500 --> 00:21:00,760
the process of other malicious thread

00:20:58,030 --> 00:21:03,400
has been sitting there you know waiting

00:21:00,760 --> 00:21:05,380
for some signal and it quickly changes

00:21:03,400 --> 00:21:07,180
what was written at that location and

00:21:05,380 --> 00:21:08,830
then you hit the kernel and the kernel

00:21:07,180 --> 00:21:11,530
goes and reads out that memory out of

00:21:08,830 --> 00:21:12,760
the out of the user space memory again

00:21:11,530 --> 00:21:15,940
and it's completely different

00:21:12,760 --> 00:21:19,750
so it's a total bypass a relatively easy

00:21:15,940 --> 00:21:22,720
total bypass of any kind of of you know

00:21:19,750 --> 00:21:27,550
intercepting those things to fix this

00:21:22,720 --> 00:21:29,560
requires either interaction with the LSM

00:21:27,550 --> 00:21:31,600
layer to get at the information once

00:21:29,560 --> 00:21:34,660
it's been processed by the kernel

00:21:31,600 --> 00:21:37,420
and that's a sort of what land lock LSM

00:21:34,660 --> 00:21:39,580
is looking to do because you can have a

00:21:37,420 --> 00:21:43,060
programmatic way to describe an LSM

00:21:39,580 --> 00:21:45,820
policy because right now most LSM like

00:21:43,060 --> 00:21:48,610
the large LSM policies are defined by

00:21:45,820 --> 00:21:52,300
the systems administrator not by you

00:21:48,610 --> 00:21:54,130
know the authors of a program the other

00:21:52,300 --> 00:21:55,450
way to solve this is to completely

00:21:54,130 --> 00:22:00,400
reaaargh attacked how the kernel

00:21:55,450 --> 00:22:01,900
processes arguments which maybe will

00:22:00,400 --> 00:22:06,190
happen it would be an interesting

00:22:01,900 --> 00:22:08,740
defense against some aspects of of cache

00:22:06,190 --> 00:22:10,920
timing attacks and other things but um

00:22:08,740 --> 00:22:14,230
it would be a lot of work to have

00:22:10,920 --> 00:22:15,610
effectively a cache of the memory you

00:22:14,230 --> 00:22:17,740
want to read out of user space

00:22:15,610 --> 00:22:19,270
sort of declare I want to be doing these

00:22:17,740 --> 00:22:22,630
things these are what these arguments

00:22:19,270 --> 00:22:23,980
would mean and in a normal Cisco the

00:22:22,630 --> 00:22:25,810
kernel would go off and say oh I don't

00:22:23,980 --> 00:22:27,670
have a cache of this yet I'll go copy it

00:22:25,810 --> 00:22:31,000
into my memory and then I'll use it and

00:22:27,670 --> 00:22:33,010
if you had set comp in between here it

00:22:31,000 --> 00:22:35,290
would have go do that copying first and

00:22:33,010 --> 00:22:36,880
then if you continued this this call it

00:22:35,290 --> 00:22:38,770
would use the cached copy so it's an

00:22:36,880 --> 00:22:40,900
idea of to try to minimize the race or

00:22:38,770 --> 00:22:49,660
eliminate the race for that kind of

00:22:40,900 --> 00:22:50,780
thing more questions if not let's fix

00:22:49,660 --> 00:22:56,049
people all right thanks

00:22:50,780 --> 00:22:56,049

YouTube URL: https://www.youtube.com/watch?v=hTdXJbnnJ88


