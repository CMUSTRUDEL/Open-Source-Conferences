Title: AMD Encrypted Virtualization Update - David Kaplan, AMD
Publication date: 2018-10-26
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	AMD Encrypted Virtualization Update - David Kaplan, AMDÂ 

This talk will update the community on Linux support for the AMD Secure Encrypted Virtualization (SEV) features discussed in past Linux Security Summits. In particular, David will discuss the current state of hardware and open source software support, especially around the new Encrypted State (SEV-ES) feature. The talk will further discuss how AMD is working with the community to create a multi-vendor standard for VM to hypervisor communication for emulated events, and the challenges being encountered. Finally, this talk will also discuss new applications of AMD SEV technology to areas outside of traditional virtualization, such as containers (e.g. Kata Containers), and how this support may evolve in the future. 

About David Kaplan
David is a Fellow at AMD who focuses on developing new security technologies across the AMD product line as part of the Security Architecture Research and Development center. He is the lead architect for the AMD memory encryption features and has worked on both CPU and SOC level security features for the last 7 years. David has over 12 years of experience at AMD, has filed over 40 patents in his career so far, and spoken at events including Linux Security Summit, ISCA, USENIX Security, and CCC.
Captions: 
	00:00:00,230 --> 00:00:06,750
all right welcome and thank you for the

00:00:04,080 --> 00:00:09,780
introduction it's great to be back at a

00:00:06,750 --> 00:00:13,290
Linux Security Summit and I wanted to

00:00:09,780 --> 00:00:14,639
take the opportunity today to kind of

00:00:13,290 --> 00:00:17,640
give you guys an update on what's been

00:00:14,639 --> 00:00:21,990
going on with AMD's secure encrypted

00:00:17,640 --> 00:00:24,810
virtualization or SCV feature both what

00:00:21,990 --> 00:00:26,730
we have been doing within the last year

00:00:24,810 --> 00:00:29,160
and kind of some of the things that were

00:00:26,730 --> 00:00:32,790
looking at in the near future as far as

00:00:29,160 --> 00:00:34,050
open source support goes so for anyone

00:00:32,790 --> 00:00:36,750
who's not familiar with this feature

00:00:34,050 --> 00:00:40,440
this is a technology that we introduced

00:00:36,750 --> 00:00:44,879
about a year ago now into our server

00:00:40,440 --> 00:00:47,940
line of x86 chips and the SCV feature is

00:00:44,879 --> 00:00:52,410
designed to offer protection for virtual

00:00:47,940 --> 00:00:53,820
machines from the hypervisor and so this

00:00:52,410 --> 00:00:56,870
is kind of a change in the traditional

00:00:53,820 --> 00:00:59,940
trust model of virtualization and

00:00:56,870 --> 00:01:02,340
there's a number of potential scenarios

00:00:59,940 --> 00:01:04,739
where this is interesting kind of the

00:01:02,340 --> 00:01:08,689
most obvious one is a public cloud type

00:01:04,739 --> 00:01:11,909
scenario and where we have this

00:01:08,689 --> 00:01:13,439
situation where from the guest

00:01:11,909 --> 00:01:16,439
perspective so kind of the cloud

00:01:13,439 --> 00:01:18,060
customer you know they they want to use

00:01:16,439 --> 00:01:20,790
a cloud but they see the potential risk

00:01:18,060 --> 00:01:23,460
of the hypervisor I mean the access that

00:01:20,790 --> 00:01:24,840
it has obviously the hypervisor is code

00:01:23,460 --> 00:01:29,520
that they are not able to control

00:01:24,840 --> 00:01:31,619
directly but the customers have various

00:01:29,520 --> 00:01:33,720
obligations including sometimes legal

00:01:31,619 --> 00:01:36,030
obligations to protect the data that

00:01:33,720 --> 00:01:39,689
they're working with and so that's

00:01:36,030 --> 00:01:41,640
concerning and on the the hypervisor say

00:01:39,689 --> 00:01:43,200
the cloud vendor side you know it's a

00:01:41,640 --> 00:01:45,360
similar situation they want to be able

00:01:43,200 --> 00:01:49,110
to offer more security to customers and

00:01:45,360 --> 00:01:52,259
really in general they tend to see the

00:01:49,110 --> 00:01:53,909
visibility as more of a liability that

00:01:52,259 --> 00:01:57,110
is the visibility they have in a

00:01:53,909 --> 00:02:00,479
customer data as a liability that that

00:01:57,110 --> 00:02:03,509
they are concerned if someone comes

00:02:00,479 --> 00:02:05,460
asking for that you know that's not

00:02:03,509 --> 00:02:09,319
really what they want to be providing

00:02:05,460 --> 00:02:10,950
and so the the net result here is that

00:02:09,319 --> 00:02:13,120
you know we believe there's this

00:02:10,950 --> 00:02:15,190
opportunity to

00:02:13,120 --> 00:02:22,300
try to offer some security enhancements

00:02:15,190 --> 00:02:24,700
in this space so the AMD SCV feature is

00:02:22,300 --> 00:02:27,040
designed primarily to protect against

00:02:24,700 --> 00:02:29,800
two different classes of attacks on the

00:02:27,040 --> 00:02:32,050
one hand we have physical access attacks

00:02:29,800 --> 00:02:33,610
which means someone is kind of

00:02:32,050 --> 00:02:36,310
physically on the motherboard and

00:02:33,610 --> 00:02:38,320
they're probing the ddr bus or they're

00:02:36,310 --> 00:02:38,920
doing a cold boot attack or something

00:02:38,320 --> 00:02:42,820
like that

00:02:38,920 --> 00:02:45,220
and so because we have memory encryption

00:02:42,820 --> 00:02:47,770
as part of this feature then we can

00:02:45,220 --> 00:02:49,990
offer strong protection against that we

00:02:47,770 --> 00:02:52,360
also are offering protection against

00:02:49,990 --> 00:02:55,209
certain types of admin access attacks

00:02:52,360 --> 00:02:57,640
and so this is like someone with root

00:02:55,209 --> 00:03:01,570
access trying to do a memory scrape of a

00:02:57,640 --> 00:03:04,750
guest trying to inject code into that

00:03:01,570 --> 00:03:06,610
guest to get it to execute that or just

00:03:04,750 --> 00:03:08,890
as kind of an extra layer of resiliency

00:03:06,610 --> 00:03:10,330
against a potential hypervisor bug or

00:03:08,890 --> 00:03:13,239
side channel attack or something like

00:03:10,330 --> 00:03:15,280
that that can potentially allow one

00:03:13,239 --> 00:03:20,410
guest to escape it's sandbox and try to

00:03:15,280 --> 00:03:22,450
see what else is going on and so just

00:03:20,410 --> 00:03:23,830
kind of at a high level the way that

00:03:22,450 --> 00:03:26,980
this feature works there's a few

00:03:23,830 --> 00:03:28,720
components this is rooted in something

00:03:26,980 --> 00:03:30,880
called the AMD secure processor which is

00:03:28,720 --> 00:03:33,700
kind of a security subsystem that's

00:03:30,880 --> 00:03:35,650
embedded in our SOC it's got an arm core

00:03:33,700 --> 00:03:38,440
on it it's got some private resources

00:03:35,650 --> 00:03:43,030
and this influenced the key management

00:03:38,440 --> 00:03:47,019
and for the VMS it provides an API for

00:03:43,030 --> 00:03:49,570
doing VM lifecycle management and so

00:03:47,019 --> 00:03:51,959
this API has things to help with

00:03:49,570 --> 00:03:55,870
starting these encrypted guests

00:03:51,959 --> 00:03:57,910
generating attestation reports assisting

00:03:55,870 --> 00:04:00,489
with migration things like that

00:03:57,910 --> 00:04:02,890
this is publicly documented we have a

00:04:00,489 --> 00:04:06,850
spec on our website that details this

00:04:02,890 --> 00:04:08,829
and from the kernel perspective the

00:04:06,850 --> 00:04:10,780
secure processor just looks like a PCI

00:04:08,829 --> 00:04:14,170
device so it has a standard MM i/o

00:04:10,780 --> 00:04:16,750
interface and this API is intended to be

00:04:14,170 --> 00:04:21,280
called from the hypervisor as it's doing

00:04:16,750 --> 00:04:24,099
these various lifecycle tasks so the

00:04:21,280 --> 00:04:25,720
hypervisor is responsible for still

00:04:24,099 --> 00:04:27,280
managing resources in the system

00:04:25,720 --> 00:04:31,870
calling the various functions that it

00:04:27,280 --> 00:04:34,780
needs to unsecure processor and then

00:04:31,870 --> 00:04:38,010
within the guest we have support for the

00:04:34,780 --> 00:04:40,780
SUV feature within the OS kernel and

00:04:38,010 --> 00:04:43,120
this is primarily because there is a new

00:04:40,780 --> 00:04:45,790
x86 page table bit that's defined as

00:04:43,120 --> 00:04:48,190
part of this architecture and that bit

00:04:45,790 --> 00:04:50,620
allows the guest kernel to indicate

00:04:48,190 --> 00:04:52,870
pages of memory that are to be marked

00:04:50,620 --> 00:04:55,480
private meaning that they're encrypted

00:04:52,870 --> 00:04:58,000
with the guest specific key and shared

00:04:55,480 --> 00:04:59,860
versus shared pages which are accessible

00:04:58,000 --> 00:05:02,080
to the hypervisor and so the way this is

00:04:59,860 --> 00:05:04,330
set up today in linux for instance is

00:05:02,080 --> 00:05:07,060
that the vast majority of pages are

00:05:04,330 --> 00:05:09,670
marked as private except for a few pages

00:05:07,060 --> 00:05:11,350
that are necessary for either pair of

00:05:09,670 --> 00:05:16,120
virtualization features or things like

00:05:11,350 --> 00:05:17,350
DNA so the nice thing is that once we

00:05:16,120 --> 00:05:18,880
have that support within the guest

00:05:17,350 --> 00:05:20,200
Colonel there's no application changes

00:05:18,880 --> 00:05:22,330
that are necessary to all the

00:05:20,200 --> 00:05:24,030
applications within the VM just run as

00:05:22,330 --> 00:05:30,040
normal and they just default to using

00:05:24,030 --> 00:05:32,620
encrypted memory and kind of a example

00:05:30,040 --> 00:05:35,230
support environment for this today we

00:05:32,620 --> 00:05:39,820
have supporters I'll get to in KVM emu

00:05:35,230 --> 00:05:42,970
and then we require using ovm F as the

00:05:39,820 --> 00:05:47,200
BIOS within the guest VM to help to

00:05:42,970 --> 00:05:51,490
bootstrap that and and I say this is

00:05:47,200 --> 00:05:55,750
this is now commercially available so

00:05:51,490 --> 00:05:57,790
I've got a brief demo video of how this

00:05:55,750 --> 00:06:00,190
works and hopefully this will this will

00:05:57,790 --> 00:06:02,560
play but essentially the setup here is

00:06:00,190 --> 00:06:04,210
that we've got a server it's running two

00:06:02,560 --> 00:06:06,220
different virtual machines one with this

00:06:04,210 --> 00:06:09,280
feature turned on and one with it turned

00:06:06,220 --> 00:06:10,690
off and we've kind of made it pretty

00:06:09,280 --> 00:06:13,570
with a little website here but

00:06:10,690 --> 00:06:16,060
essentially these are just commands that

00:06:13,570 --> 00:06:20,290
someone with with root access on the box

00:06:16,060 --> 00:06:24,550
is able to execute and so if we play

00:06:20,290 --> 00:06:27,669
this yeah so we have just looking for

00:06:24,550 --> 00:06:32,410
qmu process and then pulling up the

00:06:27,669 --> 00:06:37,020
memory map for it and then just dumping

00:06:32,410 --> 00:06:37,020
the memory with DD command

00:06:37,870 --> 00:06:42,100
and so the first page of memory is

00:06:39,520 --> 00:06:48,639
mostly zeros so that that's of course as

00:06:42,100 --> 00:06:51,490
expected if you do the same same thing

00:06:48,639 --> 00:06:54,760
but with a VM that has been run with

00:06:51,490 --> 00:06:57,340
this encrypted virtualization feature so

00:06:54,760 --> 00:07:00,600
we have that on the right side here we

00:06:57,340 --> 00:07:02,620
do the same thing and the data is

00:07:00,600 --> 00:07:05,560
essentially random and that's because

00:07:02,620 --> 00:07:07,840
the hardware is aware that we're running

00:07:05,560 --> 00:07:10,630
in a hypervisor mode versus a guest mode

00:07:07,840 --> 00:07:13,180
it only allows access to the key when

00:07:10,630 --> 00:07:15,310
it's running and get in this particular

00:07:13,180 --> 00:07:17,260
guest and so when you try to view that

00:07:15,310 --> 00:07:24,280
memory from outside then then you just

00:07:17,260 --> 00:07:29,110
see the cipher text and so then what

00:07:24,280 --> 00:07:30,789
this is going to show is just a text

00:07:29,110 --> 00:07:33,340
editor so this is like a user editing

00:07:30,789 --> 00:07:34,690
file in that VM it's just sitting in

00:07:33,340 --> 00:07:40,650
memory it's not actually written to disk

00:07:34,690 --> 00:07:43,600
yet and the the admin user on the on the

00:07:40,650 --> 00:07:46,210
native box that's running these is going

00:07:43,600 --> 00:07:49,180
to basically do a grep command on a

00:07:46,210 --> 00:07:51,910
memory and of course on the left side

00:07:49,180 --> 00:07:55,419
it's very easy to find the text that's

00:07:51,910 --> 00:07:59,050
that's in this file and when they do the

00:07:55,419 --> 00:08:01,479
same thing on the right side then they

00:07:59,050 --> 00:08:03,010
find nothing and so you know this is

00:08:01,479 --> 00:08:06,940
about as exciting as a security demo

00:08:03,010 --> 00:08:10,539
gets so that's so we got and and this is

00:08:06,940 --> 00:08:12,400
this is a two gig of ram gas so as you

00:08:10,539 --> 00:08:19,780
can see it's pretty easy to do it's

00:08:12,400 --> 00:08:21,760
pretty fast ok so what's been going on

00:08:19,780 --> 00:08:24,910
in the last year as far as this feature

00:08:21,760 --> 00:08:26,950
goes so the main thing is that we've

00:08:24,910 --> 00:08:31,150
been starting to upstream support for

00:08:26,950 --> 00:08:32,620
this feature as well as we have the SME

00:08:31,150 --> 00:08:34,510
which is secure memory encryption

00:08:32,620 --> 00:08:37,390
feature which is a simpler form that's

00:08:34,510 --> 00:08:41,650
just memory encryption support for

00:08:37,390 --> 00:08:43,959
native system and so we we have support

00:08:41,650 --> 00:08:46,270
for that starting in in 414 and then we

00:08:43,959 --> 00:08:49,600
we kind of had two sets of patches for

00:08:46,270 --> 00:08:50,720
the SCV support so we had the guest

00:08:49,600 --> 00:08:53,180
patches that

00:08:50,720 --> 00:08:55,850
the colonel aware of this new page table

00:08:53,180 --> 00:08:58,750
bit so that it could be run inside one

00:08:55,850 --> 00:09:02,689
of these VMs that went in at 4.15 and

00:08:58,750 --> 00:09:05,060
then the KVM patches that interfaced

00:09:02,689 --> 00:09:08,209
with the secure processor and did all

00:09:05,060 --> 00:09:12,290
the appropriate management for these VMs

00:09:08,209 --> 00:09:13,850
went into 4.16 and so depending on when

00:09:12,290 --> 00:09:15,620
some of the recent commercial

00:09:13,850 --> 00:09:17,839
distributions picked up their kernels

00:09:15,620 --> 00:09:20,839
there's certain ones that are capable of

00:09:17,839 --> 00:09:21,800
being run out of the box today as either

00:09:20,839 --> 00:09:26,629
an SCV

00:09:21,800 --> 00:09:28,970
guest or an SP hypervisor we do have a

00:09:26,629 --> 00:09:30,230
website that I'll mention a bit later

00:09:28,970 --> 00:09:31,519
that has kind of getting started

00:09:30,230 --> 00:09:33,860
instructions for each of these

00:09:31,519 --> 00:09:35,720
distributions so if you're interested in

00:09:33,860 --> 00:09:38,000
kind of playing with this and want to

00:09:35,720 --> 00:09:42,009
know the options to give to qmu and all

00:09:38,000 --> 00:09:45,019
that stuff we do have that documented

00:09:42,009 --> 00:09:47,569
the other thing that we've just gotten

00:09:45,019 --> 00:09:50,410
up fairly recently is there's some

00:09:47,569 --> 00:09:53,329
enhancements to the bird io GPU support

00:09:50,410 --> 00:09:55,009
we had basic Verdejo stuff working

00:09:53,329 --> 00:09:57,470
initially but there's some really

00:09:55,009 --> 00:10:02,000
texture of the GPU driver that was

00:09:57,470 --> 00:10:04,009
needed to work with how DMA works in the

00:10:02,000 --> 00:10:09,050
SUV world and so so that was recently

00:10:04,009 --> 00:10:12,829
completed and and and so that's kind of

00:10:09,050 --> 00:10:14,839
where things are right now what we're

00:10:12,829 --> 00:10:15,699
gonna be working on here in the very

00:10:14,839 --> 00:10:19,790
near future

00:10:15,699 --> 00:10:22,399
one thing is migration support for these

00:10:19,790 --> 00:10:27,410
guests this is something that is

00:10:22,399 --> 00:10:29,449
supported in our secure processor API we

00:10:27,410 --> 00:10:31,069
actually do have prototype patches

00:10:29,449 --> 00:10:33,259
available today on our public github

00:10:31,069 --> 00:10:36,079
page if anyone's interested in trying

00:10:33,259 --> 00:10:38,209
those out so we're gonna be working on

00:10:36,079 --> 00:10:40,309
getting those upstream I think right now

00:10:38,209 --> 00:10:43,579
they need some optimizations so we're

00:10:40,309 --> 00:10:45,889
gonna and do that we're also looking to

00:10:43,579 --> 00:10:49,790
open source something we call the ICV

00:10:45,889 --> 00:10:52,220
tool very shortly and and this will also

00:10:49,790 --> 00:10:54,470
go up on github and this is really just

00:10:52,220 --> 00:10:56,870
kind of reference code for parsing

00:10:54,470 --> 00:11:00,649
attestation reports validating

00:10:56,870 --> 00:11:02,870
certificates things like that so all the

00:11:00,649 --> 00:11:04,100
format's are documented but hopefully

00:11:02,870 --> 00:11:07,450
just some reference code will be

00:11:04,100 --> 00:11:09,950
full for for anyone trying to use this

00:11:07,450 --> 00:11:12,820
we're also going to be doing some

00:11:09,950 --> 00:11:16,790
support for kind of save and restore of

00:11:12,820 --> 00:11:18,410
these virtual machines and then the

00:11:16,790 --> 00:11:21,590
other big thing I'm going to talk about

00:11:18,410 --> 00:11:25,220
more here in a sec is support for a

00:11:21,590 --> 00:11:27,860
feature we call se ves which is our SUV

00:11:25,220 --> 00:11:30,320
with encrypted state support and so this

00:11:27,860 --> 00:11:36,290
is kind of the next major feature in the

00:11:30,320 --> 00:11:38,480
the SUV roadmap so the es feature I

00:11:36,290 --> 00:11:40,430
talked in more detail about this last

00:11:38,480 --> 00:11:43,340
year at the North American security

00:11:40,430 --> 00:11:46,190
summit and this is also a feature that's

00:11:43,340 --> 00:11:49,220
available in hardware today it was it

00:11:46,190 --> 00:11:53,420
was shipped as part of the initial

00:11:49,220 --> 00:11:55,490
launch we did last year and the idea

00:11:53,420 --> 00:11:58,340
with this feature is to not only protect

00:11:55,490 --> 00:11:59,990
the memory space of virtual machines but

00:11:58,340 --> 00:12:03,800
also to protect the register state

00:11:59,990 --> 00:12:05,360
across world switches so there's two

00:12:03,800 --> 00:12:07,340
main things with this feature the first

00:12:05,360 --> 00:12:08,930
thing is that there's now hardware

00:12:07,340 --> 00:12:12,560
support for kind of this really large

00:12:08,930 --> 00:12:15,050
atomic world switch operation so we've

00:12:12,560 --> 00:12:16,640
expanded what we call the VM CB which is

00:12:15,050 --> 00:12:19,520
the structure that holds all the

00:12:16,640 --> 00:12:21,410
registers state for the gas to contain

00:12:19,520 --> 00:12:23,660
basically everything that's needed so

00:12:21,410 --> 00:12:26,570
GPR state floating-point stated and so

00:12:23,660 --> 00:12:29,000
on and there's a single atomic switch

00:12:26,570 --> 00:12:32,420
that happens between high fives and mode

00:12:29,000 --> 00:12:34,340
and guest mode and then and that

00:12:32,420 --> 00:12:36,560
structure is now encrypted so the

00:12:34,340 --> 00:12:38,570
hypervisor cannot actually see what the

00:12:36,560 --> 00:12:41,420
guest contents are across these world

00:12:38,570 --> 00:12:43,670
switches the second piece of this is

00:12:41,420 --> 00:12:45,950
that for the cases where the hypervisor

00:12:43,670 --> 00:12:49,130
does need to be involved in emulation

00:12:45,950 --> 00:12:51,170
for mm IO or certain instructions we

00:12:49,130 --> 00:12:53,770
have a new exception that we call a VC

00:12:51,170 --> 00:12:55,760
or a V mm communication exception and

00:12:53,770 --> 00:12:58,220
the idea is that when the guest does

00:12:55,760 --> 00:13:00,860
something that needs support like a CPU

00:12:58,220 --> 00:13:03,470
ID the hardware throws this exception

00:13:00,860 --> 00:13:05,000
and the exception handler then does this

00:13:03,470 --> 00:13:09,020
pair of virtualization thing with the

00:13:05,000 --> 00:13:11,390
hypervisor to to process that and I'll

00:13:09,020 --> 00:13:13,190
talk about that in a second this

00:13:11,390 --> 00:13:14,750
communication is done using a structure

00:13:13,190 --> 00:13:17,840
called the guest hypervisor

00:13:14,750 --> 00:13:24,440
communication block or GHC B and this is

00:13:17,840 --> 00:13:27,140
new thing that that we're adding so with

00:13:24,440 --> 00:13:30,890
the es architecture we have divided the

00:13:27,140 --> 00:13:33,260
types of VM exits into two categories so

00:13:30,890 --> 00:13:34,790
we now have this list of we call

00:13:33,260 --> 00:13:36,770
automatic exits which are the only

00:13:34,790 --> 00:13:38,180
things that actually cause you to exit a

00:13:36,770 --> 00:13:40,430
virtual machine and go back to the

00:13:38,180 --> 00:13:42,800
hypervisor and so that's things like

00:13:40,430 --> 00:13:44,770
asynchronous interrupts certain

00:13:42,800 --> 00:13:47,890
instructions like halt and shutdown

00:13:44,770 --> 00:13:49,700
certain types of page faults and then

00:13:47,890 --> 00:13:53,000
everything else which is the vast

00:13:49,700 --> 00:13:54,020
majority are these non automatic exits

00:13:53,000 --> 00:13:57,140
which are the things that cause

00:13:54,020 --> 00:14:00,440
exceptions within the guess so I said

00:13:57,140 --> 00:14:02,750
that's CP ID you got your MSRs you got

00:14:00,440 --> 00:14:04,790
your i/o ports whatever the hypervisor

00:14:02,750 --> 00:14:06,380
is choosing to intercept instead of

00:14:04,790 --> 00:14:08,360
actually intercepting back to the

00:14:06,380 --> 00:14:13,310
hypervisor it now produces this

00:14:08,360 --> 00:14:15,830
exception in the guest and so the way

00:14:13,310 --> 00:14:18,650
this works is you know the guest starts

00:14:15,830 --> 00:14:22,520
by doing something say like a CPU ID and

00:14:18,650 --> 00:14:26,660
now instead of doing the exit will get

00:14:22,520 --> 00:14:28,480
this exception so in response to the

00:14:26,660 --> 00:14:31,690
exception there's this new handler

00:14:28,480 --> 00:14:33,680
inside the the guest VM that's going to

00:14:31,690 --> 00:14:37,190
read this error code it's going to see

00:14:33,680 --> 00:14:39,560
oh I try to do a CPU ID I need to write

00:14:37,190 --> 00:14:41,330
some information to this GHC B structure

00:14:39,560 --> 00:14:44,000
to tell the hypervisor I want to do a

00:14:41,330 --> 00:14:45,590
CPU ID and so it's going to do that and

00:14:44,000 --> 00:14:48,080
it's going to do this new instruction

00:14:45,590 --> 00:14:51,110
we've added called vmg exit which is

00:14:48,080 --> 00:14:52,700
basically a hyper call in response to

00:14:51,110 --> 00:14:54,230
that we're actually gonna completely

00:14:52,700 --> 00:14:55,940
exit the guess we're gonna save the

00:14:54,230 --> 00:14:58,880
state encrypt it we're going to go to

00:14:55,940 --> 00:15:02,000
the hypervisor the hypervisor is going

00:14:58,880 --> 00:15:04,520
to read the GHC B it's gonna see we want

00:15:02,000 --> 00:15:06,050
to do a CPI D but instead of actually

00:15:04,520 --> 00:15:07,310
writing the results directly into the

00:15:06,050 --> 00:15:10,550
registers for the guest it's going to

00:15:07,310 --> 00:15:15,620
write it into this ght B data structure

00:15:10,550 --> 00:15:17,600
and it'll then resume the guest where we

00:15:15,620 --> 00:15:19,310
go back to the handler and so the

00:15:17,600 --> 00:15:21,830
exception handler will see these new

00:15:19,310 --> 00:15:25,010
values that can decide if it likes them

00:15:21,830 --> 00:15:27,140
or not if it thinks they're safe and it

00:15:25,010 --> 00:15:29,900
can then copy them into its own register

00:15:27,140 --> 00:15:33,170
state and it can go back to the guest so

00:15:29,900 --> 00:15:35,210
the basic idea is that all of the

00:15:33,170 --> 00:15:36,620
kind of intercept behavior things they

00:15:35,210 --> 00:15:38,840
all get funneled through this

00:15:36,620 --> 00:15:40,790
centralized exception handler so the

00:15:38,840 --> 00:15:43,190
rest of the code whether it's in the

00:15:40,790 --> 00:15:50,060
kernel or in user space doesn't have to

00:15:43,190 --> 00:15:52,430
be aware of the security feature so one

00:15:50,060 --> 00:15:54,710
of the one of the pieces of feedback we

00:15:52,430 --> 00:15:56,270
got very early on with this was that it

00:15:54,710 --> 00:15:59,060
would be really nice if there is a

00:15:56,270 --> 00:16:02,420
standard protocol for doing this pair of

00:15:59,060 --> 00:16:06,530
virtualization stuff between guests and

00:16:02,420 --> 00:16:09,380
hypervisors regardless of vendor and so

00:16:06,530 --> 00:16:12,530
we decided to take on the challenge of

00:16:09,380 --> 00:16:14,620
trying to standardize this and and I

00:16:12,530 --> 00:16:18,290
mentioned this last year as well and I

00:16:14,620 --> 00:16:21,830
honestly hoped that we would be a little

00:16:18,290 --> 00:16:24,140
bit farther along than we are today it's

00:16:21,830 --> 00:16:26,390
not anything to do with this feature it

00:16:24,140 --> 00:16:28,520
more has to do with the fact that many

00:16:26,390 --> 00:16:31,310
of our security and kernel developers

00:16:28,520 --> 00:16:35,150
we're kind of busy earlier this year you

00:16:31,310 --> 00:16:36,950
guys might know why so but the good news

00:16:35,150 --> 00:16:39,290
is that is that we are coming back to

00:16:36,950 --> 00:16:42,470
this so just last week I believe we

00:16:39,290 --> 00:16:45,500
posted publicly a copy of we call the

00:16:42,470 --> 00:16:47,390
ght B software specification it's not

00:16:45,500 --> 00:16:50,720
that long it's less than 20 pages I

00:16:47,390 --> 00:16:52,670
think and this is kind of a first draft

00:16:50,720 --> 00:16:54,590
of our attempt to standardize this and

00:16:52,670 --> 00:16:56,450
so this is open for feedback there

00:16:54,590 --> 00:17:00,080
should be a mailing list thread on this

00:16:56,450 --> 00:17:02,300
pretty soon and and we've been shopping

00:17:00,080 --> 00:17:03,380
this around both within the open source

00:17:02,300 --> 00:17:07,130
community as well as with the

00:17:03,380 --> 00:17:09,110
proprietary vendors and the the

00:17:07,130 --> 00:17:10,700
specification here it defines a few

00:17:09,110 --> 00:17:13,000
things so of course it defines what the

00:17:10,700 --> 00:17:16,940
the memory of this structure looks like

00:17:13,000 --> 00:17:21,320
it defines which specific exceptions

00:17:16,940 --> 00:17:24,340
guests are expected to handle and that's

00:17:21,320 --> 00:17:26,870
because there's a lot of potential

00:17:24,340 --> 00:17:30,710
intercept bits in our architecture but

00:17:26,870 --> 00:17:33,050
most of them don't need to be set and so

00:17:30,710 --> 00:17:34,880
we're defining exactly what the minimum

00:17:33,050 --> 00:17:38,570
subset is that's required for support

00:17:34,880 --> 00:17:40,940
and with each of those we're defining

00:17:38,570 --> 00:17:42,830
what values the guest is expected to

00:17:40,940 --> 00:17:46,040
provide for the emulation and what the

00:17:42,830 --> 00:17:48,110
hypervisor expected to provide back

00:17:46,040 --> 00:17:51,410
and then there's also a few things in

00:17:48,110 --> 00:17:53,540
here about how we do bootstrapping and

00:17:51,410 --> 00:17:55,940
how we we bring up multi IV CPU

00:17:53,540 --> 00:17:58,730
environments and in my handlings and

00:17:55,940 --> 00:18:00,590
other kind of weird oddity and so what

00:17:58,730 --> 00:18:04,900
we're really hoping to do here is to

00:18:00,590 --> 00:18:07,670
provide this unified interface so that

00:18:04,900 --> 00:18:09,350
your guest OS can Boone and doesn't have

00:18:07,670 --> 00:18:14,000
to be aware of exactly what hypervisor

00:18:09,350 --> 00:18:15,590
to running under things like that so if

00:18:14,000 --> 00:18:19,280
you look at the document what you'll see

00:18:15,590 --> 00:18:22,370
in part are a number of entries like

00:18:19,280 --> 00:18:24,920
this that basically say ok on this

00:18:22,370 --> 00:18:27,410
particular type of exception how does

00:18:24,920 --> 00:18:29,930
the protocol work so for instance if the

00:18:27,410 --> 00:18:32,510
guest does a read MSR instruction it

00:18:29,930 --> 00:18:34,940
will generate this exception and then

00:18:32,510 --> 00:18:38,450
the guest is expected to set a few

00:18:34,940 --> 00:18:40,220
fields in the G HCP structure to say you

00:18:38,450 --> 00:18:42,500
know I want to do a real mess are and

00:18:40,220 --> 00:18:45,410
here's the RC x value so indicating

00:18:42,500 --> 00:18:47,960
which MSR I want to read and in return

00:18:45,410 --> 00:18:50,930
the hypervisor supplies our ax and our

00:18:47,960 --> 00:18:53,900
DX similar for CPU ID there's different

00:18:50,930 --> 00:18:56,590
things really one way to think of this

00:18:53,900 --> 00:18:59,300
is it's basically a sparsely-populated

00:18:56,590 --> 00:19:02,720
register state structure so just instead

00:18:59,300 --> 00:19:04,040
of everything being supplied only the

00:19:02,720 --> 00:19:11,030
values that are actually needed are

00:19:04,040 --> 00:19:13,070
being supplied to the hypervisor so as I

00:19:11,030 --> 00:19:15,520
mentioned feedback on this is welcome we

00:19:13,070 --> 00:19:18,290
started receiving some feedback already

00:19:15,520 --> 00:19:21,320
that I did want to share you know

00:19:18,290 --> 00:19:22,670
there's been a few things that I think

00:19:21,320 --> 00:19:26,510
have gone pretty well I've actually been

00:19:22,670 --> 00:19:29,150
pretty impressed with how well kind of

00:19:26,510 --> 00:19:31,280
people have worked together as far as

00:19:29,150 --> 00:19:33,080
both the proprietary and the open-source

00:19:31,280 --> 00:19:34,540
community so so I think that's really

00:19:33,080 --> 00:19:37,580
great

00:19:34,540 --> 00:19:40,970
in the current specification we have the

00:19:37,580 --> 00:19:43,520
layout of the GHC be matching that of

00:19:40,970 --> 00:19:46,580
the legacy the MCB so basically the

00:19:43,520 --> 00:19:47,750
state structures look the same and so

00:19:46,580 --> 00:19:50,120
that's really helpful from a

00:19:47,750 --> 00:19:51,410
compatibility standpoint because they

00:19:50,120 --> 00:19:53,660
can use the same memory offsets

00:19:51,410 --> 00:19:55,040
everything it also turns out that

00:19:53,660 --> 00:19:57,980
there's quite a lot of similarity across

00:19:55,040 --> 00:19:58,550
hypervisors in terms of which behaviors

00:19:57,980 --> 00:20:00,110
need

00:19:58,550 --> 00:20:01,850
intercepted and how those intercepts

00:20:00,110 --> 00:20:03,020
need to work and that kind of makes

00:20:01,850 --> 00:20:08,120
sense because it sort of falls out of

00:20:03,020 --> 00:20:09,890
the x86 is a quite a bit and in this

00:20:08,120 --> 00:20:12,320
type of a virtual machine environment

00:20:09,890 --> 00:20:14,300
the hypervisor really has to be very

00:20:12,320 --> 00:20:16,430
hands-off it has to let the guests as

00:20:14,300 --> 00:20:18,050
much as it can until it does something

00:20:16,430 --> 00:20:22,430
that it really has to stutter them for

00:20:18,050 --> 00:20:25,880
and so because of that we see we don't

00:20:22,430 --> 00:20:28,010
see much variation here and and also the

00:20:25,880 --> 00:20:29,570
way that we negotiate this protocol so

00:20:28,010 --> 00:20:31,820
we do have this version so it can't

00:20:29,570 --> 00:20:33,290
evolve over time and there's a way that

00:20:31,820 --> 00:20:35,540
has the guest boots that can find out

00:20:33,290 --> 00:20:39,590
what version the hypervisor supports and

00:20:35,540 --> 00:20:41,090
respond accordingly there were a few

00:20:39,590 --> 00:20:44,150
interesting challenges that we

00:20:41,090 --> 00:20:45,560
discovered during this this initial

00:20:44,150 --> 00:20:48,320
review and I say we're just getting

00:20:45,560 --> 00:20:51,040
started on this one is so there's this

00:20:48,320 --> 00:20:53,350
vmm call instruction which is

00:20:51,040 --> 00:20:55,760
traditionally used for Hyper calls and

00:20:53,350 --> 00:20:58,640
of course it kind of makes sense that

00:20:55,760 --> 00:21:01,250
different hypervisors would use vmm call

00:20:58,640 --> 00:21:02,900
for different things what we also

00:21:01,250 --> 00:21:04,430
discovered is that they're calling

00:21:02,900 --> 00:21:06,230
conventions are completely different and

00:21:04,430 --> 00:21:08,240
there's no way to make them mutually

00:21:06,230 --> 00:21:09,710
compatible so we basically had to throw

00:21:08,240 --> 00:21:11,750
our hands up on this one and we

00:21:09,710 --> 00:21:14,150
basically said that you know look you're

00:21:11,750 --> 00:21:18,890
gonna have to customize this particular

00:21:14,150 --> 00:21:21,470
behavior depending on the hypervisor we

00:21:18,890 --> 00:21:24,680
also had some some challenges around

00:21:21,470 --> 00:21:27,590
things like ap startup so this is how we

00:21:24,680 --> 00:21:30,070
boot the other V CPUs if you have

00:21:27,590 --> 00:21:32,840
multiple cores within your guest

00:21:30,070 --> 00:21:36,260
traditionally this is done using a inter

00:21:32,840 --> 00:21:38,900
process interrupt or an IP I which tells

00:21:36,260 --> 00:21:42,740
the processors where to go and start

00:21:38,900 --> 00:21:44,510
executing but we don't want the

00:21:42,740 --> 00:21:46,430
hypervisor to be able to supply an

00:21:44,510 --> 00:21:47,960
arbitrary instruction pointer for them

00:21:46,430 --> 00:21:50,690
to do that so we kind of had to rework

00:21:47,960 --> 00:21:53,870
this protocol a bit where the hypervisor

00:21:50,690 --> 00:21:57,700
can wake up a core and then the core has

00:21:53,870 --> 00:22:02,210
to go and get its actual jump address

00:21:57,700 --> 00:22:04,850
from its encrypted memory so this is

00:22:02,210 --> 00:22:07,100
kind of a new protocol you know we have

00:22:04,850 --> 00:22:11,300
a prototype I think it works this would

00:22:07,100 --> 00:22:12,050
be be something to review and then we

00:22:11,300 --> 00:22:13,640
have

00:22:12,050 --> 00:22:17,150
a few other things that are really not

00:22:13,640 --> 00:22:19,370
support in the current spec so hardware

00:22:17,150 --> 00:22:21,740
debugging is is not really supported

00:22:19,370 --> 00:22:24,730
many you are probably aware that a

00:22:21,740 --> 00:22:27,080
couple years ago there's a CVE about how

00:22:24,730 --> 00:22:28,730
hypervisors have to intercept debug

00:22:27,080 --> 00:22:30,710
traps because otherwise the guests can

00:22:28,730 --> 00:22:32,600
spin forever there's kind of a processor

00:22:30,710 --> 00:22:35,630
deadlock situation that can happen and

00:22:32,600 --> 00:22:37,490
they can do a denial service and so

00:22:35,630 --> 00:22:39,590
because of that we're not really able to

00:22:37,490 --> 00:22:43,490
make use of these in one of these

00:22:39,590 --> 00:22:45,440
isolated guest environments we also

00:22:43,490 --> 00:22:49,010
don't have support for us on them today

00:22:45,440 --> 00:22:54,170
and I hope that stays that way but we'll

00:22:49,010 --> 00:22:57,560
see so the the final thing I just wanted

00:22:54,170 --> 00:22:59,890
to mention is kind of an update is we

00:22:57,560 --> 00:23:03,560
have started looking at ways to leverage

00:22:59,890 --> 00:23:04,790
SUV support with containers and so we

00:23:03,560 --> 00:23:06,910
started getting involved a little bit

00:23:04,790 --> 00:23:12,230
with the cotta container project and

00:23:06,910 --> 00:23:13,910
this is a project that works on running

00:23:12,230 --> 00:23:17,110
containers using hardware virtualization

00:23:13,910 --> 00:23:19,340
and it uses kind of a stripped-down

00:23:17,110 --> 00:23:22,970
version of the Linux kernel I think

00:23:19,340 --> 00:23:25,700
based on clear linux and we have been

00:23:22,970 --> 00:23:29,900
looking at ways to enable the SCV

00:23:25,700 --> 00:23:31,130
functionality within that project and it

00:23:29,900 --> 00:23:32,450
turns out that's actually not too

00:23:31,130 --> 00:23:34,100
difficult because the kernel support

00:23:32,450 --> 00:23:36,920
that were already up streaming kind of

00:23:34,100 --> 00:23:41,030
flows into that with some modifications

00:23:36,920 --> 00:23:43,070
to the runtime and you know the way this

00:23:41,030 --> 00:23:44,990
works is very similar to a normal

00:23:43,070 --> 00:23:48,940
container it's just that there's a new

00:23:44,990 --> 00:23:52,660
option for specifying an SCV runtime and

00:23:48,940 --> 00:23:54,770
when you do that then you get a

00:23:52,660 --> 00:23:56,510
container that's that's using this

00:23:54,770 --> 00:23:58,520
feature and if you were to look at the

00:23:56,510 --> 00:23:59,990
memory from outside of the container it

00:23:58,520 --> 00:24:01,550
would be the same as that video that I

00:23:59,990 --> 00:24:04,610
showed earlier that it would all look to

00:24:01,550 --> 00:24:09,890
be encrypted cuz it's in a VM so this is

00:24:04,610 --> 00:24:12,770
not upstream yet but we do have we do

00:24:09,890 --> 00:24:14,360
have the those patches on our public

00:24:12,770 --> 00:24:15,920
github page so if that's something

00:24:14,360 --> 00:24:19,070
you're interested in playing with I

00:24:15,920 --> 00:24:21,950
would encourage you to check that out so

00:24:19,070 --> 00:24:24,630
you know overall we're we're making

00:24:21,950 --> 00:24:27,000
progress around SUV

00:24:24,630 --> 00:24:29,250
were we have a few areas that we're

00:24:27,000 --> 00:24:30,870
working on the encrypted state feature

00:24:29,250 --> 00:24:32,520
it's kind of a big one that that I'm

00:24:30,870 --> 00:24:35,310
hoping we're gonna make quite a bit of

00:24:32,520 --> 00:24:37,110
progress on within the next year and and

00:24:35,310 --> 00:24:39,270
part of that is trying to standardize

00:24:37,110 --> 00:24:42,140
this interface between guests and

00:24:39,270 --> 00:24:46,800
hypervisors and so I hope that works out

00:24:42,140 --> 00:24:49,020
we do have a new developer AMD comm page

00:24:46,800 --> 00:24:51,630
so that's got links to all the

00:24:49,020 --> 00:24:56,250
specifications related to the SCV

00:24:51,630 --> 00:24:58,560
feature as well as we have a public

00:24:56,250 --> 00:25:01,260
github page that has kind of getting

00:24:58,560 --> 00:25:04,040
started instructions for if you want to

00:25:01,260 --> 00:25:06,570
start running some of these cryptid VMs

00:25:04,040 --> 00:25:08,250
you right now a lot of it's still script

00:25:06,570 --> 00:25:10,080
based we don't have any nice gooeys yet

00:25:08,250 --> 00:25:13,320
but I'm sure you guys can figure it out

00:25:10,080 --> 00:25:14,670
and as I mentioned there's a tree on

00:25:13,320 --> 00:25:16,820
there as well with some of the code of

00:25:14,670 --> 00:25:19,350
stuff if if you want to play with that

00:25:16,820 --> 00:25:22,340
so that's what's been going on

00:25:19,350 --> 00:25:22,340
any questions

00:25:27,190 --> 00:25:34,150
I hand bought was empty here but I

00:25:32,290 --> 00:25:38,520
bought with trust zone

00:25:34,150 --> 00:25:42,670
Arum trust zone so you mentioned before

00:25:38,520 --> 00:25:45,010
all registers state so the question are

00:25:42,670 --> 00:25:47,830
trying to understand the difference

00:25:45,010 --> 00:25:52,390
could you please define the all register

00:25:47,830 --> 00:25:55,450
state and second question is why do we

00:25:52,390 --> 00:25:58,510
need to encrypt those when we do is when

00:25:55,450 --> 00:26:00,750
doing do a switch because usually one

00:25:58,510 --> 00:26:03,640
shouldn't have access to in different

00:26:00,750 --> 00:26:05,980
registry state as I understand and the

00:26:03,640 --> 00:26:09,580
third question is if they encrypt it

00:26:05,980 --> 00:26:12,910
where this encrypted state is stored or

00:26:09,580 --> 00:26:16,510
kept yes if I can remember all three of

00:26:12,910 --> 00:26:19,510
those so the register states so it first

00:26:16,510 --> 00:26:20,950
I've it specified in our public x86 Docs

00:26:19,510 --> 00:26:22,870
so if you want the full list you can

00:26:20,950 --> 00:26:25,780
look through that but essentially it's

00:26:22,870 --> 00:26:27,340
all the all the VM state that used to

00:26:25,780 --> 00:26:29,830
exist so kind of the basic control

00:26:27,340 --> 00:26:31,780
register or segment state it's all the

00:26:29,830 --> 00:26:34,450
general-purpose registers it's all the

00:26:31,780 --> 00:26:37,060
floating-point registers and it's a

00:26:34,450 --> 00:26:39,340
certain set of MSRs related to like

00:26:37,060 --> 00:26:42,250
system call behavior and things like

00:26:39,340 --> 00:26:45,130
that the register state is encrypted so

00:26:42,250 --> 00:26:47,620
the hypervisor or somebody with root

00:26:45,130 --> 00:26:50,950
privileges not able to see it and gain

00:26:47,620 --> 00:26:53,200
information from that for instance if

00:26:50,950 --> 00:26:55,360
you are there can often be privileged

00:26:53,200 --> 00:26:58,690
information in registers like if you're

00:26:55,360 --> 00:27:00,730
using the x86 AES instructions the key

00:26:58,690 --> 00:27:02,320
for your AES operation is actually in

00:27:00,730 --> 00:27:04,930
one of the xmm registers in the

00:27:02,320 --> 00:27:06,190
floating-point unit and so you know

00:27:04,930 --> 00:27:08,200
that's something that we would ideally

00:27:06,190 --> 00:27:10,690
not to just have they're sitting in

00:27:08,200 --> 00:27:11,800
memory if you take a and say and

00:27:10,690 --> 00:27:15,490
interrupt while you're in the middle of

00:27:11,800 --> 00:27:19,450
an aes operation the the data itself

00:27:15,490 --> 00:27:21,550
it's stored in in normal memory there's

00:27:19,450 --> 00:27:24,190
no special location for it it's just

00:27:21,550 --> 00:27:27,010
that it is encrypted with the guest

00:27:24,190 --> 00:27:28,750
specific key so it looks basically like

00:27:27,010 --> 00:27:31,240
any other page of guest memory if the

00:27:28,750 --> 00:27:36,030
hypervisor tried to read it so it just

00:27:31,240 --> 00:27:36,030
sees the cipher text thanks sure

00:27:39,859 --> 00:27:46,590
thanks for talk first is the actual

00:27:43,470 --> 00:27:52,109
contents of guests memory access

00:27:46,590 --> 00:27:54,479
accessible through JTAG so on our parts

00:27:52,109 --> 00:27:56,999
when when parts are configured for

00:27:54,479 --> 00:28:02,759
production the JTAG interface in general

00:27:56,999 --> 00:28:06,619
is blocked off so there is no jtag debug

00:28:02,759 --> 00:28:13,259
support at all on a production AMD part

00:28:06,619 --> 00:28:16,399
so so no ok and second does it does it

00:28:13,259 --> 00:28:19,789
this feature some has something to

00:28:16,399 --> 00:28:23,759
protect against side channel text or

00:28:19,789 --> 00:28:25,470
make it more difficult yeah we don't

00:28:23,759 --> 00:28:28,409
have any specific side channel

00:28:25,470 --> 00:28:31,080
protection you know the the one thing

00:28:28,409 --> 00:28:33,149
that we're able to offer is just because

00:28:31,080 --> 00:28:35,700
the the memory space is encrypted with

00:28:33,149 --> 00:28:38,489
kind of a per guest key you know if you

00:28:35,700 --> 00:28:40,830
have say a side channel that lets you

00:28:38,489 --> 00:28:43,769
kind of read memory with hypervisor

00:28:40,830 --> 00:28:45,659
permissions you can't use that to see

00:28:43,769 --> 00:28:47,249
the plaintext of another gasp right

00:28:45,659 --> 00:28:50,639
because the hypervisor normally can't

00:28:47,249 --> 00:28:54,269
see the plaintext other guest but there

00:28:50,639 --> 00:28:55,859
is nothing specific for like side

00:28:54,269 --> 00:28:56,729
channel attacks within a guest or

00:28:55,859 --> 00:29:01,129
anything like that

00:28:56,729 --> 00:29:04,470
and what about CPU caches

00:29:01,129 --> 00:29:06,869
so in terms of the security or the side

00:29:04,470 --> 00:29:09,149
channels are so the way that this works

00:29:06,869 --> 00:29:12,690
with the caches is that each cache line

00:29:09,149 --> 00:29:16,259
is tagged with the address space ID that

00:29:12,690 --> 00:29:18,090
the cache line belongs to so the data in

00:29:16,259 --> 00:29:20,460
the cache is stored in the clear but

00:29:18,090 --> 00:29:23,639
it's tagged with the owner of that data

00:29:20,460 --> 00:29:25,529
so only that VM can access it if the

00:29:23,639 --> 00:29:28,200
hypervisor tries to read that same

00:29:25,529 --> 00:29:32,129
address we'll treat that as a cache miss

00:29:28,200 --> 00:29:35,909
because the tags don't match so there is

00:29:32,129 --> 00:29:38,729
no way to kind of leak data directly

00:29:35,909 --> 00:29:40,619
through the cache but as far as kind of

00:29:38,729 --> 00:29:42,749
general cache side-channel as I said we

00:29:40,619 --> 00:29:45,649
don't have any specific features there I

00:29:42,749 --> 00:29:45,649
think

00:29:47,680 --> 00:29:55,460
try to minimize rats and so other than

00:29:51,980 --> 00:29:59,570
the GMC be registered state most of this

00:29:55,460 --> 00:30:01,300
seems to be about confidentiality rather

00:29:59,570 --> 00:30:03,680
than an integrity of the system is there

00:30:01,300 --> 00:30:06,050
anything that prevents the hypervisor

00:30:03,680 --> 00:30:07,460
from say replaying the same like

00:30:06,050 --> 00:30:08,809
snapshotting a page running the guest

00:30:07,460 --> 00:30:12,260
for a while and then replaying the old

00:30:08,809 --> 00:30:14,440
encrypted page yeah so in general in

00:30:12,260 --> 00:30:18,110
this generation the answer is no that

00:30:14,440 --> 00:30:20,360
the memory is it's just encrypted it's

00:30:18,110 --> 00:30:22,580
not an integrity checked we do some

00:30:20,360 --> 00:30:25,220
integrity checking on the state page

00:30:22,580 --> 00:30:27,110
specifically because we see that as

00:30:25,220 --> 00:30:29,090
being kind of an easier target for that

00:30:27,110 --> 00:30:32,210
so there is some protection there but in

00:30:29,090 --> 00:30:34,040
general yeah rollback attacks or not not

00:30:32,210 --> 00:30:35,660
walk today okay so is it fair to say

00:30:34,040 --> 00:30:37,010
that in the present generation this

00:30:35,660 --> 00:30:38,660
isn't a protection against an actively

00:30:37,010 --> 00:30:49,429
malicious that's correct

00:30:38,660 --> 00:30:51,830
yeah questions over there well I have

00:30:49,429 --> 00:30:53,390
two questions in the previous was the

00:30:51,830 --> 00:30:56,809
first question so I won't duplicate it

00:30:53,390 --> 00:31:00,050
Oh is there any relationship to any TPM

00:30:56,809 --> 00:31:04,340
keys and the keys inside the VM I know

00:31:00,050 --> 00:31:05,420
that you guys have a TPM in SCP so is

00:31:04,340 --> 00:31:07,760
there any relationship at all between

00:31:05,420 --> 00:31:09,020
the keys and the association between a

00:31:07,760 --> 00:31:13,850
key that might belong to that

00:31:09,020 --> 00:31:16,010
application - yeah there isn't today you

00:31:13,850 --> 00:31:18,530
know the the functionality that the

00:31:16,010 --> 00:31:20,929
secure processor provides certainly has

00:31:18,530 --> 00:31:23,300
some similarities to a TPM in terms of

00:31:20,929 --> 00:31:24,080
the way that when you set up one of

00:31:23,300 --> 00:31:26,090
these things you basically do a

00:31:24,080 --> 00:31:29,570
measurement of the initial bios image

00:31:26,090 --> 00:31:32,030
and that gets turned into basically the

00:31:29,570 --> 00:31:34,670
attestation report for the guest but

00:31:32,030 --> 00:31:36,770
it's not a TPM specific interface and

00:31:34,670 --> 00:31:39,559
today we don't have a way for the guest

00:31:36,770 --> 00:31:41,420
VM itself to actually call any services

00:31:39,559 --> 00:31:45,110
on secure processor it's only there for

00:31:41,420 --> 00:31:48,530
the the hypervisor to use so if the

00:31:45,110 --> 00:31:50,179
guest wants a TPM like functionality it

00:31:48,530 --> 00:31:51,830
basically have to provide it itself in

00:31:50,179 --> 00:31:55,340
software but the RCP I thought

00:31:51,830 --> 00:31:58,230
implemented a TPM as well so inside the

00:31:55,340 --> 00:32:00,120
same space yeah so in our client

00:31:58,230 --> 00:32:01,710
generation of parts we do support we

00:32:00,120 --> 00:32:05,490
call firmware TPM so we basically

00:32:01,710 --> 00:32:08,400
emulated TPM 2.0 we don't support that

00:32:05,490 --> 00:32:10,980
in our server line of parts which is the

00:32:08,400 --> 00:32:14,040
the line that supports this feature that

00:32:10,980 --> 00:32:16,530
that's mainly because we do is kind of a

00:32:14,040 --> 00:32:18,600
cost-saving measure and for server the

00:32:16,530 --> 00:32:20,160
cost saving isn't as important and you

00:32:18,600 --> 00:32:26,100
know the firmware TPM is not certified

00:32:20,160 --> 00:32:27,810
like a discreet TPM is unfortunately I

00:32:26,100 --> 00:32:29,490
think I have to stop for discussion but

00:32:27,810 --> 00:32:31,500
the good thing is now over coffee and

00:32:29,490 --> 00:32:33,150
tea break is fair so I think we can

00:32:31,500 --> 00:32:35,160
maybe continue with discussion where so

00:32:33,150 --> 00:32:38,459
let's rank David for the talk

00:32:35,160 --> 00:32:38,459

YouTube URL: https://www.youtube.com/watch?v=BnA6holGJ08


