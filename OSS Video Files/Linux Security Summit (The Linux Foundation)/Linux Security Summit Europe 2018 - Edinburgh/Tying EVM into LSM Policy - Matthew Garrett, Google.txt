Title: Tying EVM into LSM Policy - Matthew Garrett, Google
Publication date: 2018-10-27
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Tying EVM into LSM Policy - Matthew Garrett, GoogleÂ 

EVM (Extended Verification Module) is a Linux kernel feature that allows the shipping of signatures covering the metadata of files, including their IMA hash. This makes it possible to verify that a file's metadata is intact, in turn ensuring that the file itself is unmodified.

This presentation will discuss how EVM can be tied into other Linux security mechanisms, making it possible to grant different privileges to applications depending on their metadata and whether or not they have valid signatures. 

About Matthew Garrett
Matthew Garrett is a security developer at Google, where he focuses on improving the security of desktop Linux systems.
Captions: 
	00:00:00,060 --> 00:00:06,629
good morning so I'm going to be talking

00:00:03,689 --> 00:00:10,170
sir my name's Matthew Harris I work at

00:00:06,629 --> 00:00:13,679
Google on various things related to the

00:00:10,170 --> 00:00:15,540
security and today I'm going to be

00:00:13,679 --> 00:00:18,090
talking about some of the ways we're

00:00:15,540 --> 00:00:21,270
looking at making use of EVM I'm and

00:00:18,090 --> 00:00:23,519
look at security modules to sort of tie

00:00:21,270 --> 00:00:25,769
these into a cohesive policy that

00:00:23,519 --> 00:00:28,500
satisfies our use cases I'm going to be

00:00:25,769 --> 00:00:30,449
talking to some extent about things that

00:00:28,500 --> 00:00:32,130
Mimi already brought up but providing a

00:00:30,449 --> 00:00:34,079
bit more context about why we're

00:00:32,130 --> 00:00:37,260
interested in working on them and what

00:00:34,079 --> 00:00:43,620
we're hoping to gain as a result of this

00:00:37,260 --> 00:00:46,550
functionality so some context here we

00:00:43,620 --> 00:00:50,460
employ quite a lot of developers and

00:00:46,550 --> 00:00:52,500
those developers largely end up at some

00:00:50,460 --> 00:00:56,010
point in their day-to-day work using

00:00:52,500 --> 00:00:59,100
Linux systems and we would like those

00:00:56,010 --> 00:01:02,750
Linux systems to have reasonably strong

00:00:59,100 --> 00:01:05,880
security guarantees but unfortunately

00:01:02,750 --> 00:01:09,510
somewhat inherent in the role of being a

00:01:05,880 --> 00:01:12,229
developer is the bit where you build

00:01:09,510 --> 00:01:15,810
some software and then try to run it and

00:01:12,229 --> 00:01:18,840
if your security model is based around

00:01:15,810 --> 00:01:22,290
only allowing explicitly trusted

00:01:18,840 --> 00:01:24,390
binaries to execute then that's going to

00:01:22,290 --> 00:01:27,450
make it more difficult for developers to

00:01:24,390 --> 00:01:28,439
do their job so there's two ways of

00:01:27,450 --> 00:01:31,920
thinking about this the first would be

00:01:28,439 --> 00:01:34,049
okay we could block stuff for everyone

00:01:31,920 --> 00:01:37,799
who's not a developer and then allow

00:01:34,049 --> 00:01:42,390
developers to run anything they want

00:01:37,799 --> 00:01:44,909
that's not ideal because developers are

00:01:42,390 --> 00:01:46,950
not actually it turns out particularly

00:01:44,909 --> 00:01:49,290
better than the average user in terms of

00:01:46,950 --> 00:01:53,280
not downloading random files from the

00:01:49,290 --> 00:01:54,960
internet and clicking on them developers

00:01:53,280 --> 00:01:56,549
are not themselves inherently more

00:01:54,960 --> 00:01:58,079
trustworthy just because they know how

00:01:56,549 --> 00:02:00,270
to write codes in fact many of our

00:01:58,079 --> 00:02:03,780
security programs are it turns out down

00:02:00,270 --> 00:02:05,040
to developers writing code so another

00:02:03,780 --> 00:02:06,390
way of thinking about it is that we can

00:02:05,040 --> 00:02:08,879
be more secure if we did stop the

00:02:06,390 --> 00:02:12,060
developers doing any development but

00:02:08,879 --> 00:02:12,980
that's not really within the range of

00:02:12,060 --> 00:02:17,780
solutions I'm allowed

00:02:12,980 --> 00:02:21,620
advocate for but even if you do restrict

00:02:17,780 --> 00:02:23,510
things to signed binaries you're still

00:02:21,620 --> 00:02:27,110
left with the problem of well you can't

00:02:23,510 --> 00:02:32,510
sign data files and enforced signatures

00:02:27,110 --> 00:02:34,580
there if people are using your computer

00:02:32,510 --> 00:02:35,840
you're generating files you're going to

00:02:34,580 --> 00:02:41,120
need to be able to open those files at

00:02:35,840 --> 00:02:43,640
some point so you need to allow for

00:02:41,120 --> 00:02:46,420
unsigned files that are not exactly

00:02:43,640 --> 00:02:52,310
spalled but then when it comes to

00:02:46,420 --> 00:02:56,180
interpreted languages how do you handle

00:02:52,310 --> 00:02:58,730
this is a script a Python script is

00:02:56,180 --> 00:03:01,099
fundamentally just a data file that you

00:02:58,730 --> 00:03:04,010
feed to the Python executive all and

00:03:01,099 --> 00:03:06,530
then it's executed and we can't remove

00:03:04,010 --> 00:03:08,510
Python because a lot of infrastructure

00:03:06,530 --> 00:03:11,599
is based around Python and even if we

00:03:08,510 --> 00:03:15,170
could you're still left with shell

00:03:11,599 --> 00:03:17,209
scripts and removing the shell is really

00:03:15,170 --> 00:03:19,430
not an option so we've got this whole

00:03:17,209 --> 00:03:22,280
set of interpreted languages that will

00:03:19,430 --> 00:03:26,630
happily either read data files or in

00:03:22,280 --> 00:03:29,599
many cases even take code from standard

00:03:26,630 --> 00:03:32,750
i/o or even worse take code as an

00:03:29,599 --> 00:03:35,450
argument to them and we can't deal with

00:03:32,750 --> 00:03:38,440
that with science binaries so we need

00:03:35,450 --> 00:03:38,440
another approach

00:03:40,359 --> 00:03:45,919
Loonette security modules helped us a

00:03:42,980 --> 00:03:49,819
lot here is the reason that we are

00:03:45,919 --> 00:03:52,099
concerned about the sanctity of code in

00:03:49,819 --> 00:03:53,419
terms of it not being modifiable it

00:03:52,099 --> 00:03:55,459
being something that we can say is

00:03:53,419 --> 00:03:58,010
reasonably trustworthy is because we

00:03:55,459 --> 00:04:02,450
don't we trust that code not to do

00:03:58,010 --> 00:04:05,000
malicious things if instead we're able

00:04:02,450 --> 00:04:06,349
to say okay nothing can do malicious

00:04:05,000 --> 00:04:08,750
things regardless of whether it wants to

00:04:06,349 --> 00:04:10,220
or not then the situation is much easier

00:04:08,750 --> 00:04:14,030
we don't need to get into the same

00:04:10,220 --> 00:04:16,310
situation of having to ensure that only

00:04:14,030 --> 00:04:18,829
trusted code runs if even untrusted code

00:04:16,310 --> 00:04:21,440
can't do any damage so we can use learn

00:04:18,829 --> 00:04:22,490
security modules like selinux a commerce

00:04:21,440 --> 00:04:25,340
mac Tamayo

00:04:22,490 --> 00:04:27,020
the entire set of families to restrict

00:04:25,340 --> 00:04:29,990
what applications can do

00:04:27,020 --> 00:04:32,380
and we can split this into two sorts of

00:04:29,990 --> 00:04:35,180
boroughs categories we can say okay

00:04:32,380 --> 00:04:37,759
trusted applications should be able to

00:04:35,180 --> 00:04:42,560
do basically anything because we assume

00:04:37,759 --> 00:04:44,930
that some things there are some things

00:04:42,560 --> 00:04:46,789
that some applications need to do but

00:04:44,930 --> 00:04:48,470
which we don't want our Rico to be able

00:04:46,789 --> 00:04:50,840
to do for instance if we have

00:04:48,470 --> 00:04:53,449
credentials on a system that provide

00:04:50,840 --> 00:04:55,099
access to other systems we only want

00:04:53,449 --> 00:04:56,599
trusted codes to be able to access those

00:04:55,099 --> 00:04:58,699
credentials but we still want to

00:04:56,599 --> 00:05:00,860
untrusted code to be runnable on the

00:04:58,699 --> 00:05:03,259
system so we could write an aparment

00:05:00,860 --> 00:05:05,630
policy that has or an SE lence policy or

00:05:03,259 --> 00:05:07,940
whatever that has some mechanism to

00:05:05,630 --> 00:05:09,229
differentiate between applications that

00:05:07,940 --> 00:05:10,940
are considered trustworthy and

00:05:09,229 --> 00:05:14,539
applications that are not considered

00:05:10,940 --> 00:05:17,210
trustworthy and then based on those two

00:05:14,539 --> 00:05:19,820
policies trustworthy applications get

00:05:17,210 --> 00:05:21,169
access to credentials untrusted

00:05:19,820 --> 00:05:24,380
applications do not get access to

00:05:21,169 --> 00:05:26,330
credentials how do we tell the

00:05:24,380 --> 00:05:31,030
difference between a trustworthy

00:05:26,330 --> 00:05:31,030
application and an untrusted application

00:05:32,979 --> 00:05:37,970
small tangent Here I am a temperature

00:05:36,409 --> 00:05:40,220
measurement architecture as Mimi

00:05:37,970 --> 00:05:42,590
mentions is a mechanism that was

00:05:40,220 --> 00:05:46,099
initially something that generated

00:05:42,590 --> 00:05:47,659
measurements of files largely Executives

00:05:46,099 --> 00:05:49,880
but you can configure it so it measures

00:05:47,659 --> 00:05:53,419
all files that are accessed by different

00:05:49,880 --> 00:05:55,400
processes ima appraisal was a later

00:05:53,419 --> 00:05:57,349
addition to the I'm a feature set which

00:05:55,400 --> 00:06:01,460
allows validation of that measurement

00:05:57,349 --> 00:06:04,849
against a stored hash an either a stored

00:06:01,460 --> 00:06:08,300
hash or a stored digital signature if

00:06:04,849 --> 00:06:11,750
you have an I'm a policy that says that

00:06:08,300 --> 00:06:13,250
ima should appraise a file or executive

00:06:11,750 --> 00:06:15,849
all under a specific set of

00:06:13,250 --> 00:06:18,800
circumstances the kernel will then

00:06:15,849 --> 00:06:21,949
perform a measurement of the file

00:06:18,800 --> 00:06:26,210
compare that to the hash or to the

00:06:21,949 --> 00:06:29,509
digital signature and then block access

00:06:26,210 --> 00:06:33,259
if that measurements does not correspond

00:06:29,509 --> 00:06:35,539
to the stores copy so this is the

00:06:33,259 --> 00:06:38,240
mechanism by which we could sign

00:06:35,539 --> 00:06:40,790
executive bills which as I said we can't

00:06:38,240 --> 00:06:43,670
do in all cases we cannot say a

00:06:40,790 --> 00:06:46,430
raise all executables and then only

00:06:43,670 --> 00:06:48,080
allow execs opposed to run if they have

00:06:46,430 --> 00:06:50,330
a valid signature because we do need to

00:06:48,080 --> 00:06:58,580
allow the untrusted binary store as well

00:06:50,330 --> 00:07:01,730
and those will not have a signature the

00:06:58,580 --> 00:07:04,970
one problem around ima in this respect

00:07:01,730 --> 00:07:08,900
not so and not the slight engine ima

00:07:04,970 --> 00:07:12,800
only protects the contents of a file if

00:07:08,900 --> 00:07:14,630
I modify the file contents then the IMA

00:07:12,800 --> 00:07:17,090
measurements will change the signature

00:07:14,630 --> 00:07:19,580
will no longer validate and I ma will

00:07:17,090 --> 00:07:23,240
either warm or block access to that file

00:07:19,580 --> 00:07:25,940
as a result but the file contents are

00:07:23,240 --> 00:07:28,610
not the only security relevant part of a

00:07:25,940 --> 00:07:30,470
file the other aspects include things

00:07:28,610 --> 00:07:34,550
like the file permissions if an

00:07:30,470 --> 00:07:37,430
executive all is set you it it made

00:07:34,550 --> 00:07:40,400
behave differently to if it's not and if

00:07:37,430 --> 00:07:43,880
I add the set you ID bit to an executive

00:07:40,400 --> 00:07:45,380
all that's going to change my

00:07:43,880 --> 00:07:48,230
assumptions about that executive all

00:07:45,380 --> 00:07:50,150
security but ima is still going to be

00:07:48,230 --> 00:07:51,980
fine with this because the measurements

00:07:50,150 --> 00:07:53,200
of the file contents itself have not

00:07:51,980 --> 00:07:56,780
changed

00:07:53,200 --> 00:07:59,510
similarly the security selinux extenders

00:07:56,780 --> 00:08:01,340
attribute will determine what context

00:07:59,510 --> 00:08:05,030
unacceptable will run in all will

00:08:01,340 --> 00:08:07,070
determine which processes are able to

00:08:05,030 --> 00:08:10,360
access that file and if I modify that

00:08:07,070 --> 00:08:13,700
then again the context under which that

00:08:10,360 --> 00:08:14,870
the security context of that process

00:08:13,700 --> 00:08:15,800
will now be different security and

00:08:14,870 --> 00:08:18,140
context in that file than have any

00:08:15,800 --> 00:08:22,730
difference and again ima will not care

00:08:18,140 --> 00:08:27,670
so EVM protects the file metadata EVM

00:08:22,730 --> 00:08:27,670
adds an additional attribute which then

00:08:28,150 --> 00:08:36,290
contains a signature over either a

00:08:32,599 --> 00:08:40,880
signature or in H Mac over the metadata

00:08:36,290 --> 00:08:43,430
and then you can configure the kernels

00:08:40,880 --> 00:08:46,640
so that as well as validating the IMA

00:08:43,430 --> 00:08:50,510
signature or hash it will also verify

00:08:46,640 --> 00:08:53,750
that the EVM attribute corresponds to

00:08:50,510 --> 00:08:54,350
the other security relevant metadata of

00:08:53,750 --> 00:08:55,970
the file

00:08:54,350 --> 00:08:58,010
that's where the message easer is

00:08:55,970 --> 00:08:59,600
tampered with EVM will fail to validate

00:08:58,010 --> 00:09:07,160
if the file contents are tampered with

00:08:59,600 --> 00:09:11,570
ima will fail to validate EVM was not

00:09:07,160 --> 00:09:14,560
this time 18 months ago EVM was not

00:09:11,570 --> 00:09:18,290
quite usable for what we wanted to do

00:09:14,560 --> 00:09:21,170
EVM signatures included as we mentioned

00:09:18,290 --> 00:09:23,660
the file I note which is a reasonable

00:09:21,170 --> 00:09:27,320
thing to do for certain news cases but

00:09:23,660 --> 00:09:29,420
unfortunately you can't know ahead of

00:09:27,320 --> 00:09:32,480
time outside very constrained

00:09:29,420 --> 00:09:33,530
circumstances which I knows a file is

00:09:32,480 --> 00:09:35,450
going to end up on if you're

00:09:33,530 --> 00:09:40,190
distributing a package that hasn't yet

00:09:35,450 --> 00:09:43,460
been installed so that meant we could

00:09:40,190 --> 00:09:46,190
ship pre computers iron II signatures

00:09:43,460 --> 00:09:49,820
alongside a file but we could not ship

00:09:46,190 --> 00:09:52,370
pre computed EVM signatures which meant

00:09:49,820 --> 00:09:55,010
we couldn't automatically handle the

00:09:52,370 --> 00:10:00,800
cases where we want to protect the meta

00:09:55,010 --> 00:10:03,200
data so we've now added support for a

00:10:00,800 --> 00:10:11,540
possible ima signature sorry a possible

00:10:03,200 --> 00:10:13,720
EVM signature one which only includes a

00:10:11,540 --> 00:10:18,430
subset of the information that the full

00:10:13,720 --> 00:10:20,720
EVM signatures was include but which is

00:10:18,430 --> 00:10:23,030
something that can be calculated using

00:10:20,720 --> 00:10:24,860
only the information you know ahead of

00:10:23,030 --> 00:10:26,150
time rather than information you only

00:10:24,860 --> 00:10:30,050
get at the points where the package is

00:10:26,150 --> 00:10:31,880
installed the other change we made in

00:10:30,050 --> 00:10:33,860
terms of EVM signatures themselves is

00:10:31,880 --> 00:10:36,350
adding support first signatures that

00:10:33,860 --> 00:10:39,710
were more than a signed copy of the

00:10:36,350 --> 00:10:42,950
sha-1 digest of the file and the

00:10:39,710 --> 00:10:46,220
reasoning there is that sha-1 is

00:10:42,950 --> 00:10:47,960
absolutely fine as the basis for an H

00:10:46,220 --> 00:10:49,460
Mac there's no reason at this point to

00:10:47,960 --> 00:10:51,860
think that the use of sha-1 there is

00:10:49,460 --> 00:10:54,830
weak on the other hand we are now at the

00:10:51,860 --> 00:10:56,660
point where attacks on sha-1 in the more

00:10:54,830 --> 00:10:59,720
general case are becoming more of a

00:10:56,660 --> 00:11:01,100
concern and the potential ability for

00:10:59,720 --> 00:11:04,460
someone to come up with a pre compute

00:11:01,100 --> 00:11:07,370
attack where they are able to modify a

00:11:04,460 --> 00:11:09,140
file and still have the same shell one

00:11:07,370 --> 00:11:11,300
probably some loss at the point where

00:11:09,140 --> 00:11:12,560
it's realistic but it's probably also

00:11:11,300 --> 00:11:14,089
the case that if you're beginning to

00:11:12,560 --> 00:11:16,520
deploy this stuff you want something

00:11:14,089 --> 00:11:21,380
that's a little more future-proof so we

00:11:16,520 --> 00:11:23,930
reworked the EVM hashing code a little

00:11:21,380 --> 00:11:30,860
to add support for using additional

00:11:23,930 --> 00:11:33,050
hashes rather than just shot one so the

00:11:30,860 --> 00:11:36,700
next step was how do we tie these two

00:11:33,050 --> 00:11:39,830
things together how do we say okay

00:11:36,700 --> 00:11:42,350
signed files we can take the files that

00:11:39,830 --> 00:11:45,980
we believe are trustworthy and we can

00:11:42,350 --> 00:11:48,560
sign those but how do we then say these

00:11:45,980 --> 00:11:51,110
files should be allowed to run with

00:11:48,560 --> 00:11:54,470
elevated privileges and other files

00:11:51,110 --> 00:11:56,930
should not and the work we've done here

00:11:54,470 --> 00:11:58,510
is associated with a Palmer because

00:11:56,930 --> 00:12:00,500
that's what we're using for

00:11:58,510 --> 00:12:03,470
enforcement's you can come up with

00:12:00,500 --> 00:12:04,850
similar approaches for well SELinux is

00:12:03,470 --> 00:12:06,290
more straightforward because you already

00:12:04,850 --> 00:12:09,529
have any censored attribute that's the

00:12:06,290 --> 00:12:12,560
basis for policy attachment for a palmer

00:12:09,529 --> 00:12:17,060
previously policy attachments was based

00:12:12,560 --> 00:12:22,130
on the path of a file and the problem

00:12:17,060 --> 00:12:24,980
with that is if you say ok my trusted

00:12:22,130 --> 00:12:26,900
files all get installed into you know

00:12:24,980 --> 00:12:29,209
slash user slash bin slash user slash

00:12:26,900 --> 00:12:33,140
sbin we can rice an app on policy that

00:12:29,209 --> 00:12:37,400
says stuff there is trustworthy if I

00:12:33,140 --> 00:12:40,970
then copy a file into there it'll be

00:12:37,400 --> 00:12:45,260
considered trustworthy which is kind of

00:12:40,970 --> 00:12:48,260
not what we were aiming for so the way

00:12:45,260 --> 00:12:51,470
we're doing this is to add supports to

00:12:48,260 --> 00:12:53,660
app armor to allow profile attachments

00:12:51,470 --> 00:12:57,170
to also be based on the presence or

00:12:53,660 --> 00:13:00,080
contents of extended attributes and this

00:12:57,170 --> 00:13:03,860
means that we can write an app armor

00:13:00,080 --> 00:13:08,690
policy that says if this file has the

00:13:03,860 --> 00:13:11,060
security VM extended attribute this

00:13:08,690 --> 00:13:13,160
profile should attach and then that

00:13:11,060 --> 00:13:15,110
profile is considered a better match

00:13:13,160 --> 00:13:17,780
than one that is equivalent but doesn't

00:13:15,110 --> 00:13:21,200
have the extended attribute mentioned so

00:13:17,780 --> 00:13:24,570
we do that and then

00:13:21,200 --> 00:13:27,740
trusted files have the security VM

00:13:24,570 --> 00:13:30,690
attribute they run in the trustworthy

00:13:27,740 --> 00:13:33,300
app on our profile everything that

00:13:30,690 --> 00:13:40,079
doesn't have that attribute runs in the

00:13:33,300 --> 00:13:44,579
untrusted State the AMA policy is then

00:13:40,079 --> 00:13:47,430
configured to only appraise files that

00:13:44,579 --> 00:13:49,589
are running in the trusted profile

00:13:47,430 --> 00:13:53,130
rather than the untrusted one so if you

00:13:49,589 --> 00:13:54,839
build something that is you built

00:13:53,130 --> 00:13:57,000
something locally it does not have a

00:13:54,839 --> 00:13:58,170
signature therefore it runs in the

00:13:57,000 --> 00:14:01,170
untrusted profile

00:13:58,170 --> 00:14:04,050
therefore ima ignores it as far as

00:14:01,170 --> 00:14:05,550
appraisal is concerned you install

00:14:04,050 --> 00:14:07,230
something from a package we've built

00:14:05,550 --> 00:14:09,209
that in our build system we've

00:14:07,230 --> 00:14:12,269
determined that this is a trustworthy

00:14:09,209 --> 00:14:15,450
executive poll it has the security EVM

00:14:12,269 --> 00:14:18,329
extends its attributes it is then run in

00:14:15,450 --> 00:14:20,100
the trusted profile by a palmer and IMA

00:14:18,329 --> 00:14:23,279
then performs an appraisal so if you

00:14:20,100 --> 00:14:26,250
take a file that has the security vm

00:14:23,279 --> 00:14:28,380
exact reviews and you modify it then the

00:14:26,250 --> 00:14:33,480
IMA appraisal will fail and execution

00:14:28,380 --> 00:14:39,540
will be blocked except this didn't quite

00:14:33,480 --> 00:14:42,779
work a Palmer sorry ima has various

00:14:39,540 --> 00:14:45,600
points where you can trigger an

00:14:42,779 --> 00:14:48,079
appraisal or a measurement and BP RM

00:14:45,600 --> 00:14:51,930
check was the one that correspond to

00:14:48,079 --> 00:14:54,300
executing a file the problem here was

00:14:51,930 --> 00:14:58,589
that the appraisal and measurement were

00:14:54,300 --> 00:15:00,360
taking place early in execution at the

00:14:58,589 --> 00:15:04,199
point where the files initially read off

00:15:00,360 --> 00:15:06,029
disk and that happens before the new

00:15:04,199 --> 00:15:09,750
credentials are committed which meant

00:15:06,029 --> 00:15:14,300
that the LSM context was still that of

00:15:09,750 --> 00:15:17,490
the parent process it was not the

00:15:14,300 --> 00:15:21,810
context that the process would actually

00:15:17,490 --> 00:15:24,480
end up executing as so we added a new

00:15:21,810 --> 00:15:27,510
additional creds check function to IMA

00:15:24,480 --> 00:15:29,069
to say ok perform the appraisal after

00:15:27,510 --> 00:15:32,010
the credentials have been committed so

00:15:29,069 --> 00:15:35,509
this allows you to say I want everything

00:15:32,010 --> 00:15:38,879
that is running in this context

00:15:35,509 --> 00:15:41,220
sorry I want everything this is run by a

00:15:38,879 --> 00:15:43,649
process in this context to be appraised

00:15:41,220 --> 00:15:45,720
that's what B PRM checks does I want

00:15:43,649 --> 00:15:47,459
everything that will be running in this

00:15:45,720 --> 00:15:49,800
context to be appraised is what creds

00:15:47,459 --> 00:15:53,749
check does so it's a non-obvious

00:15:49,800 --> 00:15:53,749
difference but it's actually meaningful

00:15:55,459 --> 00:16:01,769
yeah the kernel code for all of this

00:15:59,430 --> 00:16:08,040
stuff is kind of terrifying I wish I

00:16:01,769 --> 00:16:12,449
didn't know about this now the things we

00:16:08,040 --> 00:16:13,800
do so this is what an ima policy in this

00:16:12,449 --> 00:16:17,970
case looks like it's very

00:16:13,800 --> 00:16:21,079
straightforward we say appraised at the

00:16:17,970 --> 00:16:24,029
point of the credentials being committed

00:16:21,079 --> 00:16:27,230
anything that is running in the trusted

00:16:24,029 --> 00:16:28,889
underscore exec app armor profile

00:16:27,230 --> 00:16:33,600
anything that's not running in that

00:16:28,889 --> 00:16:37,019
profile does not get appraised so this

00:16:33,600 --> 00:16:38,819
way anything that is running in the

00:16:37,019 --> 00:16:40,800
trusted profile has a signature the

00:16:38,819 --> 00:16:43,139
signature will be validated attempting

00:16:40,800 --> 00:16:45,149
to run in the trusted profile without

00:16:43,139 --> 00:16:47,790
having a valid signature will result in

00:16:45,149 --> 00:16:51,000
execution being blocked by ima if you

00:16:47,790 --> 00:16:54,930
remove the signature then the file will

00:16:51,000 --> 00:16:56,430
be run in the untrusted context and will

00:16:54,930 --> 00:17:00,899
therefore not be able to touch various

00:16:56,430 --> 00:17:02,579
bits of sensitive material interpreted

00:17:00,899 --> 00:17:06,510
languages are still a tricky problem

00:17:02,579 --> 00:17:10,470
here because Python as comes from

00:17:06,510 --> 00:17:15,360
for instance comes from our repository

00:17:10,470 --> 00:17:17,819
of trusted files we don't we haven't

00:17:15,360 --> 00:17:19,770
gone through there and then special case

00:17:17,819 --> 00:17:22,079
the build system so that's interpreted

00:17:19,770 --> 00:17:27,270
languages sorry language interpreters

00:17:22,079 --> 00:17:28,590
get the signatures left off so the

00:17:27,270 --> 00:17:32,100
approach we're taking at the moment is

00:17:28,590 --> 00:17:33,809
to make use of the security Palmer

00:17:32,100 --> 00:17:38,130
Eastern stat reviews and right now our

00:17:33,809 --> 00:17:40,260
build system just inserts the part the

00:17:38,130 --> 00:17:42,450
full path of the execs Bowl in the

00:17:40,260 --> 00:17:45,030
package into the security tap armor

00:17:42,450 --> 00:17:46,740
extended attributes these curacy Palmer

00:17:45,030 --> 00:17:47,430
extensions attributes is now part of the

00:17:46,740 --> 00:17:50,760
evey

00:17:47,430 --> 00:17:57,000
signature so modifying that will fail

00:17:50,760 --> 00:17:59,430
and then we write additional Aparna

00:17:57,000 --> 00:18:03,270
policy for language interpreters that

00:17:59,430 --> 00:18:05,130
lists that attaches to the contents of

00:18:03,270 --> 00:18:08,940
the security source at bomber incentives

00:18:05,130 --> 00:18:15,390
attribute so we can say if this

00:18:08,940 --> 00:18:18,090
executive alt is user bin Python 2.7 run

00:18:15,390 --> 00:18:20,700
is in the untrusted tier and if you

00:18:18,090 --> 00:18:22,950
rename the file it will still bind

00:18:20,700 --> 00:18:25,260
because the we're binding to the

00:18:22,950 --> 00:18:27,000
accessor not to the actual path name the

00:18:25,260 --> 00:18:28,590
security czar time harbor accessor will

00:18:27,000 --> 00:18:30,660
still contain the same value if you

00:18:28,590 --> 00:18:32,460
multiply that the signature will no

00:18:30,660 --> 00:18:34,740
longer validate and execution will be

00:18:32,460 --> 00:18:35,880
blocked so that way we can force all the

00:18:34,740 --> 00:18:37,830
language interpreters down to the

00:18:35,880 --> 00:18:42,500
untrusted tier without having a special

00:18:37,830 --> 00:18:48,920
taste-off in the build system magically

00:18:42,500 --> 00:18:54,030
scripts still work because the policy

00:18:48,920 --> 00:18:55,680
transition is determined when a process

00:18:54,030 --> 00:18:59,010
is initially executors and stuff that

00:18:55,680 --> 00:19:02,580
has a shebang line is very very very

00:18:59,010 --> 00:19:04,800
magic indeed the policy you run as is

00:19:02,580 --> 00:19:10,380
whatever policy is associated with the

00:19:04,800 --> 00:19:13,080
script not the scripts interpreter I'm

00:19:10,380 --> 00:19:17,340
not certain that this behavior is

00:19:13,080 --> 00:19:20,700
meaningfully documented as guaranteed so

00:19:17,340 --> 00:19:22,230
I have not spent enough time reading

00:19:20,700 --> 00:19:24,180
this code to be absolutely certain that

00:19:22,230 --> 00:19:25,920
I can depend on this behavior but right

00:19:24,180 --> 00:19:30,600
now this is the behavior and it's fine

00:19:25,920 --> 00:19:33,290
so and if anybody changes it now they'll

00:19:30,600 --> 00:19:33,290
be breaking userspace

00:19:33,910 --> 00:19:45,200
so what could go wrong we can make this

00:19:41,240 --> 00:19:47,260
even more complicated so as me mentions

00:19:45,200 --> 00:19:53,030
there's now support for at run time

00:19:47,260 --> 00:19:56,390
racing into a attribute in Sisyphus

00:19:53,030 --> 00:19:58,730
sorry in security affairs to say I would

00:19:56,390 --> 00:20:00,920
like additional extenders attributes to

00:19:58,730 --> 00:20:02,630
be protected by the EVM signatures so

00:20:00,920 --> 00:20:04,540
upfront you pre compute the signature

00:20:02,630 --> 00:20:06,800
including this extended attributes

00:20:04,540 --> 00:20:09,800
signature validation will then fail

00:20:06,800 --> 00:20:11,210
until you tell the kernel by the way

00:20:09,800 --> 00:20:15,650
include this additional extended

00:20:11,210 --> 00:20:18,590
attributes in the digest which means we

00:20:15,650 --> 00:20:20,510
can add metadata for instance packages

00:20:18,590 --> 00:20:23,050
that go into our build system come from

00:20:20,510 --> 00:20:26,530
various different sources we can add

00:20:23,050 --> 00:20:31,070
additional metadata that indicates which

00:20:26,530 --> 00:20:34,430
which input path those binaries came

00:20:31,070 --> 00:20:39,140
from we could even add support for which

00:20:34,430 --> 00:20:40,670
user triggered this build and that means

00:20:39,140 --> 00:20:42,380
that we can come up with even find a

00:20:40,670 --> 00:20:44,180
green security policy this is okay this

00:20:42,380 --> 00:20:46,940
is signed because it came through our

00:20:44,180 --> 00:20:49,310
build system but the upload path for

00:20:46,940 --> 00:20:51,590
this is not as trustworthy as the upload

00:20:49,310 --> 00:20:53,570
path for something else therefore even

00:20:51,590 --> 00:20:56,330
though it has a valid signature it

00:20:53,570 --> 00:20:59,630
should be run in the untrusted context

00:20:56,330 --> 00:21:01,520
and that way we can do stuff this is so

00:20:59,630 --> 00:21:03,530
for stuff that's an experimental build

00:21:01,520 --> 00:21:05,660
we can potentially put stuff somewhere

00:21:03,530 --> 00:21:06,770
in the middle it's we trust this more

00:21:05,660 --> 00:21:09,200
than we trust something was built

00:21:06,770 --> 00:21:10,820
locally because we have a full audit

00:21:09,200 --> 00:21:15,170
trail of the source code that was built

00:21:10,820 --> 00:21:16,970
but this is built from experimental code

00:21:15,170 --> 00:21:23,920
we don't want to say it's as trustworthy

00:21:16,970 --> 00:21:23,920
as something that wasn't experimental

00:21:26,740 --> 00:21:32,350
we build quite large binaries in some

00:21:30,850 --> 00:21:36,090
cases some of the binaries that we deal

00:21:32,350 --> 00:21:41,620
with are on the order of 500 megabytes

00:21:36,090 --> 00:21:44,529
go is a amazing language but more

00:21:41,620 --> 00:21:47,169
realistically debug symbols add a lot to

00:21:44,529 --> 00:21:52,380
this and debug symbols are still part of

00:21:47,169 --> 00:21:55,110
what's being measured here this is

00:21:52,380 --> 00:21:57,940
reasonably expensive as a one-off cost

00:21:55,110 --> 00:22:01,450
but if it's on a local file system

00:21:57,940 --> 00:22:03,130
then I ma will trust that the file has

00:22:01,450 --> 00:22:08,500
not been manipulated in the mean time

00:22:03,130 --> 00:22:10,419
and will not rehash it until the file

00:22:08,500 --> 00:22:12,970
system informs us that it's been changed

00:22:10,419 --> 00:22:17,919
by bumping the aversion fields in the

00:22:12,970 --> 00:22:19,720
file metadata fuse we can't rely on the

00:22:17,919 --> 00:22:23,710
fuse file systems to do that and

00:22:19,720 --> 00:22:27,070
therefore on every open the file is

00:22:23,710 --> 00:22:28,630
rehashed and if you're pulling that 500

00:22:27,070 --> 00:22:36,340
megabytes over the network in the

00:22:28,630 --> 00:22:37,990
background that's really expensive one

00:22:36,340 --> 00:22:40,149
thing here is that even if fuse is

00:22:37,990 --> 00:22:43,779
Reaper forming the measurement on every

00:22:40,149 --> 00:22:46,059
open of a file if the fuse file system

00:22:43,779 --> 00:22:49,240
is malicious it's still possible to

00:22:46,059 --> 00:22:52,720
circumvent this measurement the fuse

00:22:49,240 --> 00:22:55,270
file system can return one set of

00:22:52,720 --> 00:22:56,799
results the first time you read it while

00:22:55,270 --> 00:22:58,360
you're doing the hashing and can then

00:22:56,799 --> 00:23:00,309
return something different for all

00:22:58,360 --> 00:23:03,610
future reads and there's no guarantee

00:23:00,309 --> 00:23:05,440
that the copy that was read upfront is

00:23:03,610 --> 00:23:08,380
the copy that will always be run because

00:23:05,440 --> 00:23:10,870
the kernel may end up pushing chunks of

00:23:08,380 --> 00:23:12,539
that code out of RAM and then pulling

00:23:10,870 --> 00:23:15,010
them off the file system again later and

00:23:12,539 --> 00:23:18,549
if the file system gives a different

00:23:15,010 --> 00:23:20,770
result a second time then a sufficiently

00:23:18,549 --> 00:23:21,970
carefully malicious file system could

00:23:20,770 --> 00:23:24,070
give you something that matched the

00:23:21,970 --> 00:23:27,669
signature but which then ended up

00:23:24,070 --> 00:23:29,860
triggering unmeasured code malicious

00:23:27,669 --> 00:23:31,960
codes at a later point so we're already

00:23:29,860 --> 00:23:34,899
placing some trust in the fuse

00:23:31,960 --> 00:23:36,220
filesystem in an universe where you are

00:23:34,899 --> 00:23:38,649
trusting that i'muh

00:23:36,220 --> 00:23:40,299
will get valid measurements you probably

00:23:38,649 --> 00:23:42,190
don't want to be placing too much faith

00:23:40,299 --> 00:23:43,570
in untrusted few file systems you

00:23:42,190 --> 00:23:45,779
probably want to be ensuring that the

00:23:43,570 --> 00:23:48,309
file systems you're running are trusted

00:23:45,779 --> 00:23:51,940
if the file system you're using is

00:23:48,309 --> 00:23:54,459
trusted can we make use of that trust to

00:23:51,940 --> 00:23:57,489
improve performance one way we could do

00:23:54,459 --> 00:23:59,049
that is to say well we wrote all the

00:23:57,489 --> 00:24:01,269
data to the file system at some point

00:23:59,049 --> 00:24:03,489
the file system got all that data the

00:24:01,269 --> 00:24:06,039
file system could generate the hash at

00:24:03,489 --> 00:24:08,499
that point and we could then retrieve

00:24:06,039 --> 00:24:10,029
the hash at a later point and you can

00:24:08,499 --> 00:24:11,589
come up with situations where this isn't

00:24:10,029 --> 00:24:13,359
just necessarily about fuse you can come

00:24:11,589 --> 00:24:15,249
up with situations where you have some

00:24:13,359 --> 00:24:20,109
other mechanism on a local file system

00:24:15,249 --> 00:24:27,369
for ensuring that a hash is protected

00:24:20,109 --> 00:24:30,309
and then what we did here was and this

00:24:27,369 --> 00:24:32,200
is very much not upstream yet add an

00:24:30,309 --> 00:24:34,089
additional VFS hook that file systems

00:24:32,200 --> 00:24:37,509
can optionally provide that allows you

00:24:34,089 --> 00:24:40,929
to ask the file system to give you the

00:24:37,509 --> 00:24:43,179
hash of a file and then we pump that

00:24:40,929 --> 00:24:46,809
through fuse so then a fuse file system

00:24:43,179 --> 00:24:49,859
can optionally implement this the ROM

00:24:46,809 --> 00:24:52,029
there is that you don't want this to be

00:24:49,859 --> 00:25:02,889
achievable for file systems you don't

00:24:52,029 --> 00:25:06,820
trust so in this case what we're looking

00:25:02,889 --> 00:25:08,320
at doing is adding support in so far

00:25:06,820 --> 00:25:10,869
we've only looking at a farmer a Palmer

00:25:08,320 --> 00:25:13,659
allows you to restrict processes

00:25:10,869 --> 00:25:15,489
abilities to mount stuff based on the

00:25:13,659 --> 00:25:17,409
file system type so you can say only

00:25:15,489 --> 00:25:19,599
certain types of process come out fuse

00:25:17,409 --> 00:25:22,570
file systems fuse file systems actually

00:25:19,599 --> 00:25:25,479
add a sub file system type a file system

00:25:22,570 --> 00:25:28,690
sub type and we would like to extend

00:25:25,479 --> 00:25:32,919
stuff so that we can say ok only stuffed

00:25:28,690 --> 00:25:35,739
with fuse sorry things with fuse dot

00:25:32,919 --> 00:25:43,299
magic file system can only be mounted by

00:25:35,739 --> 00:25:46,419
trusted processes and then extend ima so

00:25:43,299 --> 00:25:48,339
that we can say appraised stuff sorry

00:25:46,419 --> 00:25:51,489
allows stuff that is being executed

00:25:48,339 --> 00:25:53,800
awesome is fused magic file system to

00:25:51,489 --> 00:25:56,290
make use of this shortcut

00:25:53,800 --> 00:25:58,870
rather than hashing the file ourselves

00:25:56,290 --> 00:26:00,700
on every access if we trust the file

00:25:58,870 --> 00:26:02,320
system we trust the file system returned

00:26:00,700 --> 00:26:04,540
consistent results if we trust the file

00:26:02,320 --> 00:26:06,460
system to return consistent results we

00:26:04,540 --> 00:26:09,610
should probably be able to trust the

00:26:06,460 --> 00:26:11,500
file system to also return the correct

00:26:09,610 --> 00:26:16,990
hash rather than start lying to us in

00:26:11,500 --> 00:26:19,240
this specific case as we mentioned

00:26:16,990 --> 00:26:22,780
there's still some difficulty in

00:26:19,240 --> 00:26:24,790
distributing signatures in Debian

00:26:22,780 --> 00:26:29,070
packages I've been working with the D

00:26:24,790 --> 00:26:31,600
package upstream to add support for

00:26:29,070 --> 00:26:33,880
Debian would like to have a generalized

00:26:31,600 --> 00:26:35,830
way to distribute and store file

00:26:33,880 --> 00:26:37,330
metadata within packages so not just

00:26:35,830 --> 00:26:39,550
about the signatures but then having a

00:26:37,330 --> 00:26:43,060
centralized store of all the file

00:26:39,550 --> 00:26:44,470
metadata and then be able to compare

00:26:43,060 --> 00:26:46,540
that against the file system

00:26:44,470 --> 00:26:50,020
this was also give a better way of

00:26:46,540 --> 00:26:51,730
distributing file capabilities which

00:26:50,020 --> 00:26:54,160
different packages otherwise right now

00:26:51,730 --> 00:26:57,130
require you to setup in the package post

00:26:54,160 --> 00:26:59,170
inst which means that in order to Gales

00:26:57,130 --> 00:27:01,450
calculate the EVM signature in advance

00:26:59,170 --> 00:27:03,130
you need to parse the post dense to

00:27:01,450 --> 00:27:04,630
figure out which file system

00:27:03,130 --> 00:27:11,340
capabilities are going to be added to a

00:27:04,630 --> 00:27:13,450
file which is really not ideal so

00:27:11,340 --> 00:27:16,180
working with G package upstream to add

00:27:13,450 --> 00:27:17,860
that we now have an implementation but

00:27:16,180 --> 00:27:19,240
it turns out there's some awkward corner

00:27:17,860 --> 00:27:20,830
cases that we're still working through

00:27:19,240 --> 00:27:22,260
those are going to slow this down a bit

00:27:20,830 --> 00:27:27,670
more

00:27:22,260 --> 00:27:31,900
so still some work to do there so the

00:27:27,670 --> 00:27:34,750
summary of this we're able to tie the a

00:27:31,900 --> 00:27:38,470
Palmer context that a process will run

00:27:34,750 --> 00:27:40,690
in to the content or in presence of an

00:27:38,470 --> 00:27:42,730
excited attribute we can then protect

00:27:40,690 --> 00:27:44,950
that sensors attributes with EVM we can

00:27:42,730 --> 00:27:47,440
protect the file contents with ima we

00:27:44,950 --> 00:27:50,650
can trigger appraisal based on it's only

00:27:47,440 --> 00:27:54,070
running on in the privileged context and

00:27:50,650 --> 00:27:55,930
then untrusted code will still run but

00:27:54,070 --> 00:27:57,550
will run in an untrusted context which

00:27:55,930 --> 00:27:59,200
is not appraised but which does not have

00:27:57,550 --> 00:28:03,680
access to the same set of sensitive

00:27:59,200 --> 00:28:06,830
material and that's it

00:28:03,680 --> 00:28:14,510
so I think if we've got any questions a

00:28:06,830 --> 00:28:16,910
couple of minutes I chance could you do

00:28:14,510 --> 00:28:19,760
us something more about the overhead to

00:28:16,910 --> 00:28:21,440
hold that okay what is the overhead full

00:28:19,760 --> 00:28:23,770
of this and the answer is actually

00:28:21,440 --> 00:28:27,200
minimal we're already using I am a

00:28:23,770 --> 00:28:29,510
measurement so the expensive part of

00:28:27,200 --> 00:28:31,220
this is reading the file and generating

00:28:29,510 --> 00:28:33,440
the hash we're already doing that

00:28:31,220 --> 00:28:35,540
adding a signature validation stat is

00:28:33,440 --> 00:28:40,180
very cheap in comparison so for our

00:28:35,540 --> 00:28:40,180
specific use case overhead it is tiny

00:28:41,440 --> 00:28:51,320
questions so you're using trusted and

00:28:49,100 --> 00:28:54,680
untrusted as far as your subject

00:28:51,320 --> 00:28:58,850
attributes any thoughts using hierarchy

00:28:54,680 --> 00:29:03,260
of trust or where or any other kind of

00:28:58,850 --> 00:29:05,270
finer granularity then yes and yell so

00:29:03,260 --> 00:29:07,490
there are certainly arguments for

00:29:05,270 --> 00:29:11,420
introducing additional tiers having a

00:29:07,490 --> 00:29:13,940
entire spectrum of what we can say in

00:29:11,420 --> 00:29:15,830
terms of a file but one aspect of this

00:29:13,940 --> 00:29:17,750
design is also to keep things as easy to

00:29:15,830 --> 00:29:20,390
understand as possible as maintainable

00:29:17,750 --> 00:29:23,090
as maintainable as possible we didn't

00:29:20,390 --> 00:29:26,960
want to create a security model which

00:29:23,090 --> 00:29:30,560
requires many years of experience to

00:29:26,960 --> 00:29:33,620
understand because that just results in

00:29:30,560 --> 00:29:35,540
people making if people misunderstand

00:29:33,620 --> 00:29:37,610
stuff and are trying to fix bugs then

00:29:35,540 --> 00:29:39,080
it's not always the case that whoever

00:29:37,610 --> 00:29:41,000
initially implemented this is still

00:29:39,080 --> 00:29:49,100
going to be around you don't want to

00:29:41,000 --> 00:29:51,950
require like the whole don't if code is

00:29:49,100 --> 00:29:53,900
if the code you're writing is at the

00:29:51,950 --> 00:29:55,430
point where you just understand what

00:29:53,900 --> 00:29:56,750
you're writing it's going to be

00:29:55,430 --> 00:29:59,480
basically impossible for anybody else to

00:29:56,750 --> 00:30:01,940
debug that and we wanted to keep things

00:29:59,480 --> 00:30:04,100
as a very simple straightforward levels

00:30:01,940 --> 00:30:05,840
so this it was as debuggable as possible

00:30:04,100 --> 00:30:08,270
and has been attainable as possible if

00:30:05,840 --> 00:30:09,980
we end up needing additional complexity

00:30:08,270 --> 00:30:13,640
then we'll look at adding more stuff but

00:30:09,980 --> 00:30:16,090
right now this is where we are no

00:30:13,640 --> 00:30:16,090
questions

00:30:16,650 --> 00:30:22,080
is there some online resources to try

00:30:19,990 --> 00:30:30,940
and reproduce and test your approach

00:30:22,080 --> 00:30:35,740
other online tools so part of this is

00:30:30,940 --> 00:30:37,720
that the build system we have is tied to

00:30:35,740 --> 00:30:39,490
our entire infrastructure so the code

00:30:37,720 --> 00:30:42,160
from there is not particularly usable in

00:30:39,490 --> 00:30:46,120
a general sense the code that I'm using

00:30:42,160 --> 00:30:50,590
is generates signatures is available on

00:30:46,120 --> 00:30:53,170
github and it's actually being

00:30:50,590 --> 00:30:55,270
maintained by someone outside the

00:30:53,170 --> 00:30:56,530
company so I can review our olefins but

00:30:55,270 --> 00:30:59,230
if you drop me an email I can say to a

00:30:56,530 --> 00:31:01,390
link to that that the code for

00:30:59,230 --> 00:31:02,920
generating the I'm a signatures only

00:31:01,390 --> 00:31:05,920
requires a small extension to be else

00:31:02,920 --> 00:31:07,990
during EDM signatures as well outside

00:31:05,920 --> 00:31:10,510
that old functionality I'm talking about

00:31:07,990 --> 00:31:12,940
is in the upstream kernel although right

00:31:10,510 --> 00:31:17,460
now the user and a partner tooling

00:31:12,940 --> 00:31:19,929
doesn't yet have support for adding the

00:31:17,460 --> 00:31:21,910
policy attachment stuff we've got these

00:31:19,929 --> 00:31:24,400
sorts of hard-coded thing right now for

00:31:21,910 --> 00:31:29,910
handling that and working on adding

00:31:24,400 --> 00:31:29,910
support for that from there

00:31:34,940 --> 00:31:40,229
what would stop some malicious code from

00:31:38,099 --> 00:31:42,629
removing a TPM nothing

00:31:40,229 --> 00:31:45,179
so if malicious code is running this

00:31:42,629 --> 00:31:48,330
routes it could remove the security EVM

00:31:45,179 --> 00:31:50,309
extends data views at which point if you

00:31:48,330 --> 00:31:52,200
attempted to run that it would run in

00:31:50,309 --> 00:31:54,720
the untrusted context so that's fine

00:31:52,200 --> 00:32:00,359
you've successfully said ok I'm going to

00:31:54,720 --> 00:32:02,210
downgrade this file and then tamper with

00:32:00,359 --> 00:32:05,249
it so that's it now runs malicious code

00:32:02,210 --> 00:32:07,379
but it now runs in the untrusted tier

00:32:05,249 --> 00:32:10,460
and as a result it should not be able to

00:32:07,379 --> 00:32:13,859
do damage or obtain sensitive material

00:32:10,460 --> 00:32:15,599
it's basically equivalent to I built a

00:32:13,859 --> 00:32:16,859
malicious file myself or I downloaded

00:32:15,599 --> 00:32:23,479
malicious file myself from somewhere

00:32:16,859 --> 00:32:23,479
else and then render questions

00:32:29,559 --> 00:32:36,669
so you use the extended attribute to

00:32:33,460 --> 00:32:39,940
attach the app arm or policy instead of

00:32:36,669 --> 00:32:42,700
the path using the path so is there an

00:32:39,940 --> 00:32:45,669
additional privilege that is required to

00:32:42,700 --> 00:32:48,070
add the security of our more extended

00:32:45,669 --> 00:32:53,610
attribute as opposed to moving a file

00:32:48,070 --> 00:32:57,490
into u.s. USR bin so security

00:32:53,610 --> 00:33:00,460
technically yes in that you need to be

00:32:57,490 --> 00:33:01,630
roots to modify these security excises

00:33:00,460 --> 00:33:03,820
attributes and you don't necessarily

00:33:01,630 --> 00:33:08,289
need spirit to move stuff into user

00:33:03,820 --> 00:33:10,210
espen but it's not you can add the

00:33:08,289 --> 00:33:14,169
security taught at Palmer extended

00:33:10,210 --> 00:33:16,720
attribute if you do that it will then

00:33:14,169 --> 00:33:18,700
run in be trusted tier but it will then

00:33:16,720 --> 00:33:20,289
also trigger appraisal so if you add it

00:33:18,700 --> 00:33:22,450
that attributes or if you modify that

00:33:20,289 --> 00:33:24,279
attribute if the file previously has an

00:33:22,450 --> 00:33:27,669
EVM signature it will no longer validate

00:33:24,279 --> 00:33:35,789
and therefore execution will be blocked

00:33:27,669 --> 00:33:35,789
that way more questions

00:33:39,120 --> 00:33:46,149
not let's make a speaker thank you

00:33:43,130 --> 00:33:46,149

YouTube URL: https://www.youtube.com/watch?v=tAq__1w1DY0


