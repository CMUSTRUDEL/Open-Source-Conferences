Title: Kernel Hardening: Protecting the Protection Mechanisms - Igor Stoppa, Huawei
Publication date: 2018-10-26
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Kernel Hardening: Protecting the Protection Mechanisms - Igor Stoppa, HuaweiÂ 

 The Linux kernel has many security-oriented features and there are efforts to harden it, yet it lacks a systematic approach to hardening those subsystems which are meant to protect it and thus are the first target for an attacker.

The purpose of this presentation is to show the use of the new features developed so far (read-only dynamically allocated memory, rare-write dynamically allocated memory, rare-write statically allocated memory).

It will be shown how to integrate them in some existing and very popular data structures (list, hlist) and use them to protect some critical data (IMA measurements list, for example).

The presentation will conclude with a set of examples extending existing data structures into others with smaller attack surface, that are compatible with the newly introduced memory protection. 

About Igor Stoppa
Igor is a security engineer with Huawei, where he works on kernel hardening. He recently discussed his ongoing work on kernel memory write-protection at the Linux Filesystem and Memory Management 2018 Summit.

Prior to joining Huawei, Igor worked at intel, where he was primarily involved in system integration (secure boot for Yocto based distro) anddevelopment of test automation tools (board flasher/test runner for Yocto). Both of these topics were presented at FSF IoT Summits

Before that, Igor worked at Nokia, as team leader both for power management and BSP R&D for linux-based tablets and phones (Maemo/Meego).

Prior to working on linux, his field of work was embedded development for microcontrollers used in automotive (FIAT group).

Igor holds an MSC in electric engineering from Turing Polytechnic

He likes to play with electronics and embedded devices.
In relation to these hobbies, he gave presentations at Linux Embedded Conferences about I2C protocol and building drones. His latest interest is 3D printing.
Captions: 
	00:00:00,620 --> 00:00:09,780
hello I'm ghost oppa I work for away at

00:00:05,640 --> 00:00:13,040
the Research Center in Helsinki I've

00:00:09,780 --> 00:00:18,000
been doing this for almost two years

00:00:13,040 --> 00:00:20,130
most of my work has been about memory

00:00:18,000 --> 00:00:22,949
protection and that's what I want to

00:00:20,130 --> 00:00:27,150
talk you talk to you about this

00:00:22,949 --> 00:00:31,529
presentation is a sort of diary journey

00:00:27,150 --> 00:00:33,270
because I'm still working on this some

00:00:31,529 --> 00:00:35,930
of the material in the slides is kinda

00:00:33,270 --> 00:00:41,460
already updated I wake up every morning

00:00:35,930 --> 00:00:43,290
finding say you're wrong here I will fix

00:00:41,460 --> 00:00:44,520
it if you think that I'm wrong

00:00:43,290 --> 00:00:49,590
constantly that I haven't found out yet

00:00:44,520 --> 00:00:57,870
please let me know so let's see where it

00:00:49,590 --> 00:00:59,579
all started to many places I work for

00:00:57,870 --> 00:01:02,010
what way what way

00:00:59,579 --> 00:01:04,290
amongst other things does mobile phones

00:01:02,010 --> 00:01:08,909
so not surprisingly I care about mobile

00:01:04,290 --> 00:01:11,460
phones in certain areas you do not have

00:01:08,909 --> 00:01:13,110
access to the Google Play Store so if

00:01:11,460 --> 00:01:14,820
you are a user you have to find from

00:01:13,110 --> 00:01:17,700
somebody application and install it and

00:01:14,820 --> 00:01:21,360
that opens the door to every sort of

00:01:17,700 --> 00:01:24,840
malicious attack that usually uses from

00:01:21,360 --> 00:01:27,090
the Google store magnumcy so it's kind

00:01:24,840 --> 00:01:29,159
of taken as granted that there will be

00:01:27,090 --> 00:01:31,470
malicious software on the phone at some

00:01:29,159 --> 00:01:35,430
point what we would like to do is to at

00:01:31,470 --> 00:01:40,320
least prevent the worst from happening

00:01:35,430 --> 00:01:42,509
that the user information is leaked we

00:01:40,320 --> 00:01:45,030
have seen a set of attacks they mostly

00:01:42,509 --> 00:01:46,829
go against the silly looks because

00:01:45,030 --> 00:01:51,000
selinux is one of the security features

00:01:46,829 --> 00:01:53,220
used by Android and it seems to be the

00:01:51,000 --> 00:01:56,670
common stepping stone of all of these

00:01:53,220 --> 00:01:59,549
attacks so the idea is if we can somehow

00:01:56,670 --> 00:02:01,439
prevent that we have already hampered a

00:01:59,549 --> 00:02:04,409
class of attacks no matter what the

00:02:01,439 --> 00:02:07,110
vulnerability that might be exploited in

00:02:04,409 --> 00:02:10,349
a specific product but then the next

00:02:07,110 --> 00:02:12,150
question is obviously can we use this

00:02:10,349 --> 00:02:14,330
technology also for protecting something

00:02:12,150 --> 00:02:14,330
else

00:02:16,340 --> 00:02:22,740
there's also we can call it a sort of

00:02:19,290 --> 00:02:25,020
sigh nice side effect which is a write

00:02:22,740 --> 00:02:28,040
protection does not only work against

00:02:25,020 --> 00:02:31,550
attacks but it works also against bugs

00:02:28,040 --> 00:02:33,720
the difference is that for bugs

00:02:31,550 --> 00:02:36,420
everything is good everything is fine

00:02:33,720 --> 00:02:40,710
you do not have to really aim for total

00:02:36,420 --> 00:02:44,430
coverage whatever you get is good but if

00:02:40,710 --> 00:02:46,610
you have attacker then you have to look

00:02:44,430 --> 00:02:50,010
at the whole chain of trust basically

00:02:46,610 --> 00:02:54,230
you might have a 95% coverage but that

00:02:50,010 --> 00:02:54,230
5% is what the attacker will go after

00:02:56,960 --> 00:03:02,820
working with upstream is rewarding but

00:02:59,580 --> 00:03:05,670
it's also tough I have been looking for

00:03:02,820 --> 00:03:07,860
an example and I have to say that it's

00:03:05,670 --> 00:03:10,710
good because looking for an example also

00:03:07,860 --> 00:03:12,930
forces you to question your own choices

00:03:10,710 --> 00:03:16,530
the initial example was SELinux and

00:03:12,930 --> 00:03:19,739
Ellison hooks but the sad reality is

00:03:16,530 --> 00:03:22,890
that sed nooks has a very complex data

00:03:19,739 --> 00:03:25,350
structure and ESM hooks are constantly

00:03:22,890 --> 00:03:27,720
moving target I mean I think every other

00:03:25,350 --> 00:03:30,630
one or two releases there's a huge patch

00:03:27,720 --> 00:03:32,670
set trying to alter them so it wasn't

00:03:30,630 --> 00:03:34,920
good for me to keep it as example

00:03:32,670 --> 00:03:37,140
because I couldn't spend my life

00:03:34,920 --> 00:03:41,220
rewriting patches for a suit for a

00:03:37,140 --> 00:03:44,430
lesson books interest me me thank you

00:03:41,220 --> 00:03:47,100
for proposing me I am a list of

00:03:44,430 --> 00:03:48,630
measurements it's so much simpler

00:03:47,100 --> 00:03:52,610
compared to the seeding of data

00:03:48,630 --> 00:03:55,739
structures and it's kind of more stable

00:03:52,610 --> 00:03:58,200
it also was useful to point out that the

00:03:55,739 --> 00:04:01,230
API I had chosen at that point that was

00:03:58,200 --> 00:04:07,530
not just not good enough at least I

00:04:01,230 --> 00:04:11,220
couldn't make it work so that also

00:04:07,530 --> 00:04:13,730
provided a bit of variety in my analysis

00:04:11,220 --> 00:04:16,350
of what can happen

00:04:13,730 --> 00:04:18,650
selinux policy DB which is what I was

00:04:16,350 --> 00:04:20,430
production initially has a sort of

00:04:18,650 --> 00:04:22,500
initial transient

00:04:20,430 --> 00:04:25,289
during which it blows a bunch of data

00:04:22,500 --> 00:04:26,530
crystal structures allocated stuff but

00:04:25,289 --> 00:04:29,170
after that it's quite

00:04:26,530 --> 00:04:33,130
you can market read only and nobody will

00:04:29,170 --> 00:04:34,360
notice turns out that is not the typical

00:04:33,130 --> 00:04:36,700
case for Criminal Code

00:04:34,360 --> 00:04:38,470
I am a is a much better representation

00:04:36,700 --> 00:04:41,410
of kernel code where you might have

00:04:38,470 --> 00:04:43,030
something which happens seldom but it

00:04:41,410 --> 00:04:45,900
does happen all the time for example

00:04:43,030 --> 00:04:48,580
with ima if you are looking at the

00:04:45,900 --> 00:04:50,280
measurements for files every time that

00:04:48,580 --> 00:04:53,950
you might want to add a new measurement

00:04:50,280 --> 00:04:56,470
it might not be performance critical in

00:04:53,950 --> 00:04:57,700
terms of that specific addition but it

00:04:56,470 --> 00:04:58,720
means that the memory cannot become

00:04:57,700 --> 00:05:01,840
completely read-only

00:04:58,720 --> 00:05:04,300
because the way the measurement list is

00:05:01,840 --> 00:05:06,070
implemented is through a linked list so

00:05:04,300 --> 00:05:09,520
every time I add a new measurement I

00:05:06,070 --> 00:05:12,850
need to modify pointer in that list and

00:05:09,520 --> 00:05:14,520
this takes us to the right rare

00:05:12,850 --> 00:05:16,270
[Music]

00:05:14,520 --> 00:05:18,550
functionality

00:05:16,270 --> 00:05:20,560
initially it was only for America

00:05:18,550 --> 00:05:22,660
allocated memory because that's what I'm

00:05:20,560 --> 00:05:25,680
a was doing it allocates a bit of memory

00:05:22,660 --> 00:05:25,680
and then adds it to the list

00:05:26,130 --> 00:05:31,690
what's the meaning of right here I think

00:05:28,330 --> 00:05:33,280
it's highly subjective because what is

00:05:31,690 --> 00:05:36,130
rare for me might not be rare for

00:05:33,280 --> 00:05:37,450
someone else and what is acceptable for

00:05:36,130 --> 00:05:40,030
me might not be acceptable for someone

00:05:37,450 --> 00:05:43,229
else so in that sense the idea is that

00:05:40,030 --> 00:05:46,090
it is provided as a mechanism and then

00:05:43,229 --> 00:05:48,910
every potential user has to make a

00:05:46,090 --> 00:05:54,840
choice analysis on whether it's suitable

00:05:48,910 --> 00:05:58,900
or not for that specific use case more

00:05:54,840 --> 00:06:01,180
learnings from I may not only

00:05:58,900 --> 00:06:02,620
dynamically allocated memory needs to

00:06:01,180 --> 00:06:06,460
change every now and then because for

00:06:02,620 --> 00:06:09,160
example if I have a list of dynamically

00:06:06,460 --> 00:06:12,039
allocated memory there is in reality a

00:06:09,160 --> 00:06:14,260
statically allocated head which I need

00:06:12,039 --> 00:06:18,729
to alter at some point to append

00:06:14,260 --> 00:06:24,820
something so right rare needs to work

00:06:18,729 --> 00:06:29,260
also there and since we are talking

00:06:24,820 --> 00:06:31,630
about lists what I initially started

00:06:29,260 --> 00:06:33,789
with was a sort of really bare-bones

00:06:31,630 --> 00:06:36,789
version of right rare where I was

00:06:33,789 --> 00:06:39,460
dealing directly with pointers but it

00:06:36,789 --> 00:06:41,710
turns out that this is extremely painful

00:06:39,460 --> 00:06:44,020
what you want to have is some sort of

00:06:41,710 --> 00:06:45,669
higher level abstraction and guess what

00:06:44,020 --> 00:06:48,099
you want it to look a lot like

00:06:45,669 --> 00:06:51,780
disruption that you would use for non

00:06:48,099 --> 00:06:58,300
protected memory which in practice means

00:06:51,780 --> 00:07:03,009
having alternate version of the function

00:06:58,300 --> 00:07:04,870
the Tachyon already uses so let's have a

00:07:03,009 --> 00:07:08,139
quick look at what is available right

00:07:04,870 --> 00:07:11,710
now this should be surprised for nobody

00:07:08,139 --> 00:07:14,199
but I just wanted to list it so you have

00:07:11,710 --> 00:07:17,259
a few ways of protecting statically

00:07:14,199 --> 00:07:19,419
allocated memory but such thing is that

00:07:17,259 --> 00:07:24,160
when you move to dynamically allocate

00:07:19,419 --> 00:07:26,710
the memory this nothing that's where the

00:07:24,160 --> 00:07:30,940
Milaap which was my initial idea came in

00:07:26,710 --> 00:07:32,620
the picture because SED nooks uses

00:07:30,940 --> 00:07:33,220
dynamic allocation for most of the

00:07:32,620 --> 00:07:36,479
memory

00:07:33,220 --> 00:07:39,460
it requires because selinux doesn't know

00:07:36,479 --> 00:07:42,130
how big would be the set of policies it

00:07:39,460 --> 00:07:45,479
needs to accommodate and as I explained

00:07:42,130 --> 00:07:49,659
earlier also statically allocated memory

00:07:45,479 --> 00:07:54,220
needs to be to have a variety or a

00:07:49,659 --> 00:07:56,080
support by the way I found out this

00:07:54,220 --> 00:07:58,240
morning that the PMM is not a good

00:07:56,080 --> 00:08:00,610
choice because it can be confused with

00:07:58,240 --> 00:08:03,219
PM m and it could even be used in the

00:08:00,610 --> 00:08:08,710
same context so if you have a proposal

00:08:03,219 --> 00:08:10,960
or welcome the difference between a

00:08:08,710 --> 00:08:13,509
radar game right there seems obvious but

00:08:10,960 --> 00:08:16,590
it's not I think it wasn't published to

00:08:13,509 --> 00:08:20,590
me till I had some soul-searching

00:08:16,590 --> 00:08:23,460
thinking but it only is final so when

00:08:20,590 --> 00:08:26,289
you say make this read-only that's it

00:08:23,460 --> 00:08:30,250
there's no way back so you are just

00:08:26,289 --> 00:08:34,839
saying I I am giving up any future

00:08:30,250 --> 00:08:38,829
choice possibility of modifying this but

00:08:34,839 --> 00:08:40,089
when you do right there periodically you

00:08:38,829 --> 00:08:42,880
are touching something that should not

00:08:40,089 --> 00:08:45,610
be touched so the question is how can we

00:08:42,880 --> 00:08:50,529
be sure that the one trying to modify it

00:08:45,610 --> 00:08:53,360
is legitimate however from a perspective

00:08:50,529 --> 00:08:59,240
of hardening I think it's still you

00:08:53,360 --> 00:09:00,380
or useful um quick overview of the

00:08:59,240 --> 00:09:07,460
protection mechanism

00:09:00,380 --> 00:09:09,740
so typically x86 armed Bay's the system

00:09:07,460 --> 00:09:12,160
they have MMU and the MMU

00:09:09,740 --> 00:09:17,000
is what can be used to protect memory

00:09:12,160 --> 00:09:20,090
Mme works a page level so what doesn't

00:09:17,000 --> 00:09:23,480
work is if you just allocate some memory

00:09:20,090 --> 00:09:25,220
from a page and want to make it read on

00:09:23,480 --> 00:09:30,290
your right layer and from the same page

00:09:25,220 --> 00:09:32,120
you get some writable memory it can be

00:09:30,290 --> 00:09:35,540
made to work if you really really want

00:09:32,120 --> 00:09:38,510
it with some hypervisor trick but it's

00:09:35,540 --> 00:09:41,500
gonna cost a lot it's much more

00:09:38,510 --> 00:09:44,060
convenient to split at the beginning

00:09:41,500 --> 00:09:47,480
writable memory from a protected memory

00:09:44,060 --> 00:09:50,450
so that whenever somebody tries to

00:09:47,480 --> 00:09:52,880
modify protected memory this will

00:09:50,450 --> 00:09:55,130
trigger an exception so the MMU comes in

00:09:52,880 --> 00:09:57,110
the way only when something bad is

00:09:55,130 --> 00:10:00,890
happening in the normal case the MMU

00:09:57,110 --> 00:10:03,530
will not generate an exception and we

00:10:00,890 --> 00:10:04,760
have two ways to do this one is only

00:10:03,530 --> 00:10:07,640
with the kernel and the other one is a

00:10:04,760 --> 00:10:10,970
kernel plus something else which can be

00:10:07,640 --> 00:10:12,170
hypervisor the you name it it doesn't

00:10:10,970 --> 00:10:16,339
matter it just something which is not

00:10:12,170 --> 00:10:18,980
kernel the first case with the kernel

00:10:16,339 --> 00:10:21,500
only the really bad thing is that the

00:10:18,980 --> 00:10:24,040
protection can be undone so current

00:10:21,500 --> 00:10:29,390
hardware does not have any one way

00:10:24,040 --> 00:10:33,320
option to say I do this once and I will

00:10:29,390 --> 00:10:37,520
never take it back so if the attacker

00:10:33,320 --> 00:10:39,980
manages to run or to modify data at

00:10:37,520 --> 00:10:45,160
kernel level the protection can be

00:10:39,980 --> 00:10:47,690
undone however even in this case from

00:10:45,160 --> 00:10:50,570
hardening perspective still reduces the

00:10:47,690 --> 00:10:52,490
attack surface which you think is better

00:10:50,570 --> 00:10:55,850
because we are moving from having

00:10:52,490 --> 00:10:58,070
basically every bit of memory as a

00:10:55,850 --> 00:11:02,630
potential target to focusing on the page

00:10:58,070 --> 00:11:05,750
table for example in the case with the

00:11:02,630 --> 00:11:06,410
advisor it's kind of easier if you

00:11:05,750 --> 00:11:10,310
happen to already

00:11:06,410 --> 00:11:11,750
have a hypervisor handy because the

00:11:10,310 --> 00:11:16,190
kernel is much more limited in what you

00:11:11,750 --> 00:11:18,319
can do and basically the hypervisor is

00:11:16,190 --> 00:11:19,910
what the kernel can use to relinquish

00:11:18,319 --> 00:11:21,769
permanently its capability

00:11:19,910 --> 00:11:24,019
the downside is of course you need to

00:11:21,769 --> 00:11:26,810
have a hypervisor or capable hardware

00:11:24,019 --> 00:11:31,579
and if you think about IOT class devices

00:11:26,810 --> 00:11:32,569
that might not always be the case but

00:11:31,579 --> 00:11:34,430
there are some cases where the

00:11:32,569 --> 00:11:37,879
hypervisor is there already for example

00:11:34,430 --> 00:11:41,689
in data centers cloud providers some

00:11:37,879 --> 00:11:44,569
mobile devices but even your regular

00:11:41,689 --> 00:11:46,819
laptop or PC supports running hypervisor

00:11:44,569 --> 00:11:49,639
usually so why not it could be used even

00:11:46,819 --> 00:11:55,189
in regular distros as a traditional have

00:11:49,639 --> 00:12:02,329
them in form I'm borrowing some naming

00:11:55,189 --> 00:12:04,430
from get so the base of this protection

00:12:02,329 --> 00:12:05,240
is what's called pure MEMS what the

00:12:04,430 --> 00:12:08,480
requirements are

00:12:05,240 --> 00:12:12,110
this must be fast or at least there

00:12:08,480 --> 00:12:15,529
shouldn't be any noticeable decrease in

00:12:12,110 --> 00:12:18,170
your read performance and write for the

00:12:15,529 --> 00:12:20,240
right wear case should be acceptable we

00:12:18,170 --> 00:12:24,139
already discussed what acceptable means

00:12:20,240 --> 00:12:26,269
it's very subjective and since Linux

00:12:24,139 --> 00:12:29,389
doesn't run all your system with system

00:12:26,269 --> 00:12:35,300
with MMU it also needs to work when

00:12:29,389 --> 00:12:40,339
there's knowingly available for dynamic

00:12:35,300 --> 00:12:40,819
allocation case I'm using the malloc as

00:12:40,339 --> 00:12:43,759
weekend

00:12:40,819 --> 00:12:45,769
this allows to be sure that as long as

00:12:43,759 --> 00:12:48,439
there is a system memory the allocation

00:12:45,769 --> 00:12:53,389
would not fail and it uses logical pools

00:12:48,439 --> 00:12:55,220
for the perspective of having properties

00:12:53,389 --> 00:12:58,430
that are assigned to the pool and then

00:12:55,220 --> 00:13:03,019
every VM a which is allocated for that

00:12:58,430 --> 00:13:06,170
pool will have the same properties it's

00:13:03,019 --> 00:13:08,569
a kind of trade-off between kim Alok and

00:13:06,170 --> 00:13:11,990
vemma locked because rÃ©moulade basically

00:13:08,569 --> 00:13:16,699
every time it's invoked allocates one or

00:13:11,990 --> 00:13:20,430
more pages and gives those that means

00:13:16,699 --> 00:13:25,350
that in every page when user TLB entry

00:13:20,430 --> 00:13:27,240
so if you allocate 5 times 10 bytes that

00:13:25,350 --> 00:13:30,120
will that's gonna cost you a lot in

00:13:27,240 --> 00:13:32,820
terms of TLB thrashing on the other hand

00:13:30,120 --> 00:13:35,670
kima log uses a huge page mapping

00:13:32,820 --> 00:13:39,150
typically so that basically is free this

00:13:35,670 --> 00:13:42,140
solution is kinda intermediate because

00:13:39,150 --> 00:13:45,180
it reuses the free space that was

00:13:42,140 --> 00:13:47,970
available from the previous allocation

00:13:45,180 --> 00:13:50,340
so if I allocate 10 bytes from a page

00:13:47,970 --> 00:13:56,010
the next allocation will use whatever is

00:13:50,340 --> 00:14:01,260
left from that page the implementation

00:13:56,010 --> 00:14:03,240
of right where for a static allocated

00:14:01,260 --> 00:14:05,700
memory is not so different from

00:14:03,240 --> 00:14:08,220
read-only after in it the major

00:14:05,700 --> 00:14:11,600
difference is that read olive tree meat

00:14:08,220 --> 00:14:14,820
can piggyback more on constant data

00:14:11,600 --> 00:14:17,820
because they kind of go hand in hand

00:14:14,820 --> 00:14:21,440
actually at least on some architectures

00:14:17,820 --> 00:14:23,520
they are very protected simultaneously

00:14:21,440 --> 00:14:27,950
bright rare intrinsically has a

00:14:23,520 --> 00:14:30,630
different right history so it cannot be

00:14:27,950 --> 00:14:32,180
treated the same especially because of

00:14:30,630 --> 00:14:35,490
arm 64

00:14:32,180 --> 00:14:38,250
I'm 64 uses huge mappings while for

00:14:35,490 --> 00:14:41,300
right there I would like to use as small

00:14:38,250 --> 00:14:43,770
as as possible mappings to minimize the

00:14:41,300 --> 00:14:49,200
area which becomes writable when I have

00:14:43,770 --> 00:14:52,020
to modify something there's a version

00:14:49,200 --> 00:14:54,990
which is what I have posted to the piano

00:14:52,020 --> 00:14:56,640
meaning list without a hypervisor and as

00:14:54,990 --> 00:15:02,280
I was saying it's supposed to your small

00:14:56,640 --> 00:15:05,430
pages to prevent completely getting the

00:15:02,280 --> 00:15:07,500
system stack it does not disable

00:15:05,430 --> 00:15:10,490
interrupts on the whole system but only

00:15:07,500 --> 00:15:15,170
locally on the CPU which is executing

00:15:10,490 --> 00:15:18,240
what it does is it gets a new random

00:15:15,170 --> 00:15:20,700
address remaps the page which is very

00:15:18,240 --> 00:15:22,610
protected to this random address which

00:15:20,700 --> 00:15:26,070
should be harder for an attacker to

00:15:22,610 --> 00:15:30,990
identify performs the change and then

00:15:26,070 --> 00:15:33,250
destroys the mapping all of the

00:15:30,990 --> 00:15:36,670
functions implementing these are in

00:15:33,250 --> 00:15:40,170
with the hope that this reduces also in

00:15:36,670 --> 00:15:42,879
that case the attacks are faced from

00:15:40,170 --> 00:15:44,680
from an attacker meaning that it should

00:15:42,879 --> 00:15:45,850
be possible for the linker to do better

00:15:44,680 --> 00:15:50,500
and the compiler to do better

00:15:45,850 --> 00:15:53,379
optimization if all this is in line the

00:15:50,500 --> 00:15:55,300
hypervisor case is easier in a sense

00:15:53,379 --> 00:15:57,670
because I don't have to worry about

00:15:55,300 --> 00:16:00,370
mapping the upper buzzer can have its

00:15:57,670 --> 00:16:02,819
own mapping it doesn't care if the

00:16:00,370 --> 00:16:06,069
kernel is having an interrupt or not

00:16:02,819 --> 00:16:08,110
it's still good to inline the functions

00:16:06,069 --> 00:16:14,009
which get the point when the hypervisor

00:16:08,110 --> 00:16:16,420
is invoked this is what I have

00:16:14,009 --> 00:16:19,870
implemented so far of plumbing there is

00:16:16,420 --> 00:16:22,930
some discussion ongoing about whether it

00:16:19,870 --> 00:16:24,879
should be like this or not I do not have

00:16:22,930 --> 00:16:25,720
an answer I guess that's the point to

00:16:24,879 --> 00:16:31,050
ask if all of you

00:16:25,720 --> 00:16:34,240
anyway the my take away is I need the

00:16:31,050 --> 00:16:38,050
right rare implementation of the basic

00:16:34,240 --> 00:16:41,410
functionality mem copy memset assignment

00:16:38,050 --> 00:16:49,420
of a pointer handling of atomic

00:16:41,410 --> 00:16:53,050
operation the these are nice side

00:16:49,420 --> 00:16:55,209
effects for example now that certain

00:16:53,050 --> 00:16:56,800
type of data which we know is supposed

00:16:55,209 --> 00:16:59,829
to be more valuable that's why we want

00:16:56,800 --> 00:17:02,470
to protect it lives in certain areas we

00:16:59,829 --> 00:17:04,539
can use this knowledge to enhance how

00:17:02,470 --> 00:17:06,069
the news your coffee coverage it was

00:17:04,539 --> 00:17:07,659
most likely that data we don't want to

00:17:06,069 --> 00:17:09,640
well it's already very protected but how

00:17:07,659 --> 00:17:10,500
do we don't want to let user space even

00:17:09,640 --> 00:17:15,459
read it

00:17:10,500 --> 00:17:18,730
and currently I'm not really releasing

00:17:15,459 --> 00:17:21,309
any memory so it means that the use of

00:17:18,730 --> 00:17:23,949
the free attacks are kinda impossible on

00:17:21,309 --> 00:17:26,799
this because even if there is some bug

00:17:23,949 --> 00:17:29,890
which tries to use memory which was

00:17:26,799 --> 00:17:34,169
freed it will still be there because

00:17:29,890 --> 00:17:36,940
once this given it's never taken back

00:17:34,169 --> 00:17:39,400
just a different use profile the TLB I

00:17:36,940 --> 00:17:41,470
haven't measured it so I cannot say how

00:17:39,400 --> 00:17:47,250
much good or bad it is I suspect it's

00:17:41,470 --> 00:17:47,250
gonna be bit worse but I do not know how

00:17:48,690 --> 00:17:54,070
this is another thing that has received

00:17:51,420 --> 00:17:57,550
crossfire from aerosol direction but we

00:17:54,070 --> 00:17:59,050
talk about it anyway for now what I

00:17:57,550 --> 00:18:01,660
wanted to achieve was to have a

00:17:59,050 --> 00:18:04,510
compatibility between the let's say

00:18:01,660 --> 00:18:06,490
normal readwrite version of a certain

00:18:04,510 --> 00:18:09,130
data structure and the right rare

00:18:06,490 --> 00:18:12,280
version of it

00:18:09,130 --> 00:18:16,150
I wanted to recycle the reading code

00:18:12,280 --> 00:18:18,490
because since it's right rare that

00:18:16,150 --> 00:18:28,990
doesn't say anything that cannot be done

00:18:18,490 --> 00:18:31,750
with reading the key part is that more

00:18:28,990 --> 00:18:37,620
of these needs to be atomic in the sense

00:18:31,750 --> 00:18:40,200
that I want to make it so that one page

00:18:37,620 --> 00:18:43,179
remapping is sufficient I do not want to

00:18:40,200 --> 00:18:49,929
have some data crossing a page boundary

00:18:43,179 --> 00:18:52,240
some simple type of data that was a lot

00:18:49,929 --> 00:18:54,640
of words this probably explains it

00:18:52,240 --> 00:18:57,130
better so on the left side there's the

00:18:54,640 --> 00:19:00,250
typical version of the data structure on

00:18:57,130 --> 00:19:04,929
the right side there's pure version in

00:19:00,250 --> 00:19:07,090
reality is just a lot of code to access

00:19:04,929 --> 00:19:08,920
the same data in different ways but at

00:19:07,090 --> 00:19:10,900
least it should give the compiler the

00:19:08,920 --> 00:19:17,100
notion of what is a very technical

00:19:10,900 --> 00:19:17,100
whatnot and the alignment is such that

00:19:17,190 --> 00:19:20,800
one of these pointers does not cross a

00:19:19,510 --> 00:19:25,960
page boundary

00:19:20,800 --> 00:19:29,110
I have already converted and they seem

00:19:25,960 --> 00:19:32,679
to work various types of lists what

00:19:29,110 --> 00:19:34,630
might be doing next if my proposal is

00:19:32,679 --> 00:19:38,320
not fully completely rejected is the

00:19:34,630 --> 00:19:41,980
object cache why because for example if

00:19:38,320 --> 00:19:44,740
I want to apply a traitor to the ABC

00:19:41,980 --> 00:19:48,280
cache in a city looks policy to be that

00:19:44,740 --> 00:19:50,980
one allocate services lot of nodes so I

00:19:48,280 --> 00:19:56,740
need to I cannot just eat up memory

00:19:50,980 --> 00:19:59,440
forever say this there are two ways of

00:19:56,740 --> 00:20:01,930
using right

00:19:59,440 --> 00:20:03,550
one I call the chain which is probably

00:20:01,930 --> 00:20:05,080
the most obvious one and the other one

00:20:03,550 --> 00:20:09,160
is looped which is something that I

00:20:05,080 --> 00:20:11,230
found in a Samson code chain basically

00:20:09,160 --> 00:20:13,300
means that you start with statically

00:20:11,230 --> 00:20:16,720
allocated pointer or some data structure

00:20:13,300 --> 00:20:19,390
and then you have one or more dynamic

00:20:16,720 --> 00:20:20,860
allocations which follow and this is

00:20:19,390 --> 00:20:24,460
really sort of chain of trust and you

00:20:20,860 --> 00:20:26,980
want to protect it all because if you

00:20:24,460 --> 00:20:31,900
live even one link out that will be the

00:20:26,980 --> 00:20:34,150
target of the attack this is more

00:20:31,900 --> 00:20:37,990
complex but for example it is used by

00:20:34,150 --> 00:20:40,870
Knox for protect for protecting LSM so

00:20:37,990 --> 00:20:42,880
let's say that you have a data structure

00:20:40,870 --> 00:20:44,860
with some fields which are writable in

00:20:42,880 --> 00:20:47,760
some fields which are you want to

00:20:44,860 --> 00:20:51,760
protect so what you do is you split it

00:20:47,760 --> 00:20:54,250
put in a specific area the part which

00:20:51,760 --> 00:20:55,690
you want to write protect and only

00:20:54,250 --> 00:20:58,630
structures of that type will belong to

00:20:55,690 --> 00:21:01,900
that area and keep elsewhere the

00:20:58,630 --> 00:21:04,570
writable one the veritable one has a

00:21:01,900 --> 00:21:07,750
pointer to the counterpart which is very

00:21:04,570 --> 00:21:11,950
protected and the replicated part has a

00:21:07,750 --> 00:21:13,420
pointer back to the writable one the

00:21:11,950 --> 00:21:17,800
cost of this is that before the

00:21:13,420 --> 00:21:21,790
referencing what I put here as a p1 it

00:21:17,800 --> 00:21:24,430
needs to be validated because attacker

00:21:21,790 --> 00:21:27,400
could write anything there so this is a

00:21:24,430 --> 00:21:29,770
case where right rera has also read

00:21:27,400 --> 00:21:34,000
overhead basically I need to verify that

00:21:29,770 --> 00:21:35,980
that p1 points to the area where the

00:21:34,000 --> 00:21:39,850
structures might be and that it's also

00:21:35,980 --> 00:21:41,260
aligned to where the field the points

00:21:39,850 --> 00:21:44,470
back should be hold or the parent

00:21:41,260 --> 00:21:46,840
structure but it's a way of having a

00:21:44,470 --> 00:21:49,090
sort of floating protection that doesn't

00:21:46,840 --> 00:21:52,540
require the whole chain that I showed in

00:21:49,090 --> 00:21:55,060
the previous slide so again once more

00:21:52,540 --> 00:21:57,370
choosing one or the other really depends

00:21:55,060 --> 00:22:00,810
on the use case and how complex it is to

00:21:57,370 --> 00:22:04,120
provide a food chain versus taking the

00:22:00,810 --> 00:22:09,740
overhead of validating before reading

00:22:04,120 --> 00:22:13,590
the pointer this is a

00:22:09,740 --> 00:22:16,830
example of protection code as I said the

00:22:13,590 --> 00:22:20,700
validity of this volatile might change

00:22:16,830 --> 00:22:23,070
soon but for now if you look at it the

00:22:20,700 --> 00:22:25,740
green part of the code is what I have

00:22:23,070 --> 00:22:33,150
added and I think it doesn't look too

00:22:25,740 --> 00:22:36,300
alien there's a initial modifier to

00:22:33,150 --> 00:22:40,860
specify that variable is brighter after

00:22:36,300 --> 00:22:44,070
in it that's a declaration - actually

00:22:40,860 --> 00:22:46,500
this a declaration of a pool the pool is

00:22:44,070 --> 00:22:50,580
a way to specify properties for the

00:22:46,500 --> 00:22:54,300
memories will be allocated and then it

00:22:50,580 --> 00:22:59,490
shows that instead of writing size equal

00:22:54,300 --> 00:23:02,670
five I use WR underscore int to set that

00:22:59,490 --> 00:23:05,250
value the reason is that this does the

00:23:02,670 --> 00:23:11,160
magic of writing through the secondary

00:23:05,250 --> 00:23:15,660
mapping the car look is just allocating

00:23:11,160 --> 00:23:19,140
some memory and then the last

00:23:15,660 --> 00:23:20,850
distraction is writing to the pointer to

00:23:19,140 --> 00:23:22,920
the actual pointer the value of the

00:23:20,850 --> 00:23:30,000
memory that the other so the memory it

00:23:22,920 --> 00:23:32,460
was allocated this is a bit more complex

00:23:30,000 --> 00:23:35,160
and I'm not sure I should linger too

00:23:32,460 --> 00:23:38,420
much on it also because it's part of

00:23:35,160 --> 00:23:40,920
what is being currently challenged

00:23:38,420 --> 00:23:44,610
mostly what I would like to say is that

00:23:40,920 --> 00:23:47,910
I am trying to reach a point where it is

00:23:44,610 --> 00:23:50,760
really explicit if I do something with

00:23:47,910 --> 00:23:53,790
protected memory rather than not while

00:23:50,760 --> 00:23:56,220
the comments I got from various people

00:23:53,790 --> 00:24:01,040
from from upstream are that I should

00:23:56,220 --> 00:24:04,500
kinda make it happen behind the scene I

00:24:01,040 --> 00:24:05,970
don't know maybe it's me trying to get

00:24:04,500 --> 00:24:11,940
someone to convince me that I should

00:24:05,970 --> 00:24:14,720
write less code which is not bad and

00:24:11,940 --> 00:24:18,540
this is a similar case so in practice

00:24:14,720 --> 00:24:22,830
the takeaway is again where I have to

00:24:18,540 --> 00:24:24,450
read I can just look at the same

00:24:22,830 --> 00:24:27,659
the structure from a different from a

00:24:24,450 --> 00:24:29,279
different angle and I can reuse the

00:24:27,659 --> 00:24:33,529
existing functionality so I'm still

00:24:29,279 --> 00:24:36,380
using each list unhatched while for

00:24:33,529 --> 00:24:40,500
writing or altering the list I have a

00:24:36,380 --> 00:24:43,679
new function which is prh list del in

00:24:40,500 --> 00:24:46,529
place of the normal age list del and the

00:24:43,679 --> 00:24:49,860
assignment also or of the null point

00:24:46,529 --> 00:24:52,309
pointer happens to a draw specific

00:24:49,860 --> 00:24:52,309
function

00:24:54,590 --> 00:25:01,380
current limitations I still have to get

00:24:57,929 --> 00:25:03,450
it work with I'm 64 I have it working

00:25:01,380 --> 00:25:05,940
but it through the hypervisor I do not

00:25:03,450 --> 00:25:07,649
have it working without because I

00:25:05,940 --> 00:25:13,049
probably need to create a separate

00:25:07,649 --> 00:25:16,440
section with different mapping but I

00:25:13,049 --> 00:25:19,940
hope I can tackle that I need to write a

00:25:16,440 --> 00:25:24,149
lot of fullback code for the no MMU case

00:25:19,940 --> 00:25:27,419
and then I cowardly avoided writing any

00:25:24,149 --> 00:25:29,309
test case for our CEO and atomic because

00:25:27,419 --> 00:25:31,980
they're really complex at this point I

00:25:29,309 --> 00:25:35,220
was just trying to get Santa which would

00:25:31,980 --> 00:25:36,480
kind of work from end to end so that I

00:25:35,220 --> 00:25:38,669
could use it as a base for a

00:25:36,480 --> 00:25:41,279
conversation and I think I got that far

00:25:38,669 --> 00:25:47,460
now there's the more grueling part of

00:25:41,279 --> 00:25:49,590
getting work for real as a disclaimer

00:25:47,460 --> 00:25:53,159
are not claiming that it's all good

00:25:49,590 --> 00:25:57,740
there are things that I know do not work

00:25:53,159 --> 00:26:02,549
or can be attacked as I said right now

00:25:57,740 --> 00:26:05,760
even with the hypervisor you do not

00:26:02,549 --> 00:26:07,350
really know for sure who is asking you

00:26:05,760 --> 00:26:09,600
to modify something so if the attacker

00:26:07,350 --> 00:26:12,210
is smart enough can use the system

00:26:09,600 --> 00:26:14,580
against itself I've actually seen this

00:26:12,210 --> 00:26:19,500
sort of attack described in some slides

00:26:14,580 --> 00:26:26,269
against a Knox phone so I'm not saying

00:26:19,500 --> 00:26:26,269
anything new the meta data used is also

00:26:26,360 --> 00:26:33,299
could be used for an attack so that

00:26:30,570 --> 00:26:35,420
might be possible to protect but I'm not

00:26:33,299 --> 00:26:38,040
sure how yet

00:26:35,420 --> 00:26:40,410
mm you page tables are also something

00:26:38,040 --> 00:26:43,560
that could be attacked but again the

00:26:40,410 --> 00:26:46,830
goal is if we could reduce the attack to

00:26:43,560 --> 00:26:49,440
surface the MMU page tables for example

00:26:46,830 --> 00:26:51,420
that might be incentive to hardware

00:26:49,440 --> 00:26:55,490
designers to think about something that

00:26:51,420 --> 00:26:57,600
would make it harder to attack those and

00:26:55,490 --> 00:27:00,230
there's the usual problem with

00:26:57,600 --> 00:27:03,180
randomness that if someone manages to

00:27:00,230 --> 00:27:05,910
drain your randomness pool then it

00:27:03,180 --> 00:27:10,980
becomes easier to guess where the next

00:27:05,910 --> 00:27:15,060
write will be marked true there are

00:27:10,980 --> 00:27:19,200
performance limitations if for example I

00:27:15,060 --> 00:27:21,630
want to append or insert a node in a

00:27:19,200 --> 00:27:23,790
list I have to deal with four pointers

00:27:21,630 --> 00:27:24,500
right now I'm doing it on them one by

00:27:23,790 --> 00:27:28,200
one

00:27:24,500 --> 00:27:29,610
also because first I wanted to get to

00:27:28,200 --> 00:27:32,190
the point where there is a good

00:27:29,610 --> 00:27:35,070
confidence that the right rear base

00:27:32,190 --> 00:27:38,640
mechanics works but the point is I am

00:27:35,070 --> 00:27:41,100
going four times through remapping or

00:27:38,640 --> 00:27:44,730
possibly hypervisor course this has a

00:27:41,100 --> 00:27:46,890
performance cost Italy if I have

00:27:44,730 --> 00:27:49,890
something which is used a lot and I

00:27:46,890 --> 00:27:53,580
think lists a very good example then it

00:27:49,890 --> 00:27:56,130
might be worth to promote them in a

00:27:53,580 --> 00:27:58,920
sense to become intrinsic right-rear

00:27:56,130 --> 00:28:03,650
functions instead of depending on some

00:27:58,920 --> 00:28:03,650
more basic function like a sign pointer

00:28:04,760 --> 00:28:13,590
yeah

00:28:07,130 --> 00:28:18,330
what's next yes I have to fix the static

00:28:13,590 --> 00:28:24,240
writer after in it for I'm 64 and the

00:28:18,330 --> 00:28:26,300
fallback in the test case is then the

00:28:24,240 --> 00:28:28,560
problems I just described

00:28:26,300 --> 00:28:32,550
probably vetting the cool part is

00:28:28,560 --> 00:28:34,260
something doable the metadata is

00:28:32,550 --> 00:28:37,020
questionable because it's not only about

00:28:34,260 --> 00:28:39,120
the metadata that I'm producing with

00:28:37,020 --> 00:28:41,490
pima lock pool but also the metadata

00:28:39,120 --> 00:28:43,710
that comes from the Rhema lock areas and

00:28:41,490 --> 00:28:47,900
that seems to be in a completely

00:28:43,710 --> 00:28:47,900
different class of difficulty

00:28:49,290 --> 00:28:54,460
this is the optimization I mentioned

00:28:52,390 --> 00:28:56,260
earlier the drawback of that is that

00:28:54,460 --> 00:28:59,500
basically whatever becomes sort of

00:28:56,260 --> 00:29:02,430
intrinsic function then needs to be

00:28:59,500 --> 00:29:06,490
implemented also on the hypervisor side

00:29:02,430 --> 00:29:09,100
so it would be nice if there was some

00:29:06,490 --> 00:29:10,960
sort of data library that could be

00:29:09,100 --> 00:29:16,900
shared in both cases but I don't know

00:29:10,960 --> 00:29:21,160
how much that is possible and assuming I

00:29:16,900 --> 00:29:24,760
have any spare time this is what I would

00:29:21,160 --> 00:29:27,370
like to do I see logs and Alison books

00:29:24,760 --> 00:29:31,030
they go kinda hand-in-hand well in

00:29:27,370 --> 00:29:33,130
reality I think protecting any Linux

00:29:31,030 --> 00:29:35,140
module requires also protecting the

00:29:33,130 --> 00:29:38,440
Ellison books because as I mentioned

00:29:35,140 --> 00:29:40,210
when I was talking about chains and SM

00:29:38,440 --> 00:29:43,690
hooks is again something that is always

00:29:40,210 --> 00:29:46,000
in the way and it's useless that you

00:29:43,690 --> 00:29:50,200
have a very hard and module if it can be

00:29:46,000 --> 00:29:52,390
just unplugged for selinux the policy DB

00:29:50,200 --> 00:29:55,510
is kinda easy I've already done it but

00:29:52,390 --> 00:29:59,440
it's not something that I have submitted

00:29:55,510 --> 00:30:01,780
upstream ABC I have tried it without

00:29:59,440 --> 00:30:05,230
right rare and I managed to make it

00:30:01,780 --> 00:30:09,310
becomes 10 times slower so I'm not gonna

00:30:05,230 --> 00:30:11,200
submit containers might be a nice use

00:30:09,310 --> 00:30:12,490
case unfortunately don't remember the

00:30:11,200 --> 00:30:15,640
name of this person but someone was

00:30:12,490 --> 00:30:20,380
trying to submit patch for Allison hooks

00:30:15,640 --> 00:30:23,680
to try to improve the support for

00:30:20,380 --> 00:30:26,080
containers so you can have read-only

00:30:23,680 --> 00:30:28,450
books for the main execution environment

00:30:26,080 --> 00:30:29,890
but you could have write rarer for

00:30:28,450 --> 00:30:34,110
everything as it is in a container

00:30:29,890 --> 00:30:34,110
because that's an D that you can destroy

00:30:34,950 --> 00:30:41,980
does it work it seems to although again

00:30:40,270 --> 00:30:44,770
this morning was pointed out that I'm

00:30:41,980 --> 00:30:47,740
doing something nasty with interact

00:30:44,770 --> 00:30:52,090
disable that I shouldn't I have to look

00:30:47,740 --> 00:30:54,430
into that but there are also two types

00:30:52,090 --> 00:30:57,060
of does it work

00:30:54,430 --> 00:31:01,149
I think so far it's also reasonably

00:30:57,060 --> 00:31:02,589
usable that it can be used to convert

00:31:01,149 --> 00:31:04,179
existing code I think that that's a

00:31:02,589 --> 00:31:06,580
major point that if I come up with

00:31:04,179 --> 00:31:08,349
something that works but nobody wants to

00:31:06,580 --> 00:31:13,749
use because this is any complicated than

00:31:08,349 --> 00:31:15,489
I haven't achieved much for sure I think

00:31:13,749 --> 00:31:18,879
we can agree that it reduces the attack

00:31:15,489 --> 00:31:22,359
surface and maybe even more it makes the

00:31:18,879 --> 00:31:26,619
system less prone to undetected the

00:31:22,359 --> 00:31:30,399
memory corruption hypervisor yes is the

00:31:26,619 --> 00:31:34,080
magic I think it's coming one way or the

00:31:30,399 --> 00:31:36,879
other a reality a lot of Linux

00:31:34,080 --> 00:31:39,009
applications do use a hypervisor for

00:31:36,879 --> 00:31:40,389
very different reasons but it's there so

00:31:39,009 --> 00:31:43,229
I don't think we can ignore that it's

00:31:40,389 --> 00:31:47,399
there we should take advantage of it

00:31:43,229 --> 00:31:50,320
there are there is a possibility that

00:31:47,399 --> 00:31:52,389
contraflow attacks can sidestep all of

00:31:50,320 --> 00:31:54,460
these I don't have an answer for that

00:31:52,389 --> 00:31:56,399
other than I couldn't think it's

00:31:54,460 --> 00:32:01,179
possible to make it completely

00:31:56,399 --> 00:32:05,529
bulletproof one thing that I think is

00:32:01,179 --> 00:32:07,389
good is the fact that it's obscene so if

00:32:05,529 --> 00:32:12,190
you feel that your system can use it

00:32:07,389 --> 00:32:17,169
good if not well maybe next time thank

00:32:12,190 --> 00:32:19,659
you as a reference okay I suggest that

00:32:17,169 --> 00:32:24,279
you do not look at my patch set because

00:32:19,659 --> 00:32:27,399
this is really ugly but what I sent to

00:32:24,279 --> 00:32:30,879
the meaning list is a bit less ugly for

00:32:27,399 --> 00:32:33,070
your convenience I have put these were

00:32:30,879 --> 00:32:34,809
just one huge star ball so what I've

00:32:33,070 --> 00:32:38,739
done I have downloaded the publicly

00:32:34,809 --> 00:32:41,200
available source code from Hawaii and

00:32:38,739 --> 00:32:43,269
from Samsung and they put it on github

00:32:41,200 --> 00:32:45,909
you can see there are some of the things

00:32:43,269 --> 00:32:47,859
I mentioned if you really want to see

00:32:45,909 --> 00:32:50,499
how we are protecting a city looks now

00:32:47,859 --> 00:32:54,899
you can see there and you can see the

00:32:50,499 --> 00:32:57,899
LSM protection from Samsung and it's all

00:32:54,899 --> 00:32:57,899
questions

00:33:03,540 --> 00:33:10,300
thanks for talking for this research

00:33:06,970 --> 00:33:13,050
you mentioned the problems and that you

00:33:10,300 --> 00:33:15,670
can't understand whether the color of

00:33:13,050 --> 00:33:19,660
the right function is well it or not

00:33:15,670 --> 00:33:23,560
maybe the control flow integrity can

00:33:19,660 --> 00:33:28,030
give partial answer to this so it

00:33:23,560 --> 00:33:32,350
enforces that only the colors from

00:33:28,030 --> 00:33:35,230
initial source code are able to call

00:33:32,350 --> 00:33:36,970
your function and it restricts and the

00:33:35,230 --> 00:33:40,240
number from which you can call the

00:33:36,970 --> 00:33:43,510
writing function yes the control flow

00:33:40,240 --> 00:33:48,040
integrity is one thing definitely

00:33:43,510 --> 00:33:50,170
doesn't hurt one problem is that there

00:33:48,040 --> 00:33:53,650
are I've seen various implementations

00:33:50,170 --> 00:33:57,820
and each of them can be kind of

00:33:53,650 --> 00:33:59,170
sidestepped in some cases so I think

00:33:57,820 --> 00:34:01,390
it's the same problem with security in

00:33:59,170 --> 00:34:03,160
general you might have something that

00:34:01,390 --> 00:34:06,190
it's nice to have but you cannot trust

00:34:03,160 --> 00:34:10,500
it at with it fix all the cases but yeah

00:34:06,190 --> 00:34:13,480
for sure anything which hampers the

00:34:10,500 --> 00:34:20,080
alteration of how the flow of the

00:34:13,480 --> 00:34:21,760
program should be small reminder to for

00:34:20,080 --> 00:34:25,090
poor asks questions please introduce

00:34:21,760 --> 00:34:32,200
yourself but people can find you just to

00:34:25,090 --> 00:34:34,930
do David Hills I would like to know

00:34:32,200 --> 00:34:37,320
what's of the vectors by which this

00:34:34,930 --> 00:34:40,090
overwriting is actually happening

00:34:37,320 --> 00:34:43,900
because I've heard stories about Android

00:34:40,090 --> 00:34:48,070
having secret files which provide access

00:34:43,900 --> 00:34:50,110
to memory these past I'm sorry I it's

00:34:48,070 --> 00:34:54,070
through that I work for a company which

00:34:50,110 --> 00:34:57,520
makes phones but what I work on is what

00:34:54,070 --> 00:35:00,960
you've seen so there might be something

00:34:57,520 --> 00:35:03,670
but I cannot answer this question so

00:35:00,960 --> 00:35:05,320
historically there was dev X nos mam on

00:35:03,670 --> 00:35:08,650
certain devices which allowed you to do

00:35:05,320 --> 00:35:09,930
that have been other things that vendors

00:35:08,650 --> 00:35:11,910
are put together where they've not

00:35:09,930 --> 00:35:22,440
thought very strongly sorry

00:35:11,910 --> 00:35:24,119
mantra and um when questions hi

00:35:22,440 --> 00:35:26,520
Tyco Anderson I'm actually one of the

00:35:24,119 --> 00:35:29,970
people who complained about the but I

00:35:26,520 --> 00:35:31,950
like the work in general so I just was

00:35:29,970 --> 00:35:33,599
wondering like you could use CF I you

00:35:31,950 --> 00:35:35,970
could also like even it's just a first

00:35:33,599 --> 00:35:37,619
attempt do like I've sort of a set F s

00:35:35,970 --> 00:35:39,059
style thing where you say okay I'm about

00:35:37,619 --> 00:35:40,829
to enter some code which is gonna cause

00:35:39,059 --> 00:35:43,140
a fault we're gonna we should allow this

00:35:40,829 --> 00:35:46,230
to be mapped writable and then unset it

00:35:43,140 --> 00:35:47,789
later just as like you know I know that

00:35:46,230 --> 00:35:51,869
this specific little bit of code is

00:35:47,789 --> 00:35:53,339
gonna write to not writable memory and I

00:35:51,869 --> 00:35:56,700
know that this other little specific bit

00:35:53,339 --> 00:35:58,740
is but in general now I will protect

00:35:56,700 --> 00:36:00,420
against all of the other write anywhere

00:35:58,740 --> 00:36:02,160
primitives that exist outside of these

00:36:00,420 --> 00:36:04,470
little specific bits of code so you get

00:36:02,160 --> 00:36:07,349
you know a lot of this without having to

00:36:04,470 --> 00:36:11,760
wait for CFI or anything else what

00:36:07,349 --> 00:36:13,049
listing of functions which can well yeah

00:36:11,760 --> 00:36:15,450
I mean I guess I was thinking of it's

00:36:13,049 --> 00:36:18,380
just like a global bit that you enable

00:36:15,450 --> 00:36:21,000
and say I'm about to do some some

00:36:18,380 --> 00:36:24,420
activity that's gonna cause a fault and

00:36:21,000 --> 00:36:26,609
writable memory but it's okay do the

00:36:24,420 --> 00:36:29,039
fault remap it is writable do your

00:36:26,609 --> 00:36:31,650
access then go back to the regular code

00:36:29,039 --> 00:36:33,660
and then unset that bit so then in

00:36:31,650 --> 00:36:36,420
normal execution if there is a write to

00:36:33,660 --> 00:36:41,819
this place then it faults and things but

00:36:36,420 --> 00:36:43,619
panic or whatever so what we like

00:36:41,819 --> 00:36:47,579
something else I don't know it's just

00:36:43,619 --> 00:36:49,770
another another level I mean so again if

00:36:47,579 --> 00:36:51,059
the bit itself is right protected then

00:36:49,770 --> 00:36:56,130
it's you have to be able to call a

00:36:51,059 --> 00:36:58,680
function and right yeah well I mean it's

00:36:56,130 --> 00:37:02,520
kind of becoming a philosophical sure

00:36:58,680 --> 00:37:04,770
yeah yeah totally but but the problem or

00:37:02,520 --> 00:37:06,599
the reason why I'm not so fond of

00:37:04,770 --> 00:37:10,740
something global is that basically you

00:37:06,599 --> 00:37:16,680
are giving a real clear point of attack

00:37:10,740 --> 00:37:18,150
that is easier to identify yeah but you

00:37:16,680 --> 00:37:20,970
also don't have to duplicate every data

00:37:18,150 --> 00:37:23,210
structure in the kernel so no well I'm

00:37:20,970 --> 00:37:26,869
wondering is there a better way so

00:37:23,210 --> 00:37:28,339
please take my proposal as something

00:37:26,869 --> 00:37:33,050
which is a conversation start they're

00:37:28,339 --> 00:37:34,940
not saying this is the truth and I think

00:37:33,050 --> 00:37:39,410
I know better I'm the saying this is a

00:37:34,940 --> 00:37:41,359
way to do it how can we do it better the

00:37:39,410 --> 00:37:43,190
pain is as soon as you start protecting

00:37:41,359 --> 00:37:46,099
larger and larger structures you wind up

00:37:43,190 --> 00:37:48,559
going Oh way to need all of the lists

00:37:46,099 --> 00:37:50,869
handling functions dealt with and now I

00:37:48,559 --> 00:37:52,640
need all the atomic sand yeah it's

00:37:50,869 --> 00:37:54,319
trying to find in the middle ground I

00:37:52,640 --> 00:37:59,480
think is where it's gonna be tricky

00:37:54,319 --> 00:38:01,369
I think we better stop here so maybe we

00:37:59,480 --> 00:38:02,070
can take more discussion so let's think

00:38:01,369 --> 00:38:05,059
a speaker

00:38:02,070 --> 00:38:05,059

YouTube URL: https://www.youtube.com/watch?v=mrq2ImIb7fY


