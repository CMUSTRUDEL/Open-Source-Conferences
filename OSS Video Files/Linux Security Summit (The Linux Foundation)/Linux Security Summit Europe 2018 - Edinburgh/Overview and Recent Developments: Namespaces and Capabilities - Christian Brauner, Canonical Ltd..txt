Title: Overview and Recent Developments: Namespaces and Capabilities - Christian Brauner, Canonical Ltd.
Publication date: 2018-10-26
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Overview and Recent Developments: Namespaces and Capabilities - Christian Brauner, Canonical Ltd.Â 

 This presentation will cover the current state of namespaces and capabilities. We will cover recent developments and take a look at new features currently being developed and touch on some open problems. 

About Christian Brauner
Christian Brauner is a kernel and core developer and maintainer of the LXD and LXC projects. He works mostly upstream on the Linux Kernel and lower-level problems. He is strongly committed to working in the open, and a strong proponent of Free Software.
Christian has been active in the open source community for a long time and is a frequent speaker at various large events:

Nvidia GPU Technology Conference, San JosÃ© 2018
FOSDEM 2016, 2017, 2018
Linux Piter 2017
Linux Plumbers 2016, 2017
Open Source Summit, NA 2017, 2018
Open Source Summit, EU 2017, 2018
Container Camp, UK 2018
Container Camp, Sydney 2017
Captions: 
	00:00:00,930 --> 00:00:06,919
so hey I'm Christian I work the colonel

00:00:04,890 --> 00:00:09,630
engineer Nana Lexi and LexA T team at

00:00:06,919 --> 00:00:12,300
canonical and I'm going to give the

00:00:09,630 --> 00:00:15,089
subsystem talk for namespaces and

00:00:12,300 --> 00:00:16,980
capabilities or SK said if containers

00:00:15,089 --> 00:00:19,010
are the piece that is painting a target

00:00:16,980 --> 00:00:24,720
on the kernel we're providing the paint

00:00:19,010 --> 00:00:27,060
essentially exactly so a short

00:00:24,720 --> 00:00:28,949
introduction into what most people know

00:00:27,060 --> 00:00:30,420
what namespaces and capabilities are so

00:00:28,949 --> 00:00:31,980
I'm not going to do any sort of deep

00:00:30,420 --> 00:00:34,260
dive but the capabilities are

00:00:31,980 --> 00:00:35,969
essentially a way to split the root

00:00:34,260 --> 00:00:37,500
privilege into distinct units of

00:00:35,969 --> 00:00:40,170
privilege if you want to put it like

00:00:37,500 --> 00:00:42,629
this so that you're not just root can do

00:00:40,170 --> 00:00:45,120
anything but you can safely delegate

00:00:42,629 --> 00:00:47,430
certain types of privilege to

00:00:45,120 --> 00:00:50,250
unprivileged users by for example using

00:00:47,430 --> 00:00:52,710
capabilities you have caps as admin cap

00:00:50,250 --> 00:00:54,329
Mac admin cap net admin and so on and

00:00:52,710 --> 00:00:59,579
they all regulate certain types of

00:00:54,329 --> 00:01:01,469
certain types of things you can do so an

00:00:59,579 --> 00:01:04,890
announcement I can make a slip cap now

00:01:01,469 --> 00:01:09,060
has been released on the 10th of

00:01:04,890 --> 00:01:11,610
September 2018 search Andrew Morgan and

00:01:09,060 --> 00:01:14,700
I added full ambient capability support

00:01:11,610 --> 00:01:17,580
and support for namespace file system

00:01:14,700 --> 00:01:20,159
capabilities the library also has moved

00:01:17,580 --> 00:01:22,200
and Andrew Morgan spec maintaining it so

00:01:20,159 --> 00:01:26,130
that's pretty cool he has been AWOL for

00:01:22,200 --> 00:01:27,990
about a couple of years I guess so

00:01:26,130 --> 00:01:30,689
namespace is what our namespaces I

00:01:27,990 --> 00:01:33,150
always like to say it's a basically a

00:01:30,689 --> 00:01:36,869
very lightweight virtualization method

00:01:33,150 --> 00:01:38,070
for various aspects of the system and in

00:01:36,869 --> 00:01:40,350
contrast to virtual machines that

00:01:38,070 --> 00:01:42,450
virtualizes well basically the whole

00:01:40,350 --> 00:01:45,810
system at once it's always just about

00:01:42,450 --> 00:01:47,820
some specific feature and what I mean by

00:01:45,810 --> 00:01:50,280
this is we have now one two three four I

00:01:47,820 --> 00:01:55,110
always need to count seven namespaces at

00:01:50,280 --> 00:01:57,000
the moment mount fits a UTS ipcc group

00:01:55,110 --> 00:01:59,070
network and user namespaces and I guess

00:01:57,000 --> 00:02:00,780
the easiest way to understand what a

00:01:59,070 --> 00:02:02,130
namespace is doing is for example to

00:02:00,780 --> 00:02:04,439
look at the oldest one which is the

00:02:02,130 --> 00:02:06,600
mountain named space so ignoring mount

00:02:04,439 --> 00:02:10,379
propagation for now if you create a new

00:02:06,600 --> 00:02:12,000
mount namespace it duplicates your mount

00:02:10,379 --> 00:02:12,290
table so all the mounts you had in the

00:02:12,000 --> 00:02:14,180
image

00:02:12,290 --> 00:02:17,120
to mount namespace you now also have any

00:02:14,180 --> 00:02:18,769
answers in our namespace and if you do a

00:02:17,120 --> 00:02:21,079
mount or you mount operation in there

00:02:18,769 --> 00:02:23,359
ignoring mount propagation it will not

00:02:21,079 --> 00:02:25,790
be reflected in your parent amount

00:02:23,359 --> 00:02:27,379
namespace but it's misleading insofar as

00:02:25,790 --> 00:02:29,720
actually mount namespaces are not

00:02:27,379 --> 00:02:31,220
hierarchical there are some hierarchical

00:02:29,720 --> 00:02:32,870
namespaces mountain is not one of them

00:02:31,220 --> 00:02:36,140
but that's sort of the idea Network

00:02:32,870 --> 00:02:39,170
namespaces network interfaces see group

00:02:36,140 --> 00:02:41,120
namespaces give you the idea that you at

00:02:39,170 --> 00:02:42,620
the root of a new C group tree even

00:02:41,120 --> 00:02:45,799
though you're further down in the C

00:02:42,620 --> 00:02:48,650
group hierarchy IP C namespaces POSIX

00:02:45,799 --> 00:02:50,959
message queues and so on are isolated

00:02:48,650 --> 00:02:52,489
per namespace bit namespaces are one of

00:02:50,959 --> 00:02:55,870
the few namespaces that are properly

00:02:52,489 --> 00:02:59,930
hierarchical means each ancestor

00:02:55,870 --> 00:03:01,849
descendant each ancestor space and pit

00:02:59,930 --> 00:03:05,269
namespace can all see all of the

00:03:01,849 --> 00:03:06,769
processes of its child namespaces so

00:03:05,269 --> 00:03:08,930
they're probably nested you could put it

00:03:06,769 --> 00:03:10,819
like this and there are a couple of

00:03:08,930 --> 00:03:14,209
other namespaces that are in the works

00:03:10,819 --> 00:03:15,950
right now so there is a patch setup for

00:03:14,209 --> 00:03:19,540
time namespaces this is something I'm

00:03:15,950 --> 00:03:22,340
going to touch upon in a little bit

00:03:19,540 --> 00:03:25,069
device namespaces were supposed to be a

00:03:22,340 --> 00:03:28,489
thing day and really but we sort of have

00:03:25,069 --> 00:03:29,930
a device namespace right now I'm going

00:03:28,489 --> 00:03:32,090
to talk about it in a little bit and

00:03:29,930 --> 00:03:34,129
there is talk about an imine namespace

00:03:32,090 --> 00:03:35,659
although this is likely not a real name

00:03:34,129 --> 00:03:38,209
space but will be tied to a namespace

00:03:35,659 --> 00:03:40,099
but Mimi's probably way better equipped

00:03:38,209 --> 00:03:43,669
to talk about this and then I am

00:03:40,099 --> 00:03:45,199
actually so the one final namespace I

00:03:43,669 --> 00:03:46,729
want to mention is the user name space

00:03:45,199 --> 00:03:48,829
this is the one and usually not a lot of

00:03:46,729 --> 00:03:50,629
people know too much about how many

00:03:48,829 --> 00:03:53,599
people are more acquainted with user

00:03:50,629 --> 00:03:56,959
name spaces Oh actually quite a few but

00:03:53,599 --> 00:03:58,609
not like not the whole crowd so for most

00:03:56,959 --> 00:04:00,530
of the other namespaces there is no real

00:03:58,609 --> 00:04:01,939
privilege separation going on that means

00:04:00,530 --> 00:04:03,620
if I create a new Mountain name space

00:04:01,939 --> 00:04:05,419
network namespace or whatever I don't

00:04:03,620 --> 00:04:06,229
get any strong security guarantees

00:04:05,419 --> 00:04:08,090
whatsoever

00:04:06,229 --> 00:04:10,220
I can still shut down the house that can

00:04:08,090 --> 00:04:12,739
still shown files and so on the system

00:04:10,220 --> 00:04:15,650
is still fully under my control and sort

00:04:12,739 --> 00:04:17,539
of one of the ideas was okay if you want

00:04:15,650 --> 00:04:19,340
to run untrusted workloads in the age of

00:04:17,539 --> 00:04:22,460
containers you should better have some

00:04:19,340 --> 00:04:24,289
way of making sure that route additives

00:04:22,460 --> 00:04:26,100
somehow isolate yourself sufficiently

00:04:24,289 --> 00:04:28,380
from the rest of the system so that

00:04:26,100 --> 00:04:30,690
easily put it in danger and so why not

00:04:28,380 --> 00:04:32,820
introduce a namespace it isolates all of

00:04:30,690 --> 00:04:34,620
the privileged concepts that a Linux

00:04:32,820 --> 00:04:36,660
system or a standard UNIX system comes

00:04:34,620 --> 00:04:39,450
with and this is sort of the idea I

00:04:36,660 --> 00:04:41,430
guess for user name space or as I like

00:04:39,450 --> 00:04:43,140
to see them he introduced a new

00:04:41,430 --> 00:04:45,450
namespace that just deals with privilege

00:04:43,140 --> 00:04:47,040
separation and so there are a couple of

00:04:45,450 --> 00:04:49,740
requirements in the way that user

00:04:47,040 --> 00:04:51,450
namespaces work is first of all

00:04:49,740 --> 00:04:53,520
obviously what carries privileges on a

00:04:51,450 --> 00:04:55,620
UNIX system the UID and GID so you

00:04:53,520 --> 00:04:59,610
separate the hosts you IDs and gids from

00:04:55,620 --> 00:05:01,200
the namespace you a DS and DS and but

00:04:59,610 --> 00:05:03,030
such in a way that you lose a user and

00:05:01,200 --> 00:05:05,310
as route ID is privileged over the user

00:05:03,030 --> 00:05:07,710
Ness so what it means is you can be UID

00:05:05,310 --> 00:05:09,390
0 from within your namespace but outside

00:05:07,710 --> 00:05:11,910
in the parent namespace or the host

00:05:09,390 --> 00:05:13,500
namespace host user namespace it will

00:05:11,910 --> 00:05:16,020
run as a fully privileged to you I D

00:05:13,500 --> 00:05:18,270
like UID 100,000 and there is a mapping

00:05:16,020 --> 00:05:20,490
mapping established between those two so

00:05:18,270 --> 00:05:22,770
ya within the namespace within the user

00:05:20,490 --> 00:05:24,450
name space you have apparently all the

00:05:22,770 --> 00:05:26,220
privileges this route has and it's

00:05:24,450 --> 00:05:27,810
semantically and syntactically somewhat

00:05:26,220 --> 00:05:30,420
similar to what the user and as root

00:05:27,810 --> 00:05:33,420
means on the host but it's isolated so

00:05:30,420 --> 00:05:35,040
it cannot affect any resources that are

00:05:33,420 --> 00:05:38,250
global for example on the system at

00:05:35,040 --> 00:05:40,170
least it's the idea you also want

00:05:38,250 --> 00:05:41,730
nesting to be possible so you want it to

00:05:40,170 --> 00:05:43,440
be a namespace so you can as an

00:05:41,730 --> 00:05:45,990
unprivileged user you should be able to

00:05:43,440 --> 00:05:47,730
create a new user name space within a

00:05:45,990 --> 00:05:49,590
user name space you should be able to

00:05:47,730 --> 00:05:51,540
create another user name space and so on

00:05:49,590 --> 00:05:54,300
so you can have layers of isolation and

00:05:51,540 --> 00:05:55,470
layers of nesting and so this is

00:05:54,300 --> 00:05:57,000
something I mentioned before the user

00:05:55,470 --> 00:05:59,280
knows food IDs should not be privileged

00:05:57,000 --> 00:06:01,620
over any resources it does not own so

00:05:59,280 --> 00:06:03,750
for example if you have a global limit

00:06:01,620 --> 00:06:06,450
on the maximum number of files that your

00:06:03,750 --> 00:06:08,610
system cannot open user and as root in a

00:06:06,450 --> 00:06:11,760
user name space should definitely not be

00:06:08,610 --> 00:06:14,490
able to set this only the initial root

00:06:11,760 --> 00:06:15,870
user should be able to do this and the

00:06:14,490 --> 00:06:17,550
last point I mentioned to unprivileged

00:06:15,870 --> 00:06:21,030
users should be able to safely create a

00:06:17,550 --> 00:06:22,530
user name space and the last point is

00:06:21,030 --> 00:06:24,720
capabilities which I mentioned at the

00:06:22,530 --> 00:06:27,120
beginning they should all be charged

00:06:24,720 --> 00:06:30,600
against the user name space meaning so

00:06:27,120 --> 00:06:33,000
if I ask the question do I have this

00:06:30,600 --> 00:06:34,860
capability then what I'm really asking

00:06:33,000 --> 00:06:35,849
over should be asking is do I have this

00:06:34,860 --> 00:06:38,249
capability in

00:06:35,849 --> 00:06:40,020
the current user namespace that model

00:06:38,249 --> 00:06:41,669
breaks for some capabilities like for a

00:06:40,020 --> 00:06:43,679
long time for example if you ask the

00:06:41,669 --> 00:06:45,689
question can I create device notes then

00:06:43,679 --> 00:06:47,909
the kernel would check do I have kept

00:06:45,689 --> 00:06:51,779
make not in the initial user namespace

00:06:47,909 --> 00:06:54,119
not in the my current user namespace

00:06:51,779 --> 00:06:56,879
although that has changed in recent

00:06:54,119 --> 00:06:58,589
current releases and you introduced a

00:06:56,879 --> 00:07:00,509
concept of an owning user namespace that

00:06:58,589 --> 00:07:02,999
means all of the other namespaces have

00:07:00,509 --> 00:07:04,469
an owning user name space such that if

00:07:02,999 --> 00:07:06,270
you create a new user name space then

00:07:04,469 --> 00:07:08,009
unshare your network namespace that

00:07:06,270 --> 00:07:10,830
network namespace will be owned by the

00:07:08,009 --> 00:07:12,899
user namespace that you created so

00:07:10,830 --> 00:07:14,969
basically if you ask questions like do I

00:07:12,899 --> 00:07:16,529
have cap net admin to operate on this

00:07:14,969 --> 00:07:18,449
network names based and the kernel will

00:07:16,529 --> 00:07:20,309
look what is the owning user namespace

00:07:18,449 --> 00:07:22,559
of that network namespace and do I have

00:07:20,309 --> 00:07:23,339
the capability in that user namespace so

00:07:22,559 --> 00:07:25,559
that's the whole idea

00:07:23,339 --> 00:07:27,719
and obviously all kinds of other

00:07:25,559 --> 00:07:29,519
resources like specific file system

00:07:27,719 --> 00:07:32,699
files and so on they can be made per

00:07:29,519 --> 00:07:34,619
user namespace or they stay global yeah

00:07:32,699 --> 00:07:37,229
so that's it for capabilities and

00:07:34,619 --> 00:07:39,179
namespaces so what has happened and

00:07:37,229 --> 00:07:41,219
actually I don't know when the last talk

00:07:39,179 --> 00:07:43,949
was about namespaces and capabilities so

00:07:41,219 --> 00:07:45,899
I'm covering 410 to 418 we can skip

00:07:43,949 --> 00:07:48,209
stuff if we don't have sufficient time

00:07:45,899 --> 00:07:52,199
but actually I think that has happened a

00:07:48,209 --> 00:07:54,869
lot so in 410 I think it even started

00:07:52,199 --> 00:07:56,639
before that I was a lot of work done by

00:07:54,869 --> 00:07:59,189
Eric and I guess by self and a bunch of

00:07:56,639 --> 00:08:00,719
other people to make a deal to basically

00:07:59,189 --> 00:08:02,430
get the infrastructure in place to

00:08:00,719 --> 00:08:04,499
enable mounts from non initial user

00:08:02,430 --> 00:08:06,479
namespaces something which hasn't been

00:08:04,499 --> 00:08:08,729
possible for an interesting file system

00:08:06,479 --> 00:08:10,439
before like I mean you can mount a temp

00:08:08,729 --> 00:08:12,089
of s or whatever inside a user name

00:08:10,439 --> 00:08:13,860
space but that's not really interesting

00:08:12,089 --> 00:08:15,539
a lot of people would be interested to

00:08:13,860 --> 00:08:17,579
mount I don't know x4 inside of the user

00:08:15,539 --> 00:08:19,559
name space which is still not possible

00:08:17,579 --> 00:08:22,169
but technically the infrastructure is

00:08:19,559 --> 00:08:24,089
there you can do with refused though so

00:08:22,169 --> 00:08:28,319
there was a lot of work done in 410

00:08:24,089 --> 00:08:30,899
around this also Eric added a new user

00:08:28,319 --> 00:08:32,579
and his owner to the mm struct so that

00:08:30,899 --> 00:08:34,919
you can now have sensible Pete Ray's

00:08:32,579 --> 00:08:37,439
permission checks across x-act this was

00:08:34,919 --> 00:08:38,819
a security issue it had been around for

00:08:37,439 --> 00:08:41,939
a long time I think there was a couple

00:08:38,819 --> 00:08:44,159
of fixes going in after this as well but

00:08:41,939 --> 00:08:45,110
it's well actually quite important and

00:08:44,159 --> 00:08:48,150
Rea vagin

00:08:45,110 --> 00:08:49,860
I have a good memory for names so

00:08:48,150 --> 00:08:51,390
I should hopefully be possible to

00:08:49,860 --> 00:08:55,140
remember most of the people that did the

00:08:51,390 --> 00:08:56,580
work but don't hold me to it he had an

00:08:55,140 --> 00:08:59,160
eye octal to get a socket network

00:08:56,580 --> 00:09:00,120
namespace so sometimes you need to ask

00:08:59,160 --> 00:09:02,520
the question

00:09:00,120 --> 00:09:04,590
this socket file descriptor I'm having

00:09:02,520 --> 00:09:06,450
right now which network namespace does

00:09:04,590 --> 00:09:08,220
it belong to this is infrastructure to

00:09:06,450 --> 00:09:14,340
actually give you an answer to this

00:09:08,220 --> 00:09:17,130
question for elf 411 ah yeah we finally

00:09:14,340 --> 00:09:18,900
got limit of inotify instances per user

00:09:17,130 --> 00:09:21,630
name space because before you could

00:09:18,900 --> 00:09:24,570
technically exhaust the global inotify

00:09:21,630 --> 00:09:26,190
limit from within a user name space

00:09:24,570 --> 00:09:28,490
this hasn't been a cowboy hadn't been

00:09:26,190 --> 00:09:33,660
accounted for just landed in 411

00:09:28,490 --> 00:09:37,520
security fix and Michael actually added

00:09:33,660 --> 00:09:39,390
a new I octal namespace i octal Cisco

00:09:37,520 --> 00:09:42,870
infrastructure to query the hierarchy

00:09:39,390 --> 00:09:45,360
and properties of namespaces so for

00:09:42,870 --> 00:09:47,070
example you can ask the question what is

00:09:45,360 --> 00:09:49,080
the owning what is the UAD

00:09:47,070 --> 00:09:50,850
of the creator of the specific user

00:09:49,080 --> 00:09:53,880
namespace which is something that is

00:09:50,850 --> 00:09:55,290
pretty helpful because you can answer

00:09:53,880 --> 00:09:56,910
the question for yourself do I have

00:09:55,290 --> 00:10:00,900
privilege over this specific user

00:09:56,910 --> 00:10:03,000
namespace also you can get the parent of

00:10:00,900 --> 00:10:04,920
any hierarchical namespace that only

00:10:03,000 --> 00:10:07,110
affects pit namespaces and user name

00:10:04,920 --> 00:10:09,420
spaces so you give it an F deve to a pit

00:10:07,110 --> 00:10:11,100
namespace and then if you have the right

00:10:09,420 --> 00:10:13,350
permissions it will give you back your

00:10:11,100 --> 00:10:16,380
and an FD to the answer to the pit

00:10:13,350 --> 00:10:18,780
namespace or a user name space and also

00:10:16,380 --> 00:10:20,820
NS get user an S which is related to

00:10:18,780 --> 00:10:22,590
what I said before all namespaces have

00:10:20,820 --> 00:10:24,960
an owning user namespace so if you give

00:10:22,590 --> 00:10:27,620
it an FD to a non-user namespace it will

00:10:24,960 --> 00:10:31,770
give you back the owning user namespace

00:10:27,620 --> 00:10:33,450
pretty helpful and further work and this

00:10:31,770 --> 00:10:36,000
is an ongoing topic I tell you that

00:10:33,450 --> 00:10:37,860
right away the infrastructure to enable

00:10:36,000 --> 00:10:39,420
and privileged mounts so months from

00:10:37,860 --> 00:10:42,180
user name spaces there was more work

00:10:39,420 --> 00:10:46,500
than there yeah we will see this popping

00:10:42,180 --> 00:10:48,300
up 412 saw an interesting feature it

00:10:46,500 --> 00:10:50,310
exposed the patinas for children and

00:10:48,300 --> 00:10:52,890
proc peed and acid which always have

00:10:50,310 --> 00:10:53,880
been in place for the kernel so how can

00:10:52,890 --> 00:10:58,230
I make this relatable

00:10:53,880 --> 00:11:00,270
so think about the question what pit

00:10:58,230 --> 00:11:01,410
namespace are children that I'm going to

00:11:00,270 --> 00:11:03,329
fork off

00:11:01,410 --> 00:11:05,250
to end up in the trivial answer to this

00:11:03,329 --> 00:11:06,660
question seems to be well in the same

00:11:05,250 --> 00:11:09,180
pit namespace that I am in

00:11:06,660 --> 00:11:11,160
well not how said NS works so if you set

00:11:09,180 --> 00:11:13,410
an S to another pit namespace you will

00:11:11,160 --> 00:11:15,629
not expires by yourself change the pit

00:11:13,410 --> 00:11:18,209
namespace but if you fork of a new

00:11:15,629 --> 00:11:20,850
process then like these ones will become

00:11:18,209 --> 00:11:23,579
a member of the new pit namespace that

00:11:20,850 --> 00:11:25,230
you actually set an S to and so paid an

00:11:23,579 --> 00:11:27,870
S for children and Pitta in that pit in

00:11:25,230 --> 00:11:29,670
s a value under these proc files will

00:11:27,870 --> 00:11:31,829
actually be different in that case and

00:11:29,670 --> 00:11:33,810
tools like creosote checkpoint restore

00:11:31,829 --> 00:11:35,699
and user space needs to sometimes needs

00:11:33,810 --> 00:11:37,319
to know this question when and the

00:11:35,699 --> 00:11:41,819
answer to the question when restoring a

00:11:37,319 --> 00:11:46,800
task yeah we also there was also support

00:11:41,819 --> 00:11:48,060
added for fuse and pit namespaces so

00:11:46,800 --> 00:11:50,670
there was probably now proper

00:11:48,060 --> 00:11:53,189
translation if fuse is run in a pit

00:11:50,670 --> 00:11:54,629
namespace so fuse will take care that

00:11:53,189 --> 00:11:56,519
the pit is actually translated to a

00:11:54,629 --> 00:11:59,759
valid pit with in the pit namespace and

00:11:56,519 --> 00:12:02,189
so on it wasn't the case before and I

00:11:59,759 --> 00:12:04,819
guess it's not super important but I was

00:12:02,189 --> 00:12:07,470
also some work done to enable namespace

00:12:04,819 --> 00:12:09,209
information in per file I've never used

00:12:07,470 --> 00:12:11,069
it before actually when I looked at it I

00:12:09,209 --> 00:12:13,759
didn't even know that we just landed but

00:12:11,069 --> 00:12:17,329
good to know

00:12:13,759 --> 00:12:21,060
4.13 saw eric doing some work around

00:12:17,329 --> 00:12:22,649
well bad human performance it's actually

00:12:21,060 --> 00:12:24,600
a back fix so probably I shouldn't have

00:12:22,649 --> 00:12:26,399
put it in but it actually increased

00:12:24,600 --> 00:12:28,259
human performance dramatically so if you

00:12:26,399 --> 00:12:30,569
had overlapping mount propagation trees

00:12:28,259 --> 00:12:31,800
the old you mount code could take up to

00:12:30,569 --> 00:12:34,649
60 seconds I think

00:12:31,800 --> 00:12:36,569
and Reagan discovered this and Eric

00:12:34,649 --> 00:12:39,019
refactor the refactor the whole you

00:12:36,569 --> 00:12:41,579
mount logic such that it tastes down to

00:12:39,019 --> 00:12:43,949
0.06 seconds so that's actually pretty

00:12:41,579 --> 00:12:48,779
good and the code is pretty interesting

00:12:43,949 --> 00:12:50,939
too and Teagan in 4.13 added an Anna

00:12:48,779 --> 00:12:53,250
Stella gate option to allow C group

00:12:50,939 --> 00:12:56,279
delegation safe C group delegation for

00:12:53,250 --> 00:12:59,519
the root user it was always kind of safe

00:12:56,279 --> 00:13:01,050
for unprivileged users at least if the

00:12:59,519 --> 00:13:02,939
system administrator set it up this way

00:13:01,050 --> 00:13:05,910
but it wasn't safe for various reasons

00:13:02,939 --> 00:13:07,439
for the root user and right now if you

00:13:05,910 --> 00:13:09,360
mount the C group tree with the Anna's

00:13:07,439 --> 00:13:12,029
delegate option then C group namespaces

00:13:09,360 --> 00:13:13,630
are considered delegation boundaries so

00:13:12,029 --> 00:13:15,610
you cannot escape limits

00:13:13,630 --> 00:13:16,990
pretty useful for I guess privileged

00:13:15,610 --> 00:13:22,230
containers which you shouldn't run you

00:13:16,990 --> 00:13:24,250
should always use your namespaces 4.14

00:13:22,230 --> 00:13:26,200
introduced namespace v capable

00:13:24,250 --> 00:13:29,950
capabilities actually done by search

00:13:26,200 --> 00:13:32,110
helen could do it and actually was a

00:13:29,950 --> 00:13:33,280
that was quite a bit of work something

00:13:32,110 --> 00:13:35,170
that we wanted for a long time

00:13:33,280 --> 00:13:37,060
unprivileged file system capabilities or

00:13:35,170 --> 00:13:40,360
in general file system capabilities

00:13:37,060 --> 00:13:44,830
weren't safe before so let me come up

00:13:40,360 --> 00:13:47,320
with an attack so imagine you you

00:13:44,830 --> 00:13:50,050
allowed to create a user name space as a

00:13:47,320 --> 00:13:53,140
number of the user so you create a new

00:13:50,050 --> 00:13:55,660
user name space you set a file system

00:13:53,140 --> 00:13:58,180
capital e whatever caps this admin on an

00:13:55,660 --> 00:14:00,490
arbitrary binary that you just wrote you

00:13:58,180 --> 00:14:05,410
in another terminal execute that binary

00:14:00,490 --> 00:14:09,300
on the host and you screwed so it wasn't

00:14:05,410 --> 00:14:12,520
safe for a long time it's now since 4.14

00:14:09,300 --> 00:14:15,280
it is per per user name space so

00:14:12,520 --> 00:14:20,310
basically the kernel records a root to

00:14:15,280 --> 00:14:23,050
ID which it considers to be the UID Det

00:14:20,310 --> 00:14:26,380
namespace or UID root inside of a user

00:14:23,050 --> 00:14:28,300
name space needs to be mapped to and if

00:14:26,380 --> 00:14:31,150
it detects a mapping for that specific

00:14:28,300 --> 00:14:35,190
root you ready then it will grant you

00:14:31,150 --> 00:14:40,030
the rights to execute that file with

00:14:35,190 --> 00:14:41,950
elevated privileges yeah so for example

00:14:40,030 --> 00:14:45,760
if you write a file system capability

00:14:41,950 --> 00:14:47,380
with rude ID 100000 and you try to

00:14:45,760 --> 00:14:49,240
execute it on the host account all will

00:14:47,380 --> 00:14:51,550
look at this and we'll see we'll see

00:14:49,240 --> 00:14:54,460
it's not UID 0 so I'm not granting you

00:14:51,550 --> 00:14:57,730
access to execute that file with

00:14:54,460 --> 00:14:59,680
elevated privileges if I go into a new

00:14:57,730 --> 00:15:02,350
user namespace and establish a mapping

00:14:59,680 --> 00:15:04,210
such that Ruda you 100000 corresponds is

00:15:02,350 --> 00:15:06,070
mapped to UID 0 with inside of the user

00:15:04,210 --> 00:15:07,360
namespace and I execute that file the

00:15:06,070 --> 00:15:09,250
kernel will see oh yeah there is a

00:15:07,360 --> 00:15:10,930
mapping for this it's fine you can

00:15:09,250 --> 00:15:13,510
execute it with elevated privileges

00:15:10,930 --> 00:15:14,980
that's sort of the gist of how this

00:15:13,510 --> 00:15:17,860
works

00:15:14,980 --> 00:15:20,500
4.15 actually worked on by me in this

00:15:17,860 --> 00:15:24,150
case we bumped the limits of allowed

00:15:20,500 --> 00:15:27,540
user namespace methods from 5 to 340

00:15:24,150 --> 00:15:28,800
the 340 limit is not arbitrary it's

00:15:27,540 --> 00:15:31,350
actually enforced by the kernel and the

00:15:28,800 --> 00:15:33,540
kernel the structure that is used so it

00:15:31,350 --> 00:15:36,150
needs to fit into a cache line 340 it's

00:15:33,540 --> 00:15:37,650
basically the layout of the structure

00:15:36,150 --> 00:15:39,240
such that it doesn't exceed the cache

00:15:37,650 --> 00:15:43,589
line if you go any higher

00:15:39,240 --> 00:15:47,300
it won't work anymore so this is useful

00:15:43,589 --> 00:15:50,760
mainly for the case when you for example

00:15:47,300 --> 00:15:53,760
usually when you run a container that

00:15:50,760 --> 00:15:55,620
has a user that has ID mapping specified

00:15:53,760 --> 00:15:57,930
you sometimes want to be able to write

00:15:55,620 --> 00:16:00,720
files to your home directory with your

00:15:57,930 --> 00:16:02,970
UID and GID s but all other you IDs and

00:16:00,720 --> 00:16:04,680
GRE should be isolated and mapped to so

00:16:02,970 --> 00:16:07,200
the host you ad should be isolated from

00:16:04,680 --> 00:16:09,000
the container you IDs and deities but

00:16:07,200 --> 00:16:10,800
you punch a hole into the map that you

00:16:09,000 --> 00:16:13,250
established by saying for example user

00:16:10,800 --> 00:16:16,230
ID 1000 and a host is mapped to user ID

00:16:13,250 --> 00:16:18,960
1000 inside of the user name space but

00:16:16,230 --> 00:16:21,570
you can only do this for like three or

00:16:18,960 --> 00:16:24,360
four you IDs and then you're running out

00:16:21,570 --> 00:16:25,770
of mappings that's just the limit it was

00:16:24,360 --> 00:16:27,870
for a long time now you can do it for

00:16:25,770 --> 00:16:31,680
340 mappings it's actually interesting

00:16:27,870 --> 00:16:35,310
the overhead is an editable actually so

00:16:31,680 --> 00:16:38,220
for five mappings you look at 145

00:16:35,310 --> 00:16:43,010
nanoseconds that time means that time

00:16:38,220 --> 00:16:46,650
for a file for 340 mappings you're up

00:16:43,010 --> 00:16:52,140
264 or something so the performance

00:16:46,650 --> 00:16:54,600
impact is also quite okay I guess 4.16

00:16:52,140 --> 00:16:56,670
saw some new infrastructure implemented

00:16:54,600 --> 00:16:59,520
to query network named faces of peer

00:16:56,670 --> 00:17:01,890
network namespaces by passing along a

00:16:59,520 --> 00:17:04,800
network namespace identifying property

00:17:01,890 --> 00:17:06,300
so RTM new link Dell Inc and settling

00:17:04,800 --> 00:17:08,309
basically allow you to pass along a

00:17:06,300 --> 00:17:10,020
property for a network namespace and you

00:17:08,309 --> 00:17:11,730
can operate on that network namespace

00:17:10,020 --> 00:17:14,699
without having to set an s into this

00:17:11,730 --> 00:17:19,309
network namespace which is a pretty

00:17:14,699 --> 00:17:22,140
performance relevant actually and in

00:17:19,309 --> 00:17:24,660
4.17 we finally got to make unprivileged

00:17:22,140 --> 00:17:26,670
fuse mounts worked with I mastered this

00:17:24,660 --> 00:17:30,540
was work that has been done by Eric and

00:17:26,670 --> 00:17:32,630
also in conjunction with me me right so

00:17:30,540 --> 00:17:35,760
there were some questions how to I guess

00:17:32,630 --> 00:17:36,400
validate I'm unprivileged fuse mounts

00:17:35,760 --> 00:17:38,980
with I'm are

00:17:36,400 --> 00:17:41,590
and it fails by default right now but

00:17:38,980 --> 00:17:44,410
you're probably way more better equipped

00:17:41,590 --> 00:17:45,580
to talk about this than I am so there

00:17:44,410 --> 00:17:47,260
was one of the final blockers to

00:17:45,580 --> 00:17:49,150
actually make unprivileged views mounts

00:17:47,260 --> 00:17:52,960
from user names or non initial user name

00:17:49,150 --> 00:17:55,570
spaces work we also fixed a

00:17:52,960 --> 00:17:58,750
long-standing buck whereby bind mounts

00:17:55,570 --> 00:18:01,000
of deaf pts PT mx2 def PT MX did not

00:17:58,750 --> 00:18:02,890
work so you could have siblings you

00:18:01,000 --> 00:18:04,840
could have a separate device node but if

00:18:02,890 --> 00:18:07,059
you try to do a bind mount o'connell

00:18:04,840 --> 00:18:10,090
which is not recognized that it's

00:18:07,059 --> 00:18:11,980
basically the same mount so we added

00:18:10,090 --> 00:18:14,290
logic to make this possible right now

00:18:11,980 --> 00:18:18,280
this is relevant for the case where you

00:18:14,290 --> 00:18:20,620
have an LS M like Obama that tries to

00:18:18,280 --> 00:18:22,900
for example restrict access to certain

00:18:20,620 --> 00:18:28,270
files by assembling so a bind mount is a

00:18:22,900 --> 00:18:30,309
way out out of this and also this is the

00:18:28,270 --> 00:18:33,100
device namespace thing I talked about

00:18:30,309 --> 00:18:36,010
you event injector works so we made it

00:18:33,100 --> 00:18:38,080
possible that you can inject you events

00:18:36,010 --> 00:18:40,030
into another network namespace so for

00:18:38,080 --> 00:18:43,960
example let's say you plug in a USB

00:18:40,030 --> 00:18:46,150
device inside of your computer and you

00:18:43,960 --> 00:18:48,490
say ok this is going to be safe to

00:18:46,150 --> 00:18:50,410
delegate to a container and then you

00:18:48,490 --> 00:18:52,960
inject it into a container which you can

00:18:50,410 --> 00:18:54,460
do using mount propagation and so on but

00:18:52,960 --> 00:18:56,530
for the container it actually doesn't

00:18:54,460 --> 00:18:58,690
appear as a proper device because it

00:18:56,530 --> 00:19:01,540
never gets you event because you events

00:18:58,690 --> 00:19:03,910
are restricted technically not but get

00:19:01,540 --> 00:19:06,220
to this in a second to the initial user

00:19:03,910 --> 00:19:08,170
namespace so what we made possible is

00:19:06,220 --> 00:19:09,760
you get to you event on the host you can

00:19:08,170 --> 00:19:12,190
parse to you event you strip of the

00:19:09,760 --> 00:19:13,540
sequence number you injected into the

00:19:12,190 --> 00:19:15,040
kernel the kernel will append a new

00:19:13,540 --> 00:19:16,809
sequence number and then if you have the

00:19:15,040 --> 00:19:19,300
right permissions which is cabinet admin

00:19:16,809 --> 00:19:21,400
in the user owning user name space of

00:19:19,300 --> 00:19:23,350
the network namespace will relay it into

00:19:21,400 --> 00:19:25,780
the other network namespace at which

00:19:23,350 --> 00:19:27,820
point you FD ins running inside of a

00:19:25,780 --> 00:19:29,860
container for example will get notified

00:19:27,820 --> 00:19:32,260
oh there is a new device that just

00:19:29,860 --> 00:19:34,350
showed up so it's as I we like to call

00:19:32,260 --> 00:19:40,050
its device namespaces from user space

00:19:34,350 --> 00:19:42,580
and 4.18 finally saw unprivileged

00:19:40,050 --> 00:19:46,150
finalizing the infrastructure to do

00:19:42,580 --> 00:19:47,830
unprivileged mounts or as I like to call

00:19:46,150 --> 00:19:50,110
it getting away with regressing user

00:19:47,830 --> 00:19:52,270
space because this is where

00:19:50,110 --> 00:19:53,920
we changed I said before kept make note

00:19:52,270 --> 00:19:56,170
was always checked against the initial

00:19:53,920 --> 00:19:59,110
user namespace so if you try to do a cat

00:19:56,170 --> 00:20:00,670
make not and make not the kernel would

00:19:59,110 --> 00:20:02,559
look do you have kept making out in the

00:20:00,670 --> 00:20:04,120
initial user namespace you don't then no

00:20:02,559 --> 00:20:08,410
it's not possible

00:20:04,120 --> 00:20:11,140
but right now it's if you mounted a file

00:20:08,410 --> 00:20:12,850
system that you're on so if you do it

00:20:11,140 --> 00:20:15,179
data mount tempeh first time professor

00:20:12,850 --> 00:20:17,860
slash mount inside of a user name space

00:20:15,179 --> 00:20:19,870
the kernel will record what user

00:20:17,860 --> 00:20:22,240
namespace this has been has been the

00:20:19,870 --> 00:20:24,040
mount or of this file system and it has

00:20:22,240 --> 00:20:25,660
been for example an unprivileged user

00:20:24,040 --> 00:20:28,630
namespace tempeh fest mounts are fine

00:20:25,660 --> 00:20:31,450
and then you do a make not the kernel

00:20:28,630 --> 00:20:33,910
will now check do you have kept make

00:20:31,450 --> 00:20:35,590
node within that user namespace the

00:20:33,910 --> 00:20:38,770
answer will be yes you create a device

00:20:35,590 --> 00:20:41,679
note but the way unprivileged mounts

00:20:38,770 --> 00:20:43,210
work is that at the same time when you

00:20:41,679 --> 00:20:45,220
mount the filesystem as an answer of

00:20:43,210 --> 00:20:48,160
this user inside of a new user namespace

00:20:45,220 --> 00:20:50,799
sorry inside of a user name space it

00:20:48,160 --> 00:20:53,110
also sets the SBI node a flag on the

00:20:50,799 --> 00:20:55,360
super block which means any device nodes

00:20:53,110 --> 00:20:56,980
that you had prior to mounting this file

00:20:55,360 --> 00:20:59,049
system or that you create after mounting

00:20:56,980 --> 00:21:02,500
this file system you will get an e perm

00:20:59,049 --> 00:21:04,059
when you do an open which given how

00:21:02,500 --> 00:21:06,070
container runtimes work they always

00:21:04,059 --> 00:21:08,110
assumed if a make not is not possible

00:21:06,070 --> 00:21:10,809
then you should do a bind mount but if

00:21:08,110 --> 00:21:13,390
the make not succeeds then it's a usable

00:21:10,809 --> 00:21:16,240
device node which is not true anymore so

00:21:13,390 --> 00:21:19,000
actually system the system D services in

00:21:16,240 --> 00:21:20,559
user namespaces and also a couple of

00:21:19,000 --> 00:21:23,590
container on times have been redressed

00:21:20,559 --> 00:21:25,240
by this but I talked to Eric about this

00:21:23,590 --> 00:21:30,070
he said spines probably not a lot of

00:21:25,240 --> 00:21:32,320
users so ok it seems ok nobody

00:21:30,070 --> 00:21:33,880
complained so far a lot and it's

00:21:32,320 --> 00:21:37,330
actually something that needs to be done

00:21:33,880 --> 00:21:39,040
at some point anyways the fun part is

00:21:37,330 --> 00:21:41,490
just that I talked to Leonard and

00:21:39,040 --> 00:21:43,410
Leonard refused to fix it in system D

00:21:41,490 --> 00:21:46,600
because he said it's a kernel regression

00:21:43,410 --> 00:21:47,890
so you can choose you can choose what

00:21:46,600 --> 00:21:51,940
the pre where the problem lies I don't

00:21:47,890 --> 00:21:53,890
know also it enabled unprivileged fuse

00:21:51,940 --> 00:21:56,350
mountains finally this has been work a

00:21:53,890 --> 00:21:58,510
lot of work done by Eric a lot of work

00:21:56,350 --> 00:22:00,640
also done by myself and a bunch of other

00:21:58,510 --> 00:22:02,630
people that try to upstream it because

00:22:00,640 --> 00:22:06,540
Seth didn't have the time

00:22:02,630 --> 00:22:08,550
right now you can mount fuse from non

00:22:06,540 --> 00:22:10,850
initial user namespaces without any set

00:22:08,550 --> 00:22:13,350
you ad trickery or something so that's

00:22:10,850 --> 00:22:14,850
one of the few file systems I'm not sure

00:22:13,350 --> 00:22:17,100
that it's going to be followed by a lot

00:22:14,850 --> 00:22:19,260
of other file systems because VFS

00:22:17,100 --> 00:22:21,690
security is different from actual file

00:22:19,260 --> 00:22:23,880
system security so meaning the VFS can

00:22:21,690 --> 00:22:25,860
do all of the permission checks at once

00:22:23,880 --> 00:22:27,660
unless the file system maintainer and

00:22:25,860 --> 00:22:29,130
please yell at me if I'm wrong gives you

00:22:27,660 --> 00:22:32,060
a guarantee that we are safe from

00:22:29,130 --> 00:22:35,220
attacks in the face of a malicious image

00:22:32,060 --> 00:22:37,320
file system image this is probably not

00:22:35,220 --> 00:22:39,540
going to happen and I'm pretty sure that

00:22:37,320 --> 00:22:43,340
most file system maintainer x' would not

00:22:39,540 --> 00:22:47,070
feel confident to enable unprivileged

00:22:43,340 --> 00:22:48,720
mounts and we did some work around user

00:22:47,070 --> 00:22:53,220
you event namespace things because we

00:22:48,720 --> 00:22:55,440
figured out that this was broken like

00:22:53,220 --> 00:22:57,750
massively broken so let's say you

00:22:55,440 --> 00:22:59,490
plugged in a device basically what

00:22:57,750 --> 00:23:01,590
happened is that the you event got

00:22:59,490 --> 00:23:04,950
yelled into each network namespace on

00:23:01,590 --> 00:23:06,330
the whole system but if the network

00:23:04,950 --> 00:23:07,920
namespace was owned by different

00:23:06,330 --> 00:23:10,020
usernames based in the initial user

00:23:07,920 --> 00:23:12,210
namespace the you IDs and G IDs that

00:23:10,020 --> 00:23:14,580
this event came with were not fixed up

00:23:12,210 --> 00:23:17,100
meaning you'd if you were running you

00:23:14,580 --> 00:23:19,260
def inside of a username space then it

00:23:17,100 --> 00:23:21,510
will just discard the events but it was

00:23:19,260 --> 00:23:24,210
we had slew of totally useless events

00:23:21,510 --> 00:23:26,760
which is also kind of it's funny insofar

00:23:24,210 --> 00:23:28,830
as the list of you event sockets for a

00:23:26,760 --> 00:23:30,810
long time was global before we did this

00:23:28,830 --> 00:23:32,820
work meaning if you took a lock it

00:23:30,810 --> 00:23:34,710
basically walked a list of all network

00:23:32,820 --> 00:23:36,600
namespaces in you events sockets held

00:23:34,710 --> 00:23:38,640
this lock for as long as a you event was

00:23:36,600 --> 00:23:40,560
sent into each network namespace then

00:23:38,640 --> 00:23:42,690
for each network namespace walked a list

00:23:40,560 --> 00:23:45,030
of multicast sockets that were listening

00:23:42,690 --> 00:23:47,670
to the network namespace and then and so

00:23:45,030 --> 00:23:49,410
on so there was actually quite pointless

00:23:47,670 --> 00:23:53,880
work the kernel did for a long time so

00:23:49,410 --> 00:23:56,250
that's gone now current patch sets that

00:23:53,880 --> 00:23:58,590
we see floating around right now a bunch

00:23:56,250 --> 00:24:00,920
of interesting patch set so there is the

00:23:58,590 --> 00:24:03,510
idea to introduce a new time namespace

00:24:00,920 --> 00:24:06,090
not a new one to introduce a time

00:24:03,510 --> 00:24:08,580
namespace which is obviously a big thing

00:24:06,090 --> 00:24:09,780
for for you for various reasons andrew

00:24:08,580 --> 00:24:12,060
bacon has done a lot of this work

00:24:09,780 --> 00:24:14,300
together with someone whose name i

00:24:12,060 --> 00:24:19,820
unfortunately right now don't remember

00:24:14,300 --> 00:24:22,520
and it's I think maybe it lands or some

00:24:19,820 --> 00:24:25,160
it's obviously going to be very I think

00:24:22,520 --> 00:24:27,920
a long discussion given that time is

00:24:25,160 --> 00:24:30,100
something that shows up as relevant very

00:24:27,920 --> 00:24:34,490
early on in the boot process or changing

00:24:30,100 --> 00:24:36,290
changing how time works is a big thing

00:24:34,490 --> 00:24:38,450
thomas bikes now also commented on a

00:24:36,290 --> 00:24:39,490
bunch on this patch set so we'll see

00:24:38,450 --> 00:24:42,170
where this leads

00:24:39,490 --> 00:24:44,770
alexa worked on a patch set or revived a

00:24:42,170 --> 00:24:49,340
pestered by i guess David wrist I'll and

00:24:44,770 --> 00:24:51,860
viral to restrict path resolutions so

00:24:49,340 --> 00:24:56,030
it's similar to I guess the unveil idea

00:24:51,860 --> 00:24:57,650
a little bit at least of the bsds we

00:24:56,030 --> 00:24:59,690
have a bunch of add flex at beneath at

00:24:57,650 --> 00:25:01,790
no prop links at no sim links at this

00:24:59,690 --> 00:25:05,300
route X staff that basically lets you

00:25:01,790 --> 00:25:07,760
specify how you how you want to resolve

00:25:05,300 --> 00:25:09,800
a path which is a big security feature

00:25:07,760 --> 00:25:12,290
for example also for container runtimes

00:25:09,800 --> 00:25:15,830
but it has uses beyond that we will see

00:25:12,290 --> 00:25:17,450
where this lands I think that Alexa

00:25:15,830 --> 00:25:19,190
right now has changed the idea to why

00:25:17,450 --> 00:25:21,380
not make it a separate syscall resolve

00:25:19,190 --> 00:25:23,240
that I don't think that's going to fly

00:25:21,380 --> 00:25:24,800
but we will see some version of this

00:25:23,240 --> 00:25:27,620
patch that will likely land because a

00:25:24,800 --> 00:25:28,940
lot of people actually want this the

00:25:27,620 --> 00:25:31,520
links is where the discussion is taking

00:25:28,940 --> 00:25:36,500
place always so you can feel free to

00:25:31,520 --> 00:25:38,450
comment and this is going to land in for

00:25:36,500 --> 00:25:40,760
nineteen ninety four twenty actually

00:25:38,450 --> 00:25:42,200
query Pia network namespaces again by

00:25:40,760 --> 00:25:43,880
sending along and network namespace

00:25:42,200 --> 00:25:44,450
identifying property if you put this

00:25:43,880 --> 00:25:48,070
together

00:25:44,450 --> 00:25:50,390
RTM get other and RTM get linked and

00:25:48,070 --> 00:25:53,210
retrieve network retrieve information

00:25:50,390 --> 00:25:55,790
for network devices and their addresses

00:25:53,210 --> 00:25:57,800
for like let's say a thousand Network

00:25:55,790 --> 00:25:59,780
namespaces it actually cuts the time in

00:25:57,800 --> 00:26:02,990
half that he would did you would need if

00:25:59,780 --> 00:26:04,640
you would do it with seven s at ed liked

00:26:02,990 --> 00:26:06,380
retrieved he addresses and then set an

00:26:04,640 --> 00:26:08,690
aspect to the host namespace so that's

00:26:06,380 --> 00:26:13,100
pretty good and as obviously David's

00:26:08,690 --> 00:26:15,110
around here right ah yeah David's done

00:26:13,100 --> 00:26:17,780
an incredible amount of work around a

00:26:15,110 --> 00:26:19,700
new amount API that's pretty cool and

00:26:17,780 --> 00:26:21,590
hopefully it's going to land soon there

00:26:19,700 --> 00:26:23,330
are a couple of discussions still to be

00:26:21,590 --> 00:26:25,100
had it's obviously it's a big change and

00:26:23,330 --> 00:26:26,330
a lot of people have a lot of opinions

00:26:25,100 --> 00:26:28,679
on this

00:26:26,330 --> 00:26:30,299
but it allows you to really not do nice

00:26:28,679 --> 00:26:32,399
things that basically one of the ideas

00:26:30,299 --> 00:26:34,739
is for example you split the the basic

00:26:32,399 --> 00:26:36,419
concept is get me an F D for a new mount

00:26:34,739 --> 00:26:39,090
point configure the mount point and then

00:26:36,419 --> 00:26:40,559
apply it which is really which is really

00:26:39,090 --> 00:26:42,059
nice you also can send around file

00:26:40,559 --> 00:26:44,279
descriptors for mount points and so on

00:26:42,059 --> 00:26:46,139
which also means you can probably make

00:26:44,279 --> 00:26:49,200
unprivileged mounting safe if you wanted

00:26:46,139 --> 00:26:52,349
to and so on that's that's really

00:26:49,200 --> 00:26:54,239
promising actually and future patch

00:26:52,349 --> 00:26:56,090
that's mostly it's stuff that I've been

00:26:54,239 --> 00:26:58,320
thinking about or working on just

00:26:56,090 --> 00:26:59,789
because I don't know what a lot of

00:26:58,320 --> 00:27:01,979
people are working on right now I think

00:26:59,789 --> 00:27:04,799
Eric is married in refactoring signal

00:27:01,979 --> 00:27:06,239
code at this point so there's not a lot

00:27:04,799 --> 00:27:08,159
of name space were coming from him at

00:27:06,239 --> 00:27:09,690
the moment one thing that I've been

00:27:08,159 --> 00:27:11,700
lacking for a long time and I've been

00:27:09,690 --> 00:27:13,649
talking to David about this is recursive

00:27:11,700 --> 00:27:15,479
read only by mounts for the old and new

00:27:13,649 --> 00:27:17,999
mount API because you kind of do this

00:27:15,479 --> 00:27:20,999
right now so right now let's say in user

00:27:17,999 --> 00:27:23,190
space you want to bind mount your whole

00:27:20,999 --> 00:27:25,259
Sisyphus mountry into it at a different

00:27:23,190 --> 00:27:29,399
location recursively and make it

00:27:25,259 --> 00:27:34,409
read-only so you do mount remount our

00:27:29,399 --> 00:27:37,559
bind slash comma ROC sis to mount that

00:27:34,409 --> 00:27:39,509
won't do what you think it does it won't

00:27:37,559 --> 00:27:42,690
make the mount tree read-only actually

00:27:39,509 --> 00:27:45,779
the same is if you do remount our bind

00:27:42,690 --> 00:27:48,809
rro on a hole mount tree it also only

00:27:45,779 --> 00:27:51,320
will remount the top of top most mount

00:27:48,809 --> 00:27:55,159
read-only would be nice especially for

00:27:51,320 --> 00:27:58,499
system managers in it yeah in it

00:27:55,159 --> 00:28:01,200
processes like system D if you could say

00:27:58,499 --> 00:28:02,700
are buying this whole mount reread only

00:28:01,200 --> 00:28:05,099
to a different location make it

00:28:02,700 --> 00:28:06,960
atomically in one shot so that we're on

00:28:05,099 --> 00:28:07,679
the safe side and also the same for

00:28:06,960 --> 00:28:09,869
remand

00:28:07,679 --> 00:28:13,080
but it's obviously trigger tricky to

00:28:09,869 --> 00:28:16,409
kind of figure this out correctly I have

00:28:13,080 --> 00:28:18,479
a patch set for this which I have been

00:28:16,409 --> 00:28:20,789
sitting on because I want to make sure

00:28:18,479 --> 00:28:22,679
that it works because I fear if I send

00:28:20,789 --> 00:28:25,830
it out and L doesn't like it then this

00:28:22,679 --> 00:28:27,929
was my one shot so yeah and the new

00:28:25,830 --> 00:28:29,700
mount API hopefully we'll see like we'll

00:28:27,929 --> 00:28:31,889
apply I guess all my properties

00:28:29,700 --> 00:28:34,580
recursively right away but David is

00:28:31,889 --> 00:28:36,809
better equipped to talk about this

00:28:34,580 --> 00:28:38,940
I've been looking into making the you

00:28:36,809 --> 00:28:41,309
mount assist called reversible together

00:28:38,940 --> 00:28:44,520
with ramp I he's probably not here right

00:28:41,309 --> 00:28:46,230
now but he said the KVM forum by reusing

00:28:44,520 --> 00:28:49,050
a concept that Eric once introduced

00:28:46,230 --> 00:28:51,540
which is basically tack mounts so right

00:28:49,050 --> 00:28:52,950
now I think if I'm not mistaken you yell

00:28:51,540 --> 00:28:54,300
at me if I'm wrong if you do a mount

00:28:52,950 --> 00:28:55,830
operation you can given mount

00:28:54,300 --> 00:28:57,780
propagation you can get into a state

00:28:55,830 --> 00:28:59,309
where the you do a mount and you do a

00:28:57,780 --> 00:29:01,170
you Mountain you think you get back to

00:28:59,309 --> 00:29:04,170
the original state of the mount tree

00:29:01,170 --> 00:29:06,090
before that you mount before you did

00:29:04,170 --> 00:29:07,559
them the additional amount it's actually

00:29:06,090 --> 00:29:08,640
not the case you can do you mount but

00:29:07,559 --> 00:29:11,070
your Mount Airy looks totally different

00:29:08,640 --> 00:29:13,320
right now with tack pounds that's at

00:29:11,070 --> 00:29:15,000
least Rams idea is you can make it such

00:29:13,320 --> 00:29:18,390
that each human gets you back to the

00:29:15,000 --> 00:29:20,460
prior state of the mountry so we'll see

00:29:18,390 --> 00:29:23,160
if that actually works out still some

00:29:20,460 --> 00:29:24,300
discussion to be had around this and I

00:29:23,160 --> 00:29:26,600
have patched that to make mount

00:29:24,300 --> 00:29:28,860
propagation in the set of s is called

00:29:26,600 --> 00:29:30,600
possible such that you can do a set of s

00:29:28,860 --> 00:29:33,630
on a mount point and then you can check

00:29:30,600 --> 00:29:35,340
for MS private ms shared or ms slave in

00:29:33,630 --> 00:29:36,929
the Flex argument because you cannot do

00:29:35,340 --> 00:29:40,200
it right now you need to pass proc mount

00:29:36,929 --> 00:29:41,309
info which is kind of annoying that's

00:29:40,200 --> 00:29:42,870
the only way to get this type of

00:29:41,309 --> 00:29:46,770
information as far as I know right now

00:29:42,870 --> 00:29:48,840
and this is something I have put on the

00:29:46,770 --> 00:29:50,940
side and I'm not sure if we're still

00:29:48,840 --> 00:29:53,220
going to need it but basically introduce

00:29:50,940 --> 00:29:55,500
new to new I are close to the in

00:29:53,220 --> 00:29:57,929
namespace IO poles that we have right

00:29:55,500 --> 00:29:59,750
now one is NS in it which allows you to

00:29:57,929 --> 00:30:02,940
answer the question is this the initial

00:29:59,750 --> 00:30:05,040
SS the initial namespace which might

00:30:02,940 --> 00:30:06,540
only make sense for pit and user name

00:30:05,040 --> 00:30:07,679
spaces because I don't think there is a

00:30:06,540 --> 00:30:09,960
nice way to do this

00:30:07,679 --> 00:30:13,460
reliably right now especially when you

00:30:09,960 --> 00:30:16,020
don't have /proc mounted and also a

00:30:13,460 --> 00:30:18,150
Ana's access which would basically be

00:30:16,020 --> 00:30:20,280
given this file descriptor to this user

00:30:18,150 --> 00:30:22,230
namespace and given a file descriptor to

00:30:20,280 --> 00:30:24,630
this file or this device do I have

00:30:22,230 --> 00:30:29,040
privilege over this file or device

00:30:24,630 --> 00:30:30,690
inside of this namespace yeah I guess I

00:30:29,040 --> 00:30:34,320
have run over time I hope not too much

00:30:30,690 --> 00:30:37,290
but that's basically it for the

00:30:34,320 --> 00:30:43,040
namespace and capability subsystem so

00:30:37,290 --> 00:30:45,600
happy to take questions yes Michael

00:30:43,040 --> 00:30:47,370
alright just curious hi I'm Michael

00:30:45,600 --> 00:30:50,490
kiosk just curious what does these

00:30:47,370 --> 00:30:53,220
very nice isn't it the NS in it in us

00:30:50,490 --> 00:30:55,710
yeah yeah for example it's it's mostly

00:30:53,220 --> 00:30:57,390
useful for the user name space when I

00:30:55,710 --> 00:31:00,960
want to determine am I in the initial

00:30:57,390 --> 00:31:02,880
user name space because then I can infer

00:31:00,960 --> 00:31:06,420
basically what operations I can perform

00:31:02,880 --> 00:31:07,920
or can't perform like if I'm in a non

00:31:06,420 --> 00:31:09,900
initial username space I'll be

00:31:07,920 --> 00:31:11,520
restricted with a lot of about a lot of

00:31:09,900 --> 00:31:13,710
things if I know I'm in the initial user

00:31:11,520 --> 00:31:14,940
name space I know that I can basically

00:31:13,710 --> 00:31:30,480
do everything I want

00:31:14,940 --> 00:31:32,309
oh no I know I'm scary David Howells two

00:31:30,480 --> 00:31:34,980
comments first on you're doing reader

00:31:32,309 --> 00:31:37,380
recursive read-only bind mounts if the

00:31:34,980 --> 00:31:39,809
open tree system call comes in and we

00:31:37,380 --> 00:31:42,690
add Mount cetera which will have a

00:31:39,809 --> 00:31:45,600
recursive flag you can just do open tree

00:31:42,690 --> 00:31:47,880
set had a recursive so you just change

00:31:45,600 --> 00:31:51,300
the read-only flag and unmount it which

00:31:47,880 --> 00:31:52,620
gets you the read only by mounts yeah so

00:31:51,300 --> 00:31:54,870
you're saying this will be in a new

00:31:52,620 --> 00:31:57,210
mount API once we've added the Mount

00:31:54,870 --> 00:31:59,730
cetera Cisco which is currently lacking

00:31:57,210 --> 00:32:02,640
yeah it's something we need to add but

00:31:59,730 --> 00:32:07,050
the the two bits on the other side exist

00:32:02,640 --> 00:32:09,120
yeah so you just clone that okay

00:32:07,050 --> 00:32:11,940
currently with the in Dubai miles by

00:32:09,120 --> 00:32:13,950
doing open tree clone yeah which close

00:32:11,940 --> 00:32:15,510
that and then you move the new mount

00:32:13,950 --> 00:32:20,130
somewhere else yeah but you'll be able

00:32:15,510 --> 00:32:22,530
to do a step in the middle which changes

00:32:20,130 --> 00:32:25,140
just to read-only flag yeah on all

00:32:22,530 --> 00:32:26,700
things currently with the bang thing at

00:32:25,140 --> 00:32:29,220
the moment you have to set all the

00:32:26,700 --> 00:32:32,820
flanks on everything because you love a

00:32:29,220 --> 00:32:35,730
mask yeah so that you won't actually

00:32:32,820 --> 00:32:37,559
need to nervous wreck read-only mounds

00:32:35,730 --> 00:32:39,750
like yeah because they'll be another way

00:32:37,559 --> 00:32:41,580
to do it how would you say I won't need

00:32:39,750 --> 00:32:44,429
that you won't need that yeah in the new

00:32:41,580 --> 00:32:46,200
mount API new melt API exactly yeah

00:32:44,429 --> 00:32:48,270
that's the hopefully we don't like this

00:32:46,200 --> 00:32:49,500
is this basically sorry I should be I

00:32:48,270 --> 00:32:51,330
should have been clear about this this

00:32:49,500 --> 00:32:54,240
is a clutch like I didn't talk about

00:32:51,330 --> 00:32:56,760
this so ms/ms rec read-only why the hell

00:32:54,240 --> 00:33:00,100
do we go with MS rec read-only why not

00:32:56,760 --> 00:33:02,230
MS read-only MS rec well

00:33:00,100 --> 00:33:04,360
not regressing userspace so probably

00:33:02,230 --> 00:33:06,670
anyone right my argument in the initial

00:33:04,360 --> 00:33:12,220
discussion was anyone in userspace who

00:33:06,670 --> 00:33:14,170
specifies Emma's rec /ms read only wants

00:33:12,220 --> 00:33:15,790
it to apply recursively and wants this

00:33:14,170 --> 00:33:17,170
to be read only and they're not getting

00:33:15,790 --> 00:33:20,140
what they want right now

00:33:17,170 --> 00:33:22,210
so failing right now would probably make

00:33:20,140 --> 00:33:23,860
the world a whole a lot safer place but

00:33:22,210 --> 00:33:26,110
it also break a lot of workload so the

00:33:23,860 --> 00:33:29,290
idea was okay we cannot do this we can

00:33:26,110 --> 00:33:31,090
maybe print a warning maybe but going

00:33:29,290 --> 00:33:33,220
forward the only way to do this is by

00:33:31,090 --> 00:33:35,470
introducing a new flag ms rec read-only

00:33:33,220 --> 00:33:38,170
which has its own problems which is why

00:33:35,470 --> 00:33:40,600
I'm sitting on this for so long since we

00:33:38,170 --> 00:33:43,210
have how many mount Lex we have 31 bits

00:33:40,600 --> 00:33:46,630
but all of them have been used even

00:33:43,210 --> 00:33:50,190
though like I guess five or some five

00:33:46,630 --> 00:33:52,930
flex or so I actually my internal super

00:33:50,190 --> 00:33:55,240
bugs brother actually listed in the UK

00:33:52,930 --> 00:33:57,670
yeah which yeah now not only new mount

00:33:55,240 --> 00:33:59,620
API I saw that which yeah but in the old

00:33:57,670 --> 00:34:02,140
mount API you for example have MS no

00:33:59,620 --> 00:34:04,230
user and MS I don't know suck mount or

00:34:02,140 --> 00:34:06,820
something exposed to user space which

00:34:04,230 --> 00:34:09,460
for MS no user this is the flag I'm

00:34:06,820 --> 00:34:13,270
reusing because you get iron ball anyway

00:34:09,460 --> 00:34:15,280
if you pass it right now yeah but with

00:34:13,270 --> 00:34:18,700
the new map when we eventually add Mount

00:34:15,280 --> 00:34:22,300
cetera you'll give it to Matt or as to

00:34:18,700 --> 00:34:24,010
two parameters one of which is the set

00:34:22,300 --> 00:34:26,080
of flags you want to set all clear and

00:34:24,010 --> 00:34:28,810
the mask to say which of those flags to

00:34:26,080 --> 00:34:32,080
apply exactly and do bare things say do

00:34:28,810 --> 00:34:34,420
this recursively yeah the other

00:34:32,080 --> 00:34:37,150
coincidence to make is you you had a

00:34:34,420 --> 00:34:39,220
thing to get me the namespace of that

00:34:37,150 --> 00:34:43,330
socket yeah we also need get me the

00:34:39,220 --> 00:34:45,250
namespace of that file so you say so you

00:34:43,330 --> 00:34:46,990
can ask what the namespace of a

00:34:45,250 --> 00:34:49,120
particular network file that's on the

00:34:46,990 --> 00:34:51,460
network file system is so you can do it

00:34:49,120 --> 00:34:53,920
some operation in that network namespace

00:34:51,460 --> 00:34:56,860
yeah that's something we will need to

00:34:53,920 --> 00:35:00,120
add at some point yeah it's basically in

00:34:56,860 --> 00:35:03,850
generic I Apple in in essence you guess

00:35:00,120 --> 00:35:05,470
yes you might not be now octal because

00:35:03,850 --> 00:35:08,760
you have to be able to do it unlike a

00:35:05,470 --> 00:35:08,760
symlink yeah

00:35:09,760 --> 00:35:16,820
any more questions

00:35:12,610 --> 00:35:18,920
yes we're running late okay so in the

00:35:16,820 --> 00:35:21,340
Sun in this case let's find a speaker in

00:35:18,920 --> 00:35:21,340

YouTube URL: https://www.youtube.com/watch?v=-PZNF8XDNn8


