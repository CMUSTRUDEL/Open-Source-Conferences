Title: Does Making the Kernel Harder Make Making the Kernel Harder? - Casey Schaufler, The Smack Project
Publication date: 2018-10-26
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Does Making the Kernel Harder Make Making the Kernel Harder? - Casey Schaufler, The Smack ProjectÂ 

 The Linux Kernel Hardening Project is making significant strides in reducing vulnerabilities and in increasing the effort required to exploit vulnerabilities that remain. Much of what has been implemented is obviously valuable, but sometimes the benefit is more subtle. How does the introduction of refcount_t make the kernel more secure, and by how much? What value is there in removing variable length arrays? Casey Schaufler, a (really) long time kernel developer will explain why some of these changes provide significantly greater value than might be apparent to the casual observer. He will discuss the cost of kernel hardening in terms of development overhead, code churn and performance. 

About Casey Schaufler
Casey Schaufler worked on Unix kernels in the 1970s-90s. He has implemented access control lists, mandatory access control, extended filesystem attributes, X11 access controls, network protocols and more audit systems than is really healthy. His involvement in Linux began with the Linux Security Module work at the turn of the century, introducing the Smack LSM in 2007. Casey is reworking the LSM infrastructure to support multiple concurrent modules. He has spoken at Linux Conference Australia, OLS, LinuxCon, Linux Plumbers and many other venues.
Captions: 
	00:00:00,000 --> 00:00:05,430
ah thank you everybody you always get a

00:00:03,140 --> 00:00:07,379
little bit nervous when you're the third

00:00:05,430 --> 00:00:09,450
talk on a touch on a subject in a row

00:00:07,379 --> 00:00:12,509
you start worrying about which of your

00:00:09,450 --> 00:00:21,359
slides you have to throw out or modify

00:00:12,509 --> 00:00:22,949
or correct but and turn on the hi I'm

00:00:21,359 --> 00:00:27,449
Casey Schaeffler I've been doing colonel

00:00:22,949 --> 00:00:29,070
development since 1978 so I've seen all

00:00:27,449 --> 00:00:34,230
kinds of interesting things going to the

00:00:29,070 --> 00:00:37,559
end of the code base why don't we think

00:00:34,230 --> 00:00:39,780
the colonel is hard for anybody here at

00:00:37,559 --> 00:00:44,579
Colonel developer who does not work in

00:00:39,780 --> 00:00:47,780
security let's just see okay good so

00:00:44,579 --> 00:00:50,340
this this won't be completely wasted

00:00:47,780 --> 00:00:52,680
first thing is to me see to cause damage

00:00:50,340 --> 00:00:54,899
we all know we all know buffer overflows

00:00:52,680 --> 00:00:56,940
stack these and string functions and

00:00:54,899 --> 00:00:59,760
it's just there are so many different

00:00:56,940 --> 00:01:01,890
ways that you can cause the kernel to do

00:00:59,760 --> 00:01:05,420
things that that you don't want to do it

00:01:01,890 --> 00:01:10,320
either for bugs or malicious it's just

00:01:05,420 --> 00:01:11,820
it's still too easy and at this point

00:01:10,320 --> 00:01:15,450
we've got a bunch of people who want to

00:01:11,820 --> 00:01:16,560
do damage who are really clever and not

00:01:15,450 --> 00:01:22,320
only are they clever they're motivated

00:01:16,560 --> 00:01:24,869
they're making money off of it it

00:01:22,320 --> 00:01:28,890
exploits the credit cards all kinds of

00:01:24,869 --> 00:01:30,750
good things even we have a title which

00:01:28,890 --> 00:01:34,710
is evolved over the past few days of

00:01:30,750 --> 00:01:36,360
security researcher used to be called

00:01:34,710 --> 00:01:37,770
hackers now now we've got a

00:01:36,360 --> 00:01:39,060
differentiate between the good guys and

00:01:37,770 --> 00:01:42,540
that so now there are security

00:01:39,060 --> 00:01:45,240
researchers if they've come out in the

00:01:42,540 --> 00:01:46,500
public and done something that they're

00:01:45,240 --> 00:01:47,939
getting paid for as part of their job

00:01:46,500 --> 00:01:50,939
they get called a security researcher

00:01:47,939 --> 00:01:55,799
otherwise they're they're a miscreant of

00:01:50,939 --> 00:01:57,329
some sort but that's not new is it I was

00:01:55,799 --> 00:02:01,320
like we've known about this for some

00:01:57,329 --> 00:02:03,509
time so what's kind of the base of the

00:02:01,320 --> 00:02:07,610
problem how old is this problem really

00:02:03,509 --> 00:02:07,610
and really it's as old as the C compiler

00:02:08,450 --> 00:02:11,459
if you've

00:02:10,389 --> 00:02:13,890
[Music]

00:02:11,459 --> 00:02:17,340
ever had ever seen the original Kate

00:02:13,890 --> 00:02:19,890
turn Han Richie C book that's about yay

00:02:17,340 --> 00:02:22,470
big and it's it's a small it's in a

00:02:19,890 --> 00:02:24,629
small format and it's really easy to

00:02:22,470 --> 00:02:27,239
read I learned it I used it as part of

00:02:24,629 --> 00:02:29,879
my my educational process and learning

00:02:27,239 --> 00:02:35,879
how to program me which explains a lot

00:02:29,879 --> 00:02:37,409
about my code if you've ever seen it but

00:02:35,879 --> 00:02:39,299
the C language is written in a time

00:02:37,409 --> 00:02:42,120
where operating systems were written in

00:02:39,299 --> 00:02:43,980
assembler in fact text for matters were

00:02:42,120 --> 00:02:47,629
written in assembler in fact virtually

00:02:43,980 --> 00:02:51,000
everything was written in assembler and

00:02:47,629 --> 00:02:53,489
for systems programming C's a really

00:02:51,000 --> 00:02:55,319
really really good language because it

00:02:53,489 --> 00:02:59,190
allows you to do the things that you can

00:02:55,319 --> 00:03:01,950
do an assembler while actually giving

00:02:59,190 --> 00:03:04,590
you some rational structure to your

00:03:01,950 --> 00:03:06,450
program so you can organize your memory

00:03:04,590 --> 00:03:08,459
with data structures and you can your

00:03:06,450 --> 00:03:11,659
control flow you can follow your control

00:03:08,459 --> 00:03:17,120
flow because of the way the the

00:03:11,659 --> 00:03:21,480
constructs in the language provide for

00:03:17,120 --> 00:03:27,599
that's but it's not strongly typed it's

00:03:21,480 --> 00:03:31,889
more a suggestion or a guideline then

00:03:27,599 --> 00:03:33,720
then an actual rule set it this is

00:03:31,889 --> 00:03:35,519
efficient and convenient just like you

00:03:33,720 --> 00:03:37,349
can do a lot of really things if it's

00:03:35,519 --> 00:03:39,599
really interesting things efficiently

00:03:37,349 --> 00:03:41,519
for exam my favorite one is the one

00:03:39,599 --> 00:03:43,769
where you have a data structure which

00:03:41,519 --> 00:03:47,129
defines a header and then it divides it

00:03:43,769 --> 00:03:49,579
defines a 1:1 element array and you can

00:03:47,129 --> 00:03:52,109
use this you can allocate memory for

00:03:49,579 --> 00:03:54,449
your data structures and say hey this

00:03:52,109 --> 00:03:57,090
thing's actually got 74 things in it so

00:03:54,449 --> 00:03:59,940
you allocate allocate enough memory 477

00:03:57,090 --> 00:04:01,290
for things plus the header and and

00:03:59,940 --> 00:04:03,799
you're good you don't have to worry

00:04:01,290 --> 00:04:06,540
about then you can dereference it

00:04:03,799 --> 00:04:07,980
appropriately so you can understand what

00:04:06,540 --> 00:04:11,989
you're doing even though you haven't

00:04:07,980 --> 00:04:15,320
constrained yourself by the data type

00:04:11,989 --> 00:04:17,820
you can be clever and you can be precise

00:04:15,320 --> 00:04:22,560
the way you have to do sometimes for

00:04:17,820 --> 00:04:25,230
example if you have a an internet

00:04:22,560 --> 00:04:26,790
protocol header you don't know

00:04:25,230 --> 00:04:29,160
at the beginning whether it's an ipv6

00:04:26,790 --> 00:04:31,740
internet or an ipv4 and the structure is

00:04:29,160 --> 00:04:36,210
different depending on that so you can

00:04:31,740 --> 00:04:38,070
actually go look in the you can have a

00:04:36,210 --> 00:04:40,430
data structure that defines what this is

00:04:38,070 --> 00:04:43,200
and if you say oh that's the wrong one

00:04:40,430 --> 00:04:45,420
after you go look you can go switch it

00:04:43,200 --> 00:04:48,200
that's pretty convenient you can't do

00:04:45,420 --> 00:04:51,270
that in a strongly typed language and

00:04:48,200 --> 00:04:52,560
now so with all that good stuff to say

00:04:51,270 --> 00:04:57,000
about it why would I want to give it up

00:04:52,560 --> 00:04:58,530
and the answer is you probably don't we

00:04:57,000 --> 00:05:02,700
all know that strong typing is for weak

00:04:58,530 --> 00:05:05,070
minds and strongly typed languages have

00:05:02,700 --> 00:05:07,020
their own issues for example if you have

00:05:05,070 --> 00:05:10,320
a piece of data which legitimately might

00:05:07,020 --> 00:05:11,880
be an ipv6 header or an ipv4 header how

00:05:10,320 --> 00:05:13,950
do you declare that in a strongly typed

00:05:11,880 --> 00:05:15,990
language the answer is you can't

00:05:13,950 --> 00:05:18,990
yeah you need to have some way to

00:05:15,990 --> 00:05:21,270
circumvent the strong typing in order to

00:05:18,990 --> 00:05:23,250
deal with that kind of data

00:05:21,270 --> 00:05:25,560
now you could talk about object-oriented

00:05:23,250 --> 00:05:29,430
programming that's always always one of

00:05:25,560 --> 00:05:31,650
my favorites let's let's do garbage

00:05:29,430 --> 00:05:32,610
collection during the interning and

00:05:31,650 --> 00:05:35,790
interrupt handler

00:05:32,610 --> 00:05:39,060
yeah real-time impacts are awfully good

00:05:35,790 --> 00:05:40,200
on that and the other thing is every now

00:05:39,060 --> 00:05:42,560
and then I'll hear somebody say hey

00:05:40,200 --> 00:05:47,040
let's rewrite the kernel in rust or

00:05:42,560 --> 00:05:47,730
language do you ER and I say great how

00:05:47,040 --> 00:05:49,410
you gonna do that

00:05:47,730 --> 00:05:51,240
well we'll automatically convert it you

00:05:49,410 --> 00:05:56,250
know we'll write some some awk scripts

00:05:51,240 --> 00:06:00,990
we don't pass that no Perl no wait a

00:05:56,250 --> 00:06:03,480
minute that will you again well use some

00:06:00,990 --> 00:06:05,850
interesting language and we're gonna

00:06:03,480 --> 00:06:08,640
just do an auto convert and that will

00:06:05,850 --> 00:06:10,830
work for about 90 percent of 90 percent

00:06:08,640 --> 00:06:13,050
of the system at which when we hit the

00:06:10,830 --> 00:06:16,410
90 90 rule which is that 90 percent of

00:06:13,050 --> 00:06:18,150
the of the code can be converted in 90

00:06:16,410 --> 00:06:19,350
percent of the time and the last 10

00:06:18,150 --> 00:06:24,090
percent will take the other 90 percent

00:06:19,350 --> 00:06:26,880
of the time but there are things we can

00:06:24,090 --> 00:06:28,320
do we can use the type in that's

00:06:26,880 --> 00:06:30,030
available that make things a little bit

00:06:28,320 --> 00:06:34,700
easier no we can fix what we knows

00:06:30,030 --> 00:06:37,020
dangerous keys talked about case sorry

00:06:34,700 --> 00:06:37,680
no name for years and I still get that

00:06:37,020 --> 00:06:43,080
wrong

00:06:37,680 --> 00:06:44,520
and only in public okay we fix we can

00:06:43,080 --> 00:06:47,250
fix things that we know we're dangerous

00:06:44,520 --> 00:06:48,210
and yeah we can prepare for failure

00:06:47,250 --> 00:06:51,960
because we know what's going to happen

00:06:48,210 --> 00:06:53,070
anyway so typing how does that help

00:06:51,960 --> 00:06:55,860
let's see

00:06:53,070 --> 00:06:59,639
well our good example here is is this

00:06:55,860 --> 00:07:02,639
case reference referenced earlier the

00:06:59,639 --> 00:07:06,030
ref count T now a reference count is a

00:07:02,639 --> 00:07:09,300
very very specific kind of behavior it

00:07:06,030 --> 00:07:11,789
really is an integer but you are using

00:07:09,300 --> 00:07:13,169
it in a very specific way it's got a

00:07:11,789 --> 00:07:15,960
couple of properties that make it very

00:07:13,169 --> 00:07:19,530
interesting one of which is that it

00:07:15,960 --> 00:07:21,330
should never be zero and that you should

00:07:19,530 --> 00:07:24,750
never assign to it you should only ever

00:07:21,330 --> 00:07:31,229
increment it or decrement it or look at

00:07:24,750 --> 00:07:33,840
it in the case of freeing so if we use a

00:07:31,229 --> 00:07:36,180
ref count T in a place where it's

00:07:33,840 --> 00:07:38,970
appropriate we can control the behavior

00:07:36,180 --> 00:07:41,970
of that and we can put checks into the

00:07:38,970 --> 00:07:45,389
handling ref County so that when we find

00:07:41,970 --> 00:07:48,330
a problem we can assume that something

00:07:45,389 --> 00:07:51,180
bad is gone bad has happened either it's

00:07:48,330 --> 00:07:52,950
been attacked or there's a bug at that

00:07:51,180 --> 00:07:55,500
point we don't know and we don't really

00:07:52,950 --> 00:07:58,889
care we just didn't just say what bad

00:07:55,500 --> 00:08:01,169
thing happened in a ref county and

00:07:58,889 --> 00:08:04,680
that'll find a lot of bugs prevent a lot

00:08:01,169 --> 00:08:07,050
of attacks good thing so what do we know

00:08:04,680 --> 00:08:08,820
can be dangerous well the stream

00:08:07,050 --> 00:08:13,349
functions

00:08:08,820 --> 00:08:18,750
I would anybody notice what's wrong with

00:08:13,349 --> 00:08:21,889
the the stern copy example here somebody

00:08:18,750 --> 00:08:21,889
must be able to figure that out

00:08:24,149 --> 00:08:32,079
actually it shouldn't be a sterling of

00:08:26,589 --> 00:08:33,519
anything yeah if it were the sterling of

00:08:32,079 --> 00:08:36,579
desks that would be whatever is already

00:08:33,519 --> 00:08:38,469
there of the source means it's coming

00:08:36,579 --> 00:08:40,240
you're saying oh yeah we'll just copy

00:08:38,469 --> 00:08:42,759
everything that's and actually there are

00:08:40,240 --> 00:08:45,189
two bugs in the second one because if

00:08:42,759 --> 00:08:47,529
it's actually the exact length of dest

00:08:45,189 --> 00:08:50,230
you're gonna lose that actually you're

00:08:47,529 --> 00:08:53,290
gonna lose the you're gonna lose the

00:08:50,230 --> 00:08:57,250
terminating null so say there are two

00:08:53,290 --> 00:08:59,139
bugs in that so the thing with string

00:08:57,250 --> 00:09:01,600
functions is that if you use them

00:08:59,139 --> 00:09:03,910
correctly it's okay

00:09:01,600 --> 00:09:05,829
the problem is that we've got a lot of

00:09:03,910 --> 00:09:09,550
people who've never learned to use them

00:09:05,829 --> 00:09:10,689
right oh well maybe they shouldn't be

00:09:09,550 --> 00:09:19,449
programming in the car

00:09:10,689 --> 00:09:25,240
we've got no js' these days okay okay so

00:09:19,449 --> 00:09:28,959
sorry so and then automatic erase case

00:09:25,240 --> 00:09:29,800
was talking about this earlier why is

00:09:28,959 --> 00:09:33,309
this a problem

00:09:29,800 --> 00:09:35,889
well because you've got a function where

00:09:33,309 --> 00:09:37,689
you're you're going to say I want to

00:09:35,889 --> 00:09:40,240
write you know I need an array here and

00:09:37,689 --> 00:09:42,490
needs to be big enough for whatever the

00:09:40,240 --> 00:09:46,899
caller is is using so he's going to tell

00:09:42,490 --> 00:09:49,329
me how big it is well we got two per two

00:09:46,899 --> 00:09:52,149
choices here if we want to actually make

00:09:49,329 --> 00:09:55,209
things safe either we can check in the

00:09:52,149 --> 00:09:58,720
in my function here to make sure that

00:09:55,209 --> 00:10:00,730
that numbers appropriate or I can check

00:09:58,720 --> 00:10:04,269
all the places to call it and make sure

00:10:00,730 --> 00:10:07,420
that that number is appropriate but both

00:10:04,269 --> 00:10:09,699
of those those approaches have have

00:10:07,420 --> 00:10:16,569
their problems when do you know what's

00:10:09,699 --> 00:10:19,209
appropriate when we're doing casts you

00:10:16,569 --> 00:10:21,490
can cast you can say I want to treat you

00:10:19,209 --> 00:10:23,290
know I want a pointer to this object

00:10:21,490 --> 00:10:25,750
over here and I want to treat it like a

00:10:23,290 --> 00:10:29,769
cred structure okay but if I is an

00:10:25,750 --> 00:10:31,209
integer I've got problems because it's

00:10:29,769 --> 00:10:33,519
not clearly not enough space for the

00:10:31,209 --> 00:10:34,480
credential on the other hand if it's

00:10:33,519 --> 00:10:35,250
something that's bigger than the

00:10:34,480 --> 00:10:37,620
credential

00:10:35,250 --> 00:10:40,680
I may not be fixing you know setting all

00:10:37,620 --> 00:10:43,530
the information that I need because the

00:10:40,680 --> 00:10:45,180
cred is your only so big and if I really

00:10:43,530 --> 00:10:48,240
have got a cred and then some stuff

00:10:45,180 --> 00:10:49,800
after it I'm not setting that I may have

00:10:48,240 --> 00:10:53,130
trouble there so castes are kind of

00:10:49,800 --> 00:10:56,790
dangerous in this case and then my

00:10:53,130 --> 00:10:58,170
second example here I'll leave it as an

00:10:56,790 --> 00:11:01,470
example to you to figure out what that

00:10:58,170 --> 00:11:03,660
is supposed to do but really what should

00:11:01,470 --> 00:11:05,790
have happened here is that temp should

00:11:03,660 --> 00:11:07,020
have been defined as an unsigned int and

00:11:05,790 --> 00:11:10,980
then there wouldn't be any problems at

00:11:07,020 --> 00:11:13,770
all by the way 80% of castes and I'm

00:11:10,980 --> 00:11:15,900
making this statistic up on the fly

00:11:13,770 --> 00:11:19,350
80% of castes are incorrect or

00:11:15,900 --> 00:11:22,310
unnecessary now it's not that these

00:11:19,350 --> 00:11:25,500
things can't be used safely they can be

00:11:22,310 --> 00:11:28,410
but checking that you that doing checks

00:11:25,500 --> 00:11:31,070
on your parameters can be expensive and

00:11:28,410 --> 00:11:36,150
sometimes you don't you know and if you

00:11:31,070 --> 00:11:37,350
if you make the check at the end you may

00:11:36,150 --> 00:11:39,480
be making a whole lot of checks you

00:11:37,350 --> 00:11:41,370
don't need to and if you make it from

00:11:39,480 --> 00:11:42,510
from all the places that are calling it

00:11:41,370 --> 00:11:44,880
well what about out of three modules

00:11:42,510 --> 00:11:48,600
that you can't see are they doing it

00:11:44,880 --> 00:11:51,810
correctly so we got a we got an issue

00:11:48,600 --> 00:11:53,940
here it's like you got to figure out

00:11:51,810 --> 00:11:55,740
which is more important you know do you

00:11:53,940 --> 00:11:57,630
find all the places to call it are you

00:11:55,740 --> 00:11:58,980
doing check there are you gonna put the

00:11:57,630 --> 00:12:00,870
check here and everybody's going to go

00:11:58,980 --> 00:12:03,870
through it even though all but one of

00:12:00,870 --> 00:12:07,820
your callers isn't isn't doing it

00:12:03,870 --> 00:12:10,250
incorrectly it can be a balancing act

00:12:07,820 --> 00:12:14,100
stacks

00:12:10,250 --> 00:12:15,780
why can't we get rid of stacks there

00:12:14,100 --> 00:12:17,520
they're machines that didn't used to

00:12:15,780 --> 00:12:18,810
have them but anyway here's a picture of

00:12:17,520 --> 00:12:24,810
the guy who invented them you can blame

00:12:18,810 --> 00:12:27,210
him their convenience you push stuff on

00:12:24,810 --> 00:12:28,620
him you pull you pop stuff off of it it

00:12:27,210 --> 00:12:31,320
can be hardware accelerated they're

00:12:28,620 --> 00:12:36,420
really great but they're also convenient

00:12:31,320 --> 00:12:38,370
for mucking up why is that well if

00:12:36,420 --> 00:12:40,470
you're in a function you know that that

00:12:38,370 --> 00:12:42,630
the stuff the parameters for the

00:12:40,470 --> 00:12:45,180
functions that are in this in the trace

00:12:42,630 --> 00:12:48,320
that got got you there are on the stack

00:12:45,180 --> 00:12:51,410
you could go look at them no no

00:12:48,320 --> 00:12:53,240
no need to actually think about passing

00:12:51,410 --> 00:12:55,970
everything you just go look on sexy what

00:12:53,240 --> 00:12:58,340
was there and you know that anybody you

00:12:55,970 --> 00:13:00,050
called the last function you called is

00:12:58,340 --> 00:13:03,530
still on the stack below you so you can

00:13:00,050 --> 00:13:06,080
just go look there right if you make a

00:13:03,530 --> 00:13:07,670
call and while they you know he had an

00:13:06,080 --> 00:13:09,170
intermediate result that I could you see

00:13:07,670 --> 00:13:10,880
that's just just you know where it is on

00:13:09,170 --> 00:13:15,050
the stack you've written read the code

00:13:10,880 --> 00:13:17,120
so you just go look for it or if heaven

00:13:15,050 --> 00:13:18,650
forbid you're an attacker you can use

00:13:17,120 --> 00:13:20,300
that same mindset you'll find

00:13:18,650 --> 00:13:22,310
information you probably shouldn't have

00:13:20,300 --> 00:13:23,510
there are some intermediate States from

00:13:22,310 --> 00:13:26,840
functions your calling you probably

00:13:23,510 --> 00:13:29,570
shouldn't be seen now you can make it

00:13:26,840 --> 00:13:32,090
harder to get to do that you can put

00:13:29,570 --> 00:13:34,880
gaps between the stack between the stack

00:13:32,090 --> 00:13:36,320
elements that set pages that works that

00:13:34,880 --> 00:13:38,540
that's a big help

00:13:36,320 --> 00:13:40,610
you can if you know what what the gaps

00:13:38,540 --> 00:13:42,830
are you can still work your way around

00:13:40,610 --> 00:13:46,460
that or if you're cleverer than I am you

00:13:42,830 --> 00:13:49,160
can come up with other ways you can

00:13:46,460 --> 00:13:50,540
erase what what's no longer needed case

00:13:49,160 --> 00:13:52,460
was talking about this earlier so you

00:13:50,540 --> 00:13:55,460
come out of a function you erase the

00:13:52,460 --> 00:13:57,590
erase the stack that solves that half of

00:13:55,460 --> 00:14:01,360
the problem right there

00:13:57,590 --> 00:14:01,360
now I just had a random thought

00:14:02,620 --> 00:14:06,770
let's randomize everything so that

00:14:04,910 --> 00:14:08,930
nobody knows where it is that'll that'll

00:14:06,770 --> 00:14:10,070
take those hackers and just walk them up

00:14:08,930 --> 00:14:12,230
the head because they won't be able to

00:14:10,070 --> 00:14:16,010
find anything anymore

00:14:12,230 --> 00:14:18,020
well attackers and developers hate

00:14:16,010 --> 00:14:20,420
randomization and they both hate it for

00:14:18,020 --> 00:14:22,670
the same reason that is it makes it

00:14:20,420 --> 00:14:25,100
really hard to find where things are

00:14:22,670 --> 00:14:28,600
when things go when things aren't

00:14:25,100 --> 00:14:28,600
working the way the code is supposed to

00:14:28,990 --> 00:14:33,230
sometimes you really need the real

00:14:30,830 --> 00:14:35,770
address of something or if you have the

00:14:33,230 --> 00:14:38,150
real address it's much easier to exploit

00:14:35,770 --> 00:14:39,920
if you're looking at logs trying to

00:14:38,150 --> 00:14:42,260
figure out where your bug is or you look

00:14:39,920 --> 00:14:47,480
in the log to figure out where where

00:14:42,260 --> 00:14:49,250
data is that you want to get at and you

00:14:47,480 --> 00:14:51,020
don't have the address in the log it's

00:14:49,250 --> 00:14:53,330
really tough to do that you have to

00:14:51,020 --> 00:14:54,380
start working and of course anytime

00:14:53,330 --> 00:14:55,580
you've written a debugger

00:14:54,380 --> 00:14:57,710
that's like you've written the debugger

00:14:55,580 --> 00:14:59,030
it's out released yay is I haven't

00:14:57,710 --> 00:15:01,040
supported it for two years and all of a

00:14:59,030 --> 00:15:04,790
sudden BAM we've got hashed

00:15:01,040 --> 00:15:06,110
dresses well what am I gonna do in math

00:15:04,790 --> 00:15:07,490
well rewrite my tool to deal with the

00:15:06,110 --> 00:15:10,579
fact that the address isn't really the

00:15:07,490 --> 00:15:12,769
address it's an arbitrary representation

00:15:10,579 --> 00:15:15,459
of the address which may or may not be

00:15:12,769 --> 00:15:20,630
accurate relative to the other addresses

00:15:15,459 --> 00:15:22,250
things my tools get buggered we can

00:15:20,630 --> 00:15:23,319
randomized data structures this is

00:15:22,250 --> 00:15:26,810
always fun

00:15:23,319 --> 00:15:28,699
someone has spent months getting this

00:15:26,810 --> 00:15:31,639
data structure in the right order so

00:15:28,699 --> 00:15:34,430
that on that armed arm 64 box that

00:15:31,639 --> 00:15:34,970
they've got yet the cache is never

00:15:34,430 --> 00:15:38,149
missed

00:15:34,970 --> 00:15:40,660
ever ever and so now you put a little

00:15:38,149 --> 00:15:43,100
thing into the compiler that says oh

00:15:40,660 --> 00:15:45,199
just what the things around in two

00:15:43,100 --> 00:15:46,430
different orders now not only you're

00:15:45,199 --> 00:15:48,980
missing your cache lines but the

00:15:46,430 --> 00:15:51,740
structure actually got smaller because

00:15:48,980 --> 00:15:55,009
their ordering is you know the random

00:15:51,740 --> 00:15:58,579
order happens to be better from a size

00:15:55,009 --> 00:16:02,720
size viewpoint then you're careful of

00:15:58,579 --> 00:16:07,190
cache line thingy and so now your system

00:16:02,720 --> 00:16:08,690
actually runs running slower and this is

00:16:07,190 --> 00:16:11,180
all bad and it's in the networking

00:16:08,690 --> 00:16:12,829
networking stack and everybody knows

00:16:11,180 --> 00:16:16,279
that nothing is more critical than cache

00:16:12,829 --> 00:16:20,899
lines in the networking stack so there

00:16:16,279 --> 00:16:22,790
are we have this in now you can say you

00:16:20,899 --> 00:16:25,760
want going to randomize your layout or

00:16:22,790 --> 00:16:29,990
not randomize your layout or let the

00:16:25,760 --> 00:16:32,480
system decide for you it's okay yes

00:16:29,990 --> 00:16:34,819
really duh one of the one of the big

00:16:32,480 --> 00:16:38,660
benefits of this makes it hard for

00:16:34,819 --> 00:16:41,149
somebody who's running a program to find

00:16:38,660 --> 00:16:42,949
a particular data structure in memory to

00:16:41,149 --> 00:16:45,889
do so because if they don't know where

00:16:42,949 --> 00:16:48,470
what the order things are in they can't

00:16:45,889 --> 00:16:51,199
finger predict okay stack pages sack

00:16:48,470 --> 00:16:52,550
pages are just pages right there's no

00:16:51,199 --> 00:16:55,730
reason we can't just shuffle them around

00:16:52,550 --> 00:16:58,000
and put them wherever we want no reason

00:16:55,730 --> 00:17:00,319
they have to be in any particular place

00:16:58,000 --> 00:17:04,880
we leave this is an exercise to the

00:17:00,319 --> 00:17:07,520
reader functions yeah there's no reason

00:17:04,880 --> 00:17:10,600
that functions you know in the kernel

00:17:07,520 --> 00:17:10,600
should be in any particular order

00:17:10,630 --> 00:17:15,580
there are optimizations that

00:17:13,900 --> 00:17:17,110
that are a little bit trickier if you're

00:17:15,580 --> 00:17:21,070
going to randomize the order of

00:17:17,110 --> 00:17:22,780
functions but not that much right and

00:17:21,070 --> 00:17:25,570
again this makes it a lot harder for

00:17:22,780 --> 00:17:27,550
somebody who is looking at the system to

00:17:25,570 --> 00:17:30,370
find things find where things are so

00:17:27,550 --> 00:17:33,160
that they can go and find how they're

00:17:30,370 --> 00:17:39,010
going about how they're going to go

00:17:33,160 --> 00:17:40,360
about exploiting it thank you this is a

00:17:39,010 --> 00:17:42,610
lot harder if you want to do it on every

00:17:40,360 --> 00:17:45,280
boot than it is if you want to do it at

00:17:42,610 --> 00:17:46,360
build time but again there are a lot of

00:17:45,280 --> 00:17:50,980
clever people out there who know

00:17:46,360 --> 00:17:53,500
compilers which unfortunately don't now

00:17:50,980 --> 00:17:55,990
do I have to worry about performance you

00:17:53,500 --> 00:17:58,930
know all this when I'm doing my looking

00:17:55,990 --> 00:18:00,610
at making the kernel harder or just

00:17:58,930 --> 00:18:05,260
doing things in general and it's like

00:18:00,610 --> 00:18:07,350
does the Sun set in the West yeah

00:18:05,260 --> 00:18:09,340
actually it does why do I have to be

00:18:07,350 --> 00:18:13,780
particularly concerned about performance

00:18:09,340 --> 00:18:16,120
well true story has happened to me all

00:18:13,780 --> 00:18:18,880
right hey we want to put this security

00:18:16,120 --> 00:18:20,800
code into the networking stack no well

00:18:18,880 --> 00:18:21,940
why not we can't measure any performance

00:18:20,800 --> 00:18:26,830
well then your benchmarks are good

00:18:21,940 --> 00:18:29,080
enough oh okay okay we've got benchmarks

00:18:26,830 --> 00:18:30,420
now but they still can't find still

00:18:29,080 --> 00:18:32,740
can't find any still can't find anything

00:18:30,420 --> 00:18:35,020
finally got a new piece of networking

00:18:32,740 --> 00:18:36,130
hardware in that was 10 times the

00:18:35,020 --> 00:18:40,240
performance of anything we did

00:18:36,130 --> 00:18:43,270
previously yes in this case in this

00:18:40,240 --> 00:18:46,000
error case under these circumstances we

00:18:43,270 --> 00:18:47,290
have a 2% performance degradation ok

00:18:46,000 --> 00:18:51,910
great you can't check that in because it

00:18:47,290 --> 00:18:54,640
has a performance impact ok well fix fix

00:18:51,910 --> 00:18:57,130
fix fix get clever get clever hey look

00:18:54,640 --> 00:18:58,930
we fixed that performance impact so it

00:18:57,130 --> 00:19:00,790
now has no performance impact can we

00:18:58,930 --> 00:19:08,920
check it in know your benchmarks aren't

00:19:00,790 --> 00:19:10,930
good enough ok so performance is always

00:19:08,920 --> 00:19:15,430
going to be critical and there's a

00:19:10,930 --> 00:19:16,720
reason for this well I hate it when my

00:19:15,430 --> 00:19:19,960
slides show up before they're supposed

00:19:16,720 --> 00:19:23,530
to ok performance Trump's security more

00:19:19,960 --> 00:19:26,200
often than not unless you're in an

00:19:23,530 --> 00:19:27,430
environment that is explicitly made the

00:19:26,200 --> 00:19:29,640
decision that they

00:19:27,430 --> 00:19:33,280
going to take security over performance

00:19:29,640 --> 00:19:35,290
performance will win in an argument and

00:19:33,280 --> 00:19:36,930
the reason for this is really pretty

00:19:35,290 --> 00:19:40,620
simple

00:19:36,930 --> 00:19:44,740
performance is objective and

00:19:40,620 --> 00:19:46,600
quantitative you can come up with a

00:19:44,740 --> 00:19:49,630
performance number you can say 2%

00:19:46,600 --> 00:19:52,090
degradation or 50% degradation or I ran

00:19:49,630 --> 00:19:53,610
this benchmark and I got a 17 instead of

00:19:52,090 --> 00:19:56,080
a 32

00:19:53,610 --> 00:19:57,280
you can come bake if you're a

00:19:56,080 --> 00:20:01,480
performance how you can come in with a

00:19:57,280 --> 00:20:04,060
number numbers are really easy to use

00:20:01,480 --> 00:20:11,620
when you're making an argument where a

00:20:04,060 --> 00:20:14,020
security is is quantum hey if you don't

00:20:11,620 --> 00:20:16,240
know of any problems any security

00:20:14,020 --> 00:20:19,110
problems with some code well nobody

00:20:16,240 --> 00:20:22,200
cares about security in that code if

00:20:19,110 --> 00:20:24,370
you've identified a possible

00:20:22,200 --> 00:20:26,650
vulnerability well there are a few

00:20:24,370 --> 00:20:28,480
people who are interested but really in

00:20:26,650 --> 00:20:29,620
general nobody cares

00:20:28,480 --> 00:20:32,410
you're not gonna win they're not with

00:20:29,620 --> 00:20:34,480
that if you've demonstrated a

00:20:32,410 --> 00:20:37,090
vulnerability people start to notice it

00:20:34,480 --> 00:20:44,260
but until it's exploited and has a name

00:20:37,090 --> 00:20:46,420
nobody gives a rat's anatomy but again

00:20:44,260 --> 00:20:48,310
once it's exploited people care until

00:20:46,420 --> 00:20:49,630
it's exploited you can't go into an

00:20:48,310 --> 00:20:51,040
argument with a performance guy because

00:20:49,630 --> 00:20:56,410
I performance guys gonna come in with a

00:20:51,040 --> 00:21:00,460
number so at the end is it worth the

00:20:56,410 --> 00:21:01,960
bother it's like some of the stuff that

00:21:00,460 --> 00:21:05,860
we're doing in kernel hardening is

00:21:01,960 --> 00:21:11,500
really kind of minutia or really looks

00:21:05,860 --> 00:21:14,530
like it we introduce code churn ref

00:21:11,500 --> 00:21:18,880
count t 180 files with ref counties in

00:21:14,530 --> 00:21:20,520
them 500 instances of ref counties in

00:21:18,880 --> 00:21:24,580
those file and there's still more to do

00:21:20,520 --> 00:21:27,220
okay the variable length or race yeah

00:21:24,580 --> 00:21:28,750
it's like we're turning a bunch of code

00:21:27,220 --> 00:21:32,580
here we're turning code that hasn't been

00:21:28,750 --> 00:21:36,130
touched in years in order to do this

00:21:32,580 --> 00:21:38,170
hypothetical security possible maybe

00:21:36,130 --> 00:21:40,650
someday somebody's gonna have a problem

00:21:38,170 --> 00:21:43,210
with this stuff

00:21:40,650 --> 00:21:47,230
and we're introducing runtime overhead

00:21:43,210 --> 00:21:49,660
when we do it not always I was like some

00:21:47,230 --> 00:21:51,100
of the the removals of the the

00:21:49,660 --> 00:21:58,360
variable-length arrays have actually

00:21:51,100 --> 00:22:00,810
sped things up harden user copy on the

00:21:58,360 --> 00:22:02,920
other hand has real performance impact

00:22:00,810 --> 00:22:05,650
there are cases where people were

00:22:02,920 --> 00:22:07,240
copying copying information from

00:22:05,650 --> 00:22:10,690
inappropriate places in the user space

00:22:07,240 --> 00:22:12,700
and vice versa you certainly don't want

00:22:10,690 --> 00:22:16,480
to cut copied directly from user space

00:22:12,700 --> 00:22:19,980
into a DMA area for example that's

00:22:16,480 --> 00:22:22,030
usually a bad thing to do and we

00:22:19,980 --> 00:22:26,200
introduced you introduced a lot of

00:22:22,030 --> 00:22:28,480
checks in places when audit went in for

00:22:26,200 --> 00:22:30,340
example there was a lot of concern about

00:22:28,480 --> 00:22:33,580
how much impact it would have on every

00:22:30,340 --> 00:22:40,300
system call well and that's these are

00:22:33,580 --> 00:22:41,290
completely legitimate concerns and the

00:22:40,300 --> 00:22:44,290
other thing you have to worry about is

00:22:41,290 --> 00:22:45,400
the developer experience okay now

00:22:44,290 --> 00:22:48,970
there's the user experience is the

00:22:45,400 --> 00:22:50,800
developer experience the Linux community

00:22:48,970 --> 00:22:52,780
has been very big on the developer

00:22:50,800 --> 00:22:54,520
experience Linna store vols is very big

00:22:52,780 --> 00:22:55,630
on the developer experience because if

00:22:54,520 --> 00:22:58,990
you don't have a good developer

00:22:55,630 --> 00:23:00,670
experience you don't have developers and

00:22:58,990 --> 00:23:03,580
developers are really pretty important

00:23:00,670 --> 00:23:05,320
especially in in a situation where not

00:23:03,580 --> 00:23:10,420
everybody who's working on the code is

00:23:05,320 --> 00:23:12,510
getting paid to do it now some of the

00:23:10,420 --> 00:23:15,850
things that we can that we do are

00:23:12,510 --> 00:23:17,590
simplest check patch all right you put

00:23:15,850 --> 00:23:21,580
something in to check patch that says

00:23:17,590 --> 00:23:24,670
hey you know what you're using this this

00:23:21,580 --> 00:23:27,550
interface but it's that's deprecated you

00:23:24,670 --> 00:23:30,100
shouldn't be using that or you're using

00:23:27,550 --> 00:23:35,140
this this function in a way that's

00:23:30,100 --> 00:23:36,790
that's really not appropriate that okay

00:23:35,140 --> 00:23:40,930
well I haven't checked the code in yet

00:23:36,790 --> 00:23:42,550
yeah can fix that before I do it I can

00:23:40,930 --> 00:23:48,120
also on the other hand it can be pretty

00:23:42,550 --> 00:23:48,120
picky like the the whole thing with % P

00:23:48,210 --> 00:23:53,530
where % P has that's how you're printing

00:23:52,179 --> 00:23:55,930
a pointer

00:23:53,530 --> 00:23:59,440
there was a lot of debate on that about

00:23:55,930 --> 00:24:00,970
how that should be handled eventually

00:23:59,440 --> 00:24:02,050
didn't it up being the simplest way but

00:24:00,970 --> 00:24:04,720
before that there were a lot of

00:24:02,050 --> 00:24:08,170
proposals like well you only you you

00:24:04,720 --> 00:24:09,700
report % P you weren't about percent P

00:24:08,170 --> 00:24:11,230
and you only allow people to use it

00:24:09,700 --> 00:24:15,520
under these circumstances these

00:24:11,230 --> 00:24:19,090
modifiers finally just dealing with it

00:24:15,520 --> 00:24:20,740
took care of it but that was a choice

00:24:19,090 --> 00:24:26,440
yeah that was a choice in the developer

00:24:20,740 --> 00:24:28,090
experience of Miletus and we see a lot

00:24:26,440 --> 00:24:34,000
of compiler warnings how many how many

00:24:28,090 --> 00:24:40,530
people remember lint okay for those of

00:24:34,000 --> 00:24:43,780
you who are under 35 lint was W - W

00:24:40,530 --> 00:24:48,670
before there was a - W when the compiler

00:24:43,780 --> 00:24:53,160
just said yeah I can do that the more

00:24:48,670 --> 00:24:58,080
compiler warnings we generate slower

00:24:53,160 --> 00:25:01,210
things can be compiler warnings about

00:24:58,080 --> 00:25:03,310
casts and about data and about data

00:25:01,210 --> 00:25:05,860
structure uses really should be paid

00:25:03,310 --> 00:25:07,960
attention to yes I think and that's one

00:25:05,860 --> 00:25:10,330
of the big reasons why we have that

00:25:07,960 --> 00:25:11,800
policy in the Linux kernel that we don't

00:25:10,330 --> 00:25:13,540
introduce warnings and that we get rid

00:25:11,800 --> 00:25:17,320
of warnings because we put them there

00:25:13,540 --> 00:25:19,210
for a reason because the stuff that that

00:25:17,320 --> 00:25:21,720
you're being warned about really can be

00:25:19,210 --> 00:25:21,720
dangerous

00:25:23,850 --> 00:25:29,020
finally a hardier is subjective you know

00:25:26,620 --> 00:25:31,300
is it it's the kernel actually harder

00:25:29,020 --> 00:25:33,040
when I make these changes does it really

00:25:31,300 --> 00:25:36,670
make it harder for people to develop the

00:25:33,040 --> 00:25:39,730
kernel if I make these changes yes

00:25:36,670 --> 00:25:41,470
sometimes yes it yes we're making it

00:25:39,730 --> 00:25:47,050
harder here but are we making it more

00:25:41,470 --> 00:25:51,880
harder over here so the answer to the

00:25:47,050 --> 00:25:53,320
original question yes it is harder we

00:25:51,880 --> 00:25:57,280
are making it harder to develop the

00:25:53,320 --> 00:26:02,200
kernel but the community is buying into

00:25:57,280 --> 00:26:05,800
it I think before yeah 10 years ago they

00:26:02,200 --> 00:26:07,810
wouldn't have now why is this well part

00:26:05,800 --> 00:26:10,570
of it is that we're working

00:26:07,810 --> 00:26:14,620
open previous efforts that I won't

00:26:10,570 --> 00:26:18,700
mention by name that we're done off on

00:26:14,620 --> 00:26:24,030
the side in their own patch stream for

00:26:18,700 --> 00:26:28,420
for direct commercial exploitation

00:26:24,030 --> 00:26:31,330
weren't going in and the reason for it

00:26:28,420 --> 00:26:33,160
you know pretty clear is that that's not

00:26:31,330 --> 00:26:35,200
a community effort okay

00:26:33,160 --> 00:26:36,940
community effort makes a huge difference

00:26:35,200 --> 00:26:40,630
whether you're talking about performance

00:26:36,940 --> 00:26:42,040
security functionality support for

00:26:40,630 --> 00:26:45,010
obscure and bizarre and unnatural

00:26:42,040 --> 00:26:47,170
Hardware it doesn't matter the kernel

00:26:45,010 --> 00:26:50,190
the being involved in the community

00:26:47,170 --> 00:26:52,300
getting the feedback giving feedback

00:26:50,190 --> 00:26:57,810
working with everybody to make

00:26:52,300 --> 00:26:57,810
everything better gets you some slack

00:26:59,280 --> 00:27:05,170
the amount help we've been getting this

00:27:01,330 --> 00:27:07,240
has been awesome every now and then you

00:27:05,170 --> 00:27:08,890
think oh god I'm working so hard on it

00:27:07,240 --> 00:27:11,050
and then you look at the at the the

00:27:08,890 --> 00:27:14,890
people who have contributed to the work

00:27:11,050 --> 00:27:17,290
you're doing and you say oh I don't have

00:27:14,890 --> 00:27:19,150
no idea who this person is yeah they

00:27:17,290 --> 00:27:22,270
popped out of the woodwork and made this

00:27:19,150 --> 00:27:26,290
little comment here and all of a sudden

00:27:22,270 --> 00:27:29,380
my code runs in half the time I thank

00:27:26,290 --> 00:27:33,550
you yeah or I was going to do it this

00:27:29,380 --> 00:27:35,470
way we looked at you know looked at at

00:27:33,550 --> 00:27:37,570
the the 45 different interfaces that

00:27:35,470 --> 00:27:41,760
that involved and somebody said dude why

00:27:37,570 --> 00:27:41,760
don't you just do this and you say oh

00:27:42,300 --> 00:27:47,110
we're even better it's like oh yeah some

00:27:45,310 --> 00:27:49,510
but somebody else had a patch for that

00:27:47,110 --> 00:27:53,470
but then they got sick maybe you should

00:27:49,510 --> 00:27:55,480
look at that cool okay so again the

00:27:53,470 --> 00:27:57,940
amount of help were getting jesting

00:27:55,480 --> 00:28:01,900
incredible the community really is

00:27:57,940 --> 00:28:03,250
buying into this but at the same time

00:28:01,900 --> 00:28:07,030
we're still learning where the bounds

00:28:03,250 --> 00:28:10,480
are as case was saying earlier you know

00:28:07,030 --> 00:28:12,490
when he has commented earlier yeah when

00:28:10,480 --> 00:28:16,510
you do your pull requests you pull on

00:28:12,490 --> 00:28:19,710
your asbestos underwear and hold your

00:28:16,510 --> 00:28:19,710
breath until you get a response

00:28:19,980 --> 00:28:23,500
sometimes it goes

00:28:21,910 --> 00:28:31,660
goes in when you don't expect it to

00:28:23,500 --> 00:28:34,750
sometimes you get feedback but on the

00:28:31,660 --> 00:28:36,040
whole we're making the current making it

00:28:34,750 --> 00:28:39,880
a little bit harder for people to

00:28:36,040 --> 00:28:43,060
develop in general and we're making it

00:28:39,880 --> 00:28:46,120
easier for people to maintain because

00:28:43,060 --> 00:28:49,690
with fewer bugs fewer exploits people

00:28:46,120 --> 00:28:58,420
can go work on new stuff instead thank

00:28:49,690 --> 00:28:59,470
you so questions any questions just a

00:28:58,420 --> 00:29:02,800
small comment

00:28:59,470 --> 00:29:06,790
I wouldn't completely discard rust as a

00:29:02,800 --> 00:29:09,700
potential language to use in Linux and

00:29:06,790 --> 00:29:13,000
the reasons are that that it's it's

00:29:09,700 --> 00:29:16,090
probably works in an environment where

00:29:13,000 --> 00:29:17,800
where you have both C code and unrushed

00:29:16,090 --> 00:29:21,160
code I mean I mean it's using the

00:29:17,800 --> 00:29:28,330
Firefox that way so that so that

00:29:21,160 --> 00:29:32,050
portions are written across well and and

00:29:28,330 --> 00:29:34,870
generally speaking all the most kernel

00:29:32,050 --> 00:29:39,570
developers that I know love for us so so

00:29:34,870 --> 00:29:39,570
it has much stronger support in the

00:29:42,240 --> 00:29:45,940
quick poll how many kernel developers

00:29:45,490 --> 00:29:50,350
here

00:29:45,940 --> 00:29:54,940
no rust how many kernel developers do

00:29:50,350 --> 00:30:01,570
not know rust it looks like about three

00:29:54,940 --> 00:30:05,100
to one against next question oh and I'll

00:30:01,570 --> 00:30:05,100
be nicer to you than I was to your Co

00:30:06,720 --> 00:30:11,530
that's alright um

00:30:08,260 --> 00:30:13,780
gurney hunt your your comment about

00:30:11,530 --> 00:30:17,080
performance versus security is certainly

00:30:13,780 --> 00:30:19,060
true historically but at least on the

00:30:17,080 --> 00:30:21,550
hardware side of the house for which the

00:30:19,060 --> 00:30:26,170
kernel is the sibling of the hardware

00:30:21,550 --> 00:30:27,340
that's shifting because people are

00:30:26,170 --> 00:30:29,380
beginning to realize they've got to

00:30:27,340 --> 00:30:31,120
think about the security implications of

00:30:29,380 --> 00:30:33,280
their microarchitectures or they get

00:30:31,120 --> 00:30:35,670
screwed in the long run through

00:30:33,280 --> 00:30:35,670
exploitation

00:30:37,500 --> 00:30:43,179
so I don't yeah I ought to rethink or we

00:30:41,679 --> 00:30:44,740
ought to figure out how to balance this

00:30:43,179 --> 00:30:46,360
thing between performance and security

00:30:44,740 --> 00:30:50,320
rather than say one always wins and the

00:30:46,360 --> 00:30:57,970
other one always loses I'm trying to

00:30:50,320 --> 00:31:00,220
balance this off but I think that I am

00:30:57,970 --> 00:31:03,840
safer career-wise not to say anything

00:31:00,220 --> 00:31:03,840
about hardware development processes

00:31:05,429 --> 00:31:16,799
just within the kernel I think I I

00:31:13,240 --> 00:31:20,080
really think that we're still gonna see

00:31:16,799 --> 00:31:25,059
until somebody makes a big stink about

00:31:20,080 --> 00:31:27,580
well okay first off we're yeah we're

00:31:25,059 --> 00:31:30,640
getting better about being able to do

00:31:27,580 --> 00:31:33,940
hardening stuff proactive things even if

00:31:30,640 --> 00:31:36,880
there is some impact but we still have

00:31:33,940 --> 00:31:40,240
to come in and say here is the kind of

00:31:36,880 --> 00:31:42,340
exploit that we expect to have a have

00:31:40,240 --> 00:31:48,299
this is a problem regardless of what the

00:31:42,340 --> 00:31:51,520
hardware does okay and we are seeing a

00:31:48,299 --> 00:31:56,559
change in new hardware features for

00:31:51,520 --> 00:31:59,470
security that make more sense than what

00:31:56,559 --> 00:32:03,490
we've seen in the past so in the past

00:31:59,470 --> 00:32:07,059
we've seen you know wizzy hardware

00:32:03,490 --> 00:32:10,900
features intended to help security get

00:32:07,059 --> 00:32:15,850
introduced and people look at them and

00:32:10,900 --> 00:32:17,890
say gene huh how are we supposed to use

00:32:15,850 --> 00:32:20,280
that and that's like yeah ring

00:32:17,890 --> 00:32:23,169
architectures are perfect example you

00:32:20,280 --> 00:32:26,230
have a machine with 17 rings for

00:32:23,169 --> 00:32:28,240
security architecture and everybody

00:32:26,230 --> 00:32:31,570
looks and says huh cool rings are

00:32:28,240 --> 00:32:35,440
overing rings something else and the

00:32:31,570 --> 00:32:39,340
other the other example I Tom lion had a

00:32:35,440 --> 00:32:42,090
paper on this in the 1970s was about a

00:32:39,340 --> 00:32:44,830
chip that he got for his UNIX machine

00:32:42,090 --> 00:32:46,809
they were building a new a UNIX machine

00:32:44,830 --> 00:32:50,139
and

00:32:46,809 --> 00:32:53,559
it was a time a time chip and it would

00:32:50,139 --> 00:32:55,690
give you daylight savings time you know

00:32:53,559 --> 00:32:58,480
time in three different times I give all

00:32:55,690 --> 00:33:00,100
kinds of wonderful things and and they

00:32:58,480 --> 00:33:01,139
said well great but how do I make it

00:33:00,100 --> 00:33:04,480
give me seconds

00:33:01,139 --> 00:33:05,529
you know seconds since January 1st 1970

00:33:04,480 --> 00:33:12,940
because that's the only thing I care

00:33:05,529 --> 00:33:15,820
about so spiffy hardware anything about

00:33:12,940 --> 00:33:17,879
hardware I don't think we can count on

00:33:15,820 --> 00:33:17,879
that

00:33:19,440 --> 00:33:29,320
in the performance security argument I

00:33:26,009 --> 00:33:32,649
think in speaking to the balance between

00:33:29,320 --> 00:33:34,179
performance and security where there is

00:33:32,649 --> 00:33:36,580
a trade-off on that because there isn't

00:33:34,179 --> 00:33:37,899
always you can get security features in

00:33:36,580 --> 00:33:40,539
where there's no problem and everyone

00:33:37,899 --> 00:33:42,850
says that sounds great let's do it those

00:33:40,539 --> 00:33:46,600
are the easy wins but for the ones that

00:33:42,850 --> 00:33:49,269
are harder I've seen a shift in the

00:33:46,600 --> 00:33:51,929
culture in the kernel it used to be that

00:33:49,269 --> 00:33:55,600
nothing would win against performance

00:33:51,929 --> 00:33:57,990
and as you start demonstrating this long

00:33:55,600 --> 00:34:01,029
history of attacks against the kernel

00:33:57,990 --> 00:34:05,350
that has begun to move and I would say

00:34:01,029 --> 00:34:08,139
that there is a bigger shift in getting

00:34:05,350 --> 00:34:10,329
rid of bug classes like accepting a

00:34:08,139 --> 00:34:14,440
performance hit for killing a bug class

00:34:10,329 --> 00:34:18,639
is easier for maintainer x' to accept

00:34:14,440 --> 00:34:21,339
than killing exploitation classes

00:34:18,639 --> 00:34:23,740
because it's too far away from what

00:34:21,339 --> 00:34:25,990
people are sort of thinking about the

00:34:23,740 --> 00:34:27,909
old style was well why do we need to

00:34:25,990 --> 00:34:30,490
kill the bug class let's just fix the

00:34:27,909 --> 00:34:34,210
bugs I was like but that's not the right

00:34:30,490 --> 00:34:35,710
approach and I think the the needle has

00:34:34,210 --> 00:34:38,290
moved enough that we say okay I guess we

00:34:35,710 --> 00:34:40,300
can get rid of bug classes but why kill

00:34:38,290 --> 00:34:44,440
exploitation methods they need a whole

00:34:40,300 --> 00:34:46,000
series of bugs to make that work so I'm

00:34:44,440 --> 00:34:48,099
hoping there will be some balance point

00:34:46,000 --> 00:34:50,560
that we reach but I'm I'm still pushing

00:34:48,099 --> 00:34:54,220
to get as far towards killing everything

00:34:50,560 --> 00:34:57,220
as we can just my thought on the balance

00:34:54,220 --> 00:34:59,720
and how we'll reach it proposed to

00:34:57,220 --> 00:35:02,000
continue discussion continue

00:34:59,720 --> 00:35:04,310
you know a break which is now so let's

00:35:02,000 --> 00:35:06,650
break free break and just to note so if

00:35:04,310 --> 00:35:08,780
there is now board here for the birth of

00:35:06,650 --> 00:35:11,330
every session proposals on overture is

00:35:08,780 --> 00:35:13,849
already one plant on TPM and recipient

00:35:11,330 --> 00:35:16,840
genie in the afternoon so please if you

00:35:13,849 --> 00:35:19,910
have more put it just an abort variously

00:35:16,840 --> 00:35:24,310
writing device for yourself and let's

00:35:19,910 --> 00:35:24,310

YouTube URL: https://www.youtube.com/watch?v=ugzSacEuzUM


