Title: Overview and Recent Developments: Kernel Self-Protection Project - Kees Cook, Google
Publication date: 2018-10-26
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Overview and Recent Developments: Kernel Self-Protection Project - Kees Cook, Google 

This presentation will cover the year-in-review of the Kernel Self-Protection Project since the last Linux Security Summit NA 2017, including an overview of all the security defenses landed in kernels 4.14 through 4.18. Some highlights are vmapped stacks, structure randomization, SLUB freelist obfuscation, set_fs() checking, fast refcount_t protection, Page Table Isolation, usercopy whitelisting, VLA removals, and the stackleak plugin.

We'll also take a quick look at the evolution of kernel CVE lifetimes, find out what defenses are still under development, and note some areas where help is still needed. 

About Kees Cook
Kees Cook has been working with Free Software since 1994, and has been a Debian Developer since 2007. He is currently employed as a Linux kernel security engineer by Google, working on Android and and Chrome OS. From 2006 through 2011 he worked for Canonical as the Ubuntu Security Team's Tech Lead, and remains on the Ubuntu Technical Board. Before that, he worked as the lead sysadmin at OSDL, before it was the Linux Foundation. He has written various utilities including GOPchop and Sendpage, and contributes randomly to other projects including fun chunks of code in OpenSSH, Inkscape, Wine, MPlayer, and Wireshark. He's been spending most of his time lately focused on security features in the Linux Kernel.
Captions: 
	00:00:00,500 --> 00:00:07,919
Thanks so this has said this is about

00:00:06,120 --> 00:00:11,219
the kernel so protection project and

00:00:07,919 --> 00:00:14,490
sort of the umbrella for lots and lots

00:00:11,219 --> 00:00:15,990
of other people doing work if you want

00:00:14,490 --> 00:00:20,460
to follow along with slides there at

00:00:15,990 --> 00:00:24,480
that URL or they should be and I'll just

00:00:20,460 --> 00:00:26,300
dive in so for this presentation you

00:00:24,480 --> 00:00:28,410
know this is like security summit and

00:00:26,300 --> 00:00:31,980
context is kind of important so trying

00:00:28,410 --> 00:00:35,160
to define security from from my narrow

00:00:31,980 --> 00:00:37,230
view is more than just access control

00:00:35,160 --> 00:00:39,480
and it's more than attack surface

00:00:37,230 --> 00:00:41,190
reduction more than bug fixing more than

00:00:39,480 --> 00:00:44,730
protecting user space all of these

00:00:41,190 --> 00:00:47,340
things are important but uh this is

00:00:44,730 --> 00:00:51,960
about protecting the kernel from attack

00:00:47,340 --> 00:00:53,640
primarily and then of course you have to

00:00:51,960 --> 00:00:55,350
say well what am i what are we actually

00:00:53,640 --> 00:00:57,870
protecting what are we trying to secure

00:00:55,350 --> 00:01:00,300
what is the justification for the work

00:00:57,870 --> 00:01:04,129
that we're doing and we've you know

00:01:00,300 --> 00:01:07,380
we've got two billion Android devices

00:01:04,129 --> 00:01:09,570
there's now a Linux supercomputer on the

00:01:07,380 --> 00:01:11,850
international space station like we've

00:01:09,570 --> 00:01:15,530
got a lot of a lot of stuff running

00:01:11,850 --> 00:01:18,299
Linux as everyone here is well aware

00:01:15,530 --> 00:01:20,700
some scary notes on the two billion

00:01:18,299 --> 00:01:24,210
Android devices of course is that the

00:01:20,700 --> 00:01:27,680
vast majority of them are running a 3.10

00:01:24,210 --> 00:01:30,210
kernel which is extraordinarily old

00:01:27,680 --> 00:01:34,020
luckily for us 318 and is quickly

00:01:30,210 --> 00:01:38,220
catching up so we're still gone from

00:01:34,020 --> 00:01:40,439
ancient to very old but this this sort

00:01:38,220 --> 00:01:45,060
of underscores a problem with with bugs

00:01:40,439 --> 00:01:47,100
like the security problems that a kernel

00:01:45,060 --> 00:01:49,500
cell protection and tend to focus on our

00:01:47,100 --> 00:01:50,700
flaws that violate the the trust

00:01:49,500 --> 00:01:54,420
boundary between user space and kernel

00:01:50,700 --> 00:01:56,490
space so if you think a bug is you know

00:01:54,420 --> 00:01:59,250
the lifetime of a bug when it was

00:01:56,490 --> 00:02:03,479
introduced in 3.10 has it been fixed in

00:01:59,250 --> 00:02:05,100
your phone I don't know and then another

00:02:03,479 --> 00:02:08,190
question is well how is this our problem

00:02:05,100 --> 00:02:10,020
isn't that the vendors problem well in a

00:02:08,190 --> 00:02:11,709
way yes it's a vendors problem for not

00:02:10,020 --> 00:02:14,530
fixing your phone and their hand

00:02:11,709 --> 00:02:17,079
maybe we could have designed the kernel

00:02:14,530 --> 00:02:20,400
better to begin with so we have fewer of

00:02:17,079 --> 00:02:22,599
these or there's a smaller lifetime

00:02:20,400 --> 00:02:25,209
which then begs the question well what

00:02:22,599 --> 00:02:29,379
does bug life time look in the upstream

00:02:25,209 --> 00:02:31,599
kernel and John Corbett took a look at

00:02:29,379 --> 00:02:34,269
this in 2010 with the exact same

00:02:31,599 --> 00:02:36,519
question how long does it take us to

00:02:34,269 --> 00:02:41,620
find and fix a bug and so he went

00:02:36,519 --> 00:02:44,379
through a handful of of CBE's and I

00:02:41,620 --> 00:02:46,450
should say CVEs certainly don't

00:02:44,379 --> 00:02:49,239
represent all security flaws in the

00:02:46,450 --> 00:02:50,889
kernel but almost all CVEs are

00:02:49,239 --> 00:02:52,720
legitimate security flaws so at least

00:02:50,889 --> 00:02:57,129
you can have a minimum baseline to look

00:02:52,720 --> 00:02:59,650
at so John found in 2010 that there was

00:02:57,129 --> 00:03:01,810
an average lifetime between when a flaw

00:02:59,650 --> 00:03:05,169
was introduced in the kernel and to when

00:03:01,810 --> 00:03:10,239
it got fixed of about 5 years which is

00:03:05,169 --> 00:03:13,030
kind of a giant timespan and I went and

00:03:10,239 --> 00:03:15,879
looked later and I continually update

00:03:13,030 --> 00:03:19,359
this now looking through the event 2cv

00:03:15,879 --> 00:03:21,159
tracker includes when bugs are

00:03:19,359 --> 00:03:23,229
introduced as well as when they were

00:03:21,159 --> 00:03:25,449
fixed and the hard the hard work John

00:03:23,229 --> 00:03:27,099
did in 2010 was trying to figure out

00:03:25,449 --> 00:03:28,419
going with every CD and then trying to

00:03:27,099 --> 00:03:32,019
figure out when the flaw was introduced

00:03:28,419 --> 00:03:34,209
so I am cheating and leaning on the

00:03:32,019 --> 00:03:37,870
Ubuntu kernel and security teams who do

00:03:34,209 --> 00:03:40,509
that research now anyway I was starting

00:03:37,870 --> 00:03:42,129
to get worried with each presentation I

00:03:40,509 --> 00:03:44,530
made on this talking about bug life time

00:03:42,129 --> 00:03:47,079
that slowly the amount of time the

00:03:44,530 --> 00:03:50,500
average lifetime was creeping up and had

00:03:47,079 --> 00:03:52,449
reached 6 years though luckily it has

00:03:50,500 --> 00:03:55,329
started to come back a little bit and I

00:03:52,449 --> 00:03:58,419
can sort of show that in a hard to read

00:03:55,329 --> 00:04:00,340
graph you've got kernel version on one

00:03:58,419 --> 00:04:03,810
side so this is the past that's the

00:04:00,340 --> 00:04:06,189
beginning of git history the top is 419

00:04:03,810 --> 00:04:09,040
the red ones the three red ones over

00:04:06,189 --> 00:04:11,349
here really nasty Seavey's the critical

00:04:09,040 --> 00:04:12,849
CVS that we've had the rest are high and

00:04:11,349 --> 00:04:15,970
I left off the medium and the low

00:04:12,849 --> 00:04:18,699
because it's makes the graph heart even

00:04:15,970 --> 00:04:20,260
harder to read and then so the lifetime

00:04:18,699 --> 00:04:22,560
the bar the length of the bar or the

00:04:20,260 --> 00:04:24,330
bottom of the of each bar is

00:04:22,560 --> 00:04:25,800
when a flaw is introduced and then top

00:04:24,330 --> 00:04:28,560
of it is when it was fixed so you can

00:04:25,800 --> 00:04:31,800
see a bug with a long lifetime has a

00:04:28,560 --> 00:04:33,270
huge length and the problem was in doing

00:04:31,800 --> 00:04:35,160
this research you'd usually stop at

00:04:33,270 --> 00:04:37,650
beginning of get history and you go yeah

00:04:35,160 --> 00:04:39,330
it's been there forever so all these

00:04:37,650 --> 00:04:42,060
bars that go plummeting to the bottom

00:04:39,330 --> 00:04:43,800
here they were introduced at or before

00:04:42,060 --> 00:04:45,480
the beginning you'd get history and what

00:04:43,800 --> 00:04:48,210
I've actually been enjoying seeing is

00:04:45,480 --> 00:04:51,080
that we're starting to see the tails of

00:04:48,210 --> 00:04:54,060
these lifting up out of get history

00:04:51,080 --> 00:04:58,080
which I hope is true and not just an

00:04:54,060 --> 00:05:00,090
artifact of it being when it is now so

00:04:58,080 --> 00:05:01,950
I'm hopeful that this is we're actually

00:05:00,090 --> 00:05:03,419
making progress on here and we still

00:05:01,950 --> 00:05:06,780
have ones that are you know have a long

00:05:03,419 --> 00:05:10,669
tail but we're starting to see the

00:05:06,780 --> 00:05:13,800
averages coming down again which is nice

00:05:10,669 --> 00:05:16,919
and people ask me so what it's five

00:05:13,800 --> 00:05:19,169
years or six years or whatever no one

00:05:16,919 --> 00:05:22,400
saw it until right before it got fixed

00:05:19,169 --> 00:05:25,290
it's like it doesn't seem to be true

00:05:22,400 --> 00:05:28,410
people whose job it is to find these

00:05:25,290 --> 00:05:33,120
flaws and exploit them tend to find them

00:05:28,410 --> 00:05:36,450
well before the upstream community and

00:05:33,120 --> 00:05:39,210
we have proof of this of occasionally an

00:05:36,450 --> 00:05:42,060
attacker will boast about having founded

00:05:39,210 --> 00:05:44,070
forever ago and you know post something

00:05:42,060 --> 00:05:49,410
about how they've been using it haha

00:05:44,070 --> 00:05:51,360
we're all stupid okay but most attackers

00:05:49,410 --> 00:05:54,150
are not publicly talking about how they

00:05:51,360 --> 00:05:55,470
found their O'Day so it's it's a real

00:05:54,150 --> 00:06:00,030
issue but it's not one that we can gauge

00:05:55,470 --> 00:06:02,000
particularly well which you know I in

00:06:00,030 --> 00:06:06,990
some doom and gloom somewhere back in

00:06:02,000 --> 00:06:09,090
like 4.8 or 4.7 I said everyone here has

00:06:06,990 --> 00:06:11,580
a major flaw and you're in Linux and you

00:06:09,090 --> 00:06:12,900
don't know where it is and I generally

00:06:11,580 --> 00:06:14,550
say that and it turns out that was dirty

00:06:12,900 --> 00:06:16,470
cow and so we just don't know what's

00:06:14,550 --> 00:06:19,440
next right there's some other thing not

00:06:16,470 --> 00:06:22,560
yet on this graph and I'm I'd like to

00:06:19,440 --> 00:06:24,870
help us defend against them the good

00:06:22,560 --> 00:06:26,760
news and hopefully why I'm seeing the

00:06:24,870 --> 00:06:29,250
the graph getting smaller is that our

00:06:26,760 --> 00:06:31,860
bug fighting continues we're finding

00:06:29,250 --> 00:06:33,450
bugs we've got a lot of static checkers

00:06:31,860 --> 00:06:34,110
we've got a lot of dynamic checkers I

00:06:33,450 --> 00:06:35,850
include

00:06:34,110 --> 00:06:37,980
colonel in that itself because it starts

00:06:35,850 --> 00:06:40,470
looking for you know operational

00:06:37,980 --> 00:06:42,720
behaviors that it doesn't like and we're

00:06:40,470 --> 00:06:44,340
fixing them I always say when people

00:06:42,720 --> 00:06:46,470
don't believe me he said go ask Gregor

00:06:44,340 --> 00:06:49,380
Hartman how many patches are landing in

00:06:46,470 --> 00:06:50,430
the Linux kernels stable tree but

00:06:49,380 --> 00:06:54,080
instead of going and asking him in

00:06:50,430 --> 00:06:58,050
person I wouldn't look tough for 1478

00:06:54,080 --> 00:06:59,370
which is an LCS release there are seven

00:06:58,050 --> 00:07:03,180
thousand five hundred and twenty nine

00:06:59,370 --> 00:07:05,610
commits which is about 96 bug fixes per

00:07:03,180 --> 00:07:08,370
stable release and that as general bug

00:07:05,610 --> 00:07:11,700
fixes some subset of that our security

00:07:08,370 --> 00:07:13,230
are known to have security effects but

00:07:11,700 --> 00:07:14,790
it's possible that there are unknown

00:07:13,230 --> 00:07:19,650
security effects fixed in there and as

00:07:14,790 --> 00:07:21,360
well so we keep making bugs and they

00:07:19,650 --> 00:07:22,860
exist whether or not we know about them

00:07:21,360 --> 00:07:25,530
which is the real problem so

00:07:22,860 --> 00:07:28,200
whack-a-mole while important is not a

00:07:25,530 --> 00:07:31,830
particularly complete solution i'm

00:07:28,200 --> 00:07:36,030
konstantine talked about a analogy in

00:07:31,830 --> 00:07:39,770
the 2015 Lenni Security Summit using the

00:07:36,030 --> 00:07:42,900
1960s car industry as an example of

00:07:39,770 --> 00:07:44,550
things are designed to run well and I

00:07:42,900 --> 00:07:46,710
can talk about where drive down the

00:07:44,550 --> 00:07:48,300
highway and you're not getting sprayed

00:07:46,710 --> 00:07:49,680
in the face with gas and oil and

00:07:48,300 --> 00:07:52,710
whatever so it's great and that's sort

00:07:49,680 --> 00:07:54,870
of in a lot of ways where he was talking

00:07:52,710 --> 00:07:57,660
generally but even in Linux like things

00:07:54,870 --> 00:07:59,460
run really nicely for us but failure

00:07:57,660 --> 00:08:02,850
modes are not particularly well handled

00:07:59,460 --> 00:08:06,990
so we want to try and handle those those

00:08:02,850 --> 00:08:10,050
failure cases better with user space

00:08:06,990 --> 00:08:11,580
getting more and more locked down we're

00:08:10,050 --> 00:08:13,170
starting to see containers and other

00:08:11,580 --> 00:08:15,650
things painting quite a target on the

00:08:13,170 --> 00:08:18,290
kernel itself so attacking the boundary

00:08:15,650 --> 00:08:22,200
and then I always like to remind people

00:08:18,290 --> 00:08:23,610
hey lives depend on Linux it's it's a

00:08:22,200 --> 00:08:26,270
it's a little bit scary but you know

00:08:23,610 --> 00:08:28,950
we've seen cases where flaws get used by

00:08:26,270 --> 00:08:32,060
oppressive regimes to go hunting for

00:08:28,950 --> 00:08:34,140
dissidents and crazy things like that so

00:08:32,060 --> 00:08:35,910
well most of the time we just have to

00:08:34,140 --> 00:08:38,220
worry about you know phones and other

00:08:35,910 --> 00:08:41,100
other things sometimes those effects are

00:08:38,220 --> 00:08:43,979
far-reaching so I want to try to get the

00:08:41,100 --> 00:08:46,460
kernel into as defensive ' can get it

00:08:43,979 --> 00:08:46,460
reasonably

00:08:47,170 --> 00:08:54,950
so as I've said killing bugs is nice

00:08:50,890 --> 00:08:56,750
there is some truth to saying that bugs

00:08:54,950 --> 00:08:59,440
that security bugs are just normal bugs

00:08:56,750 --> 00:09:01,460
we should fix them like everything else

00:08:59,440 --> 00:09:03,290
that's sort of underscored by the fact

00:09:01,460 --> 00:09:05,270
that you know some security flaw may not

00:09:03,290 --> 00:09:07,970
affect me the way it affects someone

00:09:05,270 --> 00:09:10,190
else you know they're using NFS and I'm

00:09:07,970 --> 00:09:12,320
not and the flaw was an NFS stuff like

00:09:10,190 --> 00:09:15,290
that and we don't have a great idea

00:09:12,320 --> 00:09:17,300
where which necessarily which bugs

00:09:15,290 --> 00:09:20,000
attackers are gonna be using I mean some

00:09:17,300 --> 00:09:22,340
are way better than others and bugs

00:09:20,000 --> 00:09:24,500
might be an out of tree code where again

00:09:22,340 --> 00:09:25,100
there is a sort of an echo of not our

00:09:24,500 --> 00:09:27,530
problem

00:09:25,100 --> 00:09:30,320
but if we could actually provide an

00:09:27,530 --> 00:09:32,420
infrastructure that was safe those bugs

00:09:30,320 --> 00:09:35,990
wouldn't have a problem so the focus on

00:09:32,420 --> 00:09:38,840
focus is more on killing bug classes if

00:09:35,990 --> 00:09:41,030
we can stop an entire class of bugs from

00:09:38,840 --> 00:09:43,910
happening we just don't have to worry

00:09:41,030 --> 00:09:46,100
about it ever again and in fact if we

00:09:43,910 --> 00:09:48,740
provide an infrastructure that is you

00:09:46,100 --> 00:09:51,140
know that has a bug classroom moved out

00:09:48,740 --> 00:09:53,450
of tree code can't hit it a good example

00:09:51,140 --> 00:09:56,780
of this is with format strings with

00:09:53,450 --> 00:10:00,980
printf the % n if you get a format

00:09:56,780 --> 00:10:02,960
format string abuse of some kind the

00:10:00,980 --> 00:10:05,240
kernel doesn't support % ends so you

00:10:02,960 --> 00:10:07,280
can't turn a format string flaw into a

00:10:05,240 --> 00:10:10,100
right primitive and that means that's

00:10:07,280 --> 00:10:12,620
still true even if you have a million

00:10:10,100 --> 00:10:15,500
lines of out a tree code none of that

00:10:12,620 --> 00:10:19,730
code can call into the printf function

00:10:15,500 --> 00:10:21,410
and get it and and become a flaw but

00:10:19,730 --> 00:10:23,780
like bugs we're always introducing new

00:10:21,410 --> 00:10:26,510
classes of bugs so we can't kill all bug

00:10:23,780 --> 00:10:29,210
classes either killing exploitation is

00:10:26,510 --> 00:10:32,150
really great if we can just remove all

00:10:29,210 --> 00:10:34,660
of the systems that are in the kernel

00:10:32,150 --> 00:10:38,630
that provide attackers with easy to use

00:10:34,660 --> 00:10:42,440
ways to to do their attacks it would be

00:10:38,630 --> 00:10:44,930
nice to get rid of that the tricky part

00:10:42,440 --> 00:10:47,720
here of course comes with this caveat

00:10:44,930 --> 00:10:49,610
that sometimes when we do this work we

00:10:47,720 --> 00:10:53,000
make development in the kernel more

00:10:49,610 --> 00:10:55,130
difficult and so accepting the need for

00:10:53,000 --> 00:10:56,240
this is sort of accepting the

00:10:55,130 --> 00:10:57,540
understanding that there will be

00:10:56,240 --> 00:10:59,760
overhead in

00:10:57,540 --> 00:11:02,670
you know the going back to the car

00:10:59,760 --> 00:11:05,370
analogy if you've you know put a

00:11:02,670 --> 00:11:07,170
titanium bar in the door or whatever so

00:11:05,370 --> 00:11:09,810
that when you get hit on the side you're

00:11:07,170 --> 00:11:11,760
safer the person designing the window

00:11:09,810 --> 00:11:13,380
and all the electronics and that is kind

00:11:11,760 --> 00:11:15,000
of sitting there going well it would be

00:11:13,380 --> 00:11:16,580
a lot easier to do this if I didn't have

00:11:15,000 --> 00:11:19,920
this bar across the side of my door

00:11:16,580 --> 00:11:21,810
that's the same thing even in software

00:11:19,920 --> 00:11:25,710
development you know sometimes we

00:11:21,810 --> 00:11:29,100
complicate things in an effort to make

00:11:25,710 --> 00:11:32,120
them more secure and my hope is to

00:11:29,100 --> 00:11:37,500
convince people that it is ok to do that

00:11:32,120 --> 00:11:39,480
so as part of that I started the cell

00:11:37,500 --> 00:11:42,870
protection project to try and collect

00:11:39,480 --> 00:11:45,360
people into one place and centralized

00:11:42,870 --> 00:11:47,280
discussion and and give people a place

00:11:45,360 --> 00:11:50,340
to focus on things and what work there

00:11:47,280 --> 00:11:53,040
was to do and you know I can't do it

00:11:50,340 --> 00:11:54,930
even a fraction of it all on my own but

00:11:53,040 --> 00:11:57,000
there's a lot of people out there that

00:11:54,930 --> 00:11:59,550
were interested in this stuff so I tried

00:11:57,000 --> 00:12:01,700
to get them together in one place and I

00:11:59,550 --> 00:12:03,780
wanted to try and focus us initially on

00:12:01,700 --> 00:12:05,370
kernel cell protection there's a lot of

00:12:03,780 --> 00:12:07,410
work in the kernel to protect user space

00:12:05,370 --> 00:12:09,900
from itself and that's important work

00:12:07,410 --> 00:12:11,430
and I want to get to it and you know if

00:12:09,900 --> 00:12:14,400
someone's got time and interest to work

00:12:11,430 --> 00:12:16,290
on it sure let's do it but I have been

00:12:14,400 --> 00:12:18,750
trying to focus on the self protection

00:12:16,290 --> 00:12:21,170
bit just because I felt like the kernel

00:12:18,750 --> 00:12:24,900
was pretty far behind in that work I

00:12:21,170 --> 00:12:26,970
used to say you know we were slow and

00:12:24,900 --> 00:12:28,590
steady this is you know upstream kernel

00:12:26,970 --> 00:12:31,590
development it's not a it's not

00:12:28,590 --> 00:12:33,630
revolutionary its evolutionary but

00:12:31,590 --> 00:12:36,470
Alexander Popov and his slides on Monday

00:12:33,630 --> 00:12:41,070
had a significantly better motto and

00:12:36,470 --> 00:12:45,690
which is flexible and persistence which

00:12:41,070 --> 00:12:48,480
is much better so that's sort of the

00:12:45,690 --> 00:12:51,930
justification for why we're doing what

00:12:48,480 --> 00:12:54,660
we're doing I can go through what we

00:12:51,930 --> 00:12:59,010
have done in the last year any years

00:12:54,660 --> 00:13:01,920
worth of kernel releases so starting

00:12:59,010 --> 00:13:04,860
with 4:14 we've been doing reference

00:13:01,920 --> 00:13:07,200
counting protections which needed sort

00:13:04,860 --> 00:13:09,810
of opt in to replace use of Atomics with

00:13:07,200 --> 00:13:10,890
ref counters so we had a brief stall in

00:13:09,810 --> 00:13:12,570
4:14

00:13:10,890 --> 00:13:14,310
we're sort of bike shedding about how to

00:13:12,570 --> 00:13:17,630
document it and deal that I'm so only

00:13:14,310 --> 00:13:21,600
three went in but they're more coming a

00:13:17,630 --> 00:13:24,060
randomizations plugin from gr security

00:13:21,600 --> 00:13:25,950
got an automatic mode where if you see a

00:13:24,060 --> 00:13:29,070
structure with all function pointers you

00:13:25,950 --> 00:13:31,440
can randomize it got free list

00:13:29,070 --> 00:13:33,750
obfuscation so as an attacker if you

00:13:31,440 --> 00:13:36,510
manage to get an overflow into the heap

00:13:33,750 --> 00:13:40,290
free list area this makes the attack

00:13:36,510 --> 00:13:42,810
much more unreliable struck we plug in

00:13:40,290 --> 00:13:45,990
for automatically initializing variables

00:13:42,810 --> 00:13:48,269
that haven't been initialized when they

00:13:45,990 --> 00:13:50,610
are passed into a function for example

00:13:48,269 --> 00:13:52,500
if you specify some buffer and you pass

00:13:50,610 --> 00:13:54,420
it to a device driver that is supposed

00:13:52,500 --> 00:13:56,610
to fill it in and then you copy it out

00:13:54,420 --> 00:13:59,070
to user space well if the driver didn't

00:13:56,610 --> 00:14:01,350
do it right then you're just copying

00:13:59,070 --> 00:14:02,820
kernel memory out into it so this would

00:14:01,350 --> 00:14:07,140
look for all the pass by reference

00:14:02,820 --> 00:14:09,149
variables and initialize them first via

00:14:07,140 --> 00:14:12,769
map stack similar to what we had on x86

00:14:09,149 --> 00:14:16,260
landed in arm 64 and that gets us

00:14:12,769 --> 00:14:17,970
unallocated pages between stacks and the

00:14:16,260 --> 00:14:22,050
kernels so if you try to run off the end

00:14:17,970 --> 00:14:24,510
of the stack it will fault solves a

00:14:22,050 --> 00:14:27,779
bunch of things another issue was set if

00:14:24,510 --> 00:14:28,980
s was specifying how you could copy

00:14:27,779 --> 00:14:31,470
memory in and out in and out of the

00:14:28,980 --> 00:14:33,510
kernel would check the boundary

00:14:31,470 --> 00:14:35,610
condition and said if s was would move

00:14:33,510 --> 00:14:38,040
it to include all of kernel memory for

00:14:35,610 --> 00:14:40,290
doing internal work and this has been a

00:14:38,040 --> 00:14:42,089
source of bugs in the past and now we

00:14:40,290 --> 00:14:45,120
just sort of check on return to user

00:14:42,089 --> 00:14:47,930
space did we forget to reset it so we

00:14:45,120 --> 00:14:51,120
got coverage at a number of

00:14:47,930 --> 00:14:52,140
architectures so we've picked up speed

00:14:51,120 --> 00:14:56,220
again with the reference count

00:14:52,140 --> 00:14:58,980
conversions for 15 to jog your memory

00:14:56,220 --> 00:15:03,079
was when we got Specter in meltdown

00:14:58,980 --> 00:15:06,240
protections with PTI and rep lean

00:15:03,079 --> 00:15:12,060
replaced a whole infrastructure in the

00:15:06,240 --> 00:15:14,160
kernel timer list was we changed the

00:15:12,060 --> 00:15:15,660
implementation this doesn't affect the

00:15:14,160 --> 00:15:17,850
kernel at all like everything is

00:15:15,660 --> 00:15:20,520
operating almost exactly as how how it

00:15:17,850 --> 00:15:22,440
was before but the removal of this field

00:15:20,520 --> 00:15:23,449
out of the structure removes a target

00:15:22,440 --> 00:15:26,049
for attackers

00:15:23,449 --> 00:15:29,540
that was being used in several examples

00:15:26,049 --> 00:15:31,459
in act in real life exploits this is a

00:15:29,540 --> 00:15:33,290
good example of the kernel is just

00:15:31,459 --> 00:15:35,839
designed in a way that made an attack

00:15:33,290 --> 00:15:38,059
easier and didn't have didn't matter to

00:15:35,839 --> 00:15:39,319
the kernel all we had to do was redesign

00:15:38,059 --> 00:15:43,119
things a little bit and everything was

00:15:39,319 --> 00:15:46,069
in fact simpler and there was an account

00:15:43,119 --> 00:15:47,299
so we gained fast reference counter

00:15:46,069 --> 00:15:49,009
overflow protection so the ref count

00:15:47,299 --> 00:15:50,629
protections that were going in had it

00:15:49,009 --> 00:15:52,999
had two implementations

00:15:50,629 --> 00:15:56,119
this was the faster one based on what gr

00:15:52,999 --> 00:15:58,100
security had been doing and in a

00:15:56,119 --> 00:16:01,069
surprise move move

00:15:58,100 --> 00:16:03,009
leanness decided that percent P which

00:16:01,069 --> 00:16:05,720
prints out pointers to D message and

00:16:03,009 --> 00:16:07,279
sisyphus files and other things should

00:16:05,720 --> 00:16:08,359
just never actually print out pointers

00:16:07,279 --> 00:16:10,100
anymore

00:16:08,359 --> 00:16:11,569
this was certainly on my list of things

00:16:10,100 --> 00:16:13,850
to do but was not when I was going to

00:16:11,569 --> 00:16:17,869
try to fight for for quite some time and

00:16:13,850 --> 00:16:19,639
he decided that we should not be info

00:16:17,869 --> 00:16:21,769
leaking quite as hard as the kernel was

00:16:19,639 --> 00:16:25,519
so now % PE just prints out a hashed

00:16:21,769 --> 00:16:27,169
version so you can compare two values as

00:16:25,519 --> 00:16:27,699
being the same but you have no idea what

00:16:27,169 --> 00:16:30,230
it means

00:16:27,699 --> 00:16:31,970
so it still work for debugging but it

00:16:30,230 --> 00:16:36,169
would be significantly less useful as an

00:16:31,970 --> 00:16:41,059
attacker more ref count conversions we

00:16:36,169 --> 00:16:44,629
got PTI on 164 we had harden excuse me

00:16:41,059 --> 00:16:48,289
harden user copy already ported from gr

00:16:44,629 --> 00:16:50,600
security but this and that kept we

00:16:48,289 --> 00:16:51,949
couldn't copy things that were outside

00:16:50,600 --> 00:16:54,379
of the stack or outside of a slab

00:16:51,949 --> 00:16:55,879
allocation out of heat memory and the

00:16:54,379 --> 00:16:57,919
white listing actually narrows that even

00:16:55,879 --> 00:17:01,220
further where you say I only want this

00:16:57,919 --> 00:17:02,929
specific field out of the larger slab

00:17:01,220 --> 00:17:05,809
allocation to be copied in and out of

00:17:02,929 --> 00:17:08,689
user space so that narrowed how much

00:17:05,809 --> 00:17:10,549
could how much of the kernels memory

00:17:08,689 --> 00:17:14,329
would be exposed to use your copy flaws

00:17:10,549 --> 00:17:17,000
when those bugs happen and around here

00:17:14,329 --> 00:17:18,919
was also when the blue born attack which

00:17:17,000 --> 00:17:22,399
was a blue tooth attack against user

00:17:18,919 --> 00:17:25,220
space and kernel came out and it was a

00:17:22,399 --> 00:17:28,309
straight stack overflow you know a

00:17:25,220 --> 00:17:30,380
solved problem and the blue born right

00:17:28,309 --> 00:17:32,000
up says yep here's how I attacked it on

00:17:30,380 --> 00:17:34,990
all these devices that just didn't have

00:17:32,000 --> 00:17:34,990
stack protector enabled

00:17:35,340 --> 00:17:38,910
so in looking at that of course it was

00:17:37,200 --> 00:17:40,380
once again sort of an infrastructure

00:17:38,910 --> 00:17:43,560
problem in the kernel the kernels build

00:17:40,380 --> 00:17:45,780
system didn't understand how to query

00:17:43,560 --> 00:17:47,400
what compiler was being used early

00:17:45,780 --> 00:17:49,500
enough that you could determine what

00:17:47,400 --> 00:17:50,910
sort of protections you could get so the

00:17:49,500 --> 00:17:53,640
default was the build kernels with the

00:17:50,910 --> 00:17:56,160
stack protector off but that's insane

00:17:53,640 --> 00:17:58,200
so this sort of fixed it it got fixed

00:17:56,160 --> 00:18:00,630
better in a following version but now

00:17:58,200 --> 00:18:01,860
when you build the kernel you just get

00:18:00,630 --> 00:18:03,720
the sack protector if your compiler

00:18:01,860 --> 00:18:04,260
supports it or you can specifically turn

00:18:03,720 --> 00:18:07,520
it off

00:18:04,260 --> 00:18:10,230
so going from default off the default on

00:18:07,520 --> 00:18:11,970
was simply a matter of fixing all the

00:18:10,230 --> 00:18:13,650
logic and dealing with the weird bugs

00:18:11,970 --> 00:18:15,030
about compilers and build systems and

00:18:13,650 --> 00:18:16,350
everything else but that's you know

00:18:15,030 --> 00:18:18,090
doesn't change anything about the

00:18:16,350 --> 00:18:23,610
kernels in turn the kernels internal

00:18:18,090 --> 00:18:25,920
systems just the build system really 417

00:18:23,610 --> 00:18:29,160
we started VLA removal so

00:18:25,920 --> 00:18:30,720
variable-length arrays lead to a number

00:18:29,160 --> 00:18:32,880
of problems on the stack we could have

00:18:30,720 --> 00:18:35,700
stack exhaustion problems they're also

00:18:32,880 --> 00:18:38,310
not very they they have a poor

00:18:35,700 --> 00:18:39,990
performance characteristics so we

00:18:38,310 --> 00:18:43,440
started grinding through lots and lots

00:18:39,990 --> 00:18:46,820
of relays to remove which were difficult

00:18:43,440 --> 00:18:50,430
to deal with in certain situations

00:18:46,820 --> 00:18:52,800
clearing the stack on fork when you

00:18:50,430 --> 00:18:55,460
would start a new process your stack

00:18:52,800 --> 00:18:58,170
would be allocated from memory and

00:18:55,460 --> 00:19:00,870
wouldn't be cleared so if you had an

00:18:58,170 --> 00:19:02,250
info leak especially for something

00:19:00,870 --> 00:19:04,170
that's deep in the stack and you could

00:19:02,250 --> 00:19:05,280
arrange for an info leak out of

00:19:04,170 --> 00:19:07,830
somewhere on the stack you could see

00:19:05,280 --> 00:19:09,000
what was on in some location in the

00:19:07,830 --> 00:19:11,730
stack earlier but it didn't make any

00:19:09,000 --> 00:19:14,460
sense since it would be much easier to

00:19:11,730 --> 00:19:22,200
just wipe the stack when you initially

00:19:14,460 --> 00:19:25,290
fork kernel and this was this existed

00:19:22,200 --> 00:19:28,620
before but it was it was behind a debug

00:19:25,290 --> 00:19:30,030
flag and people said well this is

00:19:28,620 --> 00:19:32,250
clearly going to be expensive

00:19:30,030 --> 00:19:36,060
every time we fork we're gonna write

00:19:32,250 --> 00:19:37,500
zeroes to multiple pages in the kernel

00:19:36,060 --> 00:19:39,330
memory that's too expensive to turn on

00:19:37,500 --> 00:19:43,170
by default so I turned it on by default

00:19:39,330 --> 00:19:44,910
and it sped things up it seems it looks

00:19:43,170 --> 00:19:46,740
like that may have just been cash

00:19:44,910 --> 00:19:48,179
priming like you brought in all this

00:19:46,740 --> 00:19:50,009
memory into the cache

00:19:48,179 --> 00:19:52,470
a part of memory that you're absolutely

00:19:50,009 --> 00:19:55,440
right akan stantly as you're running and

00:19:52,470 --> 00:19:57,179
doing things so maybe my performance

00:19:55,440 --> 00:19:59,879
metrics are terrible I don't know but it

00:19:57,179 --> 00:20:02,039
looked like a slight win so that's nice

00:19:59,879 --> 00:20:06,240
I really really like security fixes that

00:20:02,039 --> 00:20:08,909
improve performance more fixes on

00:20:06,240 --> 00:20:12,240
dealing with our limit stack our limit

00:20:08,909 --> 00:20:16,049
on exec and how stack is laid out as a

00:20:12,240 --> 00:20:18,450
part of the stack clash fixes also

00:20:16,049 --> 00:20:21,720
related stat clash was a map fixed no

00:20:18,450 --> 00:20:23,340
replace so from the kernel uses is this

00:20:21,720 --> 00:20:25,769
internally when laying out an elf file

00:20:23,340 --> 00:20:27,809
when it execs but you can also get up

00:20:25,769 --> 00:20:31,320
this from user space normally when you

00:20:27,809 --> 00:20:33,659
say map fixed you say I want to put you

00:20:31,320 --> 00:20:37,409
know this in one specific location in

00:20:33,659 --> 00:20:39,299
memory and there wasn't a way cleanly to

00:20:37,409 --> 00:20:42,119
say but don't do it if there's already

00:20:39,299 --> 00:20:46,289
something there like don't overwrite an

00:20:42,119 --> 00:20:49,320
existing allocation or you know memory

00:20:46,289 --> 00:20:51,090
out VMA and this was a problem when it

00:20:49,320 --> 00:20:53,249
within the elf loader if you would get

00:20:51,090 --> 00:20:55,279
your libraries or you know other parts

00:20:53,249 --> 00:20:57,419
really close to the stack you just start

00:20:55,279 --> 00:20:59,850
clobbering the existing VM a and you'd

00:20:57,419 --> 00:21:01,679
run things together so this solves that

00:20:59,850 --> 00:21:03,330
problem where you if you get into the

00:21:01,679 --> 00:21:06,119
situation where you somehow convinced

00:21:03,330 --> 00:21:08,070
the machine to misbehave you know get

00:21:06,119 --> 00:21:13,019
the vmas overlap it will actually fail

00:21:08,070 --> 00:21:17,369
now an interesting thing for 4:17 also

00:21:13,019 --> 00:21:20,730
was on sis call entry one of the ways to

00:21:17,369 --> 00:21:24,480
do strange things with speculation and

00:21:20,730 --> 00:21:27,389
cache stuff was you could actually find

00:21:24,480 --> 00:21:30,119
gadgets that we're using registers that

00:21:27,389 --> 00:21:31,980
weren't part of the SIS call but as the

00:21:30,119 --> 00:21:34,710
attacker you could populate the register

00:21:31,980 --> 00:21:36,779
contents from user space make a sis call

00:21:34,710 --> 00:21:39,119
and that register would sort of walk

00:21:36,779 --> 00:21:41,789
along into the kernel and be available

00:21:39,119 --> 00:21:44,519
for speculation gadgets and the idea

00:21:41,789 --> 00:21:46,039
with this was you effectively just clear

00:21:44,519 --> 00:21:49,919
all the registers that weren't used

00:21:46,039 --> 00:21:52,529
during a during sis call and XOR in a

00:21:49,919 --> 00:21:54,809
register by itself is incredibly fast so

00:21:52,529 --> 00:21:58,259
no measure performance change on this

00:21:54,809 --> 00:22:00,300
and just kills that whole side of a way

00:21:58,259 --> 00:22:02,830
to do speculation gadget manipulation

00:22:00,300 --> 00:22:09,910
and we got more speculation control

00:22:02,830 --> 00:22:13,950
fixes SSB 4:18 continue grinding away on

00:22:09,910 --> 00:22:15,700
via lays there's a whole class of

00:22:13,950 --> 00:22:20,140
multiplication overflows of memory

00:22:15,700 --> 00:22:21,910
allocators where you try to allocate so

00:22:20,140 --> 00:22:23,620
large a memory that the math wraps

00:22:21,910 --> 00:22:24,940
around you get a very small allocation

00:22:23,620 --> 00:22:26,980
than you do then your overflows and

00:22:24,940 --> 00:22:29,740
other things so we added a bunch of

00:22:26,980 --> 00:22:33,360
overflow detection helpers and did a big

00:22:29,740 --> 00:22:36,340
pass on allocators doing open coded

00:22:33,360 --> 00:22:40,320
multiplication we certainly did didn't

00:22:36,340 --> 00:22:42,850
fix all of them but we did have a couple

00:22:40,320 --> 00:22:45,720
reports come in to security at

00:22:42,850 --> 00:22:48,550
kernel.org about you know exploitable

00:22:45,720 --> 00:22:50,260
overflows like this that overlapped with

00:22:48,550 --> 00:22:52,030
the fixes that were going in so it was a

00:22:50,260 --> 00:22:54,130
nice validation of this massive tree

00:22:52,030 --> 00:22:55,650
wide change we were in fact catching

00:22:54,130 --> 00:23:01,300
real bugs that other people were finding

00:22:55,650 --> 00:23:04,150
then we got SSB on arm 64 for nineteen

00:23:01,300 --> 00:23:06,880
thirty three more relays removed all the

00:23:04,150 --> 00:23:10,600
rest are gonna be gone and for twenty we

00:23:06,880 --> 00:23:13,840
got them all done so we had add subtract

00:23:10,600 --> 00:23:15,910
multiply and divide overflow helpers we

00:23:13,840 --> 00:23:18,820
didn't have shift shift left overflow

00:23:15,910 --> 00:23:21,910
helpers that got added or helper that

00:23:18,820 --> 00:23:25,060
got added before nineteen on the Elven

00:23:21,910 --> 00:23:29,800
TF defenses you can read up on that

00:23:25,060 --> 00:23:32,980
those are fun and this is a user space

00:23:29,800 --> 00:23:35,830
defense which was in temp we solved

00:23:32,980 --> 00:23:39,180
quite some time ago now the temp races

00:23:35,830 --> 00:23:42,070
with symlinks and hard links races also

00:23:39,180 --> 00:23:44,680
but this meant that we we killed a large

00:23:42,070 --> 00:23:47,440
class of bugs about temp files following

00:23:44,680 --> 00:23:50,080
symlinks by not allowing the sim linking

00:23:47,440 --> 00:23:52,120
following to happen if the users didn't

00:23:50,080 --> 00:23:54,760
match but this shifted to finding

00:23:52,120 --> 00:23:57,780
software that would open a file in temp

00:23:54,760 --> 00:24:00,220
with oak create but without exclusive

00:23:57,780 --> 00:24:01,960
which meant that it would happily open

00:24:00,220 --> 00:24:04,540
someone else's file that they had made

00:24:01,960 --> 00:24:05,680
world writable for you and then you your

00:24:04,540 --> 00:24:07,450
program would write all sorts of

00:24:05,680 --> 00:24:09,220
information into it or however you were

00:24:07,450 --> 00:24:11,290
using it and the person who so helpfully

00:24:09,220 --> 00:24:13,940
created the file for you could then read

00:24:11,290 --> 00:24:15,679
it so this effectively

00:24:13,940 --> 00:24:17,120
says it has a similar rules to the

00:24:15,679 --> 00:24:19,669
symlink restrictions that have been in

00:24:17,120 --> 00:24:22,879
for a while it's a it's sort of an

00:24:19,669 --> 00:24:25,970
implicit Oh exclusive if the users don't

00:24:22,879 --> 00:24:28,279
match treat it as if you had asked for

00:24:25,970 --> 00:24:30,409
it to be exclusive when you're in a temp

00:24:28,279 --> 00:24:32,690
directory in a sticky writable world

00:24:30,409 --> 00:24:35,600
writable directories and this should

00:24:32,690 --> 00:24:40,370
hopefully close the last of the temp

00:24:35,600 --> 00:24:44,980
file races that still crop up and we got

00:24:40,370 --> 00:24:49,639
the unused register clearing arm 64 so

00:24:44,980 --> 00:24:51,230
coming for 420 as far as I can see all

00:24:49,639 --> 00:24:54,289
the VLA czar going to be removed and

00:24:51,230 --> 00:24:57,200
we're gonna add tend to add warnings not

00:24:54,289 --> 00:24:58,639
errors to the kernel build you know

00:24:57,200 --> 00:25:01,309
maybe in a couple years we can turn it

00:24:58,639 --> 00:25:03,470
up to a full error but adding warning

00:25:01,309 --> 00:25:05,210
weren't on VLA because we strive to make

00:25:03,470 --> 00:25:07,549
sure that the kernel builds without

00:25:05,210 --> 00:25:10,580
warnings this will keep Nuvi Lai's from

00:25:07,549 --> 00:25:13,730
appearing I'll be good and fingers

00:25:10,580 --> 00:25:15,950
crossed the stack leak plugin Alexander

00:25:13,730 --> 00:25:19,360
Popov has been working on imported from

00:25:15,950 --> 00:25:21,350
gr security will land for x86 and arm 64

00:25:19,360 --> 00:25:26,360
Venus has yelled at us several times

00:25:21,350 --> 00:25:29,000
about these and past pull attempts we

00:25:26,360 --> 00:25:31,809
think we're good again so hopefully

00:25:29,000 --> 00:25:34,639
that'll go in that will that's that's a

00:25:31,809 --> 00:25:37,429
poisoning mechanism we're on sis call

00:25:34,639 --> 00:25:40,000
exit whatever portion of the stack had

00:25:37,429 --> 00:25:43,429
but kernel stack had been used gets

00:25:40,000 --> 00:25:45,679
wiped with a Poisson value the idea

00:25:43,429 --> 00:25:48,190
being that when you come back in for

00:25:45,679 --> 00:25:50,480
your next test call uninitialized values

00:25:48,190 --> 00:25:53,240
are no longer under control of whatever

00:25:50,480 --> 00:25:54,559
the prior sis call contents set up on

00:25:53,240 --> 00:25:56,419
the stack they've all been wiped out and

00:25:54,559 --> 00:25:58,759
so your uninitialized values are now

00:25:56,419 --> 00:26:01,340
initialized with a known poison value

00:25:58,759 --> 00:26:04,220
this sort of matches the poisoning that

00:26:01,340 --> 00:26:08,210
we've had on heap and the buddy

00:26:04,220 --> 00:26:12,529
allocator for a while and then we've got

00:26:08,210 --> 00:26:16,220
lots and lots of soon coming and not so

00:26:12,529 --> 00:26:17,990
soon coming features talked a bunch

00:26:16,220 --> 00:26:19,750
about the uninitialized variables we're

00:26:17,990 --> 00:26:22,369
gonna see that from the compiler side

00:26:19,750 --> 00:26:23,600
integer overflow detection this exists

00:26:22,369 --> 00:26:26,629
in the

00:26:23,600 --> 00:26:28,879
the colonel address sanitizer the I mean

00:26:26,629 --> 00:26:31,429
one of its sort of cousins the undefined

00:26:28,879 --> 00:26:33,649
behavior sanitizer finding and getting

00:26:31,429 --> 00:26:35,509
rid of those linked time optimizations

00:26:33,649 --> 00:26:37,549
so that we can get a view of the entire

00:26:35,509 --> 00:26:40,369
kernel billed at once so you can do

00:26:37,549 --> 00:26:43,129
things like control flow integrity which

00:26:40,369 --> 00:26:46,809
is now in the pixel three phones so

00:26:43,129 --> 00:26:49,100
forward edge CFI protecting against

00:26:46,809 --> 00:26:54,200
function pointers function pointer over

00:26:49,100 --> 00:26:56,299
rights things like that Gustav has been

00:26:54,200 --> 00:26:57,859
working on getting the switch fall

00:26:56,299 --> 00:26:59,690
through markings finished so we can turn

00:26:57,859 --> 00:27:02,470
on no implicit fall through so we don't

00:26:59,690 --> 00:27:05,299
end up with busted switch statements

00:27:02,470 --> 00:27:08,779
getting a per task stack canary on non

00:27:05,299 --> 00:27:10,700
x86 and those six pieces are all very

00:27:08,779 --> 00:27:11,659
compiler dependent you'll notice we've

00:27:10,700 --> 00:27:13,249
got a whole bunch of other things that

00:27:11,659 --> 00:27:15,919
are less dependent on compilers and

00:27:13,249 --> 00:27:17,779
somewhat dependent on hardware and other

00:27:15,919 --> 00:27:20,899
research so like memory tagging is

00:27:17,779 --> 00:27:22,479
hardware support that leads to string

00:27:20,899 --> 00:27:25,929
and mem copy sized allocation checks

00:27:22,479 --> 00:27:28,940
exclusive page frame owner tends to be a

00:27:25,929 --> 00:27:31,129
mostly issue of performance but that

00:27:28,940 --> 00:27:33,830
will solve an entire class of exploits

00:27:31,129 --> 00:27:36,139
where while you can't execute user space

00:27:33,830 --> 00:27:39,139
memory from the kernel in most hardware

00:27:36,139 --> 00:27:42,109
you can still execute the mapping of the

00:27:39,139 --> 00:27:44,749
user space memory in the kernels memory

00:27:42,109 --> 00:27:47,659
only if you know the physical location

00:27:44,749 --> 00:27:49,389
of it but that's a real attack as well

00:27:47,659 --> 00:27:51,889
getting some fine grained ksl our

00:27:49,389 --> 00:27:54,409
estimate emulation anyway you can read

00:27:51,889 --> 00:27:57,049
the whole list here but if anything in

00:27:54,409 --> 00:27:58,700
here is interesting to you please join

00:27:57,049 --> 00:28:00,799
us we're not done with the any of these

00:27:58,700 --> 00:28:05,210
it's nice to get other people's help

00:28:00,799 --> 00:28:07,129
even if it's testing documentation any

00:28:05,210 --> 00:28:09,889
piece anything you're interested in or

00:28:07,129 --> 00:28:11,869
or just telling us we're doing it wrong

00:28:09,889 --> 00:28:16,279
some people can show up and do that too

00:28:11,869 --> 00:28:18,320
we get a lot of that so our challenges

00:28:16,279 --> 00:28:19,669
really are the same challenges I've

00:28:18,320 --> 00:28:23,539
talked about before we've got a lot of

00:28:19,669 --> 00:28:25,309
sort of cultural conservatism you know

00:28:23,539 --> 00:28:27,859
please leave the code alone it's good

00:28:25,309 --> 00:28:30,229
enough or and people wanting to not

00:28:27,859 --> 00:28:32,899
accept the responsibility of oh yeah but

00:28:30,229 --> 00:28:35,340
that tree you know that that phone has

00:28:32,899 --> 00:28:37,470
lots of out of tree code running on

00:28:35,340 --> 00:28:39,120
but it's still Linux a sacrifice of

00:28:37,470 --> 00:28:41,370
needing to deal with the new overheads

00:28:39,120 --> 00:28:43,320
and the patience of both dealing with

00:28:41,370 --> 00:28:45,990
how long it sometimes takes to convince

00:28:43,320 --> 00:28:48,030
people or get stuff in and vice-versa

00:28:45,990 --> 00:28:50,010
and then there's the technical

00:28:48,030 --> 00:28:51,630
complexity you know innovating in spaces

00:28:50,010 --> 00:28:54,630
where there was no obvious solution and

00:28:51,630 --> 00:28:56,580
collaborating with with people so yeah

00:28:54,630 --> 00:28:59,340
we just need developers or viewers

00:28:56,580 --> 00:29:07,200
testers back Porter's whatever you've

00:28:59,340 --> 00:29:08,970
got you can reach me there those the

00:29:07,200 --> 00:29:11,780
slides again if you want to read more

00:29:08,970 --> 00:29:14,310
about KSP pee that's the wiki link and

00:29:11,780 --> 00:29:17,010
join our mailing list and say hi and if

00:29:14,310 --> 00:29:30,030
you want to hang out on IRC there's

00:29:17,010 --> 00:29:31,830
Linux hardened on freenode so there's

00:29:30,030 --> 00:29:35,400
another major operating system out there

00:29:31,830 --> 00:29:37,650
that uses a hypervisor to kind of offer

00:29:35,400 --> 00:29:39,780
kernel protection integrity do you see

00:29:37,650 --> 00:29:42,300
that as being in linux is future at all

00:29:39,780 --> 00:29:43,950
is that the hypervisor magic bullet I do

00:29:42,300 --> 00:29:48,030
that's the piper vote this is the

00:29:43,950 --> 00:29:51,300
hypervisor magic bullet so one of the

00:29:48,030 --> 00:29:53,310
things I that we're getting to a point

00:29:51,300 --> 00:29:57,050
where people really making a lot more

00:29:53,310 --> 00:29:57,050
noise about I'm saying went too far

00:29:57,500 --> 00:30:01,610
wanting to be able to sort of check the

00:29:59,910 --> 00:30:03,510
state of the kernel from somewhere else

00:30:01,610 --> 00:30:05,940
because they want to get another

00:30:03,510 --> 00:30:10,740
boundary and this and things like the

00:30:05,940 --> 00:30:13,470
Samsung Knox had will check the the UID

00:30:10,740 --> 00:30:16,560
of the cred process from above they keep

00:30:13,470 --> 00:30:19,320
it mapped out and getting a general way

00:30:16,560 --> 00:30:21,690
to do that like so we can declare I want

00:30:19,320 --> 00:30:23,280
to protect these things from from its

00:30:21,690 --> 00:30:25,560
you know protect these things in the

00:30:23,280 --> 00:30:26,700
kernel from the kernel so we can give it

00:30:25,560 --> 00:30:28,860
to the hypervisor to take over that

00:30:26,700 --> 00:30:31,650
responsibility and while there are

00:30:28,860 --> 00:30:33,000
separate pieces for doing this in other

00:30:31,650 --> 00:30:35,700
Forks and other stuff there isn't a

00:30:33,000 --> 00:30:37,140
common way to get this communicated to

00:30:35,700 --> 00:30:40,230
the hypervisor and I would like to see

00:30:37,140 --> 00:30:42,540
that no one has really stepped forward

00:30:40,230 --> 00:30:44,940
to work on it and that's not been

00:30:42,540 --> 00:30:46,630
something that's been driven up my to-do

00:30:44,940 --> 00:30:55,530
list necessarily but I'm

00:30:46,630 --> 00:30:55,530
I'm all for it questions

00:30:59,140 --> 00:31:09,320
hi thank you key in case it's a question

00:31:03,980 --> 00:31:15,380
with my debian hat on we we are training

00:31:09,320 --> 00:31:18,800
in Debian to enroll GCC plugins but we

00:31:15,380 --> 00:31:23,030
for now we didn't manage to to redo it

00:31:18,800 --> 00:31:24,950
because of out of three modules and we

00:31:23,030 --> 00:31:30,170
don't have religion first structure to

00:31:24,950 --> 00:31:31,010
actually make the plugins available for

00:31:30,170 --> 00:31:34,240
later

00:31:31,010 --> 00:31:37,940
is there something which would be

00:31:34,240 --> 00:31:40,550
possible to help us on that because as

00:31:37,940 --> 00:31:45,010
far as I understand

00:31:40,550 --> 00:31:49,250
GCC plugins are quite sensitive to the

00:31:45,010 --> 00:31:53,960
GCC version in was built wheels so it's

00:31:49,250 --> 00:32:00,190
not always practical to to use GCC

00:31:53,960 --> 00:32:03,560
plug-in later okay so it sounds like

00:32:00,190 --> 00:32:11,420
you're attempting to ship the output of

00:32:03,560 --> 00:32:14,450
the bill for later use well yes four out

00:32:11,420 --> 00:32:17,870
of three modules in Debian basically

00:32:14,450 --> 00:32:20,420
people when try to install module it's

00:32:17,870 --> 00:32:23,450
built on the user machines and not in

00:32:20,420 --> 00:32:26,450
the bill the network so they have to

00:32:23,450 --> 00:32:30,050
have the GCC a second rebuild the GCC

00:32:26,450 --> 00:32:34,130
plug-in locally is I need to use the

00:32:30,050 --> 00:32:35,630
binary Bill I say okay nothing

00:32:34,130 --> 00:32:37,040
immediately jumps to mind but I mean

00:32:35,630 --> 00:32:40,970
that sounds like something we definitely

00:32:37,040 --> 00:32:43,810
want to get solved I approached the bun

00:32:40,970 --> 00:32:46,780
to kernel team also about turning on

00:32:43,810 --> 00:32:49,130
general GCC plugin support in the kernel

00:32:46,780 --> 00:32:51,470
because I suspected there were probably

00:32:49,130 --> 00:32:54,230
some problems we haven't yet uncovered

00:32:51,470 --> 00:32:56,510
but it sounds like you found them but

00:32:54,230 --> 00:32:58,700
yeah I mean the intention was that it

00:32:56,510 --> 00:33:00,740
should be possible to do those builds

00:32:58,700 --> 00:33:01,940
and then it would be I mean always knew

00:33:00,740 --> 00:33:05,130
it would be compiler sensitive but the

00:33:01,940 --> 00:33:06,540
hope would be that we've got the source

00:33:05,130 --> 00:33:08,460
you've got whatever compiler you're

00:33:06,540 --> 00:33:11,880
about to build it with and things would

00:33:08,460 --> 00:33:13,140
be okay it sounds like there's more work

00:33:11,880 --> 00:33:13,590
to be done but yeah I'd like to see more

00:33:13,140 --> 00:33:15,290
about it

00:33:13,590 --> 00:33:25,950
because we should definitely solve it

00:33:15,290 --> 00:33:27,550
okay thanks no questions if not let's

00:33:25,950 --> 00:33:30,490
Thanks thank you

00:33:27,550 --> 00:33:30,490

YouTube URL: https://www.youtube.com/watch?v=uOsFh5AA79k


