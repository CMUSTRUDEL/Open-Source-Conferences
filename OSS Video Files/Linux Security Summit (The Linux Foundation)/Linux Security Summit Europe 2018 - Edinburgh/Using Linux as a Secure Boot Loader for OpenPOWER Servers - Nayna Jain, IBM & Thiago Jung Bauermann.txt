Title: Using Linux as a Secure Boot Loader for OpenPOWER Servers - Nayna Jain, IBM & Thiago Jung Bauermann
Publication date: 2018-10-27
Playlist: Linux Security Summit Europe 2018 - Edinburgh
Description: 
	Using Linux as a Secure Boot Loader for OpenPOWER Servers - Nayna Jain, IBM India Pvt Ltd & Thiago Jung Bauermann, IBMÂ 

When Linux is used as a secure boot loader, the Integrity Management Architecture (IMA) subsystem provides most of the functionality needed, but has limitations that we identified and addressed. For example, the builtin "secure_boot" command line option and the new build time policies are not flexible enough to support run time decisions based on the firmware's secure boot settings. These policies and settings interact to enable or disable the enforcement of signature verification of a kexec'ed kernel image. IMA-appraisal is also limited to verifying file signatures stored as extended attributes, yet the kernel image often comes from places without extended attribute support. This talk addresses these and other limitations, and describes patch sets that provide a complete solution for Linux as a secure boot loader. 

About Thiago Jung Bauermann
Thiago Bauermann has been working with the Open Source community for more than 10 years, and is a software engineer at IBM's Linux Technology Center working on the Linux kernel for the POWER architecture. Previously, he also worked on GNU GDB for POWER systems and Linux for embedded systems. He holds a Bachelor degree in Computer Engineering from the University of Campinas. 

About Nayna Jain
Nayna Jain is a software designer and developer at IBM India Pvt Ltd in Bengaluru, Karnataka, India. Her experience is in the Linux kernel integrity and Trusted Platform Module subsystems, trusted computing, security certifications compliance, and security advocacy. She is currently pursuing an M.S. in the Research Program at the International Institute of Information Technology, Bangalore, with a focus on secure multi-party computation. Ms. Jain has been a speaker at India's premier Free and Open Source Conference (FOSS), the Grace Hopper Conference, and Eclipse Bangalore. She is a member of the IEEE, and the Women in Engineering Bangalore Affiliate.
Captions: 
	00:00:00,060 --> 00:00:07,350
okay hi everyone huh good morning

00:00:03,330 --> 00:00:09,389
so as Anna said Jo and I are presenting

00:00:07,350 --> 00:00:13,290
on using Linux as a secure boot loader

00:00:09,389 --> 00:00:16,020
for open path servers so we both are

00:00:13,290 --> 00:00:18,480
from IBM we vote for Linux technologies

00:00:16,020 --> 00:00:21,119
and chill in IBM and both of our

00:00:18,480 --> 00:00:23,220
contributing to the Condor this is a

00:00:21,119 --> 00:00:25,260
disclaimer to start with this work

00:00:23,220 --> 00:00:27,960
represents a view of the author that is

00:00:25,260 --> 00:00:30,300
our both of us and does not necessarily

00:00:27,960 --> 00:00:32,189
represent of view of IBM all these

00:00:30,300 --> 00:00:35,130
endpoints disclosed in a subject to

00:00:32,189 --> 00:00:36,750
finalization and a acceptance and they

00:00:35,130 --> 00:00:40,739
may or may not be the part of the final

00:00:36,750 --> 00:00:43,770
product rest of the things as there ok

00:00:40,739 --> 00:00:45,390
here is the agenda we will start with

00:00:43,770 --> 00:00:49,020
the secure boot goals and requirements

00:00:45,390 --> 00:00:51,059
as proppant ah and to satisfy those

00:00:49,020 --> 00:00:52,739
requirements we are trying to see what

00:00:51,059 --> 00:00:55,500
the existing mechanisms in the kernel

00:00:52,739 --> 00:00:57,960
which we can use there are some gaps in

00:00:55,500 --> 00:00:59,449
that and we'll talk about them and we

00:00:57,960 --> 00:01:02,370
also talked about our proposed solution

00:00:59,449 --> 00:01:08,280
then finally the beta status and

00:01:02,370 --> 00:01:10,830
assembly ok to get it started so secure

00:01:08,280 --> 00:01:12,750
boot goals and requirements uh I assume

00:01:10,830 --> 00:01:15,450
yeah everybody would be knowing about

00:01:12,750 --> 00:01:17,729
secure boot and we have heard about it

00:01:15,450 --> 00:01:20,250
either in other slides or in the

00:01:17,729 --> 00:01:22,439
previous analysis so it still just to

00:01:20,250 --> 00:01:24,000
give a brief overview huh it is a

00:01:22,439 --> 00:01:26,850
protection against boot kits and the

00:01:24,000 --> 00:01:30,150
root kits and it is basically to make

00:01:26,850 --> 00:01:33,060
sure that any formula for any operating

00:01:30,150 --> 00:01:35,939
system you load on this on the server is

00:01:33,060 --> 00:01:38,579
basically verified journey and from the

00:01:35,939 --> 00:01:40,770
owner as you expected so this is the

00:01:38,579 --> 00:01:42,869
same what we are targeting it's for the

00:01:40,770 --> 00:01:44,670
open path secure boot solution the

00:01:42,869 --> 00:01:46,829
second thing is it's also requirement

00:01:44,670 --> 00:01:50,520
for the standards complaints and two of

00:01:46,829 --> 00:01:55,140
them as I listed this SP 800 147 B and

00:01:50,520 --> 00:01:56,909
Common Criteria OS P P 4.1 okay um I'll

00:01:55,140 --> 00:01:59,130
first start with the open file secure

00:01:56,909 --> 00:02:00,630
boot high level overview and then we

00:01:59,130 --> 00:02:03,360
will see what problem actually we are

00:02:00,630 --> 00:02:05,430
focusing into the whole solution so here

00:02:03,360 --> 00:02:08,610
is the the formulas you can put an OS

00:02:05,430 --> 00:02:10,530
secure boot as you see okay ah the open

00:02:08,610 --> 00:02:12,810
power the root of the city starts with

00:02:10,530 --> 00:02:16,640
the SB which is basically

00:02:12,810 --> 00:02:20,780
sigh tested code embedded into the

00:02:16,640 --> 00:02:24,480
hardware and okay sorry

00:02:20,780 --> 00:02:26,720
yeah embedded into the hardware and from

00:02:24,480 --> 00:02:30,239
where the chain of trust actually starts

00:02:26,720 --> 00:02:32,400
as I told every in secure boot

00:02:30,239 --> 00:02:34,769
everything image before loading the next

00:02:32,400 --> 00:02:37,410
image is supposed to verify it and that

00:02:34,769 --> 00:02:40,080
is what is done the SB verifies the host

00:02:37,410 --> 00:02:42,239
would host would manifest ski boot which

00:02:40,080 --> 00:02:44,550
is also called as a pal and a ski boot

00:02:42,239 --> 00:02:47,519
verifies the boot corner these are the

00:02:44,550 --> 00:02:50,400
part of the firmware and they are stored

00:02:47,519 --> 00:02:52,590
in the process of flash as a sign from

00:02:50,400 --> 00:02:54,000
their containers this sign form a

00:02:52,590 --> 00:02:56,310
containers are actually the headers

00:02:54,000 --> 00:03:00,269
which are prefixed before the images and

00:02:56,310 --> 00:03:03,870
they have a defined defined format it's

00:03:00,269 --> 00:03:05,040
a that the overall security perspectives

00:03:03,870 --> 00:03:06,630
are being discussed in other addresses

00:03:05,040 --> 00:03:10,380
and we are not going into details of

00:03:06,630 --> 00:03:11,880
that this process of flash is not locked

00:03:10,380 --> 00:03:14,910
so we protect the sign from your

00:03:11,880 --> 00:03:16,739
containers via TPM now the next point

00:03:14,910 --> 00:03:18,570
comes is the OS secure boot so once the

00:03:16,739 --> 00:03:20,340
bootloader is there boot Kanaan is there

00:03:18,570 --> 00:03:24,570
it needs to load the host operating

00:03:20,340 --> 00:03:27,540
system the open powered bootloader is

00:03:24,570 --> 00:03:29,730
actually a coordinates kernel based noda

00:03:27,540 --> 00:03:31,590
which is a Pettit boot it's a user space

00:03:29,730 --> 00:03:34,700
application in undercut running under

00:03:31,590 --> 00:03:38,190
kernel which does a cake loads the

00:03:34,700 --> 00:03:41,340
kernel images from differences options

00:03:38,190 --> 00:03:43,590
and then K exactly is a hostess today's

00:03:41,340 --> 00:03:46,109
discussion is actually about making sure

00:03:43,590 --> 00:03:48,209
this part from the boot kernel to the

00:03:46,109 --> 00:03:50,340
host source verifying the kernel images

00:03:48,209 --> 00:03:53,730
which is the requirement for as part of

00:03:50,340 --> 00:03:55,680
and to end secure boot solution so

00:03:53,730 --> 00:03:58,530
getting into the bootloader details so

00:03:55,680 --> 00:04:00,359
as I said it's a Linux kernel-based

00:03:58,530 --> 00:04:03,090
bootloader and pettite boot is the

00:04:00,359 --> 00:04:05,639
application which does the kxa it can

00:04:03,090 --> 00:04:07,410
load the images from different

00:04:05,639 --> 00:04:10,049
mechanisms either as a network from

00:04:07,410 --> 00:04:11,730
local days from sun etc and then the

00:04:10,049 --> 00:04:13,650
host OS can continue the chain of k

00:04:11,730 --> 00:04:19,139
exact which is like common for any other

00:04:13,650 --> 00:04:21,419
linux possibilities so requirements okay

00:04:19,139 --> 00:04:23,159
we need a verified kernel that is a

00:04:21,419 --> 00:04:26,460
requirement Kordich basic requirement

00:04:23,159 --> 00:04:30,030
for the secure boot disk owner can be

00:04:26,460 --> 00:04:31,680
from any multiple ways and we have to

00:04:30,030 --> 00:04:33,090
make sure that whichever way we get the

00:04:31,680 --> 00:04:35,310
kernel it should be verified before

00:04:33,090 --> 00:04:37,319
loading the second thing is that a

00:04:35,310 --> 00:04:39,120
secure boot solution basically system

00:04:37,319 --> 00:04:41,340
can be in a different mode of duress

00:04:39,120 --> 00:04:44,610
part of the secure boot also it might be

00:04:41,340 --> 00:04:46,800
in a setup mode which may not require

00:04:44,610 --> 00:04:48,870
you to do the verification it might be

00:04:46,800 --> 00:04:50,819
in the audit or user mode the user mode

00:04:48,870 --> 00:04:53,099
enforces that you verify everything and

00:04:50,819 --> 00:04:55,470
the audit mode tells you to do the very

00:04:53,099 --> 00:04:57,840
fine but even if the verification fails

00:04:55,470 --> 00:04:59,840
it allows you to boot it just logs that

00:04:57,840 --> 00:05:03,419
the verification has well for later

00:04:59,840 --> 00:05:05,699
analysis so these different states of

00:05:03,419 --> 00:05:07,490
the secure boot needs to be honored the

00:05:05,699 --> 00:05:09,960
policies as per them has to be or not

00:05:07,490 --> 00:05:12,660
then you need the firmware keys support

00:05:09,960 --> 00:05:14,340
it is possible that your form a sign

00:05:12,660 --> 00:05:16,169
with a set up for my keys and their

00:05:14,340 --> 00:05:19,139
content image is also signed with the

00:05:16,169 --> 00:05:21,840
same for my keys for example DB KK keys

00:05:19,139 --> 00:05:23,940
so it is required that the kernel can

00:05:21,840 --> 00:05:27,530
verify the bootloader can verify the

00:05:23,940 --> 00:05:29,759
kernel using this form your keys

00:05:27,530 --> 00:05:32,490
maintain the secure boot policies across

00:05:29,759 --> 00:05:33,840
the K exit when the kernel does a key

00:05:32,490 --> 00:05:36,330
exec it can change the boot parameters

00:05:33,840 --> 00:05:38,729
option so it is possible then people can

00:05:36,330 --> 00:05:40,560
try to do overriding so what is required

00:05:38,729 --> 00:05:43,500
is that based on the secure boot the

00:05:40,560 --> 00:05:45,900
state of the system the KX a poly the

00:05:43,500 --> 00:05:48,810
these policy should be maintained across

00:05:45,900 --> 00:05:50,460
any set of K exact chains and you need

00:05:48,810 --> 00:05:52,680
if we need that the k exact load is

00:05:50,460 --> 00:05:54,570
disabled because k exact load allows

00:05:52,680 --> 00:05:57,990
unsigned kernel images to be loaded and

00:05:54,570 --> 00:06:00,330
the last thing as I said in L shown in

00:05:57,990 --> 00:06:01,949
my first diagram we we actually divided

00:06:00,330 --> 00:06:03,630
it into two domains from there

00:06:01,949 --> 00:06:06,090
and the operating system secure boot

00:06:03,630 --> 00:06:09,060
because the OS secure boot kernel images

00:06:06,090 --> 00:06:11,550
can come from various of options but

00:06:09,060 --> 00:06:13,770
formulas from the platform honor so it

00:06:11,550 --> 00:06:17,009
is possible that sometimes you discuss

00:06:13,770 --> 00:06:18,539
might want to load unsigned kernels for

00:06:17,009 --> 00:06:20,070
backward compatibility but then you

00:06:18,539 --> 00:06:21,990
don't want to disable the whole secure

00:06:20,070 --> 00:06:24,210
boot solution so a formal secure boot is

00:06:21,990 --> 00:06:26,219
still enabled but you allow unsigned

00:06:24,210 --> 00:06:30,300
kernels to be loaded so that is the last

00:06:26,219 --> 00:06:33,150
boy okay so the thing is we need this

00:06:30,300 --> 00:06:35,669
for our last stage of loading the host

00:06:33,150 --> 00:06:37,529
OS and we had a kernel based boot loader

00:06:35,669 --> 00:06:38,840
so the point is can we use something

00:06:37,529 --> 00:06:41,810
which already exists in the

00:06:38,840 --> 00:06:44,570
and from yesterday's two days and all of

00:06:41,810 --> 00:06:46,730
earlier discussions people know about

00:06:44,570 --> 00:06:48,830
integrity measurement architecture

00:06:46,730 --> 00:06:51,260
stammers so we consider this as a

00:06:48,830 --> 00:06:55,040
possible solution tiabo we'll discuss

00:06:51,260 --> 00:06:58,730
about them okay hello

00:06:55,040 --> 00:07:01,880
so i'ma as we have seen here today and

00:06:58,730 --> 00:07:05,570
and in other presentations and

00:07:01,880 --> 00:07:08,210
conferences i'ma is a major subsystem in

00:07:05,570 --> 00:07:11,660
the kernel being used in production so

00:07:08,210 --> 00:07:15,710
we turned to it to implement secure boot

00:07:11,660 --> 00:07:20,210
it can be used to enforce the secure

00:07:15,710 --> 00:07:23,150
boot rules that we want so how does it

00:07:20,210 --> 00:07:25,040
work to have a secure boot implemented

00:07:23,150 --> 00:07:29,270
using IMAP

00:07:25,040 --> 00:07:32,120
when when the bootloader starts it has

00:07:29,270 --> 00:07:38,740
to check the secure boot state which can

00:07:32,120 --> 00:07:42,370
be added our setup or user mode and

00:07:38,740 --> 00:07:46,690
depending on that it will load the

00:07:42,370 --> 00:07:50,120
firmer key keys to the kernel cueing and

00:07:46,690 --> 00:07:52,910
we'll load the policy that will enforce

00:07:50,120 --> 00:07:59,090
the secure boot settings of the fumer

00:07:52,910 --> 00:08:02,479
and finally it will be ready to verify

00:07:59,090 --> 00:08:07,789
the kernel before allowing it to be

00:08:02,479 --> 00:08:10,490
loaded them and booted so well I will

00:08:07,789 --> 00:08:12,950
not spend a lot of time with i'ma basics

00:08:10,490 --> 00:08:15,919
we had talks here about that already

00:08:12,950 --> 00:08:21,289
but basically we have three operations

00:08:15,919 --> 00:08:23,240
in i'ma measure appraise an audit when

00:08:21,289 --> 00:08:24,950
you measure you can also start the

00:08:23,240 --> 00:08:28,370
measurement in the measurement list as

00:08:24,950 --> 00:08:31,039
was said before and at the top here we

00:08:28,370 --> 00:08:34,729
have an example with I'm a policy with

00:08:31,039 --> 00:08:37,339
three three rules the rule in the middle

00:08:34,729 --> 00:08:40,130
here is the one we are most interested

00:08:37,339 --> 00:08:42,469
in for secure boot it appraises the

00:08:40,130 --> 00:08:45,380
kernel that is loaded we are Kasich

00:08:42,469 --> 00:08:50,120
followed and the argument here appraised

00:08:45,380 --> 00:08:51,600
type equals I'm a cig is telling imma to

00:08:50,120 --> 00:08:58,470
verify a signature

00:08:51,600 --> 00:09:02,660
starting in in the file so how do you do

00:08:58,470 --> 00:09:06,300
that you have to use the AVM CTL comment

00:09:02,660 --> 00:09:09,330
which will add that security that I my

00:09:06,300 --> 00:09:11,490
extended attribute that extended

00:09:09,330 --> 00:09:15,390
attribute contains a signature in a very

00:09:11,490 --> 00:09:19,920
simple format as can be seen here and

00:09:15,390 --> 00:09:23,400
with that I'm is able to retrieve that

00:09:19,920 --> 00:09:28,470
signature and and verify if it if the

00:09:23,400 --> 00:09:32,880
kernel is correctly signed so if this

00:09:28,470 --> 00:09:36,110
works and it does then what's the

00:09:32,880 --> 00:09:39,000
problem we found three issues that we

00:09:36,110 --> 00:09:43,050
solved and we are going to expand on

00:09:39,000 --> 00:09:45,990
them during this talk I will explain the

00:09:43,050 --> 00:09:49,320
first one and I know we'll go into more

00:09:45,990 --> 00:09:51,360
details on the next two so the first one

00:09:49,320 --> 00:09:56,940
is related to the use of extended

00:09:51,360 --> 00:10:00,720
attributes it's a very common method to

00:09:56,940 --> 00:10:04,410
when you boot your computer that you

00:10:00,720 --> 00:10:08,160
fetch your kernel from the network and

00:10:04,410 --> 00:10:12,480
some methods of booting via the network

00:10:08,160 --> 00:10:16,230
they will not allow extended attributes

00:10:12,480 --> 00:10:19,560
to be fetched for instance HTTP RT FTP

00:10:16,230 --> 00:10:22,830
or even local file system some file

00:10:19,560 --> 00:10:26,930
systems used for USB keys for example

00:10:22,830 --> 00:10:29,640
they don't support extended attribute so

00:10:26,930 --> 00:10:32,700
we need to support secure boot even in

00:10:29,640 --> 00:10:38,430
those scenarios so this is a problem we

00:10:32,700 --> 00:10:41,580
have found so well just just to

00:10:38,430 --> 00:10:44,190
reinforce these are examples of boot

00:10:41,580 --> 00:10:47,880
methods that that Betty boot allows

00:10:44,190 --> 00:10:51,750
they're fairly standard in boot loaders

00:10:47,880 --> 00:10:53,820
some of them allow signal trusted sorry

00:10:51,750 --> 00:10:58,190
some of them allow extended attributes

00:10:53,820 --> 00:11:02,360
some don't so our solution involves

00:10:58,190 --> 00:11:02,360
embedding the signature in the file

00:11:02,710 --> 00:11:09,190
the colonel has a method for that

00:11:06,100 --> 00:11:13,240
already for module signatures there's a

00:11:09,190 --> 00:11:16,540
kernel feature where you can require

00:11:13,240 --> 00:11:19,630
that modules are sign it and only sign

00:11:16,540 --> 00:11:22,180
it modules can be loaded and the format

00:11:19,630 --> 00:11:25,870
of the signature is very simple you just

00:11:22,180 --> 00:11:29,800
append at the end of the file this

00:11:25,870 --> 00:11:35,560
structure which contains a pkcs7 in

00:11:29,800 --> 00:11:38,709
message with a signature these Switzer's

00:11:35,560 --> 00:11:42,010
because the the powerpc kernel is enough

00:11:38,709 --> 00:11:45,880
image as well you can append contents to

00:11:42,010 --> 00:11:48,310
it and it will still be usable so that's

00:11:45,880 --> 00:11:51,520
what we decided to use there there's a

00:11:48,310 --> 00:11:54,700
tool already in the kernel scripts slash

00:11:51,520 --> 00:11:59,220
sign file that performs this step so

00:11:54,700 --> 00:12:03,490
that's what we use when we added

00:11:59,220 --> 00:12:05,730
appended signature supports to imma we

00:12:03,490 --> 00:12:08,260
wanted to do it in a way that's

00:12:05,730 --> 00:12:10,779
backwards compatible in the sense that

00:12:08,260 --> 00:12:14,080
if you already have a file that has an

00:12:10,779 --> 00:12:19,480
extended attribute signature nothing

00:12:14,080 --> 00:12:23,560
will change if that file has an appended

00:12:19,480 --> 00:12:28,270
signature as well so what happens is

00:12:23,560 --> 00:12:32,110
that if there is no well first the first

00:12:28,270 --> 00:12:37,000
step is there's a new argument you can

00:12:32,110 --> 00:12:39,339
pass to the appraised rule which says

00:12:37,000 --> 00:12:43,600
who I'm on that it can expect a mod cig

00:12:39,339 --> 00:12:46,690
we allow it to use a mod sig to verify

00:12:43,600 --> 00:12:49,150
the signature and if you have that and

00:12:46,690 --> 00:12:51,550
there's no extended attribute signature

00:12:49,150 --> 00:12:54,430
in the file then of course imma we will

00:12:51,550 --> 00:12:58,360
look for for an appended signature and

00:12:54,430 --> 00:13:00,970
try to use it and the other case is if

00:12:58,360 --> 00:13:05,350
there is an extended attribute signature

00:13:00,970 --> 00:13:07,420
but the signature is sign it with a key

00:13:05,350 --> 00:13:10,959
that the kernel doesn't know about it's

00:13:07,420 --> 00:13:13,540
not present in the kernel key wing so in

00:13:10,959 --> 00:13:16,770
that case it will ignore the extended

00:13:13,540 --> 00:13:19,020
attribute signature and also look for

00:13:16,770 --> 00:13:24,600
an appended signature in the file and

00:13:19,020 --> 00:13:26,279
try to use it to verify it so even

00:13:24,600 --> 00:13:29,940
though secure boot is not about

00:13:26,279 --> 00:13:32,790
measurements there is an interaction

00:13:29,940 --> 00:13:38,520
with measurements that we found that we

00:13:32,790 --> 00:13:41,970
we had to address so I coming back to to

00:13:38,520 --> 00:13:46,350
this measure step and storing it in the

00:13:41,970 --> 00:13:49,440
measurement list just an aside the rule

00:13:46,350 --> 00:13:52,350
in the middle has a setting that I

00:13:49,440 --> 00:13:54,930
mention that you can add you in Dupre's

00:13:52,350 --> 00:13:58,500
rule we can say a place type because I'm

00:13:54,930 --> 00:14:01,230
a sig or mod C then you are telling I'm

00:13:58,500 --> 00:14:07,950
not that it can use a mod sig if there

00:14:01,230 --> 00:14:08,420
is one so before I I talked about our

00:14:07,950 --> 00:14:12,240
issue

00:14:08,420 --> 00:14:14,220
how does i'ma know what to put in the

00:14:12,240 --> 00:14:18,390
measurement least it has a concept of an

00:14:14,220 --> 00:14:20,910
I'm a template the I'm a template mmm

00:14:18,390 --> 00:14:22,589
tells it which which information should

00:14:20,910 --> 00:14:25,800
be added to an entering the measurement

00:14:22,589 --> 00:14:28,260
list you can use a template fields for

00:14:25,800 --> 00:14:31,380
us for saying that you want to store the

00:14:28,260 --> 00:14:33,480
digest the name of the file and if

00:14:31,380 --> 00:14:36,510
there's a signature signature as well so

00:14:33,480 --> 00:14:39,960
there are some predefined i'ma templates

00:14:36,510 --> 00:14:43,710
for for instance the imma - sig here

00:14:39,960 --> 00:14:46,800
which includes the the signature and in

00:14:43,710 --> 00:14:52,380
that case you have a measurement entry

00:14:46,800 --> 00:14:54,180
like this one the first of well just to

00:14:52,380 --> 00:14:57,690
explain a little bit this entry

00:14:54,180 --> 00:15:01,170
the first number here in yellow is is

00:14:57,690 --> 00:15:05,550
the PCR the TPM PCR that is extended

00:15:01,170 --> 00:15:08,940
with this measurement then follows the

00:15:05,550 --> 00:15:11,220
the contents of the PCR at the time of

00:15:08,940 --> 00:15:13,830
this measurement and then you have the

00:15:11,220 --> 00:15:21,029
template the timer is configured to use

00:15:13,830 --> 00:15:24,930
in this case I'm a sig which as so as

00:15:21,029 --> 00:15:26,970
shown on this slide it tells that imma

00:15:24,930 --> 00:15:28,709
should start the digest the name and the

00:15:26,970 --> 00:15:29,220
signature of the file so that's what

00:15:28,709 --> 00:15:34,980
follows

00:15:29,220 --> 00:15:37,050
here in blue this is the sha-256 digest

00:15:34,980 --> 00:15:40,829
of the entire contents of the file that

00:15:37,050 --> 00:15:44,189
was appraised the path of the file and

00:15:40,829 --> 00:15:46,610
then at the end the contents of the

00:15:44,189 --> 00:15:50,189
security that I maxed in the debt reboot

00:15:46,610 --> 00:15:53,389
containing the digital signature so one

00:15:50,189 --> 00:15:58,139
property of these that is very useful is

00:15:53,389 --> 00:16:01,230
you can just with these entry doing out

00:15:58,139 --> 00:16:04,680
it for instance know whether the

00:16:01,230 --> 00:16:10,319
signature is valid or not for this file

00:16:04,680 --> 00:16:13,639
the digest of the file is is the digest

00:16:10,319 --> 00:16:16,110
that is used in the signature to

00:16:13,639 --> 00:16:17,910
validate the contents so with this

00:16:16,110 --> 00:16:21,629
digest in this signature you can say

00:16:17,910 --> 00:16:24,720
whether the signature was valid or not

00:16:21,629 --> 00:16:27,000
when when the file was appraised the

00:16:24,720 --> 00:16:29,610
problem we found is that when you append

00:16:27,000 --> 00:16:31,680
a signature at the end of the file you

00:16:29,610 --> 00:16:36,720
modify the file contents obviously and

00:16:31,680 --> 00:16:39,059
with that the digest of the file as

00:16:36,720 --> 00:16:41,459
measured by AIA is not the same one that

00:16:39,059 --> 00:16:45,809
was used to sign the file anymore and

00:16:41,459 --> 00:16:47,519
you can't at a later point verify

00:16:45,809 --> 00:16:52,350
whether the signature was valid or not

00:16:47,519 --> 00:16:54,329
so we solved solved these by introducing

00:16:52,350 --> 00:17:00,379
a new template field called

00:16:54,329 --> 00:17:03,029
D - sig which tells how much you store

00:17:00,379 --> 00:17:05,100
not only the sorry

00:17:03,029 --> 00:17:07,740
it tells how much you start the contents

00:17:05,100 --> 00:17:10,079
the the hash of the contents of the file

00:17:07,740 --> 00:17:15,419
but ignoring the ended signature at the

00:17:10,079 --> 00:17:17,669
end these fields this hash then is the

00:17:15,419 --> 00:17:20,429
one that is expected to match the one in

00:17:17,669 --> 00:17:22,949
the signature and here in this example

00:17:20,429 --> 00:17:25,049
we see at the end of the file the

00:17:22,949 --> 00:17:29,100
contents of the appended signature as

00:17:25,049 --> 00:17:32,460
well in the net entry and with that

00:17:29,100 --> 00:17:35,970
information we can once again verify

00:17:32,460 --> 00:17:39,530
that the signature is valid or not when

00:17:35,970 --> 00:17:39,530
the fire was was appraised

00:17:39,900 --> 00:17:47,860
one last point that's also not directly

00:17:45,460 --> 00:17:52,810
related to secure boot but important in

00:17:47,860 --> 00:17:56,800
our use case every boot is a Kazakh open

00:17:52,810 --> 00:18:00,880
power so if you want to verify the

00:17:56,800 --> 00:18:03,070
contents of the PCR registers in the TPM

00:18:00,880 --> 00:18:05,980
you need the history of measurements

00:18:03,070 --> 00:18:09,550
that were made because when UK is a

00:18:05,980 --> 00:18:12,610
canoe colonel the TPM is not reset so

00:18:09,550 --> 00:18:15,130
the PCR contents are not reset either

00:18:12,610 --> 00:18:17,770
you need the history of the measurements

00:18:15,130 --> 00:18:20,980
in the new colonel to know whether the

00:18:17,770 --> 00:18:31,530
PCR values are the ones you expect or

00:18:20,980 --> 00:18:34,030
not also you need to know at which boot

00:18:31,530 --> 00:18:36,490
which colonel each measurement

00:18:34,030 --> 00:18:39,670
corresponds so you have a measurement

00:18:36,490 --> 00:18:42,430
you want to know if it was before a

00:18:39,670 --> 00:18:46,390
given case occur after a given K is X so

00:18:42,430 --> 00:18:49,450
you need a marker for for the K exact

00:18:46,390 --> 00:18:52,720
event and i'ma has the boot aggregate

00:18:49,450 --> 00:18:54,970
that serves that function you have one

00:18:52,720 --> 00:18:58,480
boot aggregate per K exact that you

00:18:54,970 --> 00:19:01,480
perform and lastly you also need the

00:18:58,480 --> 00:19:06,430
measurement list past so the new colonel

00:19:01,480 --> 00:19:09,340
because the act of performing a Kazak

00:19:06,430 --> 00:19:12,040
file load itself generates new

00:19:09,340 --> 00:19:15,670
measurements and you want them passed on

00:19:12,040 --> 00:19:18,160
so that you can verify the TPM PCR

00:19:15,670 --> 00:19:21,310
values so we have a feature already

00:19:18,160 --> 00:19:25,090
upstream since Colonel for dot dam on on

00:19:21,310 --> 00:19:27,730
PowerPC where when you perform a key

00:19:25,090 --> 00:19:29,920
exact file load and the colonel will

00:19:27,730 --> 00:19:33,520
serialize the I'm a measurement listing

00:19:29,920 --> 00:19:35,470
to enter on I McKay's aquifer and pass

00:19:33,520 --> 00:19:38,200
it on to the next Colonel then the new

00:19:35,470 --> 00:19:41,110
colonel will detect that this buffer is

00:19:38,200 --> 00:19:45,570
there and we'll load the measurements

00:19:41,110 --> 00:19:45,570
into its own measure

00:19:50,250 --> 00:19:56,460
sorry I think I'm talking too much but

00:19:54,470 --> 00:20:01,649
I'm at the end

00:19:56,460 --> 00:20:03,870
so these summarizes how we solved the

00:20:01,649 --> 00:20:08,070
first issue that I mentioned before in

00:20:03,870 --> 00:20:11,039
the earlier slide it solves our problem

00:20:08,070 --> 00:20:14,700
with extended attribute signatures by

00:20:11,039 --> 00:20:17,990
using the module signatures so now I

00:20:14,700 --> 00:20:20,549
know we'll talk about the other points

00:20:17,990 --> 00:20:22,529
so if you'll remember from the mini

00:20:20,549 --> 00:20:25,409
slide there are three things required

00:20:22,529 --> 00:20:27,210
for the oppressor first signature then

00:20:25,409 --> 00:20:29,010
the keys and the policies now we have

00:20:27,210 --> 00:20:31,110
the kernel with the sign with the

00:20:29,010 --> 00:20:33,570
signature but we need the keys to verify

00:20:31,110 --> 00:20:36,690
those signatures and as I mentioned that

00:20:33,570 --> 00:20:38,399
one of the requirement is that we it is

00:20:36,690 --> 00:20:40,889
possible that you get the formula keys

00:20:38,399 --> 00:20:42,630
to below the the kernel images might be

00:20:40,889 --> 00:20:44,399
signed with the formula keys and we need

00:20:42,630 --> 00:20:47,580
to load these for my keys in the kernel

00:20:44,399 --> 00:20:50,279
for verified so so what's the problem

00:20:47,580 --> 00:20:52,110
there exists Giddings from David's

00:20:50,279 --> 00:20:54,539
presentation people might have an idea

00:20:52,110 --> 00:20:57,450
about kidding so there exists Giddings

00:20:54,539 --> 00:21:00,450
and dot timeline and this car I'm alike

00:20:57,450 --> 00:21:03,330
it is used by the I'ma for appraisal so

00:21:00,450 --> 00:21:05,100
I store these keys into the it so the

00:21:03,330 --> 00:21:07,590
phone via keys into these ceilings so

00:21:05,100 --> 00:21:09,450
but what is the problem let's see that

00:21:07,590 --> 00:21:12,419
imma actually accepts only the signed

00:21:09,450 --> 00:21:14,190
keys and these x keys are watched by the

00:21:12,419 --> 00:21:16,169
keys which are present in the dot

00:21:14,190 --> 00:21:20,159
secondary and the dot built interest it

00:21:16,169 --> 00:21:21,720
is the and the point is that we want to

00:21:20,159 --> 00:21:23,220
emphasize is that the dot built in and

00:21:21,720 --> 00:21:25,769
dot secondly should have only are

00:21:23,220 --> 00:21:28,230
actually accepting on this scientist

00:21:25,769 --> 00:21:31,230
that is because since they are watching

00:21:28,230 --> 00:21:33,240
the keys if they are unsigned and if

00:21:31,230 --> 00:21:35,429
somebody puts up unsigned malicious key

00:21:33,240 --> 00:21:37,080
they might end up watching most of the

00:21:35,429 --> 00:21:38,970
other malicious keys which are there in

00:21:37,080 --> 00:21:41,250
which may be loaded into the dot Emma

00:21:38,970 --> 00:21:43,740
and can be useful time a pizza so this

00:21:41,250 --> 00:21:45,510
is the like dot secondly not built in

00:21:43,740 --> 00:21:48,149
debt so I expect only the scientist and

00:21:45,510 --> 00:21:50,130
the same that the dot I mother needs the

00:21:48,149 --> 00:21:52,740
keys which are signed and watched by

00:21:50,130 --> 00:21:54,990
these to underscore imma is the one

00:21:52,740 --> 00:21:56,570
which is the users defined keyring and

00:21:54,990 --> 00:21:59,090
it can accept the

00:21:56,570 --> 00:22:01,309
keys which are unsigned and generally

00:21:59,090 --> 00:22:02,899
loaded typically loaded in in a Memphis

00:22:01,309 --> 00:22:05,269
before the system private soon

00:22:02,899 --> 00:22:07,370
the second key property is the modify

00:22:05,269 --> 00:22:09,769
ability the building trusted keys are

00:22:07,370 --> 00:22:12,110
actually compiled in time you define you

00:22:09,769 --> 00:22:14,809
at the certificate but the other keys

00:22:12,110 --> 00:22:18,110
are key can be modified by the user

00:22:14,809 --> 00:22:20,330
space and the spoke the limited and

00:22:18,110 --> 00:22:22,159
broad so though as I said the built in

00:22:20,330 --> 00:22:24,080
and secondary Keating's are used for

00:22:22,159 --> 00:22:26,029
verifying other keys or for the model

00:22:24,080 --> 00:22:27,860
signatures that's the only purpose for

00:22:26,029 --> 00:22:30,049
them so that's why I said scope is

00:22:27,860 --> 00:22:32,090
limited but for the dot time an

00:22:30,049 --> 00:22:33,139
underscore i'ma keys are used for

00:22:32,090 --> 00:22:35,659
multiple purposes

00:22:33,139 --> 00:22:37,639
so now if we see and if we need a

00:22:35,659 --> 00:22:39,379
firmware keys to be loaded what is the

00:22:37,639 --> 00:22:41,240
requirement these come from the firmware

00:22:39,379 --> 00:22:42,860
the first question is does the colonel

00:22:41,240 --> 00:22:45,590
trust the keys which are coming from the

00:22:42,860 --> 00:22:47,299
formula so you can also seen another way

00:22:45,590 --> 00:22:50,299
pre-boot keys or the post-birth keys

00:22:47,299 --> 00:22:52,759
that is one thing second thing since the

00:22:50,299 --> 00:22:55,460
keys are provided by the firmware we

00:22:52,759 --> 00:22:57,620
want the we would not want any user to

00:22:55,460 --> 00:22:59,690
be able to modify them and if we try to

00:22:57,620 --> 00:23:01,909
match none of these actually are

00:22:59,690 --> 00:23:03,320
satisfying this so I need a compiling

00:23:01,909 --> 00:23:06,590
queue loaded from firmware

00:23:03,320 --> 00:23:09,830
but the they should but the kernel may

00:23:06,590 --> 00:23:11,600
not trust them and also the formula keys

00:23:09,830 --> 00:23:13,129
may not always be signed so I may not be

00:23:11,600 --> 00:23:15,529
able to verify their signature chain of

00:23:13,129 --> 00:23:17,419
trust secondly these are used for the

00:23:15,529 --> 00:23:19,129
scope is only to use them for the kernel

00:23:17,419 --> 00:23:24,830
image verification and they should not

00:23:19,129 --> 00:23:26,210
be user modifiable now if we yes so so

00:23:24,830 --> 00:23:28,850
that's where to satisfy these three

00:23:26,210 --> 00:23:30,889
requirements we propose a new kidding

00:23:28,850 --> 00:23:34,159
which is called the platform keys and

00:23:30,889 --> 00:23:35,750
the purpose of this is that you know the

00:23:34,159 --> 00:23:37,669
four make is basically you need to

00:23:35,750 --> 00:23:40,039
provide an isolation the kernel has to

00:23:37,669 --> 00:23:42,679
isolate the keys provided by firmware

00:23:40,039 --> 00:23:44,570
which may be unsigned and the keys which

00:23:42,679 --> 00:23:47,570
its own provides by the from the kernel

00:23:44,570 --> 00:23:49,850
itself and which it just so this

00:23:47,570 --> 00:23:51,559
platform clearing the purpose of this is

00:23:49,850 --> 00:23:52,970
to provide that isolation between the

00:23:51,559 --> 00:23:56,179
untrusted form via keys and the

00:23:52,970 --> 00:23:58,070
recipients it can be loaded either the

00:23:56,179 --> 00:24:00,889
compiled in time as a single certificate

00:23:58,070 --> 00:24:03,259
or loaded from the boot time these

00:24:00,889 --> 00:24:06,740
accepts unsigned keys so they need not

00:24:03,259 --> 00:24:08,360
be satisfy any chain of trust and then

00:24:06,740 --> 00:24:10,310
the non-modifiable they should not be

00:24:08,360 --> 00:24:12,500
overly done by user

00:24:10,310 --> 00:24:16,220
so basically these keys once loaded at

00:24:12,500 --> 00:24:18,620
the boot time nobody can change them you

00:24:16,220 --> 00:24:20,300
can al we can enable this by a config

00:24:18,620 --> 00:24:23,480
option conflict let form Keaney and

00:24:20,300 --> 00:24:25,790
convict let some tests a kiss so here is

00:24:23,480 --> 00:24:27,260
how it looks like dot platform kiss it

00:24:25,790 --> 00:24:29,870
has the same permission as the dot

00:24:27,260 --> 00:24:33,650
built-in because it doesn't it need not

00:24:29,870 --> 00:24:36,710
be modifiable by user and yes that's

00:24:33,650 --> 00:24:39,500
what sitting so this actually provides a

00:24:36,710 --> 00:24:42,020
it allows us to use the formula keys

00:24:39,500 --> 00:24:44,480
which comes from the pre put time may or

00:24:42,020 --> 00:24:46,520
may not be signed to be used by the

00:24:44,480 --> 00:24:49,190
bootloader for the kernel image

00:24:46,520 --> 00:24:51,050
verification and only for the limited

00:24:49,190 --> 00:24:53,240
purpose of the kernel image and are not

00:24:51,050 --> 00:24:55,270
modifiable by user and that's how we

00:24:53,240 --> 00:24:58,460
solve this problem

00:24:55,270 --> 00:24:59,480
the second thing so again the third

00:24:58,460 --> 00:25:01,610
thing which is required for the

00:24:59,480 --> 00:25:02,960
appraisal is the policy I'm having do

00:25:01,610 --> 00:25:06,080
the appraisal only if there is a policy

00:25:02,960 --> 00:25:09,230
to find for it and we need cakes a canal

00:25:06,080 --> 00:25:10,910
check is the existing policy dual which

00:25:09,230 --> 00:25:13,250
can be used for the kernel image

00:25:10,910 --> 00:25:16,040
verification but what's the problem is

00:25:13,250 --> 00:25:18,680
discuss that these are the default

00:25:16,040 --> 00:25:21,740
policies these are the existing policies

00:25:18,680 --> 00:25:23,720
available now the upper two are more of

00:25:21,740 --> 00:25:26,210
default policies for different purposes

00:25:23,720 --> 00:25:28,040
our focus is more on the secure boot and

00:25:26,210 --> 00:25:30,740
the secure boot is specific policies

00:25:28,040 --> 00:25:34,640
which can which has the key exact kernel

00:25:30,740 --> 00:25:36,230
check so the last two does that the

00:25:34,640 --> 00:25:39,140
secure boot policies defined as the boot

00:25:36,230 --> 00:25:41,570
parameter and it can be overwritten by

00:25:39,140 --> 00:25:44,890
the user space by writing it to the

00:25:41,570 --> 00:25:47,390
assist kernel security I'm a policy five

00:25:44,890 --> 00:25:49,670
this is not preserved across key exact

00:25:47,390 --> 00:25:51,530
because I might have loaded my first

00:25:49,670 --> 00:25:53,390
choice with a boot parameter secure boot

00:25:51,530 --> 00:25:55,820
but I can do another key exact

00:25:53,390 --> 00:25:57,290
without this parameter and there's no

00:25:55,820 --> 00:26:00,740
secure boot policies anymore

00:25:57,290 --> 00:26:02,390
the second option to fix this the next

00:26:00,740 --> 00:26:05,210
option that comes the bill time policy

00:26:02,390 --> 00:26:09,770
so that it cannot be modified by the

00:26:05,210 --> 00:26:12,290
user and so here these are defined at

00:26:09,770 --> 00:26:13,820
the compile time these yeah this has

00:26:12,290 --> 00:26:16,160
come recently so these are defined at

00:26:13,820 --> 00:26:17,720
the compile time you you choose the may

00:26:16,160 --> 00:26:19,020
have to choose them is a config option

00:26:17,720 --> 00:26:20,640
and there's

00:26:19,020 --> 00:26:23,160
policies define with the cake second

00:26:20,640 --> 00:26:25,740
check is the secure boot that then they

00:26:23,160 --> 00:26:28,080
are not custom modifiable and but the

00:26:25,740 --> 00:26:30,420
problem is these are hard-coded once

00:26:28,080 --> 00:26:32,580
it's been it's returned it's it's built

00:26:30,420 --> 00:26:34,230
into the canal it's built those won't

00:26:32,580 --> 00:26:36,450
handle the security state of the system

00:26:34,230 --> 00:26:39,150
because that is what we need we need

00:26:36,450 --> 00:26:41,820
something with this runtime which at the

00:26:39,150 --> 00:26:43,800
boot time understands the state security

00:26:41,820 --> 00:26:45,990
state of the system whether it is an

00:26:43,800 --> 00:26:48,120
audit mode or a user model setup mode

00:26:45,990 --> 00:26:49,980
because the setup one may not need any

00:26:48,120 --> 00:26:52,380
verification but the user mode needs

00:26:49,980 --> 00:26:54,180
verification so it can define the policy

00:26:52,380 --> 00:26:56,280
it can check the policy accordingly

00:26:54,180 --> 00:26:58,080
it should not be custom modifiable

00:26:56,280 --> 00:26:59,970
nobody should be able to write to

00:26:58,080 --> 00:27:02,610
override it and it should be preserved

00:26:59,970 --> 00:27:04,740
across cases since every k exec will

00:27:02,610 --> 00:27:06,450
actually should be checking the security

00:27:04,740 --> 00:27:08,580
state and accordingly defining the

00:27:06,450 --> 00:27:10,620
policy and the state of the system will

00:27:08,580 --> 00:27:14,370
not be changing so that weight can be

00:27:10,620 --> 00:27:16,470
preserved so to handle this we propose

00:27:14,370 --> 00:27:18,750
another policy called architectural

00:27:16,470 --> 00:27:21,210
specific policies which can be defined

00:27:18,750 --> 00:27:23,370
specific to each architecture based on

00:27:21,210 --> 00:27:27,720
their requirements and these are loaded

00:27:23,370 --> 00:27:29,460
at the booth type these are yeah based

00:27:27,720 --> 00:27:31,980
on the secure boot state they are of the

00:27:29,460 --> 00:27:34,710
highest priority if these are defined no

00:27:31,980 --> 00:27:36,330
other policy will be overtaking them and

00:27:34,710 --> 00:27:38,580
these are the one which are given the

00:27:36,330 --> 00:27:41,040
priority if they cannot be overridden by

00:27:38,580 --> 00:27:42,840
boot parameter because diesel is

00:27:41,040 --> 00:27:45,450
specified at the runtime no good

00:27:42,840 --> 00:27:48,450
parameter is required to used to define

00:27:45,450 --> 00:27:51,330
them the one more thing is there is an

00:27:48,450 --> 00:27:53,520
IMAP read state flag you can make it the

00:27:51,330 --> 00:27:56,550
IMAP recipe can be used as a log and

00:27:53,520 --> 00:27:58,890
force or fix so I might define the

00:27:56,550 --> 00:28:01,260
policies but if I make the M I press

00:27:58,890 --> 00:28:05,180
equals to fix or lock I can sync boot an

00:28:01,260 --> 00:28:08,130
unsanctioned so this flag has to be very

00:28:05,180 --> 00:28:10,680
very carefully used along with the

00:28:08,130 --> 00:28:13,080
policies so we when the architecture

00:28:10,680 --> 00:28:15,420
policies are enabled the iMRS type

00:28:13,080 --> 00:28:17,700
option boot parameter option is disabled

00:28:15,420 --> 00:28:20,430
so that it can be configured again at

00:28:17,700 --> 00:28:23,250
the runtime this option can be enabled

00:28:20,430 --> 00:28:26,010
by I mark policy Here I am showing an

00:28:23,250 --> 00:28:27,870
example of the policies as we are

00:28:26,010 --> 00:28:30,390
considering for the open power solution

00:28:27,870 --> 00:28:31,190
for the setup mode we do want to do

00:28:30,390 --> 00:28:33,050
measurement but

00:28:31,190 --> 00:28:35,720
don't want to do that pressure and this

00:28:33,050 --> 00:28:37,910
is where is the don't oppress but for

00:28:35,720 --> 00:28:39,920
the artist and usermod we want to do

00:28:37,910 --> 00:28:42,230
both mention episode so based on the

00:28:39,920 --> 00:28:46,760
secure boot the step the runtime the

00:28:42,230 --> 00:28:49,340
code will actually learn one of this so

00:28:46,760 --> 00:28:51,710
we started saying that imma can be used

00:28:49,340 --> 00:28:53,900
for this in a generic way but we found

00:28:51,710 --> 00:28:55,760
some problems we just talked about the

00:28:53,900 --> 00:28:57,980
solutions for those problems and if we

00:28:55,760 --> 00:28:59,840
combine them all of together here is how

00:28:57,980 --> 00:29:03,110
you see the solution of it as a complete

00:28:59,840 --> 00:29:04,430
worth the boot panel is loaded ha it

00:29:03,110 --> 00:29:06,680
checks the secure boot mode of the

00:29:04,430 --> 00:29:07,940
system if it is in the setup mode you

00:29:06,680 --> 00:29:09,260
don't we don't need any kind of

00:29:07,940 --> 00:29:12,260
verification

00:29:09,260 --> 00:29:15,200
so no keys are loaded onto the platform

00:29:12,260 --> 00:29:17,180
kidding no policies are set but if we

00:29:15,200 --> 00:29:19,550
get into the auditor user mode we need

00:29:17,180 --> 00:29:21,830
the keys so we load them we need a kiss

00:29:19,550 --> 00:29:24,920
from the former from the platform so we

00:29:21,830 --> 00:29:26,150
load them to the platform puny and now

00:29:24,920 --> 00:29:28,220
these keys are locked

00:29:26,150 --> 00:29:29,990
nobody can modify them later and these

00:29:28,220 --> 00:29:32,210
are isolated from other keys of which

00:29:29,990 --> 00:29:36,260
the kernel uses these are specifically

00:29:32,210 --> 00:29:38,420
available only in dot platform fee if it

00:29:36,260 --> 00:29:40,010
is in the audit mode the policies were

00:29:38,420 --> 00:29:42,170
argued and a user more the same the only

00:29:40,010 --> 00:29:44,840
difference is I am oppressed like is log

00:29:42,170 --> 00:29:47,000
for the audit mode but in case of the

00:29:44,840 --> 00:29:50,150
user mode I my press flag is enforced

00:29:47,000 --> 00:29:52,310
because he wants to make sure that if it

00:29:50,150 --> 00:29:55,880
if it fails to verify that you cannot it

00:29:52,310 --> 00:29:58,160
just doesn't boot and then we have the

00:29:55,880 --> 00:30:00,950
keys we have the certificates we have

00:29:58,160 --> 00:30:04,040
the policy and the petty boot fetches

00:30:00,950 --> 00:30:05,990
the kernel image ah it verifies the

00:30:04,040 --> 00:30:08,360
appended signature we have depended

00:30:05,990 --> 00:30:10,010
signature on it so it verifies dependent

00:30:08,360 --> 00:30:12,560
signature and if it is verified in an

00:30:10,010 --> 00:30:13,370
host OS is loaded so this how the all

00:30:12,560 --> 00:30:15,410
three programs

00:30:13,370 --> 00:30:18,940
solutions for those departments combined

00:30:15,410 --> 00:30:22,610
together gives us a complete solution

00:30:18,940 --> 00:30:24,710
here is the patch set status so we

00:30:22,610 --> 00:30:26,000
talked about three features appended

00:30:24,710 --> 00:30:28,730
signatures platform cleaning and

00:30:26,000 --> 00:30:29,780
architecture specific i'ma policies the

00:30:28,730 --> 00:30:31,760
two pet sets

00:30:29,780 --> 00:30:33,830
I must support for appended signatures

00:30:31,760 --> 00:30:36,620
and the platform feeding are awaiting

00:30:33,830 --> 00:30:38,000
the acceptance they are post they were

00:30:36,620 --> 00:30:41,270
posted and are available on these

00:30:38,000 --> 00:30:43,220
reference links for the i'ma support for

00:30:41,270 --> 00:30:45,440
architecture specific policies we are

00:30:43,220 --> 00:30:48,520
soliciting acts and reviews for the x86

00:30:45,440 --> 00:30:51,380
specific pictures which we have in that

00:30:48,520 --> 00:30:53,570
then the caddy I'm a measurement spy

00:30:51,380 --> 00:30:56,780
lacrosse k k exec is already up his name

00:30:53,570 --> 00:30:58,669
is Thiago mention then the loading keys

00:30:56,780 --> 00:31:01,159
into the platform kidding these are

00:30:58,669 --> 00:31:03,559
based on David hotel space his pad set

00:31:01,159 --> 00:31:06,470
keys blacklisting and UEFI database lot

00:31:03,559 --> 00:31:09,140
we have used two patches under like EFI

00:31:06,470 --> 00:31:11,270
ed EFI signature data types and Eden EFI

00:31:09,140 --> 00:31:13,820
signature block passer because open par

00:31:11,270 --> 00:31:17,539
also uses the ESL format for the keys

00:31:13,820 --> 00:31:20,299
sign for the keys so this is a work in

00:31:17,539 --> 00:31:22,270
progress and power specific our policies

00:31:20,299 --> 00:31:26,630
is the work in progress

00:31:22,270 --> 00:31:29,750
in summary i'ma provides the kernel best

00:31:26,630 --> 00:31:32,600
solution for the verifying the host OS

00:31:29,750 --> 00:31:36,740
to give us a secure boot solution I mean

00:31:32,600 --> 00:31:39,140
as part of our end-to-end solution we

00:31:36,740 --> 00:31:41,809
had three problems out of it for the

00:31:39,140 --> 00:31:43,730
kidding for the signature and for the

00:31:41,809 --> 00:31:46,400
policy we fixed them by introducing

00:31:43,730 --> 00:31:49,039
platform killing like specific policies

00:31:46,400 --> 00:31:51,260
and appended signatures we have the

00:31:49,039 --> 00:31:53,750
patch sets either in the state of up

00:31:51,260 --> 00:31:56,120
streaming awaiting acceptance or

00:31:53,750 --> 00:31:59,179
awaiting reviews are work in progress

00:31:56,120 --> 00:32:00,980
we welcome the community to test them do

00:31:59,179 --> 00:32:02,840
the reviews back you there in give your

00:32:00,980 --> 00:32:06,830
inputs and feedbacks whatever think

00:32:02,840 --> 00:32:09,530
about those and this is where I have the

00:32:06,830 --> 00:32:11,210
demo photo of these patches if anybody's

00:32:09,530 --> 00:32:15,890
interested we can I can show that later

00:32:11,210 --> 00:32:18,710
afterwards these are the references and

00:32:15,890 --> 00:32:21,080
this is acknowledgements for us team

00:32:18,710 --> 00:32:22,340
with what have the IBM LTS a security

00:32:21,080 --> 00:32:23,750
team who is working and we work in

00:32:22,340 --> 00:32:27,289
collaboration with the security research

00:32:23,750 --> 00:32:33,700
group and I've been power security and

00:32:27,289 --> 00:32:33,700
their power from your team yes questions

00:32:40,549 --> 00:32:47,130
could you give us some more details

00:32:42,929 --> 00:32:52,159
about kxan crash colonel and signing the

00:32:47,130 --> 00:32:56,240
its user space as the what I mean

00:32:52,159 --> 00:33:00,570
actually key exec is very often used to

00:32:56,240 --> 00:33:03,990
launch a crash Colonel which is able to

00:33:00,570 --> 00:33:09,450
export your map at the memory of your

00:33:03,990 --> 00:33:12,510
crushed colonel and use the use program

00:33:09,450 --> 00:33:15,350
core to dump its memory is it somehow

00:33:12,510 --> 00:33:15,350
affected

00:33:24,080 --> 00:33:35,520
and and there are two in this so

00:33:31,800 --> 00:33:38,340
basically the K exact file load is doing

00:33:35,520 --> 00:33:41,100
the signature verification and then all

00:33:38,340 --> 00:33:44,670
in order to and there are two patches

00:33:41,100 --> 00:33:47,460
and that's patch set which disable K

00:33:44,670 --> 00:33:51,980
exact load as well if you have the i'ma

00:33:47,460 --> 00:33:54,630
policy then and you're using the and

00:33:51,980 --> 00:33:57,990
you're using the Imus signature

00:33:54,630 --> 00:34:01,920
verification then it will prevent the k

00:33:57,990 --> 00:34:06,870
exact load but if you're using the

00:34:01,920 --> 00:34:11,610
 signature verification kernel see

00:34:06,870 --> 00:34:15,350
the architecture specific one then if

00:34:11,610 --> 00:34:20,040
you're not in secure boot mode it won't

00:34:15,350 --> 00:34:21,600
disable k the k exact load so it depends

00:34:20,040 --> 00:34:24,770
if you're in secure boot mode or you're

00:34:21,600 --> 00:34:24,770
not in secure boot mode

00:34:30,110 --> 00:34:38,030
right that was the compromise questions

00:34:41,990 --> 00:34:49,179
if not let's find speakers

00:34:45,040 --> 00:34:49,179

YouTube URL: https://www.youtube.com/watch?v=hwB1bkXQep4


