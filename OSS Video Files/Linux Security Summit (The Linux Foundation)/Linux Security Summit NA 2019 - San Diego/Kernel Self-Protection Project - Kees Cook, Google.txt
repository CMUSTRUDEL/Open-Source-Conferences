Title: Kernel Self-Protection Project - Kees Cook, Google
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Kernel Self-Protection Project - Kees Cook, Google 

This presentation will cover the year-in-review of the Kernel Self-Protection Project since the last Linux Security Summit NA. The project continues to eliminate classes of bugs and block exploitation techniques in the kernel. It will including an overview of all the security defenses landed in kernels 4.19 through 5.3. Some highlights are stack and heap auto-initialization, heap mapping robustness, per-task stack canaries, VLA removal, implicit-fallthrough removal, and the progress on upstreaming CFI.We'll also take a quick look at the evolution of kernel CVE lifetimes, find out what defenses are still under development, and note some areas where help is still needed.
Captions: 
	00:00:00,480 --> 00:00:05,850
hi sorry for the delay my laptop hates

00:00:03,929 --> 00:00:07,109
me

00:00:05,850 --> 00:00:11,280
anyway this is about the kernel

00:00:07,109 --> 00:00:14,490
protection project I'm just gonna switch

00:00:11,280 --> 00:00:18,060
pages on both so I can see my notes so

00:00:14,490 --> 00:00:20,340
this is like we talked about security

00:00:18,060 --> 00:00:23,279
and that's a pretty loaded word so I'm

00:00:20,340 --> 00:00:25,199
trying to describe some what this

00:00:23,279 --> 00:00:27,000
project is it's more than access control

00:00:25,199 --> 00:00:29,460
more than tax surface reduction bug

00:00:27,000 --> 00:00:31,349
fixing protecting user space this is

00:00:29,460 --> 00:00:33,980
mainly about the kernel protecting

00:00:31,349 --> 00:00:36,420
itself from attack

00:00:33,980 --> 00:00:38,430
it's like integrity alone doesn't cover

00:00:36,420 --> 00:00:41,160
the ideas around in stopping the methods

00:00:38,430 --> 00:00:46,649
attackers you use to gain control for

00:00:41,160 --> 00:00:48,329
example not a lot of people in this room

00:00:46,649 --> 00:00:51,960
need convincing as to why this is

00:00:48,329 --> 00:00:53,730
important but a lot of people do I kind

00:00:51,960 --> 00:00:56,190
of think about having two and a half

00:00:53,730 --> 00:01:03,210
billion devices running Linux as is

00:00:56,190 --> 00:01:05,100
pretty terrifying the one aspect I try

00:01:03,210 --> 00:01:06,960
to talk about a lot here is the lifetime

00:01:05,100 --> 00:01:08,760
of flaws that we're dealing with how

00:01:06,960 --> 00:01:12,840
long between when a flaw was introduced

00:01:08,760 --> 00:01:16,320
and released on a machine and when it

00:01:12,840 --> 00:01:19,290
actually gets fixed it's very long even

00:01:16,320 --> 00:01:20,640
from the perspective of the software

00:01:19,290 --> 00:01:22,560
maintenance just looking at the Linux

00:01:20,640 --> 00:01:25,310
kernel project itself like oh we fixed

00:01:22,560 --> 00:01:27,330
it from you know in however many months

00:01:25,310 --> 00:01:30,509
but that doesn't tell you anything about

00:01:27,330 --> 00:01:32,070
the deployed systems so trying to come

00:01:30,509 --> 00:01:34,979
up with defensive strategy just to

00:01:32,070 --> 00:01:37,470
minimize that damage and and make it so

00:01:34,979 --> 00:01:39,350
fewer flaws actually become security

00:01:37,470 --> 00:01:41,850
vulnerabilities is pretty important and

00:01:39,350 --> 00:01:43,500
shouldn't be considered not our problem

00:01:41,850 --> 00:01:49,049
from the you know kernel development

00:01:43,500 --> 00:01:53,250
community I was inspired by John

00:01:49,049 --> 00:01:54,990
Corbett's analysis of CVEs looking at

00:01:53,250 --> 00:01:56,790
the history and trying to say when was

00:01:54,990 --> 00:01:58,740
something introduced and when was it

00:01:56,790 --> 00:02:02,040
fixed that's the lifetime I was talking

00:01:58,740 --> 00:02:03,899
about and he'd come up with it it's

00:02:02,040 --> 00:02:05,159
about five years between when something

00:02:03,899 --> 00:02:08,340
was introduced and when it was fixed

00:02:05,159 --> 00:02:12,239
which seemed insanely long to me but it

00:02:08,340 --> 00:02:13,360
turns out that's pretty stable I've been

00:02:12,239 --> 00:02:15,580
using the

00:02:13,360 --> 00:02:18,190
the bunju CV tracker to look at Colonel

00:02:15,580 --> 00:02:21,070
security flaws since their colonel team

00:02:18,190 --> 00:02:22,750
tends to find you know when was

00:02:21,070 --> 00:02:23,890
something introduced so they can figure

00:02:22,750 --> 00:02:26,500
out if they need to back port it to

00:02:23,890 --> 00:02:28,330
whatever kernel versions they've got I

00:02:26,500 --> 00:02:30,280
was concerned for a while because the

00:02:28,330 --> 00:02:32,440
average was starting to grow closer to

00:02:30,280 --> 00:02:35,200
six years and I started to think it was

00:02:32,440 --> 00:02:36,810
because in doing your analysis you're

00:02:35,200 --> 00:02:40,300
looking up to the end of getting history

00:02:36,810 --> 00:02:42,730
and your averages kept growing because

00:02:40,300 --> 00:02:44,470
well things were you know the flaw was

00:02:42,730 --> 00:02:46,690
introduced prior to get history so the

00:02:44,470 --> 00:02:49,000
further away you get from it the longer

00:02:46,690 --> 00:02:52,300
the average is between fixing it luckily

00:02:49,000 --> 00:02:56,200
this has gotten better and I have some

00:02:52,300 --> 00:02:59,920
graphs to sort of demonstrate that it's

00:02:56,200 --> 00:03:02,440
kernel versions on the side beginning to

00:02:59,920 --> 00:03:05,080
get history is at the bottom current

00:03:02,440 --> 00:03:08,950
releases at the top and the bar is how

00:03:05,080 --> 00:03:10,180
long things were exposed for and we've

00:03:08,950 --> 00:03:12,550
got I'm only paying attention to

00:03:10,180 --> 00:03:14,890
critical in high CVS because I would go

00:03:12,550 --> 00:03:17,680
blind trying to analyze all the medium

00:03:14,890 --> 00:03:21,520
and lows so the data is pretty noisy for

00:03:17,680 --> 00:03:24,700
those but this is pretty decent this

00:03:21,520 --> 00:03:28,420
also I note ignores the mitigations for

00:03:24,700 --> 00:03:30,520
CPU issues because those aren't bugs in

00:03:28,420 --> 00:03:34,120
the Linux kernel software otherwise

00:03:30,520 --> 00:03:35,830
things would look completely insane it's

00:03:34,120 --> 00:03:38,260
also worth noting that this is a subset

00:03:35,830 --> 00:03:41,380
of flaws this is things that got a CV

00:03:38,260 --> 00:03:45,190
identifier and not all flaws actually

00:03:41,380 --> 00:03:48,459
end up with those identifiers so this is

00:03:45,190 --> 00:03:50,290
sort of the what I would think of as the

00:03:48,459 --> 00:03:51,520
best-case scenario of what you're

00:03:50,290 --> 00:03:53,350
looking at as far as lifetimes because

00:03:51,520 --> 00:03:55,540
you don't have data on the things that

00:03:53,350 --> 00:04:00,910
were fixed and stable updates at another

00:03:55,540 --> 00:04:02,050
time and a lot of people say have have

00:04:00,910 --> 00:04:05,110
said in the past well this is all

00:04:02,050 --> 00:04:06,550
theoretical no one noticed that the you

00:04:05,110 --> 00:04:10,300
know this flaw was open for five years

00:04:06,550 --> 00:04:12,970
and that's just not true and thankfully

00:04:10,300 --> 00:04:15,880
we've had some cases where black hats

00:04:12,970 --> 00:04:17,169
would happily boast about them finding

00:04:15,880 --> 00:04:20,080
it the day it was committed and

00:04:17,169 --> 00:04:22,120
exploiting it for a couple years this

00:04:20,080 --> 00:04:24,340
linked one is you know they found

00:04:22,120 --> 00:04:26,520
something in 2008 and used it until it

00:04:24,340 --> 00:04:30,210
was fixed in 2010

00:04:26,520 --> 00:04:32,460
but as it turns out most most people

00:04:30,210 --> 00:04:34,139
doing this kind of attack work are not

00:04:32,460 --> 00:04:37,740
interested in telling you about the fact

00:04:34,139 --> 00:04:41,280
that they have a flaw so there's a small

00:04:37,740 --> 00:04:44,629
look into that but um bug fighting

00:04:41,280 --> 00:04:47,009
continues we're finding a lot of bugs

00:04:44,629 --> 00:04:49,020
faster and faster but we're introducing

00:04:47,009 --> 00:04:51,030
them faster and faster so it's it's a

00:04:49,020 --> 00:04:52,650
weird steady state we have a lot of

00:04:51,030 --> 00:04:54,689
tools static checkers and dynamic

00:04:52,650 --> 00:04:57,389
checkers are doing a good job

00:04:54,689 --> 00:04:59,520
you could ask Greg KH about how many

00:04:57,389 --> 00:05:02,639
patches end up going into the stable

00:04:59,520 --> 00:05:04,169
kernels and and you can ask me also

00:05:02,639 --> 00:05:08,129
because I looked it up for this talk as

00:05:04,169 --> 00:05:10,550
of for 1967 the last the most recent

00:05:08,129 --> 00:05:13,500
stable release that is an LTS release

00:05:10,550 --> 00:05:17,490
there are six thousand six hundred and

00:05:13,500 --> 00:05:19,800
ten fix commits which is like 98 fixes

00:05:17,490 --> 00:05:23,190
per stable release which is usually

00:05:19,800 --> 00:05:28,830
weekly or sometimes more frequently than

00:05:23,190 --> 00:05:31,560
that a great analogy from Constantine a

00:05:28,830 --> 00:05:35,400
while back was looking at the the car

00:05:31,560 --> 00:05:37,710
industry in the 1960s which was that

00:05:35,400 --> 00:05:41,490
cars like computers now have been

00:05:37,710 --> 00:05:42,839
designed to run not to fail the idea

00:05:41,490 --> 00:05:44,699
being that you can comfortably drive

00:05:42,839 --> 00:05:46,860
down the highway and everything's great

00:05:44,699 --> 00:05:49,379
and things work correctly but then you

00:05:46,860 --> 00:05:52,770
blow a tire and everyone dies so we

00:05:49,379 --> 00:05:55,770
actually want to get past the 1960s car

00:05:52,770 --> 00:05:59,490
thing and get caught up the picture here

00:05:55,770 --> 00:06:02,819
is a 2009 Chevy Malibu in a head-on

00:05:59,490 --> 00:06:04,740
collision with a 1959 Bel Air so it's a

00:06:02,819 --> 00:06:08,250
50 years difference in car technology

00:06:04,740 --> 00:06:12,120
and the entire front cabin of the 59 car

00:06:08,250 --> 00:06:16,319
has been obliterated and the the 2009 is

00:06:12,120 --> 00:06:17,849
looking pretty decent so we should get

00:06:16,319 --> 00:06:19,589
caught up because yes we know how to run

00:06:17,849 --> 00:06:23,659
but we really really do not know how to

00:06:19,589 --> 00:06:28,800
fail correctly we need to fail safely

00:06:23,659 --> 00:06:31,349
and some people do not necessarily think

00:06:28,800 --> 00:06:33,330
about where all the things you know

00:06:31,349 --> 00:06:37,620
where Linux is used and how how it

00:06:33,330 --> 00:06:38,700
affects people's actual lives an example

00:06:37,620 --> 00:06:41,730
being the there's

00:06:38,700 --> 00:06:43,830
a few Tech's Colonel bug in 2014 that

00:06:41,730 --> 00:06:45,690
was turned into towel route for routing

00:06:43,830 --> 00:06:48,810
Android phones which was co-opted by a

00:06:45,690 --> 00:06:51,210
hacking team who sold it as a weapon to

00:06:48,810 --> 00:06:52,530
oppressive regimes who in turn targeted

00:06:51,210 --> 00:06:54,780
activists and their families and stuff

00:06:52,530 --> 00:06:57,120
like that so it's it actually is more

00:06:54,780 --> 00:07:04,740
than oh no my server crashed it can get

00:06:57,120 --> 00:07:06,900
kind of dicey we want to do our best so

00:07:04,740 --> 00:07:11,460
getting back to yes it's good to kill

00:07:06,900 --> 00:07:14,070
bugs we have to do it but we need to do

00:07:11,460 --> 00:07:16,200
a little bit better than that so if we

00:07:14,070 --> 00:07:20,160
move on we could say well let's kill

00:07:16,200 --> 00:07:22,080
entire bug classes so that none of those

00:07:20,160 --> 00:07:23,550
bugs ever come back we will not

00:07:22,080 --> 00:07:25,050
reintroduce them because we've stopped

00:07:23,550 --> 00:07:28,440
ourselves from ever having that problem

00:07:25,050 --> 00:07:30,180
begin with and this means also out of

00:07:28,440 --> 00:07:32,550
tree code can't hit those bugs because

00:07:30,180 --> 00:07:33,810
the infrastructure or usage pattern for

00:07:32,550 --> 00:07:38,040
creating that bug has gone away

00:07:33,810 --> 00:07:41,100
completely and better still is stopping

00:07:38,040 --> 00:07:43,440
exploitation methods since we're always

00:07:41,100 --> 00:07:45,980
going to have bugs make sure that the

00:07:43,440 --> 00:07:48,450
kernel itself is not easy to to really

00:07:45,980 --> 00:07:49,830
take advantage of as an attacker there's

00:07:48,450 --> 00:07:51,060
a lot of infrastructural things that are

00:07:49,830 --> 00:07:52,440
weak inside the kernel for no good

00:07:51,060 --> 00:07:54,440
reason

00:07:52,440 --> 00:07:57,600
they're just designed the way they are

00:07:54,440 --> 00:08:01,290
because there wasn't you know it it runs

00:07:57,600 --> 00:08:03,000
fine but it doesn't fail safely one

00:08:01,290 --> 00:08:05,760
issue with this that there's a lot of

00:08:03,000 --> 00:08:07,760
pushback on is sometimes these changes

00:08:05,760 --> 00:08:10,140
make the lives of developers harder

00:08:07,760 --> 00:08:12,240
going back to the car analogy it's kind

00:08:10,140 --> 00:08:14,670
of like well I put a you know a titanium

00:08:12,240 --> 00:08:16,560
plate along the door but now there isn't

00:08:14,670 --> 00:08:17,580
room for the window to roll down so

00:08:16,560 --> 00:08:20,130
we've got a whole new engineering

00:08:17,580 --> 00:08:21,960
problem for that and sort of getting

00:08:20,130 --> 00:08:23,790
people to accept the responsibility of

00:08:21,960 --> 00:08:28,440
oK we've got to work around the defenses

00:08:23,790 --> 00:08:31,530
that we're putting in place so and

00:08:28,440 --> 00:08:36,930
actually the best is probably not using

00:08:31,530 --> 00:08:39,599
C at all so and while I'd like to get

00:08:36,930 --> 00:08:42,950
the kernel move to a galaxy brain level

00:08:39,599 --> 00:08:45,990
of memory safety languages like say rust

00:08:42,950 --> 00:08:48,000
that's really realistically going to

00:08:45,990 --> 00:08:52,140
take a very long time

00:08:48,000 --> 00:08:54,720
so in the meantime there's the kernel

00:08:52,140 --> 00:08:57,090
subduction project and this is aimed at

00:08:54,720 --> 00:08:59,370
protecting the kernel from attack it's

00:08:57,090 --> 00:09:02,760
there's really a lot of people involved

00:08:59,370 --> 00:09:04,230
you know some people spend you know all

00:09:02,760 --> 00:09:05,910
of their time working on it some people

00:09:04,230 --> 00:09:07,890
just show up and do things on the

00:09:05,910 --> 00:09:09,420
weekends it's individuals and

00:09:07,890 --> 00:09:11,850
organizations

00:09:09,420 --> 00:09:15,030
I used to say our progress was slow and

00:09:11,850 --> 00:09:16,410
steady but I liked Alexander's comment

00:09:15,030 --> 00:09:20,430
that instead we should be considered a

00:09:16,410 --> 00:09:23,910
flexible and persistence and he had a

00:09:20,430 --> 00:09:25,170
great version of that the numbers of

00:09:23,910 --> 00:09:29,640
people involved are kind of hard to

00:09:25,170 --> 00:09:33,030
count but that's why I'm up here to sort

00:09:29,640 --> 00:09:36,060
of represent all of that work so without

00:09:33,030 --> 00:09:38,520
further ado this is sort of a year's

00:09:36,060 --> 00:09:41,280
worth of kernel releases and some

00:09:38,520 --> 00:09:45,570
details about things that were going on

00:09:41,280 --> 00:09:49,230
so V lays are you know variable-length

00:09:45,570 --> 00:09:50,790
arrays sized on the stack at runtime and

00:09:49,230 --> 00:09:52,140
have been a source of a lot of problems

00:09:50,790 --> 00:09:55,290
so there was an effort to remove them

00:09:52,140 --> 00:09:56,790
and 419 we're getting very very close to

00:09:55,290 --> 00:09:59,990
getting rid of it completely we're

00:09:56,790 --> 00:10:02,340
making conversion from atomic types to a

00:09:59,990 --> 00:10:03,750
tested ref count type that is still

00:10:02,340 --> 00:10:05,850
atomic but it would actually check for

00:10:03,750 --> 00:10:08,940
overflows and under flows and those are

00:10:05,850 --> 00:10:11,400
slowly trickling conversions conversions

00:10:08,940 --> 00:10:13,800
in and I also started looking at places

00:10:11,400 --> 00:10:16,530
where bugs have been found due to the

00:10:13,800 --> 00:10:19,110
fact that ref county is in use in the

00:10:16,530 --> 00:10:20,520
kernel and we just keep getting them

00:10:19,110 --> 00:10:22,140
more and more bugs keep showing up

00:10:20,520 --> 00:10:23,970
because someone says oh look we actually

00:10:22,140 --> 00:10:27,690
tripped on the on the underflow and

00:10:23,970 --> 00:10:30,330
overflow another systemic issue was

00:10:27,690 --> 00:10:32,970
implicit fall through markings for C's

00:10:30,330 --> 00:10:35,880
switch statement and switch you have a

00:10:32,970 --> 00:10:38,910
series of cases and when you want to

00:10:35,880 --> 00:10:40,920
leave you say break and you have the

00:10:38,910 --> 00:10:42,960
option of falling through to the next

00:10:40,920 --> 00:10:45,840
case to continue processing in some way

00:10:42,960 --> 00:10:48,750
over there is no semantic information to

00:10:45,840 --> 00:10:51,240
say I meant to fall through here as

00:10:48,750 --> 00:10:53,820
opposed to oops I forgot to write break

00:10:51,240 --> 00:10:55,110
there is not a fall through mark of any

00:10:53,820 --> 00:10:58,259
kind

00:10:55,110 --> 00:11:01,019
and this this has led to a a lot of

00:10:58,259 --> 00:11:02,759
interesting or hard to notice bugs so

00:11:01,019 --> 00:11:06,660
we've been trying to mark all these

00:11:02,759 --> 00:11:09,750
implicit falters and so an example here

00:11:06,660 --> 00:11:12,180
is put in 129 markings and found in the

00:11:09,750 --> 00:11:14,000
process three different situations where

00:11:12,180 --> 00:11:17,100
break was missing like legitimate bugs

00:11:14,000 --> 00:11:20,610
we've got some shift overflow helpers to

00:11:17,100 --> 00:11:22,259
expand the the the overflow the

00:11:20,610 --> 00:11:26,300
multiplication in addition overflow

00:11:22,259 --> 00:11:29,420
helpers CPU vulnerability mitigations

00:11:26,300 --> 00:11:33,779
further restrictions and temp files for

00:11:29,420 --> 00:11:37,819
for fie pose and regular files and then

00:11:33,779 --> 00:11:40,439
clearing this clearing registers on

00:11:37,819 --> 00:11:42,509
there like unused register clearing on

00:11:40,439 --> 00:11:45,300
this call entry so that they do not they

00:11:42,509 --> 00:11:50,189
can't be used for leaking stuff into

00:11:45,300 --> 00:11:53,069
speculation flaws and 4.20 valets were

00:11:50,189 --> 00:11:55,470
completely removed I kind of like to

00:11:53,069 --> 00:11:56,939
talk about the in the in the time span

00:11:55,470 --> 00:11:58,500
it took to get rid of all of Elah is

00:11:56,939 --> 00:12:02,519
because it was started much earlier than

00:11:58,500 --> 00:12:04,350
419 I talked about it last year system D

00:12:02,519 --> 00:12:05,970
I think had two exploitable

00:12:04,350 --> 00:12:09,540
vulnerabilities due to using via lays

00:12:05,970 --> 00:12:12,569
like this is just not a safe feature to

00:12:09,540 --> 00:12:14,670
be used in c-more ref count conversions

00:12:12,569 --> 00:12:16,620
more implicit fall through markings the

00:12:14,670 --> 00:12:19,019
stack leak plugin for clearing the stack

00:12:16,620 --> 00:12:22,439
on cisco exits you have you don't have

00:12:19,019 --> 00:12:25,550
uninitialized state elena talked about

00:12:22,439 --> 00:12:28,290
this a little bit earlier this week

00:12:25,550 --> 00:12:30,449
stack Canaries on other architectures

00:12:28,290 --> 00:12:32,730
weren't per task there would be one

00:12:30,449 --> 00:12:34,860
stack canary for all tasks it would be

00:12:32,730 --> 00:12:36,990
per boot which was not great for leaking

00:12:34,860 --> 00:12:40,889
information if you could leak from one

00:12:36,990 --> 00:12:44,850
task you could attack another task more

00:12:40,889 --> 00:12:47,910
read-only memory areas and then to

00:12:44,850 --> 00:12:51,329
quickly talk about a bottom one

00:12:47,910 --> 00:12:53,430
a recent refactoring of weight ID

00:12:51,329 --> 00:12:55,559
introduced a trivially exploitable

00:12:53,430 --> 00:12:59,459
controlled kernel memory override flaw

00:12:55,559 --> 00:13:02,100
and none of the fuzzers noticed it and

00:12:59,459 --> 00:13:04,769
it's because faults through the copy to

00:13:02,100 --> 00:13:07,620
and from user if they end up targeting

00:13:04,769 --> 00:13:08,670
kernel memory and that kernel memory say

00:13:07,620 --> 00:13:10,769
is not

00:13:08,670 --> 00:13:12,839
because it just happened to be in a hole

00:13:10,769 --> 00:13:14,339
somewhere the fault would look like it

00:13:12,839 --> 00:13:16,230
was unmapped userspace memory there was

00:13:14,339 --> 00:13:18,839
no distinction being made so everything

00:13:16,230 --> 00:13:20,639
would just either you know fail quiet

00:13:18,839 --> 00:13:21,810
you know quietly or would terribly

00:13:20,639 --> 00:13:24,300
corrupt the system and would be found

00:13:21,810 --> 00:13:26,459
much later so actually getting faults

00:13:24,300 --> 00:13:31,949
out of this means that really obvious

00:13:26,459 --> 00:13:37,139
bugs can now be found in there and 5.0

00:13:31,949 --> 00:13:39,540
we've got more conversions arm 64 gained

00:13:37,139 --> 00:13:43,019
a bunch of features on the the linear

00:13:39,540 --> 00:13:45,300
mapping used to be read and write and

00:13:43,019 --> 00:13:47,730
the idea was you could just manipulate

00:13:45,300 --> 00:13:50,670
that memory directly even though the

00:13:47,730 --> 00:13:52,499
other memory like the other not on the

00:13:50,670 --> 00:13:54,569
other portions of memory were no longer

00:13:52,499 --> 00:13:56,040
had individual markings you could you

00:13:54,569 --> 00:13:58,439
could still manipulate the direct map

00:13:56,040 --> 00:14:01,879
and write to it as a target so that's

00:13:58,439 --> 00:14:04,559
made read-only more per task Canaries

00:14:01,879 --> 00:14:07,230
some top byte ignore stuff for helping

00:14:04,559 --> 00:14:11,509
sort of pave the way for memory tagging

00:14:07,230 --> 00:14:14,730
which I'll talk about briefly and

00:14:11,509 --> 00:14:16,410
pointer authentication on arm 64 and a

00:14:14,730 --> 00:14:20,550
kernel only keyring that you can't get

00:14:16,410 --> 00:14:23,809
out to can't get out from user space in

00:14:20,550 --> 00:14:28,139
5.1 we've got more ref count conversions

00:14:23,809 --> 00:14:31,620
more bugs and you're starting to see

00:14:28,139 --> 00:14:35,309
like the number of implicit falters

00:14:31,620 --> 00:14:37,709
found on averages it's about 10 percent

00:14:35,309 --> 00:14:40,379
so 10 percent of the places where there

00:14:37,709 --> 00:14:42,779
was no break the break was supposed to

00:14:40,379 --> 00:14:46,529
be there which is to me an extremely

00:14:42,779 --> 00:14:52,230
high bug ratio on these things so it's

00:14:46,529 --> 00:14:54,329
nice to soon be rid of it got pit FD for

00:14:52,230 --> 00:14:57,059
having a stable interface for talking

00:14:54,329 --> 00:15:02,579
about processes as slowly one interface

00:14:57,059 --> 00:15:04,829
at a time as being introduced at LCA

00:15:02,579 --> 00:15:07,949
there was some discussion on validating

00:15:04,829 --> 00:15:09,689
how heap memory gets mapped into user

00:15:07,949 --> 00:15:11,220
space and there were some ideas about oh

00:15:09,689 --> 00:15:13,319
here are some cases that we don't check

00:15:11,220 --> 00:15:15,120
for that should be invalid and that

00:15:13,319 --> 00:15:17,279
change was made and immediately found

00:15:15,120 --> 00:15:19,589
two bugs so clearly this was an area

00:15:17,279 --> 00:15:21,370
that needed helping LSM the first

00:15:19,589 --> 00:15:23,440
pasteles i'm stacking

00:15:21,370 --> 00:15:26,560
and 5.1 that which got talked about

00:15:23,440 --> 00:15:29,440
earlier the safe said IDL SM which was

00:15:26,560 --> 00:15:31,240
for scoping the ability of the

00:15:29,440 --> 00:15:34,060
capability of lets you change to any

00:15:31,240 --> 00:15:35,410
user being able to define a mapping of

00:15:34,060 --> 00:15:37,330
what users are actually able to

00:15:35,410 --> 00:15:39,550
transition to and from to and from

00:15:37,330 --> 00:15:41,230
because if you give that capability out

00:15:39,550 --> 00:15:43,540
suddenly you can become anybody on the

00:15:41,230 --> 00:15:46,450
system which seemed a bit strong for

00:15:43,540 --> 00:15:50,620
being able to make make you ID

00:15:46,450 --> 00:15:52,170
transitions and then for stack getting

00:15:50,620 --> 00:15:55,330
rid of an initialized stack variables

00:15:52,170 --> 00:15:57,640
the GCC plugin for that learned how to

00:15:55,330 --> 00:15:59,230
initialize scalars because before it was

00:15:57,640 --> 00:16:01,360
only initializing things that passed by

00:15:59,230 --> 00:16:03,580
reference so you if you were ignoring

00:16:01,360 --> 00:16:05,020
warnings when building a kernel and the

00:16:03,580 --> 00:16:07,300
warning would say hey you forgot to

00:16:05,020 --> 00:16:09,250
initialize this scalar on the stack and

00:16:07,300 --> 00:16:10,930
you ignored it it would be an

00:16:09,250 --> 00:16:13,360
uninitialized variable and this now

00:16:10,930 --> 00:16:17,320
would that plug-in it'll warn but you

00:16:13,360 --> 00:16:22,390
will actually get it initialized and in

00:16:17,320 --> 00:16:26,230
5.1 were or 5.2 sorry more conversions

00:16:22,390 --> 00:16:28,810
more pit ft we've had the free list

00:16:26,230 --> 00:16:30,459
randomized for the slab allocator but

00:16:28,810 --> 00:16:33,970
not the page allocator and that's been

00:16:30,459 --> 00:16:36,279
added now stack variable auto

00:16:33,970 --> 00:16:38,470
initialization is now natively available

00:16:36,279 --> 00:16:39,670
in clang so it's it's not a GCC plugin

00:16:38,470 --> 00:16:42,970
but it's a clang option if you're

00:16:39,670 --> 00:16:47,950
building clang PowerPC gain similar to

00:16:42,970 --> 00:16:52,060
the S map protections more speculation

00:16:47,950 --> 00:16:54,700
things user fault ft gained assist

00:16:52,060 --> 00:16:56,650
control knob to make it a a privileged

00:16:54,700 --> 00:16:58,270
only operation because you could you

00:16:56,650 --> 00:17:01,480
could get the kernel to arbitrarily

00:16:58,270 --> 00:17:03,640
stall on user space accesses which would

00:17:01,480 --> 00:17:06,429
gives you a lot of temporal control over

00:17:03,640 --> 00:17:07,839
making attacks so that's been you have

00:17:06,429 --> 00:17:09,640
the option of turning it off now

00:17:07,839 --> 00:17:13,990
because it was really only KVM that

00:17:09,640 --> 00:17:16,510
needed it and then a temporary memory

00:17:13,990 --> 00:17:19,569
map for doing kernel text poking and my

00:17:16,510 --> 00:17:22,329
hope is to start to use that to have to

00:17:19,569 --> 00:17:25,150
turn more of the kernel area read-only

00:17:22,329 --> 00:17:27,069
at rest and we can go in and update

00:17:25,150 --> 00:17:28,690
things similar to how we update the text

00:17:27,069 --> 00:17:31,290
segment we can update data segment and

00:17:28,690 --> 00:17:31,290
in a similar fashion

00:17:32,660 --> 00:17:38,810
so expecting for 5.3 we're at we're at

00:17:36,830 --> 00:17:40,250
rc5 now so it's a couple more weeks and

00:17:38,810 --> 00:17:41,420
then we'll have five about three so I'm

00:17:40,250 --> 00:17:43,400
pretty sure all these things are gonna

00:17:41,420 --> 00:17:46,130
happen the implicit mark through the

00:17:43,400 --> 00:17:49,190
implicit fall through markings are now

00:17:46,130 --> 00:17:51,440
done so we're actually building with the

00:17:49,190 --> 00:17:53,990
warning enabled and again you can see

00:17:51,440 --> 00:17:55,910
about ten percent of the the cases found

00:17:53,990 --> 00:17:58,250
we're actually missing a break so this

00:17:55,910 --> 00:18:02,360
is held all the way through we've fixed

00:17:58,250 --> 00:18:07,490
a lot of bugs and more conversions more

00:18:02,360 --> 00:18:10,610
fit ft so on x86 a common target for

00:18:07,490 --> 00:18:14,240
trying to bypass s map and SAS MEP was

00:18:10,610 --> 00:18:17,690
to manipulate cr4 and cr0 the turn off

00:18:14,240 --> 00:18:22,190
SMA P and s MEP so now we pin those bits

00:18:17,690 --> 00:18:25,670
on you so if you are attempting a wrap a

00:18:22,190 --> 00:18:27,440
simple wrap chain of some kind you can't

00:18:25,670 --> 00:18:28,850
just use the native functions that exist

00:18:27,440 --> 00:18:32,120
in the kernel to do that anymore you'd

00:18:28,850 --> 00:18:34,010
actually have to have built your own so

00:18:32,120 --> 00:18:37,820
it makes that more difficult it's no

00:18:34,010 --> 00:18:41,210
longer trivial and we've gained heap

00:18:37,820 --> 00:18:43,670
auto initialization so we have that four

00:18:41,210 --> 00:18:47,060
stack now but you can actually boot a

00:18:43,670 --> 00:18:51,050
5.3 kernel and say I want to treat all

00:18:47,060 --> 00:18:52,640
came Alok as if it were a KZ Alok so

00:18:51,050 --> 00:18:55,460
that everything you get out of out of

00:18:52,640 --> 00:18:58,640
the allocator has been zeroed this has

00:18:55,460 --> 00:19:00,440
not been like the performance on that

00:18:58,640 --> 00:19:02,090
has not been optimized yet the idea was

00:19:00,440 --> 00:19:03,560
to get that feature landed and then say

00:19:02,090 --> 00:19:06,290
okay what are the use cases where this

00:19:03,560 --> 00:19:08,270
is obviously stupid where you you know

00:19:06,290 --> 00:19:09,470
allocates memory zero it and then

00:19:08,270 --> 00:19:11,390
immediately fill it with something or

00:19:09,470 --> 00:19:13,610
allocate it zero it and then zero it

00:19:11,390 --> 00:19:14,750
again like finding those cases and

00:19:13,610 --> 00:19:17,000
getting rid of them getting rid of that

00:19:14,750 --> 00:19:19,160
redundancy is work for the future and

00:19:17,000 --> 00:19:21,410
adding more K free sanity checking

00:19:19,160 --> 00:19:23,630
because you could hand K free any kind

00:19:21,410 --> 00:19:26,330
of random pointer and it would attempt

00:19:23,630 --> 00:19:31,700
to do things with it

00:19:26,330 --> 00:19:35,220
and 45.4 more pit ft the kernel lock

00:19:31,700 --> 00:19:37,770
down LS m and hopefully we'll go in

00:19:35,220 --> 00:19:41,100
and we've gained some other helpers for

00:19:37,770 --> 00:19:43,500
string manipulation because frequently

00:19:41,100 --> 00:19:45,450
people pass the wrong size to various

00:19:43,500 --> 00:19:46,919
string copies when they're just dealing

00:19:45,450 --> 00:19:48,660
with an array and you can actually know

00:19:46,919 --> 00:19:54,660
at compile time the size of that array

00:19:48,660 --> 00:19:56,309
so you can use a helper instead various

00:19:54,660 --> 00:19:58,620
features that are coming there's the

00:19:56,309 --> 00:20:00,419
open patch set for improving pathname

00:19:58,620 --> 00:20:03,710
resolution because there's all kinds of

00:20:00,419 --> 00:20:06,600
weird esoteric ways to bypass and escape

00:20:03,710 --> 00:20:08,669
containers and namespaces and whatever

00:20:06,600 --> 00:20:11,640
else and that's going to address a lot

00:20:08,669 --> 00:20:14,669
of those things I'd like to split out

00:20:11,640 --> 00:20:16,350
integer overflow detection so that we

00:20:14,669 --> 00:20:18,659
can start getting rid of that as an

00:20:16,350 --> 00:20:21,240
entire class of problem link time

00:20:18,659 --> 00:20:26,700
optimization and control flow integrity

00:20:21,240 --> 00:20:28,880
are working on Android the arm 64 builds

00:20:26,700 --> 00:20:31,380
with clang you can actually do this

00:20:28,880 --> 00:20:33,539
slowly getting into upstream as we

00:20:31,380 --> 00:20:36,600
trickle bits and pieces and fight bugs

00:20:33,539 --> 00:20:38,880
and LLVM and other things there's a lot

00:20:36,600 --> 00:20:43,620
of other stuff here that's that's

00:20:38,880 --> 00:20:45,210
getting worked on and move on to talking

00:20:43,620 --> 00:20:48,600
about the challenges we've got the the

00:20:45,210 --> 00:20:49,950
conservatism from from just the people

00:20:48,600 --> 00:20:51,929
not whining make changes the kernel took

00:20:49,950 --> 00:20:55,230
16 years to get symlink restrictions in

00:20:51,929 --> 00:20:58,280
upstream so that that defense can can

00:20:55,230 --> 00:21:00,900
drive in the united states now and

00:20:58,280 --> 00:21:02,820
there's some responsibility issues like

00:21:00,900 --> 00:21:06,929
its kernel developers we have to accept

00:21:02,820 --> 00:21:08,610
the need for these changes and we have

00:21:06,929 --> 00:21:10,440
to sort of accept the technical burden

00:21:08,610 --> 00:21:12,030
and make that sacrifice and have

00:21:10,440 --> 00:21:14,669
patience on explaining to out of tree

00:21:12,030 --> 00:21:16,289
developers how the kernel is developed

00:21:14,669 --> 00:21:18,360
like it's a very evolutionary process

00:21:16,289 --> 00:21:20,490
and we've obviously got the the

00:21:18,360 --> 00:21:22,669
technical and resource challenges so if

00:21:20,490 --> 00:21:28,710
you want to help out with anything here

00:21:22,669 --> 00:21:31,409
please let me know and that's it you can

00:21:28,710 --> 00:21:35,460
get a copy of the slides it's the the

00:21:31,409 --> 00:21:37,770
wiki page for the for the project and

00:21:35,460 --> 00:21:40,789
that's it any any questions I'm not sure

00:21:37,770 --> 00:21:40,789
how over time I am

00:21:41,919 --> 00:21:44,919
okay

00:21:51,659 --> 00:21:57,789
so I think you mentioned cr4 and zero

00:21:55,390 --> 00:21:59,320
zero pending on x86 yeah so what would

00:21:57,789 --> 00:22:01,059
that mean in terms of like unlocking

00:21:59,320 --> 00:22:03,450
write-protect for example if I wanted to

00:22:01,059 --> 00:22:06,130
do that within a kernel module

00:22:03,450 --> 00:22:11,169
presumably I would be able to do it you

00:22:06,130 --> 00:22:13,710
write your own routine the disabling

00:22:11,169 --> 00:22:16,630
write-protect is explicitly not

00:22:13,710 --> 00:22:20,649
supported by as declared by the x86

00:22:16,630 --> 00:22:22,539
maintainer x' um but I do have a kernel

00:22:20,649 --> 00:22:24,340
module that does that because when I

00:22:22,539 --> 00:22:26,169
boot up I load that module and I turn

00:22:24,340 --> 00:22:28,419
off all kinds of things in the kernel

00:22:26,169 --> 00:22:30,669
that I can't get at normally and then I

00:22:28,419 --> 00:22:35,769
unload the module and turn off module

00:22:30,669 --> 00:22:37,720
loading so yeah thanks it will be out of

00:22:35,769 --> 00:22:44,679
tree just so you know your module will

00:22:37,720 --> 00:22:46,710
stay out of tree great thinking

00:22:44,679 --> 00:22:49,630
specifically about the memory corruption

00:22:46,710 --> 00:22:51,010
exploit mitigation piece one of the

00:22:49,630 --> 00:22:52,840
things that's been observed many times

00:22:51,010 --> 00:22:55,779
is anybody can build a lock that they

00:22:52,840 --> 00:22:57,809
themselves cannot pick what is the

00:22:55,779 --> 00:23:00,010
kernel self protection project sort of

00:22:57,809 --> 00:23:02,860
vulnerability research or like making

00:23:00,010 --> 00:23:05,710
sure these things really work strategy I

00:23:02,860 --> 00:23:08,980
write really simplistic tests for all

00:23:05,710 --> 00:23:10,659
these mitigations the lkd TM tool

00:23:08,980 --> 00:23:12,789
basically just tries to do all the wrong

00:23:10,659 --> 00:23:16,960
things and make sure that the kernel

00:23:12,789 --> 00:23:19,510
freaks out about it at the same time I

00:23:16,960 --> 00:23:21,669
tend to you know try to work with people

00:23:19,510 --> 00:23:23,679
who actually do the research like I you

00:23:21,669 --> 00:23:26,409
know work with project zero internally

00:23:23,679 --> 00:23:28,990
at Google and say you know yon comes and

00:23:26,409 --> 00:23:34,990
says to me hi I noticed there's a

00:23:28,990 --> 00:23:37,539
problem over here and I go no so yeah

00:23:34,990 --> 00:23:39,490
like having a small test framework to

00:23:37,539 --> 00:23:41,620
actually make sure that those things do

00:23:39,490 --> 00:23:43,480
what they're supposed to do seem like

00:23:41,620 --> 00:23:46,179
obvious to me any like yeah I turn the

00:23:43,480 --> 00:23:47,320
config on doesn't tell me anything like

00:23:46,179 --> 00:23:48,880
I can look at the configure it doesn't

00:23:47,320 --> 00:23:51,429
say anything but if I actually go and

00:23:48,880 --> 00:23:54,159
you know alright Here I am I'm gonna set

00:23:51,429 --> 00:23:56,590
my you know my reference counter to you

00:23:54,159 --> 00:23:59,350
know one below int max and increment it

00:23:56,590 --> 00:24:00,580
twice did I did I get the warning I was

00:23:59,350 --> 00:24:01,120
expecting out of the kernel can I

00:24:00,580 --> 00:24:03,550
continue

00:24:01,120 --> 00:24:07,900
fermented actually do those tests so

00:24:03,550 --> 00:24:09,730
yeah the the the LK DTM module in the

00:24:07,900 --> 00:24:12,520
kernel which no one should use on a

00:24:09,730 --> 00:24:14,170
production system I will break the

00:24:12,520 --> 00:24:16,420
kernel in all kinds of interesting ways

00:24:14,170 --> 00:24:17,650
and if you see other ways that it's not

00:24:16,420 --> 00:24:29,920
covering which I'm sure there's lots

00:24:17,650 --> 00:24:32,680
send me a patch blow things up yeah it

00:24:29,920 --> 00:24:35,820
would be good to have more people doing

00:24:32,680 --> 00:24:38,350
research on breaking the the kernel and

00:24:35,820 --> 00:24:41,590
letting us know you know to the purpose

00:24:38,350 --> 00:24:43,600
of death so my goal is to make all the

00:24:41,590 --> 00:24:45,370
books on Linux exploitation irrelevant

00:24:43,600 --> 00:24:47,110
and now someone's got to write a new

00:24:45,370 --> 00:24:50,530
book and I'll try to fix those things

00:24:47,110 --> 00:24:52,650
and then we'll have rest anyway thank

00:24:50,530 --> 00:24:52,650

YouTube URL: https://www.youtube.com/watch?v=8Pg3vC-b1aY


