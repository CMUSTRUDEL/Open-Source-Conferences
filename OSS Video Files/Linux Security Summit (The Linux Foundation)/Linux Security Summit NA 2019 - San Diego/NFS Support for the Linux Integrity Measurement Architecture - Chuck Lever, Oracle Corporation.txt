Title: NFS Support for the Linux Integrity Measurement Architecture - Chuck Lever, Oracle Corporation
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	NFS Support for the Linux Integrity Measurement Architecture - Chuck Lever, Oracle Corporation

Until recently, integrity measurement support was available only on local file systems. This talk describes the design of a proposed extension of the NFS protocol to support IMA. The discussion will include the design's strengths and limitations, and remaining challenges.
Captions: 
	00:00:00,060 --> 00:00:05,370
I'm Chuck cleaver I'm not a security

00:00:02,399 --> 00:00:08,519
person just wanted to put that out there

00:00:05,370 --> 00:00:13,530
right up front if there's something I

00:00:08,519 --> 00:00:15,089
say that that looks like complete BS you

00:00:13,530 --> 00:00:17,520
know you don't have to say I'm calling

00:00:15,089 --> 00:00:19,320
you out you can say you know maybe you

00:00:17,520 --> 00:00:21,150
don't understand this and I won't take

00:00:19,320 --> 00:00:24,930
that personally

00:00:21,150 --> 00:00:26,880
well I I'm I've been in NFS community

00:00:24,930 --> 00:00:31,170
for 20 years I'm a call maintainer of

00:00:26,880 --> 00:00:37,620
the Linux NFS server as well as the

00:00:31,170 --> 00:00:39,840
author of several NFS related RFC's so

00:00:37,620 --> 00:00:41,700
that's sort of my area of expertise and

00:00:39,840 --> 00:00:45,390
it gives you a sense of where I'm coming

00:00:41,700 --> 00:00:47,280
from with this talk and I want to thank

00:00:45,390 --> 00:00:55,199
James and the program committee for

00:00:47,280 --> 00:00:58,829
inviting me here to talk so I want to

00:00:55,199 --> 00:01:01,710
start with a sort of simplified abstract

00:00:58,829 --> 00:01:04,860
use case that my employer is mostly

00:01:01,710 --> 00:01:09,330
interested in in terms of ima it's the

00:01:04,860 --> 00:01:13,680
sort of attestation of and and as to add

00:01:09,330 --> 00:01:16,080
a station of executables so basically

00:01:13,680 --> 00:01:21,530
the basic model is that a software

00:01:16,080 --> 00:01:23,759
vendor generates a signed Mac or

00:01:21,530 --> 00:01:26,780
checksum of an executable

00:01:23,759 --> 00:01:30,240
it's just wants to distribute and

00:01:26,780 --> 00:01:35,490
publishes the application it's public

00:01:30,240 --> 00:01:40,290
key and of course the checksum and then

00:01:35,490 --> 00:01:42,780
and users are protected on systems that

00:01:40,290 --> 00:01:44,369
have these these features I'm just sort

00:01:42,780 --> 00:01:45,930
of going over this really quickly I'm

00:01:44,369 --> 00:01:48,770
sure most of you understand how this

00:01:45,930 --> 00:01:48,770
works but

00:01:52,540 --> 00:02:02,550
it's got three items a way to store the

00:01:59,280 --> 00:02:05,320
public keys of the software vendors a

00:02:02,550 --> 00:02:08,350
security module or security service that

00:02:05,320 --> 00:02:10,660
that is able to actually actually

00:02:08,350 --> 00:02:12,880
perform the measurement of executables

00:02:10,660 --> 00:02:18,790
before they're used and then a policy

00:02:12,880 --> 00:02:22,750
for handling appraisal failures so the

00:02:18,790 --> 00:02:27,460
customer installs the application and it

00:02:22,750 --> 00:02:30,010
stores the assigned checksum close to

00:02:27,460 --> 00:02:33,790
the application and then whenever it's

00:02:30,010 --> 00:02:36,460
it's opened or used of course the the

00:02:33,790 --> 00:02:41,440
Security Service is able to measure that

00:02:36,460 --> 00:02:47,680
application and verify the the checksum

00:02:41,440 --> 00:02:49,720
and the signature on it so that's how it

00:02:47,680 --> 00:02:51,610
works in the local case when of course

00:02:49,720 --> 00:02:55,720
the file system is local to the to the

00:02:51,610 --> 00:02:59,170
user who is running the executable but

00:02:55,720 --> 00:03:01,180
now what happens when the file storage

00:02:59,170 --> 00:03:03,400
is remote as in a network file system

00:03:01,180 --> 00:03:07,680
and I'm not talking about just NFS here

00:03:03,400 --> 00:03:12,940
it could be SEF it could be an SMB

00:03:07,680 --> 00:03:15,489
storage service anything that that hmm

00:03:12,940 --> 00:03:20,680
allows access to files over over network

00:03:15,489 --> 00:03:22,959
is the possibility here so the first

00:03:20,680 --> 00:03:24,670
thing to note is is we're talking about

00:03:22,959 --> 00:03:26,860
two separate systems the server and the

00:03:24,670 --> 00:03:29,140
client the server being this the storage

00:03:26,860 --> 00:03:30,910
server and the client being the the

00:03:29,140 --> 00:03:33,519
place where the applications running are

00:03:30,910 --> 00:03:34,840
actually two separate systems they're

00:03:33,519 --> 00:03:38,410
not the same system as they are in the

00:03:34,840 --> 00:03:40,209
local case and the second thing to note

00:03:38,410 --> 00:03:42,340
is that the greatest tax surface appears

00:03:40,209 --> 00:03:44,980
when the file Cantus content is in

00:03:42,340 --> 00:03:47,560
transit that's that's a that's an

00:03:44,980 --> 00:03:50,670
exposure that local storage the local

00:03:47,560 --> 00:03:50,670
storage use case doesn't have

00:03:53,550 --> 00:04:00,460
and as you may be familiar with some

00:03:56,830 --> 00:04:01,990
types of end of a storage the server the

00:04:00,460 --> 00:04:04,030
storage server doesn't have an execution

00:04:01,990 --> 00:04:06,370
environment which means the programs

00:04:04,030 --> 00:04:11,470
don't run there they will run on the

00:04:06,370 --> 00:04:14,050
storage on the on the clients we're also

00:04:11,470 --> 00:04:15,370
talking about situations where you might

00:04:14,050 --> 00:04:17,440
have different operating systems running

00:04:15,370 --> 00:04:19,810
on the client than you do on the storage

00:04:17,440 --> 00:04:22,330
server you might have Solaris running on

00:04:19,810 --> 00:04:24,070
the storage server on the NFS server and

00:04:22,330 --> 00:04:27,100
you might have Linux running on the on

00:04:24,070 --> 00:04:29,250
the clients where the applications are

00:04:27,100 --> 00:04:33,040
running so we have to be sensitive about

00:04:29,250 --> 00:04:43,240
the server not for example being able to

00:04:33,040 --> 00:04:45,310
interpret I'm a metadata or in fact they

00:04:43,240 --> 00:04:46,870
might not be able to understand Linux

00:04:45,310 --> 00:04:48,460
dialects standard attributes so we can't

00:04:46,870 --> 00:04:51,790
just say well look in this extended

00:04:48,460 --> 00:04:54,640
attribute may be for example ZFS on

00:04:51,790 --> 00:04:57,669
Solaris I mean where do you where you

00:04:54,640 --> 00:04:59,110
put the ima the security dot ima

00:04:57,669 --> 00:05:00,970
extended attribute on in a filesystem

00:04:59,110 --> 00:05:03,390
like that doesn't support extended

00:05:00,970 --> 00:05:03,390
attributes

00:05:10,730 --> 00:05:17,540
so we have also had the the quandary of

00:05:13,580 --> 00:05:25,850
how the storage server and how the NFS

00:05:17,540 --> 00:05:29,180
clients might represent users it's also

00:05:25,850 --> 00:05:30,920
the case that the server might have a

00:05:29,180 --> 00:05:33,050
different policy than the client does

00:05:30,920 --> 00:05:37,490
when it turns when it comes to

00:05:33,050 --> 00:05:39,740
interpreting ima attestation failures

00:05:37,490 --> 00:05:42,380
the server might just for example it

00:05:39,740 --> 00:05:44,570
might just audit the failure or it might

00:05:42,380 --> 00:05:46,430
say I'm sorry clients you can't access

00:05:44,570 --> 00:05:52,070
this file because this is failing my

00:05:46,430 --> 00:05:54,080
policy today what that looks like to

00:05:52,070 --> 00:05:56,270
click two clients if the server decides

00:05:54,080 --> 00:05:59,120
that the client is not allowed access it

00:05:56,270 --> 00:06:03,080
looks like suddenly the the client gets

00:05:59,120 --> 00:06:05,030
a access and the user might be well I

00:06:03,080 --> 00:06:07,550
didn't change the access control on this

00:06:05,030 --> 00:06:09,230
file Oh am I getting this it really the

00:06:07,550 --> 00:06:17,420
clients don't have any visibility into

00:06:09,230 --> 00:06:20,210
that so that kind of gives you the

00:06:17,420 --> 00:06:23,390
context for the for the NFS extension

00:06:20,210 --> 00:06:25,810
that that I would like to propose it has

00:06:23,390 --> 00:06:28,670
to deal with all these situations

00:06:25,810 --> 00:06:30,920
especially troublesome is the the fact

00:06:28,670 --> 00:06:32,330
that your your storage server might not

00:06:30,920 --> 00:06:34,820
be running the same might not be running

00:06:32,330 --> 00:06:40,810
links so it might not have any idea what

00:06:34,820 --> 00:06:44,660
I am a metadata is so the idea here is

00:06:40,810 --> 00:06:49,040
it can take any NFS server Solaris and

00:06:44,660 --> 00:06:51,640
NetApp whatever Dell EMC and enable it

00:06:49,040 --> 00:06:53,420
to store ima metadata so that

00:06:51,640 --> 00:06:57,560
executables will you store there you

00:06:53,420 --> 00:06:59,630
install there can be measured and tested

00:06:57,560 --> 00:07:02,480
on clients on NFS clients that access

00:06:59,630 --> 00:07:06,680
access them the whole idea here is to

00:07:02,480 --> 00:07:08,720
extend the protection of VM a from the

00:07:06,680 --> 00:07:10,520
NFS server all the way to end users on

00:07:08,720 --> 00:07:13,820
NFS clients in other words to bring the

00:07:10,520 --> 00:07:16,090
the protection as close to end use as

00:07:13,820 --> 00:07:16,090
possible

00:07:20,750 --> 00:07:28,470
so on linux i'm a metadata stored in the

00:07:24,210 --> 00:07:32,550
security ima etc and all I've done is

00:07:28,470 --> 00:07:36,870
I've added a new attribute to nfsv4

00:07:32,550 --> 00:07:39,540
called Fator for ima that's stored with

00:07:36,870 --> 00:07:43,130
set adder its retrieved with getattr

00:07:39,540 --> 00:07:45,780
and the end of us servers can store this

00:07:43,130 --> 00:07:47,250
the content of this attribute any way

00:07:45,780 --> 00:07:48,740
they like if they're Linux they can

00:07:47,250 --> 00:07:52,020
store them in a security dot I mean

00:07:48,740 --> 00:07:54,060
extended attribute if they're NetApp

00:07:52,020 --> 00:07:55,440
they can put them in a database if

00:07:54,060 --> 00:07:56,790
they're Solaris they can put them in a

00:07:55,440 --> 00:08:01,410
name to attribute they can do whatever

00:07:56,790 --> 00:08:03,540
they need to do but the most important

00:08:01,410 --> 00:08:07,620
part of this is that the NFS protocol

00:08:03,540 --> 00:08:09,540
and NFS implementations don't interpret

00:08:07,620 --> 00:08:11,340
they don't parse this metadata it's just

00:08:09,540 --> 00:08:12,930
a blob of data that's moved it's

00:08:11,340 --> 00:08:20,910
basically just two treated the same way

00:08:12,930 --> 00:08:25,080
as file content so this gives us some

00:08:20,910 --> 00:08:27,560
interesting features NFS has integrity

00:08:25,080 --> 00:08:31,620
protection in transit using Kerberos

00:08:27,560 --> 00:08:33,390
that's of course optional but in fact

00:08:31,620 --> 00:08:36,000
integrity protection isn't necessary

00:08:33,390 --> 00:08:38,460
when you have I'm a metadata because you

00:08:36,000 --> 00:08:40,290
be I'm a metadata has a has a signature

00:08:38,460 --> 00:08:42,390
on it it's cryptographically protected

00:08:40,290 --> 00:08:45,540
when the client gets both the file

00:08:42,390 --> 00:08:48,900
content and the ima metadata it can do

00:08:45,540 --> 00:08:52,530
its own assessment of the of the file

00:08:48,900 --> 00:08:54,120
content and a corruption of either the

00:08:52,530 --> 00:08:58,560
metadata where the file content can be

00:08:54,120 --> 00:09:03,660
detected by the the I'm a security

00:08:58,560 --> 00:09:08,280
service on the client so this this

00:09:03,660 --> 00:09:11,040
detects both corruption of the data in

00:09:08,280 --> 00:09:16,830
transit it also protects it when it's at

00:09:11,040 --> 00:09:21,570
rest on the server there are some things

00:09:16,830 --> 00:09:23,460
that I'm leaving out of the proposal to

00:09:21,570 --> 00:09:26,880
make it a little more likely that it'll

00:09:23,460 --> 00:09:30,020
be implemented and merged into Linux not

00:09:26,880 --> 00:09:34,920
doing secure boot via NFS boot NFS route

00:09:30,020 --> 00:09:37,860
and more importantly I'm not currently

00:09:34,920 --> 00:09:42,110
proposing to support attribute

00:09:37,860 --> 00:09:46,560
protection via a VM there are some

00:09:42,110 --> 00:09:49,200
strong reasons not to do it one reason

00:09:46,560 --> 00:09:53,610
is that nfsv4 ackles don't look like

00:09:49,200 --> 00:09:55,680
POSIX cycles and so the e vm checksum

00:09:53,610 --> 00:10:02,300
might be computed from POSIX Ackles and

00:09:55,680 --> 00:10:05,850
and other types of metadata from on the

00:10:02,300 --> 00:10:07,740
content generation end but the the the

00:10:05,850 --> 00:10:10,890
client NFS clients are not going to be

00:10:07,740 --> 00:10:13,260
able to see those POSIX Ackles they'll

00:10:10,890 --> 00:10:16,260
see nfsv4 Ackles and those won't look

00:10:13,260 --> 00:10:22,650
the same so the checksum won't won't

00:10:16,260 --> 00:10:27,810
work at that point so I do have a

00:10:22,650 --> 00:10:32,720
prototype of this the slide kind of

00:10:27,810 --> 00:10:32,720
details exactly how how its implemented

00:10:33,320 --> 00:10:39,360
when user space tries to on the client

00:10:37,560 --> 00:10:42,270
tries to get to security dot ima X

00:10:39,360 --> 00:10:45,930
extended attribute it's translated into

00:10:42,270 --> 00:10:48,930
the get a tour of the Fator for IMA

00:10:45,930 --> 00:10:52,200
or set adder of that attribute and sent

00:10:48,930 --> 00:10:56,330
to the server and the Linux NFS server

00:10:52,200 --> 00:10:56,330
does the opposite translation

00:10:59,460 --> 00:11:11,520
I also have written nfsv4 extension

00:11:06,980 --> 00:11:14,400
specification it's been in front of the

00:11:11,520 --> 00:11:15,900
working group for about a year it is a

00:11:14,400 --> 00:11:17,670
working group document now so it is

00:11:15,900 --> 00:11:19,170
something that the working group is

00:11:17,670 --> 00:11:22,980
interested in making sure is published

00:11:19,170 --> 00:11:25,290
as an RFC but there are certain issues

00:11:22,980 --> 00:11:28,550
that are are still a challenge

00:11:25,290 --> 00:11:32,270
one is that Linux I made doesn't have an

00:11:28,550 --> 00:11:34,470
official published specification so

00:11:32,270 --> 00:11:36,600
there are some questions about how

00:11:34,470 --> 00:11:39,360
interoperable is it to store I'm a

00:11:36,600 --> 00:11:41,310
metadata in the server and will that

00:11:39,360 --> 00:11:43,350
will all clients be guaranteed to

00:11:41,310 --> 00:11:46,440
recognize the contents of the I'm a

00:11:43,350 --> 00:11:49,020
metadata we don't have like a separate

00:11:46,440 --> 00:11:51,540
little field that says this is type 7 I

00:11:49,020 --> 00:11:54,540
am a metadata or whatever it's expected

00:11:51,540 --> 00:11:56,820
that the I'm a security services or

00:11:54,540 --> 00:11:59,070
module on the on the clients are able to

00:11:56,820 --> 00:12:00,960
recognize all of the relevant types of

00:11:59,070 --> 00:12:03,450
I'm a metadata there are and interpret

00:12:00,960 --> 00:12:05,520
them and do something with them

00:12:03,450 --> 00:12:08,280
NFS doesn't play any part of that I

00:12:05,520 --> 00:12:09,420
think I've gotten that document and the

00:12:08,280 --> 00:12:14,250
working group to a point where they've

00:12:09,420 --> 00:12:17,430
accepted that the other issue that still

00:12:14,250 --> 00:12:19,980
remains a challenge is understanding how

00:12:17,430 --> 00:12:22,830
to authorize modification if I'm a

00:12:19,980 --> 00:12:24,990
metadata on the server on the client cap

00:12:22,830 --> 00:12:26,640
sysadmin is required to do that but we

00:12:24,990 --> 00:12:28,080
don't have the same we don't have

00:12:26,640 --> 00:12:31,010
capabilities at all in the end of us

00:12:28,080 --> 00:12:34,530
protocol so we can't really rely on that

00:12:31,010 --> 00:12:36,570
the IETF is probably going to require us

00:12:34,530 --> 00:12:40,380
to make some kind of statement about how

00:12:36,570 --> 00:12:42,600
secure the ability to modify a metadata

00:12:40,380 --> 00:12:44,190
it needs to be on the server so I that's

00:12:42,600 --> 00:12:46,440
still a question mark for me and if

00:12:44,190 --> 00:12:50,820
anybody has any good ideas I'm very open

00:12:46,440 --> 00:12:52,890
to hearing them it seems to me that we

00:12:50,820 --> 00:12:54,570
really don't need to to protect it that

00:12:52,890 --> 00:12:57,390
much because obviously when when a

00:12:54,570 --> 00:12:58,950
client gets both of these things the

00:12:57,390 --> 00:13:02,310
worst that can happen if they're

00:12:58,950 --> 00:13:06,110
corrupted is by a malicious actor is

00:13:02,310 --> 00:13:06,110
that there's a denial of service

00:13:06,529 --> 00:13:11,209
but you know I'm interested in other

00:13:09,859 --> 00:13:17,989
people's opinions about how that will

00:13:11,209 --> 00:13:20,629
work so we have a prototype we have a

00:13:17,989 --> 00:13:24,229
protocol specification how do we know

00:13:20,629 --> 00:13:26,449
what it's done I'm not I'm not quite

00:13:24,229 --> 00:13:28,819
sure how to answer that question maybe

00:13:26,449 --> 00:13:32,989
y'all have some interesting ideas about

00:13:28,819 --> 00:13:35,149
that I've got the prototype

00:13:32,989 --> 00:13:39,019
implementation it looks pretty clean

00:13:35,149 --> 00:13:41,199
I haven't submitted for review yet but I

00:13:39,019 --> 00:13:43,459
think you know now that we have a

00:13:41,199 --> 00:13:46,219
specification document that's usually

00:13:43,459 --> 00:13:48,799
all that's required to get it merged and

00:13:46,219 --> 00:13:54,049
so I think we're at a point where it's

00:13:48,799 --> 00:13:54,949
probably ready for review through the

00:13:54,049 --> 00:13:56,869
through this whole thing I've been

00:13:54,949 --> 00:14:00,259
worried about the performance of this

00:13:56,869 --> 00:14:01,789
but as I understand it actual content

00:14:00,259 --> 00:14:03,919
measurement is done once and then cache

00:14:01,789 --> 00:14:08,179
and so maybe maybe that's not going to

00:14:03,919 --> 00:14:10,129
be an issue the IMA offload case is kind

00:14:08,179 --> 00:14:12,529
of interesting that's where the the NFS

00:14:10,129 --> 00:14:15,679
server handles ima and the client just

00:14:12,529 --> 00:14:17,239
trusts the server to get it right I'm

00:14:15,679 --> 00:14:19,009
not sure if that's interesting to folks

00:14:17,239 --> 00:14:23,389
or whether that's something that should

00:14:19,009 --> 00:14:28,970
definitely be forbidden so I'm

00:14:23,389 --> 00:14:31,279
interested in in any opinions there so

00:14:28,970 --> 00:14:34,189
you can find the the protocol

00:14:31,279 --> 00:14:36,919
specification at the top URL and you can

00:14:34,189 --> 00:14:39,349
find the Linux Pro to the server and

00:14:36,919 --> 00:14:40,819
client prototype at the bottom URL if

00:14:39,349 --> 00:14:46,699
you're if you're curious about trying

00:14:40,819 --> 00:14:48,649
this out and before I get to questions I

00:14:46,699 --> 00:14:51,799
just wanted to say that there is a lot

00:14:48,649 --> 00:14:54,109
more work being done in the security

00:14:51,799 --> 00:14:58,909
area in NFS and I'm interested to know

00:14:54,109 --> 00:15:01,099
if I put in a secure NFS buff on the on

00:14:58,909 --> 00:15:03,109
the flip chart if anybody would be

00:15:01,099 --> 00:15:07,609
interested in attending how many people

00:15:03,109 --> 00:15:10,070
would be interested in coming to that's

00:15:07,609 --> 00:15:18,830
good enough three all right

00:15:10,070 --> 00:15:18,830
I'll do that then okay any questions

00:15:25,640 --> 00:15:30,660
if I understand correctly this does

00:15:28,410 --> 00:15:32,100
require server-side modification so if I

00:15:30,660 --> 00:15:33,840
have a net app I'm waiting on that app

00:15:32,100 --> 00:15:34,290
to implement this protocol spec that's

00:15:33,840 --> 00:15:36,840
correct

00:15:34,290 --> 00:15:38,310
have you I guess they don't know much

00:15:36,840 --> 00:15:39,540
about the problem space but how would

00:15:38,310 --> 00:15:41,700
this compared to something like FS

00:15:39,540 --> 00:15:43,650
parity where you're storing the actual

00:15:41,700 --> 00:15:46,380
metadata has normal files so you can use

00:15:43,650 --> 00:15:48,150
a normal POSIX file system whatever that

00:15:46,380 --> 00:15:51,750
might look like to restore your

00:15:48,150 --> 00:15:53,340
integrity metadata I understand that the

00:15:51,750 --> 00:15:54,450
FS meta Verity folks are looking at

00:15:53,340 --> 00:15:59,010
integrated with ima but I don't know

00:15:54,450 --> 00:16:01,340
what the status of that is you can ask

00:15:59,010 --> 00:16:01,340
the author

00:16:05,240 --> 00:16:08,960
it's actually probably probably better

00:16:07,190 --> 00:16:11,060
to call me the original instigator

00:16:08,960 --> 00:16:16,370
Eric Biggers has actually done most of

00:16:11,060 --> 00:16:18,920
the coding work for FS Verity so let's

00:16:16,370 --> 00:16:23,450
answer in reverse order we are planning

00:16:18,920 --> 00:16:26,630
on integrating with IMA insofar as when

00:16:23,450 --> 00:16:29,990
you open an FS Verity protected file the

00:16:26,630 --> 00:16:34,000
Merkel tree hash will be sent to ima as

00:16:29,990 --> 00:16:36,860
if it were a new checksum of the file

00:16:34,000 --> 00:16:38,660
and the protection properties are

00:16:36,860 --> 00:16:42,110
slightly different than a traditional

00:16:38,660 --> 00:16:46,580
IMA verification where you drag the

00:16:42,110 --> 00:16:48,080
entire file into memory cache it do the

00:16:46,580 --> 00:16:50,870
checksum and then never check the

00:16:48,080 --> 00:16:53,210
checksum ever again with FS Verity you

00:16:50,870 --> 00:16:56,720
check the checksum every single time a

00:16:53,210 --> 00:16:59,900
page is pulled in and it's as you go as

00:16:56,720 --> 00:17:02,420
opposed to the whole file so there are

00:16:59,900 --> 00:17:05,120
differences in performance and security

00:17:02,420 --> 00:17:07,760
guarantees and it will be up to the

00:17:05,120 --> 00:17:09,470
system builder or administrator to

00:17:07,760 --> 00:17:14,120
decide what's appropriate for their use

00:17:09,470 --> 00:17:17,810
case with respect to NFS it's actually

00:17:14,120 --> 00:17:22,910
not in the file per se because the way

00:17:17,810 --> 00:17:24,980
FS Verity works is that there is as an

00:17:22,910 --> 00:17:27,800
implementation detail for local disk

00:17:24,980 --> 00:17:30,230
file systems we place the Merkel tree at

00:17:27,800 --> 00:17:34,340
the end of the file after the metadata

00:17:30,230 --> 00:17:36,830
however user space if they call stat on

00:17:34,340 --> 00:17:41,270
the file and get eye size they get the

00:17:36,830 --> 00:17:46,580
real file and the Merkel tree is

00:17:41,270 --> 00:17:48,830
effectively hidden from user space so an

00:17:46,580 --> 00:17:53,270
obvious way of implementing this for

00:17:48,830 --> 00:17:56,750
nfsv4 might be as a stream type object

00:17:53,270 --> 00:17:58,880
which I guess is called named wasn't

00:17:56,750 --> 00:18:01,970
named attributes essentially it's an

00:17:58,880 --> 00:18:04,370
alternate file stream because the Merkel

00:18:01,970 --> 00:18:07,850
tree is generally way bigger than what

00:18:04,370 --> 00:18:10,430
you can put in an extended attribute so

00:18:07,850 --> 00:18:14,420
it would be possible to support FS

00:18:10,430 --> 00:18:18,440
Verity for nfsv4

00:18:14,420 --> 00:18:22,370
with minimal changes to the NFS protocol

00:18:18,440 --> 00:18:24,800
assuming the server-side supported named

00:18:22,370 --> 00:18:26,690
attributes someone is going to have to

00:18:24,800 --> 00:18:28,610
do the work if there is anyone

00:18:26,690 --> 00:18:29,990
interested in implementing that because

00:18:28,610 --> 00:18:32,690
they have a use case where that would be

00:18:29,990 --> 00:18:35,300
useful you should probably talk to me or

00:18:32,690 --> 00:18:37,580
chalk because I'd love to see it but I

00:18:35,300 --> 00:18:40,790
don't have a use case or time to

00:18:37,580 --> 00:18:43,730
implement it myself yeah and as an aside

00:18:40,790 --> 00:18:46,340
I believe solaris implements named

00:18:43,730 --> 00:18:47,930
attributes in the client server but I

00:18:46,340 --> 00:18:52,730
don't think anybody else ever did

00:18:47,930 --> 00:18:57,870
I know Lennox does not any other

00:18:52,730 --> 00:19:01,680
questions okay thank you

00:18:57,870 --> 00:19:01,680

YouTube URL: https://www.youtube.com/watch?v=9P9pWxw26s0


