Title: Integrity Measurements and the Cruel World - Janne Karhunen, Dark Matter LLC
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Integrity Measurements and the Cruel World - Janne Karhunen, Dark Matter LLC

Offline attacks have been a hot topic for a while now, yet the deployments of integrity measurement systems have been scarce especially in the embedded world. Many deployment efforts haveyielded failures for multiple reasons, usually getting stuck with performance and measurement reliability issues due to system power outages and crashes.We have managed to overcome most of these issues for security-enhanced android device and the Linux integrity subsystem appears to work like clockwork without causing unnecessary pains for the end user. In this talk, we cover the changes needed to make things (mostly) work and how things can be improved from here.
Captions: 
	00:00:00,030 --> 00:00:04,819
so my name is Jana Caron I've been

00:00:02,669 --> 00:00:10,760
working with the this colleague of mine

00:00:04,819 --> 00:00:10,760
constantly stuff for a while oh sorry

00:00:12,769 --> 00:00:17,400
so I've been working with this colleague

00:00:15,360 --> 00:00:19,490
named concept constic our sister on Oh

00:00:17,400 --> 00:00:23,220
Emma for the past half a year a bit more

00:00:19,490 --> 00:00:25,769
and the end this talk is to share our

00:00:23,220 --> 00:00:28,590
experiences with I'm on so first she

00:00:25,769 --> 00:00:30,390
thinks about to talk so we are basically

00:00:28,590 --> 00:00:32,850
implementing a bunch of consumer

00:00:30,390 --> 00:00:35,760
electronics devices that include an

00:00:32,850 --> 00:00:39,030
android-based mobile phone and initially

00:00:35,760 --> 00:00:41,160
the desire was to use AMA for the

00:00:39,030 --> 00:00:43,489
mutable user data protection on these

00:00:41,160 --> 00:00:43,489
devices

00:00:43,850 --> 00:00:48,660
after short learning curve on Emma we

00:00:46,980 --> 00:00:50,160
found it actually to be usable on quite

00:00:48,660 --> 00:00:52,320
a few different things we really didn't

00:00:50,160 --> 00:00:53,850
expect initially the initial goal was

00:00:52,320 --> 00:00:55,500
just to have the mutable user data

00:00:53,850 --> 00:00:59,730
protection since Android really doesn't

00:00:55,500 --> 00:01:01,859
provide this and as it is always things

00:00:59,730 --> 00:01:05,510
rarely go like in the movies even though

00:01:01,859 --> 00:01:09,869
I AMA has been widely deployed as such

00:01:05,510 --> 00:01:12,090
always fully-featured deployments seem

00:01:09,869 --> 00:01:14,159
to have been backed up by the human

00:01:12,090 --> 00:01:16,979
administrator we had some unexpected

00:01:14,159 --> 00:01:20,460
issues with it so more about this later

00:01:16,979 --> 00:01:21,630
and unfortunately consumer electronics

00:01:20,460 --> 00:01:24,210
doesn't really have this human

00:01:21,630 --> 00:01:26,369
administrator back up as an option so we

00:01:24,210 --> 00:01:28,049
are we have collected this talk to

00:01:26,369 --> 00:01:29,990
address those parts of volume of that

00:01:28,049 --> 00:01:32,659
have made it difficult to deploy

00:01:29,990 --> 00:01:36,420
electronics applications

00:01:32,659 --> 00:01:39,420
so first the the use cases for Hema and

00:01:36,420 --> 00:01:42,180
consumer electronics the protection for

00:01:39,420 --> 00:01:44,100
the mutable and immutable data so we

00:01:42,180 --> 00:01:48,390
really want to protect every single file

00:01:44,100 --> 00:01:50,250
in there we want to track the I know

00:01:48,390 --> 00:01:53,460
intimate estate from the moment of

00:01:50,250 --> 00:01:56,159
creation to the deletion with no gaps in

00:01:53,460 --> 00:01:58,560
between so we want to protect the entire

00:01:56,159 --> 00:02:00,780
lifespan of the file this is something

00:01:58,560 --> 00:02:05,790
that is really not provided by anything

00:02:00,780 --> 00:02:07,740
apart from Emma and this includes the

00:02:05,790 --> 00:02:09,229
fact that we can actually reduce the

00:02:07,740 --> 00:02:12,560
trust in the software in slurry

00:02:09,229 --> 00:02:16,549
so because software installer is just a

00:02:12,560 --> 00:02:19,519
piece on the piece of the path of the

00:02:16,549 --> 00:02:21,230
life life a lifetime of the inode so it

00:02:19,519 --> 00:02:24,830
is something that moves the only node

00:02:21,230 --> 00:02:28,700
from A to B and I am okay basically it

00:02:24,830 --> 00:02:31,010
secures the transport path in full but

00:02:28,700 --> 00:02:32,720
I'm also gives us is that we can use it

00:02:31,010 --> 00:02:35,900
to prevent untrusted code and code from

00:02:32,720 --> 00:02:38,659
executing on the device it gives us

00:02:35,900 --> 00:02:42,799
means to do remote at the station of the

00:02:38,659 --> 00:02:44,870
particle that part of our device so what

00:02:42,799 --> 00:02:46,819
do we really need to get to a working

00:02:44,870 --> 00:02:49,099
consumer electronics device in real life

00:02:46,819 --> 00:02:50,629
so what we need is first we need

00:02:49,099 --> 00:02:53,989
something that the initializer so Emma

00:02:50,629 --> 00:02:56,780
properly so we have plenty of simple

00:02:53,989 --> 00:02:58,250
samples online that show how to use it

00:02:56,780 --> 00:03:00,170
how to insert the keys and how to do

00:02:58,250 --> 00:03:02,780
basic things but they're lucky in quite

00:03:00,170 --> 00:03:04,670
a lot of things so we need something

00:03:02,780 --> 00:03:07,040
that generates the keys potentially

00:03:04,670 --> 00:03:08,840
drives them from somewhere and something

00:03:07,040 --> 00:03:11,590
that stores and loads them on the

00:03:08,840 --> 00:03:14,930
subsequent boots

00:03:11,590 --> 00:03:16,790
we need basic functionality for the

00:03:14,930 --> 00:03:18,560
device state management I'll explain

00:03:16,790 --> 00:03:22,190
this bit later what this actually means

00:03:18,560 --> 00:03:25,269
and in terms of why we actually have

00:03:22,190 --> 00:03:28,400
multiple device States so and these

00:03:25,269 --> 00:03:30,530
states are basically described by a

00:03:28,400 --> 00:03:36,049
different line of policies and I'll

00:03:30,530 --> 00:03:38,540
explain this bit later then we have done

00:03:36,049 --> 00:03:42,739
is that we have done support for false

00:03:38,540 --> 00:03:44,720
full filesystem labeling in mkfs I'll

00:03:42,739 --> 00:03:49,099
explain this also later on why this is

00:03:44,720 --> 00:03:51,769
needed and the largest work piece in

00:03:49,099 --> 00:03:54,049
this whole bundle was to make I must

00:03:51,769 --> 00:03:56,980
support bright measurements and I'll

00:03:54,049 --> 00:03:59,299
explain this this is a large piece

00:03:56,980 --> 00:04:04,400
application installation support is

00:03:59,299 --> 00:04:06,169
pretty obvious and there is usually

00:04:04,400 --> 00:04:08,329
already provided by most of the distro

00:04:06,169 --> 00:04:11,780
so you can have RPM already supporting

00:04:08,329 --> 00:04:13,459
uma and then the implementation of the

00:04:11,780 --> 00:04:15,740
handling for this different states like

00:04:13,459 --> 00:04:17,840
factory reset and recovery we have had

00:04:15,740 --> 00:04:22,520
to make some code here to make these

00:04:17,840 --> 00:04:24,800
things work okay so first things first

00:04:22,520 --> 00:04:26,570
oh this is the thing that in our set up

00:04:24,800 --> 00:04:29,360
currently initializes Lima and it looks

00:04:26,570 --> 00:04:32,870
like this so this these different colors

00:04:29,360 --> 00:04:35,210
try to show the different device States

00:04:32,870 --> 00:04:37,430
with the green one showing whatever

00:04:35,210 --> 00:04:40,280
happens on the first boot and first boot

00:04:37,430 --> 00:04:42,920
only the orange path is really the

00:04:40,280 --> 00:04:45,200
normal boot bus so on every regular boot

00:04:42,920 --> 00:04:49,370
adventure through this particular bus

00:04:45,200 --> 00:04:51,560
and then the blue section is the the

00:04:49,370 --> 00:04:53,810
actual recovery state when things go

00:04:51,560 --> 00:04:56,900
wrong so this is this particular state

00:04:53,810 --> 00:04:59,060
is being requested and you can see the

00:04:56,900 --> 00:05:06,200
state transition transition in logic

00:04:59,060 --> 00:05:08,810
here from these arrows so besides this

00:05:06,200 --> 00:05:11,380
thing what this hurt the initializer

00:05:08,810 --> 00:05:14,030
does is that it actually does also

00:05:11,380 --> 00:05:17,180
signature verification of certain files

00:05:14,030 --> 00:05:19,640
right before I AMA has initialized so

00:05:17,180 --> 00:05:22,250
this initializer itself uses a

00:05:19,640 --> 00:05:25,130
configuration file which also needs

00:05:22,250 --> 00:05:28,910
verification and we have basically made

00:05:25,130 --> 00:05:31,430
this into one piece it detects the

00:05:28,910 --> 00:05:33,710
device state basically holds a state

00:05:31,430 --> 00:05:35,510
files in there and verifies those the

00:05:33,710 --> 00:05:37,340
integrity of those things and it

00:05:35,510 --> 00:05:40,610
maintains data by state and manages it

00:05:37,340 --> 00:05:43,400
and then it loads the AMA I'm a policy

00:05:40,610 --> 00:05:44,600
fragments based on these devices and on

00:05:43,400 --> 00:05:46,280
the first booted trans the key

00:05:44,600 --> 00:05:48,350
generation and gearing population and

00:05:46,280 --> 00:05:50,740
all that stuff and and all in all this

00:05:48,350 --> 00:05:54,800
all this was considerably more

00:05:50,740 --> 00:06:01,280
complicated than without that we're

00:05:54,800 --> 00:06:04,190
gonna face and the ideally in order to

00:06:01,280 --> 00:06:07,660
help people to deploy I'm ABI ha nice to

00:06:04,190 --> 00:06:10,580
have this kanafeh properly made large

00:06:07,660 --> 00:06:12,980
feature complete initializer out there

00:06:10,580 --> 00:06:14,510
at least as an example even if it cannot

00:06:12,980 --> 00:06:19,010
be used as such then it would really

00:06:14,510 --> 00:06:21,460
help people deploy on and we can open

00:06:19,010 --> 00:06:26,510
source ours it's it's really no secret

00:06:21,460 --> 00:06:28,060
and this is strictly not imma related

00:06:26,510 --> 00:06:31,300
but I wanted to touch this top

00:06:28,060 --> 00:06:34,680
tiny bit since it is also related and

00:06:31,300 --> 00:06:37,510
usually a big fall in harmony plans so

00:06:34,680 --> 00:06:40,380
real life devices really need divorce

00:06:37,510 --> 00:06:44,020
specific keys and those keys are

00:06:40,380 --> 00:06:46,300
generated on the first and in minimum

00:06:44,020 --> 00:06:48,190
look we need to generate is the device

00:06:46,300 --> 00:06:52,780
specific master key the key encryption

00:06:48,190 --> 00:06:53,950
key and the EVM age monkey so these are

00:06:52,780 --> 00:06:56,520
this is the absolute minimum

00:06:53,950 --> 00:06:59,590
configuration for rama deployment and

00:06:56,520 --> 00:07:01,680
security of these mandatory keys is more

00:06:59,590 --> 00:07:04,660
or less dependent on the presence of the

00:07:01,680 --> 00:07:06,700
physical hardware trust source or any

00:07:04,660 --> 00:07:09,390
trust source for that matters I'm about

00:07:06,700 --> 00:07:09,390
to show it later

00:07:09,810 --> 00:07:17,530
there is absolutely no agreement that I

00:07:13,600 --> 00:07:21,760
know of about how the trust is to be

00:07:17,530 --> 00:07:24,790
obtained in Linux so we have so everyone

00:07:21,760 --> 00:07:26,500
has their own te their own source of

00:07:24,790 --> 00:07:30,190
trust out there the only standards that

00:07:26,500 --> 00:07:32,080
we really have is TPM and and in the

00:07:30,190 --> 00:07:34,300
systems that I've been working with TPM

00:07:32,080 --> 00:07:39,430
just doesn't exist so we had to figure

00:07:34,300 --> 00:07:42,220
out something and in real has general

00:07:39,430 --> 00:07:47,310
manner as possible so what we ended up

00:07:42,220 --> 00:07:50,860
doing is a TPM light trusted key support

00:07:47,310 --> 00:07:53,080
that basically does the most fundamental

00:07:50,860 --> 00:07:55,960
key function is generate seal and on see

00:07:53,080 --> 00:07:58,450
why a new key type and we made it so

00:07:55,960 --> 00:08:01,660
that you can actually do this via a cry

00:07:58,450 --> 00:08:05,430
over in the user space and this fryer is

00:08:01,660 --> 00:08:05,430
in the user space are basically their

00:08:05,820 --> 00:08:11,860
their user space programs that are

00:08:08,950 --> 00:08:13,930
embedded into your kernel image so

00:08:11,860 --> 00:08:16,900
anyone it's extremely simple the right

00:08:13,930 --> 00:08:19,180
one and it may talk to a physical

00:08:16,900 --> 00:08:21,910
hardware trust source on the device or

00:08:19,180 --> 00:08:23,920
it may talk to a server in China to

00:08:21,910 --> 00:08:25,180
obtain their trust it really doesn't

00:08:23,920 --> 00:08:27,400
matter it it's just the user space

00:08:25,180 --> 00:08:30,340
program and that one is embedded in the

00:08:27,400 --> 00:08:33,940
kernel image it runs in an invisible

00:08:30,340 --> 00:08:35,700
root root filesystem within within the

00:08:33,940 --> 00:08:39,660
the car

00:08:35,700 --> 00:08:41,910
and the that's where really it does it's

00:08:39,660 --> 00:08:45,450
all of its talks it is entirely

00:08:41,910 --> 00:08:47,490
untouchable from the regular userland so

00:08:45,450 --> 00:08:50,070
the fact that it just transcends cpu

00:08:47,490 --> 00:08:54,090
user mode is the only thing that makes

00:08:50,070 --> 00:08:56,010
it different from any driver this is

00:08:54,090 --> 00:08:56,430
basically the way that it looks like in

00:08:56,010 --> 00:08:59,180
real life

00:08:56,430 --> 00:09:02,790
so this initializer talk talks to the

00:08:59,180 --> 00:09:06,150
this user space helper inside the peril

00:09:02,790 --> 00:09:07,950
which basically talks to any root of

00:09:06,150 --> 00:09:09,900
trust it can use in the particular

00:09:07,950 --> 00:09:13,860
system and as I said this can be a

00:09:09,900 --> 00:09:20,640
server in China if needed and this was

00:09:13,860 --> 00:09:23,790
made entirely key control comparable so

00:09:20,640 --> 00:09:26,730
the and those cons there show the basic

00:09:23,790 --> 00:09:30,330
use so the first comment for example it

00:09:26,730 --> 00:09:33,200
would generate 32 byte key named foo and

00:09:30,330 --> 00:09:35,700
insert that into the user keyring and

00:09:33,200 --> 00:09:37,860
the way what would actually happen is

00:09:35,700 --> 00:09:41,010
that this any program that sense of this

00:09:37,860 --> 00:09:44,190
request talks to this user space helper

00:09:41,010 --> 00:09:47,250
which then ultimately talks to the real

00:09:44,190 --> 00:09:50,760
trust source somewhere to actually

00:09:47,250 --> 00:09:53,070
generate the key then the second common

00:09:50,760 --> 00:09:55,740
is an example how you would actually

00:09:53,070 --> 00:09:59,490
search this key named foo and pipe that

00:09:55,740 --> 00:10:02,490
to a food but that to a file on the file

00:09:59,490 --> 00:10:05,190
system in its encrypted form so the

00:10:02,490 --> 00:10:07,170
regular user space never really sees the

00:10:05,190 --> 00:10:09,480
unencrypted key it would only see the

00:10:07,170 --> 00:10:11,220
encrypted one and the last one of those

00:10:09,480 --> 00:10:13,980
things is how do you know we would

00:10:11,220 --> 00:10:22,170
actually load encrypted key and unsaved

00:10:13,980 --> 00:10:24,360
it for the currently use yeah so that I

00:10:22,170 --> 00:10:27,590
just want don't want to focus on the key

00:10:24,360 --> 00:10:35,360
part since this talk is about time

00:10:27,590 --> 00:10:39,030
then this imma ships with policies

00:10:35,360 --> 00:10:41,220
policies in the kernel and this default

00:10:39,030 --> 00:10:43,380
places are pretty generic and they're

00:10:41,220 --> 00:10:45,210
probably rarely sufficient for any real

00:10:43,380 --> 00:10:47,730
web use

00:10:45,210 --> 00:10:49,830
they maybe I don't know I guess Mimi can

00:10:47,730 --> 00:10:51,600
tell us but for us it seemed that they

00:10:49,830 --> 00:10:53,070
were not proper fit and we actually had

00:10:51,600 --> 00:11:07,260
to implement multiple of them for each

00:10:53,070 --> 00:11:09,570
device so so each one of our policies

00:11:07,260 --> 00:11:15,650
so we basically use multiple polices we

00:11:09,570 --> 00:11:18,330
do we implement the the i'ma States or

00:11:15,650 --> 00:11:21,570
by our policy fragments well what we

00:11:18,330 --> 00:11:23,850
have is the one core policy which is

00:11:21,570 --> 00:11:26,100
basically shared between the all states

00:11:23,850 --> 00:11:29,310
and then we have the state specific

00:11:26,100 --> 00:11:30,780
rules on top that define what this

00:11:29,310 --> 00:11:35,370
actually supposed to happen in that

00:11:30,780 --> 00:11:37,410
particular state and even in our case it

00:11:35,370 --> 00:11:39,720
is true that we really don't have a

00:11:37,410 --> 00:11:44,600
joint agreement on the policy grammar

00:11:39,720 --> 00:11:48,420
right the only ilysm that is and use

00:11:44,600 --> 00:11:50,010
Android is our primary use but I mean

00:11:48,420 --> 00:11:52,280
Android it's obvious that everything is

00:11:50,010 --> 00:11:55,230
defined through the IC when X labels but

00:11:52,280 --> 00:11:58,560
but for other systems it is different

00:11:55,230 --> 00:12:00,450
and for that we are basically using this

00:11:58,560 --> 00:12:02,670
fragmentation so we can actually share

00:12:00,450 --> 00:12:04,950
the core policy between the systems and

00:12:02,670 --> 00:12:12,120
then have this Ellison specific editions

00:12:04,950 --> 00:12:15,000
on top based on the state's then these

00:12:12,120 --> 00:12:17,520
policies usually refer to the file

00:12:15,000 --> 00:12:20,730
systems as a whole and this is we added

00:12:17,520 --> 00:12:23,760
this support in make affairs to generate

00:12:20,730 --> 00:12:25,080
file systems with imal labels from I'm a

00:12:23,760 --> 00:12:27,150
policy point of view you currently

00:12:25,080 --> 00:12:30,390
identified those file systems with MSU

00:12:27,150 --> 00:12:31,920
you ideas or FS names and these are tiny

00:12:30,390 --> 00:12:34,320
bit problematic something properly

00:12:31,920 --> 00:12:35,850
something better I should probably come

00:12:34,320 --> 00:12:39,270
up later on

00:12:35,850 --> 00:12:41,790
FSU you idea is basically an unique ID

00:12:39,270 --> 00:12:45,610
an unique identifier generated Randy all

00:12:41,790 --> 00:12:48,430
system file system building

00:12:45,610 --> 00:12:50,530
and this is you would basically have to

00:12:48,430 --> 00:12:54,940
modify every policy should be unique to

00:12:50,530 --> 00:12:56,710
use this one properly and then F is the

00:12:54,940 --> 00:12:58,870
name of the other hand is too generic

00:12:56,710 --> 00:13:01,000
it's just F is what the Epis name is is

00:12:58,870 --> 00:13:04,210
just basically the name that this is a

00:13:01,000 --> 00:13:05,740
next for file system and you probably

00:13:04,210 --> 00:13:08,500
want to different differentiate how

00:13:05,740 --> 00:13:11,860
primal works in different texts for

00:13:08,500 --> 00:13:14,130
partitions that you have so both are

00:13:11,860 --> 00:13:16,060
slightly problematic and M is something

00:13:14,130 --> 00:13:18,670
better I should probably eventually

00:13:16,060 --> 00:13:21,280
emerge but we can leave these options

00:13:18,670 --> 00:13:24,010
and we ended up using the FS GUI days we

00:13:21,280 --> 00:13:30,310
just had to hard-code call us and which

00:13:24,010 --> 00:13:33,490
I don't personally and this file system

00:13:30,310 --> 00:13:36,940
labeling house was relatively big piece

00:13:33,490 --> 00:13:38,320
the primary mean to shape software the

00:13:36,940 --> 00:13:40,360
consumer electronics deposit stays

00:13:38,320 --> 00:13:42,130
really why our file system images they

00:13:40,360 --> 00:13:47,020
are not usually assembly and even if

00:13:42,130 --> 00:13:49,480
they are assembled by tool like rpm it's

00:13:47,020 --> 00:13:52,600
the tool is usually not present on the

00:13:49,480 --> 00:13:54,430
actual system when it runs and the

00:13:52,600 --> 00:13:57,670
software is delivered by our pawsome

00:13:54,430 --> 00:14:01,810
images and this is why we added support

00:13:57,670 --> 00:14:06,250
to make FS to support Lima and this I'm

00:14:01,810 --> 00:14:08,920
here iam signing support is added that

00:14:06,250 --> 00:14:12,760
basically besides the assilex

00:14:08,920 --> 00:14:15,940
support in contraband drug perm see it

00:14:12,760 --> 00:14:18,160
looks pretty clean we had to modify the

00:14:15,940 --> 00:14:20,410
leap by my IBM APR tiny bit to

00:14:18,160 --> 00:14:22,240
accomplish this thing but the changes

00:14:20,410 --> 00:14:27,430
are really tiny and we can publish those

00:14:22,240 --> 00:14:31,210
changes soon and the if that goes well

00:14:27,430 --> 00:14:33,040
and since Theo is here we can probably

00:14:31,210 --> 00:14:34,780
even eventually consider talking about

00:14:33,040 --> 00:14:39,640
that whether or not we could get that

00:14:34,780 --> 00:14:43,660
support straight - straight to e 2 FS

00:14:39,640 --> 00:14:46,700
frogs in this country minor currency

00:14:43,660 --> 00:14:48,560
and from there it's it's usable for how

00:14:46,700 --> 00:14:50,780
the other users than Android as well so

00:14:48,560 --> 00:14:57,230
you can at any time assemble all systems

00:14:50,780 --> 00:15:01,130
that have full I'm assigning and then

00:14:57,230 --> 00:15:03,560
it's a large part so what we had to add

00:15:01,130 --> 00:15:05,600
right measurement support into OMA and

00:15:03,560 --> 00:15:09,260
first that why do we need to measure

00:15:05,600 --> 00:15:11,960
rights so say for example when Android

00:15:09,260 --> 00:15:14,420
device boots it creates a lot of files

00:15:11,960 --> 00:15:17,510
in the first booty at one point I was

00:15:14,420 --> 00:15:20,780
counting something like 700 plus files

00:15:17,510 --> 00:15:27,470
and every single one of these files is

00:15:20,780 --> 00:15:29,000
good for all sorts of attacks and let's

00:15:27,470 --> 00:15:31,790
think about the case that we're talking

00:15:29,000 --> 00:15:34,400
about a wireless LAN LAN router you

00:15:31,790 --> 00:15:36,170
probably really want to verify that the

00:15:34,400 --> 00:15:37,790
wireless LAN router there on the wall

00:15:36,170 --> 00:15:39,920
that everyone here in this room is now

00:15:37,790 --> 00:15:41,780
using they're still running that same

00:15:39,920 --> 00:15:45,830
configuration that was actually given to

00:15:41,780 --> 00:15:47,210
it and these files are created on run

00:15:45,830 --> 00:15:55,550
time currently there's probably nothing

00:15:47,210 --> 00:15:58,310
protecting them so this is one reason to

00:15:55,550 --> 00:16:00,770
measure right so and then there's the

00:15:58,310 --> 00:16:02,870
obvious thing that you should always

00:16:00,770 --> 00:16:04,970
consider when it comes to a phone or

00:16:02,870 --> 00:16:07,250
something that the user data is

00:16:04,970 --> 00:16:09,410
ultimately more valuable than the system

00:16:07,250 --> 00:16:13,910
data these days people take for granted

00:16:09,410 --> 00:16:15,830
that the system is secure but and what

00:16:13,910 --> 00:16:22,520
they really also want to hear that their

00:16:15,830 --> 00:16:24,500
data is secure and those of you who know

00:16:22,520 --> 00:16:26,570
imma you will probably point out that I

00:16:24,500 --> 00:16:28,400
my appraisal already supports mutable

00:16:26,570 --> 00:16:32,150
data so what seems to be the problem

00:16:28,400 --> 00:16:35,510
with the support well the case is that

00:16:32,150 --> 00:16:38,510
the sub imma measured files only went to

00:16:35,510 --> 00:16:41,180
Paulo closest and user can keep us open

00:16:38,510 --> 00:16:42,650
for extremely long period period so I'm

00:16:41,180 --> 00:16:46,550
I never actually generates a measurement

00:16:42,650 --> 00:16:48,350
and this is also true for the system

00:16:46,550 --> 00:16:49,730
files so system demons can keep files

00:16:48,350 --> 00:16:52,399
open for a long period

00:16:49,730 --> 00:16:53,990
and unfortunately since we're talking

00:16:52,399 --> 00:16:57,170
about electronics devices such as phones

00:16:53,990 --> 00:17:00,139
drum no batteries they run out of

00:16:57,170 --> 00:17:03,110
battery they crash and all the weird

00:17:00,139 --> 00:17:05,569
things happened to them while the Falls

00:17:03,110 --> 00:17:07,819
are open and I'm appraisal itself is

00:17:05,569 --> 00:17:10,299
strict that if there is no measurement

00:17:07,819 --> 00:17:13,480
of the file there's also no access and

00:17:10,299 --> 00:17:15,980
from our point of view this led to the

00:17:13,480 --> 00:17:18,530
situation that in case the phone crashed

00:17:15,980 --> 00:17:21,860
while it was in use or an auto battery

00:17:18,530 --> 00:17:24,919
in Wauwatosa news it never booted after

00:17:21,860 --> 00:17:26,449
and that the probability was 100% so if

00:17:24,919 --> 00:17:29,059
any one of these things happened it

00:17:26,449 --> 00:17:31,400
never recovered and this was something

00:17:29,059 --> 00:17:36,380
that we really couldn't live with we

00:17:31,400 --> 00:17:38,540
have to solve it somehow but since its

00:17:36,380 --> 00:17:40,010
Android we're talking about is it even

00:17:38,540 --> 00:17:40,760
possible to measure all the rights

00:17:40,010 --> 00:17:43,610
they're happening

00:17:40,760 --> 00:17:44,929
so Android writes a lot so writes a

00:17:43,610 --> 00:17:47,179
frequent and the measurements team

00:17:44,929 --> 00:17:50,770
serial cells are extremely expensive and

00:17:47,179 --> 00:17:53,570
even one bit change in that file

00:17:50,770 --> 00:17:55,760
invalidates the entire measurement and

00:17:53,570 --> 00:17:58,160
there are quite a few places in the

00:17:55,760 --> 00:18:00,380
kernel tree where the paths can change

00:17:58,160 --> 00:18:02,059
so it was obvious that's quite amount of

00:18:00,380 --> 00:18:04,700
hooks will be needed to accomplish this

00:18:02,059 --> 00:18:06,290
and at this point we already concluded

00:18:04,700 --> 00:18:09,410
that it's probably impossible to make

00:18:06,290 --> 00:18:12,110
this perfect we can we can't easily make

00:18:09,410 --> 00:18:14,510
it perfect but turns out maybe there's

00:18:12,110 --> 00:18:16,130
some hope with that as well but the

00:18:14,510 --> 00:18:17,780
first we didn't want to give up we just

00:18:16,130 --> 00:18:19,220
started to get the assumption that don't

00:18:17,780 --> 00:18:21,380
let the perfect be the enemy of better

00:18:19,220 --> 00:18:25,520
let's see how good we can actually make

00:18:21,380 --> 00:18:27,740
it so we set out the basic requirements

00:18:25,520 --> 00:18:30,970
or let's relax a little bit and see how

00:18:27,740 --> 00:18:35,150
good we can make so we were aiming for

00:18:30,970 --> 00:18:37,610
minimal right performance impact and as

00:18:35,150 --> 00:18:39,919
high as possible measurement accuracy

00:18:37,610 --> 00:18:42,350
for small files so that we're really

00:18:39,919 --> 00:18:44,059
measuring small files and small files

00:18:42,350 --> 00:18:47,299
which are usually vital for this isn't

00:18:44,059 --> 00:18:50,360
functionality as soon as we possibly can

00:18:47,299 --> 00:18:52,580
and as often as we possibly can and then

00:18:50,360 --> 00:18:55,400
we want to adequate measurement accuracy

00:18:52,580 --> 00:18:56,490
for large files or large files they're

00:18:55,400 --> 00:18:59,340
usually something

00:18:56,490 --> 00:19:01,710
qapla images and such and we're fine if

00:18:59,340 --> 00:19:07,470
we end up losing them your entire device

00:19:01,710 --> 00:19:09,809
is not closed after and the architecture

00:19:07,470 --> 00:19:12,030
we landed with was based on this

00:19:09,809 --> 00:19:15,530
concurrency managed to work you present

00:19:12,030 --> 00:19:18,270
in the kernel it is excellent tool for

00:19:15,530 --> 00:19:22,410
distributing parallel work it is a low

00:19:18,270 --> 00:19:25,920
latency cpu specific work you with

00:19:22,410 --> 00:19:28,620
absolutely minimal resource waste and

00:19:25,920 --> 00:19:31,800
the cool thing in it is that it allows

00:19:28,620 --> 00:19:36,540
us to define the job plate and see so we

00:19:31,800 --> 00:19:38,309
can actually tell them when the

00:19:36,540 --> 00:19:39,900
measurement is check exactly supposed to

00:19:38,309 --> 00:19:42,300
happen for this particular final this

00:19:39,900 --> 00:19:45,360
file and this ended up being vital for

00:19:42,300 --> 00:19:47,340
getting this to work we can't constantly

00:19:45,360 --> 00:19:53,550
measure every single by the changes we

00:19:47,340 --> 00:19:56,010
have to make some compromise so we took

00:19:53,550 --> 00:19:58,110
the file life cycle changes as the basic

00:19:56,010 --> 00:20:01,920
measurement points so first measurement

00:19:58,110 --> 00:20:04,340
is generated at the time when open is

00:20:01,920 --> 00:20:06,990
being done or the pile is being created

00:20:04,340 --> 00:20:09,360
then basically every single right

00:20:06,990 --> 00:20:12,210
regardless if it is mm I changed the

00:20:09,360 --> 00:20:16,350
file or if it's right the system call we

00:20:12,210 --> 00:20:18,990
have the majority and then we had

00:20:16,350 --> 00:20:21,600
initially we had hooks in sync and em

00:20:18,990 --> 00:20:23,670
sync as well but turns out those were

00:20:21,600 --> 00:20:26,850
ultimately not needed all explained this

00:20:23,670 --> 00:20:30,360
bit later truncate was something that

00:20:26,850 --> 00:20:33,900
should absolutely have to be absolutely

00:20:30,360 --> 00:20:36,900
had to be truncated of the measured and

00:20:33,900 --> 00:20:38,370
then of course the file closed at which

00:20:36,900 --> 00:20:39,840
point we can just were just verifying

00:20:38,370 --> 00:20:42,630
this we didn't appear up to date

00:20:39,840 --> 00:20:45,660
and since we didn't really want to

00:20:42,630 --> 00:20:48,390
change the way that the user space

00:20:45,660 --> 00:20:50,130
behaves so we didn't want to change the

00:20:48,390 --> 00:20:53,780
latency of the system calls so people

00:20:50,130 --> 00:20:56,610
have some expectations how things are

00:20:53,780 --> 00:20:59,820
supposed to happen so they expect some

00:20:56,610 --> 00:21:02,340
latency from sync but they might not

00:20:59,820 --> 00:21:04,740
expect latency from open they may not

00:21:02,340 --> 00:21:06,990
expect latency from right they may not

00:21:04,740 --> 00:21:12,570
expect latency from truncate so

00:21:06,990 --> 00:21:15,780
we had to make this work and the so in

00:21:12,570 --> 00:21:17,610
the way that we do this is that at these

00:21:15,780 --> 00:21:19,800
basic measurement points we basically

00:21:17,610 --> 00:21:23,010
attack the file for delayed measurement

00:21:19,800 --> 00:21:26,040
and we don't we're not really standing

00:21:23,010 --> 00:21:29,370
of the on the system called path in any

00:21:26,040 --> 00:21:30,929
way and the overall goal is to try to

00:21:29,370 --> 00:21:34,170
keep the measurement and the disk

00:21:30,929 --> 00:21:36,270
latency as well as possible and then we

00:21:34,170 --> 00:21:38,280
noticed for the early on that the way to

00:21:36,270 --> 00:21:41,100
deal with large files is really just

00:21:38,280 --> 00:21:44,220
linearly increase the latency based on

00:21:41,100 --> 00:21:51,960
the file size otherwise the performance

00:21:44,220 --> 00:21:54,150
would just totally collapse and now that

00:21:51,960 --> 00:21:56,280
we are at the point that we are about to

00:21:54,150 --> 00:22:01,200
push this patch to the mailing lists

00:21:56,280 --> 00:22:03,059
with all things and it turns out that

00:22:01,200 --> 00:22:04,860
there's one core hope that we only need

00:22:03,059 --> 00:22:07,470
and it's the mm of your measurement tool

00:22:04,860 --> 00:22:10,559
so what we have done is that we have

00:22:07,470 --> 00:22:14,670
basically hooked the Linux kernel page

00:22:10,559 --> 00:22:17,160
right back in and in the mm-mm code so

00:22:14,670 --> 00:22:19,950
at some point so whenever your process

00:22:17,160 --> 00:22:25,110
does right it can be any form of right

00:22:19,950 --> 00:22:26,340
but that data lands in a buffer it

00:22:25,110 --> 00:22:28,260
doesn't go to the disk

00:22:26,340 --> 00:22:29,820
it just it's asynchronously returned to

00:22:28,260 --> 00:22:33,090
a buffer around and eventually there's a

00:22:29,820 --> 00:22:34,830
crown thread that wakes up and flushes

00:22:33,090 --> 00:22:36,840
and take the stage of the disk so it

00:22:34,830 --> 00:22:39,480
sees whatever the dirty pages in this

00:22:36,840 --> 00:22:43,320
file are and then takes the stuff to the

00:22:39,480 --> 00:22:44,820
disk and latency of this these kernels

00:22:43,320 --> 00:22:47,370
rights and these variables are defined

00:22:44,820 --> 00:22:50,570
in this in this prop pulse

00:22:47,370 --> 00:22:50,570
there's a bunch of them

00:22:51,009 --> 00:22:59,679
turns out that this was really the ideal

00:22:53,019 --> 00:23:01,840
place to do this and so we are and we

00:22:59,679 --> 00:23:03,909
are even this mm code we are not making

00:23:01,840 --> 00:23:06,279
the measurement at that point we're at

00:23:03,909 --> 00:23:08,529
this point we're pushing the work item

00:23:06,279 --> 00:23:10,629
for that particular I note to the work

00:23:08,529 --> 00:23:13,509
you for i'ma for delayed measurements so

00:23:10,629 --> 00:23:15,399
we're not even breaking the mm codes

00:23:13,509 --> 00:23:19,090
internal functionality in terms of it

00:23:15,399 --> 00:23:20,559
doesn't any of the its expectations how

00:23:19,090 --> 00:23:28,389
long things are supposed to take they

00:23:20,559 --> 00:23:31,869
shouldn't change and this turns out to

00:23:28,389 --> 00:23:34,690
work extremely fair well so if you have

00:23:31,869 --> 00:23:37,690
a large file say 1 megabyte file and

00:23:34,690 --> 00:23:39,309
there's something that does mm il

00:23:37,690 --> 00:23:41,379
Chinese say that there is an SQLite

00:23:39,309 --> 00:23:44,909
database in the kernel memory you have

00:23:41,379 --> 00:23:48,519
something making modifications SQLite

00:23:44,909 --> 00:23:51,570
SQLite database in the memory then there

00:23:48,519 --> 00:23:54,519
are several pages that will become dirty

00:23:51,570 --> 00:23:55,779
eventually you can have if you have if

00:23:54,519 --> 00:23:58,419
you have to find you have plenty of

00:23:55,779 --> 00:24:00,070
memory you can define that this growth

00:23:58,419 --> 00:24:02,379
rate that actually takes the days of the

00:24:00,070 --> 00:24:06,669
disk wakes up once every 5 minutes or

00:24:02,379 --> 00:24:08,679
something then at that point when that

00:24:06,669 --> 00:24:11,409
thing wakes up we take the measurement

00:24:08,679 --> 00:24:14,259
and take that measurement and the data

00:24:11,409 --> 00:24:16,779
to disk at the same time and the only

00:24:14,259 --> 00:24:18,999
way to break this from minor point of

00:24:16,779 --> 00:24:22,539
view is that you would actually have to

00:24:18,999 --> 00:24:25,210
hit with the crash to this update so you

00:24:22,539 --> 00:24:27,999
would have to make the system crash from

00:24:25,210 --> 00:24:29,980
at the point when the data is of RIP

00:24:27,999 --> 00:24:32,739
being written and the measurement is not

00:24:29,980 --> 00:24:34,629
yet there so the only motorways to make

00:24:32,739 --> 00:24:37,570
this variable fail is that particular

00:24:34,629 --> 00:24:41,769
moment so it ended up being pretty

00:24:37,570 --> 00:24:43,509
reliable so normal rights and all the

00:24:41,769 --> 00:24:47,470
MMI or file changes are handled by the

00:24:43,509 --> 00:24:48,970
same oak and if the base sink and I'm

00:24:47,470 --> 00:24:51,190
think I'm saying so you can name Shankar

00:24:48,970 --> 00:24:53,440
basically handled by the same thing it

00:24:51,190 --> 00:24:56,380
all goes back to that same

00:24:53,440 --> 00:25:00,570
page flushing logic truncate added up

00:24:56,380 --> 00:25:04,350
needing of course a separate talk and

00:25:00,570 --> 00:25:04,350
sorted open

00:25:06,540 --> 00:25:15,580
so at this point we were quite happy

00:25:11,500 --> 00:25:18,220
with the initial findings this is and

00:25:15,580 --> 00:25:20,790
thought that maybe there's some light at

00:25:18,220 --> 00:25:24,040
the end of the tunnel that this is right

00:25:20,790 --> 00:25:26,860
right measurement is not an impossible

00:25:24,040 --> 00:25:28,720
problem to solve and we have now been

00:25:26,860 --> 00:25:30,220
running random statistics from these

00:25:28,720 --> 00:25:32,290
systems that how well does it actually

00:25:30,220 --> 00:25:35,740
perform and we took it for example this

00:25:32,290 --> 00:25:38,050
is a sample from 24-hour period when the

00:25:35,740 --> 00:25:41,320
device in actually in real use then

00:25:38,050 --> 00:25:44,470
during that time it takes up to us about

00:25:41,320 --> 00:25:46,780
one millisecond to make a right we have

00:25:44,470 --> 00:25:48,700
defined it to have one millisecond

00:25:46,780 --> 00:25:50,050
measurement latency and it takes about

00:25:48,700 --> 00:25:53,110
one millisecond to measure is a

00:25:50,050 --> 00:25:55,540
particular file so that's the amount of

00:25:53,110 --> 00:25:59,830
time that we have we're basically at the

00:25:55,540 --> 00:26:03,970
worst case in inaccurate state of time

00:25:59,830 --> 00:26:06,970
of today so this is so effectively this

00:26:03,970 --> 00:26:08,350
means that we are this is really the

00:26:06,970 --> 00:26:11,430
worst guest estimate because this

00:26:08,350 --> 00:26:14,050
assumes that none of these work items

00:26:11,430 --> 00:26:19,600
executed in parallel and they were all

00:26:14,050 --> 00:26:24,190
individual jobs on a single CPU and even

00:26:19,600 --> 00:26:26,260
in this case we are 100% accurate

00:26:24,190 --> 00:26:29,940
ninety-nine point two percent of the

00:26:26,260 --> 00:26:33,130
time which is fairly reliable is this

00:26:29,940 --> 00:26:37,240
99.2% is much better than the zero

00:26:33,130 --> 00:26:39,160
percent we had in the beginning and of

00:26:37,240 --> 00:26:40,720
course real life reliability is actually

00:26:39,160 --> 00:26:43,450
considerably better since we are not

00:26:40,720 --> 00:26:44,890
we're not measuring things like log

00:26:43,450 --> 00:26:46,690
files some of these rights are actually

00:26:44,890 --> 00:26:48,220
logging and then that's one by

00:26:46,690 --> 00:26:51,010
information and we don't really care

00:26:48,220 --> 00:26:53,590
about the security of those files and if

00:26:51,010 --> 00:26:55,780
we take a sample from the device code up

00:26:53,590 --> 00:26:57,520
the statistics are here it usually takes

00:26:55,780 --> 00:27:00,370
about 6 and 1/2 milliseconds to write

00:26:57,520 --> 00:27:02,800
and the rest of the parameters are about

00:27:00,370 --> 00:27:03,260
the same and it looks like that the

00:27:02,800 --> 00:27:05,810
worst

00:27:03,260 --> 00:27:09,490
is about being that we were hundred

00:27:05,810 --> 00:27:12,260
percent accurate about 80% of the time

00:27:09,490 --> 00:27:17,150
again real-life situation is much better

00:27:12,260 --> 00:27:19,190
as as I mentioned and if we started when

00:27:17,150 --> 00:27:20,660
we start to do synthetic crash testing

00:27:19,190 --> 00:27:22,250
for this to see that's how well do we

00:27:20,660 --> 00:27:26,570
actually recover now with it from the

00:27:22,250 --> 00:27:30,050
crashes it seems that if we crash the

00:27:26,570 --> 00:27:32,120
device while it's booting it was we were

00:27:30,050 --> 00:27:35,300
we were getting one appraisal failure

00:27:32,120 --> 00:27:38,420
out of every 20 boots or so and that

00:27:35,300 --> 00:27:41,630
started to be good enough but it really

00:27:38,420 --> 00:27:45,140
wouldn't hurt to be better and I think

00:27:41,630 --> 00:27:48,470
the perfect is probably create able but

00:27:45,140 --> 00:27:51,380
we're gonna need the help of Co and some

00:27:48,470 --> 00:27:54,680
of his guys so the way that to make it

00:27:51,380 --> 00:27:57,890
perfect is that when the page flush

00:27:54,680 --> 00:28:00,050
happens we would really need to be able

00:27:57,890 --> 00:28:03,800
to walk that spawn a single transaction

00:28:00,050 --> 00:28:06,470
so all the pages that were dirty and the

00:28:03,800 --> 00:28:08,720
measurement go to the disk in one bundle

00:28:06,470 --> 00:28:11,330
with other goes through or it doesn't go

00:28:08,720 --> 00:28:14,810
through and we can solve this remaining

00:28:11,330 --> 00:28:18,410
missing piece we're as far as I know

00:28:14,810 --> 00:28:26,090
perfect we're pretty good but not

00:28:18,410 --> 00:28:29,270
absolutely perfect then some I'm a

00:28:26,090 --> 00:28:32,060
specific performance consideration

00:28:29,270 --> 00:28:33,500
considerations so we have basically

00:28:32,060 --> 00:28:35,750
apprised everything major rating

00:28:33,500 --> 00:28:41,150
configuration with VP exceptions of log

00:28:35,750 --> 00:28:45,350
files or boot up from the appraisal we

00:28:41,150 --> 00:28:47,930
have about ten percent penalty and looks

00:28:45,350 --> 00:28:49,880
like that from the right measurements we

00:28:47,930 --> 00:28:51,910
can't really easily measure even any

00:28:49,880 --> 00:28:54,860
dental penalty they hire they're nicely

00:28:51,910 --> 00:28:57,350
delayed they're nicely pushed to the

00:28:54,860 --> 00:29:00,440
background and we do understand that

00:28:57,350 --> 00:29:03,380
there of course workloads where you will

00:29:00,440 --> 00:29:05,510
absolutely start to say this so this is

00:29:03,380 --> 00:29:07,910
only a specific to us so that's why the

00:29:05,510 --> 00:29:10,100
patch that itself was made configurable

00:29:07,910 --> 00:29:12,200
so you can actually define the

00:29:10,100 --> 00:29:14,169
parameters in a way that they are

00:29:12,200 --> 00:29:16,590
suitable for your particular

00:29:14,169 --> 00:29:16,590
workload

00:29:21,170 --> 00:29:27,300
and then just few things I wanted to say

00:29:25,980 --> 00:29:29,370
about application installation support

00:29:27,300 --> 00:29:33,120
as one missing piece

00:29:29,370 --> 00:29:35,730
this channel is solved for Linux but

00:29:33,120 --> 00:29:39,540
it's not entirely appreciated in that in

00:29:35,730 --> 00:29:42,600
its current trend or so as I mentioned

00:29:39,540 --> 00:29:48,000
earlier I'm a signature actually secure

00:29:42,600 --> 00:29:50,220
the data in transit so signature of the

00:29:48,000 --> 00:29:53,490
file is verified at the exact moment

00:29:50,220 --> 00:29:56,220
when the file is being accessed so there

00:29:53,490 --> 00:29:58,380
are no gaps in the integrity tracking of

00:29:56,220 --> 00:30:00,450
that particular file if you take a

00:29:58,380 --> 00:30:02,730
normal software healer that doesn't use

00:30:00,450 --> 00:30:05,190
AMA you receive a package from the

00:30:02,730 --> 00:30:08,130
network you verify the signature you

00:30:05,190 --> 00:30:10,410
place the files to the disk and there is

00:30:08,130 --> 00:30:12,240
a considerable gap there so after the

00:30:10,410 --> 00:30:14,429
signature is verified

00:30:12,240 --> 00:30:16,970
nobody's gonna verify nobody's gonna

00:30:14,429 --> 00:30:18,630
tell what actually lend it to that disk

00:30:16,970 --> 00:30:20,790
there's a gap there

00:30:18,630 --> 00:30:23,580
files can change this is what the

00:30:20,790 --> 00:30:25,920
attacker can target and I'ma solves this

00:30:23,580 --> 00:30:29,040
and this is why I encourage everyone to

00:30:25,920 --> 00:30:33,950
use even if you're not interested in the

00:30:29,040 --> 00:30:33,950
offline attack prevention side of it so

00:30:34,970 --> 00:30:40,320
and in our case we're using custom

00:30:37,860 --> 00:30:42,690
software installer so unfortunately we

00:30:40,320 --> 00:30:47,640
can probably help in generic fashion but

00:30:42,690 --> 00:30:54,210
this is this is I think in some cases

00:30:47,640 --> 00:30:57,179
this is already in there and then

00:30:54,210 --> 00:30:59,610
factory reset is something that really

00:30:57,179 --> 00:31:05,429
has to be supported by most consumer

00:30:59,610 --> 00:31:08,940
electronics devices and almost all of

00:31:05,429 --> 00:31:15,000
those devices really support they need

00:31:08,940 --> 00:31:17,550
to have data that survives the actual

00:31:15,000 --> 00:31:21,390
factory reset and in case of Android

00:31:17,550 --> 00:31:23,160
phone for example say that such data

00:31:21,390 --> 00:31:25,500
it's actually very easy to do any

00:31:23,160 --> 00:31:28,650
example from an Android phone so your

00:31:25,500 --> 00:31:30,179
battery is has a state whether or not

00:31:28,650 --> 00:31:33,720
your software

00:31:30,179 --> 00:31:37,320
a state so if you take your phone and

00:31:33,720 --> 00:31:37,830
put it to a locker for two years take it

00:31:37,320 --> 00:31:40,830
back

00:31:37,830 --> 00:31:43,950
factory reset it and in case the battery

00:31:40,830 --> 00:31:46,320
management statistics are the same as of

00:31:43,950 --> 00:31:48,330
a new phone you can actually end up

00:31:46,320 --> 00:31:50,730
burning down your house because it will

00:31:48,330 --> 00:31:53,279
start to charge the old battery as first

00:31:50,730 --> 00:31:57,059
in you and disaster can follow so we're

00:31:53,279 --> 00:32:00,029
gonna need persistent date but I'm

00:31:57,059 --> 00:32:02,779
always the persistent data is a slight

00:32:00,029 --> 00:32:06,360
problem because we can agree are not

00:32:02,779 --> 00:32:11,190
allowed to carry keys across the factory

00:32:06,360 --> 00:32:13,649
reset and in case in case we are during

00:32:11,190 --> 00:32:15,629
the factory that we kill the keys then

00:32:13,649 --> 00:32:20,639
we also kill the access to the fall so

00:32:15,629 --> 00:32:22,769
we had to do something about them so for

00:32:20,639 --> 00:32:25,769
to address this we basically made a tiny

00:32:22,769 --> 00:32:27,119
modification to the I'm a policy logic I

00:32:25,769 --> 00:32:28,919
actually didn't even mentioned this to

00:32:27,119 --> 00:32:30,210
me because I was afraid that she might

00:32:28,919 --> 00:32:34,649
actually kill me because of the

00:32:30,210 --> 00:32:36,899
consequence but we basically had any

00:32:34,649 --> 00:32:39,539
partition specific rule that you can

00:32:36,899 --> 00:32:41,879
begin define that this day this

00:32:39,539 --> 00:32:43,259
partition is the place where all the

00:32:41,879 --> 00:32:46,669
data that is supposed to survive

00:32:43,259 --> 00:32:50,129
factories it resides and we can actually

00:32:46,669 --> 00:32:52,830
fix the after on the new boot on the

00:32:50,129 --> 00:32:54,990
first boot after the reset when the new

00:32:52,830 --> 00:32:57,299
keys which get generated I will actually

00:32:54,990 --> 00:33:01,980
allow fixing those particular owners to

00:32:57,299 --> 00:33:04,110
match the new key and this allows us to

00:33:01,980 --> 00:33:05,820
make sure that we never need to i'm

00:33:04,110 --> 00:33:08,309
already supports full fix mode so you

00:33:05,820 --> 00:33:10,259
can you can put it to complete fix mode

00:33:08,309 --> 00:33:12,600
where it fixes absolutely everything but

00:33:10,259 --> 00:33:13,799
this wasn't desired from our point of

00:33:12,600 --> 00:33:15,509
view we just found out that one

00:33:13,799 --> 00:33:19,610
particular location where the data

00:33:15,509 --> 00:33:19,610
resides to be fixed and that only

00:33:23,019 --> 00:33:28,789
recovery mode is something that we

00:33:25,639 --> 00:33:34,039
really didn't get working properly it's

00:33:28,789 --> 00:33:38,629
it's bully talk this kind of best

00:33:34,039 --> 00:33:41,210
support exercise so normal on effects

00:33:38,629 --> 00:33:44,659
assumes that you have one superpower

00:33:41,210 --> 00:33:48,019
find running through the file system and

00:33:44,659 --> 00:33:50,559
fixing everything but since our systems

00:33:48,019 --> 00:33:53,480
are bound by is a linux and the like

00:33:50,559 --> 00:33:55,669
there is no way to get that kind of her

00:33:53,480 --> 00:33:57,200
be religious so what we just try to do

00:33:55,669 --> 00:34:00,109
ways that we can try to in those cases

00:33:57,200 --> 00:34:06,169
we can put it stop until the complete

00:34:00,109 --> 00:34:09,290
recovery mode and hope that whatever

00:34:06,169 --> 00:34:11,569
gets done with the party of that that

00:34:09,290 --> 00:34:13,909
device touches that file that was broken

00:34:11,569 --> 00:34:15,889
and the device recovers but there is it

00:34:13,909 --> 00:34:17,540
works poorly and there are no guarantees

00:34:15,889 --> 00:34:19,460
that this will actually happen

00:34:17,540 --> 00:34:22,899
this is something that we need to

00:34:19,460 --> 00:34:22,899
address later on somehow

00:34:25,810 --> 00:34:36,090
so this is actually all I have all I had

00:34:29,080 --> 00:34:39,090
to say about that so so the any

00:34:36,090 --> 00:34:39,090
questions

00:34:45,680 --> 00:34:53,459
Thanks

00:34:47,389 --> 00:34:53,459

YouTube URL: https://www.youtube.com/watch?v=nHIpLfon_LM


