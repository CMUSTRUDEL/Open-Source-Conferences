Title: Making Remote Attestation Useful on Linux - Brandon Weeks & Matthew Garrett, Google
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Making Remote Attestation Useful on Linux - Brandon Weeks & Matthew Garrett, Google

TPM remote attestation allows a machine to provide proof about what happened during its boot process, in turn allowing appropriate policy and trust decisions to be made by remote services. But the flexibility of any such decision is determined by the richness of the available information that is logged and can be reported, and right now in Linux there's very little available information.This presentation will give a brief overview of remote attestation and the state of available tooling under Linux, along with the various components that generate events that can be used for policy decisions. It will compare Linux to Windows, and identify the areas where Linux is currently deficient. Finally, it will propose some potential solutions for improving the state of the ecosystem and move on to a discussion around whether there are better alternatives.
Captions: 
	00:00:00,000 --> 00:00:06,000
I'm Brendan weeks and this is Matthew

00:00:02,460 --> 00:00:08,580
Garrett we are both on Google's internal

00:00:06,000 --> 00:00:10,620
platform security team so we're

00:00:08,580 --> 00:00:13,410
responsible for securing all of the

00:00:10,620 --> 00:00:15,980
devices that are used at Google which

00:00:13,410 --> 00:00:18,199
includes all of our Linux workstations

00:00:15,980 --> 00:00:20,850
today we're going to be talking about

00:00:18,199 --> 00:00:23,880
how we're using remote attestation at

00:00:20,850 --> 00:00:27,859
Google specifically how we're using TPM

00:00:23,880 --> 00:00:30,300
based remote at the station and how were

00:00:27,859 --> 00:00:36,300
the tools we've developed to actually

00:00:30,300 --> 00:00:39,180
make this useful for us what are our

00:00:36,300 --> 00:00:42,210
goals our goals are to remotely attest

00:00:39,180 --> 00:00:45,450
to the identity and state of every

00:00:42,210 --> 00:00:49,020
client and server we have at Google we

00:00:45,450 --> 00:00:52,530
have over 200,000 machines across many

00:00:49,020 --> 00:00:55,800
different platforms the goal of this is

00:00:52,530 --> 00:00:59,190
to strengthen beyond Corp so our beyond

00:00:55,800 --> 00:01:02,989
Corp model relies on user and device

00:00:59,190 --> 00:01:07,100
identity device identity is currently

00:01:02,989 --> 00:01:09,360
not something that is always

00:01:07,100 --> 00:01:10,710
cryptographically backed or attested to

00:01:09,360 --> 00:01:13,950
and that's something we're trying to

00:01:10,710 --> 00:01:19,049
change and this also enables us to

00:01:13,950 --> 00:01:20,220
enable new workflows for our IT team for

00:01:19,049 --> 00:01:23,670
example we would like to be able to

00:01:20,220 --> 00:01:26,540
dropship clients or servers across the

00:01:23,670 --> 00:01:29,780
world with no image on them whatsoever

00:01:26,540 --> 00:01:33,659
have them remotely a test and deliver a

00:01:29,780 --> 00:01:36,000
secure image without ever having to have

00:01:33,659 --> 00:01:38,700
them go through an inventory process or

00:01:36,000 --> 00:01:43,290
have a inventory technician to touch

00:01:38,700 --> 00:01:44,759
them so across our various platforms

00:01:43,290 --> 00:01:45,960
we're implementing this in different

00:01:44,759 --> 00:01:49,649
ways

00:01:45,960 --> 00:01:52,950
Android introduced key attestation in

00:01:49,649 --> 00:01:55,560
Oreo and we are using that to attest all

00:01:52,950 --> 00:01:58,439
of our pixel phones that support key

00:01:55,560 --> 00:02:01,469
attestation chrome has the verified

00:01:58,439 --> 00:02:05,880
access API it's an API that allows you

00:02:01,469 --> 00:02:09,869
to access essentially the TPM primitives

00:02:05,880 --> 00:02:12,270
through a much simpler method and if you

00:02:09,869 --> 00:02:14,260
are managing your Chrome OS devices with

00:02:12,270 --> 00:02:18,099
G suite you can actually

00:02:14,260 --> 00:02:20,650
a test for their identity for Mac and

00:02:18,099 --> 00:02:22,150
iOS Apple unfortunately doesn't expose

00:02:20,650 --> 00:02:25,989
their add to station' primitives that

00:02:22,150 --> 00:02:29,290
exists in the secure Enclave to us so we

00:02:25,989 --> 00:02:31,569
can't actually use this anyone who works

00:02:29,290 --> 00:02:35,590
at Apple and is in the audience please

00:02:31,569 --> 00:02:37,989
help and for Linux and windows we have

00:02:35,590 --> 00:02:43,450
trusted platform modules and that's what

00:02:37,989 --> 00:02:44,800
we're here to talk to you about today so

00:02:43,450 --> 00:02:48,420
what are the requirements for the

00:02:44,800 --> 00:02:51,580
solution that we are building we want

00:02:48,420 --> 00:02:53,799
identity attestation we want to know the

00:02:51,580 --> 00:02:56,230
unique cryptographic identity of every

00:02:53,799 --> 00:02:59,110
machine we own we also want state

00:02:56,230 --> 00:03:02,549
attestation right now we are just

00:02:59,110 --> 00:03:06,489
attesting to the static court of trust

00:03:02,549 --> 00:03:10,060
and we haven't yet thought about how

00:03:06,489 --> 00:03:12,459
we're going to begin doing dynamic Court

00:03:10,060 --> 00:03:15,569
of Trust measurements with imma or any

00:03:12,459 --> 00:03:21,670
other functionality there

00:03:15,569 --> 00:03:24,549
we want the our use case is every Linux

00:03:21,670 --> 00:03:26,859
and Windows machine used at Google we

00:03:24,549 --> 00:03:29,970
have over 200,000 of these so this is a

00:03:26,859 --> 00:03:33,790
large problem with many many edge cases

00:03:29,970 --> 00:03:36,400
we have to support TPM 1.2 and 2.0

00:03:33,790 --> 00:03:39,489
because we have a non-trivial amount of

00:03:36,400 --> 00:03:43,780
TPM 1.2 devices that would cost a lot of

00:03:39,489 --> 00:03:45,910
money to replace we are building this in

00:03:43,780 --> 00:03:48,370
go because that is one of the better

00:03:45,910 --> 00:03:52,269
supported languages at Google it's

00:03:48,370 --> 00:03:55,090
memory safe and just the preferred

00:03:52,269 --> 00:03:57,160
development environment for our team and

00:03:55,090 --> 00:03:59,950
we want the foundations of this to be

00:03:57,160 --> 00:04:03,190
open-source some of the implementation

00:03:59,950 --> 00:04:04,780
specific details are very tied in to

00:04:03,190 --> 00:04:08,140
Google infrastructure and we're not able

00:04:04,780 --> 00:04:10,030
to release them but we want to we want

00:04:08,140 --> 00:04:12,130
the basis of this to be useful

00:04:10,030 --> 00:04:19,959
externally and we'd love to see it

00:04:12,130 --> 00:04:22,360
consumed by other companies and users so

00:04:19,959 --> 00:04:24,340
what have we done so far

00:04:22,360 --> 00:04:25,900
so also just to be clear when we're

00:04:24,340 --> 00:04:26,710
talking about the number of machines at

00:04:25,900 --> 00:04:28,060
Google

00:04:26,710 --> 00:04:29,800
that we're doing this for we are doing

00:04:28,060 --> 00:04:31,720
this for these systems on the internal

00:04:29,800 --> 00:04:35,190
corporate network we're not talking

00:04:31,720 --> 00:04:35,190
about this in the production environment

00:04:35,580 --> 00:04:40,360
so in terms of what we've done so far

00:04:37,780 --> 00:04:44,590
but the core things that we needed to do

00:04:40,360 --> 00:04:47,440
was add support for obtaining the crypto

00:04:44,590 --> 00:04:50,940
agile log format for systems running TPM

00:04:47,440 --> 00:04:54,490
- this turns out to be a surprisingly

00:04:50,940 --> 00:04:57,190
awkward problem for moderately

00:04:54,490 --> 00:05:00,130
legitimate reasons in the TPM one point

00:04:57,190 --> 00:05:03,009
two days the event log was contained

00:05:00,130 --> 00:05:05,259
within a static area of RAM that was

00:05:03,009 --> 00:05:06,940
allocated by the firmware but which then

00:05:05,259 --> 00:05:09,669
remained available throughout the

00:05:06,940 --> 00:05:11,860
lifetime of the system the downside of

00:05:09,669 --> 00:05:14,349
that is that that meant that memory was

00:05:11,860 --> 00:05:16,750
allocated and was never available to the

00:05:14,349 --> 00:05:19,270
operating systems so if you didn't care

00:05:16,750 --> 00:05:24,729
about the event log you were still using

00:05:19,270 --> 00:05:29,349
that Ram forever the implementation for

00:05:24,729 --> 00:05:33,310
the TCG - UEFI interface - TPM services

00:05:29,349 --> 00:05:37,780
is to allocate the event log in what's

00:05:33,310 --> 00:05:40,659
called boot services data that's memory

00:05:37,780 --> 00:05:42,580
that is freed at the point where the

00:05:40,659 --> 00:05:44,440
operating system calls exit boot

00:05:42,580 --> 00:05:46,060
services to mark the transition from the

00:05:44,440 --> 00:05:50,110
boot environments to the runtime

00:05:46,060 --> 00:05:55,060
environment so we had to copy the event

00:05:50,110 --> 00:05:56,729
log from the boot environment up to the

00:05:55,060 --> 00:06:01,120
kernel environment which involved some

00:05:56,729 --> 00:06:03,159
lightly awkward code because when you

00:06:01,120 --> 00:06:05,139
make the phone work all that tells you

00:06:03,159 --> 00:06:06,550
where the event log is it gives you a

00:06:05,139 --> 00:06:08,469
pointer to the beginning of the event

00:06:06,550 --> 00:06:10,780
log and it gives you a pointer to the

00:06:08,469 --> 00:06:12,490
beginning of the final entry of the

00:06:10,780 --> 00:06:14,469
event log it doesn't give you a pointer

00:06:12,490 --> 00:06:16,000
to the end of the event log which means

00:06:14,469 --> 00:06:19,449
you then have to calculate the size of

00:06:16,000 --> 00:06:22,780
the final entry which is variable and

00:06:19,449 --> 00:06:25,840
then copy that up things were then made

00:06:22,780 --> 00:06:27,669
slightly more awkward again because when

00:06:25,840 --> 00:06:29,680
I said the event log goes away after you

00:06:27,669 --> 00:06:33,039
called exit boot services exit boot

00:06:29,680 --> 00:06:36,760
services itself generates an event which

00:06:33,039 --> 00:06:38,889
is clearly incompatible with this so

00:06:36,760 --> 00:06:43,120
when you call exit boot services and

00:06:38,889 --> 00:06:45,310
additional log is instantiated and event

00:06:43,120 --> 00:06:47,439
sorry when you make the call to get the

00:06:45,310 --> 00:06:49,360
event log an additional log is then

00:06:47,439 --> 00:06:51,310
instantiated and all further events go

00:06:49,360 --> 00:06:55,960
into there and that's available at

00:06:51,310 --> 00:06:59,050
runtime problem there is that if the get

00:06:55,960 --> 00:07:01,180
log call is made before the kernel makes

00:06:59,050 --> 00:07:02,949
it for instance if a bootloader does

00:07:01,180 --> 00:07:05,770
this then you end up with events that

00:07:02,949 --> 00:07:07,360
are both in the event log that will be

00:07:05,770 --> 00:07:09,939
discarded and the event log that will be

00:07:07,360 --> 00:07:14,110
persisted so we also have to add code to

00:07:09,939 --> 00:07:17,710
remove duplicate events that's all lands

00:07:14,110 --> 00:07:19,419
is in 5.3 so if you use kernel 5.3 you

00:07:17,710 --> 00:07:25,360
should be able to get the crypto agile

00:07:19,419 --> 00:07:26,740
event log in terms of the go codes that

00:07:25,360 --> 00:07:28,509
we've written for a cessation purposes

00:07:26,740 --> 00:07:31,000
we now have a functioning client and

00:07:28,509 --> 00:07:33,009
server and as in random mentions we're

00:07:31,000 --> 00:07:34,270
not releasing our internal versions of

00:07:33,009 --> 00:07:35,949
those because they're fundamentally tied

00:07:34,270 --> 00:07:38,589
to Google infrastructure and Loubs you

00:07:35,949 --> 00:07:40,810
would be able to run them anyway so but

00:07:38,589 --> 00:07:44,490
we have demonstrated internally that we

00:07:40,810 --> 00:07:47,800
can do this at scale we now have over

00:07:44,490 --> 00:07:51,009
25,000 systems that are successfully

00:07:47,800 --> 00:07:52,750
generating Association events and we are

00:07:51,009 --> 00:07:56,289
verifying those and parsing out the

00:07:52,750 --> 00:07:58,990
event log we have code for verifying the

00:07:56,289 --> 00:08:01,719
quotes we have code for pausing the

00:07:58,990 --> 00:08:04,180
event log and then replaying the event

00:08:01,719 --> 00:08:06,879
log verifying that the event log matches

00:08:04,180 --> 00:08:08,979
the quote and we heard yesterday about

00:08:06,879 --> 00:08:10,990
other implementations those are also

00:08:08,979 --> 00:08:13,029
doing this so this is not itself

00:08:10,990 --> 00:08:14,349
particularly exciting but I think this

00:08:13,029 --> 00:08:16,529
is one of the first implementations that

00:08:14,349 --> 00:08:22,389
has been demonstrated to be working at

00:08:16,529 --> 00:08:25,270
large-scale the stuff we want to do next

00:08:22,389 --> 00:08:27,279
though is well an event log is itself

00:08:25,270 --> 00:08:29,379
not particularly useful you have a huge

00:08:27,279 --> 00:08:30,909
amount of information especially on

00:08:29,379 --> 00:08:33,909
Windows platforms which I'll go to in a

00:08:30,909 --> 00:08:35,649
second but that's not the information

00:08:33,909 --> 00:08:36,760
you want directly you want to be able to

00:08:35,649 --> 00:08:38,890
look at the event log and make

00:08:36,760 --> 00:08:41,229
determinations like is this system

00:08:38,890 --> 00:08:44,260
running firmware I recognize is this

00:08:41,229 --> 00:08:47,140
system booting a bootloader design

00:08:44,260 --> 00:08:48,610
recognizer does this system have various

00:08:47,140 --> 00:08:51,459
other security characteristics that I

00:08:48,610 --> 00:08:54,339
require for one of these systems to have

00:08:51,459 --> 00:08:56,260
access to internal resources so what

00:08:54,339 --> 00:08:58,720
we're still working on is a meaningful

00:08:56,260 --> 00:09:02,949
way to take the event log and turn it

00:08:58,720 --> 00:09:05,380
into like platform attributes like good

00:09:02,949 --> 00:09:07,990
firmware had disk encryption enabled

00:09:05,380 --> 00:09:10,720
that sort of thing and doing that

00:09:07,990 --> 00:09:14,529
requires us to have a solid idea of what

00:09:10,720 --> 00:09:16,480
things like valid firmware are and this

00:09:14,529 --> 00:09:17,860
needs to be an industry-wide effort to

00:09:16,480 --> 00:09:19,630
an extent we can get away with just

00:09:17,860 --> 00:09:22,569
looking at okay we have this many

00:09:19,630 --> 00:09:24,940
machines we have this many copies of

00:09:22,569 --> 00:09:27,130
firmware and we can melee go well okay

00:09:24,940 --> 00:09:28,839
if we have ten thousand machines running

00:09:27,130 --> 00:09:31,300
this specific firmware then either this

00:09:28,839 --> 00:09:34,390
firmware is legitimate or we're going to

00:09:31,300 --> 00:09:36,819
have a really really bad time so we're

00:09:34,390 --> 00:09:38,319
hoping the former but realistically we

00:09:36,819 --> 00:09:40,569
need this information to come from

00:09:38,319 --> 00:09:44,529
vendors and we need to have a reliable

00:09:40,569 --> 00:09:47,980
way to get it from the vendors to us and

00:09:44,529 --> 00:09:51,459
to the rest of the world and also

00:09:47,980 --> 00:09:53,380
ideally we want to move from our current

00:09:51,459 --> 00:09:55,779
situation where the device identity is

00:09:53,380 --> 00:09:57,610
frequently stored on disk in our systems

00:09:55,779 --> 00:09:59,980
to the device identity being backed by

00:09:57,610 --> 00:10:02,170
the hardware and for us to have full key

00:09:59,980 --> 00:10:07,329
certifications so we can verify that

00:10:02,170 --> 00:10:09,850
this key was generators on a TPM that we

00:10:07,329 --> 00:10:11,470
trust and some of that is but

00:10:09,850 --> 00:10:13,060
implementing key certification properly

00:10:11,470 --> 00:10:15,189
but the other power space is ideally

00:10:13,060 --> 00:10:17,199
making use of platform certificates so

00:10:15,189 --> 00:10:19,390
we're able to verify that the machine

00:10:17,199 --> 00:10:21,100
that came from this vendor with this

00:10:19,390 --> 00:10:23,439
serial number is expected to have this

00:10:21,100 --> 00:10:26,170
TPM and then by looking at that we can

00:10:23,439 --> 00:10:28,540
say ok this machine was shipped to us it

00:10:26,170 --> 00:10:30,760
has this TPM the manufacturer of the

00:10:28,540 --> 00:10:33,130
machine says so and now we can verify

00:10:30,760 --> 00:10:35,290
that the device identity that we have

00:10:33,130 --> 00:10:36,880
created on that machines TPM is

00:10:35,290 --> 00:10:38,980
associated with the appropriate device

00:10:36,880 --> 00:10:40,870
and so should have the amount of access

00:10:38,980 --> 00:10:47,769
that this specific computer was supposed

00:10:40,870 --> 00:10:50,500
to have for Linux the information that

00:10:47,769 --> 00:10:53,589
we have is better than it was this time

00:10:50,500 --> 00:10:55,660
last year Rob to now has support for

00:10:53,589 --> 00:10:58,870
performing measurements of boot

00:10:55,660 --> 00:11:00,459
components so obviously we have whatever

00:10:58,870 --> 00:11:02,740
measurements the firmware generates

00:11:00,459 --> 00:11:05,000
itself and so for PC R 0 and PC R 2

00:11:02,740 --> 00:11:06,860
that's information about the firmware

00:11:05,000 --> 00:11:10,389
information about the firmware in option

00:11:06,860 --> 00:11:14,329
roms on plug-in cards we also have the

00:11:10,389 --> 00:11:17,930
hash of the bootloader so for systems

00:11:14,329 --> 00:11:20,329
that are using shim and secure boot shim

00:11:17,930 --> 00:11:22,639
will also measure the next stage

00:11:20,329 --> 00:11:27,920
bootloader so you don't have a gap

00:11:22,639 --> 00:11:30,199
between shim and grub we have the secure

00:11:27,920 --> 00:11:33,949
boot key States that's measured into PC

00:11:30,199 --> 00:11:37,029
are seven by the firmware and shim also

00:11:33,949 --> 00:11:39,529
measures its secure boot state and the

00:11:37,029 --> 00:11:43,250
key certificates that it's using to

00:11:39,529 --> 00:11:46,240
verify second-stage stuff so you have a

00:11:43,250 --> 00:11:48,560
log of if you are using secure boot the

00:11:46,240 --> 00:11:51,800
the certificates that we used at every

00:11:48,560 --> 00:11:54,110
stage in the security chain grub is

00:11:51,800 --> 00:11:58,129
measuring the kernel and the integer em

00:11:54,110 --> 00:11:59,930
FS grub is also measuring the kernel

00:11:58,129 --> 00:12:01,879
command line because the kernel command

00:11:59,930 --> 00:12:03,740
line it certain sales is kind of

00:12:01,879 --> 00:12:05,000
relevant from a security perspective you

00:12:03,740 --> 00:12:07,759
have the ability to do things like

00:12:05,000 --> 00:12:09,500
overwrites the iommu configuration and

00:12:07,759 --> 00:12:11,689
if you've got a physically present

00:12:09,500 --> 00:12:13,910
attacker and if you've got DMA capable

00:12:11,689 --> 00:12:16,250
ports if someone tables turn off the

00:12:13,910 --> 00:12:18,430
iommu and you're expecting the iommu to

00:12:16,250 --> 00:12:20,809
provide protection for your system

00:12:18,430 --> 00:12:21,829
that's gone out the windows so some

00:12:20,809 --> 00:12:23,269
amounts of security sensitive

00:12:21,829 --> 00:12:26,149
informations contains within the kernel

00:12:23,269 --> 00:12:29,300
command line and then obviously we have

00:12:26,149 --> 00:12:33,399
anything that imma is measuring which is

00:12:29,300 --> 00:12:33,399
going to depend on local I'm a policy

00:12:38,329 --> 00:12:43,010
so here's the code release thus far

00:12:41,149 --> 00:12:45,949
Matthew Garrett's patches to the kernel

00:12:43,010 --> 00:12:47,690
have landed in kernel 5.3 so if you're

00:12:45,949 --> 00:12:53,570
running that version or later you can

00:12:47,690 --> 00:12:57,019
actually get a TCG to event log we also

00:12:53,570 --> 00:12:58,550
have released three different github

00:12:57,019 --> 00:13:02,060
repositories that contain the

00:12:58,550 --> 00:13:04,940
foundations for our implementation the

00:13:02,060 --> 00:13:07,190
first go TPM is actually primarily

00:13:04,940 --> 00:13:11,209
developed by different team at Google

00:13:07,190 --> 00:13:15,769
working on cloud security this contains

00:13:11,209 --> 00:13:18,680
the low-level methods for communicating

00:13:15,769 --> 00:13:21,260
with the TPM and doesn't contain any of

00:13:18,680 --> 00:13:25,220
the higher-level ways of doing things

00:13:21,260 --> 00:13:28,910
like quoting or key certification go TPM

00:13:25,220 --> 00:13:32,000
tools is where we're storing our test

00:13:28,910 --> 00:13:36,170
data and some test clients it's useful

00:13:32,000 --> 00:13:38,810
for just messing around 2:30 p.m. and go

00:13:36,170 --> 00:13:42,319
at the station is our primary project

00:13:38,810 --> 00:13:44,600
which builds upon go TP go TPM to

00:13:42,319 --> 00:13:47,860
actually do the higher-level operations

00:13:44,600 --> 00:13:50,690
such as key certification quoting

00:13:47,860 --> 00:13:52,730
grabbing the measurement log credential

00:13:50,690 --> 00:13:59,529
activation and everything you need to

00:13:52,730 --> 00:13:59,529
actually use TPMS effectively

00:14:04,390 --> 00:14:08,560
but obviously this wouldn't be a

00:14:06,850 --> 00:14:10,209
particularly convincing discussion

00:14:08,560 --> 00:14:15,190
session if we didn't have anything to

00:14:10,209 --> 00:14:17,709
discuss so right now there's something

00:14:15,190 --> 00:14:21,100
of a functionality gap between Linux and

00:14:17,709 --> 00:14:24,700
Windows Windows when it boots logs a lot

00:14:21,100 --> 00:14:26,769
of additional metadata in the event log

00:14:24,700 --> 00:14:29,500
and we now have code for parsing that

00:14:26,769 --> 00:14:33,130
out so for instance on Windows were able

00:14:29,500 --> 00:14:36,070
to verify whether a system booted with a

00:14:33,130 --> 00:14:38,470
an encrypted disk and if it did have an

00:14:36,070 --> 00:14:42,760
encrypted filesystem whether the key for

00:14:38,470 --> 00:14:44,709
that filesystem was backed by the TPM or

00:14:42,760 --> 00:14:47,230
whether that was something that the user

00:14:44,709 --> 00:14:50,500
typed in so that allows us to verify

00:14:47,230 --> 00:14:54,070
that a system meets our certain aspects

00:14:50,500 --> 00:14:56,170
of our internal security policy before

00:14:54,070 --> 00:14:58,720
we've run cert access so you can't just

00:14:56,170 --> 00:15:01,600
take a system and then throw a fresh

00:14:58,720 --> 00:15:03,130
copy of Windows onto it and have a

00:15:01,600 --> 00:15:06,700
different security posture and still

00:15:03,130 --> 00:15:08,640
retain access to internal resources we

00:15:06,700 --> 00:15:11,589
also get information about which

00:15:08,640 --> 00:15:14,410
components were loaded during the boot

00:15:11,589 --> 00:15:18,670
process so for Windows that include

00:15:14,410 --> 00:15:21,190
stuff like was Windows Defender started

00:15:18,670 --> 00:15:23,589
in the early launch phase as in before

00:15:21,190 --> 00:15:25,540
any non-microsoft components Bulow's it

00:15:23,589 --> 00:15:27,310
and that's something that we want to be

00:15:25,540 --> 00:15:29,920
able to guarantee in order to say okay

00:15:27,310 --> 00:15:31,570
if someone was able to get malware onto

00:15:29,920 --> 00:15:33,490
the system then Windows Defender was

00:15:31,570 --> 00:15:36,279
launched before that malware had an

00:15:33,490 --> 00:15:38,769
ability to do anything so the equivalent

00:15:36,279 --> 00:15:44,019
for when for Linux would be largely did

00:15:38,769 --> 00:15:45,579
we load our security policies so if

00:15:44,019 --> 00:15:48,820
we're using Eimer did we Lowe's the

00:15:45,579 --> 00:15:51,060
Eimer policy before we started launching

00:15:48,820 --> 00:15:53,589
any untrusted code because otherwise

00:15:51,060 --> 00:15:56,199
something could have had the opportunity

00:15:53,589 --> 00:15:58,660
to tamper with the system before the i/o

00:15:56,199 --> 00:16:03,579
policy was loaded and right now we don't

00:15:58,660 --> 00:16:05,110
have any of that functionality so really

00:16:03,579 --> 00:16:12,310
something we'd like to hear from people

00:16:05,110 --> 00:16:14,829
is what further stuff could people make

00:16:12,310 --> 00:16:17,670
use of and what is the best way for us

00:16:14,829 --> 00:16:19,920
to lock this should this be some

00:16:17,670 --> 00:16:22,340
up to the colonel or should we trust the

00:16:19,920 --> 00:16:25,620
interim FS as being past the TCB and

00:16:22,340 --> 00:16:29,280
just have userland generating logging

00:16:25,620 --> 00:16:31,260
events also for people who are looking

00:16:29,280 --> 00:16:33,810
to build on this we are very interested

00:16:31,260 --> 00:16:36,180
both here and afterwards in getting

00:16:33,810 --> 00:16:37,950
information about what sort of

00:16:36,180 --> 00:16:39,630
functionality you would like to see in

00:16:37,950 --> 00:16:43,260
the tooling that we're building what

00:16:39,630 --> 00:16:45,180
would make it more useful to you and you

00:16:43,260 --> 00:16:47,670
know anything else what else can we do

00:16:45,180 --> 00:16:49,530
to make this more useful in terms of

00:16:47,670 --> 00:16:55,200
being able to verify system state and

00:16:49,530 --> 00:16:57,830
device identity so with that we'll open

00:16:55,200 --> 00:17:01,170
this up for questions and discussion and

00:16:57,830 --> 00:17:03,630
also quick notes we'll be giving a

00:17:01,170 --> 00:17:07,170
presentation on the more sort of

00:17:03,630 --> 00:17:10,080
holistic detailed aspects of this at the

00:17:07,170 --> 00:17:18,200
Linux sorry at the open source limits on

00:17:10,080 --> 00:17:31,320
Friday at 3:15 so questions comments

00:17:18,200 --> 00:17:33,990
issues that you'd like to discuss one

00:17:31,320 --> 00:17:36,660
challenge with attestation is how do we

00:17:33,990 --> 00:17:38,670
know that the information that we are

00:17:36,660 --> 00:17:41,250
getting from the endpoint is the actual

00:17:38,670 --> 00:17:44,490
endpoint that we are interested in how

00:17:41,250 --> 00:17:47,760
about I spoof some values to you and are

00:17:44,490 --> 00:17:49,350
an intruder pretends that I am the

00:17:47,760 --> 00:17:51,690
machine that you're talking to a new

00:17:49,350 --> 00:17:54,920
grand access so how do you handle that

00:17:51,690 --> 00:17:54,920
kind of situation

00:18:01,049 --> 00:18:08,350
right it's a little bit awkward so in

00:18:05,859 --> 00:18:11,950
this case if we know if we have an

00:18:08,350 --> 00:18:14,619
ability to tie the identity of the

00:18:11,950 --> 00:18:17,379
endorsement key on the TPM to the device

00:18:14,619 --> 00:18:19,629
we care about then when we generate an

00:18:17,379 --> 00:18:22,019
association key we're able to verify

00:18:19,629 --> 00:18:25,899
that that a K was generators with that

00:18:22,019 --> 00:18:28,749
by a TPM with that ek if we're then able

00:18:25,899 --> 00:18:30,789
so we have two ways right now basically

00:18:28,749 --> 00:18:34,989
of binding that identity to the Machine

00:18:30,789 --> 00:18:36,429
identity the first is we trust on the

00:18:34,989 --> 00:18:38,259
initial enrollment that the machine is

00:18:36,429 --> 00:18:39,820
the machine as it claims to be the

00:18:38,259 --> 00:18:41,590
second is if we have a platform

00:18:39,820 --> 00:18:43,389
certificate from the platform vendor

00:18:41,590 --> 00:18:46,330
then we're able to make that association

00:18:43,389 --> 00:18:48,190
in a stronger way so we know in advance

00:18:46,330 --> 00:18:49,749
the Machine with this serial number that

00:18:48,190 --> 00:18:52,989
was shipped to us on this date from this

00:18:49,749 --> 00:18:55,480
vendor is expected to have this ek and

00:18:52,989 --> 00:18:57,700
therefore if an a K is presented to us

00:18:55,480 --> 00:19:01,320
that was generated by this ek we know

00:18:57,700 --> 00:19:05,590
that the a hey came from that device the

00:19:01,320 --> 00:19:08,710
quote itself has a nonce in it in those

00:19:05,590 --> 00:19:11,169
to prevent replay attacks so that gives

00:19:08,710 --> 00:19:14,590
us a way to verify that the clothes is

00:19:11,169 --> 00:19:16,029
fresh and we're able to compare the

00:19:14,590 --> 00:19:17,739
chain of trust back to the original

00:19:16,029 --> 00:19:21,029
device so it shouldn't be possible for

00:19:17,739 --> 00:19:21,029
someone to give us a fake

00:19:28,190 --> 00:19:33,409
so yes the ideally when machines are

00:19:31,610 --> 00:19:35,480
initially provisions the initial

00:19:33,409 --> 00:19:38,570
provisioning will be associated with the

00:19:35,480 --> 00:19:39,619
enrollment of the EK into our trust

00:19:38,570 --> 00:19:41,090
database if we don't have a platform

00:19:39,619 --> 00:19:42,619
certificate otherwise if we have a

00:19:41,090 --> 00:19:45,559
platform certificate then we'll also

00:19:42,619 --> 00:19:47,690
validate that the key K is associated

00:19:45,559 --> 00:19:49,100
with that we're getting something from

00:19:47,690 --> 00:19:52,129
the ek that we expect it to be

00:19:49,100 --> 00:19:54,559
associated with that device and then

00:19:52,129 --> 00:19:56,629
once we have an a K that we know is

00:19:54,559 --> 00:19:57,710
associated with this machine we can then

00:19:56,629 --> 00:20:05,659
verify that the quote came from the

00:19:57,710 --> 00:20:07,369
machine but that's a ek regarding the

00:20:05,659 --> 00:20:09,529
additional measurements and stuff so

00:20:07,369 --> 00:20:13,940
when I shouldn't think that IC is fully

00:20:09,529 --> 00:20:16,609
is measuring the signer of the Cardinal

00:20:13,940 --> 00:20:18,259
during KX ik not sure if this is already

00:20:16,609 --> 00:20:21,320
covered in your logged on patches or not

00:20:18,259 --> 00:20:24,440
if not currently I think the only I am a

00:20:21,320 --> 00:20:26,119
signatory scour but when most of the

00:20:24,440 --> 00:20:27,950
distros and do not have the ims

00:20:26,119 --> 00:20:30,470
signatures set on the kernels by default

00:20:27,950 --> 00:20:34,090
there this currently is just PE signed

00:20:30,470 --> 00:20:37,639
and when you're kicking into new kernel

00:20:34,090 --> 00:20:41,090
measuring this signature of that new con

00:20:37,639 --> 00:20:44,330
under your cakes into will complete the

00:20:41,090 --> 00:20:46,429
chain of you know right so at the

00:20:44,330 --> 00:20:49,609
moments I believe that if you're using

00:20:46,429 --> 00:20:53,269
ma and K exacting then we will end up

00:20:49,609 --> 00:20:56,269
with a log of the hash of the kernel but

00:20:53,269 --> 00:20:57,950
we won't have a way to just like with

00:20:56,269 --> 00:21:02,239
the PC are seven measurements say that

00:20:57,950 --> 00:21:04,039
the we trust the signature the signer of

00:21:02,239 --> 00:21:06,559
the kernel as opposed to having to care

00:21:04,039 --> 00:21:13,429
about the exact kernel itself so yeah I

00:21:06,559 --> 00:21:15,649
think that's a hole at the moment I'm

00:21:13,429 --> 00:21:18,559
not talking about a signature in case

00:21:15,649 --> 00:21:19,539
most of the destroys are do not have AMA

00:21:18,559 --> 00:21:21,320
signatures

00:21:19,539 --> 00:21:23,179
even if you don't have the I'm a

00:21:21,320 --> 00:21:24,259
signature then you'll still end up with

00:21:23,179 --> 00:21:27,320
the measurements of the hash of the

00:21:24,259 --> 00:21:29,480
kernel which is sufficient for some

00:21:27,320 --> 00:21:32,600
cases not for others but yes the

00:21:29,480 --> 00:21:34,539
signature of when k exec file those is

00:21:32,600 --> 00:21:37,009
verifying the signature we're not

00:21:34,539 --> 00:21:39,330
measuring this so that seems like a

00:21:37,009 --> 00:21:46,050
legitimate thing to measure

00:21:39,330 --> 00:21:48,600
I have two questions

00:21:46,050 --> 00:21:51,060
one you've I'm glad to hear you're using

00:21:48,600 --> 00:21:53,460
the platform sir second have you started

00:21:51,060 --> 00:21:56,550
looking at the idea of L dev work that's

00:21:53,460 --> 00:21:59,460
being done sorry B which work I dev and

00:21:56,550 --> 00:22:03,360
L dev from device has an identification

00:21:59,460 --> 00:22:07,440
tied to the TPM okay and then second of

00:22:03,360 --> 00:22:09,630
all you were mentioning lvl doing like a

00:22:07,440 --> 00:22:11,040
BitLocker what better to unlock

00:22:09,630 --> 00:22:13,980
something what were you thinking there

00:22:11,040 --> 00:22:16,200
cuz I mean for instance on open XT week

00:22:13,980 --> 00:22:23,160
at the PC R after we've done the unlock

00:22:16,200 --> 00:22:24,990
from yes I'm still rate so it's a great

00:22:23,160 --> 00:22:27,060
question so one of the issues that we

00:22:24,990 --> 00:22:34,230
have here is that most systems that's

00:22:27,060 --> 00:22:36,270
our if we want this to work the way that

00:22:34,230 --> 00:22:39,060
most loans distributions currently work

00:22:36,270 --> 00:22:41,190
then the unlock occurs in the energy RFS

00:22:39,060 --> 00:22:45,510
rather than in the bootloader and that

00:22:41,190 --> 00:22:47,910
means that something at that point needs

00:22:45,510 --> 00:22:49,530
to pour some information to the TPM so I

00:22:47,910 --> 00:22:50,790
think it's a reason the open question

00:22:49,530 --> 00:22:52,890
whether the thing that should be pushing

00:22:50,790 --> 00:22:56,520
us is either the user land tooling or

00:22:52,890 --> 00:22:58,830
whether certain events where we push

00:22:56,520 --> 00:23:01,260
crypto into the kernel should result in

00:22:58,830 --> 00:23:03,360
the kernel itself reducing the

00:23:01,260 --> 00:23:04,800
measurements now in cases where it's

00:23:03,360 --> 00:23:06,300
going through used lines and the kernel

00:23:04,800 --> 00:23:08,190
has no idea where this material came

00:23:06,300 --> 00:23:12,540
from then you know it's sort of

00:23:08,190 --> 00:23:17,040
inevitably we need to do that indeed use

00:23:12,540 --> 00:23:18,960
land tooling and nominally since the use

00:23:17,040 --> 00:23:23,120
line tooling is embedded within the

00:23:18,960 --> 00:23:26,910
image Ram FS the unit for FS is

00:23:23,120 --> 00:23:29,820
trustworthy it's beep very high design

00:23:26,910 --> 00:23:32,340
with that before so but then obviously

00:23:29,820 --> 00:23:33,840
if we're going to argue that the NFS is

00:23:32,340 --> 00:23:37,470
trustworthy then we probably need the

00:23:33,840 --> 00:23:38,820
energy RFS to itself cap the PC odds

00:23:37,470 --> 00:23:40,740
again at the point where the and triumph

00:23:38,820 --> 00:23:43,530
s is transitioning to the live system

00:23:40,740 --> 00:23:46,590
and the right point to do that at is not

00:23:43,530 --> 00:23:49,730
something that's really settled yet but

00:23:46,590 --> 00:23:49,730
that's an excellent point

00:23:53,029 --> 00:24:02,129
so yesterday Paul said that the colonel

00:23:59,970 --> 00:24:04,740
Quinlan was not being hashed and

00:24:02,129 --> 00:24:07,919
measured and you just said that you were

00:24:04,740 --> 00:24:12,029
doing that so Grubb does so in the

00:24:07,919 --> 00:24:14,820
current code base okay so one of the

00:24:12,029 --> 00:24:16,919
problems but that's is that since the

00:24:14,820 --> 00:24:20,129
colonel command line generally includes

00:24:16,919 --> 00:24:24,029
the root filesystem and if that's a UUID

00:24:20,129 --> 00:24:26,309
then you're if you're going to build any

00:24:24,029 --> 00:24:30,090
sort of policy around that it's very

00:24:26,309 --> 00:24:31,409
difficult to say this is a static good

00:24:30,090 --> 00:24:33,090
PCR value because that will be

00:24:31,409 --> 00:24:34,799
completely machine specific so you

00:24:33,090 --> 00:24:36,899
really need event log parsing and you

00:24:34,799 --> 00:24:38,639
even then can't look at just the values

00:24:36,899 --> 00:24:41,730
in the event log you need to look at the

00:24:38,639 --> 00:24:45,690
event log data verify whether the event

00:24:41,730 --> 00:24:49,200
log data hashes to the event log entry

00:24:45,690 --> 00:24:50,820
and then parse the command line so we're

00:24:49,200 --> 00:24:52,830
not just measuring the command line

00:24:50,820 --> 00:24:53,909
we're also logging the command line in

00:24:52,830 --> 00:24:55,830
the event log so you have a Chris

00:24:53,909 --> 00:24:59,570
graphically verified copy of the command

00:24:55,830 --> 00:24:59,570
line which you've then paused remotely

00:25:00,050 --> 00:25:05,039
[Music]

00:25:01,850 --> 00:25:07,019
so most the infrastructure to do this is

00:25:05,039 --> 00:25:08,580
there but right now we don't have policy

00:25:07,019 --> 00:25:11,159
written around consuming that and

00:25:08,580 --> 00:25:13,429
turning it into a this is good or this

00:25:11,159 --> 00:25:13,429
is bad

00:25:14,269 --> 00:25:18,840
so if you want predictable values for

00:25:17,759 --> 00:25:22,559
the kernel command line then yeah you

00:25:18,840 --> 00:25:24,149
needs before you you IDs this is sort of

00:25:22,559 --> 00:25:26,850
a policy question on how you use beyond

00:25:24,149 --> 00:25:28,740
Corp are you targeting sort of employee

00:25:26,850 --> 00:25:30,889
built devices employee owned devices or

00:25:28,740 --> 00:25:33,419
these all corporate owned devices like

00:25:30,889 --> 00:25:35,429
how do you measure how do you like

00:25:33,419 --> 00:25:37,169
usefully do measurements of like I

00:25:35,429 --> 00:25:38,759
brought my laptop in from home and I

00:25:37,169 --> 00:25:40,679
would like to check my email or is that

00:25:38,759 --> 00:25:42,210
out of scope for your use guys that

00:25:40,679 --> 00:25:44,039
times gopher use case okay so when you

00:25:42,210 --> 00:25:45,539
say beyond Corp these are all corporate

00:25:44,039 --> 00:25:47,669
IT has purchased and provisioned these

00:25:45,539 --> 00:25:52,769
devices yes but they are for taking home

00:25:47,669 --> 00:25:56,789
yes okay and ideally this is something

00:25:52,769 --> 00:25:58,679
we could use to prevent employees from

00:25:56,789 --> 00:26:01,080
actually bringing devices and using them

00:25:58,679 --> 00:26:02,580
at work okay in a cryptographic easier

00:26:01,080 --> 00:26:04,170
way it's like for example

00:26:02,580 --> 00:26:05,580
you lose your laptop and buy a new one

00:26:04,170 --> 00:26:08,640
and try to pretend you never lost your

00:26:05,580 --> 00:26:10,560
laptop and say this is now my new Google

00:26:08,640 --> 00:26:14,570
managed laptop we're gonna catch you and

00:26:10,560 --> 00:26:14,570
say no sorry okay

00:26:22,840 --> 00:26:29,210
it's like no more questions okay thanks

00:26:28,450 --> 00:26:32,640
guys

00:26:29,210 --> 00:26:32,640
[Applause]

00:26:34,150 --> 00:26:36,210

YouTube URL: https://www.youtube.com/watch?v=TKva_h66Ptc


