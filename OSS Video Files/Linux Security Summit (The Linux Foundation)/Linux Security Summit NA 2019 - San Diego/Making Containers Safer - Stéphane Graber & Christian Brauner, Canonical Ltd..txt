Title: Making Containers Safer - Stéphane Graber & Christian Brauner, Canonical Ltd.
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Making Containers Safer - Stéphane Graber & Christian Brauner, Canonical Ltd.

Containers are used for a multitude of workloads everywhere today. But not all containers are actually created in a way that we can be sure that they are safe to use. In fact, CVE-2019-5736 has shown that most containers are not.In this talk we will thus take a close look at what is required to make containers safe.The first part of this presentation we will go over the main type of containers out there, look at what security features they are using and what their security model is.In the second part we will be focusing on new features, covering recent kernel developments to make unprivileged containers safe and at the same time more usable.In the last part we will take a look at what we consider remaining challenges to make containers safe.
Captions: 
	00:00:00,030 --> 00:00:04,049
good morning everyone um I'm Stefan

00:00:01,770 --> 00:00:08,639
Gruber that's Christian Brunner we've

00:00:04,049 --> 00:00:11,460
work at canonical on the Lex tea team

00:00:08,639 --> 00:00:15,269
we also are behind the LXE like CFS

00:00:11,460 --> 00:00:18,000
projects and some amount of Keller work

00:00:15,269 --> 00:00:20,189
in the content space for wine today

00:00:18,000 --> 00:00:23,279
we're going to be looking at making

00:00:20,189 --> 00:00:24,689
containers safer and both some of the

00:00:23,279 --> 00:00:28,380
things we've done in the past kind of

00:00:24,689 --> 00:00:31,560
what our use cases are and also how to

00:00:28,380 --> 00:00:40,230
move forward and you know what needs to

00:00:31,560 --> 00:00:43,230
happen to make them that much okay so

00:00:40,230 --> 00:00:48,680
first of all like yeah and see if I can

00:00:43,230 --> 00:00:53,520
move that a bit sorry maybe pointed up

00:00:48,680 --> 00:00:56,300
testing yeah cool all right

00:00:53,520 --> 00:01:01,590
so why do we care about safe containers

00:00:56,300 --> 00:01:05,060
not everyone does Kelly we do in our

00:01:01,590 --> 00:01:07,200
case we've been working on containers

00:01:05,060 --> 00:01:08,729
for over a decade

00:01:07,200 --> 00:01:12,720
so the Alexi project which is the

00:01:08,729 --> 00:01:14,250
original Linux containers project using

00:01:12,720 --> 00:01:16,320
the mainline kernel for containers

00:01:14,250 --> 00:01:17,670
that's been around over decade legacy

00:01:16,320 --> 00:01:21,600
itself has been around about five years

00:01:17,670 --> 00:01:25,020
now those two really focus on system

00:01:21,600 --> 00:01:28,170
containers so our goal is to run

00:01:25,020 --> 00:01:30,150
unmodified Linux distributions we are

00:01:28,170 --> 00:01:31,950
not trying to run like single

00:01:30,150 --> 00:01:34,200
applications or like particularly

00:01:31,950 --> 00:01:36,659
tailored workloads we do really care

00:01:34,200 --> 00:01:40,290
about running perfectly standard UNIX

00:01:36,659 --> 00:01:42,210
distro as you find it anywhere else for

00:01:40,290 --> 00:01:43,729
legs is specifically we really very much

00:01:42,210 --> 00:01:47,790
focused on getting you the same kind of

00:01:43,729 --> 00:01:50,640
primitives and usability as a virtual

00:01:47,790 --> 00:01:52,470
machine so the user doesn't really know

00:01:50,640 --> 00:01:53,759
like once they get a shell inside that

00:01:52,470 --> 00:01:56,460
container hood that they are in a

00:01:53,759 --> 00:01:58,439
container or on this natural virtual

00:01:56,460 --> 00:02:00,780
machine it's not really visible to them

00:01:58,439 --> 00:02:04,530
the only really visible thing is that

00:02:00,780 --> 00:02:09,420
it's using a shared kernel in certain

00:02:04,530 --> 00:02:10,800
environment like we we care quite deeply

00:02:09,420 --> 00:02:12,330
about security because some people might

00:02:10,800 --> 00:02:13,230
actually want to give it's a safe access

00:02:12,330 --> 00:02:14,430
to those containers

00:02:13,230 --> 00:02:15,989
different users that might run

00:02:14,430 --> 00:02:18,959
interesting binaries that might do a lot

00:02:15,989 --> 00:02:21,120
of weird things as a result we've been

00:02:18,959 --> 00:02:24,510
focusing on security for both Eric Z and

00:02:21,120 --> 00:02:27,150
X T for a long time we are using pretty

00:02:24,510 --> 00:02:28,860
much every tricks available Lex T

00:02:27,150 --> 00:02:31,440
defaults to in previous containers using

00:02:28,860 --> 00:02:36,269
missile namespaces we used in a sense we

00:02:31,440 --> 00:02:38,400
use C groups we use like fancy custom ii

00:02:36,269 --> 00:02:41,040
policies pretty much anything you can

00:02:38,400 --> 00:02:43,530
think of we're doing it and we are

00:02:41,040 --> 00:02:47,160
working pretty hard both in user space

00:02:43,530 --> 00:02:49,470
and kernel space to just make it much

00:02:47,160 --> 00:02:51,180
easier for people to run whatever that

00:02:49,470 --> 00:02:54,150
nobody doing inside certain previous

00:02:51,180 --> 00:02:55,739
containers our goals are like previous

00:02:54,150 --> 00:02:58,349
containers should just not be a thing

00:02:55,739 --> 00:03:00,269
and we want people to be able to use our

00:02:58,349 --> 00:03:01,950
containers just like they wouldíve

00:03:00,269 --> 00:03:04,680
actual machine and not have to care

00:03:01,950 --> 00:03:09,090
about a neighboring container affecting

00:03:04,680 --> 00:03:10,500
them so I said we run on modified

00:03:09,090 --> 00:03:13,739
distros and we run quite a bit of those

00:03:10,500 --> 00:03:16,140
we do run support running Europe

00:03:13,739 --> 00:03:18,299
standards Debian Ubuntu CentOS Medora

00:03:16,140 --> 00:03:21,359
type things we also support running

00:03:18,299 --> 00:03:22,910
Android and open wrt and some of the

00:03:21,359 --> 00:03:26,639
other less-common

00:03:22,910 --> 00:03:27,090
Linux we actually build a lot of those

00:03:26,639 --> 00:03:28,500
images

00:03:27,090 --> 00:03:30,870
we've got them available on our image

00:03:28,500 --> 00:03:34,139
server that dated daily so we right now

00:03:30,870 --> 00:03:36,959
we build 18 different distros 77

00:03:34,139 --> 00:03:38,489
different releases or about 300

00:03:36,959 --> 00:03:39,870
different images every day because we

00:03:38,489 --> 00:03:43,290
also build on six different

00:03:39,870 --> 00:03:46,139
architectures we've got hundreds of

00:03:43,290 --> 00:03:48,810
thousands of active users that are using

00:03:46,139 --> 00:03:50,069
those images and creating new containers

00:03:48,810 --> 00:03:54,889
or operating the exiting containers

00:03:50,069 --> 00:03:59,819
every day we also want all Chromebooks

00:03:54,889 --> 00:04:03,269
Lex T is used behind the Linux Linux

00:03:59,819 --> 00:04:06,239
application feature on Chromebooks it's

00:04:03,269 --> 00:04:07,739
available on all new Chromebooks at this

00:04:06,239 --> 00:04:08,940
point and available on a number of all

00:04:07,739 --> 00:04:12,269
the Chromebooks as well

00:04:08,940 --> 00:04:15,239
so longer stays photo ID features for

00:04:12,269 --> 00:04:18,060
Chromebook specific it's interesting the

00:04:15,239 --> 00:04:20,729
way it's set up they are using both

00:04:18,060 --> 00:04:22,979
virtual machines and containers so they

00:04:20,729 --> 00:04:26,430
are starting a per user virtual machine

00:04:22,979 --> 00:04:27,570
using cross VM and that insight that

00:04:26,430 --> 00:04:31,500
machine they've got effectively a

00:04:27,570 --> 00:04:36,210
read-only Linux system we have which

00:04:31,500 --> 00:04:38,220
runs laxity with some persistent storage

00:04:36,210 --> 00:04:40,889
that's why someone's attached to that VM

00:04:38,220 --> 00:04:42,900
and then next Iran's own previous

00:04:40,889 --> 00:04:44,699
containers they actually contributed

00:04:42,900 --> 00:04:47,100
codes to do our projects to make it

00:04:44,699 --> 00:04:51,419
impossible to create previous containers

00:04:47,100 --> 00:04:53,400
in any way shape or form and it's very

00:04:51,419 --> 00:04:56,880
well integrated with the rest of the

00:04:53,400 --> 00:04:59,099
Chrome OS platform they support GPU pass

00:04:56,880 --> 00:05:03,990
through USB pass-through access to sound

00:04:59,099 --> 00:05:06,449
card sharing files triggering snapshots

00:05:03,990 --> 00:05:09,270
and backups directly from the Chrome OS

00:05:06,449 --> 00:05:10,770
interface and applications installed

00:05:09,270 --> 00:05:13,949
inside those containers will just

00:05:10,770 --> 00:05:18,870
seamlessly integrate with the Chrome OS

00:05:13,949 --> 00:05:23,460
system so that's kind of why we care

00:05:18,870 --> 00:05:27,060
we've got all of those users on various

00:05:23,460 --> 00:05:30,060
distros all trying to run whatever they

00:05:27,060 --> 00:05:30,930
feel like like any normal work they

00:05:30,060 --> 00:05:32,310
would normally run inside a virtual

00:05:30,930 --> 00:05:34,349
machine it would just bring it and set a

00:05:32,310 --> 00:05:39,690
container get much much increased

00:05:34,349 --> 00:05:41,010
density but like some of the words that

00:05:39,690 --> 00:05:42,720
rescues might have been a bit confusing

00:05:41,010 --> 00:05:45,720
so maybe we should just take a step back

00:05:42,720 --> 00:05:47,789
and kind of go through some of the

00:05:45,720 --> 00:05:49,500
terminology around there I did mention

00:05:47,789 --> 00:05:51,479
previous containers and previous

00:05:49,500 --> 00:05:53,820
containers you might also have heard

00:05:51,479 --> 00:05:58,470
good test containers before that's also

00:05:53,820 --> 00:05:59,880
a thing then you've got the the user

00:05:58,470 --> 00:06:04,500
space definition of some of those is

00:05:59,880 --> 00:06:06,599
also kind of quirky docker for example

00:06:04,500 --> 00:06:08,070
has a privileged flag which doesn't mean

00:06:06,599 --> 00:06:09,659
that it's unprivileged normally it just

00:06:08,070 --> 00:06:15,150
means that it's privileged privileged

00:06:09,659 --> 00:06:17,550
when you pass it and you used to have

00:06:15,150 --> 00:06:18,630
containers that like the diffusion of

00:06:17,550 --> 00:06:22,889
what the container is is always gonna

00:06:18,630 --> 00:06:25,110
like how many new species do you need to

00:06:22,889 --> 00:06:26,699
use for it to be a natural container to

00:06:25,110 --> 00:06:30,110
unity you see groups to interviews that

00:06:26,699 --> 00:06:32,070
assigns to interviews capabilities it's

00:06:30,110 --> 00:06:34,349
because there's no such thing as a

00:06:32,070 --> 00:06:38,849
container on linux that's purely a user

00:06:34,349 --> 00:06:40,590
space thing we can't just say oh you're

00:06:38,849 --> 00:06:41,909
running a second tenure you're safe but

00:06:40,590 --> 00:06:43,050
you also can't say that oh you're

00:06:41,909 --> 00:06:46,260
running it's a container therefore you

00:06:43,050 --> 00:06:53,010
can't be safe thank it really matters

00:06:46,260 --> 00:06:54,570
and exactly you've set things up so just

00:06:53,010 --> 00:06:55,940
to Train differentiate these are two

00:06:54,570 --> 00:06:58,650
main kinds

00:06:55,940 --> 00:07:00,900
first of all you've got your previous

00:06:58,650 --> 00:07:02,550
container previous container at least no

00:07:00,900 --> 00:07:04,770
definition I think everyone can agree on

00:07:02,550 --> 00:07:07,849
that one it means that root in the

00:07:04,770 --> 00:07:11,370
container is real root there is no

00:07:07,849 --> 00:07:13,050
translation going on or anything it is

00:07:11,370 --> 00:07:14,250
running we feel like if you've got the

00:07:13,050 --> 00:07:17,840
process running in that container it's

00:07:14,250 --> 00:07:20,550
running way free root privileges that

00:07:17,840 --> 00:07:23,190
sadly was used by the vast majority of

00:07:20,550 --> 00:07:25,020
containers on their most docker

00:07:23,190 --> 00:07:28,680
containers most containers running on

00:07:25,020 --> 00:07:31,139
kubernetes our previous containers the

00:07:28,680 --> 00:07:33,630
security story for those pretty much

00:07:31,139 --> 00:07:35,729
entirely relies on properly configured

00:07:33,630 --> 00:07:39,690
LSMs capabilities

00:07:35,729 --> 00:07:41,460
second extra pillage dropping wherever

00:07:39,690 --> 00:07:43,770
possible to try and prevent any of those

00:07:41,460 --> 00:07:45,960
workloads from either ever getting root

00:07:43,770 --> 00:07:49,710
access or if they need to run as root

00:07:45,960 --> 00:07:53,940
having as limited the root user as

00:07:49,710 --> 00:07:56,729
possible so that they can't escape it's

00:07:53,940 --> 00:07:58,080
very easy to create anyone can create

00:07:56,729 --> 00:08:00,300
those containers very easily with just a

00:07:58,080 --> 00:08:03,419
few shell commands but it's extremely

00:08:00,300 --> 00:08:07,860
dangerous if you're wrong and people

00:08:03,419 --> 00:08:09,750
have our personal stands for Alexian

00:08:07,860 --> 00:08:13,440
next is that previous containers are not

00:08:09,750 --> 00:08:15,630
root safe and cannot be root safe we

00:08:13,440 --> 00:08:18,000
look for a number of years now we've

00:08:15,630 --> 00:08:20,210
actually four pretty much forever with

00:08:18,000 --> 00:08:22,919
defectively - lines

00:08:20,210 --> 00:08:24,810
any report of a security issue against

00:08:22,919 --> 00:08:26,760
XE all XD that's specifically for

00:08:24,810 --> 00:08:28,409
previous containers we just don't go

00:08:26,760 --> 00:08:30,030
that route safe and if anyone has

00:08:28,409 --> 00:08:33,420
changed safety

00:08:30,030 --> 00:08:35,970
and they're just gonna have issues we do

00:08:33,420 --> 00:08:38,610
a best effort to shift policies to block

00:08:35,970 --> 00:08:40,530
any potential holes we are aware of but

00:08:38,610 --> 00:08:42,750
goes to notice new holes are popping up

00:08:40,530 --> 00:08:44,730
in Linux pretty much every day or we

00:08:42,750 --> 00:08:46,500
cannot release and that it's a losing

00:08:44,730 --> 00:08:48,350
battle that's why we've been focusing so

00:08:46,500 --> 00:08:51,510
much on the other class of containers

00:08:48,350 --> 00:08:53,910
job and previous containers obviously

00:08:51,510 --> 00:08:56,100
those mean that routing the container is

00:08:53,910 --> 00:08:58,860
not reach outside of the container but

00:08:56,100 --> 00:09:02,550
then again you've got a bit of variety

00:08:58,860 --> 00:09:05,280
there as well because sure you've got a

00:09:02,550 --> 00:09:07,170
mapped root user so if you escape the

00:09:05,280 --> 00:09:11,030
container you might be UID hundred

00:09:07,170 --> 00:09:14,040
thousand with pretty limited privileges

00:09:11,030 --> 00:09:15,870
but what happens if you get multiple one

00:09:14,040 --> 00:09:18,420
of those containers do you all do you

00:09:15,870 --> 00:09:20,640
want them all to tie to the same UID and

00:09:18,420 --> 00:09:22,290
if you do and they can escaped and are

00:09:20,640 --> 00:09:25,110
you happy with one container being able

00:09:22,290 --> 00:09:26,760
to access the other maybe not so you

00:09:25,110 --> 00:09:30,750
might also have encouraged containers

00:09:26,760 --> 00:09:32,460
that have this thing distinct Maps so

00:09:30,750 --> 00:09:34,980
either for the reducer itself or for the

00:09:32,460 --> 00:09:36,780
entirety of the container in next day we

00:09:34,980 --> 00:09:38,490
call that isolated mode if you turn that

00:09:36,780 --> 00:09:44,010
on then every single container gets

00:09:38,490 --> 00:09:48,690
there on 65,000 454 you are these entry

00:09:44,010 --> 00:09:51,030
IDs it's that way

00:09:48,690 --> 00:09:53,580
like if you can escape or some reason at

00:09:51,030 --> 00:09:55,650
least there's literally nothing else

00:09:53,580 --> 00:09:59,310
running that you can train on other than

00:09:55,650 --> 00:10:04,020
yourself but also it means that there is

00:09:59,310 --> 00:10:06,480
no d OS that can trivially be done which

00:10:04,020 --> 00:10:08,100
is not the case if you forget to do that

00:10:06,480 --> 00:10:10,800
stuff because we might be able to set

00:10:08,100 --> 00:10:12,210
like a user limit on a specific UID

00:10:10,800 --> 00:10:14,250
inside your container and as well very

00:10:12,210 --> 00:10:16,850
happily applied to the same UID in

00:10:14,250 --> 00:10:16,850
another container

00:10:18,510 --> 00:10:23,649
that's not a new thing people always

00:10:21,760 --> 00:10:25,060
talk about like oh yeah we might look

00:10:23,649 --> 00:10:27,190
into user name space at some point but

00:10:25,060 --> 00:10:29,830
it's been around since the 312 camera

00:10:27,190 --> 00:10:32,680
we've had full support for it in a taxi

00:10:29,830 --> 00:10:35,170
since that time we've shipped like the

00:10:32,680 --> 00:10:37,089
first lady release we pushed out was on

00:10:35,170 --> 00:10:39,670
an Ubuntu is that what shipping with

00:10:37,089 --> 00:10:42,399
this we thought all the time and it's

00:10:39,670 --> 00:10:43,089
been around a while we understand it it

00:10:42,399 --> 00:10:45,490
can be used

00:10:43,089 --> 00:10:49,510
none of the semantics have really

00:10:45,490 --> 00:10:53,709
changed since yet we're pretty much the

00:10:49,510 --> 00:10:55,390
only ones using it one of the big issues

00:10:53,709 --> 00:10:59,610
for some of the other container runtimes

00:10:55,390 --> 00:11:03,360
is the file system aspect of this

00:10:59,610 --> 00:11:07,390
specifically I mean as soon as you run

00:11:03,360 --> 00:11:08,860
distinct ID map so every container if

00:11:07,390 --> 00:11:10,750
the sea of fire coming from another

00:11:08,860 --> 00:11:12,640
container it's gonna show up as the

00:11:10,750 --> 00:11:14,020
overflow UID it's gonna show up as minus

00:11:12,640 --> 00:11:16,320
one effectively and you might not be

00:11:14,020 --> 00:11:20,890
able to read or write that data anymore

00:11:16,320 --> 00:11:22,240
it's fine for XD containers because it

00:11:20,890 --> 00:11:24,370
is like a limitation that people

00:11:22,240 --> 00:11:27,250
understand and sure they can't attach

00:11:24,370 --> 00:11:29,860
the shed volume to to actually get

00:11:27,250 --> 00:11:31,870
containers that's my resolution they can

00:11:29,860 --> 00:11:33,550
understand the problem is when you look

00:11:31,870 --> 00:11:36,550
at something like docker which uses

00:11:33,550 --> 00:11:38,350
layers and those layers are then stacked

00:11:36,550 --> 00:11:39,490
on top of each other and then used as

00:11:38,350 --> 00:11:42,700
the root filesystem or different

00:11:39,490 --> 00:11:44,620
containers that doesn't work because the

00:11:42,700 --> 00:11:46,930
layers themselves include your ideas

00:11:44,620 --> 00:11:47,740
entry IDs there is a single copy of them

00:11:46,930 --> 00:11:50,950
on the file system

00:11:47,740 --> 00:11:54,160
they are then layered and then that's

00:11:50,950 --> 00:11:56,290
passed into the container if you use

00:11:54,160 --> 00:11:57,790
user name spaces then everything on your

00:11:56,290 --> 00:12:00,730
inside your container shows up as the

00:11:57,790 --> 00:12:04,000
overflow UID we've actually done some

00:12:00,730 --> 00:12:04,570
work pretty recently to address those

00:12:04,000 --> 00:12:06,670
concerns

00:12:04,570 --> 00:12:08,140
not specifically for that because we're

00:12:06,670 --> 00:12:10,270
not working on docker

00:12:08,140 --> 00:12:13,000
but for the data sharing between

00:12:10,270 --> 00:12:15,190
isolated XD containers that work is

00:12:13,000 --> 00:12:18,670
shift FS which is effectively an overlay

00:12:15,190 --> 00:12:20,620
file system that does shifting of your

00:12:18,670 --> 00:12:23,770
ideas and she IDs across usernames based

00:12:20,620 --> 00:12:26,829
boundaries it's obviously dangerous if

00:12:23,770 --> 00:12:28,329
you set it wrong and you do it on slash

00:12:26,829 --> 00:12:30,579
of the host because then hey you can do

00:12:28,329 --> 00:12:32,100
what you want but it's very useful if

00:12:30,579 --> 00:12:33,870
you set it up right

00:12:32,100 --> 00:12:36,690
we are sharing data between containers

00:12:33,870 --> 00:12:39,180
it could also be used on top of a stack

00:12:36,690 --> 00:12:40,800
of layers to then allow foreign

00:12:39,180 --> 00:12:43,889
privileged application containers to a

00:12:40,800 --> 00:12:46,259
bottling right now that particular work

00:12:43,889 --> 00:12:48,660
is a distro but in the Ubuntu cammo

00:12:46,259 --> 00:12:50,699
mostly because the current approach is

00:12:48,660 --> 00:12:53,759
not considered to be really suitable for

00:12:50,699 --> 00:12:56,040
upstream we are waiting to instead add

00:12:53,759 --> 00:12:58,470
that feature to the new mount API and

00:12:56,040 --> 00:13:01,410
yep seem calm which seems like a much

00:12:58,470 --> 00:13:06,810
better fit but we needed something quick

00:13:01,410 --> 00:13:09,180
so we did something quick and maybe last

00:13:06,810 --> 00:13:11,220
thing to mention is ruthless containers

00:13:09,180 --> 00:13:14,430
which is maybe another word you've heard

00:13:11,220 --> 00:13:16,170
before that normally refers to what we

00:13:14,430 --> 00:13:18,750
were calling before fully and finished

00:13:16,170 --> 00:13:19,980
containers so that's containers not only

00:13:18,750 --> 00:13:22,319
are they on privileged in the sense that

00:13:19,980 --> 00:13:23,970
they use the user name space but also

00:13:22,319 --> 00:13:28,170
the unprivileged in sense that it was

00:13:23,970 --> 00:13:31,529
spawned by here and previous user that's

00:13:28,170 --> 00:13:34,050
mostly possible like you can and share a

00:13:31,529 --> 00:13:35,550
user name space and surname spaces as an

00:13:34,050 --> 00:13:37,350
entry user that's fine

00:13:35,550 --> 00:13:41,610
we've done that and supported it for

00:13:37,350 --> 00:13:44,459
years now in Alexi the problem usually

00:13:41,610 --> 00:13:48,199
hit is if you want more than just your

00:13:44,459 --> 00:13:51,029
own UID so you zero inside the container

00:13:48,199 --> 00:13:55,290
then you will need some security binary

00:13:51,029 --> 00:13:57,120
to set up more maps for you you can use

00:13:55,290 --> 00:13:58,860
the ones that come with shadow so that's

00:13:57,120 --> 00:14:00,870
new you ready map new GID map those

00:13:58,860 --> 00:14:03,120
about there and they use the it's easy

00:14:00,870 --> 00:14:05,579
idea CGI defines to control that

00:14:03,120 --> 00:14:08,459
behavior the other thing you're gonna

00:14:05,579 --> 00:14:10,649
run into is hey if you how about

00:14:08,459 --> 00:14:12,839
networking do you want your network

00:14:10,649 --> 00:14:14,519
interfaces because if you do you can

00:14:12,839 --> 00:14:16,800
create them but you there's no way you

00:14:14,519 --> 00:14:18,120
can bridge them on the host side or

00:14:16,800 --> 00:14:19,889
configure them on the host side as an

00:14:18,120 --> 00:14:24,839
imperious user so you need another

00:14:19,889 --> 00:14:27,060
situated minor e for that as a result we

00:14:24,839 --> 00:14:29,370
just containers of somewhat limited use

00:14:27,060 --> 00:14:31,230
right now because you just end up having

00:14:29,370 --> 00:14:33,509
to pile up a bunch of the trade binaries

00:14:31,230 --> 00:14:37,620
helpers everywhere to try and just do

00:14:33,509 --> 00:14:39,480
the pieces you need was most container

00:14:37,620 --> 00:14:42,149
managers just ran as the hosts and then

00:14:39,480 --> 00:14:43,750
spawn children container at a table and

00:14:42,149 --> 00:14:48,250
privileged

00:14:43,750 --> 00:14:49,930
if done right and there's no API access

00:14:48,250 --> 00:14:52,269
or anything from the container back to

00:14:49,930 --> 00:14:57,970
the host and you don't really concern

00:14:52,269 --> 00:15:00,899
doing that either sir I'm gonna and

00:14:57,970 --> 00:15:04,389
other things too Christian not cool oh

00:15:00,899 --> 00:15:09,250
that works sorry I need to remember to

00:15:04,389 --> 00:15:10,810
keep just my mouth so he talked about

00:15:09,250 --> 00:15:13,240
Stefan talked about privileged and

00:15:10,810 --> 00:15:15,490
unprivileged containers and one of the

00:15:13,240 --> 00:15:16,569
questions you probably have or a lot of

00:15:15,490 --> 00:15:21,040
people have is are they really that

00:15:16,569 --> 00:15:25,180
unsafe yes they really are this is a

00:15:21,040 --> 00:15:26,709
list of pretty bad CVS that we had over

00:15:25,180 --> 00:15:28,240
time and it's just against a single

00:15:26,709 --> 00:15:29,800
runtime because as we said we don't

00:15:28,240 --> 00:15:34,029
accept C be using it for privileged

00:15:29,800 --> 00:15:35,649
containers and 2019 actually started off

00:15:34,029 --> 00:15:41,319
with a pretty bad one I don't know who

00:15:35,649 --> 00:15:43,889
remembers CVE 2019 57 36 which was a

00:15:41,319 --> 00:15:46,000
bunch of things at the same time

00:15:43,889 --> 00:15:47,649
arbitrary code execution container

00:15:46,000 --> 00:15:50,139
breakout privilege escalation whatever

00:15:47,649 --> 00:15:52,740
you want it to be and one of the

00:15:50,139 --> 00:15:55,779
versions was essentially you tricked the

00:15:52,740 --> 00:15:57,459
runtime binary into executing itself it

00:15:55,779 --> 00:15:59,350
cached a file descriptor to that binary

00:15:57,459 --> 00:16:01,449
and then it overrode that binary so when

00:15:59,350 --> 00:16:04,750
you re executed and the container binary

00:16:01,449 --> 00:16:06,699
to next time well whatever the container

00:16:04,750 --> 00:16:08,589
wrote into that binary you now running

00:16:06,699 --> 00:16:11,079
and that could do anything you wanted it

00:16:08,589 --> 00:16:12,730
to be it was pretty bad and there is a

00:16:11,079 --> 00:16:16,629
pretty interesting pattern I think to

00:16:12,730 --> 00:16:18,189
this all of these attacks right here you

00:16:16,629 --> 00:16:19,569
should double check I'm claiming this

00:16:18,189 --> 00:16:21,339
right now and I looked at all of them

00:16:19,569 --> 00:16:23,559
but I'm not complex if I missed

00:16:21,339 --> 00:16:25,149
something I'm sorry but all of these TVs

00:16:23,559 --> 00:16:26,709
should not have been possible if you've

00:16:25,149 --> 00:16:30,519
used in privileged containers so if you

00:16:26,709 --> 00:16:32,259
used user name spaces CV 2019 57:36 not

00:16:30,519 --> 00:16:33,519
possible with unproduced containers and

00:16:32,259 --> 00:16:36,040
all of the other ones wouldn't have been

00:16:33,519 --> 00:16:39,069
possible to so this really matters and

00:16:36,040 --> 00:16:40,629
we can't as the found pointed out we

00:16:39,069 --> 00:16:42,100
can't really guarantee that there aren't

00:16:40,629 --> 00:16:44,920
any exploits out there against

00:16:42,100 --> 00:16:48,279
privileged containers I'm pretty sure

00:16:44,920 --> 00:16:50,079
that if young went to look at the P

00:16:48,279 --> 00:16:51,399
trace code close enough it would be

00:16:50,079 --> 00:16:54,130
pretty easy to find a bunch of other

00:16:51,399 --> 00:16:56,280
ones - actually there was a reason one

00:16:54,130 --> 00:16:59,100
right for P trace as well

00:16:56,280 --> 00:17:03,330
so there's a bunch of holes in there so

00:16:59,100 --> 00:17:04,410
privileged containers matter and we're

00:17:03,330 --> 00:17:08,160
in a state where you can actually use

00:17:04,410 --> 00:17:09,870
them for a lot of different stuff and so

00:17:08,160 --> 00:17:11,250
this is about making containers safer

00:17:09,870 --> 00:17:13,470
and one of the things that should be

00:17:11,250 --> 00:17:15,569
fairly trivial but is actually not as

00:17:13,470 --> 00:17:17,100
make use of all of the existing

00:17:15,569 --> 00:17:18,870
solutions that are out there which means

00:17:17,100 --> 00:17:20,870
all of the security features that we

00:17:18,870 --> 00:17:23,610
currently have you should use them and

00:17:20,870 --> 00:17:26,189
often when you look at when you look at

00:17:23,610 --> 00:17:28,560
security issues you see okay this is not

00:17:26,189 --> 00:17:30,150
really so much a problem of there is no

00:17:28,560 --> 00:17:33,120
mechanism that would block this it's

00:17:30,150 --> 00:17:35,640
it's a matter of it's a feature hasn't

00:17:33,120 --> 00:17:37,530
been used multiple reasons I don't know

00:17:35,640 --> 00:17:39,180
sometimes too complicated to understand

00:17:37,530 --> 00:17:41,970
not well enough documented that's

00:17:39,180 --> 00:17:43,920
obviously on if it's a kernel features

00:17:41,970 --> 00:17:48,330
on a some kernel develops we haven't

00:17:43,920 --> 00:17:51,650
documented it sufficiently but yeah you

00:17:48,330 --> 00:17:53,910
should one should definitely use them

00:17:51,650 --> 00:17:55,380
name space I'm not going to go through

00:17:53,910 --> 00:17:56,940
and explain to you what a container is

00:17:55,380 --> 00:17:59,820
I'm just going to give some general

00:17:56,940 --> 00:18:02,270
guidelines before diving into into new

00:17:59,820 --> 00:18:04,950
features that we've currently seen

00:18:02,270 --> 00:18:07,530
namespaces we have a bunch of them seven

00:18:04,950 --> 00:18:08,760
I think and too few namespaces are often

00:18:07,530 --> 00:18:10,710
used so if you look at the application

00:18:08,760 --> 00:18:13,500
container world out there if you look at

00:18:10,710 --> 00:18:15,510
especially HPC workloads out there it's

00:18:13,500 --> 00:18:17,490
often time people are like I just want

00:18:15,510 --> 00:18:19,440
to do a mount namespace and then still

00:18:17,490 --> 00:18:22,370
run untrusted workloads in there and

00:18:19,440 --> 00:18:24,810
that basically means you have problems

00:18:22,370 --> 00:18:26,670
it's trivial it's trivially to go into

00:18:24,810 --> 00:18:28,830
break out of this and all of the

00:18:26,670 --> 00:18:30,840
namespaces usually have some sort of

00:18:28,830 --> 00:18:32,370
security benefit network namespace I

00:18:30,840 --> 00:18:34,800
think I don't need to explain that user

00:18:32,370 --> 00:18:36,920
name space mount namespaces and so on it

00:18:34,800 --> 00:18:40,080
isolates the system in some sort of way

00:18:36,920 --> 00:18:41,970
the most obvious one is the user

00:18:40,080 --> 00:18:43,620
namespace this is something we keep

00:18:41,970 --> 00:18:46,080
coming back to as well because it's the

00:18:43,620 --> 00:18:48,240
only namespace that it's concerned with

00:18:46,080 --> 00:18:50,010
isolating privileges on a standard UNIX

00:18:48,240 --> 00:18:52,230
system so capabilities per user name

00:18:50,010 --> 00:18:55,440
space you use G IDs translations and so

00:18:52,230 --> 00:18:57,930
on and yeah for sure it's a clunky API

00:18:55,440 --> 00:19:01,200
there is nothing we can't have debates

00:18:57,930 --> 00:19:02,820
about that multiple people have pointed

00:19:01,200 --> 00:19:04,559
out we should probably make it nicer in

00:19:02,820 --> 00:19:07,730
some way it's just a matter of

00:19:04,559 --> 00:19:10,080
who does it and how how to make it nicer

00:19:07,730 --> 00:19:12,659
there is for example there are issues

00:19:10,080 --> 00:19:15,330
about how you create namespaces at

00:19:12,659 --> 00:19:17,880
container set up time I think there is

00:19:15,330 --> 00:19:20,130
an ordering issue with user namespaces

00:19:17,880 --> 00:19:21,720
and network namespaces if I remember

00:19:20,130 --> 00:19:24,270
correctly and this hasn't been fixed and

00:19:21,720 --> 00:19:26,159
you can create cloning new container

00:19:24,270 --> 00:19:27,809
process with specify specifying user

00:19:26,159 --> 00:19:29,760
namespace and network namespace at the

00:19:27,809 --> 00:19:32,010
same time because then all of your

00:19:29,760 --> 00:19:36,150
network I think your network devices are

00:19:32,010 --> 00:19:37,830
not owned by ul root you ad zro in your

00:19:36,150 --> 00:19:39,510
new user name space so you need to

00:19:37,830 --> 00:19:40,799
create a new user name space and then

00:19:39,510 --> 00:19:42,750
you need to unshare the network

00:19:40,799 --> 00:19:44,370
namespace and so on that's awfully is

00:19:42,750 --> 00:19:46,409
obviously stuff that probably should

00:19:44,370 --> 00:19:48,210
have should have been done by the kernel

00:19:46,409 --> 00:19:49,860
but it's I've been outsourced to user

00:19:48,210 --> 00:19:54,059
space so that's that's something people

00:19:49,860 --> 00:19:56,280
run into I have run into and also I

00:19:54,059 --> 00:19:58,260
think a big issue currently is you can't

00:19:56,280 --> 00:19:59,460
atomically set anis to all namespaces of

00:19:58,260 --> 00:20:03,330
a process so you have to do it

00:19:59,460 --> 00:20:05,280
iteratively each single namespace I have

00:20:03,330 --> 00:20:06,960
some ideas which I think I've proposed

00:20:05,280 --> 00:20:09,120
and the mailing list awhile back on how

00:20:06,960 --> 00:20:11,429
we can actually make this work now we

00:20:09,120 --> 00:20:16,429
have the infrastructure to actually do

00:20:11,429 --> 00:20:20,940
this but yeah use all of the namespaces

00:20:16,429 --> 00:20:24,720
obviously the two big topics are second

00:20:20,940 --> 00:20:27,570
and LSMs seccomp is essential for

00:20:24,720 --> 00:20:29,429
privileged containers obviously because

00:20:27,570 --> 00:20:31,919
you can trivially break out of a

00:20:29,429 --> 00:20:34,230
container if you allow any syscalls

00:20:31,919 --> 00:20:37,440
if you allow a certain class of syscalls

00:20:34,230 --> 00:20:39,330
open by handle that for example is

00:20:37,440 --> 00:20:41,730
pretty good it allows you to traverse

00:20:39,330 --> 00:20:47,880
back to house prude if it's on the same

00:20:41,730 --> 00:20:49,799
device right it was a cv in 2014 well no

00:20:47,880 --> 00:20:52,919
actually was the CVE against openvz

00:20:49,799 --> 00:20:53,360
right so it's pretty pretty old yeah it

00:20:52,919 --> 00:20:56,429
was

00:20:53,360 --> 00:20:59,070
there was a CV oven against openvz

00:20:56,429 --> 00:21:03,059
for that particular attack and that was

00:20:59,070 --> 00:21:03,720
then also affecting dock that was the

00:21:03,059 --> 00:21:06,780
shocker

00:21:03,720 --> 00:21:09,419
exploit one gravity at the time which

00:21:06,780 --> 00:21:11,760
yeah if you were not on a dedicated

00:21:09,419 --> 00:21:14,190
mount for the container you could

00:21:11,760 --> 00:21:16,950
traverse back to the host and then put

00:21:14,190 --> 00:21:18,029
in like if your parent was slashed

00:21:16,950 --> 00:21:19,889
and you couldn't go in

00:21:18,029 --> 00:21:21,389
five in C password it C shadow or

00:21:19,889 --> 00:21:23,789
whatever you want because we all stay

00:21:21,389 --> 00:21:25,349
true it's pretty bad right

00:21:23,789 --> 00:21:26,759
don't just going to gloss over this so

00:21:25,349 --> 00:21:28,950
for privilege containers it's pretty

00:21:26,759 --> 00:21:31,889
essential you probably need to maintain

00:21:28,950 --> 00:21:33,450
a whitelist and not a blacklist there is

00:21:31,889 --> 00:21:35,429
not a it's not a lot a whole lot of

00:21:33,450 --> 00:21:37,320
sisqual there's a bunch of syscall stay

00:21:35,429 --> 00:21:38,969
there for the safe but you probably want

00:21:37,320 --> 00:21:40,499
to block more than you want to allow for

00:21:38,969 --> 00:21:42,419
around privileged containers usually you

00:21:40,499 --> 00:21:45,479
get a get along with the with a

00:21:42,419 --> 00:21:47,039
blacklist we still use it in our

00:21:45,479 --> 00:21:48,539
privilege containers because it's nice

00:21:47,039 --> 00:21:51,179
for sis called blocking obviously for

00:21:48,539 --> 00:21:53,969
legacy Siskel's locking what sis calls

00:21:51,179 --> 00:21:55,200
as container has been performed or it's

00:21:53,969 --> 00:21:57,479
a new feature I'm going to be talking

00:21:55,200 --> 00:21:59,609
about in a little bit this is called

00:21:57,479 --> 00:22:01,440
interception stuff or to deal with

00:21:59,609 --> 00:22:04,469
broken user space it's pretty nifty

00:22:01,440 --> 00:22:07,139
actually going to come back to second in

00:22:04,469 --> 00:22:08,789
a bit and obviously yell SMS I don't

00:22:07,139 --> 00:22:10,679
need to talk about LSM school a lot I

00:22:08,789 --> 00:22:13,549
think the Linux security summit there's

00:22:10,679 --> 00:22:15,659
going to be an update as well I think

00:22:13,549 --> 00:22:18,659
essential again for on privilege for

00:22:15,659 --> 00:22:20,399
privileged containers there's a lot of

00:22:18,659 --> 00:22:22,769
files in progress and sisyphus that you

00:22:20,399 --> 00:22:25,649
definitely don't want even a privileged

00:22:22,769 --> 00:22:27,179
container to be able to read and they

00:22:25,649 --> 00:22:29,159
are all plug blocked and on privileged

00:22:27,179 --> 00:22:32,549
containers so by virtue of user name

00:22:29,159 --> 00:22:36,599
spaces so you need LS aims to block

00:22:32,549 --> 00:22:39,089
access to a bunch of files and to use of

00:22:36,599 --> 00:22:39,570
course Linux around a bunch more load

00:22:39,089 --> 00:22:43,320
bin

00:22:39,570 --> 00:22:44,700
Tommy is Mac a new safe set ID which I'm

00:22:43,320 --> 00:22:48,509
going to mention in a little in a little

00:22:44,700 --> 00:22:49,589
bit we use them in or one can use them

00:22:48,509 --> 00:22:52,019
in on privileged containers as well

00:22:49,589 --> 00:22:55,830
because more security but there's

00:22:52,019 --> 00:22:57,779
actually no real need I think yeah so

00:22:55,830 --> 00:23:00,149
let's talk about a couple of new

00:22:57,779 --> 00:23:02,729
features that landed recently and stuff

00:23:00,149 --> 00:23:05,489
that is planned that makes containers

00:23:02,729 --> 00:23:08,869
hopefully a little safer yeah

00:23:05,489 --> 00:23:12,599
so one of the bigger things is secum

00:23:08,869 --> 00:23:14,669
notify target or outsourcing decisions

00:23:12,599 --> 00:23:16,529
of what Cisco syscalls are going to be

00:23:14,669 --> 00:23:18,509
successful or not to user space that's a

00:23:16,529 --> 00:23:19,830
pretty big deal I don't know how many

00:23:18,509 --> 00:23:23,429
people have heard of this it's been

00:23:19,830 --> 00:23:24,640
landed in 5.0 yeah okay

00:23:23,429 --> 00:23:29,530
bunch of people hoarders

00:23:24,640 --> 00:23:31,390
okay so have you heard of him so it the

00:23:29,530 --> 00:23:32,710
nice thing is it allows the running

00:23:31,390 --> 00:23:34,270
privilege containers unprivileged

00:23:32,710 --> 00:23:35,620
containers with even less privileges

00:23:34,270 --> 00:23:38,559
it's also pretty helpful for privileged

00:23:35,620 --> 00:23:41,830
containers to be honest you can grant

00:23:38,559 --> 00:23:44,110
very fine-grained privileges and what

00:23:41,830 --> 00:23:48,130
you do or what does feature accentual e

00:23:44,110 --> 00:23:49,809
is is if a task loads a second filter it

00:23:48,130 --> 00:23:53,320
can get a file descriptor to that second

00:23:49,809 --> 00:23:55,030
filter and then it can send that file

00:23:53,320 --> 00:23:57,190
descriptor to a more privileged other

00:23:55,030 --> 00:24:01,210
like different users process users based

00:23:57,190 --> 00:24:04,240
process recently usually and that file

00:24:01,210 --> 00:24:05,710
descriptor is portable so you get an

00:24:04,240 --> 00:24:07,840
event when it's is called a relevant

00:24:05,710 --> 00:24:11,710
Cisco which you have registered in your

00:24:07,840 --> 00:24:14,530
second filter and then you can read the

00:24:11,710 --> 00:24:18,520
actual syscall arguments well you know

00:24:14,530 --> 00:24:20,290
the integer arguments and then the

00:24:18,520 --> 00:24:21,910
privileged users based process can

00:24:20,290 --> 00:24:24,549
inspect these arguments it can also

00:24:21,910 --> 00:24:25,900
inspect in a race free way I'm not going

00:24:24,549 --> 00:24:29,470
to go into details how this is possible

00:24:25,900 --> 00:24:33,220
the memory of that syscall so you can

00:24:29,470 --> 00:24:34,470
also do the work of parsing out parsing

00:24:33,220 --> 00:24:38,440
out paths and so on

00:24:34,470 --> 00:24:40,960
and then if it decides it's okay this is

00:24:38,440 --> 00:24:43,450
call is safe to make perform that

00:24:40,960 --> 00:24:45,040
syscall in lieu of the container meaning

00:24:43,450 --> 00:24:47,320
it does all of the work that usually the

00:24:45,040 --> 00:24:49,299
kernel would do which sounds really nice

00:24:47,320 --> 00:24:51,250
but it's also problematic because it

00:24:49,299 --> 00:24:54,640
means you need to make sure that you

00:24:51,250 --> 00:24:56,440
assume sufficient like a sufficient

00:24:54,640 --> 00:24:58,350
amount of credentials of the tasks

00:24:56,440 --> 00:25:01,360
you're performing the cisco Linley of

00:24:58,350 --> 00:25:04,929
while at the same time not assuming the

00:25:01,360 --> 00:25:07,840
ones that block you from doing so that's

00:25:04,929 --> 00:25:10,540
that's pretty annoying to be honest and

00:25:07,840 --> 00:25:14,890
but we think there might be a solution

00:25:10,540 --> 00:25:17,200
to this better we use it for example to

00:25:14,890 --> 00:25:19,540
intercept make not so def console

00:25:17,200 --> 00:25:22,150
definite f0 dev random def you random

00:25:19,540 --> 00:25:23,799
are usually devices that you find with

00:25:22,150 --> 00:25:25,299
delegating to unprivileged containers as

00:25:23,799 --> 00:25:27,160
well and container managers right now

00:25:25,299 --> 00:25:28,780
just bind mount them from the host but

00:25:27,160 --> 00:25:31,270
there is no reason to actually do this

00:25:28,780 --> 00:25:33,340
but I get why the kernel doesn't want to

00:25:31,270 --> 00:25:36,290
maintain a list of devices that are safe

00:25:33,340 --> 00:25:39,590
to create so you can register

00:25:36,290 --> 00:25:41,600
a second filter that specifies okay if

00:25:39,590 --> 00:25:43,730
if it's a magnet it's called for these

00:25:41,600 --> 00:25:46,820
devices identified by the device number

00:25:43,730 --> 00:25:48,770
please send me a notification then you

00:25:46,820 --> 00:25:50,360
have a privileged user space process a

00:25:48,770 --> 00:25:51,350
container manager in this case like

00:25:50,360 --> 00:25:54,920
Steve for example

00:25:51,350 --> 00:25:57,290
it reads reads the Cisco arguments looks

00:25:54,920 --> 00:25:59,840
at it looks at the Cisco a device number

00:25:57,290 --> 00:26:01,490
and finds out okay this is definitely a

00:25:59,840 --> 00:26:03,320
whatever I'm going to create the device

00:26:01,490 --> 00:26:06,110
now for you then assumes the credentials

00:26:03,320 --> 00:26:08,630
of the process is doing the SIS call in

00:26:06,110 --> 00:26:09,890
the earth is doing the magg node for it

00:26:08,630 --> 00:26:11,930
and you're done

00:26:09,890 --> 00:26:14,060
so this is obviously a pretty powerful

00:26:11,930 --> 00:26:15,740
mechanism you could intercept mound you

00:26:14,060 --> 00:26:17,930
could intercept what whatever you want

00:26:15,740 --> 00:26:19,490
you just need to be very very careful

00:26:17,930 --> 00:26:20,840
that you obviously that you're doing it

00:26:19,490 --> 00:26:25,070
right and that you don't create devices

00:26:20,840 --> 00:26:30,440
that you don't want to create but yeah

00:26:25,070 --> 00:26:34,130
that's a pretty nifty feature so one of

00:26:30,440 --> 00:26:35,810
the things obviously is so for make not

00:26:34,130 --> 00:26:37,850
it's not an issue if that's say for

00:26:35,810 --> 00:26:40,030
example I register filter and I say give

00:26:37,850 --> 00:26:42,380
me all make not six calls

00:26:40,030 --> 00:26:45,370
indiscriminately right and I intercept a

00:26:42,380 --> 00:26:49,490
bunch of mcnaught sis calls that match

00:26:45,370 --> 00:26:50,960
devices that I did I would want to allow

00:26:49,490 --> 00:26:53,990
and a bunch of that those that I

00:26:50,960 --> 00:26:55,160
wouldn't want to allow if I intercept

00:26:53,990 --> 00:26:56,690
all of them it doesn't really matter

00:26:55,160 --> 00:26:59,630
because making out a user name space

00:26:56,690 --> 00:27:01,370
spaces it's not it's not possible to

00:26:59,630 --> 00:27:03,230
talk away low so there I mean there is

00:27:01,370 --> 00:27:06,410
no device that you can create in a user

00:27:03,230 --> 00:27:10,130
name space so if you hit a bunch of

00:27:06,410 --> 00:27:13,190
Cisco's that would otherwise exceed five

00:27:10,130 --> 00:27:15,140
oh yeah you've got some well yeah okay

00:27:13,190 --> 00:27:18,020
any interesting character devices and

00:27:15,140 --> 00:27:19,220
block deep right actually hundred a few

00:27:18,020 --> 00:27:20,930
at the beginning the next day we were

00:27:19,220 --> 00:27:23,330
intercepting all of the make notes calls

00:27:20,930 --> 00:27:25,070
and that was causing problems with

00:27:23,330 --> 00:27:29,090
things that were not character or blog

00:27:25,070 --> 00:27:31,570
devices exactly so but if you if you

00:27:29,090 --> 00:27:34,790
want to intercept a difference is calls

00:27:31,570 --> 00:27:37,370
that would partially succeed in in

00:27:34,790 --> 00:27:39,860
unprivileged containers for some

00:27:37,370 --> 00:27:41,570
arguments but not for others then you

00:27:39,860 --> 00:27:43,520
obviously have a problem because right

00:27:41,570 --> 00:27:47,480
now you might intercept the ones that

00:27:43,520 --> 00:27:49,380
you could that you can do in layer of

00:27:47,480 --> 00:27:51,240
the container would otherwise fail

00:27:49,380 --> 00:27:53,130
but all of the other ones that would

00:27:51,240 --> 00:27:54,600
usually succeed you now we need to do

00:27:53,130 --> 00:27:56,400
them as well which is again pretty

00:27:54,600 --> 00:27:58,620
tricky insofar as assuming the right

00:27:56,400 --> 00:28:01,650
credentials and so on so what would be

00:27:58,620 --> 00:28:04,380
pretty nice if we could somehow tell

00:28:01,650 --> 00:28:05,730
succumb to resume a given Cisco like for

00:28:04,380 --> 00:28:07,470
example you intercept a source call you

00:28:05,730 --> 00:28:09,210
to spec do you inspect the arguments and

00:28:07,470 --> 00:28:11,340
you as a user space process especially

00:28:09,210 --> 00:28:13,170
if you manage your container or another

00:28:11,340 --> 00:28:16,440
process you usually will know when a

00:28:13,170 --> 00:28:18,000
Cisco will succeed you can tell and then

00:28:16,440 --> 00:28:21,570
you're like oh please Colonel go ahead

00:28:18,000 --> 00:28:24,030
with the Cisco and yeah would be pretty

00:28:21,570 --> 00:28:25,650
good if we if we had this I think I sent

00:28:24,030 --> 00:28:28,680
the mail to the case I'm a discus

00:28:25,650 --> 00:28:30,090
mailing list to slightly not case no but

00:28:28,680 --> 00:28:32,640
yeah it's a it's a discussion to be had

00:28:30,090 --> 00:28:35,130
because it's not easy it's not trivial

00:28:32,640 --> 00:28:39,300
to do I think but yeah that's something

00:28:35,130 --> 00:28:40,800
we would really want exactly the point

00:28:39,300 --> 00:28:42,030
no raise privileges I think the most

00:28:40,800 --> 00:28:43,380
important one the execution just

00:28:42,030 --> 00:28:44,850
continues with the privileges of the

00:28:43,380 --> 00:28:46,320
original tasks you don't need to mark

00:28:44,850 --> 00:28:49,260
them with any permissions and so on it

00:28:46,320 --> 00:28:51,440
would pretty be pretty helpful and

00:28:49,260 --> 00:28:54,150
another one is extended Cisco filtering

00:28:51,440 --> 00:28:56,370
that discussion has been popped up quite

00:28:54,150 --> 00:28:58,350
a bit over recent times I think now it's

00:28:56,370 --> 00:29:03,300
even made it into a BPF thread that is

00:28:58,350 --> 00:29:07,260
currently not so we have a bunch of sis

00:29:03,300 --> 00:29:09,720
calls that carry flag arguments and

00:29:07,260 --> 00:29:11,280
these flag arguments are usually passed

00:29:09,720 --> 00:29:13,320
in registers so they're readily

00:29:11,280 --> 00:29:16,050
available and not as pointers they're

00:29:13,320 --> 00:29:18,180
readily available for second two to

00:29:16,050 --> 00:29:21,840
filter them pretty neat traditional

00:29:18,180 --> 00:29:25,040
clone sis calls and so on but at the

00:29:21,840 --> 00:29:29,220
same time we have a bunch that don't and

00:29:25,040 --> 00:29:32,430
we have new sis calls that maybe don't

00:29:29,220 --> 00:29:35,190
want to pass flag arguments as registers

00:29:32,430 --> 00:29:37,710
or in registers but as part of pointer

00:29:35,190 --> 00:29:40,230
arguments such as structs the recent sis

00:29:37,710 --> 00:29:42,180
call that we added was the clone 3 sis

00:29:40,230 --> 00:29:45,300
call the Flex argument has moved into a

00:29:42,180 --> 00:29:47,540
dedicated argument struct and we still

00:29:45,300 --> 00:29:52,410
would like second to be able to filter

00:29:47,540 --> 00:29:55,200
these arguments and educate its

00:29:52,410 --> 00:29:58,080
discussion around this and alito miski

00:29:55,200 --> 00:30:00,340
has made a proposal I think on you can

00:29:58,080 --> 00:30:02,630
follow this mailing list threat

00:30:00,340 --> 00:30:04,760
has made a proposal on how to do this

00:30:02,630 --> 00:30:06,620
without eb PF or without bringing

00:30:04,760 --> 00:30:07,970
unprivileged EPF into the game and i

00:30:06,620 --> 00:30:10,730
think the common understanding is that

00:30:07,970 --> 00:30:12,770
we don't really want that to happen and

00:30:10,730 --> 00:30:15,800
privilege vp a UPF because of this

00:30:12,770 --> 00:30:18,260
feature but yeah it's going to be also I

00:30:15,800 --> 00:30:20,060
think pretty technical a pretty

00:30:18,260 --> 00:30:23,870
difficult technical challenge to come

00:30:20,060 --> 00:30:31,160
around but it would be pretty neat if we

00:30:23,870 --> 00:30:32,660
had this okay I probably don't need to

00:30:31,160 --> 00:30:33,950
say a lot about this right

00:30:32,660 --> 00:30:40,100
unless I'm stacking is going to be an

00:30:33,950 --> 00:30:41,870
update on Wednesday yeah okay and what

00:30:40,100 --> 00:30:44,420
we would like to do is if you have a

00:30:41,870 --> 00:30:46,250
fedora host that runs sa Linux and as a

00:30:44,420 --> 00:30:48,080
links policy you run a container with a

00:30:46,250 --> 00:30:49,850
gun - that uses app armour none of the

00:30:48,080 --> 00:30:52,040
app AMA policies that usually confine

00:30:49,850 --> 00:30:53,420
apps on the pond - would now be usable

00:30:52,040 --> 00:30:58,610
because you currently cannot stack

00:30:53,420 --> 00:31:02,600
unless I'm wrong I'm Annessa Linux or

00:30:58,610 --> 00:31:04,730
SAS Linux on a bomber and you currently

00:31:02,600 --> 00:31:06,680
can stack miner LSMs with major LSM so

00:31:04,730 --> 00:31:08,000
Tomeo load pin a primer and SL the next

00:31:06,680 --> 00:31:10,340
this has been work work that has been

00:31:08,000 --> 00:31:13,460
done recently but the ultimate goal I

00:31:10,340 --> 00:31:15,890
think is still to stack LSMs on top of

00:31:13,460 --> 00:31:20,390
each other there would be really neat

00:31:15,890 --> 00:31:23,270
wouldn't block a lot of use cases the

00:31:20,390 --> 00:31:24,830
safest area is safe said idea a Linux

00:31:23,270 --> 00:31:26,690
security module that I recently stumbled

00:31:24,830 --> 00:31:29,420
upon it has been merged or is going to

00:31:26,690 --> 00:31:32,030
show up in 5.3 which comes from the

00:31:29,420 --> 00:31:35,120
Chrome OS guys which restricts IT

00:31:32,030 --> 00:31:39,140
translation transitions through IDs this

00:31:35,120 --> 00:31:41,030
calls given a system-wide policy which

00:31:39,140 --> 00:31:44,060
will probably be mostly useful for

00:31:41,030 --> 00:31:45,680
privileged containers because you can

00:31:44,060 --> 00:31:48,260
limit a container to a limited range of

00:31:45,680 --> 00:31:50,870
you Eddie's and G IDs so it's going to

00:31:48,260 --> 00:31:52,550
be pretty helpful for that we I don't

00:31:50,870 --> 00:31:56,270
think we have a particular use case in

00:31:52,550 --> 00:31:58,610
mind right now for us and the mount API

00:31:56,270 --> 00:32:02,740
this has been mentioned before David and

00:31:58,610 --> 00:32:05,270
L have been working on this quite a bit

00:32:02,740 --> 00:32:07,850
idea is a use file descriptors for

00:32:05,270 --> 00:32:10,640
mounting for configuring setting up

00:32:07,850 --> 00:32:13,070
mounts and so on split once is called

00:32:10,640 --> 00:32:13,770
that is heavily overloaded with multiple

00:32:13,070 --> 00:32:15,360
tasks that

00:32:13,770 --> 00:32:16,890
same time into a bunch of Cisco's I

00:32:15,360 --> 00:32:21,090
think we have seven right now but we

00:32:16,890 --> 00:32:22,530
need a drone now eight or nine and it's

00:32:21,090 --> 00:32:24,990
gone on going to hopefully have a bunch

00:32:22,530 --> 00:32:27,810
of nice features such as a recursively

00:32:24,990 --> 00:32:30,300
applying mount options to a whole mount

00:32:27,810 --> 00:32:32,190
three at least David is working on this

00:32:30,300 --> 00:32:34,440
it has anonymous mounds which is a

00:32:32,190 --> 00:32:36,540
feature I've been wanting to have wanted

00:32:34,440 --> 00:32:38,130
for a long time which means you can

00:32:36,540 --> 00:32:39,630
access an amount that you have

00:32:38,130 --> 00:32:41,570
configured and set up but it is not

00:32:39,630 --> 00:32:44,660
attached to any path in the file system

00:32:41,570 --> 00:32:48,390
but you can still access files and so on

00:32:44,660 --> 00:32:51,420
and it avoids numerous race conditions

00:32:48,390 --> 00:32:53,610
as well you have been thinking about a

00:32:51,420 --> 00:32:56,250
good example before right it was the

00:32:53,610 --> 00:32:58,860
usual place first conditions we've got

00:32:56,250 --> 00:33:00,830
during attach so if you want to spawn

00:32:58,860 --> 00:33:03,570
the process inside the running container

00:33:00,830 --> 00:33:05,730
you will need to pull some information

00:33:03,570 --> 00:33:08,130
from it and you might have some like you

00:33:05,730 --> 00:33:11,610
might need access to proc to rewrite

00:33:08,130 --> 00:33:13,950
your LS m labor or to do some other

00:33:11,610 --> 00:33:15,870
operations but you can't trust proc

00:33:13,950 --> 00:33:18,750
inside of the math namespace of the

00:33:15,870 --> 00:33:20,190
container because the route in the

00:33:18,750 --> 00:33:25,170
container might have mounted like a temp

00:33:20,190 --> 00:33:28,140
of s and then pretended a few spy system

00:33:25,170 --> 00:33:29,310
that pretends enough of proc that you

00:33:28,140 --> 00:33:30,780
think everything you think you're

00:33:29,310 --> 00:33:32,400
actually writing and assembly about when

00:33:30,780 --> 00:33:35,850
you're not there was the cpu for this as

00:33:32,400 --> 00:33:38,520
well yeah issues are not fond of

00:33:35,850 --> 00:33:42,810
container managers the way we do it

00:33:38,520 --> 00:33:45,600
right now is we use DF days so we we

00:33:42,810 --> 00:33:46,980
open proc as a ofd on the hosts then we

00:33:45,600 --> 00:33:49,170
do the attachment then we do everything

00:33:46,980 --> 00:33:52,890
relative to that the FD and that kind of

00:33:49,170 --> 00:33:54,810
works but it's a bit of a pain and being

00:33:52,890 --> 00:33:57,000
able to just hold FD on two particular

00:33:54,810 --> 00:33:59,190
mounts is gonna make some of that much

00:33:57,000 --> 00:34:01,410
you know an easier thought one of the

00:33:59,190 --> 00:34:05,040
things that David has told me he's going

00:34:01,410 --> 00:34:07,770
to work on which I find pretty it's a

00:34:05,040 --> 00:34:10,230
pretty good idea is being able to set up

00:34:07,770 --> 00:34:14,070
the ID shifting missus basically shift

00:34:10,230 --> 00:34:16,080
FS which you mentioned before there are

00:34:14,070 --> 00:34:17,880
some discussion going on whether it's

00:34:16,080 --> 00:34:19,770
supposed to be tied to a user namespace

00:34:17,880 --> 00:34:21,870
or it's going to be not tied to be user

00:34:19,770 --> 00:34:25,620
name space but it would be pretty neat

00:34:21,870 --> 00:34:27,740
if you could say map these IDs for this

00:34:25,620 --> 00:34:29,600
in this mount and also to set the name

00:34:27,740 --> 00:34:31,340
spaces of a mound which is a feature

00:34:29,600 --> 00:34:34,250
that is lacking in the current API

00:34:31,340 --> 00:34:36,230
currently so - like often we inject the

00:34:34,250 --> 00:34:37,550
mounds into a container across mountain

00:34:36,230 --> 00:34:39,139
aim spaces and there is a whole lot of

00:34:37,550 --> 00:34:40,940
trickery involved to get this actually

00:34:39,139 --> 00:34:44,869
done you can't just find mounted

00:34:40,940 --> 00:34:46,760
somewhere because of namespaces work so

00:34:44,869 --> 00:34:49,070
if you could say given the right

00:34:46,760 --> 00:34:52,669
privileges inject this mount into this

00:34:49,070 --> 00:34:54,860
container basically say these namespaces

00:34:52,669 --> 00:34:57,410
that would be pretty neat if that would

00:34:54,860 --> 00:34:59,750
work out and one piece of work I should

00:34:57,410 --> 00:35:01,190
mention and I didn't put on a slide his

00:34:59,750 --> 00:35:04,190
works been done by a good friend of mine

00:35:01,190 --> 00:35:08,630
Alexa he's working on restricting path

00:35:04,190 --> 00:35:12,920
resolution on on Linux by proposing a

00:35:08,630 --> 00:35:14,930
new syscall open at - that's would be

00:35:12,920 --> 00:35:17,810
pretty neat the idea being that you

00:35:14,930 --> 00:35:22,090
attach a set of set of permissions to a

00:35:17,810 --> 00:35:24,680
file descriptor that you can then later

00:35:22,090 --> 00:35:26,330
escalate to more privileges like what

00:35:24,680 --> 00:35:28,250
you can do right now is you can open a

00:35:26,330 --> 00:35:30,530
file descriptor as read-only and then

00:35:28,250 --> 00:35:34,190
through proc and open and trickery

00:35:30,530 --> 00:35:36,859
reopen it as read write and this API

00:35:34,190 --> 00:35:38,900
would block you from doing this also you

00:35:36,859 --> 00:35:40,670
could do nice features such as if you

00:35:38,900 --> 00:35:42,530
have a file descriptor and if you have a

00:35:40,670 --> 00:35:46,160
dear file descriptor to a root directory

00:35:42,530 --> 00:35:48,020
of a container you can never walk out of

00:35:46,160 --> 00:35:49,310
the container it's always going to

00:35:48,020 --> 00:35:51,980
resolution is always going to be

00:35:49,310 --> 00:35:54,680
relative to this dfd it forms the new

00:35:51,980 --> 00:35:58,210
route essentially of your system that's

00:35:54,680 --> 00:36:01,340
pretty exciting work it's blocked on

00:35:58,210 --> 00:36:04,430
it's blocked on L let's put it like this

00:36:01,340 --> 00:36:06,350
and and yeah hopefully this is going to

00:36:04,430 --> 00:36:08,510
be landing it's going to land at some

00:36:06,350 --> 00:36:11,450
point soon in the future - will be a big

00:36:08,510 --> 00:36:13,640
security improvement as well one thing

00:36:11,450 --> 00:36:16,760
we've also been working on and I'm going

00:36:13,640 --> 00:36:17,330
to close with this not the keyring stuff

00:36:16,760 --> 00:36:19,310
I think

00:36:17,330 --> 00:36:21,470
well keyring namespacing that's what

00:36:19,310 --> 00:36:23,359
David's been working on as well

00:36:21,470 --> 00:36:24,740
ultimate goal being to have keyrings be

00:36:23,359 --> 00:36:27,200
able to use the non privileged

00:36:24,740 --> 00:36:29,210
containers so the network file systems

00:36:27,200 --> 00:36:30,800
can authenticate against the server with

00:36:29,210 --> 00:36:32,540
their own individual key and so on a

00:36:30,800 --> 00:36:35,270
bunch of that infrastructure has landed

00:36:32,540 --> 00:36:37,510
in 5.3 I'm not sure if it's completely

00:36:35,270 --> 00:36:39,760
usable at this point in time

00:36:37,510 --> 00:36:41,980
but the ultimate ultimate goal is is to

00:36:39,760 --> 00:36:44,770
get it working by the way this was also

00:36:41,980 --> 00:36:47,260
his reason for proposing containers as

00:36:44,770 --> 00:36:50,980
kernel objects at one point apparently

00:36:47,260 --> 00:36:53,770
he has abandoned this this idea and the

00:36:50,980 --> 00:36:55,660
last part is which we've used for our

00:36:53,770 --> 00:36:57,550
container manager are using for our

00:36:55,660 --> 00:36:59,380
container manager it's using file

00:36:57,550 --> 00:37:01,030
descriptors for processes to eliminate a

00:36:59,380 --> 00:37:03,660
bunch of races that have existed on

00:37:01,030 --> 00:37:08,190
Linux for quite a long time it's been

00:37:03,660 --> 00:37:10,359
some work going on in this direction so

00:37:08,190 --> 00:37:12,070
right now you can get a new file

00:37:10,359 --> 00:37:15,460
descriptor from clone with clone per FTE

00:37:12,070 --> 00:37:17,020
or from clone 3 with that flag said you

00:37:15,460 --> 00:37:20,290
can send signals through pet if you send

00:37:17,020 --> 00:37:22,359
signals to those file descriptors you

00:37:20,290 --> 00:37:24,460
can get an 50 for an existing process

00:37:22,359 --> 00:37:26,920
with pit of the open you can also pole

00:37:24,460 --> 00:37:29,310
to get an exit notifications for non

00:37:26,920 --> 00:37:32,109
child processes which is pretty handy

00:37:29,310 --> 00:37:35,680
that obviously if for us it because we

00:37:32,109 --> 00:37:38,710
have spawn sub demons right yeah we

00:37:35,680 --> 00:37:41,619
spawn sub demons and they usually have

00:37:38,710 --> 00:37:43,240
pit files and then we parse out the pair

00:37:41,619 --> 00:37:45,280
of the pit file and then we send a

00:37:43,240 --> 00:37:48,010
signal to that process and so on it's

00:37:45,280 --> 00:37:50,140
it's all racy obviously if that process

00:37:48,010 --> 00:37:52,270
exits and gets respond with a different

00:37:50,140 --> 00:37:53,920
pit but the pits in the pit file is

00:37:52,270 --> 00:37:55,780
reused and you have obviously going to

00:37:53,920 --> 00:37:58,180
have a problem and so on so this

00:37:55,780 --> 00:38:01,450
hopefully eliminates a bunch of those a

00:37:58,180 --> 00:38:03,850
bunch of those problems and there's more

00:38:01,450 --> 00:38:07,180
more features I have planned we have

00:38:03,850 --> 00:38:08,650
planned around this API and yeah that's

00:38:07,180 --> 00:38:11,980
it for me I think you want to do some

00:38:08,650 --> 00:38:16,000
closing words - fun yeah

00:38:11,980 --> 00:38:18,040
despite the name of the talk make it a

00:38:16,000 --> 00:38:20,200
lot safer like there's no there's no one

00:38:18,040 --> 00:38:23,040
way of just making it happen it

00:38:20,200 --> 00:38:25,690
definitely depends on what you're doing

00:38:23,040 --> 00:38:27,900
what I would say is like try to not

00:38:25,690 --> 00:38:29,950
reinvent the wheel there are number of

00:38:27,900 --> 00:38:32,200
container managers out there that have

00:38:29,950 --> 00:38:33,760
gone through the pain of all of those

00:38:32,200 --> 00:38:37,170
issues and I've figured out ways of

00:38:33,760 --> 00:38:40,090
doing it if you can you can even use

00:38:37,170 --> 00:38:41,590
Alexia's a libraries you're labelled XE

00:38:40,090 --> 00:38:44,700
to try and do some of that stuff for you

00:38:41,590 --> 00:38:47,890
so you don't risk hitting some of those

00:38:44,700 --> 00:38:49,480
annoying cannot issues the one

00:38:47,890 --> 00:38:50,650
recommendation obviously and I think

00:38:49,480 --> 00:38:52,570
we've said it not

00:38:50,650 --> 00:38:54,850
time saying this talk is like do not use

00:38:52,570 --> 00:38:56,290
privilege containers like if you're not

00:38:54,850 --> 00:38:59,200
using the username space you just can't

00:38:56,290 --> 00:39:03,090
make things safe it's just people should

00:38:59,200 --> 00:39:05,830
really get get to understand that and

00:39:03,090 --> 00:39:08,980
move as far away as possible from any

00:39:05,830 --> 00:39:10,180
kind of previous containers because

00:39:08,980 --> 00:39:12,190
these security issues will keep

00:39:10,180 --> 00:39:14,470
happening that guess there's really no

00:39:12,190 --> 00:39:17,350
way around it it's not something that

00:39:14,470 --> 00:39:20,190
will ever make safe and there's really

00:39:17,350 --> 00:39:20,190
no reason for that either

00:39:20,220 --> 00:39:24,400
so yeah that's it for us I think what

00:39:22,810 --> 00:39:26,110
kind of out of time so not sure we can

00:39:24,400 --> 00:39:29,860
really do questions at this stage we'll

00:39:26,110 --> 00:39:31,270
see okay otherwise we also have a bunch

00:39:29,860 --> 00:39:32,970
of stickers in front if people want to

00:39:31,270 --> 00:39:49,000
come and get some of those afterwards

00:39:32,970 --> 00:39:51,970
it's their questions the question is on

00:39:49,000 --> 00:39:53,830
the this 95 feature of SAP comp write

00:39:51,970 --> 00:39:56,320
that you're producing how deep can you

00:39:53,830 --> 00:39:57,940
go suppose you have an inode in the

00:39:56,320 --> 00:40:00,370
system call can you enumerate all the

00:39:57,940 --> 00:40:01,690
passes for that I note can you I don't

00:40:00,370 --> 00:40:04,870
know go to the superblock

00:40:01,690 --> 00:40:06,550
get the device underneath figure out

00:40:04,870 --> 00:40:13,000
whether that device is removable how

00:40:06,550 --> 00:40:15,090
flexible that user analysis of the

00:40:13,000 --> 00:40:19,090
system would be it is pretty limited

00:40:15,090 --> 00:40:21,130
understand so what you get is you you

00:40:19,090 --> 00:40:23,950
know what the task ID is and you've got

00:40:21,130 --> 00:40:25,930
the pointers to the arguments and that's

00:40:23,950 --> 00:40:27,550
all you get from user space after that

00:40:25,930 --> 00:40:30,490
normally what will do is will

00:40:27,550 --> 00:40:32,410
effectively end the spread itself is

00:40:30,490 --> 00:40:35,320
temporally frozen by the kernel well

00:40:32,410 --> 00:40:37,360
your processing so user space can go and

00:40:35,320 --> 00:40:40,120
like duplicate the memory or some of the

00:40:37,360 --> 00:40:43,180
other properties the kind of the process

00:40:40,120 --> 00:40:45,310
to try to analyze and you can you can

00:40:43,180 --> 00:40:47,350
read the pointer arguments by going

00:40:45,310 --> 00:40:49,450
through proc paid men I think and then

00:40:47,350 --> 00:40:51,190
also you have you can check there is a

00:40:49,450 --> 00:40:53,230
cookie that comes with each sis call

00:40:51,190 --> 00:40:56,560
that is made and then you can use that

00:40:53,230 --> 00:40:58,300
cookie and check whether it's still

00:40:56,560 --> 00:41:01,730
valid like this is the task is still

00:40:58,300 --> 00:41:04,980
alive and it's do not operating on

00:41:01,730 --> 00:41:07,020
yeah exactly and so you read the memory

00:41:04,980 --> 00:41:08,940
you can do all of the analyst and

00:41:07,020 --> 00:41:11,250
analysis that you want but it's pretty

00:41:08,940 --> 00:41:12,150
it's pretty annoying obviously because

00:41:11,250 --> 00:41:15,180
it's it's costly

00:41:12,150 --> 00:41:17,220
it requires proc and so on and the most

00:41:15,180 --> 00:41:20,130
important part the most difficult part

00:41:17,220 --> 00:41:22,920
is really if you're a privileged process

00:41:20,130 --> 00:41:25,680
and you perform operations in terms of a

00:41:22,920 --> 00:41:27,540
less privileged task you have always

00:41:25,680 --> 00:41:29,040
have to assume like the privileges of

00:41:27,540 --> 00:41:31,140
the less privileged tasks and that's

00:41:29,040 --> 00:41:34,110
really problematic because you need to

00:41:31,140 --> 00:41:35,610
be very very sure that you take all of

00:41:34,110 --> 00:41:36,810
the things in mind think about make note

00:41:35,610 --> 00:41:38,490
you need to make sure that you know

00:41:36,810 --> 00:41:41,280
correct devices see group in case you

00:41:38,490 --> 00:41:43,740
there is a device listed device policy

00:41:41,280 --> 00:41:46,590
that blocks you from it you probably

00:41:43,740 --> 00:41:48,450
also need to assume that like if the

00:41:46,590 --> 00:41:55,110
process is kruta do you need to be

00:41:48,450 --> 00:41:56,430
attached to amount to actually get all

00:41:55,110 --> 00:41:57,870
the right pieces in the right order so

00:41:56,430 --> 00:41:59,670
that we would be at the right spot but

00:41:57,870 --> 00:42:01,590
also we'd set up enough privileges to

00:41:59,670 --> 00:42:03,420
actually do something because we could

00:42:01,590 --> 00:42:04,710
do it reasonably easily by also

00:42:03,420 --> 00:42:06,510
doctoring to the user name space but

00:42:04,710 --> 00:42:08,370
then we effectively lost our privileges

00:42:06,510 --> 00:42:11,310
and we couldn't actually do the make not

00:42:08,370 --> 00:42:13,200
anymore and we even had other cases

00:42:11,310 --> 00:42:15,390
where like amounts that originated from

00:42:13,200 --> 00:42:17,400
each side amount name space are owned by

00:42:15,390 --> 00:42:21,660
root inside the namespace and therefore

00:42:17,400 --> 00:42:23,010
thematically marked as node exactly I

00:42:21,660 --> 00:42:24,450
mean there's also there's a bunch of

00:42:23,010 --> 00:42:26,640
other stuff like as soon as you have a

00:42:24,450 --> 00:42:29,280
file system mounted and inside of the

00:42:26,640 --> 00:42:31,080
new mount namespace you cannot just

00:42:29,280 --> 00:42:32,700
simply create a device node in the

00:42:31,080 --> 00:42:33,960
original underlying file system because

00:42:32,700 --> 00:42:36,210
obviously there's something mounted

00:42:33,960 --> 00:42:38,310
above it and there is no way to create a

00:42:36,210 --> 00:42:39,780
device node for for a file system

00:42:38,310 --> 00:42:41,910
mounted from inside a user in a

00:42:39,780 --> 00:42:43,590
namespace because there's the SB I know

00:42:41,910 --> 00:42:46,500
that flex set that prevents you from

00:42:43,590 --> 00:42:48,120
doing so details so matter so you need

00:42:46,500 --> 00:42:50,130
to inject mounts into the container if

00:42:48,120 --> 00:42:52,530
you want to have the device and it's all

00:42:50,130 --> 00:42:54,090
just really messy it's a pretty mad

00:42:52,530 --> 00:42:59,030
powerful mechanism it allows you to get

00:42:54,090 --> 00:42:59,030
rid of fake root yeah yeah

00:43:02,270 --> 00:43:09,180
but well you can get are some issues

00:43:05,430 --> 00:43:11,160
with second argument filtering because

00:43:09,180 --> 00:43:15,210
obviously you're featuring flags is

00:43:11,160 --> 00:43:16,140
easier but filtering pointers what

00:43:15,210 --> 00:43:19,079
doesn't make sense

00:43:16,140 --> 00:43:24,450
and that exactly the same issues that

00:43:19,079 --> 00:43:28,109
you can in Qatar with luck so as you

00:43:24,450 --> 00:43:31,619
know i uz BPF to try to make something

00:43:28,109 --> 00:43:35,280
whisk as a pointer to try to filter I

00:43:31,619 --> 00:43:41,060
can object because in fact it's what you

00:43:35,280 --> 00:43:45,720
want to do so I've been interesting to

00:43:41,060 --> 00:43:48,710
to know if you have some some leads to

00:43:45,720 --> 00:43:54,780
be able to feature I can object without

00:43:48,710 --> 00:44:01,680
the EBP F stuff like I do with Doc and

00:43:54,780 --> 00:44:07,589
if you ever talk about using extending

00:44:01,680 --> 00:44:09,690
no luck for your use case I think there

00:44:07,589 --> 00:44:10,440
have been a couple of have been a couple

00:44:09,690 --> 00:44:14,119
of proposals

00:44:10,440 --> 00:44:16,800
I think Andy made an idea of what was it

00:44:14,119 --> 00:44:18,599
mark a bunch of syscalls as filterable

00:44:16,800 --> 00:44:27,119
right but that's something you really

00:44:18,599 --> 00:44:29,130
cased it really didn't like yeah yeah I

00:44:27,119 --> 00:44:32,010
mean it's it's right now it appears to

00:44:29,130 --> 00:44:34,710
be a question of where to do it there's

00:44:32,010 --> 00:44:36,420
a we can either cache the arguments as

00:44:34,710 --> 00:44:39,510
they're coming in and test them in two

00:44:36,420 --> 00:44:41,940
places or we can have it that analysis

00:44:39,510 --> 00:44:43,950
happening deeper at like the LSM level

00:44:41,940 --> 00:44:46,310
where you have to have a different idea

00:44:43,950 --> 00:44:48,839
of what the what the arguments are I

00:44:46,310 --> 00:44:51,960
don't know if you're familiar with it

00:44:48,839 --> 00:44:53,880
too so there's there's it's on the

00:44:51,960 --> 00:44:57,560
agenda for the colonel summit is to try

00:44:53,880 --> 00:44:57,560
to nail something down for this

00:44:59,350 --> 00:45:06,800
so in essence essentially no concrete

00:45:02,510 --> 00:45:10,940
proposals yet it's try to hide the fact

00:45:06,800 --> 00:45:15,360
but no okay yeah thanks for the talk

00:45:10,940 --> 00:45:15,360

YouTube URL: https://www.youtube.com/watch?v=uSrPrl3tn5U


