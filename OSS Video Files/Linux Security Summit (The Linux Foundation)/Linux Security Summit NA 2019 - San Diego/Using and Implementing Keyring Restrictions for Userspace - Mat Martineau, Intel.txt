Title: Using and Implementing Keyring Restrictions for Userspace - Mat Martineau, Intel
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Using and Implementing Keyring Restrictions for Userspace - Mat Martineau, Intel

The kernel keyring facility has grown in capability beyond its initial, limited support for x.509 certificate verification. It has been generalized to allow any key type to implement its own checks for allowable keys, and to configure these restrictions from userspace.Keyrings created by the keyctl API can currently be configured to verify signed x.509 asymmetric keys as they are linked to a keyring. The iNet Wireless Daemon (iwd) and the underlying Embedded Linux Library (ELL) leverage this to validate certificate chains.This presentation will cover use of the keyring restriction userspace API with asymmetric keys in today's kernel, how to extend kernel key types to support new userspace-configurable restrictions, and ideas for more capable and flexible restrictions in the future.
Captions: 
	00:00:00,030 --> 00:00:06,990
hi everyone I'm Matt Martineau I work at

00:00:02,909 --> 00:00:10,889
Intel and just talking about key

00:00:06,990 --> 00:00:12,660
restrictions today it's not something

00:00:10,889 --> 00:00:15,020
super sophisticated as much as it's

00:00:12,660 --> 00:00:17,820
something that's relatively new that

00:00:15,020 --> 00:00:21,720
maybe could see some use and security

00:00:17,820 --> 00:00:25,470
applications and wanted to help everyone

00:00:21,720 --> 00:00:30,660
learn about it so to start out with just

00:00:25,470 --> 00:00:32,520
giving a little baseline of what parts

00:00:30,660 --> 00:00:36,020
of the kernel key system and talking

00:00:32,520 --> 00:00:40,190
about so that we can all make sense of

00:00:36,020 --> 00:00:45,510
where we're adding things later on

00:00:40,190 --> 00:00:48,300
so overall the the kernel keys it gives

00:00:45,510 --> 00:00:50,149
you there's internal kernel api's and

00:00:48,300 --> 00:00:54,480
also visible from user space you can

00:00:50,149 --> 00:00:56,280
create these key objects everyone has

00:00:54,480 --> 00:01:01,079
every object has a serial number that

00:00:56,280 --> 00:01:02,789
you can use to look it up and and each

00:01:01,079 --> 00:01:05,040
of those keys contains some kind of

00:01:02,789 --> 00:01:08,850
payload where the meaning is dependent

00:01:05,040 --> 00:01:10,680
on on what type of key it is and there's

00:01:08,850 --> 00:01:15,540
a few other kind of attributes hanging

00:01:10,680 --> 00:01:17,549
off of there and each key has a type so

00:01:15,540 --> 00:01:22,860
within we know when you're implementing

00:01:17,549 --> 00:01:25,170
a key type within kernel code you

00:01:22,860 --> 00:01:27,080
populate a structure with the whole

00:01:25,170 --> 00:01:30,210
bunch of function pointers that you know

00:01:27,080 --> 00:01:32,400
implement this key type parses the

00:01:30,210 --> 00:01:35,369
payload lets you access the payloads in

00:01:32,400 --> 00:01:37,079
a meaningful way modify key well yeah

00:01:35,369 --> 00:01:41,130
set up the keys and the values

00:01:37,079 --> 00:01:44,340
associated with it and and those

00:01:41,130 --> 00:01:47,430
payloads include things like a user type

00:01:44,340 --> 00:01:50,149
is just a binary blob be whatever you

00:01:47,430 --> 00:01:53,970
need it to be a symmetric keys it'll

00:01:50,149 --> 00:01:56,939
parse x.509 certificates and give you

00:01:53,970 --> 00:02:00,119
access to the key material to do crypto

00:01:56,939 --> 00:02:03,450
operations in the kernel big keys like

00:02:00,119 --> 00:02:06,390
is a blob like the user key but is can

00:02:03,450 --> 00:02:09,450
get paged out and so it has some

00:02:06,390 --> 00:02:14,790
different trade-offs but

00:02:09,450 --> 00:02:20,340
that's those are basics there one

00:02:14,790 --> 00:02:23,430
special key type is a key ring which has

00:02:20,340 --> 00:02:26,850
is is a key in every way but one instead

00:02:23,430 --> 00:02:30,720
of a payload it contains a list of

00:02:26,850 --> 00:02:32,520
references to other keys so you use this

00:02:30,720 --> 00:02:38,400
to organize groups of keys for different

00:02:32,520 --> 00:02:41,870
purposes and this again is accessible

00:02:38,400 --> 00:02:45,360
from user space with the key control

00:02:41,870 --> 00:02:47,819
system call to link and unlink keys and

00:02:45,360 --> 00:02:52,950
you can have key rings within key rings

00:02:47,819 --> 00:02:59,400
and things like that so getting to the

00:02:52,950 --> 00:03:01,260
restriction part of things earlier on in

00:02:59,400 --> 00:03:05,970
the kernel like version four point six

00:03:01,260 --> 00:03:08,760
and earlier well yeah so what

00:03:05,970 --> 00:03:12,720
restrictions were built for was to help

00:03:08,760 --> 00:03:14,160
manage trusted keys in the kernel so

00:03:12,720 --> 00:03:17,760
with version four point six and earlier

00:03:14,160 --> 00:03:19,680
you could have you could load a

00:03:17,760 --> 00:03:22,049
symmetric keys from user space or within

00:03:19,680 --> 00:03:26,459
the kernel from from wherever it would

00:03:22,049 --> 00:03:30,750
would decode those keys and then using

00:03:26,459 --> 00:03:33,570
the the key identifier the signing Keys

00:03:30,750 --> 00:03:35,190
identifier and embedded in those keys it

00:03:33,570 --> 00:03:39,900
could look that up in the system keyring

00:03:35,190 --> 00:03:43,739
and if the assigning key was trusted had

00:03:39,900 --> 00:03:46,590
a keith flag trusted flag set on it then

00:03:43,739 --> 00:03:50,730
if you were signed by a trusted key you

00:03:46,590 --> 00:03:55,890
became a trusted key no matter where was

00:03:50,730 --> 00:03:58,079
used elsewhere in the system so in for

00:03:55,890 --> 00:04:01,319
kernel version four point seven about

00:03:58,079 --> 00:04:05,450
two years ago David Howells the keyring

00:04:01,319 --> 00:04:08,850
maintainer refactored that trust system

00:04:05,450 --> 00:04:12,359
so that instead of using key flag

00:04:08,850 --> 00:04:14,370
trusted you had you could have this

00:04:12,359 --> 00:04:16,470
concept of a trusted keyring within the

00:04:14,370 --> 00:04:20,430
kernel and just any key that was in that

00:04:16,470 --> 00:04:25,350
ring that was how you determined trust

00:04:20,430 --> 00:04:28,100
and to implement that he added a the

00:04:25,350 --> 00:04:31,380
function pointer to the key rings that

00:04:28,100 --> 00:04:32,820
just allowed you attach a function to it

00:04:31,380 --> 00:04:34,770
that function gets called when you

00:04:32,820 --> 00:04:38,070
attempt to link a key it can look at the

00:04:34,770 --> 00:04:42,720
key it can look at some other data and

00:04:38,070 --> 00:04:46,139
figure out do I trust this or not so

00:04:42,720 --> 00:04:48,000
this was you know the initial purpose of

00:04:46,139 --> 00:04:51,570
this was that refactoring of the the

00:04:48,000 --> 00:04:57,060
trusted keys but it was flexible enough

00:04:51,570 --> 00:04:59,550
to use for other things too so there so

00:04:57,060 --> 00:05:04,080
extending this to user space so where I

00:04:59,550 --> 00:05:05,789
came at it was I had some team members

00:05:04,080 --> 00:05:09,270
who are working on the high net Wireless

00:05:05,789 --> 00:05:11,630
daemon IWD which is it's like a it is a

00:05:09,270 --> 00:05:15,530
WPA supplicant kind of replacement and

00:05:11,630 --> 00:05:18,750
to do enterprise Wi-Fi authentication

00:05:15,530 --> 00:05:26,310
there's certain types of that that need

00:05:18,750 --> 00:05:29,280
to verify RSA certificates make sure you

00:05:26,310 --> 00:05:36,030
know you can trace your signed keys back

00:05:29,280 --> 00:05:38,599
to a certain route and this this was you

00:05:36,030 --> 00:05:42,780
know fit well with this ability to use

00:05:38,599 --> 00:05:44,280
other use that infrastructure added

00:05:42,780 --> 00:05:46,949
first richtek earrings because it's kind

00:05:44,280 --> 00:05:48,479
of a different idea of trust from what's

00:05:46,949 --> 00:05:50,940
in the kernel in terms of what you want

00:05:48,479 --> 00:05:52,560
to trust to load a module well this is

00:05:50,940 --> 00:05:57,120
what you want to trust to join the Wi-Fi

00:05:52,560 --> 00:05:58,770
network and kind of constraint we had

00:05:57,120 --> 00:06:04,050
set for ourselves on with that project

00:05:58,770 --> 00:06:05,520
was we're using iwd and has a support

00:06:04,050 --> 00:06:08,099
library in the embedded Linux library

00:06:05,520 --> 00:06:10,620
sort of a kind of a lightweight July

00:06:08,099 --> 00:06:12,539
replacement that we're building a few

00:06:10,620 --> 00:06:16,320
projects on and so we only have those

00:06:12,539 --> 00:06:19,590
depend on the kernel itself and and the

00:06:16,320 --> 00:06:20,789
C library so we knew the kernel already

00:06:19,590 --> 00:06:24,150
knew how to do everything we wanted to

00:06:20,789 --> 00:06:30,000
do there was just this barrier to be

00:06:24,150 --> 00:06:31,710
able to do it from from user space so so

00:06:30,000 --> 00:06:33,380
I worked on the patches to add a key

00:06:31,710 --> 00:06:37,280
control operation

00:06:33,380 --> 00:06:39,110
that would let you set the restrict

00:06:37,280 --> 00:06:42,470
function on a key ring from user space

00:06:39,110 --> 00:06:46,250
and so this this got merged for version

00:06:42,470 --> 00:06:50,870
412 there's some user space support

00:06:46,250 --> 00:06:53,390
libraries so the key control function

00:06:50,870 --> 00:06:59,060
isn't part of the C library it's part of

00:06:53,390 --> 00:07:02,090
this key utils library and so version

00:06:59,060 --> 00:07:05,090
one five eleven and later has a wrapper

00:07:02,090 --> 00:07:09,950
function for that sis call and a

00:07:05,090 --> 00:07:12,920
command-line utility as well and every

00:07:09,950 --> 00:07:21,500
every tag release we have of DLL has

00:07:12,920 --> 00:07:25,220
that function supported too so from from

00:07:21,500 --> 00:07:28,790
the user space side using using the Q

00:07:25,220 --> 00:07:32,290
utils call it's just just this one

00:07:28,790 --> 00:07:34,640
function call to think about it's just

00:07:32,290 --> 00:07:37,160
three things you give it you want this

00:07:34,640 --> 00:07:39,500
serial number of the keyring that you're

00:07:37,160 --> 00:07:46,310
trying to configure to only allow

00:07:39,500 --> 00:07:50,560
certain keys to be contained the key

00:07:46,310 --> 00:07:53,120
type associated with that restriction so

00:07:50,560 --> 00:07:57,290
we were working with asymmetric keys so

00:07:53,120 --> 00:08:01,280
this that's the key type we added to and

00:07:57,290 --> 00:08:05,210
then this restriction string which just

00:08:01,280 --> 00:08:09,560
gets parsed out and whatever code you

00:08:05,210 --> 00:08:11,030
add to the kernel key type looks up the

00:08:09,560 --> 00:08:13,760
right function pointer to plug in and

00:08:11,030 --> 00:08:17,390
and something potentially some extra

00:08:13,760 --> 00:08:19,940
data too and sets that all up within the

00:08:17,390 --> 00:08:23,180
kernel so that then every link operation

00:08:19,940 --> 00:08:25,100
will be checked you can do this on a

00:08:23,180 --> 00:08:27,320
keyring that's empty or one that's not

00:08:25,100 --> 00:08:29,920
empty the keys that are already there

00:08:27,320 --> 00:08:33,349
aren't checked by this function at all

00:08:29,920 --> 00:08:37,849
so you can deliberately pre-populate it

00:08:33,349 --> 00:08:44,290
and then restrict and limit changes from

00:08:37,849 --> 00:08:48,050
there or you can keep it empty

00:08:44,290 --> 00:08:52,910
so what's in the kernel today from you

00:08:48,050 --> 00:08:57,290
know for dot I forget what I said 12 or

00:08:52,910 --> 00:09:01,940
17 up through today is just these

00:08:57,290 --> 00:09:03,860
asymmetric key examples so similar to

00:09:01,940 --> 00:09:06,050
what the code inside the kernel uses you

00:09:03,860 --> 00:09:08,330
can you can use the trusted keys that

00:09:06,050 --> 00:09:12,400
are contained within the kernel or the

00:09:08,330 --> 00:09:16,790
built-in keys or the secondary key ring

00:09:12,400 --> 00:09:19,640
or you can use this the second line key

00:09:16,790 --> 00:09:21,710
or key ring with a key serial number and

00:09:19,640 --> 00:09:22,790
so what you're telling what you're

00:09:21,710 --> 00:09:26,390
telling the kernel is a configure in

00:09:22,790 --> 00:09:28,580
that case is to say you know here I'm

00:09:26,390 --> 00:09:33,740
giving you a de are encoded certificate

00:09:28,580 --> 00:09:35,990
only link it if it is signed by this

00:09:33,740 --> 00:09:37,670
specific key that you gave it a serial

00:09:35,990 --> 00:09:39,290
number for or if you give it a serial

00:09:37,670 --> 00:09:42,740
number for a keyring it'll search

00:09:39,290 --> 00:09:45,640
through the entire key ring to match the

00:09:42,740 --> 00:09:49,700
key identifiers and match the signature

00:09:45,640 --> 00:09:54,350
and you can also if you add this chain

00:09:49,700 --> 00:09:56,270
to the end it will also search the

00:09:54,350 --> 00:10:01,970
keyring itself so you're trying to link

00:09:56,270 --> 00:10:04,130
into keyring X you already have keys in

00:10:01,970 --> 00:10:06,170
it it'll also search the keys that are

00:10:04,130 --> 00:10:10,610
already in it as you know potential

00:10:06,170 --> 00:10:14,029
signers so what this system call looks

00:10:10,610 --> 00:10:18,380
like for keyring 1 2 3 4 5 you want to

00:10:14,029 --> 00:10:23,150
say only add signed keys to keyring 1 2

00:10:18,380 --> 00:10:26,959
3 4 5 and only look for the signing keys

00:10:23,150 --> 00:10:29,860
in gearing 6 7 8 9 you just do what's on

00:10:26,959 --> 00:10:29,860
the last line here

00:10:34,670 --> 00:10:40,250
so kind of the simplest case of how you

00:10:38,090 --> 00:10:43,820
would validate a certificate chain with

00:10:40,250 --> 00:10:47,330
this is you you would create one keyring

00:10:43,820 --> 00:10:49,370
put your root certificates in it create

00:10:47,330 --> 00:10:52,310
a second key will that call out one CI

00:10:49,370 --> 00:10:56,180
keyring and this kind of bash like

00:10:52,310 --> 00:10:59,210
pseudocode here you create a second key

00:10:56,180 --> 00:11:02,660
run called verify keyring you you

00:10:59,210 --> 00:11:04,640
restrict that you say it's it's an

00:11:02,660 --> 00:11:07,220
asymmetric type that you're using to

00:11:04,640 --> 00:11:09,740
look it up this is key or keyring you

00:11:07,220 --> 00:11:12,470
tell who who has the the root

00:11:09,740 --> 00:11:15,560
certificates and and use this chain

00:11:12,470 --> 00:11:16,940
option and then just in order from the

00:11:15,560 --> 00:11:18,260
key that you think is supposed to be

00:11:16,940 --> 00:11:20,150
signed by the root you try to link that

00:11:18,260 --> 00:11:22,330
one first and then you go on down the

00:11:20,150 --> 00:11:25,570
intermediate certificates and if you

00:11:22,330 --> 00:11:30,770
anything that gets allowed to link is

00:11:25,570 --> 00:11:33,530
part of that chain and like I said this

00:11:30,770 --> 00:11:38,660
is a simple case you can you can make it

00:11:33,530 --> 00:11:40,100
more strict by cleaning out all but the

00:11:38,660 --> 00:11:41,810
most recent keys so that you're making

00:11:40,100 --> 00:11:50,090
sure you're only checking the signature

00:11:41,810 --> 00:11:54,440
by the last thing you linked in so for

00:11:50,090 --> 00:11:55,910
some cases and in our case we use this

00:11:54,440 --> 00:12:00,500
kernel functionality instead of a crypto

00:11:55,910 --> 00:12:03,350
library that was desirable just because

00:12:00,500 --> 00:12:05,060
of the size and complexity of crypto

00:12:03,350 --> 00:12:06,800
libraries sometimes the licensing can

00:12:05,060 --> 00:12:10,880
get tricky sometimes they pull in

00:12:06,800 --> 00:12:17,840
additional extra third-party libraries

00:12:10,880 --> 00:12:22,520
too so probably the the main benefit is

00:12:17,840 --> 00:12:24,680
if you have other parts of the kernel or

00:12:22,520 --> 00:12:26,600
security infrastructure or something

00:12:24,680 --> 00:12:28,910
that it needs to use these keys they

00:12:26,600 --> 00:12:32,600
need to be in the kernel anyway you can

00:12:28,910 --> 00:12:34,940
you can use you might have more direct

00:12:32,600 --> 00:12:37,520
access to any crypto or security

00:12:34,940 --> 00:12:40,460
hardware or lower level functionality

00:12:37,520 --> 00:12:45,130
that you might use to evaluate the keys

00:12:40,460 --> 00:12:47,630
that you're adding if you are

00:12:45,130 --> 00:12:50,330
doing a lot of these operations to add

00:12:47,630 --> 00:12:53,630
and add keys to the kernel to evaluate

00:12:50,330 --> 00:12:56,270
them it might might have more overhead

00:12:53,630 --> 00:12:58,550
than doing it in userspace because you

00:12:56,270 --> 00:13:01,100
know takes system call after system call

00:12:58,550 --> 00:13:03,410
to load a key and try to link a key and

00:13:01,100 --> 00:13:06,080
do all the setup and teardown and stuff

00:13:03,410 --> 00:13:08,200
and depending on your usage you should

00:13:06,080 --> 00:13:14,330
use a program you're using this in that

00:13:08,200 --> 00:13:15,980
may or may not work for you and you know

00:13:14,330 --> 00:13:18,830
if you're trying to do a large volume of

00:13:15,980 --> 00:13:21,860
keys there you might trip over certain

00:13:18,830 --> 00:13:25,160
things in the big kernel key system like

00:13:21,860 --> 00:13:27,050
quotas for example can fill up depending

00:13:25,160 --> 00:13:30,170
on how you remove keys if you revoke

00:13:27,050 --> 00:13:31,340
them they might not get garbage

00:13:30,170 --> 00:13:33,590
collected right away and might hang

00:13:31,340 --> 00:13:36,380
around using up quota if you invalidate

00:13:33,590 --> 00:13:43,040
them they disappear more more

00:13:36,380 --> 00:13:46,820
immediately and there are other other

00:13:43,040 --> 00:13:48,260
ways to work around quotas with process

00:13:46,820 --> 00:13:50,720
and thread specific key rings that

00:13:48,260 --> 00:13:56,030
they're only visible visible to one

00:13:50,720 --> 00:13:58,490
processor thread so that kind of covers

00:13:56,030 --> 00:14:04,370
what what au what I've used keyrings for

00:13:58,490 --> 00:14:06,710
so far next step being to add your own

00:14:04,370 --> 00:14:08,660
weather weather adding those for a

00:14:06,710 --> 00:14:10,790
symmetric keys extending what's there

00:14:08,660 --> 00:14:12,560
already or if you have another key in

00:14:10,790 --> 00:14:15,920
another type of subsystem or something

00:14:12,560 --> 00:14:19,820
like that are different used for them

00:14:15,920 --> 00:14:22,250
this is how you add more so like I

00:14:19,820 --> 00:14:25,340
showed earlier with with key types and

00:14:22,250 --> 00:14:27,770
key rings in the kernel you've added two

00:14:25,340 --> 00:14:30,740
new things one is a lookup function in

00:14:27,770 --> 00:14:32,930
the key type that takes that string that

00:14:30,740 --> 00:14:36,260
came from user space figures out a

00:14:32,930 --> 00:14:37,700
function pointer plugs it in and then

00:14:36,260 --> 00:14:39,920
the key ring has a restrict function

00:14:37,700 --> 00:14:41,690
that lives there that's just that's the

00:14:39,920 --> 00:14:46,670
function that gets called on every link

00:14:41,690 --> 00:14:48,950
operation so step one figure out which

00:14:46,670 --> 00:14:50,330
key type they're gonna work with if

00:14:48,950 --> 00:14:54,800
you're adding something that only works

00:14:50,330 --> 00:14:56,270
with asymmetric keys probably best thing

00:14:54,800 --> 00:14:58,760
to do is add it to the asymmetric key

00:14:56,270 --> 00:15:00,980
type if you have a restriction then

00:14:58,760 --> 00:15:03,110
I consider the night work across

00:15:00,980 --> 00:15:07,430
multiple key types that's totally

00:15:03,110 --> 00:15:08,930
possible they the colonel key subsystem

00:15:07,430 --> 00:15:11,780
they just you know it'll look anything

00:15:08,930 --> 00:15:16,160
up based on a serial number so you could

00:15:11,780 --> 00:15:19,940
conceivably have a mix involved but you

00:15:16,160 --> 00:15:21,800
know you might want to only only allow

00:15:19,940 --> 00:15:23,300
that restriction to be configured if all

00:15:21,800 --> 00:15:26,080
of those key types are available in the

00:15:23,300 --> 00:15:29,660
kernel or you might want to make sure to

00:15:26,080 --> 00:15:35,180
turn on certain configurations if that

00:15:29,660 --> 00:15:38,030
is important to you too and another

00:15:35,180 --> 00:15:40,340
another choice is to not use an existing

00:15:38,030 --> 00:15:42,020
key type at all but just create a whole

00:15:40,340 --> 00:15:44,330
new type where maybe you can't even

00:15:42,020 --> 00:15:47,870
create instances of those keys but you

00:15:44,330 --> 00:15:50,630
could add the restriction lookup

00:15:47,870 --> 00:15:53,420
function to it that allows you to attach

00:15:50,630 --> 00:15:55,430
that code might be good to experiment

00:15:53,420 --> 00:15:57,950
that way do you want to be able to build

00:15:55,430 --> 00:16:00,080
and load a kernel module try out your

00:15:57,950 --> 00:16:05,960
restriction do something that's not

00:16:00,080 --> 00:16:07,190
intended for upstream and yeah I don't I

00:16:05,960 --> 00:16:09,170
don't know whether that would fly with

00:16:07,190 --> 00:16:11,300
the maintainer so if you try to upstream

00:16:09,170 --> 00:16:14,480
a key that you can couldn't actually use

00:16:11,300 --> 00:16:16,430
for anything other than lookups but it's

00:16:14,480 --> 00:16:24,530
a useful tool to have for development at

00:16:16,430 --> 00:16:25,730
least so the next step is just what do

00:16:24,530 --> 00:16:30,250
these functions look like that you

00:16:25,730 --> 00:16:33,500
attach to a keyring they look like this

00:16:30,250 --> 00:16:37,100
so you tell it which keyring you're

00:16:33,500 --> 00:16:41,630
trying to link to the type and payload

00:16:37,100 --> 00:16:43,940
in the middle are the key that you're

00:16:41,630 --> 00:16:47,420
trying to work with the one that's the

00:16:43,940 --> 00:16:49,820
candidate for linking it's it might not

00:16:47,420 --> 00:16:52,280
be a key object yet it might be in the

00:16:49,820 --> 00:16:55,820
middle being created so that's why you

00:16:52,280 --> 00:17:01,040
get the payload here and then the final

00:16:55,820 --> 00:17:05,000
pointer to a key is like in the example

00:17:01,040 --> 00:17:07,970
of the existing key or keyring thing

00:17:05,000 --> 00:17:09,449
this is a pointer to the you're signing

00:17:07,970 --> 00:17:15,029
keys that

00:17:09,449 --> 00:17:16,709
you can look at so like many functions

00:17:15,029 --> 00:17:19,610
in the kernel so return zero if it's

00:17:16,709 --> 00:17:22,019
okay or some error value if it's not and

00:17:19,610 --> 00:17:23,579
if you're calling someone's trying to

00:17:22,019 --> 00:17:25,529
link the key from user space if there's

00:17:23,579 --> 00:17:30,480
an error that error gets propagated out

00:17:25,529 --> 00:17:34,710
to whoever made the system call some

00:17:30,480 --> 00:17:37,169
things to consider so this the keyring

00:17:34,710 --> 00:17:40,440
has the data structure has this restrict

00:17:37,169 --> 00:17:42,419
function pointer hanging out there if

00:17:40,440 --> 00:17:44,820
you're writing kernel code using

00:17:42,419 --> 00:17:46,260
restrictions you don't want to just plug

00:17:44,820 --> 00:17:49,620
that in directly there's a keyring

00:17:46,260 --> 00:17:52,620
restrict function that'll kind of do all

00:17:49,620 --> 00:17:54,779
the details for you of locking in

00:17:52,620 --> 00:17:57,809
reference counting and making sure that

00:17:54,779 --> 00:17:59,429
you don't have a keyring that's trying

00:17:57,809 --> 00:18:04,380
to be restricted on itself through some

00:17:59,429 --> 00:18:05,970
cycle or something since since key

00:18:04,380 --> 00:18:07,860
serial number can be associated with any

00:18:05,970 --> 00:18:10,399
key type you want to double check that

00:18:07,860 --> 00:18:13,049
you're using what you think you are and

00:18:10,399 --> 00:18:17,130
there's also a useful key validate

00:18:13,049 --> 00:18:19,110
function that when you're trying to

00:18:17,130 --> 00:18:21,120
access each key you need to make sure

00:18:19,110 --> 00:18:22,769
that it hasn't been you know garbage

00:18:21,120 --> 00:18:25,860
collected in the middle of your process

00:18:22,769 --> 00:18:33,000
or something so if you validate it it'll

00:18:25,860 --> 00:18:37,080
be available for you to use safely so

00:18:33,000 --> 00:18:39,240
that in previous couple slides just

00:18:37,080 --> 00:18:41,970
talking about this is what gets added to

00:18:39,240 --> 00:18:44,039
a keyring so the next step is what do we

00:18:41,970 --> 00:18:48,510
add to a key type and this is just the

00:18:44,039 --> 00:18:50,880
lookup function that takes that string

00:18:48,510 --> 00:18:58,649
that came from user space and figures

00:18:50,880 --> 00:19:00,029
out what to do with it so all this the

00:18:58,649 --> 00:19:02,309
you know the main job of it takes that

00:19:00,029 --> 00:19:03,929
string returns a pointer to this

00:19:02,309 --> 00:19:08,389
structure and the structure has the

00:19:03,929 --> 00:19:11,059
function pointer the the key that you're

00:19:08,389 --> 00:19:15,299
using to look up your signing keys and

00:19:11,059 --> 00:19:18,360
the key type that owns it because if you

00:19:15,299 --> 00:19:19,980
try to say remove the module or D

00:19:18,360 --> 00:19:21,750
register that key type it there's

00:19:19,980 --> 00:19:22,270
there's some cleanup for the key system

00:19:21,750 --> 00:19:28,720
to do

00:19:22,270 --> 00:19:30,490
so let's see what else and that

00:19:28,720 --> 00:19:33,580
structure should be dynamically

00:19:30,490 --> 00:19:36,130
allocated because when it gets garbage

00:19:33,580 --> 00:19:40,750
collected it's gonna it's going to try

00:19:36,130 --> 00:19:42,400
to free that anything else so that that

00:19:40,750 --> 00:19:45,790
struct key restriction that the lookup

00:19:42,400 --> 00:19:47,559
function returned if your statting more

00:19:45,790 --> 00:19:49,179
complicated functionality that needs

00:19:47,559 --> 00:19:52,780
more than a single key pointer you might

00:19:49,179 --> 00:20:00,640
need to add more members to that

00:19:52,780 --> 00:20:03,040
structure and you know just I mean kind

00:20:00,640 --> 00:20:05,140
of goes for a lot of kernel code you

00:20:03,040 --> 00:20:07,000
know if you're dealing with something

00:20:05,140 --> 00:20:07,720
reference kind of make sure you're doing

00:20:07,000 --> 00:20:13,929
it right

00:20:07,720 --> 00:20:17,190
cue key lookup is how you grab a key

00:20:13,929 --> 00:20:19,150
pointer from a serial number and that

00:20:17,190 --> 00:20:21,840
that will give you something

00:20:19,150 --> 00:20:27,570
appropriately reference counting so

00:20:21,840 --> 00:20:32,190
that's that so where to go from here

00:20:27,570 --> 00:20:35,559
this is kind of where hopefully

00:20:32,190 --> 00:20:41,130
somewhere in the security world this is

00:20:35,559 --> 00:20:45,190
this would be a useful tool for managing

00:20:41,130 --> 00:20:52,540
any key based things you might be doing

00:20:45,190 --> 00:20:54,220
with say setting up trust between you

00:20:52,540 --> 00:20:56,650
know ultra virtual machine hosts and

00:20:54,220 --> 00:20:58,300
guests or you know kind of some of the

00:20:56,650 --> 00:21:01,600
topics we've heard talked about already

00:20:58,300 --> 00:21:04,720
today in the last few days something

00:21:01,600 --> 00:21:09,420
that happened after I mean added I added

00:21:04,720 --> 00:21:13,179
the initial asymmetric restrictions

00:21:09,420 --> 00:21:17,260
there in version 4.20 of the kernel

00:21:13,179 --> 00:21:21,130
there the asymmetric key has a it has a

00:21:17,260 --> 00:21:24,730
subtype depending on where the key came

00:21:21,130 --> 00:21:28,059
from and now there is a subtype for TPM

00:21:24,730 --> 00:21:30,820
based keys so if you could add a

00:21:28,059 --> 00:21:33,000
restriction base that says oh well this

00:21:30,820 --> 00:21:34,410
will only accept keys that have been

00:21:33,000 --> 00:21:40,290
signed

00:21:34,410 --> 00:21:43,260
something in the TPM you could add other

00:21:40,290 --> 00:21:43,440
things than signatures um you could say

00:21:43,260 --> 00:21:46,710
I

00:21:43,440 --> 00:21:48,950
I only want to allow keys of you know

00:21:46,710 --> 00:21:53,700
with a certain number of bits or more

00:21:48,950 --> 00:21:56,400
because on a lot of cases you know the

00:21:53,700 --> 00:21:58,550
user space program is just passing off

00:21:56,400 --> 00:22:02,220
these include encoded certificate blobs

00:21:58,550 --> 00:22:04,410
to to the kernel to do the decoding it

00:22:02,220 --> 00:22:07,830
might not know that much about what's

00:22:04,410 --> 00:22:12,720
inside them how big the key is so that

00:22:07,830 --> 00:22:14,910
that could be used to check that and I

00:22:12,720 --> 00:22:18,120
saw the raised hands earlier in the week

00:22:14,910 --> 00:22:20,790
people who know about EBP F so you know

00:22:18,120 --> 00:22:23,100
it kind of seemed like what would have

00:22:20,790 --> 00:22:25,320
done so far is implement kernel code you

00:22:23,100 --> 00:22:29,250
use the string from user space to just

00:22:25,320 --> 00:22:32,550
say call this kernel function and and

00:22:29,250 --> 00:22:34,620
you're kind of locked in but you know

00:22:32,550 --> 00:22:37,530
maybe somewhere down the line people

00:22:34,620 --> 00:22:39,450
want something more flexible that an

00:22:37,530 --> 00:22:45,210
appropriately privileged demon or

00:22:39,450 --> 00:22:48,860
something could add some vpf e BPF code

00:22:45,210 --> 00:22:53,180
that could have some fine-tuned Abul

00:22:48,860 --> 00:22:56,040
restrictions that would have access to

00:22:53,180 --> 00:23:02,130
whatever criteria you needed to use to

00:22:56,040 --> 00:23:06,210
assess a key so that's all I've got

00:23:02,130 --> 00:23:09,150
there's or to contact me some mailing

00:23:06,210 --> 00:23:12,330
lists and whatnot referencing some of

00:23:09,150 --> 00:23:15,230
the projects I and I talked about so any

00:23:12,330 --> 00:23:15,230
questions

00:23:25,590 --> 00:23:33,250
so if we're gonna open up the Pandora's

00:23:28,780 --> 00:23:34,990
box of EPP f in the keyring you know I

00:23:33,250 --> 00:23:36,250
immediately start asking other questions

00:23:34,990 --> 00:23:37,990
like hey can we start implementing

00:23:36,250 --> 00:23:39,940
something that looks more like a crypto

00:23:37,990 --> 00:23:42,790
API based on on the keyring to say hey I

00:23:39,940 --> 00:23:45,970
want to like create a new key and give

00:23:42,790 --> 00:23:48,580
me a key descriptor back and let me use

00:23:45,970 --> 00:23:50,140
that to do rap and unwrap operations or

00:23:48,580 --> 00:23:51,310
derivations and other such things that

00:23:50,140 --> 00:23:53,980
you would normally do with a key

00:23:51,310 --> 00:23:55,270
management system right not for how much

00:23:53,980 --> 00:23:56,620
discussion there's been on this but as

00:23:55,270 --> 00:23:59,830
long as we're talking about EVP and

00:23:56,620 --> 00:24:01,930
keyring why not sure I mean some some of

00:23:59,830 --> 00:24:04,020
those key types there's like trusted and

00:24:01,930 --> 00:24:06,970
encrypted keys where those keys can be

00:24:04,020 --> 00:24:12,550
generated by through key control

00:24:06,970 --> 00:24:13,960
operation but it's I was trying to think

00:24:12,550 --> 00:24:17,080
about what else is in there already

00:24:13,960 --> 00:24:19,390
um there are so when you load an

00:24:17,080 --> 00:24:24,250
asymmetric key in the kernel there you

00:24:19,390 --> 00:24:26,380
can sign you can verify signatures you

00:24:24,250 --> 00:24:32,470
can use that too so you load multiple

00:24:26,380 --> 00:24:36,850
keys you can load two keys and say you

00:24:32,470 --> 00:24:40,540
know okay now verify a signature on the

00:24:36,850 --> 00:24:44,230
key that I pass in or you can encrypt

00:24:40,540 --> 00:24:46,870
data and there's there is a PK cs8

00:24:44,230 --> 00:24:49,750
parser now I don't remember when that

00:24:46,870 --> 00:24:51,430
got merged but you can load a a

00:24:49,750 --> 00:24:54,100
certificate that has private and public

00:24:51,430 --> 00:24:56,740
keys and you can encrypt and you can

00:24:54,100 --> 00:25:03,400
sign using the king control API as well

00:24:56,740 --> 00:25:05,440
already so but it yeah it is would be

00:25:03,400 --> 00:25:08,370
interesting to go along those lines and

00:25:05,440 --> 00:25:11,370
expose more functionality damn it damn

00:25:08,370 --> 00:25:11,370
dynamically

00:25:13,039 --> 00:25:16,249
over here

00:25:27,510 --> 00:25:35,790
they're certain storage protocols in the

00:25:33,180 --> 00:25:40,280
kernel like NFS I scuzzy and envy me on

00:25:35,790 --> 00:25:46,140
TCP that want to use TLS and there's a

00:25:40,280 --> 00:25:49,110
certain lack of ability for the kernel

00:25:46,140 --> 00:25:51,990
to discover what certificate to use to

00:25:49,110 --> 00:25:54,720
authenticate and I'm wondering if this

00:25:51,990 --> 00:25:58,590
might be an answer I mean the answer

00:25:54,720 --> 00:26:00,660
that we have today is to build a net

00:25:58,590 --> 00:26:03,360
link infrastructure but I'm not sure

00:26:00,660 --> 00:26:06,690
that's really wise sure do you have any

00:26:03,360 --> 00:26:09,210
opinions about that um it I mean it

00:26:06,690 --> 00:26:12,480
sounds like something workable I mean

00:26:09,210 --> 00:26:16,560
you could have if you had a way to

00:26:12,480 --> 00:26:20,430
provide key IDs to you know a specific

00:26:16,560 --> 00:26:24,750
connection and I mean this this kind of

00:26:20,430 --> 00:26:27,690
comes into play more of you know do I

00:26:24,750 --> 00:26:29,160
trust that do do I don't want to use the

00:26:27,690 --> 00:26:30,900
word trust because that has some very

00:26:29,160 --> 00:26:32,520
specific meaning but this is the

00:26:30,900 --> 00:26:34,860
certificate you know signed

00:26:32,520 --> 00:26:37,350
appropriately or it doesn't mean

00:26:34,860 --> 00:26:40,410
whatever criteria I have that I want to

00:26:37,350 --> 00:26:42,870
use with NFS though you could use that

00:26:40,410 --> 00:26:44,580
to say okay I tried to load this and it

00:26:42,870 --> 00:26:47,160
accepted it it rejected it

00:26:44,580 --> 00:26:49,680
okay now that key it was accepted it's

00:26:47,160 --> 00:26:53,130
in the kernel now now it's kind of a

00:26:49,680 --> 00:26:55,580
matter of just conventional using the

00:26:53,130 --> 00:26:58,920
key subsystem and tying that into

00:26:55,580 --> 00:27:00,990
whatever other you know NFS kernel code

00:26:58,920 --> 00:27:04,470
is running that you do you want to grab

00:27:00,990 --> 00:27:06,030
that for but you know if it's something

00:27:04,470 --> 00:27:07,320
you're using across multiple connections

00:27:06,030 --> 00:27:10,200
you know it could make sense to load

00:27:07,320 --> 00:27:14,220
that key once no it's good and then use

00:27:10,200 --> 00:27:18,800
that key ID over and over again so that

00:27:14,220 --> 00:27:18,800
helpful okay

00:27:18,940 --> 00:27:21,940
okay

00:27:25,990 --> 00:27:30,029
okay okay

00:27:30,610 --> 00:27:38,580
no more questions okay thanks Matt

00:27:34,590 --> 00:27:38,580

YouTube URL: https://www.youtube.com/watch?v=K5ysLhHhPJI


