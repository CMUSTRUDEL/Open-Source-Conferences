Title: Rich Authorization in a Resource Constrained Device - Kenneth Goldman, IBM
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Rich Authorization in a Resource Constrained Device - Kenneth Goldman, IBM

TPM 2.0 is an example of a low cost, resource-constrained device that provides a rich set of authorizations. The design targeted a device with very little RAM. This talk starts with the overall design of TPMauthorization policies, how they are calculated and how they are satisfied.Next, many of the policy statements are presented, with examples of use cases that they enable. Finally, a more complicated use case is presented, one that was never envisioned when the TPM was first designed.
Captions: 
	00:00:00,060 --> 00:00:07,049
okay is the microts working so what I

00:00:05,040 --> 00:00:11,580
mean by rich authorization is

00:00:07,049 --> 00:00:14,460
authorizations that go way beyond simple

00:00:11,580 --> 00:00:19,910
things like like passwords and H Max or

00:00:14,460 --> 00:00:21,990
even asymmetric a digital signatures

00:00:19,910 --> 00:00:26,880
what I mean by a resource-constrained

00:00:21,990 --> 00:00:30,330
device is specifically very small

00:00:26,880 --> 00:00:32,910
amounts of memory talking about hundreds

00:00:30,330 --> 00:00:36,860
of bytes not kilobytes and certainly not

00:00:32,910 --> 00:00:39,480
megabytes the implementation of this

00:00:36,860 --> 00:00:42,629
some of you people know about TPM

00:00:39,480 --> 00:00:45,030
policies and TPM 2.0 that's an

00:00:42,629 --> 00:00:47,700
implementation of it if you're

00:00:45,030 --> 00:00:50,460
interested in that great even if you're

00:00:47,700 --> 00:00:54,079
not interested in TPM 2.0 I hope that

00:00:50,460 --> 00:00:57,180
this will trigger some thinking about

00:00:54,079 --> 00:01:01,039
what you can do as far as authorizations

00:00:57,180 --> 00:01:03,180
using very small amounts of memory a

00:01:01,039 --> 00:01:06,659
typical example of what you would

00:01:03,180 --> 00:01:09,900
authorize is a key like a public key or

00:01:06,659 --> 00:01:12,920
a symmetric use of a symmetric key but

00:01:09,900 --> 00:01:14,960
it goes way beyond that as well into

00:01:12,920 --> 00:01:18,409
clocks

00:01:14,960 --> 00:01:20,640
memory and non-volatile memory

00:01:18,409 --> 00:01:24,150
administrative commands and I'll try to

00:01:20,640 --> 00:01:28,290
give a lot of examples of it I'm gonna

00:01:24,150 --> 00:01:30,869
start with a few slides on the the

00:01:28,290 --> 00:01:33,060
mechanism how how it works underneath

00:01:30,869 --> 00:01:38,220
but then I want to go pretty quickly

00:01:33,060 --> 00:01:43,320
into use cases so this is an example of

00:01:38,220 --> 00:01:46,920
an immediate assertion where the entity

00:01:43,320 --> 00:01:52,020
over on the Left has a single policy

00:01:46,920 --> 00:01:55,079
digest represented by policy C in order

00:01:52,020 --> 00:01:57,960
to satisfy the policy you start a

00:01:55,079 --> 00:02:02,250
session the session has again a single

00:01:57,960 --> 00:02:04,259
session digest it starts at zero and

00:02:02,250 --> 00:02:06,530
then you send in a bunch of policy

00:02:04,259 --> 00:02:09,629
commands and here I show three commands

00:02:06,530 --> 00:02:14,680
if the commands

00:02:09,629 --> 00:02:17,620
verify correctly then the session digest

00:02:14,680 --> 00:02:21,220
gets extended in the in the TPM sense

00:02:17,620 --> 00:02:23,200
where you take the old digest you append

00:02:21,220 --> 00:02:25,930
some data to it you hash that and you

00:02:23,200 --> 00:02:28,209
get a new digest so these digests

00:02:25,930 --> 00:02:32,890
accumulate as the commands come in and

00:02:28,209 --> 00:02:36,670
it goes from A to B to C once you get to

00:02:32,890 --> 00:02:39,099
see you're ready to actually run the

00:02:36,670 --> 00:02:43,410
command that you've authorized at that

00:02:39,099 --> 00:02:46,599
time it's a simple mem compare of the

00:02:43,410 --> 00:02:48,940
digest that's in the policy of the

00:02:46,599 --> 00:02:50,980
entity to the digest that's in the

00:02:48,940 --> 00:02:56,079
session and in this case they match

00:02:50,980 --> 00:02:59,290
they're both C and the the authorization

00:02:56,079 --> 00:03:02,739
succeeds these are called immediate

00:02:59,290 --> 00:03:05,980
assertions because the validation is

00:03:02,739 --> 00:03:08,590
done when the policy command is sent in

00:03:05,980 --> 00:03:10,840
so there are these three commands and

00:03:08,590 --> 00:03:12,849
they're checked at the time the command

00:03:10,840 --> 00:03:14,980
is sent in not at the time you're

00:03:12,849 --> 00:03:16,989
running the actually not at the time

00:03:14,980 --> 00:03:20,769
that you're using the the key or the

00:03:16,989 --> 00:03:23,889
entity there's another concept called

00:03:20,769 --> 00:03:26,739
deferred authorizations here where you

00:03:23,889 --> 00:03:30,459
send in a policy command and it just

00:03:26,739 --> 00:03:32,530
updates the session State something

00:03:30,459 --> 00:03:35,530
could be checked at this time but

00:03:32,530 --> 00:03:38,290
typically it's deferred and then at

00:03:35,530 --> 00:03:40,510
runtime when you send in the command and

00:03:38,290 --> 00:03:42,400
the command parameters it's checked

00:03:40,510 --> 00:03:44,620
against the session state and so the

00:03:42,400 --> 00:03:47,260
validation is done at the time that

00:03:44,620 --> 00:03:52,569
you're using the entity and I will give

00:03:47,260 --> 00:03:55,329
examples of all of these so if I go back

00:03:52,569 --> 00:03:56,920
one slide if you think about the way a

00:03:55,329 --> 00:04:02,079
hash works

00:03:56,920 --> 00:04:04,329
this becomes an and function where you

00:04:02,079 --> 00:04:07,239
need all three of these commands to

00:04:04,329 --> 00:04:10,180
succeed if one of them fails and there's

00:04:07,239 --> 00:04:13,329
no way to get from a digest of zero to a

00:04:10,180 --> 00:04:15,760
digest of C so it becomes an and and you

00:04:13,329 --> 00:04:17,019
can accumulate in this case I show three

00:04:15,760 --> 00:04:22,780
but an unknown

00:04:17,019 --> 00:04:25,659
number of of commands and the there is

00:04:22,780 --> 00:04:27,580
still one single digest in the session

00:04:25,659 --> 00:04:31,750
so memory doesn't grow no matter how

00:04:27,580 --> 00:04:34,120
many policy commands you send in and

00:04:31,750 --> 00:04:37,780
then the obvious question would be well

00:04:34,120 --> 00:04:43,360
can I do an or and the answer of course

00:04:37,780 --> 00:04:47,259
is yes the way that in or works is the

00:04:43,360 --> 00:04:51,580
entity has a policy digest widget which

00:04:47,259 --> 00:04:53,319
is a hash of all the and policies so if

00:04:51,580 --> 00:04:55,419
you look over on the left there's an and

00:04:53,319 --> 00:04:57,430
policy C which was the one from the

00:04:55,419 --> 00:05:00,759
previous slide and then there's other

00:04:57,430 --> 00:05:05,470
and policies de and F they get hashed

00:05:00,759 --> 00:05:08,680
together to policy in the way that this

00:05:05,470 --> 00:05:11,139
is satisfied is you start a session you

00:05:08,680 --> 00:05:13,719
have a session digest starts at zero as

00:05:11,139 --> 00:05:16,810
before it progresses from A to B to C

00:05:13,719 --> 00:05:18,879
and at that time you send in this polish

00:05:16,810 --> 00:05:22,419
this special command called policy or

00:05:18,879 --> 00:05:26,710
with a list of digests and the list here

00:05:22,419 --> 00:05:29,229
is C D E and F the device will look for

00:05:26,710 --> 00:05:31,120
a match against one of them if one of

00:05:29,229 --> 00:05:31,750
them matches then we know everything is

00:05:31,120 --> 00:05:36,219
okay

00:05:31,750 --> 00:05:38,830
we replace the session digests C with a

00:05:36,219 --> 00:05:42,789
session digest end the hash of the list

00:05:38,830 --> 00:05:46,090
they match and everything is good you're

00:05:42,789 --> 00:05:49,650
good to go you're authorized so a

00:05:46,090 --> 00:05:51,909
summary there it there are immediate

00:05:49,650 --> 00:05:53,529
assertions which are done at the time

00:05:51,909 --> 00:05:56,620
that you send in the policy command

00:05:53,529 --> 00:05:58,240
deferred assertions are done at the time

00:05:56,620 --> 00:06:01,060
that you're actually trying to use the

00:05:58,240 --> 00:06:03,819
authorization there are an terms and

00:06:01,060 --> 00:06:07,060
there are or terms and I should say that

00:06:03,819 --> 00:06:10,870
you're not limited to a bunch of ands

00:06:07,060 --> 00:06:12,880
and then a single or you can do a series

00:06:10,870 --> 00:06:16,120
of war terms you can do a series of or

00:06:12,880 --> 00:06:19,430
terms and then more an terms to any

00:06:16,120 --> 00:06:21,950
complexity that you like and

00:06:19,430 --> 00:06:26,180
the key is that through all of this

00:06:21,950 --> 00:06:28,820
there's just one digest just as a level

00:06:26,180 --> 00:06:32,480
set the most complicated policies that

00:06:28,820 --> 00:06:35,810
I've seen have typically about three or

00:06:32,480 --> 00:06:37,940
four and terms and three or terms I

00:06:35,810 --> 00:06:40,010
haven't seen anything more complex than

00:06:37,940 --> 00:06:44,840
that but there's nothing in the design

00:06:40,010 --> 00:06:48,320
that limits this at all let's see okay

00:06:44,840 --> 00:06:51,920
each entity has one has a policy that is

00:06:48,320 --> 00:06:55,030
one fixed size digest something else

00:06:51,920 --> 00:06:57,410
that's very nice is that if we add more

00:06:55,030 --> 00:07:00,680
authentication types in the future if we

00:06:57,410 --> 00:07:03,080
add more policy commands the structure

00:07:00,680 --> 00:07:06,050
of the key doesn't change and the

00:07:03,080 --> 00:07:09,080
structure of the session doesn't change

00:07:06,050 --> 00:07:12,320
so everything is backward compatible you

00:07:09,080 --> 00:07:15,230
can add more features without changing

00:07:12,320 --> 00:07:17,660
any of the existing structures the

00:07:15,230 --> 00:07:20,950
session just has one fixed size state

00:07:17,660 --> 00:07:23,090
plus any deferred authorizations

00:07:20,950 --> 00:07:26,630
something else that might not be obvious

00:07:23,090 --> 00:07:29,540
is that the policy calculation the

00:07:26,630 --> 00:07:31,670
policy contains no secrets it might have

00:07:29,540 --> 00:07:33,380
public keys but it doesn't have private

00:07:31,670 --> 00:07:35,930
keys it doesn't have passwords or

00:07:33,380 --> 00:07:38,480
anything like that what this means is

00:07:35,930 --> 00:07:42,350
that you can pre calculate the policies

00:07:38,480 --> 00:07:45,890
offline and you might have an even in an

00:07:42,350 --> 00:07:48,620
entity you might have each platform has

00:07:45,890 --> 00:07:51,110
its own signing key each of the signing

00:07:48,620 --> 00:07:53,600
keys will be unique but if the business

00:07:51,110 --> 00:07:56,720
logic is the same they'll have they'll

00:07:53,600 --> 00:08:00,220
all have the same policy hash the the

00:07:56,720 --> 00:08:07,070
value of the policy will be the same

00:08:00,220 --> 00:08:09,350
okay some use cases the most easy to

00:08:07,070 --> 00:08:12,020
understand perhaps is policy command

00:08:09,350 --> 00:08:15,320
code this is an authorization that's

00:08:12,020 --> 00:08:20,570
linked to a particular command its

00:08:15,320 --> 00:08:22,850
deferred in that the policy command just

00:08:20,570 --> 00:08:25,840
says in the future you need to check

00:08:22,850 --> 00:08:29,930
that a certain command code is running

00:08:25,840 --> 00:08:32,090
some use cases of this so in the TCG

00:08:29,930 --> 00:08:32,599
world there's this thing called a quote

00:08:32,090 --> 00:08:35,449
which

00:08:32,599 --> 00:08:38,509
signed attestation but you can think of

00:08:35,449 --> 00:08:40,880
other signings or other commands so you

00:08:38,509 --> 00:08:43,729
can take a key and you can say I'm going

00:08:40,880 --> 00:08:46,430
to restrict this key to only certain

00:08:43,729 --> 00:08:48,740
types of signing only a quote you can

00:08:46,430 --> 00:08:53,269
take a symmetric key and you see you can

00:08:48,740 --> 00:08:56,029
say the policy for this command I can

00:08:53,269 --> 00:09:00,470
only use it to encrypt I can't use it to

00:08:56,029 --> 00:09:03,649
decrypt another very common use is for

00:09:00,470 --> 00:09:05,870
memory if you want to have certain

00:09:03,649 --> 00:09:08,389
policies for writing which you might be

00:09:05,870 --> 00:09:11,810
more restrictive and other policies for

00:09:08,389 --> 00:09:14,569
reading which are more liberal you would

00:09:11,810 --> 00:09:16,310
use this policy command code and you

00:09:14,569 --> 00:09:21,920
would have one or term for writes

00:09:16,310 --> 00:09:25,459
another or term for reads delegation so

00:09:21,920 --> 00:09:30,649
you might have some very highly

00:09:25,459 --> 00:09:34,009
privileged administrative tasks and you

00:09:30,649 --> 00:09:36,259
can say okay we will have an or term

00:09:34,009 --> 00:09:38,420
here for example for a firmware update

00:09:36,259 --> 00:09:41,000
and you'll say well okay here's the

00:09:38,420 --> 00:09:44,120
policy for firmware update and it might

00:09:41,000 --> 00:09:46,430
be more or less relaxed or certainly

00:09:44,120 --> 00:09:49,130
different than another administrative

00:09:46,430 --> 00:09:50,959
command like like rebooting or something

00:09:49,130 --> 00:09:56,630
like that so that's what you would use

00:09:50,959 --> 00:10:00,279
command code for authorization value and

00:09:56,630 --> 00:10:02,779
password are also fairly straightforward

00:10:00,279 --> 00:10:07,220
this is saying in order to authorize

00:10:02,779 --> 00:10:10,069
this you need a password or or an H Mac

00:10:07,220 --> 00:10:12,980
of the parameters a very common thing

00:10:10,069 --> 00:10:16,519
would be to combine that with policy

00:10:12,980 --> 00:10:19,850
command code which would say say to do

00:10:16,519 --> 00:10:21,769
our memory right you need a password to

00:10:19,850 --> 00:10:23,689
do a memory read you don't need a

00:10:21,769 --> 00:10:28,189
password so you would have those two are

00:10:23,689 --> 00:10:30,589
terms that's a very common use case okay

00:10:28,189 --> 00:10:32,740
now a more a more complicated one and

00:10:30,589 --> 00:10:38,870
I'm gonna put my glasses on for this one

00:10:32,740 --> 00:10:42,079
nope so this is this is an authorization

00:10:38,870 --> 00:10:45,280
tied to a digital signature it has

00:10:42,079 --> 00:10:47,170
parameters such as a nonce

00:10:45,280 --> 00:10:49,060
which would say I'm gonna sign this

00:10:47,170 --> 00:10:52,810
authorization but it can only be used

00:10:49,060 --> 00:10:54,610
once you can lock it to the command

00:10:52,810 --> 00:10:56,680
parameters so you could say I'm only

00:10:54,610 --> 00:10:59,320
going to I can I'm authorizing this but

00:10:56,680 --> 00:11:01,090
only for certain parameters policy

00:10:59,320 --> 00:11:03,820
reference I'll get to a second in a

00:11:01,090 --> 00:11:06,550
second and an expiration so you can say

00:11:03,820 --> 00:11:09,940
okay i'm i'm signing I'm authorizing you

00:11:06,550 --> 00:11:13,060
to use this key but only for the next

00:11:09,940 --> 00:11:15,010
half an hour or only for the weekend

00:11:13,060 --> 00:11:19,600
when I come back on Monday you lose your

00:11:15,010 --> 00:11:21,610
authorization use-cases authorization

00:11:19,600 --> 00:11:24,640
using a smart card so you can have a

00:11:21,610 --> 00:11:28,090
smart card or other HSM signing an

00:11:24,640 --> 00:11:31,810
authorization to do something you might

00:11:28,090 --> 00:11:36,040
have say your your device here is being

00:11:31,810 --> 00:11:38,410
used as a CA to sign some software but

00:11:36,040 --> 00:11:41,020
you don't want to allow anyone to use

00:11:38,410 --> 00:11:43,450
that CA so you can authorize the CA

00:11:41,020 --> 00:11:47,620
itself with a smart card something like

00:11:43,450 --> 00:11:49,930
that biometric if your biometric and do

00:11:47,620 --> 00:11:52,120
digital signatures you can authorize say

00:11:49,930 --> 00:11:54,460
with a fingerprint reader and this is

00:11:52,120 --> 00:11:57,820
where the policy reference comes along

00:11:54,460 --> 00:12:00,400
because you don't want to say anybody's

00:11:57,820 --> 00:12:02,470
fingerprint who matches works works you

00:12:00,400 --> 00:12:05,980
might want to say only Alice's

00:12:02,470 --> 00:12:08,140
fingerprint or only Bob's fingerprint so

00:12:05,980 --> 00:12:10,240
that's this policy reference and of

00:12:08,140 --> 00:12:13,060
course because you can have four terms

00:12:10,240 --> 00:12:15,400
you can say well Alice's authorized with

00:12:13,060 --> 00:12:19,300
just her fingerprint Bob needs a

00:12:15,400 --> 00:12:21,540
fingerprint and a password something

00:12:19,300 --> 00:12:24,250
like that

00:12:21,540 --> 00:12:27,490
authorization from a help desk or

00:12:24,250 --> 00:12:29,560
customer support so supposing a help

00:12:27,490 --> 00:12:32,230
desk want to do something on your system

00:12:29,560 --> 00:12:34,570
so they can or give you privilege to do

00:12:32,230 --> 00:12:36,640
something honest on your system they can

00:12:34,570 --> 00:12:39,580
give you a digital signature over at

00:12:36,640 --> 00:12:43,480
their IT support department to permit

00:12:39,580 --> 00:12:45,460
you to do something delegating your key

00:12:43,480 --> 00:12:48,190
during your absence so you might be able

00:12:45,460 --> 00:12:50,170
to use your key with password but you

00:12:48,190 --> 00:12:52,120
might give a signed authorization to

00:12:50,170 --> 00:12:55,240
someone to someone else to use it with

00:12:52,120 --> 00:12:57,360
their password just while you're at

00:12:55,240 --> 00:13:00,449
lunch

00:12:57,360 --> 00:13:03,129
firmware update is a typical example of

00:13:00,449 --> 00:13:05,440
how you would sign certain command

00:13:03,129 --> 00:13:09,610
parameters so supposing of a platform

00:13:05,440 --> 00:13:12,370
and you say I want to permit a firmware

00:13:09,610 --> 00:13:14,500
update but only this particular firmware

00:13:12,370 --> 00:13:17,259
update so then you would you would sign

00:13:14,500 --> 00:13:21,339
that I say a hash of that firmware

00:13:17,259 --> 00:13:25,540
update policy secret is a level of

00:13:21,339 --> 00:13:28,029
indirection this says you're not using

00:13:25,540 --> 00:13:31,420
the password tied to this entity you're

00:13:28,029 --> 00:13:35,050
using a password that's contained in

00:13:31,420 --> 00:13:39,160
some other entity a typical use case of

00:13:35,050 --> 00:13:41,829
this you would put the password as the

00:13:39,160 --> 00:13:43,959
password of an NV index and you would

00:13:41,829 --> 00:13:45,550
tell all of your keys don't don't use

00:13:43,959 --> 00:13:47,620
the key don't use the password

00:13:45,550 --> 00:13:52,480
associated with this key use the

00:13:47,620 --> 00:13:54,009
password that's in this NV index it

00:13:52,480 --> 00:13:57,040
permits you to have one password

00:13:54,009 --> 00:13:59,740
controlling a bunch of keys it also

00:13:57,040 --> 00:14:02,430
allows you to change the password for

00:13:59,740 --> 00:14:05,949
all these keys by changing one location

00:14:02,430 --> 00:14:08,290
and then you can also have have multiple

00:14:05,949 --> 00:14:12,509
users so you can say ok I need this

00:14:08,290 --> 00:14:16,360
password plus this other password a

00:14:12,509 --> 00:14:19,120
command parameter hash hopefully will

00:14:16,360 --> 00:14:23,740
seem totally useless to all of you this

00:14:19,120 --> 00:14:26,860
is a policy that says you can only use

00:14:23,740 --> 00:14:29,470
certain parameters so you can say I have

00:14:26,860 --> 00:14:32,800
a policy that for this key that can only

00:14:29,470 --> 00:14:36,880
sign a particular hash or I can only

00:14:32,800 --> 00:14:40,300
write a 42 to that NV index it seems

00:14:36,880 --> 00:14:42,339
totally useless I'm telling you that

00:14:40,300 --> 00:14:44,339
because obviously in a few slides you'll

00:14:42,339 --> 00:14:48,970
see that it's not useless

00:14:44,339 --> 00:14:53,949
policy PCR is perhaps the only one that

00:14:48,970 --> 00:14:57,459
is TPM specific this is what was in in

00:14:53,949 --> 00:15:01,029
1.2 they called sealing - PC arse and

00:14:57,459 --> 00:15:05,860
the idea is that you can only use this

00:15:01,029 --> 00:15:08,300
key or this entity or whatever if the

00:15:05,860 --> 00:15:10,730
PCRs are in a certain value

00:15:08,300 --> 00:15:12,560
if there is a if the software is in a

00:15:10,730 --> 00:15:16,610
certain state and you can put a

00:15:12,560 --> 00:15:21,110
selection of PCRs you can say pcr 0 1 2

00:15:16,610 --> 00:15:27,740
& 7 and you specify what digest is

00:15:21,110 --> 00:15:34,580
allowed policy and V so in policy secret

00:15:27,740 --> 00:15:36,980
the this the value was the password for

00:15:34,580 --> 00:15:39,770
the env index here the value was the

00:15:36,980 --> 00:15:41,780
data in an NV index and you can do

00:15:39,770 --> 00:15:44,560
compares you can do greater than less

00:15:41,780 --> 00:15:48,470
than equal to not equal bitwise

00:15:44,560 --> 00:15:51,920
operations typical use cases for this

00:15:48,470 --> 00:15:55,330
you can do key replications so you can

00:15:51,920 --> 00:15:57,680
have an NV index that's monotonically

00:15:55,330 --> 00:16:00,920
increasing and you can say I'm

00:15:57,680 --> 00:16:05,030
authorizing this set of keys until a

00:16:00,920 --> 00:16:07,970
certain value is exceeded and that that

00:16:05,030 --> 00:16:13,480
revokes the key for everyone because we

00:16:07,970 --> 00:16:17,510
have bitwise operations you can create a

00:16:13,480 --> 00:16:21,650
monotonic bitmap index and if you have

00:16:17,510 --> 00:16:30,220
64 bits you can do individual revocation

00:16:21,650 --> 00:16:33,260
for each of 64 people entities whatever

00:16:30,220 --> 00:16:35,750
you can create an NV index that looks

00:16:33,260 --> 00:16:40,430
like a PCR in that it can extend and

00:16:35,750 --> 00:16:42,200
this gives you a PCR that perhaps has a

00:16:40,430 --> 00:16:45,110
different hash algorithm than your

00:16:42,200 --> 00:16:48,410
default or perhaps it has it requires

00:16:45,110 --> 00:16:50,960
its own authorisation you can put a

00:16:48,410 --> 00:16:54,500
password in env index and say you know

00:16:50,960 --> 00:16:56,210
is the password equal to this and then

00:16:54,500 --> 00:16:59,210
you can do an terms so you can have a

00:16:56,210 --> 00:17:03,050
range so you can say the count is

00:16:59,210 --> 00:17:07,910
greater than 3 and less than 15 so you

00:17:03,050 --> 00:17:12,050
can do ranges as well env written this

00:17:07,910 --> 00:17:14,540
this one is kind of subtle I think you

00:17:12,050 --> 00:17:17,180
can have a policy for the first right

00:17:14,540 --> 00:17:19,400
before an index is written and then you

00:17:17,180 --> 00:17:20,889
can have another policy for subsequent

00:17:19,400 --> 00:17:24,059
right

00:17:20,889 --> 00:17:27,939
and you would do that in our terms a

00:17:24,059 --> 00:17:29,950
typical use of this is that if you have

00:17:27,939 --> 00:17:33,159
some certain privileged application

00:17:29,950 --> 00:17:35,590
that's going to do the first right when

00:17:33,159 --> 00:17:41,679
you re later you can be assured that

00:17:35,590 --> 00:17:44,320
that privileged user initialized the

00:17:41,679 --> 00:17:46,929
index it prevents what we call a

00:17:44,320 --> 00:17:50,529
redefine attack where if you have an

00:17:46,929 --> 00:17:52,690
index that you that you trust someone

00:17:50,529 --> 00:17:55,899
could try to attack it by deleting the

00:17:52,690 --> 00:17:58,299
index and recreating the same index with

00:17:55,899 --> 00:17:59,889
a new with their own password instead of

00:17:58,299 --> 00:18:03,999
the password that should be there

00:17:59,889 --> 00:18:05,859
well that fails in this case because yes

00:18:03,999 --> 00:18:07,539
they can do the delete they can create

00:18:05,859 --> 00:18:09,840
the new index with their own password

00:18:07,539 --> 00:18:12,970
but they can't do that first right

00:18:09,840 --> 00:18:15,159
because they don't have the privilege to

00:18:12,970 --> 00:18:16,749
do that first right and because they

00:18:15,159 --> 00:18:21,700
can't do the first right they can't do

00:18:16,749 --> 00:18:24,759
subsequent rights counter timer if you

00:18:21,700 --> 00:18:27,429
have a system that has a clock a clock

00:18:24,759 --> 00:18:31,960
in this terminology is something that's

00:18:27,429 --> 00:18:34,480
power that's time powered time running

00:18:31,960 --> 00:18:37,419
when power is on let me try that again

00:18:34,480 --> 00:18:41,259
a clock that runs when power is on so

00:18:37,419 --> 00:18:43,929
it's wall time or time in this sense is

00:18:41,259 --> 00:18:46,269
time since a reboot and you can have

00:18:43,929 --> 00:18:50,249
policies that are linked to those two

00:18:46,269 --> 00:18:53,200
times or reboot count typical use cases

00:18:50,249 --> 00:18:54,850
if you have a service technician doing

00:18:53,200 --> 00:18:57,639
something on the system you might want

00:18:54,850 --> 00:18:59,409
to give them privilege but you want to

00:18:57,639 --> 00:19:00,820
make sure that when they walk out the

00:18:59,409 --> 00:19:05,080
door they don't still have that

00:19:00,820 --> 00:19:09,129
privilege so if you lock the the entity

00:19:05,080 --> 00:19:10,919
to a reboot count then they walk out you

00:19:09,129 --> 00:19:12,850
reboot the system and whatever

00:19:10,919 --> 00:19:13,840
authorizations that you gave them are

00:19:12,850 --> 00:19:16,059
gone

00:19:13,840 --> 00:19:17,679
you can authorize until a particular

00:19:16,059 --> 00:19:21,340
date and time so you can say this is

00:19:17,679 --> 00:19:24,129
authorized until Sunday because you have

00:19:21,340 --> 00:19:25,779
or terms you can say daytime only from

00:19:24,129 --> 00:19:28,210
8:00 in the morning to 5:00 in the

00:19:25,779 --> 00:19:32,820
afternoon or you could say only on

00:19:28,210 --> 00:19:32,820
weekdays none on the weekends etc

00:19:33,080 --> 00:19:40,730
so some of the issues some of the above

00:19:37,400 --> 00:19:43,370
use cases require the policies to be

00:19:40,730 --> 00:19:45,980
created at runtime but you can't do that

00:19:43,370 --> 00:19:49,100
an entity once you create an entity with

00:19:45,980 --> 00:19:51,890
a password that's it there's no change

00:19:49,100 --> 00:19:53,900
the policy there's no change the policy

00:19:51,890 --> 00:19:57,620
command and the reason for that is you

00:19:53,900 --> 00:19:59,600
might want to certify a key including

00:19:57,620 --> 00:20:01,580
its policy and after you certify you

00:19:59,600 --> 00:20:04,430
don't want that policy to change and

00:20:01,580 --> 00:20:08,630
then we have these totally useless

00:20:04,430 --> 00:20:13,730
policies like writing specific data to

00:20:08,630 --> 00:20:16,310
an index signing a digest for the people

00:20:13,730 --> 00:20:19,520
in the TPM world there was this issue of

00:20:16,310 --> 00:20:22,130
what we called PCR brittleness where you

00:20:19,520 --> 00:20:24,440
seal something to PCRs Paul talked about

00:20:22,130 --> 00:20:27,680
this yesterday you seal something to

00:20:24,440 --> 00:20:30,710
PCRs and then your your pre OS firmware

00:20:27,680 --> 00:20:36,110
changes and all of a sudden the the

00:20:30,710 --> 00:20:38,840
unsealed breaks in the 1.2 world the way

00:20:36,110 --> 00:20:40,940
this was worked around was you had to

00:20:38,840 --> 00:20:43,850
read the secret all the way up at the

00:20:40,940 --> 00:20:46,010
application level and then you had to

00:20:43,850 --> 00:20:50,030
reseal it to new PC ours and then you

00:20:46,010 --> 00:20:53,390
have the problem of well what are the

00:20:50,030 --> 00:20:54,890
trusted PCR values is it is it just what

00:20:53,390 --> 00:20:58,510
I happened to be running - I trust

00:20:54,890 --> 00:21:03,140
whatever's running on my system now

00:20:58,510 --> 00:21:05,630
wasn't very nice but as in all software

00:21:03,140 --> 00:21:09,050
we solve it by a level of indirection

00:21:05,630 --> 00:21:14,840
and the command is called policy

00:21:09,050 --> 00:21:18,230
authorize in words it says the policy

00:21:14,840 --> 00:21:22,040
has a public key and the entity is

00:21:18,230 --> 00:21:26,570
authorized by whatever the authorizing

00:21:22,040 --> 00:21:29,830
private key says is valid so the

00:21:26,570 --> 00:21:33,200
authorizing key signs of policy and

00:21:29,830 --> 00:21:37,340
whatever the authorizing entity signs

00:21:33,200 --> 00:21:40,310
that's the correct policy in a flowchart

00:21:37,340 --> 00:21:42,590
it works like this so an entity has a

00:21:40,310 --> 00:21:45,799
policies I just just like before a

00:21:42,590 --> 00:21:49,640
single hash in this case the

00:21:45,799 --> 00:21:52,960
is the hash of the authorizing entities

00:21:49,640 --> 00:21:57,860
public key so it's represented here by P

00:21:52,960 --> 00:22:00,530
now in use the authorizing entity who

00:21:57,860 --> 00:22:05,660
has the private key calculates a session

00:22:00,530 --> 00:22:07,730
digest that they trust they sign that

00:22:05,660 --> 00:22:10,669
session digest with their private key

00:22:07,730 --> 00:22:12,799
and they send it over to the user now

00:22:10,669 --> 00:22:14,900
what the user does is as before they run

00:22:12,799 --> 00:22:17,659
their policy commands and they get the

00:22:14,900 --> 00:22:21,860
session digest s at that point they

00:22:17,659 --> 00:22:25,010
apply the policy authorized if so the

00:22:21,860 --> 00:22:27,679
the device now has the public key it has

00:22:25,010 --> 00:22:31,520
the signature and internally in the

00:22:27,679 --> 00:22:33,530
session it has the the digest so we can

00:22:31,520 --> 00:22:36,409
do a signature verification if

00:22:33,530 --> 00:22:40,600
everything matches it replaces the

00:22:36,409 --> 00:22:44,780
session digest with this value P P P and

00:22:40,600 --> 00:22:47,270
you're good to go and of course good to

00:22:44,780 --> 00:22:49,520
go means maybe you're ready to authorize

00:22:47,270 --> 00:22:52,700
or you can have more in terms after that

00:22:49,520 --> 00:22:56,570
so how does how does it solve some of

00:22:52,700 --> 00:22:58,900
these weird things so writing fixed data

00:22:56,570 --> 00:23:02,890
to an env index doesn't work very well

00:22:58,900 --> 00:23:05,720
but I know of a use case where a

00:23:02,890 --> 00:23:08,179
platform and and this is I guess very

00:23:05,720 --> 00:23:10,159
common in big systems a platform is

00:23:08,179 --> 00:23:13,610
shipped with huge amounts of memory and

00:23:10,159 --> 00:23:17,150
lots of CPUs and then the user can buy

00:23:13,610 --> 00:23:21,230
for a certain amount of time use of five

00:23:17,150 --> 00:23:23,929
CPUs and then if there's a crunch where

00:23:21,230 --> 00:23:27,650
they need to use more CPUs they can

00:23:23,929 --> 00:23:31,490
purchase more CPUs so the way that would

00:23:27,650 --> 00:23:35,600
work here is the authorizer is whoever

00:23:31,490 --> 00:23:40,280
you're purchasing this the CPUs usage

00:23:35,600 --> 00:23:43,070
usage from they go you pay them they

00:23:40,280 --> 00:23:47,150
sign an authorization to update the NV

00:23:43,070 --> 00:23:51,049
index which holds your how many CPUs you

00:23:47,150 --> 00:23:53,299
can use they sign an authorization to

00:23:51,049 --> 00:23:57,750
update that index that says yes I can

00:23:53,299 --> 00:24:00,240
now use 12 CPUs for the next week

00:23:57,750 --> 00:24:01,830
and then you you run all your policy

00:24:00,240 --> 00:24:06,690
commands you apply that authorization

00:24:01,830 --> 00:24:09,870
and then you can write the index signing

00:24:06,690 --> 00:24:13,020
a specific digest isn't that useful but

00:24:09,870 --> 00:24:15,630
in this case you can go off to the

00:24:13,020 --> 00:24:18,330
authorizing entity and you can say I

00:24:15,630 --> 00:24:21,330
want to sign a particular digest the

00:24:18,330 --> 00:24:23,490
authorizing entity would say ok and send

00:24:21,330 --> 00:24:25,830
the authorization back to you I think

00:24:23,490 --> 00:24:28,590
this of this is kind of counter signing

00:24:25,830 --> 00:24:30,270
like if you go and get a bank check the

00:24:28,590 --> 00:24:32,100
teller might sign the bank check and

00:24:30,270 --> 00:24:34,020
then they need to go off and get the

00:24:32,100 --> 00:24:36,060
bank manager's signature if it's over a

00:24:34,020 --> 00:24:37,620
certain amount or maybe if it's not over

00:24:36,060 --> 00:24:41,190
a certain amount well this would be the

00:24:37,620 --> 00:24:44,460
same thing maybe you're a software

00:24:41,190 --> 00:24:46,350
development group and you have you have

00:24:44,460 --> 00:24:49,230
some new firmware and you want to sign

00:24:46,350 --> 00:24:52,740
that firmware hash but in order to sign

00:24:49,230 --> 00:24:55,080
the firmware hash you need authorization

00:24:52,740 --> 00:24:57,450
from management or authorization from

00:24:55,080 --> 00:24:59,250
your quality control group so it's kind

00:24:57,450 --> 00:25:02,390
of a counter counter signing you need

00:24:59,250 --> 00:25:07,620
one signer to approve the other signer

00:25:02,390 --> 00:25:10,230
and then in PCRs this is a way to solve

00:25:07,620 --> 00:25:13,830
the PCR brittleness problem what happens

00:25:10,230 --> 00:25:17,730
here is say you're a platform vendor or

00:25:13,830 --> 00:25:21,450
or a firmware vendor you have firmware

00:25:17,730 --> 00:25:24,300
that you know is is good you sign an

00:25:21,450 --> 00:25:26,670
authorization that says this is good

00:25:24,300 --> 00:25:28,920
firmware and you distribute it out to

00:25:26,670 --> 00:25:31,500
out to all the users of your platform

00:25:28,920 --> 00:25:34,680
and now when they want unseal they're

00:25:31,500 --> 00:25:37,230
not unsealing to specific PCRs that are

00:25:34,680 --> 00:25:39,990
set in the policy they're unsealing to

00:25:37,230 --> 00:25:43,800
whatever the platform manufacturer says

00:25:39,990 --> 00:25:46,770
our goods PCRs or whatever your IT

00:25:43,800 --> 00:25:48,660
department says their good pc ours so it

00:25:46,770 --> 00:25:50,430
solves the PCR brittleness problem

00:25:48,660 --> 00:25:55,710
without having to go through this unseal

00:25:50,430 --> 00:25:58,230
and reseal it also says you can do

00:25:55,710 --> 00:25:59,490
better than saying what is authorizes

00:25:58,230 --> 00:26:00,300
whatever I happened to have in my

00:25:59,490 --> 00:26:03,300
platform

00:26:00,300 --> 00:26:05,820
now what's authorized is what the

00:26:03,300 --> 00:26:08,010
software vendor says is authorized or

00:26:05,820 --> 00:26:10,520
what your IT department says is

00:26:08,010 --> 00:26:10,520
authorized

00:26:12,220 --> 00:26:18,500
one more level of indirection okay so so

00:26:15,710 --> 00:26:20,180
going back up so the problem with policy

00:26:18,500 --> 00:26:23,870
authorized is that it's linked to a

00:26:20,180 --> 00:26:26,720
public key and then at some point people

00:26:23,870 --> 00:26:28,490
came along and said well what happens if

00:26:26,720 --> 00:26:31,010
I want to change that public key what

00:26:28,490 --> 00:26:34,700
happens if the authorizer lost their

00:26:31,010 --> 00:26:36,800
private key or it expired or you're just

00:26:34,700 --> 00:26:41,360
switching to a different authorizer and

00:26:36,800 --> 00:26:43,250
you can never change a policy so later

00:26:41,360 --> 00:26:44,990
on in the design this was not in the

00:26:43,250 --> 00:26:48,410
original design but once people

00:26:44,990 --> 00:26:51,650
discovered this use case we added a new

00:26:48,410 --> 00:26:53,570
policy command and this shows an example

00:26:51,650 --> 00:26:55,640
of how you can add new policy commands

00:26:53,570 --> 00:26:58,430
and it's all backward compatible so

00:26:55,640 --> 00:27:00,200
nothing no existing software broke but

00:26:58,430 --> 00:27:02,420
if you have a device that implements

00:27:00,200 --> 00:27:05,390
this new command which is called policy

00:27:02,420 --> 00:27:07,820
authorized env then you can do

00:27:05,390 --> 00:27:12,710
additional things and what this says is

00:27:07,820 --> 00:27:17,270
that the policy is not well the policy

00:27:12,710 --> 00:27:20,210
knee in the index is not the policy the

00:27:17,270 --> 00:27:23,300
policy in the key or the policy entity

00:27:20,210 --> 00:27:26,150
is not the final policy the policy is

00:27:23,300 --> 00:27:28,490
whatever is in this envy index so it's a

00:27:26,150 --> 00:27:33,620
pointer to their actual policy in the

00:27:28,490 --> 00:27:36,910
envy index the trivially trivial use

00:27:33,620 --> 00:27:40,900
case is when you want to change a policy

00:27:36,910 --> 00:27:44,600
the very important use case is you can

00:27:40,900 --> 00:27:47,780
revoke a policy authorize public key by

00:27:44,600 --> 00:27:52,010
writing a different policy into this

00:27:47,780 --> 00:27:54,230
envy index or you of course have the

00:27:52,010 --> 00:27:56,510
issue of well what's the policy to write

00:27:54,230 --> 00:27:59,780
this in the index but that could be that

00:27:56,510 --> 00:28:02,600
could be a higher level policy so that's

00:27:59,780 --> 00:28:07,220
two use cases for policy authorized envy

00:28:02,600 --> 00:28:11,050
and to summary all this in a one dollar

00:28:07,220 --> 00:28:14,300
part which i think is pretty impressive

00:28:11,050 --> 00:28:17,360
there's only one digest per entity so

00:28:14,300 --> 00:28:20,570
for example for sha-256 it's just 32

00:28:17,360 --> 00:28:23,360
bytes and I gave you some examples of

00:28:20,570 --> 00:28:24,110
some business processes but you can go

00:28:23,360 --> 00:28:26,450
on and on

00:28:24,110 --> 00:28:30,530
as complex as you like and it's still

00:28:26,450 --> 00:28:33,740
only 32 bytes the session is opaque you

00:28:30,530 --> 00:28:37,820
don't see the int the innards of the

00:28:33,740 --> 00:28:42,200
session context from outside so if we

00:28:37,820 --> 00:28:46,340
want to add more policy commands that

00:28:42,200 --> 00:28:48,020
again is backward compatible assuming

00:28:46,340 --> 00:28:53,929
that you already have crypto in your

00:28:48,020 --> 00:28:57,020
system hashing H Mac asymmetric and

00:28:53,929 --> 00:29:00,559
symmetric key operations then it slow

00:28:57,020 --> 00:29:02,860
software overhead if you look at the TPM

00:29:00,559 --> 00:29:05,360
source code and it's all open source

00:29:02,860 --> 00:29:09,860
yeah there's a lot of crypto that's

00:29:05,360 --> 00:29:11,660
shared by other things but the the

00:29:09,860 --> 00:29:14,750
softer to do one of these policy

00:29:11,660 --> 00:29:18,290
commands is actually very small what I

00:29:14,750 --> 00:29:20,150
mean by proving usefulness is we keep

00:29:18,290 --> 00:29:23,929
coming up with more and more use cases

00:29:20,150 --> 00:29:27,350
and you know I get email from people

00:29:23,929 --> 00:29:29,299
asking me how to do use cases and except

00:29:27,350 --> 00:29:33,020
for that one level of indirection which

00:29:29,299 --> 00:29:34,940
we which we added later everything that

00:29:33,020 --> 00:29:38,120
we've wanted to do we've been able to do

00:29:34,940 --> 00:29:39,740
and that's that's a testament to the to

00:29:38,120 --> 00:29:41,330
the people who originally designed this

00:29:39,740 --> 00:29:44,390
it was not me

00:29:41,330 --> 00:29:47,059
but the fact that it's been this

00:29:44,390 --> 00:29:50,780
flexible over this many years is I think

00:29:47,059 --> 00:29:52,940
very impressive and lastly it's not as

00:29:50,780 --> 00:29:54,770
hard as I thought the I don't know what

00:29:52,940 --> 00:29:56,540
you're thinking now but the first time I

00:29:54,770 --> 00:29:58,549
saw this I thought this is really

00:29:56,540 --> 00:30:00,440
complicated nobody's going to be able to

00:29:58,549 --> 00:30:02,179
get this or it's gonna take a long time

00:30:00,440 --> 00:30:04,070
for people to get it or the thing I have

00:30:02,179 --> 00:30:06,980
to read the documentation for ever and

00:30:04,070 --> 00:30:09,320
what I'm finding through mailing lists

00:30:06,980 --> 00:30:12,290
is that people are people are really

00:30:09,320 --> 00:30:14,390
getting it people who I never heard of a

00:30:12,290 --> 00:30:16,549
lot of them seem to be graduate students

00:30:14,390 --> 00:30:18,860
or even undergraduates at university so

00:30:16,549 --> 00:30:22,010
we're starting to play with TPMS they're

00:30:18,860 --> 00:30:25,309
coming to me with policies and they

00:30:22,010 --> 00:30:29,120
understand it and you know that I really

00:30:25,309 --> 00:30:32,650
feel good about that so that's the talk

00:30:29,120 --> 00:30:32,650
ready for questions

00:30:37,510 --> 00:30:43,120
anyone someone who's not hungry

00:30:45,500 --> 00:30:54,890
so you asked two questions when you had

00:30:47,850 --> 00:30:57,420
one last time does the policy authorize

00:30:54,890 --> 00:31:02,850
have rollback protection because it's

00:30:57,420 --> 00:31:06,360
only the key that's designed ah so it

00:31:02,850 --> 00:31:08,429
can if you want to or it doesn't have to

00:31:06,360 --> 00:31:10,799
so there were those nonces on some of

00:31:08,429 --> 00:31:13,290
the previous slides I showed that there

00:31:10,799 --> 00:31:15,809
is a nonce so you can you can do a

00:31:13,290 --> 00:31:18,690
signature that says it's only good for

00:31:15,809 --> 00:31:21,630
this one session oh I should say that

00:31:18,690 --> 00:31:25,400
also a session once it's authorized can

00:31:21,630 --> 00:31:28,530
only be used once if you if you want to

00:31:25,400 --> 00:31:30,900
do something again you have to start

00:31:28,530 --> 00:31:34,860
over at zero and satisfy it again

00:31:30,900 --> 00:31:36,780
if there are no nonces you can replay if

00:31:34,860 --> 00:31:38,490
there are nonsense involved when you

00:31:36,780 --> 00:31:42,750
reset the session there's a new nonce

00:31:38,490 --> 00:31:46,820
and I think that's what you mean by anti

00:31:42,750 --> 00:31:46,820
rollback or it's not no

00:31:52,730 --> 00:31:59,370
which is which example in the example

00:31:55,590 --> 00:32:02,580
that you described where vendor pre

00:31:59,370 --> 00:32:05,480
calculating the PC R's in case of

00:32:02,580 --> 00:32:07,920
firmware update and signing those PC are

00:32:05,480 --> 00:32:10,920
expected PC are values with the vendors

00:32:07,920 --> 00:32:14,520
private key I understand okay in that

00:32:10,920 --> 00:32:17,250
example so how do you does that have an

00:32:14,520 --> 00:32:19,020
element of basically versioning and to

00:32:17,250 --> 00:32:22,080
give the rollback protection okay so

00:32:19,020 --> 00:32:24,600
there is not I'll give you to it okay

00:32:22,080 --> 00:32:28,590
you you will we allow you to questions

00:32:24,600 --> 00:32:32,850
you have to allow me to answers so so

00:32:28,590 --> 00:32:35,670
the first answer is by itself there's no

00:32:32,850 --> 00:32:40,880
anti rollback but you can do things with

00:32:35,670 --> 00:32:44,640
say counters so you can say the policy

00:32:40,880 --> 00:32:47,490
says the policy that I'm authorizes

00:32:44,640 --> 00:32:51,660
sayings it says that the counter has to

00:32:47,490 --> 00:32:53,880
be less than three and greater than

00:32:51,660 --> 00:32:56,820
three so you so you start less than

00:32:53,880 --> 00:32:59,720
three you run the the policy command and

00:32:56,820 --> 00:33:02,760
then you increment to greater than 3 and

00:32:59,720 --> 00:33:04,410
it's satisfied but you can't use it

00:33:02,760 --> 00:33:06,510
again because once it's greater than

00:33:04,410 --> 00:33:09,990
three you can't get to less than three

00:33:06,510 --> 00:33:13,260
again so by itself there's no anti

00:33:09,990 --> 00:33:15,780
rollback but in combination like I said

00:33:13,260 --> 00:33:17,100
there's so much here that you can find a

00:33:15,780 --> 00:33:19,350
way to do things and that's the way you

00:33:17,100 --> 00:33:21,600
would do it so that's one answer the

00:33:19,350 --> 00:33:23,640
other answer is and when I first went to

00:33:21,600 --> 00:33:27,660
operating divisions and talked about

00:33:23,640 --> 00:33:31,770
this they just get in a cold sweat when

00:33:27,660 --> 00:33:34,980
they hear about no rollback because in a

00:33:31,770 --> 00:33:37,290
lot of places in the real world if you

00:33:34,980 --> 00:33:39,480
do some kind of firmware update and it

00:33:37,290 --> 00:33:41,550
doesn't work the people that are looking

00:33:39,480 --> 00:33:44,040
over your shoulder the first thing

00:33:41,550 --> 00:33:46,860
they're gonna say is I don't want you to

00:33:44,040 --> 00:33:48,990
debug it put it back the way it was get

00:33:46,860 --> 00:33:51,930
me back up and running and then go back

00:33:48,990 --> 00:33:54,390
home and figure out what went wrong ok

00:33:51,930 --> 00:33:56,010
so that's the two answers is yes you can

00:33:54,390 --> 00:33:57,780
do it in combination with these

00:33:56,010 --> 00:34:01,350
monotonic counters and there's probably

00:33:57,780 --> 00:34:03,240
other ways to do it as well whether you

00:34:01,350 --> 00:34:04,860
want to do it well

00:34:03,240 --> 00:34:07,050
you have talked to the people that are

00:34:04,860 --> 00:34:09,750
you know maintaining your systems you

00:34:07,050 --> 00:34:17,639
might not want them to or they might not

00:34:09,750 --> 00:34:19,530
want you to more questions so how do you

00:34:17,639 --> 00:34:24,119
create these policies I mean is there

00:34:19,530 --> 00:34:29,879
some tools or oh great question will you

00:34:24,119 --> 00:34:36,540
allow me three answers so so one if I

00:34:29,879 --> 00:34:38,760
can go way back here so when you start

00:34:36,540 --> 00:34:40,500
this session it starts off at zero and

00:34:38,760 --> 00:34:43,440
then as you send in these policy

00:34:40,500 --> 00:34:46,919
commands it updates there's a feature in

00:34:43,440 --> 00:34:49,830
the TPM that's called a trial policy and

00:34:46,919 --> 00:34:52,649
what the trial policy says is two things

00:34:49,830 --> 00:34:54,659
first all of these policy commands that

00:34:52,649 --> 00:34:57,149
comes in or not are not validated

00:34:54,659 --> 00:34:59,070
they're just trusted to be good so no

00:34:57,149 --> 00:35:02,460
signatures are check no pastors are

00:34:59,070 --> 00:35:05,640
check nothing but you can't use that

00:35:02,460 --> 00:35:08,130
policy that session at the end for

00:35:05,640 --> 00:35:10,859
authorization so you can actually use

00:35:08,130 --> 00:35:15,540
the TPM to calculate the policies and

00:35:10,859 --> 00:35:18,210
I've seen that I also have some very

00:35:15,540 --> 00:35:22,410
primitive tools where you're just cut

00:35:18,210 --> 00:35:25,859
and pasting hex ASCII they're not very

00:35:22,410 --> 00:35:27,330
good but people are actually using them

00:35:25,859 --> 00:35:33,090
I'm shocked that people are actually

00:35:27,330 --> 00:35:37,730
using them now in the TCG they have this

00:35:33,090 --> 00:35:41,220
vision of using JSON I was originally

00:35:37,730 --> 00:35:43,680
XML and I think it's JSON where you

00:35:41,220 --> 00:35:46,590
specify the policies in Jason there's

00:35:43,680 --> 00:35:50,220
somewhat human readable and then you

00:35:46,590 --> 00:35:55,050
have a tool to take that JSON and turn

00:35:50,220 --> 00:35:57,720
them into a hash it will be nice if

00:35:55,050 --> 00:35:59,760
there are tools to generate the JSON if

00:35:57,720 --> 00:36:02,340
you have to generate the JSON by hand

00:35:59,760 --> 00:36:04,530
I'm not sure that it's any better or

00:36:02,340 --> 00:36:08,940
much better than the really primitive

00:36:04,530 --> 00:36:12,300
tools that I open-source but if there

00:36:08,940 --> 00:36:15,750
are eventually GUI tools to generate

00:36:12,300 --> 00:36:16,500
that JSON that will be terrific

00:36:15,750 --> 00:36:19,710
the

00:36:16,500 --> 00:36:21,930
other thing about that JSON for better

00:36:19,710 --> 00:36:24,540
and it may or may not be useful we'll

00:36:21,930 --> 00:36:28,830
have to see is that you can imagine once

00:36:24,540 --> 00:36:31,650
you have the policy expressed in JSON

00:36:28,830 --> 00:36:34,890
it's not only good for calculating the

00:36:31,650 --> 00:36:37,140
policies but it's good at runtime where

00:36:34,890 --> 00:36:39,870
your software say suppose you have three

00:36:37,140 --> 00:36:42,270
policy or terms well your software can

00:36:39,870 --> 00:36:44,490
present to the user and say which of

00:36:42,270 --> 00:36:47,430
these three do you want me the software

00:36:44,490 --> 00:36:50,640
to satisfy and the user can say well I

00:36:47,430 --> 00:36:54,990
pick a policy B and it can run through

00:36:50,640 --> 00:36:58,380
that so that might be a very useful use

00:36:54,990 --> 00:37:01,350
of JSON what I've seen so far in these

00:36:58,380 --> 00:37:03,180
or terms is that the business logic for

00:37:01,350 --> 00:37:05,400
the software already knows what it's

00:37:03,180 --> 00:37:08,640
trying to do it doesn't have to come

00:37:05,400 --> 00:37:10,590
back to the user and say that but that

00:37:08,640 --> 00:37:13,260
doesn't mean that it won't be useful in

00:37:10,590 --> 00:37:15,600
the future if we there might be use

00:37:13,260 --> 00:37:17,850
cases where the business logic has a

00:37:15,600 --> 00:37:20,130
bunch of choices that it can do and

00:37:17,850 --> 00:37:22,380
remember you can have ores of wars of

00:37:20,130 --> 00:37:25,770
ores and in that case the JSON might

00:37:22,380 --> 00:37:27,660
turn out to be very useful so did that

00:37:25,770 --> 00:37:32,070
kind of answer your question three times

00:37:27,660 --> 00:37:34,200
yeah okay and you know by the way I

00:37:32,070 --> 00:37:41,520
don't know how we're doing on time but

00:37:34,200 --> 00:37:44,580
I'm here all day today and tomorrow it's

00:37:41,520 --> 00:37:50,340
we write on much time so oh okay

00:37:44,580 --> 00:37:52,550
no questions okay thanks Kim thank you

00:37:50,340 --> 00:37:52,550

YouTube URL: https://www.youtube.com/watch?v=rI9f5vrvIc8


