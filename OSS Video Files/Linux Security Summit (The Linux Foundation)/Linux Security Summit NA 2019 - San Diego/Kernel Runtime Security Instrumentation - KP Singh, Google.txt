Title: Kernel Runtime Security Instrumentation - KP Singh, Google
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Kernel Runtime Security Instrumentation - KP Singh, Google 

Kernel Runtime Security Instrumentation (KRSI) [1] aims to provide an extensible Linux Security Module (LSM) by allowing userspace programs and system owners to attach eBPF (extended Berkeley Packet Filter) programs to security hooks. This makes the LSM framework extensible without needing to rebuild/re-write and enables a new class of security and auditing software.The talk discusses the need for such an LSM (with representative use cases) and compares it to some existing alternatives, such as Landlock, a separate custom LSM, kprobes+eBPF etc. The second half of the talk outlines the proposed design and interfaces, and includes a live demo.[1] https://github.com/sinkap/linux-krsi
Captions: 
	00:00:00,089 --> 00:00:04,710
so the next talk before lunch is KP

00:00:03,030 --> 00:00:07,470
Singh is going to be talking about the

00:00:04,710 --> 00:00:09,870
kernel runtime security instrumentation

00:00:07,470 --> 00:00:11,519
thank you James I couldn't have asked

00:00:09,870 --> 00:00:13,620
for a better segue into my talk than the

00:00:11,519 --> 00:00:16,890
previous question so amazing

00:00:13,620 --> 00:00:20,279
I'm KP I work in Google in Switzerland

00:00:16,890 --> 00:00:22,140
and on detection and response and I'm

00:00:20,279 --> 00:00:24,720
going to talk on kernel runtime security

00:00:22,140 --> 00:00:27,599
instrumentation we're gonna talk about

00:00:24,720 --> 00:00:29,340
why we're doing this then we go into

00:00:27,599 --> 00:00:31,439
like how does it actually work

00:00:29,340 --> 00:00:33,390
also the alternatives that exists right

00:00:31,439 --> 00:00:35,610
now we're going to do a little case

00:00:33,390 --> 00:00:38,700
study on based on some of the prototype

00:00:35,610 --> 00:00:39,750
work we've done I have added bonus we

00:00:38,700 --> 00:00:41,969
are going to have a performance

00:00:39,750 --> 00:00:43,710
comparison it's not really a true

00:00:41,969 --> 00:00:46,200
comparison study at this point because

00:00:43,710 --> 00:00:47,399
this thing is in prototype stage but we

00:00:46,200 --> 00:00:48,930
want to figure out whether we should

00:00:47,399 --> 00:00:50,760
actually be doing this in the first

00:00:48,930 --> 00:00:53,760
place or not we're going to do a small

00:00:50,760 --> 00:00:55,530
demo and beware of Murphy's Law and

00:00:53,760 --> 00:00:59,760
we're going to throw away some design

00:00:55,530 --> 00:01:01,559
questions to the community here before I

00:00:59,760 --> 00:01:02,930
start and if I run out of time thank you

00:01:01,559 --> 00:01:06,570
to everyone who contributed to that

00:01:02,930 --> 00:01:10,020
really really appreciated some

00:01:06,570 --> 00:01:11,790
motivation and before motivation I'm

00:01:10,020 --> 00:01:13,590
going to classify security into two

00:01:11,790 --> 00:01:17,040
different aspects the first aspect is

00:01:13,590 --> 00:01:19,799
signaling which is really important it

00:01:17,040 --> 00:01:22,619
bits of information that are not

00:01:19,799 --> 00:01:25,049
necessarily all bad later later like

00:01:22,619 --> 00:01:27,390
malicious activity but they they could

00:01:25,049 --> 00:01:30,210
they could imply maliciousness happening

00:01:27,390 --> 00:01:31,799
on the system and the next part is

00:01:30,210 --> 00:01:33,920
mitigation when you use those signals

00:01:31,799 --> 00:01:36,720
and prevent something bad from happening

00:01:33,920 --> 00:01:38,369
signals also from the product context

00:01:36,720 --> 00:01:40,320
when you detect something bad you want

00:01:38,369 --> 00:01:42,659
more context into that what was going

00:01:40,320 --> 00:01:45,329
wrong and that's where signals also come

00:01:42,659 --> 00:01:48,270
in so these two aspects of security are

00:01:45,329 --> 00:01:51,869
like or how signals and mitigation go

00:01:48,270 --> 00:01:55,560
hand-in-hand here how do we do signals

00:01:51,869 --> 00:01:58,259
and medication right now in in like the

00:01:55,560 --> 00:01:59,880
next land and I'm going to discuss with

00:01:58,259 --> 00:02:01,920
this little thing here like what what

00:01:59,880 --> 00:02:04,380
are the issues we have so let's say I

00:02:01,920 --> 00:02:07,350
want to update the audit subsystem to

00:02:04,380 --> 00:02:10,470
log environment variables right I

00:02:07,350 --> 00:02:13,730
changed the kernel code I changed the

00:02:10,470 --> 00:02:17,329
policy language I changed the user space

00:02:13,730 --> 00:02:19,370
I changed like the you update your user

00:02:17,329 --> 00:02:21,409
space application that builds on top of

00:02:19,370 --> 00:02:23,359
your audit stuff and then you change

00:02:21,409 --> 00:02:25,639
your pipeline that is digesting all this

00:02:23,359 --> 00:02:27,650
audit information to figure out if

00:02:25,639 --> 00:02:30,049
something bad is happening there and

00:02:27,650 --> 00:02:32,900
then you realize oh something is really

00:02:30,049 --> 00:02:35,180
bad let's say there's pelipper political

00:02:32,900 --> 00:02:37,430
particular malicious actor that has a

00:02:35,180 --> 00:02:40,099
certain LD preload signature and now you

00:02:37,430 --> 00:02:42,590
want to update the LS m the mitigation

00:02:40,099 --> 00:02:45,950
is kind of disjoined at the stage from

00:02:42,590 --> 00:02:47,989
the signaling aspect so you go you open

00:02:45,950 --> 00:02:50,540
up the LS m you update the policy

00:02:47,989 --> 00:02:52,969
language for say SELinux or a palmer you

00:02:50,540 --> 00:02:53,569
add detection or mitigation logic to

00:02:52,969 --> 00:02:56,060
seccomp

00:02:53,569 --> 00:02:58,010
and by that time the vulnerability is

00:02:56,060 --> 00:03:00,409
already moved on and you you're behind

00:02:58,010 --> 00:03:03,370
you're one step behind in this case so

00:03:00,409 --> 00:03:05,900
that's the primary motivation of why

00:03:03,370 --> 00:03:07,819
it's actually to make the signaling and

00:03:05,900 --> 00:03:11,989
mitigation go better well work well

00:03:07,819 --> 00:03:13,400
together I'm also going to talk about

00:03:11,989 --> 00:03:17,060
other signals than just environment

00:03:13,400 --> 00:03:18,979
variables so think of a process that

00:03:17,060 --> 00:03:20,659
executes and deletes its own executable

00:03:18,979 --> 00:03:23,239
right like that's a signal that you get

00:03:20,659 --> 00:03:25,009
you could do people do that when I'm

00:03:23,239 --> 00:03:26,629
working on my workstation I could I

00:03:25,009 --> 00:03:28,759
could do that just just remove that

00:03:26,629 --> 00:03:30,590
stuff it doesn't mean that I mean it

00:03:28,759 --> 00:03:33,680
doesn't imply that I mean harm to the

00:03:30,590 --> 00:03:34,970
system or the organization but it could

00:03:33,680 --> 00:03:37,729
be an indicator of something bad

00:03:34,970 --> 00:03:39,709
happening on the system another system

00:03:37,729 --> 00:03:41,180
another signal this looks really shady

00:03:39,709 --> 00:03:42,739
though like a kernel module that just

00:03:41,180 --> 00:03:44,659
loads itself and then hides itself from

00:03:42,739 --> 00:03:47,599
proc modules or whatever why would

00:03:44,659 --> 00:03:49,790
anyone do that well you need to figure

00:03:47,599 --> 00:03:52,400
out why and then you if there is a

00:03:49,790 --> 00:03:55,849
concrete evidence that this is bad stop

00:03:52,400 --> 00:03:57,409
it from happening and we talked about

00:03:55,849 --> 00:03:58,849
the other signal as well that is

00:03:57,409 --> 00:04:00,829
suspicious environment variables right

00:03:58,849 --> 00:04:02,859
LD preload setting hist file size and

00:04:00,829 --> 00:04:05,659
then like doing something bad with that

00:04:02,859 --> 00:04:07,189
not necessarily bad stuff but could

00:04:05,659 --> 00:04:10,549
indicate something bad happening on the

00:04:07,189 --> 00:04:13,340
system I'm going to talk about

00:04:10,549 --> 00:04:14,900
medications these medications could some

00:04:13,340 --> 00:04:16,459
are applicable to servers some are

00:04:14,900 --> 00:04:20,419
applicable to port data centers and

00:04:16,459 --> 00:04:23,719
servers so it sometimes is you shouldn't

00:04:20,419 --> 00:04:25,820
be mounting USB drives on servers maybe

00:04:23,719 --> 00:04:26,540
you want to whitelist at some point some

00:04:25,820 --> 00:04:28,580
USB try

00:04:26,540 --> 00:04:30,950
to be mounted maybe you want to block

00:04:28,580 --> 00:04:32,770
dynamically after certain point that's

00:04:30,950 --> 00:04:35,540
one of the medications that you could do

00:04:32,770 --> 00:04:37,670
you want to have a dynamic white list of

00:04:35,540 --> 00:04:39,080
known kernel modules so like you know

00:04:37,670 --> 00:04:40,250
all the hashes for all the kernel

00:04:39,080 --> 00:04:41,960
modules that you want to allow it to

00:04:40,250 --> 00:04:44,450
load on the system this is more relevant

00:04:41,960 --> 00:04:46,190
for data center stuff and most developer

00:04:44,450 --> 00:04:48,500
audiences also don't really compile

00:04:46,190 --> 00:04:50,000
curtain modules on the system I would

00:04:48,500 --> 00:04:53,390
like I would not like this to happen on

00:04:50,000 --> 00:04:55,250
my workstation but again like you would

00:04:53,390 --> 00:05:00,020
want this to happen in a broader broader

00:04:55,250 --> 00:05:01,700
fleet of production stuff and this is

00:05:00,020 --> 00:05:03,350
this is an interesting use case like you

00:05:01,700 --> 00:05:05,690
want to prevent known vulnerable

00:05:03,350 --> 00:05:07,220
binaries from running like let's say you

00:05:05,690 --> 00:05:09,770
you you realize that there is a

00:05:07,220 --> 00:05:11,180
vulnerability right Lee was the operator

00:05:09,770 --> 00:05:13,160
or somebody who deploys the operating

00:05:11,180 --> 00:05:15,230
system to your organization you realize

00:05:13,160 --> 00:05:17,780
that yeah these this core library has

00:05:15,230 --> 00:05:20,720
some vulnerability now you want to ask

00:05:17,780 --> 00:05:22,490
everybody to pass their binaries if you

00:05:20,720 --> 00:05:23,930
have thousands of binaries you it's

00:05:22,490 --> 00:05:26,870
going to take time to update that now

00:05:23,930 --> 00:05:28,490
you want to you want to detect some some

00:05:26,870 --> 00:05:30,290
fingerprint of that binary and prevent

00:05:28,490 --> 00:05:32,120
it from running in production and you

00:05:30,290 --> 00:05:34,460
know that you can deploy these detection

00:05:32,120 --> 00:05:37,190
rules much faster then you can deploy

00:05:34,460 --> 00:05:38,870
the deploy that binary with that but

00:05:37,190 --> 00:05:40,220
that's the nature of - binaries need to

00:05:38,870 --> 00:05:42,590
be recompiled they need to be like

00:05:40,220 --> 00:05:43,820
recertified or like made sure and

00:05:42,590 --> 00:05:46,100
there's a release process involved here

00:05:43,820 --> 00:05:49,040
and you have your own concrete release

00:05:46,100 --> 00:05:50,780
process for deploying these policies the

00:05:49,040 --> 00:05:52,760
the key thing to take away from here is

00:05:50,780 --> 00:05:55,310
that white listing and black listing can

00:05:52,760 --> 00:05:57,100
be very dynamic in nature and we want to

00:05:55,310 --> 00:06:00,890
we want to enable and facilitate that

00:05:57,100 --> 00:06:02,240
and this is the core of the of the of

00:06:00,890 --> 00:06:04,580
the of the motivation here

00:06:02,240 --> 00:06:07,610
can we make it easy to add signals and

00:06:04,580 --> 00:06:12,560
medications and and in an unified way

00:06:07,610 --> 00:06:14,810
via a single API so how does it work I

00:06:12,560 --> 00:06:17,540
know you've probably read the abstract

00:06:14,810 --> 00:06:19,130
and you've heard of ebps maybe but show

00:06:17,540 --> 00:06:22,460
of hands how many of you how many of you

00:06:19,130 --> 00:06:24,460
know what EBP F is awesome this is a

00:06:22,460 --> 00:06:27,200
great audience

00:06:24,460 --> 00:06:28,640
so what do you play what we trying to do

00:06:27,200 --> 00:06:32,450
is we're going to have a new program

00:06:28,640 --> 00:06:34,220
type and if you know ebps EBP f is

00:06:32,450 --> 00:06:36,080
essentially a number that maps to a

00:06:34,220 --> 00:06:38,340
function in the kernel it is also

00:06:36,080 --> 00:06:39,690
verified and makes sure that

00:06:38,340 --> 00:06:41,940
program completes and it is non

00:06:39,690 --> 00:06:44,970
turing-complete and stuff but think of

00:06:41,940 --> 00:06:47,280
those that those up chords or helpers as

00:06:44,970 --> 00:06:49,470
an API to define those signals and

00:06:47,280 --> 00:06:52,560
mitigation rather than just updating

00:06:49,470 --> 00:06:54,480
audit and SELinux you define these you

00:06:52,560 --> 00:06:55,920
define these helpers and functions you

00:06:54,480 --> 00:06:59,130
do your signalling and then you do your

00:06:55,920 --> 00:07:01,500
mitigation using the same API there have

00:06:59,130 --> 00:07:04,560
been what we want to point out is that

00:07:01,500 --> 00:07:07,110
this is this is not vpf probe type trace

00:07:04,560 --> 00:07:09,900
this is not BPF procter a type like a

00:07:07,110 --> 00:07:11,400
sock or c group sock it is security

00:07:09,900 --> 00:07:15,210
focused so it's going to be a security

00:07:11,400 --> 00:07:17,640
focused API here and we can build the

00:07:15,210 --> 00:07:21,480
ksi LSM or your dynamic policy logic

00:07:17,640 --> 00:07:24,120
using these helpers here I'm going to

00:07:21,480 --> 00:07:25,620
talk about v-neck security modules

00:07:24,120 --> 00:07:30,900
because that's a question that comes a

00:07:25,620 --> 00:07:33,000
lot that I get asked a lot so we want to

00:07:30,900 --> 00:07:36,390
target security behaviors rather than

00:07:33,000 --> 00:07:39,630
the API cisco is an API that you exposed

00:07:36,390 --> 00:07:41,790
to the user and and LSM hooks

00:07:39,630 --> 00:07:44,910
essentially is like a funnel you have

00:07:41,790 --> 00:07:46,950
ten different API is to enter into let's

00:07:44,910 --> 00:07:48,600
say execution of a process right you

00:07:46,950 --> 00:07:50,610
want to execute a process you can have

00:07:48,600 --> 00:07:53,370
forces calls to execute a process but

00:07:50,610 --> 00:07:53,850
the LSM hook is is is funneling into all

00:07:53,370 --> 00:07:55,470
of these

00:07:53,850 --> 00:07:57,870
it basically caters to that security

00:07:55,470 --> 00:08:00,300
behavior I can tell you a while back we

00:07:57,870 --> 00:08:02,190
missed out on instrumenting exactly at

00:08:00,300 --> 00:08:04,650
and we missed logging an auditing

00:08:02,190 --> 00:08:06,510
performance like auditing process

00:08:04,650 --> 00:08:10,830
executions for some time it's been a

00:08:06,510 --> 00:08:13,680
while though and we want to benefit the

00:08:10,830 --> 00:08:15,720
LSM ecosystem as well so if you get

00:08:13,680 --> 00:08:17,490
enough feedback from the security

00:08:15,720 --> 00:08:18,960
community if they if they're using your

00:08:17,490 --> 00:08:21,690
LS m hooks they're going to tell us ah

00:08:18,960 --> 00:08:23,520
maybe that behavior is something you

00:08:21,690 --> 00:08:25,410
should be hooking into and if they can

00:08:23,520 --> 00:08:27,660
easily use the LS m hooks and develop on

00:08:25,410 --> 00:08:30,480
that the LS m ecosystem benefits as well

00:08:27,660 --> 00:08:33,780
so that is roughly why we are targeting

00:08:30,480 --> 00:08:35,550
vlsm rather than anything else and I go

00:08:33,780 --> 00:08:37,500
into be alternatives like seccomp and

00:08:35,550 --> 00:08:39,710
I'd give a brief update on that later on

00:08:37,500 --> 00:08:42,300
in the presentation

00:08:39,710 --> 00:08:45,290
it's I have an interesting anak anecdote

00:08:42,300 --> 00:08:47,820
when I went to our security engineers I

00:08:45,290 --> 00:08:50,130
they they would they would say something

00:08:47,820 --> 00:08:51,910
like this is sort of similar they will

00:08:50,130 --> 00:08:54,430
say something like I want to log LD

00:08:51,910 --> 00:08:56,080
unprocess execution and the interesting

00:08:54,430 --> 00:08:58,120
thing to note here is they never said

00:08:56,080 --> 00:09:00,490
they never told me that I want to hook

00:08:58,120 --> 00:09:02,050
into the exact system call don't even

00:09:00,490 --> 00:09:05,440
care what the exact system call is they

00:09:02,050 --> 00:09:07,420
care about be the deep the behavior when

00:09:05,440 --> 00:09:09,940
you execute a process rather than the

00:09:07,420 --> 00:09:11,770
API you use to like trigger that

00:09:09,940 --> 00:09:13,840
behavior on your operating system so

00:09:11,770 --> 00:09:15,010
that's what I I really I really took

00:09:13,840 --> 00:09:18,970
away from that simple line of

00:09:15,010 --> 00:09:22,270
conversation that we had okay so how

00:09:18,970 --> 00:09:24,190
does it work each behavior or each hook

00:09:22,270 --> 00:09:27,940
or whatever you may call it from the LSM

00:09:24,190 --> 00:09:29,980
is like a file in Sisyphus this is the

00:09:27,940 --> 00:09:33,340
cool security engineer telling me like I

00:09:29,980 --> 00:09:35,350
want to log process executions I go and

00:09:33,340 --> 00:09:38,440
write a BPF program so that yellow thing

00:09:35,350 --> 00:09:40,810
there is a BPF program you open the hook

00:09:38,440 --> 00:09:42,790
you have the VP SV PFF you know is a

00:09:40,810 --> 00:09:44,230
multiplex system call so it has like the

00:09:42,790 --> 00:09:45,910
same system call behaves in different

00:09:44,230 --> 00:09:48,370
ways based on the flags you pass to it

00:09:45,910 --> 00:09:50,410
so you load the program you get a file

00:09:48,370 --> 00:09:51,790
descriptor back and then you match these

00:09:50,410 --> 00:09:54,730
two file descriptors together in a

00:09:51,790 --> 00:09:57,340
process called attachment and this goes

00:09:54,730 --> 00:09:58,960
this logic is executed when you when

00:09:57,340 --> 00:10:00,700
that particular behavior is encountered

00:09:58,960 --> 00:10:04,240
along with the other Ellison hooks so

00:10:00,700 --> 00:10:07,240
apparmor selinux whatever and ksi at the

00:10:04,240 --> 00:10:10,330
end and in this LS m hook you can audit

00:10:07,240 --> 00:10:11,800
you can say no you can say you you

00:10:10,330 --> 00:10:14,530
essentially have a way to communicate

00:10:11,800 --> 00:10:16,690
with user space and I go I tell how that

00:10:14,530 --> 00:10:19,110
communication happens a bit like it's

00:10:16,690 --> 00:10:21,520
still an open question though

00:10:19,110 --> 00:10:23,530
for all you programmers out there I put

00:10:21,520 --> 00:10:25,840
this like simple data structure but just

00:10:23,530 --> 00:10:28,120
look at it as mapping of a behavior or

00:10:25,840 --> 00:10:30,010
an LS m hook to the set of programs that

00:10:28,120 --> 00:10:31,900
you need to run and the key takeaway is

00:10:30,010 --> 00:10:34,480
that there can be multiple programs that

00:10:31,900 --> 00:10:37,930
you can attach so BPF attach multi is

00:10:34,480 --> 00:10:43,480
the thing here but that's like for for

00:10:37,930 --> 00:10:46,450
for all the programmers like me so again

00:10:43,480 --> 00:10:48,550
before we go further into the example

00:10:46,450 --> 00:10:50,590
use cases and stuff we want to keep one

00:10:48,550 --> 00:10:53,650
thing very clear we want to keep the

00:10:50,590 --> 00:10:56,470
helpers very precise and granular and if

00:10:53,650 --> 00:10:58,060
anyone has seen or used the BPF helpers

00:10:56,470 --> 00:10:59,650
that are in the tracing part which are

00:10:58,060 --> 00:11:01,750
really good for tracing I am not

00:10:59,650 --> 00:11:04,150
criticizing the helpers themselves but

00:11:01,750 --> 00:11:04,620
BPF probe read would give you access to

00:11:04,150 --> 00:11:06,660
man

00:11:04,620 --> 00:11:08,730
the colonel and this is not from a

00:11:06,660 --> 00:11:10,950
security perspective this is from from

00:11:08,730 --> 00:11:13,110
an API perspective you get that blob of

00:11:10,950 --> 00:11:15,360
memory you get your kernel headers from

00:11:13,110 --> 00:11:18,300
somewhere then you try to template that

00:11:15,360 --> 00:11:20,010
memory into the kernel headers and this

00:11:18,300 --> 00:11:21,720
makes it really hard to deploy on a

00:11:20,010 --> 00:11:24,090
large scale in a backward compatible

00:11:21,720 --> 00:11:26,100
fashion so we want to make sure that we

00:11:24,090 --> 00:11:28,800
don't use any kernel data structures we

00:11:26,100 --> 00:11:30,390
keep the helpers as granular and how are

00:11:28,800 --> 00:11:32,220
we going to do that we're going to talk

00:11:30,390 --> 00:11:34,020
to our security engineers exactly ask

00:11:32,220 --> 00:11:38,580
them for the information they need and

00:11:34,020 --> 00:11:41,360
then make our API on top of that so keep

00:11:38,580 --> 00:11:44,790
things simple no broad help us here

00:11:41,360 --> 00:11:46,110
and then if you look at the overall

00:11:44,790 --> 00:11:48,030
structure that's what I was telling you

00:11:46,110 --> 00:11:50,190
about you have you'll have multiple LS m

00:11:48,030 --> 00:11:53,610
hooks you'll have a b PF programs

00:11:50,190 --> 00:11:56,040
attached to that and there will be some

00:11:53,610 --> 00:11:58,320
user space utility that runs that loads

00:11:56,040 --> 00:12:01,470
your eb PF programs into that this could

00:11:58,320 --> 00:12:03,720
be an agent or a demon that then your EB

00:12:01,470 --> 00:12:05,850
PF the programs can then write auditing

00:12:03,720 --> 00:12:07,620
data to a buffer this is currently

00:12:05,850 --> 00:12:09,600
performance buffer I have I have a

00:12:07,620 --> 00:12:12,060
discussion slide on that whether what

00:12:09,600 --> 00:12:14,430
this should be and could be eventually

00:12:12,060 --> 00:12:17,790
and then your user space daemon can ship

00:12:14,430 --> 00:12:21,120
all these logs do the do your protection

00:12:17,790 --> 00:12:23,640
pipeline or whatever you also have more

00:12:21,120 --> 00:12:25,380
options here to like filter data because

00:12:23,640 --> 00:12:28,260
if you have if you're generating large

00:12:25,380 --> 00:12:30,900
volumes of data from each individual

00:12:28,260 --> 00:12:32,580
endpoint you you're going to overwhelm

00:12:30,900 --> 00:12:36,630
your detection pipeline and your

00:12:32,580 --> 00:12:41,640
response your response phase here key

00:12:36,630 --> 00:12:43,140
thing to note is that ok I think I

00:12:41,640 --> 00:12:45,210
missed my key thing to note here anyways

00:12:43,140 --> 00:12:47,460
Oh key thing to note here is it's not

00:12:45,210 --> 00:12:49,020
just for workstations it's not just for

00:12:47,460 --> 00:12:50,490
data centers we want to do detection on

00:12:49,020 --> 00:12:53,010
both I think bad things can happen I

00:12:50,490 --> 00:12:56,520
both liked both areas it's less likely

00:12:53,010 --> 00:13:01,710
in prod but works we also targeting our

00:12:56,520 --> 00:13:03,960
endpoints as well ok I'm going to go

00:13:01,710 --> 00:13:07,740
into some of the other alternatives

00:13:03,960 --> 00:13:09,450
available here and the I alluded to that

00:13:07,740 --> 00:13:12,420
previously in the presentation as well

00:13:09,450 --> 00:13:14,940
like in audit the medication needs to be

00:13:12,420 --> 00:13:17,160
handled separately so you add the your

00:13:14,940 --> 00:13:19,560
policies and your rules and stuff

00:13:17,160 --> 00:13:22,260
there is some performance overhead if

00:13:19,560 --> 00:13:26,070
you enable ordered by default I did some

00:13:22,260 --> 00:13:27,810
very crude benchmarking for that but I'm

00:13:26,070 --> 00:13:29,160
sure like you are a more experienced

00:13:27,810 --> 00:13:32,100
audience with this with this part of the

00:13:29,160 --> 00:13:34,260
system here and it also has rigid form

00:13:32,100 --> 00:13:35,910
adding constraints so you you you get

00:13:34,260 --> 00:13:38,640
strings back you need to update your

00:13:35,910 --> 00:13:40,920
user space application pass strings or

00:13:38,640 --> 00:13:43,290
user space data structures you need to

00:13:40,920 --> 00:13:45,660
be changing and and when you're talking

00:13:43,290 --> 00:13:47,850
about security and detection the faster

00:13:45,660 --> 00:13:49,590
you can respond to a threat the better

00:13:47,850 --> 00:13:51,600
you can the better you can be and this

00:13:49,590 --> 00:13:53,580
sort of limits that that aspect of the

00:13:51,600 --> 00:13:58,260
loop or detection and response loop that

00:13:53,580 --> 00:14:00,710
we have why not check compound maybe Pio

00:13:58,260 --> 00:14:03,690
said combat BPF I have an extra either

00:14:00,710 --> 00:14:07,740
LSM Maps as I said by to do security

00:14:03,690 --> 00:14:09,570
behaviors the syscall like yeah you're

00:14:07,740 --> 00:14:11,160
we were talking earlier on the I didn't

00:14:09,570 --> 00:14:13,170
even know whether it is called footprint

00:14:11,160 --> 00:14:14,910
and the Linux is increasing at all but

00:14:13,170 --> 00:14:17,130
it seems like we're talking about adding

00:14:14,910 --> 00:14:18,720
new syscalls which I if it does happen

00:14:17,130 --> 00:14:20,760
then you need to update your all your

00:14:18,720 --> 00:14:24,600
psych comp logic to incorporate those

00:14:20,760 --> 00:14:26,400
calls and then it goes into maybe I got

00:14:24,600 --> 00:14:27,990
you could also deny everything by

00:14:26,400 --> 00:14:31,230
default but that's going to make your

00:14:27,990 --> 00:14:33,330
developers very angry so like it's it's

00:14:31,230 --> 00:14:35,370
the balance between API and security

00:14:33,330 --> 00:14:37,920
behaviors here this is something that

00:14:35,370 --> 00:14:39,270
I'm not very sure of I think the

00:14:37,920 --> 00:14:41,480
previous talk did mention something

00:14:39,270 --> 00:14:44,190
about there not being a race condition

00:14:41,480 --> 00:14:45,990
when reading user space arguments or

00:14:44,190 --> 00:14:47,460
something about that but from my

00:14:45,990 --> 00:14:50,430
understanding there was some sort of

00:14:47,460 --> 00:14:52,230
race when you have maybe this has gone

00:14:50,430 --> 00:14:55,680
better in the previous kernel versions

00:14:52,230 --> 00:14:56,400
or something so I would keep that with a

00:14:55,680 --> 00:15:00,570
grain of salt

00:14:56,400 --> 00:15:02,310
yeah we also talked about the currents

00:15:00,570 --> 00:15:06,360
it's a solution we have is based on K

00:15:02,310 --> 00:15:08,910
probes and it also is like you if you

00:15:06,360 --> 00:15:12,150
use K probes an EVP F it's very flexible

00:15:08,910 --> 00:15:13,830
you can hook i practically any function

00:15:12,150 --> 00:15:16,770
in the kernel and build your logic but

00:15:13,830 --> 00:15:18,150
then you you were again adding

00:15:16,770 --> 00:15:20,130
dependencies on your kernel data

00:15:18,150 --> 00:15:21,900
structures it's going to be hard to

00:15:20,130 --> 00:15:23,730
wreak you have to keep recompiling you

00:15:21,900 --> 00:15:25,410
have to keep you again the backward

00:15:23,730 --> 00:15:27,960
compatibility or the software life cycle

00:15:25,410 --> 00:15:30,630
aspect of this solution is is is

00:15:27,960 --> 00:15:33,090
difficult also k proves is not a stay

00:15:30,630 --> 00:15:37,020
I like function might just disappear

00:15:33,090 --> 00:15:39,270
right we also saw like preemption is

00:15:37,020 --> 00:15:41,520
disabled is not disabled are the irqs

00:15:39,270 --> 00:15:43,140
disabled or not am i holding some weird

00:15:41,520 --> 00:15:45,240
locks that I need to take care of in

00:15:43,140 --> 00:15:47,430
this part and that's something that the

00:15:45,240 --> 00:15:50,850
Ellis I'm sort of guarantees in their in

00:15:47,430 --> 00:15:53,940
their hooks there was also this thing

00:15:50,850 --> 00:15:56,760
called land lock which I am which I gave

00:15:53,940 --> 00:15:58,260
a brief look at but land lock is and if

00:15:56,760 --> 00:16:00,450
somebody from land lock is here we

00:15:58,260 --> 00:16:02,850
should also talk but it was geared

00:16:00,450 --> 00:16:04,410
towards a sandboxing securities unboxing

00:16:02,850 --> 00:16:08,070
for unprivileged processes is what I

00:16:04,410 --> 00:16:09,930
could gauge from that whereas we I I

00:16:08,070 --> 00:16:12,600
think I had a slide on that before but I

00:16:09,930 --> 00:16:15,600
I removed that because it was taking too

00:16:12,600 --> 00:16:17,910
much space we intend to run ksi at least

00:16:15,600 --> 00:16:20,370
in the very beginning as like the

00:16:17,910 --> 00:16:23,700
loading of privileged PPF programs

00:16:20,370 --> 00:16:27,180
requires caps as admin we will respect

00:16:23,700 --> 00:16:28,830
that modifying a CLS and policies

00:16:27,180 --> 00:16:30,960
require caps assignment will respect

00:16:28,830 --> 00:16:33,990
that so it's essentially route so there

00:16:30,960 --> 00:16:35,850
is no unprivileged sandboxing yet in the

00:16:33,990 --> 00:16:38,220
ksi stuff while we are initially

00:16:35,850 --> 00:16:40,190
beginning this project but then again

00:16:38,220 --> 00:16:43,410
this is a slower for comparison between

00:16:40,190 --> 00:16:46,530
why not land lock and why why we want to

00:16:43,410 --> 00:16:50,760
use that so we're going to do this case

00:16:46,530 --> 00:16:51,960
study we're going to see like the the

00:16:50,760 --> 00:16:53,220
thing I talked about you might have

00:16:51,960 --> 00:16:57,120
guessed is it's about environment

00:16:53,220 --> 00:16:58,830
variables what do you want to do like we

00:16:57,120 --> 00:17:01,080
you want to end or dirty environment

00:16:58,830 --> 00:17:02,640
variables and process execution our

00:17:01,080 --> 00:17:05,189
security engineer would tell me that

00:17:02,640 --> 00:17:07,589
should be easy right like you just write

00:17:05,189 --> 00:17:09,720
some bunch of code and have dump thing

00:17:07,589 --> 00:17:11,970
we haven't variables up but it's hard

00:17:09,720 --> 00:17:14,790
you know I mean variables can be 32

00:17:11,970 --> 00:17:16,949
pages long I was I was I was myself not

00:17:14,790 --> 00:17:19,230
aware of this like limitation but when I

00:17:16,949 --> 00:17:23,189
looked at the Linux then PRM struct is

00:17:19,230 --> 00:17:27,270
like the index to that is max arc size

00:17:23,189 --> 00:17:30,420
max page size is 32 and this was

00:17:27,270 --> 00:17:32,160
surprising so this is where the this is

00:17:30,420 --> 00:17:34,200
where you talk your security engineers

00:17:32,160 --> 00:17:36,480
don't tell me I need all the environment

00:17:34,200 --> 00:17:38,340
variables tell me what you exactly need

00:17:36,480 --> 00:17:40,830
and you structure your API around that

00:17:38,340 --> 00:17:43,770
so the first possibility is give me all

00:17:40,830 --> 00:17:46,920
of them right the second possibility is

00:17:43,770 --> 00:17:48,660
well give me exactly the value of LDP

00:17:46,920 --> 00:17:50,550
Lord and then you leave it up to the

00:17:48,660 --> 00:17:53,130
user on how much buffer memory you want

00:17:50,550 --> 00:17:55,830
to allocate what do you want to do in

00:17:53,130 --> 00:17:58,980
the case of an overflow and you were you

00:17:55,830 --> 00:18:01,350
kind of limiting the that you're kind of

00:17:58,980 --> 00:18:02,910
restricting your limitation or sorry

00:18:01,350 --> 00:18:05,580
relaxing your limitation of 32-page

00:18:02,910 --> 00:18:08,550
sighs is there note these two helpers

00:18:05,580 --> 00:18:11,160
put by the way have a have an issue that

00:18:08,550 --> 00:18:13,050
they can cause the cost go to sleep

00:18:11,160 --> 00:18:16,050
because the environment variables are in

00:18:13,050 --> 00:18:18,150
user space and user page it can it

00:18:16,050 --> 00:18:21,390
requires BPF doesn't like sleeping it's

00:18:18,150 --> 00:18:22,530
like it it doesn't sleep at all so this

00:18:21,390 --> 00:18:24,090
is something you have to keep about but

00:18:22,530 --> 00:18:25,559
there's a workaround for this I can I am

00:18:24,090 --> 00:18:27,990
presenting it at the end of it and of

00:18:25,559 --> 00:18:33,179
the solution but that's also an design

00:18:27,990 --> 00:18:34,800
thing that you need to the flexibility

00:18:33,179 --> 00:18:37,920
around data format this is also pretty

00:18:34,800 --> 00:18:41,070
cool so we talked about already not like

00:18:37,920 --> 00:18:43,590
giving you the flexibility here the user

00:18:41,070 --> 00:18:45,240
is writing the vpf program or user I say

00:18:43,590 --> 00:18:46,679
developer or I say the person who's

00:18:45,240 --> 00:18:49,650
right making the security product I'm

00:18:46,679 --> 00:18:51,990
clarifying that here so they choose

00:18:49,650 --> 00:18:53,970
their data format and they can use

00:18:51,990 --> 00:18:56,400
either the same data format in the user

00:18:53,970 --> 00:18:59,010
application or security product or they

00:18:56,400 --> 00:19:01,080
can or they can use a different stuff

00:18:59,010 --> 00:19:02,790
but the choice is up to the user and

00:19:01,080 --> 00:19:04,620
kernel doesn't have to worry about the

00:19:02,790 --> 00:19:06,450
data format here kernel just worries

00:19:04,620 --> 00:19:10,020
about the API is that exposed to get the

00:19:06,450 --> 00:19:12,120
data out and done and the user space can

00:19:10,020 --> 00:19:16,470
choose whatever weird formatting they

00:19:12,120 --> 00:19:19,620
want to do with that okay now I come to

00:19:16,470 --> 00:19:21,990
the tricky part I I would say KS is very

00:19:19,620 --> 00:19:26,309
new these systems are very very well

00:19:21,990 --> 00:19:28,110
developed and very again I'm this is

00:19:26,309 --> 00:19:30,120
like a very very ballpark comparison but

00:19:28,110 --> 00:19:32,040
it says check on whether we're what

00:19:30,120 --> 00:19:34,679
we're doing isn't the right if Kara's I

00:19:32,040 --> 00:19:38,880
was taking so many cycles in in like if

00:19:34,679 --> 00:19:40,410
it was like very from high overhead this

00:19:38,880 --> 00:19:41,220
is where we would have stopped or we

00:19:40,410 --> 00:19:44,730
would have looked for other alternatives

00:19:41,220 --> 00:19:46,679
as well but as it turns out again that's

00:19:44,730 --> 00:19:50,400
soil for you each if you can take a

00:19:46,679 --> 00:19:52,590
little bit of that the the workload that

00:19:50,400 --> 00:19:54,520
we that we that we kind of used to

00:19:52,590 --> 00:19:56,650
benchmark this is like there's a

00:19:54,520 --> 00:19:59,200
no op binary that basically does nothing

00:19:56,650 --> 00:20:00,430
and you executed a hundred times you

00:19:59,200 --> 00:20:02,860
take the average of these hundred

00:20:00,430 --> 00:20:04,720
executions and that is like one point of

00:20:02,860 --> 00:20:06,340
measurement and then you do it n times

00:20:04,720 --> 00:20:08,830
and then you plot a distribution of all

00:20:06,340 --> 00:20:11,650
the times you get back also we try to

00:20:08,830 --> 00:20:13,900
like the quest testing environment as

00:20:11,650 --> 00:20:15,460
much as possible by pinning and like by

00:20:13,900 --> 00:20:17,050
task set and all that so that the

00:20:15,460 --> 00:20:19,780
scheduler overhead doesn't matter there

00:20:17,050 --> 00:20:22,600
so just just to make you aware of the

00:20:19,780 --> 00:20:26,350
testing environment here so vanilla

00:20:22,600 --> 00:20:29,650
system no audit no key RSI nothing

00:20:26,350 --> 00:20:32,170
nothing going you have a please note

00:20:29,650 --> 00:20:34,200
that there the x-axis start at 500 I'm

00:20:32,170 --> 00:20:37,030
not playing a marketing trickery here so

00:20:34,200 --> 00:20:39,370
this is the x-axis is starting at 500

00:20:37,030 --> 00:20:43,050
now it it's it averages it peaks at

00:20:39,370 --> 00:20:45,580
around 570 microseconds per execution

00:20:43,050 --> 00:20:45,910
you enable audit and this is with no

00:20:45,580 --> 00:20:47,920
rules

00:20:45,910 --> 00:20:51,190
it moves slightly but it's not too bad

00:20:47,920 --> 00:20:54,310
like you know execution is in anyways

00:20:51,190 --> 00:20:57,700
like it's an expensive event and it it

00:20:54,310 --> 00:21:01,240
moves it by slightly there you enable

00:20:57,700 --> 00:21:03,370
order it with an exactly e like and ask

00:21:01,240 --> 00:21:06,490
the exact we ESS called to be audited

00:21:03,370 --> 00:21:09,250
boom the distribution becomes more it

00:21:06,490 --> 00:21:11,010
becomes less predictable and it there's

00:21:09,250 --> 00:21:13,390
a lot of overhead here

00:21:11,010 --> 00:21:16,270
again this is not the same information

00:21:13,390 --> 00:21:17,890
that I'm putting it out so there's I'm

00:21:16,270 --> 00:21:20,110
just reading the novel variables and a

00:21:17,890 --> 00:21:22,660
few process parameters here according to

00:21:20,110 --> 00:21:24,520
that but this is like it's also

00:21:22,660 --> 00:21:27,190
testimony to the specificity that you

00:21:24,520 --> 00:21:28,660
can add when you're writing your EVP of

00:21:27,190 --> 00:21:32,170
helpers you choose the data you want to

00:21:28,660 --> 00:21:34,180
audit and then it says like small

00:21:32,170 --> 00:21:35,950
overhead about 533 and I kept adding

00:21:34,180 --> 00:21:36,460
more information like copying more

00:21:35,950 --> 00:21:39,850
strings

00:21:36,460 --> 00:21:42,280
tgd ID like PID and then you have UID

00:21:39,850 --> 00:21:43,840
and stuff the distribution still kept

00:21:42,280 --> 00:21:45,310
staying the same if I was not doing

00:21:43,840 --> 00:21:47,470
something that was non-trivial II

00:21:45,310 --> 00:21:49,870
expensive like copying him and variables

00:21:47,470 --> 00:21:51,250
and stuff so the performance doesn't

00:21:49,870 --> 00:21:53,110
look bad it could it could be very

00:21:51,250 --> 00:21:54,760
different based on the based on the

00:21:53,110 --> 00:21:58,590
helper that you're trying to use but we

00:21:54,760 --> 00:21:58,590
just have one in our prototype for now

00:21:59,250 --> 00:22:02,950
it's just not moving forward so that's

00:22:01,390 --> 00:22:04,230
that's how it looks in comparison by the

00:22:02,950 --> 00:22:07,140
way like in over

00:22:04,230 --> 00:22:11,100
distributions and stuff the key takeaway

00:22:07,140 --> 00:22:13,260
though here is that like we the main the

00:22:11,100 --> 00:22:15,929
main motivation is the hygiene around

00:22:13,260 --> 00:22:18,179
the signaling and behavior part a

00:22:15,929 --> 00:22:20,370
significant mitigation part but we also

00:22:18,179 --> 00:22:22,049
there is the added benefit that it's

00:22:20,370 --> 00:22:23,700
likely going to perform better this

00:22:22,049 --> 00:22:26,630
there's no guarantee on that but it's

00:22:23,700 --> 00:22:34,440
like it's the initial signaling for that

00:22:26,630 --> 00:22:37,100
okay now comes the demo okay we have so

00:22:34,440 --> 00:22:39,570
I saw somebody did like an excellent job

00:22:37,100 --> 00:22:41,610
doing a screencast now it's going to do

00:22:39,570 --> 00:22:43,620
the demo myself my hands are also a bit

00:22:41,610 --> 00:22:46,740
shaky right now so it's good I did a

00:22:43,620 --> 00:22:49,320
screencast while I was sitting there so

00:22:46,740 --> 00:22:56,040
you start a VM I start a VM on my on my

00:22:49,320 --> 00:22:58,559
machine it and then I start up my I

00:22:56,040 --> 00:23:02,100
guess it's a show that VM and I start up

00:22:58,559 --> 00:23:04,169
like the K RSI helper I've wrote this

00:23:02,100 --> 00:23:07,530
isn't the prototype encoding samples BPF

00:23:04,169 --> 00:23:09,630
and i look at the hook so it's in its

00:23:07,530 --> 00:23:10,830
the hook you can catch the file and it

00:23:09,630 --> 00:23:16,650
just gives you the name of the hook

00:23:10,830 --> 00:23:17,940
there and then you say you run a process

00:23:16,650 --> 00:23:20,880
and this is the output you get back

00:23:17,940 --> 00:23:22,380
essentially like this is you this is the

00:23:20,880 --> 00:23:24,320
world this is what I was logging and if

00:23:22,380 --> 00:23:26,730
you see I was initially logging just the

00:23:24,320 --> 00:23:28,140
value of quinoa environment variable but

00:23:26,730 --> 00:23:29,760
then I started adding more information

00:23:28,140 --> 00:23:36,510
that's where performance kind of stayed

00:23:29,760 --> 00:23:38,070
the same okay this is an empty slide so

00:23:36,510 --> 00:23:40,620
what's up for discussion what do we want

00:23:38,070 --> 00:23:43,650
to what what still up to the community

00:23:40,620 --> 00:23:46,470
to discuss right users of the perf ring

00:23:43,650 --> 00:23:49,020
buffer first issue is it's called perf

00:23:46,470 --> 00:23:50,520
so it should be only for performance

00:23:49,020 --> 00:23:53,370
stuff but it is actually used in other

00:23:50,520 --> 00:23:55,380
places in the kernel where it's not it's

00:23:53,370 --> 00:23:58,919
it's its scope has gone beyond

00:23:55,380 --> 00:24:01,740
performance measurement so PPF already

00:23:58,919 --> 00:24:04,290
has this helper function called BPF per

00:24:01,740 --> 00:24:09,840
event output and we just using the same

00:24:04,290 --> 00:24:12,299
and it works so it's quite fast but then

00:24:09,840 --> 00:24:14,669
like there is the usual trade-off of per

00:24:12,299 --> 00:24:16,080
CPU buffers versus like should why

00:24:14,669 --> 00:24:17,500
should i do a single buffer an art

00:24:16,080 --> 00:24:18,940
synchronization so

00:24:17,500 --> 00:24:20,710
sort of design decisions are yet to be

00:24:18,940 --> 00:24:23,290
made here like what do you do when there

00:24:20,710 --> 00:24:25,030
are 100 CPUs on the system is it going

00:24:23,290 --> 00:24:26,170
to lead to a large overhead when you in

00:24:25,030 --> 00:24:27,660
your aura ting gold or something like

00:24:26,170 --> 00:24:31,060
that

00:24:27,660 --> 00:24:35,020
again like I talked about this sleepable

00:24:31,060 --> 00:24:37,450
EVPs this is like if you allow eb PF to

00:24:35,020 --> 00:24:39,850
sleep to help us become much simple and

00:24:37,450 --> 00:24:41,770
i'm going to load back to the helper

00:24:39,850 --> 00:24:43,690
that I had there is a discussion that is

00:24:41,770 --> 00:24:45,490
happening in the VP of micro conference

00:24:43,690 --> 00:24:47,230
in the next clamors where they're trying

00:24:45,490 --> 00:24:49,600
to see whether they should allow it to

00:24:47,230 --> 00:24:51,070
happen or not the patch for that is

00:24:49,600 --> 00:24:52,960
quite trivial the main is the

00:24:51,070 --> 00:24:57,100
ideological discussion behind whether

00:24:52,960 --> 00:25:00,130
this should be allowed or not we also

00:24:57,100 --> 00:25:02,200
want to so the way we avoid it right now

00:25:00,130 --> 00:25:04,540
in the single prototype code is you do

00:25:02,200 --> 00:25:08,200
pre-computation vlsm hook so the LSM

00:25:04,540 --> 00:25:12,700
hook you will you copy the copy all the

00:25:08,200 --> 00:25:14,320
the NP and Arg V back to the kernel

00:25:12,700 --> 00:25:17,500
memory and then you pass it to your VP

00:25:14,320 --> 00:25:19,090
of program and in the context this gives

00:25:17,500 --> 00:25:21,370
you guarantee that the data will be

00:25:19,090 --> 00:25:23,830
available but it's not there and you can

00:25:21,370 --> 00:25:25,450
also do like smart stuff you can you can

00:25:23,830 --> 00:25:27,760
have the LS m hook look into the VP of

00:25:25,450 --> 00:25:30,130
program see if the environment variable

00:25:27,760 --> 00:25:32,740
function opcode is there and only do the

00:25:30,130 --> 00:25:36,040
pre computation then but again like this

00:25:32,740 --> 00:25:39,870
would not be required if the BPF was

00:25:36,040 --> 00:25:41,860
like allowed to sleep that's about it

00:25:39,870 --> 00:25:44,170
I'm going to leave it up to questions

00:25:41,860 --> 00:25:46,230
because I guess you have a few questions

00:25:44,170 --> 00:25:46,230
now

00:25:55,500 --> 00:26:00,600
just a sorry for being that person but

00:25:58,360 --> 00:26:03,159
just a clarification there is a talk to

00:26:00,600 --> 00:26:06,190
you mentioned before with seccomp yeah

00:26:03,159 --> 00:26:07,929
it is just the API that we devised with

00:26:06,190 --> 00:26:09,880
seccomb just allows you to check whether

00:26:07,929 --> 00:26:12,490
you lost it or you want it essentially

00:26:09,880 --> 00:26:15,399
so you you get a cookie back right when

00:26:12,490 --> 00:26:17,230
it's this call is performed you open you

00:26:15,399 --> 00:26:19,330
open the file descriptor to proc pit mem

00:26:17,230 --> 00:26:21,130
whatever and then you pass that cookie

00:26:19,330 --> 00:26:23,080
into another sex that comes this call

00:26:21,130 --> 00:26:24,640
and basically a score I ocular it is I

00:26:23,080 --> 00:26:25,690
think and you basically ask it is that

00:26:24,640 --> 00:26:27,279
cookies still valid

00:26:25,690 --> 00:26:29,350
okay okay if that cookie is still valid

00:26:27,279 --> 00:26:31,149
and you know your open is correct and if

00:26:29,350 --> 00:26:35,470
that cookie is not valid anymore then

00:26:31,149 --> 00:26:37,450
you know oak cask has died the same

00:26:35,470 --> 00:26:38,710
object on my fuse thing that some people

00:26:37,450 --> 00:26:43,510
might think of when they think about

00:26:38,710 --> 00:26:47,200
seccomp cisco interception is and that

00:26:43,510 --> 00:26:49,929
was mention on the side we you never

00:26:47,200 --> 00:26:53,200
move on effectively in Nakano once you

00:26:49,929 --> 00:26:55,570
hit a interception target it goes to

00:26:53,200 --> 00:26:57,159
user space and user space is has to do

00:26:55,570 --> 00:26:59,019
all the work the counter will never

00:26:57,159 --> 00:27:03,429
continue so that means that user space

00:26:59,019 --> 00:27:05,409
can safely duplicate the the arguments

00:27:03,429 --> 00:27:07,299
of the function from the process and

00:27:05,409 --> 00:27:10,389
then evaluate that and then act on that

00:27:07,299 --> 00:27:12,130
copy preventing the caller from ever

00:27:10,389 --> 00:27:13,740
like it changes that memory after you've

00:27:12,130 --> 00:27:16,510
done the copy of every valuated it

00:27:13,740 --> 00:27:17,950
whatever like you don't you never tell

00:27:16,510 --> 00:27:20,710
the colonel to continue doing anything

00:27:17,950 --> 00:27:23,200
on the original point which last point

00:27:20,710 --> 00:27:25,059
also means for example if your if your

00:27:23,200 --> 00:27:26,980
argument is also used as a return

00:27:25,059 --> 00:27:28,570
argument it's unusual space to fill on

00:27:26,980 --> 00:27:30,880
the return argument because the kernel

00:27:28,570 --> 00:27:33,010
won't fill it in okay so I mean this is

00:27:30,880 --> 00:27:37,980
about I was not really sure about that

00:27:33,010 --> 00:27:37,980
point anyways so thank you

00:27:43,720 --> 00:27:48,500
can you come back on the non-oxide

00:27:46,370 --> 00:27:52,340
please which one this one

00:27:48,500 --> 00:27:56,500
none look LAN lock oh yes sure

00:27:52,340 --> 00:28:01,460
Oh awesome

00:27:56,500 --> 00:28:05,030
so just be sure Nanak is designed to be

00:28:01,460 --> 00:28:07,100
used by in French possesses uh-huh but

00:28:05,030 --> 00:28:10,870
of course can be used by th possesses -

00:28:07,100 --> 00:28:15,410
okay so basically Languedoc is a

00:28:10,870 --> 00:28:18,710
framework to help you design your own

00:28:15,410 --> 00:28:23,240
access control but it can be could be

00:28:18,710 --> 00:28:26,150
used in same way to audit any event you

00:28:23,240 --> 00:28:28,880
want okay of course like for okay

00:28:26,150 --> 00:28:32,480
err si you need to have appropriate

00:28:28,880 --> 00:28:34,540
hooks and appropriate elbows to have

00:28:32,480 --> 00:28:40,580
fine grain

00:28:34,540 --> 00:28:44,140
ODT access control that to say that I'm

00:28:40,580 --> 00:28:49,490
pretty sure what we did could be very

00:28:44,140 --> 00:28:54,260
well integrated with the unlock I think

00:28:49,490 --> 00:28:58,880
it's quite close everything you talk

00:28:54,260 --> 00:29:03,290
about why does implement it with K

00:28:58,880 --> 00:29:07,970
probes all the stuff I I work I run

00:29:03,290 --> 00:29:13,750
through the same reasoning to create

00:29:07,970 --> 00:29:19,700
nanak sure and yeah so I think this one

00:29:13,750 --> 00:29:22,309
issue with the current way you create

00:29:19,700 --> 00:29:26,059
the file system security file system

00:29:22,309 --> 00:29:29,450
well the ABI is you use an ABI

00:29:26,059 --> 00:29:33,320
right now I think you tied it to the LSM

00:29:29,450 --> 00:29:38,120
API yeah so I think it is a matter of

00:29:33,320 --> 00:29:40,340
blocker because LS m/l s/m api is not

00:29:38,120 --> 00:29:42,260
meant to be public because you can

00:29:40,340 --> 00:29:44,690
change like every part of the kernel

00:29:42,260 --> 00:29:46,700
so I I was I was thinking about this

00:29:44,690 --> 00:29:48,679
like this is whether we should have a

00:29:46,700 --> 00:29:49,070
shadow layer on top of that or whether

00:29:48,679 --> 00:29:52,730
we should

00:29:49,070 --> 00:29:55,820
exposed LSM epi directly sorry partner

00:29:52,730 --> 00:29:58,070
I personally felt that if we if you

00:29:55,820 --> 00:30:00,350
allow the LSM API to be exposed at least

00:29:58,070 --> 00:30:01,549
in this in this situation you can do

00:30:00,350 --> 00:30:03,769
some stuff in user space that would

00:30:01,549 --> 00:30:06,080
prevent like you could have your own

00:30:03,769 --> 00:30:08,299
mapping in user space but it you need to

00:30:06,080 --> 00:30:09,980
make the LSM better and I have like the

00:30:08,299 --> 00:30:12,080
security behaviors built into the LS l

00:30:09,980 --> 00:30:14,509
like that feedback even going back from

00:30:12,080 --> 00:30:16,789
security community back into an SM and

00:30:14,509 --> 00:30:18,710
then then they build more programs on

00:30:16,789 --> 00:30:21,440
that then it goes back into the LS and I

00:30:18,710 --> 00:30:23,539
feel that this process this could

00:30:21,440 --> 00:30:25,549
benefit but I'm I think I'm open to both

00:30:23,539 --> 00:30:28,159
like talking the do Burt align lock

00:30:25,549 --> 00:30:29,960
stuff and also about like this in which

00:30:28,159 --> 00:30:34,429
this particular design to me because I

00:30:29,960 --> 00:30:36,889
just Inc which has the same review some

00:30:34,429 --> 00:30:46,399
a lot of patch series

00:30:36,889 --> 00:30:48,250
so yes so yeah about the Elpis you want

00:30:46,399 --> 00:30:52,820
to create you want to create a set of

00:30:48,250 --> 00:30:55,820
EPFL purse so that's exactly what I want

00:30:52,820 --> 00:30:58,759
to do with Lana - so why no Lana Keys

00:30:55,820 --> 00:31:01,279
focus on access control but access

00:30:58,759 --> 00:31:04,480
control is very close to a good system

00:31:01,279 --> 00:31:07,899
so I'm pretty sure we can do something

00:31:04,480 --> 00:31:07,899
okay together okay

00:31:27,309 --> 00:31:32,629
okay so you are implementing my neural

00:31:30,019 --> 00:31:35,239
Sam right so it means that you will we

00:31:32,629 --> 00:31:36,169
will need to rebuild the kernel in order

00:31:35,239 --> 00:31:38,479
to use it

00:31:36,169 --> 00:31:40,940
have you considered any alternatives

00:31:38,479 --> 00:31:43,879
that wouldn't require tribune kernels

00:31:40,940 --> 00:31:47,210
like k probes you rejected maybe F trays

00:31:43,879 --> 00:31:49,519
or anything that's wrong so you in this

00:31:47,210 --> 00:31:52,159
case when you if the helper is already

00:31:49,519 --> 00:31:53,599
there in the in the kernel you don't you

00:31:52,159 --> 00:31:55,099
need to reboot you don't need to rebuild

00:31:53,599 --> 00:31:57,559
the kernel right like if you're adding a

00:31:55,099 --> 00:32:00,649
new detection logic in this case if

00:31:57,559 --> 00:32:02,479
you're if the ksi helper or all the API

00:32:00,649 --> 00:32:04,450
is already there you don't need to

00:32:02,479 --> 00:32:07,759
rebuild the kernel you can attach your

00:32:04,450 --> 00:32:09,739
attach your BPF programs do your LS and

00:32:07,759 --> 00:32:11,419
hooks here and it just works without

00:32:09,739 --> 00:32:14,029
rebuilding the kernel so that's actually

00:32:11,419 --> 00:32:17,149
one of the important points I I did miss

00:32:14,029 --> 00:32:20,019
in my talk but yes and about the

00:32:17,149 --> 00:32:22,580
question between major and minor LSM I

00:32:20,019 --> 00:32:24,549
haven't thought yet about like whether

00:32:22,580 --> 00:32:27,889
we should allow access to security blobs

00:32:24,549 --> 00:32:31,309
from the BPF thing I would like to stay

00:32:27,889 --> 00:32:34,519
a bit far away from that till their use

00:32:31,309 --> 00:32:36,769
case actually comes up because BPF

00:32:34,519 --> 00:32:38,419
programs can do their own sort of like

00:32:36,769 --> 00:32:40,789
state management if you want to build a

00:32:38,419 --> 00:32:42,649
state machine of stuff with naps but

00:32:40,789 --> 00:32:44,389
then this is where you want to be

00:32:42,649 --> 00:32:45,799
careful about memory usage and whether

00:32:44,389 --> 00:32:47,809
this is make sense to build in the

00:32:45,799 --> 00:32:51,759
kernel but until the use case comes we

00:32:47,809 --> 00:32:51,759
want to like not make a decision on that

00:33:04,990 --> 00:33:08,220
okay that looks like yeah thanks for

00:33:07,390 --> 00:33:13,890
thank you

00:33:08,220 --> 00:33:13,890

YouTube URL: https://www.youtube.com/watch?v=2CZSSRfgAgQ


