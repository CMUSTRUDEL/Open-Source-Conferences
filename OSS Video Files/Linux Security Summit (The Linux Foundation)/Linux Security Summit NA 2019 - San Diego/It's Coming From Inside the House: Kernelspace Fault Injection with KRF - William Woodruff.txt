Title: It's Coming From Inside the House: Kernelspace Fault Injection with KRF - William Woodruff
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	It's Coming From Inside the House: Kernelspace Fault Injection with KRF - William Woodruff, Trail of Bits

Fault injection (FI) has become an increasingly popular software testing method, with major players like Netflix, Microsoft, and Google using automated failures to test the end-to-end resiliency of their (geographically, functionally) distributed services.In this talk, William Woodruff presents a lower-level, vulnerability-first approach: by randomly inducing errors in the system calls made by (targeted) programs, fault injection can be used to discover incorrect and potentially dangerous assumptions. This talk will cover specific classes of dangerous assumptions and their potential for exploitation, all motivated by KRF, a kernelspace fault injector open-sourced by Trail of Bits.
Captions: 
	00:00:00,030 --> 00:00:04,049
hello everybody my name is Wayne well

00:00:01,709 --> 00:00:04,920
Jeff the name of this talk is uh it's

00:00:04,049 --> 00:00:07,849
coming from inside the house

00:00:04,920 --> 00:00:11,070
kernel-space full injection with krf a

00:00:07,849 --> 00:00:12,210
little bit about me I am a security

00:00:11,070 --> 00:00:13,769
engineer at a company called trail

00:00:12,210 --> 00:00:15,089
Abbott's we're a small server security

00:00:13,769 --> 00:00:17,910
consultancy based out of New York

00:00:15,089 --> 00:00:20,670
although we're about I'd say about half

00:00:17,910 --> 00:00:22,320
remote these days in my day job I do a

00:00:20,670 --> 00:00:23,460
combination of just sort of general

00:00:22,320 --> 00:00:25,640
security engineering will see on

00:00:23,460 --> 00:00:27,480
open-source work as well as

00:00:25,640 --> 00:00:29,279
government-funded program analysis

00:00:27,480 --> 00:00:33,540
research mostly involving automated

00:00:29,279 --> 00:00:38,969
exploitability reasoning and automated

00:00:33,540 --> 00:00:40,200
exploit patching but to get into so this

00:00:38,969 --> 00:00:41,780
slide is kind of a lie this talk doesn't

00:00:40,200 --> 00:00:44,809
really have two parts this is to keep me

00:00:41,780 --> 00:00:48,000
honest about the stuff I want to cover

00:00:44,809 --> 00:00:50,039
the first part of this talk is that

00:00:48,000 --> 00:00:51,329
faults are vulnerabilities and I'll

00:00:50,039 --> 00:00:53,550
cover what a fault is but for the time

00:00:51,329 --> 00:00:55,230
being just accept that I'll talk about

00:00:53,550 --> 00:00:58,230
why handling faults is hard and why

00:00:55,230 --> 00:00:59,250
sometimes given like POSIX and Linux IO

00:00:58,230 --> 00:01:01,920
semantics we can't even really

00:00:59,250 --> 00:01:04,500
faithfully handle them I'll also talk

00:01:01,920 --> 00:01:06,150
about why failing to handle faults leads

00:01:04,500 --> 00:01:08,280
to real security vulnerabilities in

00:01:06,150 --> 00:01:10,229
actual code and then finally I'll talk

00:01:08,280 --> 00:01:11,700
about why the cloud itself makes it

00:01:10,229 --> 00:01:14,400
easier than ever to write fault normal

00:01:11,700 --> 00:01:17,400
code and interestingly that the cloud

00:01:14,400 --> 00:01:19,770
itself may be horrible to dangerous

00:01:17,400 --> 00:01:21,210
faults and then finally I'll sort of

00:01:19,770 --> 00:01:24,000
wrap things up with a demo of our tool

00:01:21,210 --> 00:01:26,220
krf which I wrote over a weekend as a

00:01:24,000 --> 00:01:28,979
sort of a joke and you'll see why it's

00:01:26,220 --> 00:01:30,390
kind of a joke I'll show you guys how it

00:01:28,979 --> 00:01:31,979
works show you how to use it on your

00:01:30,390 --> 00:01:33,540
tools and I'll talk about the results we

00:01:31,979 --> 00:01:36,869
got from it and real scary audits we've

00:01:33,540 --> 00:01:39,810
done so let's get started out what even

00:01:36,869 --> 00:01:40,979
is a fault so and conduct of systems

00:01:39,810 --> 00:01:43,770
will remain and specifically unkindness

00:01:40,979 --> 00:01:46,590
to this talk by fault I mean a well

00:01:43,770 --> 00:01:48,960
specified failure mode for usually

00:01:46,590 --> 00:01:50,759
kernel manage resources so that would be

00:01:48,960 --> 00:01:53,000
something like your paradigm attic

00:01:50,759 --> 00:01:55,619
access key perm cio

00:01:53,000 --> 00:01:58,439
returned by assist call when the kernel

00:01:55,619 --> 00:02:00,060
is unable to service your request and as

00:01:58,439 --> 00:02:03,020
I'm sure all of you know almost anything

00:02:00,060 --> 00:02:05,520
that such as the kernel can fail in some

00:02:03,020 --> 00:02:06,780
pretty well-defined way so you know open

00:02:05,520 --> 00:02:08,280
can fail because he commits a bad path

00:02:06,780 --> 00:02:09,030
or because you won't have access to that

00:02:08,280 --> 00:02:10,320
path

00:02:09,030 --> 00:02:12,660
or because it's been interrupted by

00:02:10,320 --> 00:02:14,910
single delivery or whatever for can I

00:02:12,660 --> 00:02:16,050
can have the same thing but also you

00:02:14,910 --> 00:02:17,970
have like really rich failure modes

00:02:16,050 --> 00:02:20,490
where like some combination of an Ellis

00:02:17,970 --> 00:02:21,990
and a CLS cause of this particular path

00:02:20,490 --> 00:02:24,630
to fail that otherwise would succeed for

00:02:21,990 --> 00:02:25,770
a given user different file system

00:02:24,630 --> 00:02:27,060
support different things and so you try

00:02:25,770 --> 00:02:30,480
to delay can send an attribute and it

00:02:27,060 --> 00:02:32,010
fails so rich things that don't

00:02:30,480 --> 00:02:35,130
necessarily correspond to like

00:02:32,010 --> 00:02:38,400
intuitions about the ways calls won't

00:02:35,130 --> 00:02:39,930
leave hell can't occur one thing that I

00:02:38,400 --> 00:02:41,340
think is really important is to think I

00:02:39,930 --> 00:02:43,830
think about fault as part of the design

00:02:41,340 --> 00:02:48,090
contract for writing secure in heavy

00:02:43,830 --> 00:02:49,830
quotes see it is your obligation as a C

00:02:48,090 --> 00:02:51,570
programmer to handle faults when they

00:02:49,830 --> 00:02:53,940
are expected to occur you can't just

00:02:51,570 --> 00:02:56,160
sort of like swipe them aside as I

00:02:53,940 --> 00:02:58,380
personally am so frequently guilty of

00:02:56,160 --> 00:03:00,239
doing because hardware is fundamentally

00:02:58,380 --> 00:03:02,760
and reliable resources are always

00:03:00,239 --> 00:03:03,900
eventually exhausted and users always do

00:03:02,760 --> 00:03:08,660
eventually challenge their permission

00:03:03,900 --> 00:03:11,160
boundaries and unfortunately for us

00:03:08,660 --> 00:03:13,890
handling faults is hard and I think

00:03:11,160 --> 00:03:15,060
actually yeah I got my slides in the

00:03:13,890 --> 00:03:18,060
wrong order start here

00:03:15,060 --> 00:03:19,500
handling false is hard there's a lot of

00:03:18,060 --> 00:03:22,500
UNIX baggage associated with like volt

00:03:19,500 --> 00:03:23,730
handling on Linux 99% of the time the

00:03:22,500 --> 00:03:25,140
right thing to do is you want to like

00:03:23,730 --> 00:03:26,850
clear or no or sometimes you don't have

00:03:25,140 --> 00:03:27,930
to you want to make your call you want

00:03:26,850 --> 00:03:30,060
to check your return value even then you

00:03:27,930 --> 00:03:32,100
want to check out now historically that

00:03:30,060 --> 00:03:34,530
wasn't always correct because thank you

00:03:32,100 --> 00:03:35,940
POSIX 1990 whatever I don't know it

00:03:34,530 --> 00:03:39,299
didn't used to be thread-local that's

00:03:35,940 --> 00:03:40,829
fixed now era no doesn't always have to

00:03:39,299 --> 00:03:42,150
be cleared that's not an issue if you do

00:03:40,829 --> 00:03:43,470
you clear it but because it doesn't

00:03:42,150 --> 00:03:45,239
always have to be cleared programmers

00:03:43,470 --> 00:03:48,000
are act inconsistently

00:03:45,239 --> 00:03:49,739
and don't clear out now you can in

00:03:48,000 --> 00:03:51,299
consistent return variables values most

00:03:49,739 --> 00:03:53,070
this calls return negative one some

00:03:51,299 --> 00:03:54,780
return null some return void store

00:03:53,070 --> 00:03:57,540
negative one some return some kind of

00:03:54,780 --> 00:03:59,100
array num if you're inside the Lib C and

00:03:57,540 --> 00:04:00,840
then finally because again this is C and

00:03:59,100 --> 00:04:02,700
C++ there's absolutely no enforcement of

00:04:00,840 --> 00:04:05,040
any of this and so you just base

00:04:02,700 --> 00:04:06,030
programmers get lazy like myself and we

00:04:05,040 --> 00:04:07,860
just don't bother checking nervous at

00:04:06,030 --> 00:04:11,640
all and then things fail and then we get

00:04:07,860 --> 00:04:13,920
sad but also to make things even worse

00:04:11,640 --> 00:04:15,840
some faults can't even really be handled

00:04:13,920 --> 00:04:18,000
so like I think some of you probably saw

00:04:15,840 --> 00:04:23,640
this recently it was like this

00:04:18,000 --> 00:04:25,080
same thing with Postgres f sync will

00:04:23,640 --> 00:04:26,850
return I think I think it returns

00:04:25,080 --> 00:04:28,410
success even if the dirty buffers inside

00:04:26,850 --> 00:04:30,150
to the kernel haven't been fully flushed

00:04:28,410 --> 00:04:31,650
in some cases and so you'll end up with

00:04:30,150 --> 00:04:35,180
like silent data corruption inside of

00:04:31,650 --> 00:04:37,650
major databases that assume that F Sync

00:04:35,180 --> 00:04:42,030
guarantees the success of every previous

00:04:37,650 --> 00:04:43,740
sync and that's terrible

00:04:42,030 --> 00:04:45,600
Google's solution to this has been I

00:04:43,740 --> 00:04:47,190
think to side-channel those errors with

00:04:45,600 --> 00:04:49,170
a linux kernel module which they've done

00:04:47,190 --> 00:04:51,330
broadcast via net link to some other

00:04:49,170 --> 00:04:54,090
service which then presumably like kills

00:04:51,330 --> 00:04:56,880
off that that database process before I

00:04:54,090 --> 00:04:58,950
can actually get corrupted there's a

00:04:56,880 --> 00:05:02,390
similar issue with like clothes and he

00:04:58,950 --> 00:05:05,370
interrupts some of you might have seen

00:05:02,390 --> 00:05:07,080
Colin Percival's blog post a few years

00:05:05,370 --> 00:05:10,169
ago about how close to is fundamentally

00:05:07,080 --> 00:05:12,150
broken because if close to receives and

00:05:10,169 --> 00:05:13,200
he enter the state of your file

00:05:12,150 --> 00:05:15,540
descriptor is no longer determined

00:05:13,200 --> 00:05:17,010
determinant so it could be open or

00:05:15,540 --> 00:05:18,120
closed and if you have another thread

00:05:17,010 --> 00:05:20,100
that is also interacting with your

00:05:18,120 --> 00:05:21,480
process and the phone script was closed

00:05:20,100 --> 00:05:22,950
it could reuse that how descriptor

00:05:21,480 --> 00:05:24,510
number so if you then go to close it

00:05:22,950 --> 00:05:26,610
again you've suddenly closed the wrong

00:05:24,510 --> 00:05:30,419
file and that's great right like who

00:05:26,610 --> 00:05:31,380
doesn't love that and you know what when

00:05:30,419 --> 00:05:33,060
we took eight years but he came up with

00:05:31,380 --> 00:05:34,919
like galaxy bring solution I feel bad

00:05:33,060 --> 00:05:37,050
because Keith Fame was case already said

00:05:34,919 --> 00:05:39,300
galaxy brain but it was already on the

00:05:37,050 --> 00:05:41,370
slides I took in my eight years I can

00:05:39,300 --> 00:05:43,229
put this like crazy solution involves a

00:05:41,370 --> 00:05:45,150
cookies and a pipe and hang a select and

00:05:43,229 --> 00:05:47,160
you basically select on the pipe and

00:05:45,150 --> 00:05:48,780
like if a cookie comes out you know that

00:05:47,160 --> 00:05:51,530
nothing else is closed dead but like

00:05:48,780 --> 00:05:53,610
nobody's gonna do that so it's broken

00:05:51,530 --> 00:05:56,820
and then also just like me enter in

00:05:53,610 --> 00:05:58,140
anything really signal FD has this issue

00:05:56,820 --> 00:05:59,820
and it's usually just safer to diebut

00:05:58,140 --> 00:06:06,540
programs don't always just die and

00:05:59,820 --> 00:06:08,460
things go awry but also we're not just

00:06:06,540 --> 00:06:10,229
also but I want the reason I think this

00:06:08,460 --> 00:06:11,370
is interesting is because faults are or

00:06:10,229 --> 00:06:15,120
I like to always I like to think of them

00:06:11,370 --> 00:06:16,590
as exploit primitives so here is like

00:06:15,120 --> 00:06:18,030
I'm this is this is code the probably

00:06:16,590 --> 00:06:19,710
doesn't occur in the real world but it

00:06:18,030 --> 00:06:20,910
takes the general form of code that does

00:06:19,710 --> 00:06:22,740
so you have some kind of like tied event

00:06:20,910 --> 00:06:25,530
loop where you're reading some data from

00:06:22,740 --> 00:06:26,760
a user or dude from some source you're

00:06:25,530 --> 00:06:27,870
performing some operations on it and

00:06:26,760 --> 00:06:29,310
you're passing it to some like

00:06:27,870 --> 00:06:32,289
serialization

00:06:29,310 --> 00:06:33,250
operation function and so what you

00:06:32,289 --> 00:06:35,650
really have here is you have a keeps

00:06:33,250 --> 00:06:37,270
beeps primitive combined with a read

00:06:35,650 --> 00:06:39,759
primitive combined with some

00:06:37,270 --> 00:06:42,789
serialization and each of these things

00:06:39,759 --> 00:06:44,650
individually is not a vulnerability but

00:06:42,789 --> 00:06:45,909
combined together you build up your heap

00:06:44,650 --> 00:06:49,360
spray you spray your heap full of you

00:06:45,909 --> 00:06:50,919
know bad bad yeah mold or whatever you

00:06:49,360 --> 00:06:52,620
fault read and all of a sudden you're

00:06:50,919 --> 00:06:54,819
doing orbit radius serialization and

00:06:52,620 --> 00:06:57,009
yamo in this case because it see

00:06:54,819 --> 00:07:00,009
probably isn't a huge issue but like you

00:06:57,009 --> 00:07:02,500
can imagine some serialization format

00:07:00,009 --> 00:07:06,060
that supports arbitrary calls or

00:07:02,500 --> 00:07:06,060
something so that could be pretty bad

00:07:06,449 --> 00:07:10,629
unfortunately for at least my purposes

00:07:08,800 --> 00:07:12,039
faults are rare

00:07:10,629 --> 00:07:13,419
even though normal programmers perform

00:07:12,039 --> 00:07:16,539
on the order of thousands to billions of

00:07:13,419 --> 00:07:18,759
sis calls as a testament to the

00:07:16,539 --> 00:07:21,580
stability of our kernels very few

00:07:18,759 --> 00:07:24,669
wouldn't fail and even fewer them fail

00:07:21,580 --> 00:07:26,650
predictably and of those ones that fell

00:07:24,669 --> 00:07:28,960
predictably even fewer them fail in ways

00:07:26,650 --> 00:07:32,439
that are sort of immediately obvious as

00:07:28,960 --> 00:07:34,449
exploitable so that makes sort of like

00:07:32,439 --> 00:07:37,930
just going out into the world and trying

00:07:34,449 --> 00:07:40,029
to make things fail really hard that

00:07:37,930 --> 00:07:42,159
being said they might not be as as rare

00:07:40,029 --> 00:07:43,779
as you think especially in our modern

00:07:42,159 --> 00:07:46,419
magical world of containers and

00:07:43,779 --> 00:07:48,580
namespaces and all these other things

00:07:46,419 --> 00:07:51,759
that are all of a sudden imposing very

00:07:48,580 --> 00:07:53,620
sensible limits on your processes in

00:07:51,759 --> 00:07:56,610
ways that the original programs weren't

00:07:53,620 --> 00:07:59,319
designed to consider so one thing that I

00:07:56,610 --> 00:08:00,669
find interesting as I like I look at a

00:07:59,319 --> 00:08:02,219
lot of a container a software from it

00:08:00,669 --> 00:08:04,479
for my job

00:08:02,219 --> 00:08:06,370
people often sort of like go willy-nilly

00:08:04,479 --> 00:08:08,379
and just containerized this old program

00:08:06,370 --> 00:08:11,099
that was not written with you know

00:08:08,379 --> 00:08:13,779
seccomp in mind and all of a sudden

00:08:11,099 --> 00:08:15,159
inherited resources like the the

00:08:13,779 --> 00:08:16,839
conditions around inherited resource has

00:08:15,159 --> 00:08:18,610
changed all of a sudden like this

00:08:16,839 --> 00:08:20,169
program can't open files that it assumed

00:08:18,610 --> 00:08:21,159
it could open and that and that's a

00:08:20,169 --> 00:08:24,400
fault that's something that actually

00:08:21,159 --> 00:08:26,699
could be predictably caused to fail by

00:08:24,400 --> 00:08:30,250
someone who has knowledge of the program

00:08:26,699 --> 00:08:31,599
similarly users do dumb things I mean

00:08:30,250 --> 00:08:33,849
like users love to unplug random

00:08:31,599 --> 00:08:36,490
peripherals when they stop working users

00:08:33,849 --> 00:08:39,729
like to like plug their monitor in over

00:08:36,490 --> 00:08:40,960
and over and over or you know eject hard

00:08:39,729 --> 00:08:43,780
drives and do other bad

00:08:40,960 --> 00:08:44,770
those things all calls faults Karn

00:08:43,780 --> 00:08:46,000
program is usually good and handle those

00:08:44,770 --> 00:08:47,740
faults in the kernel and propagate them

00:08:46,000 --> 00:08:50,800
correctly to user space user space

00:08:47,740 --> 00:08:53,200
programmers then ignore them so those

00:08:50,800 --> 00:08:55,360
are predictable sources of faults and

00:08:53,200 --> 00:08:58,090
then similarly because of like the UNIX

00:08:55,360 --> 00:09:00,400
user model any program that runs at the

00:08:58,090 --> 00:09:01,900
same user by default you know can club

00:09:00,400 --> 00:09:04,570
or other resources owned by that user so

00:09:01,900 --> 00:09:07,060
you know pipes shared memory shared

00:09:04,570 --> 00:09:08,800
objects things like that so those are

00:09:07,060 --> 00:09:12,310
all things we're like if I'm running as

00:09:08,800 --> 00:09:13,660
one program under a user and that user

00:09:12,310 --> 00:09:15,310
has another program that's running it

00:09:13,660 --> 00:09:17,110
also talks by some privilege socket or

00:09:15,310 --> 00:09:18,970
whatever to the kernel or to a more

00:09:17,110 --> 00:09:23,970
privileged user if I can reliably cause

00:09:18,970 --> 00:09:27,970
a fault and that program oops

00:09:23,970 --> 00:09:33,520
yeah maybe I can escalate my privileges

00:09:27,970 --> 00:09:36,310
that way but like I said because they

00:09:33,520 --> 00:09:38,190
are generally rare from a vulnerability

00:09:36,310 --> 00:09:40,060
and resiliency research purpose

00:09:38,190 --> 00:09:42,550
perspective I want to make them less

00:09:40,060 --> 00:09:44,920
rare what I'm actually doing like audits

00:09:42,550 --> 00:09:45,970
of programs and what that means that I

00:09:44,920 --> 00:09:48,610
don't actually want to wait for faults

00:09:45,970 --> 00:09:50,890
to happen I want to make them happen and

00:09:48,610 --> 00:09:52,030
so what's default injection this is like

00:09:50,890 --> 00:09:54,250
a common thing this is something that

00:09:52,030 --> 00:09:55,620
people been doing since the eighties and

00:09:54,250 --> 00:09:57,490
thankfully there are a ton of different

00:09:55,620 --> 00:09:59,350
really flexible approaches fault

00:09:57,490 --> 00:10:02,530
injection from within like the Linux

00:09:59,350 --> 00:10:04,510
ecosystem one that I've used a bunch for

00:10:02,530 --> 00:10:06,220
like forums where I have total control

00:10:04,510 --> 00:10:07,540
over the ecosystem is I'll just relink

00:10:06,220 --> 00:10:09,430
the program with faulty functions of

00:10:07,540 --> 00:10:11,650
wrappers so they'll have some LVM pass

00:10:09,430 --> 00:10:13,750
that just does the right thing for me

00:10:11,650 --> 00:10:15,100
and I'll have an output binary and it'll

00:10:13,750 --> 00:10:17,800
have faulty wrappers around my real

00:10:15,100 --> 00:10:19,170
functions but this isn't always great

00:10:17,800 --> 00:10:21,790
because I don't always have the source

00:10:19,170 --> 00:10:23,500
you also LD preload you're all probably

00:10:21,790 --> 00:10:24,970
familiar with LD preload you just use it

00:10:23,500 --> 00:10:28,720
interpose a library in front of your

00:10:24,970 --> 00:10:32,740
actual load linker path and bam you have

00:10:28,720 --> 00:10:34,120
a trap and finally we have like dynamic

00:10:32,740 --> 00:10:35,250
instrumentation methods and I'll go

00:10:34,120 --> 00:10:38,110
through a few of those and talk about

00:10:35,250 --> 00:10:40,120
why they're good why they're bad and why

00:10:38,110 --> 00:10:43,630
I went the route I did which is not

00:10:40,120 --> 00:10:46,360
necessarily a good reason but yeah so

00:10:43,630 --> 00:10:49,450
here's a to give some background here's

00:10:46,360 --> 00:10:50,920
a contrived dynamic linkage scenario and

00:10:49,450 --> 00:10:53,279
like obviously this is what dynamic link

00:10:50,920 --> 00:10:54,930
it really looks like but it helps

00:10:53,279 --> 00:10:57,060
visualization purposes so you know have

00:10:54,930 --> 00:10:58,499
you a view of your acro binary and

00:10:57,060 --> 00:11:00,360
inside of main it calls curly as he said

00:10:58,499 --> 00:11:01,920
opt and curlies a set up has this well

00:11:00,360 --> 00:11:03,720
defined set available failure conditions

00:11:01,920 --> 00:11:05,999
so it can either succeed and do you know

00:11:03,720 --> 00:11:07,439
curly okay or can fail for some reason

00:11:05,999 --> 00:11:11,189
and return you know under an option or

00:11:07,439 --> 00:11:12,660
whatever and those failure options are

00:11:11,189 --> 00:11:13,860
probably gonna occur this failure routes

00:11:12,660 --> 00:11:16,559
probably gonna occur pretty rarely in

00:11:13,860 --> 00:11:21,420
the real world so what I want to do is

00:11:16,559 --> 00:11:23,040
interpose my fake easy set opt and then

00:11:21,420 --> 00:11:24,509
apply some custom logic in this case

00:11:23,040 --> 00:11:27,749
really just an orangy it says oh with

00:11:24,509 --> 00:11:30,569
the RNG is zero I will bomb out with my

00:11:27,749 --> 00:11:33,480
unknown failure otherwise I will use

00:11:30,569 --> 00:11:35,029
deal sim to just go to the real easy set

00:11:33,480 --> 00:11:38,309
ops which will then perform its normal

00:11:35,029 --> 00:11:39,990
business as usual so that's you know

00:11:38,309 --> 00:11:42,600
it's really easy this is like a great

00:11:39,990 --> 00:11:44,339
way to do very like first level full

00:11:42,600 --> 00:11:50,850
objection or any sort of like dynamic

00:11:44,339 --> 00:11:52,290
interposition of functions okay so like

00:11:50,850 --> 00:11:54,029
I said this is conceptually really

00:11:52,290 --> 00:11:55,259
simple and it's really easy to use

00:11:54,029 --> 00:11:56,490
because all you have to do is that LD

00:11:55,259 --> 00:11:58,259
preload equals whatever your shared

00:11:56,490 --> 00:12:00,600
object is toss them in front your binary

00:11:58,259 --> 00:12:01,829
and off you go

00:12:00,600 --> 00:12:04,740
unfortunately this comes with a bunch of

00:12:01,829 --> 00:12:06,990
downsides one major one is that the year

00:12:04,740 --> 00:12:08,970
is 2019 and everybody loves Go Go a

00:12:06,990 --> 00:12:10,800
statically linked ODP load doesn't work

00:12:08,970 --> 00:12:13,649
with static functions because it doesn't

00:12:10,800 --> 00:12:18,029
use the dynamic linker Sattar functions

00:12:13,649 --> 00:12:19,829
don't hit the dynamic linker they don't

00:12:18,029 --> 00:12:21,000
work with sis call - or ASM intrinsics

00:12:19,829 --> 00:12:24,180
because again you're not actually

00:12:21,000 --> 00:12:26,670
calling the function in Lib C that gets

00:12:24,180 --> 00:12:28,019
dispatched eventually to the sis call LD

00:12:26,670 --> 00:12:29,160
preload is resistant is not actually

00:12:28,019 --> 00:12:31,470
interposing the syscall itself it's

00:12:29,160 --> 00:12:33,569
interposing the wrapper which in turn

00:12:31,470 --> 00:12:36,720
causes other problems like on intuitive

00:12:33,569 --> 00:12:39,449
interposition so as most you probably

00:12:36,720 --> 00:12:43,129
know open three is really open at 2 in G

00:12:39,449 --> 00:12:45,990
Lib C for 3 is really clone - there's a

00:12:43,129 --> 00:12:47,129
dozen plus other ones and this usually

00:12:45,990 --> 00:12:48,929
isn't an issue in terms of actually

00:12:47,129 --> 00:12:50,189
causing faults but it does cause issues

00:12:48,929 --> 00:12:51,389
when you're actually trying to go back

00:12:50,189 --> 00:12:54,509
and triage your faults and figure out

00:12:51,389 --> 00:12:56,370
what actually failed and then finally I

00:12:54,509 --> 00:12:56,699
hate maintaining state inside of LD

00:12:56,370 --> 00:12:57,870
preload

00:12:56,699 --> 00:13:00,209
I don't know about any of you but like

00:12:57,870 --> 00:13:03,209
every time I do it I break something I

00:13:00,209 --> 00:13:04,650
don't like thinking about it so not

00:13:03,209 --> 00:13:06,000
using it

00:13:04,650 --> 00:13:08,490
what else is there there's dynamic

00:13:06,000 --> 00:13:11,250
instrumentation Petrie's 2 is a really

00:13:08,490 --> 00:13:13,440
awesome Cisco but it's also really slow

00:13:11,250 --> 00:13:15,570
so I should say it's awesome there's a

00:13:13,440 --> 00:13:18,060
really good blog post by I think Chris

00:13:15,570 --> 00:13:20,790
Mullins on using P trace to intercept

00:13:18,060 --> 00:13:23,880
sis calls as well as you know a desist

00:13:20,790 --> 00:13:26,370
call within user space but because you

00:13:23,880 --> 00:13:28,500
have to impose I think it's a minimum of

00:13:26,370 --> 00:13:31,230
3 P trace calls for each sis call you

00:13:28,500 --> 00:13:34,230
interpose you're essentially adding a 3x

00:13:31,230 --> 00:13:35,970
overhead for every Cisco you make and

00:13:34,230 --> 00:13:37,680
also because you're actually activating

00:13:35,970 --> 00:13:39,810
P trace on your inferior process you

00:13:37,680 --> 00:13:42,810
can't easily debug that process with

00:13:39,810 --> 00:13:44,160
another de motor there's also dynamic is

00:13:42,810 --> 00:13:46,650
rotation frameworks there's dynamo Rio

00:13:44,160 --> 00:13:48,960
and Intel pin I have used these a bunch

00:13:46,650 --> 00:13:50,910
they're easy to use once you get to know

00:13:48,960 --> 00:13:52,830
them but their performance varies

00:13:50,910 --> 00:13:55,260
concerning ly their correctness varies

00:13:52,830 --> 00:13:56,430
depending on the host you're on and they

00:13:55,260 --> 00:13:58,740
take a long time to learn I can already

00:13:56,430 --> 00:14:01,170
familiar with them and then finally

00:13:58,740 --> 00:14:03,200
there's like as others have mentioned

00:14:01,170 --> 00:14:05,430
throughout this conference many many

00:14:03,200 --> 00:14:07,190
systems within the kernel for performing

00:14:05,430 --> 00:14:11,790
various forms of introspection

00:14:07,190 --> 00:14:13,740
interposition and hooking of sis calls

00:14:11,790 --> 00:14:16,050
and I think every single one of these

00:14:13,740 --> 00:14:19,170
except for maybe EBP F I can do what I

00:14:16,050 --> 00:14:21,060
want but unfortunately I am a bit of a

00:14:19,170 --> 00:14:24,150
Linux kernel noob so I don't know how to

00:14:21,060 --> 00:14:25,650
use any of these I know you can do this

00:14:24,150 --> 00:14:27,180
with set comp with a second fret err no

00:14:25,650 --> 00:14:29,460
I know you can do this with K probes

00:14:27,180 --> 00:14:31,680
somehow and I'm pretty sure you could do

00:14:29,460 --> 00:14:35,400
what else I'm hoax I just didn't try any

00:14:31,680 --> 00:14:36,360
of those sorry but among those is

00:14:35,400 --> 00:14:38,790
probably lots of like really good and

00:14:36,360 --> 00:14:40,800
fast approaches and I have to talk to a

00:14:38,790 --> 00:14:43,170
bunch of people I know to figure how to

00:14:40,800 --> 00:14:45,270
use them so the remaining question is

00:14:43,170 --> 00:14:47,910
can I can we do better than dynamic

00:14:45,270 --> 00:14:50,580
astron tation and can we do faster and

00:14:47,910 --> 00:14:52,140
the answer is yes with k RF and so I

00:14:50,580 --> 00:14:54,540
should say this is a bad approach you

00:14:52,140 --> 00:14:57,120
should never do this but I did it

00:14:54,540 --> 00:14:59,670
what care F does internally is it takes

00:14:57,120 --> 00:15:01,110
your sis call table and it replaces the

00:14:59,670 --> 00:15:03,030
slots of interest with faulty wrappers

00:15:01,110 --> 00:15:06,600
and if that sounds bad that's because it

00:15:03,030 --> 00:15:08,640
is bad inside of those wrappers if the

00:15:06,600 --> 00:15:10,560
call is targeted it redirects to a

00:15:08,640 --> 00:15:12,720
faulty sis call it returns based on

00:15:10,560 --> 00:15:14,580
another dispatch table some air no I

00:15:12,720 --> 00:15:16,510
want to generate this dispatch tables

00:15:14,580 --> 00:15:18,460
based on the man pages which

00:15:16,510 --> 00:15:21,130
you know the sort of acceptable falls

00:15:18,460 --> 00:15:22,660
for this is call if the call isn't

00:15:21,130 --> 00:15:25,030
interesting we were directed the normal

00:15:22,660 --> 00:15:26,830
Cisco and on module unload we just meant

00:15:25,030 --> 00:15:29,340
copy the original Cisco table back into

00:15:26,830 --> 00:15:31,870
place and everything precedes is normal

00:15:29,340 --> 00:15:34,060
so you know from a bird's eye view it

00:15:31,870 --> 00:15:36,160
looks like this we have this like wraps

00:15:34,060 --> 00:15:39,100
this read which performs some targeting

00:15:36,160 --> 00:15:40,240
check if that's Orion check is true we

00:15:39,100 --> 00:15:41,740
perform the real history and if it's

00:15:40,240 --> 00:15:43,810
false or you know invert or whatever

00:15:41,740 --> 00:15:45,010
returns a Fault in reality that would be

00:15:43,810 --> 00:15:47,440
a dispatch table that returns the real

00:15:45,010 --> 00:15:49,840
or no based on another targeting check

00:15:47,440 --> 00:15:51,430
I'm inside of our module in it we do a

00:15:49,840 --> 00:15:54,190
look about this is called table and then

00:15:51,430 --> 00:15:56,830
we just swap out that NR read which very

00:15:54,190 --> 00:15:58,480
bad don't do that but that looks like

00:15:56,830 --> 00:16:00,490
this from up from a high-level view so

00:15:58,480 --> 00:16:02,470
what we really have is like our runtime

00:16:00,490 --> 00:16:05,230
function call which would be F read or

00:16:02,470 --> 00:16:07,090
like Java neo read or you know some

00:16:05,230 --> 00:16:08,380
high-level language call which trickles

00:16:07,090 --> 00:16:10,390
down to like a G Lib C call to read

00:16:08,380 --> 00:16:13,480
three which eventually performs a sis

00:16:10,390 --> 00:16:16,030
call to to read to which will then hit

00:16:13,480 --> 00:16:18,160
our PRF sis read or Harris this we will

00:16:16,030 --> 00:16:19,510
perform a targeting check if it is not

00:16:18,160 --> 00:16:20,710
target it will dispatch the normal sis

00:16:19,510 --> 00:16:22,240
read if it is targeted will go to

00:16:20,710 --> 00:16:25,480
internals this read from there will

00:16:22,240 --> 00:16:27,070
perform an rng and either fault or you

00:16:25,480 --> 00:16:28,510
know one out of n times returning

00:16:27,070 --> 00:16:32,130
success just that we don't completely

00:16:28,510 --> 00:16:34,450
destroy every program we write under and

00:16:32,130 --> 00:16:35,590
this code is actually all macro it up

00:16:34,450 --> 00:16:38,020
but it's no longer like this because we

00:16:35,590 --> 00:16:39,640
drastically improved the code gen but

00:16:38,020 --> 00:16:42,910
what that looks like is just this all we

00:16:39,640 --> 00:16:46,030
do is we care have to find this break

00:16:42,910 --> 00:16:49,060
wrapper if it's targeted and we use it

00:16:46,030 --> 00:16:52,000
no longer we no longer using LCG better

00:16:49,060 --> 00:16:55,330
we use a better oranjee now but if

00:16:52,000 --> 00:16:58,690
targeted and some rng we perform a real

00:16:55,330 --> 00:17:03,010
or fake this coal and then if not

00:16:58,690 --> 00:17:04,329
perform our real one and i mentioned

00:17:03,010 --> 00:17:06,730
sort of glossed over targeting before

00:17:04,329 --> 00:17:09,550
but we actually support a variety of

00:17:06,730 --> 00:17:13,270
targeting strategies so a few nice ones

00:17:09,550 --> 00:17:14,530
are targeting by user or group ID so you

00:17:13,270 --> 00:17:17,050
know you can actually tell care if i

00:17:14,530 --> 00:17:18,940
want to fault every syscall performed by

00:17:17,050 --> 00:17:24,160
processes owned by this user by this

00:17:18,940 --> 00:17:26,079
group that makes it really easy to

00:17:24,160 --> 00:17:29,520
prototype faults like a big family

00:17:26,079 --> 00:17:30,809
processes that respond at once but

00:17:29,520 --> 00:17:32,010
you know there are multi process

00:17:30,809 --> 00:17:33,870
applications that have multiple sub

00:17:32,010 --> 00:17:36,210
users and so that has some extra hassle

00:17:33,870 --> 00:17:38,070
involved we can also currently target by

00:17:36,210 --> 00:17:39,809
process ID or i know'd or really

00:17:38,070 --> 00:17:42,090
anything that's available within that

00:17:39,809 --> 00:17:44,550
car instruct I'm exposed to rinse it's

00:17:42,090 --> 00:17:46,290
called context but my personal favorite

00:17:44,550 --> 00:17:51,059
is using personality too for this

00:17:46,290 --> 00:17:51,990
personality too is where personality to

00:17:51,059 --> 00:17:54,570
is this is called but there is a

00:17:51,990 --> 00:17:56,580
personality field inside I think it's

00:17:54,570 --> 00:17:59,070
the struct inside of the task struct

00:17:56,580 --> 00:18:00,000
which is allowed is used internally to

00:17:59,070 --> 00:18:02,490
dispatch the different rhythms of

00:18:00,000 --> 00:18:04,350
syscalls based on like I process its

00:18:02,490 --> 00:18:06,870
disposition so like you could run in

00:18:04,350 --> 00:18:10,490
theory a Sun OS or bsd process on linux

00:18:06,870 --> 00:18:12,809
and have a dispatch to like a version of

00:18:10,490 --> 00:18:14,610
malakut is different like i think this

00:18:12,809 --> 00:18:16,920
is actually used internally to fix the

00:18:14,610 --> 00:18:19,340
null page stuff for Sun OS because I

00:18:16,920 --> 00:18:22,050
think some of us has a valid mo page I

00:18:19,340 --> 00:18:23,429
might be misremembering that but another

00:18:22,050 --> 00:18:26,070
nice thing about personality too is that

00:18:23,429 --> 00:18:28,050
children actually inherit it so we can

00:18:26,070 --> 00:18:28,980
actually just exec off and all of our

00:18:28,050 --> 00:18:31,590
children will trickle down that

00:18:28,980 --> 00:18:36,090
personality and correctly be loaded into

00:18:31,590 --> 00:18:40,110
this multiple state for krf and so this

00:18:36,090 --> 00:18:41,220
is this is how I use it for I am sending

00:18:40,110 --> 00:18:45,059
you who are running like a colonel above

00:18:41,220 --> 00:18:47,910
I think 3.17 I think this is the one I

00:18:45,059 --> 00:18:49,530
need it's as simple as cloning on a repo

00:18:47,910 --> 00:18:52,020
they can make install and then make and

00:18:49,530 --> 00:18:53,250
Samad and then I'll go over a quick

00:18:52,020 --> 00:18:54,809
summary of each of these commands use

00:18:53,250 --> 00:18:58,320
from user space to actually manipulate

00:18:54,809 --> 00:19:00,690
krf I should say please do not run this

00:18:58,320 --> 00:19:02,100
on on real Hardware it is a rootkit it

00:19:00,690 --> 00:19:04,860
is a rootkit that rewrites your sis call

00:19:02,100 --> 00:19:06,090
table in unsafe ways it will break your

00:19:04,860 --> 00:19:07,620
hardware or not your heart will break

00:19:06,090 --> 00:19:09,750
it'll break your kernel build a

00:19:07,620 --> 00:19:12,630
stabilizer host we use it to find bugs

00:19:09,750 --> 00:19:14,640
but it's full of bugs itself so please

00:19:12,630 --> 00:19:17,390
please do me a favor and do yourself a

00:19:14,640 --> 00:19:19,980
favor and don't do that

00:19:17,390 --> 00:19:21,720
so you know from within the user space

00:19:19,980 --> 00:19:22,860
we have these three commands I didn't

00:19:21,720 --> 00:19:24,090
put care off message up here because all

00:19:22,860 --> 00:19:26,730
you really do is just run it and it will

00:19:24,090 --> 00:19:28,260
spit out logs but care if control can be

00:19:26,730 --> 00:19:29,940
used to actually set the parameters for

00:19:28,260 --> 00:19:30,990
the module so that includes things like

00:19:29,940 --> 00:19:32,640
setting a list of functions that you

00:19:30,990 --> 00:19:34,679
want to fall so you know in this case I

00:19:32,640 --> 00:19:37,260
set read write open and close as my

00:19:34,679 --> 00:19:39,870
foldable functions we also have a notion

00:19:37,260 --> 00:19:41,309
of profiles within PRF so if you want

00:19:39,870 --> 00:19:43,470
default every single sis call that we

00:19:41,309 --> 00:19:46,710
tagged has an IPC syscall so that's like

00:19:43,470 --> 00:19:50,309
I don't know axis B stuff you can do

00:19:46,710 --> 00:19:53,429
ticket be IPC you can fall to an entire

00:19:50,309 --> 00:19:55,110
process ID and also you can use this

00:19:53,429 --> 00:19:57,150
clear flag to just wipe out the syscall

00:19:55,110 --> 00:19:59,610
table state and return it's like a safe

00:19:57,150 --> 00:20:01,500
neutral state and then also we have this

00:19:59,610 --> 00:20:03,600
care of exec helper which all it really

00:20:01,500 --> 00:20:06,150
does is it sets personality sets some

00:20:03,600 --> 00:20:09,660
more limits and then execs off to make

00:20:06,150 --> 00:20:10,620
the process foldable under of krf and

00:20:09,660 --> 00:20:11,790
you don't actually need that unless

00:20:10,620 --> 00:20:13,320
you're actually using the personality

00:20:11,790 --> 00:20:15,840
faulting mode if you're just using like

00:20:13,320 --> 00:20:17,760
the UID or GID mode or whatever you can

00:20:15,840 --> 00:20:23,040
just run the program as normal and care

00:20:17,760 --> 00:20:25,200
F will pick it up and I sort of like

00:20:23,040 --> 00:20:27,510
glaze over this before but does this

00:20:25,200 --> 00:20:28,760
care of actually work and the answers

00:20:27,510 --> 00:20:32,130
are both yes and no

00:20:28,760 --> 00:20:33,660
krf fine hat so we've used it on our

00:20:32,130 --> 00:20:35,660
actual audits we do a lot of audits of

00:20:33,660 --> 00:20:38,040
smart contracts as well as audits of

00:20:35,660 --> 00:20:42,780
code that interacts heavily with user

00:20:38,040 --> 00:20:44,309
space basically just systems code we

00:20:42,780 --> 00:20:45,780
have used it successfully to find

00:20:44,309 --> 00:20:47,640
vulnerabilities in native components

00:20:45,780 --> 00:20:48,780
during smart contract audits we've also

00:20:47,640 --> 00:20:50,610
used it to find an auto service

00:20:48,780 --> 00:20:52,470
vulnerability or a weakness rather in

00:20:50,610 --> 00:20:54,960
kubernetes during trilobites audit which

00:20:52,470 --> 00:20:56,309
some of you may have seen and I'd like

00:20:54,960 --> 00:20:57,809
to give a special shout out to bobby

00:20:56,309 --> 00:21:00,660
tonic for doing that one because he

00:20:57,809 --> 00:21:04,260
wrote all of the instrumentation to make

00:21:00,660 --> 00:21:05,429
it run under kubernetes but also things

00:21:04,260 --> 00:21:07,830
there are things about clear effort or

00:21:05,429 --> 00:21:10,140
not ideal for one it trashes programs

00:21:07,830 --> 00:21:11,250
and unrealistic ways like your average

00:21:10,140 --> 00:21:12,660
read is not gonna fail

00:21:11,250 --> 00:21:16,290
but care F makes the average read fail

00:21:12,660 --> 00:21:18,540
care F will make things that will almost

00:21:16,290 --> 00:21:21,300
never fail in the real world fail it

00:21:18,540 --> 00:21:22,200
will find bugs there are real bugs in

00:21:21,300 --> 00:21:24,570
the sense that they are things that you

00:21:22,200 --> 00:21:25,650
should have handled but aren't fake bugs

00:21:24,570 --> 00:21:27,809
in the sense that they will almost never

00:21:25,650 --> 00:21:29,309
actually happen so that's something that

00:21:27,809 --> 00:21:31,380
we've been working on from a triage

00:21:29,309 --> 00:21:32,790
perspective so right now what care F

00:21:31,380 --> 00:21:33,990
does it spits out seg faults and

00:21:32,790 --> 00:21:35,970
courtrooms like nobody's business and

00:21:33,990 --> 00:21:36,990
then we have this giant pipeline that I

00:21:35,970 --> 00:21:39,480
actually had an intern work on this

00:21:36,990 --> 00:21:40,620
summer triaging those those core dumps

00:21:39,480 --> 00:21:42,690
and figuring out whether or not this is

00:21:40,620 --> 00:21:45,390
actually a realistic crash given like

00:21:42,690 --> 00:21:46,110
real-world conditions and they've made

00:21:45,390 --> 00:21:48,570
really

00:21:46,110 --> 00:21:50,130
some that and all share some of their

00:21:48,570 --> 00:21:57,420
analysis work if you want to come up and

00:21:50,130 --> 00:21:59,720
talk later but thank you that's it any

00:21:57,420 --> 00:21:59,720
questions

00:22:05,910 --> 00:22:11,230
um if you look at all the the fault

00:22:09,040 --> 00:22:13,480
injection system in the kernel it

00:22:11,230 --> 00:22:15,820
doesn't cover syscalls right so it'd be

00:22:13,480 --> 00:22:17,440
interesting to see if you could attach

00:22:15,820 --> 00:22:18,850
to that in some way or I don't know it

00:22:17,440 --> 00:22:20,380
wasn't mentioned anywhere here so I

00:22:18,850 --> 00:22:21,850
thought probably you've looked at it but

00:22:20,380 --> 00:22:23,650
I'm curious what you found when you were

00:22:21,850 --> 00:22:25,300
looking for it yeah when I was doing the

00:22:23,650 --> 00:22:26,620
initial write I did take a look at it

00:22:25,300 --> 00:22:27,910
and the first thing I saw was it wasn't

00:22:26,620 --> 00:22:29,980
connected directly to syscalls

00:22:27,910 --> 00:22:32,230
and so I might have incorrectly ignored

00:22:29,980 --> 00:22:34,030
it based on that initial apprehension

00:22:32,230 --> 00:22:38,410
but that is something I definitely

00:22:34,030 --> 00:22:40,240
should take another look at so so you

00:22:38,410 --> 00:22:42,700
were saying you use an RNG to decide

00:22:40,240 --> 00:22:46,330
when to fall things but it looks like

00:22:42,700 --> 00:22:48,220
based on your targeting I what I'm

00:22:46,330 --> 00:22:51,070
interested in is is there a way to see

00:22:48,220 --> 00:22:53,200
that RNG with a predictable value so

00:22:51,070 --> 00:22:55,720
that you can reproduce the exact failure

00:22:53,200 --> 00:22:57,040
failure path and know exactly when the

00:22:55,720 --> 00:22:59,860
process is going to launch at which

00:22:57,040 --> 00:23:01,330
index yeah so we do we do support

00:22:59,860 --> 00:23:03,310
exactly that we actually have a profess

00:23:01,330 --> 00:23:04,870
node exposed okay we're setting the seed

00:23:03,310 --> 00:23:08,040
and then you can just go off and

00:23:04,870 --> 00:23:08,040
reproduce crash okay

00:23:11,630 --> 00:23:19,700
yes is it is it correct that most of the

00:23:15,860 --> 00:23:22,789
time or maybe all the time the result of

00:23:19,700 --> 00:23:25,760
this is a crash is that normally what

00:23:22,789 --> 00:23:27,980
you're looking for or could could there

00:23:25,760 --> 00:23:30,080
be other errors that don't cause the seg

00:23:27,980 --> 00:23:32,929
fault but are still problems that need

00:23:30,080 --> 00:23:35,330
to be fixed and if there are how do you

00:23:32,929 --> 00:23:37,640
find those how do you find out that it

00:23:35,330 --> 00:23:39,590
happened yeah that that is a really good

00:23:37,640 --> 00:23:42,200
question because right now our current

00:23:39,590 --> 00:23:43,700
triage system assumes that a seg fault

00:23:42,200 --> 00:23:48,200
or at least something the produces a

00:23:43,700 --> 00:23:49,909
core dump is tied to you know bad

00:23:48,200 --> 00:23:51,110
behavior whereas you're completely

00:23:49,909 --> 00:23:52,309
correct a program could incorrectly

00:23:51,110 --> 00:23:53,870
handle a fault and go on and do

00:23:52,309 --> 00:23:56,750
something wrong internally without ever

00:23:53,870 --> 00:23:59,299
crashing that is something that would

00:23:56,750 --> 00:24:01,159
involve possibly instrumenting the

00:23:59,299 --> 00:24:04,280
program with like LLVM or something to

00:24:01,159 --> 00:24:07,549
determine whether or not there I have a

00:24:04,280 --> 00:24:13,960
few different ideas there for handling

00:24:07,549 --> 00:24:13,960
those kind of cases that go back to the

00:24:21,210 --> 00:24:24,020
nobody else

00:24:25,390 --> 00:24:31,040
what what about faulting like coverage

00:24:29,450 --> 00:24:32,750
like sort of walking through a program

00:24:31,040 --> 00:24:34,429
faulty in different places

00:24:32,750 --> 00:24:36,710
yeah that's not something I thought

00:24:34,429 --> 00:24:38,480
about it's not something that care off

00:24:36,710 --> 00:24:40,730
currently supports right now it is like

00:24:38,480 --> 00:24:42,440
a haphazard random choice of Siskel's

00:24:40,730 --> 00:24:43,970
and as a result you actually get pretty

00:24:42,440 --> 00:24:46,730
bad coverage because you end up faulting

00:24:43,970 --> 00:24:50,110
things early on in program execution

00:24:46,730 --> 00:24:52,610
which then cause unconditional abort

00:24:50,110 --> 00:24:54,260
so I think the solution there would be

00:24:52,610 --> 00:24:56,420
to like I've been thinking about ways to

00:24:54,260 --> 00:24:58,370
target areas of interest within a

00:24:56,420 --> 00:25:00,559
program and then defer faulting until

00:24:58,370 --> 00:25:03,650
that at that point that estimate for a

00:25:00,559 --> 00:25:05,480
future investigation yeah I think that

00:25:03,650 --> 00:25:07,880
I'm thinking the same type of thing that

00:25:05,480 --> 00:25:10,760
you asked and I'm wondering if rather

00:25:07,880 --> 00:25:14,090
than using random numbers you could say

00:25:10,760 --> 00:25:16,730
you know on the thousandth or 10,000

00:25:14,090 --> 00:25:18,320
right because that way you get if you do

00:25:16,730 --> 00:25:22,340
with a random number you may not get

00:25:18,320 --> 00:25:24,710
deep into the program yeah so I guess I

00:25:22,340 --> 00:25:28,400
didn't the demos didn't fully show but

00:25:24,710 --> 00:25:29,900
there are two parts pieces of state and

00:25:28,400 --> 00:25:31,309
choose there are three pieces of say

00:25:29,900 --> 00:25:33,290
that determine targeting there's the

00:25:31,309 --> 00:25:36,110
targeting mode which can be you ad PID

00:25:33,290 --> 00:25:38,450
or whatever there is the RNG and then

00:25:36,110 --> 00:25:40,309
there's also a probability State so I

00:25:38,450 --> 00:25:43,250
think the default probability is one out

00:25:40,309 --> 00:25:45,890
of one 100 also targeted by RNG calls

00:25:43,250 --> 00:25:47,720
get faulted and just based on like

00:25:45,890 --> 00:25:48,920
fussing with this thing in the real

00:25:47,720 --> 00:25:52,220
world that's producing pretty acceptable

00:25:48,920 --> 00:25:53,450
coverage but I think a better solution

00:25:52,220 --> 00:25:56,179
would be to have actual individual

00:25:53,450 --> 00:25:58,610
ratios for sis calls so like fall to one

00:25:56,179 --> 00:25:58,820
out of every 10,000 reads or what have

00:25:58,610 --> 00:26:02,350
you

00:25:58,820 --> 00:26:02,350
sounds like a future improvement

00:26:04,720 --> 00:26:07,910
it's like no more questions thank you

00:26:07,280 --> 00:26:14,189
thank you

00:26:07,910 --> 00:26:14,189

YouTube URL: https://www.youtube.com/watch?v=XNNYL8YEzmE


