Title: Application Whitelisting - Steven Grubb, Red Hat
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Application Whitelisting - Steven Grubb, Red Hat

Application whitelisting is an effective way of preventing unknown software from executing on a machine. This presentation will detail an open source implementation. We will talk about the various ways that applications could be executed and how to design policy. We will also look at how the information from an application whitelisting daemon can be leveraged in real time to maintain system integrity. An overall strategy will be outlined showing how this piece fits into a broader security context.
Captions: 
	00:00:00,030 --> 00:00:06,150
yes it's everybody I know hello again

00:00:03,210 --> 00:00:09,179
and to everybody I haven't met let's

00:00:06,150 --> 00:00:11,849
talk some time my name is Steve Grubb

00:00:09,179 --> 00:00:14,330
I'm a security architect at Red Hat and

00:00:11,849 --> 00:00:18,199
I work on Red Hat Enterprise Linux

00:00:14,330 --> 00:00:21,210
primarily looking at security for

00:00:18,199 --> 00:00:28,590
certifications such as Common Criteria

00:00:21,210 --> 00:00:30,779
Phipps s cap and other things we do so

00:00:28,590 --> 00:00:33,540
this talk is gonna be about application

00:00:30,779 --> 00:00:38,250
whitelisting and we're gonna dig into

00:00:33,540 --> 00:00:41,010
some interesting topics along the way so

00:00:38,250 --> 00:00:55,070
this was the the outline of what we're

00:00:41,010 --> 00:00:55,070
gonna be talking about yes oh okay okay

00:00:55,460 --> 00:00:59,609
so what we're gonna talk about here is

00:00:58,199 --> 00:01:00,379
you know what is application

00:00:59,609 --> 00:01:03,180
whitelisting

00:01:00,379 --> 00:01:05,489
compare it to other solutions how code

00:01:03,180 --> 00:01:08,369
executes we're gonna talk about the

00:01:05,489 --> 00:01:10,080
design of a solution talk about sources

00:01:08,369 --> 00:01:17,009
of trust and how this might fit into an

00:01:10,080 --> 00:01:18,840
overall system design so a couple years

00:01:17,009 --> 00:01:25,369
ago nist

00:01:18,840 --> 00:01:25,369
released a special publication 800-53

00:01:29,840 --> 00:01:34,049
and talks about different things that

00:01:32,610 --> 00:01:36,420
application whitelisting should take

00:01:34,049 --> 00:01:37,770
into account and so the way that they

00:01:36,420 --> 00:01:39,799
define whitelist

00:01:37,770 --> 00:01:42,450
is it's the list of applications

00:01:39,799 --> 00:01:44,880
libraries or files that's authorized to

00:01:42,450 --> 00:01:49,110
be present or active based on a

00:01:44,880 --> 00:01:51,720
well-defined baseline a blacklist is a

00:01:49,110 --> 00:01:53,009
list of discrete entities previously

00:01:51,720 --> 00:01:56,939
determined to be associated with

00:01:53,009 --> 00:01:59,310
malicious activity so permitted activity

00:01:56,939 --> 00:02:01,079
is corresponds to a whitelist and not

00:01:59,310 --> 00:02:06,810
permitted activity corresponds to a

00:02:01,079 --> 00:02:09,989
blacklist also Common Criteria

00:02:06,810 --> 00:02:12,410
has an optional requirement

00:02:09,989 --> 00:02:17,430
that's the software restriction policies

00:02:12,410 --> 00:02:20,360
where you may elect one of several ways

00:02:17,430 --> 00:02:24,050
to restrict the execution of software

00:02:20,360 --> 00:02:26,250
some some people use digital signatures

00:02:24,050 --> 00:02:34,709
you can also use hash or you can use

00:02:26,250 --> 00:02:37,739
file paths antivirus is a blacklisting

00:02:34,709 --> 00:02:39,930
approach you know it defines you know

00:02:37,739 --> 00:02:41,700
the malware but you know the problem

00:02:39,930 --> 00:02:45,959
with it is there's much more out there

00:02:41,700 --> 00:02:48,780
that we don't know about so you know

00:02:45,959 --> 00:02:51,840
mandatory access control usually

00:02:48,780 --> 00:02:53,849
restricts based on behavior and subject

00:02:51,840 --> 00:02:57,390
object rules around information flow and

00:02:53,849 --> 00:03:00,360
access provenance of software is really

00:02:57,390 --> 00:03:02,849
not taken into account application

00:03:00,360 --> 00:03:05,489
whitelisting there's a different

00:03:02,849 --> 00:03:07,680
approach where you tell it this is the

00:03:05,489 --> 00:03:09,480
things we know about which is simpler to

00:03:07,680 --> 00:03:16,950
say because usually you know what's

00:03:09,480 --> 00:03:19,260
installed on a system so if you take a

00:03:16,950 --> 00:03:25,079
look at the Lockheed Martin kill chain

00:03:19,260 --> 00:03:26,639
and or the the mitre attack system you

00:03:25,079 --> 00:03:29,790
know which describes you know the way

00:03:26,639 --> 00:03:32,190
that intrusions happen and what they try

00:03:29,790 --> 00:03:34,650
to do the place where application

00:03:32,190 --> 00:03:37,829
whitelisting sits is right between

00:03:34,650 --> 00:03:39,480
compromise and execution and that's

00:03:37,829 --> 00:03:42,569
that's the area that we're that we're

00:03:39,480 --> 00:03:45,150
able to target coincidentally should

00:03:42,569 --> 00:03:46,349
they get past execution then you know

00:03:45,150 --> 00:03:54,810
we'd be targeting everything on the

00:03:46,349 --> 00:03:56,099
right-hand side also okay so one of the

00:03:54,810 --> 00:04:00,450
things we need to think about is you

00:03:56,099 --> 00:04:02,280
know how how programs execute usually

00:04:00,450 --> 00:04:05,340
they start you know with an exec ve you

00:04:02,280 --> 00:04:08,160
know which calls the kernel and it opens

00:04:05,340 --> 00:04:10,169
a file loads it passes it to the runtime

00:04:08,160 --> 00:04:12,720
linker it resolves the libraries and

00:04:10,169 --> 00:04:16,799
then you know it jumps to me and takes

00:04:12,720 --> 00:04:20,099
off but there's also another trick

00:04:16,799 --> 00:04:21,299
and that is you can execute elf files

00:04:20,099 --> 00:04:23,840
directly from the run

00:04:21,299 --> 00:04:27,780
I'm linker and so like if you have

00:04:23,840 --> 00:04:31,770
something that's mounted read-only or no

00:04:27,780 --> 00:04:33,120
with the no execute this is a trick that

00:04:31,770 --> 00:04:36,090
people have used in the past where you

00:04:33,120 --> 00:04:38,129
can just download download it there's a

00:04:36,090 --> 00:04:39,690
read-only file and then you can use the

00:04:38,129 --> 00:04:42,449
runtime linker to execute it because

00:04:39,690 --> 00:04:44,039
runtime linker just reads the file it

00:04:42,449 --> 00:04:45,930
doesn't try to execute it but you know

00:04:44,039 --> 00:04:50,069
later it does but it doesn't do it

00:04:45,930 --> 00:04:52,919
through an exec ve other ways that you

00:04:50,069 --> 00:04:57,300
can force execution is by using LD

00:04:52,919 --> 00:04:58,979
preload and there's several viruses that

00:04:57,300 --> 00:05:01,349
take advantage of this and so once it

00:04:58,979 --> 00:05:03,599
once it gets loaded it passes it on to

00:05:01,349 --> 00:05:06,120
every child process and if it gets into

00:05:03,599 --> 00:05:08,060
the user session then you know can do

00:05:06,120 --> 00:05:10,710
things against your account

00:05:08,060 --> 00:05:14,099
there's also another variable called LD

00:05:10,710 --> 00:05:15,659
audit which is a cleaner version of LD

00:05:14,099 --> 00:05:19,860
preload but you know the effect is the

00:05:15,659 --> 00:05:22,020
same that you intercept the runtime

00:05:19,860 --> 00:05:25,529
linker I mean with with LD audit you can

00:05:22,020 --> 00:05:28,979
do a lot more damage because it allows

00:05:25,529 --> 00:05:31,159
you to intercept all of the the runtime

00:05:28,979 --> 00:05:34,500
linking and setting up and you can

00:05:31,159 --> 00:05:36,860
redefine the functions so you know it's

00:05:34,500 --> 00:05:40,279
a it's a formidable tool to know about

00:05:36,860 --> 00:05:44,580
and another way that things can execute

00:05:40,279 --> 00:05:49,250
is that somebody can go change the elf

00:05:44,580 --> 00:05:53,069
interpreter embedded inside these files

00:05:49,250 --> 00:05:57,779
is the preferred interpreter and usually

00:05:53,069 --> 00:05:59,069
it points to LD Linux dot s o but it

00:05:57,779 --> 00:06:02,099
doesn't have to you know it's something

00:05:59,069 --> 00:06:04,430
you can define at compile time so what

00:06:02,099 --> 00:06:08,610
you can do is you can have a legal

00:06:04,430 --> 00:06:11,129
program but the elf interpreters changed

00:06:08,610 --> 00:06:13,500
and instead of doing runtime linking a

00:06:11,129 --> 00:06:15,750
malicious interpreter just takes off and

00:06:13,500 --> 00:06:17,430
does malicious things so it looks like

00:06:15,750 --> 00:06:20,580
you're executing one thing but you're

00:06:17,430 --> 00:06:23,310
really executing something else another

00:06:20,580 --> 00:06:24,990
way that program is executed is you know

00:06:23,310 --> 00:06:27,840
through language interpreters you know

00:06:24,990 --> 00:06:30,020
such as Python Perl awk other things

00:06:27,840 --> 00:06:32,550
like that

00:06:30,020 --> 00:06:35,580
so that's that's the traditional ways

00:06:32,550 --> 00:06:39,600
but there's also much more malicious

00:06:35,580 --> 00:06:42,690
ways of executing code and that's the

00:06:39,600 --> 00:06:44,490
mobile code and when you execute through

00:06:42,690 --> 00:06:47,190
mobile code yeah we're talking about

00:06:44,490 --> 00:06:50,430
piping things into standard in to be

00:06:47,190 --> 00:06:52,259
executed you can you can also pass

00:06:50,430 --> 00:06:56,570
programs you know as command-line

00:06:52,259 --> 00:07:00,539
arguments I think you have up to 4096

00:06:56,570 --> 00:07:03,630
characters on the command line which you

00:07:00,539 --> 00:07:06,060
know that could be a small program that

00:07:03,630 --> 00:07:11,639
could bootstrap itself into you know

00:07:06,060 --> 00:07:16,919
other other things then there's remote

00:07:11,639 --> 00:07:19,830
fetching like like what Python does you

00:07:16,919 --> 00:07:22,410
can override and redefine the module

00:07:19,830 --> 00:07:26,400
import so that it pulls Python code

00:07:22,410 --> 00:07:28,620
across the network and another thing

00:07:26,400 --> 00:07:31,590
that you can do with Python is that it

00:07:28,620 --> 00:07:33,780
can call arbitrary system calls and so

00:07:31,590 --> 00:07:37,560
what you can do is you can open you know

00:07:33,780 --> 00:07:40,110
with mfv create download something into

00:07:37,560 --> 00:07:41,940
that and then execute you know basically

00:07:40,110 --> 00:07:46,650
yeah and you know never touches disk

00:07:41,940 --> 00:07:48,150
it's entirely in memory another thing is

00:07:46,650 --> 00:07:54,840
you can just paste the program straight

00:07:48,150 --> 00:07:58,909
into the shell and here's an example you

00:07:54,840 --> 00:07:58,909
know of some of this this mobile code

00:07:59,060 --> 00:08:05,250
this is this is a function that's

00:08:02,039 --> 00:08:08,400
written in bash and this is functionally

00:08:05,250 --> 00:08:12,330
equivalent to the W get command but it's

00:08:08,400 --> 00:08:13,889
entirely in bash because somewhere along

00:08:12,330 --> 00:08:18,570
the line somebody desired that was a

00:08:13,889 --> 00:08:27,720
good idea to have bash to do tcp/ip it

00:08:18,570 --> 00:08:30,470
can also do just IP if you are an

00:08:27,720 --> 00:08:32,820
attacker and you get to a shell and

00:08:30,470 --> 00:08:35,370
you're in a container and it's mounted

00:08:32,820 --> 00:08:38,159
read-only they're still going to get you

00:08:35,370 --> 00:08:40,950
and the reason why is because of this if

00:08:38,159 --> 00:08:42,289
they have access to bash they can pull

00:08:40,950 --> 00:08:45,930
down anything

00:08:42,289 --> 00:08:49,980
as a matter of fact I can show you

00:08:45,930 --> 00:08:52,170
something here we can this is a white

00:08:49,980 --> 00:09:03,020
hat talk but we can do black hat for a

00:08:52,170 --> 00:09:03,020
little while so here we got a bash shell

00:09:03,380 --> 00:09:12,980
let me see here

00:09:05,510 --> 00:09:18,980
just close so here's the function that

00:09:12,980 --> 00:09:22,529
you can just paste right into the shell

00:09:18,980 --> 00:09:24,330
and so if you're a bad guy yeah you can

00:09:22,529 --> 00:09:33,720
you can paste this right down yeah you

00:09:24,330 --> 00:09:36,330
get a shell that reversed shell and now

00:09:33,720 --> 00:09:39,089
you got you got the function okay so

00:09:36,330 --> 00:09:42,440
there's something there let's just uh

00:09:39,089 --> 00:09:42,440
let's just source it just to make sure

00:09:44,810 --> 00:09:47,810
now

00:09:51,400 --> 00:10:00,230
I've already got something set up here

00:09:53,660 --> 00:10:04,370
so entirely using bash right there it

00:10:00,230 --> 00:10:06,740
can pull down a Python script and if you

00:10:04,370 --> 00:10:14,050
go and just pipe that right in the

00:10:06,740 --> 00:10:14,050
Python then let's pull up another

00:10:24,450 --> 00:10:33,480
and you can see right there on port 8080

00:10:27,209 --> 00:10:35,660
we have a server so you this never touch

00:10:33,480 --> 00:10:37,620
a desk this came off the internet

00:10:35,660 --> 00:10:41,850
there's there's other things that you

00:10:37,620 --> 00:10:44,060
can do like for example here's another

00:10:41,850 --> 00:10:44,060
one

00:10:44,959 --> 00:10:48,350
wasn't W get

00:10:55,920 --> 00:11:02,609
that's right double you get okay so this

00:11:01,290 --> 00:11:04,399
just pulled another program off of the

00:11:02,609 --> 00:11:07,350
internet and this is this is the bad one

00:11:04,399 --> 00:11:08,970
what what this one does it this is a

00:11:07,350 --> 00:11:12,749
program called Snake Eater and you can

00:11:08,970 --> 00:11:16,999
find this out on github what this does

00:11:12,749 --> 00:11:19,609
is it creates an Earl to a shared object

00:11:16,999 --> 00:11:24,839
next thing it does is it opens it right

00:11:19,609 --> 00:11:28,160
here yeah and it does that by making an

00:11:24,839 --> 00:11:32,790
arbitrary system call you know to create

00:11:28,160 --> 00:11:35,399
MFD or MFD create so then what it does

00:11:32,790 --> 00:11:40,939
is it reads it and then down and then

00:11:35,399 --> 00:11:45,389
down here it sets a path to this FD and

00:11:40,939 --> 00:11:48,660
then it executes it and so here's a you

00:11:45,389 --> 00:11:51,779
know a quick demonstration again of a

00:11:48,660 --> 00:11:56,730
program in Python that pulls down a

00:11:51,779 --> 00:11:59,879
shared object and executes it so you can

00:11:56,730 --> 00:12:02,519
run arbitrary elf code using something

00:11:59,879 --> 00:12:09,169
like Snake Eater and it never touches

00:12:02,519 --> 00:12:09,169
disk ok so let's go back to white hat

00:12:13,750 --> 00:12:19,010
okay so you know this is just uh some

00:12:17,690 --> 00:12:22,700
objectives that you know an attacker

00:12:19,010 --> 00:12:24,560
made may try to do but you know we can

00:12:22,700 --> 00:12:26,270
narrow that down a little bit for this

00:12:24,560 --> 00:12:28,880
talk and say that you know without

00:12:26,270 --> 00:12:31,160
privileges what you can probably do is

00:12:28,880 --> 00:12:34,430
you know download malicious escalation

00:12:31,160 --> 00:12:36,890
tools you can change search paths for an

00:12:34,430 --> 00:12:38,990
account so that it's it's trying to

00:12:36,890 --> 00:12:41,480
resolve things out of you know an

00:12:38,990 --> 00:12:43,730
attacker controlled directory and you

00:12:41,480 --> 00:12:46,130
can ransomware the account with

00:12:43,730 --> 00:12:48,290
privileges you can modify and replace

00:12:46,130 --> 00:12:49,880
applications or libraries you can

00:12:48,290 --> 00:12:51,680
install new applications

00:12:49,880 --> 00:12:54,380
you know backdoors rootkits ransomware

00:12:51,680 --> 00:12:56,589
crypto miners everything or you can

00:12:54,380 --> 00:13:06,890
inject malware into a running process

00:12:56,589 --> 00:13:07,040
using P trace okay so with all this you

00:13:06,890 --> 00:13:09,290
know

00:13:07,040 --> 00:13:10,580
let's we're gonna start thinking about

00:13:09,290 --> 00:13:14,330
you know a solution to try and catch

00:13:10,580 --> 00:13:15,770
these things there is an API that the

00:13:14,330 --> 00:13:17,839
kernel has called file access

00:13:15,770 --> 00:13:22,430
notifications and it's been available

00:13:17,839 --> 00:13:24,020
since the the 2.6 dot 37 kernel and it

00:13:22,430 --> 00:13:27,500
allows recursive monitoring within a

00:13:24,020 --> 00:13:29,750
mount point it allows the user space

00:13:27,500 --> 00:13:33,380
application to say yes or no you know

00:13:29,750 --> 00:13:36,050
I'm an access or execution and the

00:13:33,380 --> 00:13:39,170
kernel hands an open descriptor of the

00:13:36,050 --> 00:13:41,209
file to the monitor program so they can

00:13:39,170 --> 00:13:46,940
read it and just was originally designed

00:13:41,209 --> 00:13:49,100
for antivirus it has a couple drawbacks

00:13:46,940 --> 00:13:55,959
that you don't get any notifications on

00:13:49,100 --> 00:14:00,320
deletes or renames or file moves and

00:13:55,959 --> 00:14:03,980
this is you know just to show you what

00:14:00,320 --> 00:14:06,290
what you get when you do the eff egg if

00:14:03,980 --> 00:14:09,339
they notify in it and then you set a

00:14:06,290 --> 00:14:12,589
mark is eventually you get a callback

00:14:09,339 --> 00:14:15,910
and the the data that comes to you is in

00:14:12,589 --> 00:14:15,910
this this structure right here

00:14:17,000 --> 00:14:21,889
so the two interesting things that that

00:14:19,699 --> 00:14:25,250
we're interested in is that you get an

00:14:21,889 --> 00:14:27,829
FD to the file and it's open

00:14:25,250 --> 00:14:30,290
so chickens inspect the file but you

00:14:27,829 --> 00:14:34,550
also get the PID of the the program

00:14:30,290 --> 00:14:36,889
that's trying to open the file so from

00:14:34,550 --> 00:14:40,730
the PFD we can we can gather some

00:14:36,889 --> 00:14:43,220
information about the file we can take a

00:14:40,730 --> 00:14:46,100
look at what the file is full path is by

00:14:43,220 --> 00:14:52,430
using read link against you know proc

00:14:46,100 --> 00:14:55,040
self FD we can also take a look at what

00:14:52,430 --> 00:14:58,129
the type of the file is by passing the

00:14:55,040 --> 00:15:00,829
descriptor to Lib magic so you know from

00:14:58,129 --> 00:15:02,600
from this API you can figure out this is

00:15:00,829 --> 00:15:06,379
a Perl program this is Python this is

00:15:02,600 --> 00:15:11,180
Ruby this is PHP this is elf and or just

00:15:06,379 --> 00:15:13,819
a text file we can also figure out what

00:15:11,180 --> 00:15:18,620
device it's on through the you dev

00:15:13,819 --> 00:15:21,139
library we can also figure out a trust

00:15:18,620 --> 00:15:22,910
status by looking it up you know once we

00:15:21,139 --> 00:15:24,019
got the path we can look it up in a

00:15:22,910 --> 00:15:26,990
database and see if this is something

00:15:24,019 --> 00:15:31,040
that we know about and we can also

00:15:26,990 --> 00:15:37,339
calculate our sha-256 hash of it using

00:15:31,040 --> 00:15:40,430
Lib G crypt we can also get some other

00:15:37,339 --> 00:15:42,350
information about the subject the FD

00:15:40,430 --> 00:15:44,389
obviously you know is information about

00:15:42,350 --> 00:15:48,250
the object well we can get information

00:15:44,389 --> 00:15:50,839
about the subject by looking at the PID

00:15:48,250 --> 00:15:53,350
we can go into the proc the proc file

00:15:50,839 --> 00:15:56,059
system and we can pull out what the the

00:15:53,350 --> 00:15:58,550
command name is we can pull out the

00:15:56,059 --> 00:16:02,949
executable we can figure out what type

00:15:58,550 --> 00:16:06,860
it is by by passing that into Lib magic

00:16:02,949 --> 00:16:10,040
we can also figure out the UID the login

00:16:06,860 --> 00:16:14,959
UID and the session ID and the proc file

00:16:10,040 --> 00:16:18,559
system also so with these these

00:16:14,959 --> 00:16:22,009
primitives and and you know attributes

00:16:18,559 --> 00:16:24,439
we can start to fashion a policy you

00:16:22,009 --> 00:16:27,199
know along these lines where we have a

00:16:24,439 --> 00:16:29,300
decision some statements about the

00:16:27,199 --> 00:16:32,209
subject and some statements about

00:16:29,300 --> 00:16:34,220
the object and so you know for the

00:16:32,209 --> 00:16:35,800
decision we can tell it you know if

00:16:34,220 --> 00:16:38,390
these things match to allow the access

00:16:35,800 --> 00:16:40,310
or we can also tell it to do that with

00:16:38,390 --> 00:16:42,050
auditing so that we get an audit event

00:16:40,310 --> 00:16:43,029
you know saying that this is this is

00:16:42,050 --> 00:16:46,820
loud

00:16:43,029 --> 00:16:49,040
we can also deny the access and we can

00:16:46,820 --> 00:16:53,899
also create audit events based on the

00:16:49,040 --> 00:16:56,870
done hours if we want them the subject

00:16:53,899 --> 00:17:00,529
attributes is just what we talked about

00:16:56,870 --> 00:17:04,040
a second ago in the in the pictures you

00:17:00,529 --> 00:17:10,610
can tell it all a UID UID session ID PID

00:17:04,040 --> 00:17:12,620
come and also some patterns on the

00:17:10,610 --> 00:17:15,620
object side yeah we can we can tell us

00:17:12,620 --> 00:17:19,550
you know paths directories devices file

00:17:15,620 --> 00:17:21,140
types and hashes we can have multiple

00:17:19,550 --> 00:17:26,929
statements and and they're ANDed

00:17:21,140 --> 00:17:29,240
together this is a little bit of

00:17:26,929 --> 00:17:33,020
information about what is in these these

00:17:29,240 --> 00:17:35,450
different things for the new IDs and

00:17:33,020 --> 00:17:38,059
session IDs these are numbers process

00:17:35,450 --> 00:17:41,419
IDs number of comm is a fifteen

00:17:38,059 --> 00:17:46,370
character string executables are also

00:17:41,419 --> 00:17:49,280
strings the exact dur also has some some

00:17:46,370 --> 00:17:52,429
key words that we can tell it that you

00:17:49,280 --> 00:18:00,140
know it's executable ders which would be

00:17:52,429 --> 00:18:03,410
stuff like s been been lived and Lib 64

00:18:00,140 --> 00:18:07,340
and Lib exact system doers would also

00:18:03,410 --> 00:18:13,190
include Etsy and maybe one or two other

00:18:07,340 --> 00:18:14,630
things now we also can do pattern

00:18:13,190 --> 00:18:18,559
detection because the way the program

00:18:14,630 --> 00:18:21,919
start up is different depending on what

00:18:18,559 --> 00:18:25,370
what's happening I did have a pattern in

00:18:21,919 --> 00:18:28,070
here for LD preload but then one day I

00:18:25,370 --> 00:18:31,640
was looking at a system that held LD

00:18:28,070 --> 00:18:33,610
library for an Nvidia graphics card and

00:18:31,640 --> 00:18:36,679
so that causes the runtime linker to do

00:18:33,610 --> 00:18:38,400
completely different things and I

00:18:36,679 --> 00:18:40,230
decided that was unreliable at the

00:18:38,400 --> 00:18:42,300
there's another way that we can we can

00:18:40,230 --> 00:18:48,260
add this back in but I pulled that one

00:18:42,300 --> 00:18:50,970
out for the moment the object statements

00:18:48,260 --> 00:18:54,960
wouldn't just tell all we can have a

00:18:50,970 --> 00:18:58,410
path we can tell it that that it has to

00:18:54,960 --> 00:19:02,520
be trusted or untrusted meaning that it

00:18:58,410 --> 00:19:05,100
lives in the the trust database we can

00:19:02,520 --> 00:19:11,520
also tell it that you know a device like

00:19:05,100 --> 00:19:14,070
dev a cd-rom and one of the main uses

00:19:11,520 --> 00:19:16,110
though is for the file type which you

00:19:14,070 --> 00:19:19,830
know just because of Lib magic having

00:19:16,110 --> 00:19:27,180
things based around mime types we list

00:19:19,830 --> 00:19:29,640
things you know in that format so this

00:19:27,180 --> 00:19:32,670
is a sample policy you know the fund it

00:19:29,640 --> 00:19:38,400
looks like and this is a first match

00:19:32,670 --> 00:19:40,230
wins kind of evaluation so so at the

00:19:38,400 --> 00:19:41,820
very top we tell it that we don't want

00:19:40,230 --> 00:19:45,300
any execution you know straight from the

00:19:41,820 --> 00:19:48,570
runtime linker so we tell it deny that

00:19:45,300 --> 00:19:50,400
with audit and trigger on the pattern

00:19:48,570 --> 00:19:53,850
you know of starting the program from

00:19:50,400 --> 00:19:58,650
the runtime linker and that's for all

00:19:53,850 --> 00:20:01,590
objects we also don't want to let

00:19:58,650 --> 00:20:03,480
untrusted executables run and so we tell

00:20:01,590 --> 00:20:06,980
it we want to design that with audit and

00:20:03,480 --> 00:20:10,260
that the the execution ders have to be

00:20:06,980 --> 00:20:13,290
the executor is that I mentioned before

00:20:10,260 --> 00:20:15,060
and it has to be trusted you know if

00:20:13,290 --> 00:20:19,170
it's untrusted then we're gonna deny and

00:20:15,060 --> 00:20:20,640
that's against all objects we also have

00:20:19,170 --> 00:20:23,310
a pattern here to allow all elf

00:20:20,640 --> 00:20:25,650
applications and this is a this is a

00:20:23,310 --> 00:20:27,780
pattern where you have to tell it to

00:20:25,650 --> 00:20:29,970
allow the types that you want that's the

00:20:27,780 --> 00:20:34,230
whitelist and then to deny everything

00:20:29,970 --> 00:20:37,380
else and so we do the same thing with

00:20:34,230 --> 00:20:39,870
elf libs and that is we we tell it what

00:20:37,380 --> 00:20:43,550
we want to allow to execute and then we

00:20:39,870 --> 00:20:43,550
tell it deny everything else

00:20:43,970 --> 00:20:49,470
same thing with Python we can we can

00:20:46,590 --> 00:20:53,940
restrict it to the exact directories you

00:20:49,470 --> 00:20:55,380
know system directories so that you know

00:20:53,940 --> 00:21:04,559
it has to come from the system directory

00:20:55,380 --> 00:21:07,909
but we also want it to be trusted the

00:21:04,559 --> 00:21:11,279
the design goals of this policy was to

00:21:07,909 --> 00:21:13,260
have no bypass of the security by

00:21:11,279 --> 00:21:16,500
starting a program from the run time

00:21:13,260 --> 00:21:19,820
linker and only approved executables

00:21:16,500 --> 00:21:22,440
that's in the trust database can run

00:21:19,820 --> 00:21:24,659
elephant Python files have to come from

00:21:22,440 --> 00:21:27,919
the system directories and this prevents

00:21:24,659 --> 00:21:33,240
you know LD library path and Python path

00:21:27,919 --> 00:21:36,779
redirection also the other languages are

00:21:33,240 --> 00:21:38,580
disallowed by default so if you have

00:21:36,779 --> 00:21:40,289
Perl on the system you would want to go

00:21:38,580 --> 00:21:44,450
in and adjust the rules or if you're

00:21:40,289 --> 00:21:44,450
using Ruby or PHP or anything like that

00:21:46,399 --> 00:21:56,760
the design of this this application

00:21:51,260 --> 00:22:00,419
looks like this we get the events and a

00:21:56,760 --> 00:22:06,240
reader thread and the reason we do do

00:22:00,419 --> 00:22:10,620
this is because the system will deadlock

00:22:06,240 --> 00:22:12,750
itself if if this application tries to

00:22:10,620 --> 00:22:15,690
open anything so what the reader thread

00:22:12,750 --> 00:22:18,690
does is it receives the event looks at

00:22:15,690 --> 00:22:22,260
the PID sees if it's the PID of the

00:22:18,690 --> 00:22:25,230
monitor program if a policy D and if it

00:22:22,260 --> 00:22:27,330
is we go ahead and approve the the

00:22:25,230 --> 00:22:30,149
access because you know why wouldn't we

00:22:27,330 --> 00:22:33,510
want to act approve accesses that we

00:22:30,149 --> 00:22:34,980
need so if it's not that PID it goes

00:22:33,510 --> 00:22:38,159
into an event queue and a decision

00:22:34,980 --> 00:22:40,110
thread gets it and this way the reader

00:22:38,159 --> 00:22:41,519
thread can continue getting getting

00:22:40,110 --> 00:22:45,360
events and putting them into the event

00:22:41,519 --> 00:22:46,860
queue so the decision thread then needs

00:22:45,360 --> 00:22:48,330
to figure out you know what are we

00:22:46,860 --> 00:22:52,620
looking at you know what's the subject

00:22:48,330 --> 00:22:54,260
what's the the object and the thing is

00:22:52,620 --> 00:22:58,040
that

00:22:54,260 --> 00:23:00,470
it it takes several system calls to to

00:22:58,040 --> 00:23:03,320
figure out you know who's what and so

00:23:00,470 --> 00:23:06,050
what you really want to do is to cache

00:23:03,320 --> 00:23:07,520
this information and so so the first

00:23:06,050 --> 00:23:10,100
thing it does is it tries to figure out

00:23:07,520 --> 00:23:11,480
what are we looking at and is this

00:23:10,100 --> 00:23:13,760
already you know something we know about

00:23:11,480 --> 00:23:15,110
and you know is it in the cache because

00:23:13,760 --> 00:23:17,060
if it is in the cache then we don't need

00:23:15,110 --> 00:23:18,440
to open up all these proc things we can

00:23:17,060 --> 00:23:20,480
just go ahead and shortcut you know to

00:23:18,440 --> 00:23:24,800
evaluating the rules you know based on

00:23:20,480 --> 00:23:27,950
the cache and so the cache is designed

00:23:24,800 --> 00:23:30,530
as a least recently used cache so that

00:23:27,950 --> 00:23:32,960
it's self cleaning things that are

00:23:30,530 --> 00:23:35,330
recently accessed stay them stay at the

00:23:32,960 --> 00:23:36,800
top of the list and things that haven't

00:23:35,330 --> 00:23:43,640
been accessed for a while eventually get

00:23:36,800 --> 00:23:47,420
popped off of the cache the decision

00:23:43,640 --> 00:23:50,360
thread also has a trust database in in

00:23:47,420 --> 00:23:52,430
this particular case since since I'm

00:23:50,360 --> 00:23:55,250
designing this on a Red Hat system the

00:23:52,430 --> 00:23:57,710
trust database comes from RPM so

00:23:55,250 --> 00:23:59,690
basically what the policies is saying

00:23:57,710 --> 00:24:02,840
that everything that we know about is

00:23:59,690 --> 00:24:05,720
packaged the packaging information is

00:24:02,840 --> 00:24:11,870
trusted and we're gonna use that to make

00:24:05,720 --> 00:24:16,190
decisions always one other feature in

00:24:11,870 --> 00:24:18,890
this and that's a watchdog timer because

00:24:16,190 --> 00:24:21,340
this is approving or denying access to

00:24:18,890 --> 00:24:24,410
things I think it's it's likely to be a

00:24:21,340 --> 00:24:27,320
target for attack and so I've tried to

00:24:24,410 --> 00:24:29,930
design this in a way so that if somebody

00:24:27,320 --> 00:24:31,880
does try to get execution control that

00:24:29,930 --> 00:24:33,680
there's a watchdog timeout that both of

00:24:31,880 --> 00:24:36,680
the threads have to acknowledge

00:24:33,680 --> 00:24:40,240
periodically or the watchdog timeouts

00:24:36,680 --> 00:24:40,240
gonna kind of kill the application

00:24:42,790 --> 00:24:46,370
program you know since it might be an

00:24:45,020 --> 00:24:49,430
attack target you know it doesn't run as

00:24:46,370 --> 00:24:51,740
word it retains capabilities it also

00:24:49,430 --> 00:24:54,710
loads a second policy that prevents exec

00:24:51,740 --> 00:24:58,880
ve so that if somebody were lucky enough

00:24:54,710 --> 00:25:00,200
to exploit this program that the one

00:24:58,880 --> 00:25:02,360
thing they probably want which is

00:25:00,200 --> 00:25:05,480
exactly is denied by them by the policy

00:25:02,360 --> 00:25:08,350
and then they're also gonna have to deal

00:25:05,480 --> 00:25:08,350
with that watchdog timer

00:25:10,370 --> 00:25:16,410
and so you mentioned that you know

00:25:13,740 --> 00:25:19,740
sources of trust we can use a package

00:25:16,410 --> 00:25:21,990
database such as rpm and out of that

00:25:19,740 --> 00:25:23,520
database there's the path there's

00:25:21,990 --> 00:25:27,750
permissions there's ownership there's a

00:25:23,520 --> 00:25:30,950
sha-256 hash and all the entries are

00:25:27,750 --> 00:25:35,940
signed so you know every every package

00:25:30,950 --> 00:25:37,800
can be trusted in the database there's

00:25:35,940 --> 00:25:40,559
another source of information that's

00:25:37,800 --> 00:25:43,559
that's new and on the horizon and this

00:25:40,559 --> 00:25:48,090
is called swig which is an acronym for

00:25:43,559 --> 00:25:51,450
software identification this is covered

00:25:48,090 --> 00:25:53,760
by an ISO standard and NIST is also

00:25:51,450 --> 00:25:57,780
putting this they've also got a an

00:25:53,760 --> 00:26:01,410
information reference 80/60 which

00:25:57,780 --> 00:26:03,450
details their take on the ISO standard

00:26:01,410 --> 00:26:07,740
and you know they they put their

00:26:03,450 --> 00:26:11,300
electives into it a swig is also being

00:26:07,740 --> 00:26:15,090
driven into all the Common Criteria

00:26:11,300 --> 00:26:17,850
protection profiles one by one they're

00:26:15,090 --> 00:26:20,850
asking for manufacturers to include Swit

00:26:17,850 --> 00:26:23,910
information for all the software they're

00:26:20,850 --> 00:26:25,740
shipping so today it's kind of sparse

00:26:23,910 --> 00:26:28,910
and you might not find many swig tags

00:26:25,740 --> 00:26:35,340
but over time it's it's gonna be

00:26:28,910 --> 00:26:37,350
everywhere now the talk a little bit

00:26:35,340 --> 00:26:39,809
more about Szwed tags because this is

00:26:37,350 --> 00:26:42,030
really an up and coming standard there's

00:26:39,809 --> 00:26:44,670
four kinds of tags one is called the

00:26:42,030 --> 00:26:47,070
corpus tag and what the corpus tag is is

00:26:44,670 --> 00:26:50,220
it's like for a body of software like a

00:26:47,070 --> 00:26:52,679
like a cd-rom so a cd-rom would have a

00:26:50,220 --> 00:26:54,780
sweat tag in a specified directory and

00:26:52,679 --> 00:26:57,980
it would give the information about

00:26:54,780 --> 00:27:01,980
what's what's on the cd-rom

00:26:57,980 --> 00:27:04,260
there's a primary tag which allows you

00:27:01,980 --> 00:27:06,390
to describe the product there's a patch

00:27:04,260 --> 00:27:08,429
tag but this is really aimed more at the

00:27:06,390 --> 00:27:10,440
Microsoft world where you install

00:27:08,429 --> 00:27:12,990
something and then you have Patch

00:27:10,440 --> 00:27:15,450
Tuesday and you keep updating and so

00:27:12,990 --> 00:27:17,190
this is designed you know more for the

00:27:15,450 --> 00:27:19,470
Microsoft world and then there's

00:27:17,190 --> 00:27:23,280
supplemental tags which allow you to add

00:27:19,470 --> 00:27:26,909
information like linking to web pages

00:27:23,280 --> 00:27:30,570
you know for more information thus would

00:27:26,909 --> 00:27:32,370
tags are an XML file they convey

00:27:30,570 --> 00:27:35,370
information about the publishers

00:27:32,370 --> 00:27:38,159
licensing and then there's an optional

00:27:35,370 --> 00:27:41,039
payload section which details files

00:27:38,159 --> 00:27:43,260
sizes and hashes and and this can also

00:27:41,039 --> 00:27:45,419
be extended with information about

00:27:43,260 --> 00:27:47,730
permission and ownership and then the

00:27:45,419 --> 00:27:51,780
whole thing is digitally signed using

00:27:47,730 --> 00:27:54,299
the ex ATS specification on fedora and

00:27:51,780 --> 00:27:59,580
in rel you can find Swit tags and use

00:27:54,299 --> 00:28:03,270
your lib swig tag and here's an example

00:27:59,580 --> 00:28:05,700
of what what they look like there's much

00:28:03,270 --> 00:28:08,429
more to this because this doesn't have

00:28:05,700 --> 00:28:10,440
the optional payload section which is

00:28:08,429 --> 00:28:15,929
the part that's probably most

00:28:10,440 --> 00:28:20,419
interesting okay so let's take a quick

00:28:15,929 --> 00:28:20,419
look and do another live demo here

00:28:25,279 --> 00:28:33,899
okay so it's coming up right now it's

00:28:30,869 --> 00:28:37,169
running it loaded its rules it changed

00:28:33,899 --> 00:28:39,210
the UID initialize the database did an

00:28:37,169 --> 00:28:40,889
integrity check of the database that

00:28:39,210 --> 00:28:44,779
found a miss compare so right now it's

00:28:40,889 --> 00:28:44,779
rebuilding rebuilding its database

00:28:57,530 --> 00:29:04,710
now one thing to mention is that what is

00:29:01,500 --> 00:29:07,590
doing right now is that we use lol DBM

00:29:04,710 --> 00:29:09,240
as the database and the reason why is

00:29:07,590 --> 00:29:11,490
because it's way faster than than the

00:29:09,240 --> 00:29:13,860
RPM database so what we do is we create

00:29:11,490 --> 00:29:17,880
our own our own database out of the RPM

00:29:13,860 --> 00:29:21,320
database and we don't have to worry

00:29:17,880 --> 00:29:21,320
about locking in other applications

00:29:44,800 --> 00:29:50,860
normally it works a lot faster than this

00:29:46,870 --> 00:29:54,640
but this is an old laptop and I was

00:29:50,860 --> 00:29:56,559
having trouble getting the the PDF file

00:29:54,640 --> 00:29:59,820
to open so there's something something

00:29:56,559 --> 00:29:59,820
busy on this machine

00:30:20,150 --> 00:30:23,530
I was thinking way too long

00:30:37,270 --> 00:30:40,270
and

00:30:46,980 --> 00:30:52,010
yeah I'm wondering if IBM had had

00:30:49,350 --> 00:30:52,010
something luck

00:31:05,960 --> 00:31:14,230
okay no now we got this thing up and

00:31:08,690 --> 00:31:16,220
running so this is a debug mode which is

00:31:14,230 --> 00:31:17,869
not the way you would normally run up

00:31:16,220 --> 00:31:19,850
but this is it and from a lot more

00:31:17,869 --> 00:31:21,919
informational so you can see what it's

00:31:19,850 --> 00:31:24,679
what it's doing what it's telling you is

00:31:21,919 --> 00:31:27,919
the rule that it triggered on what the

00:31:24,679 --> 00:31:30,049
decision was and then some some

00:31:27,919 --> 00:31:33,499
information to help debug with which is

00:31:30,049 --> 00:31:37,490
what executable and what file is trying

00:31:33,499 --> 00:31:39,619
to be accessed okay so let's let's

00:31:37,490 --> 00:31:42,649
follow this this demo script here I've

00:31:39,619 --> 00:31:45,679
got let's go over here to the temp and

00:31:42,649 --> 00:31:49,340
you can see when I went around CD that

00:31:45,679 --> 00:31:53,360
it created a whole lot of access so what

00:31:49,340 --> 00:31:56,960
we want to do is copy the system LS into

00:31:53,360 --> 00:31:59,649
the temp directory now let's also make

00:31:56,960 --> 00:31:59,649
us some link

00:32:03,730 --> 00:32:19,799
and let's try to run this program and

00:32:14,850 --> 00:32:19,799
over here you can see the the denials

00:32:19,919 --> 00:32:27,100
okay so let's try it from a symlink and

00:32:24,370 --> 00:32:29,639
you see it was allowed and the reason

00:32:27,100 --> 00:32:36,539
why is because it resolved it to the

00:32:29,639 --> 00:32:40,269
system of LS program way back here

00:32:36,539 --> 00:32:42,100
so the symlink you didn't get the full

00:32:40,269 --> 00:32:45,399
path you get what-what the real the real

00:32:42,100 --> 00:32:49,690
object was okay so let's try to run this

00:32:45,399 --> 00:33:00,149
program from the runtime linker and so

00:32:49,690 --> 00:33:00,149
we got a denial okay and just in case

00:33:07,920 --> 00:33:11,380
well we've already got a copy of it

00:33:09,850 --> 00:33:14,260
there let's try to let's try to run that

00:33:11,380 --> 00:33:18,930
one because just to show you that the

00:33:14,260 --> 00:33:18,930
temp directory is loaded with a

00:33:22,050 --> 00:33:28,810
permission so it doesn't allow execution

00:33:25,770 --> 00:33:30,250
so you see here it denies a you know

00:33:28,810 --> 00:33:34,420
even from the home directory and you can

00:33:30,250 --> 00:33:40,900
see the denial is over well Wade pass

00:33:34,420 --> 00:33:42,850
down okay so back to the demo let's take

00:33:40,900 --> 00:33:46,380
a look at a program that has the the

00:33:42,850 --> 00:33:50,260
interpreter changed and just to show you

00:33:46,380 --> 00:33:54,150
that the the interpreter is changed

00:33:50,260 --> 00:33:54,150
we'll take a look at it with three delft

00:33:57,390 --> 00:34:00,540
that's right

00:34:04,870 --> 00:34:08,290
where is test

00:34:08,540 --> 00:34:11,679
oh there it is y'all

00:34:14,200 --> 00:34:25,210
I think it was denied yeah there was a

00:34:18,730 --> 00:34:27,539
denial well let's try to run it actually

00:34:25,210 --> 00:34:36,609
I'll show you this file in just a second

00:34:27,539 --> 00:34:40,929
let's run it so there was a denial and

00:34:36,609 --> 00:34:48,779
the one last okay let's go let's go try

00:34:40,929 --> 00:34:48,779
and run into the system

00:35:00,950 --> 00:35:04,480
okay denied

00:35:08,120 --> 00:35:16,210
and you can see that system system

00:35:12,140 --> 00:35:16,210
Python files are allowed to run

00:35:27,220 --> 00:35:32,360
and one of the things I have it to do in

00:35:29,780 --> 00:35:35,600
debug mode is to output some some

00:35:32,360 --> 00:35:40,610
statistics so that you can see how how

00:35:35,600 --> 00:35:43,670
it's performing in this case there is

00:35:40,610 --> 00:35:48,380
about 1200 accesses allowed and 11 of

00:35:43,670 --> 00:35:51,190
them denied the cache size is 10 20 443

00:35:48,380 --> 00:35:55,990
slots were in use we had a lot of hits

00:35:51,190 --> 00:35:55,990
same thing on being the object side Oh

00:36:00,040 --> 00:36:03,550
while we're here

00:36:11,119 --> 00:36:19,369
now that that's shut down you can see

00:36:14,269 --> 00:36:21,380
right here in the elf that it's it's not

00:36:19,369 --> 00:36:24,190
requesting the normal runtime linker but

00:36:21,380 --> 00:36:24,190
a but a fake interpreter

00:36:33,400 --> 00:36:39,650
okay so I did show you the statistics

00:36:37,369 --> 00:36:43,400
report but it also leaves a breadcrumb

00:36:39,650 --> 00:36:45,770
trail over in VAR log there's a F a

00:36:43,400 --> 00:36:48,050
policy D file this drop there when the

00:36:45,770 --> 00:36:50,380
program shuts down so that just in case

00:36:48,050 --> 00:36:52,700
you need it for forensics information

00:36:50,380 --> 00:36:53,839
there's a breadcrumb trail of everything

00:36:52,700 --> 00:36:56,660
the system was doing right before it

00:36:53,839 --> 00:36:57,890
shut down but that's also configurable

00:36:56,660 --> 00:36:59,450
because there may be cases when you

00:36:57,890 --> 00:37:02,990
don't want that information sitting on

00:36:59,450 --> 00:37:07,430
the disk drive okay so looking back at

00:37:02,990 --> 00:37:09,520
our original code coverage we can deny

00:37:07,430 --> 00:37:12,140
everything that's got a line through it

00:37:09,520 --> 00:37:15,920
the things that are in red are within

00:37:12,140 --> 00:37:19,670
reach those those I can cover with just

00:37:15,920 --> 00:37:21,770
a little bit more work and then also

00:37:19,670 --> 00:37:24,190
this fetched remotely thing this has

00:37:21,770 --> 00:37:26,329
been handled an entirely different way

00:37:24,190 --> 00:37:28,070
I've been talking to people in the

00:37:26,329 --> 00:37:31,400
Python community and explaining the

00:37:28,070 --> 00:37:33,670
dangers of Python and mobile code and

00:37:31,400 --> 00:37:37,940
things like that so what they've done is

00:37:33,670 --> 00:37:40,400
there's a apep 578 that's been approved

00:37:37,940 --> 00:37:42,380
and is being worked on for python 3.8

00:37:40,400 --> 00:37:47,540
and what it will do is it will add audit

00:37:42,380 --> 00:37:50,930
hooks to the python interpreter and then

00:37:47,540 --> 00:37:52,760
also you can have a monitor that looks

00:37:50,930 --> 00:37:55,190
at these hooks and decides yes or no and

00:37:52,760 --> 00:37:57,740
this will be inside the same binary and

00:37:55,190 --> 00:37:59,450
so we will be able to have a policy

00:37:57,740 --> 00:38:02,270
inside the Python interpreter that says

00:37:59,450 --> 00:38:05,060
no code from standard in you know how to

00:38:02,270 --> 00:38:07,069
override the module resolution you can't

00:38:05,060 --> 00:38:09,099
pull things from the net you can't have

00:38:07,069 --> 00:38:12,380
programs that come from the command line

00:38:09,099 --> 00:38:13,760
so this this should be in 3.8 and it

00:38:12,380 --> 00:38:15,800
will solve the problem there but I don't

00:38:13,760 --> 00:38:18,329
you got the same problem in other

00:38:15,800 --> 00:38:20,829
languages but I don't have

00:38:18,329 --> 00:38:23,819
leverage or ways of influence

00:38:20,829 --> 00:38:26,829
communities for the other interpreters

00:38:23,819 --> 00:38:28,239
some things I really wished would make

00:38:26,829 --> 00:38:30,910
life a little easier is that you know if

00:38:28,239 --> 00:38:32,200
we get notification on exit yeah I

00:38:30,910 --> 00:38:34,119
suppose there's a way to do it but you

00:38:32,200 --> 00:38:35,769
know wouldn't be serialized with the the

00:38:34,119 --> 00:38:38,739
main event queue and that causes some

00:38:35,769 --> 00:38:40,269
problems the other thing is if you know

00:38:38,739 --> 00:38:41,380
because we have to figure out is this

00:38:40,269 --> 00:38:43,180
thing in the cash you know what are we

00:38:41,380 --> 00:38:44,589
looking at the very first thing we

00:38:43,180 --> 00:38:47,259
needed to do is get some some stat

00:38:44,589 --> 00:38:49,869
information so if that was passed with

00:38:47,259 --> 00:38:51,369
the event then that would save one

00:38:49,869 --> 00:38:54,910
system called we can make a decision a

00:38:51,369 --> 00:38:57,220
lot faster and then the other thing is

00:38:54,910 --> 00:39:00,339
in the proc file system everything is in

00:38:57,220 --> 00:39:02,039
different files it would be awesome if

00:39:00,339 --> 00:39:05,229
some some of this information was

00:39:02,039 --> 00:39:08,049
collated like for example proc self

00:39:05,229 --> 00:39:11,140
status does not have the login UID you

00:39:08,049 --> 00:39:13,450
have to go open proc self login UID to

00:39:11,140 --> 00:39:15,789
find that so you know it would be good

00:39:13,450 --> 00:39:17,619
if some of this was consolidated so it

00:39:15,789 --> 00:39:19,059
was just like one open system call and

00:39:17,619 --> 00:39:24,700
then a read and then we can make a

00:39:19,059 --> 00:39:27,549
decision things that are in the near

00:39:24,700 --> 00:39:30,849
term near term is reinstating the LD

00:39:27,549 --> 00:39:34,200
audit LD preload coverage detecting

00:39:30,849 --> 00:39:34,200
statically linked applications

00:39:34,229 --> 00:39:37,719
interpreters pulling code from standard

00:39:36,339 --> 00:39:40,359
in even though this will be solved by

00:39:37,719 --> 00:39:44,289
pep 578 they're still old systems out

00:39:40,359 --> 00:39:46,329
there that need protecting and you know

00:39:44,289 --> 00:39:49,710
detecting code from standard in from the

00:39:46,329 --> 00:39:51,789
command line standalone shell usage and

00:39:49,710 --> 00:39:57,219
adding more threads to it so it can

00:39:51,789 --> 00:40:00,670
scale out so how this might fit I'll

00:39:57,219 --> 00:40:02,890
briefly go through this the audit system

00:40:00,670 --> 00:40:04,479
has a bunch of event feeds from the

00:40:02,890 --> 00:40:05,829
criminal we can get promiscuous socket

00:40:04,479 --> 00:40:08,410
core dumps and links and that filled

00:40:05,829 --> 00:40:10,630
through TTY sis colon file watches

00:40:08,410 --> 00:40:13,539
there's also a trusted program to Sunday

00:40:10,630 --> 00:40:17,289
events such as Pam logon chatty utils

00:40:13,539 --> 00:40:20,680
password se manage cups cleavers Libra

00:40:17,289 --> 00:40:22,089
Swan and there's also policy engines you

00:40:20,680 --> 00:40:24,039
know L SMS and set comp

00:40:22,089 --> 00:40:26,140
can also set cause events and then

00:40:24,039 --> 00:40:29,300
there's an Tegrity apps a fa policy the

00:40:26,140 --> 00:40:31,430
USB guard so we can take these events

00:40:29,300 --> 00:40:35,390
and start the fashion a system together

00:40:31,430 --> 00:40:36,620
where events wind up coming to the audit

00:40:35,390 --> 00:40:38,510
team you know right here it just shows

00:40:36,620 --> 00:40:40,370
the the application whitelisting daemon

00:40:38,510 --> 00:40:44,120
and then the audit daemon can have an

00:40:40,370 --> 00:40:46,970
IDs plug-in you know to to look at

00:40:44,120 --> 00:40:49,070
things the audit system is really easy

00:40:46,970 --> 00:40:51,950
to use you don't have to worry about

00:40:49,070 --> 00:40:53,900
parsing events there's a parsing library

00:40:51,950 --> 00:40:55,970
which takes care of all the

00:40:53,900 --> 00:40:57,740
idiosyncrasies of the audit system and

00:40:55,970 --> 00:40:59,770
just make some some calls and it gives

00:40:57,740 --> 00:41:02,360
you the data in nice little chunks and

00:40:59,770 --> 00:41:05,090
then you know what what we would look at

00:41:02,360 --> 00:41:07,400
is putting this into an IDs system with

00:41:05,090 --> 00:41:09,260
an ensemble model something like this

00:41:07,400 --> 00:41:11,540
that looks for bad events it does

00:41:09,260 --> 00:41:14,960
pattern analysis does burst analysis

00:41:11,540 --> 00:41:16,970
looks at historical their norms and does

00:41:14,960 --> 00:41:18,470
misuse detection and then you know that

00:41:16,970 --> 00:41:24,080
all get summed up and then there's a

00:41:18,470 --> 00:41:27,940
reaction to it and that concludes the

00:41:24,080 --> 00:41:27,940
presentation questions

00:41:48,010 --> 00:41:55,640
so either a revocation story for the

00:41:51,200 --> 00:41:59,140
trusted database yes anytime that the

00:41:55,640 --> 00:42:02,390
database is updated we get in we get

00:41:59,140 --> 00:42:06,080
signaled and we update the database so

00:42:02,390 --> 00:42:10,280
if for example you do our p.m. - II you

00:42:06,080 --> 00:42:11,960
know to erase of a package then that

00:42:10,280 --> 00:42:13,280
would trigger an update to the database

00:42:11,960 --> 00:42:15,110
and then we would know that that that's

00:42:13,280 --> 00:42:26,210
no longer there so that's that's kind of

00:42:15,110 --> 00:42:27,440
how revocation what would work I'm I'm

00:42:26,210 --> 00:42:30,020
afraid I didn't understand the question

00:42:27,440 --> 00:42:31,760
so that last thing that you talked about

00:42:30,020 --> 00:42:34,190
is not white listing you said you are

00:42:31,760 --> 00:42:35,240
looking for patterns black listing

00:42:34,190 --> 00:42:37,580
basically patterns

00:42:35,240 --> 00:42:39,380
yes yes it's doing more than white

00:42:37,580 --> 00:42:40,880
listing yes you're absolutely right

00:42:39,380 --> 00:42:42,500
because white listing is just about the

00:42:40,880 --> 00:42:46,520
provenance and and whether or not it's

00:42:42,500 --> 00:42:48,350
in the trust database but in the most in

00:42:46,520 --> 00:42:52,820
a way you can stretch that to say that

00:42:48,350 --> 00:42:54,110
the runtime linker is what we trust you

00:42:52,820 --> 00:42:56,990
know and if they're calling a different

00:42:54,110 --> 00:43:02,590
runtime linker then it's outside and you

00:42:56,990 --> 00:43:05,600
know what's trusted um you mentioned

00:43:02,590 --> 00:43:07,250
Switek case you're not a big fan of XML

00:43:05,600 --> 00:43:09,980
just want to let you know there's an

00:43:07,250 --> 00:43:12,980
IETF draft for doing so a tag and

00:43:09,980 --> 00:43:16,190
concise binary call Co swig just in case

00:43:12,980 --> 00:43:18,650
yeah xml fight xml fan also i just want

00:43:16,190 --> 00:43:20,270
to do a for reference we and our 3

00:43:18,650 --> 00:43:22,490
o'clock presentation are defining

00:43:20,270 --> 00:43:27,280
another type of swift AG for our

00:43:22,490 --> 00:43:27,280
firmware so just kind of a unabashed

00:43:36,030 --> 00:43:43,890
so how does this work in along with

00:43:39,420 --> 00:43:48,000
other access control systems like I'm a

00:43:43,890 --> 00:43:49,680
or selinux like how does it go exist

00:43:48,000 --> 00:43:53,640
with others ecosystem

00:43:49,680 --> 00:43:57,300
well this because we're in the file

00:43:53,640 --> 00:44:01,440
access path I think that we're before

00:43:57,300 --> 00:44:03,570
the DAC permissions and SELinux is after

00:44:01,440 --> 00:44:05,400
the DAC permissions so I suppose in a

00:44:03,570 --> 00:44:09,530
way we get first vote or this program

00:44:05,400 --> 00:44:12,660
gets first vote or something like that

00:44:09,530 --> 00:44:15,480
but it coexists find they're

00:44:12,660 --> 00:44:17,130
complementary so is UEFI secure boot

00:44:15,480 --> 00:44:19,530
this doesn't try to solve that problem

00:44:17,130 --> 00:44:21,630
and so it's complementary on top of that

00:44:19,530 --> 00:44:23,610
because really what this is is aimed at

00:44:21,630 --> 00:44:26,070
it solving the problem of you know if

00:44:23,610 --> 00:44:28,710
somebody pops in a shell you know from a

00:44:26,070 --> 00:44:30,090
demon or gets access to somebody

00:44:28,710 --> 00:44:32,970
somebody systems for their credentials

00:44:30,090 --> 00:44:38,070
and that's way after boot but that's

00:44:32,970 --> 00:44:44,130
really what this is designed for ok last

00:44:38,070 --> 00:44:48,720
question so two questions since I said

00:44:44,130 --> 00:44:54,090
last questions ok so any plans to extend

00:44:48,720 --> 00:44:56,280
this to kernel model whitelisting would

00:44:54,090 --> 00:44:59,640
would we extend this to be a kernel

00:44:56,280 --> 00:45:03,360
module no to whitelist kernel modules oh

00:44:59,640 --> 00:45:05,790
the white was kernel much yeah I believe

00:45:03,360 --> 00:45:10,020
we can do that I you know I just have to

00:45:05,790 --> 00:45:13,230
double check to see if the FA notify

00:45:10,020 --> 00:45:15,150
system gets notified and if it does then

00:45:13,230 --> 00:45:18,330
yes we can

00:45:15,150 --> 00:45:20,450
the second question is okay believe the

00:45:18,330 --> 00:45:24,030
trusted database of the trust model is

00:45:20,450 --> 00:45:25,440
works efficiently when the software

00:45:24,030 --> 00:45:28,290
applications are installed from the

00:45:25,440 --> 00:45:30,570
package manager and if you have

00:45:28,290 --> 00:45:32,670
legitimate scenarios where you are not

00:45:30,570 --> 00:45:34,550
using a package manager or you're not

00:45:32,670 --> 00:45:37,710
installing packets rather you are

00:45:34,550 --> 00:45:39,270
directly dropping the applications

00:45:37,710 --> 00:45:43,160
distributing by a different app

00:45:39,270 --> 00:45:46,110
dissipation mechanism and you have

00:45:43,160 --> 00:45:48,300
legitimate need to hello one is certain

00:45:46,110 --> 00:45:49,140
boundaries which are distributed by a

00:45:48,300 --> 00:45:54,150
different distributions

00:45:49,140 --> 00:45:56,339
how do you foresee this very okay I'm

00:45:54,150 --> 00:45:58,470
not entirely sure I understood all the

00:45:56,339 --> 00:46:01,920
question but what I believe I heard was

00:45:58,470 --> 00:46:03,450
if somebody's has applications that's

00:46:01,920 --> 00:46:05,309
not packaged and you install it and you

00:46:03,450 --> 00:46:07,319
want that to be trusted how do you

00:46:05,309 --> 00:46:09,869
handle that situation and if that's the

00:46:07,319 --> 00:46:12,029
case there's an admin defined list that

00:46:09,869 --> 00:46:15,750
you can also modify which would then

00:46:12,029 --> 00:46:17,730
grant trust you know to that so it's

00:46:15,750 --> 00:46:21,150
there is a way you know to add your own

00:46:17,730 --> 00:46:27,630
whitelist to this so that you don't have

00:46:21,150 --> 00:46:29,069
to depend entirely on the packager so we

00:46:27,630 --> 00:46:32,069
were out of time for the questions but

00:46:29,069 --> 00:46:34,140
I'm sure Steve will be around thank you

00:46:32,069 --> 00:46:36,219
yes thanks

00:46:34,140 --> 00:46:36,219

YouTube URL: https://www.youtube.com/watch?v=Ip6ISXnFoXY


