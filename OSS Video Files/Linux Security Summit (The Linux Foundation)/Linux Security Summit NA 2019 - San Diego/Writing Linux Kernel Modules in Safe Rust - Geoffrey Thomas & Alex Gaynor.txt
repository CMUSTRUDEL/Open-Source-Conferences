Title: Writing Linux Kernel Modules in Safe Rust - Geoffrey Thomas & Alex Gaynor
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Writing Linux Kernel Modules in Safe Rust - Geoffrey Thomas, Two Sigma Investments & Alex Gaynor, Alloy

With 65% of recent Linux kernel vulnerabilities being the result of memory unsafety (buffer overflows, pointers used after being freed, etc.) and not logic errors, both kernel developers and downstream users have wondered whether it's possible to use a safer language than C for kernel development. This talk will explore the presenters' work building a framework for writing kernel modules in Rust and accessing kernel APIs in safe Rust. In particular, the talk will discuss some of the challenges of building binary-compatible kernel modules in Rust, techniques for working with existing C code, and how to design safe bindings over raw kernel APIs. It will also discuss advantages and difficulties for integrating Rust in upstream kernel development and possible directions the upstream kernel community could go.
Captions: 
	00:00:00,030 --> 00:00:14,490
all right hi everyone I'll just

00:00:03,000 --> 00:00:15,809
introduce ourselves I'm Jeffrey Thomas I

00:00:14,490 --> 00:00:18,300
work for a hedge fund this is all

00:00:15,809 --> 00:00:21,240
personal work done related to sort of

00:00:18,300 --> 00:00:25,859
what I do in my day job and this is Alex

00:00:21,240 --> 00:00:27,630
Kane our we've got a mic I do security

00:00:25,859 --> 00:00:30,000
stuff for a political data company and

00:00:27,630 --> 00:00:31,710
this is not related to my day job at all

00:00:30,000 --> 00:00:34,110
I'm also the principal and founder at

00:00:31,710 --> 00:00:37,790
fish in a barrel which is an extremely

00:00:34,110 --> 00:00:39,870
real security firm that dream Lee real

00:00:37,790 --> 00:00:41,969
you'll see a bit about what fashion

00:00:39,870 --> 00:00:44,190
apparel does so we've been working on

00:00:41,969 --> 00:00:45,930
writing kernel modules and rust but I

00:00:44,190 --> 00:00:47,579
wanted to talk a little bit about why

00:00:45,930 --> 00:00:49,850
you would want to do such a thing and

00:00:47,579 --> 00:00:52,739
sort of what the problems we're facing

00:00:49,850 --> 00:00:55,289
cool so vulnerabilities due to memory

00:00:52,739 --> 00:00:57,989
corruption are extremely common and

00:00:55,289 --> 00:00:59,010
extremely preventable so a definition of

00:00:57,989 --> 00:01:01,260
memory unsafety

00:00:59,010 --> 00:01:04,559
is sort of the property of a programming

00:01:01,260 --> 00:01:06,689
language to without programmers going

00:01:04,559 --> 00:01:08,130
out of their way to allow them allow

00:01:06,689 --> 00:01:10,799
programmers to introduce use after free

00:01:08,130 --> 00:01:13,049
double free Wildtree overflows under

00:01:10,799 --> 00:01:16,799
flows wild pointers use of uninitialized

00:01:13,049 --> 00:01:19,530
memory and data races often leading to

00:01:16,799 --> 00:01:21,990
all of the above so some statistics

00:01:19,530 --> 00:01:25,799
about the prevalence memory and safety

00:01:21,990 --> 00:01:27,960
so approximately 49 percent of the

00:01:25,799 --> 00:01:32,340
Chrome security vulnerabilities in 2019

00:01:27,960 --> 00:01:35,299
had memory unsafety as a root cause 72%

00:01:32,340 --> 00:01:39,329
of the Firefox vulnerabilities in 2019

00:01:35,299 --> 00:01:40,409
81 percent of 0 days in the wild since

00:01:39,329 --> 00:01:44,369
00:01:40,409 --> 00:01:47,340
as tracked by Google's project zero had

00:01:44,369 --> 00:01:49,110
memory unsafety as a root cause but

00:01:47,340 --> 00:01:51,000
these are all silly user space problems

00:01:49,110 --> 00:01:52,380
kernel programmers are very serious and

00:01:51,000 --> 00:01:54,869
would not introduce the same sorts of

00:01:52,380 --> 00:01:57,240
bugs into their programs so surely the

00:01:54,869 --> 00:02:01,350
numbers are more promising about kernels

00:01:57,240 --> 00:02:04,320
tastes 88 percent of mac OS kernel

00:02:01,350 --> 00:02:06,899
vulnerabilities in the 1014 series had

00:02:04,320 --> 00:02:09,239
memory corruption Microsoft doesn't

00:02:06,899 --> 00:02:13,650
release quite as granular statistics but

00:02:09,239 --> 00:02:15,780
they've said as a whole since 2006

00:02:13,650 --> 00:02:17,580
estimated 70% of vulnerabilities across

00:02:15,780 --> 00:02:19,590
all of their products head memory on

00:02:17,580 --> 00:02:21,270
safety as a root cause and I would bet

00:02:19,590 --> 00:02:23,810
almost anything the kernel is higher

00:02:21,270 --> 00:02:27,599
than other products

00:02:23,810 --> 00:02:30,810
65% of kernel CVEs that made their way

00:02:27,599 --> 00:02:32,819
into a bun two security notifications in

00:02:30,810 --> 00:02:37,019
the six months before we perform these

00:02:32,819 --> 00:02:38,940
slides were memory on safety 65% of all

00:02:37,019 --> 00:02:41,400
Android TVs this is inclusive of both

00:02:38,940 --> 00:02:42,349
kernel and user space had memory on

00:02:41,400 --> 00:02:45,030
safety

00:02:42,349 --> 00:02:47,670
Cisco lurk at the day we produced the

00:02:45,030 --> 00:02:51,780
slide was claimed 225 things that looked

00:02:47,670 --> 00:02:54,420
like ka Center km San a paper released

00:02:51,780 --> 00:02:57,630
two or three weeks ago that performed

00:02:54,420 --> 00:02:59,640
use after free static analysis on a

00:02:57,630 --> 00:03:02,010
bunch of kernel data structures

00:02:59,640 --> 00:03:04,709
particularly focused on concurrency had

00:03:02,010 --> 00:03:06,540
hundreds of findings these

00:03:04,709 --> 00:03:09,569
vulnerabilities have the same root cause

00:03:06,540 --> 00:03:11,400
c and c++ enables programmers to

00:03:09,569 --> 00:03:13,380
trivially introduce critical

00:03:11,400 --> 00:03:15,030
vulnerabilities these vulnerabilities

00:03:13,380 --> 00:03:17,340
have outcomes like surveilling

00:03:15,030 --> 00:03:18,269
dissidents advocating for human rights

00:03:17,340 --> 00:03:21,440
in the middle east

00:03:18,269 --> 00:03:24,959
taking down entire hospital systems and

00:03:21,440 --> 00:03:27,480
even surveilling nutritionists in mexico

00:03:24,959 --> 00:03:29,609
working on soda taxes that is a for real

00:03:27,480 --> 00:03:32,340
thing where memory corruption was used

00:03:29,609 --> 00:03:35,400
to surveil these people surely there's a

00:03:32,340 --> 00:03:39,780
better way so we're looking at c and c++

00:03:35,400 --> 00:03:41,190
in kernel space because we've got needs

00:03:39,780 --> 00:03:43,350
for high performance we've got needs to

00:03:41,190 --> 00:03:44,670
talk to the hardware etc we probably

00:03:43,350 --> 00:03:47,730
don't want to be using something like

00:03:44,670 --> 00:03:50,400
Python or Java what could we do we could

00:03:47,730 --> 00:03:52,200
stick with C we could try hardening C

00:03:50,400 --> 00:03:53,819
there's a very good talk last year about

00:03:52,200 --> 00:03:56,760
make you see better people have talked

00:03:53,819 --> 00:03:58,260
about a few approaches so far one of the

00:03:56,760 --> 00:03:59,400
things we've picked up from this is that

00:03:58,260 --> 00:04:01,680
all of these are fundamentally

00:03:59,400 --> 00:04:03,359
mitigations they are we will have bugs

00:04:01,680 --> 00:04:06,269
we will not keep up with their bugs

00:04:03,359 --> 00:04:07,799
aslr is a workaround to perfect make the

00:04:06,269 --> 00:04:10,530
bugs harder but not impossible to

00:04:07,799 --> 00:04:12,780
exploit several fees like stack leak

00:04:10,530 --> 00:04:13,950
have overhead several these things like

00:04:12,780 --> 00:04:17,280
sparse and Coverity doing static

00:04:13,950 --> 00:04:18,570
analysis have been used but unlike at

00:04:17,280 --> 00:04:20,280
the end of the day they are not stemming

00:04:18,570 --> 00:04:22,680
the tide we are still having hundreds

00:04:20,280 --> 00:04:24,720
and hundreds of vulnerabilities so

00:04:22,680 --> 00:04:26,520
hardening see is a admirable goal but it

00:04:24,720 --> 00:04:28,110
is not quite enough

00:04:26,520 --> 00:04:31,080
what about isolation what if we say

00:04:28,110 --> 00:04:32,970
let's run parts of the kernel in you

00:04:31,080 --> 00:04:35,400
know we could run them in web assembly

00:04:32,970 --> 00:04:37,320
we used data sandbox name we could write

00:04:35,400 --> 00:04:39,900
interesting things in EVP F we could use

00:04:37,320 --> 00:04:41,669
Hardware support we could go microkernel

00:04:39,900 --> 00:04:44,280
which again has the same sort of

00:04:41,669 --> 00:04:47,220
overhead issue of how long does it take

00:04:44,280 --> 00:04:49,440
to execute code that is in isolation and

00:04:47,220 --> 00:04:52,410
can you even use isolation before things

00:04:49,440 --> 00:04:53,820
like can my scheduler be isolated can we

00:04:52,410 --> 00:04:55,590
you know how would I do that

00:04:53,820 --> 00:04:57,720
can my core TCP stack be isolated in how

00:04:55,590 --> 00:05:00,060
do I keep the same performance and also

00:04:57,720 --> 00:05:01,500
it prevents problems between modules but

00:05:00,060 --> 00:05:02,250
it does not really prevent a problem

00:05:01,500 --> 00:05:03,870
within a module

00:05:02,250 --> 00:05:06,330
I think of heartbleed for instance

00:05:03,870 --> 00:05:07,889
heartbleed was not OpenSSL attacking

00:05:06,330 --> 00:05:10,350
some other part of the system Hart blade

00:05:07,889 --> 00:05:12,449
was one request to open SSL leaking data

00:05:10,350 --> 00:05:17,580
from another request to the very same of

00:05:12,449 --> 00:05:19,620
an SSL and so there was a catch series

00:05:17,580 --> 00:05:23,039
that was posted earlier this year about

00:05:19,620 --> 00:05:25,650
system call isolation which is like page

00:05:23,039 --> 00:05:27,240
table isolation but even more so for

00:05:25,650 --> 00:05:29,250
system calls just saying you know

00:05:27,240 --> 00:05:32,820
everything's going to go wrong let us

00:05:29,250 --> 00:05:34,080
know very carefully bound what what

00:05:32,820 --> 00:05:36,210
happened to a system call had a very

00:05:34,080 --> 00:05:39,690
high overhead cost and one Enterprise

00:05:36,210 --> 00:05:41,460
was you know if the price of using Linux

00:05:39,690 --> 00:05:44,699
Linux using an insecure C runtime is too

00:05:41,460 --> 00:05:46,919
slow system calls down so much that you

00:05:44,699 --> 00:05:48,930
know you might as well be faster in Java

00:05:46,919 --> 00:05:50,340
why aren't we actually writing Linux in

00:05:48,930 --> 00:05:53,039
Java which is not an argument for Java

00:05:50,340 --> 00:05:56,159
but what is going on with C like what

00:05:53,039 --> 00:05:58,919
should we be doing here and if you go

00:05:56,159 --> 00:06:00,570
back to 2004 well in his head there was

00:05:58,919 --> 00:06:03,960
a proposal about should we write Linux

00:06:00,570 --> 00:06:05,940
in C++ and we can talk about you know

00:06:03,960 --> 00:06:08,760
why C++ does not actually solve any of

00:06:05,940 --> 00:06:10,710
memory safety problems but without you

00:06:08,760 --> 00:06:12,510
know quite endorsing the approach here I

00:06:10,710 --> 00:06:14,400
think that the ideas that Lenny

00:06:12,510 --> 00:06:17,310
mentioned are very important which is

00:06:14,400 --> 00:06:19,229
C++ brings things like exception

00:06:17,310 --> 00:06:20,820
handling it brings things like memory

00:06:19,229 --> 00:06:21,840
allocations and it brings things like a

00:06:20,820 --> 00:06:24,180
particular approach to Africa

00:06:21,840 --> 00:06:28,710
orientation which is not quite suitable

00:06:24,180 --> 00:06:31,380
for kernel space so what do we want out

00:06:28,710 --> 00:06:33,240
of a potential language here we want

00:06:31,380 --> 00:06:34,409
memory safety of course we want

00:06:33,240 --> 00:06:36,719
exception handling if it doesn't do

00:06:34,409 --> 00:06:37,389
unwinding we want oo without the

00:06:36,719 --> 00:06:38,560
overhead

00:06:37,389 --> 00:06:40,270
things like diamond dependencies

00:06:38,560 --> 00:06:42,610
multiple inheritance we don't want

00:06:40,270 --> 00:06:44,199
hidden memory allocations several

00:06:42,610 --> 00:06:46,389
promising languages have garbage

00:06:44,199 --> 00:06:49,030
collectors or runtimes which make them

00:06:46,389 --> 00:06:50,770
unsuitable and we also want very

00:06:49,030 --> 00:06:52,120
performant FFI to see if we have any

00:06:50,770 --> 00:06:55,689
hope of integrating with the existing

00:06:52,120 --> 00:06:57,310
large body of C code and so there's a

00:06:55,689 --> 00:06:59,590
handful of very good languages Haskell

00:06:57,310 --> 00:07:01,870
Goudy ADA etc which just happened not to

00:06:59,590 --> 00:07:03,430
be what we want for this purpose one

00:07:01,870 --> 00:07:05,379
thing I want to mention briefly is ADA

00:07:03,430 --> 00:07:06,580
people mention in the context of a save

00:07:05,379 --> 00:07:09,969
compiled language and I think it's

00:07:06,580 --> 00:07:12,009
unfamiliar to many people so the real

00:07:09,969 --> 00:07:15,039
issue with it is that within ada itself

00:07:12,009 --> 00:07:16,330
there is no sort of safe dynamic memory

00:07:15,039 --> 00:07:18,460
management it's designed for use cases

00:07:16,330 --> 00:07:20,050
where you can say I statically know

00:07:18,460 --> 00:07:21,550
exactly what my tasks are and what

00:07:20,050 --> 00:07:23,849
memory I want I can do that compile time

00:07:21,550 --> 00:07:27,460
there is support for dynamic allocation

00:07:23,849 --> 00:07:29,199
but as far as I know the deallocate

00:07:27,460 --> 00:07:30,789
operator is unsafe you were expected to

00:07:29,199 --> 00:07:33,610
track lifetimes on your own which brings

00:07:30,789 --> 00:07:34,689
back use after free etc the standard

00:07:33,610 --> 00:07:36,580
solution for things that are not

00:07:34,689 --> 00:07:38,469
embedded is to use a library that does

00:07:36,580 --> 00:07:41,440
garbage collection but we probably do

00:07:38,469 --> 00:07:43,419
not want to garbage collection so that

00:07:41,440 --> 00:07:44,860
brings us to rust rust is a compiled

00:07:43,419 --> 00:07:47,229
language intended for systems

00:07:44,860 --> 00:07:48,430
programming Mozilla research or some

00:07:47,229 --> 00:07:50,469
individuals resume relation originally

00:07:48,430 --> 00:07:52,180
created as a better slash more secure

00:07:50,469 --> 00:07:54,909
implication language for Firefox which

00:07:52,180 --> 00:07:57,430
is a very large C++ code base it now has

00:07:54,909 --> 00:08:00,789
many production users and relevantly for

00:07:57,430 --> 00:08:03,129
us it is backed by LVM in userspace it

00:08:00,789 --> 00:08:04,210
uses the system linker in Lib C it

00:08:03,129 --> 00:08:06,699
generates auto files

00:08:04,210 --> 00:08:08,889
uses the platform calling convention etc

00:08:06,699 --> 00:08:10,750
basically it is a language that sort of

00:08:08,889 --> 00:08:13,120
operates the way folks who are working

00:08:10,750 --> 00:08:14,800
on C would expect it to work and so that

00:08:13,120 --> 00:08:17,139
makes it suitable for incremental

00:08:14,800 --> 00:08:18,520
rewrites you can use rust to generate a

00:08:17,139 --> 00:08:20,039
dot o that you can very directly call

00:08:18,520 --> 00:08:23,229
from C and vice versa

00:08:20,039 --> 00:08:25,150
if you were familiar with rust before

00:08:23,229 --> 00:08:27,039
1.0 you might remember that it had a

00:08:25,150 --> 00:08:29,560
garbage collector that it had a

00:08:27,039 --> 00:08:31,599
threading runtime built in it had Sigma

00:08:29,560 --> 00:08:33,699
2 stacks etc all of this was removed

00:08:31,599 --> 00:08:36,729
during rust development before 100 and

00:08:33,699 --> 00:08:38,500
so now it's a very sort of tight C

00:08:36,729 --> 00:08:41,680
compatible language which makes it

00:08:38,500 --> 00:08:43,750
appealing so let's take a look at what

00:08:41,680 --> 00:08:46,000
Russ does for memory safety I'm going

00:08:43,750 --> 00:08:47,740
very fast if you are interested in

00:08:46,000 --> 00:08:49,990
working in rust I strongly recommend the

00:08:47,740 --> 00:08:50,800
official book on their website I don't

00:08:49,990 --> 00:08:52,569
have enough time to go

00:08:50,800 --> 00:08:56,529
and cover it in huge amounts of detail

00:08:52,569 --> 00:08:58,899
so this will be fast this is a hello

00:08:56,529 --> 00:09:00,369
world very simple program the syntax

00:08:58,899 --> 00:09:02,439
should be largely familiar to C

00:09:00,369 --> 00:09:05,050
programmers a couple things to note here

00:09:02,439 --> 00:09:06,699
first types and local variables are

00:09:05,050 --> 00:09:07,929
optional if they can be inferred but in

00:09:06,699 --> 00:09:10,600
our examples we're going to be adding

00:09:07,929 --> 00:09:12,189
type annotations for clarity second

00:09:10,600 --> 00:09:14,499
unusual thing here is that exclamation

00:09:12,189 --> 00:09:16,449
point after print line means that it's a

00:09:14,499 --> 00:09:18,939
macro why it's a macro is a little bit

00:09:16,449 --> 00:09:20,619
out of scope for this talk but basically

00:09:18,939 --> 00:09:21,999
since print line wants to take an

00:09:20,619 --> 00:09:23,860
arbitrary number of parameters with

00:09:21,999 --> 00:09:25,540
arbitrary numbers types has to do some

00:09:23,860 --> 00:09:28,480
stuff at compile time to handle variable

00:09:25,540 --> 00:09:29,769
arguments in a safe way and so if you

00:09:28,480 --> 00:09:31,899
see the exclamation point all it means

00:09:29,769 --> 00:09:33,489
is it is a macro that doesn't quite

00:09:31,899 --> 00:09:35,649
follow it's not a functions on quite

00:09:33,489 --> 00:09:39,730
follow syntax that's all it's pretty

00:09:35,649 --> 00:09:41,889
rare so variables and rust are constant

00:09:39,730 --> 00:09:44,379
by default so this program is an error

00:09:41,889 --> 00:09:46,660
it will say you tried to modify X which

00:09:44,379 --> 00:09:50,290
is not mutable so you can just modify it

00:09:46,660 --> 00:09:51,279
make it mutable and this will run you're

00:09:50,290 --> 00:09:52,929
allowed to leave a variable

00:09:51,279 --> 00:09:55,540
uninitialized and rust but you have to

00:09:52,929 --> 00:09:56,709
assign something to that variable before

00:09:55,540 --> 00:09:59,559
you use it

00:09:56,709 --> 00:10:00,910
so unlike and C you can't have

00:09:59,559 --> 00:10:04,240
accidental use of uninitialized

00:10:00,910 --> 00:10:05,619
variables in this case the first line is

00:10:04,240 --> 00:10:07,720
perfectly legitimate but the rest will

00:10:05,619 --> 00:10:09,040
notice by the second line this variable

00:10:07,720 --> 00:10:11,319
was potentially I initialized that is an

00:10:09,040 --> 00:10:14,199
error that is not just a warning and

00:10:11,319 --> 00:10:15,879
also you get this error message which

00:10:14,199 --> 00:10:17,769
says that rust wants to or print line

00:10:15,879 --> 00:10:20,529
rather wants to borrow this variable X

00:10:17,769 --> 00:10:23,019
so we'll talk about rust reference

00:10:20,529 --> 00:10:25,929
system in a tiny bit and how what Baro

00:10:23,019 --> 00:10:28,470
means in that context a few more bits of

00:10:25,929 --> 00:10:30,670
syntax rust has structures just like C

00:10:28,470 --> 00:10:33,160
syntax is a little bit different but

00:10:30,670 --> 00:10:34,509
should be pretty familiar rust lets you

00:10:33,160 --> 00:10:36,269
put methods on structures which is

00:10:34,509 --> 00:10:40,119
probably starting to remind you of c++

00:10:36,269 --> 00:10:42,699
and you should not take this as it being

00:10:40,119 --> 00:10:44,259
like c++ this object orientation it does

00:10:42,699 --> 00:10:45,970
not have inheritance encourages you to

00:10:44,259 --> 00:10:48,100
use composition which is good for us it

00:10:45,970 --> 00:10:49,720
avoids multiple inheritance virtual

00:10:48,100 --> 00:10:51,939
functions down casting all sorts of

00:10:49,720 --> 00:10:53,739
weird runtime stuff you don't have the

00:10:51,939 --> 00:10:56,679
question about is a square a subclass of

00:10:53,739 --> 00:10:58,929
a rectangle or vice-versa you try to

00:10:56,679 --> 00:10:59,829
avoid that and a couple of syntax notes

00:10:58,929 --> 00:11:02,139
here that

00:10:59,829 --> 00:11:03,650
ampersand in self means reference which

00:11:02,139 --> 00:11:05,779
we'll get to in a little bit

00:11:03,650 --> 00:11:07,970
for now you should just read that as a

00:11:05,779 --> 00:11:10,760
con star except your guarantee that is

00:11:07,970 --> 00:11:12,860
valid also note the arrow for return

00:11:10,760 --> 00:11:15,110
value and finally if you end a function

00:11:12,860 --> 00:11:17,240
with an expression and no semicolon it

00:11:15,110 --> 00:11:18,410
just returns that value one of the

00:11:17,240 --> 00:11:20,240
things about Brussels it was designed

00:11:18,410 --> 00:11:21,620
with some good amount of influence from

00:11:20,240 --> 00:11:23,060
functional programming communities

00:11:21,620 --> 00:11:24,800
it isn't imperative language it is a

00:11:23,060 --> 00:11:27,140
systems language but you can see that

00:11:24,800 --> 00:11:29,180
influence here rust also does have

00:11:27,140 --> 00:11:30,500
public and private we don't have time to

00:11:29,180 --> 00:11:33,070
cover that here but you can definitely

00:11:30,500 --> 00:11:35,420
say I am making a safe abstraction and

00:11:33,070 --> 00:11:36,770
I'm encapsulating sort of what happens

00:11:35,420 --> 00:11:38,750
underneath so you get the good parts of

00:11:36,770 --> 00:11:40,310
oo which is a encapsulation abstraction

00:11:38,750 --> 00:11:43,240
sort of putting things where they belong

00:11:40,310 --> 00:11:45,890
but you stay away from the weird parts

00:11:43,240 --> 00:11:48,140
the way rust gets you polymorphism is

00:11:45,890 --> 00:11:49,400
what's called traits a trait is a set of

00:11:48,140 --> 00:11:51,620
methods that you can implement on a

00:11:49,400 --> 00:11:53,480
structure it's like an interface or a

00:11:51,620 --> 00:11:54,680
protocol in some other languages or for

00:11:53,480 --> 00:11:57,440
Colonel folks you would recognize this

00:11:54,680 --> 00:11:58,910
as similar to an operation structure you

00:11:57,440 --> 00:12:01,040
can put default implementations and

00:11:58,910 --> 00:12:02,270
traits you can have traits that depend

00:12:01,040 --> 00:12:04,010
on other traits like you can only

00:12:02,270 --> 00:12:05,930
implement shape if you also implement

00:12:04,010 --> 00:12:08,000
you know surface or something I don't

00:12:05,930 --> 00:12:10,190
know but it won't like you have problems

00:12:08,000 --> 00:12:12,200
like method name conflicts if I had both

00:12:10,190 --> 00:12:13,940
this area function I'm defining here and

00:12:12,200 --> 00:12:15,920
the one for the previous slide and I had

00:12:13,940 --> 00:12:18,230
like my circle dot area it would

00:12:15,920 --> 00:12:19,850
actually say you know that's that's

00:12:18,230 --> 00:12:21,980
ambiguous which one do you want me to

00:12:19,850 --> 00:12:24,080
call so it is not inheritance it is a

00:12:21,980 --> 00:12:28,040
collection of methods it is you know a

00:12:24,080 --> 00:12:30,230
lot more obvious what's going on you can

00:12:28,040 --> 00:12:32,660
do generic slash polymorphism in two

00:12:30,230 --> 00:12:34,279
ways one is you can make it generic over

00:12:32,660 --> 00:12:36,440
anything that implements a trait and

00:12:34,279 --> 00:12:38,029
this is expanded at compile time for

00:12:36,440 --> 00:12:39,650
each time that uses it there's no

00:12:38,029 --> 00:12:41,450
runtime dynamic stuff that's called here

00:12:39,650 --> 00:12:42,770
if I take this function I call it on a

00:12:41,450 --> 00:12:44,750
circle and I call it on a rectangle

00:12:42,770 --> 00:12:47,060
there'll be two copies of this code in

00:12:44,750 --> 00:12:49,190
the final binary the other thing I can

00:12:47,060 --> 00:12:51,830
do is I can do a dynamic call where I

00:12:49,190 --> 00:12:54,380
say I actually do want to take a trait

00:12:51,830 --> 00:12:56,959
object which is basically a fat pointer

00:12:54,380 --> 00:12:59,300
with both the object itself and the

00:12:56,959 --> 00:13:00,680
vtable for what methods I want and so

00:12:59,300 --> 00:13:03,290
this will compile into a single function

00:13:00,680 --> 00:13:05,600
that does a dispatch at runtime on the

00:13:03,290 --> 00:13:06,770
type of shape and you'll see the dine

00:13:05,600 --> 00:13:08,150
keyword and that sort of a general

00:13:06,770 --> 00:13:10,010
pattern in rust if there's some

00:13:08,150 --> 00:13:11,600
complexity happening at runtime you have

00:13:10,010 --> 00:13:13,070
to specifically opt into it usually

00:13:11,600 --> 00:13:15,350
there's some syntax calling out that

00:13:13,070 --> 00:13:17,089
you're doing something special and so

00:13:15,350 --> 00:13:17,480
you can also doing a lot of neat things

00:13:17,089 --> 00:13:19,010
like a pie

00:13:17,480 --> 00:13:21,410
time like we saw on the last slide and

00:13:19,010 --> 00:13:24,260
they compiled out with rust as LTO and

00:13:21,410 --> 00:13:25,790
often just optimized out we will also

00:13:24,260 --> 00:13:28,670
see the borrowed checker in a little bit

00:13:25,790 --> 00:13:30,440
which is also all at compile time rusted

00:13:28,670 --> 00:13:32,660
C++ both have a term for this which is

00:13:30,440 --> 00:13:35,209
zero cost abstractions which means you

00:13:32,660 --> 00:13:37,399
only pay for things you want to pay for

00:13:35,209 --> 00:13:39,709
and the language is not imposing things

00:13:37,399 --> 00:13:41,089
on you and that is I think one of the

00:13:39,709 --> 00:13:42,589
things that's absolutely critical if

00:13:41,089 --> 00:13:46,550
you're thinking what language should I

00:13:42,589 --> 00:13:49,130
use for something like a kernel rust

00:13:46,550 --> 00:13:51,829
also has enums the first part of this

00:13:49,130 --> 00:13:54,199
should look familiar from C an enum is a

00:13:51,829 --> 00:13:57,260
unique type it is not just an alias for

00:13:54,199 --> 00:13:59,089
the integer and it is impossible and

00:13:57,260 --> 00:14:01,310
safe rust to construct an enum that is

00:13:59,089 --> 00:14:02,959
not one of these values so this match

00:14:01,310 --> 00:14:04,850
statement at the bottom is in fact

00:14:02,959 --> 00:14:07,880
exhaustive even though it doesn't have a

00:14:04,850 --> 00:14:10,220
default case because you know any object

00:14:07,880 --> 00:14:13,670
of type go over commit policy has to be

00:14:10,220 --> 00:14:16,160
one of those three values enums can

00:14:13,670 --> 00:14:18,050
carry data so this probably looks a

00:14:16,160 --> 00:14:19,459
little bit less familiar from C if you

00:14:18,050 --> 00:14:22,569
have a functional programming background

00:14:19,459 --> 00:14:25,100
you might recognize this as a some type

00:14:22,569 --> 00:14:27,740
the underlying storage format is an

00:14:25,100 --> 00:14:29,750
integer discriminant saying what is what

00:14:27,740 --> 00:14:31,760
type what variant of enum it is followed

00:14:29,750 --> 00:14:34,339
by the data so it's a tagged Union it's

00:14:31,760 --> 00:14:36,980
not quite like us to Union and access to

00:14:34,339 --> 00:14:39,170
the data is safe in that the only way

00:14:36,980 --> 00:14:40,819
you can get a reference to a member of a

00:14:39,170 --> 00:14:42,199
particular variant is if you have

00:14:40,819 --> 00:14:44,510
actually checked that it belongs to this

00:14:42,199 --> 00:14:46,940
variant so in this match statement I

00:14:44,510 --> 00:14:49,399
cannot access host unless it's actually

00:14:46,940 --> 00:14:53,360
of type of subtype address colon colon

00:14:49,399 --> 00:14:56,060
IP and there are very two common enums

00:14:53,360 --> 00:14:58,310
and rust option and result which are

00:14:56,060 --> 00:14:59,720
defined in the standard library option

00:14:58,310 --> 00:15:02,329
is what you'd use for optional or

00:14:59,720 --> 00:15:03,709
nullable values and result is how you do

00:15:02,329 --> 00:15:05,930
error handling you either have a

00:15:03,709 --> 00:15:08,660
successful value of type T or an error

00:15:05,930 --> 00:15:10,579
object of type e an error object can be

00:15:08,660 --> 00:15:12,319
or whatever sort of thing makes sense

00:15:10,579 --> 00:15:14,029
maybe it's an enum that has various

00:15:12,319 --> 00:15:16,160
types of errors

00:15:14,029 --> 00:15:17,899
it's common for libraries to type def a

00:15:16,160 --> 00:15:20,720
result type with their particular error

00:15:17,899 --> 00:15:24,230
object and then there's one more syntax

00:15:20,720 --> 00:15:26,230
construct if yeah it's not here if flat

00:15:24,230 --> 00:15:28,910
which is the same sort of thing as match

00:15:26,230 --> 00:15:30,860
combined with if the only way you can

00:15:28,910 --> 00:15:32,330
get at a action

00:15:30,860 --> 00:15:34,450
a useable object of type T out of an

00:15:32,330 --> 00:15:37,520
option is if it is in fact of this

00:15:34,450 --> 00:15:39,620
variant called some if it's a nun that

00:15:37,520 --> 00:15:42,950
code won't execute and so that sort of

00:15:39,620 --> 00:15:44,570
wipes away your null pointer issues

00:15:42,950 --> 00:15:46,430
right there you can never accidentally

00:15:44,570 --> 00:15:48,320
take something and forget to check

00:15:46,430 --> 00:15:50,300
whether it's null the only way you can

00:15:48,320 --> 00:15:51,710
get into it is by checking and rust

00:15:50,300 --> 00:15:53,630
actually does one thing to optimize

00:15:51,710 --> 00:15:56,750
storage which is that since all pointers

00:15:53,630 --> 00:15:58,970
in rust are valid / not null if you have

00:15:56,750 --> 00:16:00,980
an option of a reference it just stores

00:15:58,970 --> 00:16:03,020
the nun as a null pointer so at the end

00:16:00,980 --> 00:16:05,570
of the day the representation memory is

00:16:03,020 --> 00:16:08,000
just like an SI but at the syntax level

00:16:05,570 --> 00:16:10,850
there's no way to accidentally mess this

00:16:08,000 --> 00:16:13,640
up and rust doesn't have exceptions that

00:16:10,850 --> 00:16:15,290
you throw in catch because they've got

00:16:13,640 --> 00:16:17,240
pretty good syntax for handling options

00:16:15,290 --> 00:16:18,500
and results the recommended way to

00:16:17,240 --> 00:16:20,720
handle things that could potentially

00:16:18,500 --> 00:16:23,060
fail is to return a result or an option

00:16:20,720 --> 00:16:24,500
have the caller check it which again is

00:16:23,060 --> 00:16:26,600
pretty similar to how the kernel does

00:16:24,500 --> 00:16:28,670
error handling you return a pointer that

00:16:26,600 --> 00:16:30,590
has one of the magical error values is a

00:16:28,670 --> 00:16:33,020
negative value or something and you have

00:16:30,590 --> 00:16:35,420
the caller check it and so there's no

00:16:33,020 --> 00:16:37,880
exception throwing in the kernel so very

00:16:35,420 --> 00:16:39,230
ship you should feel very similar with

00:16:37,880 --> 00:16:41,480
the notable advantage of it is

00:16:39,230 --> 00:16:42,800
statically checked sort of at compile

00:16:41,480 --> 00:16:44,750
time that you were not accidentally

00:16:42,800 --> 00:16:48,230
taking negative Ino ma'am and using that

00:16:44,750 --> 00:16:49,910
as a pointer or whatever and there's one

00:16:48,230 --> 00:16:52,520
even nicer bit of syntax which is the

00:16:49,910 --> 00:16:55,610
question mark operator some of the left

00:16:52,520 --> 00:17:00,530
- question mark expands to one of two

00:16:55,610 --> 00:17:02,720
possible things if it's okay then if I

00:17:00,530 --> 00:17:03,800
see if I have an object of variate okay

00:17:02,720 --> 00:17:06,320
and I put the question mark it just

00:17:03,800 --> 00:17:07,880
unwraps it if I have an object of

00:17:06,320 --> 00:17:10,940
variant error and I put the question

00:17:07,880 --> 00:17:13,280
mark it expands syntactically it's

00:17:10,940 --> 00:17:14,990
basically syntax sugar for a return from

00:17:13,280 --> 00:17:16,700
this function converting the error

00:17:14,990 --> 00:17:20,720
object if necessary to the error of this

00:17:16,700 --> 00:17:22,100
type so I can make code that reads very

00:17:20,720 --> 00:17:23,810
straightforwardly like code on the right

00:17:22,100 --> 00:17:25,850
well I say I'm going to open this thing

00:17:23,810 --> 00:17:27,320
that might fail I'm going to read it

00:17:25,850 --> 00:17:28,880
that might fail and get a parse it that

00:17:27,320 --> 00:17:31,640
might fail at the end if that all worked

00:17:28,880 --> 00:17:33,740
I will return another result type with

00:17:31,640 --> 00:17:35,840
my data and a straight line code there's

00:17:33,740 --> 00:17:38,450
no throwing catch behind the scenes it's

00:17:35,840 --> 00:17:40,660
very clear what this is expanding to the

00:17:38,450 --> 00:17:43,850
compiler isn't doing anything magical

00:17:40,660 --> 00:17:44,659
and so if I ever wanted to handle one of

00:17:43,850 --> 00:17:46,249
these cases myself

00:17:44,659 --> 00:17:50,149
with the match statement I could just do

00:17:46,249 --> 00:17:51,409
that so nothing implicit it's just like

00:17:50,149 --> 00:17:54,529
if I put a bunch of if statements and

00:17:51,409 --> 00:17:56,479
see but I don't have to write that for

00:17:54,529 --> 00:17:59,149
genuinely exceptional conditions like

00:17:56,479 --> 00:18:01,220
division by zero or indexing out of

00:17:59,149 --> 00:18:03,799
bounds so one over zero or three four

00:18:01,220 --> 00:18:06,289
five sub ten will do would rust cause a

00:18:03,799 --> 00:18:08,149
panic that's usually implemented with

00:18:06,289 --> 00:18:09,950
the same infrastructure as CFLs plus

00:18:08,149 --> 00:18:12,590
exception throwing and that it unwinds

00:18:09,950 --> 00:18:14,210
the stack it can be caught but it is

00:18:12,590 --> 00:18:16,729
strongly not recommended to use it for

00:18:14,210 --> 00:18:19,070
error handling it's mostly for things

00:18:16,729 --> 00:18:20,989
like I have a web server and one of the

00:18:19,070 --> 00:18:22,249
threads has panicked but I want the rest

00:18:20,989 --> 00:18:25,279
of the web server to continue running if

00:18:22,249 --> 00:18:27,080
possible or in kernel and I have you

00:18:25,279 --> 00:18:28,970
know one kernel thread or sis call that

00:18:27,080 --> 00:18:30,590
hit a bug and I would like to kill that

00:18:28,970 --> 00:18:33,080
user space process but I would like to

00:18:30,590 --> 00:18:34,549
not panic the entire kernel and so again

00:18:33,080 --> 00:18:36,950
sort of similar philosophy and how you

00:18:34,549 --> 00:18:39,710
design things if you have something that

00:18:36,950 --> 00:18:40,999
might fail rust basically always you

00:18:39,710 --> 00:18:43,359
know as a convention libraries will give

00:18:40,999 --> 00:18:46,580
you a way to do that without panicking

00:18:43,359 --> 00:18:48,739
and so if you do get instead of the

00:18:46,580 --> 00:18:50,389
index operator it will give you an

00:18:48,739 --> 00:18:53,119
option and so in this case three four

00:18:50,389 --> 00:18:54,769
five ten will just return you none and

00:18:53,119 --> 00:18:57,889
then you can always do an explicit panic

00:18:54,769 --> 00:18:58,879
with the panic macro and so yeah if you

00:18:57,889 --> 00:19:00,200
haven't noticed the thing I'm trying to

00:18:58,879 --> 00:19:02,299
sell you on here is the way you rust

00:19:00,200 --> 00:19:04,369
things about things like how do I do oo

00:19:02,299 --> 00:19:06,049
or how do I do error handling turns out

00:19:04,369 --> 00:19:08,029
to be very similar to the way the Linux

00:19:06,049 --> 00:19:10,220
kernel has also decided what is the best

00:19:08,029 --> 00:19:11,960
way to handle object orientation how do

00:19:10,220 --> 00:19:13,909
I put a bunch of methods on an inode or

00:19:11,960 --> 00:19:16,220
you know how do I handle something that

00:19:13,909 --> 00:19:17,419
might seg V on behalf of a users based

00:19:16,220 --> 00:19:21,499
process without killing the entire

00:19:17,419 --> 00:19:23,299
program or an entire kernel okay that's

00:19:21,499 --> 00:19:26,179
enough syntax hopefully some of that

00:19:23,299 --> 00:19:29,229
stuck so let's look at how rust handles

00:19:26,179 --> 00:19:31,909
safety without a garbage collector so

00:19:29,229 --> 00:19:33,979
start with references here we are taking

00:19:31,909 --> 00:19:36,470
a reference to X and we are storing that

00:19:33,979 --> 00:19:38,599
in a reference variable called Y and we

00:19:36,470 --> 00:19:40,129
dereference that and print it I can also

00:19:38,599 --> 00:19:41,929
move that to a function to show how

00:19:40,129 --> 00:19:43,669
writing a function that accepts a

00:19:41,929 --> 00:19:46,039
reference works it's pretty

00:19:43,669 --> 00:19:47,479
straightforward but rust is behind the

00:19:46,039 --> 00:19:49,669
scenes and forcing rules on how you

00:19:47,479 --> 00:19:51,289
borrow variables and most of what we

00:19:49,669 --> 00:19:52,460
like about rust for our purpose and how

00:19:51,289 --> 00:19:54,470
it solves all the memory problems we

00:19:52,460 --> 00:19:56,989
talked about is based on these rules so

00:19:54,470 --> 00:19:58,490
it's got a borrow checker and when you

00:19:56,989 --> 00:20:00,020
take a reference with variable

00:19:58,490 --> 00:20:01,760
keeps track of how long you are

00:20:00,020 --> 00:20:04,580
borrowing that variable is syntactically

00:20:01,760 --> 00:20:06,740
lexically and you cannot borrow a

00:20:04,580 --> 00:20:07,360
variable for a longer than it actually

00:20:06,740 --> 00:20:11,240
exists

00:20:07,360 --> 00:20:13,610
so imagine a for loop like this for I

00:20:11,240 --> 00:20:16,010
and one through five y equals reference

00:20:13,610 --> 00:20:18,230
to I and then I try to print line Y at

00:20:16,010 --> 00:20:19,760
the end of that for loop this would be a

00:20:18,230 --> 00:20:22,400
very easy mistake to make in a language

00:20:19,760 --> 00:20:24,200
like C in that you could have something

00:20:22,400 --> 00:20:27,170
and just have it escape the stack from

00:20:24,200 --> 00:20:28,640
beyond where it lived and in a language

00:20:27,170 --> 00:20:30,890
with garbage collector ref counting

00:20:28,640 --> 00:20:32,660
imagine Python or Java the way we'd

00:20:30,890 --> 00:20:33,890
handle this is by just doing an Inc

00:20:32,660 --> 00:20:35,030
graph incrementing the reference count

00:20:33,890 --> 00:20:37,010
on high and just keeping that alive

00:20:35,030 --> 00:20:39,530
until the end of the function but rust

00:20:37,010 --> 00:20:40,850
does not want garbage collections sort

00:20:39,530 --> 00:20:41,270
of I don't know when this objects being

00:20:40,850 --> 00:20:43,220
released

00:20:41,270 --> 00:20:45,340
you want to know statically what is

00:20:43,220 --> 00:20:47,690
happening to your memory usage and so

00:20:45,340 --> 00:20:49,100
the compiler is tracking where each

00:20:47,690 --> 00:20:50,809
reference comes from and it gives you an

00:20:49,100 --> 00:20:53,780
error yeah absolutely do quite clear

00:20:50,809 --> 00:20:55,790
error saying you know apt this

00:20:53,780 --> 00:20:57,350
particular location I does not live long

00:20:55,790 --> 00:20:59,420
enough because it was borrowed from over

00:20:57,350 --> 00:21:03,230
here and it was dropped at this curly

00:20:59,420 --> 00:21:05,090
brace if you want this to you work one

00:21:03,230 --> 00:21:07,400
thing you could do is use the standard

00:21:05,090 --> 00:21:10,340
library type RC which is a ref counting

00:21:07,400 --> 00:21:12,559
pointer that is an opt-in I would like

00:21:10,340 --> 00:21:13,910
to just allocate this on the heap and

00:21:12,559 --> 00:21:17,450
permit the ref every time I make another

00:21:13,910 --> 00:21:19,160
pointer to it and ridi allocate it once

00:21:17,450 --> 00:21:20,809
the ref count drops to zero

00:21:19,160 --> 00:21:22,070
and so in terms of overhead is like any

00:21:20,809 --> 00:21:23,690
ref count under garbage collected

00:21:22,070 --> 00:21:25,700
language but it has the advantage that

00:21:23,690 --> 00:21:27,470
you only pay for that cost if you

00:21:25,700 --> 00:21:30,710
actually want it you actually say this

00:21:27,470 --> 00:21:32,780
is what I want and like variables

00:21:30,710 --> 00:21:35,410
references are also constant by default

00:21:32,780 --> 00:21:37,280
if I try to modify something through a

00:21:35,410 --> 00:21:39,950
ampersand reference instead of any

00:21:37,280 --> 00:21:43,130
ampersand mute reference it will say you

00:21:39,950 --> 00:21:44,780
can't do that and gives me an error tell

00:21:43,130 --> 00:21:45,980
me what I should change and Russ does

00:21:44,780 --> 00:21:48,590
something more interesting with mutable

00:21:45,980 --> 00:21:50,720
references which is that you can't have

00:21:48,590 --> 00:21:52,940
more than one mutable reference at the

00:21:50,720 --> 00:21:55,340
same time you can't have a mutable

00:21:52,940 --> 00:21:57,830
reference and a constant reference at

00:21:55,340 --> 00:21:59,780
the same time basically you can think of

00:21:57,830 --> 00:22:01,850
this as a compile time reader/writer

00:21:59,780 --> 00:22:04,010
lock you can have multiple readers but

00:22:01,850 --> 00:22:05,800
you can only have one writer and that

00:22:04,010 --> 00:22:08,150
writer that mutable reference is

00:22:05,800 --> 00:22:11,150
temporarily borrowing all access to that

00:22:08,150 --> 00:22:12,860
variable for as long as it exists so

00:22:11,150 --> 00:22:15,080
really the way to think of

00:22:12,860 --> 00:22:17,750
and well like in a next slide I think

00:22:15,080 --> 00:22:19,790
about how you would get around this if

00:22:17,750 --> 00:22:21,440
you do have ways to safely modify a

00:22:19,790 --> 00:22:23,150
variable concurrently

00:22:21,440 --> 00:22:24,800
is that you should think about ampersand

00:22:23,150 --> 00:22:25,820
mute as a unique reference and you

00:22:24,800 --> 00:22:27,770
should think about the ampersand as a

00:22:25,820 --> 00:22:30,200
shared reference if you have a piece of

00:22:27,770 --> 00:22:32,210
data with ampersand mute you know that

00:22:30,200 --> 00:22:34,250
nobody is aliasing it nobody else has a

00:22:32,210 --> 00:22:36,590
reference to it etc if you're a piece of

00:22:34,250 --> 00:22:38,630
day with a murse and you know you don't

00:22:36,590 --> 00:22:40,340
know that no one else is aliasing it but

00:22:38,630 --> 00:22:44,020
you do know that it is living for as

00:22:40,340 --> 00:22:44,020
long as you have this reference around

00:22:44,140 --> 00:22:47,540
so you might be thinking at this point

00:22:45,920 --> 00:22:49,190
this all seems very restrictive or what

00:22:47,540 --> 00:22:51,080
if I do want to modify something

00:22:49,190 --> 00:22:53,090
concurrently obviously if I followed

00:22:51,080 --> 00:22:54,350
that rule just there with the ampersand

00:22:53,090 --> 00:22:55,490
represent mute I won't have any use

00:22:54,350 --> 00:22:57,170
after phrase I won't have any race

00:22:55,490 --> 00:22:58,940
conditions but like there are plenty of

00:22:57,170 --> 00:23:00,290
cases where two people have mutable

00:22:58,940 --> 00:23:01,850
pointers the same data and they

00:23:00,290 --> 00:23:04,940
successfully avoid a corrupting memory

00:23:01,850 --> 00:23:06,230
how do I do that and so that's great as

00:23:04,940 --> 00:23:08,420
long as you do it in a controlled way

00:23:06,230 --> 00:23:11,120
Russ lets you bypass all of these rules

00:23:08,420 --> 00:23:12,680
as long as you use the keyword unsafe so

00:23:11,120 --> 00:23:15,320
what you should do is create safe

00:23:12,680 --> 00:23:17,120
abstractions where you say I've got a

00:23:15,320 --> 00:23:18,950
wrapper type or the implementation uses

00:23:17,120 --> 00:23:20,840
the keyword unsafe and it's checking in

00:23:18,950 --> 00:23:23,240
some way using the type system using

00:23:20,840 --> 00:23:26,300
syntax etc that what I'm doing is safe

00:23:23,240 --> 00:23:28,580
and then a test I can use unsafe I know

00:23:26,300 --> 00:23:30,320
what I'm doing and you can also of

00:23:28,580 --> 00:23:32,150
course just use the keyword unsafe and

00:23:30,320 --> 00:23:33,260
break all the rules if you want to I

00:23:32,150 --> 00:23:34,640
won't give you examples of that because

00:23:33,260 --> 00:23:36,080
that's less interesting but that escape

00:23:34,640 --> 00:23:37,820
hatch is always there if you really want

00:23:36,080 --> 00:23:39,590
to write some code like you're writing C

00:23:37,820 --> 00:23:40,760
and you don't want to think about the

00:23:39,590 --> 00:23:42,680
rules of correctness you can still

00:23:40,760 --> 00:23:45,260
always do that in rust just but a big

00:23:42,680 --> 00:23:46,610
unsafe block around your character but

00:23:45,260 --> 00:23:50,000
let's look at how you do this in a

00:23:46,610 --> 00:23:51,860
controlled way so an atomic you 32 in

00:23:50,000 --> 00:23:54,800
particular this is a type from the rust

00:23:51,860 --> 00:23:58,160
standard library is something that you

00:23:54,800 --> 00:23:59,810
can actually modify through a ampersand

00:23:58,160 --> 00:24:02,180
which is to say a shared reference

00:23:59,810 --> 00:24:03,920
because it's atomic that's safe you have

00:24:02,180 --> 00:24:05,570
no risks of like reading it while it's

00:24:03,920 --> 00:24:07,700
being written and seeing a torn value

00:24:05,570 --> 00:24:09,860
seeing a data race undefined usually

00:24:07,700 --> 00:24:11,480
undefined behavior problems and so it's

00:24:09,860 --> 00:24:12,950
safe to have multiple threads access is

00:24:11,480 --> 00:24:14,540
it safe to have reentered code is safe

00:24:12,950 --> 00:24:17,150
to have an interrupt handler access etc

00:24:14,540 --> 00:24:18,890
and so what the author of this code the

00:24:17,150 --> 00:24:20,270
implementation of atomic in a very

00:24:18,890 --> 00:24:22,730
simplified way is shown on the right

00:24:20,270 --> 00:24:25,030
side here what the author of eCos saying

00:24:22,730 --> 00:24:27,190
with this unsafe block

00:24:25,030 --> 00:24:29,080
I know that even though this function

00:24:27,190 --> 00:24:32,290
takes an ampersand itself not in here

00:24:29,080 --> 00:24:34,060
percent mute self this underlying atomic

00:24:32,290 --> 00:24:36,700
store in this case that's an LVN

00:24:34,060 --> 00:24:40,390
intrinsic that is actually safe to do on

00:24:36,700 --> 00:24:42,580
a shared reference and on a multiple

00:24:40,390 --> 00:24:43,780
people have access to it and so as long

00:24:42,580 --> 00:24:46,240
as they are correct when they're writing

00:24:43,780 --> 00:24:48,820
this I the application author on the

00:24:46,240 --> 00:24:49,840
Left can write my code calling these

00:24:48,820 --> 00:24:53,170
functions they don't have to use the

00:24:49,840 --> 00:24:54,850
keyword unsafe and there's no deep magic

00:24:53,170 --> 00:24:56,140
by the way in atomic you 32 it is

00:24:54,850 --> 00:24:58,750
implemented much like this in the

00:24:56,140 --> 00:25:00,790
standard library the only magical thing

00:24:58,750 --> 00:25:03,160
is this word unsafe cell which is an

00:25:00,790 --> 00:25:05,140
indicator to the compiler that multiple

00:25:03,160 --> 00:25:07,150
people might be referencing this data or

00:25:05,140 --> 00:25:09,280
might be writing to this data even

00:25:07,150 --> 00:25:11,950
through an ampersand reference and so

00:25:09,280 --> 00:25:13,450
you should not optimize that it is what

00:25:11,950 --> 00:25:14,860
you've always wanted if you're like I'll

00:25:13,450 --> 00:25:18,430
just throw a volatile on this but it's

00:25:14,860 --> 00:25:19,810
actually defined bigger and so this same

00:25:18,430 --> 00:25:21,550
pattern is true of things like lock

00:25:19,810 --> 00:25:23,950
guards you can have some data behind a

00:25:21,550 --> 00:25:25,390
lock you can have a type that says I'm

00:25:23,950 --> 00:25:26,920
safely managing in current access

00:25:25,390 --> 00:25:29,170
because I've got a spin lock on this and

00:25:26,920 --> 00:25:31,330
from an ampersand reference to a spin

00:25:29,170 --> 00:25:33,400
lock you can say I'm gonna give you a

00:25:31,330 --> 00:25:34,900
borrowed a temporary ampersand mute to

00:25:33,400 --> 00:25:41,410
the underlying data until you've release

00:25:34,900 --> 00:25:44,560
locked so some more examples of a safe

00:25:41,410 --> 00:25:47,500
and unsafe rust if you want to deal with

00:25:44,560 --> 00:25:49,240
raw pointers that is star as opposed to

00:25:47,500 --> 00:25:51,490
the ampersand sort of track reference

00:25:49,240 --> 00:25:53,740
type all of that is unsafe but you can

00:25:51,490 --> 00:25:54,790
always just do that and so there's two

00:25:53,740 --> 00:25:56,590
ways you can do that you can either

00:25:54,790 --> 00:25:58,810
write a function that has an unsafe

00:25:56,590 --> 00:26:00,220
block or you can write an unsafe

00:25:58,810 --> 00:26:01,780
function in this case that first

00:26:00,220 --> 00:26:03,850
function there on the top left is

00:26:01,780 --> 00:26:05,890
probably a bad idea because it is just

00:26:03,850 --> 00:26:08,320
taking a random pointer and writing to

00:26:05,890 --> 00:26:09,280
it but if you need for say I need to do

00:26:08,320 --> 00:26:11,080
a little bit distraction I want to

00:26:09,280 --> 00:26:12,880
refactor this out to a function you can

00:26:11,080 --> 00:26:14,560
make your own unsafe function the

00:26:12,880 --> 00:26:18,280
contents of that or automatically

00:26:14,560 --> 00:26:19,330
allowed to use unsafe constructs and in

00:26:18,280 --> 00:26:21,160
this case you can write a function like

00:26:19,330 --> 00:26:23,620
this where you say I will allocate a

00:26:21,160 --> 00:26:25,360
vector vector exclamation is another

00:26:23,620 --> 00:26:27,430
macro that just allocates a vector on

00:26:25,360 --> 00:26:29,560
the heap for you I'm gonna get a

00:26:27,430 --> 00:26:31,810
reference to one item for the vector I'm

00:26:29,560 --> 00:26:37,750
going to zero it out print the contents

00:26:31,810 --> 00:26:38,500
that will just print zero and so you can

00:26:37,750 --> 00:26:41,650
call C

00:26:38,500 --> 00:26:43,540
from rust pretty straightforwardly you

00:26:41,650 --> 00:26:46,270
put the declaration for the C function

00:26:43,540 --> 00:26:48,880
in rust style or anything that's using

00:26:46,270 --> 00:26:51,400
the C API really put it in rust style

00:26:48,880 --> 00:26:52,690
syntax inside an extra in block and then

00:26:51,400 --> 00:26:55,630
that's immediately available for you to

00:26:52,690 --> 00:26:56,800
call as an unsafe function and then what

00:26:55,630 --> 00:26:59,320
you should probably do what we're doing

00:26:56,800 --> 00:27:01,810
in the next part of this is write a safe

00:26:59,320 --> 00:27:05,110
rust wrapper around here

00:27:01,810 --> 00:27:06,460
and so glossing over syntax I'm

00:27:05,110 --> 00:27:09,460
basically saying let me allocate a

00:27:06,460 --> 00:27:11,170
buffer here I'm gonna call this C

00:27:09,460 --> 00:27:12,700
function which rust doesn't know sort of

00:27:11,170 --> 00:27:15,130
what the semantics of those pointers are

00:27:12,700 --> 00:27:17,320
so rust always insists that C functions

00:27:15,130 --> 00:27:18,940
are unsafe so you put the unsafe block

00:27:17,320 --> 00:27:21,070
around it you say that's fine what I'm

00:27:18,940 --> 00:27:22,300
doing in this context is okay and then

00:27:21,070 --> 00:27:23,920
if I get an error I'm gonna return an

00:27:22,300 --> 00:27:25,390
error object if it works I'm gonna

00:27:23,920 --> 00:27:26,680
convert that to a string I'm gonna do a

00:27:25,390 --> 00:27:28,450
utf-8 parse on it

00:27:26,680 --> 00:27:30,640
if the utf-8 parse doesn't work I'm

00:27:28,450 --> 00:27:32,920
gonna throw a utf-8 error and then this

00:27:30,640 --> 00:27:36,480
ends up working and so I can just call

00:27:32,920 --> 00:27:38,320
this as RS read link from any rest code

00:27:36,480 --> 00:27:40,930
you can also do it the other way around

00:27:38,320 --> 00:27:44,140
on the left side is a function I can

00:27:40,930 --> 00:27:46,000
compile in rust and generate paid or ASO

00:27:44,140 --> 00:27:47,680
or whatever and on the right side is AC

00:27:46,000 --> 00:27:50,220
program I can link against this function

00:27:47,680 --> 00:27:53,530
and it'll just call it so very easy

00:27:50,220 --> 00:27:55,420
calling conventions are compatible they

00:27:53,530 --> 00:27:56,770
are not you cannot call an arbitrary

00:27:55,420 --> 00:27:59,230
rust function because rust has a richer

00:27:56,770 --> 00:28:01,590
type system but there's no sort of

00:27:59,230 --> 00:28:03,340
overhead there's nothing like Segoe or

00:28:01,590 --> 00:28:04,720
J&I or something where you're like I

00:28:03,340 --> 00:28:07,240
need to set up the ability to make this

00:28:04,720 --> 00:28:10,990
call rust just runs on the normal sea

00:28:07,240 --> 00:28:13,960
stacks like a normal C function and you

00:28:10,990 --> 00:28:15,760
can also access C types in the same way

00:28:13,960 --> 00:28:18,100
you put a structure you put this

00:28:15,760 --> 00:28:21,400
attribute representation C on top of it

00:28:18,100 --> 00:28:23,020
you put whatever it contains so in this

00:28:21,400 --> 00:28:24,940
case I'm picking on struct cig action

00:28:23,020 --> 00:28:27,430
because it's a little complicated it's

00:28:24,940 --> 00:28:29,020
got a function pointer this God's flag

00:28:27,430 --> 00:28:31,570
it's got a few other things and I also

00:28:29,020 --> 00:28:34,330
am importing this cig action function

00:28:31,570 --> 00:28:36,730
from the standard library and over in

00:28:34,330 --> 00:28:38,320
rust code I can call it note that I'm

00:28:36,730 --> 00:28:40,840
not doing any sort of marshalling on

00:28:38,320 --> 00:28:42,790
marshalling I'm creating a sick action

00:28:40,840 --> 00:28:44,350
struct just like I was creating any

00:28:42,790 --> 00:28:46,030
other rough struct because it is a rest

00:28:44,350 --> 00:28:48,100
rect it's just a restaurant with

00:28:46,030 --> 00:28:49,960
well-defined layout and then I can call

00:28:48,100 --> 00:28:54,490
this C function on it

00:28:49,960 --> 00:28:56,830
and so what you can do from here is say

00:28:54,490 --> 00:28:59,169
I'm starting with a large C C or C++

00:28:56,830 --> 00:29:01,029
code base and I'm going to convert it's

00:28:59,169 --> 00:29:03,100
over I'm gonna take something where I

00:29:01,029 --> 00:29:07,299
have an API boundary and I'm going to

00:29:03,100 --> 00:29:09,940
take this same API and implemented using

00:29:07,299 --> 00:29:11,320
rust underneath and so we aren't the

00:29:09,940 --> 00:29:14,769
first people to do this by any means

00:29:11,320 --> 00:29:16,389
Firefox very notably had a research

00:29:14,769 --> 00:29:18,309
project called servo where they were

00:29:16,389 --> 00:29:20,320
writing a browser entirely in rust

00:29:18,309 --> 00:29:22,600
they wrote a CSS component called stylo

00:29:20,320 --> 00:29:25,059
and now firefox quantum is shipping with

00:29:22,600 --> 00:29:26,950
stylo as its CSM's engine they are

00:29:25,059 --> 00:29:29,009
writing new components like weboth in

00:29:26,950 --> 00:29:32,230
for two factor authentication in rust

00:29:29,009 --> 00:29:33,789
lip our SVG is gnomes library for SVG

00:29:32,230 --> 00:29:35,440
rendering and that one has also gone

00:29:33,789 --> 00:29:38,440
thundering on I think at this point a

00:29:35,440 --> 00:29:40,749
basically complete rust conversion while

00:29:38,440 --> 00:29:42,850
still providing the same ABI api c

00:29:40,749 --> 00:29:45,269
header file etc to all of its existing

00:29:42,850 --> 00:29:47,950
consumers microsoft is considering

00:29:45,269 --> 00:29:50,409
switching parts of the OS kernel and

00:29:47,950 --> 00:29:52,480
other things to rust various other users

00:29:50,409 --> 00:29:56,830
brave and p.m. etcetera are all happily

00:29:52,480 --> 00:29:58,119
using rusty parts cool so now we're

00:29:56,830 --> 00:30:01,179
going to show you sort of what we built

00:29:58,119 --> 00:30:04,119
thus far in terms of interfacing with

00:30:01,179 --> 00:30:07,019
the Linux kernel from rust so this is

00:30:04,119 --> 00:30:09,879
sort of your hello world kernel module

00:30:07,019 --> 00:30:12,879
written in rust using the library we've

00:30:09,879 --> 00:30:15,369
built for abstracting around the Linux

00:30:12,879 --> 00:30:19,029
kernel and exposing it safely so we

00:30:15,369 --> 00:30:20,889
represent kernel modules as a trait that

00:30:19,029 --> 00:30:25,389
you provide the init method on which

00:30:20,889 --> 00:30:28,600
maps to the module in it macro that the

00:30:25,389 --> 00:30:31,240
kernel header is exposed so you can see

00:30:28,600 --> 00:30:34,529
we print hello world we return an

00:30:31,240 --> 00:30:37,330
instance of our hello world module and

00:30:34,529 --> 00:30:42,940
sort of print line the standard print

00:30:37,330 --> 00:30:45,369
API in rust just works compiling this we

00:30:42,940 --> 00:30:47,919
use something called cargo X build cross

00:30:45,369 --> 00:30:51,369
build to target the slightly different

00:30:47,919 --> 00:30:54,659
kernel ABI and then we have a deeply

00:30:51,369 --> 00:30:59,830
magical make file that will convert the

00:30:54,659 --> 00:31:02,259
shared object from X build into a o in

00:30:59,830 --> 00:31:03,700
terms of the scope of what we interface

00:31:02,259 --> 00:31:05,920
with thus far

00:31:03,700 --> 00:31:08,260
we we will interface with sort of print

00:31:05,920 --> 00:31:12,670
K arrow types the whole allocation

00:31:08,260 --> 00:31:15,460
system sis cuddles very basic file

00:31:12,670 --> 00:31:19,690
system support character devices user

00:31:15,460 --> 00:31:21,910
pointers and file operations so what is

00:31:19,690 --> 00:31:24,850
involved in actually mapping kernel

00:31:21,910 --> 00:31:27,520
api's to say for us so let's start with

00:31:24,850 --> 00:31:29,470
rust kind of as three important data

00:31:27,520 --> 00:31:31,870
structures to get start with there's box

00:31:29,470 --> 00:31:34,000
which you know c++ is roughly a scanner

00:31:31,870 --> 00:31:36,490
unique pointer so that's a pointer to a

00:31:34,000 --> 00:31:38,920
value on the heap that uniquely owns its

00:31:36,490 --> 00:31:41,260
memory when the box goes out of scope

00:31:38,920 --> 00:31:44,590
the memory is D allocated Beck is a

00:31:41,260 --> 00:31:47,440
heat-based growable linear array a

00:31:44,590 --> 00:31:52,150
string is a heat based linear sequence

00:31:47,440 --> 00:31:55,120
of utf-8 encoded code points and rust

00:31:52,150 --> 00:31:57,250
has a global allocator trait that you

00:31:55,120 --> 00:31:59,470
can provide in your program to use

00:31:57,250 --> 00:32:02,230
something with sides live C malloc and

00:31:59,470 --> 00:32:04,690
free we provide this built on top of K

00:32:02,230 --> 00:32:07,630
malloc or in this case K realloc since K

00:32:04,690 --> 00:32:10,930
malloc is an inline function and K free

00:32:07,630 --> 00:32:13,720
and now heap allocation is just work so

00:32:10,930 --> 00:32:16,720
the string syntax dot to owned will

00:32:13,720 --> 00:32:19,480
allocate a string that lives on the heap

00:32:16,720 --> 00:32:21,520
and this just works so programs that are

00:32:19,480 --> 00:32:23,440
using rusts heap api's will just

00:32:21,520 --> 00:32:25,450
automatically use the kernel heap in

00:32:23,440 --> 00:32:27,250
future versions of rust there will

00:32:25,450 --> 00:32:29,560
actually support for managing multiple

00:32:27,250 --> 00:32:30,970
allocators which would let you do things

00:32:29,560 --> 00:32:34,270
like have allocators that use different

00:32:30,970 --> 00:32:36,070
flags instead of always using gfp kernel

00:32:34,270 --> 00:32:38,740
but for now everything is just gfp

00:32:36,070 --> 00:32:41,200
kernel okay but what about under under

00:32:38,740 --> 00:32:42,580
user pointers this is you know serious

00:32:41,200 --> 00:32:43,840
challenge kernels have like kernel

00:32:42,580 --> 00:32:46,450
pointers aren't just like regular user

00:32:43,840 --> 00:32:48,940
space pointers and our desired goals or

00:32:46,450 --> 00:32:50,860
roughly type safety should never be able

00:32:48,940 --> 00:32:52,990
to mix up a kernel in a user space

00:32:50,860 --> 00:32:55,420
pointer you want to be bounds checked

00:32:52,990 --> 00:32:57,430
really in both directions but you know

00:32:55,420 --> 00:32:59,770
particularly when copying from user

00:32:57,430 --> 00:33:02,530
space to kernel space and you want to

00:32:59,770 --> 00:33:05,590
avoid double fetches leading to time

00:33:02,530 --> 00:33:07,150
check time abuse vulnerabilities so we

00:33:05,590 --> 00:33:10,150
have an abstraction called user slice

00:33:07,150 --> 00:33:12,460
pointer which you can you can pass

00:33:10,150 --> 00:33:15,760
around and it has methods for reading

00:33:12,460 --> 00:33:16,530
and writing to it one thing you will

00:33:15,760 --> 00:33:21,330
notice that we have

00:33:16,530 --> 00:33:23,940
demo'd so far is all these methods take

00:33:21,330 --> 00:33:25,560
self without an ampersand so they are

00:33:23,940 --> 00:33:28,230
not taking self by reference they take

00:33:25,560 --> 00:33:31,260
self by value which also means self is

00:33:28,230 --> 00:33:34,380
consumed so this means after you call

00:33:31,260 --> 00:33:37,170
read all Russ will not allow you to call

00:33:34,380 --> 00:33:40,560
read all a second time this helps

00:33:37,170 --> 00:33:42,240
prevent the double touch problem and so

00:33:40,560 --> 00:33:45,210
an example of using this is you might

00:33:42,240 --> 00:33:46,830
have a read callback that takes mutable

00:33:45,210 --> 00:33:49,710
reference to a user splice pointer

00:33:46,830 --> 00:33:51,180
writer and you just call right on it as

00:33:49,710 --> 00:33:53,460
a length method telling you how long you

00:33:51,180 --> 00:33:55,950
think it is and you'll see right has the

00:33:53,460 --> 00:33:58,380
question mark operator after it which

00:33:55,950 --> 00:34:00,870
tells it you know to handle errors

00:33:58,380 --> 00:34:02,310
because right can return an e fault and

00:34:00,870 --> 00:34:06,360
that will just propagate the error

00:34:02,310 --> 00:34:08,669
upwards in this case we call right on

00:34:06,360 --> 00:34:11,070
every method which is like a fresh call

00:34:08,669 --> 00:34:13,230
to copy to user it's like you're gonna

00:34:11,070 --> 00:34:14,970
be dropping and reacquiring SMAP after

00:34:13,230 --> 00:34:16,919
everything if you wanted to pass write a

00:34:14,970 --> 00:34:18,300
longer buffer instead of passing it one

00:34:16,919 --> 00:34:18,810
character at a time you could also do

00:34:18,300 --> 00:34:21,570
that

00:34:18,810 --> 00:34:24,690
see you get sort of control over how you

00:34:21,570 --> 00:34:28,320
are calling things like copy to user by

00:34:24,690 --> 00:34:30,120
how you use the user slice pointer API

00:34:28,320 --> 00:34:32,460
okay but what about concurrency

00:34:30,120 --> 00:34:35,820
concurrency is kind of where the the fun

00:34:32,460 --> 00:34:38,790
stuff happens so Russ models concurrency

00:34:35,820 --> 00:34:41,129
with two traits sync and send that

00:34:38,790 --> 00:34:44,129
different types in rust implement so

00:34:41,129 --> 00:34:46,740
sync if a type of one sync that means

00:34:44,129 --> 00:34:50,090
multiple threads may have references to

00:34:46,740 --> 00:34:53,879
a value of that type at the same time

00:34:50,090 --> 00:34:55,230
and so something like a mutex implements

00:34:53,879 --> 00:34:57,090
sync because you can have multiple

00:34:55,230 --> 00:34:59,430
threads with access but the mutex will

00:34:57,090 --> 00:35:02,760
only actually give its inner value to

00:34:59,430 --> 00:35:04,440
one thread at any given time send is the

00:35:02,760 --> 00:35:06,990
other type and this means that type may

00:35:04,440 --> 00:35:09,570
transfer ownership to a different thread

00:35:06,990 --> 00:35:13,110
so most types are send because they're

00:35:09,570 --> 00:35:15,770
safe to give to somebody else an example

00:35:13,110 --> 00:35:18,120
of a type that's not is something like a

00:35:15,770 --> 00:35:20,730
reference countered pointer that is not

00:35:18,120 --> 00:35:23,280
using atomic operations for the

00:35:20,730 --> 00:35:24,720
reference count because if you passed it

00:35:23,280 --> 00:35:28,710
to another thread then you could have

00:35:24,720 --> 00:35:30,150
races about the reference count so lots

00:35:28,710 --> 00:35:32,430
of kernel types need to be

00:35:30,150 --> 00:35:33,779
safe port concurrent access let's talk

00:35:32,430 --> 00:35:35,730
about file operations

00:35:33,779 --> 00:35:39,270
so we've modeled the file operations

00:35:35,730 --> 00:35:40,680
sort of virtual table as trait the

00:35:39,270 --> 00:35:43,950
different things in Russ can influence

00:35:40,680 --> 00:35:46,260
and the sort of colon syntax after pub

00:35:43,950 --> 00:35:48,390
trait file operations says to implement

00:35:46,260 --> 00:35:50,670
file operations you also must be sync in

00:35:48,390 --> 00:35:52,559
size size is not probably interesting

00:35:50,670 --> 00:35:54,119
but a file operations must be sync

00:35:52,559 --> 00:35:55,520
because you can have multiple threads

00:35:54,119 --> 00:35:59,490
trying to use a file descriptor

00:35:55,520 --> 00:36:03,150
concurrently and as a result the read

00:35:59,490 --> 00:36:05,579
callback takes an and self and not an

00:36:03,150 --> 00:36:07,109
enemy itself because you has shared

00:36:05,579 --> 00:36:09,869
semantics you can have multiple people

00:36:07,109 --> 00:36:12,029
calling read concurrently and that means

00:36:09,869 --> 00:36:14,640
if your implementation of file

00:36:12,029 --> 00:36:17,660
operations read needs to say mutate

00:36:14,640 --> 00:36:20,760
something to get the state in order to

00:36:17,660 --> 00:36:22,559
work safely with the shared reference

00:36:20,760 --> 00:36:24,510
you're receiving you will need to bring

00:36:22,559 --> 00:36:28,200
your own locking over whatever state it

00:36:24,510 --> 00:36:30,359
is that you're mutating and read so by

00:36:28,200 --> 00:36:32,910
designing our api's like this we

00:36:30,359 --> 00:36:38,760
basically force people to correctly

00:36:32,910 --> 00:36:41,579
handle handle concurrency okay

00:36:38,760 --> 00:36:44,609
so we're using bind gen which is a very

00:36:41,579 --> 00:36:47,910
nifty rusty project that art exists to

00:36:44,609 --> 00:36:50,700
parse see headers so we sort of say a

00:36:47,910 --> 00:36:52,829
point find in at the kernel headers and

00:36:50,700 --> 00:36:54,660
have it generate rust source code

00:36:52,829 --> 00:36:56,460
including both a bunch of extra things

00:36:54,660 --> 00:36:58,980
and a bunch of representation see

00:36:56,460 --> 00:37:00,660
structures mapping to kernel things and

00:36:58,980 --> 00:37:02,760
bind gen works internally using lip

00:37:00,660 --> 00:37:05,819
clang and so that means it's not it's

00:37:02,760 --> 00:37:07,410
own CMC implementation uses lip clink to

00:37:05,819 --> 00:37:09,690
read the header files and sort of get

00:37:07,410 --> 00:37:10,920
the sense of what they mean and so we're

00:37:09,690 --> 00:37:13,289
making a whole bunch of assumptions here

00:37:10,920 --> 00:37:14,250
and so this is sort of if we were

00:37:13,289 --> 00:37:16,200
thinking about putting this into

00:37:14,250 --> 00:37:17,549
production or potentially what would it

00:37:16,200 --> 00:37:20,039
look like to have this at Maine law in

00:37:17,549 --> 00:37:21,869
today's hypothetical future this is one

00:37:20,039 --> 00:37:24,270
of the interesting challenges we are

00:37:21,869 --> 00:37:26,700
assuming that clang and GCC produce

00:37:24,270 --> 00:37:29,130
binary compatible code when run for the

00:37:26,700 --> 00:37:31,799
same kernel this has been mostly working

00:37:29,130 --> 00:37:33,539
for us in practice one of the things

00:37:31,799 --> 00:37:36,569
we've noticed it actually fall apart on

00:37:33,539 --> 00:37:38,940
is GCC plugins like you have RAM struct

00:37:36,569 --> 00:37:41,279
running at the kernel bail time there is

00:37:38,940 --> 00:37:42,299
no Ram stark to clinton plugin and puts

00:37:41,279 --> 00:37:43,200
the fields in the wrong order for

00:37:42,299 --> 00:37:46,109
instance

00:37:43,200 --> 00:37:48,089
and so we would like better guarantees

00:37:46,109 --> 00:37:49,769
here and sort of a better way to sort of

00:37:48,089 --> 00:37:51,180
access this I don't know what the

00:37:49,769 --> 00:37:52,589
solutions are I'm open to it's just we

00:37:51,180 --> 00:37:54,569
don't know we're open to suggestions uh

00:37:52,589 --> 00:37:56,549
maybe we should be parsing dwarf and

00:37:54,569 --> 00:37:58,440
saying okay there's a dwarf sort of

00:37:56,549 --> 00:38:01,710
debugging metadata for the compiled

00:37:58,440 --> 00:38:03,450
kernel map the match the dwarf data that

00:38:01,710 --> 00:38:05,279
we would be generating or something

00:38:03,450 --> 00:38:08,430
this seems relevant to these sort of

00:38:05,279 --> 00:38:10,230
proc K headers tar.gz discussion has

00:38:08,430 --> 00:38:11,789
been happening recently in terms of how

00:38:10,230 --> 00:38:13,950
do you communicate what the kernels ABI

00:38:11,789 --> 00:38:16,470
is to new modules that you are building

00:38:13,950 --> 00:38:17,009
for that exact kernel is C the best way

00:38:16,470 --> 00:38:19,470
to do it

00:38:17,009 --> 00:38:20,849
it seems like it's probably the best /

00:38:19,470 --> 00:38:23,339
only tractable way now but we'd like

00:38:20,849 --> 00:38:24,930
some better guarantees we're also doing

00:38:23,339 --> 00:38:26,519
a bunch of weird things in the build

00:38:24,930 --> 00:38:29,519
script it's on github I'm not gonna go

00:38:26,519 --> 00:38:32,190
into details about running a kernel

00:38:29,519 --> 00:38:33,720
build with CC equals claim for a kernel

00:38:32,190 --> 00:38:38,630
that in most cases has been built with

00:38:33,720 --> 00:38:41,609
GCC and that works that's not totally

00:38:38,630 --> 00:38:43,259
guaranteed to work unfortunately and

00:38:41,609 --> 00:38:46,980
we've seen some issues with that on 500

00:38:43,259 --> 00:38:48,690
end up and we're also grabbing the C

00:38:46,980 --> 00:38:50,339
flags which we need to pass them Tulip

00:38:48,690 --> 00:38:52,170
clang so it interprets things correctly

00:38:50,339 --> 00:38:54,089
it knows what to define we're grabbing

00:38:52,170 --> 00:38:55,920
those by basically running a dummy

00:38:54,089 --> 00:38:57,630
kernel module build echoing a bunch of

00:38:55,920 --> 00:39:01,500
variables that K build happens to set

00:38:57,630 --> 00:39:04,470
for us which doesn't seem great but is

00:39:01,500 --> 00:39:05,990
also remarkably stable in that I guess

00:39:04,470 --> 00:39:10,019
we started working on this with like a

00:39:05,990 --> 00:39:11,970
4/4 ish kernel maybe and it does still

00:39:10,019 --> 00:39:15,420
build up to 5 - I tested 5 - what this

00:39:11,970 --> 00:39:18,269
weekend so happens to work would like

00:39:15,420 --> 00:39:20,279
better guarantees one question that is

00:39:18,269 --> 00:39:22,289
extremely valid to ask about how can I

00:39:20,279 --> 00:39:24,180
use this for real work if you were an

00:39:22,289 --> 00:39:26,190
auditory module developer or we're

00:39:24,180 --> 00:39:28,859
talking about how would we sort of start

00:39:26,190 --> 00:39:30,900
to pare back the amount of C and Linux

00:39:28,859 --> 00:39:33,990
main line how we get this into mainline

00:39:30,900 --> 00:39:36,690
is what architectures is it support and

00:39:33,990 --> 00:39:39,450
so the architectures on the left are the

00:39:36,690 --> 00:39:40,769
architectures that rust upstream does

00:39:39,450 --> 00:39:45,779
support so these are expected to work

00:39:40,769 --> 00:39:47,339
arm v5 plus arm 64 horse MIPS - plus

00:39:45,779 --> 00:39:51,539
MIPS 1 does not work

00:39:47,339 --> 00:39:55,470
PowerPC PowerPC 64 or risk 5s 390 64-bit

00:39:51,539 --> 00:39:56,099
SPARC user mode Linux probably works x86

00:39:55,470 --> 00:39:57,509
00:39:56,099 --> 00:40:00,989
the only thing we're actually running in

00:39:57,509 --> 00:40:02,459
CI right now is x86 64 so we should get

00:40:00,989 --> 00:40:05,309
that working but one notable thing about

00:40:02,459 --> 00:40:08,130
this list while it is a huge subset or a

00:40:05,309 --> 00:40:10,680
bunch of hexagons you know other random

00:40:08,130 --> 00:40:12,239
architectures in the arch directory this

00:40:10,680 --> 00:40:14,579
covers all of the district hurdles so

00:40:12,239 --> 00:40:17,009
rel fedora Debian Ubuntu Susa Android

00:40:14,579 --> 00:40:19,650
Oracle art etc are all supporting a

00:40:17,009 --> 00:40:22,019
subset of these most of the work here is

00:40:19,650 --> 00:40:23,160
actually in LLVM we don't need much rust

00:40:22,019 --> 00:40:25,949
supporters and we don't have a standard

00:40:23,160 --> 00:40:27,779
library there are some other approaches

00:40:25,949 --> 00:40:29,729
that you could take there's a rust

00:40:27,779 --> 00:40:31,589
compiler called chem rusty that commits

00:40:29,729 --> 00:40:33,569
C as output sort of an experimental

00:40:31,589 --> 00:40:36,180
thing that doesn't do any checking and

00:40:33,569 --> 00:40:38,369
then there's an L BMC back-end which the

00:40:36,180 --> 00:40:39,660
Julia folks have recently revived I have

00:40:38,369 --> 00:40:42,599
no idea of it works but it might be

00:40:39,660 --> 00:40:44,099
promising and so I'm already a few tree

00:40:42,599 --> 00:40:46,099
directions I'm going to attempt to do a

00:40:44,099 --> 00:40:51,589
live demo wish me luck

00:40:46,099 --> 00:40:51,589
so over here

00:41:07,520 --> 00:41:12,980
see if that's big enough let me know if

00:41:09,140 --> 00:41:14,000
I need to be bigger I have got do you

00:41:12,980 --> 00:41:15,980
want to talk to through this while I

00:41:14,000 --> 00:41:18,950
yeah I will talk to this so we've got a

00:41:15,980 --> 00:41:24,160
relatively simple kernel module here

00:41:18,950 --> 00:41:27,110
that exposes some sis cuddles and when

00:41:24,160 --> 00:41:29,090
it also exposes a character device and

00:41:27,110 --> 00:41:31,640
the characters rights when you read it

00:41:29,090 --> 00:41:34,820
gives you a JSON representation of your

00:41:31,640 --> 00:41:36,350
sis cuddles so this is entirely safe

00:41:34,820 --> 00:41:38,810
rust within the kernel module we have

00:41:36,350 --> 00:41:40,850
written and the JSON module is like a

00:41:38,810 --> 00:41:43,700
pre-existing one like we did not have to

00:41:40,850 --> 00:41:45,650
write our own JSON module so we're we're

00:41:43,700 --> 00:41:48,230
reporting sir to JSON core which is a

00:41:45,650 --> 00:41:50,900
standard thing for handling JSON and

00:41:48,230 --> 00:41:53,630
rust we make three atomic pools we make

00:41:50,900 --> 00:41:55,010
this empty character of ice-truck JSON

00:41:53,630 --> 00:41:56,720
care Dave went because we don't need any

00:41:55,010 --> 00:42:00,170
data we just need to implement some

00:41:56,720 --> 00:42:01,580
traits on it and we basically say you

00:42:00,170 --> 00:42:04,970
should read this as the C equivalent of

00:42:01,580 --> 00:42:08,000
you know static JSON Kara dev ops equals

00:42:04,970 --> 00:42:10,040
file operations etc and so we say when

00:42:08,000 --> 00:42:12,800
we're reading we load these three atomic

00:42:10,040 --> 00:42:15,470
variables and we put them into this

00:42:12,800 --> 00:42:17,650
output structure we asked Sarah T JSON

00:42:15,470 --> 00:42:20,000
Court is serialized this write it out

00:42:17,650 --> 00:42:22,690
and then we have our kernel module

00:42:20,000 --> 00:42:24,800
itself which contains three cisco tools

00:42:22,690 --> 00:42:26,780
ampersand static means it is borrowed

00:42:24,800 --> 00:42:28,760
for the entire lifetime of this program

00:42:26,780 --> 00:42:31,070
or in this case the entire lifetime its

00:42:28,760 --> 00:42:33,380
module and we have a registration for a

00:42:31,070 --> 00:42:34,910
character device that was the output

00:42:33,380 --> 00:42:36,890
variable I used I put the structure in

00:42:34,910 --> 00:42:38,930
the wrong order but that's fine and then

00:42:36,890 --> 00:42:41,210
here's the implementation for JSON sis

00:42:38,930 --> 00:42:43,220
kernel module which is we register this

00:42:41,210 --> 00:42:45,230
character device if it works great if

00:42:43,220 --> 00:42:46,670
not there's a question mark and then we

00:42:45,230 --> 00:42:47,840
register three Cisco tools again if it

00:42:46,670 --> 00:42:50,420
works great if not there's a question

00:42:47,840 --> 00:42:52,040
mark you will get an actual kernel you

00:42:50,420 --> 00:42:54,590
know Ian Val or something out of this at

00:42:52,040 --> 00:42:55,820
modprobe time if any of those fail and

00:42:54,590 --> 00:42:57,170
we don't need to do anything to

00:42:55,820 --> 00:42:59,150
unregister it because we have

00:42:57,170 --> 00:43:00,830
destructors that when these objects go

00:42:59,150 --> 00:43:05,030
out of scope will automatically clean

00:43:00,830 --> 00:43:07,300
things up all right live demo time pray

00:43:05,030 --> 00:43:07,300
for us

00:43:15,630 --> 00:43:20,440
okay great

00:43:18,369 --> 00:43:30,490
ignore that bit about anytime go to it's

00:43:20,440 --> 00:43:32,050
fine so this is a normal cable to make

00:43:30,490 --> 00:43:38,470
file except for the part where it picks

00:43:32,050 --> 00:43:42,369
up this day that we just generated and

00:43:38,470 --> 00:43:44,980
we insert it into the kernel you'll see

00:43:42,369 --> 00:43:49,540
our JSON device now shows up in proc

00:43:44,980 --> 00:43:52,990
devices we can make not it get JSON out

00:43:49,540 --> 00:43:58,470
and weak at it we can write to practice

00:43:52,990 --> 00:44:05,410
to change this to scuttle value and

00:43:58,470 --> 00:44:07,780
you'll see the JSON updates this

00:44:05,410 --> 00:44:10,359
hypervisor by the way is qmu with mac

00:44:07,780 --> 00:44:11,560
hypervisor dot framework so things are

00:44:10,359 --> 00:44:13,180
slightly exciting with this if you

00:44:11,560 --> 00:44:14,320
worked on qm you piper eyes right

00:44:13,180 --> 00:44:19,619
framework that is very exciting thank

00:44:14,320 --> 00:44:19,619
you for it yeah so that's our demo and

00:44:19,800 --> 00:44:26,820
source for that is on github and what do

00:44:24,760 --> 00:44:30,730
we want to say about future directions

00:44:26,820 --> 00:44:32,680
yeah so what is sort of next for this

00:44:30,730 --> 00:44:35,260
first of all we think the future is

00:44:32,680 --> 00:44:37,990
bright for writing kernel modules in not

00:44:35,260 --> 00:44:40,390
see particularly in rust sort of our

00:44:37,990 --> 00:44:42,640
design goals are to cover more kernel

00:44:40,390 --> 00:44:45,160
api's we are sort of relatively limited

00:44:42,640 --> 00:44:47,349
in what we support at the moment we'd

00:44:45,160 --> 00:44:49,990
like to find better ways to support

00:44:47,349 --> 00:44:53,320
particularly out of tree module authors

00:44:49,990 --> 00:44:56,140
give a moment for booze and we want

00:44:53,320 --> 00:44:57,400
better k build integration so more

00:44:56,140 --> 00:44:59,320
kernel api is right now like

00:44:57,400 --> 00:45:01,420
functionally we have sis cuddles and we

00:44:59,320 --> 00:45:03,460
have character devices we think

00:45:01,420 --> 00:45:05,710
particularly exciting targets for having

00:45:03,460 --> 00:45:08,859
memory safety are things like file

00:45:05,710 --> 00:45:12,339
systems and drivers for various device

00:45:08,859 --> 00:45:15,580
classes so we would like to expand to

00:45:12,339 --> 00:45:17,530
cover those real world out of tree

00:45:15,580 --> 00:45:19,420
modules so like if there are any authors

00:45:17,530 --> 00:45:21,070
who maintain out of tree modules or

00:45:19,420 --> 00:45:22,540
daintree modules for that matter like or

00:45:21,070 --> 00:45:24,880
would like to maintain a degree modules

00:45:22,540 --> 00:45:27,190
but don't want to write c yes what would

00:45:24,880 --> 00:45:28,920
it take for you to actually use this for

00:45:27,190 --> 00:45:30,630
real we would love to

00:45:28,920 --> 00:45:33,180
whether its functionality or production

00:45:30,630 --> 00:45:36,390
ization find ways to support real-world

00:45:33,180 --> 00:45:38,460
use of this we want better cabled

00:45:36,390 --> 00:45:40,230
integration so right now you have a like

00:45:38,460 --> 00:45:41,910
two step process for the build there's

00:45:40,230 --> 00:45:44,490
actually no reason the makefile couldn't

00:45:41,910 --> 00:45:46,890
drive cargo X build and just have that

00:45:44,490 --> 00:45:48,600
all sort of it look exactly like

00:45:46,890 --> 00:45:50,190
building a normal kernel module

00:45:48,600 --> 00:45:54,630
besides needing to have rust installed

00:45:50,190 --> 00:45:57,330
and finally in what would it take to

00:45:54,630 --> 00:46:01,920
have a true rust support for writing

00:45:57,330 --> 00:46:03,870
rust modules in mainline kernel c no

00:46:01,920 --> 00:46:06,050
longer brings us joy we'd like to thank

00:46:03,870 --> 00:46:08,730
it we'd like to put it aside

00:46:06,050 --> 00:46:11,840
thanks I think we have a minute or two

00:46:08,730 --> 00:46:14,070
for questions our code is on github and

00:46:11,840 --> 00:46:16,560
feel free to check it out send us pull

00:46:14,070 --> 00:46:18,630
requests etc try it on your own kernels

00:46:16,560 --> 00:46:20,730
try it on your own architectures and

00:46:18,630 --> 00:46:22,470
fish in a barrel the extremely real

00:46:20,730 --> 00:46:24,690
vulnerability research firm is on

00:46:22,470 --> 00:46:26,730
twitter at a lazy fish barrel you can

00:46:24,690 --> 00:46:27,630
follow us for more statistics like you

00:46:26,730 --> 00:46:29,790
saw in the first part of the

00:46:27,630 --> 00:46:31,290
presentation oh and we will be host

00:46:29,790 --> 00:46:32,760
we'll be having a ball if anyone wants

00:46:31,290 --> 00:46:33,810
to get started with sort of getting

00:46:32,760 --> 00:46:36,440
their environments that Evan wants to

00:46:33,810 --> 00:46:36,440
play around with things

00:46:45,520 --> 00:46:50,710
performance and code size so one thing i

00:46:48,600 --> 00:46:52,660
one thing i should have credited is that

00:46:50,710 --> 00:46:53,500
there we are based in part on some other

00:46:52,660 --> 00:46:54,670
people's work

00:46:53,500 --> 00:46:56,530
there's we're not the only people

00:46:54,670 --> 00:46:58,750
interest in this we think we've gotten a

00:46:56,530 --> 00:47:00,610
lot farther in terms of sort of safe

00:46:58,750 --> 00:47:02,740
abstractions but there's one team that

00:47:00,610 --> 00:47:04,660
started with our repo and made a real

00:47:02,740 --> 00:47:06,280
driver for the raspberry PI's either a

00:47:04,660 --> 00:47:09,490
controller and they published a paper

00:47:06,280 --> 00:47:11,860
about it and so they did benchmarking on

00:47:09,490 --> 00:47:14,500
both performance and code size code size

00:47:11,860 --> 00:47:17,950
is larger performance is quite

00:47:14,500 --> 00:47:20,140
comparable in that there is no hidden

00:47:17,950 --> 00:47:22,270
overhead in any rest operations like

00:47:20,140 --> 00:47:23,350
just like when you write see nothing is

00:47:22,270 --> 00:47:25,060
sort of being allocated on the heap

00:47:23,350 --> 00:47:26,470
unless you call malloc when you're right

00:47:25,060 --> 00:47:28,090
rust and nothing is being allocated on

00:47:26,470 --> 00:47:31,270
the heap unless you call some function

00:47:28,090 --> 00:47:34,600
that like you know uses allocations in

00:47:31,270 --> 00:47:39,280
terms of code size I can so this is with

00:47:34,600 --> 00:47:41,470
a release build it is about one megabyte

00:47:39,280 --> 00:47:43,600
and that is including a bunch of things

00:47:41,470 --> 00:47:44,830
we had not stripped out of sort of the

00:47:43,600 --> 00:47:47,460
rust core libraries and that's including

00:47:44,830 --> 00:47:50,260
this whole JSON parser so it is not

00:47:47,460 --> 00:47:53,790
untenable basically it seems quite

00:47:50,260 --> 00:47:53,790
reasonable for at least desktop systems

00:47:57,210 --> 00:48:01,660
so there's a buff is that today we'll do

00:48:00,280 --> 00:48:03,430
that day yeah okay so yeah there's a

00:48:01,660 --> 00:48:05,970
buff from 5:00 p.m.

00:48:03,430 --> 00:48:12,530
thanks for the great talk thank you

00:48:05,970 --> 00:48:12,530

YouTube URL: https://www.youtube.com/watch?v=RyY01fRyGhM


