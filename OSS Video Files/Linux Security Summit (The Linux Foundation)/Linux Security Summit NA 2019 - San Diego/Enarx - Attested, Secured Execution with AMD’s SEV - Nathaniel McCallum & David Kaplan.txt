Title: Enarx - Attested, Secured Execution with AMD’s SEV - Nathaniel McCallum & David Kaplan
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Enarx - Attested, Secured Execution with AMD’s SEV - Nathaniel McCallum, Red Hat, Inc. & David Kaplan, Advanced Micro Devices, Inc. 

AMD SEV (Secure Encrypted Virtualization) is a new CPU security technology available in AMD's EPYC processors and provides new levels of protection for virtualized workloads. AMD SEV can encrypt the memory and register state of VMs individually, isolating them from the hypervisor.  Enarx is an open source project led by Red Hat, leveraging TEEs, and providing attestation and protection for run-time workloads. It is written in Rust and aims to reduce the number of trust relationships required when running executables in the private or public cloud. It currently supports AMD SEV, and this session will: 
● Discuss SEV capabilities and roadmap; 
● Introduce the Enarx architecture; 
● Present some of the components of Enarx; 
● Show a demonstration of an early set of Enarx capabilities.
Captions: 
	00:00:00,060 --> 00:00:03,840
all right well thank you very much and

00:00:01,560 --> 00:00:06,600
good morning so as mentioned we're gonna

00:00:03,840 --> 00:00:09,480
be talking about the nrx project which

00:00:06,600 --> 00:00:11,370
is built on top of AMD's secure

00:00:09,480 --> 00:00:13,679
encrypted virtualization or SCV

00:00:11,370 --> 00:00:15,420
technology so i'm gonna kick things off

00:00:13,679 --> 00:00:19,020
I'm going to give a bit of background on

00:00:15,420 --> 00:00:21,840
what sed is and some of its capabilities

00:00:19,020 --> 00:00:23,310
around lifecycle flows including

00:00:21,840 --> 00:00:24,720
attestation and then I'm going to hand

00:00:23,310 --> 00:00:26,519
things over to Nathaniel and he's going

00:00:24,720 --> 00:00:28,050
to talk more about an arc specifically

00:00:26,519 --> 00:00:33,149
and how they're utilizing those

00:00:28,050 --> 00:00:36,540
capabilities so one of the things that

00:00:33,149 --> 00:00:37,950
we've been doing at AMD which may have

00:00:36,540 --> 00:00:40,530
heard me talk about it previous

00:00:37,950 --> 00:00:44,250
conferences is that we've began building

00:00:40,530 --> 00:00:46,020
a hardware a aes-128 engine into our

00:00:44,250 --> 00:00:48,450
memory controllers and this is present

00:00:46,020 --> 00:00:50,910
on all of our Xen based processors for

00:00:48,450 --> 00:00:53,420
the last couple years and this

00:00:50,910 --> 00:00:55,379
encryption engine is capable of

00:00:53,420 --> 00:00:58,230
transparently encrypting and decrypting

00:00:55,379 --> 00:01:01,230
DRAM traffic as it leaves the boundary

00:00:58,230 --> 00:01:03,570
of the SOC and we have two different

00:01:01,230 --> 00:01:06,119
features that utilize this encryption

00:01:03,570 --> 00:01:08,610
engine we have we call our secure memory

00:01:06,119 --> 00:01:10,799
encryption or SME feature this has a

00:01:08,610 --> 00:01:12,990
single key that's generated randomly at

00:01:10,799 --> 00:01:15,799
boot time and this can be used to

00:01:12,990 --> 00:01:17,880
encrypt some or all the physical memory

00:01:15,799 --> 00:01:20,220
primarily to protect against things like

00:01:17,880 --> 00:01:22,860
cold boot attacks this is a feature that

00:01:20,220 --> 00:01:24,840
can be enabled in BIOS or there's a

00:01:22,860 --> 00:01:28,590
Linux kernel command line parameter as

00:01:24,840 --> 00:01:30,329
well the second feature which is the one

00:01:28,590 --> 00:01:33,090
we're going to be focusing on today is

00:01:30,329 --> 00:01:35,220
secure encrypted virtualization or SCV

00:01:33,090 --> 00:01:39,329
this is a feature that uses multiple

00:01:35,220 --> 00:01:41,520
encryption keys and assigns one key for

00:01:39,329 --> 00:01:44,070
each virtual machine in order to

00:01:41,520 --> 00:01:46,110
cryptographically isolate their memory

00:01:44,070 --> 00:01:47,149
both from each other as well as from the

00:01:46,110 --> 00:01:49,950
hypervisor

00:01:47,149 --> 00:01:53,250
in the case of both of these features

00:01:49,950 --> 00:01:55,470
the software on the cpus is not aware of

00:01:53,250 --> 00:01:57,869
the actual encryption keys the keys are

00:01:55,470 --> 00:01:59,490
generated randomly and they're held in

00:01:57,869 --> 00:02:01,710
special harbour registers and they're

00:01:59,490 --> 00:02:04,259
maintained by what we call the AMD

00:02:01,710 --> 00:02:06,270
secure processor or you sometimes hear

00:02:04,259 --> 00:02:10,229
referred to as the PSP the platform

00:02:06,270 --> 00:02:13,230
security processor the AMD secure

00:02:10,229 --> 00:02:13,840
processor is a dedicated Hardware

00:02:13,230 --> 00:02:17,410
subsets

00:02:13,840 --> 00:02:20,410
that exists in the SSC it is anchored by

00:02:17,410 --> 00:02:22,750
an arm a five core it has some dedicated

00:02:20,410 --> 00:02:25,810
Hardware resources like a private SRAM

00:02:22,750 --> 00:02:28,690
some crypto capabilities and it is

00:02:25,810 --> 00:02:32,739
responsible for managing encryption keys

00:02:28,690 --> 00:02:37,150
and performing various lifecycle tasks

00:02:32,739 --> 00:02:40,780
related to virtual machines so in a

00:02:37,150 --> 00:02:43,180
typical configuration we we have those

00:02:40,780 --> 00:02:46,000
AMD secure processor forming the root of

00:02:43,180 --> 00:02:48,700
trust and it exposes an API which is

00:02:46,000 --> 00:02:52,060
publicly documented and that contains

00:02:48,700 --> 00:02:55,450
functions related to VM startup via

00:02:52,060 --> 00:02:57,489
migration at a station and so on those

00:02:55,450 --> 00:03:00,450
functions are called by the hypervisor

00:02:57,489 --> 00:03:02,680
the hypervisor is responsible for

00:03:00,450 --> 00:03:04,480
performing this interaction for

00:03:02,680 --> 00:03:08,380
allocating system resources such as

00:03:04,480 --> 00:03:10,600
memory and and physical CPUs and of

00:03:08,380 --> 00:03:16,330
course scheduling the virtual machines

00:03:10,600 --> 00:03:19,360
to run the guest operating system inside

00:03:16,330 --> 00:03:21,190
of the virtual machine is a trusted part

00:03:19,360 --> 00:03:24,700
of this architecture and it is

00:03:21,190 --> 00:03:27,310
responsible for dividing its memory

00:03:24,700 --> 00:03:29,890
between its private memory which is

00:03:27,310 --> 00:03:31,810
encrypted with its own key and its

00:03:29,890 --> 00:03:34,840
shared memory which is visible to the

00:03:31,810 --> 00:03:38,280
hypervisor so in a typical SUV system

00:03:34,840 --> 00:03:41,739
the vast majority of the guest memory is

00:03:38,280 --> 00:03:44,620
encrypted thus protecting the contents

00:03:41,739 --> 00:03:48,160
of the data that's being actively worked

00:03:44,620 --> 00:03:50,650
on except for a few pages like the

00:03:48,160 --> 00:03:53,560
software i/o TLB that are used for DMA

00:03:50,650 --> 00:03:58,510
operations to the the hypervisor and

00:03:53,560 --> 00:04:01,750
other outside entities the applications

00:03:58,510 --> 00:04:05,350
that exist within the virtual machine

00:04:01,750 --> 00:04:06,880
are not modified at all and that's one

00:04:05,350 --> 00:04:10,540
of the the benefits of this architecture

00:04:06,880 --> 00:04:12,310
is that the enlightenment happens at the

00:04:10,540 --> 00:04:14,140
operating system level and I should say

00:04:12,310 --> 00:04:16,329
that this is sort of the standard

00:04:14,140 --> 00:04:18,070
virtual machine model it's not the only

00:04:16,329 --> 00:04:24,490
model as well we'll talk about here as

00:04:18,070 --> 00:04:27,160
well in a typical setup we have support

00:04:24,490 --> 00:04:30,070
for this with KVM and QM you

00:04:27,160 --> 00:04:31,570
support is upstream we have a github

00:04:30,070 --> 00:04:34,150
page on our website that has

00:04:31,570 --> 00:04:36,670
instructions for all the major Linux

00:04:34,150 --> 00:04:38,410
distros now so if you are interested in

00:04:36,670 --> 00:04:41,200
kind of setting up a VM with this

00:04:38,410 --> 00:04:45,670
enabled we do have instructions on on

00:04:41,200 --> 00:04:48,040
how to do that I should mention that the

00:04:45,670 --> 00:04:51,280
this technology first came out a couple

00:04:48,040 --> 00:04:55,150
years ago with our first generation epic

00:04:51,280 --> 00:04:57,340
processors only our server processors

00:04:55,150 --> 00:04:59,650
support this multiple key encryption

00:04:57,340 --> 00:05:02,830
mode the single key mode is supported by

00:04:59,650 --> 00:05:04,900
all of our all of our products the first

00:05:02,830 --> 00:05:07,000
generation processors only support a

00:05:04,900 --> 00:05:08,560
maximum of 15 keys so you could only

00:05:07,000 --> 00:05:11,860
have 15 different virtual machines

00:05:08,560 --> 00:05:14,560
running at the same time we recently

00:05:11,860 --> 00:05:16,180
about two weeks ago released our second

00:05:14,560 --> 00:05:19,210
generation server processors those

00:05:16,180 --> 00:05:20,890
support up to 509 keys so you can have

00:05:19,210 --> 00:05:28,390
substantially more guests running at the

00:05:20,890 --> 00:05:30,370
same time so the SCV feature protects

00:05:28,390 --> 00:05:31,990
the memory of the guest but there are

00:05:30,370 --> 00:05:34,060
there are other things as well one of

00:05:31,990 --> 00:05:37,210
the big ones is the register state of

00:05:34,060 --> 00:05:40,240
the virtual machine and we created a

00:05:37,210 --> 00:05:43,270
second optional feature called se es or

00:05:40,240 --> 00:05:46,060
sv with encrypted state that is designed

00:05:43,270 --> 00:05:48,040
to protect the register state of the

00:05:46,060 --> 00:05:51,040
virtual machine across world switches

00:05:48,040 --> 00:05:53,590
and in particular this involves hardware

00:05:51,040 --> 00:05:56,110
changes such that all of the register

00:05:53,590 --> 00:05:59,290
state of the guest is swapped as one

00:05:56,110 --> 00:06:03,190
atomic operation whereas previously this

00:05:59,290 --> 00:06:05,950
took a number of instructions in x86 all

00:06:03,190 --> 00:06:09,750
of that register state is protected

00:06:05,950 --> 00:06:13,270
using the the guest's encryption key and

00:06:09,750 --> 00:06:15,370
because of that there is special flows

00:06:13,270 --> 00:06:17,770
that have to happen whenever there is

00:06:15,370 --> 00:06:19,690
any kind of virtualization support

00:06:17,770 --> 00:06:22,030
that's required around things like mm

00:06:19,690 --> 00:06:24,400
i/o or instruction emulation and so

00:06:22,030 --> 00:06:27,130
there's a new exception that occurs that

00:06:24,400 --> 00:06:29,800
whenever the guest does something like a

00:06:27,130 --> 00:06:31,630
MSR access that requires hypervisor

00:06:29,800 --> 00:06:33,370
support there's actually now an

00:06:31,630 --> 00:06:36,960
exception that's thrown inside the guest

00:06:33,370 --> 00:06:39,700
and a handler is invoked which

00:06:36,960 --> 00:06:40,720
communicates with the hypervisor in

00:06:39,700 --> 00:06:43,600
order to

00:06:40,720 --> 00:06:45,070
resolve this situation this protocol

00:06:43,600 --> 00:06:47,680
uses something we call a guest

00:06:45,070 --> 00:06:50,680
hypervisor communication block or GHC B

00:06:47,680 --> 00:06:52,780
which is an unencrypted page and the

00:06:50,680 --> 00:06:55,120
idea is that the guest chooses what

00:06:52,780 --> 00:06:58,180
register state it wants to expose as

00:06:55,120 --> 00:06:59,980
opposed to letting the hypervisor to see

00:06:58,180 --> 00:07:03,100
absolutely everything inside the guest

00:06:59,980 --> 00:07:05,770
the protocol for this is documented

00:07:03,100 --> 00:07:10,420
publicly again on our on our web page

00:07:05,770 --> 00:07:12,850
and this feature is is newer as far as

00:07:10,420 --> 00:07:17,140
open source support goes we do have

00:07:12,850 --> 00:07:18,730
patches on our github that support this

00:07:17,140 --> 00:07:21,370
today which you're welcome to try out

00:07:18,730 --> 00:07:22,750
they haven't gone upstream yet but what

00:07:21,370 --> 00:07:31,960
we're expecting to do that relatively

00:07:22,750 --> 00:07:34,390
soon so combine SCV and s ves they don't

00:07:31,960 --> 00:07:36,580
protect against all possible attacks on

00:07:34,390 --> 00:07:39,310
a VM but they do reduce the attack

00:07:36,580 --> 00:07:43,450
surface substantially both of these

00:07:39,310 --> 00:07:45,520
features can protect the memory of the

00:07:43,450 --> 00:07:48,310
virtual machine against things like a

00:07:45,520 --> 00:07:51,669
scrape attack like someone with root

00:07:48,310 --> 00:07:54,330
access running DD on the process they

00:07:51,669 --> 00:07:56,950
can also protect against things like

00:07:54,330 --> 00:08:00,160
some VM escapes or side-channel

00:07:56,950 --> 00:08:01,979
vulnerabilities that result in reading

00:08:00,160 --> 00:08:04,540
memory as the hypervisor

00:08:01,979 --> 00:08:06,520
because the hardware is aware of what

00:08:04,540 --> 00:08:08,440
mode it's operating in it ensures that

00:08:06,520 --> 00:08:11,430
the hypervisor is only able to see the

00:08:08,440 --> 00:08:14,560
cipher text of the virtual machine

00:08:11,430 --> 00:08:17,320
similarly we have DMA protection that if

00:08:14,560 --> 00:08:19,330
you plug in a device devices are not

00:08:17,320 --> 00:08:20,979
allowed to access memory using the guest

00:08:19,330 --> 00:08:24,550
encryption keys and so therefore they

00:08:20,979 --> 00:08:26,710
can only see the cipher text as well the

00:08:24,550 --> 00:08:28,900
VM register state as I mentioned that

00:08:26,710 --> 00:08:31,720
was added in the S ves feature that's

00:08:28,900 --> 00:08:34,990
really the the primary difference both

00:08:31,720 --> 00:08:37,450
of the features can protect against we

00:08:34,990 --> 00:08:39,159
call offline physical attacks so things

00:08:37,450 --> 00:08:40,810
like cold boot attacks again because

00:08:39,159 --> 00:08:43,690
that memory is encrypted and the

00:08:40,810 --> 00:08:45,490
encryption key is stored inside the SOC

00:08:43,690 --> 00:08:49,480
hardware it's not stored anywhere on the

00:08:45,490 --> 00:08:52,520
DRAM chip itself and we can also protect

00:08:49,480 --> 00:08:56,040
against certain kinds of

00:08:52,520 --> 00:08:59,370
buuut time attacks such as an integrity

00:08:56,040 --> 00:09:02,430
attack on the initial image of the VM as

00:08:59,370 --> 00:09:04,350
it's starting up or what's listed here

00:09:02,430 --> 00:09:06,630
is a counterfeit machine attack so that

00:09:04,350 --> 00:09:09,030
could mean either attempting to startup

00:09:06,630 --> 00:09:12,090
the virtual machine on hardware that

00:09:09,030 --> 00:09:14,220
isn't real or just not turning on the

00:09:12,090 --> 00:09:17,550
security features that the customer is

00:09:14,220 --> 00:09:20,520
expecting and both of these features are

00:09:17,550 --> 00:09:25,280
handled through the attestation flow

00:09:20,520 --> 00:09:28,860
which I'll talk about here in a second

00:09:25,280 --> 00:09:31,230
so before I get into the attestation

00:09:28,860 --> 00:09:35,430
flow let me just walk through how a

00:09:31,230 --> 00:09:38,340
typical vm is started so when the

00:09:35,430 --> 00:09:41,910
hypervisor wants to run one of these STV

00:09:38,340 --> 00:09:44,520
VMs it will first ask the secure

00:09:41,910 --> 00:09:46,980
processor to generate an encryption key

00:09:44,520 --> 00:09:49,470
this is a random key and assign it a

00:09:46,980 --> 00:09:52,380
specific slot in the key table and a

00:09:49,470 --> 00:09:55,290
memory controller after that the

00:09:52,380 --> 00:09:58,110
hypervisor will place the initial image

00:09:55,290 --> 00:10:00,330
of the guest unencrypted into memory

00:09:58,110 --> 00:10:02,520
this initial image is assumed to be

00:10:00,330 --> 00:10:04,350
something like a guest BIOS again this

00:10:02,520 --> 00:10:05,940
is speaking in the context of a

00:10:04,350 --> 00:10:09,480
traditional virtual machine it's not the

00:10:05,940 --> 00:10:11,310
only way this can be done but so this

00:10:09,480 --> 00:10:14,130
initial image is not expected to contain

00:10:11,310 --> 00:10:16,320
any secrets and the hypervisor then

00:10:14,130 --> 00:10:19,110
calls the secure processor asking it to

00:10:16,320 --> 00:10:22,470
encrypt this image with the VMS

00:10:19,110 --> 00:10:24,360
encryption key and as it does this it is

00:10:22,470 --> 00:10:28,290
computing a cryptographic measurement of

00:10:24,360 --> 00:10:32,070
the contents that it is encrypting at

00:10:28,290 --> 00:10:35,190
the end of this the hypervisor closes

00:10:32,070 --> 00:10:37,710
the context and the secure processor

00:10:35,190 --> 00:10:40,680
generates an integrity hash over what it

00:10:37,710 --> 00:10:42,870
has measured and this is at the time

00:10:40,680 --> 00:10:45,960
that the attestation protocol happens

00:10:42,870 --> 00:10:47,820
this allows the owner of the guest which

00:10:45,960 --> 00:10:49,890
would be say the cloud customer and a

00:10:47,820 --> 00:10:51,960
typical cloud computing scenario to

00:10:49,890 --> 00:10:54,240
determine if they like the way that the

00:10:51,960 --> 00:10:56,880
VM was started and if so then they have

00:10:54,240 --> 00:11:02,430
the ability to inject some sort of

00:10:56,880 --> 00:11:04,830
secret material so diving into that a

00:11:02,430 --> 00:11:05,610
little bit further this slide makes

00:11:04,830 --> 00:11:07,100
things look more

00:11:05,610 --> 00:11:10,079
complicated than they really are

00:11:07,100 --> 00:11:12,480
essentially what happens is in order to

00:11:10,079 --> 00:11:17,029
support this at a station and secret

00:11:12,480 --> 00:11:17,029
injection protocol there is a different

00:11:18,529 --> 00:11:24,029
extent on the physical box and the guest

00:11:22,050 --> 00:11:26,790
owner which again would be like you if

00:11:24,029 --> 00:11:29,310
you're the cloud customer and this is

00:11:26,790 --> 00:11:33,269
done using what we call the platform

00:11:29,310 --> 00:11:36,240
diffie-hellman key this key is signed by

00:11:33,269 --> 00:11:37,920
a number of other keys to simplify

00:11:36,240 --> 00:11:40,260
things there's really two chains of

00:11:37,920 --> 00:11:42,959
trust here that's going on the first one

00:11:40,260 --> 00:11:45,420
traces back to what's called the OCA the

00:11:42,959 --> 00:11:48,149
owner certificate authority and this is

00:11:45,420 --> 00:11:51,480
something that the owner of the Box like

00:11:48,149 --> 00:11:53,820
the cloud provider can install in order

00:11:51,480 --> 00:11:56,940
to basically demonstrate ownership of

00:11:53,820 --> 00:11:59,130
the platform and so this can assure you

00:11:56,940 --> 00:12:02,160
that your VM is started up in the data

00:11:59,130 --> 00:12:04,200
center you expect this is primarily used

00:12:02,160 --> 00:12:06,570
for enforcing things like migration

00:12:04,200 --> 00:12:09,959
policies and whatnot it's an optional

00:12:06,570 --> 00:12:12,360
feature this second chain of trust goes

00:12:09,959 --> 00:12:14,899
back to AMD and this proves that you're

00:12:12,360 --> 00:12:19,890
running on authentic AMD hardware and

00:12:14,899 --> 00:12:21,870
this goes through fuses that every part

00:12:19,890 --> 00:12:24,570
we manufacture has a unique key what we

00:12:21,870 --> 00:12:27,329
call a chip endorsement key and that key

00:12:24,570 --> 00:12:30,510
is eventually signed by an AMD root key

00:12:27,329 --> 00:12:33,060
and if you go on our website again we

00:12:30,510 --> 00:12:36,870
have an interface where you can get this

00:12:33,060 --> 00:12:39,870
certificate chain for any AMD epic part

00:12:36,870 --> 00:12:41,519
you just you put in a unique identifier

00:12:39,870 --> 00:12:43,410
of the part you got the certificate

00:12:41,519 --> 00:12:46,470
chain and we also have our public key

00:12:43,410 --> 00:12:49,140
available on the website which allows

00:12:46,470 --> 00:12:54,779
you to verify this entire chain when the

00:12:49,140 --> 00:12:58,769
stiffy Holman exchange occurs so putting

00:12:54,779 --> 00:13:01,470
this all together when the VM starts up

00:12:58,769 --> 00:13:04,250
the hypervisor will start off by getting

00:13:01,470 --> 00:13:07,380
this pdh the platform diffie-hellman key

00:13:04,250 --> 00:13:10,320
from the security processor and it will

00:13:07,380 --> 00:13:12,480
also gather the various certificates

00:13:10,320 --> 00:13:16,110
that again we've posted on our website

00:13:12,480 --> 00:13:17,699
and send them to the guest owner and the

00:13:16,110 --> 00:13:19,020
guest owner will verify that the

00:13:17,699 --> 00:13:22,830
certificate chain

00:13:19,020 --> 00:13:24,270
is correct and if everything checks out

00:13:22,830 --> 00:13:26,820
then they will generate their own

00:13:24,270 --> 00:13:30,570
diffie-hellman key send that back to the

00:13:26,820 --> 00:13:32,040
system and this is then provided to the

00:13:30,570 --> 00:13:36,089
secure processor during the launch

00:13:32,040 --> 00:13:38,910
process the hypervisor will continue by

00:13:36,089 --> 00:13:39,560
installing the initial pages for the VM

00:13:38,910 --> 00:13:42,750
and

00:13:39,560 --> 00:13:44,640
encrypting and measuring them and when

00:13:42,750 --> 00:13:47,550
it's finished it gets we call this

00:13:44,640 --> 00:13:50,520
launch measurement from the AMD secure

00:13:47,550 --> 00:13:54,060
processor and this measurement is an H

00:13:50,520 --> 00:13:58,170
Mac that contains the measurement of the

00:13:54,060 --> 00:14:00,060
pages as well as information about the

00:13:58,170 --> 00:14:02,399
policy of how the guest was started up

00:14:00,060 --> 00:14:04,920
like if it had debug enabled or not some

00:14:02,399 --> 00:14:07,080
other version information and this gets

00:14:04,920 --> 00:14:08,760
sent over to the guest owner and I

00:14:07,080 --> 00:14:10,440
should mention there are some nonces in

00:14:08,760 --> 00:14:12,870
here to ensure freshness which I've kind

00:14:10,440 --> 00:14:16,950
of crossed over but there's details in

00:14:12,870 --> 00:14:20,850
the spec the guest owner verifies that

00:14:16,950 --> 00:14:23,760
this H Mac is correct that it contains

00:14:20,850 --> 00:14:26,370
the expected information and if so then

00:14:23,760 --> 00:14:28,589
they can turn around and encrypt a

00:14:26,370 --> 00:14:30,300
secret and the secret could be something

00:14:28,589 --> 00:14:33,300
like a disk encryption key to allow the

00:14:30,300 --> 00:14:35,540
VM to continue booting it could be some

00:14:33,300 --> 00:14:38,970
other sort of root key for the system

00:14:35,540 --> 00:14:41,579
that is then sent over this encrypted

00:14:38,970 --> 00:14:44,700
differing Hellman channel to the the

00:14:41,579 --> 00:14:46,140
hypervisor it passes that in turn to the

00:14:44,700 --> 00:14:49,410
secure processor which is able to

00:14:46,140 --> 00:14:51,690
decrypt it and then inject it into the

00:14:49,410 --> 00:14:55,140
initial image of the VM and at that

00:14:51,690 --> 00:14:57,180
point the VM can then be run and if this

00:14:55,140 --> 00:14:59,970
whole process occurs successfully

00:14:57,180 --> 00:15:01,980
somewhere in its encrypted memory image

00:14:59,970 --> 00:15:04,050
at a presumably well-known location it

00:15:01,980 --> 00:15:06,149
would be able to find the secret widget

00:15:04,050 --> 00:15:09,630
which it can then use to continue the

00:15:06,149 --> 00:15:12,300
process if the attestation process fails

00:15:09,630 --> 00:15:14,250
for some reason or the hypervisor des

00:15:12,300 --> 00:15:15,899
stews is not to even do it then

00:15:14,250 --> 00:15:17,760
presumably the secret would not exist

00:15:15,899 --> 00:15:22,350
and you would not be able to continue

00:15:17,760 --> 00:15:24,690
the boot so this is the the basics of

00:15:22,350 --> 00:15:27,510
SCV and the basics of the attestation

00:15:24,690 --> 00:15:29,130
flow and at this point I'm going to hand

00:15:27,510 --> 00:15:31,529
things over to Nathaniel and he's going

00:15:29,130 --> 00:15:32,510
to talk about how this is used with n

00:15:31,529 --> 00:15:36,350
arcs and

00:15:32,510 --> 00:15:39,110
things that that can do awesome thank

00:15:36,350 --> 00:15:42,220
you David I'm gonna switch some slides

00:15:39,110 --> 00:15:42,220
here for a moment so

00:16:00,150 --> 00:16:05,650
okay so I'm Nathaniel McCollum from Red

00:16:03,670 --> 00:16:08,230
Hat and I want to be talking about the

00:16:05,650 --> 00:16:09,550
the anarch's project and I'm gonna go

00:16:08,230 --> 00:16:12,400
pretty quickly through these slides we

00:16:09,550 --> 00:16:14,530
have a lot of material to cover and but

00:16:12,400 --> 00:16:16,360
I want to make sure we get it all in so

00:16:14,530 --> 00:16:18,160
the most important thing of course is

00:16:16,360 --> 00:16:25,060
our website which is very small

00:16:18,160 --> 00:16:27,760
apparently on this screen that should be

00:16:25,060 --> 00:16:32,890
a little better anarchist dot IO so en

00:16:27,760 --> 00:16:36,070
ARX dot IO so let's quickly outline the

00:16:32,890 --> 00:16:39,130
problems escaped at a very high level

00:16:36,070 --> 00:16:41,620
we all have need for privacy and

00:16:39,130 --> 00:16:44,380
integrity in the cloud this is just a

00:16:41,620 --> 00:16:46,300
small set of examples if you have data

00:16:44,380 --> 00:16:49,660
if you have algorithms that qualifies

00:16:46,300 --> 00:16:51,460
you for privacy in the cloud but the

00:16:49,660 --> 00:16:54,280
difficulty with this of course is that

00:16:51,460 --> 00:16:55,900
we have a fairly complex stack this is

00:16:54,280 --> 00:16:58,270
your sort of traditional virtualization

00:16:55,900 --> 00:17:01,000
stack where you have everything from the

00:16:58,270 --> 00:17:02,890
CPU at the bottom up through BIOS

00:17:01,000 --> 00:17:04,930
firmware hypervisor bootloader kernel

00:17:02,890 --> 00:17:07,030
user space middleware an application and

00:17:04,930 --> 00:17:09,640
in order to have a trusted application

00:17:07,030 --> 00:17:12,070
at least currently as we deploy software

00:17:09,640 --> 00:17:14,710
we actually have to trust the entirety

00:17:12,070 --> 00:17:17,140
of this stack but unfortunately you

00:17:14,710 --> 00:17:18,850
don't have control over all of the stack

00:17:17,140 --> 00:17:21,370
typically you're only the person writing

00:17:18,850 --> 00:17:24,430
the application at the top and the

00:17:21,370 --> 00:17:26,500
different colors here highlight where at

00:17:24,430 --> 00:17:29,680
least traditionally different trust

00:17:26,500 --> 00:17:31,330
relationships came from so in

00:17:29,680 --> 00:17:33,430
virtualization right you could buy an

00:17:31,330 --> 00:17:35,050
operating system like Braille you could

00:17:33,430 --> 00:17:36,490
you could have support for it and that

00:17:35,050 --> 00:17:39,490
would give you at least one single point

00:17:36,490 --> 00:17:42,340
of trust for the for a large portion of

00:17:39,490 --> 00:17:44,500
the stack but this gets much worse in

00:17:42,340 --> 00:17:46,030
when we do containers because there's a

00:17:44,500 --> 00:17:48,100
lot more layers they come from a lot a

00:17:46,030 --> 00:17:50,320
lot more different places so the

00:17:48,100 --> 00:17:54,910
interactions are pretty bad and there's

00:17:50,320 --> 00:17:57,610
a fantastic xkcd comic which basically

00:17:54,910 --> 00:17:59,770
gives us the entire stack and shows the

00:17:57,610 --> 00:18:03,760
compromises pretty much at every layer

00:17:59,770 --> 00:18:05,100
on the stack right so one way we could

00:18:03,760 --> 00:18:07,360
try to do this is we could try to

00:18:05,100 --> 00:18:09,010
measure the entirety of the stack but

00:18:07,360 --> 00:18:10,680
that becomes somewhat fragile because of

00:18:09,010 --> 00:18:12,530
the pieces are changing out all the time

00:18:10,680 --> 00:18:14,330
so what

00:18:12,530 --> 00:18:17,000
you want to do is we want to use these

00:18:14,330 --> 00:18:19,010
trusted and execution environments as a

00:18:17,000 --> 00:18:20,360
way to in fact remove a bunch of the

00:18:19,010 --> 00:18:21,140
stack so that we just don't have to

00:18:20,360 --> 00:18:23,210
trust it at all

00:18:21,140 --> 00:18:25,370
we want to basically just trust the CPU

00:18:23,210 --> 00:18:27,440
at the bottom middleware including n

00:18:25,370 --> 00:18:28,580
arcs anything and that would include n

00:18:27,440 --> 00:18:30,650
arcs and than anything you use in your

00:18:28,580 --> 00:18:33,860
application and then finally the

00:18:30,650 --> 00:18:35,720
application itself so let's let's just

00:18:33,860 --> 00:18:38,930
look at trusted execution environments

00:18:35,720 --> 00:18:40,400
at a very high level the basic thing

00:18:38,930 --> 00:18:42,530
that trusted execution environments

00:18:40,400 --> 00:18:44,990
provide is this there's a host and

00:18:42,530 --> 00:18:47,030
there's a tenant the host is going to

00:18:44,990 --> 00:18:50,200
attest to the tenant so it's going to

00:18:47,030 --> 00:18:52,730
give it some kind of cryptographic

00:18:50,200 --> 00:18:55,000
attestation which typically includes

00:18:52,730 --> 00:18:57,530
things like some sort of diffie-hellman

00:18:55,000 --> 00:18:59,090
public key so that you can set up a

00:18:57,530 --> 00:19:01,760
session key with the actual hardware

00:18:59,090 --> 00:19:03,260
that's that's being done there this also

00:19:01,760 --> 00:19:06,140
typically includes a hardware root of

00:19:03,260 --> 00:19:08,660
trust so or this could be more than one

00:19:06,140 --> 00:19:10,280
think in the example of SCV you have two

00:19:08,660 --> 00:19:13,910
you have one for the platform owner and

00:19:10,280 --> 00:19:16,520
one for for AMD itself and then finally

00:19:13,910 --> 00:19:18,170
you have a trusted execution environment

00:19:16,520 --> 00:19:20,240
measurement and this proves

00:19:18,170 --> 00:19:21,590
cryptographically to the tenant that the

00:19:20,240 --> 00:19:24,200
environment that they're about to inject

00:19:21,590 --> 00:19:28,100
code and data into is in fact not

00:19:24,200 --> 00:19:30,080
compromised it's an okay state then once

00:19:28,100 --> 00:19:32,570
the tenant is assured of this through

00:19:30,080 --> 00:19:35,000
attestation the tenant can then deliver

00:19:32,570 --> 00:19:37,820
code and data over an encrypted channel

00:19:35,000 --> 00:19:39,770
into the trusted environment and they

00:19:37,820 --> 00:19:42,140
get things like memory encryption and

00:19:39,770 --> 00:19:43,970
integrity protection and their own

00:19:42,140 --> 00:19:48,560
independent Hardware a random number

00:19:43,970 --> 00:19:50,660
generator etc so in the industry right

00:19:48,560 --> 00:19:52,490
now we are seeing a development of

00:19:50,660 --> 00:19:55,490
basically two different approaches for

00:19:52,490 --> 00:19:57,260
how to do trusted execution on the left

00:19:55,490 --> 00:19:59,420
hand side we have the process based

00:19:57,260 --> 00:20:00,620
model and this is basically where you

00:19:59,420 --> 00:20:03,320
draw a line right down through the

00:20:00,620 --> 00:20:05,450
middle of a process and there's a secure

00:20:03,320 --> 00:20:08,480
portion of the process and an unsecured

00:20:05,450 --> 00:20:11,120
portion of the process and the two major

00:20:08,480 --> 00:20:15,890
public examples of this are Intel SGX

00:20:11,120 --> 00:20:18,110
and RISC Vives Sanctum these have

00:20:15,890 --> 00:20:19,610
several problems at least from the

00:20:18,110 --> 00:20:22,340
perspective of being able to develop on

00:20:19,610 --> 00:20:25,460
them today first is Intel SGX is not

00:20:22,340 --> 00:20:26,750
upstream nor is it even stable yet in

00:20:25,460 --> 00:20:28,520
terms of the patches

00:20:26,750 --> 00:20:31,220
are going upstream so you really can't

00:20:28,520 --> 00:20:34,280
develop on it today at least not in any

00:20:31,220 --> 00:20:35,330
way that scales risk 5 sanctum Lee of

00:20:34,280 --> 00:20:37,520
course don't have any hardware for that

00:20:35,330 --> 00:20:39,290
yet so that's sort of doesn't work on

00:20:37,520 --> 00:20:41,840
the right-hand side we have the VM based

00:20:39,290 --> 00:20:45,650
model and this works by instead of

00:20:41,840 --> 00:20:47,540
having the security boundary going down

00:20:45,650 --> 00:20:49,880
through the middle of the process it

00:20:47,540 --> 00:20:51,650
happens at the virtual machine boundary

00:20:49,880 --> 00:20:53,840
so it's an already existing boundary

00:20:51,650 --> 00:20:56,240
that we know we we trust we've deployed

00:20:53,840 --> 00:20:58,730
it very widely everyone knows how it

00:20:56,240 --> 00:21:00,890
works and basically we're just going to

00:20:58,730 --> 00:21:03,860
increase increase the security of that

00:21:00,890 --> 00:21:06,040
layer by adding things like a crypt

00:21:03,860 --> 00:21:09,640
encryption and attestation and so on and

00:21:06,040 --> 00:21:12,200
there are three public models for this

00:21:09,640 --> 00:21:14,180
MDS II V as my esteemed colleague has

00:21:12,200 --> 00:21:16,880
already given us a demonstration

00:21:14,180 --> 00:21:20,030
IBM PF I believe it was last year at a

00:21:16,880 --> 00:21:21,770
Security Summit gurney from IBM gave a

00:21:20,030 --> 00:21:23,630
talk about what they're doing with PF

00:21:21,770 --> 00:21:26,210
the hardware for that's not released yet

00:21:23,630 --> 00:21:28,880
so that's also not available to develop

00:21:26,210 --> 00:21:31,940
on today Intel also has a technology

00:21:28,880 --> 00:21:33,110
called MK tme which is currently

00:21:31,940 --> 00:21:35,210
problematic because it has no

00:21:33,110 --> 00:21:37,580
attestation however they've filed a

00:21:35,210 --> 00:21:41,660
patent for adding attestation

00:21:37,580 --> 00:21:44,960
to MK tme so you can probably guess

00:21:41,660 --> 00:21:47,330
what's coming next but there's two

00:21:44,960 --> 00:21:50,300
things I needed to highlight as not at

00:21:47,330 --> 00:21:52,790
EEE and these are trust zone and TPM

00:21:50,300 --> 00:21:54,590
trust zone is not at EEE because it's

00:21:52,790 --> 00:21:57,800
really more of a set of utilities to

00:21:54,590 --> 00:22:02,090
build a te e and it also has very

00:21:57,800 --> 00:22:04,190
significant hardware constraints and the

00:22:02,090 --> 00:22:07,070
the problem of key management is not

00:22:04,190 --> 00:22:08,780
really solved by trust zone so we are

00:22:07,070 --> 00:22:11,870
excluding it for our purposes it can't

00:22:08,780 --> 00:22:14,180
really scale the other thing is a TPM we

00:22:11,870 --> 00:22:16,310
all like TPM is there everyone has them

00:22:14,180 --> 00:22:19,040
in their laptops but it is just simply

00:22:16,310 --> 00:22:23,120
not a trusted execution environment so

00:22:19,040 --> 00:22:25,430
we've got a lot of models here and it's

00:22:23,120 --> 00:22:27,620
probably no surprise why we started with

00:22:25,430 --> 00:22:29,870
AMD SCV that's the first one for which

00:22:27,620 --> 00:22:31,550
we have both Hardware available and ful

00:22:29,870 --> 00:22:35,480
fully upstream support in the Linux

00:22:31,550 --> 00:22:37,100
kernel however we we fundamentally had

00:22:35,480 --> 00:22:38,810
this problem right we have a bunch of

00:22:37,100 --> 00:22:40,730
these technologies that are coming out

00:22:38,810 --> 00:22:43,250
they all provide very

00:22:40,730 --> 00:22:46,070
vastly different ways to approach the

00:22:43,250 --> 00:22:47,660
technology and it's really not clear

00:22:46,070 --> 00:22:51,950
what developers are supposed to do in

00:22:47,660 --> 00:22:53,570
order to embrace this technology so this

00:22:51,950 --> 00:22:56,419
is why I want to introduce the N arcs

00:22:53,570 --> 00:22:58,220
project the goal of the N arcs project

00:22:56,419 --> 00:22:59,120
is precisely to make it so that you

00:22:58,220 --> 00:23:01,910
don't have to worry about these

00:22:59,120 --> 00:23:04,160
technologies but even further we want

00:23:01,910 --> 00:23:08,090
you to not write your application to any

00:23:04,160 --> 00:23:10,250
technology including n arcs ok well n

00:23:08,090 --> 00:23:12,650
arcs is not an application platform as

00:23:10,250 --> 00:23:15,440
you'll see in a minute because what we

00:23:12,650 --> 00:23:17,660
do is basically on the bottom we have

00:23:15,440 --> 00:23:19,220
the process based keeps on the left side

00:23:17,660 --> 00:23:22,010
keeps our what we call our trusted

00:23:19,220 --> 00:23:24,290
execution environments so process based

00:23:22,010 --> 00:23:25,970
keep this includes SGX and sanctum

00:23:24,290 --> 00:23:28,190
we have vm based keeps on the right hand

00:23:25,970 --> 00:23:30,860
side and n arcs is is planning to work

00:23:28,190 --> 00:23:34,160
in both of those cases and basically

00:23:30,860 --> 00:23:36,070
what we do is we put a web assembly JIT

00:23:34,160 --> 00:23:38,630
as the very first thing that happens

00:23:36,070 --> 00:23:41,840
inside these trusted execution

00:23:38,630 --> 00:23:44,150
environments on top of that we use the

00:23:41,840 --> 00:23:47,440
web assembly system interface which is

00:23:44,150 --> 00:23:50,360
not yet finalized but is an ongoing w3c

00:23:47,440 --> 00:23:52,370
w3c standard on top of this you can

00:23:50,360 --> 00:23:54,350
build Ling language bindings like Lib C

00:23:52,370 --> 00:23:57,710
and then you just write your application

00:23:54,350 --> 00:23:59,870
and deploy it so the important bit here

00:23:57,710 --> 00:24:02,360
is we're implementing standards here

00:23:59,870 --> 00:24:04,429
there's not magical and arc stuff that

00:24:02,360 --> 00:24:06,230
you need to do to your application you

00:24:04,429 --> 00:24:08,059
take an application you compile it in a

00:24:06,230 --> 00:24:12,770
certain way and n arcs takes it from

00:24:08,059 --> 00:24:14,360
there so for example here is a here's

00:24:12,770 --> 00:24:16,429
the deployment model you'll notice that

00:24:14,360 --> 00:24:18,380
I put at the top here n arcs is not a

00:24:16,429 --> 00:24:20,929
development framework it is a deployment

00:24:18,380 --> 00:24:21,710
framework so the first thing you do of

00:24:20,929 --> 00:24:22,910
course when you're writing an

00:24:21,710 --> 00:24:24,679
application is you choose your language

00:24:22,910 --> 00:24:26,390
and tools you don't really have to think

00:24:24,679 --> 00:24:28,400
about n arcs at this stage you just

00:24:26,390 --> 00:24:29,660
develop your application and then when

00:24:28,400 --> 00:24:31,220
you're done you compile it to web

00:24:29,660 --> 00:24:33,200
assembly using the standards that are

00:24:31,220 --> 00:24:34,429
already available then at the time in

00:24:33,200 --> 00:24:36,410
which you want to deploy that

00:24:34,429 --> 00:24:38,390
application that's when n arcs get'em

00:24:36,410 --> 00:24:40,760
gets involved you take the application

00:24:38,390 --> 00:24:41,929
you pass it to n arcs you choose a host

00:24:40,760 --> 00:24:44,360
and you give it the instance

00:24:41,929 --> 00:24:46,730
configuration and then n arcs will take

00:24:44,360 --> 00:24:49,520
the responsibility to deploy that into a

00:24:46,730 --> 00:24:51,890
secure environment on your behalf this

00:24:49,520 --> 00:24:53,480
does have very significant benefits

00:24:51,890 --> 00:24:54,290
because since we're using web assembly

00:24:53,480 --> 00:24:57,800
here you

00:24:54,290 --> 00:25:01,130
you can deploy on the same binary on any

00:24:57,800 --> 00:25:03,230
of the environments right so if imagine

00:25:01,130 --> 00:25:05,360
if you get a vulnerability in one

00:25:03,230 --> 00:25:07,010
implementation you just change your

00:25:05,360 --> 00:25:09,050
deployment configuration and ship it

00:25:07,010 --> 00:25:10,820
shifted immediately to something else

00:25:09,050 --> 00:25:12,290
you don't change the binary you just

00:25:10,820 --> 00:25:15,890
keep running with the same binary just

00:25:12,290 --> 00:25:17,450
deployed to a different host so n arcs

00:25:15,890 --> 00:25:19,280
is also going to insist on best

00:25:17,450 --> 00:25:22,010
practices which will be on by default

00:25:19,280 --> 00:25:23,420
and will be very hard and we will yell

00:25:22,010 --> 00:25:26,930
at you loudly if you try to turn them

00:25:23,420 --> 00:25:30,140
off this includes things like we do not

00:25:26,930 --> 00:25:32,090
allow plaintext networking shock okay so

00:25:30,140 --> 00:25:33,110
you can't really do plaintext network

00:25:32,090 --> 00:25:35,780
networking if you don't want your

00:25:33,110 --> 00:25:38,180
traffic to be observed so we enforce TLS

00:25:35,780 --> 00:25:40,190
we have a project called cipher pipe for

00:25:38,180 --> 00:25:42,980
this it's in the process of being

00:25:40,190 --> 00:25:44,510
slightly rewritten so we actually have

00:25:42,980 --> 00:25:46,520
two projects one called TLS sock and one

00:25:44,510 --> 00:25:50,510
called cipher pipe but you can see this

00:25:46,520 --> 00:25:52,850
at our github and also we plan for a no

00:25:50,510 --> 00:25:54,260
plain plaintext persisted data so

00:25:52,850 --> 00:25:56,630
whenever you write data you just get

00:25:54,260 --> 00:25:59,570
block encryption from the host side and

00:25:56,630 --> 00:26:01,580
from the guest side you see files we

00:25:59,570 --> 00:26:03,500
will also insist on an independent keep

00:26:01,580 --> 00:26:05,510
random number generator and we will

00:26:03,500 --> 00:26:06,980
reviews all api's that are available to

00:26:05,510 --> 00:26:09,830
the hosts to make sure that they don't

00:26:06,980 --> 00:26:12,350
leak data this by the way is why you

00:26:09,830 --> 00:26:14,390
really can't put containers into these

00:26:12,350 --> 00:26:16,010
kinds of environments because containers

00:26:14,390 --> 00:26:18,020
can just call any syscall they want

00:26:16,010 --> 00:26:19,610
which means you're basically carrying a

00:26:18,020 --> 00:26:22,730
pot of soup to the dinner table in a

00:26:19,610 --> 00:26:25,100
colander so we're gonna give you a demo

00:26:22,730 --> 00:26:26,870
as I said n arcs is not fully production

00:26:25,100 --> 00:26:28,850
ready but we do have some portions of it

00:26:26,870 --> 00:26:31,730
working what you're about to see is

00:26:28,850 --> 00:26:33,830
you're gonna see a client who is going

00:26:31,730 --> 00:26:36,020
to who's going to be the tenant and

00:26:33,830 --> 00:26:39,980
they're gonna deploy some code to run in

00:26:36,020 --> 00:26:43,340
a server the on the server side we have

00:26:39,980 --> 00:26:44,690
AMD Hardware with Md firmware and we're

00:26:43,340 --> 00:26:45,680
gonna we're going to the first thing

00:26:44,690 --> 00:26:47,990
we're gonna do is we're gonna do the

00:26:45,680 --> 00:26:49,160
attestation handshake this is what's

00:26:47,990 --> 00:26:50,780
going to give us the cryptographic

00:26:49,160 --> 00:26:53,810
validation that we're talking to real

00:26:50,780 --> 00:26:55,370
AMD Hardware here the next thing we're

00:26:53,810 --> 00:26:56,990
going to do is we're going to use the

00:26:55,370 --> 00:26:59,660
session key that's derived from that

00:26:56,990 --> 00:27:03,050
attestation in order to deliver code and

00:26:59,660 --> 00:27:05,890
data into the secure VM and then we're

00:27:03,050 --> 00:27:05,890
going to execute it so

00:27:11,280 --> 00:27:15,670
so keep in mind while we're doing this

00:27:13,570 --> 00:27:17,590
that what's important here is not what

00:27:15,670 --> 00:27:19,840
we are doing but how we are doing it

00:27:17,590 --> 00:27:20,920
we're gonna take two numbers three and

00:27:19,840 --> 00:27:25,050
four and we're gonna add them together

00:27:20,920 --> 00:27:29,460
and the output is seven which I believe

00:27:25,050 --> 00:27:31,510
it's cut off the screen unfortunately

00:27:29,460 --> 00:27:34,540
yeah you could you can see it there in

00:27:31,510 --> 00:27:35,950
the second time apparently so so it does

00:27:34,540 --> 00:27:38,140
output the correct number I think we all

00:27:35,950 --> 00:27:40,000
agree three plus four is seven

00:27:38,140 --> 00:27:41,440
but again the most important thing here

00:27:40,000 --> 00:27:43,450
is is what's being done

00:27:41,440 --> 00:27:46,510
notice that we ran the command twice

00:27:43,450 --> 00:27:48,340
that we will talk about that in just a

00:27:46,510 --> 00:27:49,930
second but I want to walk through the

00:27:48,340 --> 00:27:51,490
steps of what we did so the first thing

00:27:49,930 --> 00:27:53,980
we did was the client retrieved a

00:27:51,490 --> 00:27:55,510
certificate chain from the server this

00:27:53,980 --> 00:27:56,020
is the certificate chain that David just

00:27:55,510 --> 00:27:58,240
talked about

00:27:56,020 --> 00:27:59,890
then we validated that certificate chain

00:27:58,240 --> 00:28:04,840
which means we now know that we are

00:27:59,890 --> 00:28:06,970
talking to authentic AMD hardware and we

00:28:04,840 --> 00:28:09,520
got it we got what we validate that

00:28:06,970 --> 00:28:12,160
chain so we say chain okay we now can

00:28:09,520 --> 00:28:15,010
generate session keys and an execution

00:28:12,160 --> 00:28:18,490
policy which we can deliver to the host

00:28:15,010 --> 00:28:20,080
to start the VM that's validated by the

00:28:18,490 --> 00:28:21,670
firmware and the session keys are

00:28:20,080 --> 00:28:24,370
decrypted by the firmware so the host

00:28:21,670 --> 00:28:26,140
can't see them the next thing we do is

00:28:24,370 --> 00:28:28,180
we have the server start up a virtual

00:28:26,140 --> 00:28:29,950
machine this virtual machine is empty

00:28:28,180 --> 00:28:31,060
and by virtual machine here I don't mean

00:28:29,950 --> 00:28:33,070
an operating system

00:28:31,060 --> 00:28:34,420
I mean think of like a virtual CPU

00:28:33,070 --> 00:28:35,980
that's all we're talking about there's

00:28:34,420 --> 00:28:39,340
nothing in this and by nothing I mean

00:28:35,980 --> 00:28:41,590
nothing no instructions so we started up

00:28:39,340 --> 00:28:43,450
we measure the empty virtual machine and

00:28:41,590 --> 00:28:45,550
we send the measurement back to the

00:28:43,450 --> 00:28:47,470
client the client validates the

00:28:45,550 --> 00:28:48,820
measurements okay yes this is in fact an

00:28:47,470 --> 00:28:51,100
empty virtual machine you haven't

00:28:48,820 --> 00:28:53,860
injected a boot kid in here that I can

00:28:51,100 --> 00:28:57,310
use to that you can use to grab data so

00:28:53,860 --> 00:29:00,280
now the client is has fully attested to

00:28:57,310 --> 00:29:02,500
the server and is ready to deploy code

00:29:00,280 --> 00:29:04,510
it has session keys and so the next

00:29:02,500 --> 00:29:06,580
thing it does is it encrypts its code

00:29:04,510 --> 00:29:09,040
and data and sends it directly to the

00:29:06,580 --> 00:29:10,830
server this is the point at which I want

00:29:09,040 --> 00:29:13,540
you to notice that we did this twice

00:29:10,830 --> 00:29:15,010
this is exactly the same code in exactly

00:29:13,540 --> 00:29:16,360
the same input but notice that the

00:29:15,010 --> 00:29:18,990
cipher texts are different because we

00:29:16,360 --> 00:29:22,500
have perfect forward secrecy on the

00:29:18,990 --> 00:29:24,510
three of this code so finally the server

00:29:22,500 --> 00:29:26,130
receives this encrypted code hands it

00:29:24,510 --> 00:29:28,429
over to the firmware the firmware

00:29:26,130 --> 00:29:31,620
injects the encrypted code into the VM

00:29:28,429 --> 00:29:34,170
launches the VM our code runs we get the

00:29:31,620 --> 00:29:37,460
number seven output and this takes about

00:29:34,170 --> 00:29:37,460
filling 50 milliseconds

00:29:46,010 --> 00:29:50,919
I apparently can't exit full-screen yeah

00:29:52,870 --> 00:29:59,360
so as we said we walked you through

00:29:57,620 --> 00:30:01,039
exactly what was gonna happen and what

00:29:59,360 --> 00:30:02,659
that's exactly what we did we did the

00:30:01,039 --> 00:30:05,330
attestation with the with the host firm

00:30:02,659 --> 00:30:07,519
where we got a session key we delivered

00:30:05,330 --> 00:30:10,039
code and data all the way to the secure

00:30:07,519 --> 00:30:11,659
VM and we ran the code and we did so

00:30:10,039 --> 00:30:13,130
without the host being able to see the

00:30:11,659 --> 00:30:15,590
code that we injected the data that we

00:30:13,130 --> 00:30:19,519
injected or what was happening while the

00:30:15,590 --> 00:30:21,110
code was running so this is what we call

00:30:19,519 --> 00:30:22,880
the in arcs keep right this is what

00:30:21,110 --> 00:30:25,010
we're trying to go for here we want to

00:30:22,880 --> 00:30:28,669
be able to deliver encrypted code and

00:30:25,010 --> 00:30:30,470
data into some sort of a trusted

00:30:28,669 --> 00:30:33,130
execution environment which we call a

00:30:30,470 --> 00:30:36,409
keep and we want to be able to run that

00:30:33,130 --> 00:30:38,570
however we need your help so we notice

00:30:36,409 --> 00:30:41,179
that this what was actually used in this

00:30:38,570 --> 00:30:43,490
demo was hand-coded assembly we don't

00:30:41,179 --> 00:30:47,389
have web assembly running yet we do have

00:30:43,490 --> 00:30:48,919
some some some good starts on that we do

00:30:47,389 --> 00:30:50,690
have a demos repo that shows some other

00:30:48,919 --> 00:30:52,669
demos we have pull requests against the

00:30:50,690 --> 00:30:54,919
demo repo but we would we would really

00:30:52,669 --> 00:30:56,419
love to have you participate this is of

00:30:54,919 --> 00:30:58,760
course open source everything the Red

00:30:56,419 --> 00:31:00,950
Hat does is open source it's licensed

00:30:58,760 --> 00:31:03,529
under Apache to everything we're writing

00:31:00,950 --> 00:31:05,299
is in rust which gives us the great

00:31:03,529 --> 00:31:08,120
properties of memory safety that rust

00:31:05,299 --> 00:31:10,789
provides and you can of course see our

00:31:08,120 --> 00:31:15,019
website at NRK oh and github slash

00:31:10,789 --> 00:31:17,720
anarch's so I think I've left enough

00:31:15,019 --> 00:31:19,970
time for questions here I'm gonna have

00:31:17,720 --> 00:31:23,980
Mike run around with microphone and ask

00:31:19,970 --> 00:31:23,980
questions for either myself or for David

00:31:24,940 --> 00:31:31,100
if you ask a question you get a sticker

00:31:27,230 --> 00:31:31,880
oh I get a sticker first thank you even

00:31:31,100 --> 00:31:33,950
if it's a bad question

00:31:31,880 --> 00:31:37,940
oh yeah bad questions great I'm Michael

00:31:33,950 --> 00:31:42,169
Crowe with Google have you I was curious

00:31:37,940 --> 00:31:45,620
about the a solo project yes why oh it's

00:31:42,169 --> 00:31:48,380
an open source framework and SDK for the

00:31:45,620 --> 00:31:50,240
development of you know applications for

00:31:48,380 --> 00:31:51,559
trusted execution environments and I was

00:31:50,240 --> 00:31:53,720
wondering if you could compare and

00:31:51,559 --> 00:31:56,350
contrast sure

00:31:53,720 --> 00:31:59,950
in fact we anticipated this question and

00:31:56,350 --> 00:31:59,950
we have a slide for it

00:32:00,190 --> 00:32:08,059
so currently there are two other major

00:32:04,219 --> 00:32:12,049
initiatives in the in the open source

00:32:08,059 --> 00:32:15,199
world right now the first one is to just

00:32:12,049 --> 00:32:16,639
write to the hardware specific SDK this

00:32:15,199 --> 00:32:18,320
is not what you get with the with the

00:32:16,639 --> 00:32:20,209
virtual machine based technology right

00:32:18,320 --> 00:32:22,190
virtual machine technology you just get

00:32:20,209 --> 00:32:24,769
a virtual machine you don't get an SDK

00:32:22,190 --> 00:32:27,109
to develop on it you only get the SDK in

00:32:24,769 --> 00:32:29,769
the process model so you can write

00:32:27,109 --> 00:32:32,059
directly to the hardware vendors SDK

00:32:29,769 --> 00:32:33,619
unfortunately that provides Hardware

00:32:32,059 --> 00:32:35,449
locking you're literally writing your

00:32:33,619 --> 00:32:37,039
whole application to that SDK you can

00:32:35,449 --> 00:32:39,529
only run on that one piece of hardware

00:32:37,039 --> 00:32:41,089
and whatever happens if that one piece

00:32:39,529 --> 00:32:42,409
of hardware that you can only run on

00:32:41,089 --> 00:32:44,949
because you can only develop to that one

00:32:42,409 --> 00:32:48,379
piece of hardware gets a vulnerability

00:32:44,949 --> 00:32:50,449
you're stuck right so we don't think

00:32:48,379 --> 00:32:53,690
that's a great option option number two

00:32:50,449 --> 00:32:56,539
is to create some sort of abstraction

00:32:53,690 --> 00:32:58,159
framework overtop of these and there's

00:32:56,539 --> 00:33:00,649
been two attempts at this one is from

00:32:58,159 --> 00:33:02,329
the asilah project from from google the

00:33:00,649 --> 00:33:05,209
other one is the open Enclave project

00:33:02,329 --> 00:33:07,519
from Microsoft and these basically only

00:33:05,209 --> 00:33:09,709
work with the process based model so

00:33:07,519 --> 00:33:12,829
again not VMs they only work with

00:33:09,709 --> 00:33:14,089
process based model and it's really

00:33:12,829 --> 00:33:16,909
great that people are thinking about

00:33:14,089 --> 00:33:18,889
abstracting this however we think it's

00:33:16,909 --> 00:33:19,819
not great for several reasons first we

00:33:18,889 --> 00:33:21,229
don't want you to develop your

00:33:19,819 --> 00:33:23,119
application to it we want you to develop

00:33:21,229 --> 00:33:25,429
your application like normal and just

00:33:23,119 --> 00:33:26,419
deploy into these environments right we

00:33:25,429 --> 00:33:29,269
don't want you to change the way you

00:33:26,419 --> 00:33:31,879
develop your application secondly they

00:33:29,269 --> 00:33:34,699
provide both projects only provide

00:33:31,879 --> 00:33:36,169
abstraction over SGX and Trust zone but

00:33:34,699 --> 00:33:39,709
does anybody remember what I said trust

00:33:36,169 --> 00:33:41,659
zone was not trust zone is not at EEE

00:33:39,709 --> 00:33:42,769
it's a framework for building tes and

00:33:41,659 --> 00:33:44,299
has significant problems with

00:33:42,769 --> 00:33:46,899
scalability

00:33:44,299 --> 00:33:50,989
both of these are arm is very aware of

00:33:46,899 --> 00:33:52,579
so because trust zone is not at EEE we

00:33:50,989 --> 00:33:56,269
end up with an abstraction layer over a

00:33:52,579 --> 00:33:58,519
single technology which I don't think

00:33:56,269 --> 00:34:00,169
provides a lot of value we end up with

00:33:58,519 --> 00:34:01,639
implicit hardware lock-in even though

00:34:00,169 --> 00:34:03,919
we've written to an abstracted interface

00:34:01,639 --> 00:34:06,649
the other the other downside of course

00:34:03,919 --> 00:34:08,059
is that these abstraction layers only

00:34:06,649 --> 00:34:09,529
work on the process based model so you

00:34:08,059 --> 00:34:10,860
don't get to capture any of the work

00:34:09,529 --> 00:34:12,870
that's being done in the secure VM

00:34:10,860 --> 00:34:14,420
space which is precisely why anarch's

00:34:12,870 --> 00:34:18,230
wants to build on both of them

00:34:14,420 --> 00:34:18,230
so I hope that answers your question

00:34:18,650 --> 00:34:24,090
will be very happy to answer further

00:34:21,210 --> 00:34:28,050
questions in the hallway track yeah but

00:34:24,090 --> 00:34:40,410
you only get one sticker any other

00:34:28,050 --> 00:34:41,550
questions so you're running in a virtual

00:34:40,410 --> 00:34:43,260
machine

00:34:41,550 --> 00:34:44,730
what's the kernel that's running in the

00:34:43,260 --> 00:34:47,070
virtual machine it's a kind of a unit

00:34:44,730 --> 00:34:52,470
kernel microkernel yeah so we actually

00:34:47,070 --> 00:34:54,390
haven't decided yet we are we're

00:34:52,470 --> 00:34:58,920
currently investigating an approach

00:34:54,390 --> 00:35:00,330
which I call the mono kernel and

00:34:58,920 --> 00:35:01,980
basically what we want to provide is we

00:35:00,330 --> 00:35:05,510
want to provide an integrated hypervisor

00:35:01,980 --> 00:35:08,460
kernel and application all in one binary

00:35:05,510 --> 00:35:10,170
so in terms of where we actually get

00:35:08,460 --> 00:35:14,190
that kernel code from that's not been

00:35:10,170 --> 00:35:17,010
decided we are probably not gonna use

00:35:14,190 --> 00:35:19,770
Linux for this because we want to keep

00:35:17,010 --> 00:35:22,380
everything licensed under Apache 2 and

00:35:19,770 --> 00:35:23,730
also because we need a significant

00:35:22,380 --> 00:35:25,500
number of kernel components to be

00:35:23,730 --> 00:35:27,270
reusable in the process based model as

00:35:25,500 --> 00:35:29,370
well so we need something more modular

00:35:27,270 --> 00:35:31,620
like we need for example a file system

00:35:29,370 --> 00:35:34,080
that can work in both the kernel and in

00:35:31,620 --> 00:35:37,980
SGX because we only want to expose block

00:35:34,080 --> 00:35:39,900
devices so having a kernel like like

00:35:37,980 --> 00:35:42,240
Linux would could work well in the

00:35:39,900 --> 00:35:45,780
virtualization case but then we have to

00:35:42,240 --> 00:35:48,450
reinvent the entire world for for the

00:35:45,780 --> 00:35:49,830
process based case so so we're looking

00:35:48,450 --> 00:35:52,500
at various different technologies we

00:35:49,830 --> 00:35:54,870
haven't made a decision yet I'm having a

00:35:52,500 --> 00:35:56,610
meeting on Thursday to have a deep dive

00:35:54,870 --> 00:36:04,980
hammer it out and try to try to make a

00:35:56,610 --> 00:36:06,840
decision to move forward so how are you

00:36:04,980 --> 00:36:08,700
loading this encrypted code and data are

00:36:06,840 --> 00:36:10,620
you injecting the key and then load this

00:36:08,700 --> 00:36:14,190
code and data from encrypted disk image

00:36:10,620 --> 00:36:17,250
it depends a certain so no there's not

00:36:14,190 --> 00:36:19,790
an encrypted disk image the the code is

00:36:17,250 --> 00:36:23,790
going to be delivered at runtime and

00:36:19,790 --> 00:36:25,410
decode how precisely that workflow work

00:36:23,790 --> 00:36:26,820
is dependent on the hardware so the

00:36:25,410 --> 00:36:29,970
different tech hardware technologies

00:36:26,820 --> 00:36:31,320
have different approaches for attesting

00:36:29,970 --> 00:36:37,590
what's in the trusted execution

00:36:31,320 --> 00:36:40,020
environment so for the demo we used the

00:36:37,590 --> 00:36:42,590
launch secret functionality of SCV and

00:36:40,020 --> 00:36:45,690
launched it directly into an empty

00:36:42,590 --> 00:36:47,970
virtual machine I believe that

00:36:45,690 --> 00:36:49,080
functionality is going away at some

00:36:47,970 --> 00:36:51,440
point and we're gonna get a slightly

00:36:49,080 --> 00:36:54,180
different functionality is that right

00:36:51,440 --> 00:36:56,850
yeah yeah there might be some changes in

00:36:54,180 --> 00:36:58,740
the future but yeah in the current

00:36:56,850 --> 00:37:01,530
technology is literally the the code

00:36:58,740 --> 00:37:03,240
bytes are the secret that is injected

00:37:01,530 --> 00:37:04,980
and then it's just executed from there

00:37:03,240 --> 00:37:08,660
it's not the only way that it could be

00:37:04,980 --> 00:37:08,660
done but that's that's what's done today

00:37:12,080 --> 00:37:25,020
I'm sorry mister so I heard something

00:37:23,160 --> 00:37:26,430
about protected code launch I'm not sure

00:37:25,020 --> 00:37:29,010
exactly what you're referring to there

00:37:26,430 --> 00:37:31,320
but we do so we are working on SGX

00:37:29,010 --> 00:37:33,240
we actually have a pull request for a

00:37:31,320 --> 00:37:35,010
demo doing anta station basically what

00:37:33,240 --> 00:37:37,800
you already saw kind of a little bit

00:37:35,010 --> 00:37:39,060
less than what you already saw on SUV so

00:37:37,800 --> 00:37:41,190
there's a pull request from one of my

00:37:39,060 --> 00:37:44,160
team members and we're gonna be

00:37:41,190 --> 00:37:45,750
hopefully merging that this week so we

00:37:44,160 --> 00:37:48,030
are looking at other technologies we

00:37:45,750 --> 00:37:49,350
have no intention of locking anyone into

00:37:48,030 --> 00:37:51,060
a technology the whole point of this

00:37:49,350 --> 00:37:53,850
architecture is to make it very very

00:37:51,060 --> 00:37:55,860
easy to work across a variety of

00:37:53,850 --> 00:37:57,900
technologies and not have to develop

00:37:55,860 --> 00:38:03,270
your application to one specific

00:37:57,900 --> 00:38:05,370
technology anyone else James how we

00:38:03,270 --> 00:38:08,250
doing for time was it that time ten

00:38:05,370 --> 00:38:11,660
minutes left Oh ten minutes come on very

00:38:08,250 --> 00:38:11,660
fast okay one over here

00:38:14,970 --> 00:38:18,850
so to launch this application we seem to

00:38:17,620 --> 00:38:20,710
be going through the attestation

00:38:18,850 --> 00:38:22,600
framework so how what's an overhead that

00:38:20,710 --> 00:38:25,270
happens before you could actually launch

00:38:22,600 --> 00:38:28,330
the overhead for the attestation model

00:38:25,270 --> 00:38:32,230
in the case of SCV we were looking at 50

00:38:28,330 --> 00:38:33,670
milliseconds and that was all local so

00:38:32,230 --> 00:38:35,170
there was no there was no network you

00:38:33,670 --> 00:38:36,880
would need to have some network latency

00:38:35,170 --> 00:38:38,680
as well he'd also been probably gonna

00:38:36,880 --> 00:38:42,100
deliver a larger application than that

00:38:38,680 --> 00:38:43,990
as well so it's really hard to predict

00:38:42,100 --> 00:38:47,950
and it's going to be basically linear

00:38:43,990 --> 00:38:49,750
with the size of your application we

00:38:47,950 --> 00:38:51,550
would probably implement some sort of a

00:38:49,750 --> 00:38:54,640
caching framework as well I would

00:38:51,550 --> 00:39:04,180
imagine although there's a tension with

00:38:54,640 --> 00:39:07,420
delivering perfect forward secrecy David

00:39:04,180 --> 00:39:10,390
so I'm not worried about the side

00:39:07,420 --> 00:39:12,760
channel attacks including like page page

00:39:10,390 --> 00:39:14,830
for base attacks or cache based attacks

00:39:12,760 --> 00:39:20,020
when you're encrypting the entire VM

00:39:14,830 --> 00:39:21,730
with I see V SME us Marc excite channel

00:39:20,020 --> 00:39:24,250
attacks like like prime and probe and

00:39:21,730 --> 00:39:26,620
page amazing right so those are

00:39:24,250 --> 00:39:29,410
currently not part of our threat model

00:39:26,620 --> 00:39:32,110
of SCV and they're kind of not part of

00:39:29,410 --> 00:39:34,540
the standard x86 threat model either

00:39:32,110 --> 00:39:35,770
like we don't have any way of preventing

00:39:34,540 --> 00:39:38,110
you from writing code that might be

00:39:35,770 --> 00:39:41,500
vulnerable to like a prime and pro based

00:39:38,110 --> 00:39:43,090
attack so right there's there's nothing

00:39:41,500 --> 00:39:44,830
in this generation that we provide

00:39:43,090 --> 00:39:46,780
specifically for that other than just

00:39:44,830 --> 00:39:48,880
the guidance that you know please don't

00:39:46,780 --> 00:39:50,890
write your crypto libraries to use

00:39:48,880 --> 00:39:52,780
values dependant on secrets and things

00:39:50,890 --> 00:39:55,930
like that but beyond that we don't have

00:39:52,780 --> 00:39:59,380
any special capabilities I should also

00:39:55,930 --> 00:40:02,020
note here that in the way that n arcs is

00:39:59,380 --> 00:40:03,520
designed you're going to basically get a

00:40:02,020 --> 00:40:05,590
block of native code that's all

00:40:03,520 --> 00:40:08,700
delivered by n arcs and we would hope

00:40:05,590 --> 00:40:12,160
that to be side-channel resistant and

00:40:08,700 --> 00:40:13,840
and anything that's that has problems we

00:40:12,160 --> 00:40:15,460
would want to invest in mitigations and

00:40:13,840 --> 00:40:18,400
in fact I already have an open bug about

00:40:15,460 --> 00:40:20,760
about developing mitigations foresight

00:40:18,400 --> 00:40:20,760
channels

00:40:27,479 --> 00:40:34,259
they do both have different problems you

00:40:32,609 --> 00:40:36,059
know we can we can detect some of that

00:40:34,259 --> 00:40:37,439
at compile time based upon your compile

00:40:36,059 --> 00:40:43,979
time target because you're going to be

00:40:37,439 --> 00:40:46,529
building an arcs for SGX or for SE v s/s

00:40:43,979 --> 00:40:48,900
GX cpuid is actually not unavailable

00:40:46,529 --> 00:40:51,749
instruction although if you actually

00:40:48,900 --> 00:40:53,969
look at the Intel SDK they currently

00:40:51,749 --> 00:40:56,669
proxy to the host to virtualize the

00:40:53,969 --> 00:40:58,709
CPUID instruction which now we're

00:40:56,669 --> 00:41:01,650
trusting the host again I don't really

00:40:58,709 --> 00:41:04,199
know that why that's there but but yeah

00:41:01,650 --> 00:41:06,179
so we're going we're going to have to

00:41:04,199 --> 00:41:07,769
consider that at some point exactly how

00:41:06,179 --> 00:41:09,959
we do that I don't have a clear answer

00:41:07,769 --> 00:41:11,429
to and I'd say also that if you have

00:41:09,959 --> 00:41:14,369
particular concerns about particular

00:41:11,429 --> 00:41:16,140
attacks when you are deploying you say

00:41:14,369 --> 00:41:17,969
well I have concerns about attacks on

00:41:16,140 --> 00:41:19,829
this platform so I won't allow

00:41:17,969 --> 00:41:21,660
deployment on that platform so yeah I

00:41:19,829 --> 00:41:23,640
have that option as a deployment at

00:41:21,660 --> 00:41:25,919
deployment time yeah a big point of this

00:41:23,640 --> 00:41:27,869
is right you have your application it's

00:41:25,919 --> 00:41:30,509
the same binary no matter what platform

00:41:27,869 --> 00:41:32,519
you're launching it on and so if you

00:41:30,509 --> 00:41:34,709
consider a particular platform to be

00:41:32,519 --> 00:41:38,849
broken just disable it and launch

00:41:34,709 --> 00:41:44,819
somewhere else so I'm a bit curious

00:41:38,849 --> 00:41:47,669
about why and how you feel good about

00:41:44,819 --> 00:41:50,489
web assembly given the current state of

00:41:47,669 --> 00:41:53,309
its okay so let me ask this question

00:41:50,489 --> 00:41:57,509
what is the largest decentralized

00:41:53,309 --> 00:42:02,579
computing network in the world anybody

00:41:57,509 --> 00:42:06,569
want to guess JavaScript it's JavaScript

00:42:02,579 --> 00:42:09,569
by many orders of magnitude right web

00:42:06,569 --> 00:42:11,039
assembly is I'm currently participating

00:42:09,569 --> 00:42:13,529
in the standards for web assembly to

00:42:11,039 --> 00:42:16,769
make sure that we get what we need but

00:42:13,529 --> 00:42:19,259
the I think it is clear that web

00:42:16,769 --> 00:42:21,299
assembly is the only thing that we have

00:42:19,259 --> 00:42:22,829
to potentially dethrone at javascript is

00:42:21,299 --> 00:42:26,429
the largest decentralized computing

00:42:22,829 --> 00:42:28,439
network in the world and so I think it's

00:42:26,429 --> 00:42:31,369
a very good fit it is also very

00:42:28,439 --> 00:42:34,709
conveniently the web assembly system API

00:42:31,369 --> 00:42:35,760
covers as a system API basically exactly

00:42:34,709 --> 00:42:37,080
what we can do

00:42:35,760 --> 00:42:39,600
you inside trusted execution

00:42:37,080 --> 00:42:43,440
environments so it's a very natural fit

00:42:39,600 --> 00:42:49,170
in terms of capabilities did you have a

00:42:43,440 --> 00:42:52,290
specific concern okay Marty Wiseman G

00:42:49,170 --> 00:42:54,150
research um the earlier slide you were

00:42:52,290 --> 00:42:56,820
eliminating all the Middle's stuff from

00:42:54,150 --> 00:42:59,090
your TCB I'm gonna argue there's

00:42:56,820 --> 00:43:04,980
probably some use cases for having that

00:42:59,090 --> 00:43:07,620
tested as well yes yes so they did they

00:43:04,980 --> 00:43:11,670
did they protect different sides right

00:43:07,620 --> 00:43:13,820
understand is there is there any notion

00:43:11,670 --> 00:43:16,170
of binding the thing that attests to

00:43:13,820 --> 00:43:19,050
that stuff in the middle you crossed I

00:43:16,170 --> 00:43:21,240
would be for example a TPM it would be

00:43:19,050 --> 00:43:23,700
really nice to be able to when I talk to

00:43:21,240 --> 00:43:26,340
this application to have some binding

00:43:23,700 --> 00:43:28,740
between the TPM that's on the platform

00:43:26,340 --> 00:43:30,570
that has keys for these other things you

00:43:28,740 --> 00:43:32,700
can test to this middle ground the

00:43:30,570 --> 00:43:35,550
notion of binding and maybe this is more

00:43:32,700 --> 00:43:37,200
toward the question a nd than you is

00:43:35,550 --> 00:43:38,760
there any notion of binding these two

00:43:37,200 --> 00:43:40,770
sets of attestation keys

00:43:38,760 --> 00:43:42,330
so that I answer the question these two

00:43:40,770 --> 00:43:46,770
things are on the same physical platform

00:43:42,330 --> 00:43:48,690
no and and intentionally no attestation

00:43:46,770 --> 00:43:51,750
of the platform protects the platform

00:43:48,690 --> 00:43:53,730
deployer attestation of the tenant

00:43:51,750 --> 00:43:55,860
application of the trusted execution

00:43:53,730 --> 00:43:58,650
environment protects the tenant these

00:43:55,860 --> 00:44:02,460
they protect simply different parties if

00:43:58,650 --> 00:44:04,620
you want to do you know attestation of

00:44:02,460 --> 00:44:08,180
the entire stack there are projects for

00:44:04,620 --> 00:44:11,360
that like key lime right but there's

00:44:08,180 --> 00:44:14,460
trying to link them together

00:44:11,360 --> 00:44:16,170
fundamentally undoes the sense of

00:44:14,460 --> 00:44:18,450
radical portability that we are trying

00:44:16,170 --> 00:44:21,300
to accomplish because now you've just

00:44:18,450 --> 00:44:24,480
tied your application to something very

00:44:21,300 --> 00:44:27,030
specific that the that the cloud service

00:44:24,480 --> 00:44:28,740
provider is giving you and we want our

00:44:27,030 --> 00:44:30,510
environments to be homogeneous precisely

00:44:28,740 --> 00:44:32,850
so that you can move it somewhere else

00:44:30,510 --> 00:44:36,060
right red hat is very very against

00:44:32,850 --> 00:44:39,530
lock-in and we would see that as a very

00:44:36,060 --> 00:44:39,530
clear opportunity for locking

00:44:41,569 --> 00:44:49,579
I'm kind of shocked people who haven't

00:44:43,069 --> 00:44:51,469
already asked questions just a quick

00:44:49,579 --> 00:44:55,609
question is there any way that you can

00:44:51,469 --> 00:45:03,979
detect say a hostile hypervisor say that

00:44:55,609 --> 00:45:05,419
you're handling all this stuff yes yes I

00:45:03,979 --> 00:45:13,279
can't really say more yeah

00:45:05,419 --> 00:45:14,269
patent on this you might already

00:45:13,279 --> 00:45:17,029
answered this but I might have missed it

00:45:14,269 --> 00:45:19,069
so where does we assembly actually fit

00:45:17,029 --> 00:45:20,269
into the the stack here so like I

00:45:19,069 --> 00:45:20,809
understand how the attestation process

00:45:20,269 --> 00:45:22,400
works

00:45:20,809 --> 00:45:25,009
I understand how like once you've

00:45:22,400 --> 00:45:28,369
actually developed like a sense of trust

00:45:25,009 --> 00:45:29,719
for your VM essentially anarch's is

00:45:28,369 --> 00:45:31,579
gonna be the bit that you're going to be

00:45:29,719 --> 00:45:32,929
a testing and anarch's is going to

00:45:31,579 --> 00:45:35,779
include a web assembly JIT

00:45:32,929 --> 00:45:37,189
so once you've attested now anarch's is

00:45:35,779 --> 00:45:39,650
just waiting for you to deliver web

00:45:37,189 --> 00:45:42,739
assembly code that it will JIT okay and

00:45:39,650 --> 00:45:45,049
so you will then have encrypted code and

00:45:42,739 --> 00:45:47,929
data that you deliver to the anarch's

00:45:45,049 --> 00:45:49,429
runtime anarch's runtime will handle

00:45:47,929 --> 00:45:51,859
that data in a way that's appropriate

00:45:49,429 --> 00:45:53,779
and will compile just-in-time compile

00:45:51,859 --> 00:45:56,599
the web assembly to the native platform

00:45:53,779 --> 00:45:57,289
and then execute I'll hand over James I

00:45:56,599 --> 00:45:59,659
think we're out of time

00:45:57,289 --> 00:46:01,699
sorry we're very very happy to be around

00:45:59,659 --> 00:46:02,929
and the fan is running for the rest day

00:46:01,699 --> 00:46:05,719
I'm around for the rest of the week

00:46:02,929 --> 00:46:08,630
there's a broth right later there's a

00:46:05,719 --> 00:46:09,199
better buff specifically on open Enclave

00:46:08,630 --> 00:46:10,969
stuff

00:46:09,199 --> 00:46:12,589
Mike stuff running we're happy to be

00:46:10,969 --> 00:46:16,369
involved in that if my soft folks are

00:46:12,589 --> 00:46:18,380
happy and we have stickers so you can

00:46:16,369 --> 00:46:21,290
ask this guy for stickers if you want

00:46:18,380 --> 00:46:25,280
one I think that buff is a separate okay

00:46:21,290 --> 00:46:25,280

YouTube URL: https://www.youtube.com/watch?v=0-ISmJNxGiY


