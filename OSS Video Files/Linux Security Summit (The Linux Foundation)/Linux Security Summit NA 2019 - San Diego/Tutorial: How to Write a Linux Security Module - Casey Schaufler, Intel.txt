Title: Tutorial: How to Write a Linux Security Module - Casey Schaufler, Intel
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Tutorial: How to Write a Linux Security Module - Casey Schaufler, Intel

You have a great idea for security in the Linux kernel, but you don't know how to add it properly. How can you implement additional security mechanism in a way that can be accepted upstream? This tutorial will teach you the basics of the Linux Security Module (LSM) infrastructure and how to use it properly. You will learn what an LSM can and cannot do, when you should use an LSM, when you should look into mainline changes and when you should look at namespaces. Security module data management conventions will be discussed. The filesystem, process, networking and audit interfaces will be covered.Casey Schaufler will be joined by Paul Moore and John Johansen to ensure that each LSM interface is covered by its expert. There's a lot of information to cover in 90 minutes, but there is no better set of instructors around.
Captions: 
	00:00:00,000 --> 00:00:03,750
good morning everybody I want to make

00:00:01,860 --> 00:00:05,009
sure that we get some decent questions

00:00:03,750 --> 00:00:11,040
here so I have a little bit of an

00:00:05,009 --> 00:00:14,310
incentive yeah I have a Raspberry Pi

00:00:11,040 --> 00:00:14,310
[Music]

00:00:15,170 --> 00:00:30,119
yeah it's a 2 or 3 or something I don't

00:00:29,070 --> 00:00:34,170
know I've never used it

00:00:30,119 --> 00:00:35,399
that's why I'm giving it away getting

00:00:34,170 --> 00:00:38,160
great fine yeah

00:00:35,399 --> 00:00:40,469
nobody gets it then no best question

00:00:38,160 --> 00:00:43,739
gets gets the Raspberry Pi and that

00:00:40,469 --> 00:00:48,270
includes the questions asked while other

00:00:43,739 --> 00:00:51,239
people actually presenting so we've got

00:00:48,270 --> 00:00:52,680
90 minutes the only reason why I'm doing

00:00:51,239 --> 00:00:54,870
this is because I've never had the

00:00:52,680 --> 00:00:59,250
opportunity to speak uninterrupted for

00:00:54,870 --> 00:01:04,010
90 minutes before I hope you'll ask

00:00:59,250 --> 00:01:06,590
questions as they come to you because

00:01:04,010 --> 00:01:10,200
we've got a lot of information to cover

00:01:06,590 --> 00:01:13,650
it's not the simplest situation in the

00:01:10,200 --> 00:01:15,299
world so yeah feel free to interrupt and

00:01:13,650 --> 00:01:17,750
we'll we won't cover everything but

00:01:15,299 --> 00:01:20,280
we'll try to get you sufficiently

00:01:17,750 --> 00:01:26,420
intrigued that you'll want to go off and

00:01:20,280 --> 00:01:29,070
make the world better for security so

00:01:26,420 --> 00:01:31,909
you said making sure that his fiendish

00:01:29,070 --> 00:01:31,909
thing is working

00:01:32,030 --> 00:01:39,650
haha it helps if you plug in the dongle

00:01:44,110 --> 00:01:48,560
there we go this time for sure nothing

00:01:47,870 --> 00:01:51,650
up my sleeve

00:01:48,560 --> 00:01:53,750
presto so why do you want to run right

00:01:51,650 --> 00:01:57,590
Hellenic security module I mean we got

00:01:53,750 --> 00:02:01,430
great ones already we've got smack and

00:01:57,590 --> 00:02:05,060
SELinux and app armor and Tamayo and

00:02:01,430 --> 00:02:08,420
yama load pin safe set sea safe asset

00:02:05,060 --> 00:02:12,590
Syd we've got a couple more that are

00:02:08,420 --> 00:02:15,740
coming down the pike and so really why

00:02:12,590 --> 00:02:18,080
would you want to do it and of course

00:02:15,740 --> 00:02:21,280
writing kernel code is hard you have to

00:02:18,080 --> 00:02:24,290
deal with all those community people so

00:02:21,280 --> 00:02:26,650
there are times when a Linux security

00:02:24,290 --> 00:02:31,190
module is actually the easiest way to

00:02:26,650 --> 00:02:37,010
accomplish the things that you want to

00:02:31,190 --> 00:02:39,170
do okay I just want to let everybody

00:02:37,010 --> 00:02:42,380
know that that is annoying me as much as

00:02:39,170 --> 00:02:47,360
it's annoying you the the bandsaw in the

00:02:42,380 --> 00:02:49,630
next room all right so why so when is

00:02:47,360 --> 00:02:53,390
the Linux security module - right choice

00:02:49,630 --> 00:02:56,570
yeah I hear you crying if you want to

00:02:53,390 --> 00:02:58,910
add access control decisions access

00:02:56,570 --> 00:03:01,670
control restrictions to your existing

00:02:58,910 --> 00:03:04,010
system that's what a Linux security

00:03:01,670 --> 00:03:06,190
module is for and you want to do it to

00:03:04,010 --> 00:03:09,950
things that are controlled by the kernel

00:03:06,190 --> 00:03:13,850
things like files and processes system 5

00:03:09,950 --> 00:03:15,380
IPC objects socket delivery and if you

00:03:13,850 --> 00:03:16,850
want to do mandatory access control this

00:03:15,380 --> 00:03:17,959
is about the only place you can do it

00:03:16,850 --> 00:03:19,910
because it's the only place where we

00:03:17,959 --> 00:03:22,400
actually have all the information about

00:03:19,910 --> 00:03:25,459
all of the things you might want to deal

00:03:22,400 --> 00:03:30,050
with so one of the most important things

00:03:25,459 --> 00:03:33,680
to realize about security modules that

00:03:30,050 --> 00:03:35,900
they implement restrictive controls so

00:03:33,680 --> 00:03:38,030
the traditional controls are still done

00:03:35,900 --> 00:03:39,980
you still have to pass the mode bit

00:03:38,030 --> 00:03:44,930
checks if you have access control lists

00:03:39,980 --> 00:03:48,049
you still have to pass those but you can

00:03:44,930 --> 00:03:51,470
base your access control checks on any

00:03:48,049 --> 00:03:54,410
of that information

00:03:51,470 --> 00:03:57,260
so the UID checks are based capability

00:03:54,410 --> 00:04:00,980
checks are still done if there are other

00:03:57,260 --> 00:04:02,870
LSMs you may have to wait and see that

00:04:00,980 --> 00:04:05,900
their checks are done and you can't

00:04:02,870 --> 00:04:10,490
override a denial so you cannot write an

00:04:05,900 --> 00:04:14,600
LS M that says I want to I know that any

00:04:10,490 --> 00:04:17,299
user ID that's odd an odd number is okay

00:04:14,600 --> 00:04:19,310
so yeah in spite of the fact that that

00:04:17,299 --> 00:04:21,709
user ID wouldn't have access to a file

00:04:19,310 --> 00:04:24,410
go ahead and let it happen anyway you

00:04:21,709 --> 00:04:28,550
can't do that with an LS m/l s/m are

00:04:24,410 --> 00:04:31,520
restrictive just yeah restrictive

00:04:28,550 --> 00:04:37,070
Jackson so when is a Linux community

00:04:31,520 --> 00:04:39,470
module the wrong choice if you want to

00:04:37,070 --> 00:04:41,870
change the access control restrictions

00:04:39,470 --> 00:04:46,010
of the system you can't do that with an

00:04:41,870 --> 00:04:48,590
LS M the best example of this are POSIX

00:04:46,010 --> 00:04:51,020
access control lists which you cannot

00:04:48,590 --> 00:04:53,210
implement as an LS m because they

00:04:51,020 --> 00:05:00,800
actually change the behavior of the mode

00:04:53,210 --> 00:05:04,100
bits so if you tried to do it if you

00:05:00,800 --> 00:05:06,710
tried to do access control lists as an

00:05:04,100 --> 00:05:09,080
LS m you would discover that there were

00:05:06,710 --> 00:05:10,580
denials being coming and you weren't

00:05:09,080 --> 00:05:12,050
expecting because they get to the mode

00:05:10,580 --> 00:05:14,240
bit some of which would say no you can't

00:05:12,050 --> 00:05:15,830
do that and then you get to the access

00:05:14,240 --> 00:05:17,919
control list which would which would

00:05:15,830 --> 00:05:21,620
have granted you access and you can't

00:05:17,919 --> 00:05:25,970
you'll never have gotten there the other

00:05:21,620 --> 00:05:28,460
thing is readily done in user space how

00:05:25,970 --> 00:05:32,270
many of you remember d-bus remember KD

00:05:28,460 --> 00:05:34,310
bus excuse me KD bus okay yeah there's

00:05:32,270 --> 00:05:39,530
there's there's a smattering of people

00:05:34,310 --> 00:05:42,080
over here you don't do KD bus sorry you

00:05:39,530 --> 00:05:44,690
don't do DD bus in the kernel because

00:05:42,080 --> 00:05:48,169
it's readily done in user space it's a

00:05:44,690 --> 00:05:50,390
lot easier to do things that you can do

00:05:48,169 --> 00:05:53,390
in user space typically in user space

00:05:50,390 --> 00:05:57,050
and you're a lot of other advantages to

00:05:53,390 --> 00:05:58,700
doing them in user space so if you can

00:05:57,050 --> 00:06:00,530
readily do it in user space if it's the

00:05:58,700 --> 00:06:03,220
kind of thing that you would do in user

00:06:00,530 --> 00:06:07,880
space don't try to put it in the kernel

00:06:03,220 --> 00:06:09,890
so what are the alternatives now there

00:06:07,880 --> 00:06:13,610
are a lot of security mechanisms believe

00:06:09,890 --> 00:06:15,530
it or not in the Linux kernel some

00:06:13,610 --> 00:06:19,729
people even say there might be too many

00:06:15,530 --> 00:06:21,200
sometimes you run into conflicts so one

00:06:19,729 --> 00:06:22,850
of the alternatives is special special

00:06:21,200 --> 00:06:24,800
purpose file systems if you want to

00:06:22,850 --> 00:06:29,360
encrypt your files you don't do that in

00:06:24,800 --> 00:06:31,880
an LS M you right right they put it into

00:06:29,360 --> 00:06:36,650
your filesystem code or you have a file

00:06:31,880 --> 00:06:38,210
system equipped if equipped that sits on

00:06:36,650 --> 00:06:40,370
top of everybody else or you do it in

00:06:38,210 --> 00:06:43,910
the block layer you just don't do it in

00:06:40,370 --> 00:06:50,539
an LS M we also have these cool things

00:06:43,910 --> 00:06:54,770
called namespaces which offer a variety

00:06:50,539 --> 00:06:56,720
of ways to do separation so you can have

00:06:54,770 --> 00:06:57,310
processes that are isolated from each

00:06:56,720 --> 00:07:01,640
other

00:06:57,310 --> 00:07:03,520
and because there are enough people

00:07:01,640 --> 00:07:06,320
talking about containers and other other

00:07:03,520 --> 00:07:09,080
we won't go into that too deeply but

00:07:06,320 --> 00:07:11,060
that's one of the alternatives you can

00:07:09,080 --> 00:07:12,530
do network namespaces can you file

00:07:11,060 --> 00:07:14,330
system namespace you can do user

00:07:12,530 --> 00:07:15,620
namespaces so all kinds of good stuff

00:07:14,330 --> 00:07:19,160
you can do with that we also have a

00:07:15,620 --> 00:07:20,750
system have a mechanical set comp and if

00:07:19,160 --> 00:07:22,750
what you want to do is stuff that is

00:07:20,750 --> 00:07:25,340
oriented towards system calls

00:07:22,750 --> 00:07:27,169
set cop is the way to go and if you want

00:07:25,340 --> 00:07:29,750
to do bizarre and unnatural things with

00:07:27,169 --> 00:07:32,690
set comp that it doesn't already do and

00:07:29,750 --> 00:07:36,229
there are a few that would be a place to

00:07:32,690 --> 00:07:39,460
enhance if you want to do it at the

00:07:36,229 --> 00:07:43,580
system called granularity because that's

00:07:39,460 --> 00:07:47,320
where it's oriented if you want to do

00:07:43,580 --> 00:07:47,320
packet filtering we have a net filter

00:07:49,120 --> 00:07:53,570
whereby packet come comes in the system

00:07:51,919 --> 00:07:55,910
you can do virtually anything you want

00:07:53,570 --> 00:07:58,940
to it under virtually any circumstances

00:07:55,910 --> 00:08:00,919
it's really magic and then we have BPF

00:07:58,940 --> 00:08:02,270
and EBP F which are brand new and I

00:08:00,919 --> 00:08:05,750
don't really understand as well as I

00:08:02,270 --> 00:08:09,440
ought to but they're new and cool and

00:08:05,750 --> 00:08:12,560
and magical magical thingies that you

00:08:09,440 --> 00:08:15,320
can use in sort of in some circumstances

00:08:12,560 --> 00:08:17,860
in order to do things that are oriented

00:08:15,320 --> 00:08:24,530
toward toward small small programs

00:08:17,860 --> 00:08:27,200
embedded in the kernel so security

00:08:24,530 --> 00:08:31,220
module don'ts and I apologize profusely

00:08:27,200 --> 00:08:33,320
that the picture is missing I couldn't

00:08:31,220 --> 00:08:35,479
find a really good picture for this so

00:08:33,320 --> 00:08:38,900
you don't want to duplicate an existing

00:08:35,479 --> 00:08:39,830
security module we do have several yeah

00:08:38,900 --> 00:08:43,760
you

00:08:39,830 --> 00:08:47,930
we have generic Mac systems we have

00:08:43,760 --> 00:08:52,490
three generic Mac systems we have se

00:08:47,930 --> 00:08:55,130
Linux which is granular we have SMAC

00:08:52,490 --> 00:08:58,730
which is simpler and we have a parmer

00:08:55,130 --> 00:09:02,240
which is oriented more toward usability

00:08:58,730 --> 00:09:06,110
than it is toward objects and subjects

00:09:02,240 --> 00:09:10,130
and provable correctness if I sound

00:09:06,110 --> 00:09:12,830
about right okay sure whatever that's

00:09:10,130 --> 00:09:15,830
that's the nice nice thing about John is

00:09:12,830 --> 00:09:20,089
he's Ameen able to just about being just

00:09:15,830 --> 00:09:21,740
about anything another thing you want to

00:09:20,089 --> 00:09:23,839
be really careful with if you're gonna

00:09:21,740 --> 00:09:27,110
do a security module is don't count on

00:09:23,839 --> 00:09:28,820
the user mode helper really it's like if

00:09:27,110 --> 00:09:30,860
you're going to make a security decision

00:09:28,820 --> 00:09:33,650
think about how many of those you can

00:09:30,860 --> 00:09:35,330
make in a second if you're going to make

00:09:33,650 --> 00:09:37,310
a security decision you're gonna call up

00:09:35,330 --> 00:09:39,380
to a helper and say hey helper what

00:09:37,310 --> 00:09:43,520
should I do and helpers got its gigabyte

00:09:39,380 --> 00:09:45,290
database that's going here I know how to

00:09:43,520 --> 00:09:47,150
make my decisions based on all this this

00:09:45,290 --> 00:09:49,790
learned data that I've accumulated over

00:09:47,150 --> 00:09:53,950
the past ten years and I'm gonna think

00:09:49,790 --> 00:09:53,950
about it for about 10 seconds say yes

00:09:54,040 --> 00:09:57,740
your system is gonna come to a

00:09:56,150 --> 00:09:59,450
screeching halt and you're gonna have

00:09:57,740 --> 00:10:02,450
all kinds of locking issues and nobody's

00:09:59,450 --> 00:10:05,210
going to love you so don't put a whole

00:10:02,450 --> 00:10:07,220
lot of faith in userspace helpers we've

00:10:05,210 --> 00:10:08,839
seen several things suggested that do

00:10:07,220 --> 00:10:10,670
that and they all have this problem

00:10:08,839 --> 00:10:13,820
where they end up getting a lot as soon

00:10:10,670 --> 00:10:16,640
as the second process starts the other

00:10:13,820 --> 00:10:19,910
thing is don't inflame the community and

00:10:16,640 --> 00:10:24,199
there are lots of good ways to do that

00:10:19,910 --> 00:10:26,329
it's actually pretty easy so when you

00:10:24,199 --> 00:10:29,920
come in with a security module it needs

00:10:26,329 --> 00:10:35,350
to make sense yeah wacky things don't

00:10:29,920 --> 00:10:39,430
get a lot of good coverage wacky things

00:10:35,350 --> 00:10:42,079
tend to get a lot of derisively sponsz a

00:10:39,430 --> 00:10:44,930
good example somebody reasonably

00:10:42,079 --> 00:10:46,699
proposed a security module that would do

00:10:44,930 --> 00:10:48,410
nothing but look at the path names and

00:10:46,699 --> 00:10:55,939
if there was a space in the path name

00:10:48,410 --> 00:10:57,500
rejected actually very very useful but a

00:10:55,939 --> 00:10:59,720
lot of the community people in the

00:10:57,500 --> 00:11:01,699
community thought that this because this

00:10:59,720 --> 00:11:05,930
violated POSIX semantics and other

00:11:01,699 --> 00:11:08,779
trivial things that this was probably

00:11:05,930 --> 00:11:10,879
not a good idea so when you're gonna

00:11:08,779 --> 00:11:13,279
propose something make sure that it

00:11:10,879 --> 00:11:17,689
makes makes a modicum of sense not just

00:11:13,279 --> 00:11:24,709
for your particular use case but in

00:11:17,689 --> 00:11:26,600
general okay so that said let's talk

00:11:24,709 --> 00:11:29,209
about designing your security module

00:11:26,600 --> 00:11:32,360
because really kind of makes sense to do

00:11:29,209 --> 00:11:35,449
that I know that a lot of fields in

00:11:32,360 --> 00:11:37,220
computer in in software development

00:11:35,449 --> 00:11:40,579
these days we don't design things we

00:11:37,220 --> 00:11:42,319
just throw throw stuff onto the disk and

00:11:40,579 --> 00:11:45,290
if we like it at two weeks afterwards

00:11:42,319 --> 00:11:46,939
then we try to publish it put it out on

00:11:45,290 --> 00:11:48,079
github but it really does make sense

00:11:46,939 --> 00:11:50,480
when you're dealing with security to

00:11:48,079 --> 00:11:52,759
design what it is you want it to

00:11:50,480 --> 00:11:54,350
accomplish so the first thing you have

00:11:52,759 --> 00:11:59,750
to figure out is what do you want to

00:11:54,350 --> 00:12:02,389
protect kind of an obvious thing but

00:11:59,750 --> 00:12:07,459
yeah what what matters you do you want

00:12:02,389 --> 00:12:09,949
to protect objects on the file system do

00:12:07,459 --> 00:12:14,360
you want to restrict path names like

00:12:09,949 --> 00:12:16,069
this this one LSM proposed to doing do

00:12:14,360 --> 00:12:17,750
you want to protect the interaction

00:12:16,069 --> 00:12:20,209
between processes do you want to protect

00:12:17,750 --> 00:12:23,779
what a process individual process can

00:12:20,209 --> 00:12:27,170
and can't do under circumstances do you

00:12:23,779 --> 00:12:29,930
want to do things like keep track of the

00:12:27,170 --> 00:12:31,740
number of times program accesses the

00:12:29,930 --> 00:12:33,540
number of things in Etsy and

00:12:31,740 --> 00:12:35,610
that looks at things in se more than

00:12:33,540 --> 00:12:40,010
twice then you say yeah no I don't trust

00:12:35,610 --> 00:12:42,510
this program anymore do you want to try

00:12:40,010 --> 00:12:45,930
trust hunks of data this is getting to

00:12:42,510 --> 00:12:50,520
be more interesting as we start having

00:12:45,930 --> 00:12:54,300
things like Intel's SGX where the data

00:12:50,520 --> 00:12:57,930
that you're putting into what they call

00:12:54,300 --> 00:13:01,800
an enclave is a program but you might

00:12:57,930 --> 00:13:05,460
want to actually say things about what

00:13:01,800 --> 00:13:07,470
circumstances you want to be in force

00:13:05,460 --> 00:13:10,530
when you allow people when you allow a

00:13:07,470 --> 00:13:13,980
program to do that and then there are

00:13:10,530 --> 00:13:16,760
just basic resources like the clock yeah

00:13:13,980 --> 00:13:19,470
it's like do I want to protect the clock

00:13:16,760 --> 00:13:22,440
there are some cases where the the

00:13:19,470 --> 00:13:25,560
current permissions on the clock just

00:13:22,440 --> 00:13:27,690
aren't adequate so you might want to do

00:13:25,560 --> 00:13:33,360
things on resources or other system

00:13:27,690 --> 00:13:37,530
resources memory memory pages things

00:13:33,360 --> 00:13:40,740
like that and then what do you want to

00:13:37,530 --> 00:13:44,670
protect it from yeah this is this is

00:13:40,740 --> 00:13:46,950
kind of a interesting point because you

00:13:44,670 --> 00:13:49,140
might say I want ultimate file security

00:13:46,950 --> 00:13:50,640
in Psych okay they'll put Altamont file

00:13:49,140 --> 00:13:54,180
security in place but what are you who

00:13:50,640 --> 00:13:56,000
are you protecting it from well do you

00:13:54,180 --> 00:13:58,290
you want to protect it from people

00:13:56,000 --> 00:14:00,870
because we got people out there who are

00:13:58,290 --> 00:14:03,630
malicious and we got people out there

00:14:00,870 --> 00:14:11,070
that are stupid and there are people who

00:14:03,630 --> 00:14:13,440
are poorly trained or the other thing

00:14:11,070 --> 00:14:16,500
we're seeing these days and believe me

00:14:13,440 --> 00:14:17,760
from what when I started out in the in

00:14:16,500 --> 00:14:20,310
the computer industry we never even

00:14:17,760 --> 00:14:22,560
thought about this not till mr. Morris

00:14:20,310 --> 00:14:24,900
put his worm out which is that

00:14:22,560 --> 00:14:28,650
applications themselves can be written

00:14:24,900 --> 00:14:31,530
to be malicious like they just it it's

00:14:28,650 --> 00:14:33,480
not some person doing this there's

00:14:31,530 --> 00:14:36,090
nobody sitting out there driving this

00:14:33,480 --> 00:14:38,160
but this bit of code regardless where it

00:14:36,090 --> 00:14:42,840
came from is gonna do bad things to your

00:14:38,160 --> 00:14:45,090
system and we also have believe it or

00:14:42,840 --> 00:14:45,390
not one or two applications out there in

00:14:45,090 --> 00:14:48,680
the

00:14:45,390 --> 00:14:56,310
environment today that are badly written

00:14:48,680 --> 00:14:57,720
I won't say no js' but I mean some of

00:14:56,310 --> 00:14:59,940
the things that are included in there

00:14:57,720 --> 00:15:06,510
are actually not especially well done

00:14:59,940 --> 00:15:08,459
and this isn't news I wouldn't wouldn't

00:15:06,510 --> 00:15:12,000
think it's like sturgeons law says that

00:15:08,459 --> 00:15:13,620
90% of everything is crap and that

00:15:12,000 --> 00:15:19,320
applies to software just as well as

00:15:13,620 --> 00:15:20,399
applies to to trashy novels the other

00:15:19,320 --> 00:15:21,390
thing you might want to think about is a

00:15:20,399 --> 00:15:24,450
network access

00:15:21,390 --> 00:15:27,029
what is networking and the the behavior

00:15:24,450 --> 00:15:31,380
of packets coming in and going out of

00:15:27,029 --> 00:15:35,399
your system mean for the things you want

00:15:31,380 --> 00:15:36,810
to protect the nice thing about network

00:15:35,399 --> 00:15:38,490
packets is that they don't have any

00:15:36,810 --> 00:15:41,519
attribute information associated with

00:15:38,490 --> 00:15:42,990
them usually so you don't know who they

00:15:41,519 --> 00:15:47,730
came from or who they're going to

00:15:42,990 --> 00:15:52,160
they're just blobby things so how do you

00:15:47,730 --> 00:15:52,160
want to protect against that or do you

00:15:52,880 --> 00:15:59,100
so given that now I'm going to shift

00:15:57,750 --> 00:16:01,560
gears 'la and this will happen

00:15:59,100 --> 00:16:04,680
throughout throughout the talk because I

00:16:01,560 --> 00:16:11,220
my coherency editor was was off this

00:16:04,680 --> 00:16:13,709
week and that is well we've got okay but

00:16:11,220 --> 00:16:15,360
we know we want to protect so we know

00:16:13,709 --> 00:16:18,360
what we want to protect we know what we

00:16:15,360 --> 00:16:22,410
want to protect it from what do we have

00:16:18,360 --> 00:16:27,750
to do to put how do we actually go about

00:16:22,410 --> 00:16:30,930
do that well we have two elements that

00:16:27,750 --> 00:16:36,779
we used for protecting things hooks and

00:16:30,930 --> 00:16:38,870
blobs a hook is is the piece of pieces

00:16:36,779 --> 00:16:41,910
bits of code that we that you implement

00:16:38,870 --> 00:16:43,740
for a particular when you get to a

00:16:41,910 --> 00:16:45,810
particular place in the kernel and it's

00:16:43,740 --> 00:16:48,209
going around doing some usually access

00:16:45,810 --> 00:16:52,079
control checks for other things but

00:16:48,209 --> 00:16:55,410
sometimes not we'll call a security hook

00:16:52,079 --> 00:16:59,180
and this is a bit of code that will take

00:16:55,410 --> 00:17:02,640
some set of information and then

00:16:59,180 --> 00:17:04,020
make a decision in addition to what the

00:17:02,640 --> 00:17:06,060
rest of the colonel is doing and say

00:17:04,020 --> 00:17:08,250
yeah you can do this or no you can't and

00:17:06,060 --> 00:17:13,370
they're sprinkled about the the system

00:17:08,250 --> 00:17:16,140
in a well thought out in structured way

00:17:13,370 --> 00:17:19,110
so my example here is with inode

00:17:16,140 --> 00:17:21,330
permission if you want to check and see

00:17:19,110 --> 00:17:23,580
whether a process has access to the

00:17:21,330 --> 00:17:26,190
particular inode it calls security I

00:17:23,580 --> 00:17:28,320
know permission and because you have an

00:17:26,190 --> 00:17:31,650
a security module registered in here

00:17:28,320 --> 00:17:33,960
which we'll call sample your sample LS M

00:17:31,650 --> 00:17:36,180
it will call sample inode permission

00:17:33,960 --> 00:17:39,570
which will then look at the security

00:17:36,180 --> 00:17:44,850
blob which in this case is is I know I

00:17:39,570 --> 00:17:45,930
security and say you then your security

00:17:44,850 --> 00:17:48,540
module will use that information

00:17:45,930 --> 00:17:52,370
combined with the fact that it's that

00:17:48,540 --> 00:17:55,710
hook and say I'm gonna make this

00:17:52,370 --> 00:17:58,080
decision this way yes or no you can also

00:17:55,710 --> 00:18:01,260
use any of the other I don't information

00:17:58,080 --> 00:18:03,690
by the way in this case you could use

00:18:01,260 --> 00:18:05,820
that user IDs group IDs anything else is

00:18:03,690 --> 00:18:09,000
in the inode to decide whether to make

00:18:05,820 --> 00:18:11,090
the X control check as well but this is

00:18:09,000 --> 00:18:14,580
the basic model here's you've got a hook

00:18:11,090 --> 00:18:16,020
which is your bit of code you've got the

00:18:14,580 --> 00:18:19,980
security blob which is the information

00:18:16,020 --> 00:18:21,150
that you're maintaining about that and

00:18:19,980 --> 00:18:25,740
again you can put just about anything

00:18:21,150 --> 00:18:27,990
you want there so the first kind of

00:18:25,740 --> 00:18:30,180
hooks that are really important are

00:18:27,990 --> 00:18:33,870
access control hooks these are the hooks

00:18:30,180 --> 00:18:36,570
we actually make decisions generally

00:18:33,870 --> 00:18:38,640
these are passed as past relevant

00:18:36,570 --> 00:18:42,300
security pointers which will have blobs

00:18:38,640 --> 00:18:44,940
hung off usually they're in the current

00:18:42,300 --> 00:18:47,690
context not of course always because

00:18:44,940 --> 00:18:47,690
that would be too easy

00:18:53,770 --> 00:19:01,870
okay so you don't have to have yeah yeah

00:18:59,770 --> 00:19:06,970
Stephens laughing at me that's that's

00:19:01,870 --> 00:19:10,630
just fine usually okay so you don't have

00:19:06,970 --> 00:19:11,950
to use all the LSM hooks you only have

00:19:10,630 --> 00:19:13,300
to supply those that actually are

00:19:11,950 --> 00:19:14,110
relevant to what you're trying to

00:19:13,300 --> 00:19:16,450
accomplish

00:19:14,110 --> 00:19:17,770
so if you're not looking at file system

00:19:16,450 --> 00:19:19,870
objects if you're only looking at

00:19:17,770 --> 00:19:22,060
network packets for example you don't

00:19:19,870 --> 00:19:23,680
have to use any of the any of the inode

00:19:22,060 --> 00:19:25,240
hooks if you're only looking at file

00:19:23,680 --> 00:19:27,070
system I don't have to use any of the

00:19:25,240 --> 00:19:28,840
networking hooks if you're only looking

00:19:27,070 --> 00:19:31,060
at system 5i PC you don't need

00:19:28,840 --> 00:19:32,890
networking hooks or I know it hooks you

00:19:31,060 --> 00:19:36,160
just need the ones that are relative to

00:19:32,890 --> 00:19:37,960
system 5i PC so you just need the hooks

00:19:36,160 --> 00:19:39,760
that you actually need you don't need to

00:19:37,960 --> 00:19:43,320
supply any of the others the system is

00:19:39,760 --> 00:19:47,640
just fine if you have a limited number

00:19:43,320 --> 00:19:53,860
and then they return the access decision

00:19:47,640 --> 00:19:56,020
so if you decide that if if for example

00:19:53,860 --> 00:19:58,360
your hook needs to allocate memory for

00:19:56,020 --> 00:20:02,050
some reason that fails you retain

00:19:58,360 --> 00:20:04,480
returns to that or you my reasons I say

00:20:02,050 --> 00:20:06,130
yes I like this return II access I don't

00:20:04,480 --> 00:20:09,850
like it return access yes I do return

00:20:06,130 --> 00:20:11,680
zero so the hooks are bail on fail which

00:20:09,850 --> 00:20:14,020
means that if you have a list of hooks

00:20:11,680 --> 00:20:17,050
and they're there they're kept in in a

00:20:14,020 --> 00:20:23,890
list the first error that's encountered

00:20:17,050 --> 00:20:26,110
is returned so just as the discretionary

00:20:23,890 --> 00:20:29,380
access control yeah the normal DAC

00:20:26,110 --> 00:20:32,380
checks are made first if they fail then

00:20:29,380 --> 00:20:34,330
you you never get called because it's

00:20:32,380 --> 00:20:36,220
already known that axis is gonna be

00:20:34,330 --> 00:20:38,260
denied if there's another security

00:20:36,220 --> 00:20:39,940
module ahead of you that's actually also

00:20:38,260 --> 00:20:41,920
making a check on that and it fails you

00:20:39,940 --> 00:20:44,740
don't get called but if everybody else

00:20:41,920 --> 00:20:47,620
ahead of you gets succeeds then you get

00:20:44,740 --> 00:20:51,760
called you say yay it's my turn and then

00:20:47,620 --> 00:20:53,710
you can can say I approve of this action

00:20:51,760 --> 00:20:55,660
or I don't and everybody's happy there

00:20:53,710 --> 00:20:58,960
and then it goes on to the next one if

00:20:55,660 --> 00:21:01,840
there is a next one so you have to be

00:20:58,960 --> 00:21:04,090
careful with the state engine because

00:21:01,840 --> 00:21:05,309
you have to realize that it's entirely

00:21:04,090 --> 00:21:08,840
possible

00:21:05,309 --> 00:21:12,269
that you won't get called even though

00:21:08,840 --> 00:21:14,669
you're at the point yeah I know

00:21:12,269 --> 00:21:16,169
permission gets called your security

00:21:14,669 --> 00:21:17,909
module and they never may never get

00:21:16,169 --> 00:21:20,580
called because something may may be

00:21:17,909 --> 00:21:22,049
denied ahead of you in the list so it's

00:21:20,580 --> 00:21:24,330
just a matter of State engines need to

00:21:22,049 --> 00:21:30,149
be aware of that we also have state

00:21:24,330 --> 00:21:32,999
maintenance hooks and these are used to

00:21:30,149 --> 00:21:36,259
keep the security blobs and other

00:21:32,999 --> 00:21:39,539
securities and other state consistent so

00:21:36,259 --> 00:21:41,399
for example when a file is out is opened

00:21:39,539 --> 00:21:44,429
the first time and I know it is

00:21:41,399 --> 00:21:46,320
allocated a hook is called so that the

00:21:44,429 --> 00:21:49,169
security blow the security module can

00:21:46,320 --> 00:21:58,710
allocate its blob or initialize it in

00:21:49,169 --> 00:22:03,690
the modern case sometimes call calls are

00:21:58,710 --> 00:22:05,340
made with for example if you exact a

00:22:03,690 --> 00:22:07,320
program you're going to have to change

00:22:05,340 --> 00:22:09,659
the credential you may have to change

00:22:07,320 --> 00:22:11,610
the credential in which case you need to

00:22:09,659 --> 00:22:15,029
maintain you know do some maintenance on

00:22:11,610 --> 00:22:17,039
the credential also when an inode goes

00:22:15,029 --> 00:22:19,889
away you need to tear down or free the

00:22:17,039 --> 00:22:23,970
information that's available there and

00:22:19,889 --> 00:22:27,059
we also have hooks for mapping between

00:22:23,970 --> 00:22:28,799
set contexts second security contexts

00:22:27,059 --> 00:22:31,139
and security IDs which I'll talk about

00:22:28,799 --> 00:22:32,029
in a later slide which is in the wrong

00:22:31,139 --> 00:22:35,519
order

00:22:32,029 --> 00:22:38,940
alright so access control can return

00:22:35,519 --> 00:22:41,249
values in general these are the only

00:22:38,940 --> 00:22:46,379
four values that they should should

00:22:41,249 --> 00:22:47,669
return there are exceptions but on the

00:22:46,379 --> 00:22:49,740
whole they should either return zero

00:22:47,669 --> 00:22:53,519
they if they're happy and every and they

00:22:49,740 --> 00:22:58,049
want to allow the access you know mem is

00:22:53,519 --> 00:22:59,669
kind of one of those Bane's of the C

00:22:58,049 --> 00:23:02,610
runtime environment where you have to

00:22:59,669 --> 00:23:05,610
allocate memory explicitly and you can't

00:23:02,610 --> 00:23:08,549
be guaranteed that it will succeed he

00:23:05,610 --> 00:23:13,049
access says no you I don't want you to

00:23:08,549 --> 00:23:16,129
do this an e perm is you needed to have

00:23:13,049 --> 00:23:19,140
privilege to do this and you didn't

00:23:16,129 --> 00:23:24,179
people often get exs and

00:23:19,140 --> 00:23:26,460
confused but three out but it's actually

00:23:24,179 --> 00:23:31,679
pretty simple it's like I am denying you

00:23:26,460 --> 00:23:33,420
access based on my policy eeper MS no

00:23:31,679 --> 00:23:35,130
one should be able to do that why did

00:23:33,420 --> 00:23:39,360
you ask to do that oh and you didn't

00:23:35,130 --> 00:23:46,170
have cap sysadmin okay that's that's the

00:23:39,360 --> 00:23:49,700
distinction there security blobs let's

00:23:46,170 --> 00:23:51,960
talk some about security blobs a

00:23:49,700 --> 00:23:55,620
security blob is just a chunk of

00:23:51,960 --> 00:23:57,419
information the kernel outside of your

00:23:55,620 --> 00:23:59,520
security module doesn't care about

00:23:57,419 --> 00:24:01,230
what's in the blob you care about what's

00:23:59,520 --> 00:24:03,150
in the blob you can put anything you

00:24:01,230 --> 00:24:06,179
essentially anything you want in you

00:24:03,150 --> 00:24:09,919
know blah so they're referenced by

00:24:06,179 --> 00:24:13,710
criminal data structures so for okay so

00:24:09,919 --> 00:24:17,910
Dan that's on the next slide they're

00:24:13,710 --> 00:24:18,929
managed by the infrastructure mostly not

00:24:17,910 --> 00:24:20,520
all of them are managed by the

00:24:18,929 --> 00:24:25,110
infrastructure but we're getting pretty

00:24:20,520 --> 00:24:27,570
close to that and so what that means is

00:24:25,110 --> 00:24:30,360
the infrastructure will allocate it tell

00:24:27,570 --> 00:24:34,710
you where it is and you can then

00:24:30,360 --> 00:24:36,299
manipulate it as you like there are a

00:24:34,710 --> 00:24:39,150
few cases where the modules are actually

00:24:36,299 --> 00:24:40,580
required to maintain to do the

00:24:39,150 --> 00:24:43,679
allocation and freeing of these

00:24:40,580 --> 00:24:45,570
explicitly we're in a transition state

00:24:43,679 --> 00:24:47,490
where we used to do it all where the

00:24:45,570 --> 00:24:48,630
modules did all the allocation of blobs

00:24:47,490 --> 00:24:50,040
but now we're making it so the

00:24:48,630 --> 00:24:55,309
infrastructure doesn't so you can have

00:24:50,040 --> 00:24:58,860
more than one module at a time as a 5.3

00:24:55,309 --> 00:25:03,179
the infrastructure man managed ones who

00:24:58,860 --> 00:25:06,360
are actually most of them and the ones

00:25:03,179 --> 00:25:08,040
that are module managed are ones that we

00:25:06,360 --> 00:25:11,250
haven't actually hit a conflict on yet

00:25:08,040 --> 00:25:13,980
but we will be soon most of what you'll

00:25:11,250 --> 00:25:16,260
be doing with most security modules are

00:25:13,980 --> 00:25:18,059
on the the infrastructure managed ones

00:25:16,260 --> 00:25:23,700
so you should be should actually be

00:25:18,059 --> 00:25:25,650
pretty happy there okay as I said yet

00:25:23,700 --> 00:25:27,030
there the infrastructure managed blobs

00:25:25,650 --> 00:25:28,140
or their allocated and freed by the

00:25:27,030 --> 00:25:29,490
infrastructure so you don't have to

00:25:28,140 --> 00:25:31,679
worry about it if you have a linked list

00:25:29,490 --> 00:25:32,269
inside your security blob yeah you're

00:25:31,679 --> 00:25:36,559
going to have to

00:25:32,269 --> 00:25:38,059
manage that yourself when you set up

00:25:36,559 --> 00:25:39,229
your security module when you register

00:25:38,059 --> 00:25:41,059
it with the system you're going to tell

00:25:39,229 --> 00:25:48,769
it how much space you need for each of

00:25:41,059 --> 00:25:49,999
your blobs and then when you register

00:25:48,769 --> 00:25:52,369
it's going to tell you where the offset

00:25:49,999 --> 00:25:55,219
is so that's a little bit of DJ so a

00:25:52,369 --> 00:25:57,499
little bit of detail on that when you

00:25:55,219 --> 00:25:59,479
want to we said we're gonna tell you how

00:25:57,499 --> 00:26:00,950
to write a security module here we're

00:25:59,479 --> 00:26:02,509
not gonna hit every detail but we're

00:26:00,950 --> 00:26:06,889
gonna hit some of them pretty pretty

00:26:02,509 --> 00:26:10,549
hard so module details when you want to

00:26:06,889 --> 00:26:12,079
define in LSM you have to tell it a few

00:26:10,549 --> 00:26:15,009
things you have to tell it it's tyll

00:26:12,079 --> 00:26:18,889
tyll tyll it is tell everybody its name

00:26:15,009 --> 00:26:21,619
here we're calling it sample you have to

00:26:18,889 --> 00:26:24,169
tell it where your blob sizes are and so

00:26:21,619 --> 00:26:26,839
we have a structure for that and you

00:26:24,169 --> 00:26:28,190
have to say the name of the function

00:26:26,839 --> 00:26:30,440
that you're going to use to initialize

00:26:28,190 --> 00:26:34,820
it this is so you can all can register

00:26:30,440 --> 00:26:37,339
at all the flags in a lot of cases you

00:26:34,820 --> 00:26:40,669
won't need any of them but the two flags

00:26:37,339 --> 00:26:44,419
we have our legacy major which means

00:26:40,669 --> 00:26:47,389
that on the boot line if you say

00:26:44,419 --> 00:26:49,399
security equals this security module

00:26:47,389 --> 00:26:52,909
you'll get that one and none of the

00:26:49,399 --> 00:26:56,299
other legacy legacy major modules and if

00:26:52,909 --> 00:27:01,029
you exclusive that means that you're

00:26:56,299 --> 00:27:04,969
using security blobs that are not

00:27:01,029 --> 00:27:07,549
infrastructure managed and so you can't

00:27:04,969 --> 00:27:08,929
run two of those at once so only the

00:27:07,549 --> 00:27:12,739
first one of those that's registers is

00:27:08,929 --> 00:27:16,759
going to get back get used as we go

00:27:12,739 --> 00:27:18,349
further into this stacking notion that

00:27:16,759 --> 00:27:22,070
becomes less important but for now

00:27:18,349 --> 00:27:25,639
that's how you make sure that you don't

00:27:22,070 --> 00:27:28,639
conflict with anybody so when you want

00:27:25,639 --> 00:27:30,469
to set the blob sizes we have a

00:27:28,639 --> 00:27:36,469
structure here it's called believe it or

00:27:30,469 --> 00:27:38,119
not LSN blob sizes and you tell it for

00:27:36,469 --> 00:27:40,849
each of the blobs you use how much space

00:27:38,119 --> 00:27:44,119
you want and then when you register your

00:27:40,849 --> 00:27:45,830
module it will keep track of all the

00:27:44,119 --> 00:27:48,169
modules that are allocating blobs

00:27:45,830 --> 00:27:50,750
say alright you get this this much and

00:27:48,169 --> 00:27:55,299
then it refills this structure with the

00:27:50,750 --> 00:27:59,510
offsets so you say I want 45 45 bytes

00:27:55,299 --> 00:28:02,059
bad number I want 48 bytes and at the

00:27:59,510 --> 00:28:05,500
end of registration it'll put in here

00:28:02,059 --> 00:28:09,200
the offset of your 48 bytes in the in

00:28:05,500 --> 00:28:14,149
what's in the blob that's off of that

00:28:09,200 --> 00:28:15,740
particular kernel data structure often

00:28:14,149 --> 00:28:17,360
this will be 0 which is great because

00:28:15,740 --> 00:28:22,370
that means you're you're the only one

00:28:17,360 --> 00:28:26,179
there probably so we're gonna talk a

00:28:22,370 --> 00:28:28,639
little bit now about the blob the sec ID

00:28:26,179 --> 00:28:30,169
and the sec context oh yeah we're

00:28:28,639 --> 00:28:35,029
hitting hitting the detail here I didn't

00:28:30,169 --> 00:28:36,649
promise coherency with the blob security

00:28:35,029 --> 00:28:40,880
blob is just this chunk of data that

00:28:36,649 --> 00:28:42,260
you've got so conceptually you should be

00:28:40,880 --> 00:28:47,330
able to access that you should be able

00:28:42,260 --> 00:28:49,190
to to reference it so we have two ways

00:28:47,330 --> 00:28:53,720
to reference it the first one is the sec

00:28:49,190 --> 00:28:57,169
context the context is actually a name a

00:28:53,720 --> 00:29:00,679
character string that you your module

00:28:57,169 --> 00:29:05,179
uses to reference that particular set of

00:29:00,679 --> 00:29:09,010
data now the sec ID is a 32-bit number

00:29:05,179 --> 00:29:12,559
which references the same data but

00:29:09,010 --> 00:29:15,950
that's kept completely inside the kernel

00:29:12,559 --> 00:29:18,769
that is never exported there's one per

00:29:15,950 --> 00:29:20,120
sec context and they're volatile so you

00:29:18,769 --> 00:29:22,070
don't put that out on the disk and

00:29:20,120 --> 00:29:26,080
reboot the system and expect that to be

00:29:22,070 --> 00:29:31,460
meaningful if you're going to actually

00:29:26,080 --> 00:29:34,519
so the sec context is the thing that is

00:29:31,460 --> 00:29:36,529
actually the data and then the blob

00:29:34,519 --> 00:29:39,340
itself can have whatever you want linked

00:29:36,529 --> 00:29:43,940
list soft off into I know tables

00:29:39,340 --> 00:29:46,279
whatever okay so the lifecycle

00:29:43,940 --> 00:29:50,299
management of the sec context is kind of

00:29:46,279 --> 00:29:52,940
important because these are strings they

00:29:50,299 --> 00:29:55,990
show up in audit records probably the

00:29:52,940 --> 00:29:55,990
best example for them

00:29:56,670 --> 00:30:05,040
when you send one out when if you have a

00:30:01,610 --> 00:30:07,680
set context the sec ID or ii ii ii ii

00:30:05,040 --> 00:30:11,730
context in any of the LS m hooks that

00:30:07,680 --> 00:30:15,180
generates a set context that puts a

00:30:11,730 --> 00:30:17,070
string out into the rest of the kernel

00:30:15,180 --> 00:30:20,940
code so it can you so the audit system

00:30:17,070 --> 00:30:23,160
forum says oh i have a sec ID which i

00:30:20,940 --> 00:30:26,430
got from the i note of something so i've

00:30:23,160 --> 00:30:27,930
got that and i'm going to convert it to

00:30:26,430 --> 00:30:31,050
a string so i can print it out and then

00:30:27,930 --> 00:30:33,870
when i've got that well what do i do

00:30:31,050 --> 00:30:37,740
with it well then i release it and you

00:30:33,870 --> 00:30:40,980
do have to do a release because the

00:30:37,740 --> 00:30:42,690
different LSMs treat the allocation of

00:30:40,980 --> 00:30:44,610
these things differently selinux for

00:30:42,690 --> 00:30:47,540
example will always generate a new text

00:30:44,610 --> 00:30:51,690
string and pass you a pointer to it in

00:30:47,540 --> 00:30:55,020
for a sec context smack always has all

00:30:51,690 --> 00:30:57,120
of its label names in memory so it

00:30:55,020 --> 00:30:58,740
doesn't do that it simply returns you

00:30:57,120 --> 00:31:00,090
the pointer to it and says here here's

00:30:58,740 --> 00:31:03,680
this here's a string you're going to use

00:31:00,090 --> 00:31:07,350
so you when you release an SELinux

00:31:03,680 --> 00:31:10,050
context it does a que free when you

00:31:07,350 --> 00:31:13,550
release a smack context it says yep did

00:31:10,050 --> 00:31:17,220
that because there's nothing to release

00:31:13,550 --> 00:31:19,350
so it's important that callers up and

00:31:17,220 --> 00:31:22,130
that to note that callers will always

00:31:19,350 --> 00:31:24,990
use security release context or they

00:31:22,130 --> 00:31:26,910
people who try to do it otherwise get

00:31:24,990 --> 00:31:30,860
her anger other nationally by people

00:31:26,910 --> 00:31:35,940
like me because then LSM start breaking

00:31:30,860 --> 00:31:37,860
so process attributes processes have

00:31:35,940 --> 00:31:38,510
attributes they're really figured that

00:31:37,860 --> 00:31:41,720
one out

00:31:38,510 --> 00:31:41,720
okay good

00:31:42,320 --> 00:31:47,550
most important process attributes are

00:31:45,030 --> 00:31:52,710
credentials now credential is a shared

00:31:47,550 --> 00:31:54,510
thing so a number of processes a number

00:31:52,710 --> 00:31:57,480
of tasks will actually point to the same

00:31:54,510 --> 00:32:00,630
credential this is done for a number of

00:31:57,480 --> 00:32:04,740
reasons there copy-on-write so if you if

00:32:00,630 --> 00:32:06,150
the user ID changes on a process then

00:32:04,740 --> 00:32:09,730
you're just going to get a new

00:32:06,150 --> 00:32:10,960
credential if the smack label changes

00:32:09,730 --> 00:32:12,490
it's gonna get a new credential if the

00:32:10,960 --> 00:32:15,520
Atlantic context change is gonna

00:32:12,490 --> 00:32:18,310
continue credential so there's quite a

00:32:15,520 --> 00:32:21,490
bit of you can see quite a quite a

00:32:18,310 --> 00:32:26,170
number of things you have to do here to

00:32:21,490 --> 00:32:28,270
manage a credential but it's actually

00:32:26,170 --> 00:32:31,540
fairly straightforward you just have to

00:32:28,270 --> 00:32:35,050
realize that it's not that every process

00:32:31,540 --> 00:32:39,040
has its own potential this is where the

00:32:35,050 --> 00:32:40,990
credit security is actually where the

00:32:39,040 --> 00:32:42,790
information that you're going to add to

00:32:40,990 --> 00:32:44,170
your LSM is going to going to live

00:32:42,790 --> 00:32:46,420
that's where your security Bob's going

00:32:44,170 --> 00:32:47,920
to be and current cred security is

00:32:46,420 --> 00:32:50,350
actually used in a lot of cases because

00:32:47,920 --> 00:32:55,390
a lot of these again a lot of the hooks

00:32:50,350 --> 00:32:57,070
are done in the current context the

00:32:55,390 --> 00:32:59,760
important thing here is that a cred

00:32:57,070 --> 00:33:05,470
Prudential the credit blob has to be

00:32:59,760 --> 00:33:09,150
prepared when it gets duplicated has to

00:33:05,470 --> 00:33:11,620
be set how it set when it set when it's

00:33:09,150 --> 00:33:18,370
when it's duplicated and that happens in

00:33:11,620 --> 00:33:22,510
places other than within your LSM so a

00:33:18,370 --> 00:33:24,610
task we also have a security blob on

00:33:22,510 --> 00:33:26,050
tasks which are different from

00:33:24,610 --> 00:33:29,290
credentials in that there actually could

00:33:26,050 --> 00:33:33,220
actually information about this task and

00:33:29,290 --> 00:33:35,170
so you're not sharing that so you can

00:33:33,220 --> 00:33:37,840
have two tasks with the same credential

00:33:35,170 --> 00:33:40,390
that a lot different the same credential

00:33:37,840 --> 00:33:45,790
blob they will have different task blobs

00:33:40,390 --> 00:33:49,990
and again these are both infrastructure

00:33:45,790 --> 00:33:51,130
man managed credential blobs so you

00:33:49,990 --> 00:33:55,660
don't have to allocate them or

00:33:51,130 --> 00:33:58,870
deallocate them okay so if you want to

00:33:55,660 --> 00:34:00,430
see any of these things if you're

00:33:58,870 --> 00:34:01,720
outside the kernel and you say I would

00:34:00,430 --> 00:34:04,510
like very much to know what my

00:34:01,720 --> 00:34:08,910
credential blob what my security context

00:34:04,510 --> 00:34:14,800
of my process is we actually have

00:34:08,910 --> 00:34:17,020
interfaces in proc at in /proc the adder

00:34:14,800 --> 00:34:19,540
subdirectory or the adder sub

00:34:17,020 --> 00:34:23,140
subdirectory actually contains

00:34:19,540 --> 00:34:27,040
information about your process current

00:34:23,140 --> 00:34:31,780
is used by SELinux app Armour and smack

00:34:27,040 --> 00:34:35,050
today and it will tell you one of the

00:34:31,780 --> 00:34:38,230
three which of the three depends on

00:34:35,050 --> 00:34:41,790
which one is actually first in the stack

00:34:38,230 --> 00:34:46,750
and that's kind of a kind of a problem

00:34:41,790 --> 00:34:48,130
so moving forward we have mechanism we

00:34:46,750 --> 00:34:51,760
were adding subdirectories in adder

00:34:48,130 --> 00:34:54,520
smack is the first adopter on that app

00:34:51,760 --> 00:34:57,940
armor is actually moving away from slash

00:34:54,520 --> 00:34:59,140
procs assistant to success this FS is

00:34:57,940 --> 00:35:01,800
that correct

00:34:59,140 --> 00:35:06,370
no okay he'll tell you about whether

00:35:01,800 --> 00:35:10,990
you're moving away from okay they're

00:35:06,370 --> 00:35:13,390
doing a sub-directory - okay so if

00:35:10,990 --> 00:35:15,730
you're writing in LSM the important

00:35:13,390 --> 00:35:19,690
message here if you're writing in LSM

00:35:15,730 --> 00:35:22,630
use a subdirectory the mechanism self oh

00:35:19,690 --> 00:35:30,670
I see a question okay we can now have a

00:35:22,630 --> 00:35:33,670
best question by definition okay so the

00:35:30,670 --> 00:35:39,190
question is is proc adder only used by

00:35:33,670 --> 00:35:41,080
LS m so I believe it is and if you want

00:35:39,190 --> 00:35:43,050
to write a new LS m to present something

00:35:41,080 --> 00:35:45,910
new in proc at or that would be

00:35:43,050 --> 00:35:47,980
something you could do although there's

00:35:45,910 --> 00:35:50,260
nothing to restrict it to that you could

00:35:47,980 --> 00:35:54,510
use that for for other mechanism yeah

00:35:50,260 --> 00:35:54,510
for other things yeah

00:35:57,730 --> 00:36:02,890
one of the important things there only

00:35:59,650 --> 00:36:07,720
writable if the if the the process ID

00:36:02,890 --> 00:36:11,230
the pid' there is self so you can under

00:36:07,720 --> 00:36:14,520
some circumstances write to these files

00:36:11,230 --> 00:36:17,620
and change your process attributes

00:36:14,520 --> 00:36:20,860
provided the LS m involved allows you to

00:36:17,620 --> 00:36:23,980
do that but you can't write to anybody

00:36:20,860 --> 00:36:25,900
else's process using this mechanism you

00:36:23,980 --> 00:36:28,240
can however read the information for

00:36:25,900 --> 00:36:33,700
other processes provided the security

00:36:28,240 --> 00:36:35,950
modules allow that and important again

00:36:33,700 --> 00:36:38,770
these are defined in proc if s you can

00:36:35,950 --> 00:36:41,589
add them add them add them there and use

00:36:38,770 --> 00:36:48,309
a subdirectory because nobody wants to

00:36:41,589 --> 00:36:52,960
be confused when they read current was

00:36:48,309 --> 00:36:53,770
there a question current yeah proc self

00:36:52,960 --> 00:36:57,400
adder current

00:36:53,770 --> 00:36:59,079
yeah okay if you if you're on a smacks

00:36:57,400 --> 00:37:00,970
system you'll get one value from a

00:36:59,079 --> 00:37:03,309
ceiling system you'll get the SELinux

00:37:00,970 --> 00:37:08,650
value a parmer system you'll get the app

00:37:03,309 --> 00:37:11,500
armor value and your if you use a space

00:37:08,650 --> 00:37:17,079
code doesn't know which it is it could

00:37:11,500 --> 00:37:20,760
get very confused so now we're going to

00:37:17,079 --> 00:37:23,410
talk about some of the object based or

00:37:20,760 --> 00:37:25,809
yeah the object based hooks right okay

00:37:23,410 --> 00:37:30,400
so object based hooks that are

00:37:25,809 --> 00:37:31,839
affiliated with kernel objects now how

00:37:30,400 --> 00:37:35,589
many of you are familiar with subject

00:37:31,839 --> 00:37:43,030
object models is there anybody who isn't

00:37:35,589 --> 00:37:45,490
oh good good good education time so a

00:37:43,030 --> 00:37:46,660
kernel object in a subject object model

00:37:45,490 --> 00:37:47,890
you have subjects which are the active

00:37:46,660 --> 00:37:51,339
entities and objects which are the

00:37:47,890 --> 00:37:52,270
passive entities so the objects per

00:37:51,339 --> 00:37:56,230
second right here are the passive

00:37:52,270 --> 00:37:59,770
entities and the definitions are very

00:37:56,230 --> 00:38:02,079
dependent on what quantifies what

00:37:59,770 --> 00:38:05,170
qualifies as an object varies depending

00:38:02,079 --> 00:38:07,240
on who you talk to but there but so

00:38:05,170 --> 00:38:08,890
object hooks are based are filly aging

00:38:07,240 --> 00:38:14,410
with kernel objects things like files

00:38:08,890 --> 00:38:16,569
IPC objects access is based on

00:38:14,410 --> 00:38:19,869
attributes that are attached to the

00:38:16,569 --> 00:38:22,690
objects so if you want to access a file

00:38:19,869 --> 00:38:24,940
the information off the inode if you

00:38:22,690 --> 00:38:26,710
want to access something that's file

00:38:24,940 --> 00:38:29,380
descriptor based you want to do it off

00:38:26,710 --> 00:38:32,470
the file structure if it's an IPC object

00:38:29,380 --> 00:38:35,980
it's the IPC perm structure so it's all

00:38:32,470 --> 00:38:38,170
about things that are hooked up hooked

00:38:35,980 --> 00:38:44,740
up to the object attributes of the

00:38:38,170 --> 00:38:46,510
object and the the downside on this is

00:38:44,740 --> 00:38:48,820
these things can be hard to

00:38:46,510 --> 00:38:51,460
humans to identify if for example you

00:38:48,820 --> 00:38:56,590
have a file somebody opens it it gets

00:38:51,460 --> 00:38:58,930
unlinked what's the name of it the name

00:38:56,590 --> 00:39:02,109
is actually the inode number which is

00:38:58,930 --> 00:39:05,650
still there and the device it's on which

00:39:02,109 --> 00:39:06,910
is yet the true name but that does

00:39:05,650 --> 00:39:08,590
that's not really helpful for most

00:39:06,910 --> 00:39:11,550
people most people say I just want to

00:39:08,590 --> 00:39:14,350
know what the file name was on it but

00:39:11,550 --> 00:39:16,330
you don't have that because you're just

00:39:14,350 --> 00:39:18,340
dealing with the the real object down at

00:39:16,330 --> 00:39:24,640
the bottom which again doesn't have the

00:39:18,340 --> 00:39:28,240
name so object attributes in information

00:39:24,640 --> 00:39:30,910
about think for an inode you have the

00:39:28,240 --> 00:39:33,160
file system object information you have

00:39:30,910 --> 00:39:34,780
the info in this again this the blobs

00:39:33,160 --> 00:39:36,010
infrastructure managed so if you're

00:39:34,780 --> 00:39:38,140
writing a module you don't have to

00:39:36,010 --> 00:39:40,240
allocate that it'll get allocated for

00:39:38,140 --> 00:39:44,170
you we have traditional attributes like

00:39:40,240 --> 00:39:47,020
user IDs and you have extended

00:39:44,170 --> 00:39:50,740
attributes which are attributes that

00:39:47,020 --> 00:39:53,800
you've decided to add things like smack

00:39:50,740 --> 00:39:55,390
labels SELinux contexts all kinds of

00:39:53,800 --> 00:39:56,619
things that you can add you can add it

00:39:55,390 --> 00:39:57,940
essentially anything you want with an

00:39:56,619 --> 00:40:01,050
extended attribute which we'll get to in

00:39:57,940 --> 00:40:07,300
a second we also have a file structure

00:40:01,050 --> 00:40:09,070
and these are also this is information

00:40:07,300 --> 00:40:14,109
it's relative to the file descriptor

00:40:09,070 --> 00:40:15,640
rather than then the inode it includes

00:40:14,109 --> 00:40:19,210
the animal and inode pointer thank

00:40:15,640 --> 00:40:20,560
heavens infrastructure managed and you

00:40:19,210 --> 00:40:23,710
can get at the traditional attributes

00:40:20,560 --> 00:40:25,150
and the extended attributes as well so

00:40:23,710 --> 00:40:26,680
you can actually use this and you also

00:40:25,150 --> 00:40:30,040
get a little bit more information about

00:40:26,680 --> 00:40:33,550
the open state of the file so you can

00:40:30,040 --> 00:40:35,560
use that there use that there so

00:40:33,550 --> 00:40:38,320
traditional files security attributes

00:40:35,560 --> 00:40:40,300
again you can use these at will so you

00:40:38,320 --> 00:40:43,420
can use the user IDs you can use the

00:40:40,300 --> 00:40:45,130
access modes use the file types can say

00:40:43,420 --> 00:40:47,830
yeah I don't want people to be able to

00:40:45,130 --> 00:40:51,400
read symlinks I hate symlinks you can

00:40:47,830 --> 00:40:54,760
say oh look this file has has a link

00:40:51,400 --> 00:40:56,720
count of more than two well that means

00:40:54,760 --> 00:40:59,530
it's on it's dangerous so

00:40:56,720 --> 00:41:03,290
I'm not gonna allow allow anybody to

00:40:59,530 --> 00:41:06,500
anybody to use it one of the more

00:41:03,290 --> 00:41:09,290
interesting aspects here are locks locks

00:41:06,500 --> 00:41:12,369
are hard yeah if you want to write in

00:41:09,290 --> 00:41:15,980
Ellison that does the the deals with

00:41:12,369 --> 00:41:17,570
filesystem locking I would recommend

00:41:15,980 --> 00:41:21,200
that you think really hard about it

00:41:17,570 --> 00:41:24,470
because locks have different semantics

00:41:21,200 --> 00:41:25,940
as far as accessibility than just about

00:41:24,470 --> 00:41:27,980
anything else you can say the read lock

00:41:25,940 --> 00:41:31,900
on a file you don't have access have

00:41:27,980 --> 00:41:35,960
write access to that's always funny and

00:41:31,900 --> 00:41:40,220
the other thing is yeah don't overload

00:41:35,960 --> 00:41:45,530
the attributes don't say on my LS m user

00:41:40,220 --> 00:41:47,900
IDs are going to be used to describe the

00:41:45,530 --> 00:41:49,820
time based access control I'm not going

00:41:47,900 --> 00:41:51,320
to use them to differentiate users

00:41:49,820 --> 00:41:53,450
anymore

00:41:51,320 --> 00:41:55,849
there's a famous system did that and

00:41:53,450 --> 00:41:58,190
then well we're a single user system so

00:41:55,849 --> 00:42:01,070
we're just going to co-opt these

00:41:58,190 --> 00:42:03,619
varieties and use them for for other

00:42:01,070 --> 00:42:05,839
purposes and then somebody said hey this

00:42:03,619 --> 00:42:09,339
is a great device we love it can we

00:42:05,839 --> 00:42:12,050
please have multiple users on them and

00:42:09,339 --> 00:42:14,839
the developers because that meant they

00:42:12,050 --> 00:42:16,760
had to implement profiles on top of

00:42:14,839 --> 00:42:21,320
their system instead of having multiple

00:42:16,760 --> 00:42:23,869
users that's a bad a bad bad idea there

00:42:21,320 --> 00:42:25,400
there was also another back in the UNIX

00:42:23,869 --> 00:42:27,230
days there was a system that implemented

00:42:25,400 --> 00:42:30,080
mentis or access control by stealing the

00:42:27,230 --> 00:42:31,910
groups nobody uses groups so we're gonna

00:42:30,080 --> 00:42:34,910
make the group be the the mandatory

00:42:31,910 --> 00:42:36,619
access control label that was good fun

00:42:34,910 --> 00:42:40,790
they changed the semantics of groups and

00:42:36,619 --> 00:42:44,420
it and led to tiers so extended

00:42:40,790 --> 00:42:46,369
attributes we have two we have four

00:42:44,420 --> 00:42:50,240
kinds of extended attributes on Linux

00:42:46,369 --> 00:42:53,060
how many people knew that for that there

00:42:50,240 --> 00:43:00,800
are four okay how many people knew that

00:42:53,060 --> 00:43:03,740
we actually only use two okay good we

00:43:00,800 --> 00:43:06,480
have user attributes which anybody can

00:43:03,740 --> 00:43:08,460
add to their files and

00:43:06,480 --> 00:43:11,700
the system doesn't care about these it's

00:43:08,460 --> 00:43:13,500
just a bit of information you can put on

00:43:11,700 --> 00:43:15,450
the original purpose of these was

00:43:13,500 --> 00:43:18,690
actually what kind of icon you would

00:43:15,450 --> 00:43:23,010
display when the when the the GUI

00:43:18,690 --> 00:43:25,079
was was running and you wanted to do an

00:43:23,010 --> 00:43:28,799
LS equivalent oh look I can put put the

00:43:25,079 --> 00:43:32,430
little little gift out there it shows me

00:43:28,799 --> 00:43:34,829
what kind of file it is there's the

00:43:32,430 --> 00:43:37,200
security attributes okay the security

00:43:34,829 --> 00:43:39,839
attributes are actually used by the LSMs

00:43:37,200 --> 00:43:43,349
and actually supported throughout the

00:43:39,839 --> 00:43:47,460
system and these are only used by the by

00:43:43,349 --> 00:43:49,559
the LSMs by the way so you said the the

00:43:47,460 --> 00:43:51,299
LS m is in complete control of who can

00:43:49,559 --> 00:43:55,410
access these and under what

00:43:51,299 --> 00:43:57,000
circumstances we have system we also

00:43:55,410 --> 00:43:59,640
have system attributes and trusted

00:43:57,000 --> 00:44:01,290
attributes neither of which are used but

00:43:59,640 --> 00:44:03,359
it seemed a good idea at the time when

00:44:01,290 --> 00:44:06,180
the system was when the extended

00:44:03,359 --> 00:44:07,740
attribute system was being put in so

00:44:06,180 --> 00:44:10,619
they're maintained by file systems not

00:44:07,740 --> 00:44:12,799
all file systems support them not all

00:44:10,619 --> 00:44:15,510
file systems support them the same way

00:44:12,799 --> 00:44:18,990
some file systems have severe

00:44:15,510 --> 00:44:22,859
limitations on them others you can have

00:44:18,990 --> 00:44:27,510
as security you can have attributes that

00:44:22,859 --> 00:44:30,900
are as big as the file it's a matter

00:44:27,510 --> 00:44:33,450
okay it's an implementation detail most

00:44:30,900 --> 00:44:37,440
file systems most reasonable file

00:44:33,450 --> 00:44:40,500
systems support them and if you want

00:44:37,440 --> 00:44:42,599
your LSM to deal with file systems that

00:44:40,500 --> 00:44:48,059
don't support extended attributes that's

00:44:42,599 --> 00:44:50,130
up to you so system v IPC objects and

00:44:48,059 --> 00:44:57,299
keys we're just going to talk about just

00:44:50,130 --> 00:44:59,940
ever so briefly what they have they have

00:44:57,299 --> 00:45:02,579
their own namespace for the objects when

00:44:59,940 --> 00:45:05,460
you allocate one of these things it

00:45:02,579 --> 00:45:08,549
creates its own internal data they

00:45:05,460 --> 00:45:11,040
actually have security blobs associated

00:45:08,549 --> 00:45:13,440
with them as well you can actually do

00:45:11,040 --> 00:45:15,990
whatever policy you want you want on

00:45:13,440 --> 00:45:17,670
these they're not yeah they're not files

00:45:15,990 --> 00:45:20,230
the namespace you can't use the file

00:45:17,670 --> 00:45:23,200
system semantics on the no I nodes

00:45:20,230 --> 00:45:25,960
but we do have blobs on those it's just

00:45:23,200 --> 00:45:32,410
another area where you have you have to

00:45:25,960 --> 00:45:35,950
do special work to make them work so at

00:45:32,410 --> 00:45:39,039
this point I'm going to vote in invoke

00:45:35,950 --> 00:45:41,019
my very first guest speaker we're gonna

00:45:39,039 --> 00:45:42,759
have John Johansson who is the app armor

00:45:41,019 --> 00:45:44,859
maintainer he's going to talk about path

00:45:42,759 --> 00:45:47,829
hooks because path based hooks are

00:45:44,859 --> 00:46:06,039
really interesting and he's the only one

00:45:47,829 --> 00:46:13,089
who knows how they work so with the path

00:46:06,039 --> 00:46:14,920
based tux there's a there's a config

00:46:13,089 --> 00:46:17,109
that you have to enable in the kernel to

00:46:14,920 --> 00:46:21,460
use them they're not there by default

00:46:17,109 --> 00:46:26,589
with just security LSM hooks this is the

00:46:21,460 --> 00:46:28,450
list of hooks they're not sufficient if

00:46:26,589 --> 00:46:30,190
you're gonna use them there's there's

00:46:28,450 --> 00:46:32,529
cases you can use them and for sure and

00:46:30,190 --> 00:46:34,930
and you'll get the information from them

00:46:32,529 --> 00:46:37,589
but they are not sufficient in of

00:46:34,930 --> 00:46:40,420
themselves you're gonna have to be doing

00:46:37,589 --> 00:46:43,059
other stuff in this LSM they don't

00:46:40,420 --> 00:46:45,579
mediate every file access it's it's at

00:46:43,059 --> 00:46:47,859
the system or this is called level not

00:46:45,579 --> 00:46:50,559
exactly it's this call but there is

00:46:47,859 --> 00:46:52,930
kernel accesses that will access files

00:46:50,559 --> 00:46:54,269
that bypass them they don't they don't

00:46:52,930 --> 00:46:58,029
pick those up

00:46:54,269 --> 00:46:59,140
they don't mediate open files so you're

00:46:58,029 --> 00:47:01,329
gonna have to use some of the other

00:46:59,140 --> 00:47:02,730
hooks some of those are like there's

00:47:01,329 --> 00:47:06,369
there's file hooks

00:47:02,730 --> 00:47:08,680
there's inode hooks mount hooks are

00:47:06,369 --> 00:47:11,140
really important when you're talking

00:47:08,680 --> 00:47:15,940
about file system path accesses because

00:47:11,140 --> 00:47:17,380
mounts can make aliases right so what do

00:47:15,940 --> 00:47:19,180
you get with a path the path hooks

00:47:17,380 --> 00:47:24,630
basically you're gonna get a struct path

00:47:19,180 --> 00:47:27,309
you don't get the file name directly and

00:47:24,630 --> 00:47:29,890
the file names even if you do get a file

00:47:27,309 --> 00:47:33,190
name which you don't they're not unique

00:47:29,890 --> 00:47:33,550
to the system right they're not a per

00:47:33,190 --> 00:47:35,860
object

00:47:33,550 --> 00:47:37,810
thing they can be alias depending on

00:47:35,860 --> 00:47:40,210
name spacing and everything else in

00:47:37,810 --> 00:47:43,150
there so what you do is you're gonna use

00:47:40,210 --> 00:47:45,490
some kernel mechanism kernel provides a

00:47:43,150 --> 00:47:48,880
couple denturri paths there's a reverse

00:47:45,490 --> 00:47:51,250
walk up to the mount sort of so it's

00:47:48,880 --> 00:47:53,200
just it's just on within the device

00:47:51,250 --> 00:47:55,270
right so you're just walking up a little

00:47:53,200 --> 00:47:57,220
bit you're not gonna find the full path

00:47:55,270 --> 00:47:59,800
that's in the system at the namespace

00:47:57,220 --> 00:48:01,840
and the D path does a reverse walk all

00:47:59,800 --> 00:48:03,550
the way up to the root of your your name

00:48:01,840 --> 00:48:06,580
space so you can reconstruct these paths

00:48:03,550 --> 00:48:07,840
that that are passed into the kernel so

00:48:06,580 --> 00:48:11,830
what happens with like I said these

00:48:07,840 --> 00:48:13,420
security hooks the the path hooks are at

00:48:11,830 --> 00:48:15,910
this kind of assist call level but it's

00:48:13,420 --> 00:48:17,680
after it's done the lookup right so the

00:48:15,910 --> 00:48:20,920
kernel has already walked and found the

00:48:17,680 --> 00:48:24,160
object and now we have the VFS mount and

00:48:20,920 --> 00:48:26,110
the dent tree for that object and now

00:48:24,160 --> 00:48:29,230
we're gonna walk back and reconstruct a

00:48:26,110 --> 00:48:32,410
path and it may actually not be the same

00:48:29,230 --> 00:48:38,400
path that the the lookup thought this is

00:48:32,410 --> 00:48:40,180
call used to get to this object because

00:48:38,400 --> 00:48:42,160
you can like I said you can have

00:48:40,180 --> 00:48:45,100
multiple paths to an object but also

00:48:42,160 --> 00:48:47,470
because you're the reverse lookup is

00:48:45,100 --> 00:48:50,170
going to take out two sim links so if

00:48:47,470 --> 00:48:52,510
you had a symlink in that path walk that

00:48:50,170 --> 00:48:54,810
the syscall did the reverse lookup

00:48:52,510 --> 00:48:57,130
doesn't see that sim link

00:48:54,810 --> 00:49:03,850
so those are things to consider with

00:48:57,130 --> 00:49:07,330
this the doing these D path calls it has

00:49:03,850 --> 00:49:10,240
locking on it so there's there's

00:49:07,330 --> 00:49:11,740
performance considerations everywhere

00:49:10,240 --> 00:49:14,890
you have a security path hook you can

00:49:11,740 --> 00:49:16,900
you can you can do these you can do the

00:49:14,890 --> 00:49:18,550
locking is okay to do that but it is

00:49:16,900 --> 00:49:20,230
something to consider so you you you

00:49:18,550 --> 00:49:22,420
might want to cache when you're using

00:49:20,230 --> 00:49:25,480
them and you also need a big buffer to

00:49:22,420 --> 00:49:27,850
look up the path name right if you have

00:49:25,480 --> 00:49:29,770
the dentary vsf well that's small but

00:49:27,850 --> 00:49:32,290
the path you don't know how long it's

00:49:29,770 --> 00:49:35,260
going to be and path names can be really

00:49:32,290 --> 00:49:36,600
huge and so you might be allocating a

00:49:35,260 --> 00:49:38,470
buffer every time you go in these

00:49:36,600 --> 00:49:39,880
ideally is what you want to do is you

00:49:38,470 --> 00:49:41,800
actually want some buffer that you have

00:49:39,880 --> 00:49:43,210
a working buffer that you don't have you

00:49:41,800 --> 00:49:45,930
can reuse you don't have to reallocate

00:49:43,210 --> 00:49:45,930
it all the time

00:49:46,350 --> 00:49:53,950
so aliases really are the big problem

00:49:50,050 --> 00:49:55,780
with using the path hooks you have

00:49:53,950 --> 00:49:58,330
symlinks you have hard links you have

00:49:55,780 --> 00:50:02,470
mounts to roots and namespaces all of

00:49:58,330 --> 00:50:04,720
them make aliases and so when you are

00:50:02,470 --> 00:50:06,070
looking at these you really have to

00:50:04,720 --> 00:50:08,140
think hard about your model and what

00:50:06,070 --> 00:50:09,730
you're trying to achieve now that

00:50:08,140 --> 00:50:12,600
doesn't say that doesn't mean you can't

00:50:09,730 --> 00:50:16,420
use these but you really have to think

00:50:12,600 --> 00:50:18,310
hard about it and I would caution you

00:50:16,420 --> 00:50:19,960
that you know you have to take these

00:50:18,310 --> 00:50:22,660
into consideration all of these and some

00:50:19,960 --> 00:50:24,640
of these are really hard problems sim

00:50:22,660 --> 00:50:28,510
links are actually the easiest because

00:50:24,640 --> 00:50:30,490
like I said the path hooks actually the

00:50:28,510 --> 00:50:32,250
kernel lookup resolves that first and

00:50:30,490 --> 00:50:37,510
then you don't actually see the sim link

00:50:32,250 --> 00:50:39,040
not on the reverse walk anyways so you

00:50:37,510 --> 00:50:40,810
don't have to worry about the alias the

00:50:39,040 --> 00:50:42,570
sim link is taking there as long as

00:50:40,810 --> 00:50:45,580
you're treating it as a separate object

00:50:42,570 --> 00:50:47,770
so you treat it as two objects you seem

00:50:45,580 --> 00:50:49,990
like sim link object so you'll mediate a

00:50:47,770 --> 00:50:51,850
symlink creation of the sim link maybe

00:50:49,990 --> 00:50:55,210
what's put being put in the single sim

00:50:51,850 --> 00:50:58,750
link there is a hook to mediate walking

00:50:55,210 --> 00:51:00,280
or following some links you don't get

00:50:58,750 --> 00:51:02,770
the full path you just going to get an

00:51:00,280 --> 00:51:04,390
inode entry with that but you can do

00:51:02,770 --> 00:51:08,620
some stuff with that as long as you're

00:51:04,390 --> 00:51:10,060
working with multiple hook types and

00:51:08,620 --> 00:51:12,160
then you have the target and what you're

00:51:10,060 --> 00:51:13,750
really doing is you're mediating if

00:51:12,160 --> 00:51:19,060
you're doing deep path they're mediating

00:51:13,750 --> 00:51:22,540
posts and link resolution hard links

00:51:19,060 --> 00:51:24,190
these are a lot harder they're a

00:51:22,540 --> 00:51:26,170
permanent alias right there's their

00:51:24,190 --> 00:51:27,520
store on the file system you need to

00:51:26,170 --> 00:51:29,610
really think about these now you can

00:51:27,520 --> 00:51:32,230
find that you have a link count on these

00:51:29,610 --> 00:51:34,120
you know I've got a link count of two so

00:51:32,230 --> 00:51:38,320
I know that this is a hard linked file

00:51:34,120 --> 00:51:40,810
but the system doesn't store well what

00:51:38,320 --> 00:51:42,790
the aliases are in the link you know

00:51:40,810 --> 00:51:46,750
it's potentially possible you could do

00:51:42,790 --> 00:51:49,840
that yourself in your security exit or

00:51:46,750 --> 00:51:53,200
attribute or something you have to

00:51:49,840 --> 00:51:54,400
figure this out you also have to figure

00:51:53,200 --> 00:51:56,260
out what your threat model is here

00:51:54,400 --> 00:51:58,510
because with hard links because there

00:51:56,260 --> 00:51:59,710
are permanent alias you know are you

00:51:58,510 --> 00:52:01,839
only worrying about

00:51:59,710 --> 00:52:04,119
something being an online attack so I

00:52:01,839 --> 00:52:07,420
could prevent the hard links from being

00:52:04,119 --> 00:52:09,250
created or am I worried also about

00:52:07,420 --> 00:52:11,020
somebody coming along offline attack and

00:52:09,250 --> 00:52:13,420
changing the file system adding hard

00:52:11,020 --> 00:52:17,890
links and then a that alias is there and

00:52:13,420 --> 00:52:19,059
I I don't can't deal with it right when

00:52:17,890 --> 00:52:21,940
you're when you're dealing with these

00:52:19,059 --> 00:52:24,010
aliases you have to think about if I

00:52:21,940 --> 00:52:26,349
create this link this alias and if I'm

00:52:24,010 --> 00:52:28,359
mediating based on these does you know

00:52:26,349 --> 00:52:31,270
does it create the does it expand the

00:52:28,359 --> 00:52:33,640
permission set for this task or also

00:52:31,270 --> 00:52:35,290
potentially does it expand it for any

00:52:33,640 --> 00:52:37,240
other task or any other part of the

00:52:35,290 --> 00:52:40,030
system and that's where the aliases are

00:52:37,240 --> 00:52:42,040
really dangerous and you have to come up

00:52:40,030 --> 00:52:46,359
with a way to deal with this in your

00:52:42,040 --> 00:52:48,670
model and or very least say that this

00:52:46,359 --> 00:52:50,619
really doesn't matter to my model you

00:52:48,670 --> 00:52:52,869
have to you have to think about it

00:52:50,619 --> 00:52:56,800
mount's they have basically all the same

00:52:52,869 --> 00:53:00,490
issues as hard links except for their

00:52:56,800 --> 00:53:01,960
run time only they're not going to be

00:53:00,490 --> 00:53:05,109
stored well I mean you you have your

00:53:01,960 --> 00:53:07,690
mount T at tabs and stuff but it's not

00:53:05,109 --> 00:53:10,839
an object in the system type thing that

00:53:07,690 --> 00:53:12,309
where it's stored and you can again

00:53:10,839 --> 00:53:14,140
those mounts are made every time you

00:53:12,309 --> 00:53:16,000
boot up so you if you're in there from

00:53:14,140 --> 00:53:19,569
the start you can do things mediate

00:53:16,000 --> 00:53:22,089
mounts to to help mitigate aliases and

00:53:19,569 --> 00:53:23,920
you really do want to be mediating

00:53:22,089 --> 00:53:25,869
balance if you're looking at the path

00:53:23,920 --> 00:53:28,089
names and doing any kind of mediation

00:53:25,869 --> 00:53:31,270
based off of them

00:53:28,089 --> 00:53:32,589
sure routes turns out to routes can be

00:53:31,270 --> 00:53:36,190
bad depending on how you want to use

00:53:32,589 --> 00:53:38,950
them but the system does provide a the

00:53:36,190 --> 00:53:42,040
absolute path which is a variant of D

00:53:38,950 --> 00:53:46,720
path and it will walk past the chroot

00:53:42,040 --> 00:53:48,400
back up to actual namespace route so it

00:53:46,720 --> 00:53:50,200
is one way you can deal with two routes

00:53:48,400 --> 00:53:51,849
without having to put in any extra a

00:53:50,200 --> 00:53:55,480
whole bunch of effort to deal with

00:53:51,849 --> 00:53:59,410
aliases the real killer though is mount

00:53:55,480 --> 00:54:01,809
namespaces there is no mount hierarchy

00:53:59,410 --> 00:54:03,670
with mount namespaces there's there's

00:54:01,809 --> 00:54:05,740
they're just flat they can be anywhere

00:54:03,670 --> 00:54:07,390
they can be disassociated from each

00:54:05,740 --> 00:54:09,790
other they can share

00:54:07,390 --> 00:54:10,960
there is no mapping your and have to do

00:54:09,790 --> 00:54:14,100
figure out how you're gonna deal with

00:54:10,960 --> 00:54:16,720
these or how it applies to your model

00:54:14,100 --> 00:54:20,550
different objects in the same for the

00:54:16,720 --> 00:54:24,040
same path that you know same location

00:54:20,550 --> 00:54:27,730
and then you have the issue where you

00:54:24,040 --> 00:54:29,500
will get files you will get requests not

00:54:27,730 --> 00:54:31,060
in the path hook itself but when you're

00:54:29,500 --> 00:54:33,310
trying to deal with stuff at the path

00:54:31,060 --> 00:54:34,510
level coming through the file hooks if

00:54:33,310 --> 00:54:35,740
you're working with the file hooks

00:54:34,510 --> 00:54:37,570
because you're working with those in

00:54:35,740 --> 00:54:40,240
conjunction with the Pathak's where

00:54:37,570 --> 00:54:43,660
these objects don't exist in your mount

00:54:40,240 --> 00:54:46,510
namespace so you have to know how you're

00:54:43,660 --> 00:54:49,240
going to deal with those you can figure

00:54:46,510 --> 00:54:51,460
out whether an object is in your mount

00:54:49,240 --> 00:54:55,780
namespace by using another call called

00:54:51,460 --> 00:54:57,340
our mount and then you're gonna have to

00:54:55,780 --> 00:54:59,410
figure out from there what you're gonna

00:54:57,340 --> 00:55:04,810
do for these objects that aren't in your

00:54:59,410 --> 00:55:08,530
your path mediations things like

00:55:04,810 --> 00:55:10,890
delegation models would work all right

00:55:08,530 --> 00:55:10,890
Paul

00:55:21,600 --> 00:55:25,380
let's cut this fancy little clicker

00:55:23,400 --> 00:55:27,600
which means I'm gonna screw something up

00:55:25,380 --> 00:55:29,820
so patience please

00:55:27,600 --> 00:55:32,970
anyway so the networking access looks

00:55:29,820 --> 00:55:35,520
there's basically two levels of hooks

00:55:32,970 --> 00:55:38,280
the one first one the easiest one to use

00:55:35,520 --> 00:55:40,740
socket level hooks these map very well

00:55:38,280 --> 00:55:42,660
to the socket related system calls you

00:55:40,740 --> 00:55:45,530
know we have hooks for you know doing a

00:55:42,660 --> 00:55:48,420
bind operation doing it connect

00:55:45,530 --> 00:55:51,120
listening pretty much every every major

00:55:48,420 --> 00:55:54,030
socket this call has a socket level hook

00:55:51,120 --> 00:55:57,000
and this is a good way if you want your

00:55:54,030 --> 00:55:59,040
LSM to be able to control accesses

00:55:57,000 --> 00:56:01,740
between the processes and the sockets

00:55:59,040 --> 00:56:04,110
themselves because keep in mind you can

00:56:01,740 --> 00:56:05,880
have a socket that's shared so it's not

00:56:04,110 --> 00:56:09,000
always going to be guaranteed to be

00:56:05,880 --> 00:56:11,250
exclusive to your application the next

00:56:09,000 --> 00:56:12,840
type of networking access control hooks

00:56:11,250 --> 00:56:16,500
are what what I call the packet level

00:56:12,840 --> 00:56:18,270
hooks or the per packet hooks these are

00:56:16,500 --> 00:56:22,020
low level controls that actually take

00:56:18,270 --> 00:56:24,540
place on the network traffic itself very

00:56:22,020 --> 00:56:26,430
low level these allow you to do a number

00:56:24,540 --> 00:56:31,110
of things these allow you to control

00:56:26,430 --> 00:56:33,990
access between the network interfaces in

00:56:31,110 --> 00:56:35,760
the packet the sockets in the packet if

00:56:33,990 --> 00:56:37,740
you want to look at the IP addresses you

00:56:35,760 --> 00:56:40,440
can do that pretty much anything that's

00:56:37,740 --> 00:56:42,420
in the packet itself is fair game

00:56:40,440 --> 00:56:44,790
soare is a number of things you know and

00:56:42,420 --> 00:56:47,010
in selinux for example we you know we

00:56:44,790 --> 00:56:49,290
can compare against the incoming network

00:56:47,010 --> 00:56:51,390
interface this is where we do all our

00:56:49,290 --> 00:56:53,720
label networking controls and whatnot so

00:56:51,390 --> 00:56:56,370
there's a good deal of flexibility here

00:56:53,720 --> 00:56:58,560
although we've heard locking challenges

00:56:56,370 --> 00:57:00,300
come up a few times there are definitely

00:56:58,560 --> 00:57:02,910
some locking challenges that you need to

00:57:00,300 --> 00:57:04,350
be aware of both have the inbound in the

00:57:02,910 --> 00:57:07,110
outbound side because you are getting

00:57:04,350 --> 00:57:09,240
called from the networking stack and the

00:57:07,110 --> 00:57:10,980
networking folks have gone to a lot of

00:57:09,240 --> 00:57:13,860
effort to make the networking stack

00:57:10,980 --> 00:57:15,870
extremely performant so you need to be

00:57:13,860 --> 00:57:19,760
careful not to completely mess things up

00:57:15,870 --> 00:57:19,760
so just keep that in mind

00:57:20,160 --> 00:57:23,310
the other big thing you know we've

00:57:22,110 --> 00:57:27,600
talked about there's hooks and then

00:57:23,310 --> 00:57:30,510
there's labels so network labels we I'm

00:57:27,600 --> 00:57:32,520
not I'm pretty confident when I say that

00:57:30,510 --> 00:57:34,020
networking is a little special in the

00:57:32,520 --> 00:57:34,860
case that we actually allow you to have

00:57:34,020 --> 00:57:38,640
multiple layer

00:57:34,860 --> 00:57:40,500
bowls for a single packet which can be

00:57:38,640 --> 00:57:43,890
challenging sometimes get your head

00:57:40,500 --> 00:57:46,590
around and it's maybe not the best thing

00:57:43,890 --> 00:57:50,060
to do but it's what we've got so when

00:57:46,590 --> 00:57:52,110
the first ones is the SEC mark label

00:57:50,060 --> 00:57:53,970
sometimes you might hear somebody talk

00:57:52,110 --> 00:57:56,760
about the netfilter label but we pretty

00:57:53,970 --> 00:57:58,410
much call it SEC mark label these days

00:57:56,760 --> 00:58:01,050
these are packet labels that are

00:57:58,410 --> 00:58:03,450
actually set based on your net filter

00:58:01,050 --> 00:58:06,840
configuration so you write an IP tables

00:58:03,450 --> 00:58:09,300
command line and you can use that to set

00:58:06,840 --> 00:58:11,360
a sec mark label on your traffic and you

00:58:09,300 --> 00:58:14,390
can set this for incoming traffic

00:58:11,360 --> 00:58:16,980
outgoing traffic forwarded traffic

00:58:14,390 --> 00:58:21,710
basically anything that you can write an

00:58:16,980 --> 00:58:25,890
IP tables command is fair game

00:58:21,710 --> 00:58:27,300
so the one thing to keep in mind said

00:58:25,890 --> 00:58:29,760
this before this is for the local

00:58:27,300 --> 00:58:33,510
configuration right so this doesn't give

00:58:29,760 --> 00:58:35,880
you any real information from the remote

00:58:33,510 --> 00:58:38,640
node other than what might be available

00:58:35,880 --> 00:58:40,140
in the in the packet or the stream

00:58:38,640 --> 00:58:42,360
itself you know like the the source

00:58:40,140 --> 00:58:43,920
address and the source port but you'd

00:58:42,360 --> 00:58:45,000
have no real way of getting any

00:58:43,920 --> 00:58:47,100
information about the security

00:58:45,000 --> 00:58:48,480
attributes of the remote system like

00:58:47,100 --> 00:58:50,340
you're not necessarily going to be able

00:58:48,480 --> 00:58:52,230
to determine you know what was the

00:58:50,340 --> 00:58:54,150
process running at what was the label

00:58:52,230 --> 00:58:57,860
associate with the process on the remote

00:58:54,150 --> 00:59:01,140
host with the SEC mark labels but anyway

00:58:57,860 --> 00:59:03,300
one one kind of easy quick way to think

00:59:01,140 --> 00:59:06,300
of the SEC mark labels is if you're

00:59:03,300 --> 00:59:08,610
familiar with SELinux and a parma might

00:59:06,300 --> 00:59:10,680
support context mounting same with some

00:59:08,610 --> 00:59:11,670
AK I apologize I don't know but if

00:59:10,680 --> 00:59:13,470
you're familiar with the idea of a

00:59:11,670 --> 00:59:15,180
context mount which is where you can

00:59:13,470 --> 00:59:18,000
basically mount a file system and say

00:59:15,180 --> 00:59:20,730
okay everything on this file system tree

00:59:18,000 --> 00:59:22,530
with this particular labels that's kind

00:59:20,730 --> 00:59:25,140
of at a very high level that's a fairly

00:59:22,530 --> 00:59:28,980
good analogy for the SEC mark labels if

00:59:25,140 --> 00:59:32,580
that helps you think of it the next one

00:59:28,980 --> 00:59:36,150
is net label net label isn't one

00:59:32,580 --> 00:59:38,490
particular labeling protocol or or

00:59:36,150 --> 00:59:41,670
packet label it's kind of a bit of a

00:59:38,490 --> 00:59:44,340
framework it supports to the

00:59:41,670 --> 00:59:46,590
standardized labeling protocols explicit

00:59:44,340 --> 00:59:48,059
labeling protocols we've got sip so for

00:59:46,590 --> 00:59:51,660
ipv4

00:59:48,059 --> 00:59:54,209
we've got clip so for ipv6 we also

00:59:51,660 --> 00:59:56,819
support kind of a static fallback

00:59:54,209 --> 00:59:59,759
labeling mechanism which allows you to

00:59:56,819 --> 01:00:01,650
treat unlabeled hosts or unlabeled

00:59:59,759 --> 01:00:04,559
networks the same way you might treat a

01:00:01,650 --> 01:00:06,660
sip so or a Calypso host it basically

01:00:04,559 --> 01:00:08,670
allows you to say okay if I get network

01:00:06,660 --> 01:00:11,609
traffic from this particular host over

01:00:08,670 --> 01:00:13,559
this particular interface go ahead and

01:00:11,609 --> 01:00:15,749
treat it as if it came in as a labeled

01:00:13,559 --> 01:00:18,029
host so it's great if you need to talk

01:00:15,749 --> 01:00:21,329
to things like you know an unlabeled DNS

01:00:18,029 --> 01:00:23,939
server if you have you know Windows or

01:00:21,329 --> 01:00:26,279
Mac clients you want to talk to it's a

01:00:23,939 --> 01:00:29,069
nice way to do that and you know have

01:00:26,279 --> 01:00:31,499
everything on your all the network

01:00:29,069 --> 01:00:33,359
traffic coming into your system you know

01:00:31,499 --> 01:00:37,140
it'll look to your LSM as if it's

01:00:33,359 --> 01:00:39,420
labeled so it's nice little fallback the

01:00:37,140 --> 01:00:42,509
one kind of got you to be aware of all

01:00:39,420 --> 01:00:45,509
of the on the wire protocol so sips own

01:00:42,509 --> 01:00:48,959
Calypso they only support MLS attributes

01:00:45,509 --> 01:00:51,209
so this is you know a sensitivity level

01:00:48,959 --> 01:00:53,759
you know top secret secret and then a

01:00:51,209 --> 01:00:56,489
compartment or a category bitmap so

01:00:53,759 --> 01:00:59,939
there's no standardized provision for

01:00:56,489 --> 01:01:01,619
doing more than that we do have for

01:00:59,939 --> 01:01:05,549
local traffic so things that go over

01:01:01,619 --> 01:01:08,039
loopback we do have some kind of clever

01:01:05,549 --> 01:01:11,459
cheats if you will where we can actually

01:01:08,039 --> 01:01:14,400
send the full LSM label but once again

01:01:11,459 --> 01:01:17,759
that only works for loopback we actually

01:01:14,400 --> 01:01:20,369
kind of intentionally break the format

01:01:17,759 --> 01:01:23,249
so that won't pass checksum verification

01:01:20,369 --> 01:01:25,499
if you send it off the box so that kind

01:01:23,249 --> 01:01:28,589
of as a extra protection to prevent you

01:01:25,499 --> 01:01:31,920
from doing that so once again keep that

01:01:28,589 --> 01:01:35,189
in mind the other thing we have is

01:01:31,920 --> 01:01:37,380
labeled IPSec similar to net label this

01:01:35,189 --> 01:01:39,509
is an on the wire format for

01:01:37,380 --> 01:01:41,939
communicating security labels over the

01:01:39,509 --> 01:01:45,359
network it's currently asking like

01:01:41,939 --> 01:01:47,249
specific but the good news is where I

01:01:45,359 --> 01:01:51,239
said that you know sip zone Calypso can

01:01:47,249 --> 01:01:53,489
only send MLS information labeled IPSec

01:01:51,239 --> 01:01:54,959
can send arbitrary labels it's it's

01:01:53,489 --> 01:01:57,959
basically you're just passing a string

01:01:54,959 --> 01:02:01,450
back and forth there has been some

01:01:57,959 --> 01:02:03,309
effort to standardize this at the IETF

01:02:01,450 --> 01:02:05,710
there was an effort many years ago which

01:02:03,309 --> 01:02:07,690
kind of petered out and I just saw

01:02:05,710 --> 01:02:10,299
something recently it's being there's

01:02:07,690 --> 01:02:11,770
another renewed effort I'm not part of

01:02:10,299 --> 01:02:13,780
this renewed effort so I don't know all

01:02:11,770 --> 01:02:17,650
the gory details but there is some

01:02:13,780 --> 01:02:18,670
effort going on there some of what I'm

01:02:17,650 --> 01:02:21,250
going to tell you now is a little

01:02:18,670 --> 01:02:24,119
subjective based on my experience so

01:02:21,250 --> 01:02:26,589
take this with a grain of salt but

01:02:24,119 --> 01:02:27,730
having spent several years on this I

01:02:26,589 --> 01:02:29,109
would say there's a little bit of

01:02:27,730 --> 01:02:30,849
experience behind these subjective

01:02:29,109 --> 01:02:33,369
comments

01:02:30,849 --> 01:02:35,099
IPSec granularity is typically a very

01:02:33,369 --> 01:02:38,589
poor fit for LSMs

01:02:35,099 --> 01:02:40,390
and if you want I don't want to take the

01:02:38,589 --> 01:02:42,490
rest of our time talking about that but

01:02:40,390 --> 01:02:46,059
if you're familiar with IPSec and how

01:02:42,490 --> 01:02:48,460
the selectors work and how the LSMs work

01:02:46,059 --> 01:02:51,970
typically with the access controls it's

01:02:48,460 --> 01:02:53,230
just not a good fit and it leads to some

01:02:51,970 --> 01:02:57,790
problems I'll talk about a little bit

01:02:53,230 --> 01:03:00,010
later however it's hard to ignore the

01:02:57,790 --> 01:03:01,930
the encryption in the integrity checking

01:03:00,010 --> 01:03:05,829
and the authentication that comes with

01:03:01,930 --> 01:03:07,869
IPSec it's very nice thing to have and

01:03:05,829 --> 01:03:10,480
it works in a lot of scenarios so you

01:03:07,869 --> 01:03:12,369
know if you want that benefit I would

01:03:10,480 --> 01:03:15,000
encourage you to look at some of the

01:03:12,369 --> 01:03:18,119
other things like sip so and Kalypso and

01:03:15,000 --> 01:03:20,890
running that over a standard IPSec

01:03:18,119 --> 01:03:22,589
tunnel or you know transport depending

01:03:20,890 --> 01:03:25,839
on the protocol and what your needs are

01:03:22,589 --> 01:03:28,329
that's a much more standard approach it

01:03:25,839 --> 01:03:30,640
works a lot better and it gives you many

01:03:28,329 --> 01:03:32,349
of the same advantages that you would

01:03:30,640 --> 01:03:34,150
get with labeled IPSec the only real

01:03:32,349 --> 01:03:37,359
thing you lose is you don't have nari

01:03:34,150 --> 01:03:38,980
string but in some ways if you're

01:03:37,359 --> 01:03:42,309
talking over the network to a remote

01:03:38,980 --> 01:03:45,010
host that might actually be good MLS is

01:03:42,309 --> 01:03:47,109
a much more standardized label format

01:03:45,010 --> 01:03:52,180
there's it's not an arbitrary string

01:03:47,109 --> 01:03:53,710
that could be misinterpreted okay and so

01:03:52,180 --> 01:03:55,420
now we're get off network labeling and

01:03:53,710 --> 01:03:59,380
we'll we'll go back to the local system

01:03:55,420 --> 01:04:01,569
I so pure second IP past sec these are

01:03:59,380 --> 01:04:03,549
socket options that allow you to get

01:04:01,569 --> 01:04:05,500
these network label information up into

01:04:03,549 --> 01:04:06,940
your application because there will be

01:04:05,500 --> 01:04:09,490
times when you might want to have a

01:04:06,940 --> 01:04:12,760
network daemon some sort of service on

01:04:09,490 --> 01:04:14,589
the system that is label aware and that

01:04:12,760 --> 01:04:15,400
you want to understand okay what who am

01:04:14,589 --> 01:04:17,309
I talking to

01:04:15,400 --> 01:04:19,839
the other end of this this connection

01:04:17,309 --> 01:04:24,039
nice part about is these are normal

01:04:19,839 --> 01:04:25,750
socket options with lib selinux we do

01:04:24,039 --> 01:04:27,990
provide an api for getting this

01:04:25,750 --> 01:04:31,930
information so you don't have to do the

01:04:27,990 --> 01:04:34,809
set saw cop gets a cop sort of thing but

01:04:31,930 --> 01:04:36,369
you can roll your own you know these are

01:04:34,809 --> 01:04:39,039
standard linux socket options there's

01:04:36,369 --> 01:04:41,710
nothing special it does obviously

01:04:39,039 --> 01:04:43,180
require that you have that labeling

01:04:41,710 --> 01:04:45,460
information in the kernel for the

01:04:43,180 --> 01:04:47,440
connection in the first place so you are

01:04:45,460 --> 01:04:49,930
gonna use have to use either net label

01:04:47,440 --> 01:04:51,880
with one of those different protocols or

01:04:49,930 --> 01:04:55,299
the fallback or labeled IPSec to get

01:04:51,880 --> 01:04:58,839
that information otherwise there's no

01:04:55,299 --> 01:05:00,700
label to give you the one one positive

01:04:58,839 --> 01:05:02,740
that is if you're on the local system

01:05:00,700 --> 01:05:05,260
and you're using you know AF local or F

01:05:02,740 --> 01:05:07,029
UNIX sockets you can have that

01:05:05,260 --> 01:05:08,710
information automatically because it's

01:05:07,029 --> 01:05:10,390
easy for us and the kernel to go look at

01:05:08,710 --> 01:05:14,230
the other end and see okay

01:05:10,390 --> 01:05:16,180
this is who you're talking to so now I

01:05:14,230 --> 01:05:18,670
just want to touch few more slides on

01:05:16,180 --> 01:05:22,059
just some I guess lessons learned or

01:05:18,670 --> 01:05:24,190
hidden dangers to to watch out for if

01:05:22,059 --> 01:05:26,650
you're playing around with LS M's and

01:05:24,190 --> 01:05:29,049
want to do your own thing probably the

01:05:26,650 --> 01:05:32,410
biggest thing that we see or that I've

01:05:29,049 --> 01:05:35,309
seen people try to do is try to reject

01:05:32,410 --> 01:05:39,579
connections on the accept hook and

01:05:35,309 --> 01:05:41,829
accept is way too late by the time a

01:05:39,579 --> 01:05:44,260
connection gets into the sockets

01:05:41,829 --> 01:05:46,720
you know connection queue so that you

01:05:44,260 --> 01:05:48,520
can pull it off with accept basically

01:05:46,720 --> 01:05:50,109
you've already finished the handshake

01:05:48,520 --> 01:05:50,799
with the remote node and you've said

01:05:50,109 --> 01:05:53,230
that yep

01:05:50,799 --> 01:05:54,520
we can talk life is good and you're

01:05:53,230 --> 01:05:56,799
basically just waiting for the

01:05:54,520 --> 01:05:58,450
application come along and say yeah I'm

01:05:56,799 --> 01:05:59,859
ready to start talking to you I'm gonna

01:05:58,450 --> 01:06:02,980
pull this connection out of the queue

01:05:59,859 --> 01:06:05,529
and and get going the best you can

01:06:02,980 --> 01:06:07,329
safely do unless you want to be a really

01:06:05,529 --> 01:06:09,670
bad neighbor you know I mean you could

01:06:07,329 --> 01:06:11,470
reject it but it's kind of equivalent of

01:06:09,670 --> 01:06:13,569
you know somebody knocks on your door

01:06:11,470 --> 01:06:15,010
you let them inside close the door

01:06:13,569 --> 01:06:18,880
behind them and then throw them out the

01:06:15,010 --> 01:06:22,000
window so that that's kind of the

01:06:18,880 --> 01:06:24,190
equivalent so but what you can do is you

01:06:22,000 --> 01:06:25,990
can in the accept level hook basically

01:06:24,190 --> 01:06:28,210
say that I don't want to allow this

01:06:25,990 --> 01:06:29,230
application to pull that connection off

01:06:28,210 --> 01:06:31,150
the

01:06:29,230 --> 01:06:33,160
come in connection q which that's

01:06:31,150 --> 01:06:35,560
perfectly valid the connection still

01:06:33,160 --> 01:06:37,780
stays there and presumably at some point

01:06:35,560 --> 01:06:40,650
depending on the underlying protocols it

01:06:37,780 --> 01:06:44,050
would timeout I would imagine but anyway

01:06:40,650 --> 01:06:46,330
if you want to reject incoming

01:06:44,050 --> 01:06:50,050
connections during the handshake process

01:06:46,330 --> 01:06:51,790
use the packet level access controls

01:06:50,050 --> 01:06:54,430
there are hooks specifically for that

01:06:51,790 --> 01:06:56,859
when you get an incoming connection you

01:06:54,430 --> 01:06:58,510
can drop it it's safely it's the

01:06:56,859 --> 01:07:01,869
equivalent of you basically never

01:06:58,510 --> 01:07:06,280
opening the door to your house so that's

01:07:01,869 --> 01:07:12,040
the polite way to go about doing it

01:07:06,280 --> 01:07:14,980
the other thing struct sk buff we have

01:07:12,040 --> 01:07:18,940
no security blob in the packets

01:07:14,980 --> 01:07:21,210
themselves and for a long that there's

01:07:18,940 --> 01:07:23,230
there's a huge history as to why this is

01:07:21,210 --> 01:07:26,710
and I'm just going to say that it's

01:07:23,230 --> 01:07:29,950
unlikely that we'll ever get one there

01:07:26,710 --> 01:07:33,430
is there's potentially ways we might be

01:07:29,950 --> 01:07:35,170
able to fake it and if you're really

01:07:33,430 --> 01:07:38,710
interested in doing that work come talk

01:07:35,170 --> 01:07:40,840
to me but if you're writing your own LSM

01:07:38,710 --> 01:07:44,140
you're gonna have enough challenges in

01:07:40,840 --> 01:07:47,320
the beginning don't don't take this one

01:07:44,140 --> 01:07:50,050
on once again

01:07:47,320 --> 01:07:52,570
well subjective comment but I've got a

01:07:50,050 --> 01:07:55,960
lot of battle scars to just scare you

01:07:52,570 --> 01:07:58,540
off on this one I guess the one

01:07:55,960 --> 01:08:02,200
exception is sec mark does have a 32-bit

01:07:58,540 --> 01:08:03,970
field in the sk buff if it was 64-bit

01:08:02,200 --> 01:08:07,210
this would be a totally different slide

01:08:03,970 --> 01:08:10,210
but it's not so you do have that and

01:08:07,210 --> 01:08:12,040
this is one of the kind of gets to this

01:08:10,210 --> 01:08:14,080
point of why we have two labels on a

01:08:12,040 --> 01:08:17,049
packet because the second mark is kind

01:08:14,080 --> 01:08:19,540
of separate from everything else to get

01:08:17,049 --> 01:08:22,150
around this net label has some kind of

01:08:19,540 --> 01:08:25,359
clever workarounds because net label

01:08:22,150 --> 01:08:28,120
uses explicit packet labeling protocols

01:08:25,359 --> 01:08:31,020
for the most part we actually treat the

01:08:28,120 --> 01:08:33,609
IP option headers as our security blob

01:08:31,020 --> 01:08:36,609
we just go in and look at the option

01:08:33,609 --> 01:08:38,350
header and recalculate the label each

01:08:36,609 --> 01:08:40,210
time you asked for it so if you're

01:08:38,350 --> 01:08:42,940
looking at net label there's a caching

01:08:40,210 --> 01:08:45,670
mechanism in there strongly suggest you

01:08:42,940 --> 01:08:47,140
is that because that will help get rid

01:08:45,670 --> 01:08:49,630
of lot of the overhead of having to go

01:08:47,140 --> 01:08:53,770
back into the option header and convert

01:08:49,630 --> 01:08:56,130
the label format for you labeled IPSec

01:08:53,770 --> 01:08:58,870
works around this because it uses the

01:08:56,130 --> 01:09:01,569
security associations themselves for the

01:08:58,870 --> 01:09:03,759
labeling information it's very

01:09:01,569 --> 01:09:05,980
convenient in this case but it's also

01:09:03,759 --> 01:09:08,910
one of the reasons why labeled IPSec is

01:09:05,980 --> 01:09:12,670
kind of a poor fit for a lot of LSM

01:09:08,910 --> 01:09:16,930
security models so anyway stuff to keep

01:09:12,670 --> 01:09:19,569
in mind and one of the last few slides

01:09:16,930 --> 01:09:21,250
actually sorry the last slide for the

01:09:19,569 --> 01:09:25,150
networking stuff as the labeling

01:09:21,250 --> 01:09:27,250
protocols themselves sip so uses ipv4

01:09:25,150 --> 01:09:30,190
options and I don't know how familiar

01:09:27,250 --> 01:09:34,630
most of you are with ipv4 but the ipv4

01:09:30,190 --> 01:09:37,199
options is with looking back at it I

01:09:34,630 --> 01:09:39,370
mean I think what ipv4 is 47 years old

01:09:37,199 --> 01:09:41,949
probably made great sense at the time

01:09:39,370 --> 01:09:46,870
but nowadays it's perhaps not the best

01:09:41,949 --> 01:09:48,670
way to do optional information and a lot

01:09:46,870 --> 01:09:52,120
of network infrastructure will go ahead

01:09:48,670 --> 01:09:54,160
and heat ipv4 options however in the

01:09:52,120 --> 01:09:55,780
sense of sip so this is probably not a

01:09:54,160 --> 01:09:58,449
bad thing it might actually end up

01:09:55,780 --> 01:10:01,239
protecting you from yourself because the

01:09:58,449 --> 01:10:03,430
ipv4 options are not in the sense of sip

01:10:01,239 --> 01:10:07,150
so anyway they're not protected by any

01:10:03,430 --> 01:10:10,180
sort of cryptography or any sort of you

01:10:07,150 --> 01:10:12,760
know integrity verification checks so if

01:10:10,180 --> 01:10:15,160
you're not certain about your network

01:10:12,760 --> 01:10:16,960
infrastructure and if it's going to be

01:10:15,160 --> 01:10:19,060
stripping off these sips of IP options

01:10:16,960 --> 01:10:22,210
that's a good indicator that you don't

01:10:19,060 --> 01:10:24,310
have a secured network infrastructure so

01:10:22,210 --> 01:10:25,600
you should really in that case if you're

01:10:24,310 --> 01:10:28,120
using sips I'll be running it through

01:10:25,600 --> 01:10:30,940
some sort of you know secure tunnel

01:10:28,120 --> 01:10:32,830
IPSec or whatnot in which case it's

01:10:30,940 --> 01:10:36,760
going to preserve your IP options and

01:10:32,830 --> 01:10:39,130
life will be fine similar thing with

01:10:36,760 --> 01:10:41,410
Calypso accept because Calypso is ipv6

01:10:39,130 --> 01:10:43,210
ipv6 has much better option handling

01:10:41,410 --> 01:10:46,420
Calypso happens to be a hop by hop

01:10:43,210 --> 01:10:49,060
option if you guys know what that means

01:10:46,420 --> 01:10:51,730
but similar thing if you really want to

01:10:49,060 --> 01:10:55,199
secure that der it inside an IPSec

01:10:51,730 --> 01:10:55,199
tunnel life will be much better

01:10:55,860 --> 01:10:59,360
labeled IPSec once again I want to go

01:10:57,570 --> 01:11:02,070
into too much of the gory details but

01:10:59,360 --> 01:11:05,489
labeled IPSec if you're not careful can

01:11:02,070 --> 01:11:08,460
result in a pretty badly exponential

01:11:05,489 --> 01:11:09,900
explosion of essays on your system this

01:11:08,460 --> 01:11:12,719
kind of goes back to I was saying before

01:11:09,900 --> 01:11:15,540
about it using the essays themselves to

01:11:12,719 --> 01:11:17,670
contain the labels so in your normal

01:11:15,540 --> 01:11:21,179
IPSec configuration you might have a

01:11:17,670 --> 01:11:23,610
single tunnel between two nodes you turn

01:11:21,179 --> 01:11:25,650
on labeled IPSec that could easily go

01:11:23,610 --> 01:11:28,020
into the thousands and that's just

01:11:25,650 --> 01:11:30,630
between two nodes if you're talking

01:11:28,020 --> 01:11:32,270
between three or four nodes you can see

01:11:30,630 --> 01:11:36,030
how it gets out of hand pretty quickly

01:11:32,270 --> 01:11:38,460
it's also not offload friendly no matter

01:11:36,030 --> 01:11:41,010
what you do because the label is in the

01:11:38,460 --> 01:11:42,750
SA this means that you need to do like

01:11:41,010 --> 01:11:44,310
between the two systems because that's

01:11:42,750 --> 01:11:48,150
when the label information actually gets

01:11:44,310 --> 01:11:50,190
communicated and if that si is on the

01:11:48,150 --> 01:11:52,650
local systems that means you also need

01:11:50,190 --> 01:11:55,350
to do your H or your ESP encapsulation

01:11:52,650 --> 01:11:57,750
on that system too so there's nothing

01:11:55,350 --> 01:11:59,340
saying you can't have nested IPSec you

01:11:57,750 --> 01:12:00,659
know if you have some requirement where

01:11:59,340 --> 01:12:02,820
you need an on the wire

01:12:00,659 --> 01:12:05,489
you know bump on the wire encrypt or

01:12:02,820 --> 01:12:06,540
whatnot you can do that that's fine but

01:12:05,489 --> 01:12:11,480
know that you're still going to have to

01:12:06,540 --> 01:12:14,280
run IPSec on your host that's it for

01:12:11,480 --> 01:12:16,409
networking I can see by the next slide

01:12:14,280 --> 01:12:17,760
I'm still up here for audit but before I

01:12:16,409 --> 01:12:23,820
jump into that does anybody many

01:12:17,760 --> 01:12:24,739
questions about networking okay crickets

01:12:23,820 --> 01:12:28,739
all right

01:12:24,739 --> 01:12:32,550
audit so audit versus traditional

01:12:28,739 --> 01:12:34,949
logging one of the questions we get a

01:12:32,550 --> 01:12:36,869
lot is why why do I care about audit you

01:12:34,949 --> 01:12:40,320
know I can do a print k we've got the

01:12:36,869 --> 01:12:42,090
the ring buffer you know the basic

01:12:40,320 --> 01:12:45,750
reason for this that ought is intended

01:12:42,090 --> 01:12:47,630
for security relevant events these are

01:12:45,750 --> 01:12:51,150
you know access control decisions

01:12:47,630 --> 01:12:54,060
configuration changes I'm trying to

01:12:51,150 --> 01:12:58,409
think anything that your LSM could do

01:12:54,060 --> 01:13:00,989
that could impact the ability for it to

01:12:58,409 --> 01:13:03,719
enforce you know access control

01:13:00,989 --> 01:13:06,449
decisions on the system it also happens

01:13:03,719 --> 01:13:08,880
to record not just that particular and

01:13:06,449 --> 01:13:11,400
forgave information not just you know so

01:13:08,880 --> 01:13:14,070
object object verb sort of thing but it

01:13:11,400 --> 01:13:15,960
also records important relevant

01:13:14,070 --> 01:13:17,940
information for that event you know for

01:13:15,960 --> 01:13:20,040
example if you had a if you're trying to

01:13:17,940 --> 01:13:21,719
access a file it's also going to give

01:13:20,040 --> 01:13:24,060
you information about you know the

01:13:21,719 --> 01:13:25,889
device the I know path name that was

01:13:24,060 --> 01:13:28,770
used current working directory that sort

01:13:25,889 --> 01:13:31,170
of stuff and this was primarily

01:13:28,770 --> 01:13:33,150
developed for the various security

01:13:31,170 --> 01:13:35,130
certification efforts that Linux has

01:13:33,150 --> 01:13:36,030
been put through over the years namely

01:13:35,130 --> 01:13:38,130
Common Criteria

01:13:36,030 --> 01:13:41,040
but there's others that audit Sol's as

01:13:38,130 --> 01:13:42,960
well and this kind of gets at to the

01:13:41,040 --> 01:13:45,150
real reason why we don't necessarily

01:13:42,960 --> 01:13:47,760
want to use you know D message in print

01:13:45,150 --> 01:13:52,159
K is that audit provides us kind of a

01:13:47,760 --> 01:13:54,810
nice secure path for generating these

01:13:52,159 --> 01:13:57,120
you know these audit records and storing

01:13:54,810 --> 01:13:58,830
them on the system if you know if you're

01:13:57,120 --> 01:14:00,810
familiar with you know VAR log audit

01:13:58,830 --> 01:14:02,310
audit team it you kind of get an idea of

01:14:00,810 --> 01:14:04,710
whether you're going there

01:14:02,310 --> 01:14:08,250
it also takes care of you know managing

01:14:04,710 --> 01:14:11,219
you know and handling backlog overflows

01:14:08,250 --> 01:14:14,940
you know exhausting your VAR log out at

01:14:11,219 --> 01:14:16,739
partition so on and so forth there's a

01:14:14,940 --> 01:14:19,860
lot of knobs up in the audit daemon and

01:14:16,739 --> 01:14:21,900
the kernel to handle all that so once

01:14:19,860 --> 01:14:24,630
again probably more information that we

01:14:21,900 --> 01:14:26,070
can go into today but feel free to get

01:14:24,630 --> 01:14:30,600
in touch with me if you have any

01:14:26,070 --> 01:14:32,400
questions so what is audit basically

01:14:30,600 --> 01:14:35,190
well on it is a bunch of Records that

01:14:32,400 --> 01:14:36,929
make up a singular audit event the

01:14:35,190 --> 01:14:39,900
number of Records for any given event

01:14:36,929 --> 01:14:42,449
can vary so for example I mention on the

01:14:39,900 --> 01:14:44,040
past slide you're trying to access a

01:14:42,449 --> 01:14:45,330
file on the LSM you know you're

01:14:44,040 --> 01:14:47,070
obviously going to have some MELAS of

01:14:45,330 --> 01:14:49,710
them specific information like the

01:14:47,070 --> 01:14:52,800
subject the object labeling as well as

01:14:49,710 --> 01:14:56,190
you know the access itself but you're

01:14:52,800 --> 01:14:57,690
also getting another number of other

01:14:56,190 --> 01:14:59,340
records you know one's going to be a

01:14:57,690 --> 01:15:00,690
path record which like I said it's going

01:14:59,340 --> 01:15:04,440
to give you information about the device

01:15:00,690 --> 01:15:05,850
the inode the path name will also give

01:15:04,440 --> 01:15:07,260
you a sis call record which will

01:15:05,850 --> 01:15:09,179
actually give you know ok what's the

01:15:07,260 --> 01:15:12,440
what's the sis call that was used to do

01:15:09,179 --> 01:15:16,620
this is it an open is it a read/write

01:15:12,440 --> 01:15:18,030
will give you those call arguments so on

01:15:16,620 --> 01:15:20,250
and so forth and there's there's others

01:15:18,030 --> 01:15:22,260
as well

01:15:20,250 --> 01:15:25,469
the good news is that the audit

01:15:22,260 --> 01:15:28,139
subsystem should handle a lot of this

01:15:25,469 --> 01:15:29,969
extra work for you it'll take care of

01:15:28,139 --> 01:15:32,130
bundling all these individual records

01:15:29,969 --> 01:15:34,050
have put into a single event from an

01:15:32,130 --> 01:15:36,840
Ellison perspective in this case of the

01:15:34,050 --> 01:15:39,030
file access really all you need to do is

01:15:36,840 --> 01:15:41,429
to supply your Ellison specific

01:15:39,030 --> 01:15:43,469
information if auditing is configured

01:15:41,429 --> 01:15:46,560
and turned on you'll get that sis call

01:15:43,469 --> 01:15:47,850
record you'll get those path records you

01:15:46,560 --> 01:15:49,199
know without you having you doing your

01:15:47,850 --> 01:15:51,570
work and there's actually even some

01:15:49,199 --> 01:15:53,400
discussion right now in the case of some

01:15:51,570 --> 01:15:57,300
of these things possibly even allowing

01:15:53,400 --> 01:15:59,280
the LSM to may be audit some additional

01:15:57,300 --> 01:16:01,080
information or to indicate to the audit

01:15:59,280 --> 01:16:03,060
subsystem that you want to have this

01:16:01,080 --> 01:16:05,940
extra information even if the systems

01:16:03,060 --> 01:16:08,940
not configured that way but this is work

01:16:05,940 --> 01:16:13,290
in progress so maybe it doesn't happen

01:16:08,940 --> 01:16:16,739
well let's see so that last line audit

01:16:13,290 --> 01:16:18,239
log format I think the key is through

01:16:16,739 --> 01:16:21,540
that first argument instead of sending

01:16:18,239 --> 01:16:23,580
null send audit context that basically

01:16:21,540 --> 01:16:26,670
is a hint to the audit subsystem to say

01:16:23,580 --> 01:16:29,159
that you know this this information is

01:16:26,670 --> 01:16:31,620
associated with the current tasks and

01:16:29,159 --> 01:16:33,389
things that it's doing and that's that's

01:16:31,620 --> 01:16:34,590
the clue to the audit subsystem to go

01:16:33,389 --> 01:16:37,770
ahead and bundle this with the other

01:16:34,590 --> 01:16:39,120
records if you leave that as no god

01:16:37,770 --> 01:16:41,610
subsystem will treat this as a

01:16:39,120 --> 01:16:43,830
standalone record a standalone event and

01:16:41,610 --> 01:16:46,590
won't necessarily associate it with that

01:16:43,830 --> 01:16:50,280
says call in the path record so from

01:16:46,590 --> 01:16:51,810
analysis perspective I think 99% of the

01:16:50,280 --> 01:16:54,780
time you're gonna want to add that Auto

01:16:51,810 --> 01:16:56,699
context in there the the one exception

01:16:54,780 --> 01:16:58,830
might be for some networking events

01:16:56,699 --> 01:17:00,690
because you don't necessarily have that

01:16:58,830 --> 01:17:04,770
you know it could be running of an ISR

01:17:00,690 --> 01:17:06,030
sort of thing but there's other problems

01:17:04,770 --> 01:17:10,590
if you're going to be auditing on the

01:17:06,030 --> 01:17:12,810
per packet level hooks all right so

01:17:10,590 --> 01:17:15,030
what's audit I mean I think we already

01:17:12,810 --> 01:17:18,139
covered some of this you know primarily

01:17:15,030 --> 01:17:20,040
comes down to access control decisions

01:17:18,139 --> 01:17:21,719
you know I don't want to make too many

01:17:20,040 --> 01:17:22,800
assumptions about your LSM but like I

01:17:21,719 --> 01:17:24,710
said I'm going to assume you're going to

01:17:22,800 --> 01:17:26,400
have a subject and object at a verb you

01:17:24,710 --> 01:17:29,850
definitely want to record that

01:17:26,400 --> 01:17:31,830
information configuration changes you

01:17:29,850 --> 01:17:33,870
know fresh ceilings for example we have

01:17:31,830 --> 01:17:35,100
a loadable policy that you can change

01:17:33,870 --> 01:17:37,020
so obviously you know when you learn a

01:17:35,100 --> 01:17:41,070
new policy that's something that you

01:17:37,020 --> 01:17:43,530
want to record in the audit log yeah so

01:17:41,070 --> 01:17:45,660
it's it's going to be very Ellison

01:17:43,530 --> 01:17:47,100
dependent I guess is what I'm getting at

01:17:45,660 --> 01:17:49,080
because each Allison's gonna have a

01:17:47,100 --> 01:17:51,780
different you know approach to securing

01:17:49,080 --> 01:17:53,460
the system but think about if it's if

01:17:51,780 --> 01:17:55,590
it's something that you feel is

01:17:53,460 --> 01:17:59,130
important for the LSM because it's

01:17:55,590 --> 01:18:01,770
affecting how your LSM operates or how

01:17:59,130 --> 01:18:04,380
it you know affects the system you

01:18:01,770 --> 01:18:07,860
probably want to log it the other thing

01:18:04,380 --> 01:18:10,260
is make sure that you're auditing both

01:18:07,860 --> 01:18:11,580
your success and your failures you know

01:18:10,260 --> 01:18:14,400
because a lot of time if somebody tries

01:18:11,580 --> 01:18:15,630
to access that file you want to know if

01:18:14,400 --> 01:18:17,490
they succeed you also want to know if

01:18:15,630 --> 01:18:20,250
they fail because that could be an

01:18:17,490 --> 01:18:23,100
indication that's something not great is

01:18:20,250 --> 01:18:24,540
going on in the system you know might

01:18:23,100 --> 01:18:26,370
just be poorly written code or an

01:18:24,540 --> 01:18:29,280
accident but it also might be malicious

01:18:26,370 --> 01:18:31,670
so logging your failures is just as

01:18:29,280 --> 01:18:35,610
important as logging your successes and

01:18:31,670 --> 01:18:38,730
the final point I'll mention is be

01:18:35,610 --> 01:18:40,170
careful not to log too much you know

01:18:38,730 --> 01:18:42,150
people that really care about audit

01:18:40,170 --> 01:18:44,370
logging that turn on a lot of things and

01:18:42,150 --> 01:18:46,230
that you know run a log aggregator that

01:18:44,370 --> 01:18:48,360
collects from a whole network of systems

01:18:46,230 --> 01:18:52,140
I mean they can get several gigabytes if

01:18:48,360 --> 01:18:53,730
not more a day of audit logs and not

01:18:52,140 --> 01:18:56,310
only does that prevent a storage problem

01:18:53,730 --> 01:18:58,260
over a long period of time but also

01:18:56,310 --> 01:18:59,730
people that are usually gendered people

01:18:58,260 --> 01:19:03,570
that are usually collecting that much

01:18:59,730 --> 01:19:05,940
audit information also have heuristics

01:19:03,570 --> 01:19:07,980
and business analytics that dig through

01:19:05,940 --> 01:19:10,320
those audit eyes looking for certain

01:19:07,980 --> 01:19:13,530
things and the bigger that log file is

01:19:10,320 --> 01:19:15,450
the harder that becomes so there is no

01:19:13,530 --> 01:19:17,700
one right answer here when it comes to

01:19:15,450 --> 01:19:19,170
you know how much to log but just keep

01:19:17,700 --> 01:19:21,750
that in your back your mind if it

01:19:19,170 --> 01:19:24,270
doesn't need to be in the audit log if

01:19:21,750 --> 01:19:25,980
it's not security relevant there's

01:19:24,270 --> 01:19:27,980
plenty of other locking mechanisms out

01:19:25,980 --> 01:19:30,720
there that you should probably be using

01:19:27,980 --> 01:19:34,680
and I think the last slide then I'll

01:19:30,720 --> 01:19:38,280
hand you back off to KC a few tips that

01:19:34,680 --> 01:19:41,100
will you know keep the audit people

01:19:38,280 --> 01:19:43,050
happy with what you do don't change the

01:19:41,100 --> 01:19:44,760
order of fields in a record that's a

01:19:43,050 --> 01:19:46,060
quick way to get an immediate nack from

01:19:44,760 --> 01:19:49,540
me

01:19:46,060 --> 01:19:50,980
nothing personal just the way it is try

01:19:49,540 --> 01:19:54,220
to leverage existing field names

01:19:50,980 --> 01:19:56,380
whenever possible you know audits been

01:19:54,220 --> 01:19:57,430
around it records a number of different

01:19:56,380 --> 01:19:59,880
things you know we already have a

01:19:57,430 --> 01:20:04,210
subject an object in an operation field

01:19:59,880 --> 01:20:07,300
go ahead and reuse those we also have

01:20:04,210 --> 01:20:09,870
LSM audit see under you know the

01:20:07,300 --> 01:20:13,600
security directory which is handy for

01:20:09,870 --> 01:20:15,580
auditing various objects on the system

01:20:13,600 --> 01:20:16,660
go ahead and reuse that you know you

01:20:15,580 --> 01:20:19,570
don't have to reinvent the wheel every

01:20:16,660 --> 01:20:21,820
time you know if you're creating your

01:20:19,570 --> 01:20:23,710
own LSM once you have enough challenges

01:20:21,820 --> 01:20:25,990
you're gonna be you know inventing a lot

01:20:23,710 --> 01:20:27,670
of new stuff anyway feel free to use

01:20:25,990 --> 01:20:30,550
that stuff you know make your life a

01:20:27,670 --> 01:20:33,280
little bit easier in the last two things

01:20:30,550 --> 01:20:34,900
if you're doing audit changes you know

01:20:33,280 --> 01:20:38,290
if you're using audit in your code

01:20:34,900 --> 01:20:42,730
please see see Linux audit on your patch

01:20:38,290 --> 01:20:43,930
submissions that helps us help you make

01:20:42,730 --> 01:20:46,600
sure that you're doing all the right

01:20:43,930 --> 01:20:49,000
things that you won't run into any audit

01:20:46,600 --> 01:20:50,860
problems it also lets us know that

01:20:49,000 --> 01:20:52,600
you're doing stuff so that we can make

01:20:50,860 --> 01:20:54,190
sure that the proper you know numbers

01:20:52,600 --> 01:20:56,740
are reserved and the header files for

01:20:54,190 --> 01:20:59,020
you it it just makes everybody life's

01:20:56,740 --> 01:21:01,720
easier so if we find out after the fact

01:20:59,020 --> 01:21:03,730
and there's potentially issues because

01:21:01,720 --> 01:21:06,040
once it ends up in lionesses tree and

01:21:03,730 --> 01:21:10,210
goes out you can't ever change it right

01:21:06,040 --> 01:21:14,410
so please see see Linux audit and

01:21:10,210 --> 01:21:16,600
finally write test cases you know we're

01:21:14,410 --> 01:21:19,150
I'm not going to say that we have a full

01:21:16,600 --> 01:21:22,900
CI infrastructure but we do try to test

01:21:19,150 --> 01:21:24,520
things regularly and we'll help you make

01:21:22,900 --> 01:21:26,950
sure that you know you're auditing

01:21:24,520 --> 01:21:28,630
continues to work and that if something

01:21:26,950 --> 01:21:30,520
else happens in the kernel it won't

01:21:28,630 --> 01:21:33,850
break your auditing but we can only do

01:21:30,520 --> 01:21:35,080
that if your eye test cases so please do

01:21:33,850 --> 01:21:35,740
that if you have any questions about

01:21:35,080 --> 01:21:39,010
that

01:21:35,740 --> 01:21:42,640
once again Linux audit send mail well

01:21:39,010 --> 01:21:44,230
happy to to work with you there so like

01:21:42,640 --> 01:21:45,580
I said this is my last slide on it

01:21:44,230 --> 01:21:48,300
before I hand you back over to Casey

01:21:45,580 --> 01:21:48,300
does anybody have any questions

01:21:48,780 --> 01:21:52,469
everybody still awake

01:21:51,330 --> 01:21:54,420
okay

01:21:52,469 --> 01:22:07,110
alright thanks oh sorry we doing one

01:21:54,420 --> 01:22:10,620
question so it depends a lot on what

01:22:07,110 --> 01:22:13,500
you're doing so for example in SELinux

01:22:10,620 --> 01:22:16,020
we have the ability to you know we look

01:22:13,500 --> 01:22:18,260
at and we say if there's no labeled

01:22:16,020 --> 01:22:21,540
networking configuration in the kernel

01:22:18,260 --> 01:22:24,150
such that basically all we'd be doing is

01:22:21,540 --> 01:22:27,420
comparing unlabeled to unlabeled we just

01:22:24,150 --> 01:22:29,610
don't even bother we we bail at the top

01:22:27,420 --> 01:22:32,580
of the hooks because it's all going to

01:22:29,610 --> 01:22:34,830
be the same comparison however if we do

01:22:32,580 --> 01:22:36,989
have any labeled networking

01:22:34,830 --> 01:22:38,460
configuration installed then we go ahead

01:22:36,989 --> 01:22:40,760
and do the checks because it's not

01:22:38,460 --> 01:22:42,860
always going to be an unlabeled check

01:22:40,760 --> 01:22:46,290
and that seems to work pretty well

01:22:42,860 --> 01:22:48,510
performances is pretty minimal beyond

01:22:46,290 --> 01:22:50,640
that then it's going to depend a lot on

01:22:48,510 --> 01:22:52,469
what you have the configuration setup is

01:22:50,640 --> 01:22:54,630
like for example I mentioned for net

01:22:52,469 --> 01:22:58,350
label there's a caching mechanism on

01:22:54,630 --> 01:23:00,180
there you know the first time you see

01:22:58,350 --> 01:23:02,850
that on the wire label and you have to

01:23:00,180 --> 01:23:05,640
translate it into the selinux label

01:23:02,850 --> 01:23:08,370
there is some overhead but then after

01:23:05,640 --> 01:23:11,630
that it's extremely quick because it

01:23:08,370 --> 01:23:16,320
translates it right into se laces SEC ID

01:23:11,630 --> 01:23:18,660
so if you're looking at lots of traffic

01:23:16,320 --> 01:23:21,030
but it's from one or two long-running

01:23:18,660 --> 01:23:23,040
streams you know for example in the case

01:23:21,030 --> 01:23:24,780
so not an aggregator where it's you know

01:23:23,040 --> 01:23:27,000
it opens up the channel and that just

01:23:24,780 --> 01:23:29,010
keeps firing events over the overheads

01:23:27,000 --> 01:23:30,000
can be a lot less than if you've got you

01:23:29,010 --> 01:23:31,469
know if you're bringing up a lot of

01:23:30,000 --> 01:23:33,180
individual connections you know if

01:23:31,469 --> 01:23:35,250
you've got millions of clients

01:23:33,180 --> 01:23:37,020
connecting for short-lived things and

01:23:35,250 --> 01:23:38,489
sending back the overhead might be a

01:23:37,020 --> 01:23:41,969
little bit more if they're coming at you

01:23:38,489 --> 01:23:43,260
with different labels labeled IPSec

01:23:41,969 --> 01:23:45,600
you're already paying a pretty

01:23:43,260 --> 01:23:49,530
substantial overhead because of all the

01:23:45,600 --> 01:23:50,880
cryptographic operations so while I

01:23:49,530 --> 01:23:52,770
haven't done any exact performance

01:23:50,880 --> 01:23:54,840
measurements on there my guess is the

01:23:52,770 --> 01:23:58,440
labeling overhead is noise in that

01:23:54,840 --> 01:24:01,489
particular case so yeah there there's no

01:23:58,440 --> 01:24:03,900
hard and fast numbers to give you but

01:24:01,489 --> 01:24:05,670
it's easy enough to configure your

01:24:03,900 --> 01:24:07,560
system the way you want it

01:24:05,670 --> 01:24:09,960
you know run knepper for an eye perf

01:24:07,560 --> 01:24:13,080
over it it's a pretty easy thing to

01:24:09,960 --> 01:24:13,650
benchmark so sorry for that not an

01:24:13,080 --> 01:24:16,520
answer

01:24:13,650 --> 01:24:16,520
yeah

01:24:25,540 --> 01:24:29,630
when you say overlap are you talking

01:24:28,010 --> 01:24:32,210
like the difference between like sips on

01:24:29,630 --> 01:24:33,860
calypso versus labeled IPSec or what

01:24:32,210 --> 01:24:45,110
what overlap exactly are you talking

01:24:33,860 --> 01:24:47,870
about oh so you mean like the the

01:24:45,110 --> 01:24:50,480
hooking basically yeah okay so a lot of

01:24:47,870 --> 01:24:52,070
the and we rapidly gonna get into a

01:24:50,480 --> 01:24:54,050
really technical discussion here so I

01:24:52,070 --> 01:24:58,040
might punt you to let's have this

01:24:54,050 --> 01:24:59,780
discussion in the hallway but the so the

01:24:58,040 --> 01:25:01,790
socket level hooks that's an easy one it

01:24:59,780 --> 01:25:04,640
happens you know in the purr socket

01:25:01,790 --> 01:25:07,640
that's not all that interesting most of

01:25:04,640 --> 01:25:10,190
the per packet stuff is either through

01:25:07,640 --> 01:25:12,920
knit through a net filter hook or

01:25:10,190 --> 01:25:14,930
through the socket filter hook so

01:25:12,920 --> 01:25:17,420
basically the same you know BPF is kind

01:25:14,930 --> 01:25:19,340
of cool and trendy we kind of hook in

01:25:17,420 --> 01:25:21,860
the old-school way of you know where you

01:25:19,340 --> 01:25:25,190
could actually load a BPF socket filter

01:25:21,860 --> 01:25:28,840
on there so we use that same mechanism

01:25:25,190 --> 01:25:28,840
that's where the the receive hook is

01:25:30,250 --> 01:25:36,730
nice call alright thanks everybody

01:25:38,220 --> 01:25:43,229
[Applause]

01:25:45,970 --> 01:25:54,920
okay so excellent thank you thank you

01:25:51,350 --> 01:25:56,660
both all right so we got a few more

01:25:54,920 --> 01:25:59,960
things to talk about your security

01:25:56,660 --> 01:26:01,940
module interfaces here so what if you

01:25:59,960 --> 01:26:05,150
have a security module and you want to

01:26:01,940 --> 01:26:06,590
be able to dynamically configure it you

01:26:05,150 --> 01:26:08,870
need to have some mechanism to do that

01:26:06,590 --> 01:26:11,150
you might want to tune things you might

01:26:08,870 --> 01:26:13,880
want to say oh yeah I'm doing a whole

01:26:11,150 --> 01:26:16,670
lot of controls and I haven't seen a

01:26:13,880 --> 01:26:19,550
problem in three days so I'm gonna lower

01:26:16,670 --> 01:26:21,680
the amount of checking I'm going to do

01:26:19,550 --> 01:26:23,960
or you might want to keep statistics

01:26:21,680 --> 01:26:25,940
about the number of number of things

01:26:23,960 --> 01:26:28,250
that you've denied or number of things

01:26:25,940 --> 01:26:33,080
you've permitted so we do have

01:26:28,250 --> 01:26:35,240
mechanisms for doing that generally what

01:26:33,080 --> 01:26:36,740
what we've been using for security

01:26:35,240 --> 01:26:38,330
modules well I would recommend is that

01:26:36,740 --> 01:26:42,130
you either use

01:26:38,330 --> 01:26:47,200
IFS or a Sisyphus special purple files

01:26:42,130 --> 01:26:51,800
special purpose not purple filesystem

01:26:47,200 --> 01:26:54,560
and you can create these they're usually

01:26:51,800 --> 01:26:56,090
relatively easy to do easiest way to go

01:26:54,560 --> 01:26:57,530
about it of course fine go look at an

01:26:56,090 --> 01:27:01,850
existing one

01:26:57,530 --> 01:27:03,860
and that way you can use the file system

01:27:01,850 --> 01:27:06,140
interface to update your your

01:27:03,860 --> 01:27:08,450
configuration gather your statistics as

01:27:06,140 --> 01:27:10,850
you would choose we want you to avoid

01:27:08,450 --> 01:27:14,410
using system adding system calls PR

01:27:10,850 --> 01:27:17,510
controls eff controls iocked dole's

01:27:14,410 --> 01:27:22,490
because they are difficult to integrate

01:27:17,510 --> 01:27:26,780
they consume namespace namespace in

01:27:22,490 --> 01:27:28,610
those those mechanisms and they require

01:27:26,780 --> 01:27:31,070
more application change one of the

01:27:28,610 --> 01:27:32,870
things that if you're writing security

01:27:31,070 --> 01:27:34,850
module you'll want to be aware of is

01:27:32,870 --> 01:27:39,880
that people don't change their

01:27:34,850 --> 01:27:43,160
applications to suit your LS m usually

01:27:39,880 --> 01:27:44,900
they might do it eventually you might be

01:27:43,160 --> 01:27:48,380
able to get things up streamed to do

01:27:44,900 --> 01:27:50,420
that for that but in general people

01:27:48,380 --> 01:27:52,880
won't change and they don't they

01:27:50,420 --> 01:27:56,660
certainly don't want to change their

01:27:52,880 --> 01:27:58,940
their programs just to suit your LS m so

01:27:56,660 --> 01:28:02,320
if you use this mechanism you can do it

01:27:58,940 --> 01:28:05,660
in scripts and that's a whole lot easier

01:28:02,320 --> 01:28:08,690
Mechanics for sis FS their act actually

01:28:05,660 --> 01:28:10,760
mechanisms where you can create a new

01:28:08,690 --> 01:28:12,340
mount point register with the file

01:28:10,760 --> 01:28:14,960
system and do kern mount all

01:28:12,340 --> 01:28:17,630
automatically so your magic file system

01:28:14,960 --> 01:28:21,080
shows up without having to do any any

01:28:17,630 --> 01:28:27,010
work in the configuration of the system

01:28:21,080 --> 01:28:27,010
and that's always really kind of handy

01:28:27,520 --> 01:28:33,470
something you might actually come across

01:28:29,990 --> 01:28:35,900
and just about everybody does in LS m

01:28:33,470 --> 01:28:38,720
scratches their chin and hits this one

01:28:35,900 --> 01:28:41,440
it's like I really want to have a hook

01:28:38,720 --> 01:28:45,070
here there is no hook here

01:28:41,440 --> 01:28:49,750
I need a new hook here what do I do

01:28:45,070 --> 01:28:52,000
it's actually not that hard it's we add

01:28:49,750 --> 01:28:53,530
them all the time you do want to check

01:28:52,000 --> 01:28:57,610
and see if there's an existing hook that

01:28:53,530 --> 01:28:59,740
you might be able to put flags on or use

01:28:57,610 --> 01:29:02,980
in a different way a way that might not

01:28:59,740 --> 01:29:05,200
have been anticipated earlier but

01:29:02,980 --> 01:29:09,370
generally it's it's acceptable to

01:29:05,200 --> 01:29:11,200
request a new hook you in general you

01:29:09,370 --> 01:29:13,900
passed the thing not the thing that's

01:29:11,200 --> 01:29:16,420
security so if you're doing something on

01:29:13,900 --> 01:29:18,820
an inode you pass the inode not the

01:29:16,420 --> 01:29:20,410
inode security blob if you just pass the

01:29:18,820 --> 01:29:22,630
security blob then it makes really

01:29:20,410 --> 01:29:24,190
difficult for other LSMs that might be

01:29:22,630 --> 01:29:27,790
interested in using that hook to use

01:29:24,190 --> 01:29:32,710
other bits of information so that's and

01:29:27,790 --> 01:29:36,660
be generic wherever possible it's really

01:29:32,710 --> 01:29:39,610
unpleasant when you're reading the

01:29:36,660 --> 01:29:43,750
insecurity dot C and you see a hook that

01:29:39,610 --> 01:29:50,980
is specific not only to ipv6 but ipv6

01:29:43,750 --> 01:29:53,950
over this kind of device on Tuesday so

01:29:50,980 --> 01:29:56,080
we have a boot line okay let's say

01:29:53,950 --> 01:29:59,200
you've got your LS m you want to put it

01:29:56,080 --> 01:30:01,930
in you want to try it out you okay

01:29:59,200 --> 01:30:03,640
without making it boot by default so

01:30:01,930 --> 01:30:05,770
that you can boot your system though so

01:30:03,640 --> 01:30:10,330
when your LS m fails you can they boot

01:30:05,770 --> 01:30:12,190
your system without it so we have three

01:30:10,330 --> 01:30:15,100
important mechanisms your security

01:30:12,190 --> 01:30:20,290
equals that will one run one of the

01:30:15,100 --> 01:30:23,050
major legacy LS ms+ any of the minor

01:30:20,290 --> 01:30:25,620
ones so you'll still get Yama even

01:30:23,050 --> 01:30:29,080
though you say security equals selinux

01:30:25,620 --> 01:30:30,970
if you really want to specify the entire

01:30:29,080 --> 01:30:33,490
list of security modules that gets used

01:30:30,970 --> 01:30:35,110
you could say LS M equals and then give

01:30:33,490 --> 01:30:37,150
it the list and it will only use those

01:30:35,110 --> 01:30:41,080
modules it won't automatically bring in

01:30:37,150 --> 01:30:43,510
anything else so be aware of that and

01:30:41,080 --> 01:30:45,550
then there's a nice little boot option

01:30:43,510 --> 01:30:48,640
you have LS m dot debug which will show

01:30:45,550 --> 01:30:50,440
you information about how the mod how

01:30:48,640 --> 01:30:52,550
the configuration the allison

01:30:50,440 --> 01:30:54,320
configuration is set up at

01:30:52,550 --> 01:30:59,170
time so it'll tell you things like how

01:30:54,320 --> 01:31:02,630
big the blobs are and what's registered

01:30:59,170 --> 01:31:05,660
what modules are registered if you have

01:31:02,630 --> 01:31:06,950
conflicts with legacy modules that will

01:31:05,660 --> 01:31:11,750
tell you which ones are enabled and

01:31:06,950 --> 01:31:14,720
which ones were disabled and why so it's

01:31:11,750 --> 01:31:17,300
about time we did this so first thing

01:31:14,720 --> 01:31:22,880
have a good reason for doing your LSM do

01:31:17,300 --> 01:31:25,760
something useful academic exercises are

01:31:22,880 --> 01:31:27,440
kind of fun but really we want these

01:31:25,760 --> 01:31:29,900
things to be valuable you want to add

01:31:27,440 --> 01:31:32,510
value to the system and do this

01:31:29,900 --> 01:31:34,910
something the kernel should do yeah if

01:31:32,510 --> 01:31:37,220
you can do it up in user space just as

01:31:34,910 --> 01:31:42,410
easily go do it there yeah we don't

01:31:37,220 --> 01:31:44,150
really need Java Java parsers or XML

01:31:42,410 --> 01:31:47,860
parsers or any of that kind of stuff

01:31:44,150 --> 01:31:50,390
down in the kernel we want to keep it as

01:31:47,860 --> 01:31:52,130
monolithic and small as we as we can we

01:31:50,390 --> 01:31:53,570
want to keep that under control so don't

01:31:52,130 --> 01:31:56,870
do things that you shouldn't do in the

01:31:53,570 --> 01:32:01,880
kernel in the kernel and follow up with

01:31:56,870 --> 01:32:05,240
a user space support and documentation I

01:32:01,880 --> 01:32:08,990
know and as Paul mentioned two test

01:32:05,240 --> 01:32:10,640
Suites to it's really annoying when you

01:32:08,990 --> 01:32:11,960
try to use something and you have to

01:32:10,640 --> 01:32:15,040
actually go read the code in order to

01:32:11,960 --> 01:32:18,320
figure out what it's what it's doing

01:32:15,040 --> 01:32:20,350
don't reinvent the wheel we have lots of

01:32:18,320 --> 01:32:22,940
wheels

01:32:20,350 --> 01:32:24,560
show us something you give us something

01:32:22,940 --> 01:32:26,630
that will make us make us exciting

01:32:24,560 --> 01:32:29,570
something that Jake will write about in

01:32:26,630 --> 01:32:31,940
Linux weekly news nobody's done

01:32:29,570 --> 01:32:35,540
time-based controls a second this has

01:32:31,940 --> 01:32:38,600
been on the table for like 40 years if I

01:32:35,540 --> 01:32:41,810
could only run this X if I made it so I

01:32:38,600 --> 01:32:44,000
could only run this program between 8

01:32:41,810 --> 01:32:48,050
a.m. and 5 p.m. so that it doesn't get

01:32:44,000 --> 01:32:51,560
abused by people who are moonlight it

01:32:48,050 --> 01:32:54,440
would be a great thing location controls

01:32:51,560 --> 01:32:56,630
it's a modern a new thing right I'm

01:32:54,440 --> 01:33:00,470
sorry I'm in the office I can't run my

01:32:56,630 --> 01:33:03,179
rogue program I'm out of my office I

01:33:00,470 --> 01:33:05,100
can't run my calendar program

01:33:03,179 --> 01:33:07,830
my work calendar program that would be

01:33:05,100 --> 01:33:13,230
really cool uh and it doesn't have to be

01:33:07,830 --> 01:33:17,190
dull that's like do something fun access

01:33:13,230 --> 01:33:23,310
controls based on gosh whether you're on

01:33:17,190 --> 01:33:26,520
a boat because we were in in an era now

01:33:23,310 --> 01:33:28,050
where we actually had module stacking at

01:33:26,520 --> 01:33:32,190
least to some extent getting better

01:33:28,050 --> 01:33:34,380
better every day now you don't have to

01:33:32,190 --> 01:33:38,250
say well we're running this e Linux so

01:33:34,380 --> 01:33:40,500
we can't do that well you can so you

01:33:38,250 --> 01:33:42,179
know come up with good things and yeah

01:33:40,500 --> 01:33:44,760
let's just make make things better and

01:33:42,179 --> 01:33:52,409
with that we'll open up to two general

01:33:44,760 --> 01:33:57,500
questions I know we're running just a

01:33:52,409 --> 01:33:57,500
little bit late but any questions

01:34:00,600 --> 01:34:06,040
case you could give us some examples or

01:34:03,700 --> 01:34:07,540
when the hooks are called not in the

01:34:06,040 --> 01:34:10,030
current process contacts I assume

01:34:07,540 --> 01:34:12,580
probably in Kentucky hooks only

01:34:10,030 --> 01:34:14,590
networking that's the right incoming

01:34:12,580 --> 01:34:17,980
packet obviously those are the ones I

01:34:14,590 --> 01:34:19,960
know of off the top of my head I haven't

01:34:17,980 --> 01:34:33,280
investigated some of the things like the

01:34:19,960 --> 01:34:36,040
tunes okay okay okay all process hooks

01:34:33,280 --> 01:34:37,720
for example yeah alright you'll find

01:34:36,040 --> 01:34:43,180
yeah you'll find out if you if you're

01:34:37,720 --> 01:34:48,400
not all right thanks okay so we're into

01:34:43,180 --> 01:34:51,550
the break okay so here's the deal

01:34:48,400 --> 01:34:53,670
everybody who asks the question come

01:34:51,550 --> 01:34:57,600
forward here and and we will have a

01:34:53,670 --> 01:35:01,060
contest to who gets who gets the

01:34:57,600 --> 01:35:02,950
raspberry pie if you didn't get to ask a

01:35:01,060 --> 01:35:04,270
question and you wanted to and you want

01:35:02,950 --> 01:35:07,120
to be in the contest come up and we'll

01:35:04,270 --> 01:35:09,750
we'll do the same okay great thank you

01:35:07,120 --> 01:35:09,750
very much everybody

01:35:10,530 --> 01:35:18,280
and just to mention the coffee situation

01:35:14,920 --> 01:35:22,240
is now that we are sharing coffee from

01:35:18,280 --> 01:35:23,650
next door so just go in next door I'm

01:35:22,240 --> 01:35:27,180
not sure if this is an upgrade or a

01:35:23,650 --> 01:35:27,180

YouTube URL: https://www.youtube.com/watch?v=4rFxZw3USIs


