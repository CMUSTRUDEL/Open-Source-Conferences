Title: TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM - Daniel Kiper & Daniel Smith
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM - Daniel Kiper, Oracle & Daniel Smith, Apertus Solutions

TrenchBoot is a cross-community OSS integration project for hardware-rooted, late launch integrity of open and proprietary systems. It reduces the attack surface introduced by platform firmware.TrenchBoot contributors are working to add SecureLaunch boot capability to the Linux kernel, making it capable of using Intel TXT or AMD SVM Secure Launch for platform hardware security. This will enable a general purpose, open-source DRTM kernel for measured system launch and attestation of device integrity to trust-centric access infrastructure.This talk introduces the TrenchBoot architecture, the role of SecureLaunch, the goals that drove its development, and some examples how both can increase the platform security. Within this discussion, mechanisms will be presented on how DRTM-enabled capabilities for client, server and embedded platforms may be integrated into Linux distributions.
Captions: 
	00:00:00,000 --> 00:00:07,830
okay so we would like to introduce you

00:00:03,300 --> 00:00:12,000
today into the material trust we also

00:00:07,830 --> 00:00:15,480
discuss the tangible object and I start

00:00:12,000 --> 00:00:16,109
my name is Daniel Kuiper and I work for

00:00:15,480 --> 00:00:17,940
a call

00:00:16,109 --> 00:00:19,980
I am software developer and grab

00:00:17,940 --> 00:00:23,220
maintainer and I will be doing this

00:00:19,980 --> 00:00:25,050
presentation together with my name is

00:00:23,220 --> 00:00:29,510
daniel smith I am the chief technologist

00:00:25,050 --> 00:00:32,430
for after solutions I think ok

00:00:29,510 --> 00:00:35,940
and so today Daniel and I will be

00:00:32,430 --> 00:00:38,040
presenting on trench coat so just a

00:00:35,940 --> 00:00:40,140
quick agenda I'm gonna give her an

00:00:38,040 --> 00:00:43,290
introductory to integrity and Trust

00:00:40,140 --> 00:00:45,450
Daniel will cover dynamic launch I'll

00:00:43,290 --> 00:00:46,649
cover trench foo and Daniel will talk

00:00:45,450 --> 00:00:48,719
about the upstream work that we're doing

00:00:46,649 --> 00:00:54,649
and then we'll do a Q&A session after

00:00:48,719 --> 00:00:55,860
that Oh higher aerials all right sorry

00:00:54,649 --> 00:00:59,940
all right

00:00:55,860 --> 00:01:02,480
ah so integrity and Trust so trench boot

00:00:59,940 --> 00:01:06,360
is specifically interested in the

00:01:02,480 --> 00:01:09,060
trustworthiness of booting so as a

00:01:06,360 --> 00:01:12,210
result a frequent question we get is why

00:01:09,060 --> 00:01:15,210
is secure boot not enough to answer that

00:01:12,210 --> 00:01:16,950
question what we're gonna do today is go

00:01:15,210 --> 00:01:19,920
over a common understanding of what

00:01:16,950 --> 00:01:22,130
Trust is and then using those trust

00:01:19,920 --> 00:01:24,780
constructs

00:01:22,130 --> 00:01:28,680
break down secure boot and dynamic

00:01:24,780 --> 00:01:33,060
launch and discuss that so Trust trust

00:01:28,680 --> 00:01:35,100
is a human social concept basically

00:01:33,060 --> 00:01:37,430
anytime we want something to act on our

00:01:35,100 --> 00:01:39,570
behalf we entrust it we give it trust

00:01:37,430 --> 00:01:41,490
this is the same thing with computer

00:01:39,570 --> 00:01:43,200
systems when we want the computer to do

00:01:41,490 --> 00:01:45,060
something on our behalf we give it our

00:01:43,200 --> 00:01:48,060
information we're trusting it to do the

00:01:45,060 --> 00:01:50,310
right thing with that information so

00:01:48,060 --> 00:01:52,229
when we look at this trust we need to

00:01:50,310 --> 00:01:54,780
find something that is the core that

00:01:52,229 --> 00:01:56,280
that's our root of trust and the root of

00:01:54,780 --> 00:01:58,920
trust we need to be able to understand

00:01:56,280 --> 00:02:00,450
why we can trust it and that is where we

00:01:58,920 --> 00:02:04,590
come into something that's called

00:02:00,450 --> 00:02:06,329
strengthen mechanism so the meaning of

00:02:04,590 --> 00:02:08,729
the meanings of trust is a very good

00:02:06,329 --> 00:02:11,160
paper written back in the 90s they went

00:02:08,729 --> 00:02:12,880
through all I just a human concept of

00:02:11,160 --> 00:02:15,400
trust across that I also saw

00:02:12,880 --> 00:02:17,290
areas they specifically focused on an

00:02:15,400 --> 00:02:20,520
area called what they call it system

00:02:17,290 --> 00:02:22,330
trust this is in mechanical systems or

00:02:20,520 --> 00:02:25,570
computational systems which is what

00:02:22,330 --> 00:02:27,670
we're concerned with here one of the key

00:02:25,570 --> 00:02:30,730
things they said there is that in order

00:02:27,670 --> 00:02:32,400
to believe or have trust and your system

00:02:30,730 --> 00:02:37,060
trust is that you need impersonal

00:02:32,400 --> 00:02:40,000
structures that enable you to know that

00:02:37,060 --> 00:02:43,090
the action you're asking that to do on

00:02:40,000 --> 00:02:44,710
your behalf is does it correctly these

00:02:43,090 --> 00:02:45,790
impersonal structures there's two of

00:02:44,710 --> 00:02:48,550
them that you can have you can have

00:02:45,790 --> 00:02:51,970
structural assurances and you can have

00:02:48,550 --> 00:02:53,170
situational normality we're interested

00:02:51,970 --> 00:02:55,390
in structural assurances and

00:02:53,170 --> 00:02:57,820
specifically for a route of trust we

00:02:55,390 --> 00:03:01,150
want ones that are have high degree of

00:02:57,820 --> 00:03:04,840
strength right to know that we can

00:03:01,150 --> 00:03:07,750
believe in that route of trust so what

00:03:04,840 --> 00:03:09,940
is a root of trust so according to the

00:03:07,750 --> 00:03:13,210
CCG they defined it as a component that

00:03:09,940 --> 00:03:15,430
we expect or it must always behave a

00:03:13,210 --> 00:03:17,680
certain way because if it misbehaves we

00:03:15,430 --> 00:03:19,210
have no way of detecting that so what

00:03:17,680 --> 00:03:21,100
does that mean in terms of strength of

00:03:19,210 --> 00:03:24,370
mechanism so from a strength of

00:03:21,100 --> 00:03:27,130
mechanism we are worried about and this

00:03:24,370 --> 00:03:29,770
term comes from mechanics you you worry

00:03:27,130 --> 00:03:32,200
about whether or not under stress the

00:03:29,770 --> 00:03:34,930
mechanism you're relying upon will fail

00:03:32,200 --> 00:03:36,580
or succeed so in this case we are

00:03:34,930 --> 00:03:39,490
worried about whether or not our route

00:03:36,580 --> 00:03:40,990
of trusts will misbehave and the best

00:03:39,490 --> 00:03:42,430
way we can do that in computational

00:03:40,990 --> 00:03:44,860
systems is trying to drive those through

00:03:42,430 --> 00:03:47,590
the trust to be immutable any time you

00:03:44,860 --> 00:03:49,870
induced mutability that is what the

00:03:47,590 --> 00:03:54,000
means by which somebody can create a

00:03:49,870 --> 00:03:54,000
stress that will cause it to fail on you

00:03:54,090 --> 00:03:59,770
so once we have a route of trust we now

00:03:57,940 --> 00:04:01,630
can rely on that route of trust to make

00:03:59,770 --> 00:04:04,510
evaluations of other components within

00:04:01,630 --> 00:04:06,730
the system and when it meets the right

00:04:04,510 --> 00:04:08,680
criteria we can then impart that same

00:04:06,730 --> 00:04:10,360
trust to that component that is a

00:04:08,680 --> 00:04:13,060
transitive trust what the TCG refers to

00:04:10,360 --> 00:04:16,810
as a transitive trust you can repeat

00:04:13,060 --> 00:04:20,549
that on and on recursively and that

00:04:16,810 --> 00:04:22,870
gives you a chain of trust and that that

00:04:20,549 --> 00:04:25,710
terminology of a chain of trust rooted

00:04:22,870 --> 00:04:27,870
in a in a root or anchored in a root or

00:04:25,710 --> 00:04:30,540
is a very good analogy because in real

00:04:27,870 --> 00:04:32,699
life if you have an anchor with a chain

00:04:30,540 --> 00:04:34,620
if the anchor is in something in a soft

00:04:32,699 --> 00:04:37,080
foundation a little stress will cause it

00:04:34,620 --> 00:04:39,780
to release right we want these anchors

00:04:37,080 --> 00:04:42,120
to be routed hard and then when your

00:04:39,780 --> 00:04:44,400
trust chains build up every time you do

00:04:42,120 --> 00:04:46,620
your transitive trust you're inducing

00:04:44,400 --> 00:04:48,990
mutability into your trust chain that

00:04:46,620 --> 00:04:52,080
means you have create a risk that your

00:04:48,990 --> 00:04:53,759
chain can fail on you so at the end we

00:04:52,080 --> 00:04:56,550
want to be able to build these rid of

00:04:53,759 --> 00:04:59,190
trust with these shorter chains that we

00:04:56,550 --> 00:05:02,940
can then give statements about the

00:04:59,190 --> 00:05:05,340
integrity of this system so integrity

00:05:02,940 --> 00:05:06,510
there's really two kinds of integrity we

00:05:05,340 --> 00:05:08,639
need to be worrying about

00:05:06,510 --> 00:05:12,840
there's our load time integrity and our

00:05:08,639 --> 00:05:14,130
run time integrity and we need the root

00:05:12,840 --> 00:05:17,099
of trust to be able to make assertions

00:05:14,130 --> 00:05:19,289
about these the interesting thing is

00:05:17,099 --> 00:05:21,599
that there's a there's a subtle

00:05:19,289 --> 00:05:24,030
difference subtly about the load time

00:05:21,599 --> 00:05:26,310
versus run time everybody knows that

00:05:24,030 --> 00:05:30,900
secure boot is a boot time a load time

00:05:26,310 --> 00:05:32,940
one dynamic launched from TCG typically

00:05:30,900 --> 00:05:34,860
is a load time but you can actually use

00:05:32,940 --> 00:05:37,590
it as a run time if you want which we'll

00:05:34,860 --> 00:05:39,030
discuss later and then i'ma most people

00:05:37,590 --> 00:05:41,159
think of i'ma is more of a run time but

00:05:39,030 --> 00:05:44,039
it's really low time it's measuring what

00:05:41,159 --> 00:05:45,030
was loaded at the process execution at

00:05:44,039 --> 00:05:46,500
no time does it actually actually

00:05:45,030 --> 00:05:48,030
inspect the process for while it's

00:05:46,500 --> 00:05:50,250
running that's where your runtime

00:05:48,030 --> 00:05:52,080
integrity will come in to where you want

00:05:50,250 --> 00:05:54,000
to be able to establish and re-establish

00:05:52,080 --> 00:05:56,909
the integrity of a process as it's

00:05:54,000 --> 00:05:59,699
running so that way you can continue to

00:05:56,909 --> 00:06:01,800
have trust in what you have running and

00:05:59,699 --> 00:06:03,979
typically the two you see in those are

00:06:01,800 --> 00:06:08,639
their internal integrity monitoring and

00:06:03,979 --> 00:06:11,250
process integrity monitoring so now that

00:06:08,639 --> 00:06:12,830
we've built up a verge of trust how we

00:06:11,250 --> 00:06:16,080
can expand that root of trust two

00:06:12,830 --> 00:06:19,039
components use those to give you

00:06:16,080 --> 00:06:22,139
integrity I'm gonna let Daniel touch on

00:06:19,039 --> 00:06:26,370
dynamic launch Thank You Diana for the

00:06:22,139 --> 00:06:29,340
decent erotic introduction I would like

00:06:26,370 --> 00:06:31,889
to look a bit closer to the dynamic

00:06:29,340 --> 00:06:34,050
launch first of all the mineralogy this

00:06:31,889 --> 00:06:37,050
is quite important here because it is

00:06:34,050 --> 00:06:38,639
very conflated and here in stable we

00:06:37,050 --> 00:06:41,189
have quite nice companies

00:06:38,639 --> 00:06:44,550
of different terminologies terminologies

00:06:41,189 --> 00:06:46,620
used in different specification the most

00:06:44,550 --> 00:06:49,050
important one which discusses the

00:06:46,620 --> 00:06:52,349
generic idea of the dynamic large is

00:06:49,050 --> 00:06:56,900
that specification prepared by TCG and

00:06:52,349 --> 00:06:59,389
it discussed generic idea itself the

00:06:56,900 --> 00:07:03,240
Intel specification and AMD

00:06:59,389 --> 00:07:06,029
specification focus on vendor

00:07:03,240 --> 00:07:10,169
implementation of the dynamic launch the

00:07:06,029 --> 00:07:12,120
problem here is that all three

00:07:10,169 --> 00:07:14,639
documentation as you can see use

00:07:12,120 --> 00:07:17,550
different terms for the same thing so if

00:07:14,639 --> 00:07:19,500
you read it you can feel confused this

00:07:17,550 --> 00:07:22,979
is normal not worried and I'm really

00:07:19,500 --> 00:07:27,750
surprised why why why did it happen

00:07:22,979 --> 00:07:29,969
because in the TCG committee AMD and

00:07:27,750 --> 00:07:32,819
Intel participated so I'm not sure why

00:07:29,969 --> 00:07:33,240
they invited new terms for for the same

00:07:32,819 --> 00:07:35,969
things

00:07:33,240 --> 00:07:38,400
a good example is dynamic lunch as you

00:07:35,969 --> 00:07:41,400
can see in TCG documentation it is

00:07:38,400 --> 00:07:44,759
simply called dynamic lunch in Intel

00:07:41,400 --> 00:07:47,460
click status like sorry it is called

00:07:44,759 --> 00:07:50,039
late lunch and here in the AMD it is

00:07:47,460 --> 00:07:52,469
called secure starter the same thing is

00:07:50,039 --> 00:07:57,120
for DL event you can see this is called

00:07:52,469 --> 00:07:59,550
a center or SK in it and so on and so on

00:07:57,120 --> 00:08:02,089
there are also some terms which doesn't

00:07:59,550 --> 00:08:06,599
have relevant terms in the vendor

00:08:02,089 --> 00:08:08,509
specification like d CR TM in general in

00:08:06,599 --> 00:08:11,879
this presentation we will be using

00:08:08,509 --> 00:08:14,699
terminal early terminology proposed by

00:08:11,879 --> 00:08:17,449
TCG but if we are referring to specific

00:08:14,699 --> 00:08:19,830
implementation of specific

00:08:17,449 --> 00:08:23,060
implementation of the launch then we'll

00:08:19,830 --> 00:08:27,210
be using terminology of a given vendor

00:08:23,060 --> 00:08:30,029
so let's look at let's compare UEFI

00:08:27,210 --> 00:08:32,610
secure boot trust and dynamics lunch

00:08:30,029 --> 00:08:36,599
trust so if you start the machine you

00:08:32,610 --> 00:08:42,269
have a something like you get machine

00:08:36,599 --> 00:08:45,510
started and all humor is taken from from

00:08:42,269 --> 00:08:48,810
from the flash and initially the

00:08:45,510 --> 00:08:52,279
sacrifice in the UEFI is executed which

00:08:48,810 --> 00:08:55,980
does basically

00:08:52,279 --> 00:08:58,860
initiation of of the platform and the

00:08:55,980 --> 00:09:01,670
control is passed from the sect P I and

00:08:58,860 --> 00:09:06,360
the NPI

00:09:01,670 --> 00:09:08,910
does measurement among others and as you

00:09:06,360 --> 00:09:14,040
can see the CR TM is not measured and

00:09:08,910 --> 00:09:19,079
until during the P I so SEC and P I

00:09:14,040 --> 00:09:23,269
phases has must be trusted and CR TM is

00:09:19,079 --> 00:09:26,279
of second P I so this our surfer

00:09:23,269 --> 00:09:31,199
self-referential and the trust lies

00:09:26,279 --> 00:09:34,139
relies on put on put flash and the TPM

00:09:31,199 --> 00:09:38,370
to protect me the measurements and the

00:09:34,139 --> 00:09:41,760
DX e faces and forces U of I secure boot

00:09:38,370 --> 00:09:44,779
verification so we have three kinds of

00:09:41,760 --> 00:09:47,490
root of trust here the flash and TPM

00:09:44,779 --> 00:09:50,370
forms something which is called root of

00:09:47,490 --> 00:09:52,910
trust for storage we have a root of

00:09:50,370 --> 00:09:56,579
trust formation which is built from

00:09:52,910 --> 00:09:58,920
second pai and root of trust for

00:09:56,579 --> 00:10:03,720
verification which is formed from sec

00:09:58,920 --> 00:10:06,300
PII and Driver execution environment the

00:10:03,720 --> 00:10:09,949
situation looks completely different in

00:10:06,300 --> 00:10:12,959
case of dinah dynamic launch because

00:10:09,949 --> 00:10:16,170
here we mostly depend on on the hardware

00:10:12,959 --> 00:10:18,690
how it works in at first we have

00:10:16,170 --> 00:10:21,649
something which is called the C preamble

00:10:18,690 --> 00:10:25,670
it can be a part of bootloader or can be

00:10:21,649 --> 00:10:30,570
it can be part or currently running OS

00:10:25,670 --> 00:10:35,100
and DC are TM is taken initially by the

00:10:30,570 --> 00:10:40,529
CPU and the the result is stored in in

00:10:35,100 --> 00:10:43,170
the TPM in the case of the Intel there

00:10:40,529 --> 00:10:47,610
is also additional application method of

00:10:43,170 --> 00:10:53,870
DC II just in Intel CPU just verifies

00:10:47,610 --> 00:10:56,970
the signatures of of this DCE and if if

00:10:53,870 --> 00:11:01,199
after that the control is passed to DC

00:10:56,970 --> 00:11:04,070
and DC also measures the DLA me and put

00:11:01,199 --> 00:11:07,140
the results in the to TPM

00:11:04,070 --> 00:11:12,390
how let's look into today how the

00:11:07,140 --> 00:11:16,770
dynamic loans work so initially the CPU

00:11:12,390 --> 00:11:22,520
obtains locality number four and the the

00:11:16,770 --> 00:11:26,400
TPM and it clears the TPM the rtmp CRS

00:11:22,520 --> 00:11:30,030
all CPUs are a lousy people interrupts

00:11:26,400 --> 00:11:34,920
are disabled and this disappear protects

00:11:30,030 --> 00:11:38,310
the DCE from DMI access and AMD and

00:11:34,920 --> 00:11:40,320
intel use different technologies to do

00:11:38,310 --> 00:11:43,080
that Intel uses something which is

00:11:40,320 --> 00:11:45,800
called caches Rama MD uses something

00:11:43,080 --> 00:11:49,710
which is called device exclusion vector

00:11:45,800 --> 00:11:52,950
then after that dc-dc es is measured by

00:11:49,710 --> 00:11:57,180
the cpu and the result is stored in PCR

00:11:52,950 --> 00:12:01,080
17 before the execution and here also

00:11:57,180 --> 00:12:05,190
there is a difference between Intel AMD

00:12:01,080 --> 00:12:08,400
implementation inter provides ACM for

00:12:05,190 --> 00:12:12,000
for every platform and every ACM is

00:12:08,400 --> 00:12:17,160
signed by Intel in case of AMD the owner

00:12:12,000 --> 00:12:19,950
have to provide the DCE but you are not

00:12:17,160 --> 00:12:22,410
able to verify the signature there's no

00:12:19,950 --> 00:12:26,430
such mechanic mechanism to verify that

00:12:22,410 --> 00:12:30,270
the signature of this e after that the

00:12:26,430 --> 00:12:33,630
DCE and rest the LME is the the DMA

00:12:30,270 --> 00:12:39,260
protected measures and then executed so

00:12:33,630 --> 00:12:41,610
as you can see in case of dynamic launch

00:12:39,260 --> 00:12:45,120
sorry the result is very high integrity

00:12:41,610 --> 00:12:47,730
assertion of the enemy in in this case

00:12:45,120 --> 00:12:50,220
in case get of the time like lunch as

00:12:47,730 --> 00:12:55,410
you can see the fumer is removed from

00:12:50,220 --> 00:12:59,190
this the TCB accept SMI handler so root

00:12:55,410 --> 00:13:01,920
of trust is more mostly mounted in the

00:12:59,190 --> 00:13:05,760
hardware and firmware which is usually

00:13:01,920 --> 00:13:07,080
buggy is removed from the picture and at

00:13:05,760 --> 00:13:11,370
this point I would like to hand over to

00:13:07,080 --> 00:13:15,410
Daniel all right thank you alright so

00:13:11,370 --> 00:13:17,420
transfer the the project itself so

00:13:15,410 --> 00:13:19,640
transfer originated from

00:13:17,420 --> 00:13:21,770
idea I had back in 2014 when I was

00:13:19,640 --> 00:13:26,090
implementing a Ford SIL capability and

00:13:21,770 --> 00:13:31,340
to open XT to be able to Ford SIL the

00:13:26,090 --> 00:13:33,340
platform on an update in an open XT we

00:13:31,340 --> 00:13:36,320
use t boot to launch this in environment

00:13:33,340 --> 00:13:38,060
in order to accomplish the fort sill we

00:13:36,320 --> 00:13:40,670
needed to be able to get to certain bits

00:13:38,060 --> 00:13:44,690
of information from the major launch in

00:13:40,670 --> 00:13:46,880
txt terms in the dynamic launch and in

00:13:44,690 --> 00:13:48,440
the way that t boot was constructed in

00:13:46,880 --> 00:13:51,020
conjunction with his n made some things

00:13:48,440 --> 00:13:53,450
very difficult we weren't able to get to

00:13:51,020 --> 00:13:55,400
the TPM event log that is actually it's

00:13:53,450 --> 00:13:57,950
housed inside the ACMs heap space and

00:13:55,400 --> 00:14:00,170
that's actually blocked out of the

00:13:57,950 --> 00:14:06,080
memory map so zim will not allow you to

00:14:00,170 --> 00:14:07,670
access it boot services is still today

00:14:06,080 --> 00:14:09,140
there's a conflict on who should be

00:14:07,670 --> 00:14:11,870
terminating boot services if you follow

00:14:09,140 --> 00:14:14,660
the specification the TCG's dynamic

00:14:11,870 --> 00:14:16,970
launch specification boot services is

00:14:14,660 --> 00:14:19,430
supposed to be terminated before you do

00:14:16,970 --> 00:14:22,280
the dynamic launch right now the day T

00:14:19,430 --> 00:14:24,410
Bo does it inside of it before it hands

00:14:22,280 --> 00:14:28,250
over to the target system and in our

00:14:24,410 --> 00:14:29,090
case for this situation for open xt t xt

00:14:28,250 --> 00:14:30,800
v or i'm sorry

00:14:29,090 --> 00:14:32,570
zen likes to have access to boot

00:14:30,800 --> 00:14:36,320
services as that as well so we have this

00:14:32,570 --> 00:14:38,390
conflict here t boot can only measure

00:14:36,320 --> 00:14:41,300
what was loaded into memory with it at

00:14:38,390 --> 00:14:43,160
the time that it was started only the

00:14:41,300 --> 00:14:44,900
multi boot modules there's nothing else

00:14:43,160 --> 00:14:49,580
that it has the knowledge of how to do

00:14:44,900 --> 00:14:52,130
or even considered and it only had one

00:14:49,580 --> 00:14:54,530
action at a station actions it basically

00:14:52,130 --> 00:14:57,340
can do in a policy enforcement on a pc

00:14:54,530 --> 00:15:01,190
pre different term and pc our manifest

00:14:57,340 --> 00:15:05,000
yeah and that's the best you can get out

00:15:01,190 --> 00:15:07,100
of it and then it only works for txt

00:15:05,000 --> 00:15:08,750
there was an attempt to consider putting

00:15:07,100 --> 00:15:11,240
AMD support in it and they turned it

00:15:08,750 --> 00:15:13,340
down so you know we need to be able to

00:15:11,240 --> 00:15:17,560
specifically on open xt we needed to be

00:15:13,340 --> 00:15:25,600
able to support both AMD and and intel

00:15:17,560 --> 00:15:28,640
so the motivation continue so because

00:15:25,600 --> 00:15:30,150
doing this is very important we need to

00:15:28,640 --> 00:15:32,010
make sure that we do this

00:15:30,150 --> 00:15:34,410
we need to take the time and make sure

00:15:32,010 --> 00:15:36,180
that we have a nice clean way that we've

00:15:34,410 --> 00:15:40,589
launched the platform that we make these

00:15:36,180 --> 00:15:44,130
strong assertions from so we the project

00:15:40,589 --> 00:15:46,830
isn't meant to focus on solving this

00:15:44,130 --> 00:15:48,690
problem for everybody and then in the

00:15:46,830 --> 00:15:51,180
past dynamic launches have been used

00:15:48,690 --> 00:15:52,980
just for the initial booth phase and the

00:15:51,180 --> 00:15:54,960
fact is is that dynamic launch can be

00:15:52,980 --> 00:15:56,460
ran multiple times through the entire

00:15:54,960 --> 00:16:00,029
lifecycle of the CPU

00:15:56,460 --> 00:16:03,779
all right sorry of a power on power off

00:16:00,029 --> 00:16:05,640
sequence so it's an opportunity to

00:16:03,779 --> 00:16:07,710
establish the current integrity of the

00:16:05,640 --> 00:16:13,529
platform at any time if you want so

00:16:07,710 --> 00:16:16,320
chose to do so and on top of it in the

00:16:13,529 --> 00:16:18,180
last four years now four or five years

00:16:16,320 --> 00:16:22,589
now launch integrity ecosystem has

00:16:18,180 --> 00:16:24,110
gotten extremely rich there's numerous

00:16:22,589 --> 00:16:27,029
roots of truck the roots of trust

00:16:24,110 --> 00:16:28,860
evolved in terms of measurement secure

00:16:27,029 --> 00:16:31,589
proko process have shown up spy

00:16:28,860 --> 00:16:33,150
interposers are in place now you've got

00:16:31,589 --> 00:16:35,400
hybrid solutions starting to come out

00:16:33,150 --> 00:16:37,560
and then on top of it you have vendors

00:16:35,400 --> 00:16:40,860
adopting these capabilities into their

00:16:37,560 --> 00:16:43,080
products so we want the open source

00:16:40,860 --> 00:16:47,010
system open source ecosystem to have

00:16:43,080 --> 00:16:48,810
these things as well so trench boot is a

00:16:47,010 --> 00:16:51,450
cross community integration project

00:16:48,810 --> 00:16:52,800
there is not a one thing that is trench

00:16:51,450 --> 00:16:54,950
but-- we're trying to bring these

00:16:52,800 --> 00:16:59,400
capabilities to all of the open source

00:16:54,950 --> 00:17:00,570
projects that are involved in this one

00:16:59,400 --> 00:17:02,610
of the questions I've gotten is where

00:17:00,570 --> 00:17:04,079
did I get the name so when I was working

00:17:02,610 --> 00:17:07,170
through all of this starting back in

00:17:04,079 --> 00:17:09,240
2014 and looking at all the launch

00:17:07,170 --> 00:17:10,740
integrity system and and the hardware

00:17:09,240 --> 00:17:15,030
and everything else it's it's a muddy

00:17:10,740 --> 00:17:16,860
mess and you know just trying to find a

00:17:15,030 --> 00:17:18,839
way to unify all of that in a way that

00:17:16,860 --> 00:17:21,179
all open source projects could use is

00:17:18,839 --> 00:17:22,650
just it I joked at one point that it's

00:17:21,179 --> 00:17:24,390
like I got a strap on a pair of boots to

00:17:22,650 --> 00:17:28,079
make weight my way through this several

00:17:24,390 --> 00:17:30,240
other people have gotten stuck in so at

00:17:28,079 --> 00:17:32,670
the end the purpose to develop a common

00:17:30,240 --> 00:17:34,950
unified approach to building trust into

00:17:32,670 --> 00:17:40,110
the platform during the launch phase of

00:17:34,950 --> 00:17:42,780
the plat of the platform and then work

00:17:40,110 --> 00:17:44,040
with the open source community to the

00:17:42,780 --> 00:17:45,780
various projects to get the

00:17:44,040 --> 00:17:48,300
unified approach adopted by all of them

00:17:45,780 --> 00:17:51,450
so that way you wind up with this

00:17:48,300 --> 00:17:54,540
ecosystem that any open source Colonel

00:17:51,450 --> 00:17:56,130
on but potentially proprietary kernels

00:17:54,540 --> 00:18:00,660
could use this to launch themselves if

00:17:56,130 --> 00:18:02,190
they wanted to so this brings us to the

00:18:00,660 --> 00:18:03,540
first capability we've been working on

00:18:02,190 --> 00:18:05,940
which is what we're calling secure

00:18:03,540 --> 00:18:11,940
launch for Linux so secure launch for

00:18:05,940 --> 00:18:13,410
Linux is the attempt to bring the to

00:18:11,940 --> 00:18:15,540
enable the Linux kernel to be

00:18:13,410 --> 00:18:19,980
dynamically launched by both AMD and

00:18:15,540 --> 00:18:22,020
Intel specifically the focus is on a

00:18:19,980 --> 00:18:23,670
first launch scenario which is what

00:18:22,020 --> 00:18:26,370
everybody is very familiar with were you

00:18:23,670 --> 00:18:28,200
using you know the dynamic launch as

00:18:26,370 --> 00:18:30,720
part of your boot cycle to establish the

00:18:28,200 --> 00:18:33,000
the initial integrity of the platform

00:18:30,720 --> 00:18:34,650
but you can actually we're looking at

00:18:33,000 --> 00:18:37,010
runtime integrity as well runtime

00:18:34,650 --> 00:18:39,660
launches so that a way you can actually

00:18:37,010 --> 00:18:41,640
use this to launch your kernel upgrade

00:18:39,660 --> 00:18:43,590
through a key exec you could launch an

00:18:41,640 --> 00:18:46,830
integrity kernel that could set there in

00:18:43,590 --> 00:18:48,750
dynamically inspect your system or if

00:18:46,830 --> 00:18:50,010
during a shutdown you want to make sure

00:18:48,750 --> 00:18:51,570
you want to establish the integrity of

00:18:50,010 --> 00:18:53,430
your platform before you persist

00:18:51,570 --> 00:18:55,440
everything to diskless such as an embed

00:18:53,430 --> 00:19:01,260
environments this isn't chance that are

00:18:55,440 --> 00:19:02,690
free to do that so the to compare that

00:19:01,260 --> 00:19:06,330
with the existing

00:19:02,690 --> 00:19:08,190
ecosystem of dynamic launch like I said

00:19:06,330 --> 00:19:09,840
there's been numerous attempts to bring

00:19:08,190 --> 00:19:13,290
dynamic launch into the open-source

00:19:09,840 --> 00:19:14,910
community a lot of these are actually

00:19:13,290 --> 00:19:19,200
all of these have been focused purely on

00:19:14,910 --> 00:19:21,480
the first launch use case the Intel

00:19:19,200 --> 00:19:23,190
based ones are actually XO kernels

00:19:21,480 --> 00:19:25,050
because they try to persist themselves

00:19:23,190 --> 00:19:27,920
for the entire runtime of the system and

00:19:25,050 --> 00:19:31,350
in an exocrine old fashion they hook the

00:19:27,920 --> 00:19:32,670
the sleep states to handle didn't

00:19:31,350 --> 00:19:35,790
dealing with the fact that your trusted

00:19:32,670 --> 00:19:38,220
kernel went into a sleep safe from my

00:19:35,790 --> 00:19:39,720
perspective that's not the appropriate

00:19:38,220 --> 00:19:43,500
approach but we can talk about that

00:19:39,720 --> 00:19:45,210
later and then they have a limited or no

00:19:43,500 --> 00:19:50,970
at the station capability built into

00:19:45,210 --> 00:19:53,760
them at all so the first use Kay first

00:19:50,970 --> 00:19:56,670
launch use case standard use case

00:19:53,760 --> 00:19:57,990
everybody knows this the difference that

00:19:56,670 --> 00:19:59,940
we're doing with trench

00:19:57,990 --> 00:20:01,620
is we're going to expand on it a little

00:19:59,940 --> 00:20:03,090
bit so we're going to properly terminate

00:20:01,620 --> 00:20:07,080
boot services by the bootloader

00:20:03,090 --> 00:20:09,690
and then handle the EBS handoff using

00:20:07,080 --> 00:20:14,899
Linux existing EFI capabilities to

00:20:09,690 --> 00:20:17,580
launch yourself after exit boot services

00:20:14,899 --> 00:20:19,140
Google has this amazing project called

00:20:17,580 --> 00:20:21,960
you root and which they're building

00:20:19,140 --> 00:20:25,529
these tiny init our DS for a variety of

00:20:21,960 --> 00:20:29,100
solutions for embedded boot loaders and

00:20:25,529 --> 00:20:31,020
those so it was a good means for us to

00:20:29,100 --> 00:20:33,000
build a flexible way of doing

00:20:31,020 --> 00:20:36,840
measurements and after stations during

00:20:33,000 --> 00:20:38,520
this launch phase the current focus

00:20:36,840 --> 00:20:41,370
right now is to be able to manage your

00:20:38,520 --> 00:20:44,010
block devices files and system

00:20:41,370 --> 00:20:46,289
information like BMI and then to be able

00:20:44,010 --> 00:20:47,640
to take those measurements and do that

00:20:46,289 --> 00:20:49,049
says stations and then establish the

00:20:47,640 --> 00:20:52,700
integrity of your platform before you

00:20:49,049 --> 00:20:52,700
allowed your target system start running

00:20:54,500 --> 00:21:01,230
and then we will be using the que exec

00:20:58,470 --> 00:21:04,110
interface to do the launches when we

00:21:01,230 --> 00:21:06,059
exit or when we are when the secure

00:21:04,110 --> 00:21:08,789
launch phase is completing we cap the

00:21:06,059 --> 00:21:11,640
PCRs on all platforms that means by

00:21:08,789 --> 00:21:13,350
which we can say we're done intel

00:21:11,640 --> 00:21:15,149
provides us the extra capability that I

00:21:13,350 --> 00:21:17,279
wish AMD had which is the S exit

00:21:15,149 --> 00:21:20,820
instruction which allows us to basically

00:21:17,279 --> 00:21:23,100
close off access to the piece d rtmp CRS

00:21:20,820 --> 00:21:24,720
so the way the measurements can those

00:21:23,100 --> 00:21:29,909
pieces can no longer be extended after

00:21:24,720 --> 00:21:33,779
we're completed that closes up the first

00:21:29,909 --> 00:21:38,279
use case so to to give a basic

00:21:33,779 --> 00:21:40,230
walkthrough walkthrough of it right now

00:21:38,279 --> 00:21:42,120
grub will be able to take measurements

00:21:40,230 --> 00:21:43,770
if you so choose to it it's optional of

00:21:42,120 --> 00:21:45,480
everything it's about the load into

00:21:43,770 --> 00:21:48,000
memory to start the late launch or the

00:21:45,480 --> 00:21:50,460
dynamic locks excuse me it will load

00:21:48,000 --> 00:21:52,100
either the secure loader or the ACM

00:21:50,460 --> 00:21:55,890
depending on whether you're on AMD or

00:21:52,100 --> 00:21:57,720
Intel it'll load a Linux kernel that is

00:21:55,890 --> 00:22:00,990
capable of handling the dynamic launch

00:21:57,720 --> 00:22:03,809
for the secure launch capability and the

00:22:00,990 --> 00:22:07,320
it will then call the respective event

00:22:03,809 --> 00:22:10,139
late launch or a dynamic launch event at

00:22:07,320 --> 00:22:12,050
which point the ACM will hand out do its

00:22:10,139 --> 00:22:13,970
business that's proprietary data and

00:22:12,050 --> 00:22:16,490
tell it will hand off to directly to the

00:22:13,970 --> 00:22:19,580
setup header or the setup code inside

00:22:16,490 --> 00:22:21,080
the kernel and the secure loader we have

00:22:19,580 --> 00:22:23,470
a project where we're building one and

00:22:21,080 --> 00:22:26,150
making it which is going to be is open

00:22:23,470 --> 00:22:28,580
for AMD which will basically set up the

00:22:26,150 --> 00:22:33,050
environment and transition into this

00:22:28,580 --> 00:22:34,970
setup code for the Linux kernel inside

00:22:33,050 --> 00:22:36,410
the set it set up header we we are

00:22:34,970 --> 00:22:38,480
daniel will cover this little more

00:22:36,410 --> 00:22:40,610
detail we'll take the measurements of

00:22:38,480 --> 00:22:43,760
what's necessary within the kernel so

00:22:40,610 --> 00:22:45,560
will we right now works when the piggy

00:22:43,760 --> 00:22:47,690
has been expanded in the VM like VAM

00:22:45,560 --> 00:22:50,090
Linux we take that measurement we

00:22:47,690 --> 00:22:51,590
measure the init Rd so that way we have

00:22:50,090 --> 00:22:52,550
though at least those two measurements

00:22:51,590 --> 00:22:54,020
of the things that we're going to give

00:22:52,550 --> 00:22:59,000
execution to before we turn them over

00:22:54,020 --> 00:23:01,370
once you get into the init Rd it can

00:22:59,000 --> 00:23:03,200
then take it will consume a policy file

00:23:01,370 --> 00:23:04,760
which will tell you what you want to

00:23:03,200 --> 00:23:06,980
measure it will measure those into the

00:23:04,760 --> 00:23:12,590
TPM and then execute your target rent

00:23:06,980 --> 00:23:14,300
time and with that introduction I will

00:23:12,590 --> 00:23:17,900
turn it over to Daniel to cover the

00:23:14,300 --> 00:23:20,510
status on up streaming oh thanks Nell I

00:23:17,900 --> 00:23:22,880
would like to discuss how this idea of

00:23:20,510 --> 00:23:24,800
the change would map to to the current

00:23:22,880 --> 00:23:26,870
at upstream project but at the beginning

00:23:24,800 --> 00:23:29,360
I would like to say something about

00:23:26,870 --> 00:23:32,900
history of the project the project was

00:23:29,360 --> 00:23:35,210
initiated by a purchase solution and the

00:23:32,900 --> 00:23:38,480
company invited the cooperation Oracle

00:23:35,210 --> 00:23:40,940
and fee embed free embed is a small

00:23:38,480 --> 00:23:44,840
company in north part of Poland which

00:23:40,940 --> 00:23:47,780
focuses on developing open source feel

00:23:44,840 --> 00:23:50,590
more for embedded platforms and in

00:23:47,780 --> 00:23:52,940
general are cool focuses on Intel

00:23:50,590 --> 00:23:57,220
implementation of tangible and free

00:23:52,940 --> 00:24:01,790
embed focuses on the AMD implementation

00:23:57,220 --> 00:24:03,920
so how this how this whole idea of the

00:24:01,790 --> 00:24:06,770
tangible product applies to specific

00:24:03,920 --> 00:24:11,060
projects first of all the grab it was

00:24:06,770 --> 00:24:14,120
decided to provide a dc-dc preamble for

00:24:11,060 --> 00:24:16,160
the crop at first because this is the

00:24:14,120 --> 00:24:20,150
most common bootloader in current

00:24:16,160 --> 00:24:22,520
deployments so we are we are working

00:24:20,150 --> 00:24:25,520
currently on on the pro on this project

00:24:22,520 --> 00:24:27,980
and we have to do some

00:24:25,520 --> 00:24:31,250
just in the code first of all we have to

00:24:27,980 --> 00:24:34,190
in turn extend the line Luke's boot

00:24:31,250 --> 00:24:37,190
protocol with a special additional

00:24:34,190 --> 00:24:40,100
kernel infrastructure which I will

00:24:37,190 --> 00:24:44,060
discuss a bit later we have to also add

00:24:40,100 --> 00:24:47,060
some additional comments to identify the

00:24:44,060 --> 00:24:49,640
secure lunch face and additional

00:24:47,060 --> 00:24:53,510
comments to load the DCE modules for

00:24:49,640 --> 00:24:56,480
Intel and for AMD separately and we also

00:24:53,510 --> 00:24:59,000
have to add some dearly ventra locators

00:24:56,480 --> 00:25:01,670
one for Intel as enter another one for

00:24:59,000 --> 00:25:05,150
the DMD SK in it

00:25:01,670 --> 00:25:08,540
AMD development is farther along than in

00:25:05,150 --> 00:25:10,880
the currently we haven't published part

00:25:08,540 --> 00:25:13,220
just yet because currently it doesn't

00:25:10,880 --> 00:25:15,860
work simply we do we do some tests we

00:25:13,220 --> 00:25:19,100
have some difficulties with Intel mm

00:25:15,860 --> 00:25:22,120
quite big difficulties with Intel but if

00:25:19,100 --> 00:25:26,800
everything works then we will release

00:25:22,120 --> 00:25:30,830
the first version of patches SL boot

00:25:26,800 --> 00:25:32,840
this is a small piece of code which we

00:25:30,830 --> 00:25:38,210
took or took from from the T boot

00:25:32,840 --> 00:25:41,420
because we needed something to test

00:25:38,210 --> 00:25:44,090
which will work that same almost out of

00:25:41,420 --> 00:25:46,610
the box so we decided to just strip

00:25:44,090 --> 00:25:51,740
kyboot remove all unneeded pieces and

00:25:46,610 --> 00:25:54,890
just leave at a branch code this is this

00:25:51,740 --> 00:25:57,320
solution just work on Intel because T

00:25:54,890 --> 00:25:59,600
booty boot was developed on Intel and

00:25:57,320 --> 00:26:03,200
this is interim solution we currently

00:25:59,600 --> 00:26:06,200
have this code running we have currently

00:26:03,200 --> 00:26:09,620
system boot boots but there are some

00:26:06,200 --> 00:26:12,110
problems with with network or something

00:26:09,620 --> 00:26:14,000
like that so currently working on that

00:26:12,110 --> 00:26:17,270
this is interim solution we are going to

00:26:14,000 --> 00:26:20,960
move all that code to the grab and put

00:26:17,270 --> 00:26:25,600
post it upstream the kernel info patch I

00:26:20,960 --> 00:26:30,050
was mentioning this thing in the gaba

00:26:25,600 --> 00:26:32,240
slide we have to we have to change

00:26:30,050 --> 00:26:35,240
language boot protocol we have to

00:26:32,240 --> 00:26:37,880
because we have to pass some information

00:26:35,240 --> 00:26:38,700
from the kernel to the to the bootloader

00:26:37,880 --> 00:26:40,830
in

00:26:38,700 --> 00:26:44,340
particular this is entry point to a

00:26:40,830 --> 00:26:47,850
secular lunch code which will be in

00:26:44,340 --> 00:26:50,720
setup part of the kernel and after

00:26:47,850 --> 00:26:55,290
discussion with HPA who is maintainer of

00:26:50,720 --> 00:27:01,110
Linux boot protocol we stated that it is

00:26:55,290 --> 00:27:05,160
needed to extend to extend the protocol

00:27:01,110 --> 00:27:07,500
by a by adding kernel infrastructure we

00:27:05,160 --> 00:27:11,580
have to do that because currently set up

00:27:07,500 --> 00:27:14,880
header has very limited size and - we

00:27:11,580 --> 00:27:19,170
are closing - we are using just final

00:27:14,880 --> 00:27:21,660
bits of this structure so after some

00:27:19,170 --> 00:27:24,090
discussion with him we decided to

00:27:21,660 --> 00:27:28,530
introduce this new structure which will

00:27:24,090 --> 00:27:31,170
be we will not have such limitations and

00:27:28,530 --> 00:27:34,590
can be extended in the future without

00:27:31,170 --> 00:27:40,140
any issues and I have posted two patches

00:27:34,590 --> 00:27:43,740
on Linux kernel mail increased HPA is is

00:27:40,140 --> 00:27:45,690
quite happy with with the implementation

00:27:43,740 --> 00:27:48,750
but he has still some comments and I'm

00:27:45,690 --> 00:27:53,220
going to take into account his comments

00:27:48,750 --> 00:27:57,240
in version number three a secure launch

00:27:53,220 --> 00:27:59,640
phase this is a code which will be put

00:27:57,240 --> 00:28:01,710
into the Linux kernel currently there

00:27:59,640 --> 00:28:07,230
are two sibling patches in development

00:28:01,710 --> 00:28:10,050
Intel sorry Oracle together with upper

00:28:07,230 --> 00:28:14,070
to solution focuses on the Intel txt

00:28:10,050 --> 00:28:17,100
implementation and I'm the sixth about

00:28:14,070 --> 00:28:19,820
implementation is done by 3m but with

00:28:17,100 --> 00:28:23,270
some help from upper - solution and

00:28:19,820 --> 00:28:29,010
Oracle and as I know with I am the AMD

00:28:23,270 --> 00:28:32,310
currently some RF changes so we have to

00:28:29,010 --> 00:28:36,270
we have to introduce some changes into

00:28:32,310 --> 00:28:40,080
complete part of the kernel first of all

00:28:36,270 --> 00:28:44,630
we have to introduce SL entry point and

00:28:40,080 --> 00:28:47,960
we mean minimal code - and

00:28:44,630 --> 00:28:51,800
handler and handler entry from deal deal

00:28:47,960 --> 00:28:54,610
event we also have to add some minimal

00:28:51,800 --> 00:28:58,450
implementation of the Shah and the TPM

00:28:54,610 --> 00:29:01,280
but and this code currently exists but

00:28:58,450 --> 00:29:04,640
after some reviews we realized that it

00:29:01,280 --> 00:29:07,370
is possible to optimize the TPM logic

00:29:04,640 --> 00:29:11,780
and make the codes make the code

00:29:07,370 --> 00:29:16,310
smaller and we also have to add some set

00:29:11,780 --> 00:29:18,290
up some some code to do processing of

00:29:16,310 --> 00:29:23,240
hunt over from the l event in set up

00:29:18,290 --> 00:29:28,190
part of the kernel and your stuff you

00:29:23,240 --> 00:29:32,300
root is a project made by a by Google

00:29:28,190 --> 00:29:35,000
and it is just a simple interface for

00:29:32,300 --> 00:29:39,920
tlme and we will call it a security

00:29:35,000 --> 00:29:43,490
engine for first launch we have to add a

00:29:39,920 --> 00:29:46,280
unit up that functions as a core engine

00:29:43,490 --> 00:29:48,200
for possessing a policy file which

00:29:46,280 --> 00:29:51,770
describes evidence collectors our

00:29:48,200 --> 00:29:54,380
testers and what launcher to run we have

00:29:51,770 --> 00:29:55,760
to add a measurement library that

00:29:54,380 --> 00:29:59,300
provides a core set of evidence

00:29:55,760 --> 00:30:02,660
collectors and we'll be using currently

00:29:59,300 --> 00:30:04,790
existing booting capabilities in the

00:30:02,660 --> 00:30:08,630
gyro to implement a que exact launcher

00:30:04,790 --> 00:30:12,050
and we are going to provide attestation

00:30:08,630 --> 00:30:17,230
in the LME in later forevers in later

00:30:12,050 --> 00:30:20,000
phases of development when we discussed

00:30:17,230 --> 00:30:22,100
the project among among the people it

00:30:20,000 --> 00:30:24,350
appears that there are more and more

00:30:22,100 --> 00:30:28,670
features needed but we are not able to

00:30:24,350 --> 00:30:33,440
do to provide all of them at first step

00:30:28,670 --> 00:30:37,100
so there is growing to-do list

00:30:33,440 --> 00:30:40,580
and first of all we first think which i

00:30:37,100 --> 00:30:43,070
think is worth mentioning is extending

00:30:40,580 --> 00:30:47,200
the K exactly DC preamble implementation

00:30:43,070 --> 00:30:49,850
this way this way you will be able to

00:30:47,200 --> 00:30:53,240
restart a dynamic launch from the

00:30:49,850 --> 00:30:56,320
running cause also we are considering

00:30:53,240 --> 00:30:59,260
adding DCP DC preamble to

00:30:56,320 --> 00:31:04,360
and also we are considering extending

00:30:59,260 --> 00:31:09,370
some some things in Zen we are going to

00:31:04,360 --> 00:31:13,510
make to it exactly I like it to be

00:31:09,370 --> 00:31:17,140
executed from the K exact as a day Lemmy

00:31:13,510 --> 00:31:19,000
and we also going to add DC preamble to

00:31:17,140 --> 00:31:24,580
the design which i think is quite

00:31:19,000 --> 00:31:36,610
interesting idea so that's it

00:31:24,580 --> 00:31:38,020
questions and answers Hey so you

00:31:36,610 --> 00:31:40,270
mentioned being able to get away from

00:31:38,020 --> 00:31:46,330
having the boot firmware as part of the

00:31:40,270 --> 00:31:48,460
TCB what about efi runtime services so

00:31:46,330 --> 00:31:49,680
you don't necessarily need runtime

00:31:48,460 --> 00:31:54,520
services yes you do

00:31:49,680 --> 00:31:58,120
for what p store changing boot

00:31:54,520 --> 00:31:59,980
configuration primarily those but

00:31:58,120 --> 00:32:02,440
there's a few other cases where oh um

00:31:59,980 --> 00:32:04,150
firmware update your guns needs to be

00:32:02,440 --> 00:32:06,540
able to use boot services and runtime

00:32:04,150 --> 00:32:08,560
services and also to configure the

00:32:06,540 --> 00:32:10,900
thumber updates on the next reboots

00:32:08,560 --> 00:32:12,790
right but those do those operations have

00:32:10,900 --> 00:32:14,410
anything to do with the execution of

00:32:12,790 --> 00:32:18,100
your of your operating system that

00:32:14,410 --> 00:32:20,020
you're running and that's calling them

00:32:18,100 --> 00:32:21,490
if their malicious could result in the

00:32:20,020 --> 00:32:23,590
firmware tampering with the states of

00:32:21,490 --> 00:32:25,930
the kernel after your measurements right

00:32:23,590 --> 00:32:27,910
so at that point you're you're

00:32:25,930 --> 00:32:29,230
discussing a runtime my issue as opposed

00:32:27,910 --> 00:32:31,390
to a boot time right I've established

00:32:29,230 --> 00:32:33,010
the integrity I didn't rely on the

00:32:31,390 --> 00:32:36,520
firmware to establish the integrity of

00:32:33,010 --> 00:32:38,530
my operating system I relied on the CPU

00:32:36,520 --> 00:32:39,040
to establish the integrity of what got

00:32:38,530 --> 00:32:41,050
loaded

00:32:39,040 --> 00:32:42,340
that's my load time integrity problem

00:32:41,050 --> 00:32:43,750
now if you want to tackle the runtime

00:32:42,340 --> 00:32:45,340
integrity problem that's a much larger

00:32:43,750 --> 00:32:47,350
problem right it's very difficult right

00:32:45,340 --> 00:32:50,590
you have to be able to inspect things

00:32:47,350 --> 00:32:53,560
and die to decide afterwards whether or

00:32:50,590 --> 00:32:55,180
not or after things have started

00:32:53,560 --> 00:32:56,560
executing and things have changed

00:32:55,180 --> 00:32:57,760
concern in terms of the state of the

00:32:56,560 --> 00:32:59,890
application you have to be able to

00:32:57,760 --> 00:33:04,450
inspect that and make assertions about

00:32:59,890 --> 00:33:05,950
that so yes that problem is not a

00:33:04,450 --> 00:33:07,540
dynamic launch problem that is a

00:33:05,950 --> 00:33:09,820
platform problem period it doesn't

00:33:07,540 --> 00:33:12,240
matter whether you're you've done

00:33:09,820 --> 00:33:14,680
only an SRTM boot or if you've only done

00:33:12,240 --> 00:33:16,480
dynamic launch boot if you've got

00:33:14,680 --> 00:33:17,680
corrupt firmware you've got corrupt

00:33:16,480 --> 00:33:19,450
firmware whether it was corrupted

00:33:17,680 --> 00:33:21,010
whether it was corrupted as part of the

00:33:19,450 --> 00:33:22,960
launch or it was corrupted after our

00:33:21,010 --> 00:33:25,150
execution it's still a next runtime

00:33:22,960 --> 00:33:26,620
problem so as the model that's even in a

00:33:25,150 --> 00:33:28,450
dynamic launch environments I should be

00:33:26,620 --> 00:33:30,100
looking at the srtm values as well to

00:33:28,450 --> 00:33:32,200
make us attack yes you should always you

00:33:30,100 --> 00:33:35,320
should okay because you're trusting the

00:33:32,200 --> 00:33:39,220
SRTM to have initialized the platform

00:33:35,320 --> 00:33:40,690
right so you still have that you we try

00:33:39,220 --> 00:33:42,160
to minimize that as much as possible at

00:33:40,690 --> 00:33:44,800
the dynamic launch but at the end of the

00:33:42,160 --> 00:33:46,330
day the sec face is what puts the memory

00:33:44,800 --> 00:33:47,650
timings in there if that was corrupted

00:33:46,330 --> 00:33:49,450
and it decided to screw with that you're

00:33:47,650 --> 00:33:53,140
you're done right there's nothing we can

00:33:49,450 --> 00:33:55,240
do so the we still care about the SRTM

00:33:53,140 --> 00:33:57,610
we still can't but the key point here is

00:33:55,240 --> 00:33:59,350
that we want to remove and reduce the

00:33:57,610 --> 00:34:02,560
trust chain that was used to launch your

00:33:59,350 --> 00:34:04,660
operating system so we're trying to

00:34:02,560 --> 00:34:06,670
introduce the axiom on we're trying to

00:34:04,660 --> 00:34:09,670
increase the the integrity in the

00:34:06,670 --> 00:34:10,930
platform but it's a holistic problem

00:34:09,670 --> 00:34:13,450
that's the whole point that we talked

00:34:10,930 --> 00:34:15,670
about and these roots of trust I tried

00:34:13,450 --> 00:34:17,350
away from it but the fact is is like you

00:34:15,670 --> 00:34:19,420
know the trust is there you can't drive

00:34:17,350 --> 00:34:21,310
it to zero right you can't decide that

00:34:19,420 --> 00:34:22,240
it's optional it's there it's the

00:34:21,310 --> 00:34:24,520
question of whether or not it's an

00:34:22,240 --> 00:34:26,140
implicit or an explicit trust if you're

00:34:24,520 --> 00:34:28,120
only going to be implicitly entrusted

00:34:26,140 --> 00:34:29,890
then you might as well just implicitly

00:34:28,120 --> 00:34:31,750
trust the entire platform we care about

00:34:29,890 --> 00:34:34,000
trying to make that trust explicit we're

00:34:31,750 --> 00:34:36,370
trying to create contracts between us

00:34:34,000 --> 00:34:37,810
and the hardware to make sure that

00:34:36,370 --> 00:34:43,780
everything in the running state is

00:34:37,810 --> 00:34:46,390
correct as best as we can if I may add

00:34:43,780 --> 00:34:49,780
something as far as I know you are able

00:34:46,390 --> 00:34:52,120
to avoid some runtime services calls for

00:34:49,780 --> 00:34:53,830
example you know some companies try to

00:34:52,120 --> 00:34:56,530
avoid this course which are needed to

00:34:53,830 --> 00:34:58,870
change the boot order of the platform by

00:34:56,530 --> 00:35:02,770
using external device like a BMC and

00:34:58,870 --> 00:35:06,160
variable to set the boot order of the

00:35:02,770 --> 00:35:08,590
machine using open vm BMC or something

00:35:06,160 --> 00:35:11,530
like that then you are not able sorry

00:35:08,590 --> 00:35:14,260
then you do not need to use runtime

00:35:11,530 --> 00:35:16,030
services to change that order but in

00:35:14,260 --> 00:35:18,600
case of pistil of course it is much more

00:35:16,030 --> 00:35:18,600
difficult I think

00:35:19,910 --> 00:35:25,979
um I guess a couple things let me start

00:35:23,279 --> 00:35:28,619
with the runtime issue you may I'm Monty

00:35:25,979 --> 00:35:31,049
Eisen by the way from yeah it's alright

00:35:28,619 --> 00:35:33,390
no something about this um he made a

00:35:31,049 --> 00:35:36,749
statement earlier about the SMI handler

00:35:33,390 --> 00:35:40,410
yes so that's up to the OEM Intel txt

00:35:36,749 --> 00:35:43,469
does provide support as of 2015 I think

00:35:40,410 --> 00:35:45,869
yeah support for the STM it's entirely

00:35:43,469 --> 00:35:48,719
up to the OEM as to whether to provide

00:35:45,869 --> 00:35:52,079
it there is some open-source STM's

00:35:48,719 --> 00:35:54,630
available if that's an area to me the SS

00:35:52,079 --> 00:35:56,999
my handler is much scarier yeah and the

00:35:54,630 --> 00:35:58,380
runtime Huey if I yes so that's the

00:35:56,999 --> 00:36:00,719
thing I'd be worried about all right I

00:35:58,380 --> 00:36:03,719
agree yeah so I just wanted to make that

00:36:00,719 --> 00:36:07,199
correction DL entry is the generic term

00:36:03,719 --> 00:36:09,359
that we used in the spec for s enter so

00:36:07,199 --> 00:36:13,219
they're synonymous didn't want to but

00:36:09,359 --> 00:36:15,660
you know put s enter into an industry

00:36:13,219 --> 00:36:18,630
standard specification and there was one

00:36:15,660 --> 00:36:20,939
other correct so everybody trying to

00:36:18,630 --> 00:36:23,269
blank it all right now but yeah I could

00:36:20,939 --> 00:36:26,489
probably give you some help in this area

00:36:23,269 --> 00:36:28,799
I mean yes you're correct so just a

00:36:26,489 --> 00:36:30,900
touch on your point so for those that

00:36:28,799 --> 00:36:33,269
aren't aware there is coreboot they

00:36:30,900 --> 00:36:36,900
actually hire implementing txt support

00:36:33,269 --> 00:36:39,239
as well as STM support so what Monty was

00:36:36,900 --> 00:36:41,999
touching at is the fact that when you do

00:36:39,239 --> 00:36:44,579
a dynamic launch and s enter on an Intel

00:36:41,999 --> 00:36:47,539
txt platform and you have an STM present

00:36:44,579 --> 00:36:50,549
the ACM will actually interact with the

00:36:47,539 --> 00:36:57,259
STM to establish the integrity of your

00:36:50,549 --> 00:37:02,369
SMI handler until more mainstream

00:36:57,259 --> 00:37:04,049
providers adopt that Dell HP you know we

00:37:02,369 --> 00:37:06,929
don't have anything that can handle the

00:37:04,049 --> 00:37:11,039
SMI everybody everybody is beholden by

00:37:06,929 --> 00:37:14,660
the SMI at this point the handler so all

00:37:11,039 --> 00:37:17,660
right any other questions any comments

00:37:14,660 --> 00:37:17,660
comments

00:37:17,820 --> 00:37:20,220
all right thank you very much thank you

00:37:19,740 --> 00:37:24,050
guys

00:37:20,220 --> 00:37:24,050

YouTube URL: https://www.youtube.com/watch?v=DbpCU9iSi4g


