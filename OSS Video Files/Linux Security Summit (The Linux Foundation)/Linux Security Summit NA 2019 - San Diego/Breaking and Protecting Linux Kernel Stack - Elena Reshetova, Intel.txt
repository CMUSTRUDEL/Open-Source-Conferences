Title: Breaking and Protecting Linux Kernel Stack - Elena Reshetova, Intel
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Breaking and Protecting Linux Kernel Stack - Elena Reshetova, Intel

Linux kernel stack has always been a popular attack target due to its simple structure and predictable deterministic operation. The upstream Linux kernel has been somewhat slow on implementing various protections against these attacks, but nonetheless it did made a number of changes that notably decreased attacker's success chances, namely vmalloc-based stack allocation with guard pages, thread_info removal from the stack, VLAs removal, the upstream port of the STACKLEAK grsecurity feature, etc. However, are these protections enough to combat the stack-based attacks or should we do more?This talk first presents history of stack-based attacks that are applicable to the Linux kernel together with existing implemented protections. Next it presents the case for further improving security of the kernel stack using RANDOMIZE_KSTACK_OFFSET with its challenges and performance implications.
Captions: 
	00:00:00,030 --> 00:00:04,700
okay good afternoon everyone can you

00:00:01,800 --> 00:00:08,189
hear me well it's not quite sure but

00:00:04,700 --> 00:00:10,500
louder it's this better okay I'll try

00:00:08,189 --> 00:00:13,679
I'm not very good to talking loudly but

00:00:10,500 --> 00:00:15,719
I'll try so I hope everyone hasn't had

00:00:13,679 --> 00:00:17,279
enjoyable lunch and delicious lunch so

00:00:15,719 --> 00:00:18,779
it's always a challenge to give it to a

00:00:17,279 --> 00:00:20,369
graph two lines because everyone starts

00:00:18,779 --> 00:00:23,250
to kind of falling asleep so I'll try to

00:00:20,369 --> 00:00:26,460
make it entertaining and and so this

00:00:23,250 --> 00:00:29,580
talk is kind of result of means I'm

00:00:26,460 --> 00:00:31,590
around having classed autumn trying to

00:00:29,580 --> 00:00:33,809
kind of our research into the topic okay

00:00:31,590 --> 00:00:35,850
so we have a Linux kernel stock it has

00:00:33,809 --> 00:00:39,420
been kind of our targets of various a

00:00:35,850 --> 00:00:40,770
talk for breed a long while and and I

00:00:39,420 --> 00:00:42,270
was trying to understand okay so what's

00:00:40,770 --> 00:00:44,579
the current status because there were

00:00:42,270 --> 00:00:46,890
some country measures marriage notable

00:00:44,579 --> 00:00:48,300
control measures merged in past to

00:00:46,890 --> 00:00:49,559
combat some of his attacks and I was

00:00:48,300 --> 00:00:51,030
trying to understand okay so what's the

00:00:49,559 --> 00:00:53,610
current status so I think good now

00:00:51,030 --> 00:00:55,170
what's missing Dominion to do still

00:00:53,610 --> 00:00:59,250
something or we can just say that a

00:00:55,170 --> 00:01:01,410
previous era is done and so so this is

00:00:59,250 --> 00:01:03,390
basically what this talk is about so I

00:01:01,410 --> 00:01:04,920
will try to give you also so you know

00:01:03,390 --> 00:01:06,600
the transfer of questions of course I

00:01:04,920 --> 00:01:08,460
had to go ahead and start it all the

00:01:06,600 --> 00:01:10,590
existing a talks and the country

00:01:08,460 --> 00:01:12,659
measures and Toronto not just study

00:01:10,590 --> 00:01:15,150
details the feature for talks because I

00:01:12,659 --> 00:01:17,009
mean you can I can give it to Oakland

00:01:15,150 --> 00:01:19,170
explaining you wanna Vista talks for an

00:01:17,009 --> 00:01:21,000
hour easily and and this is not with my

00:01:19,170 --> 00:01:22,860
goal here my goal here is trying to and

00:01:21,000 --> 00:01:24,509
this was not my goal or Superman I try

00:01:22,860 --> 00:01:26,460
to study so I try to kind of understand

00:01:24,509 --> 00:01:28,290
whatever patterns whatever current

00:01:26,460 --> 00:01:31,100
common things with why attackers is

00:01:28,290 --> 00:01:34,320
succeeding constantly in this area so

00:01:31,100 --> 00:01:36,299
and and when I did some gap analysis

00:01:34,320 --> 00:01:37,920
after and and various also proposed

00:01:36,299 --> 00:01:40,650
protection which we tried to merge the

00:01:37,920 --> 00:01:42,899
main line starting from maybe new year

00:01:40,650 --> 00:01:45,299
or time frame I'm not very optimistic

00:01:42,899 --> 00:01:50,399
now to to get merged after all so but

00:01:45,299 --> 00:01:52,259
I'll get there so so before I guess here

00:01:50,399 --> 00:01:54,270
I don't have to explain anyone why it's

00:01:52,259 --> 00:01:56,399
important so why attackers really go

00:01:54,270 --> 00:01:58,829
after Linux kernel while it's such an

00:01:56,399 --> 00:02:00,869
attractive target if you are for some

00:01:58,829 --> 00:02:02,880
reason not aware about it I encourage

00:02:00,869 --> 00:02:06,149
you to go listen to a case are talking

00:02:02,880 --> 00:02:08,369
on Wednesday and kernel self protection

00:02:06,149 --> 00:02:10,530
project so he'll explain you can grade

00:02:08,369 --> 00:02:12,990
it is by kernel is such a nice target

00:02:10,530 --> 00:02:14,880
but what I kind of started

00:02:12,990 --> 00:02:17,390
give myself why back Linux kernel tread

00:02:14,880 --> 00:02:21,900
stock so so while the kernels talk and

00:02:17,390 --> 00:02:24,950
to answer this question is that so I

00:02:21,900 --> 00:02:28,320
would like to kind of keep you kind of

00:02:24,950 --> 00:02:29,790
small arm I mean there are two main

00:02:28,320 --> 00:02:31,800
things that usually if you an exploit

00:02:29,790 --> 00:02:33,810
writer and you're trying to write an

00:02:31,800 --> 00:02:35,880
envelope block working explode against

00:02:33,810 --> 00:02:37,110
way kernel not just Linux kernel any

00:02:35,880 --> 00:02:38,640
operating system kernel I'm

00:02:37,110 --> 00:02:39,690
concentrating mostly on Linux care

00:02:38,640 --> 00:02:41,760
because I don't know actually anything

00:02:39,690 --> 00:02:43,200
else apart from Linux but if you're

00:02:41,760 --> 00:02:44,730
trying to write an exploit against a

00:02:43,200 --> 00:02:45,930
kernel there are too many things you

00:02:44,730 --> 00:02:47,940
should remember when you're comparing

00:02:45,930 --> 00:02:50,190
your kind of explode right into the user

00:02:47,940 --> 00:02:52,110
space the first one being is that in

00:02:50,190 --> 00:02:54,060
user space exploitation I mean if you

00:02:52,110 --> 00:02:56,730
crash to your process which you're about

00:02:54,060 --> 00:02:58,620
to exploit it's usually not so bad so I

00:02:56,730 --> 00:03:00,690
mean you can recovery process will get

00:02:58,620 --> 00:03:04,050
usually restarted unless you have very

00:03:00,690 --> 00:03:05,550
kind of highly sensitive intrusion

00:03:04,050 --> 00:03:07,710
detection system it won't didn't get

00:03:05,550 --> 00:03:09,570
probably noticed because I'm impressed

00:03:07,710 --> 00:03:12,330
you suspect birds tend to crash and they

00:03:09,570 --> 00:03:14,880
will get restarted and so on so if you

00:03:12,330 --> 00:03:15,930
now in a kernel exploit area and you

00:03:14,880 --> 00:03:17,820
actually crashed because if you

00:03:15,930 --> 00:03:19,500
something goes wrong and if you kind of

00:03:17,820 --> 00:03:21,600
screwed up or some offsets and things

00:03:19,500 --> 00:03:22,190
you're gonna crash the kernel and that's

00:03:21,600 --> 00:03:24,840
much worse

00:03:22,190 --> 00:03:26,220
so you are because I mean it's much

00:03:24,840 --> 00:03:28,620
worse for many reasons first of all

00:03:26,220 --> 00:03:30,870
there's no automatic restart possibility

00:03:28,620 --> 00:03:33,930
so I mean somebody will be the powerless

00:03:30,870 --> 00:03:35,700
machine again and you get it back to you

00:03:33,930 --> 00:03:38,010
second if you are targeting any

00:03:35,700 --> 00:03:40,560
production system with high outs it will

00:03:38,010 --> 00:03:42,600
raise some alarms because kernel crushes

00:03:40,560 --> 00:03:44,070
is not so kind of standard meant you're

00:03:42,600 --> 00:03:47,370
not expecting our kernels to crush

00:03:44,070 --> 00:03:49,140
randomly and then also when even if you

00:03:47,370 --> 00:03:51,570
kind of everything is okay and kernel is

00:03:49,140 --> 00:03:53,160
restarted machine is restarted you most

00:03:51,570 --> 00:03:54,540
likely have to start from zero because

00:03:53,160 --> 00:03:56,490
some things have changed if it's

00:03:54,540 --> 00:03:57,840
randomization in place your layouts have

00:03:56,490 --> 00:04:00,570
changed and you'll have to start

00:03:57,840 --> 00:04:02,400
figuring how to lower and so this this

00:04:00,570 --> 00:04:03,930
thing is but it's like if you read the

00:04:02,400 --> 00:04:05,730
books and kernel exploitation they will

00:04:03,930 --> 00:04:07,590
keep it like over every single second

00:04:05,730 --> 00:04:09,060
page is like do not crush the target do

00:04:07,590 --> 00:04:11,459
not crush the target so this is very

00:04:09,060 --> 00:04:13,110
important for attackers and the second

00:04:11,459 --> 00:04:14,610
thing why it's different when you write

00:04:13,110 --> 00:04:17,070
an exploit against the kernel is that

00:04:14,610 --> 00:04:18,570
you really have much less understanding

00:04:17,070 --> 00:04:19,859
of a memory layout to route you what

00:04:18,570 --> 00:04:21,770
you're trying to play with so in the

00:04:19,859 --> 00:04:24,419
user space attacking particular process

00:04:21,770 --> 00:04:25,830
usually have quite some understanding of

00:04:24,419 --> 00:04:26,310
what push process what libraries are

00:04:25,830 --> 00:04:28,470
good

00:04:26,310 --> 00:04:30,180
what kind of things happening in a car

00:04:28,470 --> 00:04:31,530
how is totally different so in in

00:04:30,180 --> 00:04:32,670
particular target you might have

00:04:31,530 --> 00:04:35,040
different set of processes running

00:04:32,670 --> 00:04:36,810
during different system goes everything

00:04:35,040 --> 00:04:38,460
like interrupts happening everything can

00:04:36,810 --> 00:04:40,440
kind of affect all of this picture and

00:04:38,460 --> 00:04:43,500
you will have much less visibility and

00:04:40,440 --> 00:04:45,540
control over it so threat in mind so

00:04:43,500 --> 00:04:47,070
what is so special about Linux kernel

00:04:45,540 --> 00:04:48,870
stock which kind of makes it a tractable

00:04:47,070 --> 00:04:51,419
I've kind of named one of the three

00:04:48,870 --> 00:04:52,830
things which I think it's important so

00:04:51,419 --> 00:04:54,930
first of all it has a deterministic

00:04:52,830 --> 00:04:58,290
structure so here I have an example of

00:04:54,930 --> 00:05:01,919
Vista kernel stack for x86 64 so it's

00:04:58,290 --> 00:05:03,510
actually four pages of size grows

00:05:01,919 --> 00:05:05,370
downwards because of how the stack is

00:05:03,510 --> 00:05:08,340
positioned in the memories of hydras

00:05:05,370 --> 00:05:11,250
being and Lord rest being a button it

00:05:08,340 --> 00:05:13,650
kind of grows down so it's having these

00:05:11,250 --> 00:05:16,260
or it's usually starts so what you use

00:05:13,650 --> 00:05:18,270
this stock for I think everyone knows it

00:05:16,260 --> 00:05:19,950
but just in case so for example if your

00:05:18,270 --> 00:05:22,560
process is your Fred running an easy

00:05:19,950 --> 00:05:24,270
spacious is called and at that point you

00:05:22,560 --> 00:05:26,490
need to you're transitioning into a

00:05:24,270 --> 00:05:28,020
kernel space and the kernel needs to

00:05:26,490 --> 00:05:31,320
start serving web sees calls on behalf

00:05:28,020 --> 00:05:33,479
of for your behalf and you can't allow

00:05:31,320 --> 00:05:35,160
the kernel executes on a user space

00:05:33,479 --> 00:05:37,620
stock because it's unsafe so you're

00:05:35,160 --> 00:05:39,690
gonna use this nice small and compact

00:05:37,620 --> 00:05:41,700
stocks to kind of process your syscall

00:05:39,690 --> 00:05:43,200
for example and it's going to be very

00:05:41,700 --> 00:05:44,880
deterministic how this whole thing is

00:05:43,200 --> 00:05:46,470
going to be layout so we're going to

00:05:44,880 --> 00:05:47,669
have a pitcher extraction beginning

00:05:46,470 --> 00:05:49,710
which is gonna have some of your Cisco

00:05:47,669 --> 00:05:51,570
parameters toward and some very

00:05:49,710 --> 00:05:52,890
important figs and many more starters

00:05:51,570 --> 00:05:54,450
your processing your Cisco landfalling

00:05:52,890 --> 00:05:56,100
function you'll start piling your stack

00:05:54,450 --> 00:05:58,650
frame similar work you do in userspace

00:05:56,100 --> 00:06:00,090
some of the part it will be unused it

00:05:58,650 --> 00:06:02,220
just builds but you'll have this special

00:06:00,090 --> 00:06:05,070
trading for structure located at the

00:06:02,220 --> 00:06:07,979
bottom now it's not a case anymore if

00:06:05,070 --> 00:06:10,020
you're having that that config option on

00:06:07,979 --> 00:06:11,160
its own as you can see it's very

00:06:10,020 --> 00:06:13,110
deterministic

00:06:11,160 --> 00:06:15,300
every time you're gonna enter a cisco

00:06:13,110 --> 00:06:18,510
because the spaces are located once only

00:06:15,300 --> 00:06:20,220
for each Fred so any subsequent syscall

00:06:18,510 --> 00:06:22,950
you're going to enter and start growing

00:06:20,220 --> 00:06:25,050
your stock from the same place down and

00:06:22,950 --> 00:06:26,250
and kind of exit to need and you're

00:06:25,050 --> 00:06:28,950
gonna have the same of course stack

00:06:26,250 --> 00:06:30,300
frames might be different and basically

00:06:28,950 --> 00:06:32,100
what kind of this call you're processing

00:06:30,300 --> 00:06:35,640
but still there's a lot of deterministic

00:06:32,100 --> 00:06:37,020
and usage and it's highly used because

00:06:35,640 --> 00:06:38,590
well this is always what you're going to

00:06:37,020 --> 00:06:41,200
use for processing syscall

00:06:38,590 --> 00:06:43,180
it's predictable because this is how way

00:06:41,200 --> 00:06:45,370
you're going to be using and it's also

00:06:43,180 --> 00:06:47,650
as many things have shown usually stock

00:06:45,370 --> 00:06:51,010
likes a very common so it's quite easy

00:06:47,650 --> 00:06:52,570
for Tucker's to locate various on this

00:06:51,010 --> 00:06:54,130
duck is actually situated in your memory

00:06:52,570 --> 00:06:55,660
so what it helps you combating this

00:06:54,130 --> 00:06:58,420
thing which you don't quite have his

00:06:55,660 --> 00:07:00,070
visibility of memory out so these are

00:06:58,420 --> 00:07:02,290
kind of the three things which I believe

00:07:00,070 --> 00:07:03,460
which has depending on very different

00:07:02,290 --> 00:07:05,320
like you can have very different to

00:07:03,460 --> 00:07:07,630
talks but still this fear free things

00:07:05,320 --> 00:07:11,290
have been like a key of what at least

00:07:07,630 --> 00:07:13,330
also been re kind of important things

00:07:11,290 --> 00:07:14,830
are stalkers so now before going to

00:07:13,330 --> 00:07:17,080
explain it is a talks I want to kind of

00:07:14,830 --> 00:07:19,540
make one distinction because it confused

00:07:17,080 --> 00:07:21,280
me and past and and sometimes it also

00:07:19,540 --> 00:07:24,130
confuses people because terminology is

00:07:21,280 --> 00:07:25,570
kind of bit confusing so there are two

00:07:24,130 --> 00:07:27,340
different types of attack so everyone

00:07:25,570 --> 00:07:29,590
usually knows what buffer overflow is so

00:07:27,340 --> 00:07:30,970
this is luck I showed an example of a

00:07:29,590 --> 00:07:33,100
kernel stalker but to use this base

00:07:30,970 --> 00:07:35,710
circle lokanathan they actually started

00:07:33,100 --> 00:07:38,680
to have this old talk timeline so the

00:07:35,710 --> 00:07:40,150
talk started back in 1996 of userspace

00:07:38,680 --> 00:07:41,680
so what you would typically have you

00:07:40,150 --> 00:07:43,479
have your step frame you'll have an

00:07:41,680 --> 00:07:45,370
argument you offer this function you

00:07:43,479 --> 00:07:48,100
have a return address and when you start

00:07:45,370 --> 00:07:50,229
finding your local variables and if you

00:07:48,100 --> 00:07:52,840
manage to have my local buffer which is

00:07:50,229 --> 00:07:54,850
located and developer didn't do due

00:07:52,840 --> 00:07:56,560
diligence you can it allows you to

00:07:54,850 --> 00:07:59,200
doesn't check proper boundaries you can

00:07:56,560 --> 00:08:00,940
overflow it because students tab grows

00:07:59,200 --> 00:08:02,890
downwards you're going to overflow the

00:08:00,940 --> 00:08:04,479
other way around and you go over right

00:08:02,890 --> 00:08:06,340
we return address and this is a

00:08:04,479 --> 00:08:08,979
classical buffer overflow and there's a

00:08:06,340 --> 00:08:10,960
long history of attacks and protections

00:08:08,979 --> 00:08:13,300
against it but it's not quite off

00:08:10,960 --> 00:08:15,310
attacks I'm gonna be talking now so but

00:08:13,300 --> 00:08:16,960
I'm going to be talking now mostly it's

00:08:15,310 --> 00:08:19,450
what we call a stack overflows and I

00:08:16,960 --> 00:08:20,350
stole the definition from or one

00:08:19,450 --> 00:08:22,960
researcher

00:08:20,350 --> 00:08:24,669
see on uber hide he has been actually

00:08:22,960 --> 00:08:27,430
behind some of his attacks it I'm going

00:08:24,669 --> 00:08:28,750
to show you and on so his definition was

00:08:27,430 --> 00:08:30,850
at the stack pointer when the stack

00:08:28,750 --> 00:08:32,830
pointer gets decremented beyond intended

00:08:30,850 --> 00:08:34,240
bouts of being memory which was

00:08:32,830 --> 00:08:35,680
allocated for stock this is what he

00:08:34,240 --> 00:08:36,990
calls stock overflow and I really like

00:08:35,680 --> 00:08:39,280
his definition it's very kind of

00:08:36,990 --> 00:08:40,810
descriptive so here you can see a stack

00:08:39,280 --> 00:08:42,880
pointer because when you execute on a

00:08:40,810 --> 00:08:44,260
stock you're you always to keep it

00:08:42,880 --> 00:08:47,350
tracking where your stack pointer

00:08:44,260 --> 00:08:49,360
pointing to and if you somehow by doing

00:08:47,350 --> 00:08:51,050
some something you manage to get your

00:08:49,360 --> 00:08:52,700
stack pointer out this is the stock

00:08:51,050 --> 00:08:55,580
so this is look very important to

00:08:52,700 --> 00:08:57,080
understand not to get confusing and and

00:08:55,580 --> 00:08:58,700
now I'm going to walk you fastly for

00:08:57,080 --> 00:09:01,430
some of their talks and I try to

00:08:58,700 --> 00:09:03,350
converse many more talks and I tried to

00:09:01,430 --> 00:09:05,510
select kind of via talks based on the

00:09:03,350 --> 00:09:07,399
class of attacks it represents to show

00:09:05,510 --> 00:09:09,440
you one particular kind of interesting

00:09:07,399 --> 00:09:10,730
pattern which photographers used and it

00:09:09,440 --> 00:09:12,560
will help us to understand the

00:09:10,730 --> 00:09:16,550
mitigations which were employed here

00:09:12,560 --> 00:09:17,839
which were developed later so and as I

00:09:16,550 --> 00:09:19,610
said I don't have time to go into

00:09:17,839 --> 00:09:21,260
details but I will try to highlight the

00:09:19,610 --> 00:09:22,970
most important things about each attack

00:09:21,260 --> 00:09:26,180
so the first attack I'm going to show

00:09:22,970 --> 00:09:29,240
you is from 2011 so and it used to be

00:09:26,180 --> 00:09:31,160
and I have references at the end for all

00:09:29,240 --> 00:09:32,779
the slides behind each of his attacks on

00:09:31,160 --> 00:09:35,630
courage if you're interested in details

00:09:32,779 --> 00:09:37,880
and we can talk or softer but we can go

00:09:35,630 --> 00:09:39,260
ahead also and check the attacks they're

00:09:37,880 --> 00:09:40,910
really interesting human details I

00:09:39,260 --> 00:09:43,250
relaxed many of them are really like

00:09:40,910 --> 00:09:45,800
pieces of hearts or in certain extent so

00:09:43,250 --> 00:09:48,200
so the first set up is this our initial

00:09:45,800 --> 00:09:52,279
our stock so it's actually cases attack

00:09:48,200 --> 00:09:54,260
so on so what it did it used with our

00:09:52,279 --> 00:09:56,270
properties on a property just two

00:09:54,260 --> 00:09:58,040
feature of it you might have an

00:09:56,270 --> 00:10:00,500
uninitialized variable located on a

00:09:58,040 --> 00:10:03,500
stock so what it is it's usually kind of

00:10:00,500 --> 00:10:05,440
some object and it's struck to Union

00:10:03,500 --> 00:10:08,120
Union and was in this particular case

00:10:05,440 --> 00:10:10,550
which developer in certain paths may

00:10:08,120 --> 00:10:12,110
forget to initialize some part of it so

00:10:10,550 --> 00:10:14,390
explicitly initialized in the beginning

00:10:12,110 --> 00:10:16,940
and if you manage to find to another

00:10:14,390 --> 00:10:18,620
lapping path like subsequent seize goal

00:10:16,940 --> 00:10:20,240
in this case it actually was the same

00:10:18,620 --> 00:10:22,820
syscalls just with different parameters

00:10:20,240 --> 00:10:24,770
so if you manage to overlap you find an

00:10:22,820 --> 00:10:27,020
overlapping path which kind of so you

00:10:24,770 --> 00:10:29,390
kind of strategy here would be but you

00:10:27,020 --> 00:10:32,420
use first Cisco to pre shield some data

00:10:29,390 --> 00:10:34,279
and bet are kind of just but later one

00:10:32,420 --> 00:10:36,440
would be this this part of the data used

00:10:34,279 --> 00:10:38,149
in a struct later on so you prefilled

00:10:36,440 --> 00:10:40,010
the date of attack on control value and

00:10:38,149 --> 00:10:42,260
are nearly sure subsequence II is called

00:10:40,010 --> 00:10:44,420
where you will use this initialized kind

00:10:42,260 --> 00:10:46,459
of pre field data for you to resolve it

00:10:44,420 --> 00:10:48,920
and this is possible because as I said

00:10:46,459 --> 00:10:50,839
meant to be colonel stock is done in a

00:10:48,920 --> 00:10:53,089
way but each subsequences call starts

00:10:50,839 --> 00:10:54,680
from the same place it goes down and

00:10:53,089 --> 00:10:56,930
kind of starts building with the frames

00:10:54,680 --> 00:10:58,699
and when it exited exits but nobody

00:10:56,930 --> 00:11:00,270
cleans the stock after you it's it has

00:10:58,699 --> 00:11:03,930
whatever it had from previous

00:11:00,270 --> 00:11:06,540
so it's possible and what is commonly

00:11:03,930 --> 00:11:09,029
also used in these cases is this copy -

00:11:06,540 --> 00:11:10,709
Oh copy from user primitives so there

00:11:09,029 --> 00:11:13,290
will be primitives which I used to copy

00:11:10,709 --> 00:11:15,839
data to and from between a user space in

00:11:13,290 --> 00:11:17,459
the kernel and here it was a copy from

00:11:15,839 --> 00:11:20,970
user date and this particular table but

00:11:17,459 --> 00:11:22,830
others are also published so what you do

00:11:20,970 --> 00:11:25,350
here is that you will if you're able to

00:11:22,830 --> 00:11:27,839
find twist copy from user call with the

00:11:25,350 --> 00:11:30,390
destination pointer which you can

00:11:27,839 --> 00:11:34,170
pre-fill using business with previous

00:11:30,390 --> 00:11:36,180
kind of proceeding Cisco so you able to

00:11:34,170 --> 00:11:40,470
influence basically the destination from

00:11:36,180 --> 00:11:42,420
there kind of to where data is copied to

00:11:40,470 --> 00:11:44,820
so what you're basically creating is

00:11:42,420 --> 00:11:46,770
arbitrary write primitive what kind of

00:11:44,820 --> 00:11:48,870
exploit others call it so which means

00:11:46,770 --> 00:11:51,690
that you're able to arbitrary who write

00:11:48,870 --> 00:11:54,209
kernel addresses at certain places and

00:11:51,690 --> 00:11:55,890
it's very powerful and in this case and

00:11:54,209 --> 00:11:57,630
and how you do take it from very where

00:11:55,890 --> 00:11:59,130
talk it's actually not so important for

00:11:57,630 --> 00:12:01,290
in many ways and it's like you mentioned

00:11:59,130 --> 00:12:02,700
imagination is morally bound this

00:12:01,290 --> 00:12:04,470
particular case had used that primitive

00:12:02,700 --> 00:12:06,000
to override a function pointer of a

00:12:04,470 --> 00:12:07,860
socket destruction function pointer

00:12:06,000 --> 00:12:09,870
which was an under attack of control and

00:12:07,860 --> 00:12:11,610
when attacker closes the socket this

00:12:09,870 --> 00:12:13,680
function pointer overeaten function

00:12:11,610 --> 00:12:15,029
pointer gets invoked and it will just go

00:12:13,680 --> 00:12:16,890
ahead and execute with traditional

00:12:15,029 --> 00:12:21,270
traditional payload to kind of raise

00:12:16,890 --> 00:12:23,250
your privileges so so this is like how

00:12:21,270 --> 00:12:25,620
you can use a copy from user if you use

00:12:23,250 --> 00:12:28,050
copy to user resource with our source

00:12:25,620 --> 00:12:29,279
pointer it's gonna create your arbitrary

00:12:28,050 --> 00:12:32,040
read primitive because you're basically

00:12:29,279 --> 00:12:34,079
gonna tell what how copy me this address

00:12:32,040 --> 00:12:36,120
content of this address to the user

00:12:34,079 --> 00:12:37,800
space copy me content of that memory

00:12:36,120 --> 00:12:39,620
address of a current user space you can

00:12:37,800 --> 00:12:43,200
just get through data out of Chrome

00:12:39,620 --> 00:12:44,910
so to summary so this the key things

00:12:43,200 --> 00:12:46,709
which were used here of course we you

00:12:44,910 --> 00:12:48,870
had to find an initialized variable

00:12:46,709 --> 00:12:50,760
which one aren't relevant path you have

00:12:48,870 --> 00:12:52,829
these primitives here helping you to do

00:12:50,760 --> 00:12:54,360
the job but again all this kind of is

00:12:52,829 --> 00:12:57,149
based in fact which you can precisely

00:12:54,360 --> 00:12:58,950
alright a certain offsets and pre-fill

00:12:57,149 --> 00:13:01,170
buried needed data and when a

00:12:58,950 --> 00:13:02,790
subsequence is called resolved if you

00:13:01,170 --> 00:13:04,290
are not precise you're really crush and

00:13:02,790 --> 00:13:06,029
McKiernan this is what you don't want to

00:13:04,290 --> 00:13:07,980
do so this missus and deterministic

00:13:06,029 --> 00:13:11,339
again structure is very important here

00:13:07,980 --> 00:13:12,579
so the next are the next talk is called

00:13:11,339 --> 00:13:16,059
start jacking same

00:13:12,579 --> 00:13:17,769
year and it had its kind of headless

00:13:16,059 --> 00:13:19,779
assumption so it already assumed

00:13:17,769 --> 00:13:22,660
vertically to have gnar Batory right

00:13:19,779 --> 00:13:25,869
primitive to begin to to begin with and

00:13:22,660 --> 00:13:27,579
the how do you get it I've just shown

00:13:25,869 --> 00:13:29,079
one wave of an initialized alcohol

00:13:27,579 --> 00:13:30,879
you'll get an arbitrary right primitive

00:13:29,079 --> 00:13:33,759
there are other ways so it just made

00:13:30,879 --> 00:13:35,980
this assumption but here if we kind of

00:13:33,759 --> 00:13:37,420
heard in a previous a talk case use it

00:13:35,980 --> 00:13:39,429
to this arbiter right primitive to

00:13:37,420 --> 00:13:41,679
override a function pointer it's not

00:13:39,429 --> 00:13:43,629
always but you have this luxury I mean a

00:13:41,679 --> 00:13:45,999
function pointers you might not find a

00:13:43,629 --> 00:13:47,589
suitable one function pointers tables

00:13:45,999 --> 00:13:49,540
might be protected so this kind of try

00:13:47,589 --> 00:13:50,860
to be more generic and say okay what can

00:13:49,540 --> 00:13:52,269
we do if you have an arbitrary right

00:13:50,860 --> 00:13:54,459
primitive but we want to get high

00:13:52,269 --> 00:13:56,259
privileges so what it tries to show you

00:13:54,459 --> 00:13:57,639
here how from arbitrary right you're

00:13:56,259 --> 00:13:59,889
actually getting an arbitrary read

00:13:57,639 --> 00:14:01,749
primitive and to get a very powerful

00:13:59,889 --> 00:14:03,309
because if you have both you can read

00:14:01,749 --> 00:14:05,709
the data you can find the data you need

00:14:03,309 --> 00:14:08,079
like location of a credential structure

00:14:05,709 --> 00:14:10,600
and when you can override that to get a

00:14:08,079 --> 00:14:12,279
root privileges so how do you get where

00:14:10,600 --> 00:14:15,759
how do you get from right to read using

00:14:12,279 --> 00:14:18,850
this talk and why so again first answer

00:14:15,759 --> 00:14:20,619
is that because Takas is it find its it

00:14:18,850 --> 00:14:22,959
used what it called like self discovered

00:14:20,619 --> 00:14:24,970
location of a stock it's used it forever

00:14:22,959 --> 00:14:26,529
like your own processor for a child

00:14:24,970 --> 00:14:29,169
process depending on which techniques

00:14:26,529 --> 00:14:30,790
they used and what it means for it it

00:14:29,169 --> 00:14:33,939
also kind of assumes that you managed to

00:14:30,790 --> 00:14:35,559
leak some address some pointer which

00:14:33,939 --> 00:14:36,970
would by point him to some address in

00:14:35,559 --> 00:14:40,239
stock so for example if you managed to

00:14:36,970 --> 00:14:41,949
leak the pointer to some local variable

00:14:40,239 --> 00:14:43,360
which is located in the stock you can

00:14:41,949 --> 00:14:45,459
kind of using this simple arithmetic

00:14:43,360 --> 00:14:47,709
because tacos fix our student you kind

00:14:45,459 --> 00:14:49,929
of its aligned and everything you can

00:14:47,709 --> 00:14:51,369
you can basically calculate we start

00:14:49,929 --> 00:14:53,259
base address so you'll know where you

00:14:51,369 --> 00:14:54,970
start starts and ends and you already

00:14:53,259 --> 00:14:57,069
suddenly enough you have a right

00:14:54,970 --> 00:14:59,169
primitive class you have this perfect

00:14:57,069 --> 00:15:01,869
stock structure or sunstruck structure

00:14:59,169 --> 00:15:03,999
stock stock pages but you know very very

00:15:01,869 --> 00:15:06,790
exactly are and you can try to kind of

00:15:03,999 --> 00:15:08,939
proceed from there so it proceeded from

00:15:06,790 --> 00:15:11,739
various in different techniques and

00:15:08,939 --> 00:15:13,419
understanding is kind of its it used to

00:15:11,739 --> 00:15:14,949
fact what we used to have this special

00:15:13,419 --> 00:15:16,600
structure into the bottom of a stock

00:15:14,949 --> 00:15:18,699
which go to the trade info

00:15:16,600 --> 00:15:21,669
it was located at a fixed bottom of a

00:15:18,699 --> 00:15:23,350
stock is defined and it and the goal of

00:15:21,669 --> 00:15:24,750
that kind of first approaches when try

00:15:23,350 --> 00:15:27,090
to kind of override because

00:15:24,750 --> 00:15:29,640
an arbitrary right try to override

00:15:27,090 --> 00:15:32,280
something in bed structure which allows

00:15:29,640 --> 00:15:33,840
you to rise privilege a classical

00:15:32,280 --> 00:15:35,820
approach was luck at some point of time

00:15:33,840 --> 00:15:38,370
was to override the address limit our

00:15:35,820 --> 00:15:41,460
variable located in at read info because

00:15:38,370 --> 00:15:43,170
if you can put a card in the S value

00:15:41,460 --> 00:15:45,120
we're like if you can change that you

00:15:43,170 --> 00:15:47,400
you basically allowing this copy to and

00:15:45,120 --> 00:15:49,580
from user to not verify arguments and

00:15:47,400 --> 00:15:52,500
copy your data between the kernel and

00:15:49,580 --> 00:15:53,820
korone to kernel or like it kind of

00:15:52,500 --> 00:15:55,230
basically gives you these primitives

00:15:53,820 --> 00:15:57,570
right away and a really primitive

00:15:55,230 --> 00:15:58,890
including but it's not so this first one

00:15:57,570 --> 00:16:00,600
is not actually very interesting because

00:15:58,890 --> 00:16:02,370
it kind of realized in this trading for

00:16:00,600 --> 00:16:05,250
being there and many things and it's

00:16:02,370 --> 00:16:07,650
actually it does many a virgin dances

00:16:05,250 --> 00:16:08,850
there to kind of get get fair but I like

00:16:07,650 --> 00:16:11,310
the second one more because it's more

00:16:08,850 --> 00:16:14,220
generic so it doesn't assume any fred

00:16:11,310 --> 00:16:16,860
info to bottom what it tries to again

00:16:14,220 --> 00:16:18,930
have is what it does actually

00:16:16,860 --> 00:16:21,210
essentially it spawns the child process

00:16:18,930 --> 00:16:22,800
of attack response the child process the

00:16:21,210 --> 00:16:24,510
child process uses three stalks of

00:16:22,800 --> 00:16:26,130
discovery to find where it's dark

00:16:24,510 --> 00:16:28,620
location so what forget which addresses

00:16:26,130 --> 00:16:31,110
it passes this in future parent but

00:16:28,620 --> 00:16:33,210
parent is aware now there it is and when

00:16:31,110 --> 00:16:36,900
what happens is that it will put we also

00:16:33,210 --> 00:16:38,220
it will put a child to sleep and and one

00:16:36,900 --> 00:16:40,230
important thing i forgot to mention is

00:16:38,220 --> 00:16:44,550
that it did have to find with this

00:16:40,230 --> 00:16:47,400
copied to user call which would use

00:16:44,550 --> 00:16:50,940
which would be kind of done from on

00:16:47,400 --> 00:16:52,440
being in the context of a child but it

00:16:50,940 --> 00:16:54,000
would because it already has an arbiter

00:16:52,440 --> 00:16:55,860
right primitive it doesn't need to have

00:16:54,000 --> 00:16:56,460
any on with uninitialized variables

00:16:55,860 --> 00:16:59,040
prefilling

00:16:56,460 --> 00:17:02,940
it can just go ahead and overwrite this

00:16:59,040 --> 00:17:05,130
copied to user the source pointer and

00:17:02,940 --> 00:17:06,930
that would give you straight with this

00:17:05,130 --> 00:17:08,880
arbitrary right so it will pass a charge

00:17:06,930 --> 00:17:11,640
we've got to put it to sleep overwrite a

00:17:08,880 --> 00:17:13,319
pointer re restores to child for assumes

00:17:11,640 --> 00:17:16,790
the child and when the child will

00:17:13,319 --> 00:17:19,050
perform is copied to user call with the

00:17:16,790 --> 00:17:20,490
information with a piece of memory the

00:17:19,050 --> 00:17:22,500
information of memory of address that

00:17:20,490 --> 00:17:24,000
you want to know and and this way you

00:17:22,500 --> 00:17:26,100
can actually luck walk with whole thing

00:17:24,000 --> 00:17:27,630
from trading nowhere stocks to

00:17:26,100 --> 00:17:30,030
architects from stock stroke you can no

00:17:27,630 --> 00:17:31,980
credit structures and so on so you can

00:17:30,030 --> 00:17:33,390
find the right location and you already

00:17:31,980 --> 00:17:36,220
have an arbiter right so you're gonna

00:17:33,390 --> 00:17:39,139
overwrite it so this this was

00:17:36,220 --> 00:17:41,509
this was time and again for both of

00:17:39,139 --> 00:17:43,070
these techniques this different approach

00:17:41,509 --> 00:17:45,529
in everything important part is that

00:17:43,070 --> 00:17:48,470
when you you need to precisely overwrite

00:17:45,529 --> 00:17:49,850
at certain point of time the location is

00:17:48,470 --> 00:17:51,860
talked and this is very sensitive again

00:17:49,850 --> 00:17:53,210
if you get it wrong if you overwrite

00:17:51,860 --> 00:17:55,730
something wrong you're gonna crush a

00:17:53,210 --> 00:17:57,769
target and talk and almost feeling

00:17:55,730 --> 00:17:59,509
myself as this explode rather books we

00:17:57,769 --> 00:18:01,009
don't want to crash the target services

00:17:59,509 --> 00:18:03,169
this is very important so we want to

00:18:01,009 --> 00:18:04,669
create reliably or explode writers want

00:18:03,169 --> 00:18:06,169
to create reliable exploits so they

00:18:04,669 --> 00:18:10,609
would never go for approach it works

00:18:06,169 --> 00:18:14,480
once and 50 only times so the next time

00:18:10,609 --> 00:18:16,100
and time ok so the next to talk is so if

00:18:14,480 --> 00:18:17,779
previous your talks we were talking

00:18:16,100 --> 00:18:19,850
about something which happens so we must

00:18:17,779 --> 00:18:21,950
talk itself now if we are getting kind

00:18:19,850 --> 00:18:23,359
of more interesting scenario so we are

00:18:21,950 --> 00:18:24,879
getting into what we call it interest

00:18:23,359 --> 00:18:26,840
our exploitation service fee

00:18:24,879 --> 00:18:30,440
subsequently or a talk which is called

00:18:26,840 --> 00:18:32,509
stack is back and now we are finding

00:18:30,440 --> 00:18:34,609
again be using with child process

00:18:32,509 --> 00:18:38,059
scenario but what we will do here is

00:18:34,609 --> 00:18:40,669
that we will our spawn out our children

00:18:38,059 --> 00:18:42,830
processes to and we will use the same

00:18:40,669 --> 00:18:44,720
trick to rediscover which talks and pass

00:18:42,830 --> 00:18:46,519
some information to a parent and we will

00:18:44,720 --> 00:18:48,320
do it until we find us in the situation

00:18:46,519 --> 00:18:50,659
when the parent and child stock is lined

00:18:48,320 --> 00:18:52,789
and it used to be but we didn't have any

00:18:50,659 --> 00:18:54,200
guard pages in between so you really to

00:18:52,789 --> 00:18:55,999
look something like this so you have a

00:18:54,200 --> 00:18:58,970
parent stock location and child star

00:18:55,999 --> 00:19:00,909
condo occasion underneath and at that

00:18:58,970 --> 00:19:03,350
moment so when you find this kind of

00:19:00,909 --> 00:19:08,149
situation so you're gonna put a child

00:19:03,350 --> 00:19:10,369
tried to sleep and what will he was also

00:19:08,149 --> 00:19:11,720
would you and kind of intuitively what

00:19:10,369 --> 00:19:14,330
you need to do you want to really kind

00:19:11,720 --> 00:19:16,429
of try to overwrite return address of a

00:19:14,330 --> 00:19:19,009
child but you can't do it unless you

00:19:16,429 --> 00:19:20,840
have a way to extend your stack frame so

00:19:19,009 --> 00:19:23,389
you basically need to go as much down

00:19:20,840 --> 00:19:26,119
from your own start frame to reach this

00:19:23,389 --> 00:19:29,210
past your past to the end of your stock

00:19:26,119 --> 00:19:31,789
an interview on stock of your child

00:19:29,210 --> 00:19:33,889
process and in userspace there has been

00:19:31,789 --> 00:19:37,220
actually hold work showing how to do to

00:19:33,889 --> 00:19:38,690
use your space from 2005 phone and there

00:19:37,220 --> 00:19:40,429
are a number of things if you have a

00:19:38,690 --> 00:19:42,679
local calls which allow you to give

00:19:40,429 --> 00:19:44,990
similar things but in a local is banned

00:19:42,679 --> 00:19:47,090
for example and we if you locate a big

00:19:44,990 --> 00:19:48,740
local stock variable compiler is clever

00:19:47,090 --> 00:19:49,700
enough it will actually put it for you

00:19:48,740 --> 00:19:51,440
off the kernels

00:19:49,700 --> 00:19:54,049
because it really doesn't want you to do

00:19:51,440 --> 00:19:55,279
it which is great but what you used to

00:19:54,049 --> 00:19:57,380
have in Colonel it's this

00:19:55,279 --> 00:20:00,470
variable-length arrays so example is

00:19:57,380 --> 00:20:02,899
shown here it's basically an array with

00:20:00,470 --> 00:20:04,850
length which is not known to compiler at

00:20:02,899 --> 00:20:06,529
a completion time because if you look

00:20:04,850 --> 00:20:08,990
here an example it might depend on some

00:20:06,529 --> 00:20:10,789
runtime variable length and if you find

00:20:08,990 --> 00:20:13,669
to find if you found such an array

00:20:10,789 --> 00:20:15,649
defined in your path which you're trying

00:20:13,669 --> 00:20:17,690
to explore it and the size you can

00:20:15,649 --> 00:20:20,389
control which means you can put it as

00:20:17,690 --> 00:20:22,279
much as you want here and not as much

00:20:20,389 --> 00:20:25,070
you actually want it is exactly as big

00:20:22,279 --> 00:20:26,450
so kind of go down and not as much so

00:20:25,070 --> 00:20:29,779
you precisely want to stop at this

00:20:26,450 --> 00:20:31,159
return address think so so with our you

00:20:29,779 --> 00:20:33,799
can basically create this variable

00:20:31,159 --> 00:20:34,940
length array you can get safely over the

00:20:33,799 --> 00:20:36,889
kind of things you don't want to

00:20:34,940 --> 00:20:40,190
overwrite you will overwrite your return

00:20:36,889 --> 00:20:42,740
address of the of your child in this

00:20:40,190 --> 00:20:44,899
case and when you will resume the child

00:20:42,740 --> 00:20:46,399
and a child basically returns to

00:20:44,899 --> 00:20:48,919
attacker control address and I guess

00:20:46,399 --> 00:20:51,250
again you can take it from there into

00:20:48,919 --> 00:20:54,529
kind of different paths you want so and

00:20:51,250 --> 00:20:56,870
again this one is different approach

00:20:54,529 --> 00:20:58,639
it's of course uses the fact that you're

00:20:56,870 --> 00:21:01,240
able to find its variable length array

00:20:58,639 --> 00:21:04,850
and and use this in fact what you can

00:21:01,240 --> 00:21:06,919
kind of get with a closed allocation it

00:21:04,850 --> 00:21:08,809
says it takes it wasn't that hard in bed

00:21:06,919 --> 00:21:10,610
time at all you don't have anything in

00:21:08,809 --> 00:21:13,460
between so you can just safely kind of

00:21:10,610 --> 00:21:16,100
overwrite but again you need to be able

00:21:13,460 --> 00:21:17,779
to do it safely and if you need to know

00:21:16,100 --> 00:21:19,250
exactly how long your variable length

00:21:17,779 --> 00:21:21,289
array needs to be to overwrite a

00:21:19,250 --> 00:21:23,330
particular precise place so with

00:21:21,289 --> 00:21:25,850
deterministic and predictability is

00:21:23,330 --> 00:21:30,440
extremely important a more recent

00:21:25,850 --> 00:21:33,019
example so this is from 2016 the guy

00:21:30,440 --> 00:21:34,820
behind visitor cause he and horn on I've

00:21:33,019 --> 00:21:36,919
kind of personally really like this one

00:21:34,820 --> 00:21:39,080
because it's it's pretty in my point of

00:21:36,919 --> 00:21:41,090
view of fruitiness so it's again it's

00:21:39,080 --> 00:21:42,620
also interesting exploitation so because

00:21:41,090 --> 00:21:44,929
we are not just doing it ruin my stack

00:21:42,620 --> 00:21:47,990
but we are not having the child process

00:21:44,929 --> 00:21:50,149
here underneath we are what he handed

00:21:47,990 --> 00:21:52,070
his he is basically creating sort of

00:21:50,149 --> 00:21:54,740
child process is he creating data pipes

00:21:52,070 --> 00:21:58,720
and he stayed apart get allocated

00:21:54,740 --> 00:22:00,370
are a page of data for it

00:21:58,720 --> 00:22:02,980
and interval kind of keeps creating with

00:22:00,370 --> 00:22:05,530
pipes until he gets nervous kind of

00:22:02,980 --> 00:22:07,060
picture here so until his process start

00:22:05,530 --> 00:22:08,590
because it used to be vivid they would

00:22:07,060 --> 00:22:10,630
be allocated from the same kind of white

00:22:08,590 --> 00:22:14,950
alligator so he will get twist to be

00:22:10,630 --> 00:22:18,430
snarl co-located and are what you do it

00:22:14,950 --> 00:22:20,410
at point is that you will and of course

00:22:18,430 --> 00:22:22,660
here he used to tricked what he found an

00:22:20,410 --> 00:22:25,390
arbitrary recursion back which was an

00:22:22,660 --> 00:22:27,370
encrypted fest as many details but but

00:22:25,390 --> 00:22:29,530
with arbitrary recursion bug allowed him

00:22:27,370 --> 00:22:31,540
to kind of basically build as many kind

00:22:29,530 --> 00:22:34,600
of keep doing with track frames as not

00:22:31,540 --> 00:22:37,170
disturb frames calls and he able to kind

00:22:34,600 --> 00:22:40,860
of records past the end of his own stock

00:22:37,170 --> 00:22:43,720
into this data pipe which he controls

00:22:40,860 --> 00:22:46,990
until is bad that he's earned by paid he

00:22:43,720 --> 00:22:49,120
controls and and at what point when he

00:22:46,990 --> 00:22:51,190
made a recursion fast far enough he

00:22:49,120 --> 00:22:51,730
would pass the process he would all

00:22:51,190 --> 00:22:54,460
right

00:22:51,730 --> 00:22:56,350
return address by writing into a pipe in

00:22:54,460 --> 00:22:58,300
a particular point when she receives the

00:22:56,350 --> 00:23:00,990
process and protests returns to address

00:22:58,300 --> 00:23:04,900
and again it whole thing continuous so

00:23:00,990 --> 00:23:07,060
again different like you had to find a

00:23:04,900 --> 00:23:08,710
very kirshen bug and he actually like in

00:23:07,060 --> 00:23:10,630
some of conversations they had he said

00:23:08,710 --> 00:23:13,000
that it's actually pretty difficult to

00:23:10,630 --> 00:23:15,280
kind of really precisely align all these

00:23:13,000 --> 00:23:17,860
things how they kind of to make sure

00:23:15,280 --> 00:23:19,740
that the stack frames align and you get

00:23:17,860 --> 00:23:22,660
to kind of to overwrite the right place

00:23:19,740 --> 00:23:23,980
but with deterministic structures was

00:23:22,660 --> 00:23:25,450
very important here because you want

00:23:23,980 --> 00:23:28,570
this whole thing to be stable and you

00:23:25,450 --> 00:23:31,570
want to know where you need to write so

00:23:28,570 --> 00:23:34,540
the last thing yes last a talk I'm going

00:23:31,570 --> 00:23:36,550
to show it's it's I just want to kind of

00:23:34,540 --> 00:23:38,560
show this for a sec of an example but

00:23:36,550 --> 00:23:41,260
problem maybe of you already thinking

00:23:38,560 --> 00:23:42,760
when I started talking about this its

00:23:41,260 --> 00:23:44,260
interests are exploitation because the

00:23:42,760 --> 00:23:46,270
pictures of the showed here we didn't

00:23:44,260 --> 00:23:48,070
have any guard pages in between so kind

00:23:46,270 --> 00:23:50,860
of is a guard page is solution to it all

00:23:48,070 --> 00:23:53,440
well in 2017 we had a stock clash which

00:23:50,860 --> 00:23:55,930
basically showed what not not quite so

00:23:53,440 --> 00:23:57,820
because attackers can use we again with

00:23:55,930 --> 00:24:00,180
variable-length arrays to basically jump

00:23:57,820 --> 00:24:02,110
over the guard page if in its present a

00:24:00,180 --> 00:24:03,790
limitation of course where you have to

00:24:02,110 --> 00:24:06,220
find this variable length array and it

00:24:03,790 --> 00:24:07,690
has to be not fully kind of writable

00:24:06,220 --> 00:24:09,130
because if you start writing and that

00:24:07,690 --> 00:24:11,560
you're going to hit a guard page this is

00:24:09,130 --> 00:24:12,160
what you don't want to do but let's

00:24:11,560 --> 00:24:14,230
attack base

00:24:12,160 --> 00:24:16,420
we showed how to kind of use this

00:24:14,230 --> 00:24:18,940
variable length array to perform a jump

00:24:16,420 --> 00:24:20,770
or regard phage and when after jump

00:24:18,940 --> 00:24:22,540
I mean you again you're here on some

00:24:20,770 --> 00:24:24,220
other memory location which can be a

00:24:22,540 --> 00:24:26,710
child's talk like we showed in previous

00:24:24,220 --> 00:24:28,480
example can be some other barber memory

00:24:26,710 --> 00:24:30,670
location and you have basically

00:24:28,480 --> 00:24:32,350
basically two scenarios like we have

00:24:30,670 --> 00:24:34,000
already seen here you can either kind of

00:24:32,350 --> 00:24:37,480
start over right and very return address

00:24:34,000 --> 00:24:40,090
of the child or you can start over

00:24:37,480 --> 00:24:41,610
writing the data on the stack which went

00:24:40,090 --> 00:24:44,650
past

00:24:41,610 --> 00:24:46,120
so you're basically kind of we are free

00:24:44,650 --> 00:24:47,650
in your choice is what to do after but

00:24:46,120 --> 00:24:49,630
the most important is that you able to

00:24:47,650 --> 00:24:52,360
kind of be able to escape a stock so

00:24:49,630 --> 00:24:53,830
your stack pointer is now out of the we

00:24:52,360 --> 00:24:55,210
discussed in beginning with stock

00:24:53,830 --> 00:24:57,580
overflow your stack pointer is out of

00:24:55,210 --> 00:25:01,270
borders and you are kind of you're

00:24:57,580 --> 00:25:03,040
enjoying yourself at so now now let's

00:25:01,270 --> 00:25:05,260
talk about your country measures so of

00:25:03,040 --> 00:25:07,540
course always attacks each of them kind

00:25:05,260 --> 00:25:09,550
of did the country measures in millions

00:25:07,540 --> 00:25:11,230
kernels this ones are very early on

00:25:09,550 --> 00:25:13,000
which are not so specific to attacks our

00:25:11,230 --> 00:25:14,440
show just kind of tell the twelve has

00:25:13,000 --> 00:25:16,570
been long too big for spin some

00:25:14,440 --> 00:25:18,430
randomization which have been initial

00:25:16,570 --> 00:25:19,960
randomization put into kernel to make

00:25:18,430 --> 00:25:22,030
sure that it's harder for stalkers to

00:25:19,960 --> 00:25:23,590
kind of figure out places and to know

00:25:22,030 --> 00:25:25,960
what's loaded where is the stack

00:25:23,590 --> 00:25:27,910
protector for simple buffer or flows you

00:25:25,960 --> 00:25:29,740
have a Connery's where you're kind of

00:25:27,910 --> 00:25:31,420
have this non-executive obeyed but it's

00:25:29,740 --> 00:25:33,700
not so easy for stalkers to place for

00:25:31,420 --> 00:25:35,170
payloads and just execute them so you

00:25:33,700 --> 00:25:37,690
kind of try to prevent when we have

00:25:35,170 --> 00:25:39,730
having debug VX which is trying to warn

00:25:37,690 --> 00:25:41,440
you if you have any of the saris enabled

00:25:39,730 --> 00:25:43,510
so to kind of try scene I don't do that

00:25:41,440 --> 00:25:45,280
but with all the early ones the

00:25:43,510 --> 00:25:47,740
interesting ones come are much more

00:25:45,280 --> 00:25:49,420
recent actually after Yun published with

00:25:47,740 --> 00:25:52,690
some showed ways he's a talk with the

00:25:49,420 --> 00:25:56,560
crypto fest bug I got for me they map

00:25:52,690 --> 00:26:01,690
based are stuck it was most satisfy us

00:25:56,560 --> 00:26:03,640
by Andy and he basically moved to

00:26:01,690 --> 00:26:05,920
Stockholm from body alligator to V

00:26:03,640 --> 00:26:07,210
malloc region it's much bigger rich and

00:26:05,920 --> 00:26:08,710
they could afford starting to have a

00:26:07,210 --> 00:26:11,170
guard pages so they started to have a

00:26:08,710 --> 00:26:13,420
guard pages in between and and we

00:26:11,170 --> 00:26:15,400
similar the same parts of formally

00:26:13,420 --> 00:26:17,740
different feature but it was developed

00:26:15,400 --> 00:26:19,360
at the same time remove at read info how

00:26:17,740 --> 00:26:20,830
the first so you kind of start to have

00:26:19,360 --> 00:26:23,620
the stock looking something like this

00:26:20,830 --> 00:26:25,020
which is much nicer point of view and

00:26:23,620 --> 00:26:26,640
our one obviously they

00:26:25,020 --> 00:26:28,290
really talk to luck in two places about

00:26:26,640 --> 00:26:32,040
this variable lungs her race and why is

00:26:28,290 --> 00:26:34,140
it bad so that also kind of there was a

00:26:32,040 --> 00:26:36,480
big effort in case case was leaning with

00:26:34,140 --> 00:26:38,490
effort within a crow hardening project

00:26:36,480 --> 00:26:41,340
of Bailey removal from a whole kernel

00:26:38,490 --> 00:26:43,200
and I think it was in 2018 he declared

00:26:41,340 --> 00:26:44,610
it kernel to be very late freeze which

00:26:43,200 --> 00:26:46,500
is a great thing because it just

00:26:44,610 --> 00:26:48,120
basically removed attacker jump

00:26:46,500 --> 00:26:51,300
primitive for any kinds of attack

00:26:48,120 --> 00:26:54,360
including stalk and more recent thing

00:26:51,300 --> 00:26:57,270
was the merging of a stock lick it

00:26:54,360 --> 00:26:58,830
seduces a plug-in and this plug-in is

00:26:57,270 --> 00:27:00,030
basically trying to kind of its main

00:26:58,830 --> 00:27:03,120
goal is trying to fight this

00:27:00,030 --> 00:27:05,100
uninitialized stock scenario so men but

00:27:03,120 --> 00:27:07,170
new executing on your C's call and

00:27:05,100 --> 00:27:08,880
you're exiting before they exit to be

00:27:07,170 --> 00:27:10,890
user space happens what it does for you

00:27:08,880 --> 00:27:12,600
it's going to go ahead and clean your

00:27:10,890 --> 00:27:15,510
stock frames it's kind of basically

00:27:12,600 --> 00:27:17,130
points the poison seat with values to

00:27:15,510 --> 00:27:19,110
make sure but nothing really staying

00:27:17,130 --> 00:27:22,470
where from a previous call which can be

00:27:19,110 --> 00:27:25,380
reused but occurs so and and and this is

00:27:22,470 --> 00:27:27,870
kind of important thing to have okay so

00:27:25,380 --> 00:27:29,880
after we looked and always the talks and

00:27:27,870 --> 00:27:31,530
and very recent especially recent

00:27:29,880 --> 00:27:33,690
protections so what doping question is

00:27:31,530 --> 00:27:35,790
so what do we have left is it kind of

00:27:33,690 --> 00:27:37,680
what is the state now so what I'm trying

00:27:35,790 --> 00:27:39,690
to claim is well despite a factored we

00:27:37,680 --> 00:27:41,340
have his protections marriage-like which

00:27:39,690 --> 00:27:44,850
targeted this particular things like

00:27:41,340 --> 00:27:47,010
relays and uninitialized talk and and

00:27:44,850 --> 00:27:49,110
with substance of guard pages what

00:27:47,010 --> 00:27:50,910
remains is still with this property

00:27:49,110 --> 00:27:53,310
surface talk which haven't kind of which

00:27:50,910 --> 00:27:56,490
been kind of course still core things to

00:27:53,310 --> 00:27:58,110
always a talk so and so this

00:27:56,490 --> 00:28:01,650
deterministic structure predictability

00:27:58,110 --> 00:28:03,870
easier to locate and also never kind of

00:28:01,650 --> 00:28:05,190
hunger - it went various lists for

00:28:03,870 --> 00:28:07,140
example things some of the country

00:28:05,190 --> 00:28:08,940
measures which already fear they might

00:28:07,140 --> 00:28:10,410
not be enabled and all the distress

00:28:08,940 --> 00:28:12,390
because they can be performance

00:28:10,410 --> 00:28:13,830
impacting and they can be quite a lot

00:28:12,390 --> 00:28:16,650
performance in pocketing depending on

00:28:13,830 --> 00:28:19,380
the load so I'm giving here an example

00:28:16,650 --> 00:28:21,060
of first ah click with one of the micro

00:28:19,380 --> 00:28:23,970
benchmark which I have been actually

00:28:21,060 --> 00:28:26,850
asked to do by England and II and an

00:28:23,970 --> 00:28:28,020
under vet benchmark the stock like for

00:28:26,850 --> 00:28:30,510
example I say about eighty percent

00:28:28,020 --> 00:28:33,030
overhead and we saw it emerges orbits

00:28:30,510 --> 00:28:34,380
but it just indicates what it might not

00:28:33,030 --> 00:28:36,600
been able to everyone in centricity

00:28:34,380 --> 00:28:37,860
plugins I have to enable the GCC plug in

00:28:36,600 --> 00:28:40,320
infrastructure and or

00:28:37,860 --> 00:28:42,690
but and also all these protections which

00:28:40,320 --> 00:28:44,940
have talked about we have existed for a

00:28:42,690 --> 00:28:46,260
long while not an upstream kernel but we

00:28:44,940 --> 00:28:47,880
have kind of been merged to upstream

00:28:46,260 --> 00:28:50,340
kernel only after somebody have shown

00:28:47,880 --> 00:28:52,890
and working explode so it kind of shows

00:28:50,340 --> 00:28:55,019
that we have some kind of not maybe

00:28:52,890 --> 00:28:56,850
initial but like can we be really more

00:28:55,019 --> 00:28:58,529
proactive and and see what we can do

00:28:56,850 --> 00:28:59,970
even if there isn't I can't show you any

00:28:58,529 --> 00:29:01,440
kind of exploit so if you have

00:28:59,970 --> 00:29:03,510
everything what I talked about is an

00:29:01,440 --> 00:29:05,370
Ableton put on I don't have a ready-made

00:29:03,510 --> 00:29:07,409
exploit which I can show you to save it

00:29:05,370 --> 00:29:09,779
ok we can break it all but can be even

00:29:07,409 --> 00:29:11,490
more proactive so and and the future

00:29:09,779 --> 00:29:13,950
Hannaford I started working in past it

00:29:11,490 --> 00:29:16,200
was it's it's not my idea and it's not a

00:29:13,950 --> 00:29:18,720
new idea it's actually a very old idea

00:29:16,200 --> 00:29:21,299
which was developed originally by parks

00:29:18,720 --> 00:29:23,730
team are in 2003 it was called front

00:29:21,299 --> 00:29:26,639
keys talk it was part of chess security

00:29:23,730 --> 00:29:29,190
people know which is non mainline are a

00:29:26,639 --> 00:29:32,279
set of security hardening purchase and

00:29:29,190 --> 00:29:33,809
and the main idea was very bit ok let's

00:29:32,279 --> 00:29:35,820
remove this deterministic and

00:29:33,809 --> 00:29:39,029
predictability by adding small random

00:29:35,820 --> 00:29:41,130
offset from beginning of a stock on each

00:29:39,029 --> 00:29:42,899
C score so every time a process is

00:29:41,130 --> 00:29:44,460
called when you start building its own

00:29:42,899 --> 00:29:46,409
kernel stack it would be kind of always

00:29:44,460 --> 00:29:48,450
up set it on some kind of random value

00:29:46,409 --> 00:29:50,429
so you will always you want exactly know

00:29:48,450 --> 00:29:52,440
where restock where PT registers for

00:29:50,429 --> 00:29:53,929
stock frames are so every time kind of

00:29:52,440 --> 00:29:56,580
you do it it's gonna be a bit different

00:29:53,929 --> 00:29:58,559
and when we started thinking about it we

00:29:56,580 --> 00:30:00,779
also can afford to do overs we actually

00:29:58,559 --> 00:30:02,970
our option of putting this random offset

00:30:00,779 --> 00:30:05,490
you can also do it kind of you can

00:30:02,970 --> 00:30:07,440
either do it way parks way on beginning

00:30:05,490 --> 00:30:08,820
or you can do it in after a PT rec

00:30:07,440 --> 00:30:10,559
structure so you're basically blind have

00:30:08,820 --> 00:30:13,080
tried to run demise what happens your

00:30:10,559 --> 00:30:14,730
normal stock frames and we'd kind of

00:30:13,080 --> 00:30:17,340
reconsider service two options have been

00:30:14,730 --> 00:30:19,919
suggested so the option one has some

00:30:17,340 --> 00:30:22,260
benefit when you're doing certain

00:30:19,919 --> 00:30:24,090
attacks which would kind of use we

00:30:22,260 --> 00:30:27,090
factor the talker is able to store some

00:30:24,090 --> 00:30:28,529
reliably stole some data and PCR X so

00:30:27,090 --> 00:30:31,190
I've been given kind of its example of a

00:30:28,529 --> 00:30:33,240
talk by one of the explode writers and

00:30:31,190 --> 00:30:35,250
but the problem with this first

00:30:33,240 --> 00:30:37,710
approaches which would also been kind of

00:30:35,250 --> 00:30:39,419
fun and also understood while talking to

00:30:37,710 --> 00:30:41,039
people is well if you have a pitch race

00:30:39,419 --> 00:30:43,080
neighbor scenarios and if you do some

00:30:41,039 --> 00:30:45,059
kind of flood to do some cache probing

00:30:43,080 --> 00:30:47,520
attacks it's quite easy to figure out

00:30:45,059 --> 00:30:49,200
where B P T regs are even if you have a

00:30:47,520 --> 00:30:50,070
small runtime I said because we can't do

00:30:49,200 --> 00:30:51,810
big upset

00:30:50,070 --> 00:30:54,360
I mean stock are so limited it's only

00:30:51,810 --> 00:30:56,250
four pages long so they can't and if you

00:30:54,360 --> 00:30:58,110
start to allocate more pages for the

00:30:56,250 --> 00:31:00,120
colonel stockroom and have even longer

00:30:58,110 --> 00:31:01,650
discussion of mind trainer so so you

00:31:00,120 --> 00:31:04,410
have to do some small offset and it

00:31:01,650 --> 00:31:06,240
might be very easy to figure it out so

00:31:04,410 --> 00:31:09,480
the event is a result to kind of went

00:31:06,240 --> 00:31:11,970
with option two or which would basically

00:31:09,480 --> 00:31:14,270
leave beat your eggs in the place and it

00:31:11,970 --> 00:31:16,860
will do this random offset after we

00:31:14,270 --> 00:31:19,500
after the PT Rex and went from via one

00:31:16,860 --> 00:31:22,020
if I start building your stock frames so

00:31:19,500 --> 00:31:23,160
we feature a config option which and the

00:31:22,020 --> 00:31:25,380
feature was posted

00:31:23,160 --> 00:31:26,940
I don't think pristine coral hardening

00:31:25,380 --> 00:31:29,970
and when we had long discussion on it

00:31:26,940 --> 00:31:32,520
okay Emma so you can find this

00:31:29,970 --> 00:31:34,020
discussion any time so the feature was

00:31:32,520 --> 00:31:37,290
called to his config randomized case

00:31:34,020 --> 00:31:39,060
knockoff said so it did it its way and

00:31:37,290 --> 00:31:41,250
and I think implementation I have

00:31:39,060 --> 00:31:43,110
written number hurried and fully like a

00:31:41,250 --> 00:31:46,080
number of times based on discussions of

00:31:43,110 --> 00:31:47,250
mine trainers and and and it turned out

00:31:46,080 --> 00:31:49,020
to be like implementation is very

00:31:47,250 --> 00:31:50,520
different from Oxfordshire secure

00:31:49,020 --> 00:31:52,950
eternal abyss initial inspiration and

00:31:50,520 --> 00:31:55,560
idea is the same so it's kind of it's

00:31:52,950 --> 00:31:58,620
randomizes on syscall entry the parks is

00:31:55,560 --> 00:32:00,270
doing it an exit it has I mean for this

00:31:58,620 --> 00:32:02,420
example this is adjustable of course we

00:32:00,270 --> 00:32:05,340
test about five bits of entropy for

00:32:02,420 --> 00:32:06,840
randomization so it's actually very tiny

00:32:05,340 --> 00:32:08,910
you can see the macro here it's

00:32:06,840 --> 00:32:10,620
basically what it takes because it uses

00:32:08,910 --> 00:32:13,020
with our local coal which is burned for

00:32:10,620 --> 00:32:15,090
colonel but it was actually suggested by

00:32:13,020 --> 00:32:16,650
Andy himself having n do Ingo who

00:32:15,090 --> 00:32:19,950
suggested it so kind of for this case

00:32:16,650 --> 00:32:22,140
we're okay using it so and it's it made

00:32:19,950 --> 00:32:24,840
it really beautiful and small but of

00:32:22,140 --> 00:32:26,970
course the devil is in details so then

00:32:24,840 --> 00:32:28,590
we run into this big kind of it went

00:32:26,970 --> 00:32:30,480
really nicely with discussion and kind

00:32:28,590 --> 00:32:32,070
of adjustment of everything till we run

00:32:30,480 --> 00:32:34,410
out of a problem okay where you forget

00:32:32,070 --> 00:32:36,240
randomness from so many we need very

00:32:34,410 --> 00:32:38,940
little of randomness here so like I mean

00:32:36,240 --> 00:32:40,830
we took about eight to five bits but

00:32:38,940 --> 00:32:43,320
we'll be happy with for his feature

00:32:40,830 --> 00:32:45,150
but the problem is between disease

00:32:43,320 --> 00:32:46,800
called path so we need a fast randomness

00:32:45,150 --> 00:32:48,240
like really really fast and then I

00:32:46,800 --> 00:32:50,790
started looking into what we have in the

00:32:48,240 --> 00:32:52,380
kernel and I try to kind of summary most

00:32:50,790 --> 00:32:54,900
common options for you in a small table

00:32:52,380 --> 00:32:56,730
here so the first kind of and and this

00:32:54,900 --> 00:32:59,700
is what parks for example using was

00:32:56,730 --> 00:33:01,860
three times to read time stamp counter

00:32:59,700 --> 00:33:03,080
thing which is which is very fast speed

00:33:01,860 --> 00:33:05,570
wise

00:33:03,080 --> 00:33:08,120
but unfortunately our it's pretty weak

00:33:05,570 --> 00:33:10,220
it's kind of it's least erotically it's

00:33:08,120 --> 00:33:12,320
considered not so terrifically maybe

00:33:10,220 --> 00:33:14,620
considered to be prone to be timing the

00:33:12,320 --> 00:33:18,679
talks so even if you use the smaller

00:33:14,620 --> 00:33:20,630
bits of the value of it it returns still

00:33:18,679 --> 00:33:23,299
looking one can kind of ridiculous save

00:33:20,630 --> 00:33:25,460
it which is not very very secure so but

00:33:23,299 --> 00:33:27,500
it was the fastest clearly and when I

00:33:25,460 --> 00:33:28,820
start looking what else do we have on we

00:33:27,500 --> 00:33:31,039
have a kind of spectrum side of a

00:33:28,820 --> 00:33:32,960
spectrum for example for x86 have the

00:33:31,039 --> 00:33:34,789
ear tear and instruction it's the CPU

00:33:32,960 --> 00:33:37,669
instruction to get the randomness from

00:33:34,789 --> 00:33:39,559
occur or from the CPU it's very good

00:33:37,669 --> 00:33:41,899
randomness quality I mean it's it's

00:33:39,559 --> 00:33:44,990
properly cryptographically secure random

00:33:41,899 --> 00:33:48,200
generators which is there unfortunately

00:33:44,990 --> 00:33:50,059
it's very slow so it was completely our

00:33:48,200 --> 00:33:52,190
budget just parameters which we measured

00:33:50,059 --> 00:33:54,409
when you have things like parandham

00:33:52,190 --> 00:33:56,450
which is observed around an internal to

00:33:54,409 --> 00:33:58,669
the random number generator which is

00:33:56,450 --> 00:34:00,500
also very fast it's not as fastest times

00:33:58,669 --> 00:34:02,899
time counter reading but also very fast

00:34:00,500 --> 00:34:04,429
but heaven and I was first very happy

00:34:02,899 --> 00:34:06,500
finding it thinking okay we're going to

00:34:04,429 --> 00:34:08,119
use that but when it turned out but

00:34:06,500 --> 00:34:11,389
actually when you look inside what it is

00:34:08,119 --> 00:34:13,550
it's basically said of it's a linear

00:34:11,389 --> 00:34:15,740
combination of a couple of lfsr's and

00:34:13,550 --> 00:34:18,080
resolve design it's like 20 years old

00:34:15,740 --> 00:34:19,520
and it's actually traveled but breakable

00:34:18,080 --> 00:34:21,800
if you assume that the tracker could get

00:34:19,520 --> 00:34:23,629
output of this could get access to this

00:34:21,800 --> 00:34:25,040
base offset so it's it's like it doesn't

00:34:23,629 --> 00:34:27,379
need to collect what many before it's

00:34:25,040 --> 00:34:30,950
breaks it so it's fully linear and and

00:34:27,379 --> 00:34:33,379
and it's so it's I determined it to be

00:34:30,950 --> 00:34:35,119
like even weaker when we lower bits of

00:34:33,379 --> 00:34:38,839
timestamp counter and kind of ruled

00:34:35,119 --> 00:34:40,700
without from the design so the middle

00:34:38,839 --> 00:34:42,230
ground which I call it was this get

00:34:40,700 --> 00:34:42,770
random bytes interface which is

00:34:42,230 --> 00:34:44,330
basically

00:34:42,770 --> 00:34:45,950
interface towards internal

00:34:44,330 --> 00:34:47,720
cryptographically secure random number

00:34:45,950 --> 00:34:50,060
generator which provides very good

00:34:47,720 --> 00:34:53,690
randomness even crypto level randomness

00:34:50,060 --> 00:34:56,540
but it's it's basement charger 20 and

00:34:53,690 --> 00:34:59,300
are the problem well I found the

00:34:56,540 --> 00:35:01,790
performance kind of to be middle ground

00:34:59,300 --> 00:35:03,200
and acceptable but of course like when

00:35:01,790 --> 00:35:05,330
you start talking with my trainers who

00:35:03,200 --> 00:35:08,060
have to take a team I think this number

00:35:05,330 --> 00:35:11,450
of this so I had with benchmark which I

00:35:08,060 --> 00:35:13,880
was given by nd and when I think English

00:35:11,450 --> 00:35:15,770
numbers that he said he would said he

00:35:13,880 --> 00:35:17,060
would be sad if he sees anything

00:35:15,770 --> 00:35:19,970
when two to three percent degradation

00:35:17,060 --> 00:35:22,100
and as we stay kind of nicely shows you

00:35:19,970 --> 00:35:24,080
but you're not able to reach that goal

00:35:22,100 --> 00:35:26,090
and by the way he told me to measure

00:35:24,080 --> 00:35:28,670
everything with page table isolation off

00:35:26,090 --> 00:35:30,080
because you first of you know it's

00:35:28,670 --> 00:35:32,660
nothing to be related with this feature

00:35:30,080 --> 00:35:34,910
but it's it's this isolation between

00:35:32,660 --> 00:35:36,410
kernel and user space page tables which

00:35:34,910 --> 00:35:38,420
were done because of speculative

00:35:36,410 --> 00:35:40,130
execution and it kind of the main thing

00:35:38,420 --> 00:35:43,100
for it it was it would slow down with

00:35:40,130 --> 00:35:45,410
this called performance so when I was

00:35:43,100 --> 00:35:47,540
asked to measure this feature I was said

00:35:45,410 --> 00:35:49,340
that okay measure against our good old

00:35:47,540 --> 00:35:51,890
days please no not this kind of slow

00:35:49,340 --> 00:35:53,930
down things so so this is the bottom

00:35:51,890 --> 00:35:55,610
line and as you can see but like if you

00:35:53,930 --> 00:35:57,680
measure even timestamp counter again

00:35:55,610 --> 00:36:00,620
it's the way this is six percent so and

00:35:57,680 --> 00:36:02,330
of course nothing like always get random

00:36:00,620 --> 00:36:03,980
by doesn't it doesn't it kind of it's

00:36:02,330 --> 00:36:05,840
it's I have a four percent in first case

00:36:03,980 --> 00:36:07,790
of fourteen and and red seem to be too

00:36:05,840 --> 00:36:09,710
much for my trainers to consider but

00:36:07,790 --> 00:36:12,410
again this is like micro benchmarking

00:36:09,710 --> 00:36:15,290
which doesn't show anything on on real

00:36:12,410 --> 00:36:17,780
case narrow so if you again his reload

00:36:15,290 --> 00:36:19,760
example like for example Caroline

00:36:17,780 --> 00:36:21,560
compiled time we see that we percentage

00:36:19,760 --> 00:36:23,540
increase we're talking about is really

00:36:21,560 --> 00:36:26,200
tiny so it's it's really not gonna kind

00:36:23,540 --> 00:36:29,180
of affect your real workload but if you

00:36:26,200 --> 00:36:31,760
start to bench make rebenchmarking when

00:36:29,180 --> 00:36:34,400
you can kind of get stuck when this is

00:36:31,760 --> 00:36:37,010
very spatially but you said stop talking

00:36:34,400 --> 00:36:38,870
about it's it's micro benchmark

00:36:37,010 --> 00:36:40,310
performance so because I looked into

00:36:38,870 --> 00:36:42,050
different of his options and I was

00:36:40,310 --> 00:36:44,030
looking into can we speed up and get

00:36:42,050 --> 00:36:47,390
random bytes but I have proof

00:36:44,030 --> 00:36:49,730
performance profile did but it's it's

00:36:47,390 --> 00:36:51,440
using earlier and in some cases which

00:36:49,730 --> 00:36:53,360
slows down but Renault words of course

00:36:51,440 --> 00:36:55,790
charger permutation itself which can be

00:36:53,360 --> 00:36:58,760
kind of touched and and so I didn't see

00:36:55,790 --> 00:37:00,320
any secure way to speed it up many

00:36:58,760 --> 00:37:02,270
insecure ways but we don't want to go

00:37:00,320 --> 00:37:04,040
over so in principle what kind of my

00:37:02,270 --> 00:37:05,780
idea here was what you don't have we are

00:37:04,040 --> 00:37:07,910
not in the case where we need the crypto

00:37:05,780 --> 00:37:09,800
level randomness we are not because we

00:37:07,910 --> 00:37:11,840
cryptographic secure number generators

00:37:09,800 --> 00:37:13,610
have a number of principles or a number

00:37:11,840 --> 00:37:15,350
of features which we don't need like for

00:37:13,610 --> 00:37:17,990
example back trace resistance so that

00:37:15,350 --> 00:37:19,580
you are able to kind of produce you if

00:37:17,990 --> 00:37:21,770
you're seeing certain random numbers

00:37:19,580 --> 00:37:23,720
which produced by your generator but

00:37:21,770 --> 00:37:25,280
you're not able to kind of find out

00:37:23,720 --> 00:37:27,740
whatever previous wants we don't care

00:37:25,280 --> 00:37:29,210
because after iris offset is reused

00:37:27,740 --> 00:37:30,740
you don't know once in the system call

00:37:29,210 --> 00:37:33,710
and it's not going to be affected and

00:37:30,740 --> 00:37:35,180
kind of in run time anymore so this kind

00:37:33,710 --> 00:37:37,640
of feature wouldn't make sense for us of

00:37:35,180 --> 00:37:39,020
course we future resistance or what you

00:37:37,640 --> 00:37:41,990
can't predict the future and put is

00:37:39,020 --> 00:37:44,060
important but so I looked at some point

00:37:41,990 --> 00:37:46,280
I need to convey for example if we have

00:37:44,060 --> 00:37:47,450
this beer random which is super old or

00:37:46,280 --> 00:37:49,460
in a kernel

00:37:47,450 --> 00:37:51,560
can we actually substitute that or can

00:37:49,460 --> 00:37:53,810
we start to use a bit more modern kind

00:37:51,560 --> 00:37:56,900
of up-to-date random number generator

00:37:53,810 --> 00:37:58,369
like this PCG number generator for

00:37:56,900 --> 00:38:00,830
example which is not it's not

00:37:58,369 --> 00:38:03,619
cryptographically secure but it's still

00:38:00,830 --> 00:38:06,500
it does provide some more it provides a

00:38:03,619 --> 00:38:08,210
better properties not just randomly

00:38:06,500 --> 00:38:10,250
statistical properties but still like

00:38:08,210 --> 00:38:12,320
it's not so easy it's supposed to be not

00:38:10,250 --> 00:38:13,730
so easy to invert to stage from it but

00:38:12,320 --> 00:38:15,140
again it's not cryptographically secure

00:38:13,730 --> 00:38:17,420
so I'm not proposing to you with a

00:38:15,140 --> 00:38:19,880
crypto but it might have been possible

00:38:17,420 --> 00:38:21,320
to use it for this case but I have made

00:38:19,880 --> 00:38:22,490
this proposal mailing list and I don't

00:38:21,320 --> 00:38:25,010
think I know what kind of been

00:38:22,490 --> 00:38:27,230
interested to when this whole idea

00:38:25,010 --> 00:38:31,970
emerges or kind of didn't didn't go that

00:38:27,230 --> 00:38:33,800
way so okay so to summary so supposed to

00:38:31,970 --> 00:38:36,950
even get this merged Richard first point

00:38:33,800 --> 00:38:38,600
I don't think we will get but is it is

00:38:36,950 --> 00:38:40,760
it like so we addressed a current a

00:38:38,600 --> 00:38:43,400
mutation so but one thing is it like

00:38:40,760 --> 00:38:44,930
other good now is it is we're done so I

00:38:43,400 --> 00:38:46,640
think what kind of important thing to

00:38:44,930 --> 00:38:48,530
remember about randomization with it's

00:38:46,640 --> 00:38:51,170
always just a kind of a way to raise the

00:38:48,530 --> 00:38:52,940
bar for truckers so and and it can't be

00:38:51,170 --> 00:38:54,410
like any randomization kind of beep a

00:38:52,940 --> 00:38:55,940
not say you're usually kind of new to

00:38:54,410 --> 00:38:58,190
try it couple it with additional

00:38:55,940 --> 00:39:00,560
measurement of additional measures to

00:38:58,190 --> 00:39:02,420
make it robust and and for example

00:39:00,560 --> 00:39:03,950
things would be really nice to have in

00:39:02,420 --> 00:39:06,470
the kernel is things like this control

00:39:03,950 --> 00:39:09,020
flow integrity so but I think we are

00:39:06,470 --> 00:39:11,119
still not so close for getting it

00:39:09,020 --> 00:39:13,640
anywhere to be usable and up stripped

00:39:11,119 --> 00:39:16,280
kernels so but it might be pretty nice

00:39:13,640 --> 00:39:18,109
so here we references which I promised

00:39:16,280 --> 00:39:20,150
so it's a basically references for all

00:39:18,109 --> 00:39:22,010
the talks I talked about and and we're

00:39:20,150 --> 00:39:24,470
really great to kind of read the details

00:39:22,010 --> 00:39:26,780
and I really encourage you to go kind of

00:39:24,470 --> 00:39:28,369
study VIII it was a fun process for me

00:39:26,780 --> 00:39:31,070
and I learned a lot of things from this

00:39:28,369 --> 00:39:32,720
and I'm grateful to every single explode

00:39:31,070 --> 00:39:34,700
writer from this list would teach me

00:39:32,720 --> 00:39:37,349
enormous things so I don't know if you

00:39:34,700 --> 00:39:40,910
have time for Q&A or oh I'm fully out

00:39:37,349 --> 00:39:40,910
okay so questions

00:39:54,550 --> 00:39:59,560
so this may be because my I have a

00:39:57,010 --> 00:40:02,530
hardware background but this feels like

00:39:59,560 --> 00:40:05,080
something where hardware in the CPU

00:40:02,530 --> 00:40:07,810
could help and I know I can't go any

00:40:05,080 --> 00:40:10,450
more than just this feeling so are

00:40:07,810 --> 00:40:12,130
people looking at that at all so this

00:40:10,450 --> 00:40:14,560
aired around instruction which I

00:40:12,130 --> 00:40:16,960
mentioned with CPU instruction to obtain

00:40:14,560 --> 00:40:20,140
randomness the problem as I said it was

00:40:16,960 --> 00:40:21,700
very slow so it's also possible with

00:40:20,140 --> 00:40:25,000
where more have been pointed for example

00:40:21,700 --> 00:40:26,980
some of the perfectly instructions which

00:40:25,000 --> 00:40:28,570
not security instructions but related to

00:40:26,980 --> 00:40:31,060
obtaining some randomness from some

00:40:28,570 --> 00:40:32,800
physical kind of hardware things what I

00:40:31,060 --> 00:40:34,180
didn't want I want us to be generic

00:40:32,800 --> 00:40:35,920
enough so I didn't want to try it with

00:40:34,180 --> 00:40:37,540
Johnny because this is where talking but

00:40:35,920 --> 00:40:39,760
upstream kernel when I'm talking about

00:40:37,540 --> 00:40:41,920
particular project so it had to kind of

00:40:39,760 --> 00:40:43,600
work on any hardware so you'd have to

00:40:41,920 --> 00:40:46,300
anyway have some backup which is

00:40:43,600 --> 00:40:47,860
reasonable backup to kind of v2 to work

00:40:46,300 --> 00:40:49,120
it if you don't have this instruction or

00:40:47,860 --> 00:40:51,340
you're in a different architecture or

00:40:49,120 --> 00:40:53,200
something even of course this space code

00:40:51,340 --> 00:40:54,910
would be executed need NICs eighty-sixed

00:40:53,200 --> 00:40:57,190
case so in principle i could tied myself

00:40:54,910 --> 00:40:59,350
to x86 and save it okay we use aired

00:40:57,190 --> 00:41:00,790
around or something else but ideally i

00:40:59,350 --> 00:41:03,220
was really hoping to get something which

00:41:00,790 --> 00:41:04,450
is known generic enough and and and

00:41:03,220 --> 00:41:07,720
because you will need to make this

00:41:04,450 --> 00:41:11,040
generic backup button with generic

00:41:07,720 --> 00:41:13,870
options tend to be very very difficult

00:41:11,040 --> 00:41:15,970
this is a question regarding this the

00:41:13,870 --> 00:41:18,040
hardware support is where like so you

00:41:15,970 --> 00:41:19,570
see it I guess if there was register

00:41:18,040 --> 00:41:22,210
that could maintain the limits of the

00:41:19,570 --> 00:41:23,860
stack such sort of checking could be

00:41:22,210 --> 00:41:27,280
done cheaply and from the hardware

00:41:23,860 --> 00:41:29,470
itself so wouldn't that be another like

00:41:27,280 --> 00:41:31,090
a boundary this is a stack pointer and

00:41:29,470 --> 00:41:32,110
this is how much it is supposed to how

00:41:31,090 --> 00:41:35,530
much it can go for this particular

00:41:32,110 --> 00:41:37,540
context so you're talking about the

00:41:35,530 --> 00:41:39,130
stock overflow I think it's partly done

00:41:37,540 --> 00:41:41,770
so if you're trying to kind of now with

00:41:39,130 --> 00:41:43,540
this part of is the malloc stock

00:41:41,770 --> 00:41:45,100
allocation and guard page it's a very

00:41:43,540 --> 00:41:47,080
serious detection which suppose so if

00:41:45,100 --> 00:41:48,790
you get to its double fault and and

00:41:47,080 --> 00:41:51,100
you're verifying but it's it's close to

00:41:48,790 --> 00:41:52,720
the end of stock so it's your

00:41:51,100 --> 00:41:54,850
understanding with your overflow is talk

00:41:52,720 --> 00:41:57,010
and stuff so where is the software not

00:41:54,850 --> 00:41:59,890
hardware specific but software specific

00:41:57,010 --> 00:42:02,170
logic with nd Footwear which tries to

00:41:59,890 --> 00:42:04,360
kind of verify you the stuff but I mean

00:42:02,170 --> 00:42:06,490
ret logic is only basically Bob kind of

00:42:04,360 --> 00:42:07,200
it's gets invoked when you double fault

00:42:06,490 --> 00:42:09,150
and

00:42:07,200 --> 00:42:11,280
double fault you kind of get her to

00:42:09,150 --> 00:42:12,930
arrive to double fold and if you're kind

00:42:11,280 --> 00:42:14,609
of managing to trick with thing to kind

00:42:12,930 --> 00:42:16,650
of pathways like our jumping or

00:42:14,609 --> 00:42:20,960
something when it's what is the hardware

00:42:16,650 --> 00:42:24,599
logic you're going to use so thanks for

00:42:20,960 --> 00:42:25,890
have a question about I would like to

00:42:24,599 --> 00:42:28,650
ask your opinion while talking about

00:42:25,890 --> 00:42:30,930
hardware like for example intercity

00:42:28,650 --> 00:42:32,970
which is using the shadow stocks which

00:42:30,930 --> 00:42:34,770
should be quite efficient and also this

00:42:32,970 --> 00:42:36,119
arm has this point authentication and so

00:42:34,770 --> 00:42:40,079
on how do you see using these

00:42:36,119 --> 00:42:42,660
technologies for protecting it's again

00:42:40,079 --> 00:42:44,490
it can be usable knowledge again the

00:42:42,660 --> 00:42:46,349
problem with that is that it's gonna be

00:42:44,490 --> 00:42:48,180
Hardware specific so you're going to

00:42:46,349 --> 00:42:50,730
have one Intel kind of technology for

00:42:48,180 --> 00:42:52,740
this thing be at an arm for something

00:42:50,730 --> 00:42:53,820
else so I'm deed for things I was trying

00:42:52,740 --> 00:42:55,710
to kind of again we are talking about

00:42:53,820 --> 00:42:57,359
upstream kernel not particular project

00:42:55,710 --> 00:43:00,300
so you try to think make something

00:42:57,359 --> 00:43:02,369
generic so in bed light is kind of basic

00:43:00,300 --> 00:43:04,650
to specific so a probably if you have

00:43:02,369 --> 00:43:06,510
some concrete product you're doing on

00:43:04,650 --> 00:43:08,640
and and variable you're not limited by

00:43:06,510 --> 00:43:10,589
the sub stream thing you can kind of be

00:43:08,640 --> 00:43:12,390
you can't even go I mean patches aware

00:43:10,589 --> 00:43:13,619
you can enable it with and if you're

00:43:12,390 --> 00:43:15,270
able to take certain I don't know what

00:43:13,619 --> 00:43:17,670
performance hits for example would be

00:43:15,270 --> 00:43:19,079
from using of that even air Durant which

00:43:17,670 --> 00:43:21,089
is the CPU instruction which was

00:43:19,079 --> 00:43:22,619
completely like I was like when I looked

00:43:21,089 --> 00:43:24,119
at the performance numbers I was

00:43:22,619 --> 00:43:25,829
thinking it's the CPU instructions

00:43:24,119 --> 00:43:28,260
should be fast and when I was looking at

00:43:25,829 --> 00:43:29,760
the numbers it was horrid so I'm afraid

00:43:28,260 --> 00:43:31,619
with read my I don't know what's way

00:43:29,760 --> 00:43:34,319
overhead fall of that technologist but

00:43:31,619 --> 00:43:36,420
it's yeah so but if you are not

00:43:34,319 --> 00:43:38,550
performance sensitive I think you have a

00:43:36,420 --> 00:43:42,480
lot of options here and you can make it

00:43:38,550 --> 00:43:45,750
relatively easy so so I sort of tweet

00:43:42,480 --> 00:43:51,119
this morning that LLVM support for the

00:43:45,750 --> 00:43:56,700
control flow guard has been submitted so

00:43:51,119 --> 00:44:02,589
LLVM can build the kernel but for the

00:43:56,700 --> 00:44:05,279
compiler LLVM build the Linux kernel

00:44:02,589 --> 00:44:05,279
okay

00:44:07,440 --> 00:44:15,300
okay JCCC unfortunately doesn't have

00:44:10,170 --> 00:44:19,290
that here yes not maybe we should switch

00:44:15,300 --> 00:44:23,040
to something else so was that the relays

00:44:19,290 --> 00:44:25,849
had to be removed to get LLVM support

00:44:23,040 --> 00:44:25,849
was that related

00:44:31,650 --> 00:44:37,790
okay I think we're out of time in this

00:44:34,110 --> 00:44:37,790

YouTube URL: https://www.youtube.com/watch?v=FacpjoQbMhU


