Title: Binary Policy with IMA and AppArmor - Eric Chiang, Google
Publication date: 2019-08-28
Playlist: Linux Security Summit NA 2019 - San Diego
Description: 
	Binary Policy with IMA and AppArmor - Eric Chiang, Google 

Google operates one of the largest fleet of developer machines, supporting a wide range of user workflows and expectations. While techniques such as social voting of binaries for whitelisting on other OSes have been successful, Corp Security has taken novel approaches on Linux workstations for providence based policy. Over the past year Eric’s worked to build features into AppArmor for targeting IMA signatures, enabling restrictions of executables that don’t originate from Google’s centralized package repositories. This talk will dive into the technical aspects of Google’s binary signing and operational challenges rolling out restrictive policies at scale.
Captions: 
	00:00:00,030 --> 00:00:05,279
hi everybody my name is Eric I am also

00:00:02,970 --> 00:00:07,820
on the platform security team at Google

00:00:05,279 --> 00:00:10,139
one of the many puff home security teams

00:00:07,820 --> 00:00:13,410
and yeah today's talk is called the

00:00:10,139 --> 00:00:16,199
binary policy with imma and a primer so

00:00:13,410 --> 00:00:18,000
I work on a platform security team at

00:00:16,199 --> 00:00:19,529
Google apiary team

00:00:18,000 --> 00:00:21,449
the platforms that we were securing are

00:00:19,529 --> 00:00:23,670
basically all of our corporate devices

00:00:21,449 --> 00:00:25,289
so you come in you want to work at

00:00:23,670 --> 00:00:26,760
Google we hand you a laptop we hand you

00:00:25,289 --> 00:00:28,529
a phone we hand you our workstation

00:00:26,760 --> 00:00:33,030
maybe not hand you but you get a

00:00:28,529 --> 00:00:34,469
workstation and this so but the primary

00:00:33,030 --> 00:00:36,390
motivation of this talk is gonna be

00:00:34,469 --> 00:00:38,160
talking about how we are doing some

00:00:36,390 --> 00:00:41,250
things to actually do weight security at

00:00:38,160 --> 00:00:44,820
Google we have a lot of devices at

00:00:41,250 --> 00:00:46,920
Google published in 2017 said we had a

00:00:44,820 --> 00:00:48,360
quarter million machines you might

00:00:46,920 --> 00:00:50,280
imagine that that number has increased

00:00:48,360 --> 00:00:52,850
in a couple years

00:00:50,280 --> 00:00:56,480
and a lot of Linux so these are

00:00:52,850 --> 00:01:00,420
workstations laptops cloud vm's

00:00:56,480 --> 00:01:02,789
servers you name it we have it and we do

00:01:00,420 --> 00:01:05,040
our best to try to secure it one of the

00:01:02,789 --> 00:01:07,049
interesting aspects of the way that

00:01:05,040 --> 00:01:08,909
Google operates and operates this fleet

00:01:07,049 --> 00:01:11,580
of machines is that we also have central

00:01:08,909 --> 00:01:13,740
app repos for any software we distribute

00:01:11,580 --> 00:01:15,659
so you're when you're working at Google

00:01:13,740 --> 00:01:18,299
and you have a Linux device you're

00:01:15,659 --> 00:01:19,409
generally not going and downloading from

00:01:18,299 --> 00:01:21,090
the internet hopefully you were

00:01:19,409 --> 00:01:23,430
downloading from our central repos where

00:01:21,090 --> 00:01:26,159
we have built everything and sort of

00:01:23,430 --> 00:01:28,920
have secured that particular aspect of

00:01:26,159 --> 00:01:32,159
it so there are a lot of ways that we

00:01:28,920 --> 00:01:33,920
try to do security for devices basically

00:01:32,159 --> 00:01:36,590
most of my job is making sure that

00:01:33,920 --> 00:01:39,299
kernels are up-to-date and people reboot

00:01:36,590 --> 00:01:41,250
but sometimes I get to do some cool

00:01:39,299 --> 00:01:43,979
stuff so this talk is primarily about

00:01:41,250 --> 00:01:45,810
execution control basically when we get

00:01:43,979 --> 00:01:47,610
new binaries on the system that want to

00:01:45,810 --> 00:01:50,759
do malicious things how can we prevent

00:01:47,610 --> 00:01:54,380
that how can we think about that this is

00:01:50,759 --> 00:01:58,399
not a new problem or unique to Linux so

00:01:54,380 --> 00:02:02,000
Google has released Santa which is a a

00:01:58,399 --> 00:02:04,950
binary execution control mechanism for

00:02:02,000 --> 00:02:07,619
Mac OS and this is just a kernel module

00:02:04,950 --> 00:02:09,330
that allows us to do allow this type of

00:02:07,619 --> 00:02:12,870
commissioning and say that this

00:02:09,330 --> 00:02:14,069
particular application can run and we

00:02:12,870 --> 00:02:15,750
can also base things like

00:02:14,069 --> 00:02:19,049
the signature I'm chaining up to

00:02:15,750 --> 00:02:21,230
particular publishers we have sort of

00:02:19,049 --> 00:02:23,670
similar capabilities for Windows as well

00:02:21,230 --> 00:02:25,110
the way you might use this at Google is

00:02:23,670 --> 00:02:27,090
you might use it something like our

00:02:25,110 --> 00:02:30,239
system that we open source called upload

00:02:27,090 --> 00:02:32,310
upload is a social allow list mechanism

00:02:30,239 --> 00:02:34,470
the way this works is that you want to

00:02:32,310 --> 00:02:36,030
run something new on your machine in

00:02:34,470 --> 00:02:40,500
order to actually run it you have to go

00:02:36,030 --> 00:02:42,599
to a you I say vote to whitelist this

00:02:40,500 --> 00:02:44,340
and then you can run it or in particular

00:02:42,599 --> 00:02:46,890
cases you can configure this to say like

00:02:44,340 --> 00:02:48,959
I have to ping a co-worker and have them

00:02:46,890 --> 00:02:50,579
upload it to and then eventually you

00:02:48,959 --> 00:02:52,590
know if there gets enough votes you

00:02:50,579 --> 00:02:54,409
might be globally whitelisted or

00:02:52,590 --> 00:02:59,190
something like that

00:02:54,409 --> 00:02:59,700
but what about Linux so doing this sort

00:02:59,190 --> 00:03:02,099
of whitelist

00:02:59,700 --> 00:03:05,220
approach on Linux is kind of convoluted

00:03:02,099 --> 00:03:07,200
the memory use of this is as developer

00:03:05,220 --> 00:03:08,340
workstations so you might imagine if

00:03:07,200 --> 00:03:10,829
you're doing development on a large

00:03:08,340 --> 00:03:12,329
source tree through that you're gonna be

00:03:10,829 --> 00:03:13,620
building New York's peoples all the time

00:03:12,329 --> 00:03:15,629
you're gonna be running them and it's

00:03:13,620 --> 00:03:17,879
basically infeasible for you to be going

00:03:15,629 --> 00:03:19,650
to a UI and clicking upload every time

00:03:17,879 --> 00:03:23,190
one of our tests or every time you want

00:03:19,650 --> 00:03:25,410
to build something and just right so

00:03:23,190 --> 00:03:28,230
this talk is about an experiment that we

00:03:25,410 --> 00:03:31,650
are piloting at Google internally with a

00:03:28,230 --> 00:03:32,669
plumber so the basic idea is to sign all

00:03:31,650 --> 00:03:34,530
the things that come from our

00:03:32,669 --> 00:03:36,629
centralized repo then we were gonna have

00:03:34,530 --> 00:03:38,669
some sort of policy around those

00:03:36,629 --> 00:03:39,989
signatures so you say that if you're

00:03:38,669 --> 00:03:41,220
trying to access if you're a binary and

00:03:39,989 --> 00:03:43,500
you're trying to access like a Google

00:03:41,220 --> 00:03:45,000
credential you should clearly be from

00:03:43,500 --> 00:03:47,280
our central repository otherwise you

00:03:45,000 --> 00:03:49,470
wouldn't even know where that Google

00:03:47,280 --> 00:03:53,190
credentials should be so this will allow

00:03:49,470 --> 00:03:55,530
us to do things like block access to

00:03:53,190 --> 00:03:58,620
Google resources from things that aren't

00:03:55,530 --> 00:04:01,109
Google you can also you can also do this

00:03:58,620 --> 00:04:02,579
too but a very important aspect of this

00:04:01,109 --> 00:04:05,129
is we still want to allow you to be able

00:04:02,579 --> 00:04:07,019
to run unsigned code so as you're doing

00:04:05,129 --> 00:04:08,519
your development locally as they're

00:04:07,019 --> 00:04:10,859
building executables and running them to

00:04:08,519 --> 00:04:14,430
do testing we want that all to still

00:04:10,859 --> 00:04:19,079
kind of work I also want to stress the

00:04:14,430 --> 00:04:20,729
experiment aspect this we got some of

00:04:19,079 --> 00:04:25,380
this working and a lot of this is lies

00:04:20,729 --> 00:04:27,660
so don't assume that we have this all

00:04:25,380 --> 00:04:31,250
working and everything's amazing

00:04:27,660 --> 00:04:33,720
it's janky and hacky all over the place

00:04:31,250 --> 00:04:35,250
so the first thing we're gonna go

00:04:33,720 --> 00:04:37,260
through is just talking about ia and

00:04:35,250 --> 00:04:39,510
sort of what aspects we use of it and

00:04:37,260 --> 00:04:40,680
give you little tutorials though seems a

00:04:39,510 --> 00:04:43,440
lot of people are familiar with the sub

00:04:40,680 --> 00:04:44,970
system so I'm a has a lot of

00:04:43,440 --> 00:04:47,460
capabilities you know I can interact

00:04:44,970 --> 00:04:48,930
with TPMS and do stuff but the ones that

00:04:47,460 --> 00:04:51,090
we really care about are these three

00:04:48,930 --> 00:04:53,910
properties of auditing appraising and

00:04:51,090 --> 00:04:55,620
protecting so auditing just logging

00:04:53,910 --> 00:04:57,690
executables as they run this is not

00:04:55,620 --> 00:04:59,160
necessarily related related to this

00:04:57,690 --> 00:05:01,650
particular experiment but it's something

00:04:59,160 --> 00:05:05,670
that we definitely use appraisal of

00:05:01,650 --> 00:05:06,480
actually when actions occur verifying

00:05:05,670 --> 00:05:08,340
signatures

00:05:06,480 --> 00:05:11,730
very important and then protecting is

00:05:08,340 --> 00:05:14,280
similar to appraise where we actually

00:05:11,730 --> 00:05:17,550
want to verify other aspects of the

00:05:14,280 --> 00:05:22,350
binary and other metadata the way that

00:05:17,550 --> 00:05:25,320
you interact with imma excuse me is

00:05:22,350 --> 00:05:30,570
there's a policy file under security FS

00:05:25,320 --> 00:05:32,760
you write a policy to it fun stuff this

00:05:30,570 --> 00:05:34,680
will this policy file will disappear

00:05:32,760 --> 00:05:37,020
after you write to it and there are some

00:05:34,680 --> 00:05:38,370
configurations you can have to like have

00:05:37,020 --> 00:05:43,320
it stick around so you can read from it

00:05:38,370 --> 00:05:45,870
or write it again for the auditing

00:05:43,320 --> 00:05:48,290
capabilities you can do stuff like set

00:05:45,870 --> 00:05:51,750
up rules to say whenever this particular

00:05:48,290 --> 00:05:55,020
whenever a new binary runs audit this to

00:05:51,750 --> 00:05:57,240
the syslog or Auto D something and

00:05:55,020 --> 00:05:59,940
essentially you get useful information

00:05:57,240 --> 00:06:02,460
that can help with your analytics of the

00:05:59,940 --> 00:06:04,530
fleet so you might imagine that somebody

00:06:02,460 --> 00:06:06,240
runs any binary it spits out a hash and

00:06:04,530 --> 00:06:09,240
you run this against fives total and say

00:06:06,240 --> 00:06:10,680
like okay is this a node Bitcoin liner

00:06:09,240 --> 00:06:15,060
that we probably want to kick off from

00:06:10,680 --> 00:06:16,200
your system there's tons of stuff you

00:06:15,060 --> 00:06:18,630
can do with this particular policy

00:06:16,200 --> 00:06:19,800
language so you can say stuff like don't

00:06:18,630 --> 00:06:23,040
measure a particular types of file

00:06:19,800 --> 00:06:25,710
systems for this one it's proc you can

00:06:23,040 --> 00:06:27,930
also have conditionals like check audio

00:06:25,710 --> 00:06:31,080
on file checks but only for right

00:06:27,930 --> 00:06:33,930
permissions you can also do stuff like

00:06:31,080 --> 00:06:35,460
say ok only do it for root and the one

00:06:33,930 --> 00:06:37,440
that we actually care about is the

00:06:35,460 --> 00:06:39,000
subject roll one this is originally for

00:06:37,440 --> 00:06:41,580
SELinux but totally works for Apple more

00:06:39,000 --> 00:06:43,800
- it basically says

00:06:41,580 --> 00:06:47,190
only execute this particular appraisal

00:06:43,800 --> 00:06:48,509
or audit or something if the process is

00:06:47,190 --> 00:06:52,440
going to be running as in particular

00:06:48,509 --> 00:06:54,000
profile as I in a particular role so for

00:06:52,440 --> 00:06:56,370
this case you could do something like

00:06:54,000 --> 00:06:58,440
this would only trigger if the process

00:06:56,370 --> 00:07:03,030
was running as my FMO profile a

00:06:58,440 --> 00:07:04,259
particular profile and then for

00:07:03,030 --> 00:07:07,340
appraisal you actually have to specify

00:07:04,259 --> 00:07:10,770
this in the policy so you can say

00:07:07,340 --> 00:07:13,410
appraise for image signatures or IMS

00:07:10,770 --> 00:07:14,340
signatures we won't talk about hash for

00:07:13,410 --> 00:07:16,169
this today because it's not quite

00:07:14,340 --> 00:07:17,669
relevant but that's the default so in

00:07:16,169 --> 00:07:18,840
order to say check for a signature you

00:07:17,669 --> 00:07:22,650
have to actually add this additional

00:07:18,840 --> 00:07:24,500
thing to your policy and then the way

00:07:22,650 --> 00:07:28,169
it's put up is that you have imma imma

00:07:24,500 --> 00:07:30,569
validates the contents of the file and

00:07:28,169 --> 00:07:32,849
is stored as extended attribute so it's

00:07:30,569 --> 00:07:36,300
security down imma and then there's EVM

00:07:32,849 --> 00:07:38,849
EVM allows us to sign other security

00:07:36,300 --> 00:07:43,050
expenditure tributes so it won't it's

00:07:38,849 --> 00:07:45,630
just for like I'm a SELinux capabilities

00:07:43,050 --> 00:07:47,940
those type of things you enable it this

00:07:45,630 --> 00:07:49,440
way and this is actually gonna be really

00:07:47,940 --> 00:07:51,090
important when we talk about adding

00:07:49,440 --> 00:07:53,969
additional metadata to a particular file

00:07:51,090 --> 00:07:58,139
later on that we might want to use in

00:07:53,969 --> 00:07:59,969
the future what that looks like is that

00:07:58,139 --> 00:08:02,430
when you go ahead and look at a

00:07:59,969 --> 00:08:04,740
particular binary on a Linux system for

00:08:02,430 --> 00:08:07,530
us you would you might see a additional

00:08:04,740 --> 00:08:09,240
extended attributes security vm Sakura

00:08:07,530 --> 00:08:10,259
imma these are just going to be file

00:08:09,240 --> 00:08:11,940
signature these are going to be

00:08:10,259 --> 00:08:16,110
signatures over either the file contents

00:08:11,940 --> 00:08:17,759
or the other extended attributes just a

00:08:16,110 --> 00:08:19,199
quick slide if you're ever implementing

00:08:17,759 --> 00:08:20,550
this it's not just a signature it's

00:08:19,199 --> 00:08:22,469
actually a header with the signature

00:08:20,550 --> 00:08:24,680
that's really important if you want to

00:08:22,469 --> 00:08:27,180
like do this in your centralized repo

00:08:24,680 --> 00:08:28,830
but otherwise you can just use something

00:08:27,180 --> 00:08:30,539
like EMC tail and you're not

00:08:28,830 --> 00:08:34,800
implementing mr. self just use of the

00:08:30,539 --> 00:08:40,469
utilities distributing signatures has

00:08:34,800 --> 00:08:42,240
been fun so we are a derivative of

00:08:40,469 --> 00:08:45,899
debian so we're gonna be using stuff

00:08:42,240 --> 00:08:47,160
like deep package and apt Debian has

00:08:45,899 --> 00:08:49,400
been thinking about this problem for

00:08:47,160 --> 00:08:54,140
quite a while but doesn't have

00:08:49,400 --> 00:08:56,480
a solution ready to go so there's been a

00:08:54,140 --> 00:08:58,310
lot of thinking while identification the

00:08:56,480 --> 00:09:01,279
hacky way that we basically solved this

00:08:58,310 --> 00:09:04,910
is shipping a dot entry file as part of

00:09:01,279 --> 00:09:06,860
the Deb M trees described file

00:09:04,910 --> 00:09:09,110
attributes but you can use them to

00:09:06,860 --> 00:09:12,200
basically say that particular file would

00:09:09,110 --> 00:09:14,510
have a bunch of extended attributes so

00:09:12,200 --> 00:09:17,600
if you were to go ahead and open a Deb

00:09:14,510 --> 00:09:21,130
of ours you would see basically an entry

00:09:17,600 --> 00:09:23,720
file in the control tar.gz

00:09:21,130 --> 00:09:29,600
that m g-- file eventually gets written

00:09:23,720 --> 00:09:31,250
to Varla d package info and has a list

00:09:29,600 --> 00:09:32,660
of files in the Dead and then additional

00:09:31,250 --> 00:09:35,570
signatures that we've added from our

00:09:32,660 --> 00:09:37,520
centralized repo so this has a extended

00:09:35,570 --> 00:09:40,850
attribute security i'ma if you went

00:09:37,520 --> 00:09:46,460
further on to the left you would see EVM

00:09:40,850 --> 00:09:48,290
and security app Armour as well this is

00:09:46,460 --> 00:09:51,440
one of the hacky aspects of this

00:09:48,290 --> 00:09:53,900
solution so the way that we actually get

00:09:51,440 --> 00:09:55,370
the foot the signatures onto disk is we

00:09:53,900 --> 00:09:56,990
just have a deep package hook deep

00:09:55,370 --> 00:09:59,959
package allows you to have hooks that

00:09:56,990 --> 00:10:02,959
just sort of like execute whenever deep

00:09:59,959 --> 00:10:06,020
package before or after D package and

00:10:02,959 --> 00:10:09,050
then we just have a little hook it's

00:10:06,020 --> 00:10:11,150
written in go and it steps through any

00:10:09,050 --> 00:10:13,490
of the EM tree files in the D package

00:10:11,150 --> 00:10:15,320
info directory and we'll go ahead and

00:10:13,490 --> 00:10:18,830
apply those extended attributes to the

00:10:15,320 --> 00:10:21,670
files this is really hacky it has really

00:10:18,830 --> 00:10:24,740
bad implications because like postin and

00:10:21,670 --> 00:10:27,709
pre and don't have the extended

00:10:24,740 --> 00:10:29,630
attributes when they run we would much

00:10:27,709 --> 00:10:32,060
prefer this to be actually in d package

00:10:29,630 --> 00:10:34,730
but our initial sort of worked at them

00:10:32,060 --> 00:10:40,220
to do that hasn't been merged yet and

00:10:34,730 --> 00:10:41,930
we'll see if when that happens key rings

00:10:40,220 --> 00:10:43,880
or another fun part of dealing with imma

00:10:41,930 --> 00:10:47,390
there was a great talk about keyring

00:10:43,880 --> 00:10:50,300
restrictions so the TLDR is that i'm i

00:10:47,390 --> 00:10:53,270
can either use compiled in key rings for

00:10:50,300 --> 00:10:55,250
the IMA or evm but we choose to use a

00:10:53,270 --> 00:10:58,459
user managed key rings underscore eye

00:10:55,250 --> 00:11:00,350
mask or EVM that's how you would sort of

00:10:58,459 --> 00:11:02,570
set this up that's more for notes than

00:11:00,350 --> 00:11:02,810
anything but essentially you just go

00:11:02,570 --> 00:11:04,640
ahead

00:11:02,810 --> 00:11:08,720
create this and like the interim FS and

00:11:04,640 --> 00:11:11,300
load your keys so what about reboots so

00:11:08,720 --> 00:11:13,460
eventually we would like to do sort of

00:11:11,300 --> 00:11:15,080
sort of rotation of these keys we don't

00:11:13,460 --> 00:11:16,510
just want to have the same signing key

00:11:15,080 --> 00:11:18,890
and continue on forever

00:11:16,510 --> 00:11:21,410
unfortunately users don't like to reboot

00:11:18,890 --> 00:11:23,360
we do our best to enforce this but

00:11:21,410 --> 00:11:25,370
ultimately we don't want to have to wait

00:11:23,360 --> 00:11:28,490
like 30 days or something like that to

00:11:25,370 --> 00:11:30,710
for the potentially loading new keys so

00:11:28,490 --> 00:11:35,720
use keyring restrictions yay thank you -

00:11:30,710 --> 00:11:37,220
yes so key restrictions work by you have

00:11:35,720 --> 00:11:39,350
a keyring but then you have another

00:11:37,220 --> 00:11:40,820
keyring that restricts the keyring this

00:11:39,350 --> 00:11:42,620
one is going to be the see a keyring

00:11:40,820 --> 00:11:45,110
when you try to add something to the

00:11:42,620 --> 00:11:47,630
actual keyring you can basically create

00:11:45,110 --> 00:11:49,820
a restriction to say does this

00:11:47,630 --> 00:11:52,430
certificate is this certificate signed

00:11:49,820 --> 00:11:55,490
by another keyring and that allows us to

00:11:52,430 --> 00:11:59,120
do online updates of the key rings that

00:11:55,490 --> 00:12:01,670
I'm an EDM use without requiring the B

00:11:59,120 --> 00:12:07,010
button and this is sort of how you would

00:12:01,670 --> 00:12:08,810
set it up so finally we get on to using

00:12:07,010 --> 00:12:13,250
all of this information that we've just

00:12:08,810 --> 00:12:15,920
set up in a very meticulous way so I've

00:12:13,250 --> 00:12:18,620
been working with a former project and

00:12:15,920 --> 00:12:21,020
matthew guerra as well to add support

00:12:18,620 --> 00:12:23,690
for apparmor targeting extended

00:12:21,020 --> 00:12:25,670
attributes and we sort of done a bit of

00:12:23,690 --> 00:12:28,790
the work to do at the usual and support

00:12:25,670 --> 00:12:33,440
as well so the basic idea that we'd like

00:12:28,790 --> 00:12:35,120
to do is have two tiers of profiles one

00:12:33,440 --> 00:12:36,530
we'll call untrusted things without

00:12:35,120 --> 00:12:40,370
signatures another one you called

00:12:36,530 --> 00:12:41,960
trusted things with signatures so what's

00:12:40,370 --> 00:12:44,390
nice about these particular profiles is

00:12:41,960 --> 00:12:47,270
that the bottom one will say anything

00:12:44,390 --> 00:12:49,820
that has a security EVM or security I'm

00:12:47,270 --> 00:12:52,400
a extended attribute that's gonna match

00:12:49,820 --> 00:12:55,730
this profile and it will attempt to run

00:12:52,400 --> 00:13:00,920
as trusted then we can set up an I'm a

00:12:55,730 --> 00:13:04,190
profile sorry and I'm a policy to say

00:13:00,920 --> 00:13:07,279
that if something has run as trusted

00:13:04,190 --> 00:13:09,560
then we trigger appraisal so this is

00:13:07,279 --> 00:13:11,720
nice because things without signatures

00:13:09,560 --> 00:13:13,940
just completely avoid this block but

00:13:11,720 --> 00:13:15,620
anything that attempts to run in this

00:13:13,940 --> 00:13:16,120
trusted profile something that maybe

00:13:15,620 --> 00:13:18,839
could

00:13:16,120 --> 00:13:21,610
Google credentials is now going to be

00:13:18,839 --> 00:13:25,300
appraised so these must match an order

00:13:21,610 --> 00:13:27,850
for it to execute a really cute trick

00:13:25,300 --> 00:13:31,150
here is actually the differences in

00:13:27,850 --> 00:13:33,900
these transactions so untrusted I

00:13:31,150 --> 00:13:36,220
believe is like inherited transactions

00:13:33,900 --> 00:13:38,589
but essentially what this does is

00:13:36,220 --> 00:13:41,560
untrusted is only allowed to transition

00:13:38,589 --> 00:13:43,720
to untrusted trusted is allowed to

00:13:41,560 --> 00:13:45,400
transition to anything why this is

00:13:43,720 --> 00:13:46,900
really important is because if you think

00:13:45,400 --> 00:13:49,270
about all the binaries that we ship

00:13:46,900 --> 00:13:53,200
everything is signed right curl is

00:13:49,270 --> 00:13:55,150
signed cat is signed whatever so what

00:13:53,200 --> 00:13:58,420
those sort of cute transition do is

00:13:55,150 --> 00:14:00,310
create a trust chapter so the way it

00:13:58,420 --> 00:14:03,550
will work is that things with signatures

00:14:00,310 --> 00:14:05,950
will run in trusted but as soon as

00:14:03,550 --> 00:14:08,560
anything in the process tree is

00:14:05,950 --> 00:14:10,480
untrusted it can't get out of untrusted

00:14:08,560 --> 00:14:13,660
it can no longer be trusted

00:14:10,480 --> 00:14:17,320
so we get to this point where you might

00:14:13,660 --> 00:14:19,180
have curl but it depends on how you got

00:14:17,320 --> 00:14:20,830
there that is actually important so if

00:14:19,180 --> 00:14:23,500
anything in your chain wasn't signed

00:14:20,830 --> 00:14:29,560
then you cannot access a Google resource

00:14:23,500 --> 00:14:33,700
as an example scripts suck for this um

00:14:29,560 --> 00:14:35,320
so you know a really easy way that you

00:14:33,700 --> 00:14:38,529
might get around this is just running an

00:14:35,320 --> 00:14:39,970
interpreter that we've signed one of the

00:14:38,529 --> 00:14:42,100
most remarkable things is a farmer

00:14:39,970 --> 00:14:44,920
actually handles shebangs correctly that

00:14:42,100 --> 00:14:47,830
when you execute a script with a shebang

00:14:44,920 --> 00:14:51,310
a polymer will appraise either if you

00:14:47,830 --> 00:14:54,610
just execute the script it will appraise

00:14:51,310 --> 00:14:56,320
and say this is a script or it will it

00:14:54,610 --> 00:14:58,000
will care about the script if you use

00:14:56,320 --> 00:15:00,640
the interpreter directly it leaves the

00:14:58,000 --> 00:15:03,850
interpreter it'll match the interpreter

00:15:00,640 --> 00:15:07,140
and shared libraries are just fine and

00:15:03,850 --> 00:15:11,950
hard to deal with so this is our sort of

00:15:07,140 --> 00:15:13,510
idea of how we deal with us so remember

00:15:11,950 --> 00:15:16,390
that we added additional information to

00:15:13,510 --> 00:15:18,220
the security of a parmer field this will

00:15:16,390 --> 00:15:19,540
hold like the binary name and we can

00:15:18,220 --> 00:15:22,540
actually do matching against this

00:15:19,540 --> 00:15:24,100
because we have secure EVM we know that

00:15:22,540 --> 00:15:25,480
all of these are temperatures that you

00:15:24,100 --> 00:15:27,910
would need to actually have signed the

00:15:25,480 --> 00:15:28,840
binary to fill in this data and if you

00:15:27,910 --> 00:15:32,380
remove security you

00:15:28,840 --> 00:15:34,450
you won't match the trusted profile so

00:15:32,380 --> 00:15:36,990
this allows us to carve out special

00:15:34,450 --> 00:15:39,730
cases where I might want to say okay

00:15:36,990 --> 00:15:40,900
Python isn't trusted if you run the

00:15:39,730 --> 00:15:43,480
script you'll be fine

00:15:40,900 --> 00:15:47,320
directly with shebang you can sign that

00:15:43,480 --> 00:15:48,820
but if you just go ahead and execute the

00:15:47,320 --> 00:15:49,720
interpreter directly you're actually

00:15:48,820 --> 00:15:51,460
going to be in the same tier as

00:15:49,720 --> 00:15:56,490
untrusted and you'll only be able to

00:15:51,460 --> 00:15:59,230
transition to other untrusted contexts

00:15:56,490 --> 00:16:02,440
there are fun caveats with that one

00:15:59,230 --> 00:16:03,880
we're currently support for AIA and EVM

00:16:02,440 --> 00:16:06,700
has a small bug in it so we can't

00:16:03,880 --> 00:16:09,940
actually target it this is getting fixed

00:16:06,700 --> 00:16:12,610
no new prince has bit us a couple times

00:16:09,940 --> 00:16:15,250
we had fun times where he crashed a

00:16:12,610 --> 00:16:16,870
bunch of machines because the way that a

00:16:15,250 --> 00:16:19,420
plumber deals with no new prezz is it

00:16:16,870 --> 00:16:21,220
makes conservative guests about when you

00:16:19,420 --> 00:16:22,990
when you execute no new Prince a plumber

00:16:21,220 --> 00:16:25,660
does not want to allow you to transition

00:16:22,990 --> 00:16:27,750
to a profile with more con with more

00:16:25,660 --> 00:16:29,830
capabilities that seems reasonable but

00:16:27,750 --> 00:16:31,900
it's actually hard for a partner to

00:16:29,830 --> 00:16:34,450
reason if you give it to profiles about

00:16:31,900 --> 00:16:37,930
which one has more or less power

00:16:34,450 --> 00:16:39,880
so conservatively it just denies it this

00:16:37,930 --> 00:16:42,760
actually has caused us some issues where

00:16:39,880 --> 00:16:45,070
um something that is trusted is cumbia

00:16:42,760 --> 00:16:46,480
turns us into untrusted and even though

00:16:45,070 --> 00:16:48,730
that should be fine because it's

00:16:46,480 --> 00:16:50,080
executed no new prince that fails it's

00:16:48,730 --> 00:16:54,880
just we had ever had a lot of fun with

00:16:50,080 --> 00:16:58,030
system D and then there's some fun stuff

00:16:54,880 --> 00:17:00,760
around script modules again and bash now

00:16:58,030 --> 00:17:03,130
remains a pain point this solution

00:17:00,760 --> 00:17:06,550
doesn't solve people curling stuff into

00:17:03,130 --> 00:17:10,690
pipe bash but we hope to have other sort

00:17:06,550 --> 00:17:12,010
of controls separate from it additional

00:17:10,690 --> 00:17:15,160
future work that we've been interested

00:17:12,010 --> 00:17:16,990
in is SEC mark so this is a kernel

00:17:15,160 --> 00:17:20,050
capability that we believe sort of works

00:17:16,990 --> 00:17:21,550
and we're working to add the user land

00:17:20,050 --> 00:17:24,490
support but this is like way in the

00:17:21,550 --> 00:17:26,470
future and basically it works in the

00:17:24,490 --> 00:17:28,060
same way that selinux work you can label

00:17:26,470 --> 00:17:31,660
particular packets and associate them

00:17:28,060 --> 00:17:33,220
with a security context so the way you

00:17:31,660 --> 00:17:37,900
might imagine this is we might write an

00:17:33,220 --> 00:17:39,550
IP table rules for the for the - a input

00:17:37,900 --> 00:17:43,190
we would say like okay that says for

00:17:39,550 --> 00:17:44,600
internal Google services and then

00:17:43,190 --> 00:17:46,940
tie them to a particular through a

00:17:44,600 --> 00:17:48,500
network label to a particular profile so

00:17:46,940 --> 00:17:49,850
you'd have to have a be running as a

00:17:48,500 --> 00:17:55,100
particular profile to access certain

00:17:49,850 --> 00:17:56,960
aspects of the network roulette is

00:17:55,100 --> 00:17:59,740
actually been probably the most

00:17:56,960 --> 00:18:02,780
interesting part of all of this so

00:17:59,740 --> 00:18:06,110
remember we have like quarter million

00:18:02,780 --> 00:18:08,870
machines and a lot of fun this is the

00:18:06,110 --> 00:18:13,130
first little bit of rollout fun that we

00:18:08,870 --> 00:18:15,800
had so this is a log event that comes

00:18:13,130 --> 00:18:17,030
out of a Parmer it's pretty reasonable

00:18:15,800 --> 00:18:19,100
right you can read this

00:18:17,030 --> 00:18:21,800
SSH was attempting to access the private

00:18:19,100 --> 00:18:24,710
key the operation was open and it failed

00:18:21,800 --> 00:18:27,890
because it's running is untrusted but if

00:18:24,710 --> 00:18:30,890
you remember we were setting this up in

00:18:27,890 --> 00:18:32,900
such a way that it actually is not only

00:18:30,890 --> 00:18:34,940
about the final binary that's running

00:18:32,900 --> 00:18:36,770
it's about the entire process to a the

00:18:34,940 --> 00:18:41,330
entire process tree has to be trusted in

00:18:36,770 --> 00:18:43,130
order for the final one to be but both

00:18:41,330 --> 00:18:46,580
of these operations at the end are

00:18:43,130 --> 00:18:48,740
exactly identical so SSH for both of

00:18:46,580 --> 00:18:50,630
these process trees are accessing it but

00:18:48,740 --> 00:18:54,020
for the top one it's totally fine for

00:18:50,630 --> 00:18:55,550
the bottom one that was that's when the

00:18:54,020 --> 00:18:58,490
violation was generated and we would get

00:18:55,550 --> 00:19:00,350
that art event so the next question is

00:18:58,490 --> 00:19:02,540
like how did this become untrusted and

00:19:00,350 --> 00:19:06,530
this context doesn't give us enough

00:19:02,540 --> 00:19:08,000
information so there's no process tree

00:19:06,530 --> 00:19:13,100
information no extended attribute

00:19:08,000 --> 00:19:14,360
information and Comm sucks so for anyone

00:19:13,100 --> 00:19:14,780
who's tried to do this you learn very

00:19:14,360 --> 00:19:17,540
quickly

00:19:14,780 --> 00:19:19,010
komm is the thread name which random

00:19:17,540 --> 00:19:21,170
binaries can set to whatever we had a

00:19:19,010 --> 00:19:22,790
fun case where a single shared library

00:19:21,170 --> 00:19:24,500
was being loaded into everything setting

00:19:22,790 --> 00:19:25,970
the com name and then like all of our

00:19:24,500 --> 00:19:29,930
violations were for this one shared

00:19:25,970 --> 00:19:31,970
library or it's a truncated path so I

00:19:29,930 --> 00:19:34,130
think it's limited to like 16 characters

00:19:31,970 --> 00:19:36,650
if you have a long path you're really

00:19:34,130 --> 00:19:38,090
out of luck and it doesn't work with

00:19:36,650 --> 00:19:39,680
your banks if you execute a script or

00:19:38,090 --> 00:19:41,720
execute in the interpreter you get the

00:19:39,680 --> 00:19:46,000
same con value this is the same with

00:19:41,720 --> 00:19:46,000
proc two which is also a pin

00:19:46,639 --> 00:19:52,759
what we had to do is actually build a

00:19:49,100 --> 00:19:54,559
really fun logs pipeline so basically in

00:19:52,759 --> 00:19:56,960
order to get useful information out of

00:19:54,559 --> 00:19:59,090
our fleet about why the strategy was

00:19:56,960 --> 00:20:01,370
working or wasn't working we had to

00:19:59,090 --> 00:20:04,100
collect process information from all of

00:20:01,370 --> 00:20:08,389
the hosts we already do this because of

00:20:04,100 --> 00:20:10,159
you know sort of signals reasons anyway

00:20:08,389 --> 00:20:11,779
so it was convenient for us if you're

00:20:10,159 --> 00:20:14,080
doing this it might not be convenient to

00:20:11,779 --> 00:20:16,909
log every process execution to Oddity

00:20:14,080 --> 00:20:18,470
and then we had to go ahead and write

00:20:16,909 --> 00:20:19,759
some programs to with them to recreate

00:20:18,470 --> 00:20:22,190
the process tree on the back end and

00:20:19,759 --> 00:20:23,779
then figure out what the process tree

00:20:22,190 --> 00:20:27,529
looked like and why we were hitting a

00:20:23,779 --> 00:20:29,899
particular failure for a portion of a

00:20:27,529 --> 00:20:31,370
quarter-million machines this is where

00:20:29,899 --> 00:20:33,379
it's really nice to be Google because we

00:20:31,370 --> 00:20:37,879
can do this and we have all the have all

00:20:33,379 --> 00:20:40,129
the tooling but I have burned through so

00:20:37,879 --> 00:20:42,200
many so much CPU and so much memory just

00:20:40,129 --> 00:20:44,299
trying to get reasonable information

00:20:42,200 --> 00:20:46,759
sort of out of our fleet because we

00:20:44,299 --> 00:20:49,820
depend on this process tree but we did

00:20:46,759 --> 00:20:52,429
end up getting results whatever the

00:20:49,820 --> 00:20:55,580
results process trees are really messy

00:20:52,429 --> 00:20:57,259
the difference between saying that I

00:20:55,580 --> 00:20:59,899
care about every process in the process

00:20:57,259 --> 00:21:02,659
tree and caring just about the final

00:20:59,899 --> 00:21:05,720
executing binary turned out to be an

00:21:02,659 --> 00:21:09,740
order of magnitude difference in noise

00:21:05,720 --> 00:21:12,200
and random stuff that we caught it turns

00:21:09,740 --> 00:21:15,590
out users like building stuff and

00:21:12,200 --> 00:21:18,620
running it we had scenarios where people

00:21:15,590 --> 00:21:21,139
were building IDs or building like T MUX

00:21:18,620 --> 00:21:25,009
locally and suddenly everything was

00:21:21,139 --> 00:21:26,929
becoming untrusted and shockingly you

00:21:25,009 --> 00:21:28,129
might imagine that some people are

00:21:26,929 --> 00:21:30,679
running binaries that didn't come from

00:21:28,129 --> 00:21:33,799
our central repo everything is a package

00:21:30,679 --> 00:21:36,320
manager these days you don't need sudo

00:21:33,799 --> 00:21:38,840
to install new packages either so people

00:21:36,320 --> 00:21:39,500
you know go get things they use get

00:21:38,840 --> 00:21:43,750
clone

00:21:39,500 --> 00:21:43,750
they run docker docker

00:21:45,039 --> 00:21:53,389
so the result is that this is messy

00:21:49,700 --> 00:21:57,080
this is extremely messy and in terms of

00:21:53,389 --> 00:21:59,029
where from here I think that we will

00:21:57,080 --> 00:22:00,919
continue to leverage app armor in some

00:21:59,029 --> 00:22:03,499
serious way because we need access

00:22:00,919 --> 00:22:06,409
control whether or not we will continue

00:22:03,499 --> 00:22:08,600
to use this sort of process tree type

00:22:06,409 --> 00:22:11,869
strategy will sort of determine on our

00:22:08,600 --> 00:22:13,820
ability to go through and say can we fix

00:22:11,869 --> 00:22:15,590
this systematically or is there just

00:22:13,820 --> 00:22:18,429
going to be way too much noise that we

00:22:15,590 --> 00:22:20,749
turn this on in an enforcing capacity so

00:22:18,429 --> 00:22:22,129
it's kind of interesting to see maybe

00:22:20,749 --> 00:22:24,950
I'll come back next year and tell you

00:22:22,129 --> 00:22:26,869
everything was fixed but it's been an

00:22:24,950 --> 00:22:29,389
interesting experience experiment and

00:22:26,869 --> 00:22:31,779
now if you have any questions I'd love

00:22:29,389 --> 00:22:31,779
to answer them

00:22:38,000 --> 00:22:46,500
thanks James I'm curious about the app

00:22:42,600 --> 00:22:48,660
Armour sort of approach because you're

00:22:46,500 --> 00:22:51,330
you're trying to build a security domain

00:22:48,660 --> 00:22:53,340
transition system using a model that is

00:22:51,330 --> 00:22:55,440
not a security domain transition system

00:22:53,340 --> 00:22:57,360
when a security domain transition system

00:22:55,440 --> 00:23:00,780
exists already in the kernel and is

00:22:57,360 --> 00:23:02,370
pretty well established and used so one

00:23:00,780 --> 00:23:05,120
of the really nice benefits of our

00:23:02,370 --> 00:23:08,550
parameters that we get basically all of

00:23:05,120 --> 00:23:10,230
Debian support for existing stuff so as

00:23:08,550 --> 00:23:12,030
we turn on a farmer we actually get

00:23:10,230 --> 00:23:13,470
security benefits just from the fact

00:23:12,030 --> 00:23:15,330
that we are sort of a derivative of

00:23:13,470 --> 00:23:17,250
Debian this was the main motivator

00:23:15,330 --> 00:23:19,140
around support ability of any sort of

00:23:17,250 --> 00:23:20,550
Linux security module that we're using

00:23:19,140 --> 00:23:23,700
because it's like that's such a big

00:23:20,550 --> 00:23:30,360
scale and Matthew Garrett it looks like

00:23:23,700 --> 00:23:32,850
you're itching to have a comment too so

00:23:30,360 --> 00:23:35,490
one of the problems with doing this with

00:23:32,850 --> 00:23:38,040
an SEO is based approach is that right

00:23:35,490 --> 00:23:40,350
now we do the package signatures

00:23:38,040 --> 00:23:44,510
includes the EVM signature on the build

00:23:40,350 --> 00:23:47,610
system and as a result we can't apply

00:23:44,510 --> 00:23:49,530
labeling on the client so if we were

00:23:47,610 --> 00:23:51,090
using selinux we would need the build

00:23:49,530 --> 00:23:52,950
system to be aware of the policy and

00:23:51,090 --> 00:23:54,450
then any modifications of the policy

00:23:52,950 --> 00:23:56,310
would mean we'd need to real able the

00:23:54,450 --> 00:23:58,860
files in the build system a tree signed

00:23:56,310 --> 00:24:00,660
those and right now that would mean

00:23:58,860 --> 00:24:01,710
taking every existing binary package and

00:24:00,660 --> 00:24:03,330
having a mechanism for pushing it

00:24:01,710 --> 00:24:05,100
through there again every time we have a

00:24:03,330 --> 00:24:06,720
policy updates that involves even one

00:24:05,100 --> 00:24:10,230
file on the system requiring a different

00:24:06,720 --> 00:24:11,550
label so otherwise we can't have the EVM

00:24:10,230 --> 00:24:13,080
protection and we need the EVM

00:24:11,550 --> 00:24:15,620
perception in order to protect against

00:24:13,080 --> 00:24:15,620
offline attacks

00:24:18,380 --> 00:24:24,270
sure right so we use only Neeta we would

00:24:21,330 --> 00:24:28,620
only need to do this for each package

00:24:24,270 --> 00:24:30,570
but then we do need it complete it

00:24:28,620 --> 00:24:32,220
brings something that has effects for

00:24:30,570 --> 00:24:34,020
the local policy into the build system

00:24:32,220 --> 00:24:36,360
and that's a conflation that doesn't

00:24:34,020 --> 00:24:38,460
work particularly well for how we build

00:24:36,360 --> 00:24:40,080
stuff at the moment so that was one of

00:24:38,460 --> 00:24:42,840
the motivations for just having the

00:24:40,080 --> 00:24:45,990
entire policy be client site based and

00:24:42,840 --> 00:24:49,140
ultimately to like I think that the

00:24:45,990 --> 00:24:50,730
difference for us at least is like the

00:24:49,140 --> 00:24:53,160
issues we're hitting is not necessary

00:24:50,730 --> 00:24:57,450
with a partner it's just what our users

00:24:53,160 --> 00:24:58,919
expect - and I think the the main sort

00:24:57,450 --> 00:25:00,900
of risk for this is that our

00:24:58,919 --> 00:25:02,460
expectations about what users should be

00:25:00,900 --> 00:25:04,980
doing and what they are and they're used

00:25:02,460 --> 00:25:07,860
to is dramatically off and that would be

00:25:04,980 --> 00:25:10,440
true regardless of whatever sort of

00:25:07,860 --> 00:25:12,990
Linux security model we were good we did

00:25:10,440 --> 00:25:15,570
go with so one thought is have you

00:25:12,990 --> 00:25:16,919
thought about using like upvote type

00:25:15,570 --> 00:25:19,950
thing to all the other developers so

00:25:16,919 --> 00:25:21,600
that it gives a prompting you said you

00:25:19,950 --> 00:25:23,400
then have a lower limb between trusted

00:25:21,600 --> 00:25:25,740
and not just likes a developer okay this

00:25:23,400 --> 00:25:27,450
because people developers tend to want

00:25:25,740 --> 00:25:28,320
to say yeah I am in control of my system

00:25:27,450 --> 00:25:30,780
yeah

00:25:28,320 --> 00:25:34,440
I am sure I could get promo if I roll

00:25:30,780 --> 00:25:36,720
that up vote to Linux whether or not

00:25:34,440 --> 00:25:41,100
that would cause too many people to quit

00:25:36,720 --> 00:25:44,660
is a question it's you have like a

00:25:41,100 --> 00:25:47,790
paperclip yeah yeah I mean I think like

00:25:44,660 --> 00:25:49,470
you know sort of our thought around

00:25:47,790 --> 00:25:50,850
users who wouldn't have to run a lot of

00:25:49,470 --> 00:25:52,410
binaries and therefore wouldn't be

00:25:50,850 --> 00:25:55,470
interacting with upvote very much is

00:25:52,410 --> 00:25:58,290
often like please just go use Chrome OS

00:25:55,470 --> 00:25:59,760
or go use Windows because those are

00:25:58,290 --> 00:26:01,830
environments that are much more locked

00:25:59,760 --> 00:26:05,070
down than sort of the development

00:26:01,830 --> 00:26:06,720
environment so there's a lot of things

00:26:05,070 --> 00:26:09,540
we're thinking about and a lot of

00:26:06,720 --> 00:26:13,410
potential solutions but that's one that

00:26:09,540 --> 00:26:14,910
has been hard to sell it's probably not

00:26:13,410 --> 00:26:18,120
a good solution for developers who build

00:26:14,910 --> 00:26:19,890
their own coverage yeah except for them

00:26:18,120 --> 00:26:24,630
to acknowledge somehow that they built

00:26:19,890 --> 00:26:25,669
it I found them this way I mean but you

00:26:24,630 --> 00:26:28,339
could

00:26:25,669 --> 00:26:30,289
we've we've thought of stuff like maybe

00:26:28,339 --> 00:26:31,820
allowing a security key to store

00:26:30,289 --> 00:26:34,249
something that could sign it so you'd

00:26:31,820 --> 00:26:37,820
like to have a touch that might be

00:26:34,249 --> 00:26:40,609
doable but then you know if you have a

00:26:37,820 --> 00:26:42,769
large chain of executables touching that

00:26:40,609 --> 00:26:44,690
like 500 times when people already have

00:26:42,769 --> 00:26:47,509
to touch a security key quite a bit at

00:26:44,690 --> 00:26:58,009
Google is again maybe comes down to

00:26:47,509 --> 00:27:00,469
palpable palatability does this work for

00:26:58,009 --> 00:27:02,089
like LinkedIn libraries so I dynamically

00:27:00,469 --> 00:27:05,379
linked in libraries or the binary is

00:27:02,089 --> 00:27:08,149
just trusted so I believe I'm a

00:27:05,379 --> 00:27:11,779
appraisal is transitive like as you

00:27:08,149 --> 00:27:15,859
memory map things and that will be those

00:27:11,779 --> 00:27:18,049
will also go through appraisal it is

00:27:15,859 --> 00:27:21,049
harder for things like a Python multiple

00:27:18,049 --> 00:27:22,729
right so if it's just referencing and

00:27:21,049 --> 00:27:25,299
reading stuff from disk and then that is

00:27:22,729 --> 00:27:25,299
not transitive

00:27:31,480 --> 00:27:37,009
does the system for trusting things

00:27:34,360 --> 00:27:39,200
particularly with interpreters where you

00:27:37,009 --> 00:27:41,720
might have like a signed you know Google

00:27:39,200 --> 00:27:45,980
Python script that is trusted mean that

00:27:41,720 --> 00:27:48,019
sort of they are all required to

00:27:45,980 --> 00:27:50,630
basically enforce things like I don't

00:27:48,019 --> 00:27:52,250
load sort of remote code execution the

00:27:50,630 --> 00:27:54,470
animal or pickles or like anything like

00:27:52,250 --> 00:27:57,590
that would totally sort of blow up the

00:27:54,470 --> 00:28:00,200
systems all right you've found a hole in

00:27:57,590 --> 00:28:05,269
my plan no yeah I mean it that's the

00:28:00,200 --> 00:28:06,919
clear problem yes

00:28:05,269 --> 00:28:08,389
there's no it doesn't really exist good

00:28:06,919 --> 00:28:11,210
answers run this particularly when we're

00:28:08,389 --> 00:28:13,549
still supporting sort of old Debian

00:28:11,210 --> 00:28:16,399
packages - that might not depend on the

00:28:13,549 --> 00:28:20,559
latest Python with the latest security

00:28:16,399 --> 00:28:22,399
hooks as we saw a few days ago so yeah

00:28:20,559 --> 00:28:26,919
we're just gonna put everything in

00:28:22,399 --> 00:28:26,919
containers and it'll be much better

00:28:38,580 --> 00:28:46,360
did you guys consider working with the

00:28:41,590 --> 00:28:50,049
destroy vendors to sign the binaries

00:28:46,360 --> 00:28:51,760
inside the packages we haven't we

00:28:50,049 --> 00:28:58,000
haven't engaged with like Debian to do

00:28:51,760 --> 00:28:59,770
that we build everything ourselves so we

00:28:58,000 --> 00:29:03,970
would we are in a position to sign it

00:28:59,770 --> 00:29:05,740
anyway so we still receive and validate

00:29:03,970 --> 00:29:08,289
all the binaries all the signatures that

00:29:05,740 --> 00:29:09,909
come from Debian but ultimately we are

00:29:08,289 --> 00:29:12,039
in control of the way that these devs

00:29:09,909 --> 00:29:13,900
are built and signed ourselves so we can

00:29:12,039 --> 00:29:17,080
just inject signatures when we want to I

00:29:13,900 --> 00:29:20,919
think so you know I am assigned the

00:29:17,080 --> 00:29:24,220
binaries and you repackage the original

00:29:20,919 --> 00:29:27,159
package yeah so we actually picked this

00:29:24,220 --> 00:29:28,960
apart create this M Tree file and then

00:29:27,159 --> 00:29:30,570
in our build system and then sign

00:29:28,960 --> 00:29:44,230
everything ourselves

00:29:30,570 --> 00:29:47,890
okay so yeah ideal goal would be for

00:29:44,230 --> 00:29:49,390
distributions to do this and then we as

00:29:47,890 --> 00:29:51,549
far as possible we want all of this to

00:29:49,390 --> 00:29:53,559
be ecosystem available rather than just

00:29:51,549 --> 00:29:57,370
being something linked in with us at the

00:29:53,559 --> 00:29:59,590
moment as Eric mentioned we're driving

00:29:57,370 --> 00:30:01,809
start from debian one of the interesting

00:29:59,590 --> 00:30:04,570
features of debian is that when a

00:30:01,809 --> 00:30:06,039
package is uploaded you don't just

00:30:04,570 --> 00:30:07,990
upload the source the maintainer has to

00:30:06,039 --> 00:30:10,419
upload a binary built for at least one

00:30:07,990 --> 00:30:14,409
architecture and then that package is

00:30:10,419 --> 00:30:17,230
incorporated directly distribution so

00:30:14,409 --> 00:30:18,340
right now with Debian infrastructure you

00:30:17,230 --> 00:30:21,820
would need to re architect to help

00:30:18,340 --> 00:30:22,990
package uploads are handled or every

00:30:21,820 --> 00:30:24,570
Debian developer with these be able to

00:30:22,990 --> 00:30:27,370
sign every Debian package which would

00:30:24,570 --> 00:30:29,730
probably not be the most desirable

00:30:27,370 --> 00:30:29,730
outcome

00:30:37,380 --> 00:30:42,130
reason for this is if you don't sign

00:30:40,600 --> 00:30:43,960
software at the origin then you lose the

00:30:42,130 --> 00:30:46,000
sense of the origin or the identity

00:30:43,960 --> 00:30:56,170
actually so if you resign it yourself so

00:30:46,000 --> 00:31:00,010
that's a primary motive we've been

00:30:56,170 --> 00:31:02,440
looking at using sweet AG extensions to

00:31:00,010 --> 00:31:04,030
Swit tags to provide signatures you

00:31:02,440 --> 00:31:05,950
didn't mention that is there any notion

00:31:04,030 --> 00:31:08,890
I mentioned in my presentation we're

00:31:05,950 --> 00:31:11,740
doing that for firmware and that's a

00:31:08,890 --> 00:31:16,630
focus but the next step would be working

00:31:11,740 --> 00:31:19,570
with David Sanford and others who extend

00:31:16,630 --> 00:31:25,690
Swift acts to include I'm a signatures

00:31:19,570 --> 00:31:28,270
and measurement about that so I'm not

00:31:25,690 --> 00:31:30,280
sure what that gets you and our setup I

00:31:28,270 --> 00:31:32,050
mean obviously it would be incredibly

00:31:30,280 --> 00:31:34,750
beneficial for more people to generate

00:31:32,050 --> 00:31:41,830
I'm an EVM or I'm a signatures for their

00:31:34,750 --> 00:31:43,270
binaries but that yeah yeah my job so

00:31:41,830 --> 00:31:45,490
far has been focusing on getting this

00:31:43,270 --> 00:31:51,010
all to like function in a reasonable

00:31:45,490 --> 00:31:54,400
capacity but yeah yeah I I mean just in

00:31:51,010 --> 00:31:57,730
terms of like binary provenance that is

00:31:54,400 --> 00:31:58,900
a huge problem that is way beyond the

00:31:57,730 --> 00:32:00,960
scope of what we're trying to address

00:31:58,900 --> 00:32:02,950
here but it's definitely something that

00:32:00,960 --> 00:32:05,370
smarter people than I are thinking about

00:32:02,950 --> 00:32:05,370
at Google

00:32:11,730 --> 00:32:16,690
yeah so the Debbie inspect that you

00:32:14,260 --> 00:32:18,220
talked about for a package Ivan I on

00:32:16,690 --> 00:32:19,600
that every so often I've noticed that

00:32:18,220 --> 00:32:20,950
it's kind of become still has been

00:32:19,600 --> 00:32:23,470
updated in about two years

00:32:20,950 --> 00:32:24,820
but I believe that I heard that D

00:32:23,470 --> 00:32:27,640
package you guys have a merge request

00:32:24,820 --> 00:32:31,230
against D package to add file signatures

00:32:27,640 --> 00:32:31,230
is that right Mathew is that you yeah

00:32:34,230 --> 00:32:39,370
all right yeah I just didn't see it in

00:32:37,210 --> 00:32:48,760
the in the specs so I want to take a

00:32:39,370 --> 00:32:51,700
look at it cool thanks for coming to the

00:32:48,760 --> 00:32:58,089
last talk of the day thanks sorry

00:32:51,700 --> 00:32:58,089

YouTube URL: https://www.youtube.com/watch?v=Qqp_pb8qKFY


