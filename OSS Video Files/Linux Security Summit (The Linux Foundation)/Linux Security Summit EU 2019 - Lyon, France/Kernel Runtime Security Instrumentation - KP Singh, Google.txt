Title: Kernel Runtime Security Instrumentation - KP Singh, Google
Publication date: 2019-11-04
Playlist: Linux Security Summit EU 2019 - Lyon, France
Description: 
	Kernel Runtime Security Instrumentation - KP Singh, Google
Forum 1

Speakers: KP Singh
Existing Linux Security Modules can only be extended by modifying and rebuilding the kernel, making it difficult to react to new threats. Kernel Runtime Security Instrumentation (KRSI) [1] aims to provide an extensible Linux Security Module (LSM) by allowing userspace programs and system owners to attach eBPF (extended Berkeley Packet Filter) programs to security hooks. This makes the LSM framework extensible without needing to rebuild/re-write and enables a new class of security and auditing software.

The talk discusses the need for such an LSM (with representative use cases) and compares it to some existing alternatives, such as Landlock, a separate custom LSM, kprobes+eBPF etc. The second half of the talk outlines the proposed design and interfaces, and includes a live demo
Captions: 
	                              I am KP Singh I work in Google Zurich on                               security to be a part of an organization                               called detection and response so and                               this is a project to improve the stuff                               we doing that in the upstream community                               so we're going to talk about why we are                               doing why are you doing this we go into                               like how does all of this work we're                               going to talk a few detection that we                                build using that what are the                                alternatives that are there in the                                community that exist and we're going to                                do a little demo because I'm aware of                                Murphy's Law this is going to be a                                screencast in order live demo so sorry                                about that so motivation right why why                                do we want to do this there are so there                                are two things that we want to that                                there like there is signals these are                                not unique signals these are like things                                that correspond to malicious activity                                and you can get this data from the                                kernel using like things like audit some                                some I executed a process I open the                                socket these are signals or data that                                you get from the kernel you can use                                performance for that they could a subset                                of the signals could correlate to                                malicious activity but they don't mean                                that this is something bad is happening                                on the system and then you have                                mitigation this is your this is the                                classic LSM space where you notice                                something bad happening and you deny the                                action from happening and what this is                                you would you were typically you slay or                                selinux apparmor LSM so you could use a                                comp you could say that I want to reduce                                my attack surface I don't want these                                system calls to be executed on the                                system so security is is essentially                                signals plus mitigation that's the                                premise I'm going to build on currently                                these two are disjoint in the Linux                                kernel so if I want to build a new                                signal I need to change audit and that's                                hard like you have to update user space                                components you let's say I want to                                change audit to start logging                                environment variables and this means                                that this this is this is a disjoint                                system so you update order date or you                                add something to perf right and if I                                want to if I realize something paired is                                happening based on that signal I need to                                update the Ellison's as well so which is                                more more work that you have to do and                                by that time the adversary is already                                moved for                                right so you you want you were trying to                                order it you are trying to order it LD                                preload environment variables now you've                                updated your LS m you need to update the                                LS m to like deny a particular                                fingerprint of an attack so that's                                that's how signals and mitigation we                                need a joint story for signals and                                medication in the linux kernel is the                                motivation behind this so again what are                                what are some examples of signals like a                                process that executes and deletes is own                                executable right it shouldn't happen                                could happen but it doesn't mean you                                need to like always denied you may want                                to deny it a kernel module that loads                                and then hides itself in /proc modules                                why would it do that may be suspicious                                environment variables if you see LD                                preload being set twice on the                                environment vector why is that happening                                you can maybe it's an honest mistake                                maybe it is something somebody trying to                                fool the lips into doing something so                                these are all signals of malicious                                activity examples of medications like                                you somebody mentioned that you don't                                want to load any kernel modules after                                the boot system boots great you may want                                to whitelist certain modules that that                                allowed to be like loaded into the                                kernel based on known hashes you want to                                prevent known vulnerable binaries from                                running this is it's it's the reason why                                why you want to do such such things is                                that when you build a binary you want to                                release in qualified and typically that                                takes more time then it would take you                                to update the policy that will prevent                                that binary from running in the system                                 and for like for a large deployment of                                 binaries this is this is actually very                                 important to stop unknown vulnerable                                 binary or version non vulnerable version                                 from running so that's there you can                                 also change these signals that I talked                                 about not not only those signals but any                                 signals that you think are relevant in                                 to a configurable Mac policy or an audit                                 policy but at the same place in the can                                 so that's essentially how signals in                                 mitigation would go hand-in-hand and                                 that's this is why we want to do kernel                                 runtime security instrumentation so and                                 the way we want to do this is in other                                 productions                                 and our end points it's not just our                                 data centers but workstations and Linux                                 works developer workstations as well so                                 this is a great segue actually but what                                 Steve was talking about in the previous                                 presentation unfortunately I don't have                                 the anonymous mask with me I wish I did                                 but we won't use EPP F and is everyone                                 aware of EB PF I saw your people laugh a                                 little bit when the things Steve talked                                 about it but it's essentially a virtual                                 machine that lives in the kernel you can                                 attach these programs to specific points                                 they are written in a C like syntax it's                                 non URI complete so it can be verified                                 and EBP F is extended vpf it has Maps it                                 has like more stack size more registers                                 you have like more complicated lookups                                 and it has these thing things called                                 helpers which are more complicated logic                                 that lives within the Linux kernel and                                 this is essentially what we won't use to                                 build those detection helpers and use                                 them in the LS m so essentially extend                                 the LS m using a BPF we will go into the                                 details of all of this as we as we walk                                 through the presentation so yes we want                                 to implement the LS m hooks as EBP F                                 programs and we don't want to do that                                 with just the PPF tracing programs you                                 don't you don't want to trace the LS m                                 you want to effectively have a new BPF                                 program type that is geared for the                                 security use case so and and you would                                 use those BPF programs to configure your                                 Mac and audit policies so people ask me                                 that why are you using an LS my you                                 being an LS M and the answers are like                                 the answers are basically what LS M was                                 created for they map not to the API so                                 we early used to trace execs s calls to                                 lock process execution events and                                 execution X access call is the API and                                 not the behavior of that represents                                 process execution so when I have a                                 security analyst come to me and tell me                                 that we want to lock this when a process                                 gets executed that's what they tell me                                 they don't tell me that I want to log                                 something on an exact V event right and                                 this is this is very key ver LSM fits                                 and it doesn't it doesn't hook at the                                 API level but it hooks at the behavior                                 level                                 so that's the one thing it is very good                                 at it has also good mapping to current                                 data structures so when you access a                                 particular kernel data structure that's                                 where the RSM hook comes into play and                                 it gives you access to these things                                 called security blobs which the LSM can                                 maintain some sort of bookkeeping or                                 state and these this helps you build                                 more complicated detections without                                 having like complicated user space code                                 to deal with the same thing you also                                 benefit the callosum is a proven                                 mechanism to do security in the kernels                                 you benefit off from the years of                                 research that has gone into this space                                 the and verification of the LSM system                                 so you you it's it's do you want to have                                 that extensible with something very                                 flexible there's EVP F but you want to                                 want it to be an LS M so that it's                                 formally proven mechanism as well not                                 just a random tracing thing you also                                 give back to the LS m in the sense right                                 you add flexibility and extensibility                                 right now there are very specific LS                                 Em's i saw there is an LS m for memory                                 protection that is coming up that isara                                 and you essentially can extend the LS m                                 framework and not create these tiny LS m                                 and you can make them flexible this is                                 actually a very good point as well that                                 you get the feedback the LS m come here                                 we're all we're all engineers we write                                 great word and this is great there are                                 the security analysts there intelligence                                 teams who work on who get like we want                                 to really write these logics and right                                 medication logic and we want to connect                                 the LS m community with these people so                                 if you have these people writing                                 detections and make it easier for them                                 to write detections or it policies and                                 mac policies you get a feedback loop                                 that goes from the from the security                                 analyst is how i try to refer to them                                 and to the RSM about TLS and developers                                 the maintainer or the Sakhi Linux                                 security community in Sirte sense                                 so here it is here is what it looks like                                 you have the each LS m hook is                                 represented by a file in security FS                                 security FS is a fancy name for says                                 kernel security you have your p PF                                 program which is this object file that                                 you compile that is the runt this is the                                 bytecode i talked about and this is                                 you're essentially saying to the LS m                                 please run this piece of logic when a                                 process is executed as a part of the LS                                 m hook you can't do you have you open                                 the file you you have a program after                                 using a b PF syscall and you attach                                 these two together and you can attach                                 multiple programs to each LS m hook and                                 it works along with the other LS m so                                 you can have se Linux apparmor blah blah                                 and then care as I would run all the bps                                 programs there so that's that's simple                                 that's like a easy high-level overview                                 of what it looks like so what happens                                 when you when you load that program it                                 can do two things it can return an error                                 like hey you not allowed to do this                                 stuff or you're like mmm                                 this sounds fishy I'm going to lock that                                 so you can you can do audit logs and the                                 audit logging happens currently                                 available mechanism in BPF is using the                                 perf events buffered so what you                                 essentially do is you you get data from                                 the kernel using those helpers I talked                                 about you assemble logging format and                                 then you dump it into the performance                                 buffer using this helper called PPF per                                 vent output so that's how you do ordered                                 policies and back at the same place so                                 again what's there in the program you                                 have helpers right the one that we                                 talked about is perfect output but you                                 can also have helpers that correspond to                                 keep detections in the kernel and                                 there's this new thing that I think                                 Steve alluded to in his talk as well is                                 the btf parts are like that they're                                 trying to make trace points more generic                                 and we won't use that part where there                                 is type information available so                                 essentially I can say that I want to                                 access this field off that entry and I                                 and I don't want the program to break                                 when the offsets change in the kernel so                                 we won't use that part of what the BPF                                 maintained as have developed in our                                 thing so that the program is more                                 flexible I don't want to write a small                                 helper each time I need to access field                                 of a struct and this is only read                                 accessed by the way it's not a right                                 access so if you want to do a trivial                                 scalar read like say what is the start                                 time of this task you could go about it                                 with writing like a helper and API                                 function add functionality in the kernel                                 or you could just treat it using this                                 but then you risk breaking if you don't                                 have the correct off circulating from                                 the structure you risk breaking the                                 usual risk rating the BPA program so                                 essentially behave like the kernel                                 module and this is solved with PDF what                                 is PDF so these people who developed PDF                                 they took like the hundreds of megabytes                                 of dwarf information and they distilled                                 into this compact file that gets                                 exported into into like sis kernel BD f                                 BM Linux so it's like hundred and twenty                                 five Meg's translates to about                                     megabytes and it like describes all the                                 various structures that are there in the                                 kernel or does the offsets or different                                 fields and how does it like relate                                 various source codes there is a Libby PF                                 library or a user space component that                                 looks at your BPF program that says hey                                 you are accessing the d inode part of                                 the inode and i know that this is there                                 in the kernel so let me update your                                 program to that product so before you                                 run the program and this makes your BPF                                 program Cori is what the people who have                                 a great call but it's essentially                                 compiled once and run everywhere so it's                                 it's where we want to have flexibility                                 but backward compatibility go hand in                                 hand                                 this comes as something new before I                                 give the last talk because this was not                                 there when we absolutely disallowed any                                 structure reads in the key recite                                 program and it it makes it more flexible                                 so it has actually enabled us last time                                 I gave the talk we just had one                                 execution hook the process execution                                 part we can now you can attach EBP F                                 programs to any LS m hook so I don't                                 have a                                                              because there are not                                                   but I just quickly added what we had                                 there and we have like                                                you can you can attach EBP of programs                                 to which is not bad like I think I think                                 it's a good balance between tracing and                                 security and again I'm making this very                                 clear this does not use trace points or                                 fancy trampolines or all of that stuff                                 we want this to be a proper LSM it's                                 just using EBP F as a mechanism to                                 extend the LSM framework but these are                                 functions that are there in the car                                 these are like there is a hook called                                 Karis IV PRM check security which takes                                 the argument                                 it runs the DPF programs and it is                                 registered as a proper Alice M hook so                                 that you benefit from all the old things                                 that are bought the Ellison framework we                                 talked about okay we're going to talk                                 about some detections it's going to show                                 some code on slides which is fine so the                                 story here is security analyst walks to                                 me and he says and they say that we want                                 to deny any process that tries to unlink                                 its own executable like okay we're                                 engineers we can find that out what do                                 we what information do we need to have                                 that sort of detection build we need on                                 the inode object we need to see what are                                 the processes executing that and on the                                 process object the task struct we need                                 to see what is the executable for that                                 particular process and how do you track                                 that you use security blobs and that's                                 what it looks like all the stuff we've                                 been talking about is essentially this                                 you say that I am going to hook at the                                 inode unlink LSM hook in the kernel care                                 as I did some bunch of work internally                                 and has provided you an API for that                                 detection which gives you three forms of                                 responses it says that you are a process                                 that is unlinking itself are linking its                                 own executable you're a process that is                                 unlinking your parents executable or you                                 are a process that is unlinking any                                 other running executable on the system                                 and based on how you perceive that as as                                 a and you can link that with other                                 signals and you can deny that action                                 from happening so in this case like I am                                 saying only if you unlink your own                                 executable are you not supposed to do                                 that                                 otherwise it's sure like itself it's                                 probably an event that somebody's not                                 aware of on the system and they're doing                                 that so it kind of adds that flexibility                                 angle to the add Mac you may just not                                 you may just even want this to happen                                 and you like okay you're doing this I'm                                 going to log it I'm going to make a note                                 of that in my in my long list of audit                                 events and if you do something bad after                                 this I'm going to deny everything you do                                 so that's how that's how this works                                 again the other example that we alluded                                 to is reality preload being set twice                                 you hook at the beep erm check security                                 which is essentially the Ellison hook                                 for process execution you say like give                                 me the value of LD preload and this                                 helper is like                                 mark this looks at all all the movement                                 variables it gives you the value back                                 even if the attacker here tries to like                                 overflow the environment variable buffer                                 like it's it's like giving you can own                                 these command variables can be really                                 large they can be                                                       of the maximum stack size which is                                 roughly translated into                                              could just set like a big environment                                 variable so it also counts how many                                 times this is set and and the detection                                 is based on like you setting LD preload                                 twice and this is where you want to you                                 can get the value you can get notified                                 of an overflow here and then you can say                                 what you do when these two things happen                                 or when one of these two things happen                                 so again use that as a building block to                                 assemble your Mac an audit policy you                                 want to this is again the file open LS m                                 hook there is Kara says again providing                                 you a helper for is this across                                 operation on the on a professed file                                 there is there is some special hooks in                                 the LS m that allow you to do and track                                 such things so whenever a process starts                                 you've got an inode object back and you                                 can say that this is this is a file that                                 this process created in progress and                                 when someone tries to read a right to                                 proc print them or like open proc reg                                 mem in this case you can you can lock                                 this it's probably okay like you may be                                 writing that but we want you in this                                 case we want to lock that there this                                 happens a lot for our different with a                                 different process tries to write to a                                 proctor in ma'am plate it is very rare                                 that our process tries to write it to                                 its own there are some cases where a                                 distantly required that's where the                                 auditing comes in handy okay so we we                                 have explained some detections there we                                 the plan is to build more detections and                                 use the flexibility of the btf stuff so                                 that at the very least by exposing all                                 the hooks you can create an LS m if you                                 need to access security blobs this is                                 again something that Kara's I will have                                 to build internally you don't expose                                 that but you can create these it already                                 exposes the LS m ecosystem to some                                 something that you can build using EBP F                                 this is a question that I was asked last                                 time I talked about                                 there was a new pad set ever send a                                 couple of days back I didn't get a                                 chance to look at it as I was traveling                                 but what we found is that line lock is                                 primarily targeting discretionary access                                 control and it needs unprivileged e BPF                                 Carris is system-wide Mac so it that we                                 don't rely on unprivileged EBP fu or you                                 have to you have all the capabilities of                                 route so we don't want and privilege to                                 be bf                                                                attachment semantics failed processes                                 are like they're attached to essentially                                 tasks credentials or like sec comm data                                 structures on the on the tasks it's                                 theoretically possible to do system-wide                                 mark using these attachment semantics                                 but it gets complicated because that's                                 not what it was designed to do here                                 right you can you'll probably need to                                 change in it you have no trivial way to                                 replace the attached vpf programs kernel                                 threads like i we we noticed that ksi                                 hooks get executed for user mode helpers                                 every now and then you will have a user                                 mode helper come in execute a binary and                                 this won't be locked by land lock if I                                 if I if I understand that correctly so                                 there are there are some things I think                                 line lock has its place as if unproduced                                 EBP F is a thing for for unreleased                                 unboxing but it's not the right design                                 for like system-wide Mac here why not                                 audit well like the obvious answer is                                 that mandatory access control needs to                                 have like be handled separately and we                                 want to do that together in one place                                 there is considerable I with all due                                 respect to all right there is like it's                                 it does give you a lot of information                                 but there is performance overhead so                                 like it trick it when you even when you                                 enable configure it on the on the on the                                 kernel like it causes a performance                                 penalty and it also imposes like in in                                 ksi when you get information of the                                 kernel you can choose the data structure                                 in in or the format you want to assemble                                 and write to the performance buffer in                                 this case like you get strings back from                                 the kernel so that is that there are                                 some                                                                     when we've like essentially build                                 detection pipeline on top of audit the I                                 did some preliminary performance                                 comparison with audit we have                                 some grains of salt at the very corner                                 so please take it with a grain of salt                                 I brought I didn't get enough for                                 everyone but I think there are enough                                 grains Karaca is the blue part so the                                 that not the exact numbers by the way                                 the y-axis is like it skipped at                                        not doing any marketing trickery here                                 but the essence is that audit has a very                                 fat distribution so it has like high                                 tail latency it can have bigger impacts                                 in the system and even when you enable                                 or did you get performance penalties                                 there so that that's the that's the kind                                 of an L that's the kind of preliminary                                 analysis that we found for process                                 execution events and we couldn't log                                 environment variables without it because                                 we have to build that friction ality                                 anyways so that's that's how it compares                                 right now this is a question I got asked                                 as well like why don't you just go and                                 trace the LSM Hawks like you have BPF                                 probe type trace it's it can do or like                                 you have trace points just create a                                 trace point and trace all the LSM hooks                                 seems like an interesting proposition                                 but you can't first of all you lose all                                 the formal verification stuff that we                                 read LSM tries to bring you leaving that                                 aside you are you are it's not trivial                                 to override the return value using                                 current BPF tracing programs to signal a                                 Mac decision you have no access to                                 security blobs because you you want to                                 write into security blobs this is not                                 something that you're allowed to do from                                 BPF programs at least we don't want care                                 SI programs to be writing arbitrary data                                 into the kernel and it's not reading LS                                 m if you go through all the security                                 underscore functions in a security dot c                                 the hook these security functions are                                 wrappers around hooks registered by L                                 SMS and they are they do they sometimes                                 I do some processing on the data before                                 I pass it to the actual registered                                 callback and you miss out on that if                                 you're if you're just tracing LS m hooks                                 there so that's one of the concerns we                                 have we run into I'm going to quickly                                 like do a demo I'm gonna pause a bit                                 while we do that so hope this so                                 great this is how you can mess up a                                 screen customer as well anyways so we                                 starting a VM that is running care as                                 high as they'll SM enabled along with                                 the other LS M's and and then I'm                                 listing the hooks to show you that                                 they're all these LS m books available                                 and we will expect to see more because                                 there are places where the Allison hooks                                 like we just not got the feedback I need                                 a hook for that particular point and                                 then what you have is I'm running the                                 this is the user space component that is                                 essentially loading your eb PF program                                 so it's loading like for e BPF programs                                 into into the various hooks so there's                                 one for environment process execution                                 there's one for inode unlink there is                                 one for like the proc FS file op file                                 open and and we oops                                 okay just a second my laptop is I did                                 spill coffee on it so that could be one                                 reason I'm going to go to the webcast                                 here                                 you cannot beat Murphy's Law less is                                 like this is amazing                                 okay                                 so yes so by whenever when I assess you                                 that machine and I go to the other other                                 side of the terminal                                 I see like punch of execution                                 information getting audited there I run                                 this thing called mem which is                                 essentially a program that reads opens                                 prepared lemon tries to write right to                                 that and what you see is an event that                                 says proc bla bla bla was accessed right                                 you also have another one                                 I run another program that's called                                 fault which is basically you cannot set                                 these environment variables on Bosch                                 like twice                                 - Ashley filters them out but you can                                 maliciously in the exact syscall like                                 paestum and variable vector twice and                                 that's what this program does I have                                 excellent values for them but it gives                                 you a warning that is set twice you can                                 actually deny the program from being                                 executed as well and and then there is                                 the famous the executable unlink where                                 this is basically removing our v-                                       like and calling on Lincoln arc v-                                      you get like an unlink event on the on                                 the system so that's essentially believe                                 me it was there it's again detecting one                                 type of unlink event this is unlinking                                 itself you could have other types of                                 events as well that you can detect on so                                 yes this slide has appeared multiple                                 times as a cause of my failure demos but                                 again thank you so much for all the                                 people who have contributed to this                                 project and who will in the future as                                 well it does it is not possible to build                                 these things without all the                                 contributions and thank you for                                 listening to me and if you have                                 questions I'm here to answer them it's                                 almost inevitable when you introduce                                 something that is sophisticated as this                                 mechanism you're going to have an                                 exploit where would you see that                                 happening I mean the answer the answer                                 has been already brought up in there in                                 the in the in the room is EBP F needs to                                 be it's it's the place where you could                                 have potential but that's where it's an                                 opportunity to like work with the                                 Medina's and make it more secure and                                 safe and that's actually something we're                                 looking at the answer is is the room                                 knows                                 yes eb PF could be the place where you                                 could introduce exploits questions                                 it's not let's ring the speaker again                                 thank you
YouTube URL: https://www.youtube.com/watch?v=kl-eeQRpeag


