Title: Address Spaces for Namespaces - Mike Rapoport, IBM
Publication date: 2019-11-11
Playlist: Linux Security Summit EU 2019 - Lyon, France
Description: 
	Address Spaces for Namespaces - Mike Rapoport, IBM
Forum 1

Speakers: Mike Rapoport
Address space isolation is used to protect the kernel and userspace programs from each other for ages.

Assuming that kernel exploits and speculation vulnerabilities are inevitable it's worth to isolate parts of the kernel to minimize damage that these exploits can cause.

One way to create such isolation is to assign an address space to the Linux namespaces, so that tasks running in namespace A have different view of kernel memory mappings than the tasks running in namespace B.

We propose to extend the SL*B allocators with the ability to create "exclusive" caches visible only in one namespace and thus ensure that per-namespace objects are mapped only in the owning namespace address
space.

We'll present the design of the "exclusive" caches and POC implementation targeting network namespaces.
Captions: 
	                              okay so let's continue so our next talk                               is gonna be from IBM my proper part is                               going to be talking about address space                               for namespaces something like that here                               I am working for IBM Research for a                               couple of years now and they our current                               research field is how to make containers                               most secure and since they address                               spaces elation is ultimate of protection                                method since the invention of virtual                                memory we are trying to see if we can                                make use of MMU and the address space is                                relation inside the kernel mappings to                                make the environment in Linux kernel                                more secure and particularly container                                engines and the container users a and                                then one of the assumptions and that                                vulnerabilities are inevitable and there                                always will be some hole somewhere and                                some system calls it doesn't take proper                                care of its edge conditions that this                                can be exploited so if we can try to                                create a restricted address spaces for                                execution of some of the kernel                                functionality then a vulnerability that                                exploits exploit something is a a                                restricted address space which will                                still make an attacker life harder to                                get to other kernel code and that as it                                is not map it in the restricted address                                space so the first example of restricted                                address space in the Linux kernel is pti                                of course it's more restricted for users                                and for caramel but still in the page                                table of user space processes cease to                                continue to contain kernel mappings at                                some point because of some problems                                probably on earth and there is also                                ongoing work in similar direction for                                giving M                                Oracle and developers are working on                                creating a restricted context for                                execution of VM call and VM exit and                                trying to avoid the in mapping sensitive                                data in the context for VM guest mode                                and the AWS proposed to creating areas                                that are mapped only in the context                                context of certain process and a lot                                method in the rest of kernel page tables                                and our group is targeting container                                security where the entire system call                                interface is the attack surface and the                                major is an isolation primitive is a                                linux namespaces so we've been thinking                                how can we use the MMU and the bridge                                table and restricted address spaces in                                order to make namespaces safer and the                                idea we've been working for last couple                                of months weeks is to assign a page                                table for namespace before that we tried                                doing something that we call system                                correlation which was an attempt to run                                a system call execution in very                                restricted address space it was kind of                                continuation of a PTI approach we took                                the PTI page table we added to it to it                                some minimal a mapping say necessary to                                enter system call and then the actual                                system call execution was running                                without any of caramely code or data                                mapped it falls it a lot it was a not so                                fast as Peter said and it kind of worked                                to the extent I could measure and could                                run micro benchmark but after I did it I                                realized that it's not the solutions                                it's going to fly and what we intended                                to do is to use these page faults to                                verify that ax                                - colonel code is safe when the this way                                prevent possible rope attacks                                so whenever a system called dry Seng to                                execute new function new functionality                                it falls in a it's cause it's a page                                fault in the patient we can run some                                verifier that ensures that the call is                                performed - known a symbol and not to                                the middle of some function and so when                                the access is considered safe we are                                mapping the required page into the                                restricted mapping if the access is not                                safe we kill the process and again it                                didn't really fly it was just our first                                attempt and looking into using page                                tables for improving a container                                security the other one we'd tried it was                                a simple patch about                                                                                                                           a team we called the map exclusive in                                its so memory region in the process is                                 considered exclusively owned by that                                 process and is related from the rest of                                 the system for instance it can be used                                 to store secrets in memory one can a map                                 very such region with that flag and then                                 read data to that region and this data                                 won't be visible nicer to kernel no to                                 other processes in the system so this                                 red thing is this is pointing to his                                 already                                                                  one of these one of their suggestions                                 that appears on the thread is instead of                                 using a map and advise and protect and                                 such it may be worse using FD backed                                 memory and create a day of exclusive                                 memory                                 as as somebody suggested or their secure                                 memories somebody else suggested and                                 then this it will be a chapter device                                 that will behave similarly to a remedy                                 and in this way we can reduce complexity                                 of such exclusives mapping of such                                 exclusive mappings in because the a map                                 method of the chart device                                 implementation will take care of                                 extracting the right memory pages from a                                 direct map and then making them making                                 them visible only to processes that own                                 the file descriptor another huge problem                                 with creating regions of memory with                                 different properties that normal direct                                 Maps uses is a fragmentation of direct                                 map mappings a direct map is usually                                 mapped with larger pages it can be one                                 jjigae or two makes only x                                       whenever we extract some small memory                                 region from the direct map we split this                                 huge map a huge map page mappings of the                                 direct map and then there is nothing as                                 it can return them back like there is th                                 pin compaction for userspace pages there                                 is nothing like that for caramel                                 mappings and the last one that is not                                 yet upstream and probably won't be                                 anytime soon but still we are working on                                 it for in the container world namespace                                 is creating isolation by means of                                 utilizing some of the kernel objects and                                 making sure that every namespace owns                                 part of the kernel objects it's using so                                 we are trying to create page table for                                 namespaces and then the                                 objects that are anyway private to that                                 namespace will be visible only in the                                 page tables in all the processes and                                 that found in that namespace so for                                 instance it will be something like that                                 if there are buffers devices sockets                                 whatever kernel structures that belong                                 to a particular name spacing they have                                 their own page tables they will be                                 mapped only in that page tables and they                                 will not be seen by the rest of the                                 camera for network namespace which was                                 our first guinea pig network namespace                                 and creates independent networks take                                 from each instance of the namespace all                                 the objects in that stack and anyway                                 private and most of them never cross                                 namespace boundaries and except escapees                                 all right                                 so being created the prototypes that                                 allows to map in objects in particular                                 net network namespace in its own page                                 table and they made these objects                                 invisible in other page tables of the                                 kernel it was pretty simple also kind of                                                                                                          working but we've added the PGD to the                                 struct nerdiness and then we are forcing                                 that PGD to be used by every process as                                 it joins the network namespace in clone                                 and share settle nests and then we also                                 post the restrictions that every thread                                 of the same process should live in the                                 same network namespace and we did                                 improve of concept with several objects                                 and the next step we did is we created                                 extensions to own page allocator and                                 slop caches to allow allocations that                                 also private to certain namespace                                 and pages or objects allocated whiskey                                 Malik and friends are visible only                                 inside the page table of the process                                 that on behalf this process these                                 objects were allocated something like                                 that and we also took special some                                 special care for Jaques traversing                                 context boundaries like whiskey being me                                 so whenever whenever whiskey being                                 traverses namespace boundaries it                                 becames unmapped in previous only                                 namespace and mapped in the next only                                 namespace these are more or less memory                                 management implementation details that                                 we are using internally for now being                                 EDG FB exclusive for pages slab                                 exclusive to mark the entire slab cache                                 as exclusive and it implies a BGP                                 exclusive for every allocation of new                                 pages for that particular slab and they                                 we mark pages that allocated in such                                 manner with a new page type which was                                 probably will be found upon but for the                                 prototype it works just fine so for now                                 we stick with it                                 so whenever page is allocated in in such                                 with GFP exclusive we call set memory                                 not present in the page or a cutter and                                 that makes the pitch disappear from                                 direct map and as such it won't be                                 visible in any kernel mappings of other                                 processes and whenever it is free to be                                 returning back to the direct map and                                 again we are returning to the same                                 problem of fragmentation of directive                                 mappings which need to be resolved and                                 also we restrict such allocations to                                 happen only when we have actual mm this                                 won't happen in case read something like                                                                                        and with key Malick most of this is                                 already implemented for POC it's so                                 scary I'm frightened to look at it                                 myself                                 and and we were able to get as far as to                                 allocate struck shock and this truck tcp                                 and struck the ski buff we'll say the                                 modified version of came out and I still                                 was being have been able to have a TCP                                 traffic inside the namespace that used                                 all these bells and whistles and                                 protection methods now it appears that                                 it's not an easy task probably it will                                 take more than a couple of months and                                 maybe even more than years touching mmm                                 code is really difficult because you can                                 get back reports and you wouldn't                                 anticipate and it actually effects every                                 Linux user and there are open questions                                 we have about how this feature could be                                 used beyond the network name spaces so                                 it could be user nests Utes and network                                 UTS namespace may be others and they                                 it's really unclear at that point with a                                 security benefit with will outweigh edit                                 complexity and performance penalties so                                 uh as many of us I am running out of                                 slides thanks a lot thank you let's                                 thank a speaker                                 questions Yelena                                 I have many but I've got to ask after                                 that's all right so with the network                                 namespace insulation what happens if I                                 create a new network namespace then open                                 a socket and network namespace pass that                                 socket Bialek fellowship by passing to                                 someone outside the namespace and in                                 that process acts on that socket like                                 does that work as it suddenly have to                                 like switch the page tables in the outer                                 process or do you just prevent passing                                 sockets around we don't support it from                                 now okay Hey well I thought that we                                 should remain the new namespace and can                                 you talk a bit about what like what the                                 overarching goal here is like are you                                 trying to just I'm mitigate arbitrary                                 reads but not prevent a vittoria writes                                 or we are not trying to mitigate it in                                 any particular issue we are presuming                                 that we'll have vulnerabilities and we                                 are trying to restrict kernel mappings                                 as much as possible so that a ever since                                 it is not strictly needed will be                                 unmapped                                 and then it would make attackers life                                 harder at least that's what we think                                 hi have you considered using memory                                 tagging instead of memory spaces should                                 achieve the same goal namespaces are                                 pretty much given for containers so what                                 we're trying to do to protect namespaces                                 rather than use different memory                                 management techniques to protect                                 processes the the the object of                                 isolation is a namespace I'm thinking                                 about the overhead that the thing you                                 will incur basically will switch between                                 namespaces well tuck if you be much                                 lower level the the context which is                                 implicit because whenever you switch                                 from process to process you do switch to                                 and they do switch of the context and                                 then a page table at the kernel part of                                 the page table of processes and                                 different namespaces will be different                                 but you have the context that context                                 switch anyway okay mark so at least on                                 on                                                                      kernel threads because we have to base                                 registers for page tables one for the                                 low half the address base we use a space                                 that actually gets context switched and                                 one for the high half that has the                                 kernel in and we only used one page                                 table there and we avoid lots of things                                 like lazily faulting in the V malloc                                 area through that so this sounds like                                 this would have quite a significant                                 overhead in our case which we don't have                                 today so we want support I'm                                    initially at least question                                 thanks for the talk some people who know                                 Windows kernel told me that Windows                                 kernel doesn't have this map at all and                                 they as I could understand every kernel                                 process has special mapping separate                                 mapping for it is it really better                                 design that having FISMA before all the                                 kernel Linux is better so probably it is                                 Linux is fastest or probably it is                                 better and I don't know it's making each                                 and every process his own view of a                                 physical memory probably not really good                                 idea                                 I know I don't know that it I don't know                                 the details about how Windows work so I                                 can but use it really compare apples to                                 apples oranges to oranges but what would                                 Linux is faster yes what would be the                                 design if we don't have this map at all                                 no idea a a lot of things rely on that                                 you can get page to physical physical to                                 page and which is the direct map like                                 DMA device drivers other things I don't                                 know Thanks                                 more questions                                 um I have a question I'm not sure I                                 understood correctly but how would that                                 work with device drivers having some                                 kind of state shared state when you have                                 a packet for instance going somewhere                                 and they have to manage Iowa State and                                 then you lose research from namespace                                 how would you be handled will be still                                 available on we understand correctly you                                 have for instance network device drivers                                 that creates an SK buffer that probably                                 happens in unit mm-my context and then                                 that that this key B will need to go to                                 some of the namespaces and that's a                                 question SKB I can understand how it                                 would go to a namespace but if there's                                 other other memory allocation the                                 memories it's mapped by physical device                                 Frank for example Oh a common state a it                                 common state between part of a physical                                 device in a namespace and part of the                                 physical device outside the namespace I                                 don't thinks it's something that's                                 possible and in container environments                                 mostly physical device leaving initial                                 namespace and the virtual devices                                 leaving the inside the namespace and                                 they just communicate with each other                                 via bridge shows some other sort of Sdn                                 implementation                                 questions                                 okay if not let's make a speaker                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=CrslqYjmzq4


