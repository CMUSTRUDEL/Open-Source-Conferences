Title: Exploiting Race Conditions Using the Scheduler - Jann Horn, Google
Publication date: 2019-11-04
Playlist: Linux Security Summit EU 2019 - Lyon, France
Description: 
	Exploiting Race Conditions Using the Scheduler - Jann Horn, Google
Forum 1

Speakers: Jann Horn
This talk shows how two bugs involving somewhat narrow-looking race windows (https://crbug.com/project-zero/1695 in the Linux kernel, https://crbug.com/project-zero/1741 in Android userspace code) can be stretched wide enough to win the race conditions on a Google Pixel 2 phone, running a Linux 4.4 kernel, by making use of the unprivileged sched_*() syscalls.
Captions: 
	                              first off I have a couple slides in this                               talk that have a bit of skim off on for                               like code samples and stuff so if you go                               to this URL                               thanks to the great website that this                               event has you can just like look at the                               slides on your own laptop alright i'm                               yun horn from google project zero i'm                               here today to talk about some tricks                                that can be used to exploit race                                conditions in lost environment all of                                the boxes i'm talking about you have                                been fixed so a long time like one of                                the boxes from like                                                    from last year and all of the exploits                                are against kernel                                                     land store is relevant for soon devices                                but of course unlike desktop the knox                                land was very ancient but the focus here                                is on like exploitation techniques not                                on the individual box so i think that's                                fine okay so i'm going to be talking                                about i'm going to be using three                                different box as examples today are to                                talk about exploitation techniques the                                first part is something that gives you a                                use of the free of a physical page                                through STL TLB entry and that we                                exploiting that require is requires                                hitting an arrow taming window and i'll                                talk a bit about how the behavior of the                                body allocate influences how you can                                exploit this and how you can play with a                                preemption and with the scheduler to                                make your race window bigger then                                there's a second park that was a kernel                                box that lets you decriminalize RAR file                                and i'll talk a bit about how you can                                exploit that in a way that would                                normally be a race condition but then                                use user for lefty and fuse to make                                deterministic again and how the KCM uses                                call helps with exporting users after                                three bags and then there's a third part                                which was an Android user space mark                                when exploitation required the primitive                                that was somewhat similar to what you'd                                get with infuse I use a hold of D but                                those aren't available on Android so                                I'll talk a bit about how you can sort                                of build up romance                                alternative to that okay so the first                                black I'm talking about is a race                                between the Emory map and effort locates                                is calls has a quick bit of background                                but you need to understand how the back                                works on you in the CPU you have the                                Translate translation lookaside buffer                                which caches page table entries                                basically so that you can do address                                translations faster than always walking                                the page tables and while the page table                                entries are essentially like rev counted                                pointers to pages the TLB just borrows                                references from your page tables because                                the CPU isn't going to like be                                incrementing and decrementing references                                on your page structures so this means                                that when you're removing entries from a                                page tables you need to also clear out                                the corresponding cache an increase in                                the TLB otherwise you get a use of the                                freeze the first physical that                                participates in this block and the one                                that actually had the buggy code as the                                M remember so small memory map can be                                used to move a memory mapping from one                                virtual address to another virtual                                address this of course requires creating                                a new virtual memory area structure and                                so on but also requires moving the                                actual page table entries and allocating                                new page tables for the destination                                address range so M remap has to go and                                allocate new page tables for the new                                mapping then move the page table entries                                over from the open mapping into the new                                mapping and then clear the translation                                lookaside buffer for the old address                                range at the second back that                                participate the second versus call that                                participates in the race is F allocate                                allocate allows you to allocate a D                                allocate space for a file and if you use                                allocated to DL okay it's based on a                                file and not only DL okay it's pages on                                disk but it also tries to free up page                                cache files sorry page cache pages that                                are currently cached in the kernel so                                 when you use allocate it has to go and                                 iterate through all of the virtual                                 memory areas across different processes                                 on system that include this file range                                 and then tries to yank out the pages                                 from them so it looks                                 our page table entries that are nonzero                                 deletes the page table entries flashes                                 the core the TLB range and then drops                                 the references on the pages and the race                                 here was that memory map didn't hold any                                 locks between the time it moved the page                                 table entries from the old address to                                 the new address and when I did that he                                 obviously at the old Adams                                 so this means that you could have a race                                 where first a Murray map moves the page                                 table entries from from the old address                                 of the new address                                 but you can still have I'm stealthy OB                                 entries for the old virtual address then                                 a fellow kid comes along deletes the                                 page table entries of the new address                                 that's a TLB flash that removes entries                                 for the new address range but not the                                 old address range and then F allocate                                 would drop references on the pages and                                 at this point you'd have the LT of the                                 entries pointing to pages that have                                 already potentially been put back on the                                 page free list so this gives you a use                                 after three of a physical page and on                                 Linux before for the nine that this was                                 actually exploitable to get right access                                 to pages starting with                                                   access was a very narrow timing window                                 and only read access to pages was easier                                 so I decided to write next for the pixel                                 to phone because that's the ones                                 afforded for kernel so the first exploit                                 idea that I had here was okay we have a                                 physical page in the free list and we                                 have really had like full read and write                                 access to this page let's try to                                 reallocate this page so that it contains                                 kernel data the thing is that the kernel                                 page locator the body a locator has the                                 vaguely this behavior I have appeared                                 this isn't entirely accurate or someone                                 who knows the alligator please don't                                 think too badly of me for simplifying it                                 this way but basically the idea is that                                 we have this free page that gets put                                 onto this read per CPU per CPU free list                                 up there which is a free list that is                                 specific to the migration type migrate                                 move all four pages that can about                                 relieve in front by the colonel and                                 colonel locations for a current all data                                 structures normally come                                 the migrate unmovable lists and the                                 patron locator kind of tries to keep                                 those memory types separate and if you                                 want a page to move from like moveable                                 type to an unmovable type you need to                                 create memory pressure and stuff and it                                 gets messy and I didn't want to deal                                 with that so instead I decided to go for                                 reallocating the page as again a page                                 belonging to user space so you could                                 either reallocate the page as an                                 anonymous page in some other process but                                 that would require you to interact with                                 another user space process and that user                                 space process might do other things that                                 disrupt the kernel heap and so on so                                 that didn't seem like such a good idea                                 so I decided to go for relocating the                                 page as a page cache file so what this                                 means is you trigger this bug to get the                                 page freed then you trigger a read on a                                 specific page in some shared library                                 that is used by a privileged process and                                 then this read will allocate the page                                 that you just read and put it in the                                 page cache for the file read data from                                 this into this page and then hopefully                                 you can modify this page of code before                                 the the before some privileged process a                                 continuous use this code and then you                                 can escalate privileges into the context                                 of that process there are two things                                 that make this kind of hard the first                                 thing is that you need to detect when n                                 mu have is at the right point where you                                 want to interrupt it and to your F                                 allocate operation luckily as an                                 attacker we can use proc affairs for                                 this because proc FS contains statistics                                 about the memory usage of each process                                 including specifically how much memory                                 is used for page tables so we can see                                 exactly when m remap is allocating                                 memory for new page tables and then use                                 it as a signal the other thing is that                                 the way I chose to exploit this requires                                 that we have this TLB entry long enough                                 it requires that the MMF operation takes                                 so long that in the middle of the MMF                                 operation we can not just reallocate the                                 page but also do disk i/o because we                                 want to be doing our use of the free                                 right after data has been fetched from                                 the disk into the page otherwise the                                 disk is just going to overwrite the data                                 we put in there so the plan for                                 exporting this requires knowing a bit                                 about how preemption works the Linux has                                 on Linux user space programs can always                                 basically be preempted by sending inter                                 processor interrupts or something like                                 that so but it gets more complicated                                 when you're running in kernel context                                 Linux they're supposed that's really                                 from preemption models one of them is                                 the voluntary preemption model where                                 kernel who explicitly calls em quandary                                 scared to say hey I can be preempted at                                 this point and this is used by many                                 Linux distros by default but Android                                 uses for preemption model in which you                                 can send like inter processor interrupt                                 to interrupt a to preempt a kernel code                                 that is executing in almost any context                                 along as long as it's not holding a spin                                 lock or something like that and                                 importantly mutexes do not behave like                                 spin locks mute actors do not prevent                                 preemption and Linux also gives us a lot                                 of control over the schedulers behavior                                 so basically the idea is that you can                                 tell the scheduler to make your tasks                                 run faster or give it higher priority                                 but you can tell the scheduler that your                                 own tasks should run at a reduced                                 priority or should only be running on                                 certain CPU cores or things like that                                 and if you for example say this task                                 should have idle priority it should run                                 a very low priority and there's some                                 other task that's running on the same                                 CPU had no priority then you only get                                 woken up something like once a second                                 also it has both higher priority never                                 preempts other tasks so this means that                                 if you have an idle task                                 that is waiting for some input to arrive                                 and then that input arrives but some                                 other house is currently running on the                                 same CPU then you will not be switching                                 over to the idle task until like the                                 next scheduled attic arrives                                 sounds like that and importantly this                                 these scheduler controls do not just                                 affect your tasks when they executing in                                 user space mode but they also affect the                                 execution of kernel code and in                                 Seussville context on behalf of your                                 tasks so this means that you can for                                 example take create two tasks yourself                                 put them on the same CPU core by telling                                 the scheduler these tasks may only run                                 on the CPU core set one of them to idle                                 scheduling priority and the other one to                                 normal priority and then let the idle                                 priority task start executing some Cisco                                 that for example takes a lock at some                                 point text sorry                                 reset yeah you can you can have your                                 idle task executes some Cisco and then                                 in the middle of that Cisco wake up your                                 normal priority task and then you can                                 use this to stall the execution of this                                 of the Cisco                                 potentially in the middle of some race                                 condition or something like that                                 for quite some time so here's a timing                                 diagram of how I ended up exploiting                                 this bag I go through this step-by-step                                 so we have five tasks here across for                                 CPU cause each task is pinned to a                                 specific CPU core at the start we have                                 test B and C sharing one CPU for each                                 other task has its own CPU core and only                                 it has B is running at idle priority                                 everything else has no low priority task                                 is the task that is a task that is just                                 in a busy loop trying to read and write                                 the page the virtual address                                 in the old mapping where we are about to                                 get a stale TLB entry the idea is that                                 by in a busy loop constantly accessing                                 the address as long as the page table                                 entry still exists when the TLB entry                                 goes away we immediately refreshing the                                 TLB entry and then later when the page                                 table entry has gone away and we still                                 are out stale TLB entry we can detect                                 when the page contains the code we                                 expect so if we actually know that the                                 page was relocated in place we wanted                                 and then we override it task task C                                 starts off by reading from some empty                                 pipe which causes a to block which means                                 that at that point it has B can can                                 execute since it's the only thing that's                                 runnable on the CPU it has B starts                                 executing every map and starts                                 allocating memory for page tables and                                 moving page table entries at this point                                 task D which is in a busy loop and                                 pulling those statistics and proc                                 affairs can can notice the progress of                                 the American corporation and wake up                                 task C by writing through the pipe that                                 has C is blocking on at this point task                                 C priam starts bb-because Thursby is                                 higher priority on chest c is not so now                                 task B is in the middle of this Emory                                 map operation what we wanted and the                                 first thing it has seen nowadays is to                                 move the task B over to CPU                                              is running and task a is just spinning a                                 loop so trance B is probably not going                                 to get woken up for quite some time and                                 at this point at SC can use F allocate                                 to trick to perform the other side of                                 the rice putting the page on the                                 perceive you free list and then use the                                 period syscall to read a page from the                                 library were targeting and reallocate                                 the page as page cache and at that point                                 hopefully                                 tusky will then see the page cache                                 contents that override them with                                 arbitrary code                                 okay that was the first bug as a second                                 example                                 this one's bit easier that this was a                                 bug from                                                             orally decrement the ref count on a                                 struct file the bug itself doesn't                                 actually have a race condition in it but                                 the way I chose to exploit it would                                 normally uraeus                                 without special tricks it's a bit of                                 background for this on Linux you have                                 two mechanisms user fault ft and fuse                                 that allow user space to synchronously                                 handle page faults in the case of user                                 fault ft that's precisely the intent I                                 use a fault if T is specifically a                                 mechanism with the intent will I use the                                 spaces infamously handle page faults                                 whereas with fuse                                 you can basically construct the same                                 primitive by mounting a fuse filesystem                                 and then a mapping a file from it and                                 when you have a page fault in a file                                 that is backed by a fuse file system the                                 fuse file system gets to resolve the                                 page fault at any time at once                                 and you can use this to these two tricks                                 on like normal                                 yes Desktop Linux systems to arbitrarily                                 block on a code execution at any point                                 where the kernel does things like a copy                                 from user copy to user ID user pod user                                 and so on but on Android I use a fault                                 fdn fuse are not exposed to undulate                                 code so it's not really usable there so                                 here's the bug I want to use as an                                 example here basically you can see the                                 code on the right-hand side we have this                                 FD get which takes a reference to a                                 struct file and then we columns as W PFF                                 get function which has an error case                                 where it calls FD put then returns an                                 error code and then we go into this if                                 our branch in the upper part of the code                                 and this branch again calls after food                                 so it's like a straight forward Park                                 that just over decrement the reference                                 count                                 a Cisco that's very useful for                                 exploiting user to freeze on certain                                 data structures including struct file is                                 the casein pieces call which is                                 available on kernels that activate a                                 checkpoint restore case EMP you can                                 basically see what it does on the right                                 hand side is a Cisco for making                                 arithmetic comparisons between a few                                 scattered kernel pointers so the intent                                 here is that if you have for example a                                 process with a big file descriptor table                                 and you want to figure out which ones of                                 those file descriptors map to the same                                 struct file so in other words which all                                 descriptors share the same file                                 description object instead of doing like                                 PR wise comparisons between the file                                 descriptors somehow you can do like a                                 normal old n log and sorting algorithm                                 where as the comparison function you use                                 the KC and pieces call so this works on                                 a bunch of different data structures in                                 the kernel are quite important clean                                 like struct file mm struct files Drive                                 and so on but this is also useful for                                 exporting use data freeze because for                                 example if in your file descriptor table                                 you have one pointer to a file yeah you                                 have a dangling pointer to a file that                                 has actually been freed and then you                                 reallocate that memory for another                                 struct file and get a pointer to that in                                 your follow scribble table and you can                                 ask a CMP hey did I reallocate the new                                 struct file in exactly the same place as                                 the old struck file or did I hit some                                 other memory location so this can be                                 used to make exploits very reliable and                                 I think this also might have some                                 interesting applications in the future                                 unless the channels especially for                                 memory tagging because you can ignore                                 this if you don't know what memory                                 tagging is but basically with memory                                 tagging you have these tag words as part                                 of your pointers and these tag words are                                 secret and if you can leak them you can                                 defeat the mitigation                                 and this thing compares the complete                                 pointers including the tag words so you                                 could use this to repeatedly query                                 whether the tag bits are the same and                                 then if they're not the same you can                                 retry until that they match up yeah so                                 here's what back in the four to four                                 days the VF has write function looked                                 like so at the very start of the villa's                                 VF s right G function we have a check                                 that checks if we have read access if we                                 have write access on this file                                 descriptor and if we do not a bails out                                 so the way you can exploit the back is                                 you create a you create a fuse file                                 system um fr from the fuse file system                                 you open a slash dev session Alice                                 writable and then you start a variety                                 operation on death null which has its IO                                 vector stored inside the fuse mapping so                                 the right vistas call comes in as the                                 check sees okay the fellows writable we                                 can continue and then further down you                                 can see this import I over call where we                                 import the io vector from user space so                                 at this point import a avec has to do a                                 copy from user on this memory region                                 that is backed by a fused filesystem                                 this blocks until user space resolves                                 the page fault by supplying some data so                                 at this point we have as much time as we                                 want to trigger how I use of the free                                 free this I'm deaf nor file struck that                                 we operating on and reallocate it as                                 something else now normally when people                                 like spot use after free say do stuff                                 like oh we replace this drug with a                                 struct of the compute different times so                                 we turn on use after free into a type                                 confusion where we are interpreting                                 numbers as pointers of interpreting a                                 type point of one type as another type                                 of something like that but what you can                                 also do is you can just allocate another                                 struct file so we open slash def left R                                 on tap as read-only and then we can use                                 the case EMP trick to check whether we                                 indeed place the crontab follows at the                                 same location where we previously at all                                 def null file and then if we see that it                                 worked or you can resolve the page fault                                 and you read the rightly continues and                                 it performs the actual vide right                                 operation on the ATC crontab file so now                                 we can write arbitrary content in the in                                 the crontab and elevate privileges to                                 route and this whole thing works without                                 any like type confusions or like Rob or                                 any of these things okay and the third                                 Park example that I have is use of the                                 get Bitcoin function in Android                                 so as background when you have some                                 system where you're where you're                                 integrating with as a Linux users base                                 demons sometimes need to figure out what                                 is the essence of context of the peer                                 but I'm talking to like if you have some                                 demon and it's receiving requests from                                 some client and has to check its the                                 client allowed to do this so if I UNIX                                 the main sockets the situation that's                                 pretty nice you can use things like SOP                                 a sec to ask the kernel hey what's the                                 security context of my peer but until                                 recently Android bind IPC system it                                 didn't tell you that bind that just gave                                 you the UID and the process ID of the                                 sender so luckily there's a helper                                 function that you can use in this case                                 which is called get vidcon you give it a                                 PID and it gives you the essence context                                 of the process with a PID so obviously                                 this has problems because for example                                 that's the classic PID reuse problem                                 that if the center of the message goes                                 away and then not a process spawns and                                 reuses that PID before you get around to                                 doing with this check then you see some                                 completely different as Linux context                                 that has nothing to do with the actual                                 sender of the message and the way that                                 get pit Khan is implemented is basically                                 that it opens in progress under the                                 process directory the address left                                 current file and read from that yeah so                                 in Android just as hardware service                                 manager thing didn't really know what it                                 need to do know what it is but it's                                 basically like some                                 demon that manages names and this is                                 reachable from like a normal application                                 context and from other places in the                                 system and this thing receives received                                 some IPC calls and then has to figure                                 out what the context of the sender is                                 and it used to get vidcon for this so to                                 exploit this we have to exit our sending                                 process and then we need to make some                                 privileged thread spawn somewhere in the                                 system that reuses the PID and like for                                 making a privileged thread spawn                                 somewhere in the system that requires                                 user space interaction and isn't very                                 fast and so it would be nice if we could                                 stretch this race window out between the                                 time the binder IPC is received and the                                 time getpid con actually reads the es                                 lunes context and luckily we can make on                                 like                                                                     gap it phone call that just opens the                                 file and in progress and reads from it                                 takes something like                                                  it's background for this on Lin up until                                 I kernel for at                                                          high notes drugs which protects a bunch                                 of operations including a get dense                                 which is used for like the really busy                                 function so this function takes this                                 mutex on a high note                                 then iterates over the directory entries                                 for this inode copies the directory                                 entries to use a space while holding the                                 lock and then drops the lock in the end                                 so if you have a big directory                                 and you doing this operation you are                                 holding this mutex while accessing a lot                                 of map user space memory which can take                                 a lot of time another path that also                                 takes the inode mutex is the lookup slow                                 function which is used if you don't have                                 like a cache directory entry for the                                 name that you're trying to look at so                                 for example in progress if you haven't                                 accessed a process through progress                                 before there won't be a cache directory                                 entry for it                                 so this means that if we can make if we                                 can clog get dense and make that take a                                 long time then we can also block this                                 the open call that getpid con dies for                                 the same amount of time most of you                                 probably already know this stuff but                                 operating systems you can have the                                 problem priority inversion we have every                                 three tasks task a with high priority                                 task B with a normal priority task C                                 with low priority and then if task C                                 which has the lowest priority takes                                 unlock and then get stranded by task B                                 which is running for an extended amount                                 of time and then at a later point task a                                 wakes up and tries to take the log task                                 a blocks in the log task a can't acquire                                 the lock because C is holding the log                                 and tasks you can make progress because                                 task B is blocking the CPU so                                 effectively task B is running even                                 though it has lower priority than task a                                 and this doesn't just apply if you have                                 a task a and has B with different                                 priorities it also applies if you have                                 tasks a and B with the same priority                                 because then you're still violating                                 fairness between true processes that                                 should be scheduled like                                          actually one of them gets all of the CPU                                 time and this also works with column                                 utexas because they don't protect                                 against priority inversion unless you                                 are unlike an PM dartie system so this                                 means that we can potentially block                                 execution by creating by artificially                                 creating priority inversion problems                                 okay so here's the basic idea instead of                                 use the user fault FD to block a user                                 space access for as long as we want we                                 create two tasks task and task B and pin                                 them to the same CPU and task a gets                                 I'll priority task we get normal                                 priority and has B is executing a spin                                 loop so now we let a task a execute the                                 retail operation the                                                    the mutex and then it starts doing a                                 user a user space memory access the user                                 space memory access triggers a page                                 fault which triggers IO now the i/o                                 operation itself is broadly short but                                 when                                 we trigger I own our task stops running                                 and yell so CPU turn to another task                                 until the i/o operation has completed                                 but because idle tasks never preempt the                                 execution of non idle tasks even after                                 the i/o operation is completed our task                                 aid doesn't get scheduled again for like                                 something like a second actually so so                                 this allows us to deal to to make the                                 this user copy operation that is                                 happening while holding the mutex stall                                 for an extended amount of time and we                                 can repeat this if we have a large user                                 copy operation so we can map a bunch of                                 pages so that the read ahead logic                                 doesn't fire for example by explicitly                                 opting out of read ahead and then we can                                 by pawning a bunch of processes make it                                 so that the get dense operation on a                                 progress right so for something like                                    pages and then we get one something like                                 one second of delay for every for every                                 single page fault waiting for the                                 schedule let you move us back on the CPU                                 and then this gives us something like                                    seconds of total delay for and for this                                 duration we can stall the get pit phone                                 call well I went through my slits way                                 faster than I expected yeah that's it                                 [Applause]                                 so questions I think many I think you                                 actually there's a lot of interesting                                 details and the part for the case in P                                 and the memory tagging is actually fully                                 new for me so I'm gonna check out that                                 so very scary thanks for the great talk                                 first question about the first buck why                                 it is easier to exploit on kernel before                                                                                                          it was a it was a specific change in the                                 like vulnerable code path so basically                                 the code behaved differently depending                                 on whether the PT ease that was flushing                                 writable or not and in the case where                                 the PT is a variety board would actually                                 do a TLB flash earlier on your kernels                                 okay yeah thank you and second about                                 second book I like user fault of D as                                 well very much and but there are cases                                 when you have several gave free calls                                 before you have your code running your                                 spray running what happens then so it is                                 the freed element is somewhere behind in                                 the free free list and your next                                 allocation doesn't reach it yes                                 so I actually kind of oversimplified                                 this year bit and what I actually did                                 was I think I am I did a I I opened                                 slash deaths or it's less a disease that                                 won't have a bunch of times and then I                                 used K CMP on each of the open instances                                 to see whether one of them managed to                                 reuse the same memory allocation so like                                 yeah and what was the size of slab                                 element which slab cache                                 did it happen file structs have their                                 own slab cash like modulus the blur like                                 a slab merging stuff so they're not                                 they're not on a came along slab okay                                 and how how many files with crontab you                                 had to open to just reach it was it a                                 lot don't know where I put this sorry I                                 don't remember this was like                                          thank you very much thank you great talk                                 questions everything was very clear or                                 questions                                 [Applause]                                 ignorant on normal desktop linux all                                 these scheduler set ready locals anybody                                 can make them right but it can can                                 normal user code do that on Android as                                 well yes normal user code on Android can                                 use like said scheduler and the pinning                                 stuff to like make themselves to move to                                 a low priority or chip into specific                                 CPUs                                 if not I guess we can the next thing                                 first assessing the speaker                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=MIJL5wLUtKE


