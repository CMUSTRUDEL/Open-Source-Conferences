Title: Zephyr Project Security Status - David Brown, Linaro
Publication date: 2019-11-04
Playlist: Linux Security Summit EU 2019 - Lyon, France
Description: 
	Zephyr Project Security Status - David Brown, Linaro
Forum 1

Speakers: David Brown
In this talk, David Brown will give an overview of recent and ongoing work on security in the Zephyr Project. The Zephyr Project is a Linux Foundation hosted collaboration project, a real time embedded OS (RTOS) optimized for resource constrained devices. Areas covered will include the Core Infrastructure Initiative Best Practices, static analysis, various certifications, API design, and fuzzing.
Captions: 
	                              hello so I get the last slot of the day                               at the Linux Security Summit where I'm                               going to not be talking about Linux so                               hopefully this is still relevant to us                               I'm gonna start with a bit of an                               overview of what Zephyr is because I                               think that's not necessarily well known                               it is a Linux Foundation project but                               let's start with the the official                                marketís little blurb there the Zephyr                                project is a scalable real-time                                operating system artists supporting                                multiple hardware architectures                                optimized for resource constrained                                devices and built with safety and                                security in mind okay what is Zephyr                                what what is it so if some of those                                words make sense it's a real-time                                operating system formal familiar with                                that it's typically focusing on                                deadlines rather than multiple users                                that kind of thing but from the                                perspective I'm coming at this from a                                security perspective it's open source so                                it's Apache licensed not quite the same                                license as the Linux kernel but it it's                                hosted in gift we actually hosted on                                github we work with the pull request                                model there are maintainer x' mailing                                lists and lots of meetings we use a cake                                config device trees we used to use k                                build that moved to Cape to see make                                just to give you an idea of little                                comparison here between the Zephyr                                project source tree and the Linux tree                                as of about an hour and a half ago                                there's a few more lines of code in the                                Linux kernel it's a bit bigger                                unfortunately no there isn't actually                                any Haskell code in in the Zephyr                                project there's a dot HS file in there                                for some reason which slot count counts                                but                                you get the idea where there's a seed                                project it's open source we try to a lot                                of people came from the Linux world and                                we've kind of brought a lot of the                                development mindset and methodology                                there so to give you an idea though it's                                a really busy project github gives these                                nice statistics the                                                commits                                                            thousands of files tens of thousands or                                                                                                        month as a comparison and I'm not sure                                how well github does this because it's                                not doesn't use github model but it                                still sees the same get tree of the                                Linux kernel you get actually pretty                                similar numbers out of that there's a                                lot more churn of the Zephyr code                                there's a bunch of things where we're                                taking code and moving it into separate                                modules and that's causing a lot of the                                the changes and additions and deletions                                but there's a lot happening with the                                codes the idea just to give you an idea                                I don't expect those to be readable or                                identifiable but there's about a hundred                                and seventy little boards of various                                types there's another exciting picture                                that was felt to marketís to me to                                include that was shoes and hard hats and                                other interesting things that are                                running zephyr but what I want to go                                over is what's different between the                                Linux kernel and zephyr I mean another                                way to put this this is a Linux                                Foundation project why are we even doing                                this we already have the Linux kernel                                key differences zephyr is typically a                                single address space there's a thing                                called a memory protection unit it's                                like an MMU light it doesn't do address                                remapping the only thing you get out of                                it is protection you can say this block                                and this usually really restrictive it                                might be a power of two alignment                                boundaries of that size of thing and you                                get                                eight of them or                                                      the controller it's typically no dynamic                                code so that has radical impact on the                                threat model the we're not running code                                that an arbitrary user on a machine runs                                we're running code that somebody                                building a product wanted in that                                product at least we're hopefully our                                running code turns out you really do                                 need to count for arbitrary code running                                 because there are bugs buffer overflows                                 incoming data that kind of thing it                                 still can be possible to run code but                                 it's still a different environment of                                 how it's how it comes about and how it's                                 run another really big difference is we                                 tend to do a lot of things at compile                                 time that would normally be dynamic on a                                 Linux system how many threads do you                                 have what kind of devices do you have in                                 your system how much memory are you                                 configured for a lot of that would be a                                 compile time choice the idea is to get                                 the code small I mean think about what                                 we're targeting here our microcontroller                                 is where you think of hundreds of                                 kilobytes of code and maybe tens or                                 hundreds of kilobytes of RAM and that's                                 it                                 so it's not a dynamic system it's well I                                 could show my age it's the kind of                                 computer that I started programming on                                 except really really tiny and cost                                    cents so with all that aside of what                                 zephyr is let's talk about security and                                 just a little bit of background I am i                                 work at Lennar oh I've been there just                                 under four years hired on to the                                 security working group team and for                                 about three years I've been having this                                 focus on IOT I came from actual Linux                                 kernel security before that and just                                 this past this was about six months ago                                 I was elected as the security architect                                 for the Zephyr project was an exciting                                 election to the end I ran and no one                                 else did so it was as long as someone                                 voted I                                 one but I want to go over what are we                                 doing about security in this project                                 linux gets a lot of focus Gregg gives                                 his talks about CVEs                                 what are we doing in this project for                                 security and so I'm gonna break time                                 down to real real easy divisions of past                                 present future what we've done what                                 we're doing and what our kind of                                 grandiose plans so now we get slides                                 with lots of words on them so big thing                                 is memory protection and this is fairly                                 new                                 most are tosses kind of don't do this                                 they assume you have a simple address                                 space and everything just runs and we                                 started out well we have this memory                                 unit this memory protection unit what                                 can we do the obvious thing is to look                                 at what Linux does you have user space                                 you have kernel space these processors                                 typically have kind of the same division                                 of the protected privileged mode and a                                 non privileged mode if you look H                                 processor uses different words for them                                 just to help keep everything confusing                                 so we added this memory protection turns                                 out it's not I mean it's quite it's                                 actually quite useful there's a lot of                                 things it protects for but as I                                 mentioned before with that user model of                                 WEP code is running on the system it's                                 not necessarily protecting against the                                 right things turns out it's pretty easy                                 to have a lot of things on the wrong                                 side of that boundary you can get a                                 system where a small amount of                                 application code is running in user mode                                 and then most of your system and most of                                 the code that's vulnerable is still                                 running in privileged mode so despite                                 the fact we have this done there's a lot                                 of work to do for memory protection a                                 lot of that is taking in order to move                                 something to the outside of this                                 boundary you need to come up with system                                 calls and it's not POSIX really haratz                                 system calls specific for drivers pieces                                 of drivers and way to figure out what                                 those are                                 so we've done that it's kind of a past                                 thing but there's a lot more to do so I                                 wanted to give that to make sure that it                                 sounds like we've done practical things                                 because a lot of these points they sound                                 like things you would give it a talk at                                 a conference instead of things you'd                                 actually do to improve security and it's                                 because they are but they're also they                                 are important things but they don't                                 immediately directly translate into code                                 so the rest of these things we've done                                 we have a security subcommittee this                                 meets bi-weekly and that little star                                 means there's more slides coming we've                                 created documentation on secure coding                                 practices if you have ever tried to do                                 that it turns out it's really hard to do                                 what it really boils down to is and it's                                 actually worded pretty much this way as                                 you need to have people on your team                                 that know about security and know what                                 to look for in code so we've created                                 this documentation it's public it's on                                 the Zephyr project org website there's a                                 little security button I'm gonna talk a                                 little bit in a minute about what we've                                 done with our git repositories to try to                                 focus a little bit on security as well                                 as safety then some of the more possibly                                 controversial things we've registered                                 with mitre as a CVE numbering authority                                 and as you can imagine these are some                                 interesting meetings we get to go to to                                 discuss what are a bunch of rules that                                 essentially amount to how you allocate                                 integers to when does a particular                                 vulnerability become one CVE or does it                                 become multiple CVEs how do they                                 correspond with patches just try to get                                 some homogeneity and to try to make the                                 database useful we've it's been about a                                 year now that we've got this we've I                                 think we've done about four official                                 CVEs that doesn't mean we haven't fixed                                 bugs we've we do fixed bugs                                 things that have been reported against                                 previously JIRA now github there's when                                 I last checked                                                       been closed as fixed no real easy notion                                 of whether those are all security fixes                                 sometimes that's hard to know we joked                                 at our last security meeting somebody                                 said well we just need something to tell                                 us what's the security bug and so I said                                 Alexa is this a security bug and was                                 immediately greeted by someone's Alexa                                 in the meeting defining bug so it didn't                                 even help when I when it did hear me a                                 couple of other things there's this                                 thing called the core infrastructure                                 initiative CII that has this notion of                                 best practices and they're not specific                                 things to software but there are things                                 like when you have a website you have to                                 use HTTPS and these things and there's a                                 big list of those and they have                                 different levels that you can qualify                                 for we are now passing as gold so it's                                 pretty smaller subset of the projects                                 that are using this infrastructure                                 initiative so that's kind of a nice                                 thing at least it tells us that our                                 source code isn't going to change easily                                 without us being aware of it that kind                                 of thing and then just lastly some of                                 the things we've done is using a                                 automation to prevent regressions the CI                                 that was set up pretty early in the                                 project we have a lot of targets as                                 about                                                                  make sure that all of the sample                                 applications all the tests not                                 everything can be run we don't have all                                 of this hardware but at least we can                                 build it and make sure it keeps building                                 all right so what is this subcommittee                                 it's defined by the Charter when Zephyr                                 was created the Zephyr project was                                 created at the Linux Foundation Zephyrs                                 a project you joined that companies join                                 the the funds are used to run the                                 company and there's different levels of                                 contribution that people can                                 companies can contribute to and way it's                                 defined as each Platinum member gets the                                 seat and then we can invite other people                                 by invitation from that and then there's                                 two roles there's a security chair which                                 is elected by the rest of the                                 subcommittee and they're basically                                 responsible for running the meetings for                                 taking notes for making sure stuff                                 happens and then there's the security                                 architect that's me that's basically                                 defined to be responsible for overall                                 project security the ideas significant                                 changes that are at least theoretically                                 supposed to affect security are supposed                                 to go through the security architect                                 before they're made to the project so                                 what do we do about our repositories                                 sure most people are familiar with the                                 long term stable release of the Linux                                 kernel and we do something quite similar                                 to this we we've had two of their know I                                 think we've only had one of these I'd                                 have to think back on that one we have                                 zero one or two of these long-term                                 stable releases it's a fairly recent                                 thing for us to have them they've been                                 in planning for quite some time and we                                 have this other branch that we call                                 auditable which is kind of like the                                 long-term stable but more so so the idea                                 of LTS is a little different than it                                 might be in a lot of other projects                                 product-focused                                 its current code with the latest                                 security updates interestingly we want                                 to bring in compatibility with new                                 hardware zeffer people at boards very                                 frequently to zephyr and usually they                                 want to use them fairly quickly and so                                 we don't really have a prohibition                                 against using brand new code from a new                                 board in this long-term stable release                                 so those are generally those patches are                                 generally pulled back into the the new                                 heart the long-term stable release they                                 tend to be isolated changes to just a                                 group of files                                 and the main thing this this code is                                 more tested the cycle of development is                                 extended and it's supposed to be stable                                 for the long term it's what you would                                 choose to bring into a product if you're                                 gonna build an IOT device a sensor a                                 shoe any of these interesting things                                 that people come up with for devices                                 this is a good starting point for that                                 that's is the idea it's a it's feature                                 based focusing on hardening the                                 functionality of what's there it's not                                 intended to be cutting edge to bring in                                 the new latest stuff now that's the one                                 in the middle this one on the the right                                 is auditable is a branch off of the long                                 term stable release and significantly it                                 is a subset of the code and the idea                                 here is there's a lot of types of                                 certification many of them involve                                 safety but there are a handful of these                                 that involve security issues                                 FIPS                                                                    want to build products and then get                                 these certifications the idea is to have                                 a part of the code that's a starting                                 point for that that we can address the                                 issues even the work with the labs to                                 get maybe call it pre certification or                                 certifiable is a term that we've we've                                 used and the idea is if you're building                                 a product excuse me if you're building a                                 product that needs some kind of                                 certification or multiple multiple kinds                                 of certification this is a good starting                                 point for you and this is just starting                                 we haven't done any of these                                 certifications yet this is just the                                 beginning of something we're kind of                                 seeing that we need to do so that's                                 where we're at now                                 as far as where we're going first point                                 there is we're trying to be open about                                 this                                 you have the product documentation                                 publish what it is what our goals are                                 and then just these lists of things that                                 are in that documentation we're working                                 on coding guidelines that's a link when                                 these slides are sent out you can click                                 on it that will take you to our current                                 coding standards current guidelines how                                 to report vulnerabilities it's a big one                                 with the CVE process is that people know                                 I found a vulnerability it may be                                 sensitive who do I send it to can I get                                 a BGP key to encrypt it too so that it                                 isn't just flying out over the Internet                                 freely what happens when I send that                                 vulnerability report in so that's                                 documented and then we have currently a                                 JIRA instance to manage bugs during any                                 kind of embargo process that's needed                                 this is still fluid we're using JIRA                                 because of it has a richer permission                                 model than github did at the time github                                 adding support for security advisories                                 we may evaluate over time just moving to                                 github so that we don't have two                                 different places that bugs our storage                                 because right now we have all of our                                 issues in github except for these                                 security issues which get reported to                                 JIRA                                 so that database is mostly not visible                                 once something has become published and                                 so we want to release notes refer to it                                 the link will work we change the                                 permissions on it and you can go look at                                 that particular issue to find out                                 information about it alright so I talked                                 about the coding guideline Linux kernel                                 has a document that I believe leanness                                 originally wrote which how do you write                                 code for the curve                                 we started with this one of the first                                 things we did with a zephyr project just                                 go through and make it look like Linux                                 code some of that was using tabs to                                 indent and proper spacing on different                                 things but when especially when you get                                 to safety certification but security                                 certifications look at these a little                                 bit there's some documents about misra c                                                                                                         these other documents to use as a                                 reference and thing about these these                                 documents is there kind of a mixture of                                 some really good ideas and what were                                 they thinking there's so what we're                                 trying to do is incorporate these in but                                 we realize you can't just say oh well                                 all your code must comply with this                                 document that's not publicly available                                 you must comply good luck so we are                                 looking into tooling that can                                 selectively enforce these different kind                                 of requirements and you know these vary                                 from basic things like you can't have                                 global variables that aren't used to                                 things it's about being able to when you                                 do security sensitive code to audit that                                 code all of it and then typically                                 involves looking at the assembly output                                 of the compiler and making sure the                                 compiler did the right thing and so                                 there's a lot of stuff in there about                                 writing code that fits with that but                                 there's also things in there like no                                 dynamic memory allocation at all so if                                 you're building something with zeffer                                 that uses TCP or uses not TCP well that                                 has AI a location to uses TLS there's                                 allocation in all of as far as I know                                 the TLS libraries embed TLS that we use                                 so we that's why we have that auditable                                 code base that you're going to have a                                 smaller subset of the code that's able                                 to comply with these things so                                 a security guy codeine guideline doesn't                                 magically make all of your code better                                 but it's it's a starting point it it                                 gives some things that we can look to                                 that you shouldn't do this in your code                                 and a tool that will flag wouldn't you                                 do that so that we can at least analyze                                 whether well should you be able to do                                 that and do we need to write up an                                 exception and that kind of thing so                                 another example in our code so this is                                 kind of what we're doing now this is an                                 open PR for updating our entropy random                                 framework we got a couple reports of                                 vulnerabilities about a subsystem or                                 another subsystem that we're using what                                 turns out and not to be a cryptographic                                 random number generator for part of the                                 protocol that needed cryptographic                                 random numbers to be secure so there's a                                 couple of those so what we're doing is                                 we're actually going through the the                                 randomness the entropy code separating                                 them out separating the randomness API                                 so this is very clear what you're asking                                 for if you just have a function that's                                 you know give me random data doesn't                                 really tell you is that                                 cryptographically secure random data is                                 that just kind of random that might be                                 good for a backup timer what's it good                                 for so this is the kind of thing we                                 discussed in the the security                                 subcommittee in this case I was actually                                 somebody on the team that worked on the                                 issue and the goal here is to clean up                                 our API we're in kind of a neat position                                 of being able to change our API and                                 document things so that it's easier for                                 people to do the right thing that these                                 things are documented it even just named                                 better so that you know what you need to                                 call if you need to do something and                                 that includes things like the entropy                                 API is made clear that you probably                                 don't want to call this you you probably                                 don't need entropy and                                 you're implementing your own                                 deterministic random bit generator and                                 make sure that it's clear no you don't                                 want to call entropy you want to call                                 the output of a random bit generator                                 that itself will use entropy to seat                                 itself so what's what's our goal I mean                                 we want to make Sepher more secure what                                 does that mean and so we've as a                                 security subcommittee we've kind of had                                 to sit down and decide what are some                                 things that we want to do and then we                                 have to work with the technical steering                                 committee to decide which of these                                 things we're gonna do so just a couple                                 of slides here on what are our goals for                                 the upcoming year so right now we have                                 this kind of mishmash of crypto drivers                                 we include both embed TLS it's pulled in                                 through our brand-new module system as                                 well it's not a get sub module it's not                                 a repo thing it's a West thing we have                                 our own tool that was written for that                                 to pull in dependencies and then we also                                 have tiny crypt which is as you can                                 imagine a small cryptographic library                                 and different parts of the code call                                 different ones of these and so there's                                 an ongoing discussion of do we need in                                 more unified API so that these can be                                 plugged in and you can use different                                 implementations for this so there's a                                 thing by arm called the platform                                 security architecture it's large and has                                 many parts but one of those is they have                                 a crypto API which is basically started                                 with the crypto library underneath embed                                 TLS with some name changes and they've                                 actually changed embed TLS to use this                                 API is defined so that's kind of one                                 obvious choice it's targeted for                                 embedded devices the same as we are                                 targeting                                 there's other people pushing for                                 something like pkcs                                                     example by Amazon free artists as their                                 official crypto API and these are                                 ongoing discussions we want to evaluate                                 these what do we do another thing we                                 want to be looking into is FIPS                                         when I first wrote these slides it                                 wasn't accessible the the text of the                                 the standard it is now I haven't                                 actually taken the time to read it but                                 people build these it's um intended for                                 cryptographic modules so first thing to                                 think of is the the little module that                                 sits inside of an ATM that performs the                                 cryptographic operations isolated from                                 the rest of the system there's a move to                                 use this for things that are parts of                                 systems and separated devices but a lot                                 of people demand the certificate or at                                 least compliance with this a lot of                                 specs the Bluetooth spec talks about                                 well you need this such-and-such                                 cryptography that needs to be fits                                                                                                                on the crypto operations they want to                                 make sure you you do the right thing                                 that you have the right primitives                                 available that you've implemented them                                 correctly they they continue to do the                                 right thing they have a set of test                                 suites that you have to run on boot in                                 order to be compliant and the idea is                                 this is a common way for people to get                                 kind of an assurance that some thing                                 providing cryptographic operations maybe                                 does them right so we're looking into                                 for people who want to use effort to                                 build something that is going to comply                                 with hips                                                             them the generally they certify products                                 we're an OS not a product but there's                                 still things that we can do so that if                                 somebody pulls this code in the                                 certification lab may be knows oh that                                 came from the Zephyr auditable tree                                 which has been pre certified and                                 just takes less work and less money for                                 them so another big issue is with secure                                 boot we've been working on this for a                                 couple of years now with zephyr there's                                 a boot loader called MCU boot and caveat                                 I'm one of the maintainer zuv that                                 project that started out as the boot                                 loader for one one ôs minut we've                                 generalized this that it now supports at                                 least effort in my note there's some                                 other things being working on for that                                 and what it is it's a small boot loader                                 so it has a lot less functionality than                                 something like you boot or what might be                                 find in a UEFI BIOS it does upgrades it                                 can revert these upgrades check                                 signatures against public keys that are                                 kept in ROM in the device and as an                                 example the trusted firmware project for                                 m-class architectures the                                 microcontrollers is using MCU boot as                                 its bootloader and for Zephyr we can                                 build with this bootloader we can use it                                 things that need to be done is it's not                                 a clean set up right now to build an                                 application that uses the bootloader you                                 can I have to go build that yourself and                                 assemble the things and try to make the                                 image out of it                                 we also don't have a real good upgrade                                 story                                 how do you do upgrades over-the-air                                 where do they where do they come from                                 and this is in process we have a couple                                 of pull requests open and one I believe                                 just closed just merged to implement                                 various standards that have been                                 developed for distributing firmware                                 over-the-air having it with the                                 signatures there's the thing called suit                                 which is the IETF working group for                                 software update for IOT and this is a                                 attempt to build a manifest format                                 it's an RFC describing a manifest format                                 to describe what's in a firmware image                                 so to have a standard format rather than                                 the ad-hoc one we made for MCU boot                                 and then things like richer key                                 infrastructure right now it's one public                                 key that somebody had to use to sign                                 every firmware image on every device and                                 clearly there's a need for whether that                                 be x.                                                                chaining or something else but there's                                 any for something richer than that and                                 then there's an interest in fuzzing                                 fuzzing gets a lot of news you talk                                 about vulnerabilities that are found by                                 fuzzing the Linux kernel different parts                                 of it fuzzing different programs case                                 you're not familiar with it the idea of                                 fuzzing is a tool that basically                                 generates garbage as inputs to something                                 to try to exercise all of the edge cases                                 looking for vulnerabilities most fuzzing                                 work is done on larger systems than                                 zephyr typically targets the typical                                 fuzzing is a library you link in with                                 your application while you build it with                                 additional profiling information so that                                 the fuzzing tool can determine what                                 paths the code is taking to direct the                                 fuzzing data that's passed in because                                 otherwise you have a problem with just                                 too much data it's too hard to find the                                 edge cases there is a research project                                 forget what university it is on a qemu                                 based buzzer where the rich part of the                                 fuzzing is done on a Linux machine and                                 then the application is running in                                 emulation and it watches that and feeds                                 it the the data because the thing is                                 that existing fuzzers often assume lots                                 of memory that we do have a POSIX native                                 port of zephir but not everything works                                 there you don't have network devices you                                 typically will have sockets available at                                 as user space tasks and there's a lot of                                 things that are a lot of the code that                                 doesn't get exercised in this                                 environment                                 big thing is this is an open area for                                 research if anyone finds this                                 fascinating it's a it it would be a very                                 useful place to put effort let's believe                                 it at that                                 and lastly documentation we want to                                 improve our documentation we well I I                                 wrote some threat models for Zephyr a                                 couple years back I've since learned                                 what a threat model actually is and it'd                                 be nice to go back and take some time to                                 write down what I wrote down as a threat                                 model to read like a threat model and                                 also to figure out is it pertinent                                 anymore and to maybe find some more                                 applicable environments or                                 configurations other applications other                                 contexts where that threat model would                                 apply so that's all I have for the the                                 Zephyr security update I guess I got a                                 couple minutes if anyone has any                                 questions                                 Hey so I have two questions if the time                                 loss                                 the first is have you considered more                                 safe language instead of C I'd love to                                 which one are you thinking of well I've                                 just looked it up and it turns out that                                 it's possible to run an NGO or a store                                 whatever on things like my microbeads                                 yeah I think it's a wonderful idea I                                 don't think that's gonna happen on this                                 ephra project for quite some time                                 the projects doing the safe languages                                 and embedded targets are pretty immature                                 right now but it's definitely a great                                 direction to go I don't know how long                                 it's gonna be before we want to move                                 there I mean there's kind of a joke on                                 the the reddit channel for rust that                                 people say oh well rewrite it in rust                                 and that's not usually a good answer for                                 something but there's definitely a place                                 for new applications to at least start                                 by looking at that and see if we can get                                 these tools to a state where that's                                 useful so I see ethics so and since                                 you're stuck with C what is your testing                                 strategy and do have any tools like a                                 cell so one of the difficulties is that                                 there's such constrained devices that                                 this code runs in we do so we have some                                 static analysis that we're running right                                 now which can detect some cases of                                 buffer overflows memory usage issues                                 that kind of thing a lot of it is we                                 test a lot we build all of the code we                                 run it we hope we find the things but no                                 there's a lot of need for that for                                 something like that                                 the challenges of how do you do that in                                 a device                                 it has a hundred kilobytes of RAM you                                 know what do you do with you know we've                                 added memory protection as is that's a                                 significant thing can we partition                                 things more fine-grained things that                                 shouldn't be handing data accessing data                                 don't and that kind of thing but if                                 people have ideas that would be really                                 helpful - thank you                                 thanks a lot for a talk could you                                 elaborate how much code do different                                 platforms share I mean I know that fur                                 can run on x                                                       microcontrollers as well how much code                                 to this platform share in common so                                 without opening a terminal window I                                 can't give you exact numbers there is a                                 lot of common code so the code that's                                 dependent on the devices you will have                                 architecture specific code for arm for                                 cortex-m                                                          processor it's not that much code the                                 whole system is much smaller than                                 something like Linux but most of the                                 code that's not common is drivers the                                 core code for scheduling that kind of                                 thing is shared between everything but                                 again I can't really give you if we want                                 to like pull up the code afterwards I                                 can get more detailed numbers there's                                 one we'll look through the tree there                                 it's pretty cleanly divided I just asked                                 because I wanted to understand if I for                                 example fusses Zephyr on one platform mm                                 how about bugs which I found do they                                 leak able to other platforms and so                                 that's gonna depend on where the bug is                                 found obviously but a lot of the the                                 core stuff for whether it be I mean the                                 networking stack is not gonna be                                 specific to it but to a platform the                                 Bluetooth stack is not gonna be specific                                 to a platform so there's a lot of that                                 code so as long as what you if what you                                 find is a bug in your platform                                 they say the flash driver that you are                                 the driver for the Bluetooth hardware                                 that's probably only gonna apply to that                                 but if you find a a bug in how memory                                 protection and semaphores work that's                                 probably in general and one small                                 question as a security architect                                 what do you think about bug volunteer                                 for Zephyr it's kind of beyond my scope                                 to come up with where the funds were for                                 that would come from it we do get                                 reports from researchers the bounty                                 might increase that I don't know it's                                 you know what I'll bring it up I'll                                 bring it up with the TSC I mean the                                 people who make the decisions about                                 money can certainly set aside some for                                 something like that and your questions                                 know what let's thank the speaker                                 [Applause]
YouTube URL: https://www.youtube.com/watch?v=VtAY2Ouw5l8


