Title: Dealing with Uninitialized Memory in the Kernel - Alexander Potapenko, Google
Publication date: 2019-11-04
Playlist: Linux Security Summit EU 2019 - Lyon, France
Description: 
	Dealing with Uninitialized Memory in the Kernel - Alexander Potapenko, Google
Forum 1

Speakers: Alexander Potapenko
During the last two years, KMSAN (a detector of uses of uninitialized memory based on compiler instrumentation) has found more than a hundred bugs in the upstream kernel using fuzzing.
Telling by the kernel code coverage, many more bugs still remain uncovered though (e.g. we have only scratched the surface of USB device drivers).

Some of such bugs pose actual security risk, letting attackers to leak kernel data or subvert the control flow, finally executing code with elevated privileges.

Given that new bugs are still being introduced every month, kernel vendors (especially those maintaining older kernels) may want to kill the whole class of uninitialized memory bugs by initializing every heap and stack allocation in the running kernel.

We'll discuss the Linux 5.3 features that perform stack and heap initialization, their applicability for production use, and potential improvements.
Captions: 
	                              hi everyone my name is Alexandra I'm                               gonna talk about uninitialized memory                               bit so sorry this is guest probably yeah                               nice so let's start with what                               uninitialized memory release its memory                               that's actually uninitialized so if we                               create a variable a local variable or a                               heap allocation and it's used before we                               assign any value to it                                then we consider it an initialized it's                                an initialized as well if we're using it                                after it has been freed so according to                                see standards starting from C                                           considered undefined behavior which                                means we compile and we do whatever it                                wants optimize the code away change it                                so some copales really do so and                                different yeah even if they don't the                                result is still undetermined about this                                means that attackers may use such bugs                                too by controlling this memory to                                provoke crashes information leaks are                                CRC's                                and so on so right now I'm working on                                kernel memory centers which is a - I                                compile a base to a bit detects uses of                                an initialized memory in the Linux                                kernel it tracks every bit every bit of                                kernel memory writing telling whether                                it's initialized or not and compiled                                instrumentation propagates this state                                and checks whether uninitialized memory                                is used in conditions or pointer                                dereferencing or whether values are                                copied to use a space or data                                oh sorry or hardware right now this code                                lives on github I've sent some RFC                                patches upstream but it will take some                                time to                                actually London so within we've                                integrated km son with his boat f as in                                infrastructure developed at Google                                within two years it has found more than                                                                                                        been using like                                                         for example case and use uses ten times                                more machines so                                                     those are real they still are false                                positives and one of non reproducible                                errors but we don't report them to                                upstream developers out of those                                    bucks                                                            there was                                                            and almost a hundred networking bugs                                yeah almost a hundred net networking                                bugs                                most of those bugs I will never report                                it upstream because networking people at                                Google just fix them right away                                                                                                      in pre moderation queue most of them are                                used after freeze which have been                                already reported by casein some of them                                just don't have the produces or not                                reproducible anymore three bugs have                                pending fixes which means the fixes                                landed already but these bodies waiting                                for for it to reach all the directories                                most of the bugs that we found are fixed                                within one week some of them however                                take ten months or more to fix                                here are the bugs that have been                                reported this year so an average game                                sound reports like seven bucks a month                                so we don't have much data about the bug                                lifetime but based on                                                 can see that the lifetimes of bugs                                almost uniformly distributed within one                                year and                                                             are below so a lot of places in the                                kernel copy parts of struct struct                                socket or a socket address from the user                                space but they treat it as a hole struck                                also a lot of people allocate a                                structure but forget to initialize some                                of the its fields or forget to                                initialize but the pattern which is also                                critical and then this structure gets                                copied to the user space so some                                pointers made malloc also USB USB code                                code initializing USB devices often                                doesn't check that the read from the                                device succeeds and it actually read                                more than                                                          there is a lot of bugs that are still                                there in the girl right now as his body                                covers only                                                         code on x                                                             attack vectors are still uncovered so we                                 we have only basic support for                                 networking for ipv                                                    really generate packets that do anything                                 complex like initiator handshake for                                 example sorry there is very limited                                 support for USB for KVM and there is                                 almost no support for vilest                                 in the Turcan stacks which probably                                 contain a lot of bugs for example                                 information leaks that don't require                                 physical access to the machine                                 I also expect like                                                 present in the Romanian networking code                                 it's an indeed sorry it's unlikely that                                 the uninitialized box may disappear                                 anytime soon                                 so whatever you took from the Google                                 project zero says that box related to                                 sorry but the bugs related to                                 information leaks are deeply rooted in                                 the C programming language and I                                 actually believe that all bugs related                                 to an initialized memory are deeply                                 rooted in C so what shall we do to never                                 have to deal with an initialized memory                                 again the answer is simple we must                                 initialize all the memory there are                                 several reasons to do so just if we                                 initialize all the memory there won't be                                 any information leaks second if we have                                 code that has branches that depend on an                                 initialized memory then it will execute                                 deterministically and third if we                                 initialize memory that has been freed                                 then it complicates use after free                                 exploitation but when Microsoft already                                 does this for pure ODS on the stack                                 since November last year so yeah we're a                                 little educated job let's start with                                 this tech initialization case Cook has                                 put a number of a number of kernel                                 configs under an umbrella there is a                                 number of GCC plugins that initialize                                 parts of the local variables so                                 structures marked as user space as has                                 been copied to use a space there are                                 structures that have passed by                                 references and finally we can zero                                 initial eyes anything passed by                                 reference there is also a flight called                                 unit stack all which initializes                                 everything on the stack with an infinite                                 screen button this is only supported by                                 clang which is something that we may                                 want to change in the near future thank                                 and also zero initialize locals but this                                 is this mode is protected by a really                                 lengthy flag because kind developers                                 don't want to introduce a new C++                                 dialect so our goal is to converge to a                                 situation where all the Spotted                                 compilers can zero initial eyes all the                                 locals on the stack in order to do so we                                 must introduce a similar option to GCC                                 by the way any GCC contributors here and                                 make MacLean community support this zero                                 initialization option as a first-class                                 citizen                                 there's been also a proposal from the                                 community to introduce yet another C                                 standard mode for the compiler which                                 will be just a collection of such                                 options so we've measured some measured                                 the performance of the locals                                 initialization and the numbers look                                 pretty good so in most cases it's almost                                 free the problem is that we it's it's                                 really hard to benchmark such changes                                 because if if a benchmark like a net                                 worth spends most of the time in the                                 kernel it's not really representative if                                 we have an answer                                 benchmark like for example androids                                 benchmarks which used both the kernel                                 code and the user space code then their                                 variance is really big and it's really                                 hard to tell whether anything slows down                                 or not so ideas are welcome if anyone                                 knows how to bench mod can slow down a                                 size impact of this instrumentation is                                 pretty low but certain hot functions                                 still needed an extra cache line or two                                 so the question is can we do better                                 first of all we must use your                                 initialization for that because the code                                 is more compact it's faster second right                                 now clang is bad at dead stir                                 elimination there is a lot of                                 opportunities to do cross base in log DC                                 in both the middle end and the back end                                 and also fgo and LG oaken so they're the                                 full program analysis can help remove                                 redundant stores that come from inline                                 functions and maybe GCC is actually                                 doing a better job so we must just                                 switch to GCC for certain cases in which                                 the compilers cannot do their job well                                 there is attribute uninitialized which                                 is prevents initialization of certain                                 hot functions so let's now move on to                                 the keep our Linux                                                 parameters called init on Alec and then                                 it on free which initialize heap and                                 pager lock memory the first option is                                 more cache friendly because it's                                 initializing the memory chunks that are                                 likely to be accessed soon the second                                 one is a bit slower but it minimizes the                                 lifetime of this sensitive data unit on                                 free works somewhat similar to packs                                 memory sanitize which is unfortunately                                 downstream                                 but Welbeck's memory scientist has an                                 advantage of disabling initialization                                 for certain caches which we haven't done                                 yet just because we come to measure the                                 security and speed impact of those                                 changes so initializing the heap with                                 substantially slower than initializing                                 the stack although it's possible to                                 reduce the costs by not initializing                                 some some places I just need to better                                 understanding of how this works in terms                                 of security whether we can try it bit                                 with security in these cases so yeah                                 it's it's a big deal to not initialize                                 so certain buffers that get for example                                 initialized later one of the approaches                                 to do so is introducing a special GFB                                 flag for that this will only work for                                 allocations because we don't passively                                 flags to three functions we've checked                                 that this can this is an easy way to                                 improve certain benchmarks by just                                 fixing one or two call sites one or two                                 allocation sites but such GP flags are                                 really easy to abused because there is a                                 lot of allocation sites in the kernel                                 and they go easily out of control on the                                 other hand there is a nice nice                                 portunity for optimizing this even                                 further by omitting and non initialized                                 K malloc last memset and the memset can                                 build at a later removed by dester                                 elimination bus in the compartment                                 another option is to introduce a slap                                 flag that disables initialization all                                 together for a certain cache which will                                 work for both Anita nelec Indonesian                                 free this is easier to set up and                                 control for example we can                                 create a list of uninitialized slaps at                                 boot time this is what packs memory                                 centers does Salinas also thinks that                                 opt-outs inevitable we just need to                                 figure out which places need to be fixed                                 and document and well yeah so memory                                 initialization is also related to the                                 new instruction set extension which is                                 called the memory tagging extension or                                 empty it has been announced last year                                 but doesn't exist in Hardware yet the                                 best of my knowledge the core idea is to                                 assign a four bit tag to every aligned                                                                                                        point chip in the girl so a load and                                 store instructions check that pointers                                 and the the corresponding memory chunks                                 have matching tags if they don't the                                 hardware exception is thrown one can                                 think of this as a hardware ace an                                 implementation which is really fast and                                 can be used in production so we hope                                 that people will actually use this                                 another foreign key to work we'll need                                 to set tags for every stack and heap                                 allocation which is suddenly what we                                 need for initializing them and MTE                                 provides special instructions that                                 perform both initialization and tagging                                 of memory which means we'll probably                                 have a cheap way to both detect keep                                 corruptions in production and kill                                 uninitialized bugs altogether                                 so yeah I'm actually out of slides at                                 this point so if anyone has any                                 questions welcome                                 for this tech initialization did you                                 also look at the increase in stack frame                                 size for functions so the question is                                 did we look at the increase of stack                                 frames right well it doesn't affect this                                 stack frame size just because we do do                                 only mean the initialization not for                                 example I'm Mt so let me explain if we                                 initialize the local variables then we                                 don't introduce any additional locals                                 yeah but the compiler tries to reuse                                 stack slots between difference so we                                 will use the same sectionals for                                 different variables in different places                                 in the function and actually when we did                                 the GCC plug-in we found out that                                 actually the stack frame size is                                 affected it could be like a pathology of                                 the plugin or it could be a GCC problem                                 but I was wondering if you had any                                 numbers for playing on the stack frame                                 size is affected I would suppose that                                 for a GCC plugin that doesn't initialize                                 all the locals it it could be so that                                 the the local variables cannot be reused                                 but in the case of LLVM which                                 initializes just everything it's still                                 possible to reuse this textbox and this                                 is done at the intermediate                                 representation level so it's optimized                                 pretty heavily                                 I myself have actually never seen a case                                 where the this cost and is tag load but                                 it probably could be possible                                 things for a talk is it possible to turn                                 memory sanitizer into runtime mitigation                                 not just debugging technique well I                                 don't think so                                 just because it's really costly                                 it requires twice twice as much memory                                 just just to store all the metadata so                                 twice as much memory altogether plus it                                 inserts a really a really heavy                                 instrumentation that affects every                                 arithmetic operation every load and                                 store in the in the kernel so it's a lot                                 cheaper and easier to just initialize                                 everything and yeah on the other hand                                 you can use memory Sanjaya for different                                 things that were that required tracking                                 of certain values from from there during                                 their lifetime for example for taint                                 analysis questions                                 thank you for the talk do we have time                                 for two questions so the first question                                 is you've shown some statistics on how                                 long does it take to fix the bug do you                                 have any thoughts of why some bugs are                                 fixed earlier than others is it about                                 the type of the park or the availability                                 of the proof-of-concept or is it                                 something else                                 so I don't think this has anything to do                                 with the type of bug by the way types of                                 bugs don't don't really say anything                                 because he's bought the just bails out                                 after the first report and it could be                                 so that there is an innocent looking bug                                 which is immediately followed by a                                 remote code execution which is don't see                                 it and really importantly the first bug                                 I think this depends heavily on the                                 availability of maintenance for the                                 certain subsystem for example the                                 natural networking people are really                                 responsive and they've fixed most of the                                 bugs within one or two days and yeah                                 maybe maybe for some people the burden                                 is bigger and they just don't have time                                 for that                                 I see thank you the the other question                                 is about the code coverage so it's also                                 really interesting statistic based on                                 your experience with these tools would                                 you say that once we get the code                                 covered let's say we have this drivers                                                                                                         that the code is bug free at this point                                 like once we get it covered is it like                                 executed millions of times thousands of                                 times I'm just trying to get a feel for                                 that                                 well this metric as as far as I                                 understand this metric actually means                                 that there exists at least one sis color                                 program that executive basic block of                                 course in most cases                                 this is not enough to trigger a bug for                                 example if if a bug requires two two                                 tasks to be made to be running at the                                 same time then you'll need some some                                 biometrics some threading average for                                 example yeah thank you very much                                 it's not let's thank a speaker thank you
YouTube URL: https://www.youtube.com/watch?v=4xJOjSZzqik


