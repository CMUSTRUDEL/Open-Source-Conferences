Title: The Future of Security is in Open Silicon - Joel Wittenauer, Rambus Security, Cryptography Research
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	The Future of Security is in Open Silicon - Joel Wittenauer, Rambus Security, Cryptography Research

In this talk we describe how we used an open operating system (Zephyr) to create a root of trust running on RISC-V based security CPU to secure a high-level operating system (Linux). Security features of the RISC-V processor and the assisting hardware security cores are utilized to implement three internal privilege levels within the root of trust in order to create a freely-programmable application sandbox providing services for Linux.

The talk quickly describes the way Zephyr OS is used as the base, internal architecture of the root of trust, the functionality of its three internal privilege levels and the hardware security cores, the programming interfaces and the current integration state with the Linux host. We would also like to establish a dialogue with the Linux security community in order to understand how to better serve Linux security.

About Joel Wittenauer
Embedded Software Product Architect, Rambus Cryptography Research
Captions: 
	00:00:00,210 --> 00:00:06,950
okay folks we'll get started on the next

00:00:02,520 --> 00:00:11,809
talk we have a talk by Joel Whannell on

00:00:06,950 --> 00:00:11,809
the future of security in open silicon

00:00:13,040 --> 00:00:18,210
ok good morning everyone

00:00:15,030 --> 00:00:18,779
again as James said my name is Joel

00:00:18,210 --> 00:00:23,420
wittenauer

00:00:18,779 --> 00:00:27,779
I am the embedded software architect at

00:00:23,420 --> 00:00:29,640
Rambis cryptography research the talk is

00:00:27,779 --> 00:00:33,780
only allotted 40 minutes and I've got a

00:00:29,640 --> 00:00:36,840
lot of content and I want time at the

00:00:33,780 --> 00:00:44,579
end for questions so I'm just going to

00:00:36,840 --> 00:00:46,590
jump right in so this is a my agenda

00:00:44,579 --> 00:00:48,719
here which is just to give you a little

00:00:46,590 --> 00:00:51,300
bit of background in who Rambis

00:00:48,719 --> 00:00:53,699
cryptography research is we'll talk a

00:00:51,300 --> 00:00:55,920
little bit about Spectre meltdown in

00:00:53,699 --> 00:00:57,840
foreshadow we will talk a lot about it

00:00:55,920 --> 00:01:00,539
but because I think everyone's already

00:00:57,840 --> 00:01:03,719
familiar and then I'm gonna give an

00:01:00,539 --> 00:01:06,960
introduction into our crypto manager

00:01:03,719 --> 00:01:09,000
root of trust core we'll talk a little

00:01:06,960 --> 00:01:11,549
bit about the CMR T hardware and

00:01:09,000 --> 00:01:13,500
software stack and then we'll finish the

00:01:11,549 --> 00:01:16,700
talk up to talk a little bit about how

00:01:13,500 --> 00:01:19,799
all of this can apply to Linux and how

00:01:16,700 --> 00:01:23,280
Rambis cryptography research is looking

00:01:19,799 --> 00:01:25,290
for some insight from the Linux security

00:01:23,280 --> 00:01:29,700
community in general to give us some

00:01:25,290 --> 00:01:39,650
feedback on how this could be used in

00:01:29,700 --> 00:01:42,329
your particular ecosystems so so first

00:01:39,650 --> 00:01:45,950
how many here by show of hands have ever

00:01:42,329 --> 00:01:48,600
heard of ram bus so quite a few of you

00:01:45,950 --> 00:01:54,439
how many of you know that Ram bus has a

00:01:48,600 --> 00:01:57,500
security division not very many so

00:01:54,439 --> 00:02:01,170
rambha's purchased cryptography research

00:01:57,500 --> 00:02:02,939
in 2011 and that was the establishment

00:02:01,170 --> 00:02:04,590
of the Security Division cryptography

00:02:02,939 --> 00:02:06,840
research was founded by a fella by the

00:02:04,590 --> 00:02:10,140
name of Paul Kocher some of you may be

00:02:06,840 --> 00:02:13,770
familiar with Paul Paul was one of the

00:02:10,140 --> 00:02:16,230
guys who helped design SSL v3 in

00:02:13,770 --> 00:02:18,050
addition to that Paul wrote the

00:02:16,230 --> 00:02:23,430
foundational white papers on

00:02:18,050 --> 00:02:26,580
side-channel attacks for hardware for

00:02:23,430 --> 00:02:28,830
extracting secret Keys particularly DPA

00:02:26,580 --> 00:02:31,650
differential power analysis that was

00:02:28,830 --> 00:02:35,640
where cryptography research made their

00:02:31,650 --> 00:02:37,470
name was in DPA extracting keys from

00:02:35,640 --> 00:02:39,349
smart cards I think at one time every

00:02:37,470 --> 00:02:42,750
smart card that was being manufactured

00:02:39,349 --> 00:02:46,769
Paul could extract keys from at one time

00:02:42,750 --> 00:02:48,360
about about 20 years ago today ram ram

00:02:46,769 --> 00:02:51,989
baskerviiie research still has a strong

00:02:48,360 --> 00:02:54,300
portfolio in DP a protection we offer

00:02:51,989 --> 00:02:58,709
cores we offer software libraries with

00:02:54,300 --> 00:03:00,480
DP a resistance we have an evaluation

00:02:58,709 --> 00:03:02,819
lab that will evaluate your products we

00:03:00,480 --> 00:03:06,060
also have a workstation that you can use

00:03:02,819 --> 00:03:09,510
to evaluate your own products on top of

00:03:06,060 --> 00:03:11,989
our DPA portfolio we also have pay-tv

00:03:09,510 --> 00:03:15,540
solutions in hardware we have

00:03:11,989 --> 00:03:19,550
anti-counterfeiting solutions we also

00:03:15,540 --> 00:03:24,480
have a mobile payments group in

00:03:19,550 --> 00:03:27,420
rotterdam netherlands we have a mobile

00:03:24,480 --> 00:03:31,430
ticketing group in East Kilbride

00:03:27,420 --> 00:03:34,379
Scotland we also have offices in Espoo

00:03:31,430 --> 00:03:38,010
Finland in addition to our offices in

00:03:34,379 --> 00:03:40,950
California so we actually have a rather

00:03:38,010 --> 00:03:44,069
large security group that spread across

00:03:40,950 --> 00:03:45,750
the globe and very few people actually

00:03:44,069 --> 00:03:47,580
know about it

00:03:45,750 --> 00:03:49,400
so that's one of the reasons why we're

00:03:47,580 --> 00:03:52,950
here is to kind of introduce ourselves

00:03:49,400 --> 00:03:54,569
again and I believe this is the first

00:03:52,950 --> 00:03:56,760
talk that anybody at Rambis has ever

00:03:54,569 --> 00:04:00,629
given at a conference quite like this

00:03:56,760 --> 00:04:02,849
so anyway so let's talk a little bit

00:04:00,629 --> 00:04:03,989
about Spector meltdown a foreshadow I'm

00:04:02,849 --> 00:04:06,420
not gonna talk much on this slide I

00:04:03,989 --> 00:04:07,890
think everybody here knows what the

00:04:06,420 --> 00:04:10,140
particulars are in this room hopefully

00:04:07,890 --> 00:04:11,489
everyone does if you don't have the

00:04:10,140 --> 00:04:14,340
related CDEs

00:04:11,489 --> 00:04:14,930
listed below in addition to that if you

00:04:14,340 --> 00:04:18,440
google

00:04:14,930 --> 00:04:21,299
any of these you'll find the respective

00:04:18,440 --> 00:04:23,040
websites that have the white papers that

00:04:21,299 --> 00:04:23,460
describe them the one thing that I will

00:04:23,040 --> 00:04:25,650
note

00:04:23,460 --> 00:04:28,020
is that the specter research team

00:04:25,650 --> 00:04:29,340
included my former boss Paul cocksure

00:04:28,020 --> 00:04:32,789
who was the Siara

00:04:29,340 --> 00:04:34,949
founder and my current colleague Mike

00:04:32,789 --> 00:04:36,960
Hamburg both of both of whom were on the

00:04:34,949 --> 00:04:39,919
spectre team I believe Paul also

00:04:36,960 --> 00:04:44,069
contributed a bit to the meltdown team

00:04:39,919 --> 00:04:46,380
so this is really what is the money

00:04:44,069 --> 00:04:47,940
quote I think that comes from the

00:04:46,380 --> 00:04:49,919
specter meltdown and now for shadow

00:04:47,940 --> 00:04:54,690
actually had to adapt my talk because

00:04:49,919 --> 00:04:57,030
foreshadow was so so recent beyond

00:04:54,690 --> 00:04:58,800
short-term solutions such as patching

00:04:57,030 --> 00:05:01,139
the semiconductor industry should

00:04:58,800 --> 00:05:03,300
seriously consider designing chips that

00:05:01,139 --> 00:05:06,389
run sensitive cryptographic functions in

00:05:03,300 --> 00:05:08,910
a physically separate secure core salad

00:05:06,389 --> 00:05:10,620
away from the CPU this design approach

00:05:08,910 --> 00:05:12,570
will go a long way in helping prevent

00:05:10,620 --> 00:05:15,810
vulnerabilities that can be exploited by

00:05:12,570 --> 00:05:20,909
meltdown inspector when that quote is

00:05:15,810 --> 00:05:23,990
from Mike Hamburg who is again one of

00:05:20,909 --> 00:05:29,430
our security researchers that worked on

00:05:23,990 --> 00:05:32,250
the meltdown our brother Spector so we

00:05:29,430 --> 00:05:35,330
think that specter meltdown foreshadow

00:05:32,250 --> 00:05:39,530
are just the tip of the iceberg in

00:05:35,330 --> 00:05:43,009
regards to micro architectural flaws

00:05:39,530 --> 00:05:48,479
again flaws that are specifically

00:05:43,009 --> 00:05:49,979
related to optimizations like with

00:05:48,479 --> 00:05:52,710
vulnerabilities that were exposed by

00:05:49,979 --> 00:05:54,630
Spector meltdown in foreshadow you know

00:05:52,710 --> 00:05:56,580
scary things are that we can break down

00:05:54,630 --> 00:06:00,300
kernel user memory isolation

00:05:56,580 --> 00:06:02,460
virtualization isolation may foreshadow

00:06:00,300 --> 00:06:05,580
even attacks SGX

00:06:02,460 --> 00:06:07,310
which is we you know under specter

00:06:05,580 --> 00:06:10,259
meltdown we thought that SGX was still

00:06:07,310 --> 00:06:12,990
okay for shadow comes along and says no

00:06:10,259 --> 00:06:16,620
so we expect that in the future there

00:06:12,990 --> 00:06:18,210
will be more bugs like this that will be

00:06:16,620 --> 00:06:23,820
found again as scrutiny around

00:06:18,210 --> 00:06:25,469
microarchitectures increases so let's

00:06:23,820 --> 00:06:28,139
talk a little bit about what rambo

00:06:25,469 --> 00:06:30,659
script buggery researches solution to

00:06:28,139 --> 00:06:32,610
this and this goes again back to Mike's

00:06:30,659 --> 00:06:36,979
may be somewhat self-serving quote is

00:06:32,610 --> 00:06:36,979
our crypto manager root of trust

00:06:38,160 --> 00:06:47,200
as you see here on your right-hand side

00:06:42,460 --> 00:06:49,180
you have what is like a die shot and in

00:06:47,200 --> 00:06:52,620
there you have the general processing

00:06:49,180 --> 00:06:55,900
region which is where your CPU cores

00:06:52,620 --> 00:06:59,320
would be located that would be executing

00:06:55,900 --> 00:07:02,620
Linux Android or any other high-level

00:06:59,320 --> 00:07:06,370
operating system next to that connected

00:07:02,620 --> 00:07:10,000
over a internal bus is the secure

00:07:06,370 --> 00:07:11,710
processing core which is in this

00:07:10,000 --> 00:07:14,500
particular instance our crypto manager

00:07:11,710 --> 00:07:17,920
root of trust the cryptid manager root

00:07:14,500 --> 00:07:20,920
of trust contains a custom risk 5 CPU

00:07:17,920 --> 00:07:26,230
that was developed by Ram bus secure

00:07:20,920 --> 00:07:30,280
memories that include a a dedicated SRAM

00:07:26,230 --> 00:07:34,780
and dedicated non-volatile memory crypto

00:07:30,280 --> 00:07:35,980
accelerators and the the nice thing is

00:07:34,780 --> 00:07:39,460
it gives you the flexibility to run

00:07:35,980 --> 00:07:43,360
custom secure applications inside the

00:07:39,460 --> 00:07:46,390
sea MRT boundary so you can develop

00:07:43,360 --> 00:07:49,450
applications yourself and run inside our

00:07:46,390 --> 00:07:54,270
secure boundary using the resources

00:07:49,450 --> 00:07:57,640
available inside the sea MRT boundary

00:07:54,270 --> 00:08:00,370
the sea MRT also offers strong Hardware

00:07:57,640 --> 00:08:02,800
infer and for security which includes

00:08:00,370 --> 00:08:09,970
anti-tamper features and other secure

00:08:02,800 --> 00:08:13,120
logic beyond what's shown here some of

00:08:09,970 --> 00:08:15,490
the use cases that we've identified are

00:08:13,120 --> 00:08:19,390
listed here the ones we think that are

00:08:15,490 --> 00:08:22,290
most applicable to Linux are secure data

00:08:19,390 --> 00:08:25,720
storage secure key storage

00:08:22,290 --> 00:08:28,660
authentication attestation user data

00:08:25,720 --> 00:08:31,300
privacy secure boot and crypto

00:08:28,660 --> 00:08:33,640
cryptographic acceleration I think all

00:08:31,300 --> 00:08:36,700
of these are applications that would fit

00:08:33,640 --> 00:08:42,400
well inside the inside the Linux

00:08:36,700 --> 00:08:44,530
ecosystem so before I go on any further

00:08:42,400 --> 00:08:46,960
since we are again here at a Linux

00:08:44,530 --> 00:08:49,510
security conference there's some

00:08:46,960 --> 00:08:50,290
potentially confusing terminology that's

00:08:49,510 --> 00:08:52,899
used with the

00:08:50,290 --> 00:08:55,060
see Mr T so I just want to make sure I

00:08:52,899 --> 00:08:56,620
pin that down now because these are

00:08:55,060 --> 00:08:57,730
terms that I'm gonna be using over and

00:08:56,620 --> 00:08:59,889
over again throughout the rest of the

00:08:57,730 --> 00:09:01,750
talk and again that could be confusing

00:08:59,889 --> 00:09:05,920
if we don't explicitly call it call them

00:09:01,750 --> 00:09:08,620
out the first is what is a root in with

00:09:05,920 --> 00:09:12,480
respect to the CMR T the root is not a

00:09:08,620 --> 00:09:16,959
user it's not a certificate authority in

00:09:12,480 --> 00:09:19,509
the world of the CRT a root is an entity

00:09:16,959 --> 00:09:22,089
that is composed of an ID and a

00:09:19,509 --> 00:09:27,100
permission set for access to see mrt

00:09:22,089 --> 00:09:29,560
assets the the root defines the security

00:09:27,100 --> 00:09:33,009
context in which user applications

00:09:29,560 --> 00:09:35,339
execute and for a given C MRT there can

00:09:33,009 --> 00:09:38,380
be more than one route that is installed

00:09:35,339 --> 00:09:40,029
again that seems confusing from a Linux

00:09:38,380 --> 00:09:41,949
context but we're not talking about a

00:09:40,029 --> 00:09:46,509
Lennox context we're talking about the

00:09:41,949 --> 00:09:49,389
CMR T's context so you it allows for we

00:09:46,509 --> 00:09:51,009
consider or call multiple routes so

00:09:49,389 --> 00:09:53,709
again I apologize for that terminology

00:09:51,009 --> 00:09:57,550
but that is what we use and that is how

00:09:53,709 --> 00:10:00,220
we market it next is the term container

00:09:57,550 --> 00:10:02,800
again in this particular instance a

00:10:00,220 --> 00:10:06,880
container is not related to docker or

00:10:02,800 --> 00:10:09,579
other OS level virtualization systems in

00:10:06,880 --> 00:10:13,029
the context of the C MRT the container

00:10:09,579 --> 00:10:14,350
is a secure user privileged application

00:10:13,029 --> 00:10:17,079
not the environment in which the

00:10:14,350 --> 00:10:19,810
application executes but the application

00:10:17,079 --> 00:10:21,910
itself and it's the application that

00:10:19,810 --> 00:10:24,699
runs under the context of a root that I

00:10:21,910 --> 00:10:28,269
described in the previous bullet up

00:10:24,699 --> 00:10:30,040
above so what's the lesson here

00:10:28,269 --> 00:10:34,350
with this terminology the lesson is you

00:10:30,040 --> 00:10:37,779
don't let hardware engineers name things

00:10:34,350 --> 00:10:40,089
so I when I got ahold of it but the

00:10:37,779 --> 00:10:43,180
names were there and they stuck and we

00:10:40,089 --> 00:10:44,889
had to live with it so and there's gonna

00:10:43,180 --> 00:10:46,720
be a lot more again as I said these are

00:10:44,889 --> 00:10:48,970
topics that I'm gonna bring up the rest

00:10:46,720 --> 00:10:54,250
of the way through this through this

00:10:48,970 --> 00:11:00,130
discussion so the next topic on the

00:10:54,250 --> 00:11:01,540
agenda here is to go into the CRT

00:11:00,130 --> 00:11:01,870
hardware I think this is probably the

00:11:01,540 --> 00:11:04,210
most

00:11:01,870 --> 00:11:07,149
Hardware specific talk that

00:11:04,210 --> 00:11:09,310
we've seen up till now but I think

00:11:07,149 --> 00:11:11,860
without discussing and describing the

00:11:09,310 --> 00:11:14,589
hardware and our design methodologies at

00:11:11,860 --> 00:11:17,980
cryptography research where we try to

00:11:14,589 --> 00:11:20,170
build this onion of security from the

00:11:17,980 --> 00:11:22,660
ground up so we start with layers of

00:11:20,170 --> 00:11:23,890
security at the hardware and eventually

00:11:22,660 --> 00:11:25,180
when we talk about the software will

00:11:23,890 --> 00:11:27,520
talk about the layers of security that

00:11:25,180 --> 00:11:29,470
we have inside the software so that we

00:11:27,520 --> 00:11:31,600
have defense and depth just like

00:11:29,470 --> 00:11:33,610
everybody else talks about it's our

00:11:31,600 --> 00:11:35,649
design philosophy it's something that we

00:11:33,610 --> 00:11:37,600
truly believe in something that's

00:11:35,649 --> 00:11:40,870
actually worked well for us in the past

00:11:37,600 --> 00:11:43,180
so we'll stop again start talking about

00:11:40,870 --> 00:11:45,640
the CM RT hardware and then move into

00:11:43,180 --> 00:11:50,910
software so hopefully you can see how it

00:11:45,640 --> 00:11:54,550
builds upon itself so what you see over

00:11:50,910 --> 00:11:57,220
over here is a block diagram it's a very

00:11:54,550 --> 00:11:59,770
simplified block diagram of the CM RT so

00:11:57,220 --> 00:12:01,270
it doesn't have all of the blocks but

00:11:59,770 --> 00:12:03,250
what I did was I called out the things

00:12:01,270 --> 00:12:07,089
that I thought were most important in

00:12:03,250 --> 00:12:09,730
the context of this particular talk so

00:12:07,089 --> 00:12:11,740
what you see here highlighted are two

00:12:09,730 --> 00:12:16,060
blocks of a CPU and the memory

00:12:11,740 --> 00:12:19,300
protection unit or mpu again the CPU is

00:12:16,060 --> 00:12:21,670
a custom CPU designed by Ram bus and

00:12:19,300 --> 00:12:24,760
it's specifically designed for the

00:12:21,670 --> 00:12:27,190
crypto manager root of trust it's based

00:12:24,760 --> 00:12:30,310
on the open source risk 5 instruction

00:12:27,190 --> 00:12:33,540
set architecture and selected standard

00:12:30,310 --> 00:12:36,100
extensions of that specification and

00:12:33,540 --> 00:12:38,740
what's critical about that is that our

00:12:36,100 --> 00:12:42,220
CPU uses standard tools you can download

00:12:38,740 --> 00:12:44,140
the risk 5 GCC toolset and build code

00:12:42,220 --> 00:12:47,740
immediately that will run on our

00:12:44,140 --> 00:12:50,470
platform so we are compliant with the

00:12:47,740 --> 00:12:57,750
risk of instruction set architecture but

00:12:50,470 --> 00:13:02,290
it has cryptography research additional

00:12:57,750 --> 00:13:04,980
behaviors that are added in to because

00:13:02,290 --> 00:13:09,370
and fundamentally we begin with

00:13:04,980 --> 00:13:12,880
designing for security right note that

00:13:09,370 --> 00:13:15,850
our CPU supports the three privilege

00:13:12,880 --> 00:13:17,890
levels that exist for a risk 5 machine

00:13:15,850 --> 00:13:19,300
supervisor and user

00:13:17,890 --> 00:13:22,990
and that will be important later when we

00:13:19,300 --> 00:13:25,360
talk about the software stack we have a

00:13:22,990 --> 00:13:29,730
memory protection unit it's based

00:13:25,360 --> 00:13:32,500
loosely on the risk 5 MP u specification

00:13:29,730 --> 00:13:36,970
but it's tailored specifically again for

00:13:32,500 --> 00:13:41,620
the CM RT we have 24 MP you regions that

00:13:36,970 --> 00:13:48,160
we can set up each MP region is assigned

00:13:41,620 --> 00:13:52,480
a privilege level you can't and a access

00:13:48,160 --> 00:13:54,070
type either read write or execute the MP

00:13:52,480 --> 00:13:57,070
registers can be locked until the next

00:13:54,070 --> 00:13:59,560
cm RT reset and why that is important is

00:13:57,070 --> 00:14:03,160
that when we load machine or supervisor

00:13:59,560 --> 00:14:05,590
code into RAM that code should not

00:14:03,160 --> 00:14:07,300
change throughout that entire boot and

00:14:05,590 --> 00:14:11,080
so there's no reason for those regions

00:14:07,300 --> 00:14:14,080
to either expand or decrease in their

00:14:11,080 --> 00:14:15,430
size and they should never change in

00:14:14,080 --> 00:14:18,550
their access type either

00:14:15,430 --> 00:14:21,460
so we lock those in and nothing not even

00:14:18,550 --> 00:14:24,400
machine code nothing of hardware can

00:14:21,460 --> 00:14:26,830
modify those registers until you until

00:14:24,400 --> 00:14:28,570
you reset and so that gives us some

00:14:26,830 --> 00:14:36,090
pretty decent security properties there

00:14:28,570 --> 00:14:38,890
I believe the next important piece to

00:14:36,090 --> 00:14:41,800
the hardware story is that we have a

00:14:38,890 --> 00:14:47,190
one-time programmable non-volatile

00:14:41,800 --> 00:14:47,190
memory that is private to the CMR T

00:14:47,250 --> 00:14:55,060
rights of 0 to 1 in our sense our

00:14:51,910 --> 00:14:57,100
permanent meaning that you cannot go

00:14:55,060 --> 00:15:00,850
back and rewrite things from one back to

00:14:57,100 --> 00:15:02,920
a zero the OTP stores cm RT

00:15:00,850 --> 00:15:06,160
configuration that includes things like

00:15:02,920 --> 00:15:11,080
the device ID the current lifecycle of

00:15:06,160 --> 00:15:14,380
the CM RT and a device unique key is

00:15:11,080 --> 00:15:15,910
also stored inside the OTP one thing to

00:15:14,380 --> 00:15:20,800
note about the device unique key it is

00:15:15,910 --> 00:15:22,930
never exposed on the CPU bus it cannot

00:15:20,800 --> 00:15:25,570
be read directly by the CPU it's never

00:15:22,930 --> 00:15:28,240
read by the CPU as a matter of fact when

00:15:25,570 --> 00:15:30,279
it's created it's created for a back

00:15:28,240 --> 00:15:32,879
channel through a command to

00:15:30,279 --> 00:15:35,949
the OTP management core during

00:15:32,879 --> 00:15:38,680
manufacturing personalization so it's

00:15:35,949 --> 00:15:40,360
it's not injected by the CPU it's done

00:15:38,680 --> 00:15:44,410
completely in the back through a back

00:15:40,360 --> 00:15:45,430
channel a table of route IDs and

00:15:44,410 --> 00:15:47,800
permissions so if you remember back

00:15:45,430 --> 00:15:49,420
earlier we're talking terminology we

00:15:47,800 --> 00:15:52,540
talked about these route IDs and

00:15:49,420 --> 00:15:57,579
permissions those are stored in a table

00:15:52,540 --> 00:15:58,689
in OTP in addition to those items that

00:15:57,579 --> 00:16:00,040
are stored in OTP we also have

00:15:58,689 --> 00:16:03,339
general-purpose non-volatile memory

00:16:00,040 --> 00:16:04,959
that's available to user containers or

00:16:03,339 --> 00:16:09,399
user applications again containers or

00:16:04,959 --> 00:16:10,480
applications and the access access to

00:16:09,399 --> 00:16:13,089
ranges of the OTP

00:16:10,480 --> 00:16:15,069
can be restricted by the permissions

00:16:13,089 --> 00:16:15,850
that are associated to the roof so if

00:16:15,069 --> 00:16:17,439
you saw earlier

00:16:15,850 --> 00:16:19,180
there's permissions each read has

00:16:17,439 --> 00:16:21,399
permissions part of those permissions

00:16:19,180 --> 00:16:22,809
can restrict access to the

00:16:21,399 --> 00:16:25,019
general-purpose non-volatile memory you

00:16:22,809 --> 00:16:27,790
can either give some or all or none

00:16:25,019 --> 00:16:30,699
permissions to a non-volatile memory for

00:16:27,790 --> 00:16:32,649
a given container associated to a with a

00:16:30,699 --> 00:16:36,660
given route and we'll get into more

00:16:32,649 --> 00:16:36,660
about how that works a little bit later

00:16:37,050 --> 00:16:43,000
the next really important part of this

00:16:39,670 --> 00:16:46,600
are the crypto engines from our standard

00:16:43,000 --> 00:16:50,639
offering we have an aes engine a shot to

00:16:46,600 --> 00:16:54,220
engine and a public key engine or PK e

00:16:50,639 --> 00:16:56,139
the aes core we have multiple versions

00:16:54,220 --> 00:16:57,699
available so as I earlier I mentioned we

00:16:56,139 --> 00:17:01,059
have differential power analysis

00:16:57,699 --> 00:17:04,360
resistant cores we have an AAS offering

00:17:01,059 --> 00:17:05,890
that it has DPA resistance we also have

00:17:04,360 --> 00:17:09,640
an offering that doesn't depending on

00:17:05,890 --> 00:17:11,439
what your size obviously we do DPA

00:17:09,640 --> 00:17:15,280
resistance the size and gate count

00:17:11,439 --> 00:17:18,760
increases similarly we have a DPA

00:17:15,280 --> 00:17:21,250
resistant hash core same thing with the

00:17:18,760 --> 00:17:23,740
AES core it only increases its size when

00:17:21,250 --> 00:17:27,549
you have DPA resistance the public key

00:17:23,740 --> 00:17:29,110
engine is DPA resistant out the door the

00:17:27,549 --> 00:17:32,500
key sizes will be support for AES or

00:17:29,110 --> 00:17:34,600
hundred twenty eight and 256 bits we

00:17:32,500 --> 00:17:37,530
don't have enough people who ask for 192

00:17:34,600 --> 00:17:40,059
bit although I guess we could if asked

00:17:37,530 --> 00:17:44,090
we have hardware direct hardware support

00:17:40,059 --> 00:17:46,400
for ECB CBC CFP counter

00:17:44,090 --> 00:17:50,180
Galois and I think a few others on top

00:17:46,400 --> 00:17:53,930
of this the shot two supports two to

00:17:50,180 --> 00:17:58,040
four to five six 384 or 512 the public

00:17:53,930 --> 00:18:01,520
key engine supports RSA standard and RSA

00:17:58,040 --> 00:18:05,840
Chinese Ranger theorem for one two three

00:18:01,520 --> 00:18:09,910
or four K sized keys we also support ECB

00:18:05,840 --> 00:18:15,530
H ECDSA for the NIST curves like P 256

00:18:09,910 --> 00:18:20,380
384 521 the IDI 255 1 9 and other curves

00:18:15,530 --> 00:18:20,380
are also available with the PK e engine

00:18:24,580 --> 00:18:30,430
so the the next core is another really

00:18:28,490 --> 00:18:32,720
important one is the key derivation core

00:18:30,430 --> 00:18:34,310
and it's responsible for deriving and

00:18:32,720 --> 00:18:35,990
managing keys

00:18:34,310 --> 00:18:38,330
it uses an is compliant key derivation

00:18:35,990 --> 00:18:39,890
algorithm to derive volatile keys from

00:18:38,330 --> 00:18:42,650
base keys so if you remember earlier I

00:18:39,890 --> 00:18:45,140
mentioned in the OTP we store a device

00:18:42,650 --> 00:18:47,690
unique key in OTP which is not exposed

00:18:45,140 --> 00:18:50,090
to the CPU that key can be delivered

00:18:47,690 --> 00:18:52,490
securely again without the CPU seeing it

00:18:50,090 --> 00:18:57,040
directly to the KDC the key gyration

00:18:52,490 --> 00:19:00,950
core and you can use that to generate

00:18:57,040 --> 00:19:02,870
volatile keys the same key over and over

00:19:00,950 --> 00:19:04,970
again but it's volatile in that you

00:19:02,870 --> 00:19:06,590
don't store it anyway so anywhere so

00:19:04,970 --> 00:19:08,270
that's I think actually a really good

00:19:06,590 --> 00:19:10,400
property is you don't have to store

00:19:08,270 --> 00:19:13,760
these keys anywhere you have one base

00:19:10,400 --> 00:19:15,260
key that is stored in secure OTP you can

00:19:13,760 --> 00:19:17,240
generate these keys on-the-fly it's the

00:19:15,260 --> 00:19:19,970
same key every time the other thing

00:19:17,240 --> 00:19:22,570
that's nice is that the part of the key

00:19:19,970 --> 00:19:26,120
derivation path where you derive the key

00:19:22,570 --> 00:19:27,440
is dependent upon what route the context

00:19:26,120 --> 00:19:30,770
of security context under what you're

00:19:27,440 --> 00:19:33,500
running so one route cannot create the

00:19:30,770 --> 00:19:35,060
same keys as another route except for

00:19:33,500 --> 00:19:38,180
collisions which are pretty rare right

00:19:35,060 --> 00:19:40,010
but so that's actually where the

00:19:38,180 --> 00:19:42,170
security part of the security context

00:19:40,010 --> 00:19:45,110
comes from is that one route can create

00:19:42,170 --> 00:19:47,060
an entire fleet of keys and another

00:19:45,110 --> 00:19:49,430
route can create another fleet of keys

00:19:47,060 --> 00:19:52,760
and the two shall never meet which is

00:19:49,430 --> 00:19:54,320
really nice they're great property again

00:19:52,760 --> 00:19:55,940
it operates independent of the CPU and

00:19:54,320 --> 00:19:56,900
can deliver keys to the harbor core so

00:19:55,940 --> 00:19:57,380
if you want to create a key and

00:19:56,900 --> 00:20:01,750
delivered

00:19:57,380 --> 00:20:03,620
to the AES engine that's supported

00:20:01,750 --> 00:20:05,270
similarly for the hash core you can

00:20:03,620 --> 00:20:14,480
deliver keys directly to the hash core

00:20:05,270 --> 00:20:17,890
to do H Mack operations other important

00:20:14,480 --> 00:20:21,950
cores that I think are interesting even

00:20:17,890 --> 00:20:23,840
specifically for your ecosystem are the

00:20:21,950 --> 00:20:26,510
key transport core which manages key

00:20:23,840 --> 00:20:28,250
interfaces outside the sea MRT boundary

00:20:26,510 --> 00:20:30,650
so you can use the key derivation core

00:20:28,250 --> 00:20:32,210
and your u device unique base key to

00:20:30,650 --> 00:20:34,670
create a key and then you can export

00:20:32,210 --> 00:20:35,930
that key to another hardware block that

00:20:34,670 --> 00:20:38,210
you have so if you have a proprietary

00:20:35,930 --> 00:20:40,760
Hardware block that does some particular

00:20:38,210 --> 00:20:42,110
crypto function if you want us to manage

00:20:40,760 --> 00:20:44,090
that key and deliver that key to that

00:20:42,110 --> 00:20:47,270
crypto block that's totally supported

00:20:44,090 --> 00:20:50,720
through this key transport core we have

00:20:47,270 --> 00:20:52,730
a Miss compliant trng and drbg I think

00:20:50,720 --> 00:20:56,420
it's yeah that that's actually it should

00:20:52,730 --> 00:20:59,060
be drbg I apologize and then we also

00:20:56,420 --> 00:21:01,760
have a DMA controller that allows for

00:20:59,060 --> 00:21:05,260
fast move and a bulk data to and from

00:21:01,760 --> 00:21:08,030
SRAM our internal SRAM crypto cores

00:21:05,260 --> 00:21:11,360
external memory etc so that gives you

00:21:08,030 --> 00:21:17,210
some extra speed boost for doing some of

00:21:11,360 --> 00:21:21,740
these algorithms okay so the the next

00:21:17,210 --> 00:21:23,540
topic is CMR T software so hopefully you

00:21:21,740 --> 00:21:25,040
saw from the previous slides we talked

00:21:23,540 --> 00:21:28,160
about the hardware where we kind of from

00:21:25,040 --> 00:21:31,340
the ground the CPU and NPU we try and

00:21:28,160 --> 00:21:35,690
build up the security of a system secure

00:21:31,340 --> 00:21:37,280
non-volatile memory we are trying to do

00:21:35,690 --> 00:21:39,640
the same thing with a software stack as

00:21:37,280 --> 00:21:45,740
well where we start from the ground up

00:21:39,640 --> 00:21:47,900
build security from the ground up so the

00:21:45,740 --> 00:21:53,120
software stack so what you see over here

00:21:47,900 --> 00:21:54,800
on over here is a again simplified

00:21:53,120 --> 00:21:58,460
diagram of the software stack what

00:21:54,800 --> 00:22:00,980
components are available and again we

00:21:58,460 --> 00:22:04,160
have support for three privileged levels

00:22:00,980 --> 00:22:06,950
of execution and we utilize all three

00:22:04,160 --> 00:22:10,070
not only during boot but also during

00:22:06,950 --> 00:22:13,690
runtime we utilize all three so in

00:22:10,070 --> 00:22:17,840
userspace obviously the containers are

00:22:13,690 --> 00:22:19,670
executing and in user space in

00:22:17,840 --> 00:22:22,690
supervisor we have an operating system

00:22:19,670 --> 00:22:25,430
we use the zephyr operating system and

00:22:22,690 --> 00:22:28,520
we also have related hardware drivers

00:22:25,430 --> 00:22:31,490
that are inside the supervisor privilege

00:22:28,520 --> 00:22:33,680
and then in machine we have our most

00:22:31,490 --> 00:22:36,410
security sensitive code that executes in

00:22:33,680 --> 00:22:38,930
the machine privilege and we also have

00:22:36,410 --> 00:22:41,510
our internal secure boot so the code

00:22:38,930 --> 00:22:46,580
that is responsible for securely booting

00:22:41,510 --> 00:22:53,870
the CM RT is is located in machine

00:22:46,580 --> 00:22:56,510
privilege as well so the first component

00:22:53,870 --> 00:22:59,720
to call out here that's located in the

00:22:56,510 --> 00:23:02,870
machine privilege is our first stage

00:22:59,720 --> 00:23:07,430
bootloader it's located in read-only

00:23:02,870 --> 00:23:11,420
memory so it's it's immutable it begins

00:23:07,430 --> 00:23:14,630
the secure boot of our cm RT since the

00:23:11,420 --> 00:23:16,610
first stage bootloader is immutable a

00:23:14,630 --> 00:23:19,670
chain of trust is built from that

00:23:16,610 --> 00:23:23,600
read-only memory through images that we

00:23:19,670 --> 00:23:25,550
have stored in OTP and in flash the

00:23:23,600 --> 00:23:28,490
image that we have stored in OTP is

00:23:25,550 --> 00:23:31,490
primarily to augment the behavior of the

00:23:28,490 --> 00:23:35,030
first stage bootloader which is again in

00:23:31,490 --> 00:23:36,830
ROM which is typically not built for a

00:23:35,030 --> 00:23:38,570
particular platform any platform

00:23:36,830 --> 00:23:41,750
specific extensions are just put into

00:23:38,570 --> 00:23:44,210
OTP and again augment the behavior of

00:23:41,750 --> 00:23:48,910
the first stage bootloader again since

00:23:44,210 --> 00:23:52,310
it's an OTP it's effectively immutable

00:23:48,910 --> 00:23:54,410
so in addition to that to note here we

00:23:52,310 --> 00:23:56,450
have a subset of the system's device

00:23:54,410 --> 00:23:58,730
drivers that are included with the

00:23:56,450 --> 00:24:03,050
bootloader so for instance if we have to

00:23:58,730 --> 00:24:04,790
check a ECDSA signature of an image that

00:24:03,050 --> 00:24:08,330
we're loading from some external flash

00:24:04,790 --> 00:24:11,780
resource into our Ram we need a hash

00:24:08,330 --> 00:24:18,350
core to do the sha-256 hash and if it's

00:24:11,780 --> 00:24:19,830
a PK a P 256 ECDSA signature then we

00:24:18,350 --> 00:24:22,320
need our PK e there of

00:24:19,830 --> 00:24:24,029
as well so we have a sub again a subset

00:24:22,320 --> 00:24:34,110
of the device drivers that are in the

00:24:24,029 --> 00:24:37,890
machine privilege as well so it's funny

00:24:34,110 --> 00:24:39,990
how I rigged the hardware engineers

00:24:37,890 --> 00:24:42,330
about naming things well we have uh

00:24:39,990 --> 00:24:45,809
something called a security monitor in

00:24:42,330 --> 00:24:48,960
our software stack which I believe the

00:24:45,809 --> 00:24:51,600
Microsoft folks have in there is there a

00:24:48,960 --> 00:24:55,289
sphere ecosystem as well

00:24:51,600 --> 00:24:57,149
our security monitor operates in the

00:24:55,289 --> 00:24:59,730
machine privilege and that's where our

00:24:57,149 --> 00:25:02,490
most security sensitive code is stored

00:24:59,730 --> 00:25:04,559
and it's stored typically in a trusted

00:25:02,490 --> 00:25:07,440
flash image that flashes external to the

00:25:04,559 --> 00:25:10,980
C MRT so we will load that image into

00:25:07,440 --> 00:25:15,240
our RAM at runtime verify its signature

00:25:10,980 --> 00:25:16,830
and then allow it to do its work so just

00:25:15,240 --> 00:25:18,779
to give you an idea of one of the one of

00:25:16,830 --> 00:25:21,000
the operations that the security monitor

00:25:18,779 --> 00:25:23,429
manages for us is that when a user

00:25:21,000 --> 00:25:25,169
container is loaded by the C MRT and the

00:25:23,429 --> 00:25:26,519
supervisor actually manages the loading

00:25:25,169 --> 00:25:28,830
force then the supervisor makes a

00:25:26,519 --> 00:25:32,850
request up to the security monitor to

00:25:28,830 --> 00:25:34,889
verify one what route owns this user

00:25:32,850 --> 00:25:36,840
what context under which will this what

00:25:34,889 --> 00:25:40,559
route context under which will this

00:25:36,840 --> 00:25:42,450
container actually execute and we'll get

00:25:40,559 --> 00:25:44,460
into how that how that's managed here

00:25:42,450 --> 00:25:48,210
shortly but it doesn't look up into the

00:25:44,460 --> 00:25:50,820
OTP to verify that that this container

00:25:48,210 --> 00:25:53,519
actually belongs inside this particular

00:25:50,820 --> 00:25:55,019
C MRT next it verifies the digital

00:25:53,519 --> 00:25:56,460
signature of the container code you know

00:25:55,019 --> 00:25:57,120
hashes the code and then verifies that

00:25:56,460 --> 00:26:00,990
signature

00:25:57,120 --> 00:26:02,490
using the pke it verifies the

00:26:00,990 --> 00:26:05,880
permissions so each container can

00:26:02,490 --> 00:26:09,450
request certain permissions those

00:26:05,880 --> 00:26:12,360
permissions though must be a subset or

00:26:09,450 --> 00:26:14,580
less than or equal to the permissions

00:26:12,360 --> 00:26:16,590
that are stored in the OTP table for

00:26:14,580 --> 00:26:18,360
that particular route and then it

00:26:16,590 --> 00:26:20,340
applies Hardware permissions to

00:26:18,360 --> 00:26:22,889
respective cores so software software

00:26:20,340 --> 00:26:24,389
doesn't actually manage most of the

00:26:22,889 --> 00:26:27,450
permissions we do have some software

00:26:24,389 --> 00:26:28,770
permissions but most of the permissions

00:26:27,450 --> 00:26:30,360
are actually managed by Hardware

00:26:28,770 --> 00:26:32,309
themselves so if you remember earlier

00:26:30,360 --> 00:26:32,990
when I mentioned that you can restrict

00:26:32,309 --> 00:26:38,090
address

00:26:32,990 --> 00:26:40,730
access to OTP that's actually managed by

00:26:38,090 --> 00:26:44,270
the OTP management controller itself not

00:26:40,730 --> 00:26:46,640
by software we we load in what address

00:26:44,270 --> 00:26:51,290
ranges are acceptable

00:26:46,640 --> 00:26:52,970
what fixed areas such as like lifecycle

00:26:51,290 --> 00:26:54,350
does this container have access to life

00:26:52,970 --> 00:26:56,900
cycle does this container have access to

00:26:54,350 --> 00:26:58,490
device ID those kinds of things are all

00:26:56,900 --> 00:27:00,800
part of the permissions model and

00:26:58,490 --> 00:27:05,809
Hardware enforced permissions not

00:27:00,800 --> 00:27:08,230
software enforce permissions and that's

00:27:05,809 --> 00:27:10,520
that's an important point to make here

00:27:08,230 --> 00:27:12,980
the other thing that the security

00:27:10,520 --> 00:27:17,630
monitor does is it also handles route

00:27:12,980 --> 00:27:19,580
management what that means is if in the

00:27:17,630 --> 00:27:22,130
field you want to create a new route for

00:27:19,580 --> 00:27:25,220
some other application to be able to

00:27:22,130 --> 00:27:27,350
execute inside the CMR T if the

00:27:25,220 --> 00:27:28,970
container that's executing actually has

00:27:27,350 --> 00:27:31,340
permissions to do so you can create that

00:27:28,970 --> 00:27:34,880
new route and add another route to the

00:27:31,340 --> 00:27:36,170
OTP table if you want to delete a route

00:27:34,880 --> 00:27:38,120
you actually can't delete it because

00:27:36,170 --> 00:27:40,340
it's an OTP but you can obliterate that

00:27:38,120 --> 00:27:42,800
route but effectively just writing all

00:27:40,340 --> 00:27:44,570
of the zeros to ones and that that route

00:27:42,800 --> 00:27:47,000
is then invalidated that that at that

00:27:44,570 --> 00:27:48,559
point and that code is then again as I

00:27:47,000 --> 00:27:55,820
said managed here in the security

00:27:48,559 --> 00:27:59,240
monitor so at the supervisor operating

00:27:55,820 --> 00:28:01,220
system layer where is where we have a

00:27:59,240 --> 00:28:02,929
modified version of the zephyr operating

00:28:01,220 --> 00:28:06,559
system

00:28:02,929 --> 00:28:08,330
it supports application loading so so we

00:28:06,559 --> 00:28:10,790
have the operating system which is

00:28:08,330 --> 00:28:14,360
effectively in SRAM you can load at

00:28:10,790 --> 00:28:16,340
runtime you can request a loading of a

00:28:14,360 --> 00:28:18,559
container at runtime which is our

00:28:16,340 --> 00:28:20,630
application so we have a runtime

00:28:18,559 --> 00:28:24,530
application loader that's available

00:28:20,630 --> 00:28:25,970
that's a part of the supervisor image we

00:28:24,530 --> 00:28:30,080
have complete kernel user memory

00:28:25,970 --> 00:28:31,790
separation which is wasn't available on

00:28:30,080 --> 00:28:33,500
risk 5 when we started this project I'm

00:28:31,790 --> 00:28:38,090
not sure if it's available yet on the

00:28:33,500 --> 00:28:40,670
mainline we have a unix linux like

00:28:38,090 --> 00:28:45,650
device driver interface with open closed

00:28:40,670 --> 00:28:46,950
eye octal now all of our modifications

00:28:45,650 --> 00:28:49,230
are controlled by K config

00:28:46,950 --> 00:28:52,799
and most of these will eventually be up

00:28:49,230 --> 00:28:55,859
streamed I believe I'm not sure what the

00:28:52,799 --> 00:28:57,960
timetable is for our up streaming but

00:28:55,859 --> 00:29:04,649
you can you can talk to us later about

00:28:57,960 --> 00:29:06,239
about our plans for that the the other

00:29:04,649 --> 00:29:08,879
features of the operating system are

00:29:06,239 --> 00:29:10,529
that it provides a containers access to

00:29:08,879 --> 00:29:12,659
hardware course so user containers have

00:29:10,529 --> 00:29:14,609
no access to hardware they're

00:29:12,659 --> 00:29:16,440
effectively sandboxed in a way that they

00:29:14,609 --> 00:29:18,749
do not have access to any hardware at

00:29:16,440 --> 00:29:21,690
all and all access must go through these

00:29:18,749 --> 00:29:25,470
device driver interfaces so again you

00:29:21,690 --> 00:29:27,809
use open closed and I out control to get

00:29:25,470 --> 00:29:29,850
access to if you want to do IES you have

00:29:27,809 --> 00:29:33,029
to open up an instance to the AES device

00:29:29,850 --> 00:29:36,029
driver and then you use IO control

00:29:33,029 --> 00:29:38,879
read/write and other system calls

00:29:36,029 --> 00:29:42,809
effectively to to gain access to the AES

00:29:38,879 --> 00:29:45,779
hardware the other thing is the

00:29:42,809 --> 00:29:47,519
operating system here is also the first

00:29:45,779 --> 00:29:49,049
line of perfect permissions enforcement

00:29:47,519 --> 00:29:52,169
so on the previous slide I mentioned

00:29:49,049 --> 00:29:54,720
that hardware is our backstop for all

00:29:52,169 --> 00:29:56,190
permissions enforcement but we also do

00:29:54,720 --> 00:29:58,139
checks here so if you're really not

00:29:56,190 --> 00:30:00,869
allowed to access a particular region of

00:29:58,139 --> 00:30:03,179
OTP for example we'll stop you here but

00:30:00,869 --> 00:30:04,769
if for some reason that check fails we

00:30:03,179 --> 00:30:06,960
always have the hardware as a backstop

00:30:04,769 --> 00:30:15,239
so we do we do it here and then we also

00:30:06,960 --> 00:30:20,639
do it in the in the hardware as well the

00:30:15,239 --> 00:30:24,330
the last bit of the software stack here

00:30:20,639 --> 00:30:27,779
are the containers again our containers

00:30:24,330 --> 00:30:29,639
are customer developed applications so

00:30:27,779 --> 00:30:31,169
they would be developed by anyone here

00:30:29,639 --> 00:30:37,489
in this room who's capable of writing a

00:30:31,169 --> 00:30:37,489
C program it's just straight C we have

00:30:38,330 --> 00:30:43,289
libraries that I mentioned here that are

00:30:41,609 --> 00:30:46,259
available as well to help in the

00:30:43,289 --> 00:30:48,749
development of these applications each

00:30:46,259 --> 00:30:51,029
container is signed with a private key

00:30:48,749 --> 00:30:53,429
that is associated with a specific route

00:30:51,029 --> 00:30:55,739
and the next slide I'll get into the

00:30:53,429 --> 00:30:58,019
details of how containers are actually

00:30:55,739 --> 00:30:59,700
built and created but just know that

00:30:58,019 --> 00:31:02,580
they have to be signed

00:30:59,700 --> 00:31:04,679
and that the the key that is used to

00:31:02,580 --> 00:31:07,020
sign it is actually somehow attached to

00:31:04,679 --> 00:31:10,770
a specific route again that route must

00:31:07,020 --> 00:31:12,510
be found inside the OTP table containers

00:31:10,770 --> 00:31:15,049
have associated permissions that control

00:31:12,510 --> 00:31:17,640
access to keys and hardware resources

00:31:15,049 --> 00:31:19,470
permissions are also limited in hardware

00:31:17,640 --> 00:31:20,880
to those available to the route

00:31:19,470 --> 00:31:22,650
associated with the container so again

00:31:20,880 --> 00:31:24,750
you have root permissions and then you

00:31:22,650 --> 00:31:28,290
have container permissions the container

00:31:24,750 --> 00:31:30,299
has a subset of its root it has subset

00:31:28,290 --> 00:31:32,730
permission of permissions for its

00:31:30,299 --> 00:31:36,200
particular route if for example if it

00:31:32,730 --> 00:31:38,790
requests an area of OTP that is not

00:31:36,200 --> 00:31:40,410
associated with its route so its route

00:31:38,790 --> 00:31:42,360
does not have permissions to access that

00:31:40,410 --> 00:31:43,830
area that container will be rejected

00:31:42,360 --> 00:31:46,530
it's actually rejected and we wipe it

00:31:43,830 --> 00:31:49,470
out of SRAM you're not allowed to

00:31:46,530 --> 00:31:52,950
request assets that your route does not

00:31:49,470 --> 00:31:54,900
have and finally we have the libraries

00:31:52,950 --> 00:31:58,799
here that are attached to the container

00:31:54,900 --> 00:32:02,280
we have a C runtime gives you your mmmm

00:31:58,799 --> 00:32:05,490
set and we also have a global platform

00:32:02,280 --> 00:32:06,720
te compliant crypto library so as I

00:32:05,490 --> 00:32:08,700
mentioned earlier if you want to get

00:32:06,720 --> 00:32:13,669
access to the AES Hardware you can do

00:32:08,700 --> 00:32:16,230
the open and then the IO controls etc or

00:32:13,669 --> 00:32:19,740
we do all of that work for you we wrap

00:32:16,230 --> 00:32:21,900
those in a again a GP te compliant

00:32:19,740 --> 00:32:24,900
crypto library that's available to

00:32:21,900 --> 00:32:31,309
developers who are writing container

00:32:24,900 --> 00:32:34,470
applications so this is a very busy

00:32:31,309 --> 00:32:36,600
diagram it's gonna get busier here but

00:32:34,470 --> 00:32:37,980
the the first thing is well where does

00:32:36,600 --> 00:32:39,809
all of this come from I mean where do

00:32:37,980 --> 00:32:41,610
root permissions come from why how do

00:32:39,809 --> 00:32:44,700
you how do you associate those things so

00:32:41,610 --> 00:32:48,690
typically root permissions start with

00:32:44,700 --> 00:32:51,270
the SOC manufacturer so you know see how

00:32:48,690 --> 00:32:53,880
the CM RT is embedded in a system on a

00:32:51,270 --> 00:32:55,740
chip that system on a chip manufacturer

00:32:53,880 --> 00:32:58,440
probably created a route during

00:32:55,740 --> 00:33:01,410
manufacturing and sets up the initial

00:32:58,440 --> 00:33:03,419
permissions if you have an agreement

00:33:01,410 --> 00:33:05,669
with that SOC manufacturer they may also

00:33:03,419 --> 00:33:08,400
program your route with your associated

00:33:05,669 --> 00:33:12,220
permissions your Associated permissions

00:33:08,400 --> 00:33:14,440
are probably something that you would

00:33:12,220 --> 00:33:15,730
work with the soc manufacturer and if

00:33:14,440 --> 00:33:19,330
you're the soc manufacturer of course

00:33:15,730 --> 00:33:20,620
you can do whatever you want so that's

00:33:19,330 --> 00:33:22,660
where the root permissions come from

00:33:20,620 --> 00:33:25,180
they're just it's just a file that

00:33:22,660 --> 00:33:28,000
describes what access this particular

00:33:25,180 --> 00:33:30,460
route will have and any container that

00:33:28,000 --> 00:33:33,250
runs in the context of this route will

00:33:30,460 --> 00:33:36,480
hat will adapt adopt those permissions

00:33:33,250 --> 00:33:41,050
as well or a subset of those permissions

00:33:36,480 --> 00:33:43,210
so how do we how do we get this into the

00:33:41,050 --> 00:33:44,590
part and how do we create this

00:33:43,210 --> 00:33:46,030
association so we have down here a

00:33:44,590 --> 00:33:47,920
hardware security module then as a

00:33:46,030 --> 00:33:49,300
public and private key inside of it and

00:33:47,920 --> 00:33:52,270
remember I mentioned earlier that a

00:33:49,300 --> 00:33:53,470
private key is used to sign container

00:33:52,270 --> 00:33:54,820
images well what do you do with the

00:33:53,470 --> 00:33:57,820
public key well the public key you

00:33:54,820 --> 00:34:00,580
export from the HSM you calculate the

00:33:57,820 --> 00:34:03,580
sha-256 fingerprint or hash digest of

00:34:00,580 --> 00:34:06,010
that public key you attach that to the

00:34:03,580 --> 00:34:10,030
permissions and program it to the OTP

00:34:06,010 --> 00:34:13,360
and that's how a root is founded inside

00:34:10,030 --> 00:34:15,970
the CMR T again this typically occurs

00:34:13,360 --> 00:34:18,010
during manufacturing personalization as

00:34:15,970 --> 00:34:19,390
I mentioned earlier if you have a

00:34:18,010 --> 00:34:22,120
container that has the proper

00:34:19,390 --> 00:34:24,820
permissions that containers later in

00:34:22,120 --> 00:34:26,440
life can also create new routes and

00:34:24,820 --> 00:34:33,669
program those routes through the exact

00:34:26,440 --> 00:34:35,590
same process okay so how do you build a

00:34:33,669 --> 00:34:39,040
container well again it's just it's C

00:34:35,590 --> 00:34:41,919
code so and you we you just use a risk v

00:34:39,040 --> 00:34:44,950
compiler it's in compile that into a

00:34:41,919 --> 00:34:48,340
binary where your text and data is

00:34:44,950 --> 00:34:52,000
located here on the right hand side of

00:34:48,340 --> 00:34:56,320
the diagram here so you have just your

00:34:52,000 --> 00:34:58,420
binary sitting here you take the routes

00:34:56,320 --> 00:35:00,130
permissions and then you determine as

00:34:58,420 --> 00:35:03,610
the developer's developer can create a

00:35:00,130 --> 00:35:05,470
subset of these although a bunch of a

00:35:03,610 --> 00:35:06,820
bunch of we'll just go I'll just take

00:35:05,470 --> 00:35:08,590
the permissions and program them that's

00:35:06,820 --> 00:35:10,990
not really good design should be using

00:35:08,590 --> 00:35:12,550
the principle of least privilege to set

00:35:10,990 --> 00:35:15,040
your container permissions to what this

00:35:12,550 --> 00:35:17,680
code is actually doing so if you don't

00:35:15,040 --> 00:35:21,880
need access to OTP then you should say

00:35:17,680 --> 00:35:23,170
in here and no access to OTP so you

00:35:21,880 --> 00:35:25,930
build the you build your container

00:35:23,170 --> 00:35:29,290
binary you attach to it a container

00:35:25,930 --> 00:35:32,349
and the request of permissions that you

00:35:29,290 --> 00:35:35,140
did through here we take this entire

00:35:32,349 --> 00:35:38,589
object send it over to our hardware

00:35:35,140 --> 00:35:40,960
security module we hash it we sign it

00:35:38,589 --> 00:35:43,089
with this private key and then we attach

00:35:40,960 --> 00:35:47,260
the signature the resulting signature

00:35:43,089 --> 00:35:49,450
here and this public key to create the

00:35:47,260 --> 00:35:52,390
entire container image so the container

00:35:49,450 --> 00:35:54,520
image again has the binary an ID the

00:35:52,390 --> 00:35:57,760
request of permissions a signature of

00:35:54,520 --> 00:36:00,550
everything above here and we attach the

00:35:57,760 --> 00:36:04,210
public key to the image and now that is

00:36:00,550 --> 00:36:09,030
a container image so now what do you do

00:36:04,210 --> 00:36:14,290
I don't know let's see so now you can

00:36:09,030 --> 00:36:17,140
load this entire image into the SRAM of

00:36:14,290 --> 00:36:22,089
the CMR T we have mechanisms that

00:36:17,140 --> 00:36:23,980
facilitate that process so you load this

00:36:22,089 --> 00:36:26,190
into SRAM and at this point as I

00:36:23,980 --> 00:36:29,319
mentioned earlier the security monitor

00:36:26,190 --> 00:36:32,680
first determines if this containers

00:36:29,319 --> 00:36:34,720
public key matches an existing route so

00:36:32,680 --> 00:36:37,270
again we just do a shock 256 of this

00:36:34,720 --> 00:36:39,819
this what's attached to this blob here

00:36:37,270 --> 00:36:43,150
we to the shot 256 of this object here

00:36:39,819 --> 00:36:46,000
we look in the OTP does it match any ID

00:36:43,150 --> 00:36:48,579
any resulting ID if not we kick the

00:36:46,000 --> 00:36:51,010
thing out if it does then we go further

00:36:48,579 --> 00:36:54,760
so the next step is now we're going to

00:36:51,010 --> 00:36:56,710
do the hash sha-256 of this information

00:36:54,760 --> 00:36:58,630
here I'm going to use this public key

00:36:56,710 --> 00:37:00,900
the signature and the hash of this

00:36:58,630 --> 00:37:03,790
information will validate that signature

00:37:00,900 --> 00:37:07,150
if that's good we go on to the next we

00:37:03,790 --> 00:37:08,650
evaluate the permissions the requested

00:37:07,150 --> 00:37:10,510
permissions we've now validated that

00:37:08,650 --> 00:37:12,040
they were signed by a trusted entity

00:37:10,510 --> 00:37:15,040
right so now we can now we can check to

00:37:12,040 --> 00:37:18,430
see are the requested permissions within

00:37:15,040 --> 00:37:20,140
the bounds of this route again which is

00:37:18,430 --> 00:37:22,390
again stored in OTP so remember we

00:37:20,140 --> 00:37:24,160
programmed this information into OTP we

00:37:22,390 --> 00:37:26,109
check to see if it's within bounds if

00:37:24,160 --> 00:37:28,510
it's outside the bounds of the requester

00:37:26,109 --> 00:37:31,270
permissions we kick it out if it's

00:37:28,510 --> 00:37:33,670
inside the bounds we're going to then

00:37:31,270 --> 00:37:37,000
apply those permissions to the

00:37:33,670 --> 00:37:38,950
respective hardware cores and now your

00:37:37,000 --> 00:37:39,670
container can execute again if your

00:37:38,950 --> 00:37:42,130
container

00:37:39,670 --> 00:37:44,109
Qwest do something at runtime that's

00:37:42,130 --> 00:37:46,990
outside its requested permissions or

00:37:44,109 --> 00:37:53,440
obviously the routes permissions again

00:37:46,990 --> 00:37:54,910
it gets kicked out so I just wanted to

00:37:53,440 --> 00:37:56,470
have a slat in here to talk a little bit

00:37:54,910 --> 00:38:00,880
about why did we select the zephyr

00:37:56,470 --> 00:38:04,720
operating system as our the microkernel

00:38:00,880 --> 00:38:06,910
that we use inside the CM RT the first

00:38:04,720 --> 00:38:08,230
and most important thing because if it

00:38:06,910 --> 00:38:10,480
didn't exist we it wouldn't have even

00:38:08,230 --> 00:38:12,549
been part of our selection process we

00:38:10,480 --> 00:38:15,700
had several micro kernels that we looked

00:38:12,549 --> 00:38:17,319
at it has an existing risk v port if it

00:38:15,700 --> 00:38:19,299
didn't have if a microkernel didn't have

00:38:17,319 --> 00:38:21,609
an existing risk raft port we we did

00:38:19,299 --> 00:38:23,589
really didn't look at it the other thing

00:38:21,609 --> 00:38:26,710
is that it's it is a Linux Foundation

00:38:23,589 --> 00:38:28,869
project and I'm not trying to kiss Rand

00:38:26,710 --> 00:38:30,160
or anything like that but it does

00:38:28,869 --> 00:38:31,359
include a formal governing board

00:38:30,160 --> 00:38:33,130
technical steering committee and a

00:38:31,359 --> 00:38:34,510
Security Committee all of those things

00:38:33,130 --> 00:38:36,549
actually were really important to us as

00:38:34,510 --> 00:38:38,020
part of the selection criteria the other

00:38:36,549 --> 00:38:40,930
thing is that the Zephyr ecosystem is

00:38:38,020 --> 00:38:42,819
actually quite nice we were quite

00:38:40,930 --> 00:38:45,549
impressed by the large active number of

00:38:42,819 --> 00:38:49,750
contributors proper quality assurance

00:38:45,549 --> 00:38:53,049
and CIO were already in place at the

00:38:49,750 --> 00:38:55,170
time of a selecting Zephyr there were

00:38:53,049 --> 00:38:58,240
great community guidelines and

00:38:55,170 --> 00:39:00,790
contribution reviews as things were

00:38:58,240 --> 00:39:03,670
being pulled in and one thing to note is

00:39:00,790 --> 00:39:06,400
a side benefit of using Zephyr is that

00:39:03,670 --> 00:39:09,160
all of our software is built using the

00:39:06,400 --> 00:39:11,349
flexible Zephyr build system so our boot

00:39:09,160 --> 00:39:13,390
loaders the security monitor image our

00:39:11,349 --> 00:39:15,490
operating system kernel and all

00:39:13,390 --> 00:39:18,069
containers are actually built using the

00:39:15,490 --> 00:39:21,609
Zephyr build system so this this was

00:39:18,069 --> 00:39:24,849
actually a huge time-saver by selecting

00:39:21,609 --> 00:39:25,780
Zephyr so it was actually I highly

00:39:24,849 --> 00:39:34,750
recommend if you're looking for a

00:39:25,780 --> 00:39:37,869
microkernel look closely at Zephyr so ok

00:39:34,750 --> 00:39:41,079
so why are you all here ok it's about

00:39:37,869 --> 00:39:44,680
Linux applications right so on all the

00:39:41,079 --> 00:39:46,210
previous slides I have been talking

00:39:44,680 --> 00:39:48,160
about a robust general-purpose

00:39:46,210 --> 00:39:51,700
programmable secure processing

00:39:48,160 --> 00:39:53,260
environment so the sea MRT can be

00:39:51,700 --> 00:39:56,350
obviously integrated into your

00:39:53,260 --> 00:39:58,060
platforms SOC but once that's there and

00:39:56,350 --> 00:39:59,500
once it's integrated into your SOC what

00:39:58,060 --> 00:40:02,590
do you do with it you know where do you

00:39:59,500 --> 00:40:04,420
go with it so the following slides are

00:40:02,590 --> 00:40:07,630
an attempt to answer this question but

00:40:04,420 --> 00:40:09,760
really what this is is I'm were Rambis

00:40:07,630 --> 00:40:11,830
cryptography research we're looking for

00:40:09,760 --> 00:40:16,330
input from the Linux security community

00:40:11,830 --> 00:40:18,880
at large any any applications or

00:40:16,330 --> 00:40:20,650
anything that you could see for using

00:40:18,880 --> 00:40:22,180
the CMR T we're looking for feedback

00:40:20,650 --> 00:40:25,600
from you because I know we're presenting

00:40:22,180 --> 00:40:28,690
this as our our offering to help solve a

00:40:25,600 --> 00:40:31,300
lot of problems in security in the wild

00:40:28,690 --> 00:40:34,240
today and so but we want some feedback

00:40:31,300 --> 00:40:37,900
from you folks to try to figure out what

00:40:34,240 --> 00:40:41,350
we can do further with this so the first

00:40:37,900 --> 00:40:45,670
thing to note is we have a CRT a Linux

00:40:41,350 --> 00:40:47,650
software development kit the SDK

00:40:45,670 --> 00:40:50,230
provides a full container development

00:40:47,650 --> 00:40:51,970
environment we have an out of tree

00:40:50,230 --> 00:40:53,080
reference kernel module implementation

00:40:51,970 --> 00:40:56,230
I'll talk a little bit more about that

00:40:53,080 --> 00:40:59,680
in the next slide we have the risk for a

00:40:56,230 --> 00:41:02,830
GC seven suite that is part of our SDK

00:40:59,680 --> 00:41:04,900
and we have a qmu emulator for fast

00:41:02,830 --> 00:41:06,490
container development it enables

00:41:04,900 --> 00:41:09,220
development prior to the hardware being

00:41:06,490 --> 00:41:12,430
available it's easier to use in debug

00:41:09,220 --> 00:41:13,870
than FPGAs in general and the other

00:41:12,430 --> 00:41:15,400
thing is it's easier to scale your

00:41:13,870 --> 00:41:17,830
continuous integration environment

00:41:15,400 --> 00:41:19,930
rather than having a farm of FPGAs there

00:41:17,830 --> 00:41:22,060
that are running your containers that

00:41:19,930 --> 00:41:26,410
you developed you can have just a whole

00:41:22,060 --> 00:41:27,820
bunch of cores running qmu and executing

00:41:26,410 --> 00:41:31,060
your containers and getting test results

00:41:27,820 --> 00:41:32,740
off of that so that's another great and

00:41:31,060 --> 00:41:35,590
actually we use that ourselves

00:41:32,740 --> 00:41:37,540
we use the qmu environment ourselves for

00:41:35,590 --> 00:41:40,810
a substantial amount of our CI we also

00:41:37,540 --> 00:41:41,860
have FPGAs that do a lot of work too

00:41:40,810 --> 00:41:44,530
we have a reference implementation

00:41:41,860 --> 00:41:49,300
available in the Xilinx Zink 7000

00:41:44,530 --> 00:41:52,950
evaluation board and we have a linux

00:41:49,300 --> 00:41:56,800
image that runs on the zhiling Zink 7000

00:41:52,950 --> 00:41:59,380
and then you instantiate the CM RT and

00:41:56,800 --> 00:42:01,960
the FPGA fabric and from there you can

00:41:59,380 --> 00:42:07,490
begin testing out your containers that

00:42:01,960 --> 00:42:09,990
you you've developed from there

00:42:07,490 --> 00:42:13,050
so some notes about the sea MRT device

00:42:09,990 --> 00:42:16,050
forever that we have we have the

00:42:13,050 --> 00:42:17,880
reference Linux device driver which

00:42:16,050 --> 00:42:20,250
loads and unloads trusted containers for

00:42:17,880 --> 00:42:22,710
you provides an interface for user space

00:42:20,250 --> 00:42:24,060
applications to reach the sea MRT so

00:42:22,710 --> 00:42:26,130
basically the applications that you have

00:42:24,060 --> 00:42:27,480
using this reference driver is only

00:42:26,130 --> 00:42:28,410
limited by your imagination you can

00:42:27,480 --> 00:42:31,710
pretty much do anything that you want

00:42:28,410 --> 00:42:32,520
with it you know but you also have to

00:42:31,710 --> 00:42:35,010
have make sure that you have available

00:42:32,520 --> 00:42:37,260
cm RTS RAM for your container that

00:42:35,010 --> 00:42:39,780
executes but one thing to note is that

00:42:37,260 --> 00:42:41,790
we have mechanisms available to chain cm

00:42:39,780 --> 00:42:43,140
RT containers together to get around

00:42:41,790 --> 00:42:46,950
these city market so you can have a

00:42:43,140 --> 00:42:48,360
computation stored away securely so that

00:42:46,950 --> 00:42:51,119
another container later can pick it up

00:42:48,360 --> 00:42:54,500
and and begin using it for to chain

00:42:51,119 --> 00:42:58,470
things together we have that available

00:42:54,500 --> 00:43:00,750
so here other things that we are

00:42:58,470 --> 00:43:03,030
actually actively looking into doing

00:43:00,750 --> 00:43:04,350
with the CM RT just and we're also

00:43:03,030 --> 00:43:08,100
gauging again if there is any interest

00:43:04,350 --> 00:43:10,080
in this is creating a Linux crypto

00:43:08,100 --> 00:43:11,609
engine module which would be similar to

00:43:10,080 --> 00:43:14,100
the examples that you find on the Linux

00:43:11,609 --> 00:43:16,200
tree at drivers crypto requires a

00:43:14,100 --> 00:43:18,420
general-purpose crypto container with a

00:43:16,200 --> 00:43:21,540
compliant interface that would plug in

00:43:18,420 --> 00:43:23,730
underneath there another thing that

00:43:21,540 --> 00:43:26,100
we're actively looking into right now is

00:43:23,730 --> 00:43:28,530
trusted platform module emulation either

00:43:26,100 --> 00:43:30,000
1.2 or 2.0 which again it would be

00:43:28,530 --> 00:43:34,290
similar to the examples as you find in

00:43:30,000 --> 00:43:36,090
drivers chart TPM it reduces the need

00:43:34,290 --> 00:43:38,100
for an extra part on the PCB so I think

00:43:36,090 --> 00:43:39,570
this is this actually excites me more

00:43:38,100 --> 00:43:42,030
than anything is that if we could reduce

00:43:39,570 --> 00:43:45,060
and get rid of a part on the PCB and

00:43:42,030 --> 00:43:48,690
traces on the PCB and and alleviate that

00:43:45,060 --> 00:43:50,400
area and move it into the SOC inside our

00:43:48,690 --> 00:43:53,520
core I think that's actually an

00:43:50,400 --> 00:43:56,090
interesting use case again it requires a

00:43:53,520 --> 00:43:58,200
container that exposes the TPM interface

00:43:56,090 --> 00:43:59,190
again these are things that we're

00:43:58,200 --> 00:44:00,720
looking at but we're looking for

00:43:59,190 --> 00:44:02,220
feedback from you folks to see whether

00:44:00,720 --> 00:44:03,900
or not these are these are things that

00:44:02,220 --> 00:44:06,540
would actually excite your interest you

00:44:03,900 --> 00:44:10,490
or interest you enough to to integrate

00:44:06,540 --> 00:44:15,080
the CM RT on your particular platform

00:44:10,490 --> 00:44:15,080
okay I don't have any time left or not

00:44:15,930 --> 00:44:26,700
out of time okay so if if you have any

00:44:18,840 --> 00:44:29,640
questions one question okay thanks for

00:44:26,700 --> 00:44:32,670
the talk so you provide the hardware

00:44:29,640 --> 00:44:34,470
solution and do you have defenses

00:44:32,670 --> 00:44:36,500
against physical attacks like various

00:44:34,470 --> 00:44:39,600
kinds of bleaches and so on yes actually

00:44:36,500 --> 00:44:42,660
and if we can talk about that after it's

00:44:39,600 --> 00:44:44,010
it's pretty involved but you know if

00:44:42,660 --> 00:44:46,650
anybody's else is interested we can talk

00:44:44,010 --> 00:44:50,630
about and small question does your board

00:44:46,650 --> 00:44:55,740
provide gatech yes face yes and do you

00:44:50,630 --> 00:44:57,240
provide it in your production yes and

00:44:55,740 --> 00:44:59,610
and it's also just you can also disable

00:44:57,240 --> 00:45:02,220
the JTAG as well and then it's a

00:44:59,610 --> 00:45:03,240
securely re-enable it later okay yeah

00:45:02,220 --> 00:45:04,830
thank you

00:45:03,240 --> 00:45:08,490
any other questions here's my contact

00:45:04,830 --> 00:45:09,930
information and I really appreciate the

00:45:08,490 --> 00:45:12,730
opportunity to talk here thank you all

00:45:09,930 --> 00:45:16,019
very much thanks Joe

00:45:12,730 --> 00:45:16,019

YouTube URL: https://www.youtube.com/watch?v=CaQupNgl7gs


