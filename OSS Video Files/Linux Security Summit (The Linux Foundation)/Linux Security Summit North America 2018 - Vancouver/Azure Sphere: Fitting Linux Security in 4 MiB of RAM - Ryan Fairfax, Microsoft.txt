Title: Azure Sphere: Fitting Linux Security in 4 MiB of RAM - Ryan Fairfax, Microsoft
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Azure Sphere: Fitting Linux Security in 4 MiB of RAM - Ryan Fairfax, Microsoft

Azure Sphere is a new solution for building highly secured, connected microcontroller-powered devices. It includes a customized version of the Linux kernel and work to fit the OS within a highly constrained memory footprint. In this talk we will cover the security components of the system, including a custom Linux Security Module, modifications and extensions to existing kernel components, and user space components that form the security backbone of the OS. Along the way weâ€™ll discuss false starts, failed attempts, and the challenges of taking modern security techniques and fitting them in resource constrained devices.

About Ryan Fairfax
Ryan leads OS development for Azure Sphere at Microsoft. Azure Sphere is a new solution for creating highly-secured, Internet-connected microcontroller devices.
Captions: 
	00:00:00,000 --> 00:00:06,930
everyone so I'm gonna talk about a sure

00:00:03,659 --> 00:00:10,550
sphere which is a new Linux based OS

00:00:06,930 --> 00:00:13,590
that Microsoft has been working on for

00:00:10,550 --> 00:00:16,859
secure IOT devices but before I kind of

00:00:13,590 --> 00:00:19,680
dive in I want to give kind of a brief

00:00:16,859 --> 00:00:21,810
overview of who I am and why why I'm

00:00:19,680 --> 00:00:24,510
here so I've been with Microsoft for

00:00:21,810 --> 00:00:26,970
about ten years working on security

00:00:24,510 --> 00:00:28,920
pieces inside at the beginning my career

00:00:26,970 --> 00:00:31,949
the Windows OS a lot of authentication

00:00:28,920 --> 00:00:34,500
work remote attestation things like that

00:00:31,949 --> 00:00:37,020
and then in 2016 I got the opportunity

00:00:34,500 --> 00:00:38,760
to start working on a Linux based

00:00:37,020 --> 00:00:40,530
operating system in secret inside the

00:00:38,760 --> 00:00:44,399
company and just jumped at the

00:00:40,530 --> 00:00:46,739
opportunity and so we we've been working

00:00:44,399 --> 00:00:48,450
on something that we went public with in

00:00:46,739 --> 00:00:50,430
April and I'll kind of walk through and

00:00:48,450 --> 00:00:53,940
talk through the problem space the

00:00:50,430 --> 00:00:58,140
product why we chose Linux and kind of

00:00:53,940 --> 00:00:59,789
go from there so I'm going to talk about

00:00:58,140 --> 00:01:01,530
as your sphere since we're a relatively

00:00:59,789 --> 00:01:03,840
recent product probably most people here

00:01:01,530 --> 00:01:05,010
don't know about it and what it is talk

00:01:03,840 --> 00:01:08,010
a bit about some kernel work that we've

00:01:05,010 --> 00:01:10,380
done user-mode work and then at the end

00:01:08,010 --> 00:01:14,369
some kind of takeaways and future work

00:01:10,380 --> 00:01:17,130
we hope to improve here so this is

00:01:14,369 --> 00:01:19,740
actually I think very interesting that I

00:01:17,130 --> 00:01:20,850
was able to have this talk scheduled so

00:01:19,740 --> 00:01:22,409
close to the talk this morning about

00:01:20,850 --> 00:01:24,479
zephyr because I think there's a lot of

00:01:22,409 --> 00:01:27,119
similar problem spaces here that we're

00:01:24,479 --> 00:01:29,610
looking at so there's nine billion

00:01:27,119 --> 00:01:31,979
microcontrollers shipped a year today

00:01:29,610 --> 00:01:33,780
and that number is just increasing right

00:01:31,979 --> 00:01:35,579
now of those one percent of those nine

00:01:33,780 --> 00:01:37,680
billion about one percent are connected

00:01:35,579 --> 00:01:40,829
to the Internet in some form that's

00:01:37,680 --> 00:01:43,290
going to increase tenfold within within

00:01:40,829 --> 00:01:46,549
a few years and we started looking at

00:01:43,290 --> 00:01:48,720
this in 2015 and we realized that well

00:01:46,549 --> 00:01:51,990
security was basically non-existent

00:01:48,720 --> 00:01:55,500
in the space and so we wanted to really

00:01:51,990 --> 00:01:57,500
figure out how can we kind of improve

00:01:55,500 --> 00:02:00,540
the security strength that space and

00:01:57,500 --> 00:02:01,890
take advantage of the new hardware and

00:02:00,540 --> 00:02:04,729
the power that's coming to

00:02:01,890 --> 00:02:07,049
microcontrollers as technology improves

00:02:04,729 --> 00:02:09,550
right now you know a microcontroller

00:02:07,049 --> 00:02:12,940
might have 286 K of RAM or

00:02:09,550 --> 00:02:16,120
512k of ram a few hundred megahertz arm

00:02:12,940 --> 00:02:17,800
CPU and what we're finding is as the

00:02:16,120 --> 00:02:20,110
technology gets more and more powerful

00:02:17,800 --> 00:02:22,750
you're going to start to seek some of

00:02:20,110 --> 00:02:24,580
the kind of more modern CPUs end up in

00:02:22,750 --> 00:02:28,420
microcontrollers things with mmm use

00:02:24,580 --> 00:02:31,420
things with integrated 802 11 Wi-Fi or

00:02:28,420 --> 00:02:35,140
cellular connectivity and megabytes of

00:02:31,420 --> 00:02:37,090
RAM and so we started on this effort to

00:02:35,140 --> 00:02:39,130
figure out how to take advantage of that

00:02:37,090 --> 00:02:40,780
hardware and bring modern operating

00:02:39,130 --> 00:02:44,980
system productivity and security to that

00:02:40,780 --> 00:02:46,390
space so as your sphere is something

00:02:44,980 --> 00:02:49,000
we've been working on like I said since

00:02:46,390 --> 00:02:50,800
2015 it's a three-part solution for

00:02:49,000 --> 00:02:52,690
microcontroller devices what I'm

00:02:50,800 --> 00:02:54,100
primarily going to talk about today is

00:02:52,690 --> 00:02:55,690
the address tier operating system this

00:02:54,100 --> 00:02:57,190
is the Linux security summit so that's

00:02:55,690 --> 00:02:59,170
most relevant to everyone's interests

00:02:57,190 --> 00:03:01,930
here but it also includes hardware

00:02:59,170 --> 00:03:05,560
technology inside the microcontrollers

00:03:01,930 --> 00:03:08,200
themselves it includes a security

00:03:05,560 --> 00:03:10,600
service for over-the-air update for

00:03:08,200 --> 00:03:14,200
device authentication and attestation to

00:03:10,600 --> 00:03:15,940
cloud services and error reporting type

00:03:14,200 --> 00:03:17,380
of capabilities but what I'm really

00:03:15,940 --> 00:03:21,489
going to focus on today is the operating

00:03:17,380 --> 00:03:23,709
system so before I dig into how we use

00:03:21,489 --> 00:03:25,690
Linux let's talk a bit about what an

00:03:23,709 --> 00:03:28,060
address your microcontroller looks like

00:03:25,690 --> 00:03:31,750
and the kind of compute power that we're

00:03:28,060 --> 00:03:35,040
seeing here so it's a multi-part chip

00:03:31,750 --> 00:03:38,350
the system on a chips are our multi-core

00:03:35,040 --> 00:03:39,820
you know complex designs because the the

00:03:38,350 --> 00:03:42,130
price points are getting in such a case

00:03:39,820 --> 00:03:43,900
where they can they can afford to

00:03:42,130 --> 00:03:46,150
include different layers of technology

00:03:43,900 --> 00:03:47,680
in the stack so the first parts is that

00:03:46,150 --> 00:03:49,300
you have your real-time processing your

00:03:47,680 --> 00:03:52,060
things driving your motors your sensors

00:03:49,300 --> 00:03:54,730
these are traditional arm often arm

00:03:52,060 --> 00:03:56,890
cortex-m microcontrollers and then we

00:03:54,730 --> 00:03:59,709
layer on top of it the rest of the

00:03:56,890 --> 00:04:02,620
technology stack we bring in a cortex a

00:03:59,709 --> 00:04:04,690
that has a memory management unit and

00:04:02,620 --> 00:04:05,890
can run something you know can run Linux

00:04:04,690 --> 00:04:09,070
can run something close to a real

00:04:05,890 --> 00:04:10,209
operating system we bring in integrated

00:04:09,070 --> 00:04:12,760
network connectivity

00:04:10,209 --> 00:04:14,440
it'll be 802 11 in the in the first chip

00:04:12,760 --> 00:04:15,340
but you know cellular is another one

00:04:14,440 --> 00:04:19,690
that comes up a lot

00:04:15,340 --> 00:04:22,450
we have on-chip flash of a greater than

00:04:19,690 --> 00:04:23,250
4 megabytes the the first chip that'll

00:04:22,450 --> 00:04:44,550
hit the market

00:04:23,250 --> 00:04:45,720
mediatek mt6752 Fram at first you know

00:04:44,550 --> 00:04:47,310
we thought about okay can we make

00:04:45,720 --> 00:04:48,870
windows fit in four megabytes of RAM can

00:04:47,310 --> 00:04:51,030
we make Linux fit in four megabytes of

00:04:48,870 --> 00:04:54,300
RAM well they're both quite hard as it

00:04:51,030 --> 00:04:55,440
turns out you know both operating

00:04:54,300 --> 00:04:56,970
systems at various points in their

00:04:55,440 --> 00:04:59,820
lifetime have run in that kind of

00:04:56,970 --> 00:05:01,650
envelope but it's been a long time since

00:04:59,820 --> 00:05:04,919
four megabytes of RAM was the standard I

00:05:01,650 --> 00:05:06,840
mean I remember upgrading my computer to

00:05:04,919 --> 00:05:09,750
four megabytes of RAM many many years

00:05:06,840 --> 00:05:12,600
ago but that was a very long time ago

00:05:09,750 --> 00:05:14,430
and and you know security today is not

00:05:12,600 --> 00:05:17,970
security of the 90s where these were the

00:05:14,430 --> 00:05:19,830
standard kind of QPR so we really

00:05:17,970 --> 00:05:22,770
realized we needed to do some specialty

00:05:19,830 --> 00:05:24,900
work and some customizations to to make

00:05:22,770 --> 00:05:26,430
it fit but still keep the heart of what

00:05:24,900 --> 00:05:30,240
makes a modern operating system

00:05:26,430 --> 00:05:31,410
functional so let's dive into the

00:05:30,240 --> 00:05:34,020
operating system and kind of talk about

00:05:31,410 --> 00:05:37,169
the architecture here so at the base of

00:05:34,020 --> 00:05:39,210
the operating system we have specific

00:05:37,169 --> 00:05:40,620
microcontroller hardware and this

00:05:39,210 --> 00:05:42,540
includes hardware support for things

00:05:40,620 --> 00:05:44,970
like secure boot and device attestation

00:05:42,540 --> 00:05:48,210
crypto acceleration things you would

00:05:44,970 --> 00:05:49,890
expect from a modern SOC and things that

00:05:48,210 --> 00:05:51,530
are really required to build a nice

00:05:49,890 --> 00:05:54,120
secure route of trust

00:05:51,530 --> 00:05:57,390
laid on top of that we have what we call

00:05:54,120 --> 00:05:59,010
the security monitor this is a secure

00:05:57,390 --> 00:06:01,290
Enclave that's responsible for the

00:05:59,010 --> 00:06:03,000
secure boot functionality and certain

00:06:01,290 --> 00:06:05,340
crypto operations accessing sensitive

00:06:03,000 --> 00:06:09,419
keys that kind of thing

00:06:05,340 --> 00:06:11,880
in the first chip it's leveraging

00:06:09,419 --> 00:06:13,560
trustzone from arm as part of its

00:06:11,880 --> 00:06:15,570
execution environment and has a

00:06:13,560 --> 00:06:18,720
dedicated CPU core for the really

00:06:15,570 --> 00:06:20,340
security sensitive operations next we

00:06:18,720 --> 00:06:21,870
have what we what we call to the public

00:06:20,340 --> 00:06:25,140
the high level OS kernel because when

00:06:21,870 --> 00:06:27,030
we're talking to device manufacturers

00:06:25,140 --> 00:06:29,280
that are making things that are looking

00:06:27,030 --> 00:06:30,660
at chips of this scale they're not used

00:06:29,280 --> 00:06:32,280
to high level operating systems they're

00:06:30,660 --> 00:06:35,640
used to are tosses real-time operating

00:06:32,280 --> 00:06:37,029
systems and so you know we say it's oh

00:06:35,640 --> 00:06:40,089
we have a high level OS kernel

00:06:37,029 --> 00:06:42,069
we have a little Linux kernel we're

00:06:40,089 --> 00:06:43,149
running a customized Linux kernel I'll

00:06:42,069 --> 00:06:45,339
get into some details on what

00:06:43,149 --> 00:06:50,319
customization we did but it is very much

00:06:45,339 --> 00:06:52,719
Linux at the heart we layer some system

00:06:50,319 --> 00:06:59,429
services on top of that for update

00:06:52,719 --> 00:07:01,989
authentication connectivity and we add

00:06:59,429 --> 00:07:03,189
kind of application containers on top of

00:07:01,989 --> 00:07:04,659
that where you run your code and so

00:07:03,189 --> 00:07:07,509
there's kind of two programming models

00:07:04,659 --> 00:07:09,159
in the azure sphere world there's what

00:07:07,509 --> 00:07:12,639
we call containers for POSIX these are

00:07:09,159 --> 00:07:14,409
things that run on the cortex a CPU the

00:07:12,639 --> 00:07:18,309
application CPU so this is where you

00:07:14,409 --> 00:07:20,079
might do your kind of compute heavy load

00:07:18,309 --> 00:07:23,529
and so if you have an ml model that you

00:07:20,079 --> 00:07:25,509
want to run awake word detection driving

00:07:23,529 --> 00:07:27,519
and LCD or something where you're

00:07:25,509 --> 00:07:29,439
displaying aux and then we have

00:07:27,519 --> 00:07:30,789
real-time containers for IO that run on

00:07:29,439 --> 00:07:32,649
cortex M's and this is where you're

00:07:30,789 --> 00:07:33,909
doing your time-sensitive operations

00:07:32,649 --> 00:07:39,369
where you need real-time your motor

00:07:33,909 --> 00:07:40,929
control that kind of thing so let's dive

00:07:39,369 --> 00:07:43,449
into the kernel customizations because I

00:07:40,929 --> 00:07:46,649
think that is in a lot of ways the the

00:07:43,449 --> 00:07:50,739
most relevant topic to this audience so

00:07:46,649 --> 00:07:52,899
we really decided very early on we

00:07:50,739 --> 00:07:54,759
wanted to bet on the Linux kernel there

00:07:52,899 --> 00:07:58,629
were two kind of deciding factors that

00:07:54,759 --> 00:08:00,849
came into that first of all you know

00:07:58,629 --> 00:08:02,709
Linux has done some great work towards

00:08:00,849 --> 00:08:05,079
targeting a very diverse range of

00:08:02,709 --> 00:08:06,369
hardware and we knew it was going to be

00:08:05,079 --> 00:08:08,349
some work to make it fit in four

00:08:06,369 --> 00:08:10,509
megabytes of RAM but we also knew it

00:08:08,349 --> 00:08:12,729
wasn't impossibly far away from that and

00:08:10,509 --> 00:08:14,199
the second thing the thing that really

00:08:12,729 --> 00:08:16,299
resonated especially when we talked to

00:08:14,199 --> 00:08:17,889
potential customers people in the

00:08:16,299 --> 00:08:20,139
artists world in the microcontroller

00:08:17,889 --> 00:08:21,339
world are used to open source we wanted

00:08:20,139 --> 00:08:23,949
something that was open source where we

00:08:21,339 --> 00:08:26,169
we could publish what we're doing we

00:08:23,949 --> 00:08:28,119
could get contributions back and really

00:08:26,169 --> 00:08:32,050
be a part of that community and so Linux

00:08:28,119 --> 00:08:33,849
was the obvious choice in many ways so

00:08:32,050 --> 00:08:35,829
our kernel that we're shipping with the

00:08:33,849 --> 00:08:37,629
OS is based on the upstream kernel.org

00:08:35,829 --> 00:08:40,300
sources were not deriving from a

00:08:37,629 --> 00:08:42,729
specific distro we're deriving from from

00:08:40,300 --> 00:08:44,110
the mainline when I started two years

00:08:42,729 --> 00:08:45,519
ago we were on four point one we've

00:08:44,110 --> 00:08:48,550
moved to four point nine we're gonna

00:08:45,519 --> 00:08:50,350
keep moving with LTS branches

00:08:48,550 --> 00:08:51,970
as they kind of come out probably about

00:08:50,350 --> 00:08:53,950
once a year but we're still figuring out

00:08:51,970 --> 00:08:56,709
how we do all that in a non disruptive

00:08:53,950 --> 00:08:59,080
manner but the goal is to not snap and

00:08:56,709 --> 00:09:02,709
fork the goal is to stay up-to-date over

00:08:59,080 --> 00:09:06,760
time and keep moving with the main line

00:09:02,709 --> 00:09:09,220
as servicing branches are declared we

00:09:06,760 --> 00:09:12,399
merge in upstream patches monthly as

00:09:09,220 --> 00:09:13,810
part of our OS build and so I think

00:09:12,399 --> 00:09:15,610
we're at four point nine point one one

00:09:13,810 --> 00:09:18,160
six at the moment and we're do actually

00:09:15,610 --> 00:09:19,320
for another merge this week but the goal

00:09:18,160 --> 00:09:21,130
is we don't want to get too far behind

00:09:19,320 --> 00:09:22,930
both to be able to pull in those

00:09:21,130 --> 00:09:24,610
security fixes when they come out and

00:09:22,930 --> 00:09:28,089
the functionality fixes when they come

00:09:24,610 --> 00:09:30,100
out but also to reduce load on you know

00:09:28,089 --> 00:09:32,050
those the cost of those actual merges we

00:09:30,100 --> 00:09:34,060
made the mistake early on of waiting six

00:09:32,050 --> 00:09:35,740
months before merging and well that was

00:09:34,060 --> 00:09:39,250
an unpleasant week for a lot of us as we

00:09:35,740 --> 00:09:40,300
thought through merge conflicts and to

00:09:39,250 --> 00:09:42,790
give you a sense of scale of how much

00:09:40,300 --> 00:09:44,709
work we've done so we've done 227

00:09:42,790 --> 00:09:47,230
commits in our in our private git repo

00:09:44,709 --> 00:09:48,820
on top of the upstream sources some of

00:09:47,230 --> 00:09:50,500
those are very very tiny and some of

00:09:48,820 --> 00:09:52,930
those are quite substantial but you know

00:09:50,500 --> 00:09:56,290
that gives you the sense of scale of how

00:09:52,930 --> 00:10:00,940
much Delta that we have on top of the

00:09:56,290 --> 00:10:02,649
kind of mainline kernel so our first and

00:10:00,940 --> 00:10:06,310
perhaps biggest problem was making it

00:10:02,649 --> 00:10:08,680
fit when we kind of took the kernel at

00:10:06,310 --> 00:10:10,990
first and I picked some config flags

00:10:08,680 --> 00:10:13,180
that made sense and I ran it you know

00:10:10,990 --> 00:10:16,270
ran the build forearm and it spit out a

00:10:13,180 --> 00:10:17,620
kernel it was four megabytes in size and

00:10:16,270 --> 00:10:20,890
so we'd have enough space to load it and

00:10:17,620 --> 00:10:24,490
then not actually boot it which wasn't

00:10:20,890 --> 00:10:26,140
super helpful and so one of the first

00:10:24,490 --> 00:10:27,610
things we realized very early on with

00:10:26,140 --> 00:10:29,620
four megabytes of RAM is we were gonna

00:10:27,610 --> 00:10:33,520
have to figure out how to avoid putting

00:10:29,620 --> 00:10:34,990
putting text into memory a lot of these

00:10:33,520 --> 00:10:36,430
microcontrollers have an execute in

00:10:34,990 --> 00:10:38,020
place feature that's integrated in their

00:10:36,430 --> 00:10:40,690
flash controller where you actually can

00:10:38,020 --> 00:10:43,630
take a flash region map it into the

00:10:40,690 --> 00:10:45,100
address space as read-only but also in

00:10:43,630 --> 00:10:47,380
in a mode where you can actually execute

00:10:45,100 --> 00:10:49,600
that as code and so that way you don't

00:10:47,380 --> 00:10:51,790
have to pay copying to ram it gives you

00:10:49,600 --> 00:10:53,649
some nice security properties that most

00:10:51,790 --> 00:10:55,540
these implementations you are immutable

00:10:53,649 --> 00:10:59,500
it doesn't support write drops writes

00:10:55,540 --> 00:11:01,720
basically in that address region and so

00:10:59,500 --> 00:11:01,930
we moved to execute in RAM which meant

00:11:01,720 --> 00:11:05,320
we

00:11:01,930 --> 00:11:07,000
could have a four megabyte kernel but we

00:11:05,320 --> 00:11:08,620
still needed about another four

00:11:07,000 --> 00:11:10,390
megabytes to successfully boot by the

00:11:08,620 --> 00:11:12,339
time it got through all the slab

00:11:10,390 --> 00:11:15,390
allocation and came Alex and everything

00:11:12,339 --> 00:11:19,750
it takes to boot up a modern kernel

00:11:15,390 --> 00:11:21,730
so the first maybe four to six months of

00:11:19,750 --> 00:11:23,500
this project was just tuning was just

00:11:21,730 --> 00:11:27,040
figuring out what config options can we

00:11:23,500 --> 00:11:29,230
add to make things more modular in some

00:11:27,040 --> 00:11:31,300
cases there were things where we didn't

00:11:29,230 --> 00:11:33,779
need the functionality but it was

00:11:31,300 --> 00:11:35,980
bundled as part of a larger config item

00:11:33,779 --> 00:11:37,360
and we wanted to kind of cut that into

00:11:35,980 --> 00:11:39,250
sub items so we could turn certain

00:11:37,360 --> 00:11:41,440
features off and a lot of it was just

00:11:39,250 --> 00:11:43,240
tuning cache sizes you know the modern

00:11:41,440 --> 00:11:45,190
Linux kernel is optimized for a million

00:11:43,240 --> 00:11:45,730
processes in in some of its look-up

00:11:45,190 --> 00:11:48,160
tables

00:11:45,730 --> 00:11:51,070
it's got hash tables for paid lookup and

00:11:48,160 --> 00:11:52,720
translation to task structures that are

00:11:51,070 --> 00:11:56,470
optimized for a million processes and

00:11:52,720 --> 00:11:59,680
you know we have I think 25 so that was

00:11:56,470 --> 00:12:01,660
a lot of wasted ram so we did we did a

00:11:59,680 --> 00:12:04,149
lot of small patches towards tweaking

00:12:01,660 --> 00:12:05,500
those default sizes squeezing RAM out of

00:12:04,149 --> 00:12:07,750
the system

00:12:05,500 --> 00:12:10,480
we turned some things off for example

00:12:07,750 --> 00:12:12,190
Sisyphus was the one that I held out the

00:12:10,480 --> 00:12:14,589
longest before fully removing the

00:12:12,190 --> 00:12:17,650
feature that saved almost a megabyte

00:12:14,589 --> 00:12:20,260
turning that offf just in in the cost of

00:12:17,650 --> 00:12:22,810
I nodes and D entry structures and those

00:12:20,260 --> 00:12:24,970
kind of things we turned off a lot of

00:12:22,810 --> 00:12:26,680
the memory tracking options simply

00:12:24,970 --> 00:12:29,200
because they took more memory overhead

00:12:26,680 --> 00:12:32,200
and things like hey all Sims that are

00:12:29,200 --> 00:12:35,860
very very helpful but add space to your

00:12:32,200 --> 00:12:38,200
kernel so as of our public preview build

00:12:35,860 --> 00:12:41,470
which will be released in about a month

00:12:38,200 --> 00:12:44,560
we're at about 2.4 megabytes of code and

00:12:41,470 --> 00:12:47,589
data size in the Linux kernel about

00:12:44,560 --> 00:12:50,440
2,100 kilobytes of RAM usage after in it

00:12:47,589 --> 00:12:51,940
has come up so we've we've come a very

00:12:50,440 --> 00:12:54,190
long way and I have kind of a breakdown

00:12:51,940 --> 00:12:56,170
here showing we're basically by

00:12:54,190 --> 00:12:58,510
top-level folder structure the the the

00:12:56,170 --> 00:12:59,860
size of this it's not surprising at

00:12:58,510 --> 00:13:02,290
least to me that most of it's in the

00:12:59,860 --> 00:13:05,260
network stack and in hardware drivers

00:13:02,290 --> 00:13:10,930
those are obviously quite sophisticated

00:13:05,260 --> 00:13:12,990
pieces of code with a lot to them so

00:13:10,930 --> 00:13:15,790
let's talk about the security model here

00:13:12,990 --> 00:13:20,350
when the first kind of internal preview

00:13:15,790 --> 00:13:21,880
release we did was December of 2016 we

00:13:20,350 --> 00:13:23,860
started with the state of the art for

00:13:21,880 --> 00:13:26,440
IOT at the time that is we had an SSH

00:13:23,860 --> 00:13:28,210
server with a fixed root password that

00:13:26,440 --> 00:13:30,010
you would just connect into and copy

00:13:28,210 --> 00:13:32,320
your app over and run as routes and

00:13:30,010 --> 00:13:36,520
everything was great obviously that was

00:13:32,320 --> 00:13:37,870
not going to cut it long term so we we

00:13:36,520 --> 00:13:39,610
took a step back and we experimented

00:13:37,870 --> 00:13:42,190
with a lot of different security models

00:13:39,610 --> 00:13:45,070
we started by kind of baking things into

00:13:42,190 --> 00:13:48,610
the file system leveraging file system

00:13:45,070 --> 00:13:52,300
capabilities leveraging set UID and set

00:13:48,610 --> 00:13:53,410
G ID to make predictable environments so

00:13:52,300 --> 00:13:54,970
we had a build process that kind of

00:13:53,410 --> 00:13:59,050
stamped these onto all of our processes

00:13:54,970 --> 00:14:00,610
and to make it even kind of easier to

00:13:59,050 --> 00:14:02,440
reason about for us and less attack

00:14:00,610 --> 00:14:05,950
surface we even experiment with a patch

00:14:02,440 --> 00:14:08,290
in the kernel to force effective u ID

00:14:05,950 --> 00:14:10,690
equals real UID in all cases and just

00:14:08,290 --> 00:14:15,250
kind of take transformation of identity

00:14:10,690 --> 00:14:17,290
off the table we ran into a problem

00:14:15,250 --> 00:14:19,150
pretty early on where what happens when

00:14:17,290 --> 00:14:21,610
two processes one IPC with each other a

00:14:19,150 --> 00:14:23,650
share data well we did we solved that

00:14:21,610 --> 00:14:25,090
with supplemental groups also kind of

00:14:23,650 --> 00:14:27,870
baked in the file system so these files

00:14:25,090 --> 00:14:30,010
would say I'm in these three groups and

00:14:27,870 --> 00:14:31,360
the end result of this after this kind

00:14:30,010 --> 00:14:33,130
of experiment is we realized it had some

00:14:31,360 --> 00:14:35,350
nice properties it was very easy to

00:14:33,130 --> 00:14:37,300
reason about what was actually going to

00:14:35,350 --> 00:14:39,340
be allowed you could write tools that

00:14:37,300 --> 00:14:41,590
could audit this very quickly but you

00:14:39,340 --> 00:14:42,850
put all the burden at Build time to make

00:14:41,590 --> 00:14:44,800
sure everything was set up correctly

00:14:42,850 --> 00:14:48,040
and any mistake there would just

00:14:44,800 --> 00:14:51,460
propagate through the system and leave

00:14:48,040 --> 00:14:53,980
you vulnerable and so we backed away

00:14:51,460 --> 00:14:56,500
from that but it really informed in a

00:14:53,980 --> 00:14:59,110
lot of ways our thought process on how

00:14:56,500 --> 00:15:00,760
do we get more granular in our

00:14:59,110 --> 00:15:03,310
permissions and how do we really build a

00:15:00,760 --> 00:15:05,200
model where applications can access

00:15:03,310 --> 00:15:08,050
resources with the principle of least

00:15:05,200 --> 00:15:10,090
privilege in using kind of some of the

00:15:08,050 --> 00:15:15,000
existing capabilities in Linux and an

00:15:10,090 --> 00:15:17,080
existing code so our second attempt here

00:15:15,000 --> 00:15:20,200
we we decided we were going to build a

00:15:17,080 --> 00:15:22,180
little really lightweight LSM and the

00:15:20,200 --> 00:15:24,190
reason we went down that route is we

00:15:22,180 --> 00:15:25,600
wanted to kind of solve a few problems

00:15:24,190 --> 00:15:27,670
first of all we wanted to reduce attack

00:15:25,600 --> 00:15:29,170
surface by taking certain features

00:15:27,670 --> 00:15:31,149
completely off the table

00:15:29,170 --> 00:15:35,799
user management isn't really relevant

00:15:31,149 --> 00:15:37,899
for for an IOT device at least not in

00:15:35,799 --> 00:15:41,049
the traditional desktop or server sense

00:15:37,899 --> 00:15:43,480
certain things for sophisticated job and

00:15:41,049 --> 00:15:45,519
process management are just surfaces

00:15:43,480 --> 00:15:47,019
that we could include in lockdown but we

00:15:45,519 --> 00:15:49,239
weren't going to use and so we wanted to

00:15:47,019 --> 00:15:50,910
completely take them off the table so

00:15:49,239 --> 00:15:53,109
that we could focus our energy elsewhere

00:15:50,910 --> 00:15:54,759
and then the other thing we wanted to do

00:15:53,109 --> 00:15:56,470
as part of this LSM is kind of focus on

00:15:54,759 --> 00:15:58,809
at new access control scenarios that

00:15:56,470 --> 00:16:00,850
more closely modeled how people were

00:15:58,809 --> 00:16:03,279
authoring applications for the platform

00:16:00,850 --> 00:16:05,649
so the LSM is really what I would

00:16:03,279 --> 00:16:07,329
consider pretty minor here it basically

00:16:05,649 --> 00:16:09,850
does two things it statically fails a

00:16:07,329 --> 00:16:12,669
number of says calls that we just don't

00:16:09,850 --> 00:16:14,949
need to support very simple just return

00:16:12,669 --> 00:16:19,299
you know negative a fail or the

00:16:14,949 --> 00:16:22,869
equivalent the second thing we do is we

00:16:19,299 --> 00:16:25,149
add app identity to every task here we

00:16:22,869 --> 00:16:27,339
kind of have three fields we put in here

00:16:25,149 --> 00:16:29,290
we have app identity which represents

00:16:27,339 --> 00:16:30,759
the application package we have a

00:16:29,290 --> 00:16:34,119
network identity which is used for

00:16:30,759 --> 00:16:35,860
remote authentication and so that's

00:16:34,119 --> 00:16:38,199
relevant when you want to go talk off

00:16:35,860 --> 00:16:41,259
box to a cloud service and we have an

00:16:38,199 --> 00:16:43,419
extended set of new capabilities and to

00:16:41,259 --> 00:16:44,949
be perfectly honest I think we will

00:16:43,419 --> 00:16:47,199
continue to evolve how this is actually

00:16:44,949 --> 00:16:48,819
modeled you know I don't like the idea

00:16:47,199 --> 00:16:51,100
of maintaining a separate set of

00:16:48,819 --> 00:16:52,629
capabilities from the base in Linux but

00:16:51,100 --> 00:16:54,489
it does to kind of prototype really

00:16:52,629 --> 00:16:56,889
quickly and add new capabilities to the

00:16:54,489 --> 00:17:00,790
system or make things more granular than

00:16:56,889 --> 00:17:02,350
the current model and then you know apps

00:17:00,790 --> 00:17:04,510
and kernel modules can use these fields

00:17:02,350 --> 00:17:06,519
for access control it's immutable once

00:17:04,510 --> 00:17:11,649
set they inherit by default kind of

00:17:06,519 --> 00:17:12,730
pretty standard set up they're the only

00:17:11,649 --> 00:17:14,079
thing in the kernel side I kind of want

00:17:12,730 --> 00:17:17,139
to talk about is we experiment a lot

00:17:14,079 --> 00:17:19,870
with file systems and one of the things

00:17:17,139 --> 00:17:21,339
we realized was that most file systems

00:17:19,870 --> 00:17:22,779
especially in the main light at this

00:17:21,339 --> 00:17:24,309
point are designed for desktop and

00:17:22,779 --> 00:17:26,889
server scenarios they're designed for

00:17:24,309 --> 00:17:29,490
setups where you know you've got a NAND

00:17:26,889 --> 00:17:32,679
device that is gigabytes in size and

00:17:29,490 --> 00:17:36,190
it's the first chip we were using us 16

00:17:32,679 --> 00:17:38,529
megabytes of flash 512 kilobytes are

00:17:36,190 --> 00:17:40,539
writable and so it's an extreme the

00:17:38,529 --> 00:17:42,650
other direction and so we we started

00:17:40,539 --> 00:17:43,790
kind of pushing that execute in place

00:17:42,650 --> 00:17:45,440
everywhere so that we could run

00:17:43,790 --> 00:17:47,960
applications execute in place as well

00:17:45,440 --> 00:17:50,330
save some RAM there we started with some

00:17:47,960 --> 00:17:52,520
kind of public cram FS patches that have

00:17:50,330 --> 00:17:54,890
been written many years ago I never made

00:17:52,520 --> 00:17:57,080
it to the upstream we kind of but we

00:17:54,890 --> 00:17:58,610
started on that basis we forked it a bit

00:17:57,080 --> 00:18:00,770
with some modifications to reduce some

00:17:58,610 --> 00:18:03,410
overhead we patched in copy-on-write

00:18:00,770 --> 00:18:04,910
support for debugging this is one that

00:18:03,410 --> 00:18:07,790
we didn't actually see coming ahead of

00:18:04,910 --> 00:18:09,980
time where you know someone starts gdb

00:18:07,790 --> 00:18:12,290
server on the device they want to do

00:18:09,980 --> 00:18:13,640
their debugging experience and you know

00:18:12,290 --> 00:18:15,920
they set a breakpoint and it wants to

00:18:13,640 --> 00:18:18,380
patch out an instruction and in an

00:18:15,920 --> 00:18:20,150
execute in-place model that just fail

00:18:18,380 --> 00:18:22,070
well it drops the drops the write on the

00:18:20,150 --> 00:18:25,730
floor and then gdb gets really really

00:18:22,070 --> 00:18:27,410
confused and so we did some small tweaks

00:18:25,730 --> 00:18:28,850
there to be able to temporarily put

00:18:27,410 --> 00:18:31,330
certain pages in RAM for debugging

00:18:28,850 --> 00:18:33,350
scenarios and then throw them away later

00:18:31,330 --> 00:18:36,620
and we tried a lot of radical file

00:18:33,350 --> 00:18:38,120
systems we try to XT - we try J ffs and

00:18:36,620 --> 00:18:39,890
Yaffe's which are popular in the flash

00:18:38,120 --> 00:18:41,690
world they all took hundreds of

00:18:39,890 --> 00:18:44,600
kilobytes of RAM to initialize and that

00:18:41,690 --> 00:18:46,550
that's nothing for most computing

00:18:44,600 --> 00:18:48,920
environments but when you're talking

00:18:46,550 --> 00:18:51,530
about you know 1/16 of the total system

00:18:48,920 --> 00:18:53,480
memory available you very much feel that

00:18:51,530 --> 00:18:56,300
and so one of the things we did is we

00:18:53,480 --> 00:19:00,230
ported arms little FS which they built

00:18:56,300 --> 00:19:03,710
as part of their embed efforts - to

00:19:00,230 --> 00:19:06,350
Linux as a VFS module this is a

00:19:03,710 --> 00:19:09,050
filesystem designed for really really

00:19:06,350 --> 00:19:10,610
tiny setups and specifically for flash

00:19:09,050 --> 00:19:14,630
chips like nor flash chips that you

00:19:10,610 --> 00:19:17,150
often see in microcontrollers and so we

00:19:14,630 --> 00:19:19,160
we ported that into Linux that driver

00:19:17,150 --> 00:19:22,010
and code will be available shortly and

00:19:19,160 --> 00:19:23,390
and we've been hopefully you know

00:19:22,010 --> 00:19:28,309
thinking towards a strategy that would

00:19:23,390 --> 00:19:30,290
let us upstream that and then the kind

00:19:28,309 --> 00:19:31,760
of other last bucket here of kernel

00:19:30,290 --> 00:19:33,950
customizations we did was really about

00:19:31,760 --> 00:19:36,380
access control to existing features the

00:19:33,950 --> 00:19:37,970
major one that kind of resonates general

00:19:36,380 --> 00:19:39,440
purpose i/o you know you've got your

00:19:37,970 --> 00:19:42,380
Raspberry Pi or whatever your preferred

00:19:39,440 --> 00:19:45,650
IOT devices of today you write a program

00:19:42,380 --> 00:19:48,290
that opens slash dev slash GPIO chip 0

00:19:45,650 --> 00:19:50,660
you've got dioctyl calls to read and

00:19:48,290 --> 00:19:53,060
write pins very simple but it treats the

00:19:50,660 --> 00:19:55,070
entire GPIO infrastructure as as one

00:19:53,060 --> 00:19:56,190
resource for access control you can read

00:19:55,070 --> 00:19:58,620
that dev node or you can

00:19:56,190 --> 00:20:00,150
and the problem is is that in the real

00:19:58,620 --> 00:20:02,340
world not everything connected to your

00:20:00,150 --> 00:20:06,630
chip has the same sensitivity so for

00:20:02,340 --> 00:20:08,970
example on a on a appliance I might have

00:20:06,630 --> 00:20:10,800
1 GPIO that toggles an LED saying I'm

00:20:08,970 --> 00:20:13,170
connected to the network not

00:20:10,800 --> 00:20:15,450
super-sensitive if that got compromised

00:20:13,170 --> 00:20:17,670
I might have another GPIO that opens the

00:20:15,450 --> 00:20:20,220
solenoid on my furnace and starts the

00:20:17,670 --> 00:20:22,230
gas flow if an attacker got control of

00:20:20,220 --> 00:20:24,090
that that's a little bit more worrisome

00:20:22,230 --> 00:20:27,780
especially if they also get control of

00:20:24,090 --> 00:20:29,970
the pilot light so we wanted to make

00:20:27,780 --> 00:20:31,350
sure we had granular access control in

00:20:29,970 --> 00:20:33,450
the OS to be able to take some of these

00:20:31,350 --> 00:20:36,000
things that are today considered kind of

00:20:33,450 --> 00:20:38,010
core hardware features only system level

00:20:36,000 --> 00:20:39,540
software needs access to them and figure

00:20:38,010 --> 00:20:42,240
out how to make the access control more

00:20:39,540 --> 00:20:43,860
granular so I can say ok app number one

00:20:42,240 --> 00:20:45,120
can toggle the network status LED

00:20:43,860 --> 00:20:47,400
because it's the network manager but it

00:20:45,120 --> 00:20:49,620
can't touch the gas control whereas app

00:20:47,400 --> 00:20:51,660
number two that is the core logic and

00:20:49,620 --> 00:20:53,520
isn't even connected to the network can

00:20:51,660 --> 00:20:56,670
be the one that can can decide when to

00:20:53,520 --> 00:20:58,440
turn the furnace on and off we added

00:20:56,670 --> 00:21:01,020
file system quota support for MTD

00:20:58,440 --> 00:21:03,960
devices turns out that wasn't there or

00:21:01,020 --> 00:21:05,640
didn't work right and some items to

00:21:03,960 --> 00:21:07,230
leverage our new capabilities instead of

00:21:05,640 --> 00:21:08,880
checking for routes I spent a lot of

00:21:07,230 --> 00:21:11,310
time trying to figure out how not to

00:21:08,880 --> 00:21:13,200
grant apps cap sysadmin because you know

00:21:11,310 --> 00:21:17,280
that's the bucket full of everything in

00:21:13,200 --> 00:21:18,360
the kernel so we took a few things and

00:21:17,280 --> 00:21:20,280
we kind of split them out into new

00:21:18,360 --> 00:21:21,960
capabilities to enable scenarios where

00:21:20,280 --> 00:21:23,640
you could give access to something that

00:21:21,960 --> 00:21:28,710
is a little bit sensitive but just that

00:21:23,640 --> 00:21:31,590
one thing in terms of our app model so

00:21:28,710 --> 00:21:33,780
you know the the kernel side we are

00:21:31,590 --> 00:21:36,330
fundamentally the Linux kernel with

00:21:33,780 --> 00:21:38,190
modifications on top of it we looked a

00:21:36,330 --> 00:21:41,010
lot in user mode to see what could we

00:21:38,190 --> 00:21:42,090
start from and we honestly fumbled a bit

00:21:41,010 --> 00:21:44,490
to try to find something that actually

00:21:42,090 --> 00:21:46,260
fit in the space that we have the kind

00:21:44,490 --> 00:21:48,090
of traditional Linux model of you know

00:21:46,260 --> 00:21:52,350
run System d or a similar init process

00:21:48,090 --> 00:21:53,790
is very expensive and they just weren't

00:21:52,350 --> 00:21:56,520
designed for resource constrained

00:21:53,790 --> 00:21:58,950
environments and so we decided to build

00:21:56,520 --> 00:22:00,390
a custom in it you know we called the

00:21:58,950 --> 00:22:05,730
application manager apparently that's a

00:22:00,390 --> 00:22:09,700
popular name it's it's basically you

00:22:05,730 --> 00:22:11,110
know the only process traditional

00:22:09,700 --> 00:22:12,700
process that runs on our system

00:22:11,110 --> 00:22:14,230
everything else is part of an applicant

00:22:12,700 --> 00:22:16,600
is all other processes are part of an

00:22:14,230 --> 00:22:18,850
application including system services

00:22:16,600 --> 00:22:20,649
and so its sole job is to load

00:22:18,850 --> 00:22:22,029
applications to configure the security

00:22:20,649 --> 00:22:26,169
environment those applications should

00:22:22,029 --> 00:22:26,889
run under to launch them apps are

00:22:26,169 --> 00:22:28,299
self-describing

00:22:26,889 --> 00:22:30,820
through through manifests they're

00:22:28,299 --> 00:22:33,580
independently updatable they actually

00:22:30,820 --> 00:22:36,220
are their own isolated file systems and

00:22:33,580 --> 00:22:37,899
they run isolated from each other and so

00:22:36,220 --> 00:22:41,679
by default an app cannot access any

00:22:37,899 --> 00:22:43,389
resources of another application the you

00:22:41,679 --> 00:22:45,940
know they all run as a unique UID that

00:22:43,389 --> 00:22:47,649
kind of thing we have four out of box

00:22:45,940 --> 00:22:50,710
system apps I kind of listed them on the

00:22:47,649 --> 00:22:52,500
right here they're very classic services

00:22:50,710 --> 00:22:54,639
here we have network management updates

00:22:52,500 --> 00:22:56,230
command and control for development

00:22:54,639 --> 00:22:59,470
scenarios when you're cabled in over

00:22:56,230 --> 00:23:01,600
over USB for example Hardware crypto an

00:22:59,470 --> 00:23:03,370
R and G acceleration and then optionally

00:23:01,600 --> 00:23:06,159
you can get gdb server on there for

00:23:03,370 --> 00:23:07,960
debugging stories and then an OEM brings

00:23:06,159 --> 00:23:11,279
one or more apps to the table that

00:23:07,960 --> 00:23:11,279
actually contains their business logic

00:23:11,429 --> 00:23:15,159
one of the major things from a security

00:23:13,570 --> 00:23:17,799
perspective we wanted to make sure was

00:23:15,159 --> 00:23:18,639
there especially in our v1 everything is

00:23:17,799 --> 00:23:20,919
updatable over-the-air

00:23:18,639 --> 00:23:23,950
everything is renewable we know there is

00:23:20,919 --> 00:23:25,690
going to be zero days in the version of

00:23:23,950 --> 00:23:27,100
Linux kernel that we run between now and

00:23:25,690 --> 00:23:28,179
the lifetime of these devices we know

00:23:27,100 --> 00:23:30,519
there's going to be zero days and the

00:23:28,179 --> 00:23:33,039
code that I've written and so it's

00:23:30,519 --> 00:23:34,840
really critical that we have the ability

00:23:33,039 --> 00:23:38,500
to update over-the-air and update

00:23:34,840 --> 00:23:40,870
quickly over-the-air when we were when

00:23:38,500 --> 00:23:43,330
we were doing some development I don't

00:23:40,870 --> 00:23:45,700
know it was about a year ago when the

00:23:43,330 --> 00:23:47,950
crack Wi-Fi vulnerability started

00:23:45,700 --> 00:23:50,559
circulating we pushed those patches out

00:23:47,950 --> 00:23:51,940
to our test devices in 24 hours and had

00:23:50,559 --> 00:23:55,059
everything patched up and ready to go

00:23:51,940 --> 00:23:57,909
from from the public disclosure to on

00:23:55,059 --> 00:24:00,010
the device the code is executing we're

00:23:57,909 --> 00:24:01,269
really aiming for four critical system

00:24:00,010 --> 00:24:03,130
vulnerabilities four critical security

00:24:01,269 --> 00:24:04,990
vulnerabilities that level of turnaround

00:24:03,130 --> 00:24:06,220
I don't know what the next spectrum

00:24:04,990 --> 00:24:09,970
meltdown is going to be but when it

00:24:06,220 --> 00:24:11,919
happens I want to be ready for it and

00:24:09,970 --> 00:24:14,200
you know from a from a product

00:24:11,919 --> 00:24:16,840
perspective Microsoft managing all the

00:24:14,200 --> 00:24:18,970
OS updates and so when a when a customer

00:24:16,840 --> 00:24:21,250
buys this product and wants to build

00:24:18,970 --> 00:24:22,539
their device on it

00:24:21,250 --> 00:24:23,679
you know we don't want them have to

00:24:22,539 --> 00:24:25,539
reason about what version of the ice

00:24:23,679 --> 00:24:27,610
kernel should I run how do I you know

00:24:25,539 --> 00:24:30,130
how do I get the patches in should I

00:24:27,610 --> 00:24:32,890
worry about this disclosure the CVE or

00:24:30,130 --> 00:24:34,840
not you know part of the product is

00:24:32,890 --> 00:24:36,640
we're going to keep the OS the OS

00:24:34,840 --> 00:24:38,380
functional om have full control over

00:24:36,640 --> 00:24:39,929
their app update story so they decide

00:24:38,380 --> 00:24:46,720
when they push out updates to their code

00:24:39,929 --> 00:24:49,120
but it's kind of a shared model from the

00:24:46,720 --> 00:24:50,890
app model perspective we looked at a few

00:24:49,120 --> 00:24:53,409
options for self-contained apps and in

00:24:50,890 --> 00:24:55,539
containers we started early on with

00:24:53,409 --> 00:24:58,480
Alexi trying to get proper containers

00:24:55,539 --> 00:25:00,760
working and we spent you know a couple

00:24:58,480 --> 00:25:03,010
months on this at various prototypes we

00:25:00,760 --> 00:25:05,380
just couldn't get it to fit you know

00:25:03,010 --> 00:25:08,380
containers have some great properties

00:25:05,380 --> 00:25:10,059
and they also have some serious overhead

00:25:08,380 --> 00:25:12,100
when you're talking about megabytes of

00:25:10,059 --> 00:25:15,340
RAM the cost of remounting your file

00:25:12,100 --> 00:25:18,580
systems is really non-trivial to it to

00:25:15,340 --> 00:25:20,289
an ax device of this size we kind of

00:25:18,580 --> 00:25:21,399
started also playing around with can we

00:25:20,289 --> 00:25:24,309
build something lighter weight with

00:25:21,399 --> 00:25:26,649
namespaces and then realized that a lot

00:25:24,309 --> 00:25:28,539
of the peripherals that people expect in

00:25:26,649 --> 00:25:31,059
IOT devices don't play right with

00:25:28,539 --> 00:25:33,820
namespaces at the moment GPIO is a good

00:25:31,059 --> 00:25:36,970
example some of the other kind of

00:25:33,820 --> 00:25:39,940
hardware level peripherals that these

00:25:36,970 --> 00:25:41,140
apps really need access to we just kept

00:25:39,940 --> 00:25:43,390
running into problems where they weren't

00:25:41,140 --> 00:25:44,799
namespace aware and that's something

00:25:43,390 --> 00:25:46,539
that I would like to revisit in the

00:25:44,799 --> 00:25:47,799
future and see if we can take more

00:25:46,539 --> 00:25:48,990
advantage of that but it's just not

00:25:47,799 --> 00:25:52,120
there today

00:25:48,990 --> 00:25:53,830
so we pivoted off at containers and we

00:25:52,120 --> 00:25:55,450
just really focused on can we can we

00:25:53,830 --> 00:25:57,070
really isolate these apps aggressively

00:25:55,450 --> 00:26:00,190
make sure that our permission model is

00:25:57,070 --> 00:26:02,559
sane and easy to reason about and that

00:26:00,190 --> 00:26:05,260
you know and an escalation a buffer

00:26:02,559 --> 00:26:06,520
overrun in an application really only

00:26:05,260 --> 00:26:09,850
gives you what that application could

00:26:06,520 --> 00:26:12,640
already do so we we build each app as

00:26:09,850 --> 00:26:15,220
its own file system they're mounted and

00:26:12,640 --> 00:26:17,380
unmounted to the to the file system as

00:26:15,220 --> 00:26:19,419
part of install and uninstall there's no

00:26:17,380 --> 00:26:21,370
copying of files around for installation

00:26:19,419 --> 00:26:23,049
this actually made it much easier to

00:26:21,370 --> 00:26:27,760
reason about how to be space efficient

00:26:23,049 --> 00:26:29,980
and do self contained update the apps

00:26:27,760 --> 00:26:32,529
have made a data in their in their file

00:26:29,980 --> 00:26:33,890
system that describes basically here's

00:26:32,529 --> 00:26:36,470
how to run the app and here's

00:26:33,890 --> 00:26:39,340
types of hardware I need access to by

00:26:36,470 --> 00:26:41,600
default all you get is compute and RAM

00:26:39,340 --> 00:26:44,960
you know you can will run your program

00:26:41,600 --> 00:26:46,070
you can you you have access to ram you

00:26:44,960 --> 00:26:48,740
don't even have access to the network by

00:26:46,070 --> 00:26:50,480
default everything must be declared as

00:26:48,740 --> 00:26:52,310
part of the manifest and that helps us

00:26:50,480 --> 00:26:55,280
reason about the security state and and

00:26:52,310 --> 00:26:57,650
help support these developers in making

00:26:55,280 --> 00:27:00,950
sure they really do least privileged for

00:26:57,650 --> 00:27:02,180
their applications and then we validate

00:27:00,950 --> 00:27:03,710
that policy and we enforce it with a

00:27:02,180 --> 00:27:05,780
bunch of linux technologies that I'll

00:27:03,710 --> 00:27:09,200
kind of go into so here's an example

00:27:05,780 --> 00:27:11,260
manifest you know it's it's very simple

00:27:09,200 --> 00:27:13,520
it describes the app in its entry point

00:27:11,260 --> 00:27:16,640
you know what to run what policy to

00:27:13,520 --> 00:27:18,560
enforce what peripheral you have access

00:27:16,640 --> 00:27:20,480
to so for example in this case this

00:27:18,560 --> 00:27:24,410
application has access to one serial

00:27:20,480 --> 00:27:27,770
port one UART called is e0 it has access

00:27:24,410 --> 00:27:29,990
to change the Wi-Fi configuration so it

00:27:27,770 --> 00:27:31,640
can put the device on and off networks

00:27:29,990 --> 00:27:34,460
as part of for example and out of box

00:27:31,640 --> 00:27:36,200
experience and it has access to a fixed

00:27:34,460 --> 00:27:38,740
number of endpoints on the internet and

00:27:36,200 --> 00:27:42,050
so it says ok I need to be able to go to

00:27:38,740 --> 00:27:44,210
log in to Microsoft online comm or graft

00:27:42,050 --> 00:27:46,280
up Microsoft comm but if someone

00:27:44,210 --> 00:27:47,630
compromises my app and they try to reach

00:27:46,280 --> 00:27:49,430
out to their botnet command and control

00:27:47,630 --> 00:27:52,270
endpoint I don't want them to get there

00:27:49,430 --> 00:27:56,780
so we aggressively firewall that traffic

00:27:52,270 --> 00:28:00,350
and use this kind of opt-in model for

00:27:56,780 --> 00:28:01,910
access and so when this is loaded by the

00:28:00,350 --> 00:28:03,020
application manager it kind of parses

00:28:01,910 --> 00:28:05,840
this and we use a bunch of different

00:28:03,020 --> 00:28:08,240
technologies for enforcement first we

00:28:05,840 --> 00:28:11,180
you see groups quite a bit for resource

00:28:08,240 --> 00:28:12,800
limiting and and quoting it also has the

00:28:11,180 --> 00:28:14,240
nice side effect of having predictable

00:28:12,800 --> 00:28:16,280
error States and so when you run out of

00:28:14,240 --> 00:28:18,230
RAM and on a device of this size you

00:28:16,280 --> 00:28:20,690
first few temps of writing code you will

00:28:18,230 --> 00:28:22,880
run out of RAM there's a predictable

00:28:20,690 --> 00:28:24,890
failure mode you don't run the default

00:28:22,880 --> 00:28:26,240
in killer where loops you accidentally

00:28:24,890 --> 00:28:28,130
killed in it or you accidentally killed

00:28:26,240 --> 00:28:31,940
another process that you needed to be

00:28:28,130 --> 00:28:34,610
able to continue it assigns every app a

00:28:31,940 --> 00:28:37,040
unique user ID and group ID this is just

00:28:34,610 --> 00:28:38,780
to get default isolation it updates

00:28:37,040 --> 00:28:40,130
access control on dev entries and so

00:28:38,780 --> 00:28:41,720
when when you say I need access to that

00:28:40,130 --> 00:28:45,140
UART we're gonna go and we're going to

00:28:41,720 --> 00:28:45,970
CH mode the the UART to say okay this

00:28:45,140 --> 00:28:48,370
process should have

00:28:45,970 --> 00:28:50,880
access to this UART at the moment so you

00:28:48,370 --> 00:28:53,320
can open dev ttyS zero or whatever it is

00:28:50,880 --> 00:28:57,310
and it programs the firewall we leverage

00:28:53,320 --> 00:28:58,360
note filter for firewall management and

00:28:57,310 --> 00:29:00,040
then the other thing I want to call out

00:28:58,360 --> 00:29:02,230
is basically every process other than in

00:29:00,040 --> 00:29:04,510
it is an application so we built this

00:29:02,230 --> 00:29:06,070
for our own usage of system services and

00:29:04,510 --> 00:29:08,200
for applications that had a nice side

00:29:06,070 --> 00:29:10,030
effect of us figuring out what we really

00:29:08,200 --> 00:29:12,760
had to build what access we had to let

00:29:10,030 --> 00:29:19,030
through and what features we could defer

00:29:12,760 --> 00:29:20,530
to the future you know the last thing

00:29:19,030 --> 00:29:22,570
I'll kind of say about the app model

00:29:20,530 --> 00:29:24,280
here is we really focused on reducing

00:29:22,570 --> 00:29:26,650
the attack surface by removing features

00:29:24,280 --> 00:29:30,040
there's a lot of things in base Linux

00:29:26,650 --> 00:29:31,930
that are powerful but not necessary for

00:29:30,040 --> 00:29:34,180
an IOT device and it at first it started

00:29:31,930 --> 00:29:35,860
of great less RAM usage I actually can

00:29:34,180 --> 00:29:37,150
get this thing out the door and then it

00:29:35,860 --> 00:29:38,590
kind of turned into well that's one less

00:29:37,150 --> 00:29:40,030
thing I have to reason about from a

00:29:38,590 --> 00:29:41,770
security perspective that's one less

00:29:40,030 --> 00:29:44,440
thing I have to figure out how do I

00:29:41,770 --> 00:29:46,240
secure and I find that that is often

00:29:44,440 --> 00:29:47,830
just as valuable is actually reasoning

00:29:46,240 --> 00:29:50,560
about how do I lock down this feature is

00:29:47,830 --> 00:29:52,150
asking yourself do I evened it so we

00:29:50,560 --> 00:29:54,910
have no shell or no user account

00:29:52,150 --> 00:29:56,470
management the shell you know keep

00:29:54,910 --> 00:29:58,420
putting a show on a device is a kind of

00:29:56,470 --> 00:30:01,960
classic IOT mistake I think in a lot of

00:29:58,420 --> 00:30:03,820
ways that a lot of products have done we

00:30:01,960 --> 00:30:06,670
have no kernel module support because we

00:30:03,820 --> 00:30:07,450
we don't yet and it's one less surface

00:30:06,670 --> 00:30:10,150
we have to worry about

00:30:07,450 --> 00:30:12,580
we have aggressively stripped our system

00:30:10,150 --> 00:30:15,130
libraries were at nine shared objects on

00:30:12,580 --> 00:30:17,230
the entire entire file system which is

00:30:15,130 --> 00:30:20,590
quite a contrast from most Linux

00:30:17,230 --> 00:30:22,270
distributions in fact many of those

00:30:20,590 --> 00:30:27,210
Essos are actually symbolic links to

00:30:22,270 --> 00:30:29,800
another Esso so it's even smaller and we

00:30:27,210 --> 00:30:32,230
really focus on limiting resource usage

00:30:29,800 --> 00:30:34,090
and so we configure C groups to make

00:30:32,230 --> 00:30:37,090
sure that when your app has an infinite

00:30:34,090 --> 00:30:38,590
malloc loop it just kills that app you

00:30:37,090 --> 00:30:40,840
know we also use it for certain resource

00:30:38,590 --> 00:30:43,000
contention making sure you can't steal

00:30:40,840 --> 00:30:45,130
100% of the CPU cycles and block update

00:30:43,000 --> 00:30:47,290
things like that

00:30:45,130 --> 00:30:48,970
and I did mention already about you you

00:30:47,290 --> 00:30:51,270
can't access anything that you don't opt

00:30:48,970 --> 00:30:51,270
into

00:30:52,749 --> 00:30:59,179
so what I kind of want to talk about

00:30:57,230 --> 00:31:00,739
here a bit is is opportunities for the

00:30:59,179 --> 00:31:02,649
future we're coming up to our public

00:31:00,739 --> 00:31:05,149
preview in the next couple of months

00:31:02,649 --> 00:31:06,830
that'll be the first time that people

00:31:05,149 --> 00:31:09,169
will be able to order or development

00:31:06,830 --> 00:31:10,580
kits from our partner seed studios and

00:31:09,169 --> 00:31:12,559
actually get their hands on it and play

00:31:10,580 --> 00:31:14,480
with it and then we're looking towards

00:31:12,559 --> 00:31:17,119
the first real products you know over

00:31:14,480 --> 00:31:18,919
the next year but we also know that

00:31:17,119 --> 00:31:20,899
there's still a lot of work we can do

00:31:18,919 --> 00:31:23,629
here and want to do here

00:31:20,899 --> 00:31:25,340
I think our original vision is still

00:31:23,629 --> 00:31:27,289
many years out and while we're very

00:31:25,340 --> 00:31:29,059
proud of the v1 and we know that it's

00:31:27,289 --> 00:31:30,889
going to uplevel some of the security in

00:31:29,059 --> 00:31:33,409
these products there's a lot of

00:31:30,889 --> 00:31:35,359
opportunities for future improvement so

00:31:33,409 --> 00:31:37,489
the first one I want to call out is now

00:31:35,359 --> 00:31:39,049
that we're public we've really been

00:31:37,489 --> 00:31:40,940
thinking about what are we upstream I

00:31:39,049 --> 00:31:42,440
really want to take some of the work

00:31:40,940 --> 00:31:44,059
that we did for memory improvements

00:31:42,440 --> 00:31:45,739
especially the ones that are generally

00:31:44,059 --> 00:31:47,809
applicable and figure out if we can get

00:31:45,739 --> 00:31:50,359
those into the mainline there's no

00:31:47,809 --> 00:31:51,470
reason for you know for us to hold those

00:31:50,359 --> 00:31:54,739
when there are things that can be

00:31:51,470 --> 00:31:58,009
applicable for for the rest of the

00:31:54,739 --> 00:31:59,809
community I talked about the file system

00:31:58,009 --> 00:32:01,580
I actually think there's a lot of

00:31:59,809 --> 00:32:03,350
potential value in that file system

00:32:01,580 --> 00:32:05,119
being in the mainline because it's very

00:32:03,350 --> 00:32:07,429
resource efficient even if you're

00:32:05,119 --> 00:32:10,249
talking megabytes or gigabytes of

00:32:07,429 --> 00:32:11,840
storage and that's something that I

00:32:10,249 --> 00:32:13,609
think you know if you think about other

00:32:11,840 --> 00:32:15,409
classes of devices even something like a

00:32:13,609 --> 00:32:16,999
Raspberry Pi or a router or something

00:32:15,409 --> 00:32:18,590
that's a bit more powerful they might be

00:32:16,999 --> 00:32:21,139
able to take advantage of that so we're

00:32:18,590 --> 00:32:23,330
reasoning through the early stages of of

00:32:21,139 --> 00:32:24,320
what we upstream not everything we do is

00:32:23,330 --> 00:32:25,549
going to be upstream some of the

00:32:24,320 --> 00:32:28,639
hardware work for example is very

00:32:25,549 --> 00:32:30,129
specific to the individual SOC but we

00:32:28,639 --> 00:32:33,440
hope we can we can get some stuff there

00:32:30,129 --> 00:32:35,539
we want to use the namespaces more you

00:32:33,440 --> 00:32:37,659
know I keep coming back to that idea of

00:32:35,539 --> 00:32:41,539
I really want something like a container

00:32:37,659 --> 00:32:43,159
and we know that some namespaces are

00:32:41,539 --> 00:32:45,320
easier to fit in this memory model than

00:32:43,159 --> 00:32:47,210
others for example putting things in a

00:32:45,320 --> 00:32:49,039
pit namespace is generally pretty

00:32:47,210 --> 00:32:51,019
lightweight putting things in a user

00:32:49,039 --> 00:32:52,039
name space is fairly lightweight putting

00:32:51,019 --> 00:32:54,109
something in a mountain name space is

00:32:52,039 --> 00:32:56,179
very expensive at the moment and so

00:32:54,109 --> 00:32:57,529
there may be opportunity for us to see

00:32:56,179 --> 00:32:59,809
if we can make some improvements there

00:32:57,529 --> 00:33:03,320
to kind of pull some of those back and

00:32:59,809 --> 00:33:06,600
put them on the table again I really

00:33:03,320 --> 00:33:08,399
want to try to figure out how we can get

00:33:06,600 --> 00:33:11,610
stuff out of caps s admin or make it

00:33:08,399 --> 00:33:12,990
more granular I there was a period of

00:33:11,610 --> 00:33:15,029
about a year where it felt every other

00:33:12,990 --> 00:33:16,740
day someone on my team was coming to me

00:33:15,029 --> 00:33:18,570
saying oh I have to give this process

00:33:16,740 --> 00:33:21,720
caps s admin and I'd say no go away

00:33:18,570 --> 00:33:24,299
figure out another way to do it but that

00:33:21,720 --> 00:33:26,220
has very much become the dumping ground

00:33:24,299 --> 00:33:27,750
and the capability model is awesome

00:33:26,220 --> 00:33:29,970
until you hit that point where you need

00:33:27,750 --> 00:33:31,049
it and then you just you're trying to

00:33:29,970 --> 00:33:34,830
figure out how do I not give them

00:33:31,049 --> 00:33:37,049
everything and some low-level hardware

00:33:34,830 --> 00:33:40,169
features shouldn't require caps ascend

00:33:37,049 --> 00:33:41,610
and I talked about GPIO I squared C and

00:33:40,169 --> 00:33:43,649
and spy and these kind of low-level

00:33:41,610 --> 00:33:44,820
peripheral interfaces are all kind of

00:33:43,649 --> 00:33:47,220
built around the fact that the only

00:33:44,820 --> 00:33:50,100
people that are using them are low-level

00:33:47,220 --> 00:33:52,110
system processes and it's just not true

00:33:50,100 --> 00:33:54,029
in this space they're the part of the

00:33:52,110 --> 00:33:55,559
scenario they're what's driving other

00:33:54,029 --> 00:33:57,960
microcontrollers as part of the product

00:33:55,559 --> 00:34:00,029
or other devices and Asics as part of

00:33:57,960 --> 00:34:02,070
the product and so figuring out how to

00:34:00,029 --> 00:34:03,539
pull some of them kind of more

00:34:02,070 --> 00:34:05,759
sophisticated security and access

00:34:03,539 --> 00:34:09,389
control into those resources that would

00:34:05,759 --> 00:34:11,879
be a major win and you know the other

00:34:09,389 --> 00:34:14,339
thing I'll say is we built our own LSM

00:34:11,879 --> 00:34:16,740
kind of out of desperation more than

00:34:14,339 --> 00:34:18,569
anything else I really want to revisit

00:34:16,740 --> 00:34:20,220
looking at something like SELinux or app

00:34:18,569 --> 00:34:23,159
armor and figure out if we can make it

00:34:20,220 --> 00:34:26,040
work and take advantage of the efforts

00:34:23,159 --> 00:34:28,260
going on you know we did some early

00:34:26,040 --> 00:34:30,149
prototypes we shelved it for the moment

00:34:28,260 --> 00:34:32,099
to focus on functionality and getting

00:34:30,149 --> 00:34:33,270
the kind of v1 out the door there's

00:34:32,099 --> 00:34:34,829
definitely opportunity to go back and

00:34:33,270 --> 00:34:37,200
revisit some of those decisions and

00:34:34,829 --> 00:34:38,819
figure out how to make how to take

00:34:37,200 --> 00:34:41,129
advantage of all that great work going

00:34:38,819 --> 00:34:43,260
on and really bring the power of that

00:34:41,129 --> 00:34:44,460
into the platform and then of course you

00:34:43,260 --> 00:34:46,200
know like I think I could fill this

00:34:44,460 --> 00:34:49,050
slide up twelve times over with crazy

00:34:46,200 --> 00:34:50,369
ideas that I have especially after a

00:34:49,050 --> 00:34:52,139
couple years of working on this we've

00:34:50,369 --> 00:34:58,290
got no shortage of things we want to

00:34:52,139 --> 00:35:00,170
improve you know the kind of last thing

00:34:58,290 --> 00:35:03,089
I'll highlight here is some takeaways

00:35:00,170 --> 00:35:04,920
the the biggest one that kind of speaks

00:35:03,089 --> 00:35:08,369
to me a lot after having done this for a

00:35:04,920 --> 00:35:10,290
couple years now is that security and

00:35:08,369 --> 00:35:13,530
resource usage are at odds in a lot of

00:35:10,290 --> 00:35:15,329
cases you know features you design

00:35:13,530 --> 00:35:16,510
something for strong security everyone

00:35:15,329 --> 00:35:18,790
here does it

00:35:16,510 --> 00:35:20,110
you focus on security you don't

00:35:18,790 --> 00:35:21,850
necessarily think about space

00:35:20,110 --> 00:35:24,790
consideration or if you do it's a

00:35:21,850 --> 00:35:26,620
secondary factor and so you build your

00:35:24,790 --> 00:35:29,050
tracking you know mechanisms for

00:35:26,620 --> 00:35:30,850
real-time analytics and and analysis and

00:35:29,050 --> 00:35:32,770
security and you don't think about well

00:35:30,850 --> 00:35:35,140
okay I just malloc two megabyte worth of

00:35:32,770 --> 00:35:36,700
tracking structures and that actually

00:35:35,140 --> 00:35:41,260
prevents certain classes of devices from

00:35:36,700 --> 00:35:42,130
even using this feature and you know

00:35:41,260 --> 00:35:42,790
security features are often

00:35:42,130 --> 00:35:45,070
all-or-nothing

00:35:42,790 --> 00:35:49,270
you can use the feature you can shut the

00:35:45,070 --> 00:35:52,180
feature off and there's not always a way

00:35:49,270 --> 00:35:54,100
to say okay I want some benefit out of

00:35:52,180 --> 00:35:56,140
this I know I can't be as secure as I

00:35:54,100 --> 00:35:58,030
could be if I'm a server with I could

00:35:56,140 --> 00:36:00,130
get byte of RAM but I don't want to I

00:35:58,030 --> 00:36:01,360
don't want to accept zero I want some

00:36:00,130 --> 00:36:02,470
value pulled in I want to be able to

00:36:01,360 --> 00:36:05,140
take advantage of some of these features

00:36:02,470 --> 00:36:08,590
and improve the strength of what is

00:36:05,140 --> 00:36:09,520
there and you know certain security

00:36:08,590 --> 00:36:11,560
frameworks have done better at this than

00:36:09,520 --> 00:36:12,880
others but in general a lot of it is

00:36:11,560 --> 00:36:14,290
seen is all or nothing because as a

00:36:12,880 --> 00:36:15,670
security expert that's how I like to

00:36:14,290 --> 00:36:20,650
think about it right why would you ever

00:36:15,670 --> 00:36:23,110
not want all of the security and then

00:36:20,650 --> 00:36:25,360
the other thing I'll say is that a lot

00:36:23,110 --> 00:36:28,030
of security features and other

00:36:25,360 --> 00:36:31,360
frameworks depend on things like sis FS

00:36:28,030 --> 00:36:33,220
and sis FS is the best example the top

00:36:31,360 --> 00:36:36,370
of my head of an all-or-nothing you say

00:36:33,220 --> 00:36:38,830
config sis FS equals yes every module

00:36:36,370 --> 00:36:41,550
out there starts putting entries in sis

00:36:38,830 --> 00:36:43,810
FS when really you just want a subset

00:36:41,550 --> 00:36:46,030
and there's not a good way right now to

00:36:43,810 --> 00:36:47,890
say I want these set of features and

00:36:46,030 --> 00:36:50,530
sisyphus but not this and so that that's

00:36:47,890 --> 00:36:51,940
part of why we had to turn it off that

00:36:50,530 --> 00:36:55,600
being said I will highlight a lot of

00:36:51,940 --> 00:36:57,160
this stuff just worked you know I I we

00:36:55,600 --> 00:36:59,380
had our first prototype up and running

00:36:57,160 --> 00:37:01,840
from the moment we decided hey we should

00:36:59,380 --> 00:37:04,240
use Linux - I have something booting on

00:37:01,840 --> 00:37:07,060
a prototype piece of silicon it was

00:37:04,240 --> 00:37:08,890
about six weeks and that's six weeks for

00:37:07,060 --> 00:37:12,490
a Microsoft team where most of us hadn't

00:37:08,890 --> 00:37:15,040
touched Linux in ten years and so you

00:37:12,490 --> 00:37:16,210
know I think that's really a credit to a

00:37:15,040 --> 00:37:18,490
lot of the effort going on in the

00:37:16,210 --> 00:37:22,330
community especially in the embedded

00:37:18,490 --> 00:37:25,510
space and and the kernel in general to

00:37:22,330 --> 00:37:26,620
just show how flexible it is and most

00:37:25,510 --> 00:37:28,150
the changes we had to deal we're pretty

00:37:26,620 --> 00:37:29,850
small you know like we added some new

00:37:28,150 --> 00:37:31,800
config flags we put some pound defy

00:37:29,850 --> 00:37:34,080
around things we tweet some constant

00:37:31,800 --> 00:37:37,200
hash table sizes those are all very

00:37:34,080 --> 00:37:39,270
small tweaks you know we have a few

00:37:37,200 --> 00:37:41,340
larger modifications but they were rare

00:37:39,270 --> 00:37:46,290
and I think that's really a credit to

00:37:41,340 --> 00:37:48,450
the quality of the work going on here so

00:37:46,290 --> 00:37:50,070
that the kind of last takeaway you know

00:37:48,450 --> 00:37:52,200
there's a lot of improvements going on

00:37:50,070 --> 00:37:53,370
in the desktop on the server space and

00:37:52,200 --> 00:37:54,990
the traditional computing space

00:37:53,370 --> 00:37:57,300
especially when it comes to security and

00:37:54,990 --> 00:38:00,510
a lot of those can benefit embedded in

00:37:57,300 --> 00:38:02,670
IOT the the problems here are just not

00:38:00,510 --> 00:38:05,670
unique they're they're scaled you know

00:38:02,670 --> 00:38:07,200
they're resource constrained but the

00:38:05,670 --> 00:38:08,970
problems of worrying about what happens

00:38:07,200 --> 00:38:11,550
when someone exploits a buffer overrun

00:38:08,970 --> 00:38:14,070
and escalates to root and you know takes

00:38:11,550 --> 00:38:15,600
over my device in my network that that's

00:38:14,070 --> 00:38:17,070
going to be there on every device out

00:38:15,600 --> 00:38:20,190
there and we're talking 9 billion

00:38:17,070 --> 00:38:22,050
devices a year that's a lot of surface

00:38:20,190 --> 00:38:24,030
to try to protect and so we really want

00:38:22,050 --> 00:38:26,370
to try to figure out a way to take

00:38:24,030 --> 00:38:28,440
advantage of that innovation going on to

00:38:26,370 --> 00:38:30,570
pull it into the IOT world and to really

00:38:28,440 --> 00:38:34,890
at times drag them kicking and screaming

00:38:30,570 --> 00:38:38,510
into the modern security world all right

00:38:34,890 --> 00:38:38,510
and with that I'll open up for questions

00:38:49,349 --> 00:39:09,849
yes yeah yep sure absolutely there there

00:39:08,290 --> 00:39:11,440
are kind of two problems to unpack here

00:39:09,849 --> 00:39:14,619
first of all is when we started this

00:39:11,440 --> 00:39:16,119
effort we were trying to convince the

00:39:14,619 --> 00:39:17,770
company this was a viable product

00:39:16,119 --> 00:39:20,109
there's a little bit of politics there

00:39:17,770 --> 00:39:23,890
to be just to be frank we're past that

00:39:20,109 --> 00:39:25,570
now which is great and you know we were

00:39:23,890 --> 00:39:27,550
able to open up and announce this year

00:39:25,570 --> 00:39:29,020
and in I think it was April at the RSA

00:39:27,550 --> 00:39:31,900
Conference and we're continuing that I

00:39:29,020 --> 00:39:33,339
will say we are publishing the source of

00:39:31,900 --> 00:39:35,530
what we've done as part of our public

00:39:33,339 --> 00:39:37,900
preview which I is scheduled currently

00:39:35,530 --> 00:39:40,270
for September so the source will be

00:39:37,900 --> 00:39:42,310
available we're going to we're really

00:39:40,270 --> 00:39:44,800
working to become more open as we as we

00:39:42,310 --> 00:39:46,570
move forward and think about things like

00:39:44,800 --> 00:39:49,300
up streaming I mean we have been doing

00:39:46,570 --> 00:39:50,800
some early thought to that even

00:39:49,300 --> 00:39:51,910
internally within code reviews there

00:39:50,800 --> 00:39:54,130
been a few times so I've had to stop

00:39:51,910 --> 00:39:56,650
members of my team and say hey go look

00:39:54,130 --> 00:39:57,700
at how this is in 4.19 and let's just

00:39:56,650 --> 00:40:00,190
make sure we're not building in an

00:39:57,700 --> 00:40:01,660
opposite direction but I do expect

00:40:00,190 --> 00:40:04,330
there's gonna be some pain as we merge

00:40:01,660 --> 00:40:05,650
back to the public and and that's part

00:40:04,330 --> 00:40:07,000
of the cost I think we're gonna pay over

00:40:05,650 --> 00:40:08,880
the next few months to get into a good

00:40:07,000 --> 00:40:13,450
State

00:40:08,880 --> 00:40:14,589
just one more question so if I

00:40:13,450 --> 00:40:17,230
understood correctly you're running

00:40:14,589 --> 00:40:18,550
Linux on the cortex a correct what are

00:40:17,230 --> 00:40:22,180
you running or can you say what you're

00:40:18,550 --> 00:40:24,130
running on the cortex sure so the

00:40:22,180 --> 00:40:26,650
coreboot processor one of the cortex M's

00:40:24,130 --> 00:40:28,089
on this first chip is the core boot CPU

00:40:26,650 --> 00:40:29,710
it's responsible for secure boot that's

00:40:28,089 --> 00:40:32,260
a proprietary piece of firmware it's

00:40:29,710 --> 00:40:34,570
really lightweight its job is to to boot

00:40:32,260 --> 00:40:37,060
to verify signatures to get out of the

00:40:34,570 --> 00:40:40,599
way there are two cortex M's for

00:40:37,060 --> 00:40:43,750
real-time i/o for customer code usage we

00:40:40,599 --> 00:40:45,700
don't prescribe what they run there so

00:40:43,750 --> 00:40:47,290
they might take an existing are toss for

00:40:45,700 --> 00:40:49,030
example and compile it and run it on

00:40:47,290 --> 00:40:51,180
that for their real-time code I think

00:40:49,030 --> 00:40:54,369
will probably provide like a reference

00:40:51,180 --> 00:40:56,020
lightweight artist slash library but

00:40:54,369 --> 00:40:57,369
we're really looking to let customers

00:40:56,020 --> 00:40:59,710
self enable on those two

00:40:57,369 --> 00:41:01,390
and what's the interface between the

00:40:59,710 --> 00:41:04,029
Linux instance and those it's a just

00:41:01,390 --> 00:41:06,519
shared memory there is a mailbox based

00:41:04,029 --> 00:41:07,930
communication protocol that we document

00:41:06,519 --> 00:41:13,150
and provide reference libraries for for

00:41:07,930 --> 00:41:17,750
communication thanks yes so we're out of

00:41:13,150 --> 00:41:22,889
time and thank you Ryan thanks

00:41:17,750 --> 00:41:22,889

YouTube URL: https://www.youtube.com/watch?v=KY1vRrS9Lrk


