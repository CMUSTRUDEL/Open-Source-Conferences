Title: STACKLEAK: A Long Way to the Linux Kernel Mainline - Alexander Popov, Positive Technologies
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	STACKLEAK: A Long Way to the Linux Kernel Mainline - Alexander Popov, Positive Technologies

STACKLEAK is a Linux kernel security feature initially created by Grsecurity/PaX developers. In May of 2017 Alexander Popov took on the task of introducing STACKLEAK into the Linux kernel mainline. The way to the mainline turned out to be long and complicated.

In this talk Alexander will describe the inner workings of this security feature and why the vanilla kernel needs it. In fact, STACKLEAK mitigates several types of attacks against the Linux kernel due to:
- reducing the information that can be revealed through kernel stack leak bugs;
- blocking some uninitialized stack variable attacks;
- blocking kernel stack depth overflow caused by alloca (aka Stack Clash attack).

Alexander will also show the timeline of his work and share some lessons he learned from it.

About Alexander Popov
Alexander Popov is a security researcher at Positive Technologies where he is having a lot of fun with the Linux kernel vulnerabilities, exploitation techniques and defensive technologies. Alexander is a Linux kernel developer since 2012.
Captions: 
	00:00:00,030 --> 00:00:06,690
hello yes I will tell about a click

00:00:04,529 --> 00:00:08,610
security feature and it's long and

00:00:06,690 --> 00:00:12,110
complicated way to the Linux kernel

00:00:08,610 --> 00:00:15,570
mainline my name is Alexander Popov I'm

00:00:12,110 --> 00:00:18,960
the Linux kernel developer and security

00:00:15,570 --> 00:00:21,480
researcher at positive technologist the

00:00:18,960 --> 00:00:23,869
plan of the talk first I will give the

00:00:21,480 --> 00:00:27,630
overview of steglich security feature

00:00:23,869 --> 00:00:29,160
then describe my role give the technical

00:00:27,630 --> 00:00:35,160
details how does it work

00:00:29,160 --> 00:00:38,570
and finally describe this way to the

00:00:35,160 --> 00:00:41,520
mainline the timeline current state and

00:00:38,570 --> 00:00:45,930
interactions with the lino send subsidy

00:00:41,520 --> 00:00:48,420
maintainer x' stay click is an awesome

00:00:45,930 --> 00:00:53,100
security feature originally initially

00:00:48,420 --> 00:00:55,379
made by parks team it comes as parks

00:00:53,100 --> 00:00:58,410
memories technique injure security parks

00:00:55,379 --> 00:01:03,000
patch but unfortunately this patch is

00:00:58,410 --> 00:01:06,229
not public anymore the last public

00:01:03,000 --> 00:01:13,409
version which we have is for kernel 4.9

00:01:06,229 --> 00:01:15,299
from April 2017 and I took the goal to

00:01:13,409 --> 00:01:19,320
introduce the click into the Linux

00:01:15,299 --> 00:01:22,680
kernel mainline and I want to thank my

00:01:19,320 --> 00:01:25,619
employer positive technologies it allows

00:01:22,680 --> 00:01:27,960
me to spend part of my working time on

00:01:25,619 --> 00:01:34,020
it and of course thank my family because

00:01:27,960 --> 00:01:34,650
I spent a lot of my free time on it what

00:01:34,020 --> 00:01:37,380
did I do

00:01:34,650 --> 00:01:40,409
first I had to extract stay click from

00:01:37,380 --> 00:01:45,270
the security parks patch which is really

00:01:40,409 --> 00:01:48,950
big more than twenty thousand two

00:01:45,270 --> 00:01:51,590
hundred thousand lines in it and I

00:01:48,950 --> 00:01:59,490
carefully learned it bit by bit

00:01:51,590 --> 00:02:02,040
and went the usual loop sent to Linux

00:01:59,490 --> 00:02:04,680
kernel mailing list get feedback improve

00:02:02,040 --> 00:02:05,310
repeat and I'm doing that for more than

00:02:04,680 --> 00:02:07,890
a year

00:02:05,310 --> 00:02:12,780
I've sent 15 versions of the patch

00:02:07,890 --> 00:02:16,890
serious and it's

00:02:12,780 --> 00:02:19,880
still in progress now about the click

00:02:16,890 --> 00:02:23,490
security features what does it provide

00:02:19,880 --> 00:02:29,100
first of all I want to show you this map

00:02:23,490 --> 00:02:32,040
describing the linux linux kernel

00:02:29,100 --> 00:02:34,530
security area they only think you can

00:02:32,040 --> 00:02:37,080
you should see on this slide is that you

00:02:34,530 --> 00:02:38,630
don't see anything because the area is

00:02:37,080 --> 00:02:41,250
very complex there are a lot of

00:02:38,630 --> 00:02:44,360
different kinds of vulnerabilities

00:02:41,250 --> 00:02:47,130
exploit techniques and Linux kernel

00:02:44,360 --> 00:02:49,310
security features which mitigate them

00:02:47,130 --> 00:02:55,520
and there are a lot of interconnections

00:02:49,310 --> 00:03:00,150
so if you want the details you can look

00:02:55,520 --> 00:03:04,610
I give the link to the repository and

00:03:00,150 --> 00:03:09,959
this is the part of this map about

00:03:04,610 --> 00:03:12,180
steglich so stay click is out of 3

00:03:09,959 --> 00:03:16,260
defense which is going to the main line

00:03:12,180 --> 00:03:23,430
it has inspired by parks memories

00:03:16,260 --> 00:03:27,690
technique and it have it interacts with

00:03:23,430 --> 00:03:31,380
three kinds of kernel vulnerabilities

00:03:27,690 --> 00:03:34,470
it has stack depth of flow uninitialized

00:03:31,380 --> 00:03:41,190
variables attacks and information

00:03:34,470 --> 00:03:43,560
exposure this links this arrows on the

00:03:41,190 --> 00:03:46,260
diagram doesn't mean that technique

00:03:43,560 --> 00:03:51,120
mitigates those kinds of bugs it means

00:03:46,260 --> 00:03:55,019
that there is some interconnection and I

00:03:51,120 --> 00:03:57,180
will describe it soon the security

00:03:55,019 --> 00:03:58,920
feature number one stay click erases the

00:03:57,180 --> 00:04:01,440
kernel stack at the end of the system

00:03:58,920 --> 00:04:05,519
call and that reduces the information

00:04:01,440 --> 00:04:09,720
which can be licked by kernels Tech

00:04:05,519 --> 00:04:14,640
League bugs how does it look how such

00:04:09,720 --> 00:04:20,580
bug looks we have user space and kernel

00:04:14,640 --> 00:04:21,330
space and two system calls on this

00:04:20,580 --> 00:04:23,610
diagram

00:04:21,330 --> 00:04:26,220
during the first system call we have

00:04:23,610 --> 00:04:28,860
some security sensitive data of

00:04:26,220 --> 00:04:32,040
at the kernel thread stack and the

00:04:28,860 --> 00:04:35,940
second system call has a bug we have

00:04:32,040 --> 00:04:38,190
copied to user with some data not

00:04:35,940 --> 00:04:40,730
initialized so this data contained

00:04:38,190 --> 00:04:43,920
contains the values which were

00:04:40,730 --> 00:04:46,860
previously put at the kernel thread

00:04:43,920 --> 00:04:49,380
stack and these values are copied to the

00:04:46,860 --> 00:04:52,830
user space and the attacker now can

00:04:49,380 --> 00:04:55,020
analyze them and what does technique do

00:04:52,830 --> 00:04:57,510
against that at the end of the system

00:04:55,020 --> 00:05:00,960
call we have stay click erase function

00:04:57,510 --> 00:05:02,880
which is called and it raises the the

00:05:00,960 --> 00:05:07,370
used part of the kernel stack it writes

00:05:02,880 --> 00:05:09,780
- beef to the kernel thread stack and

00:05:07,370 --> 00:05:15,720
overrides the security sensitive data

00:05:09,780 --> 00:05:18,180
and later the system call number - it

00:05:15,720 --> 00:05:19,710
still has the bug but the only thing

00:05:18,180 --> 00:05:23,310
which is copied to the user space is

00:05:19,710 --> 00:05:26,850
this - - beef so security sensitive data

00:05:23,310 --> 00:05:31,200
is not copied anymore and we have a nice

00:05:26,850 --> 00:05:33,090
implication from that stay click block

00:05:31,200 --> 00:05:36,390
some uninitialized kernel stack variable

00:05:33,090 --> 00:05:40,850
attacks there are nice examples and I

00:05:36,390 --> 00:05:45,840
really like the write up by case cook

00:05:40,850 --> 00:05:51,450
which describes how to exploit such kind

00:05:45,840 --> 00:05:54,120
of floor this diagram shows it we have

00:05:51,450 --> 00:06:00,450
now three system calls on the first

00:05:54,120 --> 00:06:02,790
system called the attacker prepares the

00:06:00,450 --> 00:06:06,380
payload in the user space this target

00:06:02,790 --> 00:06:09,680
address and it has copied copy from user

00:06:06,380 --> 00:06:14,360
it is copied to the kernel thread stack

00:06:09,680 --> 00:06:21,180
the second system call has a bug in it

00:06:14,360 --> 00:06:24,450
we the payload number two is copied to

00:06:21,180 --> 00:06:28,260
the address which is not initialized so

00:06:24,450 --> 00:06:32,820
it turns into so-called arbitrary right

00:06:28,260 --> 00:06:35,400
primitive and the attacker controls the

00:06:32,820 --> 00:06:38,610
target address with the first system

00:06:35,400 --> 00:06:39,520
call and now the payload number two

00:06:38,610 --> 00:06:42,130
which is prepared

00:06:39,520 --> 00:06:44,560
by the attacker is copied to the user to

00:06:42,130 --> 00:06:48,009
the kernel space and the third system

00:06:44,560 --> 00:06:50,680
call can be used to trigger the payload

00:06:48,009 --> 00:06:53,370
and elevate the privileges so it is a

00:06:50,680 --> 00:06:58,000
local privilege escalation exploit and

00:06:53,370 --> 00:07:01,750
what does this technique do to mitigate

00:06:58,000 --> 00:07:06,250
that at the end of the first system call

00:07:01,750 --> 00:07:08,050
where when that payload number one who

00:07:06,250 --> 00:07:11,979
was copied to the kernel space it is

00:07:08,050 --> 00:07:16,960
overwritten by - beef with insta click

00:07:11,979 --> 00:07:21,430
erase function and then later the abbot

00:07:16,960 --> 00:07:25,539
rewrite primitive from which we had

00:07:21,430 --> 00:07:28,479
previously turned into copying data - -

00:07:25,539 --> 00:07:32,169
beef which points to the unused hole

00:07:28,479 --> 00:07:37,530
into in the virtual memory so it will

00:07:32,169 --> 00:07:41,319
give a fault and the user space process

00:07:37,530 --> 00:07:44,889
which called it will be killed

00:07:41,319 --> 00:07:49,240
so the uninitialized stack variable

00:07:44,889 --> 00:07:51,940
attack is mitigated with that and there

00:07:49,240 --> 00:07:57,270
is an important limitation steglich

00:07:51,940 --> 00:08:00,219
doesn't mitigate such attacks which

00:07:57,270 --> 00:08:02,639
which are which happened during one

00:08:00,219 --> 00:08:05,169
single system called because the erase

00:08:02,639 --> 00:08:08,880
cyclic erase function is called at the

00:08:05,169 --> 00:08:11,919
end of the system call you the attack is

00:08:08,880 --> 00:08:13,770
performed before we can do nothing about

00:08:11,919 --> 00:08:17,919
it

00:08:13,770 --> 00:08:21,460
now the third security feature steglich

00:08:17,919 --> 00:08:29,430
blocks stack collage attack it has one

00:08:21,460 --> 00:08:33,190
of one kind of stack depth of floor and

00:08:29,430 --> 00:08:35,589
if we want the mainline kernel to be

00:08:33,190 --> 00:08:38,320
defended against stack depth overflow

00:08:35,589 --> 00:08:41,079
all kinds which we know right now we

00:08:38,320 --> 00:08:44,229
need three security three config options

00:08:41,079 --> 00:08:47,200
altogether it is config thread info in

00:08:44,229 --> 00:08:50,089
task which moves the thread and fall out

00:08:47,200 --> 00:08:53,180
of the bottom of the kernel step

00:08:50,089 --> 00:08:57,589
thread stack second we need the map

00:08:53,180 --> 00:09:01,100
stick function config option which adds

00:08:57,589 --> 00:09:03,860
guard pages around our stack and finally

00:09:01,100 --> 00:09:07,579
we need to stay click which block stack

00:09:03,860 --> 00:09:10,579
clash attack how does it work the idea

00:09:07,579 --> 00:09:15,470
of specular attack is quite old it was

00:09:10,579 --> 00:09:18,199
published for the first time at 2005 and

00:09:15,470 --> 00:09:27,040
then later it was revisited by Corliss

00:09:18,199 --> 00:09:29,509
research team in 2017 the it uses a

00:09:27,040 --> 00:09:34,569
variable-length arrays which were

00:09:29,509 --> 00:09:37,540
already covered by case today and there

00:09:34,569 --> 00:09:41,569
the memory for variable length array is

00:09:37,540 --> 00:09:45,410
allocated on the on the stack with Aloka

00:09:41,569 --> 00:09:50,029
and if we if the attacker controls the

00:09:45,410 --> 00:09:54,829
size of the array it could make he can

00:09:50,029 --> 00:09:58,160
make the kernel allocate a lot of memory

00:09:54,829 --> 00:10:00,889
and the end of the allocation will jump

00:09:58,160 --> 00:10:04,160
over the guard page and the attacker now

00:10:00,889 --> 00:10:07,699
can overwrite the neighbor memory which

00:10:04,160 --> 00:10:10,670
is next to the kernel thread stack it

00:10:07,699 --> 00:10:17,170
can be another process stack or some

00:10:10,670 --> 00:10:20,509
heap object so either it can be used for

00:10:17,170 --> 00:10:23,990
privilege elevation again and what does

00:10:20,509 --> 00:10:28,600
the Kliq do about that on every before

00:10:23,990 --> 00:10:32,620
every a locker call there is this code

00:10:28,600 --> 00:10:38,470
running if we have the allocation size

00:10:32,620 --> 00:10:42,559
big bigger or equal to the space left we

00:10:38,470 --> 00:10:45,019
call panic or bug depending on our

00:10:42,559 --> 00:10:52,220
config options and it is hated by Lee

00:10:45,019 --> 00:10:56,870
knows you may guess why I will cover it

00:10:52,220 --> 00:10:59,529
a little bit later ok and what is the

00:10:56,870 --> 00:11:03,740
price what is the performance impact

00:10:59,529 --> 00:11:07,610
there is there it is the result

00:11:03,740 --> 00:11:10,220
of the first performance test which is

00:11:07,610 --> 00:11:13,760
quite attractive we see that building

00:11:10,220 --> 00:11:17,410
the Linux kernel on one core gives us

00:11:13,760 --> 00:11:20,960
less than 1% of performance of

00:11:17,410 --> 00:11:24,380
performance penalty and there is another

00:11:20,960 --> 00:11:29,930
test which is not so attractive the hug

00:11:24,380 --> 00:11:35,600
bench synthetic test it runs it starts a

00:11:29,930 --> 00:11:38,150
lot of threads which send short messages

00:11:35,600 --> 00:11:41,240
to each others so there are a lot of

00:11:38,150 --> 00:11:44,510
short system calls the stack is erased

00:11:41,240 --> 00:11:51,560
at the end of the each call and we have

00:11:44,510 --> 00:11:54,440
more than 4% performance penalty so the

00:11:51,560 --> 00:11:56,900
conclusion about performance stay click

00:11:54,440 --> 00:11:59,600
performance penalty varies for different

00:11:56,900 --> 00:12:03,190
workloads so before deploying in

00:11:59,600 --> 00:12:06,260
production first you should evaluate the

00:12:03,190 --> 00:12:09,740
performance impact on your expected fork

00:12:06,260 --> 00:12:13,550
load and I've added the technique

00:12:09,740 --> 00:12:17,240
metrics feature which shows how much of

00:12:13,550 --> 00:12:22,100
the stack space is used for the special

00:12:17,240 --> 00:12:24,160
process and then after evaluating the

00:12:22,100 --> 00:12:27,560
performance penalty you can decide

00:12:24,160 --> 00:12:34,610
whether it is fine for your case on your

00:12:27,560 --> 00:12:37,850
system now before I speak about the app

00:12:34,610 --> 00:12:42,850
streaming process I should say that

00:12:37,850 --> 00:12:47,000
Stickley consists of two parts first is

00:12:42,850 --> 00:12:48,590
the code which raises the used part of

00:12:47,000 --> 00:12:52,640
the kernel stack at the end of this call

00:12:48,590 --> 00:12:55,670
and the second part is the GCC plugin

00:12:52,640 --> 00:12:59,570
which is responsible for compile time

00:12:55,670 --> 00:13:04,970
instrumentation it does it is needed for

00:12:59,570 --> 00:13:06,860
two tasks first it is needed for

00:13:04,970 --> 00:13:09,890
tracking the lowest border of a kernel

00:13:06,860 --> 00:13:11,780
stack because we raised on the used part

00:13:09,890 --> 00:13:16,070
of the kernel stack so when we need to

00:13:11,780 --> 00:13:16,590
know where how much of the stack we used

00:13:16,070 --> 00:13:19,590
your

00:13:16,590 --> 00:13:22,980
this is called handling and second it

00:13:19,590 --> 00:13:29,580
adds a local check which was hated by

00:13:22,980 --> 00:13:31,770
linson dropped and now a long thrilling

00:13:29,580 --> 00:13:34,670
story of stick lick up streaming the way

00:13:31,770 --> 00:13:38,700
it reminds me famous Russian painting

00:13:34,670 --> 00:13:45,089
the hunters at rest so you can see how

00:13:38,700 --> 00:13:48,900
they share the experience which they had

00:13:45,089 --> 00:13:52,050
in forests and it is the same about the

00:13:48,900 --> 00:13:55,980
kernel developers which they experience

00:13:52,050 --> 00:14:00,930
about what they encountered in the Linux

00:13:55,980 --> 00:14:05,670
kernel mailing list so it is a timeline

00:14:00,930 --> 00:14:09,300
it started in April 2017 when jar

00:14:05,670 --> 00:14:11,250
security decided to close their public

00:14:09,300 --> 00:14:14,450
patches and in May

00:14:11,250 --> 00:14:19,529
I decided decided to work on stack leak

00:14:14,450 --> 00:14:25,530
I continued the word the work which was

00:14:19,529 --> 00:14:27,750
started by Tycho Anderson and sent the

00:14:25,530 --> 00:14:30,450
first version to the Linux kernel

00:14:27,750 --> 00:14:33,750
mailing list and I should say that I was

00:14:30,450 --> 00:14:38,310
learning stack leak bit by bit so the

00:14:33,750 --> 00:14:41,520
was a cover letter when I wrote that to

00:14:38,310 --> 00:14:44,940
do so at the first on the first

00:14:41,520 --> 00:14:48,020
iteration I just learned how they stack

00:14:44,940 --> 00:14:51,570
raising written in assembly language

00:14:48,020 --> 00:14:55,230
works and I marked in to do that I

00:14:51,570 --> 00:14:59,780
should learn how GCC plugin works and

00:14:55,230 --> 00:15:03,690
what is what it is used for but suddenly

00:14:59,780 --> 00:15:08,790
in the middle of June the stack clash

00:15:03,690 --> 00:15:14,550
report by koalas was published and there

00:15:08,790 --> 00:15:19,440
are security published their blog post

00:15:14,550 --> 00:15:24,150
about stack lash and the Linux kernel

00:15:19,440 --> 00:15:27,839
and they trolled me and my up streaming

00:15:24,150 --> 00:15:29,640
efforts saying that we just copy/paste

00:15:27,839 --> 00:15:33,310
without understanding

00:15:29,640 --> 00:15:36,010
at the same time I marked in to do that

00:15:33,310 --> 00:15:38,620
ice I need to learn the DCC plugin I'm

00:15:36,010 --> 00:15:40,930
only at the beginning anyway I

00:15:38,620 --> 00:15:46,240
understood that I'm in the middle of

00:15:40,930 --> 00:15:50,140
this events going on and I should

00:15:46,240 --> 00:15:54,760
proceed on the third version I learned

00:15:50,140 --> 00:15:58,350
and documented the GCC plugin found some

00:15:54,760 --> 00:16:02,830
bugs in it then on the fourth version I

00:15:58,350 --> 00:16:05,860
learned the assertions which technique

00:16:02,830 --> 00:16:09,370
adds in stock tracking and a lock

00:16:05,860 --> 00:16:13,779
checking and there were errors in them

00:16:09,370 --> 00:16:15,910
again I fixed them then I found all the

00:16:13,779 --> 00:16:19,990
points where the stack should be erased

00:16:15,910 --> 00:16:21,490
because there are multiple ways from the

00:16:19,990 --> 00:16:25,330
kernel space to use a space at the end

00:16:21,490 --> 00:16:31,960
of this system call and I found a point

00:16:25,330 --> 00:16:38,460
which stack erasing was missed and then

00:16:31,960 --> 00:16:45,490
later in December there was a really

00:16:38,460 --> 00:16:50,830
short and interesting email sound like

00:16:45,490 --> 00:16:53,860
that did you see this patches called PTY

00:16:50,830 --> 00:16:58,839
PTI page table oscillation

00:16:53,860 --> 00:17:02,290
did you try to to rebase on them so IRA

00:16:58,839 --> 00:17:06,040
based on PTI which introduced the

00:17:02,290 --> 00:17:10,839
trampoline stack some intermediates

00:17:06,040 --> 00:17:13,179
stack which is used after before we go

00:17:10,839 --> 00:17:17,380
from the kernel space to the user space

00:17:13,179 --> 00:17:21,310
and later in January meltdown was

00:17:17,380 --> 00:17:23,800
published again I felt that I'm in the

00:17:21,310 --> 00:17:26,910
middle of this hurricane it was really

00:17:23,800 --> 00:17:31,510
impressive then some version during some

00:17:26,910 --> 00:17:36,250
month I was ignored and okay I thought

00:17:31,510 --> 00:17:39,870
that I'm ready for up streaming but

00:17:36,250 --> 00:17:43,250
version 9 sadly was burned by Lee knows

00:17:39,870 --> 00:17:51,570
he appeared in the

00:17:43,250 --> 00:17:58,280
email thread and told a lot of angry

00:17:51,570 --> 00:18:01,470
words but anyway he stated that

00:17:58,280 --> 00:18:04,710
variable-length arrays are bad by

00:18:01,470 --> 00:18:07,620
default and we should clean up the

00:18:04,710 --> 00:18:12,150
kernel from them and his cook started

00:18:07,620 --> 00:18:14,510
this movement of vlog cleanup there are

00:18:12,150 --> 00:18:19,040
more than 15 people I guess

00:18:14,510 --> 00:18:23,400
participating and it started by this

00:18:19,040 --> 00:18:27,020
email from Lee knows anyway I was

00:18:23,400 --> 00:18:32,670
emotionally dead for several weeks but

00:18:27,020 --> 00:18:35,280
then my wife helped me and I decided to

00:18:32,670 --> 00:18:42,390
extract the technical objection

00:18:35,280 --> 00:18:44,940
objections from this angry words and the

00:18:42,390 --> 00:18:48,809
main objection was that stack raising is

00:18:44,940 --> 00:18:52,410
written in assembly language and so

00:18:48,809 --> 00:18:56,190
maintenance don't like it

00:18:52,410 --> 00:19:00,450
because it is quite a lot of assembly

00:18:56,190 --> 00:19:04,950
and ideas I decided to rewrite it in C

00:19:00,450 --> 00:19:08,670
was not easy because it has tricky to

00:19:04,950 --> 00:19:11,820
make the GCC compiler create you the

00:19:08,670 --> 00:19:15,090
binary which looks at similar to

00:19:11,820 --> 00:19:18,120
handwritten assembly anyway I came up

00:19:15,090 --> 00:19:21,900
with the next version which was called

00:19:18,120 --> 00:19:25,790
stoke Stockholm Syndrome posh series by

00:19:21,900 --> 00:19:25,790
breast angler from general security

00:19:26,000 --> 00:19:34,770
there were more versions and at version

00:19:31,890 --> 00:19:39,470
14 I thought again that I'm really ready

00:19:34,770 --> 00:19:42,300
for mainline but the pull request for

00:19:39,470 --> 00:19:47,490
4.19 was burned by Linz at the second

00:19:42,300 --> 00:19:52,530
time because of this Bhagwan in a local

00:19:47,490 --> 00:19:55,290
checking and sticker raising again

00:19:52,530 --> 00:19:56,610
extracted the objections came up with

00:19:55,290 --> 00:20:01,100
the next version

00:19:56,610 --> 00:20:05,130
which avoids it and it was called

00:20:01,100 --> 00:20:09,020
version 15 sees Sisyphus edition quite

00:20:05,130 --> 00:20:12,600
funny again let's see what will happen

00:20:09,020 --> 00:20:19,580
it is not taken it is their pool request

00:20:12,600 --> 00:20:22,830
is not merged for for this release and

00:20:19,580 --> 00:20:25,710
now what is what are the changes from

00:20:22,830 --> 00:20:28,170
the original version how stick how my

00:20:25,710 --> 00:20:31,290
part series differs from the original

00:20:28,170 --> 00:20:34,830
Jersey curity patch first of all the

00:20:31,290 --> 00:20:38,179
there are bugs fixed in original

00:20:34,830 --> 00:20:41,669
technique GCC plugin their assertion

00:20:38,179 --> 00:20:46,169
instead tracking analog checks were

00:20:41,669 --> 00:20:50,240
wrong and I have fixed them and as I

00:20:46,169 --> 00:20:56,549
said there were points of stock-raising

00:20:50,240 --> 00:21:00,120
missing szostak was not erased in some

00:20:56,549 --> 00:21:03,270
cases there are there is plenty of

00:21:00,120 --> 00:21:07,020
refactoring which was done I extracted

00:21:03,270 --> 00:21:10,530
the common part for is porting to new

00:21:07,020 --> 00:21:14,910
platforms and it includes rewriting the

00:21:10,530 --> 00:21:20,520
stack arising in C which was tricky but

00:21:14,910 --> 00:21:24,440
it allowed is reporting to arm 64 which

00:21:20,520 --> 00:21:27,210
is done by Laura but thanks to here I

00:21:24,440 --> 00:21:29,700
got rid of hard-coded magic numbers

00:21:27,210 --> 00:21:31,830
documented the code so I prepared the

00:21:29,700 --> 00:21:37,460
patch series for the main line because

00:21:31,830 --> 00:21:41,340
the initial version is far from the

00:21:37,460 --> 00:21:45,150
usual requirements and it is the same

00:21:41,340 --> 00:21:49,490
about the code style and what is new

00:21:45,150 --> 00:21:53,419
functionality which was introduced this

00:21:49,490 --> 00:21:56,340
trampolines tech support which comes

00:21:53,419 --> 00:21:59,669
during page table as isolation

00:21:56,340 --> 00:22:03,150
they're nice tests which we wrote

00:21:59,669 --> 00:22:04,890
together with tae ho Andersen arm 64

00:22:03,150 --> 00:22:07,370
support which I already mentioned and

00:22:04,890 --> 00:22:13,730
GCC 8 support

00:22:07,370 --> 00:22:17,030
gc8 was released during my stay click up

00:22:13,730 --> 00:22:19,610
streaming efforts so we added the

00:22:17,030 --> 00:22:22,100
support for this new version and the new

00:22:19,610 --> 00:22:24,890
functionality which was requested by

00:22:22,100 --> 00:22:30,230
Ingham owner this technique matrix which

00:22:24,890 --> 00:22:33,170
allows you to see how much space of

00:22:30,230 --> 00:22:35,840
stack space is used during the current

00:22:33,170 --> 00:22:39,350
and previous system call for some

00:22:35,840 --> 00:22:41,480
process and this stack lik runtime

00:22:39,350 --> 00:22:44,080
disabled option which I don't like

00:22:41,480 --> 00:22:48,710
really because rent I'm disabling of

00:22:44,080 --> 00:22:51,710
security features you know I don't like

00:22:48,710 --> 00:22:54,260
it but Ingham owner fooled forced me so

00:22:51,710 --> 00:22:57,050
I added this sis control under their

00:22:54,260 --> 00:22:58,460
config option which is initially which

00:22:57,050 --> 00:23:01,580
is disabled by default

00:22:58,460 --> 00:23:07,040
so it is some kind of compromise which

00:23:01,580 --> 00:23:10,640
we found and dropped functionality as I

00:23:07,040 --> 00:23:13,430
said there the assertions in stack

00:23:10,640 --> 00:23:17,740
tracking were wrong I dropped that them

00:23:13,430 --> 00:23:21,800
and the first thing which triggered

00:23:17,740 --> 00:23:23,660
leanness was stack erasing after

00:23:21,800 --> 00:23:25,370
petraeus a comp and auditing which

00:23:23,660 --> 00:23:29,420
happens at the beginning of the system

00:23:25,370 --> 00:23:33,440
call so when leanness saw it he and he

00:23:29,420 --> 00:23:36,910
felt something bad and decided to burn

00:23:33,440 --> 00:23:42,080
it all and the local checking is dropped

00:23:36,910 --> 00:23:45,350
because bogan is now prohibited in the

00:23:42,080 --> 00:23:48,320
patches which come from the security

00:23:45,350 --> 00:23:50,830
developers but anyway the

00:23:48,320 --> 00:23:54,590
variable-length arrays will be removed

00:23:50,830 --> 00:24:00,950
and after they are completely removed

00:23:54,590 --> 00:24:03,860
there will be a global w of la flag at

00:24:00,950 --> 00:24:07,940
the same time i think that a local check

00:24:03,860 --> 00:24:14,540
would be good for the code which is not

00:24:07,940 --> 00:24:17,750
up streamed so but it is the only way

00:24:14,540 --> 00:24:20,800
how we can get to the mainline dropping

00:24:17,750 --> 00:24:26,230
this so let's see what will

00:24:20,800 --> 00:24:28,390
with the fifteenth version and as I said

00:24:26,230 --> 00:24:32,410
when stack leche was published bread

00:24:28,390 --> 00:24:35,080
Spangler said that we just copy and

00:24:32,410 --> 00:24:37,570
paste the gyre security code without

00:24:35,080 --> 00:24:39,340
understanding but I'm sure it is not

00:24:37,570 --> 00:24:47,590
applicable to stick lick up streaming

00:24:39,340 --> 00:24:50,950
efforts and a few words about what is

00:24:47,590 --> 00:24:53,290
burned by Lino's so it is strong

00:24:50,950 --> 00:24:57,790
language even swearing and there are

00:24:53,290 --> 00:25:00,010
examples I don't quote technical

00:24:57,790 --> 00:25:02,890
objections are mixed with them so you

00:25:00,010 --> 00:25:05,980
should put off your emotions and just

00:25:02,890 --> 00:25:08,380
try to extract what he means and he

00:25:05,980 --> 00:25:17,430
gives knock without looking and patches

00:25:08,380 --> 00:25:17,430
and it is difficult to to handle that so

00:25:17,790 --> 00:25:25,090
sometimes he simply simply ignores and

00:25:20,620 --> 00:25:27,220
it makes me think that he is by default

00:25:25,090 --> 00:25:28,060
irritated by Colonel hardening

00:25:27,220 --> 00:25:32,920
initiatives

00:25:28,060 --> 00:25:38,230
maybe but anyway I love Linux but all of

00:25:32,920 --> 00:25:41,560
that kills my motivation let's see what

00:25:38,230 --> 00:25:44,880
will happen with steglich if leanness

00:25:41,560 --> 00:25:48,460
will not merge it really my work will be

00:25:44,880 --> 00:25:51,250
Sisyphus work but if the click will

00:25:48,460 --> 00:25:53,620
finally find a way to the mainline it

00:25:51,250 --> 00:25:58,750
will survive like a phoenix through

00:25:53,620 --> 00:26:01,810
several flames and closing thoughts

00:25:58,750 --> 00:26:03,520
we are the Linux kernel community and we

00:26:01,810 --> 00:26:05,770
are responsible for all those machine

00:26:03,520 --> 00:26:10,000
which run our favorite operating system

00:26:05,770 --> 00:26:12,160
and if we put more effort to Linux

00:26:10,000 --> 00:26:12,970
kernel security we will definitely not

00:26:12,160 --> 00:26:15,870
be ignored

00:26:12,970 --> 00:26:20,650
thank you very much

00:26:15,870 --> 00:26:20,650
[Applause]

00:26:26,230 --> 00:26:32,740
so I wanted to ask about writing stuck

00:26:29,440 --> 00:26:36,100
arising in C so more or less how is it

00:26:32,740 --> 00:26:38,650
done because she doesn't give you direct

00:26:36,100 --> 00:26:42,010
access to registers like stack pointer

00:26:38,650 --> 00:26:44,320
so how do you do stack arising without

00:26:42,010 --> 00:26:48,040
accessing the registers or how do you

00:26:44,320 --> 00:26:51,190
access directly registers for see first

00:26:48,040 --> 00:26:55,390
of all there is a helper current top of

00:26:51,190 --> 00:26:58,930
stack in the Linux kernels so it is not

00:26:55,390 --> 00:27:04,720
a problem the main problem was was

00:26:58,930 --> 00:27:08,260
connected with with local variables

00:27:04,720 --> 00:27:10,780
which reside on which should reside in

00:27:08,260 --> 00:27:13,330
registers but not on the on the stack

00:27:10,780 --> 00:27:17,320
because we are arranging raising if a

00:27:13,330 --> 00:27:21,010
stack and it has the assumption which we

00:27:17,320 --> 00:27:24,940
make about the compiler that this

00:27:21,010 --> 00:27:33,120
function has as I remember for local

00:27:24,940 --> 00:27:35,800
variables and they are put they are the

00:27:33,120 --> 00:27:38,860
residing registers then another

00:27:35,800 --> 00:27:42,250
assumption was that during the raising

00:27:38,860 --> 00:27:49,780
the stack pointer doesn't change it was

00:27:42,250 --> 00:27:53,130
another assumption which which we just

00:27:49,780 --> 00:27:56,680
have but at the same time this

00:27:53,130 --> 00:28:00,130
trampoline stack it makes things easier

00:27:56,680 --> 00:28:03,460
because when we switch to trampoline

00:28:00,130 --> 00:28:06,130
stack and then we can erase the thread

00:28:03,460 --> 00:28:08,980
stack not from the bottom not from the

00:28:06,130 --> 00:28:10,870
lowest deck to stack pointer but to the

00:28:08,980 --> 00:28:13,780
top of the stack because we are at the

00:28:10,870 --> 00:28:17,770
separate stack right now so it makes

00:28:13,780 --> 00:28:23,920
things easier but there are cases when

00:28:17,770 --> 00:28:28,450
we erase stack being on it at the same

00:28:23,920 --> 00:28:30,279
time so now stock-raising supports both

00:28:28,450 --> 00:28:38,139
ways

00:28:30,279 --> 00:28:45,779
of work and another complicated thing

00:28:38,139 --> 00:28:49,779
was that GCC likes to optimize and when

00:28:45,779 --> 00:28:53,409
when the erasing is performed first we

00:28:49,779 --> 00:28:57,239
need to find the poison and then start

00:28:53,409 --> 00:29:01,929
from the poison it looks like that so

00:28:57,239 --> 00:29:06,879
there is a Lois stack and first of all

00:29:01,929 --> 00:29:09,399
we need to find 17 poison values on the

00:29:06,879 --> 00:29:15,159
on the stack and after we have found it

00:29:09,399 --> 00:29:19,799
we just go and write - beef between the

00:29:15,159 --> 00:29:19,799
found point and thread stack top and

00:29:22,320 --> 00:29:26,789
what did I want to say so

00:29:33,960 --> 00:29:37,190
yes and

00:29:44,570 --> 00:29:52,640
and as you see we don't erase the whole

00:29:49,880 --> 00:29:55,190
stack when I did some performance

00:29:52,640 --> 00:29:57,980
evaluation if I raise the whole stack it

00:29:55,190 --> 00:30:00,080
will give you a 40 percent of perform of

00:29:57,980 --> 00:30:04,070
performance penalty and we erase only

00:30:00,080 --> 00:30:10,850
the used part of the kernel stack and it

00:30:04,070 --> 00:30:13,160
makes it so fast that on the building

00:30:10,850 --> 00:30:21,140
the Linux kernel we have only less than

00:30:13,160 --> 00:30:25,310
1% of performance penalty so I and I

00:30:21,140 --> 00:30:30,500
want to say that the GCC wants to

00:30:25,310 --> 00:30:33,320
optimize this miss searching and when we

00:30:30,500 --> 00:30:38,360
come to the thread stack bottom on the

00:30:33,320 --> 00:30:40,640
first raising it it touched the guard

00:30:38,360 --> 00:30:46,790
page below the stack because the

00:30:40,640 --> 00:30:50,810
optimization loop was so that it read

00:30:46,790 --> 00:30:53,890
the next value below the struggle stack

00:30:50,810 --> 00:30:58,910
bottom and crack the kernel so I had to

00:30:53,890 --> 00:31:05,780
play with GCC to avoid this optimization

00:30:58,910 --> 00:31:12,080
and make it make the binary similar to

00:31:05,780 --> 00:31:12,860
initial assembly language version thanks

00:31:12,080 --> 00:31:18,200
for the question

00:31:12,860 --> 00:31:23,330
yes so some of us would actually like

00:31:18,200 --> 00:31:24,980
the bug on version of the patch maybe we

00:31:23,330 --> 00:31:28,610
can have a discussion afterwards about

00:31:24,980 --> 00:31:31,930
how to convince - that some of us want

00:31:28,610 --> 00:31:35,300
that feature I think first we should

00:31:31,930 --> 00:31:38,570
convince him to have stack leak even

00:31:35,300 --> 00:31:42,290
without bogging so if we have it in the

00:31:38,570 --> 00:31:46,370
main line then we can discuss further

00:31:42,290 --> 00:31:53,710
work there are several ideas working

00:31:46,370 --> 00:31:53,710
what can be done further so there is an

00:31:54,240 --> 00:32:03,720
there are more points where we can erase

00:31:58,000 --> 00:32:09,129
the Colonel's stack and but I think we

00:32:03,720 --> 00:32:12,090
can go with small steps and first we

00:32:09,129 --> 00:32:15,210
should have this success story of

00:32:12,090 --> 00:32:20,049
getting the city this security feature

00:32:15,210 --> 00:32:24,309
in the main line and then go to further

00:32:20,049 --> 00:32:37,240
goals we might need to introduce a

00:32:24,309 --> 00:32:39,159
security bug on version and I have that

00:32:37,240 --> 00:32:41,289
in the kernel it's used in two places I

00:32:39,159 --> 00:32:43,450
am completely terrified of pointing it

00:32:41,289 --> 00:32:45,970
out to leanness at this point so I'd

00:32:43,450 --> 00:32:49,330
like maybe to do that in the meantime

00:32:45,970 --> 00:32:52,450
people can set a panic on Warren as the

00:32:49,330 --> 00:32:53,980
workaround and that's not the first time

00:32:52,450 --> 00:32:57,240
that somebody's changed the name of

00:32:53,980 --> 00:32:59,230
something to get it up till in us I

00:32:57,240 --> 00:33:04,980
can't remember any of the others they

00:32:59,230 --> 00:33:04,980
don't ask ok any more questions

00:33:09,740 --> 00:33:17,880
have you tried to compile this your C

00:33:12,659 --> 00:33:24,830
routine using Silang now first of all

00:33:17,880 --> 00:33:29,010
this this has this GCC plugin which is

00:33:24,830 --> 00:33:33,059
works only with GCC and the

00:33:29,010 --> 00:33:36,510
stock-raising without it will give you a

00:33:33,059 --> 00:33:39,780
big performance penalty so I just didn't

00:33:36,510 --> 00:33:44,130
try to do anything with Clank because I

00:33:39,780 --> 00:33:46,110
depend on this GCC plugin but there is a

00:33:44,130 --> 00:33:50,700
plug-in is infrastructure in Clank as

00:33:46,110 --> 00:33:57,020
well so if it will work for the CC

00:33:50,700 --> 00:33:57,020
version we can do the same with clink

00:34:03,460 --> 00:34:06,590
okay thanks for all your effort in thank

00:34:05,830 --> 00:34:11,679
you

00:34:06,590 --> 00:34:11,679

YouTube URL: https://www.youtube.com/watch?v=5wIniiWSgUc


