Title: Year in Review: Android Kernel Security - Jeff Vander Stoep & Sami Tolvanen, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Year in Review: Android Kernel Security - Jeff Vander Stoep & Sami Tolvanen, Google

The Linux kernel provides Androidâ€™s trusted computing base and is the primary enforcer of Androidâ€™s security model. Increasingly, itâ€™s also the primary target for privilege escalation attacks. Letâ€™s dive into the details and discuss:
- Data data data! Where/how the kernel is being attacked. An analysis of the kernel security bugs reported to Google.
- Discussion on the effectiveness of recently introduced mitigations.
- New kernel mitigations introduced in the Android Open Source Project.
- Kernel security wishlist.

About Jeff Vander Stoep
Jeff Vander Stoep is a software engineer on the Android security team at Google where he is working on security improvements to the Android platform.

About Sami Tolvanen
Sami Tolvanen is a software engineer on the Android Platform Security team, currently focusing on kernel hardening.
Captions: 
	00:00:00,030 --> 00:00:04,680
okay um so before we get started and I

00:00:03,540 --> 00:00:08,099
have some acknowledgments we're gonna

00:00:04,680 --> 00:00:11,130
discuss a whole bunch of vulnerabilities

00:00:08,099 --> 00:00:14,759
that apply to the Linux kernel and

00:00:11,130 --> 00:00:15,900
Android specifically so part of the

00:00:14,759 --> 00:00:17,820
acknowledgments are the people who

00:00:15,900 --> 00:00:19,470
reported these bugs and the people that

00:00:17,820 --> 00:00:23,010
triage them and then also a few other

00:00:19,470 --> 00:00:25,619
people helped with the both kind of the

00:00:23,010 --> 00:00:26,880
content of these slides as well as some

00:00:25,619 --> 00:00:30,080
of the technical work that we'll be

00:00:26,880 --> 00:00:30,080
discussing later

00:00:30,830 --> 00:00:34,829
so another note is that all of this data

00:00:33,750 --> 00:00:37,020
is public data

00:00:34,829 --> 00:00:38,820
so Android produces a monthly Security

00:00:37,020 --> 00:00:40,140
Bulletin and so you can actually go and

00:00:38,820 --> 00:00:44,579
look at all the bugs that were

00:00:40,140 --> 00:00:47,579
discussing and I did want to discuss a

00:00:44,579 --> 00:00:50,039
caveat here which is that the data that

00:00:47,579 --> 00:00:52,559
we're gonna be discussing is comprised

00:00:50,039 --> 00:00:54,590
of vulnerabilities reported to Google

00:00:52,559 --> 00:00:57,899
from a bunch of different sources

00:00:54,590 --> 00:00:59,940
including from Google or from Android

00:00:57,899 --> 00:01:01,739
vendor vendors some from the upstream

00:00:59,940 --> 00:01:04,439
kernel and then from external

00:01:01,739 --> 00:01:07,229
researchers and so we're going to try to

00:01:04,439 --> 00:01:10,020
infer some patterns and problems based

00:01:07,229 --> 00:01:13,380
on this data but it's important to point

00:01:10,020 --> 00:01:16,080
out that the data almost certainly has

00:01:13,380 --> 00:01:20,460
some bias vulnerability research tends

00:01:16,080 --> 00:01:23,040
to be somewhat fashionable so for

00:01:20,460 --> 00:01:29,670
example the last year people have been

00:01:23,040 --> 00:01:32,490
looking at shared resource attacks like

00:01:29,670 --> 00:01:35,970
speculative reading so like Spectre

00:01:32,490 --> 00:01:39,329
meltdown type vulnerabilities but we see

00:01:35,970 --> 00:01:41,700
we see similar things in the subsystems

00:01:39,329 --> 00:01:42,930
that people are looking at looking into

00:01:41,700 --> 00:01:45,090
and the types of bugs that they're

00:01:42,930 --> 00:01:49,860
finding so I just want to have that

00:01:45,090 --> 00:01:52,020
caveat that while we while we're going

00:01:49,860 --> 00:01:55,409
to try to infer some some things from

00:01:52,020 --> 00:02:01,170
this data the data itself probably has

00:01:55,409 --> 00:02:03,780
some bias in it and then of course

00:02:01,170 --> 00:02:09,330
Android is an open source project so you

00:02:03,780 --> 00:02:12,040
can submit patches and bug fixes okay so

00:02:09,330 --> 00:02:13,810
why are we discussing the kernel so

00:02:12,040 --> 00:02:16,000
currently the kernel accounts for about

00:02:13,810 --> 00:02:18,099
a third of the security bugs that we

00:02:16,000 --> 00:02:20,400
have on Android the kernel is part of

00:02:18,099 --> 00:02:23,519
androids trusted computing base and so

00:02:20,400 --> 00:02:28,239
it's an important area to look at

00:02:23,519 --> 00:02:30,519
especially now when people want to

00:02:28,239 --> 00:02:32,890
compromise Android it's often easiest to

00:02:30,519 --> 00:02:34,150
go straight to the kernel as opposed to

00:02:32,890 --> 00:02:39,579
in the past where people would try to

00:02:34,150 --> 00:02:41,620
exploit privileged system processes so

00:02:39,579 --> 00:02:44,560
what's what's what's working well in

00:02:41,620 --> 00:02:46,780
terms of protecting the kernel attack

00:02:44,560 --> 00:02:49,799
surface reduction is is working really

00:02:46,780 --> 00:02:53,109
well I've managed to get a quote out of

00:02:49,799 --> 00:02:54,639
project zero where they basically say

00:02:53,109 --> 00:02:56,950
that some of the attack surface

00:02:54,639 --> 00:02:59,549
reduction that we've been doing is what

00:02:56,950 --> 00:03:02,200
they view as most effective in terms of

00:02:59,549 --> 00:03:05,769
mitigating these types of

00:03:02,200 --> 00:03:08,019
vulnerabilities and then I'm going to

00:03:05,769 --> 00:03:11,409
try to show some data which I think

00:03:08,019 --> 00:03:15,150
backs up their statement the nice part

00:03:11,409 --> 00:03:17,919
about act about attack surface reduction

00:03:15,150 --> 00:03:19,389
is that access controls which is mostly

00:03:17,919 --> 00:03:22,329
what I what I'm going to be discussing

00:03:19,389 --> 00:03:23,379
our hard mitigations so we can apply we

00:03:22,329 --> 00:03:27,099
can apply this type of mitigation

00:03:23,379 --> 00:03:30,870
without actually knowing what types of

00:03:27,099 --> 00:03:33,459
vulnerabilities there are or or

00:03:30,870 --> 00:03:41,220
knowledge of specific exploitation

00:03:33,459 --> 00:03:44,650
techniques okay so so when we look at

00:03:41,220 --> 00:03:46,840
attack surface reduction I actually want

00:03:44,650 --> 00:03:48,699
to look at all of the kernel

00:03:46,840 --> 00:03:50,919
vulnerabilities and then which one of

00:03:48,699 --> 00:03:55,150
those are made in accessible to

00:03:50,919 --> 00:03:57,729
untrusted processes so this data is

00:03:55,150 --> 00:04:00,579
looking very specifically at kernel

00:03:57,729 --> 00:04:02,919
vulnerabilities that are reachable from

00:04:00,579 --> 00:04:05,439
user space but unreachable to

00:04:02,919 --> 00:04:06,760
unprivileged processes on android and

00:04:05,439 --> 00:04:10,419
unprivileged process would be like a

00:04:06,760 --> 00:04:13,150
third party app or we also include some

00:04:10,419 --> 00:04:17,620
of the media processes as being

00:04:13,150 --> 00:04:20,370
unprivileged as well another type of

00:04:17,620 --> 00:04:23,860
data that is excluded here is data that

00:04:20,370 --> 00:04:25,479
or it are the other type of

00:04:23,860 --> 00:04:25,840
vulnerability that's excluded here are

00:04:25,479 --> 00:04:27,340
vole

00:04:25,840 --> 00:04:29,650
abilities that require you to have

00:04:27,340 --> 00:04:34,389
already completely compromised the

00:04:29,650 --> 00:04:36,400
security of the system so we we call

00:04:34,389 --> 00:04:38,229
these type of vulnerabilities you have

00:04:36,400 --> 00:04:40,510
to root the device in order to root the

00:04:38,229 --> 00:04:45,120
device so we're excluding that because

00:04:40,510 --> 00:04:47,770
those are those are uninteresting so

00:04:45,120 --> 00:04:49,660
looking at the the different attack

00:04:47,770 --> 00:04:51,820
surface reduction mechanisms that we use

00:04:49,660 --> 00:04:55,900
so I'm what I'm going to do is I'm going

00:04:51,820 --> 00:04:58,900
to break this graph into the components

00:04:55,900 --> 00:05:01,270
that add up to it I've been told that

00:04:58,900 --> 00:05:03,790
this is somewhat confusing so what it is

00:05:01,270 --> 00:05:07,630
is if you imagine that 90% of our

00:05:03,790 --> 00:05:10,150
vulnerabilities are mitigated through

00:05:07,630 --> 00:05:13,900
access control mechanisms then in this

00:05:10,150 --> 00:05:15,850
graph we we show you the different

00:05:13,900 --> 00:05:18,760
access control mechanisms and what

00:05:15,850 --> 00:05:22,750
percentage of vulnerabilities they

00:05:18,760 --> 00:05:28,210
mitigate against so obviously SELinux is

00:05:22,750 --> 00:05:30,639
the largest one but I well the only way

00:05:28,210 --> 00:05:34,479
this makes sense is that there's overlap

00:05:30,639 --> 00:05:37,380
in these so a great example is that when

00:05:34,479 --> 00:05:40,320
we look at kernel vulnerabilities

00:05:37,380 --> 00:05:42,220
specifically than UNIX permissions

00:05:40,320 --> 00:05:44,919
everything that was mitigated through

00:05:42,220 --> 00:05:47,110
UNIX permissions was also mitigated by

00:05:44,919 --> 00:05:49,090
selinux that's not true of all

00:05:47,110 --> 00:05:54,849
vulnerabilities on Android but that is

00:05:49,090 --> 00:05:57,610
true for kernel vulnerabilities so so I

00:05:54,849 --> 00:05:59,099
wrote down some example for each one of

00:05:57,610 --> 00:06:02,770
these that you can look up if you want

00:05:59,099 --> 00:06:05,820
but in the case of my example for

00:06:02,770 --> 00:06:09,010
SELinux this one was a debug FS node

00:06:05,820 --> 00:06:12,340
which you could exploit with a buffer

00:06:09,010 --> 00:06:19,389
overwrite for UNIX permissions

00:06:12,340 --> 00:06:22,450
it was a dev flash dev slash sound node

00:06:19,389 --> 00:06:24,280
so an audio driver bug that you needed

00:06:22,450 --> 00:06:26,440
the correct UNIX permissions and the

00:06:24,280 --> 00:06:29,639
correct SEO and sperm ish ins and then

00:06:26,440 --> 00:06:32,349
finally for for capabilities on Android

00:06:29,639 --> 00:06:36,430
untrusted processes can create UNIX

00:06:32,349 --> 00:06:38,500
sockets or not UNIX sockets raw sockets

00:06:36,430 --> 00:06:39,500
so in this case in order to reach this

00:06:38,500 --> 00:06:41,060
bug you had to be able

00:06:39,500 --> 00:06:44,930
create a rocket which an unprivileged

00:06:41,060 --> 00:06:48,980
process may do and you needed cap cap

00:06:44,930 --> 00:06:50,990
net raw in order to reach it so this bug

00:06:48,980 --> 00:06:53,870
would be unreachable to unprivileged

00:06:50,990 --> 00:07:02,800
process dudu files are due to

00:06:53,870 --> 00:07:07,190
capabilities another kind of note on on

00:07:02,800 --> 00:07:10,280
some of this data is that is somewhat

00:07:07,190 --> 00:07:12,500
conservative in that in this previous

00:07:10,280 --> 00:07:15,080
slide where i've got about 90% are

00:07:12,500 --> 00:07:16,790
mitigated if we couldn't actually

00:07:15,080 --> 00:07:18,800
determine reach ability which sometimes

00:07:16,790 --> 00:07:21,230
we can't because we get bug reports and

00:07:18,800 --> 00:07:25,130
no proof of concepts along with them and

00:07:21,230 --> 00:07:26,810
sometimes we just have to be

00:07:25,130 --> 00:07:30,410
conservative and say we think this is

00:07:26,810 --> 00:07:41,240
reachable from a third party app because

00:07:30,410 --> 00:07:44,419
we get lots of bugs so also starting

00:07:41,240 --> 00:07:47,930
with android oreo which is the data that

00:07:44,419 --> 00:07:49,340
we're using here we we also had a asset

00:07:47,930 --> 00:07:52,220
calm process which was applied to all

00:07:49,340 --> 00:08:01,520
apps and so that also blocked access to

00:07:52,220 --> 00:08:03,830
a few bugs this particular CV that I

00:08:01,520 --> 00:08:06,350
mentioned here is there was a

00:08:03,830 --> 00:08:10,130
vulnerability in the move pages syscall

00:08:06,350 --> 00:08:13,370
and we don't use that syscall on android

00:08:10,130 --> 00:08:15,290
so just blocking it to everyone prevents

00:08:13,370 --> 00:08:20,960
access to this particular particular

00:08:15,290 --> 00:08:23,120
vulnerability so I guess the summary

00:08:20,960 --> 00:08:24,860
from this section is that the the kernel

00:08:23,120 --> 00:08:27,440
provides us with some pretty good tools

00:08:24,860 --> 00:08:29,720
to protect the kernel from user space

00:08:27,440 --> 00:08:32,719
and attack surface reduction works

00:08:29,720 --> 00:08:35,900
really well and on Android we've got

00:08:32,719 --> 00:08:38,320
some pretty good data showing that we

00:08:35,900 --> 00:08:40,810
will also it's not like we're done

00:08:38,320 --> 00:08:43,849
applying attack surface reduction or

00:08:40,810 --> 00:08:46,070
principle of leach lease privileged from

00:08:43,849 --> 00:08:47,720
user space to the kernel so hopefully

00:08:46,070 --> 00:08:50,410
these numbers will also continue to get

00:08:47,720 --> 00:08:50,410
better with time

00:08:50,980 --> 00:08:58,389
looking at the the unprivileged

00:08:53,470 --> 00:09:01,869
reachable bugs the biggest problem is

00:08:58,389 --> 00:09:03,609
the GPU which is one of the few hardware

00:09:01,869 --> 00:09:06,879
drivers that are actually accessible to

00:09:03,609 --> 00:09:08,919
apps on Android so but it's also

00:09:06,879 --> 00:09:11,739
important to note that a bunch of the

00:09:08,919 --> 00:09:15,419
reachable bugs are reachable our bugs

00:09:11,739 --> 00:09:19,749
that we get from the upstream kernel so

00:09:15,419 --> 00:09:23,470
in other words a lot of a lot of the we

00:09:19,749 --> 00:09:27,819
get a lot of bugs from poorly written

00:09:23,470 --> 00:09:31,389
vendor drivers in the case of the GPU on

00:09:27,819 --> 00:09:33,779
Android that is a problem but in general

00:09:31,389 --> 00:09:39,519
we're able to block those by by doing

00:09:33,779 --> 00:09:41,139
sandboxing so for example only the audio

00:09:39,519 --> 00:09:43,149
house should be able to access audio

00:09:41,139 --> 00:09:45,399
drivers and therefore if there's a

00:09:43,149 --> 00:09:48,809
vulnerability in the audio driver you

00:09:45,399 --> 00:09:48,809
can't reach it as a third party app

00:09:53,300 --> 00:09:57,770
so there's also a couple of other really

00:09:56,000 --> 00:10:01,030
nice userspace to Colonel mitigations

00:09:57,770 --> 00:10:04,600
that have been introduced recently so

00:10:01,030 --> 00:10:07,280
this graph just shows the root cause of

00:10:04,600 --> 00:10:09,860
userspace reachable bugs on Android and

00:10:07,280 --> 00:10:12,290
of course the biggest problem that we

00:10:09,860 --> 00:10:14,150
have is that people either don't check

00:10:12,290 --> 00:10:16,580
bounds or they check them incorrectly

00:10:14,150 --> 00:10:19,340
allowing you to read out of bounds or

00:10:16,580 --> 00:10:22,550
right out of bounds and so that's why

00:10:19,340 --> 00:10:25,790
we're excited about hardened user copy

00:10:22,550 --> 00:10:30,490
which was introduced in the upstream

00:10:25,790 --> 00:10:32,510
kernel in the last year ish and then

00:10:30,490 --> 00:10:37,430
back ported to all of the Android

00:10:32,510 --> 00:10:44,840
kernels because it ya provides a

00:10:37,430 --> 00:10:46,910
mitigation against this this area but

00:10:44,840 --> 00:10:51,890
specifically by it by hardening the copy

00:10:46,910 --> 00:10:54,050
to or from user functions we also have

00:10:51,890 --> 00:10:57,380
something called pan privileged access

00:10:54,050 --> 00:11:00,050
never or never allow privileged access

00:10:57,380 --> 00:11:03,230
never anyway whatever it's called what

00:11:00,050 --> 00:11:05,210
it's used for is that it prevents the

00:11:03,230 --> 00:11:07,460
kernel from directly accessing a user

00:11:05,210 --> 00:11:08,780
space processes memory so there's a

00:11:07,460 --> 00:11:12,610
couple of reasons why that's that's

00:11:08,780 --> 00:11:16,640
really useful the first is that it

00:11:12,610 --> 00:11:17,870
forces all communication to and from the

00:11:16,640 --> 00:11:20,660
kernel to actually go through those

00:11:17,870 --> 00:11:24,080
hardened those newly hardened copy to

00:11:20,660 --> 00:11:27,230
and from user functions but the other

00:11:24,080 --> 00:11:30,740
reason is that the kernel directly

00:11:27,230 --> 00:11:35,090
accessing a user space processes memory

00:11:30,740 --> 00:11:37,880
is really really racy and so we want to

00:11:35,090 --> 00:11:39,890
prevent that because if the kernel is

00:11:37,880 --> 00:11:42,830
trying to access this process is memory

00:11:39,890 --> 00:11:45,080
and the process is directly changing it

00:11:42,830 --> 00:11:47,450
at the same time then obviously that

00:11:45,080 --> 00:11:51,260
could cause kernel bugs and so when we

00:11:47,450 --> 00:11:59,480
were rolling out pan we hit multiple

00:11:51,260 --> 00:12:01,040
instances of this issue and and we know

00:11:59,480 --> 00:12:03,530
that this is a problem and partner in

00:12:01,040 --> 00:12:05,180
partner devices and in other Android

00:12:03,530 --> 00:12:05,720
devices other than the ones we directly

00:12:05,180 --> 00:12:08,990
work with

00:12:05,720 --> 00:12:12,680
I did have one one interesting story

00:12:08,990 --> 00:12:14,959
where we created a test that said in our

00:12:12,680 --> 00:12:17,500
compatibility test suite which all which

00:12:14,959 --> 00:12:19,910
all Android devices have to pass that

00:12:17,500 --> 00:12:23,720
said that this was a requirement and we

00:12:19,910 --> 00:12:26,149
we had a an OEM that children shall

00:12:23,720 --> 00:12:30,310
remain nameless he said but I can't turn

00:12:26,149 --> 00:12:32,569
this on it causes my kernel to crash so

00:12:30,310 --> 00:12:36,250
we let them know that that was working

00:12:32,569 --> 00:12:36,250
as intended and they needed to fix that

00:12:38,740 --> 00:12:45,889
so I keep caveat in everything with user

00:12:43,129 --> 00:12:48,230
space accessible kernel vulnerabilities

00:12:45,889 --> 00:12:53,209
and unfortunately not all kernel vulns

00:12:48,230 --> 00:12:55,430
are reached from user space so we've

00:12:53,209 --> 00:12:57,860
been discussing about the two thirds of

00:12:55,430 --> 00:13:02,689
kernel bugs that are reachable from user

00:12:57,860 --> 00:13:07,939
space but about a third are not so let's

00:13:02,689 --> 00:13:11,029
let's get into these a little bit so I

00:13:07,939 --> 00:13:14,449
actually broke them down from where they

00:13:11,029 --> 00:13:22,069
are reachable from as well as the root

00:13:14,449 --> 00:13:25,490
cause of the vulnerability so well yeah

00:13:22,069 --> 00:13:30,230
but that's actually so someone said it's

00:13:25,490 --> 00:13:33,079
Wi-Fi so part of the reason why I wanted

00:13:30,230 --> 00:13:34,879
a caveat earlier that bug finding tends

00:13:33,079 --> 00:13:38,420
to be somewhat trendy is because that

00:13:34,879 --> 00:13:40,129
could be the case here right maybe if we

00:13:38,420 --> 00:13:41,930
ran the same analysis in a month maybe

00:13:40,129 --> 00:13:46,309
it would be Bluetooth or maybe it would

00:13:41,930 --> 00:13:50,000
be USB but the the point I want to make

00:13:46,309 --> 00:13:51,680
here is mostly that all of those lovely

00:13:50,000 --> 00:13:54,230
mitigations that we're talking about

00:13:51,680 --> 00:13:55,699
access controls hardened user copy pan

00:13:54,230 --> 00:13:57,470
things like that those are just

00:13:55,699 --> 00:13:59,509
completely irrelevant here we have

00:13:57,470 --> 00:14:02,120
kernel bugs and we have no we have

00:13:59,509 --> 00:14:05,269
absolutely no mitigations to prevent

00:14:02,120 --> 00:14:07,399
those kernel bugs and you know yes the

00:14:05,269 --> 00:14:11,420
Wi-Fi driver is a bit of a dumpster fire

00:14:07,399 --> 00:14:14,300
but you know I I fully expect people

00:14:11,420 --> 00:14:16,339
will be looking at USB and and find the

00:14:14,300 --> 00:14:17,510
same thing if the same amount of

00:14:16,339 --> 00:14:19,910
resources were

00:14:17,510 --> 00:14:21,140
into that the other thing is is there's

00:14:19,910 --> 00:14:23,260
gonna be a nice talk line says caller

00:14:21,140 --> 00:14:25,370
that's happening later things like

00:14:23,260 --> 00:14:30,080
automated fussing through sis caller

00:14:25,370 --> 00:14:33,140
also not looking here so I guess one of

00:14:30,080 --> 00:14:34,430
the positive things is that kernel bugs

00:14:33,140 --> 00:14:37,040
that are reachable through the Wi-Fi

00:14:34,430 --> 00:14:38,960
firmer would first require that you have

00:14:37,040 --> 00:14:42,110
code running in the Wi-Fi firmware to

00:14:38,960 --> 00:14:43,940
reach to reach those right so so in some

00:14:42,110 --> 00:14:45,940
ways there there is some access control

00:14:43,940 --> 00:14:48,620
going on here

00:14:45,940 --> 00:14:49,790
and then of course the other the other

00:14:48,620 --> 00:14:52,700
issue and the reason why I wanted to

00:14:49,790 --> 00:14:56,030
discuss lack of using harder hard lack

00:14:52,700 --> 00:14:58,280
of hardened user copy is that clearly

00:14:56,030 --> 00:15:00,590
missing an incorrect bounds check is an

00:14:58,280 --> 00:15:04,340
even larger problem in in this subset of

00:15:00,590 --> 00:15:11,030
bugs we really need something doing

00:15:04,340 --> 00:15:14,150
bounds checking on the heap yeah

00:15:11,030 --> 00:15:17,150
and again looking at kind of the the

00:15:14,150 --> 00:15:19,610
trendiness of bug finding a large subset

00:15:17,150 --> 00:15:22,100
of these bugs are the correct

00:15:19,610 --> 00:15:25,520
voluntaries which are just weaknesses in

00:15:22,100 --> 00:15:30,760
the WPA protocol one thing that I will

00:15:25,520 --> 00:15:34,100
say from an Android perspective is that

00:15:30,760 --> 00:15:36,890
the only safe assumption on a network is

00:15:34,100 --> 00:15:40,490
that the network is untrusted so if you

00:15:36,890 --> 00:15:43,010
are relying on WPA or you know

00:15:40,490 --> 00:15:44,750
encryption on one hop you were already

00:15:43,010 --> 00:15:47,150
in bad shape

00:15:44,750 --> 00:15:49,160
I could probably create an access point

00:15:47,150 --> 00:15:50,480
call it Starbucks and half the phones in

00:15:49,160 --> 00:15:53,030
the room would connect to it right like

00:15:50,480 --> 00:15:55,330
WPA is not keeping you safe I think it's

00:15:53,030 --> 00:15:57,980
good that we patch it but that's the

00:15:55,330 --> 00:16:04,700
only safe assumption is that the network

00:15:57,980 --> 00:16:07,160
is is untrusted okay so kind of a

00:16:04,700 --> 00:16:09,590
summary from this section is that user

00:16:07,160 --> 00:16:11,360
space to kernel we've got a lot of good

00:16:09,590 --> 00:16:13,180
tools there those are provided by the

00:16:11,360 --> 00:16:17,270
upstream kernel and they actually are

00:16:13,180 --> 00:16:19,730
fairly effective however about a third

00:16:17,270 --> 00:16:21,970
of the kernel bugs are reached by other

00:16:19,730 --> 00:16:24,770
vectors and it would be nice if we had

00:16:21,970 --> 00:16:29,900
both access good access control

00:16:24,770 --> 00:16:32,570
mechanisms as well as good good

00:16:29,900 --> 00:16:38,890
like a bounce checking for example or

00:16:32,570 --> 00:16:49,940
yeah the and then finally I wanted to

00:16:38,890 --> 00:16:53,029
talk briefly about memory unsafety so so

00:16:49,940 --> 00:16:56,450
this is again about all kernel bugs not

00:16:53,029 --> 00:16:58,880
just user space or other vector

00:16:56,450 --> 00:17:02,240
reachable bugs but clearly when we

00:16:58,880 --> 00:17:05,780
actually look at add bounds checking the

00:17:02,240 --> 00:17:07,400
the major problem is the heap and so we

00:17:05,780 --> 00:17:09,970
have some protections for the stack

00:17:07,400 --> 00:17:12,860
right we've got a stack protector and

00:17:09,970 --> 00:17:15,290
and some other things that are going to

00:17:12,860 --> 00:17:17,300
be discussed later but really what we

00:17:15,290 --> 00:17:20,240
need are protections for the heap so

00:17:17,300 --> 00:17:23,059
that if you do something like override a

00:17:20,240 --> 00:17:24,829
function pointer you don't just um you

00:17:23,059 --> 00:17:28,990
you haven't just immediately taken over

00:17:24,829 --> 00:17:31,400
control of of the kernel so with that

00:17:28,990 --> 00:17:39,980
Sammy's gonna discuss some of the work

00:17:31,400 --> 00:17:43,100
that we're doing there all right so I'm

00:17:39,980 --> 00:17:45,350
gonna say a few words about CFI control

00:17:43,100 --> 00:17:47,000
flow integrity which is the latest

00:17:45,350 --> 00:17:54,200
medication we added to android kernels

00:17:47,000 --> 00:17:56,600
in android 9 see if I helps protect

00:17:54,200 --> 00:17:59,300
against code reuse attacks it tries to

00:17:56,600 --> 00:18:00,980
accomplish this by adding runtime checks

00:17:59,300 --> 00:18:03,880
to ensure that the program's control

00:18:00,980 --> 00:18:06,980
flow stays within a pre computed graph

00:18:03,880 --> 00:18:10,010
in practice LLVM CFI implementation

00:18:06,980 --> 00:18:12,530
which we use focuses only on protecting

00:18:10,010 --> 00:18:15,100
the forward edge for C programs this

00:18:12,530 --> 00:18:17,720
basically means indirect branches

00:18:15,100 --> 00:18:21,860
luckily the kernel has plenty of those

00:18:17,720 --> 00:18:23,960
so it's decent starting place I would

00:18:21,860 --> 00:18:26,420
see if I'm LLVM had to check before each

00:18:23,960 --> 00:18:28,280
indirect branch to ensure that the

00:18:26,420 --> 00:18:31,240
target address points to the beginning

00:18:28,280 --> 00:18:34,130
of a valid function with correct type

00:18:31,240 --> 00:18:38,990
this limits the number of potential

00:18:34,130 --> 00:18:41,150
targets where the kernel can jump before

00:18:38,990 --> 00:18:43,130
we continue into more details let's take

00:18:41,150 --> 00:18:46,250
a look at how effective Olivia

00:18:43,130 --> 00:18:48,049
see if I actually is in the kernel first

00:18:46,250 --> 00:18:50,900
of all see if I is a soft mitigation

00:18:48,049 --> 00:18:52,549
that's not alone going to prevent an

00:18:50,900 --> 00:18:53,630
attacker from exploiting a sufficiently

00:18:52,549 --> 00:18:57,230
bad kernel bug

00:18:53,630 --> 00:18:58,850
however together with other current and

00:18:57,230 --> 00:19:02,150
future medications it will make

00:18:58,850 --> 00:19:04,160
exploding bugs more difficult this is a

00:19:02,150 --> 00:19:07,520
graph generated from an actual Android

00:19:04,160 --> 00:19:09,559
device kernel which shows the number of

00:19:07,520 --> 00:19:14,570
potential core targets efi allows for

00:19:09,559 --> 00:19:16,610
each indirect call without C if I'm an

00:19:14,570 --> 00:19:19,010
attacker who is able to modify a

00:19:16,610 --> 00:19:20,539
function pointer can jump anywhere but

00:19:19,010 --> 00:19:22,220
we'd see a 5 more than half of all

00:19:20,539 --> 00:19:25,850
indirect calls can branch only to a

00:19:22,220 --> 00:19:32,150
handful of functions now and 80% have at

00:19:25,850 --> 00:19:33,470
most 20 possible targets of course due

00:19:32,150 --> 00:19:36,860
to the limitations of the function

00:19:33,470 --> 00:19:39,289
signature page based approach we still

00:19:36,860 --> 00:19:41,539
have for the two most common function

00:19:39,289 --> 00:19:42,890
types in the kernel more than 1000

00:19:41,539 --> 00:19:46,820
possible functions where the kernel can

00:19:42,890 --> 00:19:48,440
jump but this applies to less than 1% of

00:19:46,820 --> 00:19:51,320
all indirect calls in the kernel and it

00:19:48,440 --> 00:19:52,909
still limits the attackers options and

00:19:51,320 --> 00:19:59,510
it prevents them from jumping to an

00:19:52,909 --> 00:20:01,190
arbitrary gadget for example in order

00:19:59,510 --> 00:20:02,600
for the compiler to determine valid call

00:20:01,190 --> 00:20:05,480
targets it needs to see the entire

00:20:02,600 --> 00:20:08,059
program or at least all the relevant

00:20:05,480 --> 00:20:09,770
parts of the program in the girls case

00:20:08,059 --> 00:20:13,640
the compiler won't see standalone

00:20:09,770 --> 00:20:16,400
assembly code for example lbm solves the

00:20:13,640 --> 00:20:19,669
visibility problem by requiring link

00:20:16,400 --> 00:20:21,770
time of the optimization or LTL where

00:20:19,669 --> 00:20:24,440
each compilation unit is first compiled

00:20:21,770 --> 00:20:26,330
into LLVM specific bit code which is had

00:20:24,440 --> 00:20:28,429
link time combined and inspected all at

00:20:26,330 --> 00:20:30,559
once

00:20:28,429 --> 00:20:32,690
unfortunately LTL somewhat complicates

00:20:30,559 --> 00:20:34,400
matters when it comes to the kernel not

00:20:32,690 --> 00:20:37,070
only do we need to switch to an LTO over

00:20:34,400 --> 00:20:38,990
linker but we also need to use LVM

00:20:37,070 --> 00:20:42,140
integrated assembler for all inline

00:20:38,990 --> 00:20:43,909
assembly because of this most of the

00:20:42,140 --> 00:20:45,770
issues we run into when adding LTO

00:20:43,909 --> 00:20:50,960
support to android kernels were actually

00:20:45,770 --> 00:20:52,309
toolchain compatibility issues some

00:20:50,960 --> 00:20:55,790
changes to kernel build spirits were

00:20:52,309 --> 00:20:56,930
needed but those were greatly simplified

00:20:55,790 --> 00:20:58,730
by the upstream dinner

00:20:56,930 --> 00:21:01,790
work which already removed all the

00:20:58,730 --> 00:21:04,220
intermediate linking steps we did have

00:21:01,790 --> 00:21:06,440
to use few LVM tools for generating

00:21:04,220 --> 00:21:09,080
symbol tables for bit code files for

00:21:06,440 --> 00:21:14,150
example but but there were not many

00:21:09,080 --> 00:21:17,660
changes here we have a simplified view

00:21:14,150 --> 00:21:18,950
of how LTI works with clang in the

00:21:17,660 --> 00:21:20,630
kernel we have some code that's

00:21:18,950 --> 00:21:22,430
translated directly into object files

00:21:20,630 --> 00:21:24,080
but the vast majority is compiled into

00:21:22,430 --> 00:21:25,940
bit code

00:21:24,080 --> 00:21:28,370
everything is added into thin archive

00:21:25,940 --> 00:21:29,900
which is then passed to the linker the

00:21:28,370 --> 00:21:32,420
linker Lucas the archive combines all

00:21:29,900 --> 00:21:34,070
the bit code optimizes composite into

00:21:32,420 --> 00:21:38,480
native code and everything is linked

00:21:34,070 --> 00:21:40,760
together in the end we ask for feedback

00:21:38,480 --> 00:21:44,030
about LTI from kernel maintain airs last

00:21:40,760 --> 00:21:47,990
year and many of them expressed concerns

00:21:44,030 --> 00:21:50,030
about possibly unsafe optimizations that

00:21:47,990 --> 00:21:52,670
might break the kernels memory model for

00:21:50,030 --> 00:21:56,000
example during the past several months

00:21:52,670 --> 00:22:00,590
we have tested LTO kernels extensively

00:21:56,000 --> 00:22:01,910
and on actual devices and we have not

00:22:00,590 --> 00:22:04,210
run into any issues that could be

00:22:01,910 --> 00:22:07,280
attributed to LT yeom

00:22:04,210 --> 00:22:09,620
in fact we are confident in a confident

00:22:07,280 --> 00:22:11,600
enough in LTO that first android devices

00:22:09,620 --> 00:22:18,080
running an LTO kernel will ship later

00:22:11,600 --> 00:22:20,900
this year once the problems with LTL

00:22:18,080 --> 00:22:23,450
were sorted out adding CFI support was

00:22:20,900 --> 00:22:25,340
relatively simple the biggest challenge

00:22:23,450 --> 00:22:28,730
was fixing all the benign CFI failures

00:22:25,340 --> 00:22:30,470
in the existing code C compilers don't

00:22:28,730 --> 00:22:32,870
currently in for similar restrictions to

00:22:30,470 --> 00:22:34,670
CF is runtime checks so there was a fair

00:22:32,870 --> 00:22:39,080
amount of coding the kernel that trips

00:22:34,670 --> 00:22:41,300
efi which we had to first fix another

00:22:39,080 --> 00:22:44,390
complication for kernel modules the

00:22:41,300 --> 00:22:45,740
compiler obviously doesn't see all the

00:22:44,390 --> 00:22:49,400
modules especially if they're compiled

00:22:45,740 --> 00:22:52,160
out of tree we adapted LLVM x' cross TSO

00:22:49,400 --> 00:22:54,620
CFI support to handle kernel modules

00:22:52,160 --> 00:22:57,140
each module now has its own CFI check

00:22:54,620 --> 00:23:00,050
function which determines the valid call

00:22:57,140 --> 00:23:01,610
targets for that specific module and the

00:23:00,050 --> 00:23:03,620
kernel looks up the correct check

00:23:01,610 --> 00:23:08,210
function to call based on the target

00:23:03,620 --> 00:23:10,760
address obviously this needs to have as

00:23:08,210 --> 00:23:12,920
little overhead as possible

00:23:10,760 --> 00:23:14,270
which brings me to the point that

00:23:12,920 --> 00:23:15,860
everyone has in their mind when it comes

00:23:14,270 --> 00:23:23,450
to security medications which is

00:23:15,860 --> 00:23:25,070
performance in our tests a colonel

00:23:23,450 --> 00:23:27,500
compiled with LTO and see if I actually

00:23:25,070 --> 00:23:30,620
performed slightly better than the base

00:23:27,500 --> 00:23:35,720
colonel obviously due to LT of more

00:23:30,620 --> 00:23:37,520
aggressive optimizations and here we

00:23:35,720 --> 00:23:40,400
have an example of a CFR failure that we

00:23:37,520 --> 00:23:41,810
run into here's a single function

00:23:40,400 --> 00:23:44,240
pointer that's used to call a large

00:23:41,810 --> 00:23:47,720
number of functions all with different

00:23:44,240 --> 00:23:50,360
argument types the compiler is naturally

00:23:47,720 --> 00:23:53,090
perfectly fine with this but to see if I

00:23:50,360 --> 00:23:54,710
run time check fails we fix this

00:23:53,090 --> 00:23:56,720
upstream a while ago with a clear

00:23:54,710 --> 00:24:01,940
solution that doesn't use mismatching

00:23:56,720 --> 00:24:03,980
function pointers this is what a

00:24:01,940 --> 00:24:08,000
compiler injected runtime check looks

00:24:03,980 --> 00:24:10,640
like on our m60 form before an indirect

00:24:08,000 --> 00:24:12,710
call the compiler has a call to see if I

00:24:10,640 --> 00:24:15,650
check function which validates a target

00:24:12,710 --> 00:24:18,140
address it's passed a hash of the

00:24:15,650 --> 00:24:22,130
expected type information and if the

00:24:18,140 --> 00:24:25,070
check fails it simply never returns and

00:24:22,130 --> 00:24:26,690
this is why it doesn't return its when

00:24:25,070 --> 00:24:28,250
the see if I check fails we first print

00:24:26,690 --> 00:24:31,640
out the target address to help us

00:24:28,250 --> 00:24:33,500
pinpoint the issue and once EFI is

00:24:31,640 --> 00:24:36,770
enabled in normal mode it panics the

00:24:33,500 --> 00:24:39,890
kernel immediately we also added a

00:24:36,770 --> 00:24:41,480
permissive mode which changes the panic

00:24:39,890 --> 00:24:43,840
into a warning instead which makes it

00:24:41,480 --> 00:24:45,950
easier to debug these failures

00:24:43,840 --> 00:24:48,500
especially if they occur in early build

00:24:45,950 --> 00:24:50,390
for example but it should be noted that

00:24:48,500 --> 00:24:52,520
the permissive mode has absolutely no

00:24:50,390 --> 00:24:56,530
security benefits and should only be

00:24:52,520 --> 00:24:56,530
used during testing or device bring up

00:24:57,960 --> 00:25:03,210
our CFI implementation is available

00:25:00,480 --> 00:25:07,529
right now in android carlos 4.9 and 414

00:25:03,210 --> 00:25:10,590
which you can find from a USB it's only

00:25:07,529 --> 00:25:12,779
forearm 64 at the moment you also need a

00:25:10,590 --> 00:25:14,879
recent enough clang and B new tools to

00:25:12,779 --> 00:25:16,379
compile the kernel and for anyone

00:25:14,879 --> 00:25:22,259
interested in testing this these are

00:25:16,379 --> 00:25:25,669
config options you need to enable and

00:25:22,259 --> 00:25:28,320
finally if you knows about future work

00:25:25,669 --> 00:25:31,139
since llbmc if I only protects forward

00:25:28,320 --> 00:25:33,240
branches forward edge we are looking

00:25:31,139 --> 00:25:36,389
into other solutions for also protecting

00:25:33,240 --> 00:25:39,809
return addresses better we previously

00:25:36,389 --> 00:25:41,970
looked into LVM safe stack which which

00:25:39,809 --> 00:25:43,830
works but to do memory overhead concerns

00:25:41,970 --> 00:25:46,909
we are not focusing on the newer shadow

00:25:43,830 --> 00:25:49,110
call stack medication instead and

00:25:46,909 --> 00:25:51,720
because of the numerous problems we run

00:25:49,110 --> 00:25:54,559
into with the gold linker we also

00:25:51,720 --> 00:25:56,909
looking into replacing it with LVM LLD

00:25:54,559 --> 00:25:58,529
which hopefully reduces the

00:25:56,909 --> 00:26:02,309
compatibility issues we run into a

00:25:58,529 --> 00:26:04,549
little bit and that's all I have thank

00:26:02,309 --> 00:26:04,549
you

00:26:04,940 --> 00:26:11,349
[Applause]

00:26:13,660 --> 00:26:16,660
questions

00:26:24,990 --> 00:26:32,220
so I had a question about previous topic

00:26:27,900 --> 00:26:35,610
about attack surface reduction I've

00:26:32,220 --> 00:26:40,110
noticed one thing that in that one of

00:26:35,610 --> 00:26:44,010
the things that caused bugs in kernel

00:26:40,110 --> 00:26:47,370
was binder the IPC mechanism right so

00:26:44,010 --> 00:26:50,400
how does the attack surface reduction in

00:26:47,370 --> 00:26:54,030
binder work is it just adding the

00:26:50,400 --> 00:26:55,800
explicit checks in code that connects on

00:26:54,030 --> 00:26:57,840
the other side of the IPC or is it

00:26:55,800 --> 00:27:00,740
something more like with a seal enix or

00:26:57,840 --> 00:27:00,740
something like that

00:27:01,520 --> 00:27:05,370
vulnerabilities from binder to the

00:27:03,390 --> 00:27:08,100
kernel or from binder to other processes

00:27:05,370 --> 00:27:10,559
no no because the talk was about kernel

00:27:08,100 --> 00:27:13,110
so from by indirect kernel so there's

00:27:10,559 --> 00:27:17,429
basically no attack surface reduction

00:27:13,110 --> 00:27:20,280
from processes to binder and I think we

00:27:17,429 --> 00:27:23,010
had one binder vulnerability in the last

00:27:20,280 --> 00:27:25,130
year so since all apps have to be able

00:27:23,010 --> 00:27:27,240
to use binder that that particular

00:27:25,130 --> 00:27:31,130
vulnerability was accessible so that

00:27:27,240 --> 00:27:35,780
that was included in the group of

00:27:31,130 --> 00:27:35,780
unprivileged reachable vulnerabilities

00:27:38,960 --> 00:27:42,530
any other questions

00:27:47,690 --> 00:27:56,250
Stephen did you get to look at gr

00:27:52,740 --> 00:28:02,280
security strap design implementation at

00:27:56,250 --> 00:28:05,430
all yes we did but since we are using

00:28:02,280 --> 00:28:09,260
plan for our kernels we decided to go

00:28:05,430 --> 00:28:09,260
with LOV Ames medications instead

00:28:24,200 --> 00:28:29,059
hi there I really appreciate the data

00:28:26,730 --> 00:28:32,669
it's nice to see it presented like that

00:28:29,059 --> 00:28:36,360
you mentioned 25 percent of the

00:28:32,669 --> 00:28:41,159
unprivileged reachable bugs were from

00:28:36,360 --> 00:28:44,580
GPU drivers what kind of helps support

00:28:41,159 --> 00:28:47,909
instructions smack on the head do you

00:28:44,580 --> 00:28:49,289
give to set vendors so that they can

00:28:47,909 --> 00:28:52,620
improve the security of their GPU

00:28:49,289 --> 00:28:55,950
drivers yeah so a couple of things that

00:28:52,620 --> 00:28:57,809
we're doing first of all I I like having

00:28:55,950 --> 00:28:59,700
the slide up there because I can kind of

00:28:57,809 --> 00:29:04,820
use that to go tell people that hey this

00:28:59,700 --> 00:29:04,820
is a problem so a couple of things that

00:29:06,770 --> 00:29:09,990
so a couple things that we can look at

00:29:08,730 --> 00:29:12,480
one nice thing about attack surface

00:29:09,990 --> 00:29:14,130
reduction is by reducing the available

00:29:12,480 --> 00:29:16,710
attack surface we can actually focus

00:29:14,130 --> 00:29:19,890
resources on the remaining surface

00:29:16,710 --> 00:29:23,700
better right so we can put for example

00:29:19,890 --> 00:29:25,559
fuzzing resources there or code review

00:29:23,700 --> 00:29:27,510
resources there whereas if we had the

00:29:25,559 --> 00:29:30,809
entire kernel that would be a bit

00:29:27,510 --> 00:29:34,649
overwhelming but other other topics that

00:29:30,809 --> 00:29:38,070
I am hoping to be able to use this data

00:29:34,649 --> 00:29:40,020
for are things like maybe GPU access

00:29:38,070 --> 00:29:42,330
maybe the GPU should not be directly

00:29:40,020 --> 00:29:43,980
accessible from unprivileged apps right

00:29:42,330 --> 00:29:47,820
so we've moved all of these other things

00:29:43,980 --> 00:29:49,649
out of our unprivileged sandboxes and

00:29:47,820 --> 00:29:51,899
that's kind of one of the few that's

00:29:49,649 --> 00:29:54,890
hanging around so maybe we need to start

00:29:51,899 --> 00:29:54,890
looking at that as well

00:30:03,430 --> 00:30:08,840
so the Android team has done a lot of

00:30:06,440 --> 00:30:10,100
work to make it much easier to do update

00:30:08,840 --> 00:30:12,650
kernels which is um you know fantastic

00:30:10,100 --> 00:30:14,630
for the ecosystem have you noticed that

00:30:12,650 --> 00:30:16,100
having any impact on the number of bugs

00:30:14,630 --> 00:30:19,100
in terms of you know either good bad

00:30:16,100 --> 00:30:23,870
ugly what do you mean by update kernels

00:30:19,100 --> 00:30:25,370
you know faster being able to get more

00:30:23,870 --> 00:30:27,400
up-to-date kernels such as opposed to

00:30:25,370 --> 00:30:29,510
being stuck on an older versions because

00:30:27,400 --> 00:30:31,580
om is just don't update them and

00:30:29,510 --> 00:30:32,840
requiring newer ones with things like

00:30:31,580 --> 00:30:37,690
project trouble and everything like that

00:30:32,840 --> 00:30:40,820
yeah so the the kernel requirements now

00:30:37,690 --> 00:30:42,770
which did not used to exist are for

00:30:40,820 --> 00:30:46,250
example I think when you launch if you

00:30:42,770 --> 00:30:49,550
launch a device with Android P you have

00:30:46,250 --> 00:30:53,630
to have a four nine kernel or newer on

00:30:49,550 --> 00:30:55,790
it what that doesn't mean is that

00:30:53,630 --> 00:30:58,040
doesn't mean that they will then ever

00:30:55,790 --> 00:31:04,370
update the kernel version for that

00:30:58,040 --> 00:31:05,840
device so I you're right in that no

00:31:04,370 --> 00:31:07,430
longer will devices be launched with

00:31:05,840 --> 00:31:10,160
these ancient kernels the way they

00:31:07,430 --> 00:31:11,870
sometimes were in the past

00:31:10,160 --> 00:31:13,190
but yeah there's there's no requirement

00:31:11,870 --> 00:31:15,170
that they actually update the kernel

00:31:13,190 --> 00:31:20,780
version on a device once it's been

00:31:15,170 --> 00:31:22,100
launched so but yeah it helps and from

00:31:20,780 --> 00:31:23,600
from our perspective we're getting all

00:31:22,100 --> 00:31:26,180
these nice mitigations and upstream

00:31:23,600 --> 00:31:27,740
kernels and so it's nice to know that we

00:31:26,180 --> 00:31:29,060
have to do less work and that partners

00:31:27,740 --> 00:31:30,500
have to do less work because those

00:31:29,060 --> 00:31:33,470
mitigations are just built right into

00:31:30,500 --> 00:31:35,870
the kernel one of the reasons why I like

00:31:33,470 --> 00:31:38,120
to present data like like I've been

00:31:35,870 --> 00:31:40,250
presenting particularly at this

00:31:38,120 --> 00:31:42,050
conference is that I know people are

00:31:40,250 --> 00:31:44,000
able to take that data and actually use

00:31:42,050 --> 00:31:45,530
it to justify work and I know that for

00:31:44,000 --> 00:31:49,040
example people from arm have been able

00:31:45,530 --> 00:31:51,680
to say oh we we can see that the the

00:31:49,040 --> 00:31:53,690
heap is a real problem and that buffer

00:31:51,680 --> 00:31:57,050
overruns in the heap are a major issue

00:31:53,690 --> 00:32:03,290
so let's let's use that data and justify

00:31:57,050 --> 00:32:05,680
putting resources towards that any other

00:32:03,290 --> 00:32:05,680
questions

00:32:07,460 --> 00:32:10,120
all righty

00:32:08,820 --> 00:32:14,750
thank you

00:32:10,120 --> 00:32:14,750

YouTube URL: https://www.youtube.com/watch?v=Yng44_9oTBM


