Title: Year in Review: Android Kernel Security - Jeff Vander Stoep & Sami Tolvanen, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Year in Review: Android Kernel Security - Jeff Vander Stoep & Sami Tolvanen, Google

The Linux kernel provides Android’s trusted computing base and is the primary enforcer of Android’s security model. Increasingly, it’s also the primary target for privilege escalation attacks. Let’s dive into the details and discuss:
- Data data data! Where/how the kernel is being attacked. An analysis of the kernel security bugs reported to Google.
- Discussion on the effectiveness of recently introduced mitigations.
- New kernel mitigations introduced in the Android Open Source Project.
- Kernel security wishlist.

About Jeff Vander Stoep
Jeff Vander Stoep is a software engineer on the Android security team at Google where he is working on security improvements to the Android platform.

About Sami Tolvanen
Sami Tolvanen is a software engineer on the Android Platform Security team, currently focusing on kernel hardening.
Captions: 
	00:00:00,030 --> 00:00:04,680
okay um so before we get started and I

00:00:03,540 --> 00:00:08,099
have some acknowledgments we're gonna

00:00:04,680 --> 00:00:11,130
discuss a whole bunch of vulnerabilities

00:00:08,099 --> 00:00:14,759
that apply to the Linux kernel and

00:00:11,130 --> 00:00:15,900
Android specifically so part of the

00:00:14,759 --> 00:00:17,820
acknowledgments are the people who

00:00:15,900 --> 00:00:19,470
reported these bugs and the people that

00:00:17,820 --> 00:00:23,010
triage them and then also a few other

00:00:19,470 --> 00:00:25,619
people helped with the both kind of the

00:00:23,010 --> 00:00:26,880
content of these slides as well as some

00:00:25,619 --> 00:00:30,080
of the technical work that we'll be

00:00:26,880 --> 00:00:30,080
discussing later

00:00:30,830 --> 00:00:34,829
so another note is that all of this data

00:00:33,750 --> 00:00:37,020
is public data

00:00:34,829 --> 00:00:38,820
so Android produces a monthly Security

00:00:37,020 --> 00:00:40,140
Bulletin and so you can actually go and

00:00:38,820 --> 00:00:44,579
look at all the bugs that were

00:00:40,140 --> 00:00:47,579
discussing and I did want to discuss a

00:00:44,579 --> 00:00:50,039
caveat here which is that the data that

00:00:47,579 --> 00:00:52,559
we're gonna be discussing is comprised

00:00:50,039 --> 00:00:54,590
of vulnerabilities reported to Google

00:00:52,559 --> 00:00:57,899
from a bunch of different sources

00:00:54,590 --> 00:00:59,940
including from Google or from Android

00:00:57,899 --> 00:01:01,739
vendor vendors some from the upstream

00:00:59,940 --> 00:01:04,439
kernel and then from external

00:01:01,739 --> 00:01:07,229
researchers and so we're going to try to

00:01:04,439 --> 00:01:10,020
infer some patterns and problems based

00:01:07,229 --> 00:01:13,380
on this data but it's important to point

00:01:10,020 --> 00:01:16,080
out that the data almost certainly has

00:01:13,380 --> 00:01:20,460
some bias vulnerability research tends

00:01:16,080 --> 00:01:23,040
to be somewhat fashionable so for

00:01:20,460 --> 00:01:29,670
example the last year people have been

00:01:23,040 --> 00:01:32,490
looking at shared resource attacks like

00:01:29,670 --> 00:01:35,970
speculative reading so like Spectre

00:01:32,490 --> 00:01:39,329
meltdown type vulnerabilities but we see

00:01:35,970 --> 00:01:41,700
we see similar things in the subsystems

00:01:39,329 --> 00:01:42,930
that people are looking at looking into

00:01:41,700 --> 00:01:45,090
and the types of bugs that they're

00:01:42,930 --> 00:01:49,860
finding so I just want to have that

00:01:45,090 --> 00:01:52,020
caveat that while we while we're going

00:01:49,860 --> 00:01:55,409
to try to infer some some things from

00:01:52,020 --> 00:02:01,170
this data the data itself probably has

00:01:55,409 --> 00:02:03,780
some bias in it and then of course

00:02:01,170 --> 00:02:09,330
Android is an open source project so you

00:02:03,780 --> 00:02:12,040
can submit patches and bug fixes okay so

00:02:09,330 --> 00:02:13,810
why are we discussing the kernel so

00:02:12,040 --> 00:02:16,000
currently the kernel accounts for about

00:02:13,810 --> 00:02:18,099
a third of the security bugs that we

00:02:16,000 --> 00:02:20,400
have on Android the kernel is part of

00:02:18,099 --> 00:02:23,519
androids trusted computing base and so

00:02:20,400 --> 00:02:28,239
it's an important area to look at

00:02:23,519 --> 00:02:30,519
especially now when people want to

00:02:28,239 --> 00:02:32,890
compromise Android it's often easiest to

00:02:30,519 --> 00:02:34,150
go straight to the kernel as opposed to

00:02:32,890 --> 00:02:39,579
in the past where people would try to

00:02:34,150 --> 00:02:41,620
exploit privileged system processes so

00:02:39,579 --> 00:02:44,560
what's what's what's working well in

00:02:41,620 --> 00:02:46,780
terms of protecting the kernel attack

00:02:44,560 --> 00:02:49,799
surface reduction is is working really

00:02:46,780 --> 00:02:53,109
well I've managed to get a quote out of

00:02:49,799 --> 00:02:54,639
project zero where they basically say

00:02:53,109 --> 00:02:56,950
that some of the attack surface

00:02:54,639 --> 00:02:59,549
reduction that we've been doing is what

00:02:56,950 --> 00:03:02,200
they view as most effective in terms of

00:02:59,549 --> 00:03:05,769
mitigating these types of

00:03:02,200 --> 00:03:08,019
vulnerabilities and then I'm going to

00:03:05,769 --> 00:03:11,409
try to show some data which I think

00:03:08,019 --> 00:03:15,150
backs up their statement the nice part

00:03:11,409 --> 00:03:17,919
about act about attack surface reduction

00:03:15,150 --> 00:03:19,389
is that access controls which is mostly

00:03:17,919 --> 00:03:22,329
what I what I'm going to be discussing

00:03:19,389 --> 00:03:23,379
our hard mitigations so we can apply we

00:03:22,329 --> 00:03:27,099
can apply this type of mitigation

00:03:23,379 --> 00:03:30,870
without actually knowing what types of

00:03:27,099 --> 00:03:33,459
vulnerabilities there are or or

00:03:30,870 --> 00:03:41,220
knowledge of specific exploitation

00:03:33,459 --> 00:03:44,650
techniques okay so so when we look at

00:03:41,220 --> 00:03:46,840
attack surface reduction I actually want

00:03:44,650 --> 00:03:48,699
to look at all of the kernel

00:03:46,840 --> 00:03:50,919
vulnerabilities and then which one of

00:03:48,699 --> 00:03:55,150
those are made in accessible to

00:03:50,919 --> 00:03:57,729
untrusted processes so this data is

00:03:55,150 --> 00:04:00,579
looking very specifically at kernel

00:03:57,729 --> 00:04:02,919
vulnerabilities that are reachable from

00:04:00,579 --> 00:04:05,439
user space but unreachable to

00:04:02,919 --> 00:04:06,760
unprivileged processes on android and

00:04:05,439 --> 00:04:10,419
unprivileged process would be like a

00:04:06,760 --> 00:04:13,150
third party app or we also include some

00:04:10,419 --> 00:04:17,620
of the media processes as being

00:04:13,150 --> 00:04:20,370
unprivileged as well another type of

00:04:17,620 --> 00:04:23,860
data that is excluded here is data that

00:04:20,370 --> 00:04:25,479
or it are the other type of

00:04:23,860 --> 00:04:25,840
vulnerability that's excluded here are

00:04:25,479 --> 00:04:27,340
vole

00:04:25,840 --> 00:04:29,650
abilities that require you to have

00:04:27,340 --> 00:04:34,389
already completely compromised the

00:04:29,650 --> 00:04:36,400
security of the system so we we call

00:04:34,389 --> 00:04:38,229
these type of vulnerabilities you have

00:04:36,400 --> 00:04:40,510
to root the device in order to root the

00:04:38,229 --> 00:04:45,120
device so we're excluding that because

00:04:40,510 --> 00:04:47,770
those are those are uninteresting so

00:04:45,120 --> 00:04:49,660
looking at the the different attack

00:04:47,770 --> 00:04:51,820
surface reduction mechanisms that we use

00:04:49,660 --> 00:04:55,900
so I'm what I'm going to do is I'm going

00:04:51,820 --> 00:04:58,900
to break this graph into the components

00:04:55,900 --> 00:05:01,270
that add up to it I've been told that

00:04:58,900 --> 00:05:03,790
this is somewhat confusing so what it is

00:05:01,270 --> 00:05:07,630
is if you imagine that 90% of our

00:05:03,790 --> 00:05:10,150
vulnerabilities are mitigated through

00:05:07,630 --> 00:05:13,900
access control mechanisms then in this

00:05:10,150 --> 00:05:15,850
graph we we show you the different

00:05:13,900 --> 00:05:18,760
access control mechanisms and what

00:05:15,850 --> 00:05:22,750
percentage of vulnerabilities they

00:05:18,760 --> 00:05:28,210
mitigate against so obviously SELinux is

00:05:22,750 --> 00:05:30,639
the largest one but I well the only way

00:05:28,210 --> 00:05:34,479
this makes sense is that there's overlap

00:05:30,639 --> 00:05:37,380
in these so a great example is that when

00:05:34,479 --> 00:05:40,320
we look at kernel vulnerabilities

00:05:37,380 --> 00:05:42,220
specifically than UNIX permissions

00:05:40,320 --> 00:05:44,919
everything that was mitigated through

00:05:42,220 --> 00:05:47,110
UNIX permissions was also mitigated by

00:05:44,919 --> 00:05:49,090
selinux that's not true of all

00:05:47,110 --> 00:05:54,849
vulnerabilities on Android but that is

00:05:49,090 --> 00:05:57,610
true for kernel vulnerabilities so so I

00:05:54,849 --> 00:05:59,099
wrote down some example for each one of

00:05:57,610 --> 00:06:02,770
these that you can look up if you want

00:05:59,099 --> 00:06:05,820
but in the case of my example for

00:06:02,770 --> 00:06:09,010
SELinux this one was a debug FS node

00:06:05,820 --> 00:06:12,340
which you could exploit with a buffer

00:06:09,010 --> 00:06:19,389
overwrite for UNIX permissions

00:06:12,340 --> 00:06:22,450
it was a dev flash dev slash sound node

00:06:19,389 --> 00:06:24,280
so an audio driver bug that you needed

00:06:22,450 --> 00:06:26,440
the correct UNIX permissions and the

00:06:24,280 --> 00:06:29,639
correct SEO and sperm ish ins and then

00:06:26,440 --> 00:06:32,349
finally for for capabilities on Android

00:06:29,639 --> 00:06:36,430
untrusted processes can create UNIX

00:06:32,349 --> 00:06:38,500
sockets or not UNIX sockets raw sockets

00:06:36,430 --> 00:06:39,500
so in this case in order to reach this

00:06:38,500 --> 00:06:41,060
bug you had to be able

00:06:39,500 --> 00:06:44,930
create a rocket which an unprivileged

00:06:41,060 --> 00:06:48,980
process may do and you needed cap cap

00:06:44,930 --> 00:06:50,990
net raw in order to reach it so this bug

00:06:48,980 --> 00:06:53,870
would be unreachable to unprivileged

00:06:50,990 --> 00:07:02,800
process dudu files are due to

00:06:53,870 --> 00:07:07,190
capabilities another kind of note on on

00:07:02,800 --> 00:07:10,280
some of this data is that is somewhat

00:07:07,190 --> 00:07:12,500
conservative in that in this previous

00:07:10,280 --> 00:07:15,080
slide where i've got about 90% are

00:07:12,500 --> 00:07:16,790
mitigated if we couldn't actually

00:07:15,080 --> 00:07:18,800
determine reach ability which sometimes

00:07:16,790 --> 00:07:21,230
we can't because we get bug reports and

00:07:18,800 --> 00:07:25,130
no proof of concepts along with them and

00:07:21,230 --> 00:07:26,810
sometimes we just have to be

00:07:25,130 --> 00:07:30,410
conservative and say we think this is

00:07:26,810 --> 00:07:41,240
reachable from a third party app because

00:07:30,410 --> 00:07:44,419
we get lots of bugs so also starting

00:07:41,240 --> 00:07:47,930
with android oreo which is the data that

00:07:44,419 --> 00:07:49,340
we're using here we we also had a asset

00:07:47,930 --> 00:07:52,220
calm process which was applied to all

00:07:49,340 --> 00:08:01,520
apps and so that also blocked access to

00:07:52,220 --> 00:08:03,830
a few bugs this particular CV that I

00:08:01,520 --> 00:08:06,350
mentioned here is there was a

00:08:03,830 --> 00:08:10,130
vulnerability in the move pages syscall

00:08:06,350 --> 00:08:13,370
and we don't use that syscall on android

00:08:10,130 --> 00:08:15,290
so just blocking it to everyone prevents

00:08:13,370 --> 00:08:20,960
access to this particular particular

00:08:15,290 --> 00:08:23,120
vulnerability so I guess the summary

00:08:20,960 --> 00:08:24,860
from this section is that the the kernel

00:08:23,120 --> 00:08:27,440
provides us with some pretty good tools

00:08:24,860 --> 00:08:29,720
to protect the kernel from user space

00:08:27,440 --> 00:08:32,719
and attack surface reduction works

00:08:29,720 --> 00:08:35,900
really well and on Android we've got

00:08:32,719 --> 00:08:38,320
some pretty good data showing that we

00:08:35,900 --> 00:08:40,810
will also it's not like we're done

00:08:38,320 --> 00:08:43,849
applying attack surface reduction or

00:08:40,810 --> 00:08:46,070
principle of leach lease privileged from

00:08:43,849 --> 00:08:47,720
user space to the kernel so hopefully

00:08:46,070 --> 00:08:50,410
these numbers will also continue to get

00:08:47,720 --> 00:08:50,410
better with time

00:08:50,980 --> 00:08:58,389
looking at the the unprivileged

00:08:53,470 --> 00:09:01,869
reachable bugs the biggest problem is

00:08:58,389 --> 00:09:03,609
the GPU which is one of the few hardware

00:09:01,869 --> 00:09:06,879
drivers that are actually accessible to

00:09:03,609 --> 00:09:08,919
apps on Android so but it's also

00:09:06,879 --> 00:09:11,739
important to note that a bunch of the

00:09:08,919 --> 00:09:15,419
reachable bugs are reachable our bugs

00:09:11,739 --> 00:09:19,749
that we get from the upstream kernel so

00:09:15,419 --> 00:09:23,470
in other words a lot of a lot of the we

00:09:19,749 --> 00:09:27,819
get a lot of bugs from poorly written

00:09:23,470 --> 00:09:31,389
vendor drivers in the case of the GPU on

00:09:27,819 --> 00:09:33,779
Android that is a problem but in general

00:09:31,389 --> 00:09:39,519
we're able to block those by by doing

00:09:33,779 --> 00:09:41,139
sandboxing so for example only the audio

00:09:39,519 --> 00:09:43,149
house should be able to access audio

00:09:41,139 --> 00:09:45,399
drivers and therefore if there's a

00:09:43,149 --> 00:09:48,809
vulnerability in the audio driver you

00:09:45,399 --> 00:09:48,809
can't reach it as a third party app

00:09:53,300 --> 00:09:57,770
so there's also a couple of other really

00:09:56,000 --> 00:10:01,030
nice userspace to Colonel mitigations

00:09:57,770 --> 00:10:04,600
that have been introduced recently so

00:10:01,030 --> 00:10:07,280
this graph just shows the root cause of

00:10:04,600 --> 00:10:09,860
userspace reachable bugs on Android and

00:10:07,280 --> 00:10:12,290
of course the biggest problem that we

00:10:09,860 --> 00:10:14,150
have is that people either don't check

00:10:12,290 --> 00:10:16,580
bounds or they check them incorrectly

00:10:14,150 --> 00:10:19,340
allowing you to read out of bounds or

00:10:16,580 --> 00:10:22,550
right out of bounds and so that's why

00:10:19,340 --> 00:10:25,790
we're excited about hardened user copy

00:10:22,550 --> 00:10:30,490
which was introduced in the upstream

00:10:25,790 --> 00:10:32,510
kernel in the last year ish and then

00:10:30,490 --> 00:10:37,430
back ported to all of the Android

00:10:32,510 --> 00:10:44,840
kernels because it ya provides a

00:10:37,430 --> 00:10:46,910
mitigation against this this area but

00:10:44,840 --> 00:10:51,890
specifically by it by hardening the copy

00:10:46,910 --> 00:10:54,050
to or from user functions we also have

00:10:51,890 --> 00:10:57,380
something called pan privileged access

00:10:54,050 --> 00:11:00,050
never or never allow privileged access

00:10:57,380 --> 00:11:03,230
never anyway whatever it's called what

00:11:00,050 --> 00:11:05,210
it's used for is that it prevents the

00:11:03,230 --> 00:11:07,460
kernel from directly accessing a user

00:11:05,210 --> 00:11:08,780
space processes memory so there's a

00:11:07,460 --> 00:11:12,610
couple of reasons why that's that's

00:11:08,780 --> 00:11:16,640
really useful the first is that it

00:11:12,610 --> 00:11:17,870
forces all communication to and from the

00:11:16,640 --> 00:11:20,660
kernel to actually go through those

00:11:17,870 --> 00:11:24,080
hardened those newly hardened copy to

00:11:20,660 --> 00:11:27,230
and from user functions but the other

00:11:24,080 --> 00:11:30,740
reason is that the kernel directly

00:11:27,230 --> 00:11:35,090
accessing a user space processes memory

00:11:30,740 --> 00:11:37,880
is really really racy and so we want to

00:11:35,090 --> 00:11:39,890
prevent that because if the kernel is

00:11:37,880 --> 00:11:42,830
trying to access this process is memory

00:11:39,890 --> 00:11:45,080
and the process is directly changing it

00:11:42,830 --> 00:11:47,450
at the same time then obviously that

00:11:45,080 --> 00:11:51,260
could cause kernel bugs and so when we

00:11:47,450 --> 00:11:59,480
were rolling out pan we hit multiple

00:11:51,260 --> 00:12:01,040
instances of this issue and and we know

00:11:59,480 --> 00:12:03,530
that this is a problem and partner in

00:12:01,040 --> 00:12:05,180
partner devices and in other Android

00:12:03,530 --> 00:12:05,720
devices other than the ones we directly

00:12:05,180 --> 00:12:08,990
work with

00:12:05,720 --> 00:12:12,680
I did have one one interesting story

00:12:08,990 --> 00:12:14,959
where we created a test that said in our

00:12:12,680 --> 00:12:17,500
compatibility test suite which all which

00:12:14,959 --> 00:12:19,910
all Android devices have to pass that

00:12:17,500 --> 00:12:23,720
said that this was a requirement and we

00:12:19,910 --> 00:12:26,149
we had a an OEM that children shall

00:12:23,720 --> 00:12:30,310
remain nameless he said but I can't turn

00:12:26,149 --> 00:12:32,569
this on it causes my kernel to crash so

00:12:30,310 --> 00:12:36,250
we let them know that that was working

00:12:32,569 --> 00:12:36,250
as intended and they needed to fix that

00:12:38,740 --> 00:12:45,889
so I keep caveat in everything with user

00:12:43,129 --> 00:12:48,230
space accessible kernel vulnerabilities

00:12:45,889 --> 00:12:53,209
and unfortunately not all kernel vulns

00:12:48,230 --> 00:12:55,430
are reached from user space so we've

00:12:53,209 --> 00:12:57,860
been discussing about the two thirds of

00:12:55,430 --> 00:13:02,689
kernel bugs that are reachable from user

00:12:57,860 --> 00:13:07,939
space but about a third are not so let's

00:13:02,689 --> 00:13:11,029
let's get into these a little bit so I

00:13:07,939 --> 00:13:14,449
actually broke them down from where they

00:13:11,029 --> 00:13:22,069
are reachable from as well as the root

00:13:14,449 --> 00:13:25,490
cause of the vulnerability so well yeah

00:13:22,069 --> 00:13:30,230
but that's actually so someone said it's

00:13:25,490 --> 00:13:33,079
Wi-Fi so part of the reason why I wanted

00:13:30,230 --> 00:13:34,879
a caveat earlier that bug finding tends

00:13:33,079 --> 00:13:38,420
to be somewhat trendy is because that

00:13:34,879 --> 00:13:40,129
could be the case here right maybe if we

00:13:38,420 --> 00:13:41,930
ran the same analysis in a month maybe

00:13:40,129 --> 00:13:46,309
it would be Bluetooth or maybe it would

00:13:41,930 --> 00:13:50,000
be USB but the the point I want to make

00:13:46,309 --> 00:13:51,680
here is mostly that all of those lovely

00:13:50,000 --> 00:13:54,230
mitigations that we're talking about

00:13:51,680 --> 00:13:55,699
access controls hardened user copy pan

00:13:54,230 --> 00:13:57,470
things like that those are just

00:13:55,699 --> 00:13:59,509
completely irrelevant here we have

00:13:57,470 --> 00:14:02,120
kernel bugs and we have no we have

00:13:59,509 --> 00:14:05,269
absolutely no mitigations to prevent

00:14:02,120 --> 00:14:07,399
those kernel bugs and you know yes the

00:14:05,269 --> 00:14:11,420
Wi-Fi driver is a bit of a dumpster fire

00:14:07,399 --> 00:14:14,300
but you know I I fully expect people

00:14:11,420 --> 00:14:16,339
will be looking at USB and and find the

00:14:14,300 --> 00:14:17,510
same thing if the same amount of

00:14:16,339 --> 00:14:19,910
resources were

00:14:17,510 --> 00:14:21,140
into that the other thing is is there's

00:14:19,910 --> 00:14:23,260
gonna be a nice talk line says caller

00:14:21,140 --> 00:14:25,370
that's happening later things like

00:14:23,260 --> 00:14:30,080
automated fussing through sis caller

00:14:25,370 --> 00:14:33,140
also not looking here so I guess one of

00:14:30,080 --> 00:14:34,430
the positive things is that kernel bugs

00:14:33,140 --> 00:14:37,040
that are reachable through the Wi-Fi

00:14:34,430 --> 00:14:38,960
firmer would first require that you have

00:14:37,040 --> 00:14:42,110
code running in the Wi-Fi firmware to

00:14:38,960 --> 00:14:43,940
reach to reach those right so so in some

00:14:42,110 --> 00:14:45,940
ways there there is some access control

00:14:43,940 --> 00:14:48,620
going on here

00:14:45,940 --> 00:14:49,790
and then of course the other the other

00:14:48,620 --> 00:14:52,700
issue and the reason why I wanted to

00:14:49,790 --> 00:14:56,030
discuss lack of using harder hard lack

00:14:52,700 --> 00:14:58,280
of hardened user copy is that clearly

00:14:56,030 --> 00:15:00,590
missing an incorrect bounds check is an

00:14:58,280 --> 00:15:04,340
even larger problem in in this subset of

00:15:00,590 --> 00:15:11,030
bugs we really need something doing

00:15:04,340 --> 00:15:14,150
bounds checking on the heap yeah

00:15:11,030 --> 00:15:17,150
and again looking at kind of the the

00:15:14,150 --> 00:15:19,610
trendiness of bug finding a large subset

00:15:17,150 --> 00:15:22,100
of these bugs are the correct

00:15:19,610 --> 00:15:25,520
voluntaries which are just weaknesses in

00:15:22,100 --> 00:15:30,760
the WPA protocol one thing that I will

00:15:25,520 --> 00:15:34,100
say from an Android perspective is that

00:15:30,760 --> 00:15:36,890
the only safe assumption on a network is

00:15:34,100 --> 00:15:40,490
that the network is untrusted so if you

00:15:36,890 --> 00:15:43,010
are relying on WPA or you know

00:15:40,490 --> 00:15:44,750
encryption on one hop you were already

00:15:43,010 --> 00:15:47,150
in bad shape

00:15:44,750 --> 00:15:49,160
I could probably create an access point

00:15:47,150 --> 00:15:50,480
call it Starbucks and half the phones in

00:15:49,160 --> 00:15:53,030
the room would connect to it right like

00:15:50,480 --> 00:15:55,330
WPA is not keeping you safe I think it's

00:15:53,030 --> 00:15:57,980
good that we patch it but that's the

00:15:55,330 --> 00:16:04,700
only safe assumption is that the network

00:15:57,980 --> 00:16:07,160
is is untrusted okay so kind of a

00:16:04,700 --> 00:16:09,590
summary from this section is that user

00:16:07,160 --> 00:16:11,360
space to kernel we've got a lot of good

00:16:09,590 --> 00:16:13,180
tools there those are provided by the

00:16:11,360 --> 00:16:17,270
upstream kernel and they actually are

00:16:13,180 --> 00:16:19,730
fairly effective however about a third

00:16:17,270 --> 00:16:21,970
of the kernel bugs are reached by other

00:16:19,730 --> 00:16:24,770
vectors and it would be nice if we had

00:16:21,970 --> 00:16:29,900
both access good access control

00:16:24,770 --> 00:16:32,570
mechanisms as well as good good

00:16:29,900 --> 00:16:38,890
like a bounce checking for example or

00:16:32,570 --> 00:16:49,940
yeah the and then finally I wanted to

00:16:38,890 --> 00:16:53,029
talk briefly about memory unsafety so so

00:16:49,940 --> 00:16:56,450
this is again about all kernel bugs not

00:16:53,029 --> 00:16:58,880
just user space or other vector

00:16:56,450 --> 00:17:02,240
reachable bugs but clearly when we

00:16:58,880 --> 00:17:05,780
actually look at add bounds checking the

00:17:02,240 --> 00:17:07,400
the major problem is the heap and so we

00:17:05,780 --> 00:17:09,970
have some protections for the stack

00:17:07,400 --> 00:17:12,860
right we've got a stack protector and

00:17:09,970 --> 00:17:15,290
and some other things that are going to

00:17:12,860 --> 00:17:17,300
be discussed later but really what we

00:17:15,290 --> 00:17:20,240
need are protections for the heap so

00:17:17,300 --> 00:17:23,059
that if you do something like override a

00:17:20,240 --> 00:17:24,829
function pointer you don't just um you

00:17:23,059 --> 00:17:28,990
you haven't just immediately taken over

00:17:24,829 --> 00:17:31,400
control of of the kernel so with that

00:17:28,990 --> 00:17:39,980
Sammy's gonna discuss some of the work

00:17:31,400 --> 00:17:43,100
that we're doing there all right so I'm

00:17:39,980 --> 00:17:45,350
gonna say a few words about CFI control

00:17:43,100 --> 00:17:47,000
flow integrity which is the latest

00:17:45,350 --> 00:17:54,200
medication we added to android kernels

00:17:47,000 --> 00:17:56,600
in android 9 see if I helps protect

00:17:54,200 --> 00:17:59,300
against code reuse attacks it tries to

00:17:56,600 --> 00:18:00,980
accomplish this by adding runtime checks

00:17:59,300 --> 00:18:03,880
to ensure that the program's control

00:18:00,980 --> 00:18:06,980
flow stays within a pre computed graph

00:18:03,880 --> 00:18:10,010
in practice LLVM CFI implementation

00:18:06,980 --> 00:18:12,530
which we use focuses only on protecting

00:18:10,010 --> 00:18:15,100
the forward edge for C programs this

00:18:12,530 --> 00:18:17,720
basically means indirect branches

00:18:15,100 --> 00:18:21,860
luckily the kernel has plenty of those

00:18:17,720 --> 00:18:23,960
so it's decent starting place I would

00:18:21,860 --> 00:18:26,420
see if I'm LLVM had to check before each

00:18:23,960 --> 00:18:28,280
indirect branch to ensure that the

00:18:26,420 --> 00:18:31,240
target address points to the beginning

00:18:28,280 --> 00:18:34,130
of a valid function with correct type

00:18:31,240 --> 00:18:38,990
this limits the number of potential

00:18:34,130 --> 00:18:41,150
targets where the kernel can jump before

00:18:38,990 --> 00:18:43,130
we continue into more details let's take

00:18:41,150 --> 00:18:46,250
a look at how effective Olivia

00:18:43,130 --> 00:18:48,049
see if I actually is in the kernel first

00:18:46,250 --> 00:18:50,900
of all see if I is a soft mitigation

00:18:48,049 --> 00:18:52,549
that's not alone going to prevent an

00:18:50,900 --> 00:18:53,630
attacker from exploiting a sufficiently

00:18:52,549 --> 00:18:57,230
bad kernel bug

00:18:53,630 --> 00:18:58,850
however together with other current and

00:18:57,230 --> 00:19:02,150
future medications it will make

00:18:58,850 --> 00:19:04,160
exploding bugs more difficult this is a

00:19:02,150 --> 00:19:07,520
graph generated from an actual Android

00:19:04,160 --> 00:19:09,559
device kernel which shows the number of

00:19:07,520 --> 00:19:14,570
potential core targets efi allows for

00:19:09,559 --> 00:19:16,610
each indirect call without C if I'm an

00:19:14,570 --> 00:19:19,010
attacker who is able to modify a

00:19:16,610 --> 00:19:20,539
function pointer can jump anywhere but

00:19:19,010 --> 00:19:22,220
we'd see a 5 more than half of all

00:19:20,539 --> 00:19:25,850
indirect calls can branch only to a

00:19:22,220 --> 00:19:32,150
handful of functions now and 80% have at

00:19:25,850 --> 00:19:33,470
most 20 possible targets of course due

00:19:32,150 --> 00:19:36,860
to the limitations of the function

00:19:33,470 --> 00:19:39,289
signature page based approach we still

00:19:36,860 --> 00:19:41,539
have for the two most common function

00:19:39,289 --> 00:19:42,890
types in the kernel more than 1000

00:19:41,539 --> 00:19:46,820
possible functions where the kernel can

00:19:42,890 --> 00:19:48,440
jump but this applies to less than 1% of

00:19:46,820 --> 00:19:51,320
all indirect calls in the kernel and it

00:19:48,440 --> 00:19:52,909
still limits the attackers options and

00:19:51,320 --> 00:19:59,510
it prevents them from jumping to an

00:19:52,909 --> 00:20:01,190
arbitrary gadget for example in order

00:19:59,510 --> 00:20:02,600
for the compiler to determine valid call

00:20:01,190 --> 00:20:05,480
targets it needs to see the entire

00:20:02,600 --> 00:20:08,059
program or at least all the relevant

00:20:05,480 --> 00:20:09,770
parts of the program in the girls case

00:20:08,059 --> 00:20:13,640
the compiler won't see standalone

00:20:09,770 --> 00:20:16,400
assembly code for example lbm solves the

00:20:13,640 --> 00:20:19,669
visibility problem by requiring link

00:20:16,400 --> 00:20:21,770
time of the optimization or LTL where

00:20:19,669 --> 00:20:24,440
each compilation unit is first compiled

00:20:21,770 --> 00:20:26,330
into LLVM specific bit code which is had

00:20:24,440 --> 00:20:28,429
link time combined and inspected all at

00:20:26,330 --> 00:20:30,559
once

00:20:28,429 --> 00:20:32,690
unfortunately LTL somewhat complicates

00:20:30,559 --> 00:20:34,400
matters when it comes to the kernel not

00:20:32,690 --> 00:20:37,070
only do we need to switch to an LTO over

00:20:34,400 --> 00:20:38,990
linker but we also need to use LVM

00:20:37,070 --> 00:20:42,140
integrated assembler for all inline

00:20:38,990 --> 00:20:43,909
assembly because of this most of the

00:20:42,140 --> 00:20:45,770
issues we run into when adding LTO

00:20:43,909 --> 00:20:50,960
support to android kernels were actually

00:20:45,770 --> 00:20:52,309
toolchain compatibility issues some

00:20:50,960 --> 00:20:55,790
changes to kernel build spirits were

00:20:52,309 --> 00:20:56,930
needed but those were greatly simplified

00:20:55,790 --> 00:20:58,730
by the upstream dinner

00:20:56,930 --> 00:21:01,790
work which already removed all the

00:20:58,730 --> 00:21:04,220
intermediate linking steps we did have

00:21:01,790 --> 00:21:06,440
to use few LVM tools for generating

00:21:04,220 --> 00:21:09,080
symbol tables for bit code files for

00:21:06,440 --> 00:21:14,150
example but but there were not many

00:21:09,080 --> 00:21:17,660
changes here we have a simplified view

00:21:14,150 --> 00:21:18,950
of how LTI works with clang in the

00:21:17,660 --> 00:21:20,630
kernel we have some code that's

00:21:18,950 --> 00:21:22,430
translated directly into object files

00:21:20,630 --> 00:21:24,080
but the vast majority is compiled into

00:21:22,430 --> 00:21:25,940
bit code

00:21:24,080 --> 00:21:28,370
everything is added into thin archive

00:21:25,940 --> 00:21:29,900
which is then passed to the linker the

00:21:28,370 --> 00:21:32,420
linker Lucas the archive combines all

00:21:29,900 --> 00:21:34,070
the bit code optimizes composite into

00:21:32,420 --> 00:21:38,480
native code and everything is linked

00:21:34,070 --> 00:21:40,760
together in the end we ask for feedback

00:21:38,480 --> 00:21:44,030
about LTI from kernel maintain airs last

00:21:40,760 --> 00:21:47,990
year and many of them expressed concerns

00:21:44,030 --> 00:21:50,030
about possibly unsafe optimizations that

00:21:47,990 --> 00:21:52,670
might break the kernels memory model for

00:21:50,030 --> 00:21:56,000
example during the past several months

00:21:52,670 --> 00:22:00,590
we have tested LTO kernels extensively

00:21:56,000 --> 00:22:01,910
and on actual devices and we have not

00:22:00,590 --> 00:22:04,210
run into any issues that could be

00:22:01,910 --> 00:22:07,280
attributed to LT yeom

00:22:04,210 --> 00:22:09,620
in fact we are confident in a confident

00:22:07,280 --> 00:22:11,600
enough in LTO that first android devices

00:22:09,620 --> 00:22:18,080
running an LTO kernel will ship later

00:22:11,600 --> 00:22:20,900
this year once the problems with LTL

00:22:18,080 --> 00:22:23,450
were sorted out adding CFI support was

00:22:20,900 --> 00:22:25,340
relatively simple the biggest challenge

00:22:23,450 --> 00:22:28,730
was fixing all the benign CFI failures

00:22:25,340 --> 00:22:30,470
in the existing code C compilers don't

00:22:28,730 --> 00:22:32,870
currently in for similar restrictions to

00:22:30,470 --> 00:22:34,670
CF is runtime checks so there was a fair

00:22:32,870 --> 00:22:39,080
amount of coding the kernel that trips

00:22:34,670 --> 00:22:41,300
efi which we had to first fix another

00:22:39,080 --> 00:22:44,390
complication for kernel modules the

00:22:41,300 --> 00:22:45,740
compiler obviously doesn't see all the

00:22:44,390 --> 00:22:49,400
modules especially if they're compiled

00:22:45,740 --> 00:22:52,160
out of tree we adapted LLVM x' cross TSO

00:22:49,400 --> 00:22:54,620
CFI support to handle kernel modules

00:22:52,160 --> 00:22:57,140
each module now has its own CFI check

00:22:54,620 --> 00:23:00,050
function which determines the valid call

00:22:57,140 --> 00:23:01,610
targets for that specific module and the

00:23:00,050 --> 00:23:03,620
kernel looks up the correct check

00:23:01,610 --> 00:23:08,210
function to call based on the target

00:23:03,620 --> 00:23:10,760
address obviously this needs to have as

00:23:08,210 --> 00:23:12,920
little overhead as possible

00:23:10,760 --> 00:23:14,270
which brings me to the point that

00:23:12,920 --> 00:23:15,860
everyone has in their mind when it comes

00:23:14,270 --> 00:23:23,450
to security medications which is

00:23:15,860 --> 00:23:25,070
performance in our tests a colonel

00:23:23,450 --> 00:23:27,500
compiled with LTO and see if I actually

00:23:25,070 --> 00:23:30,620
performed slightly better than the base

00:23:27,500 --> 00:23:35,720
colonel obviously due to LT of more

00:23:30,620 --> 00:23:37,520
aggressive optimizations and here we

00:23:35,720 --> 00:23:40,400
have an example of a CFR failure that we

00:23:37,520 --> 00:23:41,810
run into here's a single function

00:23:40,400 --> 00:23:44,240
pointer that's used to call a large

00:23:41,810 --> 00:23:47,720
number of functions all with different

00:23:44,240 --> 00:23:50,360
argument types the compiler is naturally

00:23:47,720 --> 00:23:53,090
perfectly fine with this but to see if I

00:23:50,360 --> 00:23:54,710
run time check fails we fix this

00:23:53,090 --> 00:23:56,720
upstream a while ago with a clear

00:23:54,710 --> 00:24:01,940
solution that doesn't use mismatching

00:23:56,720 --> 00:24:03,980
function pointers this is what a

00:24:01,940 --> 00:24:08,000
compiler injected runtime check looks

00:24:03,980 --> 00:24:10,640
like on our m60 form before an indirect

00:24:08,000 --> 00:24:12,710
call the compiler has a call to see if I

00:24:10,640 --> 00:24:15,650
check function which validates a target

00:24:12,710 --> 00:24:18,140
address it's passed a hash of the

00:24:15,650 --> 00:24:22,130
expected type information and if the

00:24:18,140 --> 00:24:25,070
check fails it simply never returns and

00:24:22,130 --> 00:24:26,690
this is why it doesn't return its when

00:24:25,070 --> 00:24:28,250
the see if I check fails we first print

00:24:26,690 --> 00:24:31,640
out the target address to help us

00:24:28,250 --> 00:24:33,500
pinpoint the issue and once EFI is

00:24:31,640 --> 00:24:36,770
enabled in normal mode it panics the

00:24:33,500 --> 00:24:39,890
kernel immediately we also added a

00:24:36,770 --> 00:24:41,480
permissive mode which changes the panic

00:24:39,890 --> 00:24:43,840
into a warning instead which makes it

00:24:41,480 --> 00:24:45,950
easier to debug these failures

00:24:43,840 --> 00:24:48,500
especially if they occur in early build

00:24:45,950 --> 00:24:50,390
for example but it should be noted that

00:24:48,500 --> 00:24:52,520
the permissive mode has absolutely no

00:24:50,390 --> 00:24:56,530
security benefits and should only be

00:24:52,520 --> 00:24:56,530
used during testing or device bring up

00:24:57,960 --> 00:25:03,210
our CFI implementation is available

00:25:00,480 --> 00:25:07,529
right now in android carlos 4.9 and 414

00:25:03,210 --> 00:25:10,590
which you can find from a USB it's only

00:25:07,529 --> 00:25:12,779
forearm 64 at the moment you also need a

00:25:10,590 --> 00:25:14,879
recent enough clang and B new tools to

00:25:12,779 --> 00:25:16,379
compile the kernel and for anyone

00:25:14,879 --> 00:25:22,259
interested in testing this these are

00:25:16,379 --> 00:25:25,669
config options you need to enable and

00:25:22,259 --> 00:25:28,320
finally if you knows about future work

00:25:25,669 --> 00:25:31,139
since llbmc if I only protects forward

00:25:28,320 --> 00:25:33,240
branches forward edge we are looking

00:25:31,139 --> 00:25:36,389
into other solutions for also protecting

00:25:33,240 --> 00:25:39,809
return addresses better we previously

00:25:36,389 --> 00:25:41,970
looked into LVM safe stack which which

00:25:39,809 --> 00:25:43,830
works but to do memory overhead concerns

00:25:41,970 --> 00:25:46,909
we are not focusing on the newer shadow

00:25:43,830 --> 00:25:49,110
call stack medication instead and

00:25:46,909 --> 00:25:51,720
because of the numerous problems we run

00:25:49,110 --> 00:25:54,559
into with the gold linker we also

00:25:51,720 --> 00:25:56,909
looking into replacing it with LVM LLD

00:25:54,559 --> 00:25:58,529
which hopefully reduces the

00:25:56,909 --> 00:26:02,309
compatibility issues we run into a

00:25:58,529 --> 00:26:04,549
little bit and that's all I have thank

00:26:02,309 --> 00:26:04,549
you

00:26:04,940 --> 00:26:11,349
[Applause]

00:26:13,660 --> 00:26:16,660
questions

00:26:24,990 --> 00:26:32,220
so I had a question about previous topic

00:26:27,900 --> 00:26:35,610
about attack surface reduction I've

00:26:32,220 --> 00:26:40,110
noticed one thing that in that one of

00:26:35,610 --> 00:26:44,010
the things that caused bugs in kernel

00:26:40,110 --> 00:26:47,370
was binder the IPC mechanism right so

00:26:44,010 --> 00:26:50,400
how does the attack surface reduction in

00:26:47,370 --> 00:26:54,030
binder work is it just adding the

00:26:50,400 --> 00:26:55,800
explicit checks in code that connects on

00:26:54,030 --> 00:26:57,840
the other side of the IPC or is it

00:26:55,800 --> 00:27:00,740
something more like with a seal enix or

00:26:57,840 --> 00:27:00,740
something like that

00:27:01,520 --> 00:27:05,370
vulnerabilities from binder to the

00:27:03,390 --> 00:27:08,100
kernel or from binder to other processes

00:27:05,370 --> 00:27:10,559
no no because the talk was about kernel

00:27:08,100 --> 00:27:13,110
so from by indirect kernel so there's

00:27:10,559 --> 00:27:17,429
basically no attack surface reduction

00:27:13,110 --> 00:27:20,280
from processes to binder and I think we

00:27:17,429 --> 00:27:23,010
had one binder vulnerability in the last

00:27:20,280 --> 00:27:25,130
year so since all apps have to be able

00:27:23,010 --> 00:27:27,240
to use binder that that particular

00:27:25,130 --> 00:27:31,130
vulnerability was accessible so that

00:27:27,240 --> 00:27:35,780
that was included in the group of

00:27:31,130 --> 00:27:35,780
unprivileged reachable vulnerabilities

00:27:38,960 --> 00:27:42,530
any other questions

00:27:47,690 --> 00:27:56,250
Stephen did you get to look at gr

00:27:52,740 --> 00:28:02,280
security strap design implementation at

00:27:56,250 --> 00:28:05,430
all yes we did but since we are using

00:28:02,280 --> 00:28:09,260
plan for our kernels we decided to go

00:28:05,430 --> 00:28:09,260
with LOV Ames medications instead

00:28:24,200 --> 00:28:29,059
hi there I really appreciate the data

00:28:26,730 --> 00:28:32,669
it's nice to see it presented like that

00:28:29,059 --> 00:28:36,360
you mentioned 25 percent of the

00:28:32,669 --> 00:28:41,159
unprivileged reachable bugs were from

00:28:36,360 --> 00:28:44,580
GPU drivers what kind of helps support

00:28:41,159 --> 00:28:47,909
instructions smack on the head do you

00:28:44,580 --> 00:28:49,289
give to set vendors so that they can

00:28:47,909 --> 00:28:52,620
improve the security of their GPU

00:28:49,289 --> 00:28:55,950
drivers yeah so a couple of things that

00:28:52,620 --> 00:28:57,809
we're doing first of all I I like having

00:28:55,950 --> 00:28:59,700
the slide up there because I can kind of

00:28:57,809 --> 00:29:04,820
use that to go tell people that hey this

00:28:59,700 --> 00:29:04,820
is a problem so a couple of things that

00:29:06,770 --> 00:29:09,990
so a couple things that we can look at

00:29:08,730 --> 00:29:12,480
one nice thing about attack surface

00:29:09,990 --> 00:29:14,130
reduction is by reducing the available

00:29:12,480 --> 00:29:16,710
attack surface we can actually focus

00:29:14,130 --> 00:29:19,890
resources on the remaining surface

00:29:16,710 --> 00:29:23,700
better right so we can put for example

00:29:19,890 --> 00:29:25,559
fuzzing resources there or code review

00:29:23,700 --> 00:29:27,510
resources there whereas if we had the

00:29:25,559 --> 00:29:30,809
entire kernel that would be a bit

00:29:27,510 --> 00:29:34,649
overwhelming but other other topics that

00:29:30,809 --> 00:29:38,070
I am hoping to be able to use this data

00:29:34,649 --> 00:29:40,020
for are things like maybe GPU access

00:29:38,070 --> 00:29:42,330
maybe the GPU should not be directly

00:29:40,020 --> 00:29:43,980
accessible from unprivileged apps right

00:29:42,330 --> 00:29:47,820
so we've moved all of these other things

00:29:43,980 --> 00:29:49,649
out of our unprivileged sandboxes and

00:29:47,820 --> 00:29:51,899
that's kind of one of the few that's

00:29:49,649 --> 00:29:54,890
hanging around so maybe we need to start

00:29:51,899 --> 00:29:54,890
looking at that as well

00:30:03,430 --> 00:30:08,840
so the Android team has done a lot of

00:30:06,440 --> 00:30:10,100
work to make it much easier to do update

00:30:08,840 --> 00:30:12,650
kernels which is um you know fantastic

00:30:10,100 --> 00:30:14,630
for the ecosystem have you noticed that

00:30:12,650 --> 00:30:16,100
having any impact on the number of bugs

00:30:14,630 --> 00:30:19,100
in terms of you know either good bad

00:30:16,100 --> 00:30:23,870
ugly what do you mean by update kernels

00:30:19,100 --> 00:30:25,370
you know faster being able to get more

00:30:23,870 --> 00:30:27,400
up-to-date kernels such as opposed to

00:30:25,370 --> 00:30:29,510
being stuck on an older versions because

00:30:27,400 --> 00:30:31,580
om is just don't update them and

00:30:29,510 --> 00:30:32,840
requiring newer ones with things like

00:30:31,580 --> 00:30:37,690
project trouble and everything like that

00:30:32,840 --> 00:30:40,820
yeah so the the kernel requirements now

00:30:37,690 --> 00:30:42,770
which did not used to exist are for

00:30:40,820 --> 00:30:46,250
example I think when you launch if you

00:30:42,770 --> 00:30:49,550
launch a device with Android P you have

00:30:46,250 --> 00:30:53,630
to have a four nine kernel or newer on

00:30:49,550 --> 00:30:55,790
it what that doesn't mean is that

00:30:53,630 --> 00:30:58,040
doesn't mean that they will then ever

00:30:55,790 --> 00:31:04,370
update the kernel version for that

00:30:58,040 --> 00:31:05,840
device so I you're right in that no

00:31:04,370 --> 00:31:07,430
longer will devices be launched with

00:31:05,840 --> 00:31:10,160
these ancient kernels the way they

00:31:07,430 --> 00:31:11,870
sometimes were in the past

00:31:10,160 --> 00:31:13,190
but yeah there's there's no requirement

00:31:11,870 --> 00:31:15,170
that they actually update the kernel

00:31:13,190 --> 00:31:20,780
version on a device once it's been

00:31:15,170 --> 00:31:22,100
launched so but yeah it helps and from

00:31:20,780 --> 00:31:23,600
from our perspective we're getting all

00:31:22,100 --> 00:31:26,180
these nice mitigations and upstream

00:31:23,600 --> 00:31:27,740
kernels and so it's nice to know that we

00:31:26,180 --> 00:31:29,060
have to do less work and that partners

00:31:27,740 --> 00:31:30,500
have to do less work because those

00:31:29,060 --> 00:31:33,470
mitigations are just built right into

00:31:30,500 --> 00:31:35,870
the kernel one of the reasons why I like

00:31:33,470 --> 00:31:38,120
to present data like like I've been

00:31:35,870 --> 00:31:40,250
presenting particularly at this

00:31:38,120 --> 00:31:42,050
conference is that I know people are

00:31:40,250 --> 00:31:44,000
able to take that data and actually use

00:31:42,050 --> 00:31:45,530
it to justify work and I know that for

00:31:44,000 --> 00:31:49,040
example people from arm have been able

00:31:45,530 --> 00:31:51,680
to say oh we we can see that the the

00:31:49,040 --> 00:31:53,690
heap is a real problem and that buffer

00:31:51,680 --> 00:31:57,050
overruns in the heap are a major issue

00:31:53,690 --> 00:32:03,290
so let's let's use that data and justify

00:31:57,050 --> 00:32:05,680
putting resources towards that any other

00:32:03,290 --> 00:32:05,680
questions

00:32:07,460 --> 00:32:10,120
all righty

00:32:08,820 --> 00:32:14,750
thank you

00:32:10,120 --> 00:32:14,750

YouTube URL: https://www.youtube.com/watch?v=Yng44_9oTBM


