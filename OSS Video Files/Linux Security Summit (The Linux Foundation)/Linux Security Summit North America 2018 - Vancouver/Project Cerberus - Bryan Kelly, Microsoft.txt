Title: Project Cerberus - Bryan Kelly, Microsoft
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Project Cerberus - Bryan Kelly, Microsoft

Project Cerberus is a hardware root of trust. The cryptographic microcontroller interposes between processors and their firmware load store to provide hardware enforced secure boot with digital signature enforcement, and measured boot.

About Bryan Kelly
Bryan Kelly is a Principle Firmware Engineering Manager for Microsoft’s Azure Cloud Server Infrastructure team. Bryan supports Microsoft’s cloud services by designing and developing firmware that enables hardware solutions in Microsoft’s next generation cloud platforms. During Bryan’s 12 year tenure at Microsoft his work has spanned data center design, data center control systems, UEFI, BMC, systems manageability, firmware architecture and security design.
Captions: 
	00:00:00,439 --> 00:00:08,040
okay so my name is Brian Kelly and I

00:00:05,100 --> 00:00:12,000
work at Microsoft I had the opportunity

00:00:08,040 --> 00:00:17,210
to speak here yesterday with Ron Nate

00:00:12,000 --> 00:00:20,160
and Elaine on open source firmware and

00:00:17,210 --> 00:00:23,640
in having that I get a little bit of a

00:00:20,160 --> 00:00:27,060
retry today in in this presentation I

00:00:23,640 --> 00:00:30,539
realized that some of you may be

00:00:27,060 --> 00:00:33,450
unfamiliar with would open compute the

00:00:30,539 --> 00:00:36,000
efforts that are are going on there so

00:00:33,450 --> 00:00:38,370
I'm gonna talk about project Cerberus

00:00:36,000 --> 00:00:41,070
today which is focused on hardware

00:00:38,370 --> 00:00:45,300
security which is appropriate for for

00:00:41,070 --> 00:00:47,730
this audience but I also want to maybe

00:00:45,300 --> 00:00:49,230
divulge a little bit and talk about open

00:00:47,730 --> 00:00:52,370
compute and give you some backdrop

00:00:49,230 --> 00:00:55,649
that's that's kind of relevant to why

00:00:52,370 --> 00:01:00,090
and how project servers came about

00:00:55,649 --> 00:01:04,890
okay so open compute was founded in

00:01:00,090 --> 00:01:07,950
April 2011 by by Facebook and they made

00:01:04,890 --> 00:01:10,580
some you know good contributions and and

00:01:07,950 --> 00:01:15,299
great forward momentum in establishing

00:01:10,580 --> 00:01:19,979
open compute Microsoft joined in 2014

00:01:15,299 --> 00:01:24,799
and and when we joined we made a a

00:01:19,979 --> 00:01:27,869
contribution of a open cloud server

00:01:24,799 --> 00:01:29,100
system which was a twelve use chassis

00:01:27,869 --> 00:01:33,299
you can see it there it's the it's the

00:01:29,100 --> 00:01:36,060
top image and that was optimized for

00:01:33,299 --> 00:01:38,009
density and when we made that

00:01:36,060 --> 00:01:40,170
contribution the design of it was

00:01:38,009 --> 00:01:43,310
complete it was it was a product that

00:01:40,170 --> 00:01:45,810
we've been using for some time and

00:01:43,310 --> 00:01:50,640
contributed to the three open compute

00:01:45,810 --> 00:01:53,220
then in October 2016 Microsoft announced

00:01:50,640 --> 00:01:59,219
project Olympus as part of open compute

00:01:53,220 --> 00:01:59,939
and that was a design which was not yet

00:01:59,219 --> 00:02:02,549
complete

00:01:59,939 --> 00:02:04,799
it was about 75% complete we tried to do

00:02:02,549 --> 00:02:07,140
a thing with this design whereby we

00:02:04,799 --> 00:02:09,179
wanted to foster community feedback

00:02:07,140 --> 00:02:10,770
similar to an open source project you'll

00:02:09,179 --> 00:02:12,840
start it up you won't yet be finished

00:02:10,770 --> 00:02:14,690
you'll get contributions and you'll come

00:02:12,840 --> 00:02:17,670
out with a great product

00:02:14,690 --> 00:02:21,750
pledget Olympus was was a try at that

00:02:17,670 --> 00:02:25,530
and the community really helped to steer

00:02:21,750 --> 00:02:29,280
to design and take us that extra twenty

00:02:25,530 --> 00:02:32,100
five percent so the feedback was

00:02:29,280 --> 00:02:34,440
incorporated into the design all the

00:02:32,100 --> 00:02:38,010
manufacturing collateral for product was

00:02:34,440 --> 00:02:40,520
was open sourced and in later that was

00:02:38,010 --> 00:02:44,940
followed with open firmware to open edk

00:02:40,520 --> 00:02:48,870
open vm c and part of the PDU and plug

00:02:44,940 --> 00:02:52,470
strip firmware was a open rack manager

00:02:48,870 --> 00:02:55,680
and that that stuff is all out on github

00:02:52,470 --> 00:02:58,320
and along with the board file schematics

00:02:55,680 --> 00:03:00,239
and manufacturing collateral so the

00:02:58,320 --> 00:03:04,500
open-source momentum that first project

00:03:00,239 --> 00:03:07,170
olympus design was in intel x86 well

00:03:04,500 --> 00:03:11,239
quickly followed behind that was a lot

00:03:07,170 --> 00:03:14,790
of other manufacturers taken the same

00:03:11,239 --> 00:03:16,739
form factor in design and giving more

00:03:14,790 --> 00:03:18,530
building blocks then there was more

00:03:16,739 --> 00:03:21,090
building blocks that followed that

00:03:18,530 --> 00:03:25,440
including flash storage hard drive

00:03:21,090 --> 00:03:27,360
storage GPU and PCIe expansion so all

00:03:25,440 --> 00:03:29,670
that is hardware contribution in

00:03:27,360 --> 00:03:31,860
firmware contribution was great but

00:03:29,670 --> 00:03:35,940
there was one thing that was missing and

00:03:31,860 --> 00:03:37,769
it was what about security and if you're

00:03:35,940 --> 00:03:40,860
greek mythology is is good you could

00:03:37,769 --> 00:03:43,200
probably tell from the three-headed

00:03:40,860 --> 00:03:45,840
puppies what that led to

00:03:43,200 --> 00:03:49,200
and that was our establishment the

00:03:45,840 --> 00:03:51,620
project Cerberus and not only on the

00:03:49,200 --> 00:03:54,269
announcement of project server s but

00:03:51,620 --> 00:04:02,400
around the same time we established a

00:03:54,269 --> 00:04:04,560
security forum in in OCP and the goal

00:04:02,400 --> 00:04:07,640
was to take you know typically

00:04:04,560 --> 00:04:11,280
proprietary hardware security

00:04:07,640 --> 00:04:12,720
implementations and to open it up open

00:04:11,280 --> 00:04:15,329
up the design and open up the

00:04:12,720 --> 00:04:18,870
architecture on on how we do hardware

00:04:15,329 --> 00:04:22,229
security and to drive that forward with

00:04:18,870 --> 00:04:25,220
the with the community so I have a quote

00:04:22,229 --> 00:04:27,330
here from probably somebody who probably

00:04:25,220 --> 00:04:31,250
read about which

00:04:27,330 --> 00:04:34,590
alfrid Charlotte Charles Hobbs in in

00:04:31,250 --> 00:04:39,090
1851 he was a he was a locksmith an

00:04:34,590 --> 00:04:43,250
American inventor and he came under

00:04:39,090 --> 00:04:46,199
great criticism for publicly

00:04:43,250 --> 00:04:49,379
demonstrating how to pick some of the

00:04:46,199 --> 00:04:52,259
most secure locks at a time and his

00:04:49,379 --> 00:04:54,780
response to all this criticism was that

00:04:52,259 --> 00:04:57,479
rogues are very keen in their profession

00:04:54,780 --> 00:04:59,849
and know already much more than we can

00:04:57,479 --> 00:05:02,639
teach them and this was against the

00:04:59,849 --> 00:05:05,099
attitude at a time of security by

00:05:02,639 --> 00:05:09,210
obscurity or obscurity or security

00:05:05,099 --> 00:05:13,620
through obscurity he maintained that by

00:05:09,210 --> 00:05:16,770
being open we can get more we can get

00:05:13,620 --> 00:05:18,659
have improved security by being open

00:05:16,770 --> 00:05:22,020
about our security and taking feedback

00:05:18,659 --> 00:05:25,169
from others so the the Open Compute

00:05:22,020 --> 00:05:28,050
security project was announced in

00:05:25,169 --> 00:05:31,409
February 2008 so it's it's relatively

00:05:28,050 --> 00:05:34,050
relatively recent Microsoft and Google

00:05:31,409 --> 00:05:37,039
were selected as the as the co-chairs

00:05:34,050 --> 00:05:41,479
but we have many many companies that

00:05:37,039 --> 00:05:45,330
that join weekly and and can contribute

00:05:41,479 --> 00:05:49,080
expertise and engineering time making

00:05:45,330 --> 00:05:52,620
our lives a little bit easier it is

00:05:49,080 --> 00:05:59,190
community focused on advancing platform

00:05:52,620 --> 00:06:02,159
security as a whole so that's really the

00:05:59,190 --> 00:06:04,080
the intro to OCP just to let you know a

00:06:02,159 --> 00:06:07,229
little bit about it now I want to switch

00:06:04,080 --> 00:06:09,659
gears and kind of circle back to what it

00:06:07,229 --> 00:06:16,589
originally intended on presenting which

00:06:09,659 --> 00:06:19,319
was project server specifically so in

00:06:16,589 --> 00:06:21,599
the cloud or as a cloud provider we have

00:06:19,319 --> 00:06:23,699
a different security threat model or

00:06:21,599 --> 00:06:27,930
different vectors to maybe you

00:06:23,699 --> 00:06:34,500
know traditional enterprise or client in

00:06:27,930 --> 00:06:37,500
a cloud you're essentially leasing VMs

00:06:34,500 --> 00:06:39,930
to two companies but still maintaining

00:06:37,500 --> 00:06:43,970
ownership of the hardware

00:06:39,930 --> 00:06:47,010
those those customers they may you know

00:06:43,970 --> 00:06:48,750
their VM may be on different different

00:06:47,010 --> 00:06:52,440
hardware at different stages or

00:06:48,750 --> 00:06:56,880
different times in its lifecycle so it's

00:06:52,440 --> 00:06:59,070
really how do we protect the the

00:06:56,880 --> 00:07:01,050
persistent security or the persistent

00:06:59,070 --> 00:07:02,730
security state of that device as it

00:07:01,050 --> 00:07:05,040
transitions through its lifecycle of

00:07:02,730 --> 00:07:07,920
physical device we've many different

00:07:05,040 --> 00:07:09,990
factors we've got customers who may be

00:07:07,920 --> 00:07:12,450
compromised with malicious you know

00:07:09,990 --> 00:07:15,510
software running on their own systems

00:07:12,450 --> 00:07:18,510
that tries to spread to the cloud we

00:07:15,510 --> 00:07:20,730
have you know people that may have

00:07:18,510 --> 00:07:24,030
malicious intent and poses customers

00:07:20,730 --> 00:07:28,160
that happens in both enterprises and

00:07:24,030 --> 00:07:33,120
customers or regular consumers we've

00:07:28,160 --> 00:07:37,320
insiders from within the company who you

00:07:33,120 --> 00:07:39,900
know every company is is is exposed to

00:07:37,320 --> 00:07:41,820
maybe the same thing a rogue tech or or

00:07:39,900 --> 00:07:44,460
somebody with bad intentions that tries

00:07:41,820 --> 00:07:47,669
to penetrate how do we add security and

00:07:44,460 --> 00:07:49,470
depth and ensure that the damage they

00:07:47,669 --> 00:07:52,260
can they can cause is minimized

00:07:49,470 --> 00:07:53,910
we've also got supply chain Thrax system

00:07:52,260 --> 00:07:59,190
integrated threats and of course

00:07:53,910 --> 00:08:02,400
manufacturing threats project Cerberus

00:07:59,190 --> 00:08:04,290
is is focused primarily on on firmware

00:08:02,400 --> 00:08:06,530
security and the attack surface of

00:08:04,290 --> 00:08:12,600
firmware security

00:08:06,530 --> 00:08:15,860
what is that attack surface so you

00:08:12,600 --> 00:08:19,860
driver all driver firm or interfaces

00:08:15,860 --> 00:08:21,990
access to flash during boot firmware

00:08:19,860 --> 00:08:24,240
interfaces are exposed in the OS firmer

00:08:21,990 --> 00:08:26,790
interfaces are exposed a hypervisor

00:08:24,240 --> 00:08:29,070
environment if you're providing direct

00:08:26,790 --> 00:08:29,610
access to peripherals or the platform

00:08:29,070 --> 00:08:32,880
itself

00:08:29,610 --> 00:08:34,919
there's exposure there firmware in

00:08:32,880 --> 00:08:39,479
particular unlike upper level software

00:08:34,919 --> 00:08:41,849
you don't have a lot of detection and

00:08:39,479 --> 00:08:46,470
malware and in anything running at that

00:08:41,849 --> 00:08:48,120
low hardware level recovery if there if

00:08:46,470 --> 00:08:50,250
there are compromises there can be

00:08:48,120 --> 00:08:51,959
challenging is it can disable recovery

00:08:50,250 --> 00:08:52,500
interfaces or choose to completely

00:08:51,959 --> 00:08:55,020
ignore

00:08:52,500 --> 00:08:57,300
and then of course if you get

00:08:55,020 --> 00:08:59,580
compromised it can result in bricking

00:08:57,300 --> 00:09:04,710
loss of the asset and loss of data and

00:08:59,580 --> 00:09:08,940
so on but there is some some good

00:09:04,710 --> 00:09:13,620
guidance and hope true a set of of NIST

00:09:08,940 --> 00:09:17,760
standards that were republished about a

00:09:13,620 --> 00:09:21,000
year ago initially and then then

00:09:17,760 --> 00:09:25,320
ratified a little bit more recently and

00:09:21,000 --> 00:09:29,550
I was the nest 800 193 and it focuses on

00:09:25,320 --> 00:09:34,140
on three pillars to protection of

00:09:29,550 --> 00:09:36,270
firmware detection of corruption or

00:09:34,140 --> 00:09:40,440
unauthorized access and then of course

00:09:36,270 --> 00:09:44,760
the recovery so with these with these

00:09:40,440 --> 00:09:48,390
guiding principles we aligned our our

00:09:44,760 --> 00:09:53,340
security of platform firmware in a

00:09:48,390 --> 00:09:55,230
platform as a whole and to before we

00:09:53,340 --> 00:09:57,870
could do that we had to take a look at

00:09:55,230 --> 00:10:01,170
where we were at and the current state

00:09:57,870 --> 00:10:05,040
of the industry so the typical

00:10:01,170 --> 00:10:06,900
Enterprise Server in the industry lux

00:10:05,040 --> 00:10:09,600
maybe a little bit like this you get you

00:10:06,900 --> 00:10:11,130
a lot of awards see if you use you may

00:10:09,600 --> 00:10:13,140
or may not have a base board management

00:10:11,130 --> 00:10:15,330
controller and then you've got a bunch

00:10:13,140 --> 00:10:18,020
of peripheral cars second plug in some

00:10:15,330 --> 00:10:20,970
of those peripheral cards may be more

00:10:18,020 --> 00:10:25,140
powerful than a host CPUs themselves at

00:10:20,970 --> 00:10:28,260
certain workloads so security state

00:10:25,140 --> 00:10:31,050
you've got the base firmware you know

00:10:28,260 --> 00:10:33,420
UEFI there's some limited protection

00:10:31,050 --> 00:10:37,310
there secure boot like functionality

00:10:33,420 --> 00:10:41,730
there's measured boot through the TPM

00:10:37,310 --> 00:10:48,420
but the detection and the recovery or

00:10:41,730 --> 00:10:49,530
very not really not really all there it

00:10:48,420 --> 00:10:51,720
doesn't have it doesn't have complete

00:10:49,530 --> 00:10:53,370
coverage and it's very platform

00:10:51,720 --> 00:10:57,510
independent on how these things are

00:10:53,370 --> 00:11:00,180
implemented BMC of course typically not

00:10:57,510 --> 00:11:03,030
secure no protection detection and

00:11:00,180 --> 00:11:05,580
recovery ability or attestation and and

00:11:03,030 --> 00:11:06,480
arrested or for peripherals that you'll

00:11:05,580 --> 00:11:08,519
find inside

00:11:06,480 --> 00:11:14,760
enterprise platform they follow the same

00:11:08,519 --> 00:11:19,320
suit so it brings us to project Cerberus

00:11:14,760 --> 00:11:22,399
and what is project service well it's a

00:11:19,320 --> 00:11:25,079
set of requirements around platform

00:11:22,399 --> 00:11:29,040
power sequencing and when and where and

00:11:25,079 --> 00:11:30,600
how to establish trust it's also a set

00:11:29,040 --> 00:11:33,930
of requirements around firmware

00:11:30,600 --> 00:11:37,139
integrity how to verify it how to

00:11:33,930 --> 00:11:41,579
measure it and then it's a chip that

00:11:37,139 --> 00:11:47,250
implements and enforces all three of

00:11:41,579 --> 00:11:54,389
those things so the Cerberus root of

00:11:47,250 --> 00:11:59,100
trust implements the the guidelines from

00:11:54,389 --> 00:12:02,910
that nest 800 193 it's a it's a

00:11:59,100 --> 00:12:07,560
microcontroller that enforces digital

00:12:02,910 --> 00:12:09,389
signatures on firmware and components

00:12:07,560 --> 00:12:12,660
that don't necessarily intrinsically

00:12:09,389 --> 00:12:16,410
have any and we'll get to how it does

00:12:12,660 --> 00:12:19,980
that a little bit it provides protection

00:12:16,410 --> 00:12:22,170
to not only to platform firmware but

00:12:19,980 --> 00:12:25,019
also the peripherals that get plugged

00:12:22,170 --> 00:12:27,750
into the platform so your BIOS your VM C

00:12:25,019 --> 00:12:29,670
and all your PCIe add-in cards and

00:12:27,750 --> 00:12:32,100
whatnot

00:12:29,670 --> 00:12:34,050
of course it's it's CPU and vendor

00:12:32,100 --> 00:12:36,750
agnostic so when we go back and we had a

00:12:34,050 --> 00:12:40,490
look across those vendors of the project

00:12:36,750 --> 00:12:43,620
Olympus of the project project Olympus

00:12:40,490 --> 00:12:46,560
system architecture there's multiple CPU

00:12:43,620 --> 00:12:49,769
providers and multiple hardware

00:12:46,560 --> 00:12:52,139
manufacturers that have been consistent

00:12:49,769 --> 00:12:56,699
or mismatched security this puts

00:12:52,139 --> 00:13:00,149
everybody at a common standard so what

00:12:56,699 --> 00:13:03,029
is the Cerberus ASIC it's a security

00:13:00,149 --> 00:13:06,449
microprocessor with internal secure

00:13:03,029 --> 00:13:09,410
memory and flash contains the

00:13:06,449 --> 00:13:12,720
accelerator typical accelerator blocks

00:13:09,410 --> 00:13:15,899
sha AES it's got a random number

00:13:12,720 --> 00:13:18,510
generator it's got a public key engine

00:13:15,899 --> 00:13:20,170
for public key acceleration a lot of

00:13:18,510 --> 00:13:22,380
functions and key derivation

00:13:20,170 --> 00:13:29,649
you typically do it with public keys

00:13:22,380 --> 00:13:31,420
some efj uses for its its own hash or

00:13:29,649 --> 00:13:34,120
measurement of a public key that we use

00:13:31,420 --> 00:13:36,610
to load the firmware on on it it's got a

00:13:34,120 --> 00:13:41,649
physically uncountable function or a

00:13:36,610 --> 00:13:43,620
puff for some additional entropy and

00:13:41,649 --> 00:13:46,870
it's got the Device Identifier

00:13:43,620 --> 00:13:52,600
composition engine that is part of the

00:13:46,870 --> 00:13:56,110
TCG it also has which allows it to to be

00:13:52,600 --> 00:13:57,699
coupled with a a CV or component that

00:13:56,110 --> 00:14:01,240
doesn't have any security intrinsically

00:13:57,699 --> 00:14:04,930
in it and that is a special interface

00:14:01,240 --> 00:14:07,470
that we designed to work with spy and

00:14:04,930 --> 00:14:09,940
cue spy and a lot of that

00:14:07,470 --> 00:14:12,220
microcontroller be plugged on see me

00:14:09,940 --> 00:14:15,040
ously without the host CPU even knowing

00:14:12,220 --> 00:14:17,019
it's there and of course it's got all

00:14:15,040 --> 00:14:21,930
the physical anti-tamper as well to

00:14:17,019 --> 00:14:25,360
protect the secrets that it generates

00:14:21,930 --> 00:14:26,769
so the interpose interface and how it

00:14:25,360 --> 00:14:29,680
actually works so your typical

00:14:26,769 --> 00:14:32,860
processors have a boot ROM the boot up

00:14:29,680 --> 00:14:36,820
they read in some additional

00:14:32,860 --> 00:14:37,350
instructions from from flash what

00:14:36,820 --> 00:14:40,329
happens

00:14:37,350 --> 00:14:43,449
if what's on that flash is really

00:14:40,329 --> 00:14:45,820
important a lot of those processors will

00:14:43,449 --> 00:14:49,660
just read in whatever is there and go

00:14:45,820 --> 00:14:54,790
and execute so to ensure what's on the

00:14:49,660 --> 00:14:56,170
flash is as signed and is is if good

00:14:54,790 --> 00:15:00,010
integrity and what we want to actually

00:14:56,170 --> 00:15:02,500
be there we interpose on that and in

00:15:00,010 --> 00:15:05,110
between it this Cerberus microcontroller

00:15:02,500 --> 00:15:09,390
so I talked earlier about the the

00:15:05,110 --> 00:15:12,760
properties of the project Cerberus and

00:15:09,390 --> 00:15:17,199
it was a bunch of specifications and

00:15:12,760 --> 00:15:19,540
what processors must meet in order to be

00:15:17,199 --> 00:15:22,000
considered secure or Cerberus compliant

00:15:19,540 --> 00:15:24,970
if they're not then they get this

00:15:22,000 --> 00:15:27,970
microcontroller interposed between dam

00:15:24,970 --> 00:15:31,180
under firmware load/store what does this

00:15:27,970 --> 00:15:33,250
microcontroller do all firmware that's

00:15:31,180 --> 00:15:34,060
on that flash is authenticated before

00:15:33,250 --> 00:15:37,300
CPUs are

00:15:34,060 --> 00:15:39,610
taken out a reset the Cerberus

00:15:37,300 --> 00:15:41,830
microcontroller stays in line all

00:15:39,610 --> 00:15:45,460
firmware that's read in through the CPU

00:15:41,830 --> 00:15:52,290
is measured all spy transactions are

00:15:45,460 --> 00:15:56,620
filtered so common platform design is

00:15:52,290 --> 00:15:58,930
you will take a a spy flash chip of or

00:15:56,620 --> 00:16:01,420
an or flash chip of a given size 32

00:15:58,930 --> 00:16:04,450
Meg's or 16 Meg's or 8 Meg's firmware

00:16:01,420 --> 00:16:07,240
image might only be 4 might only be 2 so

00:16:04,450 --> 00:16:08,500
you've got what a typical secure boot

00:16:07,240 --> 00:16:10,540
it's only going to measure the firmware

00:16:08,500 --> 00:16:12,940
that it's reading in to load but you've

00:16:10,540 --> 00:16:16,420
got a lot of flash that's like a little

00:16:12,940 --> 00:16:17,110
black box or a blind spot to your to

00:16:16,420 --> 00:16:18,880
your system

00:16:17,110 --> 00:16:21,730
so what servers will do is it will

00:16:18,880 --> 00:16:25,960
ensure that that unused flash is

00:16:21,730 --> 00:16:28,630
unreadable and that data portions or

00:16:25,960 --> 00:16:30,820
firmware regions of the flash that is

00:16:28,630 --> 00:16:33,040
readable is unraidable

00:16:30,820 --> 00:16:38,770
almost a firmware that's been sent to it

00:16:33,040 --> 00:16:42,370
is is authenticated so in enforcing

00:16:38,770 --> 00:16:43,600
those NIST principles that we we talked

00:16:42,370 --> 00:16:47,140
about I'm going to circle back that

00:16:43,600 --> 00:16:50,260
that's standard quite a bit the

00:16:47,140 --> 00:16:51,850
protection where all flash accesses are

00:16:50,260 --> 00:16:53,470
filtered through this service ASIC it

00:16:51,850 --> 00:16:56,590
stays in line when the platform is

00:16:53,470 --> 00:17:01,840
running it ensures that any access is

00:16:56,590 --> 00:17:05,950
out to firmware or or write or read I

00:17:01,840 --> 00:17:08,190
guess and are protected it authenticates

00:17:05,950 --> 00:17:12,400
any firmware that's coming in and

00:17:08,190 --> 00:17:14,110
there's a a feature which will we'll get

00:17:12,400 --> 00:17:17,350
to a little bit later on of it called a

00:17:14,110 --> 00:17:21,220
platform firmware manifest so in the

00:17:17,350 --> 00:17:23,200
cloud you know software and firmware or

00:17:21,220 --> 00:17:26,740
continuously updated as you manage this

00:17:23,200 --> 00:17:30,790
this large fleet you you have to be

00:17:26,740 --> 00:17:33,550
dynamic in enrolling updates seamlessly

00:17:30,790 --> 00:17:36,690
throughout the fleet you know so at any

00:17:33,550 --> 00:17:39,480
one point in time there there could be

00:17:36,690 --> 00:17:42,400
you know the latest and greatest

00:17:39,480 --> 00:17:44,530
firmware but the following day when you

00:17:42,400 --> 00:17:46,630
spin a new firmware or or whenever your

00:17:44,530 --> 00:17:47,830
new firmware comes comes along your

00:17:46,630 --> 00:17:49,799
fleet is that

00:17:47,830 --> 00:17:54,130
a you know yesterday's version

00:17:49,799 --> 00:17:57,399
essentially an minus one so the platform

00:17:54,130 --> 00:17:59,740
firmware manifest allows us to give

00:17:57,399 --> 00:18:02,289
known good but knowing good firmware

00:17:59,740 --> 00:18:04,450
versions or measurements of no good

00:18:02,289 --> 00:18:06,700
known good firmware versions into the

00:18:04,450 --> 00:18:10,570
service microcontroller and only those

00:18:06,700 --> 00:18:12,730
versions can run on the platform so what

00:18:10,570 --> 00:18:20,380
that gives us is the ability to maintain

00:18:12,730 --> 00:18:23,049
a good state and it's kind of like a

00:18:20,380 --> 00:18:25,929
soft ante rollback feature and roll

00:18:23,049 --> 00:18:30,669
forward feature without the need to go

00:18:25,929 --> 00:18:33,789
and blow TP fuses the detection

00:18:30,669 --> 00:18:36,820
mechanism of course served the server's

00:18:33,789 --> 00:18:39,370
ASIC has secure boot it does its own

00:18:36,820 --> 00:18:43,539
secure boot attest to its own

00:18:39,370 --> 00:18:46,720
measurements it'll also go and measure

00:18:43,539 --> 00:18:48,340
the firmware that it's supposed to be

00:18:46,720 --> 00:18:51,760
protecting for the device is supposed to

00:18:48,340 --> 00:18:55,720
be protecting and include that into its

00:18:51,760 --> 00:18:57,880
measurements recovery which was the

00:18:55,720 --> 00:19:02,700
other principle of the NIST

00:18:57,880 --> 00:19:07,630
eight 193 the recovery is a policy based

00:19:02,700 --> 00:19:09,850
in in Cerberus where we'll have bare

00:19:07,630 --> 00:19:11,710
metal recovery if the system is off we

00:19:09,850 --> 00:19:13,750
can do recovering irrespective of the

00:19:11,710 --> 00:19:17,350
power state to the platform we were able

00:19:13,750 --> 00:19:21,309
to recover firmware images at any point

00:19:17,350 --> 00:19:22,690
in time to a known good image as I

00:19:21,309 --> 00:19:25,750
mentioned earlier a flash access

00:19:22,690 --> 00:19:28,059
protected by service and we have

00:19:25,750 --> 00:19:30,279
automatic recovery flows should any

00:19:28,059 --> 00:19:32,679
corruption whether it's a bit blit flip

00:19:30,279 --> 00:19:37,570
or attempt that a malicious attack occur

00:19:32,679 --> 00:19:41,399
we can of course rectify that with some

00:19:37,570 --> 00:19:41,399
automatic workflow from what in Cerberus

00:19:42,960 --> 00:19:50,679
now there's there's a lot one of the

00:19:47,889 --> 00:19:55,389
reasons we went down the the Cerberus

00:19:50,679 --> 00:19:57,820
path or into service as a lot of folks

00:19:55,389 --> 00:20:01,240
are our Hardware suppliers are very

00:19:57,820 --> 00:20:01,539
focused on an individual product if

00:20:01,240 --> 00:20:03,249
you're

00:20:01,539 --> 00:20:05,109
you manufacturer you you know you're

00:20:03,249 --> 00:20:08,769
worried about the cpu the the the

00:20:05,109 --> 00:20:10,720
security at CPU and that's it when you

00:20:08,769 --> 00:20:12,789
take a whole system together and you're

00:20:10,720 --> 00:20:16,029
worried about all of the components and

00:20:12,789 --> 00:20:20,649
how they how to interoperate and the the

00:20:16,029 --> 00:20:23,259
state of the platform when it's booted

00:20:20,649 --> 00:20:25,539
and when it's running like when we take

00:20:23,259 --> 00:20:27,669
into consideration typical you know

00:20:25,539 --> 00:20:29,649
secure boot you're gonna read in some

00:20:27,669 --> 00:20:31,749
option roms anything into boot path

00:20:29,649 --> 00:20:33,999
you're probably going to measure but

00:20:31,749 --> 00:20:36,879
what about stuff that's not in the boot

00:20:33,999 --> 00:20:38,259
path accelerators GPUs microcontrollers

00:20:36,879 --> 00:20:39,489
that are out on all of these different

00:20:38,259 --> 00:20:41,409
components that are running in the

00:20:39,489 --> 00:20:46,479
system some of them more powerful than

00:20:41,409 --> 00:20:49,239
host CPU so with that we you know the

00:20:46,479 --> 00:20:51,789
Cerberus architecture was hierarchical

00:20:49,239 --> 00:20:55,529
in that we wanted to have this scalable

00:20:51,789 --> 00:20:58,690
architecture where we could have a

00:20:55,529 --> 00:21:01,119
entity on a platform attached for all

00:20:58,690 --> 00:21:03,609
those other components in that platform

00:21:01,119 --> 00:21:06,190
we wanted to be able to access that

00:21:03,609 --> 00:21:10,119
before we initially before we initialize

00:21:06,190 --> 00:21:12,340
the platform during initialization an

00:21:10,119 --> 00:21:13,599
active route at thrust should be

00:21:12,340 --> 00:21:15,099
available all the time I should be able

00:21:13,599 --> 00:21:16,809
to ask it hey what's the state of

00:21:15,099 --> 00:21:19,210
firmware firmware gets updated at

00:21:16,809 --> 00:21:20,499
runtime not only during boot when

00:21:19,210 --> 00:21:22,179
firmware gets updated at run time

00:21:20,499 --> 00:21:24,190
measurements change I want to know

00:21:22,179 --> 00:21:29,499
what's the state of the platform at any

00:21:24,190 --> 00:21:31,720
point in time so that brought us to this

00:21:29,499 --> 00:21:35,019
master slave hierarchy throughout the

00:21:31,720 --> 00:21:38,190
system components that that didn't meet

00:21:35,019 --> 00:21:40,359
those standards we'd have the ASIC

00:21:38,190 --> 00:21:43,090
interposed components that did

00:21:40,359 --> 00:21:44,590
intrinsically support those just fitted

00:21:43,090 --> 00:21:51,929
into default because it would also

00:21:44,590 --> 00:21:54,489
conform to the attestation protocol the

00:21:51,929 --> 00:21:57,129
platform level attestation as I

00:21:54,489 --> 00:21:59,049
mentioned the single measurement we

00:21:57,129 --> 00:22:01,599
extend and using some acronyms here

00:21:59,049 --> 00:22:05,109
platform firmware manifest component

00:22:01,599 --> 00:22:09,820
firmware manifests and component device

00:22:05,109 --> 00:22:12,700
file are all act you know acronyms that

00:22:09,820 --> 00:22:14,440
are in distress certification but what

00:22:12,700 --> 00:22:16,960
these what they stand for

00:22:14,440 --> 00:22:21,840
essentially manifests of measurements of

00:22:16,960 --> 00:22:21,840
permitted firmware per device

00:22:22,379 --> 00:22:29,230
there's measurement logs that come out

00:22:25,990 --> 00:22:31,570
of the the Cerberus platform ASIC and

00:22:29,230 --> 00:22:35,379
then of course there's a certificate

00:22:31,570 --> 00:22:39,009
ceiling for four machines based on their

00:22:35,379 --> 00:22:41,860
ability to attest so as servers attest

00:22:39,009 --> 00:22:43,840
to the firmware machines that are in

00:22:41,860 --> 00:22:50,350
goods they get essentially a cookie on

00:22:43,840 --> 00:22:54,330
the end of fabric so a little more about

00:22:50,350 --> 00:22:58,600
the the the Cerberus security controller

00:22:54,330 --> 00:23:02,590
enforces the guidelines from from the

00:22:58,600 --> 00:23:05,220
NIST standard it is a a small

00:23:02,590 --> 00:23:08,080
microcontroller it's also a bunch of

00:23:05,220 --> 00:23:12,090
platform specifications

00:23:08,080 --> 00:23:14,860
it's a hierarchical root of trust with

00:23:12,090 --> 00:23:20,460
topology that provides that a station

00:23:14,860 --> 00:23:23,769
for all firmware and it's an open design

00:23:20,460 --> 00:23:25,870
we open up the specifications and and

00:23:23,769 --> 00:23:28,179
more of the collateral for service will

00:23:25,870 --> 00:23:31,269
follow if you want to know more about it

00:23:28,179 --> 00:23:35,379
if you want to participate in it we

00:23:31,269 --> 00:23:40,240
encourage you to join the security

00:23:35,379 --> 00:23:45,090
project in OCP and with that I'll take

00:23:40,240 --> 00:23:45,090
maybe some questions keep it some time

00:23:51,360 --> 00:23:56,309
yes sir a couple of things so first one

00:23:54,490 --> 00:24:02,740
you talked about the Recovery Options

00:23:56,309 --> 00:24:04,809
and talked about automatic recovery

00:24:02,740 --> 00:24:09,940
workflow on detection and corruption is

00:24:04,809 --> 00:24:13,330
there any path to provide reporting of

00:24:09,940 --> 00:24:17,380
that if it takes place yeah absolutely

00:24:13,330 --> 00:24:19,240
so one of the things would it is it's

00:24:17,380 --> 00:24:20,919
it's alive and running all the time it

00:24:19,240 --> 00:24:22,029
doesn't boot and then go sleep or boot

00:24:20,919 --> 00:24:22,419
and load and go off and do something

00:24:22,029 --> 00:24:26,380
else

00:24:22,419 --> 00:24:29,409
this tcv is active all at a time so as

00:24:26,380 --> 00:24:31,929
we we decide to go and measure it or ask

00:24:29,409 --> 00:24:34,570
it for measurements it'll provide you

00:24:31,929 --> 00:24:37,690
the most current measurement in addition

00:24:34,570 --> 00:24:40,600
to that when anything changes it will

00:24:37,690 --> 00:24:43,659
raise another so there's a there's like

00:24:40,600 --> 00:24:45,220
a interrupts that will come from the

00:24:43,659 --> 00:24:46,690
from the ASIC and go into the platform

00:24:45,220 --> 00:24:48,789
to raise an alert to the attestation

00:24:46,690 --> 00:24:51,549
agent and then I will play back into the

00:24:48,789 --> 00:24:52,210
fabric so any changes that are

00:24:51,549 --> 00:24:58,179
unexpected

00:24:52,210 --> 00:25:00,070
we get a notification and the P FM's I

00:24:58,179 --> 00:25:02,019
might you know I did have some backup

00:25:00,070 --> 00:25:04,149
slides to go into a Cerberus deconstruct

00:25:02,019 --> 00:25:06,309
but I was I was running a little over

00:25:04,149 --> 00:25:11,529
time but what I will do is I'll jump

00:25:06,309 --> 00:25:13,889
down into a key element of it which is a

00:25:11,529 --> 00:25:15,970
platform firmware manifest and

00:25:13,889 --> 00:25:20,409
essentially in our build system when we

00:25:15,970 --> 00:25:22,090
build firmware it spits out a manifest

00:25:20,409 --> 00:25:23,710
and a manifest of course looks like you

00:25:22,090 --> 00:25:26,529
know if you it spits it out in this

00:25:23,710 --> 00:25:28,960
human readable form if you consider you

00:25:26,529 --> 00:25:31,389
know XML human readable but it

00:25:28,960 --> 00:25:32,950
eventually gets built into a binary list

00:25:31,389 --> 00:25:34,960
that lists all firmware that's

00:25:32,950 --> 00:25:36,669
applicable for that platform so you

00:25:34,960 --> 00:25:40,630
could have you know firmware version one

00:25:36,669 --> 00:25:42,610
two three skip four five six seven and

00:25:40,630 --> 00:25:46,899
they might be fine to run an any given

00:25:42,610 --> 00:25:49,630
component those those lists are

00:25:46,899 --> 00:25:51,700
monotonic so you you know you flash it

00:25:49,630 --> 00:25:54,850
once it can't take a previous list so

00:25:51,700 --> 00:25:57,399
there's no replay on the list I provide

00:25:54,850 --> 00:25:59,889
it allows us to keep the fabric at

00:25:57,399 --> 00:26:01,510
different states in firmer because it's

00:25:59,889 --> 00:26:02,350
always it's always transition and you

00:26:01,510 --> 00:26:06,160
know you got a tail

00:26:02,350 --> 00:26:08,770
and that might not get updated as it

00:26:06,160 --> 00:26:10,630
might be on the last version of firmware

00:26:08,770 --> 00:26:12,280
as you're going to delete update

00:26:10,630 --> 00:26:15,400
everything to the newest and change

00:26:12,280 --> 00:26:19,690
those out of station policies so this by

00:26:15,400 --> 00:26:22,600
taking that essentially the the part of

00:26:19,690 --> 00:26:24,250
the attestation policy and making this

00:26:22,600 --> 00:26:26,260
route a thrust be responsible for the

00:26:24,250 --> 00:26:28,929
enforcement to that it makes that higher

00:26:26,260 --> 00:26:31,390
level attestation a lot easier to manage

00:26:28,929 --> 00:26:34,030
and the other thing is you use the word

00:26:31,390 --> 00:26:35,020
tamper proof can we Alize never use the

00:26:34,030 --> 00:26:37,799
word time

00:26:35,020 --> 00:26:42,190
I mean 801 93 98 it talks about

00:26:37,799 --> 00:26:43,870
resistance to tampering yes and I may

00:26:42,190 --> 00:26:46,809
just be me but I hate the word temper if

00:26:43,870 --> 00:26:50,020
because resistance all good but please

00:26:46,809 --> 00:26:52,090
never tamper proof yeah good point so I

00:26:50,020 --> 00:26:54,880
just I just had Podge that together

00:26:52,090 --> 00:26:56,679
yesterday after my talk and realized

00:26:54,880 --> 00:27:00,309
that I I might have been starting at a

00:26:56,679 --> 00:27:02,169
level and in Cerberus and going into the

00:27:00,309 --> 00:27:03,610
deconstruct without too many people been

00:27:02,169 --> 00:27:07,710
familiar would open compute and what

00:27:03,610 --> 00:27:07,710
exactly service was but point well taken

00:27:08,890 --> 00:27:16,929
is it possible to use certified elements

00:27:12,280 --> 00:27:20,200
with some servers I'm sorry and is it

00:27:16,929 --> 00:27:23,260
possible to use an an al certified

00:27:20,200 --> 00:27:26,710
secure element OS secure element inside

00:27:23,260 --> 00:27:30,150
in Cerberus or instead of Cerberus is oh

00:27:26,710 --> 00:27:33,429
yes the the ASIC has a a secure element

00:27:30,150 --> 00:27:35,230
which gets back to my friends comment

00:27:33,429 --> 00:27:36,909
here about you know tamper proof convert

00:27:35,230 --> 00:27:39,669
to tamper resistance but you know it's

00:27:36,909 --> 00:27:42,010
got a secure element inside for storage

00:27:39,669 --> 00:27:46,150
of its of the keys and the entropy that

00:27:42,010 --> 00:27:48,190
it generates okay but it's not satisfied

00:27:46,150 --> 00:27:50,020
yes it's it's it's not it's not

00:27:48,190 --> 00:27:53,530
certified at this point in time it's not

00:27:50,020 --> 00:27:56,620
certified yeah so and do you have well

00:27:53,530 --> 00:27:58,840
what kind of physical secure partition

00:27:56,620 --> 00:28:02,530
do you have yes

00:27:58,840 --> 00:28:04,539
pardon do you have sites another yes

00:28:02,530 --> 00:28:07,840
sorry channel protection cheetahs as

00:28:04,539 --> 00:28:11,950
well yes so it has side channel

00:28:07,840 --> 00:28:15,100
protections the the thing about the

00:28:11,950 --> 00:28:15,970
certification and why it's not pursued

00:28:15,100 --> 00:28:17,830
yet on the

00:28:15,970 --> 00:28:20,070
certification actually takes you know

00:28:17,830 --> 00:28:25,930
quite a bit of time we announced this in

00:28:20,070 --> 00:28:29,110
in October of last year the

00:28:25,930 --> 00:28:31,450
certification - depending on where you

00:28:29,110 --> 00:28:33,070
are in the world different things are

00:28:31,450 --> 00:28:34,200
acceptable you know even Europe you got

00:28:33,070 --> 00:28:36,850
the Common Criteria

00:28:34,200 --> 00:28:38,980
over here you have the fifths in China

00:28:36,850 --> 00:28:42,820
you've got a whole different ballgame

00:28:38,980 --> 00:28:46,140
so um the the certification is something

00:28:42,820 --> 00:28:48,790
we're looking at through often confute

00:28:46,140 --> 00:28:50,860
it's it's still really TVD on what

00:28:48,790 --> 00:28:53,410
direction hell will go great question

00:28:50,860 --> 00:28:59,320
that's I guess looking at smart cards

00:28:53,410 --> 00:29:05,770
design may be interesting yes another

00:28:59,320 --> 00:29:07,450
question so when your chip is reading

00:29:05,770 --> 00:29:09,250
the firmware of the other chips to make

00:29:07,450 --> 00:29:11,380
sure they're valid is it just basically

00:29:09,250 --> 00:29:13,990
asking them hey could you tell me what's

00:29:11,380 --> 00:29:17,230
in me another compromised chip lie about

00:29:13,990 --> 00:29:21,550
that um no it's it's it's not it's

00:29:17,230 --> 00:29:25,690
actually mastering the bus at that point

00:29:21,550 --> 00:29:29,020
in time so it stays in line on what gets

00:29:25,690 --> 00:29:32,650
read so that all spices actions you know

00:29:29,020 --> 00:29:38,290
they don't they don't complete as you

00:29:32,650 --> 00:29:42,130
would think the the ASIC interposes if I

00:29:38,290 --> 00:29:44,110
go back I might be easier to to explain

00:29:42,130 --> 00:29:50,410
to the through the drawing that I

00:29:44,110 --> 00:29:50,830
rendered earlier here well where didn't

00:29:50,410 --> 00:29:56,410
we go

00:29:50,830 --> 00:30:00,280
I went back a little too far but the the

00:29:56,410 --> 00:30:03,160
host the host processors cannot access

00:30:00,280 --> 00:30:05,380
that flash directly they think they're

00:30:03,160 --> 00:30:09,790
accessing the flash directly but they're

00:30:05,380 --> 00:30:14,410
actually accessing the ASIC um in in

00:30:09,790 --> 00:30:16,210
flash as you know is it's like a memory

00:30:14,410 --> 00:30:19,120
interface it's not like you know

00:30:16,210 --> 00:30:22,840
transactional would have payload so it

00:30:19,120 --> 00:30:25,420
has to happen in really tight time the

00:30:22,840 --> 00:30:28,400
ASIC has to make a decision on whether

00:30:25,420 --> 00:30:31,430
it allows the host processor

00:30:28,400 --> 00:30:33,710
to access firmware from that device and

00:30:31,430 --> 00:30:37,550
there's a couple of techniques that we

00:30:33,710 --> 00:30:38,960
use to achieve that one of course is we

00:30:37,550 --> 00:30:40,490
have a special hardware interface that

00:30:38,960 --> 00:30:42,440
provides that bit stream kind of

00:30:40,490 --> 00:30:45,710
filtering and the other one is a little

00:30:42,440 --> 00:30:48,980
bit of a honeypot design the a sigit

00:30:45,710 --> 00:30:52,460
course or the the spy interface on on

00:30:48,980 --> 00:30:54,410
two processors in some cases those will

00:30:52,460 --> 00:30:56,720
go into a crazy control loop and an

00:30:54,410 --> 00:30:58,640
assert and do all kinds of stuff if it

00:30:56,720 --> 00:31:02,090
doesn't get a read back from from spy

00:30:58,640 --> 00:31:04,460
within a certain time or if it doesn't

00:31:02,090 --> 00:31:06,410
read back the data it expects so for

00:31:04,460 --> 00:31:09,200
that the ASIC is able to essentially

00:31:06,410 --> 00:31:13,309
honeypot it let it let it think it's

00:31:09,200 --> 00:31:14,450
doing watching but do another I don't

00:31:13,309 --> 00:31:16,790
know if that answers your question or

00:31:14,450 --> 00:31:19,190
not you can it's sort of an attack I've

00:31:16,790 --> 00:31:21,200
heard in the past is you can't really

00:31:19,190 --> 00:31:23,660
you can't really trust any device to

00:31:21,200 --> 00:31:26,420
tell you what's on itself this you're

00:31:23,660 --> 00:31:28,160
not using it that same way but it sounds

00:31:26,420 --> 00:31:30,230
like in the case where there's flash

00:31:28,160 --> 00:31:32,660
supper from a processor then you can do

00:31:30,230 --> 00:31:34,700
that but are there cases like where a

00:31:32,660 --> 00:31:39,320
chip has its own internal storage that

00:31:34,700 --> 00:31:41,600
you try to verify yes there are and the

00:31:39,320 --> 00:31:45,620
internal the internal chap you you you

00:31:41,600 --> 00:31:47,990
can't interpose the the Cerberus ASIC so

00:31:45,620 --> 00:31:51,860
it's a case of either working with with

00:31:47,990 --> 00:31:55,370
the manufacturer to to ROM that internal

00:31:51,860 --> 00:31:58,220
storage and make it not not updatable

00:31:55,370 --> 00:32:00,350
and to read externally to fuse that boot

00:31:58,220 --> 00:32:03,920
usually it's pin strapping to change

00:32:00,350 --> 00:32:05,780
that boot path off or to adapt the

00:32:03,920 --> 00:32:10,100
security requirements that we put inside

00:32:05,780 --> 00:32:13,460
in Cerberus but every component has to

00:32:10,100 --> 00:32:16,910
be analyzed pretty much at face value

00:32:13,460 --> 00:32:21,800
it's a lot easier when of components

00:32:16,910 --> 00:32:24,380
doesn't have intrinsic security to

00:32:21,800 --> 00:32:27,980
interpose the an ASIC on the side of it

00:32:24,380 --> 00:32:31,970
or outside of it as opposed to going to

00:32:27,980 --> 00:32:34,280
a development cycle and having that

00:32:31,970 --> 00:32:36,650
functionality so in other words it's

00:32:34,280 --> 00:32:38,660
easier to change a PCB a than it is to

00:32:36,650 --> 00:32:41,020
change the substrate time is going to be

00:32:38,660 --> 00:32:41,020
a lot less

00:32:41,160 --> 00:32:44,880
time to market that is which is a core

00:32:43,049 --> 00:32:47,630
also key in the cloud right at the back

00:32:44,880 --> 00:32:47,630
we got another question

00:32:49,309 --> 00:32:54,390
so you briefly mention about the use of

00:32:51,660 --> 00:32:58,410
puff for additional entropy yes what

00:32:54,390 --> 00:33:03,690
kind of puff is delay base Ram base it's

00:32:58,410 --> 00:33:06,690
rubbish resilient against non tough

00:33:03,690 --> 00:33:10,590
attacks there are many of those products

00:33:06,690 --> 00:33:14,669
yes yes so that memory that we have in

00:33:10,590 --> 00:33:17,280
sight for the puff we actually have the

00:33:14,669 --> 00:33:19,620
that memory over as part of this the

00:33:17,280 --> 00:33:21,030
secure element there's a mesh over it

00:33:19,620 --> 00:33:22,830
with drive current through it if we did

00:33:21,030 --> 00:33:24,720
attacked there say changing the state

00:33:22,830 --> 00:33:27,030
yes Ram if we detect that there's a

00:33:24,720 --> 00:33:32,880
tamper on there we also have a side

00:33:27,030 --> 00:33:38,100
channel attack side channel measurements

00:33:32,880 --> 00:33:39,840
in there too so in despising the flash

00:33:38,100 --> 00:33:45,590
accesses at the moment have you looked

00:33:39,840 --> 00:33:48,450
at any other buses say LPC we have

00:33:45,590 --> 00:33:51,539
considered that the the the thing is

00:33:48,450 --> 00:33:53,370
it's to hit it to hit the timing it's

00:33:51,539 --> 00:33:55,260
not done in firmware or software it's

00:33:53,370 --> 00:33:57,179
all it's a it's a new hardware

00:33:55,260 --> 00:33:59,760
peripheral essentially every to

00:33:57,179 --> 00:34:02,280
interpose in Sderot and keep the same

00:33:59,760 --> 00:34:04,559
timing under bus you can it you can't

00:34:02,280 --> 00:34:07,710
achieve it with with software and DMA

00:34:04,559 --> 00:34:10,230
chaining your your set of times in dmae

00:34:07,710 --> 00:34:13,950
just gonna make you have to run that bus

00:34:10,230 --> 00:34:16,710
really really slowly so to keep up with

00:34:13,950 --> 00:34:18,179
performance and boot performance it's an

00:34:16,710 --> 00:34:19,859
interface but we are looking other

00:34:18,179 --> 00:34:27,690
hardware interfaces and being able to

00:34:19,859 --> 00:34:30,000
interpose anymore guess it's lunch right

00:34:27,690 --> 00:34:33,840
ah we've actually got one more oh yeah

00:34:30,000 --> 00:34:36,139
one more alright it's alright thanks a

00:34:33,840 --> 00:34:36,139

YouTube URL: https://www.youtube.com/watch?v=oUvKEw8OchI


