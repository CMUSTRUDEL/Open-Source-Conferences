Title: Making C Less Dangerous - Kees Cook, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Making C Less Dangerous - Kees Cook, Google

With the kernel written in C, it comes with some worrisome baggage, "undefined" behaviors, and other weaknesses that lead to security flaws and vulnerable infrastructure. Some of these weaknesses related to the design of chipsets and how close C is to machine code, but others are less specific.

This presentation will explore the areas where the kernel is changing the C standard, defining undefined behaviors, or otherwise reorganizing things to make C itself less of a hazard.

Specifically this will cover removing (and enforcing the lack of) Variable Length Arrays in kernel code, forcing all stack variables to be initialized with a GCC plugin, performing implicit bounds checking with overloaded builtins, handling arithmetic overflows safely, and protecting forward (call) and reverse (return) indirect function calls with CFI under Clang.

About Kees Cook
Kees Cook has been working with Free Software since 1994, and has been a Debian Developer since 2007. He is currently employed as a Linux kernel security engineer by Google, working on Android and and Chrome OS. From 2006 through 2011 he worked for Canonical as the Ubuntu Security Team's Tech Lead, and remains on the Ubuntu Technical Board. Before that, he worked as the lead sysadmin at OSDL, before it was the Linux Foundation. He has written various utilities including GOPchop and Sendpage, and contributes randomly to other projects including fun chunks of code in OpenSSH, Inkscape, Wine, MPlayer, and Wireshark. He's been spending most of his time lately focused on security features in the Linux Kernel.
Captions: 
	00:00:00,030 --> 00:00:09,389
hi my name is case cook this is a little

00:00:05,609 --> 00:00:11,010
bit about a specific area of the kernel

00:00:09,389 --> 00:00:14,099
cell production project sort of looking

00:00:11,010 --> 00:00:16,859
at the C language generally and why it

00:00:14,099 --> 00:00:19,289
causes us so many problems and what

00:00:16,859 --> 00:00:22,050
sorts of things we can do to improve

00:00:19,289 --> 00:00:24,689
that if you want to follow along any of

00:00:22,050 --> 00:00:27,539
the links or read some of the very small

00:00:24,689 --> 00:00:30,750
text I have in here you can download the

00:00:27,539 --> 00:00:32,820
slides there or once I get that linked

00:00:30,750 --> 00:00:39,840
from the Linux Foundation website as

00:00:32,820 --> 00:00:45,059
well so this is specifically about the

00:00:39,840 --> 00:00:46,590
Linux kernel obviously and the agenda

00:00:45,059 --> 00:00:50,280
here is I want to give sort of a quick

00:00:46,590 --> 00:00:52,469
background on KS pp and talking about C

00:00:50,280 --> 00:00:56,430
as a language and how it's really just a

00:00:52,469 --> 00:00:59,160
fancy assembler and then looking towards

00:00:56,430 --> 00:01:03,649
to some specific issues that we can try

00:00:59,160 --> 00:01:03,649
to solve hopefully or at least minimize

00:01:04,400 --> 00:01:10,320
so the kernel self protection project

00:01:07,640 --> 00:01:16,020
was started a couple years ago to sort

00:01:10,320 --> 00:01:18,299
of focus on bringing kernel protections

00:01:16,020 --> 00:01:21,060
into the kernel and we've had a lot over

00:01:18,299 --> 00:01:23,340
the years of protections the kernel

00:01:21,060 --> 00:01:26,250
supports for defending user space from

00:01:23,340 --> 00:01:27,900
user space but there hadn't been as much

00:01:26,250 --> 00:01:29,630
focus in the upstream kernel on

00:01:27,900 --> 00:01:32,759
protecting the kernel from user space

00:01:29,630 --> 00:01:36,180
and this is a pretty wide project we've

00:01:32,759 --> 00:01:37,640
got about 12 organizations with maybe 10

00:01:36,180 --> 00:01:41,610
individuals working on a bunch of stuff

00:01:37,640 --> 00:01:44,040
this is an upstream project it's not a

00:01:41,610 --> 00:01:45,750
it's not a fork or anything so it sort

00:01:44,040 --> 00:01:48,780
of follows the upstream development

00:01:45,750 --> 00:01:53,220
models and is slow and steady is way I

00:01:48,780 --> 00:01:55,259
like to think about it so this brings us

00:01:53,220 --> 00:02:00,049
to one of the main problems we've had is

00:01:55,259 --> 00:02:03,270
dealing with C gets treated mostly like

00:02:00,049 --> 00:02:06,270
machine code it's trying to be an

00:02:03,270 --> 00:02:07,920
abstract adverse of this the kernel does

00:02:06,270 --> 00:02:11,410
this because it's trying to be as fast

00:02:07,920 --> 00:02:13,360
and as small as possible

00:02:11,410 --> 00:02:16,510
and there's a lot of things that the

00:02:13,360 --> 00:02:18,430
colonel does that there is no capi for

00:02:16,510 --> 00:02:20,110
you know setting up page tables

00:02:18,430 --> 00:02:22,060
switching the 64-bit mode those are

00:02:20,110 --> 00:02:24,360
machine specific issues they're not

00:02:22,060 --> 00:02:28,690
about the C language at a higher level

00:02:24,360 --> 00:02:30,100
so that's why you know that's as close

00:02:28,690 --> 00:02:33,640
as we can get to machine code without

00:02:30,100 --> 00:02:35,950
all the pain there but this comes with

00:02:33,640 --> 00:02:39,100
some really fun things with the language

00:02:35,950 --> 00:02:41,740
itself a lot of undefined undefined

00:02:39,100 --> 00:02:44,650
behaviors in the C language which comes

00:02:41,740 --> 00:02:47,400
sort of from its history and there's

00:02:44,650 --> 00:02:51,310
some problems associated with having a

00:02:47,400 --> 00:02:54,130
weak standard library that have old

00:02:51,310 --> 00:02:55,690
problems so some quick examples that

00:02:54,130 --> 00:02:57,730
I'll get into more detail in a bit are

00:02:55,690 --> 00:03:00,790
you know the the idea of an

00:02:57,730 --> 00:03:03,100
uninitialized variable from the C

00:03:00,790 --> 00:03:05,260
language perspective we just say we

00:03:03,100 --> 00:03:08,410
don't know what's happening it's fine

00:03:05,260 --> 00:03:10,660
we'll throw a warning maybe but on an

00:03:08,410 --> 00:03:12,490
actual machine code that obviously does

00:03:10,660 --> 00:03:17,560
have a value it's whatever was in memory

00:03:12,490 --> 00:03:20,230
before and then in C we start to forget

00:03:17,560 --> 00:03:22,600
that it's supposed to be a language and

00:03:20,230 --> 00:03:25,150
we think about it as machine code again

00:03:22,600 --> 00:03:27,459
and we can just call function pointers

00:03:25,150 --> 00:03:30,430
without any regard to what the actual

00:03:27,459 --> 00:03:31,959
type of the function is because when it

00:03:30,430 --> 00:03:33,880
boils down to it you're running the

00:03:31,959 --> 00:03:35,170
machine code the machine code says well

00:03:33,880 --> 00:03:37,120
we're just jumping to a location in

00:03:35,170 --> 00:03:38,950
memory and running but that's not

00:03:37,120 --> 00:03:41,800
actually what you were trying to say

00:03:38,950 --> 00:03:44,760
with the C language so there there isn't

00:03:41,800 --> 00:03:49,510
as tight a binding between those things

00:03:44,760 --> 00:03:51,370
and then you also get a you know things

00:03:49,510 --> 00:03:54,190
out of the API like mem copy where you

00:03:51,370 --> 00:03:57,550
say well I have an address and I'm just

00:03:54,190 --> 00:03:59,170
gonna copy as much as I want to it but

00:03:57,550 --> 00:04:01,600
that doesn't really help anyone using

00:03:59,170 --> 00:04:03,280
that library and normally you see people

00:04:01,600 --> 00:04:06,250
who are trying to build up a series of

00:04:03,280 --> 00:04:07,510
copies you know they'll have a size and

00:04:06,250 --> 00:04:08,770
they're tracking how much size they've

00:04:07,510 --> 00:04:10,030
copied but they're not really paying

00:04:08,770 --> 00:04:13,690
attention to how much is left in the

00:04:10,030 --> 00:04:17,020
destination so why don't we have better

00:04:13,690 --> 00:04:19,090
api's in that regard of course this is

00:04:17,020 --> 00:04:23,050
an tiny fraction of all the other

00:04:19,090 --> 00:04:26,349
undefined behaviors in C there was a

00:04:23,050 --> 00:04:27,940
a great blog post recently on this with

00:04:26,349 --> 00:04:30,280
undefined behavior anything is possible

00:04:27,940 --> 00:04:33,789
and I bought the shirt because you have

00:04:30,280 --> 00:04:36,669
to have the shirt but this is a huge

00:04:33,789 --> 00:04:38,169
topic and I'm trying to sort of focus in

00:04:36,669 --> 00:04:40,930
on specific areas where we can try to

00:04:38,169 --> 00:04:42,669
improve the kernel itself or at least

00:04:40,930 --> 00:04:46,030
deal with the problems that have been

00:04:42,669 --> 00:04:49,389
created so one of those is

00:04:46,030 --> 00:04:51,639
variable-length arrays when you define a

00:04:49,389 --> 00:04:54,129
local variable it ends up on the stack

00:04:51,639 --> 00:04:57,069
and in C you can just sort of say well I

00:04:54,129 --> 00:04:59,949
want the size of this to be however

00:04:57,069 --> 00:05:02,949
large based on an input variable for

00:04:59,949 --> 00:05:04,599
from from the function and this creates

00:05:02,949 --> 00:05:06,759
problems because the stack is a fixed

00:05:04,599 --> 00:05:09,129
size and you can have a linear overflow

00:05:06,759 --> 00:05:10,810
that just runs right past the end of the

00:05:09,129 --> 00:05:13,509
stack and writes over things next to it

00:05:10,810 --> 00:05:15,849
but this is a valid stack frame so

00:05:13,509 --> 00:05:19,539
things like the stack protection the

00:05:15,849 --> 00:05:21,960
stack canary the stack cookie is

00:05:19,539 --> 00:05:24,969
actually not going to stop this because

00:05:21,960 --> 00:05:26,949
see when mapping this down into assembly

00:05:24,969 --> 00:05:29,529
basically says oh this is fine it's just

00:05:26,949 --> 00:05:32,169
a huge stack but of course we've gone

00:05:29,529 --> 00:05:35,529
way past it and then there are cases

00:05:32,169 --> 00:05:37,120
where even if you had a guard page which

00:05:35,529 --> 00:05:39,370
is now possible you could potentially

00:05:37,120 --> 00:05:43,180
still just jump past the guard guard

00:05:39,370 --> 00:05:45,759
page and create problems as well and

00:05:43,180 --> 00:05:47,229
again as far as the C language was

00:05:45,759 --> 00:05:50,050
concerned it was perfectly happy with

00:05:47,229 --> 00:05:53,529
this the nice thing is this is easy to

00:05:50,050 --> 00:05:57,669
find with - W turn on the VLA warning -

00:05:53,529 --> 00:05:58,900
w VLA so from a security perspective the

00:05:57,669 --> 00:06:00,969
main thing I'm looking at is that

00:05:58,900 --> 00:06:03,669
they're they're bad but it turns out

00:06:00,969 --> 00:06:08,199
they are also slow when we went to

00:06:03,669 --> 00:06:11,500
remove these one of the driver authors

00:06:08,199 --> 00:06:13,779
actually did a did a micro benchmark of

00:06:11,500 --> 00:06:15,699
the code because it was I think a

00:06:13,779 --> 00:06:16,750
checksum or something code where he

00:06:15,699 --> 00:06:18,639
could actually do that and he had all

00:06:16,750 --> 00:06:21,849
the instrumentation and he saw that a

00:06:18,639 --> 00:06:24,639
fixed size stack array actually gave him

00:06:21,849 --> 00:06:26,409
a 13% speed-up it's just like great I

00:06:24,639 --> 00:06:29,349
can now justify the security improvement

00:06:26,409 --> 00:06:33,610
with improved speed but I had to know

00:06:29,349 --> 00:06:34,770
why why is it so so bad so if you can

00:06:33,610 --> 00:06:36,350
read this

00:06:34,770 --> 00:06:38,540
the

00:06:36,350 --> 00:06:40,760
having a fixed size array generates this

00:06:38,540 --> 00:06:43,190
tiny chunk of assembly and having a

00:06:40,760 --> 00:06:45,380
variable sized array did all of that I

00:06:43,190 --> 00:06:48,470
didn't I haven't bothered to read all of

00:06:45,380 --> 00:06:50,840
that but it seems impossibly bizarre

00:06:48,470 --> 00:06:56,840
that it's that bad but apparently it is

00:06:50,840 --> 00:07:00,620
so just don't don't use relays another

00:06:56,840 --> 00:07:04,220
another case is the switch fall through

00:07:00,620 --> 00:07:06,470
so C specifies break to stop a switch

00:07:04,220 --> 00:07:08,690
case but there isn't anything to say

00:07:06,470 --> 00:07:11,120
please move on to the next one it is

00:07:08,690 --> 00:07:12,920
simply the absence of a statement that

00:07:11,120 --> 00:07:14,660
says move on to the other one but an

00:07:12,920 --> 00:07:16,870
absence of a statement could also mean

00:07:14,660 --> 00:07:20,450
you forgot to put a break

00:07:16,870 --> 00:07:22,940
so this weakness in C actually has its

00:07:20,450 --> 00:07:26,120
own common weakness enumeration item the

00:07:22,940 --> 00:07:29,840
omitted break statement and switch so

00:07:26,120 --> 00:07:31,280
you know is this actually a bug we don't

00:07:29,840 --> 00:07:35,990
know we have to look at every single

00:07:31,280 --> 00:07:37,850
case so static analyzers have had this

00:07:35,990 --> 00:07:40,580
problem for a while so they flag them

00:07:37,850 --> 00:07:43,610
and to white list cases where you do

00:07:40,580 --> 00:07:45,320
want a fall through actually with static

00:07:43,610 --> 00:07:49,130
analyzers they start adding a comment

00:07:45,320 --> 00:07:51,230
that said fall through so the compiler

00:07:49,130 --> 00:07:54,760
is following the the static analyzers

00:07:51,230 --> 00:07:59,060
have added parsing of a comment as a

00:07:54,760 --> 00:08:02,810
statement to indicate I do want to fall

00:07:59,060 --> 00:08:05,090
through here but that's sort of where we

00:08:02,810 --> 00:08:07,070
are but adding this to your compiler now

00:08:05,090 --> 00:08:09,230
you can say I want implicit you know

00:08:07,070 --> 00:08:12,050
warn on implicit fall through and if you

00:08:09,230 --> 00:08:14,240
don't find the comment statement it will

00:08:12,050 --> 00:08:16,880
yell at you so we've been going through

00:08:14,240 --> 00:08:18,890
the kernel adding these looking at every

00:08:16,880 --> 00:08:21,350
every place where it's missing and

00:08:18,890 --> 00:08:25,070
trying to decide was this an accident

00:08:21,350 --> 00:08:34,390
and we've had a lot of bugs found this

00:08:25,070 --> 00:08:37,219
way so another one is back to stack is

00:08:34,390 --> 00:08:42,530
you're getting rid of the uninitialized

00:08:37,219 --> 00:08:44,540
variable case right now if you try to

00:08:42,530 --> 00:08:46,700
use with with most compilers if you try

00:08:44,540 --> 00:08:48,830
to use a variable that you've declared

00:08:46,700 --> 00:08:49,920
locally that you didn't initialize first

00:08:48,830 --> 00:08:52,130
you get a warning that's

00:08:49,920 --> 00:08:55,170
is trying to use uninitialized variable

00:08:52,130 --> 00:08:58,139
however this warning gets silenced if

00:08:55,170 --> 00:09:01,380
you pass a variable into a function by

00:08:58,139 --> 00:09:03,930
by reference and suddenly you have no

00:09:01,380 --> 00:09:05,459
idea the compiler just forgets like well

00:09:03,930 --> 00:09:07,230
I assume since you pass it into a

00:09:05,459 --> 00:09:09,899
function that now it's initialized you

00:09:07,230 --> 00:09:11,250
did it but of course there's no reason

00:09:09,899 --> 00:09:17,339
to believe that it actually got

00:09:11,250 --> 00:09:20,220
initialized so there are some plugins in

00:09:17,339 --> 00:09:24,810
the kernel for doing various versions of

00:09:20,220 --> 00:09:26,760
this one for force initializing any

00:09:24,810 --> 00:09:29,850
structure that has underscore underscore

00:09:26,760 --> 00:09:31,230
user pointers in it this was expanded to

00:09:29,850 --> 00:09:33,300
all things that are passed by reference

00:09:31,230 --> 00:09:35,910
and then there are still some leftover

00:09:33,300 --> 00:09:38,399
cases especially with structure padding

00:09:35,910 --> 00:09:41,760
where you still want to initialize them

00:09:38,399 --> 00:09:45,389
for sure and in some discussions we

00:09:41,760 --> 00:09:47,459
actually encountered leanness praising

00:09:45,389 --> 00:09:50,670
the idea of always initializing all the

00:09:47,459 --> 00:09:53,040
variables all the time so that's we're

00:09:50,670 --> 00:09:55,350
trying to work towards there was a patch

00:09:53,040 --> 00:09:57,570
for GCC to do this it's not upstream

00:09:55,350 --> 00:09:59,870
there's a patch and clang to do this it

00:09:57,570 --> 00:10:03,390
is also not upstream we're looking at

00:09:59,870 --> 00:10:06,510
building a function or a plug-in to

00:10:03,390 --> 00:10:09,600
perform them to do this as well but this

00:10:06,510 --> 00:10:11,970
sort of gets rid of the the C problem of

00:10:09,600 --> 00:10:14,399
well what's on what's in the memory it's

00:10:11,970 --> 00:10:16,860
like well we just declare everything is

00:10:14,399 --> 00:10:19,019
zero initialized no matter what you can

00:10:16,860 --> 00:10:21,720
just depend on that as a feature of the

00:10:19,019 --> 00:10:24,510
new Linux kernel version of the C

00:10:21,720 --> 00:10:28,050
language and that makes things more

00:10:24,510 --> 00:10:29,370
smore easy to think about one

00:10:28,050 --> 00:10:32,910
interesting side effect that I thought

00:10:29,370 --> 00:10:35,399
was adorable as part of the moving from

00:10:32,910 --> 00:10:37,709
C to machine language is you got this

00:10:35,399 --> 00:10:40,440
this error by once you force initialize

00:10:37,709 --> 00:10:43,140
your variables I got a warning out of

00:10:40,440 --> 00:10:45,990
GCC that said well you have unrunnable

00:10:43,140 --> 00:10:50,069
code and I went looking and it was

00:10:45,990 --> 00:10:53,160
because you had initializers before the

00:10:50,069 --> 00:10:55,170
first case statement in a switch which

00:10:53,160 --> 00:10:57,870
never gets executed because nothing will

00:10:55,170 --> 00:11:01,350
actually ever go there because variable

00:10:57,870 --> 00:11:02,940
declaration which in in assembly is

00:11:01,350 --> 00:11:05,430
making room for it on the stack

00:11:02,940 --> 00:11:07,530
and initialization requires running

00:11:05,430 --> 00:11:09,690
something to write stuff to that area of

00:11:07,530 --> 00:11:12,270
the stack so by forcing the

00:11:09,690 --> 00:11:13,470
initialization in the area of the switch

00:11:12,270 --> 00:11:16,710
statement that I didn't even know you

00:11:13,470 --> 00:11:18,030
could put declarations it would never

00:11:16,710 --> 00:11:22,020
run it and it would never be initialized

00:11:18,030 --> 00:11:25,170
so I went through and lifted out all of

00:11:22,020 --> 00:11:28,020
these places and where this occurred

00:11:25,170 --> 00:11:30,030
there weren't a lot but this was a yet

00:11:28,020 --> 00:11:36,420
another surprising side effect of see I

00:11:30,030 --> 00:11:40,590
just didn't know another case is dealing

00:11:36,420 --> 00:11:42,390
with integer overflows GCC has support

00:11:40,590 --> 00:11:45,030
for checking for signed integer

00:11:42,390 --> 00:11:47,070
overflows this is one of the many things

00:11:45,030 --> 00:11:51,750
that gets unable to with config you be

00:11:47,070 --> 00:11:54,660
seen right now so the good news is it's

00:11:51,750 --> 00:11:56,900
very very fast because it's just

00:11:54,660 --> 00:12:00,360
checking for an existing hardware flag

00:11:56,900 --> 00:12:01,980
and if you want to and I'm like I

00:12:00,360 --> 00:12:03,870
couldn't actually measure the difference

00:12:01,980 --> 00:12:04,740
I need to do better micro benchmarks to

00:12:03,870 --> 00:12:06,720
really figure out how many cycles

00:12:04,740 --> 00:12:09,810
difference it is but it's I think gonna

00:12:06,720 --> 00:12:12,390
be very very small and if you just want

00:12:09,810 --> 00:12:14,760
the kernel to abort immediately it grows

00:12:12,390 --> 00:12:17,160
the kernel image by 0.1 percent which is

00:12:14,760 --> 00:12:19,410
good but the downside is if you want

00:12:17,160 --> 00:12:21,870
warnings about this it grows the kernel

00:12:19,410 --> 00:12:24,230
image by 6 percent because there are

00:12:21,870 --> 00:12:26,400
thousands and thousands of integer

00:12:24,230 --> 00:12:29,370
calculations being made as you might

00:12:26,400 --> 00:12:31,680
imagine in the meantime there are we can

00:12:29,370 --> 00:12:34,710
do explicit single operation

00:12:31,680 --> 00:12:37,290
tests where we say I want to know for

00:12:34,710 --> 00:12:39,840
sure in this code flow whether or not I

00:12:37,290 --> 00:12:43,590
overflowed so we now have a set of

00:12:39,840 --> 00:12:48,990
arithmetic overflow detection helpers in

00:12:43,590 --> 00:12:51,780
the kernel clang can do unsigned an

00:12:48,990 --> 00:12:54,330
integer overflow detection specifically

00:12:51,780 --> 00:12:56,010
signed overflow is considered an

00:12:54,330 --> 00:12:58,560
undefined behavior for a variety of

00:12:56,010 --> 00:13:00,960
reasons but unsigned is considered well

00:12:58,560 --> 00:13:03,750
defined except that it is usually

00:13:00,960 --> 00:13:05,010
unexpected there are however a lot of

00:13:03,750 --> 00:13:07,589
cases in the kernel where we do

00:13:05,010 --> 00:13:10,950
intentionally perform on the sign to

00:13:07,589 --> 00:13:13,020
overflow so we'd have to go through and

00:13:10,950 --> 00:13:14,850
mark that and deal with it but this is

00:13:13,020 --> 00:13:16,380
one difference in implementations

00:13:14,850 --> 00:13:19,320
between GCC and clang and for do

00:13:16,380 --> 00:13:21,990
clang gives you quite a variety of ways

00:13:19,320 --> 00:13:24,060
to handle it sort of showed them in this

00:13:21,990 --> 00:13:25,890
slide here where you can have it abort

00:13:24,060 --> 00:13:27,990
you can have it warn but continue you

00:13:25,890 --> 00:13:30,300
can have it warn and give up you can do

00:13:27,990 --> 00:13:35,700
a bunch of different things so plumbing

00:13:30,300 --> 00:13:39,110
that into the kernel would be nice and

00:13:35,700 --> 00:13:42,590
then generally bounds checking this is

00:13:39,110 --> 00:13:44,490
this remains a big area of

00:13:42,590 --> 00:13:48,120
vulnerabilities in the kernel is just

00:13:44,490 --> 00:13:49,800
having string copy or mem copy wander

00:13:48,120 --> 00:13:51,300
past the end of an allocation and just

00:13:49,800 --> 00:13:54,180
keep writing into whatever memory is

00:13:51,300 --> 00:13:57,600
next in the kernel we have the the

00:13:54,180 --> 00:13:59,820
hardened user copy which checks the the

00:13:57,600 --> 00:14:02,610
places where we're explicitly copying to

00:13:59,820 --> 00:14:04,920
and from user space in the copy to from

00:14:02,610 --> 00:14:07,440
user checking and this is under 1%

00:14:04,920 --> 00:14:10,290
performance hit I tried to extend this

00:14:07,440 --> 00:14:13,290
to the string family and the mem family

00:14:10,290 --> 00:14:15,630
functions and they're about a two

00:14:13,290 --> 00:14:17,810
percent performance hit each I still

00:14:15,630 --> 00:14:22,110
need to look at this a little bit more

00:14:17,810 --> 00:14:24,330
so you know pre meltdown this was an

00:14:22,110 --> 00:14:27,630
totally unacceptable performance hit for

00:14:24,330 --> 00:14:34,050
security post meltdown it's under five

00:14:27,630 --> 00:14:37,800
percent so maybe I have a chance to land

00:14:34,050 --> 00:14:40,940
this stuff to we'll see but it would be

00:14:37,800 --> 00:14:43,050
nice because we there we keep getting

00:14:40,940 --> 00:14:45,540
vulnerabilities where the mem copy is

00:14:43,050 --> 00:14:47,490
just wrong and we could have easily

00:14:45,540 --> 00:14:49,410
detected it we got everything we knew we

00:14:47,490 --> 00:14:52,550
know how big the allocation is we know

00:14:49,410 --> 00:14:54,840
how big everything around it is anyway

00:14:52,550 --> 00:14:58,410
and this moves on des can we just get

00:14:54,840 --> 00:15:00,570
better api's and get rid of old bad

00:14:58,410 --> 00:15:03,720
api's that came came from the standard c

00:15:00,570 --> 00:15:06,300
library and this is this tends to be

00:15:03,720 --> 00:15:08,160
also quite a political problem because

00:15:06,300 --> 00:15:09,360
in trying to bring developers into the

00:15:08,160 --> 00:15:11,930
Linux kernel community don't want to

00:15:09,360 --> 00:15:14,580
have to teach them an entirely new C API

00:15:11,930 --> 00:15:17,100
however we're already doing that because

00:15:14,580 --> 00:15:19,860
we said well string string copy was no

00:15:17,100 --> 00:15:21,090
good let's use string n copy except that

00:15:19,860 --> 00:15:23,940
string n copy doesn't always null

00:15:21,090 --> 00:15:26,040
terminate and if it's too long and if

00:15:23,940 --> 00:15:28,050
it's too short it just null pads the

00:15:26,040 --> 00:15:29,760
entire allocation that you did specify

00:15:28,050 --> 00:15:30,180
so that's not good so we made string L

00:15:29,760 --> 00:15:32,880
cop

00:15:30,180 --> 00:15:35,700
but that reads the source string beyond

00:15:32,880 --> 00:15:39,450
the max length also so how about string

00:15:35,700 --> 00:15:41,820
s copy seems okay so far so maybe we can

00:15:39,450 --> 00:15:43,790
improve my macapá to that that would be

00:15:41,820 --> 00:15:47,060
great

00:15:43,790 --> 00:15:51,030
so yes the the point was this is slow

00:15:47,060 --> 00:15:53,430
but there is hopefully some some future

00:15:51,030 --> 00:15:56,730
world where we're gonna have hardware

00:15:53,430 --> 00:16:02,580
supported memory allocation tagging in

00:15:56,730 --> 00:16:05,070
hardware so the example here is that

00:16:02,580 --> 00:16:09,000
your your allocator in this case k

00:16:05,070 --> 00:16:11,040
malloc you say i 128 bytes and the

00:16:09,000 --> 00:16:15,090
allocator says okay this blue area is

00:16:11,040 --> 00:16:18,540
128 bytes i've given a tag 5 that tag

00:16:15,090 --> 00:16:20,600
lives in the high byte of the pointer

00:16:18,540 --> 00:16:23,460
value that comes back from the allocator

00:16:20,600 --> 00:16:26,970
and so you can say great I'm gonna write

00:16:23,460 --> 00:16:28,380
at an offset from that pointer and the

00:16:26,970 --> 00:16:30,390
hardware is looking at that and says ok

00:16:28,380 --> 00:16:32,910
you have the right tag for your offset

00:16:30,390 --> 00:16:35,160
it's in within the range 120 28 bytes

00:16:32,910 --> 00:16:36,810
we're good and then later on you say

00:16:35,160 --> 00:16:39,180
well I want an offset slightly beyond

00:16:36,810 --> 00:16:41,970
that and says well the memory region

00:16:39,180 --> 00:16:44,490
passed that has a different tag you're

00:16:41,970 --> 00:16:46,260
gonna fail because you're outside of

00:16:44,490 --> 00:16:49,410
what you were expecting that pointer to

00:16:46,260 --> 00:16:53,040
actually point to so stuff like this

00:16:49,410 --> 00:16:54,650
exists already in spark with their with

00:16:53,040 --> 00:16:58,880
their application data integrity

00:16:54,650 --> 00:17:01,560
extension in arm this is coming and

00:16:58,880 --> 00:17:09,540
supposedly we might have this on Intel

00:17:01,560 --> 00:17:13,890
at some point moves on to CF I control

00:17:09,540 --> 00:17:16,410
flow integrity so with with decent

00:17:13,890 --> 00:17:19,580
control over having memory not be

00:17:16,410 --> 00:17:22,200
writable and executable attackers have

00:17:19,580 --> 00:17:25,440
moved on to trying to use the existing

00:17:22,200 --> 00:17:28,590
code that's in the kernel to take

00:17:25,440 --> 00:17:30,900
advantage of indirect calls where you

00:17:28,590 --> 00:17:33,270
have saved a function pointer somewhere

00:17:30,900 --> 00:17:36,120
and you eventually turn around and

00:17:33,270 --> 00:17:37,560
actually run it in this case it's you

00:17:36,120 --> 00:17:39,630
know for the forward edge calling out

00:17:37,560 --> 00:17:41,730
you've got a function pointer saved in

00:17:39,630 --> 00:17:42,779
the heap you go fetch it and you just

00:17:41,730 --> 00:17:44,580
call it

00:17:42,779 --> 00:17:47,730
and then on return you return from

00:17:44,580 --> 00:17:50,009
somewhere to your to the to where you

00:17:47,730 --> 00:17:52,049
came from and that's effectively a an

00:17:50,009 --> 00:17:55,110
indirect call off the what was stored on

00:17:52,049 --> 00:17:58,440
the stack but this is all implementation

00:17:55,110 --> 00:17:59,820
details in see you specified I wanted to

00:17:58,440 --> 00:18:04,679
make this function call and then come

00:17:59,820 --> 00:18:07,169
back from it and without CFI it's just

00:18:04,679 --> 00:18:09,600
kind of like well I can overload I can

00:18:07,169 --> 00:18:11,539
change what what I'm calling I can just

00:18:09,600 --> 00:18:15,470
tell see don't pay no attention to this

00:18:11,539 --> 00:18:19,620
and we'll go ahead and call you know the

00:18:15,470 --> 00:18:20,970
the call one versus call two which have

00:18:19,620 --> 00:18:24,539
completely different function prototypes

00:18:20,970 --> 00:18:27,480
or violating what we'd asked this

00:18:24,539 --> 00:18:30,240
function to be but again wind map down

00:18:27,480 --> 00:18:32,429
into machine code we're like sure it's a

00:18:30,240 --> 00:18:33,870
function pointer whatever just go there

00:18:32,429 --> 00:18:38,460
and run with whatever happens to be

00:18:33,870 --> 00:18:42,899
there and we don't care so doing forward

00:18:38,460 --> 00:18:44,460
edge checking like with clangs CFI this

00:18:42,899 --> 00:18:46,139
will actually blow up because it tries

00:18:44,460 --> 00:18:48,240
to execute and it says but I was

00:18:46,139 --> 00:18:50,279
expecting to call this type of function

00:18:48,240 --> 00:18:52,889
but I arrived at a different type of

00:18:50,279 --> 00:18:56,519
function I'm gonna freak out

00:18:52,889 --> 00:19:01,289
now this isn't perfect it's based on the

00:18:56,519 --> 00:19:03,320
function prototype pattern so right now

00:19:01,289 --> 00:19:06,029
in the kernel there's still plenty of

00:19:03,320 --> 00:19:08,100
functions that return on the signed long

00:19:06,029 --> 00:19:10,649
and take as one argument and unsigned

00:19:08,100 --> 00:19:13,799
long so that's not great but for a lot

00:19:10,649 --> 00:19:16,649
of other routines it does narrow the

00:19:13,799 --> 00:19:19,860
window of an arrow the attack surface

00:19:16,649 --> 00:19:21,929
for indirect calls of course this is

00:19:19,860 --> 00:19:24,570
forward edge for backward edge and

00:19:21,929 --> 00:19:26,909
return there's things like like

00:19:24,570 --> 00:19:29,870
splitting up stacks where you say okay

00:19:26,909 --> 00:19:32,429
we're going to push all of our weird

00:19:29,870 --> 00:19:34,559
variables all of our weird locals

00:19:32,429 --> 00:19:36,389
buffers and by reference variables into

00:19:34,559 --> 00:19:37,740
this unsafe area because we don't know

00:19:36,389 --> 00:19:40,529
what's gonna happen the bad stuff might

00:19:37,740 --> 00:19:43,049
happen but things we can prove are safe

00:19:40,529 --> 00:19:44,759
to use register spills and safe accesses

00:19:43,049 --> 00:19:47,519
and the return address will split into a

00:19:44,759 --> 00:19:51,119
different stack this is one approach to

00:19:47,519 --> 00:19:52,649
solving that because it makes it so that

00:19:51,119 --> 00:19:55,500
if the attacker doesn't know where the

00:19:52,649 --> 00:19:57,659
safe stack is it's harder to deal with

00:19:55,500 --> 00:20:00,720
similar to this but with less logic is

00:19:57,659 --> 00:20:03,210
to do a shadow call stack which is only

00:20:00,720 --> 00:20:06,210
thing that you put on the other stack is

00:20:03,210 --> 00:20:08,250
the return address and it's harder to

00:20:06,210 --> 00:20:10,139
get at this one because you can keep a

00:20:08,250 --> 00:20:12,629
dedicated register for this entire stack

00:20:10,139 --> 00:20:15,149
sort of how there's you know the regular

00:20:12,629 --> 00:20:17,279
stack register for the unsafe and then

00:20:15,149 --> 00:20:20,190
the another separate register

00:20:17,279 --> 00:20:24,799
effectively for the call stack and this

00:20:20,190 --> 00:20:24,799
works in clang right now

00:20:25,879 --> 00:20:34,710
so there is hardware support for dealing

00:20:28,620 --> 00:20:37,070
with backward edge CFI intel CET deals

00:20:34,710 --> 00:20:39,929
with one aspect of this which is you're

00:20:37,070 --> 00:20:41,970
doing it in software leaves that second

00:20:39,929 --> 00:20:43,440
stack writable which means it's still if

00:20:41,970 --> 00:20:46,200
it can be found by an attacker written

00:20:43,440 --> 00:20:49,669
to they've taken over your return path

00:20:46,200 --> 00:20:52,470
with CET this is effectively a read-only

00:20:49,669 --> 00:20:54,840
area of memory that is writable only

00:20:52,470 --> 00:20:57,570
during the call and return instructions

00:20:54,840 --> 00:21:00,929
that you know do this implicit read and

00:20:57,570 --> 00:21:03,330
write to that area and then a different

00:21:00,929 --> 00:21:07,649
version is the pointer authentication

00:21:03,330 --> 00:21:13,080
and an arm v 8.3 a that adds new

00:21:07,649 --> 00:21:15,389
instructions to effectively add sort of

00:21:13,080 --> 00:21:17,460
an encrypted tag to what you're writing

00:21:15,389 --> 00:21:19,940
out to the to the stack and then when

00:21:17,460 --> 00:21:22,769
you pull it back you can Rivera fie it

00:21:19,940 --> 00:21:24,090
and that the difference on that is

00:21:22,769 --> 00:21:26,669
pretty simple it says you enter a

00:21:24,090 --> 00:21:28,080
function you sign where you're coming

00:21:26,669 --> 00:21:30,240
from and then when you're about to leave

00:21:28,080 --> 00:21:39,750
you double check that what you have is

00:21:30,240 --> 00:21:43,019
what you wanted so where are we now with

00:21:39,750 --> 00:21:47,279
V la's it's been about four releases of

00:21:43,019 --> 00:21:49,049
the kernel we went through a little bit

00:21:47,279 --> 00:21:51,779
over a hundred of these which were each

00:21:49,049 --> 00:21:53,100
a little bit different so it's taken

00:21:51,779 --> 00:21:54,899
quite a bit of time to get rid of these

00:21:53,100 --> 00:21:57,450
but we're down to only a handful and

00:21:54,899 --> 00:22:01,950
crypto remaining I'm hoping that that

00:21:57,450 --> 00:22:06,090
will be completely finished by the 4.20

00:22:01,950 --> 00:22:09,240
or whatever is next after 4.19 the

00:22:06,090 --> 00:22:11,400
explicit switch case fall through

00:22:09,240 --> 00:22:13,410
I know that Gustavo had been sending

00:22:11,400 --> 00:22:15,990
patches slowly over quite a while and I

00:22:13,410 --> 00:22:18,620
thought well how many has he sent I saw

00:22:15,990 --> 00:22:21,270
that he had sent 745 patches and like

00:22:18,620 --> 00:22:26,760
well I wonder how many we had started

00:22:21,270 --> 00:22:28,710
with so um we have only I'm sorry he

00:22:26,760 --> 00:22:31,440
hadn't said he'd sent more than 700 and

00:22:28,710 --> 00:22:32,730
he's like over a thousand so now we're

00:22:31,440 --> 00:22:34,620
only down to about 700 of these

00:22:32,730 --> 00:22:37,380
remaining but again each one of these

00:22:34,620 --> 00:22:38,910
you have to look at it and decide what

00:22:37,380 --> 00:22:40,920
did the author mean is there a comment

00:22:38,910 --> 00:22:44,310
here to describe whether or not the fall

00:22:40,920 --> 00:22:45,810
through was intentional or not but once

00:22:44,310 --> 00:22:47,900
we get through those that entire class

00:22:45,810 --> 00:22:50,640
can go away as well

00:22:47,900 --> 00:22:54,330
the always initialized automatic

00:22:50,640 --> 00:22:56,640
variables we have a lot of this is

00:22:54,330 --> 00:22:59,010
available through the plugins but we

00:22:56,640 --> 00:23:01,230
don't have complete coverage it's not

00:22:59,010 --> 00:23:02,310
quite the way we think we want it in the

00:23:01,230 --> 00:23:05,040
kernel yet

00:23:02,310 --> 00:23:07,770
we'll see it would be nice to get more

00:23:05,040 --> 00:23:09,540
complete support from the compilers on

00:23:07,770 --> 00:23:13,350
this so up streaming those existing

00:23:09,540 --> 00:23:16,380
patches would be great on overflow

00:23:13,350 --> 00:23:18,890
detection it would be nice to have GCC

00:23:16,380 --> 00:23:22,590
grow the unsigned overflow protection

00:23:18,890 --> 00:23:25,590
but this does work right now we just

00:23:22,590 --> 00:23:28,890
need to specifically tear it out of

00:23:25,590 --> 00:23:32,760
config ub san and we should have this it

00:23:28,890 --> 00:23:34,320
would be nice balance checking mainly

00:23:32,760 --> 00:23:38,760
it's crying about performance and

00:23:34,320 --> 00:23:42,420
waiting for hardware that's ok and see

00:23:38,760 --> 00:23:45,900
if I this actually works right now in

00:23:42,420 --> 00:23:51,660
Android there's a talk later on this

00:23:45,900 --> 00:23:58,080
it's pretty impressive and again waiting

00:23:51,660 --> 00:23:59,490
for hardware so sort of how do we get

00:23:58,080 --> 00:24:00,930
there you know those that's where we are

00:23:59,490 --> 00:24:03,450
how do we get there is like trying to

00:24:00,930 --> 00:24:05,580
get people involved we have a lot of

00:24:03,450 --> 00:24:07,140
cultural challenges and getting stings

00:24:05,580 --> 00:24:10,170
into upstream there's a lot of

00:24:07,140 --> 00:24:11,910
conservatism in not wanting to make

00:24:10,170 --> 00:24:14,730
changes to code and accepting

00:24:11,910 --> 00:24:16,740
responsibility of the overhead and sort

00:24:14,730 --> 00:24:18,060
of sacrificing ones time to make that

00:24:16,740 --> 00:24:20,310
happen

00:24:18,060 --> 00:24:21,970
obviously the technical piece there is a

00:24:20,310 --> 00:24:25,300
lot of complexity

00:24:21,970 --> 00:24:27,370
here but um we can solve that and of

00:24:25,300 --> 00:24:30,970
course just getting people to help with

00:24:27,370 --> 00:24:32,260
doing it reviewing it testing it and in

00:24:30,970 --> 00:24:33,610
cases where you're not running the

00:24:32,260 --> 00:24:37,180
latest kernel actually back porting it

00:24:33,610 --> 00:24:40,480
to your releases since traditionally the

00:24:37,180 --> 00:24:43,570
LTS kernels only have bug fixes they

00:24:40,480 --> 00:24:46,060
haven't normally back ported features

00:24:43,570 --> 00:24:48,910
and the reason for that as you could see

00:24:46,060 --> 00:24:51,520
with a lot of the patches you know the

00:24:48,910 --> 00:24:55,180
hundreds of patches to fix VLA is and

00:24:51,520 --> 00:24:57,220
and stack switch statements and other

00:24:55,180 --> 00:24:59,170
things it's actually a huge number of

00:24:57,220 --> 00:25:04,390
patches so back porting that is somewhat

00:24:59,170 --> 00:25:07,120
prohibitive so that's it you can reach

00:25:04,390 --> 00:25:09,970
me at these places there's the link to

00:25:07,120 --> 00:25:15,340
the sub protection project and these

00:25:09,970 --> 00:25:18,970
slides again I got I caught us back up

00:25:15,340 --> 00:25:26,550
on time any questions or other things

00:25:18,970 --> 00:25:29,830
Casey yes oh here's a microphone for you

00:25:26,550 --> 00:25:32,320
I've been doing C programming since 1977

00:25:29,830 --> 00:25:35,170
and yes always know the comment was

00:25:32,320 --> 00:25:37,960
always no break uh-huh where did they

00:25:35,170 --> 00:25:41,470
come up with this fall through it was a

00:25:37,960 --> 00:25:43,300
static analyzers so why why that comment

00:25:41,470 --> 00:25:47,080
why not the the one that's been in use

00:25:43,300 --> 00:25:48,670
for 50 years flatters I probably because

00:25:47,080 --> 00:25:53,110
the static analyzer folks hadn't been

00:25:48,670 --> 00:25:56,290
writing C since 1977 well okay I guess

00:25:53,110 --> 00:26:00,490
it was yeah it was just a it was just I

00:25:56,290 --> 00:26:02,950
mean the reading the in the feature

00:26:00,490 --> 00:26:06,460
requests for here's the support for

00:26:02,950 --> 00:26:09,010
parsing a comment as a C statement there

00:26:06,460 --> 00:26:11,260
was great anger in the fact that the

00:26:09,010 --> 00:26:13,300
that the compiler has got painted into a

00:26:11,260 --> 00:26:14,380
corner because the static analyzers like

00:26:13,300 --> 00:26:16,300
well this is what we're doing this is

00:26:14,380 --> 00:26:18,270
we're checking here are all of the giant

00:26:16,300 --> 00:26:20,980
numbers of code bases that we've

00:26:18,270 --> 00:26:23,230
instrumented now with an you know we've

00:26:20,980 --> 00:26:25,090
actually updated all the all the code to

00:26:23,230 --> 00:26:27,190
say to have fall through as a comment

00:26:25,090 --> 00:26:29,710
the compiler people were just kind of

00:26:27,190 --> 00:26:34,110
like but we could give you a statements

00:26:29,710 --> 00:26:34,110
too late now it's a comment

00:26:34,340 --> 00:26:38,179
anything else back there

00:26:38,929 --> 00:26:43,220
you wanna microphone

00:26:48,340 --> 00:26:52,840
so once upon a time is a an effort made

00:26:51,100 --> 00:26:54,940
to try and enforce things with the

00:26:52,840 --> 00:26:57,550
string api's for them to be more secure

00:26:54,940 --> 00:26:59,170
say no more stir copy fq stern copy and

00:26:57,550 --> 00:27:01,060
it resulted in some what I would call

00:26:59,170 --> 00:27:02,350
stern copy anti-patterns

00:27:01,060 --> 00:27:04,900
where people were just doing things like

00:27:02,350 --> 00:27:07,300
calling sterling on fixed sized strings

00:27:04,900 --> 00:27:09,450
or other things like that so what's the

00:27:07,300 --> 00:27:12,970
plan to try and make sure we don't turn

00:27:09,450 --> 00:27:17,350
these supposedly more secure into api's

00:27:12,970 --> 00:27:19,780
into perhaps still insecure api's I I

00:27:17,350 --> 00:27:21,670
think it's mostly us designing it right

00:27:19,780 --> 00:27:23,440
and actually getting people who have

00:27:21,670 --> 00:27:25,030
strong opinions about this and looking

00:27:23,440 --> 00:27:28,480
at the past anti-pattern isn't saying

00:27:25,030 --> 00:27:31,390
what do we need to have like what is

00:27:28,480 --> 00:27:32,560
actually helpful API for the author that

00:27:31,390 --> 00:27:34,360
provides us the defensive

00:27:32,560 --> 00:27:36,580
characteristics we want without getting

00:27:34,360 --> 00:27:38,770
in their way and like in the past we've

00:27:36,580 --> 00:27:40,870
just kept going you know doing tiny

00:27:38,770 --> 00:27:45,810
band-aid fixes like well a string and

00:27:40,870 --> 00:27:48,990
copy we're good just ship it and I I

00:27:45,810 --> 00:27:51,880
think the other problem we've had is

00:27:48,990 --> 00:27:54,490
doing evolution of api's and Linux

00:27:51,880 --> 00:27:57,460
kernel we've had a long history of

00:27:54,490 --> 00:27:59,830
saying here is a new API I will use it

00:27:57,460 --> 00:28:02,940
in this one place and it's everyone

00:27:59,830 --> 00:28:07,120
else's problem to fix all the old api's

00:28:02,940 --> 00:28:09,420
and I have tried in some of the some of

00:28:07,120 --> 00:28:13,120
the conversions we've made to look at

00:28:09,420 --> 00:28:15,670
past api's and remove them so first you

00:28:13,120 --> 00:28:17,800
know move all old api's up to you know

00:28:15,670 --> 00:28:19,870
move an ancient api up to the old api

00:28:17,800 --> 00:28:22,150
and then move all of the old api is the

00:28:19,870 --> 00:28:24,310
bad api and then move the bad api to the

00:28:22,150 --> 00:28:26,980
good api in the process of wiping out

00:28:24,310 --> 00:28:28,540
the availability of all the others and i

00:28:26,980 --> 00:28:31,180
think that's part of the the cost

00:28:28,540 --> 00:28:33,340
associated with this is actually getting

00:28:31,180 --> 00:28:35,590
rid of the old API s and not allowing

00:28:33,340 --> 00:28:36,620
them to exist anywhere and get misused

00:28:35,590 --> 00:28:41,580
in the future

00:28:36,620 --> 00:28:41,580
[Laughter]

00:28:45,920 --> 00:28:52,140
just a further bit to Loras come on when

00:28:48,720 --> 00:28:53,910
we've found anti-patterns in the past

00:28:52,140 --> 00:28:55,530
we've added like coccynelle scripts and

00:28:53,910 --> 00:28:59,010
katsu check scripts do we perhaps need

00:28:55,530 --> 00:29:00,600
to proactively figure out we're adding

00:28:59,010 --> 00:29:03,960
this API here is a way people might

00:29:00,600 --> 00:29:05,580
misuse it at add checks for those kind

00:29:03,960 --> 00:29:09,000
of things in advance before we start

00:29:05,580 --> 00:29:10,950
seeing them that would be nice we have

00:29:09,000 --> 00:29:13,020
some sets of the coccynelle scripts

00:29:10,950 --> 00:29:14,970
already in the kernel but they are

00:29:13,020 --> 00:29:20,220
effectively disjoint from a regular

00:29:14,970 --> 00:29:22,560
compiled in in some in some places where

00:29:20,220 --> 00:29:25,200
the kernels get built you know for

00:29:22,560 --> 00:29:26,910
vendors they will actually do two staged

00:29:25,200 --> 00:29:29,790
compiles what they'll say first we're

00:29:26,910 --> 00:29:31,530
going to do the static checker compile

00:29:29,790 --> 00:29:35,430
which includes coccynelle and some other

00:29:31,530 --> 00:29:37,470
things and if that those tend to be so

00:29:35,430 --> 00:29:40,110
noisy that really is if that does not

00:29:37,470 --> 00:29:43,320
produce a difference in the output from

00:29:40,110 --> 00:29:45,420
before and after then continue and do

00:29:43,320 --> 00:29:46,560
the build for real but that's actually

00:29:45,420 --> 00:29:48,090
been something that's bothered me for a

00:29:46,560 --> 00:29:50,160
while is we don't include that in the

00:29:48,090 --> 00:29:51,570
common build so there's no there's no

00:29:50,160 --> 00:29:52,020
warning that something that bad has

00:29:51,570 --> 00:29:54,900
happened

00:29:52,020 --> 00:29:56,760
which is why I've sort of pushed to just

00:29:54,900 --> 00:29:58,380
eliminate the API from the kernel

00:29:56,760 --> 00:30:01,350
because if it's gone it won't even build

00:29:58,380 --> 00:30:03,720
but we're forced into some cases where

00:30:01,350 --> 00:30:05,310
we span multiple releases with api's we

00:30:03,720 --> 00:30:07,920
have to continue to support and then

00:30:05,310 --> 00:30:11,180
people get distracted by other things so

00:30:07,920 --> 00:30:14,690
it's just a matter of doing it as

00:30:11,180 --> 00:30:14,690
completely as we can

00:30:15,390 --> 00:30:17,420
Oh

00:30:24,159 --> 00:30:28,759
the question was is there any way we can

00:30:26,330 --> 00:30:31,610
mark api's as obsolete so we did have

00:30:28,759 --> 00:30:37,820
underscore underscore deprecated but

00:30:31,610 --> 00:30:40,610
leanness deprecated it so yeah well I

00:30:37,820 --> 00:30:42,110
mean Lina says argument was effectively

00:30:40,610 --> 00:30:44,720
the same which was if you're removing an

00:30:42,110 --> 00:30:49,100
API remove it don't make it someone

00:30:44,720 --> 00:30:53,779
else's problem which is agonizing right

00:30:49,100 --> 00:30:55,399
that's yeah I have done this and yeah so

00:30:53,779 --> 00:30:55,850
there isn't a particularly good solution

00:30:55,399 --> 00:30:58,899
here

00:30:55,850 --> 00:31:01,399
I don't know without having some form of

00:30:58,899 --> 00:31:04,190
developmental mandate where someone can

00:31:01,399 --> 00:31:06,409
say I am removing this API it is your

00:31:04,190 --> 00:31:13,490
problem to fix or your code gets left

00:31:06,409 --> 00:31:14,779
out I don't know like there isn't we

00:31:13,490 --> 00:31:16,039
could add things to check patch that's

00:31:14,779 --> 00:31:18,309
happened in the past I mean there's sort

00:31:16,039 --> 00:31:22,610
of a potpourri of various mechanisms

00:31:18,309 --> 00:31:24,500
that people have tried so yeah getting

00:31:22,610 --> 00:31:26,330
just killing the API appears to be best

00:31:24,500 --> 00:31:29,809
but it is extremely time consuming

00:31:26,330 --> 00:31:32,509
yeah and however I've kept this as a hey

00:31:29,809 --> 00:31:34,789
we'd like to get rid of an API this is a

00:31:32,509 --> 00:31:37,299
bit tedious but it's actually usually

00:31:34,789 --> 00:31:42,320
pretty mechanical and that works as

00:31:37,299 --> 00:31:44,509
decent like Colonel Newby types of stuff

00:31:42,320 --> 00:31:46,820
so if there's a list of here we'd like

00:31:44,509 --> 00:31:48,519
to get rid of this timer interface or

00:31:46,820 --> 00:31:50,659
this string interface things like that

00:31:48,519 --> 00:31:57,279
keeping that list in one place is

00:31:50,659 --> 00:31:57,279
another idea and now I'm over time

00:31:57,759 --> 00:32:01,149
anything else Oh

00:32:15,030 --> 00:32:21,510
so they're also mention of hardware

00:32:18,120 --> 00:32:23,820
support for bounce checking on x86 and I

00:32:21,510 --> 00:32:26,030
am pretty sure that there are already

00:32:23,820 --> 00:32:29,790
instructions for that that there is an

00:32:26,030 --> 00:32:33,000
instruction called bound I think in x86

00:32:29,790 --> 00:32:34,770
assembly so what's the problem with it

00:32:33,000 --> 00:32:36,810
because I've heard about it I've read

00:32:34,770 --> 00:32:40,350
about it but I'm pretty sure nobody's

00:32:36,810 --> 00:32:46,860
using it not even compilers minor saying

00:32:40,350 --> 00:32:48,150
is bound is separate I looked I came

00:32:46,860 --> 00:32:50,730
across that a while back but it doesn't

00:32:48,150 --> 00:32:55,200
provide the protections we want because

00:32:50,730 --> 00:32:57,690
even even if we have that it's it

00:32:55,200 --> 00:33:00,840
requires an explicit check you would say

00:32:57,690 --> 00:33:02,970
am i inbounds and then you'd do it but

00:33:00,840 --> 00:33:05,100
that still needs to that instruction

00:33:02,970 --> 00:33:07,800
still needs to understand what the

00:33:05,100 --> 00:33:09,960
bounds were and that information may be

00:33:07,800 --> 00:33:12,360
totally separate from from the execution

00:33:09,960 --> 00:33:13,020
path so having it having the support in

00:33:12,360 --> 00:33:15,150
the MMU

00:33:13,020 --> 00:33:16,860
where it's actually working like when

00:33:15,150 --> 00:33:18,540
it's actually trying to dereference

00:33:16,860 --> 00:33:21,990
pointers and do other things

00:33:18,540 --> 00:33:22,890
attaching that at the hardware level it

00:33:21,990 --> 00:33:24,540
will actually get us what we want

00:33:22,890 --> 00:33:25,890
otherwise I you know we can just do it

00:33:24,540 --> 00:33:28,350
in software and maybe we get those

00:33:25,890 --> 00:33:30,900
instructions getting used so plumbing

00:33:28,350 --> 00:33:33,150
plumbing access to the to the allocation

00:33:30,900 --> 00:33:34,830
is the slow way and software to do it

00:33:33,150 --> 00:33:37,020
but in hardware if we can just associate

00:33:34,830 --> 00:33:43,620
it with the memory region then we get it

00:33:37,020 --> 00:33:45,780
fast for free anyway I think that's it

00:33:43,620 --> 00:33:49,780
come ask me questions if you want to in

00:33:45,780 --> 00:33:55,489
person or email me thanks

00:33:49,780 --> 00:33:55,489

YouTube URL: https://www.youtube.com/watch?v=XfNt6MsLj0E


