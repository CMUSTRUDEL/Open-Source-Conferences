Title: Syzbot and the Tale of Thousand Kernel Bugs - Dmitry Vyukov, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Syzbot and the Tale of Thousand Kernel Bugs - Dmitry Vyukov, Google

The root cause of most software exploits is bugs. Hardening, mitigations and containers are important, but they can't protect a system with thousands of bugs. In this presentation, Dmitry Vyukov will review the current [sad] situation with Linux kernel bugs and security implications based on their experience testing kernel for the past 3 years; overview a set of bug finding tools they are developing (syzbot, syzkaller, KASAN, KMSAN, KTSAN); and discuss problems and areas that require community help to improve the situation.

About Dmitry Vyukov
I am working on Linux kernel dynamic bug detection tools (KASAN, KMSAN, KTSAN), kernel fuzzing (syzkaller, syzbot) for Linux and other OSes (Fuchsia, gVisor). Before that developed ThreadSanitizer, a user-space race detector (part of llvm, gcc, Go), go-fuzz (fuzzer for Go).
Captions: 
	00:00:00,030 --> 00:00:04,410
hello my name is Mitra bukhov I work a

00:00:02,520 --> 00:00:07,680
software engineer at Google in the

00:00:04,410 --> 00:00:09,540
dynamic tools team and I'm going to talk

00:00:07,680 --> 00:00:12,420
presents his boat and the tail of

00:00:09,540 --> 00:00:15,150
thousand kernel bugs so first of all I

00:00:12,420 --> 00:00:18,740
would like to ask how many of you know

00:00:15,150 --> 00:00:22,650
about since boat and sis collar

00:00:18,740 --> 00:00:28,349
ok so roughly half name is how many of

00:00:22,650 --> 00:00:32,969
you love sis boat ok about 10 people how

00:00:28,349 --> 00:00:35,550
many of you hate hates his boat to free

00:00:32,969 --> 00:00:40,230
and how many of you both love and hate

00:00:35,550 --> 00:00:44,160
sis but ok few people also that that

00:00:40,230 --> 00:00:47,270
would be majority ok so first I'm going

00:00:44,160 --> 00:00:49,980
to talk about kernel bug disaster and

00:00:47,270 --> 00:00:53,579
then I'm going to talk about what we are

00:00:49,980 --> 00:00:56,160
trying to do with this and then I will

00:00:53,579 --> 00:00:57,949
talk about what we're not doing yet and

00:00:56,160 --> 00:01:00,780
where we need help

00:00:57,949 --> 00:01:03,210
so as announced today civilization runs

00:01:00,780 --> 00:01:05,040
on Linux we have two billion Android

00:01:03,210 --> 00:01:08,250
users we have cloud service

00:01:05,040 --> 00:01:11,610
supercomputers desktops notebooks also

00:01:08,250 --> 00:01:14,360
cars plants space station and last but

00:01:11,610 --> 00:01:17,580
not least our coffee machines and

00:01:14,360 --> 00:01:21,030
security is critical Linux protects

00:01:17,580 --> 00:01:23,490
privacy of modern 2 billion user people

00:01:21,030 --> 00:01:24,240
and protects Karp Corp and government

00:01:23,490 --> 00:01:27,270
information

00:01:24,240 --> 00:01:29,670
it protects safety critical systems and

00:01:27,270 --> 00:01:32,100
is the first line of defense for all

00:01:29,670 --> 00:01:34,770
incoming network packets for untrusted

00:01:32,100 --> 00:01:39,570
application for virtual machine guests

00:01:34,770 --> 00:01:42,170
and also USB NFC Bluetooth traffic also

00:01:39,570 --> 00:01:45,270
for things like cars phones and plans

00:01:42,170 --> 00:01:46,950
stability and safety also critical so

00:01:45,270 --> 00:01:49,200
you can say that Linux kernel is one of

00:01:46,950 --> 00:01:53,360
the most security critical components in

00:01:49,200 --> 00:01:56,159
the world world today so maybe the most

00:01:53,360 --> 00:01:58,200
so there are all those box with logos

00:01:56,159 --> 00:02:00,570
and bold headlines and they can have

00:01:58,200 --> 00:02:03,390
produced lots of noise people start

00:02:00,570 --> 00:02:06,420
running and screaming and then we can

00:02:03,390 --> 00:02:09,959
fix them and then number of non box with

00:02:06,420 --> 00:02:12,070
logos zero so were kinda good but that's

00:02:09,959 --> 00:02:14,410
only the tip of the iceberg because

00:02:12,070 --> 00:02:17,290
Colonel has box and it has lots of box

00:02:14,410 --> 00:02:23,320
and as no box are the source of security

00:02:17,290 --> 00:02:26,110
issues so last year there were 450 CVS

00:02:23,320 --> 00:02:28,420
registered on colonel and some of them

00:02:26,110 --> 00:02:32,410
work was face code execution Sam has

00:02:28,420 --> 00:02:35,800
gained privileges but lots of box are

00:02:32,410 --> 00:02:38,170
unaccounted here and last year there

00:02:35,800 --> 00:02:40,420
were more than 4,000 kind of official

00:02:38,170 --> 00:02:42,930
bug fixes I think they count them by

00:02:40,420 --> 00:02:47,440
those fixes tax so again lots are

00:02:42,930 --> 00:02:49,450
unaccounted here about a year ago we

00:02:47,440 --> 00:02:52,330
deploy the system called see spot which

00:02:49,450 --> 00:02:55,120
is a continuous colonel fastening system

00:02:52,330 --> 00:02:59,890
and for the past 12 months it reports

00:02:55,120 --> 00:03:02,080
about 200 bucks per month we it reported

00:02:59,890 --> 00:03:06,370
more than thousand now in upstream

00:03:02,080 --> 00:03:09,330
colonel and 1200 bucks in Android Chrome

00:03:06,370 --> 00:03:12,370
OS and some of our internal kernels and

00:03:09,330 --> 00:03:15,220
before that we also used the father

00:03:12,370 --> 00:03:19,690
manually and reported modern thousand

00:03:15,220 --> 00:03:22,690
bucks for previous two years so in total

00:03:19,690 --> 00:03:29,140
we reported more than three thousand

00:03:22,690 --> 00:03:31,360
bucks now to give you one example some

00:03:29,140 --> 00:03:33,880
time ago we started testing husb stack

00:03:31,360 --> 00:03:36,610
from the external site so from the side

00:03:33,880 --> 00:03:39,519
of the USB cable connected to the

00:03:36,610 --> 00:03:42,160
machine and by barely scratching the

00:03:39,519 --> 00:03:44,680
surface of found modernity box all those

00:03:42,160 --> 00:03:46,600
box that there were all kind of bad box

00:03:44,680 --> 00:03:49,480
including use of the free out-of-bounds

00:03:46,600 --> 00:03:51,700
double freeze and all those box are

00:03:49,480 --> 00:03:56,530
trigger by just say me cable that that

00:03:51,700 --> 00:03:58,570
you connect to the machine and we didn't

00:03:56,530 --> 00:04:00,610
give even get past handshake so we

00:03:58,570 --> 00:04:02,500
didn't actually test the main driver

00:04:00,610 --> 00:04:05,590
code because you just run out of time

00:04:02,500 --> 00:04:07,870
and had to switch to something else

00:04:05,590 --> 00:04:10,720
but uses so I'm sure that there are two

00:04:07,870 --> 00:04:14,260
three five hundred bucks actually more

00:04:10,720 --> 00:04:15,940
that we didn't find yet and use business

00:04:14,260 --> 00:04:18,220
special this flow of boxes

00:04:15,940 --> 00:04:21,729
representative for just any subsystem

00:04:18,220 --> 00:04:23,870
that was third tests and KVM TCP UDP no

00:04:21,729 --> 00:04:28,729
sound 9pb PAF you know

00:04:23,870 --> 00:04:31,580
it here you can see snippet from from

00:04:28,729 --> 00:04:34,790
the Seas boat dashboard so now we have

00:04:31,580 --> 00:04:36,410
more than 200 open box we have there you

00:04:34,790 --> 00:04:39,470
know things like use of the free

00:04:36,410 --> 00:04:41,150
out-of-bounds they still happen they

00:04:39,470 --> 00:04:45,680
have reproduce errs they've all reported

00:04:41,150 --> 00:04:49,660
while ago still and fixed so that that's

00:04:45,680 --> 00:04:52,070
what currently present in the kernel of

00:04:49,660 --> 00:04:54,229
course we're getting not just use of the

00:04:52,070 --> 00:04:59,150
freeze and out of bounds we were getting

00:04:54,229 --> 00:05:00,229
some mix of box he says that things like

00:04:59,150 --> 00:05:04,699
bug

00:05:00,229 --> 00:05:08,270
warning now the ref initialized memory

00:05:04,699 --> 00:05:09,620
deadlocks hanks and all other stuff but

00:05:08,270 --> 00:05:12,440
the modest estimation that we were

00:05:09,620 --> 00:05:14,600
reportedly at least 500 security box and

00:05:12,440 --> 00:05:17,780
this is not count and things like lock

00:05:14,600 --> 00:05:23,240
of the nine of service and very few of

00:05:17,780 --> 00:05:25,370
those box have CDs it's important to

00:05:23,240 --> 00:05:28,250
note that exploit as necessary mean a

00:05:25,370 --> 00:05:30,530
use of the free we've seen a case when a

00:05:28,250 --> 00:05:32,960
machine was just unresponsive but after

00:05:30,530 --> 00:05:35,930
the bargain it turned out to be full

00:05:32,960 --> 00:05:38,389
guests the host escape because now there

00:05:35,930 --> 00:05:41,539
was guest trigger about page reference

00:05:38,389 --> 00:05:43,700
leaked we've seen a warning that turned

00:05:41,539 --> 00:05:45,650
out to be inter-process inter vm

00:05:43,700 --> 00:05:47,630
information leak because that was a

00:05:45,650 --> 00:05:50,000
warning to restore registers in the

00:05:47,630 --> 00:05:52,460
context switch and we've seen stalls

00:05:50,000 --> 00:05:58,610
that turned out to be remote denying of

00:05:52,460 --> 00:06:01,370
service box but not certain that that's

00:05:58,610 --> 00:06:03,830
not all looked at the number of back

00:06:01,370 --> 00:06:08,150
ports in a stable release associate is a

00:06:03,830 --> 00:06:10,010
stable and for the for the latest active

00:06:08,150 --> 00:06:13,400
ones like four point four four point

00:06:10,010 --> 00:06:16,970
nine we have almost 10,000 back boards

00:06:13,400 --> 00:06:18,919
there so not all of them are bug fixes

00:06:16,970 --> 00:06:22,430
with a sample maybe hundred of them and

00:06:18,919 --> 00:06:24,680
got impression that more than 95% of

00:06:22,430 --> 00:06:27,440
them are actually bug fixes so week

00:06:24,680 --> 00:06:31,370
almost all of them and on top of this

00:06:27,440 --> 00:06:33,530
way also have some fixes that already

00:06:31,370 --> 00:06:36,110
upstream but not back ported yet and

00:06:33,530 --> 00:06:36,710
this happens frequently because there is

00:06:36,110 --> 00:06:39,650
just no

00:06:36,710 --> 00:06:43,430
rose's we know that there is at least

00:06:39,650 --> 00:06:46,880
700 of them must likely a most likely

00:06:43,430 --> 00:06:50,230
much more there was a box that already

00:06:46,880 --> 00:06:53,840
found upstream but just not fixed yet

00:06:50,230 --> 00:06:56,000
also hundreds and obviously lots of bugs

00:06:53,840 --> 00:06:59,570
that we didn't find yet for various

00:06:56,000 --> 00:07:01,040
reasons so based on that I can conclude

00:06:59,570 --> 00:07:03,320
that every look is good and stable

00:07:01,040 --> 00:07:07,190
releases that we produce actually

00:07:03,320 --> 00:07:08,960
contains more than 20,000 bucks and now

00:07:07,190 --> 00:07:11,000
it's not getting better over time so

00:07:08,960 --> 00:07:13,610
it's not that we can fix this massive

00:07:11,000 --> 00:07:16,040
amount of bugs and now that the code is

00:07:13,610 --> 00:07:19,460
much better and we don't have them so if

00:07:16,040 --> 00:07:24,770
anything it only becomes worse and now

00:07:19,460 --> 00:07:27,580
this is not normal but the state of the

00:07:24,770 --> 00:07:31,370
upstream and even stable doesn't matter

00:07:27,580 --> 00:07:33,950
in the end because nobody uses upstream

00:07:31,370 --> 00:07:36,500
right people people have owned forks of

00:07:33,950 --> 00:07:38,780
the kernel and that's what they use the

00:07:36,500 --> 00:07:40,670
state of those let's say distress what

00:07:38,780 --> 00:07:42,590
what actually matters in practice and

00:07:40,670 --> 00:07:44,960
these three people say that they simply

00:07:42,590 --> 00:07:49,520
can't keep up with you know this flow of

00:07:44,960 --> 00:07:53,000
changes and there our CD is a file torn

00:07:49,520 --> 00:07:54,980
on very few of those box so the stable

00:07:53,000 --> 00:07:57,320
process is not fully working on the CD

00:07:54,980 --> 00:08:00,170
process is not working and if you ask

00:07:57,320 --> 00:08:03,140
why this another view for the stable

00:08:00,170 --> 00:08:05,840
releases this number of back ports per

00:08:03,140 --> 00:08:08,210
month and to make it more Apple to Apple

00:08:05,840 --> 00:08:10,820
sis pleaded for the first year of

00:08:08,210 --> 00:08:14,450
release life and the second year of

00:08:10,820 --> 00:08:17,720
release life so you can see that for 4.9

00:08:14,450 --> 00:08:20,950
it was 400 first year and then 500 per

00:08:17,720 --> 00:08:24,350
month next year and for the latest one

00:08:20,950 --> 00:08:28,430
4.14 it's now at about 700 per months

00:08:24,350 --> 00:08:31,640
for the past nine months so this is this

00:08:28,430 --> 00:08:37,250
a huge amount right it's like 22 per day

00:08:31,640 --> 00:08:42,020
each day no weekends so people can't can

00:08:37,250 --> 00:08:43,670
can't keep up with this and then so

00:08:42,020 --> 00:08:45,529
people don't use upstream right

00:08:43,670 --> 00:08:48,399
everybody for the kernels

00:08:45,529 --> 00:08:52,850
and there are lots of those Forks out

00:08:48,399 --> 00:08:54,350
there and each each forged buck is

00:08:52,850 --> 00:08:56,899
effectively in you buck for most

00:08:54,350 --> 00:08:58,819
practical purposes because that's a

00:08:56,899 --> 00:09:01,189
separate code base maintained by

00:08:58,819 --> 00:09:03,680
separate people separate process

00:09:01,189 --> 00:09:08,059
separate testing the buck can be fixed

00:09:03,680 --> 00:09:10,040
in one but not in another so say for for

00:09:08,059 --> 00:09:12,019
Google so if upstream contains the

00:09:10,040 --> 00:09:14,569
twenty thousand bucks so for Google it

00:09:12,019 --> 00:09:16,399
already makes it hundreds of thousands

00:09:14,569 --> 00:09:18,079
of bucks that we need to deal with and

00:09:16,399 --> 00:09:21,019
if you look at this industry why this

00:09:18,079 --> 00:09:28,519
already makes millions of bucks that

00:09:21,019 --> 00:09:32,449
people need to deal with Sabinas table

00:09:28,519 --> 00:09:34,040
helps a lot but it's still huge stream

00:09:32,449 --> 00:09:38,029
of bucks and you obviously don't want

00:09:34,040 --> 00:09:40,309
something like continuous deployment the

00:09:38,029 --> 00:09:44,779
Space Station right again you need to do

00:09:40,309 --> 00:09:47,629
some testing and bugs are being back

00:09:44,779 --> 00:09:50,350
ported to stable to ended significant

00:09:47,629 --> 00:09:52,910
rate which is kind of reasonable because

00:09:50,350 --> 00:09:55,519
bugs are being introduced at high rate

00:09:52,910 --> 00:09:57,500
and there's a weak testing so bug fixes

00:09:55,519 --> 00:10:00,290
contain box and those bugs are being

00:09:57,500 --> 00:10:03,410
back ported to stable and there are also

00:10:00,290 --> 00:10:07,750
stable specific box do like miss back

00:10:03,410 --> 00:10:12,259
ports or just seems slightly different

00:10:07,750 --> 00:10:14,269
and obviously there are some

00:10:12,259 --> 00:10:17,689
distributions who have large number of

00:10:14,269 --> 00:10:21,439
custom patches and for them any back

00:10:17,689 --> 00:10:24,439
portion case is a pain and work right

00:10:21,439 --> 00:10:28,059
and they also does things like board

00:10:24,439 --> 00:10:30,470
support packages which frequently

00:10:28,059 --> 00:10:36,230
basically not updated at all after

00:10:30,470 --> 00:10:38,629
they've been released and this kind of

00:10:36,230 --> 00:10:41,420
makes me sad so it doesn't look like the

00:10:38,629 --> 00:10:45,170
situation that should you know that how

00:10:41,420 --> 00:10:47,420
should things should be for the system

00:10:45,170 --> 00:10:51,050
that is as fundamental as a security

00:10:47,420 --> 00:10:53,209
critical as Linux kernel so it's a that

00:10:51,050 --> 00:10:57,019
we need to reduce number of bugs per

00:10:53,209 --> 00:10:58,140
release by a hundred so not just an

00:10:57,019 --> 00:11:01,140
order of magnitude

00:10:58,140 --> 00:11:04,620
two orders of magnitude to get something

00:11:01,140 --> 00:11:10,440
like 200 which is much more reasonable

00:11:04,620 --> 00:11:13,560
to deal with so there are some defenses

00:11:10,440 --> 00:11:16,200
which is great but existing defenses are

00:11:13,560 --> 00:11:19,410
not enough to protect from that many

00:11:16,200 --> 00:11:22,710
bugs so there is attic surface reduction

00:11:19,410 --> 00:11:25,410
which is great but this sludge surface

00:11:22,710 --> 00:11:28,710
is still open and most sub systems are

00:11:25,410 --> 00:11:30,900
still relevant so for example use B is

00:11:28,710 --> 00:11:33,210
not relevant for servers but relevant

00:11:30,900 --> 00:11:35,040
for clients and namespaces the other way

00:11:33,210 --> 00:11:38,130
around so can if in the end we still

00:11:35,040 --> 00:11:43,770
care about all of them and we have some

00:11:38,130 --> 00:11:46,230
mitigations like stack protector and ref

00:11:43,770 --> 00:11:48,540
count hardening but they simply can

00:11:46,230 --> 00:11:51,150
mitigate from hundreds of arbitrary

00:11:48,540 --> 00:11:52,710
memory corruptions because usually they

00:11:51,150 --> 00:11:57,420
it's assumed that there are few bucks

00:11:52,710 --> 00:11:59,640
and then mitigations maybe can help they

00:11:57,420 --> 00:12:03,510
also don't mitigate lots of types of

00:11:59,640 --> 00:12:06,570
bugs like races and initialized memory

00:12:03,510 --> 00:12:08,910
or if there is a more or less like right

00:12:06,570 --> 00:12:13,170
what were primitive then it's just game

00:12:08,910 --> 00:12:15,840
over and the CFI is also not completely

00:12:13,170 --> 00:12:18,470
effective in the kernel because for some

00:12:15,840 --> 00:12:20,970
functions there is very large number of

00:12:18,470 --> 00:12:24,380
functions with the same signature and

00:12:20,970 --> 00:12:28,260
for example for read the read callbacks

00:12:24,380 --> 00:12:30,630
function there are about 4000 of them

00:12:28,260 --> 00:12:31,760
with the signature many of them can be

00:12:30,630 --> 00:12:34,620
called

00:12:31,760 --> 00:12:37,290
and some mitigation cells not backported

00:12:34,620 --> 00:12:41,010
are not enabled - some kernels because

00:12:37,290 --> 00:12:43,380
of the sleep performance then there are

00:12:41,010 --> 00:12:45,360
things like a saline ox namespaces sofa

00:12:43,380 --> 00:12:48,390
severity but this is just illogical

00:12:45,360 --> 00:12:50,220
protection so they simply they directly

00:12:48,390 --> 00:12:53,880
assume that the kernel is not bad year

00:12:50,220 --> 00:12:56,220
which is not true and in particular

00:12:53,880 --> 00:12:58,860
users namespaces open even watch heretic

00:12:56,220 --> 00:13:01,680
surface they open lots of things that

00:12:58,860 --> 00:13:05,730
were historically candy fruit only and

00:13:01,680 --> 00:13:08,280
contain lots of bugs so today it's even

00:13:05,730 --> 00:13:09,960
unclear if it's a winner or not with

00:13:08,280 --> 00:13:12,210
respect to security

00:13:09,960 --> 00:13:15,870
and there's the thing that called hidin

00:13:12,210 --> 00:13:18,420
buggy code and the route so it can help

00:13:15,870 --> 00:13:21,240
to some degree but things like a saline

00:13:18,420 --> 00:13:24,630
ox I'm a module Simon they significantly

00:13:21,240 --> 00:13:27,750
restrict route and now it simply can't

00:13:24,630 --> 00:13:30,480
save a lot arbitrary codon into Colonel

00:13:27,750 --> 00:13:33,990
and for example on Android route is just

00:13:30,480 --> 00:13:36,960
explicitly not a trusted entity so when

00:13:33,990 --> 00:13:39,030
people get execution in a process with

00:13:36,960 --> 00:13:42,000
the root privileges they still go for a

00:13:39,030 --> 00:13:44,580
kernel exploit and then then user

00:13:42,000 --> 00:13:46,500
submits do what they need to do so if

00:13:44,580 --> 00:13:48,480
they need to mount an image and it's

00:13:46,500 --> 00:13:51,390
protected by a route like what do they

00:13:48,480 --> 00:13:55,230
do they just say sudo so they start

00:13:51,390 --> 00:14:00,780
saying see the left and right and still

00:13:55,230 --> 00:14:03,810
kind of exercise this functionality so

00:14:00,780 --> 00:14:07,170
defenses existing defenses can't help

00:14:03,810 --> 00:14:10,230
with you know kind of save us the

00:14:07,170 --> 00:14:14,130
security from front from that many bugs

00:14:10,230 --> 00:14:16,620
in the kernel ok and that's it for the

00:14:14,130 --> 00:14:18,780
for the sad part and now not so sad

00:14:16,620 --> 00:14:22,590
parts about what we're trying to do with

00:14:18,780 --> 00:14:25,440
this so what we're doing is only part of

00:14:22,590 --> 00:14:27,600
the solution situation is significantly

00:14:25,440 --> 00:14:30,510
rusty so it's not that there's just one

00:14:27,600 --> 00:14:34,220
magic thing that we can do and magically

00:14:30,510 --> 00:14:34,220
solve this whole problem

00:14:41,790 --> 00:14:47,800
so we have several bug detection tools

00:14:44,770 --> 00:14:49,750
that I called they called KS n K M sin

00:14:47,800 --> 00:14:51,910
and KT son

00:14:49,750 --> 00:14:54,190
we also a bug discovery tool called

00:14:51,910 --> 00:14:57,520
Cisco ler which is system called father

00:14:54,190 --> 00:15:03,540
and we have system called sis bot which

00:14:57,520 --> 00:15:06,760
is automated systematic testing solution

00:15:03,540 --> 00:15:09,580
so KS a no kernel address sanitized it's

00:15:06,760 --> 00:15:13,420
kind of our security workhorse both in

00:15:09,580 --> 00:15:15,160
kernel and in user space it detects box

00:15:13,420 --> 00:15:18,730
like use of the free and out of bounds

00:15:15,160 --> 00:15:20,890
on the heap stack and Global's the text

00:15:18,730 --> 00:15:23,530
box right at the point of occurrence it

00:15:20,890 --> 00:15:25,870
provides information reports so for

00:15:23,530 --> 00:15:28,450
example for use of the free it says

00:15:25,870 --> 00:15:30,550
where the stack were the bad access

00:15:28,450 --> 00:15:34,150
happens where the heap block was

00:15:30,550 --> 00:15:37,050
allocated and where it was freed it's

00:15:34,150 --> 00:15:39,190
easy to use you just enable Convocation

00:15:37,050 --> 00:15:41,800
the tube is based on compiler

00:15:39,190 --> 00:15:45,370
instrumentation and you need it in GCC

00:15:41,800 --> 00:15:49,690
4.9 at least the clonk it's also

00:15:45,370 --> 00:15:54,100
reasonably fast and has a reasonable

00:15:49,690 --> 00:15:56,530
memory overhead of about 2x but that's

00:15:54,100 --> 00:15:59,860
only for the kernel part of the workload

00:15:56,530 --> 00:16:02,320
and the kernel usually takes small time

00:15:59,860 --> 00:16:04,630
of the overall CPU time so in practice

00:16:02,320 --> 00:16:07,180
it may be close be close to actually

00:16:04,630 --> 00:16:12,190
unnoticeable and it's upstream in the

00:16:07,180 --> 00:16:15,400
kernel since 4.3 the next tool is called

00:16:12,190 --> 00:16:17,920
km Sun a kernel memory sanitizer it

00:16:15,400 --> 00:16:20,710
detects uses of initialized values in

00:16:17,920 --> 00:16:22,840
kernel and in the context of security

00:16:20,710 --> 00:16:25,600
this means in particular things like

00:16:22,840 --> 00:16:29,020
information leaks both local and remote

00:16:25,600 --> 00:16:31,180
and those are very easy to exploits way

00:16:29,020 --> 00:16:34,060
easier than all that speculative stuff

00:16:31,180 --> 00:16:35,500
and gives a much faster channel from the

00:16:34,060 --> 00:16:37,750
kernel

00:16:35,500 --> 00:16:40,510
it also can lead to control flow

00:16:37,750 --> 00:16:43,510
subversion when Angeles values used in

00:16:40,510 --> 00:16:46,150
in control flow and it also can lead to

00:16:43,510 --> 00:16:48,670
data ethics for example if you have an

00:16:46,150 --> 00:16:52,329
initialized user ID and we actually seen

00:16:48,670 --> 00:16:54,759
such a box it's not upstream

00:16:52,329 --> 00:16:57,809
it's on github and at this point it can

00:16:54,759 --> 00:17:02,589
fall must ready it's already works it

00:16:57,809 --> 00:17:05,350
mostly enable enabled on sis bought in

00:17:02,589 --> 00:17:08,769
finds box it found more than 50 bucks

00:17:05,350 --> 00:17:10,419
upstream now but we're fighting we'll

00:17:08,769 --> 00:17:14,409
fight some currently with the long tail

00:17:10,419 --> 00:17:18,630
of various false positives and crashes

00:17:14,409 --> 00:17:18,630
because the tube is quite complex and

00:17:18,929 --> 00:17:26,589
the last was sketchy Santa Colonel Fred

00:17:22,120 --> 00:17:28,690
sanitizer and it detects data races yes

00:17:26,589 --> 00:17:32,710
and I forgot to mention came son also

00:17:28,690 --> 00:17:35,139
requires Clank it's so the rest of the

00:17:32,710 --> 00:17:39,100
two were ported to GC and this one is

00:17:35,139 --> 00:17:42,000
will not be ported to GCC we colonel

00:17:39,100 --> 00:17:44,620
frets indices so it finds data races

00:17:42,000 --> 00:17:48,010
supernal data race also represents

00:17:44,620 --> 00:17:50,200
security Fred there is that common type

00:17:48,010 --> 00:17:52,929
of ethical time of check time of use

00:17:50,200 --> 00:17:55,779
when you load something and check and

00:17:52,929 --> 00:17:58,000
then use this thing later assuming that

00:17:55,779 --> 00:17:59,649
it's the same value but another Fred

00:17:58,000 --> 00:18:03,610
could actually change this value in

00:17:59,649 --> 00:18:08,919
between and again sometimes we see data

00:18:03,610 --> 00:18:10,630
races on sacred credentials and also

00:18:08,919 --> 00:18:13,600
lots of use of the fries and double

00:18:10,630 --> 00:18:17,980
fries in kernel actually caused by data

00:18:13,600 --> 00:18:21,580
races so we have prototype on github it

00:18:17,980 --> 00:18:24,190
was done by an intern and currently it's

00:18:21,580 --> 00:18:27,669
frozen due to lack of resources it found

00:18:24,190 --> 00:18:30,070
about 20 data races and the main

00:18:27,669 --> 00:18:32,080
obstacle for deployment is that the

00:18:30,070 --> 00:18:34,929
kernel is full of so called benign data'

00:18:32,080 --> 00:18:38,260
races which is strictly sane undefined

00:18:34,929 --> 00:18:42,070
behavior and see but historically kernel

00:18:38,260 --> 00:18:48,370
was getting sloppy with this and there

00:18:42,070 --> 00:18:50,679
are lots of unmarked accesses yeah so to

00:18:48,370 --> 00:18:56,169
deploy that we would need to get rid of

00:18:50,679 --> 00:18:56,919
all of them sis color so it's a system

00:18:56,169 --> 00:19:00,039
called father

00:18:56,919 --> 00:19:03,580
it's grammar based and its coverage

00:19:00,039 --> 00:19:05,380
guided and it's mostly unsupervised it's

00:19:03,580 --> 00:19:10,690
also multi operating system

00:19:05,380 --> 00:19:12,400
capture and machine-type so on the first

00:19:10,690 --> 00:19:15,850
session there was a question about the

00:19:12,400 --> 00:19:19,270
fuchsia testing so we also exported the

00:19:15,850 --> 00:19:22,960
fusion with as few chances but whilst as

00:19:19,270 --> 00:19:26,290
devisor and Icarus and also all of the

00:19:22,960 --> 00:19:30,250
bsd flavours also supported mostly by

00:19:26,290 --> 00:19:34,360
isis color so it's compared to other

00:19:30,250 --> 00:19:37,000
buzzers it tends to find deeper box and

00:19:34,360 --> 00:19:39,790
it also usually provides reproducers and

00:19:37,000 --> 00:19:45,190
it does decent regression testing and

00:19:39,790 --> 00:19:47,920
it's scalable to large number of box so

00:19:45,190 --> 00:19:49,780
I've said that it's grammar based and

00:19:47,920 --> 00:19:52,810
what this means in practice is that we

00:19:49,780 --> 00:19:55,870
have declarative descriptions of system

00:19:52,810 --> 00:20:00,550
call interfaces you can see example on

00:19:55,870 --> 00:20:03,880
the slide so this small this mostly like

00:20:00,550 --> 00:20:05,410
C function and structure declaration so

00:20:03,880 --> 00:20:07,180
hopefully can read it

00:20:05,410 --> 00:20:10,150
they have just more semantical

00:20:07,180 --> 00:20:13,750
information for argument types and

00:20:10,150 --> 00:20:19,600
fields and those descriptions help to

00:20:13,750 --> 00:20:21,040
generate much better workload but the

00:20:19,600 --> 00:20:22,660
further tests only what's being

00:20:21,040 --> 00:20:25,090
described so it doesn't just magically

00:20:22,660 --> 00:20:28,030
test all of the kernel with tests on the

00:20:25,090 --> 00:20:31,450
things for which it has such

00:20:28,030 --> 00:20:35,110
descriptions and from those descriptions

00:20:31,450 --> 00:20:38,160
we generate programs in the following

00:20:35,110 --> 00:20:42,250
form we can see an example on the slide

00:20:38,160 --> 00:20:44,290
so this is also more like C program just

00:20:42,250 --> 00:20:46,510
the sequence of system calls with actual

00:20:44,290 --> 00:20:54,790
arguments and that's what actually we

00:20:46,510 --> 00:20:57,250
execute and mutate and and store and on

00:20:54,790 --> 00:21:00,340
top of this we have the C spot which is

00:20:57,250 --> 00:21:02,650
a fuzzy automation system it does it you

00:21:00,340 --> 00:21:04,780
know continuous kernel and sis color

00:21:02,650 --> 00:21:08,110
built and updates at all this uses the

00:21:04,780 --> 00:21:10,200
latest version of both thus test machine

00:21:08,110 --> 00:21:12,640
management does bug deduplication

00:21:10,200 --> 00:21:15,010
localization and in the any data

00:21:12,640 --> 00:21:18,510
magically reports box the kernel mailing

00:21:15,010 --> 00:21:22,220
lists and then thus box data straight

00:21:18,510 --> 00:21:22,220
it can understand when a bug is fixed

00:21:23,990 --> 00:21:29,340
okay so that's what I doing but we also

00:21:27,390 --> 00:21:31,590
need your help just because there are

00:21:29,340 --> 00:21:34,080
too many developers too many bugs and we

00:21:31,590 --> 00:21:36,410
simply can't handle all of this

00:21:34,080 --> 00:21:36,410
ourselves

00:21:39,900 --> 00:21:46,890
so first of all we need more of the

00:21:42,480 --> 00:21:49,010
system call descriptions because current

00:21:46,890 --> 00:21:51,590
coverage is far from being complete and

00:21:49,010 --> 00:21:56,370
the the more descriptions we had the

00:21:51,590 --> 00:21:58,700
linearly more box we discover and fix we

00:21:56,370 --> 00:22:01,860
also have poor environment setup for

00:21:58,700 --> 00:22:04,830
some things like network devices a silly

00:22:01,860 --> 00:22:06,960
Knox policies and some other so the

00:22:04,830 --> 00:22:09,660
problem is that there are hundreds of

00:22:06,960 --> 00:22:12,030
subsystems in the kernel and lots of

00:22:09,660 --> 00:22:15,570
them are quite complex and we're not an

00:22:12,030 --> 00:22:18,750
experts in any of them but we see things

00:22:15,570 --> 00:22:22,260
like say a CV that was classified as

00:22:18,750 --> 00:22:24,090
remote code execution so bad and it was

00:22:22,260 --> 00:22:25,800
in something called net filter and at

00:22:24,090 --> 00:22:29,040
the time we witches didn't know that

00:22:25,800 --> 00:22:30,900
this thing exists or we seen the Android

00:22:29,040 --> 00:22:34,140
use of the free that was classified as

00:22:30,900 --> 00:22:36,480
high severity is in something called an

00:22:34,140 --> 00:22:39,870
S FS and we still don't know what it is

00:22:36,480 --> 00:22:41,730
and don't test it so adding those

00:22:39,870 --> 00:22:44,100
description is not hard that there is

00:22:41,730 --> 00:22:47,630
some learning curve but when you do the

00:22:44,100 --> 00:22:53,310
second one it should be pretty easy and

00:22:47,630 --> 00:22:59,000
we have lots of examples the next thing

00:22:53,310 --> 00:23:02,160
is testing external inputs to the kernel

00:22:59,000 --> 00:23:04,530
so currently C scholar can inject

00:23:02,160 --> 00:23:07,710
network packets into the networking

00:23:04,530 --> 00:23:10,530
stack we had in device today as if came

00:23:07,710 --> 00:23:14,550
from from external side and this

00:23:10,530 --> 00:23:17,610
obviously gives the most critical box we

00:23:14,550 --> 00:23:21,510
have some basic coverage we will have

00:23:17,610 --> 00:23:24,240
descriptions for Ethernet IP in TCP and

00:23:21,510 --> 00:23:26,190
UDP and for few other protocols but

00:23:24,240 --> 00:23:29,220
there I'm sure there are more protocols

00:23:26,190 --> 00:23:30,730
and the quite complex and some of them

00:23:29,220 --> 00:23:35,950
require some network

00:23:30,730 --> 00:23:37,720
device setup so I mentioned USB we want

00:23:35,950 --> 00:23:41,460
to revive this work and can have

00:23:37,720 --> 00:23:44,410
actually test more of the USB drivers

00:23:41,460 --> 00:23:48,309
but then a lots of other things like NFC

00:23:44,410 --> 00:23:51,090
can Bluetooth guess the host interfaces

00:23:48,309 --> 00:23:53,350
and maybe things a keyboard mouse and

00:23:51,090 --> 00:23:54,130
also the things that I don't know about

00:23:53,350 --> 00:23:56,679
yet

00:23:54,130 --> 00:23:58,750
so some of them may require agent some

00:23:56,679 --> 00:24:01,809
stub devices like it's you need at a low

00:23:58,750 --> 00:24:04,510
to can inject the inputs into that

00:24:01,809 --> 00:24:08,790
system as is as if they came from

00:24:04,510 --> 00:24:13,000
external side some may already have it

00:24:08,790 --> 00:24:17,640
for example USB have such support and it

00:24:13,000 --> 00:24:17,640
doesn't require any additional devices

00:24:18,210 --> 00:24:26,980
okay so we also have lots of open box

00:24:23,880 --> 00:24:28,870
hundreds of box it was reported and not

00:24:26,980 --> 00:24:31,240
fixed some of them are just bad

00:24:28,870 --> 00:24:34,480
vulnerabilities in itself

00:24:31,240 --> 00:24:37,330
Adam effects the ability or denying of

00:24:34,480 --> 00:24:38,890
surface that type of box but even the

00:24:37,330 --> 00:24:42,000
rest they still harm the scholars

00:24:38,890 --> 00:24:44,440
ability to uncover more critical box so

00:24:42,000 --> 00:24:46,330
we can expect that we will find all of

00:24:44,440 --> 00:24:49,059
the critical ones if will not start

00:24:46,330 --> 00:24:52,540
fixing all of them so we need help

00:24:49,059 --> 00:24:55,630
fixing those box and also triage in

00:24:52,540 --> 00:24:58,960
route and up and closing fixed obsolete

00:24:55,630 --> 00:25:01,450
box so usually this is considered as

00:24:58,960 --> 00:25:04,960
part of the develop development workflow

00:25:01,450 --> 00:25:07,540
so if you submit code or maintain a

00:25:04,960 --> 00:25:13,780
subsystem please also contribute to to

00:25:07,540 --> 00:25:16,510
those efforts okay so the next thing is

00:25:13,780 --> 00:25:19,480
related to case on the case and back

00:25:16,510 --> 00:25:22,390
based on compiler instrumentations who

00:25:19,480 --> 00:25:24,580
checks only the C memory access and it

00:25:22,390 --> 00:25:27,750
checks them with with respect to K

00:25:24,580 --> 00:25:31,360
malloc State so it does not check

00:25:27,750 --> 00:25:33,640
Memorex has done an assembly done in

00:25:31,360 --> 00:25:35,950
hardware and it doesn't detect use of

00:25:33,640 --> 00:25:39,000
the freezing out of bounds if there is

00:25:35,950 --> 00:25:42,520
some kind of custom cache incor growth

00:25:39,000 --> 00:25:44,470
amortization scheme involved so an

00:25:42,520 --> 00:25:48,250
object can be freed in some cost

00:25:44,470 --> 00:25:50,799
- but it's not free to the kk malik

00:25:48,250 --> 00:25:52,630
rated slap so still considered as

00:25:50,799 --> 00:25:55,169
allocated in case and will not catch

00:25:52,630 --> 00:25:58,799
back on such objects

00:25:55,169 --> 00:26:01,840
jason has annotation for both chicken a

00:25:58,799 --> 00:26:03,909
range of memory if it's good or bad also

00:26:01,840 --> 00:26:08,460
know dayton a range of memories a good

00:26:03,909 --> 00:26:10,659
or bad so a good example is escapee

00:26:08,460 --> 00:26:13,210
Skippy is a core networking data

00:26:10,659 --> 00:26:18,520
structure and it used to hold packet

00:26:13,210 --> 00:26:21,159
data it has so-called linear data which

00:26:18,520 --> 00:26:25,720
is just directly accessible buffer of

00:26:21,159 --> 00:26:28,179
packet data and there's an API like you

00:26:25,720 --> 00:26:30,370
can ask for to pull in say two bytes

00:26:28,179 --> 00:26:32,289
into this liner buffer and then you can

00:26:30,370 --> 00:26:37,120
access those two bytes but should not

00:26:32,289 --> 00:26:39,010
access third byte or if you ask for

00:26:37,120 --> 00:26:41,620
three bytes now you can access free

00:26:39,010 --> 00:26:43,659
bytes but the previous book buffer can

00:26:41,620 --> 00:26:48,549
be reallocated so you should not access

00:26:43,659 --> 00:26:51,130
the previous pointer but the thing is

00:26:48,549 --> 00:26:53,860
that sqp uses very active proactive

00:26:51,130 --> 00:26:55,900
amortized grow obviously to not

00:26:53,860 --> 00:26:58,270
reallocate it you know each time you ask

00:26:55,900 --> 00:27:00,280
for another bite so usually you can get

00:26:58,270 --> 00:27:03,070
away with actual access and more or

00:27:00,280 --> 00:27:04,870
accessing the old pointers and this

00:27:03,070 --> 00:27:08,590
super easy to get wrong and there are

00:27:04,870 --> 00:27:11,350
lots and lots of such code and it's just

00:27:08,590 --> 00:27:13,360
a bug nest I'm sure there are dozens of

00:27:11,350 --> 00:27:17,110
remotely trigger bail box which we

00:27:13,360 --> 00:27:19,990
currently not detect mostly so it can

00:27:17,110 --> 00:27:22,750
make sense to do more stricter exact

00:27:19,990 --> 00:27:24,909
grow police if on the case and for ASCII

00:27:22,750 --> 00:27:28,929
be so this something that currently is

00:27:24,909 --> 00:27:31,179
not done obviously we don't want those

00:27:28,929 --> 00:27:34,090
annotations sprinkled throughout the

00:27:31,179 --> 00:27:36,640
codebase but there can be some you know

00:27:34,090 --> 00:27:39,370
things that that's still worth it for

00:27:36,640 --> 00:27:40,360
example something and GMA I to see SPI

00:27:39,370 --> 00:27:43,870
Virchow

00:27:40,360 --> 00:27:47,380
maybe something common in USB or file

00:27:43,870 --> 00:27:49,289
systems so if you have any good ideas

00:27:47,380 --> 00:27:52,750
know that this kind of a way to

00:27:49,289 --> 00:27:53,960
potentially detect lots of box there if

00:27:52,750 --> 00:27:59,059
we add some

00:27:53,960 --> 00:28:01,909
no annotations then there are some other

00:27:59,059 --> 00:28:04,399
tools which we do not use on sis both

00:28:01,909 --> 00:28:06,529
currently but it would be great to use

00:28:04,399 --> 00:28:09,529
them so the first one is came Emily

00:28:06,529 --> 00:28:12,110
called memory a leak detector and I

00:28:09,529 --> 00:28:14,210
heard from server people that memory

00:28:12,110 --> 00:28:16,850
leaks actually the worse box out there

00:28:14,210 --> 00:28:19,760
because they just silently drain machine

00:28:16,850 --> 00:28:23,210
resources slowly and then you kind of

00:28:19,760 --> 00:28:26,059
have everything slow for them can

00:28:23,210 --> 00:28:29,990
understand why obviously remote memory

00:28:26,059 --> 00:28:32,059
leaks also bad but the problem is that

00:28:29,990 --> 00:28:34,779
the tool has false positives and this

00:28:32,059 --> 00:28:37,610
means that we cannot use it in automatic

00:28:34,779 --> 00:28:40,279
systematic testing setting because we

00:28:37,610 --> 00:28:43,250
Europe automatically report all things

00:28:40,279 --> 00:28:45,230
that we find and nobody will be happy if

00:28:43,250 --> 00:28:49,340
this will produce you know in constant

00:28:45,230 --> 00:28:51,799
stream of false positives so it's

00:28:49,340 --> 00:28:56,870
possible to make it precise and would be

00:28:51,799 --> 00:28:59,600
very nice to do the next tool is KUB sun

00:28:56,870 --> 00:29:02,779
undefined behavior sanitizer and it

00:28:59,600 --> 00:29:05,440
finds some kind of more local cases of

00:29:02,779 --> 00:29:09,980
undefined behavior and seem it can find

00:29:05,440 --> 00:29:13,190
intro object overflows it can find cases

00:29:09,980 --> 00:29:15,620
where bull or an arms have wrong values

00:29:13,190 --> 00:29:18,289
and surprisingly this can lead to

00:29:15,620 --> 00:29:20,330
control flow hydration because you can

00:29:18,289 --> 00:29:23,809
have a pool that is needed true nor

00:29:20,330 --> 00:29:26,960
false or both true and false or you can

00:29:23,809 --> 00:29:30,500
have for example a switch on on an enum

00:29:26,960 --> 00:29:32,360
value implemented as a jump table and

00:29:30,500 --> 00:29:37,490
then the compiler can eliminate the

00:29:32,360 --> 00:29:40,460
bounce check on daenam also detects

00:29:37,490 --> 00:29:42,890
overflows and valid shifts which also

00:29:40,460 --> 00:29:45,140
can lead to out-of-bounds access and

00:29:42,890 --> 00:29:48,820
sometimes in surprising ways for example

00:29:45,140 --> 00:29:51,770
if you shift if variable is used as a

00:29:48,820 --> 00:29:54,260
right a Brunt in a shift operation then

00:29:51,770 --> 00:29:56,990
compiler can start making assumptions

00:29:54,260 --> 00:29:59,539
about the range of of the values in that

00:29:56,990 --> 00:30:03,130
variable and as a result it can say

00:29:59,539 --> 00:30:03,130
eliminate some bounds chicken

00:30:04,440 --> 00:30:09,530
okay the thing that the colonel still

00:30:07,020 --> 00:30:12,360
needs some cleanup for those bugs and

00:30:09,530 --> 00:30:15,500
most serious problem and that lots of

00:30:12,360 --> 00:30:19,250
bugs face some significant opposition

00:30:15,500 --> 00:30:22,950
especially the the overflows the shifts

00:30:19,250 --> 00:30:24,990
yes so it's it's kind of makes it

00:30:22,950 --> 00:30:27,510
impossible to deploy if we need to kind

00:30:24,990 --> 00:30:32,250
of have a some some kind of battle for

00:30:27,510 --> 00:30:34,920
each other bug and the next was Katie

00:30:32,250 --> 00:30:37,980
son which already mentioned so I'm sure

00:30:34,920 --> 00:30:40,980
to find thousands of hard to achilles

00:30:37,980 --> 00:30:43,950
races in Colonel and provide extra

00:30:40,980 --> 00:30:46,740
actionable reports for them but we need

00:30:43,950 --> 00:30:50,820
to say no to to the benign races and and

00:30:46,740 --> 00:30:53,160
just mark all concurrent EXO races are

00:30:50,820 --> 00:30:56,690
undefined behavior and see and they can

00:30:53,160 --> 00:30:59,400
also the super sub toad reason about and

00:30:56,690 --> 00:31:01,530
super hard to get right so if you think

00:30:59,400 --> 00:31:04,500
that it's easier then maybe you you just

00:31:01,530 --> 00:31:09,960
don't see the whole problem so even the

00:31:04,500 --> 00:31:14,630
things like aligned in store a lot can

00:31:09,960 --> 00:31:20,240
actually lead to very surprising things

00:31:14,630 --> 00:31:24,960
and the last thing I wanted to touch is

00:31:20,240 --> 00:31:28,710
Colonel testing so most of the Box can

00:31:24,960 --> 00:31:31,020
be prevented with testing and it can

00:31:28,710 --> 00:31:32,850
defuse that we're not doing enough that

00:31:31,020 --> 00:31:35,940
we can do much better on the colonel

00:31:32,850 --> 00:31:38,280
testing side so we had this twenty

00:31:35,940 --> 00:31:41,880
thousand bucks per release new bugs have

00:31:38,280 --> 00:31:45,060
been introduced at a very high rate bugs

00:31:41,880 --> 00:31:47,340
are being back ported to stable bugs

00:31:45,060 --> 00:31:50,940
have been reintroduced and nobody can

00:31:47,340 --> 00:31:53,010
keep up with this flow and development

00:31:50,940 --> 00:31:54,570
is also slowed down because there's high

00:31:53,010 --> 00:31:57,030
reliance and manual labor

00:31:54,570 --> 00:31:59,940
there are delayed releases their broken

00:31:57,030 --> 00:32:01,950
bills which in particular prevent by

00:31:59,940 --> 00:32:04,920
sections people ask us for this section

00:32:01,950 --> 00:32:09,630
but sometimes the kernel is broken a

00:32:04,920 --> 00:32:12,630
dozen boot for months there's also long

00:32:09,630 --> 00:32:14,910
fix latencies in most project with

00:32:12,630 --> 00:32:15,490
modern development processes it's

00:32:14,910 --> 00:32:17,830
usually

00:32:15,490 --> 00:32:19,960
possible to say push a critical fix for

00:32:17,830 --> 00:32:22,450
example for a build breakage within a

00:32:19,960 --> 00:32:25,570
day or even within an hour and internal

00:32:22,450 --> 00:32:27,880
it frequently takes month

00:32:25,570 --> 00:32:30,640
they're also late hit back for bugs

00:32:27,880 --> 00:32:33,760
the developers developer can receive a

00:32:30,640 --> 00:32:36,960
bug report you know after you know two

00:32:33,760 --> 00:32:41,080
or three months after he submitted the

00:32:36,960 --> 00:32:43,179
the change right and here they already

00:32:41,080 --> 00:32:47,980
forgot about the change already on the

00:32:43,179 --> 00:32:50,050
vacation so I spent some time in a

00:32:47,980 --> 00:32:52,120
thinking what to say here because there

00:32:50,050 --> 00:32:54,520
are kind of some tests somewhere and

00:32:52,120 --> 00:32:59,020
somebody kinda runs them sometimes and

00:32:54,520 --> 00:33:01,420
does something with the results so if if

00:32:59,020 --> 00:33:03,429
I say that there are no tests then or

00:33:01,420 --> 00:33:08,190
there there is no testing then it's

00:33:03,429 --> 00:33:12,990
false right but still feels that kind of

00:33:08,190 --> 00:33:15,190
there's something to improve for testing

00:33:12,990 --> 00:33:17,260
and I think that something is the

00:33:15,190 --> 00:33:20,380
testing needs to be an integral part of

00:33:17,260 --> 00:33:22,000
the development process so it not be it

00:33:20,380 --> 00:33:24,970
should not be just something you know on

00:33:22,000 --> 00:33:27,280
the side done by some other people so we

00:33:24,970 --> 00:33:29,679
need tests and trigger the testing to be

00:33:27,280 --> 00:33:31,900
easy to write is it the discover is it

00:33:29,679 --> 00:33:35,250
run and easy to understand when they

00:33:31,900 --> 00:33:39,070
pass a fail we need both user space

00:33:35,250 --> 00:33:42,820
person some internal tests with support

00:33:39,070 --> 00:33:44,679
for easy hardware mocking we meet a test

00:33:42,820 --> 00:33:47,010
for new functionalities at the

00:33:44,679 --> 00:33:50,350
regression tests and we absolutely need

00:33:47,010 --> 00:33:52,750
automated continuous testing which is a

00:33:50,350 --> 00:33:56,590
part of development processes and not

00:33:52,750 --> 00:33:58,540
just somewhere on the side so we need

00:33:56,590 --> 00:34:00,880
pre submit tests and we need say

00:33:58,540 --> 00:34:03,429
developer waiting for the four plus one

00:34:00,880 --> 00:34:07,150
from the testing infrastructure before

00:34:03,429 --> 00:34:09,040
the committee submitted or even say

00:34:07,150 --> 00:34:11,830
thing called commit queue which is now

00:34:09,040 --> 00:34:14,470
used in some projects when the changes

00:34:11,830 --> 00:34:17,889
approval approved by humans it gets into

00:34:14,470 --> 00:34:21,280
the commit queue and then robots tested

00:34:17,889 --> 00:34:24,790
on had and only test pass they came

00:34:21,280 --> 00:34:26,859
automatically commit the change and the

00:34:24,790 --> 00:34:28,200
the infrastructure she needs to use all

00:34:26,859 --> 00:34:31,109
of the available tools

00:34:28,200 --> 00:34:34,260
frequently we see box that could be

00:34:31,109 --> 00:34:38,280
trivially detected if existent the bug

00:34:34,260 --> 00:34:40,520
and tools will be used yeah but like to

00:34:38,280 --> 00:34:43,290
the case and unlock them in particular

00:34:40,520 --> 00:34:46,829
but lots of them still being committed

00:34:43,290 --> 00:34:49,409
at the kernel then the center is not an

00:34:46,829 --> 00:34:50,790
easy to do easy thing to do and it's not

00:34:49,409 --> 00:34:55,440
that they have all of the answers and

00:34:50,790 --> 00:34:58,290
kind of can say what what exactly a kind

00:34:55,440 --> 00:35:00,390
of how exactly to do this but I feel

00:34:58,290 --> 00:35:05,339
that that that's the direction where we

00:35:00,390 --> 00:35:08,030
need to move and this thank you and I'm

00:35:05,339 --> 00:35:08,030
ready to answer questions

00:35:09,750 --> 00:35:16,280
[Applause]

00:35:20,440 --> 00:35:25,900
you mentioned that you filed bugs how do

00:35:22,570 --> 00:35:29,140
you Dooley figuring out where to file a

00:35:25,900 --> 00:35:31,090
bug because there's really no clear way

00:35:29,140 --> 00:35:32,440
of figuring out how to do it do you look

00:35:31,090 --> 00:35:34,390
through the maintainer smile how do you

00:35:32,440 --> 00:35:37,750
figure out where the the bug should be

00:35:34,390 --> 00:35:40,960
going to be reported so we send box to

00:35:37,750 --> 00:35:43,570
mailing list and we from the crash

00:35:40,960 --> 00:35:45,910
report we try to find the guilty file

00:35:43,570 --> 00:35:48,250
which is kind of usually on the top of

00:35:45,910 --> 00:35:50,740
the stack trace but we skip some of the

00:35:48,250 --> 00:35:53,620
top frames like the comment for example

00:35:50,740 --> 00:35:56,050
if it's mmm slab then we skip it and

00:35:53,620 --> 00:35:58,630
then we run get maintainer

00:35:56,050 --> 00:36:02,380
on that file and that's that's the list

00:35:58,630 --> 00:36:04,000
of the people do you need this process

00:36:02,380 --> 00:36:05,260
improve do you need a better way to

00:36:04,000 --> 00:36:06,670
figure out where the bugs should be

00:36:05,260 --> 00:36:07,840
filed because I believe I'll it just

00:36:06,670 --> 00:36:11,590
looks at the maintainer file there's

00:36:07,840 --> 00:36:16,840
only like 19 bug where to file the bugs

00:36:11,590 --> 00:36:19,570
references but all of them have kind of

00:36:16,840 --> 00:36:20,890
CC people of the CC email addresses

00:36:19,570 --> 00:36:23,440
right but you mentioned that you also

00:36:20,890 --> 00:36:26,170
track when the bugs been fixed yes so

00:36:23,440 --> 00:36:29,890
the kernel doesn't have the bug tracking

00:36:26,170 --> 00:36:34,330
system per se right there is bugzilla

00:36:29,890 --> 00:36:36,850
but it's not that it's can be used so

00:36:34,330 --> 00:36:40,930
with we build the bug tracking process

00:36:36,850 --> 00:36:43,890
around the existing email kernel process

00:36:40,930 --> 00:36:46,990
so the main scenario is that we give the

00:36:43,890 --> 00:36:49,210
reported by tag in the email in the

00:36:46,990 --> 00:36:51,970
report email and then the developer

00:36:49,210 --> 00:36:54,760
needs to put the stack and fixham commit

00:36:51,970 --> 00:36:56,380
and then we pull the get trees and when

00:36:54,760 --> 00:37:00,130
we see this commit we understand that

00:36:56,380 --> 00:37:02,320
this commit fixes that bug and when we

00:37:00,130 --> 00:37:04,960
see this camila and all of our builders

00:37:02,320 --> 00:37:08,590
then we close the book and then we the

00:37:04,960 --> 00:37:11,200
closing box is important because only

00:37:08,590 --> 00:37:13,900
once we close it we can report new box

00:37:11,200 --> 00:37:15,580
that look similarly and there are cases

00:37:13,900 --> 00:37:20,110
actually when we can have see the bug

00:37:15,580 --> 00:37:21,880
that looks almost exactly the same but

00:37:20,110 --> 00:37:24,400
the new one is reported only when we

00:37:21,880 --> 00:37:26,500
close the previous one so the previous

00:37:24,400 --> 00:37:30,000
one is closed they will all just pile

00:37:26,500 --> 00:37:30,000
into the same beam

00:37:40,069 --> 00:37:43,220
I'm shortened to know if there's a copy

00:37:41,720 --> 00:37:45,380
of you talk online I saw there's a lot

00:37:43,220 --> 00:37:50,000
of hyperlinks they didn't say where they

00:37:45,380 --> 00:37:53,450
were - yeah yes I will send this to more

00:37:50,000 --> 00:37:57,339
today to organizers and I will also post

00:37:53,450 --> 00:37:57,339
it somewhere online

00:38:04,220 --> 00:38:10,010
what was curious what our options are if

00:38:06,380 --> 00:38:12,230
we want to fuzz a piece of kernel code

00:38:10,010 --> 00:38:15,619
that's not reachable due to kernel

00:38:12,230 --> 00:38:17,150
config decisions like I was taking a

00:38:15,619 --> 00:38:19,340
look at the the kernel configs that you

00:38:17,150 --> 00:38:21,910
guys have and for instance it wouldn't

00:38:19,340 --> 00:38:24,500
be possible to fuzz a Parmer currently

00:38:21,910 --> 00:38:30,050
is that possible is there a way to

00:38:24,500 --> 00:38:32,840
specify a custom kernel config you've

00:38:30,050 --> 00:38:37,160
mentioned that part right it's enabled

00:38:32,840 --> 00:38:39,200
but su linux ajussi fault okay so so

00:38:37,160 --> 00:38:41,300
there are two things one is the justices

00:38:39,200 --> 00:38:44,270
color phaser which anybody can run

00:38:41,300 --> 00:38:45,920
locally it can use Sequoia moment

00:38:44,270 --> 00:38:48,830
virtual machines and then you can give

00:38:45,920 --> 00:38:51,710
it any color now and yeah do so

00:38:48,830 --> 00:38:55,099
regarding sis bot we have some fixed set

00:38:51,710 --> 00:38:59,660
of configurations and potentially we can

00:38:55,099 --> 00:39:01,880
add new ones so yeah doc it was well

00:38:59,660 --> 00:39:04,430
colonel configs yes so our partner

00:39:01,880 --> 00:39:06,890
already came up because it's so C used

00:39:04,430 --> 00:39:10,310
in some of our internal kernels it's

00:39:06,890 --> 00:39:12,200
kind of important to us too so yeah if

00:39:10,310 --> 00:39:16,839
you will find me and send me an email

00:39:12,200 --> 00:39:16,839
then we can discuss this right thank you

00:39:17,080 --> 00:39:23,780
so as a developer when something shows

00:39:20,150 --> 00:39:26,839
up in my mailbox or on the L KML that is

00:39:23,780 --> 00:39:30,290
clearly in my code what's the best thing

00:39:26,839 --> 00:39:31,880
I can do to communicate back to you that

00:39:30,290 --> 00:39:33,170
we've actually done something with it or

00:39:31,880 --> 00:39:36,859
that we're not going to do something

00:39:33,170 --> 00:39:38,599
with it or any kind of interaction that

00:39:36,859 --> 00:39:41,030
we might have because there there are

00:39:38,599 --> 00:39:42,800
several BOTS out there right now they're

00:39:41,030 --> 00:39:45,440
doing wonderful and glorious things for

00:39:42,800 --> 00:39:46,849
us but sometimes the question comes up

00:39:45,440 --> 00:39:51,710
is gosh

00:39:46,849 --> 00:39:53,690
I fixed the code now what do I do so

00:39:51,710 --> 00:39:55,730
with each email there is a kind of link

00:39:53,690 --> 00:39:58,250
for more information and there you can

00:39:55,730 --> 00:40:01,250
find the mailing list for for Cisco ler

00:39:58,250 --> 00:40:04,550
where you can reach us and we usually

00:40:01,250 --> 00:40:07,820
Lou kind of subscribe to the reports

00:40:04,550 --> 00:40:09,680
themselves but there are lots of them

00:40:07,820 --> 00:40:12,440
and we can miss something so it's like

00:40:09,680 --> 00:40:15,109
separate proposal for our systems that

00:40:12,440 --> 00:40:16,180
is better to send it to the I'll release

00:40:15,109 --> 00:40:18,910
it Cisco

00:40:16,180 --> 00:40:21,540
at Google Groups calm do you can find

00:40:18,910 --> 00:40:21,540
this email

00:40:29,480 --> 00:40:35,970
how largely the testing infrastructure

00:40:31,890 --> 00:40:37,470
in sis but sorry Kari how large is the

00:40:35,970 --> 00:40:40,050
testing infrastructure instance about

00:40:37,470 --> 00:40:42,210
how many scholars are running how many

00:40:40,050 --> 00:40:46,010
pixel devices because you mentioned that

00:40:42,210 --> 00:40:49,410
you ran also on devices right devices

00:40:46,010 --> 00:40:52,050
but doesn't run a device doesn't know so

00:40:49,410 --> 00:40:53,970
the Cisco or phaser itself supports

00:40:52,050 --> 00:40:56,640
several types of machine in particular

00:40:53,970 --> 00:41:00,570
Android phones and all the Droid boards

00:40:56,640 --> 00:41:05,040
and it kind of can be extended if like

00:41:00,570 --> 00:41:08,040
if you want to so we totally run on GC

00:41:05,040 --> 00:41:10,530
in the cloud on virtual machines only

00:41:08,040 --> 00:41:14,370
for the Cisco versus boat infrastructure

00:41:10,530 --> 00:41:17,250
and for the Linux for the upstream Linux

00:41:14,370 --> 00:41:21,050
kernel we'll have maybe 15 to core

00:41:17,250 --> 00:41:21,050
machines something like this

00:41:29,470 --> 00:41:32,550
any more questions

00:41:43,930 --> 00:41:46,930
this is a bit more of a nitch question

00:41:46,000 --> 00:41:48,730
but I thought you were talking about

00:41:46,930 --> 00:41:50,200
canned messages could you elaborate a

00:41:48,730 --> 00:41:52,810
little more on what that's looking for

00:41:50,200 --> 00:41:54,370
now can you repeat please with this this

00:41:52,810 --> 00:41:58,990
pot you say that one of the things to

00:41:54,370 --> 00:42:01,120
add later it B can functionality Ken

00:41:58,990 --> 00:42:06,190
yeah buzzing for canned messages I

00:42:01,120 --> 00:42:10,480
believe I saw that can so currently we

00:42:06,190 --> 00:42:12,880
do something for Ken again I don't know

00:42:10,480 --> 00:42:14,680
exactly what because I have no idea

00:42:12,880 --> 00:42:17,650
where the scan and whether the interface

00:42:14,680 --> 00:42:20,530
is so I talked to Ken main maintainer

00:42:17,650 --> 00:42:22,300
and they they had some initial interest

00:42:20,530 --> 00:42:24,820
in that she look what we're doing and

00:42:22,300 --> 00:42:27,400
where this can be improved and there's

00:42:24,820 --> 00:42:32,110
something for I think actually injection

00:42:27,400 --> 00:42:34,900
the Ken packets I think there was some

00:42:32,110 --> 00:42:37,870
issue maybe didn't work with namespaces

00:42:34,900 --> 00:42:41,170
or something but they never get back to

00:42:37,870 --> 00:42:44,950
us so we have something but I don't know

00:42:41,170 --> 00:42:47,200
what so you can look and we also give

00:42:44,950 --> 00:42:50,950
that for the kernel we give coverage

00:42:47,200 --> 00:42:53,440
report and you can see what parts of the

00:42:50,950 --> 00:42:55,870
say your subsystem we cover and what

00:42:53,440 --> 00:42:58,920
parts we don't cover and you know assess

00:42:55,870 --> 00:42:58,920
how good is it

00:43:04,079 --> 00:43:07,400
okay I think that's it

00:43:08,480 --> 00:43:13,679

YouTube URL: https://www.youtube.com/watch?v=qrBVXxZDVQY


