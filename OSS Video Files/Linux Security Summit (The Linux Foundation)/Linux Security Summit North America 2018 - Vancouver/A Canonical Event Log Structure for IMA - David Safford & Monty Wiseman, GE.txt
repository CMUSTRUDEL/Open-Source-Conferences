Title: A Canonical Event Log Structure for IMA - David Safford & Monty Wiseman, GE
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	A Canonical Event Log Structure for IMA - David Safford & Monty Wiseman, GE

IMA (Integrity Measurement Architecture) provides Linux systems with attestation of runtime components. This presentation will review work in progress to convey attestation information to a verifier in the form of a Canonical Event Log structure. This format will provide cryptographic algorithm agility and sequence numbers. Sequence numbering will enable Event Log list truncation and de-duplication which will optimize storage and transmission. This will allow IMA to bound the size of its internal data structures, including the measurement list and the hash table. This new format will support existing IMA templates while enabling extensible features such as attestation of file metadata. It will also support existing firmware Event Log such as those from UEFI systems. This presentation will demonstrate the current prototype, and discuss integration with an open source verifier.

About David Safford
David Safford is a Senior Principal Engineer at GE's Global Research Center, where he leads research on industrial control system security, across power generation, power distribution, aviation, and health care devices. His current focus is in delivering hardware rooted measurement, appraisal, and attestation to the industrial embedded controller product lines. He has presented at LSS four times in the past on various linux integrity and embedded security topics.

About Monty Wiseman
Monty Wiseman is a Principal Engineer at GE's Global Research Center, where he leads research on industrial control system security, across power generation, power distribution, aviation, and health care devices. His current focus is in TCG Standards in general, and particularly in platform certificates for secure supply chains for industrial controllers.
Captions: 
	00:00:01,700 --> 00:00:06,990
good afternoon I'm Dave Safford from GE

00:00:04,710 --> 00:00:08,880
Monte Wiseman and I will be talking

00:00:06,990 --> 00:00:10,710
about a canonical event log structure

00:00:08,880 --> 00:00:13,290
for IMF it's kind of interesting over

00:00:10,710 --> 00:00:15,420
the past today and yesterday I've heard

00:00:13,290 --> 00:00:17,340
lots of comments about attestation and

00:00:15,420 --> 00:00:21,960
I've heard it described as difficult

00:00:17,340 --> 00:00:24,119
scary and terrifying so perhaps I should

00:00:21,960 --> 00:00:28,920
retitle this as adventures in

00:00:24,119 --> 00:00:32,940
attestation so what are we in doing with

00:00:28,920 --> 00:00:36,090
with this attestation in in General

00:00:32,940 --> 00:00:40,290
Electric so ge makes a lot of critical

00:00:36,090 --> 00:00:43,230
infrastructure transportation renewables

00:00:40,290 --> 00:00:44,520
power generation something like 50

00:00:43,230 --> 00:00:48,170
percent of the electricity in North

00:00:44,520 --> 00:00:53,789
America is generated on GE gas turbines

00:00:48,170 --> 00:00:57,270
gas and oil as energy storage aviation

00:00:53,789 --> 00:00:59,309
jet engines and and these are very very

00:00:57,270 --> 00:01:02,699
large critical infrastructure businesses

00:00:59,309 --> 00:01:05,760
and one of the things that we've been

00:01:02,699 --> 00:01:09,720
doing there's been this very large drive

00:01:05,760 --> 00:01:11,310
a business need to connect these devices

00:01:09,720 --> 00:01:16,009
in these controllers the embedded

00:01:11,310 --> 00:01:20,430
controllers for these into analytics

00:01:16,009 --> 00:01:23,880
type of systems because there's a

00:01:20,430 --> 00:01:28,799
tremendous amount of money that can be

00:01:23,880 --> 00:01:30,180
made by optimizing these systems so we

00:01:28,799 --> 00:01:33,530
have controllers that run everything

00:01:30,180 --> 00:01:38,070
from $35 devices all the way up to

00:01:33,530 --> 00:01:40,350
$35,000 flight control systems and it's

00:01:38,070 --> 00:01:42,780
an imperative for us to combine the

00:01:40,350 --> 00:01:47,430
real-time control system that exists

00:01:42,780 --> 00:01:49,970
with analytics capable edge OS which are

00:01:47,430 --> 00:01:53,399
basically Yocto distribution of Linux

00:01:49,970 --> 00:01:56,070
running containers to do the

00:01:53,399 --> 00:01:59,509
communication with with the cloud do

00:01:56,070 --> 00:02:01,770
sometimes local optimization and

00:01:59,509 --> 00:02:03,030
analytics because there's you know

00:02:01,770 --> 00:02:04,530
tremendous amount of money to be made

00:02:03,030 --> 00:02:06,119
here some of the numbers at the bottom

00:02:04,530 --> 00:02:09,000
we've already been seeing with some of

00:02:06,119 --> 00:02:12,810
our applications 10 percent 5 percent 3

00:02:09,000 --> 00:02:14,010
percent savings 17 percent costs down 1

00:02:12,810 --> 00:02:16,799
percent in a VA

00:02:14,010 --> 00:02:18,299
in these represent tremendous amount of

00:02:16,799 --> 00:02:21,269
money we're talking billions of dollars

00:02:18,299 --> 00:02:22,890
to be saved with with this so this all

00:02:21,269 --> 00:02:24,989
sounds well and good until you start

00:02:22,890 --> 00:02:29,640
thinking about you know the security

00:02:24,989 --> 00:02:30,780
aspects of this I mean so Mike was

00:02:29,640 --> 00:02:34,439
saying that you know attestation

00:02:30,780 --> 00:02:36,090
terrifies him what terrifies me is that

00:02:34,439 --> 00:02:37,560
currently I don't know what software is

00:02:36,090 --> 00:02:39,329
running on these controllers that are

00:02:37,560 --> 00:02:41,430
running these critical infrastructures

00:02:39,329 --> 00:02:45,720
so attestation is a you know critical

00:02:41,430 --> 00:02:47,459
piece of our security architecture to be

00:02:45,720 --> 00:02:50,159
able to answer that question do we know

00:02:47,459 --> 00:02:52,650
what's running on these systems is still

00:02:50,159 --> 00:02:54,720
what we intend it to be or has it been

00:02:52,650 --> 00:02:56,579
compromised and at a station is one

00:02:54,720 --> 00:02:58,709
thing that can really produce us there's

00:02:56,579 --> 00:03:01,620
been part of a multi-year effort that

00:02:58,709 --> 00:03:06,480
we've been been doing to create the

00:03:01,620 --> 00:03:08,069
entire security train of trust working

00:03:06,480 --> 00:03:11,730
all the way from the hardware and that's

00:03:08,069 --> 00:03:15,599
CPU selections the board's putting TPMS

00:03:11,730 --> 00:03:16,950
on the board's firmware we you talked

00:03:15,599 --> 00:03:19,230
about all the different secure boots

00:03:16,950 --> 00:03:21,120
we're looking at all aspects of secure

00:03:19,230 --> 00:03:25,590
boot protected boot to protect the

00:03:21,120 --> 00:03:28,410
actual flash verified boot measured boot

00:03:25,590 --> 00:03:30,269
in the RTM dynamic dynamic route of

00:03:28,410 --> 00:03:31,949
trust for measurement we think all of

00:03:30,269 --> 00:03:35,359
these play an important part in the

00:03:31,949 --> 00:03:38,010
architecture the operating system

00:03:35,359 --> 00:03:40,980
integrity measurement architecture to

00:03:38,010 --> 00:03:42,209
collect measurements and signatures such

00:03:40,980 --> 00:03:44,549
that we can actually do the attestation

00:03:42,209 --> 00:03:46,799
then we've been working on this and this

00:03:44,549 --> 00:03:48,959
year we finally got all of the lower

00:03:46,799 --> 00:03:50,669
layers done and now we've moved up to

00:03:48,959 --> 00:03:54,590
the attestation layer and that's been

00:03:50,669 --> 00:03:57,389
our primary thrust of work this year and

00:03:54,590 --> 00:03:58,440
some of the issues that we're coming up

00:03:57,389 --> 00:04:02,129
with they're things that we would like

00:03:58,440 --> 00:04:04,859
to enhance in attestation three main

00:04:02,129 --> 00:04:06,629
areas first thing is scalability we've

00:04:04,859 --> 00:04:08,970
had some of the issues and some of our

00:04:06,629 --> 00:04:11,250
very small and in surprising even that

00:04:08,970 --> 00:04:14,129
some of our very large controllers were

00:04:11,250 --> 00:04:17,010
the measurement list being kernel memory

00:04:14,129 --> 00:04:19,289
resident you know essentially a over

00:04:17,010 --> 00:04:22,469
long term operation being up you know

00:04:19,289 --> 00:04:23,789
effectively a kernel memory leak can

00:04:22,469 --> 00:04:26,159
actually cause problems and so we're

00:04:23,789 --> 00:04:27,030
looking at some ideas for moving these

00:04:26,159 --> 00:04:29,850
measurement lists

00:04:27,030 --> 00:04:32,910
out of the kernel into user space and

00:04:29,850 --> 00:04:34,650
managing them there and and in some

00:04:32,910 --> 00:04:36,810
sense there's really not a need to keep

00:04:34,650 --> 00:04:39,230
them in the kernel the data itself is

00:04:36,810 --> 00:04:42,780
protected because it's anchored in PCR

00:04:39,230 --> 00:04:45,630
in the TPM so regardless of where it's

00:04:42,780 --> 00:04:49,500
stored we can can the authenticate it

00:04:45,630 --> 00:04:51,600
validate it in a strong way and so

00:04:49,500 --> 00:04:53,820
that's one of our issues second issue is

00:04:51,600 --> 00:04:57,120
completeness if you think about the the

00:04:53,820 --> 00:05:00,780
chart of what's currently there I'ma can

00:04:57,120 --> 00:05:03,600
do local appraisal of data in a file it

00:05:00,780 --> 00:05:06,120
can also do remote at a station of data

00:05:03,600 --> 00:05:09,270
in the file EVM is about local

00:05:06,120 --> 00:05:12,210
protection of the metadata of the file

00:05:09,270 --> 00:05:15,169
and so what we'd like to do is extend

00:05:12,210 --> 00:05:18,150
this to include remote attestation of

00:05:15,169 --> 00:05:20,160
metadata so with our current thing if we

00:05:18,150 --> 00:05:22,020
have remote attestation since the data

00:05:20,160 --> 00:05:24,270
of the file is correct well that's good

00:05:22,020 --> 00:05:25,979
but we also need to know is the security

00:05:24,270 --> 00:05:27,750
label on it still correct is the mode

00:05:25,979 --> 00:05:30,030
still correct is somebody made it set

00:05:27,750 --> 00:05:31,740
UID root has you know these other sorts

00:05:30,030 --> 00:05:34,740
of things we need to have as part of our

00:05:31,740 --> 00:05:37,080
attestation the third aspect is

00:05:34,740 --> 00:05:39,600
standards compliance it's one of the big

00:05:37,080 --> 00:05:41,850
issues on actually fielding you know

00:05:39,600 --> 00:05:45,390
taking them on this massive task of

00:05:41,850 --> 00:05:48,780
fielding client and server attestation

00:05:45,390 --> 00:05:50,340
systems is it gets really hard if

00:05:48,780 --> 00:05:53,190
everybody's doing things a little bit

00:05:50,340 --> 00:05:55,740
differently so standardization is a very

00:05:53,190 --> 00:05:58,320
important part of that and Monty's been

00:05:55,740 --> 00:06:01,140
leading the TCG standardization effort

00:05:58,320 --> 00:06:04,410
there and so between the two of us we're

00:06:01,140 --> 00:06:06,960
trying to yeah actually have a common

00:06:04,410 --> 00:06:11,310
design based on what's called tail veer

00:06:06,960 --> 00:06:13,080
type length value triples and I've been

00:06:11,310 --> 00:06:16,770
actually doing a proof of concept of

00:06:13,080 --> 00:06:19,860
that on top of I'm up to show that you

00:06:16,770 --> 00:06:21,090
know to actually test the design make

00:06:19,860 --> 00:06:24,990
sure that it's it's something that's

00:06:21,090 --> 00:06:27,180
feasible and usable some additional

00:06:24,990 --> 00:06:30,210
bonus things that were looking at here

00:06:27,180 --> 00:06:31,650
sequence numbers for all events so we

00:06:30,210 --> 00:06:34,620
can synchronize it wherever the data

00:06:31,650 --> 00:06:37,710
goes from kernel to user space to the

00:06:34,620 --> 00:06:39,540
attestation server timestamps

00:06:37,710 --> 00:06:41,430
and this is the timestamp not on the

00:06:39,540 --> 00:06:44,729
file but there's a timestamp on when did

00:06:41,430 --> 00:06:47,430
we actually measure the file when did we

00:06:44,729 --> 00:06:49,699
verify it you know was it today or was

00:06:47,430 --> 00:06:52,350
it a year ago

00:06:49,699 --> 00:06:55,680
flexible dynamic test selection included

00:06:52,350 --> 00:06:57,060
fields and some other benefits that if

00:06:55,680 --> 00:06:58,470
we actually move the measurement list

00:06:57,060 --> 00:06:59,940
out of the kernel that actually makes

00:06:58,470 --> 00:07:02,130
some of the other operations like k

00:06:59,940 --> 00:07:04,050
exact easier so this kind of gives an

00:07:02,130 --> 00:07:05,520
overview of some of the different things

00:07:04,050 --> 00:07:08,729
that we're looking at in this

00:07:05,520 --> 00:07:12,539
proof-of-concept work this is very much

00:07:08,729 --> 00:07:15,570
an RFC right now it's both a a standard

00:07:12,539 --> 00:07:19,410
that's in development it's not final the

00:07:15,570 --> 00:07:21,990
code is very early code and so there's a

00:07:19,410 --> 00:07:23,729
very good time if you can can interact

00:07:21,990 --> 00:07:26,910
and give us comments and feedback is

00:07:23,729 --> 00:07:28,530
where you'd like to see it go and with

00:07:26,910 --> 00:07:32,610
that I'm gonna turn over Monte to talk

00:07:28,530 --> 00:07:34,830
about the standardization effort thank

00:07:32,610 --> 00:07:37,320
you I want to reiterate somewhere we

00:07:34,830 --> 00:07:39,210
lost the disclaimer that this is a draft

00:07:37,320 --> 00:07:42,419
specification of again give an approval

00:07:39,210 --> 00:07:44,940
by TCG to present it because it's still

00:07:42,419 --> 00:07:46,979
work in progress but we think after

00:07:44,940 --> 00:07:49,229
several months of kind of boiling this

00:07:46,979 --> 00:07:51,180
down this is the format that we would

00:07:49,229 --> 00:07:53,370
like to to go with and as David said we

00:07:51,180 --> 00:07:55,349
had a real problem because today we have

00:07:53,370 --> 00:07:57,479
PC measurements piece of client

00:07:55,349 --> 00:08:00,690
measurements or server measurements of

00:07:57,479 --> 00:08:03,150
firmware but we also have measurements

00:08:00,690 --> 00:08:06,720
from i'muh we want to be able to convey

00:08:03,150 --> 00:08:07,860
these out to a verifier if you think

00:08:06,720 --> 00:08:10,500
about it what's the point of all this

00:08:07,860 --> 00:08:11,940
attestation if you just don't do

00:08:10,500 --> 00:08:14,490
anything whether to goes to the verifier

00:08:11,940 --> 00:08:16,080
and the verifier wants to look at a

00:08:14,490 --> 00:08:18,210
compare it against all the measurements

00:08:16,080 --> 00:08:20,550
for example and make make some sort of

00:08:18,210 --> 00:08:22,050
trust decision so we sort of looking at

00:08:20,550 --> 00:08:24,570
this and thinking well we've got these

00:08:22,050 --> 00:08:27,150
PC client they were defined back in 2001

00:08:24,570 --> 00:08:30,389
both structures with Anna structures how

00:08:27,150 --> 00:08:32,640
do we encapsulate all of that right so

00:08:30,389 --> 00:08:35,669
what so what we've done here is we've

00:08:32,640 --> 00:08:38,250
created basically describe it is kind of

00:08:35,669 --> 00:08:40,260
an encapsulation and one would be able

00:08:38,250 --> 00:08:44,790
to put different sets of things in here

00:08:40,260 --> 00:08:48,060
as I'll describe in just a second

00:08:44,790 --> 00:08:51,390
so the overall format here is you

00:08:48,060 --> 00:08:54,270
scene is there's four fields inside of

00:08:51,390 --> 00:08:57,210
each record and each field itself is a

00:08:54,270 --> 00:09:00,990
TLD so we're starting off with a record

00:08:57,210 --> 00:09:03,779
number and and this solves the problem

00:09:00,990 --> 00:09:06,150
that that David articulated with you

00:09:03,779 --> 00:09:08,880
know if you go pull this stuff out of a

00:09:06,150 --> 00:09:10,320
viola for example how do you know what

00:09:08,880 --> 00:09:11,910
sequence the sequence is incredibly

00:09:10,320 --> 00:09:15,180
important because that's how you verify

00:09:11,910 --> 00:09:17,640
it in PCR 10 the same applies for the PC

00:09:15,180 --> 00:09:19,680
client how the PC client works is if you

00:09:17,640 --> 00:09:22,710
if you ever looked at the PC clients

00:09:19,680 --> 00:09:24,810
back in Howard how it keeps track of the

00:09:22,710 --> 00:09:27,029
measurements the requirement is there's

00:09:24,810 --> 00:09:28,950
simply sequential in memory and that's

00:09:27,029 --> 00:09:30,870
how you that's what we maintain them

00:09:28,950 --> 00:09:33,360
because nobody wanted to consume the

00:09:30,870 --> 00:09:35,190
extra space to put a sequence number in

00:09:33,360 --> 00:09:37,350
it because the assumption is when you go

00:09:35,190 --> 00:09:39,839
get it out they are by definition or by

00:09:37,350 --> 00:09:42,210
the requirement in sequence but when you

00:09:39,839 --> 00:09:43,980
go sticking this thing on a wire for

00:09:42,210 --> 00:09:45,720
example you start sticking this thing a

00:09:43,980 --> 00:09:47,279
database you're really gonna want a

00:09:45,720 --> 00:09:50,040
record number the other reason for the

00:09:47,279 --> 00:09:51,600
record number is you might maybe this

00:09:50,040 --> 00:09:54,060
the server's connected for a little

00:09:51,600 --> 00:09:57,480
while and then it connects and you want

00:09:54,060 --> 00:09:59,460
to ship off you know 10,000 records or

00:09:57,480 --> 00:10:01,920
whatever it is you want to know where to

00:09:59,460 --> 00:10:03,660
start whether those gets reconnected

00:10:01,920 --> 00:10:06,030
again you want to be able to put all of

00:10:03,660 --> 00:10:07,680
these pieces back together again so we

00:10:06,030 --> 00:10:12,360
decided the very first thing we wanted

00:10:07,680 --> 00:10:16,589
to add into this wrapper Tenedos wrapper

00:10:12,360 --> 00:10:20,670
thing is a record number and so again

00:10:16,589 --> 00:10:23,640
within each one of these fields is a tag

00:10:20,670 --> 00:10:25,470
and right now my position right now is

00:10:23,640 --> 00:10:27,480
this is an octet and eight deaths

00:10:25,470 --> 00:10:29,400
because we're gonna try to be very very

00:10:27,480 --> 00:10:31,350
stingy about how we allocate these

00:10:29,400 --> 00:10:33,060
things and I'll describe that I think

00:10:31,350 --> 00:10:35,100
there's a very very few of them that we

00:10:33,060 --> 00:10:36,930
need to create followed by a length

00:10:35,100 --> 00:10:39,300
obviously and then followed by a value

00:10:36,930 --> 00:10:42,839
right in this case the record number

00:10:39,300 --> 00:10:45,779
would simply be au nth of the the

00:10:42,839 --> 00:10:47,910
sequence number the second field is the

00:10:45,779 --> 00:10:49,800
PCR they got measured in two right and

00:10:47,910 --> 00:10:52,350
one would argue that this is kind of an

00:10:49,800 --> 00:10:54,600
overkill there are too many PC ours but

00:10:52,350 --> 00:10:57,240
we wanted to keep the TLV across all

00:10:54,600 --> 00:10:59,940
fields consistent I mean we really could

00:10:57,240 --> 00:11:01,160
have just put au in 32 in there but we

00:10:59,940 --> 00:11:03,170
wanted to do and

00:11:01,160 --> 00:11:04,819
we debated the back and forth is we

00:11:03,170 --> 00:11:06,769
wanted to make the parsers one day a

00:11:04,819 --> 00:11:08,720
very consistent for the parsers as our

00:11:06,769 --> 00:11:11,000
walking through this so every one of

00:11:08,720 --> 00:11:13,129
these fields is a TLB even though you

00:11:11,000 --> 00:11:15,649
technically don't need it to be that way

00:11:13,129 --> 00:11:17,990
for a PC are those not that many of them

00:11:15,649 --> 00:11:21,589
not even that many possible in the TCG

00:11:17,990 --> 00:11:23,420
spec but it's a TLV regardless followed

00:11:21,589 --> 00:11:25,459
by a digest and I've got another slide

00:11:23,420 --> 00:11:27,949
that will walk through exactly how the

00:11:25,459 --> 00:11:30,560
digest works and followed by the actual

00:11:27,949 --> 00:11:33,170
event content so what we will do we

00:11:30,560 --> 00:11:36,050
being TCG at this point we will define

00:11:33,170 --> 00:11:40,670
this layer as architectural TCG will

00:11:36,050 --> 00:11:41,959
define this layer of tags for each one

00:11:40,670 --> 00:11:43,879
of these fields and that's going to be

00:11:41,959 --> 00:11:46,189
the distinction between TCG

00:11:43,879 --> 00:11:48,379
architectural defined as I just

00:11:46,189 --> 00:11:52,310
arbitrarily call it down here C el4

00:11:48,379 --> 00:11:55,670
canonical event log TCG will define what

00:11:52,310 --> 00:11:57,649
those are and so this is a breakdown of

00:11:55,670 --> 00:12:00,769
them for right now we decided to start

00:11:57,649 --> 00:12:02,750
with zero anyway but it's also really

00:12:00,769 --> 00:12:04,550
convenient that every record starts with

00:12:02,750 --> 00:12:06,290
the value zero so you'd be able to

00:12:04,550 --> 00:12:08,300
actually for debugging this it might be

00:12:06,290 --> 00:12:10,279
easy to go distinguish between the

00:12:08,300 --> 00:12:15,920
records and then we'll all locate a tag

00:12:10,279 --> 00:12:18,589
of one for PCR two for this field is the

00:12:15,920 --> 00:12:21,439
TCG digests and I'll get into why I put

00:12:18,589 --> 00:12:24,800
TCG digest in front of that and then

00:12:21,439 --> 00:12:27,560
free on to the end will be defining

00:12:24,800 --> 00:12:29,600
content type and in the table below I'm

00:12:27,560 --> 00:12:31,970
describing some of the content types one

00:12:29,600 --> 00:12:35,779
is context management I'll get into that

00:12:31,970 --> 00:12:39,139
in a later slide but four and five for

00:12:35,779 --> 00:12:40,790
example will encapsulate the firmware so

00:12:39,139 --> 00:12:42,920
the stuff that comes out of the PC

00:12:40,790 --> 00:12:48,649
clients backer comes out of the firmware

00:12:42,920 --> 00:12:50,750
PC are TCG PCR event to structure for

00:12:48,649 --> 00:12:53,300
example that's where the content would

00:12:50,750 --> 00:12:55,910
be so I've defined two different types I

00:12:53,300 --> 00:12:58,459
don't have slides on those because I we

00:12:55,910 --> 00:13:01,519
want to have save time to focus on right

00:12:58,459 --> 00:13:03,920
now and then I've allocated six for

00:13:01,519 --> 00:13:05,360
Aiman and these numbers are kind of just

00:13:03,920 --> 00:13:07,670
made-up numbers for now because the

00:13:05,360 --> 00:13:10,309
specs still in trance still in

00:13:07,670 --> 00:13:12,259
development but a content type for I'm a

00:13:10,309 --> 00:13:12,910
legacy widget the army we all know and

00:13:12,259 --> 00:13:16,000
love today

00:13:12,910 --> 00:13:19,090
and then we're proposing and David's got

00:13:16,000 --> 00:13:21,820
some code for a new format for i'ma

00:13:19,090 --> 00:13:23,470
which we're calling I'm the TOB so each

00:13:21,820 --> 00:13:25,240
one of these would describe just go back

00:13:23,470 --> 00:13:27,460
for a second each one of these would

00:13:25,240 --> 00:13:31,660
describe the event content on the very

00:13:27,460 --> 00:13:34,660
very right-hand side so let me get into

00:13:31,660 --> 00:13:37,450
how the digest works now I don't know if

00:13:34,660 --> 00:13:40,090
anyone's familiar but the TPM two is at

00:13:37,450 --> 00:13:43,900
what's called algorithm agile so you

00:13:40,090 --> 00:13:46,450
don't just have a single Bank of PCR SPC

00:13:43,900 --> 00:13:49,150
errors are actually a two-dimensional

00:13:46,450 --> 00:13:52,300
array if you will so every PCR number

00:13:49,150 --> 00:13:57,580
can actually be associated with multiple

00:13:52,300 --> 00:14:02,020
Shaw or hashed types so PCR one might

00:13:57,580 --> 00:14:04,870
have a sha-1 bank and it might also have

00:14:02,020 --> 00:14:07,420
a shot 256 Bank it might have a shot

00:14:04,870 --> 00:14:10,570
free bank it might even have a saw or an

00:14:07,420 --> 00:14:12,240
sm-3 bank which is we've allocated one

00:14:10,570 --> 00:14:16,180
for the the training set of algorithms

00:14:12,240 --> 00:14:17,920
so when you address any PCR depending on

00:14:16,180 --> 00:14:20,200
how the bios the the owner of the

00:14:17,920 --> 00:14:23,410
machine has provision the machine you

00:14:20,200 --> 00:14:26,530
might likely have one or more banks of

00:14:23,410 --> 00:14:29,560
PCR s associated with one particular PCR

00:14:26,530 --> 00:14:33,790
index so what we've done is we've

00:14:29,560 --> 00:14:35,890
accommodated that inside here because

00:14:33,790 --> 00:14:39,700
what you're what you do and you create a

00:14:35,890 --> 00:14:42,490
an extend operation and in TPM two you

00:14:39,700 --> 00:14:44,470
will actually hand it a hash value for

00:14:42,490 --> 00:14:47,200
each one of the banks that you want to

00:14:44,470 --> 00:14:49,960
extend so we're reflecting that here

00:14:47,200 --> 00:14:52,030
inside the digest field so there's a TCG

00:14:49,960 --> 00:14:54,310
digest saying okay this contains an

00:14:52,030 --> 00:14:57,100
array of digests and there's a length of

00:14:54,310 --> 00:15:00,370
the whole thing and you would so if your

00:14:57,100 --> 00:15:01,480
P TPM was allocated with two banks sha-1

00:15:00,370 --> 00:15:04,570
and sha-256

00:15:01,480 --> 00:15:08,340
you would put a sha-1 hash in there and

00:15:04,570 --> 00:15:11,260
a sha-256 the digest ID is the digest ID

00:15:08,340 --> 00:15:14,890
and this is the reason I call it TCG

00:15:11,260 --> 00:15:18,220
digest is these digest IDs are taken

00:15:14,890 --> 00:15:20,800
from the TCG algorithm ID so if you go

00:15:18,220 --> 00:15:22,839
download the algorithm ID it has a bunch

00:15:20,800 --> 00:15:27,240
of enumerated values identifying shot

00:15:22,839 --> 00:15:27,240
wine sha-256 sm-3 for example

00:15:29,170 --> 00:15:35,140
lastly then is the content-type we will

00:15:32,740 --> 00:15:38,110
again tzg will define this high-level

00:15:35,140 --> 00:15:41,860
content type and right now we've got a

00:15:38,110 --> 00:15:44,980
couple that i numerated before but the

00:15:41,860 --> 00:15:47,140
important thing to say is once once

00:15:44,980 --> 00:15:50,020
you're inside the V portion the data

00:15:47,140 --> 00:15:52,630
portion of this content type how its

00:15:50,020 --> 00:15:55,330
defined inside that is entirely up to

00:15:52,630 --> 00:15:57,400
the content owner for example the PC

00:15:55,330 --> 00:15:59,560
client ones I'm actually giving over the

00:15:57,400 --> 00:16:01,180
TPC client ones I've allocated I'm

00:15:59,560 --> 00:16:03,820
giving it over to the PC client group

00:16:01,180 --> 00:16:07,150
and so you guys define how you want your

00:16:03,820 --> 00:16:10,030
event log to be transported inside this

00:16:07,150 --> 00:16:10,660
and for all right we've got one set up

00:16:10,030 --> 00:16:12,900
for ina

00:16:10,660 --> 00:16:16,810
legacy which I'll describe I'm a Tod

00:16:12,900 --> 00:16:21,100
those will define exactly how the their

00:16:16,810 --> 00:16:22,900
set of data and their algorithms will be

00:16:21,100 --> 00:16:25,840
expressed inside this content type

00:16:22,900 --> 00:16:26,980
there's a minor typo I had 82 8f and

00:16:25,840 --> 00:16:29,560
that's one I thought it said the ever

00:16:26,980 --> 00:16:35,740
did but that wasn't actually intended to

00:16:29,560 --> 00:16:37,570
be oh three through FF and and so kinda

00:16:35,740 --> 00:16:39,880
to wrap this up in in the ideal world

00:16:37,570 --> 00:16:42,850
with new sets of content type going

00:16:39,880 --> 00:16:44,860
forward all you would really do when you

00:16:42,850 --> 00:16:47,410
want to create the value that's going to

00:16:44,860 --> 00:16:49,780
be extended into the TPM is you would

00:16:47,410 --> 00:16:52,630
simply hash the entire content field and

00:16:49,780 --> 00:16:54,550
then you would put that into you know

00:16:52,630 --> 00:16:57,070
you would extend that into the TPM I

00:16:54,550 --> 00:16:58,390
think this slides up now so what you

00:16:57,070 --> 00:17:00,160
would do is you would stick that into

00:16:58,390 --> 00:17:04,180
the V value and then you would extend

00:17:00,160 --> 00:17:06,850
that that exact same value into the TPM

00:17:04,180 --> 00:17:09,850
so the value in those V is the exact

00:17:06,850 --> 00:17:15,040
same value that you you pass to the TPM

00:17:09,850 --> 00:17:18,250
extend operation itself so let me touch

00:17:15,040 --> 00:17:19,449
on a couple of the CEO management David

00:17:18,250 --> 00:17:20,680
talked about a little bit we thought

00:17:19,449 --> 00:17:23,110
there might be some pretty interesting

00:17:20,680 --> 00:17:24,670
things unfortunately we lost some of the

00:17:23,110 --> 00:17:27,550
bullets so this was actually a little

00:17:24,670 --> 00:17:29,500
maybe a little difficult to read but we

00:17:27,550 --> 00:17:32,440
thought it would be interesting to or a

00:17:29,500 --> 00:17:36,300
good idea to provide maybe some metadata

00:17:32,440 --> 00:17:38,880
around the event log itself for example

00:17:36,300 --> 00:17:40,740
as David mentioned a time stamp so you

00:17:38,880 --> 00:17:42,810
got a bunch of events that happen and

00:17:40,740 --> 00:17:45,360
I'm a for example or maybe the

00:17:42,810 --> 00:17:46,830
transition between the firmware and the

00:17:45,360 --> 00:17:48,660
first time a measurement you might want

00:17:46,830 --> 00:17:50,490
to know exactly what time that is what

00:17:48,660 --> 00:17:53,760
time that happened so you'd be able to

00:17:50,490 --> 00:17:57,510
put a timestamp CEO management event

00:17:53,760 --> 00:17:59,760
right right it's a particular point so

00:17:57,510 --> 00:18:03,480
and there's other concepts of like easy

00:17:59,760 --> 00:18:05,100
separators and and we're deciding we

00:18:03,480 --> 00:18:06,810
think all of them are security sensitive

00:18:05,100 --> 00:18:10,110
but there might be some that are

00:18:06,810 --> 00:18:11,580
informative for example what version

00:18:10,110 --> 00:18:14,550
number no actually I think it's on the

00:18:11,580 --> 00:18:17,370
next slide I give kind of an example of

00:18:14,550 --> 00:18:19,350
you know what the stream of these TVs

00:18:17,370 --> 00:18:21,090
would look like one of the things would

00:18:19,350 --> 00:18:23,010
be I think it's a good idea to first

00:18:21,090 --> 00:18:26,700
send off maybe there's a version Assoc

00:18:23,010 --> 00:18:29,460
we read this so we create a management

00:18:26,700 --> 00:18:31,560
type that simply says this is the

00:18:29,460 --> 00:18:34,890
version of the spec this particular

00:18:31,560 --> 00:18:36,420
stream this this machine is built-in so

00:18:34,890 --> 00:18:38,850
we'd probably start with something like

00:18:36,420 --> 00:18:41,100
that then they would be obviously an

00:18:38,850 --> 00:18:43,710
array of PC client measurements that

00:18:41,100 --> 00:18:45,690
came out of the firm or before that OS

00:18:43,710 --> 00:18:47,070
even started then you might have

00:18:45,690 --> 00:18:48,540
something like you need you separate

00:18:47,070 --> 00:18:51,510
okay the firmware is ending at this

00:18:48,540 --> 00:18:55,470
point we are now starting with the set

00:18:51,510 --> 00:18:57,780
of event logs and then I thought well we

00:18:55,470 --> 00:19:00,510
probably need something for systems that

00:18:57,780 --> 00:19:02,310
go into sleep or hibernate right these

00:19:00,510 --> 00:19:03,990
things go into a suspended state and

00:19:02,310 --> 00:19:06,300
they actually somewhat change the

00:19:03,990 --> 00:19:08,940
security properties it would be a good

00:19:06,300 --> 00:19:11,730
idea to have a measurement of as the

00:19:08,940 --> 00:19:13,980
machines going into sleep or coming out

00:19:11,730 --> 00:19:16,050
of sleep that we would be able to log

00:19:13,980 --> 00:19:18,540
that as well so these are an example of

00:19:16,050 --> 00:19:21,360
the kind of things we can do with a with

00:19:18,540 --> 00:19:23,180
the measurement so let me just walk

00:19:21,360 --> 00:19:25,890
through the workflow a little bit and

00:19:23,180 --> 00:19:27,480
the workflows really starting from the

00:19:25,890 --> 00:19:30,810
bottom let's start start from the bottom

00:19:27,480 --> 00:19:32,570
is obviously that we don't want either

00:19:30,810 --> 00:19:35,220
because you know the first thing when I

00:19:32,570 --> 00:19:39,750
kind of shop this around the rest of the

00:19:35,220 --> 00:19:41,100
TCG working group all of the the PCO and

00:19:39,750 --> 00:19:43,260
then there's panic you're gonna make me

00:19:41,100 --> 00:19:45,180
change my firmware no we're not going to

00:19:43,260 --> 00:19:47,280
make you change your firmware so what

00:19:45,180 --> 00:19:48,190
we're gonna do is obviously they've got

00:19:47,280 --> 00:19:50,740
their OTC

00:19:48,190 --> 00:19:53,379
PC our event structure don't change it

00:19:50,740 --> 00:19:55,450
there's going to be a utility and I'm

00:19:53,379 --> 00:19:58,779
going to work on that actually utility

00:19:55,450 --> 00:20:00,309
to convert it into this new format when

00:19:58,779 --> 00:20:03,549
it needs to be transported off the

00:20:00,309 --> 00:20:05,710
machine so we would be able to map the

00:20:03,549 --> 00:20:08,740
existing stuff into this new canonical

00:20:05,710 --> 00:20:10,840
event format the same thing going up one

00:20:08,740 --> 00:20:11,350
more level if you've got the existing

00:20:10,840 --> 00:20:13,059
i'muh

00:20:11,350 --> 00:20:15,250
you might not want to change a server

00:20:13,059 --> 00:20:17,100
but you do need to transport this

00:20:15,250 --> 00:20:19,929
information you want it to go to a

00:20:17,100 --> 00:20:22,570
verifier that understands this so we

00:20:19,929 --> 00:20:24,940
would write a utility for that if you

00:20:22,570 --> 00:20:26,320
were to have a new module like David is

00:20:24,940 --> 00:20:28,809
going to talk about in a few minutes

00:20:26,320 --> 00:20:30,700
where the kernel itself produces these

00:20:28,809 --> 00:20:32,289
TOB records there would be no

00:20:30,700 --> 00:20:36,340
translation at all it would just trash

00:20:32,289 --> 00:20:40,090
will just transfer directly so let me

00:20:36,340 --> 00:20:43,990
show you an example of our proposal for

00:20:40,090 --> 00:20:45,700
a new way to represent I'm an integrity

00:20:43,990 --> 00:20:49,389
measurements that that's very expandable

00:20:45,700 --> 00:20:50,889
all right so we would you know basically

00:20:49,389 --> 00:20:54,100
inside this content you can actually

00:20:50,889 --> 00:20:56,320
have an array of TVs representing that

00:20:54,100 --> 00:20:58,659
particular module might be mod might be

00:20:56,320 --> 00:21:02,019
path might be the actual hash of the

00:20:58,659 --> 00:21:04,509
hash of the data whatever actually David

00:21:02,019 --> 00:21:07,870
David anemia will actually end up owning

00:21:04,509 --> 00:21:10,389
this and defining these sort you know

00:21:07,870 --> 00:21:11,980
what sort of thing goes in here and and

00:21:10,389 --> 00:21:15,820
you can actually have an array of these

00:21:11,980 --> 00:21:19,269
things and so if and and even within

00:21:15,820 --> 00:21:23,110
them I we've architected in the ability

00:21:19,269 --> 00:21:25,840
to be hash agile within the IMS

00:21:23,110 --> 00:21:28,330
structure itself so for example if you

00:21:25,840 --> 00:21:31,450
wanted to at the same time create a

00:21:28,330 --> 00:21:33,340
sha-1 hash of a file because the server

00:21:31,450 --> 00:21:36,399
you're going to send this information to

00:21:33,340 --> 00:21:39,070
one shot one because it's legacy and at

00:21:36,399 --> 00:21:40,899
the same time you produce a sha-256

00:21:39,070 --> 00:21:43,419
you'd be able to just simply append

00:21:40,899 --> 00:21:46,179
these just like up on the digest field

00:21:43,419 --> 00:21:48,789
right and then you this would just be

00:21:46,179 --> 00:21:51,519
part of that that content type record

00:21:48,789 --> 00:21:53,830
and then what you would do when you get

00:21:51,519 --> 00:21:55,929
done with all of your measurement of the

00:21:53,830 --> 00:21:58,720
of the file of the data whatever your

00:21:55,929 --> 00:22:00,340
you're doing is you would hash these and

00:21:58,720 --> 00:22:01,110
what I'm depicting here is the actual

00:22:00,340 --> 00:22:04,049
structure

00:22:01,110 --> 00:22:06,960
that's sent into the TPM it's called a

00:22:04,049 --> 00:22:09,090
TPM l digest value you would create a

00:22:06,960 --> 00:22:11,580
for example a hash one this would be the

00:22:09,090 --> 00:22:13,950
example of a sha-1 or hash two and that

00:22:11,580 --> 00:22:15,360
would be the example of sha-256 you

00:22:13,950 --> 00:22:17,399
would put those in there and do the

00:22:15,360 --> 00:22:20,009
extend operation and then you would

00:22:17,399 --> 00:22:22,019
simply copy them up into this digest

00:22:20,009 --> 00:22:26,779
field and now the whole record would be

00:22:22,019 --> 00:22:31,200
complete so that was actually a lot

00:22:26,779 --> 00:22:36,720
before I go on to the example of legacy

00:22:31,200 --> 00:22:41,129
imma do have any questions or did I

00:22:36,720 --> 00:22:42,690
completely lose everybody okay so for

00:22:41,129 --> 00:22:43,139
example I am how do we deal with I'm a

00:22:42,690 --> 00:22:46,049
legacy

00:22:43,139 --> 00:22:48,539
so we decided to as an experiment and I

00:22:46,049 --> 00:22:50,700
would again that's a utility that I

00:22:48,539 --> 00:22:52,470
would like to write is you know you've

00:22:50,700 --> 00:22:56,220
got these templates that are depicted on

00:22:52,470 --> 00:22:58,320
the left hand side how do we how do we

00:22:56,220 --> 00:23:01,230
represent that so again on the right

00:22:58,320 --> 00:23:05,249
side there's a concept of you know I'm a

00:23:01,230 --> 00:23:07,859
tag content L and then tag value and

00:23:05,249 --> 00:23:10,289
I've got these various templates and so

00:23:07,859 --> 00:23:12,840
this would be an example of what we

00:23:10,289 --> 00:23:14,820
would do and this is an exception to

00:23:12,840 --> 00:23:17,159
when I said you would hash the entire

00:23:14,820 --> 00:23:19,440
content because the current I am it

00:23:17,159 --> 00:23:22,679
doesn't have that concept today so what

00:23:19,440 --> 00:23:26,340
we would do is simply take the if you're

00:23:22,679 --> 00:23:28,019
doing the template D for example which

00:23:26,340 --> 00:23:30,720
we do simply take a hash of the file

00:23:28,019 --> 00:23:32,999
content making TOB record out of that

00:23:30,720 --> 00:23:33,809
you put the the fact that this is I'm

00:23:32,999 --> 00:23:36,450
sorry it's a time--as

00:23:33,809 --> 00:23:38,879
it's an I'm a template and so that would

00:23:36,450 --> 00:23:41,549
be identified here the the D field

00:23:38,879 --> 00:23:44,489
represents the hash of the file content

00:23:41,549 --> 00:23:46,679
the end represents the how they actually

00:23:44,489 --> 00:23:48,450
the file name the string of the file

00:23:46,679 --> 00:23:51,450
name and what i'm alexi does is you

00:23:48,450 --> 00:23:54,929
concatenate those and hash them and then

00:23:51,450 --> 00:23:56,940
take that and extend it so in this case

00:23:54,929 --> 00:24:00,299
you would hatch these two together just

00:23:56,940 --> 00:24:02,789
like I'm a does today put that into the

00:24:00,299 --> 00:24:04,830
V field and then you would think I was

00:24:02,789 --> 00:24:07,080
like no that's the end all right then at

00:24:04,830 --> 00:24:10,230
that point you would extend that into

00:24:07,080 --> 00:24:11,120
the TPM or that was extended in the T

00:24:10,230 --> 00:24:12,320
because it

00:24:11,120 --> 00:24:14,210
it already happened that's right on the

00:24:12,320 --> 00:24:16,430
slide on it so this is how you would

00:24:14,210 --> 00:24:19,940
write this utility because you would

00:24:16,430 --> 00:24:21,950
have to as you read the security FS I'm

00:24:19,940 --> 00:24:24,680
a security FS and read this information

00:24:21,950 --> 00:24:27,170
this is how you would translate that so

00:24:24,680 --> 00:24:30,190
that the other end someone would be able

00:24:27,170 --> 00:24:32,450
to use this standard format be able to

00:24:30,190 --> 00:24:33,370
redo the calculations and they would

00:24:32,450 --> 00:24:39,520
just match

00:24:33,370 --> 00:24:39,520
so anyway any questions on the overall

00:24:40,450 --> 00:24:48,260
so the actual deck is about 45 slides so

00:24:46,640 --> 00:24:51,470
that was a pre that was a that was a

00:24:48,260 --> 00:24:53,150
summary okay I think it was just

00:24:51,470 --> 00:25:01,309
pretending so David has some real-life

00:24:53,150 --> 00:25:04,270
examples oh sorry yes so are you

00:25:01,309 --> 00:25:06,470
worrying about how to export this across

00:25:04,270 --> 00:25:09,020
machine boundaries where you have to

00:25:06,470 --> 00:25:12,830
worry about encoding issues such as byte

00:25:09,020 --> 00:25:15,080
order etc or is that handled somewhere

00:25:12,830 --> 00:25:17,240
else by some other layer yeah so that's

00:25:15,080 --> 00:25:19,870
gonna be handled I've got a colleague

00:25:17,240 --> 00:25:22,610
who's actually working on AC Boer

00:25:19,870 --> 00:25:24,380
implementation so we're gonna be that

00:25:22,610 --> 00:25:26,990
that's the next phase is starting to

00:25:24,380 --> 00:25:29,900
think about those kind of representation

00:25:26,990 --> 00:25:31,880
as it leaves the machine obviously you

00:25:29,900 --> 00:25:33,260
know David's got this nice little S key

00:25:31,880 --> 00:25:34,670
has he dumped but that's not what we're

00:25:33,260 --> 00:25:38,480
gonna send we're actually gonna

00:25:34,670 --> 00:25:40,940
transport this on top of a new protocol

00:25:38,480 --> 00:25:43,429
that's being developed by TCG called pts

00:25:40,940 --> 00:25:46,010
platform services so we're gonna

00:25:43,429 --> 00:25:47,540
transport this on top of that and I

00:25:46,010 --> 00:25:49,790
expect them you know like I said my

00:25:47,540 --> 00:25:52,850
colleagues working on C board today but

00:25:49,790 --> 00:25:55,490
we expect a Jason and a C bore this is

00:25:52,850 --> 00:25:57,770
as much a data representation as it is

00:25:55,490 --> 00:25:59,600
an information model so you could take

00:25:57,770 --> 00:26:02,330
this information model a map at to lots

00:25:59,600 --> 00:26:08,770
of other sorts or formats to transport

00:26:02,330 --> 00:26:08,770
yeah thanks questions okay

00:26:10,730 --> 00:26:17,670
Sofer it's all well and good to have

00:26:15,270 --> 00:26:19,050
slides and a nice design but the proof

00:26:17,670 --> 00:26:22,740
of the pudding is actually writing code

00:26:19,050 --> 00:26:28,190
and see if it actually works so we've

00:26:22,740 --> 00:26:30,510
done a proof-of-concept of this and

00:26:28,190 --> 00:26:35,010
three three aspects of it the first

00:26:30,510 --> 00:26:37,380
thing was while most of the template

00:26:35,010 --> 00:26:39,750
code was nicely isolated and I am a

00:26:37,380 --> 00:26:42,090
template and I'm a template Lib there

00:26:39,750 --> 00:26:44,610
was some aspect of template throughout

00:26:42,090 --> 00:26:46,110
some of the other files and and so the

00:26:44,610 --> 00:26:48,270
first thing was basically just doing a

00:26:46,110 --> 00:26:50,730
refactoring to get all of the template

00:26:48,270 --> 00:26:54,420
things into an additional i'ma FS

00:26:50,730 --> 00:26:56,810
template I'm a cue template and pulling

00:26:54,420 --> 00:26:59,670
off a separate I am a template dot H

00:26:56,810 --> 00:27:01,980
just not changing any functionality just

00:26:59,670 --> 00:27:05,250
you know refactoring it the second part

00:27:01,980 --> 00:27:08,580
then was tried to TLV code and the

00:27:05,250 --> 00:27:10,740
current proof of concept code I think

00:27:08,580 --> 00:27:12,810
demonstrates nicely how simple this can

00:27:10,740 --> 00:27:15,270
be when you do everything in TLV the

00:27:12,810 --> 00:27:18,150
total code is is 480 lines of code

00:27:15,270 --> 00:27:21,330
compared to the 1,700 lines of code in

00:27:18,150 --> 00:27:24,380
the existing template code and total

00:27:21,330 --> 00:27:28,680
about 4,000 lines of code in the basic

00:27:24,380 --> 00:27:31,080
part of aya so it actually it becomes

00:27:28,680 --> 00:27:35,190
very very simple to do this and it's

00:27:31,080 --> 00:27:37,170
kind of compelling the way it currently

00:27:35,190 --> 00:27:40,230
is I'm done it and the proof of concept

00:27:37,170 --> 00:27:42,120
is that it's a cake config option that

00:27:40,230 --> 00:27:45,570
you can select I'm a measurement let's

00:27:42,120 --> 00:27:47,520
format either template or TLV and I've

00:27:45,570 --> 00:27:49,410
done regression tests against that the

00:27:47,520 --> 00:27:51,030
original template version make sure you

00:27:49,410 --> 00:27:55,490
didn't break anything

00:27:51,030 --> 00:27:57,900
and then separately been testing the TLV

00:27:55,490 --> 00:28:00,960
one of the things on how easy it is to

00:27:57,900 --> 00:28:03,120
add a field basically it's only a few

00:28:00,960 --> 00:28:06,840
lines of code to add a new field you

00:28:03,120 --> 00:28:08,460
define a content type once you have a

00:28:06,840 --> 00:28:10,470
content type you have some code that

00:28:08,460 --> 00:28:13,530
figures out how long that field is going

00:28:10,470 --> 00:28:15,060
to be you then have another couple lines

00:28:13,530 --> 00:28:17,280
of code that can actually fill in that

00:28:15,060 --> 00:28:19,140
field and that's it all the rest of the

00:28:17,280 --> 00:28:21,060
the infrastructure handles it for you

00:28:19,140 --> 00:28:21,870
there's a helper functions like I'm a

00:28:21,060 --> 00:28:25,830
TLB buff

00:28:21,870 --> 00:28:28,260
that actually does the serialization in

00:28:25,830 --> 00:28:31,020
handles and unis back the end unis

00:28:28,260 --> 00:28:33,300
question we're following for the I'm

00:28:31,020 --> 00:28:35,340
apart of this the i'ma content we're

00:28:33,300 --> 00:28:36,870
doing you know the canonical format for

00:28:35,340 --> 00:28:39,570
I am which is little-endian and

00:28:36,870 --> 00:28:41,160
everything is converted and I haven't

00:28:39,570 --> 00:28:43,140
had actually a chance to test this on a

00:28:41,160 --> 00:28:44,820
big endian machine but hopefully the

00:28:43,140 --> 00:28:49,800
code would actually work correctly and

00:28:44,820 --> 00:28:52,620
produce the canonical format so what

00:28:49,800 --> 00:28:55,080
does this look like actually running so

00:28:52,620 --> 00:28:57,660
the first thing is that the existing

00:28:55,080 --> 00:28:59,490
binary runtime measurement and a ski run

00:28:57,660 --> 00:29:02,400
time measurements are persistent data

00:28:59,490 --> 00:29:05,040
you can keep doing them in this model

00:29:02,400 --> 00:29:07,770
when you cat the sis kernel security I'm

00:29:05,040 --> 00:29:10,140
at LV runtime measurements it actually

00:29:07,770 --> 00:29:12,470
reads the data one time and deletes it

00:29:10,140 --> 00:29:17,010
out of the kernel so that we you know

00:29:12,470 --> 00:29:19,790
eliminate this the memory leak issue and

00:29:17,010 --> 00:29:22,260
so what you do then is you have

00:29:19,790 --> 00:29:24,780
essentially your utility is gonna take

00:29:22,260 --> 00:29:27,210
it and save it somewhere and this can be

00:29:24,780 --> 00:29:30,540
as simple as just cat and redirect it to

00:29:27,210 --> 00:29:33,000
a file like bin data then you can take

00:29:30,540 --> 00:29:34,620
that binary data and run programs on it

00:29:33,000 --> 00:29:37,710
to do the attestation or to do analysis

00:29:34,620 --> 00:29:41,400
locally now that you preserve the data

00:29:37,710 --> 00:29:43,650
up in user space and this shows an

00:29:41,400 --> 00:29:46,530
example in which they're doing just two

00:29:43,650 --> 00:29:47,700
fields and this is an ASCII dump of the

00:29:46,530 --> 00:29:49,170
binary but what actually gets

00:29:47,700 --> 00:29:52,350
transported is a binary so you have a

00:29:49,170 --> 00:29:55,050
sequence number this was a thirteen

00:29:52,350 --> 00:29:58,170
hundred and sixty fourth entry PCR

00:29:55,050 --> 00:30:01,170
number ten TCG digest which in this case

00:29:58,170 --> 00:30:04,140
is a sha-1 there's the sha-1 and that's

00:30:01,170 --> 00:30:07,080
the digest of the entire record the

00:30:04,140 --> 00:30:09,780
record includes path and so I actually

00:30:07,080 --> 00:30:13,380
had run the TLB dump program the data

00:30:09,780 --> 00:30:16,170
hash for the file is a shot 256 which is

00:30:13,380 --> 00:30:18,900
that value the dump program also does

00:30:16,170 --> 00:30:20,670
verification on the list in this case it

00:30:18,900 --> 00:30:22,080
says the digest matches the content

00:30:20,670 --> 00:30:24,480
which is good so though that means that

00:30:22,080 --> 00:30:26,040
this record has not been this particular

00:30:24,480 --> 00:30:28,860
record has not been tampered with

00:30:26,040 --> 00:30:30,840
and after all the records are analyzed

00:30:28,860 --> 00:30:34,530
and it has been keeping track of what

00:30:30,840 --> 00:30:35,280
the pcr ten value should be after all of

00:30:34,530 --> 00:30:38,100
the extends

00:30:35,280 --> 00:30:41,100
and so it says final PCR value should be

00:30:38,100 --> 00:30:43,890
this and in fact if you do the TPM to

00:30:41,100 --> 00:30:46,050
PCR list you can see that it actually

00:30:43,890 --> 00:30:48,570
comes up with you know valid answers so

00:30:46,050 --> 00:30:50,490
we've been through you know two

00:30:48,570 --> 00:30:53,640
different things one side creating the

00:30:50,490 --> 00:30:54,750
data and another site analyzing it it

00:30:53,640 --> 00:30:56,610
would have been better if two different

00:30:54,750 --> 00:31:01,740
people did that to actually stress test

00:30:56,610 --> 00:31:04,260
the implementation but at least we've

00:31:01,740 --> 00:31:06,990
gotten to the to this this level of

00:31:04,260 --> 00:31:08,880
testing of it so before I go into

00:31:06,990 --> 00:31:10,290
summary let me actually show this

00:31:08,880 --> 00:31:12,840
running so this is actually running on

00:31:10,290 --> 00:31:15,000
my laptop here and I've been doing

00:31:12,840 --> 00:31:17,730
kernel compiles on it and it hasn't

00:31:15,000 --> 00:31:24,750
panicked in at least three days so the

00:31:17,730 --> 00:31:27,570
code must be ready to ship so here's the

00:31:24,750 --> 00:31:29,160
example of taking reading what new thing

00:31:27,570 --> 00:31:32,640
measurements are in the measurement list

00:31:29,160 --> 00:31:35,250
and redirecting them up to a file here

00:31:32,640 --> 00:31:36,810
is running the TLV dump program on that

00:31:35,250 --> 00:31:39,090
I'm just gonna look at the last two

00:31:36,810 --> 00:31:42,480
things this actually shows some of the

00:31:39,090 --> 00:31:44,970
extended fields so again we have

00:31:42,480 --> 00:31:48,630
sequence number PCR number digest for

00:31:44,970 --> 00:31:51,750
the record the data hash for the file

00:31:48,630 --> 00:31:52,650
I mean the filename owner and now

00:31:51,750 --> 00:31:54,480
there's just showing some of the

00:31:52,650 --> 00:31:57,240
metadata fields that we're testing to

00:31:54,480 --> 00:31:59,370
know so this is owners is zero group is

00:31:57,240 --> 00:32:01,800
zero and mode we'll look at this this

00:31:59,370 --> 00:32:03,810
actually turns out to be a set UID

00:32:01,800 --> 00:32:05,820
program so this is some of the sorts of

00:32:03,810 --> 00:32:08,010
things you can see remotely now and get

00:32:05,820 --> 00:32:10,230
visibility into what's running on your

00:32:08,010 --> 00:32:13,830
system so it's not just the data it's

00:32:10,230 --> 00:32:15,600
now metadata about it and I'm sorry I

00:32:13,830 --> 00:32:17,520
didn't show it an example of the of

00:32:15,600 --> 00:32:19,440
including the selinux label but that

00:32:17,520 --> 00:32:22,650
would obviously be the next fun thing

00:32:19,440 --> 00:32:23,700
that we could show there and the digest

00:32:22,650 --> 00:32:26,070
matches the content

00:32:23,700 --> 00:32:34,260
and so drumroll please let's see if this

00:32:26,070 --> 00:32:39,510
actually worked so if we go back and

00:32:34,260 --> 00:32:41,610
look hey okay I get to get paid if you

00:32:39,510 --> 00:32:44,429
see our ten should be a day through EB

00:32:41,610 --> 00:32:46,530
and that is in fact what we see here so

00:32:44,429 --> 00:32:48,220
the measurement list has not been

00:32:46,530 --> 00:32:51,910
tampered with

00:32:48,220 --> 00:32:53,710
and each of the entries are valid in the

00:32:51,910 --> 00:32:55,480
list is valid that's basically what

00:32:53,710 --> 00:32:57,520
happens in the nav station except we add

00:32:55,480 --> 00:32:59,770
the additional step that the TPM signs

00:32:57,520 --> 00:33:04,120
this value and it's a challenge response

00:32:59,770 --> 00:33:06,460
signature from the attestation server to

00:33:04,120 --> 00:33:08,530
prove freshness and then it gets the

00:33:06,460 --> 00:33:10,360
list and invalidates us but that's

00:33:08,530 --> 00:33:11,950
showing the basic functionality so at

00:33:10,360 --> 00:33:17,500
least from a proof of concept

00:33:11,950 --> 00:33:20,340
if I go back to my summary slide so this

00:33:17,500 --> 00:33:22,990
demonstrates a proof of concept level of

00:33:20,340 --> 00:33:25,540
being able to pull the measurement list

00:33:22,990 --> 00:33:27,460
out of the kernel it shows a proof

00:33:25,540 --> 00:33:29,740
concept of being able to attest it to

00:33:27,460 --> 00:33:32,650
the metadata on the file

00:33:29,740 --> 00:33:35,590
it shows how relatively simple is right

00:33:32,650 --> 00:33:37,180
in to parse the measurement list and it

00:33:35,590 --> 00:33:41,110
demonstrates that we've actually done a

00:33:37,180 --> 00:33:42,820
validation of the draft standard so

00:33:41,110 --> 00:33:45,670
that's actually doing a sanity check up

00:33:42,820 --> 00:33:47,740
on the standard itself and so at this

00:33:45,670 --> 00:33:50,950
point like I say this is all draft it's

00:33:47,740 --> 00:33:52,810
all proof of concept level which is a

00:33:50,950 --> 00:33:55,180
perfect time then you know to get some

00:33:52,810 --> 00:33:56,890
feedback on this and we have lots of

00:33:55,180 --> 00:33:59,980
questions you know feel free to kind of

00:33:56,890 --> 00:34:01,810
you know give suggestions and comments

00:33:59,980 --> 00:34:05,890
and all the rest but one of the

00:34:01,810 --> 00:34:09,340
questions is in the current code it's

00:34:05,890 --> 00:34:11,110
either template or TLV you know so you

00:34:09,340 --> 00:34:13,810
can compile the kernel to be backwards

00:34:11,110 --> 00:34:16,690
you know compatible for user space or

00:34:13,810 --> 00:34:18,250
you can select TLV is there a case the

00:34:16,690 --> 00:34:20,590
use case where we might need both I

00:34:18,250 --> 00:34:22,000
can't think of one you know so I didn't

00:34:20,590 --> 00:34:25,780
implement it but maybe that's something

00:34:22,000 --> 00:34:27,879
somebody can think of a use case the

00:34:25,780 --> 00:34:30,970
other memory leak that I took out was

00:34:27,879 --> 00:34:32,590
the in in kernel hash table and me

00:34:30,970 --> 00:34:37,149
already warned me that I shouldn't do

00:34:32,590 --> 00:34:38,679
that but the question is you know if you

00:34:37,149 --> 00:34:40,480
have all the data outside we can

00:34:38,679 --> 00:34:43,389
certainly regenerate a hash table and

00:34:40,480 --> 00:34:46,149
user space is there a need for in kernel

00:34:43,389 --> 00:34:47,889
hash table like it's had before if there

00:34:46,149 --> 00:34:50,350
is I mean it's not hard to add it but

00:34:47,889 --> 00:34:52,419
we're trying this as a proof of concept

00:34:50,350 --> 00:34:57,220
to see you know what at work if we did

00:34:52,419 --> 00:34:58,600
not have the hash table long term is

00:34:57,220 --> 00:35:01,380
that something that in fact we want to

00:34:58,600 --> 00:35:03,269
move forward and deprecated the existing

00:35:01,380 --> 00:35:05,279
template code one of the convenient

00:35:03,269 --> 00:35:08,400
things is that with TLV is is actually

00:35:05,279 --> 00:35:10,079
pretty easy to be to have you know

00:35:08,400 --> 00:35:12,089
forward compatibilities these things

00:35:10,079 --> 00:35:14,279
change because even if you're not

00:35:12,089 --> 00:35:16,950
exactly in sync with the version of the

00:35:14,279 --> 00:35:18,690
sender and receiver the fact that

00:35:16,950 --> 00:35:20,160
everything still be formatted means we

00:35:18,690 --> 00:35:22,349
can still parse it and we may not

00:35:20,160 --> 00:35:24,779
understand all of the fields but we can

00:35:22,349 --> 00:35:26,220
still parse it and and handle the fields

00:35:24,779 --> 00:35:30,619
that we do understand they're both side

00:35:26,220 --> 00:35:33,960
so it makes it easy to to to do upgrades

00:35:30,619 --> 00:35:36,119
other fields are there other aspects of

00:35:33,960 --> 00:35:38,789
data or metadata that would be

00:35:36,119 --> 00:35:42,329
interesting to include that we could you

00:35:38,789 --> 00:35:46,829
know consider a during any and any other

00:35:42,329 --> 00:35:48,420
comments or suggestions on this there's

00:35:46,829 --> 00:35:51,539
still a lot of work obviously to do on

00:35:48,420 --> 00:35:53,460
this in the Standards Committee there's

00:35:51,539 --> 00:35:56,180
obviously a lot of work to do if we

00:35:53,460 --> 00:35:59,490
actually you know want to upstream this

00:35:56,180 --> 00:36:01,619
refactor it clean it up incorporate any

00:35:59,490 --> 00:36:05,430
suggestions you have and work with the

00:36:01,619 --> 00:36:08,970
community to do that so you know feel

00:36:05,430 --> 00:36:11,630
free to give us feedback on this with

00:36:08,970 --> 00:36:11,630
that questions

00:36:14,840 --> 00:36:22,180
I think we stand them in silence

00:36:25,930 --> 00:36:33,050
timestamps I'm sure there are situations

00:36:29,990 --> 00:36:35,120
where you can get decent enough time to

00:36:33,050 --> 00:36:38,810
be sure of timestamps but I'm sure there

00:36:35,120 --> 00:36:40,850
also situations where you can't putting

00:36:38,810 --> 00:36:42,820
it in as an option means that people use

00:36:40,850 --> 00:36:45,770
it in places they absolutely shouldn't

00:36:42,820 --> 00:36:47,240
which is always a danger and also

00:36:45,770 --> 00:36:48,740
there's the problem of you know if

00:36:47,240 --> 00:36:50,960
you're taking from multiple systems and

00:36:48,740 --> 00:36:55,100
doing the remote stuff you need to have

00:36:50,960 --> 00:36:56,810
ways of managing that as just a comment

00:36:55,100 --> 00:37:00,080
to that really I mean obviously having

00:36:56,810 --> 00:37:03,050
the numbering it so you can makes a lot

00:37:00,080 --> 00:37:06,410
of sense but just be wary of the time

00:37:03,050 --> 00:37:08,510
stamping I think absolutely our kind of

00:37:06,410 --> 00:37:10,190
use case for time stamps is we have you

00:37:08,510 --> 00:37:12,950
know we have an embedded controller

00:37:10,190 --> 00:37:16,040
that's been running for a year right you

00:37:12,950 --> 00:37:18,050
know so and and the convenient thing is

00:37:16,040 --> 00:37:19,670
to take the time step you know that's

00:37:18,050 --> 00:37:21,650
there what we're actually taking is just

00:37:19,670 --> 00:37:23,780
the seconds you know from the epochs and

00:37:21,650 --> 00:37:26,930
even that's like you say probably

00:37:23,780 --> 00:37:28,430
ridiculously precise considering what we

00:37:26,930 --> 00:37:34,390
have but it seems like a reasonable

00:37:28,430 --> 00:37:36,590
thing to do and so in theory we have

00:37:34,390 --> 00:37:39,440
literally it's just a placeholder time

00:37:36,590 --> 00:37:41,420
stamp work to be done here but one of

00:37:39,440 --> 00:37:44,210
the ways I thought about is using the

00:37:41,420 --> 00:37:46,370
TPMS capability of creating a time stamp

00:37:44,210 --> 00:37:48,590
and putting that in the record right so

00:37:46,370 --> 00:37:50,710
among the options I think that's one of

00:37:48,590 --> 00:37:50,710
them

00:37:58,230 --> 00:38:04,480
[Laughter]

00:38:13,599 --> 00:38:19,009
yes okay

00:38:15,890 --> 00:38:21,319
so you're taking you're getting rid of

00:38:19,009 --> 00:38:24,410
the measurement list and let's say that

00:38:21,319 --> 00:38:27,609
we're in the case of K exact the

00:38:24,410 --> 00:38:30,589
question is your K exactly something and

00:38:27,609 --> 00:38:32,720
let's say that you're not you're not

00:38:30,589 --> 00:38:35,359
doing appraisal you're just doing

00:38:32,720 --> 00:38:38,269
measurement how are you gonna know that

00:38:35,359 --> 00:38:41,450
you didn't K exact something and that

00:38:38,269 --> 00:38:44,869
that measurement wasn't included that

00:38:41,450 --> 00:38:48,589
the next boob isn't is actually doing

00:38:44,869 --> 00:38:52,400
measurements there are that kernel might

00:38:48,589 --> 00:38:55,869
not have a policy to do measurements so

00:38:52,400 --> 00:38:59,259
you've now introduced a vulnerability of

00:38:55,869 --> 00:39:01,309
that you were you booted something and

00:38:59,259 --> 00:39:03,529
it's not going to show up in the

00:39:01,309 --> 00:39:06,589
measurement list and there's no and

00:39:03,529 --> 00:39:08,779
there's no way of showing it in the the

00:39:06,589 --> 00:39:12,289
TPM won't be extended because it's not

00:39:08,779 --> 00:39:15,619
being it's not included in the policy so

00:39:12,289 --> 00:39:18,049
I think they're they're a couple

00:39:15,619 --> 00:39:20,839
different issues are the first thing is

00:39:18,049 --> 00:39:23,809
that admittedly we're pushing the

00:39:20,839 --> 00:39:26,329
complexity of handling k exec up into

00:39:23,809 --> 00:39:27,920
user space but I think that's really in

00:39:26,329 --> 00:39:30,289
some sense the right place to do it

00:39:27,920 --> 00:39:33,529
what k exec as the application would

00:39:30,289 --> 00:39:35,690
need to do is make sure that it has

00:39:33,529 --> 00:39:38,960
flushed all measurements out of the

00:39:35,690 --> 00:39:41,390
existing thing before it actually

00:39:38,960 --> 00:39:43,609
triggers a k exact as long as it does

00:39:41,390 --> 00:39:48,440
that then there are no measurements to

00:39:43,609 --> 00:39:49,940
be lost the new system comes up and

00:39:48,440 --> 00:39:52,490
starts measurements from that

00:39:49,940 --> 00:39:57,349
perspective so there should not be

00:39:52,490 --> 00:40:00,680
anything in there that was committed to

00:39:57,349 --> 00:40:04,960
the TPM that was not already exported to

00:40:00,680 --> 00:40:07,849
to the existing list before the k exec

00:40:04,960 --> 00:40:09,210
there's nothing that's gonna show that

00:40:07,849 --> 00:40:12,530
you did a k exact

00:40:09,210 --> 00:40:16,109
when we measure a key event the cake

00:40:12,530 --> 00:40:17,970
that the neck that there might be a gap

00:40:16,109 --> 00:40:19,440
because you might have multiple kids

00:40:17,970 --> 00:40:22,670
well we certainly will get the

00:40:19,440 --> 00:40:25,680
measurement of K Exec itself and

00:40:22,670 --> 00:40:27,390
anything that would be triggered by that

00:40:25,680 --> 00:40:29,609
but it's a good point I mean we do need

00:40:27,390 --> 00:40:31,290
to look at that and in in essence we're

00:40:29,609 --> 00:40:35,040
pushing that complexity up into user

00:40:31,290 --> 00:40:36,540
space but I like taking like say out of

00:40:35,040 --> 00:40:41,180
the kernel and putting it up into user

00:40:36,540 --> 00:40:41,180

YouTube URL: https://www.youtube.com/watch?v=UxpS7NukBb0


