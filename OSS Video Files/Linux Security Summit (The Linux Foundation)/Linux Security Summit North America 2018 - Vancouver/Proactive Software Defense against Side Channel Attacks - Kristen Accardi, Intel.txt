Title: Proactive Software Defense against Side Channel Attacks - Kristen Accardi, Intel
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Proactive Software Defense against Side Channel Attacks - Kristen Accardi, Intel

Side channel attacks are here to stay. What can we do inside the operating system to proactively defend against them? This talk will walk through a few of the ideas that Intel’s Open Source Technology Center are developing to improve our resistance to side channel attacks as part of our new side channel defense project. We would also like to gather ideas from the rest of the community on what our top priorities for side channel defense for the Linux kernel should be.

About Kristen Accardi
Kristen is a Security Architect for Intel’s Open Source Technology Center (OTC), focusing on the Linux kernel. Kristen has contributed to the Linux kernel for over 15 years in various different subsystems including PCI, SATA, ACPI, and Power Management. Kristen is currently leading the OTC's side channel defense project.

Kristen has spoken previously at many Linux conferences, including LinuxCon, Linux Plumbers and LinuxConf AU.
Captions: 
	00:00:00,030 --> 00:00:03,899
well maybe I'll just do this without

00:00:01,709 --> 00:00:05,100
slides because my slides actually are

00:00:03,899 --> 00:00:09,599
not that important

00:00:05,100 --> 00:00:12,120
there's they are there on line so yeah

00:00:09,599 --> 00:00:18,240
you can walk along with it and my slides

00:00:12,120 --> 00:00:20,730
are somewhat content free because I I

00:00:18,240 --> 00:00:23,310
really took it seriously that when I

00:00:20,730 --> 00:00:26,550
presented this topic that it would be a

00:00:23,310 --> 00:00:29,130
discussion I saw that there was this

00:00:26,550 --> 00:00:32,160
nice shorter thing where you could get

00:00:29,130 --> 00:00:34,980
input from everybody so while I do have

00:00:32,160 --> 00:00:37,829
some ideas I want to present to you I'm

00:00:34,980 --> 00:00:39,960
really hoping to get your opinion on

00:00:37,829 --> 00:00:42,480
some of the things that I'm going to

00:00:39,960 --> 00:00:46,020
talk about so the first thing I want to

00:00:42,480 --> 00:00:49,170
do is introduce myself some of you guys

00:00:46,020 --> 00:00:51,329
know me but a lot of you don't my name

00:00:49,170 --> 00:00:53,670
is Kristen Accardi and I work for

00:00:51,329 --> 00:00:57,770
Intel's open-source Technology Center

00:00:53,670 --> 00:01:01,500
and I have worked in the kernel for

00:00:57,770 --> 00:01:04,140
almost 20 years now it's been all over

00:01:01,500 --> 00:01:06,780
the place I started out in networking

00:01:04,140 --> 00:01:08,970
and then I changed over to various other

00:01:06,780 --> 00:01:12,180
subsystems over the years

00:01:08,970 --> 00:01:15,990
what's notably lacking from my previous

00:01:12,180 --> 00:01:18,900
experience in the kernel is security so

00:01:15,990 --> 00:01:21,350
this is my first try at security the

00:01:18,900 --> 00:01:24,750
previous five years I've been working on

00:01:21,350 --> 00:01:26,250
power management and the thing that's

00:01:24,750 --> 00:01:28,290
really exciting about working on

00:01:26,250 --> 00:01:30,030
security is that it shares a lot of

00:01:28,290 --> 00:01:32,159
similarities with working on power

00:01:30,030 --> 00:01:34,770
management in that it's a system level

00:01:32,159 --> 00:01:37,170
problem that it takes a user space and

00:01:34,770 --> 00:01:39,780
kernel cooperation in order to solve and

00:01:37,170 --> 00:01:42,150
also we have a lot of this we had a lot

00:01:39,780 --> 00:01:43,560
of the same issues with having to make

00:01:42,150 --> 00:01:46,200
trade-offs that - most of the time

00:01:43,560 --> 00:01:47,790
people would decide they didn't want

00:01:46,200 --> 00:01:49,799
your feature because it impacted

00:01:47,790 --> 00:01:52,110
performance or you'd put it in and

00:01:49,799 --> 00:01:55,640
somebody wouldn't turn it on so I'm very

00:01:52,110 --> 00:01:58,380
familiar with a lot of the issues here

00:01:55,640 --> 00:01:59,969
the other thing that's very exciting is

00:01:58,380 --> 00:02:02,790
now that I've joined this security team

00:01:59,969 --> 00:02:05,640
I have lots of people who are really

00:02:02,790 --> 00:02:07,920
excited to help me review my slides so

00:02:05,640 --> 00:02:10,140
when you're going through them you can

00:02:07,920 --> 00:02:12,340
see that they've had a lot of attention

00:02:10,140 --> 00:02:14,920
put to them

00:02:12,340 --> 00:02:19,300
so when I started on the security team

00:02:14,920 --> 00:02:22,240
in February it was not entirely clear of

00:02:19,300 --> 00:02:25,090
what I was going to work on one thing

00:02:22,240 --> 00:02:27,820
that was clear though was that the world

00:02:25,090 --> 00:02:29,710
was going to be changing a little bit

00:02:27,820 --> 00:02:33,970
for the next few years we had recently

00:02:29,710 --> 00:02:38,770
had the specter in meltdown attacks made

00:02:33,970 --> 00:02:41,500
public and the theory is that these

00:02:38,770 --> 00:02:43,120
attacks are now very exciting and new

00:02:41,500 --> 00:02:44,380
and are going to be something that we're

00:02:43,120 --> 00:02:46,720
going to be hearing a lot of at least

00:02:44,380 --> 00:02:48,790
for the next few years so I think that

00:02:46,720 --> 00:02:50,590
CPU mark micro architectural

00:02:48,790 --> 00:02:53,230
side-channel attacks are going to be

00:02:50,590 --> 00:02:56,130
something that researchers are going to

00:02:53,230 --> 00:02:58,630
continue to work on and so we as a

00:02:56,130 --> 00:03:00,460
kernel community need to sort of

00:02:58,630 --> 00:03:04,510
anticipate that they're going to keep

00:03:00,460 --> 00:03:06,430
coming so what can we do to get

00:03:04,510 --> 00:03:10,930
ourselves out of this cycle where we're

00:03:06,430 --> 00:03:13,500
constantly trying to to fight the latest

00:03:10,930 --> 00:03:15,820
thing how can we move to a place where

00:03:13,500 --> 00:03:20,800
side-channel attacks are not quite as

00:03:15,820 --> 00:03:24,070
destructive as they might be so that's

00:03:20,800 --> 00:03:26,440
where I can't I come in as they went

00:03:24,070 --> 00:03:28,540
through the specter and meltdown

00:03:26,440 --> 00:03:31,090
mitigation work last year which started

00:03:28,540 --> 00:03:33,010
you know over the summer they came up

00:03:31,090 --> 00:03:35,020
with all kinds of ideas for things that

00:03:33,010 --> 00:03:36,640
they wish had been done better but they

00:03:35,020 --> 00:03:38,590
didn't have time to work on it right

00:03:36,640 --> 00:03:41,800
when you're in the middle of working on

00:03:38,590 --> 00:03:43,570
a mitigation for a specific exploit you

00:03:41,800 --> 00:03:46,870
don't have time to go back and do some

00:03:43,570 --> 00:03:49,360
long-term stuff so this is really what

00:03:46,870 --> 00:03:53,890
my mission and my mission is to try to

00:03:49,360 --> 00:03:56,200
find how we can prevent future a bit

00:03:53,890 --> 00:03:58,870
more proactive about preventing future

00:03:56,200 --> 00:04:01,240
side-channel attacks and harden the

00:03:58,870 --> 00:04:04,000
kernel against other potential exploits

00:04:01,240 --> 00:04:06,550
it's really important to note not just

00:04:04,000 --> 00:04:09,190
because legal wants me to say this but

00:04:06,550 --> 00:04:12,459
also because it's true we're not trying

00:04:09,190 --> 00:04:15,340
to address specific cv ease or security

00:04:12,459 --> 00:04:18,310
gaps what we're trying to do and this is

00:04:15,340 --> 00:04:20,770
important because we don't expect

00:04:18,310 --> 00:04:24,550
anything that we're working on to be a

00:04:20,770 --> 00:04:26,770
hundred percent solution to any sort of

00:04:24,550 --> 00:04:30,669
what we're really trying to do our

00:04:26,770 --> 00:04:33,610
create speed bumps things that will slow

00:04:30,669 --> 00:04:36,009
attackers down so it's not going to be

00:04:33,610 --> 00:04:38,319
perfect security there is a lot of

00:04:36,009 --> 00:04:42,520
overlap as a result with the work that

00:04:38,319 --> 00:04:44,229
case is doing on KS PPP because what

00:04:42,520 --> 00:04:45,610
we're really a lot of the things that we

00:04:44,229 --> 00:04:47,860
came up with that would make these

00:04:45,610 --> 00:04:51,699
side-channel attacks harder are just

00:04:47,860 --> 00:04:53,530
general kernel hardening things so what

00:04:51,699 --> 00:04:56,020
I'm going to do today is I want to walk

00:04:53,530 --> 00:04:58,509
through some of the project ideas that

00:04:56,020 --> 00:05:01,780
came out of the Spector work last year

00:04:58,509 --> 00:05:04,509
and and that are now at the top of the

00:05:01,780 --> 00:05:07,259
priority list for my team I should let

00:05:04,509 --> 00:05:11,080
you know that we're a very small team

00:05:07,259 --> 00:05:13,240
including myself there's two and a half

00:05:11,080 --> 00:05:17,409
people if you count Casey as half a

00:05:13,240 --> 00:05:19,629
person and so we don't have a lot of

00:05:17,409 --> 00:05:22,840
people on our team if any of these

00:05:19,629 --> 00:05:24,580
projects sound super duper exciting and

00:05:22,840 --> 00:05:24,849
you think hey I wish I could work on

00:05:24,580 --> 00:05:28,509
that

00:05:24,849 --> 00:05:32,560
then you can come look at come meet me

00:05:28,509 --> 00:05:34,000
and maybe we can we can hook up but and

00:05:32,560 --> 00:05:36,490
the other thing as I'm going through

00:05:34,000 --> 00:05:38,020
this list if any of these projects seem

00:05:36,490 --> 00:05:39,909
totally ridiculous

00:05:38,020 --> 00:05:42,159
I would really like to know about it

00:05:39,909 --> 00:05:44,110
especially some of the longer-term ones

00:05:42,159 --> 00:05:46,210
because I certainly don't want to spend

00:05:44,110 --> 00:05:49,719
a year of my life on some of these

00:05:46,210 --> 00:05:53,740
things only to get a resounding no way

00:05:49,719 --> 00:05:56,979
in hell all right so the first project I

00:05:53,740 --> 00:05:59,919
want to talk to you about is its kernel

00:05:56,979 --> 00:06:02,529
address randomization so right now you

00:05:59,919 --> 00:06:06,610
know we have ksl are implemented in the

00:06:02,529 --> 00:06:10,389
kernel it's a little bit weak as it is

00:06:06,610 --> 00:06:12,580
and some of the side channel exploits

00:06:10,389 --> 00:06:14,680
that we had would take advantage of

00:06:12,580 --> 00:06:16,779
being able to easily get a kernel

00:06:14,680 --> 00:06:18,849
address the other problem we have with

00:06:16,779 --> 00:06:21,009
it with the existing implementation is

00:06:18,849 --> 00:06:24,009
that you find one and you find

00:06:21,009 --> 00:06:27,849
everything so one idea that's been

00:06:24,009 --> 00:06:29,650
thrown out and this is kind of I guess

00:06:27,849 --> 00:06:32,770
this is the scariest thing on my list

00:06:29,650 --> 00:06:35,649
from my point of view is the idea that

00:06:32,770 --> 00:06:37,650
maybe every time you boot the kernel you

00:06:35,649 --> 00:06:39,630
should rearrange it

00:06:37,650 --> 00:06:42,540
and so basically what this is going to

00:06:39,630 --> 00:06:45,900
do is relink the kernel on every boot

00:06:42,540 --> 00:06:49,530
and the way we would do that is by

00:06:45,900 --> 00:06:52,800
incorporating a linker inside the kernel

00:06:49,530 --> 00:06:55,710
and this isn't as weird as it sounds in

00:06:52,800 --> 00:06:58,560
that we sort of already have a linker in

00:06:55,710 --> 00:07:00,990
the kernel in the module loader it's a

00:06:58,560 --> 00:07:02,850
pretty brain-dead linker and it doesn't

00:07:00,990 --> 00:07:05,430
do what we would need it to do in order

00:07:02,850 --> 00:07:08,220
to achieve this but you could use it as

00:07:05,430 --> 00:07:10,260
a foundation for doing this work so the

00:07:08,220 --> 00:07:13,560
idea would be that we break the kernel

00:07:10,260 --> 00:07:15,810
up into effectively modules but they're

00:07:13,560 --> 00:07:17,880
not really I mean I guess modules are

00:07:15,810 --> 00:07:20,010
really just a relocatable object file so

00:07:17,880 --> 00:07:22,020
a little bit of gunk thrown in there to

00:07:20,010 --> 00:07:24,360
make it easier to load them as a module

00:07:22,020 --> 00:07:27,090
so you could modify the module loader to

00:07:24,360 --> 00:07:30,630
be able to just take dot o files we may

00:07:27,090 --> 00:07:33,720
be able to rip to leverage any kind of V

00:07:30,630 --> 00:07:36,419
malloc allocation algorithms that we

00:07:33,720 --> 00:07:39,120
could write that would be more random

00:07:36,419 --> 00:07:41,970
and we might be able to take basically

00:07:39,120 --> 00:07:45,419
take all of these dot o files and create

00:07:41,970 --> 00:07:47,610
a new section in the binary now right

00:07:45,419 --> 00:07:49,889
now when the kernel boots up it takes

00:07:47,610 --> 00:07:51,930
the compressed binary and compresses it

00:07:49,889 --> 00:07:55,280
and then it does its loading so what we

00:07:51,930 --> 00:07:59,610
would do is insert into that process a

00:07:55,280 --> 00:08:02,039
step where we take the kernel binary and

00:07:59,610 --> 00:08:04,740
we read the special section that we've

00:08:02,039 --> 00:08:07,139
added we take all of our files we

00:08:04,740 --> 00:08:09,630
rearrange them according to a spiffy

00:08:07,139 --> 00:08:12,690
random algorithm and then we load them

00:08:09,630 --> 00:08:15,990
up into different places in memory so

00:08:12,690 --> 00:08:19,800
that's kind of the idea that we have it

00:08:15,990 --> 00:08:21,630
now it has some some benefits obviously

00:08:19,800 --> 00:08:24,330
otherwise we wouldn't be considering it

00:08:21,630 --> 00:08:28,590
it really does increase the difficulty

00:08:24,330 --> 00:08:30,270
on side-channel attacks in that now when

00:08:28,590 --> 00:08:31,979
you find one address that's all you

00:08:30,270 --> 00:08:37,110
really get you're not going to be able

00:08:31,979 --> 00:08:38,370
to get a second address and also this is

00:08:37,110 --> 00:08:42,419
going to strengthen what we've already

00:08:38,370 --> 00:08:48,089
got as far as KS LR um the the

00:08:42,419 --> 00:08:50,190
challenges to this is that even

00:08:48,089 --> 00:08:52,650
fine-grained KS LR can be worked around

00:08:50,190 --> 00:08:56,850
and it might be sufficient to have a

00:08:52,650 --> 00:09:00,390
single single info leak in order to find

00:08:56,850 --> 00:09:02,459
the rest of the kernel and it's this

00:09:00,390 --> 00:09:04,709
certainly is going to increase the

00:09:02,459 --> 00:09:07,260
complexity of the kernel it's going to

00:09:04,709 --> 00:09:09,300
make it harder to reproduce bugs because

00:09:07,260 --> 00:09:11,579
now you might have issues where your

00:09:09,300 --> 00:09:13,320
kernel is arranged in a certain fashion

00:09:11,579 --> 00:09:15,180
and you only have a bug that happens

00:09:13,320 --> 00:09:19,020
when it's laid out in that particular

00:09:15,180 --> 00:09:21,600
way we would have to probably make some

00:09:19,020 --> 00:09:23,160
allowances and maybe have a seed that we

00:09:21,600 --> 00:09:26,490
could export or whatever to try to

00:09:23,160 --> 00:09:29,640
reproduce images but the big thing would

00:09:26,490 --> 00:09:31,800
be customers of distros are going to be

00:09:29,640 --> 00:09:33,930
running different kernel images all of

00:09:31,800 --> 00:09:36,660
them so now instead of everybody running

00:09:33,930 --> 00:09:38,670
the same a bun to image or Fedora image

00:09:36,660 --> 00:09:40,740
they're running you know they've got the

00:09:38,670 --> 00:09:42,060
code but it's all rearranged so it's

00:09:40,740 --> 00:09:45,630
going to make it a little bit difficult

00:09:42,060 --> 00:09:47,750
for distros to be able to assume that

00:09:45,630 --> 00:09:53,520
they know exactly what the customers got

00:09:47,750 --> 00:09:57,540
so this project is is still in the

00:09:53,520 --> 00:10:05,850
research phase so I'm interested if

00:09:57,540 --> 00:10:10,040
anybody has any opinions there's an

00:10:05,850 --> 00:10:10,040
opinion over there via microphone

00:10:14,330 --> 00:10:19,710
have you all thought about how this

00:10:16,950 --> 00:10:21,810
would impact live patching because there

00:10:19,710 --> 00:10:24,480
are a number of environments that really

00:10:21,810 --> 00:10:27,060
rely on that for rolling out emergency

00:10:24,480 --> 00:10:29,430
bug fixes especially when they're

00:10:27,060 --> 00:10:32,550
security related I have wondered about

00:10:29,430 --> 00:10:34,140
life patching and that just seems to me

00:10:32,550 --> 00:10:40,530
this might make life much more difficult

00:10:34,140 --> 00:10:43,230
yeah I'm pretty sure it would I wasn't

00:10:40,530 --> 00:10:44,910
actually sure how many how prevalent it

00:10:43,230 --> 00:10:47,130
was to actually use live patching

00:10:44,910 --> 00:10:49,020
because when I was researching it seemed

00:10:47,130 --> 00:10:51,840
that many people considered this to be

00:10:49,020 --> 00:11:02,100
still fairly out there as far as what

00:10:51,840 --> 00:11:04,850
people do I think I am NOT an X but I do

00:11:02,100 --> 00:11:07,680
not speak for read out on this but I

00:11:04,850 --> 00:11:10,950
think when it happens it's really

00:11:07,680 --> 00:11:12,990
important and it doesn't that very often

00:11:10,950 --> 00:11:15,420
but when it does you really really want

00:11:12,990 --> 00:11:18,000
to make it happen so putting huge

00:11:15,420 --> 00:11:20,220
roadblocks in its way without sorting

00:11:18,000 --> 00:11:23,070
that out and I know we're not the only

00:11:20,220 --> 00:11:27,780
vendor to do it is likely to be an issue

00:11:23,070 --> 00:11:29,040
okay so don't break life patch it yeah I

00:11:27,780 --> 00:11:31,320
think it's a bit of a chicken and the

00:11:29,040 --> 00:11:32,880
egg problem people don't adopt live

00:11:31,320 --> 00:11:36,200
patching because there are things that

00:11:32,880 --> 00:11:36,200
break it really badly

00:11:43,630 --> 00:11:49,399
so I wanted to ask about because we are

00:11:46,970 --> 00:11:52,010
randomizing things at boot time and so I

00:11:49,399 --> 00:11:53,600
wanted to ask about entropy because this

00:11:52,010 --> 00:11:55,790
is something that can be a problem at

00:11:53,600 --> 00:11:58,339
boot time and especially when it comes

00:11:55,790 --> 00:12:01,870
to from what I remember which to our

00:11:58,339 --> 00:12:01,870
machines and things like that

00:12:02,260 --> 00:12:09,019
so I mean you you currently have issues

00:12:06,320 --> 00:12:12,399
with entropy already because you have to

00:12:09,019 --> 00:12:14,690
be able to I mean there's there's

00:12:12,399 --> 00:12:16,220
currently requirements that you have a

00:12:14,690 --> 00:12:19,640
certain amount of entropy when you boot

00:12:16,220 --> 00:12:21,950
a VM for example and I think that at the

00:12:19,640 --> 00:12:26,360
moment we would have to rely on the

00:12:21,950 --> 00:12:30,200
existing entropy sources for what we're

00:12:26,360 --> 00:12:32,380
trying to do that's a good question

00:12:30,200 --> 00:12:32,380
though

00:12:42,470 --> 00:12:47,060
I should be taking notes since no one

00:12:44,510 --> 00:12:49,250
can't see what I'm doing so more of a

00:12:47,060 --> 00:12:50,540
meta comment but OpenBSD implemented

00:12:49,250 --> 00:12:52,280
something along these lines a number of

00:12:50,540 --> 00:12:56,360
years ago they called it kernel address

00:12:52,280 --> 00:12:59,570
randomized link or Kao L Carl yes I know

00:12:56,360 --> 00:13:01,730
all about Carl so the main difference

00:12:59,570 --> 00:13:04,040
between what we're doing and Carl is

00:13:01,730 --> 00:13:06,920
that what Carl does is it actually

00:13:04,040 --> 00:13:11,120
recompiles the entire kernel at boot

00:13:06,920 --> 00:13:14,060
time and so it will boot into a little

00:13:11,120 --> 00:13:17,420
mini user space recompile the kernel and

00:13:14,060 --> 00:13:20,000
then boot to that I actually considered

00:13:17,420 --> 00:13:22,970
this while we were looking at the

00:13:20,000 --> 00:13:26,630
architecture for this and it seemed to

00:13:22,970 --> 00:13:28,520
me that this was more complex I know

00:13:26,630 --> 00:13:30,020
that sounds weird because I'm talking

00:13:28,520 --> 00:13:32,270
about adding and Link her into the

00:13:30,020 --> 00:13:34,550
kernel but it did sound more complex

00:13:32,270 --> 00:13:37,130
than trying to do it without the user

00:13:34,550 --> 00:13:41,540
space portion so the other thing was

00:13:37,130 --> 00:13:44,510
just as far as adoption I felt like it

00:13:41,540 --> 00:13:47,420
would be really hard to coordinate you

00:13:44,510 --> 00:13:50,180
have to sort of coordinate the the image

00:13:47,420 --> 00:13:52,100
part you know the the many user space

00:13:50,180 --> 00:14:02,030
and everything with distros and that

00:13:52,100 --> 00:14:03,800
just seemed hard does it impact the

00:14:02,030 --> 00:14:07,000
signature validation of measured

00:14:03,800 --> 00:14:10,310
measurements the signature validation

00:14:07,000 --> 00:14:15,080
measurement since you're relocating the

00:14:10,310 --> 00:14:16,610
first secure boot I don't know I guess

00:14:15,080 --> 00:14:18,920
it would depend on what we wound up

00:14:16,610 --> 00:14:23,120
actually implementing and where you put

00:14:18,920 --> 00:14:27,550
those measurements I'm gonna write that

00:14:23,120 --> 00:14:27,550
down though what about secure boot

00:14:42,410 --> 00:14:47,750
I wonder if in your research if you

00:14:45,649 --> 00:14:50,240
found any precedents for this in any

00:14:47,750 --> 00:14:51,500
microkernel approaches where you know

00:14:50,240 --> 00:14:53,629
you might have much smaller footprint

00:14:51,500 --> 00:14:55,519
you still have the same problem at the

00:14:53,629 --> 00:14:58,069
core but at least you've you know pushed

00:14:55,519 --> 00:14:59,930
everything out of the core itself but

00:14:58,069 --> 00:15:01,430
and then you're recompile is a much

00:14:59,930 --> 00:15:04,160
smaller surface area but did you come

00:15:01,430 --> 00:15:07,040
across anything similar at all as far as

00:15:04,160 --> 00:15:08,600
with microkernels no I can't say that I

00:15:07,040 --> 00:15:11,449
looked at any microkernel

00:15:08,600 --> 00:15:13,459
implementations I did consider you know

00:15:11,449 --> 00:15:16,149
what is the difference between what

00:15:13,459 --> 00:15:20,259
we're doing and just really trying to

00:15:16,149 --> 00:15:22,819
strip the kernel down to really core

00:15:20,259 --> 00:15:29,329
thing and then build everything else as

00:15:22,819 --> 00:15:32,089
a module I think the it's very similar

00:15:29,329 --> 00:15:34,850
to what I'm proposing is very similar to

00:15:32,089 --> 00:15:37,990
that idea with the difference being that

00:15:34,850 --> 00:15:40,009
you don't have all the dependency

00:15:37,990 --> 00:15:41,959
dependencies between module because

00:15:40,009 --> 00:15:43,759
you're really still making a static

00:15:41,959 --> 00:15:46,730
monolithic binary at the end of the day

00:15:43,759 --> 00:15:50,000
once you load it up into memory so you

00:15:46,730 --> 00:15:52,670
don't have the same quite the same

00:15:50,000 --> 00:15:55,569
environment and also not the dependency

00:15:52,670 --> 00:15:55,569
on file system

00:16:03,690 --> 00:16:08,460
okay so no one was throwing tomatoes too

00:16:07,740 --> 00:16:14,100
bad I guess

00:16:08,460 --> 00:16:21,270
I guess you're waiting for the first

00:16:14,100 --> 00:16:23,640
patch well that'll take a while okay so

00:16:21,270 --> 00:16:25,530
next project this one's easier to talk

00:16:23,640 --> 00:16:27,720
about because it's in it's in progress

00:16:25,530 --> 00:16:32,370
already and also it was conceptually

00:16:27,720 --> 00:16:37,230
less scary the idea here is that we

00:16:32,370 --> 00:16:39,570
wanted to apply randomization not just

00:16:37,230 --> 00:16:42,780
to the kernel text section but also to

00:16:39,570 --> 00:16:44,880
the module text section so these patches

00:16:42,780 --> 00:16:46,620
have already been posted on the mailing

00:16:44,880 --> 00:16:49,560
list some of you guys might have seen it

00:16:46,620 --> 00:16:52,170
but I'll just sort of run through the

00:16:49,560 --> 00:16:54,570
design for this what we want to do here

00:16:52,170 --> 00:16:58,890
I'm currently the module techs range is

00:16:54,570 --> 00:17:02,580
a gigabyte ish and so we've we've

00:16:58,890 --> 00:17:04,440
apparently had proposals for doing this

00:17:02,580 --> 00:17:07,440
in the past and people were concerned

00:17:04,440 --> 00:17:10,380
about fragmentation of the memory area

00:17:07,440 --> 00:17:13,050
so we try to solve this by basically

00:17:10,380 --> 00:17:15,960
splitting the existing module techs

00:17:13,050 --> 00:17:18,870
range into two sections and the first

00:17:15,960 --> 00:17:22,020
section is going to be where randomized

00:17:18,870 --> 00:17:25,110
text goes and then the second section is

00:17:22,020 --> 00:17:28,530
going to be linearly allocated so if you

00:17:25,110 --> 00:17:31,140
fail to find a sufficiently large space

00:17:28,530 --> 00:17:33,870
inside the randomize section then you

00:17:31,140 --> 00:17:37,080
can go and use the the old way of doing

00:17:33,870 --> 00:17:39,270
it in the linear section in practice we

00:17:37,080 --> 00:17:42,090
found that it takes loading a large

00:17:39,270 --> 00:17:44,760
number of modules before you ever touch

00:17:42,090 --> 00:17:47,040
the randomized I mean the linear section

00:17:44,760 --> 00:17:49,890
and I don't have the numbers with me on

00:17:47,040 --> 00:17:53,090
how many it takes but Rick has done a

00:17:49,890 --> 00:17:55,590
lot of testing now and after he was

00:17:53,090 --> 00:17:58,080
given his first round of feedback and

00:17:55,590 --> 00:17:59,970
it's looking pretty good and sort of a

00:17:58,080 --> 00:18:03,560
side effect to this is this new

00:17:59,970 --> 00:18:06,240
algorithms actually a lot faster than

00:18:03,560 --> 00:18:08,220
linearly allocated because now you're

00:18:06,240 --> 00:18:10,350
just basically bisecting this space and

00:18:08,220 --> 00:18:13,020
you're sort of randomly fitting so your

00:18:10,350 --> 00:18:14,770
module load time actually improves with

00:18:13,020 --> 00:18:20,440
this algorithm

00:18:14,770 --> 00:18:23,080
and the the other benefit to this is

00:18:20,440 --> 00:18:27,760
we've increased randomization now we get

00:18:23,080 --> 00:18:30,940
about 17 bits of entropy and you can now

00:18:27,760 --> 00:18:32,830
link you could now leak an address in

00:18:30,940 --> 00:18:34,950
one module and you don't automatically

00:18:32,830 --> 00:18:38,290
know where all the other modules are

00:18:34,950 --> 00:18:41,830
this one has the same sort of challenges

00:18:38,290 --> 00:18:44,200
as the other project does in that it

00:18:41,830 --> 00:18:46,990
still might not be good enough one

00:18:44,200 --> 00:18:49,870
address leak could still be sufficient

00:18:46,990 --> 00:18:52,390
we have slightly increased memory usage

00:18:49,870 --> 00:18:54,310
due to the increase increase in page

00:18:52,390 --> 00:18:57,070
table entries that we have to have and

00:18:54,310 --> 00:18:59,560
again we we wind up with increased

00:18:57,070 --> 00:19:02,590
complexity just because now you don't

00:18:59,560 --> 00:19:05,290
know where modules might be but at the

00:19:02,590 --> 00:19:08,680
same time this is this is to me anyway

00:19:05,290 --> 00:19:12,190
somewhat of a no-brainer thing to do so

00:19:08,680 --> 00:19:14,290
you know if you do have severe issues

00:19:12,190 --> 00:19:15,850
with this one I guess you can still

00:19:14,290 --> 00:19:18,760
comment on the mailing list since we're

00:19:15,850 --> 00:19:19,900
not merged but or if you have any

00:19:18,760 --> 00:19:21,550
comments you want to tell me right now

00:19:19,900 --> 00:19:24,790
about it but I feel like this one's

00:19:21,550 --> 00:19:31,090
somewhat uh non-controversial just

00:19:24,790 --> 00:19:33,130
correct me if I'm wrong nope okay that

00:19:31,090 --> 00:19:35,850
are you guys realizing that lunchtime is

00:19:33,130 --> 00:19:35,850
in five minutes

00:19:36,150 --> 00:19:43,240
okay here's another idea this is a POC

00:19:40,960 --> 00:19:46,090
that we have it's under development so

00:19:43,240 --> 00:19:47,350
we're pretty excited about this one to

00:19:46,090 --> 00:19:50,980
the point where we've actually got

00:19:47,350 --> 00:19:52,740
things that we're working on so the idea

00:19:50,980 --> 00:19:56,110
is that we need to start protecting

00:19:52,740 --> 00:19:58,480
pages that have secrets in them and so

00:19:56,110 --> 00:20:01,840
our thought was that we should allow

00:19:58,480 --> 00:20:04,180
user space to be able to tell the kernel

00:20:01,840 --> 00:20:06,790
that a page contains a secret that needs

00:20:04,180 --> 00:20:09,400
special protection so we think that

00:20:06,790 --> 00:20:12,730
maybe you could add a new flag to the in

00:20:09,400 --> 00:20:15,850
lock to system call and this flag would

00:20:12,730 --> 00:20:18,340
be used in order to apply mitigations to

00:20:15,850 --> 00:20:20,860
the memory area and also maybe the

00:20:18,340 --> 00:20:22,810
process that's mapping it and these

00:20:20,860 --> 00:20:25,660
mitigations might include things like

00:20:22,810 --> 00:20:28,510
making this page not don't bubble making

00:20:25,660 --> 00:20:30,610
it so that you don't copy or fork it

00:20:28,510 --> 00:20:35,980
or even disabling cashing on that

00:20:30,610 --> 00:20:38,140
particular page so in this one the only

00:20:35,980 --> 00:20:41,200
downside that I see is of course we're

00:20:38,140 --> 00:20:43,330
adding a new system call that comes with

00:20:41,200 --> 00:20:46,090
all of the maintenance overhead of that

00:20:43,330 --> 00:20:47,710
but I wasn't seeing any downsides to

00:20:46,090 --> 00:20:51,190
this one and I'm curious what people

00:20:47,710 --> 00:21:01,210
think there's a there's a comment back

00:20:51,190 --> 00:21:02,830
there so those are the potentially cause

00:21:01,210 --> 00:21:04,770
problems when you shop a G's which is

00:21:02,830 --> 00:21:07,030
our processes you might trick them into

00:21:04,770 --> 00:21:08,500
introducing a page which has properties

00:21:07,030 --> 00:21:10,210
which you might not expect and then you

00:21:08,500 --> 00:21:11,710
might have certain attacks that you

00:21:10,210 --> 00:21:14,040
actually create with the system core

00:21:11,710 --> 00:21:16,750
instead of fixing them

00:21:14,040 --> 00:21:18,790
and could you repeat that I'm not trying

00:21:16,750 --> 00:21:21,490
well I mean you're now potentially

00:21:18,790 --> 00:21:23,980
changing the poverties of userspace page

00:21:21,490 --> 00:21:25,480
tables and so now if you somehow find a

00:21:23,980 --> 00:21:27,150
way to trick and other process

00:21:25,480 --> 00:21:29,410
interesting the same page you might have

00:21:27,150 --> 00:21:34,390
interesting side effects which you might

00:21:29,410 --> 00:21:36,660
effectively create new issues 1,006 like

00:21:34,390 --> 00:21:39,720
such a view that you're saying yeah

00:21:36,660 --> 00:21:39,720
thank you

00:21:42,700 --> 00:21:51,150
I'm writing it down okay

00:21:54,180 --> 00:22:00,790
okay I think this will be the last one

00:21:57,610 --> 00:22:03,640
since it looks like we're almost out of

00:22:00,790 --> 00:22:06,960
time so the last project that I wanted

00:22:03,640 --> 00:22:11,440
to talk to you about today is removing

00:22:06,960 --> 00:22:14,380
basically cache breadcrumbs from data

00:22:11,440 --> 00:22:17,260
that might be left left behind in system

00:22:14,380 --> 00:22:20,020
calls so this one's not addressing a

00:22:17,260 --> 00:22:22,810
particular attack per se I I don't know

00:22:20,020 --> 00:22:25,900
of an exploit that does this but I'm

00:22:22,810 --> 00:22:28,360
just sort of thinking about it if you

00:22:25,900 --> 00:22:31,300
call a system call and you don't really

00:22:28,360 --> 00:22:34,000
have permission to do what you ask the

00:22:31,300 --> 00:22:37,720
system call to do you might still impact

00:22:34,000 --> 00:22:40,000
the cache by doing this there might be

00:22:37,720 --> 00:22:41,920
things left behind as a result even

00:22:40,000 --> 00:22:45,370
though you got it eventually you got a

00:22:41,920 --> 00:22:48,430
you know Ino perm or whatever and so the

00:22:45,370 --> 00:22:51,190
thought was that in an error path it's

00:22:48,430 --> 00:22:53,890
likely not performance critical and so

00:22:51,190 --> 00:22:56,710
what if every time we would return an

00:22:53,890 --> 00:22:59,200
error we sort of randomly perturbed the

00:22:56,710 --> 00:23:04,780
cache a bit before returning back to

00:22:59,200 --> 00:23:07,420
user space so for example any error

00:23:04,780 --> 00:23:09,340
that's that's a real error and not sort

00:23:07,420 --> 00:23:12,430
of a fake error like try again or

00:23:09,340 --> 00:23:14,980
something like that you might rewrite

00:23:12,430 --> 00:23:17,980
the cache there's also a new MSR that

00:23:14,980 --> 00:23:22,240
you can use on an Intel processors and

00:23:17,980 --> 00:23:24,640
thanks to the l 1tf issue we know how an

00:23:22,240 --> 00:23:26,680
MSR that we can use to wipe out parts of

00:23:24,640 --> 00:23:29,500
the cache and otherwise you can do it

00:23:26,680 --> 00:23:34,870
the old-fashioned way just by reading

00:23:29,500 --> 00:23:39,190
random junk into it so this this would

00:23:34,870 --> 00:23:41,650
definitely impact performance on in the

00:23:39,190 --> 00:23:44,080
error path but it's really easy to

00:23:41,650 --> 00:23:46,840
implement it's very simple to understand

00:23:44,080 --> 00:23:50,410
it also would definitely make cache

00:23:46,840 --> 00:23:52,330
contents harder to guess on errors it

00:23:50,410 --> 00:23:54,640
would have increased at least with the

00:23:52,330 --> 00:23:57,940
PSE that I've done so far when you're

00:23:54,640 --> 00:24:00,630
not able to use the MSR it does come

00:23:57,940 --> 00:24:03,470
with increased memory consumption

00:24:00,630 --> 00:24:05,870
because of the junk that you have to

00:24:03,470 --> 00:24:08,030
putting into the POC I currently

00:24:05,870 --> 00:24:11,539
implemented it with sort of like a per

00:24:08,030 --> 00:24:14,030
CPU data area that's just you know twice

00:24:11,539 --> 00:24:17,179
as big as my l1 cache and just sort of

00:24:14,030 --> 00:24:19,220
randomly go out and touch it and and

00:24:17,179 --> 00:24:19,730
mess things up and I do mess things up

00:24:19,220 --> 00:24:24,530
pretty good

00:24:19,730 --> 00:24:34,880
so anyway I'm curious what people think

00:24:24,530 --> 00:24:37,340
about this idea it seems like a good

00:24:34,880 --> 00:24:39,980
idea to me especially given that many of

00:24:37,340 --> 00:24:42,650
the cache probing attacks involve

00:24:39,980 --> 00:24:46,940
sending some wildly you know out of

00:24:42,650 --> 00:24:48,890
bounds index into some system call so if

00:24:46,940 --> 00:24:51,080
the system call is returning you know

00:24:48,890 --> 00:24:53,659
you know Ian valor like what the hell

00:24:51,080 --> 00:24:56,330
are you doing yeah having it do

00:24:53,659 --> 00:24:59,090
something like that that slows down you

00:24:56,330 --> 00:25:00,710
know the attacker is actually kind of a

00:24:59,090 --> 00:25:04,010
good thing I think this is along the

00:25:00,710 --> 00:25:06,380
lines of you know possibly being able to

00:25:04,010 --> 00:25:09,169
do some sort of intrusion detection by

00:25:06,380 --> 00:25:11,990
monitoring you know the error rates of

00:25:09,169 --> 00:25:13,580
system calls on processes right so

00:25:11,990 --> 00:25:15,880
there's probably I think a lot of

00:25:13,580 --> 00:25:19,070
exploration that could be done there

00:25:15,880 --> 00:25:22,940
yeah so to sort of be more intelligent

00:25:19,070 --> 00:25:24,500
about applying it if you know that

00:25:22,940 --> 00:25:25,700
you're going to be generating this is

00:25:24,500 --> 00:25:29,600
going to be slowing things down could

00:25:25,700 --> 00:25:31,010
you use it as attack as well if you know

00:25:29,600 --> 00:25:32,360
you're gonna be what if you know that

00:25:31,010 --> 00:25:34,220
this is going to generate a performance

00:25:32,360 --> 00:25:39,110
hit could you possibly be using this as

00:25:34,220 --> 00:25:42,289
an attack an attack dos attack yeah

00:25:39,110 --> 00:25:44,919
Oh a das attack the performance hit is

00:25:42,289 --> 00:25:44,919
not that bad

00:25:50,200 --> 00:25:59,810
I'd be curious to see to get numbers on

00:25:54,770 --> 00:26:02,570
how much it affected the existing cash

00:25:59,810 --> 00:26:05,120
attacks the side channels with with

00:26:02,570 --> 00:26:07,550
meltdown for example actually you know

00:26:05,120 --> 00:26:12,140
take this mitigation and apply it with

00:26:07,550 --> 00:26:15,170
an unmitigated a CPU that's vulnerable

00:26:12,140 --> 00:26:18,710
to meltdown and see what it does to it

00:26:15,170 --> 00:26:19,730
and try to change I mean I imagine it

00:26:18,710 --> 00:26:21,830
would break all of the existing

00:26:19,730 --> 00:26:23,870
reproducers but if you can try to update

00:26:21,830 --> 00:26:27,050
the reproducer to say okay to bypass

00:26:23,870 --> 00:26:30,020
this we need to sample it you know a

00:26:27,050 --> 00:26:33,740
thousand times more or a million times

00:26:30,020 --> 00:26:36,050
more to sort of gauge how much this this

00:26:33,740 --> 00:26:38,030
would affect it because I mean I guess

00:26:36,050 --> 00:26:39,950
if you clear all of the cash then you

00:26:38,030 --> 00:26:42,470
have no signal but if you're doing the

00:26:39,950 --> 00:26:45,650
random updates then trying to get a

00:26:42,470 --> 00:26:48,320
sense of how much it yeah so that's the

00:26:45,650 --> 00:26:50,780
part I haven't got sorted out yet I mean

00:26:48,320 --> 00:26:53,180
right now in my POC I just clear the

00:26:50,780 --> 00:26:54,980
entire cache but I I feel like that's

00:26:53,180 --> 00:26:59,210
probably overkill that you don't really

00:26:54,980 --> 00:27:02,030
need to do that sometimes some time ago

00:26:59,210 --> 00:27:06,560
I've heard about Intel casual occasion

00:27:02,030 --> 00:27:08,710
technology maybe we can think not about

00:27:06,560 --> 00:27:12,500
supporting the cache but about

00:27:08,710 --> 00:27:16,130
separating isolating caches for various

00:27:12,500 --> 00:27:19,850
groups of processes so the cache

00:27:16,130 --> 00:27:21,890
allocation technology it's not my area

00:27:19,850 --> 00:27:24,980
of expertise but my understanding is

00:27:21,890 --> 00:27:28,190
that it applies to l3 cache and not l1

00:27:24,980 --> 00:27:31,820
cache so I think we still have some some

00:27:28,190 --> 00:27:35,710
issues I would ask I would want to ask

00:27:31,820 --> 00:27:39,290
about the implementation of such

00:27:35,710 --> 00:27:42,200
modifications of cars because to me it

00:27:39,290 --> 00:27:45,350
seems that it would require basically a

00:27:42,200 --> 00:27:48,170
lot of manual work because for example

00:27:45,350 --> 00:27:51,050
when we have something like aia control

00:27:48,170 --> 00:27:53,360
then we have a lot of sometimes we have

00:27:51,050 --> 00:27:55,610
a lot of return error or this return

00:27:53,360 --> 00:27:58,580
error or that so is there a plan for

00:27:55,610 --> 00:28:00,710
some kind of implementation of this that

00:27:58,580 --> 00:28:05,030
would not require like

00:28:00,710 --> 00:28:07,070
thousands of repetitive code called

00:28:05,030 --> 00:28:10,040
insertions a macro or something like

00:28:07,070 --> 00:28:12,890
that so we have we have the MSR that

00:28:10,040 --> 00:28:16,010
they have in micro code that can be used

00:28:12,890 --> 00:28:18,050
on Intel platforms I don't know what's

00:28:16,010 --> 00:28:20,870
available on other architectures so I

00:28:18,050 --> 00:28:23,870
have been doing it the hard way

00:28:20,870 --> 00:28:26,780
in that case you know when that MSR is

00:28:23,870 --> 00:28:28,670
not supported and so cash probing

00:28:26,780 --> 00:28:31,010
techniques like priming probe and flush

00:28:28,670 --> 00:28:32,330
and reload typically rely on knowing

00:28:31,010 --> 00:28:35,270
something about the cache geometries

00:28:32,330 --> 00:28:38,590
you're probing a particular cache line

00:28:35,270 --> 00:28:42,920
or an alias in cache line so applying

00:28:38,590 --> 00:28:45,650
random cache perturbation is probably

00:28:42,920 --> 00:28:48,170
not it might lower the signal-to-noise

00:28:45,650 --> 00:28:50,510
ratio on those but it's there is still

00:28:48,170 --> 00:28:52,820
probably going to be a reasonable signal

00:28:50,510 --> 00:28:55,850
to noise ratio left over for those style

00:28:52,820 --> 00:28:57,530
of techniques so you you advocate wiping

00:28:55,850 --> 00:28:58,820
the entire cache I think if you were

00:28:57,530 --> 00:29:01,910
trying to just wiping the entire cache

00:28:58,820 --> 00:29:03,050
would be that what you have to do

00:29:01,910 --> 00:29:04,429
otherwise you're just lowering the

00:29:03,050 --> 00:29:06,290
signal-to-noise ratio I suspect that

00:29:04,429 --> 00:29:08,059
these things are quite resilient to

00:29:06,290 --> 00:29:09,500
random perturbation there are lots of

00:29:08,059 --> 00:29:11,750
papers on how they're Brazilian to

00:29:09,500 --> 00:29:14,240
timing perturbation I guess it would

00:29:11,750 --> 00:29:17,300
depend on how how random your you are

00:29:14,240 --> 00:29:18,920
right I mean they would I guess it

00:29:17,300 --> 00:29:20,390
depends I suspect the thing that it's

00:29:18,920 --> 00:29:22,700
critically dependent on is how many

00:29:20,390 --> 00:29:24,590
samples you can make over time yeah and

00:29:22,700 --> 00:29:26,390
given how resilient these things have

00:29:24,590 --> 00:29:28,429
been two-timing perturbation in the past

00:29:26,390 --> 00:29:31,070
I would strongly suspect they'll be

00:29:28,429 --> 00:29:32,990
resilient to random cache maintenance

00:29:31,070 --> 00:29:41,240
well it's certainly easier to just blow

00:29:32,990 --> 00:29:42,500
everything away okay thank you very much

00:29:41,240 --> 00:29:44,490
if you want to talk about any of this

00:29:42,500 --> 00:29:47,859
further I'm here

00:29:44,490 --> 00:29:47,859

YouTube URL: https://www.youtube.com/watch?v=K863u0ppCzs


