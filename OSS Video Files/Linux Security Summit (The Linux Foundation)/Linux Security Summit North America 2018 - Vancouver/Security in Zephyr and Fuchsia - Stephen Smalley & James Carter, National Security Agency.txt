Title: Security in Zephyr and Fuchsia - Stephen Smalley & James Carter, National Security Agency
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Security in Zephyr and Fuchsia - Stephen Smalley & James Carter, National Security Agency

Zephyr and Fuchsia are two emerging open source operating systems with very different architectures and approaches to security compared to each other and to Linux. Zephyr is a real-time operating system (RTOS) targeting Internet of Things (IoT) devices that are too resource-constrained to run Linux. Fuchsia is a capability-based microkernel operating system targeting more capable devices and computers. In this talk, we present the architecture and security mechanisms of these two operating systems, discuss ongoing work by ourselves and others to further advance their security, and compare their security features to those of Linux and Linux-based systems such as Android.

About James Carter
James Carter is a computer security researcher in the Information Assurance Research group of the National Security Agency (NSA). He presently is working to improve Security-Enhanced Linux (SELinux) policy development through tools and policy language improvements and serves as one of the userspace maintainers for SELinux. 

Previously, Mr. Carter led the development of the Common Intermediate Language (CIL) compiler and userspace for SELinux and he assisted in the early work on Security Enhancements for Android (SE for Android).

Mr. Carterâ€™s prior public speaking engagements have included the Linux Plumbers Conference, the SELinux Developers Summit, and the SELinux Symposium.

About Stephen Smalley
Stephen Smalley is a computer security researcher in the Information Assurance Research organization of the US National Security Agency (NSA). He presently leads the NSA's Security Enhancements (SE) for the Internet of Things (IoT) project, which is investigating and and advancing the security of IoT operating systems, as well as continuing to serve as one of the kernel and userspace maintainers for SELinux. Previously, Mr. Smalley led the development and successful technology transfer of Security Enhancements for Android (SE for Android) and Security-Enhanced Linux (SELinux) to mainline Android and Linux respectively.

Mr. Smalley's prior public speaking engagements have included the OpenXT Summit, the Linux Security Summit, LinuxCon North America, the Network and Distributed System Security (NDSS) Symposium, and the Android Builders Summit among others.
Captions: 
	00:00:00,000 --> 00:00:04,020
I'm Steven smiley and James Carter is

00:00:02,399 --> 00:00:05,970
sitting down here and we'll be coming up

00:00:04,020 --> 00:00:07,830
a little bit later to take over part of

00:00:05,970 --> 00:00:09,690
this talk and we work for the US

00:00:07,830 --> 00:00:12,179
National Security Agency and today we'll

00:00:09,690 --> 00:00:16,410
be talking about security in the zephyr

00:00:12,179 --> 00:00:17,970
and fuchsia operating systems so James

00:00:16,410 --> 00:00:20,580
and I work for the information assurance

00:00:17,970 --> 00:00:22,020
research organization of the NSA and

00:00:20,580 --> 00:00:23,939
that's an organization that is

00:00:22,020 --> 00:00:25,650
specifically focused on doing research

00:00:23,939 --> 00:00:28,140
and development in support of the

00:00:25,650 --> 00:00:30,929
agency's information assurance or

00:00:28,140 --> 00:00:32,700
defensive mission to protect information

00:00:30,929 --> 00:00:34,350
and information systems that have been

00:00:32,700 --> 00:00:36,930
designated as relevant to national

00:00:34,350 --> 00:00:39,270
security and as an organization we've

00:00:36,930 --> 00:00:41,250
existed for very long time we were

00:00:39,270 --> 00:00:43,640
originally carved out of what was known

00:00:41,250 --> 00:00:45,510
as the national computer Security Center

00:00:43,640 --> 00:00:46,980
within the information assurance

00:00:45,510 --> 00:00:48,480
research organization we work

00:00:46,980 --> 00:00:50,670
particularly for a team called trust

00:00:48,480 --> 00:00:52,770
mechanisms and our team is particularly

00:00:50,670 --> 00:00:54,469
focused on research and development in

00:00:52,770 --> 00:00:57,360
the area of both hardware and software

00:00:54,469 --> 00:00:59,670
security architectures and mechanisms to

00:00:57,360 --> 00:01:03,690
enable us to obtain trust in computing

00:00:59,670 --> 00:01:06,180
platforms while our organization is much

00:01:03,690 --> 00:01:07,799
older I myself had been involved in this

00:01:06,180 --> 00:01:11,549
body of research and development for the

00:01:07,799 --> 00:01:14,070
past 25 years going back to the

00:01:11,549 --> 00:01:16,170
distributed trusted Mach system and a

00:01:14,070 --> 00:01:19,049
series of successor research systems

00:01:16,170 --> 00:01:21,060
that we developed jointly with various

00:01:19,049 --> 00:01:24,630
university and other external research

00:01:21,060 --> 00:01:26,490
partners our team was the first within

00:01:24,630 --> 00:01:28,740
NSA and probably at the US intelligence

00:01:26,490 --> 00:01:30,869
community to create and release

00:01:28,740 --> 00:01:33,630
open-source software in the form of SD

00:01:30,869 --> 00:01:36,570
Linux or security enhanced Linux back in

00:01:33,630 --> 00:01:39,030
2000 and since that time we've gone on

00:01:36,570 --> 00:01:42,090
to a long history of open source

00:01:39,030 --> 00:01:45,680
collaboration and contribution impacting

00:01:42,090 --> 00:01:45,680
the security of many different systems

00:01:45,799 --> 00:01:49,829
so today we're going to be talking about

00:01:47,729 --> 00:01:52,560
two emerging open source operating

00:01:49,829 --> 00:01:56,340
systems both of which were open sourced

00:01:52,560 --> 00:01:58,409
in 2016 for the first time and these two

00:01:56,340 --> 00:02:00,479
open source operating systems are

00:01:58,409 --> 00:02:01,740
targeting very different use cases from

00:02:00,479 --> 00:02:03,840
one another that we'll be talking about

00:02:01,740 --> 00:02:06,090
and they have very different operating

00:02:03,840 --> 00:02:09,000
system architectures both from each

00:02:06,090 --> 00:02:10,170
other and from Linux today we'll be

00:02:09,000 --> 00:02:12,690
looking at the operating system

00:02:10,170 --> 00:02:13,740
architectures and security mechanisms of

00:02:12,690 --> 00:02:15,810
these two systems

00:02:13,740 --> 00:02:18,480
we'll look at some prior and ongoing

00:02:15,810 --> 00:02:20,550
work to advance their security and we'll

00:02:18,480 --> 00:02:23,010
touch on how they compare with Linux

00:02:20,550 --> 00:02:25,200
based systems although a full review of

00:02:23,010 --> 00:02:32,070
that would exceed the time for this talk

00:02:25,200 --> 00:02:33,780
so zephyr is a open-source project that

00:02:32,070 --> 00:02:35,960
is seeking to provide a cross

00:02:33,780 --> 00:02:39,030
architecture and vendor independent

00:02:35,960 --> 00:02:40,620
real-time operating system specifically

00:02:39,030 --> 00:02:43,530
supporting the needs of Internet of

00:02:40,620 --> 00:02:45,330
Things devices it's actually sponsored

00:02:43,530 --> 00:02:47,400
by the Linux Foundation but originates

00:02:45,330 --> 00:02:49,770
out of a long history of real-time

00:02:47,400 --> 00:02:52,290
operating systems they came out of wind

00:02:49,770 --> 00:02:55,740
river systems and which was subsequently

00:02:52,290 --> 00:02:57,780
open sourced zephyr is specifically

00:02:55,740 --> 00:03:00,360
targeting devices where linux is not

00:02:57,780 --> 00:03:03,560
considered viable either due to resource

00:03:00,360 --> 00:03:06,900
constraints or for real-time or others

00:03:03,560 --> 00:03:09,030
requirements and so in particular zephyr

00:03:06,900 --> 00:03:11,550
is currently supported on 32-bit

00:03:09,030 --> 00:03:13,590
microcontrollers ranging from as little

00:03:11,550 --> 00:03:16,890
as 8 kilobytes of RAM up to a few

00:03:13,590 --> 00:03:19,740
megabytes and in that ecosystem Zephyr

00:03:16,890 --> 00:03:22,530
is really trying to become the new Linux

00:03:19,740 --> 00:03:25,290
for little devices a common platform

00:03:22,530 --> 00:03:27,900
where both hardware and software vendors

00:03:25,290 --> 00:03:32,190
can collaborate on a shared platform and

00:03:27,900 --> 00:03:34,800
have that common ecosystem from its

00:03:32,190 --> 00:03:36,990
beginning zephyr had security as a

00:03:34,800 --> 00:03:38,640
stated goal and focus although as we'll

00:03:36,990 --> 00:03:40,410
see in a bit what they meant by that

00:03:38,640 --> 00:03:44,570
might differ a little bit in terms of

00:03:40,410 --> 00:03:44,570
what we think of normally in security so

00:03:44,930 --> 00:03:51,510
when it was first released in 2016

00:03:47,730 --> 00:03:54,000
Zephyr had a model in which one created

00:03:51,510 --> 00:03:56,490
a single executable single address space

00:03:54,000 --> 00:03:59,130
operating system the kernel was simply a

00:03:56,490 --> 00:04:03,300
library linked into the application and

00:03:59,130 --> 00:04:04,650
there was only one at a time and all of

00:04:03,300 --> 00:04:06,330
the threads within it would brought him

00:04:04,650 --> 00:04:08,430
fully privileged in supervisor mode

00:04:06,330 --> 00:04:11,070
there's no form of hardware based memory

00:04:08,430 --> 00:04:13,290
protection a new virtual memory and this

00:04:11,070 --> 00:04:15,270
kind of a model is actually quite common

00:04:13,290 --> 00:04:17,040
in many real-time operating systems

00:04:15,270 --> 00:04:20,310
targeting this kind of low end hardware

00:04:17,040 --> 00:04:22,530
and because they're generally running a

00:04:20,310 --> 00:04:24,390
single application which often has full

00:04:22,530 --> 00:04:25,830
access to the hardware in question that

00:04:24,390 --> 00:04:27,300
it's driving and they're very much

00:04:25,830 --> 00:04:28,949
focused on minimizing

00:04:27,300 --> 00:04:31,229
their footprints and any overheads

00:04:28,949 --> 00:04:34,710
associated due to this extremely tight

00:04:31,229 --> 00:04:36,389
resource constraints and so while Zephir

00:04:34,710 --> 00:04:37,889
head security as a stated goal in focus

00:04:36,389 --> 00:04:39,690
from the beginning its notion of

00:04:37,889 --> 00:04:42,629
security was primarily focused on its

00:04:39,690 --> 00:04:44,879
development process and code auditing

00:04:42,629 --> 00:04:47,729
practices the use of common static

00:04:44,879 --> 00:04:50,159
analysis tools providing some sore mo

00:04:47,729 --> 00:04:51,629
secure update and providing common

00:04:50,159 --> 00:04:53,159
libraries and infrastructure for

00:04:51,629 --> 00:04:55,259
cryptography to provide secure

00:04:53,159 --> 00:04:56,849
communications and the like not on what

00:04:55,259 --> 00:05:00,710
we would typically think of in terms of

00:04:56,849 --> 00:05:00,710
operating system protection mechanisms

00:05:01,490 --> 00:05:06,060
however even in the context of these

00:05:03,990 --> 00:05:07,440
highly resource constrained single

00:05:06,060 --> 00:05:08,759
application devices there are number of

00:05:07,440 --> 00:05:10,830
reasons why we might want to have

00:05:08,759 --> 00:05:12,870
operating system protection mechanisms

00:05:10,830 --> 00:05:14,909
these can range from increasing the

00:05:12,870 --> 00:05:16,919
difficulty of exploitation of software

00:05:14,909 --> 00:05:20,159
flaws in the real-time operating system

00:05:16,919 --> 00:05:22,800
to containing the damage from any given

00:05:20,159 --> 00:05:24,659
flaw to sandboxing components of the

00:05:22,800 --> 00:05:26,759
system that may be handling untrusted

00:05:24,659 --> 00:05:29,400
data whether that's the network protocol

00:05:26,759 --> 00:05:32,490
or whether it might be an interpreter

00:05:29,400 --> 00:05:33,960
for some sort of higher level support we

00:05:32,490 --> 00:05:36,300
also may wish to protect the integrity

00:05:33,960 --> 00:05:39,270
of certain portions of what's going on

00:05:36,300 --> 00:05:40,949
on the device protecting its the

00:05:39,270 --> 00:05:42,659
integrity of critical components or

00:05:40,949 --> 00:05:43,770
ensuring that certain functionality

00:05:42,659 --> 00:05:46,889
can't be bypassed

00:05:43,770 --> 00:05:48,810
on the device and in many cases in order

00:05:46,889 --> 00:05:51,360
to bootstrap trust in the device we need

00:05:48,810 --> 00:05:54,210
to protect some form of long term key on

00:05:51,360 --> 00:05:56,340
the device against leakage even aside

00:05:54,210 --> 00:05:58,080
from security considerations we

00:05:56,340 --> 00:05:59,940
generally can benefit from these

00:05:58,080 --> 00:06:02,069
operating system protection mechanisms

00:05:59,940 --> 00:06:04,349
simply and improving the robustness of

00:06:02,069 --> 00:06:06,029
the system both when it's deployed as

00:06:04,349 --> 00:06:08,699
well as helping application developers

00:06:06,029 --> 00:06:10,440
during the development cycle to catch

00:06:08,699 --> 00:06:15,090
errors at an early phase in their

00:06:10,440 --> 00:06:18,120
process while we've been participating

00:06:15,090 --> 00:06:19,800
in the Zephyr security work much of the

00:06:18,120 --> 00:06:20,940
Zephyr protection work has been done by

00:06:19,800 --> 00:06:22,770
the core software developers

00:06:20,940 --> 00:06:25,199
particularly from Intel for the x86

00:06:22,770 --> 00:06:27,080
architecture from lonardo for arm and

00:06:25,199 --> 00:06:29,849
from synopsis for the art architecture

00:06:27,080 --> 00:06:31,379
along the course this presentation will

00:06:29,849 --> 00:06:34,039
identify some of our own specific

00:06:31,379 --> 00:06:34,039
contributions

00:06:35,660 --> 00:06:40,640
Zephyr is limited by the the hardware

00:06:39,290 --> 00:06:42,290
that it's targeting these

00:06:40,640 --> 00:06:43,850
microcontrollers and mostly smack

00:06:42,290 --> 00:06:45,890
patrollers lacked a memory management

00:06:43,850 --> 00:06:48,230
unit and thus they provide no support

00:06:45,890 --> 00:06:50,600
for virtual memory some of them however

00:06:48,230 --> 00:06:53,840
have with known as a memory protection

00:06:50,600 --> 00:06:56,600
unit or mpu a more constrained component

00:06:53,840 --> 00:06:59,030
that does support a small number of

00:06:56,600 --> 00:07:02,510
discreetly protected physical memory

00:06:59,030 --> 00:07:04,400
regions often as few as eight distinct

00:07:02,510 --> 00:07:07,190
regions although within this it is

00:07:04,400 --> 00:07:09,320
possible to carve out sub regions these

00:07:07,190 --> 00:07:12,020
effuse are also very committed in terms

00:07:09,320 --> 00:07:14,540
of their flexibility and the classical

00:07:12,020 --> 00:07:17,570
RMP use prior to their latest generation

00:07:14,540 --> 00:07:19,730
of microcontroller these empty use

00:07:17,570 --> 00:07:22,640
required that each region have a power

00:07:19,730 --> 00:07:24,620
of two size and be aligned to the size

00:07:22,640 --> 00:07:26,150
of the region greatly limiting the

00:07:24,620 --> 00:07:29,270
ability to apply this with any

00:07:26,150 --> 00:07:31,760
granularity other MP implementations

00:07:29,270 --> 00:07:37,490
such as nxp is offered a wider range of

00:07:31,760 --> 00:07:40,850
flexibility Zephir also had a number of

00:07:37,490 --> 00:07:42,470
constraints that were imposed on the

00:07:40,850 --> 00:07:45,260
design of operating system protection

00:07:42,470 --> 00:07:47,120
mechanisms for it since suffer is

00:07:45,260 --> 00:07:49,670
targeting this very low end hardware and

00:07:47,120 --> 00:07:51,410
these microcontroller based devices they

00:07:49,670 --> 00:07:53,030
wanted to ensure that as they designed

00:07:51,410 --> 00:07:55,460
protection mechanisms for the operating

00:07:53,030 --> 00:07:57,980
system that they would be supportable on

00:07:55,460 --> 00:08:00,140
typical microcontroller boards and so

00:07:57,980 --> 00:08:02,360
while the zephyros protection mechanisms

00:08:00,140 --> 00:08:04,940
can make use of an MMU if one is

00:08:02,360 --> 00:08:08,500
available they need to also function

00:08:04,940 --> 00:08:11,390
even in the context of mpu only boards

00:08:08,500 --> 00:08:13,010
Zephir had also already made a number of

00:08:11,390 --> 00:08:14,900
releases and had been around for a

00:08:13,010 --> 00:08:17,000
little bit before this OS protection

00:08:14,900 --> 00:08:18,470
work began and so there was a key

00:08:17,000 --> 00:08:21,200
compatibility constraint for the

00:08:18,470 --> 00:08:22,880
software developers in order to avoid

00:08:21,200 --> 00:08:24,500
compatibility breakage both for

00:08:22,880 --> 00:08:27,410
application developers as well as for

00:08:24,500 --> 00:08:30,560
drivers and thus they sought to minimize

00:08:27,410 --> 00:08:32,120
changes to the colonel's interfaces and

00:08:30,560 --> 00:08:34,849
couldn't do some kind of wholesale

00:08:32,120 --> 00:08:37,010
rewrite of the kernel api's to provide a

00:08:34,849 --> 00:08:38,510
typical encapsulation of the kernel

00:08:37,010 --> 00:08:39,919
objects using handles or file

00:08:38,510 --> 00:08:43,940
descriptors that you might find in the

00:08:39,919 --> 00:08:46,850
system like Linux also do do their focus

00:08:43,940 --> 00:08:49,310
on real-time there was a key need to

00:08:46,850 --> 00:08:50,900
minimize and bound with memory and

00:08:49,310 --> 00:08:53,390
runtime overheads throughout the system

00:08:50,900 --> 00:08:54,800
and so he designed philosophy that

00:08:53,390 --> 00:08:56,360
you'll see in the zephyr protection

00:08:54,800 --> 00:08:59,720
mechanisms as they do as much as

00:08:56,360 --> 00:09:01,160
possible at Build time and then what

00:08:59,720 --> 00:09:03,320
they can't do a build time to do as much

00:09:01,160 --> 00:09:05,180
as possible at boot time minimizing any

00:09:03,320 --> 00:09:08,210
kind of runtime overheads and ensuring

00:09:05,180 --> 00:09:10,430
that they have bounded latency and then

00:09:08,210 --> 00:09:12,080
lastly the designers of the Zephyr

00:09:10,430 --> 00:09:14,570
protection mechanisms needed to ensure

00:09:12,080 --> 00:09:16,430
that they would have no impact on their

00:09:14,570 --> 00:09:18,830
ability to continue to support very low

00:09:16,430 --> 00:09:20,690
end hardware and thus these features

00:09:18,830 --> 00:09:23,060
need to remain fully configurable and

00:09:20,690 --> 00:09:30,589
imposed no overheads if disabled in the

00:09:23,060 --> 00:09:33,020
configuration so beginning in the one

00:09:30,589 --> 00:09:34,310
eighth release of zephyr and officially

00:09:33,020 --> 00:09:36,320
supported in the one nine releases

00:09:34,310 --> 00:09:39,050
effort began introducing basic Hardware

00:09:36,320 --> 00:09:41,029
enforced memory protections these are

00:09:39,050 --> 00:09:43,790
dependent on either the microcontroller

00:09:41,029 --> 00:09:46,880
having a memory protection unit or an

00:09:43,790 --> 00:09:48,440
MMU either one will suffice and they

00:09:46,880 --> 00:09:50,390
enforce sort of your conventional

00:09:48,440 --> 00:09:52,400
read-only know execute restrictions

00:09:50,390 --> 00:09:54,050
protecting the kernels text and

00:09:52,400 --> 00:09:56,690
read-only data against tampering and

00:09:54,050 --> 00:09:59,420
ensuring that data and the stack and the

00:09:56,690 --> 00:10:02,630
like aren't executable they also provide

00:09:59,420 --> 00:10:04,900
runtime guarantees to catch that death

00:10:02,630 --> 00:10:08,870
overflows through a conventional guard

00:10:04,900 --> 00:10:11,240
region mechanism most of the work here

00:10:08,870 --> 00:10:13,400
is done at build and boot time only so

00:10:11,240 --> 00:10:15,710
for example on x86 based architectures

00:10:13,400 --> 00:10:18,290
the actual page tables are generated

00:10:15,710 --> 00:10:19,700
during the build and at boot time they

00:10:18,290 --> 00:10:21,950
simply updated the corresponding

00:10:19,700 --> 00:10:23,930
register state and don't need to do any

00:10:21,950 --> 00:10:25,850
kind of dynamic manipulation there and

00:10:23,930 --> 00:10:27,710
then there's the corresponding runtime

00:10:25,850 --> 00:10:31,490
support for the actual stack depth

00:10:27,710 --> 00:10:33,140
overflow guard regions for this work our

00:10:31,490 --> 00:10:35,030
primary contribution aside from doing

00:10:33,140 --> 00:10:37,220
some review of the basic memory

00:10:35,030 --> 00:10:39,290
protections was to develop and

00:10:37,220 --> 00:10:41,839
contribute a set of kernel memory

00:10:39,290 --> 00:10:45,440
protection tests these these were

00:10:41,839 --> 00:10:47,120
modeled after the lkd TM tests in Linux

00:10:45,440 --> 00:10:49,670
from the kernel self protection project

00:10:47,120 --> 00:10:51,170
in order to validate that the guarantee

00:10:49,670 --> 00:10:54,020
is that they were claiming to provide

00:10:51,170 --> 00:10:56,089
were in fact being provided these were

00:10:54,020 --> 00:10:58,400
helpful both in the development of the

00:10:56,089 --> 00:11:00,320
suffer and PU drivers in caching some

00:10:58,400 --> 00:11:02,060
bugs in the original implementations and

00:11:00,320 --> 00:11:02,960
they subsequently also caught some

00:11:02,060 --> 00:11:04,280
regressions

00:11:02,960 --> 00:11:05,660
as the system has continued to evolve

00:11:04,280 --> 00:11:07,820
and they're now part of the standard

00:11:05,660 --> 00:11:13,340
regression testing that Zephyr performs

00:11:07,820 --> 00:11:15,560
on all future changes after creating

00:11:13,340 --> 00:11:17,630
this basic framework for hardware

00:11:15,560 --> 00:11:20,150
enforcement protections suffer then

00:11:17,630 --> 00:11:22,760
moved on to introduced support for user

00:11:20,150 --> 00:11:25,190
space since previously everything had

00:11:22,760 --> 00:11:26,330
been running in supervisor mode and so

00:11:25,190 --> 00:11:28,130
this was introduced for Intel

00:11:26,330 --> 00:11:30,380
architectures in the 110 release and

00:11:28,130 --> 00:11:32,690
then arm and arc added it in the 111

00:11:30,380 --> 00:11:34,460
release and this further builds upon the

00:11:32,690 --> 00:11:36,230
memory protection support and likewise

00:11:34,460 --> 00:11:37,850
requires either a hardware memory

00:11:36,230 --> 00:11:41,000
protection unit on the microcontroller

00:11:37,850 --> 00:11:43,160
or an MMU and it provides basic support

00:11:41,000 --> 00:11:45,560
for user mode threads with isolated

00:11:43,160 --> 00:11:48,170
memory but this is not a full process

00:11:45,560 --> 00:11:50,300
abstraction as we'll see later in the

00:11:48,170 --> 00:11:51,920
context of this work again in addition

00:11:50,300 --> 00:11:54,200
to providing some basic code review and

00:11:51,920 --> 00:11:57,500
feedback on the implementation we

00:11:54,200 --> 00:11:59,330
developed a set of user space tests that

00:11:57,500 --> 00:12:00,500
sought to validate again that the

00:11:59,330 --> 00:12:02,120
security properties that they were

00:12:00,500 --> 00:12:04,370
claiming to provide for the user mid

00:12:02,120 --> 00:12:06,800
threads were in fact being enforced and

00:12:04,370 --> 00:12:08,600
this was initially used to confirm the

00:12:06,800 --> 00:12:11,600
correctness of the Intel implemented

00:12:08,600 --> 00:12:12,740
this and then as the arm and our

00:12:11,600 --> 00:12:14,810
complementation x' were under

00:12:12,740 --> 00:12:17,120
development they used this test suite in

00:12:14,810 --> 00:12:19,520
order to validate themselves and to

00:12:17,120 --> 00:12:21,380
catch various issues as they progressed

00:12:19,520 --> 00:12:23,180
with that and once again this is now

00:12:21,380 --> 00:12:29,150
part of the standard regression testing

00:12:23,180 --> 00:12:30,830
used in Zephyr so in Suffern the

00:12:29,150 --> 00:12:33,050
operating system continues to have a

00:12:30,830 --> 00:12:35,090
single executable and address space and

00:12:33,050 --> 00:12:37,100
still just a physical address space

00:12:35,090 --> 00:12:41,090
there's no virtual memory on these even

00:12:37,100 --> 00:12:44,900
unsystematic and so we don't have a

00:12:41,090 --> 00:12:47,450
discrete virtual memory regions and so

00:12:44,900 --> 00:12:49,460
we we support user mode threads but not

00:12:47,450 --> 00:12:51,410
full processes again this is sort of

00:12:49,460 --> 00:12:52,940
conventional in this ecosystem of

00:12:51,410 --> 00:12:55,400
real-time operating systems on these

00:12:52,940 --> 00:12:57,740
low-end boards and so the application

00:12:55,400 --> 00:13:00,920
developer can launch specific threads as

00:12:57,740 --> 00:13:02,960
user mode threads and have them run deep

00:13:00,920 --> 00:13:05,300
privileged in that context at which

00:13:02,960 --> 00:13:06,920
point they can continue to execute from

00:13:05,300 --> 00:13:08,840
the text and read from the read-only

00:13:06,920 --> 00:13:11,150
data sections but then they're

00:13:08,840 --> 00:13:14,290
constrained in that they only have write

00:13:11,150 --> 00:13:16,050
access to their own per thread stack and

00:13:14,290 --> 00:13:17,820
then there's

00:13:16,050 --> 00:13:19,680
mechanism that Zephyr provides called

00:13:17,820 --> 00:13:22,529
memory domains which is an abstraction

00:13:19,680 --> 00:13:25,050
on top of the mpu or MMU functionality

00:13:22,529 --> 00:13:27,149
that allows the programmer to define

00:13:25,050 --> 00:13:29,820
shared memory regions between the user

00:13:27,149 --> 00:13:32,880
mid threads and then there's also a

00:13:29,820 --> 00:13:35,010
convenience feature that they created an

00:13:32,880 --> 00:13:36,500
application memory feature that would if

00:13:35,010 --> 00:13:39,089
enabled in the kernel configuration

00:13:36,500 --> 00:13:41,730
allow all of the user mode threads to

00:13:39,089 --> 00:13:47,040
access all of the Global's declared in

00:13:41,730 --> 00:13:48,990
the application section in order to

00:13:47,040 --> 00:13:51,959
support user space sefar had to

00:13:48,990 --> 00:13:54,899
introduce a collection of abstractions

00:13:51,959 --> 00:13:57,089
and mechanisms so first they needed some

00:13:54,899 --> 00:13:59,160
way to refer to kernel objects in the

00:13:57,089 --> 00:14:00,269
user mode threads as I mentioned earlier

00:13:59,160 --> 00:14:01,440
they were constrained in that they

00:14:00,269 --> 00:14:04,140
didn't feel they had the freedom

00:14:01,440 --> 00:14:05,970
completely rewrite the kernel api's and

00:14:04,140 --> 00:14:09,180
so they continue to pass kernel

00:14:05,970 --> 00:14:11,640
addresses as handles in those interfaces

00:14:09,180 --> 00:14:14,700
obviously exposing kernel addresses in

00:14:11,640 --> 00:14:17,339
that model in order to validate the

00:14:14,700 --> 00:14:19,950
addresses at Build time to generate a

00:14:17,339 --> 00:14:23,130
perfect hash for all the static kernel

00:14:19,950 --> 00:14:26,570
objects and thus the kernel can with

00:14:23,130 --> 00:14:28,950
fixed latency validate the addresses are

00:14:26,570 --> 00:14:30,570
pointing to actual legitimate kernel

00:14:28,950 --> 00:14:32,279
objects and this kernel objects live in

00:14:30,570 --> 00:14:33,899
the kernels memory which is protected

00:14:32,279 --> 00:14:36,660
using the memory protection mechanisms

00:14:33,899 --> 00:14:37,950
from direct access by user mode and then

00:14:36,660 --> 00:14:40,620
subsequently they've also introduced

00:14:37,950 --> 00:14:43,200
support for dynamic kernel objects and a

00:14:40,620 --> 00:14:45,570
mechanism for efficient validation of

00:14:43,200 --> 00:14:47,820
those they also added an object

00:14:45,570 --> 00:14:49,350
permissions model in which user mode

00:14:47,820 --> 00:14:51,329
threads have to first be granted

00:14:49,350 --> 00:14:52,980
permission to any given kernel object in

00:14:51,329 --> 00:14:55,050
order to access it and so that initial

00:14:52,980 --> 00:14:57,089
granting actually has to occur from the

00:14:55,050 --> 00:14:59,010
kernel mode thread so a kernel mode

00:14:57,089 --> 00:15:01,440
thread can grant access to a user mode

00:14:59,010 --> 00:15:03,270
thread or to itself and then an

00:15:01,440 --> 00:15:05,070
inheritance mechanism allows those

00:15:03,270 --> 00:15:08,040
permissions to be propagated down the

00:15:05,070 --> 00:15:10,290
chain of user mode threads this object

00:15:08,040 --> 00:15:11,850
permissions model in zephyr is purely an

00:15:10,290 --> 00:15:13,709
all-or-nothing you either have the

00:15:11,850 --> 00:15:16,230
ability to use a given kernel object

00:15:13,709 --> 00:15:18,600
using the system calls exposed for it or

00:15:16,230 --> 00:15:20,100
you don't there's no notion of per

00:15:18,600 --> 00:15:21,899
operation or readwrite distinctions

00:15:20,100 --> 00:15:23,430
currently in Suffern and it's not clear

00:15:21,899 --> 00:15:26,180
that that level of granularity is really

00:15:23,430 --> 00:15:28,500
necessary at this abstraction layer

00:15:26,180 --> 00:15:29,670
sever also had introduced a system call

00:15:28,500 --> 00:15:31,230
mechanism of course

00:15:29,670 --> 00:15:33,840
for using with threads to invoke kernel

00:15:31,230 --> 00:15:36,620
services and again focused on their

00:15:33,840 --> 00:15:38,880
whole design constraints of minimizing

00:15:36,620 --> 00:15:41,340
overheads and continued support low end

00:15:38,880 --> 00:15:44,370
boards they've introduced machinery that

00:15:41,340 --> 00:15:47,010
allows for these API calls to be

00:15:44,370 --> 00:15:49,140
transparently redirected to either

00:15:47,010 --> 00:15:51,390
direct kernel function calls or system

00:15:49,140 --> 00:15:53,250
calls depending upon whether the caller

00:15:51,390 --> 00:15:56,790
is a kernel mode caller or a user mode

00:15:53,250 --> 00:15:59,940
caller and so you can build an

00:15:56,790 --> 00:16:01,620
application that's purely kernel mode

00:15:59,940 --> 00:16:06,090
and everything can use to be direct

00:16:01,620 --> 00:16:07,470
function calls or you can construct an

00:16:06,090 --> 00:16:08,790
application where you have some kernel

00:16:07,470 --> 00:16:10,250
mode threads and some user mode threads

00:16:08,790 --> 00:16:13,020
and things will be handled correctly

00:16:10,250 --> 00:16:15,270
depending upon the callers state and

00:16:13,020 --> 00:16:17,580
then what they've been doing is they've

00:16:15,270 --> 00:16:19,200
been progressively building out the full

00:16:17,580 --> 00:16:21,780
scope of the kernel system call

00:16:19,200 --> 00:16:23,850
interface validating the current api's

00:16:21,780 --> 00:16:26,190
for their trust assumptions and then

00:16:23,850 --> 00:16:32,820
increasing the breadth of what's exposed

00:16:26,190 --> 00:16:34,860
to user mode so originally a zephyr

00:16:32,820 --> 00:16:36,870
provided a very coarse-grained

00:16:34,860 --> 00:16:39,030
application memory feature to let all

00:16:36,870 --> 00:16:39,630
user mode threads access all application

00:16:39,030 --> 00:16:41,250
Global's

00:16:39,630 --> 00:16:43,350
and so it's an all-or-nothing model and

00:16:41,250 --> 00:16:46,170
so there was no way if you enable this

00:16:43,350 --> 00:16:49,110
feature the only mechanism you would

00:16:46,170 --> 00:16:50,760
have to share memory between two user

00:16:49,110 --> 00:16:53,070
mode threads was the memory domain

00:16:50,760 --> 00:16:55,740
mechanism and that had a pretty high

00:16:53,070 --> 00:16:56,670
burden on the application developer the

00:16:55,740 --> 00:16:58,890
application developer would have to

00:16:56,670 --> 00:17:01,140
manually organize the application global

00:16:58,890 --> 00:17:03,090
layout in order to meet the NP specific

00:17:01,140 --> 00:17:05,250
restrictions and then they would have to

00:17:03,090 --> 00:17:06,900
manually set up these memory partitions

00:17:05,250 --> 00:17:08,970
and domains so I made it fairly

00:17:06,900 --> 00:17:11,610
difficult to define any notion of

00:17:08,970 --> 00:17:15,240
multiple logically isolated applications

00:17:11,610 --> 00:17:18,900
running on zephyr so to help with that

00:17:15,240 --> 00:17:21,150
problem we developed a new feature

00:17:18,900 --> 00:17:24,390
that's going to be coming out in the 113

00:17:21,150 --> 00:17:26,310
releases offer that supports a slightly

00:17:24,390 --> 00:17:28,110
more developer friendly way of grouping

00:17:26,310 --> 00:17:31,260
the application Global's based on how

00:17:28,110 --> 00:17:32,910
one wishes to grant access to them and

00:17:31,260 --> 00:17:34,680
then automatically generates

00:17:32,910 --> 00:17:38,280
behind-the-scene to the corresponding

00:17:34,680 --> 00:17:40,170
layouts and markings and the necessary

00:17:38,280 --> 00:17:41,970
memory partition definitions and the

00:17:40,170 --> 00:17:43,740
domain structures

00:17:41,970 --> 00:17:44,789
and so and then it provides a set of

00:17:43,740 --> 00:17:49,830
helpers to use the application

00:17:44,789 --> 00:17:51,539
developers work necessarily no panacea

00:17:49,830 --> 00:17:52,740
and when it comes to application

00:17:51,539 --> 00:17:55,620
development there's still an awful lot

00:17:52,740 --> 00:17:57,360
of knowledge required but is a small

00:17:55,620 --> 00:17:58,710
step forward towards the goal of being

00:17:57,360 --> 00:18:03,929
able to support multiple logically

00:17:58,710 --> 00:18:07,110
isolated applications so this is a

00:18:03,929 --> 00:18:08,850
simple example that was actually coded

00:18:07,110 --> 00:18:12,960
up to demonstrate this new application

00:18:08,850 --> 00:18:15,210
memory sharing facility and so in this

00:18:12,960 --> 00:18:17,510
context we have multiple user mode

00:18:15,210 --> 00:18:22,200
threads creating a very simple pipeline

00:18:17,510 --> 00:18:23,460
from plaintext to cipher text and so the

00:18:22,200 --> 00:18:25,169
goal here is to ensure that each of

00:18:23,460 --> 00:18:27,450
these are mid threads has its own

00:18:25,169 --> 00:18:30,210
private memory and then there's a shared

00:18:27,450 --> 00:18:32,070
memory buffer between each pair in the

00:18:30,210 --> 00:18:34,970
pipeline and that can be used to

00:18:32,070 --> 00:18:37,320
communicate the data across that

00:18:34,970 --> 00:18:39,000
providing a conventional pipeline bit

00:18:37,320 --> 00:18:40,559
for example in an SEO Linux world you

00:18:39,000 --> 00:18:46,679
might do through a type enforcement

00:18:40,559 --> 00:18:49,530
assured pipeline so these are some areas

00:18:46,679 --> 00:18:52,230
of interest to us in terms of future

00:18:49,530 --> 00:18:54,000
work with Zephyr and protection so

00:18:52,230 --> 00:18:55,500
currently as I mentioned the MP users

00:18:54,000 --> 00:18:58,740
are very constrained many of them only

00:18:55,500 --> 00:19:01,409
support eight discrete regions and so

00:18:58,740 --> 00:19:03,330
supporting a layer of mpu virtualization

00:19:01,409 --> 00:19:05,610
that would allow us to support a larger

00:19:03,330 --> 00:19:08,179
number of regions they get swapped in

00:19:05,610 --> 00:19:12,110
and out of the physical MPU on-demand

00:19:08,179 --> 00:19:14,490
would allow for greater flexibility and

00:19:12,110 --> 00:19:15,960
granularity as we move forward and some

00:19:14,490 --> 00:19:18,900
other real-time atlases have actually

00:19:15,960 --> 00:19:20,190
explored this as well currently as I

00:19:18,900 --> 00:19:22,890
mentioned we still have a single

00:19:20,190 --> 00:19:25,049
executable single address space OS and

00:19:22,890 --> 00:19:26,700
so actually splitting up the actual text

00:19:25,049 --> 00:19:28,320
and read-only data sections for the

00:19:26,700 --> 00:19:30,360
applications and supporting multiple

00:19:28,320 --> 00:19:33,240
ones of those for multiple applications

00:19:30,360 --> 00:19:35,669
as an area of interest to more fully

00:19:33,240 --> 00:19:38,669
support the notion of logically isolated

00:19:35,669 --> 00:19:40,320
applications the key area of concern for

00:19:38,669 --> 00:19:43,320
Zephyr of course is kernel soft

00:19:40,320 --> 00:19:45,090
protection and so we'd like to see

00:19:43,320 --> 00:19:47,610
greater incorporation of some of the

00:19:45,090 --> 00:19:51,690
defensive measures that are present and

00:19:47,610 --> 00:19:52,890
KSTP in the context of Zephyr but these

00:19:51,690 --> 00:19:54,659
will have to be tailored to the

00:19:52,890 --> 00:19:55,380
particular resource constraints and

00:19:54,659 --> 00:19:58,260
needs of

00:19:55,380 --> 00:19:59,970
Zephyr and as much as possible moving as

00:19:58,260 --> 00:20:02,130
much of the work as possible to build

00:19:59,970 --> 00:20:05,040
time in boot time minimizing any kind of

00:20:02,130 --> 00:20:07,260
runtime overheads their number of

00:20:05,040 --> 00:20:10,560
features coming in emerging our

00:20:07,260 --> 00:20:12,120
microcontroller hardware that we believe

00:20:10,560 --> 00:20:13,860
will enable us to construct more

00:20:12,120 --> 00:20:17,130
trustworthy architectures on these

00:20:13,860 --> 00:20:19,470
low-end devices in particular the mpu

00:20:17,130 --> 00:20:22,350
configuration support is becoming much

00:20:19,470 --> 00:20:24,540
more flexible in the next generation or

00:20:22,350 --> 00:20:27,320
the the generations it's just coming out

00:20:24,540 --> 00:20:30,060
now and arm has also released

00:20:27,320 --> 00:20:32,940
definitions for truss and support for

00:20:30,060 --> 00:20:36,320
microcontrollers which is specifically

00:20:32,940 --> 00:20:39,180
tailored there trustzone capability to

00:20:36,320 --> 00:20:40,740
microcontroller based devices and so

00:20:39,180 --> 00:20:43,860
being able to use that to construct a

00:20:40,740 --> 00:20:45,840
core rate of trust in the environment is

00:20:43,860 --> 00:20:48,960
an area of interest for us and then

00:20:45,840 --> 00:20:50,490
lastly as the work to support multiple

00:20:48,960 --> 00:20:52,650
logically separate applications

00:20:50,490 --> 00:20:54,360
continues ultimately we have an interest

00:20:52,650 --> 00:20:56,160
in exploring some form of Mantaray ax

00:20:54,360 --> 00:20:57,540
control but one suited to real-time

00:20:56,160 --> 00:20:59,010
operating systems and this would look

00:20:57,540 --> 00:21:00,990
very different from something like

00:20:59,010 --> 00:21:03,510
SELinux it would be more oriented

00:21:00,990 --> 00:21:05,400
towards build time application

00:21:03,510 --> 00:21:08,190
partitioning pipelining based on some

00:21:05,400 --> 00:21:11,570
static configuration for the system that

00:21:08,190 --> 00:21:11,570
an application developer could create

00:21:12,980 --> 00:21:18,420
all right so this little summary slide

00:21:16,740 --> 00:21:19,920
is not intended to be comprehensive or

00:21:18,420 --> 00:21:21,270
complete in any way but it kind of gives

00:21:19,920 --> 00:21:22,890
a little snapshot of some of the

00:21:21,270 --> 00:21:26,010
differences between Zephyr versus Linux

00:21:22,890 --> 00:21:28,290
and you have to understand you would

00:21:26,010 --> 00:21:30,750
never choose between Zephyr and Linux

00:21:28,290 --> 00:21:32,340
based on security right you're gonna

00:21:30,750 --> 00:21:34,590
choose between Zephyr and Linux based on

00:21:32,340 --> 00:21:39,240
your target Hardware right and what your

00:21:34,590 --> 00:21:42,750
particular goals are so Zephyr has over

00:21:39,240 --> 00:21:44,610
the past year or so gained support for

00:21:42,750 --> 00:21:46,560
some of the sort of common case

00:21:44,610 --> 00:21:49,590
protections that have been present in

00:21:46,560 --> 00:21:50,520
Linux for some time there's still no

00:21:49,590 --> 00:21:52,620
address space layout randomization

00:21:50,520 --> 00:21:55,350
support in Zephyr again it's just a

00:21:52,620 --> 00:21:57,300
physical address space and actually

00:21:55,350 --> 00:21:59,520
supporting that kind of a construct in a

00:21:57,300 --> 00:22:04,050
real-time OS on these low-end boards is

00:21:59,520 --> 00:22:05,970
somewhat challenging so again most

00:22:04,050 --> 00:22:08,040
likely moved to more of a build time

00:22:05,970 --> 00:22:08,470
randomization and maybe a small boot

00:22:08,040 --> 00:22:10,600
time

00:22:08,470 --> 00:22:13,480
location but certain things on these

00:22:10,600 --> 00:22:15,220
boards like the NPU itself have fixed

00:22:13,480 --> 00:22:17,110
physical addresses that you use to

00:22:15,220 --> 00:22:20,159
program them and it's not clear that one

00:22:17,110 --> 00:22:22,360
can in fact when we relocate those

00:22:20,159 --> 00:22:24,700
suffer also today has very much had a

00:22:22,360 --> 00:22:26,500
model where the kernel code is trusted

00:22:24,700 --> 00:22:28,720
and so again we'd like to see greater

00:22:26,500 --> 00:22:32,679
growth there of mitigations for Colonel

00:22:28,720 --> 00:22:34,870
bones and today it only has a user space

00:22:32,679 --> 00:22:35,950
thread model not a full process model

00:22:34,870 --> 00:22:37,600
they hid the cipher developers have

00:22:35,950 --> 00:22:40,659
plans to introduce more of a full

00:22:37,600 --> 00:22:43,330
process abstraction model but I believe

00:22:40,659 --> 00:22:45,640
that's only going to be on hardware that

00:22:43,330 --> 00:22:48,820
actually has mm used not on the very low

00:22:45,640 --> 00:22:50,559
end boards that only have MP use so

00:22:48,820 --> 00:22:51,520
typically in a zephyr world you're

00:22:50,559 --> 00:22:54,789
usually dealing with a single

00:22:51,520 --> 00:22:56,470
application as opposed to a multi

00:22:54,789 --> 00:22:58,690
application or a multi user type

00:22:56,470 --> 00:23:02,080
environment likens off like in Linux and

00:22:58,690 --> 00:23:03,400
then in Suffern the exact security

00:23:02,080 --> 00:23:04,770
guarantees you're going to get will tend

00:23:03,400 --> 00:23:08,020
to be very dependent on the particular

00:23:04,770 --> 00:23:11,020
sock you're using the particular kernel

00:23:08,020 --> 00:23:12,700
configuration and a lot of it depends a

00:23:11,020 --> 00:23:15,100
lot on the application developer whereas

00:23:12,700 --> 00:23:17,580
in Linux you have a number of core OS

00:23:15,100 --> 00:23:20,770
security features that are sort of

00:23:17,580 --> 00:23:25,240
neutral and common across all of those

00:23:20,770 --> 00:23:28,960
spectrums so the number of other

00:23:25,240 --> 00:23:30,970
resources on Zephyr security that you

00:23:28,960 --> 00:23:33,460
can find there's an excellent talk by

00:23:30,970 --> 00:23:35,650
Andrew boy of Intel embedded Linux

00:23:33,460 --> 00:23:37,510
conference earlier this year talking

00:23:35,650 --> 00:23:39,970
about the implementation of many of

00:23:37,510 --> 00:23:43,360
these memory protection schemes and

00:23:39,970 --> 00:23:45,159
there's some user made documentation and

00:23:43,360 --> 00:23:48,000
with that I'll hand off to James Carter

00:23:45,159 --> 00:23:48,000
to speak about fuschia

00:23:50,900 --> 00:23:53,850
thank you for the applause I have only

00:23:52,980 --> 00:23:56,550
started you have you're already

00:23:53,850 --> 00:23:58,830
applauding me I'm glad that I have the

00:23:56,550 --> 00:24:00,510
view and that you because if you had the

00:23:58,830 --> 00:24:02,940
view that I did you would get nothing

00:24:00,510 --> 00:24:04,950
from this talk whatsoever and if I zone

00:24:02,940 --> 00:24:06,420
out just throw something at me I'm

00:24:04,950 --> 00:24:07,940
probably just watching a seaplane out

00:24:06,420 --> 00:24:10,350
there which is far more interesting than

00:24:07,940 --> 00:24:12,090
what I'm going to talk about probably at

00:24:10,350 --> 00:24:13,500
least to me all right so I'm talking

00:24:12,090 --> 00:24:15,780
about fuchsia so fuchsia is a

00:24:13,500 --> 00:24:17,970
microkernel based operating system it's

00:24:15,780 --> 00:24:20,250
primarily developed by Google but it's

00:24:17,970 --> 00:24:22,920
open source so it's very much like the

00:24:20,250 --> 00:24:26,490
Android model of development fuchsia

00:24:22,920 --> 00:24:28,710
develops our targets modern 64-bit

00:24:26,490 --> 00:24:30,240
machines with plenty of memory it has an

00:24:28,710 --> 00:24:32,490
object capability based security

00:24:30,240 --> 00:24:34,530
mechanism and it's very much work in

00:24:32,490 --> 00:24:37,770
progress so everything I say today could

00:24:34,530 --> 00:24:39,750
change tomorrow so at the heart of

00:24:37,770 --> 00:24:41,580
fuchsia is the zircon microkernel so

00:24:39,750 --> 00:24:44,250
this was initially derived from the

00:24:41,580 --> 00:24:46,440
linic little kernel LK which is an

00:24:44,250 --> 00:24:49,470
embedded kernel artists used in the

00:24:46,440 --> 00:24:51,180
Android bootloader so Zarkon extends LK

00:24:49,470 --> 00:24:54,060
to make it a microkernel with add

00:24:51,180 --> 00:24:56,100
support for 64-bit as a user mode as

00:24:54,060 --> 00:24:57,900
things like processes object

00:24:56,100 --> 00:25:00,030
capabilities IPC and all those things

00:24:57,900 --> 00:25:01,620
and so sir con is the only part of

00:25:00,030 --> 00:25:04,140
future that actually runs in supervisor

00:25:01,620 --> 00:25:06,000
mode its microkernel so drivers file

00:25:04,140 --> 00:25:10,530
system the network everything runs in

00:25:06,000 --> 00:25:12,090
user mode and so future has many

00:25:10,530 --> 00:25:14,550
different security mechanisms the

00:25:12,090 --> 00:25:16,380
primary one is the handles the regular

00:25:14,550 --> 00:25:19,500
and resource handles these are the

00:25:16,380 --> 00:25:22,230
object capabilities of zircon

00:25:19,500 --> 00:25:24,480
it also has job policy and V DSO

00:25:22,230 --> 00:25:26,760
enforcement and then in the user space

00:25:24,480 --> 00:25:29,340
namespaces in and sandbox and we're

00:25:26,760 --> 00:25:31,200
going to talk about each of these so

00:25:29,340 --> 00:25:34,020
first regular handles again these are

00:25:31,200 --> 00:25:35,850
object capabilities and these are the

00:25:34,020 --> 00:25:38,220
only way that user space can access the

00:25:35,850 --> 00:25:39,900
kernel kernel objects so fuschia is

00:25:38,220 --> 00:25:42,750
different in that he uses a push model

00:25:39,900 --> 00:25:45,120
so the client creates the handles and

00:25:42,750 --> 00:25:46,620
then pushes it to a server so which is

00:25:45,120 --> 00:25:48,540
very different like most systems so

00:25:46,620 --> 00:25:51,150
handles are processed and they're

00:25:48,540 --> 00:25:52,470
unforgeable they identify both an object

00:25:51,150 --> 00:25:55,230
and a set of access rights on that

00:25:52,470 --> 00:25:57,210
object and then with the proper access

00:25:55,230 --> 00:25:59,430
right you can do things like duplicate

00:25:57,210 --> 00:26:01,310
them with equal or lesser rights you can

00:25:59,430 --> 00:26:03,140
pass them across IPC

00:26:01,310 --> 00:26:05,510
and you can use them to attain handles

00:26:03,140 --> 00:26:09,320
to child objects using object get child

00:26:05,510 --> 00:26:11,390
with equal or lesser rights so there's a

00:26:09,320 --> 00:26:13,250
lot that's nice about handles they

00:26:11,390 --> 00:26:14,990
separate rights for propagation versus

00:26:13,250 --> 00:26:17,050
use right this was a problem with the

00:26:14,990 --> 00:26:19,550
first generation of capability systems

00:26:17,050 --> 00:26:21,800
also they separate rights for different

00:26:19,550 --> 00:26:23,090
operations which is good and you have

00:26:21,800 --> 00:26:24,830
the ability to reduce rights through

00:26:23,090 --> 00:26:27,860
handle duplication all these are good

00:26:24,830 --> 00:26:30,170
features do have some concerns object

00:26:27,860 --> 00:26:33,160
get child so if you have a handle to a

00:26:30,170 --> 00:26:36,440
job then you can get a handle to

00:26:33,160 --> 00:26:38,240
anything in that job or child jobs using

00:26:36,440 --> 00:26:40,550
an object get child this could be a

00:26:38,240 --> 00:26:43,340
problem it definitely means that a leak

00:26:40,550 --> 00:26:46,130
of the route job handle is fatal to the

00:26:43,340 --> 00:26:47,960
security system and currently that means

00:26:46,130 --> 00:26:50,690
anything that has access to dev misc

00:26:47,960 --> 00:26:52,340
system full can get access to the roof

00:26:50,690 --> 00:26:54,890
job handle again this is a work in

00:26:52,340 --> 00:26:57,860
progress system so not everything is as

00:26:54,890 --> 00:26:59,740
that will be down the road I'm also not

00:26:57,860 --> 00:27:02,120
much work has been done to make

00:26:59,740 --> 00:27:04,250
everything least privilege a lot of work

00:27:02,120 --> 00:27:05,840
needs to be done that way we would also

00:27:04,250 --> 00:27:09,080
like to see more assurance of just

00:27:05,840 --> 00:27:11,900
control over handle propagation and the

00:27:09,080 --> 00:27:13,910
the addition of replication for handles

00:27:11,900 --> 00:27:16,430
and again because it's a work in

00:27:13,910 --> 00:27:19,430
progress not operate not all operations

00:27:16,430 --> 00:27:22,880
check access rights and and some of the

00:27:19,430 --> 00:27:26,060
rights are unimplemented currently so

00:27:22,880 --> 00:27:27,890
resource handles are variant of a handle

00:27:26,060 --> 00:27:31,190
for platform resources these are things

00:27:27,890 --> 00:27:33,800
like memory mapped i/o IO ports IR

00:27:31,190 --> 00:27:36,710
queues and things so these allows you to

00:27:33,800 --> 00:27:39,050
specify a resource kind and optionally

00:27:36,710 --> 00:27:41,600
arrange for the resource and the route

00:27:39,050 --> 00:27:43,790
resource handle allows access to all

00:27:41,600 --> 00:27:45,290
resources so you can use a resource

00:27:43,790 --> 00:27:46,910
handle to get a more restrictive

00:27:45,290 --> 00:27:51,920
resource handle that has for example

00:27:46,910 --> 00:27:53,600
maybe a smaller range so so that's good

00:27:51,920 --> 00:27:56,720
it supports fine grained hierarchical

00:27:53,600 --> 00:27:59,120
resource restrictions very good its

00:27:56,720 --> 00:28:00,770
concern the the routes the route

00:27:59,120 --> 00:28:02,390
resource track is very granular right

00:28:00,770 --> 00:28:04,310
now a lot of things just check whether

00:28:02,390 --> 00:28:06,500
you have a handle to the route resource

00:28:04,310 --> 00:28:08,030
or not and so that essentially means

00:28:06,500 --> 00:28:10,310
that the route resource becomes sort of

00:28:08,030 --> 00:28:12,710
like caps astad min right now the way

00:28:10,310 --> 00:28:14,710
the way things are so a lot of work

00:28:12,710 --> 00:28:17,200
needs to be done to make things leaves

00:28:14,710 --> 00:28:18,909
again if the the root resource handle

00:28:17,200 --> 00:28:20,830
leaks then that can be fatal to the

00:28:18,909 --> 00:28:23,590
security of the system and again if you

00:28:20,830 --> 00:28:27,009
have asked access to Deb misc sinfull

00:28:23,590 --> 00:28:29,320
you get that resource handle and again

00:28:27,009 --> 00:28:31,840
we have some concerns over just control

00:28:29,320 --> 00:28:34,539
and just assurance of the handle

00:28:31,840 --> 00:28:36,730
propagation and support for revocation

00:28:34,539 --> 00:28:40,210
of resource handles would be nice as

00:28:36,730 --> 00:28:42,070
well so in fuchsia everything is part of

00:28:40,210 --> 00:28:45,850
a job so processes don't have child

00:28:42,070 --> 00:28:47,919
processes jobs to have child jobs so so

00:28:45,850 --> 00:28:50,620
jobs can contain both jobs and other

00:28:47,919 --> 00:28:53,230
processes the root job it contains all

00:28:50,620 --> 00:28:55,210
other jobs and processes and so a job

00:28:53,230 --> 00:28:58,299
policy then is applied to all processes

00:28:55,210 --> 00:29:00,460
within the job so when you create a job

00:28:58,299 --> 00:29:03,129
you assign a policy to it and then you

00:29:00,460 --> 00:29:04,870
add processes to that job so policies

00:29:03,129 --> 00:29:06,850
are inherited from your inherited from

00:29:04,870 --> 00:29:09,070
the parent and they can only be made

00:29:06,850 --> 00:29:10,870
more restrictive and there's policies

00:29:09,070 --> 00:29:12,250
over things like error handling behavior

00:29:10,870 --> 00:29:15,009
you know what do you do if you have an

00:29:12,250 --> 00:29:16,990
invalid handle over various types of

00:29:15,009 --> 00:29:19,960
object creation and the mapping of write

00:29:16,990 --> 00:29:21,730
execute memory so the fine-grained

00:29:19,960 --> 00:29:24,009
object creation policies are very good

00:29:21,730 --> 00:29:25,889
we like those the support for

00:29:24,009 --> 00:29:28,419
hierarchical job policies can be good

00:29:25,889 --> 00:29:30,460
there are some concerns the write

00:29:28,419 --> 00:29:32,409
execute policy is not implemented yet

00:29:30,460 --> 00:29:34,600
and even when it is it's going to cause

00:29:32,409 --> 00:29:37,360
problems with the strict hierarchical

00:29:34,600 --> 00:29:39,009
nature because if a child needs to map

00:29:37,360 --> 00:29:40,840
something write execute that would mean

00:29:39,009 --> 00:29:43,149
all ancestors need to Bay to map that

00:29:40,840 --> 00:29:44,590
thing write execute as well so the

00:29:43,149 --> 00:29:46,299
strict hierarchy is probably not gonna

00:29:44,590 --> 00:29:48,820
work down the little bit down the wrong

00:29:46,299 --> 00:29:50,500
down the road and again like everything

00:29:48,820 --> 00:29:52,659
else just a lot of work needs to be done

00:29:50,500 --> 00:29:53,769
to make things least privileged right

00:29:52,659 --> 00:29:55,509
now there's only two things that

00:29:53,769 --> 00:29:55,870
actually have a job policy assigned to

00:29:55,509 --> 00:29:59,230
them

00:29:55,870 --> 00:30:01,419
device drivers specify what to do with

00:29:59,230 --> 00:30:03,490
an invalid handle and the future job is

00:30:01,419 --> 00:30:06,700
not allowed to create processes by

00:30:03,490 --> 00:30:08,590
itself the last mechanism in the

00:30:06,700 --> 00:30:10,990
microkernel itself for security is the

00:30:08,590 --> 00:30:13,120
video so enforcement so the goal here is

00:30:10,990 --> 00:30:15,879
that the video be TSO is the only means

00:30:13,120 --> 00:30:18,490
for invoking system calls so it is fully

00:30:15,879 --> 00:30:21,070
read-only and the the kernel constrains

00:30:18,490 --> 00:30:24,580
its mapping he can only be mapped once

00:30:21,070 --> 00:30:26,059
per process that mapping must cover the

00:30:24,580 --> 00:30:28,070
entire video so

00:30:26,059 --> 00:30:30,739
and it can't be modified removed or

00:30:28,070 --> 00:30:33,229
overridden additionally the kernel

00:30:30,739 --> 00:30:35,450
restricts then where a system call comes

00:30:33,229 --> 00:30:37,399
from and it it needs to come from the

00:30:35,450 --> 00:30:40,580
expected location in the Vidya so and

00:30:37,399 --> 00:30:42,259
also you can have a video so variant as

00:30:40,580 --> 00:30:45,889
well which allows you to have subsets of

00:30:42,259 --> 00:30:47,840
the system call interface so again a

00:30:45,889 --> 00:30:50,629
lots of good things here it limits the

00:30:47,840 --> 00:30:53,149
kernel attack surface enforces the use

00:30:50,629 --> 00:30:54,559
of the public API supports process

00:30:53,149 --> 00:30:56,869
system call restrictions all of these

00:30:54,559 --> 00:30:59,269
are very good in addition the VDS code

00:30:56,869 --> 00:31:01,759
VDSL code is not trusted by the kernel

00:30:59,269 --> 00:31:04,909
so it's still fully valid dates such as

00:31:01,759 --> 00:31:06,739
call arguments of concern though is the

00:31:04,909 --> 00:31:09,669
potential for the tampering or bypassing

00:31:06,739 --> 00:31:11,599
the video so for example right now

00:31:09,669 --> 00:31:14,059
process right memory allows you to

00:31:11,599 --> 00:31:15,499
overwrite the video so this is known

00:31:14,059 --> 00:31:19,700
again this is just part of it being a

00:31:15,499 --> 00:31:21,019
work in progress and you know the speedy

00:31:19,700 --> 00:31:23,049
ISO enforcement doesn't have as much

00:31:21,019 --> 00:31:25,969
flexibility as something like set comp

00:31:23,049 --> 00:31:28,249
in the in the user space there's

00:31:25,969 --> 00:31:30,469
namespaces in sandboxes so namespace is

00:31:28,249 --> 00:31:32,690
just a collection of objects that you

00:31:30,469 --> 00:31:34,669
can enumerate and access its the

00:31:32,690 --> 00:31:38,479
composite hierarchy of services files

00:31:34,669 --> 00:31:40,429
and vices and namespaces component not

00:31:38,479 --> 00:31:42,019
global and they're constructed by the

00:31:40,429 --> 00:31:45,080
environment which instantiates a

00:31:42,019 --> 00:31:46,879
component so if a component needs to or

00:31:45,080 --> 00:31:49,339
wants to offer a service then they can

00:31:46,879 --> 00:31:51,799
extend the namespace and offer the

00:31:49,339 --> 00:31:54,950
service and then a sandbox then is for

00:31:51,799 --> 00:31:56,359
apps so that manager creates an app

00:31:54,950 --> 00:31:58,580
based on a manifest and there's a

00:31:56,359 --> 00:32:00,320
sandbox section in the manifest which

00:31:58,580 --> 00:32:05,179
specifies what the namespace should be

00:32:00,320 --> 00:32:07,190
for that app so no Bulba namespace is

00:32:05,179 --> 00:32:08,779
good the fact that object reach ability

00:32:07,190 --> 00:32:11,779
is determined by the initial names based

00:32:08,779 --> 00:32:13,849
also very good we would like to see

00:32:11,779 --> 00:32:15,349
sandbox is not just for application

00:32:13,849 --> 00:32:18,710
packages but for things like system

00:32:15,349 --> 00:32:20,570
services as well also we'd like to see

00:32:18,710 --> 00:32:23,149
more granularity for namespace and Sam

00:32:20,570 --> 00:32:25,820
boxes as well right currently you give

00:32:23,149 --> 00:32:27,559
access to say a directory and then that

00:32:25,820 --> 00:32:29,210
process has access to anything under

00:32:27,559 --> 00:32:32,539
that directory and you can't specify

00:32:29,210 --> 00:32:35,629
like an individual file only and

00:32:32,539 --> 00:32:38,389
additionally the sandbox in the manifest

00:32:35,629 --> 00:32:39,070
there's not a lot of keywords that you

00:32:38,389 --> 00:32:42,669
can use right now

00:32:39,070 --> 00:32:44,230
for the setting up the namespace also

00:32:42,669 --> 00:32:49,750
there's no independent validation of the

00:32:44,230 --> 00:32:51,009
sandbox configuration so sort of the

00:32:49,750 --> 00:32:54,190
means when the app manager creates the

00:32:51,009 --> 00:32:55,870
namespace it doesn't ask can this app or

00:32:54,190 --> 00:32:57,130
should this app actually have this

00:32:55,870 --> 00:32:58,870
namespace just whatever is in the

00:32:57,130 --> 00:33:00,279
manifest that's what it gives out of the

00:32:58,870 --> 00:33:03,429
namespace there's there's no actual

00:33:00,279 --> 00:33:05,350
enforcement of what it should have and

00:33:03,429 --> 00:33:09,759
everything right now uses a global data

00:33:05,350 --> 00:33:11,620
and global tamper the in progress nature

00:33:09,759 --> 00:33:14,909
of it the docs mentioned per package

00:33:11,620 --> 00:33:17,139
data in temp is just not implemented yet

00:33:14,909 --> 00:33:19,720
so let me give an example of just they

00:33:17,139 --> 00:33:22,389
just bootstrap and process creation so

00:33:19,720 --> 00:33:24,129
use a boot craze the device manager and

00:33:22,389 --> 00:33:26,080
exits it's not likin it it doesn't stick

00:33:24,129 --> 00:33:27,970
around the device manager creates a

00:33:26,080 --> 00:33:29,649
zircon drivers and services these are

00:33:27,970 --> 00:33:32,320
two separate jobs with multiple

00:33:29,649 --> 00:33:35,500
processes than them device manager also

00:33:32,320 --> 00:33:37,149
creates the service host the device

00:33:35,500 --> 00:33:39,159
manager creates the fuchsia job and then

00:33:37,149 --> 00:33:42,309
the app manager process in that job and

00:33:39,159 --> 00:33:44,259
the so the service host then acts as the

00:33:42,309 --> 00:33:46,809
the thing that creates processes in

00:33:44,259 --> 00:33:48,789
fuchsia but the caller then supplies all

00:33:46,809 --> 00:33:50,769
the handles for the processes so service

00:33:48,789 --> 00:33:52,480
host doesn't actually creating handles

00:33:50,769 --> 00:33:54,820
you pass all the handles in and it

00:33:52,480 --> 00:33:56,649
creates the process with those handles

00:33:54,820 --> 00:34:00,190
so the app manager provides the

00:33:56,649 --> 00:34:01,720
component creation facility so it

00:34:00,190 --> 00:34:03,309
creates handles but it's not allowed to

00:34:01,720 --> 00:34:05,799
create the processes so the way things

00:34:03,309 --> 00:34:08,050
work caller identifies a component app

00:34:05,799 --> 00:34:10,419
manager constructs a namespace based on

00:34:08,050 --> 00:34:14,220
the sandbox and then uses the service

00:34:10,419 --> 00:34:14,220
host to create the actual zircon process

00:34:14,250 --> 00:34:19,089
alright let me talk about mandatory

00:34:16,179 --> 00:34:20,829
access control now we think that a Mac

00:34:19,089 --> 00:34:23,649
framework could address some gaps left

00:34:20,829 --> 00:34:25,210
by fuchsias existing mechanisms it could

00:34:23,649 --> 00:34:27,639
help control propagation support

00:34:25,210 --> 00:34:29,200
revocation and police privilege could

00:34:27,639 --> 00:34:32,109
support finer grained checks and

00:34:29,200 --> 00:34:34,629
generalize the job policy and validate

00:34:32,109 --> 00:34:36,760
the namespace and sandboxing and support

00:34:34,629 --> 00:34:38,530
finer granularity in addition it just

00:34:36,760 --> 00:34:40,149
could provide a unified framework for

00:34:38,530 --> 00:34:42,429
defining enforcing and validating

00:34:40,149 --> 00:34:46,589
security goals for fuschia just like it

00:34:42,429 --> 00:34:49,060
has for for Android so our early work

00:34:46,589 --> 00:34:50,649
mostly Steve even though I've been in

00:34:49,060 --> 00:34:51,990
the office for 16 years I'm still the

00:34:50,649 --> 00:34:55,079
new guy

00:34:51,990 --> 00:34:57,200
so our early work was in the context of

00:34:55,079 --> 00:35:00,269
capability-based microkernel operating

00:34:57,200 --> 00:35:02,910
system so deep talk or DT Maki D toss

00:35:00,269 --> 00:35:04,799
for the Mach microkernel flats for the

00:35:02,910 --> 00:35:06,720
Fluke microkernel and in general we

00:35:04,799 --> 00:35:09,779
think that that capability systems and

00:35:06,720 --> 00:35:11,309
Mac really work well together and we've

00:35:09,779 --> 00:35:13,589
revisited Mac and capabilities

00:35:11,309 --> 00:35:15,660
repeatedly se Linux and UNIX file

00:35:13,589 --> 00:35:19,950
descriptors SC darwin and mock ports

00:35:15,660 --> 00:35:21,779
Android and binder so we have three

00:35:19,950 --> 00:35:24,480
different sort of options we can take as

00:35:21,779 --> 00:35:26,309
we as we go forward one we can build the

00:35:24,480 --> 00:35:28,529
the Mac framework entirely in user space

00:35:26,309 --> 00:35:29,700
with no microkernel support so in this

00:35:28,529 --> 00:35:32,640
case it would just be built on top of

00:35:29,700 --> 00:35:34,049
the existing capability system the

00:35:32,640 --> 00:35:35,910
second option would be mostly in user

00:35:34,049 --> 00:35:37,829
space with some microkernel support

00:35:35,910 --> 00:35:40,230
where we just extend the capability

00:35:37,829 --> 00:35:42,420
based system and then the last option is

00:35:40,230 --> 00:35:44,670
the security policy logic in the user

00:35:42,420 --> 00:35:46,380
space with full microkernel enforcement

00:35:44,670 --> 00:35:50,009
for the objects and this would be

00:35:46,380 --> 00:35:51,390
similar to our previous work so example

00:35:50,009 --> 00:35:53,250
all of our previous work is the flask

00:35:51,390 --> 00:35:56,880
security architecture this was the stuff

00:35:53,250 --> 00:35:59,130
done on on fluke and this is what

00:35:56,880 --> 00:36:00,690
selinux is based on so I see Linux is a

00:35:59,130 --> 00:36:03,710
application of the flask security Ark

00:36:00,690 --> 00:36:07,380
architecture for the monolithic Linux

00:36:03,710 --> 00:36:09,000
kernel so in flask the user space

00:36:07,380 --> 00:36:10,710
security server provides labeling and

00:36:09,000 --> 00:36:12,509
access decisions and then the

00:36:10,710 --> 00:36:15,029
microkernel and user space object

00:36:12,509 --> 00:36:16,559
manners bind labels to their objects and

00:36:15,029 --> 00:36:18,269
enforce security server decisions on

00:36:16,559 --> 00:36:20,099
their objects so the microkernel

00:36:18,269 --> 00:36:23,779
provides peer labeling fine-grained

00:36:20,099 --> 00:36:25,559
control over transfer and then use

00:36:23,779 --> 00:36:27,299
there's lots of benefits of this

00:36:25,559 --> 00:36:29,700
approach it just helps with the Nasher

00:36:27,299 --> 00:36:31,349
pool implementation provides that direct

00:36:29,700 --> 00:36:34,710
support for labeling and asks control

00:36:31,349 --> 00:36:36,990
just helps mitigate capability leaks in

00:36:34,710 --> 00:36:38,369
the user space it just helps reduce the

00:36:36,990 --> 00:36:41,910
insurance burden on user space

00:36:38,369 --> 00:36:43,440
components and just causes user space

00:36:41,910 --> 00:36:45,349
object matters not to have to trust each

00:36:43,440 --> 00:36:47,970
of the vary trust each other very much

00:36:45,349 --> 00:36:49,859
also it gives us a centralized security

00:36:47,970 --> 00:36:52,259
policy which is very good for analysis

00:36:49,859 --> 00:36:55,009
audit management and just supports

00:36:52,259 --> 00:36:57,329
flexible fine grained access control

00:36:55,009 --> 00:36:58,980
alright so currently we've just been

00:36:57,329 --> 00:37:00,359
we're really in the beginning stages

00:36:58,980 --> 00:37:03,150
we've been looking at the creation and

00:37:00,359 --> 00:37:05,069
flow of handles among fuschia we've

00:37:03,150 --> 00:37:06,719
we've been searching or looking

00:37:05,069 --> 00:37:08,329
the reach ability of security-critical

00:37:06,719 --> 00:37:10,199
handles and objects in the system

00:37:08,329 --> 00:37:11,999
assessing the effectiveness of existing

00:37:10,199 --> 00:37:14,249
mechanisms and just exploring our

00:37:11,999 --> 00:37:16,349
options so give you an example I've been

00:37:14,249 --> 00:37:19,400
just labeling handles so I can just

00:37:16,349 --> 00:37:21,539
track and see how things flow through

00:37:19,400 --> 00:37:23,880
through the system so here are some

00:37:21,539 --> 00:37:25,919
examples and the way I label here the

00:37:23,880 --> 00:37:27,719
the vertical bar represents in addition

00:37:25,919 --> 00:37:30,419
when you're added handles added to the

00:37:27,719 --> 00:37:32,939
process vertical bar with an asterisks

00:37:30,419 --> 00:37:35,579
that signals it's being removed and this

00:37:32,939 --> 00:37:38,519
is always in the case of of being passed

00:37:35,579 --> 00:37:39,929
across a channel so what happens is well

00:37:38,519 --> 00:37:41,219
for a handle can never be in two

00:37:39,929 --> 00:37:44,309
processes at once so if you're gonna

00:37:41,219 --> 00:37:47,130
pass a handle to another process it is

00:37:44,309 --> 00:37:48,569
removed from the one process it goes to

00:37:47,130 --> 00:37:50,309
the channel and then the other process

00:37:48,569 --> 00:37:52,319
gets it so you all you see a removal and

00:37:50,309 --> 00:37:54,419
then in addition when you pass it handle

00:37:52,319 --> 00:37:56,189
across a channel the vertical bar and

00:37:54,419 --> 00:37:58,049
the plus sign indicates that duplication

00:37:56,189 --> 00:38:00,239
of the handle so in the first case we

00:37:58,049 --> 00:38:01,890
have a virtual memory object this in

00:38:00,239 --> 00:38:04,559
this case we're tracing out the VDS so

00:38:01,890 --> 00:38:06,660
this is the full VDS so not a variant

00:38:04,559 --> 00:38:10,380
and how it goes from the kernel and gets

00:38:06,660 --> 00:38:13,400
to a shell so VSO is created in the

00:38:10,380 --> 00:38:17,249
kernel that's added to the user boot

00:38:13,400 --> 00:38:18,839
process and then that passes the handle

00:38:17,249 --> 00:38:23,130
over a channel to the device manager

00:38:18,839 --> 00:38:25,019
device manager duplicates the handle the

00:38:23,130 --> 00:38:27,269
duplicate is added to device manager and

00:38:25,019 --> 00:38:29,369
then that duplicate has passed across

00:38:27,269 --> 00:38:31,890
the handle to the service host which

00:38:29,369 --> 00:38:34,049
then duplicates the handle again that

00:38:31,890 --> 00:38:36,239
duplicate is added to serve the service

00:38:34,049 --> 00:38:38,099
host which then passes that handle

00:38:36,239 --> 00:38:40,140
across the channel to the shell so we

00:38:38,099 --> 00:38:42,390
see how it goes from the kernel to the

00:38:40,140 --> 00:38:44,249
show the second example is a resource so

00:38:42,390 --> 00:38:46,679
the root resource again is created in

00:38:44,249 --> 00:38:49,229
the kernel it's added to use a boot user

00:38:46,679 --> 00:38:52,019
boot passes a handle to device manager

00:38:49,229 --> 00:38:54,119
device manager duplicates the handle the

00:38:52,019 --> 00:38:56,519
duplicate is added into device manager

00:38:54,119 --> 00:38:59,640
which then passes that across the handle

00:38:56,519 --> 00:39:02,219
to the the sir the server or the device

00:38:59,640 --> 00:39:03,779
driver dev hole cysts and then for a

00:39:02,219 --> 00:39:05,669
channel all channel consists of two

00:39:03,779 --> 00:39:08,759
objects the pair of objects so we label

00:39:05,669 --> 00:39:10,919
the pair with the kernel ID so that we

00:39:08,759 --> 00:39:13,799
can match them up later so in this case

00:39:10,919 --> 00:39:15,720
we have the kernel IDs 24:07 and 24:08

00:39:13,799 --> 00:39:18,270
it represents the channel

00:39:15,720 --> 00:39:21,420
and so this channel was created in the

00:39:18,270 --> 00:39:23,400
device manager and then won one of the

00:39:21,420 --> 00:39:25,560
handles was passed over channel to deaf

00:39:23,400 --> 00:39:27,900
holes pci number three and the other

00:39:25,560 --> 00:39:30,750
handle was passed to me the service host

00:39:27,900 --> 00:39:32,460
so now service host and deaf host pci

00:39:30,750 --> 00:39:36,569
number three they have a channel between

00:39:32,460 --> 00:39:39,450
them all right like the like Steve

00:39:36,569 --> 00:39:42,000
showed four for Zephyr so here's a slide

00:39:39,450 --> 00:39:44,640
showing fuchsia versus Linux OS security

00:39:42,000 --> 00:39:45,960
again this is not comprehensive fuchsia

00:39:44,640 --> 00:39:48,359
is a work in progress not all of these

00:39:45,960 --> 00:39:51,750
things are complete or as fully

00:39:48,359 --> 00:39:55,079
functioned as in Linux as an example ASL

00:39:51,750 --> 00:39:57,380
are all the the plumbing is there it

00:39:55,079 --> 00:40:00,030
just so happens for debugging purposes

00:39:57,380 --> 00:40:01,980
everything is loaded as the exact same

00:40:00,030 --> 00:40:04,710
random address every time right so this

00:40:01,980 --> 00:40:06,660
is just for development we also haven't

00:40:04,710 --> 00:40:09,089
really examined the the cell protection

00:40:06,660 --> 00:40:10,619
mechanisms and in fuchsia yet so in

00:40:09,089 --> 00:40:12,480
general the big differences are

00:40:10,619 --> 00:40:14,880
obviously fuchsia being a microkernel

00:40:12,480 --> 00:40:17,310
has a small D composed trusted computing

00:40:14,880 --> 00:40:20,430
base versus Linux is large amount with

00:40:17,310 --> 00:40:24,470
ik one I've just obviously fuchsia uses

00:40:20,430 --> 00:40:26,849
optical bilities Linux has DAC and Mac

00:40:24,470 --> 00:40:28,859
so zephyr and fuchsia are each seeking

00:40:26,849 --> 00:40:30,510
to advance the state of all security for

00:40:28,859 --> 00:40:32,099
their respective domains those Lollar

00:40:30,510 --> 00:40:34,170
work remains to be done for the security

00:40:32,099 --> 00:40:37,230
of both of them and I encourage you to

00:40:34,170 --> 00:40:41,760
get involved so is there any questions

00:40:37,230 --> 00:40:47,040
which I'll happily direct to Steve if we

00:40:41,760 --> 00:40:50,880
have any time left any questions I do

00:40:47,040 --> 00:40:53,030
not see all right if ou have questions

00:40:50,880 --> 00:40:53,030
yes

00:40:59,140 --> 00:41:04,550
well for fuchsia again it's very much a

00:41:02,180 --> 00:41:06,650
work in progress so there's not a lot of

00:41:04,550 --> 00:41:07,640
testing right right now it's more of

00:41:06,650 --> 00:41:09,680
just trying to get everything to work

00:41:07,640 --> 00:41:11,930
sort of stage we've try to evaluate

00:41:09,680 --> 00:41:13,070
things and we've noticed some things but

00:41:11,930 --> 00:41:15,020
most of the things that we've noted are

00:41:13,070 --> 00:41:17,859
things that are already known it just

00:41:15,020 --> 00:41:21,849
reflects the state Steve would have to

00:41:17,859 --> 00:41:21,849
answer the question about zephyr

00:42:20,060 --> 00:42:28,920
clearly has a zephyr clearly has a

00:42:25,790 --> 00:42:32,010
broad-based community coming from many

00:42:28,920 --> 00:42:34,200
different companies right now future

00:42:32,010 --> 00:42:35,760
seems to be mostly Google right now

00:42:34,200 --> 00:42:36,990
there's there are some external

00:42:35,760 --> 00:42:38,880
contributors it is an open source

00:42:36,990 --> 00:42:41,760
project but s'more in the Android mold

00:42:38,880 --> 00:42:44,760
right now and and also because it's

00:42:41,760 --> 00:42:48,000
still very much active in core heavy

00:42:44,760 --> 00:42:53,880
development it's not as broadly based

00:42:48,000 --> 00:42:56,330
yet as you know some other systems yes

00:42:53,880 --> 00:42:56,330
but

00:43:03,880 --> 00:43:09,920
well I mean it does limit how you get to

00:43:06,560 --> 00:43:12,380
the the particular system call so it

00:43:09,920 --> 00:43:15,890
doesn't force that the system call has

00:43:12,380 --> 00:43:18,230
to be through it's not that it's not a

00:43:15,890 --> 00:43:20,240
the primary security mechanism but it

00:43:18,230 --> 00:43:21,950
does limit the ways you can you can

00:43:20,240 --> 00:43:25,340
access a system system cost so it

00:43:21,950 --> 00:43:28,220
doesn't force at least at least the

00:43:25,340 --> 00:43:29,810
entry point to I would say more it would

00:43:28,220 --> 00:43:31,780
help us later on when we add security

00:43:29,810 --> 00:43:35,690
that it would make it easier for us to

00:43:31,780 --> 00:43:37,610
to to lay around the Mac I think would

00:43:35,690 --> 00:43:39,350
make it easier for us to do the Mac

00:43:37,610 --> 00:43:41,210
stuff on top of that and to enforce the

00:43:39,350 --> 00:43:43,490
stuff with that because it's always

00:43:41,210 --> 00:43:45,740
easier if you know that in order to do

00:43:43,490 --> 00:43:48,530
this you must do this first it's easier

00:43:45,740 --> 00:43:50,630
to set that up than it is if you can

00:43:48,530 --> 00:43:54,080
come from lots and lots of different

00:43:50,630 --> 00:43:55,280
ways of doing the same thing so and

00:43:54,080 --> 00:44:03,590
maybe Steve has some other with

00:43:55,280 --> 00:44:05,960
something else to say about that so

00:44:03,590 --> 00:44:07,760
first of all right today

00:44:05,960 --> 00:44:10,520
I wouldn't put any confidence in the

00:44:07,760 --> 00:44:12,400
mechanism right now right because we

00:44:10,520 --> 00:44:14,900
already found one way that we could

00:44:12,400 --> 00:44:17,210
clobber the video so and not just around

00:44:14,900 --> 00:44:18,590
but every other processes okay so this

00:44:17,210 --> 00:44:21,440
is again very much a system in

00:44:18,590 --> 00:44:24,050
development right it appears that their

00:44:21,440 --> 00:44:27,050
goal is to make the video so an done by

00:44:24,050 --> 00:44:29,510
passable gate right for entering the

00:44:27,050 --> 00:44:31,160
kernel all right and so they're trying

00:44:29,510 --> 00:44:33,530
to set up the preconditions to ensure

00:44:31,160 --> 00:44:35,000
that it's fully read-only right into the

00:44:33,530 --> 00:44:37,190
process it's mapped into and that it

00:44:35,000 --> 00:44:39,560
can't be tampered with right after that

00:44:37,190 --> 00:44:41,840
set up so it's almost like they're

00:44:39,560 --> 00:44:44,950
trying to use the video so as a as a

00:44:41,840 --> 00:44:48,140
reduced functionality set comp feature

00:44:44,950 --> 00:44:50,290
right as the gate into the kernel and

00:44:48,140 --> 00:44:52,460
then the variance really would

00:44:50,290 --> 00:44:54,380
essentially whitelist what system calls

00:44:52,460 --> 00:44:56,330
are exposed there's a little unclear to

00:44:54,380 --> 00:44:58,070
us from the outside as to whether

00:44:56,330 --> 00:44:59,960
they're thinking of it more as a

00:44:58,070 --> 00:45:03,860
security feature or if they're thinking

00:44:59,960 --> 00:45:06,710
of it more as just a let's limit the

00:45:03,860 --> 00:45:09,050
public API of our system and not let

00:45:06,710 --> 00:45:11,750
third parties you know just use random

00:45:09,050 --> 00:45:13,520
system calls it will write because

00:45:11,750 --> 00:45:16,580
that's also something that's you know

00:45:13,520 --> 00:45:19,550
generally of interest to them right

00:45:16,580 --> 00:45:21,350
system developers so it's hard to assess

00:45:19,550 --> 00:45:24,110
right now how much of it is for security

00:45:21,350 --> 00:45:25,880
how much of it is to women how much of

00:45:24,110 --> 00:45:35,240
an ABI they need to support going

00:45:25,880 --> 00:45:37,670
forward okay thanks for that in any

00:45:35,240 --> 00:45:41,409
follow-up questions

00:45:37,670 --> 00:45:41,409

YouTube URL: https://www.youtube.com/watch?v=Jov4dTnjm2o


