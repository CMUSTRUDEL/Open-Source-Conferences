Title: Sub-system Update: Kernel Self-Protection Project - Kees Cook, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Sub-system Update: Kernel Self-Protection Project - Kees Cook, Google

This presentation will cover the year-in-review of the Kernel Self-Protection Project since the last Linux Security Summit NA, including an overview of all the security defenses landed in kernels 4.14 through 4.18. Some highlights are vmapped stacks, structure randomization, SLUB freelist obfuscation, set_fs() checking, fast refcount_t protection, Page Table Isolation, usercopy whitelisting, VLA removals, and the stackleak plugin.

We'll also take a quick look at the evolution of kernel CVE lifetimes, find out what defenses are still under development, and note some areas where help is still needed.

About Kees Cook
Kees Cook has been working with Free Software since 1994, and has been a Debian Developer since 2007. He is currently employed as a Linux kernel security engineer by Google, working on Android and and Chrome OS. From 2006 through 2011 he worked for Canonical as the Ubuntu Security Team's Tech Lead, and remains on the Ubuntu Technical Board. Before that, he worked as the lead sysadmin at OSDL, before it was the Linux Foundation. He has written various utilities including GOPchop and Sendpage, and contributes randomly to other projects including fun chunks of code in OpenSSH, Inkscape, Wine, MPlayer, and Wireshark. He's been spending most of his time lately focused on security features in the Linux Kernel.
Captions: 
	00:00:00,030 --> 00:00:05,279
okay it's me again that's where you get

00:00:02,490 --> 00:00:07,500
the slides this is about the Colonel

00:00:05,279 --> 00:00:10,500
self-protection project I mentioned this

00:00:07,500 --> 00:00:12,360
earlier we're protecting the colonel

00:00:10,500 --> 00:00:15,599
from user space not user space from user

00:00:12,360 --> 00:00:18,420
space but we are interested in all of

00:00:15,599 --> 00:00:21,300
those areas so you know development is

00:00:18,420 --> 00:00:24,900
welcome even in those areas too a lot of

00:00:21,300 --> 00:00:26,699
people are involved in this but please

00:00:24,900 --> 00:00:31,260
help us and not anyone else you heard

00:00:26,699 --> 00:00:32,700
today we need the help this is mostly

00:00:31,260 --> 00:00:35,730
about bug life time I've talked about

00:00:32,700 --> 00:00:37,350
this before in other presentations and

00:00:35,730 --> 00:00:40,140
refresh the analysis and these numbers

00:00:37,350 --> 00:00:43,320
are actually have gone down by 1/10 of a

00:00:40,140 --> 00:00:44,850
year so we were at a solid 6.0 years on

00:00:43,320 --> 00:00:49,610
the high medium and low and they've

00:00:44,850 --> 00:00:51,989
they've slightly crept down and this

00:00:49,610 --> 00:00:55,680
this is the graph I have generated

00:00:51,989 --> 00:00:57,420
before of the lifetime of a bug when it

00:00:55,680 --> 00:00:59,489
was introduced this is kernel versions

00:00:57,420 --> 00:01:01,039
along the one side when it was

00:00:59,489 --> 00:01:04,439
introduced and when it was fixed

00:01:01,039 --> 00:01:07,380
critical and high so the longer lines

00:01:04,439 --> 00:01:09,119
have a longer lifetime and the concern I

00:01:07,380 --> 00:01:10,890
was having recently was that the bug

00:01:09,119 --> 00:01:12,869
life time that we'd seen at like 5 years

00:01:10,890 --> 00:01:14,820
and growing to 6 years I was worried

00:01:12,869 --> 00:01:18,330
that what we were actually seeing was

00:01:14,820 --> 00:01:20,340
distance from the beginning of get

00:01:18,330 --> 00:01:22,710
history and as we got further away from

00:01:20,340 --> 00:01:26,520
it the bug life time would continue to

00:01:22,710 --> 00:01:28,590
increase but I saw that some of these

00:01:26,520 --> 00:01:30,840
long tails were starting to lift up out

00:01:28,590 --> 00:01:34,530
of get history and it looks like that is

00:01:30,840 --> 00:01:36,720
that is continuing so maybe there is an

00:01:34,530 --> 00:01:40,409
actual real number somewhere in the 5

00:01:36,720 --> 00:01:42,659
year range they were you know trying to

00:01:40,409 --> 00:01:45,860
protect against anyway so quickly a

00:01:42,659 --> 00:01:48,420
year's worth of kernel releases in 4:14

00:01:45,860 --> 00:01:50,909
we got a whole three of reference count

00:01:48,420 --> 00:01:55,770
conversions there was a stall on bike

00:01:50,909 --> 00:01:59,130
shedding we surprised about bike

00:01:55,770 --> 00:02:02,850
shedding the the part of the ran struct

00:01:59,130 --> 00:02:04,920
plug-in in automatic mode landed we got

00:02:02,850 --> 00:02:07,619
free list pointer obfuscation so

00:02:04,920 --> 00:02:10,649
attacking metadata in the heap is more

00:02:07,619 --> 00:02:11,970
difficult the struck leaked plugin got a

00:02:10,649 --> 00:02:14,940
by reference mode that I talk

00:02:11,970 --> 00:02:19,350
about earlier we gained V map stack

00:02:14,940 --> 00:02:21,540
forearm 64 and then there was a large

00:02:19,350 --> 00:02:22,830
series of patches to just get rid of set

00:02:21,540 --> 00:02:26,570
FS which has been a problematic

00:02:22,830 --> 00:02:29,670
interface for a while along with gaining

00:02:26,570 --> 00:02:32,880
balanced detection see if we if we set

00:02:29,670 --> 00:02:35,340
FS out to all of kernel memory and then

00:02:32,880 --> 00:02:37,890
we exit out of assist call without

00:02:35,340 --> 00:02:39,300
resetting it that's a very bad bug but

00:02:37,890 --> 00:02:41,040
that's one we've tripped over a number

00:02:39,300 --> 00:02:43,080
of times so now we actually test for it

00:02:41,040 --> 00:02:47,550
on exit let me say did you forget to

00:02:43,080 --> 00:02:50,160
reset the boundary and it will come back

00:02:47,550 --> 00:02:52,050
a little crash and come back or whatever

00:02:50,160 --> 00:02:53,640
anyway so back bike shedding is done 35

00:02:52,050 --> 00:02:56,910
read count conversions about 32

00:02:53,640 --> 00:03:01,130
remaining for 15 was when we landed PTI

00:02:56,910 --> 00:03:04,890
and ret Pauline this is also where I

00:03:01,130 --> 00:03:09,000
gave myself carpal tunnel doing struck

00:03:04,890 --> 00:03:11,730
timer list removals trying to get that

00:03:09,000 --> 00:03:15,420
refactored set was a source of some

00:03:11,730 --> 00:03:18,230
exploit infrastructure and we gain the

00:03:15,420 --> 00:03:20,850
fast ref count overflow protection which

00:03:18,230 --> 00:03:23,730
is one of the very few features we've

00:03:20,850 --> 00:03:25,470
back ported to 414 for an LTS because it

00:03:23,730 --> 00:03:27,420
was really a one line bug fix plus

00:03:25,470 --> 00:03:30,450
enabling it all the code was already in

00:03:27,420 --> 00:03:34,580
for 14 and we gained the percent p

00:03:30,450 --> 00:03:37,670
hashing so that we have in theory fewer

00:03:34,580 --> 00:03:41,070
information leaks going out to logs and

00:03:37,670 --> 00:03:43,320
for 16 we had 12 reference count

00:03:41,070 --> 00:03:47,489
versions maybe about 20 more gained PTI

00:03:43,320 --> 00:03:50,130
for armed 64 hardened user copy gained

00:03:47,489 --> 00:03:53,760
whitelisting which was a instead of just

00:03:50,130 --> 00:03:56,370
checking the size of an allocation that

00:03:53,760 --> 00:03:58,709
when you're creating allocations you can

00:03:56,370 --> 00:04:01,470
specify what portion of it you expect to

00:03:58,709 --> 00:04:03,840
go out to a user space so this narrows

00:04:01,470 --> 00:04:07,440
the availability of what's getting

00:04:03,840 --> 00:04:11,459
copied out even further and around this

00:04:07,440 --> 00:04:13,980
time was the Blue Boar an attack where I

00:04:11,459 --> 00:04:16,229
was horrified to discover that basically

00:04:13,980 --> 00:04:18,390
everyone building little embedded

00:04:16,229 --> 00:04:20,340
devices did not turn on stack protector

00:04:18,390 --> 00:04:22,740
because it sort of default off due to

00:04:20,340 --> 00:04:23,840
some limitations in tooling and other

00:04:22,740 --> 00:04:26,449
things and the config

00:04:23,840 --> 00:04:29,150
I managed to get a an automatic mode of

00:04:26,449 --> 00:04:30,620
this working where during the bill that

00:04:29,150 --> 00:04:33,139
would try to figure out the best thing

00:04:30,620 --> 00:04:34,520
your compiler supported and use it this

00:04:33,139 --> 00:04:36,530
has since been replaced with better

00:04:34,520 --> 00:04:38,210
tooling but um Alta meliha gets us to

00:04:36,530 --> 00:04:39,470
the point where now you when you build a

00:04:38,210 --> 00:04:42,050
kernel you get the stack protector

00:04:39,470 --> 00:04:44,630
unless you explicitly turn it off and

00:04:42,050 --> 00:04:51,350
that's that was a long time limiting

00:04:44,630 --> 00:04:55,160
limited problem in 417 is this see ya at

00:04:51,350 --> 00:04:57,470
the start of VLA removal so 51 removed

00:04:55,160 --> 00:05:01,550
in 417 lots of people helping with this

00:04:57,470 --> 00:05:04,250
80 remaining we're wiping the stack on

00:05:01,550 --> 00:05:05,780
fork so in the past you would allocate

00:05:04,250 --> 00:05:07,820
memory for the stack and it could have

00:05:05,780 --> 00:05:09,950
come from anywhere and it wouldn't be

00:05:07,820 --> 00:05:12,680
initialized in any way so if you manage

00:05:09,950 --> 00:05:15,050
to leak something immediately or at any

00:05:12,680 --> 00:05:16,940
deep location in the stack you would

00:05:15,050 --> 00:05:18,229
have whatever used to be there and that

00:05:16,940 --> 00:05:20,330
was ridiculous

00:05:18,229 --> 00:05:22,250
because it's easy to wipe the stack on

00:05:20,330 --> 00:05:25,910
fork because that only happens once per

00:05:22,250 --> 00:05:29,050
process as it turns out this appears

00:05:25,910 --> 00:05:34,039
possibly to actually speed up exec I

00:05:29,050 --> 00:05:37,340
have bad data more fixes for our limit

00:05:34,039 --> 00:05:39,560
bypasses on exact map fix no replace

00:05:37,340 --> 00:05:44,830
came in which is yet another stack clash

00:05:39,560 --> 00:05:48,620
issue when exec it was possible to

00:05:44,830 --> 00:05:50,570
confuse the kernel into overlapping an

00:05:48,620 --> 00:05:53,690
executable region on to other regions

00:05:50,570 --> 00:05:55,430
that already been mapped since map fixed

00:05:53,690 --> 00:05:58,099
is happy to replace whatever is

00:05:55,430 --> 00:05:59,780
underneath it but map fix no replace

00:05:58,099 --> 00:06:01,370
says I'm not going to do that and will

00:05:59,780 --> 00:06:03,460
fail instead of leaving you in a

00:06:01,370 --> 00:06:07,820
dangerous position

00:06:03,460 --> 00:06:10,910
this also 417 also included on syscall

00:06:07,820 --> 00:06:16,039
entry clearing unused registers on x86

00:06:10,910 --> 00:06:19,220
as a way to avoid having registers for

00:06:16,039 --> 00:06:21,560
speculative execution gadgets

00:06:19,220 --> 00:06:23,000
speculation gadgets of any kind so you

00:06:21,560 --> 00:06:25,610
don't leave stuff sitting around in

00:06:23,000 --> 00:06:28,520
registers that aren't actively used for

00:06:25,610 --> 00:06:30,580
the syscall entry and we got the

00:06:28,520 --> 00:06:32,960
speculative store bypass disable

00:06:30,580 --> 00:06:35,280
protections for more speculation things

00:06:32,960 --> 00:06:38,560
on x86

00:06:35,280 --> 00:06:41,740
4:18 we got 38 VLA is removed 42

00:06:38,560 --> 00:06:43,530
remaining we got some of the basic

00:06:41,740 --> 00:06:47,110
arithmetic overflow detection helpers

00:06:43,530 --> 00:06:48,639
people have to use them explicitly but

00:06:47,110 --> 00:06:51,150
we made sure to go through and at least

00:06:48,639 --> 00:06:52,630
try to catch as many of the allocation

00:06:51,150 --> 00:06:53,800
allocations that are using

00:06:52,630 --> 00:06:56,800
multiplication to figure out how large

00:06:53,800 --> 00:06:58,660
their sizes to have all of those use the

00:06:56,800 --> 00:07:01,570
overflow detection so we can try to kill

00:06:58,660 --> 00:07:03,070
an entire class of issues there there's

00:07:01,570 --> 00:07:06,130
a lot more work to be done but I know

00:07:03,070 --> 00:07:08,620
that we at least got one known one as

00:07:06,130 --> 00:07:13,180
someone was trying to report overflow

00:07:08,620 --> 00:07:15,040
issues their patch collided with the

00:07:13,180 --> 00:07:17,169
tree wide changes that had come in this

00:07:15,040 --> 00:07:18,729
is like okay that's actually working we

00:07:17,169 --> 00:07:21,280
found at least one bug there who knows

00:07:18,729 --> 00:07:25,930
how many more there are and then we got

00:07:21,280 --> 00:07:27,639
s s be disabled on arm 64 so for 19 the

00:07:25,930 --> 00:07:31,240
merchant was closed so I am expecting

00:07:27,639 --> 00:07:34,660
these things to have gone in 33 valets

00:07:31,240 --> 00:07:38,590
removed with nine remaining it's been a

00:07:34,660 --> 00:07:40,840
long long path for that one as well as

00:07:38,590 --> 00:07:42,940
the multiplication and addition overflow

00:07:40,840 --> 00:07:46,090
helpers we've also gained shift overflow

00:07:42,940 --> 00:07:49,060
helpers so you can be sure that your

00:07:46,090 --> 00:07:50,950
shift actually worked correctly the l1

00:07:49,060 --> 00:07:53,169
TF defenses went in

00:07:50,950 --> 00:07:56,620
we've also we're now also able to

00:07:53,169 --> 00:07:58,090
restrict creating files in temp

00:07:56,620 --> 00:08:00,729
directories or sticky writable

00:07:58,090 --> 00:08:04,360
directories this has existed for

00:08:00,729 --> 00:08:07,150
symlinks and with symlinks gone as a

00:08:04,360 --> 00:08:09,160
target for attackers to use for for

00:08:07,150 --> 00:08:12,940
doing temporary PSA's they could

00:08:09,160 --> 00:08:17,320
actually turn to just creating regular

00:08:12,940 --> 00:08:19,960
files and pipes and temp as a target so

00:08:17,320 --> 00:08:22,389
that's now blocked if you want it and

00:08:19,960 --> 00:08:25,060
then the unused register clearing for

00:08:22,389 --> 00:08:28,210
sis call entry and armed 64 and SS be

00:08:25,060 --> 00:08:30,700
disabled on arm 64 for 419 and then

00:08:28,210 --> 00:08:32,560
hopefully in 420 we'll be done with VL a

00:08:30,700 --> 00:08:37,719
removal and we'll get the stack leak

00:08:32,560 --> 00:08:39,669
plugin as you heard about various soon

00:08:37,719 --> 00:08:42,669
and not so soon features we're looking

00:08:39,669 --> 00:08:44,950
at thinking about writing patches for

00:08:42,669 --> 00:08:47,260
zell CO and see if i heard about an

00:08:44,950 --> 00:08:48,940
exclusive page frame owner this whole

00:08:47,260 --> 00:08:53,740
list here

00:08:48,940 --> 00:08:55,150
and same same slide I had on the other

00:08:53,740 --> 00:08:57,670
one which is we have a lot of challenges

00:08:55,150 --> 00:09:03,190
with doing up streaming you heard a

00:08:57,670 --> 00:09:06,550
whole presentation on that and that's it

00:09:03,190 --> 00:09:14,650
there's places to reach me and find K s

00:09:06,550 --> 00:09:21,940
P P and these slides any questions yes I

00:09:14,650 --> 00:09:24,520
I can so I should have link to it the

00:09:21,940 --> 00:09:27,580
question was about restricting o create

00:09:24,520 --> 00:09:31,650
on existing files so if there is a file

00:09:27,580 --> 00:09:34,110
in temp that you did not own and you and

00:09:31,650 --> 00:09:37,150
you issue an oak create without

00:09:34,110 --> 00:09:40,780
exclusive it would overwrite it if you

00:09:37,150 --> 00:09:43,530
had the permissions to so you could

00:09:40,780 --> 00:09:46,390
replace files out from under or someone

00:09:43,530 --> 00:09:57,250
who is doing the wrong thing and the

00:09:46,390 --> 00:09:59,620
same thing for Phi pose I know the other

00:09:57,250 --> 00:10:01,960
way around so the the whoever is

00:09:59,620 --> 00:10:04,290
attempting to yes yes it is it is

00:10:01,960 --> 00:10:08,620
somewhat backwards you basically don't

00:10:04,290 --> 00:10:13,000
overwrite the file that was put there by

00:10:08,620 --> 00:10:15,400
an attacker because their permissions

00:10:13,000 --> 00:10:17,080
would supersede yours anyway because o

00:10:15,400 --> 00:10:19,990
create would succeed because you opened

00:10:17,080 --> 00:10:21,790
it it was already there because you did

00:10:19,990 --> 00:10:24,340
you forgot to include exclusive in your

00:10:21,790 --> 00:10:27,490
open so it's basically stopping the

00:10:24,340 --> 00:10:35,160
legitimate process from opening the bad

00:10:27,490 --> 00:10:35,160
file yes

00:10:37,830 --> 00:10:49,550
I didn't hear what was it I I cannot

00:10:45,630 --> 00:10:49,550
speak to that particularly well sorry

00:10:53,000 --> 00:10:57,960
anyway uh come and find me afterwards I

00:10:56,040 --> 00:11:01,480
don't want to keep people more than

00:10:57,960 --> 00:11:03,730
we're already way over so thank you

00:11:01,480 --> 00:11:03,930
[Applause]

00:11:03,730 --> 00:11:07,070
[Music]

00:11:03,930 --> 00:11:07,070

YouTube URL: https://www.youtube.com/watch?v=wlqjQe3vDx8


