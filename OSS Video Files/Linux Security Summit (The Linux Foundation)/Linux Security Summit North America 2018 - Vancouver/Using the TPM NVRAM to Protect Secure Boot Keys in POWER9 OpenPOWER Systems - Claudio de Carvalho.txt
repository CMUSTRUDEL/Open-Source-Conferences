Title: Using the TPM NVRAM to Protect Secure Boot Keys in POWER9 OpenPOWER Systems - Claudio de Carvalho
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	Using the TPM NVRAM to Protect Secure Boot Keys in POWER9 OpenPOWER Systems - Claudio Siqueira de Carvalho, IBM

In OpenPOWER systems, most firmware code used to boot the platform OS is stored in the processor flash memory (PNOR). Although PNOR is non-volatile memory, it is unprotected. In order to secure boot the platform OS, it is well known that only platform OSs signed with authorized keys should booted. However, saving the authorized keys in a secure non-volatile memory is as important as using them to verify the platform OS. In this presentation, Claudio Carvalho will show how the shielded non-volatile memory (NVRAM) of the Trusted Platform Module (TPM) has become essential in OpenPOWER systems to protect the secure boot keys stored in PNOR. This discussion includes design and implementation aspects that are both currently in progress for the OpenPOWER firmware and the Linux Kernel layers.

About Claudio Siqueira de Carvalho
Claudio Carvalho is a brazilian Linux enthusiastic with over 15 years of experience in the Linux field. He started his career as a package builder during his Master's degree at the University of Campinas, building packages for Linux distributions based on Arch and Debian. In 2011, he joined the IBM Linux Technology Center, where he has worked on several Linux security projects since then. He worked on linux security certifications (HIPAA, Common Criteria and FIPS 140-2); OpenCryptoKi, which is an open source implementation of the CryptoKi API defined by the PKCS #11; and also OpenSSL plugins. Currently, he is an OpenPOWER firmware developer and he also leads the Secure and Trusted Boot development team in the IBM Linux Technology Center.
Captions: 
	00:00:00,050 --> 00:00:08,250
okay thank you and good morning and this

00:00:04,589 --> 00:00:11,790
is my first presentation here in the

00:00:08,250 --> 00:00:14,490
UNIX occurs linux secured summit so a

00:00:11,790 --> 00:00:17,359
brief introduction so my name is cloud

00:00:14,490 --> 00:00:20,279
to secure each car value but in english

00:00:17,359 --> 00:00:23,939
they call me claudio car value or

00:00:20,279 --> 00:00:28,289
Carvalho or maybe Claudio Cavallo that

00:00:23,939 --> 00:00:31,519
in Portuguese Cavallo means horse it's a

00:00:28,289 --> 00:00:31,519
little bit funny that's okay

00:00:31,520 --> 00:00:41,160
and so TPM chip I'm the TPM chip is a

00:00:37,920 --> 00:00:43,800
crypto processor and it provides several

00:00:41,160 --> 00:00:45,780
capabilities and if you go to the

00:00:43,800 --> 00:00:49,890
internet you can see some TPM use cases

00:00:45,780 --> 00:00:52,530
but today I want to talk about how we

00:00:49,890 --> 00:00:55,770
are we are using the TPM nvm to protect

00:00:52,530 --> 00:01:00,149
secure boot case in open power in power

00:00:55,770 --> 00:01:04,650
line open power systems this is the this

00:01:00,149 --> 00:01:06,720
is the outline so before showing how we

00:01:04,650 --> 00:01:08,369
protect the secure boot keys and open

00:01:06,720 --> 00:01:11,220
power I want to give you a brief

00:01:08,369 --> 00:01:15,479
introduction on open power secure boot

00:01:11,220 --> 00:01:18,840
and also describe the problem and then

00:01:15,479 --> 00:01:22,590
show how we protect the secure boot keys

00:01:18,840 --> 00:01:25,950
and open power so the secure boot team

00:01:22,590 --> 00:01:28,470
open power secure boot team we have

00:01:25,950 --> 00:01:35,780
several contributors and contributors

00:01:28,470 --> 00:01:40,860
and I work in the IBM LTC security team

00:01:35,780 --> 00:01:45,210
and IBM Linux Technology Center actually

00:01:40,860 --> 00:01:48,570
and in the security team in the LTC and

00:01:45,210 --> 00:01:53,670
I am a secure interested with developer

00:01:48,570 --> 00:01:55,020
and I have led the development team the

00:01:53,670 --> 00:01:58,079
secured interest at boot development

00:01:55,020 --> 00:02:00,630
team in the LTC security but we also

00:01:58,079 --> 00:02:03,509
have contributors in our other

00:02:00,630 --> 00:02:06,840
contributors in the LTC security and

00:02:03,509 --> 00:02:11,819
also in the Linux Technology Center also

00:02:06,840 --> 00:02:13,590
IBM power4 mer and IBM research so it's

00:02:11,819 --> 00:02:16,800
climber so this work

00:02:13,590 --> 00:02:20,220
doesn't represent my view actually it

00:02:16,800 --> 00:02:22,080
represents my view not IBM's view and

00:02:20,220 --> 00:02:26,480
all design points its clothes disclosed

00:02:22,080 --> 00:02:28,680
here are subject to two finalization and

00:02:26,480 --> 00:02:30,750
acceptance in the features which I'm

00:02:28,680 --> 00:02:33,239
going to describe here they may not

00:02:30,750 --> 00:02:38,370
ultimately exist or take the described

00:02:33,239 --> 00:02:41,450
form in a product so I don't know how

00:02:38,370 --> 00:02:44,250
familiar you are with secure boot so

00:02:41,450 --> 00:02:47,730
secure boot what is the cupid for secure

00:02:44,250 --> 00:02:49,769
boot aims to prevent untrusted code from

00:02:47,730 --> 00:02:52,590
loading during the platform boot and for

00:02:49,769 --> 00:02:56,160
that it used digital signatures so that

00:02:52,590 --> 00:03:00,629
only code sign it with trusted keys or

00:02:56,160 --> 00:03:02,640
started during the platform boot but

00:03:00,629 --> 00:03:04,410
what is open power secure boot first I

00:03:02,640 --> 00:03:07,709
should say that open power is open

00:03:04,410 --> 00:03:11,040
source open power fumer is open source

00:03:07,709 --> 00:03:15,269
you can go to the key to the github the

00:03:11,040 --> 00:03:17,129
open power organization in the github in

00:03:15,269 --> 00:03:22,079
and there you can find the source code

00:03:17,129 --> 00:03:26,790
of all few more components that we load

00:03:22,079 --> 00:03:29,430
in the femur stack and we also find the

00:03:26,790 --> 00:03:33,420
opie Butte project that we use to build

00:03:29,430 --> 00:03:35,730
in open power image that you can flash

00:03:33,420 --> 00:03:41,190
you can clone that that Opie Butte

00:03:35,730 --> 00:03:44,459
repository and use it to to to build a

00:03:41,190 --> 00:03:47,220
an image and fumer image and also test

00:03:44,459 --> 00:03:50,700
the fumer image the instructions is is

00:03:47,220 --> 00:03:55,349
in the readme file so open power secure

00:03:50,700 --> 00:03:59,220
boot it's divided into two domains few

00:03:55,349 --> 00:04:04,019
more secure boot applies to all the few

00:03:59,220 --> 00:04:08,040
more images we load up to the bootloader

00:04:04,019 --> 00:04:10,940
and OS the cube root applies to this to

00:04:08,040 --> 00:04:14,120
the IMP to the oil's kernel images and

00:04:10,940 --> 00:04:16,769
that gives us some flexibility for

00:04:14,120 --> 00:04:18,959
example we can enable few more secure

00:04:16,769 --> 00:04:23,550
boot but disable or a secure boot if you

00:04:18,959 --> 00:04:25,349
want and we can also sign the kernel

00:04:23,550 --> 00:04:26,400
with different keys with only

00:04:25,349 --> 00:04:28,620
unnecessarily

00:04:26,400 --> 00:04:33,509
the canno with the same keys that we use

00:04:28,620 --> 00:04:34,740
to sign forever this is a power 9 boot

00:04:33,509 --> 00:04:37,229
flow

00:04:34,740 --> 00:04:40,440
it describes my high level with the boot

00:04:37,229 --> 00:04:42,539
flow in the power 9 but I think we don't

00:04:40,440 --> 00:04:45,300
have time to go through this this

00:04:42,539 --> 00:04:47,610
components here in this presentation so

00:04:45,300 --> 00:04:49,500
if you're interested on this to know

00:04:47,610 --> 00:04:51,630
more about the boot the power 9 to the

00:04:49,500 --> 00:04:56,310
flow you can go to the link I have down

00:04:51,630 --> 00:05:01,770
here down there instead I'm gonna use

00:04:56,310 --> 00:05:04,020
this very simplified but flow here to

00:05:01,770 --> 00:05:06,960
explain secure boot in power so few more

00:05:04,020 --> 00:05:08,370
secure boot if you were sitting in fewer

00:05:06,960 --> 00:05:10,680
secure boot the few more images are

00:05:08,370 --> 00:05:15,780
signed following the secure boot

00:05:10,680 --> 00:05:17,789
container layout and in manufacturing we

00:05:15,780 --> 00:05:23,010
sign all the few more images and start

00:05:17,789 --> 00:05:28,169
them in the processor nor here and the

00:05:23,010 --> 00:05:32,010
processor nor or pin or for short and we

00:05:28,169 --> 00:05:35,940
use this s be signing tools to build the

00:05:32,010 --> 00:05:38,699
femur images and actually to build the

00:05:35,940 --> 00:05:41,729
secure boot containers and basically it

00:05:38,699 --> 00:05:44,780
gets the the image and it signs the

00:05:41,729 --> 00:05:47,849
image with up to three former case and

00:05:44,780 --> 00:05:52,250
sign the public the public femur case

00:05:47,849 --> 00:05:59,370
with Hardware keys and three Hydra case

00:05:52,250 --> 00:06:01,199
and also in manufacturing we restored

00:05:59,370 --> 00:06:03,479
the hardware key hash because the

00:06:01,199 --> 00:06:07,020
hardware key hash the harbor keys are

00:06:03,479 --> 00:06:11,220
the root of trust in the container so to

00:06:07,020 --> 00:06:14,099
make sure that only trusted humor images

00:06:11,220 --> 00:06:17,550
are loaded during the boot we calculate

00:06:14,099 --> 00:06:20,010
a shaft 512 512 hash over the hardwick

00:06:17,550 --> 00:06:23,789
the public hardware case and store it in

00:06:20,010 --> 00:06:28,130
a non protected memory so that at boot

00:06:23,789 --> 00:06:30,720
time we can just check if the only

00:06:28,130 --> 00:06:35,150
trusted container secure boot containers

00:06:30,720 --> 00:06:35,150
are loaded and

00:06:37,970 --> 00:06:43,239
[Music]

00:06:39,300 --> 00:06:45,789
the in the container all this data the

00:06:43,239 --> 00:06:48,869
public key is the signature and the

00:06:45,789 --> 00:06:53,860
hashes they are appended to the image

00:06:48,869 --> 00:06:56,619
and that's what we call as container and

00:06:53,860 --> 00:06:59,439
the verification code is responsible is

00:06:56,619 --> 00:07:01,449
used to verify the container second the

00:06:59,439 --> 00:07:06,639
secure boots container and it is

00:07:01,449 --> 00:07:10,209
starting the LTP ROM which is a one-time

00:07:06,639 --> 00:07:13,119
programmable ROM it's sternness in a

00:07:10,209 --> 00:07:15,849
protected memory as well and the

00:07:13,119 --> 00:07:18,729
hierarchy hash the verification code and

00:07:15,849 --> 00:07:21,659
also part of the initial code that

00:07:18,729 --> 00:07:25,179
kicked off the platform they they are

00:07:21,659 --> 00:07:28,649
the they're part of our core root of

00:07:25,179 --> 00:07:31,889
trust so they don't need to be verified

00:07:28,649 --> 00:07:36,759
we trust them

00:07:31,889 --> 00:07:39,279
and secure boot in few the fewer secure

00:07:36,759 --> 00:07:41,589
boot can be enabled by a hardware set in

00:07:39,279 --> 00:07:48,550
the motherboard which is platform

00:07:41,589 --> 00:07:50,379
dependent and so self boot engine part

00:07:48,550 --> 00:07:51,879
of the self boot engine we don't as I

00:07:50,379 --> 00:07:53,860
mentioned we don't need to verify it

00:07:51,879 --> 00:07:56,050
because it's stored in a protected

00:07:53,860 --> 00:07:58,300
memory but all the other image

00:07:56,050 --> 00:08:00,459
subsequent images host boot open and

00:07:58,300 --> 00:08:03,490
open here stands for open power

00:08:00,459 --> 00:08:05,529
abstraction layer all the subsequent

00:08:03,490 --> 00:08:07,800
images needs to be verified seek the

00:08:05,529 --> 00:08:09,879
secure boot containers we were filed

00:08:07,800 --> 00:08:14,769
because they are all stored in the

00:08:09,879 --> 00:08:20,199
process sooner and fewer secure boot is

00:08:14,769 --> 00:08:25,419
upstream here I took a screenshot opal

00:08:20,199 --> 00:08:29,889
screenshot so open this level and as we

00:08:25,419 --> 00:08:35,680
can see all the images loaded by opal

00:08:29,889 --> 00:08:41,079
advil time they are verified and but

00:08:35,680 --> 00:08:43,569
even if the verification failed in this

00:08:41,079 --> 00:08:46,029
case the plat that the boot wouldn't be

00:08:43,569 --> 00:08:51,120
aborted because secure mode here is

00:08:46,029 --> 00:08:54,269
disabled so if in any of this stage

00:08:51,120 --> 00:08:56,490
host boot Opel secure route if any of

00:08:54,269 --> 00:08:58,740
the stage is the verification fail for

00:08:56,490 --> 00:09:05,009
in any of the stage the boot is aborted

00:08:58,740 --> 00:09:06,809
and the image is not loaded we also have

00:09:05,009 --> 00:09:08,309
the hierarchy hash here in the device

00:09:06,809 --> 00:09:10,110
tree if you want to take a look at the

00:09:08,309 --> 00:09:15,720
herd wiki have trusted Hardwick he has

00:09:10,110 --> 00:09:17,550
actually oh as secure boot so the OS

00:09:15,720 --> 00:09:19,110
secure boot is this is a work in

00:09:17,550 --> 00:09:23,730
progress we are still working on the

00:09:19,110 --> 00:09:27,360
design and also implementation and it's

00:09:23,730 --> 00:09:30,240
this key route is is a secure boot

00:09:27,360 --> 00:09:34,230
container and when it's loaded it's

00:09:30,240 --> 00:09:36,300
verified but as you can see this cube

00:09:34,230 --> 00:09:38,189
root is a linux kernel with embedded in

00:09:36,300 --> 00:09:39,930
it from a fast that runs very booting

00:09:38,189 --> 00:09:42,629
very boot is our bootloader

00:09:39,930 --> 00:09:47,910
it's a k exact bootloader it uses k

00:09:42,629 --> 00:09:50,670
exact to to boot the OS kernel and it

00:09:47,910 --> 00:09:53,879
reminds me the the panel discussion we

00:09:50,670 --> 00:09:56,249
had yesterday where they discuss linux

00:09:53,879 --> 00:09:59,429
as a Fuhrer

00:09:56,249 --> 00:10:02,699
so in the current design the OS kernel

00:09:59,429 --> 00:10:06,779
the host OS kernel is sign it with sign

00:10:02,699 --> 00:10:09,149
file which is the same tool used to sign

00:10:06,779 --> 00:10:13,499
kernel modules and the signature is

00:10:09,149 --> 00:10:16,920
embedded in the in the file and we are

00:10:13,499 --> 00:10:21,329
engaging with distros to design to

00:10:16,920 --> 00:10:25,199
provide sign that kernel for us the OS

00:10:21,329 --> 00:10:32,579
kernel is verified at the skill root

00:10:25,199 --> 00:10:34,920
kernel space at boot time we've hired at

00:10:32,579 --> 00:10:39,660
this cute kind of space by i'ma

00:10:34,920 --> 00:10:43,199
appraisal and we are adding supports to

00:10:39,660 --> 00:10:46,319
signature up in Eddy support your

00:10:43,199 --> 00:10:49,490
painted signatures for our chime

00:10:46,319 --> 00:10:52,199
appraisal and we are also defining a a

00:10:49,490 --> 00:10:55,980
platform keyring where we are going to

00:10:52,199 --> 00:10:58,819
put our our case so that time appraisal

00:10:55,980 --> 00:10:58,819
can verify the can

00:11:00,829 --> 00:11:05,999
so assuming the cure design we want to

00:11:03,929 --> 00:11:09,089
reuse the kernel code that supports efi

00:11:05,999 --> 00:11:13,139
as much as we can and especially the a5

00:11:09,089 --> 00:11:16,379
virus file system because with the 5

00:11:13,139 --> 00:11:18,899
virus file system we can use user space

00:11:16,379 --> 00:11:21,749
tools such as the a5 our user space

00:11:18,899 --> 00:11:26,550
tools to manipulate the secure boot

00:11:21,749 --> 00:11:31,199
variables and in order to to enable the

00:11:26,550 --> 00:11:35,029
a5 ours file system we we don't use the

00:11:31,199 --> 00:11:37,949
EFI system tables we only need to set

00:11:35,029 --> 00:11:40,350
these runtime services here they get

00:11:37,949 --> 00:11:44,999
verbal get next verbal cells very cheery

00:11:40,350 --> 00:11:47,160
query verbal info and we set them to to

00:11:44,999 --> 00:11:49,679
call open runtime services that will

00:11:47,160 --> 00:11:53,279
provide access to the to the key store

00:11:49,679 --> 00:11:57,730
starting in the pin or in the processor

00:11:53,279 --> 00:11:59,869
now this part is already prototyped

00:11:57,730 --> 00:12:02,999
[Music]

00:11:59,869 --> 00:12:06,029
assuming the current design we are in

00:12:02,999 --> 00:12:11,160
process to request distros to build the

00:12:06,029 --> 00:12:13,230
a5 our package on PowerPC 64 le and we

00:12:11,160 --> 00:12:15,509
use the a5 as I mentioned that you use

00:12:13,230 --> 00:12:18,600
the a5 are to manipulate secure boot

00:12:15,509 --> 00:12:20,990
variables and in the secure boot

00:12:18,600 --> 00:12:24,990
variables we store x.509 certificates

00:12:20,990 --> 00:12:28,170
and these are the secure boot variables

00:12:24,990 --> 00:12:31,379
we use the platform key the key exchange

00:12:28,170 --> 00:12:35,189
key and authorized signature database so

00:12:31,379 --> 00:12:37,170
the platform kid or PK for short it's

00:12:35,189 --> 00:12:42,959
the root of trust for the OS secure boot

00:12:37,170 --> 00:12:45,769
and when it said updates to any secure

00:12:42,959 --> 00:12:49,290
boot verbal requires authentication

00:12:45,769 --> 00:12:53,309
which means that if I want to update the

00:12:49,290 --> 00:12:55,499
platform key the PK the update the PK

00:12:53,309 --> 00:12:59,600
update needs to be signed with the caret

00:12:55,499 --> 00:13:02,579
PK if I want to update the Keck variable

00:12:59,600 --> 00:13:06,389
the CAC update needs to be signed by the

00:13:02,579 --> 00:13:08,490
current PK and if I want to update the

00:13:06,389 --> 00:13:11,100
DB variable the updates

00:13:08,490 --> 00:13:12,050
need to be signed by the end one of the

00:13:11,100 --> 00:13:17,810
CAC entry

00:13:12,050 --> 00:13:22,310
one of the khaki case and if the PK is

00:13:17,810 --> 00:13:27,250
said it also requires authentication now

00:13:22,310 --> 00:13:31,430
when we try to load to boot a kernel oil

00:13:27,250 --> 00:13:34,100
scanner and in it means that only

00:13:31,430 --> 00:13:36,350
authorized OS scans will be loaded will

00:13:34,100 --> 00:13:39,649
be exact we will be booted and in order

00:13:36,350 --> 00:13:44,120
to authorize a scanner to boot we need

00:13:39,649 --> 00:13:48,260
to to add the certificate that we use to

00:13:44,120 --> 00:13:54,680
to verify the the kernel into this DB

00:13:48,260 --> 00:13:59,959
variable here so what I'm trying to

00:13:54,680 --> 00:14:03,560
solve the former secure boot key is the

00:13:59,959 --> 00:14:05,720
suit the film secure boot case store we

00:14:03,560 --> 00:14:08,810
all need to to store the harbor key hash

00:14:05,720 --> 00:14:12,260
and it is starting to see prom it's a

00:14:08,810 --> 00:14:15,079
protected memory but for the OS secure

00:14:12,260 --> 00:14:17,000
boot key store we in the wire secure

00:14:15,079 --> 00:14:20,540
boot key store we have the PK the CAC

00:14:17,000 --> 00:14:24,020
and DB and these secure boot variables

00:14:20,540 --> 00:14:27,440
they are we reserved a partition in the

00:14:24,020 --> 00:14:31,579
processor nor which we start these

00:14:27,440 --> 00:14:35,270
variables but the problem is that the

00:14:31,579 --> 00:14:40,070
pin or the processor nor is protected by

00:14:35,270 --> 00:14:42,649
design so attackers could just have

00:14:40,070 --> 00:14:48,920
their malicious code executed for

00:14:42,649 --> 00:14:51,250
example if you have privilege in the OS

00:14:48,920 --> 00:14:55,880
would privilege in the OS or if you have

00:14:51,250 --> 00:14:59,570
privilege in the BMC or open in the open

00:14:55,880 --> 00:15:01,730
BMC which is our service processor you

00:14:59,570 --> 00:15:05,199
could have access to the processor law

00:15:01,730 --> 00:15:11,120
and change the key the secure boot case

00:15:05,199 --> 00:15:13,910
so we remember that we in the open power

00:15:11,120 --> 00:15:16,990
system systems we have the trusted

00:15:13,910 --> 00:15:20,510
platform module we have the TPM 2.0 and

00:15:16,990 --> 00:15:25,490
TPM 2.0 also provides novel a tomaten

00:15:20,510 --> 00:15:28,579
non-volatile memory and

00:15:25,490 --> 00:15:30,589
we could use that for store the secure

00:15:28,579 --> 00:15:33,379
boot keys you had protection to protect

00:15:30,589 --> 00:15:36,860
the secure boot keys but there is no

00:15:33,379 --> 00:15:40,279
space in the TPM envy to store to store

00:15:36,860 --> 00:15:43,910
all the the secure boot keys the secure

00:15:40,279 --> 00:15:49,759
boot variables so we need to store only

00:15:43,910 --> 00:15:52,730
what we really need in the TPM and V so

00:15:49,759 --> 00:15:54,589
let's see how we use the TPM NVRAM to

00:15:52,730 --> 00:15:58,129
protect the secure boot keys let's

00:15:54,589 --> 00:15:59,980
discuss this these issues here that we

00:15:58,129 --> 00:16:03,110
are addressing the integrity how we

00:15:59,980 --> 00:16:05,749
authorize access to the TPM and V and

00:16:03,110 --> 00:16:08,269
what variable should we store in the TPM

00:16:05,749 --> 00:16:15,949
and V in how do we provide atomic

00:16:08,269 --> 00:16:19,990
variable update so integrity the keys

00:16:15,949 --> 00:16:23,119
since the pin or the processor nor is

00:16:19,990 --> 00:16:27,230
not protected the keys could be modified

00:16:23,119 --> 00:16:30,350
without notice and that's why we we

00:16:27,230 --> 00:16:32,959
calculate a hash over the variables we

00:16:30,350 --> 00:16:36,649
store in the pin or and with that hash

00:16:32,959 --> 00:16:40,579
we can detect integrity issues it's also

00:16:36,649 --> 00:16:43,040
a five-shot sha-512 hash and we store

00:16:40,579 --> 00:16:47,720
the hash and also the size in the TPM

00:16:43,040 --> 00:16:50,779
and V and the case would be consumed the

00:16:47,720 --> 00:16:54,319
variables will be consumed only if did

00:16:50,779 --> 00:16:59,959
this integrity check pass so only if the

00:16:54,319 --> 00:17:06,289
keys are valid okay how do we authorize

00:16:59,959 --> 00:17:08,179
access to the TPM and V we store data in

00:17:06,289 --> 00:17:11,600
the TPM and V so we need to control

00:17:08,179 --> 00:17:15,140
access to the to the NV there are a few

00:17:11,600 --> 00:17:20,750
options here we could for example set a

00:17:15,140 --> 00:17:23,929
policy TPM policy to access this the

00:17:20,750 --> 00:17:27,470
data that the NV data we could share

00:17:23,929 --> 00:17:30,620
secrets with user space because the this

00:17:27,470 --> 00:17:33,220
data should be we should provide access

00:17:30,620 --> 00:17:35,600
to this data only for trusted identities

00:17:33,220 --> 00:17:38,179
we could provide access to the user

00:17:35,600 --> 00:17:39,420
space but we would need to to share

00:17:38,179 --> 00:17:42,260
secrets we will need to the

00:17:39,420 --> 00:17:45,150
a policy in that all that would

00:17:42,260 --> 00:17:48,810
complicate the design a little bit so

00:17:45,150 --> 00:17:53,180
instead we just write lock the envy

00:17:48,810 --> 00:17:57,660
memory at boot time into the next boot

00:17:53,180 --> 00:18:02,340
and that also adds a restriction in the

00:17:57,660 --> 00:18:06,260
in the design because the envy memory we

00:18:02,340 --> 00:18:09,510
locate it will be open only at boot time

00:18:06,260 --> 00:18:12,750
which means that if we have an updated

00:18:09,510 --> 00:18:15,540
the keys to those variables those

00:18:12,750 --> 00:18:17,490
updates should be processed only at boot

00:18:15,540 --> 00:18:20,910
time because that's the only time frame

00:18:17,490 --> 00:18:22,680
that we have the envy open and that's

00:18:20,910 --> 00:18:25,710
why we need we also need to have an

00:18:22,680 --> 00:18:27,780
update Q so if user space wants to

00:18:25,710 --> 00:18:30,600
manage the case all the updates should

00:18:27,780 --> 00:18:32,760
go first your the update Q and then at

00:18:30,600 --> 00:18:38,480
boot and reboot the system and at boot

00:18:32,760 --> 00:18:41,750
time we we process those updates and

00:18:38,480 --> 00:18:46,020
this the skewed Linux kernel is

00:18:41,750 --> 00:18:50,340
responsible to process those updates at

00:18:46,020 --> 00:18:53,970
boot time and so the skewed Linux kernel

00:18:50,340 --> 00:18:56,790
will process the updates and when the

00:18:53,970 --> 00:18:57,360
current skewed kernel is done with those

00:18:56,790 --> 00:19:02,570
updates

00:18:57,360 --> 00:19:07,770
it will right lock the the envy memory

00:19:02,570 --> 00:19:11,930
allocated and unix boot and what verbal

00:19:07,770 --> 00:19:15,780
should we store in the in the envy well

00:19:11,930 --> 00:19:19,020
if the platform key is lost we lose root

00:19:15,780 --> 00:19:22,350
of trust and our secure boot would be

00:19:19,020 --> 00:19:26,160
broken because we authentication

00:19:22,350 --> 00:19:32,100
wouldn't be required to to modify each

00:19:26,160 --> 00:19:35,400
mood to modify the keys in order to to

00:19:32,100 --> 00:19:38,640
boot a oh s Kerem and that's why we

00:19:35,400 --> 00:19:43,140
store the our root of trust or plot the

00:19:38,640 --> 00:19:45,060
platform key in the TPM and v what about

00:19:43,140 --> 00:19:46,760
the other the other variables we have in

00:19:45,060 --> 00:19:51,870
the processor north

00:19:46,760 --> 00:19:52,730
well the CAC and DV we wish to start

00:19:51,870 --> 00:19:55,429
them we can

00:19:52,730 --> 00:19:57,440
to start them in the process or not

00:19:55,429 --> 00:19:59,780
because we don't have space to start

00:19:57,440 --> 00:20:06,890
them in the TP M and V because DPM and V

00:19:59,780 --> 00:20:10,400
is a small it's less than 24 K and if we

00:20:06,890 --> 00:20:15,860
if the in treatment the integrity check

00:20:10,400 --> 00:20:18,830
fails on these variables here will not

00:20:15,860 --> 00:20:21,500
use them but there is no we don't need a

00:20:18,830 --> 00:20:23,510
special procedure to to recover those

00:20:21,500 --> 00:20:31,520
variables we can just submit new updates

00:20:23,510 --> 00:20:35,480
to those variables atomic variable

00:20:31,520 --> 00:20:39,679
update well now we have two storages we

00:20:35,480 --> 00:20:45,290
have keys in the processor or so and we

00:20:39,679 --> 00:20:47,150
also have case in the TP M and V and at

00:20:45,290 --> 00:20:51,350
the time that we are updating one of

00:20:47,150 --> 00:20:55,010
these especially the pin or sec the pin

00:20:51,350 --> 00:20:58,520
or the processor nor the right operation

00:20:55,010 --> 00:21:02,540
can fail we can have a power outage we

00:20:58,520 --> 00:21:04,730
can have a driver miss function and that

00:21:02,540 --> 00:21:06,770
would be a problem because the the keys

00:21:04,730 --> 00:21:12,130
would be in a bad state if that happens

00:21:06,770 --> 00:21:15,740
and that's why we we use two banks and

00:21:12,130 --> 00:21:18,980
we use a one bit in the TPM and V to

00:21:15,740 --> 00:21:23,090
indicate which bankers is the active is

00:21:18,980 --> 00:21:28,910
the current active and when we have

00:21:23,090 --> 00:21:30,919
updates to the to the variables we

00:21:28,910 --> 00:21:34,010
process those updates and apply the

00:21:30,919 --> 00:21:42,380
updates to the staging bank without

00:21:34,010 --> 00:21:45,710
touching the current active and when we

00:21:42,380 --> 00:21:49,820
finish to apply all the updates we then

00:21:45,710 --> 00:21:52,610
flip the bit this Bank selector bit to

00:21:49,820 --> 00:21:55,640
indicate that okay I'm done with all the

00:21:52,610 --> 00:21:58,880
rights and now let's reboot the system

00:21:55,640 --> 00:22:00,890
and use the new keys make sure that

00:21:58,880 --> 00:22:06,530
everybody everybody will use the new

00:22:00,890 --> 00:22:10,430
case okay now we know

00:22:06,530 --> 00:22:15,350
what data we are storing in the TPM envy

00:22:10,430 --> 00:22:19,940
and how do we create how do we allocate

00:22:15,350 --> 00:22:23,510
memory the TPM Envy use this Envy define

00:22:19,940 --> 00:22:26,450
Space Command but we don't interact

00:22:23,510 --> 00:22:29,990
directly with the tip M&T with the TPM

00:22:26,450 --> 00:22:32,180
actually TPM chip we use a TCG software

00:22:29,990 --> 00:22:34,340
stack an implementation of the TCG

00:22:32,180 --> 00:22:38,570
software stack and TCG stands for trust

00:22:34,340 --> 00:22:42,050
4 stands for trusted computing group and

00:22:38,570 --> 00:22:46,850
this is a distance this DSS is a IBM's

00:22:42,050 --> 00:22:51,290
DSS implementation so we need to use

00:22:46,850 --> 00:22:56,890
this NV define space to define an index

00:22:51,290 --> 00:23:03,020
and we need to provide the handle of the

00:22:56,890 --> 00:23:07,910
index and also provide the attributes

00:23:03,020 --> 00:23:13,340
and the size for this in the index as

00:23:07,910 --> 00:23:16,940
you can see here at the bottom we we

00:23:13,340 --> 00:23:22,610
need more than 2k bytes and there is a

00:23:16,940 --> 00:23:25,910
restriction in the TPM 2.0 that the end

00:23:22,610 --> 00:23:29,840
the maximum size for a NV index is 2 ok

00:23:25,910 --> 00:23:32,090
so that's why we need to create 3 index

00:23:29,840 --> 00:23:34,640
so we have 1 index for the header

00:23:32,090 --> 00:23:40,010
another index for the bank 0 in other

00:23:34,640 --> 00:23:43,360
index 4 for the bank 1 but they all have

00:23:40,010 --> 00:23:46,940
the same attributes but different sizes

00:23:43,360 --> 00:23:49,400
and they all they are all right Lockett

00:23:46,940 --> 00:23:52,490
at boot time went to the next boot so

00:23:49,400 --> 00:23:54,860
here we need to provide to create this

00:23:52,490 --> 00:23:57,320
to define this index indices we need to

00:23:54,860 --> 00:24:08,500
provide the TPM platform authorization

00:23:57,320 --> 00:24:08,500
and also define this the NV atributes

00:24:10,390 --> 00:24:16,220
define the NV attributes and there is

00:24:14,810 --> 00:24:19,260
another command here and if you read

00:24:16,220 --> 00:24:21,390
public where we can read the the

00:24:19,260 --> 00:24:24,750
the index attributes and here it shows

00:24:21,390 --> 00:24:29,370
that it's six bytes the sizes six bytes

00:24:24,750 --> 00:24:32,130
and the attributes are VPP right all

00:24:29,370 --> 00:24:35,820
these attributes here and P P right and

00:24:32,130 --> 00:24:38,640
all fright means that the if you provide

00:24:35,820 --> 00:24:41,610
the platform authorization or the index

00:24:38,640 --> 00:24:44,520
authorization you should be able to to

00:24:41,610 --> 00:24:48,600
update this to write to these indices to

00:24:44,520 --> 00:24:52,650
these indices here and it they are all

00:24:48,600 --> 00:24:54,780
ordinary in this indices which means

00:24:52,650 --> 00:24:57,660
that we can store any data structure in

00:24:54,780 --> 00:25:02,000
those indices right a stick clear means

00:24:57,660 --> 00:25:06,630
that if right if right lock is is called

00:25:02,000 --> 00:25:12,450
the the right locked bit will be cleared

00:25:06,630 --> 00:25:15,210
when the TPM is reset or we started and

00:25:12,450 --> 00:25:18,210
platform created means that only the

00:25:15,210 --> 00:25:19,620
platform authorization only if we

00:25:18,210 --> 00:25:23,370
provide the Pratt the platform

00:25:19,620 --> 00:25:27,420
authorization we can undefined this in

00:25:23,370 --> 00:25:31,620
this these indices few more secure boot

00:25:27,420 --> 00:25:35,370
and V in the index well I didn't mention

00:25:31,620 --> 00:25:40,400
that we we also we are also storing data

00:25:35,370 --> 00:25:43,860
for the firmware secure boot but we are

00:25:40,400 --> 00:25:46,590
so we define one index and the ending in

00:25:43,860 --> 00:25:50,550
the Indies in this index we store only

00:25:46,590 --> 00:25:53,670
the Hydra key hash because we have two

00:25:50,550 --> 00:25:58,410
domains and if the feel more secure boot

00:25:53,670 --> 00:26:00,180
domain change if the hardware key if the

00:25:58,410 --> 00:26:02,910
hybrid keys are changed in the firm

00:26:00,180 --> 00:26:05,970
secure boot domain that means we need to

00:26:02,910 --> 00:26:08,460
invalidate the root of trust of the oil

00:26:05,970 --> 00:26:11,160
secure boot in other words invalidate

00:26:08,460 --> 00:26:17,580
the pk and that's why we we also need to

00:26:11,160 --> 00:26:20,220
store to have this fumer env index we

00:26:17,580 --> 00:26:22,410
have other commands here so and we write

00:26:20,220 --> 00:26:24,180
we can write the index and we need to

00:26:22,410 --> 00:26:27,660
provide the authorization here I'm using

00:26:24,180 --> 00:26:31,620
the platform TPM platform authorization

00:26:27,660 --> 00:26:32,800
and last and I write in this first

00:26:31,620 --> 00:26:35,590
command I write Linux

00:26:32,800 --> 00:26:40,000
here at summit to the to this index here

00:26:35,590 --> 00:26:43,390
and then I read and set the output file

00:26:40,000 --> 00:26:46,150
- to the LSS dot txt and after that I

00:26:43,390 --> 00:26:48,040
just accident the LS and txt just to

00:26:46,150 --> 00:26:51,550
make sure that I have the content that I

00:26:48,040 --> 00:26:54,130
just wrote so we can write locked in the

00:26:51,550 --> 00:26:57,850
index until the next boot and to the

00:26:54,130 --> 00:27:02,230
next camera set or TPM start and after

00:26:57,850 --> 00:27:04,870
we write lock the index we if we write

00:27:02,230 --> 00:27:08,320
try to write to the index it will tell

00:27:04,870 --> 00:27:12,130
us that it's right lock it we cannot

00:27:08,320 --> 00:27:14,710
define in in the index and when it's

00:27:12,130 --> 00:27:18,750
undefined - and in order to define any

00:27:14,710 --> 00:27:21,450
of the in the index indices we we define

00:27:18,750 --> 00:27:23,290
you need to provide the platform

00:27:21,450 --> 00:27:26,830
authorization the TPM platform

00:27:23,290 --> 00:27:30,100
authorization and was after you you

00:27:26,830 --> 00:27:32,380
define you undefined the index if you

00:27:30,100 --> 00:27:36,370
try to read from that index it no longer

00:27:32,380 --> 00:27:38,740
exists there is also command to set the

00:27:36,370 --> 00:27:43,840
platform authorization to Anam default

00:27:38,740 --> 00:27:48,310
it is important because if you leave it

00:27:43,840 --> 00:27:50,860
with the default password an attacker

00:27:48,310 --> 00:27:55,630
could just undefined our index even even

00:27:50,860 --> 00:27:58,450
if we write lock the index so this is

00:27:55,630 --> 00:28:05,650
the OS secure boot architecture with the

00:27:58,450 --> 00:28:08,260
updated payment via updates opal is the

00:28:05,650 --> 00:28:13,270
open power abstraction layer is

00:28:08,260 --> 00:28:19,150
responsible to define the env indices

00:28:13,270 --> 00:28:22,780
and also and write lock the fumer index

00:28:19,150 --> 00:28:25,630
and it also provides the open runtime

00:28:22,780 --> 00:28:27,880
services that which in turn provide

00:28:25,630 --> 00:28:33,100
access to the key storage the pin or set

00:28:27,880 --> 00:28:35,770
boot and there is the update queue in

00:28:33,100 --> 00:28:38,440
the pin or sack boot which is processed

00:28:35,770 --> 00:28:46,269
only at boot time by the secure boot

00:28:38,440 --> 00:28:50,109
Linux kernel the TPM env itself it it

00:28:46,269 --> 00:28:56,349
it can be accessed by Oppo Linux Delhi

00:28:50,109 --> 00:28:58,450
or in subsequent linux kernel's and they

00:28:56,349 --> 00:29:00,580
are right locket the linux kernel will

00:28:58,450 --> 00:29:04,959
process the updates at the real time and

00:29:00,580 --> 00:29:10,989
at that point the the OS and the index

00:29:04,959 --> 00:29:16,119
is right locket and I had to implement

00:29:10,989 --> 00:29:23,379
we had to implement a TSS in the opal

00:29:16,119 --> 00:29:28,389
layer and also TPM drivers to support to

00:29:23,379 --> 00:29:33,369
interact with the TPM 2.0 so final

00:29:28,389 --> 00:29:35,169
considerations the TPM 2.0 have shown a

00:29:33,369 --> 00:29:36,309
secure and available storage protect

00:29:35,169 --> 00:29:38,859
secure boot case we don't need

00:29:36,309 --> 00:29:42,219
necessarily G to store all the keys in

00:29:38,859 --> 00:29:44,349
the T payment v so I showed that we can

00:29:42,219 --> 00:29:46,329
store only this home information some

00:29:44,349 --> 00:29:51,129
data in the T payment input and protect

00:29:46,329 --> 00:29:53,320
the keys and it has several commands

00:29:51,129 --> 00:29:56,409
that you can use to interact with the

00:29:53,320 --> 00:30:00,190
TPM and V so we can write lock we can

00:29:56,409 --> 00:30:05,109
define allocate memory we can delegate

00:30:00,190 --> 00:30:07,450
memory and by using a TPM to provide

00:30:05,109 --> 00:30:11,229
secure boot that adds a dependency on

00:30:07,450 --> 00:30:15,190
the TPM 2.0 so open power o a secure

00:30:11,229 --> 00:30:17,709
boot depends on TPM 2.0 and TPM 2.0 is

00:30:15,190 --> 00:30:21,369
is available in the power 9 systems of

00:30:17,709 --> 00:30:23,079
power 9 open power systems sharing the

00:30:21,369 --> 00:30:26,499
DSS code throughout the femur stack is

00:30:23,079 --> 00:30:28,719
challenging because the film stack each

00:30:26,499 --> 00:30:32,320
each each component in the film stack

00:30:28,719 --> 00:30:33,999
has different requirements and they

00:30:32,320 --> 00:30:38,700
don't need to have a full TSS

00:30:33,999 --> 00:30:41,259
implementation and we don't have trust

00:30:38,700 --> 00:30:45,309
protected memory to store a TSS

00:30:41,259 --> 00:30:50,440
implementation so it's challenging and

00:30:45,309 --> 00:30:52,389
variables mode well the IBM's DSS

00:30:50,440 --> 00:30:57,309
implementation it provides very Bo's

00:30:52,389 --> 00:31:00,250
mode you can just pass - - V in the

00:30:57,309 --> 00:31:05,019
command and that will show you all the

00:31:00,250 --> 00:31:08,679
the steps that it goes to send the

00:31:05,019 --> 00:31:10,659
command to the TPM chip and I think

00:31:08,679 --> 00:31:13,899
that's very interesting that helped me a

00:31:10,659 --> 00:31:16,090
lot because I could say what what's the

00:31:13,899 --> 00:31:19,059
stream byte and that what is the byte

00:31:16,090 --> 00:31:22,149
stream that was sent and received from

00:31:19,059 --> 00:31:23,889
the TPM so it was good for me to

00:31:22,149 --> 00:31:29,440
validate the commands or the

00:31:23,889 --> 00:31:32,470
implementation in the server stack and

00:31:29,440 --> 00:31:34,509
here's some references open power

00:31:32,470 --> 00:31:36,879
foundation you can find more information

00:31:34,509 --> 00:31:39,279
about open power systems in the open

00:31:36,879 --> 00:31:41,440
power foundation and the firmer is open

00:31:39,279 --> 00:31:45,340
source you can find the humor in the

00:31:41,440 --> 00:31:48,009
github if you want to know more power 9

00:31:45,340 --> 00:31:51,399
boot flow you can go to that to this

00:31:48,009 --> 00:31:54,220
other one link here and in the following

00:31:51,399 --> 00:31:56,409
one you have more information about open

00:31:54,220 --> 00:32:00,730
power secure boot few more open power

00:31:56,409 --> 00:32:02,889
secure boot trusted platform module all

00:32:00,730 --> 00:32:08,620
these specifications are available in

00:32:02,889 --> 00:32:10,750
the TCG website and IBM CSS

00:32:08,620 --> 00:32:15,940
implementation it's a good source you

00:32:10,750 --> 00:32:20,519
can find it in this link here and that's

00:32:15,940 --> 00:32:20,519
it unless anybody have any questions so

00:32:27,539 --> 00:32:33,879
am I right in understanding that there

00:32:31,509 --> 00:32:38,049
is no rollback protection in this design

00:32:33,879 --> 00:32:42,159
or if it is I missed it which is like do

00:32:38,049 --> 00:32:46,299
you have rollback protection no we don't

00:32:42,159 --> 00:32:50,559
provide that it's complicated to revert

00:32:46,299 --> 00:32:52,000
to have rollback initially we thought

00:32:50,559 --> 00:32:54,389
that we could have but that's

00:32:52,000 --> 00:32:54,389
complicated

00:32:59,460 --> 00:33:06,490
thanks for a talk please correct me if

00:33:02,559 --> 00:33:09,639
I'm wrong so secure boot helps to verify

00:33:06,490 --> 00:33:15,789
that our kernel operating system kernel

00:33:09,639 --> 00:33:18,519
is not compromised right and can you at

00:33:15,789 --> 00:33:23,110
the same time use the PM for verifying

00:33:18,519 --> 00:33:25,240
that your firmware is not compromised so

00:33:23,110 --> 00:33:29,230
yeah like like boot guard or something

00:33:25,240 --> 00:33:33,250
like that yeah we provide this feature

00:33:29,230 --> 00:33:36,159
in the few more secure boot here so all

00:33:33,250 --> 00:33:38,740
the boxes in yellow this former is a

00:33:36,159 --> 00:33:43,559
firmer stack the security is bootloader

00:33:38,740 --> 00:33:52,779
and here's the host OS kernel so we use

00:33:43,559 --> 00:33:56,289
we provide we boot only thermal images

00:33:52,779 --> 00:34:00,250
that are trusted in this case here if

00:33:56,289 --> 00:34:02,919
they are sign it with the keys we trust

00:34:00,250 --> 00:34:04,960
which means the hardware keys so they

00:34:02,919 --> 00:34:08,020
need to be signed with trusted keys and

00:34:04,960 --> 00:34:10,210
the trusted and def hardware key hash

00:34:08,020 --> 00:34:13,119
that heydrich those Hardware case those

00:34:10,210 --> 00:34:15,760
keys need to be the trusted one that the

00:34:13,119 --> 00:34:18,550
keys we trust so that's how we provides

00:34:15,760 --> 00:34:22,750
a few more secure boot does that answer

00:34:18,550 --> 00:34:27,210
your question and does this use TPM or

00:34:22,750 --> 00:34:30,839
for this key for this root of trust

00:34:27,210 --> 00:34:30,839
where it is stored

00:34:31,690 --> 00:34:37,009
I'm not sure if I understand your

00:34:33,649 --> 00:34:45,259
question but to use the TPM as a storage

00:34:37,009 --> 00:34:50,419
and we also use the all the capabilities

00:34:45,259 --> 00:34:52,879
that it provides to to to restrict

00:34:50,419 --> 00:34:57,650
access to the env yes

00:34:52,879 --> 00:35:01,059
so you use TPM both for keys for

00:34:57,650 --> 00:35:03,589
firmware verification and both for or

00:35:01,059 --> 00:35:08,869
secure boot

00:35:03,589 --> 00:35:12,680
we use the TPM only for for the OS so

00:35:08,869 --> 00:35:17,150
only for store keys keys that we use to

00:35:12,680 --> 00:35:20,660
boot the OS the other keys are stored in

00:35:17,150 --> 00:35:23,990
the container so in the container you

00:35:20,660 --> 00:35:26,720
find the public keys the signature in

00:35:23,990 --> 00:35:29,480
the secure boot container you find the

00:35:26,720 --> 00:35:32,299
public keys the signature everything

00:35:29,480 --> 00:35:34,549
that is required to verify that image

00:35:32,299 --> 00:35:38,690
but ok how do I know how do I know that

00:35:34,549 --> 00:35:40,940
that container is trusted well I use

00:35:38,690 --> 00:35:43,609
this verification code here to do this

00:35:40,940 --> 00:35:46,640
to check if the container is valid the

00:35:43,609 --> 00:35:50,690
format is valid and also to verify each

00:35:46,640 --> 00:35:54,619
signature and the root of trust is the

00:35:50,690 --> 00:35:56,779
Hydra keys so I just calculate a hash of

00:35:54,619 --> 00:35:59,329
those Hardware keys available in the

00:35:56,779 --> 00:36:01,069
container and compare with the hash that

00:35:59,329 --> 00:36:03,380
I have that I have you store in the

00:36:01,069 --> 00:36:05,180
protected memory if those two hashes

00:36:03,380 --> 00:36:10,089
match that's ok

00:36:05,180 --> 00:36:10,089
I can trust that container thank you

00:36:15,100 --> 00:36:21,680
so maybe I misunderstood but are you

00:36:18,740 --> 00:36:26,390
putting the PK as well as the hash the

00:36:21,680 --> 00:36:27,950
PK in this NV index no okay I'm trying

00:36:26,390 --> 00:36:32,410
to figure out how you're consuming so

00:36:27,950 --> 00:36:37,970
much space in there no no we're not we

00:36:32,410 --> 00:36:41,330
we put only the we we calculate a hash

00:36:37,970 --> 00:36:43,970
over what we have in the the processor

00:36:41,330 --> 00:36:53,870
lore and in the processor nor we know we

00:36:43,970 --> 00:36:57,290
we don't have the PK that was a here so

00:36:53,870 --> 00:37:01,910
this hash is calculated over kak in DB

00:36:57,290 --> 00:37:04,160
okay but those aren't too keen sighs I'm

00:37:01,910 --> 00:37:08,390
trying me you consume a lot of nd space

00:37:04,160 --> 00:37:11,270
yes trying to figure out what I'm not

00:37:08,390 --> 00:37:16,100
quite understanding what's in there hash

00:37:11,270 --> 00:37:18,920
isn't that big that that's why I asked

00:37:16,100 --> 00:37:22,520
me said no well they keep the P so why

00:37:18,920 --> 00:37:25,460
are you putting the PK in the nd because

00:37:22,520 --> 00:37:28,460
we we have some protective you don't

00:37:25,460 --> 00:37:31,460
need the whole PK in there yeah but if

00:37:28,460 --> 00:37:35,630
we if we have a with the hash we can

00:37:31,460 --> 00:37:39,110
detect integrity issues you keep the PK

00:37:35,630 --> 00:37:42,590
outside yes verify with what's an MD and

00:37:39,110 --> 00:37:44,600
then you can use it the problem is if

00:37:42,590 --> 00:37:47,090
the integrity check fails on the

00:37:44,600 --> 00:37:50,360
variables I store in the processor or I

00:37:47,090 --> 00:37:55,400
can't use those heroes anymore and if

00:37:50,360 --> 00:37:59,180
the PK is there well my route of trust

00:37:55,400 --> 00:38:02,600
is compromised I can't trust on any our

00:37:59,180 --> 00:38:05,600
own on any any code that is loaded from

00:38:02,600 --> 00:38:07,510
that point on so it's a starter it's a

00:38:05,600 --> 00:38:10,130
reliability issue you're concerned about

00:38:07,510 --> 00:38:14,060
not necessarily skippered shifty bangs

00:38:10,130 --> 00:38:17,060
yes we have okay all right but if if the

00:38:14,060 --> 00:38:18,890
module fails with PK is wrong and if the

00:38:17,060 --> 00:38:21,500
the code is wrong and the PK doesn't

00:38:18,890 --> 00:38:24,440
verify it you're still in a non boot

00:38:21,500 --> 00:38:26,430
situation if someone can attack the PK

00:38:24,440 --> 00:38:28,829
they can attack the rest of the code

00:38:26,430 --> 00:38:31,289
and then that code won't verify and

00:38:28,829 --> 00:38:33,869
you're in the same position as if the PK

00:38:31,289 --> 00:38:38,250
was messed with I'm still not seeing the

00:38:33,869 --> 00:38:39,750
benefit yeah yeah in our case because in

00:38:38,250 --> 00:38:42,480
the TPM in V I'm trying to understand

00:38:39,750 --> 00:38:45,210
yeah how could someone change the PK in

00:38:42,480 --> 00:38:46,319
the TPM in V don't write lock it I think

00:38:45,210 --> 00:38:58,079
we're out of time we can talk offline

00:38:46,319 --> 00:38:59,789
yeah Thank You Monty surfer the Linux

00:38:58,079 --> 00:39:03,059
boot worked I described yesterday we're

00:38:59,789 --> 00:39:05,460
using the Chrome verified boot model

00:39:03,059 --> 00:39:06,720
which does do anti rollback and I'm just

00:39:05,460 --> 00:39:13,529
wondering if you looked at that at all

00:39:06,720 --> 00:39:14,670
the Chromebook use of TPM let me see if

00:39:13,529 --> 00:39:16,619
I understand can repeat the your

00:39:14,670 --> 00:39:19,559
questions please so Chromebooks have

00:39:16,619 --> 00:39:22,309
used the TPM and roughly a similar way

00:39:19,559 --> 00:39:25,079
but they do implement anti rollback

00:39:22,309 --> 00:39:26,369
protection and there are just there are

00:39:25,079 --> 00:39:27,839
points of correspondence between what

00:39:26,369 --> 00:39:29,400
you're describing here and how

00:39:27,839 --> 00:39:31,230
Chromebooks work I was just wondering if

00:39:29,400 --> 00:39:33,720
you looked at how the Chromebooks

00:39:31,230 --> 00:39:37,770
implemented the verified boot when you

00:39:33,720 --> 00:39:41,130
were doing this work yeah I'm not aware

00:39:37,770 --> 00:39:43,890
of the Chrome OS implementation okay I I

00:39:41,130 --> 00:39:46,140
think it'd be pretty rewarding yeah this

00:39:43,890 --> 00:39:46,890
is neat but I think that that would you

00:39:46,140 --> 00:39:49,410
know help a little

00:39:46,890 --> 00:39:52,529
and your efi services thing looks really

00:39:49,410 --> 00:39:54,720
neat was that a kernel module the the

00:39:52,529 --> 00:39:58,140
thing that implemented efi services and

00:39:54,720 --> 00:40:01,730
then use the Opel services yeah that

00:39:58,140 --> 00:40:07,109
part is is too in progress

00:40:01,730 --> 00:40:09,450
we need to find a way that only the dead

00:40:07,109 --> 00:40:13,529
part is loaded that I think it's gonna

00:40:09,450 --> 00:40:15,750
be a margin but okay not a margin but I

00:40:13,529 --> 00:40:18,029
think that we can disable using a kernel

00:40:15,750 --> 00:40:21,059
symbol it is part of the Linux kernel

00:40:18,029 --> 00:40:23,190
though the yes that's neat okay thanks

00:40:21,059 --> 00:40:27,329
that was I was curious about that thing

00:40:23,190 --> 00:40:31,890
yeah yeah the the spirit is a fork of

00:40:27,329 --> 00:40:33,930
the vanilla kernel okay so we're a

00:40:31,890 --> 00:40:36,730
little over time so thank you a lot of

00:40:33,930 --> 00:40:39,690
questions later thank you guys

00:40:36,730 --> 00:40:39,690

YouTube URL: https://www.youtube.com/watch?v=8baIs5h-tI4


