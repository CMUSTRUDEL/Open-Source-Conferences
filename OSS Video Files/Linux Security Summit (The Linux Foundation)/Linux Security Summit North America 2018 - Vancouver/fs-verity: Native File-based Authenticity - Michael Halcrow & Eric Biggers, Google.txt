Title: fs-verity: Native File-based Authenticity - Michael Halcrow & Eric Biggers, Google
Publication date: 2018-08-31
Playlist: Linux Security Summit North America 2018 - Vancouver
Description: 
	fs-verity: Native File-based Authenticity - Michael Halcrow & Eric Biggers, Google

The Android platform uses dm-verity to protect its system image, but there are critical components in that image that require incremental updates. Michael Halcrow and Eric Biggers introduce fs-verity as a mechanism for file systems to validate the authenticity of individual files. They furthermore propose fs-verity as a capability that can integrate with the Integrity Measurement Architecture (IMA) to efficiently validate only the parts of a file that are accessed. They will also discuss potential applications of file-based authenticity in validating container image content.

About Eric Biggers
Google


About Michael Halcrow
Michael Halcrow is a software engineer at Google in Seattle. He was the original author of both eCryptfs and native file-based encryption in the upstream Linux kernel. He has previously spoken at the Ottawa Linux Symposium and at several Linux Security Summits.
Captions: 
	00:00:00,000 --> 00:00:04,650
hello my name is Michael crow and I'm

00:00:02,879 --> 00:00:08,460
here with Eric vigourous my colleague

00:00:04,650 --> 00:00:10,019
and we're gonna present on FS parity now

00:00:08,460 --> 00:00:13,860
we're just presenting on this but this

00:00:10,019 --> 00:00:15,269
is actually an effort that that's being

00:00:13,860 --> 00:00:18,060
contributed to by multiple people

00:00:15,269 --> 00:00:20,730
including Ted so and and Victor who's

00:00:18,060 --> 00:00:25,859
also here from from the Android team and

00:00:20,730 --> 00:00:29,519
so forth and so we've started out with

00:00:25,859 --> 00:00:32,540
some design work a year ago and I'd like

00:00:29,519 --> 00:00:36,930
to say any any good parts of the design

00:00:32,540 --> 00:00:38,850
came from Ted any questionable parts

00:00:36,930 --> 00:00:41,850
I'll take the fall for personally and

00:00:38,850 --> 00:00:43,649
then code wise anything that's good King

00:00:41,850 --> 00:00:45,629
comes from Erik and anything

00:00:43,649 --> 00:00:49,680
questionable you seen the code again

00:00:45,629 --> 00:00:52,170
I'll take the fall for that and so just

00:00:49,680 --> 00:00:56,039
by way of background you know I've I

00:00:52,170 --> 00:00:58,649
originally wrote e crypt FS some of you

00:00:56,039 --> 00:01:00,600
may have heard of it and I apologize

00:00:58,649 --> 00:01:03,629
every opportunity I get for having done

00:01:00,600 --> 00:01:07,049
any crypt of s I'm sorry that and and

00:01:03,629 --> 00:01:09,990
I've since also done F s crypt which is

00:01:07,049 --> 00:01:13,110
the it together again with Ted and and

00:01:09,990 --> 00:01:16,500
other contributors that's the native

00:01:13,110 --> 00:01:18,900
encryption capability and ext4 and f2s

00:01:16,500 --> 00:01:22,170
ff2 FS and anyone else who's interested

00:01:18,900 --> 00:01:26,280
in integrating FS crypt of course always

00:01:22,170 --> 00:01:27,360
interested in having a chat so don't

00:01:26,280 --> 00:01:29,850
talk a little bit about taking

00:01:27,360 --> 00:01:33,509
measurements of contents of storage DM

00:01:29,850 --> 00:01:36,150
Verity and then doing integrity and

00:01:33,509 --> 00:01:37,500
authenticity in the file system then

00:01:36,150 --> 00:01:39,720
we're gonna introduce some of the work

00:01:37,500 --> 00:01:42,240
that we've been doing with FS severity

00:01:39,720 --> 00:01:48,299
and what some of the use cases are that

00:01:42,240 --> 00:01:50,780
we have in mind so really at the core of

00:01:48,299 --> 00:01:53,009
all this it's about taking hashes and

00:01:50,780 --> 00:01:54,899
you know we take measurements of

00:01:53,009 --> 00:01:58,590
contents of storage in order in order to

00:01:54,899 --> 00:02:01,979
establish identity and you know hash is

00:01:58,590 --> 00:02:04,740
a trapdoor one-way function what that

00:02:01,979 --> 00:02:06,149
means is we take a pre-image which can

00:02:04,740 --> 00:02:07,770
be of arbitrary length and you run it

00:02:06,149 --> 00:02:09,289
through this hash algorithm and you end

00:02:07,770 --> 00:02:11,849
up getting just a few dozen bytes and

00:02:09,289 --> 00:02:13,500
those few dozen bytes can reliably

00:02:11,849 --> 00:02:16,130
uniquely identify

00:02:13,500 --> 00:02:19,020
the thing that you're taking the hash of

00:02:16,130 --> 00:02:21,560
what you can do then is you can do a

00:02:19,020 --> 00:02:24,690
verification of the root of trust

00:02:21,560 --> 00:02:26,160
against a root of trust for that few

00:02:24,690 --> 00:02:30,690
dozen bites that you generate from the

00:02:26,160 --> 00:02:33,120
hash algorithm when you take hash of an

00:02:30,690 --> 00:02:35,280
object you measure the entire thing

00:02:33,120 --> 00:02:36,990
prior to taking further action with that

00:02:35,280 --> 00:02:39,030
thing

00:02:36,990 --> 00:02:41,190
there can be significant latency on

00:02:39,030 --> 00:02:45,050
initial access of it especially if it's

00:02:41,190 --> 00:02:50,370
a large object and if the computational

00:02:45,050 --> 00:02:52,680
resources of the platform are limited if

00:02:50,370 --> 00:02:56,280
you take an initial measurement of this

00:02:52,680 --> 00:02:58,290
whole thing you can validate it before

00:02:56,280 --> 00:03:00,120
you even begin access to that thing

00:02:58,290 --> 00:03:02,459
which is a really nice security property

00:03:00,120 --> 00:03:05,880
and oftentimes a requirement given on

00:03:02,459 --> 00:03:10,250
you know given what your what your

00:03:05,880 --> 00:03:13,230
security adversarial model looks like

00:03:10,250 --> 00:03:15,030
however there's no further revalidation

00:03:13,230 --> 00:03:19,230
of the contents coming from storage

00:03:15,030 --> 00:03:20,970
after that initial measurement and so if

00:03:19,230 --> 00:03:23,489
you have a malicious data source such as

00:03:20,970 --> 00:03:25,709
a file server or a disk or controller

00:03:23,489 --> 00:03:30,239
firmware which has been attacked in some

00:03:25,709 --> 00:03:32,030
way then you can play games through this

00:03:30,239 --> 00:03:34,400
man in the disk so to speak and make

00:03:32,030 --> 00:03:36,690
changes after the initial measurement

00:03:34,400 --> 00:03:38,340
there are firmware attacks you can look

00:03:36,690 --> 00:03:39,600
up things like equation drug and greyish

00:03:38,340 --> 00:03:40,739
and so forth this is something that's

00:03:39,600 --> 00:03:42,810
been around for quite some time

00:03:40,739 --> 00:03:47,880
and it is something you have to worry

00:03:42,810 --> 00:03:49,739
about in several contexts so an

00:03:47,880 --> 00:03:52,590
alternative way to taking a measurement

00:03:49,739 --> 00:03:54,180
of the entire object all at once is to

00:03:52,590 --> 00:03:56,010
use an authenticated dictionary

00:03:54,180 --> 00:03:57,660
structure now there are several

00:03:56,010 --> 00:03:59,220
different structures that exist and they

00:03:57,660 --> 00:04:02,090
have various pros and cons depending

00:03:59,220 --> 00:04:04,470
upon what your usage requirements are

00:04:02,090 --> 00:04:07,799
but one of the common ones is a Merkel

00:04:04,470 --> 00:04:10,140
tree and with the Merkel tree what you

00:04:07,799 --> 00:04:13,140
do is you segment what it is that you're

00:04:10,140 --> 00:04:15,660
measuring in two chunks you measure the

00:04:13,140 --> 00:04:17,760
individual chunks and then you take the

00:04:15,660 --> 00:04:24,030
measurements of the measurements all the

00:04:17,760 --> 00:04:26,900
way up to some top level and so what

00:04:24,030 --> 00:04:29,350
this allows you to do is to take a

00:04:26,900 --> 00:04:33,979
Harshal measurement while ensuring

00:04:29,350 --> 00:04:36,680
comprehensive validation because all you

00:04:33,979 --> 00:04:38,210
need to do is do a signature against the

00:04:36,680 --> 00:04:41,210
top level of the authenticated

00:04:38,210 --> 00:04:44,090
dictionary structure and after you

00:04:41,210 --> 00:04:45,560
access some subset of the object you can

00:04:44,090 --> 00:04:48,830
say well at least the part that I've

00:04:45,560 --> 00:04:51,259
looked at has been validated against a

00:04:48,830 --> 00:04:56,630
digital signature which is done on the

00:04:51,259 --> 00:04:59,979
top of the data structure when you first

00:04:56,630 --> 00:05:03,410
access the object the time it takes

00:04:59,979 --> 00:05:04,820
latency wise is a logarithm of the

00:05:03,410 --> 00:05:06,500
object size because you don't have to

00:05:04,820 --> 00:05:10,220
read the entire object before you begin

00:05:06,500 --> 00:05:14,720
access to it now the trade-off with this

00:05:10,220 --> 00:05:20,030
of course is that IO errors are possible

00:05:14,720 --> 00:05:22,940
while you're processing the file so this

00:05:20,030 --> 00:05:25,880
allows for an attacker to be creative by

00:05:22,940 --> 00:05:27,470
injecting faults in the middle of the

00:05:25,880 --> 00:05:30,410
file that you're accessing and thus

00:05:27,470 --> 00:05:32,810
having some arbitrary manipulation of

00:05:30,410 --> 00:05:34,750
the execution of the process by virtue

00:05:32,810 --> 00:05:37,910
of the fact that you've gone a certain

00:05:34,750 --> 00:05:39,490
amount of computation you've generated a

00:05:37,910 --> 00:05:41,630
certain number of side effects you've

00:05:39,490 --> 00:05:42,949
impacted the environment maybe sent out

00:05:41,630 --> 00:05:45,620
some network packets or what have you

00:05:42,949 --> 00:05:48,199
and then BAM you get an IO error and you

00:05:45,620 --> 00:05:51,470
can select where that IO IO error occurs

00:05:48,199 --> 00:05:52,610
and so that is a concern when you're

00:05:51,470 --> 00:05:58,580
when you're taking this particular

00:05:52,610 --> 00:06:00,680
approach so how many people who have

00:05:58,580 --> 00:06:02,240
Android devices when you turn on your

00:06:00,680 --> 00:06:04,449
phones how many how many of you get this

00:06:02,240 --> 00:06:09,470
something that looks like this

00:06:04,449 --> 00:06:12,650
okay surprising few this this is what

00:06:09,470 --> 00:06:14,750
you see because when you when you

00:06:12,650 --> 00:06:18,139
disable Android verified boot and so

00:06:14,750 --> 00:06:21,080
this is a feature of Android where we

00:06:18,139 --> 00:06:22,570
take the system image and we generated

00:06:21,080 --> 00:06:25,610
an authenticated dictionary structure

00:06:22,570 --> 00:06:28,729
against this system image and pushed it

00:06:25,610 --> 00:06:31,430
out and then we have some keys which are

00:06:28,729 --> 00:06:34,039
in the secure environment on the on the

00:06:31,430 --> 00:06:36,349
platform that are used to validate the

00:06:34,039 --> 00:06:39,219
root of this authenticated dictionary

00:06:36,349 --> 00:06:41,120
structure or a Merkel tree and and if

00:06:39,219 --> 00:06:43,870
you're unable to valid

00:06:41,120 --> 00:06:46,040
the authenticity of the system partition

00:06:43,870 --> 00:06:47,270
then we give this morning saying hey

00:06:46,040 --> 00:06:50,350
look we don't know what's on your phone

00:06:47,270 --> 00:06:53,620
all bets are off

00:06:50,350 --> 00:06:55,370
this is accomplished with DM Verity and

00:06:53,620 --> 00:06:55,970
so this has been around for a little

00:06:55,370 --> 00:06:57,590
while

00:06:55,970 --> 00:07:02,960
DM Verity sits in between the block

00:06:57,590 --> 00:07:05,960
device and the file system and it

00:07:02,960 --> 00:07:09,949
protects all file system content plus

00:07:05,960 --> 00:07:11,479
the metadata so the user generated

00:07:09,949 --> 00:07:14,479
content or the contents of the

00:07:11,479 --> 00:07:15,889
individual files or inodes you know

00:07:14,479 --> 00:07:18,169
those are protected but in addition to

00:07:15,889 --> 00:07:20,060
that everything associated with that

00:07:18,169 --> 00:07:23,900
with a file system like the block

00:07:20,060 --> 00:07:25,699
mapping the d entries and so forth all

00:07:23,900 --> 00:07:28,220
of that is also protected which is a

00:07:25,699 --> 00:07:29,840
very nice property to have and it's

00:07:28,220 --> 00:07:32,900
something in general I recommend you

00:07:29,840 --> 00:07:34,910
have if your environment allows you to

00:07:32,900 --> 00:07:37,699
do so but not every as we're going to

00:07:34,910 --> 00:07:40,729
discuss not every environment is

00:07:37,699 --> 00:07:43,699
amenable to that level of protection so

00:07:40,729 --> 00:07:45,530
if you have for example a mobile

00:07:43,699 --> 00:07:48,260
platform like Android you have an

00:07:45,530 --> 00:07:50,000
ecosystem you have partners you have

00:07:48,260 --> 00:07:54,470
different regions different devices and

00:07:50,000 --> 00:07:56,900
so forth every incremental update to the

00:07:54,470 --> 00:08:00,470
system partition requires regenerating

00:07:56,900 --> 00:08:04,940
the entire auth tree and you'd somehow

00:08:00,470 --> 00:08:07,220
have to pack that together the all of

00:08:04,940 --> 00:08:10,160
these updates with system image updates

00:08:07,220 --> 00:08:13,820
and then when you deal with this

00:08:10,160 --> 00:08:15,949
Cartesian explosion of devices and

00:08:13,820 --> 00:08:17,270
updates and versions and so forth you

00:08:15,949 --> 00:08:19,970
end up getting something that's very

00:08:17,270 --> 00:08:21,740
unwieldy it's it's intractable to be

00:08:19,970 --> 00:08:28,370
able to keep all that authenticated in

00:08:21,740 --> 00:08:29,770
the way that we'd like so we start

00:08:28,370 --> 00:08:34,219
looking at the file system as a way to

00:08:29,770 --> 00:08:35,620
to address this issue and what we talk

00:08:34,219 --> 00:08:38,990
about is partial disk authentication

00:08:35,620 --> 00:08:41,719
we're selected parts of the file system

00:08:38,990 --> 00:08:43,610
that is primarily the final contents are

00:08:41,719 --> 00:08:46,700
validated using these authenticated

00:08:43,610 --> 00:08:48,830
dictionary structures and so this

00:08:46,700 --> 00:08:50,540
facilitates you know incremental updates

00:08:48,830 --> 00:08:52,490
of arbitrary subsets of the file system

00:08:50,540 --> 00:08:54,000
and significantly reduces the complexity

00:08:52,490 --> 00:08:56,850
and deployment

00:08:54,000 --> 00:08:58,670
of course the trade-off for this is that

00:08:56,850 --> 00:09:01,709
the file system metadata is

00:08:58,670 --> 00:09:03,600
unauthenticated and so there could be

00:09:01,709 --> 00:09:05,160
opportunities for people who are more

00:09:03,600 --> 00:09:08,040
creative than I am to find ways to

00:09:05,160 --> 00:09:09,509
manipulate the block mappings or the D

00:09:08,040 --> 00:09:13,500
entries directory structures and so

00:09:09,509 --> 00:09:14,879
forth in order to trick applications to

00:09:13,500 --> 00:09:19,199
behave in ways that they weren't

00:09:14,879 --> 00:09:20,730
intended to behave I'm gonna go ahead

00:09:19,199 --> 00:09:22,079
and turn this over to Eric we'll talk

00:09:20,730 --> 00:09:29,490
about some of the more technical details

00:09:22,079 --> 00:09:34,709
of FS parity okay so so now we got two

00:09:29,490 --> 00:09:38,060
FS verdi FS f is ferdi it's basically DM

00:09:34,709 --> 00:09:41,000
Verity for individual read-only files

00:09:38,060 --> 00:09:44,699
it's implemented at the file system

00:09:41,000 --> 00:09:47,579
level specifically it's part of the file

00:09:44,699 --> 00:09:51,089
system but also most of the code is

00:09:47,579 --> 00:09:55,319
separate out into its own own own module

00:09:51,089 --> 00:09:59,699
that is shared by multiple file systems

00:09:55,319 --> 00:10:02,639
and so far we've implemented ext 4 and F

00:09:59,699 --> 00:10:06,379
2 FS support but it could be supported

00:10:02,639 --> 00:10:11,069
by other file systems - in the future

00:10:06,379 --> 00:10:15,410
and FS parity is not yet up oops oops

00:10:11,069 --> 00:10:20,579
oops upstream of that we are but we're

00:10:15,410 --> 00:10:23,100
working on Annette and I and I am and I

00:10:20,579 --> 00:10:26,250
sent out I sent out the first version of

00:10:23,100 --> 00:10:34,040
the kernel patch set a few days ago and

00:10:26,250 --> 00:10:39,180
and anyone is welcome welcome to - - we

00:10:34,040 --> 00:10:40,769
we view it so the contents of a file

00:10:39,180 --> 00:10:45,629
using FS fair deal

00:10:40,769 --> 00:10:48,720
look look look like this there's the

00:10:45,629 --> 00:10:52,379
original file contents then potentially

00:10:48,720 --> 00:10:55,829
a bit of padding then the mark Merkle

00:10:52,379 --> 00:10:58,230
tree the size of the Merkle tree depends

00:10:55,829 --> 00:11:00,930
on the settings use but with the

00:10:58,230 --> 00:11:03,300
defaults for large files it's

00:11:00,930 --> 00:11:06,430
approximately the original file size

00:11:03,300 --> 00:11:09,100
divided by 100 120 9

00:11:06,430 --> 00:11:13,810
some small files do have more overhead

00:11:09,100 --> 00:11:16,360
due to the padding then after the mark

00:11:13,810 --> 00:11:19,930
Merkle tree there is a small structure

00:11:16,360 --> 00:11:22,060
called the FS Verde descriptor which

00:11:19,930 --> 00:11:23,830
contains some additional made that they

00:11:22,060 --> 00:11:27,510
have made data fields like the hash

00:11:23,830 --> 00:11:32,500
algorithm and the black size used in the

00:11:27,510 --> 00:11:35,560
Markel tree and similar to the Verdi all

00:11:32,500 --> 00:11:37,960
the FS Verity metadata including the

00:11:35,560 --> 00:11:41,140
Merkle tree is written by user user

00:11:37,960 --> 00:11:44,320
space ahead of time and the kernel only

00:11:41,140 --> 00:11:47,800
reads that we've written a user space

00:11:44,320 --> 00:11:51,520
tool which sets up this which sets up

00:11:47,800 --> 00:11:54,430
this meta data the simplest command is

00:11:51,520 --> 00:11:58,150
just FS Verde set up and then the file

00:11:54,430 --> 00:12:00,580
path that appends the made data to the

00:11:58,150 --> 00:12:04,150
file using the default settings which

00:12:00,580 --> 00:12:07,300
are the sha-256 hash with a fork a block

00:12:04,150 --> 00:12:09,550
size and without any signature included

00:12:07,300 --> 00:12:14,640
but there are options to change these

00:12:09,550 --> 00:12:19,270
settings if you if you if you of want to

00:12:14,640 --> 00:12:23,290
also like DM verde you set a block size

00:12:19,270 --> 00:12:25,780
usually 4096 bytes and all the hashing

00:12:23,290 --> 00:12:30,850
for the Merkle tree is done over blocks

00:12:25,780 --> 00:12:33,130
of that size also the roots level of the

00:12:30,850 --> 00:12:36,520
tree which is always only one black

00:12:33,130 --> 00:12:39,850
starred first in the file and the leaf

00:12:36,520 --> 00:12:44,200
level which we call level zero is sort

00:12:39,850 --> 00:12:47,080
less in the file the leaf level is the

00:12:44,200 --> 00:12:51,970
largest level since it gives the hatches

00:12:47,080 --> 00:12:54,220
of all the data blocks the other

00:12:51,970 --> 00:12:56,260
important may the data fields stored on

00:12:54,220 --> 00:12:58,800
disk include the block size house

00:12:56,260 --> 00:13:01,810
algorithm and the original file size

00:12:58,800 --> 00:13:04,089
there's also a way to store a variable

00:13:01,810 --> 00:13:07,240
length fields those include the route

00:13:04,089 --> 00:13:10,720
house of the Merkle tree optionally a

00:13:07,240 --> 00:13:15,370
salt - salt hashes and also optionally a

00:13:10,720 --> 00:13:18,020
pikas pkcs7 formatted digital signature

00:13:15,370 --> 00:13:21,630
of the file measurement

00:13:18,020 --> 00:13:25,980
so it turns out that the Merkle tree

00:13:21,630 --> 00:13:28,550
root hash by itself is not sufficient to

00:13:25,980 --> 00:13:31,560
reliably identified file contents

00:13:28,550 --> 00:13:33,960
because of the other method made

00:13:31,560 --> 00:13:36,420
metadata fields like the hash algorithm

00:13:33,960 --> 00:13:39,240
and the block size and the original file

00:13:36,420 --> 00:13:41,670
size and because of the padding that's

00:13:39,240 --> 00:13:45,570
needed at the end of the original file

00:13:41,670 --> 00:13:48,810
contents so what we actually do as we

00:13:45,570 --> 00:13:51,750
has the the root hash together with

00:13:48,810 --> 00:13:55,920
these other metadata fields and that

00:13:51,750 --> 00:13:59,220
gives us another has a value which we

00:13:55,920 --> 00:14:01,950
called the file measurement and the file

00:13:59,220 --> 00:14:05,970
measurement is what FS ferdi actually

00:14:01,950 --> 00:14:11,100
reports as the as the as as the house of

00:14:05,970 --> 00:14:13,970
the file as I mentioned the FS Faraday

00:14:11,100 --> 00:14:17,220
metadata is written by user space

00:14:13,970 --> 00:14:20,550
afterwards there's an octal to actually

00:14:17,220 --> 00:14:24,300
enable FS parity on the file by setting

00:14:20,550 --> 00:14:26,910
the FS ferdi bit in the inode the user

00:14:24,300 --> 00:14:30,690
space command to do this is FS parity

00:14:26,910 --> 00:14:33,690
and Abel and once FS parity is enabled

00:14:30,690 --> 00:14:36,630
the file becomes read-only and the

00:14:33,690 --> 00:14:40,350
Merkle tree and other metadata becomes

00:14:36,630 --> 00:14:44,090
invisible to user space so user space

00:14:40,350 --> 00:14:48,450
will only see the original file contents

00:14:44,090 --> 00:14:51,900
also file systems are allowed to move

00:14:48,450 --> 00:14:55,650
the metadata to somewhere else if they

00:14:51,900 --> 00:15:00,630
want to like into a file stream if the

00:14:55,650 --> 00:15:05,060
file system supports that but about for

00:15:00,630 --> 00:15:09,030
exe for and F to F F F s we're just

00:15:05,060 --> 00:15:14,160
we're just keep it keeping it past the

00:15:09,030 --> 00:15:18,360
end of the file contents so to implement

00:15:14,160 --> 00:15:20,850
FS parity when reading data we hooked

00:15:18,360 --> 00:15:22,980
the file systems read pages function

00:15:20,850 --> 00:15:26,670
which is the function that reads data

00:15:22,980 --> 00:15:29,699
from a file into that files page cast if

00:15:26,670 --> 00:15:31,889
the file is an F asperity file

00:15:29,699 --> 00:15:34,859
when the read from desk completes but

00:15:31,889 --> 00:15:37,799
before unlocking the pages we have the

00:15:34,859 --> 00:15:42,809
file system submit the pages to work.you

00:15:37,799 --> 00:15:46,199
which calls into the FS Verde module to

00:15:42,809 --> 00:15:49,949
verify the hashes of the pages to do

00:15:46,199 --> 00:15:52,889
that for each for each page FS ferdi

00:15:49,949 --> 00:15:56,069
reads any needed has pages from the file

00:15:52,889 --> 00:15:58,949
and verifies hashes starting from the

00:15:56,069 --> 00:16:01,589
root node of the Merkle tree and this

00:15:58,949 --> 00:16:04,559
descending to the appropriate leaf node

00:16:01,589 --> 00:16:08,609
and finally it verifies the house of the

00:16:04,559 --> 00:16:11,819
data page and as an optimization each

00:16:08,609 --> 00:16:14,279
house page is also cast in the page cast

00:16:11,819 --> 00:16:17,910
with a bit saying whether it's been

00:16:14,279 --> 00:16:21,600
verified or not so since there since

00:16:17,910 --> 00:16:25,470
there are many hashes perhaps page for

00:16:21,600 --> 00:16:28,379
usual io patterns most data pages get

00:16:25,470 --> 00:16:32,489
verified without having to read or hash

00:16:28,379 --> 00:16:36,480
any additional has pages and we do not

00:16:32,489 --> 00:16:40,859
allow direct IO on Verdi files since

00:16:36,480 --> 00:16:43,529
that would bypass the verification but

00:16:40,859 --> 00:16:46,289
we do support encrypted files in other

00:16:43,529 --> 00:16:54,539
words files that use both FS script and

00:16:46,289 --> 00:16:58,259
FS fare D simultaneously so FS parody is

00:16:54,539 --> 00:17:01,889
essentially a way to measure or hash a

00:16:58,259 --> 00:17:04,939
file in constant time subject to the

00:17:01,889 --> 00:17:09,389
caveat that the that the verification

00:17:04,939 --> 00:17:14,389
against that has happens on demand as

00:17:09,389 --> 00:17:17,819
data is is read and applications

00:17:14,389 --> 00:17:20,339
applications will receive an IO error if

00:17:17,819 --> 00:17:24,569
they try to read from any corrupted part

00:17:20,339 --> 00:17:27,269
of the file and F is fairly file

00:17:24,569 --> 00:17:30,419
measurements are available in the kernel

00:17:27,269 --> 00:17:34,500
but are also exposed to user space via

00:17:30,419 --> 00:17:37,080
an octal and with the user space utility

00:17:34,500 --> 00:17:39,779
FS parity measure just calls that I

00:17:37,080 --> 00:17:41,790
octal and prints out what the kernel

00:17:39,779 --> 00:17:45,059
returned

00:17:41,790 --> 00:17:48,330
so there are various use cases that can

00:17:45,059 --> 00:17:52,320
be that can be supported or enabled by

00:17:48,330 --> 00:17:55,490
the FS ferdi Mecca mechanism the

00:17:52,320 --> 00:17:59,370
simplest is integrity only to detect

00:17:55,490 --> 00:18:01,620
accidental corruption and for that for

00:17:59,370 --> 00:18:05,460
that all you have to do is turn FS

00:18:01,620 --> 00:18:08,460
parity on there's also the auditing use

00:18:05,460 --> 00:18:10,380
case where you log the file measurement

00:18:08,460 --> 00:18:14,280
before doing something with the file

00:18:10,380 --> 00:18:17,730
like executing it and finally there's

00:18:14,280 --> 00:18:20,400
the authenticity or appraisal use case

00:18:17,730 --> 00:18:22,650
where you have a known good file

00:18:20,400 --> 00:18:25,559
measurement either from a digital

00:18:22,650 --> 00:18:27,330
signature or from somewhere else a new

00:18:25,559 --> 00:18:29,600
validates that the actual file

00:18:27,330 --> 00:18:32,490
measurement matches the expected one and

00:18:29,600 --> 00:18:38,160
that detects both accidental and

00:18:32,490 --> 00:18:40,320
malicious changes to file contents there

00:18:38,160 --> 00:18:43,380
there's been some confusion about the

00:18:40,320 --> 00:18:46,230
relationship between F asperity and IMA

00:18:43,380 --> 00:18:50,730
the integrity measurement architecture

00:18:46,230 --> 00:18:53,270
which already exists in the kernel the

00:18:50,730 --> 00:18:56,700
difference is that F is fair D is a

00:18:53,270 --> 00:19:01,169
lower-level thing basically a way to

00:18:56,700 --> 00:19:05,040
hash a file whereas I am a is focused

00:19:01,169 --> 00:19:07,890
more on higher-level things like what is

00:19:05,040 --> 00:19:10,770
the policy for Rhett's files are

00:19:07,890 --> 00:19:14,910
measured and what should be done with

00:19:10,770 --> 00:19:19,200
the measurements so in general FS parity

00:19:14,910 --> 00:19:22,980
is not replacing iim-a and and in fact

00:19:19,200 --> 00:19:25,620
we're planning to have IMA support

00:19:22,980 --> 00:19:30,210
getting its as measurements through FS

00:19:25,620 --> 00:19:32,850
parity on files that that use it so that

00:19:30,210 --> 00:19:36,059
should allow iim-a users to take

00:19:32,850 --> 00:19:41,419
advantage of F asperity for example for

00:19:36,059 --> 00:19:45,450
I I'm a audit or for iim-a appraisal

00:19:41,419 --> 00:19:49,909
however we have found that some users

00:19:45,450 --> 00:19:53,909
find FS parity to be useful on its own

00:19:49,909 --> 00:19:55,149
without I ma so it will also be

00:19:53,909 --> 00:19:58,539
supported

00:19:55,149 --> 00:20:01,179
to use f asperity on its own and just do

00:19:58,539 --> 00:20:02,229
things with the file measurements in

00:20:01,179 --> 00:20:06,879
userspace

00:20:02,229 --> 00:20:09,070
via the eye octal i mentioned and we're

00:20:06,879 --> 00:20:11,559
also considering supporting a mode where

00:20:09,070 --> 00:20:14,469
you can configure FS parity to enforce

00:20:11,559 --> 00:20:18,159
that all file measurements are signed by

00:20:14,469 --> 00:20:23,080
a certificate that has been loaded into

00:20:18,159 --> 00:20:24,639
the kernel that mode is maybe still up

00:20:23,080 --> 00:20:29,950
for debate since it sense it does

00:20:24,639 --> 00:20:34,989
overlap with I am a a abet but but but

00:20:29,950 --> 00:20:39,429
we do have a user who is asking our for

00:20:34,989 --> 00:20:43,149
it so in the ima use case this is a

00:20:39,429 --> 00:20:47,979
representation of what iím a does to

00:20:43,149 --> 00:20:50,739
they today essentially when iím a needs

00:20:47,979 --> 00:20:53,679
to measure a file for example because of

00:20:50,739 --> 00:20:57,070
an open or an exec it just it just

00:20:53,679 --> 00:20:59,830
houses the entire file which causes a

00:20:57,070 --> 00:21:04,330
long latency before the operation can

00:20:59,830 --> 00:21:06,669
proceed and this is what the IMA is

00:21:04,330 --> 00:21:10,210
planned to look like when it's used on

00:21:06,669 --> 00:21:14,289
FS ferdi files and configure to support

00:21:10,210 --> 00:21:17,739
them it's the same as as before except

00:21:14,289 --> 00:21:20,499
the actual hashing of the file contents

00:21:17,739 --> 00:21:23,499
is replaced with just asking the file

00:21:20,499 --> 00:21:24,909
system for the FS parity measurements

00:21:23,499 --> 00:21:27,309
which allows

00:21:24,909 --> 00:21:33,879
operations to proceed without waiting

00:21:27,309 --> 00:21:36,460
for the whole file to be hashed so if if

00:21:33,879 --> 00:21:39,789
you're on if you're interested in FS

00:21:36,460 --> 00:21:44,889
parity you can try out the kernel

00:21:39,789 --> 00:21:52,830
patches and you go to space you tell

00:21:44,889 --> 00:21:57,070
putty and help review the patches which

00:21:52,830 --> 00:22:02,289
which which as I'm engine dice turns out

00:21:57,070 --> 00:22:05,559
a few days ago and they and and and and

00:22:02,289 --> 00:22:08,260
they are and and they add support for FS

00:22:05,559 --> 00:22:13,660
parity to exe for

00:22:08,260 --> 00:22:17,140
and f2 FS and we've also been working on

00:22:13,660 --> 00:22:23,020
tests as part of the EXIF s test files

00:22:17,140 --> 00:22:26,919
file file system testing suite so this

00:22:23,020 --> 00:22:32,930
this concludes our Payson station and

00:22:26,919 --> 00:22:36,299
and thank you for your attention

00:22:32,930 --> 00:22:36,299
[Applause]

00:22:38,730 --> 00:22:47,970
questions talk about performance impacts

00:22:58,590 --> 00:23:05,470
so the performance for smaller files is

00:23:01,900 --> 00:23:08,260
going to be a little more impactful

00:23:05,470 --> 00:23:12,460
because the the amount of space that we

00:23:08,260 --> 00:23:14,080
take for the tree structure is one block

00:23:12,460 --> 00:23:16,179
which right now is fixed to the page

00:23:14,080 --> 00:23:18,880
size which from most architectures or

00:23:16,179 --> 00:23:21,270
from you know 4k and so we're going to

00:23:18,880 --> 00:23:26,650
wind up amplifying the IO as a result

00:23:21,270 --> 00:23:28,000
however hmm you also get some

00:23:26,650 --> 00:23:32,620
characteristics of storage that help

00:23:28,000 --> 00:23:35,410
mitigate that such as read ahead the

00:23:32,620 --> 00:23:37,590
person who's best equipped to give fine

00:23:35,410 --> 00:23:40,809
details about this is sitting right here

00:23:37,590 --> 00:23:44,309
Ted so and and I'm sure he'll give a

00:23:40,809 --> 00:23:44,309
little more context on that

00:23:52,800 --> 00:24:02,890
okay so in general it's going to be no

00:23:57,670 --> 00:24:05,380
worse than DM Verity for large files DM

00:24:02,890 --> 00:24:07,240
Verity it also has some significant

00:24:05,380 --> 00:24:10,030
performance impacts if you're using it

00:24:07,240 --> 00:24:13,360
on hard drives simply because you're

00:24:10,030 --> 00:24:15,310
seeking a lot to read the Merkel tree in

00:24:13,360 --> 00:24:18,340
practice the root of the Merkel tree

00:24:15,310 --> 00:24:20,260
will probably always be cached so that's

00:24:18,340 --> 00:24:22,360
not a big deal but some of the

00:24:20,260 --> 00:24:25,000
intermediate nodes and the leaf nodes

00:24:22,360 --> 00:24:27,790
don't get used as often and so they very

00:24:25,000 --> 00:24:29,950
often will be pulled into disk in

00:24:27,790 --> 00:24:33,640
practice this has not really been a

00:24:29,950 --> 00:24:36,940
problem on flash devices because on

00:24:33,640 --> 00:24:39,640
flash devices random reads are much less

00:24:36,940 --> 00:24:43,120
of an issue I think we've been a little

00:24:39,640 --> 00:24:46,120
bit more worried about the cpu impact of

00:24:43,120 --> 00:24:48,490
actually doing the hash especially on

00:24:46,120 --> 00:24:50,650
some of the lower end Android devices

00:24:48,490 --> 00:24:54,000
that just simply have you know a CPU

00:24:50,650 --> 00:24:56,950
that doesn't have a whole lot of oomph

00:24:54,000 --> 00:24:58,600
that's right yeah I said I think it's

00:24:56,950 --> 00:25:01,720
gold montt is the Intel architecture

00:24:58,600 --> 00:25:04,300
that has the shot to acceleration and so

00:25:01,720 --> 00:25:06,580
that helps since we are targeting mobile

00:25:04,300 --> 00:25:08,080
platforms we do expect that there's

00:25:06,580 --> 00:25:10,650
going to be additional power consumption

00:25:08,080 --> 00:25:13,690
as a result of the frequent hashing

00:25:10,650 --> 00:25:17,170
which you know we anticipate is going to

00:25:13,690 --> 00:25:19,480
be a benefit because these trusted apks

00:25:17,170 --> 00:25:22,150
for these privileged applications on the

00:25:19,480 --> 00:25:24,250
platform they're currently measured at

00:25:22,150 --> 00:25:27,580
the time that the apks are installed and

00:25:24,250 --> 00:25:29,800
validated but then after a device reboot

00:25:27,580 --> 00:25:30,850
and so you know they're not revalidated

00:25:29,800 --> 00:25:33,070
so anything could have happened to

00:25:30,850 --> 00:25:35,430
storage we expect that's going to be a

00:25:33,070 --> 00:25:35,430
good trade-off

00:25:48,590 --> 00:25:54,480
so you mentioned earlier that one of the

00:25:51,300 --> 00:25:56,310
problems with having with having

00:25:54,480 --> 00:25:57,840
verification be done rather than on the

00:25:56,310 --> 00:25:59,880
entire file but on individual blocks is

00:25:57,840 --> 00:26:01,530
that you can have a i/o at a basically

00:25:59,880 --> 00:26:04,590
an arbitrary point in the file and screw

00:26:01,530 --> 00:26:07,770
it up these are any mitigation without

00:26:04,590 --> 00:26:09,510
that you have what did I miss it it's it

00:26:07,770 --> 00:26:10,110
kind of feels like the nature of the

00:26:09,510 --> 00:26:12,510
beast

00:26:10,110 --> 00:26:15,930
if you're gonna delay verification to

00:26:12,510 --> 00:26:17,430
the point of access then then you know

00:26:15,930 --> 00:26:20,310
there are things there are tricks you

00:26:17,430 --> 00:26:22,710
might be able to play if you want to try

00:26:20,310 --> 00:26:26,430
to detect that there has been an offline

00:26:22,710 --> 00:26:27,660
attack against your storage it may not

00:26:26,430 --> 00:26:29,700
necessarily be something that'll be at

00:26:27,660 --> 00:26:31,980
all helpful for man in the disk or you

00:26:29,700 --> 00:26:34,590
have a compromised controller that can

00:26:31,980 --> 00:26:36,780
fake the results arbitrarily at the time

00:26:34,590 --> 00:26:39,750
of access but you know when you bring

00:26:36,780 --> 00:26:41,430
the platform back up we've imagined

00:26:39,750 --> 00:26:43,320
scenarios where perhaps you could have

00:26:41,430 --> 00:26:46,140
something in the background that

00:26:43,320 --> 00:26:47,580
gradually reads the files and does

00:26:46,140 --> 00:26:50,340
nothing with the reads except just reads

00:26:47,580 --> 00:26:51,810
the files and and but but then you're

00:26:50,340 --> 00:26:53,340
just an erase condition and you're not

00:26:51,810 --> 00:26:55,440
just like getting stronger security

00:26:53,340 --> 00:26:59,310
guarantees the other thing to note here

00:26:55,440 --> 00:27:02,160
is that for the initial use case we're

00:26:59,310 --> 00:27:04,170
using it for privileged apk files which

00:27:02,160 --> 00:27:07,050
basically means the class loader is

00:27:04,170 --> 00:27:09,750
going to be loading a class at a time

00:27:07,050 --> 00:27:11,910
and so if there if there is a failure it

00:27:09,750 --> 00:27:15,240
will probably be as you are loading a

00:27:11,910 --> 00:27:18,090
class and not at any random point in

00:27:15,240 --> 00:27:20,370
program execution and so that mitigates

00:27:18,090 --> 00:27:24,600
that somewhat for that particular use

00:27:20,370 --> 00:27:26,730
case it's very much user beware you need

00:27:24,600 --> 00:27:30,180
to be aware of the benefits and and

00:27:26,730 --> 00:27:31,590
trade-offs of using complete measurement

00:27:30,180 --> 00:27:34,110
of the file prior to the start of any

00:27:31,590 --> 00:27:40,140
access at all versus invalidation after

00:27:34,110 --> 00:27:42,560
you've begun access so with DM Verity we

00:27:40,140 --> 00:27:45,930
added forward error correction to

00:27:42,560 --> 00:27:47,730
prevent random bit flips from you know

00:27:45,930 --> 00:27:50,430
preventing your system from running are

00:27:47,730 --> 00:27:52,890
you doing the same thing for FS parity

00:27:50,430 --> 00:27:55,170
or considering something like that we've

00:27:52,890 --> 00:27:56,310
we've considered it we haven't

00:27:55,170 --> 00:27:59,580
implemented that that's again it's going

00:27:56,310 --> 00:28:00,100
to be for you know a future version I

00:27:59,580 --> 00:28:03,230
think

00:28:00,100 --> 00:28:05,120
but it definitely is something that you

00:28:03,230 --> 00:28:09,020
want to consider doing seed on so you

00:28:05,120 --> 00:28:19,370
can mitigate the incidental bit flips as

00:28:09,020 --> 00:28:22,850
opposed to the malicious bit flows so

00:28:19,370 --> 00:28:25,580
how do you exactly protect against a man

00:28:22,850 --> 00:28:27,950
on the disc as far as I understood

00:28:25,580 --> 00:28:30,080
you're still storing the Merkel tree on

00:28:27,950 --> 00:28:32,800
the disc so the man and this could

00:28:30,080 --> 00:28:35,809
modify that a wild system boot-up to

00:28:32,800 --> 00:28:38,450
correlate to the bad changes in the file

00:28:35,809 --> 00:28:40,940
are you using some kind of cryptography

00:28:38,450 --> 00:28:44,030
and making sure to store the keys to

00:28:40,940 --> 00:28:45,230
that signature off the disk or how does

00:28:44,030 --> 00:28:48,620
that work yeah that's a great question

00:28:45,230 --> 00:28:50,330
and so it has to do with you know what

00:28:48,620 --> 00:28:53,450
what is the profile for the entire

00:28:50,330 --> 00:28:57,429
platform what it was is your secure boot

00:28:53,450 --> 00:29:00,230
process and and how our utilization

00:28:57,429 --> 00:29:02,059
toriel into the proper locations right

00:29:00,230 --> 00:29:03,860
and so you have to consider that in your

00:29:02,059 --> 00:29:05,300
adversarial model and you have to make

00:29:03,860 --> 00:29:07,160
sure that you get your keys from the

00:29:05,300 --> 00:29:10,130
trusted source the secure element of the

00:29:07,160 --> 00:29:11,809
platform then what what FS Verity is

00:29:10,130 --> 00:29:12,980
actually doing is is we're creating

00:29:11,809 --> 00:29:15,710
something called the Memphis Verity

00:29:12,980 --> 00:29:17,360
measurement which isn't just you know

00:29:15,710 --> 00:29:20,390
the contents of the files themselves but

00:29:17,360 --> 00:29:23,720
it's also the metadata including

00:29:20,390 --> 00:29:26,660
including the tree and so the root of

00:29:23,720 --> 00:29:29,240
the tree together with the descriptor

00:29:26,660 --> 00:29:31,250
which is the metadata that describes the

00:29:29,240 --> 00:29:33,980
characteristics of the FS parity file

00:29:31,250 --> 00:29:35,510
all of that is captured in the root

00:29:33,980 --> 00:29:38,000
measurement which is the thing to be

00:29:35,510 --> 00:29:40,850
validated against the key that you get

00:29:38,000 --> 00:29:42,230
from the secure element yeah I mean the

00:29:40,850 --> 00:29:44,750
other thing to say here is that

00:29:42,230 --> 00:29:47,600
measurement again for this initial use

00:29:44,750 --> 00:29:50,960
case will be digitally signed and the

00:29:47,600 --> 00:29:53,270
key to verify that will be in the system

00:29:50,960 --> 00:29:55,820
image which is protected by DM Verity

00:29:53,270 --> 00:29:57,860
and the key for DM Verity is in the

00:29:55,820 --> 00:29:59,900
kernel and the kernel is protected by

00:29:57,860 --> 00:30:04,280
the trusted bootloader and so for that

00:29:59,900 --> 00:30:05,690
initial use case that's the chain yeah

00:30:04,280 --> 00:30:09,200
in the next session we have a panel on

00:30:05,690 --> 00:30:10,700
hardware root of trust type issues so

00:30:09,200 --> 00:30:12,650
one one question I had was whether you'd

00:30:10,700 --> 00:30:13,680
thought about attestation of that

00:30:12,650 --> 00:30:16,540
appraised

00:30:13,680 --> 00:30:20,740
that you perform we haven't thought

00:30:16,540 --> 00:30:23,860
about attestation in general attestation

00:30:20,740 --> 00:30:26,470
terrifies me but yes so your talk about

00:30:23,860 --> 00:30:29,140
linking with the TPM and and and doing

00:30:26,470 --> 00:30:31,290
pcr measurements based on yeah doing

00:30:29,140 --> 00:30:34,840
sending the measurement off to be

00:30:31,290 --> 00:30:37,780
validated right and binding the PCR

00:30:34,840 --> 00:30:39,100
measurements and so forth for that's not

00:30:37,780 --> 00:30:41,560
a requirement for the Android platform

00:30:39,100 --> 00:30:47,560
it's an interesting use case and well

00:30:41,560 --> 00:30:51,420
you know we'll consider that so i'm i

00:30:47,560 --> 00:30:56,400
think is how it how it is how I think we

00:30:51,420 --> 00:31:02,920
we we might be able to get support for

00:30:56,400 --> 00:31:17,770
for for that and when we add when we add

00:31:02,920 --> 00:31:24,240
I I when we add I am a is a port Mimi's

00:31:17,770 --> 00:31:24,240
nothing over there any more questions

00:31:25,530 --> 00:31:33,950
okay thanks

00:31:27,760 --> 00:31:33,950

YouTube URL: https://www.youtube.com/watch?v=Aw5h6aBhu6M


