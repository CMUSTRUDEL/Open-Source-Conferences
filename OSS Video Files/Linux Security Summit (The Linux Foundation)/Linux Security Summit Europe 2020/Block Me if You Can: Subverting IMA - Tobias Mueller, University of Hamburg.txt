Title: Block Me if You Can: Subverting IMA - Tobias Mueller, University of Hamburg
Publication date: 2020-11-17
Playlist: Linux Security Summit Europe 2020
Description: 
	Block Me if You Can: Subverting IMA - Tobias Mueller, University of Hamburg
Captions: 
	00:00:06,960 --> 00:00:10,480
hello everybody

00:00:08,559 --> 00:00:12,080
i'm tobias miller and i have the

00:00:10,480 --> 00:00:14,080
pleasure to be talking about

00:00:12,080 --> 00:00:15,519
our work that we have been done at the

00:00:14,080 --> 00:00:17,119
university of hamburg

00:00:15,519 --> 00:00:20,160
which we have titled now block me if you

00:00:17,119 --> 00:00:22,000
can subverting linux's ima

00:00:20,160 --> 00:00:23,359
so this uh this talk this presentation

00:00:22,000 --> 00:00:25,279
this work um

00:00:23,359 --> 00:00:26,720
is about undermining or trying to

00:00:25,279 --> 00:00:29,039
undermine the

00:00:26,720 --> 00:00:31,039
security guarantees that you may be

00:00:29,039 --> 00:00:31,760
looking for when deploying certain

00:00:31,039 --> 00:00:34,719
security

00:00:31,760 --> 00:00:35,280
technologies and in this case ima the

00:00:34,719 --> 00:00:37,680
integrity

00:00:35,280 --> 00:00:39,600
integrity measurement architecture and

00:00:37,680 --> 00:00:42,800
the very very brief

00:00:39,600 --> 00:00:44,879
uh gist of this work is that

00:00:42,800 --> 00:00:47,039
if you have if you happen to have a

00:00:44,879 --> 00:00:49,520
manipulated block device

00:00:47,039 --> 00:00:50,079
then well it may cheat on you and you

00:00:49,520 --> 00:00:52,480
may

00:00:50,079 --> 00:00:53,199
run a foul this this batch device and it

00:00:52,480 --> 00:00:55,360
may

00:00:53,199 --> 00:00:57,440
actually cause you to execute

00:00:55,360 --> 00:00:59,920
executables or binaries that you

00:00:57,440 --> 00:01:00,879
well didn't intend to run in first place

00:00:59,920 --> 00:01:04,640
so keep in mind

00:01:00,879 --> 00:01:06,240
this is academic work the well

00:01:04,640 --> 00:01:08,080
we have money we have worked with a

00:01:06,240 --> 00:01:09,280
manipulated block device which

00:01:08,080 --> 00:01:11,600
may or may not be common in your

00:01:09,280 --> 00:01:14,960
scenario

00:01:11,600 --> 00:01:16,640
so the the work is in the academic

00:01:14,960 --> 00:01:17,759
context which means that we find

00:01:16,640 --> 00:01:18,880
problems where other people find

00:01:17,759 --> 00:01:22,080
solutions

00:01:18,880 --> 00:01:24,320
we try to go well we we wanted to

00:01:22,080 --> 00:01:26,159
see how far we need to go in order to

00:01:24,320 --> 00:01:29,119
break things that would typically

00:01:26,159 --> 00:01:31,119
typically work even if that means that

00:01:29,119 --> 00:01:34,799
we break assumptions that you'd

00:01:31,119 --> 00:01:37,600
normally have we try to

00:01:34,799 --> 00:01:38,000
well first break things and then tend to

00:01:37,600 --> 00:01:40,079
build

00:01:38,000 --> 00:01:41,280
these things up again under maybe

00:01:40,079 --> 00:01:43,439
different assumptions

00:01:41,280 --> 00:01:44,960
and as such we thought that the ima the

00:01:43,439 --> 00:01:46,240
integrity measurement architecture was

00:01:44,960 --> 00:01:48,240
an interesting target

00:01:46,240 --> 00:01:50,320
because we've seen it in a few projects

00:01:48,240 --> 00:01:53,520
that we are involved with otherwise

00:01:50,320 --> 00:01:54,640
so we work with people in the uh in the

00:01:53,520 --> 00:01:57,200
medical sector

00:01:54,640 --> 00:01:57,759
and in the in the energy generating

00:01:57,200 --> 00:02:00,880
sector and

00:01:57,759 --> 00:02:03,920
with power plants and we've looked

00:02:00,880 --> 00:02:05,360
at how they use linux and security

00:02:03,920 --> 00:02:08,399
technology

00:02:05,360 --> 00:02:09,840
and then we've came across this we've

00:02:08,399 --> 00:02:12,319
come across this

00:02:09,840 --> 00:02:13,520
uh integrity measurement architecture

00:02:12,319 --> 00:02:14,879
and we think it's

00:02:13,520 --> 00:02:17,040
very good technology and we've

00:02:14,879 --> 00:02:21,040
investigated how to actually

00:02:17,040 --> 00:02:23,440
well subvert the guarantees that people

00:02:21,040 --> 00:02:25,120
are trying to get from from i'm a and

00:02:23,440 --> 00:02:27,840
we've written this paper

00:02:25,120 --> 00:02:30,160
where you can see the the screenshot of

00:02:27,840 --> 00:02:32,640
this paper then the bottom right

00:02:30,160 --> 00:02:35,120
and uh this work has been performed with

00:02:32,640 --> 00:02:38,400
my colleagues which you can see there

00:02:35,120 --> 00:02:42,160
and um the context

00:02:38,400 --> 00:02:45,200
very very broadly very general is in the

00:02:42,160 --> 00:02:48,080
critical infrastructure domain

00:02:45,200 --> 00:02:49,200
we focus on this area as well because

00:02:48,080 --> 00:02:50,800
it's a bit

00:02:49,200 --> 00:02:52,400
more interesting for us because it has a

00:02:50,800 --> 00:02:53,920
few challenges that other sectors do not

00:02:52,400 --> 00:02:58,480
necessarily have

00:02:53,920 --> 00:03:00,319
it's very we have the impression that

00:02:58,480 --> 00:03:01,599
this sector is written with legacy so

00:03:00,319 --> 00:03:03,760
there's loads of

00:03:01,599 --> 00:03:04,640
well old machines long-lived machines

00:03:03,760 --> 00:03:08,000
that

00:03:04,640 --> 00:03:11,440
are say difficult to update and upgrade

00:03:08,000 --> 00:03:12,879
and these well these devices that are

00:03:11,440 --> 00:03:15,760
being run

00:03:12,879 --> 00:03:17,440
they tend to have low memory low

00:03:15,760 --> 00:03:20,239
computational power

00:03:17,440 --> 00:03:22,000
and well as such they present an

00:03:20,239 --> 00:03:26,080
interesting target to us

00:03:22,000 --> 00:03:29,200
academics we have uh here a picture of

00:03:26,080 --> 00:03:32,560
a plc a programmable logic controller

00:03:29,200 --> 00:03:34,239
is a siemens device which interestingly

00:03:32,560 --> 00:03:37,200
enough has been

00:03:34,239 --> 00:03:37,680
subject to an attack or of an attack

00:03:37,200 --> 00:03:40,959
with

00:03:37,680 --> 00:03:44,159
these iranian centrifuges this was the

00:03:40,959 --> 00:03:45,360
famous stuxnet attack it was very

00:03:44,159 --> 00:03:47,280
sophisticated

00:03:45,360 --> 00:03:49,040
at the end of the day it involved

00:03:47,280 --> 00:03:55,040
manipulated hardware

00:03:49,040 --> 00:03:58,400
so somehow the victims in this case the

00:03:55,040 --> 00:04:00,480
iranian centrifuge have been

00:03:58,400 --> 00:04:01,840
they have somehow received the malicious

00:04:00,480 --> 00:04:04,879
hardware which then

00:04:01,840 --> 00:04:06,239
caused havoc and damage and the

00:04:04,879 --> 00:04:09,120
structure into these

00:04:06,239 --> 00:04:09,120
to these devices

00:04:09,840 --> 00:04:15,200
the of course stocksnet was a very

00:04:12,720 --> 00:04:18,560
sophisticated and targeted attack

00:04:15,200 --> 00:04:19,680
so the attacker in that case has had

00:04:18,560 --> 00:04:23,120
loads of

00:04:19,680 --> 00:04:24,320
well economic and uh and

00:04:23,120 --> 00:04:27,680
economic power and was very

00:04:24,320 --> 00:04:30,720
knowledgeable in what they were doing

00:04:27,680 --> 00:04:32,960
um you may not necessarily be subject to

00:04:30,720 --> 00:04:34,320
such an attack so

00:04:32,960 --> 00:04:37,360
in that case you may not necessarily

00:04:34,320 --> 00:04:40,400
need to worry about manipulated hardware

00:04:37,360 --> 00:04:43,600
infecting you in case of stuxnet however

00:04:40,400 --> 00:04:46,639
it was a simple pen drive

00:04:43,600 --> 00:04:48,560
like your your regular usb key

00:04:46,639 --> 00:04:50,639
right the pen drive that you tend to

00:04:48,560 --> 00:04:53,840
share with uh with friends

00:04:50,639 --> 00:04:55,440
such a device has been manipulated

00:04:53,840 --> 00:04:57,919
the firmware in fact on one of these

00:04:55,440 --> 00:05:01,360
devices and to then

00:04:57,919 --> 00:05:04,080
go undetected and well for stuxnet for

00:05:01,360 --> 00:05:06,560
the the warm itself to to spread

00:05:04,080 --> 00:05:07,600
around the world in fact what it

00:05:06,560 --> 00:05:10,160
actually did was

00:05:07,600 --> 00:05:10,720
it caused the centrifuge to spin faster

00:05:10,160 --> 00:05:12,960
and

00:05:10,720 --> 00:05:14,639
more slowly than they were designed to

00:05:12,960 --> 00:05:17,520
or they were

00:05:14,639 --> 00:05:19,120
used for a normal use and that caused

00:05:17,520 --> 00:05:21,440
them to wear out

00:05:19,120 --> 00:05:22,720
super fast and then well they eventually

00:05:21,440 --> 00:05:24,560
got destroyed

00:05:22,720 --> 00:05:27,199
it has been reported that about 1000 of

00:05:24,560 --> 00:05:29,680
those have been destroyed

00:05:27,199 --> 00:05:30,240
yeah i would go as far as climbing them

00:05:29,680 --> 00:05:32,960
up

00:05:30,240 --> 00:05:34,080
it's not necessarily about the damage

00:05:32,960 --> 00:05:36,800
there in this

00:05:34,080 --> 00:05:38,240
facility but there has been some

00:05:36,800 --> 00:05:40,720
collateral damage involved

00:05:38,240 --> 00:05:41,360
in running this attack and you may very

00:05:40,720 --> 00:05:44,560
well

00:05:41,360 --> 00:05:46,000
be well cautious of this type of attack

00:05:44,560 --> 00:05:47,360
regardless of whether you think that you

00:05:46,000 --> 00:05:49,680
are

00:05:47,360 --> 00:05:51,600
that that another nation state will will

00:05:49,680 --> 00:05:55,840
be your attacker

00:05:51,600 --> 00:05:57,840
so there's other attack vectors as well

00:05:55,840 --> 00:05:59,520
so it doesn't necessarily need to be

00:05:57,840 --> 00:06:00,960
some governmental agency

00:05:59,520 --> 00:06:02,880
that attacks you could very well be the

00:06:00,960 --> 00:06:04,400
manufacturer for example you could

00:06:02,880 --> 00:06:06,240
get manipulated hardware from the

00:06:04,400 --> 00:06:07,759
manufacturer like your hard disk right

00:06:06,240 --> 00:06:10,800
you could uh

00:06:07,759 --> 00:06:11,919
have bad firmware flashed on these

00:06:10,800 --> 00:06:14,639
devices

00:06:11,919 --> 00:06:15,919
before you even put your hands on them

00:06:14,639 --> 00:06:17,199
and it doesn't actually need to be the

00:06:15,919 --> 00:06:19,680
manufacturer

00:06:17,199 --> 00:06:21,840
it could also be that the device is

00:06:19,680 --> 00:06:23,840
being manipulated while it's in transit

00:06:21,840 --> 00:06:24,880
and in fact it has been documented that

00:06:23,840 --> 00:06:26,880
this happens

00:06:24,880 --> 00:06:28,400
so there is an nsa program that well

00:06:26,880 --> 00:06:30,000
does exactly that it

00:06:28,400 --> 00:06:31,680
uh captures hardware while it is in

00:06:30,000 --> 00:06:32,560
transit and then manipulates it and then

00:06:31,680 --> 00:06:35,759
forwards it to

00:06:32,560 --> 00:06:38,160
the actual um recipient and

00:06:35,759 --> 00:06:38,880
of course then you have a bug hardware

00:06:38,160 --> 00:06:41,759
and

00:06:38,880 --> 00:06:43,120
your computing well the integrity of

00:06:41,759 --> 00:06:44,639
your computing cannot be maintained

00:06:43,120 --> 00:06:45,919
anymore

00:06:44,639 --> 00:06:48,720
there's another interesting attack

00:06:45,919 --> 00:06:51,120
vector which is that

00:06:48,720 --> 00:06:52,639
an attica well if you have um

00:06:51,120 --> 00:06:53,440
second-hand hardware saying because

00:06:52,639 --> 00:06:55,120
you're in

00:06:53,440 --> 00:06:57,039
you run an economic data center and you

00:06:55,120 --> 00:06:58,400
don't actually care about the latest and

00:06:57,039 --> 00:06:59,120
greatest hardware you just want to run

00:06:58,400 --> 00:07:00,880
your

00:06:59,120 --> 00:07:02,240
in this case uh controller for your

00:07:00,880 --> 00:07:05,599
machine and you may even need

00:07:02,240 --> 00:07:08,400
a secondhand machine and

00:07:05,599 --> 00:07:09,360
and then the attacker may very well

00:07:08,400 --> 00:07:12,479
manipulate

00:07:09,360 --> 00:07:14,479
this well this first hand machine

00:07:12,479 --> 00:07:16,000
before you buy it and then when you buy

00:07:14,479 --> 00:07:18,880
it it looks all great but in fact

00:07:16,000 --> 00:07:19,360
the attacker has infected you before you

00:07:18,880 --> 00:07:21,599
even

00:07:19,360 --> 00:07:22,880
got the machine so the attacker managed

00:07:21,599 --> 00:07:23,440
to manipulate the machine while it

00:07:22,880 --> 00:07:27,680
wasn't

00:07:23,440 --> 00:07:29,680
actually worse yet so

00:07:27,680 --> 00:07:30,720
some of these attacker models they may

00:07:29,680 --> 00:07:32,400
or may not

00:07:30,720 --> 00:07:33,840
apply to you and some are more realistic

00:07:32,400 --> 00:07:37,440
than others

00:07:33,840 --> 00:07:38,880
but we have the luxury of just assuming

00:07:37,440 --> 00:07:39,360
that this sort of attacker exists and

00:07:38,880 --> 00:07:41,120
then

00:07:39,360 --> 00:07:42,479
trying to figure out how this impacts us

00:07:41,120 --> 00:07:43,440
and how we could potentially defend

00:07:42,479 --> 00:07:46,160
against such a

00:07:43,440 --> 00:07:46,160
such an attacker

00:07:47,360 --> 00:07:50,479
in the domain of critical

00:07:49,440 --> 00:07:53,520
infrastructures

00:07:50,479 --> 00:07:56,879
you may look for certain

00:07:53,520 --> 00:07:57,680
security guarantees you may want for

00:07:56,879 --> 00:08:00,800
example

00:07:57,680 --> 00:08:03,360
to run only programs that you know are

00:08:00,800 --> 00:08:04,879
good you may not want to run you know

00:08:03,360 --> 00:08:07,520
this malware that you've just downloaded

00:08:04,879 --> 00:08:07,520
by accident

00:08:07,919 --> 00:08:14,960
and you may also want to prevent malware

00:08:12,400 --> 00:08:16,400
if you ever run it or if it ever gets

00:08:14,960 --> 00:08:19,520
into your machine

00:08:16,400 --> 00:08:21,919
to persist so you would want to well

00:08:19,520 --> 00:08:24,840
revert to something like a clean state

00:08:21,919 --> 00:08:28,080
or a pristine state

00:08:24,840 --> 00:08:28,800
and well or if that's not possible then

00:08:28,080 --> 00:08:30,879
you

00:08:28,800 --> 00:08:32,240
would like to detect at least that

00:08:30,879 --> 00:08:34,719
there's something

00:08:32,240 --> 00:08:37,760
malicious going on something that's not

00:08:34,719 --> 00:08:37,760
how you thought it would be

00:08:37,839 --> 00:08:44,399
another interesting goal could be

00:08:41,760 --> 00:08:46,880
to convince someone else that you're

00:08:44,399 --> 00:08:48,880
good or clean or in a good enough state

00:08:46,880 --> 00:08:50,160
to for example be admitted to the

00:08:48,880 --> 00:08:53,120
network

00:08:50,160 --> 00:08:54,640
or that your patch state is good enough

00:08:53,120 --> 00:08:58,240
you may

00:08:54,640 --> 00:09:00,160
want to run well protocols that

00:08:58,240 --> 00:09:02,720
allow a third party to be convinced that

00:09:00,160 --> 00:09:05,279
you're good

00:09:02,720 --> 00:09:06,880
and some of these goals are realized

00:09:05,279 --> 00:09:10,320
through ima or related

00:09:06,880 --> 00:09:13,920
technologies one

00:09:10,320 --> 00:09:16,880
probably a better known technology is

00:09:13,920 --> 00:09:18,720
measured or secured those two come tend

00:09:16,880 --> 00:09:21,760
to come together

00:09:18,720 --> 00:09:25,519
and what measured boot is about is

00:09:21,760 --> 00:09:28,160
to hash each step of the boot sequence

00:09:25,519 --> 00:09:29,600
so when the machine powers up fires the

00:09:28,160 --> 00:09:30,560
firmware that's drawing on it is being

00:09:29,600 --> 00:09:32,720
hashed

00:09:30,560 --> 00:09:34,000
and then the boot loader is being hashed

00:09:32,720 --> 00:09:35,200
and then before the kernel is loaded the

00:09:34,000 --> 00:09:38,000
kernel is being hashed

00:09:35,200 --> 00:09:39,279
and all these hashes are stored in a

00:09:38,000 --> 00:09:42,320
tamper-proof

00:09:39,279 --> 00:09:44,560
well storage in some way that an

00:09:42,320 --> 00:09:47,839
attacker would have a really hard time

00:09:44,560 --> 00:09:48,399
manipulating bear in mind this is a very

00:09:47,839 --> 00:09:49,760
brief

00:09:48,399 --> 00:09:51,680
description of these technologies that

00:09:49,760 --> 00:09:53,839
involve so much more and especially the

00:09:51,680 --> 00:09:55,120
the root of trust is uh can be very

00:09:53,839 --> 00:09:56,560
interesting depending on on your

00:09:55,120 --> 00:09:59,839
scenario

00:09:56,560 --> 00:10:02,880
but the gist of the measure boot concept

00:09:59,839 --> 00:10:05,680
is to hash each and every component

00:10:02,880 --> 00:10:06,800
before it's being brought up and record

00:10:05,680 --> 00:10:08,560
that

00:10:06,800 --> 00:10:12,720
that hash this measurement as it's

00:10:08,560 --> 00:10:12,720
called in a temporal proof way

00:10:13,200 --> 00:10:17,600
you can also compare those hashes

00:10:16,079 --> 00:10:19,360
against the golden value

00:10:17,600 --> 00:10:20,959
against something that you know is good

00:10:19,360 --> 00:10:25,200
and only proceed

00:10:20,959 --> 00:10:25,200
if well if it matches well enough

00:10:25,600 --> 00:10:31,839
those concepts can be extended

00:10:28,800 --> 00:10:33,040
onto the operating system that is each

00:10:31,839 --> 00:10:35,440
and every demon that you're on

00:10:33,040 --> 00:10:37,519
each and every uh well program that you

00:10:35,440 --> 00:10:41,040
execute or data that you load

00:10:37,519 --> 00:10:43,200
you may want to know whether this

00:10:41,040 --> 00:10:44,880
these things are good before you run or

00:10:43,200 --> 00:10:46,959
load them

00:10:44,880 --> 00:10:48,640
and integrity measurement linux's

00:10:46,959 --> 00:10:51,120
integrity measurement architecture

00:10:48,640 --> 00:10:52,560
allows you to well to extend those

00:10:51,120 --> 00:10:54,959
concepts onto well

00:10:52,560 --> 00:10:55,760
the operating system so you can make

00:10:54,959 --> 00:10:59,360
linux

00:10:55,760 --> 00:11:01,920
hash each binary that you execute before

00:10:59,360 --> 00:11:03,279
running it or that you would rather that

00:11:01,920 --> 00:11:04,079
you want to execute before actually

00:11:03,279 --> 00:11:07,360
running it

00:11:04,079 --> 00:11:09,600
and ima also allows you to compare

00:11:07,360 --> 00:11:10,880
the obtained hash with your reference

00:11:09,600 --> 00:11:14,240
with the reference that you

00:11:10,880 --> 00:11:18,079
have saved somewhere

00:11:14,240 --> 00:11:20,640
this this ima is

00:11:18,079 --> 00:11:22,240
allows you then before going further

00:11:20,640 --> 00:11:24,480
even and doing what

00:11:22,240 --> 00:11:25,839
what is called remote attestation so you

00:11:24,480 --> 00:11:29,440
can run

00:11:25,839 --> 00:11:32,959
sophisticated protocols that allow

00:11:29,440 --> 00:11:33,680
a test for to verify that you are good

00:11:32,959 --> 00:11:35,200
that you are

00:11:33,680 --> 00:11:37,440
only running software that has been

00:11:35,200 --> 00:11:40,240
approved and that you are now admitted

00:11:37,440 --> 00:11:43,600
to save the network or to resources that

00:11:40,240 --> 00:11:47,279
would be denied to you otherwise

00:11:43,600 --> 00:11:50,160
it's some noteworthy that

00:11:47,279 --> 00:11:51,200
ima does not actually need a tpm like

00:11:50,160 --> 00:11:54,639
you can run

00:11:51,200 --> 00:11:55,440
the whole um ima without an actual tpm

00:11:54,639 --> 00:11:57,760
it all

00:11:55,440 --> 00:11:59,360
works locally as well but of course and

00:11:57,760 --> 00:12:02,000
you don't have the

00:11:59,360 --> 00:12:04,639
the rouge of trust you don't have this

00:12:02,000 --> 00:12:08,079
the guarantee that the values are

00:12:04,639 --> 00:12:10,160
have been stored in a tamper-proof way

00:12:08,079 --> 00:12:11,920
it comes in handy for us because we can

00:12:10,160 --> 00:12:12,480
run our experiments and virtual machines

00:12:11,920 --> 00:12:16,000
without

00:12:12,480 --> 00:12:17,200
well messing around with tpms or virtual

00:12:16,000 --> 00:12:19,120
tpms and

00:12:17,200 --> 00:12:21,040
just we're just able to use the local

00:12:19,120 --> 00:12:22,839
logs

00:12:21,040 --> 00:12:25,760
that makes things on our side a bit

00:12:22,839 --> 00:12:29,440
easier

00:12:25,760 --> 00:12:31,440
ima on a very high level

00:12:29,440 --> 00:12:32,720
um looks like this you have two modes of

00:12:31,440 --> 00:12:34,639
operation

00:12:32,720 --> 00:12:36,839
one is the appraisal mode and the other

00:12:34,639 --> 00:12:40,880
is the measurement mode

00:12:36,839 --> 00:12:44,639
and the appraisal mode is

00:12:40,880 --> 00:12:48,240
well is similar in mind

00:12:44,639 --> 00:12:51,920
to secure boot that is you have

00:12:48,240 --> 00:12:52,399
um you hash each and everything and you

00:12:51,920 --> 00:12:56,399
well

00:12:52,399 --> 00:12:59,040
compare this against

00:12:56,399 --> 00:13:01,120
known good values which can be in or

00:12:59,040 --> 00:13:03,519
which are stored in extended attributes

00:13:01,120 --> 00:13:04,639
and you cannot only have the hash values

00:13:03,519 --> 00:13:07,440
but you can also have

00:13:04,639 --> 00:13:09,040
signatures of those and then you can

00:13:07,440 --> 00:13:09,839
well use public key cryptography to

00:13:09,040 --> 00:13:11,600
verify those

00:13:09,839 --> 00:13:14,399
those hashes rather than having static

00:13:11,600 --> 00:13:14,399
symmetric values

00:13:15,440 --> 00:13:20,560
the measurement measurement mode is

00:13:18,720 --> 00:13:21,839
similar to measured boot in that each

00:13:20,560 --> 00:13:24,399
and everything is being hashed

00:13:21,839 --> 00:13:26,720
as it is and you can have a policy as to

00:13:24,399 --> 00:13:28,800
what is hashed and what is not

00:13:26,720 --> 00:13:29,839
and those measurements you can then

00:13:28,800 --> 00:13:31,920
challenge like

00:13:29,839 --> 00:13:33,200
an external part you can challenge those

00:13:31,920 --> 00:13:34,079
those measurements and then you can get

00:13:33,200 --> 00:13:35,600
a proof

00:13:34,079 --> 00:13:37,839
of the machine being in a good enough

00:13:35,600 --> 00:13:37,839
state

00:13:37,920 --> 00:13:42,720
one thing that we noticed is that the

00:13:40,079 --> 00:13:45,360
way it's currently done

00:13:42,720 --> 00:13:46,160
and i would go as far as saying that the

00:13:45,360 --> 00:13:49,279
way

00:13:46,160 --> 00:13:52,800
it's it's thought mentally uh

00:13:49,279 --> 00:13:54,800
it's there's an inherent race so

00:13:52,800 --> 00:13:57,600
if you read if you read something of the

00:13:54,800 --> 00:13:59,360
disc but you need to hash it before

00:13:57,600 --> 00:14:01,199
then there's the potential for you

00:13:59,360 --> 00:14:03,839
needing to read it twice

00:14:01,199 --> 00:14:05,440
once for the hashing and then once once

00:14:03,839 --> 00:14:08,399
again for the actual execution or

00:14:05,440 --> 00:14:08,399
reading of the file

00:14:08,720 --> 00:14:12,000
this however it tends to not happen in

00:14:10,880 --> 00:14:14,079
practice though because

00:14:12,000 --> 00:14:16,160
there is the page cache which not only

00:14:14,079 --> 00:14:17,839
accelerates things but in this case it

00:14:16,160 --> 00:14:19,839
well also it makes things a bit more

00:14:17,839 --> 00:14:21,279
secure at the end of the day

00:14:19,839 --> 00:14:22,639
um the whole thing should be in memory

00:14:21,279 --> 00:14:24,720
already from the first reading so you

00:14:22,639 --> 00:14:27,760
don't need to read a second time

00:14:24,720 --> 00:14:29,120
but there may be circumstances

00:14:27,760 --> 00:14:31,040
where it actually happens that you need

00:14:29,120 --> 00:14:33,680
to read multiple times

00:14:31,040 --> 00:14:36,160
and in this work we concentrate on

00:14:33,680 --> 00:14:38,399
investigating the circumstances and

00:14:36,160 --> 00:14:41,040
the conditions and boundaries of when

00:14:38,399 --> 00:14:44,079
this actually happens how we can force

00:14:41,040 --> 00:14:45,680
uh the second read off

00:14:44,079 --> 00:14:48,000
well the data that we want to read or

00:14:45,680 --> 00:14:51,519
execute

00:14:48,000 --> 00:14:53,360
so the well the attack if you want to

00:14:51,519 --> 00:14:56,160
call it or the problem

00:14:53,360 --> 00:14:57,040
roughly looks like this so we we tell

00:14:56,160 --> 00:14:59,839
the kernel to

00:14:57,040 --> 00:15:00,320
well open or execute a file for us and

00:14:59,839 --> 00:15:02,720
then

00:15:00,320 --> 00:15:03,440
before it does that it wants to mesh up

00:15:02,720 --> 00:15:07,279
or hash

00:15:03,440 --> 00:15:09,279
the file and then images off

00:15:07,279 --> 00:15:10,720
and reads the file as it does for

00:15:09,279 --> 00:15:12,079
hashing it

00:15:10,720 --> 00:15:14,720
and once it's finished and once

00:15:12,079 --> 00:15:17,519
everything is is good enough

00:15:14,720 --> 00:15:18,560
then the kernel comes again for actually

00:15:17,519 --> 00:15:21,920
executing

00:15:18,560 --> 00:15:27,519
or reading the file and then the

00:15:21,920 --> 00:15:29,519
read request hits the disk a second time

00:15:27,519 --> 00:15:30,639
so that's the inherent uh time of check

00:15:29,519 --> 00:15:34,000
time of use

00:15:30,639 --> 00:15:36,880
problem of this architecture um the way

00:15:34,000 --> 00:15:40,079
we see ima being built currently

00:15:36,880 --> 00:15:45,120
and we're we're now trying to

00:15:40,079 --> 00:15:45,120
exploit this this talk to problem here

00:15:45,199 --> 00:15:52,320
so how do we uh go about exploiting this

00:15:48,639 --> 00:15:54,160
problem we have one big machine

00:15:52,320 --> 00:15:55,600
which well is big enough for all

00:15:54,160 --> 00:15:57,839
purposes and

00:15:55,600 --> 00:15:58,639
it actually runs some multiple things um

00:15:57,839 --> 00:16:01,680
for us in

00:15:58,639 --> 00:16:04,480
separate virtual machines and

00:16:01,680 --> 00:16:05,680
so we created our ima virtual machine

00:16:04,480 --> 00:16:09,120
and

00:16:05,680 --> 00:16:12,000
in that machine we then ran the

00:16:09,120 --> 00:16:14,880
the ima targets the victims the guests

00:16:12,000 --> 00:16:17,199
that we tried to attack

00:16:14,880 --> 00:16:18,079
this makes things a little bit more

00:16:17,199 --> 00:16:21,279
weird than

00:16:18,079 --> 00:16:22,399
than they need to be but well

00:16:21,279 --> 00:16:23,920
we didn't really have other

00:16:22,399 --> 00:16:25,759
infrastructure back in the day when we

00:16:23,920 --> 00:16:28,720
performed these experiments

00:16:25,759 --> 00:16:30,240
i think the results are not affected by

00:16:28,720 --> 00:16:33,759
the setup though

00:16:30,240 --> 00:16:35,519
but uh so just to let you know that

00:16:33,759 --> 00:16:37,279
maybe this setup causes problems down

00:16:35,519 --> 00:16:39,839
the line with our well

00:16:37,279 --> 00:16:42,480
results but um i think it's uh it's

00:16:39,839 --> 00:16:42,480
solid enough

00:16:42,560 --> 00:16:48,480
the now having our basic infrastructure

00:16:47,040 --> 00:16:52,079
we needed this uh

00:16:48,480 --> 00:16:54,240
malicious block device we've

00:16:52,079 --> 00:16:55,680
implemented this malicious block device

00:16:54,240 --> 00:16:58,959
through qemu

00:16:55,680 --> 00:17:01,600
the hypervisor of our choice um

00:16:58,959 --> 00:17:02,639
we could have patched firmware directly

00:17:01,600 --> 00:17:04,319
i suppose

00:17:02,639 --> 00:17:05,839
i mean if we worked on bare metal

00:17:04,319 --> 00:17:08,799
machines

00:17:05,839 --> 00:17:09,520
um but well we don't have much

00:17:08,799 --> 00:17:11,919
experience

00:17:09,520 --> 00:17:13,280
patching art or writing hardest firmware

00:17:11,919 --> 00:17:14,079
and first place later on patching it

00:17:13,280 --> 00:17:16,799
onto the

00:17:14,079 --> 00:17:17,600
devices but there are people out there

00:17:16,799 --> 00:17:20,720
who do this

00:17:17,600 --> 00:17:23,280
so we know that people exist who

00:17:20,720 --> 00:17:24,799
will manage to manipulate firmware of

00:17:23,280 --> 00:17:27,439
hard disks such that they

00:17:24,799 --> 00:17:28,640
well act maliciously so we claim it's

00:17:27,439 --> 00:17:32,240
not totally

00:17:28,640 --> 00:17:34,160
uh totally off the wall to well have

00:17:32,240 --> 00:17:36,960
malicious

00:17:34,160 --> 00:17:39,679
hard disk firmware that somehow gets

00:17:36,960 --> 00:17:43,280
onto your devices

00:17:39,679 --> 00:17:46,559
our manipulated firmware

00:17:43,280 --> 00:17:47,440
has the goal of noticing the first

00:17:46,559 --> 00:17:50,880
request of

00:17:47,440 --> 00:17:55,039
our target binary saying

00:17:50,880 --> 00:17:58,160
and then notice subsequent reads

00:17:55,039 --> 00:17:59,600
assuming that then this comes from the

00:17:58,160 --> 00:18:01,840
operating system for actually executing

00:17:59,600 --> 00:18:04,880
it so the first read so the assumption

00:18:01,840 --> 00:18:07,919
of our target binary or executable

00:18:04,880 --> 00:18:10,000
is caused by ima so we assume and the

00:18:07,919 --> 00:18:12,080
second read of our target binary

00:18:10,000 --> 00:18:13,360
is then caused by the operating the

00:18:12,080 --> 00:18:14,880
underlying operating system actually

00:18:13,360 --> 00:18:18,000
wanting to execute

00:18:14,880 --> 00:18:21,840
the file we have patched to emo

00:18:18,000 --> 00:18:24,320
in as of roughly last year that was the

00:18:21,840 --> 00:18:25,039
latest release version that we obtained

00:18:24,320 --> 00:18:27,919
when we

00:18:25,039 --> 00:18:30,160
started to implement this functionality

00:18:27,919 --> 00:18:32,960
if you want to call it that

00:18:30,160 --> 00:18:33,679
and it was relatively easy to patch qm

00:18:32,960 --> 00:18:36,080
such that

00:18:33,679 --> 00:18:37,120
well it has the desired properties so

00:18:36,080 --> 00:18:40,240
there's this uh

00:18:37,120 --> 00:18:42,960
this file driver or this driver that

00:18:40,240 --> 00:18:44,640
backs block devices with a with an

00:18:42,960 --> 00:18:47,360
actual file

00:18:44,640 --> 00:18:48,480
and in that in that file there in this

00:18:47,360 --> 00:18:52,000
in this driver

00:18:48,480 --> 00:18:52,480
we can hijack the function that reads

00:18:52,000 --> 00:18:56,240
things

00:18:52,480 --> 00:18:59,679
off the of the file on the host

00:18:56,240 --> 00:19:01,360
and well the code is relatively simple

00:18:59,679 --> 00:19:02,960
so this is the the bulk of our logic

00:19:01,360 --> 00:19:05,760
there's a bit of management

00:19:02,960 --> 00:19:07,840
piece a bit of overhead well on the top

00:19:05,760 --> 00:19:09,120
and on the bottom of this block but

00:19:07,840 --> 00:19:11,280
this gives you an impression that this

00:19:09,120 --> 00:19:13,840
is um it's not

00:19:11,280 --> 00:19:15,280
like much code that we need to have

00:19:13,840 --> 00:19:17,600
there in order to have the desired

00:19:15,280 --> 00:19:20,960
properties

00:19:17,600 --> 00:19:22,559
the main things it does is it counts the

00:19:20,960 --> 00:19:25,440
number of reads

00:19:22,559 --> 00:19:27,360
so we we have our target area that we

00:19:25,440 --> 00:19:30,799
need to define up front

00:19:27,360 --> 00:19:34,000
and then we count the number of reads

00:19:30,799 --> 00:19:37,679
to that area of the well

00:19:34,000 --> 00:19:40,799
of the hard disk and if we are in that

00:19:37,679 --> 00:19:43,120
area we copy uh well

00:19:40,799 --> 00:19:45,919
oxf in this case over to the to the

00:19:43,120 --> 00:19:45,919
original value

00:19:46,000 --> 00:19:49,440
assuming that the original value is was

00:19:48,160 --> 00:19:51,840
something else

00:19:49,440 --> 00:19:53,760
this obviously works for our case where

00:19:51,840 --> 00:19:55,919
we control everything we

00:19:53,760 --> 00:19:58,080
know what we have to expect in the b9

00:19:55,919 --> 00:19:59,200
value and now we know what to expect in

00:19:58,080 --> 00:20:01,679
the malicious values

00:19:59,200 --> 00:20:02,720
so we can easily discriminate those two

00:20:01,679 --> 00:20:05,440
and

00:20:02,720 --> 00:20:06,720
it's obvious that these well these

00:20:05,440 --> 00:20:09,679
values would need to be

00:20:06,720 --> 00:20:10,320
adapted to an actual attack to well a

00:20:09,679 --> 00:20:13,520
real

00:20:10,320 --> 00:20:15,679
scenario but uh well

00:20:13,520 --> 00:20:17,440
it works well enough um for our case

00:20:15,679 --> 00:20:20,080
because with this we can measure

00:20:17,440 --> 00:20:20,960
how many bytes we could successfully

00:20:20,080 --> 00:20:24,400
manipulate

00:20:20,960 --> 00:20:27,200
to our map to our method

00:20:24,400 --> 00:20:27,840
another um challenge with our naive

00:20:27,200 --> 00:20:30,880
approach

00:20:27,840 --> 00:20:34,480
is that depending on the file system

00:20:30,880 --> 00:20:35,360
this method does not work reliably

00:20:34,480 --> 00:20:37,200
enough

00:20:35,360 --> 00:20:39,520
so if you have sophisticated file

00:20:37,200 --> 00:20:41,679
systems they tend to spread

00:20:39,520 --> 00:20:43,200
the extends all over the disk and you

00:20:41,679 --> 00:20:44,400
need to sort of track them and you need

00:20:43,200 --> 00:20:46,480
to

00:20:44,400 --> 00:20:49,280
well make sure that you don't overwrite

00:20:46,480 --> 00:20:51,679
the actual file system metadata

00:20:49,280 --> 00:20:53,520
rather than your actual well data that

00:20:51,679 --> 00:20:56,880
you want to manipulate

00:20:53,520 --> 00:20:58,880
so um yeah if you wanted to to do it

00:20:56,880 --> 00:21:00,720
correctly then you need to account for

00:20:58,880 --> 00:21:02,080
actual file systems as well

00:21:00,720 --> 00:21:04,080
that's not to say that we haven't used

00:21:02,080 --> 00:21:05,600
an actual file system but we have made

00:21:04,080 --> 00:21:09,600
it deliberately simple

00:21:05,600 --> 00:21:11,120
uh well for us to not have to spend

00:21:09,600 --> 00:21:13,760
too much time in things that are not

00:21:11,120 --> 00:21:16,640
directly in our interest

00:21:13,760 --> 00:21:18,000
so now we have a manipulated block

00:21:16,640 --> 00:21:21,440
device

00:21:18,000 --> 00:21:23,120
so let's check whether it actually works

00:21:21,440 --> 00:21:26,159
as it's as expected

00:21:23,120 --> 00:21:29,200
and turned out that it does so

00:21:26,159 --> 00:21:30,880
we could manipulate the binary or a

00:21:29,200 --> 00:21:33,360
binary that we have there on on the

00:21:30,880 --> 00:21:36,480
victim machine on the target machine

00:21:33,360 --> 00:21:38,960
and we had a very simple

00:21:36,480 --> 00:21:39,679
uh well a very simple executable that

00:21:38,960 --> 00:21:43,520
would

00:21:39,679 --> 00:21:45,440
have some tiny state embedded in it

00:21:43,520 --> 00:21:47,520
and depending on that state it would

00:21:45,440 --> 00:21:49,679
either print a green screen or

00:21:47,520 --> 00:21:51,200
if uh if the state did not match what

00:21:49,679 --> 00:21:52,159
was expected then it would print the red

00:21:51,200 --> 00:21:54,640
screen

00:21:52,159 --> 00:21:56,480
and well then in our case we made it so

00:21:54,640 --> 00:22:01,120
that you'd be greeted with the

00:21:56,480 --> 00:22:03,760
recording um well screen there

00:22:01,120 --> 00:22:05,039
we used this also to check whether ima

00:22:03,760 --> 00:22:07,679
was working as expected

00:22:05,039 --> 00:22:08,159
and it turns out that well ubuntu comes

00:22:07,679 --> 00:22:10,080
with

00:22:08,159 --> 00:22:11,600
with good defaults but you still need to

00:22:10,080 --> 00:22:12,320
make it actually work so you need to

00:22:11,600 --> 00:22:13,520
hash over

00:22:12,320 --> 00:22:15,200
like each and every file you need to

00:22:13,520 --> 00:22:16,559
store the hashes and the extended

00:22:15,200 --> 00:22:18,480
attributes and so on

00:22:16,559 --> 00:22:20,799
uh we did all that and we manipulated

00:22:18,480 --> 00:22:22,159
our binary and then we saw that ima was

00:22:20,799 --> 00:22:23,919
actually rejecting

00:22:22,159 --> 00:22:26,159
executing this binary because it was not

00:22:23,919 --> 00:22:29,440
matching what it expected

00:22:26,159 --> 00:22:31,039
um there's no screenshot now because

00:22:29,440 --> 00:22:32,480
it's actually boring it just

00:22:31,039 --> 00:22:36,240
prints something to the kernel log like

00:22:32,480 --> 00:22:41,280
ima denied access or something

00:22:36,240 --> 00:22:43,919
so we now know that our method

00:22:41,280 --> 00:22:44,640
generally works now we were interested

00:22:43,919 --> 00:22:46,480
in

00:22:44,640 --> 00:22:48,320
well how much can we actually manipulate

00:22:46,480 --> 00:22:50,320
and under what circumstances how much

00:22:48,320 --> 00:22:51,360
memory pressure do we need to have and

00:22:50,320 --> 00:22:53,840
how um

00:22:51,360 --> 00:22:56,159
how does that relate to the size of the

00:22:53,840 --> 00:23:00,080
executable that we need to have

00:22:56,159 --> 00:23:02,640
so we have a small program

00:23:00,080 --> 00:23:03,120
that tries to assess how many pages we

00:23:02,640 --> 00:23:06,559
can

00:23:03,120 --> 00:23:09,120
manipulate and

00:23:06,559 --> 00:23:10,320
basically all it does is define and

00:23:09,120 --> 00:23:12,960
define an array

00:23:10,320 --> 00:23:14,400
with all zeros and the size of this

00:23:12,960 --> 00:23:16,799
array we can uh

00:23:14,400 --> 00:23:18,400
well we can define upfront at

00:23:16,799 --> 00:23:21,440
compilation time

00:23:18,400 --> 00:23:23,520
and then we can as well decide where we

00:23:21,440 --> 00:23:27,760
want this array to go in which

00:23:23,520 --> 00:23:30,480
which section of the elf binary and

00:23:27,760 --> 00:23:31,600
this is the definition of this this

00:23:30,480 --> 00:23:34,400
array there

00:23:31,600 --> 00:23:35,679
and because of the automation that we've

00:23:34,400 --> 00:23:39,760
that we've used

00:23:35,679 --> 00:23:41,520
we were able to change this size

00:23:39,760 --> 00:23:44,000
up front before we were compiling that

00:23:41,520 --> 00:23:46,320
was that was quite good

00:23:44,000 --> 00:23:47,919
and this is the main logic of the of

00:23:46,320 --> 00:23:50,799
this test program

00:23:47,919 --> 00:23:51,840
all it does is check whether the array

00:23:50,799 --> 00:23:53,840
is still

00:23:51,840 --> 00:23:56,320
zero or the item in the array is still

00:23:53,840 --> 00:23:59,360
zero and if it's not then we

00:23:56,320 --> 00:24:00,240
have found a a manipulation and we

00:23:59,360 --> 00:24:03,600
record

00:24:00,240 --> 00:24:07,120
uh where this manipulation

00:24:03,600 --> 00:24:10,240
has been noticed and then well we

00:24:07,120 --> 00:24:13,520
go over the array

00:24:10,240 --> 00:24:15,679
and we at the end we give

00:24:13,520 --> 00:24:16,840
the total number of manipulated bytes

00:24:15,679 --> 00:24:21,039
and the relation

00:24:16,840 --> 00:24:23,600
of well in relation to the total

00:24:21,039 --> 00:24:24,480
size of the of the array so that we can

00:24:23,600 --> 00:24:27,520
have a neat

00:24:24,480 --> 00:24:30,880
value of how many percent we

00:24:27,520 --> 00:24:33,360
were able to manipulate we use

00:24:30,880 --> 00:24:35,039
system structured logging which is uh

00:24:33,360 --> 00:24:36,559
very nice because it saves us a lot of

00:24:35,039 --> 00:24:38,799
headache when parsing

00:24:36,559 --> 00:24:40,240
or now we don't have to parse uh some

00:24:38,799 --> 00:24:40,720
output which could be interleaved and

00:24:40,240 --> 00:24:44,400
everything

00:24:40,720 --> 00:24:47,200
this um so this is uh is very good

00:24:44,400 --> 00:24:48,799
and then we have some so management

00:24:47,200 --> 00:24:50,240
around still so while this is the main

00:24:48,799 --> 00:24:51,840
logic of the program there's

00:24:50,240 --> 00:24:53,360
a little bit of logic still to create

00:24:51,840 --> 00:24:56,960
the memory pressure

00:24:53,360 --> 00:24:58,720
and um yeah so

00:24:56,960 --> 00:25:00,640
this is not the whole binary but you can

00:24:58,720 --> 00:25:02,880
all find it on github i'll present the

00:25:00,640 --> 00:25:05,520
link later

00:25:02,880 --> 00:25:06,080
so as for the memory pressure we have

00:25:05,520 --> 00:25:08,640
used

00:25:06,080 --> 00:25:10,720
stressng g which is a very nice tool

00:25:08,640 --> 00:25:13,440
with many many options

00:25:10,720 --> 00:25:14,720
and the test program that we've seen

00:25:13,440 --> 00:25:16,159
just before

00:25:14,720 --> 00:25:18,000
it waits for stress energy to be

00:25:16,159 --> 00:25:21,120
finished and

00:25:18,000 --> 00:25:25,039
then in our experiments we've run

00:25:21,120 --> 00:25:26,080
uh one instance of a test for 50 times

00:25:25,039 --> 00:25:28,159
just to get some

00:25:26,080 --> 00:25:29,600
some stability in the results and to see

00:25:28,159 --> 00:25:33,200
where things may be

00:25:29,600 --> 00:25:33,200
uh less stable than we expected

00:25:33,279 --> 00:25:40,080
and um with this setup

00:25:37,360 --> 00:25:41,679
we were we had all the necessary bits

00:25:40,080 --> 00:25:44,400
and pieces

00:25:41,679 --> 00:25:44,880
we needed to glue it all together we

00:25:44,400 --> 00:25:48,400
have

00:25:44,880 --> 00:25:50,960
a medium sized batch script that

00:25:48,400 --> 00:25:51,679
well creates these virtual machines

00:25:50,960 --> 00:25:54,080
automatically

00:25:51,679 --> 00:25:56,000
copies all the the required scripts in

00:25:54,080 --> 00:26:00,000
all the service definitions and

00:25:56,000 --> 00:26:02,880
sets up the ima and all this and we

00:26:00,000 --> 00:26:04,720
have tests for remember we have tests

00:26:02,880 --> 00:26:08,159
for two dimensions

00:26:04,720 --> 00:26:09,039
the one is the size of the executable

00:26:08,159 --> 00:26:12,320
that we

00:26:09,039 --> 00:26:14,159
well are trying to attack so that we can

00:26:12,320 --> 00:26:16,080
change with uh

00:26:14,159 --> 00:26:18,240
with the size of this array that we have

00:26:16,080 --> 00:26:21,120
there the other dimension

00:26:18,240 --> 00:26:22,640
is the the pressure that we expert on

00:26:21,120 --> 00:26:24,880
the machine the memory pressure

00:26:22,640 --> 00:26:26,320
so with the with the stress energy we

00:26:24,880 --> 00:26:30,080
can fill in

00:26:26,320 --> 00:26:31,039
uh well the number of uh of megabytes in

00:26:30,080 --> 00:26:34,080
this case

00:26:31,039 --> 00:26:37,200
that it will allocate and

00:26:34,080 --> 00:26:41,039
will stress the machine with and we run

00:26:37,200 --> 00:26:44,880
our experiments in these two dimensions

00:26:41,039 --> 00:26:45,760
as for our automation we have made great

00:26:44,880 --> 00:26:47,600
use of

00:26:45,760 --> 00:26:48,960
um of great libraries that are out there

00:26:47,600 --> 00:26:51,360
like guest fish

00:26:48,960 --> 00:26:52,720
which helps us tremendously in getting

00:26:51,360 --> 00:26:55,200
files in and out of the machine

00:26:52,720 --> 00:26:55,919
for not only our services but also then

00:26:55,200 --> 00:26:57,279
the logs

00:26:55,919 --> 00:26:59,200
out of the machine so that we can

00:26:57,279 --> 00:27:02,799
analyze them we

00:26:59,200 --> 00:27:05,840
uh use the the vert edit tool which

00:27:02,799 --> 00:27:07,600
helps with greatly with manipulating

00:27:05,840 --> 00:27:09,039
configuration files in place rather than

00:27:07,600 --> 00:27:11,520
just copying them over

00:27:09,039 --> 00:27:12,720
which well in our case is a bit more

00:27:11,520 --> 00:27:16,720
handy because then we could

00:27:12,720 --> 00:27:20,240
carry the state over and over and

00:27:16,720 --> 00:27:20,720
one thing we we were a bit uh fighting

00:27:20,240 --> 00:27:24,720
with

00:27:20,720 --> 00:27:25,840
is the the offsets of the data that we

00:27:24,720 --> 00:27:27,679
are attacking

00:27:25,840 --> 00:27:29,840
so remember we have this executable and

00:27:27,679 --> 00:27:32,720
we have this array in this executable

00:27:29,840 --> 00:27:34,320
and the relatively simple task for the

00:27:32,720 --> 00:27:36,880
task that should be relatively simple of

00:27:34,320 --> 00:27:40,000
finding the actual offset of this

00:27:36,880 --> 00:27:41,600
array in the in the executable turned

00:27:40,000 --> 00:27:43,919
out to involve

00:27:41,600 --> 00:27:44,880
more tools than i expected and more grab

00:27:43,919 --> 00:27:47,919
and awk

00:27:44,880 --> 00:27:50,559
than i thought was necessary to

00:27:47,919 --> 00:27:52,159
to finding this relatively simple

00:27:50,559 --> 00:27:54,960
address of the

00:27:52,159 --> 00:27:56,320
of this array you can have a look at all

00:27:54,960 --> 00:27:59,360
this um

00:27:56,320 --> 00:27:59,679
at this github link it's not pretty but

00:27:59,360 --> 00:28:03,360
it

00:27:59,679 --> 00:28:04,720
works well enough it produces these

00:28:03,360 --> 00:28:07,039
virtual machines it runs them it

00:28:04,720 --> 00:28:09,600
captures the output and the logs and it

00:28:07,039 --> 00:28:11,200
makes sure that all the uh all the

00:28:09,600 --> 00:28:12,640
values are filled in for the various

00:28:11,200 --> 00:28:16,720
dimensions and it

00:28:12,640 --> 00:28:19,520
then produces a nice text

00:28:16,720 --> 00:28:19,840
representation of the results so this is

00:28:19,520 --> 00:28:22,399
all

00:28:19,840 --> 00:28:24,000
should be all fairly reproducible and

00:28:22,399 --> 00:28:26,960
fairly extensible for

00:28:24,000 --> 00:28:30,720
well if you think you could run these

00:28:26,960 --> 00:28:33,760
experiments in another or better way

00:28:30,720 --> 00:28:36,799
the results are

00:28:33,760 --> 00:28:37,279
or one slice of the results say is this

00:28:36,799 --> 00:28:40,640
so

00:28:37,279 --> 00:28:43,760
here we have a a fixed size

00:28:40,640 --> 00:28:46,640
binary and

00:28:43,760 --> 00:28:48,799
the sorry we have a fixed a memory

00:28:46,640 --> 00:28:51,039
pressure 128 megabytes is uh

00:28:48,799 --> 00:28:53,120
here what we expect on the machine and

00:28:51,039 --> 00:28:55,360
we vary the the size of the binary that

00:28:53,120 --> 00:28:58,880
we want to run the executable

00:28:55,360 --> 00:29:02,240
and as as you could expect

00:28:58,880 --> 00:29:05,520
if the executable is fairly

00:29:02,240 --> 00:29:08,880
small and up to 64 megabytes

00:29:05,520 --> 00:29:12,240
then we see little to no

00:29:08,880 --> 00:29:13,919
uh effect of our manipulation everything

00:29:12,240 --> 00:29:17,360
will be in the page cache

00:29:13,919 --> 00:29:19,279
only occasionally a few pages will be

00:29:17,360 --> 00:29:20,559
evicted due to the pressure exerted on

00:29:19,279 --> 00:29:23,679
the machine

00:29:20,559 --> 00:29:26,559
but up until that

00:29:23,679 --> 00:29:27,600
like 64 mark 64 megabytes mark things

00:29:26,559 --> 00:29:29,279
are

00:29:27,600 --> 00:29:31,679
normal say no manipulation that we could

00:29:29,279 --> 00:29:31,679
observe

00:29:31,840 --> 00:29:35,760
but if we increase the size of the

00:29:34,720 --> 00:29:38,640
executable

00:29:35,760 --> 00:29:39,360
then 128 megabytes and then of course

00:29:38,640 --> 00:29:42,399
finally

00:29:39,360 --> 00:29:44,480
256 and bigger then we could manipulate

00:29:42,399 --> 00:29:48,080
more and more pages of this uh

00:29:44,480 --> 00:29:51,120
of this executable i remember we had uh

00:29:48,080 --> 00:29:54,320
512 megabytes of ram so this is not

00:29:51,120 --> 00:29:56,399
like a massive uh it's not massive

00:29:54,320 --> 00:29:59,279
amounts of memory

00:29:56,399 --> 00:30:00,000
um i bet that the results will be

00:29:59,279 --> 00:30:02,320
similar

00:30:00,000 --> 00:30:03,279
if taken into relation if we had two

00:30:02,320 --> 00:30:06,159
gigabytes of ram

00:30:03,279 --> 00:30:07,200
of memory then i guess we'd have to

00:30:06,159 --> 00:30:10,799
increase the

00:30:07,200 --> 00:30:11,279
sizes of the executables accordingly and

00:30:10,799 --> 00:30:14,640
i

00:30:11,279 --> 00:30:16,559
i guess we'd have similar results

00:30:14,640 --> 00:30:18,720
this is to accommodate our critical

00:30:16,559 --> 00:30:19,279
infrastructure domain where we know that

00:30:18,720 --> 00:30:22,159
the

00:30:19,279 --> 00:30:24,559
devices that are in use have well little

00:30:22,159 --> 00:30:24,559
memory

00:30:25,120 --> 00:30:31,760
so this is um this graph here shows uh

00:30:28,720 --> 00:30:33,440
the fixed memory pressure of 128

00:30:31,760 --> 00:30:37,120
megabytes

00:30:33,440 --> 00:30:41,120
the this graph shows a fixed sized

00:30:37,120 --> 00:30:44,799
executable so 64 megabytes in this case

00:30:41,120 --> 00:30:47,919
and we vary the the pressure

00:30:44,799 --> 00:30:48,960
that we extract on the machine you note

00:30:47,919 --> 00:30:52,000
that we have

00:30:48,960 --> 00:30:53,120
two lines one is for manipulations in

00:30:52,000 --> 00:30:55,440
the text section and the other is from

00:30:53,120 --> 00:30:59,279
many places in the data section

00:30:55,440 --> 00:31:02,399
it's fairly similar um

00:30:59,279 --> 00:31:05,360
one thing to note is that

00:31:02,399 --> 00:31:07,279
linux doesn't execute uh elf binaries

00:31:05,360 --> 00:31:09,440
when the data section is too big

00:31:07,279 --> 00:31:10,399
we found that surprising i guess there

00:31:09,440 --> 00:31:13,039
is a

00:31:10,399 --> 00:31:14,480
reason to that that we still need to

00:31:13,039 --> 00:31:15,919
learn and find out why that is

00:31:14,480 --> 00:31:18,080
it works with the text section no it's

00:31:15,919 --> 00:31:23,039
no problem but the data section

00:31:18,080 --> 00:31:23,039
it doesn't doesn't run the executable

00:31:23,120 --> 00:31:26,559
all the results can be seen in this

00:31:25,360 --> 00:31:29,519
table is a bit big it's

00:31:26,559 --> 00:31:32,880
um it's not very uh digitized the

00:31:29,519 --> 00:31:36,159
details don't really matter here

00:31:32,880 --> 00:31:38,960
what you can see though is again as you

00:31:36,159 --> 00:31:42,000
might expect the top left of the half

00:31:38,960 --> 00:31:42,799
is all fairly zero like there's a fairly

00:31:42,000 --> 00:31:45,120
little

00:31:42,799 --> 00:31:47,120
manipulation going on of course if the

00:31:45,120 --> 00:31:47,519
machine has 512 megabytes of ram and i

00:31:47,120 --> 00:31:50,000
have a

00:31:47,519 --> 00:31:50,640
an executable of 32 megabytes in this

00:31:50,000 --> 00:31:52,320
case

00:31:50,640 --> 00:31:54,240
and i only exert a pressure memory

00:31:52,320 --> 00:31:57,039
pressure of one megabyte then

00:31:54,240 --> 00:31:58,159
we'd be surprised to find uh parts of

00:31:57,039 --> 00:32:02,480
our executable

00:31:58,159 --> 00:32:02,480
uh to be evicted from the page cache

00:32:02,720 --> 00:32:06,080
however um or not however but also as

00:32:05,519 --> 00:32:09,519
expected

00:32:06,080 --> 00:32:12,320
in the bottom right where we have huge

00:32:09,519 --> 00:32:13,679
executables and large memory pressure

00:32:12,320 --> 00:32:17,840
high memory pressure

00:32:13,679 --> 00:32:22,399
then nearly all the all the contents

00:32:17,840 --> 00:32:25,760
is gone from the page cache so

00:32:22,399 --> 00:32:27,120
the interesting band i guess is there in

00:32:25,760 --> 00:32:29,360
the in the middle

00:32:27,120 --> 00:32:30,559
uh there's sort of a sweet spot when the

00:32:29,360 --> 00:32:32,720
machines begin

00:32:30,559 --> 00:32:33,679
begin to thrash and to or rather to

00:32:32,720 --> 00:32:35,760
evict

00:32:33,679 --> 00:32:37,840
things from the cache and where it then

00:32:35,760 --> 00:32:41,120
needs to hit the disk a second time for

00:32:37,840 --> 00:32:41,120
for reading the contents back in

00:32:41,679 --> 00:32:47,120
another uh

00:32:44,880 --> 00:32:48,240
thing that's um that may be interesting

00:32:47,120 --> 00:32:51,440
is that

00:32:48,240 --> 00:32:56,080
some results tend to be quite unstable

00:32:51,440 --> 00:32:57,279
so we have standard deviation of

00:32:56,080 --> 00:32:59,279
we have a relatively high standard

00:32:57,279 --> 00:33:02,320
deviation for some values

00:32:59,279 --> 00:33:03,200
especially there in the 256 uh megabytes

00:33:02,320 --> 00:33:07,200
executable and

00:33:03,200 --> 00:33:11,039
uh there the 32 megabytes pressure

00:33:07,200 --> 00:33:12,720
there we see a relatively high

00:33:11,039 --> 00:33:14,159
standard deviation of our values of the

00:33:12,720 --> 00:33:16,559
50 measurements that we have

00:33:14,159 --> 00:33:18,240
uh taken for this for this particular

00:33:16,559 --> 00:33:20,880
run

00:33:18,240 --> 00:33:22,480
um we could run it another 100 times

00:33:20,880 --> 00:33:25,039
maybe it makes it better

00:33:22,480 --> 00:33:26,399
but uh it's like this one stands out

00:33:25,039 --> 00:33:28,080
because it's uh

00:33:26,399 --> 00:33:30,240
yeah we don't know maybe we just had a

00:33:28,080 --> 00:33:32,640
bad uh bad timing there

00:33:30,240 --> 00:33:34,159
uh when running the experiment another

00:33:32,640 --> 00:33:37,519
another uh

00:33:34,159 --> 00:33:40,080
unstable result is there in the

00:33:37,519 --> 00:33:41,039
in the top with the 32 megabytes

00:33:40,080 --> 00:33:45,919
executable

00:33:41,039 --> 00:33:48,960
and uh 192 megabytes of memory pressure

00:33:45,919 --> 00:33:49,519
and also very unstable result maybe this

00:33:48,960 --> 00:33:52,080
is uh

00:33:49,519 --> 00:33:53,440
this is where the sweet spot tends to

00:33:52,080 --> 00:33:56,640
begin and maybe that's

00:33:53,440 --> 00:33:58,240
that's the magic value that well somehow

00:33:56,640 --> 00:34:00,159
creates more uncertainty in the results

00:33:58,240 --> 00:34:02,640
than what we

00:34:00,159 --> 00:34:03,440
thought it would be another interesting

00:34:02,640 --> 00:34:05,679
thing is that

00:34:03,440 --> 00:34:07,760
we noticed that the farce tartine and

00:34:05,679 --> 00:34:09,679
the last page were always retained in

00:34:07,760 --> 00:34:13,040
the cache so you remember we

00:34:09,679 --> 00:34:14,560
had recorded when we could observe the

00:34:13,040 --> 00:34:17,520
manipulation

00:34:14,560 --> 00:34:20,079
and which byte in the array and from

00:34:17,520 --> 00:34:21,760
that we couldn't fire that uh

00:34:20,079 --> 00:34:23,119
as we say the first starting pages we

00:34:21,760 --> 00:34:25,359
have uh in

00:34:23,119 --> 00:34:26,960
all the experiments we've always seen uh

00:34:25,359 --> 00:34:31,359
being present

00:34:26,960 --> 00:34:31,359
and so as well as the last page

00:34:31,760 --> 00:34:36,960
we don't know why that is uh maybe

00:34:34,159 --> 00:34:36,960
someone has a clue

00:34:37,440 --> 00:34:41,599
so that's um that describes the the

00:34:40,440 --> 00:34:45,040
circumstances

00:34:41,599 --> 00:34:46,079
and conditions under which this inherent

00:34:45,040 --> 00:34:49,119
tactile race

00:34:46,079 --> 00:34:50,960
can be exploited to have a

00:34:49,119 --> 00:34:52,159
bad effect on the on the software that

00:34:50,960 --> 00:34:54,320
you run on your

00:34:52,159 --> 00:34:57,280
on your system that you try to protect

00:34:54,320 --> 00:35:00,880
with this with this technology

00:34:57,280 --> 00:35:03,680
so you may think um how can we

00:35:00,880 --> 00:35:04,960
well make the effects less severe how

00:35:03,680 --> 00:35:08,720
can we mitigate

00:35:04,960 --> 00:35:11,920
this problem and we think that

00:35:08,720 --> 00:35:14,960
you'd somehow have to prevent ima

00:35:11,920 --> 00:35:17,599
hitting the disc additionally like you

00:35:14,960 --> 00:35:18,800
somehow need to make sure that this

00:35:17,599 --> 00:35:22,320
hashing of the

00:35:18,800 --> 00:35:23,839
of the file contents does not cause an

00:35:22,320 --> 00:35:25,680
additional read because

00:35:23,839 --> 00:35:27,119
once you hit the disk a second time it

00:35:25,680 --> 00:35:29,680
can discriminate

00:35:27,119 --> 00:35:31,760
the second read and it can then cheat on

00:35:29,680 --> 00:35:34,800
you

00:35:31,760 --> 00:35:36,560
you could probably mitigate that in turn

00:35:34,800 --> 00:35:38,320
by doing random reads

00:35:36,560 --> 00:35:39,760
like if you're idle and then you just

00:35:38,320 --> 00:35:43,119
request random blocks

00:35:39,760 --> 00:35:44,960
hoping to sort of trip up the

00:35:43,119 --> 00:35:47,280
modified firmware on the on the hard

00:35:44,960 --> 00:35:47,280
disk

00:35:47,440 --> 00:35:53,839
another approach would be to

00:35:50,720 --> 00:35:55,119
go more into into the direction that dm

00:35:53,839 --> 00:35:58,720
or fs verity

00:35:55,119 --> 00:35:59,599
are doing so as far as we could see they

00:35:58,720 --> 00:36:01,839
they verify

00:35:59,599 --> 00:36:03,520
each chunks rather than each file so

00:36:01,839 --> 00:36:06,640
this is inherently more

00:36:03,520 --> 00:36:09,680
uh more granular is more fine-grained in

00:36:06,640 --> 00:36:12,560
what it does we were told that

00:36:09,680 --> 00:36:13,280
there have been patches on the way which

00:36:12,560 --> 00:36:16,480
sort of

00:36:13,280 --> 00:36:17,680
adapts this this style of checking for

00:36:16,480 --> 00:36:19,760
when pages are being

00:36:17,680 --> 00:36:20,960
or when the contents are being paged

00:36:19,760 --> 00:36:22,640
back in

00:36:20,960 --> 00:36:24,640
we haven't followed what exactly has

00:36:22,640 --> 00:36:27,359
happened there so it may maybe that

00:36:24,640 --> 00:36:30,880
i may by now has a more granular

00:36:27,359 --> 00:36:30,880
approach to verifying things

00:36:31,200 --> 00:36:38,560
we'd also think that somehow

00:36:35,200 --> 00:36:40,720
making sure that you also include the

00:36:38,560 --> 00:36:42,240
the actual disk or disks that you're

00:36:40,720 --> 00:36:44,079
running or they're filming rather into

00:36:42,240 --> 00:36:45,440
the measurement process

00:36:44,079 --> 00:36:47,200
similar to what you do with the with the

00:36:45,440 --> 00:36:49,200
machine already right like your

00:36:47,200 --> 00:36:50,880
motherboard uh is being hashed as well

00:36:49,200 --> 00:36:54,000
like the firmware of that

00:36:50,880 --> 00:36:57,359
but it's um it's a bit unclear how

00:36:54,000 --> 00:36:58,640
you would ensure that the the hard drive

00:36:57,359 --> 00:37:01,280
that you're having is actually running

00:36:58,640 --> 00:37:04,240
the firmware that it reports

00:37:01,280 --> 00:37:05,599
at least when you have general purpose

00:37:04,240 --> 00:37:09,680
computers as we

00:37:05,599 --> 00:37:11,839
tend to have still with specialized

00:37:09,680 --> 00:37:13,920
machines it may very well be possible

00:37:11,839 --> 00:37:15,520
but at least

00:37:13,920 --> 00:37:17,200
those that are being sold to consumers

00:37:15,520 --> 00:37:19,839
these days we

00:37:17,200 --> 00:37:20,640
don't see how this could work maybe

00:37:19,839 --> 00:37:24,560
possible

00:37:20,640 --> 00:37:24,560
i'm clear to us how you do it though

00:37:24,720 --> 00:37:28,720
so the things that we've discussed so

00:37:26,320 --> 00:37:31,760
far are

00:37:28,720 --> 00:37:33,520
well they have their or they have their

00:37:31,760 --> 00:37:36,720
problems in the sense that

00:37:33,520 --> 00:37:39,760
uh the hardware attacks

00:37:36,720 --> 00:37:40,720
by themselves are quite out of scope of

00:37:39,760 --> 00:37:44,320
ima

00:37:40,720 --> 00:37:46,560
so we are exploiting something

00:37:44,320 --> 00:37:49,200
that i may does not actually try to

00:37:46,560 --> 00:37:49,200
protect against

00:37:49,359 --> 00:37:53,680
yet we argue that this type of attack

00:37:51,440 --> 00:37:55,920
exists and that the attackers

00:37:53,680 --> 00:37:57,040
exist that could execute or launch such

00:37:55,920 --> 00:38:00,800
an attack

00:37:57,040 --> 00:38:02,839
um but still it's it's a bit unfair of

00:38:00,800 --> 00:38:05,760
us to sort of uh

00:38:02,839 --> 00:38:07,200
well exploit this while

00:38:05,760 --> 00:38:10,000
this is not something that has been

00:38:07,200 --> 00:38:12,079
actually tried to defend against

00:38:10,000 --> 00:38:13,760
we also note that the binary sizes we

00:38:12,079 --> 00:38:17,440
have investigated like

00:38:13,760 --> 00:38:19,680
300 whatever megabytes is not

00:38:17,440 --> 00:38:20,640
really something that you'd have

00:38:19,680 --> 00:38:23,680
although

00:38:20,640 --> 00:38:24,560
we also note that it's increasingly more

00:38:23,680 --> 00:38:27,040
common to have

00:38:24,560 --> 00:38:28,560
large binaries so i've just checked the

00:38:27,040 --> 00:38:29,920
docker demon has something around 100

00:38:28,560 --> 00:38:32,960
megabytes

00:38:29,920 --> 00:38:34,320
and then i checked i have some some rust

00:38:32,960 --> 00:38:36,160
binaries locally

00:38:34,320 --> 00:38:38,960
which are easily in the range of 200

00:38:36,160 --> 00:38:42,400
megabytes so i guess it's not

00:38:38,960 --> 00:38:44,240
uh at least for now uh

00:38:42,400 --> 00:38:46,880
it's not unreasonable to to think of

00:38:44,240 --> 00:38:49,920
relatively large binaries

00:38:46,880 --> 00:38:53,359
although your typical

00:38:49,920 --> 00:38:55,520
debian package is not that big

00:38:53,359 --> 00:38:57,040
we also note that in order to execute

00:38:55,520 --> 00:38:59,280
such an attack

00:38:57,040 --> 00:39:00,640
you need to have a very detailed

00:38:59,280 --> 00:39:01,760
knowledge you need to be a very strong

00:39:00,640 --> 00:39:03,920
attacker to

00:39:01,760 --> 00:39:05,760
know like the environment that you're

00:39:03,920 --> 00:39:08,400
targeting and

00:39:05,760 --> 00:39:09,520
where the the binaries like the data

00:39:08,400 --> 00:39:12,800
that you're attacking

00:39:09,520 --> 00:39:14,000
is on the on the actual uh hard disk in

00:39:12,800 --> 00:39:17,119
that case

00:39:14,000 --> 00:39:22,079
that requires a lot of uh insight and

00:39:17,119 --> 00:39:24,960
motivation to well to launch this attack

00:39:22,079 --> 00:39:26,240
but depending on who you are you may

00:39:24,960 --> 00:39:30,480
very well be

00:39:26,240 --> 00:39:30,480
be a target of such an attacker

00:39:30,640 --> 00:39:33,760
what we'd also like to do what we

00:39:32,000 --> 00:39:36,560
haven't done yet though is

00:39:33,760 --> 00:39:38,400
to check other operating systems so we

00:39:36,560 --> 00:39:39,440
were told that windows has a very

00:39:38,400 --> 00:39:41,680
similar thing

00:39:39,440 --> 00:39:43,119
but uh none of us is a windows parson so

00:39:41,680 --> 00:39:45,119
we actually don't know

00:39:43,119 --> 00:39:46,720
and it would cost us a lot of time to

00:39:45,119 --> 00:39:50,320
actually check

00:39:46,720 --> 00:39:52,720
how to well do this ima style of uh

00:39:50,320 --> 00:39:53,760
integrity checking verification in

00:39:52,720 --> 00:39:55,680
windows but

00:39:53,760 --> 00:39:59,280
we were told it's possible so maybe one

00:39:55,680 --> 00:39:59,280
day we get around to actually do it

00:39:59,440 --> 00:40:06,000
so to wrap up

00:40:02,560 --> 00:40:08,880
we note that the attacks are possible

00:40:06,000 --> 00:40:11,920
indeed but probably a bit unrealistic

00:40:08,880 --> 00:40:14,160
depending on who you are

00:40:11,920 --> 00:40:16,400
with enough pressure on your system with

00:40:14,160 --> 00:40:19,680
enough memory pressure

00:40:16,400 --> 00:40:20,079
your linux ima system goes to hit the

00:40:19,680 --> 00:40:23,760
disk

00:40:20,079 --> 00:40:26,000
multiple times at least twice and this

00:40:23,760 --> 00:40:27,440
in time can be used by by a malicious

00:40:26,000 --> 00:40:31,359
block device to serve you

00:40:27,440 --> 00:40:31,359
malicious content on subsequent reads

00:40:31,520 --> 00:40:35,680
in some cases even little pressure is

00:40:33,280 --> 00:40:38,800
enough as we have seen so there's um

00:40:35,680 --> 00:40:41,040
depending on the sweet spot range there

00:40:38,800 --> 00:40:44,560
may be circumstances where you'd get

00:40:41,040 --> 00:40:45,520
surprised that your your executable has

00:40:44,560 --> 00:40:49,280
been evicted from the

00:40:45,520 --> 00:40:51,520
from the cache but again

00:40:49,280 --> 00:40:53,280
the attacker needs to be very skilled

00:40:51,520 --> 00:40:56,400
and very knowledgeable in

00:40:53,280 --> 00:40:58,720
in your scenario and

00:40:56,400 --> 00:40:59,920
it's more likely that you're not subject

00:40:58,720 --> 00:41:03,920
to such an attack than

00:40:59,920 --> 00:41:03,920
it is that you are indeed being affected

00:41:04,560 --> 00:41:09,680
the uh this work has uh resulted in a an

00:41:08,800 --> 00:41:11,520
academic paper

00:41:09,680 --> 00:41:13,280
presented at this year's uh artist

00:41:11,520 --> 00:41:14,640
conferences the conference for

00:41:13,280 --> 00:41:17,359
availability reliable

00:41:14,640 --> 00:41:19,119
lead reliability and security and you

00:41:17,359 --> 00:41:21,359
can find the link there

00:41:19,119 --> 00:41:22,800
and all the the resources that we've

00:41:21,359 --> 00:41:25,520
used are there on this

00:41:22,800 --> 00:41:27,760
on this in this github repository the

00:41:25,520 --> 00:41:30,800
best scripts for creating the

00:41:27,760 --> 00:41:33,920
uh the virtual machines the the way

00:41:30,800 --> 00:41:34,319
for uh extracting the results and uh

00:41:33,920 --> 00:41:37,599
well

00:41:34,319 --> 00:41:39,520
um capturing all the the

00:41:37,599 --> 00:41:41,359
required details you find it all there

00:41:39,520 --> 00:41:42,000
it should be reproducible it's not

00:41:41,359 --> 00:41:45,119
pretty

00:41:42,000 --> 00:41:46,880
but if you're determined then you can

00:41:45,119 --> 00:41:48,560
get it to work and reproduce these

00:41:46,880 --> 00:41:50,880
results

00:41:48,560 --> 00:41:52,160
if you have any questions then i'm of

00:41:50,880 --> 00:41:55,359
course available

00:41:52,160 --> 00:41:58,400
after this talk but as well of course

00:41:55,359 --> 00:42:00,560
via email with this address there

00:41:58,400 --> 00:42:02,000
and i would like to thank you for your

00:42:00,560 --> 00:42:03,599
attention and of course

00:42:02,000 --> 00:42:06,079
thank my colleagues for this interesting

00:42:03,599 --> 00:42:07,680
work and i hope you have

00:42:06,079 --> 00:42:16,160
many interesting questions thank you

00:42:07,680 --> 00:42:16,160

YouTube URL: https://www.youtube.com/watch?v=UTw-bfR10K4


