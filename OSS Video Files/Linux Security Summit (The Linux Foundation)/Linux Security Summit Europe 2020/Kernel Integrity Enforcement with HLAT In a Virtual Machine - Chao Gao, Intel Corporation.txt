Title: Kernel Integrity Enforcement with HLAT In a Virtual Machine - Chao Gao, Intel Corporation
Publication date: 2020-11-12
Playlist: Linux Security Summit Europe 2020
Description: 
	Kernel Integrity Enforcement with HLAT In a Virtual Machine - Chao Gao, Intel Corporation
Captions: 
	00:00:06,720 --> 00:00:10,160
hello everyone

00:00:07,520 --> 00:00:11,360
thanks for attending this junction i'm

00:00:10,160 --> 00:00:14,639
uh

00:00:11,360 --> 00:00:16,720
i'm working for intel today we are going

00:00:14,639 --> 00:00:17,760
to talk about current integrity

00:00:16,720 --> 00:00:21,119
enforcement

00:00:17,760 --> 00:00:24,480
with h9 in your virtual machine

00:00:21,119 --> 00:00:24,480
okay let's get started

00:00:24,720 --> 00:00:30,720
so here is today's agenda the first

00:00:28,080 --> 00:00:31,519
part is about some background i will

00:00:30,720 --> 00:00:33,760
explain

00:00:31,519 --> 00:00:35,040
why address translation integrity is

00:00:33,760 --> 00:00:38,480
important

00:00:35,040 --> 00:00:41,840
and what will happen if the integrity

00:00:38,480 --> 00:00:43,680
can be insured the second part is an

00:00:41,840 --> 00:00:46,000
introduction to a slide

00:00:43,680 --> 00:00:47,039
we will introduce the hardware

00:00:46,000 --> 00:00:49,200
capability

00:00:47,039 --> 00:00:51,360
and how to change kind of hardware

00:00:49,200 --> 00:00:56,000
behavior

00:00:51,360 --> 00:00:56,000
in the last part i would describe the

00:00:56,480 --> 00:01:00,879
edge light based resolution to enforce

00:00:59,440 --> 00:01:03,280
current integrity

00:01:00,879 --> 00:01:03,920
and there's some security consideration

00:01:03,280 --> 00:01:06,720
and its

00:01:03,920 --> 00:01:06,720
secure value

00:01:09,200 --> 00:01:14,799
so let's start from address translation

00:01:12,080 --> 00:01:14,799
integrity

00:01:18,320 --> 00:01:21,600
as you know page table not only

00:01:20,880 --> 00:01:24,159
translates

00:01:21,600 --> 00:01:25,520
virtual drives to physio address but

00:01:24,159 --> 00:01:27,840
also defines some

00:01:25,520 --> 00:01:28,799
permission control bits in page table

00:01:27,840 --> 00:01:31,840
entry

00:01:28,799 --> 00:01:34,960
for example the present bit

00:01:31,840 --> 00:01:37,439
read write bit user supervisor bit and

00:01:34,960 --> 00:01:39,040
execution disable it many secure

00:01:37,439 --> 00:01:42,320
features

00:01:39,040 --> 00:01:44,320
to reinforce access control are built on

00:01:42,320 --> 00:01:45,840
its permission base for example in

00:01:44,320 --> 00:01:48,240
counterliner's kernel

00:01:45,840 --> 00:01:49,840
current code and raw data are marked as

00:01:48,240 --> 00:01:53,600
read only in page table

00:01:49,840 --> 00:01:57,040
it can reduce kernel's attack surface

00:01:53,600 --> 00:02:00,240
and the kernel also matches data

00:01:57,040 --> 00:02:03,280
stack that's non-executable

00:02:00,240 --> 00:02:06,719
kernel also use smap

00:02:03,280 --> 00:02:10,319
or smep to segregate user

00:02:06,719 --> 00:02:10,319
and kernel memory exercise

00:02:13,360 --> 00:02:19,280
so what these access control methods are

00:02:16,800 --> 00:02:21,440
implemented in page table but the page

00:02:19,280 --> 00:02:25,120
table itself is readable

00:02:21,440 --> 00:02:27,280
so it's vulnerable

00:02:25,120 --> 00:02:28,640
for example assuming that a powerful

00:02:27,280 --> 00:02:32,319
attacker is about to

00:02:28,640 --> 00:02:35,280
access the arbitrary memory by

00:02:32,319 --> 00:02:36,720
exploring some kind of vulnerabilities

00:02:35,280 --> 00:02:38,720
you can inject

00:02:36,720 --> 00:02:41,040
share code into kernel with following

00:02:38,720 --> 00:02:42,879
steps first you can get paid table

00:02:41,040 --> 00:02:45,920
location from task track

00:02:42,879 --> 00:02:48,319
for example nasa mm extract

00:02:45,920 --> 00:02:50,400
pointer intestine drug and from animal

00:02:48,319 --> 00:02:51,760
structure we can locate the page tables

00:02:50,400 --> 00:02:54,800
rule page

00:02:51,760 --> 00:02:56,080
then on the tag account overrides page

00:02:54,800 --> 00:02:59,680
table to

00:02:56,080 --> 00:02:59,680
style kernel code readable

00:03:00,560 --> 00:03:04,640
then it can overwrite the beginning of a

00:03:03,760 --> 00:03:07,360
cisco

00:03:04,640 --> 00:03:10,560
with sharecode so as you can see the

00:03:07,360 --> 00:03:13,200
integrity of pay table

00:03:10,560 --> 00:03:14,640
or translation is important if the

00:03:13,200 --> 00:03:19,840
integrity is ensured

00:03:14,640 --> 00:03:19,840
access control can be easily bypassed

00:03:21,200 --> 00:03:26,239
so let's look at the two typical page

00:03:23,840 --> 00:03:28,480
table override attacks

00:03:26,239 --> 00:03:29,519
one is there is an alias mapping for

00:03:28,480 --> 00:03:31,680
example

00:03:29,519 --> 00:03:32,640
one virtual device is mapped to a

00:03:31,680 --> 00:03:36,239
physical page

00:03:32,640 --> 00:03:38,720
without right permission i assume

00:03:36,239 --> 00:03:40,879
a powerful attack already has a

00:03:38,720 --> 00:03:43,519
arbitrary memory exercise

00:03:40,879 --> 00:03:44,840
you can set up on a smip to the physical

00:03:43,519 --> 00:03:47,760
page

00:03:44,840 --> 00:03:52,400
and write

00:03:47,760 --> 00:03:55,200
the page so you can modify the content

00:03:52,400 --> 00:03:56,319
and maybe into some share code now i'm

00:03:55,200 --> 00:03:58,480
gonna try to

00:03:56,319 --> 00:04:00,480
execute the code with the original

00:03:58,480 --> 00:04:02,799
virtual address you will then modify the

00:04:00,480 --> 00:04:02,799
code

00:04:02,959 --> 00:04:07,680
so the other attack is the page

00:04:05,680 --> 00:04:09,920
remapping in this attack the anniversary

00:04:07,680 --> 00:04:12,840
doesn't need to modify the real

00:04:09,920 --> 00:04:14,080
physical page you just copy the content

00:04:12,840 --> 00:04:18,160
from

00:04:14,080 --> 00:04:21,759
original page to a new physical page

00:04:18,160 --> 00:04:23,759
and modify the content and then redirect

00:04:21,759 --> 00:04:29,840
the original virtual address to

00:04:23,759 --> 00:04:29,840
this new physical page

00:04:31,759 --> 00:04:38,639
yeah some vietnamese use epd

00:04:34,960 --> 00:04:41,199
to enforce access control and

00:04:38,639 --> 00:04:42,320
enhance gastro kernel security but for

00:04:41,199 --> 00:04:44,639
the ept is

00:04:42,320 --> 00:04:46,240
only responsible for translation from

00:04:44,639 --> 00:04:48,880
against visual drives

00:04:46,240 --> 00:04:50,000
to host a physical address it can

00:04:48,880 --> 00:04:52,240
enforce

00:04:50,000 --> 00:04:53,520
the translation from caster virtual

00:04:52,240 --> 00:04:56,400
drives to

00:04:53,520 --> 00:04:58,160
get the physical effects so even with

00:04:56,400 --> 00:05:01,120
access control in ebt

00:04:58,160 --> 00:05:03,360
vm's corner is still vulnerable to page

00:05:01,120 --> 00:05:07,680
remapping attacks

00:05:03,360 --> 00:05:10,240
now here is our example you can enforce

00:05:07,680 --> 00:05:11,120
access control at the epd level you'll

00:05:10,240 --> 00:05:14,560
read all in

00:05:11,120 --> 00:05:16,720
this physical page and

00:05:14,560 --> 00:05:18,960
but our attacker still can copy the

00:05:16,720 --> 00:05:21,919
content to another physical page

00:05:18,960 --> 00:05:22,320
and the redirect gets the virtual device

00:05:21,919 --> 00:05:25,840
to

00:05:22,320 --> 00:05:25,840
not against the visual page

00:05:25,919 --> 00:05:29,759
so this attack can't be detected by the

00:05:28,800 --> 00:05:32,240
vmm if

00:05:29,759 --> 00:05:33,680
vmm doesn't the monitor gets the pitch

00:05:32,240 --> 00:05:36,560
table change

00:05:33,680 --> 00:05:38,160
currently we don't want to monitor guess

00:05:36,560 --> 00:05:40,880
the pivot table change because

00:05:38,160 --> 00:05:41,919
you will require the amendment to drive

00:05:40,880 --> 00:05:44,639
for example move

00:05:41,919 --> 00:05:45,199
to cr3 instruction on the right product

00:05:44,639 --> 00:05:48,960
the

00:05:45,199 --> 00:05:51,440
page and the audit each change is for

00:05:48,960 --> 00:05:55,120
page table

00:05:51,440 --> 00:05:58,560
so it's similar to what shadow page does

00:05:55,120 --> 00:06:02,479
and where what we know it with a neutral

00:05:58,560 --> 00:06:02,479
significant performance penalty

00:06:04,960 --> 00:06:10,240
so the part two about edge lighting

00:06:13,199 --> 00:06:18,000
is short for hypervisor management link

00:06:15,919 --> 00:06:21,039
address translation

00:06:18,000 --> 00:06:24,000
and here is

00:06:21,039 --> 00:06:25,199
the h-lite specification if you are

00:06:24,000 --> 00:06:29,840
interested in it

00:06:25,199 --> 00:06:33,199
you can download the spec from this link

00:06:29,840 --> 00:06:37,120
the primary goal of each light is to

00:06:33,199 --> 00:06:41,360
enforce guest translation integrity and

00:06:37,120 --> 00:06:44,639
prevent page table override attacks

00:06:41,360 --> 00:06:45,919
how does a slide work here is the key

00:06:44,639 --> 00:06:49,360
idea

00:06:45,919 --> 00:06:52,720
each light allows vmm to specify

00:06:49,360 --> 00:06:56,479
a virtual address range here so-called

00:06:52,720 --> 00:07:00,000
plr which means protected linear address

00:06:56,479 --> 00:07:02,240
trans ninja address range

00:07:00,000 --> 00:07:03,360
for virtual addresses in prr the

00:07:02,240 --> 00:07:05,759
translation is

00:07:03,360 --> 00:07:06,639
done by a little piece table called each

00:07:05,759 --> 00:07:09,759
lite

00:07:06,639 --> 00:07:13,360
instead of the cs3 page table

00:07:09,759 --> 00:07:17,120
and h9 is management by vmware vm can

00:07:13,360 --> 00:07:21,440
use epg to prevent capture kernel from

00:07:17,120 --> 00:07:24,479
changing edge light other virtual

00:07:21,440 --> 00:07:27,599
other virtual drives outside plr still

00:07:24,479 --> 00:07:28,080
translated with the cr3 page table the

00:07:27,599 --> 00:07:32,000
main

00:07:28,080 --> 00:07:35,680
benefits of hlite are security

00:07:32,000 --> 00:07:40,080
and efficiency but the prr

00:07:35,680 --> 00:07:40,080
here and the baselines

00:07:40,319 --> 00:07:45,360
are mentioned by vmm and they can be

00:07:43,440 --> 00:07:48,879
changed by gatherings

00:07:45,360 --> 00:07:51,759
then for guest virtual devices in plr

00:07:48,879 --> 00:07:53,440
layer translation is unvulnerable to

00:07:51,759 --> 00:07:58,160
page remapping attack

00:07:53,440 --> 00:08:00,720
and is efficient compared with ept based

00:07:58,160 --> 00:08:01,360
page table protection because with each

00:08:00,720 --> 00:08:04,400
light

00:08:01,360 --> 00:08:05,120
vmware doesn't need to intercept change

00:08:04,400 --> 00:08:08,319
to

00:08:05,120 --> 00:08:08,319
csv page table

00:08:09,360 --> 00:08:16,720
your vmm only needs to

00:08:12,639 --> 00:08:22,000
specify the plr and

00:08:16,720 --> 00:08:22,000
map the construct h9 page table

00:08:22,879 --> 00:08:28,720
and this page is about

00:08:26,080 --> 00:08:31,280
which light is changed to a nested page

00:08:28,720 --> 00:08:35,200
type of block

00:08:31,280 --> 00:08:38,000
the dusty blue box is the legacy

00:08:35,200 --> 00:08:39,120
nicely the page table work for giving

00:08:38,000 --> 00:08:42,080
virtual drives

00:08:39,120 --> 00:08:43,440
page walker use the csv piece table to

00:08:42,080 --> 00:08:45,200
translate it

00:08:43,440 --> 00:08:47,519
against the virtual drive to cancel

00:08:45,200 --> 00:08:49,600
visual drives and the epd translate

00:08:47,519 --> 00:08:53,200
against a visual drive to

00:08:49,600 --> 00:08:57,680
host a visual device then the

00:08:53,200 --> 00:09:00,640
mapping can be cached in trp

00:08:57,680 --> 00:09:01,440
with each line enabled vmware defines a

00:09:00,640 --> 00:09:04,640
pr

00:09:01,440 --> 00:09:08,320
cpu does a prr check if

00:09:04,640 --> 00:09:11,839
the gas virtual address is in hpr range

00:09:08,320 --> 00:09:12,399
the cpu works each light rather than cs3

00:09:11,839 --> 00:09:15,200
page

00:09:12,399 --> 00:09:16,000
together against official device and a

00:09:15,200 --> 00:09:19,120
customer

00:09:16,000 --> 00:09:21,760
you'll find during each line work

00:09:19,120 --> 00:09:23,120
cpu will encounter restart bits after

00:09:21,760 --> 00:09:27,279
another cpu restart

00:09:23,120 --> 00:09:27,279
page work with csv page table

00:09:27,600 --> 00:09:31,440
and each slide will also introduce

00:09:29,680 --> 00:09:37,839
additional checks in ept

00:09:31,440 --> 00:09:37,839
our talker about eliminator

00:09:42,000 --> 00:09:45,040
so this page is about the edge slide

00:09:44,160 --> 00:09:48,480
paging

00:09:45,040 --> 00:09:49,120
page structures page page structure are

00:09:48,480 --> 00:09:52,160
almost

00:09:49,120 --> 00:09:54,720
the same as the x32e

00:09:52,160 --> 00:09:57,040
page structures it is supposed to bother

00:09:54,720 --> 00:10:01,120
five live one four level hierarchy

00:09:57,040 --> 00:10:04,399
and the bt 11 which is

00:10:01,120 --> 00:10:06,160
previously ignored is republished as the

00:10:04,399 --> 00:10:08,480
restartability

00:10:06,160 --> 00:10:10,480
he didn't need to be the result of the

00:10:08,480 --> 00:10:14,880
page walker result from

00:10:10,480 --> 00:10:14,880
just the csv piece table and

00:10:15,040 --> 00:10:21,720
about page fault if a page worker

00:10:18,399 --> 00:10:24,640
encounters a non-present entry or

00:10:21,720 --> 00:10:27,839
misconfigured entry for example

00:10:24,640 --> 00:10:31,920
the reserve beats asset in each slide

00:10:27,839 --> 00:10:34,240
page instructors cpu reports page 4 to

00:10:31,920 --> 00:10:35,600
software with a new page for the error

00:10:34,240 --> 00:10:38,900
code

00:10:35,600 --> 00:10:40,240
the bit 7 means the folder is

00:10:38,900 --> 00:10:42,350
[Music]

00:10:40,240 --> 00:10:43,600
h9 the terminal fault and

00:10:42,350 --> 00:10:45,519
[Music]

00:10:43,600 --> 00:10:47,680
another page for the ir code i set up

00:10:45,519 --> 00:10:50,320
the user

00:10:47,680 --> 00:10:50,880
now two new epd control views are

00:10:50,320 --> 00:10:54,240
defined

00:10:50,880 --> 00:10:58,399
i have to track alias mapping one is the

00:10:54,240 --> 00:11:00,640
paging write page and write allows cpu

00:10:58,399 --> 00:11:02,720
to update the adb some page

00:11:00,640 --> 00:11:04,399
even if they are not reliable to

00:11:02,720 --> 00:11:06,880
software

00:11:04,399 --> 00:11:07,440
for example previously if we write

00:11:06,880 --> 00:11:10,880
permission

00:11:07,440 --> 00:11:12,640
inside an epd entry the cpu is allowed

00:11:10,880 --> 00:11:15,839
to write through the page

00:11:12,640 --> 00:11:16,560
and adb is update if the page is used as

00:11:15,839 --> 00:11:20,079
a

00:11:16,560 --> 00:11:22,240
page table but if no write permission

00:11:20,079 --> 00:11:24,720
both the software rights and the adb

00:11:22,240 --> 00:11:26,839
updates will be delighted and the call

00:11:24,720 --> 00:11:29,680
the epd violation will

00:11:26,839 --> 00:11:30,800
exit page and writes introduce a new

00:11:29,680 --> 00:11:33,839
configuration

00:11:30,800 --> 00:11:34,160
if a page is not readable but has a page

00:11:33,839 --> 00:11:38,880
right

00:11:34,160 --> 00:11:42,640
side then direct software rights

00:11:38,880 --> 00:11:46,800
are delight but the cpu update adbs

00:11:42,640 --> 00:11:50,000
are allowed basically page and write

00:11:46,800 --> 00:11:53,440
improve efficiency if vm needs to

00:11:50,000 --> 00:11:56,560
read the online gas station table

00:11:53,440 --> 00:11:57,920
and the epd you can reduce vm access due

00:11:56,560 --> 00:12:01,279
to adb

00:11:57,920 --> 00:12:03,360
updates and then

00:12:01,279 --> 00:12:06,160
their memory don't need to do adb

00:12:03,360 --> 00:12:06,160
simulation

00:12:09,760 --> 00:12:14,800
so the other piece is verified page

00:12:11,680 --> 00:12:17,519
right grandfathering writing enforcement

00:12:14,800 --> 00:12:18,000
won't leave guess the paging structure

00:12:17,519 --> 00:12:20,399
page

00:12:18,000 --> 00:12:21,279
encountered during masterpiece table

00:12:20,399 --> 00:12:25,440
work

00:12:21,279 --> 00:12:28,560
as pw site on the ept

00:12:25,440 --> 00:12:32,000
otherwise generates an epd evaluation

00:12:28,560 --> 00:12:34,240
specifically this page

00:12:32,000 --> 00:12:34,240
is

00:12:35,120 --> 00:12:40,320
set as verify page and write on the

00:12:39,040 --> 00:12:44,079
liberty here

00:12:40,320 --> 00:12:44,959
the cpu will verify that all the guest

00:12:44,079 --> 00:12:48,160
page table

00:12:44,959 --> 00:12:51,920
pays as a paging

00:12:48,160 --> 00:12:52,480
has pw sites on the ept otherwise if it

00:12:51,920 --> 00:12:56,240
is

00:12:52,480 --> 00:12:56,240
evd evaluation is generated

00:12:57,680 --> 00:13:05,440
vernam can use vpw

00:13:01,360 --> 00:13:07,920
and the pw there's two epd

00:13:05,440 --> 00:13:09,760
beads to prevent the memory access

00:13:07,920 --> 00:13:13,839
through nx market

00:13:09,760 --> 00:13:16,880
for example for memory to be protected

00:13:13,839 --> 00:13:20,000
vmm said vpw flag

00:13:16,880 --> 00:13:22,240
and the ept and the said

00:13:20,000 --> 00:13:24,000
pw flight for each light paging

00:13:22,240 --> 00:13:27,040
structure on the epg

00:13:24,000 --> 00:13:28,399
then the protected memory can only be

00:13:27,040 --> 00:13:31,279
accessed

00:13:28,399 --> 00:13:31,680
through each light if an attacker side

00:13:31,279 --> 00:13:34,959
of

00:13:31,680 --> 00:13:36,800
enes mapping cr3ps table to access a

00:13:34,959 --> 00:13:39,600
protected memory

00:13:36,800 --> 00:13:40,160
memory exercise to protect the memory

00:13:39,600 --> 00:13:43,199
would

00:13:40,160 --> 00:13:46,880
cause ept violation due to

00:13:43,199 --> 00:13:50,240
nether low pw flight

00:13:46,880 --> 00:13:52,800
in the asia's map setup by

00:13:50,240 --> 00:13:52,800
attacker

00:13:56,800 --> 00:14:03,839
let's look at how to use h93 in force

00:13:59,839 --> 00:14:03,839
color integrity

00:14:05,120 --> 00:14:08,959
this is the high-level architecture of

00:14:08,320 --> 00:14:12,560
using

00:14:08,959 --> 00:14:13,920
h9 to protect translation for contacts

00:14:12,560 --> 00:14:16,959
and raw data

00:14:13,920 --> 00:14:20,079
so here we have a vmm and the

00:14:16,959 --> 00:14:21,199
virtual machine and a secure kind of the

00:14:20,079 --> 00:14:23,199
virtual machine

00:14:21,199 --> 00:14:24,240
new virtual machine there are two page

00:14:23,199 --> 00:14:26,959
tables

00:14:24,240 --> 00:14:28,839
to translate together virtual device one

00:14:26,959 --> 00:14:31,680
is the

00:14:28,839 --> 00:14:35,519
legacy cr3 page table

00:14:31,680 --> 00:14:38,880
now is the only user to translate

00:14:35,519 --> 00:14:39,680
for example user memory read write data

00:14:38,880 --> 00:14:43,120
in the stack

00:14:39,680 --> 00:14:45,440
and the code and the raw data is

00:14:43,120 --> 00:14:46,560
protected and translated with each

00:14:45,440 --> 00:14:48,800
knight

00:14:46,560 --> 00:14:50,160
now each match enforced read-only

00:14:48,800 --> 00:14:52,000
mappings on

00:14:50,160 --> 00:14:53,279
current attacks and raw data which

00:14:52,000 --> 00:14:54,560
finally itself is

00:14:53,279 --> 00:14:56,320
also read-only in

00:14:54,560 --> 00:14:59,360
[Music]

00:14:56,320 --> 00:15:00,959
in the normal columns view and read

00:14:59,360 --> 00:15:03,040
write in the secure color

00:15:00,959 --> 00:15:05,199
when normal color wants to set up a new

00:15:03,040 --> 00:15:08,000
protective mapping

00:15:05,199 --> 00:15:09,680
or tier down existing mappings it can

00:15:08,000 --> 00:15:11,440
talk with secure connections

00:15:09,680 --> 00:15:13,839
communication channel

00:15:11,440 --> 00:15:15,839
then the security can audit requests and

00:15:13,839 --> 00:15:18,560
the changes

00:15:15,839 --> 00:15:19,600
each night accordingly in this

00:15:18,560 --> 00:15:23,040
architecture

00:15:19,600 --> 00:15:24,079
we don't allow normal kernel to modify

00:15:23,040 --> 00:15:26,959
scientific

00:15:24,079 --> 00:15:28,800
table because if the normal kernel can

00:15:26,959 --> 00:15:32,240
modify small piece table

00:15:28,800 --> 00:15:33,199
the translation for connect text and the

00:15:32,240 --> 00:15:36,880
raw data

00:15:33,199 --> 00:15:40,079
can be redirected the trusted entity

00:15:36,880 --> 00:15:41,519
is required to measure each night

00:15:40,079 --> 00:15:44,320
pitching structures

00:15:41,519 --> 00:15:46,240
we rely on a circular kernel in this

00:15:44,320 --> 00:15:48,959
design but the trust entity can

00:15:46,240 --> 00:15:51,120
also be the vmf in that case there are a

00:15:48,959 --> 00:15:54,320
lot of intrusive changes

00:15:51,120 --> 00:15:57,519
such as some policies needed

00:15:54,320 --> 00:16:00,399
to be implemented inside

00:15:57,519 --> 00:16:00,399
the vmm

00:16:01,199 --> 00:16:04,800
through this precise management i have

00:16:04,240 --> 00:16:07,640
called

00:16:04,800 --> 00:16:08,800
several kernel can sign the consider

00:16:07,640 --> 00:16:12,000
[Music]

00:16:08,800 --> 00:16:15,600
vpw flag for current attacks and

00:16:12,000 --> 00:16:18,320
raw data on the ept and cite a

00:16:15,600 --> 00:16:20,839
pw flag for each page and structured on

00:16:18,320 --> 00:16:24,079
the ept

00:16:20,839 --> 00:16:25,759
and yeah by ensuring that the only

00:16:24,079 --> 00:16:26,480
security camera can invoke in this

00:16:25,759 --> 00:16:30,079
hardcore

00:16:26,480 --> 00:16:36,959
normal account setup venus mapping to

00:16:30,079 --> 00:16:40,000
excise the protected memory

00:16:36,959 --> 00:16:43,519
sometimes just the kernel needs to

00:16:40,000 --> 00:16:44,399
set up from the tiered or productive

00:16:43,519 --> 00:16:48,720
mappings at

00:16:44,399 --> 00:16:51,839
runtime for example when gaster

00:16:48,720 --> 00:16:54,800
knows a new module you would

00:16:51,839 --> 00:16:55,680
insert some executable code in your

00:16:54,800 --> 00:17:00,480
kernel

00:16:55,680 --> 00:17:03,279
and for the new code

00:17:00,480 --> 00:17:04,640
nail translation also needs to be

00:17:03,279 --> 00:17:08,000
protected

00:17:04,640 --> 00:17:11,360
during module unloading we need to

00:17:08,000 --> 00:17:11,760
tear down the protected mappings such

00:17:11,360 --> 00:17:14,240
that

00:17:11,760 --> 00:17:16,240
the virtual drives range and the memory

00:17:14,240 --> 00:17:19,360
can be reused

00:17:16,240 --> 00:17:22,079
but we need to avoid

00:17:19,360 --> 00:17:22,880
avoid abuse of material down operation

00:17:22,079 --> 00:17:26,400
for example our

00:17:22,880 --> 00:17:27,199
attack can just request a secure kernel

00:17:26,400 --> 00:17:30,240
to tie the

00:17:27,199 --> 00:17:30,559
protective mapping for kind of code and

00:17:30,240 --> 00:17:33,120
then

00:17:30,559 --> 00:17:34,000
modify kind of code one feasible

00:17:33,120 --> 00:17:36,880
solution

00:17:34,000 --> 00:17:39,200
is we can utilize a model based

00:17:36,880 --> 00:17:42,559
execution control for ept

00:17:39,200 --> 00:17:46,720
for example secure can ensures code

00:17:42,559 --> 00:17:50,080
has correct a signature

00:17:46,720 --> 00:17:52,640
when setting up protective mappings and

00:17:50,080 --> 00:17:53,840
give executable permission in supervisor

00:17:52,640 --> 00:17:58,000
mode

00:17:53,840 --> 00:18:01,360
and if protective mapping is torn down

00:17:58,000 --> 00:18:04,799
the revoke executable permission

00:18:01,360 --> 00:18:04,799
in supervisor mode

00:18:07,840 --> 00:18:11,360
actually in your school now some values

00:18:10,960 --> 00:18:14,720
and

00:18:11,360 --> 00:18:17,039
some important change to

00:18:14,720 --> 00:18:18,400
current attacks and render for example

00:18:17,039 --> 00:18:22,320
function tracing for

00:18:18,400 --> 00:18:26,000
debugging jump label and alternatives

00:18:22,320 --> 00:18:30,720
it should be allowed but we can't allow

00:18:26,000 --> 00:18:34,640
mama conor to do text passion directly

00:18:30,720 --> 00:18:34,640
ideally text passion

00:18:34,960 --> 00:18:40,960
needs to be done in secure corner

00:18:38,480 --> 00:18:43,039
and the security can implement a

00:18:40,960 --> 00:18:45,919
approved policy to audit

00:18:43,039 --> 00:18:46,799
the request based on the location to

00:18:45,919 --> 00:18:50,320
patch

00:18:46,799 --> 00:18:50,320
and the word patch does

00:18:51,760 --> 00:18:57,039
so what's the security values of this

00:18:55,120 --> 00:19:00,400
solution

00:18:57,039 --> 00:19:02,240
yeah basically it defends against code

00:19:00,400 --> 00:19:06,080
injection attacks

00:19:02,240 --> 00:19:08,840
like a hook cisco or override identity

00:19:06,080 --> 00:19:11,200
and a reasonable exploiting kernel of

00:19:08,840 --> 00:19:14,320
vulnerabilities

00:19:11,200 --> 00:19:16,799
and within this solution even if normal

00:19:14,320 --> 00:19:20,240
kernel is compromised

00:19:16,799 --> 00:19:21,919
vmm with secure kernel can ensure the

00:19:20,240 --> 00:19:24,080
integrity of llama

00:19:21,919 --> 00:19:26,480
from the llama kernel's code and raw

00:19:24,080 --> 00:19:26,480
data

00:19:27,280 --> 00:19:32,799
this is a summary to this section

00:19:30,320 --> 00:19:33,520
first restricting exercise to kernel

00:19:32,799 --> 00:19:36,720
code and

00:19:33,520 --> 00:19:40,160
rotator can reduce attack surface

00:19:36,720 --> 00:19:44,640
of color but peace table

00:19:40,160 --> 00:19:48,160
tanks can bypass such restrictions

00:19:44,640 --> 00:19:51,760
and the h90 providers are efficient way

00:19:48,160 --> 00:19:55,120
to reinforce the integrity of a gastric

00:19:51,760 --> 00:19:55,760
and the vmm can use h9 and epd control

00:19:55,120 --> 00:19:58,400
bits

00:19:55,760 --> 00:20:01,200
to enforce the integrity of kernel code

00:19:58,400 --> 00:20:01,200
and raw data

00:20:02,559 --> 00:20:08,480
yet this is the master page that's what

00:20:06,000 --> 00:20:18,159
i have

00:20:08,480 --> 00:20:18,159

YouTube URL: https://www.youtube.com/watch?v=N8avvE_neV0


