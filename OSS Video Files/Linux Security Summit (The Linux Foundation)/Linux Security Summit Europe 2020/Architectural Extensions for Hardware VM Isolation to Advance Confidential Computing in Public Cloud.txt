Title: Architectural Extensions for Hardware VM Isolation to Advance Confidential Computing in Public Cloud
Publication date: 2020-11-12
Playlist: Linux Security Summit Europe 2020
Description: 
	Architectural Extensions for Hardware Virtual Machine Isolation to Advance Confidential Computing in Public Clouds - Ravi Sahita & Jun Nakajima, Intel Corporation
Captions: 
	00:00:05,120 --> 00:00:09,040
hello everyone

00:00:06,480 --> 00:00:10,880
today my colleague jun nakajima and

00:00:09,040 --> 00:00:12,400
myself ravi sajita

00:00:10,880 --> 00:00:14,559
will talk to you about the architectural

00:00:12,400 --> 00:00:16,080
extensions that we are working on to

00:00:14,559 --> 00:00:18,080
advance confidential computing for

00:00:16,080 --> 00:00:20,320
public cloud environments

00:00:18,080 --> 00:00:23,920
specifically we'll talk about intel tdx

00:00:20,320 --> 00:00:23,920
or intel trust domain extensions

00:00:26,560 --> 00:00:29,760
so we'll cover the following items we'll

00:00:28,320 --> 00:00:30,560
cover the cloud thread vectors we're

00:00:29,760 --> 00:00:33,760
trying to address

00:00:30,560 --> 00:00:35,040
with intel tdx we'll look at quickly an

00:00:33,760 --> 00:00:36,320
evolution of the cloud workload

00:00:35,040 --> 00:00:38,160
isolation

00:00:36,320 --> 00:00:40,160
then we'll dive into intel tdx we'll try

00:00:38,160 --> 00:00:41,680
to cover the the key architectural

00:00:40,160 --> 00:00:44,239
building blocks

00:00:41,680 --> 00:00:45,920
the threat model and coverage and

00:00:44,239 --> 00:00:47,200
finally june nakajima will cover the

00:00:45,920 --> 00:00:50,160
software implications

00:00:47,200 --> 00:00:50,160
of intel tdx

00:00:50,640 --> 00:00:54,160
let's look at the cloud thread vectors

00:00:52,079 --> 00:00:56,320
quickly the first

00:00:54,160 --> 00:00:57,920
area we're trying to address are for

00:00:56,320 --> 00:00:58,960
cloud tenants that are worried about

00:00:57,920 --> 00:01:01,280
exploits

00:00:58,960 --> 00:01:02,800
that may lead to loss of their data at

00:01:01,280 --> 00:01:04,559
the same time providers are worried

00:01:02,800 --> 00:01:06,560
about privilege escalation

00:01:04,559 --> 00:01:08,799
that may lead to loss of control of the

00:01:06,560 --> 00:01:10,479
infrastructure

00:01:08,799 --> 00:01:12,560
the second key tenant we are trying to

00:01:10,479 --> 00:01:14,720
address is cloud providers

00:01:12,560 --> 00:01:16,400
where they want to address the fact that

00:01:14,720 --> 00:01:18,080
you know they don't want the visibility

00:01:16,400 --> 00:01:19,520
into the customer workloads

00:01:18,080 --> 00:01:21,520
they want to make sure that the data

00:01:19,520 --> 00:01:23,119
that's in use is always encrypted

00:01:21,520 --> 00:01:25,200
and addresses the key privacy and

00:01:23,119 --> 00:01:26,880
security requirements

00:01:25,200 --> 00:01:29,200
and then the third is that we're trying

00:01:26,880 --> 00:01:30,880
to address in terms of the usage models

00:01:29,200 --> 00:01:33,040
is to be able to support isolation

00:01:30,880 --> 00:01:35,680
models and confidentiality models

00:01:33,040 --> 00:01:36,479
that go across applications to virtual

00:01:35,680 --> 00:01:38,840
machines

00:01:36,479 --> 00:01:40,159
and eventually also to containers and

00:01:38,840 --> 00:01:41,840
microservices

00:01:40,159 --> 00:01:43,920
let's look at how the cloud workload

00:01:41,840 --> 00:01:46,000
isolation has evolved

00:01:43,920 --> 00:01:47,759
so today we already have intel

00:01:46,000 --> 00:01:48,159
virtualization technology which is used

00:01:47,759 --> 00:01:50,560
by

00:01:48,159 --> 00:01:52,479
virtual machine monitors to isolate

00:01:50,560 --> 00:01:54,320
hardware virtual machines today

00:01:52,479 --> 00:01:56,000
and intel txt or trusted execution

00:01:54,320 --> 00:01:57,200
technology which can be used to measure

00:01:56,000 --> 00:02:00,000
the vmm

00:01:57,200 --> 00:02:01,439
on launch so that it can be you know

00:02:00,000 --> 00:02:03,600
reported its measurements can be

00:02:01,439 --> 00:02:05,759
reported

00:02:03,600 --> 00:02:07,360
we also have the capabilities of total

00:02:05,759 --> 00:02:10,160
memory encryption

00:02:07,360 --> 00:02:11,920
and multi-key total memory encryption

00:02:10,160 --> 00:02:13,040
that can be used to encrypt either all

00:02:11,920 --> 00:02:16,560
the physical memory

00:02:13,040 --> 00:02:20,000
on the system or under the vms control

00:02:16,560 --> 00:02:22,959
selected memory on the on the system

00:02:20,000 --> 00:02:24,640
at a page granular level right and that

00:02:22,959 --> 00:02:26,640
can be enabled either

00:02:24,640 --> 00:02:28,720
just basically through the bios through

00:02:26,640 --> 00:02:30,720
for the total memory encryption

00:02:28,720 --> 00:02:32,800
or additionally through the vmm for

00:02:30,720 --> 00:02:35,519
multi-keyword memory encryption

00:02:32,800 --> 00:02:36,000
in both of these cases however the vmm

00:02:35,519 --> 00:02:38,640
remains

00:02:36,000 --> 00:02:40,239
in the trusted computing base or tcp for

00:02:38,640 --> 00:02:42,239
both the cloud providers and the cloud

00:02:40,239 --> 00:02:45,120
tenants

00:02:42,239 --> 00:02:46,239
let's look uh forward as at what other

00:02:45,120 --> 00:02:48,400
options

00:02:46,239 --> 00:02:50,560
that capabilities intel has provided for

00:02:48,400 --> 00:02:52,080
removing the vmf from the tcp

00:02:50,560 --> 00:02:54,400
so first we have intel software guard

00:02:52,080 --> 00:02:58,159
extensions or sgx which removes the os

00:02:54,400 --> 00:02:59,280
vmm from the tcp it requires enabling of

00:02:58,159 --> 00:03:02,080
the application or

00:02:59,280 --> 00:03:03,280
some library os along with the os and

00:03:02,080 --> 00:03:05,440
the vmm

00:03:03,280 --> 00:03:07,519
today we are introducing trust domain

00:03:05,440 --> 00:03:10,080
extensions or intel tdx

00:03:07,519 --> 00:03:11,680
which essentially operates at the at the

00:03:10,080 --> 00:03:13,920
vmx root level

00:03:11,680 --> 00:03:14,879
and can be used to remove the csp

00:03:13,920 --> 00:03:18,159
provided software

00:03:14,879 --> 00:03:19,200
and the vmm from the tcb while isolating

00:03:18,159 --> 00:03:22,239
the vm

00:03:19,200 --> 00:03:24,000
as the as the container boundary and we

00:03:22,239 --> 00:03:25,280
call such an isolated vm that's

00:03:24,000 --> 00:03:28,640
accelerated through intel

00:03:25,280 --> 00:03:30,720
tdx a truss domain or a td

00:03:28,640 --> 00:03:32,640
the important aspect of intel tdx is

00:03:30,720 --> 00:03:34,319
that with the right enabling

00:03:32,640 --> 00:03:37,200
done for the vmm and the operating

00:03:34,319 --> 00:03:39,200
systems the the goal is to not require

00:03:37,200 --> 00:03:40,480
any changes to the applications

00:03:39,200 --> 00:03:43,440
to be able to protect them in a

00:03:40,480 --> 00:03:43,440
confidential manner

00:03:43,760 --> 00:03:47,120
so let's start diving into the intel tdx

00:03:45,599 --> 00:03:50,159
architecture with

00:03:47,120 --> 00:03:51,920
with some key goals or our scope the

00:03:50,159 --> 00:03:53,920
first is to provide confidentiality

00:03:51,920 --> 00:03:54,879
access control and integrity protection

00:03:53,920 --> 00:03:58,640
for

00:03:54,879 --> 00:04:01,280
vms that run as tds or trust domains

00:03:58,640 --> 00:04:03,920
in and on an environment that for which

00:04:01,280 --> 00:04:05,599
a vm has been enabled

00:04:03,920 --> 00:04:07,360
we want to maintain the resource

00:04:05,599 --> 00:04:09,040
management role of the vmm and that also

00:04:07,360 --> 00:04:12,159
means ensuring that

00:04:09,040 --> 00:04:15,280
neither vms or legacy vms or

00:04:12,159 --> 00:04:17,359
new tds um cannot launch

00:04:15,280 --> 00:04:19,280
a privilege escalation attack on the pla

00:04:17,359 --> 00:04:21,199
on the platform

00:04:19,280 --> 00:04:23,120
some attacks though are out of scope

00:04:21,199 --> 00:04:24,800
since the vmm retains the resource

00:04:23,120 --> 00:04:26,639
management role on the platform

00:04:24,800 --> 00:04:28,800
any vmm-induced denial of services

00:04:26,639 --> 00:04:30,160
autoscope and also some hardware

00:04:28,800 --> 00:04:33,280
adversary attacks

00:04:30,160 --> 00:04:34,720
such as memory replay or autoscope let's

00:04:33,280 --> 00:04:35,759
start diving into the building blocks

00:04:34,720 --> 00:04:39,280
for intel tdx

00:04:35,759 --> 00:04:39,280
we'll start with the cpu iso

00:04:39,520 --> 00:04:44,479
the first key capability is a

00:04:42,639 --> 00:04:46,160
cpu mode of operation called secure

00:04:44,479 --> 00:04:49,680
arbitration mode

00:04:46,160 --> 00:04:51,759
which is used to host a intel tdx module

00:04:49,680 --> 00:04:52,880
the intel tdx module is software that

00:04:51,759 --> 00:04:56,720
runs

00:04:52,880 --> 00:04:59,120
using the cpu scene mode of operation

00:04:56,720 --> 00:05:01,440
and is protected through capabilities

00:04:59,120 --> 00:05:03,680
that the cpu provides

00:05:01,440 --> 00:05:04,560
including a specific set of instructions

00:05:03,680 --> 00:05:07,759
that are used to

00:05:04,560 --> 00:05:10,960
enable guest host interactions

00:05:07,759 --> 00:05:12,639
the ddx module uses cpu this cpu mode to

00:05:10,960 --> 00:05:14,479
host the security functions that are

00:05:12,639 --> 00:05:17,120
exposed to the vmm

00:05:14,479 --> 00:05:18,960
and in order to protect the tdx module

00:05:17,120 --> 00:05:20,000
this mode restricts the use of certain

00:05:18,960 --> 00:05:22,560
iso

00:05:20,000 --> 00:05:24,479
so the tdx module can can use those

00:05:22,560 --> 00:05:26,400
those instructions

00:05:24,479 --> 00:05:28,240
it also provides range registers to

00:05:26,400 --> 00:05:29,039
protect the tdx module from other host

00:05:28,240 --> 00:05:32,800
software

00:05:29,039 --> 00:05:34,160
on the platform the tdx module is loaded

00:05:32,800 --> 00:05:36,080
into this range register

00:05:34,160 --> 00:05:37,919
protected region through an intel

00:05:36,080 --> 00:05:39,600
authenticated code module also called a

00:05:37,919 --> 00:05:42,960
seam loader

00:05:39,600 --> 00:05:46,080
further the tgx module is also protected

00:05:42,960 --> 00:05:48,160
for against physical attacks or using

00:05:46,080 --> 00:05:50,080
the total memory encryption engine to

00:05:48,160 --> 00:05:51,919
ensure the confidentiality

00:05:50,080 --> 00:05:53,520
and more importantly the integrity of

00:05:51,919 --> 00:05:56,560
the contents of the tdx module

00:05:53,520 --> 00:05:56,560
while it is executing

00:05:57,199 --> 00:06:01,600
so let's look at how the secure

00:05:59,520 --> 00:06:03,919
arbitration mode

00:06:01,600 --> 00:06:04,880
interacts with the with the legacy state

00:06:03,919 --> 00:06:06,479
machine

00:06:04,880 --> 00:06:08,800
so what i'm showing here is sort of the

00:06:06,479 --> 00:06:11,600
the traditional vmx

00:06:08,800 --> 00:06:12,479
operation right where the cpu

00:06:11,600 --> 00:06:15,039
essentially through

00:06:12,479 --> 00:06:15,919
vm exit and vm enter transitions between

00:06:15,039 --> 00:06:19,360
vmx

00:06:15,919 --> 00:06:21,680
root mode and non-root mode of operation

00:06:19,360 --> 00:06:24,160
where the secure arbitration mode comes

00:06:21,680 --> 00:06:26,639
in is as shown on the right hand side

00:06:24,160 --> 00:06:28,080
where software can enter the same vmx

00:06:26,639 --> 00:06:28,960
root mode of operation through a scene

00:06:28,080 --> 00:06:30,720
call

00:06:28,960 --> 00:06:32,639
and can exit scene vmx root mode of

00:06:30,720 --> 00:06:35,600
operation and come out into ordinary

00:06:32,639 --> 00:06:38,960
legacy vmx route through siem read

00:06:35,600 --> 00:06:41,600
bmx and vm enters work almost

00:06:38,960 --> 00:06:42,400
similarly as ordinary vm exit and vm

00:06:41,600 --> 00:06:45,440
enters

00:06:42,400 --> 00:06:46,880
in the c mode of operation with some

00:06:45,440 --> 00:06:49,680
subtle differences

00:06:46,880 --> 00:06:52,000
that during the cpu being in the same

00:06:49,680 --> 00:06:55,360
bmx root point of operation

00:06:52,000 --> 00:06:57,599
interrupts like smis are kept pending

00:06:55,360 --> 00:07:00,160
and they may be taken when the cpu is in

00:06:57,599 --> 00:07:03,360
same vmx non-root mode of operation

00:07:00,160 --> 00:07:05,919
and are even inhibited until the scene

00:07:03,360 --> 00:07:07,520
returns to the legacy vmx root mode of

00:07:05,919 --> 00:07:11,120
operation where they are

00:07:07,520 --> 00:07:12,720
unpainted this picture on the left hand

00:07:11,120 --> 00:07:15,840
side shows that interaction

00:07:12,720 --> 00:07:19,599
that most of the interactions with

00:07:15,840 --> 00:07:22,240
opt out smm legacy smm operation

00:07:19,599 --> 00:07:23,199
or opt-in stm operation remem remain

00:07:22,240 --> 00:07:27,120
unmodified

00:07:23,199 --> 00:07:27,120
with the introduction of cmod

00:07:27,840 --> 00:07:32,960
so with those three key capabilities

00:07:30,400 --> 00:07:35,919
defined the intel tdx module

00:07:32,960 --> 00:07:37,919
the acm is used to load the the say that

00:07:35,919 --> 00:07:39,039
the seam loader acm used to load the tdx

00:07:37,919 --> 00:07:41,280
module

00:07:39,039 --> 00:07:42,639
and obviously the cpu hardware the

00:07:41,280 --> 00:07:45,360
fourth key capability

00:07:42,639 --> 00:07:45,680
that sits in the trusted computing base

00:07:45,360 --> 00:07:48,960
for

00:07:45,680 --> 00:07:51,199
tds is the is a coding only

00:07:48,960 --> 00:07:52,400
and as i've described in a later file we

00:07:51,199 --> 00:07:54,400
leveraged the coding

00:07:52,400 --> 00:07:56,080
and attestation infrastructure that

00:07:54,400 --> 00:07:59,440
intel gx offers

00:07:56,080 --> 00:08:02,319
to make it simpler for uh for

00:07:59,440 --> 00:08:03,599
you know folks using intel tdx to

00:08:02,319 --> 00:08:06,080
leverage the same attestation

00:08:03,599 --> 00:08:08,400
infrastructure as intel hdx

00:08:06,080 --> 00:08:10,479
as this picture shows all of the other

00:08:08,400 --> 00:08:13,520
remaining capabilities on the platform

00:08:10,479 --> 00:08:15,360
including devices all other host

00:08:13,520 --> 00:08:19,520
software platform firmware

00:08:15,360 --> 00:08:21,120
bios smm the host os and the vm etc

00:08:19,520 --> 00:08:26,319
are all not trusted by the td and

00:08:21,120 --> 00:08:28,000
outside the tcp or intel tdx so

00:08:26,319 --> 00:08:30,400
let's dive into the next building block

00:08:28,000 --> 00:08:32,479
which is memory confidentiality

00:08:30,400 --> 00:08:33,440
so i'm showing a simple picture here of

00:08:32,479 --> 00:08:37,440
uh

00:08:33,440 --> 00:08:40,320
of an soc with with memory exposed

00:08:37,440 --> 00:08:41,839
um and the mktme or the multi-total

00:08:40,320 --> 00:08:44,000
memory encryption engine

00:08:41,839 --> 00:08:45,120
is is used as a building block for tin

00:08:44,000 --> 00:08:46,399
intel tdx

00:08:45,120 --> 00:08:48,720
and that's programmed through an

00:08:46,399 --> 00:08:49,120
instruction called pconfig to program

00:08:48,720 --> 00:08:52,399
the

00:08:49,120 --> 00:08:55,519
the key ids in the memory controller

00:08:52,399 --> 00:08:58,480
and the mktm engine

00:08:55,519 --> 00:08:59,200
the for intel tdx what we do here is

00:08:58,480 --> 00:09:02,480
that the

00:08:59,200 --> 00:09:04,560
key id space that that is used to

00:09:02,480 --> 00:09:07,279
program the

00:09:04,560 --> 00:09:08,000
nktm engine is effectively partitioned

00:09:07,279 --> 00:09:11,200
into a td

00:09:08,000 --> 00:09:13,760
private and a shared key id space

00:09:11,200 --> 00:09:15,279
this allows the vm to select what key

00:09:13,760 --> 00:09:18,640
ids to use for tds

00:09:15,279 --> 00:09:20,320
and what kids to retain for legacy vms

00:09:18,640 --> 00:09:21,760
and this partition is configured at

00:09:20,320 --> 00:09:24,240
system bios time

00:09:21,760 --> 00:09:25,839
system initialization time through bios

00:09:24,240 --> 00:09:28,560
and is verified and locked down by

00:09:25,839 --> 00:09:28,560
internet check

00:09:29,120 --> 00:09:33,360
the key important mechanism here as i

00:09:31,120 --> 00:09:36,399
was referring to in the previous slide

00:09:33,360 --> 00:09:37,360
is some isa is restricted in some

00:09:36,399 --> 00:09:39,920
operations

00:09:37,360 --> 00:09:41,200
for the intel tdx module through the c

00:09:39,920 --> 00:09:43,920
mode of the cpu

00:09:41,200 --> 00:09:45,279
and p config is one specific example the

00:09:43,920 --> 00:09:48,320
partitioning of the

00:09:45,279 --> 00:09:50,880
key id namespace is enforced to

00:09:48,320 --> 00:09:53,519
allow the tdx module to be able to use

00:09:50,880 --> 00:09:56,240
pconfig to program the keys for tds

00:09:53,519 --> 00:09:57,440
while the vmm can assign key ids as

00:09:56,240 --> 00:10:00,480
shown in this picture

00:09:57,440 --> 00:10:04,079
but cannot actually access or program

00:10:00,480 --> 00:10:07,279
those keys through pconfig

00:10:04,079 --> 00:10:08,240
um a related point also is that the vm

00:10:07,279 --> 00:10:10,720
may optionally

00:10:08,240 --> 00:10:11,440
retain some key ids for legacy vms and

00:10:10,720 --> 00:10:13,279
that's

00:10:11,440 --> 00:10:18,000
you know that's really an opt-in

00:10:13,279 --> 00:10:20,240
capability for the for the vpn

00:10:18,000 --> 00:10:21,839
look at the next building block which is

00:10:20,240 --> 00:10:24,399
memory integrity

00:10:21,839 --> 00:10:26,000
and as shown by various researchers it

00:10:24,399 --> 00:10:27,760
is not sufficient to

00:10:26,000 --> 00:10:30,320
just provide confidentiality through

00:10:27,760 --> 00:10:34,000
encryption for for

00:10:30,320 --> 00:10:36,320
for the correct operation of the tds

00:10:34,000 --> 00:10:37,920
it is also important to provide some

00:10:36,320 --> 00:10:40,000
level of tamper resistance

00:10:37,920 --> 00:10:41,440
against uh against attacks that

00:10:40,000 --> 00:10:44,640
untrusted software may

00:10:41,440 --> 00:10:46,480
perform so

00:10:44,640 --> 00:10:48,079
that is enabled through the through

00:10:46,480 --> 00:10:50,959
memory integrity capability

00:10:48,079 --> 00:10:52,240
in the nktme engine and that is as i

00:10:50,959 --> 00:10:56,320
said to protect against

00:10:52,240 --> 00:10:59,279
various forms of memory modification

00:10:56,320 --> 00:11:01,839
tamper relocation splicing and crosstd

00:10:59,279 --> 00:11:04,079
corruption

00:11:01,839 --> 00:11:05,200
memory integrity is enabled in the mktma

00:11:04,079 --> 00:11:08,640
engine through

00:11:05,200 --> 00:11:10,880
a sha-3 based mac it is used in a

00:11:08,640 --> 00:11:11,920
in a truncated fashion with 28 bits of

00:11:10,880 --> 00:11:15,279
the of the

00:11:11,920 --> 00:11:17,440
integrity mac being retained

00:11:15,279 --> 00:11:20,000
and that is managed through the ddr5

00:11:17,440 --> 00:11:23,360
metadata

00:11:20,000 --> 00:11:24,560
further the the metadata also contains a

00:11:23,360 --> 00:11:26,160
td owner bit

00:11:24,560 --> 00:11:28,560
which ensures that the untrusted

00:11:26,160 --> 00:11:31,040
software does not have any access

00:11:28,560 --> 00:11:31,839
to the to ciphertext even when a memory

00:11:31,040 --> 00:11:35,440
when memory is in

00:11:31,839 --> 00:11:37,200
under use by a td and any attempt from

00:11:35,440 --> 00:11:39,200
untrusted software to read

00:11:37,200 --> 00:11:40,560
memory that belongs to a td will

00:11:39,200 --> 00:11:43,279
essentially return

00:11:40,560 --> 00:11:44,560
zero data and depending on the the type

00:11:43,279 --> 00:11:47,920
of access performed

00:11:44,560 --> 00:11:47,920
we also poison the cache line

00:11:48,320 --> 00:11:52,399
at the same time we also want to protect

00:11:50,160 --> 00:11:54,880
the the platform from td

00:11:52,399 --> 00:11:56,560
so the vmm can ensure through the

00:11:54,880 --> 00:11:58,560
through the tdx module

00:11:56,560 --> 00:12:00,399
that any memory used by the td is

00:11:58,560 --> 00:12:03,040
correctly initialized first

00:12:00,399 --> 00:12:04,639
using direct stores and and this

00:12:03,040 --> 00:12:06,639
protects the vmm

00:12:04,639 --> 00:12:08,959
further any as i said in the previous

00:12:06,639 --> 00:12:11,360
point any untrusted software or hardware

00:12:08,959 --> 00:12:13,360
writes to the to the memory corrupts the

00:12:11,360 --> 00:12:15,600
mac and therefore protects the team

00:12:13,360 --> 00:12:17,279
so we achieve this sort of dual goal of

00:12:15,600 --> 00:12:20,480
protecting both the vmm

00:12:17,279 --> 00:12:23,120
and the td next

00:12:20,480 --> 00:12:26,000
let's look at how the private keys are

00:12:23,120 --> 00:12:30,800
managed both by the tdx module

00:12:26,000 --> 00:12:32,800
and the cpu as a td is operating

00:12:30,800 --> 00:12:34,079
so if you recall i had described in a

00:12:32,800 --> 00:12:36,000
previous file that the

00:12:34,079 --> 00:12:37,519
key id space is partitioned between

00:12:36,000 --> 00:12:39,200
private key ids

00:12:37,519 --> 00:12:41,440
and sharepid space the private key id

00:12:39,200 --> 00:12:43,200
space are managed by the tdx module and

00:12:41,440 --> 00:12:46,639
it tracks their allocation

00:12:43,200 --> 00:12:48,079
to ensure that the vmm does not misuse

00:12:46,639 --> 00:12:50,160
a key id that has been assigned to a

00:12:48,079 --> 00:12:52,399
particular tdd

00:12:50,160 --> 00:12:53,519
and that key id is loaded by the cpu

00:12:52,399 --> 00:12:55,839
during vm entry

00:12:53,519 --> 00:12:56,639
as the virtual cpus for the tds are

00:12:55,839 --> 00:12:59,760
executing

00:12:56,639 --> 00:12:59,760
on a logical processor

00:13:00,160 --> 00:13:06,880
the td expresses its its goals

00:13:03,279 --> 00:13:09,279
of what data is accessed as private and

00:13:06,880 --> 00:13:11,519
what data is access has shared

00:13:09,279 --> 00:13:12,959
through a new architectural convention

00:13:11,519 --> 00:13:16,079
that is expressed through the

00:13:12,959 --> 00:13:18,560
ipaging structures managed by the td

00:13:16,079 --> 00:13:19,360
through the bit 51 or 47 depending on

00:13:18,560 --> 00:13:22,639
the

00:13:19,360 --> 00:13:24,480
physical address available on the system

00:13:22,639 --> 00:13:26,560
and is expressed through a control bit

00:13:24,480 --> 00:13:29,120
called the shared bit

00:13:26,560 --> 00:13:30,800
and the shared bit if cleared specifies

00:13:29,120 --> 00:13:31,600
that the td wishes to access private

00:13:30,800 --> 00:13:32,800
data

00:13:31,600 --> 00:13:35,120
through those through those guest

00:13:32,800 --> 00:13:37,519
physical addresses and for that the

00:13:35,120 --> 00:13:39,120
view automatically uses the the private

00:13:37,519 --> 00:13:42,000
key id assigned

00:13:39,120 --> 00:13:42,800
by the by the vmm and tracked by the tdx

00:13:42,000 --> 00:13:45,519
module

00:13:42,800 --> 00:13:46,240
if the shared bit is set however the cpu

00:13:45,519 --> 00:13:50,480
will use

00:13:46,240 --> 00:13:52,639
the vmm specified mktme key id

00:13:50,480 --> 00:13:54,639
to access any shared data and that

00:13:52,639 --> 00:13:57,680
example usages of that may be

00:13:54,639 --> 00:13:59,680
para virtualized io data now

00:13:57,680 --> 00:14:01,920
while this convention is in place it's

00:13:59,680 --> 00:14:03,360
also important to enforce that a

00:14:01,920 --> 00:14:06,720
malicious vmm

00:14:03,360 --> 00:14:07,839
cannot modify the address translation

00:14:06,720 --> 00:14:09,920
structures

00:14:07,839 --> 00:14:11,519
or specifically the extended page table

00:14:09,920 --> 00:14:12,720
second level address translation

00:14:11,519 --> 00:14:15,360
structures

00:14:12,720 --> 00:14:16,880
such that the td may access incorrect

00:14:15,360 --> 00:14:18,720
data

00:14:16,880 --> 00:14:20,399
and the intel tdx module and the cpu

00:14:18,720 --> 00:14:23,360
both work in conjunction

00:14:20,399 --> 00:14:24,399
to mitigate this this attack

00:14:23,360 --> 00:14:28,560
specifically when

00:14:24,399 --> 00:14:31,760
td private gpas are being translated

00:14:28,560 --> 00:14:34,800
so td vms unlike a legacy vm have

00:14:31,760 --> 00:14:35,519
a second eptp or extended page table

00:14:34,800 --> 00:14:38,720
pointer

00:14:35,519 --> 00:14:40,880
called a secure ptp and that reference

00:14:38,720 --> 00:14:43,199
is a secure extended page table

00:14:40,880 --> 00:14:45,839
that will be used by the cpu when the td

00:14:43,199 --> 00:14:48,320
is accessing my private memory

00:14:45,839 --> 00:14:50,320
so private gpas all they always get walk

00:14:48,320 --> 00:14:52,240
through the secure extended page tables

00:14:50,320 --> 00:14:53,920
whereas shared gpa is expressed through

00:14:52,240 --> 00:14:56,880
the shared bit being one

00:14:53,920 --> 00:14:58,000
the gpa get translated through the

00:14:56,880 --> 00:15:00,560
shared dpd structure

00:14:58,000 --> 00:15:02,000
and that both of these walks are are

00:15:00,560 --> 00:15:03,600
same as legacy blocks

00:15:02,000 --> 00:15:05,600
however the security properties are

00:15:03,600 --> 00:15:09,040
enforced by the tdx module

00:15:05,600 --> 00:15:11,839
on the secure extended page table

00:15:09,040 --> 00:15:12,240
and the cpu further also enforces

00:15:11,839 --> 00:15:14,639
through

00:15:12,240 --> 00:15:16,480
appropriate tags in the tlb that any

00:15:14,639 --> 00:15:17,360
translations combined translations that

00:15:16,480 --> 00:15:19,839
are cached

00:15:17,360 --> 00:15:21,839
through the security pt are tagged as

00:15:19,839 --> 00:15:25,360
being derived from the security pt

00:15:21,839 --> 00:15:27,519
in the same non-node mode of operation

00:15:25,360 --> 00:15:29,519
an important point to note here that

00:15:27,519 --> 00:15:32,160
whenever the cpu

00:15:29,519 --> 00:15:34,240
is enforcing address translation for tds

00:15:32,160 --> 00:15:34,720
it enforces that code fetches from the

00:15:34,240 --> 00:15:37,360
td

00:15:34,720 --> 00:15:38,720
or any address translation always occurs

00:15:37,360 --> 00:15:41,600
in td private memory

00:15:38,720 --> 00:15:44,240
and if that's not the case then the cpu

00:15:41,600 --> 00:15:44,240
throws a fault

00:15:44,399 --> 00:15:48,160
now let's look at the next building

00:15:45,680 --> 00:15:50,240
block of physical memory management or

00:15:48,160 --> 00:15:52,240
specifically guest physical management

00:15:50,240 --> 00:15:55,759
and how the tdx module

00:15:52,240 --> 00:15:58,800
enforces that memory assigned to a td

00:15:55,759 --> 00:16:00,800
is is tracked appropriately

00:15:58,800 --> 00:16:01,920
so all the physical memory that a vmm

00:16:00,800 --> 00:16:03,759
may assign to a t

00:16:01,920 --> 00:16:05,440
is tracked by the tdx module through a

00:16:03,759 --> 00:16:08,000
data structure called a pamt

00:16:05,440 --> 00:16:09,360
or physical address metadata table and

00:16:08,000 --> 00:16:11,920
this structure

00:16:09,360 --> 00:16:12,560
is through which the tdx module enforces

00:16:11,920 --> 00:16:14,560
that

00:16:12,560 --> 00:16:16,720
a page can be owned by only a particular

00:16:14,560 --> 00:16:18,560
td and that it's in the right state

00:16:16,720 --> 00:16:20,720
based on the memory management operation

00:16:18,560 --> 00:16:22,399
being performed by the vmm

00:16:20,720 --> 00:16:25,600
this structure is simply a bookkeeping

00:16:22,399 --> 00:16:27,600
structure and is not walked by the cpu

00:16:25,600 --> 00:16:29,839
uh any properties that are booked keep

00:16:27,600 --> 00:16:31,839
through this book kept through this

00:16:29,839 --> 00:16:32,959
structure are enforced through the

00:16:31,839 --> 00:16:35,759
security pt

00:16:32,959 --> 00:16:36,399
mappings or the td private memory and

00:16:35,759 --> 00:16:38,480
thereby

00:16:36,399 --> 00:16:39,839
we ensure that there is no additional

00:16:38,480 --> 00:16:43,040
latency for

00:16:39,839 --> 00:16:45,839
a dd page walk

00:16:43,040 --> 00:16:46,639
while enforcing the security properties

00:16:45,839 --> 00:16:49,279
the vmm

00:16:46,639 --> 00:16:50,000
assigns memory for tds dynamically and

00:16:49,279 --> 00:16:52,560
that all comes

00:16:50,000 --> 00:16:53,199
through the through the vm and you know

00:16:52,560 --> 00:16:56,000
or

00:16:53,199 --> 00:16:58,160
managed memory through the through the

00:16:56,000 --> 00:17:02,480
scene called apis that the tdx module

00:16:58,160 --> 00:17:05,520
you know exposes and the tdx module

00:17:02,480 --> 00:17:08,400
use of this tgx module apis ensures

00:17:05,520 --> 00:17:09,919
that the td ephemeral key gets used to

00:17:08,400 --> 00:17:10,640
ensure the integrity of the zpt

00:17:09,919 --> 00:17:12,160
structures

00:17:10,640 --> 00:17:14,000
so that they cannot be tampered with

00:17:12,160 --> 00:17:14,559
while guest private memory has been

00:17:14,000 --> 00:17:17,600
assigned

00:17:14,559 --> 00:17:20,559
and mapped through these epd structures

00:17:17,600 --> 00:17:21,199
um because the pmt structure maintains

00:17:20,559 --> 00:17:23,280
information

00:17:21,199 --> 00:17:24,720
at one gigabyte two megabyte and four

00:17:23,280 --> 00:17:27,120
kilobyte levels

00:17:24,720 --> 00:17:28,799
um the td private memory can be mapped

00:17:27,120 --> 00:17:32,000
in any of these

00:17:28,799 --> 00:17:32,960
sizes um also the td prime may be

00:17:32,000 --> 00:17:36,000
reallocated

00:17:32,960 --> 00:17:36,799
uh or relocated by the vmm um to support

00:17:36,000 --> 00:17:38,799
various new

00:17:36,799 --> 00:17:42,000
new optimization strategies the vmware

00:17:38,799 --> 00:17:42,000
may already be used

00:17:44,480 --> 00:17:48,960
last but not the least let's talk about

00:17:46,720 --> 00:17:52,559
the building block for supporting of uh

00:17:48,960 --> 00:17:55,120
attestation so um as is clear

00:17:52,559 --> 00:17:56,080
for for most confidential computing use

00:17:55,120 --> 00:17:57,840
cases

00:17:56,080 --> 00:17:59,440
without the relying party being able to

00:17:57,840 --> 00:18:02,320
attest that a

00:17:59,440 --> 00:18:03,919
workload is running inside a td it's

00:18:02,320 --> 00:18:07,039
kind of pointless to

00:18:03,919 --> 00:18:09,600
do any confidential computing so

00:18:07,039 --> 00:18:11,120
we leverage the same attestation model

00:18:09,600 --> 00:18:14,720
and infrastructure that we have

00:18:11,120 --> 00:18:16,240
for intel sgx and and the this flow may

00:18:14,720 --> 00:18:18,880
be familiar to a lot of you

00:18:16,240 --> 00:18:20,160
but i'll just summarize it quickly here

00:18:18,880 --> 00:18:23,360
the process starts with

00:18:20,160 --> 00:18:25,760
a challenger requesting a td to prove

00:18:23,360 --> 00:18:27,679
its authenticity to prove that it's

00:18:25,760 --> 00:18:29,280
running as a valid td

00:18:27,679 --> 00:18:31,600
with the expected measurements on an

00:18:29,280 --> 00:18:34,400
authentic intel tdx platform

00:18:31,600 --> 00:18:35,600
and the pd can add at its own data as

00:18:34,400 --> 00:18:39,360
shown in step through to

00:18:35,600 --> 00:18:42,720
through a td call request a local report

00:18:39,360 --> 00:18:45,410
for um it's it's uh

00:18:42,720 --> 00:18:46,480
it's uh state the

00:18:45,410 --> 00:18:48,640
[Music]

00:18:46,480 --> 00:18:51,200
that that local request into the tdx

00:18:48,640 --> 00:18:54,480
module is translated by the td module

00:18:51,200 --> 00:18:56,320
into ac mobs uh invocation and the

00:18:54,480 --> 00:18:57,679
cmarks leaf used for this purpose is

00:18:56,320 --> 00:18:59,440
called seam report

00:18:57,679 --> 00:19:00,880
and that generates a locally mapped

00:18:59,440 --> 00:19:02,000
report which contains both the

00:19:00,880 --> 00:19:04,400
measurement of the

00:19:02,000 --> 00:19:06,240
tdx module as measurement due as

00:19:04,400 --> 00:19:06,960
measured during and recorded during load

00:19:06,240 --> 00:19:08,960
time

00:19:06,960 --> 00:19:11,360
and the measurement of the td that is

00:19:08,960 --> 00:19:13,520
managed by the tdx module

00:19:11,360 --> 00:19:15,039
that locally mapped report is then

00:19:13,520 --> 00:19:17,360
passed back to the td

00:19:15,039 --> 00:19:18,160
which in step 6 is shared with the with

00:19:17,360 --> 00:19:20,320
the vmm

00:19:18,160 --> 00:19:21,520
since this mac is this report is locally

00:19:20,320 --> 00:19:23,600
mapped it can be

00:19:21,520 --> 00:19:25,760
verified on the platform by a quoting

00:19:23,600 --> 00:19:27,919
enclave and convert it into a quote

00:19:25,760 --> 00:19:29,520
signed with the attestation key

00:19:27,919 --> 00:19:31,280
and that quote is then returned to the

00:19:29,520 --> 00:19:32,799
td and then made it may be returned to

00:19:31,280 --> 00:19:34,559
the to the challenger

00:19:32,799 --> 00:19:36,640
which can share it with uh with a

00:19:34,559 --> 00:19:37,679
relying party that can validate that the

00:19:36,640 --> 00:19:40,559
court is coming

00:19:37,679 --> 00:19:42,960
from a valid intel tdx platform with an

00:19:40,559 --> 00:19:44,799
expected intel tdx module version

00:19:42,960 --> 00:19:46,000
and the measurement of the td that it

00:19:44,799 --> 00:19:49,200
expects

00:19:46,000 --> 00:19:52,720
the black party can then proceed to to

00:19:49,200 --> 00:19:53,360
provision any secrets etc onto the onto

00:19:52,720 --> 00:19:57,200
the td

00:19:53,360 --> 00:19:57,200
and allow the workload to proceed

00:19:58,240 --> 00:20:01,360
so with that understanding of the base

00:20:00,320 --> 00:20:03,679
building block for

00:20:01,360 --> 00:20:05,600
intel tdx let's start looking through

00:20:03,679 --> 00:20:07,840
the the thread coverage based on the

00:20:05,600 --> 00:20:09,440
threat model we presented earlier

00:20:07,840 --> 00:20:10,720
for these different scenarios we will

00:20:09,440 --> 00:20:12,240
walk through the software adversary

00:20:10,720 --> 00:20:13,360
attacks the hardware adversary attacks

00:20:12,240 --> 00:20:15,600
and so on

00:20:13,360 --> 00:20:17,440
and in each of these cases we will note

00:20:15,600 --> 00:20:19,440
uh what we consider the

00:20:17,440 --> 00:20:21,840
the attacking entities to be for the

00:20:19,440 --> 00:20:23,840
software adversary attacks we consider

00:20:21,840 --> 00:20:25,039
the any of the csp software which

00:20:23,840 --> 00:20:27,039
includes the vmm

00:20:25,039 --> 00:20:28,720
any other colluding tds on the platform

00:20:27,039 --> 00:20:31,840
the system operator etc

00:20:28,720 --> 00:20:33,600
to be in the scope of the attackers

00:20:31,840 --> 00:20:35,520
and the first attack class we look at is

00:20:33,600 --> 00:20:36,000
where software attempts direct access to

00:20:35,520 --> 00:20:38,000
the

00:20:36,000 --> 00:20:40,240
td private memory whether to read the

00:20:38,000 --> 00:20:42,000
contents or to access the ciphertext or

00:20:40,240 --> 00:20:43,679
to inject content into it

00:20:42,000 --> 00:20:45,120
and that's mitigated through both the

00:20:43,679 --> 00:20:47,039
combination of the

00:20:45,120 --> 00:20:48,640
access control properties of the td100

00:20:47,039 --> 00:20:51,840
bit and also

00:20:48,640 --> 00:20:54,720
additionally the the ephemeral key based

00:20:51,840 --> 00:20:58,240
memory encryption and integrity

00:20:54,720 --> 00:20:59,760
the next attack vectors are secondary

00:20:58,240 --> 00:21:00,799
sort of attack vectors which is through

00:20:59,760 --> 00:21:03,919
row hammer

00:21:00,799 --> 00:21:06,960
or through using system a system address

00:21:03,919 --> 00:21:09,679
map aliases created by malicious bios

00:21:06,960 --> 00:21:11,039
and both of those are addressed uh

00:21:09,679 --> 00:21:11,919
basically through the memory integrity

00:21:11,039 --> 00:21:15,039
mechanisms

00:21:11,919 --> 00:21:16,960
but also for preventing the malicious

00:21:15,039 --> 00:21:18,159
aliases through an additional alias

00:21:16,960 --> 00:21:19,600
check enforcement

00:21:18,159 --> 00:21:22,559
authentication authenticated code

00:21:19,600 --> 00:21:22,559
modules from intel

00:21:23,280 --> 00:21:27,679
the next class of software attacks falls

00:21:25,280 --> 00:21:29,280
into the next these two buckets through

00:21:27,679 --> 00:21:30,960
the address translation attacks through

00:21:29,280 --> 00:21:32,960
software based

00:21:30,960 --> 00:21:34,559
ept remapping and that's addressed

00:21:32,960 --> 00:21:36,799
through the security pt architecture is

00:21:34,559 --> 00:21:38,240
right as well as any malicious

00:21:36,799 --> 00:21:40,000
interrupter exception

00:21:38,240 --> 00:21:42,559
injection by the vmm to essentially

00:21:40,000 --> 00:21:44,880
cause invalid execution inside the td

00:21:42,559 --> 00:21:45,600
and that's mitigated by the tdx module

00:21:44,880 --> 00:21:48,159
by

00:21:45,600 --> 00:21:49,520
ensuring that it protects the virtual

00:21:48,159 --> 00:21:52,320
epic page

00:21:49,520 --> 00:21:54,640
thereby mitigating any uh violation of

00:21:52,320 --> 00:21:57,840
dpr levels or virtual nmi

00:21:54,640 --> 00:21:59,679
blocking etc by the by the

00:21:57,840 --> 00:22:00,960
and also protecting obviously the td

00:21:59,679 --> 00:22:02,480
control structures

00:22:00,960 --> 00:22:04,320
through that same confidentiality and

00:22:02,480 --> 00:22:07,760
integrity protected memory

00:22:04,320 --> 00:22:09,760
further the cpus also enforces

00:22:07,760 --> 00:22:11,280
disallowing any external interrupts with

00:22:09,760 --> 00:22:13,679
vectors that are reserved for

00:22:11,280 --> 00:22:14,400
exceptions and that's a change over the

00:22:13,679 --> 00:22:17,360
previous

00:22:14,400 --> 00:22:17,360
vmx architecture

00:22:18,000 --> 00:22:21,919
the next area of thread coverage will

00:22:20,080 --> 00:22:24,159
cover hardware registry attacks

00:22:21,919 --> 00:22:25,280
and in this case we add to the attacker

00:22:24,159 --> 00:22:27,760
set the

00:22:25,280 --> 00:22:29,919
the ability for the vmm to induce

00:22:27,760 --> 00:22:32,559
devices to perform these attacks

00:22:29,919 --> 00:22:33,200
and we'll first look at the you know

00:22:32,559 --> 00:22:35,840
sort of

00:22:33,200 --> 00:22:37,280
dma attacks coming with uh with the use

00:22:35,840 --> 00:22:40,240
of these private key ids

00:22:37,280 --> 00:22:42,559
effectively the vmm using a dma dma from

00:22:40,240 --> 00:22:44,320
a device rogue device as a conduit

00:22:42,559 --> 00:22:46,240
and the mitigation in the platform is to

00:22:44,320 --> 00:22:48,559
essentially prevent those dma access

00:22:46,240 --> 00:22:51,679
that contain the private key ids in the

00:22:48,559 --> 00:22:51,679
host physical addresses

00:22:51,919 --> 00:22:56,799
the next set of online hardware attacks

00:22:53,840 --> 00:22:57,840
are the bmm trying to use the devices to

00:22:56,799 --> 00:23:01,200
either inject uh

00:22:57,840 --> 00:23:03,600
data or move the data from uh from one

00:23:01,200 --> 00:23:05,120
location to the other across tds and

00:23:03,600 --> 00:23:07,679
that's mitigated through the

00:23:05,120 --> 00:23:08,880
uh fml key based memory encryption and

00:23:07,679 --> 00:23:11,280
integrity model

00:23:08,880 --> 00:23:12,480
however any replay of memory hardware

00:23:11,280 --> 00:23:14,640
replay of memory

00:23:12,480 --> 00:23:16,000
that targets the same physical address

00:23:14,640 --> 00:23:17,520
for a specific td

00:23:16,000 --> 00:23:20,000
is not protected against in the current

00:23:17,520 --> 00:23:20,000
generation

00:23:20,640 --> 00:23:24,400
finally looking at some of the offline

00:23:22,320 --> 00:23:27,039
dram attack

00:23:24,400 --> 00:23:27,600
methods those are basically mitigated by

00:23:27,039 --> 00:23:29,840
the

00:23:27,600 --> 00:23:32,159
memory encryption using the tdf femoral

00:23:29,840 --> 00:23:32,159
keys

00:23:33,200 --> 00:23:36,799
let's look at the next class of attack

00:23:34,720 --> 00:23:37,919
which is attacks on the attestation

00:23:36,799 --> 00:23:40,880
infrastructure

00:23:37,919 --> 00:23:43,520
or the tdx module itself for example by

00:23:40,880 --> 00:23:46,640
rolling back the tdx module to a prior

00:23:43,520 --> 00:23:50,080
version which which may be uh you know

00:23:46,640 --> 00:23:52,000
which may have you know a vulnerability

00:23:50,080 --> 00:23:53,200
that's mitigated essentially by ensuring

00:23:52,000 --> 00:23:56,000
that the same acm

00:23:53,200 --> 00:23:57,200
the same loader ecm will prevent such

00:23:56,000 --> 00:23:59,120
such downgrades

00:23:57,200 --> 00:24:00,320
because because of verifying

00:23:59,120 --> 00:24:02,400
verification of the

00:24:00,320 --> 00:24:03,360
security version number of the intel tx

00:24:02,400 --> 00:24:05,600
module

00:24:03,360 --> 00:24:06,720
further the relying party that verifies

00:24:05,600 --> 00:24:09,520
the attestation

00:24:06,720 --> 00:24:10,240
can also use that mechanism to verify

00:24:09,520 --> 00:24:12,880
that

00:24:10,240 --> 00:24:15,360
the correct tdx module is in use by the

00:24:12,880 --> 00:24:17,600
by the platform

00:24:15,360 --> 00:24:20,559
in in the other attack case where a

00:24:17,600 --> 00:24:22,559
tampered tdx module is loaded by the vmm

00:24:20,559 --> 00:24:24,400
it's also addressed partially by the the

00:24:22,559 --> 00:24:26,000
seam loader

00:24:24,400 --> 00:24:28,000
acm verifying the integrity of the

00:24:26,000 --> 00:24:29,919
module at launch time

00:24:28,000 --> 00:24:32,159
and recording those measurements through

00:24:29,919 --> 00:24:33,600
the cpu svn

00:24:32,159 --> 00:24:35,760
but it's also important to ensure the

00:24:33,600 --> 00:24:38,640
runtime integrity of that module

00:24:35,760 --> 00:24:40,400
and that is enforced by the by the cpu

00:24:38,640 --> 00:24:41,120
for in terms of software access control

00:24:40,400 --> 00:24:43,440
using the

00:24:41,120 --> 00:24:46,240
range register the same range register

00:24:43,440 --> 00:24:48,400
and also from hardware attacks

00:24:46,240 --> 00:24:52,000
as i described in the previous flight

00:24:48,400 --> 00:24:52,000
through the memory integrity mechanisms

00:24:53,600 --> 00:24:57,679
last but not the least we also have to

00:24:55,279 --> 00:24:59,840
consider since we are considering the

00:24:57,679 --> 00:25:01,120
system software that's outside the tcp

00:24:59,840 --> 00:25:02,480
we also have to consider

00:25:01,120 --> 00:25:04,240
side channel attacks that may be

00:25:02,480 --> 00:25:05,679
attempted um

00:25:04,240 --> 00:25:07,279
and we look at these different classes

00:25:05,679 --> 00:25:09,360
the first one is the

00:25:07,279 --> 00:25:10,480
poisoning of the branch prediction units

00:25:09,360 --> 00:25:13,520
to to extract

00:25:10,480 --> 00:25:14,240
uh you know site channel information

00:25:13,520 --> 00:25:16,159
through the

00:25:14,240 --> 00:25:17,520
through the cache and that is

00:25:16,159 --> 00:25:18,400
essentially prevented through the

00:25:17,520 --> 00:25:20,480
mechanisms

00:25:18,400 --> 00:25:23,039
we have already talked about such as

00:25:20,480 --> 00:25:25,360
using ibp and ibrs

00:25:23,039 --> 00:25:27,039
or branch prediction barrier methods

00:25:25,360 --> 00:25:28,240
that are enforced by the tdx module

00:25:27,039 --> 00:25:30,880
during the same call

00:25:28,240 --> 00:25:32,000
scene right transitions further the tdx

00:25:30,880 --> 00:25:34,559
module also

00:25:32,000 --> 00:25:35,679
enforces the the isolation of the spec

00:25:34,559 --> 00:25:38,960
control msr

00:25:35,679 --> 00:25:39,919
for tds to ensure the the the selected

00:25:38,960 --> 00:25:43,279
properties through the

00:25:39,919 --> 00:25:47,120
through that msr are enforced

00:25:43,279 --> 00:25:48,720
the next you know capabilities that can

00:25:47,120 --> 00:25:49,440
potentially be used as side channels are

00:25:48,720 --> 00:25:51,360
performed

00:25:49,440 --> 00:25:53,360
for performance monitoring and debug

00:25:51,360 --> 00:25:54,720
right both of these capabilities are

00:25:53,360 --> 00:25:57,039
optionally available to the

00:25:54,720 --> 00:25:58,080
to the tds that that used to turn on

00:25:57,039 --> 00:26:00,720
puff pawn and

00:25:58,080 --> 00:26:01,600
debug and if those capabilities are

00:26:00,720 --> 00:26:03,679
enabled

00:26:01,600 --> 00:26:05,360
um then the appropriate perfmon

00:26:03,679 --> 00:26:06,559
information and debug information is

00:26:05,360 --> 00:26:10,320
isolated by the

00:26:06,559 --> 00:26:12,480
tdx module for the for the td

00:26:10,320 --> 00:26:13,440
further the information that the fact

00:26:12,480 --> 00:26:15,760
that the td has

00:26:13,440 --> 00:26:16,720
opted in to debug and perfmon is

00:26:15,760 --> 00:26:18,880
reported through the

00:26:16,720 --> 00:26:20,559
through the td attestation mechanisms so

00:26:18,880 --> 00:26:21,440
that it can cannot be maliciously

00:26:20,559 --> 00:26:25,360
enabled by

00:26:21,440 --> 00:26:26,960
untrusted software

00:26:25,360 --> 00:26:28,240
the last couple of side channels are ev

00:26:26,960 --> 00:26:30,960
default information that may be

00:26:28,240 --> 00:26:33,600
extracted as a td is initializing

00:26:30,960 --> 00:26:35,440
as well as you know broad cache based

00:26:33,600 --> 00:26:36,960
side channel attacks like prime probe

00:26:35,440 --> 00:26:39,840
and those are not mitigated in the

00:26:36,960 --> 00:26:39,840
current generation

00:26:40,159 --> 00:26:44,240
so with that i'll pause here and hand it

00:26:42,320 --> 00:26:46,640
over to my colleague jun nakajima

00:26:44,240 --> 00:26:48,080
who will walk through a summary of the

00:26:46,640 --> 00:26:50,080
architectural building blocks

00:26:48,080 --> 00:26:51,760
and continue discussing the software

00:26:50,080 --> 00:26:54,559
touch points for intel tdx

00:26:51,760 --> 00:26:54,559
thank you for listening

00:26:55,200 --> 00:26:59,600
thank you ravi now we're going to talk

00:26:57,679 --> 00:27:04,159
about software

00:26:59,600 --> 00:27:07,919
therefore required to enable tdx

00:27:04,159 --> 00:27:11,360
before jumping to the details

00:27:07,919 --> 00:27:13,919
i'd have to recap what lobby shared

00:27:11,360 --> 00:27:13,919
so far

00:27:18,799 --> 00:27:27,360
if you look at the

00:27:22,159 --> 00:27:30,880
data structures shared in the

00:27:27,360 --> 00:27:34,480
if you look at data structures here

00:27:30,880 --> 00:27:37,760
for example the cpu state

00:27:34,480 --> 00:27:41,360
virtual epic page or sql extended page

00:27:37,760 --> 00:27:44,559
table and then various vm

00:27:41,360 --> 00:27:48,080
control structures they are

00:27:44,559 --> 00:27:52,159
maintained in applied by memory

00:27:48,080 --> 00:27:55,039
which is protected by the cpu

00:27:52,159 --> 00:27:56,799
and invisible to known td system

00:27:55,039 --> 00:27:59,279
software including the bmm

00:27:56,799 --> 00:27:59,279
itself

00:28:00,159 --> 00:28:08,240
and if you look at the td

00:28:04,640 --> 00:28:12,240
the memory itself is

00:28:08,240 --> 00:28:12,240
in the private memory and

00:28:12,399 --> 00:28:19,360
how do i use is the access control

00:28:15,600 --> 00:28:24,159
such as td owner bit and then also

00:28:19,360 --> 00:28:24,159
power td private key to mitigate

00:28:24,960 --> 00:28:31,840
bmm tags from modifying observing

00:28:28,640 --> 00:28:32,240
the tenant's memory whether in a cache

00:28:31,840 --> 00:28:35,200
or

00:28:32,240 --> 00:28:35,200
in ddr

00:28:36,399 --> 00:28:44,080
okay let's take a look at

00:28:40,559 --> 00:28:47,600
software implications or software

00:28:44,080 --> 00:28:51,600
effort or touchpoint

00:28:47,600 --> 00:28:54,720
for intel tdx first of all

00:28:51,600 --> 00:28:58,159
the td td starts from a guest

00:28:54,720 --> 00:29:01,520
formula we call tdvf

00:28:58,159 --> 00:29:05,039
just a td virtual firmware

00:29:01,520 --> 00:29:08,559
it needs to accommodate

00:29:05,039 --> 00:29:11,600
private shell memory and then

00:29:08,559 --> 00:29:14,399
also need to enumerate the td

00:29:11,600 --> 00:29:18,840
capabilities

00:29:14,399 --> 00:29:22,720
and then we simplify the implemented

00:29:18,840 --> 00:29:27,840
initialization of the cpu unit

00:29:22,720 --> 00:29:27,840
building so

00:29:28,320 --> 00:29:34,960
those changes are required in uh

00:29:31,760 --> 00:29:38,320
gaster formula also uh the

00:29:34,960 --> 00:29:41,919
tda the gas os it's uh

00:29:38,320 --> 00:29:43,520
kernel mostly all are in the coronal

00:29:41,919 --> 00:29:46,799
areas

00:29:43,520 --> 00:29:49,919
this has to be it's a virtual

00:29:46,799 --> 00:29:53,440
exception that

00:29:49,919 --> 00:29:57,360
exception handler will be generated

00:29:53,440 --> 00:29:57,360
by the hardware and then

00:29:57,440 --> 00:30:04,159
for various cases for example

00:30:01,120 --> 00:30:07,520
handle instructions that are not

00:30:04,159 --> 00:30:11,120
supported in the td and that would be

00:30:07,520 --> 00:30:14,679
that would generate has to be

00:30:11,120 --> 00:30:17,760
also the os itself need to

00:30:14,679 --> 00:30:22,159
explicitly tell

00:30:17,760 --> 00:30:23,120
about the shared memory by default all

00:30:22,159 --> 00:30:26,880
memory

00:30:23,120 --> 00:30:30,480
is the entire memory is

00:30:26,880 --> 00:30:34,559
private memory okay

00:30:30,480 --> 00:30:40,080
also since the primary memory

00:30:34,559 --> 00:30:40,080
cannot be accessed by the host bmm

00:30:40,159 --> 00:30:47,679
the td guest needs to use

00:30:43,840 --> 00:30:51,279
bounce buffer for data movement

00:30:47,679 --> 00:30:54,399
for example that the vf

00:30:51,279 --> 00:30:59,600
sorry the bmm

00:30:54,399 --> 00:31:03,360
needs to copy the data or read the data

00:30:59,600 --> 00:31:06,880
to the shared memory first

00:31:03,360 --> 00:31:09,840
then the guest what td

00:31:06,880 --> 00:31:10,559
needs to copy from share to the private

00:31:09,840 --> 00:31:14,159
memory

00:31:10,559 --> 00:31:20,159
okay to that end uh

00:31:14,159 --> 00:31:20,159
we need a dma api changes in the td

00:31:20,480 --> 00:31:25,760
so there are many touch points in the

00:31:23,200 --> 00:31:25,760
bmm

00:31:26,000 --> 00:31:30,320
the bmm needs to use tdx module

00:31:29,039 --> 00:31:34,000
interface or api

00:31:30,320 --> 00:31:37,360
to manage the td life cycle

00:31:34,000 --> 00:31:41,360
for example assigning key ids

00:31:37,360 --> 00:31:46,000
allocating and control use setting

00:31:41,360 --> 00:31:50,320
control structure and also

00:31:46,000 --> 00:31:54,000
setting up the secure apt and then

00:31:50,320 --> 00:31:55,919
modifying uh secure ebt entries

00:31:54,000 --> 00:31:59,120
and then if you look at the bootloader

00:31:55,919 --> 00:32:02,720
on the platform below the bios

00:31:59,120 --> 00:32:05,760
it needs to enable mktmi and then

00:32:02,720 --> 00:32:09,440
partition the key id space between

00:32:05,760 --> 00:32:11,840
mktme and in the tdx and need to load m

00:32:09,440 --> 00:32:15,120
check and simulator

00:32:11,840 --> 00:32:17,039
now take a look at a software deployment

00:32:15,120 --> 00:32:20,159
auto

00:32:17,039 --> 00:32:23,679
although td memory is encrypted

00:32:20,159 --> 00:32:27,840
so it's kind of special

00:32:23,679 --> 00:32:28,880
we can use td for our existing models

00:32:27,840 --> 00:32:31,679
without

00:32:28,880 --> 00:32:32,960
modifying the upper layers like

00:32:31,679 --> 00:32:36,720
applications

00:32:32,960 --> 00:32:40,159
as long as we have td enlightenment

00:32:36,720 --> 00:32:44,000
basically enhancement or modification

00:32:40,159 --> 00:32:46,240
in support of the tdx in the os

00:32:44,000 --> 00:32:47,679
in the os especially in the again the

00:32:46,240 --> 00:32:51,440
kernel

00:32:47,679 --> 00:32:55,120
for example this is a the typical

00:32:51,440 --> 00:32:58,640
most kind of conventional case basically

00:32:55,120 --> 00:33:03,360
you have a full operating system and

00:32:58,640 --> 00:33:03,360
land operating system within a td

00:33:03,919 --> 00:33:10,399
or container a container in

00:33:07,120 --> 00:33:13,840
operating system and if you have

00:33:10,399 --> 00:33:18,080
a guest os with

00:33:13,840 --> 00:33:21,440
td enlightenment then you can run that

00:33:18,080 --> 00:33:24,799
unmodified container

00:33:21,440 --> 00:33:28,080
inside a td

00:33:24,799 --> 00:33:28,080
or even smaller ones

00:33:30,960 --> 00:33:33,840
and in the future

00:33:35,679 --> 00:33:39,760
we may be able to support a modified

00:33:38,720 --> 00:33:43,039
legacy os

00:33:39,760 --> 00:33:48,640
and more io interactions

00:33:43,039 --> 00:33:48,640
okay now sitting gear to the kbm

00:33:49,279 --> 00:33:56,320
our but if we mention

00:33:52,880 --> 00:33:58,720
the key beam touch point

00:33:56,320 --> 00:34:00,159
uh this will give a good you know more

00:33:58,720 --> 00:34:04,240
specific example

00:34:00,159 --> 00:34:07,679
what we need to do so

00:34:04,240 --> 00:34:12,639
starting from our td initialization

00:34:07,679 --> 00:34:15,760
on the host at the bsb

00:34:12,639 --> 00:34:19,280
we launched sim loader acm

00:34:15,760 --> 00:34:23,359
module and then

00:34:19,280 --> 00:34:23,599
at the boot time uh configure tdx module

00:34:23,359 --> 00:34:27,520
on

00:34:23,599 --> 00:34:27,520
all cpus okay

00:34:27,599 --> 00:34:34,639
and then the kvm corporate one thing

00:34:31,280 --> 00:34:38,800
we need to do is tdx

00:34:34,639 --> 00:34:42,079
and bmx coexistence that's

00:34:38,800 --> 00:34:45,919
uh a bit complex but

00:34:42,079 --> 00:34:46,240
i think we can achieve that also we need

00:34:45,919 --> 00:34:49,599
a

00:34:46,240 --> 00:34:53,280
some modification

00:34:49,599 --> 00:34:56,320
to the vmx to support

00:34:53,280 --> 00:34:56,320
interrupt handling

00:34:56,560 --> 00:35:05,359
and like i said before

00:35:01,760 --> 00:35:09,839
the ttx requires the vmm

00:35:05,359 --> 00:35:13,280
to use tdx module api for various

00:35:09,839 --> 00:35:17,839
operations so we need to add

00:35:13,280 --> 00:35:17,839
the code to use tdx module api

00:35:18,640 --> 00:35:25,920
and when we're doing so we want to

00:35:22,320 --> 00:35:29,280
reuse existing md sebs

00:35:25,920 --> 00:35:34,240
io control code as much as possible

00:35:29,280 --> 00:35:37,200
okay on the mme side

00:35:34,240 --> 00:35:38,000
we need to add shield or the platinum

00:35:37,200 --> 00:35:41,359
memory

00:35:38,000 --> 00:35:47,040
handling also

00:35:41,359 --> 00:35:47,040
it's good to map guest private memory

00:35:47,440 --> 00:35:56,720
from the kernel or the user space vmm

00:35:52,960 --> 00:36:00,000
because if the kernel or user memory

00:35:56,720 --> 00:36:03,839
user user vmm

00:36:00,000 --> 00:36:07,200
accidentally modifies the guest memory

00:36:03,839 --> 00:36:09,920
that can be captured by the

00:36:07,200 --> 00:36:11,119
integrity detection and that can cause

00:36:09,920 --> 00:36:14,320
machine check

00:36:11,119 --> 00:36:17,440
we have more on the mmu side on the

00:36:14,320 --> 00:36:21,359
so we added the secure ept

00:36:17,440 --> 00:36:24,560
and like i said uh

00:36:21,359 --> 00:36:28,240
secure apd itself the page table

00:36:24,560 --> 00:36:32,000
will be in private memory and

00:36:28,240 --> 00:36:35,920
the bmm cannot modify the bmm

00:36:32,000 --> 00:36:39,520
the epd entries directly and

00:36:35,920 --> 00:36:42,560
for that kind of case the wmm

00:36:39,520 --> 00:36:44,079
needs to use the sim call sim api to

00:36:42,560 --> 00:36:46,560
modify the

00:36:44,079 --> 00:36:46,560
entries

00:36:47,119 --> 00:36:54,960
and also the it needs to evm needs to

00:36:51,440 --> 00:36:58,160
set up the ept page table

00:36:54,960 --> 00:37:02,160
to generate the hash be

00:36:58,160 --> 00:37:05,920
especially to support mmio

00:37:02,160 --> 00:37:09,119
and mmio upon mnio

00:37:05,920 --> 00:37:12,560
the emulated mmo in gas

00:37:09,119 --> 00:37:16,160
that would generate rcpe in the guest

00:37:12,560 --> 00:37:16,960
and then the guests need to handle the

00:37:16,160 --> 00:37:22,320
hashtag

00:37:16,960 --> 00:37:25,760
mmio from there okay

00:37:22,320 --> 00:37:25,760
and then the prime memory

00:37:26,320 --> 00:37:33,040
management there are various

00:37:30,000 --> 00:37:35,839
uh data structures need to be

00:37:33,040 --> 00:37:37,119
allocated in applied memory and then and

00:37:35,839 --> 00:37:40,240
the primary memory

00:37:37,119 --> 00:37:43,680
must reside in a trusted domain memory

00:37:40,240 --> 00:37:43,680
region tdmr

00:37:47,040 --> 00:37:53,760
we have more details of the kbm forum

00:37:51,040 --> 00:37:55,280
friday tomorrow and then she'll be

00:37:53,760 --> 00:38:00,400
presenting uh

00:37:55,280 --> 00:38:00,400
tdx enabling for kbr kvm okay

00:38:01,200 --> 00:38:08,720
now switching gears to

00:38:05,119 --> 00:38:11,760
uh the guest linux guests

00:38:08,720 --> 00:38:14,160
starting from uh actually

00:38:11,760 --> 00:38:14,800
guest bios guest bios is not a part of

00:38:14,160 --> 00:38:18,800
linux

00:38:14,800 --> 00:38:21,839
but uh that that you know we need to

00:38:18,800 --> 00:38:26,640
add the td support to the guest formula

00:38:21,839 --> 00:38:30,000
or tdvf right and

00:38:26,640 --> 00:38:33,520
the sub the changes required

00:38:30,000 --> 00:38:36,560
there will be basically some set of

00:38:33,520 --> 00:38:39,760
changes required for the td linux

00:38:36,560 --> 00:38:42,960
below but one

00:38:39,760 --> 00:38:46,000
important role of the against bios

00:38:42,960 --> 00:38:49,280
is measurement and station of

00:38:46,000 --> 00:38:51,520
the linux or the gas itself

00:38:49,280 --> 00:38:51,520
okay

00:38:52,320 --> 00:38:56,240
i don't cover that the measurement and

00:38:54,480 --> 00:38:58,880
attestation and here

00:38:56,240 --> 00:39:02,240
the details but i'll basically talk

00:38:58,880 --> 00:39:05,280
about the linux switch to the linux

00:39:02,240 --> 00:39:08,640
and then linux side we

00:39:05,280 --> 00:39:11,920
simplify the booting and initials

00:39:08,640 --> 00:39:12,880
in its state is different in a td so we

00:39:11,920 --> 00:39:15,599
need a

00:39:12,880 --> 00:39:16,400
modification to support that thing and

00:39:15,599 --> 00:39:19,760
then

00:39:16,400 --> 00:39:22,880
also td can get

00:39:19,760 --> 00:39:26,000
a td execution environment

00:39:22,880 --> 00:39:29,599
from tdx module

00:39:26,000 --> 00:39:32,880
so the t uh linux needs to

00:39:29,599 --> 00:39:35,760
have some changes to accommodate such

00:39:32,880 --> 00:39:35,760
modifications

00:39:36,079 --> 00:39:44,240
more importantly the linux needs

00:39:39,839 --> 00:39:47,280
some td specific

00:39:44,240 --> 00:39:50,960
modifications we call tdx

00:39:47,280 --> 00:39:53,680
enlightenment basically the linux needs

00:39:50,960 --> 00:39:53,680
to know

00:39:54,079 --> 00:40:02,560
whether it's running in a tv or not

00:39:58,160 --> 00:40:06,960
and if it's running a td it needs to

00:40:02,560 --> 00:40:06,960
take a different code pass

00:40:07,440 --> 00:40:13,839
for that we encourage

00:40:10,560 --> 00:40:17,359
to use ghci and it

00:40:13,839 --> 00:40:21,520
we propose as a spec uh cover

00:40:17,359 --> 00:40:23,520
talk a bit more on the next page so dhci

00:40:21,520 --> 00:40:24,640
is against the hypervisor communication

00:40:23,520 --> 00:40:27,760
interface

00:40:24,640 --> 00:40:30,640
and it covers the

00:40:27,760 --> 00:40:31,599
changes for building because of tdx

00:40:30,640 --> 00:40:37,040
support

00:40:31,599 --> 00:40:40,640
and tdx enlightenment guest and then

00:40:37,040 --> 00:40:44,800
defines the api or services

00:40:40,640 --> 00:40:48,000
uh from the bmm as an api

00:40:44,800 --> 00:40:48,560
we have a working group the jcl working

00:40:48,000 --> 00:40:51,680
group

00:40:48,560 --> 00:40:53,520
uh it's the goal here is that ensure the

00:40:51,680 --> 00:40:57,520
kernel

00:40:53,520 --> 00:41:00,560
uh linux kernel is being built into the

00:40:57,520 --> 00:41:04,400
single linux td binary that

00:41:00,560 --> 00:41:05,920
cam boots and operate in a major

00:41:04,400 --> 00:41:10,079
operating system i

00:41:05,920 --> 00:41:10,079
measure bmms today okay

00:41:10,800 --> 00:41:18,000
and current interface

00:41:14,079 --> 00:41:21,040
in a ghcr and an implementation

00:41:18,000 --> 00:41:24,319
consistent implementation across

00:41:21,040 --> 00:41:27,839
the vms the key to achieve the goal

00:41:24,319 --> 00:41:31,520
okay now you're almost there

00:41:27,839 --> 00:41:34,880
this is probably the final page

00:41:31,520 --> 00:41:38,400
and i just want to recap

00:41:34,880 --> 00:41:41,440
what we presented so far today

00:41:38,400 --> 00:41:45,520
this is a hardware we have also

00:41:41,440 --> 00:41:45,520
fermio then

00:41:46,240 --> 00:41:53,119
fermia does m check basically m check

00:41:49,440 --> 00:41:56,400
and then load bootleg bootloader

00:41:53,119 --> 00:41:59,599
loads the sim loader as acm

00:41:56,400 --> 00:42:03,200
then eventually bmm

00:41:59,599 --> 00:42:06,800
comes up and it can run the legacy

00:42:03,200 --> 00:42:11,359
vms and the rcbms is a bmx

00:42:06,800 --> 00:42:15,760
vm enter now for td

00:42:11,359 --> 00:42:20,240
we need a tdx module and

00:42:15,760 --> 00:42:25,359
uses new instruction theme called simrad

00:42:20,240 --> 00:42:29,119
then to create a td

00:42:25,359 --> 00:42:32,160
we need a private memory mapped by

00:42:29,119 --> 00:42:35,839
tdmr protected by tdmr

00:42:32,160 --> 00:42:39,200
and we need to create td

00:42:35,839 --> 00:42:44,319
related data structures like scpt

00:42:39,200 --> 00:42:45,839
or tdcs and also td memory cell in the

00:42:44,319 --> 00:42:50,160
private memory

00:42:45,839 --> 00:42:53,599
okay now we can create more tds

00:42:50,160 --> 00:42:54,240
or again those will be uh the key data

00:42:53,599 --> 00:42:58,160
structure

00:42:54,240 --> 00:43:01,440
need to be in the prime memory

00:42:58,160 --> 00:43:04,800
and whenever

00:43:01,440 --> 00:43:08,000
the bmn needs operation against

00:43:04,800 --> 00:43:10,240
the td deleted data structure it needs

00:43:08,000 --> 00:43:14,319
to use the same call

00:43:10,240 --> 00:43:17,440
basically api okay

00:43:14,319 --> 00:43:21,839
we also talked about the tdx

00:43:17,440 --> 00:43:25,440
ghci guest hypervisor communication api

00:43:21,839 --> 00:43:28,400
okay and finally

00:43:25,440 --> 00:43:33,359
we didn't cover this one but we have a

00:43:28,400 --> 00:43:33,359
iso leaves for attestation pop-ups

00:43:34,400 --> 00:43:38,640
thanks john so in summary we are

00:43:37,040 --> 00:43:40,160
developing intel tdx to scale

00:43:38,640 --> 00:43:41,359
confidential computing capabilities for

00:43:40,160 --> 00:43:43,440
the cloud

00:43:41,359 --> 00:43:44,400
while we try to reduce developer

00:43:43,440 --> 00:43:47,440
friction

00:43:44,400 --> 00:43:49,040
um due to recompile refactoring etc

00:43:47,440 --> 00:43:50,880
and we really look forward to continue

00:43:49,040 --> 00:43:52,400
working with this community

00:43:50,880 --> 00:43:54,560
and appreciate all the feedback that

00:43:52,400 --> 00:43:56,720
we've already started getting

00:43:54,560 --> 00:43:57,760
the links at the bottom are the

00:43:56,720 --> 00:44:01,359
references to the

00:43:57,760 --> 00:44:04,480
documentation for intel tdx as well as

00:44:01,359 --> 00:44:07,200
the the source trees for

00:44:04,480 --> 00:44:08,960
the kvm changes and the linux guest

00:44:07,200 --> 00:44:11,040
changes that we're proposing

00:44:08,960 --> 00:44:18,960
thanks for listening again and talk to

00:44:11,040 --> 00:44:18,960

YouTube URL: https://www.youtube.com/watch?v=xOONwt3E8lk


