Title: State of the User Namespace - Stephane Graber & Christian Brauner, Canonical
Publication date: 2020-11-12
Playlist: Linux Security Summit Europe 2020
Description: 
	State of the User Namespace - Stephane Graber & Christian Brauner, Canonical
Captions: 
	00:00:08,400 --> 00:00:12,719
hello

00:00:10,639 --> 00:00:13,759
i'm stefan grabber i've got uh christian

00:00:12,719 --> 00:00:16,480
branagh here

00:00:13,759 --> 00:00:17,440
and today we're gonna be going over the

00:00:16,480 --> 00:00:20,240
state of the

00:00:17,440 --> 00:00:21,199
username space we both work at uh at

00:00:20,240 --> 00:00:24,320
canonical

00:00:21,199 --> 00:00:25,119
and we are the project leaders for lexi

00:00:24,320 --> 00:00:27,119
and lexi

00:00:25,119 --> 00:00:29,439
um continental managers and christian

00:00:27,119 --> 00:00:33,119
also works on the variety of

00:00:29,439 --> 00:00:33,119
canon components

00:00:36,000 --> 00:00:42,399
okay username spaces and

00:00:39,120 --> 00:00:45,120
container security this is a quick recap

00:00:42,399 --> 00:00:46,160
and how and why we think this is

00:00:45,120 --> 00:00:48,879
relevant

00:00:46,160 --> 00:00:50,719
um container security heavily depends on

00:00:48,879 --> 00:00:53,520
the user name space

00:00:50,719 --> 00:00:55,840
and it's still a component in container

00:00:53,520 --> 00:00:58,239
security in the container security area

00:00:55,840 --> 00:01:00,399
that is seems to be misunderstood

00:00:58,239 --> 00:01:02,239
sometimes hard to use

00:01:00,399 --> 00:01:04,159
we develop as the found mentioned a

00:01:02,239 --> 00:01:06,640
system container manager which

00:01:04,159 --> 00:01:09,360
runs unmodified linux distributions with

00:01:06,640 --> 00:01:11,920
the similar workflow to virtual machines

00:01:09,360 --> 00:01:13,600
but just on a shared kernel and we over

00:01:11,920 --> 00:01:15,360
the years we did a lot of work to

00:01:13,600 --> 00:01:17,600
properly use user name spaces

00:01:15,360 --> 00:01:19,840
lsmc groups and other security measures

00:01:17,600 --> 00:01:22,479
to prevent

00:01:19,840 --> 00:01:22,960
container escapes and other issues and

00:01:22,479 --> 00:01:24,880
we're

00:01:22,960 --> 00:01:26,320
working hard in the kernel and user

00:01:24,880 --> 00:01:28,479
space to make

00:01:26,320 --> 00:01:30,159
just about every normal system run

00:01:28,479 --> 00:01:32,720
properly and privileged

00:01:30,159 --> 00:01:33,840
containers and one of our main goals is

00:01:32,720 --> 00:01:36,880
to keep our

00:01:33,840 --> 00:01:40,159
users as safe as possible and

00:01:36,880 --> 00:01:43,360
the username space is a core

00:01:40,159 --> 00:01:43,360
component in this story

00:01:44,240 --> 00:01:50,479
so there are two types of containers

00:01:47,759 --> 00:01:52,000
and only one uses a username space the

00:01:50,479 --> 00:01:54,720
first type of container is

00:01:52,000 --> 00:01:56,159
a privileged container this just means

00:01:54,720 --> 00:01:59,439
that the container uid

00:01:56,159 --> 00:02:00,240
is identical to the host uid which means

00:01:59,439 --> 00:02:02,320
real root

00:02:00,240 --> 00:02:04,000
uh root in the container equals real

00:02:02,320 --> 00:02:06,240
root on the host

00:02:04,000 --> 00:02:08,000
so that also means container breakouts

00:02:06,240 --> 00:02:11,120
are extremely serious

00:02:08,000 --> 00:02:12,959
in these scenarios but unfortunately it

00:02:11,120 --> 00:02:14,959
is still the industry standard

00:02:12,959 --> 00:02:18,160
as most workloads use privileged

00:02:14,959 --> 00:02:19,840
containers which is unfortunate

00:02:18,160 --> 00:02:21,840
and the security of privileged

00:02:19,840 --> 00:02:24,080
containers mostly hinges on lsm's

00:02:21,840 --> 00:02:25,760
capabilities and second

00:02:24,080 --> 00:02:29,440
coverage so privilege are not really

00:02:25,760 --> 00:02:32,080
isolated enough or even at all

00:02:29,440 --> 00:02:33,440
and this is this can be this can be a

00:02:32,080 --> 00:02:35,519
big issue and our

00:02:33,440 --> 00:02:37,680
personal sense is that privileged

00:02:35,519 --> 00:02:40,319
containers aren't and cannot be

00:02:37,680 --> 00:02:40,319
root safe

00:02:42,959 --> 00:02:47,680
as you can see privileged containers

00:02:45,760 --> 00:02:49,519
cause a majority of the cdas

00:02:47,680 --> 00:02:51,599
that's this is not just a statement that

00:02:49,519 --> 00:02:54,400
we that we tend to make

00:02:51,599 --> 00:02:55,200
uh lightly these are also not the cvs

00:02:54,400 --> 00:02:57,440
from the single

00:02:55,200 --> 00:02:59,920
uh runtime these are just the cvs from a

00:02:57,440 --> 00:03:02,720
single runtime

00:02:59,920 --> 00:03:03,680
lexi doesn't even show uh doesn't even

00:03:02,720 --> 00:03:07,120
accept

00:03:03,680 --> 00:03:10,800
cpes for privileged containers um

00:03:07,120 --> 00:03:13,440
and uh this is as you can see this is

00:03:10,800 --> 00:03:17,040
pretty bad most of them score at 9.3

00:03:13,440 --> 00:03:20,480
7.2 um and so this is not

00:03:17,040 --> 00:03:21,360
this is not a great state and privileged

00:03:20,480 --> 00:03:25,200
containers

00:03:21,360 --> 00:03:25,200
therefore shouldn't be used

00:03:28,319 --> 00:03:32,319
so unpublished containers these are

00:03:30,640 --> 00:03:32,959
reactive containers we actually really

00:03:32,319 --> 00:03:35,680
care about

00:03:32,959 --> 00:03:36,239
as they use the username space and

00:03:35,680 --> 00:03:39,200
therefore

00:03:36,239 --> 00:03:40,560
are more secure in our opinion or not in

00:03:39,200 --> 00:03:42,720
our opinion according to

00:03:40,560 --> 00:03:44,000
the kernel as well uh unbroken

00:03:42,720 --> 00:03:46,319
unprivileged containers

00:03:44,000 --> 00:03:48,400
uh do not have root map to rear root

00:03:46,319 --> 00:03:51,120
which means container uid0 is not

00:03:48,400 --> 00:03:53,040
identical to host uid0

00:03:51,120 --> 00:03:55,120
so that also means container breakouts

00:03:53,040 --> 00:03:56,560
are bad of course but they are not as

00:03:55,120 --> 00:04:00,400
damaging as having

00:03:56,560 --> 00:04:03,599
a container that has real root

00:04:00,400 --> 00:04:07,439
escape to the host unfortunately

00:04:03,599 --> 00:04:09,120
uh the adoption of such unprivileged

00:04:07,439 --> 00:04:12,000
containers has been quite slow

00:04:09,120 --> 00:04:13,040
apart from lexi and lexi this is

00:04:12,000 --> 00:04:16,160
something to do

00:04:13,040 --> 00:04:18,479
with the fact that you can't easily

00:04:16,160 --> 00:04:20,320
share file systems between containers

00:04:18,479 --> 00:04:21,680
between unprivileged containers which is

00:04:20,320 --> 00:04:24,080
something

00:04:21,680 --> 00:04:25,360
which we'll touch upon later in this

00:04:24,080 --> 00:04:27,440
talk

00:04:25,360 --> 00:04:29,440
and unprivileged containers as you might

00:04:27,440 --> 00:04:31,120
have guessed and as i've mentioned

00:04:29,440 --> 00:04:32,960
use the username space as the main

00:04:31,120 --> 00:04:36,479
security name

00:04:32,960 --> 00:04:38,639
security mechanism and this is

00:04:36,479 --> 00:04:40,720
great because the username space is the

00:04:38,639 --> 00:04:42,000
namespace that is actually concerned

00:04:40,720 --> 00:04:45,600
with isolating core

00:04:42,000 --> 00:04:48,639
privilege concepts so capabilities

00:04:45,600 --> 00:04:49,520
and discretionary access permissions and

00:04:48,639 --> 00:04:52,080
lsms

00:04:49,520 --> 00:04:53,919
to some extent are just the icing on the

00:04:52,080 --> 00:04:57,600
cake they're used on top of an

00:04:53,919 --> 00:04:59,759
extra safety net there are even advanced

00:04:57,600 --> 00:05:00,880
versions of such containers where you

00:04:59,759 --> 00:05:04,160
don't even

00:05:00,880 --> 00:05:06,320
map uid 0 in the container to any valid

00:05:04,160 --> 00:05:08,880
uid on the host

00:05:06,320 --> 00:05:11,199
or sometimes unprivileged containers

00:05:08,880 --> 00:05:12,240
aren't even started by root but by fully

00:05:11,199 --> 00:05:14,720
unprivileged

00:05:12,240 --> 00:05:18,320
users on the host so they provide a

00:05:14,720 --> 00:05:18,320
great additional security layer

00:05:19,199 --> 00:05:25,680
okay so i'm going to be looking a bit at

00:05:22,560 --> 00:05:27,520
the isolated username spaces

00:05:25,680 --> 00:05:29,360
and the state of things now and and

00:05:27,520 --> 00:05:33,199
where we want to to take them

00:05:29,360 --> 00:05:36,479
moving forward so um ask questions

00:05:33,199 --> 00:05:37,759
mentioned uh like

00:05:36,479 --> 00:05:39,600
a bridge container is definitely what

00:05:37,759 --> 00:05:41,280
we're pushing for uh that relies on the

00:05:39,600 --> 00:05:45,039
username space

00:05:41,280 --> 00:05:48,000
the the default for

00:05:45,039 --> 00:05:49,520
most username space based container is

00:05:48,000 --> 00:05:53,360
to use the same

00:05:49,520 --> 00:05:55,759
id map for all containers

00:05:53,360 --> 00:05:57,440
this is not ideal it is good from a

00:05:55,759 --> 00:05:58,319
security standpoint in that you can't

00:05:57,440 --> 00:05:59,680
harm the host

00:05:58,319 --> 00:06:01,520
because you're still using username

00:05:59,680 --> 00:06:02,720
space but

00:06:01,520 --> 00:06:04,800
there are some amount of shared

00:06:02,720 --> 00:06:08,000
resources in the kernel that is tied

00:06:04,800 --> 00:06:10,479
to the kernel ui and kernel gid and

00:06:08,000 --> 00:06:12,400
so if two containers use the same map

00:06:10,479 --> 00:06:14,319
one user in one container may affect the

00:06:12,400 --> 00:06:17,600
same user in another

00:06:14,319 --> 00:06:18,160
sibling container the the main one of

00:06:17,600 --> 00:06:21,280
those

00:06:18,160 --> 00:06:22,080
is related to our limits and then

00:06:21,280 --> 00:06:24,880
something we've

00:06:22,080 --> 00:06:27,039
definitely noticed before where one user

00:06:24,880 --> 00:06:28,880
reducing on our limit

00:06:27,039 --> 00:06:30,560
in one container might actually

00:06:28,880 --> 00:06:31,919
negatively impact another

00:06:30,560 --> 00:06:33,600
process running at the same user in

00:06:31,919 --> 00:06:37,360
another container

00:06:33,600 --> 00:06:38,639
to avoid that and also to to avoid any

00:06:37,360 --> 00:06:42,720
potential risk

00:06:38,639 --> 00:06:46,080
of data access or process access

00:06:42,720 --> 00:06:48,000
in the event of a container breakout

00:06:46,080 --> 00:06:49,520
we've been playing with the concept of

00:06:48,000 --> 00:06:52,960
isolated id mappings

00:06:49,520 --> 00:06:54,720
in nxt for a while now where we get uh

00:06:52,960 --> 00:06:58,080
non-configure like we get

00:06:54,720 --> 00:07:00,720
non-overlapping maps for each container

00:06:58,080 --> 00:07:01,199
this does come with some issues of its

00:07:00,720 --> 00:07:03,360
own

00:07:01,199 --> 00:07:04,319
um i'm gonna go through shoot some of

00:07:03,360 --> 00:07:08,720
that

00:07:04,319 --> 00:07:08,720
um in the next few slides so

00:07:09,759 --> 00:07:17,120
the well that kind of goes through the

00:07:13,919 --> 00:07:20,400
the solution to some extent but the

00:07:17,120 --> 00:07:25,039
problem we have um at the core of it

00:07:20,400 --> 00:07:28,160
is that there is a shared

00:07:25,039 --> 00:07:30,000
space of 32-bit integers of uids and

00:07:28,160 --> 00:07:31,919
gids in your linux channel

00:07:30,000 --> 00:07:34,960
and so even with our implementation of

00:07:31,919 --> 00:07:37,919
isolated containers

00:07:34,960 --> 00:07:39,360
we need to take from that one namespace

00:07:37,919 --> 00:07:41,960
which means that

00:07:39,360 --> 00:07:44,960
in our first implementation we went with

00:07:41,960 --> 00:07:48,160
6546 uids and gids per container

00:07:44,960 --> 00:07:50,960
which makes them posix compliant but

00:07:48,160 --> 00:07:53,360
as it turns out is not quite enough for

00:07:50,960 --> 00:07:54,960
many modern linux workloads

00:07:53,360 --> 00:07:57,199
specifically if you're doing things like

00:07:54,960 --> 00:07:59,039
primary authentication or

00:07:57,199 --> 00:08:00,720
if you're running nested containers then

00:07:59,039 --> 00:08:02,400
you might still run out of of your ids

00:08:00,720 --> 00:08:04,879
and gids which

00:08:02,400 --> 00:08:07,360
has four star users quite often to bump

00:08:04,879 --> 00:08:09,680
all the way to 10 million uids and gids

00:08:07,360 --> 00:08:11,280
per container at which point you can

00:08:09,680 --> 00:08:12,000
only run a few hundreds of those before

00:08:11,280 --> 00:08:16,240
you exhaust your

00:08:12,000 --> 00:08:19,360
entire id space on the on the system

00:08:16,240 --> 00:08:21,440
so um as a way to

00:08:19,360 --> 00:08:23,280
to improve on that and also to deal with

00:08:21,440 --> 00:08:26,319
issues like the lack of

00:08:23,280 --> 00:08:27,280
cooperation between user space processes

00:08:26,319 --> 00:08:29,199
like if you're running multiple

00:08:27,280 --> 00:08:30,879
container managers there's really

00:08:29,199 --> 00:08:32,640
communication between them to try and

00:08:30,879 --> 00:08:33,839
avoid using the same maps in multiple

00:08:32,640 --> 00:08:36,399
containers

00:08:33,839 --> 00:08:38,159
um so we figured that we need a kernel

00:08:36,399 --> 00:08:41,760
enforced solution effectively

00:08:38,159 --> 00:08:43,039
and one way uh what the main way

00:08:41,760 --> 00:08:44,800
we're pushing for right now is to

00:08:43,039 --> 00:08:48,720
actually bump the in kernel

00:08:44,800 --> 00:08:51,920
type from 32 bit to 64 bit um

00:08:48,720 --> 00:08:54,160
hiding the um

00:08:51,920 --> 00:08:56,560
the upper 32 bit from user space so user

00:08:54,160 --> 00:08:59,839
space would only ever see the lower 42s

00:08:56,560 --> 00:09:02,399
and the upper 42 would lets us do in

00:08:59,839 --> 00:09:03,440
canon name spacing effectively giving us

00:09:02,399 --> 00:09:07,519
the ability to

00:09:03,440 --> 00:09:10,560
to run like a full you know 42-bit off

00:09:07,519 --> 00:09:12,080
separate namespaces that each get the

00:09:10,560 --> 00:09:15,279
old 32-bit

00:09:12,080 --> 00:09:16,800
uid and gid space there are a lot of

00:09:15,279 --> 00:09:18,320
issues that come with with this design

00:09:16,800 --> 00:09:21,040
too uh obviously

00:09:18,320 --> 00:09:21,680
you can't write a 64-bit uid rgid on the

00:09:21,040 --> 00:09:23,920
file system

00:09:21,680 --> 00:09:25,680
the the file systems will remain 32-bit

00:09:23,920 --> 00:09:27,600
and all the user space interfaces will

00:09:25,680 --> 00:09:31,040
remain 32-bit

00:09:27,600 --> 00:09:32,399
so the linux we need to to find ways to

00:09:31,040 --> 00:09:36,000
translate when needed

00:09:32,399 --> 00:09:38,959
or to have a fallback also when needed

00:09:36,000 --> 00:09:39,839
um in the case that's why we effectively

00:09:38,959 --> 00:09:41,279
end up

00:09:39,839 --> 00:09:43,839
setting an owner for the entire

00:09:41,279 --> 00:09:46,800
namespace uh owning uidmgid

00:09:43,839 --> 00:09:47,760
which will be used for things like

00:09:46,800 --> 00:09:50,000
ukraine

00:09:47,760 --> 00:09:51,440
and for process on the shape and some

00:09:50,000 --> 00:09:55,200
other things like that when it's

00:09:51,440 --> 00:09:56,399
when when objects coming from an x80

00:09:55,200 --> 00:09:58,320
username space

00:09:56,399 --> 00:10:02,000
are seen from outside of that namespace

00:09:58,320 --> 00:10:02,000
like from my parent in space effectively

00:10:02,160 --> 00:10:07,120
the benefits of this approach is that we

00:10:05,279 --> 00:10:09,120
can do very trivial usernames business

00:10:07,120 --> 00:10:10,800
thing we never need to like allocate a

00:10:09,120 --> 00:10:11,680
larger branch to the parent so that it

00:10:10,800 --> 00:10:13,839
can have children

00:10:11,680 --> 00:10:15,279
that that quickly goes away everyone

00:10:13,839 --> 00:10:18,560
gets to create

00:10:15,279 --> 00:10:23,040
a new username space with the old 42-bit

00:10:18,560 --> 00:10:23,040
of your ids and gids available to them

00:10:23,600 --> 00:10:27,519
that also completely fixes any workload

00:10:26,399 --> 00:10:29,200
issues because anything running in a

00:10:27,519 --> 00:10:30,640
container can just use any of the normal

00:10:29,200 --> 00:10:32,720
uds and gids

00:10:30,640 --> 00:10:34,160
don't need to think about or what's

00:10:32,720 --> 00:10:35,440
actually mapped in my name space or

00:10:34,160 --> 00:10:37,440
there might be a gap in the

00:10:35,440 --> 00:10:38,880
in between like uh in the middle of my

00:10:37,440 --> 00:10:40,320
range or something i'm not

00:10:38,880 --> 00:10:42,560
all of that goes away that makes it

00:10:40,320 --> 00:10:44,800
possible to zero and add up to run some

00:10:42,560 --> 00:10:46,320
of the system the isolated units to run

00:10:44,800 --> 00:10:50,320
some of the new snapd

00:10:46,320 --> 00:10:50,320
features all of that stuff just works

00:10:50,800 --> 00:10:57,600
it also makes it

00:10:54,320 --> 00:10:57,600
quite a bit easier on the

00:10:57,680 --> 00:11:00,720
on the runtimes to create and manage

00:10:59,519 --> 00:11:02,480
username spaces

00:11:00,720 --> 00:11:04,560
so that should significantly improve

00:11:02,480 --> 00:11:06,720
adoption uh by just making it

00:11:04,560 --> 00:11:10,240
so easy for just about anything to

00:11:06,720 --> 00:11:10,240
create a new username space

00:11:10,399 --> 00:11:13,680
the the downside of all of this is that

00:11:13,200 --> 00:11:16,160
we d

00:11:13,680 --> 00:11:17,680
we need to deal uh with five system

00:11:16,160 --> 00:11:19,760
access quite carefully

00:11:17,680 --> 00:11:21,360
um because all of those now absolutely

00:11:19,760 --> 00:11:23,920
need translating

00:11:21,360 --> 00:11:24,880
um and so we've got a few approaches

00:11:23,920 --> 00:11:26,640
around that

00:11:24,880 --> 00:11:28,000
which will detail later but for the

00:11:26,640 --> 00:11:29,360
first step

00:11:28,000 --> 00:11:31,040
what you can effectively think of is

00:11:29,360 --> 00:11:32,640
that only five systems that are virtual

00:11:31,040 --> 00:11:35,920
and can be mounted from within

00:11:32,640 --> 00:11:37,600
such a container uh will be allowed and

00:11:35,920 --> 00:11:40,079
for anything else you're gonna need to

00:11:37,600 --> 00:11:42,320
be using new kernel features that allow

00:11:40,079 --> 00:11:44,800
specific mapping for period user to

00:11:42,320 --> 00:11:46,880
configure

00:11:44,800 --> 00:11:49,279
okay um so that was quite a bit of

00:11:46,880 --> 00:11:52,320
talking already let's just do a quick

00:11:49,279 --> 00:11:55,360
demo shall we um

00:11:52,320 --> 00:11:57,200
and for this one we're going to be doing

00:11:55,360 --> 00:11:58,399
the demo of the different type of

00:11:57,200 --> 00:12:02,079
containers so

00:11:58,399 --> 00:12:06,240
i'm gonna first start by creating a

00:12:02,079 --> 00:12:08,320
oops um a previous container

00:12:06,240 --> 00:12:10,399
so let's use an ubuntu training for

00:12:08,320 --> 00:12:12,880
image called contact priv

00:12:10,399 --> 00:12:12,880
and

00:12:13,600 --> 00:12:17,680
ask for it to be privileged i'm using

00:12:15,920 --> 00:12:18,880
legacy in this case as you see

00:12:17,680 --> 00:12:21,200
our default is actually to be

00:12:18,880 --> 00:12:22,800
unprivileged so i've got to specifically

00:12:21,200 --> 00:12:24,800
say that i want something privileged

00:12:22,800 --> 00:12:26,240
i'm creating a second container here

00:12:24,800 --> 00:12:30,720
which isn't privileged and we'll

00:12:26,240 --> 00:12:30,720
create a third which is configured to be

00:12:30,959 --> 00:12:37,040
isolated there we go

00:12:34,160 --> 00:12:38,160
so now we've got three containers one

00:12:37,040 --> 00:12:42,000
thing we can do is

00:12:38,160 --> 00:12:43,360
go look inside them um and you're

00:12:42,000 --> 00:12:45,040
always gonna see the same thing inside

00:12:43,360 --> 00:12:45,680
the container like process ownership and

00:12:45,040 --> 00:12:47,600
everything

00:12:45,680 --> 00:12:50,160
is gonna be the same regardless of the

00:12:47,600 --> 00:12:53,279
type so if i go in there and print one

00:12:50,160 --> 00:12:57,600
we see the exact same thing

00:12:53,279 --> 00:13:00,720
isolated oop without the typo

00:12:57,600 --> 00:13:02,399
again exact same thing now if i go back

00:13:00,720 --> 00:13:05,600
in the previous one

00:13:02,399 --> 00:13:06,000
and i go look at id map we see that

00:13:05,600 --> 00:13:08,560
there's no

00:13:06,000 --> 00:13:10,079
map in place so that means that root in

00:13:08,560 --> 00:13:11,279
the container maps to root as a level

00:13:10,079 --> 00:13:14,160
container

00:13:11,279 --> 00:13:15,040
as well as the following whole 42-bit

00:13:14,160 --> 00:13:16,959
range

00:13:15,040 --> 00:13:18,560
now if we look at my unproved container

00:13:16,959 --> 00:13:21,760
we're gonna see

00:13:18,560 --> 00:13:22,399
it's got a map um starting at one

00:13:21,760 --> 00:13:25,600
million

00:13:22,399 --> 00:13:27,519
that maps uh a billion uids and gids so

00:13:25,600 --> 00:13:31,440
that's how they fall for that

00:13:27,519 --> 00:13:31,440
um if i was to start a second one of

00:13:32,839 --> 00:13:35,839
those

00:13:42,800 --> 00:13:46,240
yeah okay uh so if i look inside this

00:13:45,920 --> 00:13:48,320
one

00:13:46,240 --> 00:13:49,600
i will see the exact same map be in

00:13:48,320 --> 00:13:53,440
place

00:13:49,600 --> 00:13:53,440
but now if we look at our isolated one

00:13:55,600 --> 00:13:59,120
we can see that it's it's mapped only

00:13:58,240 --> 00:14:02,399
65k

00:13:59,120 --> 00:14:03,279
uids and gids and on the another

00:14:02,399 --> 00:14:06,560
different

00:14:03,279 --> 00:14:09,360
spots now if we were to launch a second

00:14:06,560 --> 00:14:09,360
isolated one

00:14:11,279 --> 00:14:18,079
and i entered the right one

00:14:16,160 --> 00:14:20,000
we can see it's got the next slot

00:14:18,079 --> 00:14:22,399
effectively this next offset

00:14:20,000 --> 00:14:23,199
so isolated containers never share maps

00:14:22,399 --> 00:14:24,800
and

00:14:23,199 --> 00:14:26,880
that works that works fine in the

00:14:24,800 --> 00:14:28,480
current state of things but obviously

00:14:26,880 --> 00:14:32,000
the

00:14:28,480 --> 00:14:35,199
the the new isolated canon isolated

00:14:32,000 --> 00:14:36,639
containers um will make that so much

00:14:35,199 --> 00:14:40,560
nicer by not having

00:14:36,639 --> 00:14:40,560
something like lexi do all of that math

00:14:42,160 --> 00:14:46,880
that map isn't even required then

00:14:43,920 --> 00:14:49,839
anymore luckily

00:14:46,880 --> 00:14:50,639
uh so right supervising syscalls um this

00:14:49,839 --> 00:14:52,560
is something which

00:14:50,639 --> 00:14:54,160
uh where we also have been spending

00:14:52,560 --> 00:14:56,320
quite some time

00:14:54,160 --> 00:14:57,760
uh to get around the limitations of

00:14:56,320 --> 00:15:00,800
username spaces while

00:14:57,760 --> 00:15:04,720
also providing

00:15:00,800 --> 00:15:06,320
doing this in a safe way essentially so

00:15:04,720 --> 00:15:08,160
let's briefly look at the fuel

00:15:06,320 --> 00:15:11,440
limitations of

00:15:08,160 --> 00:15:13,199
username spaces the most

00:15:11,440 --> 00:15:14,800
obvious ones what two of the most

00:15:13,199 --> 00:15:18,079
obvious ones are

00:15:14,800 --> 00:15:19,360
um creating device notes and mounting

00:15:18,079 --> 00:15:21,920
file systems so

00:15:19,360 --> 00:15:22,480
if you are in an unprivileged container

00:15:21,920 --> 00:15:24,880
um

00:15:22,480 --> 00:15:26,240
then the username space you're in will

00:15:24,880 --> 00:15:29,120
prevent you from

00:15:26,240 --> 00:15:30,160
creating any device notes even harmless

00:15:29,120 --> 00:15:33,519
ones

00:15:30,160 --> 00:15:36,000
um which isn't uh which doesn't really

00:15:33,519 --> 00:15:38,639
make sense for device nodes such as dev0

00:15:36,000 --> 00:15:40,399
dev null that full so basically the set

00:15:38,639 --> 00:15:43,600
of device nodes that is

00:15:40,399 --> 00:15:44,480
required for um any kind of container to

00:15:43,600 --> 00:15:47,199
be usable

00:15:44,480 --> 00:15:49,360
or the linux system to be usable at all

00:15:47,199 --> 00:15:51,600
and that we already bind mount from the

00:15:49,360 --> 00:15:53,199
host into to the container so given that

00:15:51,600 --> 00:15:54,560
we already bind mounted from the host in

00:15:53,199 --> 00:15:57,600
the container and you have

00:15:54,560 --> 00:15:59,440
right access usually and read access

00:15:57,600 --> 00:16:01,360
there is actually no need to not be able

00:15:59,440 --> 00:16:03,360
to create these device nodes

00:16:01,360 --> 00:16:05,440
mounting file systems is another one so

00:16:03,360 --> 00:16:07,199
real file systems will not be mountable

00:16:05,440 --> 00:16:09,199
from inside username spaces this

00:16:07,199 --> 00:16:11,839
includes anything interesting like x4

00:16:09,199 --> 00:16:14,880
and xfs

00:16:11,839 --> 00:16:17,839
and also you can't load and attach

00:16:14,880 --> 00:16:19,920
ppf programs so username namespaces

00:16:17,839 --> 00:16:21,680
prevent you from

00:16:19,920 --> 00:16:23,279
maybe not necessarily always from

00:16:21,680 --> 00:16:24,079
loading but definitely from attaching

00:16:23,279 --> 00:16:26,480
the ppf

00:16:24,079 --> 00:16:28,079
program to for example a c group which

00:16:26,480 --> 00:16:31,680
is in 2020

00:16:28,079 --> 00:16:33,519
is kind of a a limitation that a lot of

00:16:31,680 --> 00:16:35,600
people find off-putting about privileged

00:16:33,519 --> 00:16:36,880
containers and given that ppf sees more

00:16:35,600 --> 00:16:38,720
and more adoption

00:16:36,880 --> 00:16:40,399
uh finding a way to get around such

00:16:38,720 --> 00:16:44,000
restrictions might be

00:16:40,399 --> 00:16:47,440
quite useful so

00:16:44,000 --> 00:16:49,600
um second point containers this ties

00:16:47,440 --> 00:16:52,399
into this is called supervision

00:16:49,600 --> 00:16:53,360
story secomp is already used in

00:16:52,399 --> 00:16:55,040
containers

00:16:53,360 --> 00:16:56,639
it's namely a way to restrict syscall

00:16:55,040 --> 00:16:58,639
that a task is allowed to make

00:16:56,639 --> 00:17:00,800
and it allows to filter and block

00:16:58,639 --> 00:17:01,759
syscalls to reduce the attack surface of

00:17:00,800 --> 00:17:03,279
container

00:17:01,759 --> 00:17:05,120
it's very important for the for

00:17:03,279 --> 00:17:07,839
additional containers security is you

00:17:05,120 --> 00:17:10,959
can write very fine-grained filters

00:17:07,839 --> 00:17:13,039
in classic bpf not evpf

00:17:10,959 --> 00:17:14,160
not to be confused with ebpf i should

00:17:13,039 --> 00:17:16,319
say

00:17:14,160 --> 00:17:17,679
and they allow you to filter on specific

00:17:16,319 --> 00:17:20,640
arguments or

00:17:17,679 --> 00:17:22,319
even values for arguments so you could

00:17:20,640 --> 00:17:25,439
specify i only want to

00:17:22,319 --> 00:17:27,039
allow specific make not amounts as calls

00:17:25,439 --> 00:17:30,000
to be performed to stay

00:17:27,039 --> 00:17:30,720
in state with the former examples but

00:17:30,000 --> 00:17:33,200
the kernel

00:17:30,720 --> 00:17:35,360
handles these cisco statically meaning a

00:17:33,200 --> 00:17:37,760
second filter usually causes the kernel

00:17:35,360 --> 00:17:39,280
to skip a cisco or report an error code

00:17:37,760 --> 00:17:41,679
and there is no

00:17:39,280 --> 00:17:43,840
way for any user space process to weigh

00:17:41,679 --> 00:17:45,760
in on this decision once that filter is

00:17:43,840 --> 00:17:46,400
loaded the answer that the kernel will

00:17:45,760 --> 00:17:50,720
give

00:17:46,400 --> 00:17:50,720
is always is always fixed

00:17:51,600 --> 00:17:55,760
so what is this called supervision it's

00:17:53,840 --> 00:17:59,200
basically a way

00:17:55,760 --> 00:18:03,039
or it's we interpret this to be

00:17:59,200 --> 00:18:06,480
a way for user space to intercept

00:18:03,039 --> 00:18:08,400
syscalls and as i've mentioned before

00:18:06,480 --> 00:18:10,799
second seems to be quite suited for this

00:18:08,400 --> 00:18:13,360
because it's already able to intercept

00:18:10,799 --> 00:18:15,679
syscalls and it's already widely adopted

00:18:13,360 --> 00:18:18,000
in containers so they understand

00:18:15,679 --> 00:18:19,440
what to do with this and so syscall

00:18:18,000 --> 00:18:22,320
supervision is built

00:18:19,440 --> 00:18:24,000
on top of secomp and is a way to

00:18:22,320 --> 00:18:27,039
outsource decisions about whether a

00:18:24,000 --> 00:18:29,679
cisco is allowed to use a space

00:18:27,039 --> 00:18:31,600
by introducing a new option that you set

00:18:29,679 --> 00:18:33,120
on a filter and when you load a second

00:18:31,600 --> 00:18:34,080
filter you can retrieve a file

00:18:33,120 --> 00:18:37,200
descriptor

00:18:34,080 --> 00:18:39,360
for the given tasks uh second filter

00:18:37,200 --> 00:18:40,320
and this can be handed off to a

00:18:39,360 --> 00:18:42,240
privileged

00:18:40,320 --> 00:18:45,280
user space process such as a container

00:18:42,240 --> 00:18:47,760
manager and it provides two ioctals

00:18:45,280 --> 00:18:49,520
one receive and one sent i output the

00:18:47,760 --> 00:18:50,720
receive ioctal can be used to get

00:18:49,520 --> 00:18:52,799
notified when

00:18:50,720 --> 00:18:54,160
an assist call that the filter is

00:18:52,799 --> 00:18:56,320
registered to listen on

00:18:54,160 --> 00:18:58,480
is actually performed and the second

00:18:56,320 --> 00:19:01,200
notify

00:18:58,480 --> 00:19:03,120
send dioctyl can be used to respond to

00:19:01,200 --> 00:19:07,039
the kernel and instruct it

00:19:03,120 --> 00:19:10,640
to report back an error or success to

00:19:07,039 --> 00:19:14,160
the user space process in question

00:19:10,640 --> 00:19:15,919
and as you can see there's more advanced

00:19:14,160 --> 00:19:17,919
options available as well you can also

00:19:15,919 --> 00:19:18,640
receive file descriptors from another

00:19:17,919 --> 00:19:21,600
task it's

00:19:18,640 --> 00:19:23,200
also something which we added in recent

00:19:21,600 --> 00:19:24,960
kernels

00:19:23,200 --> 00:19:27,440
it's a new dedicated syscall called

00:19:24,960 --> 00:19:28,160
pitfd getfd which makes use of a new api

00:19:27,440 --> 00:19:30,320
that we've

00:19:28,160 --> 00:19:31,520
worked on for the last couple of years

00:19:30,320 --> 00:19:35,200
and you can also

00:19:31,520 --> 00:19:38,400
with the new release 5.9 kernel

00:19:35,200 --> 00:19:41,440
inject file descriptors into

00:19:38,400 --> 00:19:45,919
a task that is currently blocked um

00:19:41,440 --> 00:19:47,760
in in secomp with the second notifier

00:19:45,919 --> 00:19:49,520
which is the term we use process called

00:19:47,760 --> 00:19:51,600
supervision the implementation is called

00:19:49,520 --> 00:19:56,240
second notifier

00:19:51,600 --> 00:19:56,240
it's also based on a new ioctal

00:19:56,400 --> 00:20:01,280
and what the syscall what is called

00:19:59,200 --> 00:20:04,080
supervision or this new second mechanism

00:20:01,280 --> 00:20:07,440
the second notifier allows you to do

00:20:04,080 --> 00:20:10,559
is it allows a process to do syscall

00:20:07,440 --> 00:20:13,120
emulation so when we're talking about

00:20:10,559 --> 00:20:16,559
the make not or the mount versus call

00:20:13,120 --> 00:20:19,280
let's say you write a silicon filter

00:20:16,559 --> 00:20:20,400
that instructs second to trap to user

00:20:19,280 --> 00:20:23,760
space whenever

00:20:20,400 --> 00:20:26,240
a make not syscall is performed then

00:20:23,760 --> 00:20:28,000
the container manager who can listen on

00:20:26,240 --> 00:20:29,679
the file descriptor for this

00:20:28,000 --> 00:20:31,360
task second filter will get a

00:20:29,679 --> 00:20:32,240
notification about this this call

00:20:31,360 --> 00:20:33,840
performed

00:20:32,240 --> 00:20:36,000
it can use the receipt by alcohol i

00:20:33,840 --> 00:20:37,919
mentioned before to receive information

00:20:36,000 --> 00:20:40,880
about the performances call

00:20:37,919 --> 00:20:42,080
it can parse out the information such as

00:20:40,880 --> 00:20:44,480
the arguments

00:20:42,080 --> 00:20:45,679
and it can then decide based on the

00:20:44,480 --> 00:20:47,679
arguments

00:20:45,679 --> 00:20:49,679
to emulate the syscall for the container

00:20:47,679 --> 00:20:51,360
so for example in the case of make note

00:20:49,679 --> 00:20:54,480
it can decide to actually create a

00:20:51,360 --> 00:20:58,080
device node for the container

00:20:54,480 --> 00:20:58,799
um such as dev0 or defnol in the case of

00:20:58,080 --> 00:21:00,799
mount you

00:20:58,799 --> 00:21:02,000
can inspect the target path the soft

00:21:00,799 --> 00:21:05,679
path the file system

00:21:02,000 --> 00:21:08,159
type and if it knows what to expect also

00:21:05,679 --> 00:21:08,960
the data passed passed to the mount says

00:21:08,159 --> 00:21:12,080
call

00:21:08,960 --> 00:21:12,799
and then based on a allow list for

00:21:12,080 --> 00:21:17,120
example

00:21:12,799 --> 00:21:19,600
decide that any x4 mounts is to be

00:21:17,120 --> 00:21:20,559
is to be allowed or even rewrite it to

00:21:19,600 --> 00:21:22,880
fuse

00:21:20,559 --> 00:21:24,720
um you can do quite quite a bit of

00:21:22,880 --> 00:21:27,760
advanced things here

00:21:24,720 --> 00:21:30,559
um and it also allows you to so

00:21:27,760 --> 00:21:33,440
for scenarios for example with the with

00:21:30,559 --> 00:21:33,440
the mount syscall

00:21:33,919 --> 00:21:37,280
because of inherent second restrictions

00:21:36,000 --> 00:21:39,919
we can't necessarily

00:21:37,280 --> 00:21:41,840
write a filter so fine-drained that it

00:21:39,919 --> 00:21:44,000
would allow us

00:21:41,840 --> 00:21:45,039
to capture only those mount syscalls

00:21:44,000 --> 00:21:48,640
that we're definitely

00:21:45,039 --> 00:21:50,400
interested in but also mount syscalls

00:21:48,640 --> 00:21:52,720
that we accidentally

00:21:50,400 --> 00:21:54,799
that we accidentally intercept but

00:21:52,720 --> 00:21:57,280
because of how cisco interception work

00:21:54,799 --> 00:21:58,000
it would require us to emulate any

00:21:57,280 --> 00:22:01,440
accidentally

00:21:58,000 --> 00:22:04,320
mount assist call that even if it would

00:22:01,440 --> 00:22:06,080
already be possible to mount

00:22:04,320 --> 00:22:07,840
to mount it inside of containers so

00:22:06,080 --> 00:22:09,120
let's say you accidentally intercept the

00:22:07,840 --> 00:22:11,039
mount of temperfest

00:22:09,120 --> 00:22:13,440
the container manager would have to

00:22:11,039 --> 00:22:15,679
emulate this mount which is a problem

00:22:13,440 --> 00:22:17,520
and so we introduce the ability to

00:22:15,679 --> 00:22:20,000
continue syscalls

00:22:17,520 --> 00:22:21,760
which needs to be obviously taken with a

00:22:20,000 --> 00:22:24,080
grain of salt it cannot be used to

00:22:21,760 --> 00:22:27,360
implement security policies

00:22:24,080 --> 00:22:29,360
in user space it is also possible to uh

00:22:27,360 --> 00:22:30,720
open and to intercept the open syscall

00:22:29,360 --> 00:22:32,880
nowadays um

00:22:30,720 --> 00:22:35,039
and it's also impossible to intercept

00:22:32,880 --> 00:22:37,120
ppfs call nowadays because we can

00:22:35,039 --> 00:22:38,159
retrieve and inject file descriptors so

00:22:37,120 --> 00:22:40,159
even if

00:22:38,159 --> 00:22:41,440
you open a file descriptor for another

00:22:40,159 --> 00:22:43,600
task you can then

00:22:41,440 --> 00:22:44,960
inject that file descriptor into the

00:22:43,600 --> 00:22:46,960
target task

00:22:44,960 --> 00:22:48,880
that the container manager for example

00:22:46,960 --> 00:22:51,840
received so this is a powerful

00:22:48,880 --> 00:22:54,000
mechanism and stefan will now continue

00:22:51,840 --> 00:22:56,480
to give a demo

00:22:54,000 --> 00:22:57,760
yeah the the the part about not using it

00:22:56,480 --> 00:22:59,840
to do that

00:22:57,760 --> 00:23:01,200
any kind of access control is quite

00:22:59,840 --> 00:23:04,640
important to keep in mind

00:23:01,200 --> 00:23:07,120
uh there is really i think

00:23:04,640 --> 00:23:08,320
especially because what we're gonna what

00:23:07,120 --> 00:23:11,760
you're gonna often do

00:23:08,320 --> 00:23:12,799
inside a notifier handler is access the

00:23:11,760 --> 00:23:15,039
process memory

00:23:12,799 --> 00:23:16,799
and resolve pointers and then do

00:23:15,039 --> 00:23:18,559
compression on those pointers

00:23:16,799 --> 00:23:19,840
it's perfectly fine for you to then

00:23:18,559 --> 00:23:23,200
decide to

00:23:19,840 --> 00:23:24,080
go and do it for the container after

00:23:23,200 --> 00:23:27,919
copying

00:23:24,080 --> 00:23:28,880
those values uh but it's not okay to be

00:23:27,919 --> 00:23:30,640
like okay

00:23:28,880 --> 00:23:32,159
this thing is safe i let the kernel do

00:23:30,640 --> 00:23:33,760
it now because

00:23:32,159 --> 00:23:35,200
those are still pointers and can still

00:23:33,760 --> 00:23:37,039
change before they're actually being run

00:23:35,200 --> 00:23:39,520
so you can never deny based on that

00:23:37,039 --> 00:23:40,400
information effectively because the user

00:23:39,520 --> 00:23:43,039
can raise you

00:23:40,400 --> 00:23:44,640
and trick you into accepting something

00:23:43,039 --> 00:23:48,799
that you shouldn't

00:23:44,640 --> 00:23:48,799
so um on the demo side

00:23:48,880 --> 00:23:55,440
for lexi we we first implemented the

00:23:52,080 --> 00:23:58,080
system called interception for set exada

00:23:55,440 --> 00:23:59,120
and for make node that was to let you

00:23:58,080 --> 00:24:01,520
run

00:23:59,120 --> 00:24:03,279
most docker containers inside in a

00:24:01,520 --> 00:24:06,320
privileged xt container

00:24:03,279 --> 00:24:07,039
by dealing with the the few odd festive

00:24:06,320 --> 00:24:09,520
interactions

00:24:07,039 --> 00:24:10,159
that unpacking some docker layers would

00:24:09,520 --> 00:24:11,919
use

00:24:10,159 --> 00:24:14,000
so that's the first two we did we then

00:24:11,919 --> 00:24:15,279
added mount interception including

00:24:14,000 --> 00:24:17,840
redirection to fuse

00:24:15,279 --> 00:24:18,880
and we've also added the bpf

00:24:17,840 --> 00:24:22,480
interception

00:24:18,880 --> 00:24:24,080
specifically for c group device policies

00:24:22,480 --> 00:24:25,520
at this point

00:24:24,080 --> 00:24:27,360
so what we're going to just show here is

00:24:25,520 --> 00:24:32,000
a quick demo is we're going to

00:24:27,360 --> 00:24:35,840
create a new container

00:24:32,000 --> 00:24:37,520
go inside it and now let's create

00:24:35,840 --> 00:24:38,880
let's pick a device node so let's just

00:24:37,520 --> 00:24:41,279
look at what we have in dev

00:24:38,880 --> 00:24:43,279
okay let's do dev0 so we're going to be

00:24:41,279 --> 00:24:45,440
creating something called dev blah which

00:24:43,279 --> 00:24:47,520
is a character device with major one

00:24:45,440 --> 00:24:49,039
minor five which is the same as dev zero

00:24:47,520 --> 00:24:50,799
as you can see

00:24:49,039 --> 00:24:52,640
this doesn't work this isn't a

00:24:50,799 --> 00:24:57,440
privileged container the camera tells us

00:24:52,640 --> 00:24:57,440
no so let's stop the container

00:24:57,919 --> 00:25:02,960
and then tell xd make node is fine

00:25:03,360 --> 00:25:06,960
and then go back to be clear when we

00:25:05,279 --> 00:25:08,559
configure xd that way it doesn't allow

00:25:06,960 --> 00:25:12,159
all make nodes because that would be

00:25:08,559 --> 00:25:13,600
a security disaster instead we have a

00:25:12,159 --> 00:25:15,840
fixed list

00:25:13,600 --> 00:25:17,440
that's allowed in next day that includes

00:25:15,840 --> 00:25:19,200
creating like a zero zero

00:25:17,440 --> 00:25:21,360
uh character device that also includes

00:25:19,200 --> 00:25:24,000
creating any of the devices that

00:25:21,360 --> 00:25:26,840
comes directly with flexi in this case

00:25:24,000 --> 00:25:29,679
we have a cloud to

00:25:26,840 --> 00:25:33,520
create this particular file

00:25:29,679 --> 00:25:37,200
as a quick example if i was to pick an

00:25:33,520 --> 00:25:37,679
nvme drive okay on my host and i try to

00:25:37,200 --> 00:25:40,720
create

00:25:37,679 --> 00:25:40,720
that particular device

00:25:41,360 --> 00:25:45,279
let's call it blow on the interception

00:25:44,159 --> 00:25:47,360
does not let us do it

00:25:45,279 --> 00:25:50,559
because that would be terribly terribly

00:25:47,360 --> 00:25:52,400
unsafe i was allowed to do this

00:25:50,559 --> 00:25:53,919
and that's pretty much it for the for

00:25:52,400 --> 00:25:55,039
how this contraception works in next day

00:25:53,919 --> 00:25:56,159
we've got a lot more options

00:25:55,039 --> 00:25:58,880
to intercept differences goals and

00:25:56,159 --> 00:26:00,880
different behaviors but that's kind of

00:25:58,880 --> 00:26:02,640
the main idea behind it doing that

00:26:00,880 --> 00:26:06,559
configuration puts in place

00:26:02,640 --> 00:26:08,799
a setcomp entry for the given cisco

00:26:06,559 --> 00:26:09,679
we try to be as restrictive as possible

00:26:08,799 --> 00:26:11,760
to avoid

00:26:09,679 --> 00:26:13,600
needlessly going to use the space then

00:26:11,760 --> 00:26:14,400
user space does the evaluation and runs

00:26:13,600 --> 00:26:17,200
it

00:26:14,400 --> 00:26:20,000
as needed or if not we'll just tell the

00:26:17,200 --> 00:26:20,000
camera to continue

00:26:22,840 --> 00:26:26,880
okay okay

00:26:24,320 --> 00:26:28,640
next up is uh file system so i kind of

00:26:26,880 --> 00:26:30,559
hinted at that well we hinted at that a

00:26:28,640 --> 00:26:32,159
couple of times so far already

00:26:30,559 --> 00:26:33,520
uh one thing that's pretty difficult

00:26:32,159 --> 00:26:34,960
within previous containers in the

00:26:33,520 --> 00:26:38,159
username space in general

00:26:34,960 --> 00:26:40,799
is fire system access because your

00:26:38,159 --> 00:26:41,679
actual file system still stores good old

00:26:40,799 --> 00:26:44,240
42-bit

00:26:41,679 --> 00:26:45,520
you're using gids uh your container

00:26:44,240 --> 00:26:47,120
might have some map might have a

00:26:45,520 --> 00:26:48,960
different map the time after that

00:26:47,120 --> 00:26:50,799
what do you do to handle file system

00:26:48,960 --> 00:26:54,880
access in that world

00:26:50,799 --> 00:26:56,720
well so there are a few things um

00:26:54,880 --> 00:26:57,919
especially a few things that we'd like

00:26:56,720 --> 00:27:00,400
to to make

00:26:57,919 --> 00:27:02,240
possible uh and that are not out of the

00:27:00,400 --> 00:27:04,720
box with a username space

00:27:02,240 --> 00:27:06,640
one thing is just sharing file systems

00:27:04,720 --> 00:27:08,320
whether you want to share a path

00:27:06,640 --> 00:27:10,080
from your whole system into a previous

00:27:08,320 --> 00:27:12,000
container or between

00:27:10,080 --> 00:27:13,840
two computer containers that use a

00:27:12,000 --> 00:27:14,960
different map so two isolated containers

00:27:13,840 --> 00:27:19,039
effectively

00:27:14,960 --> 00:27:21,360
um that's normally not possible

00:27:19,039 --> 00:27:22,240
because like one of the two will be the

00:27:21,360 --> 00:27:23,760
source and

00:27:22,240 --> 00:27:26,080
the other will see everything as

00:27:23,760 --> 00:27:27,840
overflowy id of a flow gid sufficiently

00:27:26,080 --> 00:27:29,440
as minus one when x minus one

00:27:27,840 --> 00:27:31,600
as far as the ownership because there's

00:27:29,440 --> 00:27:34,640
no way to represent that owner inside

00:27:31,600 --> 00:27:36,799
the target container um

00:27:34,640 --> 00:27:38,480
there are some limited some limited ways

00:27:36,799 --> 00:27:40,880
around that you can technically use

00:27:38,480 --> 00:27:42,960
things like posix acls to allow

00:27:40,880 --> 00:27:44,880
the target container access to those

00:27:42,960 --> 00:27:46,399
files they will still see all the

00:27:44,880 --> 00:27:48,640
ownership as being wrong

00:27:46,399 --> 00:27:49,679
but as they'd be allowed to go in and

00:27:48,640 --> 00:27:52,320
create entries

00:27:49,679 --> 00:27:54,000
um but are still going to behave very

00:27:52,320 --> 00:27:56,640
weirdly in general

00:27:54,000 --> 00:27:57,600
um and if you're thinking of doing

00:27:56,640 --> 00:28:01,679
something like that for

00:27:57,600 --> 00:28:03,679
a root file system for example um

00:28:01,679 --> 00:28:05,440
well at that point what you need to do

00:28:03,679 --> 00:28:06,080
is actually unpack your image which is

00:28:05,440 --> 00:28:09,279
normally

00:28:06,080 --> 00:28:11,279
not uh shifted

00:28:09,279 --> 00:28:12,960
and then go and manually change all of

00:28:11,279 --> 00:28:15,520
the ownership information so all the

00:28:12,960 --> 00:28:17,919
uids all the gids all the posix acl

00:28:15,520 --> 00:28:19,440
all of the file capabilities anything

00:28:17,919 --> 00:28:22,480
else that's stored within that

00:28:19,440 --> 00:28:24,000
file system that stores the ui drgid

00:28:22,480 --> 00:28:26,159
needs to be shifted

00:28:24,000 --> 00:28:27,840
to the map used by the container that's

00:28:26,159 --> 00:28:30,640
what we do in next day we've got

00:28:27,840 --> 00:28:31,600
pretty complex logic to do it is

00:28:30,640 --> 00:28:34,000
difficult to do

00:28:31,600 --> 00:28:35,600
without running into security problems

00:28:34,000 --> 00:28:37,039
and it's also slow

00:28:35,600 --> 00:28:38,799
if you're on an ssd you're probably

00:28:37,039 --> 00:28:40,559
looking at like one to two seconds

00:28:38,799 --> 00:28:43,279
shifting time which is not too bad

00:28:40,559 --> 00:28:44,960
if you're on a spinning drive you might

00:28:43,279 --> 00:28:45,600
be looking at minutes in some cases

00:28:44,960 --> 00:28:48,159
which is

00:28:45,600 --> 00:28:49,200
really not pleasant and it keeps getting

00:28:48,159 --> 00:28:51,760
bad with growing

00:28:49,200 --> 00:28:52,640
rfs right i mean the more the more files

00:28:51,760 --> 00:28:54,159
you're gonna get in

00:28:52,640 --> 00:28:55,840
in your file system and the more

00:28:54,159 --> 00:28:57,520
fragmented underlying block device the

00:28:55,840 --> 00:29:01,200
worse it's gonna get

00:28:57,520 --> 00:29:03,039
um the other thing with with that is

00:29:01,200 --> 00:29:03,840
that two isolated containers could not

00:29:03,039 --> 00:29:07,200
share

00:29:03,840 --> 00:29:10,399
a5 system and it's the same issue um

00:29:07,200 --> 00:29:12,080
but yeah that keeps popping up and it's

00:29:10,399 --> 00:29:12,480
something that's that we've noticed ever

00:29:12,080 --> 00:29:14,080
since

00:29:12,480 --> 00:29:15,840
uh the name species have been a thing so

00:29:14,080 --> 00:29:17,520
a long time ago and

00:29:15,840 --> 00:29:19,360
for a long time we were going with okay

00:29:17,520 --> 00:29:20,799
fine we just shift and then we don't

00:29:19,360 --> 00:29:23,760
allow attaching between

00:29:20,799 --> 00:29:25,360
isolated containers and if you want to

00:29:23,760 --> 00:29:26,480
pass a path from the host into your

00:29:25,360 --> 00:29:27,840
container then you need to deal with

00:29:26,480 --> 00:29:30,320
posix ecs

00:29:27,840 --> 00:29:32,799
that was our stance for a while but

00:29:30,320 --> 00:29:34,640
obviously we would like

00:29:32,799 --> 00:29:36,399
the performance of not having to do a

00:29:34,640 --> 00:29:40,159
new shifting and we would like

00:29:36,399 --> 00:29:41,679
the flexibility of being able to

00:29:40,159 --> 00:29:43,360
share paths whichever way we want and

00:29:41,679 --> 00:29:44,320
having ownership nicely lined up and

00:29:43,360 --> 00:29:46,080
everything working

00:29:44,320 --> 00:29:47,520
so we've been looking at options we did

00:29:46,080 --> 00:29:50,240
implement some of those options

00:29:47,520 --> 00:29:51,679
and we are looking at doing things in

00:29:50,240 --> 00:29:53,520
even keen away

00:29:51,679 --> 00:29:55,120
in the very near future so christian

00:29:53,520 --> 00:29:58,640
will be going through some of those

00:29:55,120 --> 00:30:00,320
yes this has been a problem that has

00:29:58,640 --> 00:30:03,520
been around for quite a while

00:30:00,320 --> 00:30:06,399
uh how to improve file system

00:30:03,520 --> 00:30:08,320
interactions for unprivileged containers

00:30:06,399 --> 00:30:09,919
and so a lot of different approaches

00:30:08,320 --> 00:30:12,960
have been thrown around

00:30:09,919 --> 00:30:15,120
and here are some that have been

00:30:12,960 --> 00:30:17,679
proposed and one that we think

00:30:15,120 --> 00:30:19,120
we might be uh going with in the future

00:30:17,679 --> 00:30:20,480
or hope that we are going with in the

00:30:19,120 --> 00:30:22,480
future

00:30:20,480 --> 00:30:23,760
um so one of the first approaches we

00:30:22,480 --> 00:30:26,480
have seen uh

00:30:23,760 --> 00:30:28,159
is uh not overriding credits uh in the

00:30:26,480 --> 00:30:31,760
vfs uh i've

00:30:28,159 --> 00:30:34,840
this uh mistake of mine but um

00:30:31,760 --> 00:30:36,720
so the idea of shift of s was originally

00:30:34,840 --> 00:30:38,559
um

00:30:36,720 --> 00:30:40,480
to enable containers to share file

00:30:38,559 --> 00:30:41,440
system that's obvious so when you shift

00:30:40,480 --> 00:30:44,720
file ownership

00:30:41,440 --> 00:30:46,799
to match the usernames to user you

00:30:44,720 --> 00:30:49,440
the username space the id mapping in the

00:30:46,799 --> 00:30:51,679
username space of the container

00:30:49,440 --> 00:30:53,760
this was done by implementing a tiny

00:30:51,679 --> 00:30:54,640
overlay-like file system that could be

00:30:53,760 --> 00:30:57,679
mounted

00:30:54,640 --> 00:30:59,440
uh inside unprivileged containers

00:30:57,679 --> 00:31:01,039
and as i said it would shift file

00:30:59,440 --> 00:31:02,960
ownership according to the caller's

00:31:01,039 --> 00:31:05,120
username space so that the caller could

00:31:02,960 --> 00:31:07,519
for example you could leave

00:31:05,120 --> 00:31:09,919
if you wanted to uh the root of s of the

00:31:07,519 --> 00:31:13,159
container completely unmapped

00:31:09,919 --> 00:31:16,240
so for example uid0 up to

00:31:13,159 --> 00:31:19,760
65536 and

00:31:16,240 --> 00:31:21,840
then shiftfs would take care that any id

00:31:19,760 --> 00:31:23,760
mapping that the container has would be

00:31:21,840 --> 00:31:25,440
sort of if you think of it shifted back

00:31:23,760 --> 00:31:27,120
to the underlying

00:31:25,440 --> 00:31:28,640
file system so that you could actually

00:31:27,120 --> 00:31:31,200
write to disk

00:31:28,640 --> 00:31:32,799
but as we've realized over time shift if

00:31:31,200 --> 00:31:34,159
as a separate file system is not a

00:31:32,799 --> 00:31:36,799
viable solution it

00:31:34,159 --> 00:31:38,080
gets you into all kinds of issues with

00:31:36,799 --> 00:31:40,320
ioctals

00:31:38,080 --> 00:31:42,399
and you need to make sure that you drop

00:31:40,320 --> 00:31:44,080
the right capabilities and often you end

00:31:42,399 --> 00:31:44,720
up in a state where you would want kind

00:31:44,080 --> 00:31:47,919
of a mix

00:31:44,720 --> 00:31:48,720
out of the original file system mount us

00:31:47,919 --> 00:31:51,679
credentials

00:31:48,720 --> 00:31:53,360
and the container users credentials so

00:31:51,679 --> 00:31:54,080
it's it's not a great look and it's not

00:31:53,360 --> 00:31:57,039
a solution

00:31:54,080 --> 00:31:57,600
we feel comfortable uh up streaming as

00:31:57,039 --> 00:32:01,360
we've said

00:31:57,600 --> 00:32:04,880
at in multiple uh talks

00:32:01,360 --> 00:32:06,880
one apology sorry the fact is like we

00:32:04,880 --> 00:32:08,960
effectively need five system specific

00:32:06,880 --> 00:32:10,720
logic within shift the first is a pretty

00:32:08,960 --> 00:32:12,240
clear sign that this is not

00:32:10,720 --> 00:32:14,159
something key not something we can

00:32:12,240 --> 00:32:16,640
really upstream and that's definitely

00:32:14,159 --> 00:32:19,919
what we run into with ioctals because

00:32:16,640 --> 00:32:21,919
the shiftfs pretends to be

00:32:19,919 --> 00:32:23,519
the underlying file system so that with

00:32:21,919 --> 00:32:23,919
the workloads running in the container

00:32:23,519 --> 00:32:25,679
can

00:32:23,919 --> 00:32:27,200
act just as if they're running on the

00:32:25,679 --> 00:32:29,760
underlying file system

00:32:27,200 --> 00:32:30,960
but that means that if your underlay is

00:32:29,760 --> 00:32:33,760
say borrow fs

00:32:30,960 --> 00:32:35,279
you're gonna need shift fs to be aware

00:32:33,760 --> 00:32:39,200
of what is the volume is

00:32:35,279 --> 00:32:41,679
and handle uh the right credential

00:32:39,200 --> 00:32:42,320
transitions for things like sub-volume

00:32:41,679 --> 00:32:44,960
creation

00:32:42,320 --> 00:32:46,720
of some volume deletion but at the same

00:32:44,960 --> 00:32:48,159
time prevent you from accessing things

00:32:46,720 --> 00:32:50,720
like device management

00:32:48,159 --> 00:32:52,320
which would be global to the system it

00:32:50,720 --> 00:32:53,519
would be a very bad thing for you to be

00:32:52,320 --> 00:32:56,080
able to access with

00:32:53,519 --> 00:32:57,679
effectively a good credential so that's

00:32:56,080 --> 00:32:58,799
definitely tricky and we've had to do a

00:32:57,679 --> 00:33:01,679
bunch of that for different

00:32:58,799 --> 00:33:03,279
fire system features it's possible it

00:33:01,679 --> 00:33:04,880
works but it's

00:33:03,279 --> 00:33:06,559
it's not something that we can

00:33:04,880 --> 00:33:09,519
realistically ever ever push

00:33:06,559 --> 00:33:12,320
upstream like it feels way too hacky and

00:33:09,519 --> 00:33:15,440
so we need a different solution

00:33:12,320 --> 00:33:17,919
i'm going to quickly present more or

00:33:15,440 --> 00:33:22,159
less three other solutions

00:33:17,919 --> 00:33:22,159
since we're nearing the end of our talk

00:33:22,559 --> 00:33:27,120
one option we pursued uh last year i

00:33:25,120 --> 00:33:28,960
think was to introduce

00:33:27,120 --> 00:33:30,640
which would have been an easier solution

00:33:28,960 --> 00:33:31,440
is to introduce new proc files in

00:33:30,640 --> 00:33:34,640
addition to

00:33:31,440 --> 00:33:37,679
ui emap and gid map introduce fsu id map

00:33:34,640 --> 00:33:41,120
and fsg id map that would let you create

00:33:37,679 --> 00:33:41,919
independent mappings for your fsuid and

00:33:41,120 --> 00:33:44,000
fsg id

00:33:41,919 --> 00:33:45,039
which are the ids that actually count

00:33:44,000 --> 00:33:48,399
when you create

00:33:45,039 --> 00:33:50,399
files on disk for most pilot systems

00:33:48,399 --> 00:33:52,000
and so the idea was that users can write

00:33:50,399 --> 00:33:55,039
custom mappings for their file

00:33:52,000 --> 00:33:55,840
system for their file system ids the

00:33:55,039 --> 00:33:57,440
problem we

00:33:55,840 --> 00:33:59,039
there are problems with this approach

00:33:57,440 --> 00:34:01,200
and advantages one

00:33:59,039 --> 00:34:03,360
glaring problem is that require special

00:34:01,200 --> 00:34:05,279
treatment of pocketfest and sisterpest

00:34:03,360 --> 00:34:07,440
so for example if you were to write an

00:34:05,279 --> 00:34:08,800
identical mapping to the initial

00:34:07,440 --> 00:34:11,200
username space

00:34:08,800 --> 00:34:13,040
then you could inside of the username

00:34:11,200 --> 00:34:15,679
space access and change

00:34:13,040 --> 00:34:19,200
all procfs and sysfs files potentially

00:34:15,679 --> 00:34:20,960
or get access to proper person cfs files

00:34:19,200 --> 00:34:23,119
that you shouldn't have otherwise access

00:34:20,960 --> 00:34:25,040
to which is obviously not great

00:34:23,119 --> 00:34:27,200
uh the advantage is that the approach is

00:34:25,040 --> 00:34:27,760
relatively simple so the vfs doesn't

00:34:27,200 --> 00:34:29,760
need

00:34:27,760 --> 00:34:31,599
to be modified too deeply still needs

00:34:29,760 --> 00:34:32,320
quite a lot of modification and actually

00:34:31,599 --> 00:34:34,720
i think

00:34:32,320 --> 00:34:35,520
some file systems would uh with this

00:34:34,720 --> 00:34:37,760
approach

00:34:35,520 --> 00:34:39,040
need to be changed too but overall it's

00:34:37,760 --> 00:34:40,720
pretty clean

00:34:39,040 --> 00:34:42,480
problem is it doesn't handle all use

00:34:40,720 --> 00:34:44,639
cases um for example

00:34:42,480 --> 00:34:46,399
it's not possible to idmap without being

00:34:44,639 --> 00:34:49,280
inside of a username space which is

00:34:46,399 --> 00:34:53,280
becoming an increasingly pop

00:34:49,280 --> 00:34:56,159
important requirement

00:34:53,280 --> 00:34:57,359
another approach is to use override

00:34:56,159 --> 00:35:01,200
credits

00:34:57,359 --> 00:35:03,200
so this has its own drawbacks

00:35:01,200 --> 00:35:04,480
it first of all it seems elegant and

00:35:03,200 --> 00:35:06,079
clean

00:35:04,480 --> 00:35:08,560
but you need to allocate and you need to

00:35:06,079 --> 00:35:09,599
allocate temporary credentials in the

00:35:08,560 --> 00:35:12,800
vfs

00:35:09,599 --> 00:35:16,000
on each path lookup and

00:35:12,800 --> 00:35:18,960
that can get that's not great especially

00:35:16,000 --> 00:35:21,200
if you consider in rcu lookup mode then

00:35:18,960 --> 00:35:23,599
you can't really you need to take care

00:35:21,200 --> 00:35:24,560
to allocate it um at the beginning of

00:35:23,599 --> 00:35:27,119
path lookup

00:35:24,560 --> 00:35:28,400
before you are actually entering into

00:35:27,119 --> 00:35:30,880
rcu

00:35:28,400 --> 00:35:32,640
path lookup it's already problematic it

00:35:30,880 --> 00:35:34,560
also requires override cred everywhere

00:35:32,640 --> 00:35:35,520
in the vfs at least every time you're

00:35:34,560 --> 00:35:38,560
crossing

00:35:35,520 --> 00:35:40,000
a mount point and it's

00:35:38,560 --> 00:35:41,760
i'm not completely clear how well this

00:35:40,000 --> 00:35:43,599
works for all file systems this

00:35:41,760 --> 00:35:45,200
might just be me and i would need to do

00:35:43,599 --> 00:35:46,880
another audit but

00:35:45,200 --> 00:35:48,240
cloud systems that call override cred

00:35:46,880 --> 00:35:50,000
themselves or change

00:35:48,240 --> 00:35:52,240
ids might get confused with this

00:35:50,000 --> 00:35:54,400
approach another problem is it doesn't

00:35:52,240 --> 00:35:56,079
handle all use cases too so for example

00:35:54,400 --> 00:35:57,920
it's not possible to id map without

00:35:56,079 --> 00:36:00,240
being inside of username space which

00:35:57,920 --> 00:36:02,480
also was a drawback of the fsuid and

00:36:00,240 --> 00:36:03,200
fsgid map and this is a use case we

00:36:02,480 --> 00:36:05,440
think we

00:36:03,200 --> 00:36:06,640
might we really need to handle

00:36:05,440 --> 00:36:09,839
especially with the

00:36:06,640 --> 00:36:12,720
rise of systemd homd and

00:36:09,839 --> 00:36:14,480
other nice features so one approach we

00:36:12,720 --> 00:36:16,720
are currently pursuing and about

00:36:14,480 --> 00:36:18,560
are about to propose or maybe by this

00:36:16,720 --> 00:36:22,000
time we'll have already proposed is

00:36:18,560 --> 00:36:23,680
id mapped bind mounts so it's

00:36:22,000 --> 00:36:25,040
essentially the idea to attach a

00:36:23,680 --> 00:36:27,680
username space to

00:36:25,040 --> 00:36:30,000
the vfs mount in the kernel and then

00:36:27,680 --> 00:36:31,280
inodes are shifted by the username space

00:36:30,000 --> 00:36:33,839
the bfs

00:36:31,280 --> 00:36:34,880
vfs mount has been marked with so the

00:36:33,839 --> 00:36:37,839
access

00:36:34,880 --> 00:36:38,320
so when you try to create a file through

00:36:37,839 --> 00:36:40,880
which

00:36:38,320 --> 00:36:42,000
vfs mount you're trying to create that

00:36:40,880 --> 00:36:45,200
file becomes

00:36:42,000 --> 00:36:47,280
irrelevant um it requires more extensive

00:36:45,200 --> 00:36:48,560
changes to the vfs because the username

00:36:47,280 --> 00:36:51,040
space is passed down

00:36:48,560 --> 00:36:52,960
even sometimes down to the file system

00:36:51,040 --> 00:36:55,359
for object creation

00:36:52,960 --> 00:36:56,160
but it feel it it's conceptually it's

00:36:55,359 --> 00:36:58,720
very clean

00:36:56,160 --> 00:36:59,839
and it allows us to cover all use cases

00:36:58,720 --> 00:37:02,079
actually

00:36:59,839 --> 00:37:04,079
it also allows us to set up id map

00:37:02,079 --> 00:37:06,160
mounts in the initial username space so

00:37:04,079 --> 00:37:09,599
you could for example

00:37:06,160 --> 00:37:12,720
mount your x4 file system once um

00:37:09,599 --> 00:37:14,720
in the host and then

00:37:12,720 --> 00:37:15,839
for different users without needing to

00:37:14,720 --> 00:37:18,720
shown

00:37:15,839 --> 00:37:21,359
providing specific subdirectories for

00:37:18,720 --> 00:37:23,119
each of your users

00:37:21,359 --> 00:37:25,599
by just giving them separate mount

00:37:23,119 --> 00:37:26,880
points uh that have a specific id

00:37:25,599 --> 00:37:29,200
mapping applied

00:37:26,880 --> 00:37:31,599
to them and other nice use cases so this

00:37:29,200 --> 00:37:33,839
is actually a very powerful mechanism

00:37:31,599 --> 00:37:35,040
and we're excited about this and hope

00:37:33,839 --> 00:37:37,359
this is something that

00:37:35,040 --> 00:37:39,520
uh that people will get excited about

00:37:37,359 --> 00:37:39,520
too

00:37:40,240 --> 00:37:44,000
and just before before going into the

00:37:42,240 --> 00:37:45,200
demo for that bit it's also worth

00:37:44,000 --> 00:37:46,640
mentioning that

00:37:45,200 --> 00:37:48,720
i mean everything we've said so far

00:37:46,640 --> 00:37:51,760
kinetized into each other

00:37:48,720 --> 00:37:53,359
so when looking at the the the work

00:37:51,760 --> 00:37:56,079
we're doing around the isolated

00:37:53,359 --> 00:37:57,440
uh username space in the camera and

00:37:56,079 --> 00:38:01,200
differently bumping from

00:37:57,440 --> 00:38:02,720
those 32-bit uid kj id over to 64-bit ui

00:38:01,200 --> 00:38:05,440
dkjid

00:38:02,720 --> 00:38:06,320
um as i mentioned you won't you won't be

00:38:05,440 --> 00:38:07,839
able to

00:38:06,320 --> 00:38:09,599
really interact with your host fight

00:38:07,839 --> 00:38:12,800
system in that mode because

00:38:09,599 --> 00:38:14,000
you need some something to know

00:38:12,800 --> 00:38:16,560
what you're supposed to be actually

00:38:14,000 --> 00:38:19,359
writing as uh otherwise

00:38:16,560 --> 00:38:20,720
you either are unable to do anything or

00:38:19,359 --> 00:38:21,839
you're allowed to do a lot more things

00:38:20,720 --> 00:38:25,040
than you should do and then you've got a

00:38:21,839 --> 00:38:28,079
massive security issue on your hands

00:38:25,040 --> 00:38:30,960
this approach will effectively let us do

00:38:28,079 --> 00:38:31,760
a bind mount of path on the host file

00:38:30,960 --> 00:38:35,040
system

00:38:31,760 --> 00:38:38,560
into a target path

00:38:35,040 --> 00:38:42,560
which is then properly tied to

00:38:38,560 --> 00:38:44,800
the isolated username space

00:38:42,560 --> 00:38:46,240
and so the iso engine space can then

00:38:44,800 --> 00:38:49,280
effectively pivot to that

00:38:46,240 --> 00:38:52,240
make that their their real file system

00:38:49,280 --> 00:38:53,920
and then move on and do normal ios and

00:38:52,240 --> 00:38:55,119
any rights they do will go through the

00:38:53,920 --> 00:39:00,720
configured mapped

00:38:55,119 --> 00:39:03,839
map onto the host file system

00:39:00,720 --> 00:39:06,800
okay so for our

00:39:03,839 --> 00:39:07,760
last demo today let's just clear this

00:39:06,800 --> 00:39:09,680
stuff

00:39:07,760 --> 00:39:11,680
uh we're gonna just be looking at the

00:39:09,680 --> 00:39:14,000
current state of things so

00:39:11,680 --> 00:39:17,119
i don't have the new experimental

00:39:14,000 --> 00:39:19,760
patches for for any of that new

00:39:17,119 --> 00:39:20,480
id mapped mine mount but we can show

00:39:19,760 --> 00:39:23,520
what we've

00:39:20,480 --> 00:39:25,760
had what we've done so far with shift fs

00:39:23,520 --> 00:39:27,520
so that's shifters was effectively

00:39:25,760 --> 00:39:30,240
started by james bonhamley

00:39:27,520 --> 00:39:31,920
at ibm a while back then canonical puts

00:39:30,240 --> 00:39:32,400
some considerable amount of time from

00:39:31,920 --> 00:39:36,240
both

00:39:32,400 --> 00:39:38,079
sephora she and christian to

00:39:36,240 --> 00:39:39,520
cover pretty much all the cases we care

00:39:38,079 --> 00:39:40,880
about make it

00:39:39,520 --> 00:39:43,200
really usable for our users and it's

00:39:40,880 --> 00:39:45,839
presented present in the ubuntu camera

00:39:43,200 --> 00:39:46,800
today it's not on by default but you can

00:39:45,839 --> 00:39:50,240
definitely turn it on

00:39:46,800 --> 00:39:51,920
and i've got it on enable on my laptop

00:39:50,240 --> 00:39:53,520
so let's just start and create a new

00:39:51,920 --> 00:39:57,040
container

00:39:53,520 --> 00:39:58,640
okay right let's just already hide one

00:39:57,040 --> 00:40:02,000
of those

00:39:58,640 --> 00:40:05,520
okay just create a new c1 container here

00:40:02,000 --> 00:40:07,599
if i go in that container just screen

00:40:05,520 --> 00:40:08,960
when you look at pog cell format info

00:40:07,599 --> 00:40:09,920
that's one of the few ways you can

00:40:08,960 --> 00:40:11,119
actually tell what are you running on

00:40:09,920 --> 00:40:13,040
shiftfs

00:40:11,119 --> 00:40:16,160
here you'll see on the first line that

00:40:13,040 --> 00:40:18,800
it shows uh slash is a shift fs mount

00:40:16,160 --> 00:40:20,400
it shows what the underlay is and it's

00:40:18,800 --> 00:40:21,520
got pass through equals three which

00:40:20,400 --> 00:40:25,839
means we

00:40:21,520 --> 00:40:25,839
pass through ioctals that we understand

00:40:26,319 --> 00:40:33,760
but if i do start on slash

00:40:30,560 --> 00:40:34,480
you'll see that the the start fs score

00:40:33,760 --> 00:40:36,560
actually

00:40:34,480 --> 00:40:40,480
gives me the zfs magic in this case and

00:40:36,560 --> 00:40:42,000
not shift fs so we can

00:40:40,480 --> 00:40:44,319
that's how we effectively get most of

00:40:42,000 --> 00:40:45,280
user space to behave as if it's running

00:40:44,319 --> 00:40:47,359
on the underlay

00:40:45,280 --> 00:40:48,720
file system and do all the normal

00:40:47,359 --> 00:40:52,319
ioctals is by also

00:40:48,720 --> 00:40:54,720
faking that bit um now let's

00:40:52,319 --> 00:40:56,319
pass my home directory into that

00:40:54,720 --> 00:40:58,000
container

00:40:56,319 --> 00:41:00,400
so we're going to just add a new device

00:40:58,000 --> 00:41:02,079
called home uh the source puffy slash

00:41:00,400 --> 00:41:06,000
home on my host and the pasta does

00:41:02,079 --> 00:41:06,720
mnt home in the container and i need to

00:41:06,000 --> 00:41:09,920
specify this

00:41:06,720 --> 00:41:13,440
disk okay

00:41:09,920 --> 00:41:15,920
so if i look at such mnt there we go so

00:41:13,440 --> 00:41:16,800
it is past 10 but as you can see i can't

00:41:15,920 --> 00:41:19,200
access anything

00:41:16,800 --> 00:41:21,280
and everything is nobody no group which

00:41:19,200 --> 00:41:22,880
is not the real nobody no group people

00:41:21,280 --> 00:41:24,480
tend to be a bit confused about that

00:41:22,880 --> 00:41:26,560
it's actually the overflow your idea of

00:41:24,480 --> 00:41:28,960
the flow gid which means

00:41:26,560 --> 00:41:31,040
the uid that actually owns this path

00:41:28,960 --> 00:41:34,400
which is user 1000

00:41:31,040 --> 00:41:35,839
1000 or something on the host is not

00:41:34,400 --> 00:41:38,640
cannot be represented inside

00:41:35,839 --> 00:41:39,599
that namespace and so it shows up as

00:41:38,640 --> 00:41:42,560
overflow

00:41:39,599 --> 00:41:44,240
in this case nobody know group now let's

00:41:42,560 --> 00:41:47,520
detach this thing

00:41:44,240 --> 00:41:50,640
so remove c1

00:41:47,520 --> 00:41:54,079
home and let's just do it again but this

00:41:50,640 --> 00:41:54,079
time do shift equals true

00:41:54,560 --> 00:41:59,359
and now if we go look at mount info

00:41:59,920 --> 00:42:04,000
the last entry here you can see that

00:42:01,760 --> 00:42:04,800
slash mnt home is now a shift device

00:42:04,000 --> 00:42:08,640
mount

00:42:04,800 --> 00:42:11,839
of some our oh it's lexi path

00:42:08,640 --> 00:42:15,520
and now if i look oops one very good

00:42:11,839 --> 00:42:17,920
mnt mnt home hey look at that you can

00:42:15,520 --> 00:42:20,480
actually resolve the uids and gids

00:42:17,920 --> 00:42:21,359
and actually access the data so that's

00:42:20,480 --> 00:42:25,520
shift fs

00:42:21,359 --> 00:42:25,520
here working and

00:42:26,079 --> 00:42:31,520
doing the translation and just removed

00:42:28,480 --> 00:42:34,960
it so it should be gone now yep

00:42:31,520 --> 00:42:36,480
and that's it for shift fs just switch

00:42:34,960 --> 00:42:40,400
back to the slides

00:42:36,480 --> 00:42:43,680
and back here

00:42:40,400 --> 00:42:45,200
so that's it for what we had today that

00:42:43,680 --> 00:42:46,720
i think should have given you a pretty

00:42:45,200 --> 00:42:48,079
good uh

00:42:46,720 --> 00:42:49,920
overview of kind of where we're standing

00:42:48,079 --> 00:42:52,000
out with the username space uh we are

00:42:49,920 --> 00:42:53,440
definitely still pushing for absolutely

00:42:52,000 --> 00:42:54,240
everyone to use them and for push

00:42:53,440 --> 00:42:58,160
containers to

00:42:54,240 --> 00:43:02,160
burn in a fire as quickly as possible

00:42:58,160 --> 00:43:04,400
um the the main issues i think

00:43:02,160 --> 00:43:05,520
we've identified over over the years is

00:43:04,400 --> 00:43:08,800
differently the

00:43:05,520 --> 00:43:10,880
the all the need for cooperation

00:43:08,800 --> 00:43:13,680
and planning to some extent of the

00:43:10,880 --> 00:43:16,079
container managers

00:43:13,680 --> 00:43:17,520
for uis and gid ranges in the user

00:43:16,079 --> 00:43:19,119
namespace which is

00:43:17,520 --> 00:43:21,599
one of the big issues and the other

00:43:19,119 --> 00:43:23,440
aspect being the file system layer

00:43:21,599 --> 00:43:25,599
we've got plans to fix both of those

00:43:23,440 --> 00:43:27,760
that should make it possible for

00:43:25,599 --> 00:43:30,800
everyone to use username spaces and for

00:43:27,760 --> 00:43:32,560
ph containers to go away for good

00:43:30,800 --> 00:43:34,240
default system layer we might just

00:43:32,560 --> 00:43:36,000
mention is particularly relevant for

00:43:34,240 --> 00:43:38,880
application containers

00:43:36,000 --> 00:43:39,359
because for those you need to be able to

00:43:38,880 --> 00:43:41,200
have

00:43:39,359 --> 00:43:42,800
a set of layers that are distributed

00:43:41,200 --> 00:43:44,079
that are none of them are shifted

00:43:42,800 --> 00:43:45,920
and then you need to spoil multiple

00:43:44,079 --> 00:43:47,839
containers each of their own map

00:43:45,920 --> 00:43:49,119
yet be able to use the same stack of

00:43:47,839 --> 00:43:50,800
layers so

00:43:49,119 --> 00:43:52,839
the the work that christian has been

00:43:50,800 --> 00:43:56,079
doing around

00:43:52,839 --> 00:43:58,319
vfs layer by mount

00:43:56,079 --> 00:44:00,480
id map mine mount will make that very

00:43:58,319 --> 00:44:03,280
easy and we'll completely sort that

00:44:00,480 --> 00:44:03,839
this particular need that's it for all

00:44:03,280 --> 00:44:06,319
we have

00:44:03,839 --> 00:44:07,440
uh if you've got any any questions just

00:44:06,319 --> 00:44:09,200
ask

00:44:07,440 --> 00:44:11,280
i can take the contact details there as

00:44:09,200 --> 00:44:12,560
well as some useful websites you can

00:44:11,280 --> 00:44:15,680
even go and try

00:44:12,560 --> 00:44:18,800
next online from your web browser and i

00:44:15,680 --> 00:44:22,880
think we're just about out of time so

00:44:18,800 --> 00:44:36,160
yeah thank you everyone thank you

00:44:22,880 --> 00:44:36,160

YouTube URL: https://www.youtube.com/watch?v=ef4WAT0ThY0


