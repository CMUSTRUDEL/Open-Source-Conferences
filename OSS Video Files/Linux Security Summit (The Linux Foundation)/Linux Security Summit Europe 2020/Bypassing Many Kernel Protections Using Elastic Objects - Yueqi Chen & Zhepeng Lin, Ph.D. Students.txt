Title: Bypassing Many Kernel Protections Using Elastic Objects - Yueqi Chen & Zhepeng Lin, Ph.D. Students
Publication date: 2020-11-12
Playlist: Linux Security Summit Europe 2020
Description: 
	Bypassing Many Kernel Protections Using Elastic Objects - Yueqi Chen & Zhepeng Lin, Ph.D. Students
Captions: 
	00:00:08,400 --> 00:00:12,400
okay

00:00:08,960 --> 00:00:15,200
here we go hello everyone

00:00:12,400 --> 00:00:16,560
i'm happy to be with you today my name

00:00:15,200 --> 00:00:19,439
is turn

00:00:16,560 --> 00:00:21,119
a phd student from pennsylvania state

00:00:19,439 --> 00:00:23,760
university

00:00:21,119 --> 00:00:24,800
in this talk i'd like to share with you

00:00:23,760 --> 00:00:27,439
some outcomes

00:00:24,800 --> 00:00:27,920
of my recent research work with my lab

00:00:27,439 --> 00:00:31,119
mate

00:00:27,920 --> 00:00:33,520
jump only this talk is about an

00:00:31,119 --> 00:00:35,360
exploitation approach which can which

00:00:33,520 --> 00:00:38,399
can bypass many medications

00:00:35,360 --> 00:00:41,520
in linux kernel this approach uses

00:00:38,399 --> 00:00:43,120
magic objects which we name as elastic

00:00:41,520 --> 00:00:44,960
objects

00:00:43,120 --> 00:00:47,520
at the beginning of the talk i will

00:00:44,960 --> 00:00:50,480
introduce several kernel protections

00:00:47,520 --> 00:00:53,760
that we are going to bypass as well as

00:00:50,480 --> 00:00:56,239
some conversative data we want to leak

00:00:53,760 --> 00:00:57,039
then i will introduce the exploitation

00:00:56,239 --> 00:01:00,480
approach

00:00:57,039 --> 00:01:01,199
using an example followed by this i will

00:01:00,480 --> 00:01:03,840
show

00:01:01,199 --> 00:01:06,240
how we track down elastic objects by

00:01:03,840 --> 00:01:07,920
extending flexible objects in the kernel

00:01:06,240 --> 00:01:10,400
codebase

00:01:07,920 --> 00:01:12,080
i will display the severity of this

00:01:10,400 --> 00:01:14,560
exploitation approach

00:01:12,080 --> 00:01:15,920
i have written about why we need to

00:01:14,560 --> 00:01:19,040
study the generality

00:01:15,920 --> 00:01:20,880
of this attack after this i will

00:01:19,040 --> 00:01:23,520
describe the way we use

00:01:20,880 --> 00:01:25,280
to study the generality and the outcome

00:01:23,520 --> 00:01:27,439
of the study

00:01:25,280 --> 00:01:28,560
finally i will go through several kernel

00:01:27,439 --> 00:01:30,479
mitigations

00:01:28,560 --> 00:01:32,960
that seem to be able to circumvent the

00:01:30,479 --> 00:01:36,000
attack but i don't think so

00:01:32,960 --> 00:01:38,079
that's why i propose a mitigation which

00:01:36,000 --> 00:01:41,360
is far away from being perfect

00:01:38,079 --> 00:01:42,960
i knew some comments from you this talk

00:01:41,360 --> 00:01:46,240
takes about

00:01:42,960 --> 00:01:48,720
40 minutes for 28 pages

00:01:46,240 --> 00:01:50,799
if you have any questions feel free to

00:01:48,720 --> 00:01:53,920
ask via text chat

00:01:50,799 --> 00:01:55,200
and also i paste my contract at the last

00:01:53,920 --> 00:01:57,200
page of the slide

00:01:55,200 --> 00:01:58,880
in case you don't have chance to ask

00:01:57,200 --> 00:02:00,960
questions

00:01:58,880 --> 00:02:02,159
i hope you can enjoy the talk and send

00:02:00,960 --> 00:02:04,079
me your comments

00:02:02,159 --> 00:02:06,479
so that we can further advance our

00:02:04,079 --> 00:02:06,479
research

00:02:06,799 --> 00:02:10,000
as i mentioned i will describe several

00:02:08,720 --> 00:02:13,200
kernel protections

00:02:10,000 --> 00:02:16,000
that we plan to bypass the first

00:02:13,200 --> 00:02:16,400
protection is stagnary which has already

00:02:16,000 --> 00:02:18,800
been

00:02:16,400 --> 00:02:20,959
deployed in both kernel and user space

00:02:18,800 --> 00:02:22,720
program for decades

00:02:20,959 --> 00:02:24,800
i'm pretty sure that you are familiar

00:02:22,720 --> 00:02:26,959
with this protection stack

00:02:24,800 --> 00:02:28,879
just in case i will brief this

00:02:26,959 --> 00:02:31,680
mitigation

00:02:28,879 --> 00:02:33,120
the idea is quite simple when having a

00:02:31,680 --> 00:02:35,599
stack buffer overflow

00:02:33,120 --> 00:02:36,160
the adversary can overwrite the return

00:02:35,599 --> 00:02:39,040
address

00:02:36,160 --> 00:02:40,160
in current stack frame later when the

00:02:39,040 --> 00:02:42,640
function returns

00:02:40,160 --> 00:02:45,599
the function the kernel execution is

00:02:42,640 --> 00:02:47,760
directed to the malicious address

00:02:45,599 --> 00:02:48,640
to detect this override drawing the

00:02:47,760 --> 00:02:51,120
prolog

00:02:48,640 --> 00:02:53,440
the kernel places the stack canary which

00:02:51,120 --> 00:02:55,680
is several bytes of random value

00:02:53,440 --> 00:02:57,360
right below the return address and old

00:02:55,680 --> 00:02:59,840
ebp

00:02:57,360 --> 00:03:01,200
during the epilogue the kernel tests the

00:02:59,840 --> 00:03:03,519
canary on stack

00:03:01,200 --> 00:03:04,239
against the one start to see if any

00:03:03,519 --> 00:03:07,519
corruptions

00:03:04,239 --> 00:03:08,239
happened if stack buffer overflow is

00:03:07,519 --> 00:03:10,319
triggered

00:03:08,239 --> 00:03:12,319
the stack canary is templed before the

00:03:10,319 --> 00:03:14,640
return address

00:03:12,319 --> 00:03:16,640
thus when the kronor finds a mismatch

00:03:14,640 --> 00:03:19,120
between the canary on stack

00:03:16,640 --> 00:03:20,400
and the one start this means stack

00:03:19,120 --> 00:03:22,560
corruption has happened

00:03:20,400 --> 00:03:24,560
and the return address is no longer

00:03:22,560 --> 00:03:26,799
trustworthy

00:03:24,560 --> 00:03:28,560
the stack canary is now by default

00:03:26,799 --> 00:03:31,200
mitigation in almost

00:03:28,560 --> 00:03:32,239
all linux gestures including ubuntu and

00:03:31,200 --> 00:03:34,239
debian

00:03:32,239 --> 00:03:36,239
it is also used in other operating

00:03:34,239 --> 00:03:40,000
system kernel like freebsd

00:03:36,239 --> 00:03:42,720
and xmu to bypass this mitigation

00:03:40,000 --> 00:03:43,280
the adversary either uses brute force

00:03:42,720 --> 00:03:46,159
method

00:03:43,280 --> 00:03:47,440
or relies on information leaking the

00:03:46,159 --> 00:03:50,319
brute force method

00:03:47,440 --> 00:03:52,000
is to get the canary bite by bat which

00:03:50,319 --> 00:03:55,439
reduces the complexity

00:03:52,000 --> 00:03:59,360
from 64 over 2 to 8 over 2

00:03:55,439 --> 00:04:01,439
on the big o information leaking

00:03:59,360 --> 00:04:03,680
is another approach in which the

00:04:01,439 --> 00:04:05,040
adversary can leak the canary to user

00:04:03,680 --> 00:04:07,599
space

00:04:05,040 --> 00:04:08,480
one of my previous works is to use iv

00:04:07,599 --> 00:04:11,360
control

00:04:08,480 --> 00:04:12,159
to perform stack leaking in this talk i

00:04:11,360 --> 00:04:14,640
will show

00:04:12,159 --> 00:04:15,599
how i use right primitive to obtain a

00:04:14,640 --> 00:04:19,120
leak primitive

00:04:15,599 --> 00:04:19,120
for exposing the stack canary

00:04:19,280 --> 00:04:22,880
the second mitigation stack i want to

00:04:21,280 --> 00:04:25,919
introduce is config

00:04:22,880 --> 00:04:29,040
initial stack or and config gcc plugin

00:04:25,919 --> 00:04:31,040
stack leak both mitigations are

00:04:29,040 --> 00:04:31,600
responsible for poisoning the kernel

00:04:31,040 --> 00:04:34,880
stack

00:04:31,600 --> 00:04:36,720
at the end of system call the kernel is

00:04:34,880 --> 00:04:39,360
buggy as we all know

00:04:36,720 --> 00:04:40,720
one type of the bug is uninitialized

00:04:39,360 --> 00:04:43,440
stack

00:04:40,720 --> 00:04:46,160
the adversary can exploit this type of

00:04:43,440 --> 00:04:48,400
bug using stack spray

00:04:46,160 --> 00:04:49,360
when the machine enters the kernel mode

00:04:48,400 --> 00:04:52,400
the kernel stack

00:04:49,360 --> 00:04:54,000
is used to store local variables

00:04:52,400 --> 00:04:55,919
some of the local variables can be

00:04:54,000 --> 00:04:57,520
similarly for example keys for

00:04:55,919 --> 00:04:59,919
encryption

00:04:57,520 --> 00:05:00,560
the adversary can use a system call to

00:04:59,919 --> 00:05:03,199
store

00:05:00,560 --> 00:05:03,840
the extensive data on kernel stack and

00:05:03,199 --> 00:05:06,160
then

00:05:03,840 --> 00:05:07,880
he or she can use another system call to

00:05:06,160 --> 00:05:11,199
trigger the

00:05:07,880 --> 00:05:13,440
uninitialized stack bug

00:05:11,199 --> 00:05:15,600
as part of the stack is uninitialized

00:05:13,440 --> 00:05:17,199
the segment of data is not erased from

00:05:15,600 --> 00:05:19,360
the stack

00:05:17,199 --> 00:05:21,280
later on when part of the stack is

00:05:19,360 --> 00:05:24,240
copied to user space

00:05:21,280 --> 00:05:26,800
the scientific data is leaked several

00:05:24,240 --> 00:05:30,000
weeks ago a stack-based information leak

00:05:26,800 --> 00:05:33,759
in a2mp of bluetooth is discovered

00:05:30,000 --> 00:05:35,680
basically practicing this idea

00:05:33,759 --> 00:05:37,360
to circumvent the leaking there has been

00:05:35,680 --> 00:05:40,000
proposed many mitigations

00:05:37,360 --> 00:05:41,199
for example randomize the base address

00:05:40,000 --> 00:05:43,360
of kernel stack

00:05:41,199 --> 00:05:46,479
so that the two system calls are not

00:05:43,360 --> 00:05:48,880
using the same memory region

00:05:46,479 --> 00:05:50,240
the two mitigations are mentioned here

00:05:48,880 --> 00:05:52,479
follow another approach with

00:05:50,240 --> 00:05:54,800
which is to poison the kernel stack at

00:05:52,479 --> 00:05:57,199
the end of system call

00:05:54,800 --> 00:05:58,560
since the sensitive data is erased the

00:05:57,199 --> 00:06:01,600
adversary cannot

00:05:58,560 --> 00:06:04,080
use the user uninitialized stack bug

00:06:01,600 --> 00:06:05,680
in the second call second system call to

00:06:04,080 --> 00:06:06,960
leak data

00:06:05,680 --> 00:06:08,720
the difference between the two

00:06:06,960 --> 00:06:11,680
mitigations are that

00:06:08,720 --> 00:06:12,400
the former is implemented in gcp gcc

00:06:11,680 --> 00:06:14,880
plugging

00:06:12,400 --> 00:06:15,680
and the latter is in kernel code base

00:06:14,880 --> 00:06:18,080
and also

00:06:15,680 --> 00:06:18,800
the form the former poisons the whole

00:06:18,080 --> 00:06:20,880
stack

00:06:18,800 --> 00:06:23,039
and the latter only erases the stack

00:06:20,880 --> 00:06:26,880
region that has been used in this

00:06:23,039 --> 00:06:27,759
system call no matter which mitigation

00:06:26,880 --> 00:06:30,000
is used

00:06:27,759 --> 00:06:32,880
both have the limitation that it only

00:06:30,000 --> 00:06:35,360
works for multisystem core attack

00:06:32,880 --> 00:06:36,479
because poisoning happens at the end of

00:06:35,360 --> 00:06:38,639
a system call

00:06:36,479 --> 00:06:41,120
if the adversary can read the data

00:06:38,639 --> 00:06:44,400
before returning back to user space

00:06:41,120 --> 00:06:46,240
information leaking is still doable

00:06:44,400 --> 00:06:48,639
in the exploitation approach i will

00:06:46,240 --> 00:06:50,880
describe in this talk a limited

00:06:48,639 --> 00:06:53,440
right primitive on corner heap can be

00:06:50,880 --> 00:06:55,759
used to leak the data on stack

00:06:53,440 --> 00:06:59,280
in one system call not using

00:06:55,759 --> 00:06:59,280
uninitialized stack bug

00:07:00,479 --> 00:07:06,080
on slab and slot one of the mitigations

00:07:03,039 --> 00:07:08,560
are config slab free list hardened

00:07:06,080 --> 00:07:10,560
this mitigation includes three patches

00:07:08,560 --> 00:07:14,240
and i show the diagram

00:07:10,560 --> 00:07:16,400
of one pass on the slide the three slots

00:07:14,240 --> 00:07:19,360
in slab allocator are chained

00:07:16,400 --> 00:07:22,080
using a single linked list the head of

00:07:19,360 --> 00:07:24,400
the list is named the free list

00:07:22,080 --> 00:07:26,560
when the slot is in free status the

00:07:24,400 --> 00:07:28,840
three the first eight bytes are used

00:07:26,560 --> 00:07:30,000
to start the address of the next slot in

00:07:28,840 --> 00:07:32,160
list

00:07:30,000 --> 00:07:33,599
this is a situation before the patch is

00:07:32,160 --> 00:07:35,680
applied

00:07:33,599 --> 00:07:37,039
after the patch is applied the first

00:07:35,680 --> 00:07:40,400
database of the free

00:07:37,039 --> 00:07:42,800
slot stores the xor result of

00:07:40,400 --> 00:07:44,240
first the address of the next slot which

00:07:42,800 --> 00:07:47,840
is free slot 3

00:07:44,240 --> 00:07:48,639
in the diagram second address of the 3ds

00:07:47,840 --> 00:07:52,240
to head

00:07:48,639 --> 00:07:54,720
and the third a random number

00:07:52,240 --> 00:07:55,360
without the patch the adversary can

00:07:54,720 --> 00:07:57,520
forge

00:07:55,360 --> 00:07:59,840
a fake address using a heap buffer

00:07:57,520 --> 00:08:02,160
overflow and mislead the kernel

00:07:59,840 --> 00:08:03,120
to return the memory region indicated by

00:08:02,160 --> 00:08:06,319
a fake address

00:08:03,120 --> 00:08:08,879
in the next allocation this allows

00:08:06,319 --> 00:08:12,240
adversary to be able to tempo the data

00:08:08,879 --> 00:08:13,120
stored in the fake address however with

00:08:12,240 --> 00:08:15,280
this patch

00:08:13,120 --> 00:08:16,479
the kernel will calculate to the address

00:08:15,280 --> 00:08:19,280
of the next free

00:08:16,479 --> 00:08:21,280
slot by reversing xor the data in the

00:08:19,280 --> 00:08:23,840
first databytes

00:08:21,280 --> 00:08:24,840
even if the adversary can forge the data

00:08:23,840 --> 00:08:27,840
using the heap above

00:08:24,840 --> 00:08:31,120
overflow the calculated address is

00:08:27,840 --> 00:08:31,680
not also the adversary once this is

00:08:31,120 --> 00:08:34,240
because

00:08:31,680 --> 00:08:36,640
the random number is involved in the

00:08:34,240 --> 00:08:39,039
calculation

00:08:36,640 --> 00:08:40,080
according to one study early this year

00:08:39,039 --> 00:08:42,880
the entropy

00:08:40,080 --> 00:08:45,920
of the hardening is very low and thus

00:08:42,880 --> 00:08:48,000
forging the address is possible

00:08:45,920 --> 00:08:50,240
as a complement in the exploitation

00:08:48,000 --> 00:08:53,120
approach i will describe in this talk

00:08:50,240 --> 00:08:53,680
the first a device after xor can be

00:08:53,120 --> 00:08:55,760
leaked

00:08:53,680 --> 00:08:57,040
with a limited right primitive on kernel

00:08:55,760 --> 00:08:59,519
heap

00:08:57,040 --> 00:09:01,120
the leaked aid bytes can then be used

00:08:59,519 --> 00:09:03,600
for forging

00:09:01,120 --> 00:09:06,480
i will call 8 bytes as a heap cookie in

00:09:03,600 --> 00:09:06,480
the following slides

00:09:07,519 --> 00:09:11,200
another mitigation on slab slump is a

00:09:09,839 --> 00:09:13,680
pair of config

00:09:11,200 --> 00:09:15,440
initial own alloy for on which is known

00:09:13,680 --> 00:09:18,000
as initial alloy

00:09:15,440 --> 00:09:18,959
and config initial on free default on

00:09:18,000 --> 00:09:22,880
which is known as

00:09:18,959 --> 00:09:24,800
initial on free two mitigations

00:09:22,880 --> 00:09:26,240
show some similarities with the stack

00:09:24,800 --> 00:09:28,480
poisoning we've discussed in the

00:09:26,240 --> 00:09:30,800
previous slides

00:09:28,480 --> 00:09:32,880
like a kernel stack the heap object

00:09:30,800 --> 00:09:34,839
encloses insensitive data

00:09:32,880 --> 00:09:36,399
like function pointer and keys for

00:09:34,839 --> 00:09:38,560
encryption

00:09:36,399 --> 00:09:39,600
without the mitigation the content in

00:09:38,560 --> 00:09:42,399
the hidden object

00:09:39,600 --> 00:09:43,920
is left unchanged after the object is

00:09:42,399 --> 00:09:46,640
freed

00:09:43,920 --> 00:09:49,279
later when a slot holding object is

00:09:46,640 --> 00:09:51,920
recycled for the following allocations

00:09:49,279 --> 00:09:52,800
the adversary can use an uninitialized

00:09:51,920 --> 00:09:55,920
heap bug

00:09:52,800 --> 00:09:58,080
to leak the data to this end

00:09:55,920 --> 00:09:59,440
the two mitigations are responsible for

00:09:58,080 --> 00:10:02,079
zeroing out the heap

00:09:59,440 --> 00:10:04,640
object at a time of freeing and

00:10:02,079 --> 00:10:07,200
reallocation respectively

00:10:04,640 --> 00:10:08,240
as such the scientific data is removed

00:10:07,200 --> 00:10:11,760
and liquid data is

00:10:08,240 --> 00:10:14,399
all zero the two mitigations

00:10:11,760 --> 00:10:16,240
work for use after free exploitation and

00:10:14,399 --> 00:10:18,720
a double free exploitation

00:10:16,240 --> 00:10:19,920
because the two types of vulnerability

00:10:18,720 --> 00:10:23,279
need to reason about

00:10:19,920 --> 00:10:25,440
freeing and reallocation however

00:10:23,279 --> 00:10:27,040
when the heap object is in use the

00:10:25,440 --> 00:10:30,160
scientific data is stopped

00:10:27,040 --> 00:10:31,600
on the hip on on the current heap this

00:10:30,160 --> 00:10:33,600
gives us the chance to leak the

00:10:31,600 --> 00:10:35,760
sensitive data in the heap object

00:10:33,600 --> 00:10:37,839
using the leak primitive obtained from

00:10:35,760 --> 00:10:41,839
limited right primitive

00:10:37,839 --> 00:10:41,839
i will elaborate on this later

00:10:42,240 --> 00:10:46,160
the next generation i want to describe

00:10:44,320 --> 00:10:47,920
is k-a-s-r

00:10:46,160 --> 00:10:50,079
kernel address space layout

00:10:47,920 --> 00:10:52,399
randomization

00:10:50,079 --> 00:10:53,680
on the slide i show part of the current

00:10:52,399 --> 00:10:56,480
memory layout

00:10:53,680 --> 00:10:56,959
with this mitigation the loaded context

00:10:56,480 --> 00:11:00,240
image

00:10:56,959 --> 00:11:02,720
could be anywhere from 8 0 to c0

00:11:00,240 --> 00:11:04,320
as long as it complies with alignment

00:11:02,720 --> 00:11:06,160
policy

00:11:04,320 --> 00:11:10,079
the loaded economy modules could be

00:11:06,160 --> 00:11:13,120
anywhere from c0 to c040 as long as

00:11:10,079 --> 00:11:16,480
it complies with alignment policy

00:11:13,120 --> 00:11:19,360
this is a situation of x64 and other

00:11:16,480 --> 00:11:21,839
architectures are similar

00:11:19,360 --> 00:11:22,399
this mitigation works because it's very

00:11:21,839 --> 00:11:24,959
hard

00:11:22,399 --> 00:11:27,360
for those exploitation approaches to

00:11:24,959 --> 00:11:28,959
reliably jump to the target code

00:11:27,360 --> 00:11:32,160
if they want to execute current

00:11:28,959 --> 00:11:34,640
instructions for medical school

00:11:32,160 --> 00:11:35,600
to defeat this mitigation the commonly

00:11:34,640 --> 00:11:38,240
used approach

00:11:35,600 --> 00:11:40,240
is to leak address of a global variable

00:11:38,240 --> 00:11:42,399
for or function

00:11:40,240 --> 00:11:43,360
then the adversary can calculate the

00:11:42,399 --> 00:11:45,519
base address

00:11:43,360 --> 00:11:47,680
of loaded current image throughout

00:11:45,519 --> 00:11:50,240
through offset

00:11:47,680 --> 00:11:51,839
that's why i say in the previous slides

00:11:50,240 --> 00:11:53,760
the return address and the function

00:11:51,839 --> 00:11:56,079
pointer is sensitive data

00:11:53,760 --> 00:11:57,360
because this restarts address or

00:11:56,079 --> 00:12:00,079
functions

00:11:57,360 --> 00:12:01,519
once they are valid usually kit k a sdr

00:12:00,079 --> 00:12:05,600
can be bypassed

00:12:01,519 --> 00:12:08,079
this is the first shortcoming of kasr

00:12:05,600 --> 00:12:09,200
another shortcoming is a low entropy

00:12:08,079 --> 00:12:11,120
because they are on

00:12:09,200 --> 00:12:12,480
there only so many locations the chrono

00:12:11,120 --> 00:12:14,560
can fit in

00:12:12,480 --> 00:12:18,480
someone thinks the tackle can guess the

00:12:14,560 --> 00:12:22,160
base address without too much trouble

00:12:18,480 --> 00:12:25,120
as such fg kscr was proposed

00:12:22,160 --> 00:12:26,880
which implements functional granularity

00:12:25,120 --> 00:12:28,639
kscr

00:12:26,880 --> 00:12:29,920
i cannot go into details of this

00:12:28,639 --> 00:12:32,720
mitigation today

00:12:29,920 --> 00:12:35,200
because it is still in development the

00:12:32,720 --> 00:12:37,120
main idea is to randomize the address

00:12:35,200 --> 00:12:38,480
of functions when loading the current

00:12:37,120 --> 00:12:40,720
image

00:12:38,480 --> 00:12:41,839
the entropy is much higher in this

00:12:40,720 --> 00:12:44,480
granularity

00:12:41,839 --> 00:12:45,040
and one leaking is far away from being

00:12:44,480 --> 00:12:47,279
enough

00:12:45,040 --> 00:12:49,360
to defeat this fine granularity

00:12:47,279 --> 00:12:51,760
mitigation

00:12:49,360 --> 00:12:53,040
similar idea has already been used in

00:12:51,760 --> 00:12:55,519
open bsd

00:12:53,040 --> 00:12:56,720
and i'm very willing to see it to be

00:12:55,519 --> 00:13:00,639
merged in linux

00:12:56,720 --> 00:13:00,639
because i believe it's very powerful

00:13:01,519 --> 00:13:04,800
on this page i list the two types of

00:13:03,839 --> 00:13:07,120
sensitive data

00:13:04,800 --> 00:13:09,040
that can be leaked from kernel according

00:13:07,120 --> 00:13:12,320
to angel

00:13:09,040 --> 00:13:15,200
conor vallos exploit

00:13:12,320 --> 00:13:16,000
the first is the content of the fire etc

00:13:15,200 --> 00:13:19,440
shadow

00:13:16,000 --> 00:13:21,279
in genome keyring demo this file

00:13:19,440 --> 00:13:24,480
constants the harsh value

00:13:21,279 --> 00:13:26,720
of the user's passwords the adversary

00:13:24,480 --> 00:13:28,639
can use harsh collision to reverse

00:13:26,720 --> 00:13:31,760
engineer the hashed value

00:13:28,639 --> 00:13:34,399
and obtain the password the earner

00:13:31,760 --> 00:13:35,920
of this file is root and the group is

00:13:34,399 --> 00:13:38,720
shadow

00:13:35,920 --> 00:13:40,800
with the league primitive adversary can

00:13:38,720 --> 00:13:41,600
scan the physical memory to search for

00:13:40,800 --> 00:13:44,079
the pattern

00:13:41,600 --> 00:13:45,279
because the first entry of the file is

00:13:44,079 --> 00:13:48,800
always for root

00:13:45,279 --> 00:13:50,720
and loaded to the beginning of the page

00:13:48,800 --> 00:13:51,920
the second is the interrupt descriptor

00:13:50,720 --> 00:13:54,079
table

00:13:51,920 --> 00:13:56,000
when interrupt happens the kernel will

00:13:54,079 --> 00:13:57,839
jump to the interrupt procedure for

00:13:56,000 --> 00:14:00,079
further process

00:13:57,839 --> 00:14:03,120
the offset to the procedural entry is

00:14:00,079 --> 00:14:04,240
start in the table if the adversary can

00:14:03,120 --> 00:14:06,720
leak the offset

00:14:04,240 --> 00:14:08,240
he or she can calculate the base address

00:14:06,720 --> 00:14:11,360
of loaded kernel image

00:14:08,240 --> 00:14:13,120
and thus bypass kascr

00:14:11,360 --> 00:14:14,399
there are many other types of synthetic

00:14:13,120 --> 00:14:16,800
data in kernel

00:14:14,399 --> 00:14:17,600
due to the time limit i cannot enumerate

00:14:16,800 --> 00:14:20,720
them and i'm

00:14:17,600 --> 00:14:20,720
very happy to learn more

00:14:21,600 --> 00:14:26,320
the exploitation approach i want to

00:14:23,440 --> 00:14:29,440
describe today is not a new attack

00:14:26,320 --> 00:14:34,160
it's used in pong2o 2017

00:14:29,440 --> 00:14:36,639
for cbe 2017-7184

00:14:34,160 --> 00:14:39,279
in exploitation of this vulnerability

00:14:36,639 --> 00:14:43,839
the attacker uses a flexible structure

00:14:39,279 --> 00:14:46,160
named transform the play state

00:14:43,839 --> 00:14:48,800
as shown in the diagram on the slide

00:14:46,160 --> 00:14:51,360
this structure has two fields

00:14:48,800 --> 00:14:51,920
one field is a bitmap length which is an

00:14:51,360 --> 00:14:54,240
integer

00:14:51,920 --> 00:14:55,760
and another is build map which is a

00:14:54,240 --> 00:14:58,079
buffer

00:14:55,760 --> 00:15:00,320
the length of bitmap is determined

00:14:58,079 --> 00:15:01,680
dynamically and indicated by bitmap

00:15:00,320 --> 00:15:04,399
length

00:15:01,680 --> 00:15:05,760
when kernel uses a structure it obtains

00:15:04,399 --> 00:15:09,040
the length of bitmap

00:15:05,760 --> 00:15:10,079
from bitmap length to do the

00:15:09,040 --> 00:15:12,639
exploitation

00:15:10,079 --> 00:15:13,440
the attacker performs heap feng shui and

00:15:12,639 --> 00:15:16,160
places

00:15:13,440 --> 00:15:18,240
transform replace that esn right after

00:15:16,160 --> 00:15:20,079
the vulnerable object

00:15:18,240 --> 00:15:22,320
then a tackle triggers the heap of

00:15:20,079 --> 00:15:23,839
buffer overflow to overwrite bitmap

00:15:22,320 --> 00:15:26,320
length

00:15:23,839 --> 00:15:28,399
the build map length is enlarged and

00:15:26,320 --> 00:15:30,959
misleads the kernel to believe

00:15:28,399 --> 00:15:33,440
the size of bin map is larger than

00:15:30,959 --> 00:15:35,680
actual size

00:15:33,440 --> 00:15:37,040
later on when the received message

00:15:35,680 --> 00:15:39,519
system call comes

00:15:37,040 --> 00:15:40,399
the content in the bitmap is copied to

00:15:39,519 --> 00:15:43,680
user space

00:15:40,399 --> 00:15:46,480
while narrating pulled function

00:15:43,680 --> 00:15:46,880
since the bitmap lens is enlarged the

00:15:46,480 --> 00:15:49,279
heap

00:15:46,880 --> 00:15:50,240
region after the bitmap is also copied

00:15:49,279 --> 00:15:54,000
out causing

00:15:50,240 --> 00:15:55,040
an overread the attacker places the file

00:15:54,000 --> 00:15:58,160
structure

00:15:55,040 --> 00:15:59,759
after the bitmap the file structure has

00:15:58,160 --> 00:16:02,240
a function pointer field

00:15:59,759 --> 00:16:02,959
named fop which points to a static

00:16:02,240 --> 00:16:06,000
variable

00:16:02,959 --> 00:16:09,360
ext4 file operations

00:16:06,000 --> 00:16:10,240
by linking the value of the ext4 file

00:16:09,360 --> 00:16:13,199
operations

00:16:10,240 --> 00:16:13,759
the taco knows address of the static

00:16:13,199 --> 00:16:16,079
variable

00:16:13,759 --> 00:16:17,519
and then calculates the base address of

00:16:16,079 --> 00:16:21,680
loaded kernel image

00:16:17,519 --> 00:16:22,000
for bypassing kslr the flexible object

00:16:21,680 --> 00:16:25,519
has

00:16:22,000 --> 00:16:28,480
two just two advantages in exploitation

00:16:25,519 --> 00:16:30,240
one is its ability to leak data another

00:16:28,480 --> 00:16:32,800
is the size of an object

00:16:30,240 --> 00:16:35,040
is determined dynamically so it can be

00:16:32,800 --> 00:16:37,759
allocated to several general caches

00:16:35,040 --> 00:16:40,560
to be paired with vulnerable object and

00:16:37,759 --> 00:16:40,560
victim object

00:16:41,360 --> 00:16:44,399
we've talked about standard flexible

00:16:43,279 --> 00:16:46,880
structure

00:16:44,399 --> 00:16:48,000
yes which has a lens field and an

00:16:46,880 --> 00:16:50,880
adjustable buffer

00:16:48,000 --> 00:16:51,759
at the end of the structure elastic

00:16:50,880 --> 00:16:54,959
object is

00:16:51,759 --> 00:16:57,199
extended from flexible object on the

00:16:54,959 --> 00:16:57,839
right side of the slide i display three

00:16:57,199 --> 00:17:01,519
ways

00:16:57,839 --> 00:17:02,639
of extension the first way is to have a

00:17:01,519 --> 00:17:04,480
large buffer

00:17:02,639 --> 00:17:06,799
i have a large buffer defined in the

00:17:04,480 --> 00:17:08,959
middle of a data object

00:17:06,799 --> 00:17:10,959
a length field within that object

00:17:08,959 --> 00:17:13,439
indicates the actual

00:17:10,959 --> 00:17:14,240
buffer size or more precisely speaking

00:17:13,439 --> 00:17:17,919
the actual

00:17:14,240 --> 00:17:20,160
bytes used for storing data at the time

00:17:17,919 --> 00:17:23,199
of defining the actual number of bytes

00:17:20,160 --> 00:17:25,600
used for storing data connor typically

00:17:23,199 --> 00:17:27,600
examines the length field and ensures

00:17:25,600 --> 00:17:29,440
that it doesn't go beyond the boundary

00:17:27,600 --> 00:17:31,919
of the large buffer

00:17:29,440 --> 00:17:33,840
however we discover that the counter

00:17:31,919 --> 00:17:35,840
doesn't always enforce

00:17:33,840 --> 00:17:38,480
this essential check at a time of

00:17:35,840 --> 00:17:41,520
reading data from that buffer

00:17:38,480 --> 00:17:44,000
as such it eases an attacker's ability

00:17:41,520 --> 00:17:45,120
to manipulate the lens field and thus

00:17:44,000 --> 00:17:48,880
construct a buffer

00:17:45,120 --> 00:17:51,679
overread in the second and third way

00:17:48,880 --> 00:17:52,720
the two implementations do not enclose

00:17:51,679 --> 00:17:55,360
the lens field

00:17:52,720 --> 00:17:56,559
and adjustable buffer in the same kernel

00:17:55,360 --> 00:17:59,360
object

00:17:56,559 --> 00:18:00,000
instead they place the lens field and

00:17:59,360 --> 00:18:03,360
the adjustable

00:18:00,000 --> 00:18:05,280
buffer in two individual cone objects

00:18:03,360 --> 00:18:06,799
the difference between the second and

00:18:05,280 --> 00:18:09,919
third implementation

00:18:06,799 --> 00:18:11,919
is that one implementation contains

00:18:09,919 --> 00:18:14,480
an explicit reference to the adjustable

00:18:11,919 --> 00:18:15,679
buffer in contrast the third

00:18:14,480 --> 00:18:18,320
implementation

00:18:15,679 --> 00:18:19,679
references the adjustable buffer through

00:18:18,320 --> 00:18:22,320
a third intermediate

00:18:19,679 --> 00:18:22,320
kernel object

00:18:24,720 --> 00:18:28,240
after the extension let's see how we can

00:18:26,720 --> 00:18:31,600
perform exploitation

00:18:28,240 --> 00:18:32,799
using elastic object the assumption of

00:18:31,600 --> 00:18:34,160
this attack is

00:18:32,799 --> 00:18:36,000
we've already obtained the right

00:18:34,160 --> 00:18:38,320
primitive on chrono heap

00:18:36,000 --> 00:18:39,520
which tempers the lens field as well as

00:18:38,320 --> 00:18:42,400
a point of field

00:18:39,520 --> 00:18:44,799
if the elastic object is implemented in

00:18:42,400 --> 00:18:47,120
the second or third way

00:18:44,799 --> 00:18:48,000
later on the value of lens field is

00:18:47,120 --> 00:18:50,400
propagated

00:18:48,000 --> 00:18:52,080
to the size argument of copy to user

00:18:50,400 --> 00:18:53,840
function

00:18:52,080 --> 00:18:56,160
copy to user function has three

00:18:53,840 --> 00:18:58,799
arguments the first argument

00:18:56,160 --> 00:19:00,480
is destination indicating where the data

00:18:58,799 --> 00:19:02,880
is copied to

00:19:00,480 --> 00:19:03,600
the second argument is source which

00:19:02,880 --> 00:19:06,880
indicates

00:19:03,600 --> 00:19:07,679
where the data is copied from the third

00:19:06,880 --> 00:19:10,400
argument is

00:19:07,679 --> 00:19:12,400
size which represents how many bytes of

00:19:10,400 --> 00:19:14,480
data to copy

00:19:12,400 --> 00:19:16,160
now we've already controlled the size

00:19:14,480 --> 00:19:18,080
argument

00:19:16,160 --> 00:19:19,520
on the right side of the slide i show

00:19:18,080 --> 00:19:22,640
three situations

00:19:19,520 --> 00:19:24,720
of where the source could come from

00:19:22,640 --> 00:19:27,840
the first situation is the source

00:19:24,720 --> 00:19:30,480
argument is the address of kernel stack

00:19:27,840 --> 00:19:31,120
in this situation if we enlarge the size

00:19:30,480 --> 00:19:33,280
value

00:19:31,120 --> 00:19:34,799
using the right primitive we can over

00:19:33,280 --> 00:19:36,960
read the kernel stack

00:19:34,799 --> 00:19:39,520
and leak the stack narry and return

00:19:36,960 --> 00:19:41,440
address to user space

00:19:39,520 --> 00:19:43,360
the second situation is the source

00:19:41,440 --> 00:19:44,480
argument is the address of a counter

00:19:43,360 --> 00:19:46,559
heap

00:19:44,480 --> 00:19:47,919
we can overrate the corner heap to just

00:19:46,559 --> 00:19:50,960
close function pointer

00:19:47,919 --> 00:19:53,440
and keep cooking the third

00:19:50,960 --> 00:19:54,640
situation is the source argument is from

00:19:53,440 --> 00:19:56,960
the point of field

00:19:54,640 --> 00:19:57,679
in the elastic object and is also

00:19:56,960 --> 00:19:59,440
tempered

00:19:57,679 --> 00:20:01,039
by its adversary using the right

00:19:59,440 --> 00:20:03,120
primitive

00:20:01,039 --> 00:20:06,080
in this situation we can make the source

00:20:03,120 --> 00:20:08,159
argument to be any kernel address as

00:20:06,080 --> 00:20:11,120
such we can leak sensitive data

00:20:08,159 --> 00:20:11,679
like etc shadow or interrupt descriptor

00:20:11,120 --> 00:20:13,280
table

00:20:11,679 --> 00:20:15,679
which we mentioned in the previous

00:20:13,280 --> 00:20:15,679
slides

00:20:16,240 --> 00:20:21,600
the severity of this attack is obvious

00:20:19,280 --> 00:20:22,720
if the advisory has the right primitive

00:20:21,600 --> 00:20:25,280
on kernel heap

00:20:22,720 --> 00:20:26,480
by triggering vulnerabilities like slab

00:20:25,280 --> 00:20:28,960
autobahn right

00:20:26,480 --> 00:20:30,480
use up the free and double free he or

00:20:28,960 --> 00:20:32,840
she can transfer

00:20:30,480 --> 00:20:34,400
this right primitive to obtain a leak

00:20:32,840 --> 00:20:37,280
primitive

00:20:34,400 --> 00:20:38,480
this capability enables adversary to

00:20:37,280 --> 00:20:41,600
leak stationary

00:20:38,480 --> 00:20:44,720
return address encrypted heap cookie

00:20:41,600 --> 00:20:45,840
function pointer etc shadow interrupt

00:20:44,720 --> 00:20:49,200
descriptor table

00:20:45,840 --> 00:20:50,559
and many other sensitive data with these

00:20:49,200 --> 00:20:52,880
sensitive data in hand

00:20:50,559 --> 00:20:56,559
it becomes easier for the tackles to

00:20:52,880 --> 00:20:56,559
perform following exploitation

00:20:56,960 --> 00:21:01,360
regarding the generality of this attack

00:20:59,039 --> 00:21:03,679
is unknown

00:21:01,360 --> 00:21:05,200
first we don't know what else channel

00:21:03,679 --> 00:21:08,159
functions in kernel

00:21:05,200 --> 00:21:09,360
except user u copy to user can provide

00:21:08,159 --> 00:21:11,840
us with the ability

00:21:09,360 --> 00:21:13,280
to communicate between counter space and

00:21:11,840 --> 00:21:15,919
user space

00:21:13,280 --> 00:21:16,640
second how many elastic structures and

00:21:15,919 --> 00:21:19,360
objects

00:21:16,640 --> 00:21:20,960
are there in the kernel codebase if we

00:21:19,360 --> 00:21:24,400
only have three or four

00:21:20,960 --> 00:21:26,240
it's very hard to cover most stab caches

00:21:24,400 --> 00:21:29,280
let alone to say let alone to say

00:21:26,240 --> 00:21:31,919
pairing them with vulnerability

00:21:29,280 --> 00:21:33,760
the third question is even if we have

00:21:31,919 --> 00:21:35,679
enough that elastic structures

00:21:33,760 --> 00:21:37,120
and down the mean the lens field and the

00:21:35,679 --> 00:21:38,720
point of field of them

00:21:37,120 --> 00:21:40,320
can be propagated to the channel

00:21:38,720 --> 00:21:42,000
functions

00:21:40,320 --> 00:21:44,000
without this guarantee that the

00:21:42,000 --> 00:21:46,320
adversary can hardly control

00:21:44,000 --> 00:21:48,080
the size argument as well as the source

00:21:46,320 --> 00:21:51,280
argument

00:21:48,080 --> 00:21:53,280
the last question giving a vulnerability

00:21:51,280 --> 00:21:55,520
does it provide us with the right

00:21:53,280 --> 00:21:58,320
primitive to override the length field

00:21:55,520 --> 00:21:59,679
and point of field it's possible that

00:21:58,320 --> 00:22:03,039
most vulnerabilities

00:21:59,679 --> 00:22:05,679
don't have that strong capability

00:22:03,039 --> 00:22:06,799
however generality problem is of vital

00:22:05,679 --> 00:22:08,960
importance

00:22:06,799 --> 00:22:11,440
because it's related to the question

00:22:08,960 --> 00:22:12,159
that do we need to pay attention to this

00:22:11,440 --> 00:22:14,799
attack

00:22:12,159 --> 00:22:16,320
and do we need a mitigation if the

00:22:14,799 --> 00:22:18,799
attack is very ad hoc

00:22:16,320 --> 00:22:19,919
i don't see any necessity to build a

00:22:18,799 --> 00:22:23,120
medication

00:22:19,919 --> 00:22:23,679
probably simple patching is enough as

00:22:23,120 --> 00:22:26,480
such

00:22:23,679 --> 00:22:30,240
our research work many focus on studying

00:22:26,480 --> 00:22:30,240
the generality of this attack

00:22:31,039 --> 00:22:34,960
first things first we identify some

00:22:33,280 --> 00:22:38,000
channel functions in the kernel

00:22:34,960 --> 00:22:39,760
and lift them on the slide we group them

00:22:38,000 --> 00:22:42,320
into three categories

00:22:39,760 --> 00:22:44,240
the first category is memory copier api

00:22:42,320 --> 00:22:46,799
which is called to user

00:22:44,240 --> 00:22:47,440
the second one is specific to narrowing

00:22:46,799 --> 00:22:49,760
socket

00:22:47,440 --> 00:22:51,919
which is a net working between between

00:22:49,760 --> 00:22:54,400
counter space and user space

00:22:51,919 --> 00:22:57,039
to use this functionality requires the

00:22:54,400 --> 00:23:00,559
capability of network admin

00:22:57,039 --> 00:23:04,400
which is granted in the user's namespace

00:23:00,559 --> 00:23:06,559
take net link put function as an example

00:23:04,400 --> 00:23:08,400
attribute lens which is highlighted

00:23:06,559 --> 00:23:10,960
highlighted with underline

00:23:08,400 --> 00:23:11,840
is a size argument and the data which is

00:23:10,960 --> 00:23:14,720
involved is

00:23:11,840 --> 00:23:15,679
source argument the two the third

00:23:14,720 --> 00:23:18,640
category is

00:23:15,679 --> 00:23:19,200
general networking for example skb put

00:23:18,640 --> 00:23:21,760
data

00:23:19,200 --> 00:23:22,559
in which length is a size argument and

00:23:21,760 --> 00:23:26,000
data

00:23:22,559 --> 00:23:26,559
is a source argument some channel

00:23:26,000 --> 00:23:28,640
functions

00:23:26,559 --> 00:23:30,320
are the combination of two functions for

00:23:28,640 --> 00:23:33,520
example in that link

00:23:30,320 --> 00:23:36,320
the return value of native domestic data

00:23:33,520 --> 00:23:38,880
is a source argument which is later used

00:23:36,320 --> 00:23:41,120
in memory copy function

00:23:38,880 --> 00:23:42,240
the size argument is count in memory

00:23:41,120 --> 00:23:44,159
copy

00:23:42,240 --> 00:23:46,640
no matter what the function prototypes

00:23:44,159 --> 00:23:47,279
are all of all of them have a source

00:23:46,640 --> 00:23:50,720
argument

00:23:47,279 --> 00:23:54,000
and a size argument our analysis begins

00:23:50,720 --> 00:23:54,000
from these channel functions

00:23:55,120 --> 00:23:59,760
the first step in our static analysis is

00:23:57,760 --> 00:24:02,799
to identify the leaking angle

00:23:59,760 --> 00:24:05,600
which is invoking to channel functions

00:24:02,799 --> 00:24:06,720
i use red to represent source argument

00:24:05,600 --> 00:24:08,400
and the green

00:24:06,720 --> 00:24:10,080
for size arguments in the channel

00:24:08,400 --> 00:24:12,559
function

00:24:10,080 --> 00:24:14,000
the second step is to check where is

00:24:12,559 --> 00:24:16,000
this length from

00:24:14,000 --> 00:24:18,559
in the diagram the lens has flown a

00:24:16,000 --> 00:24:22,400
structural variable named u

00:24:18,559 --> 00:24:23,840
payload its type is user use user key

00:24:22,400 --> 00:24:25,840
payload

00:24:23,840 --> 00:24:27,200
the third step is to check where is the

00:24:25,840 --> 00:24:29,360
source from

00:24:27,200 --> 00:24:31,200
in the diagram the source is the return

00:24:29,360 --> 00:24:33,360
value of k malloc

00:24:31,200 --> 00:24:35,039
the type of the source is the user

00:24:33,360 --> 00:24:36,960
keypad of the two

00:24:35,039 --> 00:24:40,000
we can clearly see the source and the

00:24:36,960 --> 00:24:41,679
lengths are from the same structure type

00:24:40,000 --> 00:24:43,840
besides we can learn that this

00:24:41,679 --> 00:24:45,919
structural variable is on the heap

00:24:43,840 --> 00:24:47,360
because it is generated through

00:24:45,919 --> 00:24:49,679
allocation

00:24:47,360 --> 00:24:51,520
what's more user key payload is a

00:24:49,679 --> 00:24:54,080
standard flexible structure

00:24:51,520 --> 00:24:55,760
because its size is a constant plus a

00:24:54,080 --> 00:24:57,679
variable

00:24:55,760 --> 00:24:59,520
the offset of length field and the

00:24:57,679 --> 00:25:01,039
adjustable buffer can also be tracked

00:24:59,520 --> 00:25:03,360
down

00:25:01,039 --> 00:25:04,799
through above analysis we can learn

00:25:03,360 --> 00:25:08,559
which slab cache

00:25:04,799 --> 00:25:08,559
is responsible for holding the object

00:25:09,120 --> 00:25:12,320
the last step of the analysis is to

00:25:11,520 --> 00:25:14,559
collect

00:25:12,320 --> 00:25:16,000
the constraints along the path from the

00:25:14,559 --> 00:25:19,600
ankle retrievals

00:25:16,000 --> 00:25:22,000
to the ankle that leaks data we do this

00:25:19,600 --> 00:25:24,320
examination because we want to see

00:25:22,000 --> 00:25:27,600
whether a kernel enforces a checking

00:25:24,320 --> 00:25:28,000
of landsphere's legal value range if the

00:25:27,600 --> 00:25:30,480
kernel

00:25:28,000 --> 00:25:33,120
says the lens cannot be too large the

00:25:30,480 --> 00:25:35,600
leaking probably doesn't work

00:25:33,120 --> 00:25:36,640
in the example on the slide the current

00:25:35,600 --> 00:25:39,360
only ensures

00:25:36,640 --> 00:25:40,080
that the user control the parameter

00:25:39,360 --> 00:25:43,279
buffers

00:25:40,080 --> 00:25:44,320
is larger than the data length therefore

00:25:43,279 --> 00:25:48,159
this checking doesn't

00:25:44,320 --> 00:25:48,159
influence the data leaking

00:25:48,480 --> 00:25:52,320
finally we obtain a record for each

00:25:51,039 --> 00:25:55,440
identified elastic

00:25:52,320 --> 00:25:56,880
structure we know the structure name the

00:25:55,440 --> 00:25:59,039
cache holding the object

00:25:56,880 --> 00:26:01,120
the offset of the length field and point

00:25:59,039 --> 00:26:03,600
of field allocation sites

00:26:01,120 --> 00:26:05,919
leaking sites as well as all types of

00:26:03,600 --> 00:26:08,720
sensitive data can be kit

00:26:05,919 --> 00:26:09,760
in total the static analysis tracks down

00:26:08,720 --> 00:26:11,360
14 9

00:26:09,760 --> 00:26:12,799
elastic structures in default

00:26:11,360 --> 00:26:14,799
configuration

00:26:12,799 --> 00:26:16,159
we use kernel fuzzing and a manual

00:26:14,799 --> 00:26:19,440
analysis confirmed

00:26:16,159 --> 00:26:19,440
38 of them

00:26:19,840 --> 00:26:26,640
we'll list these structures here

00:26:23,440 --> 00:26:29,440
in the table the first column represents

00:26:26,640 --> 00:26:30,400
which cache the object can reside in the

00:26:29,440 --> 00:26:33,360
second column

00:26:30,400 --> 00:26:35,120
is the structural name the third column

00:26:33,360 --> 00:26:36,480
is the offset of lens field and the

00:26:35,120 --> 00:26:38,720
point of field

00:26:36,480 --> 00:26:40,240
the fourth column is what sensitive data

00:26:38,720 --> 00:26:42,000
can be leaked

00:26:40,240 --> 00:26:44,480
the fifth guardian is a privilege

00:26:42,000 --> 00:26:48,000
required to operate the object

00:26:44,480 --> 00:26:50,640
the last column is the past constraints

00:26:48,000 --> 00:26:54,159
to sum up most general caches are

00:26:50,640 --> 00:26:57,200
covered by identified structures

00:26:54,159 --> 00:26:59,840
note that the number 36 and 38

00:26:57,200 --> 00:27:01,600
are for structures not objects if we

00:26:59,840 --> 00:27:04,240
count the number in objects

00:27:01,600 --> 00:27:05,120
and program sites that are used objects

00:27:04,240 --> 00:27:08,400
the static

00:27:05,120 --> 00:27:09,360
statistics can be thousands from this

00:27:08,400 --> 00:27:12,400
perspective

00:27:09,360 --> 00:27:14,880
the elastic objects are pervasive in

00:27:12,400 --> 00:27:14,880
code base

00:27:15,520 --> 00:27:22,000
we used 31 vulnerabilities to examine

00:27:18,880 --> 00:27:26,000
what we can do using elastic objects

00:27:22,000 --> 00:27:29,120
the results show that 23 vulnerabilities

00:27:26,000 --> 00:27:31,039
is enabled with ka slr bypassing and the

00:27:29,120 --> 00:27:33,520
heap cookies leaking

00:27:31,039 --> 00:27:34,080
12 of them can leak stack nary and five

00:27:33,520 --> 00:27:37,279
of them

00:27:34,080 --> 00:27:38,960
can perform arbitrary read thus i want

00:27:37,279 --> 00:27:41,679
to draw the conclusion that

00:27:38,960 --> 00:27:49,440
elastic object attack is general in

00:27:41,679 --> 00:27:52,240
linux kernel

00:27:49,440 --> 00:27:53,279
how about other operating system kernels

00:27:52,240 --> 00:27:56,799
in xmu

00:27:53,279 --> 00:28:00,840
the static analysis tracks down

00:27:56,799 --> 00:28:02,000
16 structures and in three bst 20

00:28:00,840 --> 00:28:05,200
structures

00:28:02,000 --> 00:28:05,440
we used in total nine cves in freebsd

00:28:05,200 --> 00:28:09,600
and

00:28:05,440 --> 00:28:11,919
xmu five of them can bypass kslr

00:28:09,600 --> 00:28:15,039
three of them can leak keep cookies

00:28:11,919 --> 00:28:17,679
because freebsd doesn't have heap cookie

00:28:15,039 --> 00:28:18,399
three of them can perform actually read

00:28:17,679 --> 00:28:21,039
it seems

00:28:18,399 --> 00:28:22,159
elastic object attack is an issue not

00:28:21,039 --> 00:28:26,399
only in linux

00:28:22,159 --> 00:28:26,399
but also in freebsd and xnu

00:28:27,360 --> 00:28:31,520
to mitigate this elastic object attack

00:28:30,000 --> 00:28:33,440
there are several mitigations in the

00:28:31,520 --> 00:28:36,640
linux kernel that seems work

00:28:33,440 --> 00:28:38,480
but i don't think so let me tell you why

00:28:36,640 --> 00:28:40,559
the first potential mitigation is

00:28:38,480 --> 00:28:42,720
greatest randomization

00:28:40,559 --> 00:28:44,000
without this mitigation the freedom

00:28:42,720 --> 00:28:46,880
slots are changed

00:28:44,000 --> 00:28:47,760
in the list linearly this means the

00:28:46,880 --> 00:28:51,120
three slots

00:28:47,760 --> 00:28:51,679
are physically continuous with this

00:28:51,120 --> 00:28:53,840
feature

00:28:51,679 --> 00:28:57,840
the adversary can predict the slab

00:28:53,840 --> 00:29:00,480
layout and perform stable hip function

00:28:57,840 --> 00:29:01,200
this mitigation the free slots are

00:29:00,480 --> 00:29:05,760
shuffled

00:29:01,200 --> 00:29:07,600
when kernel kernel creates slab cash

00:29:05,760 --> 00:29:09,279
thus the other three slots are

00:29:07,600 --> 00:29:11,039
randomized

00:29:09,279 --> 00:29:13,919
in this way that adversary cannot

00:29:11,039 --> 00:29:16,399
predict this lab layout and it's harder

00:29:13,919 --> 00:29:17,120
for he or she to exploit slab out of

00:29:16,399 --> 00:29:20,799
bound right

00:29:17,120 --> 00:29:23,679
vulnerabilities the limitations of this

00:29:20,799 --> 00:29:25,520
mitigation are first it has no effects

00:29:23,679 --> 00:29:27,120
on use after free and double free

00:29:25,520 --> 00:29:29,279
exploitation

00:29:27,120 --> 00:29:30,720
this is because the exploitation of

00:29:29,279 --> 00:29:33,840
these two bytes

00:29:30,720 --> 00:29:36,080
doesn't require to predict a slab layout

00:29:33,840 --> 00:29:38,240
second there are many second there are

00:29:36,080 --> 00:29:39,279
many bypassing techniques against this

00:29:38,240 --> 00:29:42,480
medication

00:29:39,279 --> 00:29:43,679
for example hip groom which is to first

00:29:42,480 --> 00:29:46,960
allocate the bones of

00:29:43,679 --> 00:29:49,039
placehold objects and the victim object

00:29:46,960 --> 00:29:50,799
then the adversary frees the placeholder

00:29:49,039 --> 00:29:53,679
objects and leaves holes

00:29:50,799 --> 00:29:55,360
on heap after this he or she can

00:29:53,679 --> 00:29:59,200
allocate the vulnerable object

00:29:55,360 --> 00:30:02,240
to the host to perform hip function

00:29:59,200 --> 00:30:04,480
another technique is the 3ds reversal

00:30:02,240 --> 00:30:06,000
due to the time limit i can i will not

00:30:04,480 --> 00:30:09,840
elaborate on this

00:30:06,000 --> 00:30:09,840
because more details can be found online

00:30:10,320 --> 00:30:16,240
the second potential mitigation is

00:30:12,399 --> 00:30:18,399
config gcc plugin random structure

00:30:16,240 --> 00:30:20,080
this mitigation tries to randomize the

00:30:18,399 --> 00:30:22,880
order of fields in the structure

00:30:20,080 --> 00:30:23,679
after the compilation phase it prevents

00:30:22,880 --> 00:30:25,840
the tackles

00:30:23,679 --> 00:30:28,399
from predicting the offsets of sensitive

00:30:25,840 --> 00:30:30,240
data within the structure

00:30:28,399 --> 00:30:32,799
take the structure on the slide as an

00:30:30,240 --> 00:30:34,159
example the tackles want to overwrite

00:30:32,799 --> 00:30:36,640
function pointer

00:30:34,159 --> 00:30:38,640
from the function point of field initial

00:30:36,640 --> 00:30:41,520
to hijack control flow

00:30:38,640 --> 00:30:43,120
without the randomization the offset of

00:30:41,520 --> 00:30:46,240
initial field is fixed

00:30:43,120 --> 00:30:48,320
and predictable with the randomization

00:30:46,240 --> 00:30:49,520
the initial field is shuffled to another

00:30:48,320 --> 00:30:52,559
order

00:30:49,520 --> 00:30:55,039
thus the override doesn't always work

00:30:52,559 --> 00:30:56,399
as such this mitigation seems a threat

00:30:55,039 --> 00:30:59,120
to the attack

00:30:56,399 --> 00:31:01,039
however i want to say that this defense

00:30:59,120 --> 00:31:03,679
relies on random seed to perform

00:31:01,039 --> 00:31:04,559
randomization and the protection of this

00:31:03,679 --> 00:31:07,679
seed is not

00:31:04,559 --> 00:31:10,960
trivial for example linux distros

00:31:07,679 --> 00:31:11,440
have to expose this randomized random

00:31:10,960 --> 00:31:13,600
seed

00:31:11,440 --> 00:31:15,120
to their users for building third-party

00:31:13,600 --> 00:31:16,880
kernel modules

00:31:15,120 --> 00:31:18,559
this is because the third-party column

00:31:16,880 --> 00:31:21,279
modules need to know

00:31:18,559 --> 00:31:23,039
how exactly the structure is defined

00:31:21,279 --> 00:31:26,000
after layout randomization

00:31:23,039 --> 00:31:28,240
for using these structures the

00:31:26,000 --> 00:31:29,919
mitigation works well in house building

00:31:28,240 --> 00:31:30,960
kernel if the random seed can be

00:31:29,919 --> 00:31:33,919
protected

00:31:30,960 --> 00:31:35,039
appropriately but for these trills like

00:31:33,919 --> 00:31:37,120
other gestures like

00:31:35,039 --> 00:31:39,679
ubuntu and debian it's not very

00:31:37,120 --> 00:31:39,679
practical

00:31:41,039 --> 00:31:46,399
the last potential mitigation is config

00:31:43,919 --> 00:31:49,840
harden use a copy which is imported

00:31:46,399 --> 00:31:52,559
from pax user copy this mitigation

00:31:49,840 --> 00:31:54,159
examines the size argument of use of

00:31:52,559 --> 00:31:56,720
copy to user

00:31:54,159 --> 00:31:57,360
if the source argument is a current

00:31:56,720 --> 00:31:59,760
address

00:31:57,360 --> 00:32:00,399
this defense ensures that the size

00:31:59,760 --> 00:32:03,519
argument

00:32:00,399 --> 00:32:05,360
is smaller than the frame size all the

00:32:03,519 --> 00:32:06,960
data in the current stack frame can be

00:32:05,360 --> 00:32:08,799
copied out

00:32:06,960 --> 00:32:11,039
if the source argument is the current

00:32:08,799 --> 00:32:13,360
key address the defense ensures

00:32:11,039 --> 00:32:15,039
that the size argument is smaller than

00:32:13,360 --> 00:32:18,240
the slot size

00:32:15,039 --> 00:32:20,480
cross slot overrate is disallowed

00:32:18,240 --> 00:32:22,880
the similar mechanism is also used in

00:32:20,480 --> 00:32:24,640
xnu kernel

00:32:22,880 --> 00:32:27,360
while this technique can mitigate the

00:32:24,640 --> 00:32:30,720
threat of some of some elastic objects

00:32:27,360 --> 00:32:33,039
it suffers from two problems while the

00:32:30,720 --> 00:32:33,840
on the one hand it only enforces the

00:32:33,039 --> 00:32:37,200
lens checking

00:32:33,840 --> 00:32:39,279
for use for quality user other

00:32:37,200 --> 00:32:41,600
critical kernel functions for data

00:32:39,279 --> 00:32:44,399
transferring are not included

00:32:41,600 --> 00:32:44,880
on the other hand the legit lens range

00:32:44,399 --> 00:32:48,080
is not

00:32:44,880 --> 00:32:49,519
restricted enough the sensitive data can

00:32:48,080 --> 00:32:52,240
reside in the cache slot

00:32:49,519 --> 00:32:53,440
for can result in the cash slot or stack

00:32:52,240 --> 00:32:55,600
frame

00:32:53,440 --> 00:32:56,799
it's still possible to leak them even

00:32:55,600 --> 00:32:59,519
after the mitigation

00:32:56,799 --> 00:32:59,519
is enforced

00:33:00,080 --> 00:33:03,440
according to our discussion in the

00:33:01,360 --> 00:33:05,600
previous slides there are now

00:33:03,440 --> 00:33:06,640
no mitigations in the kernel that can

00:33:05,600 --> 00:33:10,080
perfectly

00:33:06,640 --> 00:33:12,640
neutralize the threat of elastic objects

00:33:10,080 --> 00:33:14,240
to this end we propose a new defense

00:33:12,640 --> 00:33:17,120
mechanism

00:33:14,240 --> 00:33:18,559
this mechanism isolates elastic objects

00:33:17,120 --> 00:33:21,679
that we identified

00:33:18,559 --> 00:33:22,399
into individual shadow caches to be

00:33:21,679 --> 00:33:25,039
specific

00:33:22,399 --> 00:33:28,159
we create an isolated shadow cache for

00:33:25,039 --> 00:33:30,559
each general cache during kernel buddha

00:33:28,159 --> 00:33:33,120
using shadow caches we store elastic

00:33:30,559 --> 00:33:36,480
objects with the corresponding sizes

00:33:33,120 --> 00:33:39,519
for example the elastic object of object

00:33:36,480 --> 00:33:43,039
originally allocated in key metal 96

00:33:39,519 --> 00:33:46,240
will be assigned in k malloc isolate 96

00:33:43,039 --> 00:33:48,559
after the isolation mechanism is enabled

00:33:46,240 --> 00:33:49,679
to support this isolation we'll modify

00:33:48,559 --> 00:33:52,559
the kernel source code

00:33:49,679 --> 00:33:53,600
by by adding one more flag at allocation

00:33:52,559 --> 00:33:56,559
site

00:33:53,600 --> 00:33:57,600
this flag specifies that the object to

00:33:56,559 --> 00:34:00,399
be allocated

00:33:57,600 --> 00:34:00,640
is elastic object and should be placed

00:34:00,399 --> 00:34:03,600
and

00:34:00,640 --> 00:34:05,279
should be placed in the shadow caches

00:34:03,600 --> 00:34:07,279
with the isolation mechanism

00:34:05,279 --> 00:34:08,960
an adversary has little chance to

00:34:07,279 --> 00:34:11,359
leverage the vulnerability

00:34:08,960 --> 00:34:12,159
tied to other objects to manipulate the

00:34:11,359 --> 00:34:15,119
lens field

00:34:12,159 --> 00:34:15,760
and point of field elastic objects

00:34:15,119 --> 00:34:18,159
besides

00:34:15,760 --> 00:34:20,079
common heap spray objects and kernel

00:34:18,159 --> 00:34:22,560
objects with scientific information

00:34:20,079 --> 00:34:24,879
like function pointers are also isolated

00:34:22,560 --> 00:34:26,720
from the elastic objects

00:34:24,879 --> 00:34:29,679
they could not be used for hip

00:34:26,720 --> 00:34:31,839
functioning and spraying

00:34:29,679 --> 00:34:32,720
several weeks after i submitted this

00:34:31,839 --> 00:34:34,879
presentation

00:34:32,720 --> 00:34:36,000
i learned from jia secretary that they

00:34:34,879 --> 00:34:38,399
have implemented

00:34:36,000 --> 00:34:39,040
more advanced isolation their new

00:34:38,399 --> 00:34:42,079
defense

00:34:39,040 --> 00:34:42,879
named auto load autoload is much more

00:34:42,079 --> 00:34:46,320
aggressive

00:34:42,879 --> 00:34:48,320
in hip object isolation although i don't

00:34:46,320 --> 00:34:50,560
know more details about the autoload

00:34:48,320 --> 00:34:54,320
i'm pretty sure that its security

00:34:50,560 --> 00:34:54,320
improvement is very significant

00:34:54,960 --> 00:34:59,520
we evaluated the performance overhead of

00:34:57,440 --> 00:35:02,400
our proposed mitigation

00:34:59,520 --> 00:35:03,200
we used three sets of benchmarks the

00:35:02,400 --> 00:35:06,800
first set

00:35:03,200 --> 00:35:08,240
is micro benchmarks from lm bench which

00:35:06,800 --> 00:35:11,680
test the latency and the

00:35:08,240 --> 00:35:14,960
bandwidth of common system cost and the

00:35:11,680 --> 00:35:17,599
io operations the second set is

00:35:14,960 --> 00:35:19,119
macro benchmarks from fairness tester

00:35:17,599 --> 00:35:22,720
suite which runs

00:35:19,119 --> 00:35:23,599
five real world applications to prevent

00:35:22,720 --> 00:35:25,040
the overhead

00:35:23,599 --> 00:35:27,119
from being hidden behind the

00:35:25,040 --> 00:35:29,680
sophisticated cone execution

00:35:27,119 --> 00:35:30,480
we especially designed the third stat

00:35:29,680 --> 00:35:32,480
benchmark

00:35:30,480 --> 00:35:34,320
to stress test the impact of our

00:35:32,480 --> 00:35:37,440
mitigation approach

00:35:34,320 --> 00:35:38,640
this set of customized benchmarks uses a

00:35:37,440 --> 00:35:40,720
system called

00:35:38,640 --> 00:35:41,680
sequential to reach elastic object

00:35:40,720 --> 00:35:43,440
allocation

00:35:41,680 --> 00:35:45,760
and corresponding data leakage

00:35:43,440 --> 00:35:47,920
intensively

00:35:45,760 --> 00:35:49,200
overall we could observe that the

00:35:47,920 --> 00:35:51,680
performance overhead

00:35:49,200 --> 00:35:52,720
is negligible with average performance

00:35:51,680 --> 00:35:55,760
job less than

00:35:52,720 --> 00:35:55,760
less than one percent

00:35:56,079 --> 00:35:59,839
we also evaluate the security of our

00:35:58,160 --> 00:36:02,960
proposed mitigation approach

00:35:59,839 --> 00:36:04,800
by reusing 31 vulnerabilities that were

00:36:02,960 --> 00:36:08,240
used to study the generality

00:36:04,800 --> 00:36:10,480
of elastic object attack for most

00:36:08,240 --> 00:36:11,040
vulnerabilities we cannot find elastic

00:36:10,480 --> 00:36:14,160
objects

00:36:11,040 --> 00:36:14,960
that can be used for exploitation this

00:36:14,160 --> 00:36:16,960
is because

00:36:14,960 --> 00:36:20,079
the elastic objects and the vulnerable

00:36:16,960 --> 00:36:23,200
objects are mostly different

00:36:20,079 --> 00:36:25,359
they are isolated into into two caches

00:36:23,200 --> 00:36:26,560
they are no longer a possibility to use

00:36:25,359 --> 00:36:28,720
vulnerable objects

00:36:26,560 --> 00:36:31,280
to manipulate the lens field of an

00:36:28,720 --> 00:36:36,480
elastic object

00:36:31,280 --> 00:36:40,720
for vulnerable objects in cve 2017-7184

00:36:36,480 --> 00:36:42,800
and cv 2017-1705

00:36:40,720 --> 00:36:44,640
there are also elastic objects allocated

00:36:42,800 --> 00:36:46,960
in the shadow caches

00:36:44,640 --> 00:36:49,359
technically they can be leveraged to

00:36:46,960 --> 00:36:52,000
override the data in the isolated caches

00:36:49,359 --> 00:36:53,040
and thus manipulate the lens field of an

00:36:52,000 --> 00:36:56,079
elastic object

00:36:53,040 --> 00:36:58,560
for data disclosure however

00:36:56,079 --> 00:36:59,200
we argue that even if the situation

00:36:58,560 --> 00:37:01,839
exists

00:36:59,200 --> 00:37:03,200
it still raises the bar because the

00:37:01,839 --> 00:37:05,760
disclosed data

00:37:03,200 --> 00:37:07,680
is not likely to be useful for bypassing

00:37:05,760 --> 00:37:10,400
current mitigation

00:37:07,680 --> 00:37:11,440
taking the practice of circumventing

00:37:10,400 --> 00:37:17,760
kscr

00:37:11,440 --> 00:37:20,240
using cve 2617 17053 as an example

00:37:17,760 --> 00:37:21,760
you use a vulnerable object to review a

00:37:20,240 --> 00:37:23,520
kernel-based address

00:37:21,760 --> 00:37:25,359
in addition to leveraging the elastic

00:37:23,520 --> 00:37:27,839
object an attacker

00:37:25,359 --> 00:37:31,040
usually has to identify a general object

00:37:27,839 --> 00:37:32,560
that encloses a function pointer

00:37:31,040 --> 00:37:34,480
then the attacker needs to place the

00:37:32,560 --> 00:37:37,200
object in the same isolated

00:37:34,480 --> 00:37:38,320
isolated cache however due to the

00:37:37,200 --> 00:37:41,599
general and

00:37:38,320 --> 00:37:43,520
elastic object isolation certain

00:37:41,599 --> 00:37:46,480
object is no longer available for this

00:37:43,520 --> 00:37:46,480
isolated cache

00:37:47,359 --> 00:37:50,880
in addition to the difference we

00:37:48,560 --> 00:37:53,200
proposed thus several

00:37:50,880 --> 00:37:54,960
alternative defense solutions we've ever

00:37:53,200 --> 00:37:57,520
considered

00:37:54,960 --> 00:37:58,400
the first is possible solutions to build

00:37:57,520 --> 00:38:00,000
shadow memory

00:37:58,400 --> 00:38:01,920
for each of the elastic objects

00:38:00,000 --> 00:38:04,400
allocated in the kernel

00:38:01,920 --> 00:38:07,440
in that shadow memory we can record the

00:38:04,400 --> 00:38:09,760
actual size of the corresponding object

00:38:07,440 --> 00:38:10,480
when the combust closes data in an

00:38:09,760 --> 00:38:13,040
elastic

00:38:10,480 --> 00:38:13,599
buffer at any leaking angle we could

00:38:13,040 --> 00:38:15,920
check

00:38:13,599 --> 00:38:17,040
whether the amount of the data migrating

00:38:15,920 --> 00:38:21,520
to the use space if

00:38:17,040 --> 00:38:23,680
we sing alleged within a legit range

00:38:21,520 --> 00:38:25,680
since the construction of shadow memory

00:38:23,680 --> 00:38:27,760
inevitably introduces memory

00:38:25,680 --> 00:38:30,000
and performance overhead the key

00:38:27,760 --> 00:38:32,800
challenge of this solution is to develop

00:38:30,000 --> 00:38:33,520
a lightweight method to minimize

00:38:32,800 --> 00:38:37,040
overhead

00:38:33,520 --> 00:38:38,320
in a systematic method another possible

00:38:37,040 --> 00:38:40,720
solution is to design

00:38:38,320 --> 00:38:44,079
a mechanism to enable the integrity

00:38:40,720 --> 00:38:46,640
check for the data in the lens field

00:38:44,079 --> 00:38:48,800
we introduce the checksum field when the

00:38:46,640 --> 00:38:51,599
kernel allocates a corresponding object

00:38:48,800 --> 00:38:53,200
and and initializes lens field we could

00:38:51,599 --> 00:38:55,440
encrypt the lens value

00:38:53,200 --> 00:38:57,119
and store it in the checksum field

00:38:55,440 --> 00:38:59,440
accordingly

00:38:57,119 --> 00:39:02,480
with this design at a time of disclosing

00:38:59,440 --> 00:39:04,560
data in elastic buffer to the user land

00:39:02,480 --> 00:39:07,280
the kernel could easily retrieve and

00:39:04,560 --> 00:39:09,520
scrutinize the checksum

00:39:07,280 --> 00:39:11,280
the key challenge of implementing this

00:39:09,520 --> 00:39:13,200
idea is to ensure

00:39:11,280 --> 00:39:16,560
the addition of the checksum will not

00:39:13,200 --> 00:39:18,640
influence the usability of the kernel

00:39:16,560 --> 00:39:20,320
some elastic data structures are

00:39:18,640 --> 00:39:23,440
designed for protocols

00:39:20,320 --> 00:39:24,640
which have specific formats after

00:39:23,440 --> 00:39:26,960
allocating objects

00:39:24,640 --> 00:39:29,920
in these types the kernel references the

00:39:26,960 --> 00:39:32,480
data through corresponding offsets

00:39:29,920 --> 00:39:33,760
if introducing additional fields into

00:39:32,480 --> 00:39:36,240
such objects

00:39:33,760 --> 00:39:37,359
one has to ensure that the newly added

00:39:36,240 --> 00:39:42,960
checksum field

00:39:37,359 --> 00:39:45,359
does not incur incorrect data reference

00:39:42,960 --> 00:39:46,240
to sum up first we extend a flexible

00:39:45,359 --> 00:39:48,880
object

00:39:46,240 --> 00:39:51,119
to an elastic to elastic object second

00:39:48,880 --> 00:39:53,760
we design a systematic method

00:39:51,119 --> 00:39:55,280
demonstrating the generality of elastic

00:39:53,760 --> 00:39:57,520
object attack

00:39:55,280 --> 00:39:58,960
we identify channel functions or track

00:39:57,520 --> 00:40:00,960
diagnostic structures

00:39:58,960 --> 00:40:02,000
in the kernel codebase and use

00:40:00,960 --> 00:40:05,040
vulnerabilities

00:40:02,000 --> 00:40:05,760
to show the generality third we

00:40:05,040 --> 00:40:08,160
investigate

00:40:05,760 --> 00:40:09,520
existing kernel mitigations and find

00:40:08,160 --> 00:40:12,319
none of them is perfect

00:40:09,520 --> 00:40:14,079
for mitigating this attack thus we

00:40:12,319 --> 00:40:16,400
designed a new defense

00:40:14,079 --> 00:40:18,000
we evaluated the performance overhead

00:40:16,400 --> 00:40:20,480
and the security improvement

00:40:18,000 --> 00:40:23,520
of our proposed mitigation to show its

00:40:20,480 --> 00:40:23,520
cost and benefit

00:40:23,760 --> 00:40:27,119
thanks for listening and thank you very

00:40:25,440 --> 00:40:28,960
much for having me here

00:40:27,119 --> 00:40:31,040
if you want to know more about me and my

00:40:28,960 --> 00:40:31,520
other projects or you don't have chance

00:40:31,040 --> 00:40:34,240
to ask

00:40:31,520 --> 00:40:35,680
questions in this session feel free to

00:40:34,240 --> 00:40:38,000
follow me on twitter

00:40:35,680 --> 00:40:38,880
contact me using email and check my post

00:40:38,000 --> 00:40:47,680
on the page

00:40:38,880 --> 00:40:47,680

YouTube URL: https://www.youtube.com/watch?v=yXhH0IJAxkE


