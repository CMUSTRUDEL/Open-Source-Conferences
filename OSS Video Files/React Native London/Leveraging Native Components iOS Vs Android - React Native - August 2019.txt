Title: Leveraging Native Components iOS Vs Android - React Native - August 2019
Publication date: 2019-09-04
Playlist: React Native London
Description: 
	Presented by Chris Fothergill.

Chris will give us an overview of how Flock rewrote their Map View as a Native Component discussing the differences between iOS and Android.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,190
hello I'm Chris and I'm a software

00:00:03,090 --> 00:00:07,049
engineer a flock and today I'm here to

00:00:05,190 --> 00:00:10,110
talk about leveraging native components

00:00:07,049 --> 00:00:11,940
and specifically how flock replaced a

00:00:10,110 --> 00:00:13,740
key part of their application with a

00:00:11,940 --> 00:00:17,100
native component which give us much

00:00:13,740 --> 00:00:21,600
improved performance and also a better

00:00:17,100 --> 00:00:22,949
user experience so just a quick overview

00:00:21,600 --> 00:00:25,260
if I'm going to talk about I'm going to

00:00:22,949 --> 00:00:28,680
give a quick introduction to flock and

00:00:25,260 --> 00:00:30,179
then go over the problem a couple of

00:00:28,680 --> 00:00:32,369
solutions we came up with and then

00:00:30,179 --> 00:00:35,250
finally just delve into how native

00:00:32,369 --> 00:00:37,770
components are built so just a little

00:00:35,250 --> 00:00:41,309
bit about me I have built native apps in

00:00:37,770 --> 00:00:43,860
the past when I came to flock we decided

00:00:41,309 --> 00:00:45,600
that we wanted to replace the map which

00:00:43,860 --> 00:00:48,390
is sort of a key part of the application

00:00:45,600 --> 00:00:51,329
with a narrative component I'll go into

00:00:48,390 --> 00:00:53,670
how it was originally built in a bit at

00:00:51,329 --> 00:00:54,930
the time the documentation was a bit

00:00:53,670 --> 00:00:56,370
lacking on how to actually build a

00:00:54,930 --> 00:00:59,789
narrative component there was bits

00:00:56,370 --> 00:01:01,410
missing so this is going to be a fairly

00:00:59,789 --> 00:01:02,730
dense talk it's going to cover just

00:01:01,410 --> 00:01:05,909
about everything you need to know to

00:01:02,730 --> 00:01:08,790
build a native component so I've made it

00:01:05,909 --> 00:01:10,650
is them tried to make it as easy as

00:01:08,790 --> 00:01:12,210
possible to follow along but there's

00:01:10,650 --> 00:01:13,860
always if you've got any questions just

00:01:12,210 --> 00:01:17,009
sort of put your hand up and ask and

00:01:13,860 --> 00:01:18,540
I'll do my best to answer so flock

00:01:17,009 --> 00:01:21,990
essentially cells drawn insurance

00:01:18,540 --> 00:01:24,540
through a mobile app and we do that by

00:01:21,990 --> 00:01:27,210
calculating the risk at a given point in

00:01:24,540 --> 00:01:29,520
time and it's specific location and then

00:01:27,210 --> 00:01:31,110
we convert that risk into a actual

00:01:29,520 --> 00:01:37,619
monetary value which is then what we

00:01:31,110 --> 00:01:40,470
sell the insurance for so this is the

00:01:37,619 --> 00:01:42,810
app this is like the main screen that a

00:01:40,470 --> 00:01:44,939
user will end up on you can see they

00:01:42,810 --> 00:01:46,200
move them up around the price at the

00:01:44,939 --> 00:01:49,229
bottom will be going down because we're

00:01:46,200 --> 00:01:50,460
getting into a less risky area it'll

00:01:49,229 --> 00:01:52,170
move again in a second what you're

00:01:50,460 --> 00:01:53,880
seeing on screen now is actually the old

00:01:52,170 --> 00:01:57,360
map view and you can see that it's not

00:01:53,880 --> 00:01:58,710
very fast the yellow are sort of circles

00:01:57,360 --> 00:02:02,189
flickering and what that actually is a

00:01:58,710 --> 00:02:04,799
web view which is rendering a web page

00:02:02,189 --> 00:02:07,500
so that was our like sort of MVP

00:02:04,799 --> 00:02:10,259
implementation of what we wanted to sort

00:02:07,500 --> 00:02:12,209
of get out of it and the purpose of this

00:02:10,259 --> 00:02:13,410
talk is to talk to how we took it from a

00:02:12,209 --> 00:02:23,550
web view

00:02:13,410 --> 00:02:26,460
to a fully native component so we had a

00:02:23,550 --> 00:02:28,620
few options when we sort of set out to

00:02:26,460 --> 00:02:31,290
build this and one was obviously we need

00:02:28,620 --> 00:02:32,490
to get rid of the webview first option

00:02:31,290 --> 00:02:34,200
would have been to try and build this

00:02:32,490 --> 00:02:35,700
with existing react native components

00:02:34,200 --> 00:02:37,380
that are out there so we definitely

00:02:35,700 --> 00:02:39,600
could have found a map view like there's

00:02:37,380 --> 00:02:41,220
plenty of map views to choose from but

00:02:39,600 --> 00:02:42,990
the way this thing is actually built

00:02:41,220 --> 00:02:46,410
eldest bring it back up sir should've

00:02:42,990 --> 00:02:48,720
gone forward one is this background bit

00:02:46,410 --> 00:02:49,980
here is a map and then this bit in the

00:02:48,720 --> 00:02:52,770
middle here is actually another map

00:02:49,980 --> 00:02:53,940
that's been clipped so we'd somehow need

00:02:52,770 --> 00:02:55,230
to find a clip in view and that's

00:02:53,940 --> 00:02:56,820
probably going to be a lot more

00:02:55,230 --> 00:02:58,320
difficult to find like a one off the

00:02:56,820 --> 00:02:59,850
shelf that's going to be able to clip

00:02:58,320 --> 00:03:02,450
something to a circle in the middle of

00:02:59,850 --> 00:03:05,340
the screen with a yellow bar around it

00:03:02,450 --> 00:03:09,450
it's also like under the hood quite a

00:03:05,340 --> 00:03:12,120
complex task to to clip a view like this

00:03:09,450 --> 00:03:13,530
what actually happens is the system has

00:03:12,120 --> 00:03:15,330
to render the background own house to

00:03:13,530 --> 00:03:17,220
render the foreground fully and then it

00:03:15,330 --> 00:03:18,870
actually Clips the view and has to

00:03:17,220 --> 00:03:22,200
compose them on top of each other

00:03:18,870 --> 00:03:25,020
and that's called the two-step render or

00:03:22,200 --> 00:03:26,550
to pass render so when you take into

00:03:25,020 --> 00:03:28,260
your account like so I've flinging them

00:03:26,550 --> 00:03:30,420
up around and trying to get at 60 frames

00:03:28,260 --> 00:03:33,180
a second got to reanimation that's quite

00:03:30,420 --> 00:03:34,200
difficult in sort of five more than five

00:03:33,180 --> 00:03:36,720
years ago that would have been difficult

00:03:34,200 --> 00:03:38,430
to do in a fully native up device is now

00:03:36,720 --> 00:03:39,360
fortunately you're a lot more forgiving

00:03:38,430 --> 00:03:42,000
we've got a lot more graphics

00:03:39,360 --> 00:03:43,170
performance so just so I've clipped

00:03:42,000 --> 00:03:45,810
interview like that is definitely

00:03:43,170 --> 00:03:47,160
possible the biggest issue we had with

00:03:45,810 --> 00:03:48,959
doing this with like sort of

00:03:47,160 --> 00:03:51,239
off-the-shelf react native components is

00:03:48,959 --> 00:03:55,230
the overhead with communication from

00:03:51,239 --> 00:03:56,580
JavaScript to the native side every time

00:03:55,230 --> 00:03:59,100
this map moves it's going to have to

00:03:56,580 --> 00:04:00,510
send a message from the native side to

00:03:59,100 --> 00:04:02,400
JavaScript then we're going to have to

00:04:00,510 --> 00:04:05,040
send a message back from JavaScript to

00:04:02,400 --> 00:04:07,530
the native side so that the two maps can

00:04:05,040 --> 00:04:09,000
be kept in sync and that's a huge amount

00:04:07,530 --> 00:04:10,860
of overhead when you think this map is

00:04:09,000 --> 00:04:13,230
moving like 60 times a second when

00:04:10,860 --> 00:04:15,480
you're moving it around so we ultimately

00:04:13,230 --> 00:04:17,520
decided that the best way to approach

00:04:15,480 --> 00:04:19,049
this was to bring as much of into the

00:04:17,520 --> 00:04:21,840
native side as possible and then just

00:04:19,049 --> 00:04:24,390
sort of like export after a native

00:04:21,840 --> 00:04:25,770
component and by doing that we're not

00:04:24,390 --> 00:04:27,240
really helping with the performance

00:04:25,770 --> 00:04:30,030
potential issues but we

00:04:27,240 --> 00:04:32,490
reducing the overhead on the bridge to a

00:04:30,030 --> 00:04:34,740
single message when the map finishes

00:04:32,490 --> 00:04:36,479
animating to say that the positions

00:04:34,740 --> 00:04:38,729
change so we can recalculate the price

00:04:36,479 --> 00:04:40,620
the yellow circle represents the area in

00:04:38,729 --> 00:04:42,870
which she'll be insured so that the

00:04:40,620 --> 00:04:46,229
circle in the middle is the insurance

00:04:42,870 --> 00:04:51,000
area the agrea doubt--but is the the

00:04:46,229 --> 00:04:52,949
non-insured area so what is a native

00:04:51,000 --> 00:04:54,479
component so a native component

00:04:52,949 --> 00:04:56,099
represents a view on screen and a view

00:04:54,479 --> 00:04:57,960
can just be defined as a rectangle of

00:04:56,099 --> 00:05:01,830
content with on and within the

00:04:57,960 --> 00:05:03,599
application from a sort of interaction

00:05:01,830 --> 00:05:04,830
perspective from the JavaScript side the

00:05:03,599 --> 00:05:06,389
exactly the Simms normal JavaScript

00:05:04,830 --> 00:05:09,570
component you they've got props

00:05:06,389 --> 00:05:11,400
callbacks events you can call methods on

00:05:09,570 --> 00:05:12,750
them through what I call commands which

00:05:11,400 --> 00:05:16,830
I'll get onto in a second you can get

00:05:12,750 --> 00:05:18,449
refs to them you can send styles to them

00:05:16,830 --> 00:05:20,130
I'm not going to cover styling in this

00:05:18,449 --> 00:05:22,860
talk because we didn't really have to do

00:05:20,130 --> 00:05:25,500
any of it all of the sort of layout and

00:05:22,860 --> 00:05:28,590
external styling mishandle by react

00:05:25,500 --> 00:05:31,080
native out-of-the-box so we didn't

00:05:28,590 --> 00:05:32,580
really have to touch any complex style

00:05:31,080 --> 00:05:36,720
and boot styling is definitely something

00:05:32,580 --> 00:05:39,180
that is supported so there's going to be

00:05:36,720 --> 00:05:41,460
quite a few chord slides in this talk so

00:05:39,180 --> 00:05:43,500
I thought it would be best just to go

00:05:41,460 --> 00:05:45,389
over saw and what these files are where

00:05:43,500 --> 00:05:47,610
the sort of located in the project and

00:05:45,389 --> 00:05:49,020
just just saw the solve em up on every

00:05:47,610 --> 00:05:52,250
single chord slide as well it'll just

00:05:49,020 --> 00:05:54,719
have written at the top what and what

00:05:52,250 --> 00:05:57,780
chords file it from so we've got the

00:05:54,719 --> 00:06:01,919
JavaScript map view we've got several

00:05:57,780 --> 00:06:03,750
iOS files there's view in Swift and view

00:06:01,919 --> 00:06:06,360
manager and swift a view manager in

00:06:03,750 --> 00:06:08,669
Objective C and an extension to the

00:06:06,360 --> 00:06:10,979
built-in coordinate which I'll get to in

00:06:08,669 --> 00:06:12,270
a second and then Android unfortunately

00:06:10,979 --> 00:06:14,550
the past would be too long to fit on the

00:06:12,270 --> 00:06:18,509
slides over to take a few where folders

00:06:14,550 --> 00:06:22,110
out but ultimately we've got a map view

00:06:18,509 --> 00:06:24,150
and map view manager and utils which

00:06:22,110 --> 00:06:27,060
brings us on nicely to what is required

00:06:24,150 --> 00:06:28,919
for building a map view after I've

00:06:27,060 --> 00:06:33,810
quickly talked about the public API so

00:06:28,919 --> 00:06:35,699
there the view itself from a JavaScript

00:06:33,810 --> 00:06:37,139
perspective has this sort of API so

00:06:35,699 --> 00:06:39,330
we've got a coordinate which can be

00:06:37,139 --> 00:06:40,830
defined as yes sort of structure with

00:06:39,330 --> 00:06:42,270
the latitude and longitude we've got Pro

00:06:40,830 --> 00:06:44,699
we're the center coordinate so that's

00:06:42,270 --> 00:06:47,610
where the user is sort of moved them up

00:06:44,699 --> 00:06:49,740
to the zoom how far these rooms in on

00:06:47,610 --> 00:06:52,530
change is a callback that gets called

00:06:49,740 --> 00:06:54,330
when the matte finish is moving and then

00:06:52,530 --> 00:06:56,879
an on my floor field just as another

00:06:54,330 --> 00:06:58,680
example of an event we've got a shoe

00:06:56,879 --> 00:07:00,750
attribution command which I'll get to in

00:06:58,680 --> 00:07:02,819
a second and then obviously render so

00:07:00,750 --> 00:07:06,810
this is what it looks like in JavaScript

00:07:02,819 --> 00:07:08,729
now on to the native stuff so we had a

00:07:06,810 --> 00:07:10,889
few choices for languages on iOS at

00:07:08,729 --> 00:07:13,199
least we chose to go over Swift because

00:07:10,889 --> 00:07:15,680
if it's increased type safety and also

00:07:13,199 --> 00:07:19,349
because of its more familiar syntax to

00:07:15,680 --> 00:07:21,120
JavaScript developers react native

00:07:19,349 --> 00:07:23,370
itself is actually written in like

00:07:21,120 --> 00:07:25,620
objects of seeing a C++ in a bit C so

00:07:23,370 --> 00:07:27,150
you can't avoid Objective C completely

00:07:25,620 --> 00:07:28,860
but you can reduce it quite

00:07:27,150 --> 00:07:31,830
significantly just down to a few lines

00:07:28,860 --> 00:07:33,719
in a file and that's just because it

00:07:31,830 --> 00:07:35,520
relies a lot on the objective-c runtime

00:07:33,719 --> 00:07:37,440
in the way that it works under the hood

00:07:35,520 --> 00:07:38,879
so we still need that little bit of

00:07:37,440 --> 00:07:41,039
objective-c but you can't get rid of

00:07:38,879 --> 00:07:43,409
most of it for undried we chose to use

00:07:41,039 --> 00:07:46,590
Java we could have just as easily trust

00:07:43,409 --> 00:07:48,240
you Scotland we trust you either because

00:07:46,590 --> 00:07:50,400
we were already introduced into new

00:07:48,240 --> 00:07:52,440
languages of their job is probably more

00:07:50,400 --> 00:07:54,509
familiar to most developers or we just

00:07:52,440 --> 00:07:55,560
stuck with Java but we could have just

00:07:54,509 --> 00:08:00,330
of easily chosen

00:07:55,560 --> 00:08:01,680
Kotlin so I've mentioned there is a

00:08:00,330 --> 00:08:03,479
little bit of objective-c I thought I'd

00:08:01,680 --> 00:08:05,880
just quickly go over and point out the

00:08:03,479 --> 00:08:07,529
like similarities between JavaScript and

00:08:05,880 --> 00:08:09,029
like how you saw it pick the bits out

00:08:07,529 --> 00:08:13,409
because it's probably that sort of least

00:08:09,029 --> 00:08:15,090
familiar language to most people so this

00:08:13,409 --> 00:08:17,430
little dash here just means it's an

00:08:15,090 --> 00:08:20,219
instance method the next bit is the

00:08:17,430 --> 00:08:23,729
return type of the function this bit

00:08:20,219 --> 00:08:26,639
here is the method name or selector

00:08:23,729 --> 00:08:28,650
selectors it's like official name first

00:08:26,639 --> 00:08:30,090
parameter second parameter so you can

00:08:28,650 --> 00:08:32,070
see that they're sort of parameters and

00:08:30,090 --> 00:08:36,180
names all mangled up together and they

00:08:32,070 --> 00:08:38,669
do tend to get quite long but that's the

00:08:36,180 --> 00:08:43,320
equivalent method defined in JavaScript

00:08:38,669 --> 00:08:44,880
so not too dissimilar and then just sort

00:08:43,320 --> 00:08:46,050
of sum up in between Swift and

00:08:44,880 --> 00:08:48,209
objective-c because we're going to be

00:08:46,050 --> 00:08:50,250
doing that as well so the only real

00:08:48,209 --> 00:08:52,320
important thing to notice here is that

00:08:50,250 --> 00:08:55,450
the width is disappeared so there are

00:08:52,320 --> 00:08:58,360
some rules set up by Apple as to

00:08:55,450 --> 00:09:02,110
method names translate between Objective

00:08:58,360 --> 00:09:04,540
C and Swift the real important one to

00:09:02,110 --> 00:09:07,060
naught for here is that we've just

00:09:04,540 --> 00:09:09,670
disappear so if it's an M parameter

00:09:07,060 --> 00:09:11,290
there's no width and that's important

00:09:09,670 --> 00:09:12,790
because if we write a method in Swift

00:09:11,290 --> 00:09:14,260
and we need to expose it to react native

00:09:12,790 --> 00:09:16,990
if we need to know how to write it in

00:09:14,260 --> 00:09:20,740
Objective C as well unless the binding

00:09:16,990 --> 00:09:23,320
won't happen correctly there are some

00:09:20,740 --> 00:09:25,270
other rules saw apples got brilliant

00:09:23,320 --> 00:09:26,860
documentation on what these rules are so

00:09:25,270 --> 00:09:29,020
I would suggest just going and looking

00:09:26,860 --> 00:09:35,320
them up if you need to do anything like

00:09:29,020 --> 00:09:38,110
this so now onto the set up so the bare

00:09:35,320 --> 00:09:40,810
essentials to build native components

00:09:38,110 --> 00:09:44,200
are a native view and a view manager and

00:09:40,810 --> 00:09:45,580
a view manager is a singleton so there's

00:09:44,200 --> 00:09:47,530
only saw one of them running throughout

00:09:45,580 --> 00:09:50,350
your entire application process and

00:09:47,530 --> 00:09:52,450
they're responsible for managing any

00:09:50,350 --> 00:09:58,210
instance of that particular near the

00:09:52,450 --> 00:10:01,150
view on the screen on iOS view should

00:09:58,210 --> 00:10:03,120
always inherit from UI view and on

00:10:01,150 --> 00:10:06,270
Android they should inherit from view

00:10:03,120 --> 00:10:08,589
however you more likely to so plus some

00:10:06,270 --> 00:10:11,350
existence or class of view on Android

00:10:08,589 --> 00:10:13,510
such as a layout which will handle some

00:10:11,350 --> 00:10:17,410
of the more like sort of complex layouts

00:10:13,510 --> 00:10:22,390
for you I'll go into the one that we

00:10:17,410 --> 00:10:25,180
chose and why we chose it in a second so

00:10:22,390 --> 00:10:27,430
this is mock view dot Swift source is

00:10:25,180 --> 00:10:29,170
sort of our native view on iOS this is

00:10:27,430 --> 00:10:31,300
the simplest definition just to get

00:10:29,170 --> 00:10:33,040
started so we defined a class called map

00:10:31,300 --> 00:10:34,570
view did you inherit from UI view and

00:10:33,040 --> 00:10:36,580
that's this that's all you need to get

00:10:34,570 --> 00:10:38,260
started that will actually render a

00:10:36,580 --> 00:10:42,330
white box on screen or a black box on

00:10:38,260 --> 00:10:47,230
screen so that's a perfectly valid view

00:10:42,330 --> 00:10:49,330
class name and parent class this is the

00:10:47,230 --> 00:10:52,330
view manager so as I saw the singleton

00:10:49,330 --> 00:10:54,250
that will manage all the instances of

00:10:52,330 --> 00:10:56,350
the view on-screen the first thing to

00:10:54,250 --> 00:10:58,120
note here is it has to be set up on the

00:10:56,350 --> 00:10:59,920
main thread so any interruption with you

00:10:58,120 --> 00:11:00,970
is when iOS has to be done on the main

00:10:59,920 --> 00:11:03,459
thread if it isn't

00:11:00,970 --> 00:11:04,870
you'll start and see weird behaviors in

00:11:03,459 --> 00:11:06,730
your application and ultimately I'll

00:11:04,870 --> 00:11:08,590
just crush because it can't deal with it

00:11:06,730 --> 00:11:10,750
so very important

00:11:08,590 --> 00:11:15,660
any interaction with the uikit must

00:11:10,750 --> 00:11:18,310
happen on the main thread the other

00:11:15,660 --> 00:11:20,980
thing to know in here is this one so

00:11:18,310 --> 00:11:22,779
this is sort of like a factory that just

00:11:20,980 --> 00:11:24,670
gets called whenever react native

00:11:22,779 --> 00:11:27,160
requires a new instance of your view so

00:11:24,670 --> 00:11:29,020
you've in JavaScript or under this map

00:11:27,160 --> 00:11:31,150
view somewhere down the line this

00:11:29,020 --> 00:11:32,740
functions go get called and you just

00:11:31,150 --> 00:11:36,250
have to return in your version of your

00:11:32,740 --> 00:11:38,200
view the frame here is arbitrary it

00:11:36,250 --> 00:11:40,089
doesn't really matter just return

00:11:38,200 --> 00:11:42,370
anything as long as the view works it'll

00:11:40,089 --> 00:11:46,810
actually get sized later as part of the

00:11:42,370 --> 00:11:49,990
layout process and finally the

00:11:46,810 --> 00:11:52,120
objective-c bit so you need Objective C

00:11:49,990 --> 00:11:55,290
file and you just need to call this

00:11:52,120 --> 00:11:57,520
macro here which is our CT extern module

00:11:55,290 --> 00:11:59,680
what that does behind the scenes isn't

00:11:57,520 --> 00:12:02,440
really important it just spits out some

00:11:59,680 --> 00:12:04,000
Objective C chord if anyone wants to

00:12:02,440 --> 00:12:05,830
know works behind the scenes you can ask

00:12:04,000 --> 00:12:08,020
later and I've got a bit of an idea how

00:12:05,830 --> 00:12:10,960
it works but it's not really relevant to

00:12:08,020 --> 00:12:12,730
the talk you just need to do it and

00:12:10,960 --> 00:12:17,350
that's it so from an objective-c

00:12:12,730 --> 00:12:19,440
perspective that's that's that's all you

00:12:17,350 --> 00:12:23,020
need from an iOS perspective on Android

00:12:19,440 --> 00:12:24,820
this is the map view class on Android so

00:12:23,020 --> 00:12:28,300
we've got a class called map view that

00:12:24,820 --> 00:12:31,810
extends free and layout we chose to use

00:12:28,300 --> 00:12:34,990
frame layout because if you think about

00:12:31,810 --> 00:12:36,790
our map view we've got sort of Lords of

00:12:34,990 --> 00:12:38,380
views that a full screen and need to

00:12:36,790 --> 00:12:39,790
stack on top of each other and that's

00:12:38,380 --> 00:12:41,589
exactly what frame layout does it

00:12:39,790 --> 00:12:43,510
stretches its children to be the width

00:12:41,589 --> 00:12:45,610
and height of itself and then just

00:12:43,510 --> 00:12:51,520
stucks everything else on top of on top

00:12:45,610 --> 00:12:55,390
so perfectly after us that one again on

00:12:51,520 --> 00:12:56,860
Android we need a view manager it's got

00:12:55,390 --> 00:12:58,540
a factory as well it's just near him

00:12:56,860 --> 00:13:01,330
slightly differently this just returns a

00:12:58,540 --> 00:13:03,100
new instance of our map view and wasn't

00:13:01,330 --> 00:13:07,420
that like essentially the same as the

00:13:03,100 --> 00:13:10,630
iOS side and then finally back in

00:13:07,420 --> 00:13:14,950
JavaScript world we've got a components

00:13:10,630 --> 00:13:17,680
called map view and all we do is just

00:13:14,950 --> 00:13:21,939
import the native map view and just

00:13:17,680 --> 00:13:23,679
render it so the reason for this is the

00:13:21,939 --> 00:13:25,419
couple of reasons for it so firstly it

00:13:23,679 --> 00:13:27,429
keeps the fact that this is a narrative

00:13:25,419 --> 00:13:29,529
component away from the rest of your

00:13:27,429 --> 00:13:31,089
application you don't want to be like

00:13:29,529 --> 00:13:32,259
creating this thing all over the place

00:13:31,089 --> 00:13:33,729
because you might swap out the

00:13:32,259 --> 00:13:36,099
implementation if this at any point you

00:13:33,729 --> 00:13:39,339
might decide to go to I can more react

00:13:36,099 --> 00:13:40,989
native approach there's also a layer

00:13:39,339 --> 00:13:43,689
sarong going to be some translation that

00:13:40,989 --> 00:13:46,329
happens here between the event handlers

00:13:43,689 --> 00:13:47,829
and commands that you go and have to do

00:13:46,329 --> 00:13:49,929
every single time so it's best just to

00:13:47,829 --> 00:13:53,220
sort of wrap this in JavaScript

00:13:49,929 --> 00:13:56,289
component and handle all of that in here

00:13:53,220 --> 00:13:57,669
the other reason is it actually just

00:13:56,289 --> 00:14:00,119
makes it a little bit easy to test

00:13:57,669 --> 00:14:02,829
because you can just mock this file and

00:14:00,119 --> 00:14:04,809
you join you don't have to start mocking

00:14:02,829 --> 00:14:06,009
require native component and like

00:14:04,809 --> 00:14:08,739
figuring out what that's going to turn

00:14:06,009 --> 00:14:10,119
and stuff so definitely like always wrap

00:14:08,739 --> 00:14:21,129
your native components in another

00:14:10,119 --> 00:14:23,249
JavaScript component so props so most

00:14:21,129 --> 00:14:25,569
important part of any react to the API

00:14:23,249 --> 00:14:28,269
react native supports a full set of

00:14:25,569 --> 00:14:30,369
primitives it supports the reason lists

00:14:28,269 --> 00:14:32,799
and it supports objects dictionaries and

00:14:30,369 --> 00:14:36,279
maps or whatever whatever you want to

00:14:32,799 --> 00:14:38,319
call them you create a prop by defining

00:14:36,279 --> 00:14:40,149
a set on your view which I'll show you

00:14:38,319 --> 00:14:41,470
in a second and then you have to wire

00:14:40,149 --> 00:14:42,849
that with to react narrative so it's

00:14:41,470 --> 00:14:44,999
always a two-step process you have to

00:14:42,849 --> 00:14:50,229
define a setter and then you have to

00:14:44,999 --> 00:14:52,809
wire it up to react narrative on iOS the

00:14:50,229 --> 00:14:54,549
primitives includes nsns CG floor and

00:14:52,809 --> 00:14:54,999
bool on swift that would be into floor

00:14:54,549 --> 00:14:57,849
and bool

00:14:54,999 --> 00:15:00,519
nsnumber is just like a class version of

00:14:57,849 --> 00:15:04,599
the previous three and nsstring

00:15:00,519 --> 00:15:07,959
represents strings arrears in lists or

00:15:04,599 --> 00:15:11,519
lists NS r NS mutable arere NS area is

00:15:07,959 --> 00:15:14,919
immutable so that's the difference

00:15:11,519 --> 00:15:16,479
objects dictionaries are Maps NS

00:15:14,919 --> 00:15:16,809
dictionary and NS mutable dictionary

00:15:16,479 --> 00:15:18,879
again

00:15:16,809 --> 00:15:22,389
anis dictionary is the immutable version

00:15:18,879 --> 00:15:25,899
of that on Android

00:15:22,389 --> 00:15:29,709
I've got integer flawed bill boolean and

00:15:25,899 --> 00:15:31,629
string careers and lists it's readable

00:15:29,709 --> 00:15:33,489
arere and writable or rare objects

00:15:31,629 --> 00:15:35,279
dictionaries and maps it's readable map

00:15:33,489 --> 00:15:37,690
and writable map

00:15:35,279 --> 00:15:39,459
these things here are actually

00:15:37,690 --> 00:15:41,110
interfaces so you can't instantiate them

00:15:39,459 --> 00:15:43,300
directly if you do need to create one

00:15:41,110 --> 00:15:45,730
you can use the arguments class which is

00:15:43,300 --> 00:15:46,690
sort of like a factory to create these

00:15:45,730 --> 00:15:48,190
there's actually a couple of

00:15:46,690 --> 00:15:49,630
implementations of each ones of these

00:15:48,190 --> 00:15:50,260
and arguments will just create the right

00:15:49,630 --> 00:15:52,959
one for you

00:15:50,260 --> 00:15:58,000
so yeah you can't can't instantiate them

00:15:52,959 --> 00:16:00,310
things directly that's great for simple

00:15:58,000 --> 00:16:02,380
data structures but most times it's not

00:16:00,310 --> 00:16:05,470
you won't have an object with various

00:16:02,380 --> 00:16:06,910
different properties and I just saw it

00:16:05,470 --> 00:16:08,829
cover some patterns for dealing with

00:16:06,910 --> 00:16:10,870
them because what would you want is just

00:16:08,829 --> 00:16:12,220
to have our views and view managers

00:16:10,870 --> 00:16:14,500
littered with conversions between

00:16:12,220 --> 00:16:19,029
dictionaries and JavaScript and our

00:16:14,500 --> 00:16:20,680
custom types in our native chord so out

00:16:19,029 --> 00:16:24,279
of the box in iOS is actually a class

00:16:20,680 --> 00:16:25,750
called RCT convert and I saw a few

00:16:24,279 --> 00:16:28,360
problems with this so it only works one

00:16:25,750 --> 00:16:30,690
way as far as I can tell and the other

00:16:28,360 --> 00:16:33,399
problem is or not a problem the other

00:16:30,690 --> 00:16:37,120
reason is that it really only saves you

00:16:33,399 --> 00:16:40,660
one line of cord when you bring in them

00:16:37,120 --> 00:16:42,310
in so we chose to use categories and

00:16:40,660 --> 00:16:44,410
extensions in iOS which I'll go over in

00:16:42,310 --> 00:16:47,410
a second and utilities and Android

00:16:44,410 --> 00:16:51,940
because categories and extensions aren't

00:16:47,410 --> 00:16:53,740
supported in Java so this is an

00:16:51,940 --> 00:16:57,399
extension in Swift so CL location

00:16:53,740 --> 00:16:59,529
coordinate 2d is a like struct from

00:16:57,399 --> 00:17:02,860
Apple's frameworks that represents like

00:16:59,529 --> 00:17:05,169
a latitude and longitude an extension

00:17:02,860 --> 00:17:06,819
allows you to add new functionality to

00:17:05,169 --> 00:17:10,230
an existing type so in this case we've

00:17:06,819 --> 00:17:13,329
added an initializer and function to

00:17:10,230 --> 00:17:15,850
convert it to and from like a JavaScript

00:17:13,329 --> 00:17:19,000
representation so a dictionary or a

00:17:15,850 --> 00:17:23,949
object that has string as a key and a

00:17:19,000 --> 00:17:25,510
double as a volume and you can't add

00:17:23,949 --> 00:17:27,910
extra dear setter

00:17:25,510 --> 00:17:32,620
classes or structs iris you can only add

00:17:27,910 --> 00:17:35,559
extra functionality so that's that this

00:17:32,620 --> 00:17:37,990
is the map view so this is a setter here

00:17:35,559 --> 00:17:40,929
for set in the center so this is the

00:17:37,990 --> 00:17:43,300
first part of our prop creation that's

00:17:40,929 --> 00:17:46,470
there the custom initializer we've just

00:17:43,300 --> 00:17:48,820
defined for that coordinate type and

00:17:46,470 --> 00:17:50,769
there's two ways of solved

00:17:48,820 --> 00:17:53,740
you can either just directly set the

00:17:50,769 --> 00:17:55,330
value on like internal views if you've

00:17:53,740 --> 00:17:57,600
got them weed is because we add like a

00:17:55,330 --> 00:18:00,070
couple of up using a in a clip interview

00:17:57,600 --> 00:18:01,419
however if you're doing some custom draw

00:18:00,070 --> 00:18:03,399
and you haven't really got anywhere to

00:18:01,419 --> 00:18:05,019
store these properties you can't just

00:18:03,399 --> 00:18:07,990
stall them yourself and then just ask

00:18:05,019 --> 00:18:10,690
the view to re-render itself so example

00:18:07,990 --> 00:18:11,980
of where we did that was the sort of

00:18:10,690 --> 00:18:14,409
yellow circle in the middle that was

00:18:11,980 --> 00:18:18,070
drawn with like core graphics and custom

00:18:14,409 --> 00:18:21,039
drawn there's no property on views to

00:18:18,070 --> 00:18:22,870
like express that so we need to destroy

00:18:21,039 --> 00:18:24,399
that value ourselves and then just ask

00:18:22,870 --> 00:18:28,990
the viewer to re-render on the next

00:18:24,399 --> 00:18:30,940
soive tick and then to export these to

00:18:28,990 --> 00:18:32,889
react narrative you just need to use

00:18:30,940 --> 00:18:35,200
another macro in Objective C and this

00:18:32,889 --> 00:18:37,240
particular one is our CT export for your

00:18:35,200 --> 00:18:41,620
property you just give it the name of

00:18:37,240 --> 00:18:43,840
the property in Objective C and then the

00:18:41,620 --> 00:18:46,809
type of the property as well and that

00:18:43,840 --> 00:18:48,639
will just react native know about it so

00:18:46,809 --> 00:18:53,909
it can like sort of send them back and

00:18:48,639 --> 00:18:57,669
forward on Android it's a very similar

00:18:53,909 --> 00:18:59,320
story so it we haven't got extensions so

00:18:57,669 --> 00:19:01,960
this is just a utils class that hazard

00:18:59,320 --> 00:19:04,600
from reactants to react method it takes

00:19:01,960 --> 00:19:08,559
a readable map which is just a like

00:19:04,600 --> 00:19:11,620
dictionary or object in Java and returns

00:19:08,559 --> 00:19:13,799
a lot long which is just like you in

00:19:11,620 --> 00:19:16,090
longitude and then the inverse of that

00:19:13,799 --> 00:19:17,860
takes a lot long and returns a readable

00:19:16,090 --> 00:19:21,700
map so same principles as before it's

00:19:17,860 --> 00:19:26,590
just using the utils class instead of an

00:19:21,700 --> 00:19:29,259
extension this is the Android

00:19:26,590 --> 00:19:31,899
implementation for the set s or just

00:19:29,259 --> 00:19:33,820
sets and a new lot long vowel U and then

00:19:31,899 --> 00:19:38,710
just set it directly on our internal map

00:19:33,820 --> 00:19:41,710
here and then to wire it up you just

00:19:38,710 --> 00:19:44,970
need a function defined which accepts an

00:19:41,710 --> 00:19:47,500
instance of your view and new value

00:19:44,970 --> 00:19:49,389
remember these manage multiple views so

00:19:47,500 --> 00:19:51,549
this is the view that you need to set

00:19:49,389 --> 00:19:53,440
the prop on and then just call the

00:19:51,549 --> 00:19:55,570
setter from in here we use the utils

00:19:53,440 --> 00:20:00,429
class to convert from a reactive value

00:19:55,570 --> 00:20:02,179
into our lat/long value and this is the

00:20:00,429 --> 00:20:04,490
bit that lets react native know

00:20:02,179 --> 00:20:07,129
the prop exists just an annotation on

00:20:04,490 --> 00:20:11,830
the methods that accept the new and in

00:20:07,129 --> 00:20:16,159
this case just center so that's props

00:20:11,830 --> 00:20:19,100
events events just like props for when

00:20:16,159 --> 00:20:23,419
things change and we have all used them

00:20:19,100 --> 00:20:25,940
in normal react so some examples on she

00:20:23,419 --> 00:20:29,149
engine starts on finish on something did

00:20:25,940 --> 00:20:31,249
feel so Lord there's two supported types

00:20:29,149 --> 00:20:34,100
of events in react narrative first one

00:20:31,249 --> 00:20:35,480
is direct second is bubblin so starting

00:20:34,100 --> 00:20:40,009
with bubble and this is very similar to

00:20:35,480 --> 00:20:42,700
a Dom event where a parent component can

00:20:40,009 --> 00:20:45,649
capture the event from a child component

00:20:42,700 --> 00:20:48,200
so on click perfect example you've got

00:20:45,649 --> 00:20:50,419
six views inside of another view the

00:20:48,200 --> 00:20:52,299
parent can capture that one click and do

00:20:50,419 --> 00:20:56,450
something about it

00:20:52,299 --> 00:20:58,580
the really meant for sort of UI events

00:20:56,450 --> 00:21:00,169
direct events are sort of not meant for

00:20:58,580 --> 00:21:02,960
UI events are meant for more abstract

00:21:00,169 --> 00:21:05,149
things like map did fail to Lourdes the

00:21:02,960 --> 00:21:07,399
things that were only really one person

00:21:05,149 --> 00:21:11,090
needs to know about not like clicks and

00:21:07,399 --> 00:21:12,830
drugs and stuff like that the

00:21:11,090 --> 00:21:14,990
implementation please is different on

00:21:12,830 --> 00:21:17,570
iOS so I think props were probably quite

00:21:14,990 --> 00:21:20,119
like similar in the way they implemented

00:21:17,570 --> 00:21:26,779
on both platforms events do get like

00:21:20,119 --> 00:21:29,749
separated a bit so on iOS to define an

00:21:26,779 --> 00:21:31,759
event you need to define a property with

00:21:29,749 --> 00:21:33,799
one of these types so it's I've RCT

00:21:31,759 --> 00:21:38,690
bubble and event block or RCT direct

00:21:33,799 --> 00:21:39,980
event block these are just objective-c

00:21:38,690 --> 00:21:43,059
blocks and you can just think of them

00:21:39,980 --> 00:21:45,049
like functions so they just like a

00:21:43,059 --> 00:21:50,210
variable of a function that can be

00:21:45,049 --> 00:21:52,669
called later on these are callbacks in

00:21:50,210 --> 00:21:55,399
iOS that just like a call when something

00:21:52,669 --> 00:21:56,659
happens because these are optional we

00:21:55,399 --> 00:21:59,240
just need to make sure that it actually

00:21:56,659 --> 00:22:02,990
exists before we try and call it once

00:21:59,240 --> 00:22:04,580
the application will crash and then just

00:22:02,990 --> 00:22:06,889
call it like a function so unchanged

00:22:04,580 --> 00:22:08,269
just is that there and then just pass

00:22:06,889 --> 00:22:11,419
through the value that you want to remit

00:22:08,269 --> 00:22:13,309
back to the react in the other side this

00:22:11,419 --> 00:22:14,990
is just an example of a direct one this

00:22:13,309 --> 00:22:15,710
particular one doesn t echo value it

00:22:14,990 --> 00:22:17,630
doesn't really

00:22:15,710 --> 00:22:21,700
the mops filter laws I suppose we could

00:22:17,630 --> 00:22:21,700
have passed the arrow back there as well

00:22:21,910 --> 00:22:28,430
and why you're in it up so exactly the

00:22:25,700 --> 00:22:30,080
same as a normal crop on iOS just RCT

00:22:28,430 --> 00:22:34,060
x-bar for your property the names of the

00:22:30,080 --> 00:22:37,270
props and the types of the variables

00:22:34,060 --> 00:22:37,270
that's it

00:22:37,300 --> 00:22:44,570
on Android things get a bit more

00:22:39,860 --> 00:22:46,280
complicated so in order to miss an event

00:22:44,570 --> 00:22:48,620
you need to get hold of this thing here

00:22:46,280 --> 00:22:51,290
which is the RCT event emitter and the

00:22:48,620 --> 00:22:53,510
only way to get that is from the context

00:22:51,290 --> 00:22:55,280
now by default every view has got a

00:22:53,510 --> 00:22:56,900
context and Android boy it won't be

00:22:55,280 --> 00:23:00,530
typed as react context that we typed

00:22:56,900 --> 00:23:02,120
this context probably so our first thing

00:23:00,530 --> 00:23:04,190
you need to do is cast that into a

00:23:02,120 --> 00:23:06,200
context which we can be fairly confident

00:23:04,190 --> 00:23:09,590
it is because like it's a react native

00:23:06,200 --> 00:23:13,040
view and then call get GS module on it

00:23:09,590 --> 00:23:15,920
that will return and event emitter which

00:23:13,040 --> 00:23:18,650
we've got here construct the event and

00:23:15,920 --> 00:23:22,310
then finally just call the receive event

00:23:18,650 --> 00:23:23,840
function which will emit the event you

00:23:22,310 --> 00:23:26,090
need to pass through the ID of the view

00:23:23,840 --> 00:23:27,470
because the event system needs to know

00:23:26,090 --> 00:23:29,450
what component this is being emitted

00:23:27,470 --> 00:23:31,400
from the name of the event which I'll

00:23:29,450 --> 00:23:34,930
get to in a second and then the event D

00:23:31,400 --> 00:23:34,930
etre itself which is just defined here

00:23:38,320 --> 00:23:43,250
so the wire they saw up unfortunately is

00:23:40,790 --> 00:23:46,550
not as simple as it was on iOS it's a

00:23:43,250 --> 00:23:48,020
bit more involved I've defined this in

00:23:46,550 --> 00:23:49,640
JavaScript on the next slide because I

00:23:48,020 --> 00:23:53,030
think this is a bit difficult to sort of

00:23:49,640 --> 00:23:54,440
pass but essentially depending on what

00:23:53,030 --> 00:23:57,110
type of then you've got you need to

00:23:54,440 --> 00:23:59,870
implement one of these methods the bit

00:23:57,110 --> 00:24:02,030
long-winded get export a custom direct

00:23:59,870 --> 00:24:04,760
event type constants or get x-bar a

00:24:02,030 --> 00:24:06,860
custom bubbling event I constants the

00:24:04,760 --> 00:24:08,750
both accept a fairly similar structure

00:24:06,860 --> 00:24:10,220
but it'll be much easier to see what

00:24:08,750 --> 00:24:13,820
that is on the next slide so I'll just

00:24:10,220 --> 00:24:16,760
carry on so these are the two structures

00:24:13,820 --> 00:24:19,610
in JavaScript if you've got a direct

00:24:16,760 --> 00:24:21,650
event it's expected to be an object with

00:24:19,610 --> 00:24:22,700
a key for each event and this is the

00:24:21,650 --> 00:24:26,900
name that you will pass through the

00:24:22,700 --> 00:24:29,389
event emitter the next bit is so that

00:24:26,900 --> 00:24:31,159
has to be a object with a single key

00:24:29,389 --> 00:24:32,570
and it just needs to be registration

00:24:31,159 --> 00:24:34,700
name and then the name of the crop on

00:24:32,570 --> 00:24:36,649
the JavaScript side and that's what sort

00:24:34,700 --> 00:24:38,749
of makes the link between your Java

00:24:36,649 --> 00:24:40,969
events and the JavaScript events on the

00:24:38,749 --> 00:24:41,599
other side for bubblin it's a bit more

00:24:40,969 --> 00:24:44,659
complicated

00:24:41,599 --> 00:24:47,719
a bit more longer so you've got a sim

00:24:44,659 --> 00:24:50,839
structure near mother the event in Java

00:24:47,719 --> 00:24:52,309
it has to have an object as a value it

00:24:50,839 --> 00:24:55,099
needs a single key called first

00:24:52,309 --> 00:24:57,200
registration names and then that is

00:24:55,099 --> 00:24:59,539
expected to be another object with at

00:24:57,200 --> 00:25:01,459
least one key called bubbled and that

00:24:59,539 --> 00:25:04,159
should be the name of the crop on the

00:25:01,459 --> 00:25:06,619
JavaScript side if you do want to

00:25:04,159 --> 00:25:09,169
override the name of the captured events

00:25:06,619 --> 00:25:10,700
you can do that here but like in most

00:25:09,169 --> 00:25:12,440
cases probably just safe to leave that

00:25:10,700 --> 00:25:14,659
off and just use the defaults like

00:25:12,440 --> 00:25:20,209
capture on the end for like the rest of

00:25:14,659 --> 00:25:24,559
react events and then to wire this up in

00:25:20,209 --> 00:25:26,839
JavaScript just define a handler that

00:25:24,559 --> 00:25:28,159
you can pass through to the view make

00:25:26,839 --> 00:25:29,239
sure that you've actually got the proper

00:25:28,159 --> 00:25:31,249
variable because most of these are

00:25:29,239 --> 00:25:33,200
probably going to be optional and then

00:25:31,249 --> 00:25:35,749
just extract whatever information you

00:25:33,200 --> 00:25:37,519
need out with the native event and just

00:25:35,749 --> 00:25:40,669
omit it and it's as simple as that

00:25:37,519 --> 00:25:43,879
really does this translation layer here

00:25:40,669 --> 00:25:45,409
and just saw the like we're not emitting

00:25:43,879 --> 00:25:47,719
native events all over the application

00:25:45,409 --> 00:25:49,669
just in case there's any like any other

00:25:47,719 --> 00:25:51,919
change to the C API and somewhere just

00:25:49,669 --> 00:25:57,079
saves us from having to change change

00:25:51,919 --> 00:25:59,570
the court everywhere so the last bit of

00:25:57,079 --> 00:26:02,749
API you need to build an it component is

00:25:59,570 --> 00:26:04,039
a command so after this there should be

00:26:02,749 --> 00:26:07,129
every bit of information you need to

00:26:04,039 --> 00:26:08,779
build a native component so commands are

00:26:07,129 --> 00:26:13,070
just like methods on your components

00:26:08,779 --> 00:26:14,209
just a weird to sort of ask them to do

00:26:13,070 --> 00:26:15,950
something without having to deal with

00:26:14,209 --> 00:26:18,859
like sending props back and forward and

00:26:15,950 --> 00:26:20,539
stuff like that the access through refs

00:26:18,859 --> 00:26:22,519
or just like you would on a normal saw

00:26:20,539 --> 00:26:23,899
every up components you'd get a referee

00:26:22,519 --> 00:26:25,879
a component and then call a method on

00:26:23,899 --> 00:26:27,320
the instance of it exactly the same it's

00:26:25,879 --> 00:26:31,219
just this method happens to get

00:26:27,320 --> 00:26:33,169
dispatched on the native side again

00:26:31,219 --> 00:26:37,029
different implementations on iOS and

00:26:33,169 --> 00:26:40,129
Android but I've got examples of both so

00:26:37,029 --> 00:26:41,749
defining a command the reason we need is

00:26:40,129 --> 00:26:42,850
a command is because we were using map

00:26:41,749 --> 00:26:45,490
boxes

00:26:42,850 --> 00:26:46,720
mahp view for both of them and there's

00:26:45,490 --> 00:26:48,700
actually a little button in the bottom

00:26:46,720 --> 00:26:52,120
right hand corner of the map box map

00:26:48,700 --> 00:26:54,250
sure the attribution UI and start was

00:26:52,120 --> 00:26:55,720
conflicting with our UI so we took the

00:26:54,250 --> 00:26:57,340
button out but we needed in another way

00:26:55,720 --> 00:26:59,200
to trigger a circus we still needed

00:26:57,340 --> 00:27:01,930
there it was a requirement of users and

00:26:59,200 --> 00:27:04,780
Mudbox so we needed a way to trigger

00:27:01,930 --> 00:27:07,000
that UI from the JavaScript side but the

00:27:04,780 --> 00:27:09,040
call to do that was in native call so

00:27:07,000 --> 00:27:13,170
this command here lets us do that by

00:27:09,040 --> 00:27:13,170
asking them up to show such abuse in UI

00:27:15,270 --> 00:27:22,330
this is the view manager part side of it

00:27:19,810 --> 00:27:23,130
so show our tribution it's the name of

00:27:22,330 --> 00:27:25,510
the command

00:27:23,130 --> 00:27:27,580
notice the underscore here so this all

00:27:25,510 --> 00:27:30,070
this is in a little bit of Swift

00:27:27,580 --> 00:27:32,140
translation so because this isn't sure

00:27:30,070 --> 00:27:34,540
attribution with react tag it's just

00:27:32,140 --> 00:27:36,430
show attribution react tag the

00:27:34,540 --> 00:27:38,170
undisguised there to sort of map that

00:27:36,430 --> 00:27:40,570
into what an objective-c method would

00:27:38,170 --> 00:27:44,470
look like so it's a little bit of like

00:27:40,570 --> 00:27:45,880
nietzermann conventions again so right

00:27:44,470 --> 00:27:49,300
at the beginning of the talk I said keep

00:27:45,880 --> 00:27:53,230
most interact with UI kit and all its

00:27:49,300 --> 00:27:54,880
various friends on the main thread so

00:27:53,230 --> 00:27:56,200
that's a requirement number one of this

00:27:54,880 --> 00:27:57,460
because this might not be called on the

00:27:56,200 --> 00:28:01,240
main thread we don't know it's not

00:27:57,460 --> 00:28:02,920
documented second is they actually

00:28:01,240 --> 00:28:04,720
recommend that you do any of these

00:28:02,920 --> 00:28:07,960
commands after any objects have finished

00:28:04,720 --> 00:28:09,220
to the view so there is a because you

00:28:07,960 --> 00:28:11,290
might block the rendering of it or

00:28:09,220 --> 00:28:13,060
something if this is like a really sort

00:28:11,290 --> 00:28:16,080
of intensive task especially considering

00:28:13,060 --> 00:28:16,080
it needs to be done on the main thread

00:28:16,110 --> 00:28:21,460
so to do this react near provides a

00:28:19,690 --> 00:28:23,380
class called UI manager that lets you

00:28:21,460 --> 00:28:25,360
add a block of cord to be executed later

00:28:23,380 --> 00:28:28,090
on on the main thread after any of you

00:28:25,360 --> 00:28:30,910
updates have happened and this will call

00:28:28,090 --> 00:28:33,880
you back with a view registry now this

00:28:30,910 --> 00:28:35,470
comes in in Swift is optional and I'd be

00:28:33,880 --> 00:28:36,670
surprised if it ever would be optional

00:28:35,470 --> 00:28:38,020
but because it's coming through was

00:28:36,670 --> 00:28:41,260
optional in Swift we actually have to

00:28:38,020 --> 00:28:44,920
deal with that so first line just make

00:28:41,260 --> 00:28:48,280
sure that it actually exists second line

00:28:44,920 --> 00:28:49,720
is just to find our map view based on

00:28:48,280 --> 00:28:53,410
the target that was passed in here so on

00:28:49,720 --> 00:28:55,240
iOS views in view in the view managers

00:28:53,410 --> 00:28:57,580
are represented by a tag on iOS

00:28:55,240 --> 00:29:01,480
sorry on Android it's an ID on iOS it's

00:28:57,580 --> 00:29:05,799
a tug this registry here is just a

00:29:01,480 --> 00:29:07,720
dictionary from NS number to UI view and

00:29:05,799 --> 00:29:10,659
because it's coming from Objective C

00:29:07,720 --> 00:29:12,429
it's not that well typed it's so we have

00:29:10,659 --> 00:29:13,779
to unfortunately force cast it to be a

00:29:12,429 --> 00:29:16,210
map view unless we wouldn't be able to

00:29:13,779 --> 00:29:18,100
call any commands on it so that's what

00:29:16,210 --> 00:29:21,279
this sort of chord is doing here

00:29:18,100 --> 00:29:23,679
and finally just on the instance of the

00:29:21,279 --> 00:29:25,419
map view calls show attribution that'll

00:29:23,679 --> 00:29:33,220
show the show attribution UI for the

00:29:25,419 --> 00:29:36,279
user to look at last but not least on

00:29:33,220 --> 00:29:40,570
iOS you just need to now expose this to

00:29:36,279 --> 00:29:44,500
react narrative so our CTX turn method

00:29:40,570 --> 00:29:45,820
show attribution there's no width I

00:29:44,500 --> 00:29:52,779
guess of us rather than underscore in

00:29:45,820 --> 00:29:58,120
Swift so show attribution react tag on

00:29:52,779 --> 00:29:59,950
Android cm thing methods to execute for

00:29:58,120 --> 00:30:01,929
the command and then just do something

00:29:59,950 --> 00:30:03,390
as a part of that method in our case we

00:30:01,929 --> 00:30:05,890
just needed to show the attribution UI

00:30:03,390 --> 00:30:10,830
I've actually shortened this a bit it's

00:30:05,890 --> 00:30:15,760
a bit longer but it's the same principle

00:30:10,830 --> 00:30:18,580
on Android you need to do this which is

00:30:15,760 --> 00:30:22,210
this just returns a map from the command

00:30:18,580 --> 00:30:25,059
name to a specific integer that can be

00:30:22,210 --> 00:30:27,250
used to represent the command and then

00:30:25,059 --> 00:30:30,880
lastly just over I to receive command

00:30:27,250 --> 00:30:32,860
this will be provided here view which is

00:30:30,880 --> 00:30:34,600
the view that the command needs to be

00:30:32,860 --> 00:30:36,610
called on the ID which is what you've

00:30:34,600 --> 00:30:37,929
defined appear and any arguments that

00:30:36,610 --> 00:30:40,450
have been passed in from the react

00:30:37,929 --> 00:30:42,909
native side it's in the JavaScript side

00:30:40,450 --> 00:30:45,010
even and then it's just a case of like

00:30:42,909 --> 00:30:46,630
checking if the command ID match is what

00:30:45,010 --> 00:30:50,940
you're expecting and then calling the

00:30:46,630 --> 00:30:50,940
Shore attribution method

00:30:53,270 --> 00:31:02,100
in JavaScript get a ref to the native

00:30:58,470 --> 00:31:03,630
components and then just define a method

00:31:02,100 --> 00:31:04,919
here like if someone needs to call this

00:31:03,630 --> 00:31:06,539
method they would then have to get rest

00:31:04,919 --> 00:31:08,809
of this JavaScript component as well so

00:31:06,539 --> 00:31:13,380
it's a sort to ref stuff to happen and

00:31:08,809 --> 00:31:14,880
just import the UI manager from react

00:31:13,380 --> 00:31:17,340
native and called this but if you manage

00:31:14,880 --> 00:31:19,440
your command pass in the view pass in

00:31:17,340 --> 00:31:22,080
the command you want to run you can get

00:31:19,440 --> 00:31:23,400
that from the ref so view config will

00:31:22,080 --> 00:31:24,780
come back as part the ref and you can

00:31:23,400 --> 00:31:29,220
get all the information you need there

00:31:24,780 --> 00:31:30,720
to send the command off this is just

00:31:29,220 --> 00:31:32,940
where you're passing the arguments we

00:31:30,720 --> 00:31:35,370
didn't have any sort just null but yeah

00:31:32,940 --> 00:31:38,039
that's it that's everything you need to

00:31:35,370 --> 00:31:39,330
know to build a native component so I'm

00:31:38,039 --> 00:31:40,710
just going to briefly touch on how we

00:31:39,330 --> 00:31:43,440
tested all of this because I think

00:31:40,710 --> 00:31:48,299
that's just as important and then on to

00:31:43,440 --> 00:31:50,250
questions and stuff like that so we

00:31:48,299 --> 00:31:51,659
definitely want a unit test our logic

00:31:50,250 --> 00:31:56,250
that was like one of the goals from the

00:31:51,659 --> 00:31:58,230
outset we had varying approaches to do

00:31:56,250 --> 00:31:59,070
that on the different platforms and iOS

00:31:58,230 --> 00:32:00,990
it was actually quite straightforward

00:31:59,070 --> 00:32:02,760
you just instantiate at the view and

00:32:00,990 --> 00:32:05,490
just we'd already built it in such a way

00:32:02,760 --> 00:32:06,960
that most of the logic had been so I've

00:32:05,490 --> 00:32:08,130
extracted out into separate methods

00:32:06,960 --> 00:32:10,169
anywhere so we could just call the

00:32:08,130 --> 00:32:11,820
methods with the right dependencies and

00:32:10,169 --> 00:32:15,360
parameters and just make sure that the

00:32:11,820 --> 00:32:17,549
result was what we expected on Android

00:32:15,360 --> 00:32:19,679
it was a bit more complicated when you

00:32:17,549 --> 00:32:21,659
run unit tests and Android by default it

00:32:19,679 --> 00:32:23,190
actually stubs out to the entire Android

00:32:21,659 --> 00:32:24,960
framework or the version that throws an

00:32:23,190 --> 00:32:27,659
exception whenever you try and call and

00:32:24,960 --> 00:32:29,970
I enjoy you two framework method so just

00:32:27,659 --> 00:32:31,409
in a unit test and step instantiate and

00:32:29,970 --> 00:32:33,299
the view in trying to call methods on it

00:32:31,409 --> 00:32:36,030
will ultimately just end up in an

00:32:33,299 --> 00:32:37,740
exception being thrown now there are

00:32:36,030 --> 00:32:39,840
third-party libraries to help get around

00:32:37,740 --> 00:32:41,970
this but there's two problems with them

00:32:39,840 --> 00:32:43,950
so it firstly be quite tricky to get

00:32:41,970 --> 00:32:45,840
working with native dependencies as in

00:32:43,950 --> 00:32:48,000
like Android near dependencies so

00:32:45,840 --> 00:32:51,299
anything that's used in C++ or things

00:32:48,000 --> 00:32:53,340
like that and we were we were use a

00:32:51,299 --> 00:32:55,799
matte box which is mostly written in C++

00:32:53,340 --> 00:32:57,750
so that like was an initial sort of raw

00:32:55,799 --> 00:32:59,549
block the other problem is the sort of

00:32:57,750 --> 00:33:01,380
lag behind on Android releases a bit

00:32:59,549 --> 00:33:04,530
because you have to implement the hafted

00:33:01,380 --> 00:33:06,480
sort keep up with the Android API so it

00:33:04,530 --> 00:33:06,990
could wouldn't intentionally add some

00:33:06,480 --> 00:33:08,970
drug

00:33:06,990 --> 00:33:11,190
to your release process if you win for a

00:33:08,970 --> 00:33:14,040
test in dependency to be up days or to

00:33:11,190 --> 00:33:15,660
solve problems with it ultimately we

00:33:14,040 --> 00:33:18,420
decided that that was just too much sort

00:33:15,660 --> 00:33:20,610
of tech tech to take on just to test a

00:33:18,420 --> 00:33:22,530
single view so what we did is just

00:33:20,610 --> 00:33:25,230
extract out all the logic into playing

00:33:22,530 --> 00:33:28,800
JavaScript classes and test them it did

00:33:25,230 --> 00:33:30,570
add some chord complexity but it did

00:33:28,800 --> 00:33:32,280
mean that we could sort of test all the

00:33:30,570 --> 00:33:33,840
logic that we wanted to test and the

00:33:32,280 --> 00:33:40,380
rest of it was just covered by UI in

00:33:33,840 --> 00:33:43,350
application tests so what we learned

00:33:40,380 --> 00:33:45,870
from this I think is important as well

00:33:43,350 --> 00:33:47,910
so iOS is definitely a cleaner API than

00:33:45,870 --> 00:33:50,910
Android from a react native point of

00:33:47,910 --> 00:33:52,710
view Android feels he's a less finished

00:33:50,910 --> 00:33:55,440
or less polished I'm not sure which one

00:33:52,710 --> 00:33:57,330
of them it is but it is just seems to

00:33:55,440 --> 00:33:58,610
have it like nailed down a bit more

00:33:57,330 --> 00:34:01,140
[Music]

00:33:58,610 --> 00:34:02,700
testing is definitely more complex on

00:34:01,140 --> 00:34:04,440
Android I don't think that's a react

00:34:02,700 --> 00:34:06,690
native problem I just think it it's just

00:34:04,440 --> 00:34:08,580
an Android problem I'm sure if we were

00:34:06,690 --> 00:34:12,060
building a larger Android app it would

00:34:08,580 --> 00:34:13,590
have been sort of worth more investment

00:34:12,060 --> 00:34:16,649
in trying to figure it out properly but

00:34:13,590 --> 00:34:19,800
it was one view we just we did what we

00:34:16,649 --> 00:34:22,310
needed to to get tested the only big

00:34:19,800 --> 00:34:26,070
issue we had was with memory on iOS so

00:34:22,310 --> 00:34:30,090
this stemmed to the to pass rendering

00:34:26,070 --> 00:34:31,320
problem so when you zoom in that circle

00:34:30,090 --> 00:34:33,389
actually gets bigger and bigger and

00:34:31,320 --> 00:34:35,790
bigger and it got to the point where

00:34:33,389 --> 00:34:38,149
that sort of clipped view was saw a big

00:34:35,790 --> 00:34:40,619
part of the clipping process and the

00:34:38,149 --> 00:34:43,560
rendering process actually rasterizes

00:34:40,619 --> 00:34:45,600
that image so you end up with like quite

00:34:43,560 --> 00:34:47,609
large bitmaps in memory and that was

00:34:45,600 --> 00:34:50,190
ultimately leading to the application

00:34:47,609 --> 00:34:52,350
being killed because of memory issues so

00:34:50,190 --> 00:34:54,090
the way we go around that was just to

00:34:52,350 --> 00:34:55,710
disable the clipping and disable the

00:34:54,090 --> 00:34:57,210
yellow circle once it got to the point

00:34:55,710 --> 00:34:59,550
where it was too big to fit on the

00:34:57,210 --> 00:35:01,290
screen anymore anywhere so at a certain

00:34:59,550 --> 00:35:02,760
point you can actually see in the cons

00:35:01,290 --> 00:35:06,150
if you look at the arc the yellow circle

00:35:02,760 --> 00:35:08,609
actually disappears and that is what

00:35:06,150 --> 00:35:10,980
helped us avoid that sort of memory

00:35:08,609 --> 00:35:14,880
crash or kill whatever you want to call

00:35:10,980 --> 00:35:16,420
it and any questions are welcomed and

00:35:14,880 --> 00:35:16,480
thanks for listening

00:35:16,420 --> 00:35:22,420
you

00:35:16,480 --> 00:35:22,420

YouTube URL: https://www.youtube.com/watch?v=fSioAPn3keE


