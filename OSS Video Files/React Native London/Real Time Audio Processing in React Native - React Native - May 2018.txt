Title: Real Time Audio Processing in React Native - React Native - May 2018
Publication date: 2018-06-05
Playlist: React Native London
Description: 
	Real time audio processing in React Native - Zia Grosvenor

In this talk, we will compare cross platform audio engine libraries that can be used with React Native.

We will also discuss potential pain points and advise for building a smooth real time feel in an audio app with React Native.
_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,830
so before jumping into this might one

00:00:02,040 --> 00:00:06,660
day you know why why C++ you know isn't

00:00:04,830 --> 00:00:10,050
there anything on NPM can't we just use

00:00:06,660 --> 00:00:12,179
can we just use a module so if you look

00:00:10,050 --> 00:00:15,660
at the state of the art on OPM from the

00:00:12,179 --> 00:00:18,029
research that i've done i found that the

00:00:15,660 --> 00:00:21,150
functionality you can get is playback

00:00:18,029 --> 00:00:24,060
and recording of audio so there's no

00:00:21,150 --> 00:00:26,970
real time no chance to you know modulate

00:00:24,060 --> 00:00:29,130
the pitch of a sound no chance to add

00:00:26,970 --> 00:00:33,270
reverb to a sound no chance to write

00:00:29,130 --> 00:00:36,420
your own DSP blocks and run them so npm

00:00:33,270 --> 00:00:39,000
isn't isn't really a viable option i can

00:00:36,420 --> 00:00:41,250
also refer you to tom dummkopfs talk

00:00:39,000 --> 00:00:43,200
from Roley i need to do a talk on me at

00:00:41,250 --> 00:00:46,440
native at the audio developers meetup

00:00:43,200 --> 00:00:48,930
recently and he explained how to connect

00:00:46,440 --> 00:00:51,420
juice into your react native apps as

00:00:48,930 --> 00:00:54,660
another talk that i can let me give you

00:00:51,420 --> 00:00:57,030
a link to so yeah the summary there's

00:00:54,660 --> 00:01:01,469
there's no real real-time DSP control

00:00:57,030 --> 00:01:02,489
from JavaScript or an NPM yeah okay so

00:01:01,469 --> 00:01:04,530
yeah

00:01:02,489 --> 00:01:09,630
we will have to build our own bridge

00:01:04,530 --> 00:01:14,189
module so this who's who's worked with

00:01:09,630 --> 00:01:16,860
the react native bridge own before cool

00:01:14,189 --> 00:01:19,500
so the reanimated bridge all of the

00:01:16,860 --> 00:01:21,720
react native UI goes through the react

00:01:19,500 --> 00:01:23,189
native bridge so whenever you change

00:01:21,720 --> 00:01:24,600
something change a prop when your

00:01:23,189 --> 00:01:26,850
JavaScript if that needs to make an

00:01:24,600 --> 00:01:28,140
update to the native component then it

00:01:26,850 --> 00:01:30,509
will go through the reanimated bridge

00:01:28,140 --> 00:01:32,610
but you can also create your own react

00:01:30,509 --> 00:01:35,579
native modules of your native bridge

00:01:32,610 --> 00:01:37,590
modules which will allow you to

00:01:35,579 --> 00:01:40,740
communicate down there on the same

00:01:37,590 --> 00:01:44,909
bridges as the rest of your UI code yeah

00:01:40,740 --> 00:01:47,369
so also like key part of this picking an

00:01:44,909 --> 00:01:49,200
audio engine library to use and so I'm

00:01:47,369 --> 00:01:51,990
going to give an overview of three main

00:01:49,200 --> 00:01:54,390
libraries that I could recommend using

00:01:51,990 --> 00:01:57,479
how are these three I've used two of

00:01:54,390 --> 00:02:00,780
them and juice is the other one so I can

00:01:57,479 --> 00:02:02,790
refer you to Tom Tom Tom Doncaster talk

00:02:00,780 --> 00:02:05,310
fill out his very good and you can see

00:02:02,790 --> 00:02:09,690
how to communicate from react native to

00:02:05,310 --> 00:02:10,940
juice with that talk okay so also yeah

00:02:09,690 --> 00:02:14,810
probably gone over that

00:02:10,940 --> 00:02:16,130
why C++ so obviously react native it's

00:02:14,810 --> 00:02:20,450
cross-platform we're looking to deploy

00:02:16,130 --> 00:02:22,850
to iOS and Android so C++ C code is

00:02:20,450 --> 00:02:26,630
cross-platform so if you write your

00:02:22,850 --> 00:02:28,130
audio engine and C++ or C then it's you

00:02:26,630 --> 00:02:32,300
know you're gonna be able to run that on

00:02:28,130 --> 00:02:34,430
Android and iOS I can only talk from

00:02:32,300 --> 00:02:36,380
experience with iOS but I know that the

00:02:34,430 --> 00:02:37,610
libraries that I'm recommending here

00:02:36,380 --> 00:02:38,990
definitely run on Android as well

00:02:37,610 --> 00:02:42,140
there's there's a lot of examples of the

00:02:38,990 --> 00:02:45,650
money one Android so also another reason

00:02:42,140 --> 00:02:48,260
to use C++ or C is the performance so

00:02:45,650 --> 00:02:50,510
for real-time audio processing is very

00:02:48,260 --> 00:02:52,460
important the performance you can get

00:02:50,510 --> 00:02:54,170
into a situation where your if you have

00:02:52,460 --> 00:02:58,760
a performance problem your audio will

00:02:54,170 --> 00:03:01,940
pop or there will be kind of clicking or

00:02:58,760 --> 00:03:05,330
choking in the audio so that's that's

00:03:01,940 --> 00:03:07,340
another reason why people use C++ and

00:03:05,330 --> 00:03:10,580
the third reason so building on

00:03:07,340 --> 00:03:12,800
established code bases so if you look on

00:03:10,580 --> 00:03:16,190
the juice forum or if you look on online

00:03:12,800 --> 00:03:19,250
PSP forums a lot of the examples of C++

00:03:16,190 --> 00:03:21,380
I mean I work with some like DSP

00:03:19,250 --> 00:03:23,210
engineer's at work and there you see a

00:03:21,380 --> 00:03:25,610
C++ that starts the language of choice

00:03:23,210 --> 00:03:27,470
so I think the community is there nuts

00:03:25,610 --> 00:03:31,580
that's really the language of people

00:03:27,470 --> 00:03:33,130
using ok so the first library that I'd

00:03:31,580 --> 00:03:36,740
like to kind of present to you today

00:03:33,130 --> 00:03:39,500
it's called super powered so it's a

00:03:36,740 --> 00:03:42,650
cross-platform audio engine library for

00:03:39,500 --> 00:03:45,350
iOS Android and also yet wearables

00:03:42,650 --> 00:03:46,730
desktop it's it's scholar you know it

00:03:45,350 --> 00:03:50,390
burns on on several different platforms

00:03:46,730 --> 00:03:51,830
so yeah the pros of this library I would

00:03:50,390 --> 00:03:54,680
say out of the three it's the quickest

00:03:51,830 --> 00:03:56,930
to get started with it's got high level

00:03:54,680 --> 00:03:59,120
C++ API you can get straight in and you

00:03:56,930 --> 00:04:00,560
can create you can open up an audio

00:03:59,120 --> 00:04:01,970
source and then you can tell it to loop

00:04:00,560 --> 00:04:03,770
between two points and it will just

00:04:01,970 --> 00:04:06,200
constantly loop between those points I

00:04:03,770 --> 00:04:10,120
mean that's quite a high level API in

00:04:06,200 --> 00:04:13,310
terms of how you know C++ DSP code works

00:04:10,120 --> 00:04:17,120
it's not coupled to the UI by default so

00:04:13,310 --> 00:04:19,299
it's just audio engine code running

00:04:17,120 --> 00:04:24,199
inside of audio processing callback

00:04:19,299 --> 00:04:28,340
using Core Audio audio unit so all the

00:04:24,199 --> 00:04:32,509
clÃ¡udio code is open source I can also

00:04:28,340 --> 00:04:34,250
say allows you to plug in existing DSP

00:04:32,509 --> 00:04:36,469
blocks so if you're working with the DSP

00:04:34,250 --> 00:04:39,250
engine they're there they used to this

00:04:36,469 --> 00:04:42,500
place where you have an input which is

00:04:39,250 --> 00:04:46,849
stereo to two channels of floating-point

00:04:42,500 --> 00:04:49,039
data so that's your sample data and then

00:04:46,849 --> 00:04:52,219
you you process that data and you output

00:04:49,039 --> 00:04:54,800
another stream of floating-point sample

00:04:52,219 --> 00:04:56,479
data so it blesses this is how

00:04:54,800 --> 00:04:58,219
superpowers audio processing callback

00:04:56,479 --> 00:05:00,620
works the buffer is imports

00:04:58,219 --> 00:05:02,210
floating-point stereo audio and its

00:05:00,620 --> 00:05:05,689
output a disclosing quench stereo audio

00:05:02,210 --> 00:05:08,990
so straight for that there's lots of

00:05:05,689 --> 00:05:11,689
features built-in so this filters this

00:05:08,990 --> 00:05:14,689
is an audio source as an FFT plug-in is

00:05:11,689 --> 00:05:18,979
echo I've talked about about the looping

00:05:14,689 --> 00:05:22,039
as extensive API there the cons of this

00:05:18,979 --> 00:05:23,539
it's licensed so if you want to use any

00:05:22,039 --> 00:05:26,569
of the audio streaming stuff inside of

00:05:23,539 --> 00:05:30,379
there for HTTP streaming there's a

00:05:26,569 --> 00:05:32,629
fairly chunky license feeder also the

00:05:30,379 --> 00:05:36,020
API has its limitations because it's so

00:05:32,629 --> 00:05:37,669
high level you might not be able to lead

00:05:36,020 --> 00:05:39,319
with the audio source you might not be

00:05:37,669 --> 00:05:41,569
able to get right in there and write

00:05:39,319 --> 00:05:43,339
your own custom code because it's often

00:05:41,569 --> 00:05:45,319
you've got a high level API though the

00:05:43,339 --> 00:05:48,020
code base is closed source so all you

00:05:45,319 --> 00:05:50,449
get is a compiled static binary dot a

00:05:48,020 --> 00:05:51,860
file that you can run in your iOS app

00:05:50,449 --> 00:05:54,610
but you know you're um you have to look

00:05:51,860 --> 00:05:58,759
at the source code this is impossible

00:05:54,610 --> 00:06:00,169
so the next one this juice so the post

00:05:58,759 --> 00:06:03,229
of this one it's got a very large

00:06:00,169 --> 00:06:04,759
community the juice forum you can go on

00:06:03,229 --> 00:06:06,080
there there's there's all sorts of

00:06:04,759 --> 00:06:08,539
different examples that people are

00:06:06,080 --> 00:06:10,699
posted there's like questions topics

00:06:08,539 --> 00:06:12,319
about native there's questions topics

00:06:10,699 --> 00:06:15,379
about different types of DSP blocks you

00:06:12,319 --> 00:06:17,509
might want to build so yeah definitely

00:06:15,379 --> 00:06:21,409
recommend for a community that the juice

00:06:17,509 --> 00:06:23,810
was very good so again it allows you to

00:06:21,409 --> 00:06:27,110
plug in existing sample level DSP blocks

00:06:23,810 --> 00:06:29,060
and so yeah if you've got some curd the

00:06:27,110 --> 00:06:30,409
process of sample data you know you can

00:06:29,060 --> 00:06:33,050
plug it straight into your juice or

00:06:30,409 --> 00:06:34,750
audio person and go back which is it's

00:06:33,050 --> 00:06:38,830
kind of similar to super hard and out

00:06:34,750 --> 00:06:41,440
but yeah so the license also it's pretty

00:06:38,830 --> 00:06:43,600
cheap would juice just like thousand

00:06:41,440 --> 00:06:45,400
pounds for developer license so it's not

00:06:43,600 --> 00:06:49,480
so bad and that's like I think that's

00:06:45,400 --> 00:06:50,890
lifetime so yeah it's okay and you will

00:06:49,480 --> 00:06:52,600
find that with a lot of these libraries

00:06:50,890 --> 00:06:54,430
valued about this there's only three

00:06:52,600 --> 00:06:56,200
main ones but they're they're looking to

00:06:54,430 --> 00:06:58,510
license said they're looking to either

00:06:56,200 --> 00:06:59,920
for you to put the logo on a splash

00:06:58,510 --> 00:07:02,890
screen of your app or for you to pay

00:06:59,920 --> 00:07:06,940
them because the code is I suppose they

00:07:02,890 --> 00:07:10,000
they value it so it's a very large

00:07:06,940 --> 00:07:12,640
framework so it might take some time to

00:07:10,000 --> 00:07:14,890
get started with it and also it's a lot

00:07:12,640 --> 00:07:17,140
of what's useful it's making plug in so

00:07:14,890 --> 00:07:19,330
if you've ever used Logic Pro or

00:07:17,140 --> 00:07:21,910
anything you know in the digital audio

00:07:19,330 --> 00:07:25,030
stations or space on on your on your Mac

00:07:21,910 --> 00:07:26,350
or on your Windows computer the you

00:07:25,030 --> 00:07:27,669
probably have been using juice if you're

00:07:26,350 --> 00:07:30,010
using any third-party plugins because

00:07:27,669 --> 00:07:32,200
the most buggins that you see in digital

00:07:30,010 --> 00:07:35,680
audio workstations are built with juice

00:07:32,200 --> 00:07:37,780
as a sort of framework to get started so

00:07:35,680 --> 00:07:41,440
yeah I would recommend this talk on

00:07:37,780 --> 00:07:43,300
skills ma for building building a react

00:07:41,440 --> 00:07:46,660
native app with juice so it's really

00:07:43,300 --> 00:07:49,180
good so went to that talk spoke to John

00:07:46,660 --> 00:07:52,870
cheongdam-dong - yes definitely

00:07:49,180 --> 00:07:54,780
recommend that and the third one is my

00:07:52,870 --> 00:08:00,180
my favorite at the moment

00:07:54,780 --> 00:08:04,240
this is gstreamer so gstreamer is a

00:08:00,180 --> 00:08:06,580
framework for multimedia pipelines so

00:08:04,240 --> 00:08:08,380
it's got a lot it's not just built for

00:08:06,580 --> 00:08:11,650
audio processing it's built for video

00:08:08,380 --> 00:08:13,479
streaming is built for video processing

00:08:11,650 --> 00:08:15,160
apps if you if you want to you know

00:08:13,479 --> 00:08:17,400
build something like Premiere Pro you

00:08:15,160 --> 00:08:22,120
could start building it with a gstreamer

00:08:17,400 --> 00:08:25,000
yeah so the pros of gstreamer it's got a

00:08:22,120 --> 00:08:27,210
high level API and a low level API so so

00:08:25,000 --> 00:08:30,640
what do I mean by this getting started

00:08:27,210 --> 00:08:33,060
you can write no base DSP so if you've

00:08:30,640 --> 00:08:35,830
ever allow them use the Web Audio API

00:08:33,060 --> 00:08:39,099
use maybe creating web audio nodes

00:08:35,830 --> 00:08:40,659
connecting them together you can do the

00:08:39,099 --> 00:08:43,750
same thing with gstreamer once you get a

00:08:40,659 --> 00:08:46,240
set up you can you can get elements and

00:08:43,750 --> 00:08:47,410
plug-in registry link them together and

00:08:46,240 --> 00:08:50,110
I'm going to give a demonstration of

00:08:47,410 --> 00:08:53,500
this shortly where you can see an

00:08:50,110 --> 00:08:56,379
oscillator running into sample converter

00:08:53,500 --> 00:08:58,480
into a reverb into a volume and then out

00:08:56,379 --> 00:09:00,910
into the speaker's so I mean that's

00:08:58,480 --> 00:09:03,100
actually fairly fairly trivial I tell

00:09:00,910 --> 00:09:06,399
you once you've got it set up which is

00:09:03,100 --> 00:09:08,709
pretty nice but it also has a low-level

00:09:06,399 --> 00:09:11,199
API so you've got control over threading

00:09:08,709 --> 00:09:13,779
you can write your own plugins to

00:09:11,199 --> 00:09:15,459
process sample data so yeah it's

00:09:13,779 --> 00:09:19,240
definitely definitely I think pretty

00:09:15,459 --> 00:09:21,699
useful so it's not coupled to the UI by

00:09:19,240 --> 00:09:23,259
default you'll find reduce that by

00:09:21,699 --> 00:09:25,860
default they've got their own kind of UI

00:09:23,259 --> 00:09:29,079
framework built in and you'll have to

00:09:25,860 --> 00:09:31,120
give react native the route view of your

00:09:29,079 --> 00:09:34,660
juice juice app to get it running that's

00:09:31,120 --> 00:09:37,180
the advice that you'll find so yeah it's

00:09:34,660 --> 00:09:38,740
it's um it's better not to be coupled by

00:09:37,180 --> 00:09:42,310
to the UI in my opinion especially

00:09:38,740 --> 00:09:44,920
welcome throughout native so again hello

00:09:42,310 --> 00:09:46,839
some some powerful features built in the

00:09:44,920 --> 00:09:48,790
the node base DSP I gotta say you know

00:09:46,839 --> 00:09:50,589
getting started is just really great um

00:09:48,790 --> 00:09:52,750
you know you could you could build a

00:09:50,589 --> 00:09:54,189
synthesizer with it without actually you

00:09:52,750 --> 00:09:56,079
know writing your own reverb for

00:09:54,189 --> 00:09:58,779
instance you can just plug the free

00:09:56,079 --> 00:10:02,350
verben much is it like well-known open

00:09:58,779 --> 00:10:04,990
source Revo so yeah it's using the LGPL

00:10:02,350 --> 00:10:07,959
license so what does that mean it means

00:10:04,990 --> 00:10:12,069
that you can take the code build your

00:10:07,959 --> 00:10:13,809
own app with it and then you can

00:10:12,069 --> 00:10:15,189
distribute that app and you don't have

00:10:13,809 --> 00:10:17,920
to put their logo on your splash screen

00:10:15,189 --> 00:10:19,720
it's it's you'll be able to basically

00:10:17,920 --> 00:10:21,339
take that software build your own

00:10:19,720 --> 00:10:23,319
software on top of it and then you can

00:10:21,339 --> 00:10:25,720
you can sell that software so that's

00:10:23,319 --> 00:10:28,240
that's that's definitely advantage the

00:10:25,720 --> 00:10:30,370
cons it requires you to write you write

00:10:28,240 --> 00:10:33,790
some C code so like that can be a bit

00:10:30,370 --> 00:10:35,699
scary the pattern is not necessarily

00:10:33,790 --> 00:10:38,709
what DSP engineers are used to because

00:10:35,699 --> 00:10:41,110
to actually put an example level DSP

00:10:38,709 --> 00:10:42,309
into a gstreamer pipeline and you're

00:10:41,110 --> 00:10:44,290
gonna have to write your own gstreamer

00:10:42,309 --> 00:10:45,490
plugin which is again something

00:10:44,290 --> 00:10:48,040
certainly how I haven't been able to do

00:10:45,490 --> 00:10:50,500
yet and it's not something which DSP

00:10:48,040 --> 00:10:53,020
engine is generally would do they would

00:10:50,500 --> 00:10:55,480
use an audio person single back

00:10:53,020 --> 00:10:57,040
yeah so that's that's option number

00:10:55,480 --> 00:11:00,279
three out of the three audio engine

00:10:57,040 --> 00:11:02,110
libraries I'd recommend using so I've

00:11:00,279 --> 00:11:04,660
got some experience using superpowered

00:11:02,110 --> 00:11:07,149
and GStreamer I've had to play about

00:11:04,660 --> 00:11:08,740
reduce but not that much so if anybody

00:11:07,149 --> 00:11:10,390
wants any more information about this oh

00:11:08,740 --> 00:11:11,820
yeah it just just asked me many

00:11:10,390 --> 00:11:14,170
questions afterwards

00:11:11,820 --> 00:11:17,080
so yeah getting started with actually

00:11:14,170 --> 00:11:19,089
building your own module it is going to

00:11:17,080 --> 00:11:21,370
take you know opening up Xcode opening

00:11:19,089 --> 00:11:22,990
up Android studio you know creating your

00:11:21,370 --> 00:11:24,580
own react native boot module and getting

00:11:22,990 --> 00:11:26,200
in there and getting some some C code or

00:11:24,580 --> 00:11:29,740
some C++ character into a compiler

00:11:26,200 --> 00:11:32,320
basically so that's just introduction

00:11:29,740 --> 00:11:33,790
that in terms of installing there's any

00:11:32,320 --> 00:11:34,899
of those three libraries so be happy to

00:11:33,790 --> 00:11:37,060
maybe answer couple of questions

00:11:34,899 --> 00:11:38,830
afterwards but I think it's about about

00:11:37,060 --> 00:11:39,910
an hour talk just to kind of went

00:11:38,830 --> 00:11:42,850
through properly installed in those

00:11:39,910 --> 00:11:44,410
libraries so I've just put these links

00:11:42,850 --> 00:11:46,690
to some resources where you could maybe

00:11:44,410 --> 00:11:48,640
find out you know where to install where

00:11:46,690 --> 00:11:51,730
to install really reduce where to

00:11:48,640 --> 00:11:55,570
install or how to install gstreamer or

00:11:51,730 --> 00:11:58,300
how to run the super powered SDK iOS

00:11:55,570 --> 00:12:00,250
examples so then you have to kind of go

00:11:58,300 --> 00:12:01,720
through those Xcode projects and look

00:12:00,250 --> 00:12:03,310
through how they're compiled and then

00:12:01,720 --> 00:12:03,670
you know kind of pick it out and create

00:12:03,310 --> 00:12:07,360
your own

00:12:03,670 --> 00:12:09,940
we got an etymological from that okay so

00:12:07,360 --> 00:12:12,970
it would also recommend this module and

00:12:09,940 --> 00:12:17,560
NPM to get started with so react native

00:12:12,970 --> 00:12:20,140
create bridge so this plugs into the

00:12:17,560 --> 00:12:22,630
react native CLI once you installed it

00:12:20,140 --> 00:12:25,540
so that allows you to then go react

00:12:22,630 --> 00:12:28,089
native new module as a command to your

00:12:25,540 --> 00:12:30,670
terminal and then you can choose if you

00:12:28,089 --> 00:12:32,140
want to create a UI component with

00:12:30,670 --> 00:12:33,820
objective-c or Swift

00:12:32,140 --> 00:12:36,070
if you want to create a UI component

00:12:33,820 --> 00:12:38,290
with Android or Cortland or Java or

00:12:36,070 --> 00:12:39,640
Kotlin and then also if you want to

00:12:38,290 --> 00:12:43,360
create a bridge module with either of

00:12:39,640 --> 00:12:45,220
those platforms so this is really good

00:12:43,360 --> 00:12:48,370
I've used this an example that I'm about

00:12:45,220 --> 00:12:49,930
to show so both the UI components that

00:12:48,370 --> 00:12:53,709
I've written with objective-c and also

00:12:49,930 --> 00:12:56,680
the audio engine bridge for that that's

00:12:53,709 --> 00:12:58,660
all set up using this this library just

00:12:56,680 --> 00:13:00,279
to help me kind of get the initial

00:12:58,660 --> 00:13:01,839
communication going

00:13:00,279 --> 00:13:04,990
template out that bit of bridging code

00:13:01,839 --> 00:13:05,350
quite quickly so yeah I highly recommend

00:13:04,990 --> 00:13:06,760
this

00:13:05,350 --> 00:13:09,970
save me a lot of time start using it

00:13:06,760 --> 00:13:11,440
recently so a little bit about the

00:13:09,970 --> 00:13:15,670
communication before you look at the

00:13:11,440 --> 00:13:17,800
example and some codes so we've got the

00:13:15,670 --> 00:13:20,020
bridge modules which are used you can

00:13:17,800 --> 00:13:22,810
create a method with the RCT method

00:13:20,020 --> 00:13:25,480
macro on your Objective C or Java code

00:13:22,810 --> 00:13:27,730
and that exposes the method to

00:13:25,480 --> 00:13:29,890
JavaScript and then use the native

00:13:27,730 --> 00:13:32,020
modules within real native which is you

00:13:29,890 --> 00:13:33,880
can export from react native in

00:13:32,020 --> 00:13:36,250
JavaScript and you can then access that

00:13:33,880 --> 00:13:39,130
method so you can use methods to talk

00:13:36,250 --> 00:13:41,200
down to your native code to talk back up

00:13:39,130 --> 00:13:43,830
from your native code to your JavaScript

00:13:41,200 --> 00:13:46,180
code you use the native event emitter

00:13:43,830 --> 00:13:47,800
yeah there's also callbacks on the

00:13:46,180 --> 00:13:49,780
methods on the method macro but the

00:13:47,800 --> 00:13:51,340
callbacks it's just pretty much the same

00:13:49,780 --> 00:13:53,620
as an event I don't I don't recommend

00:13:51,340 --> 00:13:55,710
callbacks so this is a bit of a small

00:13:53,620 --> 00:14:00,250
part of the app that I've just shown you

00:13:55,710 --> 00:14:02,320
so over here we've got a method C++

00:14:00,250 --> 00:14:03,550
method called update coordinates I

00:14:02,320 --> 00:14:05,140
couldn't quite figure out what else to

00:14:03,550 --> 00:14:06,820
call it it's kind of bind it to the UI

00:14:05,140 --> 00:14:09,190
there but it takes the X&Y from the

00:14:06,820 --> 00:14:12,370
position on the screen and passes it

00:14:09,190 --> 00:14:13,930
into the engine so using the X&Y idea

00:14:12,370 --> 00:14:16,030
which is passed through the bridge is

00:14:13,930 --> 00:14:19,870
setting the frequency setting the room

00:14:16,030 --> 00:14:22,680
size on the reverb setting the volume so

00:14:19,870 --> 00:14:25,060
then this is a react native method macro

00:14:22,680 --> 00:14:27,790
and so I'm exporting a method called

00:14:25,060 --> 00:14:29,740
again update coordinates they come in

00:14:27,790 --> 00:14:31,030
the type to come in as NS number so with

00:14:29,740 --> 00:14:33,640
this kind of communication you need to

00:14:31,030 --> 00:14:35,890
convert types from NS fight to C++ types

00:14:33,640 --> 00:14:37,120
so that's what we're doing here we're

00:14:35,890 --> 00:14:40,600
just converting that getting a double

00:14:37,120 --> 00:14:42,400
value out of the nest value so we're now

00:14:40,600 --> 00:14:46,240
getting a C++ double value and passing

00:14:42,400 --> 00:14:47,950
it in along the JavaScript side you pull

00:14:46,240 --> 00:14:51,970
in the GStreamer bridge from native

00:14:47,950 --> 00:14:54,220
modules makovica said and then handle

00:14:51,970 --> 00:14:56,710
move is is controlled by the touch

00:14:54,220 --> 00:15:00,160
position using pan responder from from

00:14:56,710 --> 00:15:01,300
out native and then it updates it calls

00:15:00,160 --> 00:15:03,250
the update coordinates

00:15:01,300 --> 00:15:05,050
method which is which controls the kind

00:15:03,250 --> 00:15:08,170
of effect I just showed you as pitching

00:15:05,050 --> 00:15:11,320
up and down yeah so that gives that kind

00:15:08,170 --> 00:15:15,310
of slightly chaos pad like effect on the

00:15:11,320 --> 00:15:17,530
audio there yeah so any questions on

00:15:15,310 --> 00:15:18,760
this server maybe afterwards talk a bit

00:15:17,530 --> 00:15:19,190
more about it I can show some more code

00:15:18,760 --> 00:15:24,770
example

00:15:19,190 --> 00:15:27,110
maybe and then this is a so that's

00:15:24,770 --> 00:15:30,590
that's the the default way of doing this

00:15:27,110 --> 00:15:32,090
so you create a method for every

00:15:30,590 --> 00:15:34,640
communication you want to make so that

00:15:32,090 --> 00:15:36,980
would mean creating a method macro for

00:15:34,640 --> 00:15:39,440
the play methods method macro for the

00:15:36,980 --> 00:15:41,780
pause method a method macro for the set

00:15:39,440 --> 00:15:43,610
waveform method method macro for the

00:15:41,780 --> 00:15:45,230
update coordinates method and then for

00:15:43,610 --> 00:15:46,910
the init method you can end up around

00:15:45,230 --> 00:15:48,140
quite a lot of Objective C code and

00:15:46,910 --> 00:15:50,900
ended up you know that's going to be a

00:15:48,140 --> 00:15:52,340
maintenance burden every time you wanna

00:15:50,900 --> 00:15:55,670
add a new value you need to convert from

00:15:52,340 --> 00:15:57,920
NS type to C++ type and down it's it's

00:15:55,670 --> 00:16:00,260
not ideal really it's a bit too much

00:15:57,920 --> 00:16:02,390
boilerplate I would say so this is a

00:16:00,260 --> 00:16:05,720
example that maybe another pattern that

00:16:02,390 --> 00:16:07,040
we could use again this is running an

00:16:05,720 --> 00:16:09,020
app I've showed you there this is

00:16:07,040 --> 00:16:13,040
actually you know running code of I've

00:16:09,020 --> 00:16:16,970
been I'm using so basically what's going

00:16:13,040 --> 00:16:18,620
on here I set up a new method on the on

00:16:16,970 --> 00:16:22,730
the route native bridge that takes in

00:16:18,620 --> 00:16:26,000
two arguments NS string the message type

00:16:22,730 --> 00:16:27,890
and NS string message jason I've missed

00:16:26,000 --> 00:16:29,750
that out of that slide because it's it's

00:16:27,890 --> 00:16:32,570
quite similar to this it's just getting

00:16:29,750 --> 00:16:34,490
NS string as one argument and a string

00:16:32,570 --> 00:16:36,950
as a second document the message type in

00:16:34,490 --> 00:16:39,020
the message jason and then passing it it

00:16:36,950 --> 00:16:41,240
converts it to a stood string and then

00:16:39,020 --> 00:16:42,650
passes it directly into the c++ so

00:16:41,240 --> 00:16:44,060
that's the only method that you would

00:16:42,650 --> 00:16:45,860
need to write using this pattern and

00:16:44,060 --> 00:16:50,960
then everything else can be handled from

00:16:45,860 --> 00:16:54,080
c++ so this c++ method here it takes

00:16:50,960 --> 00:16:56,570
instead of string message type string

00:16:54,080 --> 00:16:58,460
message jason if the message type is a

00:16:56,570 --> 00:17:00,710
knit then it sets the state to be back

00:16:58,460 --> 00:17:03,710
though that value which is passed out of

00:17:00,710 --> 00:17:06,140
the string into a jason value it sets

00:17:03,710 --> 00:17:07,370
the waveform from that jason value

00:17:06,140 --> 00:17:08,959
that's been passed in so this is like

00:17:07,370 --> 00:17:11,449
your initial state which is configured

00:17:08,959 --> 00:17:13,850
from javascript but is mirrored in your

00:17:11,449 --> 00:17:16,100
c++ code to keep the same state in your

00:17:13,850 --> 00:17:18,560
c++ as you would have in your JavaScript

00:17:16,100 --> 00:17:20,089
app and then at that point yet early

00:17:18,560 --> 00:17:22,790
return because we don't hit this code

00:17:20,089 --> 00:17:25,689
that the merge wouldn't work but then on

00:17:22,790 --> 00:17:28,520
the second message the the play message

00:17:25,689 --> 00:17:29,270
sending in some more data is playing

00:17:28,520 --> 00:17:32,030
which

00:17:29,270 --> 00:17:35,120
isn't actually used but in that case

00:17:32,030 --> 00:17:38,450
we're passing the new message emerging

00:17:35,120 --> 00:17:40,370
it into the old state so it's in a way

00:17:38,450 --> 00:17:42,200
like in a very like a reduction story

00:17:40,370 --> 00:17:44,350
you've merging the new the new state in

00:17:42,200 --> 00:17:47,360
a way you know so you're you're keeping

00:17:44,350 --> 00:17:49,970
the state sync from your JavaScript to

00:17:47,360 --> 00:17:51,470
your C++ in this way by merging in the

00:17:49,970 --> 00:17:53,860
small state changes that you need to

00:17:51,470 --> 00:17:56,420
make with every request to the engine

00:17:53,860 --> 00:17:57,950
and then from there we're just getting

00:17:56,420 --> 00:17:59,270
these values which are using it on the

00:17:57,950 --> 00:18:01,310
function but I've taken it as far as

00:17:59,270 --> 00:18:05,390
here where you call the plane I third in

00:18:01,310 --> 00:18:06,740
a place so on the JavaScript side just a

00:18:05,390 --> 00:18:09,560
little bit of an example of that

00:18:06,740 --> 00:18:12,980
so does the state update is it's playing

00:18:09,560 --> 00:18:17,330
is true jason stringify that send a

00:18:12,980 --> 00:18:19,220
message down play type and then that's

00:18:17,330 --> 00:18:21,590
going to send it through to this protest

00:18:19,220 --> 00:18:23,900
message method and we merge in the new

00:18:21,590 --> 00:18:26,390
state just to keep everything synched up

00:18:23,900 --> 00:18:28,100
basically so the questions are I'm kind

00:18:26,390 --> 00:18:30,410
of asking here is you know is Java and

00:18:28,100 --> 00:18:32,600
objective-c detrimental to the success

00:18:30,410 --> 00:18:35,570
of your project because JavaScript and

00:18:32,600 --> 00:18:37,970
C++ a cross-platform so in this way you

00:18:35,570 --> 00:18:39,620
can literally be working on two sides of

00:18:37,970 --> 00:18:41,840
your code base your JavaScript and your

00:18:39,620 --> 00:18:45,350
C++ and not touching the objective-c

00:18:41,840 --> 00:18:47,030
which is is really nice I mean I'm quite

00:18:45,350 --> 00:18:49,490
fun to this pattern I think potentially

00:18:47,030 --> 00:18:51,860
it's not performant enough because we're

00:18:49,490 --> 00:18:53,990
adding another Jason in code and Jason

00:18:51,860 --> 00:18:56,660
Pass which is what we are natives doing

00:18:53,990 --> 00:18:59,930
anyway but doesn't doesn't matter for a

00:18:56,660 --> 00:19:01,940
play or a set waveform but it does maybe

00:18:59,930 --> 00:19:03,590
matter for the real-time frequency

00:19:01,940 --> 00:19:06,080
update that you see in the audio app

00:19:03,590 --> 00:19:09,860
that I've shown you in that case you

00:19:06,080 --> 00:19:11,840
might want to just create as a special

00:19:09,860 --> 00:19:14,090
one bridge matter for that particular

00:19:11,840 --> 00:19:18,350
request because it's a high frequency

00:19:14,090 --> 00:19:21,260
request that you're making yeah and then

00:19:18,350 --> 00:19:24,440
this is an example of sending an event

00:19:21,260 --> 00:19:28,820
back up so this is using the native

00:19:24,440 --> 00:19:30,470
event emitter you need to extend from

00:19:28,820 --> 00:19:33,350
the native event emitter class when you

00:19:30,470 --> 00:19:35,480
create your bridge module actual either

00:19:33,350 --> 00:19:37,430
than the NPM package that I showed you

00:19:35,480 --> 00:19:39,860
will do this for you so you'll be okay

00:19:37,430 --> 00:19:42,110
you can actually cool send event with

00:19:39,860 --> 00:19:44,029
which is the method that the native

00:19:42,110 --> 00:19:45,380
event emitter exposes for you that's

00:19:44,029 --> 00:19:47,260
going to be set up for you pretty much

00:19:45,380 --> 00:19:49,159
by default if you use that package

00:19:47,260 --> 00:19:50,330
second it can take you a little bit

00:19:49,159 --> 00:19:51,740
further instead of having to set the

00:19:50,330 --> 00:19:54,500
class up yourself it will set the class

00:19:51,740 --> 00:19:57,470
up with all the right kind of extensions

00:19:54,500 --> 00:19:59,870
from different base classes so yeah you

00:19:57,470 --> 00:20:02,809
have to set the supported events you

00:19:59,870 --> 00:20:04,700
have to list them out in an array

00:20:02,809 --> 00:20:06,649
otherwise it will fail and it will show

00:20:04,700 --> 00:20:09,529
you red screen on native and then you

00:20:06,649 --> 00:20:13,039
will know you have to go in there and

00:20:09,529 --> 00:20:14,539
find that arrow and fix it so then yeah

00:20:13,039 --> 00:20:16,820
this is in the component of mountainous

00:20:14,539 --> 00:20:18,500
you're starting a listener setting the

00:20:16,820 --> 00:20:20,809
level on the state to the match the

00:20:18,500 --> 00:20:22,490
users to update the UI equal quite

00:20:20,809 --> 00:20:24,500
stupidly in this example just to show

00:20:22,490 --> 00:20:26,539
kind of how busy the bridge can get if

00:20:24,500 --> 00:20:29,149
you try and just just communicate

00:20:26,539 --> 00:20:32,330
directly between JavaScript and C++ and

00:20:29,149 --> 00:20:34,970
deal with UI rendering from that yeah so

00:20:32,330 --> 00:20:37,490
those are the three things to look at I

00:20:34,970 --> 00:20:40,580
would say is creating a method to pass

00:20:37,490 --> 00:20:42,169
down data to your audio engine maybe

00:20:40,580 --> 00:20:44,450
minimizing the amount of non

00:20:42,169 --> 00:20:47,240
cross-platform so Objective C or Java

00:20:44,450 --> 00:20:50,029
code that you need to write and then

00:20:47,240 --> 00:20:52,399
finally sending events back up to your

00:20:50,029 --> 00:20:55,519
JavaScript to communicate from your C++

00:20:52,399 --> 00:20:59,480
to your JavaScript yeah so those are the

00:20:55,519 --> 00:21:02,389
code examples and then this example of

00:20:59,480 --> 00:21:05,720
our edit is a way of maybe getting

00:21:02,389 --> 00:21:10,130
access to your bridge module from a

00:21:05,720 --> 00:21:12,260
native component for instance so you can

00:21:10,130 --> 00:21:15,889
get access to a shared instance of the

00:21:12,260 --> 00:21:17,649
ICC manager get bridge that's the bridge

00:21:15,889 --> 00:21:21,440
that's the react native bridge in native

00:21:17,649 --> 00:21:23,720
and then it's going to show you can you

00:21:21,440 --> 00:21:25,519
get this module okay if the modules

00:21:23,720 --> 00:21:27,889
there then get the instance of the

00:21:25,519 --> 00:21:30,169
module so instead of using a single term

00:21:27,889 --> 00:21:32,090
we can get the one instance that react

00:21:30,169 --> 00:21:34,070
native is managing for us we are Native

00:21:32,090 --> 00:21:35,659
had his own garbage collector go into it

00:21:34,070 --> 00:21:37,820
so it's probably better to let them

00:21:35,659 --> 00:21:42,260
manage the memory of your native modules

00:21:37,820 --> 00:21:44,510
for you yeah so that's not there and

00:21:42,260 --> 00:21:45,769
then when the bridge is busy there will

00:21:44,510 --> 00:21:47,690
be increased latency with your

00:21:45,769 --> 00:21:49,190
JavaScript so as soon as you build a

00:21:47,690 --> 00:21:50,120
large react native app the bridge will

00:21:49,190 --> 00:21:51,770
get a little bit busy

00:21:50,120 --> 00:21:54,660
I mean we don't even know from

00:21:51,770 --> 00:21:56,250
which does get busy with you have to you

00:21:54,660 --> 00:21:57,990
have to optimize it minimizing amount of

00:21:56,250 --> 00:21:59,160
communication and also the amount of

00:21:57,990 --> 00:22:00,300
data that you're sending over it's

00:21:59,160 --> 00:22:02,730
pretty important because everything's

00:22:00,300 --> 00:22:06,450
getting a situation encoded and then

00:22:02,730 --> 00:22:08,940
Jason passed yeah so also just a little

00:22:06,450 --> 00:22:10,650
note on the future future ideas so I

00:22:08,940 --> 00:22:12,090
just want to put this idea out there

00:22:10,650 --> 00:22:15,840
that it'd be really cool to build a

00:22:12,090 --> 00:22:17,940
reactive module on NPM using GStreamer

00:22:15,840 --> 00:22:20,220
so you could create your own kind of

00:22:17,940 --> 00:22:21,510
pipeline script them from JavaScript and

00:22:20,220 --> 00:22:23,610
then send them down it would create them

00:22:21,510 --> 00:22:26,070
for you this could be kind of similar to

00:22:23,610 --> 00:22:28,740
the Web Audio API score most of the

00:22:26,070 --> 00:22:31,740
components in it also GStreamer is used

00:22:28,740 --> 00:22:34,380
in WebKit to write the Web Audio API so

00:22:31,740 --> 00:22:36,330
I think it would be a good fit and then

00:22:34,380 --> 00:22:38,970
finally there's this link here which I

00:22:36,330 --> 00:22:41,130
can't show you now but it's basically a

00:22:38,970 --> 00:22:44,400
sample C++ module within react native

00:22:41,130 --> 00:22:46,110
sauce so they're not publishing this on

00:22:44,400 --> 00:22:47,370
any blog post yet but you will be able

00:22:46,110 --> 00:22:49,620
to create your own native modules

00:22:47,370 --> 00:22:51,450
directly from JavaScript or C++ without

00:22:49,620 --> 00:22:52,770
writing any of that bitching code at

00:22:51,450 --> 00:22:54,510
some point I would say in the future

00:22:52,770 --> 00:22:55,620
this is something that the juice team

00:22:54,510 --> 00:22:59,310
are working on as well and they're

00:22:55,620 --> 00:23:00,930
releasing yeah so any questions any

00:22:59,310 --> 00:23:05,430
questions are welcome if I can answer

00:23:00,930 --> 00:23:07,640
them yeah that's that's the end of the

00:23:05,430 --> 00:23:07,640
talk

00:23:07,900 --> 00:23:12,979

YouTube URL: https://www.youtube.com/watch?v=iaPOO00-2es


