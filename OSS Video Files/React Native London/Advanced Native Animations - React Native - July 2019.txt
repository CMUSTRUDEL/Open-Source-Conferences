Title: Advanced Native Animations - React Native - July 2019
Publication date: 2019-08-01
Playlist: React Native London
Description: 
	Presented by Konrad W. (MagicWorks)

ROXi runs on our custom build of Android and our own developed hardware â€“ and the application is built using React Native. The topic covers technical challenges we faced optimising our animations, reducing animation latency and speeding up the time to render when attaching native animations.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:09,000
hello everyone I am Conrad I work here

00:00:03,179 --> 00:00:11,550
at magic works today I will be speaking

00:00:09,000 --> 00:00:16,699
about how to optimize render calls and

00:00:11,550 --> 00:00:19,850
latencies of native animations I think

00:00:16,699 --> 00:00:22,920
Paul has given a really nice

00:00:19,850 --> 00:00:24,779
introduction on sort of how Pan

00:00:22,920 --> 00:00:27,689
responder sort of solves the problem I

00:00:24,779 --> 00:00:29,400
think this is a really similar subject

00:00:27,689 --> 00:00:32,669
which i think is great in terms of how

00:00:29,400 --> 00:00:35,370
we can take it further and solve some of

00:00:32,669 --> 00:00:38,420
the problems possibly this a lot of the

00:00:35,370 --> 00:00:42,210
work we've been doing is engineering

00:00:38,420 --> 00:00:44,100
performance on low-level sorry low

00:00:42,210 --> 00:00:46,739
performance devices such as are the ones

00:00:44,100 --> 00:00:48,420
we manufacture ourselves so just to give

00:00:46,739 --> 00:00:52,260
you an idea we manufacture our own

00:00:48,420 --> 00:00:56,640
devices we also manufacture our own

00:00:52,260 --> 00:00:58,379
hardware to plug into your TV and it

00:00:56,640 --> 00:01:01,649
looks like this it comes with a

00:00:58,379 --> 00:01:04,799
controller just a quick recap on people

00:01:01,649 --> 00:01:06,390
who weren't here last year in August the

00:01:04,799 --> 00:01:08,430
controller we have is basically a

00:01:06,390 --> 00:01:10,770
point-and-click device so you point on

00:01:08,430 --> 00:01:14,100
things and click and that sort of it's a

00:01:10,770 --> 00:01:17,970
touch event on react native the way we

00:01:14,100 --> 00:01:19,710
run react native is by using Android and

00:01:17,970 --> 00:01:22,350
by using Android source code and

00:01:19,710 --> 00:01:24,659
flashing it on our hardware meaning that

00:01:22,350 --> 00:01:27,590
we're able to take full power of react

00:01:24,659 --> 00:01:30,930
native on our hardware

00:01:27,590 --> 00:01:33,780
about the application itself it's 16

00:01:30,930 --> 00:01:36,409
months in development we've released to

00:01:33,780 --> 00:01:38,610
production in February this year

00:01:36,409 --> 00:01:41,490
currently we are actually using a react

00:01:38,610 --> 00:01:44,579
native 56 but we are also have our

00:01:41,490 --> 00:01:46,619
branch that works with 59 we just don't

00:01:44,579 --> 00:01:50,909
really find any necessary things that we

00:01:46,619 --> 00:01:54,930
actually need from 59 but we are able to

00:01:50,909 --> 00:01:58,649
use 59 as well this is how the app used

00:01:54,930 --> 00:02:02,040
to look in August 2000 18 it works in

00:01:58,649 --> 00:02:04,439
full high-definition so 1080p resolution

00:02:02,040 --> 00:02:07,680
on the TV which is a bit unusual for the

00:02:04,439 --> 00:02:09,239
application this is how it looks now so

00:02:07,680 --> 00:02:10,679
this is a very different way of

00:02:09,239 --> 00:02:12,360
designing an application because you're

00:02:10,679 --> 00:02:13,710
not designing it for a small screen on a

00:02:12,360 --> 00:02:16,800
mobile device you're designing

00:02:13,710 --> 00:02:18,270
for a large display which is a whole new

00:02:16,800 --> 00:02:20,850
experience and a whole new level of

00:02:18,270 --> 00:02:22,410
design where usually on a react native

00:02:20,850 --> 00:02:25,950
app on a mobile you would only fit

00:02:22,410 --> 00:02:28,380
roughly six or seven buttons that you

00:02:25,950 --> 00:02:31,590
would press but you on a TV screen you

00:02:28,380 --> 00:02:34,110
would really kind of have more than few

00:02:31,590 --> 00:02:36,900
buttons to actually interact with so for

00:02:34,110 --> 00:02:39,060
us the highest sort of challenge was

00:02:36,900 --> 00:02:42,840
actually how do we scale how can we

00:02:39,060 --> 00:02:44,730
present a lot of sort of UI and not run

00:02:42,840 --> 00:02:49,470
into memory problems on a low powered

00:02:44,730 --> 00:02:51,300
hardware that we that we have this is a

00:02:49,470 --> 00:02:54,000
sort of a stack that we use it's nothing

00:02:51,300 --> 00:02:56,340
really it's pretty straightforward it's

00:02:54,000 --> 00:02:58,950
quite simple and very similar to any

00:02:56,340 --> 00:03:01,410
other react native app I'm not gonna go

00:02:58,950 --> 00:03:04,410
through them but you can't get an idea

00:03:01,410 --> 00:03:07,440
the overview of the talk will be part

00:03:04,410 --> 00:03:10,490
one how do we achieve faster animations

00:03:07,440 --> 00:03:12,960
and the latency to start the animation

00:03:10,490 --> 00:03:15,300
improving the render time so how long

00:03:12,960 --> 00:03:17,190
your component takes to render which

00:03:15,300 --> 00:03:19,560
actually by proving that time you're

00:03:17,190 --> 00:03:22,470
also reduce the number of frames that

00:03:19,560 --> 00:03:23,700
will be dropped during the animation and

00:03:22,470 --> 00:03:27,210
part three will be about your

00:03:23,700 --> 00:03:31,050
unnecessary renders which is also makes

00:03:27,210 --> 00:03:34,290
the animations a lot smoother a quick

00:03:31,050 --> 00:03:35,940
recap on animated library you simply

00:03:34,290 --> 00:03:37,950
create a new animated value having a lot

00:03:35,940 --> 00:03:39,960
of of a lot of you have used this before

00:03:37,950 --> 00:03:41,610
this API which is you create a value you

00:03:39,960 --> 00:03:44,670
start the animation and you simply

00:03:41,610 --> 00:03:48,150
render a component for instance an image

00:03:44,670 --> 00:03:51,990
move and opacity using that animator

00:03:48,150 --> 00:03:53,850
value it's a building react native API

00:03:51,990 --> 00:03:57,930
so everyone should be familiar with it

00:03:53,850 --> 00:03:59,970
but it's straightforward so how do we

00:03:57,930 --> 00:04:01,500
achieve faster animation I changed what

00:03:59,970 --> 00:04:03,600
we've created it's not a new concept

00:04:01,500 --> 00:04:06,360
it's been previously done by react

00:04:03,600 --> 00:04:08,130
native interactable by Wix they've done

00:04:06,360 --> 00:04:11,880
some work however their work is very

00:04:08,130 --> 00:04:13,980
limited to dragging elements only it

00:04:11,880 --> 00:04:16,410
works if the animation is initiated from

00:04:13,980 --> 00:04:19,170
any user input event which means we're a

00:04:16,410 --> 00:04:22,049
scroll event or a touch event or any

00:04:19,170 --> 00:04:23,700
sort of event that may come from the

00:04:22,049 --> 00:04:25,980
platform you're developing the app so

00:04:23,700 --> 00:04:28,000
for instance on a TV you get focus

00:04:25,980 --> 00:04:30,130
events on a table

00:04:28,000 --> 00:04:33,550
you get touch events on on a sort of web

00:04:30,130 --> 00:04:34,720
you get a hover events so it really

00:04:33,550 --> 00:04:37,450
depends on your platform but we've

00:04:34,720 --> 00:04:39,940
achieved ability to it for all those

00:04:37,450 --> 00:04:41,410
events because in our case our

00:04:39,940 --> 00:04:44,020
application needs to run on most

00:04:41,410 --> 00:04:46,990
platforms and we want to be able to

00:04:44,020 --> 00:04:50,650
flexibly and maintain code in an easy

00:04:46,990 --> 00:04:51,610
way so it's a new concept in our case

00:04:50,650 --> 00:04:53,700
because we want to make a

00:04:51,610 --> 00:04:56,980
general-purpose not just for dragging

00:04:53,700 --> 00:05:01,770
purpose so we are able to take it

00:04:56,980 --> 00:05:01,770
further than just dragging the elements

00:05:01,950 --> 00:05:05,470
this is sort of the how it currently

00:05:03,970 --> 00:05:07,600
works with react native you have a

00:05:05,470 --> 00:05:09,520
touchable capacity which gets on press

00:05:07,600 --> 00:05:12,250
events there's a bridge between the

00:05:09,520 --> 00:05:13,870
component and the native site you now

00:05:12,250 --> 00:05:16,120
every come every time that travel

00:05:13,870 --> 00:05:18,160
opacity is mounted over the bridge the

00:05:16,120 --> 00:05:20,980
initial props must be sent over the

00:05:18,160 --> 00:05:22,570
bridge which to the react view which is

00:05:20,980 --> 00:05:28,030
implemented either on objective-c or

00:05:22,570 --> 00:05:30,940
Swift or Java and whenever that view

00:05:28,030 --> 00:05:32,860
receives any user input events there

00:05:30,940 --> 00:05:36,490
information about event is sent back to

00:05:32,860 --> 00:05:38,140
the JavaScript context which could be

00:05:36,490 --> 00:05:40,930
either on press or on hover event and

00:05:38,140 --> 00:05:43,479
then the component makes the decision of

00:05:40,930 --> 00:05:46,810
what to do and very likely and in many

00:05:43,479 --> 00:05:49,330
cases the decision is to to start the

00:05:46,810 --> 00:05:51,130
animation using negative driver to make

00:05:49,330 --> 00:05:53,860
sure it's the non emissions happening on

00:05:51,130 --> 00:05:56,169
the native side as you can see the sort

00:05:53,860 --> 00:05:57,370
of the the message is being sent across

00:05:56,169 --> 00:05:59,350
the bridge is sort of back and forth

00:05:57,370 --> 00:06:00,760
where event is being sent and then the

00:05:59,350 --> 00:06:04,180
event is being sent back to start the

00:06:00,760 --> 00:06:06,370
animation our solution is basically

00:06:04,180 --> 00:06:10,200
writing a new component which solves the

00:06:06,370 --> 00:06:13,090
problem and what we do we send the

00:06:10,200 --> 00:06:16,419
information of the animation that should

00:06:13,090 --> 00:06:19,630
happen to the native side before the

00:06:16,419 --> 00:06:22,419
animation happens Saints so for instance

00:06:19,630 --> 00:06:25,270
we know what the hover animation may be

00:06:22,419 --> 00:06:27,820
we know what unpress animation may be so

00:06:25,270 --> 00:06:29,680
if you think of material design which

00:06:27,820 --> 00:06:31,780
sort of the Google is designed that when

00:06:29,680 --> 00:06:34,120
you press anywhere the sort of animation

00:06:31,780 --> 00:06:38,500
sort of expands sort of like a pulse

00:06:34,120 --> 00:06:39,130
animation dilation we already know how

00:06:38,500 --> 00:06:41,980
long will it

00:06:39,130 --> 00:06:45,120
and how it expands and how it animates

00:06:41,980 --> 00:06:47,440
before the user presses the click event

00:06:45,120 --> 00:06:48,880
so we're able to take advantage of

00:06:47,440 --> 00:06:51,520
sending the information over the bridge

00:06:48,880 --> 00:06:53,410
before and the animation would start

00:06:51,520 --> 00:06:54,910
actually the next frame as soon as the

00:06:53,410 --> 00:06:56,530
even happens without sending anything

00:06:54,910 --> 00:07:00,430
over the bridge which reduces the

00:06:56,530 --> 00:07:03,190
latency of our animations just a quick

00:07:00,430 --> 00:07:05,290
example how we're doing it in we are

00:07:03,190 --> 00:07:09,130
able now to use pure components as

00:07:05,290 --> 00:07:11,110
opposed to regular components in our

00:07:09,130 --> 00:07:13,450
case were able to create animated value

00:07:11,110 --> 00:07:16,030
which in this case it defines a pressed

00:07:13,450 --> 00:07:19,150
progression so when you press down a

00:07:16,030 --> 00:07:20,650
component its animating to one meaning

00:07:19,150 --> 00:07:23,290
it's been pressed and when you're

00:07:20,650 --> 00:07:25,360
unpress it goes back to zero defining

00:07:23,290 --> 00:07:28,420
that there is no that component is no

00:07:25,360 --> 00:07:31,150
longer pressed we don't have to animate

00:07:28,420 --> 00:07:34,330
the value the native side will animate

00:07:31,150 --> 00:07:36,340
the value within its own context within

00:07:34,330 --> 00:07:37,450
its own thread there's no need to send

00:07:36,340 --> 00:07:39,990
anything over the bridge

00:07:37,450 --> 00:07:42,160
and we're able to take advantage of

00:07:39,990 --> 00:07:43,720
simply telling the native side which

00:07:42,160 --> 00:07:45,490
value to animate and the native side

00:07:43,720 --> 00:07:47,250
will do it for us whenever the component

00:07:45,490 --> 00:07:49,480
is being pressed down or pressed up

00:07:47,250 --> 00:07:50,830
we're able to define the easing and

00:07:49,480 --> 00:07:53,230
duration of how long it takes

00:07:50,830 --> 00:07:55,630
which means in most cases when you hover

00:07:53,230 --> 00:07:58,110
things so when you press things the

00:07:55,630 --> 00:08:00,820
animation is pretty much always the same

00:07:58,110 --> 00:08:02,590
and in this case this component actually

00:08:00,820 --> 00:08:05,110
shown press which you may be familiar

00:08:02,590 --> 00:08:07,630
with when you receive a let's say an

00:08:05,110 --> 00:08:09,520
picture on snapchat when you press down

00:08:07,630 --> 00:08:11,050
down you make the image sort of shows up

00:08:09,520 --> 00:08:13,990
and when you release the image Heights

00:08:11,050 --> 00:08:16,180
so you can only see it one time so this

00:08:13,990 --> 00:08:19,270
is a simple implementation of sort of a

00:08:16,180 --> 00:08:22,110
snapchat sort of a feature of being able

00:08:19,270 --> 00:08:26,380
to see an image only when you press down

00:08:22,110 --> 00:08:28,420
and I you can see we're setting the

00:08:26,380 --> 00:08:31,090
opacity of that component to that the

00:08:28,420 --> 00:08:34,690
progression of depressed now that's not

00:08:31,090 --> 00:08:37,479
a simple example in we're also able to

00:08:34,690 --> 00:08:39,460
recreate touchable opacity in JavaScript

00:08:37,479 --> 00:08:42,070
without sending any events black and

00:08:39,460 --> 00:08:45,700
forth between the bridge and the Java

00:08:42,070 --> 00:08:47,770
side it's very JavaScript side the name

00:08:45,700 --> 00:08:49,480
of the component doesn't really matter

00:08:47,770 --> 00:08:52,080
in this case because it's more about the

00:08:49,480 --> 00:08:54,200
concept of what we created

00:08:52,080 --> 00:08:57,800
in our case we call it the magic view

00:08:54,200 --> 00:09:00,270
which allows you to define which

00:08:57,800 --> 00:09:01,380
animated value to animate what is the

00:09:00,270 --> 00:09:03,500
pressed animation

00:09:01,380 --> 00:09:05,880
what is the pressed animation out

00:09:03,500 --> 00:09:08,310
because in touchable capacity when you

00:09:05,880 --> 00:09:10,320
press it in the component kind of fades

00:09:08,310 --> 00:09:12,630
out instantly so in our case the

00:09:10,320 --> 00:09:14,430
duration will be 100 milliseconds and

00:09:12,630 --> 00:09:16,380
when you press it out it usually takes a

00:09:14,430 --> 00:09:18,660
while for it to fail back out that it's

00:09:16,380 --> 00:09:20,730
been done pressed so that takes 600

00:09:18,660 --> 00:09:24,120
milliseconds and you can see we've

00:09:20,730 --> 00:09:27,830
binded opacity of the hover using

00:09:24,120 --> 00:09:30,120
between 1 and active opacity or very

00:09:27,830 --> 00:09:31,680
touchable capacity which is an existing

00:09:30,120 --> 00:09:33,330
prop of touchable boxes so if you've

00:09:31,680 --> 00:09:35,610
used previously touchable plastic

00:09:33,330 --> 00:09:37,710
component you should know that there is

00:09:35,610 --> 00:09:39,840
a active opacity prop which you can

00:09:37,710 --> 00:09:41,400
define of what is the opacity of the

00:09:39,840 --> 00:09:44,100
component when it's press done

00:09:41,400 --> 00:09:47,360
in this example we're able to recreate

00:09:44,100 --> 00:09:50,430
the animation of touchable opacity

00:09:47,360 --> 00:09:52,770
without doing any messages over the

00:09:50,430 --> 00:09:54,210
bridge and being able to create it and

00:09:52,770 --> 00:09:56,010
define all the animations in the

00:09:54,210 --> 00:09:58,640
JavaScript without having to write a

00:09:56,010 --> 00:10:01,830
native component for different platforms

00:09:58,640 --> 00:10:03,860
in our case our because we have a

00:10:01,830 --> 00:10:06,300
controller so we have enough hover event

00:10:03,860 --> 00:10:10,410
where you can hover things on Android TV

00:10:06,300 --> 00:10:12,750
and on any other Smart TV on a tablet

00:10:10,410 --> 00:10:17,130
you would have a pressed event and on a

00:10:12,750 --> 00:10:19,020
on an app rock and on a Apple TV remote

00:10:17,130 --> 00:10:21,330
you may also have a focus event because

00:10:19,020 --> 00:10:24,570
you focus things you don't really hover

00:10:21,330 --> 00:10:26,720
things so in our case we wanted to have

00:10:24,570 --> 00:10:28,620
a single code base to be able to achieve

00:10:26,720 --> 00:10:30,650
defining those three different

00:10:28,620 --> 00:10:33,540
animations which is the progression of

00:10:30,650 --> 00:10:34,860
component being hovered progression of a

00:10:33,540 --> 00:10:36,360
component being focused in the

00:10:34,860 --> 00:10:38,760
progression of a component being pressed

00:10:36,360 --> 00:10:40,560
and we're actually able to create a

00:10:38,760 --> 00:10:43,710
component called accessible view which

00:10:40,560 --> 00:10:45,000
means anything that can be accessed has

00:10:43,710 --> 00:10:47,520
a different property on different

00:10:45,000 --> 00:10:52,350
platforms so for instance on android

00:10:47,520 --> 00:10:55,980
android TV whereas scaling we're scaling

00:10:52,350 --> 00:10:58,260
the component based on how much has been

00:10:55,980 --> 00:11:00,390
focused so on most TVs wonder whatever

00:10:58,260 --> 00:11:03,450
you focused kind of zooms in towards you

00:11:00,390 --> 00:11:05,380
because it's been focused we don't want

00:11:03,450 --> 00:11:08,290
that behavior

00:11:05,380 --> 00:11:09,850
it's using a touch controls because he's

00:11:08,290 --> 00:11:11,440
not really used to things ooming and

00:11:09,850 --> 00:11:13,600
when you press them you kind of expect

00:11:11,440 --> 00:11:15,580
them to kind of fade out which is why we

00:11:13,600 --> 00:11:17,920
control the opacity based on hover and

00:11:15,580 --> 00:11:20,290
pressed so when you hover things you

00:11:17,920 --> 00:11:22,029
expect things to kind of fade in more

00:11:20,290 --> 00:11:24,850
which is why we're controlling the

00:11:22,029 --> 00:11:27,130
opacity of a component between 0.7 and

00:11:24,850 --> 00:11:29,260
one which means when you hover elements

00:11:27,130 --> 00:11:32,980
they kind of fade in more and when you

00:11:29,260 --> 00:11:35,830
press them the the pressed interpolation

00:11:32,980 --> 00:11:37,570
means that it subtracts amount it's been

00:11:35,830 --> 00:11:40,960
pressed down which it feels like it's

00:11:37,570 --> 00:11:42,910
being pressed down using this map way we

00:11:40,960 --> 00:11:44,920
are able to achieve great performance

00:11:42,910 --> 00:11:46,870
because we don't have to we actually

00:11:44,920 --> 00:11:48,339
don't have any latency of being able to

00:11:46,870 --> 00:11:50,380
create those animations and we can

00:11:48,339 --> 00:11:52,660
actually from a low level and from

00:11:50,380 --> 00:11:54,160
ground up be able to define the

00:11:52,660 --> 00:11:58,960
components that we need and how they

00:11:54,160 --> 00:12:01,180
animate in our case a little example

00:11:58,960 --> 00:12:03,610
over up and how we use the hover events

00:12:01,180 --> 00:12:06,130
whenever you hover a card

00:12:03,610 --> 00:12:08,610
they simply tilt in kind of 3d space and

00:12:06,130 --> 00:12:11,500
they bring up a bit of opacity as well

00:12:08,610 --> 00:12:13,170
so in this case it looks quite nice and

00:12:11,500 --> 00:12:15,430
we're able to do it

00:12:13,170 --> 00:12:17,020
defining the whole animations on the

00:12:15,430 --> 00:12:20,170
JavaScript without having to worry about

00:12:17,020 --> 00:12:22,720
the platform or without having to worry

00:12:20,170 --> 00:12:24,490
about how it looks so if you would be

00:12:22,720 --> 00:12:27,330
using this on an Android TV you would

00:12:24,490 --> 00:12:30,250
expect that the car zoom in a little bit

00:12:27,330 --> 00:12:34,120
which is actually the pattern that Apple

00:12:30,250 --> 00:12:35,980
TV kind of recommends so we want to be a

00:12:34,120 --> 00:12:41,830
whereas on our platform we are kind of

00:12:35,980 --> 00:12:43,930
tilting it and changing the opacity part

00:12:41,830 --> 00:12:45,279
to is improving the render time so we

00:12:43,930 --> 00:12:48,190
want to make sure the animations don't

00:12:45,279 --> 00:12:51,610
drop any frames it's a new concept

00:12:48,190 --> 00:12:54,490
concept we haven't seen before in simple

00:12:51,610 --> 00:12:58,420
words we memorize all the animated and

00:12:54,490 --> 00:13:01,570
interpolation so the it usually can be

00:12:58,420 --> 00:13:03,279
solved when you interpolate any value

00:13:01,570 --> 00:13:06,870
and you can put it in a state or you can

00:13:03,279 --> 00:13:08,920
derive it or put it in the object values

00:13:06,870 --> 00:13:10,420
but we found it very difficult to

00:13:08,920 --> 00:13:11,500
maintain and manage we kind of want to

00:13:10,420 --> 00:13:13,390
keep everything within the render

00:13:11,500 --> 00:13:14,829
function to be able to define the

00:13:13,390 --> 00:13:17,750
components quite easily using pure

00:13:14,829 --> 00:13:19,670
components this is the kind of

00:13:17,750 --> 00:13:23,570
an example of a problem where you would

00:13:19,670 --> 00:13:25,850
want an an icon to be an image where

00:13:23,570 --> 00:13:27,710
opacity is being driven by if the

00:13:25,850 --> 00:13:30,560
element is being hovered or I mean it's

00:13:27,710 --> 00:13:35,210
not being hovered using the Roxy

00:13:30,560 --> 00:13:37,340
controller and the opacity would be 0.7

00:13:35,210 --> 00:13:39,680
so 70 percent opacity when the element

00:13:37,340 --> 00:13:42,530
is not overt and 100 percent when it's

00:13:39,680 --> 00:13:45,320
hovered the problem with this is every

00:13:42,530 --> 00:13:47,360
time he call interpolate function it

00:13:45,320 --> 00:13:50,750
returns a new object every time which

00:13:47,360 --> 00:13:53,510
means a new animated value sorry

00:13:50,750 --> 00:13:55,940
animated note is being created which is

00:13:53,510 --> 00:13:57,800
needs to be sent over the bridge because

00:13:55,940 --> 00:13:59,750
the react thinks it's a whole new

00:13:57,800 --> 00:14:02,540
animation and needs to be updated on the

00:13:59,750 --> 00:14:06,530
bridge and on the native side so for us

00:14:02,540 --> 00:14:09,980
that created a problem where we didn't

00:14:06,530 --> 00:14:13,240
want a latency of interpolating an

00:14:09,980 --> 00:14:16,520
object and having friends being dropped

00:14:13,240 --> 00:14:18,530
so simple solution is to create animated

00:14:16,520 --> 00:14:20,690
value and interpolate started to

00:14:18,530 --> 00:14:23,810
memorize the interpolate function which

00:14:20,690 --> 00:14:26,270
seems to work for us quite well and it

00:14:23,810 --> 00:14:28,700
is a bit more to just be the more

00:14:26,270 --> 00:14:32,990
background of how we solved it but

00:14:28,700 --> 00:14:35,300
simply we were able to create a new

00:14:32,990 --> 00:14:37,400
object called memorized animated value

00:14:35,300 --> 00:14:38,720
which extends animated value and it

00:14:37,400 --> 00:14:41,510
returns same object for the same

00:14:38,720 --> 00:14:43,940
interpolation which means we don't have

00:14:41,510 --> 00:14:47,089
to send anything over the bridge if the

00:14:43,940 --> 00:14:48,770
interpolation is the same the

00:14:47,089 --> 00:14:51,680
improvements are that reactive in

00:14:48,770 --> 00:14:54,830
previous and next render will not apply

00:14:51,680 --> 00:14:58,160
any commits because the interpolation

00:14:54,830 --> 00:14:59,750
will be the same it does not create any

00:14:58,160 --> 00:15:01,670
new objects every time we call render

00:14:59,750 --> 00:15:03,170
which sends over the bridge and prevents

00:15:01,670 --> 00:15:04,760
some animations from flickering if the

00:15:03,170 --> 00:15:07,250
value has changed so we've noticed that

00:15:04,760 --> 00:15:09,620
even though there's a lag there's also a

00:15:07,250 --> 00:15:11,860
flickering of the animation because the

00:15:09,620 --> 00:15:15,290
animation may change completely and

00:15:11,860 --> 00:15:17,589
we've run into a lot of issues on our

00:15:15,290 --> 00:15:17,589
device

00:15:17,810 --> 00:15:21,890
we'll be sharing the new class we've

00:15:20,210 --> 00:15:24,920
created with the community to hear any

00:15:21,890 --> 00:15:28,610
feedback we think it's great and we

00:15:24,920 --> 00:15:31,080
think that we are kind of trying to

00:15:28,610 --> 00:15:33,570
solve all the issues that

00:15:31,080 --> 00:15:35,580
reacted necessarily soul when it comes

00:15:33,570 --> 00:15:37,980
to animated notes and interpolations and

00:15:35,580 --> 00:15:39,390
values we think it's very useful for so

00:15:37,980 --> 00:15:42,570
we would love any feedback that you

00:15:39,390 --> 00:15:49,310
might have part 3 will be avoiding

00:15:42,570 --> 00:15:51,630
unnecessary renders we all have used

00:15:49,310 --> 00:15:54,690
mountain mail multiply and add and

00:15:51,630 --> 00:15:56,970
subtract and divide which allows you to

00:15:54,690 --> 00:16:00,180
take two animated values and be able to

00:15:56,970 --> 00:16:03,000
add them or subtract them we also knew

00:16:00,180 --> 00:16:05,520
that animated ads and adding the for

00:16:03,000 --> 00:16:07,800
instance a and B is the same as B na we

00:16:05,520 --> 00:16:11,279
didn't want it to be actually different

00:16:07,800 --> 00:16:15,149
for a component to render again with a

00:16:11,279 --> 00:16:17,250
new note and we actually wanted to

00:16:15,149 --> 00:16:18,839
realize that this compound does not in

00:16:17,250 --> 00:16:21,529
rendering because the value of it would

00:16:18,839 --> 00:16:23,550
be the same before it creates any

00:16:21,529 --> 00:16:25,320
messages over the bridge so I guess

00:16:23,550 --> 00:16:27,959
they're all work that we've been doing

00:16:25,320 --> 00:16:29,550
is sort of avoiding any messages being

00:16:27,959 --> 00:16:36,300
sent over the bridge between the react

00:16:29,550 --> 00:16:40,440
native and the native side so we can

00:16:36,300 --> 00:16:42,480
implement an existing react method

00:16:40,440 --> 00:16:45,959
called should component update

00:16:42,480 --> 00:16:48,959
the question here is how do we are how

00:16:45,959 --> 00:16:50,490
do we compare if one value is the same

00:16:48,959 --> 00:16:55,110
as the other if there are actually

00:16:50,490 --> 00:16:57,450
different objects so we've used a low -

00:16:55,110 --> 00:16:59,820
is equal width which allows us to

00:16:57,450 --> 00:17:02,850
compare two objects and it would compare

00:16:59,820 --> 00:17:05,420
those two objects the same way as a

00:17:02,850 --> 00:17:08,670
component in react we would compare them

00:17:05,420 --> 00:17:10,920
if they happen to be animated notes we

00:17:08,670 --> 00:17:14,309
simply use our function called animated

00:17:10,920 --> 00:17:16,559
note equal and if they're equal return

00:17:14,309 --> 00:17:19,110
true which means the component would not

00:17:16,559 --> 00:17:21,780
render otherwise we return undefined

00:17:19,110 --> 00:17:24,390
which means can we rely on the on the

00:17:21,780 --> 00:17:27,000
default implementation of low - which is

00:17:24,390 --> 00:17:29,850
recursive and allows us to compare two

00:17:27,000 --> 00:17:32,179
objects for instance styles or props to

00:17:29,850 --> 00:17:37,470
be able to compare it in a simple way

00:17:32,179 --> 00:17:39,330
that reactors already by default to

00:17:37,470 --> 00:17:43,320
compare whether two animated nodes are

00:17:39,330 --> 00:17:44,640
equal we simply create a couple of

00:17:43,320 --> 00:17:47,039
conditions

00:17:44,640 --> 00:17:49,320
which actually cover all the cases that

00:17:47,039 --> 00:17:51,330
are possible which means if the first

00:17:49,320 --> 00:17:53,429
condition is if there are strictly equal

00:17:51,330 --> 00:17:55,019
we'd return true right away so we don't

00:17:53,429 --> 00:17:56,870
have to worry we can exit the function

00:17:55,019 --> 00:18:00,929
as soon as possible

00:17:56,870 --> 00:18:03,809
if the second condition is if there are

00:18:00,929 --> 00:18:05,250
something else done a value we simply

00:18:03,809 --> 00:18:07,799
return false that there are suddenly not

00:18:05,250 --> 00:18:09,750
equal and then we compare their parents

00:18:07,799 --> 00:18:11,820
because an animated no it could be

00:18:09,750 --> 00:18:15,029
actually an addition of two values so

00:18:11,820 --> 00:18:17,220
they have parents and for every

00:18:15,029 --> 00:18:19,409
different module sorry for different

00:18:17,220 --> 00:18:21,720
nodes like interpolation diff clamp

00:18:19,409 --> 00:18:26,279
modular and addition multiplication and

00:18:21,720 --> 00:18:28,200
division we use different cases to

00:18:26,279 --> 00:18:30,240
define whether they are equal this

00:18:28,200 --> 00:18:32,309
functions of the recursive you can see

00:18:30,240 --> 00:18:33,960
here that if they have parents we

00:18:32,309 --> 00:18:36,230
compare the parents if the parents are

00:18:33,960 --> 00:18:39,570
also equal which means that if you

00:18:36,230 --> 00:18:41,760
multiply two nodes and add additional

00:18:39,570 --> 00:18:43,620
two nodes that function will check if

00:18:41,760 --> 00:18:48,529
they're all equal to define what our

00:18:43,620 --> 00:18:51,990
component should render or not render so

00:18:48,529 --> 00:18:54,240
to solve this you can choose using react

00:18:51,990 --> 00:18:56,909
pure component which are shallow compare

00:18:54,240 --> 00:18:58,830
of props and states you have a react

00:18:56,909 --> 00:19:00,330
component which has a deep compare and

00:18:58,830 --> 00:19:02,309
we've created our own component called

00:19:00,330 --> 00:19:04,529
animated component which is a deep

00:19:02,309 --> 00:19:07,679
compare but supports animated animation

00:19:04,529 --> 00:19:10,289
nodes meaning that it will compare any

00:19:07,679 --> 00:19:12,029
animated interpolations and any other

00:19:10,289 --> 00:19:14,669
values where there are the same or not

00:19:12,029 --> 00:19:18,600
to make sure components do not render

00:19:14,669 --> 00:19:20,070
again this is how the animated component

00:19:18,600 --> 00:19:23,039
looks like it's pretty straight forward

00:19:20,070 --> 00:19:25,200
but in the main important part here is

00:19:23,039 --> 00:19:26,970
should component update which define

00:19:25,200 --> 00:19:32,580
where a props are equal or state is

00:19:26,970 --> 00:19:35,940
equal and it is not actually creating

00:19:32,580 --> 00:19:37,919
any overhead because it is recursive but

00:19:35,940 --> 00:19:39,960
as soon as the two values are identical

00:19:37,919 --> 00:19:42,059
we don't actually Traverse for the whole

00:19:39,960 --> 00:19:44,909
tree we realize those two objects are

00:19:42,059 --> 00:19:47,100
the same and this really kind of creates

00:19:44,909 --> 00:19:49,320
a the moment we've introduced in our

00:19:47,100 --> 00:19:51,690
application with not a significant

00:19:49,320 --> 00:19:54,320
improvement of performance and all the

00:19:51,690 --> 00:19:56,750
animations being a lot faster

00:19:54,320 --> 00:19:59,450
the summary is the magic view removes

00:19:56,750 --> 00:20:03,700
all the messages from the bridge when

00:19:59,450 --> 00:20:06,590
using native driver animations the

00:20:03,700 --> 00:20:14,240
memorized I met value prevents commits

00:20:06,590 --> 00:20:18,470
after render means your component does

00:20:14,240 --> 00:20:21,890
not have to sorry your animate values do

00:20:18,470 --> 00:20:23,390
not change the value of the render

00:20:21,890 --> 00:20:25,669
function so the render function can be

00:20:23,390 --> 00:20:28,880
cached and therefore it remains the same

00:20:25,669 --> 00:20:31,280
across many renders and it's animated

00:20:28,880 --> 00:20:36,200
equal prevents from component rendering

00:20:31,280 --> 00:20:39,440
which is the part free our future work

00:20:36,200 --> 00:20:42,650
is we love hardware we love software we

00:20:39,440 --> 00:20:44,299
like bring them together we we like to

00:20:42,650 --> 00:20:46,340
react native of how simple it allows us

00:20:44,299 --> 00:20:48,410
to define a lot of the concepts that in

00:20:46,340 --> 00:20:51,890
solves a lot of time developing actual

00:20:48,410 --> 00:20:54,669
product and focusing on the UI UX and we

00:20:51,890 --> 00:20:59,360
love hardware because we like to control

00:20:54,669 --> 00:21:01,549
building device that consumers can feel

00:20:59,360 --> 00:21:04,370
as their physical and be able to connect

00:21:01,549 --> 00:21:06,220
them to your TV and listen to music and

00:21:04,370 --> 00:21:10,880
enjoy the great music that they will

00:21:06,220 --> 00:21:12,890
want so our future work is to publish

00:21:10,880 --> 00:21:15,530
more work on our github page if you're

00:21:12,890 --> 00:21:19,640
interested please let us know what you

00:21:15,530 --> 00:21:23,240
think we would like to demonstrate more

00:21:19,640 --> 00:21:27,500
work in such as our animated list

00:21:23,240 --> 00:21:30,320
component which allows us to create our

00:21:27,500 --> 00:21:34,640
own virtualized list for both Android

00:21:30,320 --> 00:21:37,370
and iOS and please reach out if you

00:21:34,640 --> 00:21:40,700
insulae in what we do we would love any

00:21:37,370 --> 00:21:41,960
feedback in terms of understanding of if

00:21:40,700 --> 00:21:44,090
someone else has been doing sort of

00:21:41,960 --> 00:21:47,360
serve the same goals that we've been

00:21:44,090 --> 00:21:50,480
trying to achieve and thank you for

00:21:47,360 --> 00:21:54,169
listening this is a quick demo of how

00:21:50,480 --> 00:21:56,620
our application looks like and I hope

00:21:54,169 --> 00:21:56,620
you enjoy it

00:22:00,960 --> 00:22:05,169
so this is what we call the carousel

00:22:03,159 --> 00:22:13,960
where you can scroll through different

00:22:05,169 --> 00:22:15,399
features of the app you're able to

00:22:13,960 --> 00:22:21,070
choose the playlist you would like to

00:22:15,399 --> 00:22:22,659
listen to and yes it plays music you're

00:22:21,070 --> 00:22:24,669
able to discover different genres of

00:22:22,659 --> 00:22:26,830
music you're able to scroll through the

00:22:24,669 --> 00:22:31,510
different lists and different curated

00:22:26,830 --> 00:22:33,880
playlists that you may like URLs are

00:22:31,510 --> 00:22:43,269
able to dive into more sections and

00:22:33,880 --> 00:22:46,570
navigate deeper through the menus and as

00:22:43,269 --> 00:22:48,850
you scroll you may choose some playlists

00:22:46,570 --> 00:22:51,429
and look at the preview of that playlist

00:22:48,850 --> 00:22:53,289
to be able to see the trucks we

00:22:51,429 --> 00:22:54,880
obviously have a lot of animations going

00:22:53,289 --> 00:22:57,940
at the same time because of the how big

00:22:54,880 --> 00:23:00,220
the screen is on the TV so our use case

00:22:57,940 --> 00:23:03,190
is very different from a mobile use case

00:23:00,220 --> 00:23:05,320
where animations are usually a lot

00:23:03,190 --> 00:23:08,649
smaller whereas now screen if s if a

00:23:05,320 --> 00:23:09,909
view slides in it's a huge thing coming

00:23:08,649 --> 00:23:11,679
on the screen rather than on a mobile

00:23:09,909 --> 00:23:13,659
device which may be kind of subtool and

00:23:11,679 --> 00:23:16,330
people may not notice a frame being

00:23:13,659 --> 00:23:19,000
dropped we also have our own keyboard

00:23:16,330 --> 00:23:21,460
that we've implemented so we're able to

00:23:19,000 --> 00:23:24,490
search through music and be able to

00:23:21,460 --> 00:23:26,610
search for results of different kinds of

00:23:24,490 --> 00:23:26,610
music

00:23:33,740 --> 00:23:38,630
we also have the latest music available

00:23:36,350 --> 00:23:41,420
so you can see this is the current

00:23:38,630 --> 00:23:43,250
charts that we have in their app meaning

00:23:41,420 --> 00:23:46,280
that you can sort of kind of get an idea

00:23:43,250 --> 00:23:52,400
of all the music we we have in our

00:23:46,280 --> 00:23:54,570
catalog and that's pretty much it thank

00:23:52,400 --> 00:24:01,580
you so much

00:23:54,570 --> 00:24:01,580

YouTube URL: https://www.youtube.com/watch?v=laTjD8c3SDE


