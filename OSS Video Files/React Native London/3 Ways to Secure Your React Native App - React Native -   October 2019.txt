Title: 3 Ways to Secure Your React Native App - React Native -   October 2019
Publication date: 2019-11-13
Playlist: React Native London
Description: 
	3 ways to secure your React Native App by Christian Chown

In this talk, we'll outline how you can add JavaScript obfuscation, certificate pinning and root detection to your React Native app to secure your codebase, your API calls and your data

Twitter: @christianchown
Github: https://github.com/christianchown
Website: https://www.christianchown.com

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,730
hello hello everyone i'm christine chan

00:00:02,159 --> 00:00:08,309
I'm a reactant react native contractor

00:00:04,730 --> 00:00:10,230
my most recent contracts with the bank

00:00:08,309 --> 00:00:14,280
Santander where we were developing a

00:00:10,230 --> 00:00:16,080
Greenfield react native app I'm not by

00:00:14,280 --> 00:00:18,330
any means a security expert but

00:00:16,080 --> 00:00:21,689
developing an app for a bank and its own

00:00:18,330 --> 00:00:22,619
set of security challenges and some of

00:00:21,689 --> 00:00:24,359
those learnings I'm going to talk about

00:00:22,619 --> 00:00:26,369
today I'm going to talk about using Java

00:00:24,359 --> 00:00:29,789
Script obfuscation to secure your

00:00:26,369 --> 00:00:32,489
codebase and certificate pinning to

00:00:29,789 --> 00:00:35,660
secure your API calls and finally

00:00:32,489 --> 00:00:40,170
jailbreak detection to secure your data

00:00:35,660 --> 00:00:42,899
so using a JavaScript obfuscation to

00:00:40,170 --> 00:00:45,149
secure your codebase

00:00:42,899 --> 00:00:48,809
we're react native developers we create

00:00:45,149 --> 00:00:50,940
apipa files for the App Store and apk

00:00:48,809 --> 00:00:54,120
files to the Play Store there's no such

00:00:50,940 --> 00:00:55,949
thing as an IPA file format these are

00:00:54,120 --> 00:00:57,780
just zip files you know if you change

00:00:55,949 --> 00:01:00,899
their extension on them running through

00:00:57,780 --> 00:01:04,739
years if you can see what's inside them

00:01:00,899 --> 00:01:06,900
at this is one of my IPA files and bunch

00:01:04,739 --> 00:01:10,490
of icons math sets and next my

00:01:06,900 --> 00:01:13,590
info.plist is my main J's bundle

00:01:10,490 --> 00:01:16,320
similarly here's an apk file they have a

00:01:13,590 --> 00:01:18,750
flutter folder structure but they're in

00:01:16,320 --> 00:01:23,400
the assets next to my fonts is my

00:01:18,750 --> 00:01:24,960
Android mundo index Android bundles but

00:01:23,400 --> 00:01:27,920
does that matter what can you actually

00:01:24,960 --> 00:01:30,770
see if you look at transfer piled

00:01:27,920 --> 00:01:34,500
minified code I mean it's it's quite

00:01:30,770 --> 00:01:35,040
condensed anyway so I have a proof of

00:01:34,500 --> 00:01:38,820
concept

00:01:35,040 --> 00:01:41,790
I spun up a create react app this is it

00:01:38,820 --> 00:01:45,899
here so let's see if I can spend where

00:01:41,790 --> 00:01:48,119
there is my create react app and in it I

00:01:45,899 --> 00:01:50,790
put a sensitive piece of information in

00:01:48,119 --> 00:01:53,700
this case a secret key and here's that

00:01:50,790 --> 00:01:56,189
same app transpired and minified you

00:01:53,700 --> 00:01:58,740
know it's it's fairly condensed but the

00:01:56,189 --> 00:02:00,210
strings are fairly visible in there in

00:01:58,740 --> 00:02:03,439
fact if I look at this middle section

00:02:00,210 --> 00:02:06,360
here and then run it through prettier

00:02:03,439 --> 00:02:08,369
you can see that this is that app

00:02:06,360 --> 00:02:12,690
component you just saw you know it's

00:02:08,369 --> 00:02:13,710
it's really nice clean clear es5 code so

00:02:12,690 --> 00:02:16,680
that's you know

00:02:13,710 --> 00:02:20,610
system and the clean abstraction that

00:02:16,680 --> 00:02:23,610
underlies we act however is very easy to

00:02:20,610 --> 00:02:25,410
reverse engineer this and just to show

00:02:23,610 --> 00:02:27,720
that's not specific to create react app

00:02:25,410 --> 00:02:32,430
this is from one of my live production

00:02:27,720 --> 00:02:35,880
apk files this is a part of my login

00:02:32,430 --> 00:02:38,460
form it's the same nice clean clear es5

00:02:35,880 --> 00:02:40,860
code but instead of dorm elements

00:02:38,460 --> 00:02:44,190
there's react native views react native

00:02:40,860 --> 00:02:46,560
styles and in the center of my bundle

00:02:44,190 --> 00:02:49,590
here's the credentials for my firebase

00:02:46,560 --> 00:02:52,320
database now leave the client-side

00:02:49,590 --> 00:02:55,110
credentials yes but it's not something

00:02:52,320 --> 00:02:59,100
I'd necessarily want completely so open

00:02:55,110 --> 00:03:02,280
and visible you know so how hard would

00:02:59,100 --> 00:03:03,690
it be for someone here say of it I think

00:03:02,280 --> 00:03:05,850
quite a lot of this room could do this

00:03:03,690 --> 00:03:07,470
right something that extract all the

00:03:05,850 --> 00:03:08,700
strings from a JavaScript file but you

00:03:07,470 --> 00:03:11,970
don't even need to write it there's an

00:03:08,700 --> 00:03:13,230
NPM module for that in fact how

00:03:11,970 --> 00:03:16,380
difficult would it be to write something

00:03:13,230 --> 00:03:19,080
that unzipped apks and ipas you know if

00:03:16,380 --> 00:03:21,090
you give it an APK file an IPA file and

00:03:19,080 --> 00:03:23,940
it will risk extracts and react native

00:03:21,090 --> 00:03:26,250
javascript how difficult would it be as

00:03:23,940 --> 00:03:29,300
well to scrape a website and download

00:03:26,250 --> 00:03:31,830
any APK zouri ipas you might find there

00:03:29,300 --> 00:03:34,230
what have you got you've just written a

00:03:31,830 --> 00:03:36,600
tool that will extract from the App

00:03:34,230 --> 00:03:38,910
Store and the Play Store every single

00:03:36,600 --> 00:03:41,040
react native app every string and then

00:03:38,910 --> 00:03:43,380
put it into a spreadsheet for you who

00:03:41,040 --> 00:03:46,770
knows what treasures you might find in

00:03:43,380 --> 00:03:49,620
there so going back to our original

00:03:46,770 --> 00:03:51,270
Brundle I took this and I gave it to the

00:03:49,620 --> 00:03:53,250
bank's penetration testing team and I

00:03:51,270 --> 00:03:59,070
said can you find the secret key and

00:03:53,250 --> 00:04:01,980
they went yes so then I ran it through a

00:03:59,070 --> 00:04:04,320
commercial JavaScript obfuscator would

00:04:01,980 --> 00:04:06,810
you like to see some commercially

00:04:04,320 --> 00:04:08,130
obfuscated JavaScript of course you

00:04:06,810 --> 00:04:13,260
would yes yes

00:04:08,130 --> 00:04:15,630
looks like this and this and this pages

00:04:13,260 --> 00:04:18,630
and pages and pages were utterly

00:04:15,630 --> 00:04:20,850
impenetrable garbage this is my preview

00:04:18,630 --> 00:04:23,070
bait obvious case you can get the idea

00:04:20,850 --> 00:04:24,750
that I showed this to the pen test team

00:04:23,070 --> 00:04:25,780
and they went what am I looking at

00:04:24,750 --> 00:04:28,420
exactly

00:04:25,780 --> 00:04:30,490
so yeah this is commercial obfuscation

00:04:28,420 --> 00:04:32,170
I've run it I've read in similar bundles

00:04:30,490 --> 00:04:34,660
through the open-source JavaScript

00:04:32,170 --> 00:04:36,160
obvious caters they do a good job too as

00:04:34,660 --> 00:04:37,660
well and all of them just weren't

00:04:36,160 --> 00:04:38,919
offered single line shell script you

00:04:37,660 --> 00:04:41,560
know you give it an input file and

00:04:38,919 --> 00:04:42,940
output file few config sayings and you

00:04:41,560 --> 00:04:45,580
get an obfuscated version as the same

00:04:42,940 --> 00:04:48,460
JavaScript and while it's used case

00:04:45,580 --> 00:04:50,919
defendant you might think well this is

00:04:48,460 --> 00:04:53,410
actually some value to me so how would

00:04:50,919 --> 00:04:56,919
you incorporate that into your react

00:04:53,410 --> 00:04:59,310
native built process one option would be

00:04:56,919 --> 00:05:02,350
to do it during transpiration there's a

00:04:59,310 --> 00:05:04,300
no npm module here which is react native

00:05:02,350 --> 00:05:07,030
obfuscating transformer if you've ever

00:05:04,300 --> 00:05:10,150
added typescript to a react code base is

00:05:07,030 --> 00:05:11,760
the same idea it's a babel transform and

00:05:10,150 --> 00:05:15,220
that will then obfuscate on a

00:05:11,760 --> 00:05:17,860
file-by-file basis we chose a different

00:05:15,220 --> 00:05:20,100
approach we chose to do it during the

00:05:17,860 --> 00:05:22,690
bundle phase when we had the entire

00:05:20,100 --> 00:05:25,840
javascript bundle to work on there were

00:05:22,690 --> 00:05:27,970
two main advantages to this transpiling

00:05:25,840 --> 00:05:29,950
the entire bundle gives the obfuscator a

00:05:27,970 --> 00:05:31,780
bit more scope to move stuff around and

00:05:29,950 --> 00:05:34,300
because we didn't have to provide

00:05:31,780 --> 00:05:36,280
interoperability between the files amen

00:05:34,300 --> 00:05:38,770
every single identifiers name could get

00:05:36,280 --> 00:05:41,890
mangled which allowed us to produce the

00:05:38,770 --> 00:05:44,470
kind of results that we did there and

00:05:41,890 --> 00:05:47,050
how would you actually do that right

00:05:44,470 --> 00:05:51,220
well here is your favorite rap and mine

00:05:47,050 --> 00:05:53,650
xcode we're in the bill phases tab of

00:05:51,220 --> 00:05:55,990
this target the final bill face here is

00:05:53,650 --> 00:05:59,100
bundle react native code and images

00:05:55,990 --> 00:06:02,140
which looks like this it just runs a

00:05:59,100 --> 00:06:05,080
shell script within react native node

00:06:02,140 --> 00:06:08,380
modules and this is where we choose to

00:06:05,080 --> 00:06:11,080
obfuscate not much for change

00:06:08,380 --> 00:06:13,270
it's basically sniff out the release

00:06:11,080 --> 00:06:15,130
configuration say that we're doing it

00:06:13,270 --> 00:06:17,740
run the same shell script you were

00:06:15,130 --> 00:06:22,620
before and then run the obfuscator on it

00:06:17,740 --> 00:06:25,600
and xcode will then just take all that

00:06:22,620 --> 00:06:29,080
obfuscated bundle and just apply that

00:06:25,600 --> 00:06:31,390
into our final OPA android a little bit

00:06:29,080 --> 00:06:34,000
more involved this is my op level build

00:06:31,390 --> 00:06:35,290
up Gradle final step here again is

00:06:34,000 --> 00:06:38,590
summing off the

00:06:35,290 --> 00:06:40,030
Rett native node modules we add an

00:06:38,590 --> 00:06:44,530
additional option skates

00:06:40,030 --> 00:06:47,050
oh you skate to the step this is the

00:06:44,530 --> 00:06:49,570
skeleton of the obfuscation script one

00:06:47,050 --> 00:06:51,370
thing if you ever write any Gradle

00:06:49,570 --> 00:06:54,010
script in Gradle is written in the

00:06:51,370 --> 00:06:57,220
groovy language which is very very

00:06:54,010 --> 00:06:59,170
similar to Java in appearance however I

00:06:57,220 --> 00:07:02,740
got caught out because groovy is

00:06:59,170 --> 00:07:05,530
declarative nor imperative so you kind

00:07:02,740 --> 00:07:07,930
of declare individual tasks and then you

00:07:05,530 --> 00:07:10,540
link them together through a dependency

00:07:07,930 --> 00:07:13,180
chain the final step is normally this

00:07:10,540 --> 00:07:15,220
assembly step which normally depends on

00:07:13,180 --> 00:07:18,490
the packaging step so packages up your

00:07:15,220 --> 00:07:20,410
apk and then assembles it so what we did

00:07:18,490 --> 00:07:22,900
we just stuck free tasks in the middle

00:07:20,410 --> 00:07:24,430
first one we said okay that thing you

00:07:22,900 --> 00:07:26,200
packaged up I want to unzip it

00:07:24,430 --> 00:07:29,380
I didn't want to obfuscate the bundle

00:07:26,200 --> 00:07:30,700
and I don't want to Rees if it this is

00:07:29,380 --> 00:07:33,010
what the tasks are low like I can't

00:07:30,700 --> 00:07:35,260
claim any ownership for this code by the

00:07:33,010 --> 00:07:37,960
way this is all completely cannibalized

00:07:35,260 --> 00:07:40,150
from an example app but just to give you

00:07:37,960 --> 00:07:43,000
some idea of you know this is this is

00:07:40,150 --> 00:07:45,310
the real thing this is why it's doing we

00:07:43,000 --> 00:07:48,010
basically say this one's a copy task so

00:07:45,310 --> 00:07:51,310
from my zip I want you to grab the a set

00:07:48,010 --> 00:07:53,470
the index android bundle the input is my

00:07:51,310 --> 00:07:57,130
apk my output I'm gonna stick in my temp

00:07:53,470 --> 00:07:59,140
file the Android bundle then I'm gonna

00:07:57,130 --> 00:08:01,440
run the obfuscation shell script single

00:07:59,140 --> 00:08:04,840
liner same as we did for iOS

00:08:01,440 --> 00:08:08,260
input/output and arguments all the same

00:08:04,840 --> 00:08:11,920
so then obfuscated in place my Android

00:08:08,260 --> 00:08:14,680
bundle and then reassemble the apk so

00:08:11,920 --> 00:08:17,080
the input is my obfuscated bundle my

00:08:14,680 --> 00:08:19,540
uploads my Achy are a PK this first bit

00:08:17,080 --> 00:08:23,200
says get everything from the original

00:08:19,540 --> 00:08:24,760
apk but exclude the Android bundle but

00:08:23,200 --> 00:08:28,450
from the temporary directory include

00:08:24,760 --> 00:08:32,050
that Android Mandal and that's it we've

00:08:28,450 --> 00:08:34,570
obviously a Java Script in our app and

00:08:32,050 --> 00:08:36,400
what we do is now protect it against a

00:08:34,570 --> 00:08:38,140
fairly unsophisticated attacker it

00:08:36,400 --> 00:08:40,870
doesn't take a very great deal of skill

00:08:38,140 --> 00:08:43,930
or effort to subject JavaScript to

00:08:40,870 --> 00:08:46,520
static analysis and what's you know

00:08:43,930 --> 00:08:49,130
while there is some setup cost

00:08:46,520 --> 00:08:51,230
it's a fair so a one-off cost you can

00:08:49,130 --> 00:08:54,770
add this a project after project in a

00:08:51,230 --> 00:08:56,630
matter of minutes there are some

00:08:54,770 --> 00:08:58,760
trade-offs first of you using anything

00:08:56,630 --> 00:09:00,170
like crashlytics you're not going to get

00:08:58,760 --> 00:09:02,630
the nice stacked rate as you were

00:09:00,170 --> 00:09:05,149
because of all the control flow

00:09:02,630 --> 00:09:06,560
flattening and all the other mangling

00:09:05,149 --> 00:09:08,690
that they office gates going to do to it

00:09:06,560 --> 00:09:11,240
normally most of the obfuscators do give

00:09:08,690 --> 00:09:15,200
you a source map it's an extra step bit

00:09:11,240 --> 00:09:17,450
of a hassle and finally your bundle is

00:09:15,200 --> 00:09:19,550
going to be bigger and as a result it's

00:09:17,450 --> 00:09:21,320
probably going to be slower for our case

00:09:19,550 --> 00:09:23,660
in the bank we were doing a banking app

00:09:21,320 --> 00:09:25,850
you know not too much heavy lifting on

00:09:23,660 --> 00:09:26,810
the JavaScript side and we found it

00:09:25,850 --> 00:09:28,779
didn't hurt really

00:09:26,810 --> 00:09:30,649
there was no noticeable difference but

00:09:28,779 --> 00:09:32,600
generally I found if you're having

00:09:30,649 --> 00:09:34,190
performance problems in react negative

00:09:32,600 --> 00:09:36,950
you know is it because you're doing too

00:09:34,190 --> 00:09:38,570
much work on the JavaScript thread or is

00:09:36,950 --> 00:09:42,170
it because there's too much going over

00:09:38,570 --> 00:09:46,760
the native bridge spoiler alert it's the

00:09:42,170 --> 00:09:48,470
bridge so the JavaScript obfuscation

00:09:46,760 --> 00:09:51,860
we're not going talk about certificate

00:09:48,470 --> 00:09:54,140
pinning to secure API calls it's hard to

00:09:51,860 --> 00:09:57,020
think of any app you know of any

00:09:54,140 --> 00:10:00,410
complexity that doesn't need to make API

00:09:57,020 --> 00:10:04,190
calls and react native defaults us to

00:10:00,410 --> 00:10:07,520
using HTTPS only it's a good thing HTTP

00:10:04,190 --> 00:10:10,070
traffic is clear text by it's clear text

00:10:07,520 --> 00:10:12,770
so you can override your react native

00:10:10,070 --> 00:10:16,220
app to use HTTP traffic but it's a

00:10:12,770 --> 00:10:18,110
hassle and Apple will ask you to justify

00:10:16,220 --> 00:10:22,250
it when you try to publish to the App

00:10:18,110 --> 00:10:25,250
Store and that's never fun plus we're

00:10:22,250 --> 00:10:29,600
operating in a hostile environment what

00:10:25,250 --> 00:10:32,839
do I mean quick primer on HTTPS when our

00:10:29,600 --> 00:10:35,209
device opens a connection to your bank

00:10:32,839 --> 00:10:37,430
comm your bank responds with an ssl

00:10:35,209 --> 00:10:39,529
certificate and your device will then

00:10:37,430 --> 00:10:42,260
compare that SSL certificate to the root

00:10:39,529 --> 00:10:43,250
certificates that has baked into the

00:10:42,260 --> 00:10:46,220
operating system

00:10:43,250 --> 00:10:48,140
the baked in root certificates are the

00:10:46,220 --> 00:10:51,589
ones from the trusted ssl certificate

00:10:48,140 --> 00:10:53,720
authorities and the way we link any

00:10:51,589 --> 00:10:55,760
certificate from you know one from your

00:10:53,720 --> 00:10:58,250
bank to the root certificates is that

00:10:55,760 --> 00:11:01,000
each of the certificate has a signature

00:10:58,250 --> 00:11:03,470
and a key and cryptical a

00:11:01,000 --> 00:11:07,130
cryptographically if you've got a

00:11:03,470 --> 00:11:08,750
signature and a public key you can

00:11:07,130 --> 00:11:11,089
verify run a little mathematical

00:11:08,750 --> 00:11:13,520
operation to verify that the signature

00:11:11,089 --> 00:11:16,220
was created by the private key that

00:11:13,520 --> 00:11:20,060
correspond to the public key and in that

00:11:16,220 --> 00:11:23,660
way each certificate can be linked so

00:11:20,060 --> 00:11:25,520
now your certificate comes in you've got

00:11:23,660 --> 00:11:28,400
signature of the certificate you can it

00:11:25,520 --> 00:11:30,500
has a link through to the any number of

00:11:28,400 --> 00:11:32,329
intermediate certificates you can pair

00:11:30,500 --> 00:11:35,120
the certificate on that to the public

00:11:32,329 --> 00:11:36,860
key on that verify that intermediate

00:11:35,120 --> 00:11:38,839
certificate intermediate sticker until

00:11:36,860 --> 00:11:41,089
finally reach its self signed

00:11:38,839 --> 00:11:42,620
root certificate and then you compare

00:11:41,089 --> 00:11:46,370
but hashes out the hash of the ones

00:11:42,620 --> 00:11:48,470
baked into device and if they match then

00:11:46,370 --> 00:11:50,839
you accept that this certificate is

00:11:48,470 --> 00:11:55,339
valid and you've established the HTTPS

00:11:50,839 --> 00:12:00,110
chain trust so how might you break the

00:11:55,339 --> 00:12:02,899
HTTPS chain of trust okay so hi this is

00:12:00,110 --> 00:12:05,390
your bank we've detected a security

00:12:02,899 --> 00:12:08,390
problem with your Android device yeah if

00:12:05,390 --> 00:12:11,300
you could just go to your bank Evo comm

00:12:08,390 --> 00:12:14,839
they're just our security partners yes

00:12:11,300 --> 00:12:16,670
click that link yep security message

00:12:14,839 --> 00:12:18,680
perfectly normal

00:12:16,670 --> 00:12:20,360
leave the box check that says this

00:12:18,680 --> 00:12:21,199
install only though because you can't be

00:12:20,360 --> 00:12:24,140
too careful

00:12:21,199 --> 00:12:27,140
right now your device will restart and

00:12:24,140 --> 00:12:30,320
you're completely secured so I've now

00:12:27,140 --> 00:12:34,339
installed a web proxy to divert network

00:12:30,320 --> 00:12:38,060
traffic and a new root certificate so

00:12:34,339 --> 00:12:40,490
now any network requests to your bank

00:12:38,060 --> 00:12:42,560
comm is going to go to a server under my

00:12:40,490 --> 00:12:45,649
control I'm going to respond with the

00:12:42,560 --> 00:12:47,870
certificate that is now signed by your

00:12:45,649 --> 00:12:50,690
the newly installed root certificate

00:12:47,870 --> 00:12:54,350
your app will now it said accept that as

00:12:50,690 --> 00:12:56,750
valid so now every request can be read

00:12:54,350 --> 00:12:59,209
and every response can be altered you

00:12:56,750 --> 00:13:00,860
know so I'd like to login with my

00:12:59,209 --> 00:13:03,980
password I'd like to login with my

00:13:00,860 --> 00:13:06,420
password log here's some login

00:13:03,980 --> 00:13:08,430
credentials

00:13:06,420 --> 00:13:13,260
transferred 10 pounds to Alex

00:13:08,430 --> 00:13:16,560
transferred 10,000 pounds evil Corp this

00:13:13,260 --> 00:13:18,690
is now a man-in-the-middle attack and

00:13:16,560 --> 00:13:21,390
know that the device has been completely

00:13:18,690 --> 00:13:24,510
compromised and not one byte of code on

00:13:21,390 --> 00:13:26,280
the banking app has changed this is what

00:13:24,510 --> 00:13:28,530
we mean by we're saying we're operating

00:13:26,280 --> 00:13:32,630
in an hostile environment because you

00:13:28,530 --> 00:13:35,130
can't necessarily trust HTTPS on its own

00:13:32,630 --> 00:13:37,440
so how do you protect against that it's

00:13:35,130 --> 00:13:39,030
actually quite simple in theory the idea

00:13:37,440 --> 00:13:40,950
is that during development you know the

00:13:39,030 --> 00:13:42,690
real Bank and so you know the real Steve

00:13:40,950 --> 00:13:44,820
Kerr and so now just the same way that

00:13:42,690 --> 00:13:47,160
you baked a root certificate into your

00:13:44,820 --> 00:13:49,530
device operating system you baked the

00:13:47,160 --> 00:13:54,650
real stuff get into your app or you pin

00:13:49,530 --> 00:13:57,060
the certificate to your app and so now

00:13:54,650 --> 00:13:59,490
anywhere a network request that goes out

00:13:57,060 --> 00:14:01,950
you just compare the reals difficut to

00:13:59,490 --> 00:14:05,010
the pins typical if it's good HTTP

00:14:01,950 --> 00:14:06,540
connection if the certificate doesn't

00:14:05,010 --> 00:14:08,250
match the pin you just don't know how

00:14:06,540 --> 00:14:09,570
many network traffic through and all you

00:14:08,250 --> 00:14:11,370
do is you'll just receive a four hundred

00:14:09,570 --> 00:14:13,500
error just like you couldn't open a

00:14:11,370 --> 00:14:16,590
secure connection so no compromise data

00:14:13,500 --> 00:14:18,240
ever gets into your app now is it worth

00:14:16,590 --> 00:14:20,580
doing this at all

00:14:18,240 --> 00:14:22,470
this is the quote from the open web

00:14:20,580 --> 00:14:23,940
security project they say you should pay

00:14:22,470 --> 00:14:26,370
in a time you want to be relatively

00:14:23,940 --> 00:14:28,110
certain of the remote hosts identity or

00:14:26,370 --> 00:14:30,600
when you're operating in a hostile

00:14:28,110 --> 00:14:33,120
environment since one or both are almost

00:14:30,600 --> 00:14:36,570
always true you should probably pin all

00:14:33,120 --> 00:14:40,470
the time they would say that they're a

00:14:36,570 --> 00:14:43,560
security organization but if it's not

00:14:40,470 --> 00:14:45,120
very much effort why not there's a

00:14:43,560 --> 00:14:46,560
couple of decent react native open

00:14:45,120 --> 00:14:49,020
source certificate pinning libraries

00:14:46,560 --> 00:14:51,930
there's react native SSL pinning react

00:14:49,020 --> 00:14:53,760
native cert pinning this is max toy

00:14:51,930 --> 00:14:55,860
balloons react native SSL pinning he

00:14:53,760 --> 00:14:58,320
gives you an S open SSH command you just

00:14:55,860 --> 00:15:00,270
give it your URL he'll then convert the

00:14:58,320 --> 00:15:03,530
certificate to a CER you decide those as

00:15:00,270 --> 00:15:06,750
assets just like you would a thumb a

00:15:03,530 --> 00:15:09,900
custom font into your app he provides a

00:15:06,750 --> 00:15:12,780
swap out for fetch and you just use that

00:15:09,900 --> 00:15:14,100
and I'll take you certain your app it

00:15:12,780 --> 00:15:16,050
under the hood that's got a little

00:15:14,100 --> 00:15:17,560
native modules that uses a fnaf

00:15:16,050 --> 00:15:20,500
networking which uses this

00:15:17,560 --> 00:15:24,670
are in the assets and okay HTTP three

00:15:20,500 --> 00:15:26,730
which uses the SSL pending alternative

00:15:24,670 --> 00:15:29,230
is approves react native cert Pinner

00:15:26,730 --> 00:15:31,390
yeah he doesn't provide you a tool for

00:15:29,230 --> 00:15:32,770
getting them but there's uh there's a

00:15:31,390 --> 00:15:35,380
couple of online tools you can use to

00:15:32,770 --> 00:15:38,830
get the base64 char hashes of either the

00:15:35,380 --> 00:15:40,870
public key all the certificates and he

00:15:38,830 --> 00:15:43,450
provides a utility which you put those

00:15:40,870 --> 00:15:46,270
into a JSON file and it then generates

00:15:43,450 --> 00:15:47,860
an info.plist or a java file which will

00:15:46,270 --> 00:15:51,010
then get linked in from the native side

00:15:47,860 --> 00:15:56,710
I use this trust kit under the hood for

00:15:51,010 --> 00:15:58,390
iOS and okay hb3 again on Android if I

00:15:56,710 --> 00:15:59,770
was going to recommend one of the

00:15:58,390 --> 00:16:02,860
libraries at the moment I'd say use

00:15:59,770 --> 00:16:05,830
approves one this is because it allows

00:16:02,860 --> 00:16:08,470
you to pin against the public key and

00:16:05,830 --> 00:16:10,750
the reason I'd say do that is if you've

00:16:08,470 --> 00:16:13,060
ever had a web client who's had their

00:16:10,750 --> 00:16:15,550
SSL certificate expire they tend to get

00:16:13,060 --> 00:16:18,400
very very cross if they're as so HTTP

00:16:15,550 --> 00:16:20,170
traffic stops working try and do that if

00:16:18,400 --> 00:16:22,510
you've got twenty thousand apps out

00:16:20,170 --> 00:16:24,700
there in the wild which are now bricked

00:16:22,510 --> 00:16:26,410
because of the networking because the

00:16:24,700 --> 00:16:29,560
pin will expire when the certificate

00:16:26,410 --> 00:16:31,510
expires so the other library the max

00:16:29,560 --> 00:16:33,339
Toyman library it has an open issue for

00:16:31,510 --> 00:16:35,440
pinning against public keys I'm sure

00:16:33,339 --> 00:16:36,880
that's coming and there's a couple of

00:16:35,440 --> 00:16:39,370
things I quite like about the Air Max

00:16:36,880 --> 00:16:41,589
toy than implementation which is part of

00:16:39,370 --> 00:16:44,370
the pin set is on the JavaScript side

00:16:41,589 --> 00:16:47,589
which means it'll get protected if you

00:16:44,370 --> 00:16:50,650
obfuscated your JavaScript so

00:16:47,589 --> 00:16:53,410
certificate pinning this time we're

00:16:50,650 --> 00:16:56,400
guarding against a certificated and

00:16:53,410 --> 00:16:59,530
determined attacker so you might think

00:16:56,400 --> 00:17:00,910
could be overkill for your app but you

00:16:59,530 --> 00:17:04,120
know what it's not actually very

00:17:00,910 --> 00:17:06,069
difficult to do you know once you've set

00:17:04,120 --> 00:17:07,870
up certificate pinning you can have it

00:17:06,069 --> 00:17:09,760
up and running on your next up and your

00:17:07,870 --> 00:17:11,380
next up and your next up you know in a

00:17:09,760 --> 00:17:14,410
matter of minutes you know we like

00:17:11,380 --> 00:17:16,839
one-off classes but like I say pin

00:17:14,410 --> 00:17:19,270
against this public key not against

00:17:16,839 --> 00:17:25,170
certificates else you might brick your

00:17:19,270 --> 00:17:28,430
app so almost there jailbreak detection

00:17:25,170 --> 00:17:32,390
now every one of our acts

00:17:28,430 --> 00:17:34,670
access to a sandboxed area slice of the

00:17:32,390 --> 00:17:36,170
file system and to our own preferences

00:17:34,670 --> 00:17:36,830
and to our own little bit of the

00:17:36,170 --> 00:17:40,490
keychain

00:17:36,830 --> 00:17:43,430
by default anyway but once your device's

00:17:40,490 --> 00:17:46,640
jailbroken or rooted that's no longer

00:17:43,430 --> 00:17:48,920
true a rooted user has access to the

00:17:46,640 --> 00:17:51,080
entire file system they can access the

00:17:48,920 --> 00:17:54,680
keychain and Android shared preference

00:17:51,080 --> 00:17:57,170
of any app they can install software and

00:17:54,680 --> 00:17:59,180
then from run executables and they can

00:17:57,170 --> 00:18:01,490
operate on modified firmware with who

00:17:59,180 --> 00:18:03,620
knows what on it and finally they could

00:18:01,490 --> 00:18:05,720
hook into a running app and run

00:18:03,620 --> 00:18:07,820
effectively run a debugger why are you

00:18:05,720 --> 00:18:09,800
running it's basically everything other

00:18:07,820 --> 00:18:11,870
than the iOS secure Enclave or the

00:18:09,800 --> 00:18:13,520
Android trusted execution environment is

00:18:11,870 --> 00:18:15,680
available all that handles is

00:18:13,520 --> 00:18:17,390
cryptography and your biometrics but

00:18:15,680 --> 00:18:20,660
everything else is available to a rooted

00:18:17,390 --> 00:18:22,460
user detecting root access is actually

00:18:20,660 --> 00:18:23,900
pretty well known and simple what you

00:18:22,460 --> 00:18:25,970
just do is you look for files that

00:18:23,900 --> 00:18:28,820
shouldn't be there like Cydia door app

00:18:25,970 --> 00:18:30,980
or you look for folders that exist that

00:18:28,820 --> 00:18:32,420
shouldn't the mostly look for exceptions

00:18:30,980 --> 00:18:34,130
not to be thrown when you're doing

00:18:32,420 --> 00:18:36,470
something you shouldn't be able to you

00:18:34,130 --> 00:18:39,530
know sudo root what and you don't

00:18:36,470 --> 00:18:42,290
complain you know so there's that there

00:18:39,530 --> 00:18:43,760
and again there's a couple of open

00:18:42,290 --> 00:18:46,010
source and react native jailbreak

00:18:43,760 --> 00:18:49,480
libraries available react native is

00:18:46,010 --> 00:18:52,460
device rooted and jambo jail monkey

00:18:49,480 --> 00:18:55,580
first one is a react native is device

00:18:52,460 --> 00:18:57,800
rooted by beast it doesn't look to be

00:18:55,580 --> 00:19:00,910
under and development sadly but nice

00:18:57,800 --> 00:19:03,350
clean API just couple of promise if I'd

00:19:00,910 --> 00:19:06,110
get me the device through it or get me

00:19:03,350 --> 00:19:08,780
the device locked but more comprehensive

00:19:06,110 --> 00:19:10,820
is gap man's jail monkey which is under

00:19:08,780 --> 00:19:12,770
active development unfortunately the

00:19:10,820 --> 00:19:14,150
main maintainer doesn't have the devices

00:19:12,770 --> 00:19:18,080
for the Piazza Center subject to

00:19:14,150 --> 00:19:20,540
community testing and as you know

00:19:18,080 --> 00:19:22,760
methods these are synchronous so they

00:19:20,540 --> 00:19:25,550
only work on the first fire up of your

00:19:22,760 --> 00:19:28,250
app so we've got ones for is jailbroken

00:19:25,550 --> 00:19:30,350
whether I'm running on the debugger hook

00:19:28,250 --> 00:19:31,940
detection or like so so it it's quite an

00:19:30,350 --> 00:19:34,160
interesting one detect whether your

00:19:31,940 --> 00:19:36,890
users can mock location if you're

00:19:34,160 --> 00:19:39,440
running an app with sensitive location

00:19:36,890 --> 00:19:41,660
data where that's specific it might be

00:19:39,440 --> 00:19:44,420
worthwhile for safeguarding reason

00:19:41,660 --> 00:19:47,240
to flag that up to other users on their

00:19:44,420 --> 00:19:50,360
map you can't necessarily trust the this

00:19:47,240 --> 00:19:53,960
person's location is might be being

00:19:50,360 --> 00:19:56,980
written misreported so once you've

00:19:53,960 --> 00:19:59,060
decided once you've detected a jailbreak

00:19:56,980 --> 00:20:01,190
you need to decide what actions you're

00:19:59,060 --> 00:20:04,160
gonna take now that will vary according

00:20:01,190 --> 00:20:05,180
to the needs of each individual app you

00:20:04,160 --> 00:20:08,180
might want to just create an access

00:20:05,180 --> 00:20:09,440
denied page just say nope sorry we're

00:20:08,180 --> 00:20:12,890
not going to run on a rooted or

00:20:09,440 --> 00:20:14,060
jailbroken device and then exit this is

00:20:12,890 --> 00:20:16,810
where you probably want to do if your

00:20:14,060 --> 00:20:21,650
app deals with particularly sensitive

00:20:16,810 --> 00:20:25,580
you know details or operations which are

00:20:21,650 --> 00:20:27,620
subject to privacy like a banking app or

00:20:25,580 --> 00:20:29,870
you might just provide them a subset of

00:20:27,620 --> 00:20:31,730
functionality just say ok you can see

00:20:29,870 --> 00:20:34,220
the balances but you can't make any

00:20:31,730 --> 00:20:35,990
transfers because we can't particularly

00:20:34,220 --> 00:20:38,600
trust that your device doesn't have key

00:20:35,990 --> 00:20:40,880
loggers and the like or you might just

00:20:38,600 --> 00:20:42,470
want to flag it up or flag up and flag

00:20:40,880 --> 00:20:44,420
it up for other users as well you know

00:20:42,470 --> 00:20:46,940
just saying that you know we have this

00:20:44,420 --> 00:20:50,900
information it may not be kundrus

00:20:46,940 --> 00:20:53,390
untrustworthy your mileage may vary so

00:20:50,900 --> 00:20:55,790
weight detection allows you to control

00:20:53,390 --> 00:20:58,880
the access of your app of a user with

00:20:55,790 --> 00:21:00,680
extended privileges but unlike the

00:20:58,880 --> 00:21:02,420
others which are one-off costs this will

00:21:00,680 --> 00:21:07,750
probably need to vary on an app buyout

00:21:02,420 --> 00:21:11,120
basis plus there are new exploits being

00:21:07,750 --> 00:21:13,670
found out every day which enables you

00:21:11,120 --> 00:21:16,550
access to the root user and you'll

00:21:13,670 --> 00:21:18,620
probably need these divine devices with

00:21:16,550 --> 00:21:21,890
these exploits on them in order to test

00:21:18,620 --> 00:21:24,620
this now when I was putting these slides

00:21:21,890 --> 00:21:26,780
together I did a Google search for a

00:21:24,620 --> 00:21:28,640
react native jailbreak detection so

00:21:26,780 --> 00:21:31,550
number one was gel monkey which I've

00:21:28,640 --> 00:21:34,970
just talked about and his beasts react

00:21:31,550 --> 00:21:38,780
native is device rooted the third here I

00:21:34,970 --> 00:21:40,700
got was bypassing jailbreak detection on

00:21:38,780 --> 00:21:43,970
a react native framework home mother

00:21:40,700 --> 00:21:46,370
read that what's the URL script kiddie

00:21:43,970 --> 00:21:48,650
don't wordpress.com well let's have a

00:21:46,370 --> 00:21:49,910
look at that man so here's script kiddie

00:21:48,650 --> 00:21:52,480
don't worry presto call me wrote a

00:21:49,910 --> 00:21:55,390
little blog article I was using some

00:21:52,480 --> 00:21:57,669
la OS FinTech app and he said while

00:21:55,390 --> 00:22:00,070
looking at sudden such iOS mobile age I

00:21:57,669 --> 00:22:02,530
was quite surprised in a good way that

00:22:00,070 --> 00:22:04,929
it had jailbreak detection implemented

00:22:02,530 --> 00:22:08,520
so he was surprised in a good way

00:22:04,929 --> 00:22:11,320
and immediately set about bypassing him

00:22:08,520 --> 00:22:13,150
the usual way of bypassing job rotation

00:22:11,320 --> 00:22:15,340
first identify the implementation of it

00:22:13,150 --> 00:22:16,720
usually by dumping the class and method

00:22:15,340 --> 00:22:18,820
names and searching for elevated

00:22:16,720 --> 00:22:21,190
relevant naming conventions in other

00:22:18,820 --> 00:22:23,650
words he's already got tools to

00:22:21,190 --> 00:22:25,929
statically analyze an objective-c or a

00:22:23,650 --> 00:22:29,169
swift code base but they don't work with

00:22:25,929 --> 00:22:31,000
ours because it's react native so the

00:22:29,169 --> 00:22:33,370
main application code he discovers in

00:22:31,000 --> 00:22:34,990
react native iOS application is located

00:22:33,370 --> 00:22:37,059
in the main jeaious bundle and by

00:22:34,990 --> 00:22:38,830
searching for relative irrelevant

00:22:37,059 --> 00:22:41,200
jailbreak detection methods we can

00:22:38,830 --> 00:22:45,010
quickly identify a few relevant related

00:22:41,200 --> 00:22:47,049
terms so he beautified the Jas Cody run

00:22:45,010 --> 00:22:49,299
it through pretty alright not quite as

00:22:47,049 --> 00:22:50,650
good prettier but and he spotted the

00:22:49,299 --> 00:22:53,679
main return value I don't know if you

00:22:50,650 --> 00:22:56,350
can see this but I donated modules

00:22:53,679 --> 00:22:58,000
thought Jo monkey it's Jo monkey and he

00:22:56,350 --> 00:23:00,640
finds the value of the jailbreak

00:22:58,000 --> 00:23:02,410
detection on around line 82 we simply

00:23:00,640 --> 00:23:05,830
had an explanation Mart to the return

00:23:02,410 --> 00:23:07,780
value of his jailbroken call copy over

00:23:05,830 --> 00:23:10,570
the edited main Jas bundle back to the

00:23:07,780 --> 00:23:12,940
application on our jailbroken iOS device

00:23:10,570 --> 00:23:15,460
we run the application thumb we've

00:23:12,940 --> 00:23:19,419
successfully bypass jailbreak detection

00:23:15,460 --> 00:23:20,860
with a single exclamation mark if only

00:23:19,419 --> 00:23:24,280
there was some way we could have

00:23:20,860 --> 00:23:26,200
defended against that and that's why it

00:23:24,280 --> 00:23:27,850
struck me that app security is more than

00:23:26,200 --> 00:23:29,919
the sum of its parts

00:23:27,850 --> 00:23:32,559
with each bit of security you add to

00:23:29,919 --> 00:23:35,380
your app they don't just protect against

00:23:32,559 --> 00:23:37,840
that immediate attack vector they also

00:23:35,380 --> 00:23:40,360
serve as protections for each other

00:23:37,840 --> 00:23:42,610
so the JavaScript obfuscation guards

00:23:40,360 --> 00:23:44,530
this jailbreak detection which joke

00:23:42,610 --> 00:23:47,980
guards against the certificate attack

00:23:44,530 --> 00:23:50,679
and while I've told a lot about hiding

00:23:47,980 --> 00:23:52,270
and obvious skating and mangling you

00:23:50,679 --> 00:23:54,010
know we were not doing these things for

00:23:52,270 --> 00:23:56,830
us or our product owners we're doing it

00:23:54,010 --> 00:24:00,730
for our users and it's a great show of

00:23:56,830 --> 00:24:03,030
faith in us when someone installs our

00:24:00,730 --> 00:24:05,880
app and uses it and

00:24:03,030 --> 00:24:09,570
I can't think of any better way to

00:24:05,880 --> 00:24:12,420
reward that faith than to secure their

00:24:09,570 --> 00:24:13,710
privacy so I've got me worth one sprint

00:24:12,420 --> 00:24:15,900
hasn't it hasn't it

00:24:13,710 --> 00:24:18,320
okay that's kind of all for me today so

00:24:15,900 --> 00:24:23,339
thank you very much for listening

00:24:18,320 --> 00:24:23,339

YouTube URL: https://www.youtube.com/watch?v=CwFD_Eb_0Qo


