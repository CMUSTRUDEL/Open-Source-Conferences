Title: Migrating a RN app from REST to GraphQL - React Native London - January 2020
Publication date: 2020-02-25
Playlist: React Native London
Description: 
	Migrating your RN app to GraphQL - by Abbie Howell

In this talk, we will learn the benefits of GraphQL, a powerful query language for your API, and we will see practical examples and the difficulties that can arise with migrating an existing React Native application to GraphQL. Expect to go away from this talk knowing why to use GraphQL, how to use it, and how to avoid the common pitfalls.
_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:04,879
a little bit about me very quickly I

00:00:02,030 --> 00:00:09,570
work at Theo doe which is a web

00:00:04,879 --> 00:00:12,330
consultancy company I am a full-stack

00:00:09,570 --> 00:00:15,990
developer we do mainly react apps and

00:00:12,330 --> 00:00:19,080
react native websites and mainly John go

00:00:15,990 --> 00:00:21,930
back in but we do a wide range and I'm

00:00:19,080 --> 00:00:25,170
also the co-founder of embolden her

00:00:21,930 --> 00:00:27,779
which is a initiative for women in tech

00:00:25,170 --> 00:00:30,960
to help them to become leaders in tech

00:00:27,779 --> 00:00:36,390
we've run events every month and we also

00:00:30,960 --> 00:00:38,879
have a coffee network which is which I

00:00:36,390 --> 00:00:43,260
run and it's for linking up women in

00:00:38,879 --> 00:00:45,780
tech in London so how many of you have

00:00:43,260 --> 00:00:50,399
used graph girl before quite a lot of

00:00:45,780 --> 00:00:53,430
you that's great so yeah I'll just

00:00:50,399 --> 00:00:55,949
briefly say what it is so a

00:00:53,430 --> 00:00:57,600
specification for api's it lets the

00:00:55,949 --> 00:00:58,050
client specify exactly what date your

00:00:57,600 --> 00:01:00,300
needs

00:00:58,050 --> 00:01:02,940
makes easier to aggregate data from

00:01:00,300 --> 00:01:06,030
multiple sources and it uses a type

00:01:02,940 --> 00:01:10,710
system to describe the data and it's

00:01:06,030 --> 00:01:14,130
widely used in the industry so why

00:01:10,710 --> 00:01:16,140
should we use graph QL well it's a pair

00:01:14,130 --> 00:01:18,270
developer experience we don't have to

00:01:16,140 --> 00:01:21,090
create a new endpoint for every query

00:01:18,270 --> 00:01:27,330
that we create it's got a clearly

00:01:21,090 --> 00:01:29,280
defined schema so you sorry yeah it's

00:01:27,330 --> 00:01:31,619
got a clear clearly defined schema it's

00:01:29,280 --> 00:01:33,780
got a shed you can have a shared API

00:01:31,619 --> 00:01:39,000
between your legacy systems micro

00:01:33,780 --> 00:01:42,030
services third party API etc and the

00:01:39,000 --> 00:01:44,790
main benefit that I see for with working

00:01:42,030 --> 00:01:46,770
with react native is that we avoid over

00:01:44,790 --> 00:01:49,860
and under fetching which I will go into

00:01:46,770 --> 00:01:51,570
more in a moment but this is really good

00:01:49,860 --> 00:01:55,439
for mobile devices where they might have

00:01:51,570 --> 00:01:58,530
limited network connection or not enough

00:01:55,439 --> 00:02:00,360
data so it's really helpful there to

00:01:58,530 --> 00:02:04,110
limit the amount of data that you're

00:02:00,360 --> 00:02:08,459
using so I'm going to quickly run

00:02:04,110 --> 00:02:11,340
through an example of a REST API and why

00:02:08,459 --> 00:02:13,640
it would have been better to use a graph

00:02:11,340 --> 00:02:18,180
QL API

00:02:13,640 --> 00:02:23,160
so in this example we're looking at a

00:02:18,180 --> 00:02:25,050
message board and we've got we're going

00:02:23,160 --> 00:02:27,030
on to the user profile page we want to

00:02:25,050 --> 00:02:29,730
get information about that user just

00:02:27,030 --> 00:02:32,520
their name and then we want to get the

00:02:29,730 --> 00:02:35,010
title of all of their posts and we want

00:02:32,520 --> 00:02:37,670
to get the names of their first three

00:02:35,010 --> 00:02:40,920
followers so with the general REST API

00:02:37,670 --> 00:02:43,350
you might be hitting a user end point to

00:02:40,920 --> 00:02:45,900
get all the data about the user and you

00:02:43,350 --> 00:02:47,340
can see we get their name but we also

00:02:45,900 --> 00:02:49,320
get their address and their birthday

00:02:47,340 --> 00:02:53,100
information that's not relevant to what

00:02:49,320 --> 00:02:56,780
we need on the page then you have to

00:02:53,100 --> 00:02:59,490
make another query to get the

00:02:56,780 --> 00:03:01,740
information about the posts and you get

00:02:59,490 --> 00:03:05,790
you just wanted the title but you end up

00:03:01,740 --> 00:03:09,930
getting the title the content and all of

00:03:05,790 --> 00:03:12,690
the comments and then you might hit the

00:03:09,930 --> 00:03:15,030
end point to get the followers and you

00:03:12,690 --> 00:03:17,130
get all this information about the

00:03:15,030 --> 00:03:18,690
followers that you don't need and every

00:03:17,130 --> 00:03:22,170
single follower you might have just

00:03:18,690 --> 00:03:25,560
wanted the last three followers so with

00:03:22,170 --> 00:03:30,210
a graph QL API we can send the query

00:03:25,560 --> 00:03:33,690
structured exactly how we want it and we

00:03:30,210 --> 00:03:35,730
tell it we want the name we want the

00:03:33,690 --> 00:03:37,530
title of the post and we want the last

00:03:35,730 --> 00:03:41,130
three followers just their names

00:03:37,530 --> 00:03:43,320
it means we only have to make one query

00:03:41,130 --> 00:03:45,750
and we get exactly the amount of data

00:03:43,320 --> 00:03:51,000
that we want avoiding over fetching and

00:03:45,750 --> 00:03:53,240
under fetching so this is the way that

00:03:51,000 --> 00:03:57,480
you interact with graph QL there's one

00:03:53,240 --> 00:04:02,610
endpoint that you send your query to or

00:03:57,480 --> 00:04:06,150
your mutation to and it works like that

00:04:02,610 --> 00:04:09,030
so so you can see the difference here

00:04:06,150 --> 00:04:11,130
the way that you define your queries is

00:04:09,030 --> 00:04:13,920
using this schema definition language

00:04:11,130 --> 00:04:16,950
it's like a syntax that you define the

00:04:13,920 --> 00:04:20,520
API with everything is a type or which

00:04:16,950 --> 00:04:23,790
is could be a query or a mutation and it

00:04:20,520 --> 00:04:26,490
is like a concise way of defining every

00:04:23,790 --> 00:04:30,930
possible use case of your API

00:04:26,490 --> 00:04:35,820
oh I did have a yes I have this simple

00:04:30,930 --> 00:04:38,070
example I don't know why I think it's

00:04:35,820 --> 00:04:39,570
because quick times it's like faded out

00:04:38,070 --> 00:04:43,110
the side of the screen so I hope you can

00:04:39,570 --> 00:04:48,240
still read what's going on but you can

00:04:43,110 --> 00:04:52,290
have enum types we've got like a main to

00:04:48,240 --> 00:04:54,390
do type here and the query type which

00:04:52,290 --> 00:04:56,700
has the different queries that you can

00:04:54,390 --> 00:05:00,660
do which of the two do query and not get

00:04:56,700 --> 00:05:03,270
all to dude and then we define their

00:05:00,660 --> 00:05:05,490
mutations that you can do and basically

00:05:03,270 --> 00:05:07,620
it concisely defines the schema and it

00:05:05,490 --> 00:05:10,830
means that they you can use tools to see

00:05:07,620 --> 00:05:13,610
all the different ways that you can use

00:05:10,830 --> 00:05:17,310
your API very concisely

00:05:13,610 --> 00:05:19,380
so yeah the top-level types are the

00:05:17,310 --> 00:05:22,110
query type and the mutation type and

00:05:19,380 --> 00:05:27,120
these are analogous to get an post in a

00:05:22,110 --> 00:05:30,420
REST API but yeah and then the way that

00:05:27,120 --> 00:05:35,580
it's resolved on the back end it's like

00:05:30,420 --> 00:05:37,890
a tree structure where you where the

00:05:35,580 --> 00:05:40,070
back end will resolve your query it will

00:05:37,890 --> 00:05:43,440
split it into its base components and

00:05:40,070 --> 00:05:46,610
resolve each part individually so it

00:05:43,440 --> 00:05:49,410
means like you don't have to write a new

00:05:46,610 --> 00:05:51,810
resolver for every time you have a new

00:05:49,410 --> 00:05:54,270
use case for your API you don't have to

00:05:51,810 --> 00:05:56,490
write a new endpoint that's gonna give

00:05:54,270 --> 00:06:01,200
the date that you need you can just send

00:05:56,490 --> 00:06:03,690
the query in whatever format and if it's

00:06:01,200 --> 00:06:05,820
in the correct format then your back end

00:06:03,690 --> 00:06:07,530
will know how to handle it I just

00:06:05,820 --> 00:06:10,680
briefly talked about graph care and its

00:06:07,530 --> 00:06:12,960
benefits and I'm now going to talk about

00:06:10,680 --> 00:06:15,270
an existing react native app and how we

00:06:12,960 --> 00:06:19,050
went about migrating it to use graph QL

00:06:15,270 --> 00:06:22,850
and we decided to use Apollo client for

00:06:19,050 --> 00:06:27,150
the front end for the react native app

00:06:22,850 --> 00:06:28,650
there's like a lot of different graph

00:06:27,150 --> 00:06:32,090
kale clients out there that you can use

00:06:28,650 --> 00:06:37,650
but we decided to use Apollo because

00:06:32,090 --> 00:06:39,330
it's like built for use with reacts it

00:06:37,650 --> 00:06:41,220
gives you a lot of freedom

00:06:39,330 --> 00:06:45,300
in what you do with it and the

00:06:41,220 --> 00:06:46,919
documentation is quite good and another

00:06:45,300 --> 00:06:51,389
benefit of Apollo that we didn't end up

00:06:46,919 --> 00:06:55,080
using for this project is the state

00:06:51,389 --> 00:06:58,020
management that comes with free with it

00:06:55,080 --> 00:07:01,020
which is really handy but yeah we didn't

00:06:58,020 --> 00:07:02,939
ended up using it in the end so I'm

00:07:01,020 --> 00:07:05,960
going to talk about an app that I've

00:07:02,939 --> 00:07:11,370
worked on it was a healthcare app for

00:07:05,960 --> 00:07:14,039
practitioners to log events about things

00:07:11,370 --> 00:07:15,960
that their patients have done and to log

00:07:14,039 --> 00:07:20,789
the progress towards the goals and it

00:07:15,960 --> 00:07:22,770
had a REST API the app could not be used

00:07:20,789 --> 00:07:24,419
offline at all which was a big problem

00:07:22,770 --> 00:07:27,870
because all of the care centers had

00:07:24,419 --> 00:07:30,960
terrible Wi-Fi and terrible signal and

00:07:27,870 --> 00:07:32,490
we wanted to have offline capability and

00:07:30,960 --> 00:07:35,460
that's something that graph cure helped

00:07:32,490 --> 00:07:37,729
us to be able to do we also wanted to

00:07:35,460 --> 00:07:39,689
make a family version of the app where

00:07:37,729 --> 00:07:43,949
friends and family members of the

00:07:39,689 --> 00:07:45,599
patients could see what their friends

00:07:43,949 --> 00:07:48,360
and family members have been doing in

00:07:45,599 --> 00:07:49,909
the center's and go after your help with

00:07:48,360 --> 00:07:52,710
that as well which I'm going to go into

00:07:49,909 --> 00:07:53,729
so it's a very simple app I've drawn

00:07:52,710 --> 00:07:57,089
some wireframes

00:07:53,729 --> 00:08:00,960
to demonstrate but this very simple app

00:07:57,089 --> 00:08:03,060
is only like five pages so here we've

00:08:00,960 --> 00:08:04,500
got like a login page we've got a

00:08:03,060 --> 00:08:06,800
timeline view where you can see a

00:08:04,500 --> 00:08:11,370
timeline of all the events that you're

00:08:06,800 --> 00:08:15,259
that the customer has done and then we

00:08:11,370 --> 00:08:18,169
have these three pages that are for

00:08:15,259 --> 00:08:21,449
creating they're used for creating

00:08:18,169 --> 00:08:24,389
editing and viewing the events that have

00:08:21,449 --> 00:08:26,699
happened so you've got the cosmic

00:08:24,389 --> 00:08:29,190
selection page where you pick which

00:08:26,699 --> 00:08:33,000
customers are were involved with the

00:08:29,190 --> 00:08:34,860
event then sorry which patients were

00:08:33,000 --> 00:08:37,620
involved with the event then you fill in

00:08:34,860 --> 00:08:40,349
the event details here and then you've

00:08:37,620 --> 00:08:44,760
got the goal details page where you put

00:08:40,349 --> 00:08:47,160
in which of the which of the goals that

00:08:44,760 --> 00:08:50,640
the patient has were related to the

00:08:47,160 --> 00:08:51,930
event so like this grows across and you

00:08:50,640 --> 00:08:53,820
can select different customer

00:08:51,930 --> 00:08:55,770
that were involved and then this grows

00:08:53,820 --> 00:08:59,420
across so you can add extra information

00:08:55,770 --> 00:09:02,160
about multiple goals for each customer

00:08:59,420 --> 00:09:03,510
so yeah very simple out but not very

00:09:02,160 --> 00:09:06,390
much to it

00:09:03,510 --> 00:09:09,120
but the fact that these three pages this

00:09:06,390 --> 00:09:11,550
flow is used for both viewing and

00:09:09,120 --> 00:09:16,709
editing and creating moments made a bit

00:09:11,550 --> 00:09:19,830
more complicated so we decided to go

00:09:16,709 --> 00:09:21,690
with a gradual approach as it's like

00:09:19,830 --> 00:09:25,560
quite a small app with not many pages

00:09:21,690 --> 00:09:28,910
you might think that we could do the

00:09:25,560 --> 00:09:32,250
conversion from rest to graph to our API

00:09:28,910 --> 00:09:36,149
all at once but still it's like

00:09:32,250 --> 00:09:38,160
dangerous to do that and yeah my

00:09:36,149 --> 00:09:41,399
introduced bugs so the good thing about

00:09:38,160 --> 00:09:43,459
this was that graph grow the way we did

00:09:41,399 --> 00:09:46,500
it allowed us to do it gradually

00:09:43,459 --> 00:09:50,209
incremental e change in like one page at

00:09:46,500 --> 00:09:56,580
a time so yeah we initially started with

00:09:50,209 --> 00:09:58,140
the timeline page and initially there

00:09:56,580 --> 00:10:00,209
was like lots of different endpoints

00:09:58,140 --> 00:10:04,709
that were being hit on this page to get

00:10:00,209 --> 00:10:07,529
the icons for the users and the all the

00:10:04,709 --> 00:10:10,040
data to display on the timeline and then

00:10:07,529 --> 00:10:15,810
we were able to get rid of all of those

00:10:10,040 --> 00:10:18,060
and just use the graph QL endpoint use

00:10:15,810 --> 00:10:22,670
just one query for this page to get all

00:10:18,060 --> 00:10:22,670
the day that we needed and that was that

00:10:22,940 --> 00:10:30,240
then we went on to convert these pages

00:10:26,730 --> 00:10:31,760
as well and yeah it was very

00:10:30,240 --> 00:10:35,310
straightforward

00:10:31,760 --> 00:10:38,130
so yeah setting up a pull out for graph

00:10:35,310 --> 00:10:43,260
QL for react me it was very simple we

00:10:38,130 --> 00:10:46,680
just went from this as our bootstrap to

00:10:43,260 --> 00:10:50,220
this you're just importing a Palo client

00:10:46,680 --> 00:10:53,279
and wrapping your your root of your app

00:10:50,220 --> 00:10:54,870
in it it's very straightforward and then

00:10:53,279 --> 00:11:00,600
to use it it's very very straightforward

00:10:54,870 --> 00:11:04,740
as well you can just write your query or

00:11:00,600 --> 00:11:05,460
your mutation so this is a mutation you

00:11:04,740 --> 00:11:09,480
import

00:11:05,460 --> 00:11:11,970
Groff girl from Apollo boo and just wrap

00:11:09,480 --> 00:11:15,120
your query in that and then you just use

00:11:11,970 --> 00:11:16,320
the user mutation hook and it's very

00:11:15,120 --> 00:11:18,360
straightforward it gives you the method

00:11:16,320 --> 00:11:20,339
to call the mutation and it and a

00:11:18,360 --> 00:11:24,839
loading prop and there's some other

00:11:20,339 --> 00:11:28,320
props that you can get as well and then

00:11:24,839 --> 00:11:31,920
for the query is just as simple you can

00:11:28,320 --> 00:11:33,720
get the loading error and data yeah you

00:11:31,920 --> 00:11:36,390
just usually use query hooks that comes

00:11:33,720 --> 00:11:48,149
from walk you out Apollo it's very

00:11:36,390 --> 00:11:52,440
straightforward I mean it's just a much

00:11:48,149 --> 00:11:57,000
simpler API when you use the hooks

00:11:52,440 --> 00:11:58,950
coming from Apollo rather than the older

00:11:57,000 --> 00:12:02,399
API this is like the more up-to-date

00:11:58,950 --> 00:12:04,770
version but I have used it without hooks

00:12:02,399 --> 00:12:07,589
on a previous project a react project

00:12:04,770 --> 00:12:10,940
and yeah it was just a lot more verbose

00:12:07,589 --> 00:12:15,330
and harder to understand the code I

00:12:10,940 --> 00:12:19,490
think this way is better so why did this

00:12:15,330 --> 00:12:25,620
help with our offline capability well

00:12:19,490 --> 00:12:28,410
the good thing about Apollo is that or

00:12:25,620 --> 00:12:31,740
graph QL is that you have this fetch

00:12:28,410 --> 00:12:33,900
policy prop that you can tell for each

00:12:31,740 --> 00:12:37,020
for each individual query or mutation

00:12:33,900 --> 00:12:39,270
you do you can tell it if you want it to

00:12:37,020 --> 00:12:42,240
be cash first which means it will check

00:12:39,270 --> 00:12:44,420
if it's cashed and use the cached

00:12:42,240 --> 00:12:46,980
version otherwise it will make the query

00:12:44,420 --> 00:12:49,410
then there's like cash and network which

00:12:46,980 --> 00:12:52,140
means it's going to use the cached

00:12:49,410 --> 00:12:54,089
version of the data Rufus there straight

00:12:52,140 --> 00:12:55,589
away so it's very quick for the users to

00:12:54,089 --> 00:12:57,360
get the information but then it will

00:12:55,589 --> 00:12:59,760
also make the network call to refresh

00:12:57,360 --> 00:13:01,500
the data that's in the cache then

00:12:59,760 --> 00:13:03,089
there's like network only if you want it

00:13:01,500 --> 00:13:07,670
to always be the most up-to-date version

00:13:03,089 --> 00:13:10,649
and then there's no cache which is like

00:13:07,670 --> 00:13:12,839
you use the network call but you also

00:13:10,649 --> 00:13:17,430
don't update the version that's in the

00:13:12,839 --> 00:13:18,760
cache so this came in very handy and

00:13:17,430 --> 00:13:21,190
like the built-in caching that you

00:13:18,760 --> 00:13:24,730
with apollo came in very handy for the

00:13:21,190 --> 00:13:28,480
offline capability for us because they

00:13:24,730 --> 00:13:31,630
didn't want to save data in any readable

00:13:28,480 --> 00:13:36,280
format to the devices as it's like a

00:13:31,630 --> 00:13:38,490
gdpr issue but with this yeah this just

00:13:36,280 --> 00:13:41,680
made it really straightforward and

00:13:38,490 --> 00:13:42,910
compliant in summary like it was much

00:13:41,680 --> 00:13:45,670
easier than we thought would be to

00:13:42,910 --> 00:13:48,220
migrate and doing it incrementing

00:13:45,670 --> 00:13:51,430
incremental even that it didn't impact

00:13:48,220 --> 00:13:55,710
the development speed and we got no more

00:13:51,430 --> 00:13:59,230
complaints about bad signal from the

00:13:55,710 --> 00:14:04,480
support workers in the sinners and yeah

00:13:59,230 --> 00:14:06,880
caching really helped with that so yeah

00:14:04,480 --> 00:14:08,740
this was about how we did it on the

00:14:06,880 --> 00:14:11,890
front end very straightforward on the

00:14:08,740 --> 00:14:14,590
back end we had django django back-end

00:14:11,890 --> 00:14:16,450
and it was a bit more complex than this

00:14:14,590 --> 00:14:19,150
but still like very straightforward

00:14:16,450 --> 00:14:24,370
maybe something I would talk about in

00:14:19,150 --> 00:14:26,260
future yeah so we wanted to have the

00:14:24,370 --> 00:14:27,940
queries working offline but not the

00:14:26,260 --> 00:14:32,610
mutations because we didn't want to have

00:14:27,940 --> 00:14:38,650
to store the data on the device before

00:14:32,610 --> 00:14:42,630
they get the signal but it is possible

00:14:38,650 --> 00:14:47,040
there's Apollo retry links which will

00:14:42,630 --> 00:14:49,750
basically cache the request and retry it

00:14:47,040 --> 00:14:51,640
when there's signal and then there's

00:14:49,750 --> 00:14:54,840
also some like link queue libraries

00:14:51,640 --> 00:14:57,340
online that you can use for with Apollo

00:14:54,840 --> 00:14:59,650
that will just like queue up all of your

00:14:57,340 --> 00:15:01,660
requests until you get signal and we

00:14:59,650 --> 00:15:03,070
also didn't really use the state

00:15:01,660 --> 00:15:06,310
management stuff that would have been

00:15:03,070 --> 00:15:09,580
quite helpful because we were a limited

00:15:06,310 --> 00:15:11,830
time on the project but yeah you can

00:15:09,580 --> 00:15:17,890
read a bye on the Apollo graph dots

00:15:11,830 --> 00:15:19,750
that's it so and take another talk from

00:15:17,890 --> 00:15:22,570
the front-end perspective it's amazing

00:15:19,750 --> 00:15:24,820
right but if you already have a backends

00:15:22,570 --> 00:15:27,450
which already exposes the restful api

00:15:24,820 --> 00:15:30,820
how do we enable graph QL

00:15:27,450 --> 00:15:32,110
it depends like is it your own back-end

00:15:30,820 --> 00:15:35,980
that you have access to or is it like

00:15:32,110 --> 00:15:38,500
yeah a one that was going to be the

00:15:35,980 --> 00:15:41,200
process of migration yeah you've got any

00:15:38,500 --> 00:15:45,340
tools which can actually map an existing

00:15:41,200 --> 00:15:48,550
relational database so you can like use

00:15:45,340 --> 00:15:50,560
any database it doesn't matter but it

00:15:48,550 --> 00:15:57,400
doesn't like impacts whether you can use

00:15:50,560 --> 00:15:59,800
graph corral but like yeah we did we we

00:15:57,400 --> 00:16:02,560
had the restful api in our django

00:15:59,800 --> 00:16:05,160
back-end initially and then we converted

00:16:02,560 --> 00:16:08,620
to using graph qo instead of rest and

00:16:05,160 --> 00:16:11,560
it's just a case of like we just have

00:16:08,620 --> 00:16:14,380
the one view which pointing that graph

00:16:11,560 --> 00:16:17,650
QL and then you have to write some

00:16:14,380 --> 00:16:23,170
resolver functions for specific types

00:16:17,650 --> 00:16:25,420
like graph QL types but yeah you can do

00:16:23,170 --> 00:16:28,540
that incrementally as well you can keep

00:16:25,420 --> 00:16:31,740
your but the resolver functions can do

00:16:28,540 --> 00:16:45,970
things like wearing the database or

00:16:31,740 --> 00:16:48,490
getting data from elsewhere no you just

00:16:45,970 --> 00:16:50,500
have the one yeah it means like there's

00:16:48,490 --> 00:16:56,500
tools like graphical that you can use in

00:16:50,500 --> 00:16:58,330
it's like it does I've forgotten the

00:16:56,500 --> 00:17:02,140
name for it but like it does a special

00:16:58,330 --> 00:17:03,880
type of query which tells gives back

00:17:02,140 --> 00:17:06,310
like all the information about all the

00:17:03,880 --> 00:17:08,710
different end points all the different

00:17:06,310 --> 00:17:10,660
types of queries and mutations that are

00:17:08,710 --> 00:17:13,600
supported by your API and then you can

00:17:10,660 --> 00:17:15,940
use graphical to like generate mutations

00:17:13,600 --> 00:17:18,910
and test them out and things it's really

00:17:15,940 --> 00:17:21,640
cool like it's a tool in the browser to

00:17:18,910 --> 00:17:23,680
do this and yeah things like that

00:17:21,640 --> 00:17:28,420
wouldn't work if you had it split

00:17:23,680 --> 00:17:31,080
between multiple different ones yes okay

00:17:28,420 --> 00:17:37,360
so your first question was about

00:17:31,080 --> 00:17:40,070
downsides yeah I'm not sure really if

00:17:37,360 --> 00:17:44,030
there's any that I can think of

00:17:40,070 --> 00:17:46,070
they probably are I just much prefer it

00:17:44,030 --> 00:17:50,180
I think it's like a better developer

00:17:46,070 --> 00:17:53,450
experience and less wasteful in terms of

00:17:50,180 --> 00:17:57,740
the amount of queries you're making the

00:17:53,450 --> 00:17:59,720
second question yes so when do you know

00:17:57,740 --> 00:18:02,900
how to when to use the cash or to

00:17:59,720 --> 00:18:05,930
actually make the request so yeah for

00:18:02,900 --> 00:18:08,840
each like it depends on like the use

00:18:05,930 --> 00:18:13,460
case right so if you're looking at a

00:18:08,840 --> 00:18:15,500
page that's you've got data that really

00:18:13,460 --> 00:18:17,600
needs to be the most up-to-date thing

00:18:15,500 --> 00:18:21,200
like for example like a banking

00:18:17,600 --> 00:18:23,480
application you can make that query be

00:18:21,200 --> 00:18:26,000
network only and it will never use the

00:18:23,480 --> 00:18:27,860
cache and it will always get the date

00:18:26,000 --> 00:18:32,270
are straight away if it's something

00:18:27,860 --> 00:18:35,330
that's less critical like I can't think

00:18:32,270 --> 00:18:38,450
of an example right now but sorry yeah

00:18:35,330 --> 00:18:40,210
like a profile page or something yeah

00:18:38,450 --> 00:18:44,060
you can use cache first and it will

00:18:40,210 --> 00:18:46,430
check if it's cached and if it is yeah

00:18:44,060 --> 00:18:50,180
you can do it on like a query by quick

00:18:46,430 --> 00:18:51,440
query basis like it's not it's you do it

00:18:50,180 --> 00:18:53,960
on the front and when you're making the

00:18:51,440 --> 00:18:55,490
query so even like in different on

00:18:53,960 --> 00:18:58,520
different pages if you're making the

00:18:55,490 --> 00:19:01,100
same query you can have it be cache only

00:18:58,520 --> 00:19:03,200
on one page and you can have it be

00:19:01,100 --> 00:19:05,900
network only on another page it's just

00:19:03,200 --> 00:19:09,050
completely flexible based on your use

00:19:05,900 --> 00:19:13,460
case so can you also perform data

00:19:09,050 --> 00:19:15,620
modifications so yeah it's the same it's

00:19:13,460 --> 00:19:18,080
using the mutation rather than the query

00:19:15,620 --> 00:19:19,670
will perform modifications but it's the

00:19:18,080 --> 00:19:22,420
same sort of way on the back end you

00:19:19,670 --> 00:19:27,830
write resolver functions for your

00:19:22,420 --> 00:19:30,410
mutations which are going to update the

00:19:27,830 --> 00:19:32,660
data in whatever way so if that's like

00:19:30,410 --> 00:19:35,060
making a call to a third party API to

00:19:32,660 --> 00:19:38,270
update something if that's like right

00:19:35,060 --> 00:19:41,450
and data to your database doesn't matter

00:19:38,270 --> 00:19:45,239
what it is cool thank you

00:19:41,450 --> 00:19:45,239

YouTube URL: https://www.youtube.com/watch?v=4WdPanGognY


