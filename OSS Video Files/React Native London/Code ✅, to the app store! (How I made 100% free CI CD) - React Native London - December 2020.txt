Title: Code âœ…, to the app store! (How I made 100% free CI CD) - React Native London - December 2020
Publication date: 2020-12-09
Playlist: React Native London
Description: 
	Paul McCabe

You finished the killer feature on your app, it's gonna make you millions, the code has been committed, huzzah! Now you have all the hassle of building the app and getting it to the app store or testing programs - and you want something a bit more repeatable and professional than an upload from your dev machine. But you also don't want to shell out for expensive Mac build services. What do you do...

Slides:
https://docs.google.com/presentation/d/1ooQHAobrIBdeXhJ6mKzbUmk3S21GQivx5FVyNfY-ek4/edit?usp=sharing

See the Q&A on the original live-stream:
https://youtu.be/EpuABmqyaWU

You can see one of Pauls's previous talks on Skeumorphic Components here:
https://youtu.be/P48t_BDq4qA

He also featured at React Advanced London conference:
https://www.youtube.com/watch?v=QZ66O8QrmfQ 

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:01,120 --> 00:00:05,120
hello everyone and welcome

00:00:03,120 --> 00:00:08,080
thanks for taking the time to see this

00:00:05,120 --> 00:00:10,320
talk uh just to introduce myself

00:00:08,080 --> 00:00:11,599
my name is paul i currently work as a

00:00:10,320 --> 00:00:12,719
principal software engineer for a

00:00:11,599 --> 00:00:14,880
company called anaplan

00:00:12,719 --> 00:00:16,240
uh working on their mobile app and this

00:00:14,880 --> 00:00:18,400
is one of my cats solomon

00:00:16,240 --> 00:00:21,199
uh he might interrupt this talk so i'll

00:00:18,400 --> 00:00:23,920
apologize in advance

00:00:21,199 --> 00:00:24,960
so what is this all about um this is

00:00:23,920 --> 00:00:26,640
about what you do

00:00:24,960 --> 00:00:28,400
when the coding ends you've created this

00:00:26,640 --> 00:00:30,640
amazing app there are dollar signs in

00:00:28,400 --> 00:00:32,640
your eyes now you need to ship it

00:00:30,640 --> 00:00:34,880
i'm going to talk a little about getting

00:00:32,640 --> 00:00:36,719
your hands on mac build hardware without

00:00:34,880 --> 00:00:38,879
breaking the bank

00:00:36,719 --> 00:00:40,160
and a lot about the stuff you need to

00:00:38,879 --> 00:00:43,040
generate and upload

00:00:40,160 --> 00:00:43,440
along with an app and how you can do

00:00:43,040 --> 00:00:46,239
that

00:00:43,440 --> 00:00:47,920
in an automated way to help you deliver

00:00:46,239 --> 00:00:48,559
your code and changes to your users

00:00:47,920 --> 00:00:50,719
visibly

00:00:48,559 --> 00:00:51,920
and quickly while keeping it looking

00:00:50,719 --> 00:00:54,320
great

00:00:51,920 --> 00:00:55,440
and it'll mostly be automated but uh

00:00:54,320 --> 00:00:57,840
more on that later

00:00:55,440 --> 00:00:59,039
you might ask what has this got to do

00:00:57,840 --> 00:01:00,320
with react native

00:00:59,039 --> 00:01:02,719
and it's a question i struggled with

00:01:00,320 --> 00:01:05,280
when i was writing this talk i love

00:01:02,719 --> 00:01:06,799
writing in native i've never had as much

00:01:05,280 --> 00:01:09,840
fun in my career

00:01:06,799 --> 00:01:12,320
as when i'm using this technology

00:01:09,840 --> 00:01:13,760
and part of the reason i think i love it

00:01:12,320 --> 00:01:15,680
is how productive i am

00:01:13,760 --> 00:01:18,080
getting stuff done on multiple platforms

00:01:15,680 --> 00:01:20,159
at once but unless those changes

00:01:18,080 --> 00:01:21,680
are getting to the people using my apps

00:01:20,159 --> 00:01:23,360
i'm not really delivering on that

00:01:21,680 --> 00:01:25,840
productivity

00:01:23,360 --> 00:01:27,200
so i think this stuff goes hand in hand

00:01:25,840 --> 00:01:30,799
with react native

00:01:27,200 --> 00:01:33,119
and in some cases is enabled by it so

00:01:30,799 --> 00:01:34,400
what do we actually need to do when

00:01:33,119 --> 00:01:37,119
we're getting our apps

00:01:34,400 --> 00:01:39,200
out to the app stores obviously creating

00:01:37,119 --> 00:01:40,880
a release of the app is important

00:01:39,200 --> 00:01:43,280
but within that you need to ensure that

00:01:40,880 --> 00:01:44,799
you have set all the build and version

00:01:43,280 --> 00:01:46,159
numbers correctly otherwise your build

00:01:44,799 --> 00:01:48,479
is going to get rejected

00:01:46,159 --> 00:01:49,920
so automating that really helps and not

00:01:48,479 --> 00:01:50,479
doing it manually from your development

00:01:49,920 --> 00:01:52,479
machine

00:01:50,479 --> 00:01:54,000
really stops you from getting some of

00:01:52,479 --> 00:01:55,759
that wrong

00:01:54,000 --> 00:01:57,439
then we have all this media that needs

00:01:55,759 --> 00:01:58,079
to be generated screenshots are a

00:01:57,439 --> 00:01:59,840
requirement

00:01:58,079 --> 00:02:01,759
for both the play store and the apple

00:01:59,840 --> 00:02:04,320
app store even if they have

00:02:01,759 --> 00:02:06,079
slightly different specs if you have

00:02:04,320 --> 00:02:07,600
users in different countries

00:02:06,079 --> 00:02:10,560
then you might also need to be

00:02:07,600 --> 00:02:13,040
generating these once for each language

00:02:10,560 --> 00:02:14,879
with multiple sizes needed for apple

00:02:13,040 --> 00:02:17,360
that can scale up in terms of work

00:02:14,879 --> 00:02:18,959
quickly if you're a huge company with a

00:02:17,360 --> 00:02:21,520
dedicated branding team

00:02:18,959 --> 00:02:23,360
uh maybe that's okay but when i'm a soul

00:02:21,520 --> 00:02:23,760
dev trying to get my own app out there

00:02:23,360 --> 00:02:26,879
it

00:02:23,760 --> 00:02:28,239
really isn't and you have the same issue

00:02:26,879 --> 00:02:30,400
with any videos

00:02:28,239 --> 00:02:32,319
of the app you want to provide and you

00:02:30,400 --> 00:02:35,200
do want to provide a video if you

00:02:32,319 --> 00:02:36,080
want to get featured on the app store or

00:02:35,200 --> 00:02:38,480
um

00:02:36,080 --> 00:02:39,760
get people to take your app seriously so

00:02:38,480 --> 00:02:41,599
lots to do

00:02:39,760 --> 00:02:43,599
um i thought i finished coding the app

00:02:41,599 --> 00:02:45,519
why am i not rich yet

00:02:43,599 --> 00:02:47,360
doing all this stuff every time you want

00:02:45,519 --> 00:02:48,640
to ship a new app version not only takes

00:02:47,360 --> 00:02:50,400
loads of time

00:02:48,640 --> 00:02:52,160
but that's a lot of places where you can

00:02:50,400 --> 00:02:53,040
get a process wrong or introduce human

00:02:52,160 --> 00:02:54,959
error

00:02:53,040 --> 00:02:57,920
so what i want to advocate is really

00:02:54,959 --> 00:03:01,519
automating as much as we humanly can

00:02:57,920 --> 00:03:02,720
and doing it as part of our ci cd

00:03:01,519 --> 00:03:04,959
pipelines we

00:03:02,720 --> 00:03:06,319
hopefully already have in most modern

00:03:04,959 --> 00:03:08,319
software projects

00:03:06,319 --> 00:03:10,640
and i mean this not just for companies

00:03:08,319 --> 00:03:13,519
but i'm a huge believer in doing it

00:03:10,640 --> 00:03:14,959
for my smaller personal projects this

00:03:13,519 --> 00:03:17,280
talk is based around an app

00:03:14,959 --> 00:03:18,319
i maintain for helping people play board

00:03:17,280 --> 00:03:20,480
games

00:03:18,319 --> 00:03:21,840
the game is called warhammer underworlds

00:03:20,480 --> 00:03:23,040
and the app is called underworld's

00:03:21,840 --> 00:03:25,840
helper

00:03:23,040 --> 00:03:26,720
it has one developer it is completely

00:03:25,840 --> 00:03:29,360
open source

00:03:26,720 --> 00:03:29,840
but every upload to the app store comes

00:03:29,360 --> 00:03:32,159
through

00:03:29,840 --> 00:03:33,599
a ci pipeline that runs when i push my

00:03:32,159 --> 00:03:37,200
deploy branch

00:03:33,599 --> 00:03:39,519
remotely as a loan dev

00:03:37,200 --> 00:03:40,640
i don't have bags of cash to spend on

00:03:39,519 --> 00:03:42,480
fancy build servers

00:03:40,640 --> 00:03:44,879
and we know we're going to need some mac

00:03:42,480 --> 00:03:46,080
hardware to build and deliver those ios

00:03:44,879 --> 00:03:49,280
apps

00:03:46,080 --> 00:03:51,280
there are some options though travis ci

00:03:49,280 --> 00:03:53,519
used to provide completely free mac

00:03:51,280 --> 00:03:55,439
build hardware for open source projects

00:03:53,519 --> 00:03:58,799
if your github repo was public you were

00:03:55,439 --> 00:04:01,280
golden sadly that's changed recently

00:03:58,799 --> 00:04:02,000
github itself now provides a really good

00:04:01,280 --> 00:04:04,560
amount of

00:04:02,000 --> 00:04:05,360
free mac build minutes uh with github

00:04:04,560 --> 00:04:08,640
actions

00:04:05,360 --> 00:04:10,480
um both for private and public repos and

00:04:08,640 --> 00:04:13,040
mac stadium one of the big mac clouds

00:04:10,480 --> 00:04:14,959
out there does offer free build time

00:04:13,040 --> 00:04:16,959
for open source projects but you have to

00:04:14,959 --> 00:04:19,120
fill out a form and pray they like you

00:04:16,959 --> 00:04:21,600
enough so

00:04:19,120 --> 00:04:23,680
when i started this app a few years ago

00:04:21,600 --> 00:04:25,280
travis was free so i settled on them but

00:04:23,680 --> 00:04:27,040
i'm actually keen to try moving over to

00:04:25,280 --> 00:04:29,360
get her actions at some point

00:04:27,040 --> 00:04:30,400
and see how that goes but enough about

00:04:29,360 --> 00:04:32,320
release builds

00:04:30,400 --> 00:04:34,000
as i said earlier that's probably a

00:04:32,320 --> 00:04:35,600
different talk

00:04:34,000 --> 00:04:37,600
let's instead turn towards some of the

00:04:35,600 --> 00:04:38,479
cool stuff you need to deliver alongside

00:04:37,600 --> 00:04:40,400
your app

00:04:38,479 --> 00:04:42,080
screenshots can make or break you on the

00:04:40,400 --> 00:04:44,160
app store so

00:04:42,080 --> 00:04:45,360
if we're gonna generate them in an

00:04:44,160 --> 00:04:47,840
automated way

00:04:45,360 --> 00:04:48,560
how can we do it without compromising on

00:04:47,840 --> 00:04:50,240
quality

00:04:48,560 --> 00:04:51,840
if we look at the pay store guidelines

00:04:50,240 --> 00:04:54,080
first

00:04:51,840 --> 00:04:55,680
we see there are a couple of hoops we

00:04:54,080 --> 00:04:58,639
know we're gonna need to jump through

00:04:55,680 --> 00:04:59,040
we need a minimum of two images no more

00:04:58,639 --> 00:05:02,400
than

00:04:59,040 --> 00:05:04,960
two to one aspect ratio um with some

00:05:02,400 --> 00:05:05,759
relaxed release resolutions actually

00:05:04,960 --> 00:05:09,520
however

00:05:05,759 --> 00:05:11,440
apple oh apple we have to deliver

00:05:09,520 --> 00:05:12,240
separate screenshots for the full screen

00:05:11,440 --> 00:05:13,919
iphones

00:05:12,240 --> 00:05:15,280
for iphones with physical home buttons

00:05:13,919 --> 00:05:16,720
and for ipads

00:05:15,280 --> 00:05:18,479
for ipads you actually need to supply

00:05:16,720 --> 00:05:20,320
two sets of images

00:05:18,479 --> 00:05:21,919
but they have the same dimensions so you

00:05:20,320 --> 00:05:24,000
can reuse the same at least

00:05:21,919 --> 00:05:26,160
i don't want to do this manually i don't

00:05:24,000 --> 00:05:27,039
own all the devices as a react native

00:05:26,160 --> 00:05:28,960
dev maybe i'm

00:05:27,039 --> 00:05:30,639
you know working on a linux or windows

00:05:28,960 --> 00:05:31,280
machine so i might not even have access

00:05:30,639 --> 00:05:33,120
to

00:05:31,280 --> 00:05:35,360
simulators there's another great reason

00:05:33,120 --> 00:05:36,639
to shift this into an automated process

00:05:35,360 --> 00:05:39,680
that runs on a build machine

00:05:36,639 --> 00:05:41,440
in a cloud somewhere but how can i

00:05:39,680 --> 00:05:42,080
generate the screenshots i want with my

00:05:41,440 --> 00:05:45,199
app

00:05:42,080 --> 00:05:47,520
in all the different states i want i

00:05:45,199 --> 00:05:49,440
went for appium as my tool of choice

00:05:47,520 --> 00:05:51,199
there are other similar options like

00:05:49,440 --> 00:05:53,600
detox and if you're lucky

00:05:51,199 --> 00:05:55,360
you could even use react native web and

00:05:53,600 --> 00:05:57,360
try automating a web browser with

00:05:55,360 --> 00:05:59,360
puppeteer or another framework

00:05:57,360 --> 00:06:00,800
appium actually uses the same protocol

00:05:59,360 --> 00:06:02,720
as selenium

00:06:00,800 --> 00:06:05,440
and this is a nice standard built around

00:06:02,720 --> 00:06:07,039
http requests to send commands

00:06:05,440 --> 00:06:08,720
so you might already be familiar with

00:06:07,039 --> 00:06:10,720
this kind of system if you

00:06:08,720 --> 00:06:12,240
if you do any web development the idea

00:06:10,720 --> 00:06:14,720
here is to script

00:06:12,240 --> 00:06:15,520
real use of your app actually opening it

00:06:14,720 --> 00:06:18,319
on a device

00:06:15,520 --> 00:06:20,400
navigating screens interacting with it

00:06:18,319 --> 00:06:22,800
and this ability to drive the app

00:06:20,400 --> 00:06:24,479
in a scripted way gives us repeatable

00:06:22,800 --> 00:06:27,919
actions that a

00:06:24,479 --> 00:06:29,680
provide us you know prove to us that our

00:06:27,919 --> 00:06:32,160
app is working the way we intended

00:06:29,680 --> 00:06:32,800
and b give us an opportunity to capture

00:06:32,160 --> 00:06:35,600
the app

00:06:32,800 --> 00:06:36,800
while we're driving it to these states

00:06:35,600 --> 00:06:38,479
what does this look like for our rec

00:06:36,800 --> 00:06:40,880
native app

00:06:38,479 --> 00:06:41,919
this is a typical setup on the left we

00:06:40,880 --> 00:06:43,759
have a test runner

00:06:41,919 --> 00:06:45,199
where we can put the logic that drives

00:06:43,759 --> 00:06:47,039
the app

00:06:45,199 --> 00:06:48,800
this will talk to our app via an appium

00:06:47,039 --> 00:06:50,080
server which we'll need to launch

00:06:48,800 --> 00:06:51,919
beforehand

00:06:50,080 --> 00:06:53,919
the appium server in turn is going to

00:06:51,919 --> 00:06:55,599
talk to our device or simulator as

00:06:53,919 --> 00:06:58,080
appropriate

00:06:55,599 --> 00:06:59,680
when running a test we provide appium

00:06:58,080 --> 00:07:01,759
with the desired set of what they call

00:06:59,680 --> 00:07:02,960
capabilities and this is really a

00:07:01,759 --> 00:07:05,840
description of the

00:07:02,960 --> 00:07:07,039
device we want to run the test on and it

00:07:05,840 --> 00:07:10,080
includes the location

00:07:07,039 --> 00:07:11,840
of our app appium takes care of

00:07:10,080 --> 00:07:13,919
installing our app on the device

00:07:11,840 --> 00:07:16,000
and it also installs a second app on

00:07:13,919 --> 00:07:18,000
there the web driver agent

00:07:16,000 --> 00:07:19,840
and this is where the magic happens the

00:07:18,000 --> 00:07:22,240
web driver and our app are signed

00:07:19,840 --> 00:07:24,800
similarly during the install process

00:07:22,240 --> 00:07:26,720
and this lets the webdriver agent which

00:07:24,800 --> 00:07:28,000
is going to receive commands from the

00:07:26,720 --> 00:07:29,599
appium server

00:07:28,000 --> 00:07:31,280
interact with our app in ways that are

00:07:29,599 --> 00:07:31,919
normally restricted to the operating

00:07:31,280 --> 00:07:34,479
system

00:07:31,919 --> 00:07:37,120
and native thresholding frameworks like

00:07:34,479 --> 00:07:39,759
xc ui test or espresso

00:07:37,120 --> 00:07:42,160
now we can start sending commands like

00:07:39,759 --> 00:07:43,759
find this element or input text or press

00:07:42,160 --> 00:07:44,879
that button and we can do that from our

00:07:43,759 --> 00:07:46,800
test

00:07:44,879 --> 00:07:48,160
we can even interact with biometrics on

00:07:46,800 --> 00:07:50,160
simulators and emulators which is

00:07:48,160 --> 00:07:52,879
actually really cool

00:07:50,160 --> 00:07:53,360
and given what we've just described so

00:07:52,879 --> 00:07:54,479
far

00:07:53,360 --> 00:07:56,080
you can imagine that this could be

00:07:54,479 --> 00:07:57,840
scaled out so we can run these tests

00:07:56,080 --> 00:07:58,879
against all device form factors that

00:07:57,840 --> 00:08:01,840
we're interested in

00:07:58,879 --> 00:08:03,120
together though in reality you are more

00:08:01,840 --> 00:08:04,080
likely to end up with something that

00:08:03,120 --> 00:08:05,440
looks like this

00:08:04,080 --> 00:08:07,199
if you want to go down that

00:08:05,440 --> 00:08:08,639
parallelizing route i found there are

00:08:07,199 --> 00:08:10,720
issues with trying to run multiple

00:08:08,639 --> 00:08:12,000
devices from one appium server

00:08:10,720 --> 00:08:14,319
though in theory you should be able to

00:08:12,000 --> 00:08:15,840
do it these days um and you can use

00:08:14,319 --> 00:08:16,160
selenium grid if you're familiar with

00:08:15,840 --> 00:08:19,199
that

00:08:16,160 --> 00:08:19,759
i believe but let's stick with the basic

00:08:19,199 --> 00:08:21,599
case

00:08:19,759 --> 00:08:23,039
you know we can always run our tests one

00:08:21,599 --> 00:08:25,520
by one and

00:08:23,039 --> 00:08:26,080
parallelize later and let's finally look

00:08:25,520 --> 00:08:27,759
at some code

00:08:26,080 --> 00:08:29,520
for this as this is for a react native

00:08:27,759 --> 00:08:31,280
app i prefer to keep as much of my code

00:08:29,520 --> 00:08:33,440
in javascript or typescript

00:08:31,280 --> 00:08:34,880
as possible and in this case i'm using

00:08:33,440 --> 00:08:37,440
jest as my testrunner

00:08:34,880 --> 00:08:38,959
we need to ensure we have appium and

00:08:37,440 --> 00:08:41,279
webdriver client installed

00:08:38,959 --> 00:08:42,719
i chose webdriverio for my webdriver

00:08:41,279 --> 00:08:44,640
client

00:08:42,719 --> 00:08:46,240
there are other options and we need to

00:08:44,640 --> 00:08:47,920
start our appium server you'll notice

00:08:46,240 --> 00:08:48,160
i'm installing it locally and starting

00:08:47,920 --> 00:08:50,080
it

00:08:48,160 --> 00:08:52,000
from within my node modules this is

00:08:50,080 --> 00:08:53,680
because i'm expecting this to be run on

00:08:52,000 --> 00:08:55,120
a ci server at some point

00:08:53,680 --> 00:08:57,120
and the more dependencies i can

00:08:55,120 --> 00:08:58,959
encapsulate in my project the less i

00:08:57,120 --> 00:08:59,519
have to worry about the state of the

00:08:58,959 --> 00:09:02,480
server

00:08:59,519 --> 00:09:04,480
and what comes pre-installed on it plus

00:09:02,480 --> 00:09:05,200
most ci systems offer some form of

00:09:04,480 --> 00:09:07,040
caching

00:09:05,200 --> 00:09:09,279
so if i cache my node modules i get the

00:09:07,040 --> 00:09:11,600
appium install cached for free

00:09:09,279 --> 00:09:13,600
and then i'm running my tests though i'm

00:09:11,600 --> 00:09:15,519
setting an environment variable for each

00:09:13,600 --> 00:09:17,040
test with the name of the device i want

00:09:15,519 --> 00:09:18,720
to run on it it's a nice way to

00:09:17,040 --> 00:09:21,360
parameterize jess tests

00:09:18,720 --> 00:09:22,080
the actual code isn't necessarily huge

00:09:21,360 --> 00:09:24,800
though this is

00:09:22,080 --> 00:09:26,880
a noddy example i would advocate using

00:09:24,800 --> 00:09:28,240
the page object model if you're really

00:09:26,880 --> 00:09:29,839
going to do all of this

00:09:28,240 --> 00:09:31,680
where you model each screen in your app

00:09:29,839 --> 00:09:33,440
as a class and make

00:09:31,680 --> 00:09:36,320
the interactions on that screen

00:09:33,440 --> 00:09:38,640
functions that you call on that class

00:09:36,320 --> 00:09:40,720
we know we're going to pick the device

00:09:38,640 --> 00:09:42,800
config based on the environment variable

00:09:40,720 --> 00:09:43,920
and these are the appium capabilities i

00:09:42,800 --> 00:09:46,080
mentioned earlier

00:09:43,920 --> 00:09:47,040
this is what we're asking appium to run

00:09:46,080 --> 00:09:49,600
our test on

00:09:47,040 --> 00:09:50,959
in this case an iphone 11 pro max

00:09:49,600 --> 00:09:52,640
simulator

00:09:50,959 --> 00:09:54,399
and appium will actually launch the

00:09:52,640 --> 00:09:56,160
simulator for us too which is very

00:09:54,399 --> 00:09:58,800
convenient

00:09:56,160 --> 00:10:00,640
before each test we're going to get a

00:09:58,800 --> 00:10:04,320
fresh webdriver io client

00:10:00,640 --> 00:10:06,640
for our given device then in our tests

00:10:04,320 --> 00:10:07,920
we can start issuing commands in this

00:10:06,640 --> 00:10:10,240
case the dollar function

00:10:07,920 --> 00:10:11,760
means select element and the tilde at

00:10:10,240 --> 00:10:15,120
the start of the string

00:10:11,760 --> 00:10:17,519
means select by test id

00:10:15,120 --> 00:10:19,839
here is what the react native codes that

00:10:17,519 --> 00:10:21,600
this is interacting with might look like

00:10:19,839 --> 00:10:22,880
the command will give us back a

00:10:21,600 --> 00:10:25,360
reference to the element

00:10:22,880 --> 00:10:27,440
not a react reference but really just an

00:10:25,360 --> 00:10:28,560
id that appium can use to refer to that

00:10:27,440 --> 00:10:31,360
element

00:10:28,560 --> 00:10:32,000
and we can do things like tap on that

00:10:31,360 --> 00:10:35,839
element with

00:10:32,000 --> 00:10:38,480
the click function and once we are

00:10:35,839 --> 00:10:39,279
on a screen we care about and the app is

00:10:38,480 --> 00:10:41,519
in a state

00:10:39,279 --> 00:10:43,360
we care about we can take a screenshot

00:10:41,519 --> 00:10:45,120
and save it to disk

00:10:43,360 --> 00:10:47,600
the images that this produces are the

00:10:45,120 --> 00:10:49,680
right size for the device it was run on

00:10:47,600 --> 00:10:51,680
great quality and always up to date with

00:10:49,680 --> 00:10:54,079
our app not only that

00:10:51,680 --> 00:10:55,519
but you can pass in the locale in those

00:10:54,079 --> 00:10:56,720
appium capabilities

00:10:55,519 --> 00:10:58,720
so if you need to run your app in

00:10:56,720 --> 00:11:00,640
japanese french german

00:10:58,720 --> 00:11:02,480
it's easy to do no messing around with

00:11:00,640 --> 00:11:05,519
device config settings

00:11:02,480 --> 00:11:06,959
there are trade-offs um for example the

00:11:05,519 --> 00:11:07,760
first time you run it it will take a

00:11:06,959 --> 00:11:10,240
while as

00:11:07,760 --> 00:11:11,120
that webdriver agent app has to be

00:11:10,240 --> 00:11:13,040
compiled

00:11:11,120 --> 00:11:14,720
and on android you have to use a

00:11:13,040 --> 00:11:17,600
different uh prop you have to use

00:11:14,720 --> 00:11:18,880
accessibility label instead of test id

00:11:17,600 --> 00:11:21,600
and the element you are

00:11:18,880 --> 00:11:22,959
setting these on needs to be an actual

00:11:21,600 --> 00:11:24,959
react native one

00:11:22,959 --> 00:11:26,720
uh you can't set test id on one of your

00:11:24,959 --> 00:11:28,079
own components and expect appium to find

00:11:26,720 --> 00:11:30,160
it you'll need to pass that

00:11:28,079 --> 00:11:32,720
down to a text or view inside your

00:11:30,160 --> 00:11:34,399
component for example

00:11:32,720 --> 00:11:36,880
it's also not really appropriate for

00:11:34,399 --> 00:11:39,680
apps that don't have a stable state

00:11:36,880 --> 00:11:40,000
now granted most react native apps tend

00:11:39,680 --> 00:11:42,880
to

00:11:40,000 --> 00:11:44,959
end up in a stable state but if you've

00:11:42,880 --> 00:11:46,640
managed to write a fast-paced 3d game

00:11:44,959 --> 00:11:48,000
this isn't going to work for you

00:11:46,640 --> 00:11:50,560
congratulations for doing that in react

00:11:48,000 --> 00:11:52,639
native i did say we're going to make

00:11:50,560 --> 00:11:54,880
these screenshots look awesome though

00:11:52,639 --> 00:11:56,000
just showing what your app looks like

00:11:54,880 --> 00:11:58,000
isn't going to get you

00:11:56,000 --> 00:11:59,120
those millions of dollars in downloads

00:11:58,000 --> 00:12:01,120
so

00:11:59,120 --> 00:12:02,639
how do we make these screenshots really

00:12:01,120 --> 00:12:04,000
sing

00:12:02,639 --> 00:12:05,519
um i'm going to keep running in

00:12:04,000 --> 00:12:06,399
javascript for as many things as

00:12:05,519 --> 00:12:08,399
possible

00:12:06,399 --> 00:12:10,079
and that includes image manipulation

00:12:08,399 --> 00:12:12,079
sharp is a nifty little library that

00:12:10,079 --> 00:12:13,760
runs in node so we can actually use it

00:12:12,079 --> 00:12:16,160
during the jest tests we were running

00:12:13,760 --> 00:12:18,000
earlier if we want to

00:12:16,160 --> 00:12:19,440
what do i want to do with my screenshots

00:12:18,000 --> 00:12:20,720
um well here's

00:12:19,440 --> 00:12:23,600
what they'll start off looking like for

00:12:20,720 --> 00:12:25,440
my app and the first thing

00:12:23,600 --> 00:12:27,600
i want to do is shrink the screenshot a

00:12:25,440 --> 00:12:28,639
little and put it on a black background

00:12:27,600 --> 00:12:32,720
the same size

00:12:28,639 --> 00:12:34,800
as the original image with the space

00:12:32,720 --> 00:12:37,040
we've now made at the top we can add a

00:12:34,800 --> 00:12:38,560
little context about the scene

00:12:37,040 --> 00:12:40,480
some nice marketing text and a fancy

00:12:38,560 --> 00:12:42,320
font um

00:12:40,480 --> 00:12:44,079
but we're dealing with an image

00:12:42,320 --> 00:12:46,560
manipulation library here

00:12:44,079 --> 00:12:47,279
so um we need to treat the text as an

00:12:46,560 --> 00:12:48,800
image

00:12:47,279 --> 00:12:50,720
and this is where svgs are really

00:12:48,800 --> 00:12:52,639
convenient as before

00:12:50,720 --> 00:12:54,000
we need to make sure we install the

00:12:52,639 --> 00:12:56,160
sharp library

00:12:54,000 --> 00:12:57,360
and as i'm introducing a utility

00:12:56,160 --> 00:12:59,519
function that

00:12:57,360 --> 00:13:01,120
takes an image and adds some text to it

00:12:59,519 --> 00:13:01,680
and we're going to look at the code for

00:13:01,120 --> 00:13:03,920
that

00:13:01,680 --> 00:13:04,959
first we need to read in the image using

00:13:03,920 --> 00:13:07,519
sharp

00:13:04,959 --> 00:13:08,480
and then we want to resize it down in

00:13:07,519 --> 00:13:11,120
this case

00:13:08,480 --> 00:13:12,880
to 80 of its original size we do that by

00:13:11,120 --> 00:13:14,720
grabbing the original width and height

00:13:12,880 --> 00:13:17,920
from the image metadata and multiplying

00:13:14,720 --> 00:13:21,040
it by in this case 0.8

00:13:17,920 --> 00:13:22,560
we'll hold that in a buffer for now

00:13:21,040 --> 00:13:23,920
but when we add it back into the

00:13:22,560 --> 00:13:26,000
original image later we want it to be in

00:13:23,920 --> 00:13:28,079
the middle and at the bottom

00:13:26,000 --> 00:13:30,240
we can do this with this gravity option

00:13:28,079 --> 00:13:32,240
later

00:13:30,240 --> 00:13:33,360
next we'll create the background image

00:13:32,240 --> 00:13:35,200
now for us

00:13:33,360 --> 00:13:36,959
this is just really a big black box and

00:13:35,200 --> 00:13:38,720
it's the same size as the original image

00:13:36,959 --> 00:13:39,519
so again we're using the width and

00:13:38,720 --> 00:13:42,720
height that we got

00:13:39,519 --> 00:13:46,160
from the original image metadata

00:13:42,720 --> 00:13:47,680
next we'll add in the text um i'll dive

00:13:46,160 --> 00:13:50,320
into this a bit deeper

00:13:47,680 --> 00:13:51,040
but it's worth noting at this point that

00:13:50,320 --> 00:13:52,560
we

00:13:51,040 --> 00:13:54,560
have this variable called vertical text

00:13:52,560 --> 00:13:56,959
space which is really just the 20

00:13:54,560 --> 00:13:58,320
of space uh we're going to be left with

00:13:56,959 --> 00:14:00,560
at the top of the image

00:13:58,320 --> 00:14:02,000
we also pass in the original image width

00:14:00,560 --> 00:14:04,160
and height here because

00:14:02,000 --> 00:14:05,199
it's easier to think about the svg layer

00:14:04,160 --> 00:14:07,360
as being the same

00:14:05,199 --> 00:14:09,519
size as the original image at least it

00:14:07,360 --> 00:14:11,199
is for me

00:14:09,519 --> 00:14:14,000
finally we can compose the three images

00:14:11,199 --> 00:14:16,079
together and we can write the result out

00:14:14,000 --> 00:14:17,120
and even overwrite the original image if

00:14:16,079 --> 00:14:18,800
we're feeling brash

00:14:17,120 --> 00:14:20,639
though if you want to do this with

00:14:18,800 --> 00:14:22,560
multiple languages i'd recommend keeping

00:14:20,639 --> 00:14:24,800
the original as is and writing to a new

00:14:22,560 --> 00:14:26,000
file

00:14:24,800 --> 00:14:28,079
i said i'd come back to the svg

00:14:26,000 --> 00:14:31,760
generation as it's kind of interesting

00:14:28,079 --> 00:14:34,639
and so this is our utility function and

00:14:31,760 --> 00:14:36,240
um we passed in that vertical text space

00:14:34,639 --> 00:14:37,839
argument which is the 20

00:14:36,240 --> 00:14:39,440
of space at the top of the image so

00:14:37,839 --> 00:14:40,639
let's ignore the rest of the image for

00:14:39,440 --> 00:14:43,199
now

00:14:40,639 --> 00:14:44,160
within that space at the top we want the

00:14:43,199 --> 00:14:47,279
center

00:14:44,160 --> 00:14:48,000
for the text um so that we can find the

00:14:47,279 --> 00:14:50,720
midpoint

00:14:48,000 --> 00:14:51,920
to put that text in but the text isn't

00:14:50,720 --> 00:14:53,040
always going to be one line

00:14:51,920 --> 00:14:55,199
in this case it's actually going to be

00:14:53,040 --> 00:14:55,680
three lines we get that by breaking the

00:14:55,199 --> 00:14:59,519
text

00:14:55,680 --> 00:15:01,120
on newline characters so

00:14:59,519 --> 00:15:02,800
we want to work out where the first line

00:15:01,120 --> 00:15:04,639
is actually going to start by shifting

00:15:02,800 --> 00:15:06,079
up from that midpoint and you'll notice

00:15:04,639 --> 00:15:07,440
that we're actually separating the

00:15:06,079 --> 00:15:10,800
concept of line height

00:15:07,440 --> 00:15:11,519
and the line itself the line height is

00:15:10,800 --> 00:15:14,480
00:15:11,519 --> 00:15:15,120
bigger than the font size so we're

00:15:14,480 --> 00:15:18,800
shifting

00:15:15,120 --> 00:15:21,040
that up by whatever amount we need to as

00:15:18,800 --> 00:15:24,560
appropriate

00:15:21,040 --> 00:15:27,839
finally we can loop over the lines

00:15:24,560 --> 00:15:29,759
and add text elements to our svg offset

00:15:27,839 --> 00:15:30,959
by the right vertical distance based on

00:15:29,759 --> 00:15:34,000
our line height

00:15:30,959 --> 00:15:34,880
and the index of the line the svg as i

00:15:34,000 --> 00:15:36,560
mentioned earlier

00:15:34,880 --> 00:15:38,480
is actually the same size as our whole

00:15:36,560 --> 00:15:40,160
image so if we get the placement of the

00:15:38,480 --> 00:15:42,240
text right here we don't have to worry

00:15:40,160 --> 00:15:44,480
about positioning the svg later it just

00:15:42,240 --> 00:15:46,639
sits over the whole final image

00:15:44,480 --> 00:15:47,920
great now we can programmatically

00:15:46,639 --> 00:15:49,600
generate our screenshots

00:15:47,920 --> 00:15:51,040
and then add some final polish with some

00:15:49,600 --> 00:15:52,560
marketing text

00:15:51,040 --> 00:15:55,199
and that's a pretty basic version of

00:15:52,560 --> 00:15:57,120
this the sky really is the limit here

00:15:55,199 --> 00:15:58,320
you can do so much more like focusing on

00:15:57,120 --> 00:16:00,399
a particular element

00:15:58,320 --> 00:16:03,440
in fact you can screenshot individual

00:16:00,399 --> 00:16:05,279
elements during the test in appium

00:16:03,440 --> 00:16:07,360
just by selecting an element and calling

00:16:05,279 --> 00:16:10,399
save screenshot on the element

00:16:07,360 --> 00:16:13,120
rather than on the client

00:16:10,399 --> 00:16:14,240
or you can crop the image as needed in

00:16:13,120 --> 00:16:16,240
sharp afterwards

00:16:14,240 --> 00:16:18,560
if you always know where a particular

00:16:16,240 --> 00:16:20,800
element will be in a scene

00:16:18,560 --> 00:16:23,839
or you could do some rotation effects

00:16:20,800 --> 00:16:25,759
composite several scenes together

00:16:23,839 --> 00:16:28,320
instead of a plain background colour you

00:16:25,759 --> 00:16:30,959
could have a nice blurred stock image

00:16:28,320 --> 00:16:32,399
you could add device frames they're

00:16:30,959 --> 00:16:32,880
something that's really popular in a lot

00:16:32,399 --> 00:16:34,880
of

00:16:32,880 --> 00:16:36,000
app store listings it's something you

00:16:34,880 --> 00:16:37,199
can have fun with and

00:16:36,000 --> 00:16:39,120
if you're already using something like

00:16:37,199 --> 00:16:41,440
fast lane there's a utility in that

00:16:39,120 --> 00:16:44,720
called frame it that can help with some

00:16:41,440 --> 00:16:44,720
of this processing too

00:16:44,880 --> 00:16:48,959
great we have our screenshots all up to

00:16:47,120 --> 00:16:50,079
date generated as part of our build

00:16:48,959 --> 00:16:51,759
pipeline

00:16:50,079 --> 00:16:53,440
now we just need to upload them in an

00:16:51,759 --> 00:16:55,680
automated way

00:16:53,440 --> 00:16:57,360
and this is where i have to admit i

00:16:55,680 --> 00:16:59,120
bailed on my own premise

00:16:57,360 --> 00:17:02,160
um i've not had the time to automate the

00:16:59,120 --> 00:17:04,000
uploading yet

00:17:02,160 --> 00:17:05,199
but it is on my list of things to do and

00:17:04,000 --> 00:17:06,880
it isn't too difficult

00:17:05,199 --> 00:17:08,959
so i'm quickly going to run through what

00:17:06,880 --> 00:17:12,799
i intend on doing

00:17:08,959 --> 00:17:15,120
i briefly mentioned uh it before um

00:17:12,799 --> 00:17:17,439
fast lane is a fantastic utility and

00:17:15,120 --> 00:17:19,520
absolutely necessary if you're doing any

00:17:17,439 --> 00:17:20,240
kind of continuous deployment with

00:17:19,520 --> 00:17:22,799
mobile apps

00:17:20,240 --> 00:17:24,880
react native or otherwise really it's a

00:17:22,799 --> 00:17:26,240
huge pile of ruby that some guys at

00:17:24,880 --> 00:17:27,919
google are constantly backwards

00:17:26,240 --> 00:17:29,360
engineering from apple and google's

00:17:27,919 --> 00:17:32,080
private apis it's

00:17:29,360 --> 00:17:34,240
bonkers within fastlane the deliver

00:17:32,080 --> 00:17:35,200
package gives us the ability to upload

00:17:34,240 --> 00:17:37,840
to apple

00:17:35,200 --> 00:17:38,880
not only our apps but also all the

00:17:37,840 --> 00:17:41,280
things that go with an app

00:17:38,880 --> 00:17:43,280
including screenshots and the equivalent

00:17:41,280 --> 00:17:45,360
of deliver in fast lane for android is

00:17:43,280 --> 00:17:47,039
called supply

00:17:45,360 --> 00:17:48,640
it does much the same thing but for

00:17:47,039 --> 00:17:50,960
google's play store

00:17:48,640 --> 00:17:52,240
let's start with supply once you have

00:17:50,960 --> 00:17:54,559
fastlane installed

00:17:52,240 --> 00:17:55,280
you can run supply init which is going

00:17:54,559 --> 00:17:57,679
to bring down

00:17:55,280 --> 00:17:58,799
this folder structure for you picking up

00:17:57,679 --> 00:18:01,039
what you've already got on the play

00:17:58,799 --> 00:18:02,799
store in terms of app metadata

00:18:01,039 --> 00:18:04,559
then we move all the screenshots into

00:18:02,799 --> 00:18:06,880
the various directories

00:18:04,559 --> 00:18:08,320
which are organized by language code

00:18:06,880 --> 00:18:09,039
once you're happy with all the images

00:18:08,320 --> 00:18:11,039
being in place

00:18:09,039 --> 00:18:13,120
you can run supply to upload the

00:18:11,039 --> 00:18:14,080
screenshots and since supply can do all

00:18:13,120 --> 00:18:16,160
your app metadata

00:18:14,080 --> 00:18:18,480
and the app itself you can do this all

00:18:16,160 --> 00:18:20,559
at the same time if you want

00:18:18,480 --> 00:18:22,080
on the ios side deliver works in a very

00:18:20,559 --> 00:18:24,559
similar way

00:18:22,080 --> 00:18:25,840
and you run an init command to download

00:18:24,559 --> 00:18:28,960
all the existing info

00:18:25,840 --> 00:18:30,880
including the existing images you have

00:18:28,960 --> 00:18:32,480
the directory structure is slightly

00:18:30,880 --> 00:18:34,480
different to android one but it

00:18:32,480 --> 00:18:35,679
has the same concept of this language

00:18:34,480 --> 00:18:37,440
code separation

00:18:35,679 --> 00:18:39,679
again we just need to copy all the

00:18:37,440 --> 00:18:41,120
appropriate screenshots into place

00:18:39,679 --> 00:18:42,559
deliver doesn't need different

00:18:41,120 --> 00:18:43,280
resolution images in different

00:18:42,559 --> 00:18:45,280
directories

00:18:43,280 --> 00:18:47,039
or named in any particular way it

00:18:45,280 --> 00:18:48,880
actually uses the resolution

00:18:47,039 --> 00:18:50,880
of the image to work out which device

00:18:48,880 --> 00:18:54,240
it's uploading for and once you're happy

00:18:50,880 --> 00:18:56,320
you run deliver to upload the images

00:18:54,240 --> 00:18:58,559
and if you want you can upload your

00:18:56,320 --> 00:19:02,160
message data and upload your app

00:18:58,559 --> 00:19:03,280
at the same time too now images that are

00:19:02,160 --> 00:19:05,280
localized

00:19:03,280 --> 00:19:06,960
up-to-date and looking professional will

00:19:05,280 --> 00:19:09,039
get you a long way

00:19:06,960 --> 00:19:10,640
but a video can really raise your

00:19:09,039 --> 00:19:11,679
chances of getting people to download

00:19:10,640 --> 00:19:13,760
your app

00:19:11,679 --> 00:19:16,480
is it something that we can automate too

00:19:13,760 --> 00:19:19,679
while keeping that high standard

00:19:16,480 --> 00:19:22,240
um for the google play store your video

00:19:19,679 --> 00:19:24,160
actually needs to be uploaded to youtube

00:19:22,240 --> 00:19:26,400
and you provide the store with a link

00:19:24,160 --> 00:19:28,720
it can't have ads turned on but that's

00:19:26,400 --> 00:19:30,400
about it otherwise it's a pretty relaxed

00:19:28,720 --> 00:19:34,400
set of um

00:19:30,400 --> 00:19:36,480
guidelines to follow for apple devices

00:19:34,400 --> 00:19:38,480
like with the screenshots we need

00:19:36,480 --> 00:19:40,400
multiple videos

00:19:38,480 --> 00:19:41,679
and there are a few more restrictions on

00:19:40,400 --> 00:19:43,840
what we need to deliver

00:19:41,679 --> 00:19:46,000
videos can't be more than 30 seconds

00:19:43,840 --> 00:19:48,720
long and they have to be provided in the

00:19:46,000 --> 00:19:50,720
right format with the right encoding

00:19:48,720 --> 00:19:52,720
and if i have to do different videos in

00:19:50,720 --> 00:19:55,760
different languages for four devices

00:19:52,720 --> 00:19:57,360
that's a lot of manual video editing

00:19:55,760 --> 00:19:59,360
if i want these to be up to date with my

00:19:57,360 --> 00:20:00,799
new app features i'm going to spend more

00:19:59,360 --> 00:20:03,039
time in imovie than i am

00:20:00,799 --> 00:20:04,320
coding features i don't have a marketing

00:20:03,039 --> 00:20:06,559
department

00:20:04,320 --> 00:20:08,159
so i want to automate as much of this as

00:20:06,559 --> 00:20:10,799
i can

00:20:08,159 --> 00:20:11,840
and since we're already diving driving

00:20:10,799 --> 00:20:15,120
our app

00:20:11,840 --> 00:20:18,000
to record screenshots why not record

00:20:15,120 --> 00:20:19,760
a video at the same time appium actually

00:20:18,000 --> 00:20:21,919
provides this functionality to us

00:20:19,760 --> 00:20:24,000
though you have to make sure ffmpeg a

00:20:21,919 --> 00:20:24,559
command line video creation and editing

00:20:24,000 --> 00:20:28,880
tool

00:20:24,559 --> 00:20:32,159
is installed as it's what appium uses

00:20:28,880 --> 00:20:33,840
so this is where we left our test code

00:20:32,159 --> 00:20:36,240
that was driving our app and taking

00:20:33,840 --> 00:20:38,480
screenshots we can add a couple more

00:20:36,240 --> 00:20:40,960
lines here to start recording the video

00:20:38,480 --> 00:20:42,720
and at the end of the test stop the

00:20:40,960 --> 00:20:43,679
video being recorded and save it to a

00:20:42,720 --> 00:20:45,520
file

00:20:43,679 --> 00:20:47,600
and when we start the recording we can

00:20:45,520 --> 00:20:49,840
specify the format and quality we want

00:20:47,600 --> 00:20:52,559
if you're recording videos of you know

00:20:49,840 --> 00:20:54,559
actual say end-to-end tests

00:20:52,559 --> 00:20:55,919
you could easily see what happens when

00:20:54,559 --> 00:20:57,600
they fail

00:20:55,919 --> 00:20:59,600
and you probably don't need super high

00:20:57,600 --> 00:21:00,159
frame rates for that example but in our

00:20:59,600 --> 00:21:01,840
case

00:21:00,159 --> 00:21:03,600
this is supposed to be eye candy for our

00:21:01,840 --> 00:21:06,159
users so we'll go as high as we

00:21:03,600 --> 00:21:08,320
reasonably can in terms of quality

00:21:06,159 --> 00:21:09,280
one more thing to note uh the appium

00:21:08,320 --> 00:21:12,880
docs describe

00:21:09,280 --> 00:21:13,520
a stop recrean stop recording screen

00:21:12,880 --> 00:21:15,440
function

00:21:13,520 --> 00:21:17,520
but here we're using a save recording

00:21:15,440 --> 00:21:20,000
screen function provided by

00:21:17,520 --> 00:21:20,799
webdriverio in this case the big

00:21:20,000 --> 00:21:22,559
difference here

00:21:20,799 --> 00:21:25,679
is stop recording screen returns a

00:21:22,559 --> 00:21:27,280
base64 encoded string of your video data

00:21:25,679 --> 00:21:28,960
which you have to correctly encode and

00:21:27,280 --> 00:21:31,280
write to a file yourself

00:21:28,960 --> 00:21:32,880
save recording screen does that bit for

00:21:31,280 --> 00:21:36,080
you

00:21:32,880 --> 00:21:38,799
um so what are the results of these

00:21:36,080 --> 00:21:40,159
you know two extra lines well the video

00:21:38,799 --> 00:21:41,840
it produces hasn't lived up to my

00:21:40,159 --> 00:21:43,120
expectations if i'm honest

00:21:41,840 --> 00:21:44,880
uh though i'm almost certain it's

00:21:43,120 --> 00:21:47,600
something that i'm doing wrong

00:21:44,880 --> 00:21:49,120
the quality is even lower when i play on

00:21:47,600 --> 00:21:51,440
google slides for some reason

00:21:49,120 --> 00:21:52,559
um but the actual video has these

00:21:51,440 --> 00:21:54,880
artifacts

00:21:52,559 --> 00:21:56,080
when large areas of the screen change

00:21:54,880 --> 00:21:57,679
it's like

00:21:56,080 --> 00:21:59,200
you know when when i navigate between

00:21:57,679 --> 00:22:01,039
screens there

00:21:59,200 --> 00:22:02,880
a lot of pixels are changing it's the

00:22:01,039 --> 00:22:05,840
kind of thing you would see in a badly

00:22:02,880 --> 00:22:08,799
encoded dvd rip from the early noughties

00:22:05,840 --> 00:22:12,080
and the speed of the video doesn't match

00:22:08,799 --> 00:22:13,919
that of the original play through

00:22:12,080 --> 00:22:15,600
isn't lost though um as there are some

00:22:13,919 --> 00:22:17,039
other ways that we can start and stop

00:22:15,600 --> 00:22:19,679
the video capture

00:22:17,039 --> 00:22:22,159
on our devices during your test run on

00:22:19,679 --> 00:22:22,720
ios the simulator control utility which

00:22:22,159 --> 00:22:25,520
is

00:22:22,720 --> 00:22:26,480
similar to adb on android it can be used

00:22:25,520 --> 00:22:29,120
to record

00:22:26,480 --> 00:22:31,039
videos straight off of the simulator

00:22:29,120 --> 00:22:32,400
this works really well and produces a

00:22:31,039 --> 00:22:35,200
high quality video

00:22:32,400 --> 00:22:37,280
you can use child processing nodes to

00:22:35,200 --> 00:22:38,720
kick this off and kill it at the end of

00:22:37,280 --> 00:22:40,880
the recording

00:22:38,720 --> 00:22:42,480
similarly on android adb actually

00:22:40,880 --> 00:22:44,159
provides a screen record command

00:22:42,480 --> 00:22:46,240
though in this case the video will be

00:22:44,159 --> 00:22:48,000
saved on the device even if it's an

00:22:46,240 --> 00:22:48,799
emulator it gets stored on the emulated

00:22:48,000 --> 00:22:50,640
device

00:22:48,799 --> 00:22:52,960
so you also need to extract it

00:22:50,640 --> 00:22:54,320
afterwards and probably remove it to

00:22:52,960 --> 00:22:56,880
keep the space clear

00:22:54,320 --> 00:22:59,280
this video we can already see is much

00:22:56,880 --> 00:23:02,480
higher quality and the speed is the same

00:22:59,280 --> 00:23:05,600
as what we what actually happened

00:23:02,480 --> 00:23:08,159
during the test run though it's worth

00:23:05,600 --> 00:23:10,000
noting that if you leave it running with

00:23:08,159 --> 00:23:11,360
nothing happening on screen

00:23:10,000 --> 00:23:12,960
and then stop the recording this

00:23:11,360 --> 00:23:14,320
technique will end up with all that

00:23:12,960 --> 00:23:17,120
waiting time being cut

00:23:14,320 --> 00:23:17,600
this is because the codec used ignores

00:23:17,120 --> 00:23:19,760
when

00:23:17,600 --> 00:23:20,640
there are no changes in the video not a

00:23:19,760 --> 00:23:22,320
biggie but

00:23:20,640 --> 00:23:24,640
worth being aware of for the end of your

00:23:22,320 --> 00:23:26,400
video as it will end abruptly after the

00:23:24,640 --> 00:23:28,960
last movement on screen

00:23:26,400 --> 00:23:31,120
while a high quality video of us tapping

00:23:28,960 --> 00:23:32,720
around the app is pretty cool

00:23:31,120 --> 00:23:35,039
we did say we were going to make it look

00:23:32,720 --> 00:23:36,720
great and more importantly

00:23:35,039 --> 00:23:39,039
it can't be more than 30 seconds for

00:23:36,720 --> 00:23:40,960
apple at the moment i've got about two

00:23:39,039 --> 00:23:42,880
minutes of video that needs cutting down

00:23:40,960 --> 00:23:44,400
to the good bits

00:23:42,880 --> 00:23:46,880
and this is where i have to make another

00:23:44,400 --> 00:23:49,600
one of those guilty admissions

00:23:46,880 --> 00:23:50,960
i currently manually edit my videos for

00:23:49,600 --> 00:23:53,120
this app

00:23:50,960 --> 00:23:55,520
i do it in imovie and i have to do it

00:23:53,120 --> 00:23:56,880
multiple times once for each device

00:23:55,520 --> 00:23:58,240
i don't currently support other

00:23:56,880 --> 00:24:00,640
languages in this app so i don't have to

00:23:58,240 --> 00:24:02,320
do it tens of times for each language

00:24:00,640 --> 00:24:03,679
but i do want to support more languages

00:24:02,320 --> 00:24:07,279
in the future

00:24:03,679 --> 00:24:08,799
i also add arty subtitles and

00:24:07,279 --> 00:24:11,360
you know to describe what's going on in

00:24:08,799 --> 00:24:14,400
each point in the video and nice music

00:24:11,360 --> 00:24:17,279
and and that makes this a manual process

00:24:14,400 --> 00:24:18,400
that is a huge no-no for a proper

00:24:17,279 --> 00:24:21,520
one-man shop

00:24:18,400 --> 00:24:22,640
i only update this app twice a year um

00:24:21,520 --> 00:24:24,640
but if you're on your own

00:24:22,640 --> 00:24:26,960
or even a small company with global

00:24:24,640 --> 00:24:29,600
ambitions and you want to release often

00:24:26,960 --> 00:24:30,320
this could be a real issue not only that

00:24:29,600 --> 00:24:33,039
but

00:24:30,320 --> 00:24:34,960
doing stuff in imovie always outputs at

00:24:33,039 --> 00:24:36,640
1080 by 1920.

00:24:34,960 --> 00:24:38,559
so i also lose one of the huge

00:24:36,640 --> 00:24:39,200
advantages of screen recordings from

00:24:38,559 --> 00:24:42,480
devices

00:24:39,200 --> 00:24:44,320
the correct aspect ratio well correcting

00:24:42,480 --> 00:24:45,039
the videos i produce in imovie is

00:24:44,320 --> 00:24:47,360
something that i

00:24:45,039 --> 00:24:48,960
can script at least a quick look at the

00:24:47,360 --> 00:24:51,919
apple specs tells me

00:24:48,960 --> 00:24:52,400
what i actually need i need to crop the

00:24:51,919 --> 00:24:55,200
video

00:24:52,400 --> 00:24:55,840
to get it to get rid of that wide screen

00:24:55,200 --> 00:24:58,000
space

00:24:55,840 --> 00:24:58,960
and scale it to what the app store

00:24:58,000 --> 00:25:01,679
requires

00:24:58,960 --> 00:25:04,559
and we already have ffmpeg installed and

00:25:01,679 --> 00:25:06,480
it lets us crop the video quite easily

00:25:04,559 --> 00:25:08,159
all we need are the width and height of

00:25:06,480 --> 00:25:11,360
the area to crop to

00:25:08,159 --> 00:25:13,520
and also the top left corner

00:25:11,360 --> 00:25:15,440
to start that crop from the ffmpeg

00:25:13,520 --> 00:25:18,159
command is pretty readable

00:25:15,440 --> 00:25:19,919
and we're just passing in the video some

00:25:18,159 --> 00:25:21,679
variables and telling it where to write

00:25:19,919 --> 00:25:23,600
to

00:25:21,679 --> 00:25:24,960
now we're left with just our mobile

00:25:23,600 --> 00:25:27,279
screen

00:25:24,960 --> 00:25:29,360
we next need to get the scale right

00:25:27,279 --> 00:25:31,279
again the ffmpeg command

00:25:29,360 --> 00:25:33,360
is fairly readable i'm just setting the

00:25:31,279 --> 00:25:36,240
new scale with what is

00:25:33,360 --> 00:25:37,679
required by the apple spec for a given

00:25:36,240 --> 00:25:40,240
device

00:25:37,679 --> 00:25:42,080
and that's it two commands and our video

00:25:40,240 --> 00:25:43,760
is back to being in the right format

00:25:42,080 --> 00:25:46,400
and ready to be uploaded to the app

00:25:43,760 --> 00:25:48,400
store here's what the commands look like

00:25:46,400 --> 00:25:49,919
when i'm running on the console

00:25:48,400 --> 00:25:51,120
i check them into my repair so i don't

00:25:49,919 --> 00:25:51,919
lose them for next time but you'll

00:25:51,120 --> 00:25:53,679
notice

00:25:51,919 --> 00:25:55,600
some funny numbers in those crop

00:25:53,679 --> 00:25:56,960
commands how do i work out

00:25:55,600 --> 00:25:59,760
what areas of the screen i need to crop

00:25:56,960 --> 00:26:01,760
to well i actually did by eye

00:25:59,760 --> 00:26:04,080
with some trial and error it doesn't

00:26:01,760 --> 00:26:05,039
take long and once i had the values

00:26:04,080 --> 00:26:06,559
right

00:26:05,039 --> 00:26:08,320
they're fine to reuse again and again

00:26:06,559 --> 00:26:10,240
year after year and

00:26:08,320 --> 00:26:12,320
i'm sure someone cleverer than i am

00:26:10,240 --> 00:26:14,080
could have done the maths

00:26:12,320 --> 00:26:16,240
and worked all out but it doesn't really

00:26:14,080 --> 00:26:17,520
matter if i'm out by a pixel or two as

00:26:16,240 --> 00:26:19,679
long as i get rid of all of the

00:26:17,520 --> 00:26:21,360
widescreen black space the scale command

00:26:19,679 --> 00:26:24,720
is going to make everything

00:26:21,360 --> 00:26:27,840
you know look pretty correct at the end

00:26:24,720 --> 00:26:31,279
uh a quick note on background music the

00:26:27,840 --> 00:26:33,600
sound effects you know that i add to the

00:26:31,279 --> 00:26:35,279
video and the music that i add

00:26:33,600 --> 00:26:36,640
i want it to be something that's

00:26:35,279 --> 00:26:38,880
professional and

00:26:36,640 --> 00:26:40,480
you know that someone is is going to

00:26:38,880 --> 00:26:41,120
want to hear when they're watching the

00:26:40,480 --> 00:26:43,120
video

00:26:41,120 --> 00:26:46,559
and this is actually pretty easy to do

00:26:43,120 --> 00:26:48,400
um i get my music from freesound.org

00:26:46,559 --> 00:26:50,080
where you can find loads of free

00:26:48,400 --> 00:26:52,480
material to use you just have to abide

00:26:50,080 --> 00:26:53,039
by the licenses on the file often this

00:26:52,480 --> 00:26:55,279
just means

00:26:53,039 --> 00:26:56,640
including a credit to the artist which i

00:26:55,279 --> 00:26:58,000
add to the app store listing

00:26:56,640 --> 00:26:59,840
and also to the youtube video

00:26:58,000 --> 00:27:02,159
description if i upload it there

00:26:59,840 --> 00:27:03,120
um here's a little snip of the audio i

00:27:02,159 --> 00:27:07,840
chose to use

00:27:03,120 --> 00:27:07,840
for the underworlds helper app video

00:27:13,410 --> 00:27:18,790
[Music]

00:27:15,100 --> 00:27:22,960
[Applause]

00:27:18,790 --> 00:27:26,080
[Music]

00:27:22,960 --> 00:27:26,880
so manually casting the video multiple

00:27:26,080 --> 00:27:29,279
videos

00:27:26,880 --> 00:27:30,480
manually editing sound manually

00:27:29,279 --> 00:27:32,960
uploading

00:27:30,480 --> 00:27:35,200
i don't want to keep doing this so let

00:27:32,960 --> 00:27:38,480
me show you what i'm planning to do next

00:27:35,200 --> 00:27:40,240
in my automation journey with video

00:27:38,480 --> 00:27:41,760
our recording might be a few minutes

00:27:40,240 --> 00:27:43,440
long um

00:27:41,760 --> 00:27:45,840
but we just want the best 30 seconds of

00:27:43,440 --> 00:27:48,000
that and it likely isn't continuous so

00:27:45,840 --> 00:27:50,640
how do we programmatically cut the right

00:27:48,000 --> 00:27:51,120
bits well the only point we actually

00:27:50,640 --> 00:27:52,720
know

00:27:51,120 --> 00:27:55,600
what is happening on screen at a given

00:27:52,720 --> 00:27:58,880
moment is during the original test run

00:27:55,600 --> 00:28:01,200
so that is the best time for us to

00:27:58,880 --> 00:28:02,159
mark these so we can cut the video into

00:28:01,200 --> 00:28:05,200
individual clips

00:28:02,159 --> 00:28:05,679
later if we go back again to our test

00:28:05,200 --> 00:28:07,360
code

00:28:05,679 --> 00:28:09,279
it's actually fairly easy to record this

00:28:07,360 --> 00:28:10,640
information we just need to add a couple

00:28:09,279 --> 00:28:13,440
more lines to

00:28:10,640 --> 00:28:14,720
you know record first the initial start

00:28:13,440 --> 00:28:16,960
time of the video

00:28:14,720 --> 00:28:18,399
and at this point i'm also introducing a

00:28:16,960 --> 00:28:21,360
structure for us to record

00:28:18,399 --> 00:28:23,120
timings of individual clips into and

00:28:21,360 --> 00:28:24,640
when there's an interesting interaction

00:28:23,120 --> 00:28:27,520
about to happen that we want in our

00:28:24,640 --> 00:28:31,039
final video we can mark the times

00:28:27,520 --> 00:28:33,279
um at the end of the interaction

00:28:31,039 --> 00:28:36,000
we can push the start time and the end

00:28:33,279 --> 00:28:38,159
time into our eclipse array

00:28:36,000 --> 00:28:40,320
and using these timestamps we can cut

00:28:38,159 --> 00:28:42,320
the clip later

00:28:40,320 --> 00:28:43,600
as we add more clips to the structure it

00:28:42,320 --> 00:28:45,840
grows and

00:28:43,600 --> 00:28:48,799
at the end of the test we can save the

00:28:45,840 --> 00:28:51,279
json to another file alongside the video

00:28:48,799 --> 00:28:52,559
now you could if you wanted just record

00:28:51,279 --> 00:28:54,480
each interaction

00:28:52,559 --> 00:28:56,000
uh you know as its own clip so you don't

00:28:54,480 --> 00:28:57,679
have to cut them up later

00:28:56,000 --> 00:29:00,000
but due to what i said before about the

00:28:57,679 --> 00:29:02,559
video recording cutting abruptly

00:29:00,000 --> 00:29:04,000
if there were any more interaction if

00:29:02,559 --> 00:29:05,760
there weren't any more interactions

00:29:04,000 --> 00:29:07,120
i personally found it easier to manage

00:29:05,760 --> 00:29:11,039
this with one

00:29:07,120 --> 00:29:13,279
long video that i'd chop up as needed

00:29:11,039 --> 00:29:16,159
i can add padding time around my clips

00:29:13,279 --> 00:29:19,120
more easily if i want to this way

00:29:16,159 --> 00:29:19,840
now i have my video file and my timings

00:29:19,120 --> 00:29:21,760
file but

00:29:19,840 --> 00:29:23,120
how do i actually operate on the video

00:29:21,760 --> 00:29:24,799
file based on this

00:29:23,120 --> 00:29:27,120
well we already saw a tool for scripted

00:29:24,799 --> 00:29:28,720
video editing we used ffmpeg earlier for

00:29:27,120 --> 00:29:32,080
cropping and scaling the videos

00:29:28,720 --> 00:29:33,520
that we got out of imovie um so instead

00:29:32,080 --> 00:29:35,279
we can use it here

00:29:33,520 --> 00:29:37,120
for chopping up our video into the clips

00:29:35,279 --> 00:29:38,559
we care about

00:29:37,120 --> 00:29:40,399
actually cutting the clips out is pretty

00:29:38,559 --> 00:29:41,840
easy we can loop over the clips array in

00:29:40,399 --> 00:29:44,799
our json and

00:29:41,840 --> 00:29:46,000
make this ffmpeg command finding the

00:29:44,799 --> 00:29:47,840
start time of each clip

00:29:46,000 --> 00:29:49,279
relative to the start of the video and

00:29:47,840 --> 00:29:52,080
the duration of the clip by taking its

00:29:49,279 --> 00:29:54,559
start time from its end time

00:29:52,080 --> 00:29:55,440
now i've got lots of short videos rather

00:29:54,559 --> 00:29:58,080
than one long one

00:29:55,440 --> 00:29:59,760
um so let's stitch them back together we

00:29:58,080 --> 00:30:02,240
want to do this in a lossless way and

00:29:59,760 --> 00:30:05,440
the ffmpeg docs recommend converting

00:30:02,240 --> 00:30:08,720
our mpeg4 to mpeg2 this is because

00:30:05,440 --> 00:30:10,320
mpeg4 is very clever has all sorts of

00:30:08,720 --> 00:30:11,919
interesting things like seek points

00:30:10,320 --> 00:30:14,399
encoded into it

00:30:11,919 --> 00:30:16,000
whereas mpeg2 you can literally

00:30:14,399 --> 00:30:16,720
concatenate the bytes of two files

00:30:16,000 --> 00:30:19,840
together

00:30:16,720 --> 00:30:22,080
and get seamless video so for a quick

00:30:19,840 --> 00:30:22,880
ffmpeg command to turn each clip into an

00:30:22,080 --> 00:30:25,919
intermediate

00:30:22,880 --> 00:30:28,480
mpeg-2 file is needed here

00:30:25,919 --> 00:30:30,159
for those wondering the dot ts file

00:30:28,480 --> 00:30:32,000
extension here stands for video

00:30:30,159 --> 00:30:33,840
transport stream

00:30:32,000 --> 00:30:36,480
which is the mpeg2 format it doesn't

00:30:33,840 --> 00:30:38,880
stand for typescript file

00:30:36,480 --> 00:30:40,240
finally we concatenate them back

00:30:38,880 --> 00:30:42,960
together with another simple

00:30:40,240 --> 00:30:44,640
ffmpeg command and re-encode the whole

00:30:42,960 --> 00:30:45,840
thing back to mp4

00:30:44,640 --> 00:30:47,760
there's probably a way to do this

00:30:45,840 --> 00:30:49,520
without the intermediate files ffmpeg

00:30:47,760 --> 00:30:51,360
can work on many streams

00:30:49,520 --> 00:30:52,960
at a time so again if you're cleverer

00:30:51,360 --> 00:30:54,640
than me you can probably work out

00:30:52,960 --> 00:30:58,080
something a little more elegant here

00:30:54,640 --> 00:31:00,880
what about transitions um

00:30:58,080 --> 00:31:02,399
just gluing our clips together might be

00:31:00,880 --> 00:31:05,360
jarring for someone

00:31:02,399 --> 00:31:07,440
watching the video um and in imovie i

00:31:05,360 --> 00:31:08,640
used a zoom blur transition to hide

00:31:07,440 --> 00:31:11,200
where i glued the clips together

00:31:08,640 --> 00:31:12,000
and you know to let the person watching

00:31:11,200 --> 00:31:14,320
it

00:31:12,000 --> 00:31:15,840
know hey the next thing you're going to

00:31:14,320 --> 00:31:18,240
see is going to be different

00:31:15,840 --> 00:31:19,600
so can we do something similar on the

00:31:18,240 --> 00:31:20,880
command line

00:31:19,600 --> 00:31:22,960
that's probably a little ambitious to

00:31:20,880 --> 00:31:23,600
try and achieve the same transition as a

00:31:22,960 --> 00:31:26,320
mature

00:31:23,600 --> 00:31:27,120
tool as imovie we could happily get away

00:31:26,320 --> 00:31:29,679
with a flash

00:31:27,120 --> 00:31:30,960
or fading in and out but i put a bit of

00:31:29,679 --> 00:31:33,760
thought into how

00:31:30,960 --> 00:31:35,120
i would script that zoom blur transition

00:31:33,760 --> 00:31:37,039
using

00:31:35,120 --> 00:31:39,600
the zoom pan and directional blur

00:31:37,039 --> 00:31:41,519
filters in ffmpeg

00:31:39,600 --> 00:31:42,640
imagine we have our two clips that we

00:31:41,519 --> 00:31:44,720
want to join

00:31:42,640 --> 00:31:47,600
i need the 500 milliseconds at the end

00:31:44,720 --> 00:31:49,760
of the first and the start of the second

00:31:47,600 --> 00:31:50,960
on this little section of video i need

00:31:49,760 --> 00:31:53,039
to apply my filters

00:31:50,960 --> 00:31:54,880
on the first 500 milliseconds i'm going

00:31:53,039 --> 00:31:55,440
to zoom in and apply the directional

00:31:54,880 --> 00:31:57,919
blur

00:31:55,440 --> 00:31:59,039
over time increasing the zoom and

00:31:57,919 --> 00:32:01,279
intensity of the blur

00:31:59,039 --> 00:32:02,559
and maybe changing the angle of the blur

00:32:01,279 --> 00:32:04,640
direction too

00:32:02,559 --> 00:32:05,840
on the second 500 milliseconds i need to

00:32:04,640 --> 00:32:08,799
do the reverse

00:32:05,840 --> 00:32:09,519
zooming back out and reducing the blur

00:32:08,799 --> 00:32:11,279
i've not

00:32:09,519 --> 00:32:12,960
tried doing this yet but i think it

00:32:11,279 --> 00:32:14,720
could be fun to play around with

00:32:12,960 --> 00:32:16,240
and it really gets me thinking about

00:32:14,720 --> 00:32:18,799
what i can and can't achieve with these

00:32:16,240 --> 00:32:21,519
command line tools

00:32:18,799 --> 00:32:23,279
what about adding text into our videos

00:32:21,519 --> 00:32:25,360
to let the person watching

00:32:23,279 --> 00:32:27,039
know what's going on or how can they

00:32:25,360 --> 00:32:29,679
interact with the app

00:32:27,039 --> 00:32:31,600
well earlier we marked when interesting

00:32:29,679 --> 00:32:33,200
things were happening during our tests

00:32:31,600 --> 00:32:36,320
and i think that's also the right time

00:32:33,200 --> 00:32:38,399
to describe what's happening in the app

00:32:36,320 --> 00:32:39,600
you know for that given clip if we want

00:32:38,399 --> 00:32:41,600
to add that description

00:32:39,600 --> 00:32:43,360
in text to the video then this is a good

00:32:41,600 --> 00:32:43,919
time to make sure that we've got that

00:32:43,360 --> 00:32:46,720
text

00:32:43,919 --> 00:32:48,080
down so back to the test code one last

00:32:46,720 --> 00:32:50,480
time i promise

00:32:48,080 --> 00:32:53,279
when we were here last we introduced

00:32:50,480 --> 00:32:56,000
this metadata for each clip

00:32:53,279 --> 00:32:57,600
now we can modify the code so that along

00:32:56,000 --> 00:33:00,399
with the timing of the clip

00:32:57,600 --> 00:33:02,080
we add the text that we will add into

00:33:00,399 --> 00:33:05,440
the video

00:33:02,080 --> 00:33:07,519
all we're really doing here is pushing

00:33:05,440 --> 00:33:09,600
one extra string into the structure

00:33:07,519 --> 00:33:11,279
in my case i went with the text that

00:33:09,600 --> 00:33:13,279
will end up in the video but you could

00:33:11,279 --> 00:33:14,080
equally just put an id here if you want

00:33:13,279 --> 00:33:16,399
to keep

00:33:14,080 --> 00:33:19,279
the actual text uh you know separate in

00:33:16,399 --> 00:33:22,640
a translations provider for example

00:33:19,279 --> 00:33:24,080
and so this is what i end up with in my

00:33:22,640 --> 00:33:26,240
video timings json file

00:33:24,080 --> 00:33:27,279
with the clip text being alongside the

00:33:26,240 --> 00:33:30,159
start and end time

00:33:27,279 --> 00:33:32,320
of the clip great we've got the text we

00:33:30,159 --> 00:33:34,240
know which clips to go with

00:33:32,320 --> 00:33:36,799
but just throwing text up into a clip is

00:33:34,240 --> 00:33:39,600
boring we we can do better

00:33:36,799 --> 00:33:40,159
in imovie i use this fun text effect

00:33:39,600 --> 00:33:42,799
with

00:33:40,159 --> 00:33:43,440
kind of falling and fading going on

00:33:42,799 --> 00:33:44,880
again

00:33:43,440 --> 00:33:46,480
it would be more than good enough to

00:33:44,880 --> 00:33:49,440
have our text fade in

00:33:46,480 --> 00:33:52,640
or move in from one side but can we

00:33:49,440 --> 00:33:55,039
replicate this nice effect too

00:33:52,640 --> 00:33:56,720
there is a draw text filter in ffmpeg

00:33:55,039 --> 00:33:58,480
that does let us put text in the video

00:33:56,720 --> 00:34:00,559
and control some aspects of it like

00:33:58,480 --> 00:34:03,120
moving it over time

00:34:00,559 --> 00:34:04,720
we know how long our clip is and we can

00:34:03,120 --> 00:34:06,960
put our text in the central section of

00:34:04,720 --> 00:34:08,960
that without too much hassle so it's not

00:34:06,960 --> 00:34:10,960
right up at the edges of our time it'll

00:34:08,960 --> 00:34:13,040
just come in after you know half second

00:34:10,960 --> 00:34:15,599
and leave you know a second before the

00:34:13,040 --> 00:34:15,599
end of the clip

00:34:15,760 --> 00:34:19,040
but when we take a closer look at what's

00:34:18,240 --> 00:34:22,480
going on

00:34:19,040 --> 00:34:24,320
you know with this imovie uh effect

00:34:22,480 --> 00:34:26,079
we can see the first character of each

00:34:24,320 --> 00:34:26,560
word acts differently to the rest of the

00:34:26,079 --> 00:34:28,639
word

00:34:26,560 --> 00:34:31,040
so for each word i need to break it in

00:34:28,639 --> 00:34:31,760
two then perform two animations on each

00:34:31,040 --> 00:34:33,839
of those bits

00:34:31,760 --> 00:34:35,760
not to mention position each one of them

00:34:33,839 --> 00:34:38,960
correctly in the video

00:34:35,760 --> 00:34:40,480
i'm sure this is all doable and i found

00:34:38,960 --> 00:34:42,960
some encouraging info

00:34:40,480 --> 00:34:43,760
on how to move text over time in some

00:34:42,960 --> 00:34:46,320
stackover

00:34:43,760 --> 00:34:47,440
overflow comments but the positioning

00:34:46,320 --> 00:34:50,320
scares me a little

00:34:47,440 --> 00:34:50,800
on top of the transform for opacity in

00:34:50,320 --> 00:34:54,159
and out

00:34:50,800 --> 00:34:57,200
and you know the the translation

00:34:54,159 --> 00:34:59,440
of position i think

00:34:57,200 --> 00:35:01,280
placement might be easier using

00:34:59,440 --> 00:35:04,720
something like svg manipulation

00:35:01,280 --> 00:35:06,720
i imagine uh cutting different svgs

00:35:04,720 --> 00:35:08,000
for each character or each run of

00:35:06,720 --> 00:35:10,560
characters

00:35:08,000 --> 00:35:12,079
and each svg uh would be the same width

00:35:10,560 --> 00:35:12,880
and height as the original video like we

00:35:12,079 --> 00:35:15,440
were doing with

00:35:12,880 --> 00:35:16,160
the screenshots i think this will let us

00:35:15,440 --> 00:35:18,400
um

00:35:16,160 --> 00:35:20,880
get each bit of text that needs to be

00:35:18,400 --> 00:35:22,480
animating into the right place initially

00:35:20,880 --> 00:35:24,720
and then we can apply transforms to each

00:35:22,480 --> 00:35:26,560
of them individually

00:35:24,720 --> 00:35:29,200
over time and overlay the resulting

00:35:26,560 --> 00:35:30,640
videos on top of each other

00:35:29,200 --> 00:35:32,880
now this is where my brain has gotten to

00:35:30,640 --> 00:35:34,400
with this one but i'm keen to you know

00:35:32,880 --> 00:35:36,800
find the time to try and make it work at

00:35:34,400 --> 00:35:39,920
some point

00:35:36,800 --> 00:35:42,560
a quick note on adding the audio again

00:35:39,920 --> 00:35:45,040
it's very quick and an easily

00:35:42,560 --> 00:35:46,800
understandable ffmpeg command here

00:35:45,040 --> 00:35:49,359
in this case i've had an argument to

00:35:46,800 --> 00:35:50,720
shorten the audio so it's no longer than

00:35:49,359 --> 00:35:52,560
the video i'm adding it to

00:35:50,720 --> 00:35:53,920
as i'm adding the audio at the end of

00:35:52,560 --> 00:35:55,760
the process

00:35:53,920 --> 00:35:58,000
i'm not going to linger on this you know

00:35:55,760 --> 00:36:00,480
you can find out how to do

00:35:58,000 --> 00:36:03,520
fade in and fade out on audio and ffmpeg

00:36:00,480 --> 00:36:03,520
quite easily online

00:36:04,320 --> 00:36:07,359
now let's talk about getting these

00:36:05,520 --> 00:36:08,240
beautiful masterpieces that we've

00:36:07,359 --> 00:36:10,400
created

00:36:08,240 --> 00:36:11,839
on the command line in an automated way

00:36:10,400 --> 00:36:14,960
in theory

00:36:11,839 --> 00:36:16,560
uploaded in an automated way we used

00:36:14,960 --> 00:36:17,680
deliver and supply to get our apps

00:36:16,560 --> 00:36:20,079
screenshots up

00:36:17,680 --> 00:36:22,000
and i had hoped that we could do the

00:36:20,079 --> 00:36:24,079
same thing for our videos

00:36:22,000 --> 00:36:25,440
alas neither of them can help us here

00:36:24,079 --> 00:36:29,520
sadly which is

00:36:25,440 --> 00:36:31,599
actually a little bit frustrating um

00:36:29,520 --> 00:36:32,560
but there are ways around this to a

00:36:31,599 --> 00:36:34,880
certain extent

00:36:32,560 --> 00:36:35,599
spaceship is one of the underlying

00:36:34,880 --> 00:36:38,240
libraries

00:36:35,599 --> 00:36:39,440
that is part of fastlane and actually

00:36:38,240 --> 00:36:43,040
it's what deliver

00:36:39,440 --> 00:36:46,800
uses under the hood i found an example

00:36:43,040 --> 00:36:47,599
in get up issue which is referenced by a

00:36:46,800 --> 00:36:49,359
few people

00:36:47,599 --> 00:36:51,359
of how to use spaceship to upload the

00:36:49,359 --> 00:36:53,520
app preview video to apple

00:36:51,359 --> 00:36:55,119
i've not tried it myself so i don't know

00:36:53,520 --> 00:36:56,480
if it actually works but it looks pretty

00:36:55,119 --> 00:36:59,839
promising

00:36:56,480 --> 00:37:00,240
a lot of likes um for the play store we

00:36:59,839 --> 00:37:02,960
actually

00:37:00,240 --> 00:37:03,920
needed a youtube video link now

00:37:02,960 --> 00:37:06,000
uploading to

00:37:03,920 --> 00:37:08,160
youtube programmatically is you know

00:37:06,000 --> 00:37:09,520
supported by their apis well documented

00:37:08,160 --> 00:37:12,240
online

00:37:09,520 --> 00:37:13,280
but what i couldn't find a way to do

00:37:12,240 --> 00:37:15,839
programmatically was

00:37:13,280 --> 00:37:16,400
update the reference to that video in

00:37:15,839 --> 00:37:19,760
the

00:37:16,400 --> 00:37:20,160
google play store console um i feel like

00:37:19,760 --> 00:37:22,079
there's

00:37:20,160 --> 00:37:23,440
there's something missing from supply

00:37:22,079 --> 00:37:26,079
here and and there's

00:37:23,440 --> 00:37:26,560
you know maybe the potential for uh for

00:37:26,079 --> 00:37:29,520
a little

00:37:26,560 --> 00:37:30,480
open source pr from me at some point so

00:37:29,520 --> 00:37:33,280
how are we doing

00:37:30,480 --> 00:37:34,400
on this app store checklist that we uh

00:37:33,280 --> 00:37:36,800
started with

00:37:34,400 --> 00:37:37,680
well in theory we've got those great

00:37:36,800 --> 00:37:39,359
screenshots

00:37:37,680 --> 00:37:40,960
um that they're generated and all the

00:37:39,359 --> 00:37:44,079
formats we need whenever we

00:37:40,960 --> 00:37:45,760
push new code and we've got our premiere

00:37:44,079 --> 00:37:48,720
video being captured cut

00:37:45,760 --> 00:37:50,560
and beautified whenever we push new code

00:37:48,720 --> 00:37:51,200
and because we have automated all of

00:37:50,560 --> 00:37:54,320
this

00:37:51,200 --> 00:37:55,280
in theory we can scale up the number of

00:37:54,320 --> 00:37:57,839
languages

00:37:55,280 --> 00:37:59,119
we're getting our app out in not just

00:37:57,839 --> 00:38:01,520
functioning in but also

00:37:59,119 --> 00:38:03,040
appearing to the markets in their own

00:38:01,520 --> 00:38:04,880
languages on the app stores

00:38:03,040 --> 00:38:06,720
our features will reach our users and

00:38:04,880 --> 00:38:07,440
our app store listing can always be up

00:38:06,720 --> 00:38:11,040
to date

00:38:07,440 --> 00:38:13,839
and looking great in theory

00:38:11,040 --> 00:38:15,680
now i completely accept as an individual

00:38:13,839 --> 00:38:18,640
this is probably overkill um

00:38:15,680 --> 00:38:20,560
the whole automation process um has been

00:38:18,640 --> 00:38:23,760
a brilliant way to procrastinate

00:38:20,560 --> 00:38:26,960
from actually doing any real features

00:38:23,760 --> 00:38:27,920
uh on the underworld helper app but i'm

00:38:26,960 --> 00:38:29,599
okay with that

00:38:27,920 --> 00:38:31,200
now i get a kick out of automating this

00:38:29,599 --> 00:38:33,200
stuff and it is

00:38:31,200 --> 00:38:36,240
uh you know investigating things like

00:38:33,200 --> 00:38:39,680
this that i find helps me progress

00:38:36,240 --> 00:38:41,040
my actual career and and my work

00:38:39,680 --> 00:38:43,440
and it's something that i genuinely find

00:38:41,040 --> 00:38:45,839
quite interesting

00:38:43,440 --> 00:38:46,560
so next time you find yourself manually

00:38:45,839 --> 00:38:48,800
doing

00:38:46,560 --> 00:38:50,720
something to get your app out there just

00:38:48,800 --> 00:38:52,000
take some time and think about

00:38:50,720 --> 00:38:54,720
whether you can automate it in the

00:38:52,000 --> 00:38:57,760
future and thank you for taking the time

00:38:54,720 --> 00:38:57,760

YouTube URL: https://www.youtube.com/watch?v=ux-NouwSQDA


