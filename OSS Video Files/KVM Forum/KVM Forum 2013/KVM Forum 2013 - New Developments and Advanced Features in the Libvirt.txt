Title: KVM Forum 2013 - New Developments and Advanced Features in the Libvirt
Publication date: 2014-10-30
Playlist: KVM Forum 2013
Description: 
	Slides https://docs.google.com/file/d/0BzyAwvVlQckeS2h3V1FKM1NCcmM

In the, almost 8 years, since it was founded, the libvirt project grown to be leading open source API for the management of virtualization hosts, with a strong focus on supporting the open source virtualization & container technologies KVM, QEMU, Xen and LXC. Most people working in the open source virtualization management space have an understanding of the core features and architecture of libvirt. This talk will focus on a selection of recently developed features and of some of the less well known advanced features of libvirt. It will describe capabilities for mutual exclusion / locking against guest disks; fine grained access control against individual operations, users and objects in the API; the sVirt mandatory access control framework; auditing and structured logging via the systemd journal; integration with systemd for cgroups resource management; and more.
Captions: 
	00:00:00,000 --> 00:00:04,770
exercise your application code from test

00:00:03,629 --> 00:00:07,309
Suites without actually having to

00:00:04,770 --> 00:00:11,160
actually learn with a real hypervisor

00:00:07,309 --> 00:00:12,750
that's that's used to quite quite a high

00:00:11,160 --> 00:00:14,570
degree of success in the vet manager

00:00:12,750 --> 00:00:20,100
application and some of our other

00:00:14,570 --> 00:00:21,990
command line tools like virgins storm so

00:00:20,100 --> 00:00:25,100
that's worth looking at if you're if

00:00:21,990 --> 00:00:25,100
you're looking at a way to test things

00:00:25,519 --> 00:00:34,950
from kvm users point of view things are

00:00:30,240 --> 00:00:38,430
a little bit more complicated each qmu

00:00:34,950 --> 00:00:39,570
instance only knows about itself so we

00:00:38,430 --> 00:00:41,879
want something that knows about the

00:00:39,570 --> 00:00:43,500
state of the host as a whole but that's

00:00:41,879 --> 00:00:46,649
where the liberal arts db1 comes into

00:00:43,500 --> 00:00:48,510
play so the application talks to live

00:00:46,649 --> 00:00:52,739
that library which goes out to our

00:00:48,510 --> 00:00:55,590
generic RPC system this talks to the

00:00:52,739 --> 00:00:57,750
lavash demon and that's where the Q mu

00:00:55,590 --> 00:01:01,500
driver or the little container driver

00:00:57,750 --> 00:01:04,040
which user mode Linux for the modern zen

00:01:01,500 --> 00:01:06,330
driver they all live in the liver demon

00:01:04,040 --> 00:01:08,100
and from the liver demon we then talked

00:01:06,330 --> 00:01:13,340
to the underlying hypervisor technology

00:01:08,100 --> 00:01:16,380
so in the km case we don't occur here

00:01:13,340 --> 00:01:18,540
so the lipid demon is maintaining all of

00:01:16,380 --> 00:01:23,570
the assistant state's about the

00:01:18,540 --> 00:01:23,570
hypervisor host in in this architecture

00:01:25,360 --> 00:01:30,040
it's now what I just moved straight onto

00:01:27,130 --> 00:01:33,370
some of the mm-hmm so some of the

00:01:30,040 --> 00:01:37,360
interesting features we've implemented

00:01:33,370 --> 00:01:39,850
in in lib verbs or the river demon that

00:01:37,360 --> 00:01:45,300
do things that are useful for kvm which

00:01:39,850 --> 00:01:48,940
kvm current or going to do itself so

00:01:45,300 --> 00:01:51,040
disk access protection people generally

00:01:48,940 --> 00:01:52,720
get a little bit unhappy if they have to

00:01:51,040 --> 00:01:54,700
be a boy for the save disk image of a

00:01:52,720 --> 00:01:57,970
Buddha both at the same time that they

00:01:54,700 --> 00:01:59,440
tend to lose all of their data qmu

00:01:57,970 --> 00:02:02,590
doesn't do anything to protect against

00:01:59,440 --> 00:02:05,080
this you posted a disk qu will happily

00:02:02,590 --> 00:02:06,490
run against that disk it doesn't have

00:02:05,080 --> 00:02:08,619
any awareness of any other virtual

00:02:06,490 --> 00:02:11,500
machines they're running on that host or

00:02:08,619 --> 00:02:18,209
any other hosts so Q mu alone there's no

00:02:11,500 --> 00:02:18,209
way to offer dis protection directly

00:02:18,560 --> 00:02:24,230
as well as the case of 22 news and yes

00:02:22,260 --> 00:02:29,430
between pointing at the same disk image

00:02:24,230 --> 00:02:31,050
you might have the same disk same guest

00:02:29,430 --> 00:02:32,730
configurational visible to multiple

00:02:31,050 --> 00:02:34,350
hosts and you don't want to risk

00:02:32,730 --> 00:02:36,270
starting that same guest on two

00:02:34,350 --> 00:02:38,459
different hosts at once because again

00:02:36,270 --> 00:02:39,930
bad stuff will happen if you're not

00:02:38,459 --> 00:02:42,380
using a cluster file system in your

00:02:39,930 --> 00:02:42,380
disks

00:02:42,420 --> 00:02:48,000
so libvirt provides three disk access

00:02:46,080 --> 00:02:53,360
modes when you're configuring will the

00:02:48,000 --> 00:02:57,569
guest you can have read only shared mode

00:02:53,360 --> 00:02:59,430
all the guests get a read-only view of

00:02:57,569 --> 00:03:02,370
the disk so they are they can't do any

00:02:59,430 --> 00:03:06,959
rights to it this is useful if you have

00:03:02,370 --> 00:03:11,489
our CD iso image typically the

00:03:06,959 --> 00:03:14,160
read/write shared mode this is intended

00:03:11,489 --> 00:03:18,330
to cope with the cluster filesystem

00:03:14,160 --> 00:03:23,549
scenario so if you want to run gfs or

00:03:18,330 --> 00:03:27,420
ocfs have you typically have sand

00:03:23,549 --> 00:03:30,480
storage that is made visible to multiple

00:03:27,420 --> 00:03:32,970
hosts and then multiple virtual machines

00:03:30,480 --> 00:03:34,410
cannot access the same run and as long

00:03:32,970 --> 00:03:40,680
as i'm using a cluster file system

00:03:34,410 --> 00:03:41,970
that's all perfectly safe the last disk

00:03:40,680 --> 00:03:46,130
access mode which is actually the

00:03:41,970 --> 00:03:48,239
default one is read-only exclusive mode

00:03:46,130 --> 00:03:50,220
this is what you want this is what you

00:03:48,239 --> 00:03:52,500
want to use if you've got a disk image

00:03:50,220 --> 00:03:55,109
there's only intended for use by a

00:03:52,500 --> 00:03:57,859
single guest at any time and as I say

00:03:55,109 --> 00:03:57,859
this is the default

00:03:58,290 --> 00:04:03,200
and I say these we don't share and we

00:04:00,689 --> 00:04:06,930
read right shared and we write exclusive

00:04:03,200 --> 00:04:08,609
one of the things we've like to keep

00:04:06,930 --> 00:04:09,900
quiet over the years is the fact that

00:04:08,609 --> 00:04:12,390
lip letters actually really enforce

00:04:09,900 --> 00:04:14,640
these different sharing works it's um

00:04:12,390 --> 00:04:16,079
it's really we've been relying on the

00:04:14,640 --> 00:04:20,070
management application using live

00:04:16,079 --> 00:04:21,870
versions not to do stupid things we only

00:04:20,070 --> 00:04:25,289
kind of we've only enforce them by

00:04:21,870 --> 00:04:28,100
accident by virtue of using selinux for

00:04:25,289 --> 00:04:30,599
labeling disk images so if you had a

00:04:28,100 --> 00:04:32,970
read/write exclusive disk can you label

00:04:30,599 --> 00:04:35,099
for one vm if you try to start a second

00:04:32,970 --> 00:04:36,930
vm it would get relabeled and ms you go

00:04:35,099 --> 00:04:40,139
to a block all rights nor first vm so

00:04:36,930 --> 00:04:41,970
we've got have had mutual exclusion by

00:04:40,139 --> 00:04:43,680
accident by virtue of using SEO the

00:04:41,970 --> 00:04:49,020
notice and that's that also he wasn't

00:04:43,680 --> 00:04:51,449
the ideal situation to be in so over the

00:04:49,020 --> 00:04:56,460
past probably two years in fact we've

00:04:51,449 --> 00:04:59,699
developed a a disk locking mechanism

00:04:56,460 --> 00:05:03,030
inside Hibbert this disk locking

00:04:59,699 --> 00:05:05,580
mechanism is pluggable so we have two

00:05:03,030 --> 00:05:08,220
implementations the first implementation

00:05:05,580 --> 00:05:12,120
we did made use of a technology called

00:05:08,220 --> 00:05:16,229
San lock and this this sandlot project

00:05:12,120 --> 00:05:19,240
came out of some work that the overt

00:05:16,229 --> 00:05:23,139
developers did and

00:05:19,240 --> 00:05:25,479
they developed this algorithm for disk

00:05:23,139 --> 00:05:31,030
access locking that is based on the disk

00:05:25,479 --> 00:05:34,630
Paxos algorithm and this is really they

00:05:31,030 --> 00:05:39,370
targeted this towards sound deployments

00:05:34,630 --> 00:05:40,870
so if you have fibre channel 5 channel

00:05:39,370 --> 00:05:43,449
dappers exposed your virtualization

00:05:40,870 --> 00:05:46,360
hosts and then virtual machines are

00:05:43,449 --> 00:05:48,400
using lungs on that fine channel adapter

00:05:46,360 --> 00:05:53,080
that's the kind of scenario they

00:05:48,400 --> 00:05:56,889
designed this fall and San lock runs as

00:05:53,080 --> 00:06:01,419
a separate demon and libvirt asked Sam

00:05:56,889 --> 00:06:03,849
log to take an exclusive lease and that

00:06:01,419 --> 00:06:07,630
lease represents a particular disk image

00:06:03,849 --> 00:06:08,889
so San log will acquire the lease and

00:06:07,630 --> 00:06:11,889
what's that lease is acquired the

00:06:08,889 --> 00:06:14,500
Liberty knows it is safe to staff this

00:06:11,889 --> 00:06:17,050
virtual machine if at any time the lease

00:06:14,500 --> 00:06:19,569
is lost for example due to the sand

00:06:17,050 --> 00:06:22,960
storage going AWOL for whatever reason

00:06:19,569 --> 00:06:27,210
then sand lock has the ability to fence

00:06:22,960 --> 00:06:30,580
the virtual machine this is this is

00:06:27,210 --> 00:06:33,550
useful if the sound goes missing on one

00:06:30,580 --> 00:06:35,530
host and you want to failover that vm to

00:06:33,550 --> 00:06:36,699
a second host and you will actually make

00:06:35,530 --> 00:06:38,860
sure that the vm on the original

00:06:36,699 --> 00:06:40,330
hamsters has gone away you want Sam up

00:06:38,860 --> 00:06:42,400
to kill the vm on the original host

00:06:40,330 --> 00:06:45,090
before it allows the least to be applied

00:06:42,400 --> 00:06:45,090
on the new host

00:06:46,529 --> 00:06:54,959
there are there are really two ways that

00:06:50,759 --> 00:06:58,859
we use San lock-in labret I call them

00:06:54,959 --> 00:07:02,489
the the manual lease method and the

00:06:58,859 --> 00:07:04,739
automatic lease method in the manual

00:07:02,489 --> 00:07:08,129
East method the management application

00:07:04,739 --> 00:07:10,649
such as overt or openstack is

00:07:08,129 --> 00:07:12,599
responsible for deciding what Lisa's

00:07:10,649 --> 00:07:17,009
need to be associated with what fee the

00:07:12,599 --> 00:07:19,199
MS and a the measurement application can

00:07:17,009 --> 00:07:20,929
use these leases for representing any

00:07:19,199 --> 00:07:23,549
type of mutual exclusion it's not

00:07:20,929 --> 00:07:25,709
restricted to doing it for disc images

00:07:23,549 --> 00:07:27,689
so if you have IP addresses your

00:07:25,709 --> 00:07:29,009
assigned into individual hosts the

00:07:27,689 --> 00:07:30,989
management management application can

00:07:29,009 --> 00:07:33,389
say one will have a lease for this VM

00:07:30,989 --> 00:07:36,269
that represents the IP address them

00:07:33,389 --> 00:07:38,249
going to assign it but the more common

00:07:36,269 --> 00:07:40,349
in the more common cases you give it a

00:07:38,249 --> 00:07:43,139
least reach virtual disk that you're

00:07:40,349 --> 00:07:44,429
giving it and so that case the

00:07:43,139 --> 00:07:47,519
management application is a total

00:07:44,429 --> 00:07:49,769
control of the leases live that doesn't

00:07:47,519 --> 00:07:52,619
care what the visas represent it just

00:07:49,769 --> 00:07:54,149
knows that this PM has this many leases

00:07:52,619 --> 00:07:58,159
and all of the nieces must be acquired

00:07:54,149 --> 00:07:58,159
before the vm is allowed to start

00:07:58,750 --> 00:08:02,810
it's a very flexible a very powerful but

00:08:01,400 --> 00:08:06,650
it also has a bit of an administrative

00:08:02,810 --> 00:08:08,630
burden so we introduced the simpler way

00:08:06,650 --> 00:08:13,550
of using same log which is the automatic

00:08:08,630 --> 00:08:19,010
lease method and in this case libvirt

00:08:13,550 --> 00:08:23,240
just creates leases based on the md5

00:08:19,010 --> 00:08:24,860
checksum of the disk path not see this

00:08:23,240 --> 00:08:28,700
has some limitations you've got to make

00:08:24,860 --> 00:08:30,850
sure that if your disk images it visible

00:08:28,700 --> 00:08:33,260
first via a number of different paths

00:08:30,850 --> 00:08:36,919
for example if you're using a block

00:08:33,260 --> 00:08:40,040
device it may be visible as dev SDA and

00:08:36,919 --> 00:08:43,310
they also be visible as dev disk by uuid

00:08:40,040 --> 00:08:45,950
some big long string so make sure you're

00:08:43,310 --> 00:08:49,040
configuring your VMs using a consistent

00:08:45,950 --> 00:08:52,280
file path for the automatic lease method

00:08:49,040 --> 00:08:56,540
to be safe but that's that's probably

00:08:52,280 --> 00:09:01,190
good enough many use cases so we provide

00:08:56,540 --> 00:09:03,950
this automatic least method in lip verbs

00:09:01,190 --> 00:09:05,810
the only other caveat is that since we

00:09:03,950 --> 00:09:08,360
did this the saddle up guys I decided

00:09:05,810 --> 00:09:10,460
they don't really want sound love doing

00:09:08,360 --> 00:09:14,060
leases on file systems they don't want

00:09:10,460 --> 00:09:15,650
to any work on Raw block devices so they

00:09:14,060 --> 00:09:17,600
don't they don't much like us doing our

00:09:15,650 --> 00:09:20,300
leases on shared file systems like NFS

00:09:17,600 --> 00:09:27,950
but it works anyway despite them up

00:09:20,300 --> 00:09:30,290
liking it very much sir Locke is great

00:09:27,950 --> 00:09:32,390
but when the downsides of San look is

00:09:30,290 --> 00:09:35,420
that the disk paxos algorithm has a

00:09:32,390 --> 00:09:37,520
pretty high I or overhead so you've got

00:09:35,420 --> 00:09:39,320
to have store it the storage us holding

00:09:37,520 --> 00:09:42,170
your leases has to be capable of

00:09:39,320 --> 00:09:44,990
sustaining fairly high data rates and

00:09:42,170 --> 00:09:47,360
you may you may not want to have all

00:09:44,990 --> 00:09:50,990
it's disco about it and with consumers

00:09:47,360 --> 00:09:54,050
just by Lisa's so we introduced a second

00:09:50,990 --> 00:09:57,680
block management plugin in live rat and

00:09:54,050 --> 00:10:01,490
this is known as the vert lochte plugin

00:09:57,680 --> 00:10:06,110
eaten and this is included by default

00:10:01,490 --> 00:10:08,840
with lip verbs so any any libvirt in the

00:10:06,110 --> 00:10:12,400
last probably four to six months has

00:10:08,840 --> 00:10:16,340
this capability included in it and this

00:10:12,400 --> 00:10:18,620
just takes locks using the f cntl system

00:10:16,340 --> 00:10:22,850
call and the locking capabilities that

00:10:18,620 --> 00:10:24,970
that provides as such an obviously

00:10:22,850 --> 00:10:27,170
requires use of a shared file system and

00:10:24,970 --> 00:10:29,630
a shared file system which actually

00:10:27,170 --> 00:10:31,040
supports fcat unlocking there are some

00:10:29,630 --> 00:10:35,960
shared file systems which don't support

00:10:31,040 --> 00:10:38,360
this locking mechanism I think mean I

00:10:35,960 --> 00:10:39,680
think ocfs is one of the ones that

00:10:38,360 --> 00:10:44,450
doesn't support it in all possible

00:10:39,680 --> 00:10:49,760
configurations but I use fcfs item rehab

00:10:44,450 --> 00:10:52,970
some people might care and at the moment

00:10:49,760 --> 00:10:55,570
the vet lagdi plugin is based

00:10:52,970 --> 00:11:00,440
exclusively around the idea of automatic

00:10:55,570 --> 00:11:02,960
least management so we have several ways

00:11:00,440 --> 00:11:05,930
actually doing the automatic leases the

00:11:02,960 --> 00:11:07,640
simplest way is direct file path so if

00:11:05,930 --> 00:11:10,840
you have a disk image you've given to

00:11:07,640 --> 00:11:13,940
your guests in vile lib lippert images

00:11:10,840 --> 00:11:16,480
my guests doc you Calv it would actually

00:11:13,940 --> 00:11:20,450
take at least directly on that file

00:11:16,480 --> 00:11:22,790
which is a right firm files that are on

00:11:20,450 --> 00:11:25,400
a shared file system but if you're using

00:11:22,790 --> 00:11:28,100
a sand sad storage you've got a device

00:11:25,400 --> 00:11:29,750
narrating / dev and you think you can

00:11:28,100 --> 00:11:32,120
take it a lock on that device no dash

00:11:29,750 --> 00:11:34,310
death using FC MTL that looks only going

00:11:32,120 --> 00:11:37,880
to invisible to one hosts that's a cell

00:11:34,310 --> 00:11:39,380
very good protection so we introduced a

00:11:37,880 --> 00:11:43,310
couple of alternative ways of acquiring

00:11:39,380 --> 00:11:47,810
releases the second way is just to do it

00:11:43,310 --> 00:11:50,690
based on a shower to 256 check some of

00:11:47,810 --> 00:11:53,120
the final path so if your block device

00:11:50,690 --> 00:11:55,160
is visible using the same path on each

00:11:53,120 --> 00:11:58,460
host then that gives you a mutual

00:11:55,160 --> 00:12:00,410
exclusion but again you civil problem

00:11:58,460 --> 00:12:02,420
lips there were several different block

00:12:00,410 --> 00:12:04,700
devices can appear in the Linux file

00:12:02,420 --> 00:12:06,590
system with several different names and

00:12:04,700 --> 00:12:08,450
we wanted to have a way to acquire

00:12:06,590 --> 00:12:10,490
leases which was safe regardless of

00:12:08,450 --> 00:12:14,180
which file path you use for the block

00:12:10,490 --> 00:12:20,870
device so we added a way to acquire

00:12:14,180 --> 00:12:22,960
leases based on either the lvm uuid and

00:12:20,870 --> 00:12:25,250
if using cluster lvm this uuid is

00:12:22,960 --> 00:12:28,690
guaranteed to be the same on all hosts

00:12:25,250 --> 00:12:31,040
which see that lvm volume or similarly

00:12:28,690 --> 00:12:33,170
scuzzy volumes have a unique ID

00:12:31,040 --> 00:12:37,700
associated with them so if you have a

00:12:33,170 --> 00:12:40,790
san san volume the visible of multiple

00:12:37,700 --> 00:12:44,470
hosts that unique ID is visible in the

00:12:40,790 --> 00:12:48,970
same way oral hosts so we acquire leases

00:12:44,470 --> 00:12:48,970
based on those unique identifiers

00:12:50,209 --> 00:12:58,709
that's the that's the second way you can

00:12:53,999 --> 00:13:01,350
you can do dis clocking in Lippert one

00:12:58,709 --> 00:13:05,480
of the enhancements we'd like to do is

00:13:01,350 --> 00:13:07,470
to introduce a way to use the Verilog d

00:13:05,480 --> 00:13:10,589
mechanism for completely arbitrary

00:13:07,470 --> 00:13:12,059
leases so that you can to the management

00:13:10,589 --> 00:13:16,050
application has complete control over

00:13:12,059 --> 00:13:17,370
how and where the leases are required so

00:13:16,050 --> 00:13:19,589
in the same way that you have the manual

00:13:17,370 --> 00:13:24,629
release mechanism with sand lock we want

00:13:19,589 --> 00:13:26,879
to add that divert lochte and so I mean

00:13:24,629 --> 00:13:29,040
I think the takeaway points for this is

00:13:26,879 --> 00:13:32,430
if you're writing imagine an application

00:13:29,040 --> 00:13:35,189
with libvirt and you want to have safety

00:13:32,430 --> 00:13:37,620
guarantees that your VMs are not going

00:13:35,189 --> 00:13:41,550
to use the same disk image at the same

00:13:37,620 --> 00:13:43,079
time then you want to be using and you

00:13:41,550 --> 00:13:45,420
want to be configuring your hosts to

00:13:43,079 --> 00:13:51,990
enable the limit block manager plugins

00:13:45,420 --> 00:13:54,269
or q of you this is just a quick

00:13:51,990 --> 00:13:59,040
illustration of the architecture of the

00:13:54,269 --> 00:14:01,199
van Lochte term plugin we've got the

00:13:59,040 --> 00:14:05,370
same general architecture across the

00:14:01,199 --> 00:14:08,339
middle here and then the Cure Muse

00:14:05,370 --> 00:14:11,519
driver actually speaks foreign RPC

00:14:08,339 --> 00:14:13,019
protocol to a separate Lochte demon the

00:14:11,519 --> 00:14:19,470
reason we did this in a separate demon

00:14:13,019 --> 00:14:22,249
is twofold we want to be able to restart

00:14:19,470 --> 00:14:25,230
the Liberty demon whilst pm's of running

00:14:22,249 --> 00:14:26,970
without having any impact on we want to

00:14:25,230 --> 00:14:29,459
do this so that we can deploy RPM

00:14:26,970 --> 00:14:31,769
upgrades and I've reached our Liberty to

00:14:29,459 --> 00:14:33,120
actually activate the new code when you

00:14:31,769 --> 00:14:35,160
restarting the demon you don't to lose

00:14:33,120 --> 00:14:38,600
all of your leases because that's a bit

00:14:35,160 --> 00:14:38,600
of a safety problem and

00:14:38,690 --> 00:14:42,630
so we decided to split the least

00:14:40,920 --> 00:14:45,060
functionality added or separate lochte

00:14:42,630 --> 00:14:48,990
demon and the way this deals with

00:14:45,060 --> 00:14:51,870
upgrades is it it's capable of reading

00:14:48,990 --> 00:14:54,180
itself whilst holding open all of the

00:14:51,870 --> 00:14:57,180
file descriptors associated with the

00:14:54,180 --> 00:15:00,000
locks that it holds there's a possible

00:14:57,180 --> 00:15:01,800
to do this re exec dance when you have a

00:15:00,000 --> 00:15:03,000
very narrowly targeted set of

00:15:01,800 --> 00:15:05,220
functionality you're trying to preserve

00:15:03,000 --> 00:15:09,180
across the exact so they have to be in a

00:15:05,220 --> 00:15:12,060
separate demon and the second reason it

00:15:09,180 --> 00:15:14,339
had to be a separate demon is because

00:15:12,060 --> 00:15:18,089
the POSIX API for locking is incredibly

00:15:14,339 --> 00:15:20,370
utterly brain-dead least stupid if you

00:15:18,089 --> 00:15:22,680
have a fire open and you have that fight

00:15:20,370 --> 00:15:24,300
open multiple times so you have say for

00:15:22,680 --> 00:15:26,640
file descriptors pointing to the same

00:15:24,300 --> 00:15:28,890
file you acquire a lock on this phone

00:15:26,640 --> 00:15:30,420
descriptor if you close any of those

00:15:28,890 --> 00:15:33,690
other file descriptors it's going to

00:15:30,420 --> 00:15:35,940
release a lot of your locks this I can't

00:15:33,690 --> 00:15:39,990
express how I'm happy this makes me was

00:15:35,940 --> 00:15:42,750
with the POSIX API it makes this F cntl

00:15:39,990 --> 00:15:44,310
looking absolutely horrible to use the

00:15:42,750 --> 00:15:46,770
only way to do it safely is to have a

00:15:44,310 --> 00:15:48,839
dedicated process just for dealing with

00:15:46,770 --> 00:15:50,790
locks where you can guarantee that no

00:15:48,839 --> 00:15:52,320
other libraries while you're making it

00:15:50,790 --> 00:15:53,670
going to be secretly hoping that opening

00:15:52,320 --> 00:15:58,910
the final that you're locking behind

00:15:53,670 --> 00:16:04,290
your back eatin so enough about locking

00:15:58,910 --> 00:16:07,220
SS we want something else this is a

00:16:04,290 --> 00:16:09,750
feature that has been requested by users

00:16:07,220 --> 00:16:12,920
for many years people been requesting

00:16:09,750 --> 00:16:15,420
this for at least five years if not more

00:16:12,920 --> 00:16:18,959
and over this past year we finally got

00:16:15,420 --> 00:16:22,170
around to implementing it so if those

00:16:18,959 --> 00:16:25,170
those reviews deliver before your know

00:16:22,170 --> 00:16:28,020
that's basically to privilege levels and

00:16:25,170 --> 00:16:30,750
live rats you can have if you connect to

00:16:28,020 --> 00:16:33,000
live words your connection neither being

00:16:30,750 --> 00:16:35,190
in read-only mode where you're allowed

00:16:33,000 --> 00:16:37,770
to do any AP is that query information

00:16:35,190 --> 00:16:40,770
about guests or what's going on the

00:16:37,770 --> 00:16:41,820
system or you can have read mark read

00:16:40,770 --> 00:16:44,550
write mode where you

00:16:41,820 --> 00:16:47,040
to do absolutely anything the follicular

00:16:44,550 --> 00:16:50,160
to allows you to do that's that's fairly

00:16:47,040 --> 00:16:51,390
crude there's a number of there's a

00:16:50,160 --> 00:16:53,580
number of cases the way you might want

00:16:51,390 --> 00:16:58,980
to have a privilege level that's

00:16:53,580 --> 00:17:02,100
somewhere in between those two cases so

00:16:58,980 --> 00:17:09,089
we introduced the fine-grained acl's

00:17:02,100 --> 00:17:13,800
capability then we introduce this in the

00:17:09,089 --> 00:17:17,940
liver to 110 release and this allows you

00:17:13,800 --> 00:17:21,930
to do set up permissions on a on a

00:17:17,940 --> 00:17:25,230
triple of the object such as the virtual

00:17:21,930 --> 00:17:27,209
machine or network or storage pool if

00:17:25,230 --> 00:17:30,420
subjects which is the user or

00:17:27,209 --> 00:17:35,820
application that's using the third and a

00:17:30,420 --> 00:17:39,600
permission such as boots shut down save

00:17:35,820 --> 00:17:42,870
XML or or so forth so now you can

00:17:39,600 --> 00:17:45,840
express rules such as allow Frank to

00:17:42,870 --> 00:17:48,060
start the guest Apache so here's much

00:17:45,840 --> 00:17:50,430
morgan's you can get access to do write

00:17:48,060 --> 00:17:54,840
operations in a much more constrained

00:17:50,430 --> 00:17:57,000
way this mechanism has been wired up

00:17:54,840 --> 00:17:59,370
across all of the lippert public API is

00:17:57,000 --> 00:18:03,690
so if you look in the API documentation

00:17:59,370 --> 00:18:04,680
for libvirt now against every API there

00:18:03,690 --> 00:18:06,360
will be a little bit of documentation

00:18:04,680 --> 00:18:09,210
which tells you what permission check is

00:18:06,360 --> 00:18:11,670
done for that API sub api's have

00:18:09,210 --> 00:18:13,260
multiple commission checks for example

00:18:11,670 --> 00:18:16,110
if there are flags that control the

00:18:13,260 --> 00:18:18,660
behavior of the API some of those flags

00:18:16,110 --> 00:18:22,740
may apply an X for permission check is

00:18:18,660 --> 00:18:25,440
performed now these permission checks

00:18:22,740 --> 00:18:27,900
are done for all of the virtualization

00:18:25,440 --> 00:18:30,330
drivers which run inside the lip verte

00:18:27,900 --> 00:18:35,280
de demon so that means these commission

00:18:30,330 --> 00:18:38,470
checks are useful for kvm nxc user mode

00:18:35,280 --> 00:18:40,790
linux or the modern zen

00:18:38,470 --> 00:18:42,350
we don't attempt to do any permission

00:18:40,790 --> 00:18:45,320
checks for the whoa for the drivers that

00:18:42,350 --> 00:18:47,570
run entirely client-side such as the ESX

00:18:45,320 --> 00:18:49,850
driver or hyper being that's really

00:18:47,570 --> 00:18:51,260
pretty pointless libert if the liver

00:18:49,850 --> 00:18:53,900
client way we did a commission check

00:18:51,260 --> 00:18:56,060
which denied you access to the ESX

00:18:53,900 --> 00:18:58,910
server host well you just go around at a

00:18:56,060 --> 00:19:01,040
book the ESX host directly so we only do

00:18:58,910 --> 00:19:02,630
commission checks for drivers may look

00:19:01,040 --> 00:19:10,040
light is actually managing the state of

00:19:02,630 --> 00:19:14,270
the of the host and this this mechanism

00:19:10,040 --> 00:19:17,320
is again pluggable because while we had

00:19:14,270 --> 00:19:18,710
an idea of those emissions

00:19:17,320 --> 00:19:20,900
implementation commissioning

00:19:18,710 --> 00:19:22,220
implementation we wanted to use we

00:19:20,900 --> 00:19:25,970
didn't want to lock ourselves into one

00:19:22,220 --> 00:19:30,100
particular technology so to start off

00:19:25,970 --> 00:19:33,850
with we've integrated with policy kit

00:19:30,100 --> 00:19:36,230
obviously it is a fairly commonly found

00:19:33,850 --> 00:19:40,400
authorization framework in modern Linux

00:19:36,230 --> 00:19:44,900
systems it's more commonly found in a

00:19:40,400 --> 00:19:47,720
desktop environment but as it's designed

00:19:44,900 --> 00:19:51,620
is in no way tight Desktop Linux usage

00:19:47,720 --> 00:19:54,710
is equally applicable to any server

00:19:51,620 --> 00:20:01,300
virtualization or server usage of Linux

00:19:54,710 --> 00:20:04,100
hosts so the first and currently only

00:20:01,300 --> 00:20:07,970
access control plug in for liberators is

00:20:04,100 --> 00:20:09,500
based on Polly Pocket when we have a

00:20:07,970 --> 00:20:11,740
mechanism for mapping the loop road

00:20:09,500 --> 00:20:16,160
commissions and live words object types

00:20:11,740 --> 00:20:20,900
to Hulk actions so if you have a start

00:20:16,160 --> 00:20:24,130
commission on a domain object this gets

00:20:20,900 --> 00:20:29,740
mapped into a action

00:20:24,130 --> 00:20:33,490
Audio API domain not start and again

00:20:29,740 --> 00:20:37,000
there's web pages that links to from the

00:20:33,490 --> 00:20:40,330
sound Lippert API documentation which

00:20:37,000 --> 00:20:42,040
tell you what all of these policy get

00:20:40,330 --> 00:20:44,590
action names are called so you can look

00:20:42,040 --> 00:20:50,920
up what actions are implied for a

00:20:44,590 --> 00:20:54,130
particular API call mm-hmm to represent

00:20:50,920 --> 00:20:57,220
the object being affected by by the way

00:20:54,130 --> 00:21:00,400
the operation we passed through one or

00:20:57,220 --> 00:21:03,850
more pieces of identifying information

00:21:00,400 --> 00:21:05,380
we pass through the driver name which is

00:21:03,850 --> 00:21:10,330
basically what virtualization driver

00:21:05,380 --> 00:21:14,260
this is so when these qmu nxc user mode

00:21:10,330 --> 00:21:17,950
of x or sin in the case of virtual

00:21:14,260 --> 00:21:20,440
domains we pass through the ID when you

00:21:17,950 --> 00:21:23,350
start a virtual guest it gets assigned a

00:21:20,440 --> 00:21:24,790
unique integer ID for as long as it is

00:21:23,350 --> 00:21:31,300
running so that's one way of identifying

00:21:24,790 --> 00:21:33,490
guests guests also have a unique uuid or

00:21:31,300 --> 00:21:37,000
they have a slightly more friendly name

00:21:33,490 --> 00:21:40,210
so those are the four attributes we

00:21:37,000 --> 00:21:42,310
provide for virtual domains other object

00:21:40,210 --> 00:21:44,230
types and lip verbs have different

00:21:42,310 --> 00:21:47,470
unique identifier associated with them

00:21:44,230 --> 00:21:50,020
and again the online documentation tells

00:21:47,470 --> 00:21:52,240
you what the unique identifiers you can

00:21:50,020 --> 00:21:54,510
rely on for each type of object and live

00:21:52,240 --> 00:21:54,510
close

00:21:55,960 --> 00:22:01,510
one thing that is slightly limited in

00:21:58,340 --> 00:22:06,920
our current implementation as how we

00:22:01,510 --> 00:22:10,750
expose details about the user this is

00:22:06,920 --> 00:22:10,750
really a limitation of policy kit itself

00:22:11,440 --> 00:22:18,560
in the in the in the backend for policy

00:22:16,760 --> 00:22:20,870
kits it really only knows about local

00:22:18,560 --> 00:22:22,750
UNIX users so if you are a local

00:22:20,870 --> 00:22:27,140
application thinking delivered locally

00:22:22,750 --> 00:22:28,910
you got a UNIX user ID a group ID and a

00:22:27,140 --> 00:22:33,110
process ID that's associated with you

00:22:28,910 --> 00:22:35,390
and that's provided to policy gets for

00:22:33,110 --> 00:22:36,860
doing commissions checks you might ask

00:22:35,390 --> 00:22:40,610
what if you're connecting to live verb

00:22:36,860 --> 00:22:44,150
to remotely over TCP you're not going to

00:22:40,610 --> 00:22:48,770
have a local UNIX user ID but it's not

00:22:44,150 --> 00:22:50,840
one that we can trust when you click to

00:22:48,770 --> 00:22:54,910
look that were locally you have to

00:22:50,840 --> 00:22:59,900
authenticate with libvirt using either

00:22:54,910 --> 00:23:02,180
an x.509 certificate which has every XY

00:22:59,900 --> 00:23:04,370
of in a certificate has a unique

00:23:02,180 --> 00:23:07,160
distinguished name associated with it so

00:23:04,370 --> 00:23:09,050
I can identify the client user or if

00:23:07,160 --> 00:23:11,390
you're authenticating using sasal and

00:23:09,050 --> 00:23:15,320
kerberos you have a Kerberos principal

00:23:11,390 --> 00:23:17,840
name so one of the things we want to do

00:23:15,320 --> 00:23:20,000
in the near future is passed through

00:23:17,840 --> 00:23:23,240
information about the sasal username or

00:23:20,000 --> 00:23:25,190
Kerberos principal name or certificate

00:23:23,240 --> 00:23:26,930
distinguished name so then you'll be

00:23:25,190 --> 00:23:29,090
able to use that information to identify

00:23:26,930 --> 00:23:32,170
the client application when writing

00:23:29,090 --> 00:23:32,170
access control rules

00:23:34,860 --> 00:23:40,120
and people that back probably can't see

00:23:38,230 --> 00:23:44,799
this but I just wanted to give a quick

00:23:40,120 --> 00:23:46,529
illustration of how you might write an

00:23:44,799 --> 00:23:48,759
access control check Philip verbs

00:23:46,529 --> 00:23:51,929
judging by people the front squinting

00:23:48,759 --> 00:23:54,009
they probably can't see it either okay

00:23:51,929 --> 00:23:57,399
now describe it anyway so it doesn't

00:23:54,009 --> 00:24:00,990
matter you can't really see it policy

00:23:57,399 --> 00:24:05,259
kit as it exists for the past year or so

00:24:00,990 --> 00:24:07,480
uses a JavaScript back end fitting

00:24:05,259 --> 00:24:13,539
access control checks previously it was

00:24:07,480 --> 00:24:15,749
just a plain any style text file let's

00:24:13,539 --> 00:24:17,980
not really flexible enough for doing

00:24:15,749 --> 00:24:20,529
some of these five rate access control

00:24:17,980 --> 00:24:23,769
checks and you might want to integrate

00:24:20,529 --> 00:24:26,259
with an external directory service of

00:24:23,769 --> 00:24:28,980
some kind so they introduced this idea

00:24:26,259 --> 00:24:32,100
of a JavaScript backends to policy get

00:24:28,980 --> 00:24:34,360
so now as an administrator on the host

00:24:32,100 --> 00:24:37,049
if you want to set up access control

00:24:34,360 --> 00:24:42,100
rules you have to write short JavaScript

00:24:37,049 --> 00:24:45,249
code fragments and the unique

00:24:42,100 --> 00:24:47,980
identifiers about the object the user

00:24:45,249 --> 00:24:52,059
and the permission the main available to

00:24:47,980 --> 00:24:54,309
this JavaScript run side so you can do

00:24:52,059 --> 00:24:57,159
things like set up a rule in this case I

00:24:54,309 --> 00:25:00,190
set up a rule saying if the operation

00:24:57,159 --> 00:25:03,399
being performed is world lippert api

00:25:00,190 --> 00:25:05,799
domain door guitarra this justice a

00:25:03,399 --> 00:25:09,519
basic query for information about domain

00:25:05,799 --> 00:25:13,600
and the user asking for it is barrel

00:25:09,519 --> 00:25:18,220
shape and the

00:25:13,600 --> 00:25:22,000
action and the and the action object has

00:25:18,220 --> 00:25:25,630
a driver name of Alexei and the guests

00:25:22,000 --> 00:25:32,110
name is demo then allow allow that user

00:25:25,630 --> 00:25:34,179
access otherwise that item this is I

00:25:32,110 --> 00:25:35,980
mean this if any powerful at the same

00:25:34,179 --> 00:25:38,980
time it's probably gonna be quite

00:25:35,980 --> 00:25:41,260
tedious to write these rules if you have

00:25:38,980 --> 00:25:46,840
a lot of very different and complex

00:25:41,260 --> 00:25:48,970
rules you try to set up so this is

00:25:46,840 --> 00:25:54,010
really this is really a first step

00:25:48,970 --> 00:25:57,039
towards future enhancements are going to

00:25:54,010 --> 00:25:58,360
try and make this work easier what it

00:25:57,039 --> 00:26:00,820
like I said it just a few months ago one

00:25:58,360 --> 00:26:01,750
of the ideas of using javascript is that

00:26:00,820 --> 00:26:04,210
you'll be able to integrate with

00:26:01,750 --> 00:26:07,539
external systems so if you have say a

00:26:04,210 --> 00:26:09,940
directory server or in this database or

00:26:07,539 --> 00:26:12,520
something which provided records about

00:26:09,940 --> 00:26:14,169
access control you could write some

00:26:12,520 --> 00:26:17,289
JavaScript to talk to that directory

00:26:14,169 --> 00:26:19,240
service to query your access control

00:26:17,289 --> 00:26:20,590
rules and that would that provide your

00:26:19,240 --> 00:26:24,909
way to centralize all your access

00:26:20,590 --> 00:26:27,130
control rules in one place that's

00:26:24,909 --> 00:26:29,080
something something something was yet to

00:26:27,130 --> 00:26:31,020
be explored really we've got the basic

00:26:29,080 --> 00:26:34,049
access control framework in lib roads

00:26:31,020 --> 00:26:36,760
but there's clearly a lot more to be

00:26:34,049 --> 00:26:39,490
done or experimented with to find out

00:26:36,760 --> 00:26:41,770
ways to make this more manageable do we

00:26:39,490 --> 00:26:43,789
want to actually adding the Libya API

00:26:41,770 --> 00:26:48,080
the

00:26:43,789 --> 00:26:50,779
di di tua to general manager rules we

00:26:48,080 --> 00:26:52,909
are we are going to upload that yeah and

00:26:50,779 --> 00:26:56,059
weld the main point of entry using

00:26:52,909 --> 00:26:58,519
policy kids is that this gives us clean

00:26:56,059 --> 00:27:00,859
separation between loop verbs which is

00:26:58,519 --> 00:27:04,070
doing all the operations and the access

00:27:00,859 --> 00:27:06,320
control mechanism we want to we want the

00:27:04,070 --> 00:27:08,119
access control the actual access control

00:27:06,320 --> 00:27:10,129
mechanism to be a completely pluggable

00:27:08,119 --> 00:27:13,369
I'm separated from web work so that

00:27:10,129 --> 00:27:15,799
people can write custom backends for

00:27:13,369 --> 00:27:17,119
policy kits to do whatever integration

00:27:15,799 --> 00:27:19,279
they might want to do will not have to

00:27:17,119 --> 00:27:20,659
modify their foot each time to come up

00:27:19,279 --> 00:27:23,779
with a new way they want to do access

00:27:20,659 --> 00:27:25,940
control so loop road simply makes the

00:27:23,779 --> 00:27:27,679
query saying and I allowed to do this on

00:27:25,940 --> 00:27:29,629
this subject and then the actual

00:27:27,679 --> 00:27:33,609
decision making is is added by an

00:27:29,629 --> 00:27:33,609
external external components

00:27:34,240 --> 00:27:44,020
mm-hmm so I'm going to move on to the

00:27:37,330 --> 00:27:45,640
next topic now which is selinux selinux

00:27:44,020 --> 00:27:50,340
has been around in liver for quite a

00:27:45,640 --> 00:27:50,340
long time often referred to as s first

00:27:50,370 --> 00:27:56,440
and the way this works by default is

00:27:52,690 --> 00:27:59,740
that each version which new stars gets

00:27:56,440 --> 00:28:02,679
assigned a unique MCS category and

00:27:59,740 --> 00:28:08,200
that's paired with a label like s party

00:28:02,679 --> 00:28:11,350
or most recently or recently sotc GT and

00:28:08,200 --> 00:28:13,870
that label will uniquely is uniquely

00:28:11,350 --> 00:28:15,880
assigned to one guest instance and it

00:28:13,870 --> 00:28:18,970
gives you mandatory access controls with

00:28:15,880 --> 00:28:21,880
each instance that eve f is a compromise

00:28:18,970 --> 00:28:23,350
at qmu selinux is going to confine that

00:28:21,880 --> 00:28:26,400
so it's not gonna be able to access any

00:28:23,350 --> 00:28:31,780
resources other than those that already

00:28:26,400 --> 00:28:34,600
access to as well as the automatic way

00:28:31,780 --> 00:28:37,570
of assigning selinux labels there was a

00:28:34,600 --> 00:28:40,330
manual way by the management application

00:28:37,570 --> 00:28:42,910
had complete control over the label that

00:28:40,330 --> 00:28:44,080
was very good flexibility but it put a

00:28:42,910 --> 00:28:46,840
bit too much of a burden on the

00:28:44,080 --> 00:28:49,390
management application so we introduced

00:28:46,840 --> 00:28:52,030
the third way where you can where you

00:28:49,390 --> 00:28:56,890
just specify the base label example you

00:28:52,030 --> 00:28:58,990
might have value a custom my s50 domain

00:28:56,890 --> 00:29:01,809
type you still want no probe to

00:28:58,990 --> 00:29:04,030
dynamically assign the categories so we

00:29:01,809 --> 00:29:08,890
introduce that third way of configuring

00:29:04,030 --> 00:29:10,720
selinux and number another flexibility

00:29:08,890 --> 00:29:14,320
thing we added was the ability to

00:29:10,720 --> 00:29:16,780
override this individual disk images so

00:29:14,320 --> 00:29:18,309
for example if you had an ISO image that

00:29:16,780 --> 00:29:20,170
was a read-only storage and you don't

00:29:18,309 --> 00:29:22,450
want liver to try relabeling an ISO

00:29:20,170 --> 00:29:26,040
image you now have the option to turn

00:29:22,450 --> 00:29:26,040
off labeling just that individual

00:29:27,990 --> 00:29:35,890
we also expand an esper to cover

00:29:31,000 --> 00:29:38,350
discretionary access control lipid has

00:29:35,890 --> 00:29:39,720
always been able for a long for a long

00:29:38,350 --> 00:29:43,870
long time they've both been able to run

00:29:39,720 --> 00:29:47,530
qmu instances under a dedicated qmu user

00:29:43,870 --> 00:29:49,240
rogue group account we're all qmu they

00:29:47,530 --> 00:29:50,320
were all all qmu instances we're running

00:29:49,240 --> 00:29:52,120
on the same usual council the no

00:29:50,320 --> 00:29:54,220
separation between them there's only

00:29:52,120 --> 00:29:57,100
protected the host from a guess they

00:29:54,220 --> 00:29:59,409
didn't protect guests from each other so

00:29:57,100 --> 00:30:01,419
we we incorporated discretionary access

00:29:59,409 --> 00:30:03,669
control into estimate so now you can

00:30:01,419 --> 00:30:07,030
assign a unique user ID to each

00:30:03,669 --> 00:30:09,039
individual guest so they'll be separated

00:30:07,030 --> 00:30:10,929
from each other using discretionary

00:30:09,039 --> 00:30:14,110
access control this is just another line

00:30:10,929 --> 00:30:18,760
of defense if you're not using su the

00:30:14,110 --> 00:30:20,890
selinux for whatever reason but again we

00:30:18,760 --> 00:30:24,120
made it possible to control this on a

00:30:20,890 --> 00:30:24,120
per disk image basis

00:30:25,710 --> 00:30:30,450
audit logging this is something that's

00:30:28,409 --> 00:30:34,380
been around for a little while in

00:30:30,450 --> 00:30:38,850
Liberty now but also be not making aware

00:30:34,380 --> 00:30:41,669
of it within in the queue of you and

00:30:38,850 --> 00:30:45,179
Linux container drivers and avert any

00:30:41,669 --> 00:30:48,090
time an operation is performed that has

00:30:45,179 --> 00:30:50,899
some relation to host resources such as

00:30:48,090 --> 00:30:54,390
starting a guest or hot plugging a disc

00:30:50,899 --> 00:30:56,909
more attaching a pci device we generate

00:30:54,390 --> 00:30:59,970
a formal audit log and this gets fed

00:30:56,909 --> 00:31:03,029
into the Colonel's audit subsystem and

00:30:59,970 --> 00:31:06,690
assisted somewhere by the audits demon

00:31:03,029 --> 00:31:08,700
this gives you a an audit trail of what

00:31:06,690 --> 00:31:13,190
operations have been performed on guests

00:31:08,700 --> 00:31:15,330
on that host this work originated with

00:31:13,190 --> 00:31:18,570
government requirements but a common

00:31:15,330 --> 00:31:21,899
criteria certification we can see that

00:31:18,570 --> 00:31:23,549
this audit trail can be useful to many

00:31:21,899 --> 00:31:25,409
other users who just want to know what's

00:31:23,549 --> 00:31:27,860
been going on with their virtualization

00:31:25,409 --> 00:31:27,860
hosts

00:31:30,080 --> 00:31:37,279
and this is more about developer

00:31:32,630 --> 00:31:40,039
relevant feature at the moment libvirt

00:31:37,279 --> 00:31:42,710
has extensive debugging capabilities and

00:31:40,039 --> 00:31:46,220
historically we just sent a message out

00:31:42,710 --> 00:31:48,679
to syslog which is as great as syslog is

00:31:46,220 --> 00:31:52,549
which is not very great it was just a

00:31:48,679 --> 00:31:54,320
plain formatted text message some people

00:31:52,549 --> 00:31:56,990
have tried to define our structure

00:31:54,320 --> 00:32:00,919
syslog where you send json documents

00:31:56,990 --> 00:32:02,510
into syslog but very few people find

00:32:00,919 --> 00:32:04,220
that appealing because the nice thing

00:32:02,510 --> 00:32:05,539
about this talk is this plain text and

00:32:04,220 --> 00:32:07,789
now you're filling it with JSON

00:32:05,539 --> 00:32:12,289
documents that's throwing away the only

00:32:07,789 --> 00:32:14,090
advantage of syslog the fortunately

00:32:12,289 --> 00:32:16,429
system became along and invented this

00:32:14,090 --> 00:32:18,559
thing for the journal and the journal is

00:32:16,429 --> 00:32:21,740
actually really really nice to use from

00:32:18,559 --> 00:32:24,620
a client application because it allows

00:32:21,740 --> 00:32:26,360
you to do structured logging where you

00:32:24,620 --> 00:32:29,809
have individual data fields for each

00:32:26,360 --> 00:32:32,179
each item you're to log and even better

00:32:29,809 --> 00:32:34,309
than this the way the communications

00:32:32,179 --> 00:32:35,990
protocol happens with the journal you

00:32:34,309 --> 00:32:38,690
can send all this structured data to the

00:32:35,990 --> 00:32:41,299
journal with zero copy overhead of your

00:32:38,690 --> 00:32:43,399
data which is not something you can do

00:32:41,299 --> 00:32:45,700
when your formatting strings with syslog

00:32:43,399 --> 00:32:47,799
or building up json strings

00:32:45,700 --> 00:32:49,870
this one this this is a nice way to

00:32:47,799 --> 00:32:54,299
minimize the overhead of debug logging

00:32:49,870 --> 00:32:54,299
will still gets no structured logging

00:32:56,190 --> 00:33:01,330
this is probably one of the most

00:32:58,899 --> 00:33:04,330
frequently requested features for loop

00:33:01,330 --> 00:33:07,389
verbs the ability to control the see

00:33:04,330 --> 00:33:09,100
groups layout if any of you have looked

00:33:07,389 --> 00:33:11,769
at the way liver does see groups in the

00:33:09,100 --> 00:33:14,529
past you will know that it's had a very

00:33:11,769 --> 00:33:17,139
fixed layout which was three three

00:33:14,529 --> 00:33:19,720
levels deep you create a loop votes

00:33:17,139 --> 00:33:21,370
directory then we create a kvm directory

00:33:19,720 --> 00:33:25,720
now we feel a directory for each

00:33:21,370 --> 00:33:27,519
individual guest this was done back in

00:33:25,720 --> 00:33:29,799
the days when sea routes are very new

00:33:27,519 --> 00:33:32,730
nobody knew how it was going to be used

00:33:29,799 --> 00:33:35,080
so we just think some arbitrary layouts

00:33:32,730 --> 00:33:39,340
until now is it bad for a variety of

00:33:35,080 --> 00:33:41,230
reasons the thing that really hit us

00:33:39,340 --> 00:33:43,419
first of all was the fact that for a

00:33:41,230 --> 00:33:46,000
long time McConnell see groups has been

00:33:43,419 --> 00:33:47,919
horrific Lee not scalable so if you

00:33:46,000 --> 00:33:49,990
created deep hierarchies where they were

00:33:47,919 --> 00:33:53,169
saying three or four levels deep then

00:33:49,990 --> 00:33:54,850
curl performers were just plummeting or

00:33:53,169 --> 00:33:58,480
if you had just a large number of see

00:33:54,850 --> 00:34:02,139
groups and big assembly machines and the

00:33:58,480 --> 00:34:04,149
scheduler performance will plummet so we

00:34:02,139 --> 00:34:06,490
made an effort to simplify the lippert

00:34:04,149 --> 00:34:08,440
layouts mostly by flattening it out

00:34:06,490 --> 00:34:10,599
which was the biggest performance

00:34:08,440 --> 00:34:11,619
benefits as the other performance

00:34:10,599 --> 00:34:14,429
problems have been addressed in the

00:34:11,619 --> 00:34:14,429
kernel to a large degree

00:34:14,560 --> 00:34:22,210
so now there's just two levels by

00:34:18,040 --> 00:34:24,310
default at the very top level will

00:34:22,210 --> 00:34:26,590
create a directory called machine and

00:34:24,310 --> 00:34:29,260
under that will create a directory for

00:34:26,590 --> 00:34:30,760
each virtual machine if you're using

00:34:29,260 --> 00:34:32,470
system d things were a little bit

00:34:30,760 --> 00:34:33,880
different because system B wants to be

00:34:32,470 --> 00:34:36,420
in charge of creating all the see groups

00:34:33,880 --> 00:34:39,010
and defining its own naming convention

00:34:36,420 --> 00:34:42,040
so the group will be called machine not

00:34:39,010 --> 00:34:43,660
slice the actual broad functionality is

00:34:42,040 --> 00:34:45,430
the same in both cases is just a sunny

00:34:43,660 --> 00:34:48,850
different naming convention if you're

00:34:45,430 --> 00:34:50,440
using system beyond your hosts so you

00:34:48,850 --> 00:34:52,570
think well I still I still fixed

00:34:50,440 --> 00:34:55,660
hierarchy to find my Lippert that's only

00:34:52,570 --> 00:34:57,940
half the problem solved so we introduced

00:34:55,660 --> 00:35:00,430
a new bit of syntax into the

00:34:57,940 --> 00:35:03,900
configuration for guests where you can

00:35:00,430 --> 00:35:06,750
specify the name of a resource partition

00:35:03,900 --> 00:35:10,300
so in this case I've specify the name of

00:35:06,750 --> 00:35:13,540
machine stash production and this gets

00:35:10,300 --> 00:35:17,040
mapped through into a seed root

00:35:13,540 --> 00:35:19,750
directory in a non system B case it's

00:35:17,040 --> 00:35:22,390
slashing machine / machine or partition

00:35:19,750 --> 00:35:24,580
in system the case is a slightly

00:35:22,390 --> 00:35:26,590
different naming convention has slice on

00:35:24,580 --> 00:35:29,920
the end of things again let's just the

00:35:26,590 --> 00:35:32,020
system be quote and the upshot is that

00:35:29,920 --> 00:35:34,090
you can now define arbitrary groups of

00:35:32,020 --> 00:35:35,560
your virtual machines with arbitrary

00:35:34,090 --> 00:35:38,590
hierarchies that you're in complete

00:35:35,560 --> 00:35:39,760
control over so you can put a lot of

00:35:38,590 --> 00:35:41,770
your virtual machines at the very top

00:35:39,760 --> 00:35:43,810
level if you want or you can create a

00:35:41,770 --> 00:35:46,120
ten level deep hierarchy or anything in

00:35:43,810 --> 00:35:50,470
between libero doesn't constrain you in

00:35:46,120 --> 00:35:51,790
any way anymore there should be one

00:35:50,470 --> 00:35:54,340
useful for people need to try out

00:35:51,790 --> 00:35:58,560
different ways of grouping and measuring

00:35:54,340 --> 00:35:58,560
their SMAS virtual machines

00:35:59,800 --> 00:36:04,030
what release were those changes name

00:36:01,630 --> 00:36:06,340
then you know all a little style is it I

00:36:04,030 --> 00:36:09,550
am a friend a cup exactly remember but

00:36:06,340 --> 00:36:11,830
it was as the long system be stuff came

00:36:09,550 --> 00:36:13,150
along first and in a release or two

00:36:11,830 --> 00:36:15,760
later we out of the system these stuff

00:36:13,150 --> 00:36:19,380
so it's probably the last four or five

00:36:15,760 --> 00:36:23,710
releases the stuff started to appear in

00:36:19,380 --> 00:36:27,820
think fedora fedora 20 definitely has it

00:36:23,710 --> 00:36:30,870
all well seven well have all this it's

00:36:27,820 --> 00:36:30,870
fairly new stuff still

00:36:37,829 --> 00:36:42,549
performance tests are ongoing and we

00:36:41,200 --> 00:36:44,170
just know from previous performance

00:36:42,549 --> 00:36:46,839
tests we do that the depth of the

00:36:44,170 --> 00:36:49,180
hierarchy is a real killer so the fact

00:36:46,839 --> 00:36:51,849
that we've reduced the hierarchy by at

00:36:49,180 --> 00:36:53,229
least two levels we already know that's

00:36:51,849 --> 00:36:56,140
going to give us a good performance when

00:36:53,229 --> 00:37:00,130
we don't know the exact quantity of that

00:36:56,140 --> 00:37:01,630
performance benefit but we have with at

00:37:00,130 --> 00:37:03,849
least in the rail side of things we have

00:37:01,630 --> 00:37:05,470
a performance team who is analyzing this

00:37:03,849 --> 00:37:07,390
on an ongoing basis and looking not just

00:37:05,470 --> 00:37:12,069
at one day but knows most of all the

00:37:07,390 --> 00:37:15,759
colonel does the hierarchy with key

00:37:12,069 --> 00:37:17,200
issue the total number of groups with

00:37:15,759 --> 00:37:19,960
another issue that's been solved by the

00:37:17,200 --> 00:37:23,950
cannon ogres it's the only place you can

00:37:19,960 --> 00:37:25,630
solve that and the last few sizes want

00:37:23,950 --> 00:37:29,739
to mention some of the resource to

00:37:25,630 --> 00:37:33,089
nobles you have with lippert some but

00:37:29,739 --> 00:37:35,710
not all of these are done using cgroups

00:37:33,089 --> 00:37:38,380
the shed jana chuda rules are done using

00:37:35,710 --> 00:37:40,779
see groups seem simple the first one of

00:37:38,380 --> 00:37:44,799
civil cpu shares this is just a relative

00:37:40,779 --> 00:37:48,130
waiting of virtual machines slightly

00:37:44,799 --> 00:37:50,950
more interesting is some absolute time

00:37:48,130 --> 00:37:53,829
slice they can specify the period and

00:37:50,950 --> 00:37:57,039
quota assigned to each individual vcpu

00:37:53,829 --> 00:37:59,460
thread in q mu as well as the long vcpu

00:37:57,039 --> 00:37:59,460
threads

00:38:00,460 --> 00:38:06,099
cpu models you can cheers number of

00:38:04,420 --> 00:38:09,310
different ways to configure the cpu with

00:38:06,099 --> 00:38:11,619
qmu either by a named model or by

00:38:09,310 --> 00:38:14,430
copying the host model or by doing

00:38:11,619 --> 00:38:20,020
actual host cpu passed through

00:38:14,430 --> 00:38:22,060
explicitly tuning memory and there are

00:38:20,020 --> 00:38:24,820
quite a few Numa Numa options in there

00:38:22,060 --> 00:38:28,240
now you can control the placement of

00:38:24,820 --> 00:38:32,560
individual vcpu threads you can control

00:38:28,240 --> 00:38:35,109
the basement of long vcpu threads you

00:38:32,560 --> 00:38:38,560
can control what Numa nodes memory is

00:38:35,109 --> 00:38:42,730
allocated from when you can do all this

00:38:38,560 --> 00:38:45,490
statically or liquids now is able to

00:38:42,730 --> 00:38:48,730
talk to a process called new body and

00:38:45,490 --> 00:38:51,250
new buddy will tell libvirt well this

00:38:48,730 --> 00:38:54,460
Numa notices have good set of resources

00:38:51,250 --> 00:38:55,920
free place the vm on that luminaire so

00:38:54,460 --> 00:38:58,869
you get a bit of automatic newer

00:38:55,920 --> 00:39:01,450
placement there which which helps the

00:38:58,869 --> 00:39:04,349
overall utilization of your new per

00:39:01,450 --> 00:39:09,130
system well that's by no means perfect

00:39:04,349 --> 00:39:12,190
and you can also set up new Matt apology

00:39:09,130 --> 00:39:13,570
inside the guests which beyond sounds a

00:39:12,190 --> 00:39:15,220
lot particularly useful at the moment

00:39:13,570 --> 00:39:17,500
because you really want to be able to

00:39:15,220 --> 00:39:18,940
map the new attack topology in the

00:39:17,500 --> 00:39:20,950
guests through to the new mythology in

00:39:18,940 --> 00:39:23,530
the host and that's an area of active

00:39:20,950 --> 00:39:25,920
discussion of qmu community at the

00:39:23,530 --> 00:39:25,920
moment

00:39:26,540 --> 00:39:31,530
there's a number of flags for

00:39:28,440 --> 00:39:33,510
controlling aspects of memory allocation

00:39:31,530 --> 00:39:35,910
so you can say whether you want explicit

00:39:33,510 --> 00:39:40,970
huge pages whether you want to allow

00:39:35,910 --> 00:39:43,080
memory sharing by the KSM demon and

00:39:40,970 --> 00:39:45,240
whether you want their guesting that way

00:39:43,080 --> 00:39:49,380
to be locked into ram so prevents

00:39:45,240 --> 00:39:51,300
swapping of the guests and and the last

00:39:49,380 --> 00:39:53,760
thing there's a few memory tunable that

00:39:51,300 --> 00:40:00,240
we implement using c groups so you can

00:39:53,760 --> 00:40:02,400
set soft limits hard limits minimum

00:40:00,240 --> 00:40:04,740
guarantees limits on the amount of swap

00:40:02,400 --> 00:40:08,150
you can consume and a few other things

00:40:04,740 --> 00:40:12,300
let's see groups exposes and

00:40:08,150 --> 00:40:15,089
questionable guarantee memory

00:40:12,300 --> 00:40:17,090
last time we checked with the

00:40:15,089 --> 00:40:20,900
guys

00:40:17,090 --> 00:40:23,510
even use anywhere in the kvm competence

00:40:20,900 --> 00:40:26,420
it was used for a six effect or a six

00:40:23,510 --> 00:40:28,170
but it wasn't used for kvm so because we

00:40:26,420 --> 00:40:30,809
use that sunshine

00:40:28,170 --> 00:40:34,440
asml yeah it wasn't used by liquid so

00:40:30,809 --> 00:40:37,049
he's changing once they chosen people

00:40:34,440 --> 00:40:39,059
I'm I'm more short girls that have to

00:40:37,049 --> 00:40:40,049
have to look into that so I've not

00:40:39,059 --> 00:40:44,190
worked on that area of the curve

00:40:40,049 --> 00:40:46,319
recently and prayed and just a couple

00:40:44,190 --> 00:40:49,980
more slides we're basically out of time

00:40:46,319 --> 00:40:53,579
here actually there's tunable foot block

00:40:49,980 --> 00:40:55,079
devices the super guest level tuna boats

00:40:53,579 --> 00:40:57,809
which we implemented using see groups

00:40:55,079 --> 00:41:01,680
and then there's / virtual disk tables

00:40:57,809 --> 00:41:05,760
which we implement using q of yours I am

00:41:01,680 --> 00:41:09,119
limiting for a special disks and we've

00:41:05,760 --> 00:41:11,549
got tuning of network interfaces we have

00:41:09,119 --> 00:41:14,369
you see groups this either because you

00:41:11,549 --> 00:41:16,500
really want your network tunable we set

00:41:14,369 --> 00:41:20,040
on a pair of virtual interface say

00:41:16,500 --> 00:41:21,720
libert directly uses the traffic

00:41:20,040 --> 00:41:24,359
classifier facilities and the next to

00:41:21,720 --> 00:41:27,599
attach policies to the individual tap

00:41:24,359 --> 00:41:29,849
devices and of course you've got some

00:41:27,599 --> 00:41:34,740
limits on the amount of bandwidth

00:41:29,849 --> 00:41:37,170
migration can use and that was really as

00:41:34,740 --> 00:41:38,940
it really and it's a brief whirlwind

00:41:37,170 --> 00:41:41,900
tour of some of the lesser-known liver

00:41:38,940 --> 00:41:46,099
features which I hope you found useful

00:41:41,900 --> 00:41:47,569
and that's a lot

00:41:46,099 --> 00:41:48,859
I think we're out of time for questions

00:41:47,569 --> 00:41:50,509
as well so if you've got any questions

00:41:48,859 --> 00:41:54,440
can we'll see me afterwards separately

00:41:50,509 --> 00:41:57,220
and help yourself to any stickers at the

00:41:54,440 --> 00:41:57,220

YouTube URL: https://www.youtube.com/watch?v=2I--VjDt26w


