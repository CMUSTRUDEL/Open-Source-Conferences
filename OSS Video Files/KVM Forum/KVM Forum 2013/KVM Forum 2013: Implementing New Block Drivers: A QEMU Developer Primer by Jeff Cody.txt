Title: KVM Forum 2013: Implementing New Block Drivers: A QEMU Developer Primer by Jeff Cody
Publication date: 2014-10-30
Playlist: KVM Forum 2013
Description: 
	Slides:  http://bugnik.us/kvm2013/ï»¿

QEMU supports many image formats, ranging from native formats such as QCOW2 and QED, to formats from competing software such as VMDK and Hyper-V, and many others. Each image format is implemented by a new block driver, and new image format patches are fairly common submissions to the QEMU developer mailing list. This talk aims to demystify the process of implementing a new image format, and act as a primer on how to create a new block driver. The interfaces required for a driver implementation are covered, as well as more complex concepts needed to create a fully-functional modern block image driver. These concepts include such topics as coroutines and how they relate to block drivers, backing files, and underlying raw files.
Captions: 
	00:00:01,570 --> 00:00:13,360
I just got a beef on the earpiece and

00:00:08,349 --> 00:00:17,980
you click the reason why like I

00:00:13,360 --> 00:00:24,029
connected to something I gotta be fun

00:00:17,980 --> 00:00:24,029
here like I connected to something okay

00:00:27,390 --> 00:01:10,680
again we call all those in charge okay

00:01:15,570 --> 00:01:24,990
all right all right I'll go ahead and

00:01:19,780 --> 00:01:29,920
get started here my name is Jeff buddy i

00:01:24,990 --> 00:01:31,840
work for red hat and it myself will be

00:01:29,920 --> 00:01:37,420
going over implemented music here new

00:01:31,840 --> 00:01:40,149
block drivers I was in focus focus on

00:01:37,420 --> 00:01:41,710
image format walk drivers but a lot of

00:01:40,149 --> 00:01:48,430
life I thought will be applicable to

00:01:41,710 --> 00:01:49,750
protocol based block drivers as well so

00:01:48,430 --> 00:01:54,210
we'll the first we'll go over some

00:01:49,750 --> 00:01:57,369
background on what block drivers are

00:01:54,210 --> 00:02:00,939
essentially provides storage or a half

00:01:57,369 --> 00:02:04,090
way to storage on the host so that that

00:02:00,939 --> 00:02:08,860
data can be seen as just as a drive or a

00:02:04,090 --> 00:02:11,110
drive image on the guests in the Hume

00:02:08,860 --> 00:02:15,310
you code basis is located in the block

00:02:11,110 --> 00:02:17,260
directory and one caveat is there are

00:02:15,310 --> 00:02:20,739
a few things in that blog directory that

00:02:17,260 --> 00:02:23,459
are not block drivers like commit and

00:02:20,739 --> 00:02:25,630
there and scream those are blocked job

00:02:23,459 --> 00:02:27,580
but the rest of stuff in there for the

00:02:25,630 --> 00:02:29,650
most part of our block drivers and all

00:02:27,580 --> 00:02:36,519
the block image and profile drivers

00:02:29,650 --> 00:02:38,080
resides in that block directory we can

00:02:36,519 --> 00:02:40,660
break down those block drivers into two

00:02:38,080 --> 00:02:42,849
major components like I mentioned before

00:02:40,660 --> 00:02:45,190
where we have image format block drivers

00:02:42,849 --> 00:02:48,459
as well as protocol based raw block

00:02:45,190 --> 00:02:51,519
drivers when I say an image format block

00:02:48,459 --> 00:02:53,620
drivers these are you know what you're

00:02:51,519 --> 00:02:56,560
familiar with when we talk about ql2 or

00:02:53,620 --> 00:03:00,819
QED or and some of the competing

00:02:56,560 --> 00:03:04,180
products we have vmdk files or BHD X

00:03:00,819 --> 00:03:07,620
Files these are a structured Lloyd

00:03:04,180 --> 00:03:11,500
sorted data into the data in the file

00:03:07,620 --> 00:03:14,140
features that are supported in that file

00:03:11,500 --> 00:03:18,400
format I wouldn't be supported just in a

00:03:14,140 --> 00:03:19,930
raw disk although there are raw image

00:03:18,400 --> 00:03:25,000
for my drivers who don't really have any

00:03:19,930 --> 00:03:30,400
features for speak up protocol based

00:03:25,000 --> 00:03:33,430
drivers they might be network-based so

00:03:30,400 --> 00:03:35,650
in a network-based sense you'd have all

00:03:33,430 --> 00:03:38,980
these drivers like bluster August cozy

00:03:35,650 --> 00:03:43,720
and BB receiving some read only ones

00:03:38,980 --> 00:03:49,000
like curl and things like that but then

00:03:43,720 --> 00:03:51,850
we also have protocol drivers that do

00:03:49,000 --> 00:03:57,700
operations on a host to write to a file

00:03:51,850 --> 00:04:00,900
or host devices so if you use a key mu

00:03:57,700 --> 00:04:03,940
instance with a few how to image file

00:04:00,900 --> 00:04:07,720
you'll be using a ql2 image format

00:04:03,940 --> 00:04:12,989
driver on top of a most likely or all

00:04:07,720 --> 00:04:12,989
posix protocol driver

00:04:17,519 --> 00:04:25,930
alright so when we're talking about

00:04:19,419 --> 00:04:27,729
defining the block driver this all comes

00:04:25,930 --> 00:04:31,749
down to being defined initially in the

00:04:27,729 --> 00:04:35,499
block reverse structure a it's an

00:04:31,749 --> 00:04:39,219
internal API structure but it has all

00:04:35,499 --> 00:04:41,680
the function pointers that are used for

00:04:39,219 --> 00:04:44,169
the different entry hooks into your

00:04:41,680 --> 00:04:46,569
image format driver most of them your

00:04:44,169 --> 00:04:47,919
for a basic image format driver you

00:04:46,569 --> 00:04:50,229
don't actually need to support unless

00:04:47,919 --> 00:04:52,689
you support the functionality the block

00:04:50,229 --> 00:04:55,629
later typically has a same default for

00:04:52,689 --> 00:05:01,479
whatever you don't include with some

00:04:55,629 --> 00:05:05,110
exceptions and we'll get into more of

00:05:01,479 --> 00:05:09,870
those player corner so if we can look at

00:05:05,110 --> 00:05:13,930
some core concepts what it goes into a

00:05:09,870 --> 00:05:16,569
block driver there's a lot more than

00:05:13,930 --> 00:05:18,879
what's listed up here but what's up here

00:05:16,569 --> 00:05:20,460
to give us at least a good start to be

00:05:18,879 --> 00:05:27,099
able to implement if nothing else a

00:05:20,460 --> 00:05:30,270
simple block Tyler if your block format

00:05:27,099 --> 00:05:33,539
can be able to be detected the first

00:05:30,270 --> 00:05:37,000
thing what happened with it as a pro

00:05:33,539 --> 00:05:41,199
then we also have open and also reopen

00:05:37,000 --> 00:05:44,589
functionality or our driver we have read

00:05:41,199 --> 00:05:46,539
and write with having through to the use

00:05:44,589 --> 00:05:50,289
of code routines and there's other

00:05:46,539 --> 00:05:51,759
focusable use co routines as well if you

00:05:50,289 --> 00:05:54,610
have an image format driver you likely

00:05:51,759 --> 00:05:56,349
have metadata and so you'll probably

00:05:54,610 --> 00:05:58,360
structures and memory to cash up that

00:05:56,349 --> 00:05:59,919
data and are sometimes we going to be

00:05:58,360 --> 00:06:02,589
aware of the fact that in your cat might

00:05:59,919 --> 00:06:06,219
need to be this artist because it might

00:06:02,589 --> 00:06:10,060
have changed and you also we will cover

00:06:06,219 --> 00:06:14,379
some image creation topics some additive

00:06:10,060 --> 00:06:15,969
handling practices if your that's going

00:06:14,379 --> 00:06:18,610
to have a backing file of the basic

00:06:15,969 --> 00:06:23,740
things will mesa oh and this testing

00:06:18,610 --> 00:06:29,330
deserts built in CMU test squeeze Hume

00:06:23,740 --> 00:06:31,819
uio tests and any new qmu image form

00:06:29,330 --> 00:06:35,780
or protocol format driver should come

00:06:31,819 --> 00:06:41,780
along with Iowa Cox as well I'll make

00:06:35,780 --> 00:06:46,669
Kevin never happy all right so look into

00:06:41,780 --> 00:06:52,789
the pro here actually let me make sure

00:06:46,669 --> 00:06:56,539
everything ok yeah so in a probe your

00:06:52,789 --> 00:06:58,969
driver is past the first 20 48 bytes

00:06:56,539 --> 00:07:00,979
first 2k of the file and this can be

00:06:58,969 --> 00:07:05,300
used to look for header information so

00:07:00,979 --> 00:07:08,599
you can see hey does this file that Q mu

00:07:05,300 --> 00:07:12,080
is program probing artist it doesn't

00:07:08,599 --> 00:07:14,000
file IT support and this example here is

00:07:12,080 --> 00:07:18,440
an example of a VHDX file and you can

00:07:14,000 --> 00:07:22,159
see the kind of magic parada de just a

00:07:18,440 --> 00:07:24,860
stream vh gets file so a VHS image for

00:07:22,159 --> 00:07:28,250
my driver would look at that and say hey

00:07:24,860 --> 00:07:30,830
I think I support this here's the

00:07:28,250 --> 00:07:33,770
example for a qk to where we have to

00:07:30,830 --> 00:07:37,279
apply and we also have an in cute how to

00:07:33,770 --> 00:07:40,129
a version string afterwards as well it's

00:07:37,279 --> 00:07:43,879
part of that that probe are not going to

00:07:40,129 --> 00:07:48,110
stream the version number and so if you

00:07:43,879 --> 00:07:50,900
think that it's yours you return

00:07:48,110 --> 00:07:53,750
confidence score ranging from 0 to 100

00:07:50,900 --> 00:07:56,150
in practice most of the image for my

00:07:53,750 --> 00:07:59,199
drivers by the return 0 100 and sport

00:07:56,150 --> 00:08:02,150
los binary there are some format return

00:07:59,199 --> 00:08:04,339
50 that they're unsure of like a raw

00:08:02,150 --> 00:08:09,889
format where basically your detection is

00:08:04,339 --> 00:08:11,870
and a lack of something now one caveat

00:08:09,889 --> 00:08:13,729
with this is since we're only passing in

00:08:11,870 --> 00:08:16,610
the first two k if all your information

00:08:13,729 --> 00:08:18,110
is identifying information to the

00:08:16,610 --> 00:08:20,539
footage of a header or something like

00:08:18,110 --> 00:08:22,250
that the probe my network do you might

00:08:20,539 --> 00:08:24,199
need to do something a little more to

00:08:22,250 --> 00:08:27,800
extend CMU or figure out a different way

00:08:24,199 --> 00:08:30,259
to detect detect your file you don't get

00:08:27,800 --> 00:08:32,029
a open file pointer far this probe

00:08:30,259 --> 00:08:35,229
you're just get a buffer and a bottom

00:08:32,029 --> 00:08:35,229
line so

00:08:37,500 --> 00:08:42,300
we'll look at an example pro piernas

00:08:39,180 --> 00:08:47,010
cystic you how to pro and we can see we

00:08:42,300 --> 00:08:48,870
get to the buffer in we do our Indian

00:08:47,010 --> 00:08:51,660
conversion on it we'll get more into

00:08:48,870 --> 00:08:53,750
later support the data handling but if

00:08:51,660 --> 00:08:58,200
they would read off a disk we assume is

00:08:53,750 --> 00:09:02,790
not in our floor mat and in this case if

00:08:58,200 --> 00:09:08,400
it sees its magic file which was the qfi

00:09:02,790 --> 00:09:09,630
there and version is greater equal to so

00:09:08,400 --> 00:09:11,610
it's over thank you fell to will

00:09:09,630 --> 00:09:14,070
recognize and it returns 100 otherwise

00:09:11,610 --> 00:09:19,500
it just bailed out the concealing that

00:09:14,070 --> 00:09:25,680
probe will continue if we look at this

00:09:19,500 --> 00:09:28,200
open flow here why once I'm not before

00:09:25,680 --> 00:09:30,960
when we're all seeing when Q goes open

00:09:28,200 --> 00:09:32,850
up a file with it the formats not

00:09:30,960 --> 00:09:36,360
explicitly get into a little gauge in

00:09:32,850 --> 00:09:39,150
the probe if the media is present and

00:09:36,360 --> 00:09:43,370
the underlying device then a reads that

00:09:39,150 --> 00:09:47,880
first 2048 bites will go through each

00:09:43,370 --> 00:09:50,670
registered driver and called probe and

00:09:47,880 --> 00:09:54,480
image format is found the new either

00:09:50,670 --> 00:09:59,850
call the driver file open if it's a

00:09:54,480 --> 00:10:05,610
protocol based or b driver open image

00:09:59,850 --> 00:10:11,940
format so we'll jump in here and

00:10:05,610 --> 00:10:14,610
implement a very basic image for my

00:10:11,940 --> 00:10:17,160
driver that does absolutely nothing it's

00:10:14,610 --> 00:10:19,980
useless but it'll give us a like an idea

00:10:17,160 --> 00:10:21,589
here we'll just call this one the silly

00:10:19,980 --> 00:10:24,830
formats that doesn't do anything as

00:10:21,589 --> 00:10:26,610
minimum but we need for this as we need

00:10:24,830 --> 00:10:31,080
blocking this is set up our

00:10:26,610 --> 00:10:32,310
initialization register our driver

00:10:31,080 --> 00:10:34,500
structure that we talked about earlier

00:10:32,310 --> 00:10:38,430
that defines the function pointers and

00:10:34,500 --> 00:10:42,750
some other variables this will basically

00:10:38,430 --> 00:10:44,040
make us visible to TMU so we can be

00:10:42,750 --> 00:10:47,100
called when we're searching for a

00:10:44,040 --> 00:10:49,860
protocol or driver map and we need a

00:10:47,100 --> 00:10:51,089
format name and the phase ours as silly

00:10:49,860 --> 00:10:54,990
as we said

00:10:51,089 --> 00:10:58,230
and we you blocked ever must also have a

00:10:54,990 --> 00:11:00,749
block driver open there's nothing to

00:10:58,230 --> 00:11:02,160
fault for not having an open if you

00:11:00,749 --> 00:11:09,240
can't have a null function pointer for

00:11:02,160 --> 00:11:12,870
that open little caesars code here so

00:11:09,240 --> 00:11:16,379
read it from the bottom up you stressing

00:11:12,870 --> 00:11:19,499
so much a lot of space drivers we have

00:11:16,379 --> 00:11:21,559
our blocking net macro that basically

00:11:19,499 --> 00:11:26,370
just creates our initialization function

00:11:21,559 --> 00:11:30,600
that the block and I've actually a knit

00:11:26,370 --> 00:11:32,100
there and that registers are a block

00:11:30,600 --> 00:11:35,850
reverse structure which is right above

00:11:32,100 --> 00:11:37,920
it which paints our format name and then

00:11:35,850 --> 00:11:40,170
the function pointer for our open and

00:11:37,920 --> 00:11:42,420
then our open is immediately about that

00:11:40,170 --> 00:11:45,749
and it doesn't do anything to return 0

00:11:42,420 --> 00:11:47,249
so it's not functional but this as an

00:11:45,749 --> 00:11:51,839
actual block or everyone will compile

00:11:47,249 --> 00:12:01,860
and be present inside qmu and also be

00:11:51,839 --> 00:12:06,509
useful but so another part of when you

00:12:01,860 --> 00:12:09,809
are opening your your block driver an

00:12:06,509 --> 00:12:13,079
important part in there is a faithful

00:12:09,809 --> 00:12:14,850
data that you have in your driver if

00:12:13,079 --> 00:12:17,129
you're almost every driver is going to

00:12:14,850 --> 00:12:18,509
have data that I'm like it's at for

00:12:17,129 --> 00:12:25,139
metadata your caption or other

00:12:18,509 --> 00:12:28,379
information needs a lot and so the way

00:12:25,139 --> 00:12:30,269
this is done is you when you're open the

00:12:28,379 --> 00:12:32,759
block driver state function pointers

00:12:30,269 --> 00:12:36,689
past you will have an opaque void

00:12:32,759 --> 00:12:39,480
pointer that will be the place where you

00:12:36,689 --> 00:12:41,970
can put all your state data the size of

00:12:39,480 --> 00:12:45,449
that is determined again by that block

00:12:41,970 --> 00:12:46,829
driver structure we didn't populate it

00:12:45,449 --> 00:12:51,179
in our example here but i'll show you an

00:12:46,829 --> 00:12:53,069
example later on what we do and you

00:12:51,179 --> 00:12:55,439
don't have anything to allocate this or

00:12:53,069 --> 00:12:58,110
free this the block layer will do that

00:12:55,439 --> 00:13:00,240
for you above you so once you get past

00:12:58,110 --> 00:13:02,660
that pointer it should be allocated at

00:13:00,240 --> 00:13:02,660
that point

00:13:06,290 --> 00:13:13,020
so what are open needs to really do at a

00:13:09,660 --> 00:13:14,760
minimum is we need to verify the

00:13:13,020 --> 00:13:18,029
integrity of our image if that's

00:13:14,760 --> 00:13:21,290
possible if your format has a sort of

00:13:18,029 --> 00:13:24,300
check something or any way to verify it

00:13:21,290 --> 00:13:26,730
populate our internal state data and add

00:13:24,300 --> 00:13:28,709
opaque blog because that's what we're

00:13:26,730 --> 00:13:30,810
going to be able to each one that calls

00:13:28,709 --> 00:13:35,310
into each one of our function pointers

00:13:30,810 --> 00:13:37,140
as defined in that block structure that

00:13:35,310 --> 00:13:38,490
will paste blob is what's going to be

00:13:37,140 --> 00:13:39,720
consistent than once another that we're

00:13:38,490 --> 00:13:41,550
going to be able to see is our state

00:13:39,720 --> 00:13:45,089
data for that open instance of that

00:13:41,550 --> 00:13:46,980
drive or on that image I should say and

00:13:45,089 --> 00:13:48,450
if it's relevant for your driver for an

00:13:46,980 --> 00:13:50,880
image format driver or something like

00:13:48,450 --> 00:13:58,560
that I'm the total number of sectors so

00:13:50,880 --> 00:14:01,050
that you know how large the driver is in

00:13:58,560 --> 00:14:06,140
addition to open there's also a reopen

00:14:01,050 --> 00:14:09,540
functionality this allows an ad and a

00:14:06,140 --> 00:14:13,110
block driver image as be opened with new

00:14:09,540 --> 00:14:18,180
flag this is often used with block jobs

00:14:13,110 --> 00:14:21,720
such as block mid or live snapshots or

00:14:18,180 --> 00:14:25,680
we need to modify a chain of images and

00:14:21,720 --> 00:14:27,630
some of those images may be read-only so

00:14:25,680 --> 00:14:30,839
we need to read reopen them so they can

00:14:27,630 --> 00:14:32,880
be rewrite and we can modify it so if

00:14:30,839 --> 00:14:36,000
your support for this is awesome for

00:14:32,880 --> 00:14:40,140
your driver but there are three books

00:14:36,000 --> 00:14:43,380
reopen there's a prepare hook commit and

00:14:40,140 --> 00:14:46,140
in the board hook anything you do in the

00:14:43,380 --> 00:14:51,329
prepare for the reopen you should be

00:14:46,140 --> 00:14:58,200
able to undo so if this way I'm you can

00:14:51,329 --> 00:14:59,940
we reopen multiple block images and one

00:14:58,200 --> 00:15:01,589
of them fails we can undo the whole

00:14:59,940 --> 00:15:05,670
thing and do that as an atomic set

00:15:01,589 --> 00:15:07,320
rather than leaving the system in some

00:15:05,670 --> 00:15:11,150
sort of indeterminate state because we

00:15:07,320 --> 00:15:11,150
got halfway through an operation

00:15:12,889 --> 00:15:18,290
is one where they're saying defaults for

00:15:14,839 --> 00:15:22,459
everything both for my drivers class

00:15:18,290 --> 00:15:27,350
will do anything or commit or a board or

00:15:22,459 --> 00:15:29,149
even in prepare other than you have a

00:15:27,350 --> 00:15:32,749
prepared if you're going to support to

00:15:29,149 --> 00:15:35,839
reopen functionality most image formats

00:15:32,749 --> 00:15:37,759
is just returned zeros stuff so I'm

00:15:35,839 --> 00:15:40,850
image formats like the mdk2 might have a

00:15:37,759 --> 00:15:43,609
digital file extents it has additional

00:15:40,850 --> 00:15:46,609
class but it open so it is real and it

00:15:43,609 --> 00:15:48,019
has to queue up each one of those reopen

00:15:46,609 --> 00:15:51,859
so they'd have some things to do in

00:15:48,019 --> 00:15:55,279
their protocols drivers will likely have

00:15:51,859 --> 00:15:58,179
more to do particularly for instance

00:15:55,279 --> 00:16:01,329
inside the commitment aboard functions

00:15:58,179 --> 00:16:06,079
it does there was are probably actually

00:16:01,329 --> 00:16:09,019
changing the flag turtles for the opened

00:16:06,079 --> 00:16:12,919
underlying file pointer or whatever on

00:16:09,019 --> 00:16:16,730
the system so in case of acute altitude

00:16:12,919 --> 00:16:20,660
image file on Linux brawl posits would

00:16:16,730 --> 00:16:23,029
be the one that would have a snit and

00:16:20,660 --> 00:16:34,939
abort that would actually go through and

00:16:23,029 --> 00:16:36,470
do file reopen all right so when we do

00:16:34,939 --> 00:16:39,619
to our read and write functionality

00:16:36,470 --> 00:16:41,089
we're gonna use kill routine this won't

00:16:39,619 --> 00:16:42,019
get to indefinitely cell routines I'm

00:16:41,089 --> 00:16:43,850
just going to kind of mention that

00:16:42,019 --> 00:16:45,350
you're here and that they use them but

00:16:43,850 --> 00:16:48,559
we could give a whole presentation just

00:16:45,350 --> 00:16:53,119
Confederate teens and probably wouldn't

00:16:48,559 --> 00:16:55,189
be me giving it so it it's very complex

00:16:53,119 --> 00:16:57,829
under the covers from the perspective of

00:16:55,189 --> 00:17:00,189
the image from the blog drivers not a

00:16:57,829 --> 00:17:02,239
lot you need to be concerned about their

00:17:00,189 --> 00:17:03,949
and the Philippines actually make your

00:17:02,239 --> 00:17:07,669
life easier because it handles so many

00:17:03,949 --> 00:17:11,240
things for a thickness access but you

00:17:07,669 --> 00:17:15,139
don't need to worry about the big thing

00:17:11,240 --> 00:17:17,600
they remember is that inside if we could

00:17:15,139 --> 00:17:19,579
use an encoding for instance in read and

00:17:17,600 --> 00:17:22,159
write that's a control toast and your

00:17:19,579 --> 00:17:25,569
function until you either deal or your

00:17:22,159 --> 00:17:25,569
your function returns

00:17:25,600 --> 00:17:31,150
so it's not pre-emptive you can fill

00:17:28,510 --> 00:17:37,630
into a loop expect that other things are

00:17:31,150 --> 00:17:39,820
going to happen unless you yield so how

00:17:37,630 --> 00:17:42,010
does your driver use code routines we

00:17:39,820 --> 00:17:46,059
basically just two things you need to

00:17:42,010 --> 00:17:48,220
remember to use you Tex lock and unlock

00:17:46,059 --> 00:17:51,370
to lock them up new texts around

00:17:48,220 --> 00:17:53,260
critical sections and your data access

00:17:51,370 --> 00:17:56,440
particularly know when you're reading

00:17:53,260 --> 00:17:58,419
writing metadata for instance and he'll

00:17:56,440 --> 00:18:00,880
defeat and some new protocol divers is

00:17:58,419 --> 00:18:05,260
my client like if you if you're waiting

00:18:00,880 --> 00:18:08,500
for i misspell veal there sorry if

00:18:05,260 --> 00:18:10,270
you're waiting for another operation or

00:18:08,500 --> 00:18:13,630
so much again you may want to yield

00:18:10,270 --> 00:18:18,760
rather than then agha fault up all the

00:18:13,630 --> 00:18:22,030
time and then the other centi-

00:18:18,760 --> 00:18:24,780
everything uses go routines even if you

00:18:22,030 --> 00:18:28,270
don't implement a co-working specific

00:18:24,780 --> 00:18:30,100
rewrite there's a rapid wrappers around

00:18:28,270 --> 00:18:31,390
in that the block letter codes i

00:18:30,100 --> 00:18:37,030
basically essentially converted

00:18:31,390 --> 00:18:38,350
everything to co routines so it's better

00:18:37,030 --> 00:18:40,539
for you just go ahead and brace it that

00:18:38,350 --> 00:18:49,929
way you can improve your performance by

00:18:40,539 --> 00:18:55,390
improving your walk granularity all

00:18:49,929 --> 00:18:58,960
right so look at a very simple I'd flow

00:18:55,390 --> 00:19:04,360
for an eye out for my driver for for

00:18:58,960 --> 00:19:07,929
reusing IL vectors and such darling

00:19:04,360 --> 00:19:10,179
neutralizes new IL vector obtain a mutex

00:19:07,929 --> 00:19:13,120
the authority mutex for its driver

00:19:10,179 --> 00:19:19,080
instance and while it still suckers to

00:19:13,120 --> 00:19:24,070
be read populate you do i 0 vector

00:19:19,080 --> 00:19:27,760
available data release your mutex law

00:19:24,070 --> 00:19:30,010
and then call the isle dr redone online

00:19:27,760 --> 00:19:34,270
protocol again we're talking on image

00:19:30,010 --> 00:19:37,059
format driver here and then really

00:19:34,270 --> 00:19:38,440
obtain your new facts until you only

00:19:37,059 --> 00:19:40,809
have any more seconds to read

00:19:38,440 --> 00:19:43,419
I want to earn annihilation of course

00:19:40,809 --> 00:19:52,029
release our defects again before they've

00:19:43,419 --> 00:19:56,409
done there in the right incense that's

00:19:52,029 --> 00:19:59,169
going to be very similar everything is

00:19:56,409 --> 00:20:01,600
very analogous to read the only

00:19:59,169 --> 00:20:04,360
difference is you need to make we need

00:20:01,600 --> 00:20:07,750
to make sure data on the disk is stable

00:20:04,360 --> 00:20:11,580
before we update any of our meta data in

00:20:07,750 --> 00:20:14,200
an image file so if all involve using

00:20:11,580 --> 00:20:19,509
functionality such as black rock or

00:20:14,200 --> 00:20:22,600
flush or so that you can keep a

00:20:19,509 --> 00:20:24,700
consistent image format in case of a

00:20:22,600 --> 00:20:33,039
crash of key of you or something like

00:20:24,700 --> 00:20:34,779
that alright so we'll get into some

00:20:33,039 --> 00:20:37,240
pockets of metadata caching there's not

00:20:34,779 --> 00:20:40,149
a whole lot to do here but the problems

00:20:37,240 --> 00:20:43,450
metadata caching is it can cause

00:20:40,149 --> 00:20:45,309
problems how's every little a driver or

00:20:43,450 --> 00:20:50,909
area mat for my drivers donated cash

00:20:45,309 --> 00:20:52,960
metadata but in case of live migrate

00:20:50,909 --> 00:20:56,049
doesn't our problems we need to know

00:20:52,960 --> 00:20:58,269
when to get rid of that if metade is

00:20:56,049 --> 00:21:04,179
getting overrun by the live migration

00:20:58,269 --> 00:21:06,190
process so in this case he doesn't

00:21:04,179 --> 00:21:08,289
causing problems we all need to worry

00:21:06,190 --> 00:21:10,090
too much about it because we can

00:21:08,289 --> 00:21:13,799
invalidate the metadata when requested

00:21:10,090 --> 00:21:13,799
or we can prevent migration all together

00:21:15,509 --> 00:21:20,860
if you want to support a lot i'm alive

00:21:18,429 --> 00:21:24,039
migration in your driver you need to

00:21:20,860 --> 00:21:25,750
respond to the invalidated cash calling

00:21:24,039 --> 00:21:28,539
you to populate down your blocks front

00:21:25,750 --> 00:21:30,940
and do what you need to do the

00:21:28,539 --> 00:21:32,740
invalidate your metadata attached if you

00:21:30,940 --> 00:21:34,929
don't want to do that which is the case

00:21:32,740 --> 00:21:38,590
for a lot of the compatibility image for

00:21:34,929 --> 00:21:41,289
my drivers like dmpk or VHDX or be bii

00:21:38,590 --> 00:21:43,029
for virtual box there's everyone can

00:21:41,289 --> 00:21:45,460
kind of building up for performance not

00:21:43,029 --> 00:21:48,730
for enterprise use really so in that

00:21:45,460 --> 00:21:52,150
case there's my great I blocker where we

00:21:48,730 --> 00:21:53,860
can essentially register a cuter and

00:21:52,150 --> 00:21:55,630
I fill my fries do you fight my

00:21:53,860 --> 00:22:07,570
greatness just give back the Hermes

00:21:55,630 --> 00:22:08,980
position and will kill do it so chances

00:22:07,570 --> 00:22:10,630
are if you have an inner core driver

00:22:08,980 --> 00:22:13,450
you're also going to want to create an

00:22:10,630 --> 00:22:16,660
image format and in this case there's

00:22:13,450 --> 00:22:18,070
the create functionality stub that's

00:22:16,660 --> 00:22:20,890
then again to find enough block

00:22:18,070 --> 00:22:23,140
structure you don't score courageously

00:22:20,890 --> 00:22:24,580
vis unpopulated and you won't be able to

00:22:23,140 --> 00:22:30,370
create and which one it just won't be a

00:22:24,580 --> 00:22:33,100
supported formats being if you do this

00:22:30,370 --> 00:22:34,750
for a parade also i need to defy your

00:22:33,100 --> 00:22:37,360
team you option parameters which

00:22:34,750 --> 00:22:41,740
basically a structure that justifies

00:22:37,360 --> 00:22:44,470
what options qmu image will take for

00:22:41,740 --> 00:22:47,620
your create present to the size of the

00:22:44,470 --> 00:22:49,930
image which is a required one or perhaps

00:22:47,620 --> 00:22:53,860
you want to give it some information

00:22:49,930 --> 00:22:57,010
like cluster size or other data like

00:22:53,860 --> 00:23:02,400
that and you can accept it as creating a

00:22:57,010 --> 00:23:02,400
flag so like a boolean or just a number

00:23:06,600 --> 00:23:11,050
so we've talked about the block driver

00:23:08,740 --> 00:23:13,210
struck some and we've talked about some

00:23:11,050 --> 00:23:17,740
of the different functionality i just

00:23:13,210 --> 00:23:20,050
want to give i will look at the q county

00:23:17,740 --> 00:23:23,860
one with some of the extra functionality

00:23:20,050 --> 00:23:25,480
snipped out that we didn't ever let in

00:23:23,860 --> 00:23:29,110
this case with you cal to you can see

00:23:25,480 --> 00:23:32,890
the format name the instant size which

00:23:29,110 --> 00:23:36,880
is what we'll use allocated state

00:23:32,890 --> 00:23:40,450
information for the inner opaque pointer

00:23:36,880 --> 00:23:43,930
on the fritz Pro Open clothes it's

00:23:40,450 --> 00:23:49,360
reopen prepare its create and then it's

00:23:43,930 --> 00:23:51,610
reading right vectors and then up a + @

00:23:49,360 --> 00:23:54,580
OS which we didn't cover but as the

00:23:51,610 --> 00:23:56,830
silicon thickens flushed any day out to

00:23:54,580 --> 00:23:58,510
the OS layer so in the community q mu

00:23:56,830 --> 00:24:01,630
two crashes consistent but not

00:23:58,510 --> 00:24:03,580
necessarily LS press level crash and

00:24:01,630 --> 00:24:05,720
then we just like our create options

00:24:03,580 --> 00:24:10,070
will there the create options

00:24:05,720 --> 00:24:11,420
we just give it a point to the create

00:24:10,070 --> 00:24:20,360
option structure that we would have

00:24:11,420 --> 00:24:24,830
created earlier so some data handling

00:24:20,360 --> 00:24:27,860
the practices when we're reading stuff

00:24:24,830 --> 00:24:30,650
in the disk we can't trust it we do need

00:24:27,860 --> 00:24:35,480
to pack it and we do need to do proper

00:24:30,650 --> 00:24:36,980
engine conversion on it the data we have

00:24:35,480 --> 00:24:39,830
to assume that the data when we read it

00:24:36,980 --> 00:24:41,390
off of them the desk or over at Network

00:24:39,830 --> 00:24:45,170
I shouldn't keep saying disk and a half

00:24:41,390 --> 00:24:47,990
network proto but anything it

00:24:45,170 --> 00:24:53,780
comes in not generated by TM you it

00:24:47,990 --> 00:24:56,540
shouldn't be trusted we can have issues

00:24:53,780 --> 00:25:00,260
like allocate more memory than its

00:24:56,540 --> 00:25:03,290
intended or is saying leading to denial

00:25:00,260 --> 00:25:05,270
of service and we don't want to read a

00:25:03,290 --> 00:25:07,700
right pass and he buffers internally if

00:25:05,270 --> 00:25:09,890
you're not validating data you open

00:25:07,700 --> 00:25:11,390
yourself up to the possibility and we

00:25:09,890 --> 00:25:16,970
don't do anything in general just crash

00:25:11,390 --> 00:25:20,570
p.m. you so all data comes in validate

00:25:16,970 --> 00:25:22,670
that it's within spec it also validate

00:25:20,570 --> 00:25:23,960
the combinations of the calculations you

00:25:22,670 --> 00:25:26,170
doing off to even things that are

00:25:23,960 --> 00:25:31,130
inspect individually create a whole

00:25:26,170 --> 00:25:37,540
holistic expect that that's valid as

00:25:31,130 --> 00:25:41,560
well and when it comes to packing and

00:25:37,540 --> 00:25:47,600
Indian conversion this is to keep your

00:25:41,560 --> 00:25:49,400
image format and everything portable so

00:25:47,600 --> 00:25:51,050
your structures that you're reading or

00:25:49,400 --> 00:25:53,990
writing from the disk when you're

00:25:51,050 --> 00:25:56,210
bringing it into memory and CMU you have

00:25:53,990 --> 00:25:57,950
them in whatever format you want for

00:25:56,210 --> 00:26:00,650
when it's coming directly from disk or

00:25:57,950 --> 00:26:03,560
from network or two disks or to network

00:26:00,650 --> 00:26:05,660
you could you should pack those

00:26:03,560 --> 00:26:08,800
structures so that there's no padding

00:26:05,660 --> 00:26:11,240
introduced by compiler based alignment

00:26:08,800 --> 00:26:14,960
that's going to from what architecture

00:26:11,240 --> 00:26:16,760
or one compiler to another and the same

00:26:14,960 --> 00:26:18,320
thing goes with Indian asst and the

00:26:16,760 --> 00:26:19,220
problem is not doing this as the chances

00:26:18,320 --> 00:26:20,780
are it's going to work for you

00:26:19,220 --> 00:26:23,090
we'll see other people that we're all

00:26:20,780 --> 00:26:26,570
probably doing a lot of testing on x86

00:26:23,090 --> 00:26:28,760
under linux and it work but then at some

00:26:26,570 --> 00:26:31,150
point probably get some weird bug

00:26:28,760 --> 00:26:33,980
someplace because i want i just use that

00:26:31,150 --> 00:26:36,429
but you created on an arm system or

00:26:33,980 --> 00:26:39,799
something like that and it doesn't work

00:26:36,429 --> 00:26:47,990
so it's up to to get that stuff taken

00:26:39,799 --> 00:26:49,730
care right out of the game and back and

00:26:47,990 --> 00:26:55,070
files if you want to support backing

00:26:49,730 --> 00:26:57,200
files inside your open functionality you

00:26:55,070 --> 00:26:59,510
need to identify the backup file for

00:26:57,200 --> 00:27:02,770
your format it likely probably be in the

00:26:59,510 --> 00:27:05,960
metadata for whatever format you have

00:27:02,770 --> 00:27:08,840
created a driver for and you need to

00:27:05,960 --> 00:27:12,559
populate the GE basking file screen and

00:27:08,840 --> 00:27:16,520
the block drivers safe structure points

00:27:12,559 --> 00:27:20,240
past you this will be used by a block

00:27:16,520 --> 00:27:23,809
later open is then open up the back and

00:27:20,240 --> 00:27:28,900
file underneath it and you also need to

00:27:23,809 --> 00:27:31,760
support the get block status

00:27:28,900 --> 00:27:35,059
functionality as well what i believe you

00:27:31,760 --> 00:27:39,110
default is allocated but you know that

00:27:35,059 --> 00:27:43,549
the driver so that we can determine

00:27:39,110 --> 00:27:46,640
which suckers are allocated inside which

00:27:43,549 --> 00:27:49,460
images if that's not support is it soon

00:27:46,640 --> 00:27:51,710
that all the suckers allocated in your

00:27:49,460 --> 00:27:59,929
image and so you won't feel it go down

00:27:51,710 --> 00:28:03,919
through the the chain so now we're going

00:27:59,929 --> 00:28:07,940
to get to testing there's a great

00:28:03,919 --> 00:28:12,100
testing framework inside pw for do

00:28:07,940 --> 00:28:14,809
create test for image formats or just

00:28:12,100 --> 00:28:18,530
block jobs even our hume you IA

00:28:14,809 --> 00:28:22,370
operations inside he needs inside the

00:28:18,530 --> 00:28:24,380
test team uio test directory you can

00:28:22,370 --> 00:28:25,730
create the test and bachelor Python I

00:28:24,380 --> 00:28:27,890
thought he's really created it anything

00:28:25,730 --> 00:28:31,299
but there's already support libraries in

00:28:27,890 --> 00:28:31,299
place for batch for Python

00:28:32,400 --> 00:28:39,520
now allow you to use Q me to IO

00:28:36,550 --> 00:28:43,750
operations and you can image and even

00:28:39,520 --> 00:28:47,830
run cunyfirst and simple stuff the file

00:28:43,750 --> 00:28:50,860
names are just a three-letter

00:28:47,830 --> 00:28:53,970
three-digit test number and then the

00:28:50,860 --> 00:28:56,320
expected output and on an error and

00:28:53,970 --> 00:28:58,120
error determined just by dipping the

00:28:56,320 --> 00:29:00,760
expected output with the output that

00:28:58,120 --> 00:29:02,890
really occurs so whatever output comes

00:29:00,760 --> 00:29:07,480
from your cut strips needs to match what

00:29:02,890 --> 00:29:09,700
you put in the expected output and you

00:29:07,480 --> 00:29:11,920
can also test sample images so if you're

00:29:09,700 --> 00:29:15,490
creating an image format driver for

00:29:11,920 --> 00:29:19,480
compatibility reasons for vmdk d div

00:29:15,490 --> 00:29:22,900
VHDX there is now an accumulate assets

00:29:19,480 --> 00:29:25,120
at samples images directory you can

00:29:22,900 --> 00:29:27,940
actually put an image in there there's

00:29:25,120 --> 00:29:29,560
an emphasis in there now for VHDX the

00:29:27,940 --> 00:29:32,200
only caveat is we don't want you know

00:29:29,560 --> 00:29:35,260
one gig images inside you can be sourced

00:29:32,200 --> 00:29:38,470
rig right so the images in there should

00:29:35,260 --> 00:29:42,030
be compressed down to really fall and

00:29:38,470 --> 00:29:45,340
some of the pantages for vhtf and VHDX

00:29:42,030 --> 00:29:48,790
exploded as a 400 Meg image but impress

00:29:45,340 --> 00:29:51,880
with these of two 874 bites because the

00:29:48,790 --> 00:29:55,570
data all inside there is all repeated

00:29:51,880 --> 00:29:57,820
patterns and so when you use compression

00:29:55,570 --> 00:30:00,970
like these up to as run-length encoding

00:29:57,820 --> 00:30:04,060
and August compress way down but that

00:30:00,970 --> 00:30:05,710
allows you to test against the acid

00:30:04,060 --> 00:30:07,810
golem source for whatever image format

00:30:05,710 --> 00:30:10,810
you're creating the problem is if we

00:30:07,810 --> 00:30:14,290
only test external image formats that we

00:30:10,810 --> 00:30:16,000
support for compatibility reasons if we

00:30:14,290 --> 00:30:18,550
only because those against what we

00:30:16,000 --> 00:30:19,810
create with human image create we're not

00:30:18,550 --> 00:30:21,700
necessarily testing we're compatible

00:30:19,810 --> 00:30:23,590
with the Act expect we're just test

00:30:21,700 --> 00:30:28,180
networking cobble with what we creating

00:30:23,590 --> 00:30:29,800
sales expect so like for instance again

00:30:28,180 --> 00:30:33,340
in the pH deck when I was an image file

00:30:29,800 --> 00:30:35,500
that was created by IP hyper-v and then

00:30:33,340 --> 00:30:38,590
copied over for the test so now we can

00:30:35,500 --> 00:30:41,830
run test read and write and verify that

00:30:38,590 --> 00:30:43,990
it works and we could read and write a

00:30:41,830 --> 00:30:45,220
known pattern back and forth to that

00:30:43,990 --> 00:30:47,860
image file

00:30:45,220 --> 00:30:51,100
and then we are early stop Bible with

00:30:47,860 --> 00:30:53,169
the spec so you're creating an image for

00:30:51,100 --> 00:31:03,970
another for an ability I would I was

00:30:53,169 --> 00:31:08,820
just be you said all right and I just

00:31:03,970 --> 00:31:11,770
really touches on a on the very top of

00:31:08,820 --> 00:31:13,600
the depth that is creating a block block

00:31:11,770 --> 00:31:16,150
there's a lot of advanced function Elia

00:31:13,600 --> 00:31:20,940
you can dive into some of which probably

00:31:16,150 --> 00:31:24,970
only applies to certain image formats

00:31:20,940 --> 00:31:26,860
whatever place look in the block in edit

00:31:24,970 --> 00:31:28,750
and you'll see the block driver

00:31:26,860 --> 00:31:34,950
structure and you can look at all the

00:31:28,750 --> 00:31:53,409
different functional is in there as it

00:31:34,950 --> 00:31:58,600
is he won't have any questions right now

00:31:53,409 --> 00:32:00,370
it just supports one file but a per test

00:31:58,600 --> 00:32:03,909
case I mean you have opal files multiple

00:32:00,370 --> 00:32:47,770
tests but that would certainly be hard

00:32:03,909 --> 00:32:49,480
to write it is confusing the adjuster

00:32:47,770 --> 00:32:52,570
questions backwards first that was

00:32:49,480 --> 00:32:55,960
though functions that are unlike on the

00:32:52,570 --> 00:32:57,669
Torico whatever art was that are being

00:32:55,960 --> 00:32:58,300
called explicitly when you know you're

00:32:57,669 --> 00:33:01,000
in the correct

00:32:58,300 --> 00:33:02,080
in context and so you only use those

00:33:01,000 --> 00:33:06,550
when you do know that you're in the

00:33:02,080 --> 00:33:09,700
co-working context however you are

00:33:06,550 --> 00:33:11,830
usually safe and just calling the one

00:33:09,700 --> 00:33:14,770
without it like instead of flushed into

00:33:11,830 --> 00:33:17,320
be driver co-wash you'd be called be

00:33:14,770 --> 00:33:19,000
driver flush and the block later it will

00:33:17,320 --> 00:33:21,280
actually look a lil detective here in

00:33:19,000 --> 00:33:22,780
the Philippine context or not and if so

00:33:21,280 --> 00:33:28,180
it will jump to the shore that up wise

00:33:22,780 --> 00:33:33,340
it will create a cover to trapper now as

00:33:28,180 --> 00:33:37,360
far as why you need the mutex I get a

00:33:33,340 --> 00:33:39,370
little hazy on some of that as well when

00:33:37,360 --> 00:33:42,580
you there are times when it can be

00:33:39,370 --> 00:33:45,310
reentrant depending on the I believe in

00:33:42,580 --> 00:33:47,440
ail case and Kevin you can jump in and

00:33:45,310 --> 00:33:50,290
correct me if I'm wrong I'm ended up but

00:33:47,440 --> 00:33:53,230
I believe in one since on the aio cases

00:33:50,290 --> 00:33:57,340
you can get some of the entrance step 2

00:33:53,230 --> 00:33:58,750
um and also i'm particularly when it

00:33:57,340 --> 00:34:41,470
released him when you're going to your

00:33:58,750 --> 00:34:43,660
underlying drivers as well just give us

00:34:41,470 --> 00:34:45,790
waiting for me you're not gonna create

00:34:43,660 --> 00:34:48,820
loss coaching are always visualized

00:34:45,790 --> 00:34:50,820
under your hat if that makes any bad

00:34:48,820 --> 00:34:56,880
just reading like a credit-based guys

00:34:50,820 --> 00:34:56,880
need to achieve another school and

00:36:00,519 --> 00:36:05,779
all right in yellow on just one more

00:36:03,349 --> 00:36:26,349
thing gonna question do not have a pro

00:36:05,779 --> 00:36:26,349
an untrusted destroy you anyway you got

00:36:27,369 --> 00:36:38,140
who did you don't get all the rope over

00:36:32,959 --> 00:36:45,259
you get 2,000 phone and there goes to

00:36:38,140 --> 00:36:46,910
thank you and that's where it be good

00:36:45,259 --> 00:36:48,650
from image format drivers or not all of

00:36:46,910 --> 00:36:50,660
them have this in there I don't think

00:36:48,650 --> 00:36:52,579
you count to the spider but to have

00:36:50,660 --> 00:37:01,029
check comes around some that's metadata

00:36:52,579 --> 00:37:05,119
but in that case yeah let me say you're

00:37:01,029 --> 00:37:09,249
joking the state to make sure that you

00:37:05,119 --> 00:37:09,249
always do

00:37:15,369 --> 00:37:23,119
keeping up I can just make the mall of

00:37:21,290 --> 00:37:27,080
georgia music because they don't have so

00:37:23,119 --> 00:37:29,750
much experience it easily a sign of

00:37:27,080 --> 00:37:34,310
course i remember i looked at happen

00:37:29,750 --> 00:37:36,260
Adam anything sudden amin 20 music space

00:37:34,310 --> 00:37:39,619
to call in two days and instead of

00:37:36,260 --> 00:37:41,960
shewbread it's like a pre-recording if

00:37:39,619 --> 00:37:43,940
they're already collecting money running

00:37:41,960 --> 00:37:46,100
with his Maddox and it's just a shoe

00:37:43,940 --> 00:37:49,670
attack if I remember the addition is

00:37:46,100 --> 00:37:53,359
just an indication that it faces they

00:37:49,670 --> 00:38:12,920
had nominated with less linear have the

00:37:53,359 --> 00:38:18,340
Golgi textbook coach I think we have a

00:38:12,920 --> 00:38:18,340

YouTube URL: https://www.youtube.com/watch?v=ybNaEeQ2jgo


