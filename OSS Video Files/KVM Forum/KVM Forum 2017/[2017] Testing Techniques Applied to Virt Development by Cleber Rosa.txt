Title: [2017] Testing Techniques Applied to Virt Development by Cleber Rosa
Publication date: 2017-11-22
Playlist: KVM Forum 2017
Description: 
	Software Testing practitioners are aware of testing strategies that exceed the developer's usual approach to test. While it is understandable that the two roles are inherently different, there are some strategies (and tools) that can greatly benefit how code is tested during development.

This talk will present the theory behind techniques such as Equivalence Partitioning, Boundary Value Analysis and Combinatorial Testing backed by real world virtualization code and use cases.

Finally, to break out of the boring theoretical space, practical demonstrations of these techniques will be applied to QEMU subsystems. This will tie the concepts and examples into improved test cases and extended test coverage.

---

Cleber Rosa
Red Hat, Inc.
Software Engineer

Cleber is a Software Engineer working for Red Hat on the virt team. He helps to develop the testing stack for virtualization technologies, such as KVM, QEMU and Libvirt. He is a maintainer of the Avocado test framework and its virtualization specific sub projects, Avocado-VT and Avocado-Virt.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:06,170 --> 00:00:13,740
welcome my name is Claire Rosa I'm a

00:00:10,559 --> 00:00:16,410
software engineer at Red Hat I work at

00:00:13,740 --> 00:00:20,580
the virtualization team mostly on

00:00:16,410 --> 00:00:23,279
testing related initiatives most

00:00:20,580 --> 00:00:25,890
specifically most of the time on a

00:00:23,279 --> 00:00:28,050
couple of projects that are really

00:00:25,890 --> 00:00:30,960
focused on testing and virtualization

00:00:28,050 --> 00:00:32,910
testing as well which is avocado and

00:00:30,960 --> 00:00:36,090
avocado Vitti

00:00:32,910 --> 00:00:39,030
today we're gonna be talking about basic

00:00:36,090 --> 00:00:41,809
software practices so it's gonna be a

00:00:39,030 --> 00:00:44,940
little bit of basic software testing

00:00:41,809 --> 00:00:48,210
theory we're gonna move into topics

00:00:44,940 --> 00:00:50,219
which are simple but have kind of fancy

00:00:48,210 --> 00:00:53,520
names so we're gonna try to demystify

00:00:50,219 --> 00:00:56,280
them these are columns partitioning

00:00:53,520 --> 00:00:58,350
boundary value analysis and we're gonna

00:00:56,280 --> 00:01:01,410
move into a possibly more interesting

00:00:58,350 --> 00:01:04,290
topic that will build on those which is

00:01:01,410 --> 00:01:06,180
called combinatorial testing and we're

00:01:04,290 --> 00:01:09,590
gonna always be looking at how we can

00:01:06,180 --> 00:01:15,570
apply those techniques and a few tools

00:01:09,590 --> 00:01:17,130
on virtualization testing so as promised

00:01:15,570 --> 00:01:20,790
we're going to start with the textbook

00:01:17,130 --> 00:01:24,720
example most software testing books they

00:01:20,790 --> 00:01:27,470
either mention or they incorporate one

00:01:24,720 --> 00:01:30,119
example which comes from Glenn 4j Meijer

00:01:27,470 --> 00:01:31,710
which presents the following situation

00:01:30,119 --> 00:01:34,829
suppose you're writing an application

00:01:31,710 --> 00:01:36,540
that's pretty simple you just have to

00:01:34,829 --> 00:01:40,439
take as input the three lengths off a

00:01:36,540 --> 00:01:42,869
triangle situs and you have to output

00:01:40,439 --> 00:01:45,590
the trial classification the point is

00:01:42,869 --> 00:01:48,930
how hard can it actually be to write

00:01:45,590 --> 00:01:52,920
such tests so we'll start with a very

00:01:48,930 --> 00:01:55,439
basic actually rather naive version of

00:01:52,920 --> 00:01:57,719
the code that actually does that and

00:01:55,439 --> 00:02:00,509
it's it just checks if the tree sizes

00:01:57,719 --> 00:02:02,450
are the same it returns a collateral if

00:02:00,509 --> 00:02:06,299
the sizes are different

00:02:02,450 --> 00:02:09,209
it's a scalene triangle' and India in

00:02:06,299 --> 00:02:11,160
the last situation where the two sizes

00:02:09,209 --> 00:02:12,440
the two sizes should be the same and the

00:02:11,160 --> 00:02:17,030
other one different it

00:02:12,440 --> 00:02:19,940
trans is isosceles so we apply in the

00:02:17,030 --> 00:02:21,740
methodology on software testing textbook

00:02:19,940 --> 00:02:23,690
we just come up with the three test

00:02:21,740 --> 00:02:26,720
cases like three really basic test cases

00:02:23,690 --> 00:02:28,910
these are all sizes are equal it's a

00:02:26,720 --> 00:02:32,270
collateral two equal and one different

00:02:28,910 --> 00:02:34,850
isosceles and finally the last one is

00:02:32,270 --> 00:02:38,870
eskalene so we just do kind of a direct

00:02:34,850 --> 00:02:41,990
translation of that into tests people

00:02:38,870 --> 00:02:45,620
familiar with unit tests should be able

00:02:41,990 --> 00:02:48,650
to read this pretty quickly so it's just

00:02:45,620 --> 00:02:52,220
like a direct translation of that code

00:02:48,650 --> 00:02:54,830
but in fact there are situations in

00:02:52,220 --> 00:02:58,010
which are naive code even with very

00:02:54,830 --> 00:03:00,530
simple extended test case can actually

00:02:58,010 --> 00:03:02,390
review problems so if we look at the

00:03:00,530 --> 00:03:06,440
original code so this is the

00:03:02,390 --> 00:03:09,170
implementation together with with the

00:03:06,440 --> 00:03:11,380
test if we run something like this I'm

00:03:09,170 --> 00:03:15,130
using the avocado test running for that

00:03:11,380 --> 00:03:17,900
we have all passes but if we expand this

00:03:15,130 --> 00:03:21,200
with something that initially we think

00:03:17,900 --> 00:03:23,239
should also be an isosceles triangle we

00:03:21,200 --> 00:03:26,420
are gonna see that there's a failure so

00:03:23,239 --> 00:03:31,550
it actually reveals a bird right away

00:03:26,420 --> 00:03:33,739
just by picking the right input value so

00:03:31,550 --> 00:03:37,160
we go ahead and had an extended test we

00:03:33,739 --> 00:03:39,620
catch errors but we are pretty much far

00:03:37,160 --> 00:03:42,130
from comprehensive test coverage in such

00:03:39,620 --> 00:03:45,290
a simple program so we can think about

00:03:42,130 --> 00:03:47,840
situations where we have a size of the

00:03:45,290 --> 00:03:50,720
triangle with new size so with zero

00:03:47,840 --> 00:03:54,230
length size the expected outcome for

00:03:50,720 --> 00:03:57,080
that is an error negative sizes are also

00:03:54,230 --> 00:03:59,720
an error and there are also situations

00:03:57,080 --> 00:04:02,390
where you would expect something to be

00:03:59,720 --> 00:04:06,739
an isosceles triangle but it they are

00:04:02,390 --> 00:04:09,080
not and also a scalene triangle but they

00:04:06,739 --> 00:04:10,940
are not so one of those situations we

00:04:09,080 --> 00:04:13,970
can translate this code like this so

00:04:10,940 --> 00:04:15,590
again pretty much simple code and the

00:04:13,970 --> 00:04:18,890
other situation where you expect

00:04:15,590 --> 00:04:21,590
triangle should be scalene or isosceles

00:04:18,890 --> 00:04:25,430
in there or not are based on the fact

00:04:21,590 --> 00:04:25,910
that the sum of two sizes of a triangle

00:04:25,430 --> 00:04:29,180
has to be

00:04:25,910 --> 00:04:33,920
the other one and we can take from there

00:04:29,180 --> 00:04:37,640
and add yet a whole next level of checks

00:04:33,920 --> 00:04:39,980
so permutations of the parameter orders

00:04:37,640 --> 00:04:43,190
are actually important and can impact

00:04:39,980 --> 00:04:45,410
the the code that we have the type of

00:04:43,190 --> 00:04:50,600
input that your program actually gets

00:04:45,410 --> 00:04:54,230
can can can actually lead you revealing

00:04:50,600 --> 00:04:56,360
problems and even the amount like the

00:04:54,230 --> 00:04:59,410
number of parameters that your program

00:04:56,360 --> 00:05:04,040
gets can quickly show you problems so

00:04:59,410 --> 00:05:07,700
after five rounds of changes to the code

00:05:04,040 --> 00:05:10,700
and actually new tests we come up with a

00:05:07,700 --> 00:05:13,430
much more lengthy version of triangle

00:05:10,700 --> 00:05:16,940
check the checks inputs check negative

00:05:13,430 --> 00:05:18,800
numbers checks all combinations of the

00:05:16,940 --> 00:05:21,220
orders of the parameters and check the

00:05:18,800 --> 00:05:24,290
sum of two sizes against the third one

00:05:21,220 --> 00:05:27,020
and finally a different lamentation that

00:05:24,290 --> 00:05:30,290
actually checks the number of unique

00:05:27,020 --> 00:05:35,240
sizes and out of this we have nine test

00:05:30,290 --> 00:05:37,240
cases so I've said all that because the

00:05:35,240 --> 00:05:39,830
lessons that we can learn from this

00:05:37,240 --> 00:05:43,100
simple example is that writing tests

00:05:39,830 --> 00:05:44,630
it's probably a little bit more it takes

00:05:43,100 --> 00:05:48,140
a little more energy than one would

00:05:44,630 --> 00:05:50,090
expect so even it's experience software

00:05:48,140 --> 00:05:54,080
developers like using the textbook

00:05:50,090 --> 00:05:57,350
example they can come up with about six

00:05:54,080 --> 00:06:00,770
or seven tests for this simple situation

00:05:57,350 --> 00:06:04,340
and one would expect at least 14 tests

00:06:00,770 --> 00:06:07,190
to cover all corner cases the point is

00:06:04,340 --> 00:06:09,320
we are probably writing software that is

00:06:07,190 --> 00:06:14,350
not as simple as a triangle check right

00:06:09,320 --> 00:06:16,940
so we can do we have to do at least a

00:06:14,350 --> 00:06:20,390
number of orders of magnitude better

00:06:16,940 --> 00:06:22,760
than the test that I've shown here one

00:06:20,390 --> 00:06:25,100
point that I've tried to get across this

00:06:22,760 --> 00:06:27,950
talk is that choosing the right input

00:06:25,100 --> 00:06:31,970
can actually help a lot so we'll be

00:06:27,950 --> 00:06:35,450
focusing on spamming our energy and

00:06:31,970 --> 00:06:38,000
where we can reap the most benefits out

00:06:35,450 --> 00:06:39,740
of testing so the idea is that not all

00:06:38,000 --> 00:06:43,370
input are created equal and

00:06:39,740 --> 00:06:46,789
we can actually exercise the best input

00:06:43,370 --> 00:06:48,949
that we pass so the first technique that

00:06:46,789 --> 00:06:52,039
we're going to talk about its

00:06:48,949 --> 00:06:55,630
equivalents partitioning is anyone here

00:06:52,039 --> 00:06:58,220
familiar with that with the term if not

00:06:55,630 --> 00:06:59,960
don't let the name scare you and it's

00:06:58,220 --> 00:07:02,599
actually something pretty simple it's

00:06:59,960 --> 00:07:04,220
actually built into our logical thinking

00:07:02,599 --> 00:07:06,500
it just makes sense you're actually

00:07:04,220 --> 00:07:10,009
named it and have a technique for

00:07:06,500 --> 00:07:13,250
finding for identifying and making use

00:07:10,009 --> 00:07:15,860
of that so when you actually write an

00:07:13,250 --> 00:07:18,110
application and consequently a test you

00:07:15,860 --> 00:07:20,330
have you you can think of values in

00:07:18,110 --> 00:07:23,180
which you pass through the tests which

00:07:20,330 --> 00:07:27,289
you can reasonably expect that will

00:07:23,180 --> 00:07:30,199
produce the same kind of result so these

00:07:27,289 --> 00:07:33,259
types of input would be in the same

00:07:30,199 --> 00:07:37,699
class and a good pick is one that is

00:07:33,259 --> 00:07:40,610
usually worth many others so if you're

00:07:37,699 --> 00:07:43,130
checking number one in as a given input

00:07:40,610 --> 00:07:45,650
to a function and you're reasonably sure

00:07:43,130 --> 00:07:47,750
that if you do if you pass you instead

00:07:45,650 --> 00:07:50,270
one and she would be in the same class

00:07:47,750 --> 00:07:53,270
there's no need to test with one and she

00:07:50,270 --> 00:07:57,740
you reasonably expect them to behave the

00:07:53,270 --> 00:08:02,570
same so in virtualization development

00:07:57,740 --> 00:08:05,780
we're usually bound to following real

00:08:02,570 --> 00:08:07,789
word hardware so we would we would be

00:08:05,780 --> 00:08:11,930
following like specifications of real

00:08:07,789 --> 00:08:16,130
Hardware or when we writing tests or for

00:08:11,930 --> 00:08:18,349
say qmu we should be looking at the

00:08:16,130 --> 00:08:21,229
limits in which this virtualized

00:08:18,349 --> 00:08:25,060
Hardware actually imposes so this is a

00:08:21,229 --> 00:08:29,780
snippet from qmu source code in which it

00:08:25,060 --> 00:08:33,700
it presents two kinds of limits the

00:08:29,780 --> 00:08:36,620
first one it's regard it regards the

00:08:33,700 --> 00:08:40,159
maximum ID of a CPU hot-plug

00:08:36,620 --> 00:08:42,770
which gives away also the second check

00:08:40,159 --> 00:08:47,600
which is the maximum number of CPUs that

00:08:42,770 --> 00:08:51,820
can be added to a virtual machine so by

00:08:47,600 --> 00:08:55,570
looking at this code we can identify

00:08:51,820 --> 00:08:58,660
two types of inputs in their respective

00:08:55,570 --> 00:09:01,660
classes so when it comes to the number

00:08:58,660 --> 00:09:06,010
of CPUs we can quickly see that see the

00:09:01,660 --> 00:09:09,790
qmu source code treats should treat from

00:09:06,010 --> 00:09:12,330
1 to 256 CPUs kind of the same way

00:09:09,790 --> 00:09:15,870
that's what expected so we can

00:09:12,330 --> 00:09:20,640
reasonably assume that but anything

00:09:15,870 --> 00:09:25,690
equal or below zero would be an invalid

00:09:20,640 --> 00:09:28,350
input and anything above 257 would be

00:09:25,690 --> 00:09:31,690
invalid these two are closely related

00:09:28,350 --> 00:09:34,060
but we really have to look them at them

00:09:31,690 --> 00:09:37,870
differently so if we look at the IDS

00:09:34,060 --> 00:09:39,670
that each CPU will actually have it's a

00:09:37,870 --> 00:09:42,370
different input type and they have a

00:09:39,670 --> 00:09:46,570
different class of input so anything

00:09:42,370 --> 00:09:50,260
from from 0 to 255 they should be valid

00:09:46,570 --> 00:09:53,290
inputs for CPU IDs and anything below or

00:09:50,260 --> 00:09:55,420
above that should be invalid so whenever

00:09:53,290 --> 00:09:58,000
you hear equivalent classes or

00:09:55,420 --> 00:10:00,880
equivalent partitioning that's all it is

00:09:58,000 --> 00:10:04,780
so you're you're putting in the first

00:10:00,880 --> 00:10:08,020
example from 1 to 250 56 in the same

00:10:04,780 --> 00:10:09,730
class and anything above it and beyond

00:10:08,020 --> 00:10:13,360
it on separate classes and the same

00:10:09,730 --> 00:10:16,690
thing for other types of input the next

00:10:13,360 --> 00:10:19,150
topic it's also pretty simple even

00:10:16,690 --> 00:10:24,580
though it has this fancy name boundary

00:10:19,150 --> 00:10:26,980
analysis it just a way of looking at the

00:10:24,580 --> 00:10:30,520
values there are at the boundary of

00:10:26,980 --> 00:10:33,670
classes they usually will give you the

00:10:30,520 --> 00:10:37,440
best benefits the the best results out

00:10:33,670 --> 00:10:41,440
of testing so looking back at the

00:10:37,440 --> 00:10:46,300
equivalent classes we saw before we can

00:10:41,440 --> 00:10:48,700
say that 0 is an invalid number of CPU

00:10:46,300 --> 00:10:52,090
IDs and it just happens that it's really

00:10:48,700 --> 00:10:55,870
at the boundary of the valid and invalid

00:10:52,090 --> 00:11:00,670
class and the same thing is it's true

00:10:55,870 --> 00:11:03,370
for 257 so valid values and invalid

00:11:00,670 --> 00:11:05,100
values can be used as input for tests

00:11:03,370 --> 00:11:07,800
that generate correct that

00:11:05,100 --> 00:11:08,550
yes correct behavior and also test error

00:11:07,800 --> 00:11:10,620
handling

00:11:08,550 --> 00:11:11,700
that's that should be pretty very simple

00:11:10,620 --> 00:11:14,010
right

00:11:11,700 --> 00:11:17,640
the same thing with CPU IDs in this case

00:11:14,010 --> 00:11:21,930
so we have here an invalid cpuid that is

00:11:17,640 --> 00:11:25,440
minus 1 and also invalid CPU why do you

00:11:21,930 --> 00:11:28,770
have 256 so boundary values it's of it's

00:11:25,440 --> 00:11:31,320
only dislike you look at the boundary

00:11:28,770 --> 00:11:33,810
values in equivalent classes and you can

00:11:31,320 --> 00:11:38,280
usually get a lot just by using those

00:11:33,810 --> 00:11:40,650
values so just to prove that sometimes

00:11:38,280 --> 00:11:43,220
this come up consciously and sometimes

00:11:40,650 --> 00:11:47,190
unconsciously this is a snippet from

00:11:43,220 --> 00:11:52,050
avocado vtt P Q mu so it's the test

00:11:47,190 --> 00:11:54,500
provider the set of tests for Q mu that

00:11:52,050 --> 00:11:57,830
is also part of the avocado project and

00:11:54,500 --> 00:11:59,880
it may be coincidence it may be not I

00:11:57,830 --> 00:12:01,440
wasn't there when the code was written

00:11:59,880 --> 00:12:03,570
so I don't know what was in the

00:12:01,440 --> 00:12:06,090
developers mind but you can pretty much

00:12:03,570 --> 00:12:09,740
see that the boundary values are being

00:12:06,090 --> 00:12:13,020
used here so it should be it shouldn't

00:12:09,740 --> 00:12:17,490
come up as a surprise that these values

00:12:13,020 --> 00:12:20,910
are kind of special so let's try to get

00:12:17,490 --> 00:12:24,180
this concept and actually apply to any

00:12:20,910 --> 00:12:25,860
piece of software so it was literally

00:12:24,180 --> 00:12:28,650
the first thing that came to my mind

00:12:25,860 --> 00:12:32,550
when I was preparing this it's just you

00:12:28,650 --> 00:12:34,620
get this like one of the most easily the

00:12:32,550 --> 00:12:38,700
components that was easy easier to

00:12:34,620 --> 00:12:41,280
interact with in Q mu which was Q mu IMG

00:12:38,700 --> 00:12:43,920
so I was looking at the the commands and

00:12:41,280 --> 00:12:46,470
I saw bench and I read run a simple

00:12:43,920 --> 00:12:48,480
sequential i/o benchmarks on the

00:12:46,470 --> 00:12:51,480
specified image that's the description

00:12:48,480 --> 00:12:54,690
in the main page and then the first

00:12:51,480 --> 00:12:57,890
option for Q IMG is a total number of

00:12:54,690 --> 00:13:01,590
count io request which is a parameter

00:12:57,890 --> 00:13:03,380
request is performed so this comes from

00:13:01,590 --> 00:13:07,230
Q mu mg

00:13:03,380 --> 00:13:11,400
if we look at bench it's the first

00:13:07,230 --> 00:13:15,690
parameter so if we look based on this

00:13:11,400 --> 00:13:17,080
description we could try it something

00:13:15,690 --> 00:13:19,900
like this

00:13:17,080 --> 00:13:23,020
I'm going to do first your benchmark on

00:13:19,900 --> 00:13:26,350
Q mu mg image I'm going to create one

00:13:23,020 --> 00:13:28,960
I'm going to create using raw I'm going

00:13:26,350 --> 00:13:31,600
to name it banks IMG and I'm gonna

00:13:28,960 --> 00:13:34,240
create it what bit one gig so that's

00:13:31,600 --> 00:13:36,490
that's nice it's we have an image and

00:13:34,240 --> 00:13:39,790
now I'm gonna try bench the first

00:13:36,490 --> 00:13:43,210
parameter is couch I don't need the

00:13:39,790 --> 00:13:45,820
image size and I'm gonna try to send a

00:13:43,210 --> 00:13:47,320
negative number of requests in my mind

00:13:45,820 --> 00:13:49,090
this doesn't make sense

00:13:47,320 --> 00:13:55,260
and it doesn't make sense you came here

00:13:49,090 --> 00:13:58,810
AMG as well so this is a boundary value

00:13:55,260 --> 00:14:01,120
if I had previously drawn that it would

00:13:58,810 --> 00:14:03,190
be pretty obvious but now I'll go a

00:14:01,120 --> 00:14:06,310
little bit further on the next boundary

00:14:03,190 --> 00:14:09,910
level and use you what happens here is

00:14:06,310 --> 00:14:14,260
that qmg runs and it sends zero requests

00:14:09,910 --> 00:14:18,010
in my mind it doesn't make much sense to

00:14:14,260 --> 00:14:20,320
do a benchmark with no requests so it is

00:14:18,010 --> 00:14:22,060
something pretty trivial so it's not

00:14:20,320 --> 00:14:24,160
like this huge do you breaker there's

00:14:22,060 --> 00:14:27,130
going to be a CVE and the words gonna

00:14:24,160 --> 00:14:29,290
have a screen that's really far from

00:14:27,130 --> 00:14:31,750
that but it just shows that a little bit

00:14:29,290 --> 00:14:36,550
of reasoning on values that should or

00:14:31,750 --> 00:14:38,890
should not be accepted can do a big deal

00:14:36,550 --> 00:14:41,950
of difference in testing so the benefits

00:14:38,890 --> 00:14:45,700
you can reap out are like pretty pretty

00:14:41,950 --> 00:14:50,080
quick so out of this experiment I

00:14:45,700 --> 00:14:52,810
actually was looking at um you and to me

00:14:50,080 --> 00:14:56,860
again this is the the the perceived

00:14:52,810 --> 00:14:59,770
values that I believe would be valid and

00:14:56,860 --> 00:15:03,340
invalid here would be more or less like

00:14:59,770 --> 00:15:06,130
this so zero requests in my mind would

00:15:03,340 --> 00:15:11,080
be something to be considered invalid

00:15:06,130 --> 00:15:14,440
and anything from 1 to an earning signed

00:15:11,080 --> 00:15:17,050
integer instead of an signed integer

00:15:14,440 --> 00:15:20,530
would be a valid number of requests so

00:15:17,050 --> 00:15:23,070
if we look at the source code this is

00:15:20,530 --> 00:15:27,340
actually a diff from actual to perceived

00:15:23,070 --> 00:15:29,390
so in my mind we should be really using

00:15:27,340 --> 00:15:31,670
here and inside games instead of

00:15:29,390 --> 00:15:33,890
it because it doesn't make sense use

00:15:31,670 --> 00:15:37,250
either zero or negative number of our

00:15:33,890 --> 00:15:39,230
requests so again no big deal

00:15:37,250 --> 00:15:42,050
but like it makes you think about the

00:15:39,230 --> 00:15:45,170
inputs that you're gonna pass chip tests

00:15:42,050 --> 00:15:48,140
and why is that so important because

00:15:45,170 --> 00:15:52,520
humans do that the best like humans can

00:15:48,140 --> 00:15:54,020
reason on really on the details of the

00:15:52,520 --> 00:15:57,890
software that we're testing

00:15:54,020 --> 00:16:01,160
so let us humans do what we do best and

00:15:57,890 --> 00:16:03,410
let us let machines do what they do best

00:16:01,160 --> 00:16:06,440
and this is where combinatorial testing

00:16:03,410 --> 00:16:10,940
comes in so this thing is also known as

00:16:06,440 --> 00:16:14,030
pairwise so you may hear about it using

00:16:10,940 --> 00:16:17,420
that term and the basic principle is

00:16:14,030 --> 00:16:20,300
that you will have in your test case so

00:16:17,420 --> 00:16:22,730
your collection of tests at least a

00:16:20,300 --> 00:16:26,930
single test that will use a pair of

00:16:22,730 --> 00:16:29,840
unique values so the idea is that if you

00:16:26,930 --> 00:16:35,060
have a matrix of tests you will have a

00:16:29,840 --> 00:16:37,580
unique value of each possible each type

00:16:35,060 --> 00:16:39,770
with a unique value but it would

00:16:37,580 --> 00:16:42,530
generate this like full-blown matrix

00:16:39,770 --> 00:16:46,460
that it would take a lot of effort to

00:16:42,530 --> 00:16:50,510
run and pairwise it's a technique where

00:16:46,460 --> 00:16:53,510
you will only put two unique values by

00:16:50,510 --> 00:16:57,700
the fold on your test plan execution it

00:16:53,510 --> 00:17:00,890
will combine those in an optimal way so

00:16:57,700 --> 00:17:03,260
the point here is that if you have a lot

00:17:00,890 --> 00:17:06,020
of knobs to turn and a lot of knobs to

00:17:03,260 --> 00:17:09,320
test it becomes impractical like really

00:17:06,020 --> 00:17:12,920
quickly so the average piece of software

00:17:09,320 --> 00:17:14,540
will have dozens hundreds sometimes

00:17:12,920 --> 00:17:17,300
thousands of different configurations

00:17:14,540 --> 00:17:18,829
and testing all of them means like

00:17:17,300 --> 00:17:20,570
multiplying everything she will

00:17:18,829 --> 00:17:23,900
developer working on a piece of software

00:17:20,570 --> 00:17:26,030
that is impractical for both coding like

00:17:23,900 --> 00:17:30,680
code writing reasons and also for test

00:17:26,030 --> 00:17:33,230
execution times so what this

00:17:30,680 --> 00:17:35,600
combinatorial testing like what has

00:17:33,230 --> 00:17:38,390
research and combinatorial testing

00:17:35,600 --> 00:17:41,090
actually delivered so this is part of a

00:17:38,390 --> 00:17:43,190
research from NIST part of the US

00:17:41,090 --> 00:17:45,290
government and they have found

00:17:43,190 --> 00:17:48,470
when you jumped from one single value in

00:17:45,290 --> 00:17:52,040
a test to chew you have this huge

00:17:48,470 --> 00:17:55,340
improvement of failures that you catch

00:17:52,040 --> 00:17:59,570
in software when you move two three four

00:17:55,340 --> 00:18:01,400
five and six you virtually catch all the

00:17:59,570 --> 00:18:03,950
software failures that you would with a

00:18:01,400 --> 00:18:07,450
full-blown matrix so this usually means

00:18:03,950 --> 00:18:10,100
it can mean running a hundred tests or

00:18:07,450 --> 00:18:12,080
three hundred tests instead of ten

00:18:10,100 --> 00:18:16,370
thousand and still achieving the same

00:18:12,080 --> 00:18:18,710
results so it makes a lot of sense in

00:18:16,370 --> 00:18:21,080
virtualization testing because we do

00:18:18,710 --> 00:18:23,510
deal with a lot of different knobs like

00:18:21,080 --> 00:18:27,380
different Hardware different cache sizes

00:18:23,510 --> 00:18:29,600
different block sizes all the different

00:18:27,380 --> 00:18:33,530
knobs we can turn in the software that

00:18:29,600 --> 00:18:38,150
we we develop so again getting back to

00:18:33,530 --> 00:18:42,140
qme qmu IMG but using convert which is a

00:18:38,150 --> 00:18:45,830
different qmg command we can look at the

00:18:42,140 --> 00:18:50,450
number of knobs this specific command

00:18:45,830 --> 00:18:53,150
has so we can list maybe ten twelve

00:18:50,450 --> 00:18:55,940
different commands and that is without

00:18:53,150 --> 00:18:59,170
going too deep into options like object

00:18:55,940 --> 00:19:01,130
image odds which are can be actually

00:18:59,170 --> 00:19:05,540
much more complex than that

00:19:01,130 --> 00:19:08,300
so to look at comunitario testing we

00:19:05,540 --> 00:19:11,960
will start simple we'll start with four

00:19:08,300 --> 00:19:15,170
nonce so we will look into a test that

00:19:11,960 --> 00:19:17,720
actually converts from one form into the

00:19:15,170 --> 00:19:20,390
other using one type of source cache and

00:19:17,720 --> 00:19:22,430
another type of destination cache so out

00:19:20,390 --> 00:19:25,100
of all those options we're only going to

00:19:22,430 --> 00:19:28,030
pick four and we're gonna see what it

00:19:25,100 --> 00:19:32,560
does so how would I go about testing

00:19:28,030 --> 00:19:35,840
this which would mean a treat almost

00:19:32,560 --> 00:19:38,300
3900 tests if I explode the matrix I'll

00:19:35,840 --> 00:19:43,640
show you that later into a much more

00:19:38,300 --> 00:19:45,920
usable and runnable set of tests so to

00:19:43,640 --> 00:19:48,140
do that we have to pick a tool and the

00:19:45,920 --> 00:19:50,420
two we're gonna pick this bit so it

00:19:48,140 --> 00:19:53,600
sounds like a tongue twister but the

00:19:50,420 --> 00:19:54,780
name of the tool expect as in pairwise

00:19:53,600 --> 00:19:57,990
in the pen and

00:19:54,780 --> 00:20:01,530
combinatorial testing this is quoted

00:19:57,990 --> 00:20:04,170
from their documentation so it generates

00:20:01,530 --> 00:20:05,730
test cases and test configuration with

00:20:04,170 --> 00:20:08,190
picked you can generate s or more

00:20:05,730 --> 00:20:10,380
effectively then manually generate a

00:20:08,190 --> 00:20:12,780
test and in a fraction of time so this

00:20:10,380 --> 00:20:15,000
is what we want we want to really rip

00:20:12,780 --> 00:20:17,940
out the benefits without spending too

00:20:15,000 --> 00:20:21,230
much energy so let the machines do what

00:20:17,940 --> 00:20:23,820
they do best this machine this

00:20:21,230 --> 00:20:27,170
application is hosted on github it's

00:20:23,820 --> 00:20:32,820
part of Microsoft effort and it's

00:20:27,170 --> 00:20:36,810
license and MIT license so following the

00:20:32,820 --> 00:20:39,780
usage guidelines or the input types

00:20:36,810 --> 00:20:42,870
accepted by pitch we come up with the

00:20:39,780 --> 00:20:44,730
tool with a file like this so out of the

00:20:42,870 --> 00:20:48,360
four knobs where you can see on the last

00:20:44,730 --> 00:20:51,720
four lines we say that we're gonna pass

00:20:48,360 --> 00:20:54,780
different values to the format output

00:20:51,720 --> 00:20:57,780
format source cash and cash knobs so

00:20:54,780 --> 00:21:00,570
different types of input and each one of

00:20:57,780 --> 00:21:05,430
them can accept those different values

00:21:00,570 --> 00:21:07,920
so different image format types and cash

00:21:05,430 --> 00:21:10,260
types and to convert an image we

00:21:07,920 --> 00:21:12,180
actually need to create an image so we

00:21:10,260 --> 00:21:14,720
are gonna do that with different image

00:21:12,180 --> 00:21:18,090
size two bytes like trying to get as

00:21:14,720 --> 00:21:20,310
small as possible and then just

00:21:18,090 --> 00:21:24,030
gradually growing to see if they have

00:21:20,310 --> 00:21:25,890
any different effects I'm not are

00:21:24,030 --> 00:21:28,200
interesting like other interesting

00:21:25,890 --> 00:21:30,390
values that we could try to apply here

00:21:28,200 --> 00:21:33,590
and if you try to do that you're gonna

00:21:30,390 --> 00:21:38,070
find interesting things about qmu IMG

00:21:33,590 --> 00:21:41,480
would be things like 8 XE bytes X 8 XE

00:21:38,070 --> 00:21:44,790
bytes plus 1 which will go beyond the

00:21:41,480 --> 00:21:48,090
boundary of the acceptable in theory

00:21:44,790 --> 00:21:52,470
input size so let's see how we can use

00:21:48,090 --> 00:21:56,430
this file so let's see Q mu IMG convert

00:21:52,470 --> 00:21:59,100
dot pict so this is just like mirror of

00:21:56,430 --> 00:22:02,520
the command line options a few things we

00:21:59,100 --> 00:22:05,520
run in we brain entry while checking out

00:22:02,520 --> 00:22:07,760
those values so I chose input value was

00:22:05,520 --> 00:22:11,210
2 bytes 1 Meg manga

00:22:07,760 --> 00:22:14,269
and those format files so by using the

00:22:11,210 --> 00:22:16,700
picked two by itself and just passing

00:22:14,269 --> 00:22:19,909
the parameter file this is what we get

00:22:16,700 --> 00:22:23,179
so for input size format output format

00:22:19,909 --> 00:22:28,340
source cash in cash our test plan like

00:22:23,179 --> 00:22:31,519
our whole test case will have 81

00:22:28,340 --> 00:22:34,970
different tests each one of those lines

00:22:31,519 --> 00:22:39,470
it would be a test in our test case and

00:22:34,970 --> 00:22:41,659
you we can be sure that any combination

00:22:39,470 --> 00:22:45,380
you mentioned of source format

00:22:41,659 --> 00:22:47,230
destination format source cash type and

00:22:45,380 --> 00:22:50,809
destination test

00:22:47,230 --> 00:22:55,190
cache type I'm sorry is listed at least

00:22:50,809 --> 00:22:57,500
once in this test case if we want to get

00:22:55,190 --> 00:23:01,000
more comprehensive like we show

00:22:57,500 --> 00:23:04,429
previously in the graph so this is at

00:23:01,000 --> 00:23:07,309
order qu so we already have a big jump

00:23:04,429 --> 00:23:09,200
from one comment light from a single

00:23:07,309 --> 00:23:12,019
parameter to a combination of unique

00:23:09,200 --> 00:23:16,039
values if we want to go two three four

00:23:12,019 --> 00:23:19,460
five which is the limit of the the

00:23:16,039 --> 00:23:24,529
number of the unique input types that we

00:23:19,460 --> 00:23:26,990
have we can go all the way to 300 let

00:23:24,529 --> 00:23:29,419
let it run but the number is something

00:23:26,990 --> 00:23:32,360
like three thousand and eight hundred

00:23:29,419 --> 00:23:35,289
and something different test cases if we

00:23:32,360 --> 00:23:38,630
go a little bit back on the number of

00:23:35,289 --> 00:23:42,559
unique values like if we go to three we

00:23:38,630 --> 00:23:45,500
still have a lot less test cases but

00:23:42,559 --> 00:23:48,950
based on research will have pretty

00:23:45,500 --> 00:23:53,500
pretty good coverage right so how can we

00:23:48,950 --> 00:23:57,110
how can we leverage this definition of

00:23:53,500 --> 00:23:58,760
combinatorial testing so we have this

00:23:57,110 --> 00:24:01,100
combination that can be generated by

00:23:58,760 --> 00:24:03,320
text but we need some machinery to

00:24:01,100 --> 00:24:05,510
actually pass those parameters to your

00:24:03,320 --> 00:24:07,820
test and we need a test runner for that

00:24:05,510 --> 00:24:11,440
and for obvious reasons we're gonna pick

00:24:07,820 --> 00:24:14,570
avocados avocado is in our opinion a

00:24:11,440 --> 00:24:16,399
versatile test runner it has a long time

00:24:14,570 --> 00:24:19,129
history and heritage in vectorization

00:24:16,399 --> 00:24:21,220
testing so it came from what was known

00:24:19,129 --> 00:24:23,230
as KVM or a test

00:24:21,220 --> 00:24:26,020
ver test and it has this close

00:24:23,230 --> 00:24:28,000
relationship with avocado VT it has

00:24:26,020 --> 00:24:30,130
buting supports for what we call test

00:24:28,000 --> 00:24:32,860
variance in test variance you write your

00:24:30,130 --> 00:24:35,289
test once and it gets run a number of

00:24:32,860 --> 00:24:37,510
times with different parameters so you

00:24:35,289 --> 00:24:41,320
probably can see how those things would

00:24:37,510 --> 00:24:45,250
fit for more information there's a bunch

00:24:41,320 --> 00:24:47,169
of of pointers but the important thing

00:24:45,250 --> 00:24:50,770
here is that we are using a proof of

00:24:47,169 --> 00:24:54,100
concept implementation that was done

00:24:50,770 --> 00:24:58,210
with tipped so let's see how a test

00:24:54,100 --> 00:25:00,970
using those things would look like so

00:24:58,210 --> 00:25:04,320
this is like an avocado instrumented

00:25:00,970 --> 00:25:09,400
test was just a Python file that uses

00:25:04,320 --> 00:25:12,760
some specificity ice on the setup method

00:25:09,400 --> 00:25:16,270
we do we get some parameters and we just

00:25:12,760 --> 00:25:20,320
execute qmu IMG create on the test

00:25:16,270 --> 00:25:23,080
itself what we do is we get those

00:25:20,320 --> 00:25:27,159
parameters so output format input format

00:25:23,080 --> 00:25:29,559
the kind of cache this is an optional

00:25:27,159 --> 00:25:31,390
treatment of compression or no

00:25:29,559 --> 00:25:34,960
compression I will show you guys that

00:25:31,390 --> 00:25:37,799
later and then you just execute key mu

00:25:34,960 --> 00:25:42,250
mg convert if the process executes

00:25:37,799 --> 00:25:44,260
correctly we have a pass if we have a

00:25:42,250 --> 00:25:49,870
process command error we have a test

00:25:44,260 --> 00:25:51,909
failure okay so if we just run this it's

00:25:49,870 --> 00:25:55,080
gonna use defaults the defaults are

00:25:51,909 --> 00:25:58,809
hard-coded in there but then we have

00:25:55,080 --> 00:26:01,630
again a proof-of-concept integration

00:25:58,809 --> 00:26:06,100
with picked so we pass picked parameter

00:26:01,630 --> 00:26:10,150
file Q mu IMG converter picked and the

00:26:06,100 --> 00:26:14,830
same test code will actually run for a

00:26:10,150 --> 00:26:16,960
number of different variations and now

00:26:14,830 --> 00:26:20,169
getting back so we have 81 different

00:26:16,960 --> 00:26:22,539
test combinations so converting a file

00:26:20,169 --> 00:26:25,360
using Q mu IMG from one format to the

00:26:22,539 --> 00:26:28,240
other with different sizes just writing

00:26:25,360 --> 00:26:30,490
a single test and what's what's

00:26:28,240 --> 00:26:34,840
interesting here is that if we apply

00:26:30,490 --> 00:26:37,720
what we have learned before on

00:26:34,840 --> 00:26:43,780
boundary values so if I just substitute

00:26:37,720 --> 00:26:47,640
this Q bytes for a zero byte file we're

00:26:43,780 --> 00:26:51,930
going to find out that for one specific

00:26:47,640 --> 00:26:55,270
combination which is VMDK we have

00:26:51,930 --> 00:27:00,340
strength situation if we look at the

00:26:55,270 --> 00:27:02,470
logs that are generated here so I'll

00:27:00,340 --> 00:27:05,410
just go really quickly here to the log

00:27:02,470 --> 00:27:08,980
and it says the command to new IMG

00:27:05,410 --> 00:27:12,850
create VMDK a name of an image file has

00:27:08,980 --> 00:27:15,220
failed zero bytes and let's look at what

00:27:12,850 --> 00:27:18,190
this looks in real life so I'll just

00:27:15,220 --> 00:27:20,350
substitute the file name because this is

00:27:18,190 --> 00:27:23,920
a directory does not act does not exist

00:27:20,350 --> 00:27:26,490
out of the that's run time and we have a

00:27:23,920 --> 00:27:29,740
pretty much interesting message so

00:27:26,490 --> 00:27:31,960
formatting image and then could not open

00:27:29,740 --> 00:27:35,980
input dot IMG so definitely it's

00:27:31,960 --> 00:27:38,260
something to look into maybe not a CV

00:27:35,980 --> 00:27:40,540
maybe not heartbleed or something like

00:27:38,260 --> 00:27:43,810
that but definitely something that

00:27:40,540 --> 00:27:47,800
should actually be checked upon and that

00:27:43,810 --> 00:27:50,500
cost us close to nothing just to mention

00:27:47,800 --> 00:27:54,850
our pict has some support for

00:27:50,500 --> 00:27:56,950
conditional situations so if we look at

00:27:54,850 --> 00:28:01,270
the parameter file again so pick the

00:27:56,950 --> 00:28:05,230
image converter picked so for example

00:28:01,270 --> 00:28:07,870
this other option here - C which is

00:28:05,230 --> 00:28:12,880
let's call it another not can only be

00:28:07,870 --> 00:28:15,430
used with with you couch.you files so

00:28:12,880 --> 00:28:21,580
there is support for conditionals like

00:28:15,430 --> 00:28:23,860
this and if we activate it and let's

00:28:21,580 --> 00:28:26,230
just run picked on it because it's gonna

00:28:23,860 --> 00:28:29,020
be faster you're gonna see that

00:28:26,230 --> 00:28:32,200
compression has only been activated when

00:28:29,020 --> 00:28:33,910
a destination image is a cue culture so

00:28:32,200 --> 00:28:40,920
you can pretty much build on those

00:28:33,910 --> 00:28:45,010
concepts so what's next we want to get a

00:28:40,920 --> 00:28:47,800
Vacarro and like the tools are necessary

00:28:45,010 --> 00:28:48,429
to make this kind of tooling and

00:28:47,800 --> 00:28:51,309
techniques of

00:28:48,429 --> 00:28:53,679
able to upstream brutalization

00:28:51,309 --> 00:28:57,220
development we are currently doing an

00:28:53,679 --> 00:28:58,889
experiment in upstream qmu this is one

00:28:57,220 --> 00:29:01,480
of the implementations that we have

00:28:58,889 --> 00:29:03,220
interesting news is that there's been

00:29:01,480 --> 00:29:05,830
collaboration with the Czech Technical

00:29:03,220 --> 00:29:07,860
University in Prague in which another

00:29:05,830 --> 00:29:11,110
algorithm is being developed

00:29:07,860 --> 00:29:13,899
specifically for avvocato now and we're

00:29:11,110 --> 00:29:17,080
gonna let the bad solution win we have

00:29:13,899 --> 00:29:20,980
found that this is quite a topic that it

00:29:17,080 --> 00:29:25,509
has not been thoroughly used in upstream

00:29:20,980 --> 00:29:27,460
so we can probably see as a next step a

00:29:25,509 --> 00:29:31,240
special interest group or something like

00:29:27,460 --> 00:29:33,039
that on our side on the the translation

00:29:31,240 --> 00:29:35,220
team at Red Hat we really want to

00:29:33,039 --> 00:29:38,679
leverage this kind of situation to allow

00:29:35,220 --> 00:29:41,110
individual virtualization developers run

00:29:38,679 --> 00:29:44,830
a much higher coverage of tests like

00:29:41,110 --> 00:29:47,590
using a lot of a lot less energy be it

00:29:44,830 --> 00:29:51,369
like human based energy on like writing

00:29:47,590 --> 00:29:56,340
less tests and using less resources as

00:29:51,369 --> 00:29:56,340
well any questions

00:30:03,299 --> 00:30:10,809
it was oh I didn't do that count

00:30:07,269 --> 00:30:14,259
oh yeah it's like three thousand eight

00:30:10,809 --> 00:30:16,450
hundred yeah actually when I use Oh 5 I

00:30:14,259 --> 00:30:18,279
mean that I want all the unique values

00:30:16,450 --> 00:30:20,759
and I have five different poo types so

00:30:18,279 --> 00:30:25,740
it's three hundred eighty eighty nine

00:30:20,759 --> 00:30:25,740
different variations that's

00:30:34,289 --> 00:30:40,479
so yeah I I briefly mentioned so we put

00:30:37,749 --> 00:30:43,960
that out as proof of concept there it's

00:30:40,479 --> 00:30:46,869
in a specific pool request and what's

00:30:43,960 --> 00:30:49,690
next for us it's getting picked itself

00:30:46,869 --> 00:30:52,690
package on fedora and Ipoh and then

00:30:49,690 --> 00:30:55,149
pushing proper support on upstream on

00:30:52,690 --> 00:31:14,169
the next sub car release so that's

00:30:55,149 --> 00:31:16,149
probably gonna be 56 or so so there's

00:31:14,169 --> 00:31:19,839
there's no difference in importance as

00:31:16,149 --> 00:31:22,509
long as in the generated test case so in

00:31:19,839 --> 00:31:26,999
the list of tests it generates each

00:31:22,509 --> 00:31:30,190
input type has at least it's listed

00:31:26,999 --> 00:31:33,519
depending on the order that you specify

00:31:30,190 --> 00:31:37,359
so for pairwise or order of Choo you're

00:31:33,519 --> 00:31:41,679
gonna find two unique values in a test

00:31:37,359 --> 00:31:43,869
within the test case right so the

00:31:41,679 --> 00:31:46,029
traditional way of doing that it's

00:31:43,869 --> 00:31:48,759
making sure you multiply everything by

00:31:46,029 --> 00:31:51,269
everything so you'd have one test with

00:31:48,759 --> 00:31:54,669
each unique value in all positions and

00:31:51,269 --> 00:31:57,609
what picked us it may have more than

00:31:54,669 --> 00:32:00,669
once if it's necessary to guarantee that

00:31:57,609 --> 00:32:03,700
each one is listed at least once each

00:32:00,669 --> 00:32:10,719
pair is listed at least once but that's

00:32:03,700 --> 00:32:13,859
that's all it does i generate Sall ways

00:32:10,719 --> 00:32:13,859
the same way as purchasing

00:32:20,760 --> 00:32:29,220
mystic situations like issues or that's

00:32:25,830 --> 00:32:31,980
that's an interesting point I mean

00:32:29,220 --> 00:32:34,140
probably by periods with another tool

00:32:31,980 --> 00:32:36,500
where you can control the deterministic

00:32:34,140 --> 00:32:38,880
non-deterministic stuff like timing

00:32:36,500 --> 00:32:40,950
probably yes so I don't see it being

00:32:38,880 --> 00:32:42,870
used for that by itself but in

00:32:40,950 --> 00:32:45,240
combination with something else like our

00:32:42,870 --> 00:32:51,570
our would be an interesting tool to

00:32:45,240 --> 00:32:53,669
couple it with thank you guys very much

00:32:51,570 --> 00:32:56,250
if you need I'll be here for a few

00:32:53,669 --> 00:32:57,280
minutes and you can find us online

00:32:56,250 --> 00:33:01,960
thank you very much

00:32:57,280 --> 00:33:07,819
[Applause]

00:33:01,960 --> 00:33:07,819

YouTube URL: https://www.youtube.com/watch?v=4cRceasctUI


