Title: [2017] The Future of virtio: Riddles, Myths and Surprises by Jens Freimann
Publication date: 2017-11-03
Playlist: KVM Forum 2017
Description: 
	As many guests use virtio for all their IO needs, the performance of virtio puts a hard limit on the system performance. virtio is useful as it's a hardware-independent interface - but for some guests, that independence comes at a performance cost. That's why for the last year the virtio community has been looking at different ways to extend virtio - making it work on the underlying hardware better, but without breaking the indepence. This work made us re-examine several underlying assumptions made during early stages of the design of the virtio ring. Some of the findings from this re-examination were surprising; some of the common assumptions are a myth. This presentation is an update on the progress made on the next version of virtio and its future - it will try to dispel some myths and describe some things about virtio that puzzled us and some things we found out that surprised us.

---

Jens Freimann
Red Hat

Jens is a Senior Software Engineer at Red Hat, working on Virtio and networking in QEMU, KVM and DPDK.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:06,170 --> 00:00:13,349
this is talk about recent work on

00:00:09,510 --> 00:00:15,599
extending the vertical specification you

00:00:13,349 --> 00:00:20,580
see the title and the first surprises

00:00:15,599 --> 00:00:22,380
I'm not Michael Sirkin so he couldn't

00:00:20,580 --> 00:00:25,710
make it his flight was canceled last

00:00:22,380 --> 00:00:29,250
minute my name is Jen's Freeman I work

00:00:25,710 --> 00:00:31,890
with him on the same team I've been

00:00:29,250 --> 00:00:35,010
working on the new weather in layout for

00:00:31,890 --> 00:00:36,719
the past couple of months and I'm

00:00:35,010 --> 00:00:41,219
filling in for Michael today so this

00:00:36,719 --> 00:00:43,200
really is his presentation okay so the

00:00:41,219 --> 00:00:46,320
goal was extending where I was on

00:00:43,200 --> 00:00:48,450
improving its performance we want to

00:00:46,320 --> 00:00:51,360
make it a better fit for new workloads

00:00:48,450 --> 00:00:54,289
and currently the support for that is

00:00:51,360 --> 00:00:57,629
not well so there were several

00:00:54,289 --> 00:01:01,289
underlying assumptions from when where

00:00:57,629 --> 00:01:04,979
IO was during its early stages of its

00:01:01,289 --> 00:01:10,680
design we looked at them again and some

00:01:04,979 --> 00:01:13,439
of those results were surprising so

00:01:10,680 --> 00:01:15,630
there are two some common misconceptions

00:01:13,439 --> 00:01:17,939
or misunderstandings about verda o how

00:01:15,630 --> 00:01:20,220
to work with it or how to extend it and

00:01:17,939 --> 00:01:23,640
we're going to talk about this as well

00:01:20,220 --> 00:01:25,259
today before I go into this we need a

00:01:23,640 --> 00:01:29,670
little bit more background about how the

00:01:25,259 --> 00:01:32,400
current but IO is working so during this

00:01:29,670 --> 00:01:34,710
talk I will mention a lot we will add a

00:01:32,400 --> 00:01:38,130
new feature bit or just needs a new

00:01:34,710 --> 00:01:39,960
feature bit and what this means will

00:01:38,130 --> 00:01:42,840
talk about first then we can continue

00:01:39,960 --> 00:01:45,720
with other stuff so let's go about the

00:01:42,840 --> 00:01:49,710
energization of a vm with respect to

00:01:45,720 --> 00:01:53,100
Vallejo so every device has a device ID

00:01:49,710 --> 00:01:56,040
right and ID one is for network ID two

00:01:53,100 --> 00:01:58,979
is for block and so on and so on the

00:01:56,040 --> 00:02:03,659
guest to us it uses this ID to low to

00:01:58,979 --> 00:02:06,299
correct driver for video device each

00:02:03,659 --> 00:02:08,489
video device has two bit knob registers

00:02:06,299 --> 00:02:10,800
and collectively we call them feature

00:02:08,489 --> 00:02:13,520
boots so one of them is called the

00:02:10,800 --> 00:02:16,310
device features and the

00:02:13,520 --> 00:02:19,610
one is the driver features and then has

00:02:16,310 --> 00:02:23,980
also status register and they recite

00:02:19,610 --> 00:02:26,950
somewhere and got and shared memory and

00:02:23,980 --> 00:02:31,010
in the device and in the driver memory

00:02:26,950 --> 00:02:36,410
so at the moment about 64-bit registers

00:02:31,010 --> 00:02:39,020
but there is enough to extent so here's

00:02:36,410 --> 00:02:42,230
how they used the driver we'll start by

00:02:39,020 --> 00:02:45,800
reading the device features and a copy

00:02:42,230 --> 00:02:47,870
of it is loaded into VM memory built

00:02:45,800 --> 00:02:50,840
into drive as a mask of supported

00:02:47,870 --> 00:02:53,750
features and that's really just a copy

00:02:50,840 --> 00:02:57,050
of the device features recorded when the

00:02:53,750 --> 00:03:00,020
driver was developed the job of the

00:02:57,050 --> 00:03:04,480
driver now is to do a bitwise end of the

00:03:00,020 --> 00:03:08,210
device and Driver features in via memory

00:03:04,480 --> 00:03:11,240
the result is then used by the driver to

00:03:08,210 --> 00:03:13,160
determine how to drive the device what

00:03:11,240 --> 00:03:14,900
features can be used what can't be used

00:03:13,160 --> 00:03:18,080
what does is what does it support and

00:03:14,900 --> 00:03:20,390
what not and this is also written into

00:03:18,080 --> 00:03:22,880
the driver features register on the

00:03:20,390 --> 00:03:26,180
device so both know what the other side

00:03:22,880 --> 00:03:29,060
supports at this point the device can

00:03:26,180 --> 00:03:31,790
validate the feature register value and

00:03:29,060 --> 00:03:36,530
if it is valid it can set the status

00:03:31,790 --> 00:03:39,080
register features okay but if not then

00:03:36,530 --> 00:03:41,720
this bit will be cleared this means the

00:03:39,080 --> 00:03:44,060
driver can check the status and it can

00:03:41,720 --> 00:03:46,760
either start using the device or it will

00:03:44,060 --> 00:03:50,450
fail gracefully and give a warning to

00:03:46,760 --> 00:03:53,330
the user okay with this out of the way

00:03:50,450 --> 00:03:55,880
let's talk about the first nurse so some

00:03:53,330 --> 00:03:58,670
people assume that when they change

00:03:55,880 --> 00:04:00,530
video or extended this would break

00:03:58,670 --> 00:04:03,620
existing and store drivers or

00:04:00,530 --> 00:04:06,680
hypervisors but that's not true because

00:04:03,620 --> 00:04:08,870
the feature negotiation it allows us to

00:04:06,680 --> 00:04:11,750
make changes with full backward and

00:04:08,870 --> 00:04:15,830
forward compatibility let's see how this

00:04:11,750 --> 00:04:19,160
works so let's say we have want to make

00:04:15,830 --> 00:04:25,250
a change to how a video input device

00:04:19,160 --> 00:04:30,180
works say we want to add a new feature

00:04:25,250 --> 00:04:33,630
multi-touch for this input device okay

00:04:30,180 --> 00:04:36,600
so we assign it because whenever we make

00:04:33,630 --> 00:04:38,640
guests visible change to device that

00:04:36,600 --> 00:04:44,670
means we have to assign it a new feature

00:04:38,640 --> 00:04:47,930
but okay we assign but zero to our new

00:04:44,670 --> 00:04:51,210
multi-touch feature and any input device

00:04:47,930 --> 00:04:55,860
implementing this will have to set this

00:04:51,210 --> 00:04:58,950
and and features register so new driver

00:04:55,860 --> 00:05:00,570
implementing multi-touch it would set

00:04:58,950 --> 00:05:03,360
our corresponding bit and the driver

00:05:00,570 --> 00:05:05,550
features then combining device and

00:05:03,360 --> 00:05:07,980
Driver features it was still reside and

00:05:05,550 --> 00:05:11,250
a bit zero set can be anthem together

00:05:07,980 --> 00:05:14,760
right so both device and driver can test

00:05:11,250 --> 00:05:18,000
this bit zero to verify if they can

00:05:14,760 --> 00:05:20,220
support multi-touch or not okay let's

00:05:18,000 --> 00:05:23,160
see what happens when we use an existing

00:05:20,220 --> 00:05:26,730
driver with the new device with this

00:05:23,160 --> 00:05:31,140
change now the driver will read the host

00:05:26,730 --> 00:05:33,390
features register was bit 0 set but bit

00:05:31,140 --> 00:05:36,870
0 is clear in a guest supported feature

00:05:33,390 --> 00:05:39,990
mask so that means it is cleared when we

00:05:36,870 --> 00:05:41,910
combine host and guest features says the

00:05:39,990 --> 00:05:47,970
driver writes out 0 into the driver

00:05:41,910 --> 00:05:49,380
features register on the device and then

00:05:47,970 --> 00:05:54,420
it would work exactly as it's supposed

00:05:49,380 --> 00:05:56,430
to be what about the device the device

00:05:54,420 --> 00:05:59,460
looks at the bit in the device feature

00:05:56,430 --> 00:06:03,480
Rochester that it has received from the

00:05:59,460 --> 00:06:07,320
guest it will see that this driver has

00:06:03,480 --> 00:06:10,170
cleared with 0 that means it's a guest

00:06:07,320 --> 00:06:13,620
without multi-touch support it can now

00:06:10,170 --> 00:06:16,320
use this indication and switch for

00:06:13,620 --> 00:06:19,560
example to a compatibility mode and it

00:06:16,320 --> 00:06:23,820
would behave just as expected by the old

00:06:19,560 --> 00:06:27,090
driver alternatively if the device does

00:06:23,820 --> 00:06:29,520
not support compatibility mode it could

00:06:27,090 --> 00:06:33,060
clear the features ok status register

00:06:29,520 --> 00:06:37,450
flag and that would cause the driver to

00:06:33,060 --> 00:06:38,550
gracefully failed to attached the device

00:06:37,450 --> 00:06:41,770
[Music]

00:06:38,550 --> 00:06:45,880
yeah that's okay

00:06:41,770 --> 00:06:49,900
so we saw that a single device can be

00:06:45,880 --> 00:06:53,200
compatible with old and new drivers what

00:06:49,900 --> 00:06:56,050
about the reverse a new driver has a bit

00:06:53,200 --> 00:06:58,900
set and a supported feature mask it will

00:06:56,050 --> 00:07:01,570
access an old device and detect zero and

00:06:58,900 --> 00:07:04,420
the device features register as the

00:07:01,570 --> 00:07:07,570
result we end up with zero and on driver

00:07:04,420 --> 00:07:09,910
features register indicating to the

00:07:07,570 --> 00:07:12,460
driver to disable multi-touch for the

00:07:09,910 --> 00:07:15,010
guests so in a way compatible with the

00:07:12,460 --> 00:07:17,620
old device this works in the reverse

00:07:15,010 --> 00:07:20,110
direction as well if there's a feature

00:07:17,620 --> 00:07:22,780
you want to drop you can do this by

00:07:20,110 --> 00:07:24,610
clearing a bit in the device and Driver

00:07:22,780 --> 00:07:29,440
feature bitmaps without affecting any

00:07:24,610 --> 00:07:31,540
other functionality okay and in fact

00:07:29,440 --> 00:07:33,910
this feature negotiation is working

00:07:31,540 --> 00:07:38,050
quite well we have been able to

00:07:33,910 --> 00:07:39,910
transition from Vario 0.9 to completely

00:07:38,050 --> 00:07:43,330
different register layout was what I

00:07:39,910 --> 00:07:46,420
wanted one auto without breaking any

00:07:43,330 --> 00:07:50,230
devices or drivers the default was

00:07:46,420 --> 00:07:52,120
changed in qmu 2.7 there was about a

00:07:50,230 --> 00:07:55,110
year ago and so far there have been a

00:07:52,120 --> 00:07:57,490
few bugs but no major complaints about

00:07:55,110 --> 00:08:02,500
compatibility so it is working quite

00:07:57,490 --> 00:08:04,440
well we can say that we can make big

00:08:02,500 --> 00:08:12,430
interface changes here without breaking

00:08:04,440 --> 00:08:14,890
compatibility next myth is it true that

00:08:12,430 --> 00:08:17,710
any change that I want to make to avert

00:08:14,890 --> 00:08:22,450
our device requires me to write or

00:08:17,710 --> 00:08:24,610
change a full special occasion you know

00:08:22,450 --> 00:08:28,240
it's not completely wrong you're

00:08:24,610 --> 00:08:33,940
absolutely encouraged to do that but it

00:08:28,240 --> 00:08:36,550
shouldn't scare you away it's not a top

00:08:33,940 --> 00:08:39,880
priority at least not for all that our

00:08:36,550 --> 00:08:42,750
developers so what are our priorities

00:08:39,880 --> 00:08:42,750
yes

00:08:43,270 --> 00:09:01,370
yes the Oasis video standard yes okay so

00:08:58,250 --> 00:09:03,650
our priorities are we want code

00:09:01,370 --> 00:09:06,380
compatibility we want to avoid conflicts

00:09:03,650 --> 00:09:10,340
between existing or past and future

00:09:06,380 --> 00:09:13,280
drivers and devices intellectual

00:09:10,340 --> 00:09:15,860
property rights compatibility we need to

00:09:13,280 --> 00:09:19,250
allow others to implement compatible

00:09:15,860 --> 00:09:22,190
with our devices and drivers and then as

00:09:19,250 --> 00:09:24,140
interface compatibility we want to allow

00:09:22,190 --> 00:09:29,630
different implementations to

00:09:24,140 --> 00:09:32,600
interoperate with each other so how do

00:09:29,630 --> 00:09:34,610
you achieve code compatibility for new

00:09:32,600 --> 00:09:38,120
devices you just need to reserve a

00:09:34,610 --> 00:09:40,970
device ID on top this is a minimal patch

00:09:38,120 --> 00:09:43,430
to reserve a device ID and this will

00:09:40,970 --> 00:09:46,940
guarantee that no other future Vario

00:09:43,430 --> 00:09:50,390
driver will be bound to your device if

00:09:46,940 --> 00:09:52,520
you are changing an existing device then

00:09:50,390 --> 00:09:55,070
the minimal patch reserves just a

00:09:52,520 --> 00:09:58,760
feature bit here's an example for a

00:09:55,070 --> 00:10:01,340
balloon device so this really is not

00:09:58,760 --> 00:10:05,870
much effort it's like one line in each

00:10:01,340 --> 00:10:09,920
case don't be scared by that how do you

00:10:05,870 --> 00:10:14,060
get this into the spec you can download

00:10:09,920 --> 00:10:16,610
you can get cloned the specification and

00:10:14,060 --> 00:10:19,730
the letter a lot edge code and you can

00:10:16,610 --> 00:10:22,760
change it you can build it it will build

00:10:19,730 --> 00:10:27,050
on Linux it will also most likely build

00:10:22,760 --> 00:10:29,060
on Windows or Mac I guess what you do

00:10:27,050 --> 00:10:31,310
then is to subscribe to this mailing

00:10:29,060 --> 00:10:33,470
list where I'll comment standing empty

00:10:31,310 --> 00:10:36,080
email there and you will be subscribed

00:10:33,470 --> 00:10:39,200
and then you need to confirm your

00:10:36,080 --> 00:10:41,900
subscription you send your patch to this

00:10:39,200 --> 00:10:43,550
mailing list for comments everyone's

00:10:41,900 --> 00:10:46,190
happy there will be no replies no

00:10:43,550 --> 00:10:49,220
comments and after a while maybe after a

00:10:46,190 --> 00:10:53,240
week you ask send an email again you ask

00:10:49,220 --> 00:10:54,600
for a vote for ballot you put Michael

00:10:53,240 --> 00:10:57,810
Serkan he's the chair

00:10:54,600 --> 00:11:00,029
the Technical Committee on CC and then

00:10:57,810 --> 00:11:03,389
the sport will be open for another week

00:11:00,029 --> 00:11:06,470
so it's about two weeks to get your

00:11:03,389 --> 00:11:06,470
change in two respects

00:11:08,420 --> 00:11:15,870
yeah so we generally ask that we have an

00:11:13,230 --> 00:11:19,230
open source implementation draft at

00:11:15,870 --> 00:11:21,149
least available and that you agree to

00:11:19,230 --> 00:11:24,329
the non assertion mode of the work of

00:11:21,149 --> 00:11:26,670
the world io spec what you'd probably do

00:11:24,329 --> 00:11:30,300
for this you subscribe to the very odd F

00:11:26,670 --> 00:11:33,029
mailing list you'll be asked to agree to

00:11:30,300 --> 00:11:35,220
these IPR rules and then you send the

00:11:33,029 --> 00:11:40,319
send your patches to this mailing list

00:11:35,220 --> 00:11:44,480
and many devices stop at this point one

00:11:40,319 --> 00:11:47,759
example would be what I or GPU device

00:11:44,480 --> 00:11:50,940
next one is interface compatibility this

00:11:47,759 --> 00:11:53,819
one is hard so to interoperate with

00:11:50,940 --> 00:11:57,449
others we really need good documentation

00:11:53,819 --> 00:12:00,360
and in the earlier case you would add a

00:11:57,449 --> 00:12:02,519
full description of new feature words to

00:12:00,360 --> 00:12:05,279
the specification of the new features to

00:12:02,519 --> 00:12:08,189
the specification you don't have to be a

00:12:05,279 --> 00:12:11,639
member of the Vireo technical committee

00:12:08,189 --> 00:12:14,670
to do this some things to consider when

00:12:11,639 --> 00:12:17,699
you write the documentation please

00:12:14,670 --> 00:12:20,540
separate device and driver requirements

00:12:17,699 --> 00:12:23,160
and separate of sector subsections and

00:12:20,540 --> 00:12:27,000
only in those you use those keywords

00:12:23,160 --> 00:12:31,139
must should marry and so on ask for help

00:12:27,000 --> 00:12:33,509
if you don't know how to start try to

00:12:31,139 --> 00:12:39,449
avoid grammar and spelling mistakes as

00:12:33,509 --> 00:12:41,819
good as you can so some examples at this

00:12:39,449 --> 00:12:46,380
stage would be video crypto and video

00:12:41,819 --> 00:12:48,360
input devices specification is still

00:12:46,380 --> 00:12:53,850
work-in-progress implementations are

00:12:48,360 --> 00:12:56,370
already in use now if you maintain a

00:12:53,850 --> 00:12:58,399
part of the specification then you could

00:12:56,370 --> 00:13:02,819
consider or you should consider becoming

00:12:58,399 --> 00:13:04,980
joining the Technical Committee because

00:13:02,819 --> 00:13:08,809
that means you can also vote on spec

00:13:04,980 --> 00:13:12,329
changes membership is open for everyone

00:13:08,809 --> 00:13:14,610
maybe your employers already a member of

00:13:12,329 --> 00:13:16,889
the laces then there's no problem

00:13:14,610 --> 00:13:20,339
there's no limitation to whom and how

00:13:16,889 --> 00:13:22,199
many employees can take part there so

00:13:20,339 --> 00:13:27,329
you might just be able to start to

00:13:22,199 --> 00:13:31,709
participate there ok let's come to the

00:13:27,329 --> 00:13:35,040
next one the word I expect the current

00:13:31,709 --> 00:13:38,399
one it seems to imply that the layout

00:13:35,040 --> 00:13:42,059
that was chosen as optimal from a cache

00:13:38,399 --> 00:13:46,649
utilization point of view but is this

00:13:42,059 --> 00:13:49,290
really true so to examine this

00:13:46,649 --> 00:13:52,889
assumption let's say it is true we will

00:13:49,290 --> 00:13:56,399
look at it look at it and get some

00:13:52,889 --> 00:13:58,889
background information so when I old

00:13:56,399 --> 00:14:01,380
does request between house and guests by

00:13:58,889 --> 00:14:04,500
storing them and that queue data

00:14:01,380 --> 00:14:08,850
structure and shared memory and this is

00:14:04,500 --> 00:14:10,740
what it looks like right now so we have

00:14:08,850 --> 00:14:13,050
an available ring we have a new string

00:14:10,740 --> 00:14:22,110
you have descriptors and air start and a

00:14:13,050 --> 00:14:24,120
table and we have these indices the

00:14:22,110 --> 00:14:26,339
buffer address and the lengths are

00:14:24,120 --> 00:14:28,259
stored in these 16 by descriptors and

00:14:26,339 --> 00:14:29,480
all of them are stored in the table

00:14:28,259 --> 00:14:32,759
right there

00:14:29,480 --> 00:14:34,620
if a buffer has not contiguous you can

00:14:32,759 --> 00:14:39,480
chain them together by adding a flag to

00:14:34,620 --> 00:14:42,439
the descriptor where in the table does

00:14:39,480 --> 00:14:45,209
descriptor is foot is up to the driver a

00:14:42,439 --> 00:14:48,209
request is then identified by the head

00:14:45,209 --> 00:14:52,500
index which is a 16 byte offset into

00:14:48,209 --> 00:14:55,290
this table head indices are stored in

00:14:52,500 --> 00:14:58,380
the available range to signal to the

00:14:55,290 --> 00:15:01,290
device which energy which of these

00:14:58,380 --> 00:15:03,149
indices are ballot the driver will

00:15:01,290 --> 00:15:06,360
maintain and available index in shared

00:15:03,149 --> 00:15:07,069
memory as well so after executing the

00:15:06,360 --> 00:15:10,079
sequest

00:15:07,069 --> 00:15:13,529
the device will store does-- head index

00:15:10,079 --> 00:15:15,480
in the used ring it also stores the

00:15:13,529 --> 00:15:18,269
lengths of the used part of the buffer

00:15:15,480 --> 00:15:19,970
and then it will increment the used and

00:15:18,269 --> 00:15:23,350
x value and

00:15:19,970 --> 00:15:24,589
memory and signal the driver by that

00:15:23,350 --> 00:15:28,040
okay

00:15:24,589 --> 00:15:31,129
so fundamentally we see that house and

00:15:28,040 --> 00:15:34,279
guests they communicate by passing

00:15:31,129 --> 00:15:38,750
messages between CPUs using shared

00:15:34,279 --> 00:15:41,420
memory and how do CPUs to that so at a

00:15:38,750 --> 00:15:44,600
very low level when one CPU accesses

00:15:41,420 --> 00:15:47,269
memory that is modified by another CPU

00:15:44,600 --> 00:15:49,639
as well this will cause the CPUs to

00:15:47,269 --> 00:15:52,220
synchronize their caches and I do that

00:15:49,639 --> 00:15:55,850
by exchanging cache coherence protocol

00:15:52,220 --> 00:15:58,100
messages for example some architectures

00:15:55,850 --> 00:16:01,220
when a CPU accesses memory that was

00:15:58,100 --> 00:16:04,370
previously accessed by another CPU that

00:16:01,220 --> 00:16:06,170
will also cause a cache miss and the

00:16:04,370 --> 00:16:08,990
number of these messages that are

00:16:06,170 --> 00:16:11,870
exchanged and the Missis this will

00:16:08,990 --> 00:16:15,680
directly impact the communication

00:16:11,870 --> 00:16:21,199
latency we have here so let's count

00:16:15,680 --> 00:16:23,240
cache misses was very old one our queue

00:16:21,199 --> 00:16:25,759
consists of these five parts with five

00:16:23,240 --> 00:16:28,220
data structures and a buffer that moves

00:16:25,759 --> 00:16:30,819
between host and guest each of these

00:16:28,220 --> 00:16:34,040
parts is written and read at least once

00:16:30,819 --> 00:16:36,709
so that implies five cache misses per

00:16:34,040 --> 00:16:39,050
buffer if we don't do batching if we do

00:16:36,709 --> 00:16:41,209
batching it looks a little bit better so

00:16:39,050 --> 00:16:45,079
sometimes the driver will be available

00:16:41,209 --> 00:16:48,470
be able to submit a batch of multiple

00:16:45,079 --> 00:16:51,610
requests at once and with dispatching to

00:16:48,470 --> 00:16:54,199
Pepa for her overhead is lower as

00:16:51,610 --> 00:16:57,379
multiple buffers fit in a single cache

00:16:54,199 --> 00:17:00,589
line widths patch size had to for for

00:16:57,379 --> 00:17:04,850
example a single 64 byte cache line

00:17:00,589 --> 00:17:08,120
holds for entries of each kind so that

00:17:04,850 --> 00:17:14,000
gives us five misses therefore buffers

00:17:08,120 --> 00:17:16,789
can we measure this overheads so here's

00:17:14,000 --> 00:17:20,780
a small micro benchmark it's from over a

00:17:16,789 --> 00:17:23,169
year ago my two data spectrum try it's

00:17:20,780 --> 00:17:26,809
trying to measure the overhead of cache

00:17:23,169 --> 00:17:29,390
synchronization and we measure the cache

00:17:26,809 --> 00:17:31,850
overhead by comparing the same micro

00:17:29,390 --> 00:17:34,040
benchmark when running on two CPUs

00:17:31,850 --> 00:17:37,160
with shared and separate memory caches

00:17:34,040 --> 00:17:39,530
and you can see that most of the time in

00:17:37,160 --> 00:17:42,290
this benchmark is actually spent on

00:17:39,530 --> 00:17:47,380
cache synchronization especially without

00:17:42,290 --> 00:17:51,410
patching how can we reduce this overhead

00:17:47,380 --> 00:17:53,780
so the information that we store in this

00:17:51,410 --> 00:17:56,660
word queue data structure it's spread

00:17:53,780 --> 00:17:58,940
over quite a few data structures what if

00:17:56,660 --> 00:18:03,170
we would pack them together more tightly

00:17:58,940 --> 00:18:07,700
and how about we just use one data

00:18:03,170 --> 00:18:09,860
structure a single one so we get rid of

00:18:07,700 --> 00:18:12,860
the available and the new string and the

00:18:09,860 --> 00:18:14,420
next structure is completely so by the

00:18:12,860 --> 00:18:17,710
way this is something that we are

00:18:14,420 --> 00:18:20,420
looking into right now were discussing

00:18:17,710 --> 00:18:25,100
so we get rid of available a new string

00:18:20,420 --> 00:18:29,660
and this index data fields and we just

00:18:25,100 --> 00:18:32,860
use a descriptor ring we make us make

00:18:29,660 --> 00:18:35,270
the guest right to script us out in

00:18:32,860 --> 00:18:37,450
descriptor in order and was an each

00:18:35,270 --> 00:18:41,240
descriptor we had three fields and

00:18:37,450 --> 00:18:47,930
available but a useful and under script

00:18:41,240 --> 00:18:50,060
or ID okay how to make buffers available

00:18:47,930 --> 00:18:52,550
to the host to guest for write them out

00:18:50,060 --> 00:18:55,400
and the descriptors in a ring and then

00:18:52,550 --> 00:18:57,410
it will flip the available but it

00:18:55,400 --> 00:19:01,550
implies that this is now okay for the

00:18:57,410 --> 00:19:03,800
host to consume this descriptor now the

00:19:01,550 --> 00:19:06,560
house can process those descriptors in

00:19:03,800 --> 00:19:09,920
any order each descriptor has an ID

00:19:06,560 --> 00:19:12,710
field and after processing the host were

00:19:09,920 --> 00:19:17,450
right to process the script or ID in the

00:19:12,710 --> 00:19:19,760
ring then it will flip the you slit and

00:19:17,450 --> 00:19:23,480
as means that for the guest that this

00:19:19,760 --> 00:19:28,430
entry has been used and it can now reuse

00:19:23,480 --> 00:19:33,890
it for a new buffer so here's a special

00:19:28,430 --> 00:19:37,120
case scope the ring was one entry driver

00:19:33,890 --> 00:19:38,750
and device they need to maintain

00:19:37,120 --> 00:19:42,470
internally each of

00:19:38,750 --> 00:19:45,410
a single bit counter it will start at 1

00:19:42,470 --> 00:19:47,300
and we'll change it each time we start

00:19:45,410 --> 00:19:50,930
writing out descriptors at the beginning

00:19:47,300 --> 00:19:53,870
of the Ring this fit had stored

00:19:50,930 --> 00:19:57,770
internally its past us available and you

00:19:53,870 --> 00:20:01,400
spit in the descriptors so let's assume

00:19:57,770 --> 00:20:04,370
that the ring is 0 initialized on the

00:20:01,400 --> 00:20:07,190
first iteration over the ring to mock

00:20:04,370 --> 00:20:11,150
descriptors available the available bit

00:20:07,190 --> 00:20:14,660
is set to 1 on an acceleration it's set

00:20:11,150 --> 00:20:17,210
to 0 and so on we change every time the

00:20:14,660 --> 00:20:22,430
cross the ring boundary in the first

00:20:17,210 --> 00:20:24,950
descriptor so tomorrow script has used

00:20:22,430 --> 00:20:27,590
the use bit is set to 1 on the first

00:20:24,950 --> 00:20:33,080
iteration and 0 on a second

00:20:27,590 --> 00:20:40,430
and we continue doing this this would be

00:20:33,080 --> 00:20:42,260
some so idol code what you can see is we

00:20:40,430 --> 00:20:46,940
read an entry and later we write it out

00:20:42,260 --> 00:20:50,090
so best case here is the read will cause

00:20:46,940 --> 00:20:50,620
a cache miss and the rightful be a cache

00:20:50,090 --> 00:20:53,960
it

00:20:50,620 --> 00:21:00,770
worst case both successors cause the

00:20:53,960 --> 00:21:08,240
customers okay so requests don't have to

00:21:00,770 --> 00:21:10,310
be used in order the host can to do it

00:21:08,240 --> 00:21:15,610
out of order so this is an example where

00:21:10,310 --> 00:21:18,050
the guests made 9 entries available and

00:21:15,610 --> 00:21:22,430
and it's starting out by using the 9th

00:21:18,050 --> 00:21:27,350
century originally both available and

00:21:22,430 --> 00:21:29,450
use flags are 0 initialized means the

00:21:27,350 --> 00:21:31,190
guest makes buffers available by

00:21:29,450 --> 00:21:34,610
changing available flat with the

00:21:31,190 --> 00:21:36,620
available flag from 0 to 1 host writes

00:21:34,610 --> 00:21:39,110
ad of the ninth buffer at the beginning

00:21:36,620 --> 00:21:42,350
of the ring and then flips to you speed

00:21:39,110 --> 00:21:45,410
from 0 to 1 this will allow the guest to

00:21:42,350 --> 00:21:48,170
override the entry next time it has to

00:21:45,410 --> 00:21:48,429
and it will then flip the available back

00:21:48,170 --> 00:21:53,940
to

00:21:48,429 --> 00:21:57,909
zero what does it mean for CPU caching

00:21:53,940 --> 00:22:01,240
we get 2 to 4 meses pair buffer with no

00:21:57,909 --> 00:22:05,169
batching and half to oneness when

00:22:01,240 --> 00:22:07,240
batching up to 4 buffers this seems

00:22:05,169 --> 00:22:13,029
better than what we have right now even

00:22:07,240 --> 00:22:17,049
in the worst case seems better we can do

00:22:13,029 --> 00:22:19,240
it differently - so did a script ID it's

00:22:17,049 --> 00:22:23,320
also useful for when the host processes

00:22:19,240 --> 00:22:26,320
the ring in order because sometimes the

00:22:23,320 --> 00:22:28,629
only meaningful information or the

00:22:26,320 --> 00:22:31,990
single useful bit of information for the

00:22:28,629 --> 00:22:34,840
script is has it been used and in this

00:22:31,990 --> 00:22:38,289
case we could also write reduce the

00:22:34,840 --> 00:22:40,179
number of memory writes and also the

00:22:38,289 --> 00:22:45,730
amount of messages that need to be

00:22:40,179 --> 00:22:49,240
exchanged between CPUs we do this by

00:22:45,730 --> 00:22:52,210
allowing it to skip just skip writing

00:22:49,240 --> 00:22:54,970
out some of those descriptions the

00:22:52,210 --> 00:22:59,499
driver will then use the feature bit to

00:22:54,970 --> 00:23:02,129
detect we're processing in order and act

00:22:59,499 --> 00:23:02,129
accordingly

00:23:02,519 --> 00:23:15,789
ok this is a comparison we see that

00:23:12,759 --> 00:23:19,090
without patching we managed to reduce

00:23:15,789 --> 00:23:22,269
the cache overhead almost by a factor of

00:23:19,090 --> 00:23:24,340
2 was patching the effect us a little

00:23:22,269 --> 00:23:27,700
bit smaller but it's still very

00:23:24,340 --> 00:23:29,470
noticeable and Michael also tested the

00:23:27,700 --> 00:23:32,919
shared cache performance of the new

00:23:29,470 --> 00:23:36,879
layout to measure the processing

00:23:32,919 --> 00:23:38,860
overhead as you can see it performs more

00:23:36,879 --> 00:23:41,019
or less the same as the old one so

00:23:38,860 --> 00:23:44,350
better cache behavior that our cache

00:23:41,019 --> 00:23:50,200
behavior is the main reason that the new

00:23:44,350 --> 00:23:55,360
layout is faster this is an actual

00:23:50,200 --> 00:23:57,980
workload while it's a test and a PvP

00:23:55,360 --> 00:24:01,909
setup was a packet generator

00:23:57,980 --> 00:24:05,919
on one system and device on a test as

00:24:01,909 --> 00:24:08,630
another system running an actual guest

00:24:05,919 --> 00:24:14,510
this is done with an initial prototype

00:24:08,630 --> 00:24:17,330
implementation 64 byte packets the

00:24:14,510 --> 00:24:21,049
improvement was was the old layout and

00:24:17,330 --> 00:24:24,919
the setup 18 point 8 million packages

00:24:21,049 --> 00:24:28,519
per second compared to two 22.6 was the

00:24:24,919 --> 00:24:29,169
new layout so this is using slow Network

00:24:28,519 --> 00:24:31,639
cuts

00:24:29,169 --> 00:24:34,519
what means was larger packets we will

00:24:31,639 --> 00:24:37,519
just hit wire speed and the setup and I

00:24:34,519 --> 00:24:41,480
didn't get around to measure bigger

00:24:37,519 --> 00:24:46,429
frame sizes with faster cards yet that

00:24:41,480 --> 00:24:49,610
should happen very soon so I think we

00:24:46,429 --> 00:24:52,130
can say that the vertical layout is not

00:24:49,610 --> 00:24:55,669
really optimal right now for host to

00:24:52,130 --> 00:24:58,250
guest communication but the current

00:24:55,669 --> 00:25:01,549
discussion that we're having our these

00:24:58,250 --> 00:25:06,909
experiments is to be able to us to work

00:25:01,549 --> 00:25:10,970
on that on fixing it okay

00:25:06,909 --> 00:25:15,320
see actually skipping this one let's go

00:25:10,970 --> 00:25:21,590
to number two so usually what I accuse

00:25:15,320 --> 00:25:26,169
they have to be a power of two why not

00:25:21,590 --> 00:25:32,779
write power of two is nice round numbers

00:25:26,169 --> 00:25:36,320
so why not also cache utilization let's

00:25:32,779 --> 00:25:40,880
take for example the CPU was ready to K

00:25:36,320 --> 00:25:44,330
and eight wait associative cache say we

00:25:40,880 --> 00:25:48,889
have a ring with 1k entries and this

00:25:44,330 --> 00:25:54,049
will occupied 16 K kilobytes so that

00:25:48,889 --> 00:25:56,389
means 48 wazers and now consider a

00:25:54,049 --> 00:25:59,600
networking device with two rings for

00:25:56,389 --> 00:26:01,720
transmit and receive respectively if the

00:25:59,600 --> 00:26:05,630
attempt to use this device for two-way

00:26:01,720 --> 00:26:09,380
communication ring access this will push

00:26:05,630 --> 00:26:10,400
all other data out of the cache now if

00:26:09,380 --> 00:26:13,580
we move

00:26:10,400 --> 00:26:16,250
this requirement for power of two we

00:26:13,580 --> 00:26:21,200
could make it a little bit smaller say

00:26:16,250 --> 00:26:22,970
we'll give it 768 entries per ring so

00:26:21,200 --> 00:26:25,309
that would leave us with at least one

00:26:22,970 --> 00:26:30,830
cache line free for something else to do

00:26:25,309 --> 00:26:34,730
okay but isn't power-of-two nicer to

00:26:30,830 --> 00:26:38,480
code doesn't it make code more compact

00:26:34,730 --> 00:26:43,250
and more beautiful but the difference is

00:26:38,480 --> 00:26:45,549
not this big so this is an example of

00:26:43,250 --> 00:26:49,460
how to find the next value descriptor

00:26:45,549 --> 00:26:53,299
with or without a disassembled power of

00:26:49,460 --> 00:26:56,210
touring sighs yes power of two is a

00:26:53,299 --> 00:26:58,510
little bit more concise but only

00:26:56,210 --> 00:26:58,510
slightly

00:26:58,929 --> 00:27:09,220
good coming to the next slide so from a

00:27:05,900 --> 00:27:13,730
guests point of view where i/o devices

00:27:09,220 --> 00:27:15,650
they've tend to be PCI devices and it

00:27:13,730 --> 00:27:18,470
seems natural to assume that things just

00:27:15,650 --> 00:27:20,510
work if you implement a variable device

00:27:18,470 --> 00:27:23,870
in hardware and pass it through to the

00:27:20,510 --> 00:27:27,230
guest things will just work right it's

00:27:23,870 --> 00:27:29,510
mostly true but sometimes we found out

00:27:27,230 --> 00:27:31,429
that hardware devices require different

00:27:29,510 --> 00:27:34,130
optimizations from our host guest

00:27:31,429 --> 00:27:36,830
communication point of view so for

00:27:34,130 --> 00:27:39,620
example software has to process the

00:27:36,830 --> 00:27:42,020
script to us one by one hardware could

00:27:39,620 --> 00:27:45,710
go grab a bunch of them and process them

00:27:42,020 --> 00:27:47,570
in parallel right so that would be nice

00:27:45,710 --> 00:27:50,600
except the device generally does not

00:27:47,570 --> 00:27:53,450
know ahead of time how many descriptors

00:27:50,600 --> 00:27:56,120
are available and to enable this

00:27:53,450 --> 00:27:58,820
optimisation driver kick must give the

00:27:56,120 --> 00:28:03,049
device a hint as to how many descriptors

00:27:58,820 --> 00:28:05,330
are available for processing the device

00:28:03,049 --> 00:28:07,220
10 uses would then use this hint to

00:28:05,330 --> 00:28:12,490
fetch and start processing multiple

00:28:07,220 --> 00:28:16,100
descriptors at once it's one thing

00:28:12,490 --> 00:28:18,190
another one we think about hardware

00:28:16,100 --> 00:28:24,310
rights are expensive

00:28:18,190 --> 00:28:27,850
so another optimization would be writing

00:28:24,310 --> 00:28:31,150
out used to script to us but each device

00:28:27,850 --> 00:28:36,330
right means some overheads so a piece I

00:28:31,150 --> 00:28:40,570
express payload is a full D word and

00:28:36,330 --> 00:28:43,480
that should be expensive we have a

00:28:40,570 --> 00:28:46,630
solution for when processing happens in

00:28:43,480 --> 00:28:49,270
order I mentioned it earlier similar to

00:28:46,630 --> 00:28:51,220
the software case what we're considering

00:28:49,270 --> 00:28:53,680
now in this discussion is actually

00:28:51,220 --> 00:28:56,470
allowing devices to skip writing out

00:28:53,680 --> 00:28:58,450
some use descriptors that means the

00:28:56,470 --> 00:29:01,240
driver will use a feature bit to detect

00:28:58,450 --> 00:29:03,130
the fact that rings are processed in

00:29:01,240 --> 00:29:06,070
order and then it will simply assume

00:29:03,130 --> 00:29:11,890
that any skipped the script us have been

00:29:06,070 --> 00:29:17,430
used so with this I already come to my

00:29:11,890 --> 00:29:21,960
last slide where I have are not one

00:29:17,430 --> 00:29:25,960
shapes up to be a big one a big filiz

00:29:21,960 --> 00:29:28,510
main focus or the is hard work

00:29:25,960 --> 00:29:30,100
performance for hardware floats and

00:29:28,510 --> 00:29:35,080
performance in general for software's

00:29:30,100 --> 00:29:38,320
well obviously contributors contribution

00:29:35,080 --> 00:29:40,510
is open don't be shy the way by the spec

00:29:38,320 --> 00:29:45,670
or ASIS or anything it's really not just

00:29:40,510 --> 00:29:52,060
complicated so good to have you as a

00:29:45,670 --> 00:29:54,240
part of the discussion we will continue

00:29:52,060 --> 00:29:56,170
with some more implementing

00:29:54,240 --> 00:29:58,240
implementation there's a lot to be done

00:29:56,170 --> 00:30:02,860
we will also continue with benchmarking

00:29:58,240 --> 00:30:05,710
and tomorrow as a both session we will

00:30:02,860 --> 00:30:08,440
have one especially for this topic so if

00:30:05,710 --> 00:30:10,030
you're interested in this join us

00:30:08,440 --> 00:30:13,780
tomorrow I think it will be announced

00:30:10,030 --> 00:30:17,880
when and where they start so look at the

00:30:13,780 --> 00:30:22,060
schedule and then we will meet there

00:30:17,880 --> 00:30:25,050
okay that's it from from my side are

00:30:22,060 --> 00:30:25,050
there any quest

00:30:28,820 --> 00:30:34,350
hello oh thanks back to my initial

00:30:32,430 --> 00:30:37,520
mentioning in the beginning and I see

00:30:34,350 --> 00:30:37,520
[Music]

00:30:37,580 --> 00:30:42,780
you on the slide about hey don't be

00:30:41,070 --> 00:30:44,820
afraid to change the standard the

00:30:42,780 --> 00:30:47,760
specification you know it's more of a

00:30:44,820 --> 00:30:48,750
standard so okay but actually there is

00:30:47,760 --> 00:30:50,700
one other step

00:30:48,750 --> 00:30:54,570
I mentioned the design specification and

00:30:50,700 --> 00:30:56,640
I see this in I I work with Vallejo from

00:30:54,570 --> 00:30:58,980
2015 I had to create a bit of custom

00:30:56,640 --> 00:31:00,780
driver for high performance computing

00:30:58,980 --> 00:31:04,260
proof of concept sharing memory

00:31:00,780 --> 00:31:06,840
resources between guests and my first

00:31:04,260 --> 00:31:08,730
task was spent month and a half to

00:31:06,840 --> 00:31:11,130
research to actually understand how

00:31:08,730 --> 00:31:14,010
everything works there was not a single

00:31:11,130 --> 00:31:15,870
like well-written document and yeah and

00:31:14,010 --> 00:31:17,970
other added things are already laughing

00:31:15,870 --> 00:31:20,250
because we are aware of this issue there

00:31:17,970 --> 00:31:23,040
is no design specification and even back

00:31:20,250 --> 00:31:24,990
then I heard this hey join us work with

00:31:23,040 --> 00:31:26,670
us you know from Lennar also and I'm

00:31:24,990 --> 00:31:28,710
thinking yeah sure a lot of people are

00:31:26,670 --> 00:31:30,840
interested but the barrier it's not

00:31:28,710 --> 00:31:32,640
about that people don't have motivation

00:31:30,840 --> 00:31:34,110
they are not interested in part of

00:31:32,640 --> 00:31:36,150
virtualization which is that when they

00:31:34,110 --> 00:31:37,350
go there what they find is a mailing

00:31:36,150 --> 00:31:40,020
list full of interesting information

00:31:37,350 --> 00:31:42,360
people open to talk but you know it

00:31:40,020 --> 00:31:43,950
would be so much easier if we can just

00:31:42,360 --> 00:31:46,320
get some kind of a design specification

00:31:43,950 --> 00:31:49,050
just the baseline so people can really

00:31:46,320 --> 00:31:52,470
enter a bit more easier and then you get

00:31:49,050 --> 00:31:54,300
a lot of more contribution I'm just so

00:31:52,470 --> 00:31:56,760
maybe this would be something part of

00:31:54,300 --> 00:31:58,860
the thinking about it yes you see

00:31:56,760 --> 00:32:00,810
anything about these forming planning

00:31:58,860 --> 00:32:03,000
people because writing documentation

00:32:00,810 --> 00:32:05,160
sure it's not fun but really you know

00:32:03,000 --> 00:32:07,500
design specification it's not the full

00:32:05,160 --> 00:32:10,050
technical documentation just the really

00:32:07,500 --> 00:32:12,480
architecture level I completely agree

00:32:10,050 --> 00:32:16,140
with you that's the barrier if you're

00:32:12,480 --> 00:32:17,730
not if you just read the spec and you

00:32:16,140 --> 00:32:20,490
supposed to understand it and

00:32:17,730 --> 00:32:22,470
implemented it it is not easy

00:32:20,490 --> 00:32:27,240
there should be a document as you say

00:32:22,470 --> 00:32:32,100
that outlines how it works where it

00:32:27,240 --> 00:32:32,770
starts in a more and more normal

00:32:32,100 --> 00:32:35,110
language

00:32:32,770 --> 00:32:38,590
yeah because and somebody needs to write

00:32:35,110 --> 00:32:40,570
that I agree it's someone time and pay

00:32:38,590 --> 00:32:43,240
someone to say hey you're working with

00:32:40,570 --> 00:32:45,429
Rita oh let us give you two weeks or one

00:32:43,240 --> 00:32:47,800
month just to actually give me your

00:32:45,429 --> 00:32:49,929
accumulated knowledge just you know make

00:32:47,800 --> 00:32:51,730
it in black and white just the basic

00:32:49,929 --> 00:32:54,850
just a paragraph because what was the

00:32:51,730 --> 00:32:56,770
barrier for me in 2015 it was just

00:32:54,850 --> 00:32:59,590
simply I had to study the code which is

00:32:56,770 --> 00:33:01,330
fine but it would be so much easier if I

00:32:59,590 --> 00:33:02,920
could just read the code they have a

00:33:01,330 --> 00:33:05,050
question about how actually this works

00:33:02,920 --> 00:33:07,809
okay here's a paragraph - three lines

00:33:05,050 --> 00:33:10,900
really you know that's all I need need

00:33:07,809 --> 00:33:12,670
that so and I - as you can see I didn't

00:33:10,900 --> 00:33:14,320
write it because at the time you know

00:33:12,670 --> 00:33:16,480
the client the company was working for

00:33:14,320 --> 00:33:18,160
yeah we don't want to pay you to write

00:33:16,480 --> 00:33:19,630
the design specification for video we

00:33:18,160 --> 00:33:21,490
want you to implement this solution for

00:33:19,630 --> 00:33:23,530
us design it right a design

00:33:21,490 --> 00:33:27,520
specification for the solution but wait

00:33:23,530 --> 00:33:29,559
there's no time just do the solution so

00:33:27,520 --> 00:33:32,080
do you see anything of this happening in

00:33:29,559 --> 00:33:33,970
the near future I really wanted to

00:33:32,080 --> 00:33:51,010
happen I don't see that it has started

00:33:33,970 --> 00:33:52,900
yet hi so it would be very useful if we

00:33:51,010 --> 00:33:54,490
could also get some hardware examples

00:33:52,900 --> 00:33:56,020
the currently the only one I've seen is

00:33:54,490 --> 00:33:58,059
the Xeon Phi chip and the many

00:33:56,020 --> 00:33:59,800
integrated course and that's not really

00:33:58,059 --> 00:34:01,179
easily understand what kind of examples

00:33:59,800 --> 00:34:02,890
I didn't get so when you want to connect

00:34:01,179 --> 00:34:04,750
an external hardware device actually so

00:34:02,890 --> 00:34:06,429
this young five was a PCIe connected

00:34:04,750 --> 00:34:08,169
device that then leveraged Verdi or to

00:34:06,429 --> 00:34:10,330
give you direct connections oh not

00:34:08,169 --> 00:34:11,980
point-to-point just the same ones but it

00:34:10,330 --> 00:34:13,389
gave you networking and blog devices and

00:34:11,980 --> 00:34:15,820
it would really help it there could be

00:34:13,389 --> 00:34:18,220
more of these devices I just really want

00:34:15,820 --> 00:34:19,950
to use vertical just for Hardware cross

00:34:18,220 --> 00:34:23,409
connection as well not just between

00:34:19,950 --> 00:34:28,109
guests and hypervisors okay good yeah

00:34:23,409 --> 00:34:28,109
I'll I'll take us with me thanks

00:34:34,270 --> 00:34:41,419
hello Christopher Lynch ah so you talked

00:34:38,870 --> 00:34:44,389
a lot about the effects of cache misses

00:34:41,419 --> 00:34:46,780
and so this seems to be an important

00:34:44,389 --> 00:34:49,340
contrary consideration for performance

00:34:46,780 --> 00:34:51,169
what kind of efforts have been put to

00:34:49,340 --> 00:34:53,720
try to preserve some kind of CPU lock

00:34:51,169 --> 00:34:56,090
per CPU locality making sure for

00:34:53,720 --> 00:34:59,120
instance that the driver and the

00:34:56,090 --> 00:35:02,510
relation run on the same CPU things like

00:34:59,120 --> 00:35:05,350
you know maybe spreading out in having

00:35:02,510 --> 00:35:09,470
one index per CPU the physical CPU and

00:35:05,350 --> 00:35:12,050
and trying to look first if I have stuff

00:35:09,470 --> 00:35:13,550
to do on my CPU and otherwise only

00:35:12,050 --> 00:35:20,270
otherwise look at the others to avoid

00:35:13,550 --> 00:35:23,060
thrashing the cache of the other guys so

00:35:20,270 --> 00:35:27,410
say I have a for CPU system one of the

00:35:23,060 --> 00:35:29,990
issues I get is if I write on my side

00:35:27,410 --> 00:35:33,350
I'm going to validate that cache line

00:35:29,990 --> 00:35:35,930
for all the others of use yeah right so

00:35:33,350 --> 00:35:38,120
that's those done looking at it so if

00:35:35,930 --> 00:35:40,790
I'm writing first trying to make sure

00:35:38,120 --> 00:35:42,770
that I write only for my own stuff stuff

00:35:40,790 --> 00:35:45,410
that would be emulated on the same CPU

00:35:42,770 --> 00:35:48,220
on the other side then I mean is this

00:35:45,410 --> 00:35:52,790
effect and if I only look at the other

00:35:48,220 --> 00:35:55,280
CPUs memory once I'm sure I have nothing

00:35:52,790 --> 00:35:57,500
to do on my own CPU then I could

00:35:55,280 --> 00:35:59,780
minimize this effect that would sort of

00:35:57,500 --> 00:36:02,180
imply I have instead of having one

00:35:59,780 --> 00:36:03,860
structure have for them and I look only

00:36:02,180 --> 00:36:08,510
at mine first and then I look at the

00:36:03,860 --> 00:36:12,790
others yeah maybe just think about I'm

00:36:08,510 --> 00:36:12,790
not sure Stefan

00:36:14,690 --> 00:36:19,490
thank you so just as a follow-up to that

00:36:17,630 --> 00:36:21,020
I mean some of the Verdejo devices are

00:36:19,490 --> 00:36:22,820
multi queue and they are designed for

00:36:21,020 --> 00:36:25,970
that but thing to keep in mind is that

00:36:22,820 --> 00:36:28,940
if the virtual machine accesses one of

00:36:25,970 --> 00:36:31,550
these queues normally when a CPU

00:36:28,940 --> 00:36:34,820
accesses Hardware you don't want the CPU

00:36:31,550 --> 00:36:37,340
to be paused while the like while the

00:36:34,820 --> 00:36:38,810
device is running and so it's the same

00:36:37,340 --> 00:36:42,140
thing with Verdi oh we don't want to

00:36:38,810 --> 00:36:43,880
incur a lot of steal time if the i/o if

00:36:42,140 --> 00:36:45,950
the device emulation is happening on the

00:36:43,880 --> 00:36:49,160
host so I think we're still gonna have

00:36:45,950 --> 00:36:51,770
threads because you you probably don't

00:36:49,160 --> 00:36:56,900
want to do everything synchronously when

00:36:51,770 --> 00:37:05,600
the CPU traps so I guess yeah so those

00:36:56,900 --> 00:37:07,070
are the constraints I think yes sir

00:37:05,600 --> 00:37:09,110
that's not what I was suggesting I was

00:37:07,070 --> 00:37:13,100
really more thinking about trying to

00:37:09,110 --> 00:37:17,960
make sure that if you're running for

00:37:13,100 --> 00:37:19,760
instance emulation on CPU one you try to

00:37:17,960 --> 00:37:23,090
first pick workloads that were written

00:37:19,760 --> 00:37:24,920
by CPU one and only then look at the

00:37:23,090 --> 00:37:30,440
queues that are on the other guys and I

00:37:24,920 --> 00:37:33,110
think you can do that so then the answer

00:37:30,440 --> 00:37:35,510
is as Stefan was saying that you don't

00:37:33,110 --> 00:37:38,720
want to an emulation on the same spew so

00:37:35,510 --> 00:37:41,930
that won't happen but what you can do is

00:37:38,720 --> 00:37:45,650
to make sure that your emulation at

00:37:41,930 --> 00:37:47,900
least turns on the same Numa node as the

00:37:45,650 --> 00:37:50,330
device so that at least the cache misses

00:37:47,900 --> 00:37:52,970
are not that expensive and do that for

00:37:50,330 --> 00:37:55,850
example we have support for multiple UCI

00:37:52,970 --> 00:37:57,560
expander bridges so that you can say

00:37:55,850 --> 00:38:00,170
that the particular device has an

00:37:57,560 --> 00:38:01,850
affinity to a particular node and then

00:38:00,170 --> 00:38:04,100
it becomes a configuration problem to

00:38:01,850 --> 00:38:05,720
put your threads and dispute threads on

00:38:04,100 --> 00:38:08,150
the same Numa node and have everything

00:38:05,720 --> 00:38:11,150
matching even potentially up to the

00:38:08,150 --> 00:38:14,000
hardware level so that the author runs

00:38:11,150 --> 00:38:15,890
on the same node as the physical network

00:38:14,000 --> 00:38:18,220
card for example does this answer the

00:38:15,890 --> 00:38:18,220
question

00:38:18,510 --> 00:38:25,720
anyone else yeah okay do you have a mic

00:38:23,700 --> 00:38:27,940
I'm still trying to get my head around

00:38:25,720 --> 00:38:29,580
this this new descriptor mod rehab so

00:38:27,940 --> 00:38:32,800
I'm not sure if this is obvious or not

00:38:29,580 --> 00:38:37,450
Oliverio wonder oh you have a situation

00:38:32,800 --> 00:38:39,910
where a device may consume and an index

00:38:37,450 --> 00:38:43,210
from the avail rank and it's processing

00:38:39,910 --> 00:38:45,010
that that descriptor and because

00:38:43,210 --> 00:38:46,990
requests can be completed out of order

00:38:45,010 --> 00:38:49,150
the aver ring can continue to be

00:38:46,990 --> 00:38:52,270
populated that if ice can continue to

00:38:49,150 --> 00:38:54,400
consume this and the very of a ring can

00:38:52,270 --> 00:38:56,200
just loop around many many times at that

00:38:54,400 --> 00:38:58,870
point just by looking at these data

00:38:56,200 --> 00:39:03,070
structures you're not able to tell

00:38:58,870 --> 00:39:05,200
what's still standing yeah so that's

00:39:03,070 --> 00:39:08,590
this something that this model would put

00:39:05,200 --> 00:39:11,770
address yes so you're talking about the

00:39:08,590 --> 00:39:15,130
case when we wrap before all other

00:39:11,770 --> 00:39:16,150
before everything was used and there was

00:39:15,130 --> 00:39:19,240
something else standing and there's

00:39:16,150 --> 00:39:24,220
something else is standing so this is

00:39:19,240 --> 00:39:28,330
covered by this and so you would the

00:39:24,220 --> 00:39:31,750
driver has to make sure that available

00:39:28,330 --> 00:39:34,060
but it's not equal to the use of it and

00:39:31,750 --> 00:39:37,240
this is how you could tell I don't know

00:39:34,060 --> 00:39:41,050
and keep in mind that you've the device

00:39:37,240 --> 00:39:42,820
the bit will be flipped as well but not

00:39:41,050 --> 00:39:46,120
for if you skipped some of those

00:39:42,820 --> 00:39:49,300
descriptors for those descriptors nobody

00:39:46,120 --> 00:39:50,860
took care of that that's the case

00:39:49,300 --> 00:39:55,990
that's what you're talking about right

00:39:50,860 --> 00:40:00,190
so in this case next time so we wrapped

00:39:55,990 --> 00:40:06,300
around and it's - I think it's on my

00:40:00,190 --> 00:40:12,430
slide the driver needs to make sure that

00:40:06,300 --> 00:40:19,410
available and use but they can't be kind

00:40:12,430 --> 00:40:22,870
of the same value what's that yeah yes

00:40:19,410 --> 00:40:26,530
but then when it when it when wants to -

00:40:22,870 --> 00:40:29,420
right - this descriptor it will notice

00:40:26,530 --> 00:40:32,000
that so its internal value has

00:40:29,420 --> 00:40:35,299
because we crossed the ring border and

00:40:32,000 --> 00:40:38,510
then so and it sees this descripted it

00:40:35,299 --> 00:40:41,210
wasn't used before and it still has the

00:40:38,510 --> 00:40:44,299
old value so let's say now we are count

00:40:41,210 --> 00:40:49,099
as one and it's still zero that's how it

00:40:44,299 --> 00:41:02,900
would tell what's the size of your ID

00:40:49,099 --> 00:41:04,220
field some two bytes I think okay

00:41:02,900 --> 00:41:06,980
singles was the last question

00:41:04,220 --> 00:41:09,109
enough end of the talk if there's

00:41:06,980 --> 00:41:11,920
anything else please consider coming to

00:41:09,109 --> 00:41:17,880
the buff tomorrow thank you

00:41:11,920 --> 00:41:23,739
[Applause]

00:41:17,880 --> 00:41:23,739

YouTube URL: https://www.youtube.com/watch?v=z9cWwgYH97A


