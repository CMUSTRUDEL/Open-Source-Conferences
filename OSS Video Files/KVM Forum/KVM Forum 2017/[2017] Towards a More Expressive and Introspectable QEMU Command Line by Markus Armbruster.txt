Title: [2017] Towards a More Expressive and Introspectable QEMU Command Line by Markus Armbruster
Publication date: 2017-11-22
Playlist: KVM Forum 2017
Description: 
	QEMU command line interface is large and increasingly complex. The infrastructure supporting it no longer meets the growing demands: it is insufficiently expressive for some configuration needs, and its introspection features are inadequate.

In this presentation, we will briefly explore how the command line traditionally works, and where it falls short. I will then present ongoing work to make it match QMP in expressiveness and introspection features. Customary ritual sacrifice to backward compatibility will be performed throughout.

---

Markus Armbruster
Red Hat, Inc.
Senior Software Engineer

"Markus Armbruster is a principal software engineer at Red Hat, and a long term contributor to QEMU. He has worked on block devices, QAPI/QMP, Coverity modeling, device model infrastructure, and more, and is currently maintaining a few of these subsystems. He enjoys a reputation as thorough patch reviewer.

Previous KVM Forum talks: 
""QEMU interface introspection: from hacks to solutions"" (2015), ""Block device configuration done right"" (2013), 
""QEMU's device model qdev: Where do we go from here?"" (2011), ""QEMU's new device model qdev"" (2010)."
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:06,319 --> 00:00:13,070
my name is Marcus Alistair and my job

00:00:10,110 --> 00:00:19,109
today is to keep you awake after lunch

00:00:13,070 --> 00:00:21,779
and what I'm a beautiful topping that

00:00:19,109 --> 00:00:24,510
could be the the lobby cam come online

00:00:21,779 --> 00:00:28,140
this presentation has three parts first

00:00:24,510 --> 00:00:30,779
we'll explore some requirements then

00:00:28,140 --> 00:00:32,940
I'll show how our current come online

00:00:30,779 --> 00:00:36,079
face to meet them and finally I'll

00:00:32,940 --> 00:00:36,079
propose what to do about it

00:00:38,390 --> 00:00:45,270
not one running here Khemu can be a

00:00:43,170 --> 00:00:46,860
simple of this a couple of options

00:00:45,270 --> 00:00:49,200
written without arguments

00:00:46,860 --> 00:00:50,969
and there's one complex option which is

00:00:49,200 --> 00:00:57,780
a comma separated list of key cross

00:00:50,969 --> 00:01:00,030
value simple enough nothing unusual but

00:00:57,780 --> 00:01:05,850
of course we frequently run gem like

00:01:00,030 --> 00:01:09,479
this and here we clearly push the

00:01:05,850 --> 00:01:11,939
command line beyond its intended use use

00:01:09,479 --> 00:01:14,700
cases like this one are better served by

00:01:11,939 --> 00:01:17,729
config files and that leads me to my

00:01:14,700 --> 00:01:20,009
first requirement whatever whatever I

00:01:17,729 --> 00:01:25,290
can do on the command line I want to be

00:01:20,009 --> 00:01:27,180
able to do in a configuration file there

00:01:25,290 --> 00:01:30,479
is another configuration for interface

00:01:27,180 --> 00:01:32,820
and that's the monitor in this talk I

00:01:30,479 --> 00:01:37,890
completely ignore the human monitor and

00:01:32,820 --> 00:01:40,650
use qmp and monitor interchangeably to

00:01:37,890 --> 00:01:42,420
interact with the monitor you send it a

00:01:40,650 --> 00:01:46,490
command you get back a response both

00:01:42,420 --> 00:01:46,490
commands and responses of JSON objects

00:01:46,640 --> 00:01:53,460
why do we have to configuration

00:01:49,409 --> 00:01:55,200
interfaces well at the runtime we have

00:01:53,460 --> 00:01:59,159
to use a monitor because the command

00:01:55,200 --> 00:02:00,810
command line is gone then so initial

00:01:59,159 --> 00:02:03,600
configuration we want to use the command

00:02:00,810 --> 00:02:07,200
line because know we've always done it

00:02:03,600 --> 00:02:09,090
that way and which one like a tanker and

00:02:07,200 --> 00:02:11,119
besides we do anything for backward

00:02:09,090 --> 00:02:11,119
compatibility

00:02:13,420 --> 00:02:21,170
some things we want to configure both in

00:02:17,360 --> 00:02:22,640
the command line and in QP for instance

00:02:21,170 --> 00:02:26,150
we want to create character device

00:02:22,640 --> 00:02:28,459
backends during initial startup with -

00:02:26,150 --> 00:02:31,190
Cardiff and at one time with the compass

00:02:28,459 --> 00:02:32,269
card at our infrastructure should

00:02:31,190 --> 00:02:36,290
support that

00:02:32,269 --> 00:02:39,739
and that means first the command line

00:02:36,290 --> 00:02:42,260
and qmp should be equally expressive so

00:02:39,739 --> 00:02:44,030
Chimpy needs to be able to express the

00:02:42,260 --> 00:02:47,360
command lines key because well you think

00:02:44,030 --> 00:02:52,819
and the command line needs to express

00:02:47,360 --> 00:02:54,680
TPMS JSON objects second we want the two

00:02:52,819 --> 00:02:57,650
external interfaces to drive a single

00:02:54,680 --> 00:03:02,090
internal interface and they should be

00:02:57,650 --> 00:03:05,540
able to do so with equal ease the

00:03:02,090 --> 00:03:07,370
command line evolves constantly this is

00:03:05,540 --> 00:03:10,099
this graph shows the number of lines in

00:03:07,370 --> 00:03:12,950
output of their help over time and as

00:03:10,099 --> 00:03:13,819
you can see it has grown by roughly five

00:03:12,950 --> 00:03:17,060
percent per year

00:03:13,819 --> 00:03:20,810
year over year it used to grow even

00:03:17,060 --> 00:03:23,480
faster programs interfacing with qmo

00:03:20,810 --> 00:03:25,489
need to cope with this change unless

00:03:23,480 --> 00:03:28,670
they are willing to tie themselves to a

00:03:25,489 --> 00:03:30,260
specific version of PMO they need to

00:03:28,670 --> 00:03:33,170
figure out got the camera they God can

00:03:30,260 --> 00:03:35,720
do this is involve questions like what

00:03:33,170 --> 00:03:38,049
options are available say does this

00:03:35,720 --> 00:03:40,900
camera see what support - block death

00:03:38,049 --> 00:03:46,010
what keys does a certain option support

00:03:40,900 --> 00:03:49,489
does their spice support UNIX and what

00:03:46,010 --> 00:03:51,319
really is a certain key supports the

00:03:49,489 --> 00:03:55,040
splash block their support driver us

00:03:51,319 --> 00:03:58,250
cluster in the same way to do that is to

00:03:55,040 --> 00:04:00,260
have QM or expose an interface to

00:03:58,250 --> 00:04:04,780
introspect introspect the command line

00:04:00,260 --> 00:04:04,780
just like it supports in respecting QP

00:04:05,169 --> 00:04:13,430
are these needs met well not really and

00:04:11,060 --> 00:04:16,459
to understand that we need to explore

00:04:13,430 --> 00:04:18,650
how things are done here's a piece of

00:04:16,459 --> 00:04:21,829
code to define a command line option

00:04:18,650 --> 00:04:25,180
simple enough it's the option is called

00:04:21,829 --> 00:04:28,310
- msg it has a mandatory argument

00:04:25,180 --> 00:04:30,320
this is the text for their help as you

00:04:28,310 --> 00:04:32,540
can see it documents the argument can

00:04:30,320 --> 00:04:35,450
either be time stone stem equals on or

00:04:32,540 --> 00:04:37,690
off and this is the text for the user

00:04:35,450 --> 00:04:40,220
manual

00:04:37,690 --> 00:04:42,970
note that the optional arguments format

00:04:40,220 --> 00:04:46,550
is documented in help and manual text

00:04:42,970 --> 00:04:51,350
but it's not specified in code that code

00:04:46,550 --> 00:04:53,890
lives elsewhere now let's explore how

00:04:51,350 --> 00:04:56,360
command-line options are parsing works

00:04:53,890 --> 00:04:58,790
let's start with a really simple option

00:04:56,360 --> 00:05:01,160
like there's out no arguments or that HG

00:04:58,790 --> 00:05:02,570
a simplified named argument well we do

00:05:01,160 --> 00:05:04,960
it the obvious way we get the next

00:05:02,570 --> 00:05:07,700
option an option argument if any and

00:05:04,960 --> 00:05:10,880
then we either execute it right away

00:05:07,700 --> 00:05:12,590
so I print help an exit or re-record the

00:05:10,880 --> 00:05:15,320
option for later in global state and

00:05:12,590 --> 00:05:17,360
then we move on to the next option this

00:05:15,320 --> 00:05:21,820
is how many simple programs work and it

00:05:17,360 --> 00:05:23,870
is how creamer worked until version 0.6

00:05:21,820 --> 00:05:25,910
but of course we have more complex

00:05:23,870 --> 00:05:28,940
options options with complex arguments

00:05:25,910 --> 00:05:32,420
arguments that need to be passed that's

00:05:28,940 --> 00:05:34,400
not how we splice in a puzzle right here

00:05:32,420 --> 00:05:36,530
and we've done that pretty

00:05:34,400 --> 00:05:41,420
enthusiastically so by now we have more

00:05:36,530 --> 00:05:44,360
than 20 of them all different eventually

00:05:41,420 --> 00:05:46,540
somebody noticed realized that adding

00:05:44,360 --> 00:05:49,790
more and more ad hoc process is silly so

00:05:46,540 --> 00:05:51,830
he set out to create the QM options

00:05:49,790 --> 00:05:56,240
argument puzzle to end all key mo chance

00:05:51,830 --> 00:05:58,160
argument passes and that is PMO's it

00:05:56,240 --> 00:06:03,460
passes the generic key equals value

00:05:58,160 --> 00:06:03,460
syntax and it always records for layer

00:06:05,020 --> 00:06:09,800
of course we haven't been able to resist

00:06:08,060 --> 00:06:12,560
the temptation to additionally do a

00:06:09,800 --> 00:06:14,600
little action on the side not in

00:06:12,560 --> 00:06:16,970
Kermit's proper because that's unable to

00:06:14,600 --> 00:06:20,210
do that but in the code using it and

00:06:16,970 --> 00:06:25,660
that is how command line passing works

00:06:20,210 --> 00:06:28,790
since 0 12 until today the old stuff is

00:06:25,660 --> 00:06:30,830
still around all the options that go

00:06:28,790 --> 00:06:35,090
through the orange cloud completely

00:06:30,830 --> 00:06:35,620
bypass queue and all the options that go

00:06:35,090 --> 00:06:37,630
through

00:06:35,620 --> 00:06:41,050
the purple cloud their kind of impure

00:06:37,630 --> 00:06:44,050
because the x-ray options that's not how

00:06:41,050 --> 00:06:47,040
can opt wants to be used and we see why

00:06:44,050 --> 00:06:49,510
this is a problem in a minute

00:06:47,040 --> 00:06:50,470
only the options on the green straight

00:06:49,510 --> 00:06:53,169
in our path

00:06:50,470 --> 00:06:57,790
use care modes as it is intended to be

00:06:53,169 --> 00:07:00,820
used this state of affairs impacts our

00:06:57,790 --> 00:07:02,979
configuration files because our

00:07:00,820 --> 00:07:05,550
configuration files apply to p.m. opt

00:07:02,979 --> 00:07:08,530
state the state here mods records

00:07:05,550 --> 00:07:11,289
that's right config write it out

00:07:08,530 --> 00:07:15,970
there's reconfig treated in and that's

00:07:11,289 --> 00:07:17,500
it so the options that take the green

00:07:15,970 --> 00:07:21,820
straight and narrow path that works just

00:07:17,500 --> 00:07:24,580
fine but for the purple cloud that's

00:07:21,820 --> 00:07:27,810
broken because we read in the state and

00:07:24,580 --> 00:07:30,970
that's it the extractions are skipped

00:07:27,810 --> 00:07:31,720
and for the orange options maybe they

00:07:30,970 --> 00:07:34,060
just don't work

00:07:31,720 --> 00:07:36,580
that's right config doesn't write out

00:07:34,060 --> 00:07:40,020
anything and there it config can't read

00:07:36,580 --> 00:07:42,400
in anything and that means that sadly

00:07:40,020 --> 00:07:46,169
only about one in five command-line

00:07:42,400 --> 00:07:46,169
options actually work in config files

00:07:46,349 --> 00:07:52,060
introspection is similarly affected

00:07:49,260 --> 00:07:54,340
because it's also based on care modes

00:07:52,060 --> 00:07:57,610
Jim piece very command-line options has

00:07:54,340 --> 00:08:00,520
no other source of truth the green

00:07:57,610 --> 00:08:03,039
options again work just fine the purple

00:08:00,520 --> 00:08:04,539
options work fine here too because

00:08:03,039 --> 00:08:07,210
credit command-line options isn't

00:08:04,539 --> 00:08:09,550
bothered by the extractions and their

00:08:07,210 --> 00:08:11,770
orange options are simply not covered in

00:08:09,550 --> 00:08:14,620
introspection so introspection again

00:08:11,770 --> 00:08:19,000
covers roughly 1 out of 5 options it is

00:08:14,620 --> 00:08:20,949
kind of sad so if the orange cloud and

00:08:19,000 --> 00:08:23,710
the purple cloud creates so many

00:08:20,949 --> 00:08:25,810
problems the fix seems obvious get rid

00:08:23,710 --> 00:08:29,440
of have p.m. ops

00:08:25,810 --> 00:08:33,760
take over and this has been in fact at

00:08:29,440 --> 00:08:35,080
length a since forever if something has

00:08:33,760 --> 00:08:39,159
been plan a since forever

00:08:35,080 --> 00:08:42,430
there must be problems one of them is

00:08:39,159 --> 00:08:45,670
obvious we want to stay comparable to

00:08:42,430 --> 00:08:48,440
more than 20 at hoc process but there's

00:08:45,670 --> 00:08:55,200
more cure mops itself as

00:08:48,440 --> 00:08:57,990
and I'll show you first let's look into

00:08:55,200 --> 00:09:00,600
p.m. ops data model it is derived from

00:08:57,990 --> 00:09:02,459
the abstract key cross value syntax so

00:09:00,600 --> 00:09:07,649
this is a list of keyboard parameters

00:09:02,459 --> 00:09:09,720
all optional with string values the

00:09:07,649 --> 00:09:12,480
whole list is encapsulated in C type Q

00:09:09,720 --> 00:09:15,480
and watts and that means that in C

00:09:12,480 --> 00:09:18,630
option parameters are all dynamically

00:09:15,480 --> 00:09:21,390
typed for convenience we throw in a

00:09:18,630 --> 00:09:25,380
feature to restrict values to integer

00:09:21,390 --> 00:09:27,990
bool this is about the stupidest model

00:09:25,380 --> 00:09:29,190
that could possibly work and have a lot

00:09:27,990 --> 00:09:33,750
of respect for that you should always

00:09:29,190 --> 00:09:37,709
try that first time for an example this

00:09:33,750 --> 00:09:41,040
is our friend - MSG again recall that

00:09:37,709 --> 00:09:45,350
msg has a single parameter and can be

00:09:41,040 --> 00:09:48,330
times that if timestamp equals on or off

00:09:45,350 --> 00:09:49,950
how do we do that in Kermit simple

00:09:48,330 --> 00:09:55,350
enough we declare a parameter named

00:09:49,950 --> 00:09:59,640
timestamp with the boolean type came up

00:09:55,350 --> 00:10:03,360
works just fine here note that this

00:09:59,640 --> 00:10:04,890
option argument definition is separate

00:10:03,360 --> 00:10:07,260
from the option definition we saw

00:10:04,890 --> 00:10:13,620
earlier there in two different files and

00:10:07,260 --> 00:10:16,980
connected only by C code next example -

00:10:13,620 --> 00:10:19,740
Numa there's numerous a mandatory

00:10:16,980 --> 00:10:23,130
parameter type and additional parameters

00:10:19,740 --> 00:10:25,200
depending on the value of type so with

00:10:23,130 --> 00:10:29,670
type equals no note there is an

00:10:25,200 --> 00:10:33,829
additional parameter node ID but qiyamat

00:10:29,670 --> 00:10:40,740
can't express that so the best we can do

00:10:33,829 --> 00:10:42,990
is we declare no parameters that leaves

00:10:40,740 --> 00:10:48,720
checking keys and values entirely to the

00:10:42,990 --> 00:10:50,850
code using humans it also means no

00:10:48,720 --> 00:10:52,470
introspection because chiamo the chronic

00:10:50,850 --> 00:10:54,209
command-line options will happily return

00:10:52,470 --> 00:10:57,680
there are no parameters we didn't

00:10:54,209 --> 00:10:57,680
declare any Nano

00:10:58,330 --> 00:11:05,440
how does the code look like well first

00:11:03,070 --> 00:11:07,960
here's a co2 past - new math option

00:11:05,440 --> 00:11:12,220
argument first we find the Declaration

00:11:07,960 --> 00:11:15,910
we just saw then we use it to pass the

00:11:12,220 --> 00:11:18,100
option argument and then we let

00:11:15,910 --> 00:11:20,980
variously get and checked all the

00:11:18,100 --> 00:11:26,770
parameters lots and lots of tedious

00:11:20,980 --> 00:11:30,160
string manipulation for example - block

00:11:26,770 --> 00:11:32,140
dev - block there is a command lines

00:11:30,160 --> 00:11:37,770
equivalent to Q and piece blocked ever

00:11:32,140 --> 00:11:37,770
had block dev adds argument is a tree

00:11:38,280 --> 00:11:46,930
but GM of this by design flat so what do

00:11:43,180 --> 00:11:48,880
we do we flatten the arguments tree with

00:11:46,930 --> 00:11:51,520
product keys thought of keys look like

00:11:48,880 --> 00:11:54,940
this on the command line and they work

00:11:51,520 --> 00:11:57,220
like this the basic idea is we specified

00:11:54,940 --> 00:12:00,610
the tree by listing its string value at

00:11:57,220 --> 00:12:04,930
least and as dotted key encodes a path

00:12:00,610 --> 00:12:07,330
to a leaf so file dot driver equals file

00:12:04,930 --> 00:12:09,430
means the root of the tree is an object

00:12:07,330 --> 00:12:12,190
which is a member of file which is an

00:12:09,430 --> 00:12:15,550
object which s has a member driver whose

00:12:12,190 --> 00:12:21,220
value as a string file this is clever

00:12:15,550 --> 00:12:23,680
but their issues first it is bolded on

00:12:21,220 --> 00:12:27,490
the PMO so again by by introspection

00:12:23,680 --> 00:12:29,620
hello extra code next it's inconsistent

00:12:27,490 --> 00:12:32,410
with other workarounds we have elsewhere

00:12:29,620 --> 00:12:36,820
and which we can't get rid of because we

00:12:32,410 --> 00:12:39,330
can get it backward compatibility and it

00:12:36,820 --> 00:12:42,340
can express most but not all trees

00:12:39,330 --> 00:12:45,600
consider the empty list there are no

00:12:42,340 --> 00:12:49,410
string valued leaves they're just more

00:12:45,600 --> 00:12:49,410
what are we running of time

00:12:51,140 --> 00:12:56,570
so our command line fails to meet a

00:12:53,329 --> 00:13:00,620
number of needs our configuration files

00:12:56,570 --> 00:13:02,060
are incomplete and inadequate the

00:13:00,620 --> 00:13:04,690
command lines expressive power is

00:13:02,060 --> 00:13:07,250
significantly weaker than QM piece

00:13:04,690 --> 00:13:09,230
driving a single see in the face because

00:13:07,250 --> 00:13:10,940
tedious glue code if he saw string

00:13:09,230 --> 00:13:14,060
manipulation and dollar keys and there's

00:13:10,940 --> 00:13:20,480
more an command line introspection is

00:13:14,060 --> 00:13:23,450
anemic compared to PM piece what shall

00:13:20,480 --> 00:13:27,740
we do about it now in fact we've done

00:13:23,450 --> 00:13:30,290
something about it already when I showed

00:13:27,740 --> 00:13:35,510
you the code to pass - numeral I this is

00:13:30,290 --> 00:13:39,649
the actual code Numa options is a copy

00:13:35,510 --> 00:13:40,279
type to represent - numerous option

00:13:39,649 --> 00:13:42,230
argument

00:13:40,279 --> 00:13:47,269
what is the copy type I'll explain in a

00:13:42,230 --> 00:13:51,760
minute we type the key remote and be map

00:13:47,269 --> 00:13:56,300
it to an uma options this mapping checks

00:13:51,760 --> 00:13:59,899
so all the string manipulation moves

00:13:56,300 --> 00:14:05,769
from option specific code into this

00:13:59,899 --> 00:14:09,110
generic mapping code and we then can use

00:14:05,769 --> 00:14:11,390
parameters just by dotting into the

00:14:09,110 --> 00:14:15,019
struct and there they have the

00:14:11,390 --> 00:14:20,000
appropriate T type so fewer string

00:14:15,019 --> 00:14:22,699
manipulation and also static typing okay

00:14:20,000 --> 00:14:26,000
but but what's a copy type guapi is the

00:14:22,699 --> 00:14:28,310
infrastructure behind qmp copy types are

00:14:26,000 --> 00:14:33,620
defined in a copy schema this is numr

00:14:28,310 --> 00:14:35,959
options or part of it and copy compiles

00:14:33,620 --> 00:14:39,500
these Numa and in these crappy types to

00:14:35,959 --> 00:14:43,610
C types plus code to Sierra's to and

00:14:39,500 --> 00:14:45,860
from json introspection and more this is

00:14:43,610 --> 00:14:47,269
Z type it generates for Numa options

00:14:45,860 --> 00:14:49,940
it's pretty pedestrian you might

00:14:47,269 --> 00:14:54,709
probably have written stuff like that

00:14:49,940 --> 00:14:58,160
yourselves many times coop e has a

00:14:54,709 --> 00:14:59,660
number of advantages over Q modes first

00:14:58,160 --> 00:15:00,780
of all it has a much more expressive

00:14:59,660 --> 00:15:04,860
type system

00:15:00,780 --> 00:15:06,930
there there are enumerations algebraic

00:15:04,860 --> 00:15:10,530
types semi-product types which can be

00:15:06,930 --> 00:15:13,980
arbitrarily nested this permits more

00:15:10,530 --> 00:15:16,740
precise introspection the generated C

00:15:13,980 --> 00:15:19,110
types are much nicer to use than pure

00:15:16,740 --> 00:15:21,300
moths and streams this is pretty obvious

00:15:19,110 --> 00:15:23,100
when you compare interfaces made for Q

00:15:21,300 --> 00:15:23,820
and P two interfaces made for the

00:15:23,100 --> 00:15:26,640
command line

00:15:23,820 --> 00:15:28,770
the former used in IC types the leather

00:15:26,640 --> 00:15:32,280
use here mops and strings and generate

00:15:28,770 --> 00:15:36,390
suck when both of them have to drive a

00:15:32,280 --> 00:15:45,060
single interface there has to be

00:15:36,390 --> 00:15:47,040
conversion and that sucks too so this

00:15:45,060 --> 00:15:49,530
mapping of kiyomatsu copy looks like

00:15:47,040 --> 00:15:53,930
progress so maybe came ups map to copy

00:15:49,530 --> 00:15:53,930
should take over not so fast

00:15:54,560 --> 00:16:01,350
options are then defined in three places

00:15:57,120 --> 00:16:04,740
which is starting to get ridiculous and

00:16:01,350 --> 00:16:06,060
more seriously the mapping code is built

00:16:04,740 --> 00:16:08,880
around the design assumption that

00:16:06,060 --> 00:16:13,290
everything is flat and that conflicts

00:16:08,880 --> 00:16:15,260
with dark piece and moreover it only

00:16:13,290 --> 00:16:19,950
adds to our compatibility headaches and

00:16:15,260 --> 00:16:22,530
this is all fixable but I feel strongly

00:16:19,950 --> 00:16:26,700
there's way too much stuff bolted on the

00:16:22,530 --> 00:16:31,230
clear modes workarounds hacks game ops

00:16:26,700 --> 00:16:33,180
was a fine design like them but our

00:16:31,230 --> 00:16:36,570
needs have since grown and we've

00:16:33,180 --> 00:16:38,940
outgrown fear mods and I feel it's time

00:16:36,570 --> 00:16:39,450
to scrap it and start over so that's my

00:16:38,940 --> 00:16:42,390
plan

00:16:39,450 --> 00:16:47,850
4p takes over let's see what I've got

00:16:42,390 --> 00:16:50,760
cooking this is how I propose to define

00:16:47,850 --> 00:16:55,500
a command-line option in the future in

00:16:50,760 --> 00:16:57,240
the in one place in the coop a schema if

00:16:55,500 --> 00:16:59,070
you're familiar with the copy schema

00:16:57,240 --> 00:17:02,010
this will look like exactly like a

00:16:59,070 --> 00:17:04,080
command-line like like a QP command

00:17:02,010 --> 00:17:05,940
definition to you which sort of makes

00:17:04,080 --> 00:17:08,190
sense because an option is similar to a

00:17:05,940 --> 00:17:10,380
command except it can't return anything

00:17:08,190 --> 00:17:10,730
and it runs only at a specific point in

00:17:10,380 --> 00:17:13,890
time

00:17:10,730 --> 00:17:16,370
there's an additional feature that's for

00:17:13,890 --> 00:17:16,370
the help text

00:17:19,010 --> 00:17:24,240
crappie then takes all these option

00:17:21,810 --> 00:17:28,230
definitions and compiles them into a

00:17:24,240 --> 00:17:30,090
single function two options parse the

00:17:28,230 --> 00:17:33,180
function takes an argument vector and

00:17:30,090 --> 00:17:35,400
returns an area of past options a past

00:17:33,180 --> 00:17:37,980
option is attacked Union the tag

00:17:35,400 --> 00:17:41,780
identifies the option and the Union

00:17:37,980 --> 00:17:44,340
member represents the options argument

00:17:41,780 --> 00:17:49,040
the code path - Newmar changes as

00:17:44,340 --> 00:17:53,040
follows the conversion from p.m. opts to

00:17:49,040 --> 00:17:54,450
new option goes out instead officially

00:17:53,040 --> 00:17:57,120
new merabh shion's out of the array

00:17:54,450 --> 00:17:58,310
returned by crappie path options -

00:17:57,120 --> 00:18:02,970
options paths

00:17:58,310 --> 00:18:06,570
that's a nice simplification I mentioned

00:18:02,970 --> 00:18:09,210
that the other Keys can't express all

00:18:06,570 --> 00:18:11,160
the JSON objects so I made crappie

00:18:09,210 --> 00:18:13,980
options pass support jason in addition

00:18:11,160 --> 00:18:16,410
to dotted t's the other keys are nicer

00:18:13,980 --> 00:18:18,510
for simple cases and they are needed of

00:18:16,410 --> 00:18:21,150
course for backward compatibility but

00:18:18,510 --> 00:18:26,760
Jason is more general and recommended

00:18:21,150 --> 00:18:28,620
for programmatic use so can this design

00:18:26,760 --> 00:18:32,310
meet our command line needs let's check

00:18:28,620 --> 00:18:34,290
on configuration files yes we can reach

00:18:32,310 --> 00:18:36,060
Jason from a configuration file just as

00:18:34,290 --> 00:18:39,570
easily as we can read it from a TMP

00:18:36,060 --> 00:18:41,880
select expressive power but it's the

00:18:39,570 --> 00:18:45,720
same as Q and P with jason arguments and

00:18:41,880 --> 00:18:48,630
it's pretty close with tortise driving a

00:18:45,720 --> 00:18:51,420
single in c interface yes because now

00:18:48,630 --> 00:18:54,060
the two are really command-line and QP

00:18:51,420 --> 00:18:56,210
are similar they both use the same

00:18:54,060 --> 00:18:59,070
crappy schema the same property types

00:18:56,210 --> 00:19:00,720
the common interface can also use these

00:18:59,070 --> 00:19:05,100
types so there's no really no need for

00:19:00,720 --> 00:19:07,410
conversions introspection yes we can

00:19:05,100 --> 00:19:11,460
introspect the command line just like we

00:19:07,410 --> 00:19:13,940
introspect EMP sy mechanisms backward

00:19:11,460 --> 00:19:13,940
compatibility

00:19:17,590 --> 00:19:24,020
puppy taking over avoids or addresses a

00:19:21,680 --> 00:19:26,780
whole number of issues we have but it

00:19:24,020 --> 00:19:31,610
can't avoid all backward compatibility

00:19:26,780 --> 00:19:35,060
issues we want to stay compatible to

00:19:31,610 --> 00:19:37,010
more than 20 at hoc process in the short

00:19:35,060 --> 00:19:38,690
term we can make the option argument a

00:19:37,010 --> 00:19:41,480
string in the crappy schema and pass

00:19:38,690 --> 00:19:43,070
that string to the existing parcel that

00:19:41,480 --> 00:19:45,200
of course defeats introspection but we

00:19:43,070 --> 00:19:47,750
are no worse off than before in the

00:19:45,200 --> 00:19:51,170
longer term we want a proper crappy

00:19:47,750 --> 00:19:54,590
schema and will then need a way to say

00:19:51,170 --> 00:19:58,060
in the copy schema ok use this we a path

00:19:54,590 --> 00:19:58,060
over there instead of the normal one

00:19:58,210 --> 00:20:02,960
we want to stay comparable to the

00:20:00,380 --> 00:20:04,690
existing boded on dotted keys I think we

00:20:02,960 --> 00:20:06,950
are good there

00:20:04,690 --> 00:20:08,840
we want to stay compatible to the

00:20:06,950 --> 00:20:11,510
existing bolded on conversions of copy

00:20:08,840 --> 00:20:13,580
and that means we get to replicate its

00:20:11,510 --> 00:20:16,790
extra features and corner cases such as

00:20:13,580 --> 00:20:19,880
automatic flattening special syntax for

00:20:16,790 --> 00:20:21,650
integer lists and so forth and of course

00:20:19,880 --> 00:20:23,480
we want to stay compatible to all the

00:20:21,650 --> 00:20:26,570
key emotes and eccentricities we've

00:20:23,480 --> 00:20:29,110
acquired over years and so we get two

00:20:26,570 --> 00:20:32,180
replicators to vary syntactic sugar

00:20:29,110 --> 00:20:34,820
trickery around repeated keys special

00:20:32,180 --> 00:20:39,050
semantics for keys key ID and it goes on

00:20:34,820 --> 00:20:41,660
and on at this point I think it's fair

00:20:39,050 --> 00:20:43,990
to ask must it be do we have to do all

00:20:41,660 --> 00:20:47,830
this work for backwards compatibility

00:20:43,990 --> 00:20:50,630
well backward compatibility is a choice

00:20:47,830 --> 00:20:53,150
we choose how much pain to inflict on

00:20:50,630 --> 00:20:56,660
ourselves to avoid inconveniencing our

00:20:53,150 --> 00:20:59,930
users up to what point are the

00:20:56,660 --> 00:21:01,790
opportunity costs Virata that's a

00:20:59,930 --> 00:21:07,070
question that we as a community need to

00:21:01,790 --> 00:21:10,100
decide where do we stand with this work

00:21:07,070 --> 00:21:12,980
I posted an RC patch and here are the

00:21:10,100 --> 00:21:15,500
highlights and some of its lowlights all

00:21:12,980 --> 00:21:17,600
options are qualified so they're all

00:21:15,500 --> 00:21:19,520
defined in the copy schema and they all

00:21:17,600 --> 00:21:22,940
mean to define command-line options I

00:21:19,520 --> 00:21:25,790
found most option arguments are not

00:21:22,940 --> 00:21:28,010
fully qualified yet and what we find

00:21:25,790 --> 00:21:28,820
then will be a lot of work including a

00:21:28,010 --> 00:21:31,669
lot of better

00:21:28,820 --> 00:21:33,380
what compatibility work intersection

00:21:31,669 --> 00:21:35,450
works it's currently meshed together

00:21:33,380 --> 00:21:38,059
with PMP introspection because that was

00:21:35,450 --> 00:21:41,870
easiest you may want to separate the two

00:21:38,059 --> 00:21:43,789
or maybe not we'll see configuration

00:21:41,870 --> 00:21:47,360
files are not yet implemented but they

00:21:43,789 --> 00:21:49,730
should be hard and finally at this stage

00:21:47,360 --> 00:21:53,720
the generate the generated documentation

00:21:49,730 --> 00:21:56,690
looks even more terrible than usual and

00:21:53,720 --> 00:22:05,470
that I would like to say thank you and

00:21:56,690 --> 00:22:05,470
are there any questions over there rich

00:22:09,160 --> 00:22:13,480
hi Marcus you you had an example with -

00:22:11,500 --> 00:22:16,870
block dev and block dev ad will those

00:22:13,480 --> 00:22:18,750
actually having identical copy schemas

00:22:16,870 --> 00:22:21,100
now yes

00:22:18,750 --> 00:22:23,520
they use the same floppy type as the

00:22:21,100 --> 00:22:23,520
argument

00:22:32,360 --> 00:22:37,580
can you hear me what about the

00:22:34,970 --> 00:22:39,860
configuration files read config and

00:22:37,580 --> 00:22:42,980
write coffee can you talk a bit about

00:22:39,860 --> 00:22:44,990
that plan for that I know you've

00:22:42,980 --> 00:22:49,580
discussed a bit on IRC and so probably

00:22:44,990 --> 00:22:52,190
so right now our configuration files use

00:22:49,580 --> 00:22:56,809
Windows any syntax which is fine for

00:22:52,190 --> 00:22:59,720
flat let's find four trees and we want

00:22:56,809 --> 00:23:03,700
trees so the obvious choice is to just

00:22:59,720 --> 00:23:13,760
read read jason and maybe maintain some

00:23:03,700 --> 00:23:15,649
compatibility for the old files you

00:23:13,760 --> 00:23:18,980
might want to consider tamil for the

00:23:15,649 --> 00:23:21,529
configuration files which is basically

00:23:18,980 --> 00:23:24,230
identical data model to jason but at the

00:23:21,529 --> 00:23:27,590
flat level looks like in any file well

00:23:24,230 --> 00:23:32,110
it's used a bunch in rusts cago stuff

00:23:27,590 --> 00:23:32,110
can you sent me a point oh sure thanks

00:23:33,639 --> 00:23:39,470
and I think this this sound to me like

00:23:37,250 --> 00:23:41,510
something that needs some testing may be

00:23:39,470 --> 00:23:42,049
it it's worth putting it back good off

00:23:41,510 --> 00:23:44,750
yes

00:23:42,049 --> 00:23:46,940
yeah putting a Google maybe a google

00:23:44,750 --> 00:23:48,529
Summer of Code project could be to write

00:23:46,940 --> 00:23:51,440
some kind of here's the introspection

00:23:48,529 --> 00:23:55,460
commit me one minute to go on a little

00:23:51,440 --> 00:23:57,169
rent of mine we care so much for

00:23:55,460 --> 00:23:59,750
backward compatibility that whenever

00:23:57,169 --> 00:24:02,059
somebody spots something in Petri review

00:23:59,750 --> 00:24:03,830
we bend over backwards to fix it but we

00:24:02,059 --> 00:24:04,940
don't quite care enough for it to

00:24:03,830 --> 00:24:09,110
actually test

00:24:04,940 --> 00:24:11,029
backward compatibility so my pet series

00:24:09,110 --> 00:24:13,490
comes with tests for the new

00:24:11,029 --> 00:24:15,350
infrastructure but that's infrastructure

00:24:13,490 --> 00:24:17,750
that's not sufficient we also need to

00:24:15,350 --> 00:24:20,380
test the end-to-end the options that

00:24:17,750 --> 00:24:20,380
they still work

00:24:28,660 --> 00:24:35,020
so how much effort do you think we will

00:24:32,090 --> 00:24:38,030
have to just find out how much

00:24:35,020 --> 00:24:40,820
compatibility we will break are we going

00:24:38,030 --> 00:24:44,150
to know what exactly it will break or it

00:24:40,820 --> 00:24:47,990
will be difficult to even find all the

00:24:44,150 --> 00:24:49,790
cases where compatibility will break we

00:24:47,990 --> 00:24:52,160
can make an educated guess now and

00:24:49,790 --> 00:24:54,200
you'll be wrong in some details so this

00:24:52,160 --> 00:24:56,900
is a good question but it's really

00:24:54,200 --> 00:24:59,559
really hard to answer that that would

00:24:56,900 --> 00:25:02,929
listen to my other question we used to

00:24:59,559 --> 00:25:05,780
it looks like it'd be lots of work to

00:25:02,929 --> 00:25:07,520
make some kind of tree not even inside

00:25:05,780 --> 00:25:10,100
camera maybe some rapper that could

00:25:07,520 --> 00:25:12,340
translate keep compatibility by just

00:25:10,100 --> 00:25:15,530
translate into the new options somehow

00:25:12,340 --> 00:25:18,650
but if you can't even find what are the

00:25:15,530 --> 00:25:22,309
options to break there's a number of

00:25:18,650 --> 00:25:25,580
ways to do this we could try to figure

00:25:22,309 --> 00:25:27,980
out how to do it incrementally that's

00:25:25,580 --> 00:25:30,140
easy when you can have the old and the

00:25:27,980 --> 00:25:32,240
new sit side by side but how can you

00:25:30,140 --> 00:25:34,670
have two minds like sit by side side by

00:25:32,240 --> 00:25:37,100
side it's difficult and then there's a

00:25:34,670 --> 00:25:40,240
lot a lot of magic in the old command

00:25:37,100 --> 00:25:41,890
line which I haven't even touched like

00:25:40,240 --> 00:25:45,760
order of things

00:25:41,890 --> 00:25:49,640
it isn't left-to-right it's magic and

00:25:45,760 --> 00:25:53,660
when it breaks we we juggle it until it

00:25:49,640 --> 00:25:58,220
works again more magic usually breaks

00:25:53,660 --> 00:26:01,340
something else then okay one more

00:25:58,220 --> 00:26:04,640
question did you do it - CPU on your

00:26:01,340 --> 00:26:07,309
series or just put a pointer on your own

00:26:04,640 --> 00:26:09,520
the custom parser I haven't thought of

00:26:07,309 --> 00:26:09,520
it yet

00:26:25,429 --> 00:26:31,559
you said in the patch series you posted

00:26:28,920 --> 00:26:33,660
you haven't actually converted all the

00:26:31,559 --> 00:26:39,000
option values you just left them as a

00:26:33,660 --> 00:26:41,640
plain string yes how does that work if

00:26:39,000 --> 00:26:43,799
you want to use if you if you want to

00:26:41,640 --> 00:26:45,299
use the the JSON syntax we'll specify in

00:26:43,799 --> 00:26:48,530
the argument you must have to have a

00:26:45,299 --> 00:26:52,260
schema define for that well both options

00:26:48,530 --> 00:26:55,049
the chosen thing doc doesn't work okay

00:26:52,260 --> 00:26:57,090
so it's not so until until you actually

00:26:55,049 --> 00:26:59,070
convert all of the OP tags you can't

00:26:57,090 --> 00:27:01,919
really use a JSON syntax you panting you

00:26:59,070 --> 00:27:03,510
hit only option by option like even

00:27:01,919 --> 00:27:06,840
before the theory's you could use it for

00:27:03,510 --> 00:27:09,809
this block there and with the theory if

00:27:06,840 --> 00:27:11,270
you can use it a bit more yeah I'm just

00:27:09,809 --> 00:27:13,830
thinking it's not it's not the case that

00:27:11,270 --> 00:27:15,059
your patch is merging and we live that

00:27:13,830 --> 00:27:17,280
could change over to using the JSON

00:27:15,059 --> 00:27:20,910
syntax whilst you do all that nasty

00:27:17,280 --> 00:27:24,090
hacks for the little bits this is a two

00:27:20,910 --> 00:27:26,510
weeks effort this pet series RFC yeah

00:27:24,090 --> 00:27:26,510
okay

00:27:34,570 --> 00:27:41,290
we do have a lot of deprecated staffing

00:27:37,750 --> 00:27:43,240
command line do I'm going to take them

00:27:41,290 --> 00:27:52,990
away use this occasion

00:27:43,240 --> 00:27:57,070
oh I hope to get away with it what about

00:27:52,990 --> 00:27:58,720
just I have someone write to take out

00:27:57,070 --> 00:28:01,450
the stuff and write a separate program

00:27:58,720 --> 00:28:03,250
that parses they all want and produces

00:28:01,450 --> 00:28:05,110
something that's compatible with the new

00:28:03,250 --> 00:28:07,810
stuff and then remove everything would

00:28:05,110 --> 00:28:09,580
be wonderful it's also a lot of wreckage

00:28:07,810 --> 00:28:17,080
yeah it is a lot of work anyway I think

00:28:09,580 --> 00:28:20,070
this so no more time sorry if you have

00:28:17,080 --> 00:28:26,240
more questions come to me thank you

00:28:20,070 --> 00:28:32,099
[Applause]

00:28:26,240 --> 00:28:32,099

YouTube URL: https://www.youtube.com/watch?v=gtpOLQgnwug


