Title: [2017] Nested Virtualization: Hyper-V on KVM by Ladi Prosek
Publication date: 2017-11-09
Playlist: KVM Forum 2017
Description: 
	Nested virtualization has been becoming increasingly important. As operating systems have started adopting virtualization-based security features, running a hypervisor as a guest of another hypervisor is no longer just a novelty with little use outside of test environments.

In this talk, Ladi Prosek will briefly describe the architecture of Microsoft Hyper-V as well as virtualization-based features introduced in Microsoft's latest server and desktop operating systems. He will review the work done in KVM so far to support running such systems as KVM/QEMU guests, describe general challenges accommodating non-KVM L1 hypervisors, and present future opportunities in this area.

---

Ladi Prosek
Red Hat, Inc.
Software Engineer

Ladi is a software engineer at Red Hat, working on virtualization and focusing primarily on KVM/QEMU Windows guest support. In his previous life he has developed closed source software in different parts of the stack.
He gave a talk about the current state of Windows guest support at DevConf.cz 2017.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:05,899 --> 00:00:15,450
my name is Larry I work for Red Hat as a

00:00:10,980 --> 00:00:19,260
software engineer and I focus on Windows

00:00:15,450 --> 00:00:23,400
guests and this talk is about nesting

00:00:19,260 --> 00:00:26,420
hyper-v on KVM which has been kind of a

00:00:23,400 --> 00:00:33,210
hobby project of mine for the last year

00:00:26,420 --> 00:00:35,700
or so and what I'm going to cover is the

00:00:33,210 --> 00:00:39,780
what the why and the how

00:00:35,700 --> 00:00:45,030
so very briefly because I'm sure most of

00:00:39,780 --> 00:00:50,090
you know what hyper-v is what nested

00:00:45,030 --> 00:00:54,860
virtualization is why we care

00:00:50,090 --> 00:00:59,100
specifically for hyper-v on KVM and

00:00:54,860 --> 00:01:00,480
lastly how it works and this is actually

00:00:59,100 --> 00:01:03,329
a spoiler because now you know that it

00:01:00,480 --> 00:01:10,939
works and there's going to be a demo at

00:01:03,329 --> 00:01:14,360
the end so hyper-v is a is Microsoft's

00:01:10,939 --> 00:01:17,580
hypervisor you can get it with Windows

00:01:14,360 --> 00:01:23,670
you also get it on Azure on Microsoft's

00:01:17,580 --> 00:01:28,080
public cloud the way the reason why I

00:01:23,670 --> 00:01:29,549
included this this screenshot is to kind

00:01:28,080 --> 00:01:33,150
of show you how you enable it and

00:01:29,549 --> 00:01:38,490
they'll get shortly to why I I'm showing

00:01:33,150 --> 00:01:43,740
you this so there's a there's this thing

00:01:38,490 --> 00:01:47,430
called server manager where you can add

00:01:43,740 --> 00:01:51,600
these roles to your Windows Server

00:01:47,430 --> 00:01:56,009
installation and there's things like DNS

00:01:51,600 --> 00:01:58,890
DHCP fax whatever services and one of

00:01:56,009 --> 00:02:02,490
them is hyper-v so you just check this

00:01:58,890 --> 00:02:06,990
checkbox you reboot and you have hyper-v

00:02:02,490 --> 00:02:08,580
you have a hypervisor it looks like

00:02:06,990 --> 00:02:11,190
you're just adding something through

00:02:08,580 --> 00:02:13,560
your operating system right it

00:02:11,190 --> 00:02:15,990
for those of you familiar with KVM which

00:02:13,560 --> 00:02:18,450
is probably most of you it looks like

00:02:15,990 --> 00:02:21,300
the equivalent of maybe loading the KBM

00:02:18,450 --> 00:02:27,420
module and the KVM Intel or KVM MD

00:02:21,300 --> 00:02:31,980
module however hyper-v is a is a true

00:02:27,420 --> 00:02:36,870
sorry it's really like a type 1

00:02:31,980 --> 00:02:39,530
hypervisor so what really happens is you

00:02:36,870 --> 00:02:42,960
get this whole new layer at the bottom

00:02:39,530 --> 00:02:48,360
sitting on the on top of hardware right

00:02:42,960 --> 00:02:52,190
so these things the hyper-v calls

00:02:48,360 --> 00:02:55,280
partitions you can think of them as VMs

00:02:52,190 --> 00:02:58,890
one of them will be the root partition

00:02:55,280 --> 00:03:03,050
the Windows that you interact with the

00:02:58,890 --> 00:03:07,020
the management OS so in this sense

00:03:03,050 --> 00:03:11,400
hyper-v is much much closer to Xen than

00:03:07,020 --> 00:03:17,100
to KVM and as a consequence just by

00:03:11,400 --> 00:03:21,870
enabling the hyper-v role you will get

00:03:17,100 --> 00:03:24,360
nested virtualization unlike Linux we're

00:03:21,870 --> 00:03:27,000
just loading the KVM module doesn't

00:03:24,360 --> 00:03:32,040
really start any VM right you have to do

00:03:27,000 --> 00:03:35,970
it explicitly so that covers hyper-v

00:03:32,040 --> 00:03:39,600
inest virtualization that was just talk

00:03:35,970 --> 00:03:41,790
before this one about measuring the

00:03:39,600 --> 00:03:45,239
performance of necen spiritualization

00:03:41,790 --> 00:03:48,060
I'm pretty sure most of you wouldn't

00:03:45,239 --> 00:03:51,810
find this picture surprising maybe

00:03:48,060 --> 00:03:57,120
except for this l-shaped piece which

00:03:51,810 --> 00:03:59,940
again comes back to the fact that once

00:03:57,120 --> 00:04:03,060
you enable hyper-v you also get Windows

00:03:59,940 --> 00:04:05,700
pretty much sitting at l2 at that point

00:04:03,060 --> 00:04:08,400
so even if you don't start any nested

00:04:05,700 --> 00:04:14,130
VMs explicitly you already have an l2

00:04:08,400 --> 00:04:16,650
which will be Windows itself and so this

00:04:14,130 --> 00:04:19,440
is the setup that we're interested in we

00:04:16,650 --> 00:04:23,130
have Linux with KBM as the l0 hypervisor

00:04:19,440 --> 00:04:24,330
hyper-v being the l1 guest and l1

00:04:23,130 --> 00:04:31,110
hypervisor

00:04:24,330 --> 00:04:31,639
and windows in Elgin so why you want to

00:04:31,110 --> 00:04:36,150
do this

00:04:31,639 --> 00:04:39,330
there's this there's this like I would

00:04:36,150 --> 00:04:41,879
say that the toy use of nested

00:04:39,330 --> 00:04:46,979
virtualization captured in the in the

00:04:41,879 --> 00:04:49,620
first bullet me having worked on

00:04:46,979 --> 00:04:53,460
virtualization for Android like two

00:04:49,620 --> 00:04:55,860
years now only I I feel kind of I'm not

00:04:53,460 --> 00:04:59,580
qualified to generalize and tell you

00:04:55,860 --> 00:05:01,469
what all the all the possible uses are

00:04:59,580 --> 00:05:04,949
but I'll give you examples like from

00:05:01,469 --> 00:05:08,490
from like my experience for this this

00:05:04,949 --> 00:05:14,009
use of nested birth one of them was was

00:05:08,490 --> 00:05:17,159
a person who wanted to demo a product

00:05:14,009 --> 00:05:20,430
called cloud forms whose purpose is to

00:05:17,159 --> 00:05:23,819
manage all kinds of hypervisors all

00:05:20,430 --> 00:05:26,509
kinds of clouds and whatnot and this

00:05:23,819 --> 00:05:29,460
person wanted to demo

00:05:26,509 --> 00:05:32,370
KVM based hypervisors as well as hyper-v

00:05:29,460 --> 00:05:36,289
on his laptop so he wanted to run

00:05:32,370 --> 00:05:40,139
hyper-v on his laptop cool right why not

00:05:36,289 --> 00:05:43,529
another one so this one would be kind of

00:05:40,139 --> 00:05:45,240
a training or demo for development

00:05:43,529 --> 00:05:50,789
I was recently I recently started

00:05:45,240 --> 00:05:54,029
looking at supporting v2v migration from

00:05:50,789 --> 00:05:57,599
hyper-v to KVM and again for this use

00:05:54,029 --> 00:06:00,210
case you it's kind of nice to have it

00:05:57,599 --> 00:06:02,430
all on one host you don't need

00:06:00,210 --> 00:06:07,889
additional hardware for for the hyper-v

00:06:02,430 --> 00:06:10,969
hosts and there's a new use case coming

00:06:07,889 --> 00:06:13,460
with Windows Server 2016 and Windows 10

00:06:10,969 --> 00:06:18,800
which is called virtualization based

00:06:13,460 --> 00:06:18,800
security so what this basically is is

00:06:19,129 --> 00:06:25,949
virtualization providing a sandbox

00:06:23,240 --> 00:06:29,279
sandboxing the operating system so that

00:06:25,949 --> 00:06:32,779
it's it doesn't it cannot hurt itself

00:06:29,279 --> 00:06:35,779
it's protected from itself and/or from

00:06:32,779 --> 00:06:35,779
malware

00:06:36,260 --> 00:06:42,920
it will be one more slide on this it

00:06:39,480 --> 00:06:49,440
seems to be getting good reviews from

00:06:42,920 --> 00:06:53,150
security researchers so far and so why

00:06:49,440 --> 00:06:55,910
hyper-v on KVM except for why not

00:06:53,150 --> 00:06:59,460
hyper-v on hyper-v already works and

00:06:55,910 --> 00:07:03,210
actually even like today on a sure you

00:06:59,460 --> 00:07:06,270
can get a VM which does support nested

00:07:03,210 --> 00:07:12,120
virtualization and we do expect demand

00:07:06,270 --> 00:07:20,730
for hyper-v on KVM as well and probably

00:07:12,120 --> 00:07:23,870
driven mostly by by VPS by security and

00:07:20,730 --> 00:07:26,790
so what is virtualization based security

00:07:23,870 --> 00:07:30,780
what Microsoft did was basically they

00:07:26,790 --> 00:07:35,270
defined these these what they call VTL

00:07:30,780 --> 00:07:42,540
virtual trust level something that's

00:07:35,270 --> 00:07:48,320
orthogonal to CPL to your rings and it's

00:07:42,540 --> 00:07:52,800
it's a way of isolating or sandboxing or

00:07:48,320 --> 00:07:54,660
removing permission permissions from the

00:07:52,800 --> 00:07:57,260
code running on the machine because the

00:07:54,660 --> 00:08:00,060
observation is that the kernel is huge

00:07:57,260 --> 00:08:03,870
on Windows you have third-party drivers

00:08:00,060 --> 00:08:07,230
of often of questionable quality and

00:08:03,870 --> 00:08:08,640
once you are in the kernel you can you

00:08:07,230 --> 00:08:10,740
basically own the machine right you can

00:08:08,640 --> 00:08:14,280
do whatever you want you can run

00:08:10,740 --> 00:08:21,660
arbitrary code you're basically doomed

00:08:14,280 --> 00:08:28,650
so with with VBS the root partition the

00:08:21,660 --> 00:08:34,560
management OS runs in this VT l0 where

00:08:28,650 --> 00:08:35,940
it doesn't have access to a few it

00:08:34,560 --> 00:08:39,180
doesn't have access to all memory

00:08:35,940 --> 00:08:40,800
basically to all physical memory and how

00:08:39,180 --> 00:08:44,640
it's implemented it's implemented using

00:08:40,800 --> 00:08:46,660
second level address translation so EPT

00:08:44,640 --> 00:08:51,580
on Intel in

00:08:46,660 --> 00:08:53,830
the on AMD they're still you still need

00:08:51,580 --> 00:08:56,890
to access this all the memory from

00:08:53,830 --> 00:08:59,320
somewhere and that's code running in VT

00:08:56,890 --> 00:09:03,240
l1 and it's it's a much smaller amount

00:08:59,320 --> 00:09:06,330
of code it's there's no third party code

00:09:03,240 --> 00:09:10,330
only Microsoft's code

00:09:06,330 --> 00:09:12,100
it's like much easier to audit and to to

00:09:10,330 --> 00:09:16,450
kind of provide some some security

00:09:12,100 --> 00:09:20,590
guarantees so they they market this

00:09:16,450 --> 00:09:21,340
under a bunch of different names there's

00:09:20,590 --> 00:09:24,690
a bunch of different names

00:09:21,340 --> 00:09:29,320
virtualization based security hypervisor

00:09:24,690 --> 00:09:32,860
code integrity I use I will use the

00:09:29,320 --> 00:09:36,940
terms device guard which is something

00:09:32,860 --> 00:09:44,020
that uses second level address

00:09:36,940 --> 00:09:47,580
translation to enforce this w exclusive

00:09:44,020 --> 00:09:50,740
or X which means that it never makes

00:09:47,580 --> 00:09:53,940
write a book page executable at the same

00:09:50,740 --> 00:09:59,920
time so pages are our executable or

00:09:53,940 --> 00:10:03,870
writable and the other marketing name

00:09:59,920 --> 00:10:07,180
they have is credential guard which

00:10:03,870 --> 00:10:11,760
completely hides pieces of physical

00:10:07,180 --> 00:10:16,060
memory by enforcing no are so memory

00:10:11,760 --> 00:10:20,770
cannot be read for code running in a

00:10:16,060 --> 00:10:23,710
VTOL zero and of course it's this is for

00:10:20,770 --> 00:10:28,420
memory read and write read and written

00:10:23,710 --> 00:10:32,350
by the by the CPU you can have memory

00:10:28,420 --> 00:10:35,170
can be accessed by by a DMA by like the

00:10:32,350 --> 00:10:38,200
PCI bus and so on so for this to be

00:10:35,170 --> 00:10:43,030
highly person bulletproof you also need

00:10:38,200 --> 00:10:45,160
a mm ooh and they also require you so

00:10:43,030 --> 00:10:48,310
iommu is still I think optional what

00:10:45,160 --> 00:10:50,380
they require you to use secure boot

00:10:48,310 --> 00:10:53,530
though because if you cannot guarantee

00:10:50,380 --> 00:10:57,310
that what you have bullied is secure and

00:10:53,530 --> 00:11:00,150
like authentic then all of this can be

00:10:57,310 --> 00:11:00,150
compromised right

00:11:01,650 --> 00:11:08,980
so I decided to try it once it was

00:11:06,190 --> 00:11:12,120
working and so I'll give you a few

00:11:08,980 --> 00:11:12,120
seconds to read this code

00:11:18,710 --> 00:11:26,840
the c3 is the opcode for the return

00:11:22,550 --> 00:11:30,080
instruction on x86 and I ran this code

00:11:26,840 --> 00:11:40,250
in the kernel on on Windows so what do

00:11:30,080 --> 00:11:44,510
you think happened so I have heard page

00:11:40,250 --> 00:11:46,340
fold yeah it's it was probably it was it

00:11:44,510 --> 00:11:52,070
was a it started as a page fold and

00:11:46,340 --> 00:11:53,960
probably escalated to be this right

00:11:52,070 --> 00:11:59,600
because you just try to execute your

00:11:53,960 --> 00:12:00,430
stack and that's not allowed for good

00:11:59,600 --> 00:12:04,610
reasons

00:12:00,430 --> 00:12:07,280
so it says attempted execute of no

00:12:04,610 --> 00:12:09,110
execute memory so this is without this

00:12:07,280 --> 00:12:13,040
is without device guard this is just

00:12:09,110 --> 00:12:19,490
your plain windows so what I did next

00:12:13,040 --> 00:12:21,140
I did something nasty and I wonder why

00:12:19,490 --> 00:12:25,820
it's not yellow supposed to be yellow so

00:12:21,140 --> 00:12:29,470
this this is the new statement and what

00:12:25,820 --> 00:12:33,380
this function does is it finds the Pte

00:12:29,470 --> 00:12:36,380
corresponding to to this address and it

00:12:33,380 --> 00:12:41,900
clears the XD bit XD meaning execute

00:12:36,380 --> 00:12:44,000
disable so i am a malware right and i I

00:12:41,900 --> 00:12:48,980
decided I really want to execute the

00:12:44,000 --> 00:12:53,810
stack so I manually clear the execute

00:12:48,980 --> 00:12:57,410
disabled bit so then on plain windows

00:12:53,810 --> 00:12:59,840
without device guard this worked it did

00:12:57,410 --> 00:13:02,060
nothing because it just it calls the

00:12:59,840 --> 00:13:05,630
return instruction returns nothing

00:13:02,060 --> 00:13:11,800
happened but once I did once I enabled

00:13:05,630 --> 00:13:13,640
device guard I got a blue screen again

00:13:11,800 --> 00:13:15,470
it's interesting because it's a

00:13:13,640 --> 00:13:19,610
different one it says system service

00:13:15,470 --> 00:13:21,050
exception just kind of indication that

00:13:19,610 --> 00:13:24,290
something else is happening under the

00:13:21,050 --> 00:13:27,110
covers and this is something else is

00:13:24,290 --> 00:13:31,369
that I really was able to clear the bit

00:13:27,110 --> 00:13:35,149
from the page tables but

00:13:31,369 --> 00:13:39,559
the execute access was blocked at the

00:13:35,149 --> 00:13:42,170
EPT level at the second level address

00:13:39,559 --> 00:13:44,209
translation level by the hypervisor and

00:13:42,170 --> 00:13:50,169
that's that's how the hyper is recorded

00:13:44,209 --> 00:13:50,169
and it triggered those screaming game

00:13:51,309 --> 00:13:59,839
okay so how does it work

00:13:55,089 --> 00:14:02,239
it's a nested virtualization so should

00:13:59,839 --> 00:14:07,759
be pretty much the same as KBM on KVM

00:14:02,239 --> 00:14:12,859
right in theory yes

00:14:07,759 --> 00:14:17,119
in practice the problem is that the

00:14:12,859 --> 00:14:19,699
virtualization extensions which in which

00:14:17,119 --> 00:14:23,540
when operating in nested mode are

00:14:19,699 --> 00:14:28,999
emulated by the l0 hypervisor it's like

00:14:23,540 --> 00:14:31,489
a hundreds of pages of of the CPU manual

00:14:28,999 --> 00:14:34,220
right so it's very easy to miss

00:14:31,489 --> 00:14:37,040
something and that's exactly what was

00:14:34,220 --> 00:14:42,169
happening in like most of the most of

00:14:37,040 --> 00:14:46,119
the problems that that I have found so -

00:14:42,169 --> 00:14:49,009
I have like a few categories of issues I

00:14:46,119 --> 00:14:53,169
I think I found only one hyper-v bug so

00:14:49,009 --> 00:14:58,360
far which has to do with the epic and

00:14:53,169 --> 00:15:01,279
using version of the local epic - and

00:14:58,360 --> 00:15:03,410
then based on the version of the local

00:15:01,279 --> 00:15:09,379
epic expecting a certain register in the

00:15:03,410 --> 00:15:13,399
i/o epoch which q mu k vm p mu happens

00:15:09,379 --> 00:15:15,289
to not implement so this is still I'm

00:15:13,399 --> 00:15:17,839
still tracking it as a hyper-v bug and

00:15:15,289 --> 00:15:21,529
trying to find a way how to report it to

00:15:17,839 --> 00:15:27,499
Microsoft but everything else we're bugs

00:15:21,529 --> 00:15:29,629
in k vm a few of these were missing

00:15:27,499 --> 00:15:34,220
features like something that was very

00:15:29,629 --> 00:15:36,649
easy to discover because I would just I

00:15:34,220 --> 00:15:39,529
would boot hyper-v and it would leave a

00:15:36,649 --> 00:15:43,790
message in the event log saying I cannot

00:15:39,529 --> 00:15:46,190
run on this host because you are not

00:15:43,790 --> 00:15:50,360
providing this and this functionality

00:15:46,190 --> 00:15:54,020
one of one of these was the table

00:15:50,360 --> 00:15:56,840
descriptor table exits which KVM doesn't

00:15:54,020 --> 00:15:59,750
use but hey Piper V does so the only

00:15:56,840 --> 00:16:03,170
thing that was that Paula did Thank You

00:15:59,750 --> 00:16:07,760
Paolo was to add like a minimal support

00:16:03,170 --> 00:16:12,700
that reflects these VM exits to the l1

00:16:07,760 --> 00:16:19,400
hypervisor and then there were many bugs

00:16:12,700 --> 00:16:26,450
most of them reproduced as the guests

00:16:19,400 --> 00:16:27,980
like hyper-v not booting hanging so very

00:16:26,450 --> 00:16:30,320
few of these were of the nature where

00:16:27,980 --> 00:16:31,900
you would just it would be easy to tell

00:16:30,320 --> 00:16:35,210
what was going on so there's a lot of

00:16:31,900 --> 00:16:38,750
detective work because windows is closed

00:16:35,210 --> 00:16:44,120
source so it's it's hard to debug a lot

00:16:38,750 --> 00:16:47,720
of reverse engineering and it's about 20

00:16:44,120 --> 00:16:54,040
k vm patches a little bit of emu work

00:16:47,720 --> 00:16:54,040
and recently there was an OB MF patch

00:16:55,180 --> 00:16:58,180
okay

00:17:05,930 --> 00:17:11,110
so this is Windows 10

00:17:09,630 --> 00:17:15,880
[Music]

00:17:11,110 --> 00:17:15,880
running with device guard enabled

00:17:16,510 --> 00:17:23,240
Microsoft provides this tool which you

00:17:20,570 --> 00:17:27,110
can use to enable device guard enable

00:17:23,240 --> 00:17:30,280
disable check if the if the machine is

00:17:27,110 --> 00:17:34,730
capable of running device guard and

00:17:30,280 --> 00:17:38,450
there's also a this - ready switch which

00:17:34,730 --> 00:17:41,090
tells you if device guard is enabled so

00:17:38,450 --> 00:17:47,710
this is going to be a proof that it is

00:17:41,090 --> 00:17:55,400
enabled once it once it finishes running

00:17:47,710 --> 00:17:58,000
also okay it's it's all green which

00:17:55,400 --> 00:18:02,900
means that it's enabled and is running

00:17:58,000 --> 00:18:07,480
another way to show you that is to run

00:18:02,900 --> 00:18:07,480
tool called msinfo32

00:18:14,480 --> 00:18:21,940
and there you go device guard

00:18:19,060 --> 00:18:24,440
virtualization based security is running

00:18:21,940 --> 00:18:29,050
we have secure boot we have a

00:18:24,440 --> 00:18:29,050
virtualization support and so on

00:18:31,630 --> 00:18:36,470
another proof if this wasn't enough is

00:18:35,600 --> 00:18:39,740
to run

00:18:36,470 --> 00:18:48,430
KVM stat this is the only VM running on

00:18:39,740 --> 00:18:54,070
this host and notice that we are getting

00:18:48,430 --> 00:18:58,580
nested VM exits and also notice that

00:18:54,070 --> 00:19:00,950
given that this is an idle guest the

00:18:58,580 --> 00:19:04,720
number of VM exits and nested VM exits

00:19:00,950 --> 00:19:04,720
is is pretty high

00:19:15,850 --> 00:19:23,220
so future work definitely performance

00:19:19,110 --> 00:19:28,090
some of the performance improvements

00:19:23,220 --> 00:19:31,480
that will be done for the general nested

00:19:28,090 --> 00:19:34,150
case will apply to hyper-v on KVM as

00:19:31,480 --> 00:19:37,030
well some of them may be hyper be

00:19:34,150 --> 00:19:39,930
specific because as of I think the

00:19:37,030 --> 00:19:42,760
version 5 of the hyper-v top level

00:19:39,930 --> 00:19:47,680
functional specification Microsoft

00:19:42,760 --> 00:19:52,470
started documenting some of nested

00:19:47,680 --> 00:19:56,040
specific privatization features I

00:19:52,470 --> 00:20:01,270
actually tried to implement at least the

00:19:56,040 --> 00:20:03,490
enlightened be MCS but I was hoping to

00:20:01,270 --> 00:20:06,940
have it ready by by the talk and to show

00:20:03,490 --> 00:20:10,170
you numbers but the it turns out that

00:20:06,940 --> 00:20:14,470
the spec shows you a few data structures

00:20:10,170 --> 00:20:20,400
of what the nested like hyper-v

00:20:14,470 --> 00:20:23,050
hypervisor expects but they then fail to

00:20:20,400 --> 00:20:24,900
fully specify some of the data types and

00:20:23,050 --> 00:20:29,760
those data structures and so there's

00:20:24,900 --> 00:20:29,760
there was some reverse engineering still

00:20:30,810 --> 00:20:35,190
so this is this is definitely for the

00:20:33,100 --> 00:20:38,530
for the future the enlightened VM CS is

00:20:35,190 --> 00:20:41,110
something like shadow BMC s but it's

00:20:38,530 --> 00:20:42,580
going to work on all CPUs doesn't

00:20:41,110 --> 00:20:45,100
require any hardware support and I think

00:20:42,580 --> 00:20:49,360
it's going to be should be even faster

00:20:45,100 --> 00:20:54,940
than then shadow BMC s because what they

00:20:49,360 --> 00:20:57,400
do is they they instead of having the

00:20:54,940 --> 00:21:01,390
nested hypervisor executed VM rate and

00:20:57,400 --> 00:21:04,270
VM write it just writes reads and writes

00:21:01,390 --> 00:21:09,940
from from its memory from the guest

00:21:04,270 --> 00:21:14,290
memory and what I want from you guys is

00:21:09,940 --> 00:21:19,270
please test hyper-v on k vm when you

00:21:14,290 --> 00:21:23,860
make changes that touch nested

00:21:19,270 --> 00:21:26,929
virtualization code in kb m you can get

00:21:23,860 --> 00:21:30,659
Windows Server 2016

00:21:26,929 --> 00:21:32,610
evaluation version four for free it can

00:21:30,659 --> 00:21:36,000
be downloaded works for a few months I

00:21:32,610 --> 00:21:39,779
think and when you run it just used your

00:21:36,000 --> 00:21:42,570
typical your usual hyper-v

00:21:39,779 --> 00:21:46,710
Enlightenment's plus of course

00:21:42,570 --> 00:21:49,440
vmx for on Intel and SVM on AMD so that

00:21:46,710 --> 00:21:54,600
you enable the virtualization extensions

00:21:49,440 --> 00:21:58,350
in the guest and if you run an older

00:21:54,600 --> 00:22:00,990
version of hyper-v like 2012 r2 it also

00:21:58,350 --> 00:22:03,899
you also need to specify - hypervisor

00:22:00,990 --> 00:22:06,629
because that version didn't officially

00:22:03,899 --> 00:22:09,570
support running nested so it will fail

00:22:06,629 --> 00:22:15,509
when you run it and it detects that it's

00:22:09,570 --> 00:22:18,120
being run in a virtual machine and just

00:22:15,509 --> 00:22:23,309
a few debugging tips in the beginning I

00:22:18,120 --> 00:22:26,970
used the gdb stub a lot the problem with

00:22:23,309 --> 00:22:32,840
the gdb stub and debugging windows is

00:22:26,970 --> 00:22:36,120
that Windows uses SLR in the kernel so

00:22:32,840 --> 00:22:37,710
addresses changed modules even the

00:22:36,120 --> 00:22:40,139
hypervisor is loaded to a different

00:22:37,710 --> 00:22:43,279
address every time you run you run the

00:22:40,139 --> 00:22:46,710
guest so what I did was I I just had a

00:22:43,279 --> 00:22:48,990
pattern that I and a script gdb script

00:22:46,710 --> 00:22:53,029
to search for a known pattern in the

00:22:48,990 --> 00:22:56,029
guest memory to find the hypervisor and

00:22:53,029 --> 00:22:58,309
then you know set breakpoints and so on

00:22:56,029 --> 00:23:03,029
what I discovered recently is that

00:22:58,309 --> 00:23:08,629
Windows actually supports debugging of

00:23:03,029 --> 00:23:11,669
the hypervisor over serial or 1394

00:23:08,629 --> 00:23:18,990
connection very similar to how you debug

00:23:11,669 --> 00:23:26,120
the root partition on Windows so in

00:23:18,990 --> 00:23:26,120
summary hyper-v on KDM works it is slow

00:23:28,100 --> 00:23:37,330
it is used under the covers by

00:23:34,330 --> 00:23:41,049
a couple of security features in the

00:23:37,330 --> 00:23:46,049
latest Windows versions and to keep in

00:23:41,049 --> 00:23:55,690
mind that just enabling the hyper-v role

00:23:46,049 --> 00:23:58,299
starts l2 automatically ok so my my

00:23:55,690 --> 00:24:00,760
email address I keep a blog which is

00:23:58,299 --> 00:24:05,769
kind of focused on Windows guests and it

00:24:00,760 --> 00:24:08,559
has a few as a few posts about this I

00:24:05,769 --> 00:24:12,720
don't think I have anything about device

00:24:08,559 --> 00:24:17,830
guard yet but I'll add it shortly and

00:24:12,720 --> 00:24:20,620
this is a pretty good presentation from

00:24:17,830 --> 00:24:21,970
Alex Yunus school two years ago if

00:24:20,620 --> 00:24:25,440
you're interested in learning more about

00:24:21,970 --> 00:24:29,500
how virtualization based security works

00:24:25,440 --> 00:24:31,840
and I would like to thank KVM maintainer

00:24:29,500 --> 00:24:34,389
for their help and for their patience

00:24:31,840 --> 00:24:40,049
with me and Red Hat

00:24:34,389 --> 00:24:45,120
qe team for finding a lot of bugs and

00:24:40,049 --> 00:24:45,120
now it's your turn to ask questions

00:24:49,570 --> 00:25:01,630
just a comment on KBM on hyper-v you had

00:24:57,430 --> 00:25:05,860
some you know kind of a maybe it work

00:25:01,630 --> 00:25:09,820
but actually we are working on that and

00:25:05,860 --> 00:25:13,650
then it learns well it runs well yes and

00:25:09,820 --> 00:25:17,620
then performance is also good and

00:25:13,650 --> 00:25:22,300
especially if you compare hyper-v on

00:25:17,620 --> 00:25:24,870
hyper V versus KBM on hi v-- hyper

00:25:22,300 --> 00:25:27,930
beyond hyper-v does better job

00:25:24,870 --> 00:25:32,620
especially for example random i/o

00:25:27,930 --> 00:25:37,000
ducking area so this is this is opposite

00:25:32,620 --> 00:25:41,820
but if we add indictment to k vm for

00:25:37,000 --> 00:25:47,290
example then kb m can actually run

00:25:41,820 --> 00:25:49,270
faster on hyper-v as a guest yeah

00:25:47,290 --> 00:25:53,560
definitely that's also I think

00:25:49,270 --> 00:25:56,040
interesting yeah there's something I

00:25:53,560 --> 00:25:59,280
also want to look look at so when I

00:25:56,040 --> 00:26:01,810
implement or at least research the the

00:25:59,280 --> 00:26:05,560
enlightened vm CS i would like to

00:26:01,810 --> 00:26:11,410
implement both the the the part that

00:26:05,560 --> 00:26:14,170
offers enlightened vm c s on on k vm

00:26:11,410 --> 00:26:19,030
which would enable hyper-v running on it

00:26:14,170 --> 00:26:21,940
and the other way also also out there

00:26:19,030 --> 00:26:25,480
adding more enlightenment especially

00:26:21,940 --> 00:26:29,560
memory management for example guests can

00:26:25,480 --> 00:26:33,070
tell this part of memories hot or warm

00:26:29,560 --> 00:26:37,950
or cold that kind of thing so that may

00:26:33,070 --> 00:26:37,950
be also interesting thank you

00:26:43,150 --> 00:26:48,350
when when you're doing the analysis of

00:26:46,550 --> 00:26:50,530
what you need for hyper-v one of the

00:26:48,350 --> 00:26:54,080
things you mentioned was immu

00:26:50,530 --> 00:26:57,590
how do they deal with RM r RS the

00:26:54,080 --> 00:27:00,320
exclusion ranges that are used for USB

00:26:57,590 --> 00:27:01,790
devices to emulate such do they actually

00:27:00,320 --> 00:27:05,990
say no you can't run in a hardware with

00:27:01,790 --> 00:27:08,720
this or do they allow it to work I only

00:27:05,990 --> 00:27:11,840
heard like I could hardly hear you but

00:27:08,720 --> 00:27:13,250
you are asking about iommu so I know

00:27:11,840 --> 00:27:15,950
very little about that

00:27:13,250 --> 00:27:17,450
so I this is very early stage you know

00:27:15,950 --> 00:27:20,420
what I showed you the demo I showed you

00:27:17,450 --> 00:27:23,540
is actually using a few patches in the

00:27:20,420 --> 00:27:25,430
kernel that are not in I don't believe

00:27:23,540 --> 00:27:28,340
they're in mainline yet

00:27:25,430 --> 00:27:30,770
plus one OBM effect so this is very like

00:27:28,340 --> 00:27:33,050
bleeding edge and so I just get to the

00:27:30,770 --> 00:27:35,840
point where it runs sorry I haven't had

00:27:33,050 --> 00:27:39,020
time to explore but I'm definitely going

00:27:35,840 --> 00:27:42,950
to explore more the additional

00:27:39,020 --> 00:27:46,340
requirements that that device guard has

00:27:42,950 --> 00:27:48,380
like iommu and a few more because the

00:27:46,340 --> 00:27:50,690
tool that I showed you that like was all

00:27:48,380 --> 00:27:54,830
green when you run it in the mode where

00:27:50,690 --> 00:27:58,460
you ask it is this machine table capable

00:27:54,830 --> 00:28:00,980
it lists a few things that we do not

00:27:58,460 --> 00:28:04,060
support now others TPM oh so like TPM is

00:28:00,980 --> 00:28:04,060
another example

00:28:15,800 --> 00:28:22,780
okay this is it then thank you

00:28:19,060 --> 00:28:29,059
[Applause]

00:28:22,780 --> 00:28:29,059

YouTube URL: https://www.youtube.com/watch?v=zQSkKgpj9jA


