Title: [2017] Instrumenting, Introspection, and Debugging with QEMU by Pavel Dovgalyuk
Publication date: 2017-11-23
Playlist: KVM Forum 2017
Description: 
	QEMU is a powerful multi-platform emulation tool, but it lacks debugging and instrumenting capabilities. QEMU includes only GDB server and some execution logging.
Guest code may be instrumented by inserting callbacks and helper instructions into the translated code. In this talk we'll cover the problems that occur when creating the QEMU-based instrumentation tools (instrumenting of the selected processes within VM, analysis with record/replay, intrusive and non-intrusive approaches), and review the existing approaches and insttumentation frameworks (PANDA, DECAF, PinOS, PEMU). We'll also present our efforts in creating instrumentation/introspection plugins for QEMU and adding new debugging stub - WinDbg server.

---

Pavel Dovgalyuk
ISPRAS
Software Developer
Novgorod, Russia

I am software developer in Institute for System Programming (ISP) of the Russian Academy of Sciences (RAS). The activities of the Institute include fundamental research, software development, applied research for the benefits of the Industry, and education.
For the last 7 years I have been working on the project which aim is adding deterministic replay, reverse debugging, instrumentation, instrospection, and analysis to qemu. Part of this work was already included into mainline QEMU.
I presented execution record/replay work on KVM Forum 2014.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:06,109 --> 00:00:13,920
so my talk is about instrumenting an

00:00:09,360 --> 00:00:23,180
introspection of the guest code in

00:00:13,920 --> 00:00:27,869
Crimea so our team started these

00:00:23,180 --> 00:00:32,160
projects when we had software analysis

00:00:27,869 --> 00:00:38,480
tasks from our customer we made

00:00:32,160 --> 00:00:43,920
deterministic and reverse debugging

00:00:38,480 --> 00:00:46,460
features for km you have slide about it

00:00:43,920 --> 00:00:51,920
later and now we are working on

00:00:46,460 --> 00:00:56,280
improving debugging and introspection

00:00:51,920 --> 00:00:58,710
capabilities in chromium so if you're

00:00:56,280 --> 00:01:00,809
working on creating new platforms or

00:00:58,710 --> 00:01:04,140
debugging like kernels or software

00:01:00,809 --> 00:01:10,409
inside the Cameo you may be interested

00:01:04,140 --> 00:01:15,780
in these approaches the simplest thing

00:01:10,409 --> 00:01:18,710
everybody I guess everybody tried is

00:01:15,780 --> 00:01:24,509
just log in the translation box that I

00:01:18,710 --> 00:01:30,290
executed in in the guest this sometimes

00:01:24,509 --> 00:01:34,890
this helps but the logs for the

00:01:30,290 --> 00:01:40,170
executions usually were big and you

00:01:34,890 --> 00:01:46,079
cannot find which processes are executed

00:01:40,170 --> 00:01:52,500
inside which memory cells are accessed

00:01:46,079 --> 00:01:54,869
and so on another side that was a

00:01:52,500 --> 00:02:02,479
previous slide about fully dynamic

00:01:54,869 --> 00:02:07,200
approach the other side as a think is

00:02:02,479 --> 00:02:10,770
fully static approach it about getting

00:02:07,200 --> 00:02:13,080
the dumps of virtual memory of virtual

00:02:10,770 --> 00:02:16,180
machines memory

00:02:13,080 --> 00:02:19,120
passing to some utilities for example

00:02:16,180 --> 00:02:22,390
relative volatility framework which has

00:02:19,120 --> 00:02:25,330
a bunch of plugins for analysis it can

00:02:22,390 --> 00:02:29,670
extract information about processes

00:02:25,330 --> 00:02:33,750
files memory regions loaded models

00:02:29,670 --> 00:02:37,480
open operating system handles and so on

00:02:33,750 --> 00:02:44,620
but this approach is static so you

00:02:37,480 --> 00:02:47,890
cannot look through the whole process of

00:02:44,620 --> 00:02:53,080
execution it too will be very favorite

00:02:47,890 --> 00:02:57,790
will create many dumps you also can use

00:02:53,080 --> 00:03:02,560
gdb there was a interface for remote

00:02:57,790 --> 00:03:06,070
debugging atmo but it has several

00:03:02,560 --> 00:03:10,000
drawbacks for example you can load the

00:03:06,070 --> 00:03:13,030
binary into gdb to match with the

00:03:10,000 --> 00:03:16,420
executed code but you can you should

00:03:13,030 --> 00:03:20,920
guess the address where this binary is

00:03:16,420 --> 00:03:24,480
located you also cannot figure out which

00:03:20,920 --> 00:03:34,769
the code relates to which project

00:03:24,480 --> 00:03:38,280
process you came you cannot send the

00:03:34,769 --> 00:03:44,190
asynchronous events like control

00:03:38,280 --> 00:03:48,330
register change or interrupt to the gdb

00:03:44,190 --> 00:03:51,790
single stepping in the debugger my

00:03:48,330 --> 00:03:53,950
effect the time in parameters of the

00:03:51,790 --> 00:04:00,940
execution may break into all connections

00:03:53,950 --> 00:04:04,810
this is this is partially solved with

00:04:00,940 --> 00:04:10,360
the deterministic execution which is

00:04:04,810 --> 00:04:14,260
based on account feature this feature is

00:04:10,360 --> 00:04:17,440
almost in cameo for some time for some

00:04:14,260 --> 00:04:20,770
moment of time it was it worked but now

00:04:17,440 --> 00:04:24,300
it is kind of broken but I hope we will

00:04:20,770 --> 00:04:24,300
fix it soon

00:04:25,090 --> 00:04:32,449
another drawback of gdb protocol is that

00:04:28,430 --> 00:04:37,250
it is exchanged with scheme with the

00:04:32,449 --> 00:04:44,780
kind of complex packets through the

00:04:37,250 --> 00:04:46,849
circuit or something like that so to use

00:04:44,780 --> 00:04:53,270
a conditional using conditional

00:04:46,849 --> 00:04:57,009
breakpoints becomes very slow leads the

00:04:53,270 --> 00:05:00,770
world so execution because every time

00:04:57,009 --> 00:05:04,039
gdb has to check the work on breakpoint

00:05:00,770 --> 00:05:10,280
conditions it has to stop

00:05:04,039 --> 00:05:13,430
eqm you get all registers get the memory

00:05:10,280 --> 00:05:20,060
vivid memory cells that required to

00:05:13,430 --> 00:05:24,229
calculate calculate the condition and

00:05:20,060 --> 00:05:26,990
then continue the execution

00:05:24,229 --> 00:05:31,729
I tried this feature in some inner loops

00:05:26,990 --> 00:05:34,610
and it it seems more like infinite

00:05:31,729 --> 00:05:39,289
waiting for successful breakpoint and

00:05:34,610 --> 00:05:41,680
not just for not looks just convenient

00:05:39,289 --> 00:05:41,680
debugging

00:05:42,830 --> 00:05:47,770
send you the expression Jesus stop

00:05:49,330 --> 00:06:00,080
yes we thought about it and did this is

00:05:54,639 --> 00:06:03,550
how the following approach presented on

00:06:00,080 --> 00:06:03,550
the following slide may be used

00:06:03,759 --> 00:06:11,199
so another thing it is interactive

00:06:09,169 --> 00:06:15,349
debugger - is wind Ibaka

00:06:11,199 --> 00:06:18,490
it gains some more information from the

00:06:15,349 --> 00:06:24,169
virtual machine when you use in Windows

00:06:18,490 --> 00:06:28,729
we created a stop similar to gdb stop

00:06:24,169 --> 00:06:31,849
it's named windy windy bug stop we

00:06:28,729 --> 00:06:38,139
posted recently posted second version to

00:06:31,849 --> 00:06:39,800
the creamy devil mailing list so if you

00:06:38,139 --> 00:06:49,460
want to try it

00:06:39,800 --> 00:06:52,039
you're welcome so in the case of in the

00:06:49,460 --> 00:06:55,819
back the communication with the queue is

00:06:52,039 --> 00:07:01,729
also is similar to gdb to also happens

00:06:55,819 --> 00:07:05,889
with packets that's why for our high

00:07:01,729 --> 00:07:09,349
intensive and high frequency events like

00:07:05,889 --> 00:07:13,520
instruction or memory accesses this

00:07:09,349 --> 00:07:20,300
approach is in a probable inapplicable

00:07:13,520 --> 00:07:26,090
and we that's why we looked at the

00:07:20,300 --> 00:07:30,430
native API like exported functions that

00:07:26,090 --> 00:07:35,770
can be used for instrumenting TCG that

00:07:30,430 --> 00:07:38,990
will be called for memory accesses

00:07:35,770 --> 00:07:43,849
amasau control register changes and

00:07:38,990 --> 00:07:47,060
something like that and this interface

00:07:43,849 --> 00:07:48,490
will be much faster than any packet

00:07:47,060 --> 00:07:51,569
based protocol and

00:07:48,490 --> 00:07:51,569
[Music]

00:07:52,960 --> 00:08:01,550
we tried this for our introspection

00:07:59,330 --> 00:08:05,930
tools for building the infrastructure

00:08:01,550 --> 00:08:12,919
tools and slow down for API tracing was

00:08:05,930 --> 00:08:15,710
about 10 - 10 to 12 persons it's not

00:08:12,919 --> 00:08:22,089
very big so there are many frameworks

00:08:15,710 --> 00:08:30,289
that used this approach the I will tell

00:08:22,089 --> 00:08:37,449
slightly about if four of them the first

00:08:30,289 --> 00:08:43,480
one is pyro box which is not very world

00:08:37,449 --> 00:08:48,350
it includes API for accesses to

00:08:43,480 --> 00:08:54,949
accessing the virtual machine state in

00:08:48,350 --> 00:08:58,160
to make the callbacks yeah and that it

00:08:54,949 --> 00:09:02,050
is it reduces volatility for extracting

00:08:58,160 --> 00:09:06,220
the information from the virtual machine

00:09:02,050 --> 00:09:12,699
another another alive project is panda

00:09:06,220 --> 00:09:16,810
it is similar to it has similar API and

00:09:12,699 --> 00:09:19,610
it also includes its own record replay

00:09:16,810 --> 00:09:26,319
implementation form but just for CPU and

00:09:19,610 --> 00:09:26,319
memory and it features taint analysis

00:09:28,779 --> 00:09:38,899
the next one is the curve it is based on

00:09:32,329 --> 00:09:40,910
old camera version I think it is what it

00:09:38,899 --> 00:09:43,160
means that it was created long time ago

00:09:40,910 --> 00:09:47,630
but I think it is still alive and used

00:09:43,160 --> 00:09:51,040
some for some people and it also

00:09:47,630 --> 00:09:58,940
implements it has taint analysis feature

00:09:51,040 --> 00:10:04,830
for there for this whole system another

00:09:58,940 --> 00:10:07,680
implementation doesn't have the

00:10:04,830 --> 00:10:11,040
drawbacks of the old Piero's there may

00:10:07,680 --> 00:10:14,420
this is federal road back sounds like

00:10:11,040 --> 00:10:18,420
not invented here it is our an approach

00:10:14,420 --> 00:10:23,220
it is similar to its API similar to all

00:10:18,420 --> 00:10:28,470
previous but it targeted to our analysis

00:10:23,220 --> 00:10:34,130
tasks and it's all the things are built

00:10:28,470 --> 00:10:37,040
upon this API are different so the

00:10:34,130 --> 00:10:41,640
looking at all of this

00:10:37,040 --> 00:10:45,960
we found that main requirements for such

00:10:41,640 --> 00:10:50,040
an API may be the following they may put

00:10:45,960 --> 00:10:52,350
in this API must pass translation events

00:10:50,040 --> 00:10:56,310
memory operation execution exception

00:10:52,350 --> 00:10:59,580
events to the external external or

00:10:56,310 --> 00:11:05,970
internal model which can react on them

00:10:59,580 --> 00:11:15,470
and insert some instrumentation code

00:11:05,970 --> 00:11:17,940
into them executed host code instruction

00:11:15,470 --> 00:11:21,330
instrumentation is straightforward we

00:11:17,940 --> 00:11:25,440
just react on the specific operation

00:11:21,330 --> 00:11:27,840
codes or specific addresses maybe we

00:11:25,440 --> 00:11:35,850
filled that with for their specific

00:11:27,840 --> 00:11:44,670
processes by comparing the page page

00:11:35,850 --> 00:11:48,300
table address and while this instruction

00:11:44,670 --> 00:11:52,920
is translated we may accompany it with

00:11:48,300 --> 00:11:59,040
them some callbacks that look like

00:11:52,920 --> 00:12:04,620
helpers in in the target part of

00:11:59,040 --> 00:12:09,120
translator this is a simple example well

00:12:04,620 --> 00:12:13,209
of system called in all the Linux

00:12:09,120 --> 00:12:22,009
kernels the system call is performed

00:12:13,209 --> 00:12:25,759
by interrupts eighty we intercept this

00:12:22,009 --> 00:12:28,129
opcode and insert our callback into the

00:12:25,759 --> 00:12:33,350
translation book before them making the

00:12:28,129 --> 00:12:39,970
interrupt that's how we can trace all

00:12:33,350 --> 00:12:41,930
system calls therefore we will need

00:12:39,970 --> 00:12:44,990
intercession come back we will need a

00:12:41,930 --> 00:12:49,610
CPU of course we will need the PC

00:12:44,990 --> 00:12:54,350
because to know which instruction to

00:12:49,610 --> 00:13:00,649
test and the translation context to

00:12:54,350 --> 00:13:03,259
insert to call back to it

00:13:00,649 --> 00:13:08,050
instrumentation functions like variable

00:13:03,259 --> 00:13:13,209
allocation and code generation some

00:13:08,050 --> 00:13:18,769
frameworks tried to instrument TCG

00:13:13,209 --> 00:13:21,620
representation but it is it looks simple

00:13:18,769 --> 00:13:27,350
but it is tricky about because of helper

00:13:21,620 --> 00:13:29,290
functions that unknown because the

00:13:27,350 --> 00:13:37,360
semantics is unknown to the

00:13:29,290 --> 00:13:41,540
instrumentation tool in addition to

00:13:37,360 --> 00:13:45,500
instrument in the instructions we also

00:13:41,540 --> 00:13:48,319
instrument memory accesses we insert we

00:13:45,500 --> 00:13:52,939
inserted the callbacks into there help

00:13:48,319 --> 00:13:57,370
us that into the helpers that perform

00:13:52,939 --> 00:14:00,290
the slow path of memory accesses and we

00:13:57,370 --> 00:14:04,100
insert embed the callbacks into the

00:14:00,290 --> 00:14:10,370
translation box into the first path of

00:14:04,100 --> 00:14:18,980
telomeric says of course this login may

00:14:10,370 --> 00:14:21,199
be used without any complex analysis for

00:14:18,980 --> 00:14:22,790
example for passing into the cache

00:14:21,199 --> 00:14:27,950
similar

00:14:22,790 --> 00:14:32,590
and we also used it for login this is

00:14:27,950 --> 00:14:39,340
the full log including the in Assam and

00:14:32,590 --> 00:14:43,430
exact and our memory logon function

00:14:39,340 --> 00:14:48,260
sometimes this helps in simple debugging

00:14:43,430 --> 00:14:51,430
tasks however they generate in their

00:14:48,260 --> 00:14:54,470
code in search and they help us may

00:14:51,430 --> 00:14:59,390
cause some problems because they buffer

00:14:54,470 --> 00:15:04,300
for generated code is limited duration

00:14:59,390 --> 00:15:06,620
stops on that line maxi's line when the

00:15:04,300 --> 00:15:10,030
instruction translated instruction

00:15:06,620 --> 00:15:14,210
passes this boundary however we can

00:15:10,030 --> 00:15:18,410
however nobody knows how big is the

00:15:14,210 --> 00:15:26,240
maximum instruction will be if we will

00:15:18,410 --> 00:15:34,100
insert many callbacks we can also offer

00:15:26,240 --> 00:15:37,250
for this tail there is a optimistic

00:15:34,100 --> 00:15:41,090
comment in the quad it describes this

00:15:37,250 --> 00:15:43,670
situation we didn't figure out the

00:15:41,090 --> 00:15:48,910
solution we just inserted the assert

00:15:43,670 --> 00:15:52,580
into the code generation code generator

00:15:48,910 --> 00:15:56,020
of course we also track the

00:15:52,580 --> 00:16:00,670
interruptions exception for example for

00:15:56,020 --> 00:16:03,650
detecting the page map in mapping this

00:16:00,670 --> 00:16:09,890
happens for example when dynamic library

00:16:03,650 --> 00:16:12,440
is loaded and when we detect you know we

00:16:09,890 --> 00:16:15,860
implemented API tracer which detects

00:16:12,440 --> 00:16:18,410
load in the libraries passes the

00:16:15,860 --> 00:16:21,890
structure and finds the addresses of the

00:16:18,410 --> 00:16:26,000
functions there is a couple of

00:16:21,890 --> 00:16:30,170
applications of not only our approach

00:16:26,000 --> 00:16:34,310
but of these approaches based on native

00:16:30,170 --> 00:16:38,820
API so we have

00:16:34,310 --> 00:16:41,880
at this moment many implementations of

00:16:38,820 --> 00:16:45,000
such instrumental frameworks so why

00:16:41,880 --> 00:16:47,460
don't we should add such an API into the

00:16:45,000 --> 00:16:49,350
mainline it could be very simple a

00:16:47,460 --> 00:16:52,650
couple of dozens of functions and

00:16:49,350 --> 00:16:56,010
callbacks and eme will be able to load

00:16:52,650 --> 00:17:03,180
and interact with their dynamic plugins

00:16:56,010 --> 00:17:13,500
or models or maybe static models and

00:17:03,180 --> 00:17:16,980
this will make them dynamic translated

00:17:13,500 --> 00:17:20,190
much more popular for them solving this

00:17:16,980 --> 00:17:23,990
analysis and debugging tasks thank you

00:17:20,190 --> 00:17:23,990
I'm ready to answer the questions

00:17:31,040 --> 00:17:36,780
you have been speaking about reverse

00:17:33,780 --> 00:17:39,000
debugging and it's like that if you

00:17:36,780 --> 00:17:41,220
consider also comparison with Kiera

00:17:39,000 --> 00:17:43,410
you know Kiera it also uses qmo to

00:17:41,220 --> 00:17:47,430
record and show in a graphical and nice

00:17:43,410 --> 00:17:53,310
way I briefly looked at Kiva but I don't

00:17:47,430 --> 00:18:01,920
remember its key idea so I can't answer

00:17:53,310 --> 00:18:03,330
now thank you Oh yep so yeah I think we

00:18:01,920 --> 00:18:07,410
definitely do want an instrumentation

00:18:03,330 --> 00:18:08,760
API main line I think that's kind of if

00:18:07,410 --> 00:18:10,650
you look at well why do people use

00:18:08,760 --> 00:18:11,820
Chrome you I think that one of the

00:18:10,650 --> 00:18:13,050
reasons why you'd want to use it rather

00:18:11,820 --> 00:18:15,390
than using hardware is because you can

00:18:13,050 --> 00:18:16,650
in theory get better idea and visibility

00:18:15,390 --> 00:18:19,170
what your guest is doing so

00:18:16,650 --> 00:18:21,750
instrumentation is great I think the

00:18:19,170 --> 00:18:24,180
difficulty here is that as soon as we

00:18:21,750 --> 00:18:26,160
add an API it's really an ABI and we

00:18:24,180 --> 00:18:27,330
need stability and we want something

00:18:26,160 --> 00:18:29,250
that we can guarantee is going to

00:18:27,330 --> 00:18:31,590
continue to work and that works across

00:18:29,250 --> 00:18:33,480
all of our CPUs and so on and so forth

00:18:31,590 --> 00:18:36,810
and that's the hard bit right it's

00:18:33,480 --> 00:18:39,930
taking something from a research project

00:18:36,810 --> 00:18:43,230
into a production engineering context

00:18:39,930 --> 00:18:44,610
and that's always hard right but mostly

00:18:43,230 --> 00:18:48,470
I think that yeah this is a great idea

00:18:44,610 --> 00:18:51,780
the thing I have a real issue with is

00:18:48,470 --> 00:18:54,150
having an API that says we're going to

00:18:51,780 --> 00:18:57,120
allow your plug-in to generate TCG code

00:18:54,150 --> 00:18:58,800
and in general the idea of having a

00:18:57,120 --> 00:19:01,320
callback that happens at translate time

00:18:58,800 --> 00:19:04,530
rather than the execute time because I

00:19:01,320 --> 00:19:06,540
think that comes down to the if all your

00:19:04,530 --> 00:19:09,330
callback events are for things which in

00:19:06,540 --> 00:19:11,610
the guest are architectural events like

00:19:09,330 --> 00:19:13,740
I loaded something I excuse an

00:19:11,610 --> 00:19:17,220
instruction those are going to stay the

00:19:13,740 --> 00:19:18,270
same across newer versions acquire me

00:19:17,220 --> 00:19:20,760
because they're our prop they're a

00:19:18,270 --> 00:19:24,570
property of the guest architecture think

00:19:20,760 --> 00:19:26,390
callback hooks like we just translated a

00:19:24,570 --> 00:19:28,320
new basic block and certainly

00:19:26,390 --> 00:19:32,130
opportunities for the plug-in to say

00:19:28,320 --> 00:19:34,770
generate TCG code that can change as we

00:19:32,130 --> 00:19:37,220
change the implementation internals

00:19:34,770 --> 00:19:40,510
equipment that I would prefer not to see

00:19:37,220 --> 00:19:44,500
certainly in a version one API right

00:19:40,510 --> 00:19:44,500
so I'm sorry that wasn't a question

00:19:54,470 --> 00:19:59,760
I was wondering as you mentioned that

00:19:57,810 --> 00:20:02,010
the packet protocol of gdb is pretty

00:19:59,760 --> 00:20:03,810
slow if you were considering using the

00:20:02,010 --> 00:20:05,280
conditional breakpoints where the

00:20:03,810 --> 00:20:07,170
conditions are implemented on the stop

00:20:05,280 --> 00:20:09,000
side and not on the gdb front and side

00:20:07,170 --> 00:20:10,350
this is missing right now so there

00:20:09,000 --> 00:20:12,510
support a call for this but no one

00:20:10,350 --> 00:20:15,270
implement of course is topside yet maybe

00:20:12,510 --> 00:20:19,800
maybe protocol supports this but qmu

00:20:15,270 --> 00:20:25,740
does not place take take the conditions

00:20:19,800 --> 00:20:26,940
right yeah this would happen of course

00:20:25,740 --> 00:20:29,220
there are other differences regarding

00:20:26,940 --> 00:20:32,570
gdb in x86 but for the other objectives

00:20:29,220 --> 00:20:32,570
there's something as well

00:20:34,250 --> 00:20:40,990
I think they'll be right up fix for this

00:20:36,470 --> 00:20:40,990
kind of orthogonal to this stuff

00:20:42,890 --> 00:20:51,159
I just wondered what is the degradation

00:20:47,320 --> 00:20:55,580
performance of instrumented clearly

00:20:51,159 --> 00:21:01,309
simple instrumentation makes a couple of

00:20:55,580 --> 00:21:07,460
percent degradation some of login some

00:21:01,309 --> 00:21:11,059
of logging like API login slow down make

00:21:07,460 --> 00:21:14,140
slow down about 10 percent to enter 20

00:21:11,059 --> 00:21:14,140
something like that

00:21:21,480 --> 00:21:27,170
thank you

00:21:23,990 --> 00:21:33,339
[Applause]

00:21:27,170 --> 00:21:33,339

YouTube URL: https://www.youtube.com/watch?v=3g1KzfBl1kI


