Title: [2017] Linux-User Support in QEMU by Riku Voipio
Publication date: 2017-11-23
Playlist: KVM Forum 2017
Description: 
	The roots of KVM are in Qemu, which was originally written as an emulator for running X86 Linux binaries on foreign architectures. Today linux-user emulation has become a sidenote in Qemu development, which tends to focus on Virtualization features. In this presentation Riku will review the current state of user-mode emulation and what use cases it still has. Riku will show how user-mode contributions can be tested and validated. Finally there will be a look forward, on how linux-user code can be improved, and discussion on it's place in greater Qemu/KVM ecosystem.

---

Riku Voipio
Linaro
Developer
Kirkkonummi, Suomi

I work at Linaro as Developer focusing on Build and Integration tools. I have worked 20 years as Debian developer, focusing mostly on supporting ARM and ARM64 ports. I'm passionate about upstream support, and thus have contributed ARM64 support to many open source projects, I am maintainer for Linux-user part of Qemu project.
Captions: 
	00:00:06,230 --> 00:00:12,150
my name is Rico Boyer and I work at

00:00:10,139 --> 00:00:15,750
Leonardo in the so called builds and

00:00:12,150 --> 00:00:24,990
basslines team and I'm also the qmo

00:00:15,750 --> 00:00:27,990
Linux user maintainer there are three

00:00:24,990 --> 00:00:30,660
different ways you can use qmo I think

00:00:27,990 --> 00:00:34,200
almost everyone here uses the first way

00:00:30,660 --> 00:00:36,989
of qmo as a virtual machine you

00:00:34,200 --> 00:00:39,210
accelerate with KVM you run virtual

00:00:36,989 --> 00:00:43,110
machines that may emulate real machines

00:00:39,210 --> 00:00:46,020
in characteristics but may also be quite

00:00:43,110 --> 00:00:50,270
virtual so that they have built io and B

00:00:46,020 --> 00:00:53,219
hosts and so on the second mode is

00:00:50,270 --> 00:00:55,770
similar we are still using machines to

00:00:53,219 --> 00:00:57,960
emulate but we might be a different

00:00:55,770 --> 00:01:00,660
architecture or if we don't have

00:00:57,960 --> 00:01:04,189
hardware virtualization support it can

00:01:00,660 --> 00:01:07,710
be the same architecture qmo has the

00:01:04,189 --> 00:01:09,060
tiny code generator which allows you to

00:01:07,710 --> 00:01:12,479
use and completely different

00:01:09,060 --> 00:01:15,119
architectures binaries or virtual

00:01:12,479 --> 00:01:19,080
machines or real machines that are being

00:01:15,119 --> 00:01:20,880
put into some kind of disk image and now

00:01:19,080 --> 00:01:23,549
for something completely different

00:01:20,880 --> 00:01:28,140
there's the Linux user mode which this

00:01:23,549 --> 00:01:30,509
talk is about we execute binaries Linux

00:01:28,140 --> 00:01:34,200
binaries and we are emulating the Linux

00:01:30,509 --> 00:01:37,009
kernel so that first two modes emulate

00:01:34,200 --> 00:01:41,579
systems they try to emulate Hardware

00:01:37,009 --> 00:01:42,150
while the last mode is just the kernel

00:01:41,579 --> 00:01:46,229
emulator

00:01:42,150 --> 00:01:49,170
there's also a BSD user mode which is

00:01:46,229 --> 00:01:54,030
less commonly used and doesn't currently

00:01:49,170 --> 00:01:57,869
have a maintainer how did we end up

00:01:54,030 --> 00:02:01,259
there well originally we started with

00:01:57,869 --> 00:02:06,149
just being Linux user the first version

00:02:01,259 --> 00:02:10,370
of qmo was to run x86 binaries on

00:02:06,149 --> 00:02:13,980
PowerPC and the goal was to run Windows

00:02:10,370 --> 00:02:15,239
applications eventually it may even be

00:02:13,980 --> 00:02:21,360
of all these days now that we have

00:02:15,239 --> 00:02:25,019
rather thread that support in qmo so

00:02:21,360 --> 00:02:31,170
this was almost 15 years ago how did we

00:02:25,019 --> 00:02:34,250
evolve from there so in about 2005 when

00:02:31,170 --> 00:02:39,260
I started using Linux user qmo we were

00:02:34,250 --> 00:02:42,840
getting a problem of cross compilation

00:02:39,260 --> 00:02:45,120
at Nokia we wanted to cross compile

00:02:42,840 --> 00:02:48,120
applications for various phones as

00:02:45,120 --> 00:02:55,980
easily as possible and that qmo was

00:02:48,120 --> 00:02:57,239
found so 0.7 qmo almost usable people

00:02:55,980 --> 00:02:59,220
were always talking that this is a

00:02:57,239 --> 00:03:03,900
temporary solution and we'll move to

00:02:59,220 --> 00:03:07,980
something else quite soon around 2009

00:03:03,900 --> 00:03:10,769
the TM gained that time code generator

00:03:07,980 --> 00:03:15,239
and it was no longer as big hack as

00:03:10,769 --> 00:03:18,209
before but on the other hand people

00:03:15,239 --> 00:03:20,310
started using KVM and the Linux user

00:03:18,209 --> 00:03:24,480
part of qiyama became a kind of a

00:03:20,310 --> 00:03:26,669
sidetrack that most people don't deal

00:03:24,480 --> 00:03:32,430
with daily and that qumu development

00:03:26,669 --> 00:03:35,310
doesn't really look a lot into so I

00:03:32,430 --> 00:03:37,260
jointly narrow and eventually Peter

00:03:35,310 --> 00:03:41,790
convinced me to become the maintainer of

00:03:37,260 --> 00:03:43,919
Q Emily Knox user and things were quite

00:03:41,790 --> 00:03:46,380
quiet there were things like people were

00:03:43,919 --> 00:03:48,810
saying that geumja Linux user will go

00:03:46,380 --> 00:03:53,220
away or you shouldn't use it because we

00:03:48,810 --> 00:03:56,629
don't have threads and that changed

00:03:53,220 --> 00:03:59,310
eventually so first there was a big

00:03:56,629 --> 00:04:01,970
revitalization of interest in qmo Linux

00:03:59,310 --> 00:04:04,560
user when we got the arm 64 architecture

00:04:01,970 --> 00:04:07,889
there was no hardware available for

00:04:04,560 --> 00:04:12,359
anyone and the emulator provided an easy

00:04:07,889 --> 00:04:15,599
access for application developers and

00:04:12,359 --> 00:04:18,000
finally last year well the excuse of

00:04:15,599 --> 00:04:20,880
don't use Linux user qmo it doesn't

00:04:18,000 --> 00:04:24,260
support threads went away when we got

00:04:20,880 --> 00:04:28,280
finally a contribution of proper

00:04:24,260 --> 00:04:28,280
threading support in qmo

00:04:29,630 --> 00:04:36,090
so why do people use a Linux user qmo as

00:04:33,140 --> 00:04:38,430
I mentioned earlier augmenting and

00:04:36,090 --> 00:04:41,550
helping cross-compilation has been a big

00:04:38,430 --> 00:04:43,590
motivator for a very long time it is

00:04:41,550 --> 00:04:46,710
often possible to cross-compiled

00:04:43,590 --> 00:04:49,170
applications without qmo and people who

00:04:46,710 --> 00:04:53,120
do yoga and openembedded will tell you

00:04:49,170 --> 00:04:56,220
that p.m. is completely unnecessary

00:04:53,120 --> 00:04:58,530
there are or you're saying something

00:04:56,220 --> 00:05:05,820
yeah actually this is because most of

00:04:58,530 --> 00:05:08,010
them configures yes so when you do a

00:05:05,820 --> 00:05:10,160
nave cross-compilation you have to run

00:05:08,010 --> 00:05:12,930
configure and somehow manage to either

00:05:10,160 --> 00:05:16,260
have the values in a kind of cache or

00:05:12,930 --> 00:05:19,740
then you can run qm1 generate them for

00:05:16,260 --> 00:05:21,570
yourself but perhaps a more interesting

00:05:19,740 --> 00:05:24,420
use case is bootstrapping new

00:05:21,570 --> 00:05:26,820
architectures as always when someone

00:05:24,420 --> 00:05:28,350
starts a new architecture there's an

00:05:26,820 --> 00:05:30,720
issue of the hardware not being

00:05:28,350 --> 00:05:33,660
available and even if the hardware is

00:05:30,720 --> 00:05:37,820
available it's often slow and prototype

00:05:33,660 --> 00:05:40,920
beyond buggy so doing it on a

00:05:37,820 --> 00:05:44,460
workstation which is fast and having an

00:05:40,920 --> 00:05:47,490
emulator lets you usually get along a

00:05:44,460 --> 00:05:51,150
lot more faster on the other hand often

00:05:47,490 --> 00:05:52,950
these people who use qmo to bootstrap

00:05:51,150 --> 00:05:55,190
their architectures don't necessarily

00:05:52,950 --> 00:05:58,320
bother to work on upstreaming the code

00:05:55,190 --> 00:06:00,480
there are being various forks of qmo

00:05:58,320 --> 00:06:05,580
supporting exotic architectures that

00:06:00,480 --> 00:06:07,919
have not been ended up in qmo then a

00:06:05,580 --> 00:06:10,860
rather new use case is building

00:06:07,919 --> 00:06:13,020
container images when you don't have the

00:06:10,860 --> 00:06:15,870
target architecture machine around or

00:06:13,020 --> 00:06:18,840
you're using some kind of community

00:06:15,870 --> 00:06:21,960
provided infrastructures from docker hub

00:06:18,840 --> 00:06:25,860
or Travis and you would like to support

00:06:21,960 --> 00:06:27,600
say raspberry PI's then people use qmo

00:06:25,860 --> 00:06:32,910
Linux user to build their container

00:06:27,600 --> 00:06:36,600
images and finally as was mentioned in

00:06:32,910 --> 00:06:39,660
the earlier that if you have some old

00:06:36,600 --> 00:06:40,620
hppa binaries around and you want to

00:06:39,660 --> 00:06:43,169
still run the money

00:06:40,620 --> 00:06:46,229
have sent your hppa machine to a museum

00:06:43,169 --> 00:06:50,100
well Linux user QM can help you run

00:06:46,229 --> 00:06:51,960
those applications often in the linux

00:06:50,100 --> 00:06:54,540
area it's not that interesting because

00:06:51,960 --> 00:06:56,940
most Linux applications are open source

00:06:54,540 --> 00:06:57,750
and you can compile them but that's not

00:06:56,940 --> 00:07:00,630
always the case

00:06:57,750 --> 00:07:03,090
there are proprietary Linux applications

00:07:00,630 --> 00:07:07,220
and sometimes you may have lost the

00:07:03,090 --> 00:07:10,380
source code or other reasons such like

00:07:07,220 --> 00:07:14,510
debugging or reverse engineering some

00:07:10,380 --> 00:07:14,510
applications for a foreign architecture

00:07:15,949 --> 00:07:21,900
the status currently is that we have

00:07:19,050 --> 00:07:25,889
about 30 targets we can build to a

00:07:21,900 --> 00:07:30,270
target may be for example we have 6

00:07:25,889 --> 00:07:33,090
different targets for MIPS and on the

00:07:30,270 --> 00:07:35,520
host side we have nine targets which is

00:07:33,090 --> 00:07:37,380
one is the interpreter which could

00:07:35,520 --> 00:07:42,020
theoretically run on any architecture

00:07:37,380 --> 00:07:46,560
but is rather slow if we take the

00:07:42,020 --> 00:07:51,060
easiest case we have then arm 64 host

00:07:46,560 --> 00:07:54,380
arm 64 target and an AMD 64 machine both

00:07:51,060 --> 00:07:58,470
are 64-bit and both are little-endian

00:07:54,380 --> 00:08:02,370
recent run of my LTP testing gave 58

00:07:58,470 --> 00:08:08,660
failures in 1158 tests that's about 5%

00:08:02,370 --> 00:08:08,660
of the two scores are failing and

00:08:09,590 --> 00:08:15,620
usually most applications that people

00:08:12,000 --> 00:08:17,820
try on qmu Linux user do work one of the

00:08:15,620 --> 00:08:20,699
current issues that we have been

00:08:17,820 --> 00:08:23,729
investigating is Java so there has been

00:08:20,699 --> 00:08:26,160
possibly a regression or then it doesn't

00:08:23,729 --> 00:08:29,160
never really work it properly but we

00:08:26,160 --> 00:08:31,169
have a bug or on it it's kind of a weird

00:08:29,160 --> 00:08:33,330
thing to emulate since it's a

00:08:31,169 --> 00:08:35,279
architecture independent language and

00:08:33,330 --> 00:08:41,729
you could direct Italy lon just run the

00:08:35,279 --> 00:08:44,790
arm 64 Java VM or x86 Java VM and not

00:08:41,729 --> 00:08:47,850
try to run it under QM but people have

00:08:44,790 --> 00:08:50,370
all kinds of reasons why they have to

00:08:47,850 --> 00:08:53,450
use the target architecture different

00:08:50,370 --> 00:08:53,450
from what they have currently

00:08:55,980 --> 00:09:04,259
so how does Linux user emulator work it

00:09:01,269 --> 00:09:08,499
tries to emulate the Linux kernel

00:09:04,259 --> 00:09:12,819
there's the system call interface IOC

00:09:08,499 --> 00:09:15,720
TLS some files under proc the interface

00:09:12,819 --> 00:09:18,449
is rather thin compared to many other

00:09:15,720 --> 00:09:21,120
things that people try to emulate and

00:09:18,449 --> 00:09:23,639
this is actually very similar to what

00:09:21,120 --> 00:09:26,529
Microsoft recently did when they started

00:09:23,639 --> 00:09:35,949
supporting Linux in Windows with their

00:09:26,529 --> 00:09:38,350
windows subsystem for Linux so here's a

00:09:35,949 --> 00:09:41,670
typical example of what we would do to

00:09:38,350 --> 00:09:45,129
emulate something in QM or Linux user

00:09:41,670 --> 00:09:48,970
the get random zeus call is rather new

00:09:45,129 --> 00:09:52,329
and it didn't exist before so we needed

00:09:48,970 --> 00:09:55,420
a patch to add it it's also a rather

00:09:52,329 --> 00:09:57,819
simple system call we have a memory area

00:09:55,420 --> 00:10:00,819
where we write some random bytes the

00:09:57,819 --> 00:10:08,439
size of the buffer and then a handful of

00:10:00,819 --> 00:10:11,680
flags we have an application that tries

00:10:08,439 --> 00:10:15,730
to call get random it sends the Zeus

00:10:11,680 --> 00:10:18,970
call and qmo intercepts it there's some

00:10:15,730 --> 00:10:21,220
mangling that needs to be done do we

00:10:18,970 --> 00:10:23,470
need to convert the endianness no

00:10:21,220 --> 00:10:26,110
because we are both if we are having the

00:10:23,470 --> 00:10:28,990
same are same endianness on both ends

00:10:26,110 --> 00:10:32,019
the constants might be different in this

00:10:28,990 --> 00:10:35,740
case it's not the case that flags are

00:10:32,019 --> 00:10:40,720
same on all architectures in some cases

00:10:35,740 --> 00:10:42,970
they they aren't and then we just call

00:10:40,720 --> 00:10:44,920
the get random from the kernel actually

00:10:42,970 --> 00:10:48,459
we don't usually call the kernel

00:10:44,920 --> 00:10:53,199
directly we call the Lib C function to

00:10:48,459 --> 00:10:55,449
do it then the main reason for this is

00:10:53,199 --> 00:10:57,970
that in some cases the host kernel might

00:10:55,449 --> 00:11:01,110
be a lot older than the target system is

00:10:57,970 --> 00:11:05,740
expecting you might be want to call on

00:11:01,110 --> 00:11:06,339
something and say the get random in the

00:11:05,740 --> 00:11:08,230
lips

00:11:06,339 --> 00:11:10,949
might have a fallback to support older

00:11:08,230 --> 00:11:14,170
Colonels while the system call would not

00:11:10,949 --> 00:11:16,600
so the colonel then gives us some random

00:11:14,170 --> 00:11:19,749
bits back in the memory buffer and then

00:11:16,600 --> 00:11:20,920
we go around the other way back do does

00:11:19,749 --> 00:11:23,800
there need to be an endianness

00:11:20,920 --> 00:11:27,129
conversion do is there some constants

00:11:23,800 --> 00:11:29,079
that need to be translated I finally did

00:11:27,129 --> 00:11:32,170
we get an error and how do we translate

00:11:29,079 --> 00:11:34,420
it to the correct error number and it

00:11:32,170 --> 00:11:37,389
gets back to the application then we

00:11:34,420 --> 00:11:39,399
continue to execute executing the TCG

00:11:37,389 --> 00:11:46,089
microbes until the next system called

00:11:39,399 --> 00:11:48,459
ioctl or whatever and then qmo it's

00:11:46,089 --> 00:11:52,089
going to look up like this this is

00:11:48,459 --> 00:11:56,620
actually from the qm source codes the

00:11:52,089 --> 00:11:58,990
loc user is a our function to allocate

00:11:56,620 --> 00:12:02,199
some memory - right - we don't actually

00:11:58,990 --> 00:12:06,300
allocate anything we might copy in some

00:12:02,199 --> 00:12:09,639
cases but usually without bother there

00:12:06,300 --> 00:12:13,620
there might be a page fault if we ask

00:12:09,639 --> 00:12:17,319
for a too big memory area - right - and

00:12:13,620 --> 00:12:19,809
then we call that get random Lipsy

00:12:17,319 --> 00:12:23,259
function and use the get err not

00:12:19,809 --> 00:12:25,749
function to convert the error number if

00:12:23,259 --> 00:12:29,410
it we got an error to the correct one

00:12:25,749 --> 00:12:33,459
and finally in the unlock user we which

00:12:29,410 --> 00:12:36,069
is tries to look a bit like copy to use

00:12:33,459 --> 00:12:39,040
this lock user and unlock user look a

00:12:36,069 --> 00:12:41,910
bit like copy to user and copy from user

00:12:39,040 --> 00:12:41,910
in the kernel

00:12:48,520 --> 00:12:54,070
so in this case we don't need to do any

00:12:51,160 --> 00:12:57,370
endianness conversion in any cases

00:12:54,070 --> 00:12:59,500
because it's random bits and even if it

00:12:57,370 --> 00:13:07,690
would swap them the endianness it's

00:12:59,500 --> 00:13:09,910
still going to be random so typical

00:13:07,690 --> 00:13:12,100
issues we pump into one implementing

00:13:09,910 --> 00:13:15,820
system calls as mentioned we have the

00:13:12,100 --> 00:13:20,230
big endianness issue most of the users

00:13:15,820 --> 00:13:22,990
of qmo in being using little endian

00:13:20,230 --> 00:13:26,680
machines and little endian targets so

00:13:22,990 --> 00:13:30,160
there's a lot of say bit rot from the

00:13:26,680 --> 00:13:33,339
idea that we should support big endian

00:13:30,160 --> 00:13:35,339
guests some big endian Hoatzin it

00:13:33,339 --> 00:13:38,490
doesn't quite work there are a lot of

00:13:35,339 --> 00:13:41,500
places where people have forgotten them

00:13:38,490 --> 00:13:43,600
we have to get user and put user

00:13:41,500 --> 00:13:46,450
functions that if you use them correctly

00:13:43,600 --> 00:13:48,580
it will do them and if you have

00:13:46,450 --> 00:13:54,730
something more complicated we have the

00:13:48,580 --> 00:13:57,130
t's web apparently with a super and then

00:13:54,730 --> 00:13:59,140
we have the usual case of that more

00:13:57,130 --> 00:14:01,089
usual case that instead of just random

00:13:59,140 --> 00:14:03,820
bits we get from kernel we get some kind

00:14:01,089 --> 00:14:06,279
of struct or we have to pass a structure

00:14:03,820 --> 00:14:08,500
the kernel so we need to write a

00:14:06,279 --> 00:14:12,070
function that converts the struct from

00:14:08,500 --> 00:14:15,550
the way it's expected in the target

00:14:12,070 --> 00:14:18,820
architecture to the way that that host

00:14:15,550 --> 00:14:22,540
will use and finally there's also kind

00:14:18,820 --> 00:14:25,420
of weird cases of special registers or

00:14:22,540 --> 00:14:29,070
memory layout accesses which are

00:14:25,420 --> 00:14:29,070
different from each architecture

00:14:33,540 --> 00:14:39,750
so how do we test all this

00:14:37,240 --> 00:14:44,350
we don't really test it a lot but

00:14:39,750 --> 00:14:46,810
there's a if we have 30 targets and 9

00:14:44,350 --> 00:14:48,700
hosts that gives us a huge combination

00:14:46,810 --> 00:14:52,990
matrix of combinations that we could

00:14:48,700 --> 00:14:56,800
test currently most testing is goes

00:14:52,990 --> 00:14:59,529
around there on armed targets and x86

00:14:56,800 --> 00:15:02,650
hosts and sometimes on MIPS and PowerPC

00:14:59,529 --> 00:15:07,930
targets and these things that people

00:15:02,650 --> 00:15:10,779
happen to be developing on the quickest

00:15:07,930 --> 00:15:14,200
way to test this with a statics busybox

00:15:10,779 --> 00:15:18,370
binary because busybox is a nice tool

00:15:14,200 --> 00:15:21,100
that has a lot of the user land that is

00:15:18,370 --> 00:15:24,010
typical for linux but in a single binary

00:15:21,100 --> 00:15:26,470
so you can typically test a lot of

00:15:24,010 --> 00:15:29,380
system calls with the visit box itself

00:15:26,470 --> 00:15:33,490
already it's quite fast to set up

00:15:29,380 --> 00:15:35,620
because it's one binary and you can

00:15:33,490 --> 00:15:39,430
usually find a static binary for the

00:15:35,620 --> 00:15:41,710
architecture you're working for for more

00:15:39,430 --> 00:15:45,100
complete testing we have been using the

00:15:41,710 --> 00:15:51,460
Linux testing project Linux testing

00:15:45,100 --> 00:15:54,040
project has lots of binaries to test all

00:15:51,460 --> 00:15:57,070
kinds of system calls that the kernel

00:15:54,040 --> 00:15:58,600
supports it does a lot more though but

00:15:57,070 --> 00:16:08,010
this is the area that we are interested

00:15:58,600 --> 00:16:08,010
in we take

00:16:12,430 --> 00:16:16,470
example of what we can do with

00:16:22,850 --> 00:16:33,850
with busybox the list of all the tools

00:16:30,949 --> 00:16:36,739
that the busybox provides is quite long

00:16:33,850 --> 00:16:39,799
which of course many of them are just

00:16:36,739 --> 00:16:43,009
some string or file handling they don't

00:16:39,799 --> 00:16:45,079
give you any bigger information but you

00:16:43,009 --> 00:16:48,379
have a lot of more complicated commands

00:16:45,079 --> 00:16:50,689
for example IPA to discuss the colonel

00:16:48,379 --> 00:16:54,619
what interfaces and what IP addresses

00:16:50,689 --> 00:16:56,569
are there we see that by running it got

00:16:54,619 --> 00:16:59,749
relatively correct

00:16:56,569 --> 00:17:10,069
looking answers there's no garbage or so

00:16:59,749 --> 00:17:13,220
on and we get probably useful error

00:17:10,069 --> 00:17:18,649
messages yes you are not route the error

00:17:13,220 --> 00:17:22,809
no translation works fine if you're

00:17:18,649 --> 00:17:25,459
brave you can run queue a move it sudo

00:17:22,809 --> 00:17:29,809
and yeah we got a row socket also

00:17:25,459 --> 00:17:34,120
correctly so in general you can be happy

00:17:29,809 --> 00:17:34,120
these this combination

00:17:39,090 --> 00:17:46,289
so I also have a static busybox

00:17:42,450 --> 00:17:48,149
collection on the wiki pages from QM or

00:17:46,289 --> 00:17:50,220
which you can download if you want to

00:17:48,149 --> 00:17:59,759
try as a specific combination that you

00:17:50,220 --> 00:18:03,990
can't compile or find yourself LTP is

00:17:59,759 --> 00:18:06,330
that bigger monster to set up and the

00:18:03,990 --> 00:18:10,850
way that I do it is that I have a docker

00:18:06,330 --> 00:18:13,289
container that starts from the standard

00:18:10,850 --> 00:18:17,009
whatever architecture I'm targeting

00:18:13,289 --> 00:18:20,850
right now this example is from arm 64 we

00:18:17,009 --> 00:18:23,669
copy a qmo binary there install the

00:18:20,850 --> 00:18:27,179
build dependencies and compiling qmo

00:18:23,669 --> 00:18:29,039
this is a very slow way to compile LTP

00:18:27,179 --> 00:18:33,600
but on the other hand because I want to

00:18:29,039 --> 00:18:36,600
test qmo using humor to run all the GCC

00:18:33,600 --> 00:18:39,389
and making these commands is a useful

00:18:36,600 --> 00:18:39,899
way to find out earlier that if it works

00:18:39,389 --> 00:18:44,369
or not

00:18:39,899 --> 00:18:46,139
if the compilation fails into some seg

00:18:44,369 --> 00:18:51,690
faults or something I can be quite

00:18:46,139 --> 00:18:55,980
suspicious this is a like a typical

00:18:51,690 --> 00:19:02,730
example of using QM for building docker

00:18:55,980 --> 00:19:04,470
containers and the nice part of part of

00:19:02,730 --> 00:19:08,100
this container building is that you only

00:19:04,470 --> 00:19:10,639
need to do it once and then you can run

00:19:08,100 --> 00:19:14,330
the new New York Yan binaries with an

00:19:10,639 --> 00:19:14,330
existing container

00:19:15,619 --> 00:19:25,110
apparently this does not look very good

00:19:17,909 --> 00:19:27,869
on the slides we use that privileged

00:19:25,110 --> 00:19:30,179
mode because without it lots of tests

00:19:27,869 --> 00:19:33,659
the system calls are not simply

00:19:30,179 --> 00:19:35,789
available and this is one problem with

00:19:33,659 --> 00:19:37,889
container testing is that container does

00:19:35,789 --> 00:19:39,840
not allow you necessarily to use all the

00:19:37,889 --> 00:19:43,830
instructions you would all the system

00:19:39,840 --> 00:19:47,700
calls you would want to test we have

00:19:43,830 --> 00:19:52,100
that one one neat trick is to use the

00:19:47,700 --> 00:19:54,799
volume flag in dr2

00:19:52,100 --> 00:19:58,970
coppy you're currently new newly-built

00:19:54,799 --> 00:20:01,520
qmo and use it as the QM mood that is

00:19:58,970 --> 00:20:05,559
being run for all the but by tests

00:20:01,520 --> 00:20:08,320
you're going to run yeah

00:20:05,559 --> 00:20:11,480
this way you can use the existing

00:20:08,320 --> 00:20:16,330
container and just copy just link that

00:20:11,480 --> 00:20:16,330
latest new give him or your testing and

00:20:16,630 --> 00:20:23,809
they just run the run LTP collect some

00:20:20,690 --> 00:20:25,940
logs and you may have to have a skip

00:20:23,809 --> 00:20:28,549
list of a handful of tests that will

00:20:25,940 --> 00:20:33,169
hang either because of docker issues or

00:20:28,549 --> 00:20:35,960
qmo issues it takes about 20 minutes and

00:20:33,169 --> 00:20:38,690
if we will do it for all the 30 targets

00:20:35,960 --> 00:20:46,120
you we have available it's a bit

00:20:38,690 --> 00:20:46,120
unwieldy for doing it then say every day

00:20:53,409 --> 00:21:02,840
so there's the discussion of the what

00:20:58,340 --> 00:21:06,289
should be the future of QA moving the

00:21:02,840 --> 00:21:08,600
Linux user part in qmo first of all if

00:21:06,289 --> 00:21:12,440
you are a new to queue a more kayvyun

00:21:08,600 --> 00:21:14,600
project the new user part is a very easy

00:21:12,440 --> 00:21:16,640
place to come to there's a lot of

00:21:14,600 --> 00:21:19,820
low-hanging fruits you can join to

00:21:16,640 --> 00:21:24,590
there's a the code hasn't really being

00:21:19,820 --> 00:21:26,750
cleaned up or refactored ever the any

00:21:24,590 --> 00:21:28,460
kind of patch you make we will give you

00:21:26,750 --> 00:21:30,980
some kind of check patch warnings

00:21:28,460 --> 00:21:34,539
because of the code around you is rather

00:21:30,980 --> 00:21:37,220
ugly and not check patch ready

00:21:34,539 --> 00:21:39,950
another easy way to find a lot of things

00:21:37,220 --> 00:21:44,360
to fix is to try something else than x86

00:21:39,950 --> 00:21:46,760
as host or try a big ambient target I'm

00:21:44,360 --> 00:21:52,909
sure you'll find a lot of fun bugs to

00:21:46,760 --> 00:21:56,380
fix and then there's the options that we

00:21:52,909 --> 00:22:02,929
could discuss off making it less ugly

00:21:56,380 --> 00:22:04,140
the Zeus call that C is one huge if case

00:22:02,929 --> 00:22:07,230
select

00:22:04,140 --> 00:22:09,059
and there's a signal that see that could

00:22:07,230 --> 00:22:11,100
be split architecture specifically

00:22:09,059 --> 00:22:12,990
instead of having each architect or

00:22:11,100 --> 00:22:16,279
every architecture in the same file

00:22:12,990 --> 00:22:16,279
under a different if there

00:22:28,150 --> 00:22:34,450
so what if if we are going to start to

00:22:31,810 --> 00:22:37,840
be serious about the Linux user usage we

00:22:34,450 --> 00:22:40,870
should find a way to do the various

00:22:37,840 --> 00:22:43,180
testing we do less ad hoc and more

00:22:40,870 --> 00:22:46,680
tightly integrated into what we are

00:22:43,180 --> 00:22:52,240
already doing in Travis and so on

00:22:46,680 --> 00:22:57,670
but I said LTP tests take 20 minutes for

00:22:52,240 --> 00:23:01,330
one architecture find find some kind of

00:22:57,670 --> 00:23:05,050
subset of tests that makes sense to run

00:23:01,330 --> 00:23:09,670
for every every bill that touches QM a

00:23:05,050 --> 00:23:11,890
user code then we have the usual follow

00:23:09,670 --> 00:23:15,100
the kernel because kernel is always

00:23:11,890 --> 00:23:21,580
changing and bringing new interfaces new

00:23:15,100 --> 00:23:23,830
architectures it's not static and on the

00:23:21,580 --> 00:23:25,950
other end we have to discuss if there's

00:23:23,830 --> 00:23:28,780
some old code that could be removed to

00:23:25,950 --> 00:23:33,310
support I think Red Hat Enterprise Linux

00:23:28,780 --> 00:23:35,860
5 as the oldest baseline if that can be

00:23:33,310 --> 00:23:40,600
bumped up we can clean up some old if

00:23:35,860 --> 00:23:42,640
depth cases one interesting thing to do

00:23:40,600 --> 00:23:46,540
is to have better support for Android

00:23:42,640 --> 00:23:50,110
users and applications technically we

00:23:46,540 --> 00:23:53,440
used the Android has the same interface

00:23:50,110 --> 00:23:58,000
it uses the kernel it has a solidly

00:23:53,440 --> 00:24:00,400
different Lipsy but it does use things

00:23:58,000 --> 00:24:06,340
like binder and those have been not been

00:24:00,400 --> 00:24:09,040
implemented in queue linux user then I

00:24:06,340 --> 00:24:12,790
said we need some people to work on the

00:24:09,040 --> 00:24:15,460
BSD user parts there are some other

00:24:12,790 --> 00:24:20,500
architectures like unique or 32 that

00:24:15,460 --> 00:24:24,610
hasn't seen a comet for years and if

00:24:20,500 --> 00:24:27,070
eventually we get that lib TCG there's

00:24:24,610 --> 00:24:28,990
the discussion if it would make sense to

00:24:27,070 --> 00:24:35,590
have Linux user as it's completely

00:24:28,990 --> 00:24:40,290
independent project so any ideas or

00:24:35,590 --> 00:24:40,290
discussion on this front

00:24:47,259 --> 00:24:53,269
well I'm mostly interests of course on

00:24:50,059 --> 00:24:54,950
the x86 host site on the testing how do

00:24:53,269 --> 00:24:58,129
you do this so far this is all run in

00:24:54,950 --> 00:24:59,690
sequence on your system or for example

00:24:58,129 --> 00:25:03,110
could imagine you could push the test

00:24:59,690 --> 00:25:06,049
cases also and Travis containers or

00:25:03,110 --> 00:25:08,269
Travis runtimes in parallel if you

00:25:06,049 --> 00:25:09,019
paralyzed these kind of tests how does

00:25:08,269 --> 00:25:13,340
it look like

00:25:09,019 --> 00:25:16,429
well my machine can take like four or

00:25:13,340 --> 00:25:18,109
three of those together but if I would

00:25:16,429 --> 00:25:21,499
have infinite resources I would have

00:25:18,109 --> 00:25:24,619
cost run them all together the LTP is

00:25:21,499 --> 00:25:27,049
quite linear but it has some phases

00:25:24,619 --> 00:25:30,399
where it starts running hundreds of

00:25:27,049 --> 00:25:30,399
threads at the same time

00:25:35,730 --> 00:25:45,840
I have a question about the dodoka I

00:25:40,019 --> 00:25:49,590
like to wonder to wonder at the LTP test

00:25:45,840 --> 00:25:54,000
so it is the this description available

00:25:49,590 --> 00:25:56,039
in the room you saw so not yet so my

00:25:54,000 --> 00:25:58,169
intention is that we should get this

00:25:56,039 --> 00:26:01,789
integrated with that make darker things

00:25:58,169 --> 00:26:05,130
that existing Gilmour already

00:26:01,789 --> 00:26:11,809
documentation explaining how to do that

00:26:05,130 --> 00:26:11,809
to the test with Linux

00:26:13,159 --> 00:26:18,960
that's basically these slides and then

00:26:16,620 --> 00:26:21,269
the wiki page that was mentioned I don't

00:26:18,960 --> 00:26:24,179
think it mentions docker specifically to

00:26:21,269 --> 00:26:32,279
the chroot but the idea is actually very

00:26:24,179 --> 00:26:34,169
similar thank you and at the very

00:26:32,279 --> 00:26:40,169
beginning you mentioned that one of the

00:26:34,169 --> 00:26:41,880
original ideas was to run wine is it is

00:26:40,169 --> 00:26:44,220
it working well no others can you run

00:26:41,880 --> 00:26:46,860
with no spinal reason other platforms do

00:26:44,220 --> 00:26:50,039
you know well I haven't actually tried

00:26:46,860 --> 00:26:53,419
so that's actually made me something to

00:26:50,039 --> 00:26:53,419
find out ok

00:27:01,570 --> 00:27:07,420
so in your demo you showed an output of

00:27:04,520 --> 00:27:08,630
the IP command and you said it looks

00:27:07,420 --> 00:27:10,790
correct

00:27:08,630 --> 00:27:12,770
have you actually checked so basically

00:27:10,790 --> 00:27:16,300
can you can you just give the output of

00:27:12,770 --> 00:27:19,160
native common execution with the qumu

00:27:16,300 --> 00:27:21,170
users stuff and I mean I'm on an

00:27:19,160 --> 00:27:24,350
automated pace to kind of make sure that

00:27:21,170 --> 00:27:30,170
IP is not swapping bits in the IP

00:27:24,350 --> 00:27:32,420
address or whatever yeah but this is one

00:27:30,170 --> 00:27:35,030
one of the things so if you just I would

00:27:32,420 --> 00:27:37,880
assume that LTP has some Network link

00:27:35,030 --> 00:27:40,520
tests and if it does my questions over

00:27:37,880 --> 00:27:42,950
around LTP solely for correctness checks

00:27:40,520 --> 00:27:44,300
and yeah I think that's smoke testing

00:27:42,950 --> 00:27:47,050
that you just mentioned it's awesome

00:27:44,300 --> 00:27:49,970
just a quicker way to do things because

00:27:47,050 --> 00:27:52,100
setting up LTP and running it is a bit

00:27:49,970 --> 00:27:56,570
of a burden but you so you don't do

00:27:52,100 --> 00:27:59,480
busybox testing on a regular pace well I

00:27:56,570 --> 00:28:02,210
do do run the busybox applets that

00:27:59,480 --> 00:28:06,350
relate to the functions that people are

00:28:02,210 --> 00:28:09,140
test patching to so that's that usually

00:28:06,350 --> 00:28:11,750
if I'm lucky enough that the function

00:28:09,140 --> 00:28:14,240
that is being modified by people is

00:28:11,750 --> 00:28:16,610
something that the PMA is using that's a

00:28:14,240 --> 00:28:20,870
very easy way to find out that if it's

00:28:16,610 --> 00:28:23,150
correct or not on the other hand busybox

00:28:20,870 --> 00:28:26,450
is often using quite old versions of the

00:28:23,150 --> 00:28:28,730
system calls to do things and if the

00:28:26,450 --> 00:28:31,580
system call that is being implemented in

00:28:28,730 --> 00:28:35,500
QM is newer than what busybox supports

00:28:31,580 --> 00:28:35,500
then of course that doesn't work

00:28:46,520 --> 00:28:49,780
any other questions

00:28:55,549 --> 00:28:59,889

YouTube URL: https://www.youtube.com/watch?v=4MaGnMGPIq0


