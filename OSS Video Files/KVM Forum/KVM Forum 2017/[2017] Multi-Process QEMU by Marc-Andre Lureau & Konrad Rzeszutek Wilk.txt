Title: [2017] Multi-Process QEMU by Marc-Andre Lureau & Konrad Rzeszutek Wilk
Publication date: 2017-11-10
Playlist: KVM Forum 2017
Description: 
	QEMU is a large program, that links with hundreds of libraries. Over a million lines of C code in a single process, to hold a VM: this brings a lot of room for security vulnerabilities, even when using sandboxing. Sandboxing has to be quite permissive for all the code, and doesn't prevent QEMU from crashing. Having a single process also means it is harder to run concurrent work and schedule it well, or could lead to more memory fragmentation. QEMU could use multiple processes for various tasks, like device emulation. vhost-user is a solution for virtio devices, mostly used for networking, but can be applied to other kind of devices. This brings modularity, and allow device emulation to exist in external projects. However, new interfaces would have to be created for other kind of devices and tasks.

---

Marc-Andre Lureau
Senior Software Engineer, Red Hat, Inc.

QEMU & Spice developer, working for Red Hat. I used to work on other desktop & multimedia related projects. I gave various talks in conferences such as FOSDEM, DevConf, and previous KVM Forum.

Konrad Rzeszutek Wilk
Oracle
Software Director

Konrad Wilk is a Software Director at Oracle. His group's mission is to make Linux and Xen Project virtualization better and faster. As part of this work, Konrad has been the maintainer of the Xen Project subsystem in Linux kernel, Xen Project maintainer and had been the Release Manager for the 4.5 release of the Xen Project Hypervisor. Konrad has been active in the Linux and Xen Project communities for more than 7 years and was instrumental in adding Xen Project support to the Linux Kernel.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:05,990 --> 00:00:12,599
so thank you everybody for coming

00:00:09,179 --> 00:00:14,639
we have about 55 slides to go and we got

00:00:12,599 --> 00:00:17,850
about 40 more minutes to do it so we're

00:00:14,639 --> 00:00:19,529
gonna go really quickly let me just

00:00:17,850 --> 00:00:22,320
first introduce myself and my

00:00:19,529 --> 00:00:25,890
co-presenter I'm Conrad milk I work at

00:00:22,320 --> 00:00:30,539
Oracle I do I manage and direct the Xen

00:00:25,890 --> 00:00:33,450
and KVM virtualization product we're

00:00:30,539 --> 00:00:36,930
working on both sides of a

00:00:33,450 --> 00:00:39,090
virtualization and today I'm happy to

00:00:36,930 --> 00:00:41,489
present a presentation about qmu and how

00:00:39,090 --> 00:00:43,649
to slim it down along with mark mark

00:00:41,489 --> 00:00:45,059
yourself so my name is Malcolm ray I

00:00:43,649 --> 00:00:46,680
work for reddit for the past seven years

00:00:45,059 --> 00:00:49,710
and I've been working on kmu for the

00:00:46,680 --> 00:00:51,899
past two years right

00:00:49,710 --> 00:00:53,550
so by the way if you have questions just

00:00:51,899 --> 00:00:55,379
raise your hand wave will try to stop

00:00:53,550 --> 00:00:57,539
and answer them but also we have time

00:00:55,379 --> 00:01:00,809
afterwards so you can always come and

00:00:57,539 --> 00:01:03,210
ask us and you know one of the things

00:01:00,809 --> 00:01:06,299
that's kind of neat is I'll go really

00:01:03,210 --> 00:01:08,250
quickly in some of these slices qmu when

00:01:06,299 --> 00:01:09,780
it started was a really cool project you

00:01:08,250 --> 00:01:11,400
could use it to test different things

00:01:09,780 --> 00:01:14,130
you can still use it obviously with the

00:01:11,400 --> 00:01:17,460
translator you can run on x86 you can

00:01:14,130 --> 00:01:20,549
run arch 64 arm code and build it and so

00:01:17,460 --> 00:01:23,189
forth but it is used in virtualization

00:01:20,549 --> 00:01:24,960
for both KVM and then there's different

00:01:23,189 --> 00:01:26,189
ways it's used and I figure the

00:01:24,960 --> 00:01:27,630
beginning of slides I'm just gonna give

00:01:26,189 --> 00:01:28,890
you guys an overview of how it's used in

00:01:27,630 --> 00:01:30,390
one world and then we're gonna jump to

00:01:28,890 --> 00:01:32,400
the other world and how we connect what

00:01:30,390 --> 00:01:34,290
we're both were thinking of going

00:01:32,400 --> 00:01:37,439
forward and looking forward to you guys

00:01:34,290 --> 00:01:39,180
input well one of the things that's very

00:01:37,439 --> 00:01:40,380
different between those two

00:01:39,180 --> 00:01:43,770
virtualization open-source

00:01:40,380 --> 00:01:46,979
virtualization is how qmu is used in KVM

00:01:43,770 --> 00:01:48,960
it's kind of used fully it's both as a

00:01:46,979 --> 00:01:52,729
control stack as AI emulation layer on

00:01:48,960 --> 00:01:56,670
then it's only used as emulation layer

00:01:52,729 --> 00:01:59,549
now why does this matter to me so one of

00:01:56,670 --> 00:02:01,259
the things that Oracle will work for is

00:01:59,549 --> 00:02:03,899
we also public cloud provider and we're

00:02:01,259 --> 00:02:06,090
really worried about attacks you know

00:02:03,899 --> 00:02:07,770
it's great we have customers at the same

00:02:06,090 --> 00:02:10,020
time those customers can get hacked and

00:02:07,770 --> 00:02:11,650
they become evil customers and when that

00:02:10,020 --> 00:02:13,360
happens we really are not too high

00:02:11,650 --> 00:02:14,890
about it and there's multiple ways this

00:02:13,360 --> 00:02:18,189
can happen you know there's that tax

00:02:14,890 --> 00:02:19,840
through x86 up codes there is the hyper

00:02:18,189 --> 00:02:21,340
calls to Emma Soros there's a whole

00:02:19,840 --> 00:02:23,349
bunch of them and there was almost two q

00:02:21,340 --> 00:02:25,989
mu this talk is more about ki mu so

00:02:23,349 --> 00:02:28,209
let's just focus on that one now if you

00:02:25,989 --> 00:02:31,569
actually look at the architecture of how

00:02:28,209 --> 00:02:34,239
Q mu is being used inside of both KVM

00:02:31,569 --> 00:02:39,459
and then you know on the right side we

00:02:34,239 --> 00:02:41,439
have I'll try not to use the pointer on

00:02:39,459 --> 00:02:43,750
the right side we have how KVM and you

00:02:41,439 --> 00:02:45,400
can see this giant we have Q mu and

00:02:43,750 --> 00:02:46,810
inside of that is where the guest is

00:02:45,400 --> 00:02:49,090
actually running that is the memory of

00:02:46,810 --> 00:02:51,489
it on the left side is how Zen is done

00:02:49,090 --> 00:02:54,040
the memory is actually being controlled

00:02:51,489 --> 00:02:57,099
by Zen of it and q mu is on the side of

00:02:54,040 --> 00:02:58,720
it and it just does emulation to make

00:02:57,099 --> 00:02:59,920
that work there's another path of it

00:02:58,720 --> 00:03:02,079
which is the control stack and the

00:02:59,920 --> 00:03:05,109
control stack called libvirt or live

00:03:02,079 --> 00:03:08,409
excel all manage the ghast along with

00:03:05,109 --> 00:03:11,349
telling q mu what to do and alongside of

00:03:08,409 --> 00:03:14,049
that there is also the kernel the kernel

00:03:11,349 --> 00:03:16,629
has a lot of the backends so on then

00:03:14,049 --> 00:03:19,359
instead of having avert a Oh it's called

00:03:16,629 --> 00:03:23,079
Zen PV drivers and most of the ones are

00:03:19,359 --> 00:03:24,579
in the kernel space all right now one

00:03:23,079 --> 00:03:26,919
thing that some people may not know is

00:03:24,579 --> 00:03:29,109
that you can also do something that's

00:03:26,919 --> 00:03:32,680
kind of tweezing apart all of the things

00:03:29,109 --> 00:03:34,690
one of the ideas that Zen had was you

00:03:32,680 --> 00:03:36,010
want to separate as many components as

00:03:34,690 --> 00:03:38,230
possible because then you can

00:03:36,010 --> 00:03:40,120
concentrate on the smaller ones and make

00:03:38,230 --> 00:03:42,250
sure there is much to cure as possible

00:03:40,120 --> 00:03:43,629
and to make that happen they're all as

00:03:42,250 --> 00:03:45,729
well there's some components we just

00:03:43,629 --> 00:03:48,400
can't really do a good job of making

00:03:45,729 --> 00:03:50,169
sure that they're secure valid that we

00:03:48,400 --> 00:03:52,180
can certify we can go through code by

00:03:50,169 --> 00:03:54,609
code and figure out hey is this really

00:03:52,180 --> 00:03:57,489
secure so they came up with this idea of

00:03:54,609 --> 00:03:59,109
tweezing things apart even further so

00:03:57,489 --> 00:04:01,510
one of the things is like well why don't

00:03:59,109 --> 00:04:03,129
we just put Q inside of a guest you know

00:04:01,510 --> 00:04:06,879
you put a gel around it if it breaks

00:04:03,129 --> 00:04:09,459
well it breaks and if it does break then

00:04:06,879 --> 00:04:11,560
you know something is wrong you might as

00:04:09,459 --> 00:04:15,159
well kill both yes it's a great way of

00:04:11,560 --> 00:04:19,030
stopping attacks now how does it

00:04:15,159 --> 00:04:21,669
actually work so the Q mu part does the

00:04:19,030 --> 00:04:24,230
emulation right we have a 1,000 it ends

00:04:21,669 --> 00:04:25,850
up taking the packets from the guest or

00:04:24,230 --> 00:04:29,330
rights to it and then on the other side

00:04:25,850 --> 00:04:32,060
it has actually a pv driver so talks to

00:04:29,330 --> 00:04:34,460
the to the initial domain the first two

00:04:32,060 --> 00:04:35,810
Linux kernel and which actually does

00:04:34,460 --> 00:04:40,190
send all the packets over the network

00:04:35,810 --> 00:04:42,380
and it picks it up from the queue mu sub

00:04:40,190 --> 00:04:44,420
domain which basically takes packets

00:04:42,380 --> 00:04:45,920
from the guest and then sends it over in

00:04:44,420 --> 00:04:47,150
sellers at the back end hey this is

00:04:45,920 --> 00:04:50,270
where you're supposed to go and pick it

00:04:47,150 --> 00:04:52,910
up so the attack vector is actually in

00:04:50,270 --> 00:04:55,970
this case if a customer evil customer

00:04:52,910 --> 00:04:59,300
gets into the q mu they have to do

00:04:55,970 --> 00:05:01,220
attack through the pv ring that's their

00:04:59,300 --> 00:05:02,570
attack vector now in the past that had

00:05:01,220 --> 00:05:05,570
been attacks pretty cool ones actually

00:05:02,570 --> 00:05:07,820
one of them was this decent interesting

00:05:05,570 --> 00:05:09,710
optimization where it would pick up an

00:05:07,820 --> 00:05:11,870
index and then it would double fetch it

00:05:09,710 --> 00:05:14,080
again and you would do a jump table and

00:05:11,870 --> 00:05:17,600
you just it was a pretty neat attack but

00:05:14,080 --> 00:05:21,550
fortunately it's all fixed but you know

00:05:17,600 --> 00:05:24,590
past where past examples have shown that

00:05:21,550 --> 00:05:27,170
the neat thing about any PB protocol

00:05:24,590 --> 00:05:30,650
vertical or Zen is it's simple I mean

00:05:27,170 --> 00:05:33,410
it's it's there but it doesn't have that

00:05:30,650 --> 00:05:35,470
many things and it's pretty reliable so

00:05:33,410 --> 00:05:37,700
there's a lot less chance of any attacks

00:05:35,470 --> 00:05:39,530
now here's an example if you're using

00:05:37,700 --> 00:05:41,240
syrup I'm gonna skip over since we don't

00:05:39,530 --> 00:05:42,920
have that much time as I said there's a

00:05:41,240 --> 00:05:44,090
lot of slides and I really recommend

00:05:42,920 --> 00:05:45,350
that you guys take a look at it

00:05:44,090 --> 00:05:48,650
afterwards and go through them in

00:05:45,350 --> 00:05:50,570
details now what does all this mean as I

00:05:48,650 --> 00:05:53,450
kind of refer to the beginning is you

00:05:50,570 --> 00:05:55,430
have a jail around it meaning it's all

00:05:53,450 --> 00:05:58,610
kind of running inside of the MCS so

00:05:55,430 --> 00:06:00,590
that if something does break it's you

00:05:58,610 --> 00:06:02,000
know you still have another way of you

00:06:00,590 --> 00:06:05,660
don't have that many ways to get out of

00:06:02,000 --> 00:06:07,580
it now this is of course not a talked

00:06:05,660 --> 00:06:10,010
about then because Helena slides it says

00:06:07,580 --> 00:06:11,150
KVM forum so let's jump to KVM how can

00:06:10,010 --> 00:06:13,610
we make something like they're similar

00:06:11,150 --> 00:06:15,290
if we wanted to do it in cave yeah well

00:06:13,610 --> 00:06:18,590
here's an example of how we can do it

00:06:15,290 --> 00:06:19,850
and what I figure it is mark has been

00:06:18,590 --> 00:06:21,860
actually looking at this in much more

00:06:19,850 --> 00:06:26,360
details so I will jump over to him and

00:06:21,860 --> 00:06:30,560
let him focus on the core deep parts of

00:06:26,360 --> 00:06:33,650
this one oh wait sorry it's jumping a

00:06:30,560 --> 00:06:35,180
little bit ahead here you know there's

00:06:33,650 --> 00:06:36,890
also the question why would you actually

00:06:35,180 --> 00:06:37,969
want to do it I mean we have a whole

00:06:36,890 --> 00:06:39,860
bunch of pieces in

00:06:37,969 --> 00:06:41,659
you already that try to secure things

00:06:39,860 --> 00:06:44,599
you can do a lot with

00:06:41,659 --> 00:06:46,459
selinux the second there's also sea

00:06:44,599 --> 00:06:47,959
route gel all of these things can do it

00:06:46,459 --> 00:06:49,759
was I said one of the things that in

00:06:47,959 --> 00:06:53,029
these security people are really

00:06:49,759 --> 00:06:55,879
conscientious about is trying to erect

00:06:53,029 --> 00:06:58,759
barriers around pieces and seeing if

00:06:55,879 --> 00:07:00,979
those barriers are as much as possible

00:06:58,759 --> 00:07:03,349
audited and then also the code that they

00:07:00,979 --> 00:07:05,839
trust really audit and that's what we

00:07:03,349 --> 00:07:07,249
all want in a cloud environment we want

00:07:05,839 --> 00:07:11,079
to make sure that we sleep at night

00:07:07,249 --> 00:07:15,819
without having to worry about exploits

00:07:11,079 --> 00:07:15,819
all right let's switch over thank you

00:07:20,139 --> 00:07:26,539
alright so this is nice so yeah I'm

00:07:24,319 --> 00:07:28,399
going to focus a bit more on kaymu first

00:07:26,539 --> 00:07:32,119
of all I must say this is a broad

00:07:28,399 --> 00:07:34,819
subject as you can imagine and we are

00:07:32,119 --> 00:07:36,829
going to focus perhaps a bit more on the

00:07:34,819 --> 00:07:38,599
device aspect because when you think

00:07:36,829 --> 00:07:41,419
about multi processing qmu it's very

00:07:38,599 --> 00:07:42,769
generic but I'm going through like many

00:07:41,419 --> 00:07:47,919
aspects of what you can do to the

00:07:42,769 --> 00:07:50,989
Whiskey mu and multi-process work only

00:07:47,919 --> 00:07:52,789
and you might remember this talk seven

00:07:50,989 --> 00:07:54,679
years ago and I think that's one of the

00:07:52,789 --> 00:07:58,069
reason why a mu is designed this way

00:07:54,679 --> 00:08:01,249
there is a lot of historical background

00:07:58,069 --> 00:08:02,899
and it's I think the way the things are

00:08:01,249 --> 00:08:05,360
today is not necessarily the things have

00:08:02,899 --> 00:08:07,429
to be in the future so but you may just

00:08:05,360 --> 00:08:10,459
remember this talk has a similar title

00:08:07,429 --> 00:08:13,899
it's just a bit funny so I'm going to

00:08:10,459 --> 00:08:17,959
list a few facts in of what mu is today

00:08:13,899 --> 00:08:20,569
we are going to see what in general what

00:08:17,959 --> 00:08:22,399
what is what is the device like into mu

00:08:20,569 --> 00:08:25,639
and so what we need if we want to under

00:08:22,399 --> 00:08:29,059
it out of process and what exists today

00:08:25,639 --> 00:08:32,419
into mu so because I think many people

00:08:29,059 --> 00:08:35,149
don't realize what you can do already so

00:08:32,419 --> 00:08:37,729
first of all well Kim you is one of the

00:08:35,149 --> 00:08:39,759
biggest binary on my laptop and it's not

00:08:37,729 --> 00:08:43,759
just one binary it's ten binaries and

00:08:39,759 --> 00:08:47,559
it's a very big binary right but docker

00:08:43,759 --> 00:08:50,290
is beating us so we are still not so bad

00:08:47,559 --> 00:08:53,440
and it's also a lot of

00:08:50,290 --> 00:08:55,270
right and nobody can really I mean yeah

00:08:53,440 --> 00:08:56,680
it's a lot of right we all agree on that

00:08:55,270 --> 00:09:00,820
whenever we need to do some refactoring

00:08:56,680 --> 00:09:02,380
it's daunting by comparison the Linux

00:09:00,820 --> 00:09:05,410
kernel is 16 million line and we are

00:09:02,380 --> 00:09:07,480
about 1 million line and I think one of

00:09:05,410 --> 00:09:10,870
the reason why there is like more and

00:09:07,480 --> 00:09:12,430
more project using KVM without GMU it's

00:09:10,870 --> 00:09:14,920
because what you need is actually just a

00:09:12,430 --> 00:09:16,450
subset of that right I mean you can run

00:09:14,920 --> 00:09:18,910
a Linux operating system very

00:09:16,450 --> 00:09:20,500
efficiently with KVM tool and it's about

00:09:18,910 --> 00:09:22,480
twenty seven thousand nine so nothing

00:09:20,500 --> 00:09:24,040
compared to to cream you anyone if you

00:09:22,480 --> 00:09:25,900
want to you know study or hacked

00:09:24,040 --> 00:09:27,640
something it's actually much faster and

00:09:25,900 --> 00:09:30,070
easier to do it with KVM too right

00:09:27,640 --> 00:09:33,490
so it's it's a bit sad that kami doesn't

00:09:30,070 --> 00:09:35,590
help out this kind of stability you know

00:09:33,490 --> 00:09:37,000
and I don't know if you know this

00:09:35,590 --> 00:09:40,030
project but while I was working on the

00:09:37,000 --> 00:09:41,680
slide so because this is a yeah I was

00:09:40,030 --> 00:09:43,000
looking at so many things

00:09:41,680 --> 00:09:46,000
and I discovered this project from

00:09:43,000 --> 00:09:48,220
Google which actually use multi-process

00:09:46,000 --> 00:09:50,800
for the device running so I encourage

00:09:48,220 --> 00:09:53,740
you to look at it and it's written in

00:09:50,800 --> 00:09:56,710
rust and the whole code is about thirty

00:09:53,740 --> 00:09:59,140
thousand nine and it's amazing so it has

00:09:56,710 --> 00:10:02,560
all the bindings I for rust so actually

00:09:59,140 --> 00:10:04,270
just the core of the the the the code is

00:10:02,560 --> 00:10:06,220
probably ten thousand I know I don't

00:10:04,270 --> 00:10:08,170
know because it even has to re-implement

00:10:06,220 --> 00:10:10,840
like UNIX ok turning because rust

00:10:08,170 --> 00:10:13,810
doesn't support certain things so you

00:10:10,840 --> 00:10:15,400
can imagine so and it's not just the

00:10:13,810 --> 00:10:19,210
size of the binary right it's all the

00:10:15,400 --> 00:10:21,370
things we depend on and yeah I'm going

00:10:19,210 --> 00:10:24,310
to that after a letter so we can see the

00:10:21,370 --> 00:10:30,250
trend it's not over and we are writing

00:10:24,310 --> 00:10:32,890
this code in C what could go wrong yeah

00:10:30,250 --> 00:10:35,920
we have about 60 dark dependencies and

00:10:32,890 --> 00:10:37,930
that total of indirect dependencies 160

00:10:35,920 --> 00:10:39,970
almost and I don't there is probably

00:10:37,930 --> 00:10:44,230
more than that if you think about what

00:10:39,970 --> 00:10:47,590
can run dynamically KVM to only use 19

00:10:44,230 --> 00:10:54,390
even with all the options on so yeah

00:10:47,590 --> 00:10:57,100
that's what I think yes so this is like

00:10:54,390 --> 00:11:00,660
what was the goal seven years ago

00:10:57,100 --> 00:11:03,150
because EMU was not as far as I know was

00:11:00,660 --> 00:11:05,580
multi-process was not motivated sorry so

00:11:03,150 --> 00:11:08,700
we have a lot of the way the things are

00:11:05,580 --> 00:11:12,750
designer people were thinking mostly in

00:11:08,700 --> 00:11:14,790
as a single thread and the goal was to

00:11:12,750 --> 00:11:18,480
have a brass abuse read and device fraud

00:11:14,790 --> 00:11:20,730
it's not exactly like that today but we

00:11:18,480 --> 00:11:23,790
do a lot of things right and we managed

00:11:20,730 --> 00:11:26,880
to put some things in different fight so

00:11:23,790 --> 00:11:30,450
I its Paulo talk actually from four

00:11:26,880 --> 00:11:32,160
years ago this slide and well correct me

00:11:30,450 --> 00:11:34,230
if this is wrong but I think this is

00:11:32,160 --> 00:11:36,090
still like the picture today this is

00:11:34,230 --> 00:11:39,480
still the design mostly like so we

00:11:36,090 --> 00:11:41,940
managed to put some devices only out of

00:11:39,480 --> 00:11:45,110
the main thread basically so we have

00:11:41,940 --> 00:11:48,690
kind of slide on device sides let's say

00:11:45,110 --> 00:11:51,150
or even cue files we can do that I think

00:11:48,690 --> 00:11:54,750
but yeah there is tons of things running

00:11:51,150 --> 00:11:57,180
into me right and the idea is to try to

00:11:54,750 --> 00:11:59,880
put this apart and you know make qmu cut

00:11:57,180 --> 00:12:02,040
bay smaller and safer and so on so yeah

00:11:59,880 --> 00:12:07,500
that's what it really I think we should

00:12:02,040 --> 00:12:10,260
try to get to yeah so but this is the

00:12:07,500 --> 00:12:11,730
trouble right you get a lot of actually

00:12:10,260 --> 00:12:13,770
interaction between all these devices

00:12:11,730 --> 00:12:15,750
very quickly and not just like the

00:12:13,770 --> 00:12:18,720
devices but the help of sidon and the

00:12:15,750 --> 00:12:21,000
Apple helper processes so yeah this is

00:12:18,720 --> 00:12:22,650
an old debate actually you may remember

00:12:21,000 --> 00:12:26,550
the kernel discussion about this

00:12:22,650 --> 00:12:31,170
monolithic versus microkernel with Venus

00:12:26,550 --> 00:12:32,790
and Tannenbaum I think and yeah it's

00:12:31,170 --> 00:12:36,120
difficult to manage because we've got

00:12:32,790 --> 00:12:37,980
lots of processes to manage difficult to

00:12:36,120 --> 00:12:41,090
debug obviously for developer it's not

00:12:37,980 --> 00:12:43,260
just one process you can put under gdb

00:12:41,090 --> 00:12:46,350
difficult to test because if you have a

00:12:43,260 --> 00:12:49,830
combination of versions and so on this

00:12:46,350 --> 00:12:52,140
is a lot of trouble and some people are

00:12:49,830 --> 00:12:54,570
concerned about performance and today

00:12:52,140 --> 00:12:58,890
yeah it's probably a concern in some

00:12:54,570 --> 00:13:00,930
cases but why we wanted so Conrad listed

00:12:58,890 --> 00:13:03,420
already many reason for the security one

00:13:00,930 --> 00:13:05,100
of the reason or so in my motivation

00:13:03,420 --> 00:13:09,020
also is to have new some Maserati

00:13:05,100 --> 00:13:12,080
especially if we have like different

00:13:09,020 --> 00:13:14,030
if we have alternative to qmu they might

00:13:12,080 --> 00:13:16,490
implement the same thing again and again

00:13:14,030 --> 00:13:18,770
and again and it would be interesting if

00:13:16,490 --> 00:13:20,740
we can share like for example one thing

00:13:18,770 --> 00:13:23,900
that is pretty complex is the Vertigo

00:13:20,740 --> 00:13:27,050
GPIO GPU right it's it's not a simple

00:13:23,900 --> 00:13:28,970
device and I don't think people want to

00:13:27,050 --> 00:13:30,710
re-implement it for chilean tool or for

00:13:28,970 --> 00:13:33,860
cross vm if they need to do accelerated

00:13:30,710 --> 00:13:35,570
on during on chromium so it would be

00:13:33,860 --> 00:13:37,430
interesting if we managed to have common

00:13:35,570 --> 00:13:39,350
interfaces and we can share some project

00:13:37,430 --> 00:13:44,960
some device implementation and what's

00:13:39,350 --> 00:13:48,950
not and yeah obviously we talked about

00:13:44,960 --> 00:13:52,760
that yeah and I'm not going through that

00:13:48,950 --> 00:13:55,610
but there is a lot of let's say new

00:13:52,760 --> 00:13:58,070
stuff in the kernel to to isolate your

00:13:55,610 --> 00:14:00,110
processes and nifty stuff and it's not

00:13:58,070 --> 00:14:01,940
easy I mean we use some of them with

00:14:00,110 --> 00:14:03,740
libvirt and so on as we said but because

00:14:01,940 --> 00:14:06,380
everything is on single binary you have

00:14:03,740 --> 00:14:08,900
to be a very permissible right we cannot

00:14:06,380 --> 00:14:12,800
I cannot really decide what cam you

00:14:08,900 --> 00:14:15,080
really needs and if I implement devata

00:14:12,800 --> 00:14:16,970
or GPU device for example I know what

00:14:15,080 --> 00:14:19,910
what it needs so it's much easier for me

00:14:16,970 --> 00:14:22,090
to to set the rules for this device and

00:14:19,910 --> 00:14:26,570
I because I mentioned that in the

00:14:22,090 --> 00:14:27,920
abstract yeah I think it could help in

00:14:26,570 --> 00:14:30,880
some cases when you have long-running

00:14:27,920 --> 00:14:35,270
processes you may have like memory

00:14:30,880 --> 00:14:37,070
trouble and maybe if we put workload in

00:14:35,270 --> 00:14:38,570
different processes it may help in some

00:14:37,070 --> 00:14:41,000
cases for memory but I don't think it's

00:14:38,570 --> 00:14:44,630
a big issue for Khemu but just because I

00:14:41,000 --> 00:14:47,120
thought about that yeah so how do we do

00:14:44,630 --> 00:14:52,400
that how do we that's good we have some

00:14:47,120 --> 00:14:54,560
time yeah so there are a lot of

00:14:52,400 --> 00:14:56,630
strategies to do this multi processing

00:14:54,560 --> 00:14:58,250
the obvious thing is we could keep a

00:14:56,630 --> 00:15:02,150
single binary right and we could just

00:14:58,250 --> 00:15:04,700
fork well could just we could we

00:15:02,150 --> 00:15:06,640
could set up devices or the work into mu

00:15:04,700 --> 00:15:10,089
and then just fork it and

00:15:06,640 --> 00:15:11,589
and jail it and what's not and so this

00:15:10,089 --> 00:15:15,010
is one approach that actually caused me

00:15:11,589 --> 00:15:16,300
a mistaken so far maybe they will you

00:15:15,010 --> 00:15:18,010
know which we managed to have some

00:15:16,300 --> 00:15:19,870
something in common that would be

00:15:18,010 --> 00:15:22,899
interesting that we share something

00:15:19,870 --> 00:15:25,750
but for now they do everything in this

00:15:22,899 --> 00:15:28,060
binary they set up the device and they

00:15:25,750 --> 00:15:30,070
said this they set up some circuits for

00:15:28,060 --> 00:15:34,420
communication and then the device goes

00:15:30,070 --> 00:15:37,240
in a jail and that's much easier to to

00:15:34,420 --> 00:15:39,240
test and so on and to code actually so

00:15:37,240 --> 00:15:41,440
you don't have to define a stable API

00:15:39,240 --> 00:15:43,899
interface and so on

00:15:41,440 --> 00:15:46,149
the other solution would be to execute a

00:15:43,899 --> 00:15:48,040
different binary right and I think I

00:15:46,149 --> 00:15:50,320
mean personally that's what I would like

00:15:48,040 --> 00:15:52,930
to see but it's it's much more difficult

00:15:50,320 --> 00:15:55,959
because you need to define these stable

00:15:52,930 --> 00:15:58,450
interfaces right and it's better if this

00:15:55,959 --> 00:16:05,079
interface supports various kind of

00:15:58,450 --> 00:16:08,740
devices and well there is some concerns

00:16:05,079 --> 00:16:11,649
about how to how to deal with all these

00:16:08,740 --> 00:16:13,300
processes so some people you know where

00:16:11,649 --> 00:16:16,899
should we do that like if I start today

00:16:13,300 --> 00:16:19,839
if I want to have my emulation in a

00:16:16,899 --> 00:16:21,910
separate process can I just should I do

00:16:19,839 --> 00:16:23,470
it in human like should I hard cut the

00:16:21,910 --> 00:16:25,990
path of the binary income you and cam

00:16:23,470 --> 00:16:27,399
you it should execute this well some

00:16:25,990 --> 00:16:30,640
people don't really like that so we had

00:16:27,399 --> 00:16:32,470
like contribution a few month ago like

00:16:30,640 --> 00:16:34,209
people started to do that with the TPM

00:16:32,470 --> 00:16:36,490
and we were not really happy about that

00:16:34,209 --> 00:16:38,230
but but it's very convenient at the same

00:16:36,490 --> 00:16:39,970
time and we want to keep like developers

00:16:38,230 --> 00:16:41,740
happy where they want to just touch gem

00:16:39,970 --> 00:16:44,649
you come online and if it uses multiple

00:16:41,740 --> 00:16:46,690
processes and then Jim you maybe should

00:16:44,649 --> 00:16:51,220
be able to do that but to do this safely

00:16:46,690 --> 00:16:53,680
is not easy because EMU is a large using

00:16:51,220 --> 00:16:55,750
a lot of memory and it's multi-sided so

00:16:53,680 --> 00:16:59,350
there is some concern how when you when

00:16:55,750 --> 00:17:02,680
you fall and we of course security

00:16:59,350 --> 00:17:04,480
reason as well and and the funny thing

00:17:02,680 --> 00:17:08,410
the funny fact that you may not realize

00:17:04,480 --> 00:17:11,350
but actually slow you can set up like an

00:17:08,410 --> 00:17:13,449
executable to another connection so this

00:17:11,350 --> 00:17:15,579
is kind of funny in fact there is

00:17:13,449 --> 00:17:17,430
actually executable path in Cameo I

00:17:15,579 --> 00:17:21,240
think most people disable that in

00:17:17,430 --> 00:17:22,710
right but and also in migration I don't

00:17:21,240 --> 00:17:23,940
know if we disable that but you can set

00:17:22,710 --> 00:17:28,440
up an executive or two on the other

00:17:23,940 --> 00:17:31,980
stream so we still we are doing this

00:17:28,440 --> 00:17:33,600
today already right and perhaps leave

00:17:31,980 --> 00:17:35,220
what would be a better fit to under all

00:17:33,600 --> 00:17:38,280
these different kind of devices and I

00:17:35,220 --> 00:17:42,150
think that's where that's where we are

00:17:38,280 --> 00:17:46,740
heading to probably for the real world

00:17:42,150 --> 00:17:49,020
where we'll use cases yeah so how do

00:17:46,740 --> 00:17:51,570
what what is the device like in

00:17:49,020 --> 00:17:55,650
cream.you so this is 10,000 feet view I

00:17:51,570 --> 00:17:59,400
have not like the low level system

00:17:55,650 --> 00:18:01,710
experience so I you know as Paula

00:17:59,400 --> 00:18:03,900
mentioned I am like in the top comatose

00:18:01,710 --> 00:18:05,460
but I don't I do a lot of cleanups and I

00:18:03,900 --> 00:18:07,170
don't I'm not specialised in one

00:18:05,460 --> 00:18:09,690
architecture or something well I know

00:18:07,170 --> 00:18:12,510
mostly x86 and KVM so I'm going to focus

00:18:09,690 --> 00:18:14,850
more about that and I touch BIOS devices

00:18:12,510 --> 00:18:17,400
let's say so the way I understand it

00:18:14,850 --> 00:18:20,370
basically you've got device description

00:18:17,400 --> 00:18:21,720
so depending on the device kind you need

00:18:20,370 --> 00:18:23,700
to describe it and you need to register

00:18:21,720 --> 00:18:27,090
it on the bus get addresses you can

00:18:23,700 --> 00:18:33,300
contact it and so on and basically boils

00:18:27,090 --> 00:18:35,580
down to registering memory regions in

00:18:33,300 --> 00:18:37,230
different address spaces and then you

00:18:35,580 --> 00:18:38,840
receive advanced on those memory region

00:18:37,230 --> 00:18:41,940
read and write events and so on and you

00:18:38,840 --> 00:18:44,100
can your device can basically interrupt

00:18:41,940 --> 00:18:45,780
the CPU at some point so there is

00:18:44,100 --> 00:18:47,670
various ways of doing that but to

00:18:45,780 --> 00:18:49,170
simplify it it's just like they say

00:18:47,670 --> 00:18:52,910
there is just an interrupt so you can

00:18:49,170 --> 00:18:55,320
say I take care of this device now and

00:18:52,910 --> 00:18:57,300
at the same time you need your device

00:18:55,320 --> 00:18:59,130
sometime is access to the memory of the

00:18:57,300 --> 00:19:01,170
system but maybe not all the memory so

00:18:59,130 --> 00:19:04,920
we've got iommu support for that

00:19:01,170 --> 00:19:07,560
and some time so this is pretty low

00:19:04,920 --> 00:19:10,140
level in general but you if you go a bit

00:19:07,560 --> 00:19:13,050
higher like with USB well it's it's a

00:19:10,140 --> 00:19:15,570
bit different right it's a higher level

00:19:13,050 --> 00:19:18,540
of abstraction and a device usually

00:19:15,570 --> 00:19:20,760
needs to manipulate to let to to be

00:19:18,540 --> 00:19:22,950
introspective all while to be

00:19:20,760 --> 00:19:25,220
discoverable let's say and to interact

00:19:22,950 --> 00:19:26,750
with it sometimes you need to have some

00:19:25,220 --> 00:19:28,360
ACPI

00:19:26,750 --> 00:19:31,150
registration or table

00:19:28,360 --> 00:19:32,770
that depending on your device and device

00:19:31,150 --> 00:19:34,929
tree is kind of similar you need to

00:19:32,770 --> 00:19:40,809
describe where your device is located

00:19:34,929 --> 00:19:42,610
and so on and a lot of details and we in

00:19:40,809 --> 00:19:45,130
cream you with we use a mechanism for

00:19:42,610 --> 00:19:47,440
that to build this kind of description

00:19:45,130 --> 00:19:48,820
we use from where config so devices

00:19:47,440 --> 00:19:53,320
interact with firmware conflict to

00:19:48,820 --> 00:19:54,940
discard them self and then income you've

00:19:53,320 --> 00:19:57,130
got a lot of cut to under the device

00:19:54,940 --> 00:19:58,660
state and the migration so this is

00:19:57,130 --> 00:20:00,520
something we have to take care we have

00:19:58,660 --> 00:20:07,030
to think about if we do the device out

00:20:00,520 --> 00:20:08,799
of process and and a lot of like if you

00:20:07,030 --> 00:20:11,350
start doing things out of process if

00:20:08,799 --> 00:20:14,260
your device access the memory directly

00:20:11,350 --> 00:20:16,360
you need to track if it's writing memory

00:20:14,260 --> 00:20:19,630
so we've got the RT memory region

00:20:16,360 --> 00:20:22,179
tracking and so on and cam us a lot of

00:20:19,630 --> 00:20:24,610
ways to introspect what's going on so if

00:20:22,179 --> 00:20:26,230
you do it out of process then you will

00:20:24,610 --> 00:20:31,620
need to interact with this so you can

00:20:26,230 --> 00:20:34,960
still see what's running and by tweak it

00:20:31,620 --> 00:20:38,470
so in kV I'm in particular the way it

00:20:34,960 --> 00:20:40,390
works and in jammu a few people well not

00:20:38,470 --> 00:20:42,850
a lot of people actually realize that I

00:20:40,390 --> 00:20:45,309
mean most people in the room I suppose

00:20:42,850 --> 00:20:49,120
know that but yeah you you when you run

00:20:45,309 --> 00:20:52,360
vc you said you use k vm and you say

00:20:49,120 --> 00:20:54,970
okay run it and whatever the the cpu

00:20:52,360 --> 00:20:56,860
touches the device in this memory region

00:20:54,970 --> 00:20:59,020
we talked about then you get an exit and

00:20:56,860 --> 00:21:01,929
you know the reason why and the location

00:20:59,020 --> 00:21:03,790
and some details and at this point in

00:21:01,929 --> 00:21:05,620
cameo we take this qme lock we talked

00:21:03,790 --> 00:21:10,630
about that still exists and that's like

00:21:05,620 --> 00:21:12,070
the legacy so in general that's the

00:21:10,630 --> 00:21:13,600
traditional device it's kind of

00:21:12,070 --> 00:21:17,679
synchronous this is my understanding

00:21:13,600 --> 00:21:19,929
feel free to correct me and so we go and

00:21:17,679 --> 00:21:21,220
we look up the the memory region and we

00:21:19,929 --> 00:21:23,890
do the read/write operation in the

00:21:21,220 --> 00:21:27,429
device and then if we need to interrupt

00:21:23,890 --> 00:21:30,580
the CPU we've got this i octal to send

00:21:27,429 --> 00:21:32,799
an intern so if we do things out of

00:21:30,580 --> 00:21:36,880
process actually k vm as as a few

00:21:32,799 --> 00:21:39,400
facilities to to let us do this job out

00:21:36,880 --> 00:21:41,230
of process and the way it works today

00:21:39,400 --> 00:21:46,360
for versed user as

00:21:41,230 --> 00:21:49,990
through 1150 so this is very nice and I

00:21:46,360 --> 00:21:52,630
are qfd so I think I'm going into a bit

00:21:49,990 --> 00:21:56,710
more details after so yeah I want every

00:21:52,630 --> 00:21:58,900
you register and address a lens and it's

00:21:56,710 --> 00:22:03,250
the lens is just like a word size kind

00:21:58,900 --> 00:22:07,570
of it's not a range and you set the EFD

00:22:03,250 --> 00:22:13,570
to be to be waking up if this the CPU

00:22:07,570 --> 00:22:15,640
right to this location but this is the

00:22:13,570 --> 00:22:17,200
as far as I understand this is not the

00:22:15,640 --> 00:22:19,420
same way as we have seen just before

00:22:17,200 --> 00:22:20,920
this is kind of a synchronous you and

00:22:19,420 --> 00:22:24,790
it's only on right immersion so you

00:22:20,920 --> 00:22:26,590
doesn't map the the legacy devices so

00:22:24,790 --> 00:22:30,250
this is good for modern devices that's

00:22:26,590 --> 00:22:31,660
kind of a synchronous and perhaps you

00:22:30,250 --> 00:22:34,060
know if we want to implement legacy

00:22:31,660 --> 00:22:36,100
devices we could extend this API somehow

00:22:34,060 --> 00:22:37,780
make it a range API to cover more memory

00:22:36,100 --> 00:22:42,120
region because we don't want to have

00:22:37,780 --> 00:22:44,650
tons of identity and and then we could

00:22:42,120 --> 00:22:47,560
we could also try to make it synchronous

00:22:44,650 --> 00:22:49,870
but I think this wouldn't fly so in

00:22:47,560 --> 00:22:51,670
general traditional devices so we will

00:22:49,870 --> 00:22:54,190
need something obviously in cream you

00:22:51,670 --> 00:22:56,920
without KVM we will need to think about

00:22:54,190 --> 00:22:59,440
the interface to to to tell the process

00:22:56,920 --> 00:23:03,190
ok the CPU try to read and write here

00:22:59,440 --> 00:23:06,850
and without using carrier but well with

00:23:03,190 --> 00:23:10,740
KVM we could use this device concept so

00:23:06,850 --> 00:23:13,980
in KVM you can like you can set up

00:23:10,740 --> 00:23:16,840
devices in the kernel or even like link

00:23:13,980 --> 00:23:20,170
your password devices with KVM using

00:23:16,840 --> 00:23:22,210
this interface and we could kind of

00:23:20,170 --> 00:23:23,950
extend this or create our own kind of

00:23:22,210 --> 00:23:26,620
device and basically the way i think

00:23:23,950 --> 00:23:30,160
about it but this is just some thought

00:23:26,620 --> 00:23:31,540
and nothing like we need to spend much

00:23:30,160 --> 00:23:33,670
more time to have a concrete proposal

00:23:31,540 --> 00:23:35,500
but the way I think it could work is

00:23:33,670 --> 00:23:39,310
basically if we need to understand

00:23:35,500 --> 00:23:41,020
synchronously we could just we could the

00:23:39,310 --> 00:23:43,480
same way as event EFD work with we

00:23:41,020 --> 00:23:44,560
register memory region we say ok I'm

00:23:43,480 --> 00:23:49,450
interested in read or write operation

00:23:44,560 --> 00:23:52,600
and we can set up an event FD and the

00:23:49,450 --> 00:23:54,610
thing is so once you register in this

00:23:52,600 --> 00:23:56,049
region we will wait for the event

00:23:54,610 --> 00:23:58,480
but the thing what would happen is the

00:23:56,049 --> 00:24:01,900
CPU would have to stop right while the

00:23:58,480 --> 00:24:05,400
other process under this and we need to

00:24:01,900 --> 00:24:05,400
think like do we want to have several

00:24:05,610 --> 00:24:12,490
several mmm how do we under the multi

00:24:10,630 --> 00:24:14,710
plus the demented solid case if we have

00:24:12,490 --> 00:24:15,370
multiple V CPU and they all access the

00:24:14,710 --> 00:24:17,080
same device

00:24:15,370 --> 00:24:21,610
do we multiplex everything in the same

00:24:17,080 --> 00:24:23,140
spread or in the same on low or you know

00:24:21,610 --> 00:24:26,170
if there are some things matter we could

00:24:23,140 --> 00:24:27,850
do and the way I think it could work is

00:24:26,170 --> 00:24:30,130
basically if we multiply splice things

00:24:27,850 --> 00:24:32,860
it's a bit like IO API

00:24:30,130 --> 00:24:35,290
I say IO API in Linux you could get all

00:24:32,860 --> 00:24:38,830
the events that happen in the values CPU

00:24:35,290 --> 00:24:40,540
and then write back what you need or

00:24:38,830 --> 00:24:42,700
send back what you need or what you did

00:24:40,540 --> 00:24:45,010
on this memory region so I think it

00:24:42,700 --> 00:24:46,540
could work this way but maybe I need to

00:24:45,010 --> 00:24:49,570
I probably need to spend some time if

00:24:46,540 --> 00:24:51,610
there is interest in this and feel free

00:24:49,570 --> 00:24:53,110
to to talk to me if you have some ideas

00:24:51,610 --> 00:24:55,299
that apparently some people have already

00:24:53,110 --> 00:25:00,130
suggested something similar in the past

00:24:55,299 --> 00:25:02,350
but yeah for migration I'm going to skip

00:25:00,130 --> 00:25:04,179
perhaps but the the idea is how can we

00:25:02,350 --> 00:25:05,710
share the infrastructure in GMU and how

00:25:04,179 --> 00:25:08,559
can we keep like the tools we have to

00:25:05,710 --> 00:25:10,720
analyze the migration trouble is various

00:25:08,559 --> 00:25:13,360
devices they use different kind of and

00:25:10,720 --> 00:25:16,330
TPM for example I think they specify how

00:25:13,360 --> 00:25:18,370
the migration is under the I think they

00:25:16,330 --> 00:25:20,590
have some format for sorry cyclization

00:25:18,370 --> 00:25:23,620
the thylacine sorry arising the the

00:25:20,590 --> 00:25:25,809
state of the TPM and sending it over for

00:25:23,620 --> 00:25:29,860
actually for your transition purposes I

00:25:25,809 --> 00:25:31,540
think and today with all the things I'm

00:25:29,860 --> 00:25:32,890
going to list it doesn't really exist

00:25:31,540 --> 00:25:35,350
like we cannot really make it the

00:25:32,890 --> 00:25:38,020
external process these very few things

00:25:35,350 --> 00:25:39,790
but it doesn't under all the cases or so

00:25:38,020 --> 00:25:41,559
what can you do today obviously you can

00:25:39,790 --> 00:25:42,910
run like the UI in a separate processor

00:25:41,559 --> 00:25:44,500
I'm going to be a bit controversial

00:25:42,910 --> 00:25:46,840
about that I'm going to suggest a few

00:25:44,500 --> 00:25:48,850
things block devices is one thing so the

00:25:46,840 --> 00:25:52,860
block layer you can actually run it in a

00:25:48,850 --> 00:25:57,760
different process in some you know ways

00:25:52,860 --> 00:25:59,260
the USB the smart card the the

00:25:57,760 --> 00:26:02,380
management interface from Intel actually

00:25:59,260 --> 00:26:03,490
the TPM recently so we've got the TPM

00:26:02,380 --> 00:26:07,270
emulation in

00:26:03,490 --> 00:26:12,429
possess the device I shouldn't talk

00:26:07,270 --> 00:26:15,279
about and the USPS user obviously this

00:26:12,429 --> 00:26:16,539
is the most popular today and I don't

00:26:15,279 --> 00:26:18,820
know why powerless you just said I

00:26:16,539 --> 00:26:20,710
talked about the FIO and then I thought

00:26:18,820 --> 00:26:23,590
okay maybe there is something to say

00:26:20,710 --> 00:26:26,649
about it so yes so VNC I think you know

00:26:23,590 --> 00:26:28,270
and in spice they allows you to run the

00:26:26,649 --> 00:26:29,260
UI in a separate process right and you

00:26:28,270 --> 00:26:31,929
can resume and so on it's very

00:26:29,260 --> 00:26:34,510
convenient the under migration actually

00:26:31,929 --> 00:26:36,070
pretty well and we spice there is some

00:26:34,510 --> 00:26:39,039
extension it's not being used but we can

00:26:36,070 --> 00:26:41,500
have like monitor and virtual terminals

00:26:39,039 --> 00:26:43,360
so what else do you need each mu right I

00:26:41,500 --> 00:26:46,149
mean why don't we just start this

00:26:43,360 --> 00:26:48,460
process and just remove all the SDL and

00:26:46,149 --> 00:26:50,500
gtk code from CMU and it would be you

00:26:48,460 --> 00:26:53,500
know one hundred thousand nine less

00:26:50,500 --> 00:26:55,210
think um you to bother and all the audio

00:26:53,500 --> 00:26:57,309
stuff for example so this is just a

00:26:55,210 --> 00:26:58,929
suggestion right and but I think it's

00:26:57,309 --> 00:27:01,049
worth to think about because there is a

00:26:58,929 --> 00:27:03,370
lot of duplication of a phone

00:27:01,049 --> 00:27:05,470
similarly so similar you know it's just

00:27:03,370 --> 00:27:07,000
like some stuff you can do today I don't

00:27:05,470 --> 00:27:08,890
know if it makes sense but yeah you can

00:27:07,000 --> 00:27:14,110
you can set up an midi server and run

00:27:08,890 --> 00:27:18,130
your your blog your your image in a

00:27:14,110 --> 00:27:20,080
separate process so this we move a lot

00:27:18,130 --> 00:27:22,330
of work from the main EMU binary I

00:27:20,080 --> 00:27:24,010
perhaps this is good enough like for

00:27:22,330 --> 00:27:26,590
desktop use cases and so on like if you

00:27:24,010 --> 00:27:28,510
don't we are not into very powerful

00:27:26,590 --> 00:27:30,070
performance sensitive applications and

00:27:28,510 --> 00:27:35,289
maybe we could make this a bit more

00:27:30,070 --> 00:27:37,419
generic or use the more often and we can

00:27:35,289 --> 00:27:39,159
probably optimize it actually and this

00:27:37,419 --> 00:27:41,440
is just an BD but actually with vast

00:27:39,159 --> 00:27:43,450
VOCs or block you can do also certain

00:27:41,440 --> 00:27:45,220
things right so we could try to push a

00:27:43,450 --> 00:27:49,059
bit the block layer outside of the qmu

00:27:45,220 --> 00:27:50,770
main binary similarly similarly they are

00:27:49,059 --> 00:27:53,830
they're all like the same kind of IDs so

00:27:50,770 --> 00:27:57,429
actually spice developed this protocol

00:27:53,830 --> 00:28:00,399
that you can you know yeah pass through

00:27:57,429 --> 00:28:02,169
your USB device or radio actual USB

00:28:00,399 --> 00:28:04,149
device from your client

00:28:02,169 --> 00:28:08,830
well the same protocol could be used to

00:28:04,149 --> 00:28:09,410
run USB emulation of devices outside of

00:28:08,830 --> 00:28:12,280
the

00:28:09,410 --> 00:28:15,350
binary I think at least that would be

00:28:12,280 --> 00:28:18,350
neat if someone like did this AK you

00:28:15,350 --> 00:28:22,210
just use the same can you USB code and

00:28:18,350 --> 00:28:26,510
you try to interface it with a USB idea

00:28:22,210 --> 00:28:28,160
so spark are dissimilar the Intel

00:28:26,510 --> 00:28:29,930
management interface if you didn't

00:28:28,160 --> 00:28:31,550
realize it's actually running it's in a

00:28:29,930 --> 00:28:34,670
separate process if you want to I think

00:28:31,550 --> 00:28:39,200
I think even you have to I personally

00:28:34,670 --> 00:28:42,830
will never really use this device and

00:28:39,200 --> 00:28:46,730
then more recently in March I think last

00:28:42,830 --> 00:28:48,410
month is the TPM emulation and as you

00:28:46,730 --> 00:28:50,540
can see all these device I mean all

00:28:48,410 --> 00:28:53,600
these cases they have different common

00:28:50,540 --> 00:28:55,790
line interface you need to set this

00:28:53,600 --> 00:29:02,630
devices differently like in the case of

00:28:55,790 --> 00:29:03,950
TPM there is some you cannot just start

00:29:02,630 --> 00:29:06,530
this binary like that I mean obviously

00:29:03,950 --> 00:29:08,420
you need to start it before you tell um

00:29:06,530 --> 00:29:10,490
you to connect to it and so on but you

00:29:08,420 --> 00:29:12,200
also need to set up like the state of

00:29:10,490 --> 00:29:14,570
the device with some comments so there

00:29:12,200 --> 00:29:16,160
is some stuff some preliminary work to

00:29:14,570 --> 00:29:17,480
do and if you want to under the

00:29:16,160 --> 00:29:20,750
migration I don't know all the details

00:29:17,480 --> 00:29:23,060
yet it's supposed to come soon but it's

00:29:20,750 --> 00:29:25,250
the same like you have a separate file

00:29:23,060 --> 00:29:27,020
or directory' that you need to take care

00:29:25,250 --> 00:29:28,610
and it's probably the management layer

00:29:27,020 --> 00:29:31,520
that is going to take care about this

00:29:28,610 --> 00:29:33,620
details the problem is if everybody for

00:29:31,520 --> 00:29:37,640
all the devices start to implement its

00:29:33,620 --> 00:29:40,220
own protocol like the TPM did and they

00:29:37,640 --> 00:29:42,080
have their own way of owning setting up

00:29:40,220 --> 00:29:43,850
the device and cheering him down and so

00:29:42,080 --> 00:29:45,560
on and it's going to be a lot of code

00:29:43,850 --> 00:29:50,930
doing kind of the same thing in submit

00:29:45,560 --> 00:29:53,900
side so in case of vias you know of

00:29:50,930 --> 00:29:57,590
yours to accelerate device something on

00:29:53,900 --> 00:30:00,470
the counter side it's been modified to

00:29:57,590 --> 00:30:02,930
work or so in user space by just using

00:30:00,470 --> 00:30:05,060
the same kind of protocol and making it

00:30:02,930 --> 00:30:07,250
over okay basically and it's very

00:30:05,060 --> 00:30:10,100
successful so we have seen try and

00:30:07,250 --> 00:30:12,950
recently it's it used to be like for the

00:30:10,100 --> 00:30:15,470
PDK and for packet switching stuff and

00:30:12,950 --> 00:30:18,300
so on and mostly network stuff now we

00:30:15,470 --> 00:30:21,960
have scuzzy only and block

00:30:18,300 --> 00:30:23,730
I have done GPU stuff input

00:30:21,960 --> 00:30:26,040
I know crypto there is some touch

00:30:23,730 --> 00:30:28,590
bending so we've got a lot of devices

00:30:26,040 --> 00:30:31,680
that people want to start to run outside

00:30:28,590 --> 00:30:34,140
of the Cameo binary and this is me this

00:30:31,680 --> 00:30:38,460
is neat I mean you can use this protocol

00:30:34,140 --> 00:30:40,680
with values implementation of the as

00:30:38,460 --> 00:30:44,340
usual you've got you know KVM tool could

00:30:40,680 --> 00:30:45,750
implement vsts awfully easily so they

00:30:44,340 --> 00:30:49,890
could benefit all all these devices

00:30:45,750 --> 00:30:51,750
quite quickly yeah I'm not going to

00:30:49,890 --> 00:30:55,230
detail how VOCs all work but basically

00:30:51,750 --> 00:30:59,310
the the outside process get access to

00:30:55,230 --> 00:31:00,750
the memory of the gas and knows the

00:30:59,310 --> 00:31:04,320
location of the ring and then it gets

00:31:00,750 --> 00:31:06,390
some file descriptor to to get notify

00:31:04,320 --> 00:31:09,600
when it needs to under the ring or it

00:31:06,390 --> 00:31:13,710
can notify the CPU that's it's it has

00:31:09,600 --> 00:31:17,640
done the work it needs to do and we

00:31:13,710 --> 00:31:19,350
recently have iommu support so you know

00:31:17,640 --> 00:31:20,970
currently this is not very secure

00:31:19,350 --> 00:31:23,280
because this outside process can

00:31:20,970 --> 00:31:24,900
actually do anything it wants with this

00:31:23,280 --> 00:31:26,910
shell memory with the memory of the

00:31:24,900 --> 00:31:30,420
guest but there is hope that in the

00:31:26,910 --> 00:31:34,170
future we managed to isolate the the

00:31:30,420 --> 00:31:35,760
memory so you only get access to the

00:31:34,170 --> 00:31:39,540
memory you are allowed to get access to

00:31:35,760 --> 00:31:42,180
and there is some tricks we could do

00:31:39,540 --> 00:31:44,250
with for example user fault it's not I

00:31:42,180 --> 00:31:46,440
discussed a bit with some RIA about it

00:31:44,250 --> 00:31:48,750
it's not yet possible but maybe in the

00:31:46,440 --> 00:31:50,640
future we could have like iommu support

00:31:48,750 --> 00:31:54,930
in user space some kind of emulated

00:31:50,640 --> 00:31:57,360
iommu so that's very interesting and so

00:31:54,930 --> 00:32:00,120
I said they actually that's why I wanted

00:31:57,360 --> 00:32:01,980
to talk about multi process that started

00:32:00,120 --> 00:32:05,160
like that I wanted to run the GPU

00:32:01,980 --> 00:32:09,300
outside of Khemu because the GPU virtual

00:32:05,160 --> 00:32:11,220
actually when you use really you've got

00:32:09,300 --> 00:32:12,780
tons of things to take care about and

00:32:11,220 --> 00:32:15,000
one of these for example is to compile

00:32:12,780 --> 00:32:16,680
your shader so it may take minute to

00:32:15,000 --> 00:32:18,750
compile and if you do it while you take

00:32:16,680 --> 00:32:21,200
the lock that we talked about basically

00:32:18,750 --> 00:32:23,910
you block um you for a minute right and

00:32:21,200 --> 00:32:25,740
so this is not really a good idea to run

00:32:23,910 --> 00:32:28,890
and yell and yeah it's not really safe

00:32:25,740 --> 00:32:31,740
API either and so it's better if we can

00:32:28,890 --> 00:32:35,110
run all the 3d

00:32:31,740 --> 00:32:38,200
stack outside of Camus and Jamie doesn't

00:32:35,110 --> 00:32:40,720
have to link with Meza and so on and so

00:32:38,200 --> 00:32:43,030
the way I suggested it and as you can

00:32:40,720 --> 00:32:44,800
see it's a bit like the goes back to the

00:32:43,030 --> 00:32:48,100
discussion like should came you under

00:32:44,800 --> 00:32:51,100
the the process and should it execute it

00:32:48,100 --> 00:32:53,230
itself the way I I implemented it in the

00:32:51,100 --> 00:32:56,920
IFC series is I created this object that

00:32:53,230 --> 00:32:58,660
for and exactly this binary so we could

00:32:56,920 --> 00:33:00,550
have a restriction on where the binary

00:32:58,660 --> 00:33:03,910
is located and so on signature and

00:33:00,550 --> 00:33:06,880
what's not if we need to but yeah and

00:33:03,910 --> 00:33:09,580
that's the way it works and it's gives

00:33:06,880 --> 00:33:12,310
you actually better performance and yeah

00:33:09,580 --> 00:33:13,870
it's more secure I have to like most

00:33:12,310 --> 00:33:15,790
devices they will need to interact with

00:33:13,870 --> 00:33:17,920
the mainframe you binary or next an

00:33:15,790 --> 00:33:20,350
external process like it would be nice

00:33:17,920 --> 00:33:21,880
if spice Ryan act or C&C server was

00:33:20,350 --> 00:33:24,580
running in a different process than chem

00:33:21,880 --> 00:33:26,920
you so you need to give some update of

00:33:24,580 --> 00:33:29,530
what's going on on the display and so on

00:33:26,920 --> 00:33:35,230
sure so and what's not so we've got just

00:33:29,530 --> 00:33:37,420
a few commands for that added on top of

00:33:35,230 --> 00:33:39,520
us user and they could be under by

00:33:37,420 --> 00:33:42,010
something different than kami but today

00:33:39,520 --> 00:33:45,220
in my life see it's just the Cameo

00:33:42,010 --> 00:33:49,690
binary right I already talked about that

00:33:45,220 --> 00:33:51,040
I know so the last one is the VF IO and

00:33:49,690 --> 00:33:52,720
ever I was really wondering like what

00:33:51,040 --> 00:33:54,430
Paulo suggested with VF i/o and the

00:33:52,720 --> 00:33:56,770
effect it's not really multi-process

00:33:54,430 --> 00:33:58,180
right it's for those who don't know VF

00:33:56,770 --> 00:34:00,370
iOS is done

00:33:58,180 --> 00:34:03,550
it's the API in the kernel to do device

00:34:00,370 --> 00:34:11,560
pass-through and we recently it has the

00:34:03,550 --> 00:34:13,540
media devices support but and so with

00:34:11,560 --> 00:34:15,730
this new support actually the

00:34:13,540 --> 00:34:19,990
interesting thing is someone from Nvidia

00:34:15,730 --> 00:34:22,360
implemented a cell device in kernel and

00:34:19,990 --> 00:34:26,470
it's not a hardware device it's just is

00:34:22,360 --> 00:34:29,200
using the internal kernel structure and

00:34:26,470 --> 00:34:30,520
an API to do the emulation and I was

00:34:29,200 --> 00:34:31,960
thinking well this is actually

00:34:30,520 --> 00:34:35,290
interesting this is all in software

00:34:31,960 --> 00:34:37,090
right so why don't we do the same thing

00:34:35,290 --> 00:34:39,190
in user space we could reuse VF i/o

00:34:37,090 --> 00:34:41,470
interface and implement the same device

00:34:39,190 --> 00:34:44,210
and perhaps many kind of devices with VF

00:34:41,470 --> 00:34:46,220
i/o so I started this work actually

00:34:44,210 --> 00:34:47,629
I just started last week and I started

00:34:46,220 --> 00:34:50,929
talking and it's going to learn sometime

00:34:47,629 --> 00:34:52,849
in the meninist as for discussion but

00:34:50,929 --> 00:34:54,980
for example some devices like the one I

00:34:52,849 --> 00:34:57,170
mentioned I wish man we don't really

00:34:54,980 --> 00:34:59,720
like it and you for some reason well we

00:34:57,170 --> 00:35:02,240
could just create a vfi or

00:34:59,720 --> 00:35:04,819
implementation in user space so we

00:35:02,240 --> 00:35:06,920
wouldn't have to bother about the I wish

00:35:04,819 --> 00:35:08,780
man maintenance and so on it's just an

00:35:06,920 --> 00:35:11,869
example right I have nothing against

00:35:08,780 --> 00:35:14,960
Ayushmann personally but so if we if we

00:35:11,869 --> 00:35:17,510
implement this VF i/o interface and it's

00:35:14,960 --> 00:35:19,160
very few changes in ki-moon card base

00:35:17,510 --> 00:35:23,510
because it's just the same IP I

00:35:19,160 --> 00:35:25,760
basically just overall circuit there are

00:35:23,510 --> 00:35:28,700
tricks to do obviously to do memory

00:35:25,760 --> 00:35:31,700
landing and so on and we need like the

00:35:28,700 --> 00:35:36,440
the KVM interface I talked about like -

00:35:31,700 --> 00:35:37,760
under the memory region exit so we need

00:35:36,440 --> 00:35:39,349
these kind of things for various kind of

00:35:37,760 --> 00:35:40,790
devices but for I wish meant for example

00:35:39,349 --> 00:35:44,960
it's very simple we probably don't need

00:35:40,790 --> 00:35:46,819
that so yeah and basically I have a

00:35:44,960 --> 00:35:49,430
proof of concept this style device this

00:35:46,819 --> 00:35:50,809
pci style device implemented as an

00:35:49,430 --> 00:35:55,280
external process using the VF i/o

00:35:50,809 --> 00:36:00,049
interface yeah so do you want to do the

00:35:55,280 --> 00:36:02,839
conclusion you know this is there's a

00:36:00,049 --> 00:36:04,760
lot of things like that there's there's

00:36:02,839 --> 00:36:06,200
a lot of things that we can do there's a

00:36:04,760 --> 00:36:07,790
lot of outstanding issues that we can

00:36:06,200 --> 00:36:10,339
that we have identified and we believe

00:36:07,790 --> 00:36:13,160
our are gonna make it hard to make it

00:36:10,339 --> 00:36:14,780
just right and you know there's there's

00:36:13,160 --> 00:36:16,970
definitely different ways of making it

00:36:14,780 --> 00:36:19,460
happen it's more of like how we can do

00:36:16,970 --> 00:36:21,079
it and which ones are make are more

00:36:19,460 --> 00:36:25,369
appropriate for certain things but if

00:36:21,079 --> 00:36:27,290
this is pretty exciting I think if you

00:36:25,369 --> 00:36:28,819
guys have any questions please raise

00:36:27,290 --> 00:36:30,140
your hand there's also time right

00:36:28,819 --> 00:36:31,700
afterwards because there's a coffee

00:36:30,140 --> 00:36:35,020
break so we can also spend some time at

00:36:31,700 --> 00:36:35,020
that but I see one hand up there

00:36:41,859 --> 00:36:48,169
so thanks a lot for the great

00:36:44,059 --> 00:36:50,899
presentation so you are giving the GPU

00:36:48,169 --> 00:36:53,209
as an example but I think that from the

00:36:50,899 --> 00:36:57,139
start you really had three different

00:36:53,209 --> 00:37:00,259
ways that splitting things could really

00:36:57,139 --> 00:37:02,299
help one was basically reducing the

00:37:00,259 --> 00:37:06,109
amount of code then you said something

00:37:02,299 --> 00:37:07,939
about improved security and you know

00:37:06,109 --> 00:37:11,179
being able to and then there is the

00:37:07,939 --> 00:37:14,449
performance aspect and so in your

00:37:11,179 --> 00:37:16,159
opinion which ones are going to really

00:37:14,449 --> 00:37:19,489
drive things if you take the vichy the

00:37:16,159 --> 00:37:22,459
GPU as an example do you think for

00:37:19,489 --> 00:37:24,829
instance the performance improvement

00:37:22,459 --> 00:37:26,449
that you are expecting are sustainable

00:37:24,829 --> 00:37:28,609
in the future is that just the current

00:37:26,449 --> 00:37:30,709
state that makes it so that it's higher

00:37:28,609 --> 00:37:35,659
performance now and do you think for

00:37:30,709 --> 00:37:39,489
instance that security is going to be

00:37:35,659 --> 00:37:39,489
very important for GPU and if so why

00:37:42,519 --> 00:37:46,639
it's not really about the performance

00:37:45,169 --> 00:37:48,709
yeah I mean if we have performance

00:37:46,639 --> 00:37:50,149
issues we solve it we try to find

00:37:48,709 --> 00:37:52,880
solution already today so it's not

00:37:50,149 --> 00:37:54,619
really about the performance what we

00:37:52,880 --> 00:37:56,779
want is to not degrade the performance

00:37:54,619 --> 00:38:00,109
if we if we start doing things out of

00:37:56,779 --> 00:38:02,899
process and I think we you know if we've

00:38:00,109 --> 00:38:04,639
used modern interfaces like dot IO there

00:38:02,899 --> 00:38:07,009
is no reason that you get lower

00:38:04,639 --> 00:38:08,659
performance if you do it out no I mean

00:38:07,009 --> 00:38:11,630
no there it might be reasons depending

00:38:08,659 --> 00:38:14,089
on the use case so it's also device per

00:38:11,630 --> 00:38:16,309
device for example the GPU I don't

00:38:14,089 --> 00:38:17,689
expect a big change of difference

00:38:16,309 --> 00:38:20,089
because most of the time is spent

00:38:17,689 --> 00:38:22,009
actually doing stuff in the GPU or doing

00:38:20,089 --> 00:38:26,059
stuff in userspace 200 all the commands

00:38:22,009 --> 00:38:27,769
and checking and compiling and so on so

00:38:26,059 --> 00:38:29,179
I don't think it's a you know it's not

00:38:27,769 --> 00:38:32,439
really a matter of performance system

00:38:29,179 --> 00:38:35,149
it's more about security and modularity

00:38:32,439 --> 00:38:37,759
yeah I mean it's a security part is if

00:38:35,149 --> 00:38:39,139
you isolated the process one of the neat

00:38:37,759 --> 00:38:41,359
thing is you can do better

00:38:39,139 --> 00:38:43,599
selinux policies be more targeted and

00:38:41,359 --> 00:38:43,599
say

00:38:44,150 --> 00:38:48,650
so you can raise the selinux policy

00:38:47,270 --> 00:38:51,490
labels that we want to apply to that

00:38:48,650 --> 00:38:54,620
process which should give you a better

00:38:51,490 --> 00:38:56,300
it will give you a better idea of what

00:38:54,620 --> 00:38:59,090
it is and what it shouldn't be doing

00:38:56,300 --> 00:39:00,710
which is really that's that's kind of

00:38:59,090 --> 00:39:02,090
what we're striving and furthermore you

00:39:00,710 --> 00:39:03,770
know by separating the code out then you

00:39:02,090 --> 00:39:07,310
can also start just focusing entirely

00:39:03,770 --> 00:39:17,630
just on that for security audit which is

00:39:07,310 --> 00:39:21,170
just good thank you change this change

00:39:17,630 --> 00:39:25,970
introduce a standard API in between

00:39:21,170 --> 00:39:30,170
parts if we're going to use the module

00:39:25,970 --> 00:39:34,940
requirement in this case those parts of

00:39:30,170 --> 00:39:38,150
we mo cannot be obliged to use of new

00:39:34,940 --> 00:39:41,090
public license and this is a big change

00:39:38,150 --> 00:39:44,570
in the whole framework right now there

00:39:41,090 --> 00:39:47,870
are all resides in of a single address

00:39:44,570 --> 00:39:52,700
space and GPL protects our work this is

00:39:47,870 --> 00:39:56,780
a modular change the right now we will

00:39:52,700 --> 00:40:02,680
corner cold source parts which could

00:39:56,780 --> 00:40:05,450
create some and unexpected complications

00:40:02,680 --> 00:40:08,090
what's the question right so it

00:40:05,450 --> 00:40:10,790
definitely it this is not a short this

00:40:08,090 --> 00:40:14,290
is a long road this project is not going

00:40:10,790 --> 00:40:16,460
to take you know a week or a month so

00:40:14,290 --> 00:40:18,560
there's pasture right you can start

00:40:16,460 --> 00:40:20,000
making these process these components

00:40:18,560 --> 00:40:23,180
being more modulus where we can load

00:40:20,000 --> 00:40:25,780
them during load time that's one way to

00:40:23,180 --> 00:40:30,530
start slowly tweeze out that namespace

00:40:25,780 --> 00:40:32,570
isolation the API part that's the tricky

00:40:30,530 --> 00:40:34,820
one that we honestly haven't figured

00:40:32,570 --> 00:40:36,650
completely out because all the devices

00:40:34,820 --> 00:40:39,020
have some of their own features that

00:40:36,650 --> 00:40:43,010
they want to expose to the guest at the

00:40:39,020 --> 00:40:45,470
same time there's a lot of them so to

00:40:43,010 --> 00:40:50,120
make a generic API for all of those it

00:40:45,470 --> 00:40:51,710
gets really hard and it for the

00:40:50,120 --> 00:40:52,520
beginning I think it's gonna be more

00:40:51,710 --> 00:40:55,070
iterative

00:40:52,520 --> 00:40:57,440
or some design errors about where we try

00:40:55,070 --> 00:40:59,000
to have a API that includes some of them

00:40:57,440 --> 00:41:01,190
and then we expand and figure out what

00:40:59,000 --> 00:41:03,680
goes as I said this is not a short-term

00:41:01,190 --> 00:41:05,300
thing so it's not going to be done in a

00:41:03,680 --> 00:41:07,369
year it's gonna take a couple of years

00:41:05,300 --> 00:41:08,930
and surely enough there will be issues

00:41:07,369 --> 00:41:20,240
along the way that we will have to

00:41:08,930 --> 00:41:21,920
revisit to make it just right it makes

00:41:20,240 --> 00:41:24,770
way for proprietary extensions which is

00:41:21,920 --> 00:41:26,420
not work oh okay yeah I'm not too happy

00:41:24,770 --> 00:41:28,070
about that either

00:41:26,420 --> 00:41:31,190
I completely agree that this could be

00:41:28,070 --> 00:41:35,930
used and for other open-source or non

00:41:31,190 --> 00:41:38,690
open-source to use it I don't really

00:41:35,930 --> 00:41:42,080
have a good answer to that except you

00:41:38,690 --> 00:41:44,450
know the idea isn't to make it an ABI

00:41:42,080 --> 00:41:46,850
it's the idea to make an API so that it

00:41:44,450 --> 00:41:50,869
would be based on the version of Q's

00:41:46,850 --> 00:41:52,970
it's not like we are going to we're not

00:41:50,869 --> 00:41:57,080
going to try to keep it in strict

00:41:52,970 --> 00:41:59,150
control but more of being fluid so every

00:41:57,080 --> 00:42:03,080
release of QM you may change it so there

00:41:59,150 --> 00:42:06,050
is gonna be breakage and that question

00:42:03,080 --> 00:42:08,119
of proprietary products linking into it

00:42:06,050 --> 00:42:13,990
linking into it I don't really have a

00:42:08,119 --> 00:42:13,990
good answer sorry I mean yeah sorry

00:42:16,310 --> 00:42:21,330
all right well I appreciate everybody

00:42:18,810 --> 00:42:23,110
now it's Coffee time thank you very much

00:42:21,330 --> 00:42:25,280
and enjoy the rest of the

00:42:23,110 --> 00:42:31,699
[Applause]

00:42:25,280 --> 00:42:31,699

YouTube URL: https://www.youtube.com/watch?v=Kq1-coHh7lg


