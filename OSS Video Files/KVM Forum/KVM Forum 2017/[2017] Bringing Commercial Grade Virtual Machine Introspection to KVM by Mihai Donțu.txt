Title: [2017] Bringing Commercial Grade Virtual Machine Introspection to KVM by Mihai Donțu
Publication date: 2017-11-16
Playlist: KVM Forum 2017
Description: 
	With this presentation, Mihai Dontu will explain what virtual machine introspection is trying to achieve, talk about previous research and current status on other platforms. He will then list the areas of the KVM hypervisor that needed enhancing to accommodate such technologies, and some of the more notable roadblocks which were overcome.

---

Mihai Donțu
Technical Project Manager, Bitdefender

Mihai Dontu is the technical project manager of the Linux development team within Bitdefender and is currently involved in integrating their virtual machine introspection technology in Xen and KVM.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:05,960 --> 00:00:10,620
good morning everyone my name is Mihai

00:00:08,580 --> 00:00:13,559
Junsu I lead the Linux development team

00:00:10,620 --> 00:00:16,890
at BitDefender where we integrate

00:00:13,559 --> 00:00:21,470
internal security technologies with open

00:00:16,890 --> 00:00:21,470
source projects this time around is KVM

00:00:22,220 --> 00:00:25,590
so my presentation is bringing

00:00:24,390 --> 00:00:29,580
commercial-grade virtual machine

00:00:25,590 --> 00:00:31,769
introspection KVM I'll like to add a bit

00:00:29,580 --> 00:00:35,579
of clarification so there are a couple

00:00:31,769 --> 00:00:39,290
of open-source vmi projects based on KVM

00:00:35,579 --> 00:00:44,370
but they mostly deal with analysis

00:00:39,290 --> 00:00:45,930
sample analysis exploits whatnot what

00:00:44,370 --> 00:00:48,270
we're trying to do is bring something

00:00:45,930 --> 00:00:52,140
that will allow doing via my real time

00:00:48,270 --> 00:00:54,210
in line that is get events from a

00:00:52,140 --> 00:00:56,789
virtual machine and react to them you

00:00:54,210 --> 00:01:02,399
know like block certain things

00:00:56,789 --> 00:01:05,400
oh I'll explain it along the way so I'm

00:01:02,399 --> 00:01:11,310
going to talk about why we're interested

00:01:05,400 --> 00:01:13,710
in VMI a bit of a history academic some

00:01:11,310 --> 00:01:17,479
third-party companies are around how we

00:01:13,710 --> 00:01:20,820
use VMI the current states in KVM and

00:01:17,479 --> 00:01:23,540
ongoing work they're not going to go

00:01:20,820 --> 00:01:27,320
into the nitty-gritty with code details

00:01:23,540 --> 00:01:34,979
it's just going to be me explain what

00:01:27,320 --> 00:01:38,900
VMI is and how it helps us is so what

00:01:34,979 --> 00:01:43,159
determines to look at VMI closer is the

00:01:38,900 --> 00:01:47,630
apparent increase in critical

00:01:43,159 --> 00:01:50,610
vulnerabilities zero-day exploits which

00:01:47,630 --> 00:01:54,600
certain actors turn into what we call

00:01:50,610 --> 00:01:59,939
advanced persistent threats some really

00:01:54,600 --> 00:02:04,439
nasty pieces of software that everybody

00:01:59,939 --> 00:02:08,390
tries to do it out so the nature of this

00:02:04,439 --> 00:02:12,180
type of attacks this type of exploit

00:02:08,390 --> 00:02:13,420
makes in guest security solutions that

00:02:12,180 --> 00:02:16,420
deal with

00:02:13,420 --> 00:02:19,870
analysis of previously seen samples of a

00:02:16,420 --> 00:02:22,300
certain malicious software they rendered

00:02:19,870 --> 00:02:25,989
them ineffective so we're looking native

00:02:22,300 --> 00:02:29,349
a VM I had a way to provide a type of

00:02:25,989 --> 00:02:34,120
generic protection for software running

00:02:29,349 --> 00:02:36,480
inside a guest the problem starts with

00:02:34,120 --> 00:02:40,800
the software itself for example

00:02:36,480 --> 00:02:43,959
obviously the kernels are very complex

00:02:40,800 --> 00:02:45,880
engineering works and they have to be

00:02:43,959 --> 00:02:49,720
there's a lot of hardware there like

00:02:45,880 --> 00:02:54,220
works in very complicated ways to put it

00:02:49,720 --> 00:02:57,130
very simply but there's also very

00:02:54,220 --> 00:02:59,799
complex user space software like

00:02:57,130 --> 00:03:02,220
browsers which these days are operating

00:02:59,799 --> 00:03:06,370
systems of their own I mean web assembly

00:03:02,220 --> 00:03:14,019
there's only there's only so much time

00:03:06,370 --> 00:03:16,200
until it turns in bite-size and some of

00:03:14,019 --> 00:03:20,049
this software can contain

00:03:16,200 --> 00:03:25,780
vulnerabilities that can be used to

00:03:20,049 --> 00:03:27,700
leverage to to gain privilege of such a

00:03:25,780 --> 00:03:33,519
nature that can compromise the entire

00:03:27,700 --> 00:03:37,660
system so obviously a number of projects

00:03:33,519 --> 00:03:39,760
of specifically for example in Linux

00:03:37,660 --> 00:03:41,470
kernel I believe please cook is leading

00:03:39,760 --> 00:03:44,019
the effort to integrate some of the

00:03:41,470 --> 00:03:46,209
PAC's approaches to some of these

00:03:44,019 --> 00:03:53,709
vulnerabilities but it's a process it's

00:03:46,209 --> 00:03:57,989
quite a long process so what is virtual

00:03:53,709 --> 00:04:00,670
machine introspection very basic details

00:03:57,989 --> 00:04:03,459
essentially deals with looking at a

00:04:00,670 --> 00:04:05,760
guest VM figuring out what's running

00:04:03,459 --> 00:04:09,190
inside it figuring out type of kernel

00:04:05,760 --> 00:04:10,389
that's easy to do when you once you find

00:04:09,190 --> 00:04:14,709
out where it's running a bit of

00:04:10,389 --> 00:04:17,380
fingerprinting will give you an idea of

00:04:14,709 --> 00:04:21,190
what type of kernel it is Linux Windows

00:04:17,380 --> 00:04:23,030
what not once you figure out how the

00:04:21,190 --> 00:04:26,450
kernel is laid out and where

00:04:23,030 --> 00:04:28,910
every bit of information it requires for

00:04:26,450 --> 00:04:34,640
management is located you can identify

00:04:28,910 --> 00:04:38,450
the applications you can get detailed

00:04:34,640 --> 00:04:42,020
information about them and once you

00:04:38,450 --> 00:04:43,700
build a complex image about everything

00:04:42,020 --> 00:04:46,630
that's going on inside the VM you can

00:04:43,700 --> 00:04:50,510
also determine when potentially

00:04:46,630 --> 00:04:53,870
malicious activity malicious code is

00:04:50,510 --> 00:04:59,900
running inside it and it's possible to

00:04:53,870 --> 00:05:03,610
do this without any software any helper

00:04:59,900 --> 00:05:07,970
and it gets tools inside the guest OS

00:05:03,610 --> 00:05:11,090
you can combine this with Hardware

00:05:07,970 --> 00:05:12,770
shadow page tables like extended page

00:05:11,090 --> 00:05:18,980
tables from inter or nested page tables

00:05:12,770 --> 00:05:20,690
OMD and you can enforce memory

00:05:18,980 --> 00:05:24,860
restrictions normally set by the guest

00:05:20,690 --> 00:05:30,020
and build a complex audit system that

00:05:24,860 --> 00:05:32,060
allows you to determine when an attack

00:05:30,020 --> 00:05:38,630
is taking place and also react to it

00:05:32,060 --> 00:05:42,160
like block it the advantages of VMI is

00:05:38,630 --> 00:05:45,940
that the nature of virtualization

00:05:42,160 --> 00:05:50,210
technologies implemented in modern CPUs

00:05:45,940 --> 00:05:52,400
make it that there you can create

00:05:50,210 --> 00:05:54,910
security solutions using VMI that are

00:05:52,400 --> 00:05:58,910
better isolated from the guest itself so

00:05:54,910 --> 00:06:01,000
obviously not needing to rely on guest

00:05:58,910 --> 00:06:03,770
services and guest kernel services and

00:06:01,000 --> 00:06:06,890
simply by looking at the memory layout

00:06:03,770 --> 00:06:12,919
figuring out what it does is an

00:06:06,890 --> 00:06:16,130
advantage it also provides a way to

00:06:12,919 --> 00:06:18,470
minimize interference with the guest

00:06:16,130 --> 00:06:20,810
software right you don't need to have

00:06:18,470 --> 00:06:26,410
drivers you don't need to load special

00:06:20,810 --> 00:06:26,410
dll's in every application in the system

00:06:26,650 --> 00:06:31,010
you can do it actually you can do it

00:06:29,150 --> 00:06:34,300
entirely without touching the guest

00:06:31,010 --> 00:06:36,360
however optimizing for specific cases

00:06:34,300 --> 00:06:40,110
might offer the

00:06:36,360 --> 00:06:43,830
I might give you the opportunity to do

00:06:40,110 --> 00:06:49,879
little injections little tricks to eight

00:06:43,830 --> 00:06:55,650
with maybe speed or particular cases so

00:06:49,879 --> 00:06:58,740
basic things basic situations that VMI

00:06:55,650 --> 00:07:01,500
can be used to defend against obviously

00:06:58,740 --> 00:07:03,449
the most popular buffer overflows you

00:07:01,500 --> 00:07:06,599
end up taking control of the execution

00:07:03,449 --> 00:07:08,159
flow and somehow along the way you get

00:07:06,599 --> 00:07:15,719
to execute a payload that's being placed

00:07:08,159 --> 00:07:17,909
on stack properly created applications

00:07:15,719 --> 00:07:19,800
might have the stack marked as none

00:07:17,909 --> 00:07:26,069
executive all but a lot of them out

00:07:19,800 --> 00:07:27,479
there are legacy applications and some

00:07:26,069 --> 00:07:29,240
of them haven't seen updates in quite a

00:07:27,479 --> 00:07:32,159
while so anyways

00:07:29,240 --> 00:07:36,050
VMI provides a way to defend against

00:07:32,159 --> 00:07:41,699
these simply by for example using the

00:07:36,050 --> 00:07:46,319
EPT to enforce normal permissions on the

00:07:41,699 --> 00:07:48,360
stack my rate right now executive it can

00:07:46,319 --> 00:07:51,860
also be used to in guaranteed the

00:07:48,360 --> 00:07:56,669
integrity of software running inside it

00:07:51,860 --> 00:07:59,759
so something that I should say is that

00:07:56,669 --> 00:08:01,919
security solutions built on VMI are not

00:07:59,759 --> 00:08:03,960
an end game they don't solve every

00:08:01,919 --> 00:08:07,469
problem out there they deal with a

00:08:03,960 --> 00:08:10,680
specific case integrity and they do it

00:08:07,469 --> 00:08:13,680
very well other cases like for example a

00:08:10,680 --> 00:08:16,860
file inspection or monitoring network

00:08:13,680 --> 00:08:19,349
events and correlating them with user

00:08:16,860 --> 00:08:22,909
applications and the connections they

00:08:19,349 --> 00:08:27,810
they have opened them communicate with

00:08:22,909 --> 00:08:30,689
those those might require dedicated

00:08:27,810 --> 00:08:33,659
applications inside a guest but VMI can

00:08:30,689 --> 00:08:37,199
make sure that these services on which

00:08:33,659 --> 00:08:40,289
those applications rely are running

00:08:37,199 --> 00:08:46,740
properly they are they haven't been

00:08:40,289 --> 00:08:47,980
compromised so

00:08:46,740 --> 00:08:51,820
[Music]

00:08:47,980 --> 00:08:55,270
with the help of all I've said so far

00:08:51,820 --> 00:08:58,580
you can build a sort of trust chain

00:08:55,270 --> 00:09:06,740
inside the guest from the kernel all the

00:08:58,580 --> 00:09:09,200
way to the user application we have I

00:09:06,740 --> 00:09:10,760
would say as luck would have it but I'm

00:09:09,200 --> 00:09:14,710
pretty sure some people were not really

00:09:10,760 --> 00:09:14,710
feeling lucky when it happened

00:09:15,650 --> 00:09:22,600
VMI basically a VMI based application

00:09:19,430 --> 00:09:26,210
proved itself useful quite fast

00:09:22,600 --> 00:09:28,180
for example the dreaded eternal blue

00:09:26,210 --> 00:09:32,810
I've talked about it in a separate

00:09:28,180 --> 00:09:36,500
presentation where a known vulnerability

00:09:32,810 --> 00:09:38,300
well known for a limited group somehow

00:09:36,500 --> 00:09:41,420
made it into the public and so did the

00:09:38,300 --> 00:09:47,150
exploit and from there it turned to a

00:09:41,420 --> 00:09:49,370
nightmare a our product based on VMI we

00:09:47,150 --> 00:09:53,260
defend their hypervisor introspection

00:09:49,370 --> 00:09:56,660
hvi identified and stopped eternal blue

00:09:53,260 --> 00:10:02,380
really fast because and I'm going to

00:09:56,660 --> 00:10:06,410
detail it in the next slides one of the

00:10:02,380 --> 00:10:09,200
key steps of the exploit is taking

00:10:06,410 --> 00:10:12,370
control over writings on architectural

00:10:09,200 --> 00:10:17,450
register something that VMI can easily

00:10:12,370 --> 00:10:19,880
detect when that happens all right a

00:10:17,450 --> 00:10:22,070
little bit of quick history so there's

00:10:19,880 --> 00:10:27,320
been quite some research in academia for

00:10:22,070 --> 00:10:30,100
VMI however around 2003 a paper that

00:10:27,320 --> 00:10:32,120
described an intrusion detection system

00:10:30,100 --> 00:10:36,400
answered a number of questions that

00:10:32,120 --> 00:10:39,260
researchers were were asking themselves

00:10:36,400 --> 00:10:42,200
the probably some of you have heard that

00:10:39,260 --> 00:10:45,440
before the context versus isolation

00:10:42,200 --> 00:10:47,930
right having a clear picture of what

00:10:45,440 --> 00:10:52,600
happens inside the guest OS and yet be

00:10:47,930 --> 00:10:57,120
outside of it in completely isolated in

00:10:52,600 --> 00:10:59,680
2006 using VMI they're people

00:10:57,120 --> 00:11:02,910
there was a paper that presented a way

00:10:59,680 --> 00:11:09,430
of creating honey pots and having

00:11:02,910 --> 00:11:13,540
analysis done with them with VMI in 2008

00:11:09,430 --> 00:11:18,660
there was a quite a practical approach

00:11:13,540 --> 00:11:21,310
to a malware detector using Zen the

00:11:18,660 --> 00:11:23,790
results of that research materialized

00:11:21,310 --> 00:11:31,810
into some code that ended up stream

00:11:23,790 --> 00:11:35,410
which was a boon for us in 2008 a large

00:11:31,810 --> 00:11:39,780
commercial entity decided to test the

00:11:35,410 --> 00:11:42,910
waters and created an API called VM safe

00:11:39,780 --> 00:11:45,970
around 2010 for reasons we can only

00:11:42,910 --> 00:11:49,780
speculate they backtracked on that and

00:11:45,970 --> 00:11:53,320
they rather than full virtual machine

00:11:49,780 --> 00:11:57,100
introspection they fall back to file

00:11:53,320 --> 00:12:00,640
inspection it is a rather nice manner

00:11:57,100 --> 00:12:02,230
they created a very tiny component that

00:12:00,640 --> 00:12:04,660
resides inside the guest and forwards

00:12:02,230 --> 00:12:07,570
everything to a virtual machine so the

00:12:04,660 --> 00:12:09,490
security application is isolated but

00:12:07,570 --> 00:12:14,260
anyway the scope of the protection is

00:12:09,490 --> 00:12:19,240
quite limited 2012 VM safe is gone and

00:12:14,260 --> 00:12:23,640
around 2014 stars aligned and a number

00:12:19,240 --> 00:12:29,020
of open-source community members and

00:12:23,640 --> 00:12:32,200
write about time with us about the same

00:12:29,020 --> 00:12:36,220
time with us we started looking at the

00:12:32,200 --> 00:12:39,280
vmi api present in Zen and look at ways

00:12:36,220 --> 00:12:42,520
of improving it adding more features or

00:12:39,280 --> 00:12:46,660
spinning speeding it up things like that

00:12:42,520 --> 00:12:50,640
in 2017 with the help of the community

00:12:46,660 --> 00:12:55,720
and Citrix we managed to build a

00:12:50,640 --> 00:12:59,650
commercial product using VMI with B

00:12:55,720 --> 00:13:05,080
defender h VI its using Citrix XenServer

00:12:59,650 --> 00:13:06,880
and after learning a lot from this

00:13:05,080 --> 00:13:09,400
experience we decided to move for

00:13:06,880 --> 00:13:14,620
further and

00:13:09,400 --> 00:13:16,000
add some like I said like the title

00:13:14,620 --> 00:13:23,050
presentation sets and commercial-grade

00:13:16,000 --> 00:13:29,680
vmi features to KPM so how do we exactly

00:13:23,050 --> 00:13:34,810
is VMI in the product of built well

00:13:29,680 --> 00:13:39,130
we're using EPT NPT to to secure it

00:13:34,810 --> 00:13:44,740
starts with securing the kernel we track

00:13:39,130 --> 00:13:50,200
the guests execution from the second

00:13:44,740 --> 00:13:52,690
zero the moment it starts and we figure

00:13:50,200 --> 00:13:56,550
out where it's been laid by the what has

00:13:52,690 --> 00:14:00,580
been placed by the bootloader we enforce

00:13:56,550 --> 00:14:02,410
permissions that are normally set up by

00:14:00,580 --> 00:14:04,480
the guest so for example by the guest

00:14:02,410 --> 00:14:08,410
kernel so for example the kernel will

00:14:04,480 --> 00:14:12,040
set its code as executable only and we

00:14:08,410 --> 00:14:14,890
enforce that an EPT and we expand that

00:14:12,040 --> 00:14:18,730
to obviously read write data read only

00:14:14,890 --> 00:14:20,530
stack heaps and things like that we

00:14:18,730 --> 00:14:22,570
secure important architectural

00:14:20,530 --> 00:14:25,150
structures like the interrupts described

00:14:22,570 --> 00:14:26,110
descriptor table global descriptor table

00:14:25,150 --> 00:14:30,360
and so on

00:14:26,110 --> 00:14:33,520
we monitor when every driver loads and

00:14:30,360 --> 00:14:36,060
secure its driver object driver object

00:14:33,520 --> 00:14:40,180
is basically a structure with pointers

00:14:36,060 --> 00:14:45,490
at indicating various routines inside

00:14:40,180 --> 00:14:48,460
the driver module we enforce certain

00:14:45,490 --> 00:14:51,100
hardware features like the supervisor

00:14:48,460 --> 00:14:55,060
mode execution prevention we make sure

00:14:51,100 --> 00:14:59,440
that whatever it's flipped by the guest

00:14:55,060 --> 00:15:02,830
know and the hypervisor it does so

00:14:59,440 --> 00:15:06,670
legitimately that's because we it is

00:15:02,830 --> 00:15:14,140
possible to build a system where you can

00:15:06,670 --> 00:15:17,200
determine the exact weights the exact

00:15:14,140 --> 00:15:23,890
source of the attempt to fit over these

00:15:17,200 --> 00:15:28,090
bits obviously SN s map we

00:15:23,890 --> 00:15:32,290
secure the kernel entry point which was

00:15:28,090 --> 00:15:36,370
essential as I said earlier earlier to

00:15:32,290 --> 00:15:38,260
stop eternal blue and once we've built

00:15:36,370 --> 00:15:40,180
this entire picture and secured all

00:15:38,260 --> 00:15:43,510
these components of the kernel we move

00:15:40,180 --> 00:15:59,350
further to the user space we identify

00:15:43,510 --> 00:16:00,670
every Windows and Linux I yeah I was

00:15:59,350 --> 00:16:03,760
afraid that the presentation might look

00:16:00,670 --> 00:16:10,930
a little biased towards Windows but it's

00:16:03,760 --> 00:16:16,000
a Windows and Linux that's a little less

00:16:10,930 --> 00:16:18,430
obvious how you find the application yes

00:16:16,000 --> 00:16:22,540
it starts with the kernel we identify

00:16:18,430 --> 00:16:25,030
every structured representing a task and

00:16:22,540 --> 00:16:31,200
from there we move to identifying every

00:16:25,030 --> 00:16:33,880
memory mapping essentially and as the

00:16:31,200 --> 00:16:35,860
application is created the structures

00:16:33,880 --> 00:16:37,750
the area mapping we track the

00:16:35,860 --> 00:16:42,100
permissions that guess kernel sets and

00:16:37,750 --> 00:16:46,450
then we enforce them in EPT so for

00:16:42,100 --> 00:16:48,400
example this stack of please I was gonna

00:16:46,450 --> 00:16:49,870
say if they're not a case where I say

00:16:48,400 --> 00:16:51,499
the kernel the application actually

00:16:49,870 --> 00:16:58,379
needs to write to some of these

00:16:51,499 --> 00:17:00,480
yes yes it is so as I've said I believe

00:16:58,379 --> 00:17:03,629
I said earlier we build an audit system

00:17:00,480 --> 00:17:07,260
we gather a bunch of such events rights

00:17:03,629 --> 00:17:10,470
in various areas then we pass them

00:17:07,260 --> 00:17:15,240
through a whitelist so some applications

00:17:10,470 --> 00:17:17,159
do do do these kind of things like

00:17:15,240 --> 00:17:20,339
patching themselves writing their code

00:17:17,159 --> 00:17:23,429
area were executing code on hip for

00:17:20,339 --> 00:17:26,250
whatever reason and yeah we use a

00:17:23,429 --> 00:17:36,120
whitelist to allow those two to work

00:17:26,250 --> 00:17:38,340
correctly for 40 vmi it's the people

00:17:36,120 --> 00:17:41,909
we're calling internal for KVM we

00:17:38,340 --> 00:17:44,519
haven't started working on the VM

00:17:41,909 --> 00:17:46,590
Librium my driver but we're working with

00:17:44,519 --> 00:17:50,100
another company also in the security

00:17:46,590 --> 00:17:54,559
space who is dependent on leave VMI and

00:17:50,100 --> 00:17:57,889
we we really want to help them out with

00:17:54,559 --> 00:17:57,889
creating a driver

00:18:02,660 --> 00:18:09,440
all right so I well I'll repeat a little

00:18:07,820 --> 00:18:12,770
bit what I just said

00:18:09,440 --> 00:18:15,130
so yeah after the kernel we moved to the

00:18:12,770 --> 00:18:21,980
applications and we apply the same

00:18:15,130 --> 00:18:24,740
provision enforcement logic we also one

00:18:21,980 --> 00:18:27,080
of those one of the things we do we

00:18:24,740 --> 00:18:29,060
prevent code injections those are pretty

00:18:27,080 --> 00:18:29,570
easy to do you either trap the SIS code

00:18:29,060 --> 00:18:31,430
that does that

00:18:29,570 --> 00:18:37,100
I believe on Windows is right process

00:18:31,430 --> 00:18:39,590
memory I forgot or you get that for free

00:18:37,100 --> 00:18:42,040
for simply marking the code as being non

00:18:39,590 --> 00:18:42,040
writable

00:18:51,580 --> 00:18:55,340
there are two ways that you can change

00:18:55,010 --> 00:18:57,910
today

00:18:55,340 --> 00:18:57,910
in the stock

00:18:58,980 --> 00:19:05,260
exactly you can you can trap for every

00:19:01,660 --> 00:19:08,500
MSR read but then you'll trap for every

00:19:05,260 --> 00:19:14,080
system call and the Cisco IP in Windows

00:19:08,500 --> 00:19:17,710
quite rich or you can add tiny patches

00:19:14,080 --> 00:19:21,070
like a breakpoint which is a single of

00:19:17,710 --> 00:19:22,240
code at the beginning of every well they

00:19:21,070 --> 00:19:27,160
have a slack space at the beginning of

00:19:22,240 --> 00:19:30,400
every system I also said that said that

00:19:27,160 --> 00:19:32,470
for specifically for specific use cases

00:19:30,400 --> 00:19:38,260
it is possible to do a bit of patching

00:19:32,470 --> 00:19:40,150
but these patches are the guests cannot

00:19:38,260 --> 00:19:44,160
tamper with them and I will explain

00:19:40,150 --> 00:19:44,160
later that is also possible to hide them

00:19:45,299 --> 00:19:56,230
right all right so we also monitored the

00:19:53,679 --> 00:20:00,760
export table for various modules and

00:19:56,230 --> 00:20:03,360
prevent hooking and the feature that

00:20:00,760 --> 00:20:06,010
comes natural whenever you see something

00:20:03,360 --> 00:20:10,179
unusual going on something that you can

00:20:06,010 --> 00:20:11,650
deem fairly reliably that is malicious

00:20:10,179 --> 00:20:13,929
you can terminate the application and

00:20:11,650 --> 00:20:15,970
there are very various way since you

00:20:13,929 --> 00:20:18,820
have write access to the guest you can

00:20:15,970 --> 00:20:22,330
just place junk that terminates the

00:20:18,820 --> 00:20:26,400
process or inject a an exception which

00:20:22,330 --> 00:20:26,400
also via mine makes it possible

00:20:26,840 --> 00:20:31,500
so when you do that how was that

00:20:29,610 --> 00:20:34,299
detective and audited like some app

00:20:31,500 --> 00:20:35,830
crashes for some series okay

00:20:34,299 --> 00:20:38,200
and it scratching every time to be

00:20:35,830 --> 00:20:40,119
inspected every time so if I was a

00:20:38,200 --> 00:20:43,690
minister that system how would I know

00:20:40,119 --> 00:20:46,570
that's malicious that so if it crashes

00:20:43,690 --> 00:20:50,009
as a result of something with it is in

00:20:46,570 --> 00:20:54,789
we crashed it specifically it usually

00:20:50,009 --> 00:20:56,849
the the the crash is triggered

00:20:54,789 --> 00:20:59,379
immediately after we've reported

00:20:56,849 --> 00:21:01,929
detailed information about an event for

00:20:59,379 --> 00:21:03,999
example an EPT violation we have

00:21:01,929 --> 00:21:05,769
detected that the code has been executed

00:21:03,999 --> 00:21:14,309
from the stack from this process at this

00:21:05,769 --> 00:21:17,169
time and the the way VMI works you can

00:21:14,309 --> 00:21:20,409
listen our case we track every process

00:21:17,169 --> 00:21:23,139
created in the system up to that point

00:21:20,409 --> 00:21:25,269
so you can build quite a chain until

00:21:23,139 --> 00:21:29,139
that application ended up executing the

00:21:25,269 --> 00:21:37,539
code and being terminated via by our

00:21:29,139 --> 00:21:42,749
solution so yeah but if if the

00:21:37,539 --> 00:21:47,049
application crashes due to and let's say

00:21:42,749 --> 00:21:50,049
an unintended effect of introspection it

00:21:47,049 --> 00:21:56,109
is possible to add specific exceptions

00:21:50,049 --> 00:22:00,519
for those cases because they also happen

00:21:56,109 --> 00:22:02,679
between before the the the VMI based

00:22:00,519 --> 00:22:05,079
application has seen something unusual

00:22:02,679 --> 00:22:09,940
and has taken an action that's not

00:22:05,079 --> 00:22:11,919
appropriate for that application okay

00:22:09,940 --> 00:22:14,859
this is the architecture we're

00:22:11,919 --> 00:22:18,009
envisioning it so on host several

00:22:14,859 --> 00:22:21,669
virtual machines running yes software

00:22:18,009 --> 00:22:26,820
one of them is specialized that is it

00:22:21,669 --> 00:22:29,829
has access to doing the mi4 on all other

00:22:26,820 --> 00:22:34,809
VMs target the ends physical as we call

00:22:29,829 --> 00:22:39,849
them the way we're working to create a

00:22:34,809 --> 00:22:43,859
VM API is to add the ability to have the

00:22:39,849 --> 00:22:45,639
security software run in user space

00:22:43,859 --> 00:22:48,059
completely deregulated

00:22:45,639 --> 00:22:50,650
maybe even put in a

00:22:48,059 --> 00:22:55,360
sandbox using cgroups

00:22:50,650 --> 00:23:01,420
and just do what it was what I was

00:22:55,360 --> 00:23:04,110
designed to do track the execution of

00:23:01,420 --> 00:23:04,110
the guest games

00:23:09,930 --> 00:23:17,740
alright so current status in KVM as I've

00:23:15,370 --> 00:23:22,090
mentioned earlier there is VMI support

00:23:17,740 --> 00:23:26,980
it can be done via queue EMU it I

00:23:22,090 --> 00:23:28,950
believe is queue monitor protocol there

00:23:26,980 --> 00:23:32,830
are also other open source projects

00:23:28,950 --> 00:23:37,559
nitro some of you I believe might have

00:23:32,830 --> 00:23:41,410
used the problem with these solutions

00:23:37,559 --> 00:23:43,690
some of these some of these either don't

00:23:41,410 --> 00:23:46,120
have support for generating events for

00:23:43,690 --> 00:23:48,790
register modifications so for example

00:23:46,120 --> 00:23:52,540
control registers I've mentioned CR for

00:23:48,790 --> 00:23:56,520
for x86 for certain model specific

00:23:52,540 --> 00:24:02,500
registers some of them have no control

00:23:56,520 --> 00:24:06,520
for adjusting the permissions for EPT or

00:24:02,500 --> 00:24:08,290
mp2 they were not designed for quick

00:24:06,520 --> 00:24:12,309
memory access they're very good at what

00:24:08,290 --> 00:24:14,910
they were initially created for but it's

00:24:12,309 --> 00:24:19,030
not usually fast guest memory access

00:24:14,910 --> 00:24:22,840
they're used mostly for analyzing

00:24:19,030 --> 00:24:29,020
malware post-mortem malware malicious

00:24:22,840 --> 00:24:31,870
code and in the case of qmp it relies on

00:24:29,020 --> 00:24:36,880
Q in when Q is a very complex software

00:24:31,870 --> 00:24:43,960
it does very good what it does but it

00:24:36,880 --> 00:24:49,990
comes natural to you know sometimes fall

00:24:43,960 --> 00:24:52,660
victim for some some tiny mishaps okay

00:24:49,990 --> 00:24:58,380
well if a couple of years ago the cd-rom

00:24:52,660 --> 00:24:58,380
emulator or floppy had a bit of a issue

00:24:59,610 --> 00:25:08,700
all right I will work on KVM for VMI

00:25:04,740 --> 00:25:13,090
where we have proposed an API that we've

00:25:08,700 --> 00:25:15,640
called KPM I've something like a nice

00:25:13,090 --> 00:25:18,910
trick we've initially posted a bunch of

00:25:15,640 --> 00:25:22,270
patches so okay this is one of what we

00:25:18,910 --> 00:25:24,630
want to do let's go get those in but no

00:25:22,270 --> 00:25:31,200
we got back to the drawing board with a

00:25:24,630 --> 00:25:31,200
specific API design this is a yes and

00:25:34,530 --> 00:25:44,860
die but really it's also a socket API

00:25:38,920 --> 00:25:53,560
between the kernel and so they'll get

00:25:44,860 --> 00:25:58,000
the socket and using yes over a second

00:25:53,560 --> 00:26:00,370
we're looking at V sock because it has a

00:25:58,000 --> 00:26:01,720
good performance but for testing or

00:26:00,370 --> 00:26:03,760
anything else

00:26:01,720 --> 00:26:06,820
Yanik sockets or pretty much anything

00:26:03,760 --> 00:26:09,490
should be usable I think there there was

00:26:06,820 --> 00:26:11,260
an idea of doing introspection nice I

00:26:09,490 --> 00:26:13,360
know you separate virtual machine

00:26:11,260 --> 00:26:15,610
running on a different host doing

00:26:13,360 --> 00:26:20,490
introspection for another host that's

00:26:15,610 --> 00:26:25,690
quite possible alright so we worked on

00:26:20,490 --> 00:26:28,830
on a design of a of an API that's to be

00:26:25,690 --> 00:26:32,350
used from user by user applications

00:26:28,830 --> 00:26:38,610
we're currently concentrating on a sixth

00:26:32,350 --> 00:26:43,300
x86 inadvertently in tow specifically

00:26:38,610 --> 00:26:50,260
I'm still waiting for some AMD arm is

00:26:43,300 --> 00:26:52,120
the next obvious target in the basic

00:26:50,260 --> 00:26:55,990
functionality we're looking to add and

00:26:52,120 --> 00:26:59,050
it's we've worked with Apollo quite a

00:26:55,990 --> 00:27:00,450
bit to minimize everything we minimize

00:26:59,050 --> 00:27:03,390
the

00:27:00,450 --> 00:27:06,960
the amount of kernel we expose to

00:27:03,390 --> 00:27:09,020
obviously reduce the attack surface so

00:27:06,960 --> 00:27:13,800
basic guest information getting

00:27:09,020 --> 00:27:16,410
infinitely number of V CPUs the TSC

00:27:13,800 --> 00:27:20,010
frequency which is used for simple

00:27:16,410 --> 00:27:23,370
performance monitoring the ability to

00:27:20,010 --> 00:27:26,160
pause and pause disappears it's quite

00:27:23,370 --> 00:27:29,490
obvious you get to post them all you get

00:27:26,160 --> 00:27:37,250
a guest full guest pause get set

00:27:29,490 --> 00:27:42,500
registers for the general register set

00:27:37,250 --> 00:27:46,560
cpuid access as the guest sees it okay

00:27:42,500 --> 00:27:49,710
I've said I've mentioned earlier the

00:27:46,560 --> 00:27:52,680
ability to control the permissions in

00:27:49,710 --> 00:27:56,270
EPT the ability to inject except

00:27:52,680 --> 00:27:59,010
exceptions one of these exceptions are

00:27:56,270 --> 00:28:01,170
the page fault exception we use it to

00:27:59,010 --> 00:28:07,170
determine the determined guest Colonel

00:28:01,170 --> 00:28:11,690
to page in code we want to look at read

00:28:07,170 --> 00:28:16,940
write either by having specific calls

00:28:11,690 --> 00:28:16,940
named read and write or by using mapping

00:28:18,260 --> 00:28:25,680
we have no consensus on that but working

00:28:22,970 --> 00:28:29,040
we're looking at having the security

00:28:25,680 --> 00:28:33,830
virtual appliance share pages with the

00:28:29,040 --> 00:28:33,830
target guest readwrite

00:28:38,330 --> 00:28:42,750
VMI can be quite verbose so once you

00:28:41,010 --> 00:28:46,490
enable all these features it can

00:28:42,750 --> 00:28:50,220
generate a ton of events so now and

00:28:46,490 --> 00:28:55,710
currently VM exits on x86 are not really

00:28:50,220 --> 00:28:59,670
cheap the CPU goes try to goes to quite

00:28:55,710 --> 00:29:01,220
some loops and hoops to do that so the

00:28:59,670 --> 00:29:05,190
ability to filter these events

00:29:01,220 --> 00:29:09,480
enable/disable them as as as you need

00:29:05,190 --> 00:29:11,370
them for everything control users and

00:29:09,480 --> 00:29:14,460
the source page faults and so on

00:29:11,370 --> 00:29:17,130
actually for page faults

00:29:14,460 --> 00:29:21,390
quite a neat optimization that we're

00:29:17,130 --> 00:29:24,480
looking to add the way

00:29:21,390 --> 00:29:26,940
EPT works with guest page tables they

00:29:24,480 --> 00:29:29,670
generate a large number of events for

00:29:26,940 --> 00:29:32,880
things that a VMI application is not

00:29:29,670 --> 00:29:36,750
normally interested in like 80 bits

00:29:32,880 --> 00:29:40,590
whenever the guest V CPU works the table

00:29:36,750 --> 00:29:43,080
it adjusts and bits for internal kernel

00:29:40,590 --> 00:29:51,020
bookkeeping but usually BMI based

00:29:43,080 --> 00:29:51,020
applications are not interested yes

00:30:06,910 --> 00:30:13,040
just repair okay how do you visit VMI

00:30:10,280 --> 00:30:25,790
working with a guest having 200 and

00:30:13,040 --> 00:30:29,120
something VC to use no actually it's

00:30:25,790 --> 00:30:32,540
quite easy so we get here to the notion

00:30:29,120 --> 00:30:37,220
of of performance so I should probably

00:30:32,540 --> 00:30:42,950
say that a finely tuned VMI security

00:30:37,220 --> 00:30:46,190
solution can can achieve quite excellent

00:30:42,950 --> 00:30:49,570
performance like 1 2 percent for normal

00:30:46,190 --> 00:30:54,700
user applications and in very very

00:30:49,570 --> 00:30:59,540
special cases go above 10 so for example

00:30:54,700 --> 00:31:01,550
surprisingly enough databases once you

00:30:59,540 --> 00:31:08,960
secure them in memory they trigger very

00:31:01,550 --> 00:31:13,700
little events so for 4 VMs with many V

00:31:08,960 --> 00:31:17,840
CPUs it's critical to to monitor exactly

00:31:13,700 --> 00:31:22,250
what you need so if you enable if you

00:31:17,840 --> 00:31:24,650
set apt protections on let's say rate

00:31:22,250 --> 00:31:26,990
write data that helps you in no way when

00:31:24,650 --> 00:31:29,270
it's get when it gets written you're

00:31:26,990 --> 00:31:31,640
setting yourself failure so you really

00:31:29,270 --> 00:31:34,880
no one really needs to study the

00:31:31,640 --> 00:31:36,330
application the guest OS that it's money

00:31:34,880 --> 00:31:39,389
time

00:31:36,330 --> 00:31:46,889
and what a performance it at noontime at

00:31:39,389 --> 00:31:52,139
boot time I don't think it's measurable

00:31:46,889 --> 00:31:53,820
in any significant way so how do you

00:31:52,139 --> 00:31:57,180
control access to the KB in my

00:31:53,820 --> 00:32:00,730
instruction if anybody gets displayed

00:31:57,180 --> 00:32:04,300
all right that's a way exactly

00:32:00,730 --> 00:32:08,710
well we how do we control it access to

00:32:04,300 --> 00:32:12,760
VMI all right we get here into a

00:32:08,710 --> 00:32:15,480
separate field of at the station of for

00:32:12,760 --> 00:32:19,840
that specifically ritual machine of

00:32:15,480 --> 00:32:24,370
isolating it on in the network

00:32:19,840 --> 00:32:27,310
infrastructure of the administrator I've

00:32:24,370 --> 00:32:29,890
mentioned sandboxing and there are many

00:32:27,310 --> 00:32:32,860
other ways but essentially your yours

00:32:29,890 --> 00:32:37,540
safe as the architecture permits it and

00:32:32,860 --> 00:32:40,020
the hypervisor on which you rely to to

00:32:37,540 --> 00:32:40,020
do VMI

00:32:51,820 --> 00:32:58,970
because you know the line oh yeah vibes

00:32:54,530 --> 00:33:02,300
are very short right yeah we've done

00:32:58,970 --> 00:33:04,580
tests with dope tests with doaker and it

00:33:02,300 --> 00:33:06,500
works naturally because docker uses

00:33:04,580 --> 00:33:09,170
cgroups which doesn't really present

00:33:06,500 --> 00:33:10,760
themselves in any way special to someone

00:33:09,170 --> 00:33:12,830
looking from the outside they're just

00:33:10,760 --> 00:33:15,130
normal tasks but for the guest Colonel

00:33:12,830 --> 00:33:20,740
they're just in a separate namespace so

00:33:15,130 --> 00:33:24,940
container technologies that rely on

00:33:20,740 --> 00:33:39,230
Linux see groups that those are easy to

00:33:24,940 --> 00:33:42,340
secure this should be also useful for we

00:33:39,230 --> 00:33:42,340
have technology to run

00:33:44,250 --> 00:33:56,520
so I think we get so using this

00:33:51,510 --> 00:33:58,679
technology for bare-metal Colonel that'd

00:33:56,520 --> 00:34:00,330
be great and I believe my colleague

00:33:58,679 --> 00:34:03,390
underrated such in the back would like

00:34:00,330 --> 00:34:09,629
her to know more about that unless he

00:34:03,390 --> 00:34:14,399
already knows and never told me please I

00:34:09,629 --> 00:34:18,260
might take everybody no way all right

00:34:14,399 --> 00:34:18,260
sorry yeah

00:34:30,700 --> 00:34:40,460
to add to this that's right maybe you

00:34:35,750 --> 00:34:47,740
should go a little bit on on the setup

00:34:40,460 --> 00:34:47,740
and how the mind mapping software

00:34:47,860 --> 00:34:58,400
you didn't go very much maybe you can I

00:34:51,650 --> 00:35:03,110
gotta mines created the discussion okay

00:34:58,400 --> 00:35:05,630
so the question is how does the VMI

00:35:03,110 --> 00:35:09,140
start and what's the involvement of qmo

00:35:05,630 --> 00:35:13,810
in the entire process q is Dean the one

00:35:09,140 --> 00:35:19,280
initially starting the VMI process it

00:35:13,810 --> 00:35:21,460
the way we we design it is to have a lip

00:35:19,280 --> 00:35:25,460
vert to have an option the elaborate

00:35:21,460 --> 00:35:29,240
that's passed to chemo and chemo makes a

00:35:25,460 --> 00:35:30,800
simple let's say TCP connection to the

00:35:29,240 --> 00:35:34,010
security application the application

00:35:30,800 --> 00:35:37,510
using VMI they do some kind of mutual

00:35:34,010 --> 00:35:40,490
authentication and after that after

00:35:37,510 --> 00:35:43,120
they're both confident that they're

00:35:40,490 --> 00:35:47,150
talking with you it only should the

00:35:43,120 --> 00:35:50,150
chemo passes the socket to using an eye

00:35:47,150 --> 00:35:52,730
octal passes it to the colonel and from

00:35:50,150 --> 00:35:55,760
that point on the communication takes

00:35:52,730 --> 00:35:58,900
place only between the VMI application

00:35:55,760 --> 00:35:58,900
and the colonel

00:36:00,480 --> 00:36:05,570
he was

00:36:07,730 --> 00:36:12,410
right now we're multiplexing everything

00:36:09,680 --> 00:36:14,380
on a single circuit using we were

00:36:12,410 --> 00:36:17,210
thinking of using a control circuit and

00:36:14,380 --> 00:36:21,740
various circuits for events for every V

00:36:17,210 --> 00:36:25,520
CPU that's the neat thing is that using

00:36:21,740 --> 00:36:28,730
sockets you can go pretty wild we had

00:36:25,520 --> 00:36:31,550
more more of a hard time

00:36:28,730 --> 00:36:35,830
taming KPM with what we want to do in

00:36:31,550 --> 00:36:35,830
terms of memory management interference

00:36:36,790 --> 00:36:44,090
okay I don't know who you need C debug

00:36:41,750 --> 00:36:45,740
symbols from the kernel and these space

00:36:44,090 --> 00:36:50,750
applications or is it done here

00:36:45,740 --> 00:36:56,030
especially initial support for 40 guest

00:36:50,750 --> 00:37:01,190
OS we don't really need debug symbols

00:36:56,030 --> 00:37:04,550
but we do need to do some some

00:37:01,190 --> 00:37:06,800
investigations about how it works

00:37:04,550 --> 00:37:09,400
for example locating of in case of

00:37:06,800 --> 00:37:12,860
Windows determining the layout of

00:37:09,400 --> 00:37:14,990
various structures and trade structures

00:37:12,860 --> 00:37:16,790
tasks structures those are some

00:37:14,990 --> 00:37:18,530
information about these I don't think

00:37:16,790 --> 00:37:21,130
they're published by Microsoft but

00:37:18,530 --> 00:37:21,130
they're available from

00:37:24,120 --> 00:37:28,080
so basically what

00:37:30,510 --> 00:37:39,400
so III just so I don't provide

00:37:35,740 --> 00:37:42,490
misinformation the the exact analysis

00:37:39,400 --> 00:37:46,870
the guests support is created by Andres

00:37:42,490 --> 00:37:52,950
team so if you want to know more about

00:37:46,870 --> 00:37:52,950
that I can invited him in front actually

00:37:53,610 --> 00:37:57,180
the article

00:37:59,200 --> 00:38:05,050
a semantic gap yes have the semantics

00:38:02,470 --> 00:38:08,830
after you need actually know the

00:38:05,050 --> 00:38:12,710
structure layout yes you need to have if

00:38:08,830 --> 00:38:14,930
it's windows actually windows

00:38:12,710 --> 00:38:18,230
be positive it will be the server that

00:38:14,930 --> 00:38:21,460
you can download and that you can also

00:38:18,230 --> 00:38:21,460
can use from recall

00:38:22,780 --> 00:38:28,180
there is a little problem because

00:38:24,730 --> 00:38:30,280
everyone in this internal and

00:38:28,180 --> 00:38:37,720
configuring differently typical the

00:38:30,280 --> 00:38:42,540
structure changes with speed lock Diwali

00:38:37,720 --> 00:38:42,540
all the structure change dramatically

00:38:44,550 --> 00:38:49,540
so this quality of the Linux kernel

00:38:47,500 --> 00:38:51,700
being highly configurable kind of stands

00:38:49,540 --> 00:38:53,890
in the way so with focusing of

00:38:51,700 --> 00:39:00,840
entrepreneurial Enterprise distributions

00:38:53,890 --> 00:39:02,890
like Red Hat we have suze Ubuntu server

00:39:00,840 --> 00:39:07,830
we're trying to keep the scope under

00:39:02,890 --> 00:39:11,320
control otherwise it can get very hairy

00:39:07,830 --> 00:39:14,620
the gentleman was sorry so the the

00:39:11,320 --> 00:39:16,030
ability to inspect modified big-ass

00:39:14,620 --> 00:39:19,050
classic knowledge is obviously very

00:39:16,030 --> 00:39:21,940
useful you have to guess who we see

00:39:19,050 --> 00:39:24,420
exports of malware or to a high price

00:39:21,940 --> 00:39:24,420
level

00:39:25,330 --> 00:39:35,300
if they get access to a VM I like

00:39:28,870 --> 00:39:42,950
capability the actually the architecture

00:39:35,300 --> 00:39:46,750
makes it possible what it's brand-new

00:39:42,950 --> 00:39:46,750
ACI so no it's secure

00:40:05,240 --> 00:40:12,740
I don't believe we we take input and

00:40:09,830 --> 00:40:13,400
process it inside the introspection

00:40:12,740 --> 00:40:17,210
technology

00:40:13,400 --> 00:40:23,180
I know if undry would like to add

00:40:17,210 --> 00:40:27,320
something about that essentially yeah we

00:40:23,180 --> 00:40:30,410
stay away from using the user guest OS

00:40:27,320 --> 00:40:35,810
that as input for us we just try to look

00:40:30,410 --> 00:40:37,760
at the CPU state what try to what's

00:40:35,810 --> 00:40:42,130
trying to do and from where it started

00:40:37,760 --> 00:40:42,130
whatever it was attempting

00:40:45,959 --> 00:40:49,709
I think randomization is for these so

00:40:48,329 --> 00:40:51,179
how do you deal with that because if the

00:40:49,709 --> 00:40:55,199
test works is that going to do the wrong

00:40:51,179 --> 00:40:57,929
and you don't know whether so how do we

00:40:55,199 --> 00:41:00,089
deal with address based randomization it

00:40:57,929 --> 00:41:01,949
all starts with the MSR indicating the

00:41:00,089 --> 00:41:11,400
kernel entry point and once you find

00:41:01,949 --> 00:41:14,609
those and patch it and at specific parts

00:41:11,400 --> 00:41:16,469
of it to determine when it when it loads

00:41:14,609 --> 00:41:20,989
and where it loads you can figure out

00:41:16,469 --> 00:41:25,529
every other every other component I

00:41:20,989 --> 00:41:27,739
think I think that it is possible that

00:41:25,529 --> 00:41:29,999
once you figure out the kernel layout

00:41:27,739 --> 00:41:32,579
for example you start via mind while the

00:41:29,999 --> 00:41:38,359
guest is already started I think certain

00:41:32,579 --> 00:41:41,219
information is located in his in a

00:41:38,359 --> 00:41:45,299
specific areas that can be determined by

00:41:41,219 --> 00:41:46,739
looking at the V CPUs I again I'm not

00:41:45,299 --> 00:41:49,679
even really involved in the

00:41:46,739 --> 00:41:54,259
introspection technology per se I just

00:41:49,679 --> 00:41:54,259
try to bridge it oh it would kayvyun

00:41:55,249 --> 00:41:58,249
please

00:41:59,840 --> 00:42:05,620
yes we both yes memory

00:42:08,939 --> 00:42:16,890
we're looking very hard at SGX and SCV I

00:42:14,249 --> 00:42:19,289
don't know what the research team has

00:42:16,890 --> 00:42:23,289
[Music]

00:42:19,289 --> 00:42:25,719
plans to do in the future but yeah we

00:42:23,289 --> 00:42:27,939
have I'm not aware of a specific plan

00:42:25,719 --> 00:42:40,779
with that we're just getting tell you

00:42:27,939 --> 00:42:44,079
that this Jake's can't run os-level

00:42:40,779 --> 00:42:46,419
can't run a print zero specifically via

00:42:44,079 --> 00:42:48,849
Twitter sorry these virtual memory

00:42:46,419 --> 00:42:50,229
encryption yeah no I was just

00:42:48,849 --> 00:42:57,209
referencing the technologies that

00:42:50,229 --> 00:42:57,209
encrypt yes

00:42:59,880 --> 00:43:04,279
is there a specification for the pain

00:43:05,650 --> 00:43:13,490
yeah the the document that lays out the

00:43:09,470 --> 00:43:16,100
API as we revisit right now is has been

00:43:13,490 --> 00:43:17,840
published on the KVR mailing list we are

00:43:16,100 --> 00:43:21,320
going to follow up with a little bit

00:43:17,840 --> 00:43:22,520
with some adjustments that we've made as

00:43:21,320 --> 00:43:24,730
we were working on the actual

00:43:22,520 --> 00:43:24,730
implementation

00:43:32,040 --> 00:43:36,610
all right

00:43:33,960 --> 00:43:42,469
[Applause]

00:43:36,610 --> 00:43:42,469

YouTube URL: https://www.youtube.com/watch?v=sUPSogabV-o


