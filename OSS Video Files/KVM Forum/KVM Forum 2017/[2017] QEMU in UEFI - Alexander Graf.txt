Title: [2017] QEMU in UEFI - Alexander Graf
Publication date: 2017-11-13
Playlist: KVM Forum 2017
Description: 
	UEFI is a firmware specification created by Intel with portability in mind. The UEFI way of doing that was to provide special UEFI byte code (EBC). Unfortunately nobody really cared so compiler, firmware support and providers of EBC option roms ceased and basically every UEFI option rom today contains native x86(_64) machine code. If you now want to plug a PCIe card into your shiny ARM server, that means even though firmware would be compatible it still can't execute the option rom. Until you add QEMU to the mix. Join me in exploring the depth of UEFI binary interfaces, marshalling between different architecture's function call ABIs on the fly and learn how to integrate all of this into a working firmware, running on real hardware, driving a real PCIe adapter.

---

Alexander Graf
SUSE
KVM Wizard
NÃ¼rnberg Area, Germany

Alexander started working for SUSE about 9 years ago. Since then he worked on fancy things like SUSE Studio, QEMU, KVM and openSUSE on ARM. Whenever something really useful comes to his mind, he tends to implement it. Among others he did Mac OS X virtualization using KVM, nested SVM, KVM on PowerPC and a lot of work in QEMU for openSUSE on ARM. He is the upstream maintainer of KVM for PowerPC, QEMU for PowerPC and QEMU for S390x.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:05,930 --> 00:00:12,960
good afternoon and welcome back from

00:00:08,189 --> 00:00:19,830
lunch everyone welcome to my amazing

00:00:12,960 --> 00:00:21,480
talk about joining qmu in UEFI so first

00:00:19,830 --> 00:00:25,019
about me if you haven't seen me or heard

00:00:21,480 --> 00:00:27,449
of me or know me I'm Alex graph I've

00:00:25,019 --> 00:00:31,019
done things like the PowerPC serve a

00:00:27,449 --> 00:00:33,000
PowerPC KVM board or what was an active

00:00:31,019 --> 00:00:35,100
maintainer for qmu there as well

00:00:33,000 --> 00:00:37,280
I did the nested spi meditation I've

00:00:35,100 --> 00:00:40,020
spent a lot of the last couple of years

00:00:37,280 --> 00:00:42,000
trying to push user to pursue the arm

00:00:40,020 --> 00:00:45,000
server market which were finally

00:00:42,000 --> 00:00:49,590
entering or have ended so this it's

00:00:45,000 --> 00:00:51,660
basically done and as part of that one

00:00:49,590 --> 00:00:53,789
thing I did was you boot UEFI support so

00:00:51,660 --> 00:00:56,579
you can run UEFI binaries inside of you

00:00:53,789 --> 00:00:58,770
boot so that your embedded environment

00:00:56,579 --> 00:01:01,050
starts to look more like something that

00:00:58,770 --> 00:01:03,270
you actually want to run on that's a

00:01:01,050 --> 00:01:05,519
complete different story it just means

00:01:03,270 --> 00:01:07,110
that because of that I hadn't rough idea

00:01:05,519 --> 00:01:08,580
on how you if I works and this

00:01:07,110 --> 00:01:13,320
presentation is going to show you some

00:01:08,580 --> 00:01:15,979
of that as well so the initial problem

00:01:13,320 --> 00:01:19,890
that we faced was about half a year ago

00:01:15,979 --> 00:01:21,360
I was Adenauer Connect and at one of

00:01:19,890 --> 00:01:24,090
those Enterprise steering committee

00:01:21,360 --> 00:01:28,490
meetings and one of those member company

00:01:24,090 --> 00:01:33,420
said well if you buy an arm server and

00:01:28,490 --> 00:01:35,189
you plug in a PCI card into that that

00:01:33,420 --> 00:01:37,530
PCI card does not work properly on

00:01:35,189 --> 00:01:39,030
Buddha because what happens is that if

00:01:37,530 --> 00:01:41,130
you take the piece I cut on an x86

00:01:39,030 --> 00:01:42,960
system you will actually see that

00:01:41,130 --> 00:01:44,340
getting used by farmers in this case it

00:01:42,960 --> 00:01:46,799
actually shows you something on the

00:01:44,340 --> 00:01:48,750
screen if it's a graphics card but on an

00:01:46,799 --> 00:01:50,310
arm server you just don't see anything

00:01:48,750 --> 00:01:52,200
that pays PCI card basically is

00:01:50,310 --> 00:01:55,829
unsupported by firmware and the reason

00:01:52,200 --> 00:02:00,180
that is is that the ROM that contains

00:01:55,829 --> 00:02:03,210
the driver for that card is on the card

00:02:00,180 --> 00:02:06,420
itself so PCI cards have a small rum in

00:02:03,210 --> 00:02:08,640
it that or flash from these days that

00:02:06,420 --> 00:02:10,050
contains a driver usually a UEFI driver

00:02:08,640 --> 00:02:13,040
these days

00:02:10,050 --> 00:02:16,470
to actually leverage that adapter from

00:02:13,040 --> 00:02:17,850
from the film we're but because x86 code

00:02:16,470 --> 00:02:24,510
we can't just run it on arm

00:02:17,850 --> 00:02:25,980
can we so let's take a live in a look at

00:02:24,510 --> 00:02:27,660
what the difference really is between

00:02:25,980 --> 00:02:29,370
this arm and this exit is six things so

00:02:27,660 --> 00:02:31,410
every time I talk about arm or actually

00:02:29,370 --> 00:02:33,360
six in this context I only talk about

00:02:31,410 --> 00:02:36,450
64-bit variants I don't talk about

00:02:33,360 --> 00:02:40,530
32-bit ones because they're odd and

00:02:36,450 --> 00:02:41,700
different but the 64-bit variants

00:02:40,530 --> 00:02:43,230
basically one of the big differences

00:02:41,700 --> 00:02:45,330
between different architectures as to

00:02:43,230 --> 00:02:47,430
the register set so arm on arm you have

00:02:45,330 --> 00:02:51,780
about 32 different registers it's more

00:02:47,430 --> 00:02:53,280
like 31 - 31 out of registers they're on

00:02:51,780 --> 00:02:55,260
x86 you have different registers that

00:02:53,280 --> 00:02:57,870
are named differently that have

00:02:55,260 --> 00:03:00,350
sometimes special semantics attached to

00:02:57,870 --> 00:03:04,950
them and obviously a much smaller number

00:03:00,350 --> 00:03:06,240
then on a HD forum on palm you don't

00:03:04,950 --> 00:03:08,280
need to actually remember all the

00:03:06,240 --> 00:03:10,170
details there but keep in mind that this

00:03:08,280 --> 00:03:13,650
is one one major difference so what if

00:03:10,170 --> 00:03:16,320
we want to move some values from a

00:03:13,650 --> 00:03:17,880
register to another register based on

00:03:16,320 --> 00:03:19,380
arm we just want to move something from

00:03:17,880 --> 00:03:23,190
wedge to zero to register one in the

00:03:19,380 --> 00:03:27,600
next is six from register rx 2 px no a

00:03:23,190 --> 00:03:31,110
to be really and 64-bit with what you do

00:03:27,600 --> 00:03:34,200
is you usually issue an instruction to

00:03:31,110 --> 00:03:36,450
the CPU to save CPU please move data

00:03:34,200 --> 00:03:40,500
from this register to the other register

00:03:36,450 --> 00:03:42,030
and while the assembly of that looks

00:03:40,500 --> 00:03:43,440
pretty similar between the different

00:03:42,030 --> 00:03:46,230
architectures that's really just a human

00:03:43,440 --> 00:03:48,750
readable form of or the CPU eats the CPU

00:03:46,230 --> 00:03:50,580
reads up codes which are these hex

00:03:48,750 --> 00:03:52,620
values down there and you can probably

00:03:50,580 --> 00:03:55,800
tell at the glimpse already that they're

00:03:52,620 --> 00:03:57,600
pretty incompatible all right running

00:03:55,800 --> 00:04:00,300
one of them on the other just simply

00:03:57,600 --> 00:04:02,130
doesn't work and making one of them work

00:04:00,300 --> 00:04:03,840
on the other that's exactly what QM

00:04:02,130 --> 00:04:06,090
users I mean I'm pretty sure that almost

00:04:03,840 --> 00:04:09,390
everybody of you guys knows that I want

00:04:06,090 --> 00:04:12,030
to make sure we're on the same page so

00:04:09,390 --> 00:04:14,250
what does Q mu Q mu gives you has

00:04:12,030 --> 00:04:16,650
different modes of emulation the usual

00:04:14,250 --> 00:04:18,270
mode of emulation that most people here

00:04:16,650 --> 00:04:20,970
are familiar with because we had KVM

00:04:18,270 --> 00:04:22,620
form is full system emulation in full

00:04:20,970 --> 00:04:23,350
system emulation what you have is you

00:04:22,620 --> 00:04:26,230
have a machine

00:04:23,350 --> 00:04:28,660
in a full system and qmu is responsible

00:04:26,230 --> 00:04:32,290
for emulating every single part of that

00:04:28,660 --> 00:04:35,770
whole system so it emulates hardware the

00:04:32,290 --> 00:04:37,780
operating system and your applications

00:04:35,770 --> 00:04:39,990
running inside so every single part of

00:04:37,780 --> 00:04:42,520
that hole and that whole stack is

00:04:39,990 --> 00:04:46,810
emulated and is completely handled and

00:04:42,520 --> 00:04:48,790
translated by qmu if you do KVM you

00:04:46,810 --> 00:04:50,500
basically just take a small piece which

00:04:48,790 --> 00:04:52,420
is the CPU down here and just plummet

00:04:50,500 --> 00:04:53,650
that through to actual hardware but the

00:04:52,420 --> 00:04:55,360
concept is still the same you basically

00:04:53,650 --> 00:04:59,170
have this envelope of qmu around

00:04:55,360 --> 00:04:59,830
everything ii moated has which is

00:04:59,170 --> 00:05:03,400
lesser-known

00:04:59,830 --> 00:05:06,130
is Linux user so in Linux user mode what

00:05:03,400 --> 00:05:08,920
you have is qmu only emulates the

00:05:06,130 --> 00:05:11,490
application layer and uses the boundary

00:05:08,920 --> 00:05:14,500
between application and the kernel as a

00:05:11,490 --> 00:05:18,550
boundary where it can hook itself into

00:05:14,500 --> 00:05:22,180
and then basically convert data

00:05:18,550 --> 00:05:23,710
structures from one to the other to from

00:05:22,180 --> 00:05:25,630
one architecture to the other basically

00:05:23,710 --> 00:05:28,960
from the semantics of one architecture

00:05:25,630 --> 00:05:33,390
the other to have a application for arm

00:05:28,960 --> 00:05:33,390
for example one on an x86 Linux kernel

00:05:33,900 --> 00:05:38,860
but you if I is your firmware right and

00:05:37,210 --> 00:05:41,470
what your film where does is essentially

00:05:38,860 --> 00:05:44,260
the same thing a kernel does and has

00:05:41,470 --> 00:05:50,500
anybody ever seen applications running

00:05:44,260 --> 00:05:53,770
on you if I with an actual boundary down

00:05:50,500 --> 00:05:57,520
there no right that's no boundary we'll

00:05:53,770 --> 00:05:59,800
get to that so what is you if I so you

00:05:57,520 --> 00:06:01,750
if I if you have a system normal PC

00:05:59,800 --> 00:06:02,920
anything you buy these days that is that

00:06:01,750 --> 00:06:07,060
roughly it looks like a server and

00:06:02,920 --> 00:06:09,400
doesn't come from IBM you will want to

00:06:07,060 --> 00:06:11,110
well you want to have that on you IBM -

00:06:09,400 --> 00:06:13,810
you just don't have the UEFI part in it

00:06:11,110 --> 00:06:15,340
you want to be able to access devices to

00:06:13,810 --> 00:06:16,900
boot from for example you want to boot

00:06:15,340 --> 00:06:18,820
from your disk you want to boot from

00:06:16,900 --> 00:06:20,020
well that's supposed to be networked

00:06:18,820 --> 00:06:24,040
hard even through those graphics

00:06:20,020 --> 00:06:26,260
connectors you want to be able to access

00:06:24,040 --> 00:06:27,820
the the network you want to be able to

00:06:26,260 --> 00:06:28,480
access a cd-rom so if you want to be

00:06:27,820 --> 00:06:29,860
able to boot

00:06:28,480 --> 00:06:33,010
obviously also want to be able to

00:06:29,860 --> 00:06:36,410
display things so each of those pieces

00:06:33,010 --> 00:06:40,430
has a driver attached to them

00:06:36,410 --> 00:06:43,160
and all of these drivers basically talk

00:06:40,430 --> 00:06:45,290
to the UEFI driver core and are able to

00:06:43,160 --> 00:06:47,090
communicate to each other randomly so

00:06:45,290 --> 00:06:48,920
any random driver can talk to any other

00:06:47,090 --> 00:06:50,180
random driver inside of UEFI and

00:06:48,920 --> 00:06:53,660
everything once in a single address

00:06:50,180 --> 00:06:55,880
space the way you can then run

00:06:53,660 --> 00:06:57,950
applications is that things like go up

00:06:55,880 --> 00:07:00,020
get loaded from the disk and then go up

00:06:57,950 --> 00:07:03,830
establishes a communication channel to a

00:07:00,020 --> 00:07:06,110
driver to then reload more data from a

00:07:03,830 --> 00:07:08,690
disk to then interpret that and for

00:07:06,110 --> 00:07:10,310
example one load Linux boot Linux and

00:07:08,690 --> 00:07:12,320
Linux throws away all of that stuff and

00:07:10,310 --> 00:07:15,140
establishes its own special one-time

00:07:12,320 --> 00:07:19,000
communication channel that's just you we

00:07:15,140 --> 00:07:23,090
find in nutshell two-minute walk through

00:07:19,000 --> 00:07:27,560
now let's dive into what UEFI actually

00:07:23,090 --> 00:07:31,010
does under the hood so this driver what

00:07:27,560 --> 00:07:33,170
does this driver do when you load up a

00:07:31,010 --> 00:07:37,010
driver and the system initializes at

00:07:33,170 --> 00:07:40,040
first the driver goes in and registers

00:07:37,010 --> 00:07:44,150
itself with that UEFI core so it just

00:07:40,040 --> 00:07:46,070
calls a function on a callback pointer

00:07:44,150 --> 00:07:47,360
which is the pattern throughout all of

00:07:46,070 --> 00:07:51,170
you if I everything's an indirect

00:07:47,360 --> 00:07:53,720
function call you call that function to

00:07:51,170 --> 00:07:55,940
register look I'm a new driver I'm a new

00:07:53,720 --> 00:07:57,980
in the system and that thing really just

00:07:55,940 --> 00:08:00,590
only gets a struct which then again has

00:07:57,980 --> 00:08:02,090
lots of fields some of them are function

00:08:00,590 --> 00:08:05,180
pointers some of them are data

00:08:02,090 --> 00:08:07,970
structures with arbitrary data so in

00:08:05,180 --> 00:08:10,430
this case you just say well this is it

00:08:07,970 --> 00:08:12,140
has this this driver just says I'm a new

00:08:10,430 --> 00:08:14,600
driver and I can either tell you whether

00:08:12,140 --> 00:08:17,390
I'm supported on a special new device or

00:08:14,600 --> 00:08:20,570
imes I can start I can stop on it so

00:08:17,390 --> 00:08:24,080
that when then another driver core

00:08:20,570 --> 00:08:25,970
inside the systems like the PCI driver

00:08:24,080 --> 00:08:28,280
call for example goes and finds a new

00:08:25,970 --> 00:08:31,220
PCI device it can accentuate a new pci

00:08:28,280 --> 00:08:33,110
object which then again can probe all

00:08:31,220 --> 00:08:35,330
drivers in the system to see whether

00:08:33,110 --> 00:08:39,500
they are actually compatible with that

00:08:35,330 --> 00:08:42,080
new card and if they are instantiate

00:08:39,500 --> 00:08:47,150
that driver on sir on top of that object

00:08:42,080 --> 00:08:48,410
make sense all right one thing you see

00:08:47,150 --> 00:08:50,980
here is that everything really is

00:08:48,410 --> 00:08:50,980
governed by

00:08:51,240 --> 00:08:55,960
that's the one point everything really

00:08:53,710 --> 00:08:57,640
is governed by this structure and

00:08:55,960 --> 00:08:59,740
function pointers going left and right

00:08:57,640 --> 00:09:02,050
and pointers getting passed everywhere

00:08:59,740 --> 00:09:04,210
it's all a single address base you don't

00:09:02,050 --> 00:09:10,180
have sis calls even if anything off the

00:09:04,210 --> 00:09:11,080
likes later on when oh yeah the starting

00:09:10,180 --> 00:09:13,630
happens on the driver

00:09:11,080 --> 00:09:16,420
they don't unring the driver is then

00:09:13,630 --> 00:09:23,440
properly installed and you want to read

00:09:16,420 --> 00:09:24,580
data all you need to do is all you need

00:09:23,440 --> 00:09:26,680
to do is from your gut education

00:09:24,580 --> 00:09:28,480
basically get the call back to that

00:09:26,680 --> 00:09:30,660
device that wasn't one of animation

00:09:28,480 --> 00:09:33,310
information too much one get the

00:09:30,660 --> 00:09:35,230
callback structure from the device and

00:09:33,310 --> 00:09:42,010
just call that read function to read

00:09:35,230 --> 00:09:44,470
from that device so what happens if we

00:09:42,010 --> 00:09:46,270
now have all of this driver be of a

00:09:44,470 --> 00:09:48,790
different architecture so imagine we

00:09:46,270 --> 00:09:51,460
want to emulate that driver which means

00:09:48,790 --> 00:09:53,290
that driver is now running say x86 and

00:09:51,460 --> 00:09:55,540
everything around us is running arm how

00:09:53,290 --> 00:09:59,170
does that even work so there are a few

00:09:55,540 --> 00:10:02,050
obstacles we need to come across and

00:09:59,170 --> 00:10:03,760
just thought experiments you have to go

00:10:02,050 --> 00:10:07,600
through to figure out is this feasible

00:10:03,760 --> 00:10:09,630
or not so the most obvious one is do the

00:10:07,600 --> 00:10:12,130
data structures even look the same right

00:10:09,630 --> 00:10:14,320
do I have the same engine as do I have

00:10:12,130 --> 00:10:16,780
the same data structures so this

00:10:14,320 --> 00:10:18,070
structure in memory is roughly looks

00:10:16,780 --> 00:10:20,740
like this the pointers are just

00:10:18,070 --> 00:10:22,630
something I thought of but roughly this

00:10:20,740 --> 00:10:26,410
is the way that structure looks like in

00:10:22,630 --> 00:10:30,700
memory and one of the nice convenient

00:10:26,410 --> 00:10:32,680
parts in UEFI in a 64-bit world is that

00:10:30,700 --> 00:10:34,660
they look the same across different

00:10:32,680 --> 00:10:36,100
architectures as long as they have the

00:10:34,660 --> 00:10:37,900
same end units which we're guaranteed

00:10:36,100 --> 00:10:40,330
because you if I dictate that everything

00:10:37,900 --> 00:10:41,800
needs to be little-endian so the only

00:10:40,330 --> 00:10:44,440
case that wouldn't work is completely

00:10:41,800 --> 00:10:46,720
governed out and our arm at x36 systems

00:10:44,440 --> 00:10:48,430
actually have the exact same layout for

00:10:46,720 --> 00:10:50,290
all the data structures so even sharing

00:10:48,430 --> 00:10:56,080
data structures between arm and x86

00:10:50,290 --> 00:10:58,720
would work right unless you configured

00:10:56,080 --> 00:11:00,550
for big onion oh sure if you should do

00:10:58,720 --> 00:11:02,650
big onion you basically lost all of UEFI

00:11:00,550 --> 00:11:07,630
anyways but

00:11:02,650 --> 00:11:09,730
do that after UEFA is gone the the only

00:11:07,630 --> 00:11:13,210
thing that people might remember is

00:11:09,730 --> 00:11:16,780
heading right so petting is something

00:11:13,210 --> 00:11:21,430
that when you have data elements in your

00:11:16,780 --> 00:11:23,590
structure fields that are not aligned at

00:11:21,430 --> 00:11:27,670
the same position so for example a

00:11:23,590 --> 00:11:29,620
pointer in a 64-bit world wants to be 64

00:11:27,670 --> 00:11:32,860
bit aligned so that you can have an

00:11:29,620 --> 00:11:34,960
aligned data read from memory which

00:11:32,860 --> 00:11:37,300
means that usually what happens is that

00:11:34,960 --> 00:11:39,520
in the ABI is defined that you have a

00:11:37,300 --> 00:11:43,570
certain petting a couple of certain

00:11:39,520 --> 00:11:46,120
padding bytes in your in between that 32

00:11:43,570 --> 00:11:48,700
bit value and a 64-bit value because

00:11:46,120 --> 00:11:56,410
otherwise the 64-bit value would not

00:11:48,700 --> 00:11:59,860
start at a 64 bit boundary fortunately

00:11:56,410 --> 00:12:02,230
enough that actually applies to both

00:11:59,860 --> 00:12:04,390
architectures the same again so all

00:12:02,230 --> 00:12:06,610
those 64-bit architectures essentially

00:12:04,390 --> 00:12:10,480
follow roughly the same ABI semantics

00:12:06,610 --> 00:12:13,410
for data layout and that means we

00:12:10,480 --> 00:12:18,000
actually can share data between an x86

00:12:13,410 --> 00:12:18,000
piece of code and an arm piece of code

00:12:20,610 --> 00:12:27,040
so however you remember all of these

00:12:25,000 --> 00:12:30,630
data structures we had right so imagine

00:12:27,040 --> 00:12:34,360
we now have some code say an arm grab

00:12:30,630 --> 00:12:36,490
that wants to call into an exodus 6 read

00:12:34,360 --> 00:12:38,620
function that it receives from a struct

00:12:36,490 --> 00:12:40,390
that we really don't want to be able to

00:12:38,620 --> 00:12:43,420
interpret from the emulator part of our

00:12:40,390 --> 00:12:46,990
of you so somehow we need to be able to

00:12:43,420 --> 00:12:50,200
to trap that this arm code is now trying

00:12:46,990 --> 00:12:51,940
to run x86 code you could obviously

00:12:50,200 --> 00:12:54,280
marshal everything but then we would

00:12:51,940 --> 00:12:55,600
have lots of lines of code I don't know

00:12:54,280 --> 00:12:57,460
how many hundreds or thousands of lines

00:12:55,600 --> 00:12:59,320
of code for different protocols to

00:12:57,460 --> 00:13:00,850
basically just Marshall that struct into

00:12:59,320 --> 00:13:02,250
function pointers that call the emulator

00:13:00,850 --> 00:13:08,280
that then call again the real function

00:13:02,250 --> 00:13:08,280
so it's essentially unfeasible but

00:13:08,750 --> 00:13:15,890
oh yeah we want to we want to call that

00:13:11,150 --> 00:13:17,180
function but what does function calls

00:13:15,890 --> 00:13:19,580
actually what does a function call

00:13:17,180 --> 00:13:22,760
actually do a function call basically

00:13:19,580 --> 00:13:25,670
just means the CP work the the code that

00:13:22,760 --> 00:13:28,790
we write takes all of the parameters we

00:13:25,670 --> 00:13:31,040
have and puts them into individual

00:13:28,790 --> 00:13:32,630
registers they are defined in the ABI

00:13:31,040 --> 00:13:36,560
which registers they are so these are

00:13:32,630 --> 00:13:38,240
the ones for forearm it then potentially

00:13:36,560 --> 00:13:39,590
also puts spill over registers on the

00:13:38,240 --> 00:13:41,960
stack in this case it doesn't

00:13:39,590 --> 00:13:44,030
and then modifies the position counter

00:13:41,960 --> 00:13:45,980
to be the position counter of the

00:13:44,030 --> 00:13:47,330
function we want to call so that it

00:13:45,980 --> 00:13:51,620
basically the next instruction that is

00:13:47,330 --> 00:13:53,300
executed is the one from is it's the one

00:13:51,620 --> 00:13:54,860
we want to and to execute there's more

00:13:53,300 --> 00:13:59,240
to it but this is in a nutshell what

00:13:54,860 --> 00:14:02,000
happens however if we want to call x86

00:13:59,240 --> 00:14:04,730
code we have a real issue because if we

00:14:02,000 --> 00:14:09,260
now just jump into the x86 code we will

00:14:04,730 --> 00:14:11,750
execute things that on arm will have

00:14:09,260 --> 00:14:13,040
different semantics and different to do

00:14:11,750 --> 00:14:16,370
different things because the instruction

00:14:13,040 --> 00:14:18,320
sets don't look the same so we somehow

00:14:16,370 --> 00:14:20,450
need to get into key mu and how do we do

00:14:18,320 --> 00:14:22,250
that that's a really really nifty

00:14:20,450 --> 00:14:25,850
feature in modern CPUs which basically

00:14:22,250 --> 00:14:29,780
every 64-bit CPU is and that's called

00:14:25,850 --> 00:14:31,910
nor execute so execute is a feature

00:14:29,780 --> 00:14:34,160
where you can say well I have these

00:14:31,910 --> 00:14:36,350
regions in memory that are mapped to do

00:14:34,160 --> 00:14:38,180
something usually you map them just as I

00:14:36,350 --> 00:14:41,720
can read to them I can write to them I

00:14:38,180 --> 00:14:43,100
can execute them but you can also using

00:14:41,720 --> 00:14:45,440
a special bit and the page tables say

00:14:43,100 --> 00:14:48,800
well this region on here don't don't

00:14:45,440 --> 00:14:50,330
allow executing on it just allow reading

00:14:48,800 --> 00:14:52,610
and writing to it but don't execute on

00:14:50,330 --> 00:14:55,070
it it's a pretty normal mechanism you

00:14:52,610 --> 00:14:57,410
have these days to prohibit things like

00:14:55,070 --> 00:14:59,210
executing things from the stack but we

00:14:57,410 --> 00:15:04,280
can use it in this case too because if

00:14:59,210 --> 00:15:08,870
we just declare our x86 code to be in a

00:15:04,280 --> 00:15:11,120
no execute region it means that once we

00:15:08,870 --> 00:15:15,410
are now changing the position counter to

00:15:11,120 --> 00:15:17,209
go to x86 the CPU will say oh sorry no

00:15:15,410 --> 00:15:19,490
you cannot execute that region because

00:15:17,209 --> 00:15:22,180
it's no X is not executable and will

00:15:19,490 --> 00:15:26,080
generate a fault and that fault we can

00:15:22,180 --> 00:15:28,990
handle and instead of buffing out we can

00:15:26,080 --> 00:15:32,589
just go and call into our qmu code which

00:15:28,990 --> 00:15:34,630
can then go and create a virtual x86 CPU

00:15:32,589 --> 00:15:38,350
where it plucks all of those registers

00:15:34,630 --> 00:15:40,600
that we had into x86 registers to

00:15:38,350 --> 00:15:51,459
basically convert from one calling API

00:15:40,600 --> 00:15:54,279
into the other calling API one nice

00:15:51,459 --> 00:15:56,980
thing to keep in mind is that not every

00:15:54,279 --> 00:15:58,839
API also has the same semantics so on

00:15:56,980 --> 00:16:00,790
arm you can have a lot of read a lot of

00:15:58,839 --> 00:16:03,880
parameters passed and registers whereas

00:16:00,790 --> 00:16:06,940
on x86 with the Windows ABI you

00:16:03,880 --> 00:16:08,770
basically limited to four four registers

00:16:06,940 --> 00:16:10,120
where you can pass parameters and

00:16:08,770 --> 00:16:11,680
everything beyond that goes on the

00:16:10,120 --> 00:16:14,290
stacks of the same code also needs to

00:16:11,680 --> 00:16:18,370
then take care of those specialties

00:16:14,290 --> 00:16:20,350
where you basically have four parameters

00:16:18,370 --> 00:16:24,070
and registers on one side and 10 stack

00:16:20,350 --> 00:16:26,470
in the stack on the other side so once

00:16:24,070 --> 00:16:28,420
you have that you now have your virtual

00:16:26,470 --> 00:16:30,100
code running york um you can just

00:16:28,420 --> 00:16:31,900
execute code inside that virtual machine

00:16:30,100 --> 00:16:33,190
it can share data with the outside

00:16:31,900 --> 00:16:36,360
because they just work just look the

00:16:33,190 --> 00:16:39,100
same it can execute exit e6 code until

00:16:36,360 --> 00:16:41,140
well until it does not want to run x86

00:16:39,100 --> 00:16:43,120
code right what what happens if you want

00:16:41,140 --> 00:16:45,209
to print something to the screen the

00:16:43,120 --> 00:16:51,730
print function is again an arm function

00:16:45,209 --> 00:16:54,430
so what we do is on anytime we see the

00:16:51,730 --> 00:16:57,190
execution environment fetch an

00:16:54,430 --> 00:16:59,950
instruction from the outside from a from

00:16:57,190 --> 00:17:02,050
an arm code point from from something

00:16:59,950 --> 00:17:04,839
that's not governed inside that x86

00:17:02,050 --> 00:17:07,959
region we again bow out and say you're

00:17:04,839 --> 00:17:11,350
sorry this is not executable and Bowsher

00:17:07,959 --> 00:17:13,120
everything back again so we can then

00:17:11,350 --> 00:17:18,520
just call a normal arm function from

00:17:13,120 --> 00:17:20,949
there which means we can now just have

00:17:18,520 --> 00:17:23,079
arm code calling x86 code calling arm

00:17:20,949 --> 00:17:27,220
code calling x86 code calling arm code

00:17:23,079 --> 00:17:28,510
you get the point right it it's taxed as

00:17:27,220 --> 00:17:31,059
much as you like it basically is

00:17:28,510 --> 00:17:33,460
completely in a stable and we emulate

00:17:31,059 --> 00:17:35,180
instruction set architectures on a cross

00:17:33,460 --> 00:17:37,400
function boundary

00:17:35,180 --> 00:17:40,370
so it's this blitz one address base you

00:17:37,400 --> 00:17:42,650
have no idea you don't get really good

00:17:40,370 --> 00:17:45,320
hints on whether some instructions are

00:17:42,650 --> 00:17:46,880
supposed to be x86 arm but you can

00:17:45,320 --> 00:17:53,870
actually emulate the whole thing thanks

00:17:46,880 --> 00:17:57,590
to no execute does it work that's a

00:17:53,870 --> 00:18:02,720
picture of me standing next to an AMD

00:17:57,590 --> 00:18:05,870
Seattle system that's an arm server that

00:18:02,720 --> 00:18:08,480
has an NVIDIA GPU plugged in and this

00:18:05,870 --> 00:18:12,140
place grew up using the graphical output

00:18:08,480 --> 00:18:13,970
of the NVIDIA GPU on a screen something

00:18:12,140 --> 00:18:20,330
that looks pretty obvious to exit e6

00:18:13,970 --> 00:18:23,540
people but it's a miracle unarmed so why

00:18:20,330 --> 00:18:27,410
did we do why did we even go with qmu

00:18:23,540 --> 00:18:31,760
with crema score called TCG so the a

00:18:27,410 --> 00:18:35,270
couple of reasons why TCG is what was

00:18:31,760 --> 00:18:37,970
the right choice for this project one

00:18:35,270 --> 00:18:40,130
really important one is it's C code all

00:18:37,970 --> 00:18:44,270
of UEFI is basically written in C it's

00:18:40,130 --> 00:18:46,370
not readable C but it's still C which

00:18:44,270 --> 00:18:48,860
means if you take something like an

00:18:46,370 --> 00:18:50,600
interpreter with in C++ or written in

00:18:48,860 --> 00:18:52,490
Ruby or written in whatever other

00:18:50,600 --> 00:18:54,170
language you you choose that's much

00:18:52,490 --> 00:18:59,240
harder to integrate and some code that

00:18:54,170 --> 00:19:01,940
is already written in C it's reasonably

00:18:59,240 --> 00:19:04,670
well isolated so I might be biased

00:19:01,940 --> 00:19:07,040
because I used to I I have basically

00:19:04,670 --> 00:19:08,720
worked on TCG for the last ten years so

00:19:07,040 --> 00:19:10,790
i roughly know what that code does but I

00:19:08,720 --> 00:19:13,820
find it reasonably well isolated it was

00:19:10,790 --> 00:19:18,440
very easy to take the TCG code from QM

00:19:13,820 --> 00:19:21,410
you take it out put it into into an

00:19:18,440 --> 00:19:23,390
indicator module a UEFI module and just

00:19:21,410 --> 00:19:26,090
went inside there they were basically no

00:19:23,390 --> 00:19:29,980
issues in just copying the code open the

00:19:26,090 --> 00:19:32,000
biggest issue however was the GPL so

00:19:29,980 --> 00:19:34,070
because we're running on the same

00:19:32,000 --> 00:19:36,110
address space I really did not want to

00:19:34,070 --> 00:19:38,660
go through any legal questioning on

00:19:36,110 --> 00:19:43,040
whether running GPL code in there is

00:19:38,660 --> 00:19:44,570
then considered derived work so one

00:19:43,040 --> 00:19:47,360
thing that was really really important

00:19:44,570 --> 00:19:48,290
is that the code is LGPL that not

00:19:47,360 --> 00:19:50,900
repealed

00:19:48,290 --> 00:19:53,600
which means that project actually is

00:19:50,900 --> 00:19:56,480
using an older copy of TCG because

00:19:53,600 --> 00:19:59,180
recently we got a lot of key OEM things

00:19:56,480 --> 00:20:02,060
creeping into TCG which then again pull

00:19:59,180 --> 00:20:05,390
in GPL dependencies which basically

00:20:02,060 --> 00:20:07,490
convert the code into GPL code so this

00:20:05,390 --> 00:20:09,080
is running on a Buffy five to ten year

00:20:07,490 --> 00:20:10,850
old version of this gene which is good

00:20:09,080 --> 00:20:12,350
enough because back then actually 664

00:20:10,850 --> 00:20:16,580
looked almost the same for normal use

00:20:12,350 --> 00:20:19,340
based applications and that one was a

00:20:16,580 --> 00:20:22,270
really big big issue we wanted to have

00:20:19,340 --> 00:20:24,830
something that supports x86 64 so you

00:20:22,270 --> 00:20:27,710
find a lot of emulators out there that

00:20:24,830 --> 00:20:29,270
emulate 32-bit x86 code there used to be

00:20:27,710 --> 00:20:32,270
lots of projects that did similar things

00:20:29,270 --> 00:20:34,130
with vga bios back in the day on SPARC

00:20:32,270 --> 00:20:36,770
machines on power machines on any other

00:20:34,130 --> 00:20:38,300
even even inside xorg you have a an

00:20:36,770 --> 00:20:41,420
emulator that emulates 32-bit

00:20:38,300 --> 00:20:43,430
instruction sets to run the vga bios for

00:20:41,420 --> 00:20:46,070
your graphical applications people have

00:20:43,430 --> 00:20:49,130
done this over and over again but only

00:20:46,070 --> 00:20:51,170
on 32-bit binaries and never on 64-bit

00:20:49,130 --> 00:20:53,990
and never including all the like

00:20:51,170 --> 00:21:00,560
basically plugging in the the same

00:20:53,990 --> 00:21:03,800
driver core SS your native modules so

00:21:00,560 --> 00:21:06,700
that's why we use TCG but since you're

00:21:03,800 --> 00:21:09,500
totally excited about having having

00:21:06,700 --> 00:21:11,150
support for running option roms on your

00:21:09,500 --> 00:21:13,550
own server now how do you actually use

00:21:11,150 --> 00:21:16,910
that the easiest way because you usually

00:21:13,550 --> 00:21:19,340
don't have an answer at home is to go to

00:21:16,910 --> 00:21:21,260
that webpage that's the package this

00:21:19,340 --> 00:21:27,530
basically this this package contains all

00:21:21,260 --> 00:21:31,070
of the all of the sources of that qemu

00:21:27,530 --> 00:21:34,370
module for indicator and it contains a

00:21:31,070 --> 00:21:37,850
readme which describes how to build an

00:21:34,370 --> 00:21:39,620
ovm F binary or AVM F or whatever you

00:21:37,850 --> 00:21:44,600
want to call it a UEFI binary for a

00:21:39,620 --> 00:21:47,180
virtual machine with that extension

00:21:44,600 --> 00:21:51,310
included the reason it's so split up is

00:21:47,180 --> 00:21:56,330
that using that same method if you just

00:21:51,310 --> 00:21:58,910
echo the include files into a different

00:21:56,330 --> 00:22:00,980
package down here you can actually make

00:21:58,910 --> 00:22:02,130
any random arm board work with this if

00:22:00,980 --> 00:22:04,560
you have a maka

00:22:02,130 --> 00:22:08,040
Ben just builded within the mikado bin

00:22:04,560 --> 00:22:11,630
descriptions if you have a you know what

00:22:08,040 --> 00:22:14,760
else is there a some huawei servers have

00:22:11,630 --> 00:22:16,590
have their sources public so if you have

00:22:14,760 --> 00:22:18,570
a public board or even if you have your

00:22:16,590 --> 00:22:20,400
own private system that you have any k2

00:22:18,570 --> 00:22:23,660
sources for all you need to do is

00:22:20,400 --> 00:22:26,250
include these modules and merge that

00:22:23,660 --> 00:22:27,720
merge this indicator tree because it

00:22:26,250 --> 00:22:30,630
contains three commits to basically

00:22:27,720 --> 00:22:38,780
teach the know execute traps into the

00:22:30,630 --> 00:22:42,390
indicator core do you believe me works

00:22:38,780 --> 00:22:46,410
so demo is pretty easy the demo is a an

00:22:42,390 --> 00:22:49,020
armed system that has an e 1000 card

00:22:46,410 --> 00:22:53,160
plugged into it which has an exodus 6

00:22:49,020 --> 00:22:55,620
efi option ROM and if it works we have

00:22:53,160 --> 00:22:58,100
Network if it doesn't work well we don't

00:22:55,620 --> 00:22:58,100
get Network

00:23:05,430 --> 00:23:13,170
so if you just run your edk to binary

00:23:11,120 --> 00:23:15,570
without emulation this is just vanilla

00:23:13,170 --> 00:23:19,140
normal indicator running in qmu

00:23:15,570 --> 00:23:21,690
obviously because we KVM from so this is

00:23:19,140 --> 00:23:22,350
just running in utica to binary you will

00:23:21,690 --> 00:23:23,910
see that

00:23:22,350 --> 00:23:28,250
well it didn't detect any network right

00:23:23,910 --> 00:23:31,650
so even if you do IP config I have con I

00:23:28,250 --> 00:23:33,780
con fig - L you will see it doesn't show

00:23:31,650 --> 00:23:39,300
you any interfaces if you do PCI you

00:23:33,780 --> 00:23:41,580
will however see that there is that

00:23:39,300 --> 00:23:52,620
there is a network controller and e1000

00:23:41,580 --> 00:23:54,450
never controlling so yes we do have the

00:23:52,620 --> 00:24:01,440
NAP record after passed in but we just

00:23:54,450 --> 00:24:03,840
don't see it as we cannot execute we

00:24:01,440 --> 00:24:09,930
cannot execute the option ROM yet if we

00:24:03,840 --> 00:24:13,010
then take a binary that has the patches

00:24:09,930 --> 00:24:18,750
included you will see we boot from

00:24:13,010 --> 00:24:21,450
network load grew up from Network load

00:24:18,750 --> 00:24:22,980
files via via group from the network and

00:24:21,450 --> 00:24:24,570
display a full menu that is actually

00:24:22,980 --> 00:24:26,790
stored on a TFTP server that gets

00:24:24,570 --> 00:24:29,690
accessed by the network driver that is

00:24:26,790 --> 00:24:29,690
all x86 code

00:24:31,690 --> 00:24:38,440
[Applause]

00:24:48,519 --> 00:24:58,269
if lots of time left right I figured if

00:24:56,980 --> 00:25:00,809
I have lots of time left I could talk

00:24:58,269 --> 00:25:03,879
about two other things without slides so

00:25:00,809 --> 00:25:08,440
other things that came up while we were

00:25:03,879 --> 00:25:11,230
discussing what this whole emulation

00:25:08,440 --> 00:25:14,590
thing should be was EBC who have you

00:25:11,230 --> 00:25:17,710
heard of EBC well that's at least 10

00:25:14,590 --> 00:25:20,529
hands it's good um EBC is something that

00:25:17,710 --> 00:25:22,960
intel invented back in the day to have

00:25:20,529 --> 00:25:26,460
compatibility of option ones between

00:25:22,960 --> 00:25:30,549
32-bit x86 and 64-bit x86 and titanium

00:25:26,460 --> 00:25:32,379
so it's the only I saw I know of two

00:25:30,549 --> 00:25:37,629
devices it really is it's byte codes

00:25:32,379 --> 00:25:46,450
that has a variable size of long so size

00:25:37,629 --> 00:25:48,340
of as a function yes the the idea was

00:25:46,450 --> 00:25:51,129
that you can basically take the same ROM

00:25:48,340 --> 00:25:54,879
and have exactly all those integration

00:25:51,129 --> 00:25:58,919
pieces even on a 32-bit system or 64-bit

00:25:54,879 --> 00:26:01,210
system depending on which one you using

00:25:58,919 --> 00:26:01,629
we don't really care about that part

00:26:01,210 --> 00:26:03,629
anymore

00:26:01,629 --> 00:26:08,320
I mean 32-bit systems are not very

00:26:03,629 --> 00:26:11,860
widely used with UEFI these days and all

00:26:08,320 --> 00:26:14,769
the downsides you have you just with the

00:26:11,860 --> 00:26:16,210
emulation you also do have with EB C so

00:26:14,769 --> 00:26:18,549
EB C wouldn't get you any performance

00:26:16,210 --> 00:26:19,960
gains ABC wouldn't get you any any

00:26:18,549 --> 00:26:21,700
better standardization on things every

00:26:19,960 --> 00:26:23,470
time you have problems with say cache

00:26:21,700 --> 00:26:27,369
coherency or anything else you would

00:26:23,470 --> 00:26:28,960
have the same issues with a normal with

00:26:27,369 --> 00:26:31,960
with EB C as well but you have more

00:26:28,960 --> 00:26:34,990
downsides so a lots of modern

00:26:31,960 --> 00:26:37,690
lots of modern option or lots of modern

00:26:34,990 --> 00:26:39,039
efi cores don't even include an eb c

00:26:37,690 --> 00:26:42,490
interpreter anymore so you could for

00:26:39,039 --> 00:26:47,169
example put an e bc piece of code onto

00:26:42,490 --> 00:26:49,090
your onto your option ROM but then you

00:26:47,169 --> 00:26:50,740
plug that card into an x86 server and it

00:26:49,090 --> 00:26:53,470
doesn't want anymore it's not really

00:26:50,740 --> 00:26:55,149
what card vendors want to do so you can

00:26:53,470 --> 00:26:57,999
as well just compile either native code

00:26:55,149 --> 00:27:00,480
which still works or just forget the

00:26:57,999 --> 00:27:03,039
whole idea it's I would prefer

00:27:00,480 --> 00:27:05,289
cache coherency is the other one so one

00:27:03,039 --> 00:27:06,730
of the the differences between arm and

00:27:05,289 --> 00:27:09,600
one of the major differences with the

00:27:06,730 --> 00:27:12,369
arm and x86 is cache coherency

00:27:09,600 --> 00:27:14,019
guarantees so on x86 you basically

00:27:12,369 --> 00:27:16,629
basically almost always guarantees kept

00:27:14,019 --> 00:27:20,740
coherent caches on arm you almost never

00:27:16,629 --> 00:27:22,679
guarantee cream caches which is only an

00:27:20,740 --> 00:27:25,840
issue if you're running with multiple

00:27:22,679 --> 00:27:27,820
CPUs or if your devices are not cache

00:27:25,840 --> 00:27:30,549
coherent however

00:27:27,820 --> 00:27:32,440
SPSA which is the stop server based and

00:27:30,549 --> 00:27:36,100
architecture for armed if declares that

00:27:32,440 --> 00:27:38,320
your PCI Express complex has to be cache

00:27:36,100 --> 00:27:39,820
coherent with the CPU so you do know

00:27:38,320 --> 00:27:42,970
that every time you drive a tries to

00:27:39,820 --> 00:27:45,759
access any or tries to DMA anything with

00:27:42,970 --> 00:27:47,499
with the PCI card these pieces at least

00:27:45,759 --> 00:27:49,600
are cache coherent so the only thing

00:27:47,499 --> 00:27:51,970
that could not be cache coherent would

00:27:49,600 --> 00:27:54,450
be another core and firmware really

00:27:51,970 --> 00:28:00,519
usually just only once on a single core

00:27:54,450 --> 00:28:05,619
so it's not an issue with that any

00:28:00,519 --> 00:28:10,419
questions wait a second wait a second I

00:28:05,619 --> 00:28:12,580
got a microphone here in order to

00:28:10,419 --> 00:28:13,720
translate the function calls between the

00:28:12,580 --> 00:28:21,009
target don't you need to know the

00:28:13,720 --> 00:28:24,100
signature of the function know if you

00:28:21,009 --> 00:28:25,269
just is so you would need to know the

00:28:24,100 --> 00:28:27,820
signature if we were using

00:28:25,269 --> 00:28:31,029
floating-point we don't use any

00:28:27,820 --> 00:28:35,230
floating-point at all anywhere in UEFI I

00:28:31,029 --> 00:28:37,690
think even by definition so and because

00:28:35,230 --> 00:28:40,179
of that everything we need only gets

00:28:37,690 --> 00:28:43,509
passed and registers or on the stack and

00:28:40,179 --> 00:28:46,389
individual 64-bit chunks which then

00:28:43,509 --> 00:28:49,090
again means they're identical the ABI is

00:28:46,389 --> 00:28:51,879
happen to be identical between 32 bit

00:28:49,090 --> 00:28:56,350
and 64 bit between 64-bit x86 and 608

00:28:51,879 --> 00:28:57,460
arm that things like is for example one

00:28:56,350 --> 00:29:02,619
one thing that that could be different

00:28:57,460 --> 00:29:05,950
right is I have only a 32-bit value in

00:29:02,619 --> 00:29:10,539
my register or my argument is only 32

00:29:05,950 --> 00:29:11,890
bits wide and on one eyes on one ABI I

00:29:10,539 --> 00:29:14,230
declare that

00:29:11,890 --> 00:29:16,720
the caller needs to clear the upper

00:29:14,230 --> 00:29:18,970
32-bit and on the other one I declare

00:29:16,720 --> 00:29:21,760
that the Kali needs to clear the upper

00:29:18,970 --> 00:29:25,299
32-bit but all of these pieces happen to

00:29:21,760 --> 00:29:27,159
be the same across the two I think it's

00:29:25,299 --> 00:29:33,490
on purpose I think I think they try to

00:29:27,159 --> 00:29:40,149
be compatible thank you that's this one

00:29:33,490 --> 00:29:42,399
back there so I'm still confused as how

00:29:40,149 --> 00:29:45,610
how when you do the marshalling how many

00:29:42,399 --> 00:29:48,010
parameters you know to copy 12 what

00:29:45,610 --> 00:29:51,940
happens if you have fogs for example so

00:29:48,010 --> 00:29:53,830
again for arcs oh the odds are the same

00:29:51,940 --> 00:29:56,080
as no parameters but just on the stack

00:29:53,830 --> 00:29:58,059
right so we just basically copy I think

00:29:56,080 --> 00:30:00,549
14 or so it was so you just have a

00:29:58,059 --> 00:30:03,010
hard-coded limit you always copy all the

00:30:00,549 --> 00:30:05,049
registers and then some depth of the

00:30:03,010 --> 00:30:06,130
stack yes because we always know we

00:30:05,049 --> 00:30:09,039
pretty deep in through into the call

00:30:06,130 --> 00:30:16,990
stack so we know that we're not going to

00:30:09,039 --> 00:30:19,480
overwhelm the stack anywhere I would

00:30:16,990 --> 00:30:22,690
love to see you doing this in userspace

00:30:19,480 --> 00:30:25,690
so you can link different architected

00:30:22,690 --> 00:30:32,110
libraries and use em map instead of

00:30:25,690 --> 00:30:34,779
changing page table entries we'd be then

00:30:32,110 --> 00:30:37,320
I would love to be able to see you doing

00:30:34,779 --> 00:30:40,990
this as a user space process so that

00:30:37,320 --> 00:30:42,340
different libraries come with written

00:30:40,990 --> 00:30:44,529
for different architectures can be

00:30:42,340 --> 00:30:49,269
linked together and then you'd use em

00:30:44,529 --> 00:30:51,340
map instead of page table entries and my

00:30:49,269 --> 00:30:53,470
work

00:30:51,340 --> 00:30:57,700
it you you will have the cache coherency

00:30:53,470 --> 00:30:59,710
problem but well the the argument so it

00:30:57,700 --> 00:31:00,700
works as long as you you don't use

00:30:59,710 --> 00:31:02,260
floating-point because they're

00:31:00,700 --> 00:31:04,600
incompatible and it works as long as it

00:31:02,260 --> 00:31:07,480
don't use SMP but if you limit yourself

00:31:04,600 --> 00:31:09,250
to a single threaded process that

00:31:07,480 --> 00:31:11,380
happens to link something to it that

00:31:09,250 --> 00:31:14,080
might work I'm just not quite sure I see

00:31:11,380 --> 00:31:16,210
the big benefit of it but it should in

00:31:14,080 --> 00:31:19,570
that if you constrain you your problem

00:31:16,210 --> 00:31:24,280
space enough it might work just for fun

00:31:19,570 --> 00:31:27,190
so one question about the trapping

00:31:24,280 --> 00:31:29,200
mechanism does edk to or any of the apps

00:31:27,190 --> 00:31:31,660
do they actually use no executes

00:31:29,200 --> 00:31:33,790
especially for security because usually

00:31:31,660 --> 00:31:35,500
it's used for security and you don't

00:31:33,790 --> 00:31:37,690
want things to execute when you jump to

00:31:35,500 --> 00:31:40,660
those addresses so you could imagine

00:31:37,690 --> 00:31:42,370
that people would put x86 shellcode onto

00:31:40,660 --> 00:31:46,780
your arm system and it would work thanks

00:31:42,370 --> 00:31:49,480
to queue Mew so what do you think so you

00:31:46,780 --> 00:31:51,460
saw you saw the the github page that I

00:31:49,480 --> 00:31:53,500
linked to the whole project was I was a

00:31:51,460 --> 00:31:57,400
collaboration between art from Lenore

00:31:53,500 --> 00:31:59,550
and me art did the EFI part the back end

00:31:57,400 --> 00:32:05,470
plumbing and added the emulation parts

00:31:59,550 --> 00:32:07,210
the the whole reason I even got the idea

00:32:05,470 --> 00:32:11,020
of using execute for it was a

00:32:07,210 --> 00:32:14,050
presentation by art at lastly nod the

00:32:11,020 --> 00:32:17,470
one now connect having a go where he

00:32:14,050 --> 00:32:19,600
presented that now you if I can use no

00:32:17,470 --> 00:32:22,300
execute because he implemented no

00:32:19,600 --> 00:32:24,820
execute support in UEFI so obviously

00:32:22,300 --> 00:32:26,650
that same person kind of grasped how new

00:32:24,820 --> 00:32:28,690
executed works and should work so that

00:32:26,650 --> 00:32:30,970
trap handler does not trap and time

00:32:28,690 --> 00:32:33,940
immediately goes to qmu there is a whole

00:32:30,970 --> 00:32:36,850
framework that basically says oh if i

00:32:33,940 --> 00:32:39,340
trapped in that pc range then i can

00:32:36,850 --> 00:32:42,100
register for a callback that then gets

00:32:39,340 --> 00:32:44,800
jumped to so the way this works is that

00:32:42,100 --> 00:32:46,540
you you jump into an actually six

00:32:44,800 --> 00:32:48,010
location you get into the no execute

00:32:46,540 --> 00:32:50,410
handle and execute handler goes through

00:32:48,010 --> 00:32:53,200
a list of different register registered

00:32:50,410 --> 00:32:55,360
handlers and if one of them says this

00:32:53,200 --> 00:32:58,780
region i would really rather like to

00:32:55,360 --> 00:33:04,270
handle myself then it just swaps the pc

00:32:58,780 --> 00:33:04,850
to that handler and returns the signal

00:33:04,270 --> 00:33:09,289
basically

00:33:04,850 --> 00:33:14,929
thank you so when you say that you have

00:33:09,289 --> 00:33:16,820
to mark the function boundary so instead

00:33:14,929 --> 00:33:19,009
you have to mark the function barring

00:33:16,820 --> 00:33:21,860
I'm just curious if there's anything

00:33:19,009 --> 00:33:23,750
like for example I don't know so instead

00:33:21,860 --> 00:33:25,970
you have I if you have to handle

00:33:23,750 --> 00:33:31,460
sections we would rather break your

00:33:25,970 --> 00:33:33,200
function boundary the question is who

00:33:31,460 --> 00:33:34,580
handles exceptions where so you do have

00:33:33,200 --> 00:33:37,309
different interrupt priorities which

00:33:34,580 --> 00:33:40,909
basically exceptions can fall into but I

00:33:37,309 --> 00:33:44,600
don't in theory there's nothing keeping

00:33:40,909 --> 00:33:47,600
you from nesting exceptions in this case

00:33:44,600 --> 00:33:49,549
I think so you could even have an

00:33:47,600 --> 00:33:51,860
interrupt handler fully implemented in

00:33:49,549 --> 00:33:54,139
XD 6 code that then has a no execute

00:33:51,860 --> 00:33:57,080
handler that immediate some to after you

00:33:54,139 --> 00:33:58,129
arrive in the interrupt handler I think

00:33:57,080 --> 00:33:59,360
that was like a ball that's that's good

00:33:58,129 --> 00:34:00,980
you know not fully stackable but

00:33:59,360 --> 00:34:04,899
technically enough for this use case yes

00:34:00,980 --> 00:34:04,899
should work thank you

00:34:06,049 --> 00:34:10,579
you mentioned earlier that you're using

00:34:08,030 --> 00:34:13,460
five year old code because of LGPL

00:34:10,579 --> 00:34:16,190
compliance is there an effort to purge

00:34:13,460 --> 00:34:17,869
the GPL portions out of upstream code so

00:34:16,190 --> 00:34:28,010
we can modernize it and keep it up to

00:34:17,869 --> 00:34:29,089
date that's no reason to I mean that I'm

00:34:28,010 --> 00:34:31,669
pretty sure it was a reasonably

00:34:29,089 --> 00:34:33,050
conscious decision even to half GPL code

00:34:31,669 --> 00:34:35,990
in there that creeps into every single

00:34:33,050 --> 00:34:37,579
piece so I think that some purpose I'm

00:34:35,990 --> 00:34:41,149
not saying I'm sympathizing with the

00:34:37,579 --> 00:34:42,889
decision but that's that was a decision

00:34:41,149 --> 00:34:44,210
that was made and it's very very hard to

00:34:42,889 --> 00:34:47,720
revert and I don't think it makes sense

00:34:44,210 --> 00:34:50,149
to reword either it's just something to

00:34:47,720 --> 00:34:52,280
keep the keep in mind for heavy GPL

00:34:50,149 --> 00:34:56,919
advocates that sometimes the GPL can

00:34:52,280 --> 00:34:56,919
actually hurt reach of a project

00:35:03,240 --> 00:35:08,440
it's the same topic you didn't get the

00:35:06,010 --> 00:35:11,440
point right now because there's cream

00:35:08,440 --> 00:35:13,540
and I just read it up so it's GPL

00:35:11,440 --> 00:35:16,270
version to correct

00:35:13,540 --> 00:35:19,420
so actually wikipedia says it so the way

00:35:16,270 --> 00:35:22,660
the way licenses work is that a project

00:35:19,420 --> 00:35:25,570
usually isn't licensed by allies about a

00:35:22,660 --> 00:35:28,930
project inherits its license by the

00:35:25,570 --> 00:35:31,000
pieces it's composed off yeah so a

00:35:28,930 --> 00:35:35,140
particular queue in your binary is

00:35:31,000 --> 00:35:37,360
basically the overall most compatible

00:35:35,140 --> 00:35:40,420
license between all the source file you

00:35:37,360 --> 00:35:45,130
compile to generate that binary and it

00:35:40,420 --> 00:35:46,900
warns default right and the the lowest

00:35:45,130 --> 00:35:50,380
common denominator are not lowest but

00:35:46,900 --> 00:35:52,660
the the most viral common denominator

00:35:50,380 --> 00:35:56,230
between all the different licenses in

00:35:52,660 --> 00:36:00,310
the QM your code base is the GPL v2 is

00:35:56,230 --> 00:36:04,060
actually GPL v2 only but if you don't

00:36:00,310 --> 00:36:07,990
compile the pieces of code that don't

00:36:04,060 --> 00:36:10,840
have GPL v2 in the header then that

00:36:07,990 --> 00:36:13,150
basically gets accounted as the license

00:36:10,840 --> 00:36:15,940
that is written in the header and all of

00:36:13,150 --> 00:36:21,580
the emulation code used to at least be

00:36:15,940 --> 00:36:25,570
LGPL but I also write up this TC cheese

00:36:21,580 --> 00:36:28,870
stuff and when you say so well you take

00:36:25,570 --> 00:36:31,360
all portions of code there I read up the

00:36:28,870 --> 00:36:33,250
if you if you want to support new either

00:36:31,360 --> 00:36:35,440
the house processes or emulated

00:36:33,250 --> 00:36:38,620
processes they need to touch that code

00:36:35,440 --> 00:36:41,980
so actually you forked away and at some

00:36:38,620 --> 00:36:44,710
point in time and so you have one main

00:36:41,980 --> 00:36:47,110
fork and the other one and so how do you

00:36:44,710 --> 00:36:49,840
support new processes you either way

00:36:47,110 --> 00:36:52,780
host and target you don't have to so the

00:36:49,840 --> 00:36:57,040
beauty of option ones is that they need

00:36:52,780 --> 00:36:58,570
to be compatible throughout eternity you

00:36:57,040 --> 00:37:03,190
want to be able to plug a PCI Express

00:36:58,570 --> 00:37:04,930
card into a 10 year old PC so you that

00:37:03,190 --> 00:37:06,760
up to the room needs to be compatible to

00:37:04,930 --> 00:37:10,300
engine CPU so you don't need all the new

00:37:06,760 --> 00:37:12,640
features so in this particular case it

00:37:10,300 --> 00:37:14,530
doesn't matter I do agree that I don't

00:37:12,640 --> 00:37:17,980
like the whole part

00:37:14,530 --> 00:37:19,660
of the licensing piece but it's I would

00:37:17,980 --> 00:37:22,980
have liked even less the discussions

00:37:19,660 --> 00:37:25,360
that I would rise raise with OEMs or

00:37:22,980 --> 00:37:27,220
silicon vendors that suddenly would

00:37:25,360 --> 00:37:29,230
include GPL code in their firmware and

00:37:27,220 --> 00:37:31,270
then if what if suddenly somebody

00:37:29,230 --> 00:37:32,920
randomly just comes in and says who you

00:37:31,270 --> 00:37:37,990
know highlighting the GPL here I want to

00:37:32,920 --> 00:37:42,850
see the source code of everything but

00:37:37,990 --> 00:37:46,210
all this this TCG stuff is only used for

00:37:42,850 --> 00:37:48,610
this option roms not for other stuff the

00:37:46,210 --> 00:37:49,990
TCG part is only used for running x86

00:37:48,610 --> 00:37:51,460
code and the only excuse is code you

00:37:49,990 --> 00:37:53,800
would be running is an option one

00:37:51,460 --> 00:37:59,080
there's no point in running the Linux

00:37:53,800 --> 00:38:01,030
kernel using the emulator on EFI so you

00:37:59,080 --> 00:38:02,890
don't believe on binaries you want you

00:38:01,030 --> 00:38:07,210
on the drivers and the drivers really

00:38:02,890 --> 00:38:11,530
just means option roms good thank you so

00:38:07,210 --> 00:38:14,280
this emulated code is running every time

00:38:11,530 --> 00:38:16,750
you access device or only at boot time

00:38:14,280 --> 00:38:19,560
it's running every time you access the

00:38:16,750 --> 00:38:19,560
device on boot time

00:38:21,780 --> 00:38:27,070
the emulator cooks also that was trying

00:38:24,820 --> 00:38:29,080
to explain in a two minute short version

00:38:27,070 --> 00:38:31,240
with how the youÃ­ve I flow works

00:38:29,080 --> 00:38:32,770
so once Linux comes in UNIX has a small

00:38:31,240 --> 00:38:36,520
you wait they're not just a UEFI binary

00:38:32,770 --> 00:38:39,160
but Linux itself really is the Linux efi

00:38:36,520 --> 00:38:43,120
stop is so the not see if i stub is a

00:38:39,160 --> 00:38:45,070
small binary part of linux where

00:38:43,120 --> 00:38:47,110
Subotica is a sauce part but it's a part

00:38:45,070 --> 00:38:49,530
that gets compiled as a binary it's a PE

00:38:47,110 --> 00:38:52,390
binary years and EFI compatible binary

00:38:49,530 --> 00:38:54,430
that really just all it does is it

00:38:52,390 --> 00:38:56,940
fetches everything from efi it needs to

00:38:54,430 --> 00:38:59,710
know and then throws it away

00:38:56,940 --> 00:39:01,450
so all these boot time services that you

00:38:59,710 --> 00:39:03,400
see and this is what drivers really do

00:39:01,450 --> 00:39:06,220
usually all these putin service drivers

00:39:03,400 --> 00:39:09,820
they just get removed yes you could run

00:39:06,220 --> 00:39:12,520
into problems if a if an option one

00:39:09,820 --> 00:39:14,290
installs a runtime service which then

00:39:12,520 --> 00:39:17,530
again would mean it's installs and exit

00:39:14,290 --> 00:39:19,960
e6 driver into something that gets

00:39:17,530 --> 00:39:21,820
executed while you're running linux or

00:39:19,960 --> 00:39:24,280
that on linux we don't support any

00:39:21,820 --> 00:39:27,250
one-time service services that get

00:39:24,280 --> 00:39:29,700
installed by drivers today so we don't

00:39:27,250 --> 00:39:29,700
really care

00:39:34,770 --> 00:39:42,300
so read another question it says stop

00:39:37,109 --> 00:39:45,380
back there I'm sorry thank you

00:39:42,300 --> 00:39:54,340
[Applause]

00:39:45,380 --> 00:39:54,340

YouTube URL: https://www.youtube.com/watch?v=uxvAH1Q4Mx0


