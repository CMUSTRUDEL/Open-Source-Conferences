Title: [2017] Managing the New Block Layer by Kevin Wolf & Max Reitz
Publication date: 2017-11-07
Playlist: KVM Forum 2017
Description: 
	QEMU 2.9 has been a big release for the block layer. With the -blockdev command line option and blockdev-add QMP command declared stable, users get a lot more flexibility in configuring their storage. This is complemented by the new op blockers system that ensures that making use of this flexibility doesn't make the setup unsafe. These changes mean that also the best practices for managing the block layer are changing.

We'll present what the building blocks of the block layer are, how they interact and what is the modern way to use them. We'll also show how we're planning to move forward and build on top of this, for example with dynamic insertion and removal of filter drivers like I/O throttling for any part of the setup.

---

Max Reitz
Red Hat

Max is a computer science student at TU Dresden and Software Engineer at Red Hat co-maintaining QEMU's block layer core. He was a presenter at the three previous KVM Forums.

Kevin Wolf
Red Hat, Inc.
Principal Software Engineer

Kevin is a Principal Software Engineer at Red Hat, working in the virtualisation team with a focus on block devices. He is the maintainer of QEMU's block subsystem and has contributed many patches to block device emulation and image format drivers. After graduating in Software Engineering at the University of Stuttgart, Germany in 2008 he worked on Xen's block layer for a year before he started working on KVM for Red Hat in 2009.
Captions: 
	00:00:00,390 --> 00:00:02,709
[Music]

00:00:06,049 --> 00:00:11,550
welcome to the next talk my name is

00:00:08,849 --> 00:00:13,679
Kevin wolf and my co-presenters max

00:00:11,550 --> 00:00:16,440
guides and we will be talking about the

00:00:13,679 --> 00:00:19,020
changes that we have made in the block

00:00:16,440 --> 00:00:22,140
layer in TMU recently there have been

00:00:19,020 --> 00:00:25,350
some pretty major changes and we're

00:00:22,140 --> 00:00:28,619
going to tell you about how to use the

00:00:25,350 --> 00:00:30,269
block there in its new state but before

00:00:28,619 --> 00:00:33,570
we start with that I have an

00:00:30,269 --> 00:00:36,210
announcement announcement for you we

00:00:33,570 --> 00:00:39,899
will have buff sessions in the afternoon

00:00:36,210 --> 00:00:43,590
and if you have a topic to propose here

00:00:39,899 --> 00:00:43,950
is the board in the next break just come

00:00:43,590 --> 00:00:45,930
here

00:00:43,950 --> 00:00:48,239
Pawel already made a start with a

00:00:45,930 --> 00:00:51,539
proposal so you have a template just

00:00:48,239 --> 00:00:54,960
come here and write your topic and now

00:00:51,539 --> 00:00:58,140
max was shot with the actual talk okay

00:00:54,960 --> 00:01:00,930
so in the title managing the block layer

00:00:58,140 --> 00:01:02,219
there's two parts or managing the new

00:01:00,930 --> 00:01:04,229
block layer there's two parts first

00:01:02,219 --> 00:01:06,840
managing and secondly the new block

00:01:04,229 --> 00:01:10,080
layer so first we'll have to start with

00:01:06,840 --> 00:01:12,450
what the new block layer actually is and

00:01:10,080 --> 00:01:14,670
that is going to be part of my part the

00:01:12,450 --> 00:01:16,799
user management part where as Kevin will

00:01:14,670 --> 00:01:19,979
talk about how qmu makes sure that you

00:01:16,799 --> 00:01:22,670
as the user don't miss manage so let's

00:01:19,979 --> 00:01:24,780
talk about what the new block layer is

00:01:22,670 --> 00:01:27,659
so this is what the block layer in

00:01:24,780 --> 00:01:29,340
general is inside of qmu you have some

00:01:27,659 --> 00:01:30,780
guests which of course wants to store

00:01:29,340 --> 00:01:33,630
its data somewhere in a persistent

00:01:30,780 --> 00:01:35,640
manner and so that this data is actually

00:01:33,630 --> 00:01:37,740
stored persistently it has to be stored

00:01:35,640 --> 00:01:39,420
on the host somewhere and the block

00:01:37,740 --> 00:01:41,610
layer is there between the emulated

00:01:39,420 --> 00:01:43,320
guest devices and the whole storage to

00:01:41,610 --> 00:01:45,659
make sure that the data actually arrives

00:01:43,320 --> 00:01:48,090
there and that it later can be read back

00:01:45,659 --> 00:01:51,180
so it has a couple of duties it has to

00:01:48,090 --> 00:01:53,100
fulfill first it has to read and write

00:01:51,180 --> 00:01:55,979
data from and to host storage that is

00:01:53,100 --> 00:01:58,560
outside of qmu it has to interpret image

00:01:55,979 --> 00:02:00,570
formats on the way and since we already

00:01:58,560 --> 00:02:02,310
have all this data flowing through it we

00:02:00,570 --> 00:02:04,649
can do things with it like we can

00:02:02,310 --> 00:02:06,780
encrypt it we can do throttling we can

00:02:04,649 --> 00:02:10,530
data duplications all of these things

00:02:06,780 --> 00:02:13,319
and for the implementation this is split

00:02:10,530 --> 00:02:15,359
into so-called block drivers and every

00:02:13,319 --> 00:02:17,700
not driver fulfills one of these tasks

00:02:15,359 --> 00:02:21,329
so we have protocol drivers which acts

00:02:17,700 --> 00:02:22,739
as host storage we have format drivers

00:02:21,329 --> 00:02:24,689
which interpret image formats for

00:02:22,739 --> 00:02:26,700
instance the cue car - driver and we

00:02:24,689 --> 00:02:28,980
have now also filter drivers which do

00:02:26,700 --> 00:02:30,780
data manipulation such as the new

00:02:28,980 --> 00:02:32,689
throttle driver which is throttling or

00:02:30,780 --> 00:02:37,379
the quorum driver for data duplication

00:02:32,689 --> 00:02:40,260
and runtime this is represented in a

00:02:37,379 --> 00:02:42,719
data flow graph and each data flow graph

00:02:40,260 --> 00:02:45,450
of course has some nodes in it and these

00:02:42,719 --> 00:02:48,900
nodes we have - and each node is managed

00:02:45,450 --> 00:02:51,659
by some blocked driver so data comes in

00:02:48,900 --> 00:02:54,060
the block driver modifies the data in a

00:02:51,659 --> 00:02:55,739
way that is appropriate and then the

00:02:54,060 --> 00:02:57,810
data comes out again of course the data

00:02:55,739 --> 00:02:59,609
flow is bi-directional because you want

00:02:57,810 --> 00:03:01,530
to read and write data at the same time

00:02:59,609 --> 00:03:03,449
but still we can't have some hierarchy

00:03:01,530 --> 00:03:06,719
of parents and children based on the

00:03:03,449 --> 00:03:08,639
fact that we have basically some kind of

00:03:06,719 --> 00:03:11,400
bus master in our system where the

00:03:08,639 --> 00:03:13,500
requests originate from usually that is

00:03:11,400 --> 00:03:15,599
the guest device so the guest device

00:03:13,500 --> 00:03:18,239
generates requests sends them down to

00:03:15,599 --> 00:03:20,549
the first node in the data flow graph

00:03:18,239 --> 00:03:22,169
and that's this node then does something

00:03:20,549 --> 00:03:24,479
with that generates new requests hands

00:03:22,169 --> 00:03:26,970
them down with it to its children and so

00:03:24,479 --> 00:03:29,009
on and finally at the bottom we arrive

00:03:26,970 --> 00:03:32,310
at the probe at the protocol nodes which

00:03:29,009 --> 00:03:35,310
do not have any other chilled but which

00:03:32,310 --> 00:03:36,840
acts as host storage so they put the

00:03:35,310 --> 00:03:41,759
data outside of Cumae or get it from

00:03:36,840 --> 00:03:43,560
outside of qmu and then usually you have

00:03:41,759 --> 00:03:45,509
your data stored in some form of image

00:03:43,560 --> 00:03:47,250
formats so you also need a format node

00:03:45,509 --> 00:03:49,680
on top of that and then you can have all

00:03:47,250 --> 00:03:51,239
kinds of filters if you so desire so

00:03:49,680 --> 00:03:53,489
this is a rather simple block graph

00:03:51,239 --> 00:03:55,199
because it's just linear so let's make

00:03:53,489 --> 00:03:59,400
something more interesting let's make a

00:03:55,199 --> 00:04:01,500
block tree so this is a rather simple

00:03:59,400 --> 00:04:03,239
example of a block tree we have on the

00:04:01,500 --> 00:04:06,269
left side the same as we have before

00:04:03,239 --> 00:04:08,849
like we have a format driver on topic

00:04:06,269 --> 00:04:10,769
you car to driver or cue car to node and

00:04:08,849 --> 00:04:12,599
then below that we have a protocol node

00:04:10,769 --> 00:04:14,909
which acts as a source search in this

00:04:12,599 --> 00:04:17,190
case the protocol node is a file node

00:04:14,909 --> 00:04:19,320
which means it will access any file on

00:04:17,190 --> 00:04:23,940
your host system just on your normal

00:04:19,320 --> 00:04:25,349
file system and this node is called the

00:04:23,940 --> 00:04:26,630
file side of the queue car to node

00:04:25,349 --> 00:04:28,820
because it stores

00:04:26,630 --> 00:04:30,530
of the main information of the Keuka to

00:04:28,820 --> 00:04:32,450
file at source all the metadata and it

00:04:30,530 --> 00:04:34,520
sorts the data that is actually stored

00:04:32,450 --> 00:04:36,530
within that file and the cuecore 2 node

00:04:34,520 --> 00:04:39,470
then interprets the image format and can

00:04:36,530 --> 00:04:41,450
handle all the actual data up to its

00:04:39,470 --> 00:04:44,960
user in this case it does not have any

00:04:41,450 --> 00:04:48,560
user does not have any parent so it

00:04:44,960 --> 00:04:50,270
doesn't do much at this point but it can

00:04:48,560 --> 00:04:52,580
queue car to nodes can also have a

00:04:50,270 --> 00:04:55,250
backing child so in this case it has one

00:04:52,580 --> 00:04:57,500
which is in this case a raw file so we

00:04:55,250 --> 00:04:59,390
need a raw format driver or actually

00:04:57,500 --> 00:05:02,240
technically it's a filter driver but not

00:04:59,390 --> 00:05:04,340
that important and this raw node of

00:05:02,240 --> 00:05:06,110
course also needs a file child which

00:05:04,340 --> 00:05:07,730
manages the actual file that is

00:05:06,110 --> 00:05:09,920
physically stored somewhere in this case

00:05:07,730 --> 00:05:15,050
is stored on a network block device so

00:05:09,920 --> 00:05:16,880
we need an nvd node you can see that

00:05:15,050 --> 00:05:19,040
every child has some name which

00:05:16,880 --> 00:05:21,740
corresponds to its know to its role so

00:05:19,040 --> 00:05:24,500
usually the main child of a node is

00:05:21,740 --> 00:05:26,840
called the file child and the backing

00:05:24,500 --> 00:05:30,500
child is appropriately called the

00:05:26,840 --> 00:05:33,380
backing child then each node can also

00:05:30,500 --> 00:05:35,300
have a name the cue car to note at the

00:05:33,380 --> 00:05:37,550
very top is named fool then we have a

00:05:35,300 --> 00:05:39,800
node called foo protocol node called

00:05:37,550 --> 00:05:41,510
parlo called pop protocol and all these

00:05:39,800 --> 00:05:43,480
names can be given can be specified by

00:05:41,510 --> 00:05:46,010
the user and they're called node names

00:05:43,480 --> 00:05:49,610
appropriately and you can use those to

00:05:46,010 --> 00:05:51,470
later identify and specify nodes in this

00:05:49,610 --> 00:05:53,030
graph if you need to modify it or if you

00:05:51,470 --> 00:05:58,190
need to start new operations on the

00:05:53,030 --> 00:06:01,610
graph then the Keuka 2 node is the root

00:05:58,190 --> 00:06:04,280
node because it does not have any nodes

00:06:01,610 --> 00:06:06,980
as its parent which also means that it's

00:06:04,280 --> 00:06:08,510
not very useful because only parents

00:06:06,980 --> 00:06:11,240
generate new requests so there won't be

00:06:08,510 --> 00:06:13,340
any requests in this graph so it will

00:06:11,240 --> 00:06:15,350
not actually do anything so let's route

00:06:13,340 --> 00:06:18,590
our tree that's connected to a guest

00:06:15,350 --> 00:06:20,620
device the guest device is not part of

00:06:18,590 --> 00:06:23,240
the core block layer so that means it's

00:06:20,620 --> 00:06:26,900
something we call an outside user so it

00:06:23,240 --> 00:06:28,910
needs to have some interface between the

00:06:26,900 --> 00:06:30,830
actual block layer and between it and

00:06:28,910 --> 00:06:32,150
this interface is called a block

00:06:30,830 --> 00:06:34,160
back-end which is just an internal

00:06:32,150 --> 00:06:36,740
object inside of qmu which connects an

00:06:34,160 --> 00:06:39,610
external user such as guest devices to

00:06:36,740 --> 00:06:43,850
know it's within the block layer

00:06:39,610 --> 00:06:46,130
we'll come back to that later on now

00:06:43,850 --> 00:06:48,200
note on filters filters are rather new

00:06:46,130 --> 00:06:51,050
in the block layer they're different

00:06:48,200 --> 00:06:53,000
from format notes and we've already told

00:06:51,050 --> 00:06:54,380
talked about by protocol notes are

00:06:53,000 --> 00:06:56,240
different protocol notes are interesting

00:06:54,380 --> 00:06:58,580
and different because they don't store

00:06:56,240 --> 00:07:00,919
any data or they don't have any children

00:06:58,580 --> 00:07:04,190
inside of the block layer but they store

00:07:00,919 --> 00:07:05,810
data outside of qmu itself so that's why

00:07:04,190 --> 00:07:08,090
protocol notes are different from format

00:07:05,810 --> 00:07:09,320
and filter notes filter notes are

00:07:08,090 --> 00:07:11,210
different from format notes and that

00:07:09,320 --> 00:07:13,910
they don't have any metadata and that

00:07:11,210 --> 00:07:15,979
means you can stack them arbitrarily in

00:07:13,910 --> 00:07:17,570
theory you can also stack like a Cukor

00:07:15,979 --> 00:07:19,460
to note on top of another cue car to

00:07:17,570 --> 00:07:21,050
note and then you have a cue car to file

00:07:19,460 --> 00:07:24,260
inside of a queue car to file but that

00:07:21,050 --> 00:07:26,270
just doesn't make much sense and you

00:07:24,260 --> 00:07:28,040
cannot stack that arbitrarily it just

00:07:26,270 --> 00:07:30,139
doesn't make sense but if you want to

00:07:28,040 --> 00:07:31,490
you can stake a throttling node on top

00:07:30,139 --> 00:07:33,169
of another throttling node if you have

00:07:31,490 --> 00:07:36,020
two working groups that you want to

00:07:33,169 --> 00:07:37,550
combine so you can do that and it makes

00:07:36,020 --> 00:07:39,020
much more sense or you can have

00:07:37,550 --> 00:07:40,340
different filters which is take on top

00:07:39,020 --> 00:07:42,590
of each other like you can have the

00:07:40,340 --> 00:07:45,260
quorum node which duplicates data and

00:07:42,590 --> 00:07:46,760
then put throttling onto one of its

00:07:45,260 --> 00:07:49,660
children and then put throttling on top

00:07:46,760 --> 00:07:51,620
of it so you can do arbitrary large

00:07:49,660 --> 00:07:54,830
configurations with that which can be

00:07:51,620 --> 00:07:57,440
arbitrarily complex and this is why you

00:07:54,830 --> 00:07:59,780
need to manage it because in the olden

00:07:57,440 --> 00:08:01,460
days you just had probably a format node

00:07:59,780 --> 00:08:02,930
on top of some protocol node maybe some

00:08:01,460 --> 00:08:05,390
backing chain and that was rather simple

00:08:02,930 --> 00:08:07,639
so GM you could basically figure out

00:08:05,390 --> 00:08:10,039
what you want to do based on a single

00:08:07,639 --> 00:08:11,690
file name that you open but now you can

00:08:10,039 --> 00:08:13,430
have very complex trees so you need to

00:08:11,690 --> 00:08:15,680
manage every single detail if you want

00:08:13,430 --> 00:08:17,090
that and this is the first thing we'll

00:08:15,680 --> 00:08:19,610
have to talk about how you can construct

00:08:17,090 --> 00:08:21,860
these trees or these generally these

00:08:19,610 --> 00:08:23,389
block graphs then how you can modify

00:08:21,860 --> 00:08:25,370
them at runtime say you have some

00:08:23,389 --> 00:08:27,050
throttling that you introduced at

00:08:25,370 --> 00:08:29,090
startup and that you later want to

00:08:27,050 --> 00:08:30,860
revoke again that's of course something

00:08:29,090 --> 00:08:32,000
where you need runtime modification you

00:08:30,860 --> 00:08:34,060
have some throttling node you want to

00:08:32,000 --> 00:08:39,740
take it out or you want to add a new one

00:08:34,060 --> 00:08:42,110
and finally the thing is that as I said

00:08:39,740 --> 00:08:44,330
these are all things you do and you can

00:08:42,110 --> 00:08:48,290
probably do a lot but you can of course

00:08:44,330 --> 00:08:51,290
also do a lot in the wrong way and QM

00:08:48,290 --> 00:08:52,640
you now has up blockers or has better up

00:08:51,290 --> 00:08:55,580
blockers than before

00:08:52,640 --> 00:08:57,590
make sure that you don't do it the wrong

00:08:55,580 --> 00:08:59,090
way and that everything still keeps safe

00:08:57,590 --> 00:09:01,250
and you don't accidentally corrupt your

00:08:59,090 --> 00:09:03,950
data and this is what Kevin is then

00:09:01,250 --> 00:09:08,210
going to talk about so let's talk about

00:09:03,950 --> 00:09:10,760
how you can construct a block graph the

00:09:08,210 --> 00:09:13,370
most simple graph of course is just a

00:09:10,760 --> 00:09:16,970
single node so let's start with that to

00:09:13,370 --> 00:09:19,490
configure a node you just give QM you a

00:09:16,970 --> 00:09:21,590
list of options or a dictionary of

00:09:19,490 --> 00:09:23,180
options and it will then construct the

00:09:21,590 --> 00:09:25,310
appropriate node the first thing you

00:09:23,180 --> 00:09:27,650
have to pass is the name of the driver

00:09:25,310 --> 00:09:30,050
that will manage the node of course and

00:09:27,650 --> 00:09:32,780
the second thing you can pass if you

00:09:30,050 --> 00:09:35,540
want to sometimes you have to is the

00:09:32,780 --> 00:09:38,180
node name which you can use to identify

00:09:35,540 --> 00:09:41,270
the node later on sometimes it's

00:09:38,180 --> 00:09:44,810
mandatory so you probably just want to

00:09:41,270 --> 00:09:46,070
specify it all the time if not anything

00:09:44,810 --> 00:09:47,510
else then because it gives you more

00:09:46,070 --> 00:09:49,070
options to manage everything if you

00:09:47,510 --> 00:09:52,490
don't specify it QA will auto-generate

00:09:49,070 --> 00:09:55,100
one but yeah depending on the driver

00:09:52,490 --> 00:09:57,410
they're also driver specific options for

00:09:55,100 --> 00:09:59,660
instance if you create a final node you

00:09:57,410 --> 00:10:01,520
have to give it a file name that the

00:09:59,660 --> 00:10:03,740
file node should then open somewhere on

00:10:01,520 --> 00:10:05,390
your normal file system and it has more

00:10:03,740 --> 00:10:07,550
options which are not interesting to us

00:10:05,390 --> 00:10:11,030
now but you can look them up in the qmp

00:10:07,550 --> 00:10:13,070
reference so to create a very simple

00:10:11,030 --> 00:10:15,350
protocol node called protocol node

00:10:13,070 --> 00:10:17,510
managed by the file driver you would

00:10:15,350 --> 00:10:20,390
just give these options given here in

00:10:17,510 --> 00:10:22,190
JSON format so you specify the driver to

00:10:20,390 --> 00:10:24,230
be file is specified a node name to be

00:10:22,190 --> 00:10:27,110
protocol node and the fire we want to

00:10:24,230 --> 00:10:29,450
open is called food at Keuka - so we

00:10:27,110 --> 00:10:32,320
pass that and then if you give that to

00:10:29,450 --> 00:10:34,280
QM you it will create this single node

00:10:32,320 --> 00:10:35,570
now a single note is not very

00:10:34,280 --> 00:10:35,950
interesting so let's make a tree out of

00:10:35,570 --> 00:10:38,000
it

00:10:35,950 --> 00:10:39,710
incidentally we can see it's a queue car

00:10:38,000 --> 00:10:41,530
two files so let's just create a queue

00:10:39,710 --> 00:10:44,180
car to form a node on top of it

00:10:41,530 --> 00:10:46,670
duplicate accuse the two node you need

00:10:44,180 --> 00:10:48,830
the file option this is a queue car two

00:10:46,670 --> 00:10:51,470
specific option actually any format node

00:10:48,830 --> 00:10:53,960
has this option and it's a reference to

00:10:51,470 --> 00:10:57,500
another node that you want to use as the

00:10:53,960 --> 00:10:59,150
file child the Cooper two node also has

00:10:57,500 --> 00:11:00,950
some other options which you can again

00:10:59,150 --> 00:11:03,580
look up in the reference if you want to

00:11:00,950 --> 00:11:06,339
but which are not important to us now

00:11:03,580 --> 00:11:09,639
there are two ways you can refer

00:11:06,339 --> 00:11:11,680
another node one is by note name so to

00:11:09,639 --> 00:11:13,089
create the SKU co2 note which sits on

00:11:11,680 --> 00:11:15,699
top of the protocol node you would

00:11:13,089 --> 00:11:17,800
simply again specify the driver of the

00:11:15,699 --> 00:11:20,050
node to be Keuka to the name to be

00:11:17,800 --> 00:11:21,939
format note in this case and as the file

00:11:20,050 --> 00:11:24,189
child you would just pass the string

00:11:21,939 --> 00:11:25,899
protocol node and then QM you will

00:11:24,189 --> 00:11:27,430
create the former node on top of that

00:11:25,899 --> 00:11:31,529
protocol node which you have already

00:11:27,430 --> 00:11:34,029
created another way to specify nodes is

00:11:31,529 --> 00:11:38,230
something we call in-line specification

00:11:34,029 --> 00:11:41,470
so instead of a string you would pass a

00:11:38,230 --> 00:11:43,660
JSON object for the file option and this

00:11:41,470 --> 00:11:45,579
JSON object then contains all the

00:11:43,660 --> 00:11:49,269
information QM you needs to construct

00:11:45,579 --> 00:11:52,749
the child node in this case the protocol

00:11:49,269 --> 00:11:54,699
the file node and let's say just for fun

00:11:52,749 --> 00:11:56,709
we don't specify a node name here and

00:11:54,699 --> 00:11:58,839
then you can see that QM you will

00:11:56,709 --> 00:12:02,529
generate a node names such as hash block

00:11:58,839 --> 00:12:04,149
o 42 and then it will create the sole

00:12:02,529 --> 00:12:05,589
tree so in this case you would not need

00:12:04,149 --> 00:12:07,180
to create the protocol node beforehand

00:12:05,589 --> 00:12:09,430
but you can't just create it with this

00:12:07,180 --> 00:12:11,199
single specification which you can see

00:12:09,430 --> 00:12:14,740
how this can be extended to an

00:12:11,199 --> 00:12:16,870
arbitrarily large tree and to pass the

00:12:14,740 --> 00:12:19,420
state information the QM you there are

00:12:16,870 --> 00:12:21,399
basically two ways the first one is the

00:12:19,420 --> 00:12:23,679
blocked a vacuum P command where you

00:12:21,399 --> 00:12:25,959
just pass the whole JSON object for the

00:12:23,679 --> 00:12:28,379
arguments option and that's it then the

00:12:25,959 --> 00:12:31,120
tree gets created nothing special to it

00:12:28,379 --> 00:12:32,920
if you're on the comment line then

00:12:31,120 --> 00:12:36,579
there's the - block type option which

00:12:32,920 --> 00:12:39,309
also just takes a JSON argument which is

00:12:36,579 --> 00:12:41,559
just Jason option just a JSON object and

00:12:39,309 --> 00:12:44,920
with that you can create just the very

00:12:41,559 --> 00:12:47,529
same trees so actually rather simple of

00:12:44,920 --> 00:12:48,579
course it can get rather long so but

00:12:47,529 --> 00:12:49,990
that shouldn't be an option for

00:12:48,579 --> 00:12:55,540
management tools which probably are the

00:12:49,990 --> 00:12:56,889
main uses for this and finally of course

00:12:55,540 --> 00:12:58,389
now you have created this tree but it's

00:12:56,889 --> 00:12:59,889
not very useful because it just hangs

00:12:58,389 --> 00:13:00,879
around in the air and the root is not

00:12:59,889 --> 00:13:02,999
attached to anything

00:13:00,879 --> 00:13:06,220
so let's attach it to a guest device

00:13:02,999 --> 00:13:08,740
which we first have to create using for

00:13:06,220 --> 00:13:10,300
instance - device and for any block

00:13:08,740 --> 00:13:12,879
device you create with - device or with

00:13:10,300 --> 00:13:15,370
device ID you have this drive option and

00:13:12,879 --> 00:13:17,259
for that option you just pass the node

00:13:15,370 --> 00:13:18,990
name of the root node and then queue

00:13:17,259 --> 00:13:23,220
will automatically connect

00:13:18,990 --> 00:13:25,710
the that node to the gas device using a

00:13:23,220 --> 00:13:27,120
block back and in the middle so you

00:13:25,710 --> 00:13:28,950
don't have to worry about that block a

00:13:27,120 --> 00:13:33,000
packing cube will just connect them

00:13:28,950 --> 00:13:35,790
automatically and do all the rest you

00:13:33,000 --> 00:13:38,730
may remember - Drive which was like the

00:13:35,790 --> 00:13:41,370
big thing to configure all your block

00:13:38,730 --> 00:13:42,530
devices and construct your whole trees

00:13:41,370 --> 00:13:45,870
and things like that

00:13:42,530 --> 00:13:47,280
now you just shouldn't use it any longer

00:13:45,870 --> 00:13:49,260
if possible

00:13:47,280 --> 00:13:50,760
probably even if it's not possible you

00:13:49,260 --> 00:13:52,710
should very much think about not using

00:13:50,760 --> 00:13:55,470
it any longer there are a couple of

00:13:52,710 --> 00:13:58,170
reasons why this is just some selection

00:13:55,470 --> 00:13:59,520
and then space run out and I couldn't

00:13:58,170 --> 00:14:03,600
and I just decided not to think of

00:13:59,520 --> 00:14:05,700
anymore but one important thing is that

00:14:03,600 --> 00:14:08,760
it does not correspond directly to the

00:14:05,700 --> 00:14:10,680
poppy schema for all this block def work

00:14:08,760 --> 00:14:12,600
we have a very strict copy schema which

00:14:10,680 --> 00:14:14,640
specifies exactly which options you can

00:14:12,600 --> 00:14:17,160
specify for which block driver which

00:14:14,640 --> 00:14:19,230
types they have and so on and - drive

00:14:17,160 --> 00:14:20,850
does not really care about that it just

00:14:19,230 --> 00:14:23,220
takes all the options and then passes

00:14:20,850 --> 00:14:25,650
them in the block layer and does it do

00:14:23,220 --> 00:14:27,630
what you need to do with that so that's

00:14:25,650 --> 00:14:29,580
not very good it also has some options

00:14:27,630 --> 00:14:32,670
which are which conflict with the

00:14:29,580 --> 00:14:34,410
options we have for this schema like it

00:14:32,670 --> 00:14:36,660
has a file option which obviously

00:14:34,410 --> 00:14:39,570
conflicts with the file option you can

00:14:36,660 --> 00:14:42,000
use for format nodes so that's rather

00:14:39,570 --> 00:14:45,030
bad it also has format probing which is

00:14:42,000 --> 00:14:47,550
a security issue so that's not that's

00:14:45,030 --> 00:14:50,790
not - nice - so all in all it's kind of

00:14:47,550 --> 00:14:52,950
a monstrosity it has a bunch of options

00:14:50,790 --> 00:14:55,560
and it tries to figure out what you want

00:14:52,950 --> 00:14:57,450
but just looking at them and tries to do

00:14:55,560 --> 00:14:59,340
the best of it which is not so good

00:14:57,450 --> 00:15:00,780
- blocked up instead looks at the

00:14:59,340 --> 00:15:02,370
options and if something is wrong it

00:15:00,780 --> 00:15:04,860
just gives you an error which is much

00:15:02,370 --> 00:15:07,290
better from an from our point of view as

00:15:04,860 --> 00:15:09,030
the ones who are implemented and also

00:15:07,290 --> 00:15:10,770
probably from a user's point of view

00:15:09,030 --> 00:15:14,850
because you don't get anything that you

00:15:10,770 --> 00:15:17,850
didn't expect finally if you specify

00:15:14,850 --> 00:15:19,380
anything but I have known for if' then

00:15:17,850 --> 00:15:21,000
it also creates a guest device along

00:15:19,380 --> 00:15:23,010
with the block tree which is not very

00:15:21,000 --> 00:15:25,080
nice because block layer and block

00:15:23,010 --> 00:15:26,750
devices are rather separate inside of

00:15:25,080 --> 00:15:29,880
queues so you probably want to use

00:15:26,750 --> 00:15:32,490
different parameters different common

00:15:29,880 --> 00:15:36,750
line parameters or qmp commands to use

00:15:32,490 --> 00:15:38,550
- also it it's better to specify all the

00:15:36,750 --> 00:15:41,640
options with - device for the guest

00:15:38,550 --> 00:15:43,740
device now if you use I have known then

00:15:41,640 --> 00:15:45,450
that - is an issue because it creates a

00:15:43,740 --> 00:15:47,880
block back and also it's kind of a hack

00:15:45,450 --> 00:15:49,290
and everything but first and foremost

00:15:47,880 --> 00:15:50,640
for you the important thing is that it

00:15:49,290 --> 00:15:51,620
creates a block packet and then you have

00:15:50,640 --> 00:15:54,390
to worry about it

00:15:51,620 --> 00:15:55,950
because you would have to give it a name

00:15:54,390 --> 00:15:57,540
you would have to give it an ID and then

00:15:55,950 --> 00:16:00,270
you would have to manage it and carry it

00:15:57,540 --> 00:16:01,770
around and that's just not good for you

00:16:00,270 --> 00:16:03,270
and that's just not good for QM you

00:16:01,770 --> 00:16:05,399
either because then we have to worry

00:16:03,270 --> 00:16:08,070
about the user having a reference to

00:16:05,399 --> 00:16:11,640
these internal objects and that's just

00:16:08,070 --> 00:16:14,040
not nice overall so there's Platov and

00:16:11,640 --> 00:16:15,330
device just created automatically so

00:16:14,040 --> 00:16:16,500
there you don't have to worry about we

00:16:15,330 --> 00:16:19,470
don't have to worry about it that's

00:16:16,500 --> 00:16:23,820
great with test drive we do so

00:16:19,470 --> 00:16:25,950
just don't use test drive any longer now

00:16:23,820 --> 00:16:28,350
for runtime configuration we've already

00:16:25,950 --> 00:16:31,170
seen blocked IFAD which is a form of

00:16:28,350 --> 00:16:33,480
runtime configuration and block to have

00:16:31,170 --> 00:16:35,700
Dell it's just the counterpart to that

00:16:33,480 --> 00:16:37,740
you can use it to delete trees you've

00:16:35,700 --> 00:16:38,820
created with block to that again there

00:16:37,740 --> 00:16:40,380
are some details on that

00:16:38,820 --> 00:16:43,410
I won't go further into it but if you

00:16:40,380 --> 00:16:47,579
want you can of course with slides later

00:16:43,410 --> 00:16:50,670
on and more interesting part is craft

00:16:47,579 --> 00:16:53,070
manipulation because that's in a sense

00:16:50,670 --> 00:16:54,630
it's new blocked a snapshot and

00:16:53,070 --> 00:16:56,760
especially blocked a snapshot sink are

00:16:54,630 --> 00:16:58,950
not very new but these are actually all

00:16:56,760 --> 00:17:01,110
the kinds of craft manipulation we

00:16:58,950 --> 00:17:03,360
already have let's say you have these

00:17:01,110 --> 00:17:05,220
two block trees which are just very

00:17:03,360 --> 00:17:07,500
simple you have some file node at the

00:17:05,220 --> 00:17:10,230
bottom and some kyouko to note on top so

00:17:07,500 --> 00:17:12,569
very simple change to interpret a queue

00:17:10,230 --> 00:17:15,720
go to image file and now you want to

00:17:12,569 --> 00:17:17,939
attach the right chain as the backing

00:17:15,720 --> 00:17:19,559
image of the left chain so what you

00:17:17,939 --> 00:17:22,140
would need to do is you attach the right

00:17:19,559 --> 00:17:23,850
you go to image as the backing child of

00:17:22,140 --> 00:17:26,540
the left hook or to image and you can do

00:17:23,850 --> 00:17:30,929
that just using block a snapshot and

00:17:26,540 --> 00:17:32,340
create this connection and that's it so

00:17:30,929 --> 00:17:33,990
this is already one form of graph

00:17:32,340 --> 00:17:35,880
manipulation but it's very limited you

00:17:33,990 --> 00:17:38,790
can only use it to attach back inside

00:17:35,880 --> 00:17:40,200
children and you can yeah you can only

00:17:38,790 --> 00:17:42,390
use it for backing children and you can

00:17:40,200 --> 00:17:43,980
only use it to attach them so we want to

00:17:42,390 --> 00:17:44,520
do you have something more flexible of

00:17:43,980 --> 00:17:47,520
course

00:17:44,520 --> 00:17:48,150
so what we've begun is called x-block

00:17:47,520 --> 00:17:49,830
turf change

00:17:48,150 --> 00:17:53,309
it's called expletive change because

00:17:49,830 --> 00:17:55,590
it's still very much experimental but

00:17:53,309 --> 00:17:57,660
you can also use it to add and remove

00:17:55,590 --> 00:17:59,280
children to or from a block node

00:17:57,660 --> 00:18:01,320
currently that's only possible for

00:17:59,280 --> 00:18:03,210
quorum but that's pretty much the same

00:18:01,320 --> 00:18:06,030
as what blocked a snapshot does it

00:18:03,210 --> 00:18:08,700
attaches another it attaches a node as

00:18:06,030 --> 00:18:10,980
the backing child of another node this

00:18:08,700 --> 00:18:11,490
would also allow it to remove the child

00:18:10,980 --> 00:18:13,170
again

00:18:11,490 --> 00:18:15,120
but unfortunately currently it's not

00:18:13,170 --> 00:18:17,970
implemented for backing children but

00:18:15,120 --> 00:18:20,809
only for quorum now the thing is that

00:18:17,970 --> 00:18:24,000
most children are not actually optional

00:18:20,809 --> 00:18:25,500
so poram supports any amount of children

00:18:24,000 --> 00:18:27,900
you can freely attach and detach

00:18:25,500 --> 00:18:30,960
children it's just some duplication

00:18:27,900 --> 00:18:32,910
driver so it's just in the most simple

00:18:30,960 --> 00:18:35,429
case it will just hand down requests

00:18:32,910 --> 00:18:38,880
from its parent to all the children and

00:18:35,429 --> 00:18:40,710
that's all it is but for instance in

00:18:38,880 --> 00:18:42,330
queue car to file always needs its file

00:18:40,710 --> 00:18:44,790
child it cannot function without because

00:18:42,330 --> 00:18:46,320
it needs some way or some place to store

00:18:44,790 --> 00:18:48,360
its metadata in some place to get its

00:18:46,320 --> 00:18:50,400
metadata form and that's how most

00:18:48,360 --> 00:18:52,860
children are you cannot detach them and

00:18:50,400 --> 00:18:56,070
attach them at will so what we actually

00:18:52,860 --> 00:18:58,050
would want is node replacement so that

00:18:56,070 --> 00:19:00,390
you could say you have some filter node

00:18:58,050 --> 00:19:03,030
and you want to attach it between a

00:19:00,390 --> 00:19:04,290
Cukor to node and it's file then that

00:19:03,030 --> 00:19:06,570
would mean that you would basically need

00:19:04,290 --> 00:19:08,809
to replace the file by the new filter

00:19:06,570 --> 00:19:12,120
we'll see an example of that in a second

00:19:08,809 --> 00:19:14,850
especially for this use case we also

00:19:12,120 --> 00:19:17,700
have a new proposal by miners on the

00:19:14,850 --> 00:19:19,050
upstream list called blocked of insert

00:19:17,700 --> 00:19:20,580
node and blocked off remove node and

00:19:19,050 --> 00:19:22,770
these commands would do exactly that

00:19:20,580 --> 00:19:25,410
you could use them to insert filter

00:19:22,770 --> 00:19:27,480
nodes into a chain or remove filter

00:19:25,410 --> 00:19:29,130
nodes from a chain let's just look at an

00:19:27,480 --> 00:19:31,140
example because that will make it easier

00:19:29,130 --> 00:19:32,970
so here's what I was talking about you

00:19:31,140 --> 00:19:35,190
have some parent node and some child

00:19:32,970 --> 00:19:38,309
node and we want to put a filter between

00:19:35,190 --> 00:19:40,410
the two now this is not a situation

00:19:38,309 --> 00:19:44,610
that's actually possible because usually

00:19:40,410 --> 00:19:46,440
the filter node will require a fire

00:19:44,610 --> 00:19:48,750
child before and you cannot just have

00:19:46,440 --> 00:19:51,179
created without any child just like you

00:19:48,750 --> 00:19:53,429
go to node it will always require a

00:19:51,179 --> 00:19:55,140
child node so this is actually the

00:19:53,429 --> 00:19:56,730
situation you start with you have parent

00:19:55,140 --> 00:19:57,960
child and then when you add the filter

00:19:56,730 --> 00:20:01,080
node it's already

00:19:57,960 --> 00:20:03,270
to the child and our blocked of

00:20:01,080 --> 00:20:05,490
internode would just do this it would

00:20:03,270 --> 00:20:09,090
put the filter between parent-child

00:20:05,490 --> 00:20:11,220
which is what we want but basically what

00:20:09,090 --> 00:20:13,230
you can see is all it does is replace

00:20:11,220 --> 00:20:17,250
the child by the filter node and nothing

00:20:13,230 --> 00:20:18,720
more so we can see that and blocked

00:20:17,250 --> 00:20:20,940
every move node would just do the

00:20:18,720 --> 00:20:22,770
opposite so you can see that this is

00:20:20,940 --> 00:20:26,070
actually just node replacement with

00:20:22,770 --> 00:20:28,260
various constraints on it which on one

00:20:26,070 --> 00:20:30,540
hand is good because you know if you do

00:20:28,260 --> 00:20:32,340
this operation you will always only

00:20:30,540 --> 00:20:33,870
insert a node because it gives you these

00:20:32,340 --> 00:20:36,030
constraints and it will arrow out if

00:20:33,870 --> 00:20:39,030
they're not met but on the other hand it

00:20:36,030 --> 00:20:40,950
means that for every use case of node

00:20:39,030 --> 00:20:44,280
replacement we have we would always have

00:20:40,950 --> 00:20:45,780
to create new commands so we're still in

00:20:44,280 --> 00:20:48,090
kind of a discussion whether we want

00:20:45,780 --> 00:20:49,890
this one single common expletive change

00:20:48,090 --> 00:20:52,620
which does everything which does every

00:20:49,890 --> 00:20:54,210
node replacement or whatever we want to

00:20:52,620 --> 00:20:59,480
have a multitude of Coburn's which can

00:20:54,210 --> 00:20:59,480
be used for everything you want to do

00:20:59,810 --> 00:21:03,780
now besides this explicit graph

00:21:02,070 --> 00:21:06,720
manipulation you also have implicit for

00:21:03,780 --> 00:21:09,300
F manipulation so whenever a block job

00:21:06,720 --> 00:21:11,220
completes it will do something with a

00:21:09,300 --> 00:21:12,570
graph or most lor chops at least for

00:21:11,220 --> 00:21:14,340
instance the mirror block job will

00:21:12,570 --> 00:21:16,290
replace the source node with the target

00:21:14,340 --> 00:21:17,820
node because that's what it does you

00:21:16,290 --> 00:21:19,680
copy the data over to the target and

00:21:17,820 --> 00:21:21,090
then once you're done you replace the

00:21:19,680 --> 00:21:23,520
source with the target and thereby

00:21:21,090 --> 00:21:27,060
continue using the target instead of the

00:21:23,520 --> 00:21:30,300
original file commit and stream depend

00:21:27,060 --> 00:21:31,920
on what they do it's details I decided

00:21:30,300 --> 00:21:35,970
to leave out here because mostly because

00:21:31,920 --> 00:21:37,740
it made it slight very full and the

00:21:35,970 --> 00:21:39,240
issue with that is if you want to have

00:21:37,740 --> 00:21:41,100
control over this whole graph if you

00:21:39,240 --> 00:21:42,480
actually created it from scratch with

00:21:41,100 --> 00:21:44,490
all the options and so on you probably

00:21:42,480 --> 00:21:47,370
don't want this implicit manipulation

00:21:44,490 --> 00:21:49,530
probably want to know exactly when what

00:21:47,370 --> 00:21:51,210
manipulation is going to happen so we're

00:21:49,530 --> 00:21:53,550
currently discussing or there have been

00:21:51,210 --> 00:21:55,590
some RC patches on introducing an option

00:21:53,550 --> 00:21:57,740
called persistent for now maybe it gets

00:21:55,590 --> 00:21:59,970
renamed later I don't know

00:21:57,740 --> 00:22:02,340
to prevent block shops from

00:21:59,970 --> 00:22:04,290
automatically exiting and automatically

00:22:02,340 --> 00:22:06,420
doing this graph manipulation so the

00:22:04,290 --> 00:22:07,950
block table runs it completes and then

00:22:06,420 --> 00:22:10,740
it would linger around basically as some

00:22:07,950 --> 00:22:11,720
kind of zombie and you would then call

00:22:10,740 --> 00:22:14,059
another expose

00:22:11,720 --> 00:22:17,030
command to delete or to reap the block

00:22:14,059 --> 00:22:18,919
job which would then result in this

00:22:17,030 --> 00:22:20,150
graph manipulation synchronously done so

00:22:18,919 --> 00:22:20,630
you know exactly when it's going to

00:22:20,150 --> 00:22:23,539
happen

00:22:20,630 --> 00:22:25,220
and speaking of block jobs they are

00:22:23,539 --> 00:22:27,650
actually going to have filter nodes now

00:22:25,220 --> 00:22:30,530
so for instance the old mirror block job

00:22:27,650 --> 00:22:32,900
looked like this you had some abstract a

00:22:30,530 --> 00:22:34,730
block job object which had references to

00:22:32,900 --> 00:22:36,230
to block backends one point to the

00:22:34,730 --> 00:22:38,150
source and one pointing to the target

00:22:36,230 --> 00:22:41,900
and then the data was copied over from

00:22:38,150 --> 00:22:44,570
source to target now it looks like this

00:22:41,900 --> 00:22:46,520
you have some explicit mirror node above

00:22:44,570 --> 00:22:48,710
the source and still these two block

00:22:46,520 --> 00:22:49,909
back ends which point to both the source

00:22:48,710 --> 00:22:52,039
and the target chain and the data gets

00:22:49,909 --> 00:22:56,210
copied over so now we have this implicit

00:22:52,039 --> 00:22:57,590
node and I hope that in the future will

00:22:56,210 --> 00:23:00,740
actually look like this where you have

00:22:57,590 --> 00:23:02,510
some mirror node that basically does all

00:23:00,740 --> 00:23:05,179
the work and you just have the block top

00:23:02,510 --> 00:23:07,010
which only references this one node and

00:23:05,179 --> 00:23:09,110
this node actually does all the work of

00:23:07,010 --> 00:23:12,500
copying source to the target let's see

00:23:09,110 --> 00:23:15,200
how far we can get with that but the

00:23:12,500 --> 00:23:17,179
thing is that if you again if you

00:23:15,200 --> 00:23:19,580
specify all the options and you want to

00:23:17,179 --> 00:23:23,000
have full control over the whole block

00:23:19,580 --> 00:23:26,240
graph then you probably want to have

00:23:23,000 --> 00:23:27,770
control over this too so now you can

00:23:26,240 --> 00:23:29,900
actually name this node that's

00:23:27,770 --> 00:23:31,370
introduced which is also a way to detect

00:23:29,900 --> 00:23:33,590
whether this node is introduced because

00:23:31,370 --> 00:23:35,210
at the same time the mirror job was

00:23:33,590 --> 00:23:37,580
given the option of naming this node and

00:23:35,210 --> 00:23:39,740
you probably should do so so that you

00:23:37,580 --> 00:23:44,090
can later identify it and do things with

00:23:39,740 --> 00:23:49,580
it and with that my person and I'll hand

00:23:44,090 --> 00:23:52,250
over to Kevin right so we have seen

00:23:49,580 --> 00:23:54,260
quite a few things in the block layer

00:23:52,250 --> 00:23:58,370
mostly about the notes but there's more

00:23:54,260 --> 00:24:00,380
going on in the block graph and that's

00:23:58,370 --> 00:24:03,890
specifically with op talkers as they

00:24:00,380 --> 00:24:06,230
used to be called it's now a bit

00:24:03,890 --> 00:24:09,710
different but let's start at the

00:24:06,230 --> 00:24:13,460
beginning so max showed us quite a few

00:24:09,710 --> 00:24:16,159
users of block nodes already one of them

00:24:13,460 --> 00:24:18,640
are the parent nodes we have to block

00:24:16,159 --> 00:24:21,710
backends and we also saw block jobs

00:24:18,640 --> 00:24:24,169
there are a few more users that happen

00:24:21,710 --> 00:24:25,890
in practice like just qmp Monisha

00:24:24,169 --> 00:24:30,600
commands for example

00:24:25,890 --> 00:24:37,080
or we have MBD server within qme which

00:24:30,600 --> 00:24:39,540
successes nodes and the thing is not all

00:24:37,080 --> 00:24:42,990
of them don't work very well together so

00:24:39,540 --> 00:24:46,170
if you use two of them on the same node

00:24:42,990 --> 00:24:50,600
they might conflict in some way for

00:24:46,170 --> 00:24:54,570
example if you have a guest device which

00:24:50,600 --> 00:24:56,670
uses a node as its hard disk that guest

00:24:54,570 --> 00:24:59,640
probably doesn't expect something

00:24:56,670 --> 00:25:01,110
external to modify its disk except if

00:24:59,640 --> 00:25:02,850
it's using a classify system maybe it

00:25:01,110 --> 00:25:05,840
would work but in the most common case

00:25:02,850 --> 00:25:05,840
it doesn't work

00:25:05,960 --> 00:25:14,490
also most block jobs create some kind of

00:25:11,000 --> 00:25:17,040
bitmap or something at the beginning and

00:25:14,490 --> 00:25:20,940
currently they don't support to resize a

00:25:17,040 --> 00:25:22,530
node while they are running this is just

00:25:20,940 --> 00:25:27,600
meeting in the implementation but just

00:25:22,530 --> 00:25:30,179
currently those are not compatible what

00:25:27,600 --> 00:25:33,270
else yeah if you have a commit job and

00:25:30,179 --> 00:25:34,980
you commit down across you know it's to

00:25:33,270 --> 00:25:37,920
the backing file you commit down the

00:25:34,980 --> 00:25:39,450
newer data to the backing file several

00:25:37,920 --> 00:25:42,630
layers below it

00:25:39,450 --> 00:25:45,210
the image is in between don't make any

00:25:42,630 --> 00:25:47,100
sense anymore because they they will

00:25:45,210 --> 00:25:49,500
present some data that is the mixture

00:25:47,100 --> 00:25:54,000
between the old state and then your

00:25:49,500 --> 00:25:58,110
state that were committing back so while

00:25:54,000 --> 00:26:01,080
we killed in theory that all these

00:25:58,110 --> 00:26:04,950
things run on the same note it doesn't

00:26:01,080 --> 00:26:07,200
make sense it they're conflicting and we

00:26:04,950 --> 00:26:11,580
want to protect against that so the very

00:26:07,200 --> 00:26:13,980
first thing we did was we introduced a

00:26:11,580 --> 00:26:18,300
simple flag at each node which just told

00:26:13,980 --> 00:26:21,660
out this is in use don't touch this and

00:26:18,300 --> 00:26:28,230
actually I think I just skipped some

00:26:21,660 --> 00:26:34,560
slides so if we start a merge job we set

00:26:28,230 --> 00:26:36,920
the flag in years and then if we say in

00:26:34,560 --> 00:26:39,549
the monitor I want to resize this image

00:26:36,920 --> 00:26:41,649
the resize command would

00:26:39,549 --> 00:26:46,049
check is this image in use if it's in

00:26:41,649 --> 00:26:56,169
use we don't do it we return error and

00:26:46,049 --> 00:26:59,710
well there's no conflict so we set this

00:26:56,169 --> 00:27:02,619
in use flag for everything that we

00:26:59,710 --> 00:27:06,460
thought might conflict with each other

00:27:02,619 --> 00:27:08,679
so really usually blocking too much

00:27:06,460 --> 00:27:14,529
because some of these operations could

00:27:08,679 --> 00:27:15,789
actually be compatible but if it's it's

00:27:14,529 --> 00:27:18,279
conflicting with a different operation

00:27:15,789 --> 00:27:20,980
we just said have to set the in use so

00:27:18,279 --> 00:27:23,159
that this is protected so we're we're

00:27:20,980 --> 00:27:26,080
too restrictive and at the same time

00:27:23,159 --> 00:27:29,379
some things aren't we're not protected

00:27:26,080 --> 00:27:32,139
with lien use flag like guest devices

00:27:29,379 --> 00:27:34,989
because if you can't use the operation

00:27:32,139 --> 00:27:38,019
while the the same image is used as a

00:27:34,989 --> 00:27:40,869
gate as a guest device that makes the

00:27:38,019 --> 00:27:42,789
operation completely useless so at the

00:27:40,869 --> 00:27:46,720
same time while it's too strict it's

00:27:42,789 --> 00:27:51,419
also not strict enough so it wasn't the

00:27:46,720 --> 00:27:53,769
optimal solution next thing we did was

00:27:51,419 --> 00:27:56,440
well then we'll just distinguish

00:27:53,769 --> 00:27:57,909
different operations and then tell for

00:27:56,440 --> 00:27:58,389
each one separately whether you can do

00:27:57,909 --> 00:28:04,389
it now

00:27:58,389 --> 00:28:08,409
or whether you can't so for example the

00:28:04,389 --> 00:28:11,220
resize would be an option and other

00:28:08,409 --> 00:28:14,259
operations such as doing a block job

00:28:11,220 --> 00:28:18,029
would be a separate operation and it

00:28:14,259 --> 00:28:18,029
could be plot and unblocked separately

00:28:18,960 --> 00:28:26,320
so when the mirror block job starts any

00:28:24,820 --> 00:28:28,600
wants to protect against resizing

00:28:26,320 --> 00:28:30,639
because it just relies on the initial

00:28:28,600 --> 00:28:34,470
value it stores it internally and you

00:28:30,639 --> 00:28:37,899
can't handle a resize of the disk

00:28:34,470 --> 00:28:40,200
they can just set the resize blocker

00:28:37,899 --> 00:28:43,419
badly for example the commit blocker

00:28:40,200 --> 00:28:47,289
unset so you could still do a commit

00:28:43,419 --> 00:28:50,919
block show at the same time so resize

00:28:47,289 --> 00:28:52,320
would still check whether the resize

00:28:50,919 --> 00:28:55,980
blocker is set

00:28:52,320 --> 00:28:57,840
and would fail appropriately and a

00:28:55,980 --> 00:29:00,810
different operation could still succeed

00:28:57,840 --> 00:29:03,450
because it's using a different blocker

00:29:00,810 --> 00:29:09,210
because it's well we have blockers for

00:29:03,450 --> 00:29:12,060
each separate operation in practice this

00:29:09,210 --> 00:29:15,360
didn't quite work out because it means

00:29:12,060 --> 00:29:18,840
that every place that needs to be

00:29:15,360 --> 00:29:22,320
protected needs to know which other

00:29:18,840 --> 00:29:24,420
operation conflicts with it and this

00:29:22,320 --> 00:29:27,000
also means it needs to know about all

00:29:24,420 --> 00:29:30,180
operations that even exist and if we add

00:29:27,000 --> 00:29:34,230
a new operation we have to amend all of

00:29:30,180 --> 00:29:37,470
these places which we never did in

00:29:34,230 --> 00:29:39,540
practice in practice we just block

00:29:37,470 --> 00:29:43,170
everything so we were back to the old

00:29:39,540 --> 00:29:48,990
state was not quite what we wanted to

00:29:43,170 --> 00:29:51,240
achieve with the system also the the up

00:29:48,990 --> 00:29:53,910
blockers were usually only added for the

00:29:51,240 --> 00:29:56,340
root node so that's where we protected

00:29:53,910 --> 00:30:03,270
things because most monitor commands

00:29:56,340 --> 00:30:07,230
only only worked at a root so it's not

00:30:03,270 --> 00:30:11,190
quite how the plot layer works today we

00:30:07,230 --> 00:30:14,510
need something different and the

00:30:11,190 --> 00:30:16,890
different system that we're using now

00:30:14,510 --> 00:30:18,960
it's basically a permission system that

00:30:16,890 --> 00:30:21,840
we have built in into the graph it's

00:30:18,960 --> 00:30:26,100
it's now a core aspect of the block

00:30:21,840 --> 00:30:29,130
graph and it works this way you just

00:30:26,100 --> 00:30:32,220
define a set of low-level operations

00:30:29,130 --> 00:30:35,550
that you need and you define a set of

00:30:32,220 --> 00:30:37,860
other low-level know the same kind of

00:30:35,550 --> 00:30:45,510
low-level operations that other users

00:30:37,860 --> 00:30:48,750
can use while you're active so we have a

00:30:45,510 --> 00:30:51,690
small set of operations of low-level

00:30:48,750 --> 00:30:54,330
operations that you can use for

00:30:51,690 --> 00:30:56,520
permissions that's basically I want to

00:30:54,330 --> 00:31:00,630
write that's the most important one I

00:30:56,520 --> 00:31:05,100
want to write to a node and I can

00:31:00,630 --> 00:31:05,940
tolerate riders to the same node we also

00:31:05,100 --> 00:31:13,200
have reason

00:31:05,940 --> 00:31:14,880
we have a consistent rate which is well

00:31:13,200 --> 00:31:17,130
you can read from a note without having

00:31:14,880 --> 00:31:20,730
a consistent read permission

00:31:17,130 --> 00:31:21,900
the consistent read main means that the

00:31:20,730 --> 00:31:23,880
content of the image actually makes

00:31:21,900 --> 00:31:27,890
sense so that's exactly the case with

00:31:23,880 --> 00:31:27,890
the commit job that I mentioned earlier

00:31:28,310 --> 00:31:35,610
so the intermediate nodes of a commit

00:31:31,110 --> 00:31:47,010
job don't allow anyone to consistent

00:31:35,610 --> 00:31:49,710
read from it so instead of just being

00:31:47,010 --> 00:31:53,280
tacked on on the nodes like the the opt

00:31:49,710 --> 00:31:55,890
lockers before or the in use flag this

00:31:53,280 --> 00:31:58,020
is made a mandatory core concept because

00:31:55,890 --> 00:32:01,140
in the old system it was easy to just

00:31:58,020 --> 00:32:04,430
forget to block operations or to forget

00:32:01,140 --> 00:32:07,710
to check whether someone else is using

00:32:04,430 --> 00:32:09,570
the node and that could be conflicting

00:32:07,710 --> 00:32:12,780
so now it's a mandatory core concept

00:32:09,570 --> 00:32:15,690
when you take a reference to a node when

00:32:12,780 --> 00:32:19,230
you're attaching it to something you

00:32:15,690 --> 00:32:22,920
have to specify which operations do I

00:32:19,230 --> 00:32:25,620
want to do on this node and which

00:32:22,920 --> 00:32:29,420
operations can I tolerate that others do

00:32:25,620 --> 00:32:35,730
on the same node while I'm active and

00:32:29,420 --> 00:32:37,320
this is actually checked so if you write

00:32:35,730 --> 00:32:41,010
to a node without getting the right

00:32:37,320 --> 00:32:43,950
permission first you will crash it we do

00:32:41,010 --> 00:32:47,220
assert that the the permissions are

00:32:43,950 --> 00:32:49,620
taking so you're actually forced to say

00:32:47,220 --> 00:32:51,510
what you're doing because you can't get

00:32:49,620 --> 00:32:53,430
a reference to a node otherwise you

00:32:51,510 --> 00:32:57,750
can't attach a note to it to a different

00:32:53,430 --> 00:32:59,340
node when you don't say explicitly what

00:32:57,750 --> 00:33:03,630
permissions you want and what you can

00:32:59,340 --> 00:33:05,130
tolerate from others and if you give the

00:33:03,630 --> 00:33:07,110
wrong set of permissions there are

00:33:05,130 --> 00:33:11,250
chances that assertions will catch it

00:33:07,110 --> 00:33:13,650
and you will crash so this is much

00:33:11,250 --> 00:33:16,730
harder to forget to actually use so it

00:33:13,650 --> 00:33:16,730
becomes a core concept

00:33:19,280 --> 00:33:26,850
also the user almost never needs to do

00:33:24,840 --> 00:33:30,299
anything about that hmm

00:33:26,850 --> 00:33:34,400
because Kimmy already knows like for

00:33:30,299 --> 00:33:38,340
example if you have a former driver node

00:33:34,400 --> 00:33:40,530
which accesses the image file node Jamie

00:33:38,340 --> 00:33:44,419
knows what the the format driver will

00:33:40,530 --> 00:33:46,950
need so usually doesn't have to specify

00:33:44,419 --> 00:33:50,240
what kind of permissions it needs

00:33:46,950 --> 00:33:53,460
because there was an idea that was often

00:33:50,240 --> 00:33:56,880
that came up when when in the context of

00:33:53,460 --> 00:34:00,929
image locking that users would specify

00:33:56,880 --> 00:34:02,580
it on each node what permissions to take

00:34:00,929 --> 00:34:04,350
and that's not necessary because Jamie

00:34:02,580 --> 00:34:07,049
knows about it there's only one case

00:34:04,350 --> 00:34:11,220
where km can't now and that's guest

00:34:07,049 --> 00:34:15,740
devices because it depends on the guest

00:34:11,220 --> 00:34:15,740
really the guest could be okay with

00:34:16,010 --> 00:34:22,470
other processes writing to to the same

00:34:19,409 --> 00:34:25,909
disk in the background for example if

00:34:22,470 --> 00:34:25,909
it's running a class to file system but

00:34:26,179 --> 00:34:33,179
usually the guest isn't okay with it and

00:34:29,090 --> 00:34:34,740
so that becomes an option of the of the

00:34:33,179 --> 00:34:37,710
the common block devices like rogue a

00:34:34,740 --> 00:34:40,230
block you can share it right property

00:34:37,710 --> 00:34:48,720
and you can set it to own if you want to

00:34:40,230 --> 00:34:53,359
allow sharing so let's do this and

00:34:48,720 --> 00:34:57,090
create example this is just a simple

00:34:53,359 --> 00:35:01,530
block graph disk and a backing file like

00:34:57,090 --> 00:35:04,170
we had before and now we have the

00:35:01,530 --> 00:35:08,790
permissions on all of the edges so if we

00:35:04,170 --> 00:35:11,340
start on left top I'll retire block

00:35:08,790 --> 00:35:15,000
device wants to read from the disk and

00:35:11,340 --> 00:35:18,270
wants to write to the disk and it can

00:35:15,000 --> 00:35:20,340
allow others to read sure no problem

00:35:18,270 --> 00:35:23,130
they can also resize because rivero

00:35:20,340 --> 00:35:24,540
block reacts to two resizes so it

00:35:23,130 --> 00:35:28,890
communicates it to the guest so that's

00:35:24,540 --> 00:35:31,440
okay but it doesn't allow usually others

00:35:28,890 --> 00:35:36,620
to write to the image

00:35:31,440 --> 00:35:39,480
yes we have said share equals off and

00:35:36,620 --> 00:35:43,290
then the permission is basically

00:35:39,480 --> 00:35:45,380
propagated through the graph but they do

00:35:43,290 --> 00:35:47,850
change according to to the note what

00:35:45,380 --> 00:35:50,880
yeah to the requirements of each note

00:35:47,850 --> 00:35:54,090
for example the q2 driver will need to

00:35:50,880 --> 00:35:57,540
resize the image because it's sparse

00:35:54,090 --> 00:36:04,140
format so the image file might grow we

00:35:57,540 --> 00:36:06,690
require to resize the backing file we

00:36:04,140 --> 00:36:08,700
only need to read no problem there we

00:36:06,690 --> 00:36:12,330
can't allow others to write because it

00:36:08,700 --> 00:36:17,220
will modify data that we're seeing so

00:36:12,330 --> 00:36:17,900
for example if we're going to and a

00:36:17,220 --> 00:36:25,230
second

00:36:17,900 --> 00:36:28,410
Verdejo block device this won't work

00:36:25,230 --> 00:36:31,080
because a second device wants to write

00:36:28,410 --> 00:36:36,200
to the same node and we said we don't

00:36:31,080 --> 00:36:36,200
allow others to write to the same node

00:36:36,320 --> 00:36:41,460
we can make it read-only still doesn't

00:36:39,120 --> 00:36:45,420
work because the first one wants to

00:36:41,460 --> 00:36:49,380
write and we have share equals off on a

00:36:45,420 --> 00:36:58,050
second one as well but if we may both

00:36:49,380 --> 00:37:02,370
read-only then we can add that or we can

00:36:58,050 --> 00:37:04,080
say we share it in that case

00:37:02,370 --> 00:37:06,510
what actually happens is that Verdejo

00:37:04,080 --> 00:37:10,950
block says if someone else writes to

00:37:06,510 --> 00:37:15,210
this image that's okay as you see on the

00:37:10,950 --> 00:37:17,190
bottom the disk dot file still cannot be

00:37:15,210 --> 00:37:19,340
written to by another process because

00:37:17,190 --> 00:37:22,770
 two can't tolerate anyone else

00:37:19,340 --> 00:37:26,040
because of its metadata it would yeah

00:37:22,770 --> 00:37:28,770
cause corruption but the backing file is

00:37:26,040 --> 00:37:34,140
now allowed to be written to as well so

00:37:28,770 --> 00:37:36,750
I could attach something there attaching

00:37:34,140 --> 00:37:40,940
the second forego block just works fine

00:37:36,750 --> 00:37:43,410
now so

00:37:40,940 --> 00:37:45,239
why would I attach a second Verdejo

00:37:43,410 --> 00:37:49,589
block it doesn't make a whole lot of

00:37:45,239 --> 00:37:52,079
sense within one process but we have

00:37:49,589 --> 00:37:55,950
image locking which extends this across

00:37:52,079 --> 00:37:59,579
several key ma processes which means

00:37:55,950 --> 00:38:00,930
that we're used for six locking no we

00:37:59,579 --> 00:38:04,079
use open file descriptor locking

00:38:00,930 --> 00:38:06,200
positive locking isn't quite enough that

00:38:04,079 --> 00:38:11,539
is relatively new in Linux but it works

00:38:06,200 --> 00:38:14,930
so we propagate these the permissions

00:38:11,539 --> 00:38:18,029
into locked bytes in the image file so

00:38:14,930 --> 00:38:22,230
that a second carry process will see the

00:38:18,029 --> 00:38:24,450
same and then if I start a second kami

00:38:22,230 --> 00:38:25,950
process that's accessing the same image

00:38:24,450 --> 00:38:28,950
that's basically the second relay or

00:38:25,950 --> 00:38:30,960
block node for the o block device that I

00:38:28,950 --> 00:38:34,049
just have and then it actually makes

00:38:30,960 --> 00:38:40,200
sense and it will prevent this from

00:38:34,049 --> 00:38:42,960
happening so if things go wrong with

00:38:40,200 --> 00:38:45,119
locking first try if you have said the

00:38:42,960 --> 00:38:49,680
sharp share it right property correctly

00:38:45,119 --> 00:38:52,410
if you haven't well that's probably the

00:38:49,680 --> 00:38:55,470
cause of your failure if that is set

00:38:52,410 --> 00:38:58,019
correctly and you get errors from the

00:38:55,470 --> 00:39:02,279
permission system you're probably doing

00:38:58,019 --> 00:39:04,259
something dangerous in some cases you

00:39:02,279 --> 00:39:05,160
might decide that I'm doing only a

00:39:04,259 --> 00:39:09,480
read-only access

00:39:05,160 --> 00:39:12,930
I don't care someone else's writing I

00:39:09,480 --> 00:39:14,910
know I might get corrupted data it's not

00:39:12,930 --> 00:39:20,099
that important then you can use the

00:39:14,910 --> 00:39:23,849
fourth share option for block nodes they

00:39:20,099 --> 00:39:27,630
basically they don't remove the the

00:39:23,849 --> 00:39:32,999
permissions that you take bad days the

00:39:27,630 --> 00:39:40,829
force on yeah they force basically the

00:39:32,999 --> 00:39:42,269
node to tolerate any other access no

00:39:40,829 --> 00:39:47,369
matter what the parents of the node

00:39:42,269 --> 00:39:49,849
actually requested and if all else fails

00:39:47,369 --> 00:39:54,990
you can use the locking equals of

00:39:49,849 --> 00:39:57,060
options for file nodes so far I haven't

00:39:54,990 --> 00:40:03,900
in a single use case that actually

00:39:57,060 --> 00:40:06,210
needed this okay and third part is kind

00:40:03,900 --> 00:40:08,130
of a summary so what should management

00:40:06,210 --> 00:40:12,090
tools actually do now with all the

00:40:08,130 --> 00:40:17,460
changes that we made we had the block

00:40:12,090 --> 00:40:20,360
packing names well don't use their

00:40:17,460 --> 00:40:24,780
strife ids anymore

00:40:20,360 --> 00:40:30,540
you have no names GF device names in qmp

00:40:24,780 --> 00:40:33,210
commands use well all commands that

00:40:30,540 --> 00:40:37,470
previously took block packing names that

00:40:33,210 --> 00:40:40,350
is Drive IDs they either take node names

00:40:37,470 --> 00:40:44,640
now or they take if their motive right

00:40:40,350 --> 00:40:51,410
device related they take qdf IDs so use

00:40:44,640 --> 00:40:58,920
that also stop using their strife at all

00:40:51,410 --> 00:41:02,640
use block def instead filter nodes we

00:40:58,920 --> 00:41:05,280
can get filter nodes automatically make

00:41:02,640 --> 00:41:11,070
sure that you manage them manually

00:41:05,280 --> 00:41:14,070
because if you don't if you don't assign

00:41:11,070 --> 00:41:15,690
names for example manually you won't be

00:41:14,070 --> 00:41:18,060
able to manage that part of the graph

00:41:15,690 --> 00:41:20,310
you you won't be able to even address if

00:41:18,060 --> 00:41:25,380
you want to change something at that

00:41:20,310 --> 00:41:27,210
point in the graph try to use for

00:41:25,380 --> 00:41:30,270
example the iris sorting filter node

00:41:27,210 --> 00:41:34,380
instead of using the the old test drive

00:41:30,270 --> 00:41:36,900
throttling options because the the the

00:41:34,380 --> 00:41:39,270
stripe options will create an automatic

00:41:36,900 --> 00:41:45,480
node and you don't just have the control

00:41:39,270 --> 00:41:47,690
over it that you want to have same thing

00:41:45,480 --> 00:41:55,680
for block shops block shops insert

00:41:47,690 --> 00:41:58,290
filter craft filter nodes and well you

00:41:55,680 --> 00:42:02,070
want to manage them so give them a name

00:41:58,290 --> 00:42:03,720
also once we actually implement the the

00:42:02,070 --> 00:42:07,440
explicit job deletion make use of it

00:42:03,720 --> 00:42:08,549
because otherwise you get surprised

00:42:07,440 --> 00:42:11,640
changes in the graph

00:42:08,549 --> 00:42:14,579
and that will be really nasty to manage

00:42:11,640 --> 00:42:16,499
especially if you're doing other craft

00:42:14,579 --> 00:42:21,269
manipulations like inserting filters

00:42:16,499 --> 00:42:22,859
which as max told us it's really two

00:42:21,269 --> 00:42:26,279
steps creating the new filter node and

00:42:22,859 --> 00:42:30,630
then inserting it into the existing edge

00:42:26,279 --> 00:42:35,579
and that could lead to race conditions

00:42:30,630 --> 00:42:37,739
if you have automatic block block job

00:42:35,579 --> 00:42:43,140
completion and it's a surprise changes

00:42:37,739 --> 00:42:46,709
to the graph so do things manually and

00:42:43,140 --> 00:42:49,650
finally the permissions well just avoid

00:42:46,709 --> 00:42:51,689
dangerous setups if you can make sure

00:42:49,650 --> 00:42:56,819
that you said the share readwrite

00:42:51,689 --> 00:43:00,569
property correctly avoid the other two

00:42:56,819 --> 00:43:03,599
options that exist if you can at all and

00:43:00,569 --> 00:43:07,439
if you must then prefer the four share

00:43:03,599 --> 00:43:09,449
node option because that at least

00:43:07,439 --> 00:43:11,729
doesn't turn off the locking completely

00:43:09,449 --> 00:43:14,339
so it still guarantee yes yeah gives you

00:43:11,729 --> 00:43:18,209
some safety at least it's not good but

00:43:14,339 --> 00:43:20,759
at least some safety and well if you

00:43:18,209 --> 00:43:23,729
must you can turn off locking as I said

00:43:20,759 --> 00:43:29,279
I have so far never seen a case where

00:43:23,729 --> 00:43:30,749
this is really necessary so if you think

00:43:29,279 --> 00:43:39,319
you must turn off locking think twice

00:43:30,749 --> 00:43:39,319
and that's it so any questions

00:43:40,540 --> 00:43:43,680
in the back

00:43:52,540 --> 00:43:58,780
I have two questions so the first

00:43:55,840 --> 00:44:02,230
question is do we recommend the user use

00:43:58,780 --> 00:44:04,630
the no name instead of the file name to

00:44:02,230 --> 00:44:07,720
specify their target and the second

00:44:04,630 --> 00:44:10,840
question is we have dry Miro and dry

00:44:07,720 --> 00:44:13,570
pack up and we also have a block the

00:44:10,840 --> 00:44:16,840
mirror and block the backup so two

00:44:13,570 --> 00:44:20,440
implants you replace one by another or

00:44:16,840 --> 00:44:23,700
if not which one is recommended to the

00:44:20,440 --> 00:44:23,700
user thank you

00:44:25,120 --> 00:44:30,910
the second question yes blocked if

00:44:28,300 --> 00:44:32,620
backup is the new one the the issue with

00:44:30,910 --> 00:44:34,600
Drive backup is that it just takes a

00:44:32,620 --> 00:44:36,580
file name again and that it all that's

00:44:34,600 --> 00:44:38,950
all does everything automatically

00:44:36,580 --> 00:44:40,780
creates the file opens it and everything

00:44:38,950 --> 00:44:42,220
well if it's blocked F backup it's your

00:44:40,780 --> 00:44:45,070
responsibility to create the fire and

00:44:42,220 --> 00:44:46,870
then open it in qmu so that's the more

00:44:45,070 --> 00:44:48,370
modern way to go forward and I think in

00:44:46,870 --> 00:44:50,680
qmu three-door we're thinking about

00:44:48,370 --> 00:44:58,330
deprecating Drive marrow and Drive

00:44:50,680 --> 00:45:03,420
backup and the first question was about

00:44:58,330 --> 00:45:06,040
node names for didn't quite get it was

00:45:03,420 --> 00:45:14,980
noting for a target node from the mirror

00:45:06,040 --> 00:45:18,550
operation or so we can space for our

00:45:14,980 --> 00:45:22,120
target by both no name and the file name

00:45:18,550 --> 00:45:27,940
right so which one is recommended to the

00:45:22,120 --> 00:45:33,250
user you specify the target by a node

00:45:27,940 --> 00:45:36,400
name in or we can specify the target yes

00:45:33,250 --> 00:45:40,570
with no name your file name right

00:45:36,400 --> 00:45:42,220
yes so which one is recommended well

00:45:40,570 --> 00:45:44,200
block death backups replica commit or

00:45:42,220 --> 00:45:46,450
using the node name always is now

00:45:44,200 --> 00:45:47,980
recommended if you think every

00:45:46,450 --> 00:45:49,720
everything you specify in the block

00:45:47,980 --> 00:45:53,770
graph should please specified using the

00:45:49,720 --> 00:45:55,270
node name and if you specify something

00:45:53,770 --> 00:45:58,650
on the device level then you would need

00:45:55,270 --> 00:46:01,210
to use the one path to the device or the

00:45:58,650 --> 00:46:02,680
idea of the device but everything in the

00:46:01,210 --> 00:46:05,320
block layer should now be specified

00:46:02,680 --> 00:46:06,520
using the node name as possible and if

00:46:05,320 --> 00:46:11,520
it's not possible is probably

00:46:06,520 --> 00:46:11,520
and we should fix it okay thank you

00:46:26,230 --> 00:46:31,390
should we honor to change the approach

00:46:28,690 --> 00:46:34,030
for image management pass right now we

00:46:31,390 --> 00:46:37,920
have cui I am G which is doing most of

00:46:34,030 --> 00:46:41,160
the work maybe it would be wise to move

00:46:37,920 --> 00:46:44,680
image management to live birth level and

00:46:41,160 --> 00:46:46,870
start human process to perform actual

00:46:44,680 --> 00:46:50,620
block iteration if there was no way

00:46:46,870 --> 00:47:02,290
Iranian Iranian version will be handled

00:46:50,620 --> 00:47:06,910
by you that you want to move the

00:47:02,290 --> 00:47:09,580
management from Kim you to know I'm sure

00:47:06,910 --> 00:47:12,970
which is doing a lot of work yes it

00:47:09,580 --> 00:47:19,920
manipulates images but this working this

00:47:12,970 --> 00:47:22,630
becomes a problem and yeah it's a

00:47:19,920 --> 00:47:25,270
problem because this allows images not

00:47:22,630 --> 00:47:29,320
to be corrupted yeah but maybe they need

00:47:25,270 --> 00:47:32,830
some automation in Leopard which checks

00:47:29,320 --> 00:47:36,760
but there is no VM if there is no Runyan

00:47:32,830 --> 00:47:40,330
it starts and decayed image manipulation

00:47:36,760 --> 00:47:42,250
routines where so you think instead of

00:47:40,330 --> 00:47:44,590
the permission system in km you lip-read

00:47:42,250 --> 00:47:47,830
should already be doing that right they

00:47:44,590 --> 00:47:50,200
should have the mission system then you

00:47:47,830 --> 00:47:54,120
just it's very good what they have it

00:47:50,200 --> 00:47:57,270
they do but it's not enough because many

00:47:54,120 --> 00:48:02,020
many times that we saw a corruption

00:47:57,270 --> 00:48:04,810
reported the reason was that while the

00:48:02,020 --> 00:48:07,200
VM was run by Lippert someone else is

00:48:04,810 --> 00:48:10,150
chemi oMG manually on the same image

00:48:07,200 --> 00:48:11,650
okay and that just broke the image so we

00:48:10,150 --> 00:48:14,730
needed something on the key mu level so

00:48:11,650 --> 00:48:17,380
that GME IMG would already refused to

00:48:14,730 --> 00:48:22,540
touch an image that is in use by Lippert

00:48:17,380 --> 00:48:26,830
a Lippert can't do anything about it I

00:48:22,540 --> 00:48:29,470
propose to move I want to discuss moving

00:48:26,830 --> 00:48:33,520
of management layer in which we

00:48:29,470 --> 00:48:35,830
pollution routines to revert level

00:48:33,520 --> 00:48:39,119
provide similar functionality in which

00:48:35,830 --> 00:48:41,380
instead of running when your iam OMG

00:48:39,119 --> 00:48:43,599
because it's dangerous as you have said

00:48:41,380 --> 00:48:47,200
well yes that would be preferable but

00:48:43,599 --> 00:48:49,300
users still use qmz manually so that's

00:48:47,200 --> 00:48:51,520
the reason why we had to implement it

00:48:49,300 --> 00:48:53,380
yeah I think even if you if you provided

00:48:51,520 --> 00:48:56,970
the way inverse to actually do these

00:48:53,380 --> 00:48:59,170
things without using key mu mg manually

00:48:56,970 --> 00:49:00,940
users are used to the way they're doing

00:48:59,170 --> 00:49:04,930
things today they will keep doing this

00:49:00,940 --> 00:49:09,820
so even if you did it I think it

00:49:04,930 --> 00:49:12,250
wouldn't fully solve the problem okay

00:49:09,820 --> 00:49:14,730
thank you so we are out of time so any

00:49:12,250 --> 00:49:14,730
questions

00:49:17,830 --> 00:49:24,949
[Applause]

00:49:19,100 --> 00:49:24,949

YouTube URL: https://www.youtube.com/watch?v=9-CA7M8C7wI


