Title: [2016] Dirty Memory Tracking for Performant Checkpointing Solutions by Lei Cao
Publication date: 2016-09-05
Playlist: KVM Forum 2016
Description: 
	There are bottlenecks and limitations in KVM that hamper the performance of a checkpoint/rollback system, namely use of large bitmaps to track dirty memory and lack of multi thread support due to mmu lock implementation. In this presentation, I will discuss a new dirty memory tracking mechanism that improves the performance of checkpoint/rollback implementations for commercial production. This new mechanism can also be used to improve the predictability of live migration of memory write intensive workloads.


Lei Cao
Stratus Technologies

I work for Stratus Technologies, a company that specializes in fault tolerant hardware and software solutions. I am currently working on our fault tolerant software product.


Slides: http://www.linux-kvm.org/images/d/d8/02x05A-Lei_Cao-Dirti_Memory_Tracking_for_Performant_Checkpointing_Solutions.pdf
Captions: 
	00:00:10,099 --> 00:00:19,260
everyone sorry about the delay currently

00:00:12,630 --> 00:00:25,199
have outdated laptop so my name is late

00:00:19,260 --> 00:00:29,220
i work for Stratis technology so this

00:00:25,199 --> 00:00:33,360
plantation talk about some set of

00:00:29,220 --> 00:00:37,100
changes that we propose to the kvm dirty

00:00:33,360 --> 00:00:42,120
memory tracking mechanism to facilitate

00:00:37,100 --> 00:00:43,829
perform and check pointing solution so

00:00:42,120 --> 00:00:45,840
for those of you who are not familiar

00:00:43,829 --> 00:00:49,879
with checkpointing it's a technique that

00:00:45,840 --> 00:00:54,539
is used to achieve software for torrents

00:00:49,879 --> 00:00:56,430
it's it does that by connecting a pair

00:00:54,539 --> 00:00:59,160
of physical servers then periodically

00:00:56,430 --> 00:01:02,070
pause the vm and capture the states and

00:00:59,160 --> 00:01:06,740
send the captured states from the prior

00:01:02,070 --> 00:01:11,549
the active server to the standby server

00:01:06,740 --> 00:01:13,260
and for sabah zoo who are familiar with

00:01:11,549 --> 00:01:17,820
checkpointing you probably heard of or

00:01:13,260 --> 00:01:20,280
know of colo which is different from a

00:01:17,820 --> 00:01:23,729
traditional checkpointing solution in

00:01:20,280 --> 00:01:28,530
that it's it it does the checkpoint on

00:01:23,729 --> 00:01:31,890
demand so it doesn't periodically pause

00:01:28,530 --> 00:01:37,799
the vm but it does it one a deemed

00:01:31,890 --> 00:01:39,329
necessary but this plantation out the in

00:01:37,799 --> 00:01:41,600
this presentation are talked about the

00:01:39,329 --> 00:01:50,100
traditional checkpointing solutions and

00:01:41,600 --> 00:01:52,259
and the changes that we propose so i'll

00:01:50,100 --> 00:01:55,369
go into the check pointing in a little

00:01:52,259 --> 00:02:00,060
detail then i talk about the motivations

00:01:55,369 --> 00:02:03,710
for the changes and now going to little

00:02:00,060 --> 00:02:03,710
detail about the actual changes

00:02:04,329 --> 00:02:11,900
so in traditional checkpoint solution a

00:02:08,379 --> 00:02:16,430
protected guest runs inside a virtual

00:02:11,900 --> 00:02:18,170
machine then then hypervisor will the

00:02:16,430 --> 00:02:22,790
user space can instruct the piper either

00:02:18,170 --> 00:02:27,290
to pause the vm periodically and capture

00:02:22,790 --> 00:02:33,640
the states the state includes divided

00:02:27,290 --> 00:02:36,110
state at the memory state then it will

00:02:33,640 --> 00:02:40,610
send the capture state from the active

00:02:36,110 --> 00:02:44,480
side to the stand by side in the case of

00:02:40,610 --> 00:02:46,220
a failure of the active server the stem

00:02:44,480 --> 00:02:49,370
the stem by side will have sufficient

00:02:46,220 --> 00:02:53,630
state to assume the guest operation from

00:02:49,370 --> 00:02:56,060
the last checkpoint so the so I talked

00:02:53,630 --> 00:02:58,250
about do you periodically pause the vm

00:02:56,060 --> 00:03:02,690
so that period is it will kill an epic

00:02:58,250 --> 00:03:05,750
and wasn't happy the guest has a time

00:03:02,690 --> 00:03:07,579
has it will run for a period of time

00:03:05,750 --> 00:03:14,060
then you go into a checkpoint stay where

00:03:07,579 --> 00:03:18,829
it's paused so this is a simple diagram

00:03:14,060 --> 00:03:22,430
of a check pointing system where the

00:03:18,829 --> 00:03:25,850
guests will run through apics and it's

00:03:22,430 --> 00:03:29,150
hm epic it will transfer the states from

00:03:25,850 --> 00:03:32,840
the active host to the semi host and in

00:03:29,150 --> 00:03:36,670
case of a failure the stand by side will

00:03:32,840 --> 00:03:39,170
take over using the last checkpoint

00:03:36,670 --> 00:03:44,389
here's a look another diagram was a

00:03:39,170 --> 00:03:52,040
little more detail so if we CH for each

00:03:44,389 --> 00:03:54,500
checkpoint it will it will hold ayos due

00:03:52,040 --> 00:03:56,780
to correctness it will hold iOS and it

00:03:54,500 --> 00:03:59,030
will transfer the stage to the stand by

00:03:56,780 --> 00:04:01,630
side and get a college man generally

00:03:59,030 --> 00:04:01,630
released iOS

00:04:05,220 --> 00:04:12,400
so there are a few known open source

00:04:11,080 --> 00:04:15,190
checkpointing solutions the

00:04:12,400 --> 00:04:19,350
aforementioned the Colo is the only one

00:04:15,190 --> 00:04:21,820
that's active now then there's also

00:04:19,350 --> 00:04:25,540
Remus camera and a micro checkpointing

00:04:21,820 --> 00:04:27,880
which are not active anymore and there's

00:04:25,540 --> 00:04:31,270
also some proprietary supporting

00:04:27,880 --> 00:04:37,600
solution to vm RFTs estrellas ever and

00:04:31,270 --> 00:04:42,550
software in a via solutions so what's

00:04:37,600 --> 00:04:44,830
the motivation for the changes so a

00:04:42,550 --> 00:04:48,880
check pointing system it's all about

00:04:44,830 --> 00:04:50,380
performance so check pointing solution a

00:04:48,880 --> 00:04:52,480
traditional checkpointing solution where

00:04:50,380 --> 00:04:55,180
it periodically a positive vm it

00:04:52,480 --> 00:04:58,570
performs anywhere from over ninety

00:04:55,180 --> 00:05:02,830
percent compared to an unchecked morning

00:04:58,570 --> 00:05:04,780
vm for cpu intensive loads to under

00:05:02,830 --> 00:05:07,200
twenty-five percent for high-bandwidth

00:05:04,780 --> 00:05:12,070
slowly they see Network intensive loads

00:05:07,200 --> 00:05:19,870
a for commercial workloads it typically

00:05:12,070 --> 00:05:21,250
perform around fifty percent and now

00:05:19,870 --> 00:05:25,600
those number the fifty percent those

00:05:21,250 --> 00:05:28,330
numbers up you know it's we obtained it

00:05:25,600 --> 00:05:31,510
from running a you know Stratus ever and

00:05:28,330 --> 00:05:37,090
software against benchmarks and

00:05:31,510 --> 00:05:39,669
realistic commercial applications and we

00:05:37,090 --> 00:05:42,720
run that on the latest like the bra oil

00:05:39,669 --> 00:05:47,680
system in the latest Intel platforms to

00:05:42,720 --> 00:05:51,880
get that fifty percent so while I

00:05:47,680 --> 00:05:54,580
perform at a fifty percent because you

00:05:51,880 --> 00:05:59,020
know because any to papaws the VM and

00:05:54,580 --> 00:06:03,360
they need to do a checkpoint and you can

00:05:59,020 --> 00:06:06,720
see as we find out the majority of the

00:06:03,360 --> 00:06:09,900
check point in time is spent on

00:06:06,720 --> 00:06:12,630
obtaining the dirty pages from

00:06:09,900 --> 00:06:16,050
kvm and process those and transfer them

00:06:12,630 --> 00:06:19,080
to the stand by side so the longer the

00:06:16,050 --> 00:06:23,100
checkpoint the last time the guests will

00:06:19,080 --> 00:06:26,060
be running and doing actual work so

00:06:23,100 --> 00:06:28,590
there's direct correlation between the

00:06:26,060 --> 00:06:30,960
checkpoint I'm or the dirty memory

00:06:28,590 --> 00:06:37,530
harvest time to the performance of the

00:06:30,960 --> 00:06:41,550
system so the current memory tracking

00:06:37,530 --> 00:06:44,729
mechanism that used by kem uses a vm

00:06:41,550 --> 00:06:48,419
sized ability vm sized bitmap to track

00:06:44,729 --> 00:06:51,270
30 memories it works well with live

00:06:48,419 --> 00:06:53,039
migration but in checkpointing a

00:06:51,270 --> 00:06:58,949
traditional checkpointing system the

00:06:53,039 --> 00:07:01,680
number of 30 pages is bounded so Ames

00:06:58,949 --> 00:07:05,660
strata system for commercial workload

00:07:01,680 --> 00:07:09,570
you can have per second you can have

00:07:05,660 --> 00:07:12,360
from 150 to 1,500 check points per

00:07:09,570 --> 00:07:16,020
second and a number of 30 pages each

00:07:12,360 --> 00:07:20,340
second each checkpoint is around 300 to

00:07:16,020 --> 00:07:23,880
3,000 that compared to over two million

00:07:20,340 --> 00:07:28,169
pages for a kick vm so if you use bitmap

00:07:23,880 --> 00:07:32,639
you have to if you use bitmap to attract

00:07:28,169 --> 00:07:39,330
30 pages you have to traverse that huge

00:07:32,639 --> 00:07:42,630
bitmap to get to those you know 302 3030

00:07:39,330 --> 00:07:44,220
pages and and it's very expensive you

00:07:42,630 --> 00:07:46,320
have to do that every checkpoint so it's

00:07:44,220 --> 00:07:48,030
very time confused consuming and you

00:07:46,320 --> 00:07:50,610
also need to copy the bitmap to the user

00:07:48,030 --> 00:08:00,840
space and that's every checkpoint and

00:07:50,610 --> 00:08:02,789
it's very you know costly also so for

00:08:00,840 --> 00:08:07,380
the for the chain proposed for the

00:08:02,789 --> 00:08:09,750
proposed changes we wanted to be easily

00:08:07,380 --> 00:08:12,770
portable to you know different kernel

00:08:09,750 --> 00:08:16,830
versions so far we have ported to

00:08:12,770 --> 00:08:18,740
various versions of Santa's and ubuntu

00:08:16,830 --> 00:08:22,240
and susi and

00:08:18,740 --> 00:08:25,759
we don't want to change any existing kvm

00:08:22,240 --> 00:08:29,720
functionalities so we use new I octos

00:08:25,759 --> 00:08:32,000
learn new new functions for

00:08:29,720 --> 00:08:35,300
communication between the user space and

00:08:32,000 --> 00:08:38,719
kvm and we also wanted to coexist with

00:08:35,300 --> 00:08:44,779
the current dirty memory logging

00:08:38,719 --> 00:08:49,100
facilities and and we wanted to also to

00:08:44,779 --> 00:08:51,410
be usable by lab live migration another

00:08:49,100 --> 00:08:54,529
goal is to we want to avoid dynamic

00:08:51,410 --> 00:08:56,720
memory allocations and freeing during a

00:08:54,529 --> 00:09:01,940
checkpointing cycle because those

00:08:56,720 --> 00:09:04,760
operations are unpredictable and we are

00:09:01,940 --> 00:09:12,200
we only want to do it when we enter or

00:09:04,760 --> 00:09:19,459
is it checkpointing mode so those other

00:09:12,200 --> 00:09:23,680
changes proposed the changes you know

00:09:19,459 --> 00:09:26,060
because the pin map is very costly for

00:09:23,680 --> 00:09:29,570
chef pointing solution to track 30

00:09:26,060 --> 00:09:35,500
memory we proposed to use a compact list

00:09:29,570 --> 00:09:39,440
well of dirty pages okay have one list /

00:09:35,500 --> 00:09:43,040
online vcpu and we do that because we

00:09:39,440 --> 00:09:47,270
want to avoid logging locking when bcp

00:09:43,040 --> 00:09:52,130
use dirty memories and there's also one

00:09:47,270 --> 00:09:54,380
global list that's for keep track of the

00:09:52,130 --> 00:10:00,290
30 pages the pages that dirtied by the

00:09:54,380 --> 00:10:05,329
kvm and also handles overflowed 30 pages

00:10:00,290 --> 00:10:14,290
for from / vcpu list and because it's a

00:10:05,329 --> 00:10:18,440
list we want to avoid duplicates well

00:10:14,290 --> 00:10:21,290
duplicates a does they're fine if we're

00:10:18,440 --> 00:10:25,550
using a bitmap but its variant desire

00:10:21,290 --> 00:10:28,959
because this list is as a fixed size and

00:10:25,550 --> 00:10:31,980
we've seen tons of duplicates mostly by

00:10:28,959 --> 00:10:34,410
kvm during the guest memory

00:10:31,980 --> 00:10:38,430
you know when I doing guest time updates

00:10:34,410 --> 00:10:44,160
and among other things and now we can

00:10:38,430 --> 00:10:51,180
use to current bin lab to to keep

00:10:44,160 --> 00:10:57,600
traveling to the duplicates so another

00:10:51,180 --> 00:11:01,590
change is when the dirty list is full we

00:10:57,600 --> 00:11:06,960
need to force of these vm exit because

00:11:01,590 --> 00:11:09,450
each during each checkpoint number of 30

00:11:06,960 --> 00:11:14,460
pages is bounded because of the limited

00:11:09,450 --> 00:11:16,440
limited buffering space on host and we

00:11:14,460 --> 00:11:19,470
don't want to exceed buffer size because

00:11:16,440 --> 00:11:22,440
when it happens the primary the active

00:11:19,470 --> 00:11:24,390
and standby side will diverge and it

00:11:22,440 --> 00:11:31,410
will there it will be very costly to do

00:11:24,390 --> 00:11:33,810
resynchronization so when the list is

00:11:31,410 --> 00:11:38,690
for we want to force a vm exit all the

00:11:33,810 --> 00:11:38,690
way to userspace then the user space can

00:11:38,810 --> 00:11:51,780
you know start can start a checkpoint

00:11:41,580 --> 00:11:59,610
and do its things and and those the the

00:11:51,780 --> 00:12:01,950
threshold of the of the dirty pages the

00:11:59,610 --> 00:12:04,560
size of the database is usually cat

00:12:01,950 --> 00:12:07,100
calculated by user space and it will be

00:12:04,560 --> 00:12:10,100
passed down to the kvm during

00:12:07,100 --> 00:12:10,100
initialization

00:12:15,330 --> 00:12:26,430
so those are the new I octos you have a

00:12:20,670 --> 00:12:29,320
initialization and cling up octo which

00:12:26,430 --> 00:12:31,630
during an initialization the user space

00:12:29,320 --> 00:12:33,400
can specify the max number of dirty

00:12:31,630 --> 00:12:37,780
pages per checkpoint that services are

00:12:33,400 --> 00:12:43,180
so I showed that the kvm uses to exit

00:12:37,780 --> 00:12:47,860
users bags at vm when when there are too

00:12:43,180 --> 00:12:51,700
many dirty pages then also the active

00:12:47,860 --> 00:12:56,500
will activate and deactivate the

00:12:51,700 --> 00:12:59,230
checkpointing mode and for that I octyl

00:12:56,500 --> 00:13:04,620
the kvm will allocate a free dirty list

00:12:59,230 --> 00:13:04,620
and or enable or disable dirty traps

00:13:07,650 --> 00:13:14,970
those three new actos are used during a

00:13:11,740 --> 00:13:17,590
checkpoint cycle so it each checkpoint

00:13:14,970 --> 00:13:19,750
the user space can tell can be M to

00:13:17,590 --> 00:13:22,630
prepare for a new checkpoint psycho the

00:13:19,750 --> 00:13:26,260
kvm resets all you know counters or

00:13:22,630 --> 00:13:28,600
indexes for the dirty list then the

00:13:26,260 --> 00:13:33,730
universe space can fetch the daily list

00:13:28,600 --> 00:13:35,590
and and using the second Alto octo

00:13:33,730 --> 00:13:37,810
supports fetch from multiple user space

00:13:35,590 --> 00:13:40,510
right so you can have multiple multiple

00:13:37,810 --> 00:13:42,280
threads running user space fetch the

00:13:40,510 --> 00:13:45,420
daily list at the same time that just

00:13:42,280 --> 00:13:48,100
you know helps was the performance

00:13:45,420 --> 00:13:54,400
another octo is used by the user space

00:13:48,100 --> 00:13:58,230
to rearm the dirty traps so and when the

00:13:54,400 --> 00:14:02,290
user space gets all the Daniel 30 pages

00:13:58,230 --> 00:14:05,350
it can tell que bien to reset the dirty

00:14:02,290 --> 00:14:08,070
traps for the pages that studied from

00:14:05,350 --> 00:14:08,070
the last cycle

00:14:11,110 --> 00:14:18,830
so this is the flow from the point of

00:14:13,940 --> 00:14:21,740
view of the user space so when it

00:14:18,830 --> 00:14:23,360
started checkpointing psycho it it will

00:14:21,740 --> 00:14:28,550
need to enter the checkpointing world

00:14:23,360 --> 00:14:30,080
first so doing it and to enable the

00:14:28,550 --> 00:14:32,900
check pony mode then for each

00:14:30,080 --> 00:14:42,230
checkpointing cycle it does the prepared

00:14:32,900 --> 00:14:44,390
of the fatch and the reset and then when

00:14:42,230 --> 00:14:47,600
it exits the chap warning mode it will

00:14:44,390 --> 00:14:50,390
disable the checkpoint disable the check

00:14:47,600 --> 00:14:55,910
pointing then just do the cleanup so

00:14:50,390 --> 00:15:00,950
it's a you know uncomplicated that's

00:14:55,910 --> 00:15:03,800
crucial flow so how about my alive

00:15:00,950 --> 00:15:09,320
migration well the proposed change does

00:15:03,800 --> 00:15:11,180
not break live migration well it can be

00:15:09,320 --> 00:15:13,520
used by lab medication and avoid

00:15:11,180 --> 00:15:21,530
obviously and need user space support

00:15:13,520 --> 00:15:23,510
and and if if the user space has the

00:15:21,530 --> 00:15:25,370
support for the check pony mode it will

00:15:23,510 --> 00:15:28,070
improve will help improve the

00:15:25,370 --> 00:15:31,310
predictability of librarian alive my

00:15:28,070 --> 00:15:36,610
version of certain workloads like memory

00:15:31,310 --> 00:15:39,980
right intensive workloads korea moooore

00:15:36,610 --> 00:15:44,360
currently has a auto auto converge

00:15:39,980 --> 00:15:48,800
feature that addresses this poor problem

00:15:44,360 --> 00:15:52,880
PF cpu throttling well it may not be

00:15:48,800 --> 00:15:55,970
effective for certain workloads but you

00:15:52,880 --> 00:15:59,330
know if we use checkpointing mode where

00:15:55,970 --> 00:16:03,140
it pause the vm periodically harvest the

00:15:59,330 --> 00:16:06,970
dirty pages you know we can be sure that

00:16:03,140 --> 00:16:06,970
the migration will succeed

00:16:14,120 --> 00:16:21,650
so we tried to push those changes

00:16:17,570 --> 00:16:24,000
upstream we submit the first version

00:16:21,650 --> 00:16:27,210
we're currently working on the second

00:16:24,000 --> 00:16:29,400
version and you know target for a

00:16:27,210 --> 00:16:31,320
September and we got some very good

00:16:29,400 --> 00:16:36,950
feedbacks from the community and we're

00:16:31,320 --> 00:16:36,950
looking to submit a second version soon

00:16:38,750 --> 00:16:43,880
so that's that's it any questions

00:16:49,500 --> 00:16:54,870
hey there I like I really like the idea

00:16:52,170 --> 00:16:57,570
of using a different data structure to

00:16:54,870 --> 00:16:59,700
represent a sparse sparse set of dirty

00:16:57,570 --> 00:17:01,590
pages that's a conceptual very

00:16:59,700 --> 00:17:03,930
straightforward optimization that I'd

00:17:01,590 --> 00:17:07,290
love to see that going however I don't

00:17:03,930 --> 00:17:11,610
understand the motivation for making the

00:17:07,290 --> 00:17:14,339
new a whole new state machine an API to

00:17:11,610 --> 00:17:16,140
represent basically like a something

00:17:14,339 --> 00:17:17,880
that could be like a vm get dirty log to

00:17:16,140 --> 00:17:21,900
where the colonel decides to return a

00:17:17,880 --> 00:17:24,150
bitmap or or or a list why that why all

00:17:21,900 --> 00:17:27,270
of the extra states and transitions and

00:17:24,150 --> 00:17:30,540
data when it to my mind it's a it's a

00:17:27,270 --> 00:17:36,990
tiny kind of natural extension of kvm

00:17:30,540 --> 00:17:40,230
get 30 log right um it's not well it's

00:17:36,990 --> 00:17:42,510
just a set up new I octos that the user

00:17:40,230 --> 00:17:47,280
space can use it's not a mistake machine

00:17:42,510 --> 00:17:50,040
per se it's just how I presented as a

00:17:47,280 --> 00:17:53,670
like look like a state machine but you

00:17:50,040 --> 00:17:56,880
know it's how the user space should use

00:17:53,670 --> 00:18:00,030
those I octos to go through the check

00:17:56,880 --> 00:18:02,580
pointing system so actually agree with

00:18:00,030 --> 00:18:06,870
Peter in that anyway you have to beat

00:18:02,580 --> 00:18:10,620
map so i would just enable the dirty

00:18:06,870 --> 00:18:13,380
logging normally and you would maybe

00:18:10,620 --> 00:18:20,370
with the flag that says do a vm exit

00:18:13,380 --> 00:18:23,430
after n dirty pages that's the size of

00:18:20,370 --> 00:18:30,180
the list of whatever similar to pml in

00:18:23,430 --> 00:18:35,370
harbor and then you may need I octal to

00:18:30,180 --> 00:18:37,170
clean the state like to to clear the

00:18:35,370 --> 00:18:40,200
dirty bit map based on the contents of

00:18:37,170 --> 00:18:42,540
the list so that may be a new I accident

00:18:40,200 --> 00:18:45,000
it but I think the state machine huh as

00:18:42,540 --> 00:18:47,430
he called it can definitely reuse what

00:18:45,000 --> 00:18:49,200
is already done for the bitmap based off

00:18:47,430 --> 00:18:53,550
the log because you have the dirty bit

00:18:49,200 --> 00:18:56,640
one right too so I think it's a very

00:18:53,550 --> 00:18:58,590
complicated the new API and the more

00:18:56,640 --> 00:18:59,970
complicated API is the easier it is to

00:18:58,590 --> 00:19:02,510
screw it up and

00:18:59,970 --> 00:19:05,790
there's only if you can make it simpler

00:19:02,510 --> 00:19:09,770
one possibility could also be to have

00:19:05,790 --> 00:19:12,180
some kind of shared memory page so that

00:19:09,770 --> 00:19:15,690
when you get the vm exit you already

00:19:12,180 --> 00:19:21,270
have without need to do a new I Oracle a

00:19:15,690 --> 00:19:23,640
place where you can fetch the the the

00:19:21,270 --> 00:19:32,760
dirty pages and you just need dioctyl to

00:19:23,640 --> 00:19:35,160
a set the the dirty list okay but

00:19:32,760 --> 00:19:37,980
something even simpler would be like I

00:19:35,160 --> 00:19:40,380
said kvm get dirty log 2 and then the

00:19:37,980 --> 00:19:43,470
colonel ill know how many dirty how many

00:19:40,380 --> 00:19:45,420
dirty pages it would set in that bitmap

00:19:43,470 --> 00:19:48,150
and then it would decide okay all either

00:19:45,420 --> 00:19:50,370
all either return it as a list of dirty

00:19:48,150 --> 00:19:52,350
pages because if that will fit in the

00:19:50,370 --> 00:19:53,520
buffer then I know you'll do you know

00:19:52,350 --> 00:19:55,050
I'd most the same amount of work you

00:19:53,520 --> 00:19:58,070
would have done traversing the bitmap or

00:19:55,050 --> 00:20:00,150
ah i need to you know I can't I can't

00:19:58,070 --> 00:20:01,830
there aren't enough list entry so it's a

00:20:00,150 --> 00:20:04,080
bitmap and that would be another return

00:20:01,830 --> 00:20:06,930
field that would be super simple and I

00:20:04,080 --> 00:20:09,560
think you get the the trade-off exactly

00:20:06,930 --> 00:20:09,560
that you're looking for

00:20:14,259 --> 00:20:19,279
so as far as the actual tracking is

00:20:17,570 --> 00:20:20,869
concerned of the dirty pages do you do

00:20:19,279 --> 00:20:23,049
something different or is it just built

00:20:20,869 --> 00:20:24,950
on top of whatever we have in kvm so

00:20:23,049 --> 00:20:27,919
what I'm trying to understand is if

00:20:24,950 --> 00:20:32,059
suppose there's a you know the suppose p

00:20:27,919 --> 00:20:33,470
ml is present is it is your version is

00:20:32,059 --> 00:20:34,549
going to just use it automatically or do

00:20:33,470 --> 00:20:37,789
you have to do something for ya

00:20:34,549 --> 00:20:41,419
piggybacks on the current kvm mechanism

00:20:37,789 --> 00:20:44,059
it has the mark page dirty thing then

00:20:41,419 --> 00:20:49,369
with you know the change is just add a

00:20:44,059 --> 00:20:52,279
new function that on top of that but

00:20:49,369 --> 00:20:54,289
most this is most specific question

00:20:52,279 --> 00:20:56,600
about the API is there a reason that

00:20:54,289 --> 00:20:58,399
they prepare and the reset our separate

00:20:56,600 --> 00:21:00,590
operations because as far as i can tell

00:20:58,399 --> 00:21:02,869
you to always use them right I mean yeah

00:21:00,590 --> 00:21:06,649
those can be those can be combined I

00:21:02,869 --> 00:21:09,649
agree it's just how we haven't work

00:21:06,649 --> 00:21:12,529
initially but you know it obviously can

00:21:09,649 --> 00:21:15,499
be combined I mean logically it's a kind

00:21:12,529 --> 00:21:18,590
of testing result operations I mean

00:21:15,499 --> 00:21:21,080
exchange like getting the old data and

00:21:18,590 --> 00:21:26,440
resetting the point of 20 so that you

00:21:21,080 --> 00:21:26,440
can again start fighting new pages so

00:21:30,340 --> 00:21:33,519
all right

00:21:42,750 --> 00:21:51,670
hello there is think we can get a

00:21:46,300 --> 00:21:55,690
benefit if it's a DVD if it is a memory

00:21:51,670 --> 00:21:59,470
walk alone in the vm because it was it

00:21:55,690 --> 00:22:03,190
was a we are morons memory since k will

00:21:59,470 --> 00:22:07,390
work load it can generate a lot of data

00:22:03,190 --> 00:22:11,170
pages it will cost heat will cause a lot

00:22:07,390 --> 00:22:14,170
of will make state and you need to clean

00:22:11,170 --> 00:22:18,430
to be the man that will cost read were

00:22:14,170 --> 00:22:23,080
detected et/pt tables so and don't think

00:22:18,430 --> 00:22:31,470
in this case this way is a better than

00:22:23,080 --> 00:22:35,670
the current data page yeah i think well

00:22:31,470 --> 00:22:42,010
it's better for a high-frequency

00:22:35,670 --> 00:22:44,770
checkpointing system so in liking live

00:22:42,010 --> 00:22:47,470
migration you can have all the memory

00:22:44,770 --> 00:22:49,990
dirtied you obviously a list won't do

00:22:47,470 --> 00:22:52,960
any good but if you have a check

00:22:49,990 --> 00:22:56,940
pointing system work pay it pause the vm

00:22:52,960 --> 00:22:59,980
paraguay and it can pause you know

00:22:56,940 --> 00:23:03,790
hundreds of times per second then each

00:22:59,980 --> 00:23:08,080
those checkpoint the number of 30 pages

00:23:03,790 --> 00:23:11,770
is pretty small so just the one to come

00:23:08,080 --> 00:23:16,690
film so you owe me a during the during

00:23:11,770 --> 00:23:21,250
the Tang pond you mean the vm cannot

00:23:16,690 --> 00:23:22,870
generate lots of what the page right so

00:23:21,250 --> 00:23:28,420
if you have a chip on your system where

00:23:22,870 --> 00:23:32,770
it say it checkpoint every 100

00:23:28,420 --> 00:23:37,390
millisecond then you have to pause vm

00:23:32,770 --> 00:23:39,700
every 100 millisecond and and and the vm

00:23:37,390 --> 00:23:42,720
won't generate that much dirty memory

00:23:39,700 --> 00:23:47,470
doing that more of that amount of time

00:23:42,720 --> 00:23:49,990
and we have run benchmarks and

00:23:47,470 --> 00:23:52,700
commercial work clothes

00:23:49,990 --> 00:23:57,140
collecting data on those kind of runs

00:23:52,700 --> 00:24:00,970
and it only we only see like between 300

00:23:57,140 --> 00:24:03,860
to 3000 dirty pages each when you have

00:24:00,970 --> 00:24:08,990
when you're running the check pointing

00:24:03,860 --> 00:24:11,990
at a high frequency okay I've actually I

00:24:08,990 --> 00:24:16,850
was thinking if we can you prove so

00:24:11,990 --> 00:24:22,010
current tthe we can let the user space

00:24:16,850 --> 00:24:25,310
allocated to a bitmap and under then and

00:24:22,010 --> 00:24:28,040
then it needn't copies a day to pay 30

00:24:25,310 --> 00:24:31,760
bit of map from Kevin modeled so choose

00:24:28,040 --> 00:24:36,020
the user space also we can partition so

00:24:31,760 --> 00:24:39,470
memory and the lead is a under let a bit

00:24:36,020 --> 00:24:42,970
of man poop this more then walk the p

00:24:39,470 --> 00:24:46,160
the man who will be much cheaper so

00:24:42,970 --> 00:24:51,350
pleasing hey if we can improve the

00:24:46,160 --> 00:24:55,400
current 30 pitch 30 page in inter

00:24:51,350 --> 00:24:58,580
kayvyun do you mean you think there's a

00:24:55,400 --> 00:25:02,000
better way I mean the way to improve the

00:24:58,580 --> 00:25:07,660
current yeah map yeah yeah maybe we can

00:25:02,000 --> 00:25:07,660
you know get together and discuss that

00:25:11,240 --> 00:25:19,790
any more questions right thank you thank

00:25:17,130 --> 00:25:19,790

YouTube URL: https://www.youtube.com/watch?v=-VRSQ-AYUOY


