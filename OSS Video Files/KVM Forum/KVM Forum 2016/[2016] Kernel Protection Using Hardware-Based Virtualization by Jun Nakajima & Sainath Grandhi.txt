Title: [2016] Kernel Protection Using Hardware-Based Virtualization by Jun Nakajima & Sainath Grandhi
Publication date: 2016-09-01
Playlist: KVM Forum 2016
Description: 
	We propose that the Linux run in virtualization mode, activating hardware virtualization features to improve security and monitoring. Hardware enforced virtualization features can be used for hardening the kernel, by protecting key kernel data structures and locking the processor state when the processor is executing in guest mode. Security features from the latest processors can be added to virtual processors. Kernels running on platforms with processors from older generations are benefitted.

For the bare-metal, we have added a thin hypervisor to the kernel, and we have extended KVM for guest kernels so that they can identify this capability as a CPU feature, become enlightened and work with the hypervisor to lock and monitor kernel resources and processor state.

In this talk we will present the idea, its benefits and the work we have done in Linux/KVM.

Sainath Grandhi
Intel

Work for Intel in Open Source Virtualization group. Work on Xen and KVM kernel feature enabling. Currently working on a project that is a solution to run containers with a hypervisor underneath to provide security and resource isolation.

Jun Nakajima
Intel Open Source Technology Center, Senior Principal Engineer
San Francisco Bay Area

Jun Nakajima is a Senior Principal Engineer leading open source virtualization and cloud projects, such as, KVM, Xen, and OpenStack at the Intel Open Source Technology Center. Jun has been working on various virtualization projects for almost a decade, and NFV is one of his ongoing projects. Jun presented a number of times at technical conferences, including KVM Forum, Xen Summit, and USENIX. He has over 20 years of experience with operating system internals and virtualization.

Slides: http://www.linux-kvm.org/images/4/40/01x05-Jun_Nakajima-Kernel_Protection_Using_Hardware-Based_Virtualization.pdf
Captions: 
	00:00:08,389 --> 00:00:16,650
so my name is a Jew nakajima I'm an

00:00:11,849 --> 00:00:18,990
architect at OTC you know if Intel open

00:00:16,650 --> 00:00:21,359
source technology center I've been

00:00:18,990 --> 00:00:24,779
working on our virtues Asian more than

00:00:21,359 --> 00:00:28,250
10 years so and then assign us he

00:00:24,779 --> 00:00:30,960
couldn't make this but uh he walked on

00:00:28,250 --> 00:00:35,070
you know lots of debugging stuff for

00:00:30,960 --> 00:00:38,520
this project so anyway I'll cover the

00:00:35,070 --> 00:00:42,570
entire session today okay so this is

00:00:38,520 --> 00:00:46,260
about our about actually power of the

00:00:42,570 --> 00:00:49,379
virtualization if you run the colonel

00:00:46,260 --> 00:00:51,510
the o as in virtualization actually you

00:00:49,379 --> 00:00:54,960
can have a more power to protect the

00:00:51,510 --> 00:00:57,239
monitor and that way you can maintain I

00:00:54,960 --> 00:01:02,270
you know integrity for colonel that's

00:00:57,239 --> 00:01:08,700
that you know the point of this talk ok

00:01:02,270 --> 00:01:11,610
so just want to quick this one so first

00:01:08,700 --> 00:01:14,189
I you know talk about hardware-based

00:01:11,610 --> 00:01:17,250
virtualization and then also the

00:01:14,189 --> 00:01:20,130
software that uses harder virtualization

00:01:17,250 --> 00:01:24,570
which is also called virtual machine

00:01:20,130 --> 00:01:27,270
monitor ok dmm I will stay at idle

00:01:24,570 --> 00:01:29,400
because I don't think all over you are

00:01:27,270 --> 00:01:32,040
familiar with low level you know but

00:01:29,400 --> 00:01:37,619
she's Asian stuff so i'll keep you know

00:01:32,040 --> 00:01:42,229
high level ok then i will explain the

00:01:37,619 --> 00:01:46,950
ideas or in our idea how we add the

00:01:42,229 --> 00:01:50,850
monitoring and protection capability ok

00:01:46,950 --> 00:01:53,909
in virtualization ok then followed by

00:01:50,850 --> 00:01:57,259
the policy and how we handle all the

00:01:53,909 --> 00:02:02,729
events incident upon some vibration ok

00:01:57,259 --> 00:02:04,890
then talk about the architecture the

00:02:02,729 --> 00:02:09,330
current architecture and then based on

00:02:04,890 --> 00:02:12,340
our POC and implementation one thing i

00:02:09,330 --> 00:02:15,940
want to point out is this technique

00:02:12,340 --> 00:02:21,030
is applicable to both our virtual

00:02:15,940 --> 00:02:21,030
machine and also bear mellow okay and

00:02:21,060 --> 00:02:26,800
bare metal well actually you don't need

00:02:24,220 --> 00:02:29,260
to pay the overhead of virtualization

00:02:26,800 --> 00:02:31,720
you can still maintain a good

00:02:29,260 --> 00:02:34,480
performance noble noble metal I'll share

00:02:31,720 --> 00:02:37,900
the performance number as well okay then

00:02:34,480 --> 00:02:44,010
finally I'll talk about more advanced

00:02:37,900 --> 00:02:44,010
topic beyond just a kernel protection ok

00:02:44,519 --> 00:02:50,680
so again this is the high level just to

00:02:47,680 --> 00:02:54,310
refresh your memory ok so left hand side

00:02:50,680 --> 00:02:56,769
this is a you know typical bare metal OS

00:02:54,310 --> 00:03:01,000
where the operating system single

00:02:56,769 --> 00:03:03,160
berating system are managed the order

00:03:01,000 --> 00:03:06,459
physical system and the system resources

00:03:03,160 --> 00:03:08,560
ok then on the right hand side you see

00:03:06,459 --> 00:03:13,510
the virtual machines with virtual

00:03:08,560 --> 00:03:15,579
devices running on top of a vm m virtual

00:03:13,510 --> 00:03:20,920
machine monitor ok I'll talk about more

00:03:15,579 --> 00:03:23,560
details the next page ok and in this

00:03:20,920 --> 00:03:26,200
case are multiple guests if the virtual

00:03:23,560 --> 00:03:30,549
machine will share the system resources

00:03:26,200 --> 00:03:33,370
ok now if we look at the detail virtual

00:03:30,549 --> 00:03:35,620
machine monitor ok typically for example

00:03:33,370 --> 00:03:37,989
like I'd in case of Linux the

00:03:35,620 --> 00:03:41,349
combination of the Linux and then the

00:03:37,989 --> 00:03:45,849
kvm becomes virtual machine monitor

00:03:41,349 --> 00:03:50,169
including qmu ok so what basically it

00:03:45,849 --> 00:03:58,599
does is or virtualizes for processor

00:03:50,169 --> 00:04:02,019
memory and i/o devices ok so more now

00:03:58,599 --> 00:04:05,970
the question is how can we extend ok

00:04:02,019 --> 00:04:09,069
we'll use this kind of a software to add

00:04:05,970 --> 00:04:14,230
what we need basically the protection of

00:04:09,069 --> 00:04:16,510
motoring ok so this is a high level of

00:04:14,230 --> 00:04:22,780
Colonel protection ok basically the idea

00:04:16,510 --> 00:04:26,190
is we extend the synchronous this one ok

00:04:22,780 --> 00:04:29,520
a process of virtualization memory

00:04:26,190 --> 00:04:34,050
goes to add those basically for example

00:04:29,520 --> 00:04:38,970
in case of memory right the hypervisor

00:04:34,050 --> 00:04:43,590
or bmm can actually write to protect

00:04:38,970 --> 00:04:51,650
some pages of the colonel pages right

00:04:43,590 --> 00:04:54,840
what data or the use of this one of

00:04:51,650 --> 00:04:57,390
hypervisor can lock the processor

00:04:54,840 --> 00:05:00,480
controls ok I have a more detail the

00:04:57,390 --> 00:05:08,580
next page and then also we can do the

00:05:00,480 --> 00:05:10,710
same thing for iommu ok now what is the

00:05:08,580 --> 00:05:14,280
benefit is why we're going to use the

00:05:10,710 --> 00:05:16,590
virtualization ok so in virtualization

00:05:14,280 --> 00:05:18,630
actually you have a more power like I

00:05:16,590 --> 00:05:26,180
said right you have a more monitoring

00:05:18,630 --> 00:05:29,510
capability isolation ok and in fact the

00:05:26,180 --> 00:05:33,660
Intel of example BTW feature was

00:05:29,510 --> 00:05:36,060
initially intended for security

00:05:33,660 --> 00:05:39,570
enhancement the virtualization came

00:05:36,060 --> 00:05:44,040
actually later ok that happened like a

00:05:39,570 --> 00:05:46,050
more than 10 years ago but i don't think

00:05:44,040 --> 00:05:48,060
this is a secret annual right done

00:05:46,050 --> 00:05:53,280
anyway so forth ization is a pretty

00:05:48,060 --> 00:05:58,350
effective to add more security ok so

00:05:53,280 --> 00:06:01,020
again hypervisor runs like you know some

00:05:58,350 --> 00:06:04,850
people say it's a ring minus one right

00:06:01,020 --> 00:06:07,790
even to lower than the native colonel ok

00:06:04,850 --> 00:06:11,400
technically we call a virtualization

00:06:07,790 --> 00:06:13,560
root mode so hyper bite itself runs in a

00:06:11,400 --> 00:06:19,550
virtualization root mode and then gasps

00:06:13,560 --> 00:06:19,550
run in virtualization non-root mode ok

00:06:19,850 --> 00:06:28,919
the other thing we can do is we can

00:06:24,200 --> 00:06:32,070
virtually our extend the cpu feature for

00:06:28,919 --> 00:06:34,710
security so that the colonel can harden

00:06:32,070 --> 00:06:38,700
itself to you know increase the security

00:06:34,710 --> 00:06:41,960
example right so that's what

00:06:38,700 --> 00:06:46,110
benefits the other thing in terms of our

00:06:41,960 --> 00:06:48,420
implementation you don't need to have

00:06:46,110 --> 00:06:51,480
other code in you know you don't need to

00:06:48,420 --> 00:06:54,120
modify the gas you can have a logic

00:06:51,480 --> 00:06:58,160
inside contained inside a hypervisor

00:06:54,120 --> 00:07:01,710
okay that would allow for example to

00:06:58,160 --> 00:07:04,920
change the behavior of the guests

00:07:01,710 --> 00:07:09,180
because Colonel at runtime it's like a

00:07:04,920 --> 00:07:12,360
hot touch but incapable native case you

00:07:09,180 --> 00:07:15,840
need to probably modify the bits right

00:07:12,360 --> 00:07:19,560
in the current right otherwise you

00:07:15,840 --> 00:07:22,340
cannot change that the code paths but in

00:07:19,560 --> 00:07:24,990
bro tradition you can for example

00:07:22,340 --> 00:07:27,960
intercept of various events we can I go

00:07:24,990 --> 00:07:31,160
to the some attacks used by you know

00:07:27,960 --> 00:07:35,550
exploit Colonel Expo is like up are

00:07:31,160 --> 00:07:39,090
divided by 0 okay we can intercept that

00:07:35,550 --> 00:07:41,280
can exception in the hypervisor or page

00:07:39,090 --> 00:07:44,310
fault if Paige would help in the krona

00:07:41,280 --> 00:07:46,350
mode we can intercept and if you take a

00:07:44,310 --> 00:07:49,170
look at where you to happen then we can

00:07:46,350 --> 00:07:53,760
modify that the gaze of behavior okay so

00:07:49,170 --> 00:07:58,320
we can do that kind of thing and like I

00:07:53,760 --> 00:08:02,010
said this is also applicable to our bare

00:07:58,320 --> 00:08:05,220
metal relics ok so the burial of limits

00:08:02,010 --> 00:08:07,440
can actually Dupree bridge itself to

00:08:05,220 --> 00:08:13,050
become virtualization laundry tomorrow

00:08:07,440 --> 00:08:18,990
ok I'll have a more details here ok so

00:08:13,050 --> 00:08:22,350
don't worry about it um so this way if

00:08:18,990 --> 00:08:25,760
we run the Linux bare metal linux in

00:08:22,350 --> 00:08:31,860
this mode we can have additional

00:08:25,760 --> 00:08:34,349
security ok without incurring or

00:08:31,860 --> 00:08:36,750
virtualization overhead so this is good

00:08:34,349 --> 00:08:38,880
for you know for example running of the

00:08:36,750 --> 00:08:42,540
other metal containers were four acre

00:08:38,880 --> 00:08:43,169
hpc okay where you don't want to have

00:08:42,540 --> 00:08:48,690
any

00:08:43,169 --> 00:08:51,120
you know behind right so this is more

00:08:48,690 --> 00:08:58,170
details or for example I started with a

00:08:51,120 --> 00:08:59,940
memory protection okay so typically if

00:08:58,170 --> 00:09:04,079
you look at the colonel implementation

00:08:59,940 --> 00:09:07,230
chrono has read only mapping for example

00:09:04,079 --> 00:09:10,560
for Colonel text in a code was some

00:09:07,230 --> 00:09:13,410
other data I have example in a read-only

00:09:10,560 --> 00:09:16,889
data with the colonel in the next page

00:09:13,410 --> 00:09:23,070
so he want he wants to protect some

00:09:16,889 --> 00:09:28,459
pages right but the way the Linux can do

00:09:23,070 --> 00:09:34,709
is basically have a page table and set

00:09:28,459 --> 00:09:39,630
the permissions as we'd only okay this

00:09:34,709 --> 00:09:43,740
is actually a bit fragile okay for

00:09:39,630 --> 00:09:47,000
example on somebody record drive or even

00:09:43,740 --> 00:09:51,120
the ball can change the permission of

00:09:47,000 --> 00:09:54,680
you know the page table entry to make it

00:09:51,120 --> 00:09:58,760
writable okay that's one thing or

00:09:54,680 --> 00:10:02,550
somehow you can have different

00:09:58,760 --> 00:10:06,990
translation mapping to the same page but

00:10:02,550 --> 00:10:10,649
this time with writable okay so in this

00:10:06,990 --> 00:10:15,680
case if we use this this translation you

00:10:10,649 --> 00:10:19,470
can actually modify this page okay but

00:10:15,680 --> 00:10:24,060
in virtualization remember that the

00:10:19,470 --> 00:10:27,750
hypervisor has more power okay so we

00:10:24,060 --> 00:10:32,190
need additional page table okay that

00:10:27,750 --> 00:10:35,100
map's gets too physical okay this one

00:10:32,190 --> 00:10:37,620
gets the physical address to host of

00:10:35,100 --> 00:10:41,069
physical and that kind of page table is

00:10:37,620 --> 00:10:43,949
called by code like EPT extended the

00:10:41,069 --> 00:10:46,889
page table on the Intel and then on md

00:10:43,949 --> 00:10:50,190
its nest of the page table okay and they

00:10:46,889 --> 00:10:54,410
have additional permission okay so if

00:10:50,190 --> 00:10:56,470
that page page table says it's read-only

00:10:54,410 --> 00:11:05,970
even the guest

00:10:56,470 --> 00:11:12,250
I'm sorry sit this way yeah if just had

00:11:05,970 --> 00:11:15,940
write permission this this are you know

00:11:12,250 --> 00:11:20,080
read-only actually win so you just

00:11:15,940 --> 00:11:24,070
cannot modify okay actually causes vm

00:11:20,080 --> 00:11:27,340
exit call EPT vibration okay Let Go Go

00:11:24,070 --> 00:11:31,980
jump to the basically the switch to the

00:11:27,340 --> 00:11:31,980
hypervisor okay so this is one example

00:11:33,150 --> 00:11:39,490
example the colonel video only data for

00:11:37,090 --> 00:11:41,980
example the like I said the colonel text

00:11:39,490 --> 00:11:45,160
right in the colonel you know code you

00:11:41,980 --> 00:11:48,790
don't want to modify it right and then

00:11:45,160 --> 00:11:51,340
some data structure for example are some

00:11:48,790 --> 00:11:54,640
portion of a page table that actually

00:11:51,340 --> 00:11:56,740
mapping the we don't okay if somebody

00:11:54,640 --> 00:12:01,240
tried to change the permission right

00:11:56,740 --> 00:12:03,640
page table itself then you will change

00:12:01,240 --> 00:12:07,330
you know you can change any translation

00:12:03,640 --> 00:12:11,140
in the car okay other thing is a system

00:12:07,330 --> 00:12:12,940
called table okay or the IDT interrupt

00:12:11,140 --> 00:12:17,670
two disparate our table those are

00:12:12,940 --> 00:12:23,200
typically used for exploits okay and

00:12:17,670 --> 00:12:26,680
there are more and then if you look at

00:12:23,200 --> 00:12:31,780
the counter code you see this kind of

00:12:26,680 --> 00:12:35,410
thing okay and the those should be also

00:12:31,780 --> 00:12:38,260
read only oh but some people are not

00:12:35,410 --> 00:12:42,040
really sure actually we may break if we

00:12:38,260 --> 00:12:44,020
really respect as a read-only but anyway

00:12:42,040 --> 00:12:46,150
from programmers point of view you think

00:12:44,020 --> 00:12:49,030
this is a read-only so we should you

00:12:46,150 --> 00:12:53,830
know protect right make sure this is not

00:12:49,030 --> 00:12:58,360
written modify if it's not then the you

00:12:53,830 --> 00:13:01,740
know the code is not very cracked the

00:12:58,360 --> 00:13:05,050
other thing is CPU control state okay

00:13:01,740 --> 00:13:06,970
when the Linux initialize complete in

00:13:05,050 --> 00:13:12,040
association then

00:13:06,970 --> 00:13:16,240
he's set up the control state for

00:13:12,040 --> 00:13:19,389
example 64-bit pee and all the features

00:13:16,240 --> 00:13:22,029
available okay what I can see our

00:13:19,389 --> 00:13:25,120
security features you don't need to know

00:13:22,029 --> 00:13:30,009
those but those are example enabling and

00:13:25,120 --> 00:13:32,800
some security features ok and then ma

00:13:30,009 --> 00:13:35,709
saw the machine specific register that

00:13:32,800 --> 00:13:39,480
can affect the behavior of a platform or

00:13:35,709 --> 00:13:42,790
a processor ok so once the colonel

00:13:39,480 --> 00:13:46,509
initialize a complete initialization and

00:13:42,790 --> 00:13:49,810
assume some control state and he

00:13:46,509 --> 00:13:53,199
continued to modify some bits in a

00:13:49,810 --> 00:13:56,290
contrary sir but for others he really

00:13:53,199 --> 00:13:59,050
want to you know fix those bits and he

00:13:56,290 --> 00:14:02,110
doesn't want to change ok if somebody's

00:13:59,050 --> 00:14:10,930
tried to modify those bits that it's

00:14:02,110 --> 00:14:12,759
probably bog or some attack ok and I

00:14:10,930 --> 00:14:15,339
will take about this one's a cute

00:14:12,759 --> 00:14:17,769
extension and one example is so called a

00:14:15,339 --> 00:14:22,269
unit and I think of the power or

00:14:17,769 --> 00:14:27,430
submitted a part but this is one example

00:14:22,269 --> 00:14:29,500
so today we don't have a processor that

00:14:27,430 --> 00:14:32,139
suppose this one you know broadly

00:14:29,500 --> 00:14:35,860
available ok in the market that's

00:14:32,139 --> 00:14:39,069
supposed to this processor ok but in

00:14:35,860 --> 00:14:45,850
virtualization actually we can implement

00:14:39,069 --> 00:14:48,670
or this kind of an advanced feature even

00:14:45,850 --> 00:14:52,209
on current processor we're all old

00:14:48,670 --> 00:14:56,079
processors because we already have a BMX

00:14:52,209 --> 00:14:58,720
features on all the processors so that

00:14:56,079 --> 00:15:00,910
way the the current or even all the

00:14:58,720 --> 00:15:05,139
processor can take advantage about this

00:15:00,910 --> 00:15:07,899
feature security feature what the you

00:15:05,139 --> 00:15:12,029
you meep does is basically our prevent

00:15:07,899 --> 00:15:14,819
our the user level to execute summer

00:15:12,029 --> 00:15:18,610
sensitive instructions for example

00:15:14,819 --> 00:15:27,640
exposing IDT interrupt this little table

00:15:18,610 --> 00:15:29,260
okay today I say it's mostly but this is

00:15:27,640 --> 00:15:35,110
good enough if you know if we use

00:15:29,260 --> 00:15:39,399
existing vmx feature or then purple

00:15:35,110 --> 00:15:42,579
ization so if somebody comes up with

00:15:39,399 --> 00:15:45,850
very small security feature okay that

00:15:42,579 --> 00:15:47,620
doesn't exist in real hardware then you

00:15:45,850 --> 00:15:53,260
know you can implement that kind of a

00:15:47,620 --> 00:15:58,089
feature brewery in hypervisor and expose

00:15:53,260 --> 00:16:01,690
to the gas as a pervert ization then you

00:15:58,089 --> 00:16:05,709
can for example or improve the security

00:16:01,690 --> 00:16:07,899
of all linux okay with kind of

00:16:05,709 --> 00:16:14,680
cooperation between the guests and the

00:16:07,899 --> 00:16:18,100
hypervisor okay so this is the iom of

00:16:14,680 --> 00:16:20,410
you I don't want to totally cover the

00:16:18,100 --> 00:16:26,350
lots of detail property Alexa like this

00:16:20,410 --> 00:16:29,769
but the same thing is iommu so when I

00:16:26,350 --> 00:16:33,310
think Alex talked about iommu but up in

00:16:29,769 --> 00:16:36,610
iommu there are some of basic structures

00:16:33,310 --> 00:16:39,430
and some nums in our static once the

00:16:36,610 --> 00:16:42,730
installation is done okay the colonel

00:16:39,430 --> 00:16:47,170
doesn't expect they will be modified

00:16:42,730 --> 00:16:49,870
okay what are the teachers he detected

00:16:47,170 --> 00:16:53,380
the enable okay if somebody's try to

00:16:49,870 --> 00:17:01,120
turn off work some mistake that's also

00:16:53,380 --> 00:17:03,699
bug or a mistake or attack okay this is

00:17:01,120 --> 00:17:08,290
the example of how we specify the policy

00:17:03,699 --> 00:17:11,199
and a hundred ok so we specified asset

00:17:08,290 --> 00:17:14,500
when I said asset means like a system

00:17:11,199 --> 00:17:19,689
resources like the bits in a control

00:17:14,500 --> 00:17:26,770
register MSR port or the guest of

00:17:19,689 --> 00:17:29,710
physical address okay or oh yeah so yeah

00:17:26,770 --> 00:17:31,350
so then the permission like a read only

00:17:29,710 --> 00:17:33,630
way execution

00:17:31,350 --> 00:17:37,110
known they were not available and an

00:17:33,630 --> 00:17:41,760
action so when somebody's try to for

00:17:37,110 --> 00:17:44,160
example x 0 is dis auditing and the

00:17:41,760 --> 00:17:48,299
hypervisor the needs to take some action

00:17:44,160 --> 00:17:50,789
and at this point what we have is

00:17:48,299 --> 00:17:54,419
basically ignore ok so basically don't

00:17:50,789 --> 00:17:56,820
change the visibility that control

00:17:54,419 --> 00:18:01,919
register don't change that control

00:17:56,820 --> 00:18:04,710
register ok what are allow ok but the

00:18:01,919 --> 00:18:07,610
log now kind of same so this is a this

00:18:04,710 --> 00:18:10,710
still kind of all you know re stage I

00:18:07,610 --> 00:18:13,860
you know appreciate your feedback how we

00:18:10,710 --> 00:18:18,990
going to set up or you know the

00:18:13,860 --> 00:18:21,510
interface between user now I'm talking

00:18:18,990 --> 00:18:23,730
about the architecture so this is first

00:18:21,510 --> 00:18:25,980
of all this is a kvm guests only this

00:18:23,730 --> 00:18:30,110
should be simple right this is what's

00:18:25,980 --> 00:18:34,669
happening today ok like I said yes are

00:18:30,110 --> 00:18:38,280
running a virtualization non-root mode

00:18:34,669 --> 00:18:41,970
this is a in a portable architectural

00:18:38,280 --> 00:18:46,890
state of the processor ok and this is

00:18:41,970 --> 00:18:51,350
what's happening today on the kvm now

00:18:46,890 --> 00:18:55,080
what we do is basically extend a kvm to

00:18:51,350 --> 00:18:58,350
the monitor and to protect a specific

00:18:55,080 --> 00:19:01,620
part of the kernel or the cpu virtual

00:18:58,350 --> 00:19:03,480
CPU resources while i am a view ok so

00:19:01,620 --> 00:19:13,169
this is what's happening today about

00:19:03,480 --> 00:19:14,850
what we are adding ok now with host what

00:19:13,169 --> 00:19:19,470
happened is a biscuit basically we

00:19:14,850 --> 00:19:23,039
extend the kvm ok to add platform

00:19:19,470 --> 00:19:26,100
protection I'll cover more problem

00:19:23,039 --> 00:19:30,840
protection but this is something like

00:19:26,100 --> 00:19:33,720
chipset were like bios or some sensitive

00:19:30,840 --> 00:19:36,440
or hardware resources ok we can also

00:19:33,720 --> 00:19:39,510
protect a cannonball you know resources

00:19:36,440 --> 00:19:44,549
because that's a really physical stuff

00:19:39,510 --> 00:19:45,270
ok then we call right this is a thing

00:19:44,549 --> 00:19:46,620
hypervisor

00:19:45,270 --> 00:19:53,420
if you think of this is I think

00:19:46,620 --> 00:19:58,770
hypervisor okay then we deeply bridge

00:19:53,420 --> 00:20:01,500
the entire linux and then also the vm is

00:19:58,770 --> 00:20:05,100
to you know running a vm x the

00:20:01,500 --> 00:20:11,420
virtualization on Rita mode okay so this

00:20:05,100 --> 00:20:15,020
way almost entire system runs in

00:20:11,420 --> 00:20:18,570
virtualization non-root mode okay and

00:20:15,020 --> 00:20:23,610
then all the changes are integrated into

00:20:18,570 --> 00:20:25,860
the KPM and all this I'll have a more

00:20:23,610 --> 00:20:31,710
details are next but it doesn't require

00:20:25,860 --> 00:20:39,840
qmu and you can deactivate or deactivate

00:20:31,710 --> 00:20:41,880
at runtime okay and this is if should we

00:20:39,840 --> 00:20:48,840
use the so called the password technique

00:20:41,880 --> 00:20:51,510
ok over more in the next page ok so this

00:20:48,840 --> 00:20:57,990
page this right explain how we do this

00:20:51,510 --> 00:21:01,350
so first of all paths through since you

00:20:57,990 --> 00:21:03,210
for the bare metal we don't need to we

00:21:01,350 --> 00:21:08,040
don't want to you know are virtualized

00:21:03,210 --> 00:21:11,450
election platform ok we use a password

00:21:08,040 --> 00:21:16,110
basically the bare metal linux just

00:21:11,450 --> 00:21:19,340
access IO devices interrupt controller

00:21:16,110 --> 00:21:22,740
timer panic power management those

00:21:19,340 --> 00:21:26,580
without causing any vm exit ok it's

00:21:22,740 --> 00:21:31,710
basically native access now for the

00:21:26,580 --> 00:21:34,730
memory of area we kind of this is also

00:21:31,710 --> 00:21:38,490
virtualized but we use identity mapping

00:21:34,730 --> 00:21:41,580
what it means is guest of physical

00:21:38,490 --> 00:21:44,660
address is same as host physical address

00:21:41,580 --> 00:21:50,460
ok so no translation but we add

00:21:44,660 --> 00:21:53,400
protection permission to this one ok so

00:21:50,460 --> 00:21:55,950
if you look at memory overhead only

00:21:53,400 --> 00:21:59,200
thing you need to pay is additional

00:21:55,950 --> 00:22:02,080
memory for EPT and this is just

00:21:59,200 --> 00:22:05,860
poor system so it's it doesn't increase

00:22:02,080 --> 00:22:11,080
as you have more gas it's basically fix

00:22:05,860 --> 00:22:13,419
the cost and it's small and then form

00:22:11,080 --> 00:22:15,970
protection like I said for example in

00:22:13,419 --> 00:22:20,740
the proper form you have a chipset or

00:22:15,970 --> 00:22:24,190
you know memory controller you know some

00:22:20,740 --> 00:22:27,850
setup for the bios you know those kind

00:22:24,190 --> 00:22:30,899
of saying okay and if you run for

00:22:27,850 --> 00:22:35,080
example container right you don't want

00:22:30,899 --> 00:22:38,980
the application in a container to access

00:22:35,080 --> 00:22:41,260
you know based on some security for for

00:22:38,980 --> 00:22:44,130
example right you really want to catch

00:22:41,260 --> 00:22:44,130
and prevent

00:22:48,599 --> 00:22:52,440
I'm taking a time

00:22:59,420 --> 00:23:06,900
so there's one problem it's not really

00:23:03,330 --> 00:23:11,150
problem issue we need to solve to

00:23:06,900 --> 00:23:17,810
maintain hype good performance of a kvm

00:23:11,150 --> 00:23:21,750
okay the problem is the kb m is not

00:23:17,810 --> 00:23:27,960
available in virtualization non-root

00:23:21,750 --> 00:23:32,130
mode ok unless you use nested motivation

00:23:27,960 --> 00:23:34,500
ok and probably you don't want to use

00:23:32,130 --> 00:23:37,050
nested virtualization for various

00:23:34,500 --> 00:23:41,370
reasons one reason is a performance

00:23:37,050 --> 00:23:47,900
right and this basically explain how we

00:23:41,370 --> 00:23:51,240
solve this problem ok so what we do is

00:23:47,900 --> 00:23:53,940
whenever you know the colonel runs like

00:23:51,240 --> 00:23:56,610
it you know you use our runs here no

00:23:53,940 --> 00:24:02,940
problem but he wants to go across this

00:23:56,610 --> 00:24:06,390
one to use kvm ok in this case we need

00:24:02,940 --> 00:24:10,920
to go back to the virtualization route

00:24:06,390 --> 00:24:15,260
mode ok to that end we need to generate

00:24:10,920 --> 00:24:18,260
BMX BMX it right there are tangible

00:24:15,260 --> 00:24:23,970
instruction that causes a vm exit

00:24:18,260 --> 00:24:29,250
unconditionally ok the vmx of is one of

00:24:23,970 --> 00:24:33,180
them ok if the you know you execute vmx

00:24:29,250 --> 00:24:36,210
off in virtualization or non read that

00:24:33,180 --> 00:24:39,780
automatic unconditionally causes vm exit

00:24:36,210 --> 00:24:44,280
and jump to the hypervisor so in this

00:24:39,780 --> 00:24:47,730
case we have the hypervisor ok a game

00:24:44,280 --> 00:24:51,240
that's a part of a kvm today ok but it's

00:24:47,730 --> 00:24:55,260
different hondro and that hondro the BMX

00:24:51,240 --> 00:25:00,570
attendre basically does kind of ID it ok

00:24:55,260 --> 00:25:04,170
i read to the next instruction after BMX

00:25:00,570 --> 00:25:08,850
off ok so from Chronos point of view

00:25:04,170 --> 00:25:11,340
it's basically kind of seamless he c vm

00:25:08,850 --> 00:25:12,330
x of just the code sequence and just

00:25:11,340 --> 00:25:23,399
jumps to the

00:25:12,330 --> 00:25:27,390
instruction so nothing happened okay now

00:25:23,399 --> 00:25:30,149
this is a prototype implementation how

00:25:27,390 --> 00:25:37,250
you know how we did is so basically we

00:25:30,149 --> 00:25:37,250
added the new I'll control to kb m ok

00:25:38,000 --> 00:25:50,190
here ok which is a switch and exit ok

00:25:45,889 --> 00:25:52,620
what it does is basically construct pmcs

00:25:50,190 --> 00:25:55,019
BMC's is virtual machine control

00:25:52,620 --> 00:26:01,049
structure basically it has the guest

00:25:55,019 --> 00:26:06,510
stage and host estate ok in this case we

00:26:01,049 --> 00:26:08,429
set the host r.i.p this is a you know

00:26:06,510 --> 00:26:12,380
instruction pointer into entry point

00:26:08,429 --> 00:26:14,519
when you enter the witchy you know which

00:26:12,380 --> 00:26:17,909
instruction that the guest needs to

00:26:14,519 --> 00:26:23,039
execute the first so what we do is

00:26:17,909 --> 00:26:26,820
certain this r.i.p gets are a p2 then

00:26:23,039 --> 00:26:31,620
again the next instruction ok so when we

00:26:26,820 --> 00:26:34,860
do when the colonel does vm entering

00:26:31,620 --> 00:26:37,769
instruction then just jump to the go to

00:26:34,860 --> 00:26:39,570
the next two instruction so again from

00:26:37,769 --> 00:26:42,019
carlos point of view it's just a

00:26:39,570 --> 00:26:45,179
seamless contiguously you know are

00:26:42,019 --> 00:26:47,510
executed instructions to be so it's very

00:26:45,179 --> 00:26:47,510
simple

00:26:51,610 --> 00:26:58,970
yeah and then this separate BMX Andhra

00:26:54,950 --> 00:27:01,910
does the monitoring and then protection

00:26:58,970 --> 00:27:07,430
for the proper you know bare metal

00:27:01,910 --> 00:27:11,720
lyrics about EPT extended page table we

00:27:07,430 --> 00:27:15,260
can construct in advance or other option

00:27:11,720 --> 00:27:22,450
we can construct at the runtime as we

00:27:15,260 --> 00:27:22,450
get you know BMX our apt vibration yep

00:27:24,160 --> 00:27:29,600
any question I can take a questionnaire

00:27:27,380 --> 00:27:45,620
for you guys this is a little complex

00:27:29,600 --> 00:27:48,020
thing so if you okay you use mic yep the

00:27:45,620 --> 00:27:50,810
the switching back and forth from root

00:27:48,020 --> 00:27:53,210
mode non-root mode does that not in

00:27:50,810 --> 00:27:57,470
itself defeat the purpose of the

00:27:53,210 --> 00:28:00,800
security does that not create a whole we

00:27:57,470 --> 00:28:06,730
may have some hole when we switch to the

00:28:00,800 --> 00:28:11,060
kvm yes so if que bien if that attack is

00:28:06,730 --> 00:28:16,720
inside a kbm right if somebody tweak the

00:28:11,060 --> 00:28:21,490
kba module then yeah it's possible yeah

00:28:16,720 --> 00:28:24,110
but again I think you know we can have a

00:28:21,490 --> 00:28:26,330
you know the code is very limited by the

00:28:24,110 --> 00:28:29,930
small piece of code that changes from

00:28:26,330 --> 00:28:34,690
the guests to the host so rather than

00:28:29,930 --> 00:28:37,310
scary you know having that the point

00:28:34,690 --> 00:28:39,770
every in the colonel I think if we just

00:28:37,310 --> 00:28:43,580
focus on the one point then switch

00:28:39,770 --> 00:28:46,600
between the guest mode versus a root

00:28:43,580 --> 00:28:52,340
mode versus a non-root mode then I think

00:28:46,600 --> 00:28:53,750
we have a more confident so basically

00:28:52,340 --> 00:28:55,130
you're trying to the other thing you're

00:28:53,750 --> 00:28:57,950
preventing the tragic event is that

00:28:55,130 --> 00:29:01,070
somebody manages to get code execution

00:28:57,950 --> 00:29:02,480
or anything in your in CPL 0 and then

00:29:01,070 --> 00:29:03,830
it's able to break out onto the actual

00:29:02,480 --> 00:29:04,790
system using that right i mean that's

00:29:03,830 --> 00:29:07,250
basically the thing you're trying to

00:29:04,790 --> 00:29:09,380
event now if i'm in CPL zero i can just

00:29:07,250 --> 00:29:11,330
write code that basically construct my

00:29:09,380 --> 00:29:14,330
own vm CS and I call the same thing and

00:29:11,330 --> 00:29:16,010
I basically have food mode so if I know

00:29:14,330 --> 00:29:17,900
that I'm running on such a system I

00:29:16,010 --> 00:29:21,680
don't buy any security I completely

00:29:17,900 --> 00:29:24,230
agree yeah but invite bus what was for

00:29:21,680 --> 00:29:27,500
example you get somebody you once you

00:29:24,230 --> 00:29:28,460
get into this mode right well then CPL 0

00:29:27,500 --> 00:29:30,260
that's all you need you don't need to

00:29:28,460 --> 00:29:33,380
modify kvm adore you don't have to care

00:29:30,260 --> 00:29:35,360
about kvm at all once you either you do

00:29:33,380 --> 00:29:38,090
have a colonel I explode or you don't if

00:29:35,360 --> 00:29:39,830
you do have a colonel I exploit then you

00:29:38,090 --> 00:29:41,030
don't buy additional security except for

00:29:39,830 --> 00:29:43,190
the few parts that you managed to

00:29:41,030 --> 00:29:45,740
prevent beforehand because you were able

00:29:43,190 --> 00:29:48,230
to like trap read-only pages and stuff

00:29:45,740 --> 00:29:55,550
but like other than that there's nothing

00:29:48,230 --> 00:29:57,680
that she prevents things just I want to

00:29:55,550 --> 00:30:00,170
come back to that moment after this one

00:29:57,680 --> 00:30:05,660
okay and can you ask that question again

00:30:00,170 --> 00:30:11,690
yeah okay so okay before that I want to

00:30:05,660 --> 00:30:15,160
cover that the performance stuff so so

00:30:11,690 --> 00:30:18,770
we ran some you know the micro bench on

00:30:15,160 --> 00:30:23,080
like Adam bench animate is a good to

00:30:18,770 --> 00:30:26,080
detect order you know overhead okay and

00:30:23,080 --> 00:30:29,540
three know then the bare metal and then

00:30:26,080 --> 00:30:34,100
non-root bare metal and then the kbm

00:30:29,540 --> 00:30:37,490
guest and those are the system call okay

00:30:34,100 --> 00:30:41,630
as you see there are some visible

00:30:37,490 --> 00:30:46,460
overhead with the kvm okay if you just

00:30:41,630 --> 00:30:49,070
run kbm with the this one you don't see

00:30:46,460 --> 00:30:54,440
any difference between pyramidal okay so

00:30:49,070 --> 00:30:58,220
we don't have a you know visible

00:30:54,440 --> 00:31:00,590
overhead with this one something we

00:30:58,220 --> 00:31:03,050
observed was this one but this is kind

00:31:00,590 --> 00:31:06,950
of not noise level well this so one

00:31:03,050 --> 00:31:11,420
point something this is kind of the max

00:31:06,950 --> 00:31:14,060
latency or the overhead we saw okay the

00:31:11,420 --> 00:31:14,960
major reason is again we're doing pass

00:31:14,060 --> 00:31:18,289
through and

00:31:14,960 --> 00:31:29,510
and you know we only monitor specific

00:31:18,289 --> 00:31:36,130
areas today ok so now I'm talking about

00:31:29,510 --> 00:31:40,640
the more advanced you know use cases so

00:31:36,130 --> 00:31:43,279
obviously debugging right you can monito

00:31:40,640 --> 00:31:47,260
protect some area which means you can

00:31:43,279 --> 00:31:49,909
you know you can do some of debugging

00:31:47,260 --> 00:31:52,549
focusing on some of example if you you

00:31:49,909 --> 00:31:55,520
you want to monitor if somebody is

00:31:52,549 --> 00:31:58,760
writing some area then you can you know

00:31:55,520 --> 00:32:04,880
right to protect and use this as a kind

00:31:58,760 --> 00:32:07,429
of debugger ok other area is in

00:32:04,880 --> 00:32:12,919
virtualization we have a more capability

00:32:07,429 --> 00:32:16,760
or in hardware the reason is we want to

00:32:12,919 --> 00:32:21,200
monitor the guest you know more means

00:32:16,760 --> 00:32:24,590
for example the PLM it's called a page

00:32:21,200 --> 00:32:27,230
modification login so this is not

00:32:24,590 --> 00:32:31,600
available in a bare-metal system but if

00:32:27,230 --> 00:32:34,820
you run the you know our OS in

00:32:31,600 --> 00:32:38,659
virtualization the hypervisor can

00:32:34,820 --> 00:32:42,860
monitor which pages in a guest or

00:32:38,659 --> 00:32:45,980
modified ok so this will be good to you

00:32:42,860 --> 00:32:50,590
know monitor memory activity in a guest

00:32:45,980 --> 00:32:52,970
ok or you can get additional or

00:32:50,590 --> 00:32:55,669
exception this is the so-called

00:32:52,970 --> 00:32:59,360
virtualization exception as you see the

00:32:55,669 --> 00:33:02,240
name so on the native system you don't

00:32:59,360 --> 00:33:04,659
get this kind of exception but if you

00:33:02,240 --> 00:33:07,460
run that system in you know

00:33:04,659 --> 00:33:09,500
virtualization read mode now you can get

00:33:07,460 --> 00:33:14,510
this kind of exception of course the

00:33:09,500 --> 00:33:17,450
hypervisor enable this one ok and the

00:33:14,510 --> 00:33:22,760
other thing is a hot patch Rebecca said

00:33:17,450 --> 00:33:25,940
and then intercepting exception this is

00:33:22,760 --> 00:33:28,470
a more like a brainstorming so okay so

00:33:25,940 --> 00:33:33,750
I'm not sure this may work on

00:33:28,470 --> 00:33:40,320
but you know many dolls attack actually

00:33:33,750 --> 00:33:44,039
you use / 0 or page fold in a colonel

00:33:40,320 --> 00:33:46,830
okay so if you know for example your

00:33:44,039 --> 00:33:49,890
colonel has that kind of attribute and

00:33:46,830 --> 00:33:52,950
you know how the colonel knows right but

00:33:49,890 --> 00:33:57,000
you don't want to reboot the system in

00:33:52,950 --> 00:34:01,770
that case you either patch the colonel

00:33:57,000 --> 00:34:03,600
right or you use you can use this

00:34:01,770 --> 00:34:07,409
counting and this might be better

00:34:03,600 --> 00:34:11,490
because you can have the patch in a

00:34:07,409 --> 00:34:18,179
separate component and for many cases

00:34:11,490 --> 00:34:20,879
you may be able to avoid modification to

00:34:18,179 --> 00:34:24,830
the binary patch to the guest operating

00:34:20,879 --> 00:34:28,800
system because we can intercept the

00:34:24,830 --> 00:34:31,950
again divide by zero in hypervisor and

00:34:28,800 --> 00:34:35,220
we can change the behavior okay for

00:34:31,950 --> 00:34:39,629
example we can modify that the term

00:34:35,220 --> 00:34:43,770
berry from the instruction okay for some

00:34:39,629 --> 00:34:46,440
are those attack that may may not work

00:34:43,770 --> 00:34:51,320
but for some that may work so depending

00:34:46,440 --> 00:34:51,320
on the bugs or the exploit it made work

00:34:54,290 --> 00:35:02,070
so the current status and so we have

00:34:58,619 --> 00:35:05,070
having the POC has been done and then

00:35:02,070 --> 00:35:07,580
the code is very small it's like our

00:35:05,070 --> 00:35:11,810
less than thousand lines of code of

00:35:07,580 --> 00:35:15,780
course some are in assembly code right

00:35:11,810 --> 00:35:23,070
but it's small and then again this is a

00:35:15,780 --> 00:35:25,770
container kbm module okay we are working

00:35:23,070 --> 00:35:29,280
on our policies and then actions and

00:35:25,770 --> 00:35:33,109
then we're planning to share the patch

00:35:29,280 --> 00:35:36,150
with community getting some feedback and

00:35:33,109 --> 00:35:39,200
next step is you know we're gonna send

00:35:36,150 --> 00:35:44,440
out some RFC with patch so that cuts

00:35:39,200 --> 00:35:48,290
prod okay so if all you know you are

00:35:44,440 --> 00:35:50,540
interested in you know debugging

00:35:48,290 --> 00:35:59,359
inaudible stuff well this might be the

00:35:50,540 --> 00:36:02,230
good area okay because if you run the

00:35:59,359 --> 00:36:07,790
bare metal colonel okay in

00:36:02,230 --> 00:36:10,010
virtualization sometimes when you you

00:36:07,790 --> 00:36:12,560
know we already don't have completed at

00:36:10,010 --> 00:36:17,270
the buggy but when we done this forest

00:36:12,560 --> 00:36:20,839
we never saw anything right right after

00:36:17,270 --> 00:36:24,410
we've example start running a guest bed

00:36:20,839 --> 00:36:28,520
then we lost the system block you know

00:36:24,410 --> 00:36:30,589
Brock screen of course we completed that

00:36:28,520 --> 00:36:33,020
kind of thing so if you really want to

00:36:30,589 --> 00:36:35,200
enjoy the car oh you know Laura for the

00:36:33,020 --> 00:36:38,900
working this this would be should be fun

00:36:35,200 --> 00:36:43,760
okay so now I'll take a back go back to

00:36:38,900 --> 00:36:49,670
Alexa question so I didn't expect that

00:36:43,760 --> 00:36:52,040
that creature so so I guess what it

00:36:49,670 --> 00:36:53,540
really boils down to is it feels a bit

00:36:52,040 --> 00:36:54,619
like a solution searching for a problem

00:36:53,540 --> 00:36:57,589
rather than a problem searching for

00:36:54,619 --> 00:36:59,210
solution and I'm just trying to figure

00:36:57,589 --> 00:37:03,700
out what the actual problem is you are

00:36:59,210 --> 00:37:05,810
trying to solve really as in what what

00:37:03,700 --> 00:37:07,400
functionality I mean I've seen this lie

00:37:05,810 --> 00:37:09,710
down like you're missing a few pieces

00:37:07,400 --> 00:37:11,780
where you can trap certain things but

00:37:09,710 --> 00:37:13,400
the fact that you can trap them probably

00:37:11,780 --> 00:37:14,930
means that nobody actually asked Intel

00:37:13,400 --> 00:37:18,560
to actually have them trouble or have

00:37:14,930 --> 00:37:20,930
them recordable so what what is status

00:37:18,560 --> 00:37:24,650
quo missing in Linux in just general

00:37:20,930 --> 00:37:29,349
Linux operating systems that you do need

00:37:24,650 --> 00:37:33,710
for what use case that this enables you

00:37:29,349 --> 00:37:37,160
first of all are the goal is to keep the

00:37:33,710 --> 00:37:39,530
integrity of colonel for example colonel

00:37:37,160 --> 00:37:41,960
has a lots of assumptions right the you

00:37:39,530 --> 00:37:44,680
know kuroda proposal assumption of a

00:37:41,960 --> 00:37:48,069
data structure some are read-only

00:37:44,680 --> 00:37:51,940
or does set up that the configuration he

00:37:48,069 --> 00:37:54,280
said is a should be starting right if

00:37:51,940 --> 00:37:57,670
some bug was something happened and you

00:37:54,280 --> 00:38:00,640
really want to detect otherwise

00:37:57,670 --> 00:38:04,960
debugging was sobbing would be you know

00:38:00,640 --> 00:38:09,359
on its compared comp rack so from at

00:38:04,960 --> 00:38:11,619
least I mean my limited view point I

00:38:09,359 --> 00:38:13,270
don't really remember too many cases

00:38:11,619 --> 00:38:15,430
where you suddenly have a second page

00:38:13,270 --> 00:38:16,900
table that happens to point at kernel

00:38:15,430 --> 00:38:19,440
memory which then happens to be read

00:38:16,900 --> 00:38:21,790
wide usually the box we have for either

00:38:19,440 --> 00:38:23,410
hardware issues and well that's what you

00:38:21,790 --> 00:38:26,050
have i oh muse and stuff for all you

00:38:23,410 --> 00:38:27,760
have actually like real hardware issues

00:38:26,050 --> 00:38:30,160
like the the thing where you just have

00:38:27,760 --> 00:38:32,980
memory flip but memory bit flips alright

00:38:30,160 --> 00:38:34,869
but this doesn't prevent memory bit

00:38:32,980 --> 00:38:37,510
flips it doesn't prevent hardware going

00:38:34,869 --> 00:38:40,270
wrong the only thing it prevents is a

00:38:37,510 --> 00:38:41,800
software bug basically that you then

00:38:40,270 --> 00:38:45,430
would modify kernel memory and you can

00:38:41,800 --> 00:38:47,109
still modify kernel memory in space in

00:38:45,430 --> 00:38:48,640
some space that then is weed wide so if

00:38:47,109 --> 00:38:50,020
you are actually able to control a

00:38:48,640 --> 00:38:51,970
pointer you could then point it to

00:38:50,020 --> 00:38:53,349
something that is weed wide and because

00:38:51,970 --> 00:38:55,569
that sweet ride you just have to find

00:38:53,349 --> 00:38:57,069
something else we'd white and executable

00:38:55,569 --> 00:38:58,720
I am sure you will find something and

00:38:57,069 --> 00:39:00,040
then you suddenly have all the root mode

00:38:58,720 --> 00:39:01,809
that you want again if you have a

00:39:00,040 --> 00:39:04,089
malicious attacker this won't prevent

00:39:01,809 --> 00:39:05,980
anything if you have if you will only

00:39:04,089 --> 00:39:08,829
get along if you're certain like a

00:39:05,980 --> 00:39:12,309
slightly tiny bit more confidence that

00:39:08,829 --> 00:39:16,480
nothing happens by accident well I think

00:39:12,309 --> 00:39:19,839
here first of all there are security you

00:39:16,480 --> 00:39:22,059
know making system secure is not just a

00:39:19,839 --> 00:39:25,480
kernel right it is sure to go across the

00:39:22,059 --> 00:39:27,849
protocol and yeah this scope is only

00:39:25,480 --> 00:39:31,119
kernel and some even the call it's

00:39:27,849 --> 00:39:34,119
summer look some low-level right and try

00:39:31,119 --> 00:39:36,579
to provide consistent view of the

00:39:34,119 --> 00:39:39,700
program okay so basically helping a

00:39:36,579 --> 00:39:42,490
program the other thing is we are

00:39:39,700 --> 00:39:46,270
actually adding more security features

00:39:42,490 --> 00:39:48,880
to the hardware there are those are

00:39:46,270 --> 00:39:52,990
available in virtualization so I really

00:39:48,880 --> 00:39:54,760
wanna you know linux our developers

00:39:52,990 --> 00:39:56,950
Colonel the word prostitute to take

00:39:54,760 --> 00:39:59,609
advantage of a more advanced security

00:39:56,950 --> 00:39:59,609
features

00:40:02,090 --> 00:40:05,460
okay I think I slowly I slowly

00:40:04,290 --> 00:40:07,440
understand where you're getting it

00:40:05,460 --> 00:40:08,970
you're basically doing the thing that

00:40:07,440 --> 00:40:10,410
AMD does with the encrypted virtual

00:40:08,970 --> 00:40:12,480
machines you can authenticate yourself

00:40:10,410 --> 00:40:13,950
and that only works in virtual machines

00:40:12,480 --> 00:40:18,990
and so you want to be prepared when the

00:40:13,950 --> 00:40:21,420
time comes what that the other thing but

00:40:18,990 --> 00:40:28,020
but yeah all right make sense that that

00:40:21,420 --> 00:40:31,290
makes a lot of sense cool um I have a

00:40:28,020 --> 00:40:33,060
question maybe it was the thing to

00:40:31,290 --> 00:40:34,560
better understand how you're doing it

00:40:33,060 --> 00:40:39,260
you said that you have an identity

00:40:34,560 --> 00:40:42,030
mapping so whether you put the the

00:40:39,260 --> 00:40:44,130
hypervisor shim when you have an

00:40:42,030 --> 00:40:45,870
identity vamping there must be some some

00:40:44,130 --> 00:40:48,630
kind of difference between the the

00:40:45,870 --> 00:40:50,760
bare-metal memory layout and see

00:40:48,630 --> 00:40:53,280
identity mappings to put it on the top

00:40:50,760 --> 00:40:59,100
of the memory or where do you hide the

00:40:53,280 --> 00:41:00,930
the you look it's almost a gun and and

00:40:59,100 --> 00:41:04,770
then the next question is when you when

00:41:00,930 --> 00:41:07,650
you deep remote ok and you promote from

00:41:04,770 --> 00:41:10,920
non-root mode to to root mode doesn't

00:41:07,650 --> 00:41:16,020
mean that then the the guest runs in on

00:41:10,920 --> 00:41:19,470
their metal or you're talking about bare

00:41:16,020 --> 00:41:23,160
metal case or kvm gasps the but when you

00:41:19,470 --> 00:41:26,790
start a KTM guests wow you said there's

00:41:23,160 --> 00:41:29,820
in the vm off ok billion guess we'll

00:41:26,790 --> 00:41:32,790
just continue to run in a kvm guest the

00:41:29,820 --> 00:41:42,960
one I talked about was that for the bare

00:41:32,790 --> 00:41:46,760
metal case right maybe just go back this

00:41:42,960 --> 00:41:49,980
one a world is one year okay um when you

00:41:46,760 --> 00:41:52,380
this case is for example this I'll

00:41:49,980 --> 00:41:55,530
control will be triggered by user mode

00:41:52,380 --> 00:42:00,150
right then that the mode that program

00:41:55,530 --> 00:42:03,650
does this new I control so it's this one

00:42:00,150 --> 00:42:09,670
okay he does I'll control then you know

00:42:03,650 --> 00:42:14,530
from there once we do be a mentor than

00:42:09,670 --> 00:42:16,900
the this kernel start running in a BMX

00:42:14,530 --> 00:42:19,990
non-root mode then go back to user so

00:42:16,900 --> 00:42:22,510
the user process entire process right in

00:42:19,990 --> 00:42:25,319
the system we start running in a BMXer

00:42:22,510 --> 00:42:30,490
you know ver tradition non-root mode

00:42:25,319 --> 00:42:35,589
this is not a kvm again this is a this

00:42:30,490 --> 00:42:40,660
is a bare metal linux okay yeah have you

00:42:35,589 --> 00:42:46,619
thought about wining kvm in the

00:42:40,660 --> 00:42:49,960
privilege to bare metal linux like

00:42:46,619 --> 00:42:52,900
virtualizing vmx on vm x off and all

00:42:49,960 --> 00:42:57,339
that so that you can still run virtual

00:42:52,900 --> 00:42:59,619
machines in this next virtualization

00:42:57,339 --> 00:43:01,780
yeah because I mean it's much simpler

00:42:59,619 --> 00:43:04,270
than message because of course it's

00:43:01,780 --> 00:43:06,490
partially identity mapped like of the

00:43:04,270 --> 00:43:07,960
three layers of page tables the outer

00:43:06,490 --> 00:43:11,740
one is identity so you don't need

00:43:07,960 --> 00:43:16,390
shadowing you can simplify a lot of

00:43:11,740 --> 00:43:22,420
things actually polymorph VMS es field

00:43:16,390 --> 00:43:27,190
can be this this one right I don't know

00:43:22,420 --> 00:43:29,559
so you are saying so in this case this

00:43:27,190 --> 00:43:32,200
one this you know this one native this

00:43:29,559 --> 00:43:36,970
is from a native right running on a bare

00:43:32,200 --> 00:43:38,740
metal and if we just go to this one

00:43:36,970 --> 00:43:43,180
which are doing if we this doesn't

00:43:38,740 --> 00:43:46,690
happen then we continue to run in the

00:43:43,180 --> 00:43:49,390
non-root mode right then que vienen

00:43:46,690 --> 00:43:52,809
finds try to do some for example be a

00:43:49,390 --> 00:43:55,839
mentor I say what be you know then that

00:43:52,809 --> 00:43:58,150
generate vm exit yes right so back to

00:43:55,839 --> 00:43:59,859
this or that base connected vertices so

00:43:58,150 --> 00:44:03,010
yeah so my two questions about these our

00:43:59,859 --> 00:44:05,049
first performance and second whether you

00:44:03,010 --> 00:44:07,329
need to actually protect some vm CS

00:44:05,049 --> 00:44:11,710
fields and how do you do that so the

00:44:07,329 --> 00:44:14,410
performance the cost of this one BMX it

00:44:11,710 --> 00:44:16,780
is a less than thousand psycho it's

00:44:14,410 --> 00:44:19,410
actually lighter than

00:44:16,780 --> 00:44:23,280
you'll be an exit because you just

00:44:19,410 --> 00:44:28,630
continue to you know run you know and

00:44:23,280 --> 00:44:31,240
you you can optimize that processor

00:44:28,630 --> 00:44:33,310
state to save right you don't do

00:44:31,240 --> 00:44:35,350
anything you just continue to jump to

00:44:33,310 --> 00:44:41,580
the next instruction yeah so it's

00:44:35,350 --> 00:44:45,040
lighter than our usual vm exit okay and

00:44:41,580 --> 00:44:48,370
do you have you can trap like the vm

00:44:45,040 --> 00:44:51,900
read nvm i am right to shadow them well

00:44:48,370 --> 00:44:55,170
we can do that so we can avoid this one

00:44:51,900 --> 00:44:57,990
continue to run in kb m in

00:44:55,170 --> 00:45:00,970
virtualization the nested virtualization

00:44:57,990 --> 00:45:06,580
we haven't made sure that you know that

00:45:00,970 --> 00:45:12,820
kind of performance yet but i think this

00:45:06,580 --> 00:45:21,730
is a move you know are more optimal or

00:45:12,820 --> 00:45:24,640
you know solution ok yeah hi so i think

00:45:21,730 --> 00:45:26,110
if i understand correctly the the issue

00:45:24,640 --> 00:45:28,690
that was discussed in security wise

00:45:26,110 --> 00:45:32,590
before was that if an attacker can issue

00:45:28,690 --> 00:45:34,870
a vm x off then the protection provides

00:45:32,590 --> 00:45:38,590
is there's not their security you can

00:45:34,870 --> 00:45:39,670
turn off is not secured at all but do

00:45:38,590 --> 00:45:42,760
you think that there is actually a use

00:45:39,670 --> 00:45:44,770
case where you could have like openbsd s

00:45:42,760 --> 00:45:46,750
pledge we say i'm not going to issue any

00:45:44,770 --> 00:45:50,950
more vm CS management anymore and you

00:45:46,750 --> 00:45:57,790
break the fuse yeah so did this one

00:45:50,950 --> 00:45:59,590
right if we can change this behavior at

00:45:57,790 --> 00:46:02,860
this point this is you you can go back

00:45:59,590 --> 00:46:05,200
and forth but depending on the

00:46:02,860 --> 00:46:08,080
implementation the hypervisor if you

00:46:05,200 --> 00:46:11,410
allow only one transition for the life

00:46:08,080 --> 00:46:14,530
of the system right then somebody else

00:46:11,410 --> 00:46:17,380
try try to vm x 0 then in that case

00:46:14,530 --> 00:46:21,970
that's a mauritius because we only allow

00:46:17,380 --> 00:46:23,710
one x transition right i think that

00:46:21,970 --> 00:46:28,050
could have some applications with its

00:46:23,710 --> 00:46:28,050
aesthetic embedded device yeah

00:46:29,199 --> 00:46:36,079
how do you handle multiple consumers of

00:46:31,939 --> 00:46:38,089
the dmx extensions multiple consumers

00:46:36,079 --> 00:46:46,400
yeah like a vmware workstation for

00:46:38,089 --> 00:46:48,019
instance Tehran days on the VMO or now

00:46:46,400 --> 00:46:58,519
if you're running vmware workstation on

00:46:48,019 --> 00:47:02,449
this list version of linux ok ok so you

00:46:58,519 --> 00:47:05,569
talking about ok additional so you have

00:47:02,449 --> 00:47:07,189
a vm a driver in the colonel the initial

00:47:05,569 --> 00:47:11,779
driver that use european market

00:47:07,189 --> 00:47:14,900
sanctions i think we can do can have a

00:47:11,779 --> 00:47:17,419
dis kind of thing as well so initially

00:47:14,900 --> 00:47:20,419
we had this code in actually the context

00:47:17,419 --> 00:47:23,900
which we make our the part you know see

00:47:20,419 --> 00:47:27,199
groups for kb m so when we enter the kvm

00:47:23,900 --> 00:47:30,979
we do this so we kind of example or tell

00:47:27,199 --> 00:47:36,019
that the colonel order the vm a driver

00:47:30,979 --> 00:47:38,299
right Oh to cause this contain then the

00:47:36,019 --> 00:47:41,569
BMA will get the native of MX you know

00:47:38,299 --> 00:47:46,099
future and will this require changes to

00:47:41,569 --> 00:47:50,029
their software as well I think I need to

00:47:46,099 --> 00:47:56,989
think about or the other way is easiest

00:47:50,029 --> 00:47:59,709
it is a this this happens per CPU okay

00:47:56,989 --> 00:48:02,569
so you can run some cpu in

00:47:59,709 --> 00:48:06,650
virtualization non-root mode okay and

00:48:02,569 --> 00:48:10,059
you can continue to run our the rest as

00:48:06,650 --> 00:48:14,179
just you know native mode in that case

00:48:10,059 --> 00:48:21,109
if you bind those processes to you know

00:48:14,179 --> 00:48:23,239
be ma you don't need to do anything so

00:48:21,109 --> 00:48:25,249
add a quick question about pml so I do

00:48:23,239 --> 00:48:26,779
quite understand how what more

00:48:25,249 --> 00:48:29,089
information you're getting just because

00:48:26,779 --> 00:48:32,390
you're running the host in non-root mode

00:48:29,089 --> 00:48:37,239
so so pml still gives the same one

00:48:32,390 --> 00:48:37,239
information right yeah pml basically a

00:48:37,419 --> 00:48:43,010
causes a BMX it a

00:48:40,160 --> 00:48:46,069
for example the number of a vm the

00:48:43,010 --> 00:48:49,579
modified the pages reach 5 12 or

00:48:46,069 --> 00:48:52,010
whatever number okay then there's a log

00:48:49,579 --> 00:48:58,280
in which guest of physical pages or

00:48:52,010 --> 00:49:01,940
modify okay so that case if you use that

00:48:58,280 --> 00:49:05,289
for the native Colonel the bare metal

00:49:01,940 --> 00:49:10,430
Colonel then you can tell which pages

00:49:05,289 --> 00:49:12,740
have been modified but the metric

00:49:10,430 --> 00:49:14,539
colonel knows you mean kvm will learn

00:49:12,740 --> 00:49:17,270
about the best you know okay so

00:49:14,539 --> 00:49:21,770
properties to know which pages are

00:49:17,270 --> 00:49:25,940
modified okay you need to go through all

00:49:21,770 --> 00:49:27,589
the page table or you know somehow you

00:49:25,940 --> 00:49:29,990
need to write protect the proc file

00:49:27,589 --> 00:49:31,430
system I mean some something the profile

00:49:29,990 --> 00:49:34,670
system will tell you about what is idle

00:49:31,430 --> 00:49:39,530
what's not and so on not sure you you

00:49:34,670 --> 00:49:41,750
can effectively do that okay maybe I

00:49:39,530 --> 00:49:43,190
think it's possible but that's fine this

00:49:41,750 --> 00:49:45,470
is another way to I'm talking about the

00:49:43,190 --> 00:49:48,140
physical memory yes okay not that

00:49:45,470 --> 00:49:49,970
virtuous your jaw dress yeah but I

00:49:48,140 --> 00:49:52,760
admittedly this is another way to do it

00:49:49,970 --> 00:49:56,000
yes yeah and then in this case you don't

00:49:52,760 --> 00:49:58,490
need to work all the page table because

00:49:56,000 --> 00:50:01,819
page table has a modified access bit

00:49:58,490 --> 00:50:03,650
right and need to find out those which

00:50:01,819 --> 00:50:07,130
pages are modified you need to go

00:50:03,650 --> 00:50:09,500
through all the page table hierarchy but

00:50:07,130 --> 00:50:12,650
in this case you have just a log it's

00:50:09,500 --> 00:50:15,160
just a one-dimensional array contains

00:50:12,650 --> 00:50:18,799
over you know the page frame numbers

00:50:15,160 --> 00:50:24,200
okay now where you can simply identify

00:50:18,799 --> 00:50:27,020
which pages are modified okay I think

00:50:24,200 --> 00:50:31,390
I'm done so this is the end of my

00:50:27,020 --> 00:50:31,390

YouTube URL: https://www.youtube.com/watch?v=D6CCz2EZ2eo


