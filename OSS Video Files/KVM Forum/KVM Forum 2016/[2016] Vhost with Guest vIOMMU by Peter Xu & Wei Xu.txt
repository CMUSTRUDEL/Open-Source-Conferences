Title: [2016] Vhost with Guest vIOMMU by Peter Xu & Wei Xu
Publication date: 2016-09-12
Playlist: KVM Forum 2016
Description: 
	Vhost is the technique used in QEMU/KVM to accelerate IOs for virtio devices, so that guest IOs can be handled without trapping into QEMU userspace. While vhost boosts guest block/network performance, it also brings security issues considering it is (before this work) bypassing protection of vIOMMUs. This becomes a more critical issue for NFV scenarios, in which user-space drivers are vastly used. A problematic user space driver inside guest can directly corrupt guest kernel in no time. In this presentation, Jason Wang (Wei Xu as presenter) and Peter Xu will propose a solution to add guest vIOMMU protection for vhost devices, and some performance numbers.

Peter Xu
Software Engineer, Red Hat

Software engineer at Red Hat virtualization team.

Wei Xu
Red Hat

Slides: http://www.linux-kvm.org/images/c/c5/03x07B-Peter_Xu_and_Wei_Xu-Vhost_with_Guest_vIOMMU.pdf
Captions: 
	00:00:09,679 --> 00:00:18,000
thank good Avenue everybody welcome to

00:00:14,160 --> 00:00:20,670
this session so in this session we're

00:00:18,000 --> 00:00:24,630
going to sure you secure without

00:00:20,670 --> 00:00:27,150
transfer model with your guys and this

00:00:24,630 --> 00:00:31,309
basically it will involve both the host

00:00:27,150 --> 00:00:34,170
and the virtual Iowa and amusing in qmo

00:00:31,309 --> 00:00:38,420
before I introduce the authors let's

00:00:34,170 --> 00:00:38,420
have a have a look at the agenda first

00:00:39,770 --> 00:00:45,420
in this session I'll go to a few

00:00:43,469 --> 00:00:47,730
background knowledge about the island

00:00:45,420 --> 00:00:52,230
anew and the virtual realm you first and

00:00:47,730 --> 00:00:55,590
then thought why we do need a new secure

00:00:52,230 --> 00:00:59,219
that will transfer and this slide

00:00:55,590 --> 00:01:01,800
includes two main components the first

00:00:59,219 --> 00:01:06,659
one EMEA mapping which was Finch the bad

00:01:01,800 --> 00:01:09,920
Jason one hates the current but under

00:01:06,659 --> 00:01:12,510
the device met Henry in chemo and the

00:01:09,920 --> 00:01:14,670
interrupted mapping which was finished

00:01:12,510 --> 00:01:15,810
by a Peter Street here so he'll

00:01:14,670 --> 00:01:18,960
continually introduced to the

00:01:15,810 --> 00:01:20,640
interrupted remapping after me and he

00:01:18,960 --> 00:01:24,060
also you just introduced a few

00:01:20,640 --> 00:01:27,720
performance results and status and maybe

00:01:24,060 --> 00:01:31,560
the water to nest in the future okay

00:01:27,720 --> 00:01:34,280
that's why I hit me I have this man

00:01:31,560 --> 00:01:36,420
named Hiro the president I wish

00:01:34,280 --> 00:01:38,280
otherwise on maybe some people maybe

00:01:36,420 --> 00:01:41,420
think this may be finished by me I think

00:01:38,280 --> 00:01:46,290
it's not not good opposed to a yes enemy

00:01:41,420 --> 00:01:48,000
okay thank you okay let's have a quick

00:01:46,290 --> 00:01:50,579
look at the Iowa and the new and the

00:01:48,000 --> 00:01:53,729
virtual I have a new basically a

00:01:50,579 --> 00:01:55,799
hardware unit with the IO translation

00:01:53,729 --> 00:01:59,790
device isolation are the French of the

00:01:55,799 --> 00:02:03,180
pattern hardware I am you and this would

00:01:59,790 --> 00:02:07,200
normally achieved by some kind of device

00:02:03,180 --> 00:02:08,250
PMA and the interrupter in mapping and a

00:02:07,200 --> 00:02:09,810
virtual

00:02:08,250 --> 00:02:13,410
iommu it normal

00:02:09,810 --> 00:02:14,780
unrelated immu which works as if it's a

00:02:13,410 --> 00:02:18,540
real one

00:02:14,780 --> 00:02:21,930
currently we have both Intel power and

00:02:18,540 --> 00:02:24,690
the some pretty I'm a million km o which

00:02:21,930 --> 00:02:29,940
was supported or partially supported

00:02:24,690 --> 00:02:31,470
right now and the only thing I want to

00:02:29,940 --> 00:02:33,750
emphasize and occur with Fayed

00:02:31,470 --> 00:02:35,670
there's no any dependence between our

00:02:33,750 --> 00:02:39,060
hardware Ireland and the virtual iron

00:02:35,670 --> 00:02:42,570
menu in other words you don't need a

00:02:39,060 --> 00:02:47,700
hardware mm you on to launch a VM with a

00:02:42,570 --> 00:02:50,100
virtual hmmm you the motivation behind

00:02:47,700 --> 00:02:52,950
that it's quite straightforward of

00:02:50,100 --> 00:02:55,860
course it's for the security concern it

00:02:52,950 --> 00:02:58,709
is virtually well with the increasing

00:02:55,860 --> 00:03:01,950
popularity of the NFA and the DPD care

00:02:58,709 --> 00:03:04,650
for the recent years normally people

00:03:01,950 --> 00:03:06,360
will use some kind of user base holy

00:03:04,650 --> 00:03:07,470
moly travel to utilize the system

00:03:06,360 --> 00:03:10,560
resource

00:03:07,470 --> 00:03:14,549
first of all with CPU and the memory so

00:03:10,560 --> 00:03:18,600
this is the target of some performance

00:03:14,549 --> 00:03:21,350
critical users which we want who want

00:03:18,600 --> 00:03:25,440
the post highest performance and

00:03:21,350 --> 00:03:29,549
extremely low latency in some kind of

00:03:25,440 --> 00:03:32,549
usage some nested VM that IOT path path

00:03:29,549 --> 00:03:36,750
through will also get involved with the

00:03:32,549 --> 00:03:39,930
security risk and but unfortunately

00:03:36,750 --> 00:03:42,440
there's no any protection all right not

00:03:39,930 --> 00:03:49,470
for but our devices

00:03:42,440 --> 00:03:54,690
that's why do we need a new model that's

00:03:49,470 --> 00:03:58,859
let's have a look at the current divider

00:03:54,690 --> 00:04:05,220
it's just based overview mmm we can

00:03:58,859 --> 00:04:10,200
start from the top left part which is

00:04:05,220 --> 00:04:13,650
the guest we can say but I have not

00:04:10,200 --> 00:04:16,229
device can the driver can also be a DVD

00:04:13,650 --> 00:04:18,709
K which launched inside inside the user

00:04:16,229 --> 00:04:21,900
space or native but I'll not device

00:04:18,709 --> 00:04:22,700
instant inside the kernel or other

00:04:21,900 --> 00:04:25,610
device

00:04:22,700 --> 00:04:29,750
drivers may be for some interesting or

00:04:25,610 --> 00:04:32,740
some stuffs so and the memory page here

00:04:29,750 --> 00:04:37,370
is going to be used to bad riverine

00:04:32,740 --> 00:04:42,380
mm-hmm on the top on the right side who

00:04:37,370 --> 00:04:44,660
mo runs that's a cuomo provider back-end

00:04:42,380 --> 00:04:48,050
service and a memory api to collaborate

00:04:44,660 --> 00:04:50,030
with the guest driver to make it work at

00:04:48,050 --> 00:04:54,710
least although but I own that back-end

00:04:50,030 --> 00:04:56,720
here as a separate box actually there

00:04:54,710 --> 00:04:59,120
should be some kind of back-end should

00:04:56,720 --> 00:05:02,960
be also running inside at qmo such as

00:04:59,120 --> 00:05:05,350
the users based on but our back-end hmm

00:05:02,960 --> 00:05:07,700
I just worry the understanding so

00:05:05,350 --> 00:05:11,690
supposing we are just starting your new

00:05:07,700 --> 00:05:14,450
transfer start we start from the driver

00:05:11,690 --> 00:05:19,190
loading ok during the travel

00:05:14,450 --> 00:05:21,410
initialization the driver will set the

00:05:19,190 --> 00:05:25,130
memory page as the castle phase go ahead

00:05:21,410 --> 00:05:27,440
chest to the brain and then this address

00:05:25,130 --> 00:05:30,470
will be passed to totally remove

00:05:27,440 --> 00:05:32,150
back-end service the Pagani survives

00:05:30,470 --> 00:05:34,730
when they were asked for translation

00:05:32,150 --> 00:05:37,400
from API to translate this because the

00:05:34,730 --> 00:05:42,800
fatal girl just to a host virtual yes

00:05:37,400 --> 00:05:46,160
and then panned out time we almost get

00:05:42,800 --> 00:05:48,110
everything done that's we have set up

00:05:46,160 --> 00:05:53,240
the order or the scene for the poor a

00:05:48,110 --> 00:05:57,530
real DMA transfer ok it's quite exciting

00:05:53,240 --> 00:06:04,150
huh Oh family I've got a Olympic way

00:05:57,530 --> 00:06:07,130
rain I think but something very

00:06:04,150 --> 00:06:09,890
dangerous with this model you can say

00:06:07,130 --> 00:06:12,890
from all the memory pages is going to be

00:06:09,890 --> 00:06:16,100
used by the faith colleges which means

00:06:12,890 --> 00:06:20,950
all the whole whole gets the memories at

00:06:16,100 --> 00:06:24,080
just base work it exposed to the driver

00:06:20,950 --> 00:06:27,070
suppose some malicious generated second

00:06:24,080 --> 00:06:29,930
for a full chance I think a typical a

00:06:27,070 --> 00:06:32,700
typical attacked can be easily achieved

00:06:29,930 --> 00:06:34,590
by just seeking for some

00:06:32,700 --> 00:06:36,780
it's a virtual page in the memory with

00:06:34,590 --> 00:06:39,300
such as in the security case I was

00:06:36,780 --> 00:06:42,390
whatever and then just put it into the

00:06:39,300 --> 00:06:46,980
ravine and exported in the Berlin

00:06:42,390 --> 00:06:48,750
Network so this is quite happy so I

00:06:46,980 --> 00:06:52,680
think there should be a ton of

00:06:48,750 --> 00:06:54,990
thousand-odd hack technology to to

00:06:52,680 --> 00:06:58,320
attack the system that should be

00:06:54,990 --> 00:07:00,990
required disaster to the system on the

00:06:58,320 --> 00:07:06,090
other hand is a pretty awesome and

00:07:00,990 --> 00:07:08,670
elegant the next green round glass tool

00:07:06,090 --> 00:07:16,560
to the hackers I think I think that they

00:07:08,670 --> 00:07:19,260
can't love it anymore and so we we do

00:07:16,560 --> 00:07:21,660
need a new secure shell for model with

00:07:19,260 --> 00:07:26,010
this model definitely we should

00:07:21,660 --> 00:07:27,830
introduce mmm you to the guests and most

00:07:26,010 --> 00:07:32,430
of us start work be the same as before

00:07:27,830 --> 00:07:35,460
except the red pad so post the Kassadin

00:07:32,430 --> 00:07:39,170
the PMO has a visual menu here to

00:07:35,460 --> 00:07:42,360
collaborate we can say from the

00:07:39,170 --> 00:07:45,030
flowcharts this time we don't use any

00:07:42,360 --> 00:07:49,950
castle face cards just anymore instead

00:07:45,030 --> 00:07:52,920
of that we use the io virtual jazz which

00:07:49,950 --> 00:07:55,830
can be easily achieved by just using the

00:07:52,920 --> 00:07:59,510
TM API in general colonel and he said

00:07:55,830 --> 00:08:04,500
just will also be passed to the qmo and

00:07:59,510 --> 00:08:06,720
after that it will the difference papers

00:08:04,500 --> 00:08:10,280
hero you two out here the end you look

00:08:06,720 --> 00:08:15,330
up to gain to translate data to the new

00:08:10,280 --> 00:08:23,120
hosted virtual jazz so so right now we

00:08:15,330 --> 00:08:23,120
get a secure over the transfer okay sure

00:08:26,600 --> 00:08:33,140
recently a new favorite was introduced

00:08:29,630 --> 00:08:36,110
it to the Linux kernel but the memo

00:08:33,140 --> 00:08:38,660
skeptical is still on and emerging with

00:08:36,110 --> 00:08:43,280
this favorite guest virtual device we'll

00:08:38,660 --> 00:08:46,250
have to use the iOS at just space

00:08:43,280 --> 00:08:51,020
instead of the old gas which were jazz

00:08:46,250 --> 00:08:52,370
and other words the address will feel to

00:08:51,020 --> 00:08:54,470
feel so used

00:08:52,370 --> 00:08:57,380
but you were in the way to pay the

00:08:54,470 --> 00:09:03,980
negotiation then you can use this device

00:08:57,380 --> 00:09:07,280
anymore so we have got the secure no

00:09:03,980 --> 00:09:12,700
transfer model but here comes a new

00:09:07,280 --> 00:09:16,600
program from the new model we can see

00:09:12,700 --> 00:09:19,310
there this this should be a lot of

00:09:16,600 --> 00:09:21,830
interfering from the clear mo if we run

00:09:19,310 --> 00:09:23,330
them we host not in the kernel excellent

00:09:21,830 --> 00:09:25,670
of the host noddies were and the most

00:09:23,330 --> 00:09:27,650
popular back end right now because it

00:09:25,670 --> 00:09:31,820
had a very high performance and high

00:09:27,650 --> 00:09:34,880
reliability so in such a situation I

00:09:31,820 --> 00:09:37,370
think the interfering will impact the

00:09:34,880 --> 00:09:44,720
system performance dramatically so we

00:09:37,370 --> 00:09:48,170
need a further optimization and so how

00:09:44,720 --> 00:09:51,470
does we host survive we introduce a

00:09:48,170 --> 00:09:57,830
little bit from the pizza is back which

00:09:51,470 --> 00:10:02,990
named the 80s after that it has in the

00:09:57,830 --> 00:10:04,880
address translations of ice mmm in the

00:10:02,990 --> 00:10:07,540
short story it should be your kind of

00:10:04,880 --> 00:10:11,210
feasible to a lot of a specific piece ie

00:10:07,540 --> 00:10:14,960
device to synchronize until I would hear

00:10:11,210 --> 00:10:18,770
the entry from iommu TOB NGS full and

00:10:14,960 --> 00:10:21,980
then it can during the DMA it can direct

00:10:18,770 --> 00:10:24,500
access access the memory without any and

00:10:21,980 --> 00:10:27,710
any interference from iommu

00:10:24,500 --> 00:10:30,320
the sleep it can decouple the iommu and

00:10:27,710 --> 00:10:32,800
the device and faster the system

00:10:30,320 --> 00:10:32,800
performance

00:10:33,120 --> 00:10:39,430
actually we do have consider other

00:10:36,130 --> 00:10:42,430
alternatives before choose ATS such as

00:10:39,430 --> 00:10:45,089
we can implement an individual VDD in

00:10:42,430 --> 00:10:48,339
the host but the downside is

00:10:45,089 --> 00:10:50,470
unacceptable and acceptable such as it

00:10:48,339 --> 00:10:53,680
were involved a lot of code duplication

00:10:50,470 --> 00:10:55,500
with the current is IB MO and we should

00:10:53,680 --> 00:10:58,120
pay more attention to the vendor and

00:10:55,500 --> 00:10:59,980
architectural specific issue such as

00:10:58,120 --> 00:11:04,690
different city different architecture

00:10:59,980 --> 00:11:07,360
from Intel power whatever and which we

00:11:04,690 --> 00:11:11,620
should also take care of the new API for

00:11:07,360 --> 00:11:15,459
everybody on other side the benefit of

00:11:11,620 --> 00:11:18,160
the 88 is quite remarkable because it

00:11:15,459 --> 00:11:21,450
comes from the pizza is back and had a

00:11:18,160 --> 00:11:26,380
very nature part from independent

00:11:21,450 --> 00:11:28,779
personality and morally important we can

00:11:26,380 --> 00:11:35,560
easily achieve this based on the current

00:11:28,779 --> 00:11:38,140
Avenue infrastructure so so let's have a

00:11:35,560 --> 00:11:40,750
quick look at both the new device out

00:11:38,140 --> 00:11:45,750
here the flow chart with this flow chart

00:11:40,750 --> 00:11:50,070
we can see there had been a few catched

00:11:45,750 --> 00:11:54,490
gob entries here the field in the past

00:11:50,070 --> 00:12:00,040
means it's just start from a and has a

00:11:54,490 --> 00:12:02,130
sad one and it's read-only or writing or

00:12:00,040 --> 00:12:05,440
whatever

00:12:02,130 --> 00:12:08,380
suppose we are studying a new transfer a

00:12:05,440 --> 00:12:11,860
start from the that's just D then

00:12:08,380 --> 00:12:15,820
definitely work at a LT of amis in this

00:12:11,860 --> 00:12:18,370
case we all submit a require the quest

00:12:15,820 --> 00:12:20,560
will be hosted service narrative API to

00:12:18,370 --> 00:12:26,950
ask for translation it's kind of like

00:12:20,560 --> 00:12:30,040
the hard work dude so the IOT okie API

00:12:26,950 --> 00:12:32,470
you can incur more will vary find this

00:12:30,040 --> 00:12:35,920
ad adjust and see if it's a leak or

00:12:32,470 --> 00:12:39,820
legal adjust unfortunately if it's a

00:12:35,920 --> 00:12:42,400
illegal just then this this access will

00:12:39,820 --> 00:12:44,830
be blocked Rob rocked it automatically

00:12:42,400 --> 00:12:49,120
out with an error report

00:12:44,830 --> 00:12:52,839
and if it's a legal jazz then a new

00:12:49,120 --> 00:12:55,920
entry will be generated and right back

00:12:52,839 --> 00:13:00,670
to the we host Colonel we also know well

00:12:55,920 --> 00:13:05,940
get this update message and created a

00:13:00,670 --> 00:13:05,940
new entry in the Colonel interval tree

00:13:06,000 --> 00:13:15,370
then continue the transfer sometimes to

00:13:11,380 --> 00:13:18,760
after the look at the faint DMA then it

00:13:15,370 --> 00:13:22,660
will normally in general Colonel

00:13:18,760 --> 00:13:25,660
normally well issue a map request to

00:13:22,660 --> 00:13:28,329
divert menu but for most of the end of

00:13:25,660 --> 00:13:30,970
three drivers normally and do use the

00:13:28,329 --> 00:13:34,360
static banning so it means maybe in the

00:13:30,970 --> 00:13:37,300
case continued with the TLB entries with

00:13:34,360 --> 00:13:41,260
which we don't need more update

00:13:37,300 --> 00:13:43,510
operations in this case there were

00:13:41,260 --> 00:13:46,720
active API were outstanding in Veritate

00:13:43,510 --> 00:13:49,060
invalidate message' to the play host

00:13:46,720 --> 00:13:53,680
we host of demo deleted or correspond

00:13:49,060 --> 00:13:56,709
Oregonian entries from the tray hmm the

00:13:53,680 --> 00:14:02,070
idea is pretty clear I think so this

00:13:56,709 --> 00:14:02,070
time we got a Toronto bourbon

00:14:03,149 --> 00:14:10,149
so I finish to finish in the DMA out

00:14:07,060 --> 00:14:12,399
were with the summary the actually the

00:14:10,149 --> 00:14:14,350
design idea to produce are clear so

00:14:12,399 --> 00:14:16,209
first of the wall which would switch on

00:14:14,350 --> 00:14:19,899
the gas phase words just to my aversion

00:14:16,209 --> 00:14:22,270
adjust and then you should keep the IOT

00:14:19,899 --> 00:14:25,360
of you catch in the kernel all the time

00:14:22,270 --> 00:14:27,699
and make sure we always translate look

00:14:25,360 --> 00:14:31,420
up the entries first before we you

00:14:27,699 --> 00:14:33,220
student request for chemo and then we

00:14:31,420 --> 00:14:37,360
should handle the synchronization as

00:14:33,220 --> 00:14:39,310
well I'm sorry the pit structure under

00:14:37,360 --> 00:14:42,880
you dissipate on the corner interface is

00:14:39,310 --> 00:14:45,880
also quite straightforward we introduce

00:14:42,880 --> 00:14:48,250
a new interval tree for to save the

00:14:45,880 --> 00:14:50,649
heavy entries mmm

00:14:48,250 --> 00:14:52,870
the interval tray it's kind of structure

00:14:50,649 --> 00:14:55,180
based on the current red black tree in

00:14:52,870 --> 00:14:56,540
kernel so it has very good performance

00:14:55,180 --> 00:14:59,120
for

00:14:56,540 --> 00:15:02,810
I frequents apparently our updates

00:14:59,120 --> 00:15:04,940
insert lead of populations and the

00:15:02,810 --> 00:15:07,040
message quake was also introduced

00:15:04,940 --> 00:15:11,060
imperative a host identity was

00:15:07,040 --> 00:15:14,780
synchronized kind of the iterate of FD

00:15:11,060 --> 00:15:19,040
it iterations was introduced to keep

00:15:14,780 --> 00:15:19,520
them serialized okay and that's all for

00:15:19,040 --> 00:15:21,950
me

00:15:19,520 --> 00:15:25,060
let's give you are introduced the

00:15:21,950 --> 00:15:25,060
interrupt I love you guys

00:15:37,279 --> 00:15:49,860
hi hi everyone is that okay yeah okay

00:15:47,040 --> 00:15:52,019
hi everyone third time I'm Peter Shi

00:15:49,860 --> 00:15:53,399
from Red Hat and working on the

00:15:52,019 --> 00:15:56,940
interrupter mapping in the past few

00:15:53,399 --> 00:16:00,170
months and I would like to do a very

00:15:56,940 --> 00:16:03,300
quick overview um what's it about

00:16:00,170 --> 00:16:06,540
so as we has already mentioned that we

00:16:03,300 --> 00:16:08,850
have some requirements to enable DMA

00:16:06,540 --> 00:16:12,029
remapping and all all kinds of gas

00:16:08,850 --> 00:16:14,339
kernel protections for DP decay

00:16:12,029 --> 00:16:18,209
applications inside gas or something

00:16:14,339 --> 00:16:20,690
so we just besides the DMA remapping

00:16:18,209 --> 00:16:24,630
part which is protecting the memory

00:16:20,690 --> 00:16:25,560
operations from devices we also need the

00:16:24,630 --> 00:16:28,949
interrupt remapping

00:16:25,560 --> 00:16:31,709
that protects malicious interrupts or

00:16:28,949 --> 00:16:35,790
something so it makes it a complete

00:16:31,709 --> 00:16:37,589
solution so before going deeper to the

00:16:35,790 --> 00:16:39,930
interrupt remapping part I would like to

00:16:37,589 --> 00:16:43,260
introduce something about how the x86

00:16:39,930 --> 00:16:45,569
system interrupts works it's very it's

00:16:43,260 --> 00:16:48,269
very simple graph I think so we can see

00:16:45,569 --> 00:16:50,579
that there are two yellow boxes which is

00:16:48,269 --> 00:16:53,850
line based interrupts and a signal based

00:16:50,579 --> 00:16:56,610
interrupts these two are mostly the two

00:16:53,850 --> 00:16:59,370
kinds of interrupts that we are we are

00:16:56,610 --> 00:17:01,260
having now and also we can see that

00:16:59,370 --> 00:17:04,230
there are two kinds of our code ships

00:17:01,260 --> 00:17:06,390
already first one is Iowa pic which

00:17:04,230 --> 00:17:10,079
handles the line based interrupts

00:17:06,390 --> 00:17:13,319
something like a line based a surgeon or

00:17:10,079 --> 00:17:15,449
something into a interrupts message onto

00:17:13,319 --> 00:17:18,140
the system path and the other one is

00:17:15,449 --> 00:17:20,880
called local API C and mostly we use a

00:17:18,140 --> 00:17:23,839
KVM version which is with be epic

00:17:20,880 --> 00:17:27,329
the epoch which is per processor that

00:17:23,839 --> 00:17:31,730
handles the per processor interrupts all

00:17:27,329 --> 00:17:31,730
kinds of including IP is of course

00:17:32,920 --> 00:17:39,310
so in general interrupter mapping is

00:17:36,550 --> 00:17:43,710
something about oh I'd say interrupts

00:17:39,310 --> 00:17:46,960
remapping poby host is something about

00:17:43,710 --> 00:17:50,110
yeah ah is a is in general protect

00:17:46,960 --> 00:17:52,390
guests from malicious interrupts so when

00:17:50,110 --> 00:17:54,250
this happens if we do not have

00:17:52,390 --> 00:17:56,590
interrupter a mapping if there is

00:17:54,250 --> 00:17:58,960
something for example a device is broken

00:17:56,590 --> 00:18:01,630
or something like that and it just

00:17:58,960 --> 00:18:03,580
triggers interrupts all the time and the

00:18:01,630 --> 00:18:05,710
system will trigger the interrupt

00:18:03,580 --> 00:18:08,620
handler that's not it not a good thing

00:18:05,710 --> 00:18:11,340
and what we want is that we want to know

00:18:08,620 --> 00:18:13,710
what's wrong there and why there is

00:18:11,340 --> 00:18:17,740
strange interrupts happening without

00:18:13,710 --> 00:18:20,440
without any reason so we if we interrupt

00:18:17,740 --> 00:18:24,100
remapping iommu we will do this for you

00:18:20,440 --> 00:18:27,160
so if we have that when we got malicious

00:18:24,100 --> 00:18:29,380
interrupts lmm you will trap it and see

00:18:27,160 --> 00:18:32,950
oh that's something wrong and it will

00:18:29,380 --> 00:18:37,660
have a report which is a interrupt as

00:18:32,950 --> 00:18:39,640
well to the CPU in the gas to notify

00:18:37,660 --> 00:18:41,950
that there is something wrong and who

00:18:39,640 --> 00:18:45,310
did something wrong so to achieve this

00:18:41,950 --> 00:18:48,790
finally we want to support B host so to

00:18:45,310 --> 00:18:51,130
achieve this we need basic remapping

00:18:48,790 --> 00:18:53,770
support in general to for the two kinds

00:18:51,130 --> 00:18:56,830
of interrupts already existing and also

00:18:53,770 --> 00:18:58,180
the be a peak support which is which is

00:18:56,830 --> 00:19:00,130
something that we want to make the

00:18:58,180 --> 00:19:02,850
interrupt faster because for the first

00:19:00,130 --> 00:19:07,300
one we we are talking about emulated

00:19:02,850 --> 00:19:10,320
archetypes mostly so but but we know

00:19:07,300 --> 00:19:13,390
that is very well it's very slow and

00:19:10,320 --> 00:19:15,880
mostly we are using the apex so we need

00:19:13,390 --> 00:19:18,610
to support be epic as the certain second

00:19:15,880 --> 00:19:21,790
step last we need to support we host

00:19:18,610 --> 00:19:26,070
which is the same as to support our qfd

00:19:21,790 --> 00:19:26,070
and I'll talk about it later

00:19:27,250 --> 00:19:34,480
I will take one example of MSI delivery

00:19:31,600 --> 00:19:36,580
in this case before and after interrupt

00:19:34,480 --> 00:19:39,370
your mapping so before that things are

00:19:36,580 --> 00:19:43,179
quite simple I think I think most of

00:19:39,370 --> 00:19:46,750
people people would know that MSI is

00:19:43,179 --> 00:19:48,820
something that is that is that we write

00:19:46,750 --> 00:19:51,490
some specific data the specific address

00:19:48,820 --> 00:19:55,090
write this an memory right and the dress

00:19:51,490 --> 00:19:56,710
would be possibly something like 0x at

00:19:55,090 --> 00:20:00,309
the east or something it's a very

00:19:56,710 --> 00:20:03,400
specific address and also so when we

00:20:00,309 --> 00:20:05,289
deliberate it we just write to a memory

00:20:03,400 --> 00:20:07,840
right actually from the device right

00:20:05,289 --> 00:20:09,850
which is DNA as well and after

00:20:07,840 --> 00:20:12,340
interrupts remapping things become

00:20:09,850 --> 00:20:14,620
slightly different and we have something

00:20:12,340 --> 00:20:17,280
called interrupter mapping table this

00:20:14,620 --> 00:20:20,620
table is stored inside cast memory oh

00:20:17,280 --> 00:20:24,309
I'm taking gas that as an example is

00:20:20,620 --> 00:20:27,070
inside system memory so and when we

00:20:24,309 --> 00:20:30,100
configure the device for MSI or MSI X

00:20:27,070 --> 00:20:33,580
interrupts we fill in something virtual

00:20:30,100 --> 00:20:35,820
is not the original interrupts original

00:20:33,580 --> 00:20:39,010
MSI messages we fill in something

00:20:35,820 --> 00:20:43,360
virtual so I used a orange box instead

00:20:39,010 --> 00:20:46,630
of the green one in this box we hide we

00:20:43,360 --> 00:20:49,900
hide something like a IR te index our

00:20:46,630 --> 00:20:51,940
team is a interrupts remapping table

00:20:49,900 --> 00:20:55,870
entry which is this one with a small box

00:20:51,940 --> 00:20:59,530
we hide an index into that virtual MSI

00:20:55,870 --> 00:21:01,659
message we use this index and to look up

00:20:59,530 --> 00:21:04,809
a specific RT inside the tail bone

00:21:01,659 --> 00:21:07,150
inside caste memory regardless I RT e we

00:21:04,809 --> 00:21:09,549
parse it finally we gather with the

00:21:07,150 --> 00:21:13,840
green one which is the original original

00:21:09,549 --> 00:21:16,500
interrupt that's all that's how

00:21:13,840 --> 00:21:19,990
interrupts remapping is happening and

00:21:16,500 --> 00:21:21,789
when error happens something will have

00:21:19,990 --> 00:21:24,750
something wrong we'll go there for

00:21:21,789 --> 00:21:26,650
example it will fail to find our te

00:21:24,750 --> 00:21:29,350
maybe maybe it's empty

00:21:26,650 --> 00:21:32,740
so error reports and maybe or something

00:21:29,350 --> 00:21:35,289
like device is sending is trying to send

00:21:32,740 --> 00:21:36,809
it interrupt from device B and there is

00:21:35,289 --> 00:21:41,100
something called ice ID verification

00:21:36,809 --> 00:21:41,100
which will notify the gas that

00:21:41,650 --> 00:21:47,440
the a sativa the replication is run so

00:21:44,170 --> 00:21:50,290
so somebody is trying to attend to be

00:21:47,440 --> 00:21:50,950
somebody else anything like that so the

00:21:50,290 --> 00:21:53,170
other cases

00:21:50,950 --> 00:22:01,450
error we would be reported to the to the

00:21:53,170 --> 00:22:04,150
system so previous slide talks about how

00:22:01,450 --> 00:22:06,970
interrupt remapping works and this slide

00:22:04,150 --> 00:22:11,890
talks about how to make it faster so

00:22:06,970 --> 00:22:13,929
which is to support the apex the thing

00:22:11,890 --> 00:22:15,580
is quite simple because we we have

00:22:13,929 --> 00:22:19,720
something called GI side routing table

00:22:15,580 --> 00:22:22,870
in the KVM we have that as a as far as I

00:22:19,720 --> 00:22:25,809
understand as a interrupt cash inside

00:22:22,870 --> 00:22:28,299
kernel so that we can have interrupts

00:22:25,809 --> 00:22:31,690
delivered totally inside kernel without

00:22:28,299 --> 00:22:34,299
trapping into commuter space and this is

00:22:31,690 --> 00:22:36,669
quite good for implement internet we

00:22:34,299 --> 00:22:40,929
interrupt remapping for V I pick because

00:22:36,669 --> 00:22:44,410
I don't need to have another because the

00:22:40,929 --> 00:22:46,570
thing works quite similar here we just

00:22:44,410 --> 00:22:49,390
what we need to do to translate the

00:22:46,570 --> 00:22:51,549
message is just to put a translate

00:22:49,390 --> 00:22:54,160
message into the routing table so that's

00:22:51,549 --> 00:22:57,070
quite simple and the translation is

00:22:54,160 --> 00:22:59,710
slightly different from the email

00:22:57,070 --> 00:23:01,960
related one because for that one we

00:22:59,710 --> 00:23:04,840
translate on the fly for example if

00:23:01,960 --> 00:23:08,650
there is an interrupt is generated we

00:23:04,840 --> 00:23:11,260
translate and we deliver and for the VA

00:23:08,650 --> 00:23:13,990
pick support we if we support this and

00:23:11,260 --> 00:23:16,720
we if we cache the translated result

00:23:13,990 --> 00:23:20,260
into the GI side routing table something

00:23:16,720 --> 00:23:23,470
is quicker because we we set up we do

00:23:20,260 --> 00:23:26,140
the translation beforehand we just we

00:23:23,470 --> 00:23:28,510
just translated it during setup so when

00:23:26,140 --> 00:23:31,480
the interrupt is trigger we do not it to

00:23:28,510 --> 00:23:33,549
translate it at all so it's just as fast

00:23:31,480 --> 00:23:36,549
as before even without interrupting

00:23:33,549 --> 00:23:38,710
mapping so this one is quite easy to

00:23:36,549 --> 00:23:40,809
implement because we do not have to

00:23:38,710 --> 00:23:44,890
touch KB ml after at all we just

00:23:40,809 --> 00:23:49,290
leveraged GI side routing table and so

00:23:44,890 --> 00:23:53,280
we have merely no performance impact and

00:23:49,290 --> 00:23:56,460
we just support split because for

00:23:53,280 --> 00:23:58,970
for the full colonel colonel microchip

00:23:56,460 --> 00:24:02,070
support we cannot support that because

00:23:58,970 --> 00:24:04,140
because in that case I weigh pigs inside

00:24:02,070 --> 00:24:05,430
Colonel as well and we cannot trap it in

00:24:04,140 --> 00:24:08,370
Kumu that's the problem

00:24:05,430 --> 00:24:10,710
but split is quite okay for us because

00:24:08,370 --> 00:24:13,890
for one thing is fast and for the other

00:24:10,710 --> 00:24:16,140
thing is saver as there's a Google

00:24:13,890 --> 00:24:18,150
there's a Google presentation in this or

00:24:16,140 --> 00:24:23,570
in the previous conform talks about it

00:24:18,150 --> 00:24:23,570
so so mostly we are using split here

00:24:24,800 --> 00:24:32,580
this is to one step further to support

00:24:29,010 --> 00:24:35,310
IFD we know that our KFD spaced on GI

00:24:32,580 --> 00:24:37,290
side routing table we set up routing

00:24:35,310 --> 00:24:41,150
table first we set up our QFT and

00:24:37,290 --> 00:24:46,710
everything works so Oh

00:24:41,150 --> 00:24:49,260
so basically Q is responsible to set up

00:24:46,710 --> 00:24:52,680
everything set up the V host back-end

00:24:49,260 --> 00:24:55,020
set up GSI routing table insert every

00:24:52,680 --> 00:24:57,840
MSN messages and the when the interrupt

00:24:55,020 --> 00:25:00,510
comes for example if this is a road I'll

00:24:57,840 --> 00:25:03,030
net PCI when there is some data from the

00:25:00,510 --> 00:25:05,220
tap device or Sunday we just got an

00:25:03,030 --> 00:25:08,730
event which is an interrupt to be host

00:25:05,220 --> 00:25:11,580
we host the triggers gas notifier and it

00:25:08,730 --> 00:25:15,390
will actually fetch specific MSN message

00:25:11,580 --> 00:25:17,580
and injected into guest so that's how we

00:25:15,390 --> 00:25:21,300
host interrupts works in general and

00:25:17,580 --> 00:25:24,000
after that we have already mentioned to

00:25:21,300 --> 00:25:26,520
support a our craft is quite simple

00:25:24,000 --> 00:25:28,590
because we are still leveraging GI side

00:25:26,520 --> 00:25:29,730
routing table here we just translate the

00:25:28,590 --> 00:25:32,550
message beforehand

00:25:29,730 --> 00:25:35,340
so when we set up this we do the

00:25:32,550 --> 00:25:38,790
translation and everything is cool or

00:25:35,340 --> 00:25:41,460
what we need to do is to consider the

00:25:38,790 --> 00:25:44,490
cache invalidation issues because these

00:25:41,460 --> 00:25:48,240
things can be invalidated by the Gast

00:25:44,490 --> 00:25:49,680
IRT can be changed and I didn't have

00:25:48,240 --> 00:25:53,160
slides for this because time is limited

00:25:49,680 --> 00:25:55,920
but we have something for that for the

00:25:53,160 --> 00:25:58,430
American process which is not mentioned

00:25:55,920 --> 00:25:58,430
in this presentation

00:25:59,650 --> 00:26:08,140
okay so I finished I are part this is a

00:26:05,280 --> 00:26:12,460
general performance numbers on what we

00:26:08,140 --> 00:26:16,150
have got is a very first is very amateur

00:26:12,460 --> 00:26:20,140
so firstly firstly this work the whole

00:26:16,150 --> 00:26:23,340
work is for deep DK and the BTK only

00:26:20,140 --> 00:26:27,040
mostly for static DMA mapping DB decay

00:26:23,340 --> 00:26:29,950
trees DMA addresses where especially

00:26:27,040 --> 00:26:32,590
they just a lock huge pages and is that

00:26:29,950 --> 00:26:37,000
they just map it once mostly they just

00:26:32,590 --> 00:26:43,720
do not change it so for TBD k case our

00:26:37,000 --> 00:26:47,200
our work works quite well we get safety

00:26:43,720 --> 00:26:48,280
and we drop 5% performance and it can be

00:26:47,200 --> 00:26:50,470
better in the future

00:26:48,280 --> 00:26:53,260
and Jason should be working on it may be

00:26:50,470 --> 00:26:56,500
a way or some day in the future there

00:26:53,260 --> 00:26:58,540
are some future works and but for

00:26:56,500 --> 00:27:00,640
dynamic the I mean mapping which is the

00:26:58,540 --> 00:27:03,720
default one maybe we just use the

00:27:00,640 --> 00:27:07,360
default default virtual PCI driver and

00:27:03,720 --> 00:27:10,990
all the DMA mappings are managed by the

00:27:07,360 --> 00:27:14,530
kernel in that case is dramatically

00:27:10,990 --> 00:27:16,630
worse is not it's not good you can see

00:27:14,530 --> 00:27:21,940
the number I just I just want mention it

00:27:16,630 --> 00:27:24,190
because it's too poor so so so yes we

00:27:21,940 --> 00:27:27,280
are only for the second one and fourth

00:27:24,190 --> 00:27:29,559
was for first one maybe I don't know who

00:27:27,280 --> 00:27:32,790
will use that is functionally working

00:27:29,559 --> 00:27:32,790
but it it will be very slow

00:27:33,300 --> 00:27:41,170
translators is that most of the patches

00:27:36,280 --> 00:27:44,890
emerged upstream except recent ones Qumu

00:27:41,170 --> 00:27:46,600
IBMers patches in Kumu trees alone will

00:27:44,890 --> 00:27:49,330
be responsible for it and it will

00:27:46,600 --> 00:27:51,809
approach the patch soon and also some ir

00:27:49,330 --> 00:27:54,880
work there are lots of ir issues

00:27:51,809 --> 00:27:59,530
thanks to yankees can lots of people

00:27:54,880 --> 00:28:01,210
that helps in improving this work and so

00:27:59,530 --> 00:28:08,080
there are still lots of works to be done

00:28:01,210 --> 00:28:09,809
and so this is so about yeah that's all

00:28:08,080 --> 00:28:15,179
mostly that's all

00:28:09,809 --> 00:28:17,609
oh thank you so do you have any comments

00:28:15,179 --> 00:28:21,479
or questions regarding to our where is

00:28:17,609 --> 00:28:27,629
why wait yeah do you have any questions

00:28:21,479 --> 00:28:30,809
or comments you validated a virtual I am

00:28:27,629 --> 00:28:37,229
a new both with great i/o devices and

00:28:30,809 --> 00:28:40,349
postural devices in the same way just if

00:28:37,229 --> 00:28:42,629
you validated the virtual arena new both

00:28:40,349 --> 00:28:49,019
with VPN pass-through devices in the

00:28:42,629 --> 00:28:54,690
same guest Oh what we have verified is a

00:28:49,019 --> 00:28:58,259
current rate to tip TK and MFA normally

00:28:54,690 --> 00:29:00,599
under user the you IO driver with the

00:28:58,259 --> 00:29:03,269
widget feature now we can use the VF

00:29:00,599 --> 00:29:05,129
I'll pass through in low caste so what

00:29:03,269 --> 00:29:08,749
we are test is running the dippity k

00:29:05,129 --> 00:29:37,649
directly in the caste system and then

00:29:08,749 --> 00:29:39,210
for nest nest it's hot so it's do you

00:29:37,649 --> 00:29:41,369
actually support multiple request ID

00:29:39,210 --> 00:29:44,549
mean I don't know how the details

00:29:41,369 --> 00:29:47,519
implementation right how do you I'm late

00:29:44,549 --> 00:29:49,950
all simulators or the Rio BDD pay tables

00:29:47,519 --> 00:29:55,679
you have no power covered all because

00:29:49,950 --> 00:29:58,799
this case is one device yes mmm

00:29:55,679 --> 00:30:02,399
actually uh the page tables here are we

00:29:58,799 --> 00:30:07,909
only used the Linda's kernel DMA API in

00:30:02,399 --> 00:30:07,909
the in the custard travel kernel inside

00:30:08,500 --> 00:30:12,600
another thing so when you said you

00:30:10,480 --> 00:30:15,070
mentioned you implement ideas right so

00:30:12,600 --> 00:30:17,710
for the invitation part do you think

00:30:15,070 --> 00:30:19,990
having an ATS it will be do consider

00:30:17,710 --> 00:30:22,270
having ETS as a security problem because

00:30:19,990 --> 00:30:25,480
when you have a TSA device telling how

00:30:22,270 --> 00:30:29,200
to go through the i/o new translation to

00:30:25,480 --> 00:30:39,790
his IO TLB yeah sure actually we can say

00:30:29,200 --> 00:30:45,280
from this figure Soria okay so this

00:30:39,790 --> 00:30:50,590
figure did here mmm it's from here sorry

00:30:45,280 --> 00:30:55,000
here well wish you'd learned it all the

00:30:50,590 --> 00:30:57,370
and just ranch before we translated

00:30:55,000 --> 00:31:07,450
further they host Colonel so I think

00:30:57,370 --> 00:31:08,470
it's sipping the promise it kinda was

00:31:07,450 --> 00:31:10,480
right

00:31:08,470 --> 00:31:12,460
is that because you with ATS you have

00:31:10,480 --> 00:31:21,780
invited all the way down to the device

00:31:12,460 --> 00:31:21,780
oh sure that's true so every I'm sorry

00:31:22,919 --> 00:31:24,980

YouTube URL: https://www.youtube.com/watch?v=Zzb_N7TTh_8


