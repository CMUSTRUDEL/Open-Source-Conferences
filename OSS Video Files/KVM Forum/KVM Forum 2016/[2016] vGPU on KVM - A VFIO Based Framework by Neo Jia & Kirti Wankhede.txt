Title: [2016] vGPU on KVM - A VFIO Based Framework by Neo Jia & Kirti Wankhede
Publication date: 2016-09-02
Playlist: KVM Forum 2016
Description: 
	GPU virtualization becomes more and more important these days since its first public debut in 2013. To bring vGPU solutions of different GPU vendors onto KVM/QEMU platform, while maintaining a highly unified kernel and user space interface, a VFIO based vGPU framework is introduced in this presentation. In this talk, we will review the GPU vendor driver registration interface, the vGPU bus, vGPU core driver, VGPU TYPE1 IOMMU internals, walk through vGPU enabled VM life cycle, introduce the kernel and user space sysfs and the framebuffer interface for QEMU console VNC, discuss roadmap for future vGPU VFIO framework performance/scalability optimization.

Neo Jia
Chief Software Architect, NVIDIA Corporation

Neo Jia works on GPU virtualization for NVIDIA Corporation. As a Chief Software Architect and a founding member of GPU virtualization team, he has been actively bringing NVIDIA GPU virtualization technology to different platforms. Nowdays, he is working on vGPU VFIO framework with Linux/KVM community.

Kirti Wankhede
NVIDIA Corporation

Slides: http://www.linux-kvm.org/images/5/59/02x03-Neo_Jia_and_Kirti_Wankhede-vGPU_on_KVM-A_VFIO_based_Framework.pdf
Captions: 
	00:00:09,200 --> 00:00:15,839
okay thank you Oh welcome to the our

00:00:12,690 --> 00:00:20,699
talk so today we are going to present

00:00:15,839 --> 00:00:26,369
the vgpu on KVM as we serve EFI outpaced

00:00:20,699 --> 00:00:28,590
media here device framework so so this

00:00:26,369 --> 00:00:30,029
our agenda today we are going to cover

00:00:28,590 --> 00:00:32,009
the first row to talk about the

00:00:30,029 --> 00:00:34,579
background of this work and the motor

00:00:32,009 --> 00:00:36,719
motivation why we are doing this and we

00:00:34,579 --> 00:00:40,559
talked about the overview of this

00:00:36,719 --> 00:00:42,840
framework and then we are we tap into

00:00:40,559 --> 00:00:46,620
some key areas I think people might be

00:00:42,840 --> 00:00:48,450
interested in and then Mike or kurti is

00:00:46,620 --> 00:00:51,030
going to take over the stage talk about

00:00:48,450 --> 00:00:54,660
the current status about the patches and

00:00:51,030 --> 00:01:00,030
also we do a quick demo here and then

00:00:54,660 --> 00:01:03,329
talk about the future work so let's take

00:01:00,030 --> 00:01:05,729
a look at what today's GPU inside the

00:01:03,329 --> 00:01:08,010
kami and virtual machines so obviously

00:01:05,729 --> 00:01:09,750
yeah we are using the VF IO device pass

00:01:08,010 --> 00:01:12,030
roof I have the reference about

00:01:09,750 --> 00:01:15,659
yesterday Eric stocks you can see the

00:01:12,030 --> 00:01:17,189
details there so with this framework yes

00:01:15,659 --> 00:01:18,750
you get a great performance

00:01:17,189 --> 00:01:20,759
right so the GPO is a director assigned

00:01:18,750 --> 00:01:24,689
to the virtual machines you complete on

00:01:20,759 --> 00:01:25,830
the GPU and also you get a food API

00:01:24,689 --> 00:01:27,330
credibility

00:01:25,830 --> 00:01:29,130
so basically me because you have a

00:01:27,330 --> 00:01:31,320
completely you have a wonder driver

00:01:29,130 --> 00:01:33,689
running inside a virtual machine which

00:01:31,320 --> 00:01:35,340
means the application you used to run on

00:01:33,689 --> 00:01:37,650
bare metal should just run here without

00:01:35,340 --> 00:01:40,530
any modification so those are all good

00:01:37,650 --> 00:01:42,630
things but there are several several

00:01:40,530 --> 00:01:45,060
issues victory framework or limitations

00:01:42,630 --> 00:01:47,549
the first one is you complete a limited

00:01:45,060 --> 00:01:49,979
by the PCIe resource because depends on

00:01:47,549 --> 00:01:52,729
how many PCIe slots you have that's how

00:01:49,979 --> 00:01:56,460
many virtual machine you can run and

00:01:52,729 --> 00:01:59,280
then another problem is because we are

00:01:56,460 --> 00:02:02,579
allowed to keep gpo do you actually

00:01:59,280 --> 00:02:04,829
utilized by the cache driver because by

00:02:02,579 --> 00:02:06,570
the castle virtual machine from the host

00:02:04,829 --> 00:02:09,509
point of view we don't know anything

00:02:06,570 --> 00:02:11,550
about this device and this is because we

00:02:09,509 --> 00:02:13,420
are running a generic OVF our psi driver

00:02:11,550 --> 00:02:14,770
so subpoena

00:02:13,420 --> 00:02:18,099
driver can only do some generic

00:02:14,770 --> 00:02:19,959
operations like enable disabled or

00:02:18,099 --> 00:02:24,550
interrupts and etc and the recited

00:02:19,959 --> 00:02:27,220
device right secondary bus or flr so

00:02:24,550 --> 00:02:28,930
that's all you don't have much

00:02:27,220 --> 00:02:30,190
visibility what's going on inside the

00:02:28,930 --> 00:02:33,370
virtual machine you don't know about the

00:02:30,190 --> 00:02:35,290
usage right another most important thing

00:02:33,370 --> 00:02:38,260
so for the GP from the GP point of view

00:02:35,290 --> 00:02:40,989
is it's very very difficult to cover the

00:02:38,260 --> 00:02:44,530
variety of workload for example if you

00:02:40,989 --> 00:02:46,209
have a high-end the GPU here when you

00:02:44,530 --> 00:02:48,000
have when you run low and the graphics

00:02:46,209 --> 00:02:51,069
workload it's your GPO is kind of

00:02:48,000 --> 00:02:53,950
underutilized but you can also solve

00:02:51,069 --> 00:02:56,950
that problem by stick a bunch of a small

00:02:53,950 --> 00:02:57,459
GPU here but those small GPU is very too

00:02:56,950 --> 00:02:59,830
small

00:02:57,459 --> 00:03:03,519
they cannot drive they cannot serve the

00:02:59,830 --> 00:03:05,230
big 3d workload individually as we said

00:03:03,519 --> 00:03:07,959
because it's a directed sign right it

00:03:05,230 --> 00:03:10,239
has to work on their own so now we have

00:03:07,959 --> 00:03:13,090
two problems one is the visibility of

00:03:10,239 --> 00:03:15,220
this to manage this resource and also we

00:03:13,090 --> 00:03:18,930
want to have a biter sharing to cover a

00:03:15,220 --> 00:03:23,579
wide range of workload so let's look at

00:03:18,930 --> 00:03:23,579
the vgp solution

00:03:36,319 --> 00:03:42,319
yeah so this is a high-level view of the

00:03:39,260 --> 00:03:43,939
vgpu solution so basically we share we

00:03:42,319 --> 00:03:45,439
provide the share the physical PPO

00:03:43,939 --> 00:03:48,019
amount of multiple virtual machines and

00:03:45,439 --> 00:03:50,180
it has great performance and also

00:03:48,019 --> 00:03:51,709
suitable for different workload right so

00:03:50,180 --> 00:03:54,260
the way you achieve the greater

00:03:51,709 --> 00:03:56,090
performance is a wheel we have the de

00:03:54,260 --> 00:03:58,250
Vaca communication path from the

00:03:56,090 --> 00:04:00,859
application or from the you can say from

00:03:58,250 --> 00:04:04,220
the drivers inside the glass to your

00:04:00,859 --> 00:04:07,189
Kate to the GPU itself I will cover this

00:04:04,220 --> 00:04:09,409
part later in the in a talk and also we

00:04:07,189 --> 00:04:10,609
provide a free API capability because we

00:04:09,409 --> 00:04:12,680
have a wonder drug money especially

00:04:10,609 --> 00:04:15,680
drivers inside the virtual machine so if

00:04:12,680 --> 00:04:19,489
you rely on some OpenGL recensions

00:04:15,680 --> 00:04:21,560
vendors intentions it's all there and

00:04:19,489 --> 00:04:23,509
also we have the we have we have better

00:04:21,560 --> 00:04:26,060
visibility in on the host so basically

00:04:23,509 --> 00:04:28,400
because this event is a vendor specific

00:04:26,060 --> 00:04:31,360
driver devices that somatic driver you

00:04:28,400 --> 00:04:33,979
actually can provide a much more device

00:04:31,360 --> 00:04:36,380
centric information like dynamic

00:04:33,979 --> 00:04:37,940
monitoring on performance tuning and or

00:04:36,380 --> 00:04:39,560
even all error reporting right you

00:04:37,940 --> 00:04:41,169
hadn't even know what is going on what

00:04:39,560 --> 00:04:45,740
is what kind of errors is going on

00:04:41,169 --> 00:04:47,960
inside the virtual machine so at the end

00:04:45,740 --> 00:04:49,789
of the day we are talking about GPU as

00:04:47,960 --> 00:04:51,199
actually it's the i/o device right so

00:04:49,789 --> 00:04:55,690
what we are doing here is we are trying

00:04:51,199 --> 00:04:59,300
to virtualize an i/o device so here is

00:04:55,690 --> 00:05:01,760
the i/o virtualization status today so

00:04:59,300 --> 00:05:04,550
we have srl we device and which was

00:05:01,760 --> 00:05:07,849
supported by the standard via file PCI

00:05:04,550 --> 00:05:09,680
but with your periodic assignment the UT

00:05:07,849 --> 00:05:13,520
records and also virtual functions into

00:05:09,680 --> 00:05:16,370
the virtual machines so this this vfi

00:05:13,520 --> 00:05:18,729
OPC I think yesterday Alex article is so

00:05:16,370 --> 00:05:22,550
you have art you have an established

00:05:18,729 --> 00:05:25,389
QEMU piece.i driver and it's a KVM the

00:05:22,550 --> 00:05:29,330
gnostic so as long as you are using the

00:05:25,389 --> 00:05:32,720
center user API is you can use the VFL

00:05:29,330 --> 00:05:34,789
framework and it's already provided to

00:05:32,720 --> 00:05:38,030
virtualize the p-side convict space and

00:05:34,789 --> 00:05:41,680
also Marilyn for iOS ways and between

00:05:38,030 --> 00:05:43,210
the interrupt delivery and also it has

00:05:41,680 --> 00:05:46,460
motorized

00:05:43,210 --> 00:05:48,349
iommu back end so you can do pin and

00:05:46,460 --> 00:05:50,979
marriage for the Emer purpose that's

00:05:48,349 --> 00:05:54,039
that's very important of

00:05:50,979 --> 00:05:57,649
for the DMA devices for the i/o devices

00:05:54,039 --> 00:06:00,049
so what we are doing here is so we have

00:05:57,649 --> 00:06:03,229
immediately media key devices which is a

00:06:00,049 --> 00:06:05,329
non SRV device and though it's required

00:06:03,229 --> 00:06:07,429
under specific driver to mediators of

00:06:05,329 --> 00:06:10,519
sharing so you wonder this vendor

00:06:07,429 --> 00:06:13,429
drivers job to to help to share to

00:06:10,519 --> 00:06:16,519
virtualize the device right so it's a

00:06:13,429 --> 00:06:18,860
framework of one framework what we are

00:06:16,519 --> 00:06:21,529
building here is soviet laboratories VFL

00:06:18,860 --> 00:06:23,239
framework so we basically we use the

00:06:21,529 --> 00:06:24,919
existing user API we maintain that

00:06:23,239 --> 00:06:28,279
existing user it yes so there's no

00:06:24,919 --> 00:06:29,809
changes online on that and also we rely

00:06:28,279 --> 00:06:31,819
on the vendor driver to manage their

00:06:29,809 --> 00:06:37,719
device internal our resources to do the

00:06:31,819 --> 00:06:40,249
sharing right so here's the framework

00:06:37,719 --> 00:06:43,339
yep we are proposing and we are working

00:06:40,249 --> 00:06:45,589
on so this is a common framework for

00:06:43,339 --> 00:06:47,289
media et IO device right well any i/o

00:06:45,589 --> 00:06:50,179
device in which you are trying to do

00:06:47,289 --> 00:06:53,239
moisturization without SRO we think that

00:06:50,179 --> 00:06:56,149
should apply to this framework we have a

00:06:53,239 --> 00:06:58,459
three or three changes to new modules

00:06:56,149 --> 00:07:01,459
and no one you can say enhancement or

00:06:58,459 --> 00:07:04,659
modification on existing code so the

00:07:01,459 --> 00:07:08,300
first one is we have a new media module

00:07:04,659 --> 00:07:09,919
we have that basically it's a media

00:07:08,300 --> 00:07:12,050
provide immediate bus driver

00:07:09,919 --> 00:07:15,110
it'll create as a media a delay device

00:07:12,050 --> 00:07:18,379
and also is provided it's an interface

00:07:15,110 --> 00:07:19,789
for the bundle drivers callback because

00:07:18,379 --> 00:07:23,629
we need the vendor prefix kha' guys to

00:07:19,789 --> 00:07:26,269
provide our sharings and also we provide

00:07:23,629 --> 00:07:27,879
we provided we provided generic

00:07:26,269 --> 00:07:31,269
immediate device management interfaces

00:07:27,879 --> 00:07:34,129
vsfs that's the interface we want to

00:07:31,269 --> 00:07:35,989
provide to the user space and if you

00:07:34,129 --> 00:07:39,429
want to build on any abstraction layer

00:07:35,989 --> 00:07:42,589
on top of that that's what we want to do

00:07:39,429 --> 00:07:45,199
then we have a mediated device module

00:07:42,589 --> 00:07:48,979
which is a common module is not limited

00:07:45,199 --> 00:07:51,469
to PCI device anymore and also we this

00:07:48,979 --> 00:07:53,449
is basically a driver to is a driver for

00:07:51,469 --> 00:07:56,179
the previous created previously we

00:07:53,449 --> 00:07:58,129
create media ad the device and it's also

00:07:56,179 --> 00:08:02,899
fully compatible with the VF i/o user

00:07:58,129 --> 00:08:03,650
API the last thing is the VF IMU driver

00:08:02,899 --> 00:08:05,690
is

00:08:03,650 --> 00:08:08,060
your husband so basically means we don't

00:08:05,690 --> 00:08:10,160
change anything of that user API we just

00:08:08,060 --> 00:08:13,100
added two new kernel in the eyes to

00:08:10,160 --> 00:08:17,150
allowed a vendor driver to do a pin and

00:08:13,100 --> 00:08:19,789
empty memories and also list because

00:08:17,150 --> 00:08:22,550
because of loud because lad you can

00:08:19,789 --> 00:08:27,710
easily extend it to Nong type one by

00:08:22,550 --> 00:08:31,460
again so this is the diagram I'm going

00:08:27,710 --> 00:08:33,169
to keep using a through my talk so you

00:08:31,460 --> 00:08:34,880
can see there's a green box it's all the

00:08:33,169 --> 00:08:38,120
of the new other new modules so we are

00:08:34,880 --> 00:08:41,419
adding here and actually there will be a

00:08:38,120 --> 00:08:44,080
one small box here just to this to the

00:08:41,419 --> 00:08:47,510
new API is the new kernel api's we add

00:08:44,080 --> 00:08:51,470
but Oh add a lot in the following slides

00:08:47,510 --> 00:08:53,870
you can see that and the one one key

00:08:51,470 --> 00:08:56,570
takeaway here is I think you can see

00:08:53,870 --> 00:08:59,990
there's no modification here between the

00:08:56,570 --> 00:09:02,810
FIO user API and the type one IMU AVI

00:08:59,990 --> 00:09:05,120
so basically means you can run vanilla

00:09:02,810 --> 00:09:07,520
version of QEMU and later we are going

00:09:05,120 --> 00:09:09,350
to do that with a quick demo it's it's

00:09:07,520 --> 00:09:12,800
demo with vanilla

00:09:09,350 --> 00:09:17,180
I think a qemu 2.7 are released

00:09:12,800 --> 00:09:20,959
candidated - so we are using that so

00:09:17,180 --> 00:09:22,190
this is the framework so let's look at

00:09:20,959 --> 00:09:27,800
how the framework actually get

00:09:22,190 --> 00:09:30,350
initialized so the first thing is you do

00:09:27,800 --> 00:09:32,630
is you read it register the VF IOM dev

00:09:30,350 --> 00:09:39,020
as a driver as a driver for the mediated

00:09:32,630 --> 00:09:40,700
device later and then is went up to the

00:09:39,020 --> 00:09:42,800
vendor driver to register his device

00:09:40,700 --> 00:09:45,410
which he want to use for virtualization

00:09:42,800 --> 00:09:47,750
for to create a mediator device later

00:09:45,410 --> 00:09:53,750
right so it's a wonder driver to

00:09:47,750 --> 00:09:55,160
register through this interface and then

00:09:53,750 --> 00:09:56,270
when the driver will register the

00:09:55,160 --> 00:09:59,480
mediator callback

00:09:56,270 --> 00:10:02,120
I as I said before we rely on the vendor

00:09:59,480 --> 00:10:03,529
driver to provide the IO sharings so

00:10:02,120 --> 00:10:06,560
there will be several callbacks

00:10:03,529 --> 00:10:11,000
we need to register to for the vendor

00:10:06,560 --> 00:10:12,920
drivers here so now we are about to

00:10:11,000 --> 00:10:16,160
create a virtual virtual device or

00:10:12,920 --> 00:10:17,420
mediated device as I said we really

00:10:16,160 --> 00:10:19,879
provides the city

00:10:17,420 --> 00:10:22,009
as a generic interface for user to match

00:10:19,879 --> 00:10:24,589
or if you manage the life cycles of

00:10:22,009 --> 00:10:28,959
those virtual device so let's take a

00:10:24,589 --> 00:10:31,579
quick look of what those CFS looks like

00:10:28,959 --> 00:10:34,369
so here it's the immediatly device

00:10:31,579 --> 00:10:37,309
itself s so after when the driver read

00:10:34,369 --> 00:10:38,899
finish the registration you can see

00:10:37,309 --> 00:10:42,079
under the under the physical device

00:10:38,899 --> 00:10:46,220
itself as we add as we had a several new

00:10:42,079 --> 00:10:50,449
of sisyphus file which is I'm def crate

00:10:46,220 --> 00:10:52,069
with its own aka media device created

00:10:50,449 --> 00:10:54,889
virtual device and then you can destroy

00:10:52,069 --> 00:10:57,350
that virtual device and then and have

00:10:54,889 --> 00:11:00,439
support types under you can suppose you

00:10:57,350 --> 00:11:02,569
will basically tell you what kind of me

00:11:00,439 --> 00:11:03,980
dat device type is supported by lacy

00:11:02,569 --> 00:11:06,799
physical device and what kind of

00:11:03,980 --> 00:11:09,709
contribution you can create for this

00:11:06,799 --> 00:11:11,600
device powerful now and then once you

00:11:09,709 --> 00:11:14,720
create a virtual device then you will

00:11:11,600 --> 00:11:19,040
have the CFL's pass as to represent a

00:11:14,720 --> 00:11:21,350
lot of virtual device and then we added

00:11:19,040 --> 00:11:23,149
this online on you can just similar to

00:11:21,350 --> 00:11:24,980
the CPU online offline operation so you

00:11:23,149 --> 00:11:30,199
can do a start and stop the ritual

00:11:24,980 --> 00:11:31,029
device so now let's let's go back to the

00:11:30,199 --> 00:11:34,579
slides

00:11:31,029 --> 00:11:36,889
so now user can write the MDF CSFs to

00:11:34,579 --> 00:11:41,329
create an dev device then you create

00:11:36,889 --> 00:11:45,819
your echo tool like I'm W UID this UID

00:11:41,329 --> 00:11:45,819
has to be unique at least or per system

00:11:46,779 --> 00:11:51,829
then once you create a device then you

00:11:49,519 --> 00:11:54,739
have listed the device and we have I

00:11:51,829 --> 00:11:57,110
just mentioned in previous slide then

00:11:54,739 --> 00:11:59,629
the analysis the past this is a first

00:11:57,110 --> 00:12:05,540
pass you put your path to the Quyen you

00:11:59,629 --> 00:12:07,610
as the vfo device arguments then the qm

00:12:05,540 --> 00:12:10,399
you will call the via file API and to

00:12:07,610 --> 00:12:13,369
add the vehicle is at vfo device to this

00:12:10,399 --> 00:12:14,779
iommu container and the group etc and

00:12:13,369 --> 00:12:18,169
then eventually we will cut out your

00:12:14,779 --> 00:12:20,239
cause I also say CAD a via ferrata best

00:12:18,169 --> 00:12:23,559
felt without descriptor right so now you

00:12:20,239 --> 00:12:23,559
gather the faulty scooter back

00:12:25,499 --> 00:12:30,040
then once you have less about this

00:12:28,209 --> 00:12:31,809
criminal back learning you the cue is

00:12:30,040 --> 00:12:33,699
qem the job to access a large file

00:12:31,809 --> 00:12:36,699
descriptor and the present it into the

00:12:33,699 --> 00:12:38,860
virtual machine by by doing the PC

00:12:36,699 --> 00:12:43,439
config space access and also checking

00:12:38,860 --> 00:12:46,629
the bar until memory Mac iOS does right

00:12:43,439 --> 00:12:51,579
so let's talk about the holder access to

00:12:46,629 --> 00:12:53,170
device so this is a mediator you said a

00:12:51,579 --> 00:12:57,430
how to access devices the first thing is

00:12:53,170 --> 00:12:59,410
I want to mention is I'm related so we

00:12:57,430 --> 00:13:00,639
do because the folder to makers of under

00:12:59,410 --> 00:13:02,920
drivers a lot easier right we

00:13:00,639 --> 00:13:04,149
represented the virtual for the virtual

00:13:02,920 --> 00:13:05,889
device memory region to be still

00:13:04,149 --> 00:13:09,279
presented inside a virtual machine just

00:13:05,889 --> 00:13:11,470
to keep a condition wheel right so now

00:13:09,279 --> 00:13:13,329
most time you don't have to have much

00:13:11,470 --> 00:13:15,240
modifications inside for your vendor

00:13:13,329 --> 00:13:17,649
driver running inside a guest

00:13:15,240 --> 00:13:20,499
another important another thing is so I

00:13:17,649 --> 00:13:22,689
have this is emulated versus possible so

00:13:20,499 --> 00:13:24,639
this is not not this is not something we

00:13:22,689 --> 00:13:26,470
have added here it's already this

00:13:24,639 --> 00:13:29,920
provided is it with existing VF i/o

00:13:26,470 --> 00:13:32,230
interface for when when you write will

00:13:29,920 --> 00:13:34,720
declare your region or memory mapped i/o

00:13:32,230 --> 00:13:36,459
region if you don't have a don't set any

00:13:34,720 --> 00:13:39,220
special flag and you will get an

00:13:36,459 --> 00:13:42,189
emulated the type if you set as I'm map

00:13:39,220 --> 00:13:43,899
you get at the but we can't alcohol this

00:13:42,189 --> 00:13:46,600
pass route basically you just directly

00:13:43,899 --> 00:13:48,910
map a lot of large device memory to the

00:13:46,600 --> 00:13:51,339
cat to the guest which where you want

00:13:48,910 --> 00:13:54,100
right so that it can let her give you

00:13:51,339 --> 00:13:56,259
the best performance because so whenever

00:13:54,100 --> 00:13:58,449
the of another whenever the application

00:13:56,259 --> 00:14:00,850
or the cache driver trying to talk to

00:13:58,449 --> 00:14:02,860
the memory mile region instead of gas

00:14:00,850 --> 00:14:05,079
actually he started talking to the

00:14:02,860 --> 00:14:10,569
virtual to the hardware there's no BM

00:14:05,079 --> 00:14:13,029
exit so so the ad so it's access to the

00:14:10,569 --> 00:14:16,240
emulated region will will be routed to

00:14:13,029 --> 00:14:18,429
the mediated driver on the host for the

00:14:16,240 --> 00:14:19,600
pass-through region you will sign it

00:14:18,429 --> 00:14:21,100
you're signed into the device

00:14:19,600 --> 00:14:23,559
corresponding rated right this is

00:14:21,100 --> 00:14:26,470
completely in this framework we don't

00:14:23,559 --> 00:14:30,819
put any restriction so it's completely

00:14:26,470 --> 00:14:33,129
up to the vendor driver to twist to

00:14:30,819 --> 00:14:35,379
implement this or all you can say or we

00:14:33,129 --> 00:14:37,699
prefer to do the M map at the beginning

00:14:35,379 --> 00:14:42,369
or we'd prefer to do research that I am

00:14:37,699 --> 00:14:42,369
in a runtime so it's completely flexible

00:14:44,529 --> 00:14:52,609
so this is the how the access works and

00:14:49,910 --> 00:14:55,850
so a person like um you look at a region

00:14:52,609 --> 00:14:58,609
info we are the via file user api's so

00:14:55,850 --> 00:15:00,350
then that region info go eventually

00:14:58,609 --> 00:15:02,869
provided by the vendor driver basically

00:15:00,350 --> 00:15:05,869
run the driver to tell him hey I have

00:15:02,869 --> 00:15:07,609
this this this regions will be I'm

00:15:05,869 --> 00:15:13,939
latina like a normal no more like a

00:15:07,609 --> 00:15:16,339
party or registers will be emanated and

00:15:13,939 --> 00:15:18,980
then the follow van driver when the when

00:15:16,339 --> 00:15:22,160
a driver access the Merrimac io area of

00:15:18,980 --> 00:15:27,559
this device which will trap into the

00:15:22,160 --> 00:15:30,199
trigger EPA violation try to be here and

00:15:27,559 --> 00:15:31,879
then the window key am service apt

00:15:30,199 --> 00:15:38,899
violation and then forward to the QM

00:15:31,879 --> 00:15:41,119
UEFI we have our driver then the qemu of

00:15:38,899 --> 00:15:43,869
your convert such a request from the KVM

00:15:41,119 --> 00:15:47,179
to readwrite access to to Lisa and

00:15:43,869 --> 00:15:49,459
Delphi descriptor this there's nothing

00:15:47,179 --> 00:15:56,989
new here is just miss it reused to the

00:15:49,459 --> 00:15:58,609
code we have for the cosine and then the

00:15:56,989 --> 00:16:02,119
reader writer will by the vendor driver

00:15:58,609 --> 00:16:05,299
then we'll go back to the vendor driver

00:16:02,119 --> 00:16:09,829
so from the gas now you go back to the

00:16:05,299 --> 00:16:11,689
Baniya driver on host so this is the the

00:16:09,829 --> 00:16:13,730
distance device access the pass is

00:16:11,689 --> 00:16:15,919
normally forward for you to count to

00:16:13,730 --> 00:16:17,600
configure the device to set up the set

00:16:15,919 --> 00:16:19,220
up device the initialization right so

00:16:17,600 --> 00:16:22,699
once you set up this then you are ready

00:16:19,220 --> 00:16:24,769
to launch the DMA operation let's take a

00:16:22,699 --> 00:16:26,959
look at how the DMA operation works in

00:16:24,769 --> 00:16:28,669
this mediated device framework because

00:16:26,959 --> 00:16:30,679
when one important thing is we are not

00:16:28,669 --> 00:16:34,009
eyes are we so bi only have single

00:16:30,679 --> 00:16:36,019
request ID so it's up to the is reliance

00:16:34,009 --> 00:16:40,549
the wonder driver on the host to set up

00:16:36,019 --> 00:16:42,859
the right mappings so the queuing starts

00:16:40,549 --> 00:16:44,480
this is the so first things that we have

00:16:42,859 --> 00:16:45,739
to the memory Tracking's we want to know

00:16:44,480 --> 00:16:47,629
we're on the tracks of the memories

00:16:45,739 --> 00:16:49,879
inside the guest right so there's no

00:16:47,629 --> 00:16:50,709
there's no static mapping so we don't we

00:16:49,879 --> 00:16:53,089
don't have to

00:16:50,709 --> 00:16:56,269
set out with a one-to-one mappings as we

00:16:53,089 --> 00:17:01,279
do on the right like a regular normal

00:16:56,269 --> 00:17:03,529
pass route right so so memory region

00:17:01,279 --> 00:17:05,240
will get added up by the QEMU right so

00:17:03,529 --> 00:17:07,309
when the gas memory gets in your eyes

00:17:05,240 --> 00:17:12,290
and you have the glass frame numbers you

00:17:07,309 --> 00:17:15,650
get into the Q&A will be a space and

00:17:12,290 --> 00:17:18,140
then qmu will call the v fidme map API

00:17:15,650 --> 00:17:20,360
via the memory listener so the all the

00:17:18,140 --> 00:17:22,400
memories will add it and when one

00:17:20,360 --> 00:17:25,040
interesting part of funny I want to make

00:17:22,400 --> 00:17:27,980
is it's not just a class of physical

00:17:25,040 --> 00:17:30,260
memory it's also it's also a device

00:17:27,980 --> 00:17:33,169
memory will also be added into a Surya

00:17:30,260 --> 00:17:39,770
Sumerian listener but we're not going to

00:17:33,169 --> 00:17:41,630
abuse that information so so now we call

00:17:39,770 --> 00:17:43,360
um you'll call this a via file with the

00:17:41,630 --> 00:17:48,260
mmm but there's nothing kind of map

00:17:43,360 --> 00:17:50,179
physically then we just build a pivot

00:17:48,260 --> 00:17:52,220
table here we just basically say hey

00:17:50,179 --> 00:17:54,230
list the VA and we track it on the Mac

00:17:52,220 --> 00:18:00,230
in relation between the tech um you'll

00:17:54,230 --> 00:18:02,510
be a to a class frame number and then in

00:18:00,230 --> 00:18:04,549
a runtime when the vendor drivers say oh

00:18:02,510 --> 00:18:07,669
I'm going to do the DMA toward the third

00:18:04,549 --> 00:18:10,730
especially a class physical memory he

00:18:07,669 --> 00:18:13,610
need he need to call this new API to the

00:18:10,730 --> 00:18:16,160
type one IMU say I want I want to pin

00:18:13,610 --> 00:18:18,470
some specific Akash frame number so what

00:18:16,160 --> 00:18:19,340
is can you help me to pin that memory on

00:18:18,470 --> 00:18:22,340
the translated back

00:18:19,340 --> 00:18:25,910
so let's code or we'll find a lot of

00:18:22,340 --> 00:18:28,309
castrum number and an appeal data memory

00:18:25,910 --> 00:18:30,140
and also his first recirc added letter P

00:18:28,309 --> 00:18:32,929
Evan and then

00:18:30,140 --> 00:18:34,880
son like memory back so now that get

00:18:32,929 --> 00:18:37,130
another the window driver knows was the

00:18:34,880 --> 00:18:42,770
P Evan he's he need to pin or he need to

00:18:37,130 --> 00:18:44,179
map to it's already pin here then the

00:18:42,770 --> 00:18:46,490
wonder drug is then the wonder driver

00:18:44,179 --> 00:18:48,740
will call the piece a PCM map as tree to

00:18:46,490 --> 00:18:52,880
a to map to P happen to be F in right so

00:18:48,740 --> 00:18:55,220
another program DMA so so the PCI map as

00:18:52,880 --> 00:18:57,530
G so we'll handle automatically for us

00:18:55,220 --> 00:19:03,110
is a ways enemies order it's a physical

00:18:57,530 --> 00:19:05,630
om you here so you then do

00:19:03,110 --> 00:19:10,880
than the than the address of you put it

00:19:05,630 --> 00:19:13,159
on a path will be it's cracked right so

00:19:10,880 --> 00:19:14,600
window when the DMA is set up then the

00:19:13,159 --> 00:19:16,340
next thing is the device is going to

00:19:14,600 --> 00:19:19,130
launch the DMA and the device is going

00:19:16,340 --> 00:19:23,149
to notify hey I'm done right so that is

00:19:19,130 --> 00:19:29,870
that is through the interim so this next

00:19:23,149 --> 00:19:31,789
topic about interrupts so still we go

00:19:29,870 --> 00:19:34,519
back to the initialization time the qemu

00:19:31,789 --> 00:19:37,220
of your check was to ask her for the

00:19:34,519 --> 00:19:38,990
interrupts setup so cameo ask the

00:19:37,220 --> 00:19:41,659
felicity carry this device supported

00:19:38,990 --> 00:19:43,850
interrupts I'd like in the index or MSI

00:19:41,659 --> 00:19:45,580
or MSI acts like how many message you

00:19:43,850 --> 00:19:48,080
support or how many vectors you need

00:19:45,580 --> 00:19:54,919
exact words and this will be provided by

00:19:48,080 --> 00:19:57,830
the window driver then the qemu as I

00:19:54,919 --> 00:19:59,630
think this this alex or talk about this

00:19:57,830 --> 00:20:03,289
include the details yesterday so then

00:19:59,630 --> 00:20:05,480
cumulus setup so i RQ f dr k vm r k ft

00:20:03,289 --> 00:20:07,100
and also p.m. you is going to setup that

00:20:05,480 --> 00:20:09,250
you've adapted and hook up the min

00:20:07,100 --> 00:20:09,250
together

00:20:09,820 --> 00:20:15,169
thank you amy will notify the vendor

00:20:12,139 --> 00:20:18,679
driver aren't lefty the other PDF i/o PC

00:20:15,169 --> 00:20:22,179
user api's that also will be signed into

00:20:18,679 --> 00:20:22,179
the wonder driver through this callback

00:20:22,240 --> 00:20:27,080
then the wonder driver then in the in at

00:20:25,070 --> 00:20:28,610
runtime when the run the driver because

00:20:27,080 --> 00:20:31,250
he is the guy received the physical

00:20:28,610 --> 00:20:32,990
interrupt storage device then the vendor

00:20:31,250 --> 00:20:34,429
driver was his receive the physical

00:20:32,990 --> 00:20:37,429
interrupts he's going to re-inject

00:20:34,429 --> 00:20:40,159
signal Linda even on the even FD which

00:20:37,429 --> 00:20:42,760
we just told by the qemu to trigger to

00:20:40,159 --> 00:20:46,549
trigger the gas as our inside a guest

00:20:42,760 --> 00:20:52,779
so now let's not have finished the

00:20:46,549 --> 00:20:52,779
introductions 30

00:20:53,220 --> 00:20:56,210
so

00:20:58,010 --> 00:21:05,299
okay so I'm going to cover the current

00:21:00,140 --> 00:21:07,790
status yeah so we started the started

00:21:05,299 --> 00:21:10,640
the RFC on the Camus devil right from

00:21:07,790 --> 00:21:13,700
the FEHB and till now we are improving

00:21:10,640 --> 00:21:15,980
right now the version seven of the

00:21:13,700 --> 00:21:19,850
patches are out yesterday we are at

00:21:15,980 --> 00:21:23,169
enter to me in that with all those

00:21:19,850 --> 00:21:26,120
improvements all the suggestions like

00:21:23,169 --> 00:21:28,730
and like the new had already described

00:21:26,120 --> 00:21:32,630
we have the four major patches one first

00:21:28,730 --> 00:21:34,610
one is the core driver then of the VFR

00:21:32,630 --> 00:21:39,710
you driver for the mediated devices and

00:21:34,610 --> 00:21:42,320
the Iowa enhancement to the iommu driver

00:21:39,710 --> 00:21:45,860
and we had also added the documentation

00:21:42,320 --> 00:21:47,929
how how that could be used and how it

00:21:45,860 --> 00:21:51,260
will be helpful for the vendor driver to

00:21:47,929 --> 00:21:53,299
use the interfaces while posting the

00:21:51,260 --> 00:21:55,549
patches we had tested all these patches

00:21:53,299 --> 00:21:58,790
with the mediated device we had tested

00:21:55,549 --> 00:22:00,530
the vgpu on the nvidia GPU and we had

00:21:58,790 --> 00:22:02,960
tried multiple we had tested all the

00:22:00,530 --> 00:22:06,679
multiple combinations like multiple vgp

00:22:02,960 --> 00:22:09,770
used in multiple into multiple VMs into

00:22:06,679 --> 00:22:11,960
multiple VG fuse in the power vm we had

00:22:09,770 --> 00:22:16,010
also tested the combination of the pass

00:22:11,960 --> 00:22:19,130
through and vgpu in a single VM so so

00:22:16,010 --> 00:22:25,220
that we we covered all the test cases

00:22:19,130 --> 00:22:28,010
here I'm going to do our give a short

00:22:25,220 --> 00:22:31,330
demo how the vgpu works and how this is

00:22:28,010 --> 00:22:31,330
surface interface works here

00:22:43,840 --> 00:22:50,510
so this is the system which is based

00:22:47,150 --> 00:22:54,650
into the location it's in the Santa

00:22:50,510 --> 00:23:01,460
Clara but it's just to give an overview

00:22:54,650 --> 00:23:03,860
how it works so like I had knew I had

00:23:01,460 --> 00:23:05,809
already mentioned that for and the

00:23:03,860 --> 00:23:09,260
device is registered for the mediated

00:23:05,809 --> 00:23:12,190
co-driver we provide the surface entries

00:23:09,260 --> 00:23:16,549
like mediated supported types mediated

00:23:12,190 --> 00:23:19,700
em there create an dem dev destroy so we

00:23:16,549 --> 00:23:22,130
can use this MDL supported types to

00:23:19,700 --> 00:23:25,250
query what all the configurations that

00:23:22,130 --> 00:23:27,140
vendor driver can support so it's up to

00:23:25,250 --> 00:23:29,149
the vendor driver what they want to

00:23:27,140 --> 00:23:31,909
define how what configurations they want

00:23:29,149 --> 00:23:33,799
to support for example for the MVA vgp

00:23:31,909 --> 00:23:37,340
we support these configurations now I

00:23:33,799 --> 00:23:39,770
have a one m60 in the system and we

00:23:37,340 --> 00:23:44,240
support all these configurations in the

00:23:39,770 --> 00:23:49,669
with a VG to m60 so right now there is

00:23:44,240 --> 00:23:52,210
no VM running on this V GPU so it it

00:23:49,669 --> 00:23:56,929
shows all the list which we can try out

00:23:52,210 --> 00:23:59,600
then if we decide to go with the one so

00:23:56,929 --> 00:24:02,080
let's say we will go with the I have a

00:23:59,600 --> 00:24:02,080
scripts

00:24:08,790 --> 00:24:16,230
so you go with the m64 queue so I have

00:24:14,040 --> 00:24:20,190
the script ready so that we can just use

00:24:16,230 --> 00:24:23,010
it to go ahead so for this we have to

00:24:20,190 --> 00:24:25,200
specify the UUID for the device then

00:24:23,010 --> 00:24:27,150
that the UUID should be unique into the

00:24:25,200 --> 00:24:30,410
system for the device which we have been

00:24:27,150 --> 00:24:33,720
going to create over the physical device

00:24:30,410 --> 00:24:36,690
with the e by doing the echo and no UUID

00:24:33,720 --> 00:24:38,880
and the parameters which are the vendor

00:24:36,690 --> 00:24:42,150
specific parameters now I am using here

00:24:38,880 --> 00:24:44,400
number 20 the 20 specifies that we are

00:24:42,150 --> 00:24:48,090
going to use and grid m64 queue

00:24:44,400 --> 00:24:55,590
configuration there and just by case

00:24:48,090 --> 00:24:58,260
running the script will get this will

00:24:55,590 --> 00:25:01,160
create the device now to check that

00:24:58,260 --> 00:25:07,980
which device has been created let's so

00:25:01,160 --> 00:25:10,620
you can see oh you can see that device

00:25:07,980 --> 00:25:14,130
is created here at device with the same

00:25:10,620 --> 00:25:19,110
UID that we had provided and the first

00:25:14,130 --> 00:25:23,310
there in the to the create so this

00:25:19,110 --> 00:25:25,580
device is now online and you can see

00:25:23,310 --> 00:25:25,580
that

00:25:36,100 --> 00:25:48,510
okay now gentle I started chemo

00:25:43,380 --> 00:25:48,510
so it says voting the wind 7bm

00:26:05,950 --> 00:26:19,710
hello Vincent beam is booting and just

00:26:08,290 --> 00:26:19,710
get the VNC of the booted VM then sorry

00:26:20,490 --> 00:26:24,240
okay

00:26:21,610 --> 00:26:24,240
okay sure sure

00:27:25,450 --> 00:27:31,270
okay this is the cable come on and you

00:27:28,930 --> 00:27:33,490
can see here the device which I we had

00:27:31,270 --> 00:27:36,520
provided through the surface we gave the

00:27:33,490 --> 00:27:38,680
device the path here and the device part

00:27:36,520 --> 00:27:41,920
is what we had seen that this bus MDF

00:27:38,680 --> 00:27:45,580
devices and the device I the UUID of it

00:27:41,920 --> 00:27:52,840
so you have to provide this the this

00:27:45,580 --> 00:27:54,760
part to the chemo command ring and then

00:27:52,840 --> 00:27:56,020
it's the same as the Alex's mentioned in

00:27:54,760 --> 00:27:57,610
the yesterday's gave for your

00:27:56,020 --> 00:28:01,450
presentation with the surface part

00:27:57,610 --> 00:28:03,780
itself takes the device now we have the

00:28:01,450 --> 00:28:03,780
VM running

00:28:23,510 --> 00:28:31,700
okay so this is a VNC so it's a it's not

00:28:28,870 --> 00:28:34,519
it's not a remoting client if you use a

00:28:31,700 --> 00:28:36,950
remote inclined to accept the GPU is

00:28:34,519 --> 00:28:39,139
devices that it gives of very good

00:28:36,950 --> 00:28:43,279
performance but this has got to be the

00:28:39,139 --> 00:28:46,539
VNC we are doing now and you can see

00:28:43,279 --> 00:28:46,539
that driver is loaded

00:28:56,480 --> 00:29:01,539
so Nvidia driver is loaded and it's

00:28:59,179 --> 00:29:01,539
running

00:29:06,430 --> 00:29:12,490
and see we had selected m64 queue

00:29:09,720 --> 00:29:13,920
creating the device so this is an M 64

00:29:12,490 --> 00:29:16,920
cube option

00:29:13,920 --> 00:29:16,920
device

00:29:25,560 --> 00:29:32,070
I hope on 3d app which is a this called

00:29:29,100 --> 00:29:35,790
a dolphin which is done as an now on a

00:29:32,070 --> 00:29:38,370
test case so this is a dolphin running

00:29:35,790 --> 00:29:40,920
it's running at the 60fps but as I said

00:29:38,370 --> 00:29:42,600
this is a BNC this is not any remoting

00:29:40,920 --> 00:29:44,790
client so if we go with the remoting

00:29:42,600 --> 00:29:47,900
client at actually it actually gives an

00:29:44,790 --> 00:29:47,900
very good performance

00:29:54,330 --> 00:30:01,759
so this is all about a demo we go back

00:29:58,709 --> 00:30:01,759
to the slides again

00:30:30,860 --> 00:30:37,760
so what's the food future work which is

00:30:32,810 --> 00:30:41,120
remaining in this hold model right now

00:30:37,760 --> 00:30:44,630
we had not supported the pass Oh mmm you

00:30:41,120 --> 00:30:46,880
type we had done the enhancement to the

00:30:44,630 --> 00:30:49,910
IOM my phone module which is which is

00:30:46,880 --> 00:30:52,610
the Intel x86 architecture but we do

00:30:49,910 --> 00:30:54,890
want to support this I remember you

00:30:52,610 --> 00:30:57,220
model as well so that pinning and

00:30:54,890 --> 00:31:01,670
unpinning is supported by this model

00:30:57,220 --> 00:31:04,130
then we want to get get this all

00:31:01,670 --> 00:31:06,170
interface integrated with the lippert so

00:31:04,130 --> 00:31:10,420
that it will be easy for the users to

00:31:06,170 --> 00:31:13,280
configure the Khemu and it's it's just

00:31:10,420 --> 00:31:15,500
just to configure it and run it out so

00:31:13,280 --> 00:31:19,420
don't have to do any of the manual work

00:31:15,500 --> 00:31:22,160
like the baby had seen with the surface

00:31:19,420 --> 00:31:24,290
so these are beyond pieces all we are

00:31:22,160 --> 00:31:28,840
looking for do the future work in a very

00:31:24,290 --> 00:31:31,820
recent in the very fluid coming time

00:31:28,840 --> 00:31:34,460
these are the references suppose one is

00:31:31,820 --> 00:31:37,490
the alex's work or the VA value that we

00:31:34,460 --> 00:31:40,400
had to hold yesterday and the links to

00:31:37,490 --> 00:31:44,330
the version 7 patches that we had

00:31:40,400 --> 00:31:45,830
already out with the code and then we

00:31:44,330 --> 00:31:47,510
had also started the live bird

00:31:45,830 --> 00:31:50,450
discussions on the live bird mailing

00:31:47,510 --> 00:31:52,820
list so that includes all the details

00:31:50,450 --> 00:31:54,470
what we are expecting to the return what

00:31:52,820 --> 00:31:56,650
is expected from the live birth to be

00:31:54,470 --> 00:31:56,650
done

00:32:10,600 --> 00:32:15,460
don't you want to awesome it works hi

00:32:13,720 --> 00:32:17,410
first off kudos this is the first time I

00:32:15,460 --> 00:32:20,050
actually see a sane solution to the

00:32:17,410 --> 00:32:21,700
whole how to butterfly CPUs problem I

00:32:20,050 --> 00:32:25,900
mean seriously the first time I see

00:32:21,700 --> 00:32:28,540
somebody present something saying two

00:32:25,900 --> 00:32:30,940
simple questions the first is how do I

00:32:28,540 --> 00:32:33,370
get the frame buffer off that virtual

00:32:30,940 --> 00:32:36,730
GPU into my host so that I don't have to

00:32:33,370 --> 00:32:38,950
poke holes into like the guests to then

00:32:36,730 --> 00:32:40,210
patch the framework from inside I would

00:32:38,950 --> 00:32:42,220
rather want to have it from the outside

00:32:40,210 --> 00:32:44,980
like and then use take Hume use native

00:32:42,220 --> 00:32:47,200
VNC server cues spy server whatever it

00:32:44,980 --> 00:32:50,710
is to display the contents of the

00:32:47,200 --> 00:32:54,640
virtual GPU okay I single whatever the

00:32:50,710 --> 00:32:58,060
asking is about how to to Canada to

00:32:54,640 --> 00:33:01,330
integrate the integrator our to see the

00:32:58,060 --> 00:33:05,560
guest house through the Killian amÃ©o BNC

00:33:01,330 --> 00:33:10,060
console all SDL right that is something

00:33:05,560 --> 00:33:12,340
we have we have in mind but a generic

00:33:10,060 --> 00:33:17,040
one based on the history we haven't seen

00:33:12,340 --> 00:33:20,650
in the other use case that is not like a

00:33:17,040 --> 00:33:23,050
high-end accelerate interface because

00:33:20,650 --> 00:33:27,010
most of people use this interface a bit

00:33:23,050 --> 00:33:28,750
of GPUs right a transition is directly

00:33:27,010 --> 00:33:30,790
from the guests they have like a remote

00:33:28,750 --> 00:33:35,080
agent running inside the gas like a

00:33:30,790 --> 00:33:37,480
Santa hub or VMware View solutions but

00:33:35,080 --> 00:33:39,010
for a different use case which

00:33:37,480 --> 00:33:42,550
definitely we can look at in to learn

00:33:39,010 --> 00:33:45,190
what how to implement this our frame

00:33:42,550 --> 00:33:47,170
buffer informations basically you wanted

00:33:45,190 --> 00:33:52,180
to subtract of the pixels and a surface

00:33:47,170 --> 00:33:54,610
into the into the qmu console right just

00:33:52,180 --> 00:33:56,890
map the frame buffer that's there

00:33:54,610 --> 00:33:59,560
already that you already like update 30

00:33:56,890 --> 00:34:01,450
times a second 46 times whatever right

00:33:59,560 --> 00:34:03,190
and post that ass like just my friend

00:34:01,450 --> 00:34:05,680
before you to interlace the console

00:34:03,190 --> 00:34:07,600
right right so um first thing I'm not

00:34:05,680 --> 00:34:10,030
aware of people actually is doing like a

00:34:07,600 --> 00:34:12,730
30 frame per seconds or 60 frame per

00:34:10,030 --> 00:34:14,650
seconds who like from the 3mu or tabasum

00:34:12,730 --> 00:34:16,300
module console but if you there's a use

00:34:14,650 --> 00:34:19,690
case we definitely should look into that

00:34:16,300 --> 00:34:22,570
right but the main use case is it would

00:34:19,690 --> 00:34:24,640
make it work locally right he will look

00:34:22,570 --> 00:34:28,480
work locally but uh

00:34:24,640 --> 00:34:29,980
in our case is most timely when people

00:34:28,480 --> 00:34:31,840
use that it rely on that interface it's

00:34:29,980 --> 00:34:33,460
just for the management rightful it is

00:34:31,840 --> 00:34:34,660
the installing driver checking what's

00:34:33,460 --> 00:34:37,090
going on inside a virtual machine for

00:34:34,660 --> 00:34:40,210
the idea the patricians those type of

00:34:37,090 --> 00:34:42,160
work right so that not a lot of wipe

00:34:40,210 --> 00:34:44,020
that lasts the case no one we can

00:34:42,160 --> 00:34:45,700
support our interface but a normally

00:34:44,020 --> 00:34:48,070
large interface will be limited like a

00:34:45,700 --> 00:34:50,890
10 frame per seconds or something like

00:34:48,070 --> 00:34:53,680
that it's like a low frequency low FPS

00:34:50,890 --> 00:34:57,490
interface but yeah but it isn't there's

00:34:53,680 --> 00:34:59,830
no I mean if even there's a valid use

00:34:57,490 --> 00:35:01,120
case we definitely should look into how

00:34:59,830 --> 00:35:02,890
it will make a lot of faster right

00:35:01,120 --> 00:35:08,620
advanced that we don't burn too much of

00:35:02,890 --> 00:35:10,690
CPU cycles maybe you can even keep it

00:35:08,620 --> 00:35:13,330
inside the GPU memory and just really

00:35:10,690 --> 00:35:15,100
point it as a surface yeah we do we

00:35:13,330 --> 00:35:16,870
should be able to like a DNA directly

00:35:15,100 --> 00:35:18,490
like a frame buffer back to the marriage

00:35:16,870 --> 00:35:19,510
you need again you don't you don't

00:35:18,490 --> 00:35:21,340
really have to because you are

00:35:19,510 --> 00:35:23,440
eventually like you actually are

00:35:21,340 --> 00:35:25,150
overlaying right you just use the next V

00:35:23,440 --> 00:35:27,130
interphasic Smith I'll interface this is

00:35:25,150 --> 00:35:29,290
all like old times to these days you do

00:35:27,130 --> 00:35:31,000
it differently but something that keeps

00:35:29,290 --> 00:35:32,200
your memory inside the GPU so you don't

00:35:31,000 --> 00:35:34,510
have to flush it out to memory all the

00:35:32,200 --> 00:35:37,540
time which then again burns are you PCI

00:35:34,510 --> 00:35:38,470
Express cycles the other one and that I

00:35:37,540 --> 00:35:39,880
think that would be really cool because

00:35:38,470 --> 00:35:42,850
then I could just say on my notebook

00:35:39,880 --> 00:35:45,820
with it NVIDIA GPU go and run any random

00:35:42,850 --> 00:35:47,500
VM and just have a window with fully

00:35:45,820 --> 00:35:48,970
accelerate graphics in there right

00:35:47,500 --> 00:35:52,720
that's basically what's missing on that

00:35:48,970 --> 00:35:55,420
solution yeah the other part is for DMA

00:35:52,720 --> 00:35:57,580
accesses I remember from the Intel stuff

00:35:55,420 --> 00:36:01,030
that they went through great lengths to

00:35:57,580 --> 00:36:03,760
make sure that they isolate all the

00:36:01,030 --> 00:36:06,220
separate context as they have in there

00:36:03,760 --> 00:36:07,540
like internally and usually switch them

00:36:06,220 --> 00:36:08,710
all the whole time and make sure you

00:36:07,540 --> 00:36:10,330
that they have different IDs and

00:36:08,710 --> 00:36:12,010
different page tables for them you have

00:36:10,330 --> 00:36:14,080
something similar on yours oh we don't

00:36:12,010 --> 00:36:16,630
have that so basically if one guest

00:36:14,080 --> 00:36:19,030
could access another guest memory

00:36:16,630 --> 00:36:21,100
oh no no no what I'm saying is that we

00:36:19,030 --> 00:36:22,420
don't have a restriction solver to put

00:36:21,100 --> 00:36:25,120
it on the into the different Oba space

00:36:22,420 --> 00:36:28,060
right but because we have we have a keep

00:36:25,120 --> 00:36:30,580
you have our mu as well so we fully rely

00:36:28,060 --> 00:36:32,710
on the keep you have annuity to isolate

00:36:30,580 --> 00:36:34,810
those contacts so they can all that

00:36:32,710 --> 00:36:35,800
access to each other's memories okay so

00:36:34,810 --> 00:36:37,300
they are

00:36:35,800 --> 00:36:40,270
they can run in parallel you basely have

00:36:37,300 --> 00:36:42,520
virtual IDs inside your your mu in

00:36:40,270 --> 00:36:51,280
multiple contexts is - yeah yeah we have

00:36:42,520 --> 00:36:54,070
multiple thank you thank you in the

00:36:51,280 --> 00:36:57,520
Sisyphus interface you have a supportive

00:36:54,070 --> 00:36:58,810
M dev types file yes which list is very

00:36:57,520 --> 00:37:01,090
definitely seeing things you can create

00:36:58,810 --> 00:37:02,470
right unless I'm missing something it

00:37:01,090 --> 00:37:05,080
didn't say how many of each you could

00:37:02,470 --> 00:37:06,910
create yeah we have and there's a

00:37:05,080 --> 00:37:08,500
maximum or comment Oh max I can forget

00:37:06,910 --> 00:37:12,840
the term is a max instance of Mexico

00:37:08,500 --> 00:37:12,840
account that is how many you can create

00:37:12,870 --> 00:37:19,720
yeah also is it is inside a name but we

00:37:16,870 --> 00:37:21,370
do have a specific column say presumably

00:37:19,720 --> 00:37:23,830
if you create one of one type that's

00:37:21,370 --> 00:37:26,020
gonna decrement how many you can create

00:37:23,830 --> 00:37:27,640
of all the other types right right so

00:37:26,020 --> 00:37:29,650
far we don't support on mix mix match

00:37:27,640 --> 00:37:31,510
types so once you've created one types

00:37:29,650 --> 00:37:33,670
and if you do if you check that a file

00:37:31,510 --> 00:37:41,200
again you just show you this physical

00:37:33,670 --> 00:37:43,990
GPUs can only support that type okay and

00:37:41,200 --> 00:37:47,320
there seems to be kind of two levels to

00:37:43,990 --> 00:37:50,020
this there's a generic type of M or

00:37:47,320 --> 00:37:51,820
device type that you introduce right and

00:37:50,020 --> 00:37:54,460
then there's the specifics for graphics

00:37:51,820 --> 00:37:56,500
devices okay do you have a plan to kind

00:37:54,460 --> 00:37:58,440
of separate those two so that all the

00:37:56,500 --> 00:38:03,310
types of devices that doesn't have

00:37:58,440 --> 00:38:05,560
resolution so far actually the framework

00:38:03,310 --> 00:38:07,000
of your building here is so I should

00:38:05,560 --> 00:38:10,390
have you actually applied to a generic

00:38:07,000 --> 00:38:14,140
i/o device I don't see anything else

00:38:10,390 --> 00:38:16,450
other than what Alex just asked to track

00:38:14,140 --> 00:38:18,310
the instructor frame buffer outside to

00:38:16,450 --> 00:38:21,250
the commit that it will be graphics is

00:38:18,310 --> 00:38:25,740
specific right but for everything else

00:38:21,250 --> 00:38:25,740
here it should be generic icing

00:38:27,950 --> 00:38:38,660
I mean you know Intel dealers similar

00:38:35,960 --> 00:38:42,230
things I think are we presented to at

00:38:38,660 --> 00:38:45,020
KBM Requiem two years ago right and just

00:38:42,230 --> 00:38:49,630
wondering if you know on this basically

00:38:45,020 --> 00:38:57,589
you know approach is the same basically

00:38:49,630 --> 00:38:59,510
right so question is oh yeah sure and so

00:38:57,589 --> 00:39:01,180
this is a like Alex said yesterday so

00:38:59,510 --> 00:39:05,079
this is a collaboration where capital

00:39:01,180 --> 00:39:08,000
Nvidia Intel Red Hat and also IBM so

00:39:05,079 --> 00:39:08,630
yeah it's a very very well discussed

00:39:08,000 --> 00:39:11,960
okay

00:39:08,630 --> 00:39:15,380
that's good and then other question is

00:39:11,960 --> 00:39:24,680
they you may need some scheduling if you

00:39:15,380 --> 00:39:25,970
have multiple graphics so there's

00:39:24,680 --> 00:39:27,470
actually two part of scheduling

00:39:25,970 --> 00:39:28,910
right so one part is the castle

00:39:27,470 --> 00:39:31,609
shattering like a for example if you run

00:39:28,910 --> 00:39:33,380
Windows Windows VM you run WDDM all

00:39:31,609 --> 00:39:35,000
right it's WDM it's between schedules of

00:39:33,380 --> 00:39:36,260
graphics workload for you already right

00:39:35,000 --> 00:39:38,119
so we don't want to touch that part

00:39:36,260 --> 00:39:39,920
right there so the second part of

00:39:38,119 --> 00:39:41,930
scheduling is on a host so it's a

00:39:39,920 --> 00:39:44,150
completely owned by the vendor specific

00:39:41,930 --> 00:39:46,790
drivers in lasik in our case is NVIDIA

00:39:44,150 --> 00:39:50,030
GPU and the risk we program our hardware

00:39:46,790 --> 00:39:51,740
and we do the scheduling and we will try

00:39:50,030 --> 00:39:54,140
to achieve the best performance for the

00:39:51,740 --> 00:40:02,900
photo for the fairness right all the key

00:39:54,140 --> 00:40:12,619
lasting example you know the GPU

00:40:02,900 --> 00:40:15,109
resources so yeah it's a it really

00:40:12,619 --> 00:40:17,059
depends on what kind of subscription you

00:40:15,109 --> 00:40:18,799
do mention here right so let's say if

00:40:17,059 --> 00:40:22,069
you said do you support of frame buffer

00:40:18,799 --> 00:40:23,599
or subscription right yes or no right so

00:40:22,069 --> 00:40:25,670
if I say yes it's because the windows

00:40:23,599 --> 00:40:29,000
are supported already so if I give you a

00:40:25,670 --> 00:40:31,339
photo megabyte oh we were to GPO VM you

00:40:29,000 --> 00:40:33,049
actually can run on much more water than

00:40:31,339 --> 00:40:34,549
twelve because Windows will manage the

00:40:33,049 --> 00:40:37,549
paging pitting and pick out already

00:40:34,549 --> 00:40:38,900
not even automatically right but on the

00:40:37,549 --> 00:40:41,210
other hand we don't support us our

00:40:38,900 --> 00:40:42,590
subscription on the host you can see

00:40:41,210 --> 00:40:44,690
the number of virtual machines you run

00:40:42,590 --> 00:41:02,630
actually is limited by the size of frame

00:40:44,690 --> 00:41:09,470
buffers of the physical so yeah so is

00:41:02,630 --> 00:41:12,950
that something the control pass is let's

00:41:09,470 --> 00:41:15,500
say in this is this is not the truth

00:41:12,950 --> 00:41:17,450
this is not us and some anything new for

00:41:15,500 --> 00:41:20,450
the for personalization and folder for

00:41:17,450 --> 00:41:22,040
the right even you program the oh I owe

00:41:20,450 --> 00:41:24,230
a device or graphics the workload oh we

00:41:22,040 --> 00:41:26,600
wanted the control path will be very

00:41:24,230 --> 00:41:28,220
short you just set up everything then

00:41:26,600 --> 00:41:29,660
the next thing is you take the data pass

00:41:28,220 --> 00:41:34,700
you basically just shuffle your commands

00:41:29,660 --> 00:41:38,570
to the GPU queue actually so those two

00:41:34,700 --> 00:41:40,220
part is are a separate in the in the in

00:41:38,570 --> 00:41:43,160
the bare metal when you hire program the

00:41:40,220 --> 00:41:45,530
GPU we just preserve data attribute and

00:41:43,160 --> 00:41:47,750
we just make sure when you when you want

00:41:45,530 --> 00:41:50,120
is a shuffle the commands to the GPU as

00:41:47,750 --> 00:41:52,850
as fast as possible we don't provide we

00:41:50,120 --> 00:41:54,800
don't provide any we don't have any

00:41:52,850 --> 00:41:58,900
photo neck in this virtualization

00:41:54,800 --> 00:41:58,900
framework okay that's what we did

00:42:06,520 --> 00:42:23,620
switching is also possible sorry what oh

00:42:10,490 --> 00:42:23,620
that dynamic switching I don't think so

00:42:24,640 --> 00:42:31,070
the vendor driver needs to specify it at

00:42:27,440 --> 00:42:34,070
the initialization itself so when we for

00:42:31,070 --> 00:42:36,950
API queries about the gate region

00:42:34,070 --> 00:42:38,990
information at that time only the region

00:42:36,950 --> 00:42:40,610
information the flags has to be said at

00:42:38,990 --> 00:42:42,260
that time only and that's so do it and

00:42:40,610 --> 00:42:45,410
that's done and when the okay move

00:42:42,260 --> 00:42:46,640
initialization so so initially it's the

00:42:45,410 --> 00:42:49,840
vendor diamond that needs to provide

00:42:46,640 --> 00:42:49,840
this information right

00:42:59,260 --> 00:43:04,840
I you mentioned that one of the

00:43:01,810 --> 00:43:06,730
advantages of the mediator versus food

00:43:04,840 --> 00:43:10,480
pass-through is the control of the

00:43:06,730 --> 00:43:12,880
Austin but I I don't see any kind of

00:43:10,480 --> 00:43:14,980
configuration what can you do what's the

00:43:12,880 --> 00:43:17,200
flexibility of the configuration can you

00:43:14,980 --> 00:43:19,420
reduce the I don't know the coup de

00:43:17,200 --> 00:43:20,520
coeur inside one um and assigned to

00:43:19,420 --> 00:43:32,560
another

00:43:20,520 --> 00:43:35,260
can you change sure yeah one thing is I

00:43:32,560 --> 00:43:37,510
think June already asking a question

00:43:35,260 --> 00:43:39,190
about scheduling right so what we can do

00:43:37,510 --> 00:43:41,200
here is we can actually be now have more

00:43:39,190 --> 00:43:43,990
better scheduling algorithm are here

00:43:41,200 --> 00:43:45,910
because we have a host of vendor

00:43:43,990 --> 00:43:48,250
specific drivers on the on the host

00:43:45,910 --> 00:43:50,170
right on the device right so you don't

00:43:48,250 --> 00:43:52,450
help you fully just rely on the virtual

00:43:50,170 --> 00:43:56,140
machine itself that's one part and also

00:43:52,450 --> 00:43:57,640
we can we have a better monitoring right

00:43:56,140 --> 00:44:02,380
so you can not more interim what's the

00:43:57,640 --> 00:44:04,510
usage workload on ladder device you this

00:44:02,380 --> 00:44:25,210
is not like a so the coup de coeur is

00:44:04,510 --> 00:44:28,480
not like something you can write that's

00:44:25,210 --> 00:44:31,150
good question so so for now we don't we

00:44:28,480 --> 00:44:33,490
don't have a we don't support lat so

00:44:31,150 --> 00:44:36,280
basically what are you are saying is you

00:44:33,490 --> 00:44:39,070
are you still going to run the graphics

00:44:36,280 --> 00:44:41,920
workload on the host right as a client

00:44:39,070 --> 00:44:44,470
type of virtualization so you can put

00:44:41,920 --> 00:44:48,100
supported their virtual machine and also

00:44:44,470 --> 00:44:50,890
you have you have a local graphics on

00:44:48,100 --> 00:44:53,820
all the supported by the GPU so far we

00:44:50,890 --> 00:44:53,820
don't have large support

00:44:58,050 --> 00:45:03,310
now this is a this is a this is a server

00:45:01,240 --> 00:45:05,950
of but it's mainly for the server market

00:45:03,310 --> 00:45:09,970
and these you know I shouldn't say those

00:45:05,950 --> 00:45:13,900
marketing stuff but this is mainly for

00:45:09,970 --> 00:45:16,360
the secondary keep used right is there a

00:45:13,900 --> 00:45:18,190
particular reason that you decided to do

00:45:16,360 --> 00:45:20,950
this software implementation rather than

00:45:18,190 --> 00:45:25,840
doing it in hardware as an SR IV device

00:45:20,950 --> 00:45:28,720
once a is expensive right we want to we

00:45:25,840 --> 00:45:31,390
want to prove the market we want to then

00:45:28,720 --> 00:45:36,400
build a burning burning something say in

00:45:31,390 --> 00:45:39,360
the city code right I have a very simple

00:45:36,400 --> 00:45:42,160
question so currently currently the

00:45:39,360 --> 00:45:44,950
physical GPU hardware was sharing about

00:45:42,160 --> 00:45:48,010
multiple VMs alright so my question is

00:45:44,950 --> 00:45:52,120
currently how many VMs can can share the

00:45:48,010 --> 00:45:55,330
same hardware like in today's in the

00:45:52,120 --> 00:46:01,060
current US release we do we support 16

00:45:55,330 --> 00:46:03,250
in virtual machines 16 16 1 6 how about

00:46:01,060 --> 00:46:05,920
the performance the issue like the total

00:46:03,250 --> 00:46:08,890
performance compared with the native the

00:46:05,920 --> 00:46:12,880
performance is a depends right so if you

00:46:08,890 --> 00:46:14,980
say if I want 16 machine machines and I

00:46:12,880 --> 00:46:17,620
run like I run like and you didn't have

00:46:14,980 --> 00:46:19,540
it right so that probably don't get it

00:46:17,620 --> 00:46:20,920
the best performance as you have on the

00:46:19,540 --> 00:46:23,140
bare metal it depends and also it

00:46:20,920 --> 00:46:27,700
depends on the application you have is a

00:46:23,140 --> 00:46:29,290
CPU bond or TPU bomb right if you see if

00:46:27,700 --> 00:46:30,550
you bother than you should go get a

00:46:29,290 --> 00:46:38,070
better performance to the comparing to

00:46:30,550 --> 00:46:38,070
the bare metal I'm 16

00:46:39,010 --> 00:46:46,800
I think of you that's it Oh guys thank

00:46:43,750 --> 00:46:46,800

YouTube URL: https://www.youtube.com/watch?v=Xs0TJU_sIPc


