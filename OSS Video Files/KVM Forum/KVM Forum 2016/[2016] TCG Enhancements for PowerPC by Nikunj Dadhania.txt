Title: [2016] TCG Enhancements for PowerPC by Nikunj Dadhania
Publication date: 2016-09-06
Playlist: KVM Forum 2016
Description: 
	QEMU allows for emulating different target architectures using the TCG mode. TCG
mode has been effectively used for validating pre-silicon systems. Developers
have often used QEMU TCG to develop application stack before actually deploying
them on real target architectures. Even though application development with TCG
can be slow, the non-availability of early hardware is often a compelling reason
to use TCG.

This talk will focus on some of the enhancements that are in progress to support
PowerPC architecture better in QEMU TCG mode. This includes the new PowerNV
platform, support for upcoming POWER9 processor and its ISA. We will also look
at some of the performance enhancements like multi-threaded TCG support for
PowerPC.

Nikunj Dadhania
Advisory Software Engineer, IBM Linux Technology Center

Nikunj A. Dadhania works on KVM virtualization as part of IBM Linux Technology Center, India. He has been the maintainer of SLOF (Slim-line Open Firmware) fornKVM on Power. He has experience in libvirt, scheduler and embedded systems.


Slides: http://www.linux-kvm.org/images/1/13/02x09A-Nikunj_Dadhania-TCG_Enhancements_for_PowerPC.pdf
Captions: 
	00:00:09,290 --> 00:00:17,100
good afternoon today I will be speaking

00:00:12,900 --> 00:00:21,350
about TCG enhancements that we are doing

00:00:17,100 --> 00:00:26,180
in powerpc my name is nikanj adanya i

00:00:21,350 --> 00:00:29,820
work for IBM linux technology center

00:00:26,180 --> 00:00:32,340
something about myself and primarily the

00:00:29,820 --> 00:00:37,230
guests from where developer for pc

00:00:32,340 --> 00:00:41,340
series called sloth initially i started

00:00:37,230 --> 00:00:46,530
somewhere around put 2012 developing

00:00:41,340 --> 00:00:51,270
slop and I was like I had to debug slav

00:00:46,530 --> 00:00:53,370
or tests love so the thing at the time

00:00:51,270 --> 00:00:55,770
the kvm own power was not even available

00:00:53,370 --> 00:01:00,539
so one of the issues that I had was to

00:00:55,770 --> 00:01:02,250
how to develop Slough and Q mu was cute

00:01:00,539 --> 00:01:04,739
ECG was very helpful during that time

00:01:02,250 --> 00:01:10,280
and i've been using q mu TCG for quite a

00:01:04,739 --> 00:01:13,200
long time so and as a cue user and

00:01:10,280 --> 00:01:18,299
trying to do something in TCG as well as

00:01:13,200 --> 00:01:21,979
so the agenda so we would basically

00:01:18,299 --> 00:01:26,580
touch up on quickly on the q me TCG part

00:01:21,979 --> 00:01:29,939
after that i would cover the new power

00:01:26,580 --> 00:01:34,140
is a 30 come which is upcoming in our

00:01:29,939 --> 00:01:36,630
new processor power 9 the next topic

00:01:34,140 --> 00:01:39,329
would be power envy this is basically

00:01:36,630 --> 00:01:43,979
the bare metal emulation of the power

00:01:39,329 --> 00:01:46,850
hardware some experiments that i did

00:01:43,979 --> 00:01:49,700
with a multitude TCG will cover that and

00:01:46,850 --> 00:01:56,009
some of the optimization and future work

00:01:49,700 --> 00:01:58,829
so let's for let's start with Q TCG so

00:01:56,009 --> 00:02:03,060
how is emulation done so if i have a

00:01:58,829 --> 00:02:04,770
power bc machine code I'll have a stream

00:02:03,060 --> 00:02:07,140
of instructions and basically I will

00:02:04,770 --> 00:02:09,060
need to translate into on the on to the

00:02:07,140 --> 00:02:11,310
host where I want to run so basically it

00:02:09,060 --> 00:02:13,230
will be like if it is x86 I would just

00:02:11,310 --> 00:02:13,720
convert that instruction stream into an

00:02:13,230 --> 00:02:18,640
excess

00:02:13,720 --> 00:02:22,900
score and then I'm able to run on x86 so

00:02:18,640 --> 00:02:25,690
the it is easy to do for maybe like few

00:02:22,900 --> 00:02:27,610
instruction but if I look at is a I say

00:02:25,690 --> 00:02:31,000
is huge actually so will be hundreds of

00:02:27,610 --> 00:02:33,790
instructions so basically chai one is a

00:02:31,000 --> 00:02:36,310
to the other is a conversion so if I

00:02:33,790 --> 00:02:38,740
have multiple architectures basically I

00:02:36,310 --> 00:02:41,590
need to translate from various

00:02:38,740 --> 00:02:44,740
architectures to x86 and then I will do

00:02:41,590 --> 00:02:48,760
not exceed six and this really gets

00:02:44,740 --> 00:02:51,459
complicated with multiple n cross n kind

00:02:48,760 --> 00:02:54,160
of scenario where I know where I want to

00:02:51,459 --> 00:02:58,900
run power on x86 or arm or something

00:02:54,160 --> 00:03:01,920
like that so TCG here helps a lot so the

00:02:58,900 --> 00:03:05,580
qme TCG with the tiny code generator

00:03:01,920 --> 00:03:08,820
basically gives us a machine independent

00:03:05,580 --> 00:03:12,010
intermediate rotation so basically

00:03:08,820 --> 00:03:16,209
architecture developer just needs to

00:03:12,010 --> 00:03:18,300
encode in my crops and finally whatever

00:03:16,209 --> 00:03:20,970
back and support is there i can run

00:03:18,300 --> 00:03:25,900
power on any back-end which is supported

00:03:20,970 --> 00:03:31,480
so this TCG engine can be combined in

00:03:25,900 --> 00:03:33,700
different ways to give us something if i

00:03:31,480 --> 00:03:37,840
combine it with a linux system call

00:03:33,700 --> 00:03:41,860
emulation so what I get is basically qmu

00:03:37,840 --> 00:03:46,870
linux user so i would be able to test my

00:03:41,860 --> 00:03:50,110
linux programs using that a target

00:03:46,870 --> 00:03:54,370
program on on a foreign architecture

00:03:50,110 --> 00:03:56,530
actually so the qme of the auras lyrics

00:03:54,370 --> 00:03:58,810
user actually so what what do I input I

00:03:56,530 --> 00:04:01,269
input the target target boundary and the

00:03:58,810 --> 00:04:03,370
libraries it provides me the Linux

00:04:01,269 --> 00:04:06,340
system call emulation and it emulates

00:04:03,370 --> 00:04:09,040
the ISA so this basically can be used

00:04:06,340 --> 00:04:12,850
for debugging user programs and now i

00:04:09,040 --> 00:04:14,970
have been using this to test the new is

00:04:12,850 --> 00:04:17,160
a seed Otto

00:04:14,970 --> 00:04:19,739
unit-testing basically the newer code

00:04:17,160 --> 00:04:22,590
that that I am writing so with this

00:04:19,739 --> 00:04:25,800
short premiere on TCG let us start

00:04:22,590 --> 00:04:29,130
looking at what do we have in power is a

00:04:25,800 --> 00:04:31,440
so the newer is a so the I say it comes

00:04:29,130 --> 00:04:33,930
with a lot of instructions actually so

00:04:31,440 --> 00:04:37,590
that the newer I say has around more

00:04:33,930 --> 00:04:39,630
than 180 instructions and there are

00:04:37,590 --> 00:04:43,410
various classes of instructions that are

00:04:39,630 --> 00:04:45,450
added there are in ethnic categories

00:04:43,410 --> 00:04:49,310
then hash you support a lot of string

00:04:45,450 --> 00:04:53,790
operations that we can optimize reading

00:04:49,310 --> 00:04:55,860
string many little endian big endian

00:04:53,790 --> 00:04:59,430
kind of scenarios where a load would

00:04:55,860 --> 00:05:02,130
generate the consistent memory layout so

00:04:59,430 --> 00:05:03,870
the the the standard is open now and we

00:05:02,130 --> 00:05:07,530
can actually download the standard from

00:05:03,870 --> 00:05:11,040
the link that I have provided so we have

00:05:07,530 --> 00:05:16,320
been like publishing patches for power

00:05:11,040 --> 00:05:18,690
is a and we have around 24 cued up in

00:05:16,320 --> 00:05:22,020
the in the PPC tree for the next two dot

00:05:18,690 --> 00:05:24,470
eight we have basically started from the

00:05:22,020 --> 00:05:27,660
arithmetic and the vector instructions

00:05:24,470 --> 00:05:30,270
there are many under review basically a

00:05:27,660 --> 00:05:35,729
load store kind of instructions that are

00:05:30,270 --> 00:05:39,060
load sir Ector scalar in TCG we don't

00:05:35,729 --> 00:05:41,340
have 128 bit low loads actually so we

00:05:39,060 --> 00:05:43,350
are finding trouble there we have to

00:05:41,340 --> 00:05:45,660
split the load into two things and do it

00:05:43,350 --> 00:05:48,570
so that that would be something that we

00:05:45,660 --> 00:05:50,940
would like to add as well there are many

00:05:48,570 --> 00:05:54,360
instructions that I have under testing

00:05:50,940 --> 00:05:56,490
understood the difference so that's the

00:05:54,360 --> 00:05:59,070
link that that I have that's a working

00:05:56,490 --> 00:06:03,419
link that I have right now so the

00:05:59,070 --> 00:06:06,060
working progress for p90 cg so the the

00:06:03,419 --> 00:06:09,419
challenges that we see here is the is

00:06:06,060 --> 00:06:10,680
the testing so we we have like huge

00:06:09,419 --> 00:06:14,360
number of instructions that we are

00:06:10,680 --> 00:06:17,070
adding here and some of the instructions

00:06:14,360 --> 00:06:19,860
do change something retrospective as

00:06:17,070 --> 00:06:23,039
well because now there there are some

00:06:19,860 --> 00:06:26,160
new bit fields that carry fields that

00:06:23,039 --> 00:06:27,180
they have upload upload updated so the

00:06:26,160 --> 00:06:28,949
older in

00:06:27,180 --> 00:06:33,630
actions that you are multiplied

00:06:28,949 --> 00:06:36,660
instructions would change would would

00:06:33,630 --> 00:06:42,270
would have to start changing the 32-bit

00:06:36,660 --> 00:06:43,830
or flow flags as well so so so testing

00:06:42,270 --> 00:06:46,020
is one of the one of the important

00:06:43,830 --> 00:06:49,680
things that we are seeing there is

00:06:46,020 --> 00:06:52,650
there's a gap there so we have been

00:06:49,680 --> 00:06:55,560
talking and there are different options

00:06:52,650 --> 00:06:57,509
there 11 is used kvm unit tests

00:06:55,560 --> 00:06:59,009
basically to make sure that we add for

00:06:57,509 --> 00:07:02,639
every instruction that we are adding we

00:06:59,009 --> 00:07:06,240
use we add a unit test there and make

00:07:02,639 --> 00:07:09,330
sure that different kinds of invalid

00:07:06,240 --> 00:07:11,789
test cases then value test case is over

00:07:09,330 --> 00:07:15,150
flow conditions we can do one of the

00:07:11,789 --> 00:07:18,020
idea was using qm e più test of the

00:07:15,150 --> 00:07:21,180
first 1 qm unit test i tried doing

00:07:18,020 --> 00:07:23,220
hacking up and adding a few things so

00:07:21,180 --> 00:07:26,039
that simple but i'm not sure about

00:07:23,220 --> 00:07:30,660
cutest i have to still look at that part

00:07:26,039 --> 00:07:34,949
of it the last one is Anton Blanchard

00:07:30,660 --> 00:07:38,280
has basically written the fuzzer so it

00:07:34,949 --> 00:07:39,840
would be something like like sagar

00:07:38,280 --> 00:07:45,599
explained i guess in the previous talk

00:07:39,840 --> 00:07:48,360
we're in like we have a real hardware

00:07:45,599 --> 00:07:52,860
power it hardware and and q mu TCG power

00:07:48,360 --> 00:07:55,110
8 so we run the stream of instructions

00:07:52,860 --> 00:07:57,570
on power it real hardware and the stream

00:07:55,110 --> 00:07:59,880
of instruction cumin TCG compared the

00:07:57,570 --> 00:08:03,419
results and we could find whether

00:07:59,880 --> 00:08:04,860
they're there correct or not the thing

00:08:03,419 --> 00:08:07,530
is we still don't have power line

00:08:04,860 --> 00:08:14,340
hardware so we can't do testing for this

00:08:07,530 --> 00:08:19,759
so that is one thing so the next thing

00:08:14,340 --> 00:08:23,690
is the power NV platform enablement so

00:08:19,759 --> 00:08:27,449
till now incur me what we have is

00:08:23,690 --> 00:08:31,139
basically the gist emulation so power

00:08:27,449 --> 00:08:34,140
would always run in guest mode so power

00:08:31,139 --> 00:08:36,959
n V stands for non virtualized so this

00:08:34,140 --> 00:08:37,779
is the new machine model that we are

00:08:36,959 --> 00:08:43,959
adding

00:08:37,779 --> 00:08:45,490
and to just to system elevation I think

00:08:43,959 --> 00:08:47,949
everyone knows but let's go through it

00:08:45,490 --> 00:08:50,499
so the system emulation the same TCG

00:08:47,949 --> 00:08:52,740
engine when when I combine with with the

00:08:50,499 --> 00:08:55,240
emulated devices and the soft mm you

00:08:52,740 --> 00:08:58,180
along with the guests firmware what i

00:08:55,240 --> 00:09:00,339
get is basically the new qmu house are

00:08:58,180 --> 00:09:02,920
called system Revelation where is like I

00:09:00,339 --> 00:09:05,769
can provide a machine whatever kind of

00:09:02,920 --> 00:09:08,529
machine that I have it runs it can run

00:09:05,769 --> 00:09:14,079
various different vm sin it's in its own

00:09:08,529 --> 00:09:17,499
isolated memory and it I can use that NT

00:09:14,079 --> 00:09:21,519
cg mode to debug my form where i can t

00:09:17,499 --> 00:09:23,410
bug the colonel so this is what I was

00:09:21,519 --> 00:09:26,829
talking about the pcj is machine

00:09:23,410 --> 00:09:29,019
emulation so the current qmu support

00:09:26,829 --> 00:09:31,149
that we have is for a p-series machine

00:09:29,019 --> 00:09:35,379
emulation wherein we have the TCG

00:09:31,149 --> 00:09:37,420
combined with slav the emulated vio mm

00:09:35,379 --> 00:09:41,290
maybe you and the interrupt controller a

00:09:37,420 --> 00:09:43,629
Malaysian + real-time abstraction layer

00:09:41,290 --> 00:09:46,509
so this all combined gives gives us a

00:09:43,629 --> 00:09:49,149
p-series machine emulation so this is

00:09:46,509 --> 00:09:53,649
basically based on the on the papr

00:09:49,149 --> 00:09:57,910
standard which defines the hypervisor to

00:09:53,649 --> 00:10:00,970
the guest interface so the p-series is

00:09:57,910 --> 00:10:04,029
basically hyper call based so this this

00:10:00,970 --> 00:10:06,819
has been there from last few years so

00:10:04,029 --> 00:10:09,910
the new thing is the power NB machine so

00:10:06,819 --> 00:10:16,059
it it basically emulates the bare bare

00:10:09,910 --> 00:10:19,990
metal power so and along with that we

00:10:16,059 --> 00:10:23,860
need the bare metal also has the BMC the

00:10:19,990 --> 00:10:27,579
board management controller the IP my so

00:10:23,860 --> 00:10:29,949
we need support for those things we also

00:10:27,579 --> 00:10:32,649
need also need to support hypervisor

00:10:29,949 --> 00:10:37,389
mode actually so till now as it was

00:10:32,649 --> 00:10:39,579
running only on only as a guest so we

00:10:37,389 --> 00:10:43,329
never had support hypervisor mode in

00:10:39,579 --> 00:10:45,309
Emily in TCG system emulation so the

00:10:43,329 --> 00:10:48,339
power and we patch has added X the

00:10:45,309 --> 00:10:50,130
hypervisor mode it can run nested guests

00:10:48,339 --> 00:10:53,820
basically so it will it can be

00:10:50,130 --> 00:10:56,340
you mowed and maybe who knows a PR

00:10:53,820 --> 00:10:58,380
inside HP so it will we can have three

00:10:56,340 --> 00:11:02,760
levels of means two levels of nesting on

00:10:58,380 --> 00:11:04,680
top of this so it basically assists in

00:11:02,760 --> 00:11:07,230
the early bring up of of the of the

00:11:04,680 --> 00:11:09,570
hardware so before we actually get the

00:11:07,230 --> 00:11:13,620
systems we can actually a week we can

00:11:09,570 --> 00:11:19,740
use power nvm elation to do all our

00:11:13,620 --> 00:11:23,910
driver testing yeah so the status right

00:11:19,740 --> 00:11:27,960
now is the it was initially done by Ben

00:11:23,910 --> 00:11:29,820
Haren Schmidt and our engineer for

00:11:27,960 --> 00:11:32,630
France called Roderick is basically

00:11:29,820 --> 00:11:35,700
developing pushing the patches so the

00:11:32,630 --> 00:11:39,270
around like 50 patches of our

00:11:35,700 --> 00:11:43,140
preparatory work for our power NB is

00:11:39,270 --> 00:11:45,060
already in some stage in either its

00:11:43,140 --> 00:11:48,390
upstream or it's in David's tree

00:11:45,060 --> 00:11:51,570
actually so as I said we added

00:11:48,390 --> 00:11:54,180
hypervisor special purpose registers and

00:11:51,570 --> 00:11:57,480
we split the instruction and the data

00:11:54,180 --> 00:12:02,610
caches so that we can we have better

00:11:57,480 --> 00:12:05,700
performance TLB flushes basically what

00:12:02,610 --> 00:12:08,730
used to happen was there there's to be

00:12:05,700 --> 00:12:13,590
TLB IE and SL bie and that used to come

00:12:08,730 --> 00:12:17,280
in batches so if if we go and do a TLB

00:12:13,590 --> 00:12:19,680
flush every time so it will be like them

00:12:17,280 --> 00:12:22,770
clear maybe 10 time or something like

00:12:19,680 --> 00:12:25,320
that so we batch them together and then

00:12:22,770 --> 00:12:28,980
that improve the performance of booting

00:12:25,320 --> 00:12:33,060
the booting the guest X ICS rework so

00:12:28,980 --> 00:12:35,250
because we are adding the native model

00:12:33,060 --> 00:12:39,660
we need the native interrupt controller

00:12:35,250 --> 00:12:42,090
support so that revoke some some portion

00:12:39,660 --> 00:12:47,280
of his upstream and stream some of them

00:12:42,090 --> 00:12:51,720
are still pending actually yep so this

00:12:47,280 --> 00:12:55,100
is something that I tried their patches

00:12:51,720 --> 00:12:58,230
floating around Alex when he had some

00:12:55,100 --> 00:13:01,890
enablement for multi-threaded TCG and I

00:12:58,230 --> 00:13:03,900
thought that let us give it a try so to

00:13:01,890 --> 00:13:07,410
explain how current system

00:13:03,900 --> 00:13:10,710
asian work is basically we run a

00:13:07,410 --> 00:13:14,340
multiprocessor we can actually start a

00:13:10,710 --> 00:13:16,850
guest with multiple CPUs but all the VC

00:13:14,340 --> 00:13:20,370
fuels are going to run serially and the

00:13:16,850 --> 00:13:22,620
emulation would happen serially so we

00:13:20,370 --> 00:13:25,800
cannot basically do the concurrent

00:13:22,620 --> 00:13:28,560
emulation basically we will not end up

00:13:25,800 --> 00:13:30,420
in a situation of that log or something

00:13:28,560 --> 00:13:35,460
like that in this kind of scenario so

00:13:30,420 --> 00:13:39,480
the multi-threaded TCG basically brings

00:13:35,460 --> 00:13:43,230
this feature where in like we can run be

00:13:39,480 --> 00:13:46,050
CPUs in the each CPUs and then basically

00:13:43,230 --> 00:13:49,500
we can do the multi-core bring up which

00:13:46,050 --> 00:13:53,250
would basically we can we can find out

00:13:49,500 --> 00:13:59,580
issues much before we actually go on to

00:13:53,250 --> 00:14:04,740
the hardware right so the 44 PP we see

00:13:59,580 --> 00:14:08,190
support I based on his latest patch

00:14:04,740 --> 00:14:12,450
cities v4 with atomic compare exchange

00:14:08,190 --> 00:14:15,000
patches and p series basically how we

00:14:12,450 --> 00:14:21,030
can we get we we have h co op h call

00:14:15,000 --> 00:14:23,940
based virtual machine so the edge call

00:14:21,030 --> 00:14:26,520
can actually return which can actually

00:14:23,940 --> 00:14:30,170
do I owe as well so we had to take a I

00:14:26,520 --> 00:14:32,910
of thread lock for forever eh call

00:14:30,170 --> 00:14:35,990
powerpc has load with reservation and

00:14:32,910 --> 00:14:39,710
store conditional which is used for

00:14:35,990 --> 00:14:42,330
atomic instructions so we had to write

00:14:39,710 --> 00:14:45,060
those we had to change those instruction

00:14:42,330 --> 00:14:48,780
basically to use our at me compare

00:14:45,060 --> 00:14:52,140
exchange microbes so I was able to boot

00:14:48,780 --> 00:14:54,350
a vm with 4 v cpus and did some testing

00:14:52,140 --> 00:14:56,610
with single threaded so i used to get

00:14:54,350 --> 00:14:58,230
single threaded runs with four thread

00:14:56,610 --> 00:15:00,990
was something like this and the

00:14:58,230 --> 00:15:07,980
multi-threaded that Iran was like around

00:15:00,990 --> 00:15:11,470
three dot 55 x kind of scenario so okay

00:15:07,980 --> 00:15:13,980
the problems is it's still unstable

00:15:11,470 --> 00:15:18,690
that there might be some issues that

00:15:13,980 --> 00:15:24,490
related to power or that I see that

00:15:18,690 --> 00:15:27,540
because we have the page table is owned

00:15:24,490 --> 00:15:31,660
by the hypervisor actually so we need to

00:15:27,540 --> 00:15:34,480
up TLB flush would come as a hyper hyper

00:15:31,660 --> 00:15:37,000
call h remove or something like that and

00:15:34,480 --> 00:15:40,060
it can come for one entry or it can come

00:15:37,000 --> 00:15:42,490
for bulk of entries so when that comes i

00:15:40,060 --> 00:15:45,160
have to make sure that all i remove them

00:15:42,490 --> 00:15:47,070
from all the cpus so I have some

00:15:45,160 --> 00:15:50,500
something working but it's still not

00:15:47,070 --> 00:15:53,130
functional yet so the other problems

00:15:50,500 --> 00:15:55,240
that I think could be memory barriers

00:15:53,130 --> 00:15:58,660
because of which I am seeing some

00:15:55,240 --> 00:16:00,760
crashes and next would be the current

00:15:58,660 --> 00:16:04,000
thing that I hacked was basically the

00:16:00,760 --> 00:16:06,990
p-series emulation so next would be to

00:16:04,000 --> 00:16:10,120
support power NV platform as well so

00:16:06,990 --> 00:16:13,980
moving on to the next thing is basically

00:16:10,120 --> 00:16:18,360
okay so there are multiple things that

00:16:13,980 --> 00:16:20,680
were posted so been helen smith has

00:16:18,360 --> 00:16:23,860
mostly doing a lot of surgery in the

00:16:20,680 --> 00:16:26,800
tcga of power recently and there are lot

00:16:23,860 --> 00:16:29,350
of load store improvements that he had

00:16:26,800 --> 00:16:32,560
done and then there were issues with

00:16:29,350 --> 00:16:36,310
exception handling so he has improved

00:16:32,560 --> 00:16:39,810
that I've started doing the load/store

00:16:36,310 --> 00:16:44,490
console consolidation so power did not

00:16:39,810 --> 00:16:46,900
use the Q mu load store my crops so it

00:16:44,490 --> 00:16:50,650
the newer my crops are that I would say

00:16:46,900 --> 00:16:56,800
so I'm doing that consolidation so going

00:16:50,650 --> 00:16:58,540
on to the next slide yep so future so we

00:16:56,800 --> 00:17:02,110
have lot of instructions that we need to

00:16:58,540 --> 00:17:05,110
add so that's that's a big piece of work

00:17:02,110 --> 00:17:09,340
that we need to make sure that we can

00:17:05,110 --> 00:17:11,050
get in and then testing those

00:17:09,340 --> 00:17:14,110
instruction is one of the one of the

00:17:11,050 --> 00:17:18,010
things up streaming power envy is an

00:17:14,110 --> 00:17:19,810
ongoing thing and I think maybe buy in

00:17:18,010 --> 00:17:24,670
to dot ate mostly we can get all the

00:17:19,810 --> 00:17:25,329
patches same future power line power and

00:17:24,670 --> 00:17:27,699
we support

00:17:25,329 --> 00:17:30,940
so we would like to have the system

00:17:27,699 --> 00:17:34,539
emulation of power 9 available so that

00:17:30,940 --> 00:17:37,720
we can do the testing early stabilize

00:17:34,539 --> 00:17:41,860
empty TCG that I was talking about back

00:17:37,720 --> 00:17:43,740
and 128-bit load store support in TCG in

00:17:41,860 --> 00:17:47,019
some way if you can if you can get that

00:17:43,740 --> 00:17:49,720
the load store in the vector loads would

00:17:47,019 --> 00:17:52,120
become very simple for us right now what

00:17:49,720 --> 00:17:53,880
we do is we we do lot of this in the in

00:17:52,120 --> 00:17:56,679
the helper routines most of the times

00:17:53,880 --> 00:17:59,049
and which we which would be slow and

00:17:56,679 --> 00:18:04,510
it's tedious to write those things there

00:17:59,049 --> 00:18:07,539
and yep testing mechanisms credits yep

00:18:04,510 --> 00:18:10,149
so range have been Harold fit so I'm

00:18:07,539 --> 00:18:13,840
representing work up for Ben and Cedric

00:18:10,149 --> 00:18:17,559
here as well thanks to Alexander graph

00:18:13,840 --> 00:18:20,289
he has a very nice presentation on TCG

00:18:17,559 --> 00:18:23,440
and Alex Benny's toward multiplayer TCG

00:18:20,289 --> 00:18:29,039
is that a present hit last night so with

00:18:23,440 --> 00:18:29,039
that I think yep said questions

00:18:30,919 --> 00:18:41,179
hi first of us more comment my name is

00:18:34,460 --> 00:18:42,379
alexander with annie is that okay and

00:18:41,179 --> 00:18:46,129
then have you have you heard of rizu

00:18:42,379 --> 00:18:49,129
okay today yeah I actually I you you

00:18:46,129 --> 00:18:51,710
told that in his stock so RI s you use a

00:18:49,129 --> 00:18:54,679
trick is you yes that's Alex's baby

00:18:51,710 --> 00:19:01,249
basically well it's both of yours right

00:18:54,679 --> 00:19:05,210
like you and Peter together yes come

00:19:01,249 --> 00:19:06,499
over come to the mic so it's recorded so

00:19:05,210 --> 00:19:08,230
oh it sounds very much like the

00:19:06,499 --> 00:19:10,249
instruction fuzzy mentioned but

00:19:08,230 --> 00:19:13,129
basically we used it when we did the a

00:19:10,249 --> 00:19:15,259
out 64 implementation and it does a

00:19:13,129 --> 00:19:16,789
similar thing you give it a bit bit

00:19:15,259 --> 00:19:18,830
pattern for a set of instructions it

00:19:16,789 --> 00:19:20,539
randomly generates the instructions and

00:19:18,830 --> 00:19:22,940
then you run it on something that you

00:19:20,539 --> 00:19:26,779
know is good and compare the trace with

00:19:22,940 --> 00:19:28,159
your emulations the problem as you noted

00:19:26,779 --> 00:19:29,629
did you need some hardware that you know

00:19:28,159 --> 00:19:31,429
it's good so when we first started we

00:19:29,629 --> 00:19:34,220
were using the arm foundation model

00:19:31,429 --> 00:19:35,659
which we knew was valid and then we were

00:19:34,220 --> 00:19:38,029
testing against crema and then when we

00:19:35,659 --> 00:19:39,679
finally got hardware we did that but it

00:19:38,029 --> 00:19:43,460
sounds like the instruction fuzzer does

00:19:39,679 --> 00:19:45,379
a similar sort of thing okay I bust them

00:19:43,460 --> 00:19:49,940
up here I won't but the problem with Q

00:19:45,379 --> 00:19:52,009
test which is a general problem we have

00:19:49,940 --> 00:19:54,859
for testing anything that's TCG related

00:19:52,009 --> 00:19:57,440
is when you want to compile stuff for a

00:19:54,859 --> 00:20:00,230
foreign architecture so you can test on

00:19:57,440 --> 00:20:02,989
the host architecture it gets tricky

00:20:00,230 --> 00:20:05,779
because you either have to assume what

00:20:02,989 --> 00:20:08,080
the cross compiler is cooled or test to

00:20:05,779 --> 00:20:11,629
see if there's a cross compiler there

00:20:08,080 --> 00:20:13,850
and it just doesn't work very well so it

00:20:11,629 --> 00:20:16,460
tends to bit wrong but there are some

00:20:13,850 --> 00:20:19,340
potential solutions we're looking at so

00:20:16,460 --> 00:20:22,100
you can build a docker image with linux

00:20:19,340 --> 00:20:24,259
user and then maybe we'll can set

00:20:22,100 --> 00:20:25,820
something up to do a cross compilation

00:20:24,259 --> 00:20:30,429
that work but no one's actually got that

00:20:25,820 --> 00:20:30,429
working it sorry

00:20:36,570 --> 00:20:41,669
a good

00:20:38,549 --> 00:20:41,669

YouTube URL: https://www.youtube.com/watch?v=lOOcCiGzpOY


