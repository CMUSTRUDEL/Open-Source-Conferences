Title: [2016] LinuxCon: Real-Time KVM by Rik van Riel
Publication date: 2016-09-08
Playlist: KVM Forum 2016
Description: 
	Linux and KVM can be used to obtain fast, real time response times inside virtual machines. This requires both changes to the software, and careful system configuration. This presentation will cover everything from common hardware pitfalls, to Linux kernel changes, to system configuration, and should be suitable for both Linux kernel developers and people deploying Linux. 

Rik van Riel
Principal Software Engineer, Red Hat

Rik van Riel is a principal software engineer at Red Hat, and a long term contributor to the Linux kernel. He has contributed to the memory management subsystem, the scheduler, and various components related to virtualization. Rik is active in community projects like kernelnewbies.org and likes to hike and rock climb in his spare time.

Slides: http://www.linux-kvm.org/images/d/d2/LC-Rick_van_Riel-Real-time_KVM.pdf
Captions: 
	00:00:10,550 --> 00:00:17,580
okay um welcome to this presentation I

00:00:13,830 --> 00:00:19,800
work with a loud guys over there and no

00:00:17,580 --> 00:00:23,220
and I've been working on the next kernel

00:00:19,800 --> 00:00:24,990
for a while and the past year or two one

00:00:23,220 --> 00:00:30,510
of the cool projects that I've been

00:00:24,990 --> 00:00:36,690
working on is real time a vm ware Louise

00:00:30,510 --> 00:00:40,760
and seven other people and when working

00:00:36,690 --> 00:00:45,090
on getting kvm to work or real-time

00:00:40,760 --> 00:00:49,020
response time now the first thing of

00:00:45,090 --> 00:00:52,680
course then a lot of people imagine they

00:00:49,020 --> 00:00:54,930
know what real time in and they tend to

00:00:52,680 --> 00:00:56,879
have it mostly right but there's a quick

00:00:54,930 --> 00:01:02,160
intro slide on there explaining what

00:00:56,879 --> 00:01:03,660
real time is and another issue that we

00:01:02,160 --> 00:01:07,470
see a lot of people with people trying

00:01:03,660 --> 00:01:10,350
to use real time is that they imagine

00:01:07,470 --> 00:01:12,810
that that computer just works and all

00:01:10,350 --> 00:01:16,740
they have to do is run special software

00:01:12,810 --> 00:01:18,780
we got real time unfortunately that is

00:01:16,740 --> 00:01:21,299
not always the case I'm also going to

00:01:18,780 --> 00:01:24,210
explain the hardware pitfalls in real

00:01:21,299 --> 00:01:28,950
time and going over what the real time

00:01:24,210 --> 00:01:31,110
preempt a linux kernel batches do we had

00:01:28,950 --> 00:01:34,590
to make a few changes into mu in the

00:01:31,110 --> 00:01:37,650
code it might not be as interesting at

00:01:34,590 --> 00:01:40,710
the sum of you and the configuration

00:01:37,650 --> 00:01:43,590
when it comes to real time a lot of the

00:01:40,710 --> 00:01:46,320
magic is not in the code but in the way

00:01:43,590 --> 00:01:50,360
the system is set up that will spend a

00:01:46,320 --> 00:01:50,360
fair amount of time in that and

00:01:50,750 --> 00:01:54,750
performance numbers are looking pretty

00:01:52,799 --> 00:01:59,490
good Lewis has been working really hard

00:01:54,750 --> 00:02:03,270
on keeping that when keeping nets from

00:01:59,490 --> 00:02:09,729
regressing and a pagina numbers better

00:02:03,270 --> 00:02:11,769
than we ever imagined well real time

00:02:09,729 --> 00:02:14,110
a lot of people imagine that real time

00:02:11,769 --> 00:02:17,319
is about speed something happens you

00:02:14,110 --> 00:02:20,370
need to react to it instantly and for

00:02:17,319 --> 00:02:27,400
some classes of real time that is

00:02:20,370 --> 00:02:31,000
absolutely true but or some things like

00:02:27,400 --> 00:02:33,849
audio processing don't times you care

00:02:31,000 --> 00:02:37,720
more about having super high average

00:02:33,849 --> 00:02:40,780
latency and if you have a little spike

00:02:37,720 --> 00:02:43,780
in your audio once a day that might be

00:02:40,780 --> 00:02:49,989
perfectly acceptable on the other hand

00:02:43,780 --> 00:02:51,819
if you are a phone company you might be

00:02:49,989 --> 00:02:56,769
fine with slightly higher average

00:02:51,819 --> 00:02:59,769
latency but the maximum latency that you

00:02:56,769 --> 00:03:02,890
have happened is absolutely the single

00:02:59,769 --> 00:03:08,069
most important thing out there because

00:03:02,890 --> 00:03:12,790
if you have 50 million customers and a

00:03:08,069 --> 00:03:16,120
hundred thousand of them had some

00:03:12,790 --> 00:03:18,880
artifacts in a voice breaking up every

00:03:16,120 --> 00:03:22,120
week or so they will switch the

00:03:18,880 --> 00:03:24,489
different zeljko you lose customers the

00:03:22,120 --> 00:03:26,819
maximum latency is much more important

00:03:24,489 --> 00:03:29,410
than the average latency for many cases

00:03:26,819 --> 00:03:34,660
dock trading has a similar thing where

00:03:29,410 --> 00:03:36,609
if you let requests by one customer get

00:03:34,660 --> 00:03:39,730
ahead of requests that were filed

00:03:36,609 --> 00:03:43,150
earlier by a different customer you

00:03:39,730 --> 00:03:47,139
might end up paying very large fine even

00:03:43,150 --> 00:03:49,840
if your violation of the rules was

00:03:47,139 --> 00:03:52,690
caused by a software bug and even if the

00:03:49,840 --> 00:03:56,410
software bug was created by somebody

00:03:52,690 --> 00:03:59,319
else like me and not by people at the

00:03:56,410 --> 00:04:01,810
trading firm the maximum latency again

00:03:59,319 --> 00:04:04,269
is super important there and the same is

00:04:01,810 --> 00:04:07,810
true for controlling vehicles like

00:04:04,269 --> 00:04:09,459
airplanes or rockets where if you have

00:04:07,810 --> 00:04:13,060
if you trying to launch your rocket into

00:04:09,459 --> 00:04:15,010
space and you waits for a little bit on

00:04:13,060 --> 00:04:19,120
garbage collection rocket will twist out

00:04:15,010 --> 00:04:20,769
of control 80 by somewhere else or if

00:04:19,120 --> 00:04:22,960
you the military your rocket might

00:04:20,769 --> 00:04:23,590
simply explode at a long time might as

00:04:22,960 --> 00:04:26,620
well not have X

00:04:23,590 --> 00:04:30,639
loaded at all in what on the target who

00:04:26,620 --> 00:04:34,380
cares and an applications may have many

00:04:30,639 --> 00:04:37,180
thousands of deadlines a second so we

00:04:34,380 --> 00:04:39,820
put a lot of markets telco and financial

00:04:37,180 --> 00:04:43,470
they want low latency on the order of a

00:04:39,820 --> 00:04:46,300
few dozen microseconds maximum latency

00:04:43,470 --> 00:04:49,120
it mayne mm any average latency may be a

00:04:46,300 --> 00:04:50,770
lot lower than that but let's not do

00:04:49,120 --> 00:04:53,020
important they care about the maximum

00:04:50,770 --> 00:04:56,380
latency and you care about knowing for

00:04:53,020 --> 00:05:00,250
sure that when a request comes in it is

00:04:56,380 --> 00:05:02,830
handled within from deadline it might be

00:05:00,250 --> 00:05:04,840
10 microseconds for some people it might

00:05:02,830 --> 00:05:07,600
be 50 microseconds for other speak for

00:05:04,840 --> 00:05:10,120
other people it might even be 200

00:05:07,600 --> 00:05:14,229
microseconds for some people as long as

00:05:10,120 --> 00:05:20,470
they know that every single time request

00:05:14,229 --> 00:05:25,120
is handled within that amount of time so

00:05:20,470 --> 00:05:27,669
if we compare the regular kernel or r l

00:05:25,120 --> 00:05:31,150
7 and with a real time tree and a kvm

00:05:27,669 --> 00:05:35,380
real-time tree then the regular colonel

00:05:31,150 --> 00:05:37,750
here is shown in red the regular kernel

00:05:35,380 --> 00:05:40,210
is a lot simpler than the realtime

00:05:37,750 --> 00:05:41,919
kernel butter most of the time the

00:05:40,210 --> 00:05:44,560
regular kernel is actually faster than a

00:05:41,919 --> 00:05:46,389
realtime kernel the average latency the

00:05:44,560 --> 00:05:49,169
minimum latency they'll be way down

00:05:46,389 --> 00:05:54,460
there they hidden behind a green graph

00:05:49,169 --> 00:05:56,800
but you can see few bikes in the red

00:05:54,460 --> 00:05:59,830
graph which are totally unacceptable to

00:05:56,800 --> 00:06:02,349
people who need real-time and the green

00:05:59,830 --> 00:06:05,470
and blue might be slightly higher on

00:06:02,349 --> 00:06:10,120
average than the average or for the

00:06:05,470 --> 00:06:13,300
normal kernel is the red graph but never

00:06:10,120 --> 00:06:15,580
having an acceptable latency spike is

00:06:13,300 --> 00:06:17,289
what real time is all about and while

00:06:15,580 --> 00:06:21,280
the green one is the realtime kernel

00:06:17,289 --> 00:06:23,710
running on bare metal the blue one is a

00:06:21,280 --> 00:06:25,599
realtime kernel running on top of kvm

00:06:23,710 --> 00:06:29,740
which runs on top of a realtime kernel

00:06:25,599 --> 00:06:33,130
on the actual machine Oh latency inside

00:06:29,740 --> 00:06:36,420
a virtual machine is obviously going to

00:06:33,130 --> 00:06:38,150
be higher than running on bare metal

00:06:36,420 --> 00:06:41,730
we have managed to keep the maximum

00:06:38,150 --> 00:06:48,510
latency in the system that at a level

00:06:41,730 --> 00:06:50,190
where people are happy with it now a lot

00:06:48,510 --> 00:06:52,620
of the issues there are actually in the

00:06:50,190 --> 00:06:54,150
hardware not in the software well for

00:06:52,620 --> 00:06:57,090
people who want these slides and they

00:06:54,150 --> 00:06:59,640
are available online both on the Linux

00:06:57,090 --> 00:07:01,800
Foundation website and on my own that

00:06:59,640 --> 00:07:06,240
you can just download them later on Avva

00:07:01,800 --> 00:07:09,450
mean full quality well the biggest

00:07:06,240 --> 00:07:12,140
problem as usual is the bios and all the

00:07:09,450 --> 00:07:14,120
different parts of the bios and

00:07:12,140 --> 00:07:18,630
specifically system management

00:07:14,120 --> 00:07:23,190
interrupts are a huge problem thumb

00:07:18,630 --> 00:07:26,250
hardware we have seen things like the

00:07:23,190 --> 00:07:28,470
processor gets too warm the bios traps

00:07:26,250 --> 00:07:31,560
the whole system in the system

00:07:28,470 --> 00:07:36,060
management mode and all of the CPUs in

00:07:31,560 --> 00:07:39,510
the system are stopped a no longer run

00:07:36,060 --> 00:07:42,480
the operating system and the bios will

00:07:39,510 --> 00:07:46,380
do something like increase the velocity

00:07:42,480 --> 00:07:50,690
of the fan and when it knows that the

00:07:46,380 --> 00:07:53,370
fan is now running faster or at least

00:07:50,690 --> 00:07:55,620
enough current has been sent to the fan

00:07:53,370 --> 00:07:58,260
of all the judgment changed etc etc that

00:07:55,620 --> 00:08:02,130
it will be running faster really soon at

00:07:58,260 --> 00:08:04,980
that point the bios will exit system

00:08:02,130 --> 00:08:06,750
memory system management mode and it

00:08:04,980 --> 00:08:11,760
will finally start running the operating

00:08:06,750 --> 00:08:15,540
system again and in some cases it can

00:08:11,760 --> 00:08:17,520
take several milliseconds but you may be

00:08:15,540 --> 00:08:18,750
running software that can handle every

00:08:17,520 --> 00:08:21,990
request that comes in in five

00:08:18,750 --> 00:08:23,760
microseconds but if your hardware every

00:08:21,990 --> 00:08:26,250
once in awhile goes on an extended

00:08:23,760 --> 00:08:30,330
vacation to change the speed of the CPU

00:08:26,250 --> 00:08:32,940
fan you are not going to be able to hit

00:08:30,330 --> 00:08:34,880
your 5 micro second response time you'll

00:08:32,940 --> 00:08:39,720
be waiting for several milliseconds

00:08:34,880 --> 00:08:43,560
though in this kind of a situation when

00:08:39,720 --> 00:08:47,340
the hardware is not cooperating you need

00:08:43,560 --> 00:08:49,070
to change settings in the bios or in

00:08:47,340 --> 00:08:50,600
some really bad cases

00:08:49,070 --> 00:08:52,240
you may have to put your system back in

00:08:50,600 --> 00:08:54,530
the box then it back for a refund

00:08:52,240 --> 00:08:57,440
because you are going to need a

00:08:54,530 --> 00:09:00,940
different piece of hardware then not all

00:08:57,440 --> 00:09:04,400
systems can handle really low latencies

00:09:00,940 --> 00:09:09,940
and when the hardware pitfall is out of

00:09:04,400 --> 00:09:13,150
the way the next pitfall is Linux itself

00:09:09,940 --> 00:09:18,350
linux like most other operating system

00:09:13,150 --> 00:09:21,950
also has sections in the code where the

00:09:18,350 --> 00:09:24,230
colonel it takes a lock and it goes off

00:09:21,950 --> 00:09:26,030
to do something and it does some more

00:09:24,230 --> 00:09:29,300
and it does some more stuff and

00:09:26,030 --> 00:09:32,840
eventually it releases the lock and at

00:09:29,300 --> 00:09:34,550
that point that cpu and start scheduling

00:09:32,840 --> 00:09:38,810
again and it can start doing other

00:09:34,550 --> 00:09:44,360
things and it works really well for most

00:09:38,810 --> 00:09:48,260
use cases but sometimes the particular

00:09:44,360 --> 00:09:50,930
lock where for a particular other former

00:09:48,260 --> 00:09:54,500
critical section where preemption is

00:09:50,930 --> 00:10:00,460
disabled interrupts are disabled it can

00:09:54,500 --> 00:10:04,010
cause Layton sees and only after

00:10:00,460 --> 00:10:08,450
critical section is over can you run

00:10:04,010 --> 00:10:10,250
your real time program though people

00:10:08,450 --> 00:10:12,110
have been working on resolving that

00:10:10,250 --> 00:10:14,630
issue by making the critical section

00:10:12,110 --> 00:10:17,000
shorter and by changing the way locking

00:10:14,630 --> 00:10:18,500
is done in the colonel if entrusted over

00:10:17,000 --> 00:10:23,030
there has been working on that for years

00:10:18,500 --> 00:10:24,890
and as a result linux actually works

00:10:23,030 --> 00:10:27,370
really well as a real-time operating

00:10:24,890 --> 00:10:27,370
system

00:10:27,889 --> 00:10:38,720
it's in there and yeah go ahead so the

00:10:37,069 --> 00:10:42,079
loader is the main reason why they don't

00:10:38,720 --> 00:10:46,249
take the tunnels of hatch basically

00:10:42,079 --> 00:10:49,160
bigger like 3am party Oh a lot of the a

00:10:46,249 --> 00:10:51,369
lot of priam party code is already in

00:10:49,160 --> 00:10:54,290
the upstream colonel yes that's a

00:10:51,369 --> 00:10:56,540
desktop right and they're they're slowly

00:10:54,290 --> 00:11:00,019
going in bit by bit maybe stephen has

00:10:56,540 --> 00:11:02,389
some more info on i-20 reason why what

00:11:00,019 --> 00:11:04,519
we doing there's a lot of our things

00:11:02,389 --> 00:11:08,299
that are designed and Colonel right now

00:11:04,519 --> 00:11:10,160
that that we have worked around sport

00:11:08,299 --> 00:11:11,720
but to us those were drugs are not good

00:11:10,160 --> 00:11:13,669
enough to go upstream we actually have

00:11:11,720 --> 00:11:15,889
to go in and redesigns parts of the code

00:11:13,669 --> 00:11:17,359
within systems like hot plug right now

00:11:15,889 --> 00:11:19,189
he is ugly mess and we're those

00:11:17,359 --> 00:11:21,019
different invest but no one wants to

00:11:19,189 --> 00:11:21,730
touch it so we actually have to go when

00:11:21,019 --> 00:11:23,769
you

00:11:21,730 --> 00:11:26,110
and everyone be happy we going to fix

00:11:23,769 --> 00:11:28,360
hot-plug you saw a lot of other problems

00:11:26,110 --> 00:11:29,560
on 10 it makes real time work so

00:11:28,360 --> 00:11:31,779
basically there's a lot of issues

00:11:29,560 --> 00:11:33,279
throughout the kernel that we have built

00:11:31,779 --> 00:11:35,560
and passion to work around support those

00:11:33,279 --> 00:11:37,329
are not was a work night so where'd you

00:11:35,560 --> 00:11:39,190
although we can still get the same as oh

00:11:37,329 --> 00:11:41,860
they're not going to be attainable for

00:11:39,190 --> 00:11:44,050
long run so what we have hi are for what

00:11:41,860 --> 00:11:46,240
goes into the currently so we're kicking

00:11:44,050 --> 00:11:48,190
things off slowly but there's like lots

00:11:46,240 --> 00:11:49,779
of little things in each time so so

00:11:48,190 --> 00:11:52,209
that's why the colonel for last year's

00:11:49,779 --> 00:11:59,649
being becoming much better by the

00:11:52,209 --> 00:12:02,320
real-time fashions work but and as you

00:11:59,649 --> 00:12:05,199
can see a lot of the real-time stuff is

00:12:02,320 --> 00:12:07,329
already upstream then the real-time

00:12:05,199 --> 00:12:09,670
scheduling policies in the linux kernel

00:12:07,329 --> 00:12:12,279
and having support for Colonel

00:12:09,670 --> 00:12:15,130
preemption priority inherence mute

00:12:12,279 --> 00:12:17,050
excess of going to that in a bit high

00:12:15,130 --> 00:12:20,920
resolution timer came from the real-time

00:12:17,050 --> 00:12:23,850
project long ago in Linux if you wanted

00:12:20,920 --> 00:12:26,589
to leave for a certain amount of time

00:12:23,850 --> 00:12:29,350
you only could get woken up when there

00:12:26,589 --> 00:12:32,829
was a timer tick and now with the high

00:12:29,350 --> 00:12:35,410
resolution timers you can flip or an

00:12:32,829 --> 00:12:38,170
arbitrary amount of time you can waken

00:12:35,410 --> 00:12:41,079
up in between one time rejection

00:12:38,170 --> 00:12:42,760
happening by resistant programming a

00:12:41,079 --> 00:12:47,230
timer to wake up at just the right

00:12:42,760 --> 00:12:49,930
moment and pin lock annotation is a big

00:12:47,230 --> 00:12:52,810
thing that went upstream nodes full mode

00:12:49,930 --> 00:12:55,260
is upstream but some of the last bits of

00:12:52,810 --> 00:12:58,029
full real-time preemption are still in a

00:12:55,260 --> 00:13:02,440
separate tree and bit by bit they are

00:12:58,029 --> 00:13:04,560
going upstream a goal of the project is

00:13:02,440 --> 00:13:09,459
to make sure that all the real time code

00:13:04,560 --> 00:13:13,540
ends up in the upstream kernel and that

00:13:09,459 --> 00:13:16,720
all the remaining critical sections in

00:13:13,540 --> 00:13:25,180
Colonel execution are either preempted

00:13:16,720 --> 00:13:27,279
or very very very short and well the

00:13:25,180 --> 00:13:29,589
biggest goal of course in a real-time

00:13:27,279 --> 00:13:33,960
system is to have the highest priority

00:13:29,589 --> 00:13:36,530
task run right when it wants to run

00:13:33,960 --> 00:13:40,500
that waiting on anything else who

00:13:36,530 --> 00:13:41,700
finished doing what it is doing which

00:13:40,500 --> 00:13:45,390
could be things like lower priority

00:13:41,700 --> 00:13:49,170
tasks it could be spin locks it could be

00:13:45,390 --> 00:13:51,510
interrupt or it could be interrupt being

00:13:49,170 --> 00:13:53,730
blocked and stopping the timer from

00:13:51,510 --> 00:13:57,540
coming in and waking up your high

00:13:53,730 --> 00:14:02,580
priority task how does it do all of

00:13:57,540 --> 00:14:05,040
those things one of them go ahead so

00:14:02,580 --> 00:14:07,410
I'll talk about the real contact in the

00:14:05,040 --> 00:14:09,360
linux kernel go see you mention i feel

00:14:07,410 --> 00:14:12,000
very short time do you have like stuff

00:14:09,360 --> 00:14:14,510
got a cheap shot primerica okay gimme

00:14:12,000 --> 00:14:17,840
gimme on machinima it won't

00:14:14,510 --> 00:14:20,150
take up to a threshold will have some

00:14:17,840 --> 00:14:23,090
irregularities your chips on tour its

00:14:20,150 --> 00:14:25,310
just oh and hopefully pass the local

00:14:23,090 --> 00:14:28,490
native a personal farm is where shot or

00:14:25,310 --> 00:14:33,620
menu at one now the measurement is done

00:14:28,490 --> 00:14:36,110
at a hundred percent but in that I had

00:14:33,620 --> 00:14:37,880
to also have to be honest in that we

00:14:36,110 --> 00:14:41,150
cannot measure every possible thing that

00:14:37,880 --> 00:14:42,470
everybody would like to do though there

00:14:41,150 --> 00:14:45,230
are certain things that have been

00:14:42,470 --> 00:14:50,270
measured and we make sure that they

00:14:45,230 --> 00:14:53,390
remain fast and typical test run is 24

00:14:50,270 --> 00:14:59,450
hours where we're in a particular test

00:14:53,390 --> 00:15:01,840
and we do not allow any latency over

00:14:59,450 --> 00:15:04,130
threshold within the 24 hour period

00:15:01,840 --> 00:15:07,160
that's not just a ninety nine hundred

00:15:04,130 --> 00:15:08,980
ninety-nine point nine percent guarantee

00:15:07,160 --> 00:15:17,960
we want it to be a hundred percent

00:15:08,980 --> 00:15:19,880
guarantee and well one of the big things

00:15:17,960 --> 00:15:23,810
that has me down is changing spin locks

00:15:19,880 --> 00:15:25,670
into priority inherited mutex though

00:15:23,810 --> 00:15:30,110
everything that is a spin lock in a

00:15:25,670 --> 00:15:33,940
normal kernel and held by a cpu is now a

00:15:30,110 --> 00:15:36,530
sleeping lock that is held by a desk and

00:15:33,940 --> 00:15:41,510
a few data structures are still

00:15:36,530 --> 00:15:44,540
classical spin locks because you need

00:15:41,510 --> 00:15:46,400
things like the scheduler who be able

00:15:44,540 --> 00:15:48,650
and the timer interrupts to be able to

00:15:46,400 --> 00:15:51,640
wake up desk and manage the data

00:15:48,650 --> 00:15:54,260
structures we're running tasks are

00:15:51,640 --> 00:15:57,050
fitting and those need to be still

00:15:54,260 --> 00:15:58,730
classical spin locks we use it also

00:15:57,050 --> 00:16:03,920
called raw spin locks and if you look in

00:15:58,730 --> 00:16:06,410
the kernel you can see some places or

00:16:03,920 --> 00:16:08,840
spin lock particular lock in other

00:16:06,410 --> 00:16:10,370
places michael ross pin lock off a

00:16:08,840 --> 00:16:14,210
locked it was declared as a raw spin

00:16:10,370 --> 00:16:16,790
look in a normal colonel these two are

00:16:14,210 --> 00:16:19,010
exactly the same in a preemptory of time

00:16:16,790 --> 00:16:22,160
colonel they are totally different looks

00:16:19,010 --> 00:16:24,050
and a lot of the annotation of the locks

00:16:22,160 --> 00:16:26,330
is already upstream and you may wonder

00:16:24,050 --> 00:16:28,000
hey why why are these two locks named

00:16:26,330 --> 00:16:30,940
differently when they do the same thing

00:16:28,000 --> 00:16:32,320
in a regular kernel and well now you

00:16:30,940 --> 00:16:35,830
know that they are totally different in

00:16:32,320 --> 00:16:39,010
a realtime kernel a big thing is

00:16:35,830 --> 00:16:41,260
priority inheritance where you might

00:16:39,010 --> 00:16:46,630
have three tasks running on a particular

00:16:41,260 --> 00:16:48,130
CPU you have a low priority task that it

00:16:46,630 --> 00:16:51,700
does something and it grabs a lock in

00:16:48,130 --> 00:16:53,650
the kernel and then it gets preempted

00:16:51,700 --> 00:16:57,180
because you have a slightly higher

00:16:53,650 --> 00:16:59,620
priority program that wants to run and

00:16:57,180 --> 00:17:02,110
Anna medium priority program gets

00:16:59,620 --> 00:17:05,319
interrupted again when your highest

00:17:02,110 --> 00:17:08,020
priority program in the system wants to

00:17:05,319 --> 00:17:11,500
run and it's at highest priority program

00:17:08,020 --> 00:17:14,800
now once the lock it needs to wait for a

00:17:11,500 --> 00:17:17,500
lower priority program who maybe at some

00:17:14,800 --> 00:17:21,010
point in the future run and release that

00:17:17,500 --> 00:17:23,589
look that's a problem with real-time and

00:17:21,010 --> 00:17:27,490
that is fixed with something called

00:17:23,589 --> 00:17:32,050
priority inheritance where the highest

00:17:27,490 --> 00:17:35,260
priority program waiting on a lock will

00:17:32,050 --> 00:17:38,260
temporarily give its priority with the

00:17:35,260 --> 00:17:40,810
program that is holding the lock and a

00:17:38,260 --> 00:17:43,660
program that is holding the lock can n

00:17:40,810 --> 00:17:46,660
keep that high priority until the lock

00:17:43,660 --> 00:17:49,210
is released and then immediately the

00:17:46,660 --> 00:17:52,240
higher priority program will grab the

00:17:49,210 --> 00:17:55,180
lock and continue running on its own

00:17:52,240 --> 00:17:59,710
thing and this is something that really

00:17:55,180 --> 00:18:01,570
helps a lot and allows the people on

00:17:59,710 --> 00:18:05,560
bare metal real time to keep their

00:18:01,570 --> 00:18:10,450
Layton sees um single-digit microsecond

00:18:05,560 --> 00:18:15,010
in every single case another thing that

00:18:10,450 --> 00:18:18,400
helps with that is RCU is no longer

00:18:15,010 --> 00:18:21,400
something that stops things deepu's from

00:18:18,400 --> 00:18:25,120
scheduling tasks from scheduling most

00:18:21,400 --> 00:18:27,160
interrupts are run in threads that can

00:18:25,120 --> 00:18:33,220
be preempted when something else needs

00:18:27,160 --> 00:18:34,990
to run well hardware real-time is pretty

00:18:33,220 --> 00:18:37,960
complicated once you add in

00:18:34,990 --> 00:18:40,250
virtualization and gets slightly harder

00:18:37,960 --> 00:18:42,010
and Louisa

00:18:40,250 --> 00:18:48,070
I have been working on that for the past

00:18:42,010 --> 00:18:52,550
year or two but we've got it working and

00:18:48,070 --> 00:18:57,460
some of the issues are that things like

00:18:52,550 --> 00:19:01,430
priority that inheritance do not work

00:18:57,460 --> 00:19:06,680
between a guest in a host because if you

00:19:01,430 --> 00:19:08,810
have your virtual machine it may have a

00:19:06,680 --> 00:19:12,130
certain real-time priority you may give

00:19:08,810 --> 00:19:15,500
it priority to for example in the host

00:19:12,130 --> 00:19:18,890
inside the virtual machine you might

00:19:15,500 --> 00:19:20,960
have programs of various real-time

00:19:18,890 --> 00:19:23,060
priorities running there might be

00:19:20,960 --> 00:19:25,520
something with Priority One nothing is

00:19:23,060 --> 00:19:30,230
priority to nothing with priority three

00:19:25,520 --> 00:19:34,370
and it doesn't help because the host has

00:19:30,230 --> 00:19:37,400
no idea which of reversal CPUs in a

00:19:34,370 --> 00:19:42,010
guest is running the highest priority

00:19:37,400 --> 00:19:44,150
program it's not visible to the home and

00:19:42,010 --> 00:19:47,330
we have thought about making it visible

00:19:44,150 --> 00:19:51,290
to the host but it's not something we

00:19:47,330 --> 00:19:55,790
can actually do because if you are

00:19:51,290 --> 00:19:59,120
running a virtual CPU with a lower

00:19:55,790 --> 00:20:01,520
priority program and host decides to run

00:19:59,120 --> 00:20:04,010
something else and at some point a

00:20:01,520 --> 00:20:08,270
higher priority program have become

00:20:04,010 --> 00:20:10,850
Furnival on that real-time virtual CPU

00:20:08,270 --> 00:20:12,800
that is now not running then we cannot

00:20:10,850 --> 00:20:14,720
inform the host that we now have a

00:20:12,800 --> 00:20:18,200
higher priority same until it is running

00:20:14,720 --> 00:20:20,120
again so they can have a chicken and egg

00:20:18,200 --> 00:20:22,280
thing and we came up we had to come up

00:20:20,120 --> 00:20:25,360
with a totally different solution or

00:20:22,280 --> 00:20:28,370
real-time virtualization and

00:20:25,360 --> 00:20:32,920
housekeeping tasks that might take two

00:20:28,370 --> 00:20:35,690
microseconds in bare metal real time in

00:20:32,920 --> 00:20:39,020
a virtual machine they might take a

00:20:35,690 --> 00:20:41,500
whole lot longer first because when the

00:20:39,020 --> 00:20:43,880
guests does that housekeeping thing

00:20:41,500 --> 00:20:48,320
instead of writing to a single hardware

00:20:43,880 --> 00:20:50,060
register you may end up first trying to

00:20:48,320 --> 00:20:52,340
write to a hardware register

00:20:50,060 --> 00:20:55,820
and the CPU realizes hey I am

00:20:52,340 --> 00:20:58,310
virtualized I cannot do this it traps

00:20:55,820 --> 00:21:01,790
into the host the host has to emulate

00:20:58,310 --> 00:21:03,770
what is going on buffer and then after

00:21:01,790 --> 00:21:07,760
everything is done the host can return

00:21:03,770 --> 00:21:12,590
into the guest is it not too bad but

00:21:07,760 --> 00:21:15,440
then what if the host due to bad luck

00:21:12,590 --> 00:21:19,610
also tries to do the same housekeeping

00:21:15,440 --> 00:21:22,670
task itself and a host and guest both do

00:21:19,610 --> 00:21:25,940
the same to micro second thing it takes

00:21:22,670 --> 00:21:27,590
for micro seconds in the guests the host

00:21:25,940 --> 00:21:29,120
adds its own two microseconds as soon

00:21:27,590 --> 00:21:31,750
when you're looking at a 6 micro second

00:21:29,120 --> 00:21:34,730
thing or something he used to take two

00:21:31,750 --> 00:21:38,690
but over a number of issues there where

00:21:34,730 --> 00:21:40,880
we had to redo or change the way that

00:21:38,690 --> 00:21:43,010
housekeeping tasking a kernel are done

00:21:40,880 --> 00:21:45,200
because we do not want the host and the

00:21:43,010 --> 00:21:47,900
guest doing the same thing at the same

00:21:45,200 --> 00:21:50,090
time and we'd rather not have to not do

00:21:47,900 --> 00:21:53,180
that at all the some of the issues that

00:21:50,090 --> 00:21:55,160
were not an issue at all or bare metal

00:21:53,180 --> 00:22:01,730
real time they became problems for us

00:21:55,160 --> 00:22:04,910
and we had to solve those oh and there

00:22:01,730 --> 00:22:07,460
was one other thing and when you're

00:22:04,910 --> 00:22:11,870
running on hardware and you have a low

00:22:07,460 --> 00:22:14,480
priority program that does anything you

00:22:11,870 --> 00:22:18,260
can always interrupt it bring your

00:22:14,480 --> 00:22:19,820
higher higher priority program inside a

00:22:18,260 --> 00:22:24,260
virtual machine this does not always

00:22:19,820 --> 00:22:28,100
work because you may have done program

00:22:24,260 --> 00:22:32,900
in your virtual machine that place the

00:22:28,100 --> 00:22:36,770
right to the graphics card and the

00:22:32,900 --> 00:22:40,400
graphics card is emulated by piece of

00:22:36,770 --> 00:22:46,820
software running in user space on the

00:22:40,400 --> 00:22:52,040
host and a Malaysian can be slow on time

00:22:46,820 --> 00:22:55,400
and it's possible for a program running

00:22:52,040 --> 00:22:58,730
on a real-time virtual machine the start

00:22:55,400 --> 00:23:01,580
and operation it has to be finished on a

00:22:58,730 --> 00:23:03,370
different CPU on the host by a different

00:23:01,580 --> 00:23:05,870
thread running there

00:23:03,370 --> 00:23:09,230
running on a cpu that might also have

00:23:05,870 --> 00:23:11,780
something higher priority on it and if

00:23:09,230 --> 00:23:14,770
you have something like a program

00:23:11,780 --> 00:23:17,870
writing to a graphics card inside guests

00:23:14,770 --> 00:23:20,930
that could prevent that virtual CPU from

00:23:17,870 --> 00:23:26,120
doing anything else or hundreds of micro

00:23:20,930 --> 00:23:27,530
second though we've had we find a

00:23:26,120 --> 00:23:31,160
solution for that and we'll get to that

00:23:27,530 --> 00:23:37,150
in a bit we made a few colonel changes

00:23:31,160 --> 00:23:39,860
to a real time to make stuff work right

00:23:37,150 --> 00:23:42,110
we're some small bugs in the real time

00:23:39,860 --> 00:23:46,040
code that really were not an issue or

00:23:42,110 --> 00:23:49,010
bare metal real time things like having

00:23:46,040 --> 00:23:50,540
the scheduler tick still enabled when

00:23:49,010 --> 00:23:54,020
you have one high priority and one low

00:23:50,540 --> 00:23:56,300
priority real time and every millisecond

00:23:54,020 --> 00:23:58,280
the colonel looks well do I want to

00:23:56,300 --> 00:23:59,990
reschedule look I'm running something

00:23:58,280 --> 00:24:03,500
real time and the other thing is low

00:23:59,990 --> 00:24:07,190
priority and every micro second it does

00:24:03,500 --> 00:24:10,340
that it's perfectly fine if you run one

00:24:07,190 --> 00:24:14,450
kernel on bare metal it's not perfectly

00:24:10,340 --> 00:24:17,000
fine if you have a virtual machine and a

00:24:14,450 --> 00:24:19,880
host both doing that thing at the same

00:24:17,000 --> 00:24:23,570
time a thousand times a second and some

00:24:19,880 --> 00:24:26,600
other small changes to make to this make

00:24:23,570 --> 00:24:28,280
stuff work right we're having the

00:24:26,600 --> 00:24:36,490
hosting a guest do stuff at the same

00:24:28,280 --> 00:24:39,170
time cost issues priority inversion

00:24:36,490 --> 00:24:41,900
inheritance they simply do not work in a

00:24:39,170 --> 00:24:43,760
virtual environment because we have a

00:24:41,900 --> 00:24:47,290
relatively clean abstraction between a

00:24:43,760 --> 00:24:50,720
host and a guest and host cannot see

00:24:47,290 --> 00:24:53,090
whether a guest is running something

00:24:50,720 --> 00:24:54,740
really important or whether it is

00:24:53,090 --> 00:25:01,730
running the idle threat and it was

00:24:54,740 --> 00:25:05,500
started with idle this ball and we also

00:25:01,730 --> 00:25:08,540
run into the issue if we do not know

00:25:05,500 --> 00:25:13,490
what the highest priority thing on a

00:25:08,540 --> 00:25:16,640
particular CPU is that means we do not

00:25:13,490 --> 00:25:18,290
know whether if

00:25:16,640 --> 00:25:20,780
you'll see p you should be interrupted

00:25:18,290 --> 00:25:23,570
for a higher priority thing on the host

00:25:20,780 --> 00:25:26,120
or whether the virtual CPU will ever

00:25:23,570 --> 00:25:28,250
stop running and we will finally get to

00:25:26,120 --> 00:25:33,260
run the lower priority thing on the same

00:25:28,250 --> 00:25:35,150
physical cpu in a host and and if we

00:25:33,260 --> 00:25:37,190
kind of do real-time scheduling because

00:25:35,150 --> 00:25:40,460
we do not know the priority of one of

00:25:37,190 --> 00:25:44,840
the things on a particular cpu then we

00:25:40,460 --> 00:25:47,540
need a different solution and pollution

00:25:44,840 --> 00:25:51,560
for that is to do some form of

00:25:47,540 --> 00:25:55,820
partitioning where the virtual CPUs that

00:25:51,560 --> 00:25:59,350
run real time tasks of a guest have to

00:25:55,820 --> 00:26:05,120
run on what is essentially a dedicated

00:25:59,350 --> 00:26:08,960
physical CPU the host we boot the host

00:26:05,120 --> 00:26:11,630
with ISIL CPUs and no hurtsfoe that

00:26:08,960 --> 00:26:18,730
means we do not get timer interrupts on

00:26:11,630 --> 00:26:18,730
those CPUs when the guest is running and

00:26:19,270 --> 00:26:25,550
most of the colonel housekeeping tasks

00:26:22,370 --> 00:26:31,010
that it normally does on a cpu things

00:26:25,550 --> 00:26:32,930
like RCU callbacks and various other

00:26:31,010 --> 00:26:35,750
random things and offloaded the

00:26:32,930 --> 00:26:38,390
housekeeping cpus and we have as few

00:26:35,750 --> 00:26:42,710
interruptions as possible or are real

00:26:38,390 --> 00:26:46,130
time and he use and the interruptions

00:26:42,710 --> 00:26:49,820
that are remaining they have passed our

00:26:46,130 --> 00:26:58,580
test as being short enough that they do

00:26:49,820 --> 00:27:01,700
not inhibit the latency Oh what it looks

00:26:58,580 --> 00:27:04,000
like is no go ahead for the previous

00:27:01,700 --> 00:27:04,000
slice

00:27:04,290 --> 00:27:11,230
the road hockey be a Manzo the jailhouse

00:27:07,830 --> 00:27:15,550
um the difference between real-time kvm

00:27:11,230 --> 00:27:18,550
in jail house is mostly that Hill House

00:27:15,550 --> 00:27:22,000
aims for pretty small code base and

00:27:18,550 --> 00:27:24,730
limited functionality and we try to be

00:27:22,000 --> 00:27:26,860
able to just run everything with the

00:27:24,730 --> 00:27:31,510
same code base that is also used

00:27:26,860 --> 00:27:34,600
elsewhere and I don't know exactly if

00:27:31,510 --> 00:27:36,010
there are functionality gaps between it

00:27:34,600 --> 00:27:40,840
to for what people are actually using

00:27:36,010 --> 00:27:43,210
them for I do know that with red hat for

00:27:40,840 --> 00:27:46,570
example we would like to support one

00:27:43,210 --> 00:27:49,000
code base and not have two different

00:27:46,570 --> 00:27:51,610
code bases and maybe have different

00:27:49,000 --> 00:27:55,330
security issues that we need to track in

00:27:51,610 --> 00:27:57,940
both we have just one solution and one

00:27:55,330 --> 00:28:00,820
piece of code we can make sure that the

00:27:57,940 --> 00:28:05,080
real time people get the same level of

00:28:00,820 --> 00:28:07,150
support that everybody else gets and if

00:28:05,080 --> 00:28:09,280
we have a totally separate code based

00:28:07,150 --> 00:28:11,380
and it will probably get less developer

00:28:09,280 --> 00:28:14,200
attention and you will not be able to

00:28:11,380 --> 00:28:17,620
look after it as well as having just one

00:28:14,200 --> 00:28:20,200
code base for everybody can you support

00:28:17,620 --> 00:28:25,900
multiple position real Travis is also

00:28:20,200 --> 00:28:29,320
staying safe you know there if you need

00:28:25,900 --> 00:28:32,200
if you always need low latency within

00:28:29,320 --> 00:28:37,990
one guest you need to make sure that all

00:28:32,200 --> 00:28:43,170
the virtual abuse of each guest are on

00:28:37,990 --> 00:28:46,860
different physical CPUs and you could

00:28:43,170 --> 00:28:50,050
hear a physical cpu with a non real-time

00:28:46,860 --> 00:28:55,090
guest on the host site if you wanted to

00:28:50,050 --> 00:28:59,110
but at that point if the real time guest

00:28:55,090 --> 00:29:02,170
misbehaved then the other guests could

00:28:59,110 --> 00:29:04,410
see CPU starvation but may not be worth

00:29:02,170 --> 00:29:04,410
doing

00:29:05,950 --> 00:29:13,370
if you have a funny or visit you you

00:29:08,899 --> 00:29:17,120
know has case like yeah if all the stars

00:29:13,370 --> 00:29:19,580
amidst issues yeah but in real time you

00:29:17,120 --> 00:29:25,750
could starve another fee cpu forever a

00:29:19,580 --> 00:29:28,279
lower priority thing um oh this is one

00:29:25,750 --> 00:29:31,820
possible configuration other ways to do

00:29:28,279 --> 00:29:34,370
it and with newer intel cpus you do not

00:29:31,820 --> 00:29:36,890
have to partition things on a on a

00:29:34,370 --> 00:29:38,840
socket basis at all because they have a

00:29:36,890 --> 00:29:43,659
technology that will get into later they

00:29:38,840 --> 00:29:43,659
can partition the cash inside a socket

00:29:43,750 --> 00:29:52,340
um well inside the guest we have similar

00:29:47,809 --> 00:29:56,140
issues where if you have a task inside a

00:29:52,340 --> 00:29:58,159
virtual CPU in a virtual machine that

00:29:56,140 --> 00:30:01,690
does something that it should not be

00:29:58,159 --> 00:30:06,020
doing like writing to a serial port or

00:30:01,690 --> 00:30:10,340
vga card you can get you can hit a code

00:30:06,020 --> 00:30:11,960
path that has very slow emulation and at

00:30:10,340 --> 00:30:14,870
that point you cannot run your high

00:30:11,960 --> 00:30:19,610
priority real time task until the slow a

00:30:14,870 --> 00:30:21,169
malaysian has finished though we need

00:30:19,610 --> 00:30:27,169
the same kind of partitioning inside a

00:30:21,169 --> 00:30:31,039
guest as well but the guest we also boot

00:30:27,169 --> 00:30:33,799
with ISIL cpus the real time tasks run

00:30:31,039 --> 00:30:36,679
on the isolated cpus and everything else

00:30:33,799 --> 00:30:40,159
runs on the system cpus inside the

00:30:36,679 --> 00:30:41,630
guests and i'm sure i could come up with

00:30:40,159 --> 00:30:46,460
a really confusing graphic that shows

00:30:41,630 --> 00:30:48,830
both in one but i did not do that well

00:30:46,460 --> 00:30:52,159
performance numbers how well does it

00:30:48,830 --> 00:30:56,480
actually work kind of a complicated

00:30:52,159 --> 00:31:03,080
thing but on the other hand modern CPUs

00:30:56,480 --> 00:31:07,520
have a lot of course and both intel and

00:31:03,080 --> 00:31:11,559
AMD have produced EP use where if you

00:31:07,520 --> 00:31:14,179
were to run every single core in a

00:31:11,559 --> 00:31:16,850
system or every single core in in a

00:31:14,179 --> 00:31:18,800
particular cpu at full power at the same

00:31:16,850 --> 00:31:22,940
time cpu

00:31:18,800 --> 00:31:24,950
would catch fire though it looks very

00:31:22,940 --> 00:31:29,000
wasteful to have dedicated course for

00:31:24,950 --> 00:31:31,670
real time but on most of the really

00:31:29,000 --> 00:31:34,040
modern the newer CPUs you could not run

00:31:31,670 --> 00:31:36,620
everything at full power simultaneously

00:31:34,040 --> 00:31:39,560
anyway you don't have the resources you

00:31:36,620 --> 00:31:42,140
think you have though it's it's not as

00:31:39,560 --> 00:31:45,100
bad as it looks and rescheduling

00:31:42,140 --> 00:31:47,210
latencies that we have measured and I

00:31:45,100 --> 00:31:49,330
think some things that Lewis did

00:31:47,210 --> 00:31:52,940
actually brought the maximum down to 13

00:31:49,330 --> 00:31:56,210
microsecond and the average is just a

00:31:52,940 --> 00:31:58,130
few microseconds you know if the new

00:31:56,210 --> 00:32:00,370
numbers are much better than this or

00:31:58,130 --> 00:32:00,370
similar

00:32:09,700 --> 00:32:29,690
so yeah well numbers have gotten a

00:32:12,140 --> 00:32:32,710
little bit better well it's very

00:32:29,690 --> 00:32:35,540
hardware dependent and it's easy to

00:32:32,710 --> 00:32:38,000
accidentally run into some kind of BIOS

00:32:35,540 --> 00:32:40,370
code it will give you 100 microseconds

00:32:38,000 --> 00:32:42,170
latency and then you need to dig into

00:32:40,370 --> 00:32:45,500
the bios and figure out what is going on

00:32:42,170 --> 00:32:48,770
and you have a tool to help detect

00:32:45,500 --> 00:32:53,350
whether that is happening as well now if

00:32:48,770 --> 00:32:53,350
you look at the latency graphs again a

00:32:53,440 --> 00:32:59,260
graph on the Left compares normal rel

00:32:57,080 --> 00:33:02,890
seven or the real time tree and

00:32:59,260 --> 00:33:05,600
real-time tree in kvm you can see that

00:33:02,890 --> 00:33:08,500
the normal colonel that's perfectly

00:33:05,600 --> 00:33:12,380
acceptable agencies most of the time

00:33:08,500 --> 00:33:16,760
here's the maximum latency is totally

00:33:12,380 --> 00:33:18,470
unacceptable to some people and graph on

00:33:16,760 --> 00:33:20,230
the Left we have removed the maximum

00:33:18,470 --> 00:33:24,740
latency to zoom in and you can see that

00:33:20,230 --> 00:33:27,320
real-time kvm is a fair bit slower

00:33:24,740 --> 00:33:31,700
they're running on bare metal in latency

00:33:27,320 --> 00:33:34,790
has expected but we can still get to

00:33:31,700 --> 00:33:37,220
around a dozen microsecond maximum

00:33:34,790 --> 00:33:39,110
latency and running in virtual machines

00:33:37,220 --> 00:33:41,750
does have certain management advantages

00:33:39,110 --> 00:33:43,940
for four people and they might have an

00:33:41,750 --> 00:33:46,790
application that a built for certain

00:33:43,940 --> 00:33:48,080
version of you afraid of the OS and I

00:33:46,790 --> 00:33:50,990
want to continue running that

00:33:48,080 --> 00:33:55,100
application inside the same version of

00:33:50,990 --> 00:33:58,070
the OS for the next 15 years anyways

00:33:55,100 --> 00:34:00,920
change out the hardware under it danger

00:33:58,070 --> 00:34:02,960
the hypervisor but keep running the same

00:34:00,920 --> 00:34:05,690
OS with the same application does they

00:34:02,960 --> 00:34:10,090
know that works and the maximum latency

00:34:05,690 --> 00:34:10,090
for real-time kvm is pretty low

00:34:12,380 --> 00:34:18,740
be 675 second numbers you are showing

00:34:15,470 --> 00:34:20,960
that how do those compares who say a 486

00:34:18,740 --> 00:34:22,760
system will receive six or seven

00:34:20,960 --> 00:34:25,360
microseconds on that system or would

00:34:22,760 --> 00:34:25,360
that be more

00:34:25,650 --> 00:34:33,310
that's a good question and I don't know

00:34:29,800 --> 00:34:35,380
I have no idea how much latency got

00:34:33,310 --> 00:34:37,510
better over the past decade or so in

00:34:35,380 --> 00:34:42,430
hardware when throughput is obviously

00:34:37,510 --> 00:34:45,940
improved a lot but latency and there are

00:34:42,430 --> 00:34:49,620
some latency effects actually where you

00:34:45,940 --> 00:34:52,480
need the new technology that intel has

00:34:49,620 --> 00:34:54,130
you have the cash allocation technology

00:34:52,480 --> 00:34:57,190
where you can partition a level three

00:34:54,130 --> 00:35:02,800
cash and you actually need that for some

00:34:57,190 --> 00:35:05,290
more clothes because it takes about 80

00:35:02,800 --> 00:35:09,900
90 seconds I think below the cache line

00:35:05,290 --> 00:35:12,450
of data in from run and if you are

00:35:09,900 --> 00:35:16,030
running inside the same sockets

00:35:12,450 --> 00:35:18,070
unconstrained CPU cache and you have a

00:35:16,030 --> 00:35:21,610
non real-time program running that makes

00:35:18,070 --> 00:35:23,770
a backup of the whole system and on one

00:35:21,610 --> 00:35:26,920
core and the other core is dedicated to

00:35:23,770 --> 00:35:29,770
a real-time task your real time task may

00:35:26,920 --> 00:35:33,970
find itself needing the load several

00:35:29,770 --> 00:35:37,540
megabytes of info from ram into the

00:35:33,970 --> 00:35:42,510
level three cash and there is no way you

00:35:37,540 --> 00:35:44,980
can do that in a dozen microseconds and

00:35:42,510 --> 00:35:49,060
you actually need to do things like

00:35:44,980 --> 00:35:53,110
ensuring that most of the data you need

00:35:49,060 --> 00:35:58,870
paste in the level 3 CPU cache otherwise

00:35:53,110 --> 00:36:01,030
you're too slow and that means you

00:35:58,870 --> 00:36:03,100
either on others on other systems you

00:36:01,030 --> 00:36:06,310
would have to move things into different

00:36:03,100 --> 00:36:09,070
sockets by the real-time stuff it sits

00:36:06,310 --> 00:36:10,600
on the socket together and it competes

00:36:09,070 --> 00:36:14,410
only with its with itself with each

00:36:10,600 --> 00:36:16,390
other or with this knob the newer CPUs

00:36:14,410 --> 00:36:18,580
that have cash allocation technology you

00:36:16,390 --> 00:36:23,440
can use that same kind of mesh

00:36:18,580 --> 00:36:26,770
partitioning inside a socket and well

00:36:23,440 --> 00:36:30,340
there are a number of piston operations

00:36:26,770 --> 00:36:33,220
are known to cause high latency thanks

00:36:30,340 --> 00:36:36,550
like CPU frequency change tape your hot

00:36:33,220 --> 00:36:37,800
plug inside a virtual machine hardware

00:36:36,550 --> 00:36:41,850
hot plug is

00:36:37,800 --> 00:36:44,130
extraordinarily rare loading and

00:36:41,850 --> 00:36:46,740
unloading kernel modules tops the whole

00:36:44,130 --> 00:36:48,450
kernel for a little bit you don't want

00:36:46,740 --> 00:36:52,260
to stop the whole kernel you're doing

00:36:48,450 --> 00:36:55,590
real time moving tasks between isolated

00:36:52,260 --> 00:36:57,990
CPUs and non isolated CPUs can cause

00:36:55,590 --> 00:37:01,500
Layton sees that are issues for some

00:36:57,990 --> 00:37:06,390
people if you are running a real time

00:37:01,500 --> 00:37:09,060
task on epu number seven for example and

00:37:06,390 --> 00:37:13,650
you have some low priority gaffa thing

00:37:09,060 --> 00:37:15,690
running on a system that has 500 threads

00:37:13,650 --> 00:37:18,570
that sometimes do something and they

00:37:15,690 --> 00:37:21,720
sometimes run somewhere and one of them

00:37:18,570 --> 00:37:25,170
is the garbage collector and it wants to

00:37:21,720 --> 00:37:31,110
it does an emperor tactical and suddenly

00:37:25,170 --> 00:37:35,280
your low priority Jaffa thing turns out

00:37:31,110 --> 00:37:40,800
a TLB flush to the CPU that runs your

00:37:35,280 --> 00:37:43,560
high priority real-time program and once

00:37:40,800 --> 00:37:47,700
the TLB flushes are all done and all the

00:37:43,560 --> 00:37:51,000
CPUs ep.7 can go back to running the

00:37:47,700 --> 00:37:54,060
real time program or whether the flash

00:37:51,000 --> 00:37:56,100
will prevent your real-time program from

00:37:54,060 --> 00:37:58,800
being scheduled in if it happens to wake

00:37:56,100 --> 00:38:00,270
up while the flash is going on there are

00:37:58,800 --> 00:38:03,960
some things there where it makes sense

00:38:00,270 --> 00:38:05,790
to do some partitioning in the system to

00:38:03,960 --> 00:38:09,920
keep real-time and non-real-time things

00:38:05,790 --> 00:38:09,920
that parade it away from each other

00:38:09,950 --> 00:38:17,070
real-time also needs a very fast clock

00:38:13,320 --> 00:38:20,670
source that means you need a system that

00:38:17,070 --> 00:38:23,610
has table esc and you need a system

00:38:20,670 --> 00:38:26,100
where the TAC a nut is not just stable

00:38:23,610 --> 00:38:28,860
it gives you the same number on every

00:38:26,100 --> 00:38:31,020
cpu if you read it simultaneously I

00:38:28,860 --> 00:38:33,960
think CSE third out of sync between

00:38:31,020 --> 00:38:37,020
different CPUs makes real-time really

00:38:33,960 --> 00:38:40,080
difficult and the best thing to do is to

00:38:37,020 --> 00:38:43,490
buy a computer right the tsc gives the

00:38:40,080 --> 00:38:43,490
same value in every cpu

00:38:43,750 --> 00:38:56,210
cure but yeah yeah right now so

00:38:50,660 --> 00:38:58,310
you'll be a bios later and well a an

00:38:56,210 --> 00:39:02,390
obvious cause of non real-time response

00:38:58,310 --> 00:39:04,660
is page faults if your real-time program

00:39:02,390 --> 00:39:07,160
is swapping it's no longer real-time

00:39:04,660 --> 00:39:12,200
solution is to have enough memory for

00:39:07,160 --> 00:39:15,350
your program and a more subtle one is

00:39:12,200 --> 00:39:17,630
using slow devices if you have a

00:39:15,350 --> 00:39:21,410
real-time program that read something to

00:39:17,630 --> 00:39:23,900
disk you may end up waiting on the file

00:39:21,410 --> 00:39:26,020
system and you didn't really want to do

00:39:23,900 --> 00:39:30,010
that if you want a real time and

00:39:26,020 --> 00:39:32,120
response and a solution for that is

00:39:30,010 --> 00:39:36,320
usually to split up the real time

00:39:32,120 --> 00:39:38,810
application into multiple programs and

00:39:36,320 --> 00:39:41,120
one program takes care of say the

00:39:38,810 --> 00:39:44,570
network transaction would have to happen

00:39:41,120 --> 00:39:47,650
in 10 microseconds and a difference

00:39:44,570 --> 00:39:51,440
totally separate part of the program

00:39:47,650 --> 00:39:54,230
will log stuff to disk because that is

00:39:51,440 --> 00:40:01,370
not something you want to interrupt your

00:39:54,230 --> 00:40:04,340
real-time responses for know now we come

00:40:01,370 --> 00:40:06,620
to cash allocation technology I think

00:40:04,340 --> 00:40:08,150
you can get cpu's with at least 20

00:40:06,620 --> 00:40:15,230
course nowadays there might be more

00:40:08,150 --> 00:40:18,320
maybe 22 not sure um but it takes

00:40:15,230 --> 00:40:21,670
certain amount of time pilote something

00:40:18,320 --> 00:40:25,640
from drm and if your real-time program

00:40:21,670 --> 00:40:31,000
purchase several megabytes of code and

00:40:25,640 --> 00:40:34,900
data you can spend a lot of time just

00:40:31,000 --> 00:40:37,970
waiting for staff the load from ram and

00:40:34,900 --> 00:40:39,650
it will be no piece of code that keeps

00:40:37,970 --> 00:40:42,140
your program slow you're just waiting on

00:40:39,650 --> 00:40:48,650
ram because your stuff is not in the CPU

00:40:42,140 --> 00:40:51,230
cache and if you want then micro second

00:40:48,650 --> 00:40:54,710
or even 20 micro second Layton sees you

00:40:51,230 --> 00:40:56,650
simply have to make sure that programs

00:40:54,710 --> 00:40:59,260
that use lots of memory

00:40:56,650 --> 00:41:02,099
do not get a chance to push your

00:40:59,260 --> 00:41:04,809
real-time programs out of the CPU k and

00:41:02,099 --> 00:41:06,520
this can be done by keeping things on

00:41:04,809 --> 00:41:10,990
different sockets or by cutting the

00:41:06,520 --> 00:41:13,390
newer CPUs would have the guts a tough

00:41:10,990 --> 00:41:16,210
inner that allows you to partition the

00:41:13,390 --> 00:41:19,240
cash between different workloads

00:41:16,210 --> 00:41:22,920
different course they can have out of

00:41:19,240 --> 00:41:25,809
your 22 course on the sockets you might

00:41:22,920 --> 00:41:30,460
dedicate 16 course the real time stuff

00:41:25,809 --> 00:41:33,849
and give them two thirds of the cache of

00:41:30,460 --> 00:41:36,339
that particular CPU and you might have

00:41:33,849 --> 00:41:38,289
the other course or everything else

00:41:36,339 --> 00:41:41,220
running on the system and give them only

00:41:38,289 --> 00:41:44,500
one third of the CPU cache on let's c pu

00:41:41,220 --> 00:41:46,859
and had a real time programs will not

00:41:44,500 --> 00:41:51,520
suffer from having all of their data

00:41:46,859 --> 00:41:54,549
picked out of the CPU cache by the other

00:41:51,520 --> 00:41:58,809
stuff running on the system and it

00:41:54,549 --> 00:42:01,630
really helps improve the latencies it's

00:41:58,809 --> 00:42:03,819
not a hundred percent guarantee but if

00:42:01,630 --> 00:42:06,670
ninety-nine point nine percent of your

00:42:03,819 --> 00:42:08,799
stuff is still in the cache it's only a

00:42:06,670 --> 00:42:12,119
tiny amount of data where you will

00:42:08,799 --> 00:42:15,119
suffer your 60 nanosecond access later

00:42:12,119 --> 00:42:21,789
that's not going to break your several

00:42:15,119 --> 00:42:22,930
microsecond real-time response i start

00:42:21,789 --> 00:42:25,770
the conclusion with the biggest surprise

00:42:22,930 --> 00:42:29,170
and real-time kvm is actually possible

00:42:25,770 --> 00:42:30,910
managed to get it to work and but it is

00:42:29,170 --> 00:42:33,640
done largely to the system partitioning

00:42:30,910 --> 00:42:38,559
and the over commits that he may be used

00:42:33,640 --> 00:42:40,960
to from running virtualization in the

00:42:38,559 --> 00:42:43,779
cloud or from somebody else running

00:42:40,960 --> 00:42:45,430
virtualization in mcleod so you can rent

00:42:43,779 --> 00:42:48,069
a virtual server for eight dollars a

00:42:45,430 --> 00:42:49,599
month that's not really an option for

00:42:48,069 --> 00:42:53,890
real time you need some dedicated

00:42:49,599 --> 00:42:57,369
resources and we've got Layton sees down

00:42:53,890 --> 00:43:00,510
to about a dozen microseconds for real

00:42:57,369 --> 00:43:03,250
time tasks running inside virtual CPUs

00:43:00,510 --> 00:43:07,930
this is the maximum latency the average

00:43:03,250 --> 00:43:08,470
is a lot lower than that and it is very

00:43:07,930 --> 00:43:13,630
deep

00:43:08,470 --> 00:43:15,640
in hardware you need to make sure the

00:43:13,630 --> 00:43:20,740
hardware does not break real-time

00:43:15,640 --> 00:43:22,450
responses virtualization is useful in

00:43:20,740 --> 00:43:24,640
real-time applications for some use

00:43:22,450 --> 00:43:26,410
cases where people need some more

00:43:24,640 --> 00:43:28,000
isolation or they use it for

00:43:26,410 --> 00:43:31,030
manageability hardware compatibility

00:43:28,000 --> 00:43:34,710
things like that but the configuration

00:43:31,030 --> 00:43:34,710
needs to be done very carefully and

00:43:35,609 --> 00:43:43,060
luckily we're working in automation the

00:43:39,760 --> 00:43:46,450
things like OpenStack and Rev can do a

00:43:43,060 --> 00:43:49,570
lot of the hard work for people and set

00:43:46,450 --> 00:43:50,710
things up the right way takes on with

00:43:49,570 --> 00:43:54,280
the guesswork away from system

00:43:50,710 --> 00:43:58,390
administrator and another thing to look

00:43:54,280 --> 00:44:02,830
at is a tool called the hardware latency

00:43:58,390 --> 00:44:05,500
tool that is used the test bare-metal

00:44:02,830 --> 00:44:09,460
the see if a system is actually capable

00:44:05,500 --> 00:44:17,190
of running a real-time workload with low

00:44:09,460 --> 00:44:20,470
latency sisters oh I'm excellency

00:44:17,190 --> 00:44:23,619
okay so work things are coming up to

00:44:20,470 --> 00:44:29,980
turn the hardware latency tool into its

00:44:23,619 --> 00:44:33,070
racer it's that's really nice great to

00:44:29,980 --> 00:44:34,390
hear that it's really nice and we have a

00:44:33,070 --> 00:44:36,430
few minutes left for questions and

00:44:34,390 --> 00:44:39,369
answers before the end of this session

00:44:36,430 --> 00:44:41,740
are there any other questions oh go

00:44:39,369 --> 00:44:43,780
ahead just let you know if this is

00:44:41,740 --> 00:44:45,070
actually more about sales pitch better a

00:44:43,780 --> 00:44:47,020
lot of the same that we're pushing as

00:44:45,070 --> 00:44:48,850
like yeah we're trying to help we work

00:44:47,020 --> 00:44:50,260
on how low latencies we can get a

00:44:48,850 --> 00:44:53,080
real-time just really means

00:44:50,260 --> 00:44:55,630
deterministic horse case scenarios so if

00:44:53,080 --> 00:44:58,480
you're real time tasks only requires

00:44:55,630 --> 00:45:00,130
like 1,000,000 places and you can do

00:44:58,480 --> 00:45:01,930
anything within that a lot of these

00:45:00,130 --> 00:45:04,450
things that we specialize are not

00:45:01,930 --> 00:45:07,060
required so we're showing you like

00:45:04,450 --> 00:45:09,200
hardly extreme what Rick's ears like the

00:45:07,060 --> 00:45:11,089
extreme getting down to know

00:45:09,200 --> 00:45:13,160
100 microseconds latency is as I just

00:45:11,089 --> 00:45:15,200
act requires tricks but if you do have

00:45:13,160 --> 00:45:18,260
an application at it doesn't require

00:45:15,200 --> 00:45:19,760
that strict of worst piece of variables

00:45:18,260 --> 00:45:22,680
a lot of stuff that you can actually

00:45:19,760 --> 00:45:25,450
respond and still get over

00:45:22,680 --> 00:45:27,630
yeah that's a good point and it

00:45:25,450 --> 00:45:30,010
certainly keeps people's lives easier I

00:45:27,630 --> 00:45:32,170
have a question about the business of

00:45:30,010 --> 00:45:33,640
data here so we are ready running the

00:45:32,170 --> 00:45:36,220
Stickley fast are you running much

00:45:33,640 --> 00:45:38,470
posterized all of the vista views for

00:45:36,220 --> 00:45:40,059
the real time via or you are just a

00:45:38,470 --> 00:45:44,069
running one i think lewis is probably

00:45:40,059 --> 00:45:48,490
the best person to answer that so

00:45:44,069 --> 00:45:51,450
because contrast and then the Macan s 46

00:45:48,490 --> 00:45:51,450
real

00:45:53,160 --> 00:46:02,750
in crystal blue bit but it's good

00:45:58,650 --> 00:46:02,750
didn't try to escape those who

00:46:02,930 --> 00:46:09,210
also have disgusting and it's also more

00:46:06,660 --> 00:46:10,830
you try to look like a lot sometimes you

00:46:09,210 --> 00:46:13,350
have found is if you're single try to

00:46:10,830 --> 00:46:16,079
answer eyes are all of the basic yields

00:46:13,350 --> 00:46:19,890
honesty was the maximum thickness

00:46:16,079 --> 00:46:23,369
ok and I'll supposed so they do try to

00:46:19,890 --> 00:46:28,009
run be one stay clean pass to the right

00:46:23,369 --> 00:46:28,009
of each real time based in here

00:46:29,450 --> 00:46:37,230
141 cycling test on each basic yes yes

00:46:33,650 --> 00:46:39,410
the usual thanks no chance takes off at

00:46:37,230 --> 00:46:39,410
eight

00:46:41,020 --> 00:46:48,010
mmmm

00:46:43,510 --> 00:46:50,870
it's where you got this friend yeah I

00:46:48,010 --> 00:46:54,110
right now you guys will be the same

00:46:50,870 --> 00:46:56,090
one on your CV go spread out and all the

00:46:54,110 --> 00:46:58,700
girls you safe I want I want run on all

00:46:56,090 --> 00:47:01,450
these views real-time task manager yes

00:46:58,700 --> 00:47:04,190
here so I'm just wondering because like

00:47:01,450 --> 00:47:06,230
even for the much post right here is the

00:47:04,190 --> 00:47:09,770
right you drumsticks to rise up page

00:47:06,230 --> 00:47:11,360
basic you p.m. so basically I'm assuming

00:47:09,770 --> 00:47:13,880
like you kick out all of the system

00:47:11,360 --> 00:47:16,190
stories to the other two are SEOs I'm

00:47:13,880 --> 00:47:19,520
just wondering like you what if you got

00:47:16,190 --> 00:47:21,770
your secrets right aren't the cpu and

00:47:19,520 --> 00:47:25,550
say how much is in there is it may get

00:47:21,770 --> 00:47:27,530
so this particular we talked about the

00:47:25,550 --> 00:47:30,400
prettiest women too

00:47:27,530 --> 00:47:30,400
the house key

00:47:31,020 --> 00:47:36,849
the positive you're not

00:47:33,220 --> 00:47:39,630
so you have to waste it because they

00:47:36,849 --> 00:47:39,630
dumped it here

00:47:40,150 --> 00:47:44,980
we probably need to take that discussion

00:47:42,789 --> 00:47:46,660
out into the hallway since we just got

00:47:44,980 --> 00:47:50,980
the one minute sign and we can you human

00:47:46,660 --> 00:47:53,840
question yeah about another layer was

00:47:50,980 --> 00:47:55,880
rewarded year or the year

00:47:53,840 --> 00:47:58,200
you could buy or sell

00:47:55,880 --> 00:48:00,920
our heavy

00:47:58,200 --> 00:48:00,920
but the way

00:48:05,230 --> 00:48:11,840
for example the gift makes a nubian

00:48:07,970 --> 00:48:12,580
but I don't know how people itís the kvm

00:48:11,840 --> 00:48:16,650
good

00:48:12,580 --> 00:48:16,650
it has cancer on

00:48:17,850 --> 00:48:25,470
the impossible is apply school official

00:48:21,000 --> 00:48:27,540
right so one issue maybe who in the

00:48:25,470 --> 00:48:29,790
guest that's that field they share for

00:48:27,540 --> 00:48:35,280
the hypervisor if you're not running you

00:48:29,790 --> 00:48:38,750
cannot change that field yeah but it's

00:48:35,280 --> 00:48:38,750

YouTube URL: https://www.youtube.com/watch?v=o6H8PhtOWK8


