Title: [2016] Performant Security Hardening of KVM by Steve Rutherford
Publication date: 2016-08-31
Playlist: KVM Forum 2016
Description: 
	Guest escapes and host information leaks in KVM are a causes for great concern. This talk covers a safer mode for KVM on x86 that is intended to reduce the frequency of such exploits, without decreasing performance. By removing complex, non-performance critical devices from KVM (namely, legacy interrupt controllers and the instruction emulator), the host kernel can expose less attack surface to the guest. This talk analyzes the guest exposed attack surface of KVM, as well as the performance and security implications of this new mode in production.


Steve Rutherford
Google

Steve is a Software Engineer on Google's Virtualization Security team, which maintains the security of Google Compute Engine. Steve's recent projects include KVM attack surface reduction (pulling legacy interrupt controllers out of KVM), which was merged into the 4.4 kernel.

Slides: http://www.linux-kvm.org/images/3/3d/01x02-Steve_Rutherford-Performant_Security_Hardening_of_KVM.pdf
Captions: 
	00:00:09,469 --> 00:00:13,679
I'm Steve brother furred I work on

00:00:11,790 --> 00:00:18,990
Google's virtualization security team

00:00:13,679 --> 00:00:24,170
and I'm here to talk about I stepped on

00:00:18,990 --> 00:00:24,170
the wire and then things happen or

00:00:26,119 --> 00:00:48,360
alright one second this I see ah let's

00:00:37,200 --> 00:00:50,660
sleep whatever power cord sorry about

00:00:48,360 --> 00:00:50,660
that everyone

00:00:56,620 --> 00:01:07,280
oh my god I got this this just an FYI

00:01:05,059 --> 00:01:09,770
for everyone don't use the four random

00:01:07,280 --> 00:01:22,700
word passwords from xkcd they get really

00:01:09,770 --> 00:01:25,010
long hey 37 characters it's fine alright

00:01:22,700 --> 00:01:27,020
so anyway um I'm here to talk about

00:01:25,010 --> 00:01:28,869
performance security hardening so just

00:01:27,020 --> 00:01:31,160
some history I've been working with

00:01:28,869 --> 00:01:33,650
Andrew Hoenig for the past few years who

00:01:31,160 --> 00:01:39,200
also came here to to speak I think in

00:01:33,650 --> 00:01:41,540
kayvyun form 2014 so first this talk is

00:01:39,200 --> 00:01:45,050
x86 and KVM centric so what I mean by

00:01:41,540 --> 00:01:47,360
this is that uh I a lot of my testing

00:01:45,050 --> 00:01:48,920
was actually not done with QEMU some of

00:01:47,360 --> 00:01:51,470
it was done with a different user space

00:01:48,920 --> 00:01:54,440
vmm a lot of this work has been actually

00:01:51,470 --> 00:01:56,090
ported to QEMU as well so we'll talk

00:01:54,440 --> 00:01:58,040
about that later on in this talk it's

00:01:56,090 --> 00:02:00,050
also x86 centric and then a lot of the

00:01:58,040 --> 00:02:01,820
security work I've done is just for x86

00:02:00,050 --> 00:02:03,560
a lot of these strategies and things

00:02:01,820 --> 00:02:05,840
that have kind of on a high level done

00:02:03,560 --> 00:02:07,280
would be valuable for these other

00:02:05,840 --> 00:02:10,610
architectures as well but I'm just going

00:02:07,280 --> 00:02:12,500
to focus on that one so first I'm going

00:02:10,610 --> 00:02:14,060
to talk about some background then I'm

00:02:12,500 --> 00:02:15,470
going to talk about the work we've

00:02:14,060 --> 00:02:19,070
already done that we've already tested

00:02:15,470 --> 00:02:21,140
we've had been released in or into KVM

00:02:19,070 --> 00:02:22,400
and then I'm going to talk about some

00:02:21,140 --> 00:02:24,769
future or some work we've already

00:02:22,400 --> 00:02:26,450
prototypes we've got working with KBM

00:02:24,769 --> 00:02:28,489
but we haven't actually merged into KVM

00:02:26,450 --> 00:02:32,180
and I'd like to talk about a proposal

00:02:28,489 --> 00:02:35,900
for a proposal for an interface that we

00:02:32,180 --> 00:02:39,290
could use in order to actually get that

00:02:35,900 --> 00:02:41,510
working so first what is our threat

00:02:39,290 --> 00:02:43,580
model so the things I'm concerned about

00:02:41,510 --> 00:02:46,480
are sort of untrusted users with code

00:02:43,580 --> 00:02:48,850
execution in a VM so what I mean is we

00:02:46,480 --> 00:02:51,380
Google compute engine gives customers

00:02:48,850 --> 00:02:53,840
access direct access to a VM they run

00:02:51,380 --> 00:02:55,489
code in it it's scary the thing that I'm

00:02:53,840 --> 00:02:57,910
worried about in this context our guest

00:02:55,489 --> 00:03:00,920
trigger able bugs so sort of like I

00:02:57,910 --> 00:03:02,870
guess against triggering a denial

00:03:00,920 --> 00:03:05,450
service on the host of the hosts crashes

00:03:02,870 --> 00:03:07,700
or a guest escaping into the host that's

00:03:05,450 --> 00:03:11,030
kind of terrifying and

00:03:07,700 --> 00:03:12,440
sort of information leaks from the hosts

00:03:11,030 --> 00:03:13,790
into the guests so that guests able to

00:03:12,440 --> 00:03:15,319
read something inside of the host it

00:03:13,790 --> 00:03:18,769
shouldn't be able to all of these things

00:03:15,319 --> 00:03:20,989
have happened so there have been around

00:03:18,769 --> 00:03:21,860
41 guest worker we'll see the ease since

00:03:20,989 --> 00:03:23,870
00:03:21,860 --> 00:03:25,250
notice that I'm saying guess trigger

00:03:23,870 --> 00:03:26,180
able as opposed to sort of a host

00:03:25,250 --> 00:03:29,209
trigger roll thing

00:03:26,180 --> 00:03:30,709
so I'm not as worried about say a sis

00:03:29,209 --> 00:03:32,360
called vulnerability like someone

00:03:30,709 --> 00:03:34,069
calling some crazy I knock Tolls and

00:03:32,360 --> 00:03:38,930
crashing the host I'm less worried about

00:03:34,069 --> 00:03:41,030
that in this context so historically the

00:03:38,930 --> 00:03:43,069
team I work on has done sort of code

00:03:41,030 --> 00:03:44,510
auditing and fuzzing it's been fairly

00:03:43,069 --> 00:03:47,090
successful doing this so we found

00:03:44,510 --> 00:03:48,110
something like fifteen CVEs and KVM

00:03:47,090 --> 00:03:49,910
probably more than that I actually

00:03:48,110 --> 00:03:52,430
didn't count out exactly how many it was

00:03:49,910 --> 00:03:54,829
but what this talk is primarily about is

00:03:52,430 --> 00:03:57,470
sort of a different strategy so the goal

00:03:54,829 --> 00:03:59,750
of this talk is to talk about ways of

00:03:57,470 --> 00:04:02,239
reducing KB M's guest accessible attack

00:03:59,750 --> 00:04:03,860
surface without impacting performance so

00:04:02,239 --> 00:04:06,739
I'll talk about what I mean by these

00:04:03,860 --> 00:04:08,209
things in just a second so guest

00:04:06,739 --> 00:04:10,099
accessible attack surface is sort of any

00:04:08,209 --> 00:04:13,000
privileged code with an interface

00:04:10,099 --> 00:04:15,200
accessible to the guest so say some

00:04:13,000 --> 00:04:17,289
device inside of the kernel like the

00:04:15,200 --> 00:04:20,389
pits the pic anything along these lines

00:04:17,289 --> 00:04:22,280
are things that the guest can access and

00:04:20,389 --> 00:04:24,889
so there's sort of ways of estimating

00:04:22,280 --> 00:04:27,289
how much attack service there is in the

00:04:24,889 --> 00:04:30,139
kernel or in KVM you can kind of go with

00:04:27,289 --> 00:04:32,180
like lines of code or say pages of

00:04:30,139 --> 00:04:33,560
specification of the devices a lot of

00:04:32,180 --> 00:04:37,490
these things are kind of indicative of

00:04:33,560 --> 00:04:38,600
the complexity of the interface another

00:04:37,490 --> 00:04:40,970
heuristic I use is sort of just

00:04:38,600 --> 00:04:42,979
historical CVEs anything complicated is

00:04:40,970 --> 00:04:46,880
probably in have bugs and when there's

00:04:42,979 --> 00:04:50,450
bugs there's probably more bugs so there

00:04:46,880 --> 00:04:52,700
are two primary strategies for kind of

00:04:50,450 --> 00:04:54,380
reducing attack surface you can either

00:04:52,700 --> 00:04:56,030
get rid of code you can reduce the

00:04:54,380 --> 00:04:59,150
amount of the attack surface or you can

00:04:56,030 --> 00:05:00,950
reduce the privilege of the code so what

00:04:59,150 --> 00:05:02,660
I mean by reduce the amount is sort of

00:05:00,950 --> 00:05:04,550
you can delete code you can get rid of

00:05:02,660 --> 00:05:06,440
interfaces you can kind of pare down

00:05:04,550 --> 00:05:08,539
what you actually expose to the guest

00:05:06,440 --> 00:05:11,419
the thing is you can only go so far in

00:05:08,539 --> 00:05:14,660
doing this eventually sort of run out of

00:05:11,419 --> 00:05:16,640
things to remove and you have to if you

00:05:14,660 --> 00:05:18,650
want to be more secure you have to go

00:05:16,640 --> 00:05:20,470
slightly further so another option is

00:05:18,650 --> 00:05:23,020
sort of to reduce the print

00:05:20,470 --> 00:05:24,490
of guests successful attack surface so

00:05:23,020 --> 00:05:27,040
one good way of doing this is move

00:05:24,490 --> 00:05:30,100
devices into user space move the attack

00:05:27,040 --> 00:05:32,080
surface into user space so why would you

00:05:30,100 --> 00:05:33,430
want to do this uh obviously it's it's

00:05:32,080 --> 00:05:35,680
lower privilege there's a sis called

00:05:33,430 --> 00:05:38,230
boundary so even if someone escapes the

00:05:35,680 --> 00:05:39,910
guest into that device they would just

00:05:38,230 --> 00:05:42,670
be jumping up into user space instead

00:05:39,910 --> 00:05:44,890
which is you know it's still scary but

00:05:42,670 --> 00:05:47,530
it's not as scary other nice things is

00:05:44,890 --> 00:05:49,600
that denial service attacks only killed

00:05:47,530 --> 00:05:52,270
that guests process it doesn't kill all

00:05:49,600 --> 00:05:55,300
of the VMS on the machine which is far

00:05:52,270 --> 00:05:57,340
better scenario also while in user space

00:05:55,300 --> 00:06:00,010
exploit mitigations and sandboxing are

00:05:57,340 --> 00:06:01,630
sort of more easily available kind of

00:06:00,010 --> 00:06:02,980
mucking with the kernel is a sort of a

00:06:01,630 --> 00:06:04,750
hard proposition but up in user space

00:06:02,980 --> 00:06:08,560
you can to some extent do whatever you

00:06:04,750 --> 00:06:11,140
want but why not

00:06:08,560 --> 00:06:11,680
put code in user space one big piece

00:06:11,140 --> 00:06:16,060
here

00:06:11,680 --> 00:06:18,280
is that user space devices require kV or

00:06:16,060 --> 00:06:21,250
sorry it's performance user space

00:06:18,280 --> 00:06:26,200
devices require KDM exits it's basically

00:06:21,250 --> 00:06:27,700
takes way longer to go from the from the

00:06:26,200 --> 00:06:29,530
guest up into user space and it does

00:06:27,700 --> 00:06:31,120
just to go down into karla zones

00:06:29,530 --> 00:06:33,190
probably two or three times longer so

00:06:31,120 --> 00:06:37,990
this will kind of take have higher

00:06:33,190 --> 00:06:40,120
latency and have lower throughput so the

00:06:37,990 --> 00:06:43,419
question is what can actually be moved

00:06:40,120 --> 00:06:45,520
into user space at all the heuristics

00:06:43,419 --> 00:06:48,730
i've used and or my team's used is sort

00:06:45,520 --> 00:06:50,770
of code that's complex slow rarely used

00:06:48,730 --> 00:06:52,390
but necessary the reason to say but

00:06:50,770 --> 00:06:54,220
necessary is it if it weren't necessary

00:06:52,390 --> 00:06:56,680
you could just get rid of it you

00:06:54,220 --> 00:06:59,380
wouldn't run it but for everything else

00:06:56,680 --> 00:07:01,600
you can kind of find the things that you

00:06:59,380 --> 00:07:04,180
want to target so good choices are sort

00:07:01,600 --> 00:07:06,520
of legacy devices among these are sort

00:07:04,180 --> 00:07:07,660
of the pick pit IO a pick I'll talk

00:07:06,520 --> 00:07:09,150
about these in more detail in a moment

00:07:07,660 --> 00:07:11,710
these are things that are sort of

00:07:09,150 --> 00:07:14,500
relatively slow now and haven't had

00:07:11,710 --> 00:07:15,910
thorough optimization by Intel with

00:07:14,500 --> 00:07:19,300
their virtualization instruction or

00:07:15,910 --> 00:07:20,919
extensions other things are sort of edge

00:07:19,300 --> 00:07:22,930
case handlers so things like the

00:07:20,919 --> 00:07:25,900
instruction emulator and NS are handling

00:07:22,930 --> 00:07:27,190
so there's a bunch of small teeny edge

00:07:25,900 --> 00:07:28,690
cases that you need to be able to

00:07:27,190 --> 00:07:33,650
support an emulation you need to be able

00:07:28,690 --> 00:07:37,630
to emulate but they're subtle and yeah

00:07:33,650 --> 00:07:37,630
and it's also slow to do these things so

00:07:38,680 --> 00:07:44,389
next I'm going to move into talking

00:07:42,289 --> 00:07:46,669
about one form of hardening that we've

00:07:44,389 --> 00:07:53,330
implanted which is split our acute chip

00:07:46,669 --> 00:07:55,250
and userspace pit so what is the irq

00:07:53,330 --> 00:07:57,560
chip in general so KVM uses the IARC

00:07:55,250 --> 00:07:59,600
uShip to refer to interrupt controllers

00:07:57,560 --> 00:08:02,600
as a whole so basically the picked the

00:07:59,600 --> 00:08:08,289
Iowa pick in the apex so any device that

00:08:02,600 --> 00:08:11,389
kind of converts a a line raise from a

00:08:08,289 --> 00:08:14,690
physical device into an interrupt inside

00:08:11,389 --> 00:08:17,419
of the guest:so KVM has support for both

00:08:14,690 --> 00:08:18,650
user space and kernel irq chips I'm not

00:08:17,419 --> 00:08:20,090
sure on the whole the history here I

00:08:18,650 --> 00:08:24,229
believe it initially was user space and

00:08:20,090 --> 00:08:26,060
maybe became kernel but the kernel I our

00:08:24,229 --> 00:08:28,460
cube has a significant performance boost

00:08:26,060 --> 00:08:30,860
over the user space one particularly so

00:08:28,460 --> 00:08:34,909
given that intel has added a large

00:08:30,860 --> 00:08:36,950
number of features to accelerate epic

00:08:34,909 --> 00:08:38,839
access and a pic interrupts and all of

00:08:36,950 --> 00:08:41,930
these other things that are sort of only

00:08:38,839 --> 00:08:45,470
really usable while the APIs inside of

00:08:41,930 --> 00:08:47,089
the kernel so note that mostly I just

00:08:45,470 --> 00:08:47,480
talked about performance of the apec

00:08:47,089 --> 00:08:49,670
there

00:08:47,480 --> 00:08:52,730
so what split req chip is which is the

00:08:49,670 --> 00:08:54,080
one of the things I've worked on is kind

00:08:52,730 --> 00:08:56,270
of taking the best of both of these

00:08:54,080 --> 00:08:58,070
scenarios so move the pic in the Iowa

00:08:56,270 --> 00:09:00,800
pick which aren't used by modern VMs

00:08:58,070 --> 00:09:03,110
very much and put those up in the user

00:09:00,800 --> 00:09:06,010
space but leave the a pic down in the

00:09:03,110 --> 00:09:08,720
kernel this turns out to be sort of a

00:09:06,010 --> 00:09:12,620
nightmare scenario these things are kind

00:09:08,720 --> 00:09:14,180
of quite coupled in KVM but we were able

00:09:12,620 --> 00:09:15,800
to sort of splice these apart and I'll

00:09:14,180 --> 00:09:22,790
get into more details of about that in a

00:09:15,800 --> 00:09:24,110
second so first the programmable

00:09:22,790 --> 00:09:26,600
interrupt controllers of the pic

00:09:24,110 --> 00:09:29,209
it's an interrupt controller that maps

00:09:26,600 --> 00:09:32,000
directly from lines to interrupts they

00:09:29,209 --> 00:09:33,620
it's a one-to-one mapping it's a device

00:09:32,000 --> 00:09:36,140
you can't really live without it's used

00:09:33,620 --> 00:09:37,520
for an early boot for like real mode

00:09:36,140 --> 00:09:39,100
interrupts and I think maybe a little

00:09:37,520 --> 00:09:42,410
bit later I'm not entirely certain but

00:09:39,100 --> 00:09:44,029
it's mostly used for all their devices

00:09:42,410 --> 00:09:46,329
that are still useful like the real-time

00:09:44,029 --> 00:09:49,959
clock and the

00:09:46,329 --> 00:09:53,100
but after fairly early on in boot its

00:09:49,959 --> 00:09:57,249
masks I think pick actually sends only

00:09:53,100 --> 00:10:00,339
50 interrupts in remember correctly in

00:09:57,249 --> 00:10:02,800
Debian and like a hundred and Windows so

00:10:00,339 --> 00:10:04,059
it's like not used very much it's so

00:10:02,800 --> 00:10:05,769
it's masked pretty early so it doesn't

00:10:04,059 --> 00:10:10,749
send anymore interrupts and eventually

00:10:05,769 --> 00:10:13,889
just replaced by the IOA pick so why

00:10:10,749 --> 00:10:16,120
even worry about the pic so it has a

00:10:13,889 --> 00:10:20,889
medium-large attack service it takes up

00:10:16,120 --> 00:10:23,379
about 1% of all code in x86 KBM i'm i

00:10:20,889 --> 00:10:26,110
think that's um I believe there's about

00:10:23,379 --> 00:10:29,139
50,000 lines in x86 KVM and it takes up

00:10:26,110 --> 00:10:31,449
about 600 of them so Paulo might give me

00:10:29,139 --> 00:10:35,050
a face I'm not sure if that sounds about

00:10:31,449 --> 00:10:38,259
right yeah there's a 24 page spec it's

00:10:35,050 --> 00:10:39,730
kind of it's very very dense it's very

00:10:38,259 --> 00:10:41,740
detailed it'd be very easy to make a

00:10:39,730 --> 00:10:44,410
mistake in in interpreting this or

00:10:41,740 --> 00:10:48,129
anything along those lines in particular

00:10:44,410 --> 00:10:49,809
it has a complex epi so it has tons of

00:10:48,129 --> 00:10:54,339
different modes you can kind of switch

00:10:49,809 --> 00:10:57,189
from auto Aoi to UI or specific versus

00:10:54,339 --> 00:11:00,160
auto rotation of priorities it's all of

00:10:57,189 --> 00:11:03,370
these like weird things that I think

00:11:00,160 --> 00:11:05,769
very few less is use but could be

00:11:03,370 --> 00:11:06,910
potential attack surface there's also a

00:11:05,769 --> 00:11:08,829
non-trivial amount of sort of

00:11:06,910 --> 00:11:11,350
unspecified behavior in it there are

00:11:08,829 --> 00:11:13,000
certain cases where if you were to do

00:11:11,350 --> 00:11:15,939
one thing and do something else it's not

00:11:13,000 --> 00:11:18,430
really clear what should happen I think

00:11:15,939 --> 00:11:22,420
most implementations do sort of the nice

00:11:18,430 --> 00:11:26,620
gentle thing in these contexts but it's

00:11:22,420 --> 00:11:29,079
a thing to worry about so why not keep

00:11:26,620 --> 00:11:31,360
the pic in KVM so it's in definitely

00:11:29,079 --> 00:11:33,279
masked during boot and most common

00:11:31,360 --> 00:11:34,899
devices and it's slow so it already

00:11:33,279 --> 00:11:37,750
requires vm exits and instruction

00:11:34,899 --> 00:11:39,040
emulation to access so really there's I

00:11:37,750 --> 00:11:40,839
don't know to say it's not very

00:11:39,040 --> 00:11:42,490
convincing to leave it there but there

00:11:40,839 --> 00:11:44,139
you could just readily move it into user

00:11:42,490 --> 00:11:48,370
space and not get too much of a

00:11:44,139 --> 00:11:53,470
performance hit so what's necessary in

00:11:48,370 --> 00:11:55,779
order to actually implement a user space

00:11:53,470 --> 00:11:58,920
pic well so the pic needs to be able to

00:11:55,779 --> 00:11:58,920
send interrupts so

00:11:58,950 --> 00:12:04,240
one way of doing this is just to kind of

00:12:01,270 --> 00:12:06,340
hijack the interface from the users face

00:12:04,240 --> 00:12:09,070
irq ship which also supports a user's

00:12:06,340 --> 00:12:10,570
face pic and so we've updated basically

00:12:09,070 --> 00:12:12,670
KVM interrupts you believe sent

00:12:10,570 --> 00:12:13,620
interrupts in that context I might be

00:12:12,670 --> 00:12:17,440
mistaken

00:12:13,620 --> 00:12:19,270
okay pel is nodding his head we also

00:12:17,440 --> 00:12:21,220
added support for user space interrupts

00:12:19,270 --> 00:12:23,830
windows so the pic needs to know when

00:12:21,220 --> 00:12:26,230
it's capable of sending interrupts into

00:12:23,830 --> 00:12:28,000
the guest immediately once it's allowed

00:12:26,230 --> 00:12:30,160
to because that's how hardware is able

00:12:28,000 --> 00:12:32,110
to behave so as soon as it's unmasked it

00:12:30,160 --> 00:12:34,570
needs to immediately send any pending

00:12:32,110 --> 00:12:37,480
interrupts and so we hijacked between

00:12:34,570 --> 00:12:40,290
the fields already in use by user space

00:12:37,480 --> 00:12:48,280
irq chip in order to implement these

00:12:40,290 --> 00:12:50,530
user space in our windows so next I'm

00:12:48,280 --> 00:12:52,500
going to talk about the Iowa pick the

00:12:50,530 --> 00:12:56,650
iowa pick is sort of a yet another

00:12:52,500 --> 00:12:57,970
interrupt handling device it does it's a

00:12:56,650 --> 00:13:00,130
global interrupt controller kind of is a

00:12:57,970 --> 00:13:01,870
pic from multi-core I don't know if this

00:13:00,130 --> 00:13:04,900
is is a pretty good intuition for it

00:13:01,870 --> 00:13:06,010
it's as a configurable mapping from like

00:13:04,900 --> 00:13:09,970
level and edge triggered inner

00:13:06,010 --> 00:13:12,490
interrupts or sorry from GSIS to engine

00:13:09,970 --> 00:13:15,610
level triggered a pic interrupts it's

00:13:12,490 --> 00:13:18,570
necessary for any sort of non MSI

00:13:15,610 --> 00:13:20,620
supporting interrupt device so pitch

00:13:18,570 --> 00:13:23,530
real-time clock a lot of these older

00:13:20,620 --> 00:13:25,510
devices but some more modern devices

00:13:23,530 --> 00:13:28,180
that use Emma size are actually able to

00:13:25,510 --> 00:13:30,280
bypass the i/o a big message signaled

00:13:28,180 --> 00:13:33,190
interrupts just kind of go directly to

00:13:30,280 --> 00:13:37,060
the APEC and the apex Devlin just hand

00:13:33,190 --> 00:13:40,030
it off directly into the guest so why

00:13:37,060 --> 00:13:42,850
worry about the i/o a pic at all so it

00:13:40,030 --> 00:13:44,770
has sort of a bad history there's at

00:13:42,850 --> 00:13:46,630
least two bugs so far one of which was

00:13:44,770 --> 00:13:48,970
an arbitrary read guided guarded by an

00:13:46,630 --> 00:13:51,130
assert so someone was doing some actual

00:13:48,970 --> 00:13:54,280
checking using an assert and it turns

00:13:51,130 --> 00:13:56,620
out when you compile in the non debug

00:13:54,280 --> 00:14:00,100
modes that assert goes away and all of a

00:13:56,620 --> 00:14:02,800
sudden the bug appears on top of that

00:14:00,100 --> 00:14:07,810
there was a dinosaur via the invalid

00:14:02,800 --> 00:14:11,350
redirect table entry of also similar to

00:14:07,810 --> 00:14:13,720
the pic it's has reasonable measurable

00:14:11,350 --> 00:14:19,380
so it's got also about 800 lines of code

00:14:13,720 --> 00:14:19,380
or 1% of KBM and an other 20 page deck

00:14:20,160 --> 00:14:26,800
so why not keep the Iowa pick in kbm so

00:14:24,670 --> 00:14:29,320
first of all it has pretty significant

00:14:26,800 --> 00:14:30,970
performance degradation for these older

00:14:29,320 --> 00:14:33,070
interrupts so in text so anything that

00:14:30,970 --> 00:14:36,670
actually uses the IOA pick one part is

00:14:33,070 --> 00:14:38,080
that level triggered interrupts with so

00:14:36,670 --> 00:14:39,640
level triggered interrupts require end

00:14:38,080 --> 00:14:41,290
of interrupts messages in order to be

00:14:39,640 --> 00:14:45,040
informed that they should go back down

00:14:41,290 --> 00:14:46,330
and these messages will now need to go

00:14:45,040 --> 00:14:48,580
to user space and so that's gonna take

00:14:46,330 --> 00:14:50,760
an additional step up and down and will

00:14:48,580 --> 00:14:53,950
kind of slow down the entire process

00:14:50,760 --> 00:14:56,170
there's also performance degradation for

00:14:53,950 --> 00:15:01,029
i/o a pic reads and writes

00:14:56,170 --> 00:15:04,839
so VM exit so these will now require vm

00:15:01,029 --> 00:15:06,850
exits in addition we're sorry these will

00:15:04,839 --> 00:15:08,260
now cut require k vm exits in addition

00:15:06,850 --> 00:15:10,060
to the m exit so going the whole off to

00:15:08,260 --> 00:15:13,060
whole web teaser space and this is kind

00:15:10,060 --> 00:15:16,680
of bad for I think I observed qnx which

00:15:13,060 --> 00:15:19,570
is sort of maybe an obscure OS actually

00:15:16,680 --> 00:15:20,980
masking interrupts during an interrupt

00:15:19,570 --> 00:15:22,450
handler which seems kind of strange but

00:15:20,980 --> 00:15:24,100
it was doing this since it was reading

00:15:22,450 --> 00:15:28,390
and writing frequently to the i/o a

00:15:24,100 --> 00:15:31,180
thick and it really really slowed things

00:15:28,390 --> 00:15:32,560
down in that context but any sort of

00:15:31,180 --> 00:15:34,270
performance sensitive devices you should

00:15:32,560 --> 00:15:35,770
already be using and Maasai's and

00:15:34,270 --> 00:15:37,690
bypassing the i/o a pic anyway so

00:15:35,770 --> 00:15:42,480
there's not really a strong case for

00:15:37,690 --> 00:15:42,480
keeping this inside of the kernel

00:15:53,249 --> 00:16:11,169
yes so my response to that would be this

00:16:08,259 --> 00:16:13,779
should only be used in context where you

00:16:11,169 --> 00:16:16,389
have a modern operating system inside

00:16:13,779 --> 00:16:18,759
like there is absolutely if you are

00:16:16,389 --> 00:16:20,439
going to target performance for older

00:16:18,759 --> 00:16:20,829
operating systems this is a terrible

00:16:20,439 --> 00:16:22,149
idea

00:16:20,829 --> 00:16:24,779
it's gonna slow things down I'll talk

00:16:22,149 --> 00:16:27,429
about this later probably by about 20% I

00:16:24,779 --> 00:16:28,929
mean maybe that doesn't matter for a lot

00:16:27,429 --> 00:16:32,079
of people if you're trying to target

00:16:28,929 --> 00:16:33,759
these legacy operating systems the 20%

00:16:32,079 --> 00:16:35,859
performance hit might not matter that

00:16:33,759 --> 00:16:37,959
much because you could try to forcibly

00:16:35,859 --> 00:16:39,549
upgrade I'm not entirely certain like

00:16:37,959 --> 00:16:42,609
there are contexts I can imagine where

00:16:39,549 --> 00:16:50,019
you wouldn't want to change OSS but

00:16:42,609 --> 00:16:53,439
anyway so in order to be have a user

00:16:50,019 --> 00:16:56,379
fail space Iowa pic you need to be able

00:16:53,439 --> 00:16:58,600
to send interrupts to Apex so from user

00:16:56,379 --> 00:17:01,419
space fortunately this was already

00:16:58,600 --> 00:17:03,399
available through basically GSI routing

00:17:01,419 --> 00:17:07,569
table and KT and said irq so you can

00:17:03,399 --> 00:17:09,100
actually take the IOA pics route you can

00:17:07,569 --> 00:17:11,319
pan it down to the kernel and you can

00:17:09,100 --> 00:17:13,589
raise and lower line correspondingly to

00:17:11,319 --> 00:17:16,720
send interrupts into the guest

00:17:13,589 --> 00:17:18,850
additionally the user space i io a pic

00:17:16,720 --> 00:17:23,709
will need to be informed of any iya wise

00:17:18,850 --> 00:17:25,480
so we added in a UI kbm exit that just

00:17:23,709 --> 00:17:30,190
goes up to user space and points this

00:17:25,480 --> 00:17:33,519
out whenever a UI VM exit happens also

00:17:30,190 --> 00:17:35,590
we made the you my exit bitmap

00:17:33,519 --> 00:17:40,629
configurable by user space so when aim

00:17:35,590 --> 00:17:44,500
by this is a recent acceleration for x86

00:17:40,629 --> 00:17:45,970
was it there's an EAJA exit bitmap

00:17:44,500 --> 00:17:50,919
saying which interrupts you should

00:17:45,970 --> 00:17:53,500
actually exit for for e you eyes and in

00:17:50,919 --> 00:17:55,389
order to actually get any inner core you

00:17:53,500 --> 00:17:57,399
eyes up into the i/o a pic you need it

00:17:55,389 --> 00:17:58,960
to actually exit and so this needs to be

00:17:57,399 --> 00:18:00,580
configurable and we made this

00:17:58,960 --> 00:18:02,170
configurable using a

00:18:00,580 --> 00:18:03,850
basically arranged within the GSI

00:18:02,170 --> 00:18:05,950
routing table where you would look and

00:18:03,850 --> 00:18:07,330
you'd see oh is this one bit flipped is

00:18:05,950 --> 00:18:09,370
it considered a level trigger to

00:18:07,330 --> 00:18:24,220
interrupt and if so it should definitely

00:18:09,370 --> 00:18:33,790
exit from the guests wait there's an

00:18:24,220 --> 00:18:35,920
Iowa picket register huh I've learned

00:18:33,790 --> 00:18:40,570
also some other crazy things uh I I

00:18:35,920 --> 00:18:42,880
found a thread from 2010 wear a bikini

00:18:40,570 --> 00:18:44,920
the previous kayvyun maintainer was

00:18:42,880 --> 00:18:53,170
basically proposing a large fraction of

00:18:44,920 --> 00:18:54,130
this project so yeah um so after the I

00:18:53,170 --> 00:18:56,110
only pick I'm going to talk about the

00:18:54,130 --> 00:18:58,450
programmable interval timer so it's

00:18:56,110 --> 00:19:01,720
another device so it's a fixed frequency

00:18:58,450 --> 00:19:03,970
timer with multiple counters it's pretty

00:19:01,720 --> 00:19:05,980
commonly used for calibrating other

00:19:03,970 --> 00:19:08,140
timers I don't know all the details of

00:19:05,980 --> 00:19:09,670
exactly why it's used but my

00:19:08,140 --> 00:19:14,200
understanding is it's primarily used for

00:19:09,670 --> 00:19:17,920
sort of not necessarily to performance

00:19:14,200 --> 00:19:20,920
critical things why worry about the pit

00:19:17,920 --> 00:19:23,170
it's had four CVEs so far the most

00:19:20,920 --> 00:19:25,390
exciting which was a pit out-of-balance

00:19:23,170 --> 00:19:27,580
memory axis with it potentially could

00:19:25,390 --> 00:19:29,320
have been used to escape the guests it

00:19:27,580 --> 00:19:32,800
was kind of rated as really hard to pull

00:19:29,320 --> 00:19:34,750
off and it was also I think even though

00:19:32,800 --> 00:19:38,680
was discovered in 2015 it was originally

00:19:34,750 --> 00:19:44,350
there in like 2012 and accidentally

00:19:38,680 --> 00:19:46,360
fixed so the pit also is kind of complex

00:19:44,350 --> 00:19:48,550
so it's yet yet again like all of these

00:19:46,360 --> 00:19:53,830
other devices as about 800 lines of code

00:19:48,550 --> 00:19:55,870
and 20 ish pages of spec so why not keep

00:19:53,830 --> 00:19:57,670
it in the kernel so it's as far as I saw

00:19:55,870 --> 00:20:00,130
or I think Debian and Windows and a few

00:19:57,670 --> 00:20:03,820
other things it's typically only used

00:20:00,130 --> 00:20:05,980
during boot and then it's also slow so

00:20:03,820 --> 00:20:07,780
it's reads and writes already require vm

00:20:05,980 --> 00:20:09,370
exits an instruction emulation to access

00:20:07,780 --> 00:20:11,080
it so it's gonna take a while before you

00:20:09,370 --> 00:20:13,890
can even get to the device so why not

00:20:11,080 --> 00:20:13,890
just go to user space too

00:20:13,960 --> 00:20:18,800
so summing up all of these devices we're

00:20:17,360 --> 00:20:22,010
actually able to move about four or five

00:20:18,800 --> 00:20:26,300
percent of KPM into user space and get

00:20:22,010 --> 00:20:30,110
rid of the sources of six out of like 41

00:20:26,300 --> 00:20:31,790
of the guest turbo CBE since 2009 and

00:20:30,110 --> 00:20:33,200
I'll get to exactly what I mean by a

00:20:31,790 --> 00:20:36,020
negligible performance impact in just a

00:20:33,200 --> 00:20:39,140
second but for modern VM so modern OS is

00:20:36,020 --> 00:20:42,020
on top of modern versions of KVM with

00:20:39,140 --> 00:20:44,270
modern versions of the user space

00:20:42,020 --> 00:20:46,850
portion you get negligible performance

00:20:44,270 --> 00:20:51,590
in fact so what I mean by this is so I

00:20:46,850 --> 00:20:54,200
ran a disk random read test using on a

00:20:51,590 --> 00:20:56,750
machine with MSI support I do this on

00:20:54,200 --> 00:20:59,000
both IV Britain as well so in blue you

00:20:56,750 --> 00:21:00,890
can see the kernel irq chip performance

00:20:59,000 --> 00:21:02,930
and in red you can see the split area q

00:21:00,890 --> 00:21:04,700
chip performance and they're actually

00:21:02,930 --> 00:21:07,550
really really close actually the error

00:21:04,700 --> 00:21:08,990
bars it's I think for some reason split

00:21:07,550 --> 00:21:10,820
errection ship was slightly better even

00:21:08,990 --> 00:21:14,390
though I ran thinking about fifty or

00:21:10,820 --> 00:21:16,640
hundred tests of this for context the

00:21:14,390 --> 00:21:20,660
the bars are actually a five percent

00:21:16,640 --> 00:21:22,280
confidence intervals and so it's sort of

00:21:20,660 --> 00:21:23,900
indistinguishable or apparently splitter

00:21:22,280 --> 00:21:26,080
a cue chip is faster but that would blow

00:21:23,900 --> 00:21:30,020
my mind that doesn't make sense to me

00:21:26,080 --> 00:21:32,120
but this only is for modern teams so how

00:21:30,020 --> 00:21:34,130
modern is modern well you have to have

00:21:32,120 --> 00:21:35,390
an msi support I guess one thing that

00:21:34,130 --> 00:21:37,900
goes into mention here is that you need

00:21:35,390 --> 00:21:41,060
to have a modern OS inside of the guest

00:21:37,900 --> 00:21:44,540
and the guest should not be reading or

00:21:41,060 --> 00:21:45,800
writing to the i/o a pic or the pit too

00:21:44,540 --> 00:21:49,130
frequently if it's doing that you're

00:21:45,800 --> 00:21:50,900
really gonna tank in performance so what

00:21:49,130 --> 00:21:56,170
happens if you're actually doing that so

00:21:50,900 --> 00:21:59,600
I also ran this test with a legacy

00:21:56,170 --> 00:22:02,960
legacy guest and not significantly worse

00:21:59,600 --> 00:22:04,250
performance so once again in blue you

00:22:02,960 --> 00:22:07,580
could soon see the kernel our kinship

00:22:04,250 --> 00:22:09,170
performance and in red the split our

00:22:07,580 --> 00:22:10,850
kinship performance and you get about a

00:22:09,170 --> 00:22:12,920
ten to twenty percent performance data

00:22:10,850 --> 00:22:14,000
creation in this context and some for

00:22:12,920 --> 00:22:18,590
some people that might actually be

00:22:14,000 --> 00:22:20,360
acceptable but if if you're too worried

00:22:18,590 --> 00:22:23,900
about this sort of performance it's

00:22:20,360 --> 00:22:24,980
probably not worth using this feature so

00:22:23,900 --> 00:22:26,299
you can actually go and try this out

00:22:24,980 --> 00:22:30,739
right now it's available

00:22:26,299 --> 00:22:33,070
in qemu version 2.6 via Colonel so -

00:22:30,739 --> 00:22:35,809
machine Colonel hire q-tip equal split

00:22:33,070 --> 00:22:37,459
but you need the four for Linux kernel

00:22:35,809 --> 00:22:38,629
or higher so if you have both of those

00:22:37,459 --> 00:22:44,419
together then you can go and try this

00:22:38,629 --> 00:22:46,249
out so next I'm going to talk about

00:22:44,419 --> 00:22:47,899
something we've already prototypes and

00:22:46,249 --> 00:22:49,519
tested out runs a performance test

00:22:47,899 --> 00:22:52,369
against which is a user space

00:22:49,519 --> 00:22:55,549
instruction emulator so what is the

00:22:52,369 --> 00:22:58,249
instruction emulator it's a basically

00:22:55,549 --> 00:23:00,619
it's emulates x86 instructions with

00:22:58,249 --> 00:23:01,999
eddie x86 when the cpu can't actually

00:23:00,619 --> 00:23:04,219
virtualize so when you actually up to

00:23:01,999 --> 00:23:07,279
exit out on the guest and say right to

00:23:04,219 --> 00:23:09,489
read or write - mmm I owe you need to be

00:23:07,279 --> 00:23:13,419
using the instruction emulator or

00:23:09,489 --> 00:23:15,859
emulated in the way I should say oh so

00:23:13,419 --> 00:23:18,349
why worry about the instruction emulator

00:23:15,859 --> 00:23:20,570
so it's it basically converts arbitrary

00:23:18,349 --> 00:23:23,179
bytes into an instruction and then

00:23:20,570 --> 00:23:25,700
emulates that instruction which is kind

00:23:23,179 --> 00:23:27,979
of crazy right so in particular it

00:23:25,700 --> 00:23:30,049
handles I think around 80 or so of the

00:23:27,979 --> 00:23:31,879
x86 instructions that's not too big a

00:23:30,049 --> 00:23:33,889
fraction of x86 but still pretty

00:23:31,879 --> 00:23:35,690
complicated it's about five hundred five

00:23:33,889 --> 00:23:39,349
thousand five hundred lines of code and

00:23:35,690 --> 00:23:42,799
growing its head eleven bugs so far so

00:23:39,349 --> 00:23:50,059
it's not exactly a confidence-building

00:23:42,799 --> 00:23:51,529
device at this point um sorry oh and in

00:23:50,059 --> 00:23:53,929
particular some of these have even been

00:23:51,529 --> 00:23:55,399
guest escapes the push a bug was a bump

00:23:53,929 --> 00:23:57,589
from I think two years ago found by a

00:23:55,399 --> 00:23:59,329
co-worker of mine that actually was made

00:23:57,589 --> 00:24:01,999
it possible to escape from the guest

00:23:59,329 --> 00:24:05,749
into the host so that's like not what

00:24:01,999 --> 00:24:08,599
you want to have around so why not keep

00:24:05,749 --> 00:24:11,149
the emulator in the kernel so we split

00:24:08,599 --> 00:24:13,879
Eric you chip so the big thing is that

00:24:11,149 --> 00:24:16,219
the emulator needs to be able to

00:24:13,879 --> 00:24:17,539
actually access these mm i/o devices

00:24:16,219 --> 00:24:24,320
needs to be able to read and write to

00:24:17,539 --> 00:24:25,940
them and so in order to so fortunately

00:24:24,320 --> 00:24:27,679
with split Eric you ship most of these

00:24:25,940 --> 00:24:30,799
devices have already been moved into

00:24:27,679 --> 00:24:33,379
user space and so if the emulators were

00:24:30,799 --> 00:24:34,969
to have been moved to user space it can

00:24:33,379 --> 00:24:36,469
just directly read and write across

00:24:34,969 --> 00:24:39,500
without having to have an additional

00:24:36,469 --> 00:24:40,640
kernel interface there is Oh

00:24:39,500 --> 00:24:43,310
exception with litter a couch if you

00:24:40,640 --> 00:24:44,930
need to have access to the apex so you

00:24:43,310 --> 00:24:45,350
need to have some way to write read and

00:24:44,930 --> 00:24:48,530
write to that

00:24:45,350 --> 00:24:53,420
fortunately with x86 is virtual machine

00:24:48,530 --> 00:24:54,770
or with x86 is a pic V extensions you

00:24:53,420 --> 00:24:56,240
can actually skip a lot of this

00:24:54,770 --> 00:24:58,550
emulation so you can actually just

00:24:56,240 --> 00:25:01,220
directly exit and say oh it's this type

00:24:58,550 --> 00:25:02,450
of a pic right and then directly right

00:25:01,220 --> 00:25:04,130
to it so you don't have to balance up to

00:25:02,450 --> 00:25:05,390
user space to the emulator and then

00:25:04,130 --> 00:25:07,040
bounce back down to the kernel you don't

00:25:05,390 --> 00:25:14,810
have to do a lot of that most of the

00:25:07,040 --> 00:25:16,820
time so in order to get the user space

00:25:14,810 --> 00:25:18,550
instruction familiar working it's going

00:25:16,820 --> 00:25:20,930
to need guest register access

00:25:18,550 --> 00:25:21,710
fortunately this is already available so

00:25:20,930 --> 00:25:24,530
you need this so that you can actually

00:25:21,710 --> 00:25:27,980
find out why are in memory your emulated

00:25:24,530 --> 00:25:29,930
and you also need I guess memory access

00:25:27,980 --> 00:25:31,220
to which is also available from user

00:25:29,930 --> 00:25:32,420
space so combining this together you can

00:25:31,220 --> 00:25:35,930
actually find the bytes of the

00:25:32,420 --> 00:25:37,220
instruction read that decode then etc so

00:25:35,930 --> 00:25:38,330
all this is already available but could

00:25:37,220 --> 00:25:40,460
be accelerated if you were to use

00:25:38,330 --> 00:25:43,880
something like k vm sync registers which

00:25:40,460 --> 00:25:45,740
is a way of kind of marking registers to

00:25:43,880 --> 00:25:49,430
be read read and read from up from the

00:25:45,740 --> 00:25:51,530
kernel you're also going to need a new

00:25:49,430 --> 00:25:53,390
key vm exit type to go up to user space

00:25:51,530 --> 00:25:55,310
to say that you should be emulating so

00:25:53,390 --> 00:25:58,940
one option here would see something like

00:25:55,310 --> 00:26:02,390
k vm exit emulation needed pretty

00:25:58,940 --> 00:26:04,790
straightforward one and once again it

00:26:02,390 --> 00:26:10,340
must be able to talk to any kernel or

00:26:04,790 --> 00:26:11,870
MMI o pv i/o device so in particular the

00:26:10,340 --> 00:26:13,970
only thing that is kind of mark needed

00:26:11,870 --> 00:26:16,280
marginally is the ability to read and

00:26:13,970 --> 00:26:17,450
write to the apec fortunately most of

00:26:16,280 --> 00:26:20,330
the time this isn't necessary but you

00:26:17,450 --> 00:26:22,700
still need the access because the I

00:26:20,330 --> 00:26:25,280
believe the SDM so Intel's manual

00:26:22,700 --> 00:26:28,040
doesn't promise that it will never exit

00:26:25,280 --> 00:26:29,660
it might do that on occasion so we need

00:26:28,040 --> 00:26:32,690
to do know why optimal to support

00:26:29,660 --> 00:26:38,270
reading writing to the a pic once again

00:26:32,690 --> 00:26:41,090
I did a disk random read test with with

00:26:38,270 --> 00:26:43,010
MSI support and here I'm comparing all

00:26:41,090 --> 00:26:46,040
of these together on IV version as well

00:26:43,010 --> 00:26:47,660
and so the user space emulator is in

00:26:46,040 --> 00:26:49,700
green where the other parts are in the

00:26:47,660 --> 00:26:50,809
same colors as before and largely you

00:26:49,700 --> 00:26:53,149
get sort of the same

00:26:50,809 --> 00:26:55,429
it's again it's not really noticeable in

00:26:53,149 --> 00:27:01,669
this context whether or not you're

00:26:55,429 --> 00:27:03,710
getting any perfect so in this context

00:27:01,669 --> 00:27:06,289
how modern is a modern VM obviously you

00:27:03,710 --> 00:27:08,570
need modern unless still but on top of

00:27:06,289 --> 00:27:11,149
that you need a pick V support so you

00:27:08,570 --> 00:27:12,710
need to be ID bridge or newer this is

00:27:11,149 --> 00:27:14,509
just so you can get the a pickaxe SVM

00:27:12,710 --> 00:27:16,940
exits which were necessary to kind of

00:27:14,509 --> 00:27:21,710
bypass going up to the to user space

00:27:16,940 --> 00:27:24,259
every time to emulate reason writes to

00:27:21,710 --> 00:27:26,029
the a pic this is also in addition to

00:27:24,259 --> 00:27:28,879
all the requirements to for a splitter

00:27:26,029 --> 00:27:32,539
acute chip so once again I ran this

00:27:28,879 --> 00:27:35,269
against a legacy guest as well that was

00:27:32,539 --> 00:27:37,480
using a Headley using the i/o a pic and

00:27:35,269 --> 00:27:40,009
the performance hit here is even greater

00:27:37,480 --> 00:27:42,499
it looks like it's probably an extra 10

00:27:40,009 --> 00:27:44,210
or 20 percent so overall it's not such a

00:27:42,499 --> 00:27:48,860
great story to be using this in a legacy

00:27:44,210 --> 00:27:52,399
context so ideally if you know you are

00:27:48,860 --> 00:27:54,559
not using such a legacy guest you could

00:27:52,399 --> 00:28:00,409
definitely use this and be a little less

00:27:54,559 --> 00:28:02,929
concerned about security it's

00:28:00,409 --> 00:28:08,090
predominantly a I want to say port of

00:28:02,929 --> 00:28:09,320
the kernel emulator i I I think one

00:28:08,090 --> 00:28:10,580
reason this could be such a big

00:28:09,320 --> 00:28:13,779
performance hit is because I did not

00:28:10,580 --> 00:28:16,789
implement the accelerations involving

00:28:13,779 --> 00:28:18,440
KVM sink regs so it's going up and down

00:28:16,789 --> 00:28:20,830
up and down from the kernel to grab the

00:28:18,440 --> 00:28:20,830
registers

00:28:31,049 --> 00:28:41,020
interesting huh so I don't know why it's

00:28:35,380 --> 00:28:43,270
not faster but yeah so like one thing

00:28:41,020 --> 00:28:45,250
for us is that even for these like newer

00:28:43,270 --> 00:28:47,320
guests we haven't needed to optimize

00:28:45,250 --> 00:28:49,179
this case but maybe it's worth actually

00:28:47,320 --> 00:28:55,960
going back and fixing up a lot of these

00:28:49,179 --> 00:29:01,210
cases so overall we were able to remove

00:28:55,960 --> 00:29:03,580
about 17 of the 41 of the his sorry

00:29:01,210 --> 00:29:05,049
these sources of 17 of the 41 historical

00:29:03,580 --> 00:29:07,480
guests Trevor will see the ease I

00:29:05,049 --> 00:29:08,950
removed about seven hundred seven

00:29:07,480 --> 00:29:11,470
thousand five hundred lines of code from

00:29:08,950 --> 00:29:13,809
KVM which is about 15% of it and with

00:29:11,470 --> 00:29:18,520
negligible performance impact for modern

00:29:13,809 --> 00:29:20,380
VMs so from future work that we could do

00:29:18,520 --> 00:29:22,179
would be actually finalizing this

00:29:20,380 --> 00:29:26,200
interface for user space instruction

00:29:22,179 --> 00:29:27,730
emulation and adding it into QAM you pay

00:29:26,200 --> 00:29:29,260
perhaps with a similar interface to

00:29:27,730 --> 00:29:32,320
split our cue chip where you actually

00:29:29,260 --> 00:29:35,140
opt into it and another thing that I

00:29:32,320 --> 00:29:36,700
would like to encourage people to do to

00:29:35,140 --> 00:29:38,110
work on is user space and thus our

00:29:36,700 --> 00:29:39,760
handling I believe they were overcome

00:29:38,110 --> 00:29:42,610
from previous conversations about this

00:29:39,760 --> 00:29:45,460
before but it could be a pretty

00:29:42,610 --> 00:29:47,190
significant security enhancement given

00:29:45,460 --> 00:29:49,660
that there have been four or five six

00:29:47,190 --> 00:29:53,730
somewhere around there CVEs and ms are

00:29:49,660 --> 00:29:57,309
handling in the past including a recent

00:29:53,730 --> 00:29:58,570
information leaked into the guest so it

00:29:57,309 --> 00:30:00,190
would be nice if we went back through

00:29:58,570 --> 00:30:01,570
and just move a lot of that to user

00:30:00,190 --> 00:30:03,220
space obviously you can't move a lot of

00:30:01,570 --> 00:30:05,169
MS are handling into user space it's a

00:30:03,220 --> 00:30:09,010
mess ours are model specific registers

00:30:05,169 --> 00:30:11,049
but being able to do so would be would

00:30:09,010 --> 00:30:12,429
be quite useful and then another thing

00:30:11,049 --> 00:30:14,799
would be actually test performance of

00:30:12,429 --> 00:30:17,080
all of these things actually against

00:30:14,799 --> 00:30:19,330
qemu instead I did all of this testing

00:30:17,080 --> 00:30:20,950
against a different user space Bamm and

00:30:19,330 --> 00:30:23,049
it be valuable if we could move this

00:30:20,950 --> 00:30:27,040
into a more generically applicable thing

00:30:23,049 --> 00:30:32,940
as well and thanks anyone have any

00:30:27,040 --> 00:30:32,940
questions could you use the microphone

00:30:37,210 --> 00:30:44,000
there are two problems actually

00:30:40,040 --> 00:30:47,690
first of all nowadays windows if it's

00:30:44,000 --> 00:30:53,410
run this factory cannot run this IP if

00:30:47,690 --> 00:30:59,030
you enable I seen a scenic support yeah

00:30:53,410 --> 00:31:01,070
so okay so that would be a concern for a

00:30:59,030 --> 00:31:06,170
user space emulator as well if you

00:31:01,070 --> 00:31:08,390
wanted to be able to use okay so we

00:31:06,170 --> 00:31:11,260
think through that I'm not entirely

00:31:08,390 --> 00:31:14,830
certain how we'd go about it cannot

00:31:11,260 --> 00:31:19,850
because this out yo'ii

00:31:14,830 --> 00:31:22,790
which is used by default in cynic how

00:31:19,850 --> 00:31:24,320
family is the AAP used when you're using

00:31:22,790 --> 00:31:28,610
a synthetic interrupt controller as well

00:31:24,320 --> 00:31:30,800
I think we cannot be used it Hanks no no

00:31:28,610 --> 00:31:38,980
no in the epic how much is the epic used

00:31:30,800 --> 00:31:38,980
I thought it had a VM call on your face

00:31:39,700 --> 00:31:43,990
it's it used them a service

00:31:44,650 --> 00:31:50,809
how are those emulated we can talk about

00:31:48,260 --> 00:31:54,530
this effort it's my way to incite Keeley

00:31:50,809 --> 00:32:07,400
emkay100 was that it's move a 2-ton

00:31:54,530 --> 00:32:14,000
kernel right now but you are saying what

00:32:07,400 --> 00:32:16,460
IP is not actually used but it's real be

00:32:14,000 --> 00:32:18,920
used for Windows it's that's one point

00:32:16,460 --> 00:32:20,690
and another point is article E is

00:32:18,920 --> 00:32:22,880
supported in re bridge

00:32:20,690 --> 00:32:25,670
yes it's supported but it's supported

00:32:22,880 --> 00:32:28,580
only high models of shown people do not

00:32:25,670 --> 00:32:40,130
buy such hard because they save money

00:32:28,580 --> 00:32:43,280
that's it so the I think the scenic

00:32:40,130 --> 00:32:46,070
turns off epic V only after you start

00:32:43,280 --> 00:32:46,770
using the scenic so the problem so you

00:32:46,070 --> 00:32:50,090
actually

00:32:46,770 --> 00:32:53,460
with epic V until Windows takes over

00:32:50,090 --> 00:32:55,830
which is a good thing because the

00:32:53,460 --> 00:32:58,020
problem with the maletto is only when

00:32:55,830 --> 00:33:01,170
you use them a Maya interface 2d epic

00:32:58,020 --> 00:33:03,030
which windows doesn't use because cynic

00:33:01,170 --> 00:33:07,140
uses a massage so you have two parts

00:33:03,030 --> 00:33:12,630
with epic V before Windows with M Mao

00:33:07,140 --> 00:33:15,090
and without epic V for Windows with

00:33:12,630 --> 00:33:20,250
themselves both of them should work in

00:33:15,090 --> 00:33:23,190
theory okay the second is obvious but

00:33:20,250 --> 00:33:27,000
then you just don't do it yeah all

00:33:23,190 --> 00:33:29,130
processor a small pause I guess so let

00:33:27,000 --> 00:33:30,140
me go to my notes I didn't want to drop

00:33:29,130 --> 00:33:33,990
you while you were talking

00:33:30,140 --> 00:33:35,280
the IOA epic issue were you saying you

00:33:33,990 --> 00:33:36,810
you basically have to bounce off to use

00:33:35,280 --> 00:33:39,540
a space for all you your eyes and for

00:33:36,810 --> 00:33:41,100
you register reads yeah especially the

00:33:39,540 --> 00:33:42,780
register register reads but maybe even

00:33:41,100 --> 00:33:45,450
the writes could you just use a share

00:33:42,780 --> 00:33:47,610
page so go to the share page thing with

00:33:45,450 --> 00:33:49,080
it what we do with the CPUs I think we

00:33:47,610 --> 00:33:50,690
had something similar for SD 90

00:33:49,080 --> 00:33:52,770
somewhere

00:33:50,690 --> 00:33:54,720
there might be some clever way to get

00:33:52,770 --> 00:33:55,980
that work but the default interface for

00:33:54,720 --> 00:33:58,680
the i/o a pic is this weird like

00:33:55,980 --> 00:34:01,530
register select like you select a window

00:33:58,680 --> 00:34:03,840
and then you write to some other port

00:34:01,530 --> 00:34:06,260
thing to like get all that to work and

00:34:03,840 --> 00:34:08,909
so I'm not really sure how you kind of

00:34:06,260 --> 00:34:11,490
force those things together and part of

00:34:08,909 --> 00:34:13,409
the point of this is just like even so

00:34:11,490 --> 00:34:15,060
that would let us optimize sort of the

00:34:13,409 --> 00:34:17,250
legacy case which is what we weren't

00:34:15,060 --> 00:34:19,380
even that concerned about like even with

00:34:17,250 --> 00:34:22,310
this it was only something like a tennis

00:34:19,380 --> 00:34:24,440
percent performance it for disuse so

00:34:22,310 --> 00:34:27,810
maybe that's actually not a huge concern

00:34:24,440 --> 00:34:29,040
right no but yeah you right I mean and

00:34:27,810 --> 00:34:31,440
you would still need this much later

00:34:29,040 --> 00:34:34,050
because you still have a now Myo

00:34:31,440 --> 00:34:35,940
interface that's awful for the for the

00:34:34,050 --> 00:34:37,409
epic you are talking that you are saying

00:34:35,940 --> 00:34:39,149
that you basically had to invent a new

00:34:37,409 --> 00:34:41,790
user space interface to push things back

00:34:39,149 --> 00:34:43,200
into into the lay pick into in the

00:34:41,790 --> 00:34:45,360
kernel yeah so to go back from user

00:34:43,200 --> 00:34:45,870
space down into the kernel do that but

00:34:45,360 --> 00:34:49,050
do it right

00:34:45,870 --> 00:34:51,899
create a new device interface which is

00:34:49,050 --> 00:34:53,700
something that x86 has been like oh it

00:34:51,899 --> 00:34:55,169
was was around but able to get around

00:34:53,700 --> 00:34:56,490
because with it because they were only

00:34:55,169 --> 00:34:58,560
using legacy interfaces they were there

00:34:56,490 --> 00:35:00,810
before the the device APA was there but

00:34:58,560 --> 00:35:02,670
just create a device for your lay pig

00:35:00,810 --> 00:35:04,290
and then just use our clothes on that

00:35:02,670 --> 00:35:07,500
device because I mean that's the normal

00:35:04,290 --> 00:35:08,970
object way yeah don't invent I just

00:35:07,500 --> 00:35:09,990
don't don't follow the normal x86 let's

00:35:08,970 --> 00:35:16,140
look at the other architectures that you

00:35:09,990 --> 00:35:17,310
would much better the the injecting an

00:35:16,140 --> 00:35:19,290
interrupt back into the light pick

00:35:17,310 --> 00:35:22,860
directly one yeah there's just I mean

00:35:19,290 --> 00:35:24,810
you you just create don't don't invent a

00:35:22,860 --> 00:35:27,780
new article basically and then for the

00:35:24,810 --> 00:35:29,100
instruction emulation it might be you

00:35:27,780 --> 00:35:31,890
might be able to get away with something

00:35:29,100 --> 00:35:33,270
similar to what armed us so I obviously

00:35:31,890 --> 00:35:36,450
don't get hub activation for everything

00:35:33,270 --> 00:35:39,290
but so arm only it's only able to cover

00:35:36,450 --> 00:35:42,090
like five percent or so of all mio exits

00:35:39,290 --> 00:35:44,990
in hardware and you could do the same in

00:35:42,090 --> 00:35:47,430
KVM you could only look at like the top

00:35:44,990 --> 00:35:50,210
five percent of instructions that really

00:35:47,430 --> 00:35:52,740
do get used for normal operation mi OS

00:35:50,210 --> 00:35:55,170
emulate those and in the kernel and just

00:35:52,740 --> 00:35:56,610
forward all the odd oddball cases that

00:35:55,170 --> 00:35:58,830
nobody really cares about with like ten

00:35:56,610 --> 00:36:07,290
prefixes in front of something all of

00:35:58,830 --> 00:36:08,850
that into in the user space every

00:36:07,290 --> 00:36:10,350
instruction so the comment was that

00:36:08,850 --> 00:36:12,060
every inspection can can touch memory

00:36:10,350 --> 00:36:13,950
yes that's true a bit such in Kenema we

00:36:12,060 --> 00:36:16,350
can touch my movie but just for file

00:36:13,950 --> 00:36:18,150
what Linux does usually what because you

00:36:16,350 --> 00:36:19,950
usually access things using we del Y del

00:36:18,150 --> 00:36:21,570
whatever they're all very limited

00:36:19,950 --> 00:36:25,650
instructions that you actually do care

00:36:21,570 --> 00:36:28,410
about on on like you usually access

00:36:25,650 --> 00:36:30,420
patterns so don't I mean yes you can

00:36:28,410 --> 00:36:31,920
access everything but every like you

00:36:30,420 --> 00:36:34,740
have about a couple of thousand

00:36:31,920 --> 00:36:37,050
instructions that can access your new

00:36:34,740 --> 00:36:47,370
memory but you don't have to be fast on

00:36:37,050 --> 00:36:49,950
all of those sometimes and then was many

00:36:47,370 --> 00:36:52,260
years ago doing this it had like three

00:36:49,950 --> 00:36:54,330
instructions decoder those were olden in

00:36:52,260 --> 00:36:56,550
the hypervisor so it's different but it

00:36:54,330 --> 00:36:58,470
wasn't really pleasant to maintain so

00:36:56,550 --> 00:37:00,060
you have to kind of find the balance

00:36:58,470 --> 00:37:02,070
it's just profile and see if it's only

00:37:00,060 --> 00:37:05,820
ten instructions I would say it might be

00:37:02,070 --> 00:37:07,860
worth to put in the kernel one thing if

00:37:05,820 --> 00:37:09,510
you are going to send the patches sooner

00:37:07,860 --> 00:37:12,180
or later I would like to keep the

00:37:09,510 --> 00:37:14,130
instruction fetch in the kernel like

00:37:12,180 --> 00:37:15,990
because you have like AMD decode

00:37:14,130 --> 00:37:19,440
cysts that actually tells you already

00:37:15,990 --> 00:37:23,339
the instruction length BMX it's time for

00:37:19,440 --> 00:37:25,410
example so I would like QA more the user

00:37:23,339 --> 00:37:28,500
space to actually get the instruction

00:37:25,410 --> 00:37:30,359
bytes already as part of the VM exit if

00:37:28,500 --> 00:37:31,140
possible but I don't remember exactly

00:37:30,359 --> 00:37:34,859
how that works

00:37:31,140 --> 00:37:36,569
oh yeah me neither honestly but I know

00:37:34,859 --> 00:37:39,089
that at least the instruction length is

00:37:36,569 --> 00:37:40,740
there and Polly Thomas Linda key from

00:37:39,089 --> 00:37:43,349
Mindy is going to talk about this

00:37:40,740 --> 00:37:45,410
tomorrow in his talk I think I see my

00:37:43,349 --> 00:37:50,400
mother being some weird issue with that

00:37:45,410 --> 00:37:53,369
so but anyway this is just the only

00:37:50,400 --> 00:37:55,740
thing that is known obvious in how I

00:37:53,369 --> 00:37:59,730
would design the emulation I'm sure that

00:37:55,740 --> 00:38:01,650
we would agree on everything else so hi

00:37:59,730 --> 00:38:04,740
I just wanted to ask if you've thought

00:38:01,650 --> 00:38:07,769
about code reuse because it's a little

00:38:04,740 --> 00:38:10,259
sad to see you do this because once

00:38:07,769 --> 00:38:12,299
you've done it who's gonna care about

00:38:10,259 --> 00:38:15,240
the security of this code that's still

00:38:12,299 --> 00:38:16,259
in the KVM kernel module the things that

00:38:15,240 --> 00:38:19,529
are performance

00:38:16,259 --> 00:38:21,630
you know relevant you've added an option

00:38:19,529 --> 00:38:23,640
but I've guessed that from now on Google

00:38:21,630 --> 00:38:25,049
won't care about that code anymore it's

00:38:23,640 --> 00:38:26,640
nice to know that you guys are working

00:38:25,049 --> 00:38:29,730
on making it secure and keeping it

00:38:26,640 --> 00:38:31,410
secure so if we could reuse the code for

00:38:29,730 --> 00:38:34,019
example the instruction emulator which

00:38:31,410 --> 00:38:37,019
is just you know input/output taking

00:38:34,019 --> 00:38:38,609
state if we could reuse that and

00:38:37,019 --> 00:38:40,470
literally just move the same code to

00:38:38,609 --> 00:38:42,599
user space then we know that if the

00:38:40,470 --> 00:38:45,089
security bug there gets fixed it'll get

00:38:42,599 --> 00:38:48,660
fixed in both places so the thing is

00:38:45,089 --> 00:38:50,519
killing me already it actually has a

00:38:48,660 --> 00:38:52,980
user it already has a user space

00:38:50,519 --> 00:38:56,279
instruction emulator for the the context

00:38:52,980 --> 00:38:57,240
where you're actually hope I said it's

00:38:56,279 --> 00:39:00,269
wrong me to present know what else

00:38:57,240 --> 00:39:01,410
should take over just yeah it works I

00:39:00,269 --> 00:39:02,910
know what you're going wrong wrong

00:39:01,410 --> 00:39:05,670
direction one direction we had this

00:39:02,910 --> 00:39:07,740
about eight years ago where the original

00:39:05,670 --> 00:39:10,380
KVM implementation in the kernel

00:39:07,740 --> 00:39:12,210
actually didn't only handle 64-bit like

00:39:10,380 --> 00:39:13,529
virtual mode and nothing else and

00:39:12,210 --> 00:39:16,259
everything was done in human there was

00:39:13,529 --> 00:39:19,410
this really insane dyd interface that

00:39:16,259 --> 00:39:20,759
that basically allowed all the cpus de

00:39:19,410 --> 00:39:23,549
to be transferred between kernel and

00:39:20,759 --> 00:39:24,890
user space and eventually people broke

00:39:23,549 --> 00:39:26,480
their necks on that and

00:39:24,890 --> 00:39:28,520
decided it was a bad idea and gave up on

00:39:26,480 --> 00:39:31,130
it don't go down that path don't don't

00:39:28,520 --> 00:39:40,490
use the qmu emulator for all the state

00:39:31,130 --> 00:39:42,230
that you have it just doesn't work so do

00:39:40,490 --> 00:39:44,420
you have any more thoughts on is it

00:39:42,230 --> 00:39:48,110
possible to just reuse the same code

00:39:44,420 --> 00:39:50,180
whether it's in QEMU kernel or maybe

00:39:48,110 --> 00:39:51,980
even in google's vmm because it would be

00:39:50,180 --> 00:39:54,860
a shame to split it and then have to do

00:39:51,980 --> 00:39:58,130
several bug fixes I assume there would

00:39:54,860 --> 00:39:59,690
be some way to actually make this

00:39:58,130 --> 00:40:01,190
slightly more portable it would be way

00:39:59,690 --> 00:40:03,710
more ideal right because I would prefer

00:40:01,190 --> 00:40:05,870
to not have to like maintain my own user

00:40:03,710 --> 00:40:10,070
space version as well like that's likely

00:40:05,870 --> 00:40:14,150
to also rot in code not being a paying

00:40:10,070 --> 00:40:15,500
attention to l but I'm not entirely

00:40:14,150 --> 00:40:17,720
certain what the right way to refactor

00:40:15,500 --> 00:40:21,970
all of these details are to make it so

00:40:17,720 --> 00:40:21,970
that you only have one version overall

00:40:24,580 --> 00:40:29,210
just to respond we actually did take the

00:40:26,900 --> 00:40:31,250
emulate C file from the kernel and pull

00:40:29,210 --> 00:40:33,020
it in user space in our VM M so we did

00:40:31,250 --> 00:40:34,340
most of that it took a lot of massaging

00:40:33,020 --> 00:40:36,140
and actually get it to work and getting

00:40:34,340 --> 00:40:38,360
it to compile because it it makes some

00:40:36,140 --> 00:40:41,740
ugly assumptions about GCC that are

00:40:38,360 --> 00:40:41,740
always true that aren't always true but

00:40:42,880 --> 00:40:47,810
any other questions well thank you

00:40:47,480 --> 00:40:49,990
everyone

00:40:47,810 --> 00:40:49,990
and

00:40:52,059 --> 00:40:54,119

YouTube URL: https://www.youtube.com/watch?v=vj5PA_D03Vg


