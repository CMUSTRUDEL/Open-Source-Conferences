Title: [2016] Lightning Talk: Nested VMX Migration by Jim Mattson & David Matlack
Publication date: 2016-09-05
Playlist: KVM Forum 2016
Description: 
	How to live migrate virtual machine using nested vmx support.

Jim Mattson
Google, Software Engineer

David Matlack
Google
Captions: 
	00:00:09,559 --> 00:00:16,830
okay so I I'm David Matlack from google

00:00:13,530 --> 00:00:18,810
and I'm gym mats and also from google so

00:00:16,830 --> 00:00:22,710
I've rather recently we've been working

00:00:18,810 --> 00:00:26,490
on allowing a virtual machine that's

00:00:22,710 --> 00:00:30,330
using the nested vmx support to be live

00:00:26,490 --> 00:00:33,690
migrated so there's kind of two

00:00:30,330 --> 00:00:35,960
components of this work one half of it

00:00:33,690 --> 00:00:39,000
that I've been doing which is allowing a

00:00:35,960 --> 00:00:42,170
vm that's using nested vmx to live

00:00:39,000 --> 00:00:45,960
migrate across different versions of kvm

00:00:42,170 --> 00:00:48,450
where you know version a of kvm supports

00:00:45,960 --> 00:00:50,730
some set of the nested vmx features and

00:00:48,450 --> 00:00:53,090
version B supports some different set of

00:00:50,730 --> 00:00:56,520
those features and also across different

00:00:53,090 --> 00:00:59,010
cpu types so some of the kvm will only

00:00:56,520 --> 00:01:01,079
virtualize certain vmx features if the

00:00:59,010 --> 00:01:05,369
host also has the support for those

00:01:01,079 --> 00:01:08,880
features so the way you handle this is

00:01:05,369 --> 00:01:12,360
there are BMX capability MSRs that

00:01:08,880 --> 00:01:15,540
advertise what features are supported so

00:01:12,360 --> 00:01:17,159
kvm advertises these msrs to guests

00:01:15,540 --> 00:01:19,880
guests read these ms ours and they only

00:01:17,159 --> 00:01:24,420
use the features that are supported so

00:01:19,880 --> 00:01:27,000
we can add these ms ours to the virtual

00:01:24,420 --> 00:01:29,390
machine savestate kvm just has to be

00:01:27,000 --> 00:01:32,250
taught how to restore these ms ours

00:01:29,390 --> 00:01:34,220
currently kvm you know advertises as

00:01:32,250 --> 00:01:38,640
many features as it can make available

00:01:34,220 --> 00:01:40,920
the short story is when restoring these

00:01:38,640 --> 00:01:44,430
ms ours if they are subset of what kvm

00:01:40,920 --> 00:01:46,500
and the cpu support it's valid and you

00:01:44,430 --> 00:01:49,049
can do a restore if they're not then

00:01:46,500 --> 00:01:52,200
it's an incompatible migration so for

00:01:49,049 --> 00:01:57,840
example you could not start a virtual

00:01:52,200 --> 00:02:00,509
machine on you know a very modern CPU

00:01:57,840 --> 00:02:02,369
that supports some advanced feature and

00:02:00,509 --> 00:02:04,710
then migrated to an older cpu that does

00:02:02,369 --> 00:02:08,090
not support that feature but this you

00:02:04,710 --> 00:02:08,090
know would be handled at a higher level

00:02:08,179 --> 00:02:13,870
over gym for the

00:02:10,980 --> 00:02:15,220
okay and the other thing I had to what

00:02:13,870 --> 00:02:17,500
David was saying is that this means that

00:02:15,220 --> 00:02:21,220
these vmx capability ms ours which are

00:02:17,500 --> 00:02:24,010
currently defined once in the kvm module

00:02:21,220 --> 00:02:25,840
are going to have to be defying / / bc

00:02:24,010 --> 00:02:29,890
few actually so what I've been looking

00:02:25,840 --> 00:02:32,409
at is doing the migration of BMX state

00:02:29,890 --> 00:02:35,110
essentially and you know there are a

00:02:32,409 --> 00:02:37,150
bunch of I octaves now for get and set

00:02:35,110 --> 00:02:39,340
various pieces of state their registers

00:02:37,150 --> 00:02:41,980
the system registers the MSR is you know

00:02:39,340 --> 00:02:44,530
there's a long laundry list X save XC

00:02:41,980 --> 00:02:46,000
ours I don't know if I can list them all

00:02:44,530 --> 00:02:48,970
and and you would think well we'll just

00:02:46,000 --> 00:02:51,190
add BMX state and I'll you know round

00:02:48,970 --> 00:02:54,040
out the list but there's a bit of a

00:02:51,190 --> 00:02:57,220
problem with us restoring the vmx state

00:02:54,040 --> 00:02:59,470
which is that if you're restoring and

00:02:57,220 --> 00:03:02,139
this is going to get technically into

00:02:59,470 --> 00:03:04,870
details of nested VMs that maybe some of

00:03:02,139 --> 00:03:09,370
you are going to be bored with but if

00:03:04,870 --> 00:03:12,400
you restore the BMX state last then

00:03:09,370 --> 00:03:18,699
you've restored s reges like CR three CR

00:03:12,400 --> 00:03:20,620
400 into vmc s01 and then we restore the

00:03:18,699 --> 00:03:24,519
vmx state at the end you're going to

00:03:20,620 --> 00:03:26,919
actually want to make vmc s0 to live now

00:03:24,519 --> 00:03:29,169
is that state you just restored was that

00:03:26,919 --> 00:03:32,349
the state of the nested guest in which

00:03:29,169 --> 00:03:34,030
case that you're going to vm cs0 to you

00:03:32,349 --> 00:03:36,010
know one way of handling this is you

00:03:34,030 --> 00:03:39,940
restore always restore the BMX state

00:03:36,010 --> 00:03:41,290
first I've kind of leaned away from

00:03:39,940 --> 00:03:43,900
doing this because it seems like the

00:03:41,290 --> 00:03:46,030
existing I octaves allow you to restore

00:03:43,900 --> 00:03:49,120
the existing pieces of state and pretty

00:03:46,030 --> 00:03:51,849
much any order you like I haven't looked

00:03:49,120 --> 00:03:54,459
into how they deal with illegal machine

00:03:51,849 --> 00:03:57,310
states that are comprised of pieces from

00:03:54,459 --> 00:04:00,010
two different sets like s reges sets CR

00:03:57,310 --> 00:04:02,829
0 and C are four and then restoring

00:04:00,010 --> 00:04:06,040
restoring msrs restores efird you might

00:04:02,829 --> 00:04:08,919
have an invalid combination of efer and

00:04:06,040 --> 00:04:10,449
CR 0 and 0 4 and you know if you restore

00:04:08,919 --> 00:04:11,590
them in one order that it looks like

00:04:10,449 --> 00:04:15,790
they're okay and the other over there

00:04:11,590 --> 00:04:19,090
and lot but anyway I was so I was

00:04:15,790 --> 00:04:20,590
thinking that maybe a better approach to

00:04:19,090 --> 00:04:24,100
all this would be to have

00:04:20,590 --> 00:04:25,690
one blob of the CPU state that you

00:04:24,100 --> 00:04:28,510
restored instead of all these bits and

00:04:25,690 --> 00:04:30,699
pieces and you could basically have a

00:04:28,510 --> 00:04:33,250
structure that always grows at the tail

00:04:30,699 --> 00:04:37,120
and and there's one I I octal to ask how

00:04:33,250 --> 00:04:38,889
big is the structure that contains the

00:04:37,120 --> 00:04:40,960
vcpu state and then whatever you get

00:04:38,889 --> 00:04:41,770
back there's some amount at the

00:04:40,960 --> 00:04:43,120
beginning that you're going to

00:04:41,770 --> 00:04:45,400
understand and then some of mount

00:04:43,120 --> 00:04:47,830
perhaps at the end that you're not going

00:04:45,400 --> 00:04:50,229
to understand if you live migrate this

00:04:47,830 --> 00:04:53,400
if you migrate the state to say an older

00:04:50,229 --> 00:04:55,780
version of kvm or something like that

00:04:53,400 --> 00:04:59,320
anyway I wanted to talk to anyone who's

00:04:55,780 --> 00:05:03,610
interested in how best to design save

00:04:59,320 --> 00:05:05,889
and restore of the state of a DM that's

00:05:03,610 --> 00:05:08,950
using the nested enhancements

00:05:05,889 --> 00:05:14,340
particularly BMX I haven't really looked

00:05:08,950 --> 00:05:14,340

YouTube URL: https://www.youtube.com/watch?v=Q2l02Pblqis


