Title: [2016] Experience in Developing a Driver for a Complex New Hardware Device  by Knut Omang
Publication date: 2016-08-31
Playlist: KVM Forum 2016
Description: 
	In this presentation Knut Omang will talk about how he has been deploying a patched version of QEMU/KVM as part of a framework to enable writing an almost functionally complete device driver for a complex new network device before any hardware was available. Different levels of simulation/emulation has different benefits and challenges. Detailed low level simulation of hardware is accurate but painfully slow. High level simulation/emulation is fast enough to run real workloads, but with somewhat lower precision. QEMU/KVM with device hot plugging allows recompiling/relinking/restarting different device models while keeping the guest(s) running. Even after availablity of hardware, the QEMU anchored models are valuable tools, as some testing can be run on the models, saving expensive server hardware, and also simplifying monitoring of traffic between device and driver.

Knut Omang
Oracle, Principal Software Engineer
Oslo, Norway

Knut Omang has been using and championing the use of virtualization for testing for many years. He is currently working for Oracle as the lead developer of a Linux driver and user space library for Oracle's new Infiniband HCA. He has been an early user/adopter of the Q35/PCIe based Qemu machine type, where he also has contributed a few patches such as the initial work on a virtual Intel IOMMU and SR/IOV support. He holds a Ph.D in computer networks from the University of Oslo, 1998. He also holds a part time position as associate professor at the University of Oslo, where he is lecturing and supervising students.

Slides: http://www.linux-kvm.org/images/c/c2/01x01-Knut_Omang-Experience_in_Developing_a_Driver_for_a_Complex_New_Hardware_Device_in_QEMU_KVM.pdf
Captions: 
	00:00:09,469 --> 00:00:18,029
I'm excited to finally be starting here

00:00:14,120 --> 00:00:20,520
after I attended this is my taste

00:00:18,029 --> 00:00:22,230
chagum forming guru and find that and

00:00:20,520 --> 00:00:26,279
talk about what I mean during all the

00:00:22,230 --> 00:00:31,230
time so just to give a few words about

00:00:26,279 --> 00:00:35,969
myself I grew up with the the fathers of

00:00:31,230 --> 00:00:41,370
object-oriented programming my master

00:00:35,969 --> 00:00:46,530
thesis for one of the fathers of Simula

00:00:41,370 --> 00:00:51,239
I so I made a computer science

00:00:46,530 --> 00:00:55,710
background but then I ended up working

00:00:51,239 --> 00:00:59,699
on very exciting projects on our DNA

00:00:55,710 --> 00:01:08,220
back in the nineteen nineties and I took

00:00:59,699 --> 00:01:10,920
my PhD and very performance supid and

00:01:08,220 --> 00:01:13,110
then I went ahead and worked for several

00:01:10,920 --> 00:01:16,140
companies before I went back to work on

00:01:13,110 --> 00:01:19,439
our DNA again about the same time I

00:01:16,140 --> 00:01:23,689
started to attend caviar for the

00:01:19,439 --> 00:01:26,759
conference's the team that I work for is

00:01:23,689 --> 00:01:29,400
located or a kind of based out of Oslo

00:01:26,759 --> 00:01:33,720
we have people in several life in

00:01:29,400 --> 00:01:35,790
general right they have several people

00:01:33,720 --> 00:01:39,689
throughout the organization in Oracle

00:01:35,790 --> 00:01:42,500
but much of the root of the project is

00:01:39,689 --> 00:01:42,500
from

00:01:42,530 --> 00:01:47,870
but the older an old norwegian company

00:01:45,050 --> 00:01:52,820
called most data which made mainframes

00:01:47,870 --> 00:01:55,670
they can do a test and we have them and

00:01:52,820 --> 00:01:59,270
only that the people at work in this

00:01:55,670 --> 00:02:01,250
department have been required from

00:01:59,270 --> 00:02:03,710
within several companies over the years

00:02:01,250 --> 00:02:06,350
but some of them have kept the same

00:02:03,710 --> 00:02:11,680
office in the same building all the way

00:02:06,350 --> 00:02:16,520
along and this company was so this

00:02:11,680 --> 00:02:18,560
started was that acquired my son and son

00:02:16,520 --> 00:02:21,560
was an acquired by Oracle and that's how

00:02:18,560 --> 00:02:27,739
this group of people ended up working

00:02:21,560 --> 00:02:36,650
for Oracle and I joined them so the

00:02:27,739 --> 00:02:40,160
agenda for today is a project our

00:02:36,650 --> 00:02:43,730
project I'll talk a little bit about the

00:02:40,160 --> 00:02:49,150
target for our development and I'll talk

00:02:43,730 --> 00:02:52,880
about goals and why we ended up using

00:02:49,150 --> 00:02:55,100
virtualization thank you and give you

00:02:52,880 --> 00:02:57,680
some a little bit of taste on kind of

00:02:55,100 --> 00:03:01,790
high-level test or the the tool sets

00:02:57,680 --> 00:03:06,140
that we have been developing some of the

00:03:01,790 --> 00:03:10,450
use cases and a little bit about what we

00:03:06,140 --> 00:03:10,450
achieved and what we could have achieved

00:03:14,240 --> 00:03:23,660
so this is a picture of the device under

00:03:19,150 --> 00:03:27,170
test or in fact the device that we

00:03:23,660 --> 00:03:31,100
didn't have vacuumed when I started on

00:03:27,170 --> 00:03:35,830
this project the voice existed only as a

00:03:31,100 --> 00:03:39,080
few lines of RTL in the hardware good

00:03:35,830 --> 00:03:44,720
but this is this is what we now have

00:03:39,080 --> 00:03:49,600
available the topmost entries here are

00:03:44,720 --> 00:03:53,090
the PCI Express for factors of this card

00:03:49,600 --> 00:03:56,210
the bottom is the one that's in children

00:03:53,090 --> 00:04:02,960
integrated into the spark the news part

00:03:56,210 --> 00:04:05,500
CPUs and it's a very complicated piece

00:04:02,960 --> 00:04:05,500
of hardware

00:04:05,990 --> 00:04:14,510
it is a highly asynchronous model it

00:04:11,000 --> 00:04:17,660
supports a lot of fancy features like SR

00:04:14,510 --> 00:04:23,210
Iove it has integrated the virtual

00:04:17,660 --> 00:04:27,080
switches and it has very sophisticated a

00:04:23,210 --> 00:04:30,800
menu which is compatible with the CPU

00:04:27,080 --> 00:04:34,880
page tables and it also has a lot of

00:04:30,800 --> 00:04:42,110
hardware features for uploading if I be

00:04:34,880 --> 00:04:47,570
an IPO variety so for those of you not

00:04:42,110 --> 00:04:51,230
familiar with InfiniBand in cinnamon

00:04:47,570 --> 00:04:55,460
color is kind of different from Ethernet

00:04:51,230 --> 00:05:01,460
in that it is the standard is kind of

00:04:55,460 --> 00:05:05,210
defined both by software and harder the

00:05:01,460 --> 00:05:07,980
host channel adapter which is a phenom

00:05:05,210 --> 00:05:11,760
and standard term

00:05:07,980 --> 00:05:14,670
equals a network adapter but it defines

00:05:11,760 --> 00:05:17,000
all the set of operations to support it

00:05:14,670 --> 00:05:19,610
doesn't doesn't have a partner or

00:05:17,000 --> 00:05:23,880
software is going to implement it and

00:05:19,610 --> 00:05:26,400
the standard depart defines the ref

00:05:23,880 --> 00:05:29,580
semantics of the verbs the requirements

00:05:26,400 --> 00:05:31,920
but not the same text and implementation

00:05:29,580 --> 00:05:35,520
so that means that there are quite a lot

00:05:31,920 --> 00:05:42,060
of room for implementation differences

00:05:35,520 --> 00:05:44,730
and challenges in that area so the Linux

00:05:42,060 --> 00:05:48,720
implementation is what many of you know

00:05:44,730 --> 00:05:54,180
as the RMA or remote direct memory

00:05:48,720 --> 00:05:56,370
access support we used back in the old

00:05:54,180 --> 00:05:58,680
days we used to call this a shared

00:05:56,370 --> 00:06:07,320
address space or remote address space

00:05:58,680 --> 00:06:12,200
but our DMA is the modern term for it it

00:06:07,320 --> 00:06:15,780
has a kernel and a user space part and

00:06:12,200 --> 00:06:19,680
the kernel and user space interfaces are

00:06:15,780 --> 00:06:21,390
quite similar about the reason why we

00:06:19,680 --> 00:06:23,730
have a user space part is because we

00:06:21,390 --> 00:06:29,760
have they want to be able to bypass the

00:06:23,730 --> 00:06:34,080
kernel for as much as possible and the

00:06:29,760 --> 00:06:38,100
standard is quite least more than 2500

00:06:34,080 --> 00:06:43,530
pages but still there are details that

00:06:38,100 --> 00:06:47,760
are left for two implementations so this

00:06:43,530 --> 00:06:51,990
felt a bit like this guy here which is a

00:06:47,760 --> 00:06:55,430
regard from an original adventure all

00:06:51,990 --> 00:06:58,760
over North adventure and this

00:06:55,430 --> 00:07:01,580
you glittering in there is the castle

00:06:58,760 --> 00:07:04,040
where the princesses have been captured

00:07:01,580 --> 00:07:06,770
by the trolls and this guy is going to

00:07:04,040 --> 00:07:12,050
rescue and nobody believes that he will

00:07:06,770 --> 00:07:15,650
ever make it so what was challenging for

00:07:12,050 --> 00:07:19,510
me in this project was that we were able

00:07:15,650 --> 00:07:24,890
to get in early before progress even

00:07:19,510 --> 00:07:27,290
made we could kind of start the software

00:07:24,890 --> 00:07:29,090
team will come left to itself in the

00:07:27,290 --> 00:07:34,090
beginning so we were free to do whatever

00:07:29,090 --> 00:07:36,980
shape the project in every salt useful

00:07:34,090 --> 00:07:39,490
so it was kind of an event true so

00:07:36,980 --> 00:07:45,740
that's why I think this is them

00:07:39,490 --> 00:07:48,620
illustration needs as you might well do

00:07:45,740 --> 00:07:56,780
tools is often hard to work when you

00:07:48,620 --> 00:07:59,270
have a big task but to get them tools

00:07:56,780 --> 00:08:01,970
you need to pay for it in some way

00:07:59,270 --> 00:08:04,820
the you can probably get this one at the

00:08:01,970 --> 00:08:07,700
garage sale for the net for burger at a

00:08:04,820 --> 00:08:12,110
garage sale for free almost but you have

00:08:07,700 --> 00:08:15,470
to pay some more to get this right hand

00:08:12,110 --> 00:08:20,120
side too but the quality would be much

00:08:15,470 --> 00:08:22,550
better so we had decided we need to do

00:08:20,120 --> 00:08:24,590
this we have been out there and on

00:08:22,550 --> 00:08:28,160
projects like this the force we knew we

00:08:24,590 --> 00:08:31,850
had to really invest in the tooling to

00:08:28,160 --> 00:08:36,020
be able to to get accomplished what we

00:08:31,850 --> 00:08:42,050
wanted to so some of the survival rules

00:08:36,020 --> 00:08:46,250
we Pratap was that we wanted to set time

00:08:42,050 --> 00:08:47,990
aside to develop tools and as you know

00:08:46,250 --> 00:08:49,279
it's very easy to get the answer that

00:08:47,990 --> 00:08:52,100
yes that's a

00:08:49,279 --> 00:08:57,139
idea just threw that long as it doesn't

00:08:52,100 --> 00:08:59,509
take any time but we managed any writer

00:08:57,139 --> 00:09:01,999
panel because the challenge is of course

00:08:59,509 --> 00:09:04,670
that if you need to write good tools you

00:09:01,999 --> 00:09:07,490
you will spend time without tools and in

00:09:04,670 --> 00:09:10,399
the meantime nothing happens on the

00:09:07,490 --> 00:09:14,410
coding side if you don't have a lot of

00:09:10,399 --> 00:09:21,889
people which we didn't the other

00:09:14,410 --> 00:09:24,920
fundamental success criteria was that we

00:09:21,889 --> 00:09:28,519
decided we want to write the software as

00:09:24,920 --> 00:09:31,579
it was going to be released to start

00:09:28,519 --> 00:09:34,670
with we didn't want to have a lot of

00:09:31,579 --> 00:09:37,639
stuff in the test environment and else

00:09:34,670 --> 00:09:40,519
something else we wanted to be able to

00:09:37,639 --> 00:09:45,800
have the code start writing the recalled

00:09:40,519 --> 00:09:49,610
from the beginning and we did that also

00:09:45,800 --> 00:09:51,470
because we realized that we have to have

00:09:49,610 --> 00:09:53,899
a lot of tests there's lots of

00:09:51,470 --> 00:09:56,750
dimensions that we need to cover to be

00:09:53,899 --> 00:09:59,360
able to deliver something on this and we

00:09:56,750 --> 00:10:02,000
needed to have those tests not only

00:09:59,360 --> 00:10:03,829
working during the tests or the tests

00:10:02,000 --> 00:10:08,540
that we wanted to be able to use the

00:10:03,829 --> 00:10:11,990
same tests in also when they receive

00:10:08,540 --> 00:10:15,199
hardware so that means that when that

00:10:11,990 --> 00:10:17,059
pie api's was very important for us so

00:10:15,199 --> 00:10:22,069
we tried to define the API was at

00:10:17,059 --> 00:10:25,790
various points in in our test bed so

00:10:22,069 --> 00:10:27,800
that we could do as much you reuse as

00:10:25,790 --> 00:10:30,259
much as possible or what we developed

00:10:27,800 --> 00:10:34,670
for different kind of scenarios as we

00:10:30,259 --> 00:10:38,500
move forward and we also decided very

00:10:34,670 --> 00:10:43,000
early to to do test-driven development

00:10:38,500 --> 00:10:44,140
not test driven to the extreme sense but

00:10:43,000 --> 00:10:48,450
you

00:10:44,140 --> 00:10:51,880
the sense that whenever we have my issue

00:10:48,450 --> 00:10:54,430
work that is serious enough we write a

00:10:51,880 --> 00:10:56,500
test for it and they provide a test so

00:10:54,430 --> 00:11:01,630
that that will never happen again that

00:10:56,500 --> 00:11:05,680
error and that has been a great success

00:11:01,630 --> 00:11:08,800
and we also early on deployed continuous

00:11:05,680 --> 00:11:13,839
integration with Jenkins and we also

00:11:08,800 --> 00:11:19,630
added after a while Jared and we check

00:11:13,839 --> 00:11:21,970
all our commits through that I'll come

00:11:19,630 --> 00:11:26,730
back to that details in that so our

00:11:21,970 --> 00:11:29,860
motivation for using virtualization of

00:11:26,730 --> 00:11:31,930
course to be able to start early we need

00:11:29,860 --> 00:11:35,100
we didn't have any hardware we needed to

00:11:31,930 --> 00:11:40,420
create a fake hardware environment and

00:11:35,100 --> 00:11:42,399
we needed to and I also needed from my

00:11:40,420 --> 00:11:46,060
understanding as a software they need to

00:11:42,399 --> 00:11:48,820
get more insight into how PCI Express

00:11:46,060 --> 00:11:51,490
worked since the last time I worked on

00:11:48,820 --> 00:11:53,980
the driver it was a PCIe driver so what

00:11:51,490 --> 00:11:56,680
was this PCI Express thing I have a long

00:11:53,980 --> 00:12:01,390
way to go so I spent a lot of time

00:11:56,680 --> 00:12:03,220
reading iqra called them to understand

00:12:01,390 --> 00:12:05,860
what was going on and of course the

00:12:03,220 --> 00:12:10,079
standards but but it's really useful to

00:12:05,860 --> 00:12:13,779
be able to have emulation to look at

00:12:10,079 --> 00:12:15,730
another challenge we had was that since

00:12:13,779 --> 00:12:18,880
we have been working with Hardware

00:12:15,730 --> 00:12:22,300
broken hardware before in our team as a

00:12:18,880 --> 00:12:27,089
software team we really wanted to avoid

00:12:22,300 --> 00:12:29,920
having to solve very difficult problems

00:12:27,089 --> 00:12:33,760
or work around very different Hardware

00:12:29,920 --> 00:12:35,649
the difficult hardware issues also type

00:12:33,760 --> 00:12:38,110
out so we really wanted to be able to

00:12:35,649 --> 00:12:39,579
get a handle on the hardware developers

00:12:38,110 --> 00:12:41,860
and Feinberg's

00:12:39,579 --> 00:12:48,209
before tape out and we managed to

00:12:41,860 --> 00:12:52,230
do that actually and of course the the

00:12:48,209 --> 00:12:54,880
as a software team wants Hardware result

00:12:52,230 --> 00:12:56,500
most higher is available the software

00:12:54,880 --> 00:12:59,529
team is under pressure to get things

00:12:56,500 --> 00:13:02,050
things done so for our own the hearts

00:12:59,529 --> 00:13:05,050
and the survivalist

00:13:02,050 --> 00:13:09,550
it's very what we wanted to minimize our

00:13:05,050 --> 00:13:13,690
pain by being ahead of things that part

00:13:09,550 --> 00:13:19,779
we didn't quite succeed even if we did

00:13:13,690 --> 00:13:21,850
improve and the final home point area is

00:13:19,779 --> 00:13:25,779
also very important

00:13:21,850 --> 00:13:29,440
there's always limited hardware so using

00:13:25,779 --> 00:13:32,380
virtualization we could should do more

00:13:29,440 --> 00:13:34,089
with the same amount of hardware do more

00:13:32,380 --> 00:13:38,500
testing get more out of the hardware

00:13:34,089 --> 00:13:43,570
area so why did we ended up end up with

00:13:38,500 --> 00:13:47,980
um a km well of course it is to be able

00:13:43,570 --> 00:13:51,640
to source or available source some

00:13:47,980 --> 00:13:53,290
people wanted me to to use some people

00:13:51,640 --> 00:13:55,570
in the brought some of the engineers in

00:13:53,290 --> 00:14:00,160
the project module and using VirtualBox

00:13:55,570 --> 00:14:02,920
so I and since version boxes omorrow

00:14:00,160 --> 00:14:07,949
Oracle that Apple's obviously something

00:14:02,920 --> 00:14:11,230
that would have been interesting as well

00:14:07,949 --> 00:14:14,050
but I had used like you ever in a

00:14:11,230 --> 00:14:19,990
previous project so I really wanted to

00:14:14,050 --> 00:14:21,490
use human but I had to sell it so I so

00:14:19,990 --> 00:14:25,480
not

00:14:21,490 --> 00:14:28,870
and but then can their Israel PCI

00:14:25,480 --> 00:14:33,370
Express of course nobody else supports

00:14:28,870 --> 00:14:35,350
PCI Express emulation not even human

00:14:33,370 --> 00:14:38,770
that time I had to take the patch set

00:14:35,350 --> 00:14:45,959
for q35 something I've got a good excuse

00:14:38,770 --> 00:14:49,480
for you securing of course also volatile

00:14:45,959 --> 00:14:52,570
copy-on-write supporting you come to has

00:14:49,480 --> 00:14:55,000
saved us a lot because we have these

00:14:52,570 --> 00:14:59,920
expensive servers with very expensive

00:14:55,000 --> 00:15:05,260
disks but this is our very small so we

00:14:59,920 --> 00:15:07,510
can't really afford to to have we needed

00:15:05,260 --> 00:15:09,700
to save disk space to be able to run as

00:15:07,510 --> 00:15:14,010
many virtual machines of the motor so

00:15:09,700 --> 00:15:14,010
that can cook up to 10 very handy

00:15:19,269 --> 00:15:29,079
we also have a number of challenges we

00:15:25,980 --> 00:15:32,319
wanted to have a flexible solution so

00:15:29,079 --> 00:15:39,610
that they could cover different types of

00:15:32,319 --> 00:15:44,079
simulations with the same system and we

00:15:39,610 --> 00:15:46,029
had this RTL and the RTL developers so

00:15:44,079 --> 00:15:49,059
we wanted to hook into the RTL

00:15:46,029 --> 00:15:50,499
development as soon as possible so we

00:15:49,059 --> 00:15:53,379
were questioned yourself could be

00:15:50,499 --> 00:15:55,480
automated in too fast in this RTL early

00:15:53,379 --> 00:15:59,679
on so that we could actually start

00:15:55,480 --> 00:16:04,269
finding bugs even before this hardware

00:15:59,679 --> 00:16:08,980
most available almost working to the

00:16:04,269 --> 00:16:11,910
full extent already touched on a very

00:16:08,980 --> 00:16:11,910
the server part

00:16:16,060 --> 00:16:22,550
yes

00:16:18,620 --> 00:16:27,170
now here is the picture kind of abstract

00:16:22,550 --> 00:16:33,310
picture of our over a set up so we have

00:16:27,170 --> 00:16:40,670
the the QM process with the normal

00:16:33,310 --> 00:16:45,530
emulation and then we do this

00:16:40,670 --> 00:16:51,710
LD underscore PCI part here which is

00:16:45,530 --> 00:16:55,670
basically a kind of a dynamically label

00:16:51,710 --> 00:16:59,540
or other the the percept necessary to be

00:16:55,670 --> 00:17:07,250
able to define a clear link in different

00:16:59,540 --> 00:17:09,620
device models so we're and this this if

00:17:07,250 --> 00:17:13,520
you look at the blue it device instances

00:17:09,620 --> 00:17:19,280
there there are them instances of you

00:17:13,520 --> 00:17:23,240
across objects so we I needed to be able

00:17:19,280 --> 00:17:29,750
to add types dynamically and then inside

00:17:23,240 --> 00:17:32,810
certain those types basically we have

00:17:29,750 --> 00:17:36,920
only one major implementation so far and

00:17:32,810 --> 00:17:39,560
that's the device on the test but we

00:17:36,920 --> 00:17:41,600
wanted to be able to create the tool

00:17:39,560 --> 00:17:44,660
that would be a usable for all the

00:17:41,600 --> 00:17:47,160
projects as well so then we decided that

00:17:44,660 --> 00:17:49,200
we needed to have

00:17:47,160 --> 00:17:52,950
by a protocol to be able to communicate

00:17:49,200 --> 00:17:55,200
with these simulators that had to run in

00:17:52,950 --> 00:17:57,270
the simulation form particularly this

00:17:55,200 --> 00:18:01,440
one had to run on the hardware

00:17:57,270 --> 00:18:04,410
simulation form this one was the high

00:18:01,440 --> 00:18:07,200
level simulation was kind of complicated

00:18:04,410 --> 00:18:11,940
enough that it could be useful to run it

00:18:07,200 --> 00:18:15,390
on a separate model so and then we

00:18:11,940 --> 00:18:18,240
decided that we would use PCI Express

00:18:15,390 --> 00:18:26,250
transactions as the communication

00:18:18,240 --> 00:18:30,770
protocol there we also were able to sew

00:18:26,250 --> 00:18:35,730
it and we wanted to and also support for

00:18:30,770 --> 00:18:40,920
for ease of debugging so we added serial

00:18:35,730 --> 00:18:44,910
ports multiple serial ports we also have

00:18:40,920 --> 00:18:46,680
remember that runs of this card realms

00:18:44,910 --> 00:18:49,470
as a separate can run as a separate

00:18:46,680 --> 00:18:52,530
process or moved into the simulation

00:18:49,470 --> 00:18:55,860
simulations so that the problem of total

00:18:52,530 --> 00:18:59,240
property also to be able to to to use

00:18:55,860 --> 00:19:02,220
this to test early and we achieve that

00:18:59,240 --> 00:19:06,720
so I'll probably come back to this later

00:19:02,220 --> 00:19:08,580
this picture so what is this LDPC on so

00:19:06,720 --> 00:19:11,400
it's a plug-in framework as I mentioned

00:19:08,580 --> 00:19:16,100
it is a single right we had the phone

00:19:11,400 --> 00:19:16,100
with minimum include appearances

00:19:16,310 --> 00:19:23,330
currently it has lessons and callbacks

00:19:19,440 --> 00:19:27,930
that is implemented by the device model

00:19:23,330 --> 00:19:31,010
and it has some 13 utilities that is

00:19:27,930 --> 00:19:37,260
basically as much as possible now

00:19:31,010 --> 00:19:39,870
one-to-one mappings to qme functions so

00:19:37,260 --> 00:19:44,770
I have this percent now that I've been

00:19:39,870 --> 00:19:47,320
maintaining over the earth and it is it

00:19:44,770 --> 00:19:53,080
the size of interest I had to change 16

00:19:47,320 --> 00:19:54,940
files other 2000 changed 1412 Sanders so

00:19:53,080 --> 00:19:59,710
it's a fairly small patch stuff that is

00:19:54,940 --> 00:20:03,160
necessary to to implement this the the

00:19:59,710 --> 00:20:08,770
light blue LD PCI box there that the

00:20:03,160 --> 00:20:11,650
model goes within and the reason why I

00:20:08,770 --> 00:20:15,340
needed it to be single I feel I had the

00:20:11,650 --> 00:20:17,980
firewalls because this to be able to

00:20:15,340 --> 00:20:21,010
Saladin I had to have it working on on

00:20:17,980 --> 00:20:25,270
VirtualBox as well so the initial

00:20:21,010 --> 00:20:27,700
Marshall worked on most limited I have a

00:20:25,270 --> 00:20:30,160
sibling implementation of the framework

00:20:27,700 --> 00:20:33,130
on VirtualBox and then the plugins could

00:20:30,160 --> 00:20:36,760
be used interchangeably on VirtualBox or

00:20:33,130 --> 00:20:39,610
QA but that's not the case and

00:20:36,760 --> 00:20:42,190
importance we can move on with the QM

00:20:39,610 --> 00:20:44,940
implementation but I do have benefited

00:20:42,190 --> 00:20:47,530
from this by being able to use it in

00:20:44,940 --> 00:20:51,550
faith testing environment that I'll

00:20:47,530 --> 00:20:55,900
probably mention verify a hundred so the

00:20:51,550 --> 00:20:59,950
ability to have a very limited API made

00:20:55,900 --> 00:21:02,100
it useful and can make it useful later

00:20:59,950 --> 00:21:07,050
as well

00:21:02,100 --> 00:21:10,470
so here is what it looks like and where

00:21:07,050 --> 00:21:13,630
we use it so we use command line

00:21:10,470 --> 00:21:17,740
interface to the kurma but I have some

00:21:13,630 --> 00:21:24,070
shell script management to operate that

00:21:17,740 --> 00:21:26,990
I'll mention later this so what happens

00:21:24,070 --> 00:21:30,299
is that during a PC I am

00:21:26,990 --> 00:21:35,640
besides president elaboration and the

00:21:30,299 --> 00:21:38,490
device realization cure the normal path

00:21:35,640 --> 00:21:40,770
is for loading humor and then at some

00:21:38,490 --> 00:21:44,250
point it checks it doesn't find the

00:21:40,770 --> 00:21:48,210
device model because the device doesn't

00:21:44,250 --> 00:21:55,500
exist then it will call this pipes etc

00:21:48,210 --> 00:22:00,030
and that actually knows how to from this

00:21:55,500 --> 00:22:02,520
common ones that can be supplied and

00:22:00,030 --> 00:22:04,919
then it knows that there's a device here

00:22:02,520 --> 00:22:09,929
that is called sip which is our internal

00:22:04,919 --> 00:22:12,750
name for this HCI with has a

00:22:09,929 --> 00:22:16,140
configuration directory in that pulse

00:22:12,750 --> 00:22:20,820
and it has the ID is necessary to plug

00:22:16,140 --> 00:22:23,790
it into the PCI Express bus and it's

00:22:20,820 --> 00:22:27,120
going to go into or to talk about it in

00:22:23,790 --> 00:22:36,690
in Prague and so on and it has to go

00:22:27,120 --> 00:22:39,929
into the PCIe port 0 and this triggers a

00:22:36,690 --> 00:22:45,270
DLL open so that the doomed device model

00:22:39,929 --> 00:22:48,150
gets loaded you can have in theory at

00:22:45,270 --> 00:22:52,440
least have several and also files that

00:22:48,150 --> 00:22:57,960
and device different device models and

00:22:52,440 --> 00:22:59,820
then during instance create this so file

00:22:57,960 --> 00:23:01,350
gets already at the other end gets

00:22:59,820 --> 00:23:03,600
called for this particular

00:23:01,350 --> 00:23:06,120
implementation and if they can

00:23:03,600 --> 00:23:09,780
implementation we read the configuration

00:23:06,120 --> 00:23:11,760
file and that for our device Mahalo

00:23:09,780 --> 00:23:16,799
doesn't try to connect to the simulator

00:23:11,760 --> 00:23:20,840
and if that works out and the simulator

00:23:16,799 --> 00:23:26,010
takes over and does a lot on the work

00:23:20,840 --> 00:23:29,730
and it's the plug-in is only forwarding

00:23:26,010 --> 00:23:31,650
transactions to the simulator but I very

00:23:29,730 --> 00:23:34,260
soon figured out that it was not very

00:23:31,650 --> 00:23:38,130
useful it was very cumbersome to work

00:23:34,260 --> 00:23:40,169
with if we were completely relying on

00:23:38,130 --> 00:23:42,539
the several editor instance to be

00:23:40,169 --> 00:23:45,679
connected because you can imagine what

00:23:42,539 --> 00:23:50,669
happens you can have a PCI device and

00:23:45,679 --> 00:23:54,240
the device does all services are right

00:23:50,669 --> 00:23:58,320
or a CCS I read doesn't terminate then

00:23:54,240 --> 00:24:00,860
the machine becomes very stuck so we

00:23:58,320 --> 00:24:07,020
needed to have some kind of fallback

00:24:00,860 --> 00:24:08,610
implementation to be able to handle the

00:24:07,020 --> 00:24:11,429
situation where this there's no

00:24:08,610 --> 00:24:13,679
simulator or the simulator crushed or

00:24:11,429 --> 00:24:17,309
something happened so that means that

00:24:13,679 --> 00:24:19,799
there is some logic in this component in

00:24:17,309 --> 00:24:22,049
the plugin that will just answer yes NCS

00:24:19,799 --> 00:24:26,370
yes to everything that it get presented

00:24:22,049 --> 00:24:28,530
with so that the kind of user interface

00:24:26,370 --> 00:24:32,070
that the machine continues to work and

00:24:28,530 --> 00:24:36,600
you can do stuff with it later on hope

00:24:32,070 --> 00:24:38,400
plan to get device enumeration over

00:24:36,600 --> 00:24:41,450
again and get to the similarity

00:24:38,400 --> 00:24:45,299
connected once it's up and running again

00:24:41,450 --> 00:24:47,070
similarly on device under realised we do

00:24:45,299 --> 00:24:49,919
the disconnect from the simulation if

00:24:47,070 --> 00:24:52,620
necessary and then the minute the device

00:24:49,919 --> 00:24:53,950
instance and there's a reference count

00:24:52,620 --> 00:24:57,220
of number of the

00:24:53,950 --> 00:24:59,889
that's using this particular model once

00:24:57,220 --> 00:25:03,250
it goes to 0 the type definitions are

00:24:59,889 --> 00:25:05,440
removed and deal closed appears and

00:25:03,250 --> 00:25:08,049
that's very useful because at least

00:25:05,440 --> 00:25:11,519
during the early development we could

00:25:08,049 --> 00:25:15,370
then have them virtual machines running

00:25:11,519 --> 00:25:18,070
making to recompile the model and then

00:25:15,370 --> 00:25:22,860
hope plug it and the whole device the

00:25:18,070 --> 00:25:26,350
development cycle was very short so

00:25:22,860 --> 00:25:28,899
moving on to it later on I have this

00:25:26,350 --> 00:25:31,090
whole example here that I used to run to

00:25:28,899 --> 00:25:33,460
my students at university that I thought

00:25:31,090 --> 00:25:36,549
might be useful to you for some of you

00:25:33,460 --> 00:25:38,889
that are not familiar InfiniBand

00:25:36,549 --> 00:25:41,850
communication works in practice because

00:25:38,889 --> 00:25:50,080
this is kind of useful to understand the

00:25:41,850 --> 00:25:53,230
challenges we have so typically and this

00:25:50,080 --> 00:25:56,470
is kind of ping pong example with Amanda

00:25:53,230 --> 00:26:00,370
hello world program almost so it's not

00:25:56,470 --> 00:26:02,470
trivial but it's relatively simple so we

00:26:00,370 --> 00:26:06,789
have one user process here that

00:26:02,470 --> 00:26:09,309
typically will allocate some memory this

00:26:06,789 --> 00:26:11,559
memory will be have had to be pinned to

00:26:09,309 --> 00:26:14,980
be able to do device to be able to be

00:26:11,559 --> 00:26:19,179
accessible for the device so that means

00:26:14,980 --> 00:26:24,070
that we have to call this home in the in

00:26:19,179 --> 00:26:25,659
the user level part of the which

00:26:24,070 --> 00:26:29,740
communicates with the car need to set up

00:26:25,659 --> 00:26:35,350
in memory mapping called Empire and

00:26:29,740 --> 00:26:40,149
memory region and then we typically will

00:26:35,350 --> 00:26:43,440
need to create a couple of tools we will

00:26:40,149 --> 00:26:47,150
have completely kills for completion

00:26:43,440 --> 00:26:50,480
notifications we will have

00:26:47,150 --> 00:26:52,790
yes which are senders and receivers

00:26:50,480 --> 00:27:00,880
which are in the actual communication

00:26:52,790 --> 00:27:05,720
for the data domain and several other

00:27:00,880 --> 00:27:08,270
process that's really irritating then we

00:27:05,720 --> 00:27:10,700
need to decide this this process number

00:27:08,270 --> 00:27:15,110
one would need to decide where to

00:27:10,700 --> 00:27:20,179
receive his message so he allocates of

00:27:15,110 --> 00:27:23,450
memory in this memory region and calls

00:27:20,179 --> 00:27:26,240
are opposed to receive to say that all I

00:27:23,450 --> 00:27:31,070
have this received butter and makes that

00:27:26,240 --> 00:27:36,950
available for communication for the

00:27:31,070 --> 00:27:39,230
anonymous a dozen similar on the other

00:27:36,950 --> 00:27:41,420
side would have to make a receive buffer

00:27:39,230 --> 00:27:45,170
available and that receiver buffer can

00:27:41,420 --> 00:27:49,390
be a scatter list if necessary so the

00:27:45,170 --> 00:27:49,390
memory can be taken from several several

00:27:49,540 --> 00:27:59,210
segments to to be able to use this to do

00:27:53,960 --> 00:28:02,120
this in a efficient way without copying

00:27:59,210 --> 00:28:06,550
because that's a primary goal if the man

00:28:02,120 --> 00:28:06,550
is the way we communicate single copy

00:28:08,260 --> 00:28:16,970
okay and then we want to send something

00:28:12,520 --> 00:28:21,110
so then maybe this user process one here

00:28:16,970 --> 00:28:23,480
would have some list of items it wants

00:28:21,110 --> 00:28:25,790
to send to the other side so that will

00:28:23,480 --> 00:28:31,100
typically than the post and as a send

00:28:25,790 --> 00:28:33,750
request and once that's posted the

00:28:31,100 --> 00:28:38,220
hardware will

00:28:33,750 --> 00:28:41,190
send an idea packet with that request or

00:28:38,220 --> 00:28:44,970
end up sending either this is a Sandra

00:28:41,190 --> 00:28:48,000
question so it will send that over to

00:28:44,970 --> 00:28:51,090
the other side on the other side this

00:28:48,000 --> 00:28:53,760
user process - would check would call

00:28:51,090 --> 00:28:59,130
its completion queue it could my

00:28:53,760 --> 00:29:01,560
prevents as well or this is the the past

00:28:59,130 --> 00:29:05,880
Boston area where it's active and

00:29:01,560 --> 00:29:09,300
pulling and writing for that mystically

00:29:05,880 --> 00:29:12,150
and then at some point the packet

00:29:09,300 --> 00:29:17,160
arrives and the completion is written by

00:29:12,150 --> 00:29:23,250
the harbor into the condition - and the

00:29:17,160 --> 00:29:26,610
day the user process can pick up the

00:29:23,250 --> 00:29:29,630
result knowing that now the result is

00:29:26,610 --> 00:29:32,070
similar sieve queue entry that could

00:29:29,630 --> 00:29:36,180
receive so it will never see the guy

00:29:32,070 --> 00:29:43,670
there and then they can similarly do we

00:29:36,180 --> 00:29:46,920
go the other way to send back again so I

00:29:43,670 --> 00:29:49,710
didn't mention that there's vacations

00:29:46,920 --> 00:29:51,090
there so the first efficient in the use

00:29:49,710 --> 00:29:54,260
the sources one there is the same

00:29:51,090 --> 00:29:56,460
equation you can request the completion

00:29:54,260 --> 00:30:02,550
notification while in the Senate has

00:29:56,460 --> 00:30:05,670
been performed but that's so that's how

00:30:02,550 --> 00:30:10,320
InfiniBand worsen InfiniBand works very

00:30:05,670 --> 00:30:11,280
much in that the device is taking stuff

00:30:10,320 --> 00:30:13,260
from memory

00:30:11,280 --> 00:30:17,940
putting it directly into memory on the

00:30:13,260 --> 00:30:20,550
other world so what we don't try to look

00:30:17,940 --> 00:30:23,130
at the device and see how - we should

00:30:20,550 --> 00:30:27,010
model it it's interesting to look at how

00:30:23,130 --> 00:30:31,150
this device communicates so obviously

00:30:27,010 --> 00:30:35,110
as a computer icon takes place it has or

00:30:31,150 --> 00:30:36,760
our device has three bars watan former

00:30:35,110 --> 00:30:40,900
access bar which is used to communicate

00:30:36,760 --> 00:30:45,990
to the forever and one ms IX bars for

00:30:40,900 --> 00:30:49,480
the interrupt for the Amazon I dropped a

00:30:45,990 --> 00:30:53,260
work request West posting bar which is

00:30:49,480 --> 00:30:56,380
used to post it's all similar to modern

00:30:53,260 --> 00:30:58,810
analog phones blue flame which is

00:30:56,380 --> 00:31:01,330
basically to write request directly to

00:30:58,810 --> 00:31:07,270
God this is this week always collect

00:31:01,330 --> 00:31:09,580
workers and then it has the MSI's

00:31:07,270 --> 00:31:13,990
support MSI export for in terms of

00:31:09,580 --> 00:31:16,780
course it does lots of DMA and the base

00:31:13,990 --> 00:31:20,080
are triggered by Bonnie's work requests

00:31:16,780 --> 00:31:25,450
and it's implicitly done by device by

00:31:20,080 --> 00:31:28,690
the device so initially our initial

00:31:25,450 --> 00:31:31,690
implementation here's a lot of directly

00:31:28,690 --> 00:31:35,080
queue with support for instance for MSI

00:31:31,690 --> 00:31:36,970
X handling that were only already

00:31:35,080 --> 00:31:40,570
convenient functions to handle that but

00:31:36,970 --> 00:31:42,430
as our simulation environment matured we

00:31:40,570 --> 00:31:47,320
moved more and more on the functionality

00:31:42,430 --> 00:31:49,810
or to the simulation side but we still

00:31:47,320 --> 00:31:57,820
kept the logic to be able to come in

00:31:49,810 --> 00:32:00,490
useful for the next project so of course

00:31:57,820 --> 00:32:05,110
when you are in driver developer there

00:32:00,490 --> 00:32:06,760
are some key issues and for performing I

00:32:05,110 --> 00:32:10,600
think one of the key issues is the

00:32:06,760 --> 00:32:12,670
driver development cycle time to all

00:32:10,600 --> 00:32:13,820
developers development cycle time is

00:32:12,670 --> 00:32:16,810
really

00:32:13,820 --> 00:32:19,490
and just to give you an example how our

00:32:16,810 --> 00:32:25,370
development cycle time is much better

00:32:19,490 --> 00:32:32,600
using to other than using hover you can

00:32:25,370 --> 00:32:35,030
just look at this we have this servers

00:32:32,600 --> 00:32:36,710
for some reason I don't understand it

00:32:35,030 --> 00:32:39,080
seems like the more complicated the

00:32:36,710 --> 00:32:42,470
server is the longer it takes to boot or

00:32:39,080 --> 00:32:49,040
even get out of the BIOS problem you

00:32:42,470 --> 00:32:50,840
face so Amaya the server I have four

00:32:49,040 --> 00:32:53,570
Hardware trusting the single server I am

00:32:50,840 --> 00:32:57,800
with harbor on that I used takes three

00:32:53,570 --> 00:33:01,130
minutes from I press the result our type

00:32:57,800 --> 00:33:04,760
tere sath come on in in the console

00:33:01,130 --> 00:33:08,240
interface until I am able to login by

00:33:04,760 --> 00:33:10,730
Isis age and start working for the VM

00:33:08,240 --> 00:33:14,300
that time is 30 seconds this was

00:33:10,730 --> 00:33:17,930
actually it's doing so much but this was

00:33:14,300 --> 00:33:22,220
actually imagined for my home office so

00:33:17,930 --> 00:33:28,250
it was really something like but so it's

00:33:22,220 --> 00:33:31,850
best time 30 seconds actually the the VM

00:33:28,250 --> 00:33:36,020
to boot Tex not that much time at least

00:33:31,850 --> 00:33:37,870
not running for instance fedora with

00:33:36,020 --> 00:33:42,850
system Lea

00:33:37,870 --> 00:33:46,370
so obviously the the server side is

00:33:42,850 --> 00:33:52,520
really the bios probing and stuff takes

00:33:46,370 --> 00:33:54,770
a lot of time and but why I'm moving to

00:33:52,520 --> 00:33:56,360
the hoplon scenario the for the

00:33:54,770 --> 00:34:01,370
scenarios were that work with the

00:33:56,360 --> 00:34:02,580
machine is not completely done this goes

00:34:01,370 --> 00:34:04,679
down to about

00:34:02,580 --> 00:34:08,030
eleven seconds which is really good

00:34:04,679 --> 00:34:10,409
because I think if you think about

00:34:08,030 --> 00:34:14,310
development cycle time I think it's very

00:34:10,409 --> 00:34:18,629
important to for me the the kind of the

00:34:14,310 --> 00:34:20,849
threshold is when the time is long

00:34:18,629 --> 00:34:22,649
enough that you need to make a context

00:34:20,849 --> 00:34:25,770
switch and do something useful in

00:34:22,649 --> 00:34:30,629
between you can have the confer break

00:34:25,770 --> 00:34:33,629
time kind of length where everything at

00:34:30,629 --> 00:34:37,349
least my brain everything is blown away

00:34:33,629 --> 00:34:39,839
or you could have that but as long as

00:34:37,349 --> 00:34:42,419
it's within the sorta second range it's

00:34:39,839 --> 00:34:45,389
possible to just take a sip or coffee

00:34:42,419 --> 00:34:48,419
being back and and be in the same

00:34:45,389 --> 00:34:51,510
context and continue to work again well

00:34:48,419 --> 00:34:52,080
if it goes to three minutes that's too

00:34:51,510 --> 00:34:55,020
much

00:34:52,080 --> 00:34:57,089
then my thoughts at least are somewhere

00:34:55,020 --> 00:35:00,859
else and I have to kind of focus on

00:34:57,089 --> 00:35:03,900
doing again kind of thing thank you

00:35:00,859 --> 00:35:10,560
so I think it's really important to have

00:35:03,900 --> 00:35:16,760
that another very important thing is

00:35:10,560 --> 00:35:19,920
also ability for InfiniBand a lot of

00:35:16,760 --> 00:35:22,740
stuff goes on in the hardware at very

00:35:19,920 --> 00:35:24,630
high speed it's very hard to to serve

00:35:22,740 --> 00:35:27,619
everything without affecting the

00:35:24,630 --> 00:35:32,640
performance or affecting the timing

00:35:27,619 --> 00:35:36,530
output in general so in a simulated

00:35:32,640 --> 00:35:36,530
environment that's much easier of course

00:35:37,400 --> 00:35:48,240
and of course debugging facilities also

00:35:43,700 --> 00:35:52,369
human provides interesting support there

00:35:48,240 --> 00:35:52,369
that makes debugging much easier message

00:35:53,030 --> 00:35:58,589
and further for test coverage is always

00:35:56,430 --> 00:36:04,050
the question once the project has

00:35:58,589 --> 00:36:05,280
arrived to a certain stage it it becomes

00:36:04,050 --> 00:36:07,470
a question of how

00:36:05,280 --> 00:36:10,680
the interchange without breaking things

00:36:07,470 --> 00:36:13,050
and in my experience the better the

00:36:10,680 --> 00:36:15,690
tests you have the more and they are to

00:36:13,050 --> 00:36:17,550
change and the later in the project and

00:36:15,690 --> 00:36:20,760
that's really good because then you can

00:36:17,550 --> 00:36:23,130
actually do things the right way by

00:36:20,760 --> 00:36:25,590
having virtual machines to do some of

00:36:23,130 --> 00:36:27,900
the testing we can do a lot can do a lot

00:36:25,590 --> 00:36:30,390
more testing that we would have been

00:36:27,900 --> 00:36:33,090
able to do if we would have to have new

00:36:30,390 --> 00:36:51,600
machines or separate machines for all

00:36:33,090 --> 00:36:59,400
the tests we need to execute so so some

00:36:51,600 --> 00:37:01,710
of the debugging so what we have we have

00:36:59,400 --> 00:37:05,610
added a lot of debugging features in the

00:37:01,710 --> 00:37:08,310
in the kurma part of this for instance

00:37:05,610 --> 00:37:11,460
we do a lot of snooping so that we can

00:37:08,310 --> 00:37:15,750
actually see all the traffic coming both

00:37:11,460 --> 00:37:19,860
from the simulator to the machine the

00:37:15,750 --> 00:37:22,590
opposite and do that by just linking in

00:37:19,860 --> 00:37:26,250
the same same libraries that we used for

00:37:22,590 --> 00:37:28,950
for the driver to be able to do this at

00:37:26,250 --> 00:37:32,820
the source code level and get full

00:37:28,950 --> 00:37:35,460
overview as opposed to when we have to

00:37:32,820 --> 00:37:37,710
do this with our hardware the few times

00:37:35,460 --> 00:37:39,480
now that we actually have to to debug

00:37:37,710 --> 00:37:42,180
things on however it is not able to

00:37:39,480 --> 00:37:45,370
reproduce it on software we will have to

00:37:42,180 --> 00:37:47,590
use a tracer which has

00:37:45,370 --> 00:37:49,840
very old kind of old fashioned in the

00:37:47,590 --> 00:37:52,990
first la flama interface takes a lot of

00:37:49,840 --> 00:37:56,200
time to sit through if we are able to

00:37:52,990 --> 00:37:58,120
trigger the right scenario within the

00:37:56,200 --> 00:38:01,540
time that before the trace the first

00:37:58,120 --> 00:38:04,180
games up it's really difficult to to

00:38:01,540 --> 00:38:08,830
find where it is and takes a lot of time

00:38:04,180 --> 00:38:10,780
even to set up the scenario so we save a

00:38:08,830 --> 00:38:14,260
lot of time from being able to debug

00:38:10,780 --> 00:38:16,570
things on software side also we have

00:38:14,260 --> 00:38:20,620
it's a very heavy content and resources

00:38:16,570 --> 00:38:24,850
very expensive most such PC erasers so

00:38:20,620 --> 00:38:28,950
not always as much as referrals whenever

00:38:24,850 --> 00:38:32,350
we can do it with the simulations and

00:38:28,950 --> 00:38:35,380
put there so we have this RTL simulation

00:38:32,350 --> 00:38:38,170
where we can actually run the exact

00:38:35,380 --> 00:38:40,660
saying that in the chip that will be in

00:38:38,170 --> 00:38:45,820
the hardware and it's kind of painfully

00:38:40,660 --> 00:38:48,460
slow but if and we were able to actually

00:38:45,820 --> 00:38:51,310
use this to success sometimes during our

00:38:48,460 --> 00:38:56,790
development we were able to to find the

00:38:51,310 --> 00:38:59,620
problem run a tests with with a current

00:38:56,790 --> 00:39:02,800
waveform output to and send it to the

00:38:59,620 --> 00:39:05,410
hardware engineers and then sport hours

00:39:02,800 --> 00:39:08,050
in their code and fix the bugs before

00:39:05,410 --> 00:39:09,760
table so we were actually having fights

00:39:08,050 --> 00:39:12,100
obsessed with that we should have had a

00:39:09,760 --> 00:39:15,100
much more successful coalition and have

00:39:12,100 --> 00:39:17,560
this too much earlier so that we can

00:39:15,100 --> 00:39:21,510
undetected even more bugs but we find

00:39:17,560 --> 00:39:21,510
our foundation works

00:39:27,130 --> 00:39:34,509
so one of the things we already figured

00:39:30,460 --> 00:39:37,029
out we needed was a safety net while we

00:39:34,509 --> 00:39:40,150
have this model that important the

00:39:37,029 --> 00:39:42,279
hardware was not finished and the

00:39:40,150 --> 00:39:44,829
software wasn't finished and you have

00:39:42,279 --> 00:39:47,229
this we request the driver request some

00:39:44,829 --> 00:39:51,160
some address to be fetched from memory

00:39:47,229 --> 00:39:53,680
by by the device it's very easy to make

00:39:51,160 --> 00:39:56,200
mistakes so that it reads from somewhere

00:39:53,680 --> 00:39:58,630
else or even worse write to some random

00:39:56,200 --> 00:40:00,670
location in the kernel so the first

00:39:58,630 --> 00:40:03,999
thing we really wanted to address was

00:40:00,670 --> 00:40:07,239
file and a new support so that that we

00:40:03,999 --> 00:40:09,640
can track all the accesses to memory

00:40:07,239 --> 00:40:12,309
that wasn't really set up to be

00:40:09,640 --> 00:40:14,729
communicated by the device so we wanted

00:40:12,309 --> 00:40:17,729
as much control as possible there

00:40:14,729 --> 00:40:21,099
unfortunately there weren't any virtual

00:40:17,729 --> 00:40:26,410
mmmyou I am using support available in

00:40:21,099 --> 00:40:29,799
Cuba later we had some successful work I

00:40:26,410 --> 00:40:32,279
got some good help from from young kids

00:40:29,799 --> 00:40:32,279
kata

00:40:32,819 --> 00:40:37,869
jisub project

00:40:34,479 --> 00:40:42,009
I got I own a new support from

00:40:37,869 --> 00:40:45,489
employment support but early on I had to

00:40:42,009 --> 00:40:47,950
kind of make a quick Act and the I

00:40:45,489 --> 00:40:53,619
successfully did that with just

00:40:47,950 --> 00:40:57,339
implementing some an extra csr page in

00:40:53,619 --> 00:41:01,319
the device and some callbacks in the DMA

00:40:57,339 --> 00:41:04,559
API in the kernel so that we could have

00:41:01,319 --> 00:41:07,349
the driver actually just right setup

00:41:04,559 --> 00:41:09,329
through all the demand callbacks setting

00:41:07,349 --> 00:41:13,019
up on demand members so that we could do

00:41:09,329 --> 00:41:15,869
this and this simple iommu model to fold

00:41:13,019 --> 00:41:18,630
so that actually we just disconnected

00:41:15,869 --> 00:41:21,539
the simulator each time the legal access

00:41:18,630 --> 00:41:23,249
came in so that we would track the air

00:41:21,539 --> 00:41:25,349
immediately and figure out what the

00:41:23,249 --> 00:41:28,380
problems so that was really useful and

00:41:25,349 --> 00:41:31,890
saves us a lot of time another feature

00:41:28,380 --> 00:41:37,799
that was really useful was the ability

00:41:31,890 --> 00:41:41,579
to be able to to do since I'm a software

00:41:37,799 --> 00:41:43,769
guy I do really don't like having to

00:41:41,579 --> 00:41:47,069
read the Santa code to figure out where

00:41:43,769 --> 00:41:50,869
the crash occurred so I really love to

00:41:47,069 --> 00:41:56,039
have a gdb support whenever possible so

00:41:50,869 --> 00:41:58,729
Q marry or kill all our environment

00:41:56,039 --> 00:42:01,229
there helped a lot because we were and

00:41:58,729 --> 00:42:03,239
for instance it's very useful tab to

00:42:01,229 --> 00:42:06,869
console torture rather than one so that

00:42:03,239 --> 00:42:09,599
you get the console log or the console

00:42:06,869 --> 00:42:11,900
log in one place in one place and the K

00:42:09,599 --> 00:42:16,170
GDP connection in the mother price

00:42:11,900 --> 00:42:19,440
trigonometry and another thing was the

00:42:16,170 --> 00:42:26,339
ability to be able to symbolically debug

00:42:19,440 --> 00:42:30,839
also depends on being able to load the

00:42:26,339 --> 00:42:34,660
liquor locations of the modules that we

00:42:30,839 --> 00:42:38,590
need to debug into our

00:42:34,660 --> 00:42:41,290
Multi Burger through the console and we

00:42:38,590 --> 00:42:44,680
I was very pleased with this simple

00:42:41,290 --> 00:42:46,900
solution where we when we have a script

00:42:44,680 --> 00:42:49,360
to use to know the driver when we'd love

00:42:46,900 --> 00:42:53,230
the drawbridge in the environment in the

00:42:49,360 --> 00:42:56,260
Testament and the driver will and that

00:42:53,230 --> 00:43:00,280
script to also report in a manifest

00:42:56,260 --> 00:43:02,020
location where the the the oldest simple

00:43:00,280 --> 00:43:05,160
information for them where near where

00:43:02,020 --> 00:43:08,230
the driver ended up in the crane and

00:43:05,160 --> 00:43:12,520
that will then be available also after

00:43:08,230 --> 00:43:15,760
the machine has crashed so that we could

00:43:12,520 --> 00:43:18,100
actually assault now routinely try to

00:43:15,760 --> 00:43:26,200
make a mistake and have another

00:43:18,100 --> 00:43:30,820
exception I can access the the console I

00:43:26,200 --> 00:43:34,750
get through gdb symbolic output much

00:43:30,820 --> 00:43:38,020
faster figure out what went wrong and I

00:43:34,750 --> 00:43:40,600
can even do that with zero devices so

00:43:38,020 --> 00:43:44,830
one thing I can't do in hardware is if

00:43:40,600 --> 00:43:47,380
if the driver the Falls already doing

00:43:44,830 --> 00:43:49,360
driver node that's before the symbol

00:43:47,380 --> 00:43:51,760
information is available and written I

00:43:49,360 --> 00:43:54,520
couldn't do an act on hardware because I

00:43:51,760 --> 00:43:57,460
can't help track this device that is

00:43:54,520 --> 00:43:59,770
physically in the machine I can do that

00:43:57,460 --> 00:44:04,360
and cumin because we have periodic

00:43:59,770 --> 00:44:07,540
support then I can just start with zero

00:44:04,360 --> 00:44:12,850
devices and load the driver plug-in

00:44:07,540 --> 00:44:15,040
device it will pain and thought and then

00:44:12,850 --> 00:44:17,610
but then I have a similar information so

00:44:15,040 --> 00:44:20,410
this was really helpful

00:44:17,610 --> 00:44:24,730
the problem of course with this is this

00:44:20,410 --> 00:44:26,390
my figure here you can imagine these

00:44:24,730 --> 00:44:30,890
tools I think I have like

00:44:26,390 --> 00:44:34,160
different tools that I'm maintaining

00:44:30,890 --> 00:44:37,100
more or less and my main goal was to

00:44:34,160 --> 00:44:40,430
write this driver we have a team working

00:44:37,100 --> 00:44:44,440
on the driver still a lot of time and

00:44:40,430 --> 00:44:47,630
goes into these tools unfortunately and

00:44:44,440 --> 00:44:51,620
not only did we have to do the tools to

00:44:47,630 --> 00:44:53,810
to have tools to do this to have a plug

00:44:51,620 --> 00:45:00,650
in and everything but we also needed to

00:44:53,810 --> 00:45:02,960
manage hundreds of VMs and we have this

00:45:00,650 --> 00:45:06,080
very shortage of this space early on but

00:45:02,960 --> 00:45:07,910
an underworld so I had to come up with

00:45:06,080 --> 00:45:11,180
just a quick and dirty solution to just

00:45:07,910 --> 00:45:12,740
not have to tell people what command

00:45:11,180 --> 00:45:16,600
lines to use with you

00:45:12,740 --> 00:45:19,880
so that resulted in this transcript

00:45:16,600 --> 00:45:21,890
saying that I maintain that this kind of

00:45:19,880 --> 00:45:33,470
virtually never received memory

00:45:21,890 --> 00:45:39,680
management system yep so that script

00:45:33,470 --> 00:45:41,900
soon started to become a lot of stuff we

00:45:39,680 --> 00:45:45,530
have a lot of features when the idiom as

00:45:41,900 --> 00:45:49,190
you can see piece of i/o besides press

00:45:45,530 --> 00:45:52,010
booth number of reports to use the land

00:45:49,190 --> 00:45:54,260
support multiple subnets bridges disk is

00:45:52,010 --> 00:45:58,040
offenses Ethernet model lots of this

00:45:54,260 --> 00:46:00,440
verified or over time I even use it with

00:45:58,040 --> 00:46:02,400
the pass-through because we wanted to

00:46:00,440 --> 00:46:10,740
support

00:46:02,400 --> 00:46:12,779
is important and the DIA file so are we

00:46:10,740 --> 00:46:15,240
play employment today is where this

00:46:12,779 --> 00:46:18,059
continuous integration based on Jenkins

00:46:15,240 --> 00:46:21,589
I Garrett every committee we submit

00:46:18,059 --> 00:46:23,940
submit goes through a two-stage test

00:46:21,589 --> 00:46:27,630
there is a smoke test that runs in

00:46:23,940 --> 00:46:29,940
parallel very clear to to kind of figure

00:46:27,630 --> 00:46:34,099
out the obvious mistakes compiling and

00:46:29,940 --> 00:46:37,470
stuff like that and some smoke tests

00:46:34,099 --> 00:46:40,770
actually based on gene tests most of it

00:46:37,470 --> 00:46:43,200
and then we have a longer see realized

00:46:40,770 --> 00:46:46,170
it has to be sterilized because of the

00:46:43,200 --> 00:46:49,789
amount of hardware we have available and

00:46:46,170 --> 00:46:52,170
chicken regression tests that actually

00:46:49,789 --> 00:46:57,450
will the resulting commits being

00:46:52,170 --> 00:47:00,420
accepted every run a lot of test

00:46:57,450 --> 00:47:03,480
applications both our own in-house

00:47:00,420 --> 00:47:07,079
developed unit test my study test and

00:47:03,480 --> 00:47:10,200
simple system tests a lot of other tests

00:47:07,079 --> 00:47:14,039
there are several tests systems that

00:47:10,200 --> 00:47:16,819
they are developed to have more tests we

00:47:14,039 --> 00:47:19,020
couldn't have achieved this without

00:47:16,819 --> 00:47:22,910
virtualization because we didn't simply

00:47:19,020 --> 00:47:26,789
don't have enough harder to do it so

00:47:22,910 --> 00:47:31,260
what did we achieve with this well we

00:47:26,789 --> 00:47:34,020
have the ability to start very early in

00:47:31,260 --> 00:47:37,799
the development we found a lot of bugs

00:47:34,020 --> 00:47:40,020
those before not to type out it reform

00:47:37,799 --> 00:47:43,680
both harder and lots of subjects of

00:47:40,020 --> 00:47:47,130
course I think we have a significantly

00:47:43,680 --> 00:47:49,289
shorter development cycle both for the

00:47:47,130 --> 00:47:53,190
program and the software the driver

00:47:49,289 --> 00:47:55,349
software and user level debris and we

00:47:53,190 --> 00:47:58,289
actually have the working driver did all

00:47:55,349 --> 00:48:02,470
the day we got the first hire in in the

00:47:58,289 --> 00:48:04,869
lab and in the longer term we expect

00:48:02,470 --> 00:48:07,390
more from this infrastructure that we

00:48:04,869 --> 00:48:09,490
built up by they and whenever an shown

00:48:07,390 --> 00:48:11,380
future project I get even further now

00:48:09,490 --> 00:48:14,430
that we don't have to make all new

00:48:11,380 --> 00:48:17,109
tooling in the first time first place

00:48:14,430 --> 00:48:19,420
and the question is what more could have

00:48:17,109 --> 00:48:21,640
done and I think we could have done a

00:48:19,420 --> 00:48:23,530
lot and really excited about it I think

00:48:21,640 --> 00:48:24,280
we could have done the real in the sky's

00:48:23,530 --> 00:48:27,670
the limit

00:48:24,280 --> 00:48:30,430
we could have had several more civil

00:48:27,670 --> 00:48:33,130
national ones but it's really as

00:48:30,430 --> 00:48:36,430
resource allocation is human manpower

00:48:33,130 --> 00:48:38,500
issue and it's also to a great extent

00:48:36,430 --> 00:48:41,170
the trust issue if you're trying to do

00:48:38,500 --> 00:48:44,980
something like this you need to have

00:48:41,170 --> 00:48:48,430
some trusts from management because I've

00:48:44,980 --> 00:48:51,240
seen projects where people try to create

00:48:48,430 --> 00:48:54,730
a lot of ancillary to tests and lots of

00:48:51,240 --> 00:48:58,450
simulation models stuff like that and

00:48:54,730 --> 00:49:00,550
the model ends up not being used time

00:48:58,450 --> 00:49:05,160
has been wasted so management is

00:49:00,550 --> 00:49:10,270
typically very and has to become

00:49:05,160 --> 00:49:13,740
critical to a lot of upfront investment

00:49:10,270 --> 00:49:17,230
in customers because it can go wrong so

00:49:13,740 --> 00:49:20,740
it's a matter of trust in that sense and

00:49:17,230 --> 00:49:25,119
competence of course some of the

00:49:20,740 --> 00:49:26,859
challenges the challenges we have of

00:49:25,119 --> 00:49:29,500
course there was a lot I had to realize

00:49:26,859 --> 00:49:32,619
a lot of times but that's our one fall

00:49:29,500 --> 00:49:39,400
since we couldn't open sources at that

00:49:32,619 --> 00:49:41,320
point today we can know but also for the

00:49:39,400 --> 00:49:43,990
goods of course the cousin of this

00:49:41,320 --> 00:49:46,030
action has actually shrunk over time it

00:49:43,990 --> 00:49:49,270
was more complicated in their universes

00:49:46,030 --> 00:49:51,099
now it has is much more elegant and

00:49:49,270 --> 00:49:53,849
shorter than it used to be because on

00:49:51,099 --> 00:49:53,849
the developments

00:49:54,849 --> 00:50:01,040
what other problem I had was that PCI

00:49:58,609 --> 00:50:04,490
Express has a memory consistency model

00:50:01,040 --> 00:50:07,700
where writes are ordered that doesn't

00:50:04,490 --> 00:50:09,560
really apply in in the Qumu sense when

00:50:07,700 --> 00:50:12,260
you have the MS coming in you don't

00:50:09,560 --> 00:50:15,440
really have an ordering of memory so I

00:50:12,260 --> 00:50:18,740
have to actually some Thai society it is

00:50:15,440 --> 00:50:22,579
our knowledge about required ordering by

00:50:18,740 --> 00:50:26,900
having introducing a memory barriers

00:50:22,579 --> 00:50:30,260
some places in the the this device

00:50:26,900 --> 00:50:40,790
simulation just to be able to get the

00:50:30,260 --> 00:50:42,619
model that we rely on in order so the

00:50:40,790 --> 00:50:45,290
other challenge of course was to kind of

00:50:42,619 --> 00:50:48,380
at least took off and people started to

00:50:45,290 --> 00:50:50,630
using it the you know the slide told you

00:50:48,380 --> 00:50:53,560
what that was all about and the

00:50:50,630 --> 00:50:56,599
maintenance of VMs and I wanted to do

00:50:53,560 --> 00:51:03,770
several times under briefly out trying

00:50:56,599 --> 00:51:06,310
to go to use the word manager over all

00:51:03,770 --> 00:51:08,830
the new stuff to do

00:51:06,310 --> 00:51:10,990
virtual machine management but there's

00:51:08,830 --> 00:51:15,540
think there wasn't enough time to get

00:51:10,990 --> 00:51:19,710
rid of the shell scripts did another

00:51:15,540 --> 00:51:19,710
interesting problem I have that is

00:51:19,830 --> 00:51:25,240
obvious when you start to run with a

00:51:22,120 --> 00:51:28,120
small simulation mobile yes sir there's

00:51:25,240 --> 00:51:32,590
a timer we have this what I call a

00:51:28,120 --> 00:51:35,170
timeout scaling problem if on Hardware

00:51:32,590 --> 00:51:38,020
something that takes nanoseconds can

00:51:35,170 --> 00:51:40,570
take tens of seconds on the RTL

00:51:38,020 --> 00:51:42,370
simulation what is nice about that is

00:51:40,570 --> 00:51:45,310
that I can actually wipe and see the

00:51:42,370 --> 00:51:47,110
package policy in real time so I can

00:51:45,310 --> 00:51:51,180
have a cup of coffee or something

00:51:47,110 --> 00:51:55,180
oh dear married the Americas Oh

00:51:51,180 --> 00:51:58,720
everything in order in a kind of slow

00:51:55,180 --> 00:52:00,700
pace suitable to my brain but the

00:51:58,720 --> 00:52:03,460
problem is that the kernel becomes

00:52:00,700 --> 00:52:05,230
really angry it has to wait for 25

00:52:03,460 --> 00:52:07,630
seconds for something you get into

00:52:05,230 --> 00:52:12,310
turning soft block ups and even hard

00:52:07,630 --> 00:52:16,230
lock ups and that was kind of

00:52:12,310 --> 00:52:19,000
problematic to handle what I did to

00:52:16,230 --> 00:52:20,800
alleviate the most serious problems was

00:52:19,000 --> 00:52:23,410
to add some patches to some of the

00:52:20,800 --> 00:52:27,280
modules in the kernel - to avoid it from

00:52:23,410 --> 00:52:30,010
timing out by having this scaling final

00:52:27,280 --> 00:52:32,440
scaling factor that I kind of introduced

00:52:30,010 --> 00:52:34,230
that what we're able to set the filter

00:52:32,440 --> 00:52:37,090
for different simulation environments

00:52:34,230 --> 00:52:40,300
but that's not you know I haven't been

00:52:37,090 --> 00:52:43,600
able to handle network stack network

00:52:40,300 --> 00:52:47,050
time also when we try to run IP over I

00:52:43,600 --> 00:52:50,320
be on this harbor slow harbor simulation

00:52:47,050 --> 00:52:53,350
we run into problems because either to

00:52:50,320 --> 00:52:59,730
try out a new IP prime or TCP entitled

00:52:53,350 --> 00:53:03,100
long before me we want to actually start

00:52:59,730 --> 00:53:05,620
so that's something I wonder that's

00:53:03,100 --> 00:53:07,450
something for them to work on on this is

00:53:05,620 --> 00:53:11,200
- how can you

00:53:07,450 --> 00:53:19,450
nonsense I'm Colonel particular related

00:53:11,200 --> 00:53:25,270
Marcus is this yeah some of them getting

00:53:19,450 --> 00:53:27,160
the patches merged better truth

00:53:25,270 --> 00:53:29,380
one thing I'm intrigued about of them

00:53:27,160 --> 00:53:31,839
like to see if there's a possibility to

00:53:29,380 --> 00:53:34,809
be able to actually hold a virtual

00:53:31,839 --> 00:53:37,329
machine in the kernel from within the

00:53:34,809 --> 00:53:40,150
virtual machine from from beneath the

00:53:37,329 --> 00:53:44,380
virtual machine now I'm happy to

00:53:40,150 --> 00:53:49,180
recompile it ad to be very point-blank

00:53:44,380 --> 00:53:56,410
but I'm like to do if I have a machine

00:53:49,180 --> 00:54:00,280
that this fact a lot of this happiness

00:53:56,410 --> 00:54:02,079
about changing people in smiles so lots

00:54:00,280 --> 00:54:04,210
of social engineering trying to kind of

00:54:02,079 --> 00:54:07,240
sneak things out try to convince people

00:54:04,210 --> 00:54:09,940
that it's a their own very good to to

00:54:07,240 --> 00:54:14,410
work test driven that we spend time and

00:54:09,940 --> 00:54:18,549
truly obviously their evolutionary

00:54:14,410 --> 00:54:21,910
approach once again kind of for novice

00:54:18,549 --> 00:54:24,280
to think that developers also need

00:54:21,910 --> 00:54:26,770
things to be neat so all the tests

00:54:24,280 --> 00:54:28,540
around for people to start using it it

00:54:26,770 --> 00:54:31,750
should look good you should get a good

00:54:28,540 --> 00:54:34,510
feeling if the tests passed and a bad

00:54:31,750 --> 00:54:40,030
feeling if they fail so that you are a

00:54:34,510 --> 00:54:43,569
client fix them and finally my personal

00:54:40,030 --> 00:54:46,299
take a ride if you want understand how a

00:54:43,569 --> 00:54:47,330
particular piece of hardware works try

00:54:46,299 --> 00:54:51,160
to write an

00:54:47,330 --> 00:54:51,160
recorded questions

00:54:55,000 --> 00:55:04,510
hello dimensions using KGTV 50 buggy no

00:55:02,530 --> 00:55:07,540
colonel is there a specific reason why

00:55:04,510 --> 00:55:17,170
he didn't just use HTTP server tell you

00:55:07,540 --> 00:55:25,990
this quite me use TD visa I should look

00:55:17,170 --> 00:55:28,450
into that you mentioned you are doing

00:55:25,990 --> 00:55:30,640
this as our only device right there is

00:55:28,450 --> 00:55:37,140
also directly attachment of like of

00:55:30,640 --> 00:55:39,760
multiple virtual functions as our VM

00:55:37,140 --> 00:55:44,770
instances virtual functions and that's

00:55:39,760 --> 00:55:47,710
why the ISO file is able to have these

00:55:44,770 --> 00:55:49,630
styrofoam device model because it's it

00:55:47,710 --> 00:55:51,760
requires both the physical of our mobile

00:55:49,630 --> 00:55:54,070
and the virtual device model kind of

00:55:51,760 --> 00:55:56,080
okay but do you rely on the this

00:55:54,070 --> 00:55:57,970
dimension this the virtual a new patch

00:55:56,080 --> 00:56:00,250
by yury rounds over to element patches

00:55:57,970 --> 00:56:04,240
to rally the multiple requests ideas

00:56:00,250 --> 00:56:07,350
father DNA no that's that's something

00:56:04,240 --> 00:56:15,310
the Sahrawi patch will take care ok

00:56:07,350 --> 00:56:16,350
thank you hello you mentioned is that so

00:56:15,310 --> 00:56:21,130
I say otherwise

00:56:16,350 --> 00:56:24,940
however as a member you need right yeah

00:56:21,130 --> 00:56:29,680
so so my question is hard to emulate

00:56:24,940 --> 00:56:35,470
sister this is a MMO you need to emu

00:56:29,680 --> 00:56:38,740
oh this particular mm you test facility

00:56:35,470 --> 00:56:42,310
that I was talking about was just it's

00:56:38,740 --> 00:56:44,470
just a an extension to the device model

00:56:42,310 --> 00:56:46,600
a simple extension that just checks all

00:56:44,470 --> 00:56:49,090
the address puts creates a table of all

00:56:46,600 --> 00:56:51,970
the addresses that is that it receives

00:56:49,090 --> 00:56:53,349
while the DMA API because there are

00:56:51,970 --> 00:56:56,799
Saturday

00:56:53,349 --> 00:56:58,779
dai gathers DMA API in the driver that

00:56:56,799 --> 00:57:00,519
you wearing that callbacks where a

00:56:58,779 --> 00:57:04,660
driver can get call backs for all types

00:57:00,519 --> 00:57:06,910
of DMA accesses or setup and they may

00:57:04,660 --> 00:57:08,710
not think that on mappings and we just

00:57:06,910 --> 00:57:11,769
implement those callbacks for the

00:57:08,710 --> 00:57:16,739
purpose of testing and then write to

00:57:11,769 --> 00:57:19,930
special csr page in the device where the

00:57:16,739 --> 00:57:22,749
curbside picks that up and the model

00:57:19,930 --> 00:57:27,069
picks it up and and adds to that take

00:57:22,749 --> 00:57:34,180
this kind of a take simple two months I

00:57:27,069 --> 00:57:36,160
have a new solution so whatever happened

00:57:34,180 --> 00:57:42,220
before the test that I change it's a

00:57:36,160 --> 00:57:48,160
base table was a good advice I mean it

00:57:42,220 --> 00:58:02,229
was a really change to Mme you was a big

00:57:48,160 --> 00:58:09,479
device the same I'm a human under a CH

00:58:02,229 --> 00:58:12,609
device which I say to device is a VM

00:58:09,479 --> 00:58:16,239
yeah so this is a this works the same

00:58:12,609 --> 00:58:21,880
way as it's kind of the way they ordered

00:58:16,239 --> 00:58:25,180
my stack works your macro memory to you

00:58:21,880 --> 00:58:27,069
you pay the colonel will pin the memory

00:58:25,180 --> 00:58:29,349
that is accessible so that memories

00:58:27,069 --> 00:58:32,380
looked for the entire lifetime without

00:58:29,349 --> 00:58:34,719
the region and then it gets a lot and

00:58:32,380 --> 00:58:37,869
then the device will destroy the binding

00:58:34,719 --> 00:58:39,759
so the bonding will always be static

00:58:37,869 --> 00:58:42,400
kind of for the lifetime at that point

00:58:39,759 --> 00:58:46,390
they while totally partisan from the

00:58:42,400 --> 00:58:48,460
device so that there's no that we don't

00:58:46,390 --> 00:58:51,650
have in this device there's no support

00:58:48,460 --> 00:58:52,760
for page request interfaces that

00:58:51,650 --> 00:58:55,160
if that's what they're talking about

00:58:52,760 --> 00:58:57,590
kind of dynamic painting and stuff like

00:58:55,160 --> 00:59:04,310
that Phil will advise some things thank

00:58:57,590 --> 00:59:10,600
you other questions I'm almost running

00:59:04,310 --> 00:59:10,600

YouTube URL: https://www.youtube.com/watch?v=ZpvsI5PJik4


