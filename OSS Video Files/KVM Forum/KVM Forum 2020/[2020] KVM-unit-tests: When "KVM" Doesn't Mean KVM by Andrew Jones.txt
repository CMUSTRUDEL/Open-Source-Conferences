Title: [2020] KVM-unit-tests: When "KVM" Doesn't Mean KVM by Andrew Jones
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	kvm-unit-tests is a tool created to help develop KVM. Like many tools, while it was initially intended for more specific tasks, other applications of it have emerged over time. For some of these new applications, KVM isn't even in the picture. We present the evolution of kvm-unit-tests, from its origins to current day, describing how the unit test framework can support multiple targets with no impact to test code. We also make suggestions of new targets and framework enhancements for the further generalization of the tool.

---

Andrew Jones
Red Hat, Principal Software Engineer

Andrew (Drew) has been involved in system software development for almost 20 years. Drew has focused over half of those years on Virtualization, starting with pHype at IBM, and then continuing with Xen and KVM/QEMU at Red Hat. For the majority of the last decade he has been leading a team at Red Hat which has the objective of bringing Red Hat's enterprise virtualization stack to AArch64 servers. Additionally, from his first official task as a Software Engineer in 2001, which was to port a test suite to an embedded platform in order to fuzz an RTOS, Drew has kept software testing a top priority. Regarding AArch64 KVM testing, he contributed and maintains the KVM selftests AArch64 port, as well as the Arm/AArch64 support for kvm-unit-tests. His contributions to kvm-unit-tests also include the initial PowerPC support and several framework enhancements which apply to all supported architectures. Drew presented an overview of kvm-unit-tests at KVM Forum 2015.
Captions: 
	00:00:11,519 --> 00:00:14,000
hello

00:00:12,160 --> 00:00:16,560
i'm drew jones and this presentation is

00:00:14,000 --> 00:00:19,520
about testing targets other than kvm

00:00:16,560 --> 00:00:20,880
with kvm unit tests to broaden the

00:00:19,520 --> 00:00:23,439
testing domain we

00:00:20,880 --> 00:00:25,680
also present building unit tests as fe

00:00:23,439 --> 00:00:25,680
apps

00:00:27,199 --> 00:00:30,480
presentation is organized as follows we

00:00:29,519 --> 00:00:33,680
do a quick

00:00:30,480 --> 00:00:37,200
introduction to kvmuta tests followed by

00:00:33,680 --> 00:00:39,040
a quick status of the non-kvm targets we

00:00:37,200 --> 00:00:40,800
already can test

00:00:39,040 --> 00:00:43,280
then we present the motivation current

00:00:40,800 --> 00:00:46,480
status and implementation

00:00:43,280 --> 00:00:49,600
of building unit tests as fe apps

00:00:46,480 --> 00:00:52,160
finally we wrap up with a summary of the

00:00:49,600 --> 00:00:52,160
main points

00:00:53,039 --> 00:00:56,800
so what are kvm unit tests well as the

00:00:55,680 --> 00:00:59,520
name suggests

00:00:56,800 --> 00:01:01,520
it's the test framework for testing kvm

00:00:59,520 --> 00:01:04,239
and it also tests communion

00:01:01,520 --> 00:01:06,080
how does it do that well we run tiny

00:01:04,239 --> 00:01:08,240
guests

00:01:06,080 --> 00:01:10,159
operating systems that when they

00:01:08,240 --> 00:01:13,200
generate

00:01:10,159 --> 00:01:16,560
traps to kvm or exits to pmu we can

00:01:13,200 --> 00:01:19,759
test for specific behaviors uh

00:01:16,560 --> 00:01:22,640
what does a unit test look like to a

00:01:19,759 --> 00:01:23,920
test developer it looks quite familiar

00:01:22,640 --> 00:01:27,680
it looks like a typical c

00:01:23,920 --> 00:01:31,520
program that starts in maine also the

00:01:27,680 --> 00:01:34,799
api in many cases is familiar

00:01:31,520 --> 00:01:38,079
such as when we mimic kernel

00:01:34,799 --> 00:01:41,680
named functions irq enable for example

00:01:38,079 --> 00:01:44,960
also we have some lipsy functions

00:01:41,680 --> 00:01:46,320
implemented uh in order to be easy to

00:01:44,960 --> 00:01:49,280
adopt

00:01:46,320 --> 00:01:49,920
one thing to keep in mind is that we are

00:01:49,280 --> 00:01:53,119
not in

00:01:49,920 --> 00:01:55,920
user mode when we enter this main

00:01:53,119 --> 00:01:57,439
are in kernel mode if you want to learn

00:01:55,920 --> 00:01:58,079
more about kv immediate tests there's a

00:01:57,439 --> 00:02:01,280
write-up

00:01:58,079 --> 00:02:04,399
on the kvm web pages

00:02:01,280 --> 00:02:06,159
which has a link down below

00:02:04,399 --> 00:02:08,720
and immediately following this

00:02:06,159 --> 00:02:12,160
presentation eric oger will present on

00:02:08,720 --> 00:02:14,879
giving me to test as well as another kvm

00:02:12,160 --> 00:02:14,879
test framework

00:02:16,640 --> 00:02:20,959
so this diagram is just to make sure

00:02:19,440 --> 00:02:22,800
we're clear on where it gave the immune

00:02:20,959 --> 00:02:25,040
test run

00:02:22,800 --> 00:02:27,840
exactly the same place as a normal

00:02:25,040 --> 00:02:27,840
gadium vm

00:02:31,760 --> 00:02:35,200
so what's the current status of testing

00:02:33,440 --> 00:02:38,959
non-kvm targets

00:02:35,200 --> 00:02:42,319
well because a gaming media test is

00:02:38,959 --> 00:02:44,800
used as qmu for skating user space

00:02:42,319 --> 00:02:45,599
then other kmu accelerators are a

00:02:44,800 --> 00:02:49,120
natural

00:02:45,599 --> 00:02:51,519
target tcg is probably always

00:02:49,120 --> 00:02:54,319
worked to some degree and and then uh

00:02:51,519 --> 00:02:57,120
not only another test target but

00:02:54,319 --> 00:02:58,959
a common way to develop tests uh for

00:02:57,120 --> 00:03:02,400
cross arch

00:02:58,959 --> 00:03:04,000
before uh moving the test to kvm to see

00:03:02,400 --> 00:03:05,920
if it works on kvm and real hardware as

00:03:04,000 --> 00:03:09,200
well um

00:03:05,920 --> 00:03:10,480
also hypervisor framework and windows

00:03:09,200 --> 00:03:14,000
hypervisor platform

00:03:10,480 --> 00:03:14,000
are supported for testing

00:03:14,560 --> 00:03:18,720
beyond kmu accelerators other

00:03:17,680 --> 00:03:21,440
hypervisors

00:03:18,720 --> 00:03:22,720
can already be tested for example on

00:03:21,440 --> 00:03:26,720
s390x

00:03:22,720 --> 00:03:28,480
zvm and lpar hypervisors

00:03:26,720 --> 00:03:31,440
if you want to learn more about those

00:03:28,480 --> 00:03:33,680
then you can check a presentation

00:03:31,440 --> 00:03:34,799
a forum presentation from last year that

00:03:33,680 --> 00:03:38,879
was presented by

00:03:34,799 --> 00:03:42,480
janos fan finally uh

00:03:38,879 --> 00:03:46,480
just a bit over a year ago vmware

00:03:42,480 --> 00:03:49,599
contributors posted over 50 patches

00:03:46,480 --> 00:03:52,879
to kvm unit tests in order to enable the

00:03:49,599 --> 00:03:56,159
test to run on bare metal and on vmware

00:03:52,879 --> 00:03:58,080
the approach used for that is to launch

00:03:56,159 --> 00:04:01,840
the test from grub

00:03:58,080 --> 00:04:03,760
and they also uh use a lesser-known

00:04:01,840 --> 00:04:06,239
feature of kv-muted tests which is

00:04:03,760 --> 00:04:06,959
environment variables um as stated

00:04:06,239 --> 00:04:08,959
before

00:04:06,959 --> 00:04:10,239
giving a test looks just like a user

00:04:08,959 --> 00:04:12,959
space

00:04:10,239 --> 00:04:14,239
c program with the main where you have

00:04:12,959 --> 00:04:15,840
your

00:04:14,239 --> 00:04:17,919
command line arguments that you can

00:04:15,840 --> 00:04:20,639
parse as well as

00:04:17,919 --> 00:04:21,120
it has an environment so you can use git

00:04:20,639 --> 00:04:24,639
in

00:04:21,120 --> 00:04:26,840
or whatever uh in order to be able to

00:04:24,639 --> 00:04:30,080
check for environment variables which

00:04:26,840 --> 00:04:31,680
allows a nice way to configure tests for

00:04:30,080 --> 00:04:34,560
different environments without having to

00:04:31,680 --> 00:04:34,560
recompile them

00:04:37,040 --> 00:04:40,400
so what's the motivation for building

00:04:38,800 --> 00:04:43,919
these unit tests

00:04:40,400 --> 00:04:44,720
as fe apps well as we want to expand the

00:04:43,919 --> 00:04:48,000
domain

00:04:44,720 --> 00:04:50,320
of targets that we can test on

00:04:48,000 --> 00:04:51,440
then choosing something like an fv app

00:04:50,320 --> 00:04:54,880
which is

00:04:51,440 --> 00:04:58,400
or an fe target which is the reason

00:04:54,880 --> 00:05:00,000
why uh it exists in order to help

00:04:58,400 --> 00:05:01,919
operating systems and secondary boot

00:05:00,000 --> 00:05:03,360
loaders be portable

00:05:01,919 --> 00:05:05,680
we can also make caving unit tests

00:05:03,360 --> 00:05:08,840
portable

00:05:05,680 --> 00:05:10,080
they are tiny operating systems after

00:05:08,840 --> 00:05:13,919
all uh

00:05:10,080 --> 00:05:15,759
also similar to the grub approach we can

00:05:13,919 --> 00:05:17,919
use environment variables if necessary

00:05:15,759 --> 00:05:19,360
to avoid

00:05:17,919 --> 00:05:22,639
having to recompile the tests for

00:05:19,360 --> 00:05:24,400
different targets as

00:05:22,639 --> 00:05:26,560
fe targets also support environment

00:05:24,400 --> 00:05:28,720
variables

00:05:26,560 --> 00:05:30,639
it's a relatively easy targets to choose

00:05:28,720 --> 00:05:33,919
as well in order to

00:05:30,639 --> 00:05:33,919
to get a new target quickly

00:05:34,560 --> 00:05:40,160
and we have a couple of other benefits

00:05:36,560 --> 00:05:42,880
from choosing this particular target

00:05:40,160 --> 00:05:43,360
for example similar to the grub being

00:05:42,880 --> 00:05:44,960
able to

00:05:43,360 --> 00:05:47,520
launch straight from firmware or from

00:05:44,960 --> 00:05:49,840
boot loader

00:05:47,520 --> 00:05:51,600
we'll be able to now remove a large

00:05:49,840 --> 00:05:54,160
amount of the stack necessary

00:05:51,600 --> 00:05:56,160
when we want to develop or test the

00:05:54,160 --> 00:05:57,759
tests themselves

00:05:56,160 --> 00:06:00,000
so when emulators are used instead of

00:05:57,759 --> 00:06:02,240
hardware which is sometimes the case

00:06:00,000 --> 00:06:05,520
for developing kvu minute tests like

00:06:02,240 --> 00:06:05,520
actual test for kvn

00:06:05,600 --> 00:06:09,680
now we should be able to make the

00:06:08,000 --> 00:06:12,479
testing process

00:06:09,680 --> 00:06:13,440
uh of those tests quicker because we

00:06:12,479 --> 00:06:17,039
won't need to boot

00:06:13,440 --> 00:06:19,280
an entire linux operating system um

00:06:17,039 --> 00:06:20,639
and even start up kvm user space we'll

00:06:19,280 --> 00:06:23,680
just go straight from

00:06:20,639 --> 00:06:26,319
firmware to test uh

00:06:23,680 --> 00:06:28,160
and if you're thinking that maybe not

00:06:26,319 --> 00:06:32,080
all emulators or

00:06:28,160 --> 00:06:35,280
or models will support

00:06:32,080 --> 00:06:35,919
edk2 uh in order to be able to do that

00:06:35,280 --> 00:06:39,199
well that's

00:06:35,919 --> 00:06:43,520
don't don't be have no fear um

00:06:39,199 --> 00:06:43,520
uboot also supports launching effie apps

00:06:43,919 --> 00:06:49,120
also uh maybe a lesser benefit because

00:06:46,400 --> 00:06:52,319
i'm i'm sure that

00:06:49,120 --> 00:06:54,960
uefi has several

00:06:52,319 --> 00:06:54,960
unit testing

00:06:55,840 --> 00:06:59,680
frameworks already so it probably

00:06:57,759 --> 00:07:03,039
doesn't need knee mini tests but

00:06:59,680 --> 00:07:06,720
we can now also test uh these

00:07:03,039 --> 00:07:08,720
uh fe implementations

00:07:06,720 --> 00:07:10,160
with gave me the tests if we can run on

00:07:08,720 --> 00:07:12,960
them so

00:07:10,160 --> 00:07:12,960
yet another target

00:07:13,680 --> 00:07:17,360
okay here's our diagram from before

00:07:16,300 --> 00:07:19,599
[Music]

00:07:17,360 --> 00:07:20,560
on the left it's basically the same it

00:07:19,599 --> 00:07:23,599
just shows

00:07:20,560 --> 00:07:26,880
that in order to run the unit test now

00:07:23,599 --> 00:07:30,160
in the typical vert stack we also

00:07:26,880 --> 00:07:35,360
need to add in the virtual machine

00:07:30,160 --> 00:07:35,360
firmware for ar64 we refer to that

00:07:35,599 --> 00:07:39,199
as avmf and for x86 we refer to it as

00:07:38,319 --> 00:07:41,759
ovmf

00:07:39,199 --> 00:07:43,759
and both of them are exist and are

00:07:41,759 --> 00:07:47,120
supported and developed

00:07:43,759 --> 00:07:47,120
so we can do that

00:07:47,440 --> 00:07:51,280
also we can cut out the entire birch

00:07:50,639 --> 00:07:52,800
stack

00:07:51,280 --> 00:07:54,879
and go straight from the hardware or

00:07:52,800 --> 00:07:57,599
emulator

00:07:54,879 --> 00:08:00,639
into the firmware which supports fe and

00:07:57,599 --> 00:08:00,639
then straight into the test

00:08:05,039 --> 00:08:09,199
so um what's the current status of this

00:08:08,080 --> 00:08:12,240
fe app building

00:08:09,199 --> 00:08:14,720
well nothing is

00:08:12,240 --> 00:08:16,560
is merged nothing is even posted yet but

00:08:14,720 --> 00:08:19,680
uh i do have a

00:08:16,560 --> 00:08:23,280
proof of concept patch set

00:08:19,680 --> 00:08:26,560
available in my github repository on the

00:08:23,280 --> 00:08:30,639
target effort branch and

00:08:26,560 --> 00:08:33,440
you can compile unit test as fe apps by

00:08:30,639 --> 00:08:35,200
simply enabling the target fe configure

00:08:33,440 --> 00:08:38,240
switch

00:08:35,200 --> 00:08:38,880
running make and then when you move

00:08:38,240 --> 00:08:42,080
these

00:08:38,880 --> 00:08:44,080
fe apps to uh to the

00:08:42,080 --> 00:08:46,160
fat file system the empty file system

00:08:44,080 --> 00:08:49,440
for the target

00:08:46,160 --> 00:08:50,080
for example kmu and avmf then you can

00:08:49,440 --> 00:08:52,640
launch them

00:08:50,080 --> 00:08:54,720
and well currently the patch series is

00:08:52,640 --> 00:08:57,760
only for age 64 but

00:08:54,720 --> 00:09:00,480
i intend to expand that for x86 as well

00:08:57,760 --> 00:09:00,480
in the near future

00:09:00,560 --> 00:09:06,000
anyway they work great over here mu

00:09:04,160 --> 00:09:07,519
but that's not super exciting because we

00:09:06,000 --> 00:09:10,080
could already run the tests

00:09:07,519 --> 00:09:11,600
over qmu without the need for firmware

00:09:10,080 --> 00:09:13,760
even

00:09:11,600 --> 00:09:14,720
so the work in progress is to get them

00:09:13,760 --> 00:09:17,279
to also run

00:09:14,720 --> 00:09:18,959
directly on bare metal and i've already

00:09:17,279 --> 00:09:22,720
started that work

00:09:18,959 --> 00:09:23,200
testing with an amd seattle and so as i

00:09:22,720 --> 00:09:26,800
said

00:09:23,200 --> 00:09:30,959
x86 is in the queue um naturally i'll

00:09:26,800 --> 00:09:34,399
start with ovmf as the targets

00:09:30,959 --> 00:09:36,080
but a quick second stop opm for cuny for

00:09:34,399 --> 00:09:37,040
the first target but as a quick second

00:09:36,080 --> 00:09:40,000
stop uh

00:09:37,040 --> 00:09:40,800
it'll be ovmf over virtualbox because

00:09:40,000 --> 00:09:43,839
virtualbox

00:09:40,800 --> 00:09:43,839
also supports ovmf

00:09:45,200 --> 00:09:49,360
okay so the rest of the talk is about

00:09:47,360 --> 00:09:53,120
the implementation

00:09:49,360 --> 00:09:55,680
some of the details so um to do that

00:09:53,120 --> 00:09:56,240
this is kind of an outline of of the

00:09:55,680 --> 00:10:00,160
remaining

00:09:56,240 --> 00:10:01,600
slides uh first we will

00:10:00,160 --> 00:10:03,360
talk about what needs to be added the

00:10:01,600 --> 00:10:06,320
framework in order to support

00:10:03,360 --> 00:10:07,839
building as fe apps also it needs to be

00:10:06,320 --> 00:10:10,240
removed

00:10:07,839 --> 00:10:13,200
actually nothing is really removed but

00:10:10,240 --> 00:10:17,200
compiled in different ways or bypassed

00:10:13,200 --> 00:10:19,440
and then some other changes that

00:10:17,200 --> 00:10:22,320
are needed in order to start supporting

00:10:19,440 --> 00:10:22,320
multiple targets

00:10:24,800 --> 00:10:28,160
so what do we add well the main thing we

00:10:27,440 --> 00:10:32,959
add

00:10:28,160 --> 00:10:32,959
is the dependency on gnu fe

00:10:33,120 --> 00:10:37,839
development environment and uh that uses

00:10:35,279 --> 00:10:41,200
the gnu tool chain

00:10:37,839 --> 00:10:43,920
this um when linking

00:10:41,200 --> 00:10:46,560
with inuffy and creating fe apps in this

00:10:43,920 --> 00:10:48,640
way it's a bit of an odd build process

00:10:46,560 --> 00:10:50,320
the app that you're building you start

00:10:48,640 --> 00:10:52,640
out by compiling linking as a shared

00:10:50,320 --> 00:10:55,040
library

00:10:52,640 --> 00:10:56,079
along with obj copying select sections

00:10:55,040 --> 00:10:59,360
and to create this

00:10:56,079 --> 00:11:01,839
fe binary uh

00:10:59,360 --> 00:11:01,839
then

00:11:02,480 --> 00:11:06,320
then one thing uh to know about all the

00:11:04,480 --> 00:11:09,040
gnuffy apps is that they

00:11:06,320 --> 00:11:10,560
they all start in an effi main function

00:11:09,040 --> 00:11:12,720
that's supposed to mean

00:11:10,560 --> 00:11:14,320
uh which you need to write yourself for

00:11:12,720 --> 00:11:17,200
your app and

00:11:14,320 --> 00:11:18,880
in our case for kvm unit tests we would

00:11:17,200 --> 00:11:21,600
like to

00:11:18,880 --> 00:11:23,519
have just a single fe app implementation

00:11:21,600 --> 00:11:27,839
that will work for all architectures

00:11:23,519 --> 00:11:31,360
and for all tests that's a goal

00:11:27,839 --> 00:11:33,760
also the point of the fe app for

00:11:31,360 --> 00:11:34,959
for our purposes for kvm unit tests is

00:11:33,760 --> 00:11:38,000
to

00:11:34,959 --> 00:11:40,640
do the startup

00:11:38,000 --> 00:11:41,279
setup before launching the unit test

00:11:40,640 --> 00:11:44,480
which

00:11:41,279 --> 00:11:48,560
is the main function so

00:11:44,480 --> 00:11:51,519
in other words femaine will do

00:11:48,560 --> 00:11:53,120
test preparation to start up and then

00:11:51,519 --> 00:11:55,920
call main

00:11:53,120 --> 00:11:56,639
another thing that now that we're

00:11:55,920 --> 00:12:00,800
running on a

00:11:56,639 --> 00:12:04,240
fe target we can do

00:12:00,800 --> 00:12:04,880
is we can exit from the unit test or

00:12:04,240 --> 00:12:10,160
quit the

00:12:04,880 --> 00:12:11,040
unit test in a different way so one

00:12:10,160 --> 00:12:13,839
thing that's a bit

00:12:11,040 --> 00:12:15,279
odd about how kvm unit tests works when

00:12:13,839 --> 00:12:18,720
running over key memo

00:12:15,279 --> 00:12:22,000
at kvm is there's no easy way to

00:12:18,720 --> 00:12:23,850
to exit from running vm

00:12:22,000 --> 00:12:25,920
at the vm's

00:12:23,850 --> 00:12:29,360
[Music]

00:12:25,920 --> 00:12:30,959
time of choice without using sort of

00:12:29,360 --> 00:12:33,120
power management or something which

00:12:30,959 --> 00:12:35,279
originally wasn't implemented for gave

00:12:33,120 --> 00:12:39,440
me the test it is now

00:12:35,279 --> 00:12:41,839
for at least arm and power pc

00:12:39,440 --> 00:12:43,279
but uh we also want to be able to hand

00:12:41,839 --> 00:12:45,920
back a status code

00:12:43,279 --> 00:12:46,320
to the shell that launched the test and

00:12:45,920 --> 00:12:48,959
so

00:12:46,320 --> 00:12:50,639
even then it's uh insufficient to just

00:12:48,959 --> 00:12:52,560
implement the power management we

00:12:50,639 --> 00:12:53,920
we use a thing called a test dev allows

00:12:52,560 --> 00:12:58,800
you to

00:12:53,920 --> 00:13:01,920
pass a a status code and tell qmmu

00:12:58,800 --> 00:13:03,200
it's time to quit well we can now

00:13:01,920 --> 00:13:05,200
we can no longer do that because we

00:13:03,200 --> 00:13:08,079
don't have a test dev

00:13:05,200 --> 00:13:09,440
obvious not when running on uh directly

00:13:08,079 --> 00:13:12,720
on the hardware we can still have a test

00:13:09,440 --> 00:13:16,880
development running over camera sure but

00:13:12,720 --> 00:13:20,000
now we prefer to use the fe

00:13:16,880 --> 00:13:24,079
uefi or runtime service to be able

00:13:20,000 --> 00:13:26,160
to um to exit

00:13:24,079 --> 00:13:27,279
also i should point out uh the on the

00:13:26,160 --> 00:13:30,720
second to last bullet

00:13:27,279 --> 00:13:32,320
um i bring up exit boot services

00:13:30,720 --> 00:13:34,639
uh as something else we need to do after

00:13:32,320 --> 00:13:38,240
preparing to launch the guest

00:13:34,639 --> 00:13:41,519
i want to test and this is a uefi

00:13:38,240 --> 00:13:46,000
thing which basically says

00:13:41,519 --> 00:13:47,680
uh okay thank you ebf5 for getting our

00:13:46,000 --> 00:13:48,720
app launched but now please get out of

00:13:47,680 --> 00:13:51,600
the way

00:13:48,720 --> 00:13:53,760
so some of the things it's it's a setup

00:13:51,600 --> 00:13:56,079
while running the app such as

00:13:53,760 --> 00:13:58,480
timer events so interrupts being

00:13:56,079 --> 00:13:58,480
delivered

00:13:59,199 --> 00:14:02,480
will interfere with the test of course

00:14:01,440 --> 00:14:05,760
so we need to

00:14:02,480 --> 00:14:07,920
call exit boot services in order for

00:14:05,760 --> 00:14:08,800
those things to go away the runtime

00:14:07,920 --> 00:14:11,920
services

00:14:08,800 --> 00:14:12,959
another uefi thing are left in place for

00:14:11,920 --> 00:14:17,199
us to use

00:14:12,959 --> 00:14:20,800
when we want to exit the test

00:14:17,199 --> 00:14:24,000
okay so what gets removed or bypassed

00:14:20,800 --> 00:14:25,600
um well our own linker script

00:14:24,000 --> 00:14:27,440
for example though it gave him unit

00:14:25,600 --> 00:14:28,959
tests defaults or

00:14:27,440 --> 00:14:32,160
original linker script cannot be used

00:14:28,959 --> 00:14:35,440
anymore because gnuffee provides one

00:14:32,160 --> 00:14:37,360
so we're swapping that out uh this also

00:14:35,440 --> 00:14:40,800
means any symbols in the linker scripts

00:14:37,360 --> 00:14:45,440
need to be either avoided

00:14:40,800 --> 00:14:47,279
or maybe renamed in the case of the ar64

00:14:45,440 --> 00:14:48,959
proof of concept

00:14:47,279 --> 00:14:51,360
i did a little both i avoided most of

00:14:48,959 --> 00:14:51,360
them but

00:14:51,440 --> 00:14:56,079
there was actually no reason not to just

00:14:53,600 --> 00:14:56,079
rename

00:14:56,240 --> 00:15:01,600
e-text to underscory text which is a

00:14:58,720 --> 00:15:04,240
more popular name for that symbol anyway

00:15:01,600 --> 00:15:04,240
then um

00:15:04,959 --> 00:15:09,040
another another goal then for this port

00:15:07,839 --> 00:15:11,519
is to

00:15:09,040 --> 00:15:13,839
take all of the assumptions or all of

00:15:11,519 --> 00:15:13,839
the

00:15:14,000 --> 00:15:17,519
references that the original linker

00:15:16,639 --> 00:15:21,360
script

00:15:17,519 --> 00:15:24,240
creates and shove them into as little

00:15:21,360 --> 00:15:25,519
space as possible so just into the

00:15:24,240 --> 00:15:27,199
startup code that

00:15:25,519 --> 00:15:28,800
we have in our init section is where i

00:15:27,199 --> 00:15:32,480
want those to live

00:15:28,800 --> 00:15:35,120
that way when we build as an effi app

00:15:32,480 --> 00:15:36,399
we just need to have that in its section

00:15:35,120 --> 00:15:38,399
if deft out

00:15:36,399 --> 00:15:40,959
and we can continue from where we would

00:15:38,399 --> 00:15:44,800
have left off

00:15:40,959 --> 00:15:47,279
in the same same way for both targets

00:15:44,800 --> 00:15:50,240
so all the common initialization between

00:15:47,279 --> 00:15:53,279
being an effie app or

00:15:50,240 --> 00:15:57,360
or being a traditional target build

00:15:53,279 --> 00:15:57,839
qmu target can be shoved into the setup

00:15:57,360 --> 00:16:00,480
code

00:15:57,839 --> 00:16:01,759
which is run in c and that can be a

00:16:00,480 --> 00:16:04,320
function called from

00:16:01,759 --> 00:16:07,040
femain so the next slide makes this a

00:16:04,320 --> 00:16:07,040
little bit more clear

00:16:07,120 --> 00:16:13,279
uh by illustrating it so

00:16:10,480 --> 00:16:14,639
on the left you see the original or

00:16:13,279 --> 00:16:18,240
default target

00:16:14,639 --> 00:16:20,240
um and on the right

00:16:18,240 --> 00:16:21,600
uh so that's the flow for that for that

00:16:20,240 --> 00:16:24,639
that target on the right the

00:16:21,600 --> 00:16:26,880
the flow for the fe app target

00:16:24,639 --> 00:16:28,560
so we've rearranged a little bit on who

00:16:26,880 --> 00:16:31,199
does the relocating of the

00:16:28,560 --> 00:16:31,920
uh unit test and where the stack gets

00:16:31,199 --> 00:16:34,240
set up

00:16:31,920 --> 00:16:36,560
now we rely on the effie app side we

00:16:34,240 --> 00:16:39,600
rely on the uefe

00:16:36,560 --> 00:16:39,600
loader to do it for us

00:16:40,959 --> 00:16:46,320
we also currently have the

00:16:44,560 --> 00:16:47,600
preparation of the command line

00:16:46,320 --> 00:16:51,199
arguments the

00:16:47,600 --> 00:16:54,160
the environment variables and the

00:16:51,199 --> 00:16:54,880
memory map all kind of squeeze into

00:16:54,160 --> 00:16:58,720
setup

00:16:54,880 --> 00:17:02,079
on the original target but on the

00:16:58,720 --> 00:17:06,480
fef target a lot of that stuff it's done

00:17:02,079 --> 00:17:10,799
in fmain now using the uefi

00:17:06,480 --> 00:17:15,600
calls so we can pass that information

00:17:10,799 --> 00:17:17,679
in to setup instead on that side

00:17:15,600 --> 00:17:19,280
beyond that the setups should be the

00:17:17,679 --> 00:17:22,400
same

00:17:19,280 --> 00:17:25,120
ideally and then

00:17:22,400 --> 00:17:25,919
definitely a goal is that the unit test

00:17:25,120 --> 00:17:30,720
stays the same

00:17:25,919 --> 00:17:34,799
we shouldn't need to have different code

00:17:30,720 --> 00:17:37,120
running when we're fe app versus not a

00:17:34,799 --> 00:17:38,480
at the app when when running the unit

00:17:37,120 --> 00:17:39,679
test the unit test developers should be

00:17:38,480 --> 00:17:41,280
able to focus

00:17:39,679 --> 00:17:45,280
on just what they want to test and it

00:17:41,280 --> 00:17:45,280
should run in on all targets

00:17:45,520 --> 00:17:49,679
and i already talked about how exit can

00:17:48,080 --> 00:17:53,360
be different

00:17:49,679 --> 00:17:55,600
using a test dev or otherwise on the

00:17:53,360 --> 00:17:56,480
original target and on the ff target you

00:17:55,600 --> 00:17:59,760
can use

00:17:56,480 --> 00:18:02,559
the runtime service call but the flow

00:17:59,760 --> 00:18:02,559
should still be the same

00:18:03,280 --> 00:18:06,480
so this slide uh talks a little bit

00:18:05,520 --> 00:18:09,200
about

00:18:06,480 --> 00:18:10,640
how those differences we saw in the

00:18:09,200 --> 00:18:13,280
previous slide

00:18:10,640 --> 00:18:14,480
on where things happen how they're

00:18:13,280 --> 00:18:18,000
actually different

00:18:14,480 --> 00:18:20,320
as well um what happens so

00:18:18,000 --> 00:18:21,840
the top part uh the top line is just

00:18:20,320 --> 00:18:22,400
about the relocating and there's not

00:18:21,840 --> 00:18:25,840
much

00:18:22,400 --> 00:18:26,960
to say about it as far as getting the

00:18:25,840 --> 00:18:30,240
information

00:18:26,960 --> 00:18:32,799
um getting the device tree or other

00:18:30,240 --> 00:18:34,160
boot time information in the original

00:18:32,799 --> 00:18:36,559
target that's

00:18:34,160 --> 00:18:37,440
that's uh from dt which is actually a

00:18:36,559 --> 00:18:40,559
good thing for

00:18:37,440 --> 00:18:41,120
ar-16 dt is for h64 power and multi-boot

00:18:40,559 --> 00:18:44,400
info

00:18:41,120 --> 00:18:46,000
xc6 but uh um the

00:18:44,400 --> 00:18:47,919
it's good that we already have taught

00:18:46,000 --> 00:18:48,880
gaming tests to look at the dt for these

00:18:47,919 --> 00:18:51,280
things because

00:18:48,880 --> 00:18:53,120
then when we switch to bare metal uh

00:18:51,280 --> 00:18:55,600
with the fdm target

00:18:53,120 --> 00:18:56,480
all we need to do is provide the bare

00:18:55,600 --> 00:18:59,039
metal

00:18:56,480 --> 00:19:01,200
actual hardware dt rather than the qmu

00:18:59,039 --> 00:19:05,360
machine model dt

00:19:01,200 --> 00:19:06,720
um but

00:19:05,360 --> 00:19:07,520
so we already can get the information we

00:19:06,720 --> 00:19:08,559
just have to get it a little bit

00:19:07,520 --> 00:19:11,039
differently on the fe

00:19:08,559 --> 00:19:12,799
side we actually need to read the btb

00:19:11,039 --> 00:19:14,880
from the fe file system

00:19:12,799 --> 00:19:16,799
whereas the dt is provided by keynote

00:19:14,880 --> 00:19:20,080
directly

00:19:16,799 --> 00:19:23,280
a pointer is directly provided to the

00:19:20,080 --> 00:19:27,440
unit test from qmu on the default side

00:19:23,280 --> 00:19:29,039
but um command line arguments come

00:19:27,440 --> 00:19:30,799
from slightly different places we could

00:19:29,039 --> 00:19:32,400
fish them out of uh

00:19:30,799 --> 00:19:34,799
we've fished them out of dt on the

00:19:32,400 --> 00:19:38,080
original targets we need to get them

00:19:34,799 --> 00:19:41,280
from evfi on the fe target

00:19:38,080 --> 00:19:43,840
and environment variables so

00:19:41,280 --> 00:19:45,440
here's where they live in the original

00:19:43,840 --> 00:19:46,559
target they actually live in an nrd

00:19:45,440 --> 00:19:50,080
that's how we

00:19:46,559 --> 00:19:52,320
provide them to the unit test but

00:19:50,080 --> 00:19:54,000
on the fdf target well uefi supports

00:19:52,320 --> 00:19:57,200
environment variables so we get them

00:19:54,000 --> 00:19:59,760
with the native uefi

00:19:57,200 --> 00:19:59,760
service call

00:20:00,320 --> 00:20:07,600
memory map on the

00:20:04,159 --> 00:20:09,120
original target side is uh

00:20:07,600 --> 00:20:11,919
something you can extract from bt or

00:20:09,120 --> 00:20:14,080
multi-boot info sometimes we've just

00:20:11,919 --> 00:20:16,159
uh assumed we were going to be running

00:20:14,080 --> 00:20:16,880
on kmu for so long as i was the main

00:20:16,159 --> 00:20:19,919
target

00:20:16,880 --> 00:20:22,000
that some stuff is hard coded and

00:20:19,919 --> 00:20:23,600
so that all needs to change and use the

00:20:22,000 --> 00:20:27,520
memory map that we can get

00:20:23,600 --> 00:20:29,520
from uefi we can't just continue to

00:20:27,520 --> 00:20:30,960
obviously for bare metal we can't just

00:20:29,520 --> 00:20:34,799
have hard-coded memory

00:20:30,960 --> 00:20:38,320
uh map addresses but

00:20:34,799 --> 00:20:39,840
even if we were using only dt

00:20:38,320 --> 00:20:42,640
to get those addresses it wouldn't be

00:20:39,840 --> 00:20:45,840
enough because

00:20:42,640 --> 00:20:47,600
ubfi reserves some regions of its own

00:20:45,840 --> 00:20:49,840
for the runtime services that we

00:20:47,600 --> 00:20:51,679
want to make sure we're aware of so we

00:20:49,840 --> 00:20:54,799
need to pass in that map

00:20:51,679 --> 00:20:56,240
to the unit test and the unit

00:20:54,799 --> 00:20:59,360
gave me the test framework needs to be

00:20:56,240 --> 00:21:02,799
able to handle that stuff

00:20:59,360 --> 00:21:04,799
the last bullet

00:21:02,799 --> 00:21:06,480
is interesting so we we call set up from

00:21:04,799 --> 00:21:08,880
both that was

00:21:06,480 --> 00:21:10,320
a goal was to get our flows to to

00:21:08,880 --> 00:21:12,559
synchronize again after

00:21:10,320 --> 00:21:15,120
startup but there's still a difference

00:21:12,559 --> 00:21:18,400
and that difference is that uh

00:21:15,120 --> 00:21:20,400
when we come from on the fe app

00:21:18,400 --> 00:21:21,520
target side when we come to setup the

00:21:20,400 --> 00:21:22,559
mmu is on and

00:21:21,520 --> 00:21:24,880
some of the devices have been

00:21:22,559 --> 00:21:26,720
initialized whereas

00:21:24,880 --> 00:21:30,400
on the original targets that's not the

00:21:26,720 --> 00:21:34,480
case so this can um

00:21:30,400 --> 00:21:36,400
this can cause some other issues

00:21:34,480 --> 00:21:39,360
based on assumptions that we have in our

00:21:36,400 --> 00:21:42,640
startup code our setup code

00:21:39,360 --> 00:21:44,400
and we have to work around those

00:21:42,640 --> 00:21:46,080
so that's what brings us to the next

00:21:44,400 --> 00:21:49,200
slide

00:21:46,080 --> 00:21:50,480
so from from the point where the the

00:21:49,200 --> 00:21:52,480
paths would synchronize

00:21:50,480 --> 00:21:55,120
where both targets should have the same

00:21:52,480 --> 00:21:58,799
code which is a goal we don't want

00:21:55,120 --> 00:22:02,240
lots of uh if target fe then this and

00:21:58,799 --> 00:22:04,960
else that stuff uh then we need to

00:22:02,240 --> 00:22:06,080
remember that we've started with mmu on

00:22:04,960 --> 00:22:09,919
so there might need to be

00:22:06,080 --> 00:22:11,039
at least a way to go ahead and disable

00:22:09,919 --> 00:22:13,039
that

00:22:11,039 --> 00:22:14,559
in order to allow it to be reinitialized

00:22:13,039 --> 00:22:16,960
with the same path

00:22:14,559 --> 00:22:17,760
that's quite possible to do because the

00:22:16,960 --> 00:22:21,120
uh

00:22:17,760 --> 00:22:23,039
without any trouble because uh

00:22:21,120 --> 00:22:24,400
the while the mmu is on it's actually

00:22:23,039 --> 00:22:27,520
just using an identity map

00:22:24,400 --> 00:22:30,080
so as long as we uh

00:22:27,520 --> 00:22:32,240
clean the caches when we when we uh

00:22:30,080 --> 00:22:34,960
disable mmu we should be okay to

00:22:32,240 --> 00:22:35,520
to just turn it off run on physical

00:22:34,960 --> 00:22:38,159
memory

00:22:35,520 --> 00:22:40,080
this it will have the same addresses and

00:22:38,159 --> 00:22:42,320
then turn it on in any way we want

00:22:40,080 --> 00:22:45,039
again the same way we would do for the

00:22:42,320 --> 00:22:45,039
original target

00:22:46,159 --> 00:22:49,679
but also the devices some of the devices

00:22:48,480 --> 00:22:51,039
have been in use

00:22:49,679 --> 00:22:53,280
at this point so they're already

00:22:51,039 --> 00:22:53,760
initialized and they maybe need to be

00:22:53,280 --> 00:22:56,400
reset

00:22:53,760 --> 00:22:58,159
before we init which is new because we

00:22:56,400 --> 00:23:01,360
always assumed in the

00:22:58,159 --> 00:23:03,280
original target the qmu kvm target that

00:23:01,360 --> 00:23:05,600
they're fresh and ready for us to start

00:23:03,280 --> 00:23:08,159
poking and using

00:23:05,600 --> 00:23:08,720
um and then there's other device driver

00:23:08,159 --> 00:23:10,799
issues

00:23:08,720 --> 00:23:11,919
like i didn't have any problem writing

00:23:10,799 --> 00:23:15,200
to the uart

00:23:11,919 --> 00:23:17,200
um right away with the

00:23:15,200 --> 00:23:18,720
fe app target but uh i could only write

00:23:17,200 --> 00:23:21,200
32 characters

00:23:18,720 --> 00:23:22,000
because the driver is so simple just

00:23:21,200 --> 00:23:26,400
writing in

00:23:22,000 --> 00:23:27,679
nothing else to the data register

00:23:26,400 --> 00:23:30,080
that we would fill the fifo and it would

00:23:27,679 --> 00:23:32,880
just get stuck so

00:23:30,080 --> 00:23:33,760
now i've added some some fifo handling

00:23:32,880 --> 00:23:35,679
to the driver

00:23:33,760 --> 00:23:37,679
still keeping it as simple as possible

00:23:35,679 --> 00:23:38,960
which i should point out is a main goal

00:23:37,679 --> 00:23:40,400
of kvm unit tests

00:23:38,960 --> 00:23:43,679
we don't want to write another operating

00:23:40,400 --> 00:23:47,279
system we have linux for that

00:23:43,679 --> 00:23:47,279
we want it to be so simple that

00:23:47,360 --> 00:23:51,120
developers can be confident that their

00:23:48,960 --> 00:23:52,240
unit test is doing just what they wanted

00:23:51,120 --> 00:23:54,320
to do and nothing

00:23:52,240 --> 00:23:55,919
but what they wanted to do and also so

00:23:54,320 --> 00:23:58,240
they can jump in and contribute

00:23:55,919 --> 00:23:58,240
quickly

00:24:01,919 --> 00:24:05,840
i already talked about bullet three

00:24:04,400 --> 00:24:07,679
another

00:24:05,840 --> 00:24:09,600
kind of difference between the bare

00:24:07,679 --> 00:24:12,320
metal and qmu world

00:24:09,600 --> 00:24:13,840
pmu target world is sometimes you need a

00:24:12,320 --> 00:24:15,440
carriage return

00:24:13,840 --> 00:24:17,120
uh we could make that configurable of

00:24:15,440 --> 00:24:18,480
course

00:24:17,120 --> 00:24:21,200
other things we already talked about the

00:24:18,480 --> 00:24:23,279
mmu um on the last bullets there

00:24:21,200 --> 00:24:24,559
but um anything else that we find that

00:24:23,279 --> 00:24:26,400
uh

00:24:24,559 --> 00:24:27,760
well maybe we do need a different path

00:24:26,400 --> 00:24:30,559
we can't exactly have

00:24:27,760 --> 00:24:32,880
perfectly synchronized paths but we

00:24:30,559 --> 00:24:34,799
could possibly do a little better job in

00:24:32,880 --> 00:24:38,480
making these things uh dependent

00:24:34,799 --> 00:24:41,120
on environment variables or

00:24:38,480 --> 00:24:42,960
another uh tool we have and giving me to

00:24:41,120 --> 00:24:46,159
test this augs info thing

00:24:42,960 --> 00:24:47,360
ugg's info isn't quite as nice as the

00:24:46,159 --> 00:24:49,279
environment variables though because you

00:24:47,360 --> 00:24:53,120
do need to recompile when you use that

00:24:49,279 --> 00:24:54,799
it's a compile-time setup

00:24:53,120 --> 00:24:56,159
well you can use the structure even

00:24:54,799 --> 00:24:59,279
after you've compiled but

00:24:56,159 --> 00:25:00,000
then you need to write to it which would

00:24:59,279 --> 00:25:03,360
be yet another

00:25:00,000 --> 00:25:03,360
path so it doesn't help

00:25:05,679 --> 00:25:11,279
so um talk about most of these or some

00:25:08,960 --> 00:25:14,799
of these problems already

00:25:11,279 --> 00:25:16,960
where we need to now

00:25:14,799 --> 00:25:19,200
get our reset the devices or get our

00:25:16,960 --> 00:25:21,520
information from different places

00:25:19,200 --> 00:25:22,799
for x86 this may require parsing acpi

00:25:21,520 --> 00:25:25,679
i'm not sure yet

00:25:22,799 --> 00:25:26,960
i forgot to mention one problem though

00:25:25,679 --> 00:25:31,039
um

00:25:26,960 --> 00:25:34,159
that i still have i say r64 um

00:25:31,039 --> 00:25:34,159
and that is that

00:25:34,720 --> 00:25:39,120
in order to use the

00:25:39,520 --> 00:25:44,799
fe memory map that we get from ubfi

00:25:43,039 --> 00:25:47,279
we need to be able to use it at the

00:25:44,799 --> 00:25:50,159
granularity that it's given to us and

00:25:47,279 --> 00:25:50,960
currently the implementation for ar64

00:25:50,159 --> 00:25:54,400
unit tests

00:25:50,960 --> 00:25:54,720
only uses 64k pages so this memory map

00:25:54,400 --> 00:25:58,320
which

00:25:54,720 --> 00:26:00,159
doesn't have 64k alignments

00:25:58,320 --> 00:26:01,919
is no good for us at the moment and uh

00:26:00,159 --> 00:26:04,000
so i need to

00:26:01,919 --> 00:26:05,600
i need to rework some of the memory

00:26:04,000 --> 00:26:09,600
management framework for

00:26:05,600 --> 00:26:13,520
the page table setup framework for ar64

00:26:09,600 --> 00:26:13,520
in order to allow 4k pages as well

00:26:16,960 --> 00:26:23,279
so to wrap up

00:26:21,279 --> 00:26:26,080
give you immune tests is already testing

00:26:23,279 --> 00:26:26,080
more than kvm

00:26:26,720 --> 00:26:34,000
and if we add an fe app build target

00:26:30,559 --> 00:26:37,200
to knit test we can further expand the

00:26:34,000 --> 00:26:38,720
test targets we can run on

00:26:37,200 --> 00:26:42,240
since that'll allow us to have a

00:26:38,720 --> 00:26:42,240
portable unit test

00:26:45,120 --> 00:26:48,240
one of the other benefits of being able

00:26:47,360 --> 00:26:51,279
to

00:26:48,240 --> 00:26:53,120
run a unit test directly from firmware

00:26:51,279 --> 00:26:54,799
is that we will be able to write the

00:26:53,120 --> 00:26:57,279
test even

00:26:54,799 --> 00:26:59,600
for kvn not just for bare metal but kvm

00:26:57,279 --> 00:27:02,240
kv muni tests

00:26:59,600 --> 00:27:03,120
faster because we won't need to boot all

00:27:02,240 --> 00:27:06,559
of linux

00:27:03,120 --> 00:27:08,400
and run kvm user space on top of an

00:27:06,559 --> 00:27:12,159
uh an emulator if we don't have the

00:27:08,400 --> 00:27:14,000
hardware available to do otherwise

00:27:12,159 --> 00:27:15,360
so the proof of concept for air 64 is

00:27:14,000 --> 00:27:17,360
pretty far along

00:27:15,360 --> 00:27:18,480
but unfortunately not all the tests are

00:27:17,360 --> 00:27:22,080
running

00:27:18,480 --> 00:27:25,200
on bare metal yet so work in progress

00:27:22,080 --> 00:27:26,559
uh also work in progress although not

00:27:25,200 --> 00:27:31,200
really

00:27:26,559 --> 00:27:35,440
started much yet uh is the x86

00:27:31,200 --> 00:27:36,960
work to be able to do it as well

00:27:35,440 --> 00:27:39,200
i expect uh some different challenges

00:27:36,960 --> 00:27:41,520
there and i actually hope

00:27:39,200 --> 00:27:42,720
that all the work uh done by vmware in

00:27:41,520 --> 00:27:44,880
order to

00:27:42,720 --> 00:27:46,559
remove assumptions about kimimu being

00:27:44,880 --> 00:27:47,360
the targets in order to run on bare

00:27:46,559 --> 00:27:50,480
metal

00:27:47,360 --> 00:27:53,760
and vmware already will allow

00:27:50,480 --> 00:27:56,799
the test to run more easily than

00:27:53,760 --> 00:28:00,080
on bare metal than what i'm having for

00:27:56,799 --> 00:28:00,080
my experience was there 64.

00:28:01,120 --> 00:28:05,170
thank you um if i understand quite

00:28:03,840 --> 00:28:06,399
correctly there's uh

00:28:05,170 --> 00:28:08,000
[Music]

00:28:06,399 --> 00:28:09,760
going to be some question and answer

00:28:08,000 --> 00:28:12,880
time reserved after

00:28:09,760 --> 00:28:16,240
the uh after this presentation is

00:28:12,880 --> 00:28:27,840
made available so uh please

00:28:16,240 --> 00:28:27,840

YouTube URL: https://www.youtube.com/watch?v=kvaufVrL0J0


