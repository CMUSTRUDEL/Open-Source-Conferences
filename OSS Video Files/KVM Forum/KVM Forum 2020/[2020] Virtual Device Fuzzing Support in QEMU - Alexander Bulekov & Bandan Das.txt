Title: [2020] Virtual Device Fuzzing Support in QEMU - Alexander Bulekov & Bandan Das
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	For some time, the community has been interested in fuzzing QEMU to identify potential security vulnerabilities. Last year, Dima Stepanov presented an approach for fuzzing VIRTIO devices using AFL at KVM Forum 2019, and there is an existing image-fuzzer tool in the tree. Since then our virtual-device fuzzing work has landed upstream and has identified dozens of bugs. In this talk, we will introduce our solution, based on QEMU’s existing qtest and qos frameworks. We will cover topics such as: - Why fuzz virtual devices? - How to build a fuzzer for a virtual-device. - Fuzzing a virtual device vs writing a test for it. - How to fuzz new devices/QEMU configurations without writing any code. - Plan for reporting and triaging crashes found by the fuzzer. - Options for fuzzing “external” devices (e.g vhost). - Fuzzing other attack surfaces in QEMU. - How to get involved

---

Bandan Das
Red Hat, Software Engineer
Boston

Bandan works on Virtualization at Red Hat. He is primarily interested in systems security and performance. Bandan has presented on various topics such as KVM, usb-mtp emulation in Qemu and the IIO interface in the Linux kernel.

Alexander Bulekov
Captions: 
	00:00:04,240 --> 00:00:08,880
hello everyone

00:00:05,200 --> 00:00:11,519
um my name is bhandan das i am a

00:00:08,880 --> 00:00:12,480
virtualization engineer at red hat um

00:00:11,519 --> 00:00:14,400
and

00:00:12,480 --> 00:00:16,880
uh today we we are gonna be talking

00:00:14,400 --> 00:00:19,920
about uh the state of fuzzing

00:00:16,880 --> 00:00:22,960
in uh in kyumu

00:00:19,920 --> 00:00:25,359
with me i have um alex

00:00:22,960 --> 00:00:26,720
who works at red hat research and is

00:00:25,359 --> 00:00:30,080
also a phd student

00:00:26,720 --> 00:00:32,079
at boston university um and alex

00:00:30,080 --> 00:00:33,920
works on fuzzing alex would you want to

00:00:32,079 --> 00:00:37,360
give a quick introduction

00:00:33,920 --> 00:00:41,040
sure uh so i i started working on

00:00:37,360 --> 00:00:42,559
um on qmu in uh in 2019 during the

00:00:41,040 --> 00:00:45,120
google summer of code

00:00:42,559 --> 00:00:46,000
uh specifically i was i was working on

00:00:45,120 --> 00:00:47,600
uh

00:00:46,000 --> 00:00:49,280
building out a framework for fuzzing

00:00:47,600 --> 00:00:51,280
virtual devices and i've

00:00:49,280 --> 00:00:53,120
stuck around since then and i think it's

00:00:51,280 --> 00:00:55,360
a very exciting topic and i hope you

00:00:53,120 --> 00:00:58,640
enjoy our talk

00:00:55,360 --> 00:00:59,120
all right thanks alex so let's move on

00:00:58,640 --> 00:01:02,320
so

00:00:59,120 --> 00:01:04,320
um so before we talk about fuzzing

00:01:02,320 --> 00:01:05,920
uh so the first slide just talks a

00:01:04,320 --> 00:01:09,360
little bit about qmu

00:01:05,920 --> 00:01:11,760
and how we decided on

00:01:09,360 --> 00:01:12,720
what would be a good interface to fuzz

00:01:11,760 --> 00:01:14,240
uh not that

00:01:12,720 --> 00:01:16,159
uh qmu does not have a lot of

00:01:14,240 --> 00:01:19,200
interesting uh you know interfaces

00:01:16,159 --> 00:01:21,280
qmi is a vast uh you know emulator

00:01:19,200 --> 00:01:22,479
it's it's there uh there are millions of

00:01:21,280 --> 00:01:26,000
interfaces to which

00:01:22,479 --> 00:01:27,920
guests interact um but uh this in this

00:01:26,000 --> 00:01:29,600
slide just talks a little bit about

00:01:27,920 --> 00:01:32,000
what are the more interesting interfaces

00:01:29,600 --> 00:01:32,960
that um wherefore where fuzzing can uh

00:01:32,000 --> 00:01:37,119
you know

00:01:32,960 --> 00:01:39,280
benefit qmu so um as you all know qmu is

00:01:37,119 --> 00:01:42,880
an emulator uh it can work with

00:01:39,280 --> 00:01:46,479
kvm it can work with dcg

00:01:42,880 --> 00:01:49,600
and a big chunk of qmu

00:01:46,479 --> 00:01:51,840
is basically implementing virtual

00:01:49,600 --> 00:01:54,320
devices which enable

00:01:51,840 --> 00:01:55,280
guest environments to do i o of some

00:01:54,320 --> 00:01:58,399
sort

00:01:55,280 --> 00:02:01,119
um so these devices could be actual

00:01:58,399 --> 00:02:02,560
uh implementations of you know like

00:02:01,119 --> 00:02:04,240
emulations of real hardware

00:02:02,560 --> 00:02:06,960
or they can also be para virtualized

00:02:04,240 --> 00:02:08,640
like uh like virtio devices

00:02:06,960 --> 00:02:10,319
so if you look at the figure on the

00:02:08,640 --> 00:02:12,560
right um we

00:02:10,319 --> 00:02:13,760
see we show a very very uh you know

00:02:12,560 --> 00:02:15,599
simplified version of

00:02:13,760 --> 00:02:17,760
you know the hypervisor that's uh you

00:02:15,599 --> 00:02:19,840
know are sitting on top of hardware

00:02:17,760 --> 00:02:20,959
and there's this virtual virtual devices

00:02:19,840 --> 00:02:23,680
layer

00:02:20,959 --> 00:02:26,239
and then we have guest choices basically

00:02:23,680 --> 00:02:28,319
running on top of the hypervisor

00:02:26,239 --> 00:02:29,520
with their own apps running in this

00:02:28,319 --> 00:02:33,280
sandbox that

00:02:29,520 --> 00:02:35,920
the hypervisor has provided now

00:02:33,280 --> 00:02:37,360
due to a attack surface that's probably

00:02:35,920 --> 00:02:38,160
lurking in somewhere in the virtual

00:02:37,360 --> 00:02:41,760
device layer

00:02:38,160 --> 00:02:44,319
uh a malicious app um

00:02:41,760 --> 00:02:45,040
can uh if it knows about this um you

00:02:44,319 --> 00:02:48,080
know

00:02:45,040 --> 00:02:49,840
this this attack surface the

00:02:48,080 --> 00:02:51,840
malicious app can try to take advantage

00:02:49,840 --> 00:02:53,680
of it now the app itself

00:02:51,840 --> 00:02:55,280
is malicious but the guest os might not

00:02:53,680 --> 00:02:58,080
be necessarily so

00:02:55,280 --> 00:02:58,959
so the guest might be an unwilling you

00:02:58,080 --> 00:03:01,040
know participant

00:02:58,959 --> 00:03:02,239
in exposing some interfaces that the app

00:03:01,040 --> 00:03:04,720
can use

00:03:02,239 --> 00:03:05,920
to escape out of the sandbox that qmu

00:03:04,720 --> 00:03:09,200
has provided

00:03:05,920 --> 00:03:11,599
now so this just basically shows how uh

00:03:09,200 --> 00:03:13,440
you know the virtual device layer that

00:03:11,599 --> 00:03:14,400
that's being exposed by keemu is very

00:03:13,440 --> 00:03:16,239
very critical

00:03:14,400 --> 00:03:19,040
it needs to be hardened on a continuous

00:03:16,239 --> 00:03:21,680
basis and we always need to

00:03:19,040 --> 00:03:22,400
kind of be one step ahead of you know

00:03:21,680 --> 00:03:25,040
any

00:03:22,400 --> 00:03:26,959
uh any vulnerabilities that might ex get

00:03:25,040 --> 00:03:30,080
exposed out in the wild

00:03:26,959 --> 00:03:31,519
so um with that let's move on to a

00:03:30,080 --> 00:03:34,239
little bit of discussion

00:03:31,519 --> 00:03:35,760
about uh you know the basic code

00:03:34,239 --> 00:03:39,360
analysis techniques

00:03:35,760 --> 00:03:39,920
right uh so basically there are two

00:03:39,360 --> 00:03:43,200
kinds of

00:03:39,920 --> 00:03:44,560
uh you know code inspection techniques

00:03:43,200 --> 00:03:47,360
that you can think of

00:03:44,560 --> 00:03:48,239
uh the first one is a static analysis

00:03:47,360 --> 00:03:51,599
where

00:03:48,239 --> 00:03:53,760
you basically use this

00:03:51,599 --> 00:03:54,879
program special special program called a

00:03:53,760 --> 00:03:58,000
static analyzer

00:03:54,879 --> 00:03:59,760
to uh you know feed in your test program

00:03:58,000 --> 00:04:01,360
and then the static analyzer based on a

00:03:59,760 --> 00:04:03,519
set of rules uh

00:04:01,360 --> 00:04:05,519
basically checks for inconsistencies in

00:04:03,519 --> 00:04:08,080
syntax or semantics

00:04:05,519 --> 00:04:09,680
uh and the advantage of a static

00:04:08,080 --> 00:04:11,599
analyzer is basically that

00:04:09,680 --> 00:04:14,000
you don't have to make major changes or

00:04:11,599 --> 00:04:16,320
probably no changes at all to your

00:04:14,000 --> 00:04:18,000
test program uh because you are

00:04:16,320 --> 00:04:19,199
essentially running your test program

00:04:18,000 --> 00:04:22,320
offline

00:04:19,199 --> 00:04:25,680
and there's also this uh well-known um

00:04:22,320 --> 00:04:26,400
you know uh fact that uh you get a lot

00:04:25,680 --> 00:04:28,880
of

00:04:26,400 --> 00:04:29,840
you know false positive with static

00:04:28,880 --> 00:04:31,919
analyzers and

00:04:29,840 --> 00:04:33,440
the way to get around that is basically

00:04:31,919 --> 00:04:35,440
by teaching your static analyzer

00:04:33,440 --> 00:04:36,320
especially specialized rules how to kind

00:04:35,440 --> 00:04:38,960
of you know

00:04:36,320 --> 00:04:39,840
um detect uh certain things like for

00:04:38,960 --> 00:04:41,520
example

00:04:39,840 --> 00:04:43,040
your code might be written in such a way

00:04:41,520 --> 00:04:46,320
that even if

00:04:43,040 --> 00:04:48,880
the the variable seems uninitialized uh

00:04:46,320 --> 00:04:49,919
in in in the it's it's basically

00:04:48,880 --> 00:04:52,000
impossible for the

00:04:49,919 --> 00:04:53,040
code logic to actually use it on

00:04:52,000 --> 00:04:54,320
uninitialized and

00:04:53,040 --> 00:04:56,720
those are the kind of things where you

00:04:54,320 --> 00:04:58,560
know you might get some kind of fault

00:04:56,720 --> 00:04:59,680
positive false positives from static

00:04:58,560 --> 00:05:03,120
analyzers

00:04:59,680 --> 00:05:04,800
now the other uh technique which is

00:05:03,120 --> 00:05:06,479
which is basically where fuzzing falls

00:05:04,800 --> 00:05:09,520
is dynamic analysis

00:05:06,479 --> 00:05:10,400
and that is where you know you actually

00:05:09,520 --> 00:05:13,840
change your

00:05:10,400 --> 00:05:16,560
um you know test program and integrate

00:05:13,840 --> 00:05:18,560
you know specialized uh you know input

00:05:16,560 --> 00:05:19,759
paths which basically allow your test

00:05:18,560 --> 00:05:22,320
program to

00:05:19,759 --> 00:05:22,800
um you know go through a series of very

00:05:22,320 --> 00:05:24,960
very

00:05:22,800 --> 00:05:26,639
various inputs and so that what this

00:05:24,960 --> 00:05:28,080
does is it allows coverage of

00:05:26,639 --> 00:05:30,479
all the test paths that your test

00:05:28,080 --> 00:05:31,199
program can take and as you as you can

00:05:30,479 --> 00:05:33,120
already see

00:05:31,199 --> 00:05:34,880
this definitely is a more intrusive

00:05:33,120 --> 00:05:37,919
approach than uh than static

00:05:34,880 --> 00:05:40,000
analysis um and uh

00:05:37,919 --> 00:05:41,520
there might be false positives also with

00:05:40,000 --> 00:05:43,759
dynamic analysis but

00:05:41,520 --> 00:05:45,440
suffice it to say that when you when

00:05:43,759 --> 00:05:47,759
you're doing dynamic analysis

00:05:45,440 --> 00:05:48,639
there's definitely uh you know a problem

00:05:47,759 --> 00:05:50,880
somewhere it's up

00:05:48,639 --> 00:05:53,440
it's it's just a question of whether

00:05:50,880 --> 00:05:56,560
that that code path is actually

00:05:53,440 --> 00:05:57,039
you know um exploitable is the real

00:05:56,560 --> 00:05:59,600
question

00:05:57,039 --> 00:06:01,360
otherwise uh sometimes fuzzing will

00:05:59,600 --> 00:06:02,160
actually most of the times will actually

00:06:01,360 --> 00:06:05,280
detect

00:06:02,160 --> 00:06:08,800
uh a flaw in a specific code path um

00:06:05,280 --> 00:06:11,919
so static analysis and dynamic analysis

00:06:08,800 --> 00:06:14,800
are kind of complementary they they are

00:06:11,919 --> 00:06:16,479
recommended uh for you know as a good

00:06:14,800 --> 00:06:18,720
security practice it's recommended that

00:06:16,479 --> 00:06:19,600
you run both static analysis and dynamic

00:06:18,720 --> 00:06:22,479
analysis

00:06:19,600 --> 00:06:24,240
sometimes uh people even recommend uh as

00:06:22,479 --> 00:06:26,720
a good security practice to

00:06:24,240 --> 00:06:28,000
you know teach your static analysis uh

00:06:26,720 --> 00:06:29,280
the findings that you

00:06:28,000 --> 00:06:31,520
you know get out of your dynamic

00:06:29,280 --> 00:06:33,919
analysis tools like fuzzing so

00:06:31,520 --> 00:06:35,199
uh you know so that you get the best of

00:06:33,919 --> 00:06:37,919
both worlds

00:06:35,199 --> 00:06:38,720
um so with that let's uh talk a little

00:06:37,919 --> 00:06:41,840
bit about

00:06:38,720 --> 00:06:45,039
the history of fuzzing in cumula um

00:06:41,840 --> 00:06:45,680
so qmill is not new to fuzzing there has

00:06:45,039 --> 00:06:48,479
been

00:06:45,680 --> 00:06:51,039
some work in this area in different

00:06:48,479 --> 00:06:53,280
subsections of uh the qmu code base

00:06:51,039 --> 00:06:54,960
um some of the examples uh that are

00:06:53,280 --> 00:06:55,440
mentioned on this slide include things

00:06:54,960 --> 00:06:58,560
like

00:06:55,440 --> 00:07:02,080
the cucu fuzzer this was integrated in

00:06:58,560 --> 00:07:04,240
2014 then around 2015

00:07:02,080 --> 00:07:06,400
uh there were some patches to the

00:07:04,240 --> 00:07:09,520
megasas virtual device layer

00:07:06,400 --> 00:07:10,080
uh there was not a lot of uh information

00:07:09,520 --> 00:07:12,880
as to

00:07:10,080 --> 00:07:15,440
how this uh this worked but it's

00:07:12,880 --> 00:07:18,639
probably a modified version of

00:07:15,440 --> 00:07:19,599
keemu with you know with afl integrated

00:07:18,639 --> 00:07:22,560
that was able to

00:07:19,599 --> 00:07:23,440
detect some bugs in the in the pci bar

00:07:22,560 --> 00:07:26,560
space

00:07:23,440 --> 00:07:30,000
uh for mega sas uh more recently

00:07:26,560 --> 00:07:33,440
um we had work in 2019

00:07:30,000 --> 00:07:34,880
uh basically dima presented about uh

00:07:33,440 --> 00:07:38,479
what what io device

00:07:34,880 --> 00:07:41,680
fuzzing using afl at kvm forum

00:07:38,479 --> 00:07:44,960
which where he talks about how he

00:07:41,680 --> 00:07:47,440
used a setup of afl a a proxy

00:07:44,960 --> 00:07:48,879
and then uh and the qmu test program

00:07:47,440 --> 00:07:51,039
using q test to

00:07:48,879 --> 00:07:52,080
uh you know first virtual device

00:07:51,039 --> 00:07:54,240
interfaces

00:07:52,080 --> 00:07:56,080
and around the same time uh we also had

00:07:54,240 --> 00:07:56,720
google summer of code that was going

00:07:56,080 --> 00:07:58,400
along

00:07:56,720 --> 00:08:00,000
in parallel i guess in a different

00:07:58,400 --> 00:08:02,479
approach where alex

00:08:00,000 --> 00:08:03,039
um who is also presenting with me um you

00:08:02,479 --> 00:08:06,479
know

00:08:03,039 --> 00:08:09,520
uh was uh was kind of researching and

00:08:06,479 --> 00:08:10,080
you know trying to approach this problem

00:08:09,520 --> 00:08:12,720
using

00:08:10,080 --> 00:08:14,560
uh lyft fuzzer which is more kind of the

00:08:12,720 --> 00:08:17,039
llvm back-end and we have some

00:08:14,560 --> 00:08:18,240
we have some slides later on in our talk

00:08:17,039 --> 00:08:21,680
where we talk about uh

00:08:18,240 --> 00:08:24,400
those approaches so um

00:08:21,680 --> 00:08:27,520
so based on our uh you know past uh you

00:08:24,400 --> 00:08:30,000
know um

00:08:27,520 --> 00:08:32,240
you know exposure to fuzzing uh we kind

00:08:30,000 --> 00:08:34,719
of identified some missing pieces

00:08:32,240 --> 00:08:35,279
um one of the most important missing

00:08:34,719 --> 00:08:38,800
pieces

00:08:35,279 --> 00:08:39,599
is uh basically you know you don't want

00:08:38,800 --> 00:08:41,760
your fuzzing

00:08:39,599 --> 00:08:43,440
environment to be just limited to the

00:08:41,760 --> 00:08:45,600
developers uh you know personal

00:08:43,440 --> 00:08:46,560
workspace the main benefit of fuzzing

00:08:45,600 --> 00:08:48,640
comes

00:08:46,560 --> 00:08:50,959
out of uh you know making it more

00:08:48,640 --> 00:08:53,200
available making it more generic so that

00:08:50,959 --> 00:08:54,080
all developers can you know utilize

00:08:53,200 --> 00:08:57,360
fuzzing

00:08:54,080 --> 00:08:59,920
uh without major hiccups and also

00:08:57,360 --> 00:09:01,600
um you could run fuzzing on a continuous

00:08:59,920 --> 00:09:03,440
basis more like ci

00:09:01,600 --> 00:09:05,279
because qmu is a very very active

00:09:03,440 --> 00:09:05,920
community with you know lots of patches

00:09:05,279 --> 00:09:09,279
coming in

00:09:05,920 --> 00:09:11,200
every day uh so so you know

00:09:09,279 --> 00:09:12,800
integration brings up the topic of

00:09:11,200 --> 00:09:14,640
continuous integration uh kmu

00:09:12,800 --> 00:09:17,600
integration brings up the topic of

00:09:14,640 --> 00:09:18,399
continuous integration uh and so that's

00:09:17,600 --> 00:09:20,640
how

00:09:18,399 --> 00:09:21,920
you know you are gonna actually catch

00:09:20,640 --> 00:09:24,240
bugs as they come

00:09:21,920 --> 00:09:26,080
in new patches for example and also the

00:09:24,240 --> 00:09:27,920
other important aspect again closely

00:09:26,080 --> 00:09:30,160
tied to continuous integration is where

00:09:27,920 --> 00:09:32,160
exactly are we gonna run these uh

00:09:30,160 --> 00:09:34,160
continuous integration tests

00:09:32,160 --> 00:09:36,080
so and that's that's that's kind of you

00:09:34,160 --> 00:09:37,760
know some of the uh you know problems

00:09:36,080 --> 00:09:40,640
that kind of influenced uh

00:09:37,760 --> 00:09:41,279
where this uh kmu fuzzing work uh took

00:09:40,640 --> 00:09:44,560
us

00:09:41,279 --> 00:09:46,720
um but uh before we go to uh

00:09:44,560 --> 00:09:48,000
you know the solutions uh let's also

00:09:46,720 --> 00:09:50,800
talk about the challenges

00:09:48,000 --> 00:09:51,680
um which probably have been mentioned at

00:09:50,800 --> 00:09:54,560
some point

00:09:51,680 --> 00:09:55,760
in in other you know discussions as well

00:09:54,560 --> 00:09:58,080
um

00:09:55,760 --> 00:09:59,920
uh but uh you know the more the more

00:09:58,080 --> 00:10:00,480
kind of obvious and uh more kind of

00:09:59,920 --> 00:10:02,880
interesting

00:10:00,480 --> 00:10:04,959
uh and important challenges with fuzzing

00:10:02,880 --> 00:10:07,360
junior qmu is not a regular

00:10:04,959 --> 00:10:09,200
general purpose just a simple piece of

00:10:07,360 --> 00:10:11,839
um you know software that just

00:10:09,200 --> 00:10:13,680
does something specific it's basically

00:10:11,839 --> 00:10:16,720
changing states all the time

00:10:13,680 --> 00:10:19,120
uh based on guest behavior and

00:10:16,720 --> 00:10:20,160
it implements a large amount of virtual

00:10:19,120 --> 00:10:22,160
devices

00:10:20,160 --> 00:10:24,320
and all of these virtual devices have

00:10:22,160 --> 00:10:25,680
their own you know quirks and they have

00:10:24,320 --> 00:10:27,279
their own implementations and

00:10:25,680 --> 00:10:28,800
you know this just adds to the

00:10:27,279 --> 00:10:31,200
complexity of the

00:10:28,800 --> 00:10:32,240
kind of input that you will probably

00:10:31,200 --> 00:10:35,440
provide

00:10:32,240 --> 00:10:36,959
uh to to qmu uh so the so the fuzzer has

00:10:35,440 --> 00:10:39,519
to take care of this

00:10:36,959 --> 00:10:41,360
uh the framework uh so although there's

00:10:39,519 --> 00:10:43,040
not a lot of uh you know options and

00:10:41,360 --> 00:10:46,000
when it comes to pre-built fuzzers

00:10:43,040 --> 00:10:47,920
um uh we also need to decide on what

00:10:46,000 --> 00:10:50,079
would be a good fuzzing framework for

00:10:47,920 --> 00:10:51,440
kmu should we have a custom framework or

00:10:50,079 --> 00:10:52,800
should we just pick up something that's

00:10:51,440 --> 00:10:54,880
already out there

00:10:52,800 --> 00:10:56,560
um you know the advantage of picking up

00:10:54,880 --> 00:10:59,279
something out there is basically you

00:10:56,560 --> 00:11:00,880
you you know save a lot of time but the

00:10:59,279 --> 00:11:03,040
disadvantage is of course

00:11:00,880 --> 00:11:05,680
uh now you have this challenge of kind

00:11:03,040 --> 00:11:06,079
of molding this pre-built fuzzer to work

00:11:05,680 --> 00:11:09,600
with

00:11:06,079 --> 00:11:11,920
gmu uh and equally important is also the

00:11:09,600 --> 00:11:13,839
concept of state changes uh so as i said

00:11:11,920 --> 00:11:14,560
uh in the first bullet point uh you know

00:11:13,839 --> 00:11:16,640
qmu

00:11:14,560 --> 00:11:18,720
is constantly changing state and the

00:11:16,640 --> 00:11:21,360
fuzzer basically does not know

00:11:18,720 --> 00:11:22,800
about uh you know states and to have a

00:11:21,360 --> 00:11:26,000
reliable fuzzing run

00:11:22,800 --> 00:11:27,600
you probably have to feed in inputs at

00:11:26,000 --> 00:11:29,680
some consistent state of

00:11:27,600 --> 00:11:31,279
uh of the virtual device or the subset

00:11:29,680 --> 00:11:32,320
of you know the virtual machine that you

00:11:31,279 --> 00:11:35,040
are dealing with

00:11:32,320 --> 00:11:36,000
so these are these are some you know big

00:11:35,040 --> 00:11:38,560
problems with

00:11:36,000 --> 00:11:39,760
fuzzing you know qmu but you know any

00:11:38,560 --> 00:11:41,839
any complicated

00:11:39,760 --> 00:11:43,200
um you know test program and so we are

00:11:41,839 --> 00:11:46,079
going to quickly cover

00:11:43,200 --> 00:11:46,480
uh a little bit more um in detail um

00:11:46,079 --> 00:11:48,959
these

00:11:46,480 --> 00:11:51,440
these specific points so with respect to

00:11:48,959 --> 00:11:53,360
fuzzing frameworks we have afl

00:11:51,440 --> 00:11:54,560
we have lift fuzzer that we discussed a

00:11:53,360 --> 00:11:56,639
little bit um

00:11:54,560 --> 00:11:58,880
you know in some of the previous slides

00:11:56,639 --> 00:11:59,839
um so the advantage of lift buzzer is

00:11:58,880 --> 00:12:02,160
basically that it's

00:11:59,839 --> 00:12:03,760
uh it's integrated into llvm and

00:12:02,160 --> 00:12:07,360
google's oss fuzz

00:12:03,760 --> 00:12:09,360
runs nicely um you know with live fuzzer

00:12:07,360 --> 00:12:10,000
um and oss fuzz as you might already

00:12:09,360 --> 00:12:11,200
know is

00:12:10,000 --> 00:12:13,360
basically you know google's

00:12:11,200 --> 00:12:16,000
infrastructure where you can submit your

00:12:13,360 --> 00:12:17,760
uh you know programs your your project

00:12:16,000 --> 00:12:18,880
and they are going to run continuous

00:12:17,760 --> 00:12:21,839
integration on

00:12:18,880 --> 00:12:23,040
fuzzing runs on your on your uh program

00:12:21,839 --> 00:12:26,720
um

00:12:23,040 --> 00:12:27,920
so um the the disadvantages i mentioned

00:12:26,720 --> 00:12:29,360
before in the previous slide is

00:12:27,920 --> 00:12:32,160
pre-built fuzzers are

00:12:29,360 --> 00:12:34,000
um kind of you know they need some type

00:12:32,160 --> 00:12:35,920
of molding so that you can

00:12:34,000 --> 00:12:37,040
use them with your with your uh test

00:12:35,920 --> 00:12:39,040
program

00:12:37,040 --> 00:12:41,200
uh the other option is obviously you

00:12:39,040 --> 00:12:43,920
know why not just use a custom fuzzer

00:12:41,200 --> 00:12:44,480
the you know you you will start from

00:12:43,920 --> 00:12:46,480
scratch

00:12:44,480 --> 00:12:47,519
you will um you know have better

00:12:46,480 --> 00:12:49,600
integration

00:12:47,519 --> 00:12:50,639
but obviously it has downsides as well

00:12:49,600 --> 00:12:52,880
um so

00:12:50,639 --> 00:12:54,160
so this is a this is this is the this is

00:12:52,880 --> 00:12:55,680
the problem with the fuzzing framework

00:12:54,160 --> 00:12:56,320
what kind of fuzzing framework should we

00:12:55,680 --> 00:13:00,160
use

00:12:56,320 --> 00:13:02,959
the next challenge is um uh you know

00:13:00,160 --> 00:13:05,120
uh the interface that we decided to fuzz

00:13:02,959 --> 00:13:07,040
uh so

00:13:05,120 --> 00:13:09,040
we decided to first the virtual devices

00:13:07,040 --> 00:13:10,639
which we identified in the one of the

00:13:09,040 --> 00:13:11,920
previous slides that it is an important

00:13:10,639 --> 00:13:14,160
area to first

00:13:11,920 --> 00:13:14,959
uh and for all practical purposes

00:13:14,160 --> 00:13:18,160
because we are

00:13:14,959 --> 00:13:18,800
using running general purpose os's uh as

00:13:18,160 --> 00:13:21,920
guests

00:13:18,800 --> 00:13:23,920
uh you know virtual devices are

00:13:21,920 --> 00:13:25,839
most or more or less identical to real

00:13:23,920 --> 00:13:28,880
devices real hardware out there

00:13:25,839 --> 00:13:31,040
and all devices as you already know um

00:13:28,880 --> 00:13:34,399
you know have different mechanisms uh

00:13:31,040 --> 00:13:37,200
to uh you know to help or

00:13:34,399 --> 00:13:38,399
to talk to them so the most the most

00:13:37,200 --> 00:13:40,320
common uh you know

00:13:38,399 --> 00:13:42,560
legacy devices almost all the devices

00:13:40,320 --> 00:13:46,480
will implement some form of port io

00:13:42,560 --> 00:13:49,120
um but at the same time uh you also have

00:13:46,480 --> 00:13:49,760
uh you know memory mapped io where you

00:13:49,120 --> 00:13:52,160
can

00:13:49,760 --> 00:13:53,199
map specific regions of the hardware to

00:13:52,160 --> 00:13:56,399
you know regular

00:13:53,199 --> 00:13:58,240
memory and uh you know that also and you

00:13:56,399 --> 00:13:58,959
can write to these memory locations and

00:13:58,240 --> 00:14:00,399
they are gonna

00:13:58,959 --> 00:14:02,639
you know enable some form of

00:14:00,399 --> 00:14:06,639
functionality in the hardware

00:14:02,639 --> 00:14:08,000
um so the the way port i o and m i o is

00:14:06,639 --> 00:14:09,839
configured is definitely

00:14:08,000 --> 00:14:11,760
it's not it's not set in stone you know

00:14:09,839 --> 00:14:12,560
it depends from it varies from hardware

00:14:11,760 --> 00:14:14,720
to hardware

00:14:12,560 --> 00:14:16,320
uh it might also depend on you know you

00:14:14,720 --> 00:14:17,920
know the device driver developers so

00:14:16,320 --> 00:14:20,880
there's a lot of uh you know

00:14:17,920 --> 00:14:21,519
uh non-standardization as to how you can

00:14:20,880 --> 00:14:24,240
enable

00:14:21,519 --> 00:14:24,800
the port io space and the mmi air space

00:14:24,240 --> 00:14:26,320
and that's

00:14:24,800 --> 00:14:28,240
uh you know and that's something you

00:14:26,320 --> 00:14:31,600
have to know to efficiently fuzz

00:14:28,240 --> 00:14:34,240
right so uh on top of that

00:14:31,600 --> 00:14:35,199
almost all devices today also have dma

00:14:34,240 --> 00:14:38,800
um

00:14:35,199 --> 00:14:42,320
which basically lets the cpu kind of

00:14:38,800 --> 00:14:44,959
you know uh save some cycles or maybe

00:14:42,320 --> 00:14:46,800
use use some cpu cycles for something

00:14:44,959 --> 00:14:47,920
more useful or maybe even get into a low

00:14:46,800 --> 00:14:50,720
power state

00:14:47,920 --> 00:14:52,959
while some data transfer is going on now

00:14:50,720 --> 00:14:54,560
as you might already know dma transfers

00:14:52,959 --> 00:14:56,480
you know deals with descriptors these

00:14:54,560 --> 00:14:56,880
descriptors can be nested they can be

00:14:56,480 --> 00:14:59,920
you know

00:14:56,880 --> 00:15:01,440
complicated chains of uh you know memory

00:14:59,920 --> 00:15:02,160
locations that are fed to the dma

00:15:01,440 --> 00:15:04,639
controller

00:15:02,160 --> 00:15:06,399
so that also adds to the complexity of

00:15:04,639 --> 00:15:08,240
the input space that we're dealing with

00:15:06,399 --> 00:15:08,959
here so now if you combine everything

00:15:08,240 --> 00:15:11,760
together

00:15:08,959 --> 00:15:13,199
as you can imagine for just even us even

00:15:11,760 --> 00:15:15,760
a single virtual device

00:15:13,199 --> 00:15:17,199
uh we are talking about a space that is

00:15:15,760 --> 00:15:19,600
you know really really

00:15:17,199 --> 00:15:21,440
you know huge uh and that makes it very

00:15:19,600 --> 00:15:24,880
very complicated

00:15:21,440 --> 00:15:27,839
so the next um uh

00:15:24,880 --> 00:15:29,360
problem is the concept of a state so as

00:15:27,839 --> 00:15:31,759
we discussed before

00:15:29,360 --> 00:15:33,199
uh you know qmu is changing state all

00:15:31,759 --> 00:15:35,519
the time based on the

00:15:33,199 --> 00:15:36,320
events that are happening uh or what

00:15:35,519 --> 00:15:39,040
kind of uh

00:15:36,320 --> 00:15:41,120
you know uh behavior the guest is you

00:15:39,040 --> 00:15:44,399
know

00:15:41,120 --> 00:15:46,639
displaying and so the problem is

00:15:44,399 --> 00:15:47,600
uh fuzzing does not work that way right

00:15:46,639 --> 00:15:50,240
i mean you always

00:15:47,600 --> 00:15:51,759
have to uh get to a specific state

00:15:50,240 --> 00:15:54,639
before you put in an input

00:15:51,759 --> 00:15:55,600
and then see what coverage it gives you

00:15:54,639 --> 00:15:57,920
if your state

00:15:55,600 --> 00:15:58,720
changes your fuzzing runs won't be

00:15:57,920 --> 00:16:00,639
reliable

00:15:58,720 --> 00:16:02,880
and that basically means that sometimes

00:16:00,639 --> 00:16:05,199
your fuzzing run wouldn't make any sense

00:16:02,880 --> 00:16:06,560
or maybe even your bugs that you find

00:16:05,199 --> 00:16:08,560
with your fuzzy neurons won't

00:16:06,560 --> 00:16:10,079
be you know repeatable so the

00:16:08,560 --> 00:16:11,199
maintaining state is a very very

00:16:10,079 --> 00:16:13,519
important topic

00:16:11,199 --> 00:16:15,120
so how do we maintain state now you know

00:16:13,519 --> 00:16:17,680
qmu always already gives you

00:16:15,120 --> 00:16:19,519
you know some existing um you know

00:16:17,680 --> 00:16:22,639
mechanisms like for example you could

00:16:19,519 --> 00:16:25,680
probably reboot the instance of

00:16:22,639 --> 00:16:27,360
your guest machine that you um that you

00:16:25,680 --> 00:16:29,199
were using for your fuzzing runs

00:16:27,360 --> 00:16:31,040
uh qmu also provides you the concept of

00:16:29,199 --> 00:16:31,839
snapshots that is helpful in migration

00:16:31,040 --> 00:16:34,800
you probably could

00:16:31,839 --> 00:16:35,360
reuse those here and you know have your

00:16:34,800 --> 00:16:37,759
fuzzing

00:16:35,360 --> 00:16:39,920
infrastructure integrated with vm state

00:16:37,759 --> 00:16:40,800
uh functionalities to save and restore

00:16:39,920 --> 00:16:42,720
snapshots

00:16:40,800 --> 00:16:44,880
and you can also probably go one step

00:16:42,720 --> 00:16:46,480
ahead and try forking where basically

00:16:44,880 --> 00:16:49,360
you fork off these fuzzing

00:16:46,480 --> 00:16:51,199
threads and they uh you know uh dates

00:16:49,360 --> 00:16:52,959
this very common point and then they

00:16:51,199 --> 00:16:54,320
you know merge back fuzzing results back

00:16:52,959 --> 00:16:55,759
to the parent thread

00:16:54,320 --> 00:16:57,440
so uh so these are some of the

00:16:55,759 --> 00:17:00,160
challenges that uh you know

00:16:57,440 --> 00:17:01,040
we identified uh with respect to fuzzing

00:17:00,160 --> 00:17:04,720
uh you know

00:17:01,040 --> 00:17:06,319
and and qmu so with this i think i would

00:17:04,720 --> 00:17:08,079
like to hand it over to alex who's going

00:17:06,319 --> 00:17:09,199
to talk a little bit about how we went

00:17:08,079 --> 00:17:10,720
ahead and started

00:17:09,199 --> 00:17:12,559
kind of looking at these problems in

00:17:10,720 --> 00:17:13,439
detail and what we did about these

00:17:12,559 --> 00:17:15,199
problems

00:17:13,439 --> 00:17:16,799
in terms of solutions so alex do you

00:17:15,199 --> 00:17:21,120
want to take over yes

00:17:16,799 --> 00:17:23,520
yes thank you it's useful to

00:17:21,120 --> 00:17:24,319
look at the ways we've been testing qmu

00:17:23,520 --> 00:17:27,039
uh

00:17:24,319 --> 00:17:28,000
um up to fuzzing because fuzzing is

00:17:27,039 --> 00:17:30,720
essentially

00:17:28,000 --> 00:17:32,640
doing the same thing as these normal uh

00:17:30,720 --> 00:17:35,919
virtual device tests but it

00:17:32,640 --> 00:17:39,360
adds a randomization component to that

00:17:35,919 --> 00:17:40,559
um and in qmu we have some uh some great

00:17:39,360 --> 00:17:44,480
apis for

00:17:40,559 --> 00:17:47,679
for unit testing um

00:17:44,480 --> 00:17:51,200
virtual devices um starting off with a q

00:17:47,679 --> 00:17:54,799
test for example where q test

00:17:51,200 --> 00:17:56,880
provides uh provides some instructions

00:17:54,799 --> 00:18:00,480
for performing input and output

00:17:56,880 --> 00:18:03,919
with devices such as memory rights or

00:18:00,480 --> 00:18:06,960
port io rights um and it also lets you

00:18:03,919 --> 00:18:11,200
control um qmu's clock

00:18:06,960 --> 00:18:12,799
um and uh and this is a this is a great

00:18:11,200 --> 00:18:14,480
facility and there's lots of tests

00:18:12,799 --> 00:18:17,760
written

00:18:14,480 --> 00:18:19,600
using the libq test but for some more

00:18:17,760 --> 00:18:22,559
complicated devices

00:18:19,600 --> 00:18:24,320
you quickly run into a problem because

00:18:22,559 --> 00:18:27,520
complex devices require complex

00:18:24,320 --> 00:18:32,080
initialization complex protocols

00:18:27,520 --> 00:18:36,240
so there's a library built out on top of

00:18:32,080 --> 00:18:39,919
q test called libqos which lets you

00:18:36,240 --> 00:18:40,799
leverage some some common apis in sort

00:18:39,919 --> 00:18:43,760
of a

00:18:40,799 --> 00:18:45,919
it's almost like a a driver a testing

00:18:43,760 --> 00:18:46,400
specific driver for a bunch of devices

00:18:45,919 --> 00:18:49,520
which

00:18:46,400 --> 00:18:52,320
which lets you bypass things like

00:18:49,520 --> 00:18:53,280
implementing uh pci enumeration and

00:18:52,320 --> 00:18:56,320
mapping

00:18:53,280 --> 00:18:58,160
pci base address registers um

00:18:56,320 --> 00:19:00,000
for every single device because all of

00:18:58,160 --> 00:19:02,080
this is abstracted away into this nice

00:19:00,000 --> 00:19:05,440
api

00:19:02,080 --> 00:19:08,640
um and through libqos you can

00:19:05,440 --> 00:19:11,039
uh you have access to these higher level

00:19:08,640 --> 00:19:15,120
apis for bus access

00:19:11,039 --> 00:19:16,720
allocating uh space in in ram for

00:19:15,120 --> 00:19:18,930
for data that will be transferred over

00:19:16,720 --> 00:19:20,320
dma in things like

00:19:18,930 --> 00:19:24,559
[Music]

00:19:20,320 --> 00:19:25,679
pci controlling the pci configuration

00:19:24,559 --> 00:19:29,200
space

00:19:25,679 --> 00:19:30,559
um so we have these really nice apis and

00:19:29,200 --> 00:19:34,960
it makes sense to leverage them

00:19:30,559 --> 00:19:34,960
for fuzzing as well so moving on

00:19:35,039 --> 00:19:38,720
the the way we built out the fuzzing

00:19:37,039 --> 00:19:41,840
framework within qmu

00:19:38,720 --> 00:19:43,280
is is that we want to um make it as

00:19:41,840 --> 00:19:44,320
simple as possible for somebody who's

00:19:43,280 --> 00:19:47,520
familiar with

00:19:44,320 --> 00:19:50,799
building out q tests and qos tests

00:19:47,520 --> 00:19:55,280
to to build fuzzing tests as well

00:19:50,799 --> 00:19:57,440
so the the basic api is very similar to

00:19:55,280 --> 00:19:59,280
to something like a q test where you

00:19:57,440 --> 00:20:01,760
provide a name for your test

00:19:59,280 --> 00:20:02,480
you provide some method for getting the

00:20:01,760 --> 00:20:05,120
arguments

00:20:02,480 --> 00:20:07,760
that you need to pass to qmu to set up

00:20:05,120 --> 00:20:08,480
the uh the device that you want to fuzz

00:20:07,760 --> 00:20:10,400
and then

00:20:08,480 --> 00:20:12,320
also you need to specify a function that

00:20:10,400 --> 00:20:14,320
will perform the actual fuzzing

00:20:12,320 --> 00:20:15,919
and if you look at these actual uh

00:20:14,320 --> 00:20:19,440
fuzzing functions

00:20:15,919 --> 00:20:22,400
um they look very similar to

00:20:19,440 --> 00:20:24,400
to something that you would use to to

00:20:22,400 --> 00:20:25,840
test the device uh the only difference

00:20:24,400 --> 00:20:28,799
is that you have

00:20:25,840 --> 00:20:31,280
your function accepts a a randomized

00:20:28,799 --> 00:20:34,880
data buffer and the size of that bumper

00:20:31,280 --> 00:20:36,720
and um basically the fuzzing target's

00:20:34,880 --> 00:20:38,320
job or the fuzzing function's job is to

00:20:36,720 --> 00:20:41,440
take that randomized buffer

00:20:38,320 --> 00:20:44,480
and convert it into these i o actions

00:20:41,440 --> 00:20:45,760
um well with the device so in this case

00:20:44,480 --> 00:20:48,640
we're fuzzing

00:20:45,760 --> 00:20:50,240
a pci controller with with two registers

00:20:48,640 --> 00:20:52,880
basically the

00:20:50,240 --> 00:20:54,000
cfg and the data registers so you might

00:20:52,880 --> 00:20:56,799
take the first byte

00:20:54,000 --> 00:20:57,520
of the of your input and interpret that

00:20:56,799 --> 00:20:59,120
as

00:20:57,520 --> 00:21:00,960
uh do i want to read or do i want to

00:20:59,120 --> 00:21:02,880
write from the register and then

00:21:00,960 --> 00:21:04,720
the second byte might be okay which

00:21:02,880 --> 00:21:06,799
register do i want to write from

00:21:04,720 --> 00:21:07,919
two uh out of these two registers and

00:21:06,799 --> 00:21:10,880
then the third

00:21:07,919 --> 00:21:11,280
right uh the the the last set of bytes

00:21:10,880 --> 00:21:13,600
might

00:21:11,280 --> 00:21:15,280
indicate you know what data do i want to

00:21:13,600 --> 00:21:17,360
write to the register if i'm

00:21:15,280 --> 00:21:19,440
doing it right um so it's quite similar

00:21:17,360 --> 00:21:21,520
to you know a standard test that you

00:21:19,440 --> 00:21:23,919
would write you just have to

00:21:21,520 --> 00:21:26,720
guide the test according to some

00:21:23,919 --> 00:21:26,720
randomized data

00:21:26,880 --> 00:21:30,000
this one is actually it's is basically

00:21:28,880 --> 00:21:32,720
doing exactly the same

00:21:30,000 --> 00:21:33,120
thing it's more of a demonstration test

00:21:32,720 --> 00:21:35,760
um

00:21:33,120 --> 00:21:36,320
but it's leveraging the qos framework uh

00:21:35,760 --> 00:21:38,480
to

00:21:36,320 --> 00:21:39,840
to do that so you can see here that

00:21:38,480 --> 00:21:43,520
instead of these

00:21:39,840 --> 00:21:46,159
simple q test out or q test in

00:21:43,520 --> 00:21:47,120
instructions or or function calls that

00:21:46,159 --> 00:21:49,600
we had on the prior

00:21:47,120 --> 00:21:50,240
um in the prior example you can actually

00:21:49,600 --> 00:21:54,000
leverage

00:21:50,240 --> 00:21:54,480
libqos's bus apis to to uh to configure

00:21:54,000 --> 00:21:56,640
bytes

00:21:54,480 --> 00:21:57,679
this really comes in handy when you're

00:21:56,640 --> 00:21:59,440
testing

00:21:57,679 --> 00:22:01,120
more sophisticated devices such as

00:21:59,440 --> 00:22:04,960
network controllers

00:22:01,120 --> 00:22:07,200
or um or uh disk controllers

00:22:04,960 --> 00:22:08,880
you can go even further so one thing

00:22:07,200 --> 00:22:10,880
that we've spent a lot of time doing is

00:22:08,880 --> 00:22:14,080
actually building out a

00:22:10,880 --> 00:22:16,640
a generic fuzzer program

00:22:14,080 --> 00:22:18,240
that leverages q tests but instead of

00:22:16,640 --> 00:22:20,640
requiring the developer to

00:22:18,240 --> 00:22:22,159
build out a function for every single

00:22:20,640 --> 00:22:23,919
device that they wish to buzz

00:22:22,159 --> 00:22:25,280
they can just specify a couple

00:22:23,919 --> 00:22:27,520
environment variables

00:22:25,280 --> 00:22:29,120
um the first one being you know the set

00:22:27,520 --> 00:22:32,080
of arguments that you want to

00:22:29,120 --> 00:22:33,760
pass to qmu to set up a virtual device

00:22:32,080 --> 00:22:37,360
and then the second one being

00:22:33,760 --> 00:22:38,559
um a a set of or a set of strings that

00:22:37,360 --> 00:22:40,960
basically

00:22:38,559 --> 00:22:43,360
indicate the rules that you use to match

00:22:40,960 --> 00:22:46,640
the names of memory regions or

00:22:43,360 --> 00:22:49,600
objects um that you want to fuzz

00:22:46,640 --> 00:22:50,320
um and uh we've we spent quite a bit of

00:22:49,600 --> 00:22:53,039
time

00:22:50,320 --> 00:22:53,679
uh building out that buzzer and um i'm

00:22:53,039 --> 00:22:55,120
not going to

00:22:53,679 --> 00:22:56,960
going to go into too much detail about

00:22:55,120 --> 00:22:58,960
how that works under the hood

00:22:56,960 --> 00:23:00,400
um but it can actually generate some

00:22:58,960 --> 00:23:03,600
pretty interesting and

00:23:00,400 --> 00:23:04,480
complicated uh inputs so for example the

00:23:03,600 --> 00:23:07,919
one on

00:23:04,480 --> 00:23:08,720
the left is a real uh crash that it

00:23:07,919 --> 00:23:10,640
found for

00:23:08,720 --> 00:23:12,559
for a network device where you can see

00:23:10,640 --> 00:23:13,280
how in the beginning it's performing all

00:23:12,559 --> 00:23:16,320
these out

00:23:13,280 --> 00:23:17,919
um port io instructions it's basically

00:23:16,320 --> 00:23:21,120
automatically doing

00:23:17,919 --> 00:23:23,280
the um uh the

00:23:21,120 --> 00:23:25,360
uh pci setup and mapping the base

00:23:23,280 --> 00:23:27,200
address registers for this device

00:23:25,360 --> 00:23:29,440
and then interacting with the memory

00:23:27,200 --> 00:23:32,080
mapped io registers in orange

00:23:29,440 --> 00:23:32,480
and then finally in the purple um this

00:23:32,080 --> 00:23:34,960
is

00:23:32,480 --> 00:23:36,240
actually it right into a dma buffer that

00:23:34,960 --> 00:23:38,960
will be read by

00:23:36,240 --> 00:23:41,120
um by the network device and then in

00:23:38,960 --> 00:23:43,840
this case the bug was actually that the

00:23:41,120 --> 00:23:44,400
the address in red is also a dma address

00:23:43,840 --> 00:23:47,120
but

00:23:44,400 --> 00:23:48,240
instead of being located in some free

00:23:47,120 --> 00:23:51,919
location in ram

00:23:48,240 --> 00:23:55,120
it happens to be um overlapping the

00:23:51,919 --> 00:23:56,960
uh memory mapped io uh space of the

00:23:55,120 --> 00:23:59,120
device which you can see if you

00:23:56,960 --> 00:24:00,400
just flip the indium-ness of those bytes

00:23:59,120 --> 00:24:03,200
uh in your head

00:24:00,400 --> 00:24:04,320
um we built out some scripts that

00:24:03,200 --> 00:24:07,200
convert

00:24:04,320 --> 00:24:08,880
um these uh the resulting crashes into

00:24:07,200 --> 00:24:11,360
normal q test test

00:24:08,880 --> 00:24:13,440
cases and and we also minimize those

00:24:11,360 --> 00:24:16,480
crashes to remove bites that

00:24:13,440 --> 00:24:18,559
are not needed to produce the crash

00:24:16,480 --> 00:24:20,000
and the crash reproducers are usually

00:24:18,559 --> 00:24:22,880
small enough that they can be

00:24:20,000 --> 00:24:24,240
included inside an email in a report to

00:24:22,880 --> 00:24:27,760
to the mailing list or

00:24:24,240 --> 00:24:30,240
or even inside a commit message

00:24:27,760 --> 00:24:30,880
um which you can you can see here on

00:24:30,240 --> 00:24:34,320
this

00:24:30,880 --> 00:24:36,640
uh small movie where basically as

00:24:34,320 --> 00:24:38,320
a developer who's receiving a bug report

00:24:36,640 --> 00:24:41,679
all you have to do is copy

00:24:38,320 --> 00:24:44,000
and paste a command from an email to to

00:24:41,679 --> 00:24:44,799
get our reproducer trace but that you

00:24:44,000 --> 00:24:47,279
can

00:24:44,799 --> 00:24:49,840
then look at it gdb or attach some

00:24:47,279 --> 00:24:52,640
tracing events to it

00:24:49,840 --> 00:24:53,440
um and our project has already been

00:24:52,640 --> 00:24:56,880
accepted to

00:24:53,440 --> 00:25:00,159
oss fuzz this means that qmu will be

00:24:56,880 --> 00:25:02,799
fuzzed basically all the time and uh

00:25:00,159 --> 00:25:04,159
any any new code that gets upstreamed uh

00:25:02,799 --> 00:25:05,919
will be fuzzed and hopefully we can

00:25:04,159 --> 00:25:09,360
catch any new issues that show up

00:25:05,919 --> 00:25:12,960
before before the next release

00:25:09,360 --> 00:25:14,640
um and using the fuzzing approach that

00:25:12,960 --> 00:25:16,320
uh that we've developed in the fuzzing

00:25:14,640 --> 00:25:19,120
frameworks that we've developed we've

00:25:16,320 --> 00:25:20,640
not only have we been able to find brand

00:25:19,120 --> 00:25:23,520
new bugs but we've also

00:25:20,640 --> 00:25:25,440
built out reproducers for bugs that have

00:25:23,520 --> 00:25:27,440
been reported a long time ago but

00:25:25,440 --> 00:25:28,480
um there was no reliable reproducer for

00:25:27,440 --> 00:25:30,799
them

00:25:28,480 --> 00:25:32,159
and because of the reproducer that we

00:25:30,799 --> 00:25:34,400
found now it's a lot easier for the

00:25:32,159 --> 00:25:37,520
developer to work on fixing those bugs

00:25:34,400 --> 00:25:41,360
and we've also found some bugs that

00:25:37,520 --> 00:25:43,200
that uncovered some deep problems in

00:25:41,360 --> 00:25:46,080
in some of the architectural decisions

00:25:43,200 --> 00:25:49,440
uh in qmu such as

00:25:46,080 --> 00:25:50,400
the way devices access access data over

00:25:49,440 --> 00:25:53,520
dma

00:25:50,400 --> 00:25:55,200
and also the memory access api itself

00:25:53,520 --> 00:25:58,000
with with some problems with the

00:25:55,200 --> 00:26:01,039
alignment and memory access sizes

00:25:58,000 --> 00:26:03,840
um so far we've reported uh over

00:26:01,039 --> 00:26:05,200
50 bugs on on launch pad and six bugs

00:26:03,840 --> 00:26:09,039
have been

00:26:05,200 --> 00:26:12,400
assigned cbe ids and we're still

00:26:09,039 --> 00:26:14,000
very much trying to work out how to

00:26:12,400 --> 00:26:16,320
deal with reporting these bugs in the

00:26:14,000 --> 00:26:18,799
future and working out a process because

00:26:16,320 --> 00:26:19,600
um fuzzing unknown says fuzz is still

00:26:18,799 --> 00:26:23,039
quite a

00:26:19,600 --> 00:26:24,720
new uh concept for qmu so we're

00:26:23,039 --> 00:26:26,320
actively looking for input on the best

00:26:24,720 --> 00:26:28,799
ways to to

00:26:26,320 --> 00:26:31,520
get reports to a developer that can fix

00:26:28,799 --> 00:26:33,600
them as smoothly as possible

00:26:31,520 --> 00:26:36,000
um and in the future there's there's so

00:26:33,600 --> 00:26:36,320
much stuff that i'd love to talk about

00:26:36,000 --> 00:26:38,559
and

00:26:36,320 --> 00:26:40,000
i think there's a lot of places where uh

00:26:38,559 --> 00:26:43,279
this work can go

00:26:40,000 --> 00:26:44,960
um and just to mention a few uh

00:26:43,279 --> 00:26:46,640
devices are often hooked up to

00:26:44,960 --> 00:26:49,840
complicated back ends such as

00:26:46,640 --> 00:26:53,039
uh spice vnc uh slurp um

00:26:49,840 --> 00:26:55,120
we want to be able to fuzz those as well

00:26:53,039 --> 00:26:56,159
we also want to be able to fuzz

00:26:55,120 --> 00:26:59,600
migration code

00:26:56,159 --> 00:27:03,919
so save vm load vm and

00:26:59,600 --> 00:27:06,799
vm state descriptors and reboots

00:27:03,919 --> 00:27:07,200
we also still don't have a great way to

00:27:06,799 --> 00:27:10,240
uh

00:27:07,200 --> 00:27:10,880
to fuzz uh to to reproduce crashes that

00:27:10,240 --> 00:27:12,559
require

00:27:10,880 --> 00:27:14,480
you know thousands and thousands and

00:27:12,559 --> 00:27:17,760
thousands of interactions because

00:27:14,480 --> 00:27:20,480
um lib fuzzer sets a cap of uh

00:27:17,760 --> 00:27:21,919
4k or 60k for each input that it tries

00:27:20,480 --> 00:27:24,880
to use to fuzz

00:27:21,919 --> 00:27:25,840
um and then we can also talk about um

00:27:24,880 --> 00:27:29,600
you know fuzzing

00:27:25,840 --> 00:27:31,279
fuzzing devices that rely on kernel

00:27:29,600 --> 00:27:33,039
components in the kernel such as the

00:27:31,279 --> 00:27:34,640
vhost and you know

00:27:33,039 --> 00:27:36,399
some devices are moving out of the

00:27:34,640 --> 00:27:37,679
process with with stuff uh like

00:27:36,399 --> 00:27:41,360
multi-process kimu

00:27:37,679 --> 00:27:44,640
and um v-host user um

00:27:41,360 --> 00:27:46,399
and uh in and i i think overall there's

00:27:44,640 --> 00:27:48,399
there's still a lot of work to be done

00:27:46,399 --> 00:27:49,679
if anybody is interested in any of these

00:27:48,399 --> 00:27:53,919
topics uh

00:27:49,679 --> 00:27:56,880
i'd love to uh talk to you about it um

00:27:53,919 --> 00:27:58,000
so alex um how would you suggest

00:27:56,880 --> 00:28:00,640
somebody who's

00:27:58,000 --> 00:28:02,080
uh you know not very very familiar with

00:28:00,640 --> 00:28:04,320
you know the fuzzing infrastructure

00:28:02,080 --> 00:28:05,520
in qmu how would you suggest they get

00:28:04,320 --> 00:28:08,559
you know started

00:28:05,520 --> 00:28:11,039
to you know possibly kind of even you

00:28:08,559 --> 00:28:14,320
know contribute to these topics

00:28:11,039 --> 00:28:17,600
all right uh awesome question uh bandan

00:28:14,320 --> 00:28:18,399
um i uh so here are our contact details

00:28:17,600 --> 00:28:21,279
first of all

00:28:18,399 --> 00:28:22,000
we're always happy to talk about um uh

00:28:21,279 --> 00:28:23,840
these bugs

00:28:22,000 --> 00:28:25,520
if you want to take a look on your own

00:28:23,840 --> 00:28:27,679
uh we have documentation

00:28:25,520 --> 00:28:28,559
uh for the fuzzer uh it should be pretty

00:28:27,679 --> 00:28:30,399
easy to find

00:28:28,559 --> 00:28:31,919
but really all you need to get started

00:28:30,399 --> 00:28:32,960
with building the fuzzer and writing a

00:28:31,919 --> 00:28:36,799
new fuzzer's

00:28:32,960 --> 00:28:39,279
reasonably recent version of um clang

00:28:36,799 --> 00:28:40,240
um we have some very simple examples as

00:28:39,279 --> 00:28:43,279
as i showed

00:28:40,240 --> 00:28:46,000
earlier on in the presentation um

00:28:43,279 --> 00:28:46,559
and yeah as i said we're really happy to

00:28:46,000 --> 00:28:48,320
talk to

00:28:46,559 --> 00:28:51,600
anybody who's interested in this i want

00:28:48,320 --> 00:28:54,240
to give a huge thanks to everybody who

00:28:51,600 --> 00:28:55,840
uh who helps with reviewing the code and

00:28:54,240 --> 00:29:00,159
working on the bugs

00:28:55,840 --> 00:29:02,720
um that we reported and with that uh

00:29:00,159 --> 00:29:10,080
i guess if anybody has any questions

00:29:02,720 --> 00:29:10,080

YouTube URL: https://www.youtube.com/watch?v=2PRGlLoUpLs


