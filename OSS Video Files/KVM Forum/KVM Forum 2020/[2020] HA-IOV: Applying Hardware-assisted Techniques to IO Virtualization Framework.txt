Title: [2020] HA-IOV: Applying Hardware-assisted Techniques to IO Virtualization Framework
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	In I/O virtualization, notification mechanism, such as ioeventfd, achieves a significant fraction of request latency as long as I/O physical devices become faster. Polling techniques can reduce latency but prevents other threads from running and waste CPU if events are rare. This talk introduces HA-IOV, an efficient and flexible hardware-assisted I/O Virtualization framework, to obtain high CPU utilization as well as satisfying performance. First, VMs can deliver I/O requests to asynchronous I/O processing threads without trapping out by hardware support to reduce delivery latency. I/O processing threads are further wakened up by hardware-assisted scheduler with no kernel scheduler overheads. Polling mode can thus be eliminated in HA-IOV to improve CPU utilization. Second, HA-IOV allows VMs to trap out to user-level threads bypassing KVM, leading to a reduction of synchronous I/O path.

---

Yifei Jiang
Huawei, Chief Engineer

Yifei Jiang is a chief engineer at Huawei, and has 9 years working experience on Virtualization. Currently working on next generation virtualization technology research.

Bo Wan
Huawei, Senior engineer

Bo Wan, Doctor of University of Science and Technology of China, is a senior engineer in Huawei. He is working on the ongoing next generation virtualization project.
Captions: 
	00:00:04,240 --> 00:00:08,639
hello

00:00:04,880 --> 00:00:11,759
everyone i'm jennifer from huawei

00:00:08,639 --> 00:00:15,519
here i'd like to present our work

00:00:11,759 --> 00:00:18,560
on applying hardware assisted technicals

00:00:15,519 --> 00:00:23,199
to bio virtualization from the work

00:00:18,560 --> 00:00:23,199
we name this work how shall we

00:00:24,880 --> 00:00:31,840
we first explain the background

00:00:28,560 --> 00:00:34,960
and the motivation of our work

00:00:31,840 --> 00:00:38,160
then the actual way architecture

00:00:34,960 --> 00:00:41,280
is introduced what tears

00:00:38,160 --> 00:00:45,039
about irv are described

00:00:41,280 --> 00:00:48,239
in the following three parts finally

00:00:45,039 --> 00:00:51,280
we conclude our work and introduce

00:00:48,239 --> 00:00:51,280
our future work

00:00:52,320 --> 00:00:56,000
the even increasing demand for high

00:00:55,120 --> 00:00:58,879
performance

00:00:56,000 --> 00:00:59,920
computing in data centers highest

00:00:58,879 --> 00:01:03,199
results

00:00:59,920 --> 00:01:06,400
in the dramatic development of

00:01:03,199 --> 00:01:09,920
various virtualization environments

00:01:06,400 --> 00:01:13,119
our virtualization is one of the most

00:01:09,920 --> 00:01:16,479
crucial components which

00:01:13,119 --> 00:01:20,080
targets not only to optimize

00:01:16,479 --> 00:01:25,200
the utilization of physical resource

00:01:20,080 --> 00:01:25,200
but also to enhance the io performance

00:01:25,680 --> 00:01:30,240
to eliminate the io virtualization

00:01:28,880 --> 00:01:33,040
overhangs

00:01:30,240 --> 00:01:34,079
hardware assisted technicals are

00:01:33,040 --> 00:01:37,759
proposed

00:01:34,079 --> 00:01:41,600
to directly pass through excise

00:01:37,759 --> 00:01:44,880
physical io devices but then complicate

00:01:41,600 --> 00:01:48,159
the lab migration

00:01:44,880 --> 00:01:52,240
software techniques such as four

00:01:48,159 --> 00:01:53,840
emulated io devices and para virtual io

00:01:52,240 --> 00:01:57,280
devices

00:01:53,840 --> 00:01:58,240
from performance lows due to costly

00:01:57,280 --> 00:02:02,240
content switch

00:01:58,240 --> 00:02:05,439
between guests and the host our work

00:02:02,240 --> 00:02:09,679
focus on the four emulated io devices

00:02:05,439 --> 00:02:13,440
and power virtual devices

00:02:09,679 --> 00:02:17,680
why guests soften performance loads

00:02:13,440 --> 00:02:20,840
we are accessing emulated io devices

00:02:17,680 --> 00:02:22,000
implemented in the user live camera

00:02:20,840 --> 00:02:25,440
slides

00:02:22,000 --> 00:02:28,879
let's see the whole procedure firstly

00:02:25,440 --> 00:02:33,280
to access for emulated io devices

00:02:28,879 --> 00:02:33,280
guests should trip out to qm

00:02:33,440 --> 00:02:37,440
and the qm will further transform our

00:02:36,640 --> 00:02:40,480
request

00:02:37,440 --> 00:02:43,840
to the user library by handling

00:02:40,480 --> 00:02:47,680
exceptions thus context

00:02:43,840 --> 00:02:50,959
should switch from corner to the

00:02:47,680 --> 00:02:54,160
user space then

00:02:50,959 --> 00:02:58,480
cumulus writes process i request

00:02:54,160 --> 00:03:04,000
and retain processing and results

00:02:58,480 --> 00:03:07,280
context will switch back to qm

00:03:04,000 --> 00:03:11,760
cam further returns back to

00:03:07,280 --> 00:03:15,040
guest through switching contacts

00:03:11,760 --> 00:03:18,159
finally the gaster resumes

00:03:15,040 --> 00:03:20,959
as we can see from the whole procedure

00:03:18,159 --> 00:03:22,000
costly context switch between host and

00:03:20,959 --> 00:03:25,440
guest

00:03:22,000 --> 00:03:28,319
exit and are unavailable

00:03:25,440 --> 00:03:30,720
in current software and the hardware

00:03:28,319 --> 00:03:33,760
architecture

00:03:30,720 --> 00:03:37,040
as for para virtual io devices

00:03:33,760 --> 00:03:40,640
which are implemented using l thread

00:03:37,040 --> 00:03:44,159
bases on water front work there are also

00:03:40,640 --> 00:03:44,159
costly contact switch

00:03:44,560 --> 00:03:52,000
the is site the gaster traps out

00:03:48,239 --> 00:03:55,200
to qm and the qm

00:03:52,000 --> 00:03:56,239
send i will even have d to blocking ios

00:03:55,200 --> 00:03:59,360
rights

00:03:56,239 --> 00:04:02,560
this is done by sending ipi to

00:03:59,360 --> 00:04:07,040
target cpu course instead of

00:04:02,560 --> 00:04:10,400
handling exception in the same cpu cores

00:04:07,040 --> 00:04:13,760
intact cpu core corner schedule wakes

00:04:10,400 --> 00:04:16,560
up the ios thread to process

00:04:13,760 --> 00:04:16,560
i o request

00:04:17,440 --> 00:04:24,400
after the processing

00:04:20,720 --> 00:04:27,440
israelite sends interrupt bike to

00:04:24,400 --> 00:04:30,479
guest to notify the completion

00:04:27,440 --> 00:04:33,600
of io requests

00:04:30,479 --> 00:04:38,160
gather trip out again to

00:04:33,600 --> 00:04:38,160
get watch interrupt injected

00:04:40,160 --> 00:04:46,960
of course this can be optimized by

00:04:43,680 --> 00:04:49,600
x-list interrupter mechanism but

00:04:46,960 --> 00:04:50,560
when guests say the io request the

00:04:49,600 --> 00:04:54,840
overhangs

00:04:50,560 --> 00:04:57,440
caused by gaster trapping cannot be

00:04:54,840 --> 00:05:01,840
avoided let's see the

00:04:57,440 --> 00:05:04,960
we host so we host

00:05:01,840 --> 00:05:05,919
proposed to elevate io processing

00:05:04,960 --> 00:05:09,280
overhangs

00:05:05,919 --> 00:05:12,560
by adapting chronos right

00:05:09,280 --> 00:05:17,520
but all hands caused by counter switch

00:05:12,560 --> 00:05:17,520
between guests and the host steer exit

00:05:18,000 --> 00:05:22,639
different different from we host we host

00:05:21,440 --> 00:05:25,840
the user

00:05:22,639 --> 00:05:26,479
elevate i o overhands will share the

00:05:25,840 --> 00:05:30,320
memory

00:05:26,479 --> 00:05:34,000
between guests and the host

00:05:30,320 --> 00:05:37,440
however it prevents other threats

00:05:34,000 --> 00:05:40,880
from running on the polling cpu core

00:05:37,440 --> 00:05:44,960
when watch aisle workloads

00:05:40,880 --> 00:05:48,880
become real the cpu the cpu utilization

00:05:44,960 --> 00:05:51,840
becomes lower to elevate

00:05:48,880 --> 00:05:53,120
iops overhangs in io virtualization

00:05:51,840 --> 00:05:56,880
frontal work

00:05:53,120 --> 00:06:00,080
as well as improving cpu utilization

00:05:56,880 --> 00:06:03,840
lowered by polymod we introduced

00:06:00,080 --> 00:06:07,680
the hlv node sites

00:06:03,840 --> 00:06:11,919
our technicals also targeted to avoid

00:06:07,680 --> 00:06:11,919
complicating the level migration

00:06:12,240 --> 00:06:18,639
as mentioned before when guests

00:06:15,360 --> 00:06:21,680
excise four emulated io devices

00:06:18,639 --> 00:06:25,840
costly contact switch between guests and

00:06:21,680 --> 00:06:29,199
host reduced performance

00:06:25,840 --> 00:06:31,680
thus we propose the actually a way to

00:06:29,199 --> 00:06:33,120
eliminate those content switch over

00:06:31,680 --> 00:06:36,160
hands

00:06:33,120 --> 00:06:39,280
we do this by directly

00:06:36,160 --> 00:06:43,759
delegating exception from guest

00:06:39,280 --> 00:06:46,560
to host user space by passing qm

00:06:43,759 --> 00:06:49,840
more details will be described in the

00:06:46,560 --> 00:06:49,840
following slides

00:06:49,919 --> 00:06:56,800
as for para virtual io devices in corner

00:06:53,759 --> 00:07:00,840
and the user space water and

00:06:56,800 --> 00:07:03,919
we host require the guests to trap out

00:07:00,840 --> 00:07:06,960
to send api or send

00:07:03,919 --> 00:07:10,560
human time i will even have d to

00:07:06,960 --> 00:07:11,639
notify what i backend and we host the

00:07:10,560 --> 00:07:15,120
backend

00:07:11,639 --> 00:07:18,800
responsively particularly

00:07:15,120 --> 00:07:21,919
ill threads running in user space

00:07:18,800 --> 00:07:24,960
should be scheduled by corner

00:07:21,919 --> 00:07:27,520
this is further called overhangs before

00:07:24,960 --> 00:07:31,680
purchasing a request

00:07:27,520 --> 00:07:34,720
to serve the costly i'll pass over hands

00:07:31,680 --> 00:07:38,880
pulling mod in with host user

00:07:34,720 --> 00:07:43,680
is used it allows the guests

00:07:38,880 --> 00:07:46,720
to interact with user level io servers

00:07:43,680 --> 00:07:47,440
directly will share the memory between

00:07:46,720 --> 00:07:50,800
gaster

00:07:47,440 --> 00:07:54,240
and the host however pulling

00:07:50,800 --> 00:07:54,879
threats prevent other threats running on

00:07:54,240 --> 00:07:58,080
the

00:07:54,879 --> 00:08:01,520
polling cpu cores which lowers

00:07:58,080 --> 00:08:05,280
the cpu utilization

00:08:01,520 --> 00:08:09,199
here we will propose the ijr way

00:08:05,280 --> 00:08:12,720
for one thing virtual inventor interrupt

00:08:09,199 --> 00:08:16,479
mechanism is introduced to allow

00:08:12,720 --> 00:08:20,000
guests to send interrupts without

00:08:16,479 --> 00:08:22,960
tripping out to qm for another

00:08:20,000 --> 00:08:23,360
user level interrupt handler which is

00:08:22,960 --> 00:08:26,479
for

00:08:23,360 --> 00:08:27,280
handling virtual inventory interrupt can

00:08:26,479 --> 00:08:30,319
be worked

00:08:27,280 --> 00:08:33,599
up quickly by hardware assisted

00:08:30,319 --> 00:08:37,760
contact switch mechanism

00:08:33,599 --> 00:08:40,800
from above battery airway can eliminate

00:08:37,760 --> 00:08:44,240
costly content switch between host and

00:08:40,800 --> 00:08:47,920
guest the user level threads can

00:08:44,240 --> 00:08:47,920
be worked up quickly

00:08:48,000 --> 00:08:54,560
furthermore through the combination of

00:08:51,360 --> 00:08:57,680
vi and hcs the

00:08:54,560 --> 00:09:01,120
wasted polling cpu cores become

00:08:57,680 --> 00:09:05,920
free to run other threats

00:09:01,120 --> 00:09:09,120
it can improve the cpu utilization

00:09:05,920 --> 00:09:12,480
to validate our ideas we

00:09:09,120 --> 00:09:16,560
implement a prototype on the risk

00:09:12,480 --> 00:09:20,160
file systems in risk file architectures

00:09:16,560 --> 00:09:23,600
privilege mode is defined as shown

00:09:20,160 --> 00:09:26,720
in the fragra figure

00:09:23,600 --> 00:09:29,120
there are four pro privilege labs and

00:09:26,720 --> 00:09:32,320
the two virtualization modes

00:09:29,120 --> 00:09:35,600
gaster runs in virtualization mode

00:09:32,320 --> 00:09:37,360
and holster runs in non-virtualization

00:09:35,600 --> 00:09:40,480
mode

00:09:37,360 --> 00:09:44,000
an extension is proposed in

00:09:40,480 --> 00:09:46,959
risk fiber privilege architecture

00:09:44,000 --> 00:09:48,720
for adding user live interrupt and

00:09:46,959 --> 00:09:51,839
exception handle

00:09:48,720 --> 00:09:56,880
interrupts and exceptions

00:09:51,839 --> 00:09:56,880
can thus be delegated to user library

00:09:57,360 --> 00:10:04,480
hardware can transfer control

00:10:00,800 --> 00:10:08,079
deliver delete directly

00:10:04,480 --> 00:10:13,360
to use a live trap handle without

00:10:08,079 --> 00:10:17,040
invoking the auto execution environments

00:10:13,360 --> 00:10:20,480
to support harvey will further extend

00:10:17,040 --> 00:10:24,320
the extension with the ability

00:10:20,480 --> 00:10:28,079
to redirect exception occurs in vs model

00:10:24,320 --> 00:10:32,160
or view mode to your mod and

00:10:28,079 --> 00:10:35,839
the ability to alone vs model real mode

00:10:32,160 --> 00:10:38,480
to be interrupted by the user level

00:10:35,839 --> 00:10:38,480
interrupts

00:10:39,120 --> 00:10:45,600
both emulated and

00:10:42,160 --> 00:10:49,040
virtual io devices can benefit from

00:10:45,600 --> 00:10:52,079
actually a way next we'll show

00:10:49,040 --> 00:10:55,440
the more details in

00:10:52,079 --> 00:10:55,440
following three parts

00:10:55,839 --> 00:11:02,560
for emulated virtual devices such as

00:10:59,519 --> 00:11:06,399
uat gets the trip out

00:11:02,560 --> 00:11:10,000
when accessing mammal region

00:11:06,399 --> 00:11:13,040
qm obtains the reason and the death of

00:11:10,000 --> 00:11:14,720
trap and the further transform service

00:11:13,040 --> 00:11:17,839
information to the

00:11:14,720 --> 00:11:21,519
user space kimtor

00:11:17,839 --> 00:11:24,640
or kumar process io request

00:11:21,519 --> 00:11:28,000
according to this information

00:11:24,640 --> 00:11:33,279
after that country flow returns back to

00:11:28,000 --> 00:11:33,279
qm and the further returns back to guest

00:11:33,600 --> 00:11:40,560
as shown in the graph which the support

00:11:37,360 --> 00:11:43,680
of hardware a specific

00:11:40,560 --> 00:11:44,480
exception whereas the guest can be

00:11:43,680 --> 00:11:47,839
directly

00:11:44,480 --> 00:11:52,160
redirect to host user space

00:11:47,839 --> 00:11:56,880
by passing qm user level exception

00:11:52,160 --> 00:12:01,200
under first save the guest contacts

00:11:56,880 --> 00:12:04,959
also some function implemented in qm

00:12:01,200 --> 00:12:08,160
under the exception in our work

00:12:04,959 --> 00:12:11,920
they they are moving to the

00:12:08,160 --> 00:12:14,320
host user space sas procedure

00:12:11,920 --> 00:12:16,240
of obtain exhibition reason and the

00:12:14,320 --> 00:12:20,320
related data

00:12:16,240 --> 00:12:24,079
are moved to the host user space

00:12:20,320 --> 00:12:27,120
besides when corner traps occur

00:12:24,079 --> 00:12:28,800
during the i o processing new corner

00:12:27,120 --> 00:12:31,920
stack

00:12:28,800 --> 00:12:36,320
should be a region to avoid

00:12:31,920 --> 00:12:36,320
broken the exiting corner stack

00:12:36,560 --> 00:12:39,920
to directly redirect the exception from

00:12:39,360 --> 00:12:43,680
guest

00:12:39,920 --> 00:12:47,519
to the host user space we extended

00:12:43,680 --> 00:12:49,920
an extension an extension is for

00:12:47,519 --> 00:12:51,839
adding user level exhibition and

00:12:49,920 --> 00:12:54,959
interrupt handle

00:12:51,839 --> 00:12:58,720
in extension control state register

00:12:54,959 --> 00:13:02,639
such as your status your scratch

00:12:58,720 --> 00:13:06,320
etc are used as shown in the

00:13:02,639 --> 00:13:09,440
following tables so we no longer

00:13:06,320 --> 00:13:09,440
determine them here

00:13:10,399 --> 00:13:17,519
use level exception handler defined

00:13:13,440 --> 00:13:21,279
in an extension can only

00:13:17,519 --> 00:13:24,480
precise execution in your mod

00:13:21,279 --> 00:13:25,200
we here extended an extension to be able

00:13:24,480 --> 00:13:29,680
to

00:13:25,200 --> 00:13:33,200
handle exhibition rest in the guest

00:13:29,680 --> 00:13:37,200
first we added a new csr

00:13:33,200 --> 00:13:42,240
actually delegates to a long exemptions

00:13:37,200 --> 00:13:42,240
rest in guests to be

00:13:46,839 --> 00:13:49,839
delegated

00:13:55,440 --> 00:14:01,360
recording the previous

00:13:58,560 --> 00:14:02,240
privilege live and the virtualization

00:14:01,360 --> 00:14:05,600
mode

00:14:02,240 --> 00:14:09,279
country floor in guest can thus be

00:14:05,600 --> 00:14:12,720
redirected to user space also

00:14:09,279 --> 00:14:16,320
the country floor should also be able to

00:14:12,720 --> 00:14:19,519
return to back to return back to

00:14:16,320 --> 00:14:22,959
guest from the host user space

00:14:19,519 --> 00:14:24,240
directly at that time the new return

00:14:22,959 --> 00:14:27,440
instruction

00:14:24,240 --> 00:14:31,199
is extended with the semantics

00:14:27,440 --> 00:14:31,839
of a long return to vs model for real

00:14:31,199 --> 00:14:34,880
model

00:14:31,839 --> 00:14:36,959
from your mod further

00:14:34,880 --> 00:14:38,240
to avoid abusing the you written

00:14:36,959 --> 00:14:42,000
instruction

00:14:38,240 --> 00:14:45,120
a new field called hur

00:14:42,000 --> 00:14:48,240
is aided in edge status

00:14:45,120 --> 00:14:52,639
this can prevent normal slides

00:14:48,240 --> 00:14:55,839
normal user stretch to jump to any place

00:14:52,639 --> 00:14:59,440
in guest this is because

00:14:55,839 --> 00:15:02,480
the returned address counted

00:14:59,440 --> 00:15:07,920
by uepc and the use data

00:15:02,480 --> 00:15:07,920
can be changed without any restriction

00:15:08,399 --> 00:15:13,199
besides 2ml page photo exception are

00:15:12,160 --> 00:15:16,320
added

00:15:13,199 --> 00:15:19,839
those exceptions will also be

00:15:16,320 --> 00:15:23,360
hand in holster user space

00:15:19,839 --> 00:15:24,639
one guest access specifically manual

00:15:23,360 --> 00:15:28,160
address of

00:15:24,639 --> 00:15:29,839
emulated io devices by loading or store

00:15:28,160 --> 00:15:32,320
instruction

00:15:29,839 --> 00:15:33,519
cross-spending exceptions were being

00:15:32,320 --> 00:15:37,120
raised

00:15:33,519 --> 00:15:41,440
to implement this a new field

00:15:37,120 --> 00:15:44,720
called mammal is added in pte

00:15:41,440 --> 00:15:47,759
when mmu access the pte at

00:15:44,720 --> 00:15:51,120
the second stage

00:15:47,759 --> 00:15:54,800
translation and the mammal is

00:15:51,120 --> 00:15:58,160
said in pt mammal page foot

00:15:54,800 --> 00:15:58,160
will be raised

00:15:58,560 --> 00:16:01,839
to eliminate the performance

00:16:00,880 --> 00:16:05,519
improvements

00:16:01,839 --> 00:16:09,279
brought by irv we perform

00:16:05,519 --> 00:16:12,480
our experiments on risk 5 systems

00:16:09,279 --> 00:16:16,240
which is running on the hustling

00:16:12,480 --> 00:16:20,320
compound 920 cpu cross

00:16:16,240 --> 00:16:24,959
the host is configured with 4 cpu

00:16:20,320 --> 00:16:28,000
and 2 gigabytes system memory

00:16:24,959 --> 00:16:31,839
where the guest is start up with

00:16:28,000 --> 00:16:36,320
one cpu and one gigabytes system memory

00:16:31,839 --> 00:16:39,519
which is enough to perform our test

00:16:36,320 --> 00:16:42,959
due to the lack of standardized

00:16:39,519 --> 00:16:46,240
uart benchmark we tested the performance

00:16:42,959 --> 00:16:49,600
of uart by putting one kilo

00:16:46,240 --> 00:16:53,920
10 kilo 50 kilo 100 kilo lengths

00:16:49,600 --> 00:16:57,199
of hollow wood to the terminal

00:16:53,920 --> 00:17:00,240
as we can see from the red finger

00:16:57,199 --> 00:17:04,559
the output speed of actually

00:17:00,240 --> 00:17:09,120
based uart achieves near two terms

00:17:04,559 --> 00:17:09,120
faster than the original one

00:17:10,240 --> 00:17:17,280
corner per virtual io devices such as

00:17:14,079 --> 00:17:20,559
rehearsal knight can also benefit

00:17:17,280 --> 00:17:23,199
from harvey

00:17:20,559 --> 00:17:25,679
in extending measured to accessing

00:17:23,199 --> 00:17:28,440
corner prevention io devices

00:17:25,679 --> 00:17:31,360
guests should trap out to say the

00:17:28,440 --> 00:17:35,039
notifications

00:17:31,360 --> 00:17:37,679
in actual way we propose the va

00:17:35,039 --> 00:17:38,880
with alonso guest said supervisor

00:17:37,679 --> 00:17:42,080
interrupt

00:17:38,880 --> 00:17:44,720
without tripping out holster

00:17:42,080 --> 00:17:45,679
corner threats can thus be worked up

00:17:44,720 --> 00:17:48,960
quickly

00:17:45,679 --> 00:17:49,760
by eliminating the overhangs of contact

00:17:48,960 --> 00:17:53,679
switch

00:17:49,760 --> 00:17:53,679
between hoster and the guest

00:17:53,919 --> 00:18:00,799
to allow guests to notify corner threats

00:17:57,600 --> 00:18:02,160
in the host each corner slides for

00:18:00,799 --> 00:18:05,600
hunting supervisor

00:18:02,160 --> 00:18:06,640
interrupts is paired to a physical world

00:18:05,600 --> 00:18:09,919
trial

00:18:06,640 --> 00:18:13,600
virtual inventor interrupt which is

00:18:09,919 --> 00:18:17,360
identified by the vr id

00:18:13,600 --> 00:18:20,720
guest only need to send the vr

00:18:17,360 --> 00:18:22,160
request number to the interrupt

00:18:20,720 --> 00:18:24,480
controller

00:18:22,160 --> 00:18:26,559
then the interrupt controller will

00:18:24,480 --> 00:18:30,080
transfer the vr request

00:18:26,559 --> 00:18:33,200
number to the vr id

00:18:30,080 --> 00:18:34,400
then the mapping information is are

00:18:33,200 --> 00:18:38,240
private

00:18:34,400 --> 00:18:41,039
by kumar and hoster corner

00:18:38,240 --> 00:18:41,679
finally each should we request the

00:18:41,039 --> 00:18:45,039
number

00:18:41,679 --> 00:18:48,960
in a guest will be attached

00:18:45,039 --> 00:18:51,760
to a vid on the specific

00:18:48,960 --> 00:18:51,760
cpu core

00:18:52,640 --> 00:18:56,240
more specifically following steps will

00:18:55,600 --> 00:18:59,679
be

00:18:56,240 --> 00:19:03,760
performed to send

00:18:59,679 --> 00:19:06,880
and deliver supervisor vr

00:19:03,760 --> 00:19:10,320
firstly gaster sends vi by

00:19:06,880 --> 00:19:13,679
writing via request to a new add

00:19:10,320 --> 00:19:16,720
cpu request the register is

00:19:13,679 --> 00:19:20,240
alone to access in guest so

00:19:16,720 --> 00:19:24,080
there is no need for gaster to check

00:19:20,240 --> 00:19:27,280
out then vid is obtained by

00:19:24,080 --> 00:19:30,160
waya motor in cpu to further

00:19:27,280 --> 00:19:31,039
clear the rejected mapping information

00:19:30,160 --> 00:19:34,559
present

00:19:31,039 --> 00:19:37,919
in the interrupt controller finally

00:19:34,559 --> 00:19:39,120
when the target cpid is found a physical

00:19:37,919 --> 00:19:42,400
interrupter

00:19:39,120 --> 00:19:45,360
identified by vid is delivered

00:19:42,400 --> 00:19:47,840
to the host of counter-strikes in target

00:19:45,360 --> 00:19:47,840
cpu

00:19:48,080 --> 00:19:54,160
to show the advantage of harvey will

00:19:52,240 --> 00:19:57,280
perform our test

00:19:54,160 --> 00:20:01,039
using the rehoster knight the

00:19:57,280 --> 00:20:01,600
experiment environment is the sum to the

00:20:01,039 --> 00:20:05,600
one

00:20:01,600 --> 00:20:08,640
to elevate the uart netport

00:20:05,600 --> 00:20:11,840
is choosing as the benchmark

00:20:08,640 --> 00:20:12,640
to evaluate the performance of vehicles

00:20:11,840 --> 00:20:15,760
light

00:20:12,640 --> 00:20:20,240
and actually based vehicles light

00:20:15,760 --> 00:20:23,440
as we can see from the red fingers

00:20:20,240 --> 00:20:27,280
and ways in tcp and the udp of

00:20:23,440 --> 00:20:30,640
rehearsal night can be improved by

00:20:27,280 --> 00:20:34,559
over 100 percent when message

00:20:30,640 --> 00:20:37,919
size are small

00:20:34,559 --> 00:20:41,120
finally to improve cpu utilization

00:20:37,919 --> 00:20:44,240
polymorph is replaced by

00:20:41,120 --> 00:20:45,280
virtual inventor interrupt and hardware

00:20:44,240 --> 00:20:49,840
assessor

00:20:45,280 --> 00:20:49,840
contact switch in our approach

00:20:49,919 --> 00:20:55,120
in the polling model gaster interact

00:20:52,720 --> 00:20:58,080
with user level io devices

00:20:55,120 --> 00:20:59,840
will share the memory between guests and

00:20:58,080 --> 00:21:03,200
the host

00:20:59,840 --> 00:21:07,440
water banking cells are implemented

00:21:03,200 --> 00:21:10,960
as polling threats which still

00:21:07,440 --> 00:21:14,480
keep other threats from

00:21:10,960 --> 00:21:17,679
running on the polling cpu course

00:21:14,480 --> 00:21:21,039
when i requests become real this

00:21:17,679 --> 00:21:23,440
lowers the utilization of polling cpu

00:21:21,039 --> 00:21:23,440
cross

00:21:23,760 --> 00:21:29,679
in actual way gas the interactor with

00:21:27,280 --> 00:21:32,880
the user level

00:21:29,679 --> 00:21:35,919
devices by using

00:21:32,880 --> 00:21:39,760
live virtual inventor interrupt

00:21:35,919 --> 00:21:43,360
guest is alone to send user level vi

00:21:39,760 --> 00:21:46,880
without tripping out to qm

00:21:43,360 --> 00:21:48,799
water blanket is implemented in user

00:21:46,880 --> 00:21:51,919
level interrupt handles

00:21:48,799 --> 00:21:55,280
it can be triggered by the vi

00:21:51,919 --> 00:21:58,400
instead of the schedule of scheduled

00:21:55,280 --> 00:22:02,799
by the kernel it can enhance

00:21:58,400 --> 00:22:06,640
the responsibilities hardware assisted

00:22:02,799 --> 00:22:10,080
contact switch is thus extended

00:22:06,640 --> 00:22:13,200
in the cpu and interrupt controller

00:22:10,080 --> 00:22:14,799
for swiping the memory space and the

00:22:13,200 --> 00:22:18,400
data structure

00:22:14,799 --> 00:22:21,440
data structure of using level interrupt

00:22:18,400 --> 00:22:24,720
handlers by passing

00:22:21,440 --> 00:22:27,840
the kernel to support

00:22:24,720 --> 00:22:31,360
the user level interrupt just reduced

00:22:27,840 --> 00:22:34,640
including your scratcher utility

00:22:31,360 --> 00:22:35,360
as you scratch and the ico atp should

00:22:34,640 --> 00:22:39,600
also be

00:22:35,360 --> 00:22:42,880
provided in the interrupt controller

00:22:39,600 --> 00:22:44,080
use brush saves the user-level data

00:22:42,880 --> 00:22:47,280
structure of the

00:22:44,080 --> 00:22:51,280
interrupt handle where ut vector

00:22:47,280 --> 00:22:54,240
stores the venture address of the

00:22:51,280 --> 00:22:55,840
interrupt handler to achieve faster

00:22:54,240 --> 00:22:58,559
responsiveness

00:22:55,840 --> 00:22:59,679
when handling user-level interrupts

00:22:58,559 --> 00:23:04,799
request

00:22:59,679 --> 00:23:08,799
as you scratch and the ictp are extended

00:23:04,799 --> 00:23:09,679
the request as you scratch is for saving

00:23:08,799 --> 00:23:12,080
the

00:23:09,679 --> 00:23:13,919
corner data structure of the user

00:23:12,080 --> 00:23:17,679
library interrupt handler

00:23:13,919 --> 00:23:18,400
where the sutp is for saving the memory

00:23:17,679 --> 00:23:23,280
space

00:23:18,400 --> 00:23:26,080
of the user level interrupt handler

00:23:23,280 --> 00:23:26,480
when a user level watch event interrupt

00:23:26,080 --> 00:23:30,640
is

00:23:26,480 --> 00:23:33,919
sent by the guest interrupter controller

00:23:30,640 --> 00:23:34,720
creates a mapping information to find

00:23:33,919 --> 00:23:38,240
the vi

00:23:34,720 --> 00:23:42,559
physical number also rejects

00:23:38,240 --> 00:23:44,720
mentioned above in the target cpu cross

00:23:42,559 --> 00:23:46,640
are overwritten by the interrupt

00:23:44,720 --> 00:23:49,760
controller

00:23:46,640 --> 00:23:50,000
then the interrupt controller delivers

00:23:49,760 --> 00:23:54,960
the

00:23:50,000 --> 00:23:58,080
vid to the target cpu course

00:23:54,960 --> 00:24:00,000
when target cpu course handles the user

00:23:58,080 --> 00:24:02,159
level interrupts

00:24:00,000 --> 00:24:03,039
hardware assists the context switch

00:24:02,159 --> 00:24:06,159
mechanism

00:24:03,039 --> 00:24:09,679
in cpu for the swap wheels

00:24:06,159 --> 00:24:13,120
in seo scratch and gtp with

00:24:09,679 --> 00:24:16,000
a scratch as atp

00:24:13,120 --> 00:24:16,720
the critical context including member

00:24:16,000 --> 00:24:20,480
space

00:24:16,720 --> 00:24:23,600
and data structures of the interrupted

00:24:20,480 --> 00:24:24,720
user threat and the user level interrupt

00:24:23,600 --> 00:24:27,919
handlers

00:24:24,720 --> 00:24:30,960
are swept by the hardware access

00:24:27,919 --> 00:24:30,960
context switch

00:24:31,760 --> 00:24:37,919
to handle the user live interrupts

00:24:34,880 --> 00:24:41,440
crossbending software interrupt handle

00:24:37,919 --> 00:24:45,279
is proposed and it is architecture

00:24:41,440 --> 00:24:48,000
is shown in the red fingers

00:24:45,279 --> 00:24:48,799
a user level interrupt handler is

00:24:48,000 --> 00:24:52,320
composed

00:24:48,799 --> 00:24:55,679
to is composed of

00:24:52,320 --> 00:24:56,799
interrupt handler and user spec user

00:24:55,679 --> 00:25:00,320
strict

00:24:56,799 --> 00:25:04,159
user threat both of

00:25:00,320 --> 00:25:07,679
which showing the same member space

00:25:04,159 --> 00:25:10,640
and corner data structure

00:25:07,679 --> 00:25:11,919
which the interrupt handle is triggered

00:25:10,640 --> 00:25:16,320
to run

00:25:11,919 --> 00:25:19,840
contacts are saved in it is user style

00:25:16,320 --> 00:25:24,640
the saved contacts will be restored

00:25:19,840 --> 00:25:27,520
when returned to the interrupted thread

00:25:24,640 --> 00:25:28,559
during the execution of the interrupt

00:25:27,520 --> 00:25:31,679
handle

00:25:28,559 --> 00:25:35,120
from the view of corner

00:25:31,679 --> 00:25:38,559
or cpu the interrupted threat

00:25:35,120 --> 00:25:42,080
is still running and it is

00:25:38,559 --> 00:25:46,000
only regarded as interrupted

00:25:42,080 --> 00:25:48,640
in standard of being scheduled out

00:25:46,000 --> 00:25:49,840
this is done by showing the schedule

00:25:48,640 --> 00:25:53,360
information

00:25:49,840 --> 00:25:56,960
of the interrupted slide with the

00:25:53,360 --> 00:26:00,559
interrupter handler

00:25:56,960 --> 00:26:04,240
however the cpu core sometimes is not

00:26:00,559 --> 00:26:06,799
in the u mode and this may post upon

00:26:04,240 --> 00:26:08,159
the handling of the user level

00:26:06,799 --> 00:26:11,440
interrupts

00:26:08,159 --> 00:26:14,799
just for one thing the

00:26:11,440 --> 00:26:17,919
period of wheels mode view mode is

00:26:14,799 --> 00:26:21,039
defined to be lower than the

00:26:17,919 --> 00:26:23,919
period of your mode

00:26:21,039 --> 00:26:24,640
user-level interrupts are able to

00:26:23,919 --> 00:26:27,279
interrupt

00:26:24,640 --> 00:26:28,559
the running guest by switching

00:26:27,279 --> 00:26:32,720
virtualization mode

00:26:28,559 --> 00:26:36,080
to non-virtualization mode for another

00:26:32,720 --> 00:26:37,360
if the targeted cpu core is in address

00:26:36,080 --> 00:26:41,120
mode

00:26:37,360 --> 00:26:45,039
for example the other tasker is running

00:26:41,120 --> 00:26:48,880
adobe interrupt is addressed to schedule

00:26:45,039 --> 00:26:52,480
user strikes then the interrupt handler

00:26:48,880 --> 00:26:56,240
is triggered by the user level vr

00:26:52,480 --> 00:26:59,120
to run io process by interrupting the

00:26:56,240 --> 00:26:59,120
user's threat

00:26:59,520 --> 00:27:06,159
due to the lack of dptk and

00:27:02,640 --> 00:27:09,679
sbdk support in risc 5 systems

00:27:06,159 --> 00:27:13,840
we evaluate the user level vi using

00:27:09,679 --> 00:27:17,279
world high block we use ifr benchmark

00:27:13,840 --> 00:27:20,480
to test the reader write render reader

00:27:17,279 --> 00:27:23,600
and run write performance of

00:27:20,480 --> 00:27:26,720
guests on the basis

00:27:23,600 --> 00:27:31,360
of water black and actually best

00:27:26,720 --> 00:27:34,880
water black from the red fingers

00:27:31,360 --> 00:27:38,080
we can i see that against the

00:27:34,880 --> 00:27:42,320
average 20 percent performance

00:27:38,080 --> 00:27:45,039
improvement when message size are small

00:27:42,320 --> 00:27:45,760
also the performance in revelation

00:27:45,039 --> 00:27:49,520
results

00:27:45,760 --> 00:27:52,960
we obtained are still unstable

00:27:49,520 --> 00:27:56,399
we believe it is caused by the software

00:27:52,960 --> 00:28:01,840
where human even merely in

00:27:56,399 --> 00:28:05,120
emulate thus fpga based

00:28:01,840 --> 00:28:08,480
that supports risk file virtualization

00:28:05,120 --> 00:28:11,279
is needed for fasten validated

00:28:08,480 --> 00:28:11,279
new ideas

00:28:13,520 --> 00:28:17,919
in this talk we propose the hardware

00:28:16,240 --> 00:28:21,840
assisted technicals

00:28:17,919 --> 00:28:25,840
for io virtualization including

00:28:21,840 --> 00:28:29,200
user level exhibition redirection

00:28:25,840 --> 00:28:31,440
virtual inventory interrupt and hardware

00:28:29,200 --> 00:28:35,679
assisted contact switch

00:28:31,440 --> 00:28:38,799
we named it a trade away actually i will

00:28:35,679 --> 00:28:39,840
enhance performance of four emulated io

00:28:38,799 --> 00:28:43,039
devices

00:28:39,840 --> 00:28:44,080
and the per virtual devices in both the

00:28:43,039 --> 00:28:47,279
kernel and

00:28:44,080 --> 00:28:50,399
user space besides it

00:28:47,279 --> 00:28:54,320
improved cpu utilization by

00:28:50,399 --> 00:28:57,360
freeing up polling cpu cores

00:28:54,320 --> 00:29:00,840
there are some future work the

00:28:57,360 --> 00:29:04,399
map current hardware models in current

00:29:00,840 --> 00:29:07,760
implementation prototypes is

00:29:04,399 --> 00:29:11,039
kneeview so the latency of

00:29:07,760 --> 00:29:14,720
current vm map information

00:29:11,039 --> 00:29:18,320
deserves future optimization

00:29:14,720 --> 00:29:22,399
also since with vi is attached to a

00:29:18,320 --> 00:29:25,360
physical cpu core cpu affinity process

00:29:22,399 --> 00:29:26,960
for vi should be provided for load

00:29:25,360 --> 00:29:30,000
balancing

00:29:26,960 --> 00:29:33,919
due to the obturation on privilege

00:29:30,000 --> 00:29:37,200
reduced such as uepc and your status

00:29:33,919 --> 00:29:40,799
may cause some security issues

00:29:37,200 --> 00:29:44,000
much more work on enhancing the security

00:29:40,799 --> 00:29:47,440
of actually our way should be took

00:29:44,000 --> 00:29:54,799
into consideration okay

00:29:47,440 --> 00:29:56,880
this is all our work thank you

00:29:54,799 --> 00:29:56,880

YouTube URL: https://www.youtube.com/watch?v=mFLI1Me-TvE


