Title: [2020] Debugging KVM Using Intel DCI Technology by Raymond Zhang
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Debugging KVM using print/log is inefficient and has many limitations. This talk will introduce a new way to debug KVM using the Direct Connect Interface (DCI). DCI is a new technology introduced by Intel Skylake. It exposes the Intel Target Probe (ITP) and JTAG scan chain to USB 3 ports so that host computer can build a JTAG connection with Intel silicon via a USB 3 cable. For the transportation lay is USB 3, it's very fast. Besides the transferring speed, debugging via DCI controls CPU at hardware level, has no dependency on software. This brings several benefits, such as break in when interrupt is off, break on VM entry and VM exit and single stepping sensitive code in VMM etc. In this talk, Raymond, a veteran Intel architect, will explain the DCI technology and how to use it to debug KVM, both the VMM layer and VM layer.

---

Raymond Zhang
Xedge.AI, Software Architect

Raymond (Yinkui Zhang) is a widely recognized expert on system software and low level debugging. He is author of the top-selling book on Software Debugging and columnist for the Debugging Sword column of the Programmer magazine. He has worked in the IT industry for over 20 years with different roles, including software design engineer, system validation engineer, project leader, software architect, and software team manager. He worked in Intel for over 13 years. Now he is a software architect of Xedge.AI. Raymond graduated from Shanghai Jiaotong University in 1996. Raymond is a frequent speaker for technical conference, such as Microsoft Ignite 2016, Microsoft TechEd, C/C++ Conference 2016, 2019, AI Conference 2018, etc.
Captions: 
	00:00:00,160 --> 00:00:07,120
and uh i'm very happy

00:00:03,679 --> 00:00:10,480
to share my experience

00:00:07,120 --> 00:00:12,080
of debugging kvm using internal dci

00:00:10,480 --> 00:00:15,599
technology

00:00:12,080 --> 00:00:17,920
this is my first time to present in qvm

00:00:15,599 --> 00:00:17,920
forum

00:00:20,560 --> 00:00:26,180
i will do a quick self introduction

00:00:24,720 --> 00:00:28,000
my name is

00:00:26,180 --> 00:00:32,880
[Music]

00:00:28,000 --> 00:00:32,880
i used to work at intel

00:00:32,960 --> 00:00:41,040
from 2003 to 2016.

00:00:37,120 --> 00:00:45,680
in 2009 i

00:00:41,040 --> 00:00:49,039
joined a project which

00:00:45,680 --> 00:00:53,680
is based in onsen

00:00:49,039 --> 00:00:58,640
our goal is made a videographic

00:00:53,680 --> 00:01:02,079
tpo to work in windows vm

00:00:58,640 --> 00:01:05,360
at that time is quite difficult to

00:01:02,079 --> 00:01:08,799
make a

00:01:05,360 --> 00:01:12,320
graphic gpu to work

00:01:08,799 --> 00:01:18,320
in vm usually there is a very

00:01:12,320 --> 00:01:21,360
uh weak gpu uh using vm

00:01:18,320 --> 00:01:25,439
after we pass this path through

00:01:21,360 --> 00:01:29,040
the device to our vm um

00:01:25,439 --> 00:01:32,240
we installed

00:01:29,040 --> 00:01:36,880
12 uh his binary

00:01:32,240 --> 00:01:40,079
and there will be

00:01:36,880 --> 00:01:43,280
there there was a random tdr

00:01:40,079 --> 00:01:46,960
blue screen and i

00:01:43,280 --> 00:01:48,399
spent significant effort to do the week

00:01:46,960 --> 00:01:52,000
debugging

00:01:48,399 --> 00:01:52,880
after three months is i found the root

00:01:52,000 --> 00:01:56,079
cause

00:01:52,880 --> 00:01:59,600
it's about in the mml

00:01:56,079 --> 00:02:03,600
code of the shadow memory

00:01:59,600 --> 00:02:07,119
logic of them at that time

00:02:03,600 --> 00:02:10,879
the only way to do debugging is

00:02:07,119 --> 00:02:14,560
print analog so

00:02:10,879 --> 00:02:18,160
today i will share how to use

00:02:14,560 --> 00:02:23,840
a debugger to do to do the debug

00:02:18,160 --> 00:02:23,840
which is much more efficient

00:02:24,640 --> 00:02:31,120
here is a classy classic

00:02:27,840 --> 00:02:31,120
dan architecture

00:02:31,599 --> 00:02:38,800
there is a hypervisor under all

00:02:35,280 --> 00:02:41,440
vms and

00:02:38,800 --> 00:02:43,840
there is a space of vm is called domain

00:02:41,440 --> 00:02:47,120
zero

00:02:43,840 --> 00:02:50,800
it's a privilege it provides

00:02:47,120 --> 00:02:55,120
a service and it also

00:02:50,800 --> 00:02:58,879
manages other vms

00:02:55,120 --> 00:03:02,480
for example there is an io email process

00:02:58,879 --> 00:03:05,920
for each vm to do a

00:03:02,480 --> 00:03:05,920
device innovation

00:03:07,280 --> 00:03:14,159
and usually we

00:03:10,720 --> 00:03:15,519
only left domain 0 to see the real

00:03:14,159 --> 00:03:20,239
hardware

00:03:15,519 --> 00:03:20,239
all other vms only see the

00:03:20,560 --> 00:03:25,360
emulated fake devices

00:03:26,080 --> 00:03:34,159
so hyperv from microsoft has a similar

00:03:29,519 --> 00:03:37,280
architecture there is also a hypervisor

00:03:34,159 --> 00:03:40,400
under all vms

00:03:37,280 --> 00:03:44,560
in microsoft's term uh vm

00:03:40,400 --> 00:03:47,680
is called partition the parent partition

00:03:44,560 --> 00:03:51,519
is equivalent uh

00:03:47,680 --> 00:03:51,519
to a domain zero of them

00:03:51,599 --> 00:03:58,000
and for windows 10 uh microsoft

00:03:55,360 --> 00:03:59,439
introduced a feature called isolated

00:03:58,000 --> 00:04:02,239
user mode

00:03:59,439 --> 00:04:02,720
also is called working like waterization

00:04:02,239 --> 00:04:06,720
based

00:04:02,720 --> 00:04:11,200
security if this feature

00:04:06,720 --> 00:04:15,519
is enabled a hyperwave

00:04:11,200 --> 00:04:19,120
hypervisor will run and above that

00:04:15,519 --> 00:04:22,400
window 10 is running and

00:04:19,120 --> 00:04:26,639
there is also another special sql kernel

00:04:22,400 --> 00:04:26,639
run on top of the hypervisor

00:04:27,680 --> 00:04:36,320
for uh there will be

00:04:32,639 --> 00:04:40,320
a lot of vm exes uh

00:04:36,320 --> 00:04:43,840
when the windows access hardware

00:04:40,320 --> 00:04:46,880
so after uh this feature is turned on

00:04:43,840 --> 00:04:51,840
actually um the performance

00:04:46,880 --> 00:04:51,840
will be sacrificed

00:04:52,320 --> 00:04:56,800
um i think pvm has a different

00:04:55,759 --> 00:05:00,320
architecture

00:04:56,800 --> 00:05:05,039
and is better so i believe

00:05:00,320 --> 00:05:05,039
kvm has a smarter design

00:05:05,199 --> 00:05:13,280
from the architectural perspective

00:05:08,960 --> 00:05:16,320
um kvm uh combines dominzero's kernel

00:05:13,280 --> 00:05:19,680
and hypervisor into one

00:05:16,320 --> 00:05:21,759
actually they are run in one address

00:05:19,680 --> 00:05:25,120
space

00:05:21,759 --> 00:05:28,400
with this structure

00:05:25,120 --> 00:05:30,320
it has a lot of benefits

00:05:28,400 --> 00:05:32,160
dominguez kernel

00:05:30,320 --> 00:05:35,680
[Music]

00:05:32,160 --> 00:05:40,160
will not exist to have wiser when it

00:05:35,680 --> 00:05:40,160
access hardware

00:05:40,800 --> 00:05:48,160
so it has at one piece

00:05:44,880 --> 00:05:48,160
auto advantages

00:05:49,840 --> 00:05:58,000
people some some people may not agree

00:05:54,080 --> 00:06:01,199
with my previous diagram

00:05:58,000 --> 00:06:04,840
so here i will show some code

00:06:01,199 --> 00:06:08,080
here is a code from

00:06:04,840 --> 00:06:12,720
uh vmx.c

00:06:08,080 --> 00:06:12,720
actually is a code from

00:06:13,039 --> 00:06:21,840
intel to support

00:06:17,600 --> 00:06:21,840
vm technology and

00:06:22,080 --> 00:06:28,960
we can see is a vm

00:06:25,280 --> 00:06:32,720
extension for kvm

00:06:28,960 --> 00:06:35,840
so so this function has a

00:06:32,720 --> 00:06:35,840
very important

00:06:35,919 --> 00:06:42,800
reason says vmx arm

00:06:39,280 --> 00:06:46,319
reaction via maxim is

00:06:42,800 --> 00:06:50,240
an instruction from

00:06:46,319 --> 00:06:55,680
the cpu uh actually it turns on

00:06:50,240 --> 00:06:59,120
uh the hardware support about vm

00:06:55,680 --> 00:07:02,479
about vt um

00:06:59,120 --> 00:07:05,680
using uh to

00:07:02,479 --> 00:07:08,880
disassemble a feature of debugger

00:07:05,680 --> 00:07:12,479
uh we can see uh the instruction uh

00:07:08,880 --> 00:07:13,280
using land into the hardware enable

00:07:12,479 --> 00:07:16,479
function

00:07:13,280 --> 00:07:18,880
uh of kvm uh

00:07:16,479 --> 00:07:18,880
module

00:07:19,599 --> 00:07:26,240
um the vr maximum

00:07:23,039 --> 00:07:29,680
destruction has very

00:07:26,240 --> 00:07:34,240
special low

00:07:29,680 --> 00:07:37,919
uh in the way and in the vp technology

00:07:34,240 --> 00:07:42,160
actually the software uh which

00:07:37,919 --> 00:07:46,160
is killed via vms on uh firstly

00:07:42,160 --> 00:07:49,280
will win the advisor role

00:07:46,160 --> 00:07:51,680
or other uh after that

00:07:49,280 --> 00:07:53,039
if other software is kills the the

00:07:51,680 --> 00:07:57,039
instruction

00:07:53,039 --> 00:07:59,840
it will fail and it will be tweeted

00:07:57,039 --> 00:07:59,840
a twitter

00:08:01,199 --> 00:08:10,840
so with this diagram actually

00:08:05,840 --> 00:08:14,160
it shows a cpus exclusion

00:08:10,840 --> 00:08:17,840
route in

00:08:14,160 --> 00:08:23,199
vt environment

00:08:17,840 --> 00:08:23,199
we will talk it uh later in more detail

00:08:23,520 --> 00:08:29,599
we can set a breakpoint at the via a

00:08:26,800 --> 00:08:33,279
microphone is flexing

00:08:29,599 --> 00:08:37,519
after we set the breakpoint we

00:08:33,279 --> 00:08:41,760
let the target go and

00:08:37,519 --> 00:08:45,760
we launched a kvl vm

00:08:41,760 --> 00:08:45,760
in ubuntu target for example

00:08:45,920 --> 00:08:49,839
after we click the launch button the

00:08:48,720 --> 00:08:54,399
breakdown

00:08:49,839 --> 00:08:55,040
will be hit and using the call stack

00:08:54,399 --> 00:08:58,640
function

00:08:55,040 --> 00:09:00,399
we can see the call stack from the call

00:08:58,640 --> 00:09:03,600
stack we can see

00:09:00,399 --> 00:09:07,040
the linux kernel is

00:09:03,600 --> 00:09:10,640
invoking kvm module

00:09:07,040 --> 00:09:13,920
to do hardware enable actually

00:09:10,640 --> 00:09:19,120
it's using the linux kernels

00:09:13,920 --> 00:09:22,240
of smp

00:09:19,120 --> 00:09:26,399
mechanism to uh

00:09:22,240 --> 00:09:29,440
let all uh cpu

00:09:26,399 --> 00:09:32,560
assign to vm to enable

00:09:29,440 --> 00:09:32,560
to turn on the feature

00:09:35,760 --> 00:09:39,760
after uh kvm uh gains control uh it will

00:09:39,120 --> 00:09:44,000
begin

00:09:39,760 --> 00:09:47,519
invoke uh kvm intel uh actually is

00:09:44,000 --> 00:09:50,880
a function uh pointer uh registered

00:09:47,519 --> 00:09:52,640
into kvm so we can see the hardware

00:09:50,880 --> 00:09:56,320
enable function inclusion

00:09:52,640 --> 00:09:59,680
and we killed the vmx on

00:09:56,320 --> 00:10:03,120
destruction after this instruction

00:09:59,680 --> 00:10:06,160
actually the code

00:10:03,120 --> 00:10:09,920
which it kills the interaction with

00:10:06,160 --> 00:10:13,120
the hypervisor law and

00:10:09,920 --> 00:10:16,560
according to a list called stack

00:10:13,120 --> 00:10:19,680
we can see the hybridizer called

00:10:16,560 --> 00:10:23,760
the linear kernel runs in one

00:10:19,680 --> 00:10:27,040
address space so it's safe to say

00:10:23,760 --> 00:10:32,880
the hypervisor and the linux kernel

00:10:27,040 --> 00:10:36,000
is run it is combined in kvm's

00:10:32,880 --> 00:10:39,279
architecture actually the kvm

00:10:36,000 --> 00:10:42,240
name is very good it means

00:10:39,279 --> 00:10:43,040
kernel based uh word tumors water

00:10:42,240 --> 00:10:46,959
machine

00:10:43,040 --> 00:10:50,000
technology so uh the

00:10:46,959 --> 00:10:50,000
kernel uh

00:10:50,079 --> 00:10:56,640
plays the hypervisor role

00:10:54,000 --> 00:10:56,640
is smart

00:10:57,120 --> 00:11:06,880
that's a quick uh view of kvm

00:11:01,920 --> 00:11:10,160
so next week i will talk about dci

00:11:06,880 --> 00:11:14,000
then i will talk how to

00:11:10,160 --> 00:11:19,040
debug pvm using pci

00:11:14,000 --> 00:11:24,079
and here is my debugging environment

00:11:19,040 --> 00:11:24,079
actually i'm in travel and

00:11:24,720 --> 00:11:31,260
i'm talking in a small hotel

00:11:28,959 --> 00:11:33,279
here is the

00:11:31,260 --> 00:11:36,560
[Music]

00:11:33,279 --> 00:11:39,839
machines are used so

00:11:36,560 --> 00:11:43,200
a laptop is running as

00:11:39,839 --> 00:11:47,360
host and for the target i run

00:11:43,200 --> 00:11:50,399
ubuntu i turn on the kvm feature

00:11:47,360 --> 00:11:54,839
and also install ubuntu inside

00:11:50,399 --> 00:11:56,399
the v1 vm the hardware of the target is

00:11:54,839 --> 00:12:00,399
a

00:11:56,399 --> 00:12:03,680
general cpu low power

00:12:00,399 --> 00:12:07,360
for the target the bios is

00:12:03,680 --> 00:12:10,800
customized i will talk the reason

00:12:07,360 --> 00:12:14,560
shortly between the target and

00:12:10,800 --> 00:12:18,240
host i use a usb 3 cable

00:12:14,560 --> 00:12:21,360
to connect them that's a dci

00:12:18,240 --> 00:12:25,120
technology so dci

00:12:21,360 --> 00:12:28,639
stands for a direct connect interface

00:12:25,120 --> 00:12:28,639
and the name is

00:12:28,959 --> 00:12:32,399
very easy to understand

00:12:33,120 --> 00:12:38,399
it means we can connect the host with

00:12:36,839 --> 00:12:42,399
target

00:12:38,399 --> 00:12:46,000
very easy very direct

00:12:42,399 --> 00:12:49,680
and i think

00:12:46,000 --> 00:12:55,760
before dci we have to

00:12:49,680 --> 00:12:55,760
open the choices to connect the

00:12:56,880 --> 00:13:03,600
itp connector before this i

00:13:00,160 --> 00:13:05,519
interrupt use itp technology to do low

00:13:03,600 --> 00:13:10,000
level debugging

00:13:05,519 --> 00:13:13,120
for itp way

00:13:10,000 --> 00:13:15,279
the connector is our motherboard it's

00:13:13,120 --> 00:13:19,279
not opposed to

00:13:15,279 --> 00:13:22,560
traces so we have to open traces

00:13:19,279 --> 00:13:25,760
that's inconvenient

00:13:22,560 --> 00:13:29,440
so for dci actually it's

00:13:25,760 --> 00:13:34,240
introduced by skelet

00:13:29,440 --> 00:13:37,680
in 2016. um

00:13:34,240 --> 00:13:41,120
ipd is a very

00:13:37,680 --> 00:13:44,720
cool uh very good technology

00:13:41,120 --> 00:13:48,079
it it holds the powerful itp

00:13:44,720 --> 00:13:51,360
test detects the entwine

00:13:48,079 --> 00:13:54,880
technology and to

00:13:51,360 --> 00:13:59,600
usb connector which is

00:13:54,880 --> 00:13:59,600
very easy to do connection

00:14:00,399 --> 00:14:07,199
inside the silicon actually there is

00:14:03,440 --> 00:14:11,680
a new component called xdci

00:14:07,199 --> 00:14:15,440
xdci uh will uh

00:14:11,680 --> 00:14:19,680
work with a gtech secant twin

00:14:15,440 --> 00:14:23,040
and transfer the date uh to xhci

00:14:19,680 --> 00:14:26,720
that's a usb 3 controller

00:14:23,040 --> 00:14:30,480
they will work together to expose the

00:14:26,720 --> 00:14:34,399
atp technology to a

00:14:30,480 --> 00:14:34,399
convenient usb port

00:14:35,199 --> 00:14:41,680
um here is the

00:14:38,240 --> 00:14:44,320
devices using

00:14:41,680 --> 00:14:47,920
dci debugger actually here is an

00:14:44,320 --> 00:14:47,920
impaired system studio

00:14:49,120 --> 00:14:55,199
i think the beauty

00:14:52,160 --> 00:14:58,480
of dci debugger is

00:14:55,199 --> 00:15:03,440
you can see a lot of

00:14:58,480 --> 00:15:06,639
internal devices

00:15:03,440 --> 00:15:09,839
using the debugger

00:15:06,639 --> 00:15:12,959
for example here here we can see

00:15:09,839 --> 00:15:17,120
the internal car

00:15:12,959 --> 00:15:20,720
also the anchor banker part

00:15:17,120 --> 00:15:27,839
also the integrity

00:15:20,720 --> 00:15:27,839
devices inside the tube side

00:15:28,320 --> 00:15:34,880
so for people doing low-level

00:15:31,920 --> 00:15:35,600
development for recap for example os

00:15:34,880 --> 00:15:39,040
development

00:15:35,600 --> 00:15:39,600
or general development i believe it's

00:15:39,040 --> 00:15:43,839
very

00:15:39,600 --> 00:15:44,560
useful actually there are two types of

00:15:43,839 --> 00:15:47,680
dci

00:15:44,560 --> 00:15:51,519
uh one is called boundary scan seven

00:15:47,680 --> 00:15:54,880
hosted dci it need a small

00:15:51,519 --> 00:15:59,040
uh box the box is called a closed

00:15:54,880 --> 00:16:02,320
traces adapter as cca

00:15:59,040 --> 00:16:06,839
near salt the other way is called

00:16:02,320 --> 00:16:08,079
usb hosted dci it only needs a usb 3

00:16:06,839 --> 00:16:11,519
cable

00:16:08,079 --> 00:16:15,120
and the second way

00:16:11,519 --> 00:16:19,120
is low cost and it's convenient actually

00:16:15,120 --> 00:16:22,800
i'm using the second way and

00:16:19,120 --> 00:16:26,000
just to constitution constraint

00:16:22,800 --> 00:16:29,839
of the second way is it can only do i

00:16:26,000 --> 00:16:35,360
zero debugging it cannot divide

00:16:29,839 --> 00:16:39,360
early recap for cca

00:16:35,360 --> 00:16:43,680
it can develop early wake up that's a

00:16:39,360 --> 00:16:45,920
one page of the cca

00:16:43,680 --> 00:16:45,920
tool

00:16:47,279 --> 00:16:56,160
um i have to mention that

00:16:52,079 --> 00:16:56,160
to do dci debugging um

00:16:56,720 --> 00:17:05,520
we need usually uh customize the bios

00:17:02,079 --> 00:17:09,280
the reason is for security concern

00:17:05,520 --> 00:17:13,520
uh intel uh advise our oem

00:17:09,280 --> 00:17:17,439
to turn off the feature i give about

00:17:13,520 --> 00:17:20,640
just lock the feature

00:17:17,439 --> 00:17:25,600
after it's locked uh it cannot be

00:17:20,640 --> 00:17:25,600
turned on again without power cycle

00:17:26,000 --> 00:17:33,039
it means if instant off uh inside bios

00:17:29,760 --> 00:17:36,480
there is no way a to turn on it

00:17:33,039 --> 00:17:41,600
in os that's why

00:17:36,480 --> 00:17:41,600
we usually need a customized firmware

00:17:44,840 --> 00:17:50,480
sorry

00:17:47,039 --> 00:17:53,679
um after i introduce the

00:17:50,480 --> 00:17:57,280
pci then i will um

00:17:53,679 --> 00:18:02,160
share my experience about debug qvm

00:17:57,280 --> 00:18:05,679
using vci i will talk uh some typical

00:18:02,160 --> 00:18:10,320
scenario to do the debugging for example

00:18:05,679 --> 00:18:15,440
uh about vm create

00:18:10,320 --> 00:18:19,120
there are a lot of steps to create a vm

00:18:15,440 --> 00:18:22,400
i will talk some

00:18:19,120 --> 00:18:29,360
examples for example here is

00:18:22,400 --> 00:18:33,760
a breakpoint vmix create vcpu

00:18:29,360 --> 00:18:37,520
when this preponderate we can examine

00:18:33,760 --> 00:18:40,240
the details about creating

00:18:37,520 --> 00:18:40,240
vcpu

00:18:41,200 --> 00:18:45,919
after creating vcpu uh

00:18:48,320 --> 00:18:56,160
the kvm will create virtual mmu

00:18:52,320 --> 00:18:59,760
uh working mu i mean i think it's just a

00:18:56,160 --> 00:19:02,799
simple name actually it's uh

00:18:59,760 --> 00:19:06,080
creating the facility

00:19:02,799 --> 00:19:10,640
of memory and page

00:19:06,080 --> 00:19:16,000
for the vm says

00:19:10,640 --> 00:19:16,000
turn on the for example the epp

00:19:16,480 --> 00:19:23,600
technology of the hardware if

00:19:19,600 --> 00:19:28,160
no epp support in hardware

00:19:23,600 --> 00:19:33,120
i will give you a special shadow

00:19:28,160 --> 00:19:33,120
page mechanism in software

00:19:34,559 --> 00:19:42,960
after creating a recipe and

00:19:39,360 --> 00:19:47,120
what you mma you the kvm

00:19:42,960 --> 00:19:50,400
will create local ap for the vm

00:19:47,120 --> 00:19:52,559
local ap means

00:19:50,400 --> 00:19:55,039
advanced programmable interrupt

00:19:52,559 --> 00:19:55,039
controller

00:19:55,440 --> 00:19:59,440
that's a virtual uh

00:19:59,760 --> 00:20:04,240
plc for the vm

00:20:04,720 --> 00:20:10,559
to to interrupt and transfer

00:20:07,840 --> 00:20:10,559
to the vm

00:20:13,440 --> 00:20:20,320
oxygen pvm

00:20:16,480 --> 00:20:23,679
will also create some

00:20:20,320 --> 00:20:27,120
uh facility to

00:20:23,679 --> 00:20:27,120
emulate hybrid's

00:20:27,520 --> 00:20:34,240
vampire facility i believe

00:20:30,720 --> 00:20:39,039
this is to uh

00:20:34,240 --> 00:20:44,240
speed up the device communication

00:20:39,039 --> 00:20:44,240
between vms

00:20:46,840 --> 00:20:53,520
in in in the times

00:20:49,280 --> 00:20:57,039
uh i think in the uh 10 years before

00:20:53,520 --> 00:21:01,600
we usually emulate the device

00:20:57,039 --> 00:21:04,640
using the real protocol

00:21:01,600 --> 00:21:08,000
but it is it might be slow

00:21:04,640 --> 00:21:11,120
and the vm bus has

00:21:08,000 --> 00:21:14,159
a special protocol uh defend

00:21:11,120 --> 00:21:17,840
for vm it has

00:21:14,159 --> 00:21:17,840
a better performance

00:21:19,280 --> 00:21:26,559
after that kvm will create

00:21:22,480 --> 00:21:30,240
a project more uh pro uh private

00:21:26,559 --> 00:21:33,600
pid for vm

00:21:30,240 --> 00:21:38,960
is for a timely draft

00:21:33,600 --> 00:21:43,520
timer interrupt is a classic

00:21:38,960 --> 00:21:48,480
facility for for pc

00:21:43,520 --> 00:21:48,480
actually and today is still used

00:21:48,720 --> 00:21:56,240
so that the machine

00:21:52,080 --> 00:21:56,240
has a clock support

00:21:56,840 --> 00:22:03,760
um so after uh

00:21:59,919 --> 00:22:07,200
success about vm create so

00:22:03,760 --> 00:22:12,159
so uh so now i will talk vm exit

00:22:07,200 --> 00:22:15,200
actually after a vm uh is created uh

00:22:12,159 --> 00:22:18,640
cpu uh uh will

00:22:15,200 --> 00:22:23,600
uh run the vm launch instruction of vm

00:22:18,640 --> 00:22:27,520
enter then uh the cpu will

00:22:23,600 --> 00:22:30,960
enter the guest domain

00:22:27,520 --> 00:22:33,360
and runs his runs instruction inside the

00:22:30,960 --> 00:22:33,360
vm

00:22:33,440 --> 00:22:39,280
for normal distraction

00:22:36,880 --> 00:22:40,000
says unprevailing the instruction the

00:22:39,280 --> 00:22:42,400
cpu will

00:22:40,000 --> 00:22:43,760
directly execute the youtube use

00:22:42,400 --> 00:22:47,039
function that's called

00:22:43,760 --> 00:22:50,240
direct execute

00:22:47,039 --> 00:22:54,320
but when cpu needs

00:22:50,240 --> 00:22:57,520
a previous instruction or io destruction

00:22:54,320 --> 00:23:01,280
then we will exit that's called

00:22:57,520 --> 00:23:05,919
vm exit so from

00:23:01,280 --> 00:23:09,679
uh to some extent

00:23:05,919 --> 00:23:13,039
when a cpu is running a vm

00:23:09,679 --> 00:23:16,320
it runs in such a loop

00:23:13,039 --> 00:23:20,960
enters vm and

00:23:16,320 --> 00:23:23,600
if it needs meets a special

00:23:20,960 --> 00:23:24,400
instruction is also called sunday tv

00:23:23,600 --> 00:23:28,080
succinct

00:23:24,400 --> 00:23:31,280
it will exit to hypervisor hypervisor

00:23:28,080 --> 00:23:34,320
uh will solve the issue and

00:23:31,280 --> 00:23:38,799
after that if you let the cpu

00:23:34,320 --> 00:23:42,880
enter the vm again test the loop

00:23:38,799 --> 00:23:47,440
so here vm exit doesn't mean vm saddam

00:23:42,880 --> 00:23:51,840
it means vm cpu exists from vm

00:23:47,440 --> 00:23:51,840
for some reason

00:23:52,000 --> 00:23:58,559
one typical reason about io access

00:23:55,679 --> 00:24:00,240
i think this is also the primary way to

00:23:58,559 --> 00:24:04,080
stop vm disorder

00:24:00,240 --> 00:24:07,760
hardware uh in

00:24:04,080 --> 00:24:08,080
a vm uh environment uh there are several

00:24:07,760 --> 00:24:11,120
uh

00:24:08,080 --> 00:24:14,240
vms uh they may have

00:24:11,120 --> 00:24:18,480
uh they may share one real device so

00:24:14,240 --> 00:24:22,000
if they access a hardware

00:24:18,480 --> 00:24:25,440
it will exist and the hypervisor

00:24:22,000 --> 00:24:28,320
will management

00:24:25,440 --> 00:24:28,320
to the management

00:24:29,279 --> 00:24:36,240
here is a breakpoint uh

00:24:33,200 --> 00:24:39,520
and in the debugging

00:24:36,240 --> 00:24:42,080
we can see the call stack and

00:24:39,520 --> 00:24:42,080
source code

00:24:42,559 --> 00:24:47,039
actually there are two types io is

00:24:44,799 --> 00:24:47,039
called

00:24:51,120 --> 00:24:58,000
is created by the classic pc

00:24:54,240 --> 00:25:01,120
parts right now most

00:24:58,000 --> 00:25:06,080
i o is memory map l uh is more

00:25:01,120 --> 00:25:09,279
common and better performance

00:25:06,080 --> 00:25:14,320
so for uh hypervisor

00:25:09,279 --> 00:25:18,880
uh actually today we use two email

00:25:14,320 --> 00:25:22,400
in both kvm for both kvm and xam

00:25:18,880 --> 00:25:25,440
for uh qemu actually it will register

00:25:22,400 --> 00:25:29,120
uh l power uh function callbacks

00:25:25,440 --> 00:25:32,559
for io error part so

00:25:29,120 --> 00:25:33,600
actually when we uh create a new uh

00:25:32,559 --> 00:25:37,200
wordpress device

00:25:33,600 --> 00:25:40,400
uh to privately the main job is to do uh

00:25:37,200 --> 00:25:43,840
uh to to to develop the

00:25:40,400 --> 00:25:43,840
read write callback

00:25:44,799 --> 00:25:52,000
and in pvm there is a kvm io bus

00:25:48,720 --> 00:25:55,840
it will uh management all

00:25:52,000 --> 00:25:59,760
all i o ports and the register

00:25:55,840 --> 00:26:04,720
function callbacks um for example

00:25:59,760 --> 00:26:07,760
here here is it

00:26:04,720 --> 00:26:07,760
for port arrow

00:26:08,840 --> 00:26:16,240
then

00:26:11,520 --> 00:26:16,240
as clear it means

00:26:16,799 --> 00:26:23,600
cpu to the io access

00:26:20,159 --> 00:26:27,600
inside vm and exit

00:26:23,600 --> 00:26:30,640
after exit kvm will yield

00:26:27,600 --> 00:26:31,919
will handle the uses and invoke kvm

00:26:30,640 --> 00:26:34,960
internal

00:26:31,919 --> 00:26:38,480
but that's expansion by

00:26:34,960 --> 00:26:41,840
by intel uh and can

00:26:38,480 --> 00:26:44,080
uh came in here will uh

00:26:41,840 --> 00:26:44,080
uh

00:26:45,440 --> 00:26:48,559
will check the exact region and invoke

00:26:48,080 --> 00:26:53,200
the

00:26:48,559 --> 00:26:57,919
first pio function

00:26:53,200 --> 00:27:01,600
also then it will uh walk through the

00:26:57,919 --> 00:27:04,000
i o bus to find the

00:27:01,600 --> 00:27:04,880
read write callback and invoke the

00:27:04,000 --> 00:27:09,600
callback

00:27:04,880 --> 00:27:13,440
here we can see the part address in

00:27:09,600 --> 00:27:15,919
seven one actually is the classic cmos

00:27:13,440 --> 00:27:15,919
device

00:27:16,559 --> 00:27:23,039
there is a agriculture and

00:27:20,240 --> 00:27:23,039
cost cost

00:27:26,399 --> 00:27:33,200
then i will talk another example about

00:27:29,840 --> 00:27:36,480
my rematch i o here actually the

00:27:33,200 --> 00:27:42,399
ap is using mml

00:27:36,480 --> 00:27:42,399
is read callback and here is a

00:27:43,039 --> 00:27:48,399
call stack is in debugger we can see

00:27:50,240 --> 00:27:56,720
it's a right access and

00:27:53,600 --> 00:28:00,880
it invokes the kvm red mmol

00:27:56,720 --> 00:28:03,360
and it will dispatch to the ap function

00:28:00,880 --> 00:28:03,360
register

00:28:03,900 --> 00:28:06,979
[Music]

00:28:08,080 --> 00:28:14,840
we can see this a special address

00:28:11,120 --> 00:28:18,000
actually is a peak

00:28:14,840 --> 00:28:21,039
register in the epic spike

00:28:18,000 --> 00:28:24,480
it defines that

00:28:21,039 --> 00:28:28,240
linear advice range uh

00:28:24,480 --> 00:28:31,360
beneath for four giga bytes

00:28:28,240 --> 00:28:34,559
uh actually

00:28:31,360 --> 00:28:34,559
is reserved for ap

00:28:34,640 --> 00:28:37,919
so here are some useful breakpoints to

00:28:37,279 --> 00:28:42,840
do

00:28:37,919 --> 00:28:47,200
to develop kvm uh for reference

00:28:42,840 --> 00:28:51,120
um here is a quick uh real case

00:28:47,200 --> 00:28:55,440
actually when i turn off the

00:28:51,120 --> 00:28:58,559
target machine as you want to

00:28:55,440 --> 00:29:01,600
take a long long time

00:28:58,559 --> 00:29:05,520
as a power of

00:29:01,600 --> 00:29:07,760
a screen it seems calm somewhere

00:29:05,520 --> 00:29:09,760
research debugger is very hard to do the

00:29:07,760 --> 00:29:13,279
debug

00:29:09,760 --> 00:29:16,399
then i use the debugger to

00:29:13,279 --> 00:29:18,080
make to break it then the target breaks

00:29:16,399 --> 00:29:22,240
into the debugger

00:29:18,080 --> 00:29:26,159
i i checked the cpu0 firstly

00:29:22,240 --> 00:29:29,760
from the call stack it's servicing

00:29:26,159 --> 00:29:30,159
a reboot interrupt and from the source

00:29:29,760 --> 00:29:33,679
code

00:29:30,159 --> 00:29:33,679
of the rebooting draft

00:29:34,240 --> 00:29:40,960
it's doing a stop cpu actually

00:29:37,760 --> 00:29:44,399
a list function will trigger

00:29:40,960 --> 00:29:48,240
the ib video trigger ipi

00:29:44,399 --> 00:29:51,440
to let all other cpu

00:29:48,240 --> 00:29:55,200
response that command

00:29:51,440 --> 00:29:58,640
and we will switch to cpu2 we can see

00:29:55,200 --> 00:30:02,480
it means it might panic and

00:29:58,640 --> 00:30:02,480
it's in constantly

00:30:02,640 --> 00:30:09,120
so that's why the hand it means

00:30:05,840 --> 00:30:13,039
when we turn off ubuntu

00:30:09,120 --> 00:30:16,320
with some vm iran

00:30:13,039 --> 00:30:20,159
there are some special cars triggered

00:30:16,320 --> 00:30:23,279
panic of linux kernel

00:30:20,159 --> 00:30:28,320
with this tiny there is delay

00:30:23,279 --> 00:30:28,320
uh inside the kernel and called uh

00:30:28,559 --> 00:30:32,159
uh sfu is

00:30:32,640 --> 00:30:39,279
zero of about one minute

00:30:36,240 --> 00:30:39,279
uh delay

00:30:39,520 --> 00:30:46,080
so that's uh all about my uh

00:30:42,559 --> 00:30:49,120
talk um i'm very thankful uh

00:30:46,080 --> 00:30:52,559
uh for your uh attendance

00:30:49,120 --> 00:30:58,399
and see you

00:30:52,559 --> 00:30:58,399

YouTube URL: https://www.youtube.com/watch?v=9Ur8YLQcCTw


