Title: [2020] Intel VT Extensions to Enable Hardware Isolated VMs by Sean Christopherson
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Deploying virtual machines in an unsecured environment might expose a cloud tenant to risk of losing confidentiality and integrity of its sensitive data and IP, e.g. via attacks from privileged software, offline memory analysis, and active memory attacks at system interfaces. This talk will present an upcoming Intel technology to isolate VMs from many hardware and most software-based threats, by providing capabilities for confidentiality and integrity of memory, address translation, and cpu state, as well as secure interrupt and exception delivery, and remote attestation. Sean will provide an overview of the technology and its unique, novel features, and briefly cover the state of enabling in KVM and Qemu.

---

Sean Christopherson
Intel, Software Engineer
Portland, OR, USA

Sean is a reviewer for x86 KVM's VMX and MMU sub-sub-systems, and a prolific contributor to KVM. Sean is the lead KVM developer for SGX and TDX.
Captions: 
	00:00:01,040 --> 00:00:04,799
hi i'm sean christopherson from intel

00:00:02,960 --> 00:00:06,879
welcome to the 2020

00:00:04,799 --> 00:00:09,280
kvm forum presentation on intel trust

00:00:06,879 --> 00:00:11,920
domain extensions

00:00:09,280 --> 00:00:13,440
trust domain extensions or tdx is a set

00:00:11,920 --> 00:00:15,200
of hardware and software features and

00:00:13,440 --> 00:00:17,039
upcoming intel cpus that

00:00:15,200 --> 00:00:18,960
allow for the creation of hardware

00:00:17,039 --> 00:00:21,359
isolated virtual machines

00:00:18,960 --> 00:00:23,600
trust domains trust domains provide

00:00:21,359 --> 00:00:24,320
memory and cpu state confidentiality and

00:00:23,600 --> 00:00:26,960
integrity

00:00:24,320 --> 00:00:29,199
while allowing the csp or platform owner

00:00:26,960 --> 00:00:30,240
to maintain control of system resources

00:00:29,199 --> 00:00:33,120
and maintain

00:00:30,240 --> 00:00:34,320
platform integrity on the hardware side

00:00:33,120 --> 00:00:37,040
tdx adds

00:00:34,320 --> 00:00:39,120
extensions to intel's isa and to vmx

00:00:37,040 --> 00:00:40,719
intel's virtualization technology

00:00:39,120 --> 00:00:42,239
as well as memory encryption with

00:00:40,719 --> 00:00:44,640
integrity

00:00:42,239 --> 00:00:46,640
on the software side there is a new cpu

00:00:44,640 --> 00:00:48,559
attested software module

00:00:46,640 --> 00:00:49,840
that implements the bulk of the tdx

00:00:48,559 --> 00:00:51,760
functionality

00:00:49,840 --> 00:00:53,760
due to time constraints i'll mostly be

00:00:51,760 --> 00:00:56,079
focusing on the functional aspects of

00:00:53,760 --> 00:00:57,280
tdx as well as the impact on linux and

00:00:56,079 --> 00:00:59,760
kvm

00:00:57,280 --> 00:01:01,520
for an in-depth view of the security

00:00:59,760 --> 00:01:03,039
properties of tdx and things like

00:01:01,520 --> 00:01:04,479
promote attestation

00:01:03,039 --> 00:01:07,519
please see my colleagues presentation at

00:01:04,479 --> 00:01:07,519
the linux security summit

00:01:07,920 --> 00:01:11,439
on the hardware side there's a new

00:01:09,360 --> 00:01:13,840
architectural cpu mode called secure

00:01:11,439 --> 00:01:16,400
arbitration mode or seam

00:01:13,840 --> 00:01:17,680
seam is effectively a sub mode of vmx

00:01:16,400 --> 00:01:19,759
root mode

00:01:17,680 --> 00:01:22,000
it is slightly more privileged in that

00:01:19,759 --> 00:01:22,880
it has access to some new assets in the

00:01:22,000 --> 00:01:24,960
system

00:01:22,880 --> 00:01:28,080
but beyond those it is the same

00:01:24,960 --> 00:01:30,240
privilege level as vmx root mode

00:01:28,080 --> 00:01:31,920
c mode can only be entered through vmx

00:01:30,240 --> 00:01:35,520
root mode via new instruction

00:01:31,920 --> 00:01:37,600
scene call and then conversely can be

00:01:35,520 --> 00:01:40,960
only exited from seam root through a new

00:01:37,600 --> 00:01:42,479
instruction seam rat being a sub mode of

00:01:40,960 --> 00:01:44,960
vmx

00:01:42,479 --> 00:01:45,680
scene mode has full access to the vmx

00:01:44,960 --> 00:01:48,240
instructions

00:01:45,680 --> 00:01:50,479
so that it can create vmcs's manage

00:01:48,240 --> 00:01:52,640
vmcs's and ultimately run vms

00:01:50,479 --> 00:01:54,000
through those vmcs's through vm launch

00:01:52,640 --> 00:01:55,920
and vm resume

00:01:54,000 --> 00:01:57,759
transitioning between seam root and seam

00:01:55,920 --> 00:02:01,439
non-root

00:01:57,759 --> 00:02:02,719
on the memory side tdx builds on mkt me

00:02:01,439 --> 00:02:04,560
to add integrity

00:02:02,719 --> 00:02:06,880
where integrity in this context means

00:02:04,560 --> 00:02:08,879
that if software accesses

00:02:06,880 --> 00:02:11,120
integrity protected memory with the

00:02:08,879 --> 00:02:14,160
incorrect encryption key

00:02:11,120 --> 00:02:16,959
the hardware will poison memory

00:02:14,160 --> 00:02:18,800
and ultimately result in a recoverable

00:02:16,959 --> 00:02:20,640
machine check when that memory is next

00:02:18,800 --> 00:02:23,680
accessed

00:02:20,640 --> 00:02:26,319
tdx also partitions the mktme key id

00:02:23,680 --> 00:02:28,480
space into shared and private keys

00:02:26,319 --> 00:02:30,080
where share where private keys can only

00:02:28,480 --> 00:02:33,519
be used and programmed in

00:02:30,080 --> 00:02:35,920
c mode so for example the untrusted vmm

00:02:33,519 --> 00:02:37,840
cannot take the private key for a trust

00:02:35,920 --> 00:02:39,519
domain and shove it into its own page

00:02:37,840 --> 00:02:42,080
tables and read out

00:02:39,519 --> 00:02:43,519
the guest memory that operation will

00:02:42,080 --> 00:02:45,920
fail

00:02:43,519 --> 00:02:47,680
tdx also adds a shared bit in the guest

00:02:45,920 --> 00:02:50,400
physical address space

00:02:47,680 --> 00:02:51,280
this allows the guest the trust domain

00:02:50,400 --> 00:02:53,680
to select

00:02:51,280 --> 00:02:55,519
between shared and private memory and

00:02:53,680 --> 00:02:57,120
ultimately allows the guest to decide

00:02:55,519 --> 00:02:58,000
which memory is shared with the outside

00:02:57,120 --> 00:02:59,680
world and which

00:02:58,000 --> 00:03:01,120
memory remains private within the trust

00:02:59,680 --> 00:03:03,760
domain

00:03:01,120 --> 00:03:06,959
also related to shared memory a second

00:03:03,760 --> 00:03:09,840
ept pointer is added to the vmcs

00:03:06,959 --> 00:03:10,800
this allows the ept tables to be split

00:03:09,840 --> 00:03:12,319
into

00:03:10,800 --> 00:03:13,840
shared epg tables that are managed

00:03:12,319 --> 00:03:16,000
directly by the vmm

00:03:13,840 --> 00:03:17,760
and private or secure ept tables that

00:03:16,000 --> 00:03:20,959
are managed through the tdx

00:03:17,760 --> 00:03:23,599
module again the

00:03:20,959 --> 00:03:24,239
cpu switches on the shared bit in the

00:03:23,599 --> 00:03:26,000
gpa

00:03:24,239 --> 00:03:28,239
to select between shared and private so

00:03:26,000 --> 00:03:30,319
if this bit is set the cpu will

00:03:28,239 --> 00:03:32,720
start its ebt walk from the shared ebt

00:03:30,319 --> 00:03:34,640
pointer and if the shared bit is clear

00:03:32,720 --> 00:03:38,480
it will start its ept walk from the

00:03:34,640 --> 00:03:38,480
secure ept pointer in the vmcs

00:03:38,640 --> 00:03:42,720
on the software side there's a new intel

00:03:41,840 --> 00:03:45,840
developed module

00:03:42,720 --> 00:03:48,080
called the tdx module that runs in seam

00:03:45,840 --> 00:03:48,720
the tdx module is digitally signed and

00:03:48,080 --> 00:03:51,920
verified

00:03:48,720 --> 00:03:53,680
but not encrypted the tdx module is

00:03:51,920 --> 00:03:54,640
responsible for managing guest private

00:03:53,680 --> 00:03:56,239
state

00:03:54,640 --> 00:03:57,760
including context switching register

00:03:56,239 --> 00:04:01,120
state x save state

00:03:57,760 --> 00:04:03,519
and select msrs and the tdx module also

00:04:01,120 --> 00:04:07,120
directly controls the secure ept tables

00:04:03,519 --> 00:04:08,959
the vmcs for the trust domains and so on

00:04:07,120 --> 00:04:11,200
because the untrusted vmm does not have

00:04:08,959 --> 00:04:12,640
access to guest register state and guest

00:04:11,200 --> 00:04:15,519
memory

00:04:12,640 --> 00:04:16,400
traditional emulation of vm exiting

00:04:15,519 --> 00:04:19,199
instructions

00:04:16,400 --> 00:04:20,720
cannot occur without explicit asks from

00:04:19,199 --> 00:04:22,160
the guest so the guest needs to be

00:04:20,720 --> 00:04:24,479
enlightened to explicitly request

00:04:22,160 --> 00:04:26,400
emulation of an instruction

00:04:24,479 --> 00:04:28,160
to aid in that the tdx module will

00:04:26,400 --> 00:04:30,639
reflect any instruction that would

00:04:28,160 --> 00:04:32,560
otherwise vm exit

00:04:30,639 --> 00:04:34,000
into the guest as a virtualization

00:04:32,560 --> 00:04:35,840
exception

00:04:34,000 --> 00:04:37,840
so this isn't all instructions that vm

00:04:35,840 --> 00:04:38,560
exit only those that are not otherwise

00:04:37,840 --> 00:04:41,120
emulated

00:04:38,560 --> 00:04:42,320
or passed through by the tdx module an

00:04:41,120 --> 00:04:44,560
example being

00:04:42,320 --> 00:04:46,960
many cpuid leafs are emulated directly

00:04:44,560 --> 00:04:50,400
by the tdx module

00:04:46,960 --> 00:04:53,840
reflecting these exits as palm ves

00:04:50,400 --> 00:04:55,360
allows the guests to run with

00:04:53,840 --> 00:04:57,280
legacy code that has not been

00:04:55,360 --> 00:04:58,880
enlightened so for example a legacy

00:04:57,280 --> 00:05:01,520
driver that

00:04:58,880 --> 00:05:02,160
is executing instructions instead of

00:05:01,520 --> 00:05:05,680
directly

00:05:02,160 --> 00:05:08,240
doing hyper calls to request emulation

00:05:05,680 --> 00:05:08,960
the tdx module also exposes an abi to

00:05:08,240 --> 00:05:11,600
the vmm

00:05:08,960 --> 00:05:12,800
to create and manage trust domains this

00:05:11,600 --> 00:05:15,520
is analogous to

00:05:12,800 --> 00:05:17,360
how kvm exposes an api to user space to

00:05:15,520 --> 00:05:19,840
create and run vms

00:05:17,360 --> 00:05:22,479
so where user space makes syscalls to

00:05:19,840 --> 00:05:23,759
create vms add vcpus to the vms and run

00:05:22,479 --> 00:05:27,360
those vcpus

00:05:23,759 --> 00:05:29,840
the tdx module exposes avi to the vmm

00:05:27,360 --> 00:05:31,840
to create trust domains add vcpus and

00:05:29,840 --> 00:05:35,280
manage these using those trust domains

00:05:31,840 --> 00:05:38,880
and run those vcpus

00:05:35,280 --> 00:05:40,720
the vmm kvnr kvm in our case is still

00:05:38,880 --> 00:05:43,039
responsible for managing resources

00:05:40,720 --> 00:05:45,120
including memory scheduling

00:05:43,039 --> 00:05:46,400
and so this allows the vmm to maintain

00:05:45,120 --> 00:05:48,320
control over

00:05:46,400 --> 00:05:50,080
what memory gets assigned to a td and

00:05:48,320 --> 00:05:51,520
reclaim that memory

00:05:50,080 --> 00:05:53,280
but everything gets routed through the

00:05:51,520 --> 00:05:56,479
tdx module that would affect the

00:05:53,280 --> 00:05:58,319
security properties of a trust domain

00:05:56,479 --> 00:06:00,479
another notable software component in

00:05:58,319 --> 00:06:02,560
tdx is the seam loader

00:06:00,479 --> 00:06:04,560
which is an authenticated code module

00:06:02,560 --> 00:06:07,199
that is responsible for verifying and

00:06:04,560 --> 00:06:09,440
loading the tdx module

00:06:07,199 --> 00:06:10,240
once loaded the tdx module was protected

00:06:09,440 --> 00:06:13,440
via a new

00:06:10,240 --> 00:06:14,400
set of range registers the cmrr and this

00:06:13,440 --> 00:06:17,440
prevents

00:06:14,400 --> 00:06:19,520
code from outside of the scene module

00:06:17,440 --> 00:06:22,560
from poking into the scene module and

00:06:19,520 --> 00:06:24,000
reading or writing its code and data

00:06:22,560 --> 00:06:26,319
another responsibility of the seam

00:06:24,000 --> 00:06:27,199
loader is to configure the sim vmcs for

00:06:26,319 --> 00:06:29,680
sim call

00:06:27,199 --> 00:06:30,880
so underneath the hood same call is just

00:06:29,680 --> 00:06:34,400
a fancy variant

00:06:30,880 --> 00:06:34,960
of vm exit meaning that when simcall is

00:06:34,400 --> 00:06:38,800
exited

00:06:34,960 --> 00:06:41,759
is executed in vmx root it effectively

00:06:38,800 --> 00:06:42,400
is a vm exit from vmx root into seam

00:06:41,759 --> 00:06:46,240
root

00:06:42,400 --> 00:06:48,880
where seam root is the host and vmx root

00:06:46,240 --> 00:06:51,919
is the guest state so for example

00:06:48,880 --> 00:06:54,400
when seam loader loads the tdx module

00:06:51,919 --> 00:06:55,280
it programs the entry point of the tdx

00:06:54,400 --> 00:07:01,919
module

00:06:55,280 --> 00:07:02,880
into the host rip field of the siem vmcs

00:07:01,919 --> 00:07:06,000
at boot time

00:07:02,880 --> 00:07:09,039
the kernel invokes the seam loader acm

00:07:06,000 --> 00:07:11,840
which loads the tdx module into memory

00:07:09,039 --> 00:07:13,039
again protected by the cmrr and also

00:07:11,840 --> 00:07:16,319
does some configuration

00:07:13,039 --> 00:07:19,840
of the tdx module the boot

00:07:16,319 --> 00:07:22,240
then at run time kvm executes sim call

00:07:19,840 --> 00:07:23,120
to invoke apis provided by the tdx

00:07:22,240 --> 00:07:25,360
module

00:07:23,120 --> 00:07:28,800
and the tdx module executes seamret to

00:07:25,360 --> 00:07:31,680
return control back to kvm

00:07:28,800 --> 00:07:32,960
as mentioned earlier programming of the

00:07:31,680 --> 00:07:36,720
mktme engine

00:07:32,960 --> 00:07:38,560
is done by the tdx module for

00:07:36,720 --> 00:07:40,400
for trust domains to program up the

00:07:38,560 --> 00:07:42,080
private keys and these private keys are

00:07:40,400 --> 00:07:45,199
represented by the different color bands

00:07:42,080 --> 00:07:47,360
over on the left

00:07:45,199 --> 00:07:48,720
all data structures and private memory

00:07:47,360 --> 00:07:51,039
of a trust domain

00:07:48,720 --> 00:07:52,319
are encrypted with the private key

00:07:51,039 --> 00:07:56,000
associated with that

00:07:52,319 --> 00:07:59,759
td this includes the security pt tables

00:07:56,000 --> 00:08:03,199
the vmcs xsav state etc

00:07:59,759 --> 00:08:03,840
all the memory is conceptually owned by

00:08:03,199 --> 00:08:05,440
kbm

00:08:03,840 --> 00:08:07,039
in the sense that kvm does the

00:08:05,440 --> 00:08:09,520
management of that even though it can't

00:08:07,039 --> 00:08:11,360
directly access that memory so kvm

00:08:09,520 --> 00:08:14,160
controls the life cycle of the memory

00:08:11,360 --> 00:08:16,240
but can't directly access it or program

00:08:14,160 --> 00:08:16,240
it

00:08:17,280 --> 00:08:21,680
there are 40 and change apis provided by

00:08:20,479 --> 00:08:24,000
the tdx module

00:08:21,680 --> 00:08:24,800
that can be invoked by the vmm via

00:08:24,000 --> 00:08:26,720
seamcall

00:08:24,800 --> 00:08:28,319
and these are all the usual suspects of

00:08:26,720 --> 00:08:30,960
creating a vm

00:08:28,319 --> 00:08:31,919
adding memory to the vm configuring the

00:08:30,960 --> 00:08:34,159
key used to

00:08:31,919 --> 00:08:35,680
encrypt the vm's private memory adding

00:08:34,159 --> 00:08:38,000
vcpus

00:08:35,680 --> 00:08:40,640
adding entries into the ept tables and

00:08:38,000 --> 00:08:43,279
running the vm

00:08:40,640 --> 00:08:45,839
the tdx module also provides apis that

00:08:43,279 --> 00:08:48,560
can be executed by the guest

00:08:45,839 --> 00:08:50,320
these are done via td call a new seam

00:08:48,560 --> 00:08:52,800
only

00:08:50,320 --> 00:08:54,000
instruction tdcall is for all intents

00:08:52,800 --> 00:08:55,760
and purposes vm call

00:08:54,000 --> 00:08:58,080
just with a different exit code so that

00:08:55,760 --> 00:08:59,680
the tdx module can differentiate between

00:08:58,080 --> 00:09:03,360
enlightened code executing

00:08:59,680 --> 00:09:04,800
td call and legacy code executing a vm

00:09:03,360 --> 00:09:08,720
call

00:09:04,800 --> 00:09:12,000
this api allows the guest kernel

00:09:08,720 --> 00:09:12,880
to do some introspection on the platform

00:09:12,000 --> 00:09:14,959
capabilities

00:09:12,880 --> 00:09:17,839
except memory into its private memory

00:09:14,959 --> 00:09:18,959
space and to tunnel vm calls out to the

00:09:17,839 --> 00:09:23,839
untrusted vmm

00:09:18,959 --> 00:09:27,279
to request emulation for example

00:09:23,839 --> 00:09:29,680
in the kernel in kvm during boot the

00:09:27,279 --> 00:09:31,360
kernel will invoke the seam loader acm

00:09:29,680 --> 00:09:34,080
on the bsp

00:09:31,360 --> 00:09:35,120
and then configure the tdx module on all

00:09:34,080 --> 00:09:36,640
cpus

00:09:35,120 --> 00:09:39,839
and i'll talk about this a little bit

00:09:36,640 --> 00:09:42,320
later in a few slides

00:09:39,839 --> 00:09:43,040
on the kvm side of things the biggest

00:09:42,320 --> 00:09:46,000
change to

00:09:43,040 --> 00:09:48,720
existing code in terms of lines of code

00:09:46,000 --> 00:09:51,839
is to wrap the x86 callbacks in vmx

00:09:48,720 --> 00:09:55,200
to achieve vmx and tdx coexistence

00:09:51,839 --> 00:09:58,800
meaning a single instance of kvm

00:09:55,200 --> 00:10:00,800
can run vms and tds side by side

00:09:58,800 --> 00:10:02,399
and by wrapping those callbacks as

00:10:00,800 --> 00:10:03,440
opposed to introducing a new set of

00:10:02,399 --> 00:10:05,600
callbacks

00:10:03,440 --> 00:10:07,600
we can do so without any meaningful

00:10:05,600 --> 00:10:11,440
performance impact to vmx or

00:10:07,600 --> 00:10:13,839
svm for tdx we are able to reuse select

00:10:11,440 --> 00:10:16,839
portions of emx

00:10:13,839 --> 00:10:18,560
for example irq and nmi trampolines for

00:10:16,839 --> 00:10:20,560
handling

00:10:18,560 --> 00:10:22,160
hardware interrupts the post interrupt

00:10:20,560 --> 00:10:24,720
support in bmx

00:10:22,160 --> 00:10:26,880
the ebt entry points into the kvm mmu

00:10:24,720 --> 00:10:28,640
page vault and so on

00:10:26,880 --> 00:10:32,399
outside of vmx there's moderate

00:10:28,640 --> 00:10:34,560
factoring to x86 in common kvm

00:10:32,399 --> 00:10:35,760
we piggyback and repurpose the i o

00:10:34,560 --> 00:10:39,200
controls added by

00:10:35,760 --> 00:10:42,480
sev and also do some

00:10:39,200 --> 00:10:45,200
refactoring of the life cycle of vms as

00:10:42,480 --> 00:10:46,079
the ordering of api is dictated by the

00:10:45,200 --> 00:10:48,240
tdx module

00:10:46,079 --> 00:10:51,200
doesn't perfectly align with the

00:10:48,240 --> 00:10:54,160
existing code in kvm

00:10:51,200 --> 00:10:55,600
the most impactful changes for tdx are

00:10:54,160 --> 00:10:59,440
to support secure ept

00:10:55,600 --> 00:11:00,000
in kvm's mmu and we also likely need to

00:10:59,440 --> 00:11:02,160
modify

00:11:00,000 --> 00:11:03,200
the kernel mmu to support unmapping

00:11:02,160 --> 00:11:07,279
guest private memory

00:11:03,200 --> 00:11:07,279
which i'll talk about in a couple slides

00:11:08,560 --> 00:11:12,320
in kvm's mu to handle shared and private

00:11:11,279 --> 00:11:15,360
memory

00:11:12,320 --> 00:11:17,360
kvm aliases the shared gpas to private

00:11:15,360 --> 00:11:20,079
gpas in the mem slots

00:11:17,360 --> 00:11:22,000
which means that we effectively treat

00:11:20,079 --> 00:11:25,200
the shared bit as an attribute bit as

00:11:22,000 --> 00:11:27,839
opposed to a real physical address bit

00:11:25,200 --> 00:11:30,399
by doing so we can hide kvm can hide the

00:11:27,839 --> 00:11:34,160
shared bit from host user space

00:11:30,399 --> 00:11:37,839
for example when exiting to user space

00:11:34,160 --> 00:11:38,480
to handle emulated mmio kvm strips the

00:11:37,839 --> 00:11:40,880
shared bit

00:11:38,480 --> 00:11:41,680
so that the host user space only ever

00:11:40,880 --> 00:11:44,560
sees the

00:11:41,680 --> 00:11:46,160
kind of real or private gpas and this

00:11:44,560 --> 00:11:47,279
means that host user space doesn't have

00:11:46,160 --> 00:11:49,200
to be enlightened

00:11:47,279 --> 00:11:50,639
to understand the difference and doesn't

00:11:49,200 --> 00:11:52,639
have to be

00:11:50,639 --> 00:11:55,920
doesn't have to manage separate memory

00:11:52,639 --> 00:11:58,000
pools for private versus shared memory

00:11:55,920 --> 00:12:00,639
for security pt

00:11:58,000 --> 00:12:01,279
tdx adds several new hooks into kvm's

00:12:00,639 --> 00:12:04,480
mmu

00:12:01,279 --> 00:12:06,160
to insert zap and remove secure ept

00:12:04,480 --> 00:12:08,240
entries

00:12:06,160 --> 00:12:11,519
this is necessary because the security

00:12:08,240 --> 00:12:14,560
pt is managed through the tdx module

00:12:11,519 --> 00:12:16,399
so whereas a traditional ept management

00:12:14,560 --> 00:12:19,200
would involve reading and writing memory

00:12:16,399 --> 00:12:22,079
directly with tdx the security pt

00:12:19,200 --> 00:12:23,200
can only be managed by invoking sim

00:12:22,079 --> 00:12:25,440
calls to

00:12:23,200 --> 00:12:27,279
again insert zap and remove security pt

00:12:25,440 --> 00:12:29,519
entries

00:12:27,279 --> 00:12:31,279
kvm still does maintain a shadow copy of

00:12:29,519 --> 00:12:32,880
the screepi tables

00:12:31,279 --> 00:12:34,880
this is because simcall is quite

00:12:32,880 --> 00:12:37,839
expensive so

00:12:34,880 --> 00:12:38,079
if kvm were to invoke seamcall to read

00:12:37,839 --> 00:12:41,600
an

00:12:38,079 --> 00:12:43,360
ept entry for every level of an ebt walk

00:12:41,600 --> 00:12:47,200
handling page faults would be extremely

00:12:43,360 --> 00:12:50,160
costly in terms of latency

00:12:47,200 --> 00:12:51,360
these shadows are used anytime we're

00:12:50,160 --> 00:12:52,959
walking the page tables

00:12:51,360 --> 00:12:55,360
and so it's only when we actually need

00:12:52,959 --> 00:12:57,120
to modify an entry do we invoke the sim

00:12:55,360 --> 00:12:58,639
call

00:12:57,120 --> 00:13:01,600
and then secure apt also needs an

00:12:58,639 --> 00:13:04,959
additional api from the mmu

00:13:01,600 --> 00:13:08,480
to allow adding translations with out

00:13:04,959 --> 00:13:11,200
in without a page fault

00:13:08,480 --> 00:13:12,880
this is necessary because the only way

00:13:11,200 --> 00:13:15,680
to load non-zero memory

00:13:12,880 --> 00:13:16,720
into i guess private memory space aka

00:13:15,680 --> 00:13:20,160
load the initial

00:13:16,720 --> 00:13:23,839
memory image is to that can only

00:13:20,160 --> 00:13:26,320
be done before vcpus are runnable and to

00:13:23,839 --> 00:13:28,480
load non-zero memory the security pt

00:13:26,320 --> 00:13:31,519
translations for the associated guest

00:13:28,480 --> 00:13:33,440
private memory must be in place so long

00:13:31,519 --> 00:13:35,680
story short we have to have this qpt

00:13:33,440 --> 00:13:37,920
translations before we can run vcpus

00:13:35,680 --> 00:13:40,000
which conflicts with kvm's existing

00:13:37,920 --> 00:13:43,120
model of

00:13:40,000 --> 00:13:46,800
populating the ept tables on demand

00:13:43,120 --> 00:13:46,800
in response to page faults from the

00:13:46,839 --> 00:13:50,399
guest

00:13:48,079 --> 00:13:51,680
on the private memory side of things all

00:13:50,399 --> 00:13:54,240
private memory

00:13:51,680 --> 00:13:55,199
so all memory that can be stuffed into a

00:13:54,240 --> 00:13:57,360
handed over to

00:13:55,199 --> 00:13:59,120
the tdx module to create private memory

00:13:57,360 --> 00:14:00,560
for a guest must reside in a trust

00:13:59,120 --> 00:14:04,160
domain memory region

00:14:00,560 --> 00:14:06,320
or a tdmr a tdmr is just a software

00:14:04,160 --> 00:14:08,399
construct defined by tdx module that it

00:14:06,320 --> 00:14:11,440
uses to

00:14:08,399 --> 00:14:12,800
track metadata for system memory and it

00:14:11,440 --> 00:14:15,360
does this so that

00:14:12,800 --> 00:14:16,800
it can detect attempts from the vmm to

00:14:15,360 --> 00:14:20,880
do remapping attacks

00:14:16,800 --> 00:14:23,839
or to hand the same physical page

00:14:20,880 --> 00:14:26,399
twice to a td so for example mapping

00:14:23,839 --> 00:14:28,880
multiple gpas to a single

00:14:26,399 --> 00:14:29,440
hpa in the guest to try and attack the

00:14:28,880 --> 00:14:33,279
guests

00:14:29,440 --> 00:14:33,760
that way during boot the kernel adds all

00:14:33,279 --> 00:14:37,360
ram

00:14:33,760 --> 00:14:39,360
to the tdmr array and this allows kvm to

00:14:37,360 --> 00:14:41,680
allocate private memory

00:14:39,360 --> 00:14:44,079
um through the normal memory allocator

00:14:41,680 --> 00:14:45,680
apis which it then gifts to the tdx

00:14:44,079 --> 00:14:48,800
module

00:14:45,680 --> 00:14:50,240
so for example huge tlbfs transparent

00:14:48,800 --> 00:14:52,720
huge pages

00:14:50,240 --> 00:14:53,760
memfd anonymous memory etc are all

00:14:52,720 --> 00:14:55,279
naturally supported

00:14:53,760 --> 00:14:58,399
simply because we're routing through the

00:14:55,279 --> 00:15:01,519
normal memory allocator

00:14:58,399 --> 00:15:03,600
as for unmapping guest private memory

00:15:01,519 --> 00:15:04,639
because integrity failures result in

00:15:03,600 --> 00:15:06,959
machine checks

00:15:04,639 --> 00:15:08,160
leaving the guest private memory mapped

00:15:06,959 --> 00:15:09,839
in host user space

00:15:08,160 --> 00:15:12,079
would allow host user space to

00:15:09,839 --> 00:15:13,440
essentially induce machine checks out

00:15:12,079 --> 00:15:15,279
well

00:15:13,440 --> 00:15:17,600
while it's theoretically possible that

00:15:15,279 --> 00:15:19,199
we could harden the linux kernel

00:15:17,600 --> 00:15:21,120
to gracefully handle all these machine

00:15:19,199 --> 00:15:22,959
checks there's definitely

00:15:21,120 --> 00:15:24,240
a certain amount of risk associated with

00:15:22,959 --> 00:15:26,320
that approach

00:15:24,240 --> 00:15:28,800
so we're exploring unmapping guest

00:15:26,320 --> 00:15:31,120
private memory so that

00:15:28,800 --> 00:15:31,920
accesses from host user space to guest

00:15:31,120 --> 00:15:34,320
private memory

00:15:31,920 --> 00:15:37,440
would result in a page fault as opposed

00:15:34,320 --> 00:15:37,440
to a machine check

00:15:37,680 --> 00:15:44,079
for shared memory tdx allows

00:15:41,360 --> 00:15:45,360
the shared ept in tdx allows the

00:15:44,079 --> 00:15:48,560
untrusted vmm

00:15:45,360 --> 00:15:50,399
to configure select ept entries to

00:15:48,560 --> 00:15:52,880
generate ebt violation

00:15:50,399 --> 00:15:56,720
virtualization exceptions this means

00:15:52,880 --> 00:15:58,800
that instead of causing an ept vm exit

00:15:56,720 --> 00:16:00,399
faults to these addresses get reflected

00:15:58,800 --> 00:16:02,639
back to the guest as

00:16:00,399 --> 00:16:03,600
virtualization exceptions the primary

00:16:02,639 --> 00:16:06,079
use case for this

00:16:03,600 --> 00:16:07,040
is to reflect mmio addresses as pound

00:16:06,079 --> 00:16:09,199
bees

00:16:07,040 --> 00:16:10,160
so again if the guest kernel is not

00:16:09,199 --> 00:16:12,880
fully enlightened

00:16:10,160 --> 00:16:14,639
and has code that is accessing memory

00:16:12,880 --> 00:16:18,480
accessing memory mapped i o

00:16:14,639 --> 00:16:20,480
instead of doing direct td calls

00:16:18,480 --> 00:16:22,000
the hardware can reflect those accesses

00:16:20,480 --> 00:16:25,600
as pound v ease and then

00:16:22,000 --> 00:16:28,240
the palm ve handler and the guest can

00:16:25,600 --> 00:16:29,600
request emulation after decoding the

00:16:28,240 --> 00:16:32,639
instruction

00:16:29,600 --> 00:16:35,600
the catch with ept violation pound ve

00:16:32,639 --> 00:16:37,279
is that suppression is opt out meaning

00:16:35,600 --> 00:16:40,480
that

00:16:37,279 --> 00:16:42,480
not present ept entries if zeroed

00:16:40,480 --> 00:16:43,759
would get reflected to the guest as

00:16:42,480 --> 00:16:46,160
pound ves

00:16:43,759 --> 00:16:48,000
so from kvm mmu perspective this means

00:16:46,160 --> 00:16:50,320
we have to support a non-zero init value

00:16:48,000 --> 00:16:53,279
for ept entries

00:16:50,320 --> 00:16:54,079
this isn't a significant change in terms

00:16:53,279 --> 00:16:55,759
of

00:16:54,079 --> 00:16:59,360
lines of code but it's obviously

00:16:55,759 --> 00:17:01,360
touching a core part of the kvm mmu

00:16:59,360 --> 00:17:03,199
as for more advanced features tdx

00:17:01,360 --> 00:17:06,880
architecture supports large pages

00:17:03,199 --> 00:17:09,120
both two meg and one gig pages

00:17:06,880 --> 00:17:10,959
two meg pages we haven't yet implemented

00:17:09,120 --> 00:17:12,319
yet simply because we haven't gotten to

00:17:10,959 --> 00:17:14,559
them

00:17:12,319 --> 00:17:16,319
one gig pages on the other hand will

00:17:14,559 --> 00:17:17,600
require a little bit of complexity as

00:17:16,319 --> 00:17:19,520
there is some extra bookkeeping that

00:17:17,600 --> 00:17:22,000
needs to be done to

00:17:19,520 --> 00:17:24,000
first build the memory region using two

00:17:22,000 --> 00:17:25,360
meg pages and then promote to a one gig

00:17:24,000 --> 00:17:28,000
page

00:17:25,360 --> 00:17:29,440
tdx also supports host page migration so

00:17:28,000 --> 00:17:32,480
for example

00:17:29,440 --> 00:17:34,640
to support pneuma balancing as well as

00:17:32,480 --> 00:17:37,200
page promotion and demotion

00:17:34,640 --> 00:17:38,880
so for example page migration for

00:17:37,200 --> 00:17:40,400
transparent huge pages to collect

00:17:38,880 --> 00:17:47,360
fractured pages

00:17:40,400 --> 00:17:50,799
and promote them into a two make page

00:17:47,360 --> 00:17:53,039
stand is for linux and kvm and qmu

00:17:50,799 --> 00:17:53,840
the basic functionality in kvm is code

00:17:53,039 --> 00:17:57,679
complete

00:17:53,840 --> 00:17:59,679
where basic here means we can build a td

00:17:57,679 --> 00:18:01,440
with an enlightened guest virtual bios

00:17:59,679 --> 00:18:03,280
an enlightened kernel

00:18:01,440 --> 00:18:05,600
boot that guest kernel which in this

00:18:03,280 --> 00:18:09,200
case is linux guest

00:18:05,600 --> 00:18:10,880
and have full access to all verdio

00:18:09,200 --> 00:18:13,280
synthetic devices

00:18:10,880 --> 00:18:15,760
so we can access the network and disk

00:18:13,280 --> 00:18:18,160
etc all within the guest

00:18:15,760 --> 00:18:18,799
qmu is functional but not as code

00:18:18,160 --> 00:18:22,400
complete as

00:18:18,799 --> 00:18:25,679
kvm on the kvm side

00:18:22,400 --> 00:18:29,039
there are 40 plus files changed

00:18:25,679 --> 00:18:32,400
little over 6 000 new lines of code and

00:18:29,039 --> 00:18:34,480
700 changed lines of code give or take

00:18:32,400 --> 00:18:36,160
most of those changes being the wrapping

00:18:34,480 --> 00:18:39,280
of vmx's x86

00:18:36,160 --> 00:18:40,960
ops the code is publicly available on

00:18:39,280 --> 00:18:45,440
intel's github

00:18:40,960 --> 00:18:47,919
for kvm and qmu will follow shortly

00:18:45,440 --> 00:18:49,200
in the near future so effectively prior

00:18:47,919 --> 00:18:52,240
to upstreaming

00:18:49,200 --> 00:18:54,720
on our to-do list is large sage support

00:18:52,240 --> 00:18:55,440
especially two meg pages and host page

00:18:54,720 --> 00:18:57,120
migration

00:18:55,440 --> 00:18:58,559
and the unmapping of guest private

00:18:57,120 --> 00:19:01,360
memory

00:18:58,559 --> 00:19:02,400
longer term our top priority is live

00:19:01,360 --> 00:19:04,400
migration

00:19:02,400 --> 00:19:05,919
and we also have line of sight to nested

00:19:04,400 --> 00:19:07,919
virtualization

00:19:05,919 --> 00:19:09,520
nested in this case meaning nesting

00:19:07,919 --> 00:19:12,480
legacy vms inside

00:19:09,520 --> 00:19:13,520
trust domains we are not planning on

00:19:12,480 --> 00:19:16,000
supporting

00:19:13,520 --> 00:19:18,720
trust domains nested within within other

00:19:16,000 --> 00:19:18,720
trust domains

00:19:20,240 --> 00:19:23,679
last but not least if you want a bit of

00:19:22,640 --> 00:19:25,679
light reading

00:19:23,679 --> 00:19:28,480
the specs for tdx are available on

00:19:25,679 --> 00:19:28,480
intel's website

00:19:29,520 --> 00:19:36,880
thank you and hope you have a great

00:19:31,760 --> 00:19:36,880

YouTube URL: https://www.youtube.com/watch?v=ZngicM91ggo


