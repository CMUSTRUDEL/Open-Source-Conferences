Title: [2020] Challenges in Supporting Virtual CPU Hotplug on SoC Based Systems (like ARM64) by Salil Mehta
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Recently some attempts have been made to add support of the Virtual CPU Hotplug for ARM64 in QEMU virtualizer and Linux Guest Kernel but this has got mixed reviews from the community. Where some vendors have practical reasons to have such a support added, on the other hand some community members have apprehensions about its support. Idea about this talk is to:
1. Present the motivation of Virtual CPU Hotplug support on ARM64
2. Quick Overview
3. Problems in supporting Virtual CPU Hotplug 
    - ARM64 System Arch constraints? 
    - Host KVM
    - QEMU Virtualizer
    - Guest Kernel
4. Discussed Workarounds to the knowm limitation or problems
5. Existing work/attempts made to upstream (short mention)
6. Problems being faced in up-streaming.
7. Question/Feedback's
    - Feedback from people how to proceed and avoid the current deadlock.
    - Should Virtual CPU Hotplug support depend upon existence of Physical CPU Hotplug support?

---

Salil Mehta
Huawei Technologies (U.K) R&D Ltd., System Software Architect
Cambridge, UK

Salil works primarily on various system aspects of HiSilicon's ARM64 based Server chips. He is also a co-author and an official kernel maintainer of Huawei's on-chip integrated NIC driver HNS (HiSilicon Network Subsystem) across various multi-core server chips (Kunpeng920 and earlier) and has contributed at different phases of its development. His recent efforts have been towards adding the support of the Virtual CPU Hotplug on ARM64 based systems and enabling the support of the XDP (eXpress Data Path) in the HNS Driver for existing and upcoming Server Chips.
Captions: 
	00:00:07,919 --> 00:00:12,480
hello everyone

00:00:09,120 --> 00:00:14,160
um welcome to my presentation

00:00:12,480 --> 00:00:16,080
so the topic for the presentation is

00:00:14,160 --> 00:00:18,960
challenges in supporting virtual cpu hot

00:00:16,080 --> 00:00:22,240
plug in shock-based systems like arm64

00:00:18,960 --> 00:00:23,119
well uh i am system software architect

00:00:22,240 --> 00:00:27,840
working at

00:00:23,119 --> 00:00:31,439
huawei technologies cambridge uk uh uk

00:00:27,840 --> 00:00:33,920
and um

00:00:31,439 --> 00:00:36,000
primarily in my past i've done a lot of

00:00:33,920 --> 00:00:40,960
networking stuff

00:00:36,000 --> 00:00:43,440
dealt with system aspects of it

00:00:40,960 --> 00:00:44,000
here in huawei i'm also official

00:00:43,440 --> 00:00:47,360
maintainer

00:00:44,000 --> 00:00:48,960
of their networking driver hns across

00:00:47,360 --> 00:00:50,550
different socks

00:00:48,960 --> 00:00:52,079
and

00:00:50,550 --> 00:00:55,039
[Music]

00:00:52,079 --> 00:00:56,960
in my recent attempt beside this virtual

00:00:55,039 --> 00:01:00,000
cp hot plug i've been

00:00:56,960 --> 00:01:04,719
also involved in

00:01:00,000 --> 00:01:04,719
enabling xdp on hns driver

00:01:06,720 --> 00:01:12,159
agenda for today's presentation is

00:01:10,640 --> 00:01:14,400
in the recent past there have been

00:01:12,159 --> 00:01:17,040
attempts made to add the support of the

00:01:14,400 --> 00:01:20,240
virtual cpr plug for arm 64

00:01:17,040 --> 00:01:22,320
based systems in chemo and linux guess

00:01:20,240 --> 00:01:25,520
we have received some sort of a mixed

00:01:22,320 --> 00:01:26,960
reviews from the community

00:01:25,520 --> 00:01:29,520
though some vendors have practical

00:01:26,960 --> 00:01:32,720
reasons to have such a support added

00:01:29,520 --> 00:01:33,840
uh but a few of the community members

00:01:32,720 --> 00:01:37,520
have an improvement

00:01:33,840 --> 00:01:40,720
apprehension as well to support it

00:01:37,520 --> 00:01:42,399
so this presentation is an attempt to

00:01:40,720 --> 00:01:44,479
highlight the key issues in supporting

00:01:42,399 --> 00:01:48,880
the virtual cpr plug

00:01:44,479 --> 00:01:48,880
feature for arm64 based socks

00:01:50,159 --> 00:01:54,880
outline so um

00:01:53,200 --> 00:01:56,399
the entire presentation has been divided

00:01:54,880 --> 00:01:59,439
into some sort of a very quick

00:01:56,399 --> 00:02:01,439
overview uh and then we'll go through

00:01:59,439 --> 00:02:03,439
the known challenges across the system

00:02:01,439 --> 00:02:06,159
architecture kvm host

00:02:03,439 --> 00:02:08,160
hemovirtualizer guest kernel and we'll

00:02:06,159 --> 00:02:11,920
discuss the work arounds

00:02:08,160 --> 00:02:14,000
uh some implementation

00:02:11,920 --> 00:02:15,760
attempts have been made in the past and

00:02:14,000 --> 00:02:17,680
the recent times as well

00:02:15,760 --> 00:02:19,120
we'll see the problem being faced in

00:02:17,680 --> 00:02:20,800
them and then summary

00:02:19,120 --> 00:02:24,879
we'll discuss about the future work and

00:02:20,800 --> 00:02:24,879
then we'll open the session for the q a

00:02:25,520 --> 00:02:29,040
so why do we need a cp hot plug in

00:02:27,760 --> 00:02:32,959
general what we know

00:02:29,040 --> 00:02:35,519
is it can be used for provisioning

00:02:32,959 --> 00:02:36,000
while progress name rather so for

00:02:35,519 --> 00:02:40,000
example

00:02:36,000 --> 00:02:42,239
in case of pre-provisioned uh resources

00:02:40,000 --> 00:02:44,000
but which are auto scaled uh so

00:02:42,239 --> 00:02:47,440
orchestration frameworks like

00:02:44,000 --> 00:02:48,400
k8s uh can use a feature called as

00:02:47,440 --> 00:02:50,959
vertical part or

00:02:48,400 --> 00:02:52,480
scaling in which they can add up a

00:02:50,959 --> 00:02:55,120
certain cpu resources

00:02:52,480 --> 00:02:56,400
and remove them dynamically depending

00:02:55,120 --> 00:02:58,000
upon their occupancy

00:02:56,400 --> 00:03:00,080
for example during the night server

00:02:58,000 --> 00:03:01,840
systems are less occupant

00:03:00,080 --> 00:03:03,510
so they might like to remove certain

00:03:01,840 --> 00:03:05,519
cpus

00:03:03,510 --> 00:03:07,920
[Music]

00:03:05,519 --> 00:03:08,800
and it can also be done for the load

00:03:07,920 --> 00:03:10,560
balancing

00:03:08,800 --> 00:03:12,640
the thing is the on-demand provisioning

00:03:10,560 --> 00:03:14,159
so a very good example is a capacity of

00:03:12,640 --> 00:03:16,159
grid on demand in which

00:03:14,159 --> 00:03:19,040
certain kind of customers would like to

00:03:16,159 --> 00:03:22,000
add uh

00:03:19,040 --> 00:03:22,800
or increase the capacity later on once

00:03:22,000 --> 00:03:25,519
their

00:03:22,800 --> 00:03:26,159
business have grown in so now they have

00:03:25,519 --> 00:03:29,280
kind of

00:03:26,159 --> 00:03:33,120
uh they can afford

00:03:29,280 --> 00:03:35,280
that kind of resources so

00:03:33,120 --> 00:03:36,720
it is used for that purposes as well so

00:03:35,280 --> 00:03:39,599
you need a basic

00:03:36,720 --> 00:03:41,920
cpu feature to be able to support this

00:03:39,599 --> 00:03:46,080
particular demand

00:03:41,920 --> 00:03:49,120
and then it can be used to isolate

00:03:46,080 --> 00:03:51,120
the error causing cpus uh

00:03:49,120 --> 00:03:53,280
the offending cpus within the system due

00:03:51,120 --> 00:03:56,959
to the errors identified due to errors

00:03:53,280 --> 00:03:57,760
and uh this guy this might be required

00:03:56,959 --> 00:03:59,920
just because

00:03:57,760 --> 00:04:01,360
uh to stop the propagation of the errors

00:03:59,920 --> 00:04:03,280
within the system

00:04:01,360 --> 00:04:04,480
but i'm not very sure this is uh

00:04:03,280 --> 00:04:06,080
something which makes sense in the

00:04:04,480 --> 00:04:10,080
virtual world

00:04:06,080 --> 00:04:12,239
but anyways um another

00:04:10,080 --> 00:04:14,640
reason could be for onlining and

00:04:12,239 --> 00:04:17,600
offlining the cpus for the suspend

00:04:14,640 --> 00:04:19,040
resume this kind of support has been

00:04:17,600 --> 00:04:21,600
there for the arm 64-base

00:04:19,040 --> 00:04:23,440
systems for quite long and this is based

00:04:21,600 --> 00:04:27,280
upon pesci

00:04:23,440 --> 00:04:30,080
calls uh cp of base art plug

00:04:27,280 --> 00:04:33,360
and you could see this support is

00:04:30,080 --> 00:04:36,720
already there as part of their

00:04:33,360 --> 00:04:39,120
kernel changes

00:04:36,720 --> 00:04:40,720
for quite long and has been there

00:04:39,120 --> 00:04:42,320
there's better for detail which i've

00:04:40,720 --> 00:04:44,000
mentioned as part of the links you can

00:04:42,320 --> 00:04:45,520
see below and you would like to read

00:04:44,000 --> 00:04:49,840
them

00:04:45,520 --> 00:04:49,840
i'll just skip for now

00:04:50,960 --> 00:04:56,000
well there's certain even sequences

00:04:54,240 --> 00:04:59,040
which happens while you plug in

00:04:56,000 --> 00:05:03,360
the cpu and while you unplug the

00:04:59,040 --> 00:05:07,440
cpu so this is for the virtual cpr plug

00:05:03,360 --> 00:05:10,720
so um i've just added these diagrams

00:05:07,440 --> 00:05:11,600
as a completeness these are very well

00:05:10,720 --> 00:05:13,840
understood

00:05:11,600 --> 00:05:15,680
uh framework and has already been part

00:05:13,840 --> 00:05:18,320
of the kernel for quite long

00:05:15,680 --> 00:05:19,600
uh i'll just kind of scratch through it

00:05:18,320 --> 00:05:21,919
uh to get

00:05:19,600 --> 00:05:24,400
uh things started so we can see

00:05:21,919 --> 00:05:27,600
different layers like uh

00:05:24,400 --> 00:05:30,080
hardware uh host kvm kimono

00:05:27,600 --> 00:05:30,880
then acp interface and the guest kernel

00:05:30,080 --> 00:05:35,120
whenever the

00:05:30,880 --> 00:05:37,600
cpu is plugged or unplugged the

00:05:35,120 --> 00:05:39,440
event gets exchanged from the chemo

00:05:37,600 --> 00:05:40,240
through the sap interface to the guest

00:05:39,440 --> 00:05:44,960
kernel

00:05:40,240 --> 00:05:47,039
so certain kind of events get

00:05:44,960 --> 00:05:48,080
sent by the guest os to the queue as

00:05:47,039 --> 00:05:51,360
well through the

00:05:48,080 --> 00:05:54,240
acpa cpu control device

00:05:51,360 --> 00:05:55,680
and for the events uh from the kimo to

00:05:54,240 --> 00:05:59,840
the guest os

00:05:55,680 --> 00:06:01,840
ged device is used uh to intimidate

00:05:59,840 --> 00:06:03,039
the kind of even which is uh which has

00:06:01,840 --> 00:06:06,319
happened

00:06:03,039 --> 00:06:06,800
so uh eventual result of these event is

00:06:06,319 --> 00:06:10,000
to

00:06:06,800 --> 00:06:11,120
kind of uh know first of all what event

00:06:10,000 --> 00:06:14,240
has happened and then

00:06:11,120 --> 00:06:14,560
uh to associate for example in case of

00:06:14,240 --> 00:06:17,840
the

00:06:14,560 --> 00:06:20,880
hot plug the

00:06:17,840 --> 00:06:21,440
the physical id which in arm term we

00:06:20,880 --> 00:06:24,080
call

00:06:21,440 --> 00:06:25,440
it as a mp idea to that of the logical

00:06:24,080 --> 00:06:29,360
cpu id

00:06:25,440 --> 00:06:33,039
and of course um the

00:06:29,360 --> 00:06:36,720
in case of the reverse that is unplug

00:06:33,039 --> 00:06:38,880
you uh you identify

00:06:36,720 --> 00:06:40,479
the cpu which is being unplugged and

00:06:38,880 --> 00:06:42,080
then you try to offline that particular

00:06:40,479 --> 00:06:45,199
cpu and

00:06:42,080 --> 00:06:45,680
and the eject action take place so i

00:06:45,199 --> 00:06:48,720
would

00:06:45,680 --> 00:06:49,280
i won't be going into detail and said as

00:06:48,720 --> 00:06:51,919
i said

00:06:49,280 --> 00:06:52,800
uh these are well understood uh concepts

00:06:51,919 --> 00:06:55,840
and

00:06:52,800 --> 00:06:58,080
my idea about representation is uh

00:06:55,840 --> 00:06:58,880
to assume you know already these things

00:06:58,080 --> 00:07:01,199
and

00:06:58,880 --> 00:07:03,599
i'm gonna present further the known

00:07:01,199 --> 00:07:07,360
challenges

00:07:03,599 --> 00:07:10,800
so in the in the in the previous past

00:07:07,360 --> 00:07:16,319
uh there have been certain attempts what

00:07:10,800 --> 00:07:19,520
uh uh what have been kind of

00:07:16,319 --> 00:07:22,000
you know attempts to uh add up

00:07:19,520 --> 00:07:22,720
this virtual cpr product support but

00:07:22,000 --> 00:07:24,960
there have been

00:07:22,720 --> 00:07:27,360
uh some problems what we have faced

00:07:24,960 --> 00:07:29,360
across different areas so

00:07:27,360 --> 00:07:30,270
in case of the arm64 system architecture

00:07:29,360 --> 00:07:32,240
first of all

00:07:30,270 --> 00:07:36,000
[Music]

00:07:32,240 --> 00:07:37,280
we know that the system architecture

00:07:36,000 --> 00:07:40,639
assets does not have

00:07:37,280 --> 00:07:42,720
any concept of physical cp hot plug

00:07:40,639 --> 00:07:44,560
there is no specification as such from

00:07:42,720 --> 00:07:46,800
the arm which defines

00:07:44,560 --> 00:07:48,319
any standard way to realize a virtual

00:07:46,800 --> 00:07:50,639
cpr plug either

00:07:48,319 --> 00:07:53,199
because you don't have a physical cpr

00:07:50,639 --> 00:07:55,919
plug specification

00:07:53,199 --> 00:07:57,840
on the other hand the arm components

00:07:55,919 --> 00:07:59,919
like gig

00:07:57,840 --> 00:08:02,560
also have not been designed to realize a

00:07:59,919 --> 00:08:04,879
physical cpu output capability

00:08:02,560 --> 00:08:12,800
as such gig requires all the cpus to be

00:08:04,879 --> 00:08:15,680
present at initialization

00:08:12,800 --> 00:08:16,319
now known challenges within the host kvm

00:08:15,680 --> 00:08:18,479
uh

00:08:16,319 --> 00:08:19,840
kvm also requires all the vcps to be

00:08:18,479 --> 00:08:24,400
created during the vmware

00:08:19,840 --> 00:08:27,440
time um now this is something

00:08:24,400 --> 00:08:29,440
which you can say uh is

00:08:27,440 --> 00:08:31,840
kind of reflecting what the system

00:08:29,440 --> 00:08:35,760
architecture requires in

00:08:31,840 --> 00:08:35,760
but because

00:08:36,080 --> 00:08:40,159
it it should have all the vcps created

00:08:39,440 --> 00:08:43,599
and

00:08:40,159 --> 00:08:46,800
it has some sort of uh

00:08:43,599 --> 00:08:50,800
you know effects on other components

00:08:46,800 --> 00:08:54,240
which are part of the kvm for example uh

00:08:50,800 --> 00:08:56,800
the vcpu each vcpu will have

00:08:54,240 --> 00:08:58,720
v git related resources initialized and

00:08:56,800 --> 00:09:01,920
fixed during the creation

00:08:58,720 --> 00:09:04,480
uh and um various uh

00:09:01,920 --> 00:09:04,959
vga per cpu static data structures for

00:09:04,480 --> 00:09:09,040
example

00:09:04,959 --> 00:09:12,080
they need to be initialized early

00:09:09,040 --> 00:09:14,320
some config of the related

00:09:12,080 --> 00:09:15,440
uh private interrupts for example sds

00:09:14,320 --> 00:09:17,440
and ppis

00:09:15,440 --> 00:09:19,200
they also need to be present at the time

00:09:17,440 --> 00:09:21,839
when the cpus are created

00:09:19,200 --> 00:09:22,640
so they get initialized at that time

00:09:21,839 --> 00:09:26,240
right

00:09:22,640 --> 00:09:27,600
and also uh any resources like memory

00:09:26,240 --> 00:09:30,959
regions related

00:09:27,600 --> 00:09:34,399
redistributors they also need to be uh

00:09:30,959 --> 00:09:36,000
done uh at the vmware time right so for

00:09:34,399 --> 00:09:38,800
example whenever

00:09:36,000 --> 00:09:40,800
those the vcpus are getting created at

00:09:38,800 --> 00:09:43,279
that time basically all these

00:09:40,800 --> 00:09:44,880
resources member regions data structures

00:09:43,279 --> 00:09:47,920
get initialized

00:09:44,880 --> 00:09:52,000
and uh you cannot change them later on

00:09:47,920 --> 00:09:54,720
so uh it's all related to

00:09:52,000 --> 00:09:56,480
the vcpus which should be great which

00:09:54,720 --> 00:09:58,959
should be present

00:09:56,480 --> 00:10:02,000
and get should get created all during

00:09:58,959 --> 00:10:02,000
the vm in a time

00:10:02,480 --> 00:10:06,240
once the vcps have been created in the

00:10:04,320 --> 00:10:08,000
host kvm their destruction is also not

00:10:06,240 --> 00:10:10,160
reported yet this is not something which

00:10:08,000 --> 00:10:13,279
is on 64 specific but

00:10:10,160 --> 00:10:15,120
intel uh architecture also has got the

00:10:13,279 --> 00:10:17,680
same limitation in the kvm

00:10:15,120 --> 00:10:19,440
but there are workarounds around this so

00:10:17,680 --> 00:10:20,640
this is not a big challenge but

00:10:19,440 --> 00:10:23,360
people have already solved this

00:10:20,640 --> 00:10:23,360
particular part

00:10:25,330 --> 00:10:30,839
[Music]

00:10:27,360 --> 00:10:33,760
also we know that generally

00:10:30,839 --> 00:10:35,680
the the

00:10:33,760 --> 00:10:38,000
mpidr is something which uniquely

00:10:35,680 --> 00:10:41,440
identify the vcp in the system

00:10:38,000 --> 00:10:44,800
and for the virtual world

00:10:41,440 --> 00:10:46,959
as of now this particular value

00:10:44,800 --> 00:10:50,160
of the resistor is getting derived and

00:10:46,959 --> 00:10:52,399
set by the kvm

00:10:50,160 --> 00:10:53,519
ideally it should be a responsibility of

00:10:52,399 --> 00:10:57,440
the user space

00:10:53,519 --> 00:10:57,440
instead of the kvm and

00:10:58,480 --> 00:11:01,600
right now it is being derived using the

00:11:00,160 --> 00:11:04,880
vcpid uh

00:11:01,600 --> 00:11:07,120
which is sent by the chemo to the kvm

00:11:04,880 --> 00:11:09,279
and it does some sort of mapping as you

00:11:07,120 --> 00:11:13,519
can see uh with the diagram

00:11:09,279 --> 00:11:15,839
and derives the the mpidr value

00:11:13,519 --> 00:11:17,600
which gets programmed into vap idea or

00:11:15,839 --> 00:11:21,360
register

00:11:17,600 --> 00:11:21,360
for that particular cpu

00:11:26,079 --> 00:11:31,920
so at the kimo level um

00:11:30,000 --> 00:11:34,079
because there's a limitation imposed by

00:11:31,920 --> 00:11:36,240
the v-gic at the host kbm level

00:11:34,079 --> 00:11:37,920
given must create and initialize all the

00:11:36,240 --> 00:11:41,120
vcpus at the word mark

00:11:37,920 --> 00:11:44,000
in a time now uh

00:11:41,120 --> 00:11:45,040
this has got uh a ripple effect kind of

00:11:44,000 --> 00:11:48,240
thing because

00:11:45,040 --> 00:11:51,360
you need to do this thing must then

00:11:48,240 --> 00:11:54,079
ensure all uh the complete

00:11:51,360 --> 00:11:56,079
initialization of the git as well

00:11:54,079 --> 00:11:57,279
this includes initialization of all the

00:11:56,079 --> 00:12:01,519
redistributors

00:11:57,279 --> 00:12:03,680
its related to all possible vcpus

00:12:01,519 --> 00:12:05,360
realization of vcpus and its threads in

00:12:03,680 --> 00:12:07,360
keeping might not be desirable for

00:12:05,360 --> 00:12:11,839
possible vcpus which are

00:12:07,360 --> 00:12:11,839
in disabled state

00:12:20,480 --> 00:12:24,000
also the unwiring of the interrupt

00:12:22,240 --> 00:12:25,200
setups between the vcpus

00:12:24,000 --> 00:12:27,920
and the gig requires further

00:12:25,200 --> 00:12:30,959
consideration in qmm

00:12:27,920 --> 00:12:31,600
and this is something which is not

00:12:30,959 --> 00:12:34,720
present

00:12:31,600 --> 00:12:36,639
by default uh in the chemo so

00:12:34,720 --> 00:12:38,480
as part of the changes of the vc virtual

00:12:36,639 --> 00:12:40,720
cpu hot plug this has this support has

00:12:38,480 --> 00:12:43,519
been added

00:12:40,720 --> 00:12:44,880
for arm 64 kimo lacks support to

00:12:43,519 --> 00:12:48,160
correctly specify the

00:12:44,880 --> 00:12:51,279
cpu topology that is on the basis of saw

00:12:48,160 --> 00:12:51,279
cluster course threads

00:12:51,360 --> 00:12:55,200
this is required to uniquely identify a

00:12:53,040 --> 00:12:58,240
vcp being plugged or unplugged

00:12:55,200 --> 00:13:01,839
and uh ideally

00:12:58,240 --> 00:13:05,519
this should be mapped to something

00:13:01,839 --> 00:13:10,000
uh like mpidr mpid

00:13:05,519 --> 00:13:10,000
is unique remember and

00:13:11,279 --> 00:13:16,560
it's kind of broken

00:13:14,399 --> 00:13:17,600
for a physical system it does have the

00:13:16,560 --> 00:13:19,760
affinity

00:13:17,600 --> 00:13:20,959
but that affinity is something which we

00:13:19,760 --> 00:13:24,000
cannot use

00:13:20,959 --> 00:13:27,200
as suggested by our people to uh get the

00:13:24,000 --> 00:13:27,760
cpu topology information so it it has

00:13:27,200 --> 00:13:30,800
got

00:13:27,760 --> 00:13:34,639
no relation as such uh we can uh

00:13:30,800 --> 00:13:37,279
say it but uh at the virtual world

00:13:34,639 --> 00:13:39,199
within the kimo we do require some sort

00:13:37,279 --> 00:13:41,199
of association between

00:13:39,199 --> 00:13:42,720
what we are trying to plug in and where

00:13:41,199 --> 00:13:46,000
we are trying to plug in

00:13:42,720 --> 00:13:47,279
and correlated with mp in dir using some

00:13:46,000 --> 00:13:49,760
sort of a mapping

00:13:47,279 --> 00:13:51,360
so perhaps this needs to be done and

00:13:49,760 --> 00:13:54,079
discussed

00:13:51,360 --> 00:13:54,800
also chemo labs the support of ppt table

00:13:54,079 --> 00:13:56,800
which

00:13:54,800 --> 00:14:02,000
shall be used to pass on the vcpu

00:13:56,800 --> 00:14:05,279
topology to the guest model

00:14:02,000 --> 00:14:07,199
now within the guest kennel uh any arm

00:14:05,279 --> 00:14:08,800
64 architecture related changes done

00:14:07,199 --> 00:14:11,199
inside the kernel for the guest

00:14:08,800 --> 00:14:13,360
should seamlessly run on the host kernel

00:14:11,199 --> 00:14:15,199
now this is a big requirement because

00:14:13,360 --> 00:14:17,279
it has got a lot of implications which

00:14:15,199 --> 00:14:19,279
means that

00:14:17,279 --> 00:14:20,320
you cannot place any kind of switches

00:14:19,279 --> 00:14:22,800
within the

00:14:20,320 --> 00:14:23,920
guest kernel to distinguish whether this

00:14:22,800 --> 00:14:26,800
is a

00:14:23,920 --> 00:14:28,000
this is the code running as part of the

00:14:26,800 --> 00:14:31,839
guest kernel

00:14:28,000 --> 00:14:35,440
and is related to the cp hot plug

00:14:31,839 --> 00:14:38,160
for for the virtual cpus

00:14:35,440 --> 00:14:38,160
now um

00:14:38,720 --> 00:14:41,839
vcpu as such vcpr plug might benefit

00:14:41,199 --> 00:14:43,279
from some

00:14:41,839 --> 00:14:44,880
some sort of standardization in the

00:14:43,279 --> 00:14:48,240
architecture and firmware

00:14:44,880 --> 00:14:51,360
is api level if

00:14:48,240 --> 00:14:52,959
we can do that and any future

00:14:51,360 --> 00:14:56,560
specification along

00:14:52,959 --> 00:14:59,839
physical cpr plugins must

00:14:56,560 --> 00:15:01,040
not be duly constrained by vcp hot plug

00:14:59,839 --> 00:15:04,399
interface defined now

00:15:01,040 --> 00:15:07,279
uh so whatever we do

00:15:04,399 --> 00:15:09,040
as part of the standardization uh

00:15:07,279 --> 00:15:10,880
because currently physical cpu plug

00:15:09,040 --> 00:15:12,560
doesn't exist suppose in future it comes

00:15:10,880 --> 00:15:15,680
and that shouldn't contradict

00:15:12,560 --> 00:15:17,920
uh to what you have done and

00:15:15,680 --> 00:15:19,680
should pay attention to that so that is

00:15:17,920 --> 00:15:21,920
just a kind of consideration we need to

00:15:19,680 --> 00:15:26,560
paint

00:15:21,920 --> 00:15:28,480
that's a kind of a challenge as well

00:15:26,560 --> 00:15:29,839
uh there have been certain uh workaround

00:15:28,480 --> 00:15:31,120
which has been discussed for the

00:15:29,839 --> 00:15:34,079
for the challenges what we just

00:15:31,120 --> 00:15:37,120
discussed so various workarounds

00:15:34,079 --> 00:15:40,240
um which have been discussed within the

00:15:37,120 --> 00:15:43,279
community across the years

00:15:40,240 --> 00:15:46,480
are something like uh

00:15:43,279 --> 00:15:47,199
all possible vcu's create are created

00:15:46,480 --> 00:15:49,519
within

00:15:47,199 --> 00:15:52,000
the kvm and chemo at the vm

00:15:49,519 --> 00:15:54,320
initialization

00:15:52,000 --> 00:15:56,800
so it's kind of pre-creation of all of

00:15:54,320 --> 00:15:59,600
the vcpus

00:15:56,800 --> 00:16:02,800
but the keemum only realizes possible

00:15:59,600 --> 00:16:05,440
vcpus that are not disabled

00:16:02,800 --> 00:16:06,480
now remember the realization of vcpu

00:16:05,440 --> 00:16:09,839
means

00:16:06,480 --> 00:16:13,519
that the threads also get spawned right

00:16:09,839 --> 00:16:16,399
but uh as per the new changes

00:16:13,519 --> 00:16:19,120
the threads are not spawned uh for the

00:16:16,399 --> 00:16:20,160
disabled vcpus so we save a bit in that

00:16:19,120 --> 00:16:23,199
as well

00:16:20,160 --> 00:16:26,240
and that just kind of helps in in

00:16:23,199 --> 00:16:28,880
just fitting the changes as part of

00:16:26,240 --> 00:16:30,480
neatly within the qm and the way the qm

00:16:28,880 --> 00:16:32,560
works as of now for the

00:16:30,480 --> 00:16:33,920
normal case as well without cpu hot plug

00:16:32,560 --> 00:16:35,920
case as well

00:16:33,920 --> 00:16:38,240
now kimo pre initializes weak

00:16:35,920 --> 00:16:38,959
distributors for all the possible vcpus

00:16:38,240 --> 00:16:42,399
in the v8

00:16:38,959 --> 00:16:45,120
now i remember because the v-gec uh

00:16:42,399 --> 00:16:46,000
has got this requirement that this needs

00:16:45,120 --> 00:16:48,720
to be done

00:16:46,000 --> 00:16:48,720
as part of the

00:16:49,360 --> 00:16:52,639
initializes as part of the vma net uh

00:16:52,079 --> 00:16:56,880
process

00:16:52,639 --> 00:16:58,720
right so chemo does that and

00:16:56,880 --> 00:17:00,639
all the distributors are created along

00:16:58,720 --> 00:17:04,260
with the vcpus

00:17:00,639 --> 00:17:07,299
uh at the pma time and

00:17:04,260 --> 00:17:07,299
[Music]

00:17:11,120 --> 00:17:19,199
yeah and of course

00:17:14,240 --> 00:17:22,559
because the redistributors are

00:17:19,199 --> 00:17:25,360
like for each of the vcpu so

00:17:22,559 --> 00:17:26,000
they're kind of both present together at

00:17:25,360 --> 00:17:27,919
the vmware

00:17:26,000 --> 00:17:29,200
time so there have been certain

00:17:27,919 --> 00:17:31,840
discussions uh

00:17:29,200 --> 00:17:32,480
which are related to these you can refer

00:17:31,840 --> 00:17:36,000
to below

00:17:32,480 --> 00:17:36,000
i have just provided them the links

00:17:37,280 --> 00:17:41,730
well um kimu

00:17:40,400 --> 00:17:44,960
and host kvm

00:17:41,730 --> 00:17:47,520
[Music]

00:17:44,960 --> 00:17:48,559
is enhanced to support use space should

00:17:47,520 --> 00:17:50,559
be enhanced to

00:17:48,559 --> 00:17:53,280
support the user space configuration of

00:17:50,559 --> 00:17:54,960
the mpidr value of the vcpu so

00:17:53,280 --> 00:17:56,320
right now as discussed in the previous

00:17:54,960 --> 00:17:59,360
slides this is the

00:17:56,320 --> 00:18:02,480
being done by the kvm and it derives the

00:17:59,360 --> 00:18:04,640
value of mpidr using the vcpu id

00:18:02,480 --> 00:18:06,640
but ideally there should be a for the

00:18:04,640 --> 00:18:09,840
virtualized case there should be a

00:18:06,640 --> 00:18:11,200
user space thing and kvm shouldn't get

00:18:09,840 --> 00:18:14,480
involved

00:18:11,200 --> 00:18:18,400
in the derivation of the np idr value

00:18:14,480 --> 00:18:18,400
except for

00:18:18,960 --> 00:18:23,919
configuring that value within the vmp

00:18:22,400 --> 00:18:27,200
idr

00:18:23,919 --> 00:18:31,280
register which is a privileged operation

00:18:27,200 --> 00:18:34,400
uh also on vcpu hot unplug

00:18:31,280 --> 00:18:37,840
emu parks and powers down the vcpu so

00:18:34,400 --> 00:18:39,919
remember that there was a limitation

00:18:37,840 --> 00:18:41,840
within the kvm that it you can create

00:18:39,919 --> 00:18:43,120
the bcps but you cannot destroy them

00:18:41,840 --> 00:18:46,080
which is

00:18:43,120 --> 00:18:46,720
kind of a limitation which is uh also

00:18:46,080 --> 00:18:49,840
present in

00:18:46,720 --> 00:18:51,360
intel so the common framework which has

00:18:49,840 --> 00:18:54,799
been added as part of the

00:18:51,360 --> 00:18:55,200
key move is to park down the vcpus which

00:18:54,799 --> 00:18:56,960
have been

00:18:55,200 --> 00:18:58,240
unplugged rather than destroying them at

00:18:56,960 --> 00:19:01,360
the kvm level

00:18:58,240 --> 00:19:02,720
so at kvm they always remain alive uh

00:19:01,360 --> 00:19:04,799
just that

00:19:02,720 --> 00:19:07,120
they are brought down to the low power

00:19:04,799 --> 00:19:07,120
mode

00:19:07,280 --> 00:19:10,320
now kimu provides the complete ambiguity

00:19:09,600 --> 00:19:12,320
table

00:19:10,320 --> 00:19:14,160
including all possible vcpu interfaces

00:19:12,320 --> 00:19:15,840
and it's redistributed to the guest

00:19:14,160 --> 00:19:17,280
kernel this information is used by the

00:19:15,840 --> 00:19:21,520
guest kernel

00:19:17,280 --> 00:19:23,280
to basically initialize

00:19:21,520 --> 00:19:24,310
its data structures for the base

00:19:23,280 --> 00:19:26,160
addresses

00:19:24,310 --> 00:19:29,840
[Music]

00:19:26,160 --> 00:19:32,640
and other parameters

00:19:29,840 --> 00:19:33,760
uh at the boot time guest channel uses

00:19:32,640 --> 00:19:35,280
info from the email

00:19:33,760 --> 00:19:37,120
table to size its various data

00:19:35,280 --> 00:19:39,039
structures including initialization of

00:19:37,120 --> 00:19:41,280
redistributors as i said

00:19:39,039 --> 00:19:42,480
with all possible vcpus so

00:19:41,280 --> 00:19:44,160
redistributors

00:19:42,480 --> 00:19:45,919
also start to exist within the guest

00:19:44,160 --> 00:19:48,880
kernel just that

00:19:45,919 --> 00:19:49,200
they don't have their vcpu instances for

00:19:48,880 --> 00:19:52,720
the

00:19:49,200 --> 00:19:53,520
disabled possible vcpus which gets

00:19:52,720 --> 00:19:57,120
created

00:19:53,520 --> 00:19:59,760
and reflected while the cpu is unplugged

00:19:57,120 --> 00:19:59,760
or unplugged

00:20:00,559 --> 00:20:05,039
now uh these are the recent and the

00:20:03,520 --> 00:20:08,000
earlier attempts

00:20:05,039 --> 00:20:11,039
which have been made very recent were

00:20:08,000 --> 00:20:14,480
the ones done in the june by me

00:20:11,039 --> 00:20:17,600
so uh both the kernel changes that is

00:20:14,480 --> 00:20:20,799
the guest changes and the virtual

00:20:17,600 --> 00:20:24,960
uh cpu cpr changes for the chemo

00:20:20,799 --> 00:20:28,240
uh uh were floated uh

00:20:24,960 --> 00:20:28,960
the the host kernel didn't require any

00:20:28,240 --> 00:20:30,880
change

00:20:28,960 --> 00:20:32,559
and these were found to be working as

00:20:30,880 --> 00:20:35,520
such uh without the change

00:20:32,559 --> 00:20:36,880
any change within the host kernel though

00:20:35,520 --> 00:20:40,080
there's one change like

00:20:36,880 --> 00:20:41,760
uh ability to configure the mp id and

00:20:40,080 --> 00:20:43,679
from the user space that might

00:20:41,760 --> 00:20:45,919
require a bit of a change but as such

00:20:43,679 --> 00:20:48,960
these are pretty agnostic of the host

00:20:45,919 --> 00:20:52,720
so all the workarounds are take care

00:20:48,960 --> 00:20:56,159
of the limitations what we just uh

00:20:52,720 --> 00:20:58,000
kind of discussed uh within the

00:20:56,159 --> 00:20:59,200
within the chemo as well as the guest

00:20:58,000 --> 00:21:00,840
kernel and

00:20:59,200 --> 00:21:02,640
the changes in the guest candle are

00:21:00,840 --> 00:21:06,159
non-destructive

00:21:02,640 --> 00:21:10,720
but again since

00:21:06,159 --> 00:21:13,520
they are kind of done in a way

00:21:10,720 --> 00:21:14,799
and we don't have a specification so

00:21:13,520 --> 00:21:17,039
that can be a concern

00:21:14,799 --> 00:21:18,000
we'll see it later so you might like to

00:21:17,039 --> 00:21:21,760
go through these

00:21:18,000 --> 00:21:23,280
references so what are the problems

00:21:21,760 --> 00:21:26,880
being phased in upstreaming now

00:21:23,280 --> 00:21:27,520
uh arm64 system architecture does not

00:21:26,880 --> 00:21:30,480
supports

00:21:27,520 --> 00:21:31,679
physical cpu hot plug as we know now due

00:21:30,480 --> 00:21:33,600
to the absence of the suitable

00:21:31,679 --> 00:21:34,960
specification

00:21:33,600 --> 00:21:36,960
they have been concerned which have been

00:21:34,960 --> 00:21:39,760
raised to avoid

00:21:36,960 --> 00:21:41,679
any divergent system architectures being

00:21:39,760 --> 00:21:43,280
invented by different vendors so it's

00:21:41,679 --> 00:21:45,120
not just

00:21:43,280 --> 00:21:46,640
one vendor who is trying to support this

00:21:45,120 --> 00:21:49,039
thing maybe other people might come with

00:21:46,640 --> 00:21:52,000
their own ideas and

00:21:49,039 --> 00:21:53,360
it might happen if if there's no

00:21:52,000 --> 00:21:58,080
standardization of this

00:21:53,360 --> 00:22:01,360
then the things can get bit messy

00:21:58,080 --> 00:22:02,320
and probably this has left patches

00:22:01,360 --> 00:22:06,080
stranded

00:22:02,320 --> 00:22:07,840
uh across multiple attempts

00:22:06,080 --> 00:22:09,520
few patches cannot proceed till the time

00:22:07,840 --> 00:22:11,039
the guests know patches

00:22:09,520 --> 00:22:13,120
are duly considered by the kennel

00:22:11,039 --> 00:22:16,960
community which currently

00:22:13,120 --> 00:22:19,039
we feel that it has not been done

00:22:16,960 --> 00:22:20,720
and so i would like to request the

00:22:19,039 --> 00:22:23,600
community for more reviews and

00:22:20,720 --> 00:22:23,600
involvement in this

00:22:24,880 --> 00:22:29,280
so just to recap the summary and what is

00:22:27,679 --> 00:22:32,400
the way forwards

00:22:29,280 --> 00:22:33,840
um ac based support of the virtual cpu

00:22:32,400 --> 00:22:35,840
hot plug feature is a much

00:22:33,840 --> 00:22:38,159
requested feature for the use cases

00:22:35,840 --> 00:22:40,640
stated earlier in the slides

00:22:38,159 --> 00:22:42,640
and as you can see we have posed a

00:22:40,640 --> 00:22:44,960
practical implementation

00:22:42,640 --> 00:22:46,480
but uh it seemed to be making a little

00:22:44,960 --> 00:22:49,280
progress in upstreaming

00:22:46,480 --> 00:22:50,880
uh for the reason which again we have

00:22:49,280 --> 00:22:54,159
discussed

00:22:50,880 --> 00:22:56,080
uh so the key thing is how do we

00:22:54,159 --> 00:22:59,360
overcome the resistance

00:22:56,080 --> 00:23:00,720
uh to implementing a virtual only

00:22:59,360 --> 00:23:02,720
feature

00:23:00,720 --> 00:23:04,960
while minimizing the possible clashes

00:23:02,720 --> 00:23:06,240
with the say for example any potential

00:23:04,960 --> 00:23:09,520
future

00:23:06,240 --> 00:23:12,480
physical equivalent if it ever will come

00:23:09,520 --> 00:23:13,600
but we need to take care of it now and

00:23:12,480 --> 00:23:15,520
would some sort of a minimal

00:23:13,600 --> 00:23:17,440
specification to ensure

00:23:15,520 --> 00:23:18,640
some sort of a consistency of

00:23:17,440 --> 00:23:21,039
implementation

00:23:18,640 --> 00:23:22,240
in the virtual case specifically elevate

00:23:21,039 --> 00:23:26,000
such concerns

00:23:22,240 --> 00:23:26,000
and appears how to do this

00:23:29,919 --> 00:23:34,480
the future work is which is left is

00:23:32,880 --> 00:23:38,000
around the light migration support

00:23:34,480 --> 00:23:38,960
support of the hot plug with pneuma cpu

00:23:38,000 --> 00:23:42,240
topology

00:23:38,960 --> 00:23:44,400
as mentioned earlier pptt support

00:23:42,240 --> 00:23:45,679
to hand over the right vcp topology info

00:23:44,400 --> 00:23:49,360
to the guest

00:23:45,679 --> 00:23:51,120
test cases lots of docs to explain

00:23:49,360 --> 00:23:52,720
because there are a lot of workarounds

00:23:51,120 --> 00:23:55,840
so products require a proper

00:23:52,720 --> 00:23:55,840
documentation for this

00:23:58,400 --> 00:24:01,600
well i'd like to take this opportunity

00:24:00,640 --> 00:24:03,440
to thank

00:24:01,600 --> 00:24:04,640
all the individuals who have worked for

00:24:03,440 --> 00:24:07,760
this particular

00:24:04,640 --> 00:24:10,400
topic in the past and have discussed

00:24:07,760 --> 00:24:12,720
and their ideas i'm just trying to carry

00:24:10,400 --> 00:24:16,640
forward the past button to me

00:24:12,720 --> 00:24:18,799
and actual work have been done

00:24:16,640 --> 00:24:20,799
much earlier the concepts i just tried

00:24:18,799 --> 00:24:24,080
to implement

00:24:20,799 --> 00:24:27,919
uh the ideas which were well discussed

00:24:24,080 --> 00:24:31,120
and uh and to demonstrate that

00:24:27,919 --> 00:24:35,039
those were achievable and actually those

00:24:31,120 --> 00:24:39,279
work so anyone that i've missed

00:24:35,039 --> 00:24:41,520
into my list uh uh please forgive me

00:24:39,279 --> 00:24:43,760
as i said it's it's a tribute to

00:24:41,520 --> 00:24:47,360
everyone who was involved

00:24:43,760 --> 00:24:51,039
in this effort with this

00:24:47,360 --> 00:24:54,159
i like to open the session for any q a

00:24:51,039 --> 00:24:57,200
so uh and also i would like to thank you

00:24:54,159 --> 00:25:00,240
for listening patiently to my

00:24:57,200 --> 00:25:02,880
uh session thank you so much

00:25:00,240 --> 00:25:15,600
and i'm open for any questions from here

00:25:02,880 --> 00:25:15,600

YouTube URL: https://www.youtube.com/watch?v=o8nZcUwgXmw


