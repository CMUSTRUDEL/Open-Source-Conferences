Title: [2020] Extremely Fast and Efficient NFV with Unikraft by Sharan Santhanami
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	DPDK is the golden standard for high performance networking, but that performance comes at the cost of high memory consumption, high CPU utilization, and long start-up times. In this talk we introduce a highly efficient port of DPDK to Unikraft, a Linux Foundation open source project consisting of a micro-library operating system and build system that is able to seamlessly generate purpose-built KVM virtual machines. In this talk we will introduce Unikraft and the DPDK port, and show how these make a powerful combination towards building truly high performance, efficient and quick-to-boot virtual functions. In particular, we will show throughput numbers equivalent to Linux while consuming a fraction of the memory it uses, using a single CPU core as opposed to several ones, and significantly reducing boot times on multiple VMMs. Finally, we will show a brief demo of Unikraft in action.

---

Sharan Santhanam
NEC Laboratories Europe GmbH, Software Specialist
Captions: 
	00:00:06,160 --> 00:00:09,840
good morning

00:00:07,440 --> 00:00:11,200
i am sharon santana today i am here to

00:00:09,840 --> 00:00:13,599
present our work

00:00:11,200 --> 00:00:16,080
on building extremely fast and efficient

00:00:13,599 --> 00:00:18,000
industries with unica

00:00:16,080 --> 00:00:19,520
before we start on this topic let me

00:00:18,000 --> 00:00:21,680
introduce myself

00:00:19,520 --> 00:00:23,039
i work as a software specialist at nec

00:00:21,680 --> 00:00:24,880
laboratories europe

00:00:23,039 --> 00:00:26,400
and i am part of a team of eight

00:00:24,880 --> 00:00:27,920
researchers

00:00:26,400 --> 00:00:31,199
who are working as a part of the systems

00:00:27,920 --> 00:00:33,520
group in our lab one of the projects

00:00:31,199 --> 00:00:35,600
within our group is unicraft and this

00:00:33,520 --> 00:00:38,960
work contributes towards the port of

00:00:35,600 --> 00:00:41,280
tpdk on top of ut craft message

00:00:38,960 --> 00:00:42,480
so for today's talk we have structured

00:00:41,280 --> 00:00:44,800
it in such a way

00:00:42,480 --> 00:00:46,160
that we begin to discuss what is

00:00:44,800 --> 00:00:49,280
existing out there

00:00:46,160 --> 00:00:52,480
then we move on to introduce unicraft

00:00:49,280 --> 00:00:54,239
the motivation behind unicraft and

00:00:52,480 --> 00:00:56,480
how everything is structured within your

00:00:54,239 --> 00:00:58,719
aircraft then we talk about

00:00:56,480 --> 00:01:00,000
how to integrate dpdk libraries on top

00:00:58,719 --> 00:01:02,079
of unicraft

00:01:00,000 --> 00:01:04,080
then we speak about the functionalities

00:01:02,079 --> 00:01:05,840
which unicraft should provide to support

00:01:04,080 --> 00:01:07,840
these dpdk libraries

00:01:05,840 --> 00:01:09,200
and we make a performance evaluation

00:01:07,840 --> 00:01:11,600
between a linux vm

00:01:09,200 --> 00:01:13,280
as well as a unigraphed image and we

00:01:11,600 --> 00:01:15,600
discuss about the synergies of the two

00:01:13,280 --> 00:01:18,640
projects unicraft and dpdk

00:01:15,600 --> 00:01:20,400
and uh how it fits into this ecosystem

00:01:18,640 --> 00:01:23,439
message

00:01:20,400 --> 00:01:24,560
so when we began what we had in our mind

00:01:23,439 --> 00:01:26,960
is something like the

00:01:24,560 --> 00:01:28,640
diagram in the slide where we have a

00:01:26,960 --> 00:01:30,960
guest operating system

00:01:28,640 --> 00:01:32,400
and we have kvm as a hypervisor and the

00:01:30,960 --> 00:01:34,720
host and the guest

00:01:32,400 --> 00:01:36,479
interacting on one another through a

00:01:34,720 --> 00:01:37,119
para virtualized framework like first

00:01:36,479 --> 00:01:39,759
item

00:01:37,119 --> 00:01:41,040
and then this part and then this uh

00:01:39,759 --> 00:01:43,360
framework was further

00:01:41,040 --> 00:01:44,399
uh optimized with something called v

00:01:43,360 --> 00:01:47,360
hostnet

00:01:44,399 --> 00:01:48,799
to to further uh improve the performance

00:01:47,360 --> 00:01:51,360
of this communication channel

00:01:48,799 --> 00:01:52,159
and dpdk came along with his own b host

00:01:51,360 --> 00:01:53,520
user

00:01:52,159 --> 00:01:56,079
which further enhances this

00:01:53,520 --> 00:01:58,159
communication in our bottle exists

00:01:56,079 --> 00:01:59,119
but one part of this picture which has

00:01:58,159 --> 00:02:01,439
been left

00:01:59,119 --> 00:02:02,640
untouched is the guest operating system

00:02:01,439 --> 00:02:04,320
message

00:02:02,640 --> 00:02:06,079
we believe we can do better with the

00:02:04,320 --> 00:02:08,479
guest operating system we believe we can

00:02:06,079 --> 00:02:10,800
specialize the guest operating system

00:02:08,479 --> 00:02:12,879
where is wherein we take in only the

00:02:10,800 --> 00:02:14,640
required components needed by the

00:02:12,879 --> 00:02:17,680
application into the guest operating

00:02:14,640 --> 00:02:20,400
system thereby we optimize it for

00:02:17,680 --> 00:02:21,440
something like a boot time or image size

00:02:20,400 --> 00:02:24,080
or even memory

00:02:21,440 --> 00:02:25,440
memory requirements for an application

00:02:24,080 --> 00:02:27,440
and

00:02:25,440 --> 00:02:29,120
if we are only running specific

00:02:27,440 --> 00:02:31,120
application within against operating

00:02:29,120 --> 00:02:32,640
system we could also reconsider the

00:02:31,120 --> 00:02:34,480
necessity for having

00:02:32,640 --> 00:02:36,800
kernel and user space separation within

00:02:34,480 --> 00:02:39,360
the guest operating system message

00:02:36,800 --> 00:02:41,200
thus if you're focused on a particular

00:02:39,360 --> 00:02:44,319
use case in mind

00:02:41,200 --> 00:02:47,760
then unicorn seems to be a good fit

00:02:44,319 --> 00:02:49,599
for that specific image as such

00:02:47,760 --> 00:02:51,120
so if we were to make a comparison

00:02:49,599 --> 00:02:54,000
between a virtual machine

00:02:51,120 --> 00:02:55,200
image and that of a unikernel image it

00:02:54,000 --> 00:02:56,319
looks like something like something like

00:02:55,200 --> 00:02:58,159
this

00:02:56,319 --> 00:02:59,920
uh and in a virtual machine image you

00:02:58,159 --> 00:03:02,159
have a number of applications

00:02:59,920 --> 00:03:03,280
and we have a large number of library

00:03:02,159 --> 00:03:06,560
pool and

00:03:03,280 --> 00:03:08,800
we have a single monolithic kernel

00:03:06,560 --> 00:03:10,560
from an application an application needs

00:03:08,800 --> 00:03:12,879
only some subset

00:03:10,560 --> 00:03:15,519
of these libraries from the library pool

00:03:12,879 --> 00:03:18,239
and some specific kernel components

00:03:15,519 --> 00:03:19,040
contrast this with that of a unicorn

00:03:18,239 --> 00:03:21,599
image

00:03:19,040 --> 00:03:23,120
a unicorn image is built with one

00:03:21,599 --> 00:03:26,159
purpose in mind

00:03:23,120 --> 00:03:26,959
thereby you only need an image which has

00:03:26,159 --> 00:03:29,760
the specific

00:03:26,959 --> 00:03:31,760
libraries and specific kernel components

00:03:29,760 --> 00:03:34,799
with the application

00:03:31,760 --> 00:03:37,360
just to summarize a unicorn image what a

00:03:34,799 --> 00:03:40,000
unikernel image is a purpose built image

00:03:37,360 --> 00:03:40,640
with a thin layer of the kernel embedded

00:03:40,000 --> 00:03:43,120
into the

00:03:40,640 --> 00:03:44,560
application message thereby the

00:03:43,120 --> 00:03:47,200
application

00:03:44,560 --> 00:03:48,319
as such has to as to select which are

00:03:47,200 --> 00:03:50,080
all the libraries

00:03:48,319 --> 00:03:52,080
it needs and which are all the kernel

00:03:50,080 --> 00:03:55,040
components it needs

00:03:52,080 --> 00:03:57,439
since the kernel is embedded into the

00:03:55,040 --> 00:03:59,760
application image as such

00:03:57,439 --> 00:04:01,920
the necessity for kernel and user space

00:03:59,760 --> 00:04:04,480
separation is no longer needed

00:04:01,920 --> 00:04:06,000
and whatever was a syscall in a virtual

00:04:04,480 --> 00:04:09,040
machine image now becomes function

00:04:06,000 --> 00:04:11,040
called within the unicode images

00:04:09,040 --> 00:04:13,280
and since we are picking and choosing

00:04:11,040 --> 00:04:16,160
components needed by the application

00:04:13,280 --> 00:04:16,639
you can specialize the entire software

00:04:16,160 --> 00:04:18,560
stack

00:04:16,639 --> 00:04:20,479
right from the kernel to the libraries

00:04:18,560 --> 00:04:22,079
to the application message

00:04:20,479 --> 00:04:24,960
where do we realize the potential of a

00:04:22,079 --> 00:04:27,040
unicode we can realize it in terms of

00:04:24,960 --> 00:04:28,560
faster boot times because it needs only

00:04:27,040 --> 00:04:31,280
a few milliseconds to go to your

00:04:28,560 --> 00:04:32,960
unicorn whereas it takes few seconds for

00:04:31,280 --> 00:04:35,120
a virtual machine image

00:04:32,960 --> 00:04:36,479
just lower memory footprints for example

00:04:35,120 --> 00:04:37,280
a unique kernel needs only a few

00:04:36,479 --> 00:04:39,840
megabytes in

00:04:37,280 --> 00:04:40,720
size whereas a typical virtual machine

00:04:39,840 --> 00:04:43,440
needs few

00:04:40,720 --> 00:04:46,160
few hundred megabytes or a few kilo few

00:04:43,440 --> 00:04:48,960
gigabytes in size of memory

00:04:46,160 --> 00:04:50,880
and also it has a higher deployment

00:04:48,960 --> 00:04:54,080
density so it's easier to pack

00:04:50,880 --> 00:04:56,639
a lot of unicorns and its performance is

00:04:54,080 --> 00:04:59,840
comparable to that of a regular

00:04:56,639 --> 00:05:02,160
virtual machine image and also since we

00:04:59,840 --> 00:05:03,759
are only making what is necessary for an

00:05:02,160 --> 00:05:05,759
application into the final

00:05:03,759 --> 00:05:07,360
image it has a reduced attack surface

00:05:05,759 --> 00:05:10,639
because it contains what

00:05:07,360 --> 00:05:12,479
an application needs and also since

00:05:10,639 --> 00:05:13,759
the since it has only those necessary

00:05:12,479 --> 00:05:16,560
components it is

00:05:13,759 --> 00:05:18,720
as a smaller trusted computing base as

00:05:16,560 --> 00:05:18,720
such

00:05:18,800 --> 00:05:23,600
so a unicorn looks quite promising right

00:05:21,600 --> 00:05:25,600
it has good performance it has

00:05:23,600 --> 00:05:27,440
quite a nice isolation features in

00:05:25,600 --> 00:05:30,560
sensation time and image size

00:05:27,440 --> 00:05:32,880
but why the question is why has sin why

00:05:30,560 --> 00:05:35,199
hasn't it been adopted more often

00:05:32,880 --> 00:05:37,039
there are a number of reasons for it

00:05:35,199 --> 00:05:39,039
building a unicorn is quite tedious it

00:05:37,039 --> 00:05:40,080
sinks a lot of development cycles to get

00:05:39,039 --> 00:05:42,800
it right

00:05:40,080 --> 00:05:44,240
and since you are doing it for each of

00:05:42,800 --> 00:05:45,600
the specific application you keep

00:05:44,240 --> 00:05:47,600
repeating the same process

00:05:45,600 --> 00:05:49,360
again and again and it becomes a bit

00:05:47,600 --> 00:05:51,919
tedious as such

00:05:49,360 --> 00:05:52,400
and the other part is specialization is

00:05:51,919 --> 00:05:55,680
quite

00:05:52,400 --> 00:05:57,680
hard to build as such because

00:05:55,680 --> 00:06:00,319
uh when you're specializing you need a

00:05:57,680 --> 00:06:02,479
way to establish dependencies

00:06:00,319 --> 00:06:03,759
between the different components in the

00:06:02,479 --> 00:06:05,520
library pool and the different

00:06:03,759 --> 00:06:07,840
components in the kernel

00:06:05,520 --> 00:06:08,960
and the kernel and this and these

00:06:07,840 --> 00:06:11,600
components

00:06:08,960 --> 00:06:12,240
need to have a well-defined interface as

00:06:11,600 --> 00:06:14,400
such

00:06:12,240 --> 00:06:17,120
so bringing up this interface definition

00:06:14,400 --> 00:06:20,160
is also quite a difficult task

00:06:17,120 --> 00:06:21,039
also since you want to run off the shelf

00:06:20,160 --> 00:06:23,360
application

00:06:21,039 --> 00:06:25,199
on top of these libraries you need to

00:06:23,360 --> 00:06:26,639
make sure that you stick to a standard

00:06:25,199 --> 00:06:28,720
interface so these off-the-shelf

00:06:26,639 --> 00:06:31,199
applications can run on your

00:06:28,720 --> 00:06:35,199
on your library tool and and on your

00:06:31,199 --> 00:06:37,680
kernel components as such

00:06:35,199 --> 00:06:38,880
so with this we decided to come up with

00:06:37,680 --> 00:06:41,759
a tool

00:06:38,880 --> 00:06:43,360
where it makes it easier to build unique

00:06:41,759 --> 00:06:46,080
errors as such

00:06:43,360 --> 00:06:47,600
so with that in mind we had these common

00:06:46,080 --> 00:06:50,560
objectives in mind

00:06:47,600 --> 00:06:52,160
we wanted to make sure most of these

00:06:50,560 --> 00:06:53,919
components were reusable

00:06:52,160 --> 00:06:56,080
so we don't have to throw away any

00:06:53,919 --> 00:06:57,039
effort taken to build a specific

00:06:56,080 --> 00:06:59,680
application message

00:06:57,039 --> 00:07:01,199
so we wanted to build as much minimal

00:06:59,680 --> 00:07:03,919
basic blocks needed

00:07:01,199 --> 00:07:04,800
to build off we we came up with a lot of

00:07:03,919 --> 00:07:06,400
basic blocks

00:07:04,800 --> 00:07:08,400
so that we can support a wide range of

00:07:06,400 --> 00:07:10,240
use cases such as

00:07:08,400 --> 00:07:12,080
and also we needed to make sure that we

00:07:10,240 --> 00:07:15,919
have necessary tools

00:07:12,080 --> 00:07:18,000
to make sure we can establish these

00:07:15,919 --> 00:07:19,840
links between the different libraries

00:07:18,000 --> 00:07:23,360
and and the components

00:07:19,840 --> 00:07:26,800
and also we needed to make sure that uh

00:07:23,360 --> 00:07:29,759
the generic components or generic

00:07:26,800 --> 00:07:30,639
uh components are separated from

00:07:29,759 --> 00:07:32,639
specific

00:07:30,639 --> 00:07:34,080
uh platform specific or architecture

00:07:32,639 --> 00:07:36,639
specific components

00:07:34,080 --> 00:07:37,840
so that you can use those generic

00:07:36,639 --> 00:07:39,280
components across the different

00:07:37,840 --> 00:07:40,800
platforms

00:07:39,280 --> 00:07:42,319
and we wanted to support a wide number

00:07:40,800 --> 00:07:44,000
of hypervisors as well as

00:07:42,319 --> 00:07:45,759
archite as far as architectures are

00:07:44,000 --> 00:07:47,440
concerned

00:07:45,759 --> 00:07:49,199
so with this in mind we came up with a

00:07:47,440 --> 00:07:51,599
tool called unicraft

00:07:49,199 --> 00:07:52,479
where everything is a micro library or

00:07:51,599 --> 00:07:55,360
library

00:07:52,479 --> 00:07:56,639
in itself and the two prominent

00:07:55,360 --> 00:07:59,759
components

00:07:56,639 --> 00:08:02,479
in the entire ecosystem are the library

00:07:59,759 --> 00:08:05,440
pools and the build tools

00:08:02,479 --> 00:08:07,280
with the library pool what what you can

00:08:05,440 --> 00:08:10,080
what you can do is you can enable us

00:08:07,280 --> 00:08:12,080
disable a specific library pool and the

00:08:10,080 --> 00:08:14,720
build system provides you the necessary

00:08:12,080 --> 00:08:16,479
necessary convenience to do that and

00:08:14,720 --> 00:08:18,400
also you can establish a dependency

00:08:16,479 --> 00:08:20,639
between one library to another or one

00:08:18,400 --> 00:08:23,759
library and a kernel component

00:08:20,639 --> 00:08:24,960
and this library pool also includes the

00:08:23,759 --> 00:08:28,000
os components

00:08:24,960 --> 00:08:31,039
which are decomposed as such

00:08:28,000 --> 00:08:33,680
so how does it affect so

00:08:31,039 --> 00:08:36,479
and also unicraft is open source which

00:08:33,680 --> 00:08:38,479
is bst licensed

00:08:36,479 --> 00:08:40,640
so how does it take to what does it take

00:08:38,479 --> 00:08:40,959
to build an application with unicorn

00:08:40,640 --> 00:08:42,640
right

00:08:40,959 --> 00:08:44,800
let's take an example and then let's run

00:08:42,640 --> 00:08:45,279
through it so if we take an application

00:08:44,800 --> 00:08:48,160
like an

00:08:45,279 --> 00:08:49,360
uh typical dpdk application l2 forward

00:08:48,160 --> 00:08:51,600
we needed to select

00:08:49,360 --> 00:08:52,560
which are all the libraries which it

00:08:51,600 --> 00:08:55,200
needs to which

00:08:52,560 --> 00:08:57,120
which it needs to select those libraries

00:08:55,200 --> 00:08:58,720
these libraries also includes

00:08:57,120 --> 00:09:01,040
something specific like kernel

00:08:58,720 --> 00:09:03,920
components also for example a net dev

00:09:01,040 --> 00:09:04,800
provides you a net device interface so

00:09:03,920 --> 00:09:06,640
you need that

00:09:04,800 --> 00:09:08,000
in order to support an l2 forward

00:09:06,640 --> 00:09:10,880
application message

00:09:08,000 --> 00:09:12,160
and then uh unicraft provides a

00:09:10,880 --> 00:09:14,480
different set of

00:09:12,160 --> 00:09:16,800
platform architectures which it runs on

00:09:14,480 --> 00:09:18,800
so those specific libraries which are

00:09:16,800 --> 00:09:20,480
specific to a specific platform needs to

00:09:18,800 --> 00:09:22,640
be selected

00:09:20,480 --> 00:09:24,240
and also the architecture specific code

00:09:22,640 --> 00:09:26,320
and once this is selected

00:09:24,240 --> 00:09:28,000
the unigraph build system message bakes

00:09:26,320 --> 00:09:30,399
your final image together

00:09:28,000 --> 00:09:31,760
and you have your final executable image

00:09:30,399 --> 00:09:36,399
to run on a specific

00:09:31,760 --> 00:09:40,080
platform so when we started uh

00:09:36,399 --> 00:09:41,440
our work on uh dpdk this was the mental

00:09:40,080 --> 00:09:44,640
image we had

00:09:41,440 --> 00:09:47,360
to port a dpdk image to unicrafters

00:09:44,640 --> 00:09:48,880
where we have a dpdk application and we

00:09:47,360 --> 00:09:52,080
have something like a

00:09:48,880 --> 00:09:55,360
lib uk dpdk which provides the

00:09:52,080 --> 00:09:57,600
unicraft functionality to a to a

00:09:55,360 --> 00:09:58,640
dpdk application and it interacts with

00:09:57,600 --> 00:10:02,000
the internal

00:09:58,640 --> 00:10:02,000
unicraft libraries

00:10:02,320 --> 00:10:08,720
but uh we also had

00:10:05,360 --> 00:10:10,800
uh some design considerations into uh

00:10:08,720 --> 00:10:12,640
account when we came up when we had this

00:10:10,800 --> 00:10:15,680
mental image also

00:10:12,640 --> 00:10:17,760
one of the advantages of the dpdk

00:10:15,680 --> 00:10:20,720
library is its modularity

00:10:17,760 --> 00:10:22,560
and the advantage and also the benefit

00:10:20,720 --> 00:10:24,800
of unicraft is its modularity

00:10:22,560 --> 00:10:26,800
so we wanted to retain as much

00:10:24,800 --> 00:10:28,720
modularity as possible

00:10:26,800 --> 00:10:31,040
so to do that we needed to make sure

00:10:28,720 --> 00:10:32,079
that the build system of unicraft can

00:10:31,040 --> 00:10:36,399
understand the build system

00:10:32,079 --> 00:10:40,079
of dpdk thereby it can use

00:10:36,399 --> 00:10:42,640
its modular modular libraries as such

00:10:40,079 --> 00:10:45,120
and we wanted to find out where are all

00:10:42,640 --> 00:10:46,000
the possible cases where we can optimize

00:10:45,120 --> 00:10:48,720
the guest operating

00:10:46,000 --> 00:10:49,519
system that way you can simplify a lot

00:10:48,720 --> 00:10:52,720
of

00:10:49,519 --> 00:10:54,320
simplify a lot of operations for a dpdk

00:10:52,720 --> 00:10:56,480
application message

00:10:54,320 --> 00:10:58,480
and also the the final constraint which

00:10:56,480 --> 00:11:01,760
is for quoting any libraries

00:10:58,480 --> 00:11:03,440
we wanted to minimize as many

00:11:01,760 --> 00:11:06,640
minimize the changes within the upstream

00:11:03,440 --> 00:11:06,640
code within dpdks

00:11:07,200 --> 00:11:11,360
so to make sure these build system

00:11:09,839 --> 00:11:14,000
compatibilities are matched

00:11:11,360 --> 00:11:15,519
we first compare and contrast the two

00:11:14,000 --> 00:11:18,000
build systems as such

00:11:15,519 --> 00:11:18,720
unicraft build system is k config based

00:11:18,000 --> 00:11:22,000
whereas

00:11:18,720 --> 00:11:24,959
a dpd cable system has some

00:11:22,000 --> 00:11:26,000
auto auto config generation happening

00:11:24,959 --> 00:11:27,839
and also

00:11:26,000 --> 00:11:29,600
a unicraft build system has some

00:11:27,839 --> 00:11:32,320
specific library name

00:11:29,600 --> 00:11:34,399
variable naming convention whereas the

00:11:32,320 --> 00:11:36,320
dpdk also has a similar

00:11:34,399 --> 00:11:38,959
uh naming convention which needs to be

00:11:36,320 --> 00:11:41,040
translated from one to another

00:11:38,959 --> 00:11:42,240
and and also it had something called

00:11:41,040 --> 00:11:45,600
export since when

00:11:42,240 --> 00:11:47,519
dp in unicraft which tries to hide

00:11:45,600 --> 00:11:48,800
uh unnecessary functionalities from a

00:11:47,519 --> 00:11:51,600
library to uh

00:11:48,800 --> 00:11:55,200
to other libraries as such similarly uh

00:11:51,600 --> 00:11:55,200
dpdk had a version map

00:11:55,600 --> 00:12:00,480
so in order to address these differences

00:11:58,959 --> 00:12:02,880
we came up with a solution

00:12:00,480 --> 00:12:04,560
using a typical unicraft approach which

00:12:02,880 --> 00:12:06,240
is to build a library around it

00:12:04,560 --> 00:12:07,839
so we came up with this library called

00:12:06,240 --> 00:12:11,120
dpdk build library

00:12:07,839 --> 00:12:13,680
what it does is it processes

00:12:11,120 --> 00:12:15,519
the make files of dpdk and translate it

00:12:13,680 --> 00:12:17,279
to the make files understandable to

00:12:15,519 --> 00:12:20,079
unicraft as such

00:12:17,279 --> 00:12:22,880
the advantage of doing it is we can add

00:12:20,079 --> 00:12:25,279
a dpdk library as such to unicraft and

00:12:22,880 --> 00:12:27,040
unicraft can then translate all its

00:12:25,279 --> 00:12:28,800
all its necessary dependencies to a

00:12:27,040 --> 00:12:30,639
unicraft build system understandable

00:12:28,800 --> 00:12:33,680
make file message

00:12:30,639 --> 00:12:35,519
thereby what advantage we gained is we

00:12:33,680 --> 00:12:37,440
were forward compatible right

00:12:35,519 --> 00:12:39,680
so as long as there was no change build

00:12:37,440 --> 00:12:42,240
system change in dpdk as such

00:12:39,680 --> 00:12:43,200
we can adapt all its libraries necessary

00:12:42,240 --> 00:12:46,399
to unicraft

00:12:43,200 --> 00:12:50,320
without without any further changes

00:12:46,399 --> 00:12:51,920
anywhere else and also this library

00:12:50,320 --> 00:12:53,120
contained if you have any specific

00:12:51,920 --> 00:12:54,880
configurations within

00:12:53,120 --> 00:12:57,440
dpdk this library contains those

00:12:54,880 --> 00:12:59,839
configurations also

00:12:57,440 --> 00:13:01,839
so with that in mind we came up with

00:12:59,839 --> 00:13:04,480
this sort of an architecture diagram

00:13:01,839 --> 00:13:05,279
or a building block diagram where we

00:13:04,480 --> 00:13:09,680
retain

00:13:05,279 --> 00:13:12,000
as much as uh the as much as the uh

00:13:09,680 --> 00:13:12,880
dpdk libraries are mentioned for example

00:13:12,000 --> 00:13:16,880
this rte

00:13:12,880 --> 00:13:20,399
ethdiv or m um the memory pool

00:13:16,880 --> 00:13:23,440
m pools or m buffs were not changed

00:13:20,399 --> 00:13:23,920
one bit in within unicorn whereas for

00:13:23,440 --> 00:13:26,079
each

00:13:23,920 --> 00:13:27,120
for the abstraction layer we needed to

00:13:26,079 --> 00:13:29,440
add some

00:13:27,120 --> 00:13:30,560
specific unica specific code which we'll

00:13:29,440 --> 00:13:32,240
talk about later

00:13:30,560 --> 00:13:33,600
and apart from that there are two

00:13:32,240 --> 00:13:36,160
libraries which are of

00:13:33,600 --> 00:13:38,160
consequence here which are the uk ring

00:13:36,160 --> 00:13:39,760
and the uk pmd libraries

00:13:38,160 --> 00:13:43,360
we will talk about these libraries

00:13:39,760 --> 00:13:43,360
further down the top yes

00:13:43,839 --> 00:13:49,839
so then uh the next part of

00:13:47,440 --> 00:13:51,839
our discussion was how to specialize the

00:13:49,839 --> 00:13:54,959
guest operating system message

00:13:51,839 --> 00:13:58,000
we we looked at three uh three parts

00:13:54,959 --> 00:14:00,320
where we could uh optimize

00:13:58,000 --> 00:14:02,000
on where you could optimize the unicraft

00:14:00,320 --> 00:14:05,040
guest operating system message

00:14:02,000 --> 00:14:07,040
one is the memory management system the

00:14:05,040 --> 00:14:09,680
second is a device management system and

00:14:07,040 --> 00:14:11,440
third is the scheduling part

00:14:09,680 --> 00:14:13,440
in terms of memory management system

00:14:11,440 --> 00:14:16,880
what unicraft provide

00:14:13,440 --> 00:14:19,839
was a static memory image

00:14:16,880 --> 00:14:22,079
where we where we have huge pages of two

00:14:19,839 --> 00:14:24,480
gigabytes mapped

00:14:22,079 --> 00:14:26,320
into the first one gigabit of the

00:14:24,480 --> 00:14:28,959
address space

00:14:26,320 --> 00:14:30,720
so thereby we only support one gigabit

00:14:28,959 --> 00:14:32,320
of memory and

00:14:30,720 --> 00:14:34,560
and thereby we have a one to one

00:14:32,320 --> 00:14:36,480
translation between a pa and va

00:14:34,560 --> 00:14:37,760
within a physical address to a virtual

00:14:36,480 --> 00:14:41,199
address within that of a

00:14:37,760 --> 00:14:43,920
unique analysis and

00:14:41,199 --> 00:14:44,720
from an application perspective an

00:14:43,920 --> 00:14:48,800
application

00:14:44,720 --> 00:14:51,440
can specify a reserve and memory range

00:14:48,800 --> 00:14:52,000
from the unicraft uni kernel thereby you

00:14:51,440 --> 00:14:53,920
can

00:14:52,000 --> 00:14:55,519
make sure that this is specific to you

00:14:53,920 --> 00:14:57,120
can resolve this memory region

00:14:55,519 --> 00:14:59,040
and you can take this memory region and

00:14:57,120 --> 00:15:02,079
use it for your memory buffers

00:14:59,040 --> 00:15:03,360
already and also it is possible to

00:15:02,079 --> 00:15:05,760
implement

00:15:03,360 --> 00:15:06,480
multiple allocators to understand which

00:15:05,760 --> 00:15:09,199
allocator

00:15:06,480 --> 00:15:09,839
is best suited for your for your

00:15:09,199 --> 00:15:13,680
specific

00:15:09,839 --> 00:15:17,600
application message

00:15:13,680 --> 00:15:21,199
in terms of the device management itself

00:15:17,600 --> 00:15:23,120
what unicraft provides you is unicraft

00:15:21,199 --> 00:15:24,720
just probes the devices and lets the

00:15:23,120 --> 00:15:25,360
application take over the device

00:15:24,720 --> 00:15:27,440
controller

00:15:25,360 --> 00:15:29,120
all together so unicraft identifies

00:15:27,440 --> 00:15:30,079
which are all the devices necessary for

00:15:29,120 --> 00:15:31,199
an application

00:15:30,079 --> 00:15:33,199
and just hands it over to the

00:15:31,199 --> 00:15:34,079
application and the application it's up

00:15:33,199 --> 00:15:37,360
to the application

00:15:34,079 --> 00:15:37,360
how to handle these devices

00:15:37,440 --> 00:15:41,120
you don't need any any additional file

00:15:40,079 --> 00:15:45,600
system or

00:15:41,120 --> 00:15:45,600
anything else to handle these devices

00:15:46,720 --> 00:15:53,199
and finally for scheduling message uh

00:15:50,079 --> 00:15:56,079
unicraft gives you the ability

00:15:53,199 --> 00:15:57,440
to make sure that you can run an

00:15:56,079 --> 00:16:01,040
application an application

00:15:57,440 --> 00:16:04,079
can hawk the cpu cycle

00:16:01,040 --> 00:16:06,160
until it can yield to another uh

00:16:04,079 --> 00:16:08,000
to another thread so unicaf uses a

00:16:06,160 --> 00:16:11,440
cooperative scheduler thereby it runs

00:16:08,000 --> 00:16:14,399
at an application can run a task without

00:16:11,440 --> 00:16:15,600
minimal interference from the uh unique

00:16:14,399 --> 00:16:18,880
kernel as such

00:16:15,600 --> 00:16:21,440
and also if if it is possible if if

00:16:18,880 --> 00:16:22,800
necessary we can also completely do away

00:16:21,440 --> 00:16:26,800
with the scheduler

00:16:22,800 --> 00:16:27,519
and run uh run the entire application

00:16:26,800 --> 00:16:29,680
within a

00:16:27,519 --> 00:16:30,720
full polling mode where everything is

00:16:29,680 --> 00:16:32,079
even

00:16:30,720 --> 00:16:37,680
when everything is even driven or

00:16:32,079 --> 00:16:41,199
interrupt or a name interrupting

00:16:37,680 --> 00:16:41,839
so next what is needed from unicraft to

00:16:41,199 --> 00:16:45,120
support

00:16:41,839 --> 00:16:45,839
a dpdk library session so we compare and

00:16:45,120 --> 00:16:49,519
contrast

00:16:45,839 --> 00:16:52,240
how a typical data flow

00:16:49,519 --> 00:16:53,519
works with between a unicraft library

00:16:52,240 --> 00:16:55,519
and dpdk library

00:16:53,519 --> 00:16:56,800
so on the left you have the dpdk

00:16:55,519 --> 00:16:58,079
workflow and on the right you have the

00:16:56,800 --> 00:17:00,480
unicraft workflow

00:16:58,079 --> 00:17:01,120
where you have an application wanting to

00:17:00,480 --> 00:17:04,240
send

00:17:01,120 --> 00:17:08,240
calls the dev

00:17:04,240 --> 00:17:11,199
burst in uh dpdk and uk netf

00:17:08,240 --> 00:17:12,079
burst and and then it calls the what are

00:17:11,199 --> 00:17:15,120
your drivers to

00:17:12,079 --> 00:17:18,400
send out the data out so you need

00:17:15,120 --> 00:17:21,600
um and also here

00:17:18,400 --> 00:17:24,959
uh dpdk libraries handle m buffs

00:17:21,600 --> 00:17:27,120
whereas uh unicraft libraries handle

00:17:24,959 --> 00:17:28,640
network sassage so there is a difference

00:17:27,120 --> 00:17:29,440
in data structure between the two

00:17:28,640 --> 00:17:32,440
libraries

00:17:29,440 --> 00:17:35,479
so we need a way to have

00:17:32,440 --> 00:17:35,479
[Music]

00:17:36,960 --> 00:17:42,160
a similar diagram for the rx part of it

00:17:39,200 --> 00:17:43,919
i'll skip this part right

00:17:42,160 --> 00:17:45,200
so what is what is the difference

00:17:43,919 --> 00:17:48,400
between a net buff

00:17:45,200 --> 00:17:52,320
and the m buff message so

00:17:48,400 --> 00:17:54,960
with a net buff what you have is uh

00:17:52,320 --> 00:17:56,080
you had a you had a packet data with a

00:17:54,960 --> 00:17:58,000
net buff you had this

00:17:56,080 --> 00:18:00,080
network structure and then you have the

00:17:58,000 --> 00:18:02,000
user private data within the

00:18:00,080 --> 00:18:04,880
which is the net which is the

00:18:02,000 --> 00:18:06,400
applications usage of the network

00:18:04,880 --> 00:18:07,919
and then you have the packet headers and

00:18:06,400 --> 00:18:09,919
the packet data

00:18:07,919 --> 00:18:11,280
whereas if you take the equivalent of an

00:18:09,919 --> 00:18:14,080
uh

00:18:11,280 --> 00:18:15,679
m buff you have this m buff buffer then

00:18:14,080 --> 00:18:16,960
you had the packet data and you had some

00:18:15,679 --> 00:18:19,919
private data for it

00:18:16,960 --> 00:18:21,200
so we needed a way to mangle from one

00:18:19,919 --> 00:18:24,320
net buff to an

00:18:21,200 --> 00:18:25,520
ember message so we came up with this uk

00:18:24,320 --> 00:18:28,880
ringed library

00:18:25,520 --> 00:18:32,080
which does this mangling from one

00:18:28,880 --> 00:18:34,000
uh one data structure to another and

00:18:32,080 --> 00:18:36,000
also the pole mode driver

00:18:34,000 --> 00:18:37,840
translates the call anything which is

00:18:36,000 --> 00:18:40,720
happening within the

00:18:37,840 --> 00:18:42,400
dpdk context to that of the unicraft

00:18:40,720 --> 00:18:45,360
context within the network

00:18:42,400 --> 00:18:45,760
so thereby we were able to translate

00:18:45,360 --> 00:18:48,799
from

00:18:45,760 --> 00:18:50,160
a net buff to a m buff and m buff to a

00:18:48,799 --> 00:18:52,320
net buff

00:18:50,160 --> 00:18:54,080
with with just these manipulations

00:18:52,320 --> 00:18:57,200
whereby we point

00:18:54,080 --> 00:18:57,919
the private data of a of a m-buff to the

00:18:57,200 --> 00:18:59,919
network

00:18:57,919 --> 00:19:01,679
and the private data of netbuff to a

00:18:59,919 --> 00:19:04,320
number thereby it's easier to translate

00:19:01,679 --> 00:19:04,320
from another

00:19:06,960 --> 00:19:10,960
and finally we talk about the

00:19:09,280 --> 00:19:15,039
performance evaluations

00:19:10,960 --> 00:19:18,320
here we used uh two sets two systems

00:19:15,039 --> 00:19:20,160
one was the package generator receiver

00:19:18,320 --> 00:19:21,760
and the other other system is the one

00:19:20,160 --> 00:19:25,679
which runs

00:19:21,760 --> 00:19:29,520
linux vm or a unicraft vm message

00:19:25,679 --> 00:19:32,720
the one it is it is a

00:19:29,520 --> 00:19:35,360
sandy sandy bridge server with

00:19:32,720 --> 00:19:36,400
six cores on it and uh we have we were

00:19:35,360 --> 00:19:39,679
using dpdk

00:19:36,400 --> 00:19:41,679
1908 chemo version 4

00:19:39,679 --> 00:19:42,720
and the linux kernel the host kernel and

00:19:41,679 --> 00:19:45,919
the guest kernel were

00:19:42,720 --> 00:19:45,919
4.19 db

00:19:46,160 --> 00:19:51,200
and in terms of the next graph where you

00:19:49,200 --> 00:19:53,760
show is the baseline performance

00:19:51,200 --> 00:19:56,240
what we do here is we vary the package

00:19:53,760 --> 00:19:59,919
sizes from 64 bytes

00:19:56,240 --> 00:20:02,400
until 1500 bytes and we measure

00:19:59,919 --> 00:20:03,200
how much throughput we get in terms of

00:20:02,400 --> 00:20:06,320
uh

00:20:03,200 --> 00:20:07,280
millions of packets per second so what

00:20:06,320 --> 00:20:11,200
we gain is

00:20:07,280 --> 00:20:14,000
we in terms of uh in terms of

00:20:11,200 --> 00:20:15,919
we measured it in four mechanisms one is

00:20:14,000 --> 00:20:18,000
using the v host user

00:20:15,919 --> 00:20:19,520
and which is the dpdk accelerated

00:20:18,000 --> 00:20:22,000
version and the v host

00:20:19,520 --> 00:20:23,360
is the kernel accelerated version and in

00:20:22,000 --> 00:20:26,320
terms of unicraft

00:20:23,360 --> 00:20:27,440
versus dpdk comparison we are quite

00:20:26,320 --> 00:20:31,520
similar

00:20:27,440 --> 00:20:34,320
in uh transmission performance as such

00:20:31,520 --> 00:20:35,200
similar performance we did for the rx

00:20:34,320 --> 00:20:38,640
throughput

00:20:35,200 --> 00:20:40,240
where uh the rx part of unicraft with a

00:20:38,640 --> 00:20:43,440
v host user

00:20:40,240 --> 00:20:47,440
is slightly slower than is about 11

00:20:43,440 --> 00:20:50,880
million 11.5 million packets whereas the

00:20:47,440 --> 00:20:53,919
rx of uh rx of uh

00:20:50,880 --> 00:20:56,400
linux vm was around 13 million packets

00:20:53,919 --> 00:20:57,280
uh for the minimal packet size and for

00:20:56,400 --> 00:21:00,480
the rest of them

00:20:57,280 --> 00:21:02,240
was quite matching so we there are some

00:21:00,480 --> 00:21:03,360
bottlenecks within the rx which we need

00:21:02,240 --> 00:21:06,559
to figure out

00:21:03,360 --> 00:21:06,559
which is part of the future work

00:21:07,679 --> 00:21:11,280
so in the previous two experiments what

00:21:10,080 --> 00:21:13,600
we did was

00:21:11,280 --> 00:21:15,440
a package generator keeps sending

00:21:13,600 --> 00:21:16,080
packets and we drop the packet once we

00:21:15,440 --> 00:21:18,799
receive it

00:21:16,080 --> 00:21:20,320
or once we send it here we did another

00:21:18,799 --> 00:21:22,480
experiment which is like a key value

00:21:20,320 --> 00:21:24,720
store what we did was

00:21:22,480 --> 00:21:25,919
a package generator sends you a stream

00:21:24,720 --> 00:21:28,720
of packets

00:21:25,919 --> 00:21:29,440
we receive the packet we read some

00:21:28,720 --> 00:21:31,760
specific

00:21:29,440 --> 00:21:33,360
based on the values in the packet we

00:21:31,760 --> 00:21:35,919
read a key value store

00:21:33,360 --> 00:21:36,480
and we send out the packet out so with

00:21:35,919 --> 00:21:39,760
that

00:21:36,480 --> 00:21:42,159
a single core is is being is now being

00:21:39,760 --> 00:21:43,760
is now processing the receive of packet

00:21:42,159 --> 00:21:44,960
processing some data within the packet

00:21:43,760 --> 00:21:47,520
and sending it out

00:21:44,960 --> 00:21:49,039
and we made a comparison of that with

00:21:47,520 --> 00:21:52,159
the linux vm

00:21:49,039 --> 00:21:53,760
and that of a unicraft and with dpdk and

00:21:52,159 --> 00:21:55,679
unicraft with net dev running

00:21:53,760 --> 00:21:59,840
and all of them were quite similar in

00:21:55,679 --> 00:21:59,840
terms of six million packets per second

00:22:00,080 --> 00:22:06,000
and in terms of resource usage itself uh

00:22:03,200 --> 00:22:06,720
what we observed was in terms of memory

00:22:06,000 --> 00:22:10,080
usage

00:22:06,720 --> 00:22:11,280
unicraft needed to run to run the dpdk

00:22:10,080 --> 00:22:12,960
application you need

00:22:11,280 --> 00:22:15,039
just one gigabit of memory whereas the

00:22:12,960 --> 00:22:15,760
linux vm needed a six gigabyte of memory

00:22:15,039 --> 00:22:18,720
so it's about

00:22:15,760 --> 00:22:21,440
six orders same savings the boot times

00:22:18,720 --> 00:22:24,480
of unicraft is about 87 milliseconds

00:22:21,440 --> 00:22:28,159
whereas the view time of a linux pm is

00:22:24,480 --> 00:22:30,960
unoptimized is about 12 seconds i switch

00:22:28,159 --> 00:22:32,480
and the image size comparison is the

00:22:30,960 --> 00:22:35,679
unicraft image is about

00:22:32,480 --> 00:22:36,799
1.4 megabytes in size whereas a linux vm

00:22:35,679 --> 00:22:39,440
is about

00:22:36,799 --> 00:22:40,799
2.5 gigabytes in size so it's about a

00:22:39,440 --> 00:22:42,720
huge order of magnitude

00:22:40,799 --> 00:22:45,280
difference between in terms of resource

00:22:42,720 --> 00:22:45,280
you say yes

00:22:45,919 --> 00:22:51,919
finally the next part of our

00:22:49,840 --> 00:22:53,600
of this journey is we needed to add

00:22:51,919 --> 00:22:55,600
support for smp's

00:22:53,600 --> 00:22:56,880
drivers smp support so that we have

00:22:55,600 --> 00:22:59,440
multiple cpus

00:22:56,880 --> 00:23:01,919
and also we wanted to try out running

00:22:59,440 --> 00:23:02,960
dpdk drivers instead of unicraft drivers

00:23:01,919 --> 00:23:06,720
which were run

00:23:02,960 --> 00:23:06,720
so that we can keep it up to date

00:23:07,280 --> 00:23:10,960
so if you if you find this work

00:23:08,799 --> 00:23:12,559
interesting you could you could also

00:23:10,960 --> 00:23:14,159
for further references you could i have

00:23:12,559 --> 00:23:17,520
put on some of the links

00:23:14,159 --> 00:23:20,799
you can refer it and that's to

00:23:17,520 --> 00:23:21,360
conclude my talk uh of unicraft we made

00:23:20,799 --> 00:23:23,919
us

00:23:21,360 --> 00:23:25,600
a comparison unicraft provides you

00:23:23,919 --> 00:23:28,880
multiple platform support

00:23:25,600 --> 00:23:31,440
a specialized guest operate guest os

00:23:28,880 --> 00:23:33,039
whereby we optimize for image size

00:23:31,440 --> 00:23:36,320
memory consumption

00:23:33,039 --> 00:23:38,640
and also the boot times

00:23:36,320 --> 00:23:39,600
at the same performance and we have a

00:23:38,640 --> 00:23:41,679
simpler managed

00:23:39,600 --> 00:23:44,480
device management simpler device

00:23:41,679 --> 00:23:46,960
management for a dpdk application

00:23:44,480 --> 00:23:49,039
and we provide increased control for an

00:23:46,960 --> 00:23:52,400
application compared to that of a linux

00:23:49,039 --> 00:23:54,880
guest vm and in terms of dpdk

00:23:52,400 --> 00:23:57,039
dpdk provides you the benefit of and

00:23:54,880 --> 00:24:00,080
highly optimized network stack

00:23:57,039 --> 00:24:01,120
a specialized pnf functionality and a

00:24:00,080 --> 00:24:05,200
lot of

00:24:01,120 --> 00:24:07,840
untapped potential from the dpdk drivers

00:24:05,200 --> 00:24:08,320
so i think the two projects go hand in

00:24:07,840 --> 00:24:12,559
hand

00:24:08,320 --> 00:24:17,440
in the vnf domain and it is a benefit

00:24:12,559 --> 00:24:21,360
that we use unicraft as a dpdk image

00:24:17,440 --> 00:24:24,159
in the in a in the virtualized

00:24:21,360 --> 00:24:24,159
network functions

00:24:24,400 --> 00:24:28,240
if there are further questions i would

00:24:25,919 --> 00:24:29,039
like to leave the flow for further

00:24:28,240 --> 00:24:31,200
questions if

00:24:29,039 --> 00:24:33,840
you have any questions please ask thank

00:24:31,200 --> 00:24:33,840
you

00:24:44,960 --> 00:24:47,039

YouTube URL: https://www.youtube.com/watch?v=YbrjClYFapE


