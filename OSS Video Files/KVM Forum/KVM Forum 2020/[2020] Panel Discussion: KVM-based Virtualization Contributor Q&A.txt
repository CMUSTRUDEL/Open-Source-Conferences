Title: [2020] Panel Discussion: KVM-based Virtualization Contributor Q&A
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	A Q&A panel discussion on a variety of topics (technical and non-technical) related to KVM, QEMU, securing virtual machines, and more. The discussion will be for about an hour. Topics will be chosen based on several sources: prepared list, audience questions on a live Etherpad, or interesting tangents based on live discussion.

Live Etherpad link - https://etherpad.opendev.org/p/KVMForum_2020_Panel

---

Richard W.M. Jones
Red Hat, Senior Principal Software Engineer

Richard Jones works at Red Hat. He works on virtualization, importing VMs from other hypervisors to KVM, RISC-V, Fedora, and Unikernels.

Stefan Hajnoczi
Red Hat, Senior Principal Software Engineer
United Kingdom

Stefan has been active in QEMU since 2010 and is a Senior Principal Software Engineer in Red Hat's virtualization team with a focus on storage. He works on virtio drivers in Linux and helps maintain the block layer and tracing in QEMU. He also organizes and mentors in the Google Summer of Code and Outreachy internship programs for QEMU, and participates in the VIRTIO Technical Committee.

Hubertus Franke
IBM, Distinguished Research Staff Member

Dr. Hubertus Franke is a Distinguished Research Staff Member at the IBM T.J.Watson Research Center since 1993. His area of current work and interests are the area of operating systems, virtualization, processor architectures, cloud runtimes and security. Some time back he has also worked in the area of HPC middleware, compilers and robotics. He was active in the Linux kernel in the first decade of this millennium, working on scalable schedulers, NUMA memory management and introduced futexes and precursors of today's namespaces and cgroups. He graduated with a Diplom Informatik degree (computer science) from the University of Karlsruhe (now KIT), Germany in 1987. He obtained a Ph.D. in Electrical Engineering from Vanderbilt University in 1992. He authored / co-authored over 130 publications and holds over 150 patents. He is a member of the IBM Academy of Technology and an IBM Master Inventor. He is an ACM Distinguished Engineer. Since 2011 he has also been an Adjunct Professor at the New York University, year round teaching graduate operating system classes.

Susie Li
Intel, Software Engineering Director

Susie Li is an Software Engineering Director in Intel. She joined Intel in 1999 and had been involved in leadership role for a variety of software projects, including UEFI/Tiano, virtualization (KVM, Xen, ACRN, HAXM), Yocto Linux, Linux kernel and OpenStack, etc. Susie is a two-time winner of Intel Achievement Award, and holds three US patents. She received her Bachelor’s and Master’s degrees in Computer Science from Shanghai Jiao Tong University, China.

David Kaplan
AMD, Fellow

David Kaplan is a Fellow at AMD who focuses on developing new security technologies across the AMD product line as part of the Product Security Organization. He is the lead architect for the AMD encrypted virutalization features and has worked on both CPU and SOC level security features for the last 9 years. David has over 14 years of experience at AMD, has filed over 50 patents in his career so far, and spoken at events including Linux Security Summit, ISCA, USENIX Security, and CCC.

Peter Maydell
Arm, Principal Software Engineer

Peter works for Arm, but has been seconded into Linaro for the last ten years to handle all things Arm in QEMU, including CPU architecture emulation, support for KVM virtualization on Arm servers, and herding an ever-increasing number of board, SoC and device models. He also didn't duck fast enough to avoid being lumbered with "General Project Administration" :-). Before Arm he worked for a small company on an embedded OS and JITting Java virtual machine; watching a decade of work vanish when the company went under was a compelling argument for the merits of working on open source codebases.
Captions: 
	00:00:06,799 --> 00:00:10,320
hi

00:00:07,120 --> 00:00:12,880
and welcome to the kvm forum 2020

00:00:10,320 --> 00:00:14,240
panel discussion my name is stefan

00:00:12,880 --> 00:00:16,800
heinzie and i'm going to be

00:00:14,240 --> 00:00:18,400
the moderator for this discussion today

00:00:16,800 --> 00:00:20,560
we have with us panelists

00:00:18,400 --> 00:00:23,600
who are from organizations that

00:00:20,560 --> 00:00:26,400
contribute to qmu and kvm

00:00:23,600 --> 00:00:27,199
and we have a list of questions from the

00:00:26,400 --> 00:00:29,039
community

00:00:27,199 --> 00:00:30,560
that have been suggested as topics for

00:00:29,039 --> 00:00:33,120
today's discussion

00:00:30,560 --> 00:00:34,160
before we dive into the questions we're

00:00:33,120 --> 00:00:36,000
going to go around

00:00:34,160 --> 00:00:38,559
and let the panelists introduce

00:00:36,000 --> 00:00:38,559
themselves

00:00:38,800 --> 00:00:42,960
so let's begin would you like to

00:00:41,840 --> 00:00:46,399
introduce yourself

00:00:42,960 --> 00:00:48,480
yourself susie hi everyone

00:00:46,399 --> 00:00:49,840
this is susie lee from intel and

00:00:48,480 --> 00:00:52,800
managing the intel open source

00:00:49,840 --> 00:00:52,800
virtualization team

00:00:54,960 --> 00:00:59,600
thank you um richard would you like to

00:00:57,760 --> 00:01:02,960
introduce yourself

00:00:59,600 --> 00:01:06,159
hi i'm richard jones from red hat

00:01:02,960 --> 00:01:08,560
um and i work on v2v

00:01:06,159 --> 00:01:09,840
some virtualization things some mbd

00:01:08,560 --> 00:01:13,600
things

00:01:09,840 --> 00:01:17,040
and other topics in the vert space

00:01:13,600 --> 00:01:19,759
thank you david kaplan

00:01:17,040 --> 00:01:22,720
hi uh david kaplan from amd i'm a

00:01:19,759 --> 00:01:24,720
security architect i focus mostly on

00:01:22,720 --> 00:01:27,840
confidential computing technologies like

00:01:24,720 --> 00:01:27,840
encrypted virtualization

00:01:29,280 --> 00:01:35,840
thank you um peter maida

00:01:33,040 --> 00:01:37,040
hi i'm peter i work for arm i've been

00:01:35,840 --> 00:01:40,000
seconded into

00:01:37,040 --> 00:01:42,079
linaro for about 10 years now working on

00:01:40,000 --> 00:01:45,200
quermue mostly dealing with

00:01:42,079 --> 00:01:48,399
arm related emulation work

00:01:45,200 --> 00:01:50,320
and we also do a bunch of the admin and

00:01:48,399 --> 00:01:52,880
build type stuff as well didn't duck

00:01:50,320 --> 00:01:55,600
fast enough to avoid that

00:01:52,880 --> 00:01:57,439
thank you and hubertos franke yeah i'm

00:01:55,600 --> 00:02:00,000
hubris frank from ibm research i

00:01:57,439 --> 00:02:02,000
mostly work in architecture and

00:02:00,000 --> 00:02:04,000
operating systems and the interfaces and

00:02:02,000 --> 00:02:07,040
now how they basically surface up in

00:02:04,000 --> 00:02:09,039
cloud environments thank you

00:02:07,040 --> 00:02:10,879
okay well let's begin we have an ether

00:02:09,039 --> 00:02:13,280
pad that was submitted by the

00:02:10,879 --> 00:02:14,959
the community with uh questions in a

00:02:13,280 --> 00:02:17,520
bunch of different areas and we can just

00:02:14,959 --> 00:02:19,680
keep going until we run out of time

00:02:17,520 --> 00:02:22,319
this year one of the trends seems to be

00:02:19,680 --> 00:02:25,040
encrypted vms confidential cloud

00:02:22,319 --> 00:02:26,400
and so on so we let's start with a

00:02:25,040 --> 00:02:28,239
question from there

00:02:26,400 --> 00:02:29,599
because i know that several of you have

00:02:28,239 --> 00:02:32,800
been looking at this area

00:02:29,599 --> 00:02:36,160
and are involved in that

00:02:32,800 --> 00:02:38,879
so so for the the first question let's

00:02:36,160 --> 00:02:40,959
let's start discussing um what other use

00:02:38,879 --> 00:02:41,360
cases for encrypted vms have you looked

00:02:40,959 --> 00:02:44,319
at

00:02:41,360 --> 00:02:45,760
besides improving privacy in the cloud

00:02:44,319 --> 00:02:48,160
so feel free to just

00:02:45,760 --> 00:02:48,160
jump in

00:02:49,040 --> 00:02:51,280
yes

00:02:53,200 --> 00:02:57,840
i can start on this one so yeah i i

00:02:56,000 --> 00:03:00,000
think it's an interesting question

00:02:57,840 --> 00:03:01,840
certainly there are a lot of use cases

00:03:00,000 --> 00:03:04,400
in the cloud and i know at amd

00:03:01,840 --> 00:03:06,159
that is probably the primary place we

00:03:04,400 --> 00:03:07,280
focus on when we talk about confidential

00:03:06,159 --> 00:03:09,519
computing

00:03:07,280 --> 00:03:10,879
whether it's traditional virtualization

00:03:09,519 --> 00:03:13,760
container lightweight

00:03:10,879 --> 00:03:15,040
virtualization things like that but the

00:03:13,760 --> 00:03:16,800
question was about

00:03:15,040 --> 00:03:18,560
scenarios beyond the cloud and you know

00:03:16,800 --> 00:03:20,640
maybe there's one that i'll offer that i

00:03:18,560 --> 00:03:22,480
think could be interesting in the future

00:03:20,640 --> 00:03:25,120
and that would be sort of a bring your

00:03:22,480 --> 00:03:28,159
own device type scenario

00:03:25,120 --> 00:03:31,280
you can imagine a corporation

00:03:28,159 --> 00:03:32,080
that uses employee devices but they have

00:03:31,280 --> 00:03:33,840
sensitive data

00:03:32,080 --> 00:03:35,120
they have special programs that they

00:03:33,840 --> 00:03:37,440
want to use

00:03:35,120 --> 00:03:39,360
and they don't know what malware or

00:03:37,440 --> 00:03:41,760
other programs might be installed

00:03:39,360 --> 00:03:43,920
on the employee device and so in that

00:03:41,760 --> 00:03:46,319
sense you have a similar trust model to

00:03:43,920 --> 00:03:49,840
what you might find in the cloud in that

00:03:46,319 --> 00:03:51,680
you have a employer that wants to run a

00:03:49,840 --> 00:03:54,799
secure workload in an otherwise

00:03:51,680 --> 00:03:56,959
untrusted system so i think that could

00:03:54,799 --> 00:03:58,720
be an interesting scenario

00:03:56,959 --> 00:04:00,799
maybe in the future although as i say

00:03:58,720 --> 00:04:04,000
right now we're at least at amd we're

00:04:00,799 --> 00:04:04,000
primarily focused on cloud

00:04:04,080 --> 00:04:08,080
so i would say that uh anytime you

00:04:06,560 --> 00:04:08,799
basically have some form of service

00:04:08,080 --> 00:04:11,519
provider

00:04:08,799 --> 00:04:13,120
right whether it's in the cloud or not

00:04:11,519 --> 00:04:14,000
such as edge computing these are

00:04:13,120 --> 00:04:16,160
interesting

00:04:14,000 --> 00:04:17,600
use cases right it's not clear to me yet

00:04:16,160 --> 00:04:19,759
at this point

00:04:17,600 --> 00:04:20,639
when applications busy driving towards

00:04:19,759 --> 00:04:22,240
the edge whether we

00:04:20,639 --> 00:04:24,720
still want to include this into the

00:04:22,240 --> 00:04:26,960
cloud computing scenario or not

00:04:24,720 --> 00:04:28,960
but certainly similar to what david just

00:04:26,960 --> 00:04:31,120
said the moment you're running in an

00:04:28,960 --> 00:04:32,240
effectively untrusted environment and

00:04:31,120 --> 00:04:33,840
application

00:04:32,240 --> 00:04:37,199
they are certainly going to have to look

00:04:33,840 --> 00:04:37,199
at encrypted vms

00:04:37,280 --> 00:04:41,600
yeah one thing i want to add is uh you

00:04:39,360 --> 00:04:43,440
know certainly a lot of the usage is

00:04:41,600 --> 00:04:44,880
for the encrypted vm is in the cloud

00:04:43,440 --> 00:04:47,040
space but also

00:04:44,880 --> 00:04:49,600
we are now seeing a lot of the

00:04:47,040 --> 00:04:52,320
development of virtualization use cases

00:04:49,600 --> 00:04:54,240
in the client space and also in the you

00:04:52,320 --> 00:04:56,560
know iot age space

00:04:54,240 --> 00:04:58,160
so for example there are more and more

00:04:56,560 --> 00:04:58,800
uh workload consolidation happening

00:04:58,160 --> 00:05:00,320
there

00:04:58,800 --> 00:05:02,160
and also you know the

00:05:00,320 --> 00:05:03,360
virtualization-based security right for

00:05:02,160 --> 00:05:06,479
example you want to

00:05:03,360 --> 00:05:09,600
run uh you know virtualization-based um

00:05:06,479 --> 00:05:10,639
te environment so and all these are you

00:05:09,600 --> 00:05:13,039
know based on vt

00:05:10,639 --> 00:05:13,759
so this could be a lot of architectural

00:05:13,039 --> 00:05:16,160
um

00:05:13,759 --> 00:05:18,479
options on how to do this so i think

00:05:16,160 --> 00:05:20,639
that's having encrypted vm there

00:05:18,479 --> 00:05:22,320
yeah we're definitely i think that's uh

00:05:20,639 --> 00:05:24,000
will bring a very interesting

00:05:22,320 --> 00:05:27,360
architecture option into that and has

00:05:24,000 --> 00:05:27,360
the profound architectural impacts

00:05:29,919 --> 00:05:34,080
okay thank you so we have a follow-up

00:05:32,639 --> 00:05:36,960
question that was posted

00:05:34,080 --> 00:05:39,039
about memory isolation isolation so i

00:05:36,960 --> 00:05:40,880
guess this is a more technical one

00:05:39,039 --> 00:05:42,320
it's a question of how is memory

00:05:40,880 --> 00:05:43,919
isolation being done

00:05:42,320 --> 00:05:45,039
and you can interpret that how you want

00:05:43,919 --> 00:05:45,759
i'm not sure whether they're thinking

00:05:45,039 --> 00:05:47,759
about

00:05:45,759 --> 00:05:49,039
caches and avoiding side channel attacks

00:05:47,759 --> 00:05:52,560
and so on

00:05:49,039 --> 00:05:54,400
so please go ahead

00:05:52,560 --> 00:05:57,039
so in general this is done through the

00:05:54,400 --> 00:06:00,319
uh uh memory controller right so

00:05:57,039 --> 00:06:01,919
when essentially a encrypted vm calls

00:06:00,319 --> 00:06:03,680
the load store operation it's

00:06:01,919 --> 00:06:05,840
effectively going through your caches

00:06:03,680 --> 00:06:06,880
and at the end it's basically tagged

00:06:05,840 --> 00:06:10,160
with the

00:06:06,880 --> 00:06:12,479
uh address base id and at the

00:06:10,160 --> 00:06:13,840
memory controller level it's going to go

00:06:12,479 --> 00:06:15,759
through the various encryption

00:06:13,840 --> 00:06:18,160
mechanisms that are being provided so

00:06:15,759 --> 00:06:19,360
data is then encrypted writing out and

00:06:18,160 --> 00:06:22,479
on the way in it's being

00:06:19,360 --> 00:06:25,199
decrypted from a caching uh

00:06:22,479 --> 00:06:25,759
i guess suzy and david can speak more to

00:06:25,199 --> 00:06:27,600
it

00:06:25,759 --> 00:06:29,759
but you will effectively have to tag the

00:06:27,600 --> 00:06:32,319
caches right so to make sure that

00:06:29,759 --> 00:06:35,840
nobody can snoop on your cache outside

00:06:32,319 --> 00:06:35,840
your address space

00:06:36,639 --> 00:06:39,199
yeah i mean i would just had to say that

00:06:38,080 --> 00:06:40,639
that kind of gets into the

00:06:39,199 --> 00:06:42,160
implementation details

00:06:40,639 --> 00:06:43,440
and you know i think different vendors

00:06:42,160 --> 00:06:45,199
have chosen to implement this in

00:06:43,440 --> 00:06:47,520
different ways

00:06:45,199 --> 00:06:49,440
but i think that you know everyone has

00:06:47,520 --> 00:06:50,880
some sort of a solution for it

00:06:49,440 --> 00:06:52,880
you know there are a few different

00:06:50,880 --> 00:06:55,520
general techniques for isolation

00:06:52,880 --> 00:06:57,280
there's uh cryptographic isolation as uh

00:06:55,520 --> 00:06:58,720
ebert has kind of talked about

00:06:57,280 --> 00:07:00,319
where if you don't have the correct

00:06:58,720 --> 00:07:01,599
encryption key then you're not able to

00:07:00,319 --> 00:07:04,160
access the data

00:07:01,599 --> 00:07:05,919
there's also so-called logical isolation

00:07:04,160 --> 00:07:09,039
which would be where you use

00:07:05,919 --> 00:07:10,400
a mechanism whether it's page tables or

00:07:09,039 --> 00:07:12,800
something of that sort

00:07:10,400 --> 00:07:15,039
to actually block access to data that

00:07:12,800 --> 00:07:18,080
you're not supposed to

00:07:15,039 --> 00:07:21,199
um have i know at amd we've used both

00:07:18,080 --> 00:07:25,360
uh in different cases and i i'm

00:07:21,199 --> 00:07:25,360
sure that other vendors uh are similar

00:07:26,479 --> 00:07:30,080
it's actually a good point david i mean

00:07:28,000 --> 00:07:31,360
do you do either in space isolation

00:07:30,080 --> 00:07:33,759
right you guarantee that

00:07:31,360 --> 00:07:35,680
you cannot access or you basically if

00:07:33,759 --> 00:07:37,680
you allow access then it doesn't have to

00:07:35,680 --> 00:07:40,800
make sense right so that's basically the

00:07:37,680 --> 00:07:43,840
content isolation right so to speak

00:07:40,800 --> 00:07:45,280
yeah i mean to take it a step a step

00:07:43,840 --> 00:07:46,960
higher right there's kind of four

00:07:45,280 --> 00:07:48,720
general types of isolation you could

00:07:46,960 --> 00:07:50,000
have physical isolation which would be

00:07:48,720 --> 00:07:50,879
running on two different machines

00:07:50,000 --> 00:07:52,960
obviously

00:07:50,879 --> 00:07:53,759
you know that's not what we're doing

00:07:52,960 --> 00:07:55,039
otherwise we wouldn't have

00:07:53,759 --> 00:07:56,960
virtualization

00:07:55,039 --> 00:07:58,400
there's temporal isolation of running

00:07:56,960 --> 00:08:00,479
one workload and then

00:07:58,400 --> 00:08:02,319
sort of getting rid of all the traces of

00:08:00,479 --> 00:08:04,400
it and then running a second workload

00:08:02,319 --> 00:08:06,240
and then you have the logical isolation

00:08:04,400 --> 00:08:06,879
and the cryptographic and i think that

00:08:06,240 --> 00:08:09,199
for

00:08:06,879 --> 00:08:10,720
confidential computing the logical

00:08:09,199 --> 00:08:11,680
isolation and the cryptographic make the

00:08:10,720 --> 00:08:15,919
most sense

00:08:11,680 --> 00:08:15,919
but all of them you know have trade-offs

00:08:19,599 --> 00:08:24,639
okay thank you and this leads us on to

00:08:22,639 --> 00:08:26,319
kind of the the final encrypted vms

00:08:24,639 --> 00:08:29,120
question and that is

00:08:26,319 --> 00:08:31,199
about this mechanism is designed to

00:08:29,120 --> 00:08:34,320
provide confidentiality

00:08:31,199 --> 00:08:35,039
but what do we do or what what does the

00:08:34,320 --> 00:08:39,039
software

00:08:35,039 --> 00:08:40,880
and the hardware do in order to mitigate

00:08:39,039 --> 00:08:42,080
issues that might be discovered later on

00:08:40,880 --> 00:08:44,320
in these designs

00:08:42,080 --> 00:08:45,839
how do you what should users do in order

00:08:44,320 --> 00:08:49,839
to protect themselves and not put all

00:08:45,839 --> 00:08:49,839
their eggs in one basket relying on this

00:08:52,839 --> 00:08:56,160
mechanism

00:08:54,240 --> 00:08:57,600
yeah it's a good question i i i can take

00:08:56,160 --> 00:09:00,240
a stab at it but i don't want to

00:08:57,600 --> 00:09:01,279
dominate the conversation on this uh

00:09:00,240 --> 00:09:03,279
certainly

00:09:01,279 --> 00:09:04,399
you know it is prudent to think about

00:09:03,279 --> 00:09:07,920
that scenario

00:09:04,399 --> 00:09:09,440
and uh i know at amd we've

00:09:07,920 --> 00:09:11,200
done some work especially with our newer

00:09:09,440 --> 00:09:13,920
technologies to try to provide

00:09:11,200 --> 00:09:15,519
stronger guarantees around mutable

00:09:13,920 --> 00:09:17,760
components in the architecture

00:09:15,519 --> 00:09:18,560
it's very common in these kind of setups

00:09:17,760 --> 00:09:21,680
to have

00:09:18,560 --> 00:09:23,200
some firmware or or you know trusted

00:09:21,680 --> 00:09:25,519
components that can be upgraded in the

00:09:23,200 --> 00:09:27,519
field which is great for fixing bugs

00:09:25,519 --> 00:09:29,680
but then you do have to deal with the

00:09:27,519 --> 00:09:31,040
issue of how do you prove that

00:09:29,680 --> 00:09:32,880
you're actually running the version that

00:09:31,040 --> 00:09:35,440
you need to be running

00:09:32,880 --> 00:09:36,320
and so we've taken some steps recently

00:09:35,440 --> 00:09:37,920
to

00:09:36,320 --> 00:09:39,279
create more of an architecture around

00:09:37,920 --> 00:09:40,880
that where there's actually a

00:09:39,279 --> 00:09:42,800
cryptographic proof

00:09:40,880 --> 00:09:45,120
of what version you're running and that

00:09:42,800 --> 00:09:46,800
can help ensure that we are able to

00:09:45,120 --> 00:09:48,160
deploy patches when needed

00:09:46,800 --> 00:09:50,640
and you can be assured that you're

00:09:48,160 --> 00:09:51,120
running with them the other thing which

00:09:50,640 --> 00:09:52,880
i'll just

00:09:51,120 --> 00:09:54,240
you know kind of give a call out to the

00:09:52,880 --> 00:09:56,480
the red hat folks here

00:09:54,240 --> 00:09:58,560
is uh red hat has a very interesting

00:09:56,480 --> 00:10:01,360
project called anarchs

00:09:58,560 --> 00:10:02,959
and as i understand their their vision

00:10:01,360 --> 00:10:04,480
one of the goals is that

00:10:02,959 --> 00:10:06,160
sort of you write your application and

00:10:04,480 --> 00:10:08,000
then it can run on

00:10:06,160 --> 00:10:11,839
multiple different backends whether it's

00:10:08,000 --> 00:10:14,560
amd suv or intel sgx or even arm

00:10:11,839 --> 00:10:15,760
and so you know sort of the question of

00:10:14,560 --> 00:10:17,360
how do you avoid putting all your eggs

00:10:15,760 --> 00:10:19,920
in one basket

00:10:17,360 --> 00:10:21,120
well if you do have a infrastructure

00:10:19,920 --> 00:10:22,640
like that

00:10:21,120 --> 00:10:24,240
and you wake up one day and you discover

00:10:22,640 --> 00:10:25,360
there's a zero day in one vendor's

00:10:24,240 --> 00:10:27,120
technology then it

00:10:25,360 --> 00:10:28,480
becomes very easy to just switch your

00:10:27,120 --> 00:10:30,480
target to a different one

00:10:28,480 --> 00:10:32,800
and so i think that's a very uh very

00:10:30,480 --> 00:10:34,720
interesting approach

00:10:32,800 --> 00:10:36,640
yeah i was going to mention nrx as well

00:10:34,720 --> 00:10:38,079
of course nrx is based on web assembly

00:10:36,640 --> 00:10:40,160
which is as i intended how they're going

00:10:38,079 --> 00:10:47,839
to do this portability between

00:10:40,160 --> 00:10:47,839
completely different platforms

00:10:50,240 --> 00:10:56,480
okay thank you um we have a

00:10:53,519 --> 00:10:58,399
slightly related topic uh about cloud

00:10:56,480 --> 00:10:59,519
and about hardware about new hardware

00:10:58,399 --> 00:11:01,040
innovations

00:10:59,519 --> 00:11:02,880
and the question is about with

00:11:01,040 --> 00:11:04,800
hyperscale clouds building

00:11:02,880 --> 00:11:06,640
their own silicon hardware and i guess

00:11:04,800 --> 00:11:08,399
it's talking about tier one cloud

00:11:06,640 --> 00:11:11,360
providers who are able to

00:11:08,399 --> 00:11:12,640
optimize everything to the to the last

00:11:11,360 --> 00:11:14,880
few percent

00:11:12,640 --> 00:11:16,320
and are able to deploy custom hardware

00:11:14,880 --> 00:11:18,240
for their cloud

00:11:16,320 --> 00:11:19,839
how do we keep users of commodity

00:11:18,240 --> 00:11:22,320
hardware happy

00:11:19,839 --> 00:11:23,200
um what what this is an open-ended

00:11:22,320 --> 00:11:24,560
question so

00:11:23,200 --> 00:11:28,560
i don't know if you have any thoughts in

00:11:24,560 --> 00:11:30,399
this area

00:11:28,560 --> 00:11:32,880
yeah i can i can take a you know first

00:11:30,399 --> 00:11:37,120
step on this one so i think that's uh

00:11:32,880 --> 00:11:38,640
it's really the um you know the level

00:11:37,120 --> 00:11:39,040
and the pace of the innovation you can

00:11:38,640 --> 00:11:40,480
drive

00:11:39,040 --> 00:11:42,320
right to make sure your customer

00:11:40,480 --> 00:11:45,120
workload can run

00:11:42,320 --> 00:11:46,240
well on your platform so i think that's

00:11:45,120 --> 00:11:48,560
involves a lot of

00:11:46,240 --> 00:11:49,360
you know deep engagement with your

00:11:48,560 --> 00:11:52,480
customers

00:11:49,360 --> 00:11:54,639
to really understand um you know

00:11:52,480 --> 00:11:56,079
what their workload the characteristics

00:11:54,639 --> 00:11:57,839
and how the you know

00:11:56,079 --> 00:12:00,240
we can design in the hallway in a way

00:11:57,839 --> 00:12:02,800
that is uh able to support all this

00:12:00,240 --> 00:12:04,240
software workload and also i think

00:12:02,800 --> 00:12:06,880
another thing is um

00:12:04,240 --> 00:12:07,920
you know for this um you know this uh

00:12:06,880 --> 00:12:10,560
kamali hardware

00:12:07,920 --> 00:12:12,320
and the terminology here i think we

00:12:10,560 --> 00:12:14,240
actually are targeting um

00:12:12,320 --> 00:12:16,000
you know we're having a large deployment

00:12:14,240 --> 00:12:18,560
uh you know that's the base

00:12:16,000 --> 00:12:19,360
and we're talking a wide range of uh you

00:12:18,560 --> 00:12:22,160
know the

00:12:19,360 --> 00:12:25,279
uh segments right for example the um you

00:12:22,160 --> 00:12:27,920
know the client devices the iot edge

00:12:25,279 --> 00:12:28,959
and also um you know the all the way to

00:12:27,920 --> 00:12:32,560
the data center

00:12:28,959 --> 00:12:33,120
so i think this um brings us a very

00:12:32,560 --> 00:12:36,000
unique

00:12:33,120 --> 00:12:37,360
uh you know end-to-end advantage to

00:12:36,000 --> 00:12:39,279
allow us to

00:12:37,360 --> 00:12:42,079
you know have a better um you know

00:12:39,279 --> 00:12:44,959
workload workload compatibility across

00:12:42,079 --> 00:12:45,360
you know the full stack and um you know

00:12:44,959 --> 00:12:47,120
the

00:12:45,360 --> 00:12:48,720
uh we can optimize for the end-to-end

00:12:47,120 --> 00:12:50,320
use it brings us more opportunity to

00:12:48,720 --> 00:12:51,040
optimize for the end-to-end stack as

00:12:50,320 --> 00:12:53,279
well

00:12:51,040 --> 00:12:55,120
and another thing is i think beyond the

00:12:53,279 --> 00:12:56,880
um you know in this

00:12:55,120 --> 00:12:58,560
commodity hardware space we're also

00:12:56,880 --> 00:12:59,519
offering accelerators various

00:12:58,560 --> 00:13:02,000
accelerators

00:12:59,519 --> 00:13:02,720
for uh your um you know the customer

00:13:02,000 --> 00:13:05,040
specific

00:13:02,720 --> 00:13:06,800
usage the second special usage so you

00:13:05,040 --> 00:13:09,120
can kind of tune the hardware

00:13:06,800 --> 00:13:11,279
and uh using acceleration to optimize

00:13:09,120 --> 00:13:14,320
your you know software

00:13:11,279 --> 00:13:15,920
thank you so uh stefan this actually

00:13:14,320 --> 00:13:17,760
also goes back to the previous question

00:13:15,920 --> 00:13:19,680
how do you basically not put all your

00:13:17,760 --> 00:13:21,200
eggs in one basket right it basically

00:13:19,680 --> 00:13:22,880
means you have to move up the chain you

00:13:21,200 --> 00:13:25,279
have to use portable libraries

00:13:22,880 --> 00:13:27,279
right and for instance when you take

00:13:25,279 --> 00:13:29,760
machine learning as an example right

00:13:27,279 --> 00:13:31,360
people have basically uh joined

00:13:29,760 --> 00:13:33,200
effectively the tensorflow

00:13:31,360 --> 00:13:35,279
community right that becomes ultimately

00:13:33,200 --> 00:13:36,399
my my portability platform so to speak

00:13:35,279 --> 00:13:38,880
right and underneath you

00:13:36,399 --> 00:13:41,120
essentially build now devices that uh

00:13:38,880 --> 00:13:41,760
effectively uh cater to exactly that

00:13:41,120 --> 00:13:44,560
interface

00:13:41,760 --> 00:13:45,920
right so you step away from specific

00:13:44,560 --> 00:13:48,560
hardware where you can

00:13:45,920 --> 00:13:50,639
number one right uh that kind of at

00:13:48,560 --> 00:13:51,760
least the end users are somewhat

00:13:50,639 --> 00:13:54,399
isolated from from

00:13:51,760 --> 00:13:55,120
hardware changes then right but we also

00:13:54,399 --> 00:13:57,600
see that

00:13:55,120 --> 00:13:59,199
particular with hardware these in the

00:13:57,600 --> 00:14:00,560
cloud space more and more things are

00:13:59,199 --> 00:14:03,600
basically driven down

00:14:00,560 --> 00:14:05,760
out of the os space per se and being

00:14:03,600 --> 00:14:06,560
driven down into the hardware devices

00:14:05,760 --> 00:14:08,639
themselves

00:14:06,560 --> 00:14:10,160
right network cards becoming

00:14:08,639 --> 00:14:12,320
significantly more capable with the

00:14:10,160 --> 00:14:13,839
virtualization capabilities right

00:14:12,320 --> 00:14:15,440
and ultimately they don't even shine

00:14:13,839 --> 00:14:17,519
through to the to the

00:14:15,440 --> 00:14:18,880
end users that's let's say it's a vm

00:14:17,519 --> 00:14:22,079
it's only the very

00:14:18,880 --> 00:14:23,440
high-end vms such as for utilized for

00:14:22,079 --> 00:14:25,279
hpc and so on that

00:14:23,440 --> 00:14:26,880
are effectively interested in getting

00:14:25,279 --> 00:14:29,040
access to a much lower

00:14:26,880 --> 00:14:31,839
interface for instance to run dpdk or

00:14:29,040 --> 00:14:31,839
something of that nature

00:14:33,920 --> 00:14:37,360
thank you i i think that maybe maybe

00:14:36,800 --> 00:14:39,600
peter

00:14:37,360 --> 00:14:40,720
has an interesting perspective to share

00:14:39,600 --> 00:14:45,199
here because

00:14:40,720 --> 00:14:47,920
with from the arm architecture what

00:14:45,199 --> 00:14:49,040
an area where arm was extremely um

00:14:47,920 --> 00:14:52,160
successful

00:14:49,040 --> 00:14:54,160
is in allowing um the integration of

00:14:52,160 --> 00:14:55,680
custom systems on chips and custom

00:14:54,160 --> 00:14:59,199
boards

00:14:55,680 --> 00:15:01,360
and yet they ended up also providing a

00:14:59,199 --> 00:15:03,199
standard server platform

00:15:01,360 --> 00:15:04,480
um so i don't know peter if you want to

00:15:03,199 --> 00:15:05,839
kind of

00:15:04,480 --> 00:15:07,680
if you have any thoughts on this because

00:15:05,839 --> 00:15:09,120
it's kind of interesting that arm has

00:15:07,680 --> 00:15:11,120
evolved into the

00:15:09,120 --> 00:15:13,040
offering a standard server platform for

00:15:11,120 --> 00:15:16,000
for for maybe having a more

00:15:13,040 --> 00:15:18,320
commodity you could say um hardware

00:15:16,000 --> 00:15:21,360
environment versus the

00:15:18,320 --> 00:15:22,399
versus the custom designs that uh arm is

00:15:21,360 --> 00:15:25,120
also extremely

00:15:22,399 --> 00:15:26,560
popular in well so i'll start this off

00:15:25,120 --> 00:15:28,079
with the disclaimer that i'm not an

00:15:26,560 --> 00:15:30,480
expert in this area of

00:15:28,079 --> 00:15:31,360
how harm does stuff but i think my my

00:15:30,480 --> 00:15:33,519
view of

00:15:31,360 --> 00:15:35,440
what has gone on with arm has basically

00:15:33,519 --> 00:15:37,920
been there's a balancing act here

00:15:35,440 --> 00:15:40,639
so different companies that want to use

00:15:37,920 --> 00:15:41,920
bits of arm hardware and build their

00:15:40,639 --> 00:15:43,360
systems around it

00:15:41,920 --> 00:15:45,199
they want to have things that they want

00:15:43,360 --> 00:15:46,320
to do that is that's the difference that

00:15:45,199 --> 00:15:48,000
they bring to it

00:15:46,320 --> 00:15:49,600
but you also want to have a common

00:15:48,000 --> 00:15:51,440
ground which is what arm provides in the

00:15:49,600 --> 00:15:55,279
architecture itself

00:15:51,440 --> 00:15:57,519
so that the idea is that it's different

00:15:55,279 --> 00:15:59,600
where the difference really is

00:15:57,519 --> 00:16:00,959
significantly useful and where it isn't

00:15:59,600 --> 00:16:02,320
so

00:16:00,959 --> 00:16:04,000
where it doesn't matter so much you try

00:16:02,320 --> 00:16:05,920
and avoid those differences and it says

00:16:04,000 --> 00:16:07,120
you can gradually standardize things

00:16:05,920 --> 00:16:09,279
and i think that's definitely you can

00:16:07,120 --> 00:16:11,920
see that in the server space

00:16:09,279 --> 00:16:12,800
where the server space is much less

00:16:11,920 --> 00:16:16,480
tolerant of

00:16:12,800 --> 00:16:18,160
random weird stuff and so

00:16:16,480 --> 00:16:20,240
there are a bunch of things like

00:16:18,160 --> 00:16:23,120
server-based system architecture

00:16:20,240 --> 00:16:24,720
specs that standardize that so that if

00:16:23,120 --> 00:16:26,399
you've got a distro you can run that

00:16:24,720 --> 00:16:27,360
distro on whatever server highway you

00:16:26,399 --> 00:16:28,880
like

00:16:27,360 --> 00:16:30,480
but there are also people in the server

00:16:28,880 --> 00:16:32,480
space who while yes they're

00:16:30,480 --> 00:16:34,880
doing standard systems they're still

00:16:32,480 --> 00:16:37,680
putting some of their own

00:16:34,880 --> 00:16:38,880
magic source in there to because that's

00:16:37,680 --> 00:16:39,920
that's the point that that's why they're

00:16:38,880 --> 00:16:42,000
not they don't want to just build

00:16:39,920 --> 00:16:43,839
something completely off the shelf

00:16:42,000 --> 00:16:46,480
so you've got to make maintain a balance

00:16:43,839 --> 00:16:46,480
there i think

00:16:49,519 --> 00:16:54,399
thank you okay so

00:16:52,639 --> 00:16:55,759
one of the topics we have is cpu

00:16:54,399 --> 00:16:57,519
architectures and

00:16:55,759 --> 00:16:59,519
um that's always an interesting one for

00:16:57,519 --> 00:17:00,639
kvm because kvm supports multiple

00:16:59,519 --> 00:17:02,399
architectures that implement

00:17:00,639 --> 00:17:03,600
virtualization in different ways they

00:17:02,399 --> 00:17:05,280
have different instructions set

00:17:03,600 --> 00:17:07,439
extensions and approaches

00:17:05,280 --> 00:17:08,880
to the virtualization hardware features

00:17:07,439 --> 00:17:10,679
so

00:17:08,880 --> 00:17:12,640
where do you see potential

00:17:10,679 --> 00:17:14,400
cross-architectural collaboration

00:17:12,640 --> 00:17:16,079
uh for example with encrypted and

00:17:14,400 --> 00:17:17,839
isolated guests

00:17:16,079 --> 00:17:20,160
all doing their own things are things

00:17:17,839 --> 00:17:22,640
going to converge or

00:17:20,160 --> 00:17:24,559
what areas do you see where maybe in kvm

00:17:22,640 --> 00:17:28,000
we can

00:17:24,559 --> 00:17:28,000
have common infrastructure

00:17:29,360 --> 00:17:34,400
so in terms of kvm and one of the when

00:17:32,480 --> 00:17:37,200
we look for instance the encrypted vms

00:17:34,400 --> 00:17:40,000
right i mean there's amd suv

00:17:37,200 --> 00:17:42,160
intel tdx for instance is going to be uh

00:17:40,000 --> 00:17:45,200
coming out was announced last month as

00:17:42,160 --> 00:17:46,080
a result as an example the whole level

00:17:45,200 --> 00:17:47,840
of key management

00:17:46,080 --> 00:17:49,760
right i mean in confidential computing

00:17:47,840 --> 00:17:52,080
you cannot have any of your data or any

00:17:49,760 --> 00:17:52,559
of your keys in in the in the open that

00:17:52,080 --> 00:17:54,720
means

00:17:52,559 --> 00:17:56,000
uh from a service provider as well as

00:17:54,720 --> 00:17:57,520
from ad customer i need to have an

00:17:56,000 --> 00:17:58,160
infrastructure in place that allows me

00:17:57,520 --> 00:18:00,160
to

00:17:58,160 --> 00:18:01,919
shuffle keys around in a secure fashion

00:18:00,160 --> 00:18:02,799
that is not being exposed to the service

00:18:01,919 --> 00:18:07,440
provider

00:18:02,799 --> 00:18:10,720
okay there i believe is an ability to uh

00:18:07,440 --> 00:18:11,520
to uh have a common ground uh as david

00:18:10,720 --> 00:18:13,840
knows

00:18:11,520 --> 00:18:15,840
features like once in vm migration right

00:18:13,840 --> 00:18:16,720
which essentially has to go at the lower

00:18:15,840 --> 00:18:19,520
level

00:18:16,720 --> 00:18:20,960
uh and again encrypt or shuttle

00:18:19,520 --> 00:18:23,520
encrypted data around

00:18:20,960 --> 00:18:24,960
uh seems to be there is a commonality

00:18:23,520 --> 00:18:26,480
among architectures

00:18:24,960 --> 00:18:29,039
right for instance when they're using

00:18:26,480 --> 00:18:31,840
encryption keys as discussed earlier on

00:18:29,039 --> 00:18:32,720
right again that would be provided in a

00:18:31,840 --> 00:18:36,559
more generic

00:18:32,720 --> 00:18:38,080
feature i think going further into

00:18:36,559 --> 00:18:40,960
architectures the whole

00:18:38,080 --> 00:18:42,640
area of encrypted io right i strongly

00:18:40,960 --> 00:18:43,840
believe that particularly in the cloud

00:18:42,640 --> 00:18:46,240
that

00:18:43,840 --> 00:18:48,080
i o devices will largely be become

00:18:46,240 --> 00:18:52,080
completely as i re-enabled

00:18:48,080 --> 00:18:53,600
with offload functions and that these uh

00:18:52,080 --> 00:18:55,600
virtual functions so to speak can be

00:18:53,600 --> 00:18:57,840
reached through to the virtual

00:18:55,600 --> 00:18:58,720
interfaces or the virtual agents running

00:18:57,840 --> 00:19:01,760
uh

00:18:58,720 --> 00:19:03,919
virtual clients vms containers

00:19:01,760 --> 00:19:06,080
will directly access the i o devices to

00:19:03,919 --> 00:19:08,559
bypass the operating system right

00:19:06,080 --> 00:19:10,400
so again along that path the whole setup

00:19:08,559 --> 00:19:13,679
of having a

00:19:10,400 --> 00:19:14,320
clearly secure encrypted channel will be

00:19:13,679 --> 00:19:16,240
important

00:19:14,320 --> 00:19:17,440
right again many of these things have to

00:19:16,240 --> 00:19:20,480
be set up by qmu

00:19:17,440 --> 00:19:22,840
at the end of the day right and there

00:19:20,480 --> 00:19:25,120
seems to be commonality across different

00:19:22,840 --> 00:19:27,280
architectures

00:19:25,120 --> 00:19:28,160
yeah i think that's a good point you

00:19:27,280 --> 00:19:30,240
know i think that

00:19:28,160 --> 00:19:31,600
it's unlikely that we'll see much

00:19:30,240 --> 00:19:32,640
commonality when it comes to harbor

00:19:31,600 --> 00:19:34,320
implementation just

00:19:32,640 --> 00:19:35,760
sort of because the business reality of

00:19:34,320 --> 00:19:38,480
that but

00:19:35,760 --> 00:19:39,280
providing a uniform software interface

00:19:38,480 --> 00:19:41,360
kind of like what

00:19:39,280 --> 00:19:43,200
kvm already does for virtualization i

00:19:41,360 --> 00:19:46,880
think is very reasonable

00:19:43,200 --> 00:19:49,039
i think that you know ibm power also has

00:19:46,880 --> 00:19:50,559
some you know confidential computing

00:19:49,039 --> 00:19:52,160
technologies in it and i believe that

00:19:50,559 --> 00:19:53,679
there's already been some effort to

00:19:52,160 --> 00:19:55,520
to merge some of that with the work that

00:19:53,679 --> 00:19:56,799
amd's done just to share some of the

00:19:55,520 --> 00:19:59,200
code there

00:19:56,799 --> 00:20:00,320
so i think that yeah that's a that's

00:19:59,200 --> 00:20:03,840
going to be a

00:20:00,320 --> 00:20:05,600
good area especially as now more vendors

00:20:03,840 --> 00:20:07,280
have announced technologies and

00:20:05,600 --> 00:20:11,120
from an end-user standpoint i think they

00:20:07,280 --> 00:20:13,200
really appreciate a common interface

00:20:11,120 --> 00:20:14,480
yeah i very much agree on that i think a

00:20:13,200 --> 00:20:17,760
common interface is

00:20:14,480 --> 00:20:18,080
definitely the place we can have a lot

00:20:17,760 --> 00:20:20,960
of

00:20:18,080 --> 00:20:22,640
collaboration for enterprising in the um

00:20:20,960 --> 00:20:24,480
you know the encrypted vm space we're

00:20:22,640 --> 00:20:26,559
already seeing some

00:20:24,480 --> 00:20:28,159
uh good collaboration on you know for

00:20:26,559 --> 00:20:31,280
example how to define the

00:20:28,159 --> 00:20:33,360
exposure key management uh you know

00:20:31,280 --> 00:20:34,400
key id to the c group right how to

00:20:33,360 --> 00:20:36,640
abstract in a way

00:20:34,400 --> 00:20:38,559
that can support both you know the intel

00:20:36,640 --> 00:20:40,960
tdx and amg cv

00:20:38,559 --> 00:20:42,559
and i'm sure there's uh many other

00:20:40,960 --> 00:20:45,200
spaces as well for example

00:20:42,559 --> 00:20:47,039
hey for example on the you know for the

00:20:45,200 --> 00:20:50,240
encrypted vm technology today we

00:20:47,039 --> 00:20:52,240
require to um you know modify the guess

00:20:50,240 --> 00:20:54,480
os to collaborate with the hypervisor

00:20:52,240 --> 00:20:56,720
and currently the interfaces are

00:20:54,480 --> 00:20:59,039
different across the vendors right so

00:20:56,720 --> 00:21:00,880
um you know are we able to kind of have

00:20:59,039 --> 00:21:04,080
a unified interface that can

00:21:00,880 --> 00:21:06,080
you know certainly help our customers

00:21:04,080 --> 00:21:10,000
to deploy much easier i think that's

00:21:06,080 --> 00:21:10,000
definitely so maybe one area we can look

00:21:14,840 --> 00:21:21,039
into

00:21:17,520 --> 00:21:24,720
thank you so on this theme of software

00:21:21,039 --> 00:21:25,840
um you know common software interfaces

00:21:24,720 --> 00:21:27,520
and so on

00:21:25,840 --> 00:21:28,960
we have a question about management

00:21:27,520 --> 00:21:31,039
stacks and the question is

00:21:28,960 --> 00:21:32,480
what management stack do you have in

00:21:31,039 --> 00:21:35,600
place today is it

00:21:32,480 --> 00:21:36,559
levert based is it a custom qmu

00:21:35,600 --> 00:21:39,600
management tool

00:21:36,559 --> 00:21:41,760
and maybe even a custom virtual machine

00:21:39,600 --> 00:21:43,840
monitor that you're using instead of qmu

00:21:41,760 --> 00:21:46,480
and how has this changed over the past

00:21:43,840 --> 00:21:46,480
few years

00:21:50,400 --> 00:21:55,120
this is an easy one for for richard

00:21:52,480 --> 00:21:56,720
jones from red hat right

00:21:55,120 --> 00:21:59,200
i mean i i would turn this question

00:21:56,720 --> 00:22:02,320
around and say um

00:21:59,200 --> 00:22:03,120
how has libert itself changed and how is

00:22:02,320 --> 00:22:06,080
liver

00:22:03,120 --> 00:22:07,120
changing i mean liberte was this

00:22:06,080 --> 00:22:11,360
monolithic

00:22:07,120 --> 00:22:13,520
single node management demon

00:22:11,360 --> 00:22:14,799
and then we tried to you know fit that

00:22:13,520 --> 00:22:17,760
into the

00:22:14,799 --> 00:22:19,760
um to the kubernetes model where you're

00:22:17,760 --> 00:22:21,360
running everything in a pod

00:22:19,760 --> 00:22:23,200
um and then we came across problems

00:22:21,360 --> 00:22:23,679
should you know should each pod run its

00:22:23,200 --> 00:22:25,919
own

00:22:23,679 --> 00:22:28,320
copy of live verts and so on and and

00:22:25,919 --> 00:22:32,000
from that we started to basically

00:22:28,320 --> 00:22:35,039
um look at how we can make liver more

00:22:32,000 --> 00:22:38,240
not not so monolithic more separable uh

00:22:35,039 --> 00:22:39,600
move things like the the creation of the

00:22:38,240 --> 00:22:42,880
chemo command line

00:22:39,600 --> 00:22:44,320
out into separate libraries um

00:22:42,880 --> 00:22:45,840
i mean it's not something that i'm a

00:22:44,320 --> 00:22:46,400
huge expert on this because i'm not

00:22:45,840 --> 00:22:48,080
really

00:22:46,400 --> 00:22:49,840
directly involved in this although i am

00:22:48,080 --> 00:22:50,559
sort of using some of the fruits of this

00:22:49,840 --> 00:22:53,520
but

00:22:50,559 --> 00:22:53,980
certainly this question is in in a sense

00:22:53,520 --> 00:22:55,280
um

00:22:53,980 --> 00:22:57,360
[Music]

00:22:55,280 --> 00:22:58,559
backwards i guess because maybe if you

00:22:57,360 --> 00:22:59,919
if you thought that libber

00:22:58,559 --> 00:23:02,480
worked in a particular way it's like

00:22:59,919 --> 00:23:04,720
this huge monolithic demon well you know

00:23:02,480 --> 00:23:06,640
take another look at it now um it may be

00:23:04,720 --> 00:23:09,919
different from how you expect

00:23:06,640 --> 00:23:11,679
it it works yeah um and and i think the

00:23:09,919 --> 00:23:14,559
liver team's extremely

00:23:11,679 --> 00:23:16,400
aware of the sort of traditional model

00:23:14,559 --> 00:23:19,200
and the problems with that and

00:23:16,400 --> 00:23:21,360
and there's a huge push within red hat

00:23:19,200 --> 00:23:23,679
there's certainly no secret to

00:23:21,360 --> 00:23:25,919
to you know move everything towards

00:23:23,679 --> 00:23:29,280
kubernetes and open shift

00:23:25,919 --> 00:23:30,720
um and so you know the making liberte

00:23:29,280 --> 00:23:32,880
ronald openshift is like number one

00:23:30,720 --> 00:23:34,240
priority at the moment

00:23:32,880 --> 00:23:37,200
i hope that i hope that's the sufficient

00:23:34,240 --> 00:23:40,960
answer stephan but um

00:23:37,200 --> 00:23:43,600
thank you so i mean since i'm i'm

00:23:40,960 --> 00:23:45,760
with ibm cloud in a way right in a

00:23:43,600 --> 00:23:48,480
research organization right i do think

00:23:45,760 --> 00:23:48,960
we use libert basically as you can do it

00:23:48,480 --> 00:23:50,559
right

00:23:48,960 --> 00:23:52,400
it does give you additional lifecycle

00:23:50,559 --> 00:23:55,120
management not to have to do with the

00:23:52,400 --> 00:23:56,960
insane qmu command line interfaces right

00:23:55,120 --> 00:24:00,240
that everybody knows about

00:23:56,960 --> 00:24:01,200
um but uh let me turn the question a

00:24:00,240 --> 00:24:04,240
little bit around

00:24:01,200 --> 00:24:06,400
right which is essentially as a when you

00:24:04,240 --> 00:24:07,120
ask about vmms right we actually see

00:24:06,400 --> 00:24:09,840
that there's

00:24:07,120 --> 00:24:11,360
uh quite a bunch of activities like

00:24:09,840 --> 00:24:14,320
firecrackers intel

00:24:11,360 --> 00:24:16,000
uh cloud hypervisor vmms that are

00:24:14,320 --> 00:24:18,159
basically spawning up that are trying to

00:24:16,000 --> 00:24:20,080
move different technologies

00:24:18,159 --> 00:24:21,760
in so for instance many of them are rust

00:24:20,080 --> 00:24:23,279
based under the premise that rust is a

00:24:21,760 --> 00:24:23,840
better and more secure programming

00:24:23,279 --> 00:24:25,520
language

00:24:23,840 --> 00:24:26,960
right we're not going to go into detail

00:24:25,520 --> 00:24:29,120
here about that but

00:24:26,960 --> 00:24:30,080
it is out there this question right and

00:24:29,120 --> 00:24:32,320
so

00:24:30,080 --> 00:24:33,600
our focus has been more on the qmu side

00:24:32,320 --> 00:24:35,840
right uh you know it's a

00:24:33,600 --> 00:24:37,760
huge investment that has been made in in

00:24:35,840 --> 00:24:39,760
qru right over the

00:24:37,760 --> 00:24:41,679
many many years and we're trying to

00:24:39,760 --> 00:24:43,279
leverage that and basically addressing

00:24:41,679 --> 00:24:45,200
some of the concerns that people have

00:24:43,279 --> 00:24:47,679
raised with qmu which basically

00:24:45,200 --> 00:24:48,799
uh similar to lip word has been it's a

00:24:47,679 --> 00:24:52,400
pretty large entity

00:24:48,799 --> 00:24:53,679
uh of of code right and it also has gone

00:24:52,400 --> 00:24:55,039
through quite some life cycle it's much

00:24:53,679 --> 00:24:58,000
more configurable these days

00:24:55,039 --> 00:24:58,720
right and new techniques can be for

00:24:58,000 --> 00:25:01,360
instance be

00:24:58,720 --> 00:25:02,480
integrated into that particular code

00:25:01,360 --> 00:25:04,480
base so for instance

00:25:02,480 --> 00:25:06,080
in our end we're looking at control flow

00:25:04,480 --> 00:25:08,480
integrity you know we're having now

00:25:06,080 --> 00:25:10,240
hardware features coming with various

00:25:08,480 --> 00:25:12,080
architectures that allow us to do

00:25:10,240 --> 00:25:14,720
control flow integrity in hardware

00:25:12,080 --> 00:25:15,679
right need support for that in the

00:25:14,720 --> 00:25:18,400
compiling uh

00:25:15,679 --> 00:25:20,240
uh two chains right number one number

00:25:18,400 --> 00:25:20,880
two as you know stefan there's also the

00:25:20,240 --> 00:25:22,960
the

00:25:20,880 --> 00:25:24,400
proposals uh i think largely driven by

00:25:22,960 --> 00:25:26,799
you effectively right that

00:25:24,400 --> 00:25:28,640
essentially says okay can i take the

00:25:26,799 --> 00:25:30,640
somewhat configurable architecture that

00:25:28,640 --> 00:25:32,480
exists today in qmu and do a

00:25:30,640 --> 00:25:33,679
piecewise migration to uh new

00:25:32,480 --> 00:25:35,039
technologies like for instance

00:25:33,679 --> 00:25:38,320
introducing rust

00:25:35,039 --> 00:25:39,840
as an ios for io emulation right

00:25:38,320 --> 00:25:41,600
you don't want to have this monolithic

00:25:39,840 --> 00:25:42,000
code that once you have been broken in

00:25:41,600 --> 00:25:43,919
because

00:25:42,000 --> 00:25:45,440
maybe of a device driver bug or

00:25:43,919 --> 00:25:47,919
something of that nature

00:25:45,440 --> 00:25:49,039
right and to basically put your vmf at

00:25:47,919 --> 00:25:50,880
risk right so

00:25:49,039 --> 00:25:52,240
essentially compartmentalizing it is

00:25:50,880 --> 00:25:54,080
actually a very good idea

00:25:52,240 --> 00:25:56,320
and the io sub model exactly gives you

00:25:54,080 --> 00:25:59,279
that ability that's number one

00:25:56,320 --> 00:26:00,640
on the topic of uh next generations

00:25:59,279 --> 00:26:02,960
where i think

00:26:00,640 --> 00:26:05,120
we have seen that what used to be the

00:26:02,960 --> 00:26:07,120
more legacy vm technologies like okay

00:26:05,120 --> 00:26:08,799
here's your machine model emulated

00:26:07,120 --> 00:26:12,240
right we have now basically realized

00:26:08,799 --> 00:26:15,279
that the interactions between the vmm

00:26:12,240 --> 00:26:16,240
and the vm itself is very chatty right

00:26:15,279 --> 00:26:19,039
that's busy where

00:26:16,240 --> 00:26:19,840
uh devices like word io index sprung out

00:26:19,039 --> 00:26:22,000
right so you can

00:26:19,840 --> 00:26:24,000
maybe provide basically a more

00:26:22,000 --> 00:26:25,760
streamlined implementation

00:26:24,000 --> 00:26:27,679
and i believe more work can be done in

00:26:25,760 --> 00:26:29,039
that case at the end of the day and i

00:26:27,679 --> 00:26:30,240
think that's where some lessons can be

00:26:29,039 --> 00:26:34,000
learned from firecracker

00:26:30,240 --> 00:26:35,600
and into cloud hypervisor is to really

00:26:34,000 --> 00:26:37,360
in a cloud environment think about it

00:26:35,600 --> 00:26:38,320
what is my machine model that i really

00:26:37,360 --> 00:26:40,240
need

00:26:38,320 --> 00:26:42,720
do i actually need a do i really need a

00:26:40,240 --> 00:26:44,559
pci bus emulation

00:26:42,720 --> 00:26:46,880
right it's not clear to me we actually

00:26:44,559 --> 00:26:48,880
need that right if your machine model

00:26:46,880 --> 00:26:50,480
truly is just here's a bunch of word i o

00:26:48,880 --> 00:26:52,720
devices do i need this to be through a

00:26:50,480 --> 00:26:55,360
pci bus that is an architectural feature

00:26:52,720 --> 00:26:55,840
that's already being emulated so i think

00:26:55,360 --> 00:26:58,320
there's

00:26:55,840 --> 00:27:00,799
quite some research that can be done in

00:26:58,320 --> 00:27:00,799
that area

00:27:05,440 --> 00:27:12,080
thank you okay so

00:27:08,799 --> 00:27:14,400
we have a big bigger

00:27:12,080 --> 00:27:15,120
uh list of questions around the

00:27:14,400 --> 00:27:17,520
developer

00:27:15,120 --> 00:27:18,880
community and these are things from how

00:27:17,520 --> 00:27:21,919
do i get started

00:27:18,880 --> 00:27:24,799
to about the qme project itself

00:27:21,919 --> 00:27:25,760
to the process and how organizations are

00:27:24,799 --> 00:27:28,080
able to

00:27:25,760 --> 00:27:29,440
get features upstream and collaborate so

00:27:28,080 --> 00:27:32,880
we can

00:27:29,440 --> 00:27:33,679
take a look at some of them so the first

00:27:32,880 --> 00:27:35,840
one

00:27:33,679 --> 00:27:37,039
is about specialization versus

00:27:35,840 --> 00:27:38,960
generalization it's

00:27:37,039 --> 00:27:40,159
should developers work across the full

00:27:38,960 --> 00:27:42,000
virtualization stack

00:27:40,159 --> 00:27:43,600
or should they specialize on this

00:27:42,000 --> 00:27:46,880
particular component like

00:27:43,600 --> 00:27:48,080
kvm kernel module or qmu and how does

00:27:46,880 --> 00:27:51,200
this work today

00:27:48,080 --> 00:27:51,200
in your organization

00:27:53,279 --> 00:27:56,480
oh i can tell you i think that if you

00:27:54,720 --> 00:27:59,600
like oh sorry

00:27:56,480 --> 00:28:01,360
go ahead uh yeah so i think that

00:27:59,600 --> 00:28:03,039
some of that depends in terms of what

00:28:01,360 --> 00:28:05,039
you want to do it depends on your own

00:28:03,039 --> 00:28:07,120
preferences some some people really like

00:28:05,039 --> 00:28:09,120
being able to put together a complete

00:28:07,120 --> 00:28:10,799
feature by doing a little bit of work at

00:28:09,120 --> 00:28:13,039
every layer in the stack

00:28:10,799 --> 00:28:15,360
some i tend towards the other end of the

00:28:13,039 --> 00:28:17,279
thing i tend to like to

00:28:15,360 --> 00:28:18,559
look at one component and get quite

00:28:17,279 --> 00:28:20,799
deeply involved and

00:28:18,559 --> 00:28:22,480
knowledgeable about it and then just

00:28:20,799 --> 00:28:24,960
work on that one component so some of

00:28:22,480 --> 00:28:27,760
that is just personal preference

00:28:24,960 --> 00:28:28,480
um in terms of how does um work with

00:28:27,760 --> 00:28:31,520
this

00:28:28,480 --> 00:28:32,880
we tend more to be a bit more split up

00:28:31,520 --> 00:28:34,799
in terms of what i'm mostly doing

00:28:32,880 --> 00:28:36,080
chromium stuff and there are some peop

00:28:34,799 --> 00:28:38,240
other people who work for arm who are

00:28:36,080 --> 00:28:40,240
doing only the kernel stuff but

00:28:38,240 --> 00:28:41,840
that's kind of organizational reasons

00:28:40,240 --> 00:28:45,840
rather than because it's necessarily the

00:28:41,840 --> 00:28:45,840
most efficient way of doing it

00:28:47,360 --> 00:28:50,480
i i mean i think at red hat we have

00:28:49,440 --> 00:28:53,200
people who work

00:28:50,480 --> 00:28:54,159
you know in both that way and that way

00:28:53,200 --> 00:28:57,200
so they work

00:28:54,159 --> 00:28:58,559
some people work across all the layers

00:28:57,200 --> 00:29:01,200
of the stack and

00:28:58,559 --> 00:29:02,159
some concentrate on a single layer so

00:29:01,200 --> 00:29:03,520
it's so much down to

00:29:02,159 --> 00:29:05,360
the programmers and i think if you're

00:29:03,520 --> 00:29:07,760
talking if this question is really about

00:29:05,360 --> 00:29:10,720
how do we get new developers on board

00:29:07,760 --> 00:29:11,440
and should those developers go that way

00:29:10,720 --> 00:29:12,799
or that way

00:29:11,440 --> 00:29:14,799
i think it probably doesn't matter i

00:29:12,799 --> 00:29:15,840
mean getting new developers is the thing

00:29:14,799 --> 00:29:18,880
rather than

00:29:15,840 --> 00:29:20,720
um which particular way they work

00:29:18,880 --> 00:29:22,000
there certainly are features which we

00:29:20,720 --> 00:29:23,200
develop i mean almost

00:29:22,000 --> 00:29:26,080
all of the features i should think that

00:29:23,200 --> 00:29:29,440
go into kyomu sort of end up having a

00:29:26,080 --> 00:29:30,159
libert um component and then even

00:29:29,440 --> 00:29:33,600
perhaps a

00:29:30,159 --> 00:29:35,760
you know a manager or a cooper

00:29:33,600 --> 00:29:38,000
component on top of that so there may be

00:29:35,760 --> 00:29:42,159
sort of two or three

00:29:38,000 --> 00:29:45,520
different places languages

00:29:42,159 --> 00:29:47,120
um styles communities that

00:29:45,520 --> 00:29:49,360
that you have to interact with in order

00:29:47,120 --> 00:29:52,399
to get a single feature added

00:29:49,360 --> 00:29:56,720
whether or not this is a good thing um

00:29:52,399 --> 00:29:56,720
it has its it has its ups and downs

00:29:59,120 --> 00:30:02,240
speaking diplomatically

00:30:05,600 --> 00:30:09,120
um what about at intel how does that

00:30:08,000 --> 00:30:11,360
work they're

00:30:09,120 --> 00:30:12,960
contributing to say the linux kernel and

00:30:11,360 --> 00:30:16,720
the kvm kernel module

00:30:12,960 --> 00:30:19,120
versus qmu versus higher level project

00:30:16,720 --> 00:30:20,880
yeah i agree with what richard and peter

00:30:19,120 --> 00:30:24,399
said right i think it's just

00:30:20,880 --> 00:30:26,559
we need expertise um you know in both

00:30:24,399 --> 00:30:27,600
areas people who are concentrating on

00:30:26,559 --> 00:30:30,080
one component

00:30:27,600 --> 00:30:31,279
and the people who are you know able to

00:30:30,080 --> 00:30:33,520
look at the whole stack

00:30:31,279 --> 00:30:35,440
and drive the you know the system

00:30:33,520 --> 00:30:38,159
optimization system charge

00:30:35,440 --> 00:30:40,480
so i think both are very very important

00:30:38,159 --> 00:30:42,480
it really depends on you know the

00:30:40,480 --> 00:30:44,080
engineers what's the engineer's passion

00:30:42,480 --> 00:30:50,320
you know which way he likes better

00:30:44,080 --> 00:30:54,320
right and also where his talent is

00:30:50,320 --> 00:30:56,480
thank you um

00:30:54,320 --> 00:30:59,760
david did you want to add something um

00:30:56,480 --> 00:31:01,600
or should we move to the next question

00:30:59,760 --> 00:31:03,120
i i i don't know much to add i think

00:31:01,600 --> 00:31:05,279
what other folks said is

00:31:03,120 --> 00:31:07,679
is true you know i will just point out

00:31:05,279 --> 00:31:10,080
that at least when it comes to

00:31:07,679 --> 00:31:10,880
uh implementing new hardware features

00:31:10,080 --> 00:31:12,640
especially

00:31:10,880 --> 00:31:14,399
things like all this confidential

00:31:12,640 --> 00:31:15,919
computing stuff that really requires a

00:31:14,399 --> 00:31:19,039
full stack approach

00:31:15,919 --> 00:31:20,960
and so it does require that expertise of

00:31:19,039 --> 00:31:22,640
you know being able to know enough about

00:31:20,960 --> 00:31:25,440
all the components to actually

00:31:22,640 --> 00:31:28,480
fit things together so i certainly think

00:31:25,440 --> 00:31:28,480
that's a valuable skill

00:31:30,240 --> 00:31:34,240
excellent so the next question we have

00:31:32,240 --> 00:31:35,200
is how would you describe your process

00:31:34,240 --> 00:31:37,679
for developing

00:31:35,200 --> 00:31:39,919
new hardware features and enabling them

00:31:37,679 --> 00:31:41,360
in the linux and kvm software stack and

00:31:39,919 --> 00:31:47,840
how can it be improved i mean maybe

00:31:41,360 --> 00:31:47,840
there are some frustrations there

00:31:51,600 --> 00:31:56,399
uh maybe okay i can take a first step as

00:31:54,320 --> 00:31:58,799
this one right i think that's uh

00:31:56,399 --> 00:32:00,720
uh for designing our horror features is

00:31:58,799 --> 00:32:03,200
start with

00:32:00,720 --> 00:32:04,559
defining the the problem right so what

00:32:03,200 --> 00:32:08,000
problem are you trying to solve

00:32:04,559 --> 00:32:09,440
is this uh you know supporting a new

00:32:08,000 --> 00:32:11,919
emerging use case

00:32:09,440 --> 00:32:13,200
or you want to make the existing use

00:32:11,919 --> 00:32:16,240
case more

00:32:13,200 --> 00:32:19,519
for example more efficient and more

00:32:16,240 --> 00:32:22,000
you know secure right so um

00:32:19,519 --> 00:32:22,799
during this problem definition phase our

00:32:22,000 --> 00:32:25,760
software team

00:32:22,799 --> 00:32:27,360
actually works very closely to our

00:32:25,760 --> 00:32:30,559
hardware design team

00:32:27,360 --> 00:32:32,320
to give them input on you know hey what

00:32:30,559 --> 00:32:33,600
other you know pinpoints we see on the

00:32:32,320 --> 00:32:36,640
software side right

00:32:33,600 --> 00:32:38,000
and i i'm sure you know that's uh other

00:32:36,640 --> 00:32:39,200
vendors do the same thing you know the

00:32:38,000 --> 00:32:41,679
software team and also

00:32:39,200 --> 00:32:43,840
we get the input from our ecosystem

00:32:41,679 --> 00:32:45,840
partners on what other pinpoint they are

00:32:43,840 --> 00:32:47,039
observing right so this is a define the

00:32:45,840 --> 00:32:49,440
problem phase

00:32:47,039 --> 00:32:50,320
and then we were starting on the you

00:32:49,440 --> 00:32:52,240
know

00:32:50,320 --> 00:32:54,080
technology readiness kind of pace right

00:32:52,240 --> 00:32:55,279
so during the past finding doing the

00:32:54,080 --> 00:32:57,919
pocs

00:32:55,279 --> 00:32:59,760
to really make sure you know the um we

00:32:57,919 --> 00:33:02,080
have a hot you know sound

00:32:59,760 --> 00:33:02,960
you know our design and uh the hardware

00:33:02,080 --> 00:33:06,720
implementation

00:33:02,960 --> 00:33:09,360
is software friendly right so um

00:33:06,720 --> 00:33:10,240
and then that's uh when going to the um

00:33:09,360 --> 00:33:12,159
you know the

00:33:10,240 --> 00:33:13,360
um after the technical rate of phase we

00:33:12,159 --> 00:33:15,279
move on the

00:33:13,360 --> 00:33:17,760
assumption is approved then we go to the

00:33:15,279 --> 00:33:20,320
uh play pure office the plan of

00:33:17,760 --> 00:33:20,799
record phase right we will you know

00:33:20,320 --> 00:33:24,480
that's

00:33:20,799 --> 00:33:27,279
uh um such right that's

00:33:24,480 --> 00:33:29,600
uh uh have our engineering team will do

00:33:27,279 --> 00:33:30,960
the you know the pre-silicon enabling

00:33:29,600 --> 00:33:31,519
right before hallways are available

00:33:30,960 --> 00:33:34,000
we'll

00:33:31,519 --> 00:33:35,519
implement this in the example in a

00:33:34,000 --> 00:33:38,320
software simulation environment

00:33:35,519 --> 00:33:39,279
so to make sure we have you know code as

00:33:38,320 --> 00:33:42,640
possible

00:33:39,279 --> 00:33:45,840
and then we will uh submit this to the

00:33:42,640 --> 00:33:47,279
you know the open source community uh to

00:33:45,840 --> 00:33:49,200
get the community feedback on

00:33:47,279 --> 00:33:52,000
architecture on the implementation

00:33:49,200 --> 00:33:53,919
and after you know that's uh uh many

00:33:52,000 --> 00:33:56,480
many rounds of discussions and we just

00:33:53,919 --> 00:33:57,120
got emerged into the open source uh

00:33:56,480 --> 00:33:59,360
community

00:33:57,120 --> 00:34:01,120
right so this is the upstream part and

00:33:59,360 --> 00:34:04,320
then we were on the downstream part

00:34:01,120 --> 00:34:06,240
we will work a lot with our uh you know

00:34:04,320 --> 00:34:08,399
downstream partners like the redhead

00:34:06,240 --> 00:34:09,280
you know suse and other and our csp

00:34:08,399 --> 00:34:11,119
partners

00:34:09,280 --> 00:34:13,280
to make sure all these technologies can

00:34:11,119 --> 00:34:16,399
productize in your distro in their

00:34:13,280 --> 00:34:16,960
uh deployment so i think that's kind of

00:34:16,399 --> 00:34:19,760
the

00:34:16,960 --> 00:34:21,040
the high level flow of how we do you

00:34:19,760 --> 00:34:24,800
know how our future

00:34:21,040 --> 00:34:29,599
enabling um in terms of

00:34:24,800 --> 00:34:29,599
um improvement i think that's um

00:34:30,639 --> 00:34:34,320
as i say i think currently i see you

00:34:33,359 --> 00:34:36,240
know we

00:34:34,320 --> 00:34:38,159
our software team is already involved a

00:34:36,240 --> 00:34:38,800
lot in the howard future definition

00:34:38,159 --> 00:34:40,800
we'll do

00:34:38,800 --> 00:34:42,079
many kind of hardware software code

00:34:40,800 --> 00:34:44,960
design together

00:34:42,079 --> 00:34:46,960
um you know but i think that's given the

00:34:44,960 --> 00:34:49,760
more and more importance of the software

00:34:46,960 --> 00:34:50,720
you know so i think i'm looking for you

00:34:49,760 --> 00:34:53,599
know we can

00:34:50,720 --> 00:34:55,119
do more on the you know the software

00:34:53,599 --> 00:34:57,839
hardware code design side

00:34:55,119 --> 00:34:58,800
so to really um i think that's a lot of

00:34:57,839 --> 00:35:03,839
opportunity we

00:34:58,800 --> 00:35:03,839
we can kind of dig into in that space

00:35:06,160 --> 00:35:09,440
yeah i'll just add to say you know it's

00:35:08,720 --> 00:35:11,359
a challenge

00:35:09,440 --> 00:35:13,839
definitely especially because the

00:35:11,359 --> 00:35:16,480
hardware design cycles can be so long

00:35:13,839 --> 00:35:17,440
that by the time that feedback

00:35:16,480 --> 00:35:20,480
especially from the

00:35:17,440 --> 00:35:23,440
open source community is present then

00:35:20,480 --> 00:35:24,000
it's sort of too late to change things

00:35:23,440 --> 00:35:26,480
uh

00:35:24,000 --> 00:35:27,760
and you know that's that is a challenge

00:35:26,480 --> 00:35:29,680
that i'm not quite sure what the

00:35:27,760 --> 00:35:32,640
solution is you know certainly

00:35:29,680 --> 00:35:34,320
when you know company like amd is

00:35:32,640 --> 00:35:35,440
developing new hardware features we will

00:35:34,320 --> 00:35:37,920
have conversations

00:35:35,440 --> 00:35:39,520
with our software partners about those

00:35:37,920 --> 00:35:41,680
and get feedback

00:35:39,520 --> 00:35:43,359
but you know we don't typically have

00:35:41,680 --> 00:35:46,320
those conversations with

00:35:43,359 --> 00:35:48,079
the public mailing lists for kind of

00:35:46,320 --> 00:35:50,400
obvious reasons and i'm assuming that

00:35:48,079 --> 00:35:53,119
you know intel works similarly

00:35:50,400 --> 00:35:54,320
and so you know the the downside of that

00:35:53,119 --> 00:35:56,079
is that by the time that there is a

00:35:54,320 --> 00:35:58,160
discussion on public main list probably

00:35:56,079 --> 00:35:59,599
things are pretty well baked and there's

00:35:58,160 --> 00:36:01,359
there's less opportunities to

00:35:59,599 --> 00:36:02,960
incorporate feedback so

00:36:01,359 --> 00:36:04,480
you know i think that's something that

00:36:02,960 --> 00:36:04,880
it would be interesting to improve i'm

00:36:04,480 --> 00:36:06,320
not

00:36:04,880 --> 00:36:08,079
quite sure what that solution would look

00:36:06,320 --> 00:36:10,839
like but that is a

00:36:08,079 --> 00:36:13,200
sort of a gap i think in our design

00:36:10,839 --> 00:36:14,320
process i think it will be interesting

00:36:13,200 --> 00:36:16,400
to see what the

00:36:14,320 --> 00:36:19,040
risk five folks do with this and whether

00:36:16,400 --> 00:36:21,200
they manage to make a better

00:36:19,040 --> 00:36:22,960
job of the whole interaction given they

00:36:21,200 --> 00:36:24,400
don't they're not unlike the rest of us

00:36:22,960 --> 00:36:26,400
they're not working under that same set

00:36:24,400 --> 00:36:27,760
of restrictions so are they going to be

00:36:26,400 --> 00:36:29,839
able to make a

00:36:27,760 --> 00:36:32,720
better designs as a result that will be

00:36:29,839 --> 00:36:32,720
interesting to watch

00:36:35,839 --> 00:36:40,320
yeah so this whole thing seems like an

00:36:37,680 --> 00:36:43,280
area where amd or intel

00:36:40,320 --> 00:36:44,560
uh and ibm an arm need to come together

00:36:43,280 --> 00:36:46,560
and invent a time machine

00:36:44,560 --> 00:36:47,839
that way you can go back and not do the

00:36:46,560 --> 00:36:50,000
project that

00:36:47,839 --> 00:36:51,359
that didn't land so if you do that that

00:36:50,000 --> 00:36:53,200
would be that would be great i think

00:36:51,359 --> 00:36:54,880
that would be a good solution

00:36:53,200 --> 00:36:56,240
one way of dealing with this is to get

00:36:54,880 --> 00:36:58,240
early engineering

00:36:56,240 --> 00:37:00,000
into public hands so to speak either in

00:36:58,240 --> 00:37:01,119
a designated open source lab or

00:37:00,000 --> 00:37:03,280
something like this right

00:37:01,119 --> 00:37:05,280
obviously the problem as david pointed

00:37:03,280 --> 00:37:06,720
out like you often don't want to let

00:37:05,280 --> 00:37:08,800
your

00:37:06,720 --> 00:37:10,320
new ideas surface too early right for

00:37:08,800 --> 00:37:12,960
competitive reasons right

00:37:10,320 --> 00:37:14,880
understand that but at the same point uh

00:37:12,960 --> 00:37:17,359
you know getting some engineers on

00:37:14,880 --> 00:37:18,640
maybe even emulation software right i

00:37:17,359 --> 00:37:21,359
mean that

00:37:18,640 --> 00:37:22,320
that would already help right because

00:37:21,359 --> 00:37:23,760
you know once the

00:37:22,320 --> 00:37:25,119
hardware is big there's very little you

00:37:23,760 --> 00:37:27,760
can change anymore right and you have to

00:37:25,119 --> 00:37:27,760
work around it

00:37:32,720 --> 00:37:37,040
okay great thanks so um up next we have

00:37:36,160 --> 00:37:40,560
some questions

00:37:37,040 --> 00:37:43,359
about getting into open source

00:37:40,560 --> 00:37:44,880
um about new contributors joining the

00:37:43,359 --> 00:37:47,200
projects and so on so

00:37:44,880 --> 00:37:48,640
the first one is virtualization and

00:37:47,200 --> 00:37:50,960
systems programming

00:37:48,640 --> 00:37:52,880
is in general considered low level uh is

00:37:50,960 --> 00:37:54,160
a low-level software field

00:37:52,880 --> 00:37:56,320
that new developers may find

00:37:54,160 --> 00:37:57,760
inaccessible how do you recommend

00:37:56,320 --> 00:37:58,640
getting started in open source

00:37:57,760 --> 00:38:01,359
virtualization

00:37:58,640 --> 00:38:01,359
as a developer

00:38:03,599 --> 00:38:07,599
um stop stop submitting patches is

00:38:06,640 --> 00:38:09,680
really the

00:38:07,599 --> 00:38:11,040
the key here i mean i think some people

00:38:09,680 --> 00:38:13,200
um

00:38:11,040 --> 00:38:15,119
don't see the low level aspect as being

00:38:13,200 --> 00:38:16,560
a barrier but see it as

00:38:15,119 --> 00:38:19,119
something that's really interesting and

00:38:16,560 --> 00:38:22,000
exciting i mean you know anyone can

00:38:19,119 --> 00:38:23,119
develop web applications um but uh

00:38:22,000 --> 00:38:25,599
developing you know

00:38:23,119 --> 00:38:26,880
low-level bit banging hardware stuff is

00:38:25,599 --> 00:38:29,440
is uh

00:38:26,880 --> 00:38:31,040
a rare skill and exciting and

00:38:29,440 --> 00:38:33,119
interesting for many people so

00:38:31,040 --> 00:38:35,599
i don't see that being a barrier

00:38:33,119 --> 00:38:35,599
particularly

00:38:36,880 --> 00:38:40,400
yes i mean in some ways working at a low

00:38:39,040 --> 00:38:43,680
level is kind of it

00:38:40,400 --> 00:38:45,680
it's almost easier because if i'm

00:38:43,680 --> 00:38:47,040
working on emulation of some feature

00:38:45,680 --> 00:38:48,800
somebody has helpfully produced a

00:38:47,040 --> 00:38:50,720
several thousand page specification that

00:38:48,800 --> 00:38:51,440
says exactly what it needs to do i don't

00:38:50,720 --> 00:38:53,760
have to guess

00:38:51,440 --> 00:38:54,880
i don't have to do all this i don't have

00:38:53,760 --> 00:38:56,560
to deal with ui

00:38:54,880 --> 00:38:58,560
aspects very much which just as well

00:38:56,560 --> 00:39:00,000
because i'm terrible at them

00:38:58,560 --> 00:39:01,440
so in some ways it's quite easy it's

00:39:00,000 --> 00:39:02,079
like this the spec says this is what

00:39:01,440 --> 00:39:03,599
you've got to do

00:39:02,079 --> 00:39:05,839
you've just got to translate it all into

00:39:03,599 --> 00:39:09,680
code and hopefully it will work

00:39:05,839 --> 00:39:11,599
um i i think kind of the

00:39:09,680 --> 00:39:13,200
the barrier to entry with some of this

00:39:11,599 --> 00:39:14,880
is that

00:39:13,200 --> 00:39:17,040
software components like chrome you are

00:39:14,880 --> 00:39:19,359
now so huge we have millions of lines of

00:39:17,040 --> 00:39:21,440
code that it could be hard to

00:39:19,359 --> 00:39:23,119
get a grasp on where you should maybe

00:39:21,440 --> 00:39:26,720
start so i think my

00:39:23,119 --> 00:39:28,079
advice for that is not to try and grasp

00:39:26,720 --> 00:39:28,640
the whole thing in your brain at once

00:39:28,079 --> 00:39:30,560
because

00:39:28,640 --> 00:39:32,320
nobody on the project has a view of how

00:39:30,560 --> 00:39:34,480
the whole thing works

00:39:32,320 --> 00:39:35,680
but you kind of maybe you have a small

00:39:34,480 --> 00:39:38,079
outline of where

00:39:35,680 --> 00:39:39,680
roughly all the pieces are but mostly

00:39:38,079 --> 00:39:41,359
it's like ignore all the stuff that is

00:39:39,680 --> 00:39:42,640
not relevant to whatever feature you're

00:39:41,359 --> 00:39:46,640
trying to implement

00:39:42,640 --> 00:39:48,320
and just go ahead and try and

00:39:46,640 --> 00:39:49,520
deal with the bit look at the code that

00:39:48,320 --> 00:39:53,520
you need to look at and don't look at

00:39:49,520 --> 00:39:53,520
the other 900 000 lines basically

00:39:53,760 --> 00:39:56,800
one choice is to basically look at the

00:39:55,440 --> 00:39:59,119
open

00:39:56,800 --> 00:40:01,200
open issues list and and pick one that

00:39:59,119 --> 00:40:03,839
looks interesting that's number one

00:40:01,200 --> 00:40:05,839
number two well with rpms and things in

00:40:03,839 --> 00:40:07,920
many cases you can stand up the system

00:40:05,839 --> 00:40:09,760
into a running level and my favorite

00:40:07,920 --> 00:40:12,160
tool for that is basically just run it

00:40:09,760 --> 00:40:13,440
under debugger and hit control c and see

00:40:12,160 --> 00:40:15,280
where you end up

00:40:13,440 --> 00:40:17,200
right and that's often just walking the

00:40:15,280 --> 00:40:19,119
stack gives you a lot of insights into

00:40:17,200 --> 00:40:22,000
any uh any software system

00:40:19,119 --> 00:40:23,760
right and at least in in the past that's

00:40:22,000 --> 00:40:26,560
how i learned systems right really just

00:40:23,760 --> 00:40:28,560
hitting ctrl c at runtime and seeing

00:40:26,560 --> 00:40:31,760
where's the code currently stuck and

00:40:28,560 --> 00:40:31,760
what can i learn along the way

00:40:35,839 --> 00:40:40,800
cool thanks for sharing that um any any

00:40:38,319 --> 00:40:44,480
other suggestions on how to get started

00:40:40,800 --> 00:40:44,480
in open source virtualization

00:40:44,800 --> 00:40:49,760
i think the other thing i would say is

00:40:46,640 --> 00:40:53,200
to it helps a lot to come and talk to us

00:40:49,760 --> 00:40:54,640
um because we know the code base we know

00:40:53,200 --> 00:40:57,040
what kind of

00:40:54,640 --> 00:40:58,960
features seem like they're relatively

00:40:57,040 --> 00:41:01,359
tractable for somebody who's new

00:40:58,960 --> 00:41:03,760
and some parts of chrome u are to be

00:41:01,359 --> 00:41:05,440
honest just not very well maintained

00:41:03,760 --> 00:41:07,760
so if you're coming along and your idea

00:41:05,440 --> 00:41:11,119
is i'm going to contribute to

00:41:07,760 --> 00:41:12,480
um some parts of cremeu and it turns out

00:41:11,119 --> 00:41:13,920
that there's actually nobody else in the

00:41:12,480 --> 00:41:15,200
upstream community that's really working

00:41:13,920 --> 00:41:16,640
on that at the moment

00:41:15,200 --> 00:41:18,319
it's going to be much harder to find

00:41:16,640 --> 00:41:22,480
somebody to review your code or

00:41:18,319 --> 00:41:22,480
give you suggestions or whatever so

00:41:23,119 --> 00:41:25,760
if that's the thing you really really

00:41:24,319 --> 00:41:26,720
want to do then go ahead and do it but

00:41:25,760 --> 00:41:28,400
if you're kind of

00:41:26,720 --> 00:41:30,720
just interested in general and getting

00:41:28,400 --> 00:41:32,160
started then picking an area where there

00:41:30,720 --> 00:41:33,359
are other people working who can give

00:41:32,160 --> 00:41:35,839
you a helping hand i think it's

00:41:33,359 --> 00:41:35,839
important

00:41:44,000 --> 00:41:51,520
you so as a follow-up i think

00:41:47,359 --> 00:41:53,040
you mentioned um you know

00:41:51,520 --> 00:41:54,720
subsystems that are maintained to

00:41:53,040 --> 00:41:56,319
various degrees

00:41:54,720 --> 00:41:57,760
one of the interesting things that

00:41:56,319 --> 00:42:01,119
sometimes

00:41:57,760 --> 00:42:03,280
comes up in in upstream contributions

00:42:01,119 --> 00:42:05,119
is this difference in in the in the

00:42:03,280 --> 00:42:06,880
maybe quality or the amount of

00:42:05,119 --> 00:42:08,960
time that's been invested in different

00:42:06,880 --> 00:42:10,240
parts of qmu and we have a question here

00:42:08,960 --> 00:42:12,880
that says

00:42:10,240 --> 00:42:14,560
is qmu still accessible for hobbyists

00:42:12,880 --> 00:42:17,680
with limited time

00:42:14,560 --> 00:42:20,240
and i guess that may be referring to

00:42:17,680 --> 00:42:22,480
we have a lot of infrastructure in qmu

00:42:20,240 --> 00:42:25,520
that someone who's new and maybe

00:42:22,480 --> 00:42:26,160
only focused on one particular new

00:42:25,520 --> 00:42:29,520
feature

00:42:26,160 --> 00:42:32,079
would have to learn and then and and

00:42:29,520 --> 00:42:33,520
might not know um so what are your

00:42:32,079 --> 00:42:36,480
thoughts on on that

00:42:33,520 --> 00:42:38,720
how can we make qmu not just a good

00:42:36,480 --> 00:42:45,839
corporate open source project but also

00:42:38,720 --> 00:42:45,839
good for hobbyists

00:42:48,720 --> 00:42:53,040
there's always a bit of a dilemma with

00:42:50,079 --> 00:42:54,560
um with very large open source projects

00:42:53,040 --> 00:42:57,760
that you you have to put these

00:42:54,560 --> 00:43:00,880
kind of standards and codes of

00:42:57,760 --> 00:43:02,640
you know contributions and style guides

00:43:00,880 --> 00:43:04,880
in place

00:43:02,640 --> 00:43:06,480
because you you hope to increase the

00:43:04,880 --> 00:43:08,000
total quality of the code by doing that

00:43:06,480 --> 00:43:10,160
but you actually by doing that you also

00:43:08,000 --> 00:43:12,960
make it harder to contribute

00:43:10,160 --> 00:43:13,839
um i don't know if there's a really good

00:43:12,960 --> 00:43:17,119
answer to that

00:43:13,839 --> 00:43:20,240
really um except to probably make

00:43:17,119 --> 00:43:21,200
it more automated so that um

00:43:20,240 --> 00:43:24,079
you know even if people aren't

00:43:21,200 --> 00:43:26,079
necessarily fully aware of how to format

00:43:24,079 --> 00:43:27,280
their patch or something they can submit

00:43:26,079 --> 00:43:29,680
something and then they will get an

00:43:27,280 --> 00:43:31,920
automated return saying

00:43:29,680 --> 00:43:34,319
you know format it this way and then

00:43:31,920 --> 00:43:36,000
they can proceed in steps that way

00:43:34,319 --> 00:43:40,880
but i i don't think any project has

00:43:36,000 --> 00:43:42,960
really solved this very well

00:43:40,880 --> 00:43:44,720
yeah so i think that's it's got to be

00:43:42,960 --> 00:43:46,160
harder for hobbyists these days just

00:43:44,720 --> 00:43:49,680
because credibility is bigger

00:43:46,160 --> 00:43:50,160
and standards of we have gradually

00:43:49,680 --> 00:43:52,160
raised

00:43:50,160 --> 00:43:54,160
standards as you as you have to as comey

00:43:52,160 --> 00:43:56,000
has sort of morphed from being a here's

00:43:54,160 --> 00:43:57,280
a nice emulator toy to

00:43:56,000 --> 00:43:59,440
here's something that's actually going

00:43:57,280 --> 00:44:00,880
in people's uh

00:43:59,440 --> 00:44:02,640
service and that's got a security

00:44:00,880 --> 00:44:06,160
boundary and all the

00:44:02,640 --> 00:44:08,800
issues associated with it so it's harder

00:44:06,160 --> 00:44:09,150
i think it is still possible absolutely

00:44:08,800 --> 00:44:10,720
um

00:44:09,150 --> 00:44:12,800
[Music]

00:44:10,720 --> 00:44:14,560
but also the direction of the project is

00:44:12,800 --> 00:44:16,160
going to be influenced by

00:44:14,560 --> 00:44:17,760
who is putting in more hours and

00:44:16,160 --> 00:44:18,640
inevitably the corporate contributors

00:44:17,760 --> 00:44:21,119
are putting in

00:44:18,640 --> 00:44:22,560
the bulk of the hours and that's that's

00:44:21,119 --> 00:44:24,319
just the way it is

00:44:22,560 --> 00:44:26,960
i i do agree with richard that we could

00:44:24,319 --> 00:44:28,720
definitely do better about

00:44:26,960 --> 00:44:30,480
making our process easier we have a

00:44:28,720 --> 00:44:31,760
fairly old school process that's mostly

00:44:30,480 --> 00:44:33,359
borrowed from the way that the linux

00:44:31,760 --> 00:44:36,160
kernel tends to work

00:44:33,359 --> 00:44:36,960
and that is not very sort of 21st

00:44:36,160 --> 00:44:39,839
century

00:44:36,960 --> 00:44:41,040
friendly new contributors but changing

00:44:39,839 --> 00:44:50,240
process is very hard

00:44:41,040 --> 00:44:52,800
though so

00:44:50,240 --> 00:44:53,280
okay thank you we have some questions

00:44:52,800 --> 00:44:55,760
about

00:44:53,280 --> 00:44:57,760
containers and vms uh the combination of

00:44:55,760 --> 00:44:59,200
containers and vms or the choice between

00:44:57,760 --> 00:45:01,599
them or using both

00:44:59,200 --> 00:45:04,560
has been an interesting thing to see in

00:45:01,599 --> 00:45:06,560
the past few years

00:45:04,560 --> 00:45:08,720
so the question we have is how do you

00:45:06,560 --> 00:45:09,760
see the future usage of full machine

00:45:08,720 --> 00:45:12,880
virtualization

00:45:09,760 --> 00:45:15,680
evolving into the

00:45:12,880 --> 00:45:16,720
the the ongoing competition from

00:45:15,680 --> 00:45:19,839
container-based

00:45:16,720 --> 00:45:19,839
deployment models

00:45:20,640 --> 00:45:23,920
well i mean i think we've seen for a

00:45:22,000 --> 00:45:26,400
really long time particularly since

00:45:23,920 --> 00:45:28,480
intel's clear linux project has sort of

00:45:26,400 --> 00:45:30,240
morphed over time into cata containers

00:45:28,480 --> 00:45:33,440
that um

00:45:30,240 --> 00:45:36,720
there is a space for the two to coexist

00:45:33,440 --> 00:45:38,400
for um the virtualization technologies

00:45:36,720 --> 00:45:40,319
in that certainly in the hardware and

00:45:38,400 --> 00:45:42,560
the low levels of the stack

00:45:40,319 --> 00:45:44,160
to harden containers because then today

00:45:42,560 --> 00:45:46,480
containers aren't actually very secure

00:45:44,160 --> 00:45:49,680
and people are using them in a

00:45:46,480 --> 00:45:51,520
in the expectation that they are as

00:45:49,680 --> 00:45:52,240
secure as virtualization which i'm

00:45:51,520 --> 00:45:54,880
afraid they

00:45:52,240 --> 00:45:56,560
they aren't really um but with

00:45:54,880 --> 00:45:57,680
virtualization technologies at the

00:45:56,560 --> 00:45:59,920
bottom end you can

00:45:57,680 --> 00:46:02,720
actually give people that promise

00:45:59,920 --> 00:46:06,000
deliver on that promise so

00:46:02,720 --> 00:46:06,000
i think that's where it's going

00:46:06,880 --> 00:46:11,359
so i also think there's a there's a

00:46:09,599 --> 00:46:12,960
spectrum right i mean when you go from

00:46:11,359 --> 00:46:14,640
containers you have exactly the kernel

00:46:12,960 --> 00:46:16,720
exposures right i mean

00:46:14,640 --> 00:46:18,240
the various projects that we everyone's

00:46:16,720 --> 00:46:19,920
been pursuing and trying to figure out

00:46:18,240 --> 00:46:22,160
can we actually take some of the

00:46:19,920 --> 00:46:24,000
emerging virtualization techniques and

00:46:22,160 --> 00:46:25,920
isolation features that hardware provide

00:46:24,000 --> 00:46:26,720
us and basically drive them deeper into

00:46:25,920 --> 00:46:28,480
the kernel

00:46:26,720 --> 00:46:29,920
right so you have actually memory

00:46:28,480 --> 00:46:32,079
management techniques

00:46:29,920 --> 00:46:33,520
uh to isolate parts of the kernel

00:46:32,079 --> 00:46:34,880
because the kernel doesn't have to touch

00:46:33,520 --> 00:46:35,359
many of the data structures that the

00:46:34,880 --> 00:46:39,599
user

00:46:35,359 --> 00:46:39,599
uses right at the same time

00:46:40,000 --> 00:46:43,040
you're basically having a resource

00:46:41,280 --> 00:46:45,760
problem right containers are rather thin

00:46:43,040 --> 00:46:47,520
you love the uh the way of uh how

00:46:45,760 --> 00:46:49,839
containers are being managed right

00:46:47,520 --> 00:46:50,880
and uh slipping a vm underneath will

00:46:49,839 --> 00:46:52,800
cost you dearly

00:46:50,880 --> 00:46:54,079
right in terms of memory overhead and

00:46:52,800 --> 00:46:56,240
things like this

00:46:54,079 --> 00:46:58,240
so one way and i think qmu is already

00:46:56,240 --> 00:47:00,240
going after that is busy how you can

00:46:58,240 --> 00:47:01,920
get to thinner machines how can you make

00:47:00,240 --> 00:47:03,920
your distribution smaller

00:47:01,920 --> 00:47:05,599
right so that the overhead you're paying

00:47:03,920 --> 00:47:06,480
for a virtual machine backing a

00:47:05,599 --> 00:47:09,760
container

00:47:06,480 --> 00:47:11,040
is basically uh removed or not at least

00:47:09,760 --> 00:47:13,119
reduced

00:47:11,040 --> 00:47:14,880
right so there's basically across the

00:47:13,119 --> 00:47:16,560
stack many things that can be done to

00:47:14,880 --> 00:47:19,520
provide the customer choice

00:47:16,560 --> 00:47:20,720
right where you can still get the same

00:47:19,520 --> 00:47:23,280
way of managing

00:47:20,720 --> 00:47:24,160
uh your applications maybe through a

00:47:23,280 --> 00:47:26,240
container image

00:47:24,160 --> 00:47:27,520
right but at the same time provides

00:47:26,240 --> 00:47:31,040
increased

00:47:27,520 --> 00:47:32,240
increased security or even isolation

00:47:31,040 --> 00:47:34,480
right i mean there are

00:47:32,240 --> 00:47:35,760
various projects where we for instance

00:47:34,480 --> 00:47:39,119
the

00:47:35,760 --> 00:47:39,920
security features of sav or tdx can be

00:47:39,119 --> 00:47:41,680
basically

00:47:39,920 --> 00:47:44,800
raised with a vm to back a cutter

00:47:41,680 --> 00:47:44,800
container as an example

00:47:45,359 --> 00:47:48,480
yeah to me i think my personal opinion

00:47:47,280 --> 00:47:50,559
is i think this

00:47:48,480 --> 00:47:51,599
is to me i think this is not a final

00:47:50,559 --> 00:47:53,680
choice is a

00:47:51,599 --> 00:47:55,359
you know this is a vm or a container

00:47:53,680 --> 00:47:57,119
right to me i think that's uh

00:47:55,359 --> 00:47:58,400
this will be a kind of a blended

00:47:57,119 --> 00:48:01,280
technology so

00:47:58,400 --> 00:48:02,400
that's and the people may have a

00:48:01,280 --> 00:48:04,800
different usage

00:48:02,400 --> 00:48:06,240
requirement and then we will pick the um

00:48:04,800 --> 00:48:08,240
you know kind of technology that

00:48:06,240 --> 00:48:10,000
best suit for them right so for example

00:48:08,240 --> 00:48:13,440
i think today it's uh

00:48:10,000 --> 00:48:14,720
you know um uh you know it's already in

00:48:13,440 --> 00:48:16,559
the container space as

00:48:14,720 --> 00:48:18,480
richard and fr uh you know who just

00:48:16,559 --> 00:48:20,240
mentioned there was you know the

00:48:18,480 --> 00:48:22,240
ad using the vt technology the

00:48:20,240 --> 00:48:24,079
lightweight vm technology to improve the

00:48:22,240 --> 00:48:25,359
security and isolation for container

00:48:24,079 --> 00:48:27,359
right and also

00:48:25,359 --> 00:48:29,280
a lot of uh you know container i think

00:48:27,359 --> 00:48:31,520
80 percent of the container today that's

00:48:29,280 --> 00:48:32,960
running in the vm right so not one

00:48:31,520 --> 00:48:34,960
containing one vm but

00:48:32,960 --> 00:48:36,960
you know um you know they were pulsing

00:48:34,960 --> 00:48:38,880
the 1vm so i think that's uh

00:48:36,960 --> 00:48:40,559
um you know yeah i think it's not about

00:48:38,880 --> 00:48:40,960
the choice to me that's uh this kind of

00:48:40,559 --> 00:48:42,319
uh

00:48:40,960 --> 00:48:44,880
you know it was to be a blended

00:48:42,319 --> 00:48:44,880
technology

00:48:45,599 --> 00:48:48,720
yeah i i think i agree with that you

00:48:47,440 --> 00:48:50,559
know i think that the

00:48:48,720 --> 00:48:53,040
use cases of lightweight virtualization

00:48:50,559 --> 00:48:55,040
are really interesting with containers

00:48:53,040 --> 00:48:56,640
i also wonder what sort of the economic

00:48:55,040 --> 00:48:59,119
impact is going to be

00:48:56,640 --> 00:49:01,040
uh if it becomes just so much cheaper to

00:48:59,119 --> 00:49:02,400
run container-type workloads and

00:49:01,040 --> 00:49:04,960
especially in public clouds

00:49:02,400 --> 00:49:08,559
it could incentivize people to go even

00:49:04,960 --> 00:49:08,559
further down that path potentially

00:49:10,800 --> 00:49:14,800
okay well thanks a lot we're reaching

00:49:13,520 --> 00:49:16,960
the end of our time

00:49:14,800 --> 00:49:18,559
so i want to thank you all for being

00:49:16,960 --> 00:49:21,440
part of this panel

00:49:18,559 --> 00:49:23,040
and i hope that um this was a good

00:49:21,440 --> 00:49:25,119
discussion that everyone enjoyed thank

00:49:23,040 --> 00:49:28,559
you very much

00:49:25,119 --> 00:49:28,559
thank you thank you

00:49:28,839 --> 00:49:31,839

YouTube URL: https://www.youtube.com/watch?v=Ge_H4nf_h6w


