Title: [2020] Evolution of SPDK vhost Towards Secure Container Storage Service
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Secure container provides strong isolation for multi-tenant, serverless workloads. Generally, it is light VM based, like Kata containers and Firecracker. It is already used in production by top CSPs. Previously, SPDK vhost application has been widely adopted for storage virtualization. While SPDK applications are polling based, and require hugepage memory. But for container scenarios, host resources are always oversubscribed in order to serve thousands of light VMs. This means reserved hugepage and polling pinned CPU cores are hard to be tolerated. So SPDK vhost should keep evolving to fit the requirement from container scenarios. In this talk, we will go over what evolution SPDK vhost requires and how polling pinned CPU and hugepage are avoided. With the new improvement, SPDK vhost will be a good choice to provide storage service to secure containers.

---

Changpeng Liu
Intel, Senior Software Engineer

Changpeng Liu is a senior software engineer in Intel and a core maintainer of SPDK (storage performance development kit) project. His working areas include NVMe, NVMf, virtualization and block storage.

Xiaodong Liu
Intel, Senior Cloud Engineer

Xiaodong Liu is a senior cloud engineer at Intel, working on storage related areas like Storage Performance Development Kit (SPDK) and Intel Intelligent acceleration Library (ISA-L). He focuses on acceleration, protocols and innovations among virtualization, cloud native storage and userspace storage solutions.
Captions: 
	00:00:07,120 --> 00:00:11,360
hello everyone

00:00:08,960 --> 00:00:13,679
japan and i are coming from intel

00:00:11,360 --> 00:00:15,519
storage software team

00:00:13,679 --> 00:00:17,440
we are talking about the evolution of

00:00:15,519 --> 00:00:22,080
spk towards

00:00:17,440 --> 00:00:22,080
secure container storage service

00:00:23,600 --> 00:00:30,240
spdk is a storage performance

00:00:27,279 --> 00:00:31,199
development kit it provides a set of

00:00:30,240 --> 00:00:33,760
tools and

00:00:31,199 --> 00:00:34,640
libraries for writing high performance

00:00:33,760 --> 00:00:37,840
scalable

00:00:34,640 --> 00:00:41,840
user mode storage applications

00:00:37,840 --> 00:00:45,440
sdk vhost is one spk

00:00:41,840 --> 00:00:46,320
provided application as a high

00:00:45,440 --> 00:00:49,360
performance

00:00:46,320 --> 00:00:50,480
storage authorization solution with

00:00:49,360 --> 00:00:54,320
flexibility and

00:00:50,480 --> 00:00:57,520
robustness is already widely deployed by

00:00:54,320 --> 00:00:59,840
loss of csp and enterprises in their

00:00:57,520 --> 00:00:59,840
infrastructure

00:01:02,000 --> 00:01:05,360
in this topic we start another

00:01:04,479 --> 00:01:09,600
consideration

00:01:05,360 --> 00:01:09,600
on vm-based secure container

00:01:11,119 --> 00:01:19,040
from recent papers and reports of aws

00:01:14,880 --> 00:01:21,520
or id cloud superior container is the

00:01:19,040 --> 00:01:22,720
bedrock for their public cloud container

00:01:21,520 --> 00:01:26,720
service

00:01:22,720 --> 00:01:29,840
so it is popular in csp

00:01:26,720 --> 00:01:30,960
and commonly secure container is virtual

00:01:29,840 --> 00:01:33,600
machine based

00:01:30,960 --> 00:01:35,119
like cotton containers here the

00:01:33,600 --> 00:01:38,400
evaluation work we have

00:01:35,119 --> 00:01:42,240
done is based on color containers

00:01:38,400 --> 00:01:45,920
since it is virtual machine based

00:01:42,240 --> 00:01:48,159
can acidic warehouse directly be applied

00:01:45,920 --> 00:01:52,000
to color containers

00:01:48,159 --> 00:01:55,600
let's take a look at the characteristic

00:01:52,000 --> 00:01:58,159
of secure container the first

00:01:55,600 --> 00:01:59,600
characteristic is the high container

00:01:58,159 --> 00:02:01,439
density

00:01:59,600 --> 00:02:03,759
not like a traditional virtualization

00:02:01,439 --> 00:02:07,040
scenario that only tons of

00:02:03,759 --> 00:02:08,080
vm are running in a server secure

00:02:07,040 --> 00:02:12,000
container

00:02:08,080 --> 00:02:14,560
so more than 1 000 of containers on a

00:02:12,000 --> 00:02:17,040
single on one single host

00:02:14,560 --> 00:02:18,560
which means more than 1 000 of

00:02:17,040 --> 00:02:22,480
lightweight virtual machines

00:02:18,560 --> 00:02:27,760
are running on a single host

00:02:22,480 --> 00:02:30,959
the second item is resource over prison

00:02:27,760 --> 00:02:34,000
cpu and map resource will not be planned

00:02:30,959 --> 00:02:35,280
and pre-assigned to specific virtual

00:02:34,000 --> 00:02:38,080
machines

00:02:35,280 --> 00:02:39,920
probably these resources will be

00:02:38,080 --> 00:02:42,400
scheduled to different

00:02:39,920 --> 00:02:42,959
container dynamically and they are

00:02:42,400 --> 00:02:46,160
always

00:02:42,959 --> 00:02:48,560
trends seriously since there are a lot

00:02:46,160 --> 00:02:51,440
of containers

00:02:48,560 --> 00:02:52,400
and commonly containers do not only

00:02:51,440 --> 00:02:55,760
focus on

00:02:52,400 --> 00:03:00,720
extremely high performance but it also

00:02:55,760 --> 00:03:00,720
focus on flexibility and robustness

00:03:02,720 --> 00:03:09,599
the first problem we might with sfdk

00:03:06,720 --> 00:03:11,920
and the square container is about the

00:03:09,599 --> 00:03:15,440
high canada density

00:03:11,920 --> 00:03:18,480
smdk application uses polling mode

00:03:15,440 --> 00:03:22,640
which is a undies while loop

00:03:18,480 --> 00:03:26,239
to pull each device check and process

00:03:22,640 --> 00:03:30,799
zero requests for warehouse device

00:03:26,239 --> 00:03:33,440
spk posts each watch queue in roms

00:03:30,799 --> 00:03:34,400
poly mode with this type of application

00:03:33,440 --> 00:03:36,879
framework

00:03:34,400 --> 00:03:38,159
is good and efficient for heavy

00:03:36,879 --> 00:03:41,519
workloads

00:03:38,159 --> 00:03:44,480
but for container their l

00:03:41,519 --> 00:03:47,200
clothes are not always so high so when

00:03:44,480 --> 00:03:50,640
containers are in high density

00:03:47,200 --> 00:03:54,480
protein to cure a massive world queues

00:03:50,640 --> 00:03:54,480
is not efficient at all

00:03:55,280 --> 00:04:00,799
the second problem is about the cpu and

00:03:58,879 --> 00:04:05,200
the memory resource

00:04:00,799 --> 00:04:07,360
over prison when some cpu cores are

00:04:05,200 --> 00:04:10,319
running sdk warehouse

00:04:07,360 --> 00:04:11,120
then this course will be occupied or

00:04:10,319 --> 00:04:14,239
pinned

00:04:11,120 --> 00:04:17,759
by svk warehouse all the time due to

00:04:14,239 --> 00:04:20,720
pulling mode just like our slogan

00:04:17,759 --> 00:04:21,759
don't interrupt me i'm pulling for

00:04:20,720 --> 00:04:25,600
memory

00:04:21,759 --> 00:04:29,600
due to user space device dma operation

00:04:25,600 --> 00:04:32,800
svk requires memory to be pre-allocated

00:04:29,600 --> 00:04:36,320
as a huge page memory

00:04:32,800 --> 00:04:39,440
the memory pre-allocation and the cpu

00:04:36,320 --> 00:04:43,199
occupation required by spdk

00:04:39,440 --> 00:04:46,720
warehouse are barriers to our provision

00:04:43,199 --> 00:04:49,919
also resources to container

00:04:46,720 --> 00:04:52,720
okay towards secure containers can we

00:04:49,919 --> 00:04:54,560
involve as big as applications to be

00:04:52,720 --> 00:05:00,000
interruptable

00:04:54,560 --> 00:05:00,000
let's first look back on spdk internal

00:05:00,639 --> 00:05:04,560
one of the primary aims of sp is to

00:05:03,759 --> 00:05:07,840
scale

00:05:04,560 --> 00:05:11,600
skill linearly with the addition

00:05:07,840 --> 00:05:14,960
of hardware to achieve this spd

00:05:11,600 --> 00:05:18,560
execution unit must be independent

00:05:14,960 --> 00:05:22,080
from one another as much as possible

00:05:18,560 --> 00:05:25,840
and avoid soft locks

00:05:22,080 --> 00:05:27,199
instead of placing a shared in a global

00:05:25,840 --> 00:05:30,639
location

00:05:27,199 --> 00:05:31,039
that all thread access after acquiring a

00:05:30,639 --> 00:05:33,680
lock

00:05:31,039 --> 00:05:35,360
as pd takes a different approach

00:05:33,680 --> 00:05:38,160
altogether

00:05:35,360 --> 00:05:40,800
as ptke will often assign that a date to

00:05:38,160 --> 00:05:43,520
a single thread

00:05:40,800 --> 00:05:43,919
when other threads want to access the

00:05:43,520 --> 00:05:46,639
date

00:05:43,919 --> 00:05:47,360
they must pass a message to the owings

00:05:46,639 --> 00:05:50,400
right to

00:05:47,360 --> 00:05:54,800
perform the operation on behalf

00:05:50,400 --> 00:05:58,800
of the threads this strategy of course

00:05:54,800 --> 00:06:01,680
is not new for instance it is

00:05:58,800 --> 00:06:02,800
one of the core design principle of eric

00:06:01,680 --> 00:06:06,240
syn long

00:06:02,800 --> 00:06:09,280
and is the main concurrency mechanism

00:06:06,240 --> 00:06:09,280
in google language

00:06:11,280 --> 00:06:18,840
spd provides several layers to construct

00:06:15,440 --> 00:06:21,600
messaging passing in front

00:06:18,840 --> 00:06:22,560
infrastructure the most fundamental

00:06:21,600 --> 00:06:26,319
libraries in

00:06:22,560 --> 00:06:27,680
spd for instance don't do any message

00:06:26,319 --> 00:06:30,240
passing on their own

00:06:27,680 --> 00:06:31,759
it depends on as bdk's thread

00:06:30,240 --> 00:06:34,880
abstraction

00:06:31,759 --> 00:06:35,360
i speak thread abstraction provides a

00:06:34,880 --> 00:06:38,319
basic

00:06:35,360 --> 00:06:39,440
message passing framework and defense a

00:06:38,319 --> 00:06:42,479
key

00:06:39,440 --> 00:06:45,600
primitives first

00:06:42,479 --> 00:06:49,680
spd is an abstraction

00:06:45,600 --> 00:06:52,720
for a lightweight stack list thread of

00:06:49,680 --> 00:06:55,840
execution a low level framework

00:06:52,720 --> 00:06:59,599
kind executed and a split

00:06:55,840 --> 00:07:02,880
thread for a single timelines by calling

00:06:59,599 --> 00:07:04,639
spdk thread pull function

00:07:02,880 --> 00:07:06,479
the lightweight thread is the

00:07:04,639 --> 00:07:09,840
fundamental abstraction

00:07:06,479 --> 00:07:10,479
for threading in sdk there are also a

00:07:09,840 --> 00:07:14,400
few

00:07:10,479 --> 00:07:16,560
additional abstract layers on top of the

00:07:14,400 --> 00:07:19,759
spd thread

00:07:16,560 --> 00:07:21,919
where is the sp polar which is a

00:07:19,759 --> 00:07:23,199
abstraction for a function that should

00:07:21,919 --> 00:07:26,240
be repeatedly

00:07:23,199 --> 00:07:26,720
called on the given thread and the other

00:07:26,240 --> 00:07:29,680
one is

00:07:26,720 --> 00:07:30,800
spdk message which is a function pointer

00:07:29,680 --> 00:07:34,000
and a context

00:07:30,800 --> 00:07:36,400
pointer that can be sent from a thread

00:07:34,000 --> 00:07:39,039
to another

00:07:36,400 --> 00:07:40,800
the library also defines two additional

00:07:39,039 --> 00:07:44,160
abstractions

00:07:40,800 --> 00:07:48,160
one is spkr device and

00:07:44,160 --> 00:07:50,639
the other is sbl channel

00:07:48,160 --> 00:07:53,280
in order to implement a message passing

00:07:50,639 --> 00:07:56,319
strategy the code would describe

00:07:53,280 --> 00:07:59,120
describe some object within

00:07:56,319 --> 00:07:59,759
global state and also some crossroads

00:07:59,120 --> 00:08:03,840
context

00:07:59,759 --> 00:08:03,840
associated with that abstract

00:08:07,120 --> 00:08:12,080
this makes spd very portable to a widely

00:08:11,280 --> 00:08:17,120
variety

00:08:12,080 --> 00:08:17,120
of asynchronous event based framework

00:08:19,520 --> 00:08:23,759
spd provides a framework for writing a

00:08:22,960 --> 00:08:26,960
synchronous

00:08:23,759 --> 00:08:29,120
pro mode shared nothing several

00:08:26,960 --> 00:08:32,080
applications

00:08:29,120 --> 00:08:32,959
the framework defines several concept

00:08:32,080 --> 00:08:36,080
reactors

00:08:32,959 --> 00:08:39,200
events and lightweight thread

00:08:36,080 --> 00:08:41,680
a reactor the event framework spawns

00:08:39,200 --> 00:08:44,959
when system thread per call reactor

00:08:41,680 --> 00:08:48,560
stands for the system thread

00:08:44,959 --> 00:08:49,680
events reactor connect each other with

00:08:48,560 --> 00:08:52,640
lockless

00:08:49,680 --> 00:08:53,760
cues events can be passed between the

00:08:52,640 --> 00:08:55,279
reactors

00:08:53,760 --> 00:08:57,040
the lightweight trader is a

00:08:55,279 --> 00:09:01,120
representative for sp

00:08:57,040 --> 00:09:01,839
thread who is the stackless execution

00:09:01,120 --> 00:09:05,279
unit

00:09:01,839 --> 00:09:09,200
lightweight thread in sp is

00:09:05,279 --> 00:09:11,839
linked in a list inside a reactor

00:09:09,200 --> 00:09:12,720
in this event a framework reactor

00:09:11,839 --> 00:09:16,000
running

00:09:12,720 --> 00:09:19,920
a while loop round and round posts

00:09:16,000 --> 00:09:22,959
its event queue process incoming events

00:09:19,920 --> 00:09:25,440
also post sp thread attached

00:09:22,959 --> 00:09:27,519
in eight so that is the polar are

00:09:25,440 --> 00:09:31,200
executed

00:09:27,519 --> 00:09:34,560
this framework shows how to put sp

00:09:31,200 --> 00:09:35,360
at piggy components together as pdg

00:09:34,560 --> 00:09:37,920
community

00:09:35,360 --> 00:09:40,720
uses data to build their applications

00:09:37,920 --> 00:09:44,080
like we use a target

00:09:40,720 --> 00:09:45,399
it glows as big components in a pooling

00:09:44,080 --> 00:09:50,640
programming

00:09:45,399 --> 00:09:54,080
programming model

00:09:50,640 --> 00:09:57,920
so here for sbb whose target is applying

00:09:54,080 --> 00:09:58,160
related components esp with use space

00:09:57,920 --> 00:10:01,360
and

00:09:58,160 --> 00:10:04,959
pulling techniques

00:10:01,360 --> 00:10:09,040
when running ys delivers the target

00:10:04,959 --> 00:10:11,920
first a the first step is

00:10:09,040 --> 00:10:14,399
if uh when create awareness the device

00:10:11,920 --> 00:10:18,000
at speedg will create a specific

00:10:14,399 --> 00:10:21,519
sp thread inside the lightweight as

00:10:18,000 --> 00:10:22,079
big thread pullers are registered to

00:10:21,519 --> 00:10:25,440
tick

00:10:22,079 --> 00:10:28,320
and process our request in virtual cues

00:10:25,440 --> 00:10:28,320
as a front-end

00:10:28,480 --> 00:10:35,040
block device as a backhand

00:10:32,240 --> 00:10:35,839
all functions are driven by pulling

00:10:35,040 --> 00:10:38,959
exactly

00:10:35,839 --> 00:10:38,959
same injectors

00:10:40,240 --> 00:10:46,560
now we want to evolve sdk application

00:10:43,519 --> 00:10:49,279
in interrupt mode it should be

00:10:46,560 --> 00:10:49,920
compatible with current sdk event

00:10:49,279 --> 00:10:53,040
framework

00:10:49,920 --> 00:10:54,160
and spk thread abstraction which is

00:10:53,040 --> 00:10:56,320
created for

00:10:54,160 --> 00:10:57,440
effective message passing a

00:10:56,320 --> 00:11:00,320
synchronization

00:10:57,440 --> 00:11:02,079
and run to completion characteristics

00:11:00,320 --> 00:11:05,120
used by applications

00:11:02,079 --> 00:11:05,120
inside sdk

00:11:05,760 --> 00:11:12,079
the interrupt abstraction object

00:11:08,800 --> 00:11:15,120
now are based on ipo and event fd

00:11:12,079 --> 00:11:18,399
on linux platform it is the

00:11:15,120 --> 00:11:22,320
core concept to achieve interrupt with

00:11:18,399 --> 00:11:25,360
notify mechanism initially it is one

00:11:22,320 --> 00:11:29,279
import instance with registered

00:11:25,360 --> 00:11:31,360
target file descriptors

00:11:29,279 --> 00:11:32,480
different target vertice crafters

00:11:31,360 --> 00:11:35,600
represents

00:11:32,480 --> 00:11:36,800
different interrupts or even a cells for

00:11:35,600 --> 00:11:38,959
example

00:11:36,800 --> 00:11:40,240
even fd is used for internal queue

00:11:38,959 --> 00:11:44,240
notification

00:11:40,240 --> 00:11:48,720
socket fd is used for network data

00:11:44,240 --> 00:11:51,920
coming or out notification tamafd

00:11:48,720 --> 00:11:52,639
is used for periodic work we have valued

00:11:51,920 --> 00:11:55,040
fd

00:11:52,639 --> 00:11:56,240
can be used for user space device

00:11:55,040 --> 00:11:58,880
interrupt

00:11:56,240 --> 00:12:00,480
the most important one is cascading the

00:11:58,880 --> 00:12:03,839
hippo instance

00:12:00,480 --> 00:12:03,839
for grouped events

00:12:04,399 --> 00:12:11,920
if we map the interrupt abstraction of

00:12:08,480 --> 00:12:15,600
ipo group then we can get spk

00:12:11,920 --> 00:12:18,800
reactor and sdk stride

00:12:15,600 --> 00:12:21,600
to be interruptable we'll apply

00:12:18,800 --> 00:12:22,800
interrupt abstraction to reactor the

00:12:21,600 --> 00:12:27,519
reactor itself

00:12:22,800 --> 00:12:31,600
contains one top level input instance

00:12:27,519 --> 00:12:34,800
and one import and one event fd

00:12:31,600 --> 00:12:38,160
represents for its internal even q

00:12:34,800 --> 00:12:40,480
is registered to to the import instance

00:12:38,160 --> 00:12:41,839
or small other registered file

00:12:40,480 --> 00:12:44,720
descriptors

00:12:41,839 --> 00:12:46,000
are all sub-level e for instance which

00:12:44,720 --> 00:12:49,120
represents

00:12:46,000 --> 00:12:51,440
svk stress which is attached to this

00:12:49,120 --> 00:12:54,800
reactor

00:12:51,440 --> 00:12:57,040
as we just decide speak thread itself

00:12:54,800 --> 00:12:58,399
also contains one input instance as a

00:12:57,040 --> 00:13:01,200
central row

00:12:58,399 --> 00:13:04,079
then we can register corresponding file

00:13:01,200 --> 00:13:04,079
descriptors

00:13:04,560 --> 00:13:11,839
to the threat epo instance instead of

00:13:08,000 --> 00:13:15,600
registering polars to spg right

00:13:11,839 --> 00:13:18,959
for example at force message q

00:13:15,600 --> 00:13:21,839
polar or mass q process

00:13:18,959 --> 00:13:23,839
event can be replaced by one event fd

00:13:21,839 --> 00:13:27,279
for message queue

00:13:23,839 --> 00:13:31,040
polars with interval time can be

00:13:27,279 --> 00:13:33,760
replaced by timer f d hardware q polars

00:13:31,040 --> 00:13:36,079
for enemy device or what health device

00:13:33,760 --> 00:13:40,399
can be replaced by vfl

00:13:36,079 --> 00:13:44,079
event fd npd powers can be replaced by

00:13:40,399 --> 00:13:47,519
just registering its pub fd to the

00:13:44,079 --> 00:13:51,199
iphone instance arob dell

00:13:47,519 --> 00:13:54,399
can use immediately together with dpl

00:13:51,199 --> 00:13:56,800
if soccer group applied

00:13:54,399 --> 00:13:57,920
interrupt abstraction for its

00:13:56,800 --> 00:14:01,680
connections

00:13:57,920 --> 00:14:04,560
then sk or omfu

00:14:01,680 --> 00:14:07,680
polars can be triggered directly by the

00:14:04,560 --> 00:14:07,680
saw group interrupt

00:14:09,040 --> 00:14:12,959
after applying interrupt abstraction

00:14:11,680 --> 00:14:16,240
into reactor

00:14:12,959 --> 00:14:17,120
and acetic stripe then one spk

00:14:16,240 --> 00:14:20,320
application

00:14:17,120 --> 00:14:23,760
can run in such methods to get itself

00:14:20,320 --> 00:14:23,760
running in interrupt mode

00:14:24,160 --> 00:14:30,160
the application will do block weight

00:14:27,199 --> 00:14:31,920
on reactor input instance and do not

00:14:30,160 --> 00:14:33,600
block weight on asperger's through the

00:14:31,920 --> 00:14:37,920
equal instance

00:14:33,600 --> 00:14:40,320
then the system strikes of the reactors

00:14:37,920 --> 00:14:43,279
will only get blocked at the reactor

00:14:40,320 --> 00:14:43,279
equal instance

00:14:43,680 --> 00:14:47,680
if the evil instance of reactor wakes up

00:14:46,720 --> 00:14:50,720
from

00:14:47,680 --> 00:14:53,440
is even the queue then it directly

00:14:50,720 --> 00:14:55,040
comes to the unique and plus process

00:14:53,440 --> 00:14:59,760
event

00:14:55,040 --> 00:15:02,639
if it is waking up from

00:14:59,760 --> 00:15:03,760
one i speak through the message then the

00:15:02,639 --> 00:15:08,000
reactor

00:15:03,760 --> 00:15:09,839
will come to the specific sdk slide

00:15:08,000 --> 00:15:11,600
and then the thread will process the

00:15:09,839 --> 00:15:15,600
message queue

00:15:11,600 --> 00:15:18,560
if there is one epio

00:15:15,600 --> 00:15:19,120
l completion then the reactor for

00:15:18,560 --> 00:15:22,480
instance

00:15:19,120 --> 00:15:25,440
will wake up and come to that specific

00:15:22,480 --> 00:15:28,880
spdik slide and then the thread will

00:15:25,440 --> 00:15:32,000
come to process the liberal

00:15:28,880 --> 00:15:35,519
event each time

00:15:32,000 --> 00:15:38,720
the process is completed after waking up

00:15:35,519 --> 00:15:41,680
the system thread will come back

00:15:38,720 --> 00:15:44,320
to reactor and the block on reactor e4

00:15:41,680 --> 00:15:44,320
instance

00:15:45,440 --> 00:15:51,360
spdk further provides a full block stack

00:15:48,639 --> 00:15:54,880
as a user switch library that performs

00:15:51,360 --> 00:15:57,680
many of the same operations as a

00:15:54,880 --> 00:15:58,959
block stack in an operating system

00:15:57,680 --> 00:16:01,040
kernel

00:15:58,959 --> 00:16:02,320
all of them are designed around message

00:16:01,040 --> 00:16:06,240
passing instead of

00:16:02,320 --> 00:16:08,480
logging and most of the spk libraries

00:16:06,240 --> 00:16:09,920
makes several assumptions like a message

00:16:08,480 --> 00:16:12,160
passing event

00:16:09,920 --> 00:16:13,199
called rooting or laterally threading

00:16:12,160 --> 00:16:16,160
framework

00:16:13,199 --> 00:16:17,120
so if the underlying threading model is

00:16:16,160 --> 00:16:19,839
interruptable

00:16:17,120 --> 00:16:21,519
then many of the libraries inside spdk

00:16:19,839 --> 00:16:25,360
can run directly in

00:16:21,519 --> 00:16:28,079
in interrupt mode for example the

00:16:25,360 --> 00:16:29,360
basic video modules like ready be down

00:16:28,079 --> 00:16:32,720
speak without

00:16:29,360 --> 00:16:36,000
gpt on malok video for

00:16:32,720 --> 00:16:38,639
sdk blob store and it's up layer

00:16:36,000 --> 00:16:40,320
logic volume it can always run directly

00:16:38,639 --> 00:16:41,519
in interrupt mode without any

00:16:40,320 --> 00:16:44,560
modification

00:16:41,519 --> 00:16:48,560
for sdk block fis and its

00:16:44,560 --> 00:16:51,279
fuse module they can also run directly

00:16:48,560 --> 00:16:53,920
in interrupt mode without any

00:16:51,279 --> 00:16:57,519
modification

00:16:53,920 --> 00:17:02,079
so here we have prepared a minimal set

00:16:57,519 --> 00:17:04,160
of interactable warehouse target

00:17:02,079 --> 00:17:05,360
interrupt mode for secure container

00:17:04,160 --> 00:17:09,760
evaluation

00:17:05,360 --> 00:17:13,520
based on some interrupt mode purchase

00:17:09,760 --> 00:17:14,640
it will use linux aopdo as the storage

00:17:13,520 --> 00:17:17,679
backend

00:17:14,640 --> 00:17:21,039
it will export linux mbd

00:17:17,679 --> 00:17:24,400
server is host and it will provide

00:17:21,039 --> 00:17:27,120
provider warehouse block device

00:17:24,400 --> 00:17:29,840
to the lightweight virtual machine of

00:17:27,120 --> 00:17:32,720
secure container

00:17:29,840 --> 00:17:35,200
a flexible block stack with logical

00:17:32,720 --> 00:17:35,200
volume

00:17:36,720 --> 00:17:44,559
azir for advanced block operations

00:17:41,440 --> 00:17:47,840
users can also manage this

00:17:44,559 --> 00:17:50,880
evaluation application still

00:17:47,840 --> 00:17:54,240
by spk rpc masters the

00:17:50,880 --> 00:17:56,480
difference of this application with

00:17:54,240 --> 00:17:57,919
general aspect application is that it

00:17:56,480 --> 00:18:01,120
won't be pulling

00:17:57,919 --> 00:18:03,039
or occupying cpu cores anymore when

00:18:01,120 --> 00:18:05,600
there is no workload

00:18:03,039 --> 00:18:06,559
its cpu percentage is lower than one

00:18:05,600 --> 00:18:10,160
percentage

00:18:06,559 --> 00:18:10,160
is lower than one percent

00:18:11,120 --> 00:18:17,360
a set of tools are provided by sdk

00:18:14,400 --> 00:18:18,799
some of them are also easy to run in

00:18:17,360 --> 00:18:21,840
interrupt mode

00:18:18,799 --> 00:18:24,559
for example the video protocol it is a

00:18:21,840 --> 00:18:24,559
benchmark

00:18:25,360 --> 00:18:35,039
tool of svg block device

00:18:28,480 --> 00:18:35,039
for slide and even work cost

00:18:39,280 --> 00:18:45,600
a set of tools are provided by sdk

00:18:42,480 --> 00:18:46,559
some of them are also easy to run in

00:18:45,600 --> 00:18:50,000
interrupt mode

00:18:46,559 --> 00:18:51,120
for example for video protocol it is a

00:18:50,000 --> 00:18:57,840
benchmark

00:18:51,120 --> 00:18:57,840
it is a performance

00:18:59,200 --> 00:19:05,360
a set of tools are provided by svdk

00:19:02,480 --> 00:19:07,360
some of them are also easy to draw in

00:19:05,360 --> 00:19:10,240
interrupt mode for example

00:19:07,360 --> 00:19:11,440
for video profitable it is a performance

00:19:10,240 --> 00:19:14,720
benchmark tool of

00:19:11,440 --> 00:19:18,080
svk block devices

00:19:14,720 --> 00:19:21,200
for thread and event framework cost

00:19:18,080 --> 00:19:24,480
we have added a parameter to video curve

00:19:21,200 --> 00:19:25,440
to set interrupt mode flag with this

00:19:24,480 --> 00:19:28,320
simple

00:19:25,440 --> 00:19:29,679
modification we got some brief

00:19:28,320 --> 00:19:32,640
performance evaluation

00:19:29,679 --> 00:19:34,000
and interrupt mode for you to have a

00:19:32,640 --> 00:19:36,640
preview

00:19:34,000 --> 00:19:39,120
of course there is a obvious performance

00:19:36,640 --> 00:19:39,120
drawdown

00:19:39,520 --> 00:19:46,400
without a memory video

00:19:42,720 --> 00:19:49,919
it shows about the throughput of

00:19:46,400 --> 00:19:51,120
interrupt mode is less than one-third of

00:19:49,919 --> 00:19:54,160
the throughput of

00:19:51,120 --> 00:19:58,160
mode without part of

00:19:54,160 --> 00:20:01,840
an umi based albedo it shows about

00:19:58,160 --> 00:20:05,280
the throughput of interrupt mode is

00:20:01,840 --> 00:20:08,480
around five to eight percent

00:20:05,280 --> 00:20:10,640
worse than pulling mode this

00:20:08,480 --> 00:20:12,400
is not good for extremely high

00:20:10,640 --> 00:20:15,840
performance situation

00:20:12,400 --> 00:20:20,159
but for the container scenario

00:20:15,840 --> 00:20:23,679
it will be enough

00:20:20,159 --> 00:20:26,720
the last part on top of interrupt

00:20:23,679 --> 00:20:30,799
interruptable s3 application

00:20:26,720 --> 00:20:34,480
we can provide a secure

00:20:30,799 --> 00:20:36,960
container storage service at start

00:20:34,480 --> 00:20:37,760
the most straightforward step is to

00:20:36,960 --> 00:20:40,880
providing

00:20:37,760 --> 00:20:40,880
device volume

00:20:41,200 --> 00:20:47,440
from a spdkv host by doc command

00:20:45,280 --> 00:20:49,440
provider volume service to cutter

00:20:47,440 --> 00:20:52,720
containers via the interrupt

00:20:49,440 --> 00:20:56,080
sbv host target

00:20:52,720 --> 00:20:59,840
and sp

00:20:56,080 --> 00:21:02,960
logic volume can do sim promising and

00:20:59,840 --> 00:21:06,640
snapshot like a logical

00:21:02,960 --> 00:21:08,400
volume on the device member sp logic

00:21:06,640 --> 00:21:11,360
volume provides basic

00:21:08,400 --> 00:21:12,880
functionalities to meet a container root

00:21:11,360 --> 00:21:15,520
type s

00:21:12,880 --> 00:21:16,559
provide root face service to qatar

00:21:15,520 --> 00:21:18,880
containers

00:21:16,559 --> 00:21:19,760
where the interrupter sbv hosts the

00:21:18,880 --> 00:21:22,880
target

00:21:19,760 --> 00:21:22,880
and the continuity

00:21:24,640 --> 00:21:31,360
how you survive spd is much

00:21:28,159 --> 00:21:33,760
more diverse than we expect

00:21:31,360 --> 00:21:34,559
from a speaking hub issue and select

00:21:33,760 --> 00:21:37,600
channel

00:21:34,559 --> 00:21:38,159
we realized that there are users who run

00:21:37,600 --> 00:21:41,280
sp

00:21:38,159 --> 00:21:45,360
inside the docker container when

00:21:41,280 --> 00:21:48,480
containing containering application

00:21:45,360 --> 00:21:51,840
there are no sbtk specific changes

00:21:48,480 --> 00:21:54,799
needed however general speed application

00:21:51,840 --> 00:21:56,320
always requires dedicated cpu cores and

00:21:54,799 --> 00:22:00,320
huge memories

00:21:56,320 --> 00:22:02,640
so exclusive resource ocu

00:22:00,320 --> 00:22:04,080
and patient is the main issue for

00:22:02,640 --> 00:22:07,120
continuing

00:22:04,080 --> 00:22:10,000
spdk application if

00:22:07,120 --> 00:22:10,720
sp application inside the container is

00:22:10,000 --> 00:22:14,240
running

00:22:10,720 --> 00:22:18,000
in the interrupt mode also with

00:22:14,240 --> 00:22:23,520
nine huge memory the container

00:22:18,000 --> 00:22:23,520
density will not be impacted by spdk

00:22:24,840 --> 00:22:30,400
container

00:22:26,559 --> 00:22:33,440
and currently only basic interrupt mode

00:22:30,400 --> 00:22:35,440
is supported if we want to get spd to be

00:22:33,440 --> 00:22:38,159
more suitable to

00:22:35,440 --> 00:22:40,200
uh secure container scenarios from

00:22:38,159 --> 00:22:45,280
container in a

00:22:40,200 --> 00:22:45,280
infrastructure to container instance

00:22:46,799 --> 00:22:53,840
so let's give a summary first pulling

00:22:51,679 --> 00:22:55,520
pin the cpu and huge memory player

00:22:53,840 --> 00:22:58,720
location can be avoided

00:22:55,520 --> 00:22:59,679
from non-performance situation with the

00:22:58,720 --> 00:23:02,240
interrupt mode

00:22:59,679 --> 00:23:04,320
spdw host will be a good choice to

00:23:02,240 --> 00:23:09,200
provide a storage service

00:23:04,320 --> 00:23:13,679
to secure containers

00:23:09,200 --> 00:23:17,120
and for the future in

00:23:13,679 --> 00:23:19,280
involution we may either interrupt

00:23:17,120 --> 00:23:20,320
support on your space hardware block

00:23:19,280 --> 00:23:23,360
device packing

00:23:20,320 --> 00:23:23,840
such as the mme driver and the block

00:23:23,360 --> 00:23:26,480
layer

00:23:23,840 --> 00:23:27,919
with whole device driver under the block

00:23:26,480 --> 00:23:31,280
device layer

00:23:27,919 --> 00:23:35,520
and also we can add interrupt support

00:23:31,280 --> 00:23:38,640
or modules related with the network

00:23:35,520 --> 00:23:39,200
protocol such as mmu or fabrics under

00:23:38,640 --> 00:23:42,640
the ice

00:23:39,200 --> 00:23:44,960
cushion also with a running mode

00:23:42,640 --> 00:23:47,279
switch between the pulling and the

00:23:44,960 --> 00:23:51,840
interrupt

00:23:47,279 --> 00:23:55,600
the last is we can official

00:23:51,840 --> 00:23:59,360
nine huge memory support for all the net

00:23:55,600 --> 00:23:59,360
dmasp application

00:23:59,679 --> 00:24:05,840
uh that's all for today's presentation

00:24:03,360 --> 00:24:05,840

YouTube URL: https://www.youtube.com/watch?v=AONlzxm6SyM


