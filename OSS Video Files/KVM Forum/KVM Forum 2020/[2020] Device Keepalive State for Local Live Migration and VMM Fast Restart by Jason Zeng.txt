Title: [2020] Device Keepalive State for Local Live Migration and VMM Fast Restart by Jason Zeng
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Passthrough devices are painpoints of VM live migration or VMM/Host upgrade. Currently there are community discussions and approaches to support passthrough device live migration, however they usually require vendor specific driver support, which is also a painpoint for legacy devices. This topic will introduce a new device state, keepalive state, for passthrough devices and other related hardware and software components to support local migration and VMM/host reboot. The new keepalive state doesnâ€™t require vendor specific driver support for most legacy devices. It keeps devices and other related hardware alive during the local live migration period. In this topic, we will present the design and implementation of the kernel and Qemu changes for supporting keepalive state.

---

Jason Zeng
Intel Coporation, Software Engineer

Jason Zeng is a software engineer from Intel virtualization team, focusing on various KVM/virtualization features and projects. Currently he is working on VMM Fast Restart project which aims to provide a solution for fast upgrading and rebooting VMM/host kernel while impose less impact to guest VMs. Jason was a speaker of KVM Forum 2019.
Captions: 
	00:00:13,840 --> 00:00:19,680
welcome to this session today i will

00:00:16,800 --> 00:00:20,880
introduce our team's work the design and

00:00:19,680 --> 00:00:23,840
implementation of

00:00:20,880 --> 00:00:25,039
device keep live state which can be used

00:00:23,840 --> 00:00:27,359
for implementing

00:00:25,039 --> 00:00:28,240
local line migration and vm faster

00:00:27,359 --> 00:00:31,840
restart

00:00:28,240 --> 00:00:31,840
with pass-through device support

00:00:34,480 --> 00:00:37,680
we will first give an overview of the

00:00:36,719 --> 00:00:42,079
design

00:00:37,680 --> 00:00:42,079
and then dive into some major details

00:00:42,239 --> 00:00:48,399
first let's have a recap of the problem

00:00:45,840 --> 00:00:49,440
system update is the pain point of cloud

00:00:48,399 --> 00:00:52,079
vendors

00:00:49,440 --> 00:00:53,680
because system update is usually taking

00:00:52,079 --> 00:00:56,840
too long time

00:00:53,680 --> 00:00:58,000
so we see more service downtime for

00:00:56,840 --> 00:01:00,160
customers

00:00:58,000 --> 00:01:02,160
the existing solutions can be divided

00:01:00,160 --> 00:01:04,320
into several categories

00:01:02,160 --> 00:01:05,280
first choice is to move the vms

00:01:04,320 --> 00:01:08,320
somewhere else

00:01:05,280 --> 00:01:09,680
although the system can be updated the

00:01:08,320 --> 00:01:13,040
typical solution of

00:01:09,680 --> 00:01:14,400
this category is live migration however

00:01:13,040 --> 00:01:16,799
live migration doesn't support

00:01:14,400 --> 00:01:19,040
pass-through device very well

00:01:16,799 --> 00:01:20,240
the other choice is to keep the vm and

00:01:19,040 --> 00:01:23,680
local

00:01:20,240 --> 00:01:24,880
then an option is to live patching the

00:01:23,680 --> 00:01:28,080
kernel

00:01:24,880 --> 00:01:30,479
it is good for small fixes however

00:01:28,080 --> 00:01:32,159
big kernel changes will raise the

00:01:30,479 --> 00:01:35,439
failure rate

00:01:32,159 --> 00:01:36,880
our focus is the final category update

00:01:35,439 --> 00:01:40,960
the relevant components

00:01:36,880 --> 00:01:43,439
separately or in a whole on local system

00:01:40,960 --> 00:01:46,079
examples of this category include the

00:01:43,439 --> 00:01:47,040
proposal from oracle to do the tumor lab

00:01:46,079 --> 00:01:49,520
update

00:01:47,040 --> 00:01:50,159
alibaba also had a paper which talks

00:01:49,520 --> 00:01:55,840
about

00:01:50,159 --> 00:01:55,840
updating the kvm module

00:01:57,200 --> 00:02:02,159
looking into the solutions two questions

00:02:00,719 --> 00:02:05,680
need to be answered

00:02:02,159 --> 00:02:08,080
first do we allow pausing vm

00:02:05,680 --> 00:02:09,599
and second do we allow to reboot the

00:02:08,080 --> 00:02:12,720
host

00:02:09,599 --> 00:02:15,599
if we allow pausing the vm then

00:02:12,720 --> 00:02:16,720
pass through devices and kernel update

00:02:15,599 --> 00:02:19,520
can be supported

00:02:16,720 --> 00:02:20,879
naturally because password devices can

00:02:19,520 --> 00:02:24,080
be suspended

00:02:20,879 --> 00:02:26,080
within the vm and then resumed when vm

00:02:24,080 --> 00:02:29,040
restart

00:02:26,080 --> 00:02:29,440
if we don't allow passing the vm which

00:02:29,040 --> 00:02:32,879
means

00:02:29,440 --> 00:02:35,599
we can't require vm cooperation then we

00:02:32,879 --> 00:02:39,599
will have two further choices

00:02:35,599 --> 00:02:43,200
first don't allow host reboot

00:02:39,599 --> 00:02:45,760
then we can't update kernel

00:02:43,200 --> 00:02:47,200
we can only update userland vmm

00:02:45,760 --> 00:02:49,760
typically cumule

00:02:47,200 --> 00:02:50,959
here we still need to pass the state of

00:02:49,760 --> 00:02:54,080
the password device

00:02:50,959 --> 00:02:56,080
to receive the qmil we also need to pass

00:02:54,080 --> 00:02:57,440
the guest memory mapping across the

00:02:56,080 --> 00:02:59,760
restart

00:02:57,440 --> 00:03:02,480
steve from oracle also had a proposal

00:02:59,760 --> 00:03:02,480
for this case

00:03:03,200 --> 00:03:06,239
fast restart wants to solve the final

00:03:05,360 --> 00:03:09,040
category

00:03:06,239 --> 00:03:09,440
in which we don't allow pausing vm and

00:03:09,040 --> 00:03:12,959
we

00:03:09,440 --> 00:03:14,800
allow host reboot this is the most

00:03:12,959 --> 00:03:18,959
flexible solution which means

00:03:14,800 --> 00:03:21,680
kernel and cumin can both be updated

00:03:18,959 --> 00:03:22,480
here we can leverage kxtec reboot to

00:03:21,680 --> 00:03:25,519
boost the

00:03:22,480 --> 00:03:27,200
reboot time we also want to support

00:03:25,519 --> 00:03:30,319
password devices

00:03:27,200 --> 00:03:32,879
there is a special situation here

00:03:30,319 --> 00:03:35,519
during the reboot time window the

00:03:32,879 --> 00:03:38,159
pass-through device has no owner

00:03:35,519 --> 00:03:40,000
since we can't rely on the guest driver

00:03:38,159 --> 00:03:43,040
to suspend the device

00:03:40,000 --> 00:03:47,840
so the choice that we have is to

00:03:43,040 --> 00:03:47,840
keep the device alive across the reboot

00:03:49,680 --> 00:03:53,599
so here comes our proposal and

00:03:51,760 --> 00:03:56,480
implementation

00:03:53,599 --> 00:03:59,280
we introduce a device keep live state

00:03:56,480 --> 00:04:01,599
for pass-through devices

00:03:59,280 --> 00:04:02,480
we will talk about the overall idea of

00:04:01,599 --> 00:04:06,959
the proposal

00:04:02,480 --> 00:04:06,959
and then dive into some major details

00:04:08,080 --> 00:04:12,400
as shown in top right corner of the

00:04:11,040 --> 00:04:14,959
slide

00:04:12,400 --> 00:04:16,079
we introduce a flag in the core device

00:04:14,959 --> 00:04:19,519
data structure

00:04:16,079 --> 00:04:22,800
to denote a device is in the keep

00:04:19,519 --> 00:04:25,120
alive state what does it mean

00:04:22,800 --> 00:04:26,800
by putting a device into keep alive

00:04:25,120 --> 00:04:28,800
state

00:04:26,800 --> 00:04:30,240
it means the device hardware is still

00:04:28,800 --> 00:04:34,000
alive

00:04:30,240 --> 00:04:35,360
although it has no owner it may continue

00:04:34,000 --> 00:04:38,479
to issue dma

00:04:35,360 --> 00:04:40,560
and irq however

00:04:38,479 --> 00:04:42,320
the host software must not notify the

00:04:40,560 --> 00:04:44,639
hardware state of the device

00:04:42,320 --> 00:04:47,600
it can't bind the device to any other

00:04:44,639 --> 00:04:47,600
drivers either

00:04:47,759 --> 00:04:50,880
on the other hand the device software

00:04:50,160 --> 00:04:53,680
state

00:04:50,880 --> 00:04:54,479
which is managed by drivers must be

00:04:53,680 --> 00:04:57,520
saved

00:04:54,479 --> 00:04:59,840
at one of two stages if it

00:04:57,520 --> 00:05:00,960
can't be restored without clobbering

00:04:59,840 --> 00:05:03,440
hardware

00:05:00,960 --> 00:05:04,639
either at the time the device enters

00:05:03,440 --> 00:05:07,280
keep live state

00:05:04,639 --> 00:05:09,520
or at the time the host reboot it

00:05:07,280 --> 00:05:10,800
depends on whether it is affected by

00:05:09,520 --> 00:05:14,639
cumin run time

00:05:10,800 --> 00:05:16,880
operation or not or it is

00:05:14,639 --> 00:05:19,360
configured or maintained by the kernel

00:05:16,880 --> 00:05:19,360
or not

00:05:21,199 --> 00:05:28,720
the whole k exact reboot procedure

00:05:24,560 --> 00:05:31,840
consists of two incremental stages

00:05:28,720 --> 00:05:32,800
stage one is related to cumule when

00:05:31,840 --> 00:05:36,000
cumulus starts

00:05:32,800 --> 00:05:36,639
it opens the password device when tumor

00:05:36,000 --> 00:05:39,759
quits

00:05:36,639 --> 00:05:40,560
it closes the device this will cause the

00:05:39,759 --> 00:05:43,919
device

00:05:40,560 --> 00:05:45,759
to be enabled and disabled thus changing

00:05:43,919 --> 00:05:48,320
its hardware state

00:05:45,759 --> 00:05:49,919
so if we want to keep the device alive

00:05:48,320 --> 00:05:53,600
across the restart

00:05:49,919 --> 00:05:56,720
we need to set it into keep a live state

00:05:53,600 --> 00:06:00,319
before cumule quits this is called

00:05:56,720 --> 00:06:04,080
state one hip have state

00:06:00,319 --> 00:06:07,680
stage two is related to kernel reboot

00:06:04,080 --> 00:06:09,199
some devices such as iomu its driver

00:06:07,680 --> 00:06:11,759
maintains its own state

00:06:09,199 --> 00:06:13,440
as long as the kernel is running but

00:06:11,759 --> 00:06:16,080
when kernel is about 2k

00:06:13,440 --> 00:06:18,800
exact reboot the state will need to be

00:06:16,080 --> 00:06:22,479
preserved so that it can be handed over

00:06:18,800 --> 00:06:24,400
to the new kernel this is stage two keep

00:06:22,479 --> 00:06:27,280
alive state

00:06:24,400 --> 00:06:28,400
here we can see that stage one keep

00:06:27,280 --> 00:06:30,639
alive states

00:06:28,400 --> 00:06:31,680
can be used for implementing cumulative

00:06:30,639 --> 00:06:34,160
update

00:06:31,680 --> 00:06:35,520
this is an alternative solution to the

00:06:34,160 --> 00:06:39,600
fd parsing

00:06:35,520 --> 00:06:40,560
over exec it also can be applied for

00:06:39,600 --> 00:06:43,840
implementing

00:06:40,560 --> 00:06:43,840
local live migration

00:06:45,440 --> 00:06:48,479
this slide shows the example cumulative

00:06:47,840 --> 00:06:51,599
comments

00:06:48,479 --> 00:06:54,639
for implementing the vmm faster restart

00:06:51,599 --> 00:06:56,880
we put the guest memory in a dax device

00:06:54,639 --> 00:06:58,000
which is a dram emulated persistent

00:06:56,880 --> 00:07:01,199
memory

00:06:58,000 --> 00:07:02,160
and turn on its share property in this

00:07:01,199 --> 00:07:05,440
way

00:07:02,160 --> 00:07:07,360
qmil can pick up the guest memory from

00:07:05,440 --> 00:07:10,560
the persistent memory

00:07:07,360 --> 00:07:13,680
after k exact reboot

00:07:10,560 --> 00:07:17,199
the cumin common migrate set capability

00:07:13,680 --> 00:07:20,240
x ignore shared makes the

00:07:17,199 --> 00:07:23,440
save vm command ignore the

00:07:20,240 --> 00:07:26,720
guest memory region that has turned on

00:07:23,440 --> 00:07:29,520
share property so

00:07:26,720 --> 00:07:31,759
we don't need to copy the guest memory

00:07:29,520 --> 00:07:34,560
into the snapshot

00:07:31,759 --> 00:07:36,720
the cumin command set keep alive is a

00:07:34,560 --> 00:07:39,599
newly added comment to set all the

00:07:36,720 --> 00:07:42,800
password devices into keep a live state

00:07:39,599 --> 00:07:46,240
it also specifies a uuid token

00:07:42,800 --> 00:07:48,720
when qmi restarts after k exact reboot

00:07:46,240 --> 00:07:50,160
it needs to specify this token to the

00:07:48,720 --> 00:07:53,759
vfio

00:07:50,160 --> 00:07:55,840
device parameter so that the kernel can

00:07:53,759 --> 00:07:59,280
verify the resume the qmil

00:07:55,840 --> 00:08:01,680
has the permission to own the password

00:07:59,280 --> 00:08:01,680
device

00:08:02,080 --> 00:08:04,479
after

00:08:05,440 --> 00:08:09,199
after the resume the qmill load the

00:08:08,160 --> 00:08:12,720
snapshot

00:08:09,199 --> 00:08:15,919
we issue the set keep alive off command

00:08:12,720 --> 00:08:17,680
to clear the keep life flag for all the

00:08:15,919 --> 00:08:20,240
password devices

00:08:17,680 --> 00:08:26,080
after that the password devices will

00:08:20,240 --> 00:08:28,639
start working as usual

00:08:26,080 --> 00:08:30,720
so as shown in this picture a lot of

00:08:28,639 --> 00:08:31,680
data structures or software states are

00:08:30,720 --> 00:08:35,279
evolved

00:08:31,680 --> 00:08:38,800
in the lifetime of the vm to implement

00:08:35,279 --> 00:08:41,360
bmm fast restart we need to figure out

00:08:38,800 --> 00:08:43,519
which ones need to be preserved and

00:08:41,360 --> 00:08:47,440
which ones we can recreate

00:08:43,519 --> 00:08:47,440
across the kxf reboot

00:08:48,399 --> 00:08:52,080
there are some rationales to help

00:08:50,320 --> 00:08:55,680
determine this

00:08:52,080 --> 00:08:59,360
first does it need to be saved at

00:08:55,680 --> 00:08:59,760
all if the state are pure software state

00:08:59,360 --> 00:09:01,760
which

00:08:59,760 --> 00:09:04,640
means it doesn't depend on hardware

00:09:01,760 --> 00:09:05,440
state or it can be restored by reading

00:09:04,640 --> 00:09:07,680
back

00:09:05,440 --> 00:09:09,600
the hardware registers then we don't

00:09:07,680 --> 00:09:12,480
need to save it

00:09:09,600 --> 00:09:13,760
if we can only restore it by clobbering

00:09:12,480 --> 00:09:18,640
the hardware

00:09:13,760 --> 00:09:18,640
register then we will need to save it

00:09:19,360 --> 00:09:22,720
all the gray states in the picture are

00:09:21,600 --> 00:09:24,959
those

00:09:22,720 --> 00:09:26,480
we don't need to save because we can

00:09:24,959 --> 00:09:30,959
reconstruct them without

00:09:26,480 --> 00:09:33,360
clobbering hardware registers and second

00:09:30,959 --> 00:09:35,760
we don't want the resulting state saving

00:09:33,360 --> 00:09:39,200
code to be too much intrusive

00:09:35,760 --> 00:09:42,720
to other kernel components pass-through

00:09:39,200 --> 00:09:46,080
devices are managed by vfio driver

00:09:42,720 --> 00:09:50,560
it is reasonable to put major device

00:09:46,080 --> 00:09:53,200
keep life management logic in vfio layer

00:09:50,560 --> 00:09:55,440
so as not to touch other components too

00:09:53,200 --> 00:09:55,440
much

00:09:55,760 --> 00:10:02,240
and third if we need to save it

00:09:59,120 --> 00:10:04,240
which stage does it belong to is it

00:10:02,240 --> 00:10:05,600
manipulated by two male run time

00:10:04,240 --> 00:10:08,959
operations

00:10:05,600 --> 00:10:10,640
or will it only be destroyed by kernel

00:10:08,959 --> 00:10:13,920
reboot

00:10:10,640 --> 00:10:16,640
for example the vfio pci

00:10:13,920 --> 00:10:18,320
device data structure has hardware

00:10:16,640 --> 00:10:20,480
dependent states

00:10:18,320 --> 00:10:22,240
the underlying pci device will be

00:10:20,480 --> 00:10:24,399
disabled when tumor quits

00:10:22,240 --> 00:10:26,160
and it will it will be enabled by

00:10:24,399 --> 00:10:29,760
communal restarts

00:10:26,160 --> 00:10:32,880
so it belongs to stage 1.

00:10:29,760 --> 00:10:36,880
in later slides we will look into these

00:10:32,880 --> 00:10:36,880
keep alive states in more details

00:10:37,600 --> 00:10:41,440
now let's dive a little bit deeper to

00:10:40,000 --> 00:10:45,120
see how we keep

00:10:41,440 --> 00:10:50,880
alive the two major device

00:10:45,120 --> 00:10:50,880
keep live states irq and bma

00:10:52,160 --> 00:10:56,160
the challenge for keeping ir2 alive is

00:10:55,120 --> 00:10:58,480
that

00:10:56,160 --> 00:10:59,200
during the key exact reboot both

00:10:58,480 --> 00:11:01,440
hardware

00:10:59,200 --> 00:11:02,800
and software are not available to handle

00:11:01,440 --> 00:11:05,640
the irq

00:11:02,800 --> 00:11:07,279
cpu is undergoing reboot and

00:11:05,640 --> 00:11:10,640
re-initialization

00:11:07,279 --> 00:11:14,079
software is not ready either

00:11:10,640 --> 00:11:17,760
there are two options to keep irq alive

00:11:14,079 --> 00:11:18,079
first one is to mask irq when the device

00:11:17,760 --> 00:11:21,120
is

00:11:18,079 --> 00:11:24,320
put into keep alive state and unmask

00:11:21,120 --> 00:11:27,279
it when vm resumes

00:11:24,320 --> 00:11:29,600
in this way device can hold from issuing

00:11:27,279 --> 00:11:33,279
irq during the

00:11:29,600 --> 00:11:34,800
restart period the problem of this

00:11:33,279 --> 00:11:38,480
approach is that

00:11:34,800 --> 00:11:41,120
msi masking is an optional feature

00:11:38,480 --> 00:11:42,079
of pci devices which means there are

00:11:41,120 --> 00:11:46,800
some devices

00:11:42,079 --> 00:11:46,800
that don't support msi masking

00:11:47,200 --> 00:11:51,760
another approach is to leverage posted

00:11:49,279 --> 00:11:55,600
interrupt which we choose here

00:11:51,760 --> 00:11:58,399
it doesn't depend on msi or msix

00:11:55,600 --> 00:12:00,959
so it is more generic and has more

00:11:58,399 --> 00:12:00,959
coverage

00:12:01,040 --> 00:12:07,279
the irq setup and teardown are triggered

00:12:04,079 --> 00:12:10,720
from the vfio pci device layer

00:12:07,279 --> 00:12:13,680
it goes through the pci and irq

00:12:10,720 --> 00:12:15,279
core layer down to the irq remapping

00:12:13,680 --> 00:12:18,320
driver to locate

00:12:15,279 --> 00:12:21,680
or free the irte which means

00:12:18,320 --> 00:12:25,200
interrupt remapping table entry

00:12:21,680 --> 00:12:28,240
meanwhile the kvm side will allocate

00:12:25,200 --> 00:12:31,600
posted interrupted descriptor pid

00:12:28,240 --> 00:12:32,560
for the vcpu it will be connected to the

00:12:31,600 --> 00:12:38,880
specific

00:12:32,560 --> 00:12:41,519
device interrupt vector via the irte

00:12:38,880 --> 00:12:42,720
so here we basically have three things

00:12:41,519 --> 00:12:47,040
to preserve

00:12:42,720 --> 00:12:48,480
pid irte and the device interrupt vector

00:12:47,040 --> 00:12:51,519
index

00:12:48,480 --> 00:12:51,920
the device interrupt vector index is not

00:12:51,519 --> 00:12:54,959
shown

00:12:51,920 --> 00:12:58,240
in this picture it is saved

00:12:54,959 --> 00:13:03,040
in the qmil snapshot next

00:12:58,240 --> 00:13:03,040
we will talk about how we save pid and

00:13:04,839 --> 00:13:10,320
irte

00:13:07,120 --> 00:13:13,519
there are also two options to notify kvm

00:13:10,320 --> 00:13:16,720
site to preserve pid

00:13:13,519 --> 00:13:20,560
one is to introduce io control

00:13:16,720 --> 00:13:23,040
comments so that qmu can issue to kvm

00:13:20,560 --> 00:13:25,680
side to save the pid

00:13:23,040 --> 00:13:26,800
another one is to leverage irq bypass

00:13:25,680 --> 00:13:29,920
mechanism

00:13:26,800 --> 00:13:33,200
which is currently used by vfio driver

00:13:29,920 --> 00:13:36,639
to notify kvm site to enable or disable

00:13:33,200 --> 00:13:36,639
posted interrupt mode

00:13:37,040 --> 00:13:40,880
we introduced two callback interfaces

00:13:39,600 --> 00:13:43,920
for the irq

00:13:40,880 --> 00:13:47,040
bypass consumer data structure

00:13:43,920 --> 00:13:50,480
when the device enters keep alive state

00:13:47,040 --> 00:13:54,800
the callback safe consumer

00:13:50,480 --> 00:13:57,120
will be invoked from the vfio side

00:13:54,800 --> 00:13:57,839
it will eventually trigger a newly added

00:13:57,120 --> 00:14:00,880
callback

00:13:57,839 --> 00:14:04,880
in the kvm x 86

00:14:00,880 --> 00:14:09,120
ops which will save pid and set the

00:14:04,880 --> 00:14:09,120
suppress notification bit in the pid

00:14:10,800 --> 00:14:17,839
and for irte again two options

00:14:14,399 --> 00:14:21,279
for preserving it it is a long code

00:14:17,839 --> 00:14:23,040
path as we mentioned to set up or tear

00:14:21,279 --> 00:14:26,240
down an irq

00:14:23,040 --> 00:14:29,199
it starts from vfio driver goes

00:14:26,240 --> 00:14:30,160
through the pci core and the irq core

00:14:29,199 --> 00:14:33,040
layers

00:14:30,160 --> 00:14:34,720
and finally it arrives at irq remapping

00:14:33,040 --> 00:14:38,240
driver

00:14:34,720 --> 00:14:40,480
if we want to make the pci core and irq

00:14:38,240 --> 00:14:42,639
core layer to be aware of the keeper

00:14:40,480 --> 00:14:45,519
live saving and restoring

00:14:42,639 --> 00:14:46,880
then we will need to introduce apis and

00:14:45,519 --> 00:14:50,000
pretty much code changes

00:14:46,880 --> 00:14:53,199
into these two core kernel layers

00:14:50,000 --> 00:14:55,920
which may be much intrusive to the

00:14:53,199 --> 00:14:55,920
two layers

00:14:56,480 --> 00:15:00,240
so we choose another approach by which

00:14:59,519 --> 00:15:03,120
we

00:15:00,240 --> 00:15:04,240
reuse most of the irq setup and teardown

00:15:03,120 --> 00:15:07,519
code pass

00:15:04,240 --> 00:15:11,519
we just check the device kepler flag

00:15:07,519 --> 00:15:13,760
at the irq remapping driver

00:15:11,519 --> 00:15:14,720
if the device is kept alive then we

00:15:13,760 --> 00:15:18,079
don't free

00:15:14,720 --> 00:15:21,760
the irte when iq is turned down

00:15:18,079 --> 00:15:24,720
instead we save the irte aside

00:15:21,760 --> 00:15:26,000
we also record the mapping between the

00:15:24,720 --> 00:15:29,120
irte and the

00:15:26,000 --> 00:15:30,959
irq vector index within the device so

00:15:29,120 --> 00:15:34,320
that they can be reconnected

00:15:30,959 --> 00:15:35,680
when the device iq vector index is reset

00:15:34,320 --> 00:15:38,480
up

00:15:35,680 --> 00:15:39,360
in this way we can introduce less

00:15:38,480 --> 00:15:44,399
intrusive

00:15:39,360 --> 00:15:44,399
code change for all the involved layers

00:15:47,040 --> 00:15:53,759
for dma states preserving

00:15:50,320 --> 00:15:56,320
we need to preserve the dma page table

00:15:53,759 --> 00:15:57,279
domain id and various iomu

00:15:56,320 --> 00:16:01,440
configurations

00:15:57,279 --> 00:16:04,720
for example the root table of the iomu

00:16:01,440 --> 00:16:07,360
the context table etc

00:16:04,720 --> 00:16:07,839
there is a dilemma situation for us

00:16:07,360 --> 00:16:12,160
about

00:16:07,839 --> 00:16:14,800
whether to preserve iomu domain or not

00:16:12,160 --> 00:16:16,720
the iomu domain data structure is a

00:16:14,800 --> 00:16:18,000
software data structure which can be

00:16:16,720 --> 00:16:21,279
recreated without

00:16:18,000 --> 00:16:22,000
clobbering hardware states if we do

00:16:21,279 --> 00:16:24,800
recreate

00:16:22,000 --> 00:16:25,360
it we will have pretty much code change

00:16:24,800 --> 00:16:28,880
to

00:16:25,360 --> 00:16:32,480
iomu driver on the other hand

00:16:28,880 --> 00:16:35,519
if we preserve it most of the code

00:16:32,480 --> 00:16:38,480
change will be in vfio

00:16:35,519 --> 00:16:39,759
then do we want to consider other device

00:16:38,480 --> 00:16:43,600
pass-through framework

00:16:39,759 --> 00:16:46,240
such as vdpa

00:16:43,600 --> 00:16:47,519
it looks more reasonable to let the iomu

00:16:46,240 --> 00:16:51,440
driver to do more things

00:16:47,519 --> 00:16:53,839
than both vdpa and vfio duplicate the

00:16:51,440 --> 00:16:56,480
efforts

00:16:53,839 --> 00:16:58,560
currently our poc work choose to

00:16:56,480 --> 00:17:05,360
preserve the iommu

00:16:58,560 --> 00:17:08,079
and this and leave this issue as an open

00:17:05,360 --> 00:17:09,120
device ownership authentication is a

00:17:08,079 --> 00:17:12,319
security issue

00:17:09,120 --> 00:17:12,799
we need to consider this is because when

00:17:12,319 --> 00:17:14,799
we

00:17:12,799 --> 00:17:16,079
when the pass-through device is put into

00:17:14,799 --> 00:17:19,120
keep live state

00:17:16,079 --> 00:17:19,919
it will be detached from its owner when

00:17:19,120 --> 00:17:22,640
the resumed

00:17:19,919 --> 00:17:25,199
vm is trying to reattach to the device

00:17:22,640 --> 00:17:26,640
there must be a mechanism to verify the

00:17:25,199 --> 00:17:29,840
ownership

00:17:26,640 --> 00:17:32,960
we leverage the vf token mechanism which

00:17:29,840 --> 00:17:33,679
is an existing feature of current vfio

00:17:32,960 --> 00:17:37,120
driver

00:17:33,679 --> 00:17:40,160
to do the job a token will be set

00:17:37,120 --> 00:17:43,600
into the vfio device when it is

00:17:40,160 --> 00:17:46,480
put into keep live state then

00:17:43,600 --> 00:17:49,280
when the cumulative starts it needs to

00:17:46,480 --> 00:17:53,520
pass the token to the kernel vfi driver

00:17:49,280 --> 00:17:53,520
in order to reopen the password device

00:17:57,280 --> 00:18:04,320
k exact reboot procedure also need some

00:18:00,960 --> 00:18:06,880
modifications we introduce a keep

00:18:04,320 --> 00:18:08,480
live callback notifier before okay exact

00:18:06,880 --> 00:18:11,360
reboot happens

00:18:08,480 --> 00:18:12,720
where the stage two keep live states can

00:18:11,360 --> 00:18:14,880
be preserved

00:18:12,720 --> 00:18:17,120
and all the cape lab states can be

00:18:14,880 --> 00:18:20,320
copied to the persistent memory

00:18:17,120 --> 00:18:21,360
to pass to the new kernel after the new

00:18:20,320 --> 00:18:24,799
kernel starts

00:18:21,360 --> 00:18:27,360
to re to boot all the keep alive states

00:18:24,799 --> 00:18:28,240
will be copied back from the persistent

00:18:27,360 --> 00:18:31,919
memory

00:18:28,240 --> 00:18:34,160
so that device states can be restored

00:18:31,919 --> 00:18:36,080
pass through device list is another

00:18:34,160 --> 00:18:38,320
important information that needs to

00:18:36,080 --> 00:18:39,760
pass to the new kernel so that the new

00:18:38,320 --> 00:18:41,440
kernel can identify the

00:18:39,760 --> 00:18:43,760
keep alive devices and do special

00:18:41,440 --> 00:18:48,080
handling during

00:18:43,760 --> 00:18:50,720
pci enumeration we also need a memory

00:18:48,080 --> 00:18:52,799
handover mechanism to pass all this data

00:18:50,720 --> 00:18:57,440
from out kernel to new kernel

00:18:52,799 --> 00:18:57,440
and so if oracle has a proposal for us

00:18:59,520 --> 00:19:03,679
for keep alive devices pci enumeration

00:19:02,880 --> 00:19:06,720
procedure

00:19:03,679 --> 00:19:09,200
needs special handling basically

00:19:06,720 --> 00:19:10,160
we can't re-initialize the device

00:19:09,200 --> 00:19:12,400
instead we

00:19:10,160 --> 00:19:14,320
need to restore the states from the data

00:19:12,400 --> 00:19:17,679
passed from out kernel

00:19:14,320 --> 00:19:18,640
meanwhile we can't reassign pci bar

00:19:17,679 --> 00:19:21,919
resources

00:19:18,640 --> 00:19:22,400
to the keep live devices instead we need

00:19:21,919 --> 00:19:25,039
to

00:19:22,400 --> 00:19:25,760
inherit the resources from outcome which

00:19:25,039 --> 00:19:28,000
are already

00:19:25,760 --> 00:19:30,559
recorded in the bar registers of the

00:19:28,000 --> 00:19:30,559
devices

00:19:31,600 --> 00:19:37,520
so until now we have talked about how we

00:19:34,480 --> 00:19:41,120
handle the many issues we will encounter

00:19:37,520 --> 00:19:44,320
for the vm and fast restart

00:19:41,120 --> 00:19:46,400
however we still have many opens first

00:19:44,320 --> 00:19:47,520
we still can't make the keeper live flag

00:19:46,400 --> 00:19:51,360
transparent

00:19:47,520 --> 00:19:52,080
to pci core code we check device keep

00:19:51,360 --> 00:19:55,679
live flag

00:19:52,080 --> 00:19:58,720
in msi msix irq set up and tier

00:19:55,679 --> 00:20:02,559
done code pass to avoid the clobbering

00:19:58,720 --> 00:20:04,799
hardware msi msix registers

00:20:02,559 --> 00:20:06,159
do we want to check the keep align flag

00:20:04,799 --> 00:20:09,440
in all pci

00:20:06,159 --> 00:20:12,480
core code paths since we already

00:20:09,440 --> 00:20:16,880
introduced this flag would that be

00:20:12,480 --> 00:20:20,400
too intrusive to pci core code

00:20:16,880 --> 00:20:23,200
and what about pci enumeration failure

00:20:20,400 --> 00:20:26,559
because of resource conflict how do we

00:20:23,200 --> 00:20:26,559
notify camera about this

00:20:28,880 --> 00:20:32,320
and since all the dependent devices

00:20:30,960 --> 00:20:35,840
along the i o paths

00:20:32,320 --> 00:20:35,840
also need to be kept live

00:20:35,919 --> 00:20:39,039
how do we handle the states of these

00:20:38,080 --> 00:20:42,880
devices

00:20:39,039 --> 00:20:44,880
for example switch port and root port

00:20:42,880 --> 00:20:47,120
they may register irqs for different

00:20:44,880 --> 00:20:49,679
pcie capabilities

00:20:47,120 --> 00:20:50,720
can we just disable them when keep live

00:20:49,679 --> 00:20:52,799
operation starts

00:20:50,720 --> 00:20:53,760
and read events back from their status

00:20:52,799 --> 00:20:57,120
registers

00:20:53,760 --> 00:20:58,080
after we reboot and re-inject those

00:20:57,120 --> 00:21:01,679
event into

00:20:58,080 --> 00:21:05,440
guest and what about

00:21:01,679 --> 00:21:08,000
sriov and s-ilv support

00:21:05,440 --> 00:21:08,960
pf device states also need to be

00:21:08,000 --> 00:21:11,919
preserved

00:21:08,960 --> 00:21:11,919
how do we do that

00:21:14,799 --> 00:21:21,440
currently we have finished the poc of

00:21:18,640 --> 00:21:22,559
cumin fast restart and the full vmm fast

00:21:21,440 --> 00:21:25,679
restart

00:21:22,559 --> 00:21:28,400
with our testing environment which is

00:21:25,679 --> 00:21:32,720
hardwell and broadwell platform with

00:21:28,400 --> 00:21:36,159
intel nic card youtube video streaming

00:21:32,720 --> 00:21:39,600
and scp workloads in vm can be restored

00:21:36,159 --> 00:21:39,600
after k exact reboot

00:21:39,760 --> 00:21:45,200
we hope this effort can go to upstream

00:21:43,440 --> 00:21:50,080
so would like to have your comments and

00:21:45,200 --> 00:21:50,080
suggestions and cooperation is welcome

00:21:56,640 --> 00:22:10,240

YouTube URL: https://www.youtube.com/watch?v=wW_ayDQr4Q8


