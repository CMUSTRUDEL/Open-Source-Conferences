Title: [2020] Speed Up Creation of a VM With Pass Through GPU by Liang Li
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Creating a virtual machine (VM) instance with GPU will take more time than creating a VM without GPU, the gap depends on many factors, eg. System configuration, RAM size of VM, type of GPU and the count of GPU cards, from several seconds to serval minutes. It impacts user experience, and in some situation it becomes unacceptable. In this session, Liang will first introduce the factors affect the creation time of a VM with GPU, and then elaborate some issues in QEMU and linux kernel. In the end, Liang will show the solutions for these issues in detail and their achievement for the optimization.

---

Liang Li
DIDI Chuxing, Senior Expert Engineer

Liang has 7 years experience in embedded system software development and 7 years experience in system virtualization. He is working for DIDI and focus in the area of system virtualization and public cloud. He had two topics about live migration optimization on KVM forum in 2015 and in 2016.
Captions: 
	00:00:06,879 --> 00:00:10,960
hello everyone

00:00:08,240 --> 00:00:14,960
my name is leon and i'm from the

00:00:10,960 --> 00:00:18,720
infrastructure team of td tuition

00:00:14,960 --> 00:00:19,520
let's get started with the rapid

00:00:18,720 --> 00:00:21,439
development

00:00:19,520 --> 00:00:23,519
of artificial intelligence in these

00:00:21,439 --> 00:00:28,640
years gpu plays

00:00:23,519 --> 00:00:31,119
a very important role and is widely used

00:00:28,640 --> 00:00:32,960
it has usually provided as a form or

00:00:31,119 --> 00:00:35,920
virtual machine instance by cloud

00:00:32,960 --> 00:00:35,920
service providers

00:00:36,160 --> 00:00:39,600
for some technical reasons creating

00:00:38,800 --> 00:00:44,399
virtual machine

00:00:39,600 --> 00:00:46,960
with a password field card is very slow

00:00:44,399 --> 00:00:50,399
which is a common issue faced by all's

00:00:46,960 --> 00:00:50,399
cloud service providers

00:00:50,480 --> 00:00:53,600
today i will share you with a practice

00:00:53,280 --> 00:00:59,840
that

00:00:53,600 --> 00:00:59,840
how dd through this issue

00:01:04,559 --> 00:01:08,720
the agenda of my presentation contains

00:01:06,799 --> 00:01:12,159
the following parts

00:01:08,720 --> 00:01:14,960
the first part is a background and

00:01:12,159 --> 00:01:16,880
the second part we release the main

00:01:14,960 --> 00:01:18,880
issues slow down the creation

00:01:16,880 --> 00:01:21,200
of a virtual machine with the

00:01:18,880 --> 00:01:22,960
pass-through gpu card

00:01:21,200 --> 00:01:26,159
the third part will give you some

00:01:22,960 --> 00:01:29,439
details of the solutions and

00:01:26,159 --> 00:01:32,799
then the fact of the optimization

00:01:29,439 --> 00:01:40,240
will be shown the last part

00:01:32,799 --> 00:01:42,960
is the conclusion

00:01:40,240 --> 00:01:44,320
in this topic i will call a virtual

00:01:42,960 --> 00:01:47,759
machine without

00:01:44,320 --> 00:01:49,680
or pass through psi device as a cpu

00:01:47,759 --> 00:01:52,159
virtual machine

00:01:49,680 --> 00:01:54,159
and the watch machine with one or more

00:01:52,159 --> 00:01:57,520
possible gpu cars

00:01:54,159 --> 00:01:57,520
as a gpu virtual machine

00:01:57,840 --> 00:02:01,680
creating a cpu world machine instance is

00:02:00,399 --> 00:02:05,119
fast

00:02:01,680 --> 00:02:08,000
it usually takes several seconds

00:02:05,119 --> 00:02:08,879
while creating a gp virtual machine

00:02:08,000 --> 00:02:11,360
instance

00:02:08,879 --> 00:02:12,800
with the same resource configuration is

00:02:11,360 --> 00:02:16,080
slow

00:02:12,800 --> 00:02:19,760
it may take several minutes if the

00:02:16,080 --> 00:02:19,760
virtual machine has a lot of ram

00:02:20,319 --> 00:02:25,760
in most cases virtual machine creation

00:02:22,879 --> 00:02:28,800
time is not critical

00:02:25,760 --> 00:02:30,879
but in some interactivity scenario

00:02:28,800 --> 00:02:32,319
a long watch machine instance creation

00:02:30,879 --> 00:02:34,800
time means

00:02:32,319 --> 00:02:37,840
poor user experience and computing

00:02:34,800 --> 00:02:37,840
resource waste

00:02:45,840 --> 00:02:49,120
virtual machine creation time is defined

00:02:48,400 --> 00:02:51,680
as a time

00:02:49,120 --> 00:02:53,200
interval between cumulative process

00:02:51,680 --> 00:02:56,879
starts to execute

00:02:53,200 --> 00:02:56,879
and its guest color start to run

00:02:57,360 --> 00:03:04,400
is divided into two parts the first part

00:03:01,040 --> 00:03:07,200
is virtual machine initialization time

00:03:04,400 --> 00:03:08,640
which is defined as a time interval

00:03:07,200 --> 00:03:11,599
between cumulative process

00:03:08,640 --> 00:03:14,000
start to execute and the wii cpu start

00:03:11,599 --> 00:03:14,000
to run

00:03:14,319 --> 00:03:20,879
the second part is bios execution time

00:03:18,239 --> 00:03:22,879
which is defined as the time interval

00:03:20,879 --> 00:03:24,959
between which cpu start run

00:03:22,879 --> 00:03:27,360
and the first guest current log is

00:03:24,959 --> 00:03:27,360
printed

00:03:27,440 --> 00:03:31,680
the chart in the right shows the

00:03:29,840 --> 00:03:32,080
creation time of different virtual

00:03:31,680 --> 00:03:36,000
machine

00:03:32,080 --> 00:03:36,000
instance before optimization

00:03:36,080 --> 00:03:39,680
some factors like virtual machine ram

00:03:38,720 --> 00:03:43,280
size

00:03:39,680 --> 00:03:46,159
the type or gpu card and the count

00:03:43,280 --> 00:03:48,879
or gpu cards will affect virtual machine

00:03:46,159 --> 00:03:48,879
creation time

00:03:54,400 --> 00:03:57,760
you will be curious about the reason for

00:03:56,799 --> 00:04:00,959
the long time

00:03:57,760 --> 00:04:03,439
it takes when creating a gpu virtual

00:04:00,959 --> 00:04:07,840
machine instance

00:04:03,439 --> 00:04:10,799
what slow down the creation process

00:04:07,840 --> 00:04:12,720
to find out the reason we can use perf

00:04:10,799 --> 00:04:16,560
to get the hot spot functions

00:04:12,720 --> 00:04:19,199
of cumulative the flame graph

00:04:16,560 --> 00:04:21,600
in this page shows the hotspot is in the

00:04:19,199 --> 00:04:29,840
coding or call function

00:04:21,600 --> 00:04:29,840
wii fio pinpage remote

00:04:31,600 --> 00:04:36,800
this page lists the main factors

00:04:35,120 --> 00:04:38,400
slowing down the virtual machine

00:04:36,800 --> 00:04:41,919
creation

00:04:38,400 --> 00:04:43,759
the key factors is a function with fio

00:04:41,919 --> 00:04:46,240
pin page remote

00:04:43,759 --> 00:04:46,240
is slow

00:04:47,600 --> 00:04:52,000
by debug you will find some repeated wii

00:04:50,479 --> 00:04:56,320
file dma map

00:04:52,000 --> 00:04:59,600
and on map for the same ioa

00:04:56,320 --> 00:04:59,600
which makes sense worse

00:04:59,680 --> 00:05:07,520
besides that psi device reset

00:05:03,520 --> 00:05:10,160
management metadata initialization in qm

00:05:07,520 --> 00:05:10,880
and other is seniors configuration will

00:05:10,160 --> 00:05:14,720
slow down

00:05:10,880 --> 00:05:14,720
virtual machine instance creation

00:05:14,800 --> 00:05:25,840
i will describe these factors in detail

00:05:26,400 --> 00:05:33,360
for wii file pin page remote

00:05:29,440 --> 00:05:36,400
there are two main issues making it slow

00:05:33,360 --> 00:05:38,720
the first one is zero out operation

00:05:36,400 --> 00:05:41,520
which is required when allocating pages

00:05:38,720 --> 00:05:44,400
for user space

00:05:41,520 --> 00:05:45,840
server also page content will make sure

00:05:44,400 --> 00:05:49,120
sensitive information

00:05:45,840 --> 00:05:51,440
invisible to user space

00:05:49,120 --> 00:05:53,280
because page allocated may have been

00:05:51,440 --> 00:05:56,800
used by other process

00:05:53,280 --> 00:05:57,520
of the kernel and has sensitive

00:05:56,800 --> 00:06:00,639
information

00:05:57,520 --> 00:06:03,520
retained as

00:06:00,639 --> 00:06:04,560
a solution we introduced a new feature

00:06:03,520 --> 00:06:07,840
called

00:06:04,560 --> 00:06:11,600
pre-zero all free pages to speed up

00:06:07,840 --> 00:06:14,960
page publication the idea

00:06:11,600 --> 00:06:19,280
is simple there are three pages

00:06:14,960 --> 00:06:23,520
in advance some when allocating pages

00:06:19,280 --> 00:06:23,520
page zero out can be skipped

00:06:25,680 --> 00:06:32,639
the second issue is the wii fio dma map

00:06:29,360 --> 00:06:33,520
p memory in all page by page way this

00:06:32,639 --> 00:06:37,520
results in

00:06:33,520 --> 00:06:37,520
too many page table entries access

00:06:38,319 --> 00:06:49,840
as a solution pin memory embark is used

00:06:41,919 --> 00:06:49,840
to reduce the cost

00:06:50,720 --> 00:06:54,560
for preserve our free page it is based

00:06:54,160 --> 00:06:57,680
on

00:06:54,560 --> 00:07:01,840
three page reporting paste

00:06:57,680 --> 00:07:05,199
out operation is down in your code works

00:07:01,840 --> 00:07:06,080
after page is zeroed out cell's page

00:07:05,199 --> 00:07:09,280
zero flag

00:07:06,080 --> 00:07:13,599
is corresponding page struct

00:07:09,280 --> 00:07:17,120
one page allocated list to be zeroed out

00:07:13,599 --> 00:07:22,720
check page zero flag first

00:07:17,120 --> 00:07:22,720
if is set zero operation can be skipped

00:07:23,919 --> 00:07:27,520
when pages are free peggy zero flag is

00:07:26,800 --> 00:07:33,199
cleared

00:07:27,520 --> 00:07:33,199
and the zero out worker will be woken up

00:07:35,120 --> 00:07:38,479
i have sent the rfc patch set to

00:07:37,440 --> 00:07:41,520
upstream

00:07:38,479 --> 00:07:44,720
you can find the implementation details

00:07:41,520 --> 00:07:47,680
with the link in this page i will

00:07:44,720 --> 00:07:47,680
talk more about it

00:07:54,560 --> 00:07:58,400
to make weak file dma map p memory

00:07:57,360 --> 00:08:01,759
embark

00:07:58,400 --> 00:08:03,599
we add two functions in kernel they are

00:08:01,759 --> 00:08:07,680
get user city page

00:08:03,599 --> 00:08:10,800
and get user page long term

00:08:07,680 --> 00:08:14,560
they are corresponding to get user page

00:08:10,800 --> 00:08:14,560
and get user page long term

00:08:14,879 --> 00:08:20,319
ct here means physical continuous

00:08:18,000 --> 00:08:21,840
the new function will try to pin memory

00:08:20,319 --> 00:08:24,840
and get the information

00:08:21,840 --> 00:08:27,840
about opaque or physical continuous

00:08:24,840 --> 00:08:27,840
memory

00:08:28,000 --> 00:08:32,000
the chart on the right shows the

00:08:29,840 --> 00:08:35,200
different behavior of the new function

00:08:32,000 --> 00:08:35,200
and the original one

00:08:36,479 --> 00:08:40,080
the new function will be friendlier to

00:08:39,039 --> 00:08:43,599
function

00:08:40,080 --> 00:08:47,440
we order get pfn and make its life

00:08:43,599 --> 00:08:47,440
easier to pin memory embark

00:08:48,720 --> 00:08:55,839
to take more benefits huge page should

00:08:51,360 --> 00:08:55,839
be used

00:09:00,320 --> 00:09:08,399
we fio dma map is inefficient

00:09:04,399 --> 00:09:09,519
there are two reasons for this the first

00:09:08,399 --> 00:09:13,920
one is the same

00:09:09,519 --> 00:09:18,880
ioa map experienced as a map

00:09:13,920 --> 00:09:22,480
on map and then remap per setting

00:09:18,880 --> 00:09:25,600
it's unreasonable

00:09:22,480 --> 00:09:28,959
to solve this issue the mapped

00:09:25,600 --> 00:09:32,399
iov aerial information are retained

00:09:28,959 --> 00:09:32,880
in qmu to avoid unnecessary wii fio dma

00:09:32,399 --> 00:09:36,000
map

00:09:32,880 --> 00:09:39,200
and unmap operation

00:09:36,000 --> 00:09:42,320
for the horse's work we fio

00:09:39,200 --> 00:09:47,120
iomu unmapped dma our control is all

00:09:42,320 --> 00:09:50,160
called with map of conflict ioa

00:09:47,120 --> 00:09:51,120
conflict here means a new added airway

00:09:50,160 --> 00:09:53,360
area

00:09:51,120 --> 00:09:56,000
which is intersected with an already

00:09:53,360 --> 00:09:59,440
mapped ioa area

00:09:56,000 --> 00:09:59,440
but not equal to it

00:10:02,480 --> 00:10:06,000
the second issue is inefficient iowa

00:10:05,440 --> 00:10:09,600
area

00:10:06,000 --> 00:10:12,399
mapping update for example

00:10:09,600 --> 00:10:13,200
to change or tribute or sub-region or an

00:10:12,399 --> 00:10:15,760
ioa

00:10:13,200 --> 00:10:16,480
area which is already mapped the whole

00:10:15,760 --> 00:10:19,519
iowa

00:10:16,480 --> 00:10:23,680
area needs to be unmapped first and then

00:10:19,519 --> 00:10:27,040
be mapped again this will happen for an

00:10:23,680 --> 00:10:29,680
iowa area contains the address of

00:10:27,040 --> 00:10:29,680
one mega

00:10:30,160 --> 00:10:37,279
as a solution the iova error is split

00:10:34,399 --> 00:10:37,279
into two parts

00:10:38,480 --> 00:10:44,839
one part is below

00:10:41,600 --> 00:10:46,160
one mega and the last part is about

00:10:44,839 --> 00:10:49,600
omega

00:10:46,160 --> 00:10:52,720
it can it can prevent high part

00:10:49,600 --> 00:10:54,000
iowa error from being unmapped for

00:10:52,720 --> 00:11:01,839
modifications

00:10:54,000 --> 00:11:01,839
to slow part

00:11:03,360 --> 00:11:08,560
for pci device reset one reset takes

00:11:06,720 --> 00:11:11,760
about one second

00:11:08,560 --> 00:11:14,880
so it's a slow operation

00:11:11,760 --> 00:11:17,120
there are two issues in qmu the first

00:11:14,880 --> 00:11:17,120
one

00:11:17,360 --> 00:11:20,640
a device was reset price during virtual

00:11:20,160 --> 00:11:23,200
machine

00:11:20,640 --> 00:11:23,200
creation

00:11:24,079 --> 00:11:31,519
one eating function q system reset

00:11:28,240 --> 00:11:34,800
and another one in wii file group

00:11:31,519 --> 00:11:37,920
get device fdio control

00:11:34,800 --> 00:11:42,880
reset ties is redundant

00:11:37,920 --> 00:11:45,279
one of them can be removed

00:11:42,880 --> 00:11:46,000
the second issue is psi device reset

00:11:45,279 --> 00:11:51,120
operation

00:11:46,000 --> 00:11:51,120
are specifying a 0 are serialized

00:11:52,079 --> 00:11:56,639
if a virtual machine has more than 1 gpu

00:11:54,880 --> 00:12:00,800
cards it will

00:11:56,639 --> 00:12:00,800
take more time to reset the device

00:12:01,680 --> 00:12:07,360
do the pci device reset in parallel will

00:12:04,800 --> 00:12:10,000
be more scalable

00:12:07,360 --> 00:12:10,560
and furthermore make the pci device

00:12:10,000 --> 00:12:13,920
reset

00:12:10,560 --> 00:12:24,320
in parallel with vlfio dme map

00:12:13,920 --> 00:12:28,160
can maximizing the benefits

00:12:24,320 --> 00:12:29,360
for qm color model there are some time

00:12:28,160 --> 00:12:32,560
consuming operations

00:12:29,360 --> 00:12:35,920
which can be optimized

00:12:32,560 --> 00:12:38,160
third page bitmap initialization is one

00:12:35,920 --> 00:12:40,560
of them

00:12:38,160 --> 00:12:41,839
virtual machine with a pass-through gpu

00:12:40,560 --> 00:12:44,959
does not support

00:12:41,839 --> 00:12:47,120
level migration currently so third-party

00:12:44,959 --> 00:12:50,480
login for a pci bar

00:12:47,120 --> 00:12:53,760
specified mmi

00:12:50,480 --> 00:12:57,519
mm-io range is a useless

00:12:53,760 --> 00:13:00,959
which can be skipped when pml

00:12:57,519 --> 00:13:04,959
is enabled instead if he enters dbit

00:13:00,959 --> 00:13:04,959
is a last time consuming operation

00:13:05,120 --> 00:13:10,320
it uses reverse map to get the ept

00:13:08,880 --> 00:13:12,639
entries for setting the

00:13:10,320 --> 00:13:12,639
db

00:13:14,720 --> 00:13:20,399
closing all the reverse map entries

00:13:18,240 --> 00:13:23,680
are time consuming if the virtual

00:13:20,399 --> 00:13:23,680
machine has a large ram

00:13:24,320 --> 00:13:28,320
during the virtual machine creation most

00:13:26,800 --> 00:13:32,800
of the ep entrants

00:13:28,320 --> 00:13:35,760
are empty so croatian or the reverse

00:13:32,800 --> 00:13:36,639
map to find a few or effective ep

00:13:35,760 --> 00:13:40,320
entries

00:13:36,639 --> 00:13:41,440
is lot worse this can be improved by

00:13:40,320 --> 00:13:45,360
making the reverse

00:13:41,440 --> 00:13:47,760
map closer more efficient for example

00:13:45,360 --> 00:13:49,600
we can introduce a sparse bitmap

00:13:47,760 --> 00:13:53,120
merchandising

00:13:49,600 --> 00:13:54,399
like hb map used in qview to skip the

00:13:53,120 --> 00:13:58,560
empty reverse map

00:13:54,399 --> 00:14:00,959
entries in our environment

00:13:58,560 --> 00:14:04,160
we use a lot of simple way to serve this

00:14:00,959 --> 00:14:07,279
issue by counting the effective

00:14:04,160 --> 00:14:07,279
reverse map entries

00:14:07,680 --> 00:14:15,120
silver's map entrance for memory slot

00:14:10,800 --> 00:14:19,199
can be skipped if we so factor

00:14:15,120 --> 00:14:19,199
reverse map entries count is zero

00:14:20,000 --> 00:14:25,760
this is not an ideal solution but

00:14:23,040 --> 00:14:28,560
it is a balance between benefits and the

00:14:25,760 --> 00:14:28,560
development

00:14:28,839 --> 00:14:31,839
complexity

00:14:36,720 --> 00:14:42,560
there are some configurations which will

00:14:39,040 --> 00:14:46,720
affect the virtual machine creation time

00:14:42,560 --> 00:14:50,639
see i listed uh listed about

00:14:46,720 --> 00:14:53,600
c bios with mario has 2.5 seconds of

00:14:50,639 --> 00:14:56,720
timeout by default

00:14:53,600 --> 00:14:59,839
if we put manual is unnecessary please

00:14:56,720 --> 00:14:59,839
disable it

00:15:00,720 --> 00:15:04,720
if linux guest is used the graph may

00:15:03,440 --> 00:15:08,160
configure a timeout

00:15:04,720 --> 00:15:11,120
for selecting different color

00:15:08,160 --> 00:15:13,839
if is unnecessary please change it to

00:15:11,120 --> 00:15:13,839
zero

00:15:14,800 --> 00:15:18,959
new memory pulses will affect the speed

00:15:17,600 --> 00:15:22,000
of page allocation

00:15:18,959 --> 00:15:23,440
when some of the loads have memory

00:15:22,000 --> 00:15:27,839
pressure

00:15:23,440 --> 00:15:27,839
so be careful with it

00:15:32,880 --> 00:15:36,399
this page shows the cumulative process

00:15:35,199 --> 00:15:39,440
flame graph

00:15:36,399 --> 00:15:40,160
of the optimization you can find the

00:15:39,440 --> 00:15:44,320
hotspot

00:15:40,160 --> 00:15:44,320
we saw before has disappeared

00:15:51,040 --> 00:15:57,279
and this page shows a accumulated time

00:15:53,920 --> 00:16:00,639
takes by some make human functions

00:15:57,279 --> 00:16:09,120
as you see the time is reduced greatly

00:16:00,639 --> 00:16:12,000
after optimization

00:16:09,120 --> 00:16:13,199
this page shows the gpu virtual machine

00:16:12,000 --> 00:16:14,959
instance

00:16:13,199 --> 00:16:17,759
creation time when different

00:16:14,959 --> 00:16:20,079
optimization method is used

00:16:17,759 --> 00:16:21,040
compared with cpu virtual machine

00:16:20,079 --> 00:16:24,320
instance

00:16:21,040 --> 00:16:24,320
it takes a little longer

00:16:31,279 --> 00:16:35,360
and this page shows the creation time of

00:16:34,000 --> 00:16:39,759
a gpu watch machine

00:16:35,360 --> 00:16:43,600
instance with one gpu card and

00:16:39,759 --> 00:16:46,959
48 giga byte ram

00:16:43,600 --> 00:16:48,560
before optimization it takes about 38

00:16:46,959 --> 00:16:52,240
seconds

00:16:48,560 --> 00:16:54,399
after optimization it only takes 3.3

00:16:52,240 --> 00:16:57,519
seconds

00:16:54,399 --> 00:17:00,880
the creation time is reduced

00:16:57,519 --> 00:17:00,880
by more than light percent

00:17:02,079 --> 00:17:05,760
for gpu virtual machine instance with 4

00:17:04,480 --> 00:17:09,360
gpu cards

00:17:05,760 --> 00:17:13,360
and 192 giga ram

00:17:09,360 --> 00:17:16,959
it is is reduced from about 2 minutes

00:17:13,360 --> 00:17:20,319
to 4.4 seconds

00:17:16,959 --> 00:17:32,080
which is which is reduced by

00:17:20,319 --> 00:17:36,000
more than 95 percent

00:17:32,080 --> 00:17:39,520
the conclusion part i have to point out

00:17:36,000 --> 00:17:43,600
words of optimizations a lot limited

00:17:39,520 --> 00:17:45,840
to gpu virtual machine instance

00:17:43,600 --> 00:17:47,520
they apply to virtual machine instance

00:17:45,840 --> 00:17:50,559
with other pci

00:17:47,520 --> 00:17:54,559
pass-through device and some

00:17:50,559 --> 00:17:56,960
of them applying to cpu virtual machine

00:17:54,559 --> 00:17:56,960
instance

00:17:58,320 --> 00:18:04,000
about pre-zero or free page it has some

00:18:01,280 --> 00:18:04,000
limitations

00:18:04,400 --> 00:18:07,520
its current implementation is load

00:18:06,640 --> 00:18:10,960
friendly to

00:18:07,520 --> 00:18:14,000
huge qrb file systems extra work

00:18:10,960 --> 00:18:16,799
is needed for this case

00:18:14,000 --> 00:18:17,200
and there is a core case if the free

00:18:16,799 --> 00:18:20,480
page

00:18:17,200 --> 00:18:24,080
a lot zeroed out in time

00:18:20,480 --> 00:18:25,520
it may lose the fact of boosting sends

00:18:24,080 --> 00:18:29,840
up

00:18:25,520 --> 00:18:29,840
so it's far from perfect

00:18:33,840 --> 00:18:40,640
our solutions have some pros

00:18:36,880 --> 00:18:43,679
the first point is transparent to guest

00:18:40,640 --> 00:18:46,080
nothing needs to be changed for gas

00:18:43,679 --> 00:18:48,400
so it's more appropriate for public

00:18:46,080 --> 00:18:51,440
cloud environment

00:18:48,400 --> 00:18:54,640
the second point dma operation

00:18:51,440 --> 00:18:56,640
in biostate can be handled correctly

00:18:54,640 --> 00:18:59,360
other solutions based on parallel

00:18:56,640 --> 00:19:03,120
virtualization need some workaround

00:18:59,360 --> 00:19:10,559
to forbid the dma operations in bios

00:19:03,120 --> 00:19:12,720
execution state

00:19:10,559 --> 00:19:13,600
about the gpu virtual machine creation

00:19:12,720 --> 00:19:17,200
time

00:19:13,600 --> 00:19:20,320
there is some some room some room for

00:19:17,200 --> 00:19:21,440
further improvement we find the linux

00:19:20,320 --> 00:19:24,320
memory mat

00:19:21,440 --> 00:19:27,120
memory management seems inefficient in

00:19:24,320 --> 00:19:30,000
device pass-through scenario

00:19:27,120 --> 00:19:31,280
for example all the features for page

00:19:30,000 --> 00:19:34,559
migration

00:19:31,280 --> 00:19:39,120
and memory or commits

00:19:34,559 --> 00:19:41,600
are useless in this case

00:19:39,120 --> 00:19:44,240
so it's possible to make sense simpler

00:19:41,600 --> 00:19:47,840
and more efficient

00:19:44,240 --> 00:19:47,840
is in our future play

00:19:49,120 --> 00:19:55,280
one motion we will contribute our work

00:19:52,480 --> 00:19:55,280
to off stream

00:20:00,559 --> 00:20:07,120
that's all for my presentation and

00:20:03,760 --> 00:20:09,200
this is my email if you have a question

00:20:07,120 --> 00:20:14,159
which i can't answer online

00:20:09,200 --> 00:20:14,159
you can send an email to me thanks

00:20:18,840 --> 00:20:21,840
bye

00:20:24,400 --> 00:20:26,480

YouTube URL: https://www.youtube.com/watch?v=clyoIhSaOyg


