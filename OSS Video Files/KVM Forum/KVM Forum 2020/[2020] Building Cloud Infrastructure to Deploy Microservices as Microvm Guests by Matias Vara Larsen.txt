Title: [2020] Building Cloud Infrastructure to Deploy Microservices as Microvm Guests by Matias Vara Larsen
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	This talk presents a proof of concept solution that evaluates a cloud infrastructure to deploy microservices by relying on microvm Qemu machine, virtio-fs and virtio-vsocket. Microservices run as Toro's guest, a dedicated unikernel to deploy all-in-one embedded applications into the cloud. We highlight the following benefits when using microvm machine, virtio-fs and virtio-vsocket: reduced attack surface, deployment of several VMs in a single host, continuous deployment due to the short booting time, easily VMs configuration and simplified unikernel architecture. The infrastructure is built on top of a CephFS cluster thus allowing VMs to share a common filesystem. During the talk, we present the architecture of such a cloud infrastructure and the current implementation. We discuss technical challenges and ongoing work. The tutorial and scripts to reproduce this infrastructure can be found at https://github.com/torokernel/torocloudscripts.

---

Matias Vara Larsen
Huawei, Software Engineer
Grenoble, France

I am a Software Engineer at Huawei. I am interested in the use of formal languages and the development of Operating Systems.
Captions: 
	00:00:06,640 --> 00:00:10,800
hello everyone

00:00:07,839 --> 00:00:11,280
and uh thanks for coming i'm matthias

00:00:10,800 --> 00:00:13,679
farah

00:00:11,280 --> 00:00:15,200
and i work at huawei france in this

00:00:13,679 --> 00:00:17,440
presentation i'm going

00:00:15,200 --> 00:00:20,240
to talk about the deployment of

00:00:17,440 --> 00:00:21,279
microservice as micro vm total guest i

00:00:20,240 --> 00:00:25,359
hope you enjoyed

00:00:21,279 --> 00:00:26,880
the presentation before i go deeply into

00:00:25,359 --> 00:00:29,599
the presentation i would like

00:00:26,880 --> 00:00:30,400
to picture what is a microservice richly

00:00:29,599 --> 00:00:33,040
speaking

00:00:30,400 --> 00:00:34,160
a microservice is a way to decompose a

00:00:33,040 --> 00:00:36,800
monolithic

00:00:34,160 --> 00:00:38,000
application into simpler components

00:00:36,800 --> 00:00:42,800
namely service

00:00:38,000 --> 00:00:42,800
each service provides a functionality

00:00:43,520 --> 00:00:47,600
one possible way to the deploy

00:00:46,399 --> 00:00:50,160
microservice

00:00:47,600 --> 00:00:51,840
is by using virtual machines this

00:00:50,160 --> 00:00:55,760
spotter is called

00:00:51,840 --> 00:00:55,760
service instant per vm

00:00:56,399 --> 00:01:01,760
the deployment of microservice as

00:00:59,039 --> 00:01:05,199
virtual machines has mainly two benefits

00:01:01,760 --> 00:01:08,000
first it allows to isolate microservice

00:01:05,199 --> 00:01:09,200
this means that they can interfere one

00:01:08,000 --> 00:01:11,040
each other

00:01:09,200 --> 00:01:13,520
second you can leverage from cloud

00:01:11,040 --> 00:01:17,119
infrastructure like amazon web service

00:01:13,520 --> 00:01:17,119
or google cloud engine

00:01:17,280 --> 00:01:21,200
so let's see how is the actual

00:01:19,200 --> 00:01:22,640
deployment of a micro service by

00:01:21,200 --> 00:01:24,960
following this pattern

00:01:22,640 --> 00:01:25,680
i'm going to describe a picture from

00:01:24,960 --> 00:01:28,799
boot on to

00:01:25,680 --> 00:01:30,640
top we have a environmental hosts which

00:01:28,799 --> 00:01:33,920
contain an operating system

00:01:30,640 --> 00:01:36,240
and the hypervisor in the context of

00:01:33,920 --> 00:01:38,079
each virtual machines we have the device

00:01:36,240 --> 00:01:39,200
model which is created by the virtual

00:01:38,079 --> 00:01:42,320
machine monitor

00:01:39,200 --> 00:01:43,439
which could be qui or firecracker and

00:01:42,320 --> 00:01:46,000
the microservice

00:01:43,439 --> 00:01:49,200
run as a user application on top of a

00:01:46,000 --> 00:01:49,200
general proposed os

00:01:50,640 --> 00:01:55,520
let's see what are the features that a

00:01:53,119 --> 00:01:57,680
propose os

00:01:55,520 --> 00:01:59,920
propose os provides generally speaking

00:01:57,680 --> 00:02:03,280
our writing system has a scheduler

00:01:59,920 --> 00:02:05,200
file system networking and some drivers

00:02:03,280 --> 00:02:06,479
there is a separation between user and

00:02:05,200 --> 00:02:09,360
current space

00:02:06,479 --> 00:02:11,360
and the microservices execute as a user

00:02:09,360 --> 00:02:13,360
process with on memory space

00:02:11,360 --> 00:02:16,879
and the communication between user and

00:02:13,360 --> 00:02:19,200
kernel is based on cs goals

00:02:16,879 --> 00:02:21,440
however a general proposed os consumes a

00:02:19,200 --> 00:02:24,319
lot of resources like memory cpu

00:02:21,440 --> 00:02:25,360
and on this mesh also the creation and

00:02:24,319 --> 00:02:28,080
storage of this

00:02:25,360 --> 00:02:28,959
sort of vm is complicated for example if

00:02:28,080 --> 00:02:31,280
they mesh

00:02:28,959 --> 00:02:33,519
deployed in different cloud providers

00:02:31,280 --> 00:02:35,200
different drivers should be packed

00:02:33,519 --> 00:02:37,760
the reason is that for example the

00:02:35,200 --> 00:02:39,280
device model for amazon web service is

00:02:37,760 --> 00:02:40,239
not the same that the google cloud

00:02:39,280 --> 00:02:42,959
engine

00:02:40,239 --> 00:02:43,599
and also the vms stay too long to be up

00:02:42,959 --> 00:02:46,720
and running

00:02:43,599 --> 00:02:50,879
which makes hard to implement continuous

00:02:46,720 --> 00:02:52,640
integration and deployment of microsoft

00:02:50,879 --> 00:02:54,480
so the result of consuming so much

00:02:52,640 --> 00:02:56,480
resources makes

00:02:54,480 --> 00:02:57,920
that we can only host a few virtual

00:02:56,480 --> 00:03:01,200
machines per house

00:02:57,920 --> 00:03:04,239
and in addition the maintenance of these

00:03:01,200 --> 00:03:07,120
vms is high

00:03:04,239 --> 00:03:09,760
so to reduce the complexity of a general

00:03:07,120 --> 00:03:11,840
proposal as for a dedicated task

00:03:09,760 --> 00:03:13,840
as microservice and at the same time

00:03:11,840 --> 00:03:14,879
leverage on the strong insulation that

00:03:13,840 --> 00:03:18,159
virtual machines

00:03:14,879 --> 00:03:20,319
provide some approaches propose

00:03:18,159 --> 00:03:21,440
the use of a unique kernel to host

00:03:20,319 --> 00:03:23,599
microsoft

00:03:21,440 --> 00:03:25,760
ionic kernel is when you compile the

00:03:23,599 --> 00:03:28,319
kernel with the user application

00:03:25,760 --> 00:03:29,840
currently there are different unicorns

00:03:28,319 --> 00:03:33,440
which are used in different

00:03:29,840 --> 00:03:37,840
scenarios like aussie va mirage os

00:03:33,440 --> 00:03:37,840
unicraft nano vns etc

00:03:37,920 --> 00:03:42,080
in these approaches the kernel and

00:03:39,840 --> 00:03:44,319
applications share the memory space

00:03:42,080 --> 00:03:45,599
the kernel code and user code are

00:03:44,319 --> 00:03:47,680
combined into

00:03:45,599 --> 00:03:49,440
single binary and in most of these

00:03:47,680 --> 00:03:50,239
approaches there is no separation

00:03:49,440 --> 00:03:53,760
between

00:03:50,239 --> 00:03:54,400
user space and kernel space no context

00:03:53,760 --> 00:03:57,680
switching

00:03:54,400 --> 00:04:01,120
no paging and the cisco shows calls to

00:03:57,680 --> 00:04:02,959
kernel code

00:04:01,120 --> 00:04:04,319
however the power of an application

00:04:02,959 --> 00:04:06,640
takes time and effort

00:04:04,319 --> 00:04:08,560
so sometimes the unicorn must be read on

00:04:06,640 --> 00:04:10,560
for each new application that need to be

00:04:08,560 --> 00:04:14,239
ported

00:04:10,560 --> 00:04:17,199
so in this context toro is a unique

00:04:14,239 --> 00:04:19,919
kernel that provides a minimalistic api

00:04:17,199 --> 00:04:21,519
to develop microservice i'm going to

00:04:19,919 --> 00:04:25,759
present total in the following

00:04:21,519 --> 00:04:28,000
slides so torio is an application

00:04:25,759 --> 00:04:30,000
oriented kernel which provide

00:04:28,000 --> 00:04:31,199
a minimalistic api to bright

00:04:30,000 --> 00:04:33,600
applications

00:04:31,199 --> 00:04:34,479
the uni kernel is mainly made of five

00:04:33,600 --> 00:04:36,560
models

00:04:34,479 --> 00:04:38,160
so for example the threads unit allows

00:04:36,560 --> 00:04:40,479
the manipulation of thread

00:04:38,160 --> 00:04:41,360
the memory unit allows the allocation of

00:04:40,479 --> 00:04:44,320
memory

00:04:41,360 --> 00:04:46,800
the whole kernel is about 18 kilo lines

00:04:44,320 --> 00:04:49,280
of code

00:04:46,800 --> 00:04:51,840
so to get better performance from kvm

00:04:49,280 --> 00:04:54,479
total focus on built-in devices

00:04:51,840 --> 00:04:55,600
and the networking support both blocking

00:04:54,479 --> 00:04:59,520
and no blocking

00:04:55,600 --> 00:05:01,199
socket interface so in total the useful

00:04:59,520 --> 00:05:02,080
application and the kernel compiled

00:05:01,199 --> 00:05:04,720
together

00:05:02,080 --> 00:05:06,400
and the user application has to

00:05:04,720 --> 00:05:07,520
explicitly define what are the

00:05:06,400 --> 00:05:10,639
components

00:05:07,520 --> 00:05:12,800
that must be included

00:05:10,639 --> 00:05:14,880
to define this the developer must

00:05:12,800 --> 00:05:17,039
implicitly specify the unit

00:05:14,880 --> 00:05:19,280
that must be added by using the keyword

00:05:17,039 --> 00:05:19,280
use

00:05:21,199 --> 00:05:26,479
so the resulting elec binary contain

00:05:23,520 --> 00:05:28,560
both the kernel and the application

00:05:26,479 --> 00:05:30,960
this binary is immutable in the sense

00:05:28,560 --> 00:05:34,080
that you can use the same binary

00:05:30,960 --> 00:05:36,800
different hypervisors without modifying

00:05:34,080 --> 00:05:39,840
it thus simplifying the maintenance of

00:05:36,800 --> 00:05:39,840
the microservice

00:05:40,400 --> 00:05:45,440
then we use a script called clothing

00:05:43,680 --> 00:05:47,120
to create the ends in different

00:05:45,440 --> 00:05:50,240
hypervisors

00:05:47,120 --> 00:05:52,800
but let's see how much work

00:05:50,240 --> 00:05:54,560
is needed to deploy an appliance like a

00:05:52,800 --> 00:05:57,919
web server by using toro

00:05:54,560 --> 00:05:59,440
and how much work is needed

00:05:57,919 --> 00:06:01,199
to illustrate the amount of work to

00:05:59,440 --> 00:06:03,039
deploy an appliance i mean

00:06:01,199 --> 00:06:05,840
i'm going to use iron x as a ring

00:06:03,039 --> 00:06:08,080
example the web server appliance

00:06:05,840 --> 00:06:10,720
which is a simple micro service that

00:06:08,080 --> 00:06:12,800
serves a file by using http

00:06:10,720 --> 00:06:16,160
this appliance is currently used to host

00:06:12,800 --> 00:06:16,160
the total website

00:06:16,479 --> 00:06:21,440
so in term of code

00:06:19,759 --> 00:06:23,280
this appliance needs to get connection

00:06:21,440 --> 00:06:26,319
from the internet and be able to read

00:06:23,280 --> 00:06:28,160
files so it needs to include a network

00:06:26,319 --> 00:06:29,759
driver and a blog driver

00:06:28,160 --> 00:06:31,440
and in addition the appliance needs to

00:06:29,759 --> 00:06:34,560
include a file system like

00:06:31,440 --> 00:06:37,759
fad or extend and also the tcb

00:06:34,560 --> 00:06:39,120
ips stack so the microservice has to be

00:06:37,759 --> 00:06:43,039
compiled with this

00:06:39,120 --> 00:06:44,720
with this code in term of device model

00:06:43,039 --> 00:06:46,400
we need to set up the devices that our

00:06:44,720 --> 00:06:47,280
plan is going to use so for example in

00:06:46,400 --> 00:06:50,240
this case

00:06:47,280 --> 00:06:51,199
the device model must include a built-in

00:06:50,240 --> 00:06:55,440
network core

00:06:51,199 --> 00:06:55,440
and a built-in block for block devices

00:06:56,960 --> 00:07:03,599
to deploy the appliance two on these

00:07:00,400 --> 00:07:04,319
files are needed first the binary that

00:07:03,599 --> 00:07:06,720
contains

00:07:04,319 --> 00:07:08,800
he could tell the code which is an elf

00:07:06,720 --> 00:07:11,199
els 64 binary

00:07:08,800 --> 00:07:14,160
and the files that appliance hosts

00:07:11,199 --> 00:07:18,639
generally speaking the binary is about

00:07:14,160 --> 00:07:23,039
250 kilobytes but the files could be

00:07:18,639 --> 00:07:23,039
in the order of megabyte or gigabyte

00:07:23,680 --> 00:07:27,440
and finally to provide networking for

00:07:26,560 --> 00:07:30,000
the vm

00:07:27,440 --> 00:07:32,880
we need to set up for example the ip of

00:07:30,000 --> 00:07:35,120
the vm but also the ip of the host

00:07:32,880 --> 00:07:37,039
and in addition to expose the vm to

00:07:35,120 --> 00:07:40,080
internet we have to set up some sort of

00:07:37,039 --> 00:07:43,599
ep for ip forwarding for example

00:07:40,080 --> 00:07:46,879
so let's summarize the main drawbacks

00:07:43,599 --> 00:07:49,919
of this configuration first

00:07:46,879 --> 00:07:53,039
dc mesh consume memory and on this space

00:07:49,919 --> 00:07:56,240
for example each guess has its own image

00:07:53,039 --> 00:07:58,720
this mesh has to be suited in all nodes

00:07:56,240 --> 00:08:00,160
and the use of a tcp ip stack requires

00:07:58,720 --> 00:08:03,840
configuration like

00:08:00,160 --> 00:08:05,199
bridge and epa parker gas guest drivers

00:08:03,840 --> 00:08:07,440
devices

00:08:05,199 --> 00:08:09,199
also the use of more devices increase

00:08:07,440 --> 00:08:11,360
the attack surface

00:08:09,199 --> 00:08:13,120
sharing of files between guests and host

00:08:11,360 --> 00:08:15,599
is most of the time hard

00:08:13,120 --> 00:08:16,639
and complicated and relying on a

00:08:15,599 --> 00:08:19,919
specific file

00:08:16,639 --> 00:08:26,400
system in the guess is not good for

00:08:19,919 --> 00:08:29,199
inmutable image

00:08:26,400 --> 00:08:30,319
so the question was can we do better and

00:08:29,199 --> 00:08:32,640
when i said

00:08:30,319 --> 00:08:34,479
can we do better i mean can we simplify

00:08:32,640 --> 00:08:37,440
the configuration steps

00:08:34,479 --> 00:08:38,399
can we reduce the tax for phase can we

00:08:37,440 --> 00:08:41,120
still provide

00:08:38,399 --> 00:08:42,320
a rediable share file system can we

00:08:41,120 --> 00:08:46,320
reduce the vm

00:08:42,320 --> 00:08:49,279
cpu consumption and footprints so

00:08:46,320 --> 00:08:51,120
we propose to title this issue by

00:08:49,279 --> 00:08:53,360
providing a cloud infrastructure in

00:08:51,120 --> 00:08:55,600
which vms are micro vms

00:08:53,360 --> 00:08:58,080
networking our file system in the guest

00:08:55,600 --> 00:08:59,680
is implemented by uc beard io v socket

00:08:58,080 --> 00:09:02,000
and build ifs

00:08:59,680 --> 00:09:05,200
and a distributed file system is

00:09:02,000 --> 00:09:06,720
implemented by using cf

00:09:05,200 --> 00:09:08,880
in the following i'm going to briefly

00:09:06,720 --> 00:09:12,640
present these technologies and explain

00:09:08,880 --> 00:09:12,640
how they were implemented in toronto

00:09:13,440 --> 00:09:17,760
so built ifs and victory of this socket

00:09:16,399 --> 00:09:21,920
are both built-in

00:09:17,760 --> 00:09:23,680
devices different other devices they are

00:09:21,920 --> 00:09:25,519
in kernel devices so they are more

00:09:23,680 --> 00:09:28,800
personal and performant than

00:09:25,519 --> 00:09:30,560
emulated devices and i'm not sure about

00:09:28,800 --> 00:09:31,600
built-in b socket but in the case of

00:09:30,560 --> 00:09:35,040
tutorial fs

00:09:31,600 --> 00:09:38,480
it is in emu since

00:09:35,040 --> 00:09:41,680
5.0 in the case

00:09:38,480 --> 00:09:43,680
in the case of micro bn it is a

00:09:41,680 --> 00:09:45,760
minimalistic qma machine which is

00:09:43,680 --> 00:09:47,760
inspired by firecracker

00:09:45,760 --> 00:09:49,279
it provides several benefits like

00:09:47,760 --> 00:09:52,720
reducing device model

00:09:49,279 --> 00:09:55,839
based on virtual improved booting time

00:09:52,720 --> 00:09:58,160
and reduced footprint so

00:09:55,839 --> 00:10:00,000
let's talk about a bit built-in fs and

00:09:58,160 --> 00:10:02,399
built-in b socket in the context of

00:10:00,000 --> 00:10:02,399
storage

00:10:02,480 --> 00:10:06,000
ufs is a build io device that allows to

00:10:05,600 --> 00:10:07,680
share

00:10:06,000 --> 00:10:10,240
directory between the guests and the

00:10:07,680 --> 00:10:13,600
hosts in the guest site you only need a

00:10:10,240 --> 00:10:17,040
build ifs driver the device is supported

00:10:13,600 --> 00:10:18,480
by micro vm machine the only requirement

00:10:17,040 --> 00:10:20,240
is to support

00:10:18,480 --> 00:10:23,120
is that the driver has to support the

00:10:20,240 --> 00:10:25,279
built-in your mmi real transport layer

00:10:23,120 --> 00:10:26,640
in the host site you need a demo name

00:10:25,279 --> 00:10:29,519
and build ifs

00:10:26,640 --> 00:10:30,800
d in which you have to set up what is

00:10:29,519 --> 00:10:32,959
the directory to share

00:10:30,800 --> 00:10:35,200
an attack that is afterward used by the

00:10:32,959 --> 00:10:35,200
guest

00:10:36,800 --> 00:10:40,160
the use of build ifs has several

00:10:39,279 --> 00:10:42,560
benefits

00:10:40,160 --> 00:10:43,200
for example we don't need to base on a

00:10:42,560 --> 00:10:45,200
specific

00:10:43,200 --> 00:10:46,240
file system this means that the binary

00:10:45,200 --> 00:10:48,959
can be

00:10:46,240 --> 00:10:50,560
immutable the configuration for build

00:10:48,959 --> 00:10:53,920
ifs is minimal

00:10:50,560 --> 00:10:55,519
so you don't need image anymore

00:10:53,920 --> 00:10:58,000
the unique kernel source called an

00:10:55,519 --> 00:10:58,959
architecture can be drastically reduced

00:10:58,000 --> 00:11:01,600
for example

00:10:58,959 --> 00:11:04,240
the virtual file system becomes becomes

00:11:01,600 --> 00:11:07,279
a driver for read ifs

00:11:04,240 --> 00:11:11,519
you can remove buffer cache

00:11:07,279 --> 00:11:11,519
file system driver and block driver for

00:11:12,839 --> 00:11:18,399
example

00:11:14,720 --> 00:11:21,360
in the case of built-in v sockets

00:11:18,399 --> 00:11:23,519
it allows to establish a positive socket

00:11:21,360 --> 00:11:24,240
based communication between the host and

00:11:23,519 --> 00:11:28,079
the guests

00:11:24,240 --> 00:11:28,320
in which each guest has a context id to

00:11:28,079 --> 00:11:30,959
be

00:11:28,320 --> 00:11:30,959
identified

00:11:32,640 --> 00:11:36,079
so the use of glutamine circuits has

00:11:34,480 --> 00:11:37,839
several benefits like simple

00:11:36,079 --> 00:11:40,720
configuration on the gas

00:11:37,839 --> 00:11:41,839
no need of tcp stack no need of built-in

00:11:40,720 --> 00:11:44,240
net

00:11:41,839 --> 00:11:46,079
etc in case of you want to expose the

00:11:44,240 --> 00:11:48,880
virtual machine to internet you need

00:11:46,079 --> 00:11:49,440
some sort of proxy to forward traffic

00:11:48,880 --> 00:11:52,480
from

00:11:49,440 --> 00:11:52,480
internet to the guest

00:11:53,200 --> 00:11:56,720
and the last piece in this architecture

00:11:56,000 --> 00:11:59,600
is the

00:11:56,720 --> 00:12:01,760
share file file system follow all knows

00:11:59,600 --> 00:12:05,279
to access to a common file system

00:12:01,760 --> 00:12:07,680
we build a cfvfs cluster and we use it

00:12:05,279 --> 00:12:09,680
to provide the binaries of the vms

00:12:07,680 --> 00:12:12,000
and the files i'm going to talk a bit

00:12:09,680 --> 00:12:15,680
about this cluster

00:12:12,000 --> 00:12:15,680
and how it have been developed

00:12:16,800 --> 00:12:21,440
so to try this architecture i build a

00:12:19,200 --> 00:12:25,519
three nodes

00:12:21,440 --> 00:12:28,880
cf cluster each node participates with

00:12:25,519 --> 00:12:32,480
10 gigabytes disk to the cluster

00:12:28,880 --> 00:12:35,040
and i use the the public cloud ovh

00:12:32,480 --> 00:12:36,639
each cluster is a 2 core with 8

00:12:35,040 --> 00:12:40,079
gigabytes of memory

00:12:36,639 --> 00:12:42,959
and the cost of each note is about

00:12:40,079 --> 00:12:42,959
16 euros

00:12:44,800 --> 00:12:48,560
to deploy the virtual machines i

00:12:46,480 --> 00:12:50,800
rendered two cheaper nodes these are

00:12:48,560 --> 00:12:53,120
one core and two shield of memory holes

00:12:50,800 --> 00:12:55,680
that costs about 3 euros per month

00:12:53,120 --> 00:12:57,120
in this machine i'm on to the cfs file

00:12:55,680 --> 00:13:00,079
system

00:12:57,120 --> 00:13:00,800
and the cluster has been used to store

00:13:00,079 --> 00:13:03,839
finites

00:13:00,800 --> 00:13:07,839
for the vns and the files that are

00:13:03,839 --> 00:13:07,839
served by the microservice

00:13:09,360 --> 00:13:13,600
the host client one and client two are

00:13:11,519 --> 00:13:16,160
used to deploy the microservice

00:13:13,600 --> 00:13:16,720
to ease the creation's virtual machines

00:13:16,160 --> 00:13:20,160
and

00:13:16,720 --> 00:13:21,279
i started an open source project on

00:13:20,160 --> 00:13:24,320
these machines

00:13:21,279 --> 00:13:25,040
name it xml wrap which allows to

00:13:24,320 --> 00:13:27,279
automate

00:13:25,040 --> 00:13:29,839
the launching of vm so for example to

00:13:27,279 --> 00:13:34,720
ease the forwarding of ports

00:13:29,839 --> 00:13:38,000
to launch view ifs and so on

00:13:34,720 --> 00:13:41,120
so i have some results about uh

00:13:38,000 --> 00:13:42,560
evaluation of the architecture so the

00:13:41,120 --> 00:13:46,079
binary side which is

00:13:42,560 --> 00:13:51,040
the binary include the kernel

00:13:46,079 --> 00:13:52,480
and the user application has about 235

00:13:51,040 --> 00:13:54,639
kilobytes

00:13:52,480 --> 00:13:56,800
the time to review the microservice is

00:13:54,639 --> 00:13:58,320
about 500 milliseconds which is the

00:13:56,800 --> 00:14:00,959
compilation times

00:13:58,320 --> 00:14:01,839
and it is the time that's going to

00:14:00,959 --> 00:14:05,920
impact

00:14:01,839 --> 00:14:08,800
the ability to do continuous deployment

00:14:05,920 --> 00:14:10,959
and integration of microservice and the

00:14:08,800 --> 00:14:14,959
boot cycle which is turning

00:14:10,959 --> 00:14:16,320
off and on of the microservices about 80

00:14:14,959 --> 00:14:18,399
milliseconds

00:14:16,320 --> 00:14:19,839
and just to have in mind that an echo

00:14:18,399 --> 00:14:24,639
hello world

00:14:19,839 --> 00:14:26,560
takes about two and a half milliseconds

00:14:24,639 --> 00:14:28,880
and other important factor i was

00:14:26,560 --> 00:14:33,040
interested in was the cpu sash

00:14:28,880 --> 00:14:36,320
um in this case the

00:14:33,040 --> 00:14:40,079
um the vm comes here 90 percent of the

00:14:36,320 --> 00:14:41,760
of the cpu when is answering a request

00:14:40,079 --> 00:14:44,240
and then when it's completely asleep

00:14:41,760 --> 00:14:48,399
means that the the core is

00:14:44,240 --> 00:14:50,639
hold or the bn is hold and it is

00:14:48,399 --> 00:14:52,880
taking about 10 hundred percent of of

00:14:50,639 --> 00:14:56,639
cpu

00:14:52,880 --> 00:14:57,199
and the memory footprint per bn is

00:14:56,639 --> 00:15:00,720
around

00:14:57,199 --> 00:15:01,760
2.9 percent of memory which is about 60

00:15:00,720 --> 00:15:05,120
megabytes

00:15:01,760 --> 00:15:07,279
or 35 vms per host

00:15:05,120 --> 00:15:08,399
in this case i have compiled a cameo

00:15:07,279 --> 00:15:11,600
with all the

00:15:08,399 --> 00:15:13,920
configuration enabled and just to have

00:15:11,600 --> 00:15:14,959
in mind that the whole cluster it costs

00:15:13,920 --> 00:15:17,600
about eight

00:15:14,959 --> 00:15:19,279
fifty eight euros month so it makes that

00:15:17,600 --> 00:15:23,040
you spend about

00:15:19,279 --> 00:15:27,199
um eighty five something euros per month

00:15:23,040 --> 00:15:31,040
per pm and i have also uploaded

00:15:27,199 --> 00:15:32,959
all the scripts and the tutorial to

00:15:31,040 --> 00:15:36,399
create your own cloud based on the

00:15:32,959 --> 00:15:36,399
configuration that's just presented

00:15:37,680 --> 00:15:41,839
so in the following i'm going to show a

00:15:40,000 --> 00:15:46,000
video that

00:15:41,839 --> 00:15:48,639
presents the implementation of this

00:15:46,000 --> 00:15:48,639
architecture

00:15:49,839 --> 00:15:54,480
so what we use we see here is first is

00:15:52,560 --> 00:15:57,519
the dashboard of tf

00:15:54,480 --> 00:16:00,399
we can see we have three nodes

00:15:57,519 --> 00:16:02,800
and as i said each one country would

00:16:00,399 --> 00:16:06,000
with 10 gigabytes with me would make

00:16:02,800 --> 00:16:09,519
30 gigs of total of the of

00:16:06,000 --> 00:16:11,759
the whole cluster then we have xml rad

00:16:09,519 --> 00:16:12,800
which is the tool that's going to we are

00:16:11,759 --> 00:16:15,199
using to

00:16:12,800 --> 00:16:16,880
ease the deployment of the vm so for

00:16:15,199 --> 00:16:18,240
example here we have the two nodes and

00:16:16,880 --> 00:16:21,680
the static web server

00:16:18,240 --> 00:16:24,000
microservice we have some parameters

00:16:21,680 --> 00:16:26,800
like the binary

00:16:24,000 --> 00:16:27,759
and the file system that is shared to

00:16:26,800 --> 00:16:29,360
the host

00:16:27,759 --> 00:16:32,320
and also the forwarding of the port

00:16:29,360 --> 00:16:34,560
between the host and the guest

00:16:32,320 --> 00:16:36,320
and we can also have the output of the

00:16:34,560 --> 00:16:36,880
screen if we click on the web socket so

00:16:36,320 --> 00:16:40,160
this is the

00:16:36,880 --> 00:16:42,079
screen of the of the bm

00:16:40,160 --> 00:16:43,920
and it could be compilated by using

00:16:42,079 --> 00:16:48,480
headless but in this case

00:16:43,920 --> 00:16:51,360
i just compiled with the screen

00:16:48,480 --> 00:16:52,399
and this is the total website and i'm

00:16:51,360 --> 00:16:56,000
going to refresh

00:16:52,399 --> 00:17:00,160
just to show that the viennese

00:16:56,000 --> 00:17:03,199
and toriel is currently answering and

00:17:00,160 --> 00:17:06,400
so for example if now i'm refresh

00:17:03,199 --> 00:17:09,360
and we're going to see that the screen

00:17:06,400 --> 00:17:09,360
scroll up

00:17:09,439 --> 00:17:13,199
i'm going to do it again since it's not

00:17:11,839 --> 00:17:19,520
really evident

00:17:13,199 --> 00:17:22,160
we can see that the screen move up

00:17:19,520 --> 00:17:23,520
and now i'm going to just get and pick a

00:17:22,160 --> 00:17:27,600
picture and see that is

00:17:23,520 --> 00:17:27,600
currently open in the vm

00:17:31,440 --> 00:17:35,440
so yeah well um this is one of the

00:17:34,559 --> 00:17:38,640
challenges

00:17:35,440 --> 00:17:41,760
that i face i'm continually

00:17:38,640 --> 00:17:43,280
facing at the moment uh in order to

00:17:41,760 --> 00:17:45,039
improve the deployment of this

00:17:43,280 --> 00:17:48,799
architecture first

00:17:45,039 --> 00:17:49,280
and i would like to improve the support

00:17:48,799 --> 00:17:51,760
for

00:17:49,280 --> 00:17:55,039
live migration which is not currently

00:17:51,760 --> 00:17:59,039
supported by micro micro vm machine

00:17:55,039 --> 00:18:01,520
also i see that we have a sort of

00:17:59,039 --> 00:18:03,200
bottleneck when we have to forward

00:18:01,520 --> 00:18:05,440
traffic from the internet

00:18:03,200 --> 00:18:07,679
to the guests so we have to improve the

00:18:05,440 --> 00:18:11,600
way we do it in that case

00:18:07,679 --> 00:18:14,400
and i think we have we can improve

00:18:11,600 --> 00:18:15,280
the overall performance by using cello

00:18:14,400 --> 00:18:17,280
copy

00:18:15,280 --> 00:18:19,039
when we use built-in fs and multi-um

00:18:17,280 --> 00:18:21,360
soccer this is more in the

00:18:19,039 --> 00:18:22,400
guest site in the drivers in the total

00:18:21,360 --> 00:18:26,240
drivers

00:18:22,400 --> 00:18:28,400
and i think current evaluation of this

00:18:26,240 --> 00:18:31,840
architecture should be improved by

00:18:28,400 --> 00:18:34,880
comparing with approaches like unicorns

00:18:31,840 --> 00:18:38,320
containers and also general proposed

00:18:34,880 --> 00:18:43,840
os and all these challenge

00:18:38,320 --> 00:18:43,840
remain as a future word

00:18:45,600 --> 00:18:50,640
so well i finished the presentation so

00:18:48,559 --> 00:18:57,840
if you have any question

00:18:50,640 --> 00:18:57,840
feel free to ask thank you very much

00:19:00,480 --> 00:19:02,559

YouTube URL: https://www.youtube.com/watch?v=VdMovJsadDY


