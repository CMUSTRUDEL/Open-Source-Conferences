Title: [2020] Trap-less Virtual Interrupt for KVM on RISC-V by Siqi Zhao
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	Virtual interrupt is an integral part in virtualization. However, so far the handling of virtual interrupt always involve traps to the host with the exception only in the case of passthrough devices. For example, interrupts from the timer, the virtual device and between virtual CPUs still need the host software to inject. This situation incurs non-negligible overhead in interrupt-intensive scenarios. A design that eliminates most of the traps to host for handling interrupts is presented. The solution includes a new virtualization-aware interrupt controller and the accompanying software implementation in KVM. With this design, delivery of the above interrupts on longer involve traps to the host, improving performance. The interrupt controller design has been implemented on an emulated RISC-V platform due to its simplicity in design and potential for pioneering new virtualization ideas.

---

Siqi Zhao
Huawei Technologies Co., Ltd, Senior Engineer

Siqi Zhao is a Senior Engineer currently in Huawei Technologies Co., Ltd. He is working on the ongoing next generation virtualization project. Before joining Huawei, he had spoken in conferences such as Usenix Security and Euro S&P during his Ph.D. studies.
Captions: 
	00:00:06,319 --> 00:00:09,280
hello everyone

00:00:07,279 --> 00:00:10,960
today i'll present you a work related to

00:00:09,280 --> 00:00:12,080
virtual interrupts on the risk 5

00:00:10,960 --> 00:00:13,679
architecture

00:00:12,080 --> 00:00:16,000
virtual interrupts are an integral

00:00:13,679 --> 00:00:18,160
component of a virtualization solution

00:00:16,000 --> 00:00:19,840
however since the capability of directly

00:00:18,160 --> 00:00:21,279
delivering interrupts from past two

00:00:19,840 --> 00:00:22,880
devices to a vm

00:00:21,279 --> 00:00:24,320
we have nothing much developing this

00:00:22,880 --> 00:00:25,840
menu here

00:00:24,320 --> 00:00:27,439
we like to take the opportunity of the

00:00:25,840 --> 00:00:29,039
emerging risk 5 architecture to

00:00:27,439 --> 00:00:29,679
introduce some new ideas to keep

00:00:29,039 --> 00:00:31,840
improved

00:00:29,679 --> 00:00:34,000
in virtual interrupts in this

00:00:31,840 --> 00:00:35,440
presentation i'll first provide some

00:00:34,000 --> 00:00:36,960
background information on how the

00:00:35,440 --> 00:00:39,200
virtual interrupts are processed on the

00:00:36,960 --> 00:00:42,239
current risk 5k vm architecture

00:00:39,200 --> 00:00:44,879
as to motivate our proposed improvements

00:00:42,239 --> 00:00:45,280
next i'll talk about more more detail

00:00:44,879 --> 00:00:47,920
about

00:00:45,280 --> 00:00:50,160
improvement which includes the design of

00:00:47,920 --> 00:00:51,199
a virtualization aware interrupt

00:00:50,160 --> 00:00:53,199
controller

00:00:51,199 --> 00:00:54,800
and direct delivery of virtual

00:00:53,199 --> 00:00:56,559
interrupts to vcpu

00:00:54,800 --> 00:00:58,000
next i'll show you the detailed

00:00:56,559 --> 00:01:00,239
implementation in kvm

00:00:58,000 --> 00:01:01,280
to handle the virtual various kinds of

00:01:00,239 --> 00:01:03,920
virtual interrupts

00:01:01,280 --> 00:01:05,280
and vcpu state changes i also show you

00:01:03,920 --> 00:01:06,799
some performance results

00:01:05,280 --> 00:01:10,080
lastly i'll briefly talk about some

00:01:06,799 --> 00:01:10,080
future work and directions

00:01:10,159 --> 00:01:14,400
let's move on to the background of

00:01:11,840 --> 00:01:16,880
motivation

00:01:14,400 --> 00:01:18,960
the current hypervisor extension on risk

00:01:16,880 --> 00:01:21,119
five does not include any support for

00:01:18,960 --> 00:01:22,799
accelerating virtual interrupts

00:01:21,119 --> 00:01:24,960
all virtual interrupts are implemented

00:01:22,799 --> 00:01:26,400
on a trap and emulated approach

00:01:24,960 --> 00:01:28,240
there are three types of virtual

00:01:26,400 --> 00:01:30,159
interrupts that are of concern

00:01:28,240 --> 00:01:31,840
corresponding to three types of physical

00:01:30,159 --> 00:01:32,640
interrupts there are virtual timer

00:01:31,840 --> 00:01:34,479
interrupts

00:01:32,640 --> 00:01:36,159
virtual supervisor software generating

00:01:34,479 --> 00:01:37,600
interrupt and virtual supervisor

00:01:36,159 --> 00:01:39,600
external interrupt

00:01:37,600 --> 00:01:41,200
the current flow of the virtual timer

00:01:39,600 --> 00:01:43,200
interrupt is shown here

00:01:41,200 --> 00:01:44,960
whenever the vm kernel needs to set up

00:01:43,200 --> 00:01:47,680
the timer for a timer interrupt

00:01:44,960 --> 00:01:49,680
it needs to trap to kvm which utilizes

00:01:47,680 --> 00:01:51,680
the hr timer and the timer driver which

00:01:49,680 --> 00:01:53,040
finally traps the machine mode to set up

00:01:51,680 --> 00:01:55,439
the physical timer

00:01:53,040 --> 00:01:56,799
on the interrupt the heart is switched

00:01:55,439 --> 00:02:00,560
to machine mode first

00:01:56,799 --> 00:02:03,200
the open spi then injects

00:02:00,560 --> 00:02:04,880
timer into up to the hm mode host kernel

00:02:03,200 --> 00:02:05,920
which then injects the timer into up to

00:02:04,880 --> 00:02:07,759
the gas kernel

00:02:05,920 --> 00:02:09,039
the entire process includes multiple

00:02:07,759 --> 00:02:10,879
traps and components

00:02:09,039 --> 00:02:14,319
many cycles are spend the emulation of

00:02:10,879 --> 00:02:14,319
the timer interf to the guest

00:02:16,239 --> 00:02:19,840
the virtual software generated interrupt

00:02:18,720 --> 00:02:21,680
is shown here

00:02:19,840 --> 00:02:23,520
to send the virtual software generated

00:02:21,680 --> 00:02:26,000
interrupts the guest vm needs to call

00:02:23,520 --> 00:02:28,560
the emulated spi by the kvm

00:02:26,000 --> 00:02:30,239
which causes the trap to the host the

00:02:28,560 --> 00:02:32,080
host save the interrupt for the other

00:02:30,239 --> 00:02:33,760
vcpu and notify the heart that the other

00:02:32,080 --> 00:02:35,840
vcpu is running on

00:02:33,760 --> 00:02:37,920
to perform the notification the host

00:02:35,840 --> 00:02:39,599
needs to call the real sbi which calls

00:02:37,920 --> 00:02:41,840
another trap to machine mode

00:02:39,599 --> 00:02:42,959
when the machine mode interrupt arrives

00:02:41,840 --> 00:02:45,120
at the other heart

00:02:42,959 --> 00:02:46,800
the heart first switches to machine mode

00:02:45,120 --> 00:02:47,519
the open spin injects a software

00:02:46,800 --> 00:02:49,440
interrupt to the

00:02:47,519 --> 00:02:51,280
host kernel then the host kernel

00:02:49,440 --> 00:02:52,720
realizes that there's a saved software

00:02:51,280 --> 00:02:55,200
interval for the guest

00:02:52,720 --> 00:02:57,120
inject injects this interrupt to the

00:02:55,200 --> 00:02:59,680
guest when resuming the guest

00:02:57,120 --> 00:03:00,239
we can see that software virtual

00:02:59,680 --> 00:03:02,000
software

00:03:00,239 --> 00:03:04,319
interrupts also introduce the number of

00:03:02,000 --> 00:03:07,519
traps results in the same situation as

00:03:04,319 --> 00:03:07,519
virtual timer interrupt

00:03:07,840 --> 00:03:12,000
on the current kvn mall risk 5 to send

00:03:10,319 --> 00:03:12,959
the interrupt by the emulated virtual

00:03:12,000 --> 00:03:14,879
device in qmu

00:03:12,959 --> 00:03:17,599
the steps involves firstly to perform

00:03:14,879 --> 00:03:19,920
necessary emulation of the plic

00:03:17,599 --> 00:03:21,599
next to notify the guest vm a trap to

00:03:19,920 --> 00:03:24,640
host kernel is needed by the

00:03:21,599 --> 00:03:26,799
plic kvn modules in the host kernel next

00:03:24,640 --> 00:03:28,799
saves the interrupt info for the vcpu

00:03:26,799 --> 00:03:30,640
and uses the host software generator

00:03:28,799 --> 00:03:33,840
interrupt to notify the heart

00:03:30,640 --> 00:03:36,319
on which the vcp is executing the vcpu

00:03:33,840 --> 00:03:37,920
traps and quickly resumes the execution

00:03:36,319 --> 00:03:38,879
it picks up the interrupt during the

00:03:37,920 --> 00:03:41,120
resumption

00:03:38,879 --> 00:03:44,319
we see that again a number of traps are

00:03:41,120 --> 00:03:46,319
needed in this process

00:03:44,319 --> 00:03:47,519
during the handling of interrupt from

00:03:46,319 --> 00:03:50,640
the virtual

00:03:47,519 --> 00:03:52,400
um from the virtual devices again a

00:03:50,640 --> 00:03:54,879
number of traps are incurred

00:03:52,400 --> 00:03:57,120
the main reason is that the mmio access

00:03:54,879 --> 00:03:58,000
to the emulator plic causes traps to the

00:03:57,120 --> 00:03:59,760
host

00:03:58,000 --> 00:04:02,239
there are further switches in a host

00:03:59,760 --> 00:04:02,720
with when the plic emulation coding user

00:04:02,239 --> 00:04:05,519
space

00:04:02,720 --> 00:04:07,439
interacts with the host kernel the mmio

00:04:05,519 --> 00:04:09,280
is needed to at least acknowledge the

00:04:07,439 --> 00:04:10,480
pending interrupt and to signal end of

00:04:09,280 --> 00:04:15,519
interrupt handling which

00:04:10,480 --> 00:04:17,759
involves at least two traps

00:04:15,519 --> 00:04:19,919
so we notice that all the processing of

00:04:17,759 --> 00:04:23,199
interrupts involves a number of traps

00:04:19,919 --> 00:04:25,759
meanwhile other architectures such as

00:04:23,199 --> 00:04:27,360
x86 and arm have been providing direct

00:04:25,759 --> 00:04:29,759
delivery of certain kind of virtual

00:04:27,360 --> 00:04:33,520
intro to the vcp for a while

00:04:29,759 --> 00:04:35,199
so direct delivery of virtual interrupts

00:04:33,520 --> 00:04:37,360
avoids excessive traps

00:04:35,199 --> 00:04:38,880
reducing overhead and improving the

00:04:37,360 --> 00:04:40,880
overall performance

00:04:38,880 --> 00:04:44,000
the question is can we have something

00:04:40,880 --> 00:04:44,000
like that for risk five

00:04:44,240 --> 00:04:47,520
um from that let's move on to our work

00:04:46,320 --> 00:04:50,960
that um

00:04:47,520 --> 00:04:50,960
on the risk five actually

00:04:52,320 --> 00:04:57,120
so we extended the interrupt controller

00:04:55,199 --> 00:04:57,680
on the current risk 5 architecture to

00:04:57,120 --> 00:04:59,680
support

00:04:57,680 --> 00:05:01,039
direct delivery of all kinds of virtual

00:04:59,680 --> 00:05:03,120
interrupts in

00:05:01,039 --> 00:05:04,880
including virtual timer interrupts

00:05:03,120 --> 00:05:06,320
virtual software generated interrupts

00:05:04,880 --> 00:05:07,280
and virtual supervisor external

00:05:06,320 --> 00:05:09,280
interrupt

00:05:07,280 --> 00:05:11,840
we have also implemented implementing

00:05:09,280 --> 00:05:13,680
necessary support on the kvm for kvm to

00:05:11,840 --> 00:05:15,759
validate the functional design of the

00:05:13,680 --> 00:05:18,639
extended interrupt controller

00:05:15,759 --> 00:05:20,240
note that our extensions id are not

00:05:18,639 --> 00:05:20,960
dependent on a particular interrupt

00:05:20,240 --> 00:05:22,400
controller

00:05:20,960 --> 00:05:24,639
can be adapted to future internal

00:05:22,400 --> 00:05:26,639
controllers needed

00:05:24,639 --> 00:05:28,160
the existing intel controller on risk 5

00:05:26,639 --> 00:05:31,360
consists of two parts

00:05:28,160 --> 00:05:34,000
the c-linked and the plic the c-link

00:05:31,360 --> 00:05:37,360
mainly contains the local timer csr

00:05:34,000 --> 00:05:40,000
called the m-time cnp the

00:05:37,360 --> 00:05:40,479
plic acts as the routing units so to

00:05:40,000 --> 00:05:42,720
speak

00:05:40,479 --> 00:05:44,240
for external interrupts and software

00:05:42,720 --> 00:05:46,320
generating interrupts

00:05:44,240 --> 00:05:48,400
it contains the various controls and

00:05:46,320 --> 00:05:50,240
state of space for the interrupt sources

00:05:48,400 --> 00:05:53,840
i'll skip the details of these please

00:05:50,240 --> 00:05:53,840
refer to specs if you're interested

00:05:54,960 --> 00:06:00,000
we have extended the ceiling tennis plic

00:05:57,440 --> 00:06:02,479
with a set of csr to support that

00:06:00,000 --> 00:06:03,280
direct delivery of virtual interrupts

00:06:02,479 --> 00:06:05,360
for each

00:06:03,280 --> 00:06:07,199
type of virtual interrupts we provide

00:06:05,360 --> 00:06:09,600
csrs according to the functional

00:06:07,199 --> 00:06:12,400
requirement of the virtual interrupt

00:06:09,600 --> 00:06:13,840
for example for timer interrupt we

00:06:12,400 --> 00:06:16,880
provide a csr for

00:06:13,840 --> 00:06:18,400
vs mode and vhs mode that act as the

00:06:16,880 --> 00:06:19,759
dedicated clock event source

00:06:18,400 --> 00:06:22,800
respectively

00:06:19,759 --> 00:06:24,560
the csrs can be accessed directly from

00:06:22,800 --> 00:06:25,440
the mode they are intended for without

00:06:24,560 --> 00:06:27,759
trapping

00:06:25,440 --> 00:06:29,120
the guest vm can directly set the timer

00:06:27,759 --> 00:06:31,680
interrupt with vs

00:06:29,120 --> 00:06:32,639
time cmp for example it does not need to

00:06:31,680 --> 00:06:36,720
trap to the host

00:06:32,639 --> 00:06:36,720
all other csrs follow the same idea

00:06:36,880 --> 00:06:40,800
we extended the plic to handle virtual

00:06:39,120 --> 00:06:43,039
interrupts that are not local

00:06:40,800 --> 00:06:44,240
which are the virtual software generated

00:06:43,039 --> 00:06:47,039
interrupts and

00:06:44,240 --> 00:06:47,680
external interrupts these new registers

00:06:47,039 --> 00:06:49,599
contain

00:06:47,680 --> 00:06:52,080
structures that are used for routing

00:06:49,599 --> 00:06:54,479
virtual interrupts while considering

00:06:52,080 --> 00:06:55,280
the whole scheduling decisions for

00:06:54,479 --> 00:06:57,680
example

00:06:55,280 --> 00:06:58,960
for each heart x we provide the

00:06:57,680 --> 00:07:02,639
corresponding if

00:06:58,960 --> 00:07:06,400
map x register the ifmap register

00:07:02,639 --> 00:07:09,199
holds the evm id and vhard id pair

00:07:06,400 --> 00:07:10,560
that indicates the identity of a vcpu

00:07:09,199 --> 00:07:11,440
that is currently running on the

00:07:10,560 --> 00:07:14,720
physical

00:07:11,440 --> 00:07:16,800
physical heart x when the pure ic needs

00:07:14,720 --> 00:07:17,360
to deliver a virtual software generated

00:07:16,800 --> 00:07:19,919
interrupt

00:07:17,360 --> 00:07:21,039
it looks up all the ifmap registers in

00:07:19,919 --> 00:07:24,160
parallel

00:07:21,039 --> 00:07:26,800
to locate the target vcpu if any of

00:07:24,160 --> 00:07:29,039
these slots matches the plic knows that

00:07:26,800 --> 00:07:30,080
the target vcpu is on the heart that the

00:07:29,039 --> 00:07:31,680
corresponding

00:07:30,080 --> 00:07:33,440
that corresponds to the heart to the

00:07:31,680 --> 00:07:35,360
slot

00:07:33,440 --> 00:07:38,400
the the advantage of this design is that

00:07:35,360 --> 00:07:40,720
instead of contention on the share

00:07:38,400 --> 00:07:43,120
single share resources such as global

00:07:40,720 --> 00:07:45,440
table or certain kind of command queue

00:07:43,120 --> 00:07:47,199
each thread only writes to its own slots

00:07:45,440 --> 00:07:49,520
without taking any logs

00:07:47,199 --> 00:07:50,720
the hardware later can perform the local

00:07:49,520 --> 00:07:53,440
being parallel

00:07:50,720 --> 00:07:53,840
the other registers are designed with

00:07:53,440 --> 00:07:59,120
this

00:07:53,840 --> 00:08:01,120
same idea to directly

00:07:59,120 --> 00:08:02,800
deliver virtual interrupts the ceiling

00:08:01,120 --> 00:08:04,400
needs to be able to directly set the

00:08:02,800 --> 00:08:05,120
pending bits first for the virtual

00:08:04,400 --> 00:08:07,440
interrupts

00:08:05,120 --> 00:08:09,360
currently such in such pending bits are

00:08:07,440 --> 00:08:12,639
only set by host software

00:08:09,360 --> 00:08:15,440
we change that so that when v equals one

00:08:12,639 --> 00:08:15,919
the guess receives an interrupt directly

00:08:15,440 --> 00:08:19,440
the v

00:08:15,919 --> 00:08:22,560
bit is risk five nominator that whether

00:08:19,440 --> 00:08:23,759
the heart is running a vcpu to minimize

00:08:22,560 --> 00:08:25,599
the possible delay

00:08:23,759 --> 00:08:27,759
we also consider delivering the

00:08:25,599 --> 00:08:29,520
interrupts when v equals zero

00:08:27,759 --> 00:08:31,759
when a virtual interrupt arrives on a

00:08:29,520 --> 00:08:34,880
certain heart when v equals zero

00:08:31,759 --> 00:08:36,880
the host still handles it in this case

00:08:34,880 --> 00:08:38,560
the virtual interval goes along the same

00:08:36,880 --> 00:08:41,760
handling path as the

00:08:38,560 --> 00:08:42,959
existing approach so our design is as

00:08:41,760 --> 00:08:45,440
good as the

00:08:42,959 --> 00:08:46,240
existing approach in the slow pass note

00:08:45,440 --> 00:08:48,560
that also

00:08:46,240 --> 00:08:49,839
conceptually this needs differentiation

00:08:48,560 --> 00:08:52,800
between the interrupt

00:08:49,839 --> 00:08:53,279
from the same source by hand handled by

00:08:52,800 --> 00:08:55,839
different

00:08:53,279 --> 00:08:55,839
entities

00:08:57,600 --> 00:09:01,920
because even if the host claimed the

00:08:59,920 --> 00:09:02,480
virtual interrupt the handling does not

00:09:01,920 --> 00:09:04,480
finish

00:09:02,480 --> 00:09:08,000
the virtual interview still remain

00:09:04,480 --> 00:09:09,839
pending for the guests

00:09:08,000 --> 00:09:11,360
so to differentiate the pending states

00:09:09,839 --> 00:09:13,360
of the same virtual interrupt

00:09:11,360 --> 00:09:14,800
for the hypervisor and the guest we need

00:09:13,360 --> 00:09:16,399
to introduce additional bits

00:09:14,800 --> 00:09:18,240
different types of interrupts need to be

00:09:16,399 --> 00:09:20,080
treated differently

00:09:18,240 --> 00:09:21,760
we don't need one for the virtual timer

00:09:20,080 --> 00:09:23,600
interrupt because the hypervisor doesn't

00:09:21,760 --> 00:09:24,720
really claim a virtual timer interrupt

00:09:23,600 --> 00:09:28,000
since it's

00:09:24,720 --> 00:09:32,560
level triggered having separated

00:09:28,000 --> 00:09:34,560
hip the vstip bit and vsipwstip bit does

00:09:32,560 --> 00:09:36,959
not really make sense

00:09:34,560 --> 00:09:37,600
eventually the timer will clear any

00:09:36,959 --> 00:09:40,640
blending

00:09:37,600 --> 00:09:43,040
bits once the value inside is

00:09:40,640 --> 00:09:44,000
updated to repent to represent future

00:09:43,040 --> 00:09:46,080
time

00:09:44,000 --> 00:09:48,000
uh we do not need to separate and then

00:09:46,080 --> 00:09:51,040
and we do need to separate the enable

00:09:48,000 --> 00:09:53,800
bits though the v v-s-i-e-s-t-i-e

00:09:51,040 --> 00:09:56,800
and is no longer an alias of the

00:09:53,800 --> 00:09:56,800
h-i-e-s-t-i-e

00:09:57,120 --> 00:10:01,399
we introduced additional bits for vssi

00:09:59,600 --> 00:10:05,760
by separating the

00:10:01,399 --> 00:10:09,360
vsip ssip build from the alias relation

00:10:05,760 --> 00:10:12,480
with hip.v ssip bit

00:10:09,360 --> 00:10:15,760
we also need to separate the enable bits

00:10:12,480 --> 00:10:17,839
we use for virtual

00:10:15,760 --> 00:10:19,440
supervisor external interrupts we use

00:10:17,839 --> 00:10:21,040
another notification interrupt to

00:10:19,440 --> 00:10:23,920
represent the host interrupts

00:10:21,040 --> 00:10:25,200
so the separation is completed with the

00:10:23,920 --> 00:10:32,000
pending bit

00:10:25,200 --> 00:10:33,519
for that notification interrupt

00:10:32,000 --> 00:10:36,240
to support the above interrupt

00:10:33,519 --> 00:10:37,120
controller extension the kvm's main task

00:10:36,240 --> 00:10:39,839
is to handle

00:10:37,120 --> 00:10:41,920
interrupt 1v 0 and to maintain a

00:10:39,839 --> 00:10:45,680
consistent interrupt context for each

00:10:41,920 --> 00:10:47,760
vcpu the vcp using kvm essentially using

00:10:45,680 --> 00:10:50,880
one of the three states showing this

00:10:47,760 --> 00:10:52,959
in this state transition diagram kvn's

00:10:50,880 --> 00:10:54,000
main task concentrates on the right

00:10:52,959 --> 00:10:56,880
portion

00:10:54,000 --> 00:10:57,760
when the vcpu is impulsed and scheduled

00:10:56,880 --> 00:11:00,160
off state

00:10:57,760 --> 00:11:01,360
the kvm handles the virtual interrupts

00:11:00,160 --> 00:11:04,560
saving them for

00:11:01,360 --> 00:11:06,480
injection if necessary when the visible

00:11:04,560 --> 00:11:08,399
transits between these two states the

00:11:06,480 --> 00:11:12,000
kvm perform necessary context

00:11:08,399 --> 00:11:13,760
maintenance in kvmv cpu put and kvm vcp

00:11:12,000 --> 00:11:15,120
load functions

00:11:13,760 --> 00:11:17,040
the reason for the host to handle

00:11:15,120 --> 00:11:19,920
virtual intel for the guest is that if

00:11:17,040 --> 00:11:20,800
the vcpu was not scheduled off it's just

00:11:19,920 --> 00:11:22,480
paused

00:11:20,800 --> 00:11:24,399
the interrupt controller will still

00:11:22,480 --> 00:11:26,240
regard the heart as having the vcp

00:11:24,399 --> 00:11:29,760
running because the update

00:11:26,240 --> 00:11:33,279
of the ifmap x register happens in vcpu

00:11:29,760 --> 00:11:34,880
put kvm vcp output and kv and vcp load

00:11:33,279 --> 00:11:38,959
then the virtual interface will still

00:11:34,880 --> 00:11:42,160
arrive but the vcp is not executing

00:11:38,959 --> 00:11:44,560
next we will show how kvm performs

00:11:42,160 --> 00:11:45,920
this these tags for each kind of virtual

00:11:44,560 --> 00:11:49,200
interrupts

00:11:45,920 --> 00:11:52,240
that brings us to the actual trapler's

00:11:49,200 --> 00:11:52,240
virtual interrupt

00:11:54,560 --> 00:11:57,920
for virtual timer interrupt to set a

00:11:57,360 --> 00:12:01,360
timer

00:11:57,920 --> 00:12:02,480
the guest writes to the vs time cmp csr

00:12:01,360 --> 00:12:06,480
via the ads

00:12:02,480 --> 00:12:09,120
s time cs and cmp to set the timer

00:12:06,480 --> 00:12:12,240
the host writes directly to the vsm cmp

00:12:09,120 --> 00:12:15,839
to switch the vcp contacts

00:12:12,240 --> 00:12:17,680
when a timer interrupt fires if the vcpu

00:12:15,839 --> 00:12:21,519
is in running state

00:12:17,680 --> 00:12:24,880
v equals one so hip.vstip is set

00:12:21,519 --> 00:12:25,360
the guest handles it directly in pulse

00:12:24,880 --> 00:12:28,880
state

00:12:25,360 --> 00:12:30,240
v equals zero hip.vstip is still set

00:12:28,880 --> 00:12:33,440
however the whole standard

00:12:30,240 --> 00:12:34,560
this time for the host does this to

00:12:33,440 --> 00:12:36,480
allow

00:12:34,560 --> 00:12:39,040
a necessary priority adjustment for

00:12:36,480 --> 00:12:40,800
scheduling for example

00:12:39,040 --> 00:12:43,120
in the scheduled off state the host

00:12:40,800 --> 00:12:44,880
tracks the vcpu's timer using hr timer

00:12:43,120 --> 00:12:45,200
which is same as the existing approach

00:12:44,880 --> 00:12:48,480
so

00:12:45,200 --> 00:12:53,519
no timer virtual interrupts

00:12:48,480 --> 00:12:56,240
is handled it's fired

00:12:53,519 --> 00:12:58,240
during the vcpu state transition the kvm

00:12:56,240 --> 00:12:59,839
needs to maintain consistencies

00:12:58,240 --> 00:13:02,320
so during the transition from the

00:12:59,839 --> 00:13:04,399
running state to the pulse state

00:13:02,320 --> 00:13:07,040
the kevin saves the state to the vsi

00:13:04,399 --> 00:13:09,680
ecsr so that if the vcpu enters the

00:13:07,040 --> 00:13:12,959
pulse state because it executed wfi

00:13:09,680 --> 00:13:13,920
instruction the host needs an updated

00:13:12,959 --> 00:13:16,320
view to

00:13:13,920 --> 00:13:18,000
whether the guest has enabled interrupt

00:13:16,320 --> 00:13:21,120
so they can bring the vcpu

00:13:18,000 --> 00:13:24,399
out of the vcp block function later when

00:13:21,120 --> 00:13:26,079
the interrupt is intended for the guest

00:13:24,399 --> 00:13:28,320
for the transition between the pulse

00:13:26,079 --> 00:13:30,720
state and scheduled off states

00:13:28,320 --> 00:13:31,680
the kvm needs to save the value of the

00:13:30,720 --> 00:13:35,120
vs

00:13:31,680 --> 00:13:37,279
time cmp csr and utilize the host hr

00:13:35,120 --> 00:13:41,440
timer for city to track

00:13:37,279 --> 00:13:45,040
the timer set by the guest

00:13:41,440 --> 00:13:48,079
as shown in in these lines

00:13:45,040 --> 00:13:50,240
on the slides the host

00:13:48,079 --> 00:13:51,600
needs to temporarily disable its own

00:13:50,240 --> 00:13:53,519
handling of vs mode

00:13:51,600 --> 00:13:56,000
virtual timer interrupt because if at

00:13:53,519 --> 00:13:59,440
any moment the value being saved

00:13:56,000 --> 00:14:01,360
or restored happens to be in the past

00:13:59,440 --> 00:14:03,199
the host needs to avoid double handling

00:14:01,360 --> 00:14:04,880
of the same time or interrupt again this

00:14:03,199 --> 00:14:07,040
is because we still need to maintain the

00:14:04,880 --> 00:14:08,880
level trigger semantics of timer

00:14:07,040 --> 00:14:11,360
interrupt

00:14:08,880 --> 00:14:13,839
the same as defined on the physical

00:14:11,360 --> 00:14:13,839
platform

00:14:14,079 --> 00:14:18,399
so with the extended interrupt

00:14:16,320 --> 00:14:20,160
controller and the kvm support now the

00:14:18,399 --> 00:14:22,639
virtual timer interrupt can be

00:14:20,160 --> 00:14:24,720
directly delivered to the vm kernel when

00:14:22,639 --> 00:14:28,639
the vcpu is running

00:14:24,720 --> 00:14:30,000
when the vcpu is paused the interrupt is

00:14:28,639 --> 00:14:33,680
delivered to the host

00:14:30,000 --> 00:14:36,560
which immediately injects it to the vcpu

00:14:33,680 --> 00:14:38,399
when the vcpu is scheduled off the host

00:14:36,560 --> 00:14:40,959
utilize the hr timer to track the

00:14:38,399 --> 00:14:43,360
virtual timers the hr timer uses the

00:14:40,959 --> 00:14:46,959
new timer dedicated for the hs mode

00:14:43,360 --> 00:14:46,959
avoiding traps to machine mode

00:14:49,920 --> 00:14:53,360
so that's for virtual timer interrupt

00:14:52,800 --> 00:14:55,680
for

00:14:53,360 --> 00:14:56,959
virtual supervisor software generated

00:14:55,680 --> 00:15:00,160
interrupt

00:14:56,959 --> 00:15:03,040
when a guest vcpu needs to

00:15:00,160 --> 00:15:05,600
send a software generator interrupt for

00:15:03,040 --> 00:15:08,800
another vcpu it writes to the s-gen

00:15:05,600 --> 00:15:11,680
ipi csr to do so

00:15:08,800 --> 00:15:13,519
it does so and specified the target

00:15:11,680 --> 00:15:16,000
vcpuid

00:15:13,519 --> 00:15:16,639
that that's intended to receive the

00:15:16,000 --> 00:15:20,160
virtual

00:15:16,639 --> 00:15:21,600
software generator interrupt after the

00:15:20,160 --> 00:15:24,560
write the poic

00:15:21,600 --> 00:15:24,959
received the target vcpuid so it looks

00:15:24,560 --> 00:15:28,240
up

00:15:24,959 --> 00:15:30,320
all the ifmap registers whether it is

00:15:28,240 --> 00:15:33,600
one that contains a specified

00:15:30,320 --> 00:15:37,920
vcpu id if found

00:15:33,600 --> 00:15:41,360
it delivers the vssi to the heart

00:15:37,920 --> 00:15:44,560
with the oops

00:15:41,360 --> 00:15:48,240
to the heart with m heart value

00:15:44,560 --> 00:15:49,360
n that which that which is the end slot

00:15:48,240 --> 00:15:53,279
that contains the

00:15:49,360 --> 00:15:54,000
matching vcpu id the vcpu can be either

00:15:53,279 --> 00:15:56,720
in running state

00:15:54,000 --> 00:15:57,199
or in pulse state if it's running the

00:15:56,720 --> 00:16:00,639
gas

00:15:57,199 --> 00:16:01,199
take the interrupt directly that handles

00:16:00,639 --> 00:16:03,920
it

00:16:01,199 --> 00:16:06,720
if the vcp is paused host takes the

00:16:03,920 --> 00:16:08,959
interrupt and injects it to the vcpu

00:16:06,720 --> 00:16:10,000
if there is no such a slot that contains

00:16:08,959 --> 00:16:13,759
the specified

00:16:10,000 --> 00:16:15,839
vcp id a notification interrupt

00:16:13,759 --> 00:16:17,680
is delivered to any host card for later

00:16:15,839 --> 00:16:23,120
injection the vcpu

00:16:17,680 --> 00:16:27,120
now must be in the scheduled off state

00:16:23,120 --> 00:16:27,440
the kvn job is also to maintain context

00:16:27,120 --> 00:16:28,959
for

00:16:27,440 --> 00:16:31,440
virtual software generating interrupts

00:16:28,959 --> 00:16:33,600
during the same stage transition

00:16:31,440 --> 00:16:35,360
when the vcpu transit between the

00:16:33,600 --> 00:16:37,759
running state and the pulse state

00:16:35,360 --> 00:16:39,199
the kvm synchronize the saved pending

00:16:37,759 --> 00:16:42,560
state for the vssi

00:16:39,199 --> 00:16:44,480
and the hardware vsip register recall

00:16:42,560 --> 00:16:46,240
that we separated the pending bits for

00:16:44,480 --> 00:16:49,040
the guest and the host

00:16:46,240 --> 00:16:51,440
unlike the virtual timer interrupts when

00:16:49,040 --> 00:16:53,759
the vcpu is in pulse state the host

00:16:51,440 --> 00:16:55,519
handles the vss side that receives

00:16:53,759 --> 00:16:56,240
because the plc thinks that the hard

00:16:55,519 --> 00:16:58,240
target

00:16:56,240 --> 00:17:00,399
that the target vcpu is still running on

00:16:58,240 --> 00:17:03,920
a particular heart

00:17:00,399 --> 00:17:05,600
when the host schedules off a vcpu or

00:17:03,920 --> 00:17:08,000
scales on a vcpu

00:17:05,600 --> 00:17:09,839
it updates the corresponding ifmap

00:17:08,000 --> 00:17:12,559
register

00:17:09,839 --> 00:17:14,799
when the target vcpu is scheduled off

00:17:12,559 --> 00:17:16,799
the pliac sends a notification interrupt

00:17:14,799 --> 00:17:19,600
to the heart so that the host can

00:17:16,799 --> 00:17:22,240
wake up the target vcpu and resume its

00:17:19,600 --> 00:17:22,240
execution

00:17:23,039 --> 00:17:28,240
with the extension on the interrupt

00:17:25,679 --> 00:17:29,440
controller and kvn support now the vst

00:17:28,240 --> 00:17:31,440
site can be directly

00:17:29,440 --> 00:17:33,360
directly delivered to the vm kernel when

00:17:31,440 --> 00:17:34,880
the vcpu is running

00:17:33,360 --> 00:17:37,280
avoiding traps to the current to the

00:17:34,880 --> 00:17:39,360
host when the vcpu is not currently

00:17:37,280 --> 00:17:41,840
running the host receives the interrupt

00:17:39,360 --> 00:17:46,240
and injects it to the vcpu same as the

00:17:41,840 --> 00:17:48,880
current solution

00:17:46,240 --> 00:17:50,400
similarly for virtual supervisor

00:17:48,880 --> 00:17:53,440
external interrupt

00:17:50,400 --> 00:17:55,520
um when

00:17:53,440 --> 00:17:57,679
the virtual machine is created the host

00:17:55,520 --> 00:17:58,400
allocates a piece of memory for pending

00:17:57,679 --> 00:18:03,120
bits

00:17:58,400 --> 00:18:03,120
of the external interrupts for the vm

00:18:03,280 --> 00:18:08,000
when the emulative external device needs

00:18:07,280 --> 00:18:10,160
to send

00:18:08,000 --> 00:18:11,200
a virtual supervisor external interrupt

00:18:10,160 --> 00:18:15,440
to the guest

00:18:11,200 --> 00:18:18,720
it writes the new ugen vsc icsr to send

00:18:15,440 --> 00:18:21,440
an external device interpreted guest

00:18:18,720 --> 00:18:22,720
it writes the vmid and the interim

00:18:21,440 --> 00:18:25,520
number

00:18:22,720 --> 00:18:28,000
into the register so that the pls

00:18:25,520 --> 00:18:30,400
receive these it looks up the virtual

00:18:28,000 --> 00:18:31,520
interrupt affinity tables pointed to by

00:18:30,400 --> 00:18:34,320
the v

00:18:31,520 --> 00:18:35,440
table base n registers and locate the

00:18:34,320 --> 00:18:36,880
vcpu that

00:18:35,440 --> 00:18:39,120
this virtual interrupt should be

00:18:36,880 --> 00:18:42,480
delivered to

00:18:39,120 --> 00:18:44,880
next the plic performs similar tasks

00:18:42,480 --> 00:18:47,760
when is looking for a particular

00:18:44,880 --> 00:18:49,600
vcpu for the software generated

00:18:47,760 --> 00:18:52,559
interrupt because

00:18:49,600 --> 00:18:54,559
this kind of interrupt also resembles

00:18:52,559 --> 00:18:56,480
the software generated interrupt

00:18:54,559 --> 00:18:58,080
because they are there between it

00:18:56,480 --> 00:19:01,200
happens between

00:18:58,080 --> 00:19:02,480
hearts so the plic looks up the ifmap

00:19:01,200 --> 00:19:05,280
registers

00:19:02,480 --> 00:19:07,520
um to see if there's a matching vcp id

00:19:05,280 --> 00:19:09,280
if they're easily delivered to

00:19:07,520 --> 00:19:10,640
the the virtual interrupt to that

00:19:09,280 --> 00:19:13,280
particular heart

00:19:10,640 --> 00:19:15,360
if the heart if the vcpu is running it

00:19:13,280 --> 00:19:16,960
takes the interrupt directly if it's not

00:19:15,360 --> 00:19:18,559
the host takes the interrupt injection

00:19:16,960 --> 00:19:21,280
sci to the vcpu

00:19:18,559 --> 00:19:25,120
if not found a notification interrupt is

00:19:21,280 --> 00:19:28,480
delivered to the host

00:19:25,120 --> 00:19:30,160
after the guest received the external

00:19:28,480 --> 00:19:33,440
interrupt it needs to handle

00:19:30,160 --> 00:19:33,679
it there are at least two steps during

00:19:33,440 --> 00:19:36,400
the

00:19:33,679 --> 00:19:37,200
handling of the interrupt so for guests

00:19:36,400 --> 00:19:40,400
to claim

00:19:37,200 --> 00:19:43,039
and to signal the end of interrupt

00:19:40,400 --> 00:19:45,120
processing the guests that just directly

00:19:43,039 --> 00:19:47,919
read from the right to the vs claim

00:19:45,120 --> 00:19:50,240
register to claim and signal it

00:19:47,919 --> 00:19:51,679
reading and writing to this particular

00:19:50,240 --> 00:19:56,080
register does not

00:19:51,679 --> 00:19:56,080
cause traps to host in our design

00:19:58,880 --> 00:20:02,799
so similar to the other virtual

00:20:00,400 --> 00:20:05,600
interrupts the kvm saves and restore

00:20:02,799 --> 00:20:07,760
the hip csr when the vcpu transits

00:20:05,600 --> 00:20:09,520
between the running and power state

00:20:07,760 --> 00:20:11,919
when the power state the host handles

00:20:09,520 --> 00:20:14,240
the vsci that it receives because the

00:20:11,919 --> 00:20:16,400
plc thing that the target vcpu is still

00:20:14,240 --> 00:20:20,720
running

00:20:16,400 --> 00:20:23,360
on the heart the plic reuse the same

00:20:20,720 --> 00:20:24,559
ifmap register to decide if a target

00:20:23,360 --> 00:20:27,360
vcpu is

00:20:24,559 --> 00:20:28,880
executing on any heart when the vcpu is

00:20:27,360 --> 00:20:30,799
scheduled on and off

00:20:28,880 --> 00:20:32,840
the host needs to maintain the pending

00:20:30,799 --> 00:20:35,440
bits for that particular

00:20:32,840 --> 00:20:38,480
vm um

00:20:35,440 --> 00:20:39,440
like this when the vcpu is in schedule

00:20:38,480 --> 00:20:41,280
off state

00:20:39,440 --> 00:20:42,799
the host handles any notification

00:20:41,280 --> 00:20:46,840
interrupt for

00:20:42,799 --> 00:20:49,679
vscis and that targets the schedule of

00:20:46,840 --> 00:20:52,480
vcpu

00:20:49,679 --> 00:20:55,039
so when ext with this extension and

00:20:52,480 --> 00:20:57,360
corresponding kvm support the vsci can

00:20:55,039 --> 00:21:00,400
be directly delivered to the vm kernel

00:20:57,360 --> 00:21:02,320
when the vcp is in the running state as

00:21:00,400 --> 00:21:04,400
shown in this diagram

00:21:02,320 --> 00:21:06,080
when the vcp is not running the host

00:21:04,400 --> 00:21:08,159
handles the interrupt

00:21:06,080 --> 00:21:10,880
and injects them to the vcp in a similar

00:21:08,159 --> 00:21:14,400
fashion as vssi

00:21:10,880 --> 00:21:16,480
on the processing and acknowledging side

00:21:14,400 --> 00:21:18,480
the claiming and signaling end of

00:21:16,480 --> 00:21:19,679
interrupt also happens without trapping

00:21:18,480 --> 00:21:22,720
the vm kernel that

00:21:19,679 --> 00:21:26,720
directly reads and writes a v claim csr

00:21:22,720 --> 00:21:26,720
which updates states accordingly

00:21:28,400 --> 00:21:33,440
let's move on to our information

00:21:30,080 --> 00:21:33,440
implementation results

00:21:33,679 --> 00:21:38,000
we have implemented above improving

00:21:35,840 --> 00:21:40,720
extensions in risk 5q

00:21:38,000 --> 00:21:41,360
version 5 um which provides an emulated

00:21:40,720 --> 00:21:43,280
risk 5

00:21:41,360 --> 00:21:44,799
environment with with the hypervisor

00:21:43,280 --> 00:21:48,159
extension we're using

00:21:44,799 --> 00:21:48,960
qmu because right now uh there have been

00:21:48,159 --> 00:21:52,400
no

00:21:48,960 --> 00:21:54,400
hardware that risk five hardware that

00:21:52,400 --> 00:21:57,840
contains hypervisor extension

00:21:54,400 --> 00:22:00,559
so we got no choice um we have also

00:21:57,840 --> 00:22:04,240
implemented necessary kvm support

00:22:00,559 --> 00:22:06,480
uh we on this uh kvm support we run

00:22:04,240 --> 00:22:09,200
benchmarks that can be compiled and run

00:22:06,480 --> 00:22:11,440
in the emulator with reasonable support

00:22:09,200 --> 00:22:13,360
and obtain some performance results many

00:22:11,440 --> 00:22:15,360
we are able to compile the run radius

00:22:13,360 --> 00:22:18,880
and unix bench

00:22:15,360 --> 00:22:18,880
and here are the results

00:22:19,840 --> 00:22:23,919
this benchmark shows the performance

00:22:21,760 --> 00:22:25,600
boost during radius obtained by

00:22:23,919 --> 00:22:27,200
adopting the extension for the virtual

00:22:25,600 --> 00:22:29,679
timer interrupt

00:22:27,200 --> 00:22:30,960
with one vcpu and virtual timer

00:22:29,679 --> 00:22:35,280
interrupt extension

00:22:30,960 --> 00:22:36,559
we observed around 60 to 70 percent of

00:22:35,280 --> 00:22:39,039
performance boost

00:22:36,559 --> 00:22:41,120
compared to the original solution the

00:22:39,039 --> 00:22:42,320
game mainly comes from the elimination

00:22:41,120 --> 00:22:44,640
of the traps

00:22:42,320 --> 00:22:45,679
to update the timer and to deliver the

00:22:44,640 --> 00:22:48,799
interrupts

00:22:45,679 --> 00:22:51,200
similar results are observed for unix

00:22:48,799 --> 00:22:51,200
bench

00:22:52,960 --> 00:22:56,799
this figure shows the performance

00:22:55,120 --> 00:23:00,080
boosting radius with both the virtual

00:22:56,799 --> 00:23:03,360
timer extension and the vssi extension

00:23:00,080 --> 00:23:05,679
with two v cpus we observe around

00:23:03,360 --> 00:23:08,320
50 performance gain compared to the

00:23:05,679 --> 00:23:11,200
original spi based interrupts

00:23:08,320 --> 00:23:12,080
the performance scan again also comes

00:23:11,200 --> 00:23:15,120
from

00:23:12,080 --> 00:23:15,919
the elimination of the extensive traps

00:23:15,120 --> 00:23:22,320
to the host

00:23:15,919 --> 00:23:25,520
and to various modes in the host for

00:23:22,320 --> 00:23:27,760
vsdi we used ping to

00:23:25,520 --> 00:23:29,840
the virtual machine from the host and

00:23:27,760 --> 00:23:32,320
measure the latency

00:23:29,840 --> 00:23:33,919
with our extension the latency is

00:23:32,320 --> 00:23:37,200
reduced by 11

00:23:33,919 --> 00:23:38,960
on average the game also comes from

00:23:37,200 --> 00:23:41,600
elimination of traps due to i o

00:23:38,960 --> 00:23:41,600
operations

00:23:42,080 --> 00:23:46,080
the traps are like we send we ping the

00:23:45,520 --> 00:23:49,679
machine

00:23:46,080 --> 00:23:52,960
hundred thousand times and we observe

00:23:49,679 --> 00:23:53,279
traps reduction due to mmi oh by three

00:23:52,960 --> 00:23:56,799
how

00:23:53,279 --> 00:23:59,440
around 300 000 times uh

00:23:56,799 --> 00:24:00,320
this number is expected because the

00:23:59,440 --> 00:24:03,760
current flow

00:24:00,320 --> 00:24:06,880
of io handling do cause like

00:24:03,760 --> 00:24:10,400
around three traps per handling

00:24:06,880 --> 00:24:13,120
one interrupt so we think

00:24:10,400 --> 00:24:15,200
these results here are strong indication

00:24:13,120 --> 00:24:18,159
that the extension can reduce the

00:24:15,200 --> 00:24:20,240
performance cost due to frequent traps

00:24:18,159 --> 00:24:22,000
although actually when implementing a

00:24:20,240 --> 00:24:22,720
hardware the magnitude of the numbers

00:24:22,000 --> 00:24:24,880
may change

00:24:22,720 --> 00:24:27,440
because we are still using an emulating

00:24:24,880 --> 00:24:27,440
environment

00:24:27,600 --> 00:24:32,799
so for the future we like to continue to

00:24:30,480 --> 00:24:33,679
explore along the direction to include

00:24:32,799 --> 00:24:35,919
support for

00:24:33,679 --> 00:24:38,400
password devices which means we need an

00:24:35,919 --> 00:24:40,559
iomu in the first place

00:24:38,400 --> 00:24:41,919
we still need to furnish our extension

00:24:40,559 --> 00:24:45,039
with more details

00:24:41,919 --> 00:24:49,440
with practical practical implementations

00:24:45,039 --> 00:24:52,320
such as priority controls etc etc

00:24:49,440 --> 00:24:54,799
um we also like to seek to integrate our

00:24:52,320 --> 00:24:57,200
extension with futurist risk 5 interrupt

00:24:54,799 --> 00:25:00,480
controllers as well as validating our

00:24:57,200 --> 00:25:03,279
idea with more hypervisors

00:25:00,480 --> 00:25:13,520
with that i end my presentation and

00:25:03,279 --> 00:25:13,520

YouTube URL: https://www.youtube.com/watch?v=KIJuqtHC4bQ


