Title: [2020] Hypervisor Based Integrity: Protect Guest Kernel in Cloud by Ning Yang & Forrest Yuan Yu
Publication date: 2020-12-09
Playlist: KVM Forum 2020
Description: 
	There are multiple efforts from the community that tries to bring Virtualization based security into the industry and there are a number of papers published every year to discuss the benefit of this approach. Hypervisor Based Integrity(HBI) is product Google Cloud is currently investing to be the public offering for such security hardening in the Cloud. The talk will cover the place where this implementation fits in the Cloud environment, the relationship between this mechanism and other security enhancement for the Linux kernel, what HBI can protect/monitor, special challenges encountered along the road. In addition, it will also cover an overview of the new hypervisor security kernel module Google plans to upstream and show how all hypervisor/VMM can easily implement the support for it so guest VM can move across different providers while getting the same security guarantee.

---

Ning Yang
Google Inc, Senior Software Developer

Ning is a Senior Software Developer at Google Compute Infrastructure Team. He contributes to Google internal VMM, including device emulation and guest firmware/driver support. Worked on bringing UEFI(OVMF) into Google Cloud and the Google Cloud Shielded VM project, which provides secure boot support and security monitoring as the measured boot.

Forrest Yuan Yu
Google Inc, Software Developer

Forrest is a software engineer at Google working on firmware, virtualization and making GCP more secure for customers.
Captions: 
	00:00:07,120 --> 00:00:09,840
hello everyone

00:00:08,080 --> 00:00:12,400
thanks for attending this session my

00:00:09,840 --> 00:00:14,960
name is ning i'm working as

00:00:12,400 --> 00:00:16,640
software engineer for google cloud our

00:00:14,960 --> 00:00:18,240
team is mainly responsible for

00:00:16,640 --> 00:00:19,840
maintaining the hypervisor

00:00:18,240 --> 00:00:21,439
and virtual machine monitor inside

00:00:19,840 --> 00:00:23,920
google and google cloud

00:00:21,439 --> 00:00:25,279
today the topic of the top is hypervisor

00:00:23,920 --> 00:00:27,840
based integrity

00:00:25,279 --> 00:00:30,080
as you can probably tell from the name

00:00:27,840 --> 00:00:32,559
we are trying to utilize the super power

00:00:30,080 --> 00:00:33,200
given by the hypervisor and hardware to

00:00:32,559 --> 00:00:35,440
provide

00:00:33,200 --> 00:00:37,920
the gas kernels running inside the cloud

00:00:35,440 --> 00:00:37,920
environment

00:00:39,920 --> 00:00:44,960
so some high level disclaimer this is

00:00:42,640 --> 00:00:47,280
not a statement of direction of planted

00:00:44,960 --> 00:00:48,559
investment by google yet we are

00:00:47,280 --> 00:00:51,120
exploring this

00:00:48,559 --> 00:00:51,680
as a possible security mechanisms and we

00:00:51,120 --> 00:00:53,600
are

00:00:51,680 --> 00:00:56,239
seeking feedbacks from the big

00:00:53,600 --> 00:00:56,239
communities

00:00:57,520 --> 00:01:00,800
a background on why we are heading this

00:01:00,160 --> 00:01:03,680
way

00:01:00,800 --> 00:01:04,080
so google cloud offer a product called

00:01:03,680 --> 00:01:07,760
should

00:01:04,080 --> 00:01:09,280
vm in fact that's a default vm type if

00:01:07,760 --> 00:01:11,600
you try to create a virtual machine

00:01:09,280 --> 00:01:13,600
inside google cloud

00:01:11,600 --> 00:01:15,759
as you can tell from the name it comes

00:01:13,600 --> 00:01:19,439
with some enhanced security

00:01:15,759 --> 00:01:20,960
features one of them called secure boot

00:01:19,439 --> 00:01:23,920
on high level in case you are not

00:01:20,960 --> 00:01:25,200
familiar with it provide integrity check

00:01:23,920 --> 00:01:29,439
against firmware

00:01:25,200 --> 00:01:33,759
bootloader and kernel during boot time

00:01:29,439 --> 00:01:33,759
it will use as duplicates and

00:01:34,640 --> 00:01:40,799
into to verify the signature of

00:01:37,920 --> 00:01:41,520
all the modules and has been sent

00:01:40,799 --> 00:01:43,920
correctly

00:01:41,520 --> 00:01:45,200
all the drivers and all the binaries

00:01:43,920 --> 00:01:48,720
they're trying to load

00:01:45,200 --> 00:01:49,200
so it gives you a guarantee like at the

00:01:48,720 --> 00:01:51,680
end

00:01:49,200 --> 00:01:53,280
of the boot everything should be in a

00:01:51,680 --> 00:01:54,720
very good shape nothing has been

00:01:53,280 --> 00:01:57,520
modified have been

00:01:54,720 --> 00:01:58,000
or has been hijacked in any way after

00:01:57,520 --> 00:02:01,040
that

00:01:58,000 --> 00:02:01,840
most kernel modules if you try to load

00:02:01,040 --> 00:02:04,640
additional

00:02:01,840 --> 00:02:07,119
um dynamic kernel modules they will be

00:02:04,640 --> 00:02:10,000
protected by the module signings so

00:02:07,119 --> 00:02:11,039
that's code in the in the kernel which

00:02:10,000 --> 00:02:12,879
will do secondary

00:02:11,039 --> 00:02:15,360
signature checkings against the module

00:02:12,879 --> 00:02:18,959
you are trying to load

00:02:15,360 --> 00:02:22,239
that's all good but in real life

00:02:18,959 --> 00:02:23,280
attackers can still find them different

00:02:22,239 --> 00:02:26,959
ways

00:02:23,280 --> 00:02:30,080
to gain like highest privileges inside

00:02:26,959 --> 00:02:33,920
a running coin if he can do that

00:02:30,080 --> 00:02:36,400
and he can modify the code page or

00:02:33,920 --> 00:02:37,360
call back in some special way like all

00:02:36,400 --> 00:02:40,879
the security

00:02:37,360 --> 00:02:43,440
gate we put in place cannot be

00:02:40,879 --> 00:02:44,400
trusted and we could put user

00:02:43,440 --> 00:02:47,680
applications

00:02:44,400 --> 00:02:47,680
in a risk state

00:02:48,480 --> 00:02:52,080
the goal is trying to protect the kernel

00:02:50,720 --> 00:02:53,920
ima at the runtime

00:02:52,080 --> 00:02:55,920
since we already have all these green

00:02:53,920 --> 00:02:59,040
box checked during boot

00:02:55,920 --> 00:03:02,959
we are trying to extend what we can and

00:02:59,040 --> 00:03:05,599
help make sure like the kernel

00:03:02,959 --> 00:03:06,480
at runtime is also protect and can be

00:03:05,599 --> 00:03:08,400
trusted

00:03:06,480 --> 00:03:10,800
if kernel has not been modified in any

00:03:08,400 --> 00:03:13,840
way and running as expected

00:03:10,800 --> 00:03:17,440
the user application can feel much safe

00:03:13,840 --> 00:03:20,000
about it and one more thing

00:03:17,440 --> 00:03:21,840
is the production we put in place the

00:03:20,000 --> 00:03:25,519
cat should not be able to turn off

00:03:21,840 --> 00:03:27,280
from the guest because

00:03:25,519 --> 00:03:29,200
i mean rootkit can gain highest

00:03:27,280 --> 00:03:31,280
privilege if he can

00:03:29,200 --> 00:03:32,640
change the settings in the gas to turn

00:03:31,280 --> 00:03:36,319
off the protection then

00:03:32,640 --> 00:03:38,720
the protection is not that

00:03:36,319 --> 00:03:38,720
strong

00:03:39,440 --> 00:03:42,799
so let's talk about the threat model

00:03:41,040 --> 00:03:44,840
here so we assume

00:03:42,799 --> 00:03:47,120
the attacker has the following

00:03:44,840 --> 00:03:50,879
capabilities so it can gain

00:03:47,120 --> 00:03:54,159
ring zero access it can

00:03:50,879 --> 00:03:57,120
have arbitrary read and write

00:03:54,159 --> 00:03:58,640
permissions so it can read and any kind

00:03:57,120 --> 00:04:02,879
of memory address and write

00:03:58,640 --> 00:04:02,879
any value to any kernel memory address

00:04:03,200 --> 00:04:06,879
so how do we protect the guest kernel

00:04:04,879 --> 00:04:08,159
based on the threat model we just talked

00:04:06,879 --> 00:04:09,360
about

00:04:08,159 --> 00:04:11,599
first of all we want to make sure

00:04:09,360 --> 00:04:13,840
there's no intended modifications on the

00:04:11,599 --> 00:04:14,400
kernel code segment and read-only data

00:04:13,840 --> 00:04:17,680
segment

00:04:14,400 --> 00:04:19,519
and this is very obvious we have very

00:04:17,680 --> 00:04:21,280
well written code we don't want it get

00:04:19,519 --> 00:04:23,840
replaced by some

00:04:21,280 --> 00:04:25,440
molecular code second of all we want to

00:04:23,840 --> 00:04:27,440
make sure the code execution

00:04:25,440 --> 00:04:29,040
no code execution from other part of the

00:04:27,440 --> 00:04:31,040
kernel space

00:04:29,040 --> 00:04:32,800
data statement should always be read and

00:04:31,040 --> 00:04:35,759
write but not executable

00:04:32,800 --> 00:04:36,960
and yes this is where buffer blow attack

00:04:35,759 --> 00:04:39,919
happens and we won't

00:04:36,960 --> 00:04:41,280
block that and third and we want to make

00:04:39,919 --> 00:04:43,759
sure there's no

00:04:41,280 --> 00:04:45,280
intended modifications of key kernel

00:04:43,759 --> 00:04:48,080
data structures

00:04:45,280 --> 00:04:48,639
for example a system call table which is

00:04:48,080 --> 00:04:51,759
a

00:04:48,639 --> 00:04:53,199
table of functional pointers hackers

00:04:51,759 --> 00:04:53,919
managed to replace it with something

00:04:53,199 --> 00:04:56,880
else

00:04:53,919 --> 00:04:58,240
user may get monitored or hacked without

00:04:56,880 --> 00:05:01,039
realizing it

00:04:58,240 --> 00:05:03,680
um as example is control register like

00:05:01,039 --> 00:05:05,680
cr0 or cr4 there's a bit in the control

00:05:03,680 --> 00:05:08,880
register in the cr0

00:05:05,680 --> 00:05:12,160
which is really write protection so

00:05:08,880 --> 00:05:14,960
if you and after bit the

00:05:12,160 --> 00:05:17,440
kernel that the the process will allow

00:05:14,960 --> 00:05:17,840
you to write to a read-only memory which

00:05:17,440 --> 00:05:21,840
is

00:05:17,840 --> 00:05:23,919
not ideal and there's other msr

00:05:21,840 --> 00:05:25,840
important msrs like there's people

00:05:23,919 --> 00:05:28,960
talking about system enter

00:05:25,840 --> 00:05:32,000
msr and

00:05:28,960 --> 00:05:35,039
utilizing that msr they can hack

00:05:32,000 --> 00:05:37,120
this sound system course of course

00:05:35,039 --> 00:05:38,400
similar to system call table there's a

00:05:37,120 --> 00:05:41,199
idt

00:05:38,400 --> 00:05:43,039
interrupt descript descriptor table and

00:05:41,199 --> 00:05:45,039
gdt global descripto

00:05:43,039 --> 00:05:46,560
table both of them has some function

00:05:45,039 --> 00:05:47,840
pointers we want to make sure it never

00:05:46,560 --> 00:05:50,160
gets overwritten

00:05:47,840 --> 00:05:50,880
of course last but not least we have the

00:05:50,160 --> 00:05:54,479
page table

00:05:50,880 --> 00:05:57,199
which has the mapping from

00:05:54,479 --> 00:05:57,919
virtual to physical so if people hacks

00:05:57,199 --> 00:06:00,240
mappings

00:05:57,919 --> 00:06:02,960
they can redirect the code execution to

00:06:00,240 --> 00:06:05,360
some other place

00:06:02,960 --> 00:06:07,360
but why we want to use hypervisor as

00:06:05,360 --> 00:06:10,160
another security layer

00:06:07,360 --> 00:06:12,160
and our understanding is there's always

00:06:10,160 --> 00:06:13,680
a risk of protecting guests from

00:06:12,160 --> 00:06:15,840
wheeling the guests

00:06:13,680 --> 00:06:17,280
because we we already did a lot of

00:06:15,840 --> 00:06:19,039
kernel handling work

00:06:17,280 --> 00:06:20,560
in the kernel space to make it harder

00:06:19,039 --> 00:06:23,039
and harder but it's not

00:06:20,560 --> 00:06:23,919
guaranteed to be impossible rootkit or

00:06:23,039 --> 00:06:26,240
attacker can

00:06:23,919 --> 00:06:28,000
still gain highest privilege and read

00:06:26,240 --> 00:06:29,360
and write any guess memories if they

00:06:28,000 --> 00:06:31,199
want

00:06:29,360 --> 00:06:32,479
and it's not easy but it's still

00:06:31,199 --> 00:06:36,400
possible

00:06:32,479 --> 00:06:39,600
so anything we put in kernel space um

00:06:36,400 --> 00:06:41,280
could be risky and but on the other hand

00:06:39,600 --> 00:06:41,840
if we guarantee like kernel number

00:06:41,280 --> 00:06:43,919
change

00:06:41,840 --> 00:06:45,759
uh conor code never changes then

00:06:43,919 --> 00:06:48,639
basically in return it will make sure

00:06:45,759 --> 00:06:50,960
all the security checks we put in place

00:06:48,639 --> 00:06:52,400
be more robust so this is not a

00:06:50,960 --> 00:06:54,160
replacement of all the

00:06:52,400 --> 00:06:56,000
kernel handling work we have there we

00:06:54,160 --> 00:06:57,919
hope this is just an

00:06:56,000 --> 00:07:00,960
enhancement layer like make sure

00:06:57,919 --> 00:07:00,960
whatever you put there

00:07:01,280 --> 00:07:06,240
is cracked and remain

00:07:04,319 --> 00:07:08,639
cracked for the entire life cycle of the

00:07:06,240 --> 00:07:08,639
vm

00:07:09,039 --> 00:07:14,720
applies the on the other hand hyper has

00:07:11,759 --> 00:07:17,120
almost 21 mappings to all the

00:07:14,720 --> 00:07:18,080
protection we want to achieve hypervisor

00:07:17,120 --> 00:07:20,720
can control read

00:07:18,080 --> 00:07:21,919
write exclude bit for page align guest

00:07:20,720 --> 00:07:25,520
memory reading

00:07:21,919 --> 00:07:26,880
and utilizing the two dimensional pages

00:07:25,520 --> 00:07:30,000
like ebt or

00:07:26,880 --> 00:07:31,759
npt for md we can set up

00:07:30,000 --> 00:07:34,319
the permissions which guests can never

00:07:31,759 --> 00:07:36,880
change and hypervisor can

00:07:34,319 --> 00:07:39,199
protect unsafe modifications of control

00:07:36,880 --> 00:07:42,960
gestures and msrs we just configure

00:07:39,199 --> 00:07:46,400
the vm exit on those um right

00:07:42,960 --> 00:07:48,000
to msr or control register and then we

00:07:46,400 --> 00:07:51,199
can do double check whether

00:07:48,000 --> 00:07:53,840
that's legitimate legitimate or not

00:07:51,199 --> 00:07:56,319
and hypervisor can also protect the key

00:07:53,840 --> 00:07:57,840
kernel page table

00:07:56,319 --> 00:08:00,080
there's a new feature called advisor

00:07:57,840 --> 00:08:00,960
managed to linear adjust translation for

00:08:00,080 --> 00:08:03,039
intel

00:08:00,960 --> 00:08:05,039
which allow you to set up page table

00:08:03,039 --> 00:08:07,280
mappings controlled by hypervisor and

00:08:05,039 --> 00:08:09,919
guests can never change it

00:08:07,280 --> 00:08:11,120
and most importantly for us for google

00:08:09,919 --> 00:08:14,080
cloud

00:08:11,120 --> 00:08:15,599
both of our guests all of our customer

00:08:14,080 --> 00:08:17,280
customer

00:08:15,599 --> 00:08:18,639
machines are already running in a

00:08:17,280 --> 00:08:20,879
virtual machine mode

00:08:18,639 --> 00:08:22,240
we already have a layer underneath all

00:08:20,879 --> 00:08:23,840
those vms

00:08:22,240 --> 00:08:25,280
and we are not trying to introduce

00:08:23,840 --> 00:08:27,440
another

00:08:25,280 --> 00:08:29,280
layer of complexity here we are just

00:08:27,440 --> 00:08:32,000
using the existing layer to make

00:08:29,280 --> 00:08:34,479
everything more robust and more

00:08:32,000 --> 00:08:34,479
secure

00:08:36,880 --> 00:08:40,880
so how does everything work end to end

00:08:39,039 --> 00:08:42,640
here we want to introduce a new guest

00:08:40,880 --> 00:08:44,800
security kernel module

00:08:42,640 --> 00:08:47,040
um this module should be loaded at both

00:08:44,800 --> 00:08:49,279
time ideally by the end of boot time

00:08:47,040 --> 00:08:50,480
so we the kernel has already set up all

00:08:49,279 --> 00:08:53,519
the page table

00:08:50,480 --> 00:08:55,440
idt gdt system call table etc

00:08:53,519 --> 00:08:56,560
it should be signed and protected by the

00:08:55,440 --> 00:08:58,720
secure boot

00:08:56,560 --> 00:09:00,959
so it can be trusted at both time if

00:08:58,720 --> 00:09:04,959
anyone tries to modify it in some way

00:09:00,959 --> 00:09:06,480
a secure board will fail and it should

00:09:04,959 --> 00:09:08,480
after it gets loaded and will check

00:09:06,480 --> 00:09:11,760
whether the supports

00:09:08,480 --> 00:09:13,839
special integrity protections if it does

00:09:11,760 --> 00:09:15,040
i will try to identify all the kernel

00:09:13,839 --> 00:09:17,360
code data segment

00:09:15,040 --> 00:09:18,399
and address of the key data structures

00:09:17,360 --> 00:09:20,320
and send a

00:09:18,399 --> 00:09:21,680
piece protect me request to the

00:09:20,320 --> 00:09:24,320
hypervisor

00:09:21,680 --> 00:09:25,760
and then we need to wait um i cannot

00:09:24,320 --> 00:09:27,600
wait for the acknowledgement from

00:09:25,760 --> 00:09:30,720
hypervisor because

00:09:27,600 --> 00:09:34,000
we don't want to jump into the runtime

00:09:30,720 --> 00:09:34,880
and so everything become a little bit

00:09:34,000 --> 00:09:36,399
out of control

00:09:34,880 --> 00:09:39,600
during boot time everything is still in

00:09:36,399 --> 00:09:39,600
the control and in good shape

00:09:39,680 --> 00:09:44,800
on the hypothesis side during both time

00:09:42,959 --> 00:09:47,120
it needs to decode the memory segment

00:09:44,800 --> 00:09:49,360
information sent from the guest

00:09:47,120 --> 00:09:51,519
we'll modify the second level

00:09:49,360 --> 00:09:53,040
translation table to set correct read

00:09:51,519 --> 00:09:55,440
write execute bit

00:09:53,040 --> 00:09:57,279
with a specific memory reading and it

00:09:55,440 --> 00:10:00,720
will configure the vm exit

00:09:57,279 --> 00:10:03,279
on msrs and control registers after that

00:10:00,720 --> 00:10:04,079
it should acknowledge the request and

00:10:03,279 --> 00:10:07,839
let it continue

00:10:04,079 --> 00:10:10,160
to boot we just a few actors we need to

00:10:07,839 --> 00:10:14,640
call so it should not

00:10:10,160 --> 00:10:17,920
have significant impact on guestbook

00:10:14,640 --> 00:10:19,920
during runtime the hypervisor and qmu or

00:10:17,920 --> 00:10:23,839
vmm were just

00:10:19,920 --> 00:10:27,920
handling ept and mpt access valuations

00:10:23,839 --> 00:10:30,240
and if that happens user can config

00:10:27,920 --> 00:10:32,079
one of the following actions and either

00:10:30,240 --> 00:10:35,279
kill the running vm and dump

00:10:32,079 --> 00:10:38,640
all the memories for analyze as for

00:10:35,279 --> 00:10:40,240
the people like who care a lot about

00:10:38,640 --> 00:10:43,680
security and want to make sure

00:10:40,240 --> 00:10:46,079
nothing wrong should happen

00:10:43,680 --> 00:10:48,240
and from quadratic users we would expect

00:10:46,079 --> 00:10:49,920
we will just log up critical event and

00:10:48,240 --> 00:10:52,959
notify the user and let them

00:10:49,920 --> 00:10:55,120
decide what they want meanwhile

00:10:52,959 --> 00:10:56,320
on the other hand like we do the same

00:10:55,120 --> 00:10:59,680
thing for the controller set

00:10:56,320 --> 00:11:01,040
register and msr modifications and you

00:10:59,680 --> 00:11:04,560
may be wondering like

00:11:01,040 --> 00:11:05,519
you know in runtime we can add dynamic

00:11:04,560 --> 00:11:07,600
kernel modules

00:11:05,519 --> 00:11:09,760
those kernel modules are executable so

00:11:07,600 --> 00:11:13,279
how do we handle that

00:11:09,760 --> 00:11:14,079
our recommendation is much safer to do

00:11:13,279 --> 00:11:16,880
not do that

00:11:14,079 --> 00:11:18,000
but if we have to do that and we have

00:11:16,880 --> 00:11:20,480
apis

00:11:18,000 --> 00:11:22,079
exposed by the guest module so we'll

00:11:20,480 --> 00:11:24,079
modify the kernel code a little bit

00:11:22,079 --> 00:11:25,200
so first of all the kernel code will

00:11:24,079 --> 00:11:28,079
locate

00:11:25,200 --> 00:11:29,120
um read and write both memory region

00:11:28,079 --> 00:11:32,959
then copy

00:11:29,120 --> 00:11:34,959
binary into it and once the ss

00:11:32,959 --> 00:11:36,720
when the verification is done it will

00:11:34,959 --> 00:11:39,200
cause the api to change

00:11:36,720 --> 00:11:40,720
the code segment of that memory region

00:11:39,200 --> 00:11:43,760
to be read and acceptable

00:11:40,720 --> 00:11:46,560
so i probably will make sure like the

00:11:43,760 --> 00:11:50,240
code segment never change after the

00:11:46,560 --> 00:11:50,240
first time you load the kernel module

00:11:50,959 --> 00:11:54,399
you may wonder like what's the promise

00:11:52,639 --> 00:11:55,440
impact since we're doing a lot of stuff

00:11:54,399 --> 00:11:57,440
here

00:11:55,440 --> 00:11:58,959
for memory access the impact should be

00:11:57,440 --> 00:12:01,600
minimal

00:11:58,959 --> 00:12:02,639
mainly because we have surpassed through

00:12:01,600 --> 00:12:05,760
the hardware

00:12:02,639 --> 00:12:07,760
intel epto md and pt

00:12:05,760 --> 00:12:09,519
if there's no violation happens there

00:12:07,760 --> 00:12:12,320
should be no impact at all

00:12:09,519 --> 00:12:13,519
but if something happens i think it's

00:12:12,320 --> 00:12:16,560
okay to

00:12:13,519 --> 00:12:18,959
pay some extra cost on the vm exit to

00:12:16,560 --> 00:12:22,720
determine whether the operation is

00:12:18,959 --> 00:12:25,279
legitimate legitimate or not and

00:12:22,720 --> 00:12:27,360
from our prototype prototyping and

00:12:25,279 --> 00:12:30,399
testing

00:12:27,360 --> 00:12:33,760
those do not happen very often if that's

00:12:30,399 --> 00:12:36,800
if it is a lc kernel for

00:12:33,760 --> 00:12:37,920
control reduction and msr module

00:12:36,800 --> 00:12:40,160
specific regressor

00:12:37,920 --> 00:12:41,760
the impact should also be minimal and we

00:12:40,160 --> 00:12:44,240
because we don't expect a lot of

00:12:41,760 --> 00:12:45,279
multiplications on a typical kernel

00:12:44,240 --> 00:12:46,560
runtime

00:12:45,279 --> 00:12:48,320
if you are running a nasty

00:12:46,560 --> 00:12:48,959
virtualization it's completely another

00:12:48,320 --> 00:12:52,160
story

00:12:48,959 --> 00:12:53,120
so we we don't expect we don't recommend

00:12:52,160 --> 00:12:55,200
people to know this

00:12:53,120 --> 00:12:56,720
if yeah they're running into these

00:12:55,200 --> 00:12:59,920
scenarios

00:12:56,720 --> 00:13:02,000
and for the page table translation it

00:12:59,920 --> 00:13:03,839
need hardware support um but currently

00:13:02,000 --> 00:13:07,360
only limited to intel

00:13:03,839 --> 00:13:10,320
other lake so it's not there yet and

00:13:07,360 --> 00:13:10,320
we cannot measure it

00:13:11,760 --> 00:13:15,519
it sounds straightforward but it has a

00:13:14,639 --> 00:13:18,959
bunch of

00:13:15,519 --> 00:13:21,519
technical challenges and two major ones

00:13:18,959 --> 00:13:22,560
is like how do we distinguish between

00:13:21,519 --> 00:13:26,399
legitimate

00:13:22,560 --> 00:13:28,800
uh legitimate kernel modifications

00:13:26,399 --> 00:13:29,920
yes a bunch of reasons you can see we

00:13:28,800 --> 00:13:34,639
list here

00:13:29,920 --> 00:13:36,639
uh gonna want to mod by itself and

00:13:34,639 --> 00:13:39,040
we need to work with our customers to

00:13:36,639 --> 00:13:42,160
either disable those

00:13:39,040 --> 00:13:45,519
disable those special scenarios

00:13:42,160 --> 00:13:46,959
in their image or we need to decode the

00:13:45,519 --> 00:13:48,480
instruction pointer and

00:13:46,959 --> 00:13:51,519
goes through the core stack and white

00:13:48,480 --> 00:13:54,399
lists those operations

00:13:51,519 --> 00:13:55,199
another major problem is when set memory

00:13:54,399 --> 00:13:58,079
permission

00:13:55,199 --> 00:14:00,160
not all segments are nicely aligned if

00:13:58,079 --> 00:14:00,959
we have one page and because when we set

00:14:00,160 --> 00:14:03,839
permission it

00:14:00,959 --> 00:14:05,680
on the page level if we have one page

00:14:03,839 --> 00:14:06,399
that is shared between a code segment

00:14:05,680 --> 00:14:09,680
and the test

00:14:06,399 --> 00:14:14,399
segment will be very hard for us

00:14:09,680 --> 00:14:14,399
to set correct permission on it and

00:14:15,199 --> 00:14:18,480
we will have a potential problem here so

00:14:17,040 --> 00:14:20,560
to mitigate this issue

00:14:18,480 --> 00:14:22,160
um some change in the kernel need to

00:14:20,560 --> 00:14:24,000
happen to make sure

00:14:22,160 --> 00:14:26,000
like all the code segment all the

00:14:24,000 --> 00:14:31,680
different segments of kernel

00:14:26,000 --> 00:14:34,399
um is nicely aligned

00:14:31,680 --> 00:14:35,120
so here's a quick example of what it

00:14:34,399 --> 00:14:37,600
looks like

00:14:35,120 --> 00:14:39,360
if we turn on the protection we have a

00:14:37,600 --> 00:14:41,440
guest running on dbm 10

00:14:39,360 --> 00:14:44,000
after kernel boots we map the entire

00:14:41,440 --> 00:14:46,399
canonical segment as read and executable

00:14:44,000 --> 00:14:47,440
we got a bunch of epta violations right

00:14:46,399 --> 00:14:49,680
away

00:14:47,440 --> 00:14:51,199
but if we go through the course stack

00:14:49,680 --> 00:14:53,399
for each of them it comes

00:14:51,199 --> 00:14:55,360
back to the same function which is a

00:14:53,399 --> 00:14:57,360
textbook

00:14:55,360 --> 00:14:59,279
the description of this function clearly

00:14:57,360 --> 00:15:01,040
says it's trying to update instructions

00:14:59,279 --> 00:15:03,920
on live kernel so this is a

00:15:01,040 --> 00:15:05,920
valid case for kernel modifications

00:15:03,920 --> 00:15:07,440
after you remove of that particular

00:15:05,920 --> 00:15:09,839
particular module look

00:15:07,440 --> 00:15:11,519
at that the gas running smoothly without

00:15:09,839 --> 00:15:13,360
any further violations

00:15:11,519 --> 00:15:14,720
this is this is a very good example to

00:15:13,360 --> 00:15:18,240
show you like

00:15:14,720 --> 00:15:21,680
if we configure the image correctly

00:15:18,240 --> 00:15:24,959
any violations any access violations

00:15:21,680 --> 00:15:27,839
would be a strong hint of possible

00:15:24,959 --> 00:15:27,839
attack

00:15:30,000 --> 00:15:35,759
now let's talk about to support

00:15:33,360 --> 00:15:37,440
the protection we just mentioned what

00:15:35,759 --> 00:15:41,040
are the changes we need

00:15:37,440 --> 00:15:42,480
for kvm and qmu and first of all we want

00:15:41,040 --> 00:15:45,120
a common interface to turn

00:15:42,480 --> 00:15:47,120
on the protection as you can see during

00:15:45,120 --> 00:15:48,240
boot time the guest agent is sending

00:15:47,120 --> 00:15:51,519
some message

00:15:48,240 --> 00:15:55,360
to the hypervisor and bmm

00:15:51,519 --> 00:15:59,360
so currently we are using a select msr

00:15:55,360 --> 00:16:02,240
for these configurations it's not ideal

00:15:59,360 --> 00:16:04,720
if we can make allocator special hype

00:16:02,240 --> 00:16:07,440
call just for this purpose

00:16:04,720 --> 00:16:08,880
it will show that this is for vm only

00:16:07,440 --> 00:16:11,839
and with one it will

00:16:08,880 --> 00:16:13,839
avoid a lot of confusions and once

00:16:11,839 --> 00:16:17,199
people agree on the interface

00:16:13,839 --> 00:16:20,720
api what's a hype call looks like

00:16:17,199 --> 00:16:23,360
any hypervisor or vmm can implement

00:16:20,720 --> 00:16:25,360
the support for this api to provide the

00:16:23,360 --> 00:16:29,360
same level of production

00:16:25,360 --> 00:16:30,320
no matter where or the vm will be

00:16:29,360 --> 00:16:33,440
landing

00:16:30,320 --> 00:16:36,880
uh like azure aws or google cloud

00:16:33,440 --> 00:16:40,399
or music can all implement the same apis

00:16:36,880 --> 00:16:43,519
so the guests can move freely

00:16:40,399 --> 00:16:46,880
around different providers and gain the

00:16:43,519 --> 00:16:46,880
same level of protection

00:16:47,120 --> 00:16:55,199
we have a rfc sent out a while ago

00:16:51,040 --> 00:16:58,639
so that's for adding a hap call

00:16:55,199 --> 00:17:00,320
called abm hype call you call so this is

00:16:58,639 --> 00:17:03,759
a hype call we want to

00:17:00,320 --> 00:17:07,120
tell the high visor to to hand over to

00:17:03,759 --> 00:17:08,000
bmm to handle this uh special hack

00:17:07,120 --> 00:17:09,839
course

00:17:08,000 --> 00:17:11,199
we have a link and you guys can review

00:17:09,839 --> 00:17:14,319
it um

00:17:11,199 --> 00:17:15,520
so why we need this change so today all

00:17:14,319 --> 00:17:20,079
the hypeco are handled

00:17:15,520 --> 00:17:23,360
inside kvm it never caused any vm exit

00:17:20,079 --> 00:17:25,520
and but we won't have call to pass

00:17:23,360 --> 00:17:26,400
we want our help co interface to pass

00:17:25,520 --> 00:17:29,360
the control

00:17:26,400 --> 00:17:30,320
back to the vmm why we want to bmm to

00:17:29,360 --> 00:17:34,000
handle this request

00:17:30,320 --> 00:17:36,799
instead of kvm because bmim

00:17:34,000 --> 00:17:38,320
is responsible for setting up the guest

00:17:36,799 --> 00:17:40,400
memory mapping

00:17:38,320 --> 00:17:41,360
and should have knowledge or should

00:17:40,400 --> 00:17:44,480
control

00:17:41,360 --> 00:17:47,039
the permission associated with it

00:17:44,480 --> 00:17:49,440
and what's more important is it can

00:17:47,039 --> 00:17:52,240
simplify this part for line migration

00:17:49,440 --> 00:17:52,799
because during live migration vmm could

00:17:52,240 --> 00:17:55,360
just

00:17:52,799 --> 00:17:56,320
create the same gas memory apply the

00:17:55,360 --> 00:17:58,960
permission

00:17:56,320 --> 00:17:59,760
because it has knowledge of everything

00:17:58,960 --> 00:18:02,240
and

00:17:59,760 --> 00:18:04,400
and we can keep the kvm simple kvm just

00:18:02,240 --> 00:18:06,240
need to expose api we need to turn on

00:18:04,400 --> 00:18:07,039
the production and all the status is

00:18:06,240 --> 00:18:10,880
maintained

00:18:07,039 --> 00:18:10,880
in the vmm instead of kvn

00:18:11,679 --> 00:18:16,640
so once we have the hype call defined we

00:18:14,880 --> 00:18:19,440
want to defend the message

00:18:16,640 --> 00:18:20,799
sending from the guest to bmm this is a

00:18:19,440 --> 00:18:24,240
single proposal

00:18:20,799 --> 00:18:27,760
we put here we want um

00:18:24,240 --> 00:18:30,240
we won't call it hbi request it's a

00:18:27,760 --> 00:18:33,360
hyper-based integrity request

00:18:30,240 --> 00:18:36,880
and we have a version and operation code

00:18:33,360 --> 00:18:38,559
so for operation um it can be set memory

00:18:36,880 --> 00:18:41,600
protection

00:18:38,559 --> 00:18:42,720
etc etc we can extend it for future

00:18:41,600 --> 00:18:46,240
usage

00:18:42,720 --> 00:18:48,880
and for the memory for the message body

00:18:46,240 --> 00:18:49,919
it only needs to tell us what's the pfn

00:18:48,880 --> 00:18:51,440
page physical number

00:18:49,919 --> 00:18:53,840
how many number of pages you want to

00:18:51,440 --> 00:18:56,320
protect what memory permission you want

00:18:53,840 --> 00:18:58,160
to set on this on those pages

00:18:56,320 --> 00:19:00,240
for the memory permission it can be read

00:18:58,160 --> 00:19:03,679
and they read and execute

00:19:00,240 --> 00:19:06,880
or read and write never allowed

00:19:03,679 --> 00:19:09,360
execute and write happen same time

00:19:06,880 --> 00:19:11,679
and once the the request is complete

00:19:09,360 --> 00:19:17,120
gets able to

00:19:11,679 --> 00:19:17,120
get the result from this written code

00:19:18,320 --> 00:19:23,120
that's for the protocol for the guest

00:19:20,720 --> 00:19:27,039
vmm communication protocol

00:19:23,120 --> 00:19:30,480
other than that um they correctly

00:19:27,039 --> 00:19:33,200
set the memory machine we need to call

00:19:30,480 --> 00:19:35,600
the kvm set user memory region adapter

00:19:33,200 --> 00:19:37,600
because unfortunately today the current

00:19:35,600 --> 00:19:41,120
call only supports setting memory as

00:19:37,600 --> 00:19:44,080
read and executable but we want

00:19:41,120 --> 00:19:44,880
read and write not executable this is

00:19:44,080 --> 00:19:46,480
something

00:19:44,880 --> 00:19:47,919
at the last part today we'll try to

00:19:46,480 --> 00:19:50,400
extend it

00:19:47,919 --> 00:19:53,360
and we also want to expose the ability

00:19:50,400 --> 00:19:56,240
to do vm exit on

00:19:53,360 --> 00:19:58,080
control register modifications because

00:19:56,240 --> 00:19:59,039
there's a lot of bits we want to protect

00:19:58,080 --> 00:20:02,400
here

00:19:59,039 --> 00:20:04,960
and the hardware entire amd this

00:20:02,400 --> 00:20:05,760
part if you config for example the vmcs

00:20:04,960 --> 00:20:09,039
correctly

00:20:05,760 --> 00:20:12,559
we can get the exit on for the um

00:20:09,039 --> 00:20:14,720
controller 0 or control register 4. and

00:20:12,559 --> 00:20:16,480
we want vmm to make its call whether we

00:20:14,720 --> 00:20:18,559
like the modification to go through or

00:20:16,480 --> 00:20:21,600
we should not

00:20:18,559 --> 00:20:23,600
last um this is basically support the

00:20:21,600 --> 00:20:26,000
new intel hypervisor manager

00:20:23,600 --> 00:20:27,280
linear address translation this is new

00:20:26,000 --> 00:20:31,919
hardware i don't think

00:20:27,280 --> 00:20:34,320
obviously um i hope intel or

00:20:31,919 --> 00:20:35,200
some committee members or us will work

00:20:34,320 --> 00:20:38,240
on the support

00:20:35,200 --> 00:20:38,240
for this together

00:20:38,640 --> 00:20:45,840
and for the future once we have the

00:20:41,679 --> 00:20:49,840
um the production we talk about in place

00:20:45,840 --> 00:20:52,799
we can extend this gasket module to

00:20:49,840 --> 00:20:54,240
expose apis for any kernel code to

00:20:52,799 --> 00:20:57,440
consume

00:20:54,240 --> 00:21:00,640
it can be a driver it can be a security

00:20:57,440 --> 00:21:02,799
hardening code inside the kernel so they

00:21:00,640 --> 00:21:06,159
can call the api during boot

00:21:02,799 --> 00:21:06,799
locate a memory and write to it and then

00:21:06,159 --> 00:21:10,559
mark it

00:21:06,799 --> 00:21:13,760
as read only so we will

00:21:10,559 --> 00:21:16,960
send this memory segment to the

00:21:13,760 --> 00:21:19,440
advisor at the end of boot and then we

00:21:16,960 --> 00:21:23,679
make sure those memory will never change

00:21:19,440 --> 00:21:25,919
during the entire lifetime of the vm

00:21:23,679 --> 00:21:28,320
so yeah all the kernel security and

00:21:25,919 --> 00:21:31,840
driver modules can take other advantage

00:21:28,320 --> 00:21:31,840
of these to protect themselves

00:21:32,880 --> 00:21:37,039
now let's talk about some other security

00:21:35,600 --> 00:21:38,960
considerations

00:21:37,039 --> 00:21:40,480
first of all all the protection we

00:21:38,960 --> 00:21:42,880
talked about today is built

00:21:40,480 --> 00:21:44,159
on top of keyboard if skill boot is

00:21:42,880 --> 00:21:46,720
broken um

00:21:44,159 --> 00:21:47,520
our guest agent could be changed and we

00:21:46,720 --> 00:21:51,039
cannot trust

00:21:47,520 --> 00:21:51,039
the message it's done to us

00:21:51,120 --> 00:21:54,159
so why can't we trust the keyboard in

00:21:52,720 --> 00:21:56,480
google cloud um

00:21:54,159 --> 00:21:58,720
for google cloud oh the guest program if

00:21:56,480 --> 00:22:00,559
uv runway is actually immutable

00:21:58,720 --> 00:22:03,200
we inject the gas from we are doing both

00:22:00,559 --> 00:22:06,080
time to copy it into the gas memory

00:22:03,200 --> 00:22:07,760
and so even if you manage to change the

00:22:06,080 --> 00:22:08,880
front wheel in some special way during

00:22:07,760 --> 00:22:11,120
runtime

00:22:08,880 --> 00:22:12,880
after you reboot you will get a fresh

00:22:11,120 --> 00:22:15,520
piece of firmware and

00:22:12,880 --> 00:22:16,320
will restore back to a good state a lot

00:22:15,520 --> 00:22:18,799
of

00:22:16,320 --> 00:22:19,679
firmware integrity check is actually

00:22:18,799 --> 00:22:22,720
happening

00:22:19,679 --> 00:22:23,600
outside guest we know that's critical

00:22:22,720 --> 00:22:26,559
piece of code

00:22:23,600 --> 00:22:27,679
um we want to make sure it's doing what

00:22:26,559 --> 00:22:29,919
we expect

00:22:27,679 --> 00:22:31,440
so a lot of security check signature

00:22:29,919 --> 00:22:34,080
check is happening

00:22:31,440 --> 00:22:35,760
we upload those osologic into the vmm

00:22:34,080 --> 00:22:36,799
processor it's not happening inside the

00:22:35,760 --> 00:22:38,880
guest

00:22:36,799 --> 00:22:41,520
and for important security boot

00:22:38,880 --> 00:22:43,440
variables primary keys

00:22:41,520 --> 00:22:45,600
signatures they are stored on remote

00:22:43,440 --> 00:22:49,039
server instead of your local disk

00:22:45,600 --> 00:22:52,480
so there's no way a guest can skip

00:22:49,039 --> 00:22:55,360
uv and skip our formula to modify the

00:22:52,480 --> 00:22:56,159
those variables directly one popular

00:22:55,360 --> 00:22:58,880
attack

00:22:56,159 --> 00:22:59,919
against secure boot is through system

00:22:58,880 --> 00:23:03,440
management mode

00:22:59,919 --> 00:23:03,440
for the sdm attack

00:23:04,240 --> 00:23:10,400
to reduce the attack surface

00:23:07,600 --> 00:23:11,520
and the sn smm is completely dropped

00:23:10,400 --> 00:23:14,799
from workout

00:23:11,520 --> 00:23:16,880
we don't support it at all but

00:23:14,799 --> 00:23:18,880
the protection is not perfect even if we

00:23:16,880 --> 00:23:21,120
guarantee the kernel code stays the same

00:23:18,880 --> 00:23:22,080
through the entire runtime and nothing

00:23:21,120 --> 00:23:24,799
gets executed

00:23:22,080 --> 00:23:25,360
outside this kernel code space there's

00:23:24,799 --> 00:23:27,440
still

00:23:25,360 --> 00:23:28,880
possibilities people can use something

00:23:27,440 --> 00:23:32,159
called return oriented

00:23:28,880 --> 00:23:33,520
programming drop attack and what it does

00:23:32,159 --> 00:23:37,039
is trying to find

00:23:33,520 --> 00:23:39,120
some instructions on your executable

00:23:37,039 --> 00:23:41,679
region and change them together to

00:23:39,120 --> 00:23:45,760
achieve some special goals

00:23:41,679 --> 00:23:47,679
and for example if people use swap

00:23:45,760 --> 00:23:50,400
attack to modify the corner prototype

00:23:47,679 --> 00:23:52,720
kernel page table will still break the

00:23:50,400 --> 00:23:54,720
protection because

00:23:52,720 --> 00:23:56,000
you can modify the page table

00:23:54,720 --> 00:23:58,000
translation and

00:23:56,000 --> 00:23:59,919
point the kernel code to a different

00:23:58,000 --> 00:24:03,360
memory location

00:23:59,919 --> 00:24:05,600
and if that happens that memory location

00:24:03,360 --> 00:24:08,799
is not is no longer protected by

00:24:05,600 --> 00:24:10,880
any ept or ntp so

00:24:08,799 --> 00:24:13,120
the hacker can do whatever they want

00:24:10,880 --> 00:24:17,120
there medicaid is a problem

00:24:13,120 --> 00:24:20,880
um i think knows randomization

00:24:17,120 --> 00:24:24,159
is very popular today let's make

00:24:20,880 --> 00:24:26,720
rubber attack a little bit harder and

00:24:24,159 --> 00:24:28,240
yes ongoing work for the internal

00:24:26,720 --> 00:24:31,039
control flow integrity

00:24:28,240 --> 00:24:32,000
make sure make it harder to happen or

00:24:31,039 --> 00:24:34,960
make sure it's never

00:24:32,000 --> 00:24:35,360
happened and there's hardware support

00:24:34,960 --> 00:24:37,679
like

00:24:35,360 --> 00:24:39,200
the hypervisor managed linear address

00:24:37,679 --> 00:24:39,919
based translation we talked about

00:24:39,200 --> 00:24:42,640
earlier

00:24:39,919 --> 00:24:44,240
where you can make sure the adjust base

00:24:42,640 --> 00:24:45,520
adjust space translation is happening on

00:24:44,240 --> 00:24:48,799
the hypervisor side

00:24:45,520 --> 00:24:50,960
so let's and avoid

00:24:48,799 --> 00:24:53,360
people hack this page table in some

00:24:50,960 --> 00:24:55,760
special way

00:24:53,360 --> 00:24:56,400
to summarize this presentation we are

00:24:55,760 --> 00:24:59,840
trying to

00:24:56,400 --> 00:25:01,840
propose a hypervisor based reinforced

00:24:59,840 --> 00:25:03,120
protection for gas memories and system

00:25:01,840 --> 00:25:06,640
registers

00:25:03,120 --> 00:25:08,000
and we want to also provide a parallel

00:25:06,640 --> 00:25:11,360
virtualization

00:25:08,000 --> 00:25:14,400
interface to enable and

00:25:11,360 --> 00:25:16,720
enable this in protection

00:25:14,400 --> 00:25:18,320
and we want to enable secure security by

00:25:16,720 --> 00:25:20,799
default um

00:25:18,320 --> 00:25:22,159
this happening we are proposing here is

00:25:20,799 --> 00:25:25,120
to extend the skill boot

00:25:22,159 --> 00:25:28,480
and provide runtime protection for

00:25:25,120 --> 00:25:38,640
kernel integrity

00:25:28,480 --> 00:25:38,640

YouTube URL: https://www.youtube.com/watch?v=fO5Sj2RTn4Q


