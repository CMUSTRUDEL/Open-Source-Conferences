Title: Private vs. Common: Reflection on Cross-architecture Commonality by Christian Borntraeger
Publication date: 2018-11-14
Playlist: KVM Forum 2018
Description: 
	While starting out as an x86 hypervisor, the KVM module supports a variety of architectures. Over time a split between common code and per-architecture code has evolved. This talk will reflect on history, current state and potential future improvement regarding commonality.

---

Christian Borntraeger
KVM maintainer for IBM Z
IBM

Christian Borntraeger is a software engineer at IBM Germany and is the IBM z (s390) maintainer for KVM and QEMU/KVM. He has been active in KVM since 2007.
Captions: 
	00:00:00,340 --> 00:00:02,709
[Music]

00:00:06,049 --> 00:00:11,820
my name is Kristen Bartling and I'm be

00:00:08,370 --> 00:00:14,790
the maintainer for KVM when I visit a

00:00:11,820 --> 00:00:17,730
DMZ or we know it as 290 in the

00:00:14,790 --> 00:00:20,369
gnu/linux tree and I brought together

00:00:17,730 --> 00:00:22,260
with a bigger team and in the building

00:00:20,369 --> 00:00:25,019
in Lebanon Germany and we are doing the

00:00:22,260 --> 00:00:28,800
all the load of stuff for s through 98

00:00:25,019 --> 00:00:30,660
so Linux kernel KVM GCC Lipsy all the

00:00:28,800 --> 00:00:37,140
low level stuff just from enablement and

00:00:30,660 --> 00:00:40,079
so on I work for KTM since about 2007

00:00:37,140 --> 00:00:42,329
so actually quite for a long time now I

00:00:40,079 --> 00:00:45,030
had some some breaks in between did some

00:00:42,329 --> 00:00:50,420
compiler work but I'm back with Kevin

00:00:45,030 --> 00:00:53,280
now so for a long time and this is what

00:00:50,420 --> 00:00:59,090
I'm going to do some greetings from our

00:00:53,280 --> 00:00:59,090
legal department as well warm welcome

00:00:59,449 --> 00:01:04,320
so what is the motivation of that talk

00:01:01,949 --> 00:01:08,369
as I said I'm the maintainer for KTM on

00:01:04,320 --> 00:01:10,200
s39 team and that's why mostly focus on

00:01:08,369 --> 00:01:13,770
that platform so I have to take care

00:01:10,200 --> 00:01:16,259
that Astra 90 KVM continues to work that

00:01:13,770 --> 00:01:19,320
our performance is good that we exploit

00:01:16,259 --> 00:01:23,070
new new hardware features and these kind

00:01:19,320 --> 00:01:27,390
of things at the same time I actually

00:01:23,070 --> 00:01:30,150
try to stay up to date with what's going

00:01:27,390 --> 00:01:32,520
on in KDM so whenever time allows I try

00:01:30,150 --> 00:01:36,600
to follow the work of other people's and

00:01:32,520 --> 00:01:39,450
I have quite often seen changes from

00:01:36,600 --> 00:01:41,759
from newcomers or people that working on

00:01:39,450 --> 00:01:44,820
other architectures that do specific

00:01:41,759 --> 00:01:47,970
things that were written in a way that

00:01:44,820 --> 00:01:51,450
was only working for one architecture

00:01:47,970 --> 00:01:53,549
usually Exodus six and quite often it

00:01:51,450 --> 00:01:55,079
turn out that this kind of feature would

00:01:53,549 --> 00:01:57,420
actually be useful also for other

00:01:55,079 --> 00:02:01,829
platforms like arm power or s/390

00:01:57,420 --> 00:02:04,170
so this was a motivation and I'll give

00:02:01,829 --> 00:02:06,659
some kind of history what how KTM

00:02:04,170 --> 00:02:08,520
evolved regarding multiple architectures

00:02:06,659 --> 00:02:11,310
I give some examples of good and bad

00:02:08,520 --> 00:02:13,879
things and also some market and what can

00:02:11,310 --> 00:02:13,879
we do in the future

00:02:14,569 --> 00:02:19,950
okay

00:02:16,439 --> 00:02:22,079
the first steps of kam were done in 2006

00:02:19,950 --> 00:02:26,370
by a young starter from Israel called

00:02:22,079 --> 00:02:29,129
Qumran net and it started as a device

00:02:26,370 --> 00:02:35,220
driver that was how the committee then

00:02:29,129 --> 00:02:38,220
and called it specifically for the 32

00:02:35,220 --> 00:02:39,840
and 64-bit version of Exodus 6 and the

00:02:38,220 --> 00:02:42,959
first one was actually even into the

00:02:39,840 --> 00:02:44,489
honey so they had plans to add an D

00:02:42,959 --> 00:02:48,120
support later on because at that point

00:02:44,489 --> 00:02:51,510
in time implant and Depot's provided

00:02:48,120 --> 00:02:55,049
hardware extensions to to do hardware

00:02:51,510 --> 00:02:57,540
support virtualization and by having an

00:02:55,049 --> 00:03:00,299
introvert and an AMD version that

00:02:57,540 --> 00:03:02,609
actually drove some first kind of

00:03:00,299 --> 00:03:05,549
factorization so they could already had

00:03:02,609 --> 00:03:08,970
to be prepared to to deal with two

00:03:05,549 --> 00:03:11,340
different kinds of things but still the

00:03:08,970 --> 00:03:13,980
device driver itself was very exited six

00:03:11,340 --> 00:03:16,139
specific and when you have a device

00:03:13,980 --> 00:03:18,150
driver that usually is for that device

00:03:16,139 --> 00:03:20,459
and you're not going to extend that to

00:03:18,150 --> 00:03:22,680
other devices but as it turns out the

00:03:20,459 --> 00:03:24,900
the interface of the akkadian device

00:03:22,680 --> 00:03:28,049
driver was actually be flexible enough

00:03:24,900 --> 00:03:31,919
and and generic enough to be useful for

00:03:28,049 --> 00:03:34,199
other architectures so there was

00:03:31,919 --> 00:03:36,030
interest from the Itanium fork from end

00:03:34,199 --> 00:03:37,949
levels interest from the PowerPC folks

00:03:36,030 --> 00:03:39,030
at IBM and also interest from the Astra

00:03:37,949 --> 00:03:42,209
94 so early on

00:03:39,030 --> 00:03:44,430
so the first KDM forum in 2007 and

00:03:42,209 --> 00:03:46,409
enthusing people talked about how what

00:03:44,430 --> 00:03:50,129
can they do and the decision was made to

00:03:46,409 --> 00:03:53,790
actually reflect or KDM to basically

00:03:50,129 --> 00:03:56,790
split out the common code from x86

00:03:53,790 --> 00:03:59,819
specific code was some kind of joint

00:03:56,790 --> 00:04:01,829
work and probably one of the times where

00:03:59,819 --> 00:04:03,959
the work between IBM into the boss as

00:04:01,829 --> 00:04:06,419
close as possible as I can get because

00:04:03,959 --> 00:04:08,579
uh the Itanium folks did a lot of

00:04:06,419 --> 00:04:11,129
patches and we did review them and vice

00:04:08,579 --> 00:04:13,549
versa so when you look back at these

00:04:11,129 --> 00:04:16,829
commits you see a lot of Revit bike

00:04:13,549 --> 00:04:19,049
commands from improve for our patches

00:04:16,829 --> 00:04:20,190
and vice versa and that actually it

00:04:19,049 --> 00:04:22,919
worked quite well I mean look at the

00:04:20,190 --> 00:04:26,219
diffs that I mean we had about 50 50

00:04:22,919 --> 00:04:26,530
commits overall of refactoring so we we

00:04:26,219 --> 00:04:29,470
did

00:04:26,530 --> 00:04:31,330
did that in in one big chunk the goal

00:04:29,470 --> 00:04:34,780
was to keep the whole thing running all

00:04:31,330 --> 00:04:38,170
the time so we had split that in around

00:04:34,780 --> 00:04:40,480
50 different commits that split KVM

00:04:38,170 --> 00:04:44,500
piece by piece into a common part and

00:04:40,480 --> 00:04:46,750
architecture part and about half a year

00:04:44,500 --> 00:04:48,730
later this is a screen full of a blog

00:04:46,750 --> 00:04:50,520
post from our vacuity where he compared

00:04:48,730 --> 00:04:53,890
the code size of different architectures

00:04:50,520 --> 00:04:56,140
KDM was basically everywhere and only

00:04:53,890 --> 00:04:58,720
the arm and nips Fogg might disagree

00:04:56,140 --> 00:05:02,980
here but back then there was actually no

00:04:58,720 --> 00:05:09,760
hardware support in in in arm or MIPS to

00:05:02,980 --> 00:05:12,160
run a virtualization and in fact it was

00:05:09,760 --> 00:05:14,590
actually also true for PowerPC because

00:05:12,160 --> 00:05:17,740
if the first Power PC port was not for

00:05:14,590 --> 00:05:20,680
the for the big IBM main the IBM systems

00:05:17,740 --> 00:05:23,350
like power 7 8 or 9 but it was for the

00:05:20,680 --> 00:05:25,960
tiny little PowerPC 440 which was an

00:05:23,350 --> 00:05:28,000
embedded controller so the Power PC port

00:05:25,960 --> 00:05:30,970
was was purely a entrapping emulated

00:05:28,000 --> 00:05:35,500
version of KVM with no hardware support

00:05:30,970 --> 00:05:37,750
at all interestingly enough okay so

00:05:35,500 --> 00:05:39,970
let's now look into components I mean

00:05:37,750 --> 00:05:43,390
this was mostly kernel let's also look

00:05:39,970 --> 00:05:45,970
into what what other components do we

00:05:43,390 --> 00:05:49,090
have in a VMware we actually could share

00:05:45,970 --> 00:05:51,940
code as I said the Deucalion kernel

00:05:49,090 --> 00:05:54,100
module module or the KTM driver is

00:05:51,940 --> 00:05:57,669
actually the closest one to the hardware

00:05:54,100 --> 00:06:00,100
so we would expect that there's the

00:05:57,669 --> 00:06:04,390
least amount of commonality between

00:06:00,100 --> 00:06:07,000
different architectures and my

00:06:04,390 --> 00:06:10,570
expectation is that if we go along next

00:06:07,000 --> 00:06:12,669
step is basically the km user space but

00:06:10,570 --> 00:06:15,640
it's also relatively close to the

00:06:12,669 --> 00:06:19,180
hardware but it already uses an abstract

00:06:15,640 --> 00:06:21,160
interface system calls basically so it

00:06:19,180 --> 00:06:25,780
will not be worse it should be better in

00:06:21,160 --> 00:06:29,650
terms of common code usage and when you

00:06:25,780 --> 00:06:32,020
then look at levert that is even farther

00:06:29,650 --> 00:06:33,820
away so it also uses system core

00:06:32,020 --> 00:06:36,130
interfaces but the interface to the

00:06:33,820 --> 00:06:39,550
virtualization part is then done while

00:06:36,130 --> 00:06:41,520
the qnp interface of lazin based and

00:06:39,550 --> 00:06:45,090
you will expect that the amount of

00:06:41,520 --> 00:06:47,260
shared code is actually even higher and

00:06:45,090 --> 00:06:50,710
when you look beyond that

00:06:47,260 --> 00:06:53,440
OpenStack road manager ref all these

00:06:50,710 --> 00:06:58,270
kind of management stacks on top of

00:06:53,440 --> 00:07:02,110
libvirt things are are getting more

00:06:58,270 --> 00:07:07,240
common even more so I did a quick check

00:07:02,110 --> 00:07:10,090
comparing qmu and an internal the charts

00:07:07,240 --> 00:07:12,190
are a bit roughly the actual lying I

00:07:10,090 --> 00:07:14,440
mean I only checked the files that have

00:07:12,190 --> 00:07:16,480
KVM in the file name so I did not

00:07:14,440 --> 00:07:19,660
consider the memory management that is

00:07:16,480 --> 00:07:22,330
actually common and KVM heavily relies

00:07:19,660 --> 00:07:23,890
on building upon the host scheduler and

00:07:22,330 --> 00:07:28,150
building upon the hosts memory

00:07:23,890 --> 00:07:30,430
management so just look at the KTM code

00:07:28,150 --> 00:07:32,710
here and as you can see the nicola is

00:07:30,430 --> 00:07:35,920
actually pretty distributed across

00:07:32,710 --> 00:07:40,180
architectures with pretty small piece of

00:07:35,920 --> 00:07:44,020
common code when you look at GM you hear

00:07:40,180 --> 00:07:46,690
these things are actually much better so

00:07:44,020 --> 00:07:48,550
you have a much bigger range the blue

00:07:46,690 --> 00:07:51,220
one is especially the common code and

00:07:48,550 --> 00:07:53,560
the gray ones are the different

00:07:51,220 --> 00:07:56,080
architectures what I find interesting is

00:07:53,560 --> 00:07:57,910
that when you remember the blog post

00:07:56,080 --> 00:08:02,230
from our activity there have been large

00:07:57,910 --> 00:08:04,630
differences among the architectures but

00:08:02,230 --> 00:08:08,520
in Kenya turns out that these ties of

00:08:04,630 --> 00:08:11,410
the KTM related files are actually

00:08:08,520 --> 00:08:14,110
pretty similar that was pretty

00:08:11,410 --> 00:08:16,780
unexpected for me I do not have charts

00:08:14,110 --> 00:08:20,200
for the bird because in libvirt there

00:08:16,780 --> 00:08:22,900
are actually no real files specifically

00:08:20,200 --> 00:08:25,630
for an architecture so you have code

00:08:22,900 --> 00:08:28,120
that basically knows different kinds of

00:08:25,630 --> 00:08:29,860
devices but it handles basically all of

00:08:28,120 --> 00:08:32,170
them so you have code that for example

00:08:29,860 --> 00:08:35,560
deals with whatever Scotty and that code

00:08:32,170 --> 00:08:37,000
knows about Verto PCI and whatever CCW

00:08:35,560 --> 00:08:38,500
different kind of things but it's all

00:08:37,000 --> 00:08:41,560
the same code so it's pretty hard to

00:08:38,500 --> 00:08:45,430
actually just see how much common code

00:08:41,560 --> 00:08:47,110
is here but the fact that there is no no

00:08:45,430 --> 00:08:49,450
separation on the file level actually

00:08:47,110 --> 00:08:51,460
indicates that things are even better in

00:08:49,450 --> 00:08:54,130
the vert regarding commonality

00:08:51,460 --> 00:08:57,010
but let's go back to the kernel I mean I

00:08:54,130 --> 00:08:59,320
was actually shocked when I saw that

00:08:57,010 --> 00:09:02,290
slide because we are talking about less

00:08:59,320 --> 00:09:05,920
than four percent commonality when you

00:09:02,290 --> 00:09:11,140
just count the lines of code and that

00:09:05,920 --> 00:09:11,770
looked pretty bad to me so um I looked a

00:09:11,140 --> 00:09:14,170
bit closer

00:09:11,770 --> 00:09:17,080
um let's first start with your

00:09:14,170 --> 00:09:19,990
architectures I mean the the biggest

00:09:17,080 --> 00:09:21,430
architecture is obviously x86 and there

00:09:19,990 --> 00:09:24,399
are several reasons for that I mean

00:09:21,430 --> 00:09:27,279
actually 6km still supports hardware

00:09:24,399 --> 00:09:29,709
without nest paging it supports

00:09:27,279 --> 00:09:35,760
basically all kind of addressing modes

00:09:29,709 --> 00:09:40,510
64 but it's 32-bit it has a lot of

00:09:35,760 --> 00:09:44,230
emulation to run all kinds of windows so

00:09:40,510 --> 00:09:47,350
the KTM part of x86 is pretty much

00:09:44,230 --> 00:09:51,820
complete you can run almost any Exodus

00:09:47,350 --> 00:09:54,810
six capable operating system the second

00:09:51,820 --> 00:09:57,779
biggest architecture is PowerPC here is

00:09:54,810 --> 00:10:01,209
also something to consider

00:09:57,779 --> 00:10:03,910
PowerPC still contains the the old code

00:10:01,209 --> 00:10:07,540
from back then that is based on the

00:10:03,910 --> 00:10:09,339
PowerPC 440 it is now called a 500 so

00:10:07,540 --> 00:10:12,580
freescale basically took the original

00:10:09,339 --> 00:10:14,500
code and and modified that to also be

00:10:12,580 --> 00:10:17,650
able to run there and Barrett course and

00:10:14,500 --> 00:10:22,029
then there's a book 3s which is the big

00:10:17,650 --> 00:10:23,740
IBM systems power 8 or 9 and so on and

00:10:22,029 --> 00:10:26,320
then mips s/390

00:10:23,740 --> 00:10:26,950
arm are basically all in the same

00:10:26,320 --> 00:10:29,200
ballpark

00:10:26,950 --> 00:10:31,420
the interesting part ways with arm is

00:10:29,200 --> 00:10:34,650
that actually to certif of the arm code

00:10:31,420 --> 00:10:37,420
is about the interrupt controller so and

00:10:34,650 --> 00:10:39,579
quite frankly this is a code I'd

00:10:37,420 --> 00:10:44,350
necessarily do not want to share as you

00:10:39,579 --> 00:10:47,079
90 for obvious reasons but again we had

00:10:44,350 --> 00:10:49,390
less than 4% commonality so my question

00:10:47,079 --> 00:10:52,750
was did it actually get better over time

00:10:49,390 --> 00:10:54,910
so I checked the last releases and it

00:10:52,750 --> 00:10:59,079
turns out no it did not get better in

00:10:54,910 --> 00:11:01,470
fact the blue line here is the amount of

00:10:59,079 --> 00:11:04,340
code for that are common across all

00:11:01,470 --> 00:11:06,529
architectures and the red line is the

00:11:04,340 --> 00:11:08,750
within the architecture files and as you

00:11:06,529 --> 00:11:11,360
can see the architecture specific code

00:11:08,750 --> 00:11:13,880
is growing in a linear fashion but it's

00:11:11,360 --> 00:11:17,570
growing pretty heavily while the common

00:11:13,880 --> 00:11:22,460
code almost stays the same we have some

00:11:17,570 --> 00:11:24,170
we have some drums in here as you can

00:11:22,460 --> 00:11:28,040
see around I think three eight three

00:11:24,170 --> 00:11:29,440
three nine arm and MIPS were added some

00:11:28,040 --> 00:11:32,690
one later

00:11:29,440 --> 00:11:34,279
Itanium was removed this is something I

00:11:32,690 --> 00:11:35,930
hear from several kernel people that

00:11:34,279 --> 00:11:39,470
they actually would like to remove

00:11:35,930 --> 00:11:42,110
Itanium also beyond carry em but there

00:11:39,470 --> 00:11:47,600
are that seem to be uses so it's not

00:11:42,110 --> 00:11:50,710
that easy interesting enough the removal

00:11:47,600 --> 00:11:54,560
of Itanium actually led to a case where

00:11:50,710 --> 00:11:57,800
the common code part was actually

00:11:54,560 --> 00:12:00,140
reduced again there was code for device

00:11:57,800 --> 00:12:02,900
assignment is the assigning PCI devices

00:12:00,140 --> 00:12:06,020
to a guest and that was used for Itanium

00:12:02,900 --> 00:12:08,630
in x86 and after the removal of Itanium

00:12:06,020 --> 00:12:10,160
it was basically only used for x86 so we

00:12:08,630 --> 00:12:15,020
moved that to the common to the

00:12:10,160 --> 00:12:17,420
architecture code when I first saw that

00:12:15,020 --> 00:12:20,330
slot I found that a bit depressing so

00:12:17,420 --> 00:12:23,810
when I looked further so why is it that

00:12:20,330 --> 00:12:26,360
way and there are actually three kinds

00:12:23,810 --> 00:12:29,270
of things in in the Akkadian kernel

00:12:26,360 --> 00:12:31,910
module there are things which are really

00:12:29,270 --> 00:12:34,780
common across all architectures and

00:12:31,910 --> 00:12:37,490
that's basically everything that is

00:12:34,780 --> 00:12:41,089
related to user space interfaces the

00:12:37,490 --> 00:12:43,330
system code cio controls debug FS these

00:12:41,089 --> 00:12:46,040
kind of things and codes that are

00:12:43,330 --> 00:12:48,140
related to that so the lifecycle

00:12:46,040 --> 00:12:49,910
management of CPUs or the lifecycle

00:12:48,140 --> 00:12:52,160
management of guest this is basically

00:12:49,910 --> 00:12:54,380
one of the the most common our controls

00:12:52,160 --> 00:12:57,050
create the MV CPU and so on and

00:12:54,380 --> 00:13:01,220
therefore these things are obviously

00:12:57,050 --> 00:13:03,170
common then there are things that are

00:13:01,220 --> 00:13:05,060
partially common where there is some

00:13:03,170 --> 00:13:10,540
common code with some architecture

00:13:05,060 --> 00:13:13,310
back-end and this class is more of the

00:13:10,540 --> 00:13:15,589
things that have some kind of internal

00:13:13,310 --> 00:13:17,850
state attached to it either guest state

00:13:15,589 --> 00:13:21,360
or host said

00:13:17,850 --> 00:13:23,250
these things share a lot of common code

00:13:21,360 --> 00:13:24,060
but you need some kind of architectural

00:13:23,250 --> 00:13:26,790
knowledge in there

00:13:24,060 --> 00:13:30,000
and the biggest part is then the

00:13:26,790 --> 00:13:32,279
architectural code and obviously here

00:13:30,000 --> 00:13:35,220
are things which are really hard to

00:13:32,279 --> 00:13:37,649
share you usually have to set up control

00:13:35,220 --> 00:13:39,540
blocks and KVM to drive the hardware and

00:13:37,649 --> 00:13:41,490
these control blocks are Hardware

00:13:39,540 --> 00:13:44,250
specific there's no way of ever being

00:13:41,490 --> 00:13:46,230
able to share those nested

00:13:44,250 --> 00:13:48,240
virtualization is obviously very

00:13:46,230 --> 00:13:51,470
Hardware specific there is no way of

00:13:48,240 --> 00:13:54,480
sharing these the emulation of the

00:13:51,470 --> 00:13:56,639
memory management unit it's pretty much

00:13:54,480 --> 00:14:00,180
hotter specific and so on and also the

00:13:56,639 --> 00:14:02,069
the counters of KDM stud we have two or

00:14:00,180 --> 00:14:05,310
three common ones but the big ones are

00:14:02,069 --> 00:14:08,339
really hard to specific and basically

00:14:05,310 --> 00:14:10,259
any hardware enablement I mean that's

00:14:08,339 --> 00:14:13,050
what would we do when you look at arm at

00:14:10,259 --> 00:14:15,870
IBM at Inter when we provide patches we

00:14:13,050 --> 00:14:18,199
we often try to get our CPU features

00:14:15,870 --> 00:14:22,589
enabled and of course these are

00:14:18,199 --> 00:14:24,509
architecture specific but still wouldn't

00:14:22,589 --> 00:14:26,220
it be nice to actually identify these

00:14:24,509 --> 00:14:29,220
things that could be shared across

00:14:26,220 --> 00:14:31,880
architectures and why didn't it work out

00:14:29,220 --> 00:14:36,089
so well so what kind of problems did we

00:14:31,880 --> 00:14:38,310
did we had let me give one example here

00:14:36,089 --> 00:14:42,720
there is a feature called hard calling

00:14:38,310 --> 00:14:46,350
and that feature is part of of KVM and

00:14:42,720 --> 00:14:48,689
what it does is it optimizes the

00:14:46,350 --> 00:14:53,339
performance for workload where the guest

00:14:48,689 --> 00:15:02,100
CPU is basically stopped for a short

00:14:53,339 --> 00:15:04,279
period of time and the pauling the

00:15:02,100 --> 00:15:06,990
reason for calling is actually that

00:15:04,279 --> 00:15:10,160
quite often when a CPU goes to sleep

00:15:06,990 --> 00:15:16,259
it is woken up again pretty quickly and

00:15:10,160 --> 00:15:17,850
- - and that has a lot of latency when

00:15:16,259 --> 00:15:19,920
and the guests of your sleeves and the

00:15:17,850 --> 00:15:22,050
host puts it to sleep as well it has to

00:15:19,920 --> 00:15:24,990
wake up again very quickly the latency

00:15:22,050 --> 00:15:27,510
is pretty large and to avoid that kam

00:15:24,990 --> 00:15:31,170
busily spins a bit after the CPU goes to

00:15:27,510 --> 00:15:33,269
sleep okay

00:15:31,170 --> 00:15:35,339
turns out that this does not work

00:15:33,269 --> 00:15:37,709
overall when I first tried it on Astra

00:15:35,339 --> 00:15:39,570
90 I basically lots of guest CPUs

00:15:37,709 --> 00:15:43,470
running a hundred percent all the time

00:15:39,570 --> 00:15:44,940
the problem here was that on s/390 own

00:15:43,470 --> 00:15:48,000
interrupts are floating interrupts so

00:15:44,940 --> 00:15:50,339
they are pending on every CPU so the the

00:15:48,000 --> 00:15:52,680
logic in that code actually decided oh

00:15:50,339 --> 00:15:54,899
the polling was successful and decided

00:15:52,680 --> 00:15:56,370
that on all CPUs even though the

00:15:54,899 --> 00:16:00,389
interrupt was only a little bit and at

00:15:56,370 --> 00:16:03,300
one CPU we could actually fix that we

00:16:00,389 --> 00:16:05,959
had architectural callbacks and so

00:16:03,300 --> 00:16:05,959
things are fine

00:16:06,269 --> 00:16:11,699
another thing power actually has a

00:16:09,449 --> 00:16:14,160
private copy of of how calling because

00:16:11,699 --> 00:16:17,310
it turned out to be actually hard to

00:16:14,160 --> 00:16:19,290
have an architecture independent way of

00:16:17,310 --> 00:16:22,680
how polling for the way how power

00:16:19,290 --> 00:16:26,459
managers is it's as antes so its threats

00:16:22,680 --> 00:16:30,420
so here's a case where we actually were

00:16:26,459 --> 00:16:32,279
not able to to to use a common code and

00:16:30,420 --> 00:16:34,860
power had to have its own private copy

00:16:32,279 --> 00:16:38,060
because making common would have made

00:16:34,860 --> 00:16:41,160
the code more complicated what is about

00:16:38,060 --> 00:16:43,260
architecture review and when you I just

00:16:41,160 --> 00:16:46,220
grabbed for a refuge by and different

00:16:43,260 --> 00:16:49,740
architecture codes and it turns out that

00:16:46,220 --> 00:16:52,470
we are not in only not that good at

00:16:49,740 --> 00:16:55,110
sharing code we are also not that good

00:16:52,470 --> 00:16:57,420
at doing cross architecture review most

00:16:55,110 --> 00:17:00,300
of these reviews are pretty much inside

00:16:57,420 --> 00:17:02,970
a silo which responding exception Sankey

00:17:00,300 --> 00:17:05,730
redhead for doing cross architecture nu

00:17:02,970 --> 00:17:10,290
but other than that this is really

00:17:05,730 --> 00:17:13,290
inside of silo so we could actually do

00:17:10,290 --> 00:17:15,600
more cross team education and when you

00:17:13,290 --> 00:17:18,780
look at KTM forum here these things work

00:17:15,600 --> 00:17:21,390
pretty well we had lots of talks in the

00:17:18,780 --> 00:17:26,250
in the past from AMD from from power

00:17:21,390 --> 00:17:29,940
from arm from ender from s/390 we have

00:17:26,250 --> 00:17:31,860
lots of talks this time so we could use

00:17:29,940 --> 00:17:33,210
that chance to actually talk more to

00:17:31,860 --> 00:17:35,750
each other and I actually want to

00:17:33,210 --> 00:17:38,809
propose a buff session about that topic

00:17:35,750 --> 00:17:41,490
what can we do to improve architecture

00:17:38,809 --> 00:17:43,570
similarity or maybe lost exchange what

00:17:41,490 --> 00:17:46,720
kind of features do we have

00:17:43,570 --> 00:17:49,659
can we basically talk to each other and

00:17:46,720 --> 00:17:54,580
get get something out of the the other

00:17:49,659 --> 00:17:55,629
architectures get some ideas but not not

00:17:54,580 --> 00:17:57,879
everything is bad

00:17:55,629 --> 00:18:01,149
there are also successful changes for

00:17:57,879 --> 00:18:04,389
example time accounting as you might

00:18:01,149 --> 00:18:09,970
know you not only have now a user and

00:18:04,389 --> 00:18:13,359
system time you also have now guess time

00:18:09,970 --> 00:18:15,309
that is measured for for you any

00:18:13,359 --> 00:18:18,129
processor so you can directly see is

00:18:15,309 --> 00:18:21,279
that CPU spending time in the guest or

00:18:18,129 --> 00:18:23,440
in house doing work for the guest

00:18:21,279 --> 00:18:26,289
so I've here an output from from the

00:18:23,440 --> 00:18:28,149
start which shows some some kind of gas

00:18:26,289 --> 00:18:30,039
percentage and this color is actually

00:18:28,149 --> 00:18:32,409
pretty generic in hand it's all kind of

00:18:30,039 --> 00:18:34,479
cases with whispered CPU account in

00:18:32,409 --> 00:18:36,849
generic word CPU accounting for power

00:18:34,479 --> 00:18:38,649
and ezra 90 perhaps for the no hurts

00:18:36,849 --> 00:18:42,580
case so this is really something that

00:18:38,649 --> 00:18:44,950
seems to be quite about satsang is when

00:18:42,580 --> 00:18:46,570
this was introduced proc PS top was

00:18:44,950 --> 00:18:49,419
still maintained by a maintainer that

00:18:46,570 --> 00:18:52,629
was not very responsive so there is no

00:18:49,419 --> 00:18:54,879
support for that in top yet now that we

00:18:52,629 --> 00:19:00,099
have property s ng we might actually

00:18:54,879 --> 00:19:04,509
follow up on that again other things

00:19:00,099 --> 00:19:06,279
that are good is sharing ideas if you

00:19:04,509 --> 00:19:08,169
know me have seen my presentation two

00:19:06,279 --> 00:19:10,570
years ago one of my hobbies is to

00:19:08,169 --> 00:19:12,970
optimize the guest entry exit times so I

00:19:10,570 --> 00:19:15,789
try to squeeze a lot of things and one

00:19:12,970 --> 00:19:18,249
of the things I have done was to put out

00:19:15,789 --> 00:19:22,869
the loading and reloading of the FPU

00:19:18,249 --> 00:19:25,720
registers more and more far out of the

00:19:22,869 --> 00:19:28,869
current so when you first started we did

00:19:25,720 --> 00:19:33,129
the loading and reloading of FDU at

00:19:28,869 --> 00:19:35,049
guest entry and exit then we moved that

00:19:33,129 --> 00:19:37,720
out to VC B you couldn't get so

00:19:35,049 --> 00:19:43,239
basically on rescheduling and and going

00:19:37,720 --> 00:19:45,099
out of the KDM and finally I actually

00:19:43,239 --> 00:19:48,580
even put even further into the i/o

00:19:45,099 --> 00:19:50,859
control pass so I only load the floating

00:19:48,580 --> 00:19:53,769
point register basically when going into

00:19:50,859 --> 00:19:55,269
KTM and going out from carrier and last

00:19:53,769 --> 00:19:57,160
year I talked to Rick funny about that

00:19:55,269 --> 00:19:59,350
he liked that idea so

00:19:57,160 --> 00:20:03,190
he did the same for x86 so we can

00:19:59,350 --> 00:20:05,680
actually share ideas another thing as

00:20:03,190 --> 00:20:08,920
entradas page faults this is something

00:20:05,680 --> 00:20:11,590
that IBM had for quite a long time on

00:20:08,920 --> 00:20:14,230
with CBM and we tried to implement the

00:20:11,590 --> 00:20:16,270
same interface with KDM but meanwhile I

00:20:14,230 --> 00:20:20,320
actually six had implemented a similar

00:20:16,270 --> 00:20:22,990
scheme called as a PF and when we sent

00:20:20,320 --> 00:20:24,880
out the patch of our interface Adi

00:20:22,990 --> 00:20:27,130
basically asked with the only right

00:20:24,880 --> 00:20:29,530
question this is actually duplicating

00:20:27,130 --> 00:20:31,810
code and yes it did and we were able by

00:20:29,530 --> 00:20:36,730
doing some kind of small refactoring to

00:20:31,810 --> 00:20:39,040
riu see the other code and last thing I

00:20:36,730 --> 00:20:42,330
want to talk about this is an idea that

00:20:39,040 --> 00:20:48,100
did not yet worked out quite fine

00:20:42,330 --> 00:20:50,980
we had guest patron ting since 2005 on a

00:20:48,100 --> 00:20:53,730
DMZ and there have been numerous tries

00:20:50,980 --> 00:20:57,520
to also have gasp a 20 on actually six

00:20:53,730 --> 00:21:00,970
there's a talk about that I think took

00:20:57,520 --> 00:21:03,670
Friday and we I think we have to see if

00:21:00,970 --> 00:21:05,740
we can actually make use of of some

00:21:03,670 --> 00:21:08,440
commonality here if that will never be

00:21:05,740 --> 00:21:10,240
common but you see my point there are

00:21:08,440 --> 00:21:12,610
several things where different

00:21:10,240 --> 00:21:17,230
architectures work on similar things at

00:21:12,610 --> 00:21:18,610
the same time okay

00:21:17,230 --> 00:21:23,290
last but not least I want to talk about

00:21:18,610 --> 00:21:25,150
interfaces oh sorry mr. quick when what

00:21:23,290 --> 00:21:30,070
IO was first introduced it was basically

00:21:25,150 --> 00:21:32,290
a very generic interface and so you

00:21:30,070 --> 00:21:36,220
could actually implement weather over a

00:21:32,290 --> 00:21:38,770
serial line and these kind of things as

00:21:36,220 --> 00:21:43,060
I put in our pigeon carriers if you want

00:21:38,770 --> 00:21:45,130
to have that but sooner or later go so

00:21:43,060 --> 00:21:48,220
sorry we need a spec and during specking

00:21:45,130 --> 00:21:51,580
of it was too started to do it with a

00:21:48,220 --> 00:21:53,800
PCI interface because it is much easier

00:21:51,580 --> 00:21:58,210
to add a PCI driver to Windows and then

00:21:53,800 --> 00:22:01,980
to add a new bus type problem was as 290

00:21:58,210 --> 00:22:05,950
had no PCI back then so we then actually

00:22:01,980 --> 00:22:09,400
discussed this and provided our our own

00:22:05,950 --> 00:22:10,960
back-end still reusing most of the code

00:22:09,400 --> 00:22:14,080
but we now have

00:22:10,960 --> 00:22:16,029
different interface into verow does it

00:22:14,080 --> 00:22:19,059
cause any problems and and yes it does

00:22:16,029 --> 00:22:21,880
yeah I have three examples here it's

00:22:19,059 --> 00:22:25,299
really blurred commits the same is

00:22:21,880 --> 00:22:27,070
actually also true for Keanu the first

00:22:25,299 --> 00:22:30,490
comment basically added murder was

00:22:27,070 --> 00:22:32,289
scheduled support in libvirt only if I

00:22:30,490 --> 00:22:34,690
were a PCI so it didn't work for Astra

00:22:32,289 --> 00:22:36,730
90 we realized that a bit later so we

00:22:34,690 --> 00:22:39,279
added further opus the world of CCW

00:22:36,730 --> 00:22:41,470
support in leopard to have the same on

00:22:39,279 --> 00:22:43,840
Astro 90 and some years later somebody

00:22:41,470 --> 00:22:45,850
realized okay we have actually a lot of

00:22:43,840 --> 00:22:48,460
code duplicated here we can actually

00:22:45,850 --> 00:22:51,669
fold it together so by having multiple

00:22:48,460 --> 00:22:53,590
interfaces for the same common code you

00:22:51,669 --> 00:22:58,960
still have the danger of actually

00:22:53,590 --> 00:23:01,840
getting Singh's duplicated and we have

00:22:58,960 --> 00:23:04,270
to pay attention here okay c2

00:23:01,840 --> 00:23:06,039
development I just want to show two

00:23:04,270 --> 00:23:08,909
things that happened this this week and

00:23:06,039 --> 00:23:13,630
last week there was a patch on the list

00:23:08,909 --> 00:23:15,520
introducing an interface under this

00:23:13,630 --> 00:23:18,250
hypervisor and the good Singlish

00:23:15,520 --> 00:23:21,100
dispatches it tries it tried to do an

00:23:18,250 --> 00:23:25,090
interface in the same fashion as it was

00:23:21,100 --> 00:23:25,600
available understand so that is really a

00:23:25,090 --> 00:23:27,549
good thing

00:23:25,600 --> 00:23:29,409
somebody tried to have the same

00:23:27,549 --> 00:23:30,789
interface on different hypervisors the

00:23:29,409 --> 00:23:34,899
bad thing is that the whole code was

00:23:30,789 --> 00:23:38,200
fully x86 specific but as it turns out

00:23:34,899 --> 00:23:40,750
it should be relatively easy to to

00:23:38,200 --> 00:23:42,610
actually get that code in a fashion that

00:23:40,750 --> 00:23:44,200
we can use it on our architecture so

00:23:42,610 --> 00:23:45,760
having the same interface on our

00:23:44,200 --> 00:23:51,549
architectures would be really a good

00:23:45,760 --> 00:23:54,429
thing another interface that was coming

00:23:51,549 --> 00:23:57,429
along just this week we only enforcement

00:23:54,429 --> 00:23:59,169
so that the guests can basically harden

00:23:57,429 --> 00:24:03,539
itself by telling the hosts please make

00:23:59,169 --> 00:24:06,340
that page we only and that is also

00:24:03,539 --> 00:24:09,039
exodus take specific I have no idea yet

00:24:06,340 --> 00:24:11,470
if we can make that cross architecture

00:24:09,039 --> 00:24:14,190
but at least we could try and there's a

00:24:11,470 --> 00:24:17,440
steady flow of such kind of changes and

00:24:14,190 --> 00:24:19,919
that brings me to the to the summary we

00:24:17,440 --> 00:24:23,470
could really try to improve

00:24:19,919 --> 00:24:25,479
discussion among the architecture team

00:24:23,470 --> 00:24:27,849
and for everybody else please do not

00:24:25,479 --> 00:24:29,470
assume everything is actually six you

00:24:27,849 --> 00:24:31,269
might know armed but there are even more

00:24:29,470 --> 00:24:34,570
less power there's MIPS there's s

00:24:31,269 --> 00:24:36,639
Trinity and if done right can actually

00:24:34,570 --> 00:24:39,460
be shared with other hypervisors like

00:24:36,639 --> 00:24:42,669
sin or maybe we can do some interface

00:24:39,460 --> 00:24:45,059
that look like PowerVM or zvm where it

00:24:42,669 --> 00:24:47,950
makes sense why not but at the same time

00:24:45,059 --> 00:24:49,869
sometimes sharing too much hurt so it

00:24:47,950 --> 00:24:51,970
will not be possible to share everything

00:24:49,869 --> 00:24:54,309
as you have seen it was a hard calling

00:24:51,970 --> 00:24:58,749
code so if it doesn't work out then it's

00:24:54,309 --> 00:25:01,029
fine to have non shared code and if

00:24:58,749 --> 00:25:03,539
you're interested in that topic please

00:25:01,029 --> 00:25:06,999
see my offset and I will film that later

00:25:03,539 --> 00:25:09,639
time is running out and so thank you

00:25:06,999 --> 00:25:10,350
very much for your attention and have a

00:25:09,639 --> 00:25:16,410
nice

00:25:10,350 --> 00:25:33,850
[Applause]

00:25:16,410 --> 00:25:36,640
other questions for example if I am

00:25:33,850 --> 00:25:38,950
looking at the V fi all stuff we have we

00:25:36,640 --> 00:25:41,140
have a PCI which was mostly cosmetic

00:25:38,950 --> 00:25:44,320
sure but they are also architecture

00:25:41,140 --> 00:25:47,470
specific implementations like CCW or so

00:25:44,320 --> 00:25:49,360
on and so on and you also should

00:25:47,470 --> 00:25:52,150
consider if you are doing some VF i/o

00:25:49,360 --> 00:25:55,270
work that you may have not only we have

00:25:52,150 --> 00:25:57,850
a PCI but other stuff which is maybe a

00:25:55,270 --> 00:26:00,940
bit strange sometimes it will be hard to

00:25:57,850 --> 00:26:02,500
accommodate those other weird

00:26:00,940 --> 00:26:04,660
implementations if you are doing new

00:26:02,500 --> 00:26:09,309
feature but it's really good to keep it

00:26:04,660 --> 00:26:11,440
in mind that they exist right I can only

00:26:09,309 --> 00:26:13,090
agree to that when time is running out

00:26:11,440 --> 00:26:14,679
but we had a panel session afterwards so

00:26:13,090 --> 00:26:20,800
you might just stick in the question in

00:26:14,679 --> 00:26:23,070
there or just please contact me on the

00:26:20,800 --> 00:26:23,070
floor

00:26:31,110 --> 00:26:41,900
[Applause]

00:26:35,670 --> 00:26:41,900

YouTube URL: https://www.youtube.com/watch?v=VWlg1Z5RvS4


