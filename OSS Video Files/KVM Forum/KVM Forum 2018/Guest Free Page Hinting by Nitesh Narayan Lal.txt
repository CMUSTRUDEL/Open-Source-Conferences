Title: Guest Free Page Hinting by Nitesh Narayan Lal
Publication date: 2018-11-17
Playlist: KVM Forum 2018
Description: 
	KVM guest suffers a major setback when it comes to freeing the unused memory. With the current implementation, when a guest frees certain memory chunk its availability for reuse is never communicated back to the host. Due to which the host fails to reclaim the memory freed by the guest for any other purpose. This talk presents the idea of guest free page hinting for efficiently handing freed memory between the guest and the host. This presentation also briefly covers memory ballooning and its pros and cons compared to this approach, the current design, challenges, performance, and possible improvement areas.

---

Nitesh Narayan Lal
Software Engineer
Red Hat Inc

Nitesh is a Software Engineer in the Virtualization team at Red Hat. He is currently working on projects related to memory management and Fuzzers. He likes to research and read about latest security breaches, and breakthroughs.
Nitesh first presented a talk on KVM & Virtio Introduction in 2013 at Fedora Flock.
Captions: 
	00:00:01,040 --> 00:00:09,240
[Music]

00:00:05,450 --> 00:00:12,179
hello everyone my name is Nitish Nandlal

00:00:09,240 --> 00:00:16,320
I'm working as a software engineer with

00:00:12,179 --> 00:00:18,480
Red Hat and I'll be talking about gets

00:00:16,320 --> 00:00:24,420
free painting so I've been working with

00:00:18,480 --> 00:00:26,609
this since last year and let's get into

00:00:24,420 --> 00:00:29,060
this so this is how the agenda looks

00:00:26,609 --> 00:00:32,309
like I'll talk about what is the issue

00:00:29,060 --> 00:00:35,670
which we are trying to solve by gas free

00:00:32,309 --> 00:00:37,440
painting what is our objective at the

00:00:35,670 --> 00:00:41,070
end of the day what we want to achieve

00:00:37,440 --> 00:00:42,960
with gas free page hunting and how the

00:00:41,070 --> 00:00:47,070
India and how the implementation looks

00:00:42,960 --> 00:00:48,960
like at this point of time and once we

00:00:47,070 --> 00:00:55,469
are done with that we'll have time for

00:00:48,960 --> 00:00:59,219
questions and suggestions so what's the

00:00:55,469 --> 00:01:02,760
issue looks like so I have a host I have

00:00:59,219 --> 00:01:06,150
three VMs running on top of it let's say

00:01:02,760 --> 00:01:08,729
BM one VM to VM three vm 1 you was using

00:01:06,150 --> 00:01:11,159
a certain amount of memory at certain

00:01:08,729 --> 00:01:13,530
point of time after which it freed a

00:01:11,159 --> 00:01:16,710
little bit of memory which it was using

00:01:13,530 --> 00:01:19,740
earlier it's the same case with VM 2

00:01:16,710 --> 00:01:22,740
it's the same case with VM 3 so this is

00:01:19,740 --> 00:01:25,110
how it looks like at this point BM one

00:01:22,740 --> 00:01:27,630
VM to VM 3 has certain amount of free

00:01:25,110 --> 00:01:32,250
memory with each of them

00:01:27,630 --> 00:01:36,270
now the problem arises when my host runs

00:01:32,250 --> 00:01:38,520
out of memory now ideally each VM should

00:01:36,270 --> 00:01:40,470
report that Pirtle free memory back to

00:01:38,520 --> 00:01:42,720
the host and host should be able it

00:01:40,470 --> 00:01:44,790
should be in a position to use that

00:01:42,720 --> 00:01:48,090
memory to launch another guest

00:01:44,790 --> 00:01:49,799
another process right so that's the

00:01:48,090 --> 00:01:52,259
problem I mean at this point of time

00:01:49,799 --> 00:01:55,590
with the current implementation guest

00:01:52,259 --> 00:01:58,530
even if it has free memory and the host

00:01:55,590 --> 00:02:01,200
is running out of memory does not report

00:01:58,530 --> 00:02:06,500
that free memory back to the host so

00:02:01,200 --> 00:02:09,420
that's the entire issue now considering

00:02:06,500 --> 00:02:11,849
my horse is running out of memory and it

00:02:09,420 --> 00:02:13,420
still wants to launch another process

00:02:11,849 --> 00:02:15,820
another guest

00:02:13,420 --> 00:02:17,850
first question arises is that even

00:02:15,820 --> 00:02:24,300
possible

00:02:17,850 --> 00:02:28,600
so yes it is possible and how exactly

00:02:24,300 --> 00:02:31,060
this entire thing will look like it is

00:02:28,600 --> 00:02:36,090
something like this I have a host I have

00:02:31,060 --> 00:02:40,540
certain free memory in vm1 vm 2 + vm 3

00:02:36,090 --> 00:02:43,120
now what host will see ok now I will at

00:02:40,540 --> 00:02:45,880
this point of time I don't have enough

00:02:43,120 --> 00:02:49,030
free memory and I want to launch another

00:02:45,880 --> 00:02:49,300
guest or another process so what should

00:02:49,030 --> 00:02:52,690
I do

00:02:49,300 --> 00:02:55,900
it will start swapping out its least

00:02:52,690 --> 00:03:00,780
recently used pages now in most of the

00:02:55,900 --> 00:03:05,650
cases what happens is VM one VM to VM 3

00:03:00,780 --> 00:03:08,680
this mask I blue block shows the least

00:03:05,650 --> 00:03:10,450
shows the area memory area in guest

00:03:08,680 --> 00:03:14,320
which is mapped to the host least

00:03:10,450 --> 00:03:18,550
recently used pages or memory now in if

00:03:14,320 --> 00:03:22,090
you see a good amount of this sky-blue I

00:03:18,550 --> 00:03:26,770
realized in the area where VM has its

00:03:22,090 --> 00:03:30,550
free pages what I mean is the least

00:03:26,770 --> 00:03:33,640
recently used pages which host host is

00:03:30,550 --> 00:03:36,010
trying to swap out is actually mapped to

00:03:33,640 --> 00:03:38,650
guess free pages which does not make

00:03:36,010 --> 00:03:42,280
sense right it's stopping out a free

00:03:38,650 --> 00:03:44,530
page which has no useful data now we can

00:03:42,280 --> 00:03:51,880
simply discard that data why do we have

00:03:44,530 --> 00:03:54,100
to swap it out so so I mean after this

00:03:51,880 --> 00:03:56,530
host will still be able to launch

00:03:54,100 --> 00:03:59,350
another guest or in the process

00:03:56,530 --> 00:04:02,800
it looks fine but what's the issue so

00:03:59,350 --> 00:04:08,800
the three key issues which exist in this

00:04:02,800 --> 00:04:11,920
setup will arise when my VM 1 VN 2 RPL

00:04:08,800 --> 00:04:14,980
tree starts accessing that particular

00:04:11,920 --> 00:04:19,540
area which was sapped swapped out by the

00:04:14,980 --> 00:04:22,450
host now when it accesses maybe the m1

00:04:19,540 --> 00:04:25,150
or v m2 or v n3 it starts access that

00:04:22,450 --> 00:04:26,560
particular area what will happen a page

00:04:25,150 --> 00:04:30,370
fault will occur

00:04:26,560 --> 00:04:32,440
and as as a normal way the way page

00:04:30,370 --> 00:04:36,070
fault is served it will be served from

00:04:32,440 --> 00:04:39,790
the secondary storage which is fine but

00:04:36,070 --> 00:04:42,970
I mean it's pretty obvious like you are

00:04:39,790 --> 00:04:45,580
swapping out a free page and then you

00:04:42,970 --> 00:04:47,710
are serving it when when guest is asking

00:04:45,580 --> 00:04:50,470
for guest is trying to access that

00:04:47,710 --> 00:04:52,419
particular memory area you are serving

00:04:50,470 --> 00:04:57,090
that from a secondary disk which does

00:04:52,419 --> 00:04:59,680
not make sense so what are the issues in

00:04:57,090 --> 00:05:03,690
summarize summarizing the issues with

00:04:59,680 --> 00:05:08,500
this particular setup the first issue is

00:05:03,690 --> 00:05:11,320
V CPU stall now when a guest tries to

00:05:08,500 --> 00:05:16,180
access that swapped out memory area or

00:05:11,320 --> 00:05:19,600
reason and by the time its page fault

00:05:16,180 --> 00:05:22,570
request is served in in that particular

00:05:19,600 --> 00:05:27,310
amount of time the V CPU of that word

00:05:22,570 --> 00:05:28,950
live M will be started right so that's

00:05:27,310 --> 00:05:32,200
the first issue

00:05:28,950 --> 00:05:34,660
io is expensive right we want to

00:05:32,200 --> 00:05:38,169
minimize the number of i/o operations as

00:05:34,660 --> 00:05:40,419
much as possible so which does make

00:05:38,169 --> 00:05:42,520
which completely make sense but we are

00:05:40,419 --> 00:05:48,520
not able to do that in this particular

00:05:42,520 --> 00:05:50,860
situation and ion free pages which as I

00:05:48,520 --> 00:05:53,050
have said earlier does not makes any

00:05:50,860 --> 00:05:56,530
sense I mean I owe is already expensive

00:05:53,050 --> 00:05:59,830
and we are doing we are spending energy

00:05:56,530 --> 00:06:03,400
on performing i/o operations on free

00:05:59,830 --> 00:06:08,010
pages why don't we simply discard the

00:06:03,400 --> 00:06:12,160
data which is which is on the free pages

00:06:08,010 --> 00:06:16,539
so they this is the issue okay now what

00:06:12,160 --> 00:06:19,030
we are trying to do is basically the

00:06:16,539 --> 00:06:22,570
free pages or the free memory which was

00:06:19,030 --> 00:06:24,520
there with the with each guest or VMs VM

00:06:22,570 --> 00:06:26,530
one VM truly and three we are trying to

00:06:24,520 --> 00:06:29,350
retrieve that we are trying to enable

00:06:26,530 --> 00:06:32,470
the guest in such a way that whenever it

00:06:29,350 --> 00:06:34,510
has a free memory it should report that

00:06:32,470 --> 00:06:39,889
I have this much amount of free memory

00:06:34,510 --> 00:06:43,460
back to the host so that that particular

00:06:39,889 --> 00:06:45,710
can be used to launch maybe another VM

00:06:43,460 --> 00:06:48,560
or maybe another process that's what

00:06:45,710 --> 00:06:51,620
I've shown in the block diagram on the

00:06:48,560 --> 00:06:53,960
right side there are now earlier there

00:06:51,620 --> 00:06:57,349
was they were trilliant now using that

00:06:53,960 --> 00:06:59,599
free memory which was lined with each of

00:06:57,349 --> 00:07:02,120
the guests I am able to launch another

00:06:59,599 --> 00:07:04,300
VM and still I have some amount of free

00:07:02,120 --> 00:07:04,300
memory

00:07:05,449 --> 00:07:13,939
remaining with the host so how exactly

00:07:10,280 --> 00:07:15,620
guest free page hinting fits in in the

00:07:13,939 --> 00:07:17,779
current situation or the current

00:07:15,620 --> 00:07:23,300
implementation right right now there is

00:07:17,779 --> 00:07:25,909
no way to report the free pages or the

00:07:23,300 --> 00:07:30,979
free memory which is there with a guest

00:07:25,909 --> 00:07:33,800
back to the host now this is where guest

00:07:30,979 --> 00:07:38,029
free page hinting comes into the picture

00:07:33,800 --> 00:07:40,939
it enables the guest dynamically so the

00:07:38,029 --> 00:07:43,460
key or the important point which I would

00:07:40,939 --> 00:07:45,110
like to emphasize over here is that the

00:07:43,460 --> 00:07:48,440
free memory whatever it is with the

00:07:45,110 --> 00:07:50,509
guest is reported back to the host in a

00:07:48,440 --> 00:07:52,909
dynamic manner there is no user

00:07:50,509 --> 00:07:56,719
intervention required as soon as guest

00:07:52,909 --> 00:07:58,639
has some free memory it quickly I mean

00:07:56,719 --> 00:08:02,240
based on some maybe threshold condition

00:07:58,639 --> 00:08:07,000
it reports it back to the host and host

00:08:02,240 --> 00:08:10,879
can free that and use based on its need

00:08:07,000 --> 00:08:13,219
so this is how the implement implement

00:08:10,879 --> 00:08:20,479
in the current implementation guest free

00:08:13,219 --> 00:08:23,150
page hinting fits in so when I started

00:08:20,479 --> 00:08:27,800
working on this this is how the initial

00:08:23,150 --> 00:08:32,329
implementation looked like I have so

00:08:27,800 --> 00:08:35,360
whenever page is freed from free path 3

00:08:32,329 --> 00:08:39,829
code path arc 3 page is a function which

00:08:35,360 --> 00:08:42,800
gets called so what I did I had my guest

00:08:39,829 --> 00:08:46,490
free page hook called from this arc free

00:08:42,800 --> 00:08:48,680
page and once I capped and in that guest

00:08:46,490 --> 00:08:51,800
free page what I was doing is basically

00:08:48,680 --> 00:08:52,910
capturing all the freed pages in a per

00:08:51,800 --> 00:08:56,750
CPU array

00:08:52,910 --> 00:08:59,360
now let's say I have the size of the

00:08:56,750 --> 00:09:01,550
persevere is thousand pages so my guess

00:08:59,360 --> 00:09:04,220
three page is called every time every

00:09:01,550 --> 00:09:08,120
day every time that patellar page will

00:09:04,220 --> 00:09:10,760
be captured into this per CPU array and

00:09:08,120 --> 00:09:12,170
once I have thousand entries or thousand

00:09:10,760 --> 00:09:15,170
pages or whatever it is

00:09:12,170 --> 00:09:17,030
what I'm doing is acquiring a second

00:09:15,170 --> 00:09:18,830
lock now what why six o'clock is

00:09:17,030 --> 00:09:19,990
required is basically for a simple

00:09:18,830 --> 00:09:22,940
reason

00:09:19,990 --> 00:09:24,650
while then once I have thousand entries

00:09:22,940 --> 00:09:27,710
or thousand pages captured

00:09:24,650 --> 00:09:30,260
I don't want and I'm going into scanning

00:09:27,710 --> 00:09:31,850
them so that I can send those pages back

00:09:30,260 --> 00:09:34,700
to the hosts okay now you can free them

00:09:31,850 --> 00:09:36,590
I don't want any other process to kind

00:09:34,700 --> 00:09:40,220
of allocate it because that will lead to

00:09:36,590 --> 00:09:41,780
memory corruption so that's why my so

00:09:40,220 --> 00:09:43,550
similar to our free page I have our

00:09:41,780 --> 00:09:45,740
Kellogg page which gets called from the

00:09:43,550 --> 00:09:47,330
allocation path now to prevent any

00:09:45,740 --> 00:09:49,910
further allocation what I'm doing is

00:09:47,330 --> 00:09:52,700
based on that set lock which I took in

00:09:49,910 --> 00:09:56,030
ox free page or guest free page I'm

00:09:52,700 --> 00:09:57,890
blocking this our Kellogg page good but

00:09:56,030 --> 00:09:59,120
so that there is no further allocation

00:09:57,890 --> 00:10:01,880
by the time I'm scanning

00:09:59,120 --> 00:10:04,670
okay so I have thousand entries or

00:10:01,880 --> 00:10:06,470
thousand pages I'm scanning them what

00:10:04,670 --> 00:10:09,050
basically what I'm doing is I'm checking

00:10:06,470 --> 00:10:11,060
if they are reallocated by the time I

00:10:09,050 --> 00:10:12,860
was capturing thousand pages it's quite

00:10:11,060 --> 00:10:14,870
possible that some of them yet three

00:10:12,860 --> 00:10:17,110
allocated by some process so I don't

00:10:14,870 --> 00:10:20,240
want to free them I'll simply skip them

00:10:17,110 --> 00:10:23,090
based on that if they are still free I'm

00:10:20,240 --> 00:10:25,880
adding them to a new area and once I

00:10:23,090 --> 00:10:28,580
have let's say thousand entries in this

00:10:25,880 --> 00:10:31,100
new array what I'm doing is I'm

00:10:28,580 --> 00:10:32,780
notifying them to the host okay these

00:10:31,100 --> 00:10:36,140
are the thousand pages which are not

00:10:32,780 --> 00:10:38,930
used in any way in the guest now you can

00:10:36,140 --> 00:10:42,140
go ahead and free them now in order to

00:10:38,930 --> 00:10:44,330
do that I have I'm using were tire

00:10:42,140 --> 00:10:47,780
balloon framework so I have 1 new

00:10:44,330 --> 00:10:50,390
hinting v/q added in the existing water

00:10:47,780 --> 00:10:53,180
balloon framework which I am using which

00:10:50,390 --> 00:10:56,750
kind of reports these set of free pages

00:10:53,180 --> 00:10:58,550
to the QEMU and in queueing qemu what

00:10:56,750 --> 00:11:00,890
I'm doing is I'm calling my advice for

00:10:58,550 --> 00:11:02,810
your mad buys don't need so that I can

00:11:00,890 --> 00:11:06,800
throw them out and host can use that

00:11:02,810 --> 00:11:08,810
memory so this is how the initial

00:11:06,800 --> 00:11:10,970
elimination looked like now what are the

00:11:08,810 --> 00:11:14,149
issues with this implementation one

00:11:10,970 --> 00:11:15,880
clear-cut issue with this existing with

00:11:14,149 --> 00:11:18,560
this initial implementation was of

00:11:15,880 --> 00:11:20,720
blocking the entire allocation path now

00:11:18,560 --> 00:11:22,700
if I'm blocking the entire location path

00:11:20,720 --> 00:11:24,709
by the time I'm scanning

00:11:22,700 --> 00:11:26,660
there will be no allocation which does

00:11:24,709 --> 00:11:29,000
not make sense I mean it is in no way it

00:11:26,660 --> 00:11:31,160
is scalable right so that was the key

00:11:29,000 --> 00:11:34,220
issue with that other than that the

00:11:31,160 --> 00:11:38,810
other issue was I was blocking arc a log

00:11:34,220 --> 00:11:40,579
page and arcs free page code path once I

00:11:38,810 --> 00:11:43,550
have like thousand entries or sholde

00:11:40,579 --> 00:11:45,769
based increase in my persevering and I'm

00:11:43,550 --> 00:11:48,709
going to scan them I'm blocking this arc

00:11:45,769 --> 00:11:52,010
free page in every manner this arc free

00:11:48,709 --> 00:11:53,089
page code path never returns that does

00:11:52,010 --> 00:11:56,600
not sounds good

00:11:53,089 --> 00:11:59,930
right so we changed our approach and

00:11:56,600 --> 00:12:04,579
this is how the existing implementation

00:11:59,930 --> 00:12:07,339
looks like so I have I still have a

00:12:04,579 --> 00:12:09,740
process I still have my hook in arc free

00:12:07,339 --> 00:12:12,620
page which is guest free page I'm still

00:12:09,740 --> 00:12:16,940
capturing the free pages in a percy puri

00:12:12,620 --> 00:12:18,920
and once I have all the entries or all

00:12:16,940 --> 00:12:20,630
the pages that's a thousand pages

00:12:18,920 --> 00:12:24,290
captured in my percy puri

00:12:20,630 --> 00:12:26,149
I'm not taking the say clock right first

00:12:24,290 --> 00:12:29,570
thing I'm not taking a sec lock over

00:12:26,149 --> 00:12:31,910
here and I'm not blocking a free page

00:12:29,570 --> 00:12:33,020
code path what I'm doing is I'm calling

00:12:31,910 --> 00:12:35,649
a per CPU thread

00:12:33,020 --> 00:12:39,529
now this percy putrid is basically

00:12:35,649 --> 00:12:42,020
responsible for all sort of scanning and

00:12:39,529 --> 00:12:44,089
further processing and reporting these

00:12:42,020 --> 00:12:45,950
pages to the hosts so I'm not blocking

00:12:44,089 --> 00:12:48,260
our free page that's fine

00:12:45,950 --> 00:12:51,380
that's one issue is resolved now within

00:12:48,260 --> 00:12:54,620
this per CPU thread what I'm doing is

00:12:51,380 --> 00:12:57,640
instead of taking the set lock to avoid

00:12:54,620 --> 00:13:00,649
any allocation I'm taking a zone lock

00:12:57,640 --> 00:13:02,420
the way it will work is once I have the

00:13:00,649 --> 00:13:05,720
zone lock based on the page which I'm

00:13:02,420 --> 00:13:09,260
trying to scan it will prevent any sort

00:13:05,720 --> 00:13:11,329
of allocation just in that zone so if I

00:13:09,260 --> 00:13:14,570
have a if I have a page which belongs to

00:13:11,329 --> 00:13:17,690
zone one my zone 0 and zone 2 will still

00:13:14,570 --> 00:13:20,600
be able to do allocations so I'm not

00:13:17,690 --> 00:13:23,089
blocking all or the entire allocation

00:13:20,600 --> 00:13:27,829
but which is better than the previous

00:13:23,089 --> 00:13:31,940
approach okay so I have my I have my

00:13:27,829 --> 00:13:35,509
pages I have zone lock acquired what's

00:13:31,940 --> 00:13:37,370
next so what I do is for with this

00:13:35,509 --> 00:13:41,029
approach I'm depending on the birdie

00:13:37,370 --> 00:13:44,360
free system now once the page is freed

00:13:41,029 --> 00:13:48,470
what happens is it gets added to the

00:13:44,360 --> 00:13:50,870
body free list now once I have I have

00:13:48,470 --> 00:13:53,810
checked at the page which I'm scanning

00:13:50,870 --> 00:13:56,540
is not reallocated what I'm doing is I'm

00:13:53,810 --> 00:13:59,120
isolating it so what I mean by isolation

00:13:56,540 --> 00:14:02,060
is that it is plucked out of this body

00:13:59,120 --> 00:14:05,120
free list which means it will not be

00:14:02,060 --> 00:14:07,970
used or it will not be used by any

00:14:05,120 --> 00:14:12,009
process for any sort of allocation so

00:14:07,970 --> 00:14:14,690
now the PFN or the page which I have is

00:14:12,009 --> 00:14:17,060
isolated from the guest now guests will

00:14:14,690 --> 00:14:19,100
not be able to allocate this particular

00:14:17,060 --> 00:14:21,290
pages so this is what I am doing I'm

00:14:19,100 --> 00:14:23,480
four thousand entries which I have

00:14:21,290 --> 00:14:26,420
captured I'm continuously checking for

00:14:23,480 --> 00:14:28,699
any real location if there is any and if

00:14:26,420 --> 00:14:31,339
there are none then I'm isolating it

00:14:28,699 --> 00:14:34,250
from the body free list okay which

00:14:31,339 --> 00:14:36,380
sounds fine and after this I do the same

00:14:34,250 --> 00:14:39,500
thing which I was doing earlier I added

00:14:36,380 --> 00:14:42,319
two enough new policy puri I wait wait

00:14:39,500 --> 00:14:45,949
until a certain I have elect maybe five

00:14:42,319 --> 00:14:48,740
five five hundred maybe hundred isolated

00:14:45,949 --> 00:14:51,380
pages once I have those pages I report

00:14:48,740 --> 00:14:53,990
them to the host now host receives it

00:14:51,380 --> 00:14:56,750
and does the same thing I'm still using

00:14:53,990 --> 00:14:58,399
the birthday balloon framework and in

00:14:56,750 --> 00:15:01,130
the water balloon framework I'm still

00:14:58,399 --> 00:15:04,850
using the same vq and once I have all

00:15:01,130 --> 00:15:08,000
the isolated pages I'll free them and

00:15:04,850 --> 00:15:10,550
once this entire process is done AK will

00:15:08,000 --> 00:15:12,709
be sent back to the guest now in the

00:15:10,550 --> 00:15:15,439
guest what it will do once this AK is

00:15:12,709 --> 00:15:17,389
received it will release those PF n or

00:15:15,439 --> 00:15:21,769
page values back to the body free list

00:15:17,389 --> 00:15:24,699
or in a way it will add I mean it will

00:15:21,769 --> 00:15:27,380
put those PF ends or pages which we

00:15:24,699 --> 00:15:30,680
initially isolated back to the body

00:15:27,380 --> 00:15:34,400
finish so guests can still just can

00:15:30,680 --> 00:15:35,900
again use these pages for its eyelet

00:15:34,400 --> 00:15:43,280
for its allocation for any sort of

00:15:35,900 --> 00:15:46,220
allocation so the benefits of this

00:15:43,280 --> 00:15:49,340
approach as I've said earlier is the

00:15:46,220 --> 00:15:51,320
same I mean I'm not blocked the best

00:15:49,340 --> 00:15:53,330
benefit I would say is that I'm not

00:15:51,320 --> 00:15:56,870
blocking the entire allocation path I'm

00:15:53,330 --> 00:16:00,110
just blocking the zone allocation second

00:15:56,870 --> 00:16:03,400
is I'm not blocking any any sort of code

00:16:00,110 --> 00:16:06,800
flows free page or our key lock page and

00:16:03,400 --> 00:16:09,410
this is still dynamic and I'm still not

00:16:06,800 --> 00:16:12,350
depending on user to make anything I'm

00:16:09,410 --> 00:16:14,750
still into the entire process of

00:16:12,350 --> 00:16:19,160
reporting three pages is still tied at

00:16:14,750 --> 00:16:21,110
me so what are the challenges so the

00:16:19,160 --> 00:16:23,630
biggest challenge which we which we are

00:16:21,110 --> 00:16:25,370
facing right now is - I have a test

00:16:23,630 --> 00:16:26,930
application what it does is simply

00:16:25,370 --> 00:16:30,680
allocates a certain amount of memory

00:16:26,930 --> 00:16:32,480
touches it and it frees it right now in

00:16:30,680 --> 00:16:34,670
this poor CPA array if it is like

00:16:32,480 --> 00:16:37,430
thousand and ten thousand pages I'm not

00:16:34,670 --> 00:16:41,870
able to cap capture all set of free

00:16:37,430 --> 00:16:44,240
pages which is a problem right now

00:16:41,870 --> 00:16:46,250
that's the first problem now second

00:16:44,240 --> 00:16:48,290
problem is even with the pages which I

00:16:46,250 --> 00:16:49,910
have captured let's thousand pages which

00:16:48,290 --> 00:16:52,060
I have captured when I'm trying to

00:16:49,910 --> 00:16:55,580
isolate what I have analyzed that I'm

00:16:52,060 --> 00:16:57,800
not able to isolate them because they

00:16:55,580 --> 00:16:59,720
are not in the body free list why they

00:16:57,800 --> 00:17:01,520
are not in the body free list is

00:16:59,720 --> 00:17:06,470
basically because they are ending up in

00:17:01,520 --> 00:17:09,170
some sort of cache list or in some sort

00:17:06,470 --> 00:17:10,970
of caches which due to which they are

00:17:09,170 --> 00:17:14,870
not getting added to the body frame

00:17:10,970 --> 00:17:17,780
relation body free list then we although

00:17:14,870 --> 00:17:20,720
we have a test case but we would like to

00:17:17,780 --> 00:17:24,320
experiment a little bit more to find a

00:17:20,720 --> 00:17:26,330
better development oriented test case so

00:17:24,320 --> 00:17:28,600
that we can find out other kind of

00:17:26,330 --> 00:17:30,950
issues associated with this approach and

00:17:28,600 --> 00:17:34,070
this is the last one is a bit futuristic

00:17:30,950 --> 00:17:35,930
a target to kind of once we have

00:17:34,070 --> 00:17:38,780
everything set up and behaving in the

00:17:35,930 --> 00:17:41,720
manner in which we wanted it to we will

00:17:38,780 --> 00:17:45,590
see how much overhead this per CPU

00:17:41,720 --> 00:17:48,230
thread is adding and the loan

00:17:45,590 --> 00:17:50,299
limitations are isolation when

00:17:48,230 --> 00:17:52,940
if you are trying to isolate a page it

00:17:50,299 --> 00:17:55,309
will check whether the zone to which

00:17:52,940 --> 00:17:57,440
this page belongs whether it has three

00:17:55,309 --> 00:17:59,540
pages or not under lots of memory

00:17:57,440 --> 00:18:03,530
pressure that will not be the case so

00:17:59,540 --> 00:18:06,410
isolation will pay second we depend on

00:18:03,530 --> 00:18:08,780
the body free list if the page is not in

00:18:06,410 --> 00:18:11,179
the body free list we cannot perform

00:18:08,780 --> 00:18:13,940
isolation and hence we cannot free that

00:18:11,179 --> 00:18:20,450
particular page so those are the two

00:18:13,940 --> 00:18:23,330
known limitations I would say now what

00:18:20,450 --> 00:18:27,049
are the future optimizations which we

00:18:23,330 --> 00:18:32,000
have in our mind so as of now what I'm

00:18:27,049 --> 00:18:33,950
doing is I'm kicking the host with so if

00:18:32,000 --> 00:18:36,580
I have initial in my initial policy

00:18:33,950 --> 00:18:39,559
period if I have thousand pages I'm

00:18:36,580 --> 00:18:42,710
scanning those thousand pages finding

00:18:39,559 --> 00:18:46,480
out whether they are reallocated if they

00:18:42,710 --> 00:18:48,650
are not reallocated isolating them so

00:18:46,480 --> 00:18:51,559
after scanning these thousand pages

00:18:48,650 --> 00:18:54,470
irrespective of how many peas isolated

00:18:51,559 --> 00:18:57,440
pages I have it may be fine it may be

00:18:54,470 --> 00:18:59,179
hundred it may be ten I'm every time

00:18:57,440 --> 00:19:01,070
after thousand page scanning I'm

00:18:59,179 --> 00:19:04,010
reporting it to the host and what you

00:19:01,070 --> 00:19:06,980
kick is a costly process so what we

00:19:04,010 --> 00:19:09,080
would like to do is make sure I have

00:19:06,980 --> 00:19:11,870
thousand isolated pages or thousand

00:19:09,080 --> 00:19:14,360
entries of isolated pages and once I

00:19:11,870 --> 00:19:17,750
have that then only go ahead and kind of

00:19:14,360 --> 00:19:19,100
report it to the host that will saves

00:19:17,750 --> 00:19:23,030
that will improve the performance

00:19:19,100 --> 00:19:24,559
overall the second thing is when I'm

00:19:23,030 --> 00:19:27,679
acquiring the zone lock right now

00:19:24,559 --> 00:19:29,780
acquiring the zone lock on each entry

00:19:27,679 --> 00:19:32,780
what I mean is if I have three entries

00:19:29,780 --> 00:19:35,600
in my quasi pure a page one or entry one

00:19:32,780 --> 00:19:37,700
belongs to zone zero entry to belongs to

00:19:35,600 --> 00:19:40,750
zone zero entry 3 belongs to zone 0 I'm

00:19:37,700 --> 00:19:43,820
acquiring the zone lock for each entry

00:19:40,750 --> 00:19:46,790
which does not make sense what we would

00:19:43,820 --> 00:19:48,440
do is sort the entire Percy PA rate

00:19:46,790 --> 00:19:51,410
based on zone number and acquired the

00:19:48,440 --> 00:19:53,919
zone of just once for and scan all the

00:19:51,410 --> 00:19:57,559
entries corresponding to that zone that

00:19:53,919 --> 00:20:01,409
is we have in our mind then the

00:19:57,559 --> 00:20:04,509
threshold the threshold is kind of a

00:20:01,409 --> 00:20:08,200
concept or keeping which we have to

00:20:04,509 --> 00:20:10,990
figure out threshold defines when we are

00:20:08,200 --> 00:20:14,830
actually so there are two thresholds

00:20:10,990 --> 00:20:17,830
first when we are actually waking up our

00:20:14,830 --> 00:20:19,389
Percy putrid based on the first

00:20:17,830 --> 00:20:22,990
threshold and the second threshold is

00:20:19,389 --> 00:20:25,750
based on that second threshold I'm

00:20:22,990 --> 00:20:29,259
deciding when to notify my hosts about

00:20:25,750 --> 00:20:31,630
the isolated pages and considering the

00:20:29,259 --> 00:20:35,019
use case of a customer or anyone using

00:20:31,630 --> 00:20:38,830
this will differ what I mean by that is

00:20:35,019 --> 00:20:41,169
a process may free like thousand pages

00:20:38,830 --> 00:20:43,240
in a regular interval of time it may

00:20:41,169 --> 00:20:47,320
free 10,000 pages in a regular interval

00:20:43,240 --> 00:20:49,750
of time so what we intend to do is have

00:20:47,320 --> 00:20:52,179
a default value have a generic default

00:20:49,750 --> 00:20:54,879
value which we may be analyzed by

00:20:52,179 --> 00:20:59,019
running different kind of workloads have

00:20:54,879 --> 00:21:00,970
that and once I have that I'll make at

00:20:59,019 --> 00:21:03,190
the same time I'll make it configurable

00:21:00,970 --> 00:21:05,529
so that if user wants to change it based

00:21:03,190 --> 00:21:07,929
on his use case then he should be able

00:21:05,529 --> 00:21:15,279
to do it so that's the entire goal of

00:21:07,929 --> 00:21:17,200
this so this is so the last path which I

00:21:15,279 --> 00:21:20,559
which I have posted upstream was

00:21:17,200 --> 00:21:24,250
basically with my earlier or earlier

00:21:20,559 --> 00:21:26,679
approach as the current approach on

00:21:24,250 --> 00:21:30,009
which I am working right now is still in

00:21:26,679 --> 00:21:34,240
a kind of an early phase but I do plug

00:21:30,009 --> 00:21:37,480
do have a plan to post this new approach

00:21:34,240 --> 00:21:39,309
soon enough and the development

00:21:37,480 --> 00:21:42,039
repository which I use feel free to

00:21:39,309 --> 00:21:50,309
check it out it's the both for Linux and

00:21:42,039 --> 00:21:50,309
qemu when my changes are there that's it

00:21:55,790 --> 00:22:03,290
[Applause]

00:22:10,890 --> 00:22:23,210
I can't hear you sorry hello did you

00:22:20,220 --> 00:22:26,340
talk about allocating just a bitmap of

00:22:23,210 --> 00:22:29,790
pages and just pass the notification

00:22:26,340 --> 00:22:34,080
once of the of the big map and use that

00:22:29,790 --> 00:22:37,200
bitmap what's that so instead of having

00:22:34,080 --> 00:22:39,840
to not notify every time the page is

00:22:37,200 --> 00:22:43,080
free just allocate a bitmap I passed

00:22:39,840 --> 00:22:45,450
that bitmap on a qmo so having shared

00:22:43,080 --> 00:22:48,510
memory and QM you can reach just a

00:22:45,450 --> 00:22:52,799
memory when it needs to to get free

00:22:48,510 --> 00:22:56,870
pages from the guest I'm not sure if I

00:22:52,799 --> 00:22:56,870
understood your question entirely I mean

00:22:57,020 --> 00:23:06,480
let's say that you have 4 gigabyte post

00:23:02,610 --> 00:23:09,570
right is 1 million pages ok you locate a

00:23:06,480 --> 00:23:13,380
bitmap of my medium which is so yeah I

00:23:09,570 --> 00:23:17,100
mean you are talking about so yeah so

00:23:13,380 --> 00:23:19,559
bitmap was one thing which I mean the

00:23:17,100 --> 00:23:22,080
last patch which I posted upstream was

00:23:19,559 --> 00:23:25,470
suggested by Rick so I still have to

00:23:22,080 --> 00:23:27,630
look into that and right now I'm I mean

00:23:25,470 --> 00:23:29,190
so as I'm saying I mean this is

00:23:27,630 --> 00:23:32,190
something which I would like I would

00:23:29,190 --> 00:23:34,830
have to kind of analyze so the previous

00:23:32,190 --> 00:23:36,990
implementation we I did complete I mean

00:23:34,830 --> 00:23:39,240
I completed that and then I analyzed ok

00:23:36,990 --> 00:23:42,150
ok it has some flaws so let's move on to

00:23:39,240 --> 00:23:44,910
the other one bitmap was and was another

00:23:42,150 --> 00:23:46,770
thing which is in my to-do list and once

00:23:44,910 --> 00:23:48,270
I analyze this I'll probably look into

00:23:46,770 --> 00:23:52,410
that so that is something which I have

00:23:48,270 --> 00:23:54,809
to still look into it can I ask a

00:23:52,410 --> 00:23:56,880
question about the fundamental of this

00:23:54,809 --> 00:23:59,460
approach yeah you say but there are a

00:23:56,880 --> 00:24:01,710
lot of memory inside of a guest which is

00:23:59,460 --> 00:24:04,470
free what usually this is not true

00:24:01,710 --> 00:24:07,740
because memory allocator inside the

00:24:04,470 --> 00:24:10,230
guest tries to keep 3 to 5 megabytes of

00:24:07,740 --> 00:24:13,919
free memory and the rest of memory is

00:24:10,230 --> 00:24:16,770
usually is available but not free it

00:24:13,919 --> 00:24:20,190
usually resides and the discussions so

00:24:16,770 --> 00:24:22,830
most likely you are not working 3 pages

00:24:20,190 --> 00:24:25,710
but you are swapping pages under the

00:24:22,830 --> 00:24:29,220
get some gifts and this will not fit to

00:24:25,710 --> 00:24:32,340
your brooch so if if I understood your

00:24:29,220 --> 00:24:34,500
question correctly then what I am trying

00:24:32,340 --> 00:24:37,350
to imply with this is basically if you

00:24:34,500 --> 00:24:39,360
have a guest let's say you boot your

00:24:37,350 --> 00:24:40,409
guests it is using at that once it's

00:24:39,360 --> 00:24:43,500
completely booted up

00:24:40,409 --> 00:24:45,570
it is using 1 GB of memory maybe just an

00:24:43,500 --> 00:24:47,789
assumption after that it performed it

00:24:45,570 --> 00:24:51,059
runs some process which which starts

00:24:47,789 --> 00:24:53,640
using bujji B 3 GB memory and at the end

00:24:51,059 --> 00:24:55,769
of this process when it terminates it

00:24:53,640 --> 00:24:58,649
will not be using that 3 GB memory right

00:24:55,769 --> 00:25:01,919
it will no it will keep it will be kept

00:24:58,649 --> 00:25:04,230
in the page cache so most likely he will

00:25:01,919 --> 00:25:07,260
not have free page so normal memory

00:25:04,230 --> 00:25:09,600
management of any modern Oz tries to

00:25:07,260 --> 00:25:12,090
preserve minimal amount of memory as a3

00:25:09,600 --> 00:25:16,830
the rest of memory the memory is healed

00:25:12,090 --> 00:25:19,950
this cache is this that as well that so

00:25:16,830 --> 00:25:22,139
if you remember like so this having

00:25:19,950 --> 00:25:24,690
certain amount of memory what I have

00:25:22,139 --> 00:25:26,880
analyzed so far you are right I mean

00:25:24,690 --> 00:25:29,130
there is a group I'm certain amount of

00:25:26,880 --> 00:25:32,519
memory which ends up in the cache and I

00:25:29,130 --> 00:25:35,190
I think I have mentioned it in the

00:25:32,519 --> 00:25:37,429
challenges in the page frame cashless so

00:25:35,190 --> 00:25:41,070
page frame cache list has this condition

00:25:37,429 --> 00:25:42,720
so I'm going back a little again I am

00:25:41,070 --> 00:25:46,940
depending on the body free list right

00:25:42,720 --> 00:25:50,850
now page cache frame list releases those

00:25:46,940 --> 00:25:54,149
pages which are in its cache only after

00:25:50,850 --> 00:25:56,549
the high count is met which is like 278

00:25:54,149 --> 00:25:58,710
pages or something like that now if that

00:25:56,549 --> 00:26:01,260
condition is not met I will not have

00:25:58,710 --> 00:26:03,539
that those pages so the previous

00:26:01,260 --> 00:26:07,289
implementation or when I was working

00:26:03,539 --> 00:26:10,740
with Rick was to work or to come up with

00:26:07,289 --> 00:26:14,159
a solution for a guest without a cache

00:26:10,740 --> 00:26:17,580
and we had planned to use fake dots at

00:26:14,159 --> 00:26:20,549
that time however in this approach so

00:26:17,580 --> 00:26:22,110
far we are not we are hoping that we

00:26:20,549 --> 00:26:27,389
don't have to go that way we don't have

00:26:22,110 --> 00:26:29,490
to disable the cache in the guest but so

00:26:27,389 --> 00:26:32,460
the test application which I was running

00:26:29,490 --> 00:26:36,750
you are right I mean in that some pages

00:26:32,460 --> 00:26:38,310
were ended up in the guest of cache list

00:26:36,750 --> 00:26:40,380
but still there was a good amount of

00:26:38,310 --> 00:26:43,200
memory which was not in the cache and

00:26:40,380 --> 00:26:46,560
which I had freed and which I received

00:26:43,200 --> 00:26:52,920
on the hosts back so that's what I have

00:26:46,560 --> 00:26:55,950
analyzed when you say you have a zone

00:26:52,920 --> 00:26:57,990
locks is that the existing mm zones like

00:26:55,950 --> 00:27:00,360
zone damage what's that or is that that

00:26:57,990 --> 00:27:02,490
your own definition of zones can you

00:27:00,360 --> 00:27:03,480
when you're talking about having a zone

00:27:02,490 --> 00:27:05,460
locks yes

00:27:03,480 --> 00:27:08,400
are those the existing is that the

00:27:05,460 --> 00:27:10,200
existing concept designs in the mm yes

00:27:08,400 --> 00:27:12,480
ok I didn't think they were particularly

00:27:10,200 --> 00:27:14,610
evenly divided what's that

00:27:12,480 --> 00:27:15,900
I didn't think the existing mm zones

00:27:14,610 --> 00:27:18,150
were particular like they're generally

00:27:15,900 --> 00:27:22,100
for special purposes not just a way of

00:27:18,150 --> 00:27:22,100
dividing memory up into equal chunks

00:27:22,970 --> 00:27:34,410
what exactly in my equal chunks well

00:27:32,970 --> 00:27:36,090
that's what I'm asking are you talking

00:27:34,410 --> 00:27:38,280
about zone DNA or are you talking about

00:27:36,090 --> 00:27:40,170
a different concept designs so I'm

00:27:38,280 --> 00:27:43,470
acquiring the zone lock just to prevent

00:27:40,170 --> 00:27:45,960
oh no no no way the lock but what are

00:27:43,470 --> 00:27:47,580
those ions did you define the zones or

00:27:45,960 --> 00:27:51,390
there's no I define the zone so there

00:27:47,580 --> 00:27:53,490
are still there it's still there are

00:27:51,390 --> 00:27:56,670
three zones which are predefined I am

00:27:53,490 --> 00:27:58,920
NOT defining them in my image like you

00:27:56,670 --> 00:27:59,520
want you want hash marks based on the

00:27:58,920 --> 00:28:02,400
page address

00:27:59,520 --> 00:28:03,990
no those are because the zone doesn't

00:28:02,400 --> 00:28:06,300
seem between a particularly good way of

00:28:03,990 --> 00:28:12,450
the fire of splitting what locks you're

00:28:06,300 --> 00:28:20,820
using I don't know I mean so far it has

00:28:12,450 --> 00:28:24,440
worked yeah thank you thank you

00:28:20,820 --> 00:28:30,219
[Applause]

00:28:24,440 --> 00:28:30,219

YouTube URL: https://www.youtube.com/watch?v=aSZgImtJs9s


