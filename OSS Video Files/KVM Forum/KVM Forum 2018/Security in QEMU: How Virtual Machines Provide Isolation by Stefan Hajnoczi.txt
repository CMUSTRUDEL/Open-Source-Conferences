Title: Security in QEMU: How Virtual Machines Provide Isolation by Stefan Hajnoczi
Publication date: 2018-11-14
Playlist: KVM Forum 2018
Description: 
	Is it safe to use QEMU to do X? This talk explains the security model and use cases that QEMU is designed for.

Understanding the security model is critical for deploying virtual machines as well as contributing code to QEMU. This talk gives an overview of the attack surfaces, including emulated devices, the monitor, remote desktop, disk images, and the CPU accelerators.

Virtual machines offer isolation from each other and the host if QEMU is configured properly. Most of these best practices are encapsulated in libvirt, but not all users choose to use it, so it is worth understanding them.

Finally, no discussion of security in QEMU would be complete without reviewing CVEs and the lessons learnt from them.

---

Stefan Hajnoczi
Red Hat
Principle Software Engineer

Stefan has been active in QEMU since 2010 and works in Red Hat's virtualization team with a focus on storage. He helps maintain the block layer and tracing in QEMU. He also organizes and mentors in the Google Summer of Code and Outreachy internship programs, and participates in the VIRTIO Technical Committee.

Current projects include the virtio-vsock communications device, file sharing, and lightweight virtual machines.

Stefan has presented at previous KVM Forums, as well as FOSDEM, LinuxCon, and Linux Plumbers.
Captions: 
	00:00:00,380 --> 00:00:02,709
[Music]

00:00:06,020 --> 00:00:13,259
hi my name is Stefan poignancy I'm gonna

00:00:09,179 --> 00:00:16,619
talk about security in pews let's get

00:00:13,259 --> 00:00:19,020
started okay so just a little bit about

00:00:16,619 --> 00:00:21,930
me I work in Red Hat virtualization team

00:00:19,020 --> 00:00:24,900
and I've been contributing to me since

00:00:21,930 --> 00:00:26,310
around 2010 and over those years I have

00:00:24,900 --> 00:00:29,630
been involved in reviewing security

00:00:26,310 --> 00:00:32,489
fixes and also in the disclosure process

00:00:29,630 --> 00:00:34,680
we haven't really had a talk

00:00:32,489 --> 00:00:37,800
IBM forum that gives an overview of

00:00:34,680 --> 00:00:42,719
queueing security issues a bit about the

00:00:37,800 --> 00:00:44,520
design of how things work both some

00:00:42,719 --> 00:00:47,160
information for users who are deploying

00:00:44,520 --> 00:00:50,219
it or considering commute as well as for

00:00:47,160 --> 00:00:52,110
developers what to look out for when

00:00:50,219 --> 00:00:56,910
adding new features in order to keep you

00:00:52,110 --> 00:00:59,940
secure okay so let's start off with the

00:00:56,910 --> 00:01:03,120
security process there is a security

00:00:59,940 --> 00:01:05,400
process for reporting security issues to

00:01:03,120 --> 00:01:07,920
the CUNY community and the whole point

00:01:05,400 --> 00:01:10,350
of like most disclosure processes is

00:01:07,920 --> 00:01:12,510
that if the security bug is discovered

00:01:10,350 --> 00:01:15,479
it's important that that bug remains

00:01:12,510 --> 00:01:18,420
private and not publicly known until

00:01:15,479 --> 00:01:21,900
fixes are available that users kind of

00:01:18,420 --> 00:01:23,460
used to patch their systems that way you

00:01:21,900 --> 00:01:26,540
minimize the risk that users will be

00:01:23,460 --> 00:01:30,590
exposed to to bucks

00:01:26,540 --> 00:01:34,259
so please follow this process if you

00:01:30,590 --> 00:01:38,280
discover bugs in the code and you want

00:01:34,259 --> 00:01:39,750
to report them you can also use it if

00:01:38,280 --> 00:01:40,950
you find something in the code that

00:01:39,750 --> 00:01:42,780
looks suspicious

00:01:40,950 --> 00:01:45,149
you're not sure I didn't not sure if

00:01:42,780 --> 00:01:47,130
it's really a security bug so you can go

00:01:45,149 --> 00:01:49,470
through this process and it means that

00:01:47,130 --> 00:01:49,770
someone but you'll have someone to talk

00:01:49,470 --> 00:01:51,390
to

00:01:49,770 --> 00:01:53,670
maybe it's the maintainer of the code

00:01:51,390 --> 00:01:55,320
who can then help you figure out what's

00:01:53,670 --> 00:01:57,960
the severity of this is this really a

00:01:55,320 --> 00:02:01,130
security issue so that's the page go to

00:01:57,960 --> 00:02:04,170
and that's the thing to get started with

00:02:01,130 --> 00:02:05,820
now communion has a long history and

00:02:04,170 --> 00:02:07,460
there's a lot of different use cases

00:02:05,820 --> 00:02:09,979
people use mu and

00:02:07,460 --> 00:02:11,450
some ways and those different ways have

00:02:09,979 --> 00:02:13,580
kind of different expectations different

00:02:11,450 --> 00:02:17,060
security requirements associated with

00:02:13,580 --> 00:02:18,440
them so I have basically the most

00:02:17,060 --> 00:02:20,540
trivial example here

00:02:18,440 --> 00:02:21,890
taury kernel development so you want to

00:02:20,540 --> 00:02:23,660
do a bit of little bit more programming

00:02:21,890 --> 00:02:25,910
you want to play around with operating

00:02:23,660 --> 00:02:27,590
systems concepts so you're hacking on

00:02:25,910 --> 00:02:30,230
your toy kernel and you want to test it

00:02:27,590 --> 00:02:33,080
run it inside aviÃ³n so use Q Union in

00:02:30,230 --> 00:02:35,120
that case the virtual machine the guest

00:02:33,080 --> 00:02:37,100
is trusted right because it's just

00:02:35,120 --> 00:02:38,540
running your code and chances are it's

00:02:37,100 --> 00:02:40,670
not even connected to the internet so

00:02:38,540 --> 00:02:43,420
the risk of anything malicious coming

00:02:40,670 --> 00:02:47,209
from I guess is basically non-existent

00:02:43,420 --> 00:02:48,410
in the scenario the user is also trusted

00:02:47,209 --> 00:02:50,480
because it's just you you're not gonna

00:02:48,410 --> 00:02:54,019
try and hack yourself there's no there's

00:02:50,480 --> 00:02:57,739
no real issue here but in most

00:02:54,019 --> 00:03:01,880
real-world races we do have components

00:02:57,739 --> 00:03:03,890
that are untrusted so what I want to do

00:03:01,880 --> 00:03:05,750
is I want to I want to first go over

00:03:03,890 --> 00:03:08,510
what Hume used security with primers are

00:03:05,750 --> 00:03:11,360
what the cube community today agrees on

00:03:08,510 --> 00:03:13,130
are the security boundaries and I hope

00:03:11,360 --> 00:03:15,440
that that will help you when you

00:03:13,130 --> 00:03:18,579
evaluate your own use case and you think

00:03:15,440 --> 00:03:20,660
about is it safe for me to use Q you

00:03:18,579 --> 00:03:23,390
because you basically just need to make

00:03:20,660 --> 00:03:25,549
sure that what Q you guarantees is at

00:03:23,390 --> 00:03:27,350
least as strict as what you need right

00:03:25,549 --> 00:03:29,840
if you have stricter requirements than

00:03:27,350 --> 00:03:34,160
what's that will Q new guarantees then

00:03:29,840 --> 00:03:37,250
you need to either talk to the community

00:03:34,160 --> 00:03:39,260
and see how you can get Q me to fill

00:03:37,250 --> 00:03:44,209
those stricter requirements or maybe you

00:03:39,260 --> 00:03:45,650
need to consider an alternative so how

00:03:44,209 --> 00:03:48,200
does that work right we're an open

00:03:45,650 --> 00:03:50,660
source project we're a community how do

00:03:48,200 --> 00:03:52,790
we decide what the security boundaries

00:03:50,660 --> 00:03:54,650
are because there's there's different

00:03:52,790 --> 00:03:56,870
like a ella mentioned there's different

00:03:54,650 --> 00:03:59,959
use cases someone might use Q as a

00:03:56,870 --> 00:04:02,780
research platform to prototype things or

00:03:59,959 --> 00:04:04,370
or or want to share their experiments

00:04:02,780 --> 00:04:06,530
with the community so they might just

00:04:04,370 --> 00:04:08,780
want to commit code get it merged and

00:04:06,530 --> 00:04:10,730
share it with people but that code isn't

00:04:08,780 --> 00:04:12,200
really hardened it's not something that

00:04:10,730 --> 00:04:16,139
you would want to deploy in production

00:04:12,200 --> 00:04:18,599
where there might be malicious user

00:04:16,139 --> 00:04:20,189
we want to compromise it on the other

00:04:18,599 --> 00:04:23,250
hand you might have people who say well

00:04:20,189 --> 00:04:26,310
I need an emulator or hypervisor that

00:04:23,250 --> 00:04:28,169
has very stringent meets very stringent

00:04:26,310 --> 00:04:29,699
security requirements and I really don't

00:04:28,169 --> 00:04:33,599
have time for any of the other stuff

00:04:29,699 --> 00:04:36,090
that the features that I'm not using and

00:04:33,599 --> 00:04:38,520
so on so we have kind of a spectrum of

00:04:36,090 --> 00:04:40,830
different you know where you could be on

00:04:38,520 --> 00:04:43,710
this spectrum and the way it works is

00:04:40,830 --> 00:04:46,860
because Q is a project as people join

00:04:43,710 --> 00:04:48,270
and leave the project the focus shifts

00:04:46,860 --> 00:04:51,240
around a little bit and it has shifted

00:04:48,270 --> 00:04:52,710
over time and so basically what I'm

00:04:51,240 --> 00:04:55,139
saying here is I'm just encouraging you

00:04:52,710 --> 00:04:56,789
that if you find you have stricter

00:04:55,139 --> 00:04:58,800
requirements than what you mean

00:04:56,789 --> 00:05:01,289
currently supports there's always scope

00:04:58,800 --> 00:05:05,159
to enhance human and discuss it with the

00:05:01,289 --> 00:05:07,110
community if you have very few

00:05:05,159 --> 00:05:09,120
requirements then it's gonna be hard to

00:05:07,110 --> 00:05:11,009
convince people but they should run an

00:05:09,120 --> 00:05:13,050
insecurity me so it's hard for us to go

00:05:11,009 --> 00:05:15,539
the other way but we can sometimes make

00:05:13,050 --> 00:05:17,930
it stricter it become clear that there's

00:05:15,539 --> 00:05:21,900
demand for that

00:05:17,930 --> 00:05:23,819
okay so what does qu me do today today

00:05:21,900 --> 00:05:29,039
for the virtualization use case and

00:05:23,819 --> 00:05:30,960
there I mean using KVM the guest is

00:05:29,039 --> 00:05:33,270
considered untrusted okay the guest is

00:05:30,960 --> 00:05:35,009
considered you know it could have

00:05:33,270 --> 00:05:37,349
malicious code it could be trying to

00:05:35,009 --> 00:05:40,860
compromise the rest of the system the

00:05:37,349 --> 00:05:42,599
user facing interfaces like VNC for

00:05:40,860 --> 00:05:46,020
example they are also considered

00:05:42,599 --> 00:05:48,330
untrusted because those might be given

00:05:46,020 --> 00:05:51,050
to untrusted users who will then connect

00:05:48,330 --> 00:05:53,219
to the VM the network protocols

00:05:51,050 --> 00:05:55,020
basically talking to anything external

00:05:53,219 --> 00:05:56,669
is considered untrusted and the same

00:05:55,020 --> 00:05:58,589
thing for user supplied files like disk

00:05:56,669 --> 00:06:00,710
images or kernel image files and those

00:05:58,589 --> 00:06:05,069
things Hugh doesn't trust

00:06:00,710 --> 00:06:07,439
so that's virtualization but for the non

00:06:05,069 --> 00:06:09,419
virtualization use case which is TCG

00:06:07,439 --> 00:06:11,370
that's when you're not using a VM and

00:06:09,419 --> 00:06:14,039
you're using the software adjusting to

00:06:11,370 --> 00:06:15,720
the compiler at the moment there are no

00:06:14,039 --> 00:06:18,270
security claims there no kind of

00:06:15,720 --> 00:06:20,310
teas on security support the reason for

00:06:18,270 --> 00:06:22,640
that is largely historic because a lot

00:06:20,310 --> 00:06:25,290
of that colby code is the oldest code

00:06:22,640 --> 00:06:28,920
some of it doesn't get used very much or

00:06:25,290 --> 00:06:32,250
it gets used in use cases where you

00:06:28,920 --> 00:06:33,810
don't have security clients and so or

00:06:32,250 --> 00:06:40,320
it's on audited so at the moment that

00:06:33,810 --> 00:06:42,330
stuff is not considered but this changes

00:06:40,320 --> 00:06:44,670
over time so if the community of people

00:06:42,330 --> 00:06:46,770
do decide it's time we need to support

00:06:44,670 --> 00:06:48,540
sort of things that an effort can be put

00:06:46,770 --> 00:06:50,280
in and these these guarantees can change

00:06:48,540 --> 00:06:53,130
and this is also documented on that same

00:06:50,280 --> 00:07:00,480
security process wiki page that explains

00:06:53,130 --> 00:07:02,340
how to submit security okay so one thing

00:07:00,480 --> 00:07:05,700
we don't have though which would be very

00:07:02,340 --> 00:07:08,610
useful is a per feature list of the

00:07:05,700 --> 00:07:11,160
status weather features are considered

00:07:08,610 --> 00:07:12,840
safe for production it's not that people

00:07:11,160 --> 00:07:14,580
don't know this people do know what's

00:07:12,840 --> 00:07:16,200
safe and what's not so Hume you does

00:07:14,580 --> 00:07:17,669
have some experimental features in it

00:07:16,200 --> 00:07:20,220
but you shouldn't really deploy in

00:07:17,669 --> 00:07:22,290
production but the problem is today it's

00:07:20,220 --> 00:07:24,030
really down streams that know that and

00:07:22,290 --> 00:07:26,970
that have that knowledge and we don't

00:07:24,030 --> 00:07:28,470
have a single table or page on unit org

00:07:26,970 --> 00:07:32,100
where you can go to and say oh I want to

00:07:28,470 --> 00:07:34,110
use this feature is it supported and I

00:07:32,100 --> 00:07:36,960
think we can fix this problem and

00:07:34,110 --> 00:07:39,300
basically today it's the package

00:07:36,960 --> 00:07:41,640
maintainer is Linux distros or

00:07:39,300 --> 00:07:44,100
organizations that build queuing in from

00:07:41,640 --> 00:07:46,560
sourcing it and use the binary who

00:07:44,100 --> 00:07:50,490
decide which features to build in which

00:07:46,560 --> 00:07:52,020
features not to configure it so I think

00:07:50,490 --> 00:07:53,280
we need to get this information upstream

00:07:52,020 --> 00:07:55,860
it'll make it much easier for newcomers

00:07:53,280 --> 00:07:58,650
to see ok maybe I should have touched

00:07:55,860 --> 00:07:59,850
this feature because it's not it's not

00:07:58,650 --> 00:08:04,410
something it's something that's

00:07:59,850 --> 00:08:06,330
experimental it's not suitable ok before

00:08:04,410 --> 00:08:07,860
I move on to the technical parts are

00:08:06,330 --> 00:08:10,350
there any questions about the process

00:08:07,860 --> 00:08:12,919
and about the things I've talked about

00:08:10,350 --> 00:08:12,919
so far

00:08:13,950 --> 00:08:20,350
okay so I move on to to kind of describe

00:08:17,290 --> 00:08:21,550
the architecture so we're gonna look at

00:08:20,350 --> 00:08:23,080
the virtualization use case right

00:08:21,550 --> 00:08:26,590
because the non virtualization use case

00:08:23,080 --> 00:08:29,920
doesn't have any security claims

00:08:26,590 --> 00:08:31,390
associated so for virtualization what

00:08:29,920 --> 00:08:34,690
you have just as a refresher the

00:08:31,390 --> 00:08:37,000
overview is that you have a management

00:08:34,690 --> 00:08:39,280
tool that orchestrates the peons so it

00:08:37,000 --> 00:08:41,710
starts then it stopped them it lives

00:08:39,280 --> 00:08:44,980
might might live migrate stone it's over

00:08:41,710 --> 00:08:47,920
and then you have 1qe new process for a

00:08:44,980 --> 00:08:51,340
virtual machine inside community you

00:08:47,920 --> 00:08:54,250
have the guest round and the qumu also

00:08:51,340 --> 00:08:56,070
handles most of the device emulation so

00:08:54,250 --> 00:08:58,570
it contains the device emulation code

00:08:56,070 --> 00:09:01,360
and this code gets gets triggered it

00:08:58,570 --> 00:09:05,080
gets called when a guest tries to access

00:09:01,360 --> 00:09:07,180
hardware registers on its device it

00:09:05,080 --> 00:09:12,100
traps in the qmu humans able to have you

00:09:07,180 --> 00:09:14,290
like that okay and then Hugh itself

00:09:12,100 --> 00:09:15,610
doesn't run the there's the guest

00:09:14,290 --> 00:09:17,830
instructions the guess a few

00:09:15,610 --> 00:09:21,220
instructions they get executed by a

00:09:17,830 --> 00:09:23,170
driver like KVA and basically what that

00:09:21,220 --> 00:09:25,770
does is it switches the host CPU into

00:09:23,170 --> 00:09:29,380
guest mode so you can safely execute

00:09:25,770 --> 00:09:31,150
untrusted guest instructions so there's

00:09:29,380 --> 00:09:34,930
that driver component inside the host

00:09:31,150 --> 00:09:36,820
panel the other piece that's inside the

00:09:34,930 --> 00:09:40,240
host kernel is that there are a few

00:09:36,820 --> 00:09:41,620
internal devices so I said that device

00:09:40,240 --> 00:09:43,020
emulation offense including you but

00:09:41,620 --> 00:09:45,010
actually there are a few exceptions

00:09:43,020 --> 00:09:47,470
usually these exceptions are for

00:09:45,010 --> 00:09:50,110
performance reasons or they are because

00:09:47,470 --> 00:09:51,790
the kernel has certain internal API is

00:09:50,110 --> 00:09:53,560
they're not available to use your space

00:09:51,790 --> 00:09:55,660
and it would just not be possible to get

00:09:53,560 --> 00:09:58,590
that functionality from user space will

00:09:55,660 --> 00:10:01,270
have to do it inside the host part

00:09:58,590 --> 00:10:06,120
okay so those are the components that we

00:10:01,270 --> 00:10:06,120
have and I'm gonna be focusing on today

00:10:06,240 --> 00:10:11,200
okay so and the title is talk o'clock I

00:10:09,580 --> 00:10:12,220
mentioned isolation I mean this is this

00:10:11,200 --> 00:10:15,790
is the key thing

00:10:12,220 --> 00:10:17,980
how do we isolate the guest and I'm

00:10:15,790 --> 00:10:20,980
gonna go into a few of the aspects of

00:10:17,980 --> 00:10:22,690
isolation now first of all we want to

00:10:20,980 --> 00:10:23,540
make sure that whatever is running

00:10:22,690 --> 00:10:26,389
inside a virtual

00:10:23,540 --> 00:10:29,060
you cannot escape cannot compromise the

00:10:26,389 --> 00:10:30,649
host in a gain control of a system it's

00:10:29,060 --> 00:10:36,560
always going to be stuck in its virtual

00:10:30,649 --> 00:10:41,240
machine so the guest has a few attack

00:10:36,560 --> 00:10:43,880
surfaces for escaping interviews the

00:10:41,240 --> 00:10:46,040
main one is device emulation because

00:10:43,880 --> 00:10:47,930
your guest has a certain set of emulated

00:10:46,040 --> 00:10:50,630
devices and whenever it writes to

00:10:47,930 --> 00:10:52,519
hardware registers that drops into the

00:10:50,630 --> 00:10:53,899
device emulation ability inconvenient so

00:10:52,519 --> 00:10:55,430
if there are any security bugs in there

00:10:53,899 --> 00:10:58,279
that might be a way for the guest to

00:10:55,430 --> 00:11:00,440
gain control over the Kimia process and

00:10:58,279 --> 00:11:02,870
and just reminded it that Hume you

00:11:00,440 --> 00:11:06,800
process is running on post and it's a

00:11:02,870 --> 00:11:10,459
user space process their TCG of course

00:11:06,800 --> 00:11:12,139
is another attack vector but I'm not

00:11:10,459 --> 00:11:13,430
really gonna go into it because it's not

00:11:12,139 --> 00:11:15,529
it's not covered by the security

00:11:13,430 --> 00:11:21,470
guarantee only the virtualization stuff

00:11:15,529 --> 00:11:24,829
is kinda participating ok so what other

00:11:21,470 --> 00:11:27,350
aspects of isolation are important well

00:11:24,829 --> 00:11:30,350
a guest must not be able to attack

00:11:27,350 --> 00:11:31,670
another guest the traditional attack

00:11:30,350 --> 00:11:32,990
directors are always going to be there

00:11:31,670 --> 00:11:35,269
if you have the IP address of another

00:11:32,990 --> 00:11:37,339
guest and it's running a network service

00:11:35,269 --> 00:11:39,260
and you can connect to it then of course

00:11:37,339 --> 00:11:41,329
if it's unpatched or whatever you can

00:11:39,260 --> 00:11:43,069
still exploit the triggers traditional

00:11:41,329 --> 00:11:45,290
stuff is not what I'm talking about what

00:11:43,069 --> 00:11:48,350
I'm talking about our virtualization

00:11:45,290 --> 00:11:49,940
specific attack vectors a so you do have

00:11:48,350 --> 00:11:53,480
one here what if you managed to get

00:11:49,940 --> 00:11:55,550
control over human can you or can you

00:11:53,480 --> 00:11:57,470
process go and attack other teaming

00:11:55,550 --> 00:12:00,589
processes we need some isolation there

00:11:57,470 --> 00:12:02,660
otherwise once queue is compromised it's

00:12:00,589 --> 00:12:04,639
game over and all the other VMS are also

00:12:02,660 --> 00:12:07,839
probable so that's very important so I'm

00:12:04,639 --> 00:12:07,839
going to talk about how that's achieved

00:12:09,389 --> 00:12:12,929
and the final aspect maybe this should

00:12:11,699 --> 00:12:15,329
have been the first one because it's a

00:12:12,929 --> 00:12:18,179
very critical one these liens internal

00:12:15,329 --> 00:12:19,980
devices or or drivers right kayvyun

00:12:18,179 --> 00:12:22,139
kernel module and anything that's

00:12:19,980 --> 00:12:24,360
running in the kernel that's the most

00:12:22,139 --> 00:12:26,399
privileged part of the entire system and

00:12:24,360 --> 00:12:28,980
if that is compromised then your title

00:12:26,399 --> 00:12:31,410
posts including all the guests are also

00:12:28,980 --> 00:12:33,179
compromised so that's the most

00:12:31,410 --> 00:12:36,809
performant that's more security critical

00:12:33,179 --> 00:12:39,720
part I'm but if in this presentation I'm

00:12:36,809 --> 00:12:41,819
mainly focusing on QEMU though I'm not

00:12:39,720 --> 00:12:48,480
gonna go into KTM kernel module specific

00:12:41,819 --> 00:12:50,369
things so I've given an overview of the

00:12:48,480 --> 00:12:52,739
architecture and talked about isolation

00:12:50,369 --> 00:12:55,559
so the next step is to kind of talk

00:12:52,739 --> 00:12:59,339
about what what the security's design is

00:12:55,559 --> 00:13:02,549
how things how things work so one of the

00:12:59,339 --> 00:13:04,589
main properties that we have in in KVM

00:13:02,549 --> 00:13:06,329
is defense intent because we already

00:13:04,589 --> 00:13:08,339
have this virtualization spec we RNA

00:13:06,329 --> 00:13:11,279
from multiple components we have the

00:13:08,339 --> 00:13:13,649
management tool we have QEMU and then

00:13:11,279 --> 00:13:18,119
we've got the host kernel on it's like

00:13:13,649 --> 00:13:19,679
KBN so it's important that if one of

00:13:18,119 --> 00:13:21,480
these components is compromised it

00:13:19,679 --> 00:13:24,860
doesn't give you access to the entire

00:13:21,480 --> 00:13:27,209
system compromising one component should

00:13:24,860 --> 00:13:28,769
okay you get access that component but

00:13:27,209 --> 00:13:30,860
you'll have to find additional attacks

00:13:28,769 --> 00:13:33,660
to get into other components so that way

00:13:30,860 --> 00:13:35,160
a single compromised isn't enough to

00:13:33,660 --> 00:13:36,629
reach your goal as an attacker

00:13:35,160 --> 00:13:38,939
it makes things harder for attackers

00:13:36,629 --> 00:13:41,549
have multiple security bodies so this is

00:13:38,939 --> 00:13:44,279
a pretty well-known thing and just due

00:13:41,549 --> 00:13:46,319
to the the architecture of KP on and

00:13:44,279 --> 00:13:48,839
virtualization were able to take

00:13:46,319 --> 00:13:50,220
advantage of that so I want to highlight

00:13:48,839 --> 00:13:54,829
that but I'm gonna get into some

00:13:50,220 --> 00:13:59,519
specifics now so how is the cumulus

00:13:54,829 --> 00:14:01,259
isolated so the management tool this is

00:13:59,519 --> 00:14:02,850
not QD by the way this is not the QE

00:14:01,259 --> 00:14:04,470
program when it starts off it does a

00:14:02,850 --> 00:14:06,209
bunch of magic stuff and said this is

00:14:04,470 --> 00:14:07,660
something that the management tool needs

00:14:06,209 --> 00:14:09,010
to do and

00:14:07,660 --> 00:14:12,640
this is something that levert

00:14:09,010 --> 00:14:14,680
specifically already does today it's

00:14:12,640 --> 00:14:18,850
really important to run commute as an

00:14:14,680 --> 00:14:20,710
unprivileged user and that might seem

00:14:18,850 --> 00:14:22,390
obvious but it's often tempting to run

00:14:20,710 --> 00:14:24,220
queue as route if you're giving it

00:14:22,390 --> 00:14:26,500
access to some devices like some network

00:14:24,220 --> 00:14:27,940
interfaces or something because if you

00:14:26,500 --> 00:14:30,490
run out privileged what you have to do

00:14:27,940 --> 00:14:32,230
is you have to launch it on privilege

00:14:30,490 --> 00:14:34,510
and then you have to send it the file

00:14:32,230 --> 00:14:36,280
descriptors to just those view privilege

00:14:34,510 --> 00:14:37,930
devices are those few networked devices

00:14:36,280 --> 00:14:39,640
that you want to give it so if some of

00:14:37,930 --> 00:14:41,740
the people say all that that set up is

00:14:39,640 --> 00:14:43,870
too hard I'm just gonna launch key

00:14:41,740 --> 00:14:44,770
minutes we give it the path to a network

00:14:43,870 --> 00:14:47,230
interface that's a really bad idea

00:14:44,770 --> 00:14:49,150
because remember if CUNY gets

00:14:47,230 --> 00:14:51,070
compromised then the attacker would

00:14:49,150 --> 00:14:52,210
actually have root on the hose so it's

00:14:51,070 --> 00:14:57,010
very important to run Keaney on

00:14:52,210 --> 00:14:58,990
privilege but you can go beyond that I

00:14:57,010 --> 00:15:01,240
mean being unperfect user is not really

00:14:58,990 --> 00:15:03,460
enough because if you have two processes

00:15:01,240 --> 00:15:05,920
from the same user running on the same

00:15:03,460 --> 00:15:07,300
UID they can still interfere with each

00:15:05,920 --> 00:15:10,750
other they could make me trace each

00:15:07,300 --> 00:15:14,110
other or is that if you're using UNIX

00:15:10,750 --> 00:15:16,120
file permissions they could think it

00:15:14,110 --> 00:15:17,860
access to the same files on disk which

00:15:16,120 --> 00:15:20,230
you don't want you want to isolate the

00:15:17,860 --> 00:15:23,110
disk images that are assigned to each

00:15:20,230 --> 00:15:26,560
guest so guest a can all access guest B

00:15:23,110 --> 00:15:28,780
disk so one way of doing that is using

00:15:26,560 --> 00:15:29,980
selinux and so webpart implements this

00:15:28,780 --> 00:15:33,820
so there are a bunch of things that

00:15:29,980 --> 00:15:36,850
we'll do to actually confine the human

00:15:33,820 --> 00:15:39,790
process and ensure that even if the QA

00:15:36,850 --> 00:15:43,090
process were to attempt to open the disk

00:15:39,790 --> 00:15:44,500
image for example of another viana then

00:15:43,090 --> 00:15:45,910
that will fail because selinux were

00:15:44,500 --> 00:15:47,980
prevented and the same thing about

00:15:45,910 --> 00:15:49,870
Petros I mean debugging if Kim you were

00:15:47,980 --> 00:15:53,020
to pee trace another process that will

00:15:49,870 --> 00:15:56,200
also be and the final thing here is

00:15:53,020 --> 00:15:57,790
resource controls if if labert

00:15:56,200 --> 00:15:59,470
configures resource controls on

00:15:57,790 --> 00:16:01,950
communion and they're enforced by the

00:15:59,470 --> 00:16:03,940
host account and so gaining control of

00:16:01,950 --> 00:16:05,470
accumulate escaped they'll still be

00:16:03,940 --> 00:16:08,760
stuck with those resource limits so

00:16:05,470 --> 00:16:11,230
that's another important factor to have

00:16:08,760 --> 00:16:12,970
I'm so always check that your management

00:16:11,230 --> 00:16:15,460
tool is doing this especially if you run

00:16:12,970 --> 00:16:17,580
queueing you if you launch it manually

00:16:15,460 --> 00:16:19,470
or if you

00:16:17,580 --> 00:16:21,360
custom told because you may be missing

00:16:19,470 --> 00:16:25,140
some of this stuff and if you do if you

00:16:21,360 --> 00:16:28,200
do that then the you know in practice

00:16:25,140 --> 00:16:36,540
your actual security will be worse than

00:16:28,200 --> 00:16:38,460
if you say useful okay so let's let's

00:16:36,540 --> 00:16:42,000
move on to the next so the next kind of

00:16:38,460 --> 00:16:44,250
design idea that's important so every

00:16:42,000 --> 00:16:47,790
single virtual machine has a single

00:16:44,250 --> 00:16:49,500
human process dedicated to it so it's

00:16:47,790 --> 00:16:52,710
it's a one-to-one thing one VM is

00:16:49,500 --> 00:16:54,750
belongs to one human process in fact

00:16:52,710 --> 00:16:57,060
what that means what we can do is we can

00:16:54,750 --> 00:16:58,890
give that process only those resources

00:16:57,060 --> 00:17:00,960
that belong to the VM that means the

00:16:58,890 --> 00:17:03,660
digits network interfaces graphics cards

00:17:00,960 --> 00:17:05,339
whatever human you should not have

00:17:03,660 --> 00:17:07,200
access to anything else anything beyond

00:17:05,339 --> 00:17:09,420
that because otherwise if Cumae is

00:17:07,200 --> 00:17:11,010
compromised we will gain access as those

00:17:09,420 --> 00:17:14,130
resources that you shouldn't have access

00:17:11,010 --> 00:17:16,260
to so if we can do this if we can

00:17:14,130 --> 00:17:18,209
strictly give only the things the

00:17:16,260 --> 00:17:20,940
privileges that are needed to the cumene

00:17:18,209 --> 00:17:24,120
process then what happens is when you

00:17:20,940 --> 00:17:26,430
break out from the guest into qemu you

00:17:24,120 --> 00:17:28,010
haven't gained very much because you

00:17:26,430 --> 00:17:31,230
just have access to those same resources

00:17:28,010 --> 00:17:32,760
now you use the native API to use

00:17:31,230 --> 00:17:34,520
syscalls to access those same resources

00:17:32,760 --> 00:17:36,480
but you haven't gained any other

00:17:34,520 --> 00:17:38,790
resources that you shouldn't be allowed

00:17:36,480 --> 00:17:41,730
to access so this is in a very important

00:17:38,790 --> 00:17:44,700
principle the problem is that this is

00:17:41,730 --> 00:17:46,380
just theory because they practice in the

00:17:44,700 --> 00:17:48,780
Linux user space environment it's

00:17:46,380 --> 00:17:52,310
actually quite hard to confine things to

00:17:48,780 --> 00:17:54,750
that extent so in reality the guest

00:17:52,310 --> 00:17:57,120
compromising team you will gain a few

00:17:54,750 --> 00:18:00,300
things that it could use to then further

00:17:57,120 --> 00:18:03,330
attack those most obvious things the

00:18:00,300 --> 00:18:04,740
system call interface right so you're no

00:18:03,330 --> 00:18:08,040
longer inside the guest you know in the

00:18:04,740 --> 00:18:11,220
CUNY user space process you can do any

00:18:08,040 --> 00:18:12,630
system call that you want to so any of

00:18:11,220 --> 00:18:15,630
these kind of native api's are now

00:18:12,630 --> 00:18:17,910
available in order to in order to

00:18:15,630 --> 00:18:21,780
prevent that and mitigate that both as

00:18:17,910 --> 00:18:24,840
you guys can be used so Lippert also

00:18:21,780 --> 00:18:27,570
supports SATCOM seccomp is actually set

00:18:24,840 --> 00:18:28,320
up by Hugh EMU when it starts off so

00:18:27,570 --> 00:18:32,130
a little bit different it's not

00:18:28,320 --> 00:18:35,130
externally setup but what it does is

00:18:32,130 --> 00:18:37,950
speaking it can blacklist certain system

00:18:35,130 --> 00:18:40,380
calls system calls that Hume you should

00:18:37,950 --> 00:18:43,200
never under any circumstances use and so

00:18:40,380 --> 00:18:45,210
you can at least you can at least reduce

00:18:43,200 --> 00:18:46,620
the kernel attack surface you can at

00:18:45,210 --> 00:18:49,560
least get rid of some system calls and

00:18:46,620 --> 00:18:52,370
you can be sure that compromised Cumaean

00:18:49,560 --> 00:18:54,570
cannot make those calls in those times

00:18:52,370 --> 00:18:56,070
there's actually a whole talk on it so

00:18:54,570 --> 00:18:58,260
if you're interested in in that aspect

00:18:56,070 --> 00:18:59,700
on SEC home you can check out at

00:18:58,260 --> 00:19:02,940
Barbara's and walk

00:18:59,700 --> 00:19:05,490
so basically goes into that again it's

00:19:02,940 --> 00:19:09,890
kind of a theory versus practice thing

00:19:05,490 --> 00:19:12,930
where it's very hard to to confine the

00:19:09,890 --> 00:19:15,080
Kami process all the way down to the

00:19:12,930 --> 00:19:18,890
theoretical minimum that you would like

00:19:15,080 --> 00:19:21,180
so he goes into that a little bit more

00:19:18,890 --> 00:19:22,920
let me give you another example if

00:19:21,180 --> 00:19:26,940
you're wondering so what else do I gain

00:19:22,920 --> 00:19:30,480
if I break out into cumin if we're using

00:19:26,940 --> 00:19:32,610
network storage and you're using Q

00:19:30,480 --> 00:19:36,990
driver so say you're using set for

00:19:32,610 --> 00:19:38,970
example and you're using cuny's RBD

00:19:36,990 --> 00:19:42,330
driver then there will be a file

00:19:38,970 --> 00:19:46,890
descriptor and an IP address for talking

00:19:42,330 --> 00:19:49,020
to whatever whatever a server the second

00:19:46,890 --> 00:19:50,670
client is talking to so now that you've

00:19:49,020 --> 00:19:52,820
escaped you can also talk to it and

00:19:50,670 --> 00:19:54,570
imagine that on you on your stuff

00:19:52,820 --> 00:19:58,350
deployment you've got lots of other

00:19:54,570 --> 00:19:59,610
disks all the other guests business when

00:19:58,350 --> 00:20:01,820
you were inside the guest

00:19:59,610 --> 00:20:04,860
you only had say a vertical block device

00:20:01,820 --> 00:20:06,210
you have no way of numerating or even

00:20:04,860 --> 00:20:08,100
getting to all those other days but now

00:20:06,210 --> 00:20:10,950
that you've escaped into Q Mew you have

00:20:08,100 --> 00:20:13,500
the ability to connect it and you could

00:20:10,950 --> 00:20:16,170
try to look at other discs so the best

00:20:13,500 --> 00:20:18,510
practice here in order to to mitigate

00:20:16,170 --> 00:20:21,060
this and prevent any any issues with

00:20:18,510 --> 00:20:24,000
this is to always use authentication if

00:20:21,060 --> 00:20:25,200
you're using network disk because you

00:20:24,000 --> 00:20:27,060
basically have to assume that you're

00:20:25,200 --> 00:20:28,560
beyond the eventually would be able to

00:20:27,060 --> 00:20:31,880
just connect to the server

00:20:28,560 --> 00:20:31,880
and try to gain access and

00:20:32,390 --> 00:20:36,060
so you can do that with I scuzzy you can

00:20:34,800 --> 00:20:37,920
do with that it's possible to put

00:20:36,060 --> 00:20:39,390
passwords on it's over so forth but

00:20:37,920 --> 00:20:44,040
that's that's that's a very important

00:20:39,390 --> 00:20:45,780
thing to realize okay so the final thing

00:20:44,040 --> 00:20:49,170
is that unfortunately some of the

00:20:45,780 --> 00:20:51,600
resource limits that we offer like block

00:20:49,170 --> 00:20:54,360
IO snarling they are implemented inside

00:20:51,600 --> 00:20:56,550
the QA process so if you compromise

00:20:54,360 --> 00:20:58,410
community you can bypass them so

00:20:56,550 --> 00:21:00,360
suddenly you're no longer limited to

00:20:58,410 --> 00:21:02,970
whatever it was 50 megabytes per second

00:21:00,360 --> 00:21:04,470
disk i/o bandwidth you can now just skip

00:21:02,970 --> 00:21:07,080
that because you you've compromised

00:21:04,470 --> 00:21:11,250
commute you have access to that disk

00:21:07,080 --> 00:21:12,810
file and if there are solutions to that

00:21:11,250 --> 00:21:15,420
as well for example you can use the

00:21:12,810 --> 00:21:19,710
kernel block IO controller and Lebert

00:21:15,420 --> 00:21:22,320
supports that so so that's one option if

00:21:19,710 --> 00:21:24,750
you're not using another network storage

00:21:22,320 --> 00:21:26,430
if using network storage you could see

00:21:24,750 --> 00:21:30,060
if the server side supports rate

00:21:26,430 --> 00:21:34,560
limiting if it's very critical for

00:21:30,060 --> 00:21:41,040
security that people don't abuse don't

00:21:34,560 --> 00:21:42,140
break those limits so this whole thing

00:21:41,040 --> 00:21:45,180
about the principle of least privilege

00:21:42,140 --> 00:21:47,430
in theory in reality I think is quite

00:21:45,180 --> 00:21:49,680
important for developers to understand

00:21:47,430 --> 00:21:51,540
because as we have new features to

00:21:49,680 --> 00:21:54,750
queuing we should always keep in mind am

00:21:51,540 --> 00:21:57,060
I giving qemu access only to the

00:21:54,750 --> 00:21:59,670
resources that belong to the guest or am

00:21:57,060 --> 00:22:02,040
I giving a queuing access to something

00:21:59,670 --> 00:22:04,200
else you me should be enforcing anything

00:22:02,040 --> 00:22:05,970
keying we shouldn't really be the last

00:22:04,200 --> 00:22:09,540
line of defense preventing the guest

00:22:05,970 --> 00:22:10,700
from gaining access to something so we

00:22:09,540 --> 00:22:12,960
need to give it as little as possible

00:22:10,700 --> 00:22:14,580
and if there are exceptions for

00:22:12,960 --> 00:22:18,180
practical reasons like what I've

00:22:14,580 --> 00:22:19,860
described documenting them is the most

00:22:18,180 --> 00:22:22,730
important thing so that people want to

00:22:19,860 --> 00:22:22,730
get FOIA they're aware

00:22:25,090 --> 00:22:29,960
okay so we've talked a bit about the

00:22:27,320 --> 00:22:32,919
design and the general architecture I'm

00:22:29,960 --> 00:22:35,659
going to move on to the next section

00:22:32,919 --> 00:22:38,139
did anyone have any questions or

00:22:35,659 --> 00:22:38,139
comments

00:22:50,010 --> 00:22:55,480
yeah so Paolo Paolo mentioned I'll just

00:22:53,260 --> 00:22:57,940
repeat the question so Paolo said that

00:22:55,480 --> 00:22:59,710
defense and that works for the qmu

00:22:57,940 --> 00:23:01,780
process because it's a host userspace

00:22:59,710 --> 00:23:12,460
process and there's additional layers

00:23:01,780 --> 00:23:15,090
that we can still have in between the

00:23:12,460 --> 00:23:18,460
point is if if you go and you attack

00:23:15,090 --> 00:23:21,130
became in kernel module directly and you

00:23:18,460 --> 00:23:22,150
gain access to it there is there are no

00:23:21,130 --> 00:23:24,360
more layers of defense

00:23:22,150 --> 00:23:27,010
you're already in the host kernel so

00:23:24,360 --> 00:23:29,380
this is the most security critical part

00:23:27,010 --> 00:23:31,330
of the system and we don't have original

00:23:29,380 --> 00:23:34,180
layers of defense there one thing you

00:23:31,330 --> 00:23:35,680
can do though is I mentioned internal

00:23:34,180 --> 00:23:38,760
devices we host neck is the most

00:23:35,680 --> 00:23:41,230
well-known one that people use now

00:23:38,760 --> 00:23:44,230
depending on how paranoid you are and

00:23:41,230 --> 00:23:46,450
how important this is you could all to

00:23:44,230 --> 00:23:48,580
not use that device because typically we

00:23:46,450 --> 00:23:50,620
also have a user space implementation of

00:23:48,580 --> 00:23:52,690
that and so that user space

00:23:50,620 --> 00:23:55,120
implementation will probably be a bit

00:23:52,690 --> 00:23:57,820
slower these devices are usually there

00:23:55,120 --> 00:23:59,050
for performance reasons but you'll have

00:23:57,820 --> 00:24:01,750
better security because now you have

00:23:59,050 --> 00:24:04,200
defense and back so that's a choice that

00:24:01,750 --> 00:24:04,200
you can make

00:24:11,460 --> 00:24:17,620
yes so so there are some interactions

00:24:14,980 --> 00:24:20,320
obviously that the KVM kernel module has

00:24:17,620 --> 00:24:22,390
with the guest but there are also some

00:24:20,320 --> 00:24:23,770
interactions using IOC tales that the

00:24:22,390 --> 00:24:27,270
Keena process has with guests actually

00:24:23,770 --> 00:24:27,270
they're two separate attack surfaces

00:24:28,450 --> 00:24:31,450
yes

00:24:40,260 --> 00:24:47,980
once taught another thing or once a

00:24:45,790 --> 00:24:50,350
video physical device is busting to the

00:24:47,980 --> 00:24:53,559
guests our security model is completely

00:24:50,350 --> 00:24:58,120
changed okay yeah yes we use device

00:24:53,559 --> 00:25:00,790
pass-through then of course that has

00:24:58,120 --> 00:25:03,570
that has implications because you no

00:25:00,790 --> 00:25:07,830
longer have a software layer that is

00:25:03,570 --> 00:25:07,830
mediating the access and limiting things

00:25:09,929 --> 00:25:13,510
okay

00:25:11,170 --> 00:25:14,860
so I'll move on to the next section for

00:25:13,510 --> 00:25:17,530
the next section I want to go a little

00:25:14,860 --> 00:25:19,240
bit more in depth and what I did to

00:25:17,530 --> 00:25:22,420
start this is I went and looked at the

00:25:19,240 --> 00:25:24,160
security history of QEMU I looked at the

00:25:22,420 --> 00:25:26,470
security bugs that have been reported I

00:25:24,160 --> 00:25:31,390
looked at the severity and what the

00:25:26,470 --> 00:25:33,220
cause was and I want to kind of

00:25:31,390 --> 00:25:35,890
highlight a few and then we can go into

00:25:33,220 --> 00:25:38,200
discussion on what it means one of the

00:25:35,890 --> 00:25:41,559
well known ones Benesch came out a few

00:25:38,200 --> 00:25:45,280
years ago it was a bug in the floppy

00:25:41,559 --> 00:25:46,750
disk controller emulation code I think

00:25:45,280 --> 00:25:48,610
the reason a lot of people got scared is

00:25:46,750 --> 00:25:50,350
because the floppy disk controller is

00:25:48,610 --> 00:25:52,900
there by default in a lot of machines

00:25:50,350 --> 00:25:55,150
and so everyone's like oh I'm not using

00:25:52,900 --> 00:25:58,590
this but it has a security bug so this

00:25:55,150 --> 00:26:02,410
is a bad thing how do I get rid of it

00:25:58,590 --> 00:26:04,720
the actual bug itself was a typical C C

00:26:02,410 --> 00:26:06,850
programming bug it was a heap buffer

00:26:04,720 --> 00:26:09,040
overflow and it's gets trigger ball

00:26:06,850 --> 00:26:11,530
because this function here the FD

00:26:09,040 --> 00:26:14,320
control write theta function it's

00:26:11,530 --> 00:26:16,120
executed when the guest rights to harder

00:26:14,320 --> 00:26:18,700
register on the floppy controller and

00:26:16,120 --> 00:26:20,650
what was happening is that there were

00:26:18,700 --> 00:26:22,990
some floppy controller commands that

00:26:20,650 --> 00:26:25,540
never reset the array index data pause

00:26:22,990 --> 00:26:27,460
and so if you just keep calling them you

00:26:25,540 --> 00:26:28,450
would be able to overflow the array and

00:26:27,460 --> 00:26:31,750
then you would be able to write to

00:26:28,450 --> 00:26:33,670
memory beyond the entity array so

00:26:31,750 --> 00:26:35,530
potentially you could then get food

00:26:33,670 --> 00:26:39,020
execution if maybe there was a function

00:26:35,530 --> 00:26:42,360
pointer or beyond

00:26:39,020 --> 00:26:44,190
so this kind of leads us on to what are

00:26:42,360 --> 00:26:46,260
the important things for device

00:26:44,190 --> 00:26:48,000
simulation code either because you're

00:26:46,260 --> 00:26:49,530
reviewing it or you're auditing it for

00:26:48,000 --> 00:26:52,700
security or because you're a developer

00:26:49,530 --> 00:26:54,780
and you're emulating a new device so

00:26:52,700 --> 00:26:56,640
I'll go through some of the things that

00:26:54,780 --> 00:26:59,330
I think are quite important so sadly

00:26:56,640 --> 00:27:02,190
number one the suite C programming bugs

00:26:59,330 --> 00:27:04,740
if you look at their RC ve history a lot

00:27:02,190 --> 00:27:07,590
of them are but the overflows integer

00:27:04,740 --> 00:27:09,630
overflows use after free these these

00:27:07,590 --> 00:27:13,100
kinds of typical Snee bugs so that's the

00:27:09,630 --> 00:27:15,990
number one thing to still watch out for

00:27:13,100 --> 00:27:17,970
number two this one is obvious is that

00:27:15,990 --> 00:27:21,540
we don't trust the guest so it's

00:27:17,970 --> 00:27:23,130
important to validate all inputs as an

00:27:21,540 --> 00:27:25,740
example of this say you're emulating a

00:27:23,130 --> 00:27:28,320
device that has four execution units and

00:27:25,740 --> 00:27:30,210
it has a hardware register that lets you

00:27:28,320 --> 00:27:32,520
select elects the driver select which

00:27:30,210 --> 00:27:34,049
unit you're currently talking to so Kim

00:27:32,520 --> 00:27:35,490
you should never trust that number it

00:27:34,049 --> 00:27:37,530
should always validate to make sure it's

00:27:35,490 --> 00:27:39,030
only zero one two or three you know one

00:27:37,530 --> 00:27:41,580
of the four units it shouldn't just

00:27:39,030 --> 00:27:43,820
index into our array because then the

00:27:41,580 --> 00:27:46,500
guest could put in a bogus number and

00:27:43,820 --> 00:27:49,110
you will go beyond the end of the array

00:27:46,500 --> 00:27:52,400
so we always have to validate in inputs

00:27:49,110 --> 00:27:54,419
from guests this is very widely known so

00:27:52,400 --> 00:27:56,160
when there's a bug it's typically

00:27:54,419 --> 00:27:59,160
because this is like the one case that

00:27:56,160 --> 00:28:00,750
was brought in this device but let me

00:27:59,160 --> 00:28:03,840
move on to some more interesting ones to

00:28:00,750 --> 00:28:06,809
some more subtle ones that are not so

00:28:03,840 --> 00:28:09,059
well known when you implement device

00:28:06,809 --> 00:28:11,309
emulation it's usually understood that

00:28:09,059 --> 00:28:13,890
there's a certain order in which the

00:28:11,309 --> 00:28:15,929
driver will do things in order to do its

00:28:13,890 --> 00:28:20,100
business so in order to send packets or

00:28:15,929 --> 00:28:24,510
in order to update the frame buffer or

00:28:20,100 --> 00:28:26,010
whatever your device does however as a

00:28:24,510 --> 00:28:27,419
driver writer you can kind of stick to

00:28:26,010 --> 00:28:31,350
that you'll just initialize the device

00:28:27,419 --> 00:28:34,650
and in the way that the hardware specs

00:28:31,350 --> 00:28:37,350
recommend you do it and so on but as an

00:28:34,650 --> 00:28:39,780
emulation author you can't it can't rely

00:28:37,350 --> 00:28:41,880
on that you have to anticipate that any

00:28:39,780 --> 00:28:44,280
possible hardware register on your

00:28:41,880 --> 00:28:45,799
device could be accessed at any time

00:28:44,280 --> 00:28:49,249
even at times where it doesn't

00:28:45,799 --> 00:28:50,749
sense for them to be accessed and they

00:28:49,249 --> 00:28:54,769
could be accessed in the wrong order as

00:28:50,749 --> 00:28:57,919
well so malicious guests could try to

00:28:54,769 --> 00:29:00,080
trigger bugs so one example for this

00:28:57,919 --> 00:29:02,269
would be if you if you have a device

00:29:00,080 --> 00:29:04,249
that takes a request and some kind of

00:29:02,269 --> 00:29:06,080
i/o request and then that request is

00:29:04,249 --> 00:29:07,759
pending for you know a couple of

00:29:06,080 --> 00:29:09,559
milliseconds or whatever and it is

00:29:07,759 --> 00:29:12,110
expecting interrupts well during that

00:29:09,559 --> 00:29:13,730
time what happens if the device already

00:29:12,110 --> 00:29:15,230
starts writing to the registers again

00:29:13,730 --> 00:29:16,549
and it gives you another request you

00:29:15,230 --> 00:29:18,739
need to make sure that your device in

00:29:16,549 --> 00:29:21,019
relation code doesn't corrupt whatever

00:29:18,739 --> 00:29:22,909
is in progress doesn't leak the the

00:29:21,019 --> 00:29:24,350
pending thing right you need to

00:29:22,909 --> 00:29:26,989
basically make sure that the state

00:29:24,350 --> 00:29:30,379
machine all possible transitions are

00:29:26,989 --> 00:29:33,169
covered so this one is really hard to

00:29:30,379 --> 00:29:35,119
find with the source code analysis tools

00:29:33,169 --> 00:29:36,409
a static scanners because they're mainly

00:29:35,119 --> 00:29:39,499
looking for sea bugs you're not gonna

00:29:36,409 --> 00:29:43,330
swap it so that's this is where human

00:29:39,499 --> 00:29:46,940
view errs and auditing is very important

00:29:43,330 --> 00:29:49,460
another another issue in devices is

00:29:46,940 --> 00:29:51,739
validating the light migration the end

00:29:49,460 --> 00:29:53,419
state they gonna gets loaded and

00:29:51,739 --> 00:29:56,840
historically we haven't always done that

00:29:53,419 --> 00:29:58,220
very strictly and then for reliability

00:29:56,840 --> 00:29:59,419
reasons we've done it more because if

00:29:58,220 --> 00:30:00,739
light immigration was not working and

00:29:59,419 --> 00:30:02,629
you're having really hard time debugging

00:30:00,739 --> 00:30:04,850
it wouldn't be a good idea to validate

00:30:02,629 --> 00:30:06,470
the inputs and so over time we started

00:30:04,850 --> 00:30:08,059
to do that more it turns out it's

00:30:06,470 --> 00:30:13,759
actually important for security too

00:30:08,059 --> 00:30:15,710
because one one scenario is someone

00:30:13,759 --> 00:30:17,269
might create a disk image file make it

00:30:15,710 --> 00:30:19,070
available for download and it contains a

00:30:17,269 --> 00:30:21,649
snapshot and people want to load that's

00:30:19,070 --> 00:30:24,230
not y'all see what it does well if a

00:30:21,649 --> 00:30:26,419
malicious you know user create a visitor

00:30:24,230 --> 00:30:29,239
file that's not true contain cross

00:30:26,419 --> 00:30:31,159
migration data and you don't want it you

00:30:29,239 --> 00:30:34,600
don't want that disk image restoring

00:30:31,159 --> 00:30:34,600
that snap try to compromise

00:30:35,230 --> 00:30:39,580
another kind of subtle one luckily our

00:30:37,779 --> 00:30:41,110
memory API is designed in a way so it's

00:30:39,580 --> 00:30:43,570
hard to shoot yourself in the foot here

00:30:41,110 --> 00:30:45,880
and it's it's it happens rarely but does

00:30:43,570 --> 00:30:48,610
happen sometimes it's just like in the

00:30:45,880 --> 00:30:50,710
kernel and this is called boundary if

00:30:48,610 --> 00:30:53,440
you in a kernel you can't really trust

00:30:50,710 --> 00:30:55,690
user memory you typically would copy in

00:30:53,440 --> 00:30:57,549
what the user has requested from you if

00:30:55,690 --> 00:30:59,470
they give you a struct and then you

00:30:57,549 --> 00:31:00,909
would process it your own local copy the

00:30:59,470 --> 00:31:02,409
reason for doing nice other threads

00:31:00,909 --> 00:31:05,110
could still modify that memory we have

00:31:02,409 --> 00:31:07,510
the same thing in queueing when the

00:31:05,110 --> 00:31:11,010
device simulation runs other VC few

00:31:07,510 --> 00:31:14,049
threads might still be like so if you

00:31:11,010 --> 00:31:16,000
fetch a feel and then you perform a

00:31:14,049 --> 00:31:18,789
check on it to go do some other things

00:31:16,000 --> 00:31:20,620
and then you fetch it again it could

00:31:18,789 --> 00:31:23,380
have changed the second time you fetch

00:31:20,620 --> 00:31:25,600
it and so they can bypass or check with

00:31:23,380 --> 00:31:28,299
a race condition so it's important to

00:31:25,600 --> 00:31:32,289
copy in data from the guest do not trust

00:31:28,299 --> 00:31:34,990
guest memory okay so I'm gonna go on now

00:31:32,289 --> 00:31:37,149
to kind of perform the security

00:31:34,990 --> 00:31:39,370
improvements and upcoming things that

00:31:37,149 --> 00:31:41,679
are happening but does anyone else have

00:31:39,370 --> 00:31:44,440
any things they want to shout out and

00:31:41,679 --> 00:31:47,919
and share something that I've missed

00:31:44,440 --> 00:31:50,440
here that is important when writing the

00:31:47,919 --> 00:31:52,029
by stimulation protocol heystop so it's

00:31:50,440 --> 00:31:54,539
that's rated for device simulation code

00:31:52,029 --> 00:31:58,419
but you were mentioning earlier about

00:31:54,539 --> 00:32:00,309
things like ice-crazy etcetera so if at

00:31:58,419 --> 00:32:03,519
some point later we decide to have some

00:32:00,309 --> 00:32:06,490
of the management of sans and devices in

00:32:03,519 --> 00:32:09,519
the guest instead of in the host then

00:32:06,490 --> 00:32:12,220
you have also to add some security layer

00:32:09,519 --> 00:32:15,899
there I don't think it exists today but

00:32:12,220 --> 00:32:15,899
at some point this might happen yeah

00:32:18,820 --> 00:32:25,539
but there are two things that can help

00:32:21,649 --> 00:32:29,090
with some of those things one is

00:32:25,539 --> 00:32:32,539
actually related the users is England s

00:32:29,090 --> 00:32:39,679
sources hardening techniques like the

00:32:32,539 --> 00:32:44,179
control flow integrity you know memory

00:32:39,679 --> 00:32:46,549
safety many may be adversely dies our

00:32:44,179 --> 00:32:50,179
fortify source and so that's something

00:32:46,549 --> 00:32:52,730
that can users can do to harden the cue

00:32:50,179 --> 00:32:53,299
in general and the second thing is

00:32:52,730 --> 00:32:57,100
Fozzie

00:32:53,299 --> 00:33:00,980
it can help invalid inputs and

00:32:57,100 --> 00:33:05,690
unexpected states is there any practice

00:33:00,980 --> 00:33:09,019
of using those things yeah so why don't

00:33:05,690 --> 00:33:12,169
I go to that section so what can we do

00:33:09,019 --> 00:33:13,820
to improve cuny security there's a kind

00:33:12,169 --> 00:33:15,590
of split this into three classes of

00:33:13,820 --> 00:33:18,259
things one is finding bugs early so you

00:33:15,590 --> 00:33:21,049
mentioned fuzzing we have this device

00:33:18,259 --> 00:33:23,419
emulation code but if what we do is we

00:33:21,049 --> 00:33:25,669
write the code and then we boot Linux or

00:33:23,419 --> 00:33:26,869
Windows or something and say oh it works

00:33:25,669 --> 00:33:29,570
great my job is done

00:33:26,869 --> 00:33:31,460
then we're missing a whole bunch of

00:33:29,570 --> 00:33:34,309
potential bugs that could be in that

00:33:31,460 --> 00:33:36,320
device and so what fuzzing is about it's

00:33:34,309 --> 00:33:38,299
random input testing you send random

00:33:36,320 --> 00:33:40,059
inputs to a program and you see if they

00:33:38,299 --> 00:33:42,679
crash the program or get it to misbehave

00:33:40,059 --> 00:33:44,389
and by doing that because you're sending

00:33:42,679 --> 00:33:46,850
it random inputs you're exploring the

00:33:44,389 --> 00:33:50,389
entire input space hopefully you'll find

00:33:46,850 --> 00:33:53,419
crashes and issues it's not done

00:33:50,389 --> 00:33:55,249
upstream it's done downstream so there

00:33:53,419 --> 00:33:57,230
are some organizations some users of

00:33:55,249 --> 00:34:00,350
queuing you have specific devices that

00:33:57,230 --> 00:34:02,179
they care about and they fuzz them but

00:34:00,350 --> 00:34:06,129
we don't have an upstream fuzzing effort

00:34:02,179 --> 00:34:08,780
I know that there is a Google OSS bus

00:34:06,129 --> 00:34:10,010
and I think some people have played with

00:34:08,780 --> 00:34:13,040
it a little bit to see if we can hook

00:34:10,010 --> 00:34:15,710
into it because then we get the compute

00:34:13,040 --> 00:34:17,960
resources to actually run fuzzing and we

00:34:15,710 --> 00:34:21,110
could do it upstream but that's kind of

00:34:17,960 --> 00:34:23,760
an open project if anyone is in

00:34:21,110 --> 00:34:26,340
so another thing is static analysis

00:34:23,760 --> 00:34:26,760
tools and that's already widely used

00:34:26,340 --> 00:34:29,850
today

00:34:26,760 --> 00:34:32,159
so there are static analysis tools that

00:34:29,850 --> 00:34:34,260
are being run on the Kami codebase to

00:34:32,159 --> 00:34:35,550
make sure that C programming bugs and

00:34:34,260 --> 00:34:39,720
things that can be automatically

00:34:35,550 --> 00:34:41,280
detected are being found and then those

00:34:39,720 --> 00:34:43,440
bugs are being worked through and the

00:34:41,280 --> 00:34:46,850
patches get upstream so that's working

00:34:43,440 --> 00:34:50,070
on a code audits we have code review

00:34:46,850 --> 00:34:52,590
patches do not get merged there has to

00:34:50,070 --> 00:34:53,879
be at least one review but often times

00:34:52,590 --> 00:34:56,040
they're actually more than one reviews

00:34:53,879 --> 00:34:57,840
so security bugs also get found a review

00:34:56,040 --> 00:35:03,570
but there's no kind of formal auditing

00:34:57,840 --> 00:35:06,060
going on especially not upstream okay so

00:35:03,570 --> 00:35:07,710
that was how do we find bugs early what

00:35:06,060 --> 00:35:10,020
about how do we mitigate the impact of

00:35:07,710 --> 00:35:12,000
bugs because just finding bugs is not

00:35:10,020 --> 00:35:14,550
enough you're not gonna find all bugs so

00:35:12,000 --> 00:35:17,160
you need to also reduce the severity of

00:35:14,550 --> 00:35:18,930
bugs when they do happen so that's what

00:35:17,160 --> 00:35:21,900
mitigating the impact of bugs is all

00:35:18,930 --> 00:35:23,850
about I talked about sound boxing so as

00:35:21,900 --> 00:35:27,840
your Linux and SATCOM trying to define

00:35:23,850 --> 00:35:32,130
the cue music an be done once you think

00:35:27,840 --> 00:35:34,230
control is minimized but those those

00:35:32,130 --> 00:35:36,270
interfaces and the capabilities of those

00:35:34,230 --> 00:35:38,370
systems aren't so that continues to

00:35:36,270 --> 00:35:40,860
evolve so if Linux gets new capabilities

00:35:38,370 --> 00:35:43,320
hopefully someone can apply them on Cuba

00:35:40,860 --> 00:35:46,260
and jail and the sandbox schema more

00:35:43,320 --> 00:35:49,320
tightly one way of doing this might be

00:35:46,260 --> 00:35:51,180
multi-process community where instead of

00:35:49,320 --> 00:35:53,280
having a single cleaning process that is

00:35:51,180 --> 00:35:54,900
doing a lot of things we have multiple

00:35:53,280 --> 00:35:57,990
processes because then these multiple

00:35:54,900 --> 00:35:59,520
processes have specific tasks and so the

00:35:57,990 --> 00:36:02,490
number of system calls that they require

00:35:59,520 --> 00:36:07,020
is smaller and you have less problems

00:36:02,490 --> 00:36:11,850
confining this sandbox basically so that

00:36:07,020 --> 00:36:13,860
could improve we also have modules so

00:36:11,850 --> 00:36:15,660
modular Q is something we've had for a

00:36:13,860 --> 00:36:17,880
couple of years now it's not why they

00:36:15,660 --> 00:36:20,790
used it but the idea is when you build Q

00:36:17,880 --> 00:36:24,060
me you have a core Q binary and then you

00:36:20,790 --> 00:36:26,910
have shared libraries for features and

00:36:24,060 --> 00:36:29,220
they get roaded out right now for

00:36:26,910 --> 00:36:31,160
security the good thing about this is

00:36:29,220 --> 00:36:34,580
that if your process is compromised

00:36:31,160 --> 00:36:36,800
the code footprint is smaller and so it

00:36:34,580 --> 00:36:39,200
makes it harder to write certain types

00:36:36,800 --> 00:36:42,200
of exploits exploits that we use pieces

00:36:39,200 --> 00:36:44,630
of codes that are already in memory so

00:36:42,200 --> 00:36:47,410
by by reducing the footprint we make it

00:36:44,630 --> 00:36:47,410
a bit harder to explain

00:36:48,610 --> 00:36:54,080
you mean historically also has been

00:36:51,310 --> 00:36:56,180
quite monolithic we haven't always added

00:36:54,080 --> 00:36:58,100
features to compile out and disable

00:36:56,180 --> 00:37:00,080
things so for example now it's possible

00:36:58,100 --> 00:37:02,180
to disable TC genes but that took a long

00:37:00,080 --> 00:37:04,040
time for a long time you always have the

00:37:02,180 --> 00:37:06,980
TC gene code in there even if you

00:37:04,040 --> 00:37:10,340
weren't using it so you can do this

00:37:06,980 --> 00:37:12,620
statically at compile time as well and a

00:37:10,340 --> 00:37:15,020
lot more work is possible so if people

00:37:12,620 --> 00:37:18,140
want to be able to build without certain

00:37:15,020 --> 00:37:20,690
features or devices you know there are

00:37:18,140 --> 00:37:25,640
ways of doing it and you know patches

00:37:20,690 --> 00:37:27,310
will can be sent upstream to do that so

00:37:25,640 --> 00:37:30,290
that was the mitigating but what about

00:37:27,310 --> 00:37:32,090
eliminating entire classes of bugs so

00:37:30,290 --> 00:37:33,560
that we don't even have these headaches

00:37:32,090 --> 00:37:37,550
and don't even have to worry about it

00:37:33,560 --> 00:37:39,160
there are some things we can do here one

00:37:37,550 --> 00:37:41,600
thing that always gets discussed is

00:37:39,160 --> 00:37:43,760
using a safe programming language or a

00:37:41,600 --> 00:37:47,030
safer or programming language that

00:37:43,760 --> 00:37:49,160
eliminates some of these bugs so rust is

00:37:47,030 --> 00:37:50,960
the one that's been kind of most most

00:37:49,160 --> 00:37:53,930
seriously discussed because it seems to

00:37:50,960 --> 00:37:56,410
have most of the qualities that we want

00:37:53,930 --> 00:38:00,320
the challenge there is that we have a

00:37:56,410 --> 00:38:03,560
large code base over a million lines of

00:38:00,320 --> 00:38:05,480
code and so that's not gonna migrate to

00:38:03,560 --> 00:38:09,140
a new language right away maybe the way

00:38:05,480 --> 00:38:11,120
to attack it is for us to start using

00:38:09,140 --> 00:38:13,360
the new language on new features new

00:38:11,120 --> 00:38:17,240
processes that are separate from that

00:38:13,360 --> 00:38:19,040
the original human by name something we

00:38:17,240 --> 00:38:21,530
can do though which is a lot less impact

00:38:19,040 --> 00:38:23,270
energy will help is to maybe restrict

00:38:21,530 --> 00:38:25,550
ourselves a little bit and not open code

00:38:23,270 --> 00:38:28,400
stuff and see when it's dangerous to do

00:38:25,550 --> 00:38:32,120
so so for example that fight pool the

00:38:28,400 --> 00:38:36,110
floppy but if the author of that driver

00:38:32,120 --> 00:38:36,849
of that device had say used a FIFO API

00:38:36,110 --> 00:38:39,279
that had

00:38:36,849 --> 00:38:42,819
was checking and I checked for the size

00:38:39,279 --> 00:38:44,559
of the current pointer in the FIFO then

00:38:42,819 --> 00:38:45,700
that bug would have turned into maybe a

00:38:44,559 --> 00:38:47,229
denial-of-service it would have been

00:38:45,700 --> 00:38:48,999
code execution it would not have been

00:38:47,229 --> 00:38:51,009
memory corruption because we could have

00:38:48,999 --> 00:38:51,700
said wait your index is too big there's

00:38:51,009 --> 00:38:55,989
a bug here

00:38:51,700 --> 00:38:57,369
stop cueing so that but doesn't it

00:38:55,989 --> 00:38:59,140
doesn't totally eliminate it but at

00:38:57,369 --> 00:39:00,910
least it avoids the worst problems that

00:38:59,140 --> 00:39:04,089
you get with certain aspects of the C

00:39:00,910 --> 00:39:07,900
programming language so yeah so these

00:39:04,089 --> 00:39:12,009
are some things that we can do all right

00:39:07,900 --> 00:39:19,420
I think I think I'll just see if there

00:39:12,009 --> 00:39:21,249
any other questions I think you have

00:39:19,420 --> 00:39:25,059
missed and I deleted the way at least

00:39:21,249 --> 00:39:27,609
some portal drivers which is done which

00:39:25,059 --> 00:39:30,430
even down streams at least and thinking

00:39:27,609 --> 00:39:33,309
right now about these formats our child

00:39:30,430 --> 00:39:40,869
is four months reach which can do at

00:39:33,309 --> 00:39:43,989
least they have have a code for example

00:39:40,869 --> 00:39:47,410
of a realization of different virtual

00:39:43,989 --> 00:39:49,599
disk formats and in at least in

00:39:47,410 --> 00:39:53,529
downstream we MOV have an ability to

00:39:49,599 --> 00:39:57,039
have some formats about lists and they

00:39:53,529 --> 00:39:58,869
are not available at least informants

00:39:57,039 --> 00:40:01,269
are not available in PMO only

00:39:58,869 --> 00:40:04,359
whitelisted formats are available but

00:40:01,269 --> 00:40:08,019
not weightless performances are usually

00:40:04,359 --> 00:40:10,739
used in we amo I am G okay this is also

00:40:08,019 --> 00:40:15,989
an activity to have some strange and

00:40:10,739 --> 00:40:15,989
strengthen in not just

00:40:21,070 --> 00:40:26,420
so you mentioned multi-process qm ooh is

00:40:24,710 --> 00:40:27,710
that a thing or is that just some

00:40:26,420 --> 00:40:30,710
aspiration

00:40:27,710 --> 00:40:32,570
it's a multi-process qmu is already a

00:40:30,710 --> 00:40:35,000
thing in the sense that the host user

00:40:32,570 --> 00:40:37,340
exists today so you can write Verdi Oh

00:40:35,000 --> 00:40:39,530
divisive Verdi old-style devices are Bo

00:40:37,340 --> 00:40:43,190
style devices that live in a separate

00:40:39,530 --> 00:40:46,400
process so yes that exists but it's it's

00:40:43,190 --> 00:40:47,870
the whole thing has been in active

00:40:46,400 --> 00:40:50,330
development over the past couple of

00:40:47,870 --> 00:40:51,950
years and people are still working on

00:40:50,330 --> 00:40:54,680
new things in that area so it's

00:40:51,950 --> 00:40:57,380
definitely not finished now there's more

00:40:54,680 --> 00:40:59,600
to do and I think there was a good talk

00:40:57,380 --> 00:41:02,300
buddy buck wanna be a I believe it was

00:40:59,600 --> 00:41:04,880
given for molester or maybe dev cough

00:41:02,300 --> 00:41:07,880
that we've talked about pushing some of

00:41:04,880 --> 00:41:10,730
the graphics components in a separate

00:41:07,880 --> 00:41:13,490
process and spice poisons is a

00:41:10,730 --> 00:41:15,560
relatively large piece of code includes

00:41:13,490 --> 00:41:23,770
a number of components like tea strainer

00:41:15,560 --> 00:41:48,950
and centrist so it is said that it has

00:41:23,770 --> 00:41:56,810
to leave okay so how do you do some

00:41:48,950 --> 00:41:59,030
double both the post and the short

00:41:56,810 --> 00:42:00,110
answer for networking is that the

00:41:59,030 --> 00:42:01,460
configurations are actually very

00:42:00,110 --> 00:42:03,290
flexible there's many ways you can

00:42:01,460 --> 00:42:05,630
configure that and that happens outside

00:42:03,290 --> 00:42:07,430
of Q you got something about either good

00:42:05,630 --> 00:42:08,840
vert or you can set up manually so you

00:42:07,430 --> 00:42:11,270
can use software British or whatever

00:42:08,840 --> 00:42:15,650
there's many ways of doing it so there's

00:42:11,270 --> 00:42:18,560
no one way about the device passenger

00:42:15,650 --> 00:42:19,820
with the camera I mean Kim Yu has PCI

00:42:18,560 --> 00:42:20,580
device you pass through it has a USB

00:42:19,820 --> 00:42:25,140
device

00:42:20,580 --> 00:42:26,670
- and you can do that you can give a lot

00:42:25,140 --> 00:42:28,830
of ice to the guests and the guests then

00:42:26,670 --> 00:42:30,810
just uses its normal device driver to

00:42:28,830 --> 00:42:35,820
talk to her engine could introduce new

00:42:30,810 --> 00:42:37,050
security issues okay so I think we have

00:42:35,820 --> 00:42:40,610
to end here because we're running out of

00:42:37,050 --> 00:42:40,610
time thank you

00:42:42,960 --> 00:42:48,829

YouTube URL: https://www.youtube.com/watch?v=YAdRf_hwxU8


