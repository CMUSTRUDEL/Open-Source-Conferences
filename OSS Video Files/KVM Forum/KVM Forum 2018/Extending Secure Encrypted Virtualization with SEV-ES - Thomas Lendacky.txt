Title: Extending Secure Encrypted Virtualization with SEV-ES - Thomas Lendacky
Publication date: 2018-11-14
Playlist: KVM Forum 2018
Description: 
	AMD has enhanced the capabilities of its hardware-based memory encryption to further extend the security protections provided by Secure Encrypted Virtualization (SEV). This talk will focus on the Encrypted State (ES) technology which extends the SEV support to minimize exposure of the guest register state for added isolation and protection from the hypervisor. The presentation will discuss the technical details of this technology with a focus on how it is being integrated into KVM.

---

Thomas Lendacky
PMTS Software Engineer
AMD

Tom Lendacky is a member of the Linux OS group at Advanced Micro Devices. He is responsible for enabling and enhancing support for AMD processor features in the Linux kernel. He is currently working on extending the SEV support to enable SEV-ES (Secure Encrypted Virtualization - Encrypted State). He has spoken at various Linux events, most recently at KVM Forum 2016.
Captions: 
	00:00:00,350 --> 00:00:02,710
[Music]

00:00:06,620 --> 00:00:14,190
my name is common acne I work at A&E and

00:00:10,820 --> 00:00:16,470
talk about the next phase of our

00:00:14,190 --> 00:00:25,140
security virtualization technology

00:00:16,470 --> 00:00:28,230
called CVS quick overview and just do a

00:00:25,140 --> 00:00:31,109
quick review of what FCB is for those

00:00:28,230 --> 00:00:34,079
who may or may not know talk about what

00:00:31,109 --> 00:00:37,350
that CVS is and then how it works and

00:00:34,079 --> 00:00:44,820
then talk about where we are streaming

00:00:37,350 --> 00:00:46,670
patches so the nd secure memory

00:00:44,820 --> 00:00:48,870
encryption and secure and encrypted

00:00:46,670 --> 00:00:53,460
virtualization future came out and our

00:00:48,870 --> 00:00:56,190
latest Hardware chip it is in a EES

00:00:53,460 --> 00:00:59,489
engine in the memory controller so any

00:00:56,190 --> 00:01:01,859
rights to DRAM retreats from DRAM will

00:00:59,489 --> 00:01:05,220
be encrypted and decrypted based on the

00:01:01,859 --> 00:01:08,490
direction minimal performance impact

00:01:05,220 --> 00:01:10,680
there's some extra latency that's they

00:01:08,490 --> 00:01:12,330
candidate before just burn encrypted

00:01:10,680 --> 00:01:15,090
pages so it's still in the running of

00:01:12,330 --> 00:01:18,540
the page there's no no overhead from

00:01:15,090 --> 00:01:22,729
this no application changes are required

00:01:18,540 --> 00:01:24,780
so this is all down in the OS layer

00:01:22,729 --> 00:01:27,990
application changes I'm talking about

00:01:24,780 --> 00:01:30,000
more from using the application as

00:01:27,990 --> 00:01:36,689
opposed to like support that we've been

00:01:30,000 --> 00:01:39,720
put into qmu and all the encryption keys

00:01:36,689 --> 00:01:43,560
are managed by our secure processor so

00:01:39,720 --> 00:01:48,370
they are Hardware isolated from all the

00:01:43,560 --> 00:01:50,890
x86 CPUs so the hypervisor or the guest

00:01:48,370 --> 00:01:53,410
that matter cannot access the keys or

00:01:50,890 --> 00:01:57,520
see what those keys are so all that is

00:01:53,410 --> 00:02:06,450
handled 300 calls by the secured

00:01:57,520 --> 00:02:06,450
processor this is kind of an overview of

00:02:07,170 --> 00:02:15,390
it looks like we have different keys for

00:02:10,960 --> 00:02:15,390
the hypervisor and for the various guest

00:02:15,420 --> 00:02:21,820
they allow you to cryptographically

00:02:18,370 --> 00:02:24,790
isolate each other each guest from each

00:02:21,820 --> 00:02:27,100
other or from the hypervisor itself - so

00:02:24,790 --> 00:02:29,380
the hypervisor gets one key or

00:02:27,100 --> 00:02:32,440
bare-metal system would have just one

00:02:29,380 --> 00:02:37,660
key and then all the encrypted guests we

00:02:32,440 --> 00:02:41,530
would have you need this all integrates

00:02:37,660 --> 00:02:44,440
into our existing virtualization

00:02:41,530 --> 00:02:49,990
technology and it doesn't include new

00:02:44,440 --> 00:02:53,590
from running just regular vs your usual

00:02:49,990 --> 00:03:01,000
virtual machines along with your ftp

00:02:53,590 --> 00:03:05,950
machines so a lot of this support

00:03:01,000 --> 00:03:10,030
recently made it upstream and 450 we

00:03:05,950 --> 00:03:12,910
added the support to allow the Linux

00:03:10,030 --> 00:03:16,150
kernel to run as an SCP guest and in

00:03:12,910 --> 00:03:20,050
4:16 we added the hypervisor support so

00:03:16,150 --> 00:03:24,130
that you can launch the there was work

00:03:20,050 --> 00:03:30,090
done in only a map that landed in the

00:03:24,130 --> 00:03:30,090
early part of the year support / q mu is

00:03:30,209 --> 00:03:37,350
2.12 and the lippert support is in for

00:03:37,580 --> 00:03:42,660
kind of up the stack even above that I

00:03:40,410 --> 00:03:45,480
know it works kind of being looked at

00:03:42,660 --> 00:03:48,720
and going on and hopefully that whole

00:03:45,480 --> 00:03:53,580
ecosystem will will come together but

00:03:48,720 --> 00:03:56,370
this is this is what we have so far hey

00:03:53,580 --> 00:03:59,520
so if I move on and talk about what what

00:03:56,370 --> 00:04:02,480
is se ve s so yes in this case thanks

00:03:59,520 --> 00:04:05,040
for encrypted State right where's se B

00:04:02,480 --> 00:04:08,970
we don't think the memory of the guest

00:04:05,040 --> 00:04:15,090
and with se ve s we go step beyond and

00:04:08,970 --> 00:04:17,730
we encrypt the the VM estate before that

00:04:15,090 --> 00:04:21,630
guess okay so all the guests register

00:04:17,730 --> 00:04:25,350
your state gets encrypted and integrity

00:04:21,630 --> 00:04:29,670
protected so that now only the guest is

00:04:25,350 --> 00:04:32,220
able to modify its register state so the

00:04:29,670 --> 00:04:36,300
hypervisor can no longer go in and

00:04:32,220 --> 00:04:40,140
update registers to try and change or

00:04:36,300 --> 00:04:42,480
modify how the guest runs when we do

00:04:40,140 --> 00:04:45,750
want to have a hypervisor performs and

00:04:42,480 --> 00:04:48,750
functions for us we have to explicitly

00:04:45,750 --> 00:04:50,400
share the register information and we do

00:04:48,750 --> 00:04:53,040
that through a guest hypervisor

00:04:50,400 --> 00:04:53,770
community and I'll talk a little bit

00:04:53,040 --> 00:04:59,069
more about

00:04:53,770 --> 00:05:03,370
coming slides so by doing this we

00:04:59,069 --> 00:05:07,180
protect the register state from from the

00:05:03,370 --> 00:05:11,500
hypervisor against some of the attacks

00:05:07,180 --> 00:05:11,979
around exfiltration control flow or

00:05:11,500 --> 00:05:15,280
rollback

00:05:11,979 --> 00:05:18,400
which is all about either snooping on

00:05:15,280 --> 00:05:21,660
the state or trying to control or modify

00:05:18,400 --> 00:05:21,660
the state of the guests

00:05:25,550 --> 00:05:32,900
so the way we kind of have to start this

00:05:29,100 --> 00:05:37,650
is we start kind of with a known

00:05:32,900 --> 00:05:40,650
registered state and then as during the

00:05:37,650 --> 00:05:44,190
sed launch process that exists today per

00:05:40,650 --> 00:05:46,620
se because we now also encrypt and

00:05:44,190 --> 00:05:50,419
measure the register that initial

00:05:46,620 --> 00:05:54,000
register state that measurement is now

00:05:50,419 --> 00:05:56,730
added to the sed launch measurement and

00:05:54,000 --> 00:06:01,470
so that way everything can be attested

00:05:56,730 --> 00:06:04,590
to - to the launch measurement and you

00:06:01,470 --> 00:06:09,360
can ensure that the initial state of

00:06:04,590 --> 00:06:13,800
your guest registers is what you

00:06:09,360 --> 00:06:16,080
expected it to be right every time you

00:06:13,800 --> 00:06:19,500
do a VM run there's an integrity check

00:06:16,080 --> 00:06:21,750
performed on the same state so that if

00:06:19,500 --> 00:06:24,330
the hypervisor was to try and change

00:06:21,750 --> 00:06:29,060
some of the register state the being run

00:06:24,330 --> 00:06:32,970
and then fail and I guess wouldn't run

00:06:29,060 --> 00:06:36,330
and as part of this all the world

00:06:32,970 --> 00:06:38,400
switches now save the entire guest

00:06:36,330 --> 00:06:40,800
register state so there's no more need

00:06:38,400 --> 00:06:44,400
to do me unload or VM state before after

00:06:40,800 --> 00:06:48,780
the me umbrella and all of that

00:06:44,400 --> 00:06:51,390
information is is saved and will be

00:06:48,780 --> 00:06:52,210
reloading as soon as you do be abroad

00:06:51,390 --> 00:06:55,690
the more state

00:06:52,210 --> 00:06:58,300
via medicine now we traditionally now

00:06:55,690 --> 00:07:02,500
the BM control block of the mCP that's

00:06:58,300 --> 00:07:06,370
been kind of a continuous page and under

00:07:02,500 --> 00:07:11,470
sed yes that changes and you now have a

00:07:06,370 --> 00:07:13,449
BM control area which points to we'll

00:07:11,470 --> 00:07:16,150
have an entry point to the same area and

00:07:13,449 --> 00:07:23,789
that same area is where we will have the

00:07:16,150 --> 00:07:27,759
encrypted data saved and then just I

00:07:23,789 --> 00:07:29,830
know they're the same area has been

00:07:27,759 --> 00:07:34,870
extended so that we save more

00:07:29,830 --> 00:07:36,550
information doesn't help the hypervisor

00:07:34,870 --> 00:07:40,389
because it's not going to be able to

00:07:36,550 --> 00:07:42,880
read it anyways but it just needs to

00:07:40,389 --> 00:07:48,759
needs to be accounted for when we

00:07:42,880 --> 00:07:53,949
allocate this space so with scbs we also

00:07:48,759 --> 00:07:58,590
have new VM exit types so we have

00:07:53,949 --> 00:08:01,570
automatic exits which are anything from

00:07:58,590 --> 00:08:05,260
asynchronous events such as interrupts

00:08:01,570 --> 00:08:07,270
or events that don't require any state

00:08:05,260 --> 00:08:11,229
information like a halt instruction or

00:08:07,270 --> 00:08:14,289
pause instruction and then anything that

00:08:11,229 --> 00:08:18,039
is not an automatic exit is considered a

00:08:14,289 --> 00:08:21,039
non automatic exit a non automatic

00:08:18,039 --> 00:08:23,500
accident now generates an exception and

00:08:21,039 --> 00:08:28,259
the exception call the VMM communication

00:08:23,500 --> 00:08:30,250
exception at that point the guest the

00:08:28,259 --> 00:08:33,820
exception handler will get control and

00:08:30,250 --> 00:08:36,400
ask to determine what register state it

00:08:33,820 --> 00:08:37,080
needs to share with the hypervisor and

00:08:36,400 --> 00:08:39,180
it would put

00:08:37,080 --> 00:08:43,470
information into the guests hypervisor

00:08:39,180 --> 00:08:45,450
control block it issues a new

00:08:43,470 --> 00:08:49,110
instruction called the BMG exit

00:08:45,450 --> 00:08:52,230
instruction and that will then cause an

00:08:49,110 --> 00:08:56,310
automatic exit with a new exit code so

00:08:52,230 --> 00:09:00,450
that the hypervisor can now handle this

00:08:56,310 --> 00:09:02,490
VMT exit the hypervisor will do its

00:09:00,450 --> 00:09:05,460
thing and I'll talk a little bit more on

00:09:02,490 --> 00:09:08,190
that in a bit so then upon return the

00:09:05,460 --> 00:09:10,470
hypervisor will have filled in the DHCP

00:09:08,190 --> 00:09:15,210
with results from the request that

00:09:10,470 --> 00:09:19,170
they've made and then the handler will

00:09:15,210 --> 00:09:21,770
update the register information so that

00:09:19,170 --> 00:09:26,310
the guests can continue operation so

00:09:21,770 --> 00:09:30,060
also with sepds we have some new control

00:09:26,310 --> 00:09:34,980
register traps these are just for rights

00:09:30,060 --> 00:09:39,510
to some of the C are 0 through C are 15

00:09:34,980 --> 00:09:41,790
and meet for register so it's it's a

00:09:39,510 --> 00:09:43,740
it's a right after the register has been

00:09:41,790 --> 00:09:46,500
modified or a trap back to the registers

00:09:43,740 --> 00:09:48,590
been modified the new value is applied

00:09:46,500 --> 00:09:51,030
to it in some of the exit information

00:09:48,590 --> 00:09:54,420
mainly there so that a hypervisor can

00:09:51,030 --> 00:09:57,800
track what changes are being made to

00:09:54,420 --> 00:10:00,300
control registers one of the things that

00:09:57,800 --> 00:10:03,210
KTM would be able to do with that is

00:10:00,300 --> 00:10:05,520
determine whether the guest machine is

00:10:03,210 --> 00:10:07,350
in protected mode things like that where

00:10:05,520 --> 00:10:08,640
normally it tries to read that register

00:10:07,350 --> 00:10:10,440
information the terms of that

00:10:08,640 --> 00:10:10,980
information and since it can't do that

00:10:10,440 --> 00:10:13,440
anymore

00:10:10,980 --> 00:10:16,200
we provide some information

00:10:13,440 --> 00:10:23,970
the right traps are only supported for

00:10:16,200 --> 00:10:26,430
se BES guests so the guests head

00:10:23,970 --> 00:10:30,630
provides our communication block or the

00:10:26,430 --> 00:10:33,029
gh TV it's going to allow the gues

00:10:30,630 --> 00:10:36,540
improviser to communicate state

00:10:33,029 --> 00:10:38,970
information that's needed it's what we

00:10:36,540 --> 00:10:41,339
call a shared or an unencrypted page so

00:10:38,970 --> 00:10:42,870
that way when the guest rights to it the

00:10:41,339 --> 00:10:44,550
hypervisor can read into when the

00:10:42,870 --> 00:10:49,950
hypervisor rights to it the guest can

00:10:44,550 --> 00:10:52,710
read it the guest sets that to the

00:10:49,950 --> 00:10:56,520
guests physical address of that page by

00:10:52,710 --> 00:11:02,400
writing to an MSR and the MSR is not an

00:10:56,520 --> 00:11:05,400
inn acceptable MSR and the hypervisor

00:11:02,400 --> 00:11:08,250
has an entry in the VM control block or

00:11:05,400 --> 00:11:12,630
the control area which reflects that as

00:11:08,250 --> 00:11:14,790
our value so when a BM DX that occurs it

00:11:12,630 --> 00:11:16,560
will read that BMC control area to

00:11:14,790 --> 00:11:19,350
determine where that page is it will

00:11:16,560 --> 00:11:21,630
translate it from guest physical into

00:11:19,350 --> 00:11:25,380
those physical and be able to access the

00:11:21,630 --> 00:11:31,170
page information we're working on a

00:11:25,380 --> 00:11:36,060
specification so that we extended use of

00:11:31,170 --> 00:11:39,390
the DHT B and the various exits and and

00:11:36,060 --> 00:11:40,890
things so that every guest should be

00:11:39,390 --> 00:11:43,380
able to run in their everyday provider

00:11:40,890 --> 00:11:46,230
or every hypervisor should be able to

00:11:43,380 --> 00:11:48,270
run any guests that supports this right

00:11:46,230 --> 00:11:50,970
so we're defining the format and the

00:11:48,270 --> 00:11:54,270
DHCP so the register information and you

00:11:50,970 --> 00:11:57,420
saved into the guest hypervisor control

00:11:54,270 --> 00:12:00,500
in case you block the the actual offsets

00:11:57,420 --> 00:12:00,500
that are associated with that

00:12:00,620 --> 00:12:07,620
there's a guy minimum setting and

00:12:03,390 --> 00:12:09,720
minimum set of supported non non

00:12:07,620 --> 00:12:12,720
automatic exits right so this will be

00:12:09,720 --> 00:12:15,930
the things that you would expect to be

00:12:12,720 --> 00:12:19,410
able to do from the guests such as like

00:12:15,930 --> 00:12:25,410
a CPU I need call or read or write Emma

00:12:19,410 --> 00:12:27,450
SARS it will define the required state

00:12:25,410 --> 00:12:30,390
that needs to be provided with each of

00:12:27,450 --> 00:12:37,050
those a needs so in the case of say

00:12:30,390 --> 00:12:41,190
cpuid RA XS for a read MSR the CX

00:12:37,050 --> 00:12:43,980
register so that and then return we know

00:12:41,190 --> 00:12:46,890
what we should be looking for so again

00:12:43,980 --> 00:12:54,210
cpuid we would look for you know r IX

00:12:46,890 --> 00:12:56,640
through our ad RDX we defined some

00:12:54,210 --> 00:12:58,590
software fields within the ght be to

00:12:56,640 --> 00:13:03,510
represent the X and information that

00:12:58,590 --> 00:13:05,880
were processing so very similar to the

00:13:03,510 --> 00:13:06,400
control fields the exit code exit info

00:13:05,880 --> 00:13:09,160
one and

00:13:06,400 --> 00:13:15,280
two of these are software fields within

00:13:09,160 --> 00:13:18,940
the DHCP and we use all of the exit

00:13:15,280 --> 00:13:20,830
codes that we can so that from the

00:13:18,940 --> 00:13:24,010
hypervisor point of view they can just

00:13:20,830 --> 00:13:25,690
pull that exit in for me we pull some of

00:13:24,010 --> 00:13:28,180
that same information and then just

00:13:25,690 --> 00:13:35,530
process the information and process the

00:13:28,180 --> 00:13:38,440
request like that yes so let's see the

00:13:35,530 --> 00:13:40,570
instruction you know has a certain exit

00:13:38,440 --> 00:13:43,720
code we would put that into the software

00:13:40,570 --> 00:13:46,270
exit code and then hypervisor gets

00:13:43,720 --> 00:13:49,860
control it can it can use that in this

00:13:46,270 --> 00:13:54,760
process its performance manual process

00:13:49,860 --> 00:14:07,030
and then we also have to define some new

00:13:54,760 --> 00:14:11,500
methods normally when you do trying to

00:14:07,030 --> 00:14:14,740
do your secondary processors and you and

00:14:11,500 --> 00:14:17,860
then an it in a sippy call and that will

00:14:14,740 --> 00:14:20,440
tell the hypervisor to various registers

00:14:17,860 --> 00:14:23,170
state but we can't do that anymore

00:14:20,440 --> 00:14:26,370
so we have to come up with some new new

00:14:23,170 --> 00:14:35,920
ways of doing this this booting of

00:14:26,370 --> 00:14:37,920
secondary processors that is recently

00:14:35,920 --> 00:14:39,329
gone online

00:14:37,920 --> 00:14:44,600
at the end of the presentation I'll show

00:14:39,329 --> 00:14:44,600
the link and we be able to look at that

00:14:47,269 --> 00:14:53,399
so when the gas tries to execute

00:14:51,170 --> 00:14:57,060
something that requires hypervisor

00:14:53,399 --> 00:15:03,060
support and we get that an automatic

00:14:57,060 --> 00:15:09,180
exit event the new exception handler the

00:15:03,060 --> 00:15:14,339
DC handler will get control to make it

00:15:09,180 --> 00:15:19,079
easy the error code is part of or what

00:15:14,339 --> 00:15:22,320
would have been the exit code if it were

00:15:19,079 --> 00:15:24,870
running as a normal guest so that makes

00:15:22,320 --> 00:15:29,690
it easy for the VC handler to be able to

00:15:24,870 --> 00:15:31,769
do some things doesn't have to parse

00:15:29,690 --> 00:15:33,600
almost all of its it doesn't have to

00:15:31,769 --> 00:15:37,440
parse instructions to figure out what's

00:15:33,600 --> 00:15:39,600
going on so we'll have liked it a cpuid

00:15:37,440 --> 00:15:42,420
exit code so you know exactly what

00:15:39,600 --> 00:15:45,600
information you need to prepare and put

00:15:42,420 --> 00:15:48,720
into the DHCP some some other things

00:15:45,600 --> 00:15:56,760
like like an MMI Oh access which show up

00:15:48,720 --> 00:16:00,930
as but we have a reserve bit on there so

00:15:56,760 --> 00:16:02,790
that would be so the message pops are

00:16:00,930 --> 00:16:05,220
interesting because if it's not a

00:16:02,790 --> 00:16:07,350
reserved it that causes an instant page

00:16:05,220 --> 00:16:12,240
ball that's an automatic exit because it

00:16:07,350 --> 00:16:14,220
can be handled without requiring the

00:16:12,240 --> 00:16:16,980
help of the guests but in the case of

00:16:14,220 --> 00:16:19,680
MMI oh we would we would have to parse

00:16:16,980 --> 00:16:21,949
the instruction to figure out what

00:16:19,680 --> 00:16:26,300
information in what addresses are being

00:16:21,949 --> 00:16:29,010
requested and supplied that information

00:16:26,300 --> 00:16:31,170
once all that information is set up the

00:16:29,010 --> 00:16:35,790
guests would then issue the BMV exit

00:16:31,170 --> 00:16:39,180
which generates an automatic exit with

00:16:35,790 --> 00:16:42,060
that new exit code and the bmd exit is

00:16:39,180 --> 00:16:44,500
now just the VMM call with a with the

00:16:42,060 --> 00:16:47,149
rep prefix

00:16:44,500 --> 00:16:49,839
the hypervisor would examine the

00:16:47,149 --> 00:16:54,560
information supplying its results back

00:16:49,839 --> 00:16:59,149
we'll examine the DHCP information upon

00:16:54,560 --> 00:17:02,570
return we allow for the hypervisor to

00:16:59,149 --> 00:17:06,650
indicate error conditions so like for a

00:17:02,570 --> 00:17:10,250
read MSR it wants to generate a general

00:17:06,650 --> 00:17:15,049
protection flaw right we can we can see

00:17:10,250 --> 00:17:16,640
that and then continue down an exception

00:17:15,049 --> 00:17:19,010
handler for general protection vault

00:17:16,640 --> 00:17:24,770
rather than going out there trying to

00:17:19,010 --> 00:17:27,530
retrieve information from the DHCP and

00:17:24,770 --> 00:17:29,929
then assuming everything was valid

00:17:27,530 --> 00:17:31,820
though we would copy that register state

00:17:29,929 --> 00:17:34,610
into the register state of the exception

00:17:31,820 --> 00:17:38,570
handler so that when we return from the

00:17:34,610 --> 00:17:44,660
exception handler it would be all the

00:17:38,570 --> 00:17:47,480
registers a would be filled out some

00:17:44,660 --> 00:17:48,140
quick little animation of how this all

00:17:47,480 --> 00:17:52,309
works

00:17:48,140 --> 00:17:55,040
so the guest in this case I use the good

00:17:52,309 --> 00:17:58,610
old cpuid example I've been talking

00:17:55,040 --> 00:18:01,880
about yes this is a CPUID instruction

00:17:58,610 --> 00:18:05,660
that's gonna generate a VM exit

00:18:01,880 --> 00:18:10,850
condition the hardware will see that and

00:18:05,660 --> 00:18:18,510
it's an sed yes yes it will send a DC

00:18:10,850 --> 00:18:21,090
exception to guess the exception

00:18:18,510 --> 00:18:24,320
exception handler will look at the error

00:18:21,090 --> 00:18:29,700
code see that it's a CPUID instruction

00:18:24,320 --> 00:18:34,710
error code and it will write the cpuid

00:18:29,700 --> 00:18:37,920
exit code along with a copy of our ax

00:18:34,710 --> 00:18:41,400
into the THC P at that point it will

00:18:37,920 --> 00:18:44,550
issue in the exit the hardware will save

00:18:41,400 --> 00:18:47,040
all of the segment encrypt all the guest

00:18:44,550 --> 00:18:50,400
state and then load the hypervisor

00:18:47,040 --> 00:18:54,090
stayed in the hypervisor state will then

00:18:50,400 --> 00:18:57,260
look and read the DHD b/c it's a cpuid

00:18:54,090 --> 00:19:01,890
exit it'll emulate the cpuid request and

00:18:57,260 --> 00:19:06,780
write our ax BX CX + DX into the DHCP

00:19:01,890 --> 00:19:15,500
and then issue a VM run which will then

00:19:06,780 --> 00:19:15,500
swap the guest state back in decrypted

00:19:15,890 --> 00:19:21,690
the guests would then copy the registers

00:19:20,100 --> 00:19:23,160
that were supplied by the register

00:19:21,690 --> 00:19:26,430
information supplied behind the

00:19:23,160 --> 00:19:28,740
hypervisor back into its register state

00:19:26,430 --> 00:19:36,600
from the exception handler and then

00:19:28,740 --> 00:19:38,850
issue an iraq allah s so just a quick

00:19:36,600 --> 00:19:46,590
talk of some of the challenges that we

00:19:38,850 --> 00:19:49,620
encountered and with SE v before

00:19:46,590 --> 00:19:52,760
painting is enabled every patient is

00:19:49,620 --> 00:19:55,350
considered encrypted so any accesses

00:19:52,760 --> 00:19:58,220
instruction fetches reach the writes to

00:19:55,350 --> 00:20:04,110
memory are going to be automatically

00:19:58,220 --> 00:20:07,500
encrypted and decrypted in order to be

00:20:04,110 --> 00:20:11,160
able to share the geo CD you need to be

00:20:07,500 --> 00:20:12,680
in a painting mode and you need to make

00:20:11,160 --> 00:20:15,080
sure that the encryption

00:20:12,680 --> 00:20:17,720
in that painting mode is not set well

00:20:15,080 --> 00:20:20,330
I'm going to get the encryption bit we

00:20:17,720 --> 00:20:23,480
need tissue a CPUID instruction which

00:20:20,330 --> 00:20:27,200
isn't going to cause an nad event and

00:20:23,480 --> 00:20:29,390
cause the DC handling to get control we

00:20:27,200 --> 00:20:32,050
do need to do something where we require

00:20:29,390 --> 00:20:37,930
the hypervisor to supply some

00:20:32,050 --> 00:20:40,580
information in the initial DHCP MSR and

00:20:37,930 --> 00:20:42,650
we that way we can do some protocol

00:20:40,580 --> 00:20:44,660
negotiation determine where the C bit

00:20:42,650 --> 00:20:48,080
location is and then set up all our page

00:20:44,660 --> 00:20:52,640
tables properly so that we can then

00:20:48,080 --> 00:20:56,720
continue on all this is talk about the

00:20:52,640 --> 00:20:59,390
PCB specification along with some other

00:20:56,720 --> 00:21:02,690
things such as the SMT you support on

00:20:59,390 --> 00:21:07,010
how we have to pay a secondary CPUs and

00:21:02,690 --> 00:21:09,680
a my support since since we have to make

00:21:07,010 --> 00:21:11,960
sure that I rents are intercepted but

00:21:09,680 --> 00:21:13,880
pirates are intercepted by an animai

00:21:11,960 --> 00:21:16,210
zapper so that you can tell them in my

00:21:13,880 --> 00:21:16,210
hands

00:21:18,070 --> 00:21:26,690
TCB specification which I'll show you

00:21:23,630 --> 00:21:30,320
the link in the next slide so kind of a

00:21:26,690 --> 00:21:33,020
current status of where we are so we

00:21:30,320 --> 00:21:39,020
have some proof of concept patches for

00:21:33,020 --> 00:21:43,220
obeah map in linux and queuing you to to

00:21:39,020 --> 00:21:48,230
be able to run and multiple DCP you

00:21:43,220 --> 00:21:49,930
guess so we're going the OVF stuff is

00:21:48,230 --> 00:21:55,990
all done and I'm moving all the way to

00:21:49,930 --> 00:21:57,100
and UEFI and working at this point

00:21:55,990 --> 00:21:59,400
there's

00:21:57,100 --> 00:22:04,450
some SIL some early GU stuff I need to

00:21:59,400 --> 00:22:06,340
address things with SR and things that

00:22:04,450 --> 00:22:12,460
it's doing before we decompress the

00:22:06,340 --> 00:22:14,830
terminal should be doable and the dhcp

00:22:12,460 --> 00:22:19,840
specification is under review and is

00:22:14,830 --> 00:22:20,980
available publicly and so i'll be we

00:22:19,840 --> 00:22:24,700
price them is something out to the

00:22:20,980 --> 00:22:27,490
mailing list to point to it and get

00:22:24,700 --> 00:22:29,049
feedback from folks so that we can you

00:22:27,490 --> 00:22:31,750
know kind of settle on the specification

00:22:29,049 --> 00:22:35,830
that everyone be able to use between all

00:22:31,750 --> 00:22:39,190
the hypervisor factors and then this is

00:22:35,830 --> 00:22:43,120
just a link to the references so it's at

00:22:39,190 --> 00:22:47,110
a developer that AMD comm /sepb so

00:22:43,120 --> 00:22:48,880
there's white papers out there tht these

00:22:47,110 --> 00:22:51,760
specifications out there and then

00:22:48,880 --> 00:22:58,559
pointers to the the APM that talks about

00:22:51,760 --> 00:22:58,559
se BES that's all I have

00:23:25,050 --> 00:23:31,450
so I'm asking that they're all bunch of

00:23:29,770 --> 00:23:33,850
em yourself but contains actually

00:23:31,450 --> 00:23:36,030
function pointers inside against things

00:23:33,850 --> 00:23:38,800
like I saw in stone that contains that

00:23:36,030 --> 00:23:40,750
assistant call others right and this

00:23:38,800 --> 00:23:42,610
still needs to be best grown to the

00:23:40,750 --> 00:23:46,900
hypervisor to correctly configured

00:23:42,610 --> 00:23:50,230
Amazon in the EMC be right and what

00:23:46,900 --> 00:23:53,140
still confuse me is that the operator

00:23:50,230 --> 00:23:56,350
can still for example increment the

00:23:53,140 --> 00:23:58,150
himself in a couple to skip a couple

00:23:56,350 --> 00:24:02,440
instruction in the system called handle

00:23:58,150 --> 00:24:04,180
of the guest security problems for the

00:24:02,440 --> 00:24:06,490
guest and maybe even never attempt to

00:24:04,180 --> 00:24:08,380
actually mark all the exciting days and

00:24:06,490 --> 00:24:15,790
then break this all the protection

00:24:08,380 --> 00:24:18,970
mechanism so I think what top line I'm

00:24:15,790 --> 00:24:22,720
not sure exactly if this is in the realm

00:24:18,970 --> 00:24:27,340
of like the debug method of doing things

00:24:22,720 --> 00:24:31,480
or just you know we we also make sure

00:24:27,340 --> 00:24:35,260
that you know we say that provides gonna

00:24:31,480 --> 00:24:37,090
have to not intercept certain MSRs

00:24:35,260 --> 00:24:41,820
so it's not it's not going to be

00:24:37,090 --> 00:24:45,760
foolproof right in some cases right but

00:24:41,820 --> 00:24:48,940
the general idea is that now nothing can

00:24:45,760 --> 00:24:54,490
kind of snooping to register state now

00:24:48,940 --> 00:24:56,620
if you if you try and the instruction

00:24:54,490 --> 00:24:58,470
pointer is not through the grid but

00:24:56,620 --> 00:25:01,110
through through an MSR

00:24:58,470 --> 00:25:03,710
saying you know I'm not sure what would

00:25:01,110 --> 00:25:06,179
happen inside the guest at that point if

00:25:03,710 --> 00:25:08,940
information isn't set up properly and

00:25:06,179 --> 00:25:11,159
you know on the instruction so this

00:25:08,940 --> 00:25:12,929
means that the guest needs to know what

00:25:11,159 --> 00:25:14,789
are the M cells that I provider actually

00:25:12,929 --> 00:25:18,860
intersect right because it's too

00:25:14,789 --> 00:25:18,860
productive GHC be incorrectly

00:25:19,280 --> 00:25:26,520
well the hypervisor or the handlers

00:25:23,309 --> 00:25:29,429
we'll see when it gets saying there are

00:25:26,520 --> 00:25:31,140
read or write when it executes an MS of

00:25:29,429 --> 00:25:33,870
read MS are right Emma sorry

00:25:31,140 --> 00:25:35,789
it knows what MSR is being has been

00:25:33,870 --> 00:25:38,100
innocent yeah

00:25:35,789 --> 00:25:43,549
so today the guest doesn't know which is

00:25:38,100 --> 00:25:46,049
other intercepted but sorry

00:25:43,549 --> 00:25:48,150
well doesn't I mean it doesn't have to

00:25:46,049 --> 00:25:50,940
know right it just it just knows that it

00:25:48,150 --> 00:25:54,120
takes the value and the MSR so for a

00:25:50,940 --> 00:25:56,039
read MSR it's supplying the MSR value

00:25:54,120 --> 00:25:58,230
max RCX

00:25:56,039 --> 00:26:09,539
all right and so it just don't use the

00:25:58,230 --> 00:26:11,970
contents of our CI into the DHCP I'll

00:26:09,539 --> 00:26:14,330
talk to you offline I'll try a little

00:26:11,970 --> 00:26:14,330
bit more

00:26:18,130 --> 00:27:02,680
so it sounds like you know right well

00:26:58,500 --> 00:27:04,450
yeah and it's a it's a matter of just

00:27:02,680 --> 00:27:06,700
how how much you're going to trust by

00:27:04,450 --> 00:27:24,580
provider right so we're trying to get a

00:27:06,700 --> 00:27:26,140
little bit further in the look at that I

00:27:24,580 --> 00:27:30,360
mean I think it's still possible to

00:27:26,140 --> 00:27:34,360
provide provider to injected exceptions

00:27:30,360 --> 00:27:40,330
as long as it's not changing registers

00:27:34,360 --> 00:27:44,980
state to do that in and it's it's been a

00:27:40,330 --> 00:27:47,260
little bit since I've looked at the like

00:27:44,980 --> 00:27:48,970
exception injection and whether anything

00:27:47,260 --> 00:27:51,670
that's changed versus just the event

00:27:48,970 --> 00:27:54,190
against but I think there's some

00:27:51,670 --> 00:27:58,269
register state that might make

00:27:54,190 --> 00:28:01,000
I'm not positive it's been a while I was

00:27:58,269 --> 00:28:02,919
mainly I was kind of mainly concerned

00:28:01,000 --> 00:28:09,429
with just getting proof of concept

00:28:02,919 --> 00:28:13,210
anything's working well how to get say

00:28:09,429 --> 00:28:43,620
DPS or whatever back that the hypervisor

00:28:13,210 --> 00:28:46,389
wants to get into at some point in the

00:28:43,620 --> 00:28:47,409
the whole part of attestation right that

00:28:46,389 --> 00:28:50,470
we were talking a little bit earlier

00:28:47,409 --> 00:28:52,090
about right when you first launch the

00:28:50,470 --> 00:28:56,830
guest that launch measurement is only

00:28:52,090 --> 00:28:59,049
for say the UEFI code right then you

00:28:56,830 --> 00:29:04,389
need to do your group if you want to

00:28:59,049 --> 00:29:06,279
make sure that everything thereafter in

00:29:04,389 --> 00:29:25,409
the trust model that you're looking for

00:29:06,279 --> 00:29:25,409
right yes yes is in all things like like

00:29:28,769 --> 00:29:33,879
lots of lots of threat models that come

00:29:31,419 --> 00:29:37,409
from proper that securable guys

00:29:33,879 --> 00:29:47,409
basically say loses them just you know

00:29:37,409 --> 00:29:49,900
close your USB ports and yeah yeah and

00:29:47,409 --> 00:29:55,900
there's there's very sad

00:29:49,900 --> 00:29:58,720
we can possibly do you know and to the

00:29:55,900 --> 00:30:02,260
guests itself right and only allowing

00:29:58,720 --> 00:30:06,429
certain certain devices to be attached

00:30:02,260 --> 00:30:09,279
or you know through you through like an

00:30:06,429 --> 00:30:13,690
in rem FS or things like that and just

00:30:09,279 --> 00:30:18,299
saying okay I'm only gonna look for this

00:30:13,690 --> 00:30:24,340
or this if somebody plugged something in

00:30:18,299 --> 00:30:29,230
maybe not allowing that to occur or in

00:30:24,340 --> 00:30:31,779
the case of this you know the launch the

00:30:29,230 --> 00:30:34,390
launch information also allows for a

00:30:31,779 --> 00:30:37,840
launch secret to be supplied back to the

00:30:34,390 --> 00:30:40,299
guests so that only the guest gets that

00:30:37,840 --> 00:30:45,220
secret and maybe that could be used

00:30:40,299 --> 00:30:47,200
unlock disk encryption keys things like

00:30:45,220 --> 00:30:50,409
that so that if somebody tries to put in

00:30:47,200 --> 00:30:55,240
a corrupt disk it if it the Kryptonite

00:30:50,409 --> 00:30:57,220
the encryption he doesn't match you know

00:30:55,240 --> 00:31:07,390
so there's various things that can be

00:30:57,220 --> 00:31:10,240
done we're looking at everything so

00:31:07,390 --> 00:31:14,260
matter resources though and but you know

00:31:10,240 --> 00:31:14,980
so we're trying we're it's kind of an

00:31:14,260 --> 00:31:18,570
evolution

00:31:14,980 --> 00:31:21,970
let's still look everybody let's go

00:31:18,570 --> 00:31:25,240
right now the main focus yeah so from

00:31:21,970 --> 00:31:27,100
because because go sort of from a

00:31:25,240 --> 00:31:28,929
hardware point of view to right and what

00:31:27,100 --> 00:31:31,690
can we do in Hardware and what is the

00:31:28,929 --> 00:31:33,850
next steps in hardware and then you know

00:31:31,690 --> 00:31:37,610
taking advantages and software and then

00:31:33,850 --> 00:31:42,890
also then looking outside

00:31:37,610 --> 00:31:42,890
it's twofold yeah resources

00:31:51,080 --> 00:31:56,950

YouTube URL: https://www.youtube.com/watch?v=lgJQYVZVbRc


