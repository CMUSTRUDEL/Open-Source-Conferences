Title: Distributed QEMU by Yubin Chen & Zhuocheng Ding
Publication date: 2018-11-14
Playlist: KVM Forum 2018
Description: 
	It is difficult for a single physical machine to satisfy applications which require massive resources such as big data analysis, while a virtual machine spanning multiple physical nodes can do it. In this presentation, Yubin will demonstrate their work of distributed QEMU which allows a guest OS running on single virtual machine to take advantage of resources (CPU, memory, I/O, etc.) from multiple physical nodes. They extend QEMU to enable forwarding of PIO, MMIO, Interrupts so that vCPUs and I/O devices on different machines can communicate with each other. Furthermore, in order to run a cross-node virtual machine, they also have implemented an RDMA-based distributed shared memory by extending the access control of EPT, which makes it possible for aggregating physical memory transparently. The preliminary experiment shows near-native performance for NUMA-friendly benchmarks on sv6 OS.

---

Yubin Chen
Researcher
Shanghai Jiao Tong University

Yubin Chen is a second-year graduate student researcher at School of Software, Shanghai Jiao Tong University. His research focuses on building distributed system by taking advantage of virtualization. The main topics of interests are QEMU/KVM, containers, and distributed systems.

Zhuocheng Ding
Researcher
Shanghai Jiao Tong University

Zhuocheng Ding is a second-year graduate student researcher at School of Software, Shanghai Jiao Tong University. His research interests include parallel and high-performance computing, system virtualization, distributed system and system security, and currently
focuses on building distributed hypervisor to support scaling up and resource aggregation easily and efficiently.
Captions: 
	00:00:01,040 --> 00:00:06,940
[Music]

00:00:15,590 --> 00:00:21,960
humor in this talk reached a fevered

00:00:19,560 --> 00:00:24,539
Emma so we will introduce our

00:00:21,960 --> 00:00:27,410
motivations of building disability q and

00:00:24,539 --> 00:00:29,910
then we will introduce the

00:00:27,410 --> 00:00:32,130
implementations of CP Ohio and the

00:00:29,910 --> 00:00:34,980
memory visualizations in the shipped

00:00:32,130 --> 00:00:37,440
Beauty environment furthermore some

00:00:34,980 --> 00:00:41,190
experiments results are given to saw the

00:00:37,440 --> 00:00:45,600
potentials of distributed Kumu we will

00:00:41,190 --> 00:00:48,300
show a demo here the main purpose is

00:00:45,600 --> 00:00:50,760
that distributed human run guest OS on

00:00:48,300 --> 00:00:53,250
multiple machines which provide a

00:00:50,760 --> 00:00:56,129
consistent with huge amounts of power

00:00:53,250 --> 00:00:58,559
resources in this demo we want to step

00:00:56,129 --> 00:01:01,260
out the end of 32 costs on two machines

00:00:58,559 --> 00:01:03,930
which each machine runs to make a VM

00:01:01,260 --> 00:01:09,750
instance and the processing cost now the

00:01:03,930 --> 00:01:12,900
guest OS begins to boot once we have

00:01:09,750 --> 00:01:16,740
login we could use the list CPU - so the

00:01:12,900 --> 00:01:19,439
guest OS truly has 32 workers we can see

00:01:16,740 --> 00:01:21,360
that the worker and then we can run the

00:01:19,439 --> 00:01:23,549
workload is the D to occur we can see

00:01:21,360 --> 00:01:25,259
that the workers are dispatch it to

00:01:23,549 --> 00:01:27,420
different costs on the two machine and

00:01:25,259 --> 00:01:29,549
we can use the edge table on the host

00:01:27,420 --> 00:01:34,590
machine to inspect the result

00:01:29,549 --> 00:01:38,070
utilization okay so why do we need to

00:01:34,590 --> 00:01:39,689
make you distributed the data

00:01:38,070 --> 00:01:41,790
applications and the machine learning

00:01:39,689 --> 00:01:45,149
for people to handle the data they have

00:01:41,790 --> 00:01:49,200
collected however those that are have to

00:01:45,149 --> 00:01:52,110
handle in a normal machine this is

00:01:49,200 --> 00:01:55,470
simply because they need a lot of CPU IO

00:01:52,110 --> 00:01:57,930
and memory resources today the

00:01:55,470 --> 00:02:00,000
conventional wisdom is that traditional

00:01:57,930 --> 00:02:02,640
scale of solutions such as min friends

00:02:00,000 --> 00:02:05,310
has low cost performance ratio and a

00:02:02,640 --> 00:02:07,170
physical limitation in the same height

00:02:05,310 --> 00:02:09,989
the data processing framework such as

00:02:07,170 --> 00:02:11,840
memory reduce and the SPARC are proposed

00:02:09,989 --> 00:02:13,500
and the quickly become prevalent

00:02:11,840 --> 00:02:15,210
however those

00:02:13,500 --> 00:02:17,760
the beauty framework brings some

00:02:15,210 --> 00:02:18,380
programming model capacities and Ottawa

00:02:17,760 --> 00:02:21,090
hair

00:02:18,380 --> 00:02:24,930
furthermore some programs cannot be

00:02:21,090 --> 00:02:27,180
rewriting to this style in order to stop

00:02:24,930 --> 00:02:30,270
this program represent the concepts of

00:02:27,180 --> 00:02:32,880
distribute EQ it is a hypervisor which

00:02:30,270 --> 00:02:34,890
enable guest OS running on physical

00:02:32,880 --> 00:02:38,850
machines with consistent how--where

00:02:34,890 --> 00:02:41,070
obstruction so SOS can make use of cpu

00:02:38,850 --> 00:02:44,160
IO and the memory resources of those

00:02:41,070 --> 00:02:47,190
machines in this figure we saw an

00:02:44,160 --> 00:02:49,770
overview of the distribute EQ each

00:02:47,190 --> 00:02:52,320
machine has a qk VM instance which

00:02:49,770 --> 00:02:54,900
manager local resources which view is

00:02:52,320 --> 00:02:57,390
manager locally where the memory is

00:02:54,900 --> 00:03:00,900
manager by the distributed shared memory

00:02:57,390 --> 00:03:03,630
protocol for each i/o device there is a

00:03:00,900 --> 00:03:06,739
master machine other mushy just forward

00:03:03,630 --> 00:03:09,690
the request to the master of this device

00:03:06,739 --> 00:03:13,230
but there are some changes in building

00:03:09,690 --> 00:03:15,300
the distribute EQ the first one is how

00:03:13,230 --> 00:03:17,910
to implement the communications between

00:03:15,300 --> 00:03:21,030
this view and i/o devices on different

00:03:17,910 --> 00:03:23,280
machines the next one is how to keep

00:03:21,030 --> 00:03:25,560
signalization of memory and the time

00:03:23,280 --> 00:03:27,900
among different machines since the guest

00:03:25,560 --> 00:03:30,720
OS is now running on the distributed

00:03:27,900 --> 00:03:35,549
environment we saw the solution to those

00:03:30,720 --> 00:03:38,640
challenges let's begin with the view

00:03:35,549 --> 00:03:40,620
virtualization in our design each team

00:03:38,640 --> 00:03:43,170
will create a food amounts of this view

00:03:40,620 --> 00:03:46,200
stress we divide that into local this

00:03:43,170 --> 00:03:47,880
view and a remove this view local refers

00:03:46,200 --> 00:03:50,340
to the we're still running on the local

00:03:47,880 --> 00:03:52,459
machine while the remove referred to the

00:03:50,340 --> 00:03:55,680
VCO running on other physical machine

00:03:52,459 --> 00:03:57,870
locally spirit behave as usual

00:03:55,680 --> 00:04:01,709
why the remove this view set is dummy

00:03:57,870 --> 00:04:03,840
and an arrow type into KVM therefore

00:04:01,709 --> 00:04:06,329
only so physically this view thread will

00:04:03,840 --> 00:04:08,880
run on physicalist view of each machine

00:04:06,329 --> 00:04:11,880
which visualize the distributions of

00:04:08,880 --> 00:04:15,360
these views as we have shown in the demo

00:04:11,880 --> 00:04:17,880
with you 0 to 15 located on the machine

00:04:15,360 --> 00:04:21,209
0 and the rest with view are located on

00:04:17,880 --> 00:04:24,539
the mushy one for machine 0 this view 0

00:04:21,209 --> 00:04:26,920
to 15 local biz view while the others

00:04:24,539 --> 00:04:30,260
are remove is view

00:04:26,920 --> 00:04:32,720
now we have disability with use two

00:04:30,260 --> 00:04:36,170
different machine the next thing to be

00:04:32,720 --> 00:04:38,720
consider is the ipi folding the overall

00:04:36,170 --> 00:04:41,690
strategy is straightforward if the ipi

00:04:38,720 --> 00:04:44,510
is sent to the local with view then we

00:04:41,690 --> 00:04:47,090
just process yes usual otherwise resent

00:04:44,510 --> 00:04:50,350
it to remove human and inject it to the

00:04:47,090 --> 00:04:53,390
apic of the target base view for example

00:04:50,350 --> 00:04:55,790
visible zero locating on the human zeros

00:04:53,390 --> 00:04:58,430
and an api to the this view one located

00:04:55,790 --> 00:05:02,900
on the human one so kimmel zeros to

00:04:58,430 --> 00:05:05,750
forward this IP i to the q1 however

00:05:02,900 --> 00:05:08,570
there is a detail of api see that makes

00:05:05,750 --> 00:05:11,540
things more complicated as it is s

00:05:08,570 --> 00:05:14,840
platform or IPS are implemented as

00:05:11,540 --> 00:05:17,510
broadcast message under the whole after

00:05:14,840 --> 00:05:20,630
receiving an IP i message thus view use

00:05:17,510 --> 00:05:22,970
three special register of api c to

00:05:20,630 --> 00:05:26,300
determine whether it is the destinations

00:05:22,970 --> 00:05:28,460
of this IP i but in a distributed

00:05:26,300 --> 00:05:31,250
environment we cannot check the

00:05:28,460 --> 00:05:34,460
relevancy of remove these views so we

00:05:31,250 --> 00:05:36,590
initialize MEAP Isis for removes abused

00:05:34,460 --> 00:05:40,340
to provide those three necessary

00:05:36,590 --> 00:05:42,770
registers whenever locus will modify one

00:05:40,340 --> 00:05:45,290
of those three register it will do a

00:05:42,770 --> 00:05:49,160
broadcast to make Ottoman API see up

00:05:45,290 --> 00:05:51,500
today then the remove whom you could

00:05:49,160 --> 00:05:55,550
know the target of an idea and enjoy it

00:05:51,500 --> 00:05:58,610
accordingly in this way IP i forwarding

00:05:55,550 --> 00:06:01,400
implements the interim ingestion inhuman

00:05:58,610 --> 00:06:05,330
ones will it behave as the same as

00:06:01,400 --> 00:06:07,880
receiving api for local beach view in

00:06:05,330 --> 00:06:10,370
addition to the ipi folding the

00:06:07,880 --> 00:06:13,070
interests and for i/o devices to these

00:06:10,370 --> 00:06:14,990
views also need to be forward if the

00:06:13,070 --> 00:06:18,440
beach view and i/o devices are not

00:06:14,990 --> 00:06:20,390
located on the same machine or as it is

00:06:18,440 --> 00:06:22,610
says preference there are two ways for

00:06:20,390 --> 00:06:25,940
devices to send and interact that is

00:06:22,610 --> 00:06:28,520
through our PLC or msi one important

00:06:25,940 --> 00:06:31,730
difference is that multiple Legacy's

00:06:28,520 --> 00:06:34,400
devices 301 our api see why each modern

00:06:31,730 --> 00:06:38,419
PCI or PCI device configured on and

00:06:34,400 --> 00:06:40,310
generates interest on their own the

00:06:38,419 --> 00:06:43,250
interrupt forwarding process

00:06:40,310 --> 00:06:44,240
our apse stolen in this figure as there

00:06:43,250 --> 00:06:47,030
should be only one

00:06:44,240 --> 00:06:47,540
I will Piz position we dedicate one of

00:06:47,030 --> 00:06:51,560
who

00:06:47,540 --> 00:06:53,540
Kim you as master after a few maintain

00:06:51,560 --> 00:06:55,850
the Tommy Iowa pic2 collect those

00:06:53,540 --> 00:06:58,640
interest signals and forward and to the

00:06:55,850 --> 00:07:00,800
master our API see reefs and the rights

00:06:58,640 --> 00:07:03,920
to the register of IOPS II are all

00:07:00,800 --> 00:07:05,320
rooted to the master IP I see so it

00:07:03,920 --> 00:07:07,880
counting all the necessary

00:07:05,320 --> 00:07:10,670
configurations and is able to generate

00:07:07,880 --> 00:07:15,920
interest once the four were single or a

00:07:10,670 --> 00:07:18,590
wife also I all appear Isis requires an

00:07:15,920 --> 00:07:21,920
end of interim message from CPUs for

00:07:18,590 --> 00:07:23,810
level chicken interest YMS I does not so

00:07:21,920 --> 00:07:27,080
we also need to forward end of

00:07:23,810 --> 00:07:30,380
interrupts message to the master IO apic

00:07:27,080 --> 00:07:32,870
who are necessary for MSI things are

00:07:30,380 --> 00:07:35,060
much simpler if the access to the PC

00:07:32,870 --> 00:07:37,310
configuration space our poverty forward

00:07:35,060 --> 00:07:40,190
the MSI of this device will be

00:07:37,310 --> 00:07:42,410
configured correctly then all we need is

00:07:40,190 --> 00:07:45,020
to forward interest to the remove is

00:07:42,410 --> 00:07:48,620
view when MMS is generated by this

00:07:45,020 --> 00:07:52,850
device the next pass is the aisle

00:07:48,620 --> 00:07:56,180
folding January our devices and access

00:07:52,850 --> 00:07:57,740
and the program through MMI all why on

00:07:56,180 --> 00:08:00,590
sa t--'s is performed there is an

00:07:57,740 --> 00:08:02,600
additional IOH a space that can be only

00:08:00,590 --> 00:08:06,140
accessed through special Pio

00:08:02,600 --> 00:08:09,590
instructions once the VCO performs a Pio

00:08:06,140 --> 00:08:13,430
or MMA all it will trap to que cambian

00:08:09,590 --> 00:08:16,790
or q accordingly when KBM exit due to a

00:08:13,430 --> 00:08:19,880
Pio or MMI all we add a check if the Pio

00:08:16,790 --> 00:08:22,460
or MMI all is to the remote us we will

00:08:19,880 --> 00:08:24,560
forward it to the remote human after the

00:08:22,460 --> 00:08:27,200
access is processed on the Riverside

00:08:24,560 --> 00:08:29,000
reprise Samba and then we can finish

00:08:27,200 --> 00:08:32,990
this i/o abscess and the return to the

00:08:29,000 --> 00:08:35,780
guest mode again for PC or PCI devices

00:08:32,990 --> 00:08:37,910
the saturation is more complicated each

00:08:35,780 --> 00:08:41,270
device has its own configuration space

00:08:37,910 --> 00:08:44,240
which is SS indirectly through the Pio

00:08:41,270 --> 00:08:48,620
we need to distinguish access to the

00:08:44,240 --> 00:08:50,920
configuration space of local and the

00:08:48,620 --> 00:08:54,080
remote devices and forward accordingly

00:08:50,920 --> 00:08:56,270
further the MMO memory regions is

00:08:54,080 --> 00:08:58,220
Namie config we need to broadcast this

00:08:56,270 --> 00:09:01,190
configuration so that we can distinguish

00:08:58,220 --> 00:09:05,840
Mme owes to remote devices and legal

00:09:01,190 --> 00:09:07,330
mouse nest we will talk about the memory

00:09:05,840 --> 00:09:10,700
and the high second ization of

00:09:07,330 --> 00:09:13,370
distribute EQ my panel includes home we

00:09:10,700 --> 00:09:14,960
will talk about this so let's call the

00:09:13,370 --> 00:09:17,030
virtualization of memory since I've

00:09:14,960 --> 00:09:20,480
contributed much to this part so

00:09:17,030 --> 00:09:23,690
basically to make challenges to maintain

00:09:20,480 --> 00:09:25,340
a consistent view of memory for multiple

00:09:23,690 --> 00:09:26,990
machines to achieve this we've

00:09:25,340 --> 00:09:31,340
implemented a classical distribution

00:09:26,990 --> 00:09:35,060
memory in KVM to provide the coherent

00:09:31,340 --> 00:09:38,480
memory required by guests as guest is

00:09:35,060 --> 00:09:41,090
not well to have either so we cannot use

00:09:38,480 --> 00:09:45,710
explicit message passing to maintain

00:09:41,090 --> 00:09:50,360
consistency or use modern GSM variants

00:09:45,710 --> 00:09:52,580
that allow or even enforce clients to do

00:09:50,360 --> 00:09:55,730
manual synchronization to improve

00:09:52,580 --> 00:09:59,420
performance so this is the reason why we

00:09:55,730 --> 00:10:02,990
choose to use classical DSM solution and

00:09:59,420 --> 00:10:07,910
take it back to 1989 and we try to use

00:10:02,990 --> 00:10:10,630
our DMA network to speed-up it so for

00:10:07,910 --> 00:10:12,740
those who are not familiar with DSM a

00:10:10,630 --> 00:10:15,500
brief overview of it

00:10:12,740 --> 00:10:17,480
basically we have three sets motiva

00:10:15,500 --> 00:10:21,140
shared and email associate with each

00:10:17,480 --> 00:10:22,790
page and they're controlled by EPT if a

00:10:21,140 --> 00:10:27,200
page is in multi-state it indicates

00:10:22,790 --> 00:10:29,390
Express ownership of this page and have

00:10:27,200 --> 00:10:32,240
read and write privileges if pages in

00:10:29,390 --> 00:10:35,600
the shared state then it can it is

00:10:32,240 --> 00:10:38,120
potentially owned by multiple machines

00:10:35,600 --> 00:10:42,230
and is write protected if it a pages in

00:10:38,120 --> 00:10:44,720
United State then it means the current

00:10:42,230 --> 00:10:47,510
given instance the lot on develop a copy

00:10:44,720 --> 00:10:51,310
of this page and then the corresponding

00:10:47,510 --> 00:10:54,620
EBT entries mark lot present so our

00:10:51,310 --> 00:10:58,910
operation of DSM follows a simple MSI

00:10:54,620 --> 00:11:02,420
protocol that is well gasps tries to

00:10:58,910 --> 00:11:07,400
write a shared own web page then it will

00:11:02,420 --> 00:11:07,989
first acquire retrieve the latest copy

00:11:07,400 --> 00:11:11,689
of this

00:11:07,989 --> 00:11:14,299
completely right the immediate or the

00:11:11,689 --> 00:11:17,289
covers of this page and then sell the

00:11:14,299 --> 00:11:21,669
state to multiple if the best try to

00:11:17,289 --> 00:11:26,509
read email tape that it will first

00:11:21,669 --> 00:11:28,849
retrieve the copy and then add this

00:11:26,509 --> 00:11:35,869
requesting page to the cassette of the

00:11:28,849 --> 00:11:39,409
owner of this page well sorry

00:11:35,869 --> 00:11:43,009
well I mentioned the owner and copy said

00:11:39,409 --> 00:11:46,849
well the owner of a multiple pages

00:11:43,009 --> 00:11:49,899
itself and for share paid for the copies

00:11:46,849 --> 00:11:56,059
of share page we designate one of copies

00:11:49,899 --> 00:11:58,879
the owner and set it and maintain a copy

00:11:56,059 --> 00:12:01,819
set of those copies at this page and

00:11:58,879 --> 00:12:03,919
then we have managers to track owner of

00:12:01,819 --> 00:12:06,470
those Papes each machine is responsible

00:12:03,919 --> 00:12:09,019
for a portion of guests memory and this

00:12:06,470 --> 00:12:13,039
mentor of this memory so let's log into

00:12:09,019 --> 00:12:15,859
detail for showing these two figures for

00:12:13,039 --> 00:12:19,429
the first steps that gap since we have

00:12:15,859 --> 00:12:24,259
said those privileges in EBT when the

00:12:19,429 --> 00:12:27,439
gap try to write to a shared hedgerow

00:12:24,259 --> 00:12:31,459
access invalidate that it will first

00:12:27,439 --> 00:12:34,239
cause an apt evaluation and then the

00:12:31,459 --> 00:12:38,720
exclusion is transferred to KVM then

00:12:34,239 --> 00:12:40,729
intercept power DSM well if you if the

00:12:38,720 --> 00:12:44,509
manager is owner we should you can just

00:12:40,729 --> 00:12:47,449
retrieve page from mentor if not we can

00:12:44,509 --> 00:12:51,799
tag it the request to the owner and a

00:12:47,449 --> 00:12:56,869
gadget so basically there to situation

00:12:51,799 --> 00:12:58,220
if it is a real we should just add the

00:12:56,869 --> 00:13:03,829
requesting page to the publisher of

00:12:58,220 --> 00:13:07,699
donor and this or this it is right we

00:13:03,829 --> 00:13:10,999
just transfer the copy type of old owner

00:13:07,699 --> 00:13:15,619
to the new owner showing us the blue

00:13:10,999 --> 00:13:20,420
line disappears and then invented old

00:13:15,619 --> 00:13:26,490
copies of this page right before we

00:13:20,420 --> 00:13:32,690
we return to get more so basically this

00:13:26,490 --> 00:13:36,840
is basically we tell now we have give a

00:13:32,690 --> 00:13:38,430
review of DSM and here are some

00:13:36,840 --> 00:13:42,240
interesting themes that we've

00:13:38,430 --> 00:13:46,950
encountered in the temp to implement

00:13:42,240 --> 00:13:50,670
this DSM in KVM well since we're there

00:13:46,950 --> 00:13:53,190
are some difficulties due to the

00:13:50,670 --> 00:13:56,160
complexity of the KVM memory subsystem

00:13:53,190 --> 00:13:58,260
but more importantly we found that map

00:13:56,160 --> 00:14:01,140
amendment but the first challenges that

00:13:58,260 --> 00:14:02,580
maybe management in the presence of

00:14:01,140 --> 00:14:06,330
virtualization is quite different from

00:14:02,580 --> 00:14:08,460
those in traditional DSM's that is you

00:14:06,330 --> 00:14:10,070
know like Kimio allocates the cat memory

00:14:08,460 --> 00:14:13,650
in its virtual dressed place and

00:14:10,070 --> 00:14:16,950
registrate to KVM so essentially we have

00:14:13,650 --> 00:14:19,650
the only shared space we have is the

00:14:16,950 --> 00:14:24,920
grass physical address space so we

00:14:19,650 --> 00:14:31,080
should use the GPA address in our

00:14:24,920 --> 00:14:35,970
internal messages of DSM and one may

00:14:31,080 --> 00:14:39,270
think that we may think that we should

00:14:35,970 --> 00:14:42,590
associate the states and copy set with

00:14:39,270 --> 00:14:45,990
page in GPA space it turns out it is not

00:14:42,590 --> 00:14:49,530
like this because there can be some page

00:14:45,990 --> 00:14:54,260
in HBA face that can correspond to

00:14:49,530 --> 00:14:59,190
multiple page in GPA space a words in

00:14:54,260 --> 00:15:01,230
x86 architectures basically every

00:14:59,190 --> 00:15:03,900
essentially every page in edgeways let's

00:15:01,230 --> 00:15:07,860
put on to two pages in GPS because of

00:15:03,900 --> 00:15:10,110
the SMM pseudo GPS base so we maintain

00:15:07,860 --> 00:15:13,310
state and copy set of pages in HPA space

00:15:10,110 --> 00:15:17,310
and maintain the reverse mapping from

00:15:13,310 --> 00:15:21,720
hva to to deviate lives and when we try

00:15:17,310 --> 00:15:25,290
to change the state of a page in the

00:15:21,720 --> 00:15:28,410
state of n HB a page we will change old

00:15:25,290 --> 00:15:31,110
EPT entries of those corresponding GPA

00:15:28,410 --> 00:15:33,510
pips and then the second generation is

00:15:31,110 --> 00:15:36,300
that there can be memory access

00:15:33,510 --> 00:15:42,240
bypassing the protection provided by EPT

00:15:36,300 --> 00:15:43,769
because well the memory that memory is

00:15:42,240 --> 00:15:45,660
allocated by few minutes of humor and

00:15:43,769 --> 00:15:51,149
KVM can manipulate this guest page

00:15:45,660 --> 00:15:53,850
directly so the solution is to add pin

00:15:51,149 --> 00:15:55,529
and unpin operations exposed as DSM man

00:15:53,850 --> 00:15:59,190
pain I'll control to kill me

00:15:55,529 --> 00:16:02,100
those are basically basically locking

00:15:59,190 --> 00:16:05,040
operations for example if you want to

00:16:02,100 --> 00:16:08,399
operate on some page then we first ping

00:16:05,040 --> 00:16:11,300
it transfer it to our desired state and

00:16:08,399 --> 00:16:14,730
block all incoming requests on this page

00:16:11,300 --> 00:16:17,790
then we can do and if you want to want

00:16:14,730 --> 00:16:20,790
to this page and the MP need a block

00:16:17,790 --> 00:16:24,240
king order incoming requests on this

00:16:20,790 --> 00:16:26,610
page and proceeded usual well there

00:16:24,240 --> 00:16:28,740
another thing is time second edition

00:16:26,610 --> 00:16:32,310
well at first we haven't considered it

00:16:28,740 --> 00:16:35,779
only to find that some time related

00:16:32,310 --> 00:16:38,730
system course such as sleep would not

00:16:35,779 --> 00:16:41,339
did not behave correctly for example

00:16:38,730 --> 00:16:45,209
sleep would sleep for longer than we

00:16:41,339 --> 00:16:47,970
requested it turns out it is thought of

00:16:45,209 --> 00:16:50,640
PBM clock chemical oak is a prioritized

00:16:47,970 --> 00:16:54,060
clock device that ring a constant rate

00:16:50,640 --> 00:17:01,290
of one covers usually used by s.o.s its

00:16:54,060 --> 00:17:04,530
primary plot sauce so we since Camus has

00:17:01,290 --> 00:17:08,900
to initialize the TVM clock to zero upon

00:17:04,530 --> 00:17:12,390
startup we have different offsets of

00:17:08,900 --> 00:17:17,010
kvam clock in different instance of km

00:17:12,390 --> 00:17:21,089
you a result in a clock skill problem so

00:17:17,010 --> 00:17:24,270
our solution is to make Kaimuki record

00:17:21,089 --> 00:17:26,790
the value of given clock of the master

00:17:24,270 --> 00:17:28,890
human that is the first started commune

00:17:26,790 --> 00:17:31,919
and then that's this value and apply it

00:17:28,890 --> 00:17:35,490
to the chemical of the current commune

00:17:31,919 --> 00:17:42,120
so this way our BCPs were see the same

00:17:35,490 --> 00:17:44,490
value of km clock okay okay that's our

00:17:42,120 --> 00:17:46,710
desires of this beauty queue then we

00:17:44,490 --> 00:17:47,460
will talk about the performance the

00:17:46,710 --> 00:17:49,649
distributed

00:17:47,460 --> 00:17:52,740
Kumu is able to run popular Linux

00:17:49,649 --> 00:17:55,140
distributions as guess OS we conduct a

00:17:52,740 --> 00:17:57,990
series of experiments on our prototype

00:17:55,140 --> 00:18:00,230
with below configuration including you

00:17:57,990 --> 00:18:04,559
join a network debtor Fortis vinegar and

00:18:00,230 --> 00:18:06,000
HCA for our DMA Network we have two

00:18:04,559 --> 00:18:08,429
purpose on experiments

00:18:06,000 --> 00:18:10,590
the first one is running some benchmarks

00:18:08,429 --> 00:18:13,320
on different guest OS using the tissue

00:18:10,590 --> 00:18:16,049
beauty qumu comparing running with then

00:18:13,320 --> 00:18:18,929
on in the spark and measuring the tie

00:18:16,049 --> 00:18:21,659
consumption we're on SB six leanness and

00:18:18,929 --> 00:18:24,409
spark with same configurations on three

00:18:21,659 --> 00:18:27,870
benchmark the green power represent the

00:18:24,409 --> 00:18:30,510
sv6 the blue bar linux by the orange

00:18:27,870 --> 00:18:33,120
about a spark refried that in some case

00:18:30,510 --> 00:18:36,690
distributed queue out performs back even

00:18:33,120 --> 00:18:38,820
when running on leanness the second one

00:18:36,690 --> 00:18:42,179
is providing the ties binding on each

00:18:38,820 --> 00:18:45,299
part of VM to identify the performance

00:18:42,179 --> 00:18:47,789
bottleneck of this system we fry that

00:18:45,299 --> 00:18:51,120
interrupt or IO thought is spent ice

00:18:47,789 --> 00:18:53,190
less than 1% while the most high span in

00:18:51,120 --> 00:18:56,039
non-root moments that gets to some

00:18:53,190 --> 00:18:58,200
useful work so the bottleneck is exactly

00:18:56,039 --> 00:19:00,929
the page fault of the distributed shared

00:18:58,200 --> 00:19:03,210
memory then we compare the time

00:19:00,929 --> 00:19:05,730
consumption when using the TCO RDMA

00:19:03,210 --> 00:19:08,909
network the green bar represent our DMA

00:19:05,730 --> 00:19:10,710
were the blue bar represent SP lattices

00:19:08,909 --> 00:19:12,960
in the bottle bus is the ratio that

00:19:10,710 --> 00:19:16,409
distributed shared memory page four

00:19:12,960 --> 00:19:19,789
occupies when the patron with TCP net

00:19:16,409 --> 00:19:23,250
was payable 50% of time distributed

00:19:19,789 --> 00:19:25,980
remember event page for the patron with

00:19:23,250 --> 00:19:29,789
Audrina will only spend about 25% of

00:19:25,980 --> 00:19:31,710
ties so we can conclude that faster DMA

00:19:29,789 --> 00:19:33,750
network is necessary under can

00:19:31,710 --> 00:19:36,120
potentially make distributed Qumu

00:19:33,750 --> 00:19:40,620
practical enough for real-world use

00:19:36,120 --> 00:19:43,140
cases to someone we try to extend human

00:19:40,620 --> 00:19:46,110
to support guest OS running on multiple

00:19:43,140 --> 00:19:49,409
machines with a consistent will reduce

00:19:46,110 --> 00:19:52,020
virtualization issues about human and

00:19:49,409 --> 00:19:54,570
memory in distributed environment our

00:19:52,020 --> 00:19:58,039
experience saw the potentials of

00:19:54,570 --> 00:20:00,720
distributed commune at the last we will

00:19:58,039 --> 00:20:01,440
discuss some future works of distributed

00:20:00,720 --> 00:20:06,360
commune

00:20:01,440 --> 00:20:07,560
firstly we now disable the 30 and SSP

00:20:06,360 --> 00:20:10,590
support of EDG

00:20:07,560 --> 00:20:12,840
when this feature is able and the access

00:20:10,590 --> 00:20:16,290
to the guest page table including the

00:20:12,840 --> 00:20:18,810
page works performed by the power is

00:20:16,290 --> 00:20:21,660
considered by EBT as a write operations

00:20:18,810 --> 00:20:25,230
and when the GPA to hph and salacious

00:20:21,660 --> 00:20:27,510
happen the results turn rifle will cause

00:20:25,230 --> 00:20:30,440
page trailing and ruin the performance

00:20:27,510 --> 00:20:33,030
so we have to disable this feature

00:20:30,440 --> 00:20:35,370
secondary support our cue chip in the

00:20:33,030 --> 00:20:37,530
KVM now we have implement interrupt

00:20:35,370 --> 00:20:40,020
forwarding in the queue which need to

00:20:37,530 --> 00:20:43,080
configure a queue chip in Q mu and make

00:20:40,020 --> 00:20:44,550
more axis from Kannamma to user mode in

00:20:43,080 --> 00:20:47,730
the future we'll put the interrupt

00:20:44,550 --> 00:20:50,400
forwarding mechanism to the KVL surgery

00:20:47,730 --> 00:20:52,740
support distributing our devices Korea

00:20:50,400 --> 00:20:54,750
recently put order devices under the

00:20:52,740 --> 00:20:57,090
master to me and the derive or Pio

00:20:54,750 --> 00:20:59,220
mm i/o tree in the future will support

00:20:57,090 --> 00:21:02,250
making use of our devices from the other

00:20:59,220 --> 00:21:05,010
commune the most challenges since is for

00:21:02,250 --> 00:21:07,500
all torrents if one or more machines

00:21:05,010 --> 00:21:10,680
certainly break down then resew fire way

00:21:07,500 --> 00:21:12,690
to catch and handle it that's all we

00:21:10,680 --> 00:21:14,340
want to share with you this is the home

00:21:12,690 --> 00:21:18,000
page of our poacher and we will upload

00:21:14,340 --> 00:21:20,630
the code to there later so thank you any

00:21:18,000 --> 00:21:20,630
question

00:21:21,630 --> 00:21:24,809
[Applause]

00:21:34,309 --> 00:21:44,790
your your point about the mapping of APA

00:21:39,240 --> 00:21:48,299
and GPA addresses yeah that is the same

00:21:44,790 --> 00:21:53,130
problem for things like migration have

00:21:48,299 --> 00:21:57,169
the same and the way that we solve it in

00:21:53,130 --> 00:22:05,790
migration is that we always migrate

00:21:57,169 --> 00:22:11,309
indexing them so if you always use a

00:22:05,790 --> 00:22:19,190
block that is unique within the qmu

00:22:11,309 --> 00:22:23,010
address space so it's the same problem

00:22:19,190 --> 00:22:27,000
the other question was have you looked

00:22:23,010 --> 00:22:31,110
at all the things like a cat no sure we

00:22:27,000 --> 00:22:36,590
did something similar a few years what

00:22:31,110 --> 00:22:36,590
so there's been a few attempts to do DSL

00:22:36,770 --> 00:22:49,110
how did you actually we have no actually

00:22:46,260 --> 00:22:52,280
we have no see before and we will see

00:22:49,110 --> 00:22:52,280
after that

00:22:56,220 --> 00:23:01,900
okay I was actually wondering if you

00:22:59,080 --> 00:23:04,780
compare the performance to standard

00:23:01,900 --> 00:23:08,110
Linux clustering standard same standard

00:23:04,780 --> 00:23:09,550
you can get multiple Linux kernels

00:23:08,110 --> 00:23:18,090
talking to each other directly on the

00:23:09,550 --> 00:23:18,090
guest level years ago

00:23:22,360 --> 00:23:26,420
sorry I don't get your point okay so I

00:23:25,190 --> 00:23:29,720
was wondering if you compare the

00:23:26,420 --> 00:23:32,330
performance with the blended clustering

00:23:29,720 --> 00:23:34,250
basically running to cue animals with

00:23:32,330 --> 00:23:37,540
guests that talk to each other instead

00:23:34,250 --> 00:23:37,540
of KVM was talking to each other

00:23:43,920 --> 00:23:48,120
so we can talk about later

00:24:05,989 --> 00:24:14,489
did you see any issues with

00:24:08,479 --> 00:24:19,009
synchronizing okay we have consider it

00:24:14,489 --> 00:24:23,159
but we haven't implemented yet also

00:24:19,009 --> 00:24:25,759
since TSC can already be synchronized in

00:24:23,159 --> 00:24:31,859
some environments in real hardware so

00:24:25,759 --> 00:24:36,749
the Linux Linux gas can deal with it in

00:24:31,859 --> 00:24:43,249
most cases most applications can bomb as

00:24:36,749 --> 00:24:43,249
well as usual and not get some problem

00:24:48,160 --> 00:24:53,440
so thank you okay

00:24:50,830 --> 00:24:59,219
[Applause]

00:24:53,440 --> 00:24:59,219

YouTube URL: https://www.youtube.com/watch?v=GprmhYU1M8Q


