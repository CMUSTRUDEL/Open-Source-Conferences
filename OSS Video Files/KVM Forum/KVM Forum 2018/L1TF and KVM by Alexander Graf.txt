Title: L1TF and KVM by Alexander Graf
Publication date: 2018-10-31
Playlist: KVM Forum 2018
Description: 
	Recently a new speculative execution side channel was unvealed, which
could potentially result in leakage of arbitrary memory contents into
unprivileged virtual machines on most recent Intel CPUs. This
presentation will give insights as to what the L1 Terminal Fault (L1TF)
Spectre vulnerability is. It will show how it can be exploited and based
on that knowledge it will take a look at how KVM mitigates those
issues. It will also show performance penalties these mitigations incur.

On top of that, the presentation will present an alternative work in
progress approach to mitigate L1TF that may recover some of the
performance penalties by leveraging unrelated CPU features.

---

Alexander Graf
SUSE :)
Principal Software Engineer

Alexander started working for SUSE about 10 years ago. Since then he worked on fancy things like SUSE Studio, QEMU, KVM, openSUSE and SLES on ARM and U-Boot. Whenever something really useful comes to his mind, he tends to implement it. Among others he did Mac OS X virtualization using KVM, nested SVM, KVM on PowerPC, a lot of work in QEMU for openSUSE on ARM and the UEFI compatibility layer in U-Boot.
Captions: 
	00:00:00,350 --> 00:00:02,710
[Music]

00:00:05,540 --> 00:00:10,620
good morning welcome to premium from

00:00:07,589 --> 00:00:12,929
2018 I got the glory of basically

00:00:10,620 --> 00:00:15,150
opening it this time around with an

00:00:12,929 --> 00:00:17,090
really really amazing topic one of the

00:00:15,150 --> 00:00:19,710
many speculation texts we have this year

00:00:17,090 --> 00:00:21,539
this is the latest one of the bunch l1

00:00:19,710 --> 00:00:24,680
TF which is the one that probably

00:00:21,539 --> 00:00:26,490
affects us the most of every one of them

00:00:24,680 --> 00:00:30,060
if I get started

00:00:26,490 --> 00:00:31,529
Who am I who has not see me I'm Alex

00:00:30,060 --> 00:00:33,570
graph I make a BM can we develop

00:00:31,529 --> 00:00:35,730
officially for Souza's doesn't mean I do

00:00:33,570 --> 00:00:38,010
a lot of kayvyun continue book these

00:00:35,730 --> 00:00:40,260
things because I got involved in the

00:00:38,010 --> 00:00:42,059
armed coup a while back and basically

00:00:40,260 --> 00:00:44,489
dedicating one time enough to the whole

00:00:42,059 --> 00:00:46,370
case which also got me interviewed and

00:00:44,489 --> 00:00:49,410
you advising so if you want to see other

00:00:46,370 --> 00:00:51,899
amazing fun hex that I do look at

00:00:49,410 --> 00:00:54,629
motherto some other conferences I

00:00:51,899 --> 00:00:56,850
usually do things that seem weird and

00:00:54,629 --> 00:00:59,609
hard um I want yeah there's nothing that

00:00:56,850 --> 00:01:02,370
I actually did it's what Intel did this

00:00:59,609 --> 00:01:03,899
one is not to bring with me I'm just

00:01:02,370 --> 00:01:06,710
going to tell you what this all whole

00:01:03,899 --> 00:01:09,000
thing is about how it works how

00:01:06,710 --> 00:01:15,060
potentially you could make use of it on

00:01:09,000 --> 00:01:17,009
either side of white and blue and ideas

00:01:15,060 --> 00:01:18,450
on how to mitigate it how we mitigate it

00:01:17,009 --> 00:01:20,130
today how we put the times to mitigate

00:01:18,450 --> 00:01:22,470
tomorrow just things that are floating

00:01:20,130 --> 00:01:24,299
around at this point in time but to

00:01:22,470 --> 00:01:26,450
understand what this whole thing is

00:01:24,299 --> 00:01:29,009
about we need to understand what

00:01:26,450 --> 00:01:33,990
speculation is so if you knows what CPU

00:01:29,009 --> 00:01:35,909
speculation really does okay so I need

00:01:33,990 --> 00:01:37,770
to I need to actually go into a bit of

00:01:35,909 --> 00:01:40,259
detail there so this is a simple C

00:01:37,770 --> 00:01:46,680
snippet just a simple C function that

00:01:40,259 --> 00:01:48,750
takes a pointer and then as a number to

00:01:46,680 --> 00:01:50,880
a global variable and then returns in

00:01:48,750 --> 00:01:52,530
addition of that number and the dear

00:01:50,880 --> 00:01:54,210
friends of that pointer this is a

00:01:52,530 --> 00:01:55,409
completely contrived example I just

00:01:54,210 --> 00:01:58,469
wanted to have some code that would

00:01:55,409 --> 00:02:00,540
potentially speculate in your CPU and so

00:01:58,469 --> 00:02:01,770
in reality when you CPU executes this is

00:02:00,540 --> 00:02:03,509
done nice you could sing code it

00:02:01,770 --> 00:02:06,240
executes assembly or well actually all

00:02:03,509 --> 00:02:08,670
codes you know these these numbers

00:02:06,240 --> 00:02:10,569
strings here these number sequences that

00:02:08,670 --> 00:02:13,030
are human readable

00:02:10,569 --> 00:02:15,489
see that reusable on the right hand side

00:02:13,030 --> 00:02:17,760
and this is the thing you see you

00:02:15,489 --> 00:02:20,230
actually goes and makes you self to

00:02:17,760 --> 00:02:23,230
execute whatever you want attracts acute

00:02:20,230 --> 00:02:28,599
so in this case what this code does is

00:02:23,230 --> 00:02:30,700
basically goes and adds the one value we

00:02:28,599 --> 00:02:33,459
had we've had to be put in as a

00:02:30,700 --> 00:02:36,670
parameter to the function to a global

00:02:33,459 --> 00:02:40,450
variable which is in memory then it

00:02:36,670 --> 00:02:42,879
copies the other the better the result

00:02:40,450 --> 00:02:45,989
of that in the another register which is

00:02:42,879 --> 00:02:49,689
the return of Manchester and at the

00:02:45,989 --> 00:02:50,919
another point any reference to our data

00:02:49,689 --> 00:02:54,250
structure that we passed into the C

00:02:50,919 --> 00:02:56,049
function to that one again in return

00:02:54,250 --> 00:02:57,760
it's pretty just a couple of

00:02:56,049 --> 00:02:59,019
instructions to show the example of what

00:02:57,760 --> 00:03:01,540
speculation that's because in reality

00:02:59,019 --> 00:03:03,819
you CPU doesn't execute those

00:03:01,540 --> 00:03:05,760
instructions one after another this it

00:03:03,819 --> 00:03:08,590
does give you a fake assumption it would

00:03:05,760 --> 00:03:10,079
but in reality doing that first

00:03:08,590 --> 00:03:14,049
instruction is going to take a while

00:03:10,079 --> 00:03:16,479
because this thing over here this

00:03:14,049 --> 00:03:19,419
builder is a memory and memory is not

00:03:16,479 --> 00:03:21,280
always passed to access it depends on

00:03:19,419 --> 00:03:23,169
how fair I put on kind of constraints on

00:03:21,280 --> 00:03:24,720
how fast it is to access I will get you

00:03:23,169 --> 00:03:28,449
better than America later slides but

00:03:24,720 --> 00:03:29,769
basically this instruction might take it

00:03:28,449 --> 00:03:32,079
might end up to a few hundred cycles

00:03:29,769 --> 00:03:35,169
depending on how how things go at this

00:03:32,079 --> 00:03:36,220
point even more so during that time you

00:03:35,169 --> 00:03:38,829
have a lot of spare time on your hands

00:03:36,220 --> 00:03:40,870
what does to you as a CPU well you may

00:03:38,829 --> 00:03:43,419
as well go and speculate in that

00:03:40,870 --> 00:03:44,590
instruction and do other things I just

00:03:43,419 --> 00:03:45,669
realized there's a terrible example

00:03:44,590 --> 00:03:47,109
because that instruction could actually

00:03:45,669 --> 00:03:50,590
get exited because it needs to be solved

00:03:47,109 --> 00:03:53,159
but you're getting the idea the CPU

00:03:50,590 --> 00:03:55,949
basically goes on and executes stuff and

00:03:53,159 --> 00:03:58,989
that's all of that in the background

00:03:55,949 --> 00:04:01,930
while it is it basically shows you the

00:03:58,989 --> 00:04:03,819
world that lives here but in reality it

00:04:01,930 --> 00:04:06,250
already has something like a sibling

00:04:03,819 --> 00:04:09,329
look show CPU that executes all these

00:04:06,250 --> 00:04:11,650
pieces over here one after another

00:04:09,329 --> 00:04:14,680
even through we are still stuck at this

00:04:11,650 --> 00:04:16,389
instruction and the idea is that any of

00:04:14,680 --> 00:04:19,389
these things down here we're accessing

00:04:16,389 --> 00:04:22,330
memory for example we can pull that into

00:04:19,389 --> 00:04:23,020
faster access Panthers than what we

00:04:22,330 --> 00:04:24,940
would

00:04:23,020 --> 00:04:26,830
if we didn't execute the piece in the B

00:04:24,940 --> 00:04:29,319
that's roughly the idea that's that's

00:04:26,830 --> 00:04:31,960
more to it but just so you it's all

00:04:29,319 --> 00:04:34,419
about being fast in memory access that

00:04:31,960 --> 00:04:35,979
that is the ultimate goal sometimes you

00:04:34,419 --> 00:04:38,319
can actually use the results you take

00:04:35,979 --> 00:04:45,009
like even speculation even in in your

00:04:38,319 --> 00:04:48,669
wiener but if we look at what this this

00:04:45,009 --> 00:04:50,050
this point of really is it that's a

00:04:48,669 --> 00:04:52,889
couple very will be accessing this

00:04:50,050 --> 00:04:56,590
memory were accessing that one goes and

00:04:52,889 --> 00:04:59,860
acts that dereferences or refers to a

00:04:56,590 --> 00:05:03,310
location in memory and memory these days

00:04:59,860 --> 00:05:05,620
is incredibly slow and if I'm saying it

00:05:03,310 --> 00:05:08,169
gonna be slow I mean on a skylight

00:05:05,620 --> 00:05:10,449
system Dungey find a website where you

00:05:08,169 --> 00:05:11,590
can figure out all the amazing latency

00:05:10,449 --> 00:05:12,789
numbers that it needs tuned to

00:05:11,590 --> 00:05:15,610
accidentally on difference if you

00:05:12,789 --> 00:05:18,220
architecture some types it takes about

00:05:15,610 --> 00:05:19,870
150 CPU cycles depending on how fast you

00:05:18,220 --> 00:05:22,990
CPU wants a faster grant ones but give

00:05:19,870 --> 00:05:26,380
or take color 50 cycles to access just

00:05:22,990 --> 00:05:27,729
memory and I mean if you imagine that

00:05:26,380 --> 00:05:30,310
you wouldn't have anything in between

00:05:27,729 --> 00:05:31,930
your CPU in that memory and every time

00:05:30,310 --> 00:05:35,469
you accidentally it would take 250 CPU

00:05:31,930 --> 00:05:38,710
cycles you basically can tell that you

00:05:35,469 --> 00:05:40,360
would be calling right so it next thing

00:05:38,710 --> 00:05:43,330
memory directly is completely out of the

00:05:40,360 --> 00:05:46,330
question you cannot do that so people

00:05:43,330 --> 00:05:49,570
invented caches um there are a couple of

00:05:46,330 --> 00:05:50,949
levels of caches we for example have the

00:05:49,570 --> 00:05:52,719
level three cache which on that system

00:05:50,949 --> 00:05:55,360
that I have an example is about eight

00:05:52,719 --> 00:05:58,000
megabytes I'm so much much smaller

00:05:55,360 --> 00:06:00,520
amount of memory than your whole memory

00:05:58,000 --> 00:06:04,630
but it is very faster it only takes 40

00:06:00,520 --> 00:06:05,889
cycles to access it's still not as fast

00:06:04,630 --> 00:06:07,599
as you want it to be so that's more

00:06:05,889 --> 00:06:09,280
levels there's a level two cache which

00:06:07,599 --> 00:06:12,610
is even against more so it's only a

00:06:09,280 --> 00:06:14,469
quarter megabyte bit but it is fast it

00:06:12,610 --> 00:06:17,020
only takes 12 Tigers to access and then

00:06:14,469 --> 00:06:19,900
we have the ultimate fast access which

00:06:17,020 --> 00:06:22,300
is our level 1 data cache and that one

00:06:19,900 --> 00:06:24,310
only takes 4 cycles taxes on that

00:06:22,300 --> 00:06:28,409
particular CPU now I have an example as

00:06:24,310 --> 00:06:31,210
an example it's just starving but

00:06:28,409 --> 00:06:32,440
another thing that this diagram doesn't

00:06:31,210 --> 00:06:34,610
show is there's actually a good reason

00:06:32,440 --> 00:06:37,310
for this hierarchy

00:06:34,610 --> 00:06:39,969
that all of these caches sit at

00:06:37,310 --> 00:06:43,580
different pieces in your topology so you

00:06:39,969 --> 00:06:45,229
have level 1 caches per core usually you

00:06:43,580 --> 00:06:47,539
have little to occur so that catches per

00:06:45,229 --> 00:06:50,539
call complex and then you have little 3

00:06:47,539 --> 00:06:56,569
caches per cluster or you maybe prefer

00:06:50,539 --> 00:06:59,180
full system or per se and your Ram is

00:06:56,569 --> 00:07:01,460
depending on how numerous you are also

00:06:59,180 --> 00:07:04,250
either only a single big entity or

00:07:01,460 --> 00:07:07,639
multiple different pieces this could be

00:07:04,250 --> 00:07:09,020
its own presentations alone for me if

00:07:07,639 --> 00:07:11,090
you don't get the full picture but this

00:07:09,020 --> 00:07:14,210
is the rough idea is you have the faster

00:07:11,090 --> 00:07:18,650
you get the smaller the caches and the

00:07:14,210 --> 00:07:22,939
more unique caches so another thing we

00:07:18,650 --> 00:07:25,969
have in modern machines is called paging

00:07:22,939 --> 00:07:28,370
I guess for almost all of you know what

00:07:25,969 --> 00:07:30,110
painting is products quickly get through

00:07:28,370 --> 00:07:32,569
that and that's that the address we

00:07:30,110 --> 00:07:35,000
looked at which is a memory reference to

00:07:32,569 --> 00:07:37,729
memory reference to memory is not

00:07:35,000 --> 00:07:39,669
actually referring memory directly it is

00:07:37,729 --> 00:07:43,029
there's another level of indirection

00:07:39,669 --> 00:07:47,500
because you can always head another

00:07:43,029 --> 00:07:49,969
which is basically we have a virtual a

00:07:47,500 --> 00:07:51,409
virtual address space which our

00:07:49,969 --> 00:07:53,089
applications use so if you're running

00:07:51,409 --> 00:07:54,620
application you have basically the sort

00:07:53,089 --> 00:07:57,139
of really big address space that

00:07:54,620 --> 00:08:00,680
sparsely in between has some pieces that

00:07:57,139 --> 00:08:03,889
then get mapped over into your actual

00:08:00,680 --> 00:08:06,650
physical memory down here using a page

00:08:03,889 --> 00:08:08,210
table entry as a data structure that's

00:08:06,650 --> 00:08:10,610
controlled by your grading system and

00:08:08,210 --> 00:08:12,050
that allows you to basically give you a

00:08:10,610 --> 00:08:13,879
virtual view of the world as an

00:08:12,050 --> 00:08:17,870
application but still maintain a

00:08:13,879 --> 00:08:20,779
contiguous memory model down at the

00:08:17,870 --> 00:08:22,159
actual physical layer this page table

00:08:20,779 --> 00:08:25,759
entries are pretty simple they just

00:08:22,159 --> 00:08:28,009
basically show based based on the it's a

00:08:25,759 --> 00:08:31,610
table that's actually of a hybrid key of

00:08:28,009 --> 00:08:32,990
tables and based on the at the point

00:08:31,610 --> 00:08:34,490
that you get into the page table entry

00:08:32,990 --> 00:08:36,289
you do know which virtual atmosphere

00:08:34,490 --> 00:08:38,000
already referring to which is the one up

00:08:36,289 --> 00:08:39,769
here so what all you need to write into

00:08:38,000 --> 00:08:41,269
your prisoner into your page table entry

00:08:39,769 --> 00:08:42,400
is the physical address of the one down

00:08:41,269 --> 00:08:44,380
here you want to be first

00:08:42,400 --> 00:08:46,029
and a couple of flex right through

00:08:44,380 --> 00:08:50,470
whether you want to actually use Cassius

00:08:46,029 --> 00:08:52,600
or nod for rights user access can use

00:08:50,470 --> 00:08:54,760
the access that is it colonel only page

00:08:52,600 --> 00:08:59,800
table if you've seen meltdown that's the

00:08:54,760 --> 00:09:01,720
one day exploit rights can you write to

00:08:59,800 --> 00:09:02,890
that page can use it read-only or do you

00:09:01,720 --> 00:09:05,050
want to get a page for when you write

00:09:02,890 --> 00:09:05,620
through it and the president that's the

00:09:05,050 --> 00:09:08,589
last one

00:09:05,620 --> 00:09:12,010
if you for for element you have the

00:09:08,589 --> 00:09:14,339
important bit is the present so what

00:09:12,010 --> 00:09:19,000
happens if you don't set the present

00:09:14,339 --> 00:09:19,870
usually in a normal system Memphis still

00:09:19,000 --> 00:09:22,210
it's the case don't worry

00:09:19,870 --> 00:09:25,270
intro didn't mess up that much now you

00:09:22,210 --> 00:09:27,580
are getting a page fault page for mean

00:09:25,270 --> 00:09:30,070
Jackson future stops and at that point

00:09:27,580 --> 00:09:31,240
you're going and recover useful but

00:09:30,070 --> 00:09:32,620
you're going to a recovery function

00:09:31,240 --> 00:09:34,589
basically in your grading system to

00:09:32,620 --> 00:09:36,850
recover from whatever fault they happen

00:09:34,589 --> 00:09:38,350
they can use page was a lot of things we

00:09:36,850 --> 00:09:40,570
use page wasn't it looks for example for

00:09:38,350 --> 00:09:42,160
coffee is right so base where they used

00:09:40,570 --> 00:09:43,570
all over the places it's a it's a calm

00:09:42,160 --> 00:09:47,650
completely novel mechanism they buddies

00:09:43,570 --> 00:09:49,510
using page Falls all day long so with

00:09:47,650 --> 00:09:52,000
this virtual model how does that fit in

00:09:49,510 --> 00:09:54,040
with our caches so we have this level

00:09:52,000 --> 00:09:56,230
one cache and in that level one cache we

00:09:54,040 --> 00:09:58,089
have data for a couple of things we call

00:09:56,230 --> 00:10:02,290
cache lines are just small pieces of

00:09:58,089 --> 00:10:05,080
data and how do we how do you actually

00:10:02,290 --> 00:10:06,700
associate our memory or how do you mean

00:10:05,080 --> 00:10:09,190
how do you know which address the cache

00:10:06,700 --> 00:10:12,160
actually refers to in our overall system

00:10:09,190 --> 00:10:15,640
if we used virtual tags that gets us

00:10:12,160 --> 00:10:17,970
into into really big trouble because if

00:10:15,640 --> 00:10:22,750
you're only virtually intact over here

00:10:17,970 --> 00:10:24,580
then every time we have the same page

00:10:22,750 --> 00:10:27,850
down here mapped into two different

00:10:24,580 --> 00:10:31,390
processes we would have to make sure we

00:10:27,850 --> 00:10:34,209
keep those coherent on the same cache

00:10:31,390 --> 00:10:38,310
hierarchy so that's why people usually

00:10:34,209 --> 00:10:41,500
on Intel always do physically text

00:10:38,310 --> 00:10:43,870
caches which means you putting this onto

00:10:41,500 --> 00:10:47,640
here the the address to this physical

00:10:43,870 --> 00:10:47,640
address in your level one cache

00:10:47,700 --> 00:10:56,220
it is associated a couple of fights with

00:10:51,120 --> 00:10:58,680
a crazy 64 bytes on Intel in a virtual

00:10:56,220 --> 00:11:00,030
machine environment we usually don't

00:10:58,680 --> 00:11:02,010
only have a single page to go through

00:11:00,030 --> 00:11:05,240
because we have a virtual machine so we

00:11:02,010 --> 00:11:07,950
have the same mechanism again for

00:11:05,240 --> 00:11:10,380
translation from host page to perform

00:11:07,950 --> 00:11:12,060
host than we to guest memory and then

00:11:10,380 --> 00:11:13,950
from guess what we two guest application

00:11:12,060 --> 00:11:15,570
the movie so this is a host physical

00:11:13,950 --> 00:11:19,590
address and guest physical address and a

00:11:15,570 --> 00:11:21,180
guest physical shadows so we have two

00:11:19,590 --> 00:11:25,710
levels of page tables which one would

00:11:21,180 --> 00:11:27,540
you put into your cache well the obvious

00:11:25,710 --> 00:11:29,700
answer is you of course always pulled

00:11:27,540 --> 00:11:31,410
the one that's closest to you in and so

00:11:29,700 --> 00:11:33,750
we can in the virtual machine you put

00:11:31,410 --> 00:11:35,250
this address in in a physical

00:11:33,750 --> 00:11:38,720
environment we put this address in

00:11:35,250 --> 00:11:38,720
because then you can speculate faster

00:11:38,960 --> 00:11:42,630
you don't have to go through tune to

00:11:41,010 --> 00:11:43,800
through two levels of HDL just to be

00:11:42,630 --> 00:11:47,850
able to speculate right it's just

00:11:43,800 --> 00:11:49,920
quicker so what does all this tell

00:11:47,850 --> 00:11:52,970
auntie everything but then let's go to

00:11:49,920 --> 00:11:54,090
through it a simple example of what

00:11:52,970 --> 00:11:56,190
secrets

00:11:54,090 --> 00:12:00,770
we could have so it mention we have a

00:11:56,190 --> 00:12:03,060
CPU and the CPU rise some secret code

00:12:00,770 --> 00:12:08,340
something that holds a secret like your

00:12:03,060 --> 00:12:10,190
SSH session anything and obviously

00:12:08,340 --> 00:12:13,280
because it accesses that secret that

00:12:10,190 --> 00:12:16,440
secret is now in your level 1 cache

00:12:13,280 --> 00:12:18,240
because you just accessed it so you want

00:12:16,440 --> 00:12:19,950
to have it accessed fast again all the

00:12:18,240 --> 00:12:24,770
so it's always thought in your level 1

00:12:19,950 --> 00:12:27,930
cache now if somebody evil comes in and

00:12:24,770 --> 00:12:31,290
runs in a virtual machine so you get a

00:12:27,930 --> 00:12:33,360
context which other person comes in runs

00:12:31,290 --> 00:12:38,280
that data chunk is still deliver one

00:12:33,360 --> 00:12:40,140
cache and that person could potentially

00:12:38,280 --> 00:12:43,380
this is taken from official Microsoft

00:12:40,140 --> 00:12:47,250
documentation I just looked that up it

00:12:43,380 --> 00:12:50,850
could you could potentially read some

00:12:47,250 --> 00:12:52,860
variable down here and then access an

00:12:50,850 --> 00:12:55,950
Oracle just a global variable again

00:12:52,860 --> 00:12:57,960
based with an offset based on that value

00:12:55,950 --> 00:12:59,260
when you read which usually well

00:12:57,960 --> 00:13:00,970
translates to

00:12:59,260 --> 00:13:02,290
assembly code and then usually in a

00:13:00,970 --> 00:13:04,660
normal environment you mentioned you

00:13:02,290 --> 00:13:07,000
have you page table all probably set up

00:13:04,660 --> 00:13:09,660
everything is valid you have the present

00:13:07,000 --> 00:13:12,700
bit said everything does exist

00:13:09,660 --> 00:13:15,520
yeah that would mean that you reading

00:13:12,700 --> 00:13:17,620
from this address that address points to

00:13:15,520 --> 00:13:19,300
this point down here which happens to

00:13:17,620 --> 00:13:21,160
have the same address as a physical

00:13:19,300 --> 00:13:22,480
address at that point out because of

00:13:21,160 --> 00:13:24,910
another tag that says I'm in this

00:13:22,480 --> 00:13:29,710
virtual machine it doesn't really affect

00:13:24,910 --> 00:13:32,320
it and then it would go in and basically

00:13:29,710 --> 00:13:35,110
lower get another piece of data for my

00:13:32,320 --> 00:13:36,880
virtual memory internet over that into

00:13:35,110 --> 00:13:39,070
the little one cache and then you can

00:13:36,880 --> 00:13:40,360
just access that one using your

00:13:39,070 --> 00:13:42,340
instructions but that's something what

00:13:40,360 --> 00:13:46,980
we want to do if we want to exploit

00:13:42,340 --> 00:13:50,860
either one terminal for drive so the

00:13:46,980 --> 00:13:53,830
idea behind that is what is we don't

00:13:50,860 --> 00:13:55,540
actually expose a real page table entry

00:13:53,830 --> 00:13:57,510
that says that's mapped entry but

00:13:55,540 --> 00:14:04,030
instead expose something that's invalid

00:13:57,510 --> 00:14:05,500
like a non present entry well if it's

00:14:04,030 --> 00:14:08,770
not present that means you're getting a

00:14:05,500 --> 00:14:10,720
page fold right non presently sweet this

00:14:08,770 --> 00:14:13,330
this page doesn't exist if you please go

00:14:10,720 --> 00:14:17,110
and hold everything you do and instead

00:14:13,330 --> 00:14:19,960
allow me to handle that page fault in a

00:14:17,110 --> 00:14:21,250
defined manner well turns out taking a

00:14:19,960 --> 00:14:23,380
page so it actually takes quite a while

00:14:21,250 --> 00:14:26,250
and what do you do when it something

00:14:23,380 --> 00:14:28,570
takes a while you speculate

00:14:26,250 --> 00:14:31,240
so because the page fault takes so long

00:14:28,570 --> 00:14:33,040
we can now go and actually make use of

00:14:31,240 --> 00:14:35,350
the address that we put into our page

00:14:33,040 --> 00:14:37,210
table entry as a speculation address

00:14:35,350 --> 00:14:38,890
because obviously the non at present

00:14:37,210 --> 00:14:41,800
entry had a valid entry in its page

00:14:38,890 --> 00:14:44,530
table in his physical address keys and

00:14:41,800 --> 00:14:48,940
then we suddenly have in speculative

00:14:44,530 --> 00:14:50,620
context our secret in a register in a

00:14:48,940 --> 00:14:52,210
speculative register so we don't

00:14:50,620 --> 00:14:55,600
actually get to see it but we have

00:14:52,210 --> 00:14:58,230
something we can work with so if we take

00:14:55,600 --> 00:15:01,300
that we shift it over a bit and then we

00:14:58,230 --> 00:15:04,930
access another variable based on the

00:15:01,300 --> 00:15:10,210
secret value that again means we've

00:15:04,930 --> 00:15:11,430
pulling in data into the cache so now we

00:15:10,210 --> 00:15:14,160
have

00:15:11,430 --> 00:15:16,770
another piece of data that we know where

00:15:14,160 --> 00:15:19,980
it is and what it is in the cache that

00:15:16,770 --> 00:15:25,350
is actually accessible by us as a evil

00:15:19,980 --> 00:15:27,570
person we're not evil of course so now

00:15:25,350 --> 00:15:29,040
we get in the page fault handler and in

00:15:27,570 --> 00:15:31,589
the page fault handler all we need to do

00:15:29,040 --> 00:15:35,520
is we need to go and measure how long it

00:15:31,589 --> 00:15:37,500
takes to access really slow memory over

00:15:35,520 --> 00:15:39,779
really fast memory because that one

00:15:37,500 --> 00:15:42,210
piece is now in our level one cache and

00:15:39,779 --> 00:15:45,630
suddenly we basically have about eight

00:15:42,210 --> 00:15:47,510
bits of data from our secret depending

00:15:45,630 --> 00:15:50,040
on how we pick we do the chunks in our

00:15:47,510 --> 00:15:53,220
Oracle but in this example you say it's

00:15:50,040 --> 00:15:55,440
three it's yes so one byte so we now

00:15:53,220 --> 00:15:56,730
have one byte of data that is actually

00:15:55,440 --> 00:16:00,360
secret that we shouldn't even have

00:15:56,730 --> 00:16:03,029
potentially access have access to so

00:16:00,360 --> 00:16:04,920
this gets even better there's another

00:16:03,029 --> 00:16:07,920
cool feature in interesting use called

00:16:04,920 --> 00:16:10,350
hyper-threading so imagine you have a

00:16:07,920 --> 00:16:13,380
CPU and the teeth use a lot of different

00:16:10,350 --> 00:16:15,029
components it has like different an ALU

00:16:13,380 --> 00:16:16,709
actually a lot of different I'll use

00:16:15,029 --> 00:16:18,839
that can do things in parallel and then

00:16:16,709 --> 00:16:21,240
you have load units install units and

00:16:18,839 --> 00:16:23,279
AVX and whatever all of these units and

00:16:21,240 --> 00:16:25,470
most of them are idle because you even

00:16:23,279 --> 00:16:28,740
with speculation you cannot really fill

00:16:25,470 --> 00:16:30,720
any pieces up all the time so Intel

00:16:28,740 --> 00:16:32,730
figured well if we expose another CPU

00:16:30,720 --> 00:16:35,070
that is not actually another CPU but

00:16:32,730 --> 00:16:37,440
maybe just another view onto the same

00:16:35,070 --> 00:16:39,270
CPU that can execute the different

00:16:37,440 --> 00:16:41,820
instruction stream we can maybe fill up

00:16:39,270 --> 00:16:43,410
those instruction units a bit or those

00:16:41,820 --> 00:16:46,080
those those computer commutation units a

00:16:43,410 --> 00:16:47,430
bit better and that's what hyper

00:16:46,080 --> 00:16:50,220
fighting is so hyper threading basically

00:16:47,430 --> 00:16:52,290
shares almost all resources but it's

00:16:50,220 --> 00:16:57,360
from an operating system point of view

00:16:52,290 --> 00:16:59,339
looks like a separate CPU because of

00:16:57,360 --> 00:17:01,200
that it obviously also shares your level

00:16:59,339 --> 00:17:03,000
1 cache which means if you now have your

00:17:01,200 --> 00:17:06,540
secret application running on this one

00:17:03,000 --> 00:17:11,220
fare and your evil application running

00:17:06,540 --> 00:17:13,790
on the other thread you put your secret

00:17:11,220 --> 00:17:16,020
data into your shelter the one clock and

00:17:13,790 --> 00:17:18,480
immediately that other person gets to

00:17:16,020 --> 00:17:21,780
see it you don't even need that context

00:17:18,480 --> 00:17:22,640
switch there's no chance that operating

00:17:21,780 --> 00:17:25,010
system can

00:17:22,640 --> 00:17:26,300
do anything about any of what said was

00:17:25,010 --> 00:17:33,680
what's in here because it doesn't even

00:17:26,300 --> 00:17:35,240
get involved which means how do we

00:17:33,680 --> 00:17:37,310
mitigate all this but how do we how do

00:17:35,240 --> 00:17:38,480
you fix up the situation that makes

00:17:37,310 --> 00:17:42,040
people secure again

00:17:38,480 --> 00:17:44,390
well if I'm running on the same core

00:17:42,040 --> 00:17:46,340
saying the same thread basically if we

00:17:44,390 --> 00:17:47,960
only event in the world but we don't

00:17:46,340 --> 00:17:50,780
have hyper-threading it's only a single

00:17:47,960 --> 00:17:53,570
core we need to have a context switch to

00:17:50,780 --> 00:17:57,710
go between our secret process and our

00:17:53,570 --> 00:18:00,170
untrusted process and because inherently

00:17:57,710 --> 00:18:03,560
this buck can only really be well

00:18:00,170 --> 00:18:04,760
exploited by using the virtual machine

00:18:03,560 --> 00:18:08,440
because the only then you have control

00:18:04,760 --> 00:18:10,940
over your page tables which you need in

00:18:08,440 --> 00:18:13,850
reality we have kvn in the green light

00:18:10,940 --> 00:18:17,570
so we usually have a VM coming in

00:18:13,850 --> 00:18:21,560
between our trusted environment and our

00:18:17,570 --> 00:18:23,330
untrusted environment which means KVN

00:18:21,560 --> 00:18:26,720
can easily just go and flush the cache

00:18:23,330 --> 00:18:28,520
and we go because at that point there's

00:18:26,720 --> 00:18:30,290
nothing left in the cache for this guy

00:18:28,520 --> 00:18:32,150
to see and then he can do whatever he

00:18:30,290 --> 00:18:35,780
wants it couldn't actually affect

00:18:32,150 --> 00:18:38,210
anything well unfortunately that's not

00:18:35,780 --> 00:18:41,930
as easy as it sounds because there's

00:18:38,210 --> 00:18:48,200
hype of it okay so what do you do what

00:18:41,930 --> 00:18:49,400
type of it turn it off exactly you just

00:18:48,200 --> 00:18:53,630
turn it off because why would you need

00:18:49,400 --> 00:18:55,430
CPU features right that is the current

00:18:53,630 --> 00:18:57,140
recommendation so basically if you if

00:18:55,430 --> 00:18:59,480
you're running any recent kernel these

00:18:57,140 --> 00:19:01,490
days it turns off hyper threading for

00:18:59,480 --> 00:19:02,600
you or you that these tells you to turn

00:19:01,490 --> 00:19:04,160
off hyper threading and then this a

00:19:02,600 --> 00:19:05,720
kernel command under the table allows

00:19:04,160 --> 00:19:07,310
you to automatically turn off and type

00:19:05,720 --> 00:19:09,500
operating if you running virtual

00:19:07,310 --> 00:19:13,280
machines because otherwise you will be

00:19:09,500 --> 00:19:15,490
insecure and it flushes the level 1

00:19:13,280 --> 00:19:19,760
cache on the inventory's axis depending

00:19:15,490 --> 00:19:22,850
on a couple of heuristics so what does

00:19:19,760 --> 00:19:25,820
that mean performance wise so

00:19:22,850 --> 00:19:26,960
performance wise the easy thing people

00:19:25,820 --> 00:19:28,490
usually do when they measure performance

00:19:26,960 --> 00:19:31,820
is build kernels because that's what we

00:19:28,490 --> 00:19:34,470
do all day and I couldn't find a better

00:19:31,820 --> 00:19:35,580
example at this point

00:19:34,470 --> 00:19:38,580
and so if you dislike the

00:19:35,580 --> 00:19:40,679
hyper-threading you basically get this

00:19:38,580 --> 00:19:43,830
is an example where you see this is

00:19:40,679 --> 00:19:47,159
running with only I had a 8 core system

00:19:43,830 --> 00:19:50,690
16 threads this is when I only use 8

00:19:47,159 --> 00:19:53,039
cores this is when I use all 16 threats

00:19:50,690 --> 00:19:54,899
the performance difference in the kernel

00:19:53,039 --> 00:19:58,350
build really is 15 to 20 percent it's

00:19:54,899 --> 00:20:00,659
not that much you you are losing a bit

00:19:58,350 --> 00:20:02,190
of performance but then again you gain

00:20:00,659 --> 00:20:03,809
some humour which is good you want to

00:20:02,190 --> 00:20:06,600
gain secure

00:20:03,809 --> 00:20:08,639
I heard of examples and I definitely am

00:20:06,600 --> 00:20:10,169
pretty sure if I actually spend another

00:20:08,639 --> 00:20:11,669
week on this I could probably contrive

00:20:10,169 --> 00:20:17,279
an example way to get this number down

00:20:11,669 --> 00:20:18,809
to 50% but that would be a something

00:20:17,279 --> 00:20:21,720
that usually would not happen in the

00:20:18,809 --> 00:20:23,309
real world it's will be very contract

00:20:21,720 --> 00:20:25,289
example so this is a something actually

00:20:23,309 --> 00:20:28,049
you would see so imagine om to mention

00:20:25,289 --> 00:20:29,759
assume you will definitely get a snowman

00:20:28,049 --> 00:20:37,799
of about 20% if you turn a factor tree

00:20:29,759 --> 00:20:40,500
for the L&D cache process I would say

00:20:37,799 --> 00:20:43,500
it's almost incredible I've heard of

00:20:40,500 --> 00:20:46,289
people that also claimed they found on

00:20:43,500 --> 00:20:48,509
certain CPUs with certain workloads they

00:20:46,289 --> 00:20:53,669
were able to get this number

00:20:48,509 --> 00:20:57,029
again to 50% so in the worst case you're

00:20:53,669 --> 00:20:59,929
basically down to 25% by enabling all

00:20:57,029 --> 00:21:04,230
medications in a real-world example

00:20:59,929 --> 00:21:05,610
assume 20 to 30% maybe but then again it

00:21:04,230 --> 00:21:08,009
depends on your workload if you happen

00:21:05,610 --> 00:21:09,990
to run I don't know

00:21:08,009 --> 00:21:12,090
memcache D maybe that's a completely

00:21:09,990 --> 00:21:16,350
different story that one actually goes

00:21:12,090 --> 00:21:18,059
down 50% so you definitely after

00:21:16,350 --> 00:21:20,549
litigations you want to if you had

00:21:18,059 --> 00:21:21,750
something fine-tuned before your ended

00:21:20,549 --> 00:21:24,360
up mitigations are now you

00:21:21,750 --> 00:21:27,510
we definitely want to measure it again

00:21:24,360 --> 00:21:30,500
just to make sure the environment is

00:21:27,510 --> 00:21:32,610
still as good as you thought it would be

00:21:30,500 --> 00:21:34,080
so what can we do brothers now let me

00:21:32,610 --> 00:21:35,550
know that we can potentially have

00:21:34,080 --> 00:21:37,410
terrible numbers of performance that

00:21:35,550 --> 00:21:39,540
actually opens up a lot of performance

00:21:37,410 --> 00:21:42,170
gap we can fill with other alternative

00:21:39,540 --> 00:21:49,290
ideas to waste the time in more

00:21:42,170 --> 00:21:50,220
innovative ways so you saw this picture

00:21:49,290 --> 00:21:53,130
all right this is basically the

00:21:50,220 --> 00:21:55,440
hypothetic sample we're getting one CPU

00:21:53,130 --> 00:21:57,330
producing in a secret and the other CPU

00:21:55,440 --> 00:22:00,390
consuming the secret and that's nothing

00:21:57,330 --> 00:22:01,950
you can do about it well why is there

00:22:00,390 --> 00:22:04,050
nothing we can do about it I mean there

00:22:01,950 --> 00:22:07,070
there is an event right we we have to

00:22:04,050 --> 00:22:11,670
have a page fault over here to actually

00:22:07,070 --> 00:22:14,870
provoke a speculation without that page

00:22:11,670 --> 00:22:19,410
fault we do not get the speculation so

00:22:14,870 --> 00:22:22,140
why don't we just go and basically well

00:22:19,410 --> 00:22:26,280
we're getting this page fault to get our

00:22:22,140 --> 00:22:30,240
data we have to run our evil code before

00:22:26,280 --> 00:22:33,900
and after and if in between we just go

00:22:30,240 --> 00:22:35,670
and clean all of that up in kvam so in

00:22:33,900 --> 00:22:38,360
KVM you just turn on page holes we would

00:22:35,670 --> 00:22:38,360
be safe for it

00:22:41,399 --> 00:22:45,340
the first thing that that definitely

00:22:43,630 --> 00:22:47,320
implies overhead every page fault would

00:22:45,340 --> 00:22:49,059
be slower so you would slow down your

00:22:47,320 --> 00:22:50,919
non operation but then again if we're

00:22:49,059 --> 00:22:54,120
talking about 20 30 % stolen at least

00:22:50,919 --> 00:22:56,919
maybe that might be worth it it could be

00:22:54,120 --> 00:22:58,600
but that's another caveat even that's

00:22:56,919 --> 00:23:02,529
another really cool feature in tax

00:22:58,600 --> 00:23:05,970
called T is X so thanks for memory

00:23:02,529 --> 00:23:10,480
so using transactional memory you can

00:23:05,970 --> 00:23:14,250
basically have a good number of

00:23:10,480 --> 00:23:18,159
operations behave as if they really only

00:23:14,250 --> 00:23:20,529
ever occurred at as a single entity so

00:23:18,159 --> 00:23:22,149
you have tenant instructions and these

00:23:20,529 --> 00:23:23,850
ten instructions either all comes in at

00:23:22,149 --> 00:23:30,010
the same time or they just never come

00:23:23,850 --> 00:23:32,649
and conveniently enough that includes

00:23:30,010 --> 00:23:34,330
page faults so if in between your

00:23:32,649 --> 00:23:36,549
transaction you're getting a page fault

00:23:34,330 --> 00:23:38,080
it just avoids the resection but

00:23:36,549 --> 00:23:40,330
everything it happened everything that

00:23:38,080 --> 00:23:44,799
happened before that transaction still

00:23:40,330 --> 00:23:47,590
had an effect on your caches add one I

00:23:44,799 --> 00:23:49,000
wanted you know what I mean it basically

00:23:47,590 --> 00:23:51,370
means if you had if you have

00:23:49,000 --> 00:23:53,740
transactions you do not have any event

00:23:51,370 --> 00:23:56,559
and trap on in KDM there's no way you

00:23:53,740 --> 00:23:58,240
can ever know what that that a

00:23:56,559 --> 00:23:59,830
transaction no that is faithful even

00:23:58,240 --> 00:24:04,090
accurate it's completely hidden inside

00:23:59,830 --> 00:24:07,049
the CPU so potentially you could say

00:24:04,090 --> 00:24:09,539
well that's just disabled transactions

00:24:07,049 --> 00:24:13,029
nobody uses protection of memory anyways

00:24:09,539 --> 00:24:14,440
you can just not expose that feature in

00:24:13,029 --> 00:24:15,760
the first place and then you're safe

00:24:14,440 --> 00:24:17,950
again because then we can trap on page

00:24:15,760 --> 00:24:21,419
faults and we can disable transactional

00:24:17,950 --> 00:24:24,450
memory it turns out on modern Intel CPUs

00:24:21,419 --> 00:24:28,750
transactional memory is considered a

00:24:24,450 --> 00:24:30,610
legacy feature so it's not conditionally

00:24:28,750 --> 00:24:32,669
switchable anymore so you can't turn it

00:24:30,610 --> 00:24:32,669
off

00:24:36,109 --> 00:24:40,859
and the other thing is in order to

00:24:39,359 --> 00:24:43,049
actually provoke this page fault you

00:24:40,859 --> 00:24:46,499
always have to have a page table entry

00:24:43,049 --> 00:24:48,349
that has the present bit not set it's

00:24:46,499 --> 00:24:51,029
the only way to ever get this page book

00:24:48,349 --> 00:24:52,950
and at the same time while you have the

00:24:51,029 --> 00:24:55,109
zero in there you have to have something

00:24:52,950 --> 00:24:56,190
sensible in this effort to actually read

00:24:55,109 --> 00:25:04,320
out there the funding cash because

00:24:56,190 --> 00:25:07,499
that's the tactic trying to read from so

00:25:04,320 --> 00:25:09,389
what if in that environments is this are

00:25:07,499 --> 00:25:11,190
nested page environment where we have

00:25:09,389 --> 00:25:14,190
that's the page table and then our own

00:25:11,190 --> 00:25:16,289
guest page table over here because all

00:25:14,190 --> 00:25:18,029
of the above is handled by a virtual

00:25:16,289 --> 00:25:20,190
machine or inside the virtual machine

00:25:18,029 --> 00:25:22,409
this basically nothing we can do about

00:25:20,190 --> 00:25:23,429
it in heaven again we can show up on the

00:25:22,409 --> 00:25:25,440
page Scrolls but that doesn't help

00:25:23,429 --> 00:25:27,329
because I'm tears X we can't really tell

00:25:25,440 --> 00:25:28,649
the guests not to set its own page table

00:25:27,329 --> 00:25:29,940
because that's the whole point of nested

00:25:28,649 --> 00:25:32,820
pages that's why we have it because we

00:25:29,940 --> 00:25:36,379
want to be fast but back in the day they

00:25:32,820 --> 00:25:38,489
used to be something we called shadow PE

00:25:36,379 --> 00:25:40,139
where we didn't have harbor that

00:25:38,489 --> 00:25:41,729
actually allowed us to have these two

00:25:40,139 --> 00:25:45,539
page tables after one update other and

00:25:41,729 --> 00:25:47,759
instead KVM would go and convert guest

00:25:45,539 --> 00:25:49,529
page tables to host page tables and to

00:25:47,759 --> 00:25:53,190
sanitization for you and sanitization

00:25:49,529 --> 00:25:56,099
obviously means it would never add a

00:25:53,190 --> 00:25:59,279
present page with a real physical

00:25:56,099 --> 00:26:01,169
address put in so you say if you're

00:25:59,279 --> 00:26:04,019
using shadow pde if you dissin distantly

00:26:01,169 --> 00:26:08,570
disabled apt altogether on intel cpus

00:26:04,019 --> 00:26:13,409
you are saved as well unfortunately

00:26:08,570 --> 00:26:18,209
shadow PDEs half there downsides let's

00:26:13,409 --> 00:26:20,609
turn to them one is if you have one

00:26:18,209 --> 00:26:22,499
application and then you want to context

00:26:20,609 --> 00:26:26,820
switch to another application you need

00:26:22,499 --> 00:26:28,649
to change your your Co 3 value your page

00:26:26,820 --> 00:26:30,529
table value so you switching from one

00:26:28,649 --> 00:26:33,450
page table to another page table and

00:26:30,529 --> 00:26:35,579
that is obviously a privileged operation

00:26:33,450 --> 00:26:37,440
because only the kernel can do that and

00:26:35,579 --> 00:26:38,759
in that environment you don't want to

00:26:37,440 --> 00:26:41,039
actually have the guests head that

00:26:38,759 --> 00:26:42,779
directly to the CPU unless your mind

00:26:41,039 --> 00:26:46,320
master pages which again mean protection

00:26:42,779 --> 00:26:48,779
so every time you're switching contact

00:26:46,320 --> 00:26:51,059
you will have to go to KVM and then go

00:26:48,779 --> 00:26:54,570
back into your guest to act into the

00:26:51,059 --> 00:26:56,340
context version which used to be okay

00:26:54,570 --> 00:26:57,500
back in the old days but then that don't

00:26:56,340 --> 00:26:59,970
happen

00:26:57,500 --> 00:27:02,009
and thanks to meltdown this actually

00:26:59,970 --> 00:27:04,169
doesn't only a cure when you're going

00:27:02,009 --> 00:27:09,240
between different processes but on every

00:27:04,169 --> 00:27:12,779
Cisco multiple times and every Cisco so

00:27:09,240 --> 00:27:16,320
we're taking things from slowly falling

00:27:12,779 --> 00:27:19,919
basically which wouldn't fit into our

00:27:16,320 --> 00:27:22,409
20% project um but there's another

00:27:19,919 --> 00:27:25,019
really cool feature on intel vt-x which

00:27:22,409 --> 00:27:30,149
is called a sea of me by whitelist so

00:27:25,019 --> 00:27:31,799
you could tell your guests do not set Co

00:27:30,149 --> 00:27:33,539
for you that directly give me a hype

00:27:31,799 --> 00:27:36,509
apology want to set it and then you give

00:27:33,539 --> 00:27:38,669
a cannery bag that contains the pointer

00:27:36,509 --> 00:27:42,720
to your page table that you would put in

00:27:38,669 --> 00:27:45,149
as a shadow page table and the guests

00:27:42,720 --> 00:27:47,399
will just set that s seo seo free value

00:27:45,149 --> 00:27:50,340
and in me TX you would have a list of up

00:27:47,399 --> 00:27:54,029
to four co3 values that you allow the

00:27:50,340 --> 00:27:57,269
CPU to be set regardless off well

00:27:54,029 --> 00:27:59,070
regardless if you're now it gets to be

00:27:57,269 --> 00:28:00,889
certain if it's not part of those four

00:27:59,070 --> 00:28:03,600
values then you get a trap

00:28:00,889 --> 00:28:06,419
so that way you would basically be able

00:28:03,600 --> 00:28:08,730
to get all the malko mitigations back to

00:28:06,419 --> 00:28:12,629
almost zero performance penalty with

00:28:08,730 --> 00:28:13,919
shadow paging now while we're down to

00:28:12,629 --> 00:28:15,600
zoom performance penalty with shadow

00:28:13,919 --> 00:28:16,950
paging it still needs a lot of

00:28:15,600 --> 00:28:19,259
performance penalty because shadow pages

00:28:16,950 --> 00:28:20,879
are not fast but quite all that not fast

00:28:19,259 --> 00:28:23,220
well they're not fast we both need to do

00:28:20,879 --> 00:28:25,529
a lot of work and we need to every time

00:28:23,220 --> 00:28:29,250
you modify a page table in the ghast we

00:28:25,529 --> 00:28:31,799
need to go get modified go into KVM and

00:28:29,250 --> 00:28:34,129
basically create another channel copy

00:28:31,799 --> 00:28:36,480
for that page table entry on your host

00:28:34,129 --> 00:28:38,789
and that is a slow process there are a

00:28:36,480 --> 00:28:42,299
couple of optimizations for that inside

00:28:38,789 --> 00:28:44,730
of the inside of the shadow paging code

00:28:42,299 --> 00:28:46,919
but they're all based on your aesthetics

00:28:44,730 --> 00:28:49,500
you basically go and see well if I see

00:28:46,919 --> 00:28:51,720
so many page faults on the same page

00:28:49,500 --> 00:28:54,659
table entry then I just set that page

00:28:51,720 --> 00:28:56,340
table entry to be profitable but next

00:28:54,659 --> 00:28:57,720
time I get cash flush all righty of

00:28:56,340 --> 00:28:58,440
these brushes I will just go through

00:28:57,720 --> 00:29:02,100
that

00:28:58,440 --> 00:29:03,570
and loop through every entry afterwards

00:29:02,100 --> 00:29:05,009
because I assume the appalling was to

00:29:03,570 --> 00:29:07,559
modify the whole page anyways well why

00:29:05,009 --> 00:29:09,929
don't we take that progress process one

00:29:07,559 --> 00:29:12,090
more level up there's a really really

00:29:09,929 --> 00:29:15,509
cool feature in modern interesting views

00:29:12,090 --> 00:29:17,399
from PAML the page fortification lock

00:29:15,509 --> 00:29:19,429
which really is meant for something

00:29:17,399 --> 00:29:22,350
completely different

00:29:19,429 --> 00:29:25,049
this is what allows us to record what

00:29:22,350 --> 00:29:26,360
pages a guests touch between the last

00:29:25,049 --> 00:29:30,179
time we invented it

00:29:26,360 --> 00:29:32,580
so using PML we can basically get a log

00:29:30,179 --> 00:29:35,490
of all the pages that a guest was

00:29:32,580 --> 00:29:38,970
writing to that's it since the last time

00:29:35,490 --> 00:29:41,399
we process that page what education is

00:29:38,970 --> 00:29:42,539
this useful life migration so doing live

00:29:41,399 --> 00:29:44,519
migration you want to know what got

00:29:42,539 --> 00:29:46,620
changed on the guest and everything that

00:29:44,519 --> 00:29:48,799
got changed you want to migrate over to

00:29:46,620 --> 00:29:51,299
the non system but at the end of the day

00:29:48,799 --> 00:29:53,370
changing page tables is the same idea

00:29:51,299 --> 00:29:56,279
right if you have a patient education

00:29:53,370 --> 00:30:00,629
love you know which pages to guess 25 so

00:29:56,279 --> 00:30:02,460
you know exactly which page table pages

00:30:00,629 --> 00:30:04,049
the guest also modified because you know

00:30:02,460 --> 00:30:05,549
which page state which which which pages

00:30:04,049 --> 00:30:09,480
inside the guest address base actually

00:30:05,549 --> 00:30:12,179
our page table tables so you could use

00:30:09,480 --> 00:30:14,039
that to combine all of your updates to a

00:30:12,179 --> 00:30:15,389
point of Cohiba to to to a point where

00:30:14,039 --> 00:30:17,070
you won't know the guest wants to be

00:30:15,389 --> 00:30:18,629
coherent again until they're only two of

00:30:17,070 --> 00:30:20,429
those there are still three words

00:30:18,629 --> 00:30:22,649
service lee when you just vintage in

00:30:20,429 --> 00:30:25,740
context and there are explicitly

00:30:22,649 --> 00:30:27,179
invitations so if on those two you trap

00:30:25,740 --> 00:30:28,889
and you process your female love and you

00:30:27,179 --> 00:30:30,840
just after the fact process through your

00:30:28,889 --> 00:30:32,220
header page tables you should be much

00:30:30,840 --> 00:30:33,809
faster heart unfortunate i wanted to

00:30:32,220 --> 00:30:37,350
actually put a type of this and show you

00:30:33,809 --> 00:30:39,290
numbers turns out animations take a lot

00:30:37,350 --> 00:30:43,040
of time

00:30:39,290 --> 00:30:47,760
[Laughter]

00:30:43,040 --> 00:30:50,240
yes so as you can see we do take a lot

00:30:47,760 --> 00:30:52,470
of time because I don't have any year

00:30:50,240 --> 00:30:54,720
there are other advantages that people

00:30:52,470 --> 00:30:57,420
suggesting these days so there's a call

00:30:54,720 --> 00:31:01,950
scheduling where basically you would not

00:30:57,420 --> 00:31:04,920
allow VMs to these their multiple ideas

00:31:01,950 --> 00:31:09,500
one of you is you would still see all

00:31:04,920 --> 00:31:12,870
hyper quit and the host but if you see a

00:31:09,500 --> 00:31:14,970
CPU running KVM it would look for its

00:31:12,870 --> 00:31:17,250
sibling CPU and make sure that the

00:31:14,970 --> 00:31:20,040
sibling CPU only ever wants the sibling

00:31:17,250 --> 00:31:21,390
of the same virtual machine because

00:31:20,040 --> 00:31:24,090
otherwise you could potentially leak

00:31:21,390 --> 00:31:27,090
data that is outside of that virtual

00:31:24,090 --> 00:31:28,980
machine and then you assume that the

00:31:27,090 --> 00:31:32,840
virtual machine in itself is secure

00:31:28,980 --> 00:31:37,230
again because there that hopefully

00:31:32,840 --> 00:31:41,250
safeguards your page students turns out

00:31:37,230 --> 00:31:43,050
scheduling is really hard I know people

00:31:41,250 --> 00:31:45,780
who benchmark this and basically in time

00:31:43,050 --> 00:31:48,780
like pointed to or got got two points

00:31:45,780 --> 00:31:50,310
where it was not worth it basically

00:31:48,780 --> 00:31:51,810
awesome eats up 30 percent of

00:31:50,310 --> 00:31:54,180
performance and then you you've done to

00:31:51,810 --> 00:31:58,560
zero you don't get any benefit from you

00:31:54,180 --> 00:32:00,600
have it anymore other alternative is we

00:31:58,560 --> 00:32:03,390
could do what we do on power on power

00:32:00,600 --> 00:32:08,160
you only expose the first threat ever on

00:32:03,390 --> 00:32:10,680
your hosts and then guests can have more

00:32:08,160 --> 00:32:13,320
threats so basically you schedule all of

00:32:10,680 --> 00:32:17,040
your sibling threats only when your post

00:32:13,320 --> 00:32:20,670
to and get scheduled so one a single

00:32:17,040 --> 00:32:23,610
host see you basically looks like up to

00:32:20,670 --> 00:32:24,840
eight guest CPUs at a time that's that's

00:32:23,610 --> 00:32:26,670
what we do on powers we could do the

00:32:24,840 --> 00:32:28,380
same thing on Intel people are

00:32:26,670 --> 00:32:30,630
prototyping all this currently in the

00:32:28,380 --> 00:32:33,900
background so expect patches to either

00:32:30,630 --> 00:32:35,850
be there or come really soon and then

00:32:33,900 --> 00:32:37,260
this this helps you against all the

00:32:35,850 --> 00:32:38,460
hyper threading problems but it doesn't

00:32:37,260 --> 00:32:41,550
help you against the little one cache

00:32:38,460 --> 00:32:44,520
blockers and that one reads mean easy

00:32:41,550 --> 00:32:49,440
but I the idea is what if you simply

00:32:44,520 --> 00:32:53,840
don't have anything to hide and that is

00:32:49,440 --> 00:32:53,840
a very attractive idea I

00:32:54,370 --> 00:32:59,320
I know that a couple of our

00:32:56,620 --> 00:33:01,120
hypest getting friends to there so there

00:32:59,320 --> 00:33:04,420
are bare metal hypervisors are not not

00:33:01,120 --> 00:33:06,760
metal but more I had one hypervisors

00:33:04,420 --> 00:33:08,170
type one the one the ones where you

00:33:06,760 --> 00:33:12,150
basically have as a real split into

00:33:08,170 --> 00:33:14,350
hypervisor and operating system that

00:33:12,150 --> 00:33:16,720
basically makes sure there's nothing

00:33:14,350 --> 00:33:19,030
that meaning is terribly secret in your

00:33:16,720 --> 00:33:21,580
level 1 data cache when you are going

00:33:19,030 --> 00:33:23,380
into a virtual machine so you could do

00:33:21,580 --> 00:33:25,030
things on the host on the side and then

00:33:23,380 --> 00:33:27,640
go back in it's really really hard and

00:33:25,030 --> 00:33:31,210
KVM though because what happens if you

00:33:27,640 --> 00:33:33,580
take an interrupt in between your guest

00:33:31,210 --> 00:33:35,080
execution you guys concerned you process

00:33:33,580 --> 00:33:36,520
something that really shouldn't affect

00:33:35,080 --> 00:33:38,110
it too much I'll show them to make sure

00:33:36,520 --> 00:33:40,720
got any important data into a level 1

00:33:38,110 --> 00:33:42,610
cache and then you get an interrupt in

00:33:40,720 --> 00:33:44,230
between if it info up reach data from

00:33:42,610 --> 00:33:45,640
the network and you really don't want to

00:33:44,230 --> 00:33:49,990
have all your network data exposed to

00:33:45,640 --> 00:33:52,840
your guest but it's it's a very very

00:33:49,990 --> 00:34:00,190
hard problem to solve in in the KPM

00:33:52,840 --> 00:34:01,750
world Alex that wouldn't help with l1 TF

00:34:00,190 --> 00:34:04,120
anyway would it because you still have

00:34:01,750 --> 00:34:05,530
they they can without both L&T f you

00:34:04,120 --> 00:34:08,520
could spy directly wait a second I

00:34:05,530 --> 00:34:08,520
wasn't get this microphone

00:34:08,760 --> 00:34:14,290
nobody can you okay well with isn't it

00:34:12,010 --> 00:34:15,460
the case that with ln TF the guests can

00:34:14,290 --> 00:34:16,960
spy directly on each other using

00:34:15,460 --> 00:34:19,810
physical addresses so that wouldn't help

00:34:16,960 --> 00:34:23,200
I want to particularly anyway is that

00:34:19,810 --> 00:34:25,330
true it would help with other things

00:34:23,200 --> 00:34:26,800
like sp1 or something again if you're

00:34:25,330 --> 00:34:30,010
looking at the hyper scale

00:34:26,800 --> 00:34:32,860
idea you really only run in icing our

00:34:30,010 --> 00:34:36,250
guest on one horror view you have pretty

00:34:32,860 --> 00:34:40,300
steady pretty steady scheduling off of

00:34:36,250 --> 00:34:41,649
guests to course and then you that ho

00:34:40,300 --> 00:34:43,030
problems didn't exist

00:34:41,649 --> 00:34:45,040
so I guess most if you want to see how

00:34:43,030 --> 00:34:48,850
this works and I'll have to really

00:34:45,040 --> 00:34:50,380
quickly see if I can actually go and SSH

00:34:48,850 --> 00:34:53,850
into my test fishy to show you that

00:34:50,380 --> 00:34:53,850
because it doesn't be very well on a Mac

00:34:59,760 --> 00:35:05,380
so this is a really really simple

00:35:02,110 --> 00:35:09,150
program I can agree that this is a

00:35:05,380 --> 00:35:17,110
really simple program that just goes in

00:35:09,150 --> 00:35:19,210
and reads something from its cache it I

00:35:17,110 --> 00:35:22,090
will show you the code now but it really

00:35:19,210 --> 00:35:29,650
is boring it's just an easy move at this

00:35:22,090 --> 00:35:32,410
point that goes and reads secrets from

00:35:29,650 --> 00:35:36,730
memory that it folds itself you can see

00:35:32,410 --> 00:35:38,410
this runs on the host as root so this is

00:35:36,730 --> 00:35:40,600
a would process running on the host is

00:35:38,410 --> 00:35:43,090
this could as well be your gbg

00:35:40,600 --> 00:35:44,860
application your ssh application

00:35:43,090 --> 00:35:47,610
anything that's running on the host s

00:35:44,860 --> 00:35:52,150
something that is meeting me privileged

00:35:47,610 --> 00:35:54,730
and then what we can do is we can go and

00:35:52,150 --> 00:35:56,560
search our physical address space using

00:35:54,730 --> 00:35:59,890
a vocalist units of I'm running a

00:35:56,560 --> 00:36:04,380
virtual machine with KVM in the okay VM

00:35:59,890 --> 00:36:07,600
here with a simple L 1tf reproducer

00:36:04,380 --> 00:36:10,960
using a TSX so nobody can ever see where

00:36:07,600 --> 00:36:12,160
I'm actually doing Metro schools and

00:36:10,960 --> 00:36:13,210
churches through my other space and

00:36:12,160 --> 00:36:15,730
let's see if that actually works the

00:36:13,210 --> 00:36:18,130
demo goes on always faithful so that

00:36:15,730 --> 00:36:20,530
phone let old stale data at address zero

00:36:18,130 --> 00:36:22,480
this actually looks like proper data I

00:36:20,530 --> 00:36:24,550
guess it did find something but by the

00:36:22,480 --> 00:36:28,390
time I'm trying to read it out many hard

00:36:24,550 --> 00:36:30,250
that they disappeared l1 cache is not as

00:36:28,390 --> 00:36:31,930
big so you get the blood of ill eternity

00:36:30,250 --> 00:36:34,330
in there so it will probably show you

00:36:31,930 --> 00:36:36,310
lots of zeros now yes so it didn't

00:36:34,330 --> 00:36:38,260
actually find that data and then if it

00:36:36,310 --> 00:36:39,880
found some data over here that address

00:36:38,260 --> 00:36:41,860
I'm not quite sure what that is but that

00:36:39,880 --> 00:36:43,630
is validated so it's fine to read that

00:36:41,860 --> 00:36:47,470
out to okay you can see the prisoner

00:36:43,630 --> 00:36:50,680
address that the producer is on so as

00:36:47,470 --> 00:36:54,400
soon as you see that pop up to be about

00:36:50,680 --> 00:36:56,230
now after this it will try to read the

00:36:54,400 --> 00:36:59,940
data that this background task force

00:36:56,230 --> 00:37:02,410
meeting this is yes that's the address

00:36:59,940 --> 00:37:05,349
so we actually found data at that

00:37:02,410 --> 00:37:09,940
address and there you go it's the secret

00:37:05,349 --> 00:37:12,749
I guess with a bit of optimization you

00:37:09,940 --> 00:37:18,609
could Polly get this down to two seconds

00:37:12,749 --> 00:37:32,289
did you see the point with that any

00:37:18,609 --> 00:37:34,989
questions thank you so what I think that

00:37:32,289 --> 00:37:37,479
is still missing here is that well if

00:37:34,989 --> 00:37:40,479
there is some VM exit path on kayvyun

00:37:37,479 --> 00:37:42,670
the data I have a half spectral gadget

00:37:40,479 --> 00:37:44,789
which means that it does speculatively

00:37:42,670 --> 00:37:48,519
load from some global variable based on

00:37:44,789 --> 00:37:50,199
VM controlled index then still it

00:37:48,519 --> 00:37:52,390
basically can read anything on the

00:37:50,199 --> 00:37:55,299
future other space where the KVM VM

00:37:52,390 --> 00:37:57,249
extender runs and when the one this is

00:37:55,299 --> 00:38:00,160
being populated into the devil d cache

00:37:57,249 --> 00:38:03,489
you can still steal it from the cycling

00:38:00,160 --> 00:38:05,349
hypervalent so I think that one thing

00:38:03,489 --> 00:38:07,660
that we need to consider is doing

00:38:05,349 --> 00:38:10,170
something similar to what I'm pervious

00:38:07,660 --> 00:38:12,670
down in a zone which is basically

00:38:10,170 --> 00:38:14,979
isolating the address space well KVM via

00:38:12,670 --> 00:38:16,869
makes it handles run and this is

00:38:14,979 --> 00:38:18,910
something that we need because it's very

00:38:16,869 --> 00:38:20,920
big war then we need to think and

00:38:18,910 --> 00:38:23,949
collaborate on this and this wasn't

00:38:20,920 --> 00:38:26,650
specified here is one's domestication I

00:38:23,949 --> 00:38:28,539
agree this was not covered at all I

00:38:26,650 --> 00:38:30,309
don't know I mean it depends on how

00:38:28,539 --> 00:38:32,680
early you can actually do your level 1

00:38:30,309 --> 00:38:34,599
cache brush if you do that before you

00:38:32,680 --> 00:38:38,410
getting into any potential candidates

00:38:34,599 --> 00:38:41,259
you don't need that the problem is that

00:38:38,410 --> 00:38:43,119
you need to scan for every possible

00:38:41,259 --> 00:38:46,479
gadget that can be speculative really

00:38:43,119 --> 00:38:48,999
run with IBM control gadget so there are

00:38:46,479 --> 00:38:51,190
some people does work on collecting

00:38:48,999 --> 00:38:53,229
compiler the extensions that will find

00:38:51,190 --> 00:38:54,309
this gadget but basically if you will

00:38:53,229 --> 00:38:56,920
look at the mailing list for example

00:38:54,309 --> 00:39:00,459
with line ups who say that is very good

00:38:56,920 --> 00:39:03,009
I by the way fing the same because it's

00:39:00,459 --> 00:39:05,680
not it's not a real solution to really

00:39:03,009 --> 00:39:07,539
put elephants for example things like

00:39:05,680 --> 00:39:09,849
that before every possible branch of

00:39:07,539 --> 00:39:11,470
voyage at this point where we are the

00:39:09,849 --> 00:39:13,510
only sane

00:39:11,470 --> 00:39:15,760
you have is to disable hypertense yeah I

00:39:13,510 --> 00:39:18,520
know so I do a way to be enabled them in

00:39:15,760 --> 00:39:20,770
the future you'll see yeah but I think

00:39:18,520 --> 00:39:23,590
that we should think about refactoring

00:39:20,770 --> 00:39:26,470
KVM code to I said another space of

00:39:23,590 --> 00:39:29,890
where the VM extenders are run until at

00:39:26,470 --> 00:39:31,840
some point what wait for example if that

00:39:29,890 --> 00:39:33,609
we will flush delay what do you catch on

00:39:31,840 --> 00:39:34,869
the next entry to the guests this is the

00:39:33,609 --> 00:39:37,180
point when we need to switch the other

00:39:34,869 --> 00:39:38,920
space to another other space but until

00:39:37,180 --> 00:39:45,130
then we need to run with us isolated

00:39:38,920 --> 00:39:46,840
under space similar to a specification

00:39:45,130 --> 00:39:48,550
right and you do know about the

00:39:46,840 --> 00:39:51,790
performance application of kpti right

00:39:48,550 --> 00:39:54,280
yeah so it's much much much much faster

00:39:51,790 --> 00:39:56,130
to just disable a purpose in your system

00:39:54,280 --> 00:39:59,020
I go through what you would basically

00:39:56,130 --> 00:40:01,090
double the time it would take or give

00:39:59,020 --> 00:40:04,000
you access so I don't think so if you

00:40:01,090 --> 00:40:06,220
use PC I mean I think I think it was

00:40:04,000 --> 00:40:07,869
still perform much better so you might

00:40:06,220 --> 00:40:09,640
be CID you should at least kind of like

00:40:07,869 --> 00:40:12,849
10 to 20 with some phone store that eats

00:40:09,640 --> 00:40:15,700
up every benefit you get from you like I

00:40:12,849 --> 00:40:18,310
say to the KTM is basic because you run

00:40:15,700 --> 00:40:20,230
a untrusted application it's not very

00:40:18,310 --> 00:40:22,240
different than running an untrusted you

00:40:20,230 --> 00:40:24,070
know space applications the gesso

00:40:22,240 --> 00:40:31,170
specification can be considered very

00:40:24,070 --> 00:40:34,119
single so it's going to be above

00:40:31,170 --> 00:40:37,830
@kv inform about I want yet alternatives

00:40:34,119 --> 00:40:37,830
etc it's take it there

00:40:40,700 --> 00:40:45,930
yes so you mentioned that you need a

00:40:43,830 --> 00:40:48,990
baseball team for your speculation for

00:40:45,930 --> 00:40:50,550
this problem to happen but I don't think

00:40:48,990 --> 00:40:52,410
that's the only way you can fit your

00:40:50,550 --> 00:40:54,660
expectation what about just the simple

00:40:52,410 --> 00:40:56,160
questions examine you can you can

00:40:54,660 --> 00:40:57,840
trigger speculation just perfectly fine

00:40:56,160 --> 00:41:01,080
with any other method but you cannot

00:40:57,840 --> 00:41:05,700
trigger a few zeros so speculate I mean

00:41:01,080 --> 00:41:08,100
I it took me about two weeks of this

00:41:05,700 --> 00:41:10,290
presentation time in creation time to

00:41:08,100 --> 00:41:13,170
figure out that inside a speculative

00:41:10,290 --> 00:41:17,460
context you cannot trigger an element EF

00:41:13,170 --> 00:41:20,070
speculation so if you if you're getting

00:41:17,460 --> 00:41:22,070
a page fall inside of a speculative path

00:41:20,070 --> 00:41:24,480
that will not trigger another

00:41:22,070 --> 00:41:26,490
speculation based on the physical

00:41:24,480 --> 00:41:29,970
address that the envelop page table

00:41:26,490 --> 00:41:32,220
energy contained so yes you can do any

00:41:29,970 --> 00:41:35,730
speculation things you like but it will

00:41:32,220 --> 00:41:37,080
not have tags inside you and would not

00:41:35,730 --> 00:41:40,320
be taxed when you have one cut it will

00:41:37,080 --> 00:41:43,560
only ever read data that was backed by

00:41:40,320 --> 00:41:45,990
real page tables on your guests and then

00:41:43,560 --> 00:41:49,880
you have guest data in you speculation

00:41:45,990 --> 00:41:49,880
you don't have whole state inspectors

00:41:50,400 --> 00:41:59,000
I think we got one more Red Horse done

00:41:55,590 --> 00:42:01,800
yeah hello

00:41:59,000 --> 00:42:03,870
quick question on the you would mention

00:42:01,800 --> 00:42:06,690
that somebody had implemented course

00:42:03,870 --> 00:42:09,090
scheduling and people filed it yes no

00:42:06,690 --> 00:42:11,340
some somebody somebody implemented the

00:42:09,090 --> 00:42:13,770
social cost continues on the work right

00:42:11,340 --> 00:42:15,480
now that's probably different binary

00:42:13,770 --> 00:42:17,490
much together chilling especially

00:42:15,480 --> 00:42:18,750
there's call scheduling where you

00:42:17,490 --> 00:42:20,550
actually modify the scheduler and then

00:42:18,750 --> 00:42:22,500
there's the idea that inside KVM you

00:42:20,550 --> 00:42:24,360
just shoot down something else that

00:42:22,500 --> 00:42:28,670
wants on a sibling and that one was

00:42:24,360 --> 00:42:28,670
definitely measured and just not good

00:42:39,800 --> 00:42:48,469
[Applause]

00:42:41,600 --> 00:42:48,469

YouTube URL: https://www.youtube.com/watch?v=sssAEPxMKOI


