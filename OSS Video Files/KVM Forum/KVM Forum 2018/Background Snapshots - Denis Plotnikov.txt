Title: Background Snapshots - Denis Plotnikov
Publication date: 2018-11-17
Playlist: KVM Forum 2018
Description: 
	The VM snapshot is a widely-used feature to save a VM state. Currently, when you make a snapshot you are forced to pause your virtual machine until the snapshot is done. This is undesirable behavior because it's seen for the user as a temporary VM shutdown which is something you don't want when your goal is to provide your end-users with good quality of service.
I would like to introduce background snapshots: the feature allowing not to pause your virtual machine when making a VM snapshot. It keeps your virtual machine up and running until the end of the snapshotting process. I would like to explain some technical details on how we have achieved that and very short overview on how to use the feature.

---

Denis Plotnikov
Software developer
Virtuozzo

A member of Server Virtualization Team at Virtuozzo
Captions: 
	00:00:01,040 --> 00:00:09,510
[Music]

00:00:05,690 --> 00:00:12,990
welcome to the last taco day of the

00:00:09,510 --> 00:00:15,360
conference so my name is Dennis

00:00:12,990 --> 00:00:19,560
plotnikov I'm a software developer at

00:00:15,360 --> 00:00:24,420
virtuosa and I'm working on kernel

00:00:19,560 --> 00:00:26,400
development in different places so why

00:00:24,420 --> 00:00:31,740
am I here it's because background

00:00:26,400 --> 00:00:32,640
snapshot so obviously and someday go my

00:00:31,740 --> 00:00:36,030
boss

00:00:32,640 --> 00:00:40,410
so my boss was hacking around kernel and

00:00:36,030 --> 00:00:43,829
somebody from support my user support

00:00:40,410 --> 00:00:49,020
call him and said hey then your software

00:00:43,829 --> 00:00:51,960
works badly and he replied why and you

00:00:49,020 --> 00:00:55,289
know we have a customer that customer

00:00:51,960 --> 00:00:59,070
makes a snapshot of the VM every time

00:00:55,289 --> 00:01:01,559
every single day and it took him two

00:00:59,070 --> 00:01:04,769
minutes to do that and then said and

00:01:01,559 --> 00:01:07,200
what and they replied because it's bad

00:01:04,769 --> 00:01:14,040
because it's a VM working on the

00:01:07,200 --> 00:01:20,820
production and it cost him a lot to live

00:01:14,040 --> 00:01:25,860
out here it is it cost the customer a

00:01:20,820 --> 00:01:29,220
lot to have two minutes VM downtime

00:01:25,860 --> 00:01:31,409
every time and my boss said okay I will

00:01:29,220 --> 00:01:34,560
do something something about that and

00:01:31,409 --> 00:01:36,180
then yeah I was hacking around the

00:01:34,560 --> 00:01:38,549
kernel doing something and then he

00:01:36,180 --> 00:01:41,490
called me oh hey then you know what I

00:01:38,549 --> 00:01:43,619
said what and you need to do something

00:01:41,490 --> 00:01:45,659
with the snapshot and I was like oh okay

00:01:43,619 --> 00:01:56,939
sure I'll do something with session so

00:01:45,659 --> 00:01:59,250
but I was like so and agenda but this is

00:01:56,939 --> 00:02:02,640
not interesting and that's what the

00:01:59,250 --> 00:02:05,579
snapshot is I'm talking about the VM

00:02:02,640 --> 00:02:10,580
snapshot and it turns out it consists of

00:02:05,579 --> 00:02:14,069
two parts the disk snapshot some somehow

00:02:10,580 --> 00:02:18,629
state of the disk the data

00:02:14,069 --> 00:02:22,499
these sales somewhere and other virtual

00:02:18,629 --> 00:02:27,209
machine devices state also saved

00:02:22,499 --> 00:02:31,349
somewhere and it turns out that to make

00:02:27,209 --> 00:02:34,379
this snapshot is it is already solved

00:02:31,349 --> 00:02:38,370
problem so if we are talking about Coco

00:02:34,379 --> 00:02:42,359
Coco - it's basically very fast because

00:02:38,370 --> 00:02:47,639
all you need to do is to copy a mapping

00:02:42,359 --> 00:02:51,060
table which Maps guests offsets to host

00:02:47,639 --> 00:02:52,739
offsets and this table is not that

00:02:51,060 --> 00:02:54,980
beacon you just can copy that and you're

00:02:52,739 --> 00:03:00,840
you're good to go with this snapshot

00:02:54,980 --> 00:03:04,549
whether virtual machine devices States

00:03:00,840 --> 00:03:07,639
it is also kind of solve problem because

00:03:04,549 --> 00:03:12,689
on migration you use a migration stream

00:03:07,639 --> 00:03:17,430
to save all your devices States to some

00:03:12,689 --> 00:03:20,790
place so it's also good but it turns out

00:03:17,430 --> 00:03:25,109
that to took all to take that snapshot

00:03:20,790 --> 00:03:29,459
you need to stop the VM and save all the

00:03:25,109 --> 00:03:34,349
stage in into some destination let's say

00:03:29,459 --> 00:03:40,409
safe well with the VM stop then I go

00:03:34,349 --> 00:03:45,810
then I went into into VM devices States

00:03:40,409 --> 00:03:49,049
and start investigating what well what

00:03:45,810 --> 00:03:52,530
shall we time consumes and did that it

00:03:49,049 --> 00:03:57,620
turned out that the biggest part of a VM

00:03:52,530 --> 00:04:02,280
VM divided state is memory it usually

00:03:57,620 --> 00:04:05,009
consists of hundreds megabytes even

00:04:02,280 --> 00:04:08,569
gigabytes when the other VM state is

00:04:05,009 --> 00:04:14,340
around 10 gigabyte a 10 megabyte overall

00:04:08,569 --> 00:04:17,549
so then I started thinking that we need

00:04:14,340 --> 00:04:22,400
to save the that memory somehow in the

00:04:17,549 --> 00:04:27,520
background kind of synchronously to

00:04:22,400 --> 00:04:31,970
actually pretend that VM work in a cave

00:04:27,520 --> 00:04:35,600
but saving meanwhile the memory at some

00:04:31,970 --> 00:04:38,330
place so I decided to start doing

00:04:35,600 --> 00:04:40,130
something about that and encounter

00:04:38,330 --> 00:04:43,250
another thing that snapshot has two

00:04:40,130 --> 00:04:46,699
types there are internal snapshots and

00:04:43,250 --> 00:04:49,789
external snapshots external snapshot a

00:04:46,699 --> 00:04:52,729
it's it's fairly easy you just need to

00:04:49,789 --> 00:04:55,639
give a destination to your three to save

00:04:52,729 --> 00:04:57,800
it somewhere but internal snapshot is

00:04:55,639 --> 00:05:00,320
tricky because when you're thinking

00:04:57,800 --> 00:05:04,160
about a synchronous write in your memory

00:05:00,320 --> 00:05:07,370
you need to calculate what size of

00:05:04,160 --> 00:05:11,510
memory so internal internal snapshots

00:05:07,370 --> 00:05:15,110
are saving are saved inside disk image

00:05:11,510 --> 00:05:16,970
so to write something in that image as

00:05:15,110 --> 00:05:18,860
synchronously you need to pre allocate

00:05:16,970 --> 00:05:20,410
the space in that image and to pre

00:05:18,860 --> 00:05:24,490
allocate the space you should calculate

00:05:20,410 --> 00:05:29,169
everything so you are not really used

00:05:24,490 --> 00:05:32,389
stream semantics which integration

00:05:29,169 --> 00:05:35,120
implements so I decided to not think

00:05:32,389 --> 00:05:39,470
about internal snapshot and go with the

00:05:35,120 --> 00:05:42,500
external snapshot so here is the

00:05:39,470 --> 00:05:45,650
definition so called definition of the

00:05:42,500 --> 00:05:49,370
ground snapshot so it is it allows you

00:05:45,650 --> 00:05:55,400
to save virtual machine with minimal

00:05:49,370 --> 00:06:00,289
downtime by saying minimal I I mean that

00:05:55,400 --> 00:06:04,820
we stop actually stop the room and grab

00:06:00,289 --> 00:06:06,770
all the states which which should be

00:06:04,820 --> 00:06:10,400
freezed which should be mutable at the

00:06:06,770 --> 00:06:13,430
time and then we doing some hex to write

00:06:10,400 --> 00:06:17,930
the member synchronously so here is the

00:06:13,430 --> 00:06:20,360
three bricks we use existing virtual

00:06:17,930 --> 00:06:24,590
machine immigration immigration code to

00:06:20,360 --> 00:06:28,030
save the VM state and we just we just

00:06:24,590 --> 00:06:31,029
need some modifications of the error and

00:06:28,030 --> 00:06:34,360
we use existing implementation of

00:06:31,029 --> 00:06:37,840
snapshot for the disks especially for

00:06:34,360 --> 00:06:41,469
ow - and the hardest part is to actually

00:06:37,840 --> 00:06:44,460
arrive memory asynchronously so there

00:06:41,469 --> 00:06:47,139
are two ways to do that you basically

00:06:44,460 --> 00:06:50,919
what you need to do you need to somehow

00:06:47,139 --> 00:06:52,419
seal your memory and write a channel

00:06:50,919 --> 00:06:54,580
chunk by chunk to do that you just

00:06:52,419 --> 00:06:57,780
protect your memory from writing and

00:06:54,580 --> 00:07:01,800
here is two ways you can actually

00:06:57,780 --> 00:07:06,759
intercept the writings from the peers

00:07:01,800 --> 00:07:09,729
first one is to use a segmentation fault

00:07:06,759 --> 00:07:12,699
handler which happens if your access

00:07:09,729 --> 00:07:16,210
memory which which is not which

00:07:12,699 --> 00:07:21,300
shouldn't be accessed really but it

00:07:16,210 --> 00:07:21,300
turns out that we can't use that because

00:07:22,409 --> 00:07:27,900
ge-mu is such a good thing that

00:07:25,090 --> 00:07:31,990
sometimes it's shares memory with

00:07:27,900 --> 00:07:35,800
different processes and if another

00:07:31,990 --> 00:07:38,919
processes access your memory you can't

00:07:35,800 --> 00:07:43,389
really intercept it with a zigzag

00:07:38,919 --> 00:07:46,629
handler in your process so it will break

00:07:43,389 --> 00:07:49,539
your memory you can't do that then we

00:07:46,629 --> 00:07:52,659
decided to use user fault FD actual

00:07:49,539 --> 00:07:55,659
immigration already used a user fault of

00:07:52,659 --> 00:08:00,000
D for post copy migration but it turned

00:07:55,659 --> 00:08:03,159
out that user photos it doesn't have

00:08:00,000 --> 00:08:07,680
right right protected mode tracking yet

00:08:03,159 --> 00:08:11,620
but I know but I know that some person

00:08:07,680 --> 00:08:15,339
work really hard to make it happen soon

00:08:11,620 --> 00:08:22,360
so we totally rely on that user fault of

00:08:15,339 --> 00:08:25,389
them then here is here is how it is how

00:08:22,360 --> 00:08:27,669
our background snapshot is seen for user

00:08:25,389 --> 00:08:29,699
and what do you need to do to use it

00:08:27,669 --> 00:08:34,390
actually you just need to make an

00:08:29,699 --> 00:08:36,909
immigration weather correspondent

00:08:34,390 --> 00:08:39,399
capability set yourself capability pause

00:08:36,909 --> 00:08:42,610
your VM make disk snapshot which is

00:08:39,399 --> 00:08:44,680
first make then the then start with

00:08:42,610 --> 00:08:45,800
immigration thread migration thread

00:08:44,680 --> 00:08:47,660
collect all the

00:08:45,800 --> 00:08:51,579
[Music]

00:08:47,660 --> 00:08:55,040
state states except memory it saves it

00:08:51,579 --> 00:08:56,120
in the in the destination and then it

00:08:55,040 --> 00:09:01,069
started

00:08:56,120 --> 00:09:03,290
it starts writing the memory and while

00:09:01,069 --> 00:09:07,279
it's right in the memory V CPUs is

00:09:03,290 --> 00:09:11,740
already running they are not really

00:09:07,279 --> 00:09:15,170
released anymore so what we achieved

00:09:11,740 --> 00:09:18,550
this is this is numbers for Justin I

00:09:15,170 --> 00:09:23,959
didn't move am having two gigabytes of

00:09:18,550 --> 00:09:28,360
RAM of course it is a kind of not

00:09:23,959 --> 00:09:31,040
realistic scenario but and when

00:09:28,360 --> 00:09:34,189
important thing when you're using

00:09:31,040 --> 00:09:40,339
background snapshot your you will

00:09:34,189 --> 00:09:43,279
experience some slowing down of of your

00:09:40,339 --> 00:09:46,160
virtual machine this is because when vcp

00:09:43,279 --> 00:09:50,870
you encounter a page that should be

00:09:46,160 --> 00:09:53,959
written it stops puts the quiz in a deck

00:09:50,870 --> 00:09:56,720
near the page in the priority queue this

00:09:53,959 --> 00:09:59,269
page from the priority queue is taken

00:09:56,720 --> 00:10:02,449
before all other memory pages which is

00:09:59,269 --> 00:10:05,689
written sequentially writes it to the

00:10:02,449 --> 00:10:08,389
destination and release the cpu so you

00:10:05,689 --> 00:10:11,319
you will have summon speed you will

00:10:08,389 --> 00:10:15,769
haven't you will have experience

00:10:11,319 --> 00:10:21,050
freezing at that time but is it is

00:10:15,769 --> 00:10:26,750
better than than the downtime for quite

00:10:21,050 --> 00:10:29,389
a big amount of time and this is where

00:10:26,750 --> 00:10:34,639
we're now we have draft implementation

00:10:29,389 --> 00:10:37,579
and where the majority of functionality

00:10:34,639 --> 00:10:40,399
is ready and waiting for user fault if

00:10:37,579 --> 00:10:45,699
there were right protected mode will end

00:10:40,399 --> 00:10:45,699
into the mainstream so that's it

00:10:48,260 --> 00:11:05,660
please ask questions sure so I haven't

00:11:03,329 --> 00:11:10,610
been following these patches too closely

00:11:05,660 --> 00:11:10,610
how far along is the write-protected I

00:11:13,519 --> 00:11:20,360
didn't know I didn't know for sure but

00:11:16,760 --> 00:11:24,570
I'm sorry I don't know I don't know I

00:11:20,360 --> 00:11:28,829
don't know for sure but I believe better

00:11:24,570 --> 00:11:34,760
is working on them and here and here

00:11:28,829 --> 00:11:34,760
also interested in getting those patches

00:11:37,910 --> 00:11:42,350
we're about to do that okay

00:11:48,649 --> 00:12:02,569
any questions related to being it didn't

00:11:53,899 --> 00:12:03,420
work maybe something okay then thank you

00:12:02,569 --> 00:12:06,280
very much

00:12:03,420 --> 00:12:12,059
[Applause]

00:12:06,280 --> 00:12:12,059

YouTube URL: https://www.youtube.com/watch?v=fKj4j8lw8pU


