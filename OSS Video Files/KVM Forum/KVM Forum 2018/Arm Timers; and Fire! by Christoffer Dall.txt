Title: Arm Timers; and Fire! by Christoffer Dall
Publication date: 2018-11-17
Playlist: KVM Forum 2018
Description: 
	A key feature that is missing in KVM/ARM compared to x86 is the support for stolen time reporting to virtual CPUs. Stolen time allows a virtual CPU to make more informed scheduling decisions on oversubscribed systems by factoring in CPU time used by the hypervisor for other tasks instead of running the virtual CPU. The Arm architecture defines two separate timers: The virtual and physical timers, which are both available to the OS, and further provides separate timers for the hypervisor. While the intention behind these architecture features is to provide OSes a mechanism for telling physical and virtual time apart, this does not work in practice. This talk explains why we cannot easily use the architected mechanism to provide stolen time on Arm, and why we must instead use a paravirtualized solution based on a shared page and how this approach differs slightly from the one used on x86.

---

Christoffer Dall
Principal Engineer
Arm

Christoffer Dall is principal engineer in Arm's architecture and technology group. Christoffer is a long-time open source contributor, and original author of KVM/ARM. Christoffer has a PhD in computer science from Columbia
University, specializing in operating systems and virtualization, and has presented at numerous academic as well as community conferences.
Captions: 
	00:00:01,040 --> 00:00:07,049
[Music]

00:00:05,299 --> 00:00:09,360
good morning everybody

00:00:07,049 --> 00:00:12,360
some people stuck around I'm happy to

00:00:09,360 --> 00:00:14,340
see that my name is Christopher Dowell

00:00:12,360 --> 00:00:16,170
and I work for arm used to work for

00:00:14,340 --> 00:00:18,750
Lennar oh and I do a combination of

00:00:16,170 --> 00:00:21,930
architecture work but I still work on

00:00:18,750 --> 00:00:26,099
KVM farms well some Co maintain of KVM

00:00:21,930 --> 00:00:27,810
armed with marksmanship and KVM arm is

00:00:26,099 --> 00:00:30,689
becoming sort of a reasonably stable

00:00:27,810 --> 00:00:32,309
platform for virtualization an arm but

00:00:30,689 --> 00:00:35,430
there is one source button that is

00:00:32,309 --> 00:00:38,730
timekeeping we know we have some

00:00:35,430 --> 00:00:41,820
problems when we migrate with virtual

00:00:38,730 --> 00:00:43,890
machines around on KVM arm or if we run

00:00:41,820 --> 00:00:47,070
KVM arm on a laptop and close the lid on

00:00:43,890 --> 00:00:48,780
that laptop suspend the VM we see all

00:00:47,070 --> 00:00:51,180
sorts of strange warnings watchdog

00:00:48,780 --> 00:00:53,160
messages kernel RCU faults and stuff

00:00:51,180 --> 00:00:55,079
like that and that's the reason that

00:00:53,160 --> 00:00:56,460
great and that's actually in spite of

00:00:55,079 --> 00:00:58,109
the fact that the ARM architecture has

00:00:56,460 --> 00:01:01,800
some sort of support for virtual

00:00:58,109 --> 00:01:03,870
timekeeping so we don't really we didn't

00:01:01,800 --> 00:01:05,369
really know what we had to do but we had

00:01:03,870 --> 00:01:07,049
to figure out what we had to do to fix

00:01:05,369 --> 00:01:08,520
these problems and so I thought okay

00:01:07,049 --> 00:01:09,810
what better way to figure out what we

00:01:08,520 --> 00:01:11,760
have to do then to actually give a talk

00:01:09,810 --> 00:01:13,799
at KVM forum about this so that's what

00:01:11,760 --> 00:01:14,939
this is so at the end of this talk

00:01:13,799 --> 00:01:16,650
hopefully you'll have some understanding

00:01:14,939 --> 00:01:18,330
of what KVM arm does in terms of

00:01:16,650 --> 00:01:19,950
timekeeping what the ARM architecture

00:01:18,330 --> 00:01:21,090
provides you and maybe I'll learn

00:01:19,950 --> 00:01:22,650
something from you based on your

00:01:21,090 --> 00:01:27,689
experience with other architectures in

00:01:22,650 --> 00:01:29,790
terms of timekeeping in VMs so what do

00:01:27,689 --> 00:01:31,229
we have today in a VM arm we have very

00:01:29,790 --> 00:01:33,750
basic timekeeping which means that you

00:01:31,229 --> 00:01:35,670
can read a counter and you can program a

00:01:33,750 --> 00:01:37,710
timer and you can cancel a timer from

00:01:35,670 --> 00:01:41,329
within the VM without traffic to the

00:01:37,710 --> 00:01:41,329
hypervisor so that's fantastic

00:01:42,710 --> 00:01:49,439
but as I alluded to before if you pass a

00:01:47,280 --> 00:01:51,860
VM so that you know passing the VM from

00:01:49,439 --> 00:01:54,890
the qmu command line or literally

00:01:51,860 --> 00:01:58,170
suspending the host that your VM runs on

00:01:54,890 --> 00:01:59,549
then you see warning from the VM we

00:01:58,170 --> 00:02:02,250
don't account for any sort of stolen

00:01:59,549 --> 00:02:03,810
time so if your VM wants to run but

00:02:02,250 --> 00:02:05,490
somehow it can and your hypervisor is

00:02:03,810 --> 00:02:07,020
spending CPU time doing something else

00:02:05,490 --> 00:02:08,550
we don't account for that and the DM

00:02:07,020 --> 00:02:12,000
gets confused and it tells you about it

00:02:08,550 --> 00:02:13,560
and that's also bad and finally if you

00:02:12,000 --> 00:02:15,000
start migrating VM

00:02:13,560 --> 00:02:16,680
between physical machines that have

00:02:15,000 --> 00:02:18,720
different physical frequencies

00:02:16,680 --> 00:02:23,310
you see really strange behaviors as well

00:02:18,720 --> 00:02:24,690
also bad so I'm gonna try to tell you a

00:02:23,310 --> 00:02:26,610
little bit about the tools that we have

00:02:24,690 --> 00:02:30,510
for the time keeping with the ARM

00:02:26,610 --> 00:02:31,890
architecture so the ARM architecture has

00:02:30,510 --> 00:02:34,500
something called the arm generic timer's

00:02:31,890 --> 00:02:36,090
architecture we usually call it the arch

00:02:34,500 --> 00:02:37,380
timers or the architects the timers and

00:02:36,090 --> 00:02:38,819
that's also what you'll find if you go

00:02:37,380 --> 00:02:40,560
looking for this in the KB alarm source

00:02:38,819 --> 00:02:42,150
code and the reason why we call it that

00:02:40,560 --> 00:02:43,620
is that once upon a time we didn't have

00:02:42,150 --> 00:02:45,480
any notion of timekeeping in the

00:02:43,620 --> 00:02:47,250
architecture and then at some point we

00:02:45,480 --> 00:02:51,330
did so we architected it and hence the

00:02:47,250 --> 00:02:53,190
name which stuck in RB 8.0 we have two

00:02:51,330 --> 00:02:55,920
counters a physical counter and a

00:02:53,190 --> 00:02:57,810
virtual counter and we have four timers

00:02:55,920 --> 00:03:00,180
we have the l3 physical timer which is

00:02:57,810 --> 00:03:01,970
for secure world trustzone type stuff

00:03:00,180 --> 00:03:04,440
which is not really relevant to KVM arm

00:03:01,970 --> 00:03:06,660
we have yield the yield to physical

00:03:04,440 --> 00:03:09,239
timer for the hypervisor and we have an

00:03:06,660 --> 00:03:12,959
l1 virtual and an EO one physical timer

00:03:09,239 --> 00:03:14,819
both for an operating system it doesn't

00:03:12,959 --> 00:03:16,200
end there though in 8.1 with virtually

00:03:14,819 --> 00:03:18,299
with the virtualization host extensions

00:03:16,200 --> 00:03:20,549
we get one more time err we get the e l2

00:03:18,299 --> 00:03:24,420
virtual timer as well so now we have

00:03:20,549 --> 00:03:25,799
symmetry between l2 and l1 don't worry

00:03:24,420 --> 00:03:27,510
too much about well one and yield to our

00:03:25,799 --> 00:03:29,519
yet yield one is for operating systems

00:03:27,510 --> 00:03:33,209
yield two for the hypervisor broadly

00:03:29,519 --> 00:03:34,350
speaking so counters and timers what's

00:03:33,209 --> 00:03:38,239
the counter and what's the timer a

00:03:34,350 --> 00:03:42,180
counter is a counter it counts time at a

00:03:38,239 --> 00:03:44,220
system specific frequency a timer is a

00:03:42,180 --> 00:03:47,010
device that can trigger an event after

00:03:44,220 --> 00:03:49,500
some time has passed okay so each timer

00:03:47,010 --> 00:03:51,170
has a compare value register which is a

00:03:49,500 --> 00:03:53,190
register that software can write into

00:03:51,170 --> 00:03:54,690
and a control register where you can

00:03:53,190 --> 00:03:57,000
enable or disable the timer read it

00:03:54,690 --> 00:03:58,799
status and stuff like that and the idea

00:03:57,000 --> 00:04:00,239
is that if you have an enable timer and

00:03:58,799 --> 00:04:02,880
you write a specific value into the

00:04:00,239 --> 00:04:05,820
compare register when the counter that a

00:04:02,880 --> 00:04:07,920
timer is associated with has higher than

00:04:05,820 --> 00:04:09,959
or equal to value than the compare value

00:04:07,920 --> 00:04:12,150
then you assert the output signal from

00:04:09,959 --> 00:04:16,350
the timer which often results in an

00:04:12,150 --> 00:04:18,180
interrupt so the two counters so first

00:04:16,350 --> 00:04:21,180
we have the fiscal counter which is a 64

00:04:18,180 --> 00:04:23,940
bit monotonically increasing counter you

00:04:21,180 --> 00:04:26,490
access it via the CTC and TPC tl0

00:04:23,940 --> 00:04:27,360
register and you can trap accesses to

00:04:26,490 --> 00:04:30,000
that register

00:04:27,360 --> 00:04:31,229
to yell 1 and yell to so that means to

00:04:30,000 --> 00:04:35,310
either the operating system from user

00:04:31,229 --> 00:04:36,900
space or to the hypervisor the virtual

00:04:35,310 --> 00:04:38,789
counter is almost the same as the

00:04:36,900 --> 00:04:40,590
physical counter except that there is an

00:04:38,789 --> 00:04:42,659
offset that you can subtract from the

00:04:40,590 --> 00:04:45,000
physical counter to get the virtual

00:04:42,659 --> 00:04:47,969
account that offset is controlled by a

00:04:45,000 --> 00:04:49,080
register called C and TV off l2 all of

00:04:47,969 --> 00:04:53,039
these names just rolls right off the

00:04:49,080 --> 00:04:55,229
tongue and you can access the virtual

00:04:53,039 --> 00:04:59,550
account with this other register of C NT

00:04:55,229 --> 00:05:01,050
VC T l0 that register you cannot trap to

00:04:59,550 --> 00:05:04,370
the hypervisor you can only trap that to

00:05:01,050 --> 00:05:04,370
the operating system from user space

00:05:04,460 --> 00:05:07,979
there's another curl here which will

00:05:06,539 --> 00:05:09,960
become relevant later if I have time

00:05:07,979 --> 00:05:13,110
which is that if you read the virtual

00:05:09,960 --> 00:05:14,849
counter in an from a VG hypervisor then

00:05:13,110 --> 00:05:19,800
you actually don't ever observe that

00:05:14,849 --> 00:05:21,270
officer to use a fix offset of zero so

00:05:19,800 --> 00:05:23,219
trying to put all that together I said

00:05:21,270 --> 00:05:25,560
that a timer is associated with a

00:05:23,219 --> 00:05:27,210
specific counter what you'll see is that

00:05:25,560 --> 00:05:29,639
all of the timer's are associated with

00:05:27,210 --> 00:05:31,349
the physical counter except the Ã®le one

00:05:29,639 --> 00:05:34,020
virtual timer which is associated with

00:05:31,349 --> 00:05:35,789
the virtual counter and then there are

00:05:34,020 --> 00:05:36,839
some limitations on where you can access

00:05:35,789 --> 00:05:41,639
these things and where you can trap

00:05:36,839 --> 00:05:44,490
things too so that's the tools we have

00:05:41,639 --> 00:05:46,020
oh if you want to know more you can go

00:05:44,490 --> 00:05:48,629
read the arm arm it's a bit painful

00:05:46,020 --> 00:05:51,120
you can try there's also a myth that

00:05:48,629 --> 00:05:54,000
virtual timers generate virtual

00:05:51,120 --> 00:05:56,009
interrupts that's not true all timers

00:05:54,000 --> 00:05:57,779
are devices devices generate physical

00:05:56,009 --> 00:05:58,020
interrupts trap to the whole type of

00:05:57,779 --> 00:06:00,330
Iser

00:05:58,020 --> 00:06:02,669
if you have a timer for from a virtual

00:06:00,330 --> 00:06:03,960
timer that goes for a VM the host

00:06:02,669 --> 00:06:07,800
hypervisor to generate a virtual

00:06:03,960 --> 00:06:10,919
interrupt and injected afterwards right

00:06:07,800 --> 00:06:15,120
so how do we use these tools in KVM arm

00:06:10,919 --> 00:06:18,060
today so this is a very very quick

00:06:15,120 --> 00:06:20,039
refresher on KVM arm and how it matched

00:06:18,060 --> 00:06:21,599
the arm CPU modes so the arm CPU modes

00:06:20,039 --> 00:06:23,520
are yield zero for user space yield one

00:06:21,599 --> 00:06:25,770
for the OS and yield two for the

00:06:23,520 --> 00:06:27,300
hypervisor if you want to know more

00:06:25,770 --> 00:06:28,830
about this I've given other talks about

00:06:27,300 --> 00:06:33,569
this and written papers and stuff so you

00:06:28,830 --> 00:06:35,430
can go find out there for a vhg kb m arm

00:06:33,569 --> 00:06:37,110
hypervisor the thing to take away for

00:06:35,430 --> 00:06:39,569
the purpose of this talk is that all of

00:06:37,110 --> 00:06:40,950
Linux host Linux and KVM runs in the l2

00:06:39,569 --> 00:06:44,190
and European

00:06:40,950 --> 00:06:48,330
runs in the l1 and yields Iran if you're

00:06:44,190 --> 00:06:49,770
on a non vhe system because you've

00:06:48,330 --> 00:06:52,410
disabled it in the kernel or you have an

00:06:49,770 --> 00:06:54,900
older piece of hardware then your host

00:06:52,410 --> 00:06:56,910
Linux instance runs in l1 some of KBM

00:06:54,900 --> 00:06:57,960
runs in the l2 and your vm also runs in

00:06:56,910 --> 00:07:00,510
the other one with different

00:06:57,960 --> 00:07:03,780
configurations and that has an effect on

00:07:00,510 --> 00:07:06,600
which time which we can use so for the

00:07:03,780 --> 00:07:10,050
vhe case it's relatively simple your KVM

00:07:06,600 --> 00:07:13,230
and Linux host use the yield to physical

00:07:10,050 --> 00:07:14,850
timer and your guest can then use the l1

00:07:13,230 --> 00:07:18,500
virtual and physical timers directly

00:07:14,850 --> 00:07:22,140
deal to virtual timer is not used at all

00:07:18,500 --> 00:07:24,450
for non daj the host uses that you'll

00:07:22,140 --> 00:07:26,820
want physical timer the guest then uses

00:07:24,450 --> 00:07:28,950
the l1 virtual timer but the guest can

00:07:26,820 --> 00:07:30,060
also try to access the one physical

00:07:28,950 --> 00:07:35,220
timer but in that case we'll have to

00:07:30,060 --> 00:07:37,110
trap an emulator and it's slow so for

00:07:35,220 --> 00:07:38,400
Linux that means that the assumption if

00:07:37,110 --> 00:07:39,930
you want to access a timer which is

00:07:38,400 --> 00:07:41,130
going to be fast and directly accessed

00:07:39,930 --> 00:07:42,630
you have to use the virtual timer and

00:07:41,130 --> 00:07:45,540
that's in fact what Linux does today in

00:07:42,630 --> 00:07:47,100
practice so that means that Linux as a

00:07:45,540 --> 00:07:48,750
guest always uses the virtual timer

00:07:47,100 --> 00:07:50,610
which means that we as a hypervisor have

00:07:48,750 --> 00:07:54,390
the officer to play with and then we can

00:07:50,610 --> 00:07:55,560
do stuff with that so what we do with

00:07:54,390 --> 00:07:57,150
that and now I'm going to show you

00:07:55,560 --> 00:07:58,950
throughout the rest of the talks a

00:07:57,150 --> 00:08:00,630
number of examples of timekeeping and

00:07:58,950 --> 00:08:03,540
I'm gonna use this type of graph to do

00:08:00,630 --> 00:08:06,270
that and what that shows is that on the

00:08:03,540 --> 00:08:07,710
x-axis I show real time that's time you

00:08:06,270 --> 00:08:10,230
know in the world as it progresses that

00:08:07,710 --> 00:08:12,510
we don't ever get back and on the y-axis

00:08:10,230 --> 00:08:14,630
I show counts some some measure of count

00:08:12,510 --> 00:08:17,520
of time that we account ok

00:08:14,630 --> 00:08:19,710
so what we do for KBR today is that when

00:08:17,520 --> 00:08:22,980
we create a VM we set the offset to the

00:08:19,710 --> 00:08:24,930
value of the physical counter so that it

00:08:22,980 --> 00:08:26,970
looks to the VM as if it starts around

00:08:24,930 --> 00:08:32,220
zero and then we just progress and

00:08:26,970 --> 00:08:34,440
follow the physical time when we migrate

00:08:32,220 --> 00:08:35,910
we also support the qm you can save and

00:08:34,440 --> 00:08:36,990
restore the value of the virtual counter

00:08:35,910 --> 00:08:38,490
so if you migrate to a different

00:08:36,990 --> 00:08:39,690
physical machine the the physical

00:08:38,490 --> 00:08:41,250
counter may be at a completely different

00:08:39,690 --> 00:08:43,410
place which I try to illustrate with

00:08:41,250 --> 00:08:44,580
this jump here but then we can save it

00:08:43,410 --> 00:08:47,630
restore that offset so it looks

00:08:44,580 --> 00:08:50,340
continues to the guest that's all right

00:08:47,630 --> 00:08:53,220
if we migrate to a physical machine with

00:08:50,340 --> 00:08:55,230
a different physical frequency

00:08:53,220 --> 00:08:57,060
sort of the vm's perception of how

00:08:55,230 --> 00:08:59,639
virtual time progresses relative to

00:08:57,060 --> 00:09:01,410
actual real time is skewed and you get

00:08:59,639 --> 00:09:03,029
really weird results for example your

00:09:01,410 --> 00:09:04,620
process is running at a very very very

00:09:03,029 --> 00:09:06,750
small amount of time and you end up

00:09:04,620 --> 00:09:10,519
spending all your actual time concert

00:09:06,750 --> 00:09:15,569
switching for example if we steal time

00:09:10,519 --> 00:09:17,579
from a virtual CPU the guest actually

00:09:15,569 --> 00:09:18,689
perceives if you're running all the time

00:09:17,579 --> 00:09:20,790
because they can just see time

00:09:18,689 --> 00:09:22,620
progressing we don't actually account

00:09:20,790 --> 00:09:25,579
for that in any way which is also bad to

00:09:22,620 --> 00:09:28,439
leave to process starvation and warnings

00:09:25,579 --> 00:09:29,790
if you're running on a real system and

00:09:28,439 --> 00:09:32,069
you're observing physical time and

00:09:29,790 --> 00:09:33,689
you're suspending that real system you

00:09:32,069 --> 00:09:35,550
get a notifier in Linux that tells you

00:09:33,689 --> 00:09:36,990
you're suspended and another notifier

00:09:35,550 --> 00:09:38,790
that tells you you've just woken up and

00:09:36,990 --> 00:09:40,860
then you can go and account for that and

00:09:38,790 --> 00:09:42,720
whatever timekeeping you do we don't

00:09:40,860 --> 00:09:46,740
actually propagate those events into the

00:09:42,720 --> 00:09:51,689
VM so that's also bad and that's what we

00:09:46,740 --> 00:09:53,009
do today we could solve this pause while

00:09:51,689 --> 00:09:55,170
suspend the thing by simply adjusting

00:09:53,009 --> 00:09:57,120
the offset in the kernel with the tools

00:09:55,170 --> 00:09:57,959
we have today and that's something we

00:09:57,120 --> 00:09:59,339
should do and that's something we're

00:09:57,959 --> 00:10:05,220
looking into but it's not there yet

00:09:59,339 --> 00:10:06,829
right what do we have so far so we have

00:10:05,220 --> 00:10:08,970
the basic timekeeping is alright

00:10:06,829 --> 00:10:11,100
migration is okay on machines that have

00:10:08,970 --> 00:10:12,839
the same frequency gets weird with

00:10:11,100 --> 00:10:14,670
different frequencies we're not

00:10:12,839 --> 00:10:17,220
accounting for stolen time we're not

00:10:14,670 --> 00:10:20,759
accounting for suspense but we can

00:10:17,220 --> 00:10:23,459
probably fix that so we have something

00:10:20,759 --> 00:10:26,220
some things to do and what we've done in

00:10:23,459 --> 00:10:28,649
arm not me but other people in arm is

00:10:26,220 --> 00:10:33,209
propose a something called

00:10:28,649 --> 00:10:35,449
paravirtualized time and TV time

00:10:33,209 --> 00:10:38,220
perverts last time it's a spec that

00:10:35,449 --> 00:10:40,889
tries to generally provide a unified

00:10:38,220 --> 00:10:42,500
interface between hypervisors and guest

00:10:40,889 --> 00:10:44,730
operating systems no matter which

00:10:42,500 --> 00:10:47,670
specific hypervisor vendor or operating

00:10:44,730 --> 00:10:50,339
system vendor you're using to tell to

00:10:47,670 --> 00:10:54,240
tell paravirtualized time that spec is

00:10:50,339 --> 00:10:55,889
in beta that's the link pizza' means it

00:10:54,240 --> 00:10:57,300
can change please go have a look at it

00:10:55,889 --> 00:10:58,709
and provide us any feedback you may have

00:10:57,300 --> 00:11:03,089
so we can change it in time that would

00:10:58,709 --> 00:11:06,360
be very very very appreciated the

00:11:03,089 --> 00:11:07,080
paravirtualized time is discoverable via

00:11:06,360 --> 00:11:08,760
the SMT

00:11:07,080 --> 00:11:10,290
the colon convention to be one-point-one

00:11:08,760 --> 00:11:12,150
what that means is that you don't have

00:11:10,290 --> 00:11:13,530
to have firmware description that tells

00:11:12,150 --> 00:11:15,270
you that you have this feature from your

00:11:13,530 --> 00:11:18,450
hypervisor you can just discover it from

00:11:15,270 --> 00:11:20,490
within the VM which is kind of cool and

00:11:18,450 --> 00:11:20,850
what this peccaries does is it provides

00:11:20,490 --> 00:11:23,010
you

00:11:20,850 --> 00:11:24,920
paravirtualized time by some standard

00:11:23,010 --> 00:11:26,850
and it standardized as hyper calls

00:11:24,920 --> 00:11:30,330
parameters return codes and data

00:11:26,850 --> 00:11:32,160
structures it also provides you with

00:11:30,330 --> 00:11:33,210
some definitions of time so we know what

00:11:32,160 --> 00:11:34,470
the different concepts that are being

00:11:33,210 --> 00:11:37,260
communicated by a pair of virtualize

00:11:34,470 --> 00:11:39,390
time actually mean so first of all we

00:11:37,260 --> 00:11:40,680
have paused so past means the VM is

00:11:39,390 --> 00:11:42,020
deliberately passed or the host that

00:11:40,680 --> 00:11:44,640
it's running on is simply not running

00:11:42,020 --> 00:11:46,050
running means that the VM is not passed

00:11:44,640 --> 00:11:48,060
and that some piece of you could be

00:11:46,050 --> 00:11:53,180
running but not necessarily a CPU is

00:11:48,060 --> 00:11:56,220
running sorry physical time is real time

00:11:53,180 --> 00:12:00,480
live physical time is physical time -

00:11:56,220 --> 00:12:03,030
post ok virtual time is a per CPU

00:12:00,480 --> 00:12:04,710
concept which means that the V CPU is

00:12:03,030 --> 00:12:06,360
running or it's deliberately waiting for

00:12:04,710 --> 00:12:08,730
interrupts alright so if you're pausing

00:12:06,360 --> 00:12:11,400
your CPU like halt on x86 or W file on

00:12:08,730 --> 00:12:15,180
arm you're at you're still counting that

00:12:11,400 --> 00:12:16,680
as we CPU time right stolen time is that

00:12:15,180 --> 00:12:18,120
your VC PU is runnable so you want to

00:12:16,680 --> 00:12:20,340
run but it's actually waiting for other

00:12:18,120 --> 00:12:23,100
that task to run on your hypervisor or

00:12:20,340 --> 00:12:25,320
your host and then finally we introduced

00:12:23,100 --> 00:12:27,390
a concept of a paravirtualized frequency

00:12:25,320 --> 00:12:28,440
so that we can keep time in a reasonable

00:12:27,390 --> 00:12:33,960
manner across different underlying

00:12:28,440 --> 00:12:35,310
physical frequencies so in in graphics

00:12:33,960 --> 00:12:38,400
what does that look like well if you

00:12:35,310 --> 00:12:42,350
pass a VM you plateau on live physical

00:12:38,400 --> 00:12:42,350
time okay let's look something like this

00:12:42,590 --> 00:12:47,190
virtual and stolen time so if we start

00:12:44,910 --> 00:12:50,400
accounting for stolen time then virtual

00:12:47,190 --> 00:12:53,580
time increases at a lower rate when you

00:12:50,400 --> 00:12:55,080
start stealing time from the V CPU and

00:12:53,580 --> 00:12:58,700
so you plateau for example if you steal

00:12:55,080 --> 00:13:00,750
all the all the time off the B CPU

00:12:58,700 --> 00:13:02,580
everybody looks like this graphics is

00:13:00,750 --> 00:13:05,640
not helping at all but ok sorry about

00:13:02,580 --> 00:13:06,960
that so if you're migrating with

00:13:05,640 --> 00:13:09,450
different frequencies because we can now

00:13:06,960 --> 00:13:11,520
adjust for the paravirtualized frequency

00:13:09,450 --> 00:13:13,050
we now get this behavior so from the

00:13:11,520 --> 00:13:15,060
point of view of the VM time progresses

00:13:13,050 --> 00:13:17,430
at the same at the same rate which is

00:13:15,060 --> 00:13:18,630
great and we can use live physical time

00:13:17,430 --> 00:13:20,400
to communicate the fact that we had

00:13:18,630 --> 00:13:28,890
found time during migration so

00:13:20,400 --> 00:13:30,840
cool paravirtualized frequencies so the

00:13:28,890 --> 00:13:32,190
idea is you define some paravirtualized

00:13:30,840 --> 00:13:34,350
frequency which is something that the

00:13:32,190 --> 00:13:36,210
hypervisor just decides for your VM okay

00:13:34,350 --> 00:13:37,200
and then depending on which physical

00:13:36,210 --> 00:13:38,550
system you're running on you have a

00:13:37,200 --> 00:13:40,890
native frequency and what you generally

00:13:38,550 --> 00:13:43,050
want is you want to say okay I want time

00:13:40,890 --> 00:13:44,640
but in a PV unit and what you do is you

00:13:43,050 --> 00:13:46,530
read the counter directly from the

00:13:44,640 --> 00:13:48,510
hardware without trapping and then you

00:13:46,530 --> 00:13:52,440
multiply by a fraction and you get time

00:13:48,510 --> 00:13:54,810
in PV units the obvious question then is

00:13:52,440 --> 00:13:57,030
how does the VM know paravirtualized

00:13:54,810 --> 00:13:59,010
frequency and the native frequency and

00:13:57,030 --> 00:14:00,480
so we provide a shared data structure

00:13:59,010 --> 00:14:03,720
between the hypervisor and the VM which

00:14:00,480 --> 00:14:06,360
contains some fields contains a sequence

00:14:03,720 --> 00:14:07,710
number which gets increased when you're

00:14:06,360 --> 00:14:09,330
migrating so that you're not reading

00:14:07,710 --> 00:14:13,530
data in the middle of a migration and

00:14:09,330 --> 00:14:16,200
getting weird results you report the

00:14:13,530 --> 00:14:20,070
actual native frequency and TV frequency

00:14:16,200 --> 00:14:21,630
to the guest you have a scale multiplier

00:14:20,070 --> 00:14:23,840
and a shift so that you can do fast

00:14:21,630 --> 00:14:27,150
conversions between native to TV

00:14:23,840 --> 00:14:31,140
frequencies and something to do the

00:14:27,150 --> 00:14:34,350
opposite and how does that actually work

00:14:31,140 --> 00:14:36,000
so this is a pseudocode example trying

00:14:34,350 --> 00:14:37,980
to illustrate what what do you do so

00:14:36,000 --> 00:14:41,330
what you do is inside the guest to read

00:14:37,980 --> 00:14:45,270
live physical time well you'd read the

00:14:41,330 --> 00:14:46,530
CBC T yield zero the virtual counter

00:14:45,270 --> 00:14:48,060
which you read directly from the

00:14:46,530 --> 00:14:50,100
hardware without trapping right and that

00:14:48,060 --> 00:14:54,110
adjusts for past time so that gives you

00:14:50,100 --> 00:14:56,400
the native measure of live physical time

00:14:54,110 --> 00:14:58,110
and then inside a loop where you read

00:14:56,400 --> 00:15:00,180
the sequence number before and after and

00:14:58,110 --> 00:15:01,140
you check if that changes that means you

00:15:00,180 --> 00:15:03,090
were doing this in the middle of a

00:15:01,140 --> 00:15:03,510
migration and then you have to start

00:15:03,090 --> 00:15:05,820
over

00:15:03,510 --> 00:15:08,310
you read that value and then you scale

00:15:05,820 --> 00:15:10,440
that to the pervert / frequency and the

00:15:08,310 --> 00:15:11,880
way you do that is that you shift up you

00:15:10,440 --> 00:15:13,350
multiply and you shift down and you do

00:15:11,880 --> 00:15:19,380
that that way because it's faster than

00:15:13,350 --> 00:15:21,030
doing division so that's that so yeah

00:15:19,380 --> 00:15:25,380
that gives you fast timekeeping in VMs

00:15:21,030 --> 00:15:26,850
in PD units without trapping yeah if you

00:15:25,380 --> 00:15:28,320
need to program a timer inside the VM

00:15:26,850 --> 00:15:29,760
you're programming a real device that

00:15:28,320 --> 00:15:32,400
runs up the native frequency so now you

00:15:29,760 --> 00:15:33,960
need to convert your view of TV time

00:15:32,400 --> 00:15:35,930
back to native time

00:15:33,960 --> 00:15:38,520
that's why we had that other multiplier

00:15:35,930 --> 00:15:42,300
in the math some details of the math is

00:15:38,520 --> 00:15:43,950
rounding this adding FPV -1 is to avoid

00:15:42,300 --> 00:15:45,840
ever rounding down because you don't

00:15:43,950 --> 00:15:47,550
want any perception of time going

00:15:45,840 --> 00:15:48,960
backwards in the vm it's being debated

00:15:47,550 --> 00:15:50,280
whether there's a bug in there if you

00:15:48,960 --> 00:15:52,260
have feedback on that i'll be happy to

00:15:50,280 --> 00:15:54,990
hear that

00:15:52,260 --> 00:15:57,600
and finally we provide a pervy cpu data

00:15:54,990 --> 00:16:00,390
structure between the hypervisor and the

00:15:57,600 --> 00:16:01,530
vm to report stolen time in nanoseconds

00:16:00,390 --> 00:16:03,150
and here we don't need a sequence number

00:16:01,530 --> 00:16:07,440
because we can access that single field

00:16:03,150 --> 00:16:09,060
tonically so what do we do when we

00:16:07,440 --> 00:16:12,060
migrate between machines with different

00:16:09,060 --> 00:16:14,280
frequencies well for the counter we

00:16:12,060 --> 00:16:16,620
calculate what live physical time in

00:16:14,280 --> 00:16:18,960
native units is on the source machine we

00:16:16,620 --> 00:16:21,210
transfer that over along with the source

00:16:18,960 --> 00:16:23,250
native frequency and then we scale that

00:16:21,210 --> 00:16:25,320
amount on the destination adjust the

00:16:23,250 --> 00:16:27,870
shift and the scale multiplier increase

00:16:25,320 --> 00:16:29,640
the sequence number and then calculate

00:16:27,870 --> 00:16:32,130
the right new offset so that when the VM

00:16:29,640 --> 00:16:34,440
reads the counter and adjusts for the

00:16:32,130 --> 00:16:40,560
new perceived scalar multiplier and

00:16:34,440 --> 00:16:41,820
shift you get a coherent view of time we

00:16:40,560 --> 00:16:43,290
do the same thing with the timer except

00:16:41,820 --> 00:16:45,780
that here we calculate the actual

00:16:43,290 --> 00:16:48,900
interval that the guest wants in real

00:16:45,780 --> 00:16:53,610
time to pass before you get a timer

00:16:48,900 --> 00:16:54,690
warning and then we scale that so

00:16:53,610 --> 00:16:56,490
putting it all together we now have us

00:16:54,690 --> 00:16:59,270
back out in beta where would like

00:16:56,490 --> 00:17:02,310
feedback on which solve the problem of

00:16:59,270 --> 00:17:04,470
migration it solve the problem suspend

00:17:02,310 --> 00:17:06,350
and is solve the problem of stolen time

00:17:04,470 --> 00:17:08,730
so that's fantastic

00:17:06,350 --> 00:17:11,250
patches will come on the list very very

00:17:08,730 --> 00:17:13,380
soon I've written some of it and then

00:17:11,250 --> 00:17:14,610
Stephen price from arm will we'll do

00:17:13,380 --> 00:17:18,089
some of the work to carry that forward

00:17:14,610 --> 00:17:22,640
an upstream that so that's great right

00:17:18,089 --> 00:17:25,640
we've sold all the problems except

00:17:22,640 --> 00:17:28,950
nested virtualization breaks everything

00:17:25,640 --> 00:17:34,170
so once we introduce nesting to this

00:17:28,950 --> 00:17:36,210
thing there's a problem the generic time

00:17:34,170 --> 00:17:37,290
architecture in the ARM architecture is

00:17:36,210 --> 00:17:40,260
not designed with nest of virtualization

00:17:37,290 --> 00:17:42,180
in mind at all ok and the complexity

00:17:40,260 --> 00:17:44,460
space really really explodes so your

00:17:42,180 --> 00:17:46,710
guest hypervisor can be via G or non-va

00:17:44,460 --> 00:17:47,520
G your host hypervisor can be BFG or non

00:17:46,710 --> 00:17:49,170
deg

00:17:47,520 --> 00:17:52,530
your guest hypervisor can use pb time

00:17:49,170 --> 00:17:54,150
itself or not it can expose PV time to

00:17:52,530 --> 00:17:56,040
guests or not and the guests can choose

00:17:54,150 --> 00:17:57,360
to use that TV time or not and you need

00:17:56,040 --> 00:17:59,910
to make all combinations work and

00:17:57,360 --> 00:18:02,730
migration between any guest hypervisor

00:17:59,910 --> 00:18:04,680
on a host hypervisor to work as well and

00:18:02,730 --> 00:18:08,010
it just makes it really really hard to

00:18:04,680 --> 00:18:09,180
figure out what you can do and some of

00:18:08,010 --> 00:18:11,670
the complexity comes from the fact that

00:18:09,180 --> 00:18:14,340
you now have to combine live physical

00:18:11,670 --> 00:18:18,060
time at multiple levels so you know when

00:18:14,340 --> 00:18:20,190
you have this nested virtualization in

00:18:18,060 --> 00:18:21,570
graphics where you have a host type of

00:18:20,190 --> 00:18:23,220
Iser and a guest hypervisor and the

00:18:21,570 --> 00:18:25,820
notion of virtual yield to running in

00:18:23,220 --> 00:18:27,600
the o1 you now have two instances of

00:18:25,820 --> 00:18:29,460
paravirtualized time you have to cater

00:18:27,600 --> 00:18:30,990
for and each one can have a different

00:18:29,460 --> 00:18:33,180
measure of life physical time so for

00:18:30,990 --> 00:18:35,400
example the host hypervisor can decide

00:18:33,180 --> 00:18:36,540
to pause the entire VM which you

00:18:35,400 --> 00:18:38,520
probably want to reflect into your

00:18:36,540 --> 00:18:40,110
nested VM as well but the guest

00:18:38,520 --> 00:18:42,450
hypervisor could also decide to pass

00:18:40,110 --> 00:18:43,890
your nested VM and you might want to

00:18:42,450 --> 00:18:46,880
combine those two and scale them when

00:18:43,890 --> 00:18:48,840
you migrate it gets really complicated

00:18:46,880 --> 00:18:50,850
one idea that we're working on is you

00:18:48,840 --> 00:18:53,250
can share that single life physical time

00:18:50,850 --> 00:18:55,140
structure all the way for the host

00:18:53,250 --> 00:18:56,640
hypervisor into the nested VM and then

00:18:55,140 --> 00:18:57,840
report two instances of stolen time

00:18:56,640 --> 00:19:00,510
because that's really separate and

00:18:57,840 --> 00:19:07,050
between the hypervisor and its immediate

00:19:00,510 --> 00:19:10,980
child always we have this ID on well how

00:19:07,050 --> 00:19:13,050
do you communicate live physical time or

00:19:10,980 --> 00:19:14,790
past time which we use the the CNTV off

00:19:13,050 --> 00:19:16,320
to communicate the fact that something

00:19:14,790 --> 00:19:18,150
has been passed by subtracting an amount

00:19:16,320 --> 00:19:19,860
from the counter how do we communicate

00:19:18,150 --> 00:19:21,750
that to the guest hypervisor well if we

00:19:19,860 --> 00:19:23,640
just do the same thing that we usually

00:19:21,750 --> 00:19:25,170
do for for a normal between a hypervisor

00:19:23,640 --> 00:19:26,490
and a guest that would work and that's

00:19:25,170 --> 00:19:26,940
kind of nice and that's what we're going

00:19:26,490 --> 00:19:29,100
for

00:19:26,940 --> 00:19:31,020
except that the architecture always says

00:19:29,100 --> 00:19:32,700
that well if you're running in yell to

00:19:31,020 --> 00:19:35,370
you're in control of the offset so you

00:19:32,700 --> 00:19:36,390
can immediately see what the offset does

00:19:35,370 --> 00:19:38,610
between the physical and the virtual

00:19:36,390 --> 00:19:40,680
counter which we can then do at the same

00:19:38,610 --> 00:19:42,720
time so we're trying to come up with a

00:19:40,680 --> 00:19:44,670
solution that doesn't depart too much on

00:19:42,720 --> 00:19:47,190
the ARM architecture but also gives you

00:19:44,670 --> 00:19:54,030
the accounting of time that you need

00:19:47,190 --> 00:19:55,290
which is hard so I think I said all of

00:19:54,030 --> 00:19:58,690
this

00:19:55,290 --> 00:20:00,130
yep so in conclusion the ARM

00:19:58,690 --> 00:20:01,450
architecture has some basic support for

00:20:00,130 --> 00:20:05,380
virtual time but really all we can do

00:20:01,450 --> 00:20:07,440
with that is to provide past time and

00:20:05,380 --> 00:20:09,550
provide this view of life physical time

00:20:07,440 --> 00:20:11,260
we have a looked at whether you could

00:20:09,550 --> 00:20:12,460
use this offset between physical time

00:20:11,260 --> 00:20:15,190
and virtual time to also communicate

00:20:12,460 --> 00:20:16,600
stolen time but the fact that you can

00:20:15,190 --> 00:20:18,160
read a counter with different values

00:20:16,600 --> 00:20:20,260
that and you and that counters are

00:20:18,160 --> 00:20:22,300
supposed to use a space with different

00:20:20,260 --> 00:20:24,430
values across different CPUs is get

00:20:22,300 --> 00:20:26,830
really confuses things and Linux it just

00:20:24,430 --> 00:20:28,750
doesn't assume that that can happen so

00:20:26,830 --> 00:20:30,520
if you want to use that that's a major

00:20:28,750 --> 00:20:32,920
rework and no matter how you look at it

00:20:30,520 --> 00:20:34,690
you need to communicate multiple

00:20:32,920 --> 00:20:36,040
concepts the fact that your vm is passed

00:20:34,690 --> 00:20:39,220
and the fact that you've stolen time

00:20:36,040 --> 00:20:41,620
from a specific v cpu so that's why we

00:20:39,220 --> 00:20:43,810
basically end up needing this PB time to

00:20:41,620 --> 00:20:46,450
address migration in stolen time in

00:20:43,810 --> 00:20:48,150
addition to to just what we can do with

00:20:46,450 --> 00:20:50,890
the arm or the architecture itself and

00:20:48,150 --> 00:20:52,270
the piece of specification is out and as

00:20:50,890 --> 00:20:57,900
I said many times would really really

00:20:52,270 --> 00:20:57,900
appreciate feedback and input ok

00:20:58,170 --> 00:21:01,170
questions

00:21:04,660 --> 00:21:10,160
when you talk about the parallelized

00:21:07,040 --> 00:21:11,720
interface are you doing a hyper pool

00:21:10,160 --> 00:21:14,540
every time you need to read that or is

00:21:11,720 --> 00:21:17,960
that setting up a structure you don't

00:21:14,540 --> 00:21:19,520
need to trap on afterwards I understand

00:21:17,960 --> 00:21:20,600
that right so the question is how do we

00:21:19,520 --> 00:21:21,740
configure the power of our class

00:21:20,600 --> 00:21:23,120
interface and do you communicate with

00:21:21,740 --> 00:21:26,480
the hypervisor every time you need to

00:21:23,120 --> 00:21:28,309
get the paravirtualized information we

00:21:26,480 --> 00:21:30,110
we don't track to the hypervisor every

00:21:28,309 --> 00:21:32,300
time when you boot a VM you can you can

00:21:30,110 --> 00:21:33,980
use this SMC calling convention to

00:21:32,300 --> 00:21:36,920
discover whether you have PB time and if

00:21:33,980 --> 00:21:39,740
you have PB time you can say please give

00:21:36,920 --> 00:21:41,270
me an IPA so that's a guest physical

00:21:39,740 --> 00:21:42,559
address of where there is a light

00:21:41,270 --> 00:21:44,120
physical time data structure and then

00:21:42,559 --> 00:21:46,880
you map that in in your VM and you have

00:21:44,120 --> 00:21:49,580
that as long as you run if the

00:21:46,880 --> 00:21:51,230
hypervisor is well-behaved there's a

00:21:49,580 --> 00:21:53,630
separate call for stolen time that gives

00:21:51,230 --> 00:21:59,540
you pervy CPU a data structure that you

00:21:53,630 --> 00:22:01,340
can wrap in hi I have a question where s

00:21:59,540 --> 00:22:02,990
true 90 has some issues regarding timing

00:22:01,340 --> 00:22:04,640
and that's when in the house does time

00:22:02,990 --> 00:22:07,970
steering with ntp and these kind of

00:22:04,640 --> 00:22:10,820
things do you have trouble if guests in

00:22:07,970 --> 00:22:14,030
host steer at a different rate or is

00:22:10,820 --> 00:22:15,290
that okay with your scheme so sorry I

00:22:14,030 --> 00:22:17,929
didn't quite understand if the getting

00:22:15,290 --> 00:22:19,550
host does what you have time steering in

00:22:17,929 --> 00:22:21,830
linear so when you have an NTP daemon

00:22:19,550 --> 00:22:26,120
running then then there will be some

00:22:21,830 --> 00:22:28,010
kind of the software time will run at a

00:22:26,120 --> 00:22:30,890
different pace and in the hardware time

00:22:28,010 --> 00:22:36,140
just to just here against timing offsets

00:22:30,890 --> 00:22:40,970
and we have some issues if guests in

00:22:36,140 --> 00:22:43,130
host year it was different different

00:22:40,970 --> 00:22:46,010
directions basically then when the timer

00:22:43,130 --> 00:22:48,350
actually pops too early or too late

00:22:46,010 --> 00:22:51,080
sometimes the guests do you have similar

00:22:48,350 --> 00:22:54,860
issues with sets kimura's that actually

00:22:51,080 --> 00:22:57,050
solve one I don't know it's a short

00:22:54,860 --> 00:23:02,020
answer I don't know if we have the same

00:22:57,050 --> 00:23:02,020
problem good question

00:23:13,230 --> 00:23:20,059
yep so to answer your question we we had

00:23:17,009 --> 00:23:23,909
something similar a couple of years ago

00:23:20,059 --> 00:23:29,159
where timers would fire early or late

00:23:23,909 --> 00:23:31,740
actually too early most of the time for

00:23:29,159 --> 00:23:34,559
the guests when the host was running NTP

00:23:31,740 --> 00:23:37,529
we fixed that by simply checking each

00:23:34,559 --> 00:23:40,080
time the timer was expiring oh you were

00:23:37,529 --> 00:23:45,149
not supposed to fire now let's get back

00:23:40,080 --> 00:23:48,779
to to first base so the workaround was

00:23:45,149 --> 00:23:49,889
to actually run an TP in the guest ever

00:23:48,779 --> 00:23:50,340
since we didn't have that problem

00:23:49,889 --> 00:23:52,619
anymore

00:23:50,340 --> 00:23:55,619
but it may be that we have some other

00:23:52,619 --> 00:23:58,499
issues we wasn't part of the workaround

00:23:55,619 --> 00:24:00,869
also that we went the time of fires we

00:23:58,499 --> 00:24:02,850
actually now go and check if if we

00:24:00,869 --> 00:24:05,070
adjusted the our view of time we move

00:24:02,850 --> 00:24:07,080
everything up it's a good question how

00:24:05,070 --> 00:24:10,499
that would work in with the introduction

00:24:07,080 --> 00:24:13,049
of TV time my sort of initial thoughts

00:24:10,499 --> 00:24:14,129
were that that would have been like NTP

00:24:13,049 --> 00:24:17,700
just would have been talkin all -

00:24:14,129 --> 00:24:25,769
counting progression of time let's look

00:24:17,700 --> 00:24:28,110
into that the first one is how do you

00:24:25,769 --> 00:24:30,749
how do you account for yield zero inside

00:24:28,110 --> 00:24:32,580
the guest so he also has started access

00:24:30,749 --> 00:24:35,070
to counter registers which obviously

00:24:32,580 --> 00:24:36,389
gets queued when you migrate so you now

00:24:35,070 --> 00:24:39,059
have a different frequency for your

00:24:36,389 --> 00:24:40,799
yield zero counter and the user space

00:24:39,059 --> 00:24:42,840
application is no awareness whatsoever

00:24:40,799 --> 00:24:44,309
of TV time so the question is how do we

00:24:42,840 --> 00:24:45,960
deal with yield zero inside a guest

00:24:44,309 --> 00:24:48,480
window you have key B time you need to

00:24:45,960 --> 00:24:50,639
adjust the count to a different

00:24:48,480 --> 00:24:52,230
frequency and the answer to that

00:24:50,639 --> 00:24:53,789
question is that you have to trap user

00:24:52,230 --> 00:24:57,480
space access to the virtual counter to

00:24:53,789 --> 00:25:01,320
the host inside the VM isn't it gonna be

00:24:57,480 --> 00:25:03,720
still yes that's gonna be slow okay so

00:25:01,320 --> 00:25:05,130
in that basically that's the same same

00:25:03,720 --> 00:25:06,630
car is

00:25:05,130 --> 00:25:08,280
that the whole concept sounds basically

00:25:06,630 --> 00:25:10,950
the same as KVM clock just reinvented

00:25:08,280 --> 00:25:13,650
yeah wouldn't it make sense to a share

00:25:10,950 --> 00:25:17,970
data structures be sure code and see

00:25:13,650 --> 00:25:20,880
share ideas like use VDS or map the PBE

00:25:17,970 --> 00:25:22,140
table we'd only into user space and

00:25:20,880 --> 00:25:23,850
basically have completely seamless

00:25:22,140 --> 00:25:25,980
access to that get time of day for

00:25:23,850 --> 00:25:27,780
example is fast even through your

00:25:25,980 --> 00:25:30,690
counter access isn't at which point you

00:25:27,780 --> 00:25:31,920
cannot wrap your 0 counter so the

00:25:30,690 --> 00:25:34,590
question is whether we should use KVM

00:25:31,920 --> 00:25:35,970
clock instead of using any of this so

00:25:34,590 --> 00:25:37,320
our point of view has been by talking to

00:25:35,970 --> 00:25:39,530
multiple hypervisor vendors that there's

00:25:37,320 --> 00:25:41,970
value in saying on the ARM architecture

00:25:39,530 --> 00:25:43,680
which has some features built-in for

00:25:41,970 --> 00:25:46,050
offsetting virtual time to physical time

00:25:43,680 --> 00:25:48,030
to come up with a cross cross OS and

00:25:46,050 --> 00:25:49,950
cross hypervisor solution for keeping

00:25:48,030 --> 00:25:53,610
track of paravirtualized time so that's

00:25:49,950 --> 00:25:57,480
what this is when I look at the k vm for

00:25:53,610 --> 00:26:00,210
x86 stolen time data structures it does

00:25:57,480 --> 00:26:01,530
a lot of complicated things for sequence

00:26:00,210 --> 00:26:02,880
accounting which we don't need an arm

00:26:01,530 --> 00:26:04,110
because we can do I don't know why they

00:26:02,880 --> 00:26:05,340
need the Nexus 6 but I know that we

00:26:04,110 --> 00:26:07,590
don't need it an arm because we can do a

00:26:05,340 --> 00:26:10,560
single atomic access so we can simplify

00:26:07,590 --> 00:26:13,260
a lot of that and I don't know if on x86

00:26:10,560 --> 00:26:18,260
they have the same feature to do virtual

00:26:13,260 --> 00:26:18,260
versus physical time which we do so

00:26:18,350 --> 00:26:22,320
based based on that we said ok let's

00:26:20,790 --> 00:26:24,930
let's move forward what we have here and

00:26:22,320 --> 00:26:27,390
hopefully we can will have seamlessly

00:26:24,930 --> 00:26:30,630
seamless PB time across different

00:26:27,390 --> 00:26:32,340
devices and different hypervisors that's

00:26:30,630 --> 00:26:35,640
our conclusion my concern is that it

00:26:32,340 --> 00:26:38,370
took about six years or so to actually

00:26:35,640 --> 00:26:40,110
get KBN time although k vm clock stable

00:26:38,370 --> 00:26:41,640
so from the first time we got introduced

00:26:40,110 --> 00:26:43,800
to actually it's more because it used to

00:26:41,640 --> 00:26:46,110
be zen time so so from from the first

00:26:43,800 --> 00:26:47,820
time we got the zen pv clock to KVM

00:26:46,110 --> 00:26:51,000
clock being stable it was almost a

00:26:47,820 --> 00:26:54,080
decade and I I don't think that arm

00:26:51,000 --> 00:26:55,950
would get that right in the first job

00:26:54,080 --> 00:27:01,170
alright well thank you for the vote of

00:26:55,950 --> 00:27:02,050
confidence so many different pieces

00:27:01,170 --> 00:27:03,940
around time keep

00:27:02,050 --> 00:27:06,700
that are just I mean you don't you never

00:27:03,940 --> 00:27:08,020
aware of all of them I think Alex's

00:27:06,700 --> 00:27:09,220
point is that we should use KVM clock

00:27:08,020 --> 00:27:11,380
which is fine

00:27:09,220 --> 00:27:12,760
or at least get get down in a room with

00:27:11,380 --> 00:27:14,070
everybody who worked on KVN clock and

00:27:12,760 --> 00:27:19,530
learn from their mistakes

00:27:14,070 --> 00:27:19,530
um thank you okay thank you very much

00:27:19,590 --> 00:27:27,059
[Applause]

00:27:21,280 --> 00:27:27,059

YouTube URL: https://www.youtube.com/watch?v=fCEgG5p_23c


