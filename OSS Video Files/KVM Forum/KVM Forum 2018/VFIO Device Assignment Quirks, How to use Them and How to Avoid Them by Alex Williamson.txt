Title: VFIO Device Assignment Quirks, How to use Them and How to Avoid Them by Alex Williamson
Publication date: 2018-11-17
Playlist: KVM Forum 2018
Description: 
	In order to assign a peripheral I/O device to a virtual machine, the device needs to be isolated from the host and aspects of the hardware need to be virtualized for transparency to the guest. Some devices and platforms are better at this than others. Nonobservance to specifications and creative backdoors through hardware can present challenges to device assignment. In this presentation, Alex Williamson will look at some of the common mistakes found in hardware that make device assignment more challenging, how we work around those challenges, and how devices and platforms can better enable device assignment.

---

Alex Williamson
Senior Principal Software Engineer
Red Hat

Alex Williamson is a Senior Principal Software Engineer with Red Hat, maintainer of VFIO, Linux’s secure userspace driver framework, for both the kernel and QEMU components, and regular contributor to the Linux kernel IOMMU and PCI subsystems. Alex has given previous talks on VFIO, including “An Introduction to PCI Device Assignment with VFIO”, “VFIO, OVMF, GPU and You”, and “VGA Assignment Using VFIO” (see KVM Forum YouTube channel). Additionally Alex has contributed device assignment related how-to guides and articles on the blog site http://vfio.blogspot.com.
Captions: 
	00:00:01,040 --> 00:00:08,849
[Music]

00:00:05,480 --> 00:00:12,150
okay let's get started

00:00:08,849 --> 00:00:14,040
my name is Alex Williamson and in this

00:00:12,150 --> 00:00:15,960
session we're going to talk about VF I

00:00:14,040 --> 00:00:17,279
have advice assignment quirks and how to

00:00:15,960 --> 00:00:21,740
use them how to make devices work better

00:00:17,279 --> 00:00:24,930
with them early for troublesome devices

00:00:21,740 --> 00:00:28,920
I'm sure everybody's heard about VF i/o

00:00:24,930 --> 00:00:32,130
by now today maybe yesterday let's do a

00:00:28,920 --> 00:00:35,219
really quick refresher our time is

00:00:32,130 --> 00:00:36,930
limited so I'll keep it short but VF i/o

00:00:35,219 --> 00:00:40,890
is basically a user space driver

00:00:36,930 --> 00:00:44,850
interface we decompose devices into a

00:00:40,890 --> 00:00:48,510
user space API the core of that API is

00:00:44,850 --> 00:00:50,250
an iommu group where a group is the

00:00:48,510 --> 00:00:55,710
smallest set of devices that are DMA

00:00:50,250 --> 00:00:57,210
isolated from all other groups isolation

00:00:55,710 --> 00:00:59,579
of that group is an important part of

00:00:57,210 --> 00:01:03,539
some of the courts we'll talk about and

00:00:59,579 --> 00:01:05,460
the BFF container if the user creates a

00:01:03,539 --> 00:01:06,990
VF i/o container adds the group to that

00:01:05,460 --> 00:01:10,020
container and that represents the island

00:01:06,990 --> 00:01:11,729
context for one or more groups that

00:01:10,020 --> 00:01:14,630
allows them the ability to get access to

00:01:11,729 --> 00:01:16,799
a VF i/o device the VF o device is

00:01:14,630 --> 00:01:18,509
segmented into regions where the

00:01:16,799 --> 00:01:20,520
region's represent things like PCI

00:01:18,509 --> 00:01:22,530
config space if it's a PCI device and

00:01:20,520 --> 00:01:25,830
then my other spaces i/o port spaces we

00:01:22,530 --> 00:01:27,509
have device specific spaces as well we

00:01:25,830 --> 00:01:29,430
have a number of i/o controls for

00:01:27,509 --> 00:01:31,860
interacting with the containers and

00:01:29,430 --> 00:01:35,009
groups and devices and we usually

00:01:31,860 --> 00:01:39,150
configure interrupts via event f DS via

00:01:35,009 --> 00:01:40,590
those I of controls so being a user

00:01:39,150 --> 00:01:42,630
space driver interface we need user

00:01:40,590 --> 00:01:44,100
space drivers where when we're talking

00:01:42,630 --> 00:01:48,000
about a VM we're really talking about

00:01:44,100 --> 00:01:50,610
Hugh is the user space driver and that

00:01:48,000 --> 00:01:53,009
recomposes the device back into a new

00:01:50,610 --> 00:01:54,030
virtual device and the virtual nosov

00:01:53,009 --> 00:01:58,560
that device is something we'll talk

00:01:54,030 --> 00:02:01,200
about here today too so the overall

00:01:58,560 --> 00:02:03,000
end-to-end view of VF IO is that we have

00:02:01,200 --> 00:02:04,710
a kernel driver that exposes a user

00:02:03,000 --> 00:02:06,450
interface that is consumed by a user

00:02:04,710 --> 00:02:09,130
space driver and then the VM case

00:02:06,450 --> 00:02:11,470
becomes a new virtual device in the VM

00:02:09,130 --> 00:02:14,380
and has been kindly referenced a few

00:02:11,470 --> 00:02:16,030
times please take a look at my kV inform

00:02:14,380 --> 00:02:20,020
talk from 2 years ago there's a video on

00:02:16,030 --> 00:02:21,820
the KTM forum channel page that goes

00:02:20,020 --> 00:02:27,100
into this in much more detail than I can

00:02:21,820 --> 00:02:29,860
provide in two minutes so here we're

00:02:27,100 --> 00:02:33,820
going to be talking about quirks and so

00:02:29,860 --> 00:02:36,340
let's start out with what is a quirk I'm

00:02:33,820 --> 00:02:38,530
not sure how universal this term is but

00:02:36,340 --> 00:02:41,020
in the kernel we like to call quirks any

00:02:38,530 --> 00:02:43,060
piece of software that fixes the device

00:02:41,020 --> 00:02:44,980
and makes it work more how we want to

00:02:43,060 --> 00:02:46,660
and in in the case of VF i/o we're

00:02:44,980 --> 00:02:48,430
talking about missing and broken

00:02:46,660 --> 00:02:50,530
features and topology changes and

00:02:48,430 --> 00:02:55,330
additional virtualization for the most

00:02:50,530 --> 00:02:59,620
part and where can we make use of those

00:02:55,330 --> 00:03:02,950
quirks I guess I missed that slide

00:02:59,620 --> 00:03:04,690
didn't show up in this one we can pretty

00:03:02,950 --> 00:03:08,050
much make use of quirks anywhere in the

00:03:04,690 --> 00:03:09,760
VF i/o stack but something we need to be

00:03:08,050 --> 00:03:11,800
concerned with when we're implementing

00:03:09,760 --> 00:03:14,590
quirks is the performance effect we have

00:03:11,800 --> 00:03:17,380
on the device so think when we're

00:03:14,590 --> 00:03:19,480
modifying things in config space that's

00:03:17,380 --> 00:03:21,220
pretty much free because config space is

00:03:19,480 --> 00:03:24,340
usually considered to be a slow path

00:03:21,220 --> 00:03:26,410
anyway but when we start interacting

00:03:24,340 --> 00:03:29,290
with mm i/o spaces we need to be sure

00:03:26,410 --> 00:03:30,520
that that's not a performance path some

00:03:29,290 --> 00:03:33,130
of the interrupt types we'll deal with

00:03:30,520 --> 00:03:35,500
we have to virtualize parts of the mm

00:03:33,130 --> 00:03:36,550
ice mm IO space of the device and we

00:03:35,500 --> 00:03:40,030
have to be careful about how that

00:03:36,550 --> 00:03:41,680
affects access to other registers

00:03:40,030 --> 00:03:44,770
because that implies that we're trapping

00:03:41,680 --> 00:03:49,660
into qmu rather than providing direct

00:03:44,770 --> 00:03:52,959
access to those so in our model of V

00:03:49,660 --> 00:03:56,140
fio2 user space we have isolation quirks

00:03:52,959 --> 00:03:59,680
so I mentioned the IMU group's isolation

00:03:56,140 --> 00:04:01,540
quirks are targeting how we consider the

00:03:59,680 --> 00:04:03,490
isolation of individual devices the size

00:04:01,540 --> 00:04:05,380
of those groups because we want the

00:04:03,490 --> 00:04:07,000
groups to be as small as possible so we

00:04:05,380 --> 00:04:08,980
have the greatest granularity and our

00:04:07,000 --> 00:04:13,360
ability to use them in different ways

00:04:08,980 --> 00:04:15,100
and with user space aliasing is also

00:04:13,360 --> 00:04:18,820
another issue related to the iommu

00:04:15,100 --> 00:04:21,979
of how does the item you see the device

00:04:18,820 --> 00:04:24,620
does it use the correct request your ID

00:04:21,979 --> 00:04:27,259
we've seen talks referring to the BDF

00:04:24,620 --> 00:04:29,600
the bus device function a number of

00:04:27,259 --> 00:04:31,699
devices that's the request ID and how

00:04:29,600 --> 00:04:33,350
the IOU selects the set of context

00:04:31,699 --> 00:04:35,330
tables that is used for that device so

00:04:33,350 --> 00:04:40,370
we have quirks correcting issues with

00:04:35,330 --> 00:04:42,020
that resets how does the device get back

00:04:40,370 --> 00:04:44,720
to an initial state how do we wipe the

00:04:42,020 --> 00:04:46,639
state from the device there are ways to

00:04:44,720 --> 00:04:48,169
do this but they often don't work

00:04:46,639 --> 00:04:50,919
sometimes they're not implemented

00:04:48,169 --> 00:04:53,000
sometimes we need to buy specific things

00:04:50,919 --> 00:04:55,699
and sometimes we'll implement those

00:04:53,000 --> 00:04:57,169
quirks in qmu so whenever we're

00:04:55,699 --> 00:04:59,660
implementing quirks there's a question

00:04:57,169 --> 00:05:03,259
of is this applicable to the kernel is

00:04:59,660 --> 00:05:05,990
it specific to the virtual machine is it

00:05:03,259 --> 00:05:08,330
robust so we might implement corks and

00:05:05,990 --> 00:05:11,990
PM you simply because they're not good

00:05:08,330 --> 00:05:13,669
enough for the kernel virtualization

00:05:11,990 --> 00:05:17,090
every device needs some degree of

00:05:13,669 --> 00:05:19,310
virtualization some devices need more so

00:05:17,090 --> 00:05:21,740
oftentimes if it's VM specific we'll

00:05:19,310 --> 00:05:23,750
implement that and qmu but we can also

00:05:21,740 --> 00:05:25,340
put it in the kernel and again it's

00:05:23,750 --> 00:05:27,949
another question of is this generally

00:05:25,340 --> 00:05:29,870
useful things like PCI bars we never

00:05:27,949 --> 00:05:32,000
want the user to have direct access to

00:05:29,870 --> 00:05:35,630
so we actually virtualize those both in

00:05:32,000 --> 00:05:37,130
the kernel and qmu we really only make

00:05:35,630 --> 00:05:38,599
use of one of those virtualization

00:05:37,130 --> 00:05:41,539
depending on if we're using qmu or

00:05:38,599 --> 00:05:43,729
something like DB DK but that's a case

00:05:41,539 --> 00:05:48,080
where it makes sense to do it in the

00:05:43,729 --> 00:05:51,620
kernel as well so I thought maybe the

00:05:48,080 --> 00:05:54,409
best way to look at what we can do is to

00:05:51,620 --> 00:05:56,090
look at what we have done but when we

00:05:54,409 --> 00:05:58,000
start out with a disclaimer it's always

00:05:56,090 --> 00:06:00,639
fun to pick on hardware that's broken

00:05:58,000 --> 00:06:03,169
but that's not really the goal here

00:06:00,639 --> 00:06:07,330
mistakes happen things like isolation

00:06:03,169 --> 00:06:09,530
are only considered when you are

00:06:07,330 --> 00:06:12,979
targeting device assignment use cases

00:06:09,530 --> 00:06:15,940
perhaps so we've worked with a number of

00:06:12,979 --> 00:06:18,020
hardware vendors to correct mistakes

00:06:15,940 --> 00:06:20,330
some of those vendors have gone on to

00:06:18,020 --> 00:06:22,039
implement them in hardware so I think we

00:06:20,330 --> 00:06:26,840
should always encourage making devices

00:06:22,039 --> 00:06:28,250
work better with device assignment so

00:06:26,840 --> 00:06:31,310
stepping back through each one of our

00:06:28,250 --> 00:06:32,490
little quirk band-aids we can start with

00:06:31,310 --> 00:06:35,699
isolation and as

00:06:32,490 --> 00:06:37,169
I mentioned this is targeting how our

00:06:35,699 --> 00:06:40,470
device is segmented into i/o melee

00:06:37,169 --> 00:06:42,630
groups in PCI devices we're really

00:06:40,470 --> 00:06:45,240
looking at access control services and

00:06:42,630 --> 00:06:47,639
our ability to enforce whether

00:06:45,240 --> 00:06:50,090
transactions are always targeted

00:06:47,639 --> 00:06:53,610
upstream towards the MMU or whether

00:06:50,090 --> 00:06:56,250
untranslated requests can take

00:06:53,610 --> 00:06:59,639
peer-to-peer routes through lower Leafs

00:06:56,250 --> 00:07:02,340
of the topology so whenever we don't

00:06:59,639 --> 00:07:05,340
have ACS we assume that redirection is

00:07:02,340 --> 00:07:07,050
possible not having ACS doesn't

00:07:05,340 --> 00:07:10,289
necessarily mean that peer-to-peer

00:07:07,050 --> 00:07:12,659
happens but without ACS we have no

00:07:10,289 --> 00:07:15,270
indication that it doesn't so whenever

00:07:12,659 --> 00:07:17,819
there's not ACS that increases the size

00:07:15,270 --> 00:07:19,110
of our main groups decreases the

00:07:17,819 --> 00:07:21,509
granularity with which we can do

00:07:19,110 --> 00:07:24,840
assignment and it's generally a bad

00:07:21,509 --> 00:07:26,669
thing so I always encourage vendors to

00:07:24,840 --> 00:07:29,610
implement ACS but when they don't have

00:07:26,669 --> 00:07:31,949
ACS we can work with them to determine

00:07:29,610 --> 00:07:34,590
whether the devices and the

00:07:31,949 --> 00:07:36,479
interconnects implement equivalent

00:07:34,590 --> 00:07:43,229
routings and we can implement quirks for

00:07:36,479 --> 00:07:45,419
those so some examples and let me start

00:07:43,229 --> 00:07:48,180
out at the root ports because when

00:07:45,419 --> 00:07:50,039
you're dealing with ACS grouping it is

00:07:48,180 --> 00:07:51,870
the isolation of the device from the

00:07:50,039 --> 00:07:56,690
endpoint all the way to the iommu

00:07:51,870 --> 00:07:59,190
so the top level of the PCI Express

00:07:56,690 --> 00:08:00,659
topology is the most important for

00:07:59,190 --> 00:08:02,069
having isolation because if we don't

00:08:00,659 --> 00:08:05,069
have isolation there we can't have

00:08:02,069 --> 00:08:07,229
isolation anywhere downstream and of

00:08:05,069 --> 00:08:09,300
course a lot of chipsets came out before

00:08:07,229 --> 00:08:11,370
we started really looking at device

00:08:09,300 --> 00:08:13,440
assignment and what are the requirements

00:08:11,370 --> 00:08:16,050
of doing the vise assignment so there

00:08:13,440 --> 00:08:18,840
are a number of Intel chipsets listed

00:08:16,050 --> 00:08:22,620
here where the Southbridge the PCH route

00:08:18,840 --> 00:08:25,469
ports do not implement ACS but the

00:08:22,620 --> 00:08:29,789
chipset itself has features that allow

00:08:25,469 --> 00:08:32,700
us to equivalent ACS so we've worked

00:08:29,789 --> 00:08:35,039
with Intel to provide that and we got a

00:08:32,700 --> 00:08:36,450
little step further in the next

00:08:35,039 --> 00:08:39,990
generation of chipsets they'd actually

00:08:36,450 --> 00:08:41,930
did implement ACS but the register size

00:08:39,990 --> 00:08:44,050
was wrong so we actually had to

00:08:41,930 --> 00:08:46,480
implement a

00:08:44,050 --> 00:08:49,029
a different implementation of ACS to

00:08:46,480 --> 00:08:51,160
work around these so that was also

00:08:49,029 --> 00:08:52,810
implement as a quirk and finally in the

00:08:51,160 --> 00:08:55,750
latest chipsets it seems like we have

00:08:52,810 --> 00:08:57,670
ACS and it's working well so that's

00:08:55,750 --> 00:08:59,470
that's an example of where we have

00:08:57,670 --> 00:09:01,329
worked with the vendors and they have

00:08:59,470 --> 00:09:04,690
incrementally improved the hardware to

00:09:01,329 --> 00:09:06,640
make it better for device assignment on

00:09:04,690 --> 00:09:08,110
the client processor side unfortunately

00:09:06,640 --> 00:09:09,670
we still don't have a CS and we don't

00:09:08,110 --> 00:09:10,930
have isolation guarantees and we don't

00:09:09,670 --> 00:09:13,540
have quirks and that's often an issue

00:09:10,930 --> 00:09:15,220
for people and unfortunately the

00:09:13,540 --> 00:09:17,920
recommendation there is to use server

00:09:15,220 --> 00:09:20,320
processors most the hardware vendors are

00:09:17,920 --> 00:09:22,510
really targeting device assignment as a

00:09:20,320 --> 00:09:25,959
server feature and even though we can do

00:09:22,510 --> 00:09:31,029
it on our laptops today it's not always

00:09:25,959 --> 00:09:34,149
the easiest thing to do so some more

00:09:31,029 --> 00:09:35,920
examples am the reisen processors when

00:09:34,149 --> 00:09:37,810
they came out we're also lacking ACS

00:09:35,920 --> 00:09:40,420
luckily this was something that was in

00:09:37,810 --> 00:09:42,160
the hardware but not exposed so firmware

00:09:40,420 --> 00:09:45,459
updates were able to fix that we don't

00:09:42,160 --> 00:09:48,880
actually need quirks for those endpoint

00:09:45,459 --> 00:09:50,920
devices are constantly having ACS issues

00:09:48,880 --> 00:09:53,529
anytime we have multi function endpoints

00:09:50,920 --> 00:09:56,620
we need ACS to separate those functions

00:09:53,529 --> 00:09:58,930
into separate groups so there are

00:09:56,620 --> 00:10:01,920
numerous chipset examples the arm

00:09:58,930 --> 00:10:05,110
vendors are not immune from these issues

00:10:01,920 --> 00:10:07,510
Intel Nix is another example where we

00:10:05,110 --> 00:10:09,970
had many devices really released before

00:10:07,510 --> 00:10:12,190
we really understood that we need this

00:10:09,970 --> 00:10:14,320
sort of isolation we have a ton of

00:10:12,190 --> 00:10:17,880
quirks to handle the multifunction Nicks

00:10:14,320 --> 00:10:21,550
and the newer NICs now do implement ACS

00:10:17,880 --> 00:10:23,170
and NICs from other vendors as well also

00:10:21,550 --> 00:10:26,829
implement quirks for some of these

00:10:23,170 --> 00:10:28,870
things so the overall story with

00:10:26,829 --> 00:10:30,010
isolation is it was bad but we're

00:10:28,870 --> 00:10:33,250
getting better

00:10:30,010 --> 00:10:34,510
and it's increasingly common and if

00:10:33,250 --> 00:10:37,480
there are hardware vendors in the room

00:10:34,510 --> 00:10:39,250
please implement ACS on all downstream

00:10:37,480 --> 00:10:40,420
ports and multi-function endpoints there

00:10:39,250 --> 00:10:44,199
is some ongoing discussion about

00:10:40,420 --> 00:10:45,850
upstream ports on switches but I when

00:10:44,199 --> 00:10:48,519
usually switches are making use of

00:10:45,850 --> 00:10:51,970
single ports single core single function

00:10:48,519 --> 00:10:53,230
option boards and we believe we can we

00:10:51,970 --> 00:10:56,940
have the correct

00:10:53,230 --> 00:10:56,940
them for ignoring those for now

00:10:58,570 --> 00:11:05,290
deema aliasing so does the device

00:11:02,080 --> 00:11:10,360
actually expose the requestor ID the BD

00:11:05,290 --> 00:11:13,420
f that it intends to we have this is

00:11:10,360 --> 00:11:16,270
often a multi-function issue where the

00:11:13,420 --> 00:11:17,380
device will regardless of which function

00:11:16,270 --> 00:11:20,020
you're dealing with perhaps it only

00:11:17,380 --> 00:11:23,590
exposes itself to the IMM of you through

00:11:20,020 --> 00:11:26,080
one function this quirk is actually

00:11:23,590 --> 00:11:28,390
really a both a bare metal and a device

00:11:26,080 --> 00:11:30,910
assignment issue because some of these

00:11:28,390 --> 00:11:33,190
devices were developed years ago when I

00:11:30,910 --> 00:11:35,260
am use were not very common and now that

00:11:33,190 --> 00:11:36,910
they are common you see the problems

00:11:35,260 --> 00:11:40,180
even on laptops just trying to turn on

00:11:36,910 --> 00:11:43,750
them and on the host system so some

00:11:40,180 --> 00:11:46,480
examples the multifunction devices the

00:11:43,750 --> 00:11:49,000
first two examples are cases where it's

00:11:46,480 --> 00:11:50,740
a multi-function device and we simply

00:11:49,000 --> 00:11:53,110
the hardware simply uses the wrong

00:11:50,740 --> 00:11:55,630
requestor ID and so we have to alias

00:11:53,110 --> 00:11:57,310
those two to the any devices that use

00:11:55,630 --> 00:12:00,940
that requestor ID with the device that's

00:11:57,310 --> 00:12:03,670
actually matches the BDF that the iommu

00:12:00,940 --> 00:12:05,260
sees so that expands them and we group

00:12:03,670 --> 00:12:07,960
because obviously if the item you can't

00:12:05,260 --> 00:12:10,930
distinguish between devices we can't

00:12:07,960 --> 00:12:12,940
separate them there's an example of an

00:12:10,930 --> 00:12:14,680
Adaptec device where it makes use of a

00:12:12,940 --> 00:12:16,450
bridge and actually not only is the

00:12:14,680 --> 00:12:20,770
function wrong this the slot number is

00:12:16,450 --> 00:12:23,530
wrong and and then we also have non

00:12:20,770 --> 00:12:25,690
transparent bridges and this is probably

00:12:23,530 --> 00:12:28,870
the one that is continuing to be an

00:12:25,690 --> 00:12:31,090
ongoing problem typically when you have

00:12:28,870 --> 00:12:32,710
a PCI bridge you can discover the

00:12:31,090 --> 00:12:35,230
devices downstream and you can enumerate

00:12:32,710 --> 00:12:37,780
those devices when you have a non

00:12:35,230 --> 00:12:40,960
transparent bridge you cannot see the

00:12:37,780 --> 00:12:42,700
devices on the other side so these non

00:12:40,960 --> 00:12:45,670
transparent bridges are often used for

00:12:42,700 --> 00:12:47,770
connecting to like nodes of a system

00:12:45,670 --> 00:12:50,260
together and you have proprietary

00:12:47,770 --> 00:12:52,720
drivers that communicate across those

00:12:50,260 --> 00:12:54,880
bridges so the host system can't

00:12:52,720 --> 00:12:57,340
actually see what it is that's

00:12:54,880 --> 00:13:00,540
generating the DMA and so far we've been

00:12:57,340 --> 00:13:03,880
using quirks to fill in those gaps to

00:13:00,540 --> 00:13:04,290
let the MMU know what to expect is

00:13:03,880 --> 00:13:07,800
coming

00:13:04,290 --> 00:13:09,449
across that bridge so the advice here

00:13:07,800 --> 00:13:11,399
for avoiding quirks is of course that

00:13:09,449 --> 00:13:13,410
hardware designs must consider the IOM

00:13:11,399 --> 00:13:15,810
use and predict use predictable and

00:13:13,410 --> 00:13:17,490
discoverable request your IDs we may

00:13:15,810 --> 00:13:19,589
still have an ongoing problem with

00:13:17,490 --> 00:13:21,779
transparent bridges until we have some

00:13:19,589 --> 00:13:26,610
sort of architectural specification of

00:13:21,779 --> 00:13:28,290
how to handle those though resets so we

00:13:26,610 --> 00:13:30,779
want to return devices to known States

00:13:28,290 --> 00:13:33,779
we want to wipe the device between use

00:13:30,779 --> 00:13:35,910
cases and PCI provides a number of

00:13:33,779 --> 00:13:37,290
mechanisms to do this there are various

00:13:35,910 --> 00:13:39,000
function level resets there are power

00:13:37,290 --> 00:13:43,170
management resets there are bus resets

00:13:39,000 --> 00:13:45,480
and slot resets the slot and bus resets

00:13:43,170 --> 00:13:47,459
have some scoping issues that you're

00:13:45,480 --> 00:13:49,410
affecting multiple devices when you do

00:13:47,459 --> 00:13:52,199
that reset so that makes them a little

00:13:49,410 --> 00:13:54,660
bit less ideal for device assignment use

00:13:52,199 --> 00:13:56,250
cases often that's okay when we have

00:13:54,660 --> 00:13:59,009
things like graphics cards assign

00:13:56,250 --> 00:14:01,290
assignment and your bus consists of a

00:13:59,009 --> 00:14:04,170
GPU and an audio function because those

00:14:01,290 --> 00:14:06,720
are usually assigned together anyway but

00:14:04,170 --> 00:14:09,630
in ideal scale-out system you want flr

00:14:06,720 --> 00:14:12,779
available but it's apparently still

00:14:09,630 --> 00:14:15,959
difficult to implement sometimes some

00:14:12,779 --> 00:14:17,550
examples here we have some nvme devices

00:14:15,959 --> 00:14:19,800
and nvme is interesting because the

00:14:17,550 --> 00:14:22,920
specification actually requires the

00:14:19,800 --> 00:14:25,589
device to implement flr but it doesn't

00:14:22,920 --> 00:14:28,889
always work so there are some older

00:14:25,589 --> 00:14:31,589
Intel nvme devices that if we talk to

00:14:28,889 --> 00:14:34,139
them too quickly after an flr they lock

00:14:31,589 --> 00:14:37,260
up and no longer work so we have to add

00:14:34,139 --> 00:14:39,690
an extra delay there are Samsung devices

00:14:37,260 --> 00:14:43,110
that actually drop off the PCI bus when

00:14:39,690 --> 00:14:45,649
we reset them if they're in the right

00:14:43,110 --> 00:14:49,589
condition and we found that if we

00:14:45,649 --> 00:14:51,689
disable the nvme controller before we do

00:14:49,589 --> 00:14:53,850
that reset then they behave correctly so

00:14:51,689 --> 00:14:56,760
we have a quirk in the host kernel that

00:14:53,850 --> 00:14:59,339
stops the nvme controller then does the

00:14:56,760 --> 00:15:00,709
flr and they seem to be more stable that

00:14:59,339 --> 00:15:03,420
way

00:15:00,709 --> 00:15:06,449
Radeon graphics are kind of a persistent

00:15:03,420 --> 00:15:08,100
problem we have some quirks and

00:15:06,449 --> 00:15:11,970
sometimes these devices work great

00:15:08,100 --> 00:15:13,680
sometimes they don't it's this is

00:15:11,970 --> 00:15:15,540
probably one where we would really

00:15:13,680 --> 00:15:19,470
appreciate some more input from a and

00:15:15,540 --> 00:15:22,730
how we can make nice isolated reset

00:15:19,470 --> 00:15:25,350
quirks to make those devices work better

00:15:22,730 --> 00:15:28,290
Wireless cards kind of similar problems

00:15:25,350 --> 00:15:31,019
to the Samsung nvme controller except we

00:15:28,290 --> 00:15:32,690
don't know how to fix them so they drop

00:15:31,019 --> 00:15:36,180
off the bus when we do a bus reset and

00:15:32,690 --> 00:15:39,720
our only quirk there is to not do a bus

00:15:36,180 --> 00:15:41,639
reset so just avoid the problem which

00:15:39,720 --> 00:15:43,079
means that we're not wiping the device

00:15:41,639 --> 00:15:47,519
we're not getting that clean state but

00:15:43,079 --> 00:15:49,230
at least the host system works thread

00:15:47,519 --> 00:15:50,970
Ripper amy's workstation processor

00:15:49,230 --> 00:15:52,949
initially had some issues doing bus

00:15:50,970 --> 00:15:55,560
resets and it wouldn't aneue Maury

00:15:52,949 --> 00:15:58,139
anything downstream of the bus after it

00:15:55,560 --> 00:15:59,670
was reset there were some patches

00:15:58,139 --> 00:16:02,730
proposed but luckily this one was also

00:15:59,670 --> 00:16:04,920
fixed in firmware so avoided another

00:16:02,730 --> 00:16:07,949
quirk there but we do have this ability

00:16:04,920 --> 00:16:11,279
to implement device specific resets to

00:16:07,949 --> 00:16:13,949
modify how resets work so if a device

00:16:11,279 --> 00:16:17,480
doesn't expose a reset but can be reset

00:16:13,949 --> 00:16:17,480
we can make it work with quirks

00:16:17,779 --> 00:16:22,860
virtualization is really the asterisk in

00:16:19,920 --> 00:16:24,480
the device and the new device in qmu so

00:16:22,860 --> 00:16:26,220
all devices need some degree of

00:16:24,480 --> 00:16:28,170
virtualization as I mentioned before the

00:16:26,220 --> 00:16:29,880
the PCI bars we have to virtualize

00:16:28,170 --> 00:16:32,670
because we're transposing the device

00:16:29,880 --> 00:16:34,949
into a different address space the IMU

00:16:32,670 --> 00:16:38,370
only handles the translation of the DMA

00:16:34,949 --> 00:16:41,010
not the MM IO and i/o port spaces of

00:16:38,370 --> 00:16:44,459
device sometimes we're moving the device

00:16:41,010 --> 00:16:46,829
in the topology route complex devices

00:16:44,459 --> 00:16:48,750
become endpoints under route ports

00:16:46,829 --> 00:16:50,190
multifunction devices become single

00:16:48,750 --> 00:16:52,050
function devices all those sorts of

00:16:50,190 --> 00:16:54,810
things are just a normal part of the

00:16:52,050 --> 00:16:59,040
virtualization of the device but some

00:16:54,810 --> 00:17:01,529
things require a little extra VGA is a

00:16:59,040 --> 00:17:04,589
prime example of this one and I've given

00:17:01,529 --> 00:17:06,480
previous talks on this the latter one

00:17:04,589 --> 00:17:07,980
you can find the video on the kV inform

00:17:06,480 --> 00:17:09,929
talk I believe the first one was before

00:17:07,980 --> 00:17:11,850
we started recording but I would

00:17:09,929 --> 00:17:13,740
encourage going to look at those the

00:17:11,850 --> 00:17:15,569
general problem there is that these

00:17:13,740 --> 00:17:17,610
devices step through different address

00:17:15,569 --> 00:17:19,290
spaces from VGA space to IO port space

00:17:17,610 --> 00:17:22,549
2mm i/o space and they can actually

00:17:19,290 --> 00:17:26,309
access PCI configuration space through

00:17:22,549 --> 00:17:27,870
numerous ones of those so they're

00:17:26,309 --> 00:17:28,520
getting the physical addresses rather

00:17:27,870 --> 00:17:30,800
than the

00:17:28,520 --> 00:17:32,210
guests physical addresses and yeah I'm

00:17:30,800 --> 00:17:34,520
gonna be protects us from them doing

00:17:32,210 --> 00:17:37,630
anything bad but the drivers don't work

00:17:34,520 --> 00:17:40,360
unless we provide the virtualization

00:17:37,630 --> 00:17:44,180
Intel graphics is a notoriously

00:17:40,360 --> 00:17:46,070
difficult to virtualized device the

00:17:44,180 --> 00:17:50,900
graphics translation table is just one

00:17:46,070 --> 00:17:53,090
of the issues that it has the the

00:17:50,900 --> 00:17:54,650
addresses that it uses for stolen memory

00:17:53,090 --> 00:17:58,250
are effectively latched into the

00:17:54,650 --> 00:18:02,240
hardware on boot and so we have to trap

00:17:58,250 --> 00:18:06,580
the programming of that to relocate it

00:18:02,240 --> 00:18:09,740
to a VM allocated stolen memory region

00:18:06,580 --> 00:18:12,560
so that one is always troublesome but

00:18:09,740 --> 00:18:17,270
luckily we have B GPU to avoid those

00:18:12,560 --> 00:18:20,600
sorts of issues on with IgD the i-40

00:18:17,270 --> 00:18:23,390
graphics are I free network adapter when

00:18:20,600 --> 00:18:26,420
it we're doing assignment of the

00:18:23,390 --> 00:18:30,050
physical function in order to virtualize

00:18:26,420 --> 00:18:32,240
interrupts legacy interrupts we need PCI

00:18:30,050 --> 00:18:33,980
the PCI device to support generically

00:18:32,240 --> 00:18:36,200
telling us the interrupts status and

00:18:33,980 --> 00:18:40,100
also providing us a way to mask the

00:18:36,200 --> 00:18:41,600
interrupts the i-40 e only provides the

00:18:40,100 --> 00:18:42,740
latter one of those it allows us to mask

00:18:41,600 --> 00:18:45,110
the interrupts but we don't know when

00:18:42,740 --> 00:18:47,000
it's signaling so if we try to assign

00:18:45,110 --> 00:18:48,890
this device using legacy interrupts it

00:18:47,000 --> 00:18:51,860
just screams on the host and generates a

00:18:48,890 --> 00:18:54,950
flood of interrupts and it gets shot

00:18:51,860 --> 00:18:58,220
down by the the host kernel so in that

00:18:54,950 --> 00:18:59,690
case we've virtualized the legacy

00:18:58,220 --> 00:19:01,060
interrupts do not expose it to the guest

00:18:59,690 --> 00:19:03,620
and make sure that we're always

00:19:01,060 --> 00:19:05,660
disabling that interrupts so effectively

00:19:03,620 --> 00:19:08,450
becomes a physical function without

00:19:05,660 --> 00:19:12,320
legacy interrupts on the flip side

00:19:08,450 --> 00:19:16,340
there's a new quirk going in for 4.20

00:19:12,320 --> 00:19:18,050
where an SRO v VF actually reports a pin

00:19:16,340 --> 00:19:20,990
register indicating that it does support

00:19:18,050 --> 00:19:22,130
legacy interrupts but virtual functions

00:19:20,990 --> 00:19:25,490
are not allowed to support legacy

00:19:22,130 --> 00:19:28,870
interrupts and it doesn't so we need to

00:19:25,490 --> 00:19:32,120
virtualize that pin to mask that problem

00:19:28,870 --> 00:19:36,710
we have a couple MSI X issues we have a

00:19:32,120 --> 00:19:40,190
real tech card that exposes MSI through

00:19:36,710 --> 00:19:42,460
a backdoor and it's in mio space so

00:19:40,190 --> 00:19:45,010
that's another case where it's

00:19:42,460 --> 00:19:48,040
physical addresses to the device of the

00:19:45,010 --> 00:19:53,860
device allows the the user to program

00:19:48,040 --> 00:19:55,780
those and we have to virtualize that and

00:19:53,860 --> 00:19:57,010
I'll skip Chelsea oh because we're

00:19:55,780 --> 00:19:59,950
running out of time but I will mention

00:19:57,010 --> 00:20:04,410
that we do have MSI X relocation so that

00:19:59,950 --> 00:20:06,880
problem I mentioned with when we have

00:20:04,410 --> 00:20:08,170
virtualizing mm i/o space and that can

00:20:06,880 --> 00:20:10,660
cause performance problems and we

00:20:08,170 --> 00:20:15,190
necessarily need to virtualize the MSI X

00:20:10,660 --> 00:20:17,200
ok ssin we can actually move that so the

00:20:15,190 --> 00:20:18,970
PCI spec recommends things like 4 and 8k

00:20:17,200 --> 00:20:22,210
page sizes which are just simply not

00:20:18,970 --> 00:20:27,610
good for things like arm where we might

00:20:22,210 --> 00:20:30,220
be using 64 K page sizes so quickly

00:20:27,610 --> 00:20:31,390
wrapping up here I hope this is giving

00:20:30,220 --> 00:20:34,120
you a good idea of things we have

00:20:31,390 --> 00:20:35,620
quirked things we can quark some of the

00:20:34,120 --> 00:20:39,220
issues that we need to think about when

00:20:35,620 --> 00:20:41,110
we're working devices and in general

00:20:39,220 --> 00:20:43,600
well be quote unquote well behaved

00:20:41,110 --> 00:20:46,630
devices don't shouldn't need these

00:20:43,600 --> 00:20:49,510
quirks but we do have them available to

00:20:46,630 --> 00:20:53,980
us when we need to to make devices that

00:20:49,510 --> 00:20:56,290
are troublesome work well and again for

00:20:53,980 --> 00:21:00,070
hardware designers things to do to avoid

00:20:56,290 --> 00:21:02,860
these sorts of quirks ACS as I mentioned

00:21:00,070 --> 00:21:05,880
provides us the isolation we need gets

00:21:02,860 --> 00:21:09,130
those I mean we group sizes smaller

00:21:05,880 --> 00:21:11,020
working function level resets shouldn't

00:21:09,130 --> 00:21:15,280
need to say working and provide this

00:21:11,020 --> 00:21:16,960
feature but we do and avoid leaking any

00:21:15,280 --> 00:21:18,550
sorts of physical addresses so we should

00:21:16,960 --> 00:21:20,230
only be looking at physical addresses of

00:21:18,550 --> 00:21:23,830
the device through the PCI config space

00:21:20,230 --> 00:21:26,320
anytime you can get to those through mm

00:21:23,830 --> 00:21:28,150
IO space and the driver makes use of

00:21:26,320 --> 00:21:33,160
those are potentially cases where we

00:21:28,150 --> 00:21:35,650
need to virtualize and as I mentioned

00:21:33,160 --> 00:21:37,630
with the MSI X bar it seems like the

00:21:35,650 --> 00:21:40,240
best way to avoid page size issues with

00:21:37,630 --> 00:21:42,520
him as X vector table is to simply make

00:21:40,240 --> 00:21:44,860
use of the MSX table in a different bar

00:21:42,520 --> 00:21:46,600
a separate bar from anything else and

00:21:44,860 --> 00:21:50,560
then you don't have to worry about those

00:21:46,600 --> 00:21:52,880
sorts of issues so I don't know if I

00:21:50,560 --> 00:22:03,720
have any time for questions but

00:21:52,880 --> 00:22:07,410
Cerrone Thanks

00:22:03,720 --> 00:22:11,280
I have two questions one is about it if

00:22:07,410 --> 00:22:14,059
a canoe it's been West night so there

00:22:11,280 --> 00:22:16,410
are two different implementations of flr

00:22:14,059 --> 00:22:19,740
one can be implemented through an

00:22:16,410 --> 00:22:21,660
advanced function capability which was I

00:22:19,740 --> 00:22:23,660
believe it was specified so that you

00:22:21,660 --> 00:22:26,130
could implement it with a PCI

00:22:23,660 --> 00:22:29,130
conventional PCI device because it

00:22:26,130 --> 00:22:31,400
doesn't require the PCIe capability and

00:22:29,130 --> 00:22:34,440
then the other one is through the PCIe

00:22:31,400 --> 00:22:36,360
capability itself so it's just two

00:22:34,440 --> 00:22:40,950
different mechanisms in PCI config space

00:22:36,360 --> 00:22:44,390
to trigger an flr so the other one is

00:22:40,950 --> 00:22:47,550
probably a m-- d radio the password set

00:22:44,390 --> 00:22:50,400
the problem you encounter is seeing that

00:22:47,550 --> 00:22:53,490
visa can now come back all the

00:22:50,400 --> 00:22:56,490
resentment there is not supported so

00:22:53,490 --> 00:22:58,950
there in most graphics cards there is no

00:22:56,490 --> 00:23:02,550
flr support perhaps the ones you're

00:22:58,950 --> 00:23:05,429
working on there are hopefully so we

00:23:02,550 --> 00:23:08,190
generally do a bus reset and then the

00:23:05,429 --> 00:23:11,429
device doesn't come back so the battery

00:23:08,190 --> 00:23:13,440
said yeah just referring to our second

00:23:11,429 --> 00:23:15,540
does six second plasma secondary bus we

00:23:13,440 --> 00:23:17,910
said yeah so the device doesn't come

00:23:15,540 --> 00:23:21,390
back we and we understood there were

00:23:17,910 --> 00:23:24,809
some actual ASIC issues on the Bonaire

00:23:21,390 --> 00:23:26,100
and Hawaii chips and we do have those

00:23:24,809 --> 00:23:30,179
are the quirks that we've implemented in

00:23:26,100 --> 00:23:33,300
qmu that are kind of 80% stable but we

00:23:30,179 --> 00:23:35,460
see users randomly complaining about

00:23:33,300 --> 00:23:38,160
other devices and it seems like some

00:23:35,460 --> 00:23:39,870
users have great success and other users

00:23:38,160 --> 00:23:42,390
don't so I don't know if they're using

00:23:39,870 --> 00:23:46,470
different chips or but if we could have

00:23:42,390 --> 00:23:49,050
a you as a contact for working on those

00:23:46,470 --> 00:23:51,800
that'd be great yeah I think you can

00:23:49,050 --> 00:23:55,440
come to me for that reset we have some

00:23:51,800 --> 00:23:58,770
tricks left very work and actually

00:23:55,440 --> 00:23:59,630
implement the animators are very

00:23:58,770 --> 00:24:02,120
surprised

00:23:59,630 --> 00:24:04,760
in these oceans that would make me eat

00:24:02,120 --> 00:24:07,610
if you cut that properly okay in the

00:24:04,760 --> 00:24:09,770
virtualization cases actually we have a

00:24:07,610 --> 00:24:12,920
few other recent mixers they were able

00:24:09,770 --> 00:24:15,800
to reset the tip you'll I can think

00:24:12,920 --> 00:24:19,040
kindig early result 1000 times or maybe

00:24:15,800 --> 00:24:20,870
up to 2,000 times it can contain yeah

00:24:19,040 --> 00:24:23,180
yeah I understand there are some

00:24:20,870 --> 00:24:25,490
improvements in the AMD GPU driver for

00:24:23,180 --> 00:24:28,910
reset and if we could port some of those

00:24:25,490 --> 00:24:31,010
to the general reset quirks that would

00:24:28,910 --> 00:24:33,320
be great for making use making use of

00:24:31,010 --> 00:24:38,060
them in device assignment thank you yeah

00:24:33,320 --> 00:24:40,760
thanks just real quick are there any

00:24:38,060 --> 00:24:47,090
works for the reserved region I mean

00:24:40,760 --> 00:24:52,280
device is those are an issue as well

00:24:47,090 --> 00:24:55,190
so generally our mr ours are there vtd

00:24:52,280 --> 00:24:57,470
specific and they specify that the host

00:24:55,190 --> 00:25:00,140
should have an identity mapping of that

00:24:57,470 --> 00:25:03,530
arm are arranged through the MMU and

00:25:00,140 --> 00:25:05,570
we've we've taken the approach that for

00:25:03,530 --> 00:25:10,160
USB devices we think they're only used

00:25:05,570 --> 00:25:13,010
for emulation of basically ps2 support

00:25:10,160 --> 00:25:15,770
and so we generally ignore the arm are

00:25:13,010 --> 00:25:17,210
for those for graphics we believe

00:25:15,770 --> 00:25:20,810
they're usually used for stolen memory

00:25:17,210 --> 00:25:23,150
and we think that we can ignore them too

00:25:20,810 --> 00:25:24,980
but they are causing us some serious

00:25:23,150 --> 00:25:28,640
issues because we're trying to implement

00:25:24,980 --> 00:25:31,130
code for an io v a list so we know what

00:25:28,640 --> 00:25:34,100
ranges of io v a space we can actually

00:25:31,130 --> 00:25:36,800
make use of and those are mars are

00:25:34,100 --> 00:25:38,900
coming up as reserved regions that we

00:25:36,800 --> 00:25:40,910
cannot make use of and so we can't

00:25:38,900 --> 00:25:43,340
continue we can't we have a conflict in

00:25:40,910 --> 00:25:45,050
requirement that we want to know what

00:25:43,340 --> 00:25:47,540
i'm in new ranges we can use and what we

00:25:45,050 --> 00:25:49,910
can't and we were using those previously

00:25:47,540 --> 00:25:52,760
just ignoring them and now we have an

00:25:49,910 --> 00:25:55,370
issue that we can't so if you have any

00:25:52,760 --> 00:26:00,190
input on how we can resolve that it

00:25:55,370 --> 00:26:01,850
would be great okay okay thank you

00:26:00,190 --> 00:26:06,720
thanks

00:26:01,850 --> 00:26:12,509
[Applause]

00:26:06,720 --> 00:26:12,509

YouTube URL: https://www.youtube.com/watch?v=A9rV2_3yIOk


