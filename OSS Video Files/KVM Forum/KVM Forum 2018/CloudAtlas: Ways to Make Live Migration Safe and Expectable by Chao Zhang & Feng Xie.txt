Title: CloudAtlas: Ways to Make Live Migration Safe and Expectable by Chao Zhang & Feng Xie
Publication date: 2018-11-14
Playlist: KVM Forum 2018
Description: 
	The public cloud users, especially enterprise users, are increasingly concerned about the stability of the infrastructure provided, therefore the performance impact of the live migration itself can no longer be ignored. In order to perform migration, the following needs to be considered: 1)How to classify the workload and evaluate the performance impact. 2)When should we migrate to reduce the impact to a minimum. 3)How to select params of the migration to balance the resource consumption and migrate speed. The ClouAtlas we build rely on KVM hypervisor to collect data like CPU usage, memory/TLB access and IO. Based on a statistical model and Deep Learning Algorithm, we classify the workload of the VM, and predict proper time to perform migration. After tens of thousands of tests, our system shows an obvious alleviation of the migration impact and a boost of the migration performance.

---

Feng Xie
technical expert
Alibaba Cloud

Feng has been working on virtualization since 2012. He's worked on several areas such as GPU virtualizaton and ARM virtualization. Now Feng is employed by Alibaba Cloud, and is focus on Artificial Intelligence Operation and Maintenance based on Machine Learning.

Chao Zhang
technical expert
Alibaba Cloud

Chao, as a initiated participant of the Live migration team at Alibaba Cloud, has completely witnessed how this technology implanted itself into the Ali-Cloud system along a tough way. 
Before join Alibaba, Chao is a kernel developer engineer working at Huawei EulerLinux team for five years.
Captions: 
	00:00:01,040 --> 00:00:07,940
[Music]

00:00:05,420 --> 00:00:12,440
good afternoon everyone

00:00:07,940 --> 00:00:15,870
I'm Jung ho I worked at Alibaba cloud

00:00:12,440 --> 00:00:18,869
today I will introduce about the Cloud

00:00:15,870 --> 00:00:21,660
Atlas and this year system we build in

00:00:18,869 --> 00:00:24,230
our cloud system to makes a live

00:00:21,660 --> 00:00:29,279
migration in our cloud easy and

00:00:24,230 --> 00:00:31,050
expectable in the last few years we've

00:00:29,279 --> 00:00:33,540
been paying a lot of attention to

00:00:31,050 --> 00:00:36,600
increase the migration performance in

00:00:33,540 --> 00:00:40,620
our cloud and as the live migration is

00:00:36,600 --> 00:00:43,590
gaining very important influential role

00:00:40,620 --> 00:00:46,469
in our cloud we gradually find that

00:00:43,590 --> 00:00:51,710
there is a gap between the basic

00:00:46,469 --> 00:00:55,649
migration capability and its you scenery

00:00:51,710 --> 00:00:59,250
the major dilemma is that the migration

00:00:55,649 --> 00:01:01,289
performance and its cost which means

00:00:59,250 --> 00:01:04,739
that if we want to decrease the

00:01:01,289 --> 00:01:07,110
migration to to time and migration

00:01:04,739 --> 00:01:10,200
downtown and increase the success rate

00:01:07,110 --> 00:01:14,250
we need to assign more CPU and network

00:01:10,200 --> 00:01:17,520
bandwidth to the migrations thread but

00:01:14,250 --> 00:01:20,520
as we what we see from our cloud is that

00:01:17,520 --> 00:01:23,189
our customer are demanding more and more

00:01:20,520 --> 00:01:26,040
sleep memory and CPU usage in our cloud

00:01:23,189 --> 00:01:30,630
and more and more memory intensive

00:01:26,040 --> 00:01:35,759
workload a star to mousse our machine or

00:01:30,630 --> 00:01:38,369
mousse our workload to our cloud so is

00:01:35,759 --> 00:01:41,610
there anything else else what we can do

00:01:38,369 --> 00:01:45,479
to rather other than just assign more

00:01:41,610 --> 00:01:49,409
CPUs to our migrations read so we want

00:01:45,479 --> 00:01:54,479
to step back and to say if there

00:01:49,409 --> 00:01:57,060
anything else we can do here is an

00:01:54,479 --> 00:02:01,200
example of the migration cost in our

00:01:57,060 --> 00:02:03,930
cloud with the VM configuration is very

00:02:01,200 --> 00:02:09,989
low more in our cloud about the it has

00:02:03,930 --> 00:02:11,489
30 32 we CPU and 128 gigabyte memory we

00:02:09,989 --> 00:02:13,380
found that if we start the migration

00:02:11,489 --> 00:02:16,710
that's the peak pea

00:02:13,380 --> 00:02:20,040
of the workload the 30 rate can be

00:02:16,710 --> 00:02:23,220
greater than 600 souls in the pages per

00:02:20,040 --> 00:02:26,190
second and which means that if we want

00:02:23,220 --> 00:02:29,700
if we want my gradient of this can we

00:02:26,190 --> 00:02:33,300
have to assign six views to do the

00:02:29,700 --> 00:02:38,120
compression and decompression work but

00:02:33,300 --> 00:02:42,110
if we migrate Savion at its lower peak

00:02:38,120 --> 00:02:46,350
usage the dirty rate can drop down to

00:02:42,110 --> 00:02:48,540
200 thousand pages per second which

00:02:46,350 --> 00:02:51,030
means that only one CPU is enough

00:02:48,540 --> 00:02:55,370
sometimes there is no need to do the

00:02:51,030 --> 00:02:58,470
compression and from the statistic

00:02:55,370 --> 00:03:00,720
statistic data in our cloud we found

00:02:58,470 --> 00:03:03,870
that the dirty page rate difference

00:03:00,720 --> 00:03:07,620
between the peak load period and low

00:03:03,870 --> 00:03:13,050
peak period may reach larger than large

00:03:07,620 --> 00:03:16,560
as large as five times so here are the

00:03:13,050 --> 00:03:20,520
we list the challenges we face when we

00:03:16,560 --> 00:03:23,310
want to employ a lie measuring you slam

00:03:20,520 --> 00:03:26,280
a migration as possible as much as

00:03:23,310 --> 00:03:28,610
possible the first one is why should I

00:03:26,280 --> 00:03:32,310
mark where migration be performed and

00:03:28,610 --> 00:03:35,850
second if the migration is essential

00:03:32,310 --> 00:03:38,400
which we and is required to migrate the

00:03:35,850 --> 00:03:43,350
third went to migrate and how to migrate

00:03:38,400 --> 00:03:45,510
how many resources should be assigned so

00:03:43,350 --> 00:03:49,140
we built this little boost and migration

00:03:45,510 --> 00:03:51,480
system in our cloud the even center we

00:03:49,140 --> 00:03:55,290
are collection events like maintenance

00:03:51,480 --> 00:03:58,800
events scheduling events and then the

00:03:55,290 --> 00:04:02,940
data analyzer here we are

00:03:58,800 --> 00:04:08,520
evaluate the migration cost using the

00:04:02,940 --> 00:04:11,280
data VM data are collected and then the

00:04:08,520 --> 00:04:14,550
analyzer we are gives a give out the

00:04:11,280 --> 00:04:17,340
migration candidate which means that we

00:04:14,550 --> 00:04:20,910
and should be migrated and then the

00:04:17,340 --> 00:04:24,630
predictor will and then a predictor we

00:04:20,910 --> 00:04:27,510
are predictive M workload and fun try to

00:04:24,630 --> 00:04:30,500
find a win and how to migrate

00:04:27,510 --> 00:04:33,110
during the whole migration process the

00:04:30,500 --> 00:04:35,880
migration performance data we all be

00:04:33,110 --> 00:04:41,729
collected and then return back to our

00:04:35,880 --> 00:04:45,419
monitor system let's first look at

00:04:41,729 --> 00:04:47,610
something about the analyzer the

00:04:45,419 --> 00:04:51,630
migration analyzer the first when we

00:04:47,610 --> 00:04:54,600
need to do is the workload prediction as

00:04:51,630 --> 00:04:57,440
I already have a lot of works related to

00:04:54,600 --> 00:05:00,510
the workload prediction much of them

00:04:57,440 --> 00:05:05,100
machine learning algorithms like ARIMA

00:05:00,510 --> 00:05:06,810
and rst n but but we soon found out

00:05:05,100 --> 00:05:11,669
these algorithms are quite

00:05:06,810 --> 00:05:14,940
time-consuming and because we don't need

00:05:11,669 --> 00:05:17,370
the exact value of the vm workload what

00:05:14,940 --> 00:05:21,600
we need is just as a changing of the

00:05:17,370 --> 00:05:26,699
workload we just want to know that they

00:05:21,600 --> 00:05:28,800
will go up or they will go down and we

00:05:26,699 --> 00:05:31,320
have investigated our workload for a

00:05:28,800 --> 00:05:36,090
little bit ton and we found that nearly

00:05:31,320 --> 00:05:39,810
60% to 80% of our workload a period

00:05:36,090 --> 00:05:44,039
workload so we did allow a lot work to

00:05:39,810 --> 00:05:47,490
accelerate to the workload prediction to

00:05:44,039 --> 00:05:50,700
detect if it is a period workload after

00:05:47,490 --> 00:05:53,820
the after the workload prediction Rian's

00:05:50,700 --> 00:05:57,479
which have small size and low and always

00:05:53,820 --> 00:06:00,300
have low usage we all be classified into

00:05:57,479 --> 00:06:03,479
the insensitive migration insensitive

00:06:00,300 --> 00:06:06,630
workload all these well we a mess we all

00:06:03,479 --> 00:06:09,960
be means that all of these VMs can be

00:06:06,630 --> 00:06:13,680
migrated immediately and for we'ums

00:06:09,960 --> 00:06:16,410
which have been used heavily with where

00:06:13,680 --> 00:06:19,470
we are trying to migrate them when they

00:06:16,410 --> 00:06:23,610
are used their usage are down and for

00:06:19,470 --> 00:06:27,450
some cases like very extraordinary large

00:06:23,610 --> 00:06:29,520
reams when we not only we should mike

00:06:27,450 --> 00:06:32,729
resent when they are you ins are low

00:06:29,520 --> 00:06:35,039
peak period we have to assign more

00:06:32,729 --> 00:06:39,650
receive you and buyers to do the

00:06:35,039 --> 00:06:39,650
compression or since anything else

00:06:41,160 --> 00:06:47,620
first let us look something about the

00:06:44,490 --> 00:06:50,410
workload prediction before the workload

00:06:47,620 --> 00:06:54,330
prediction I want to introduce a little

00:06:50,410 --> 00:06:57,910
things about the basic signal processing

00:06:54,330 --> 00:07:00,070
background as we can see from the middle

00:06:57,910 --> 00:07:03,639
picture this is this is a region of

00:07:00,070 --> 00:07:06,280
Sierra's although we can hardly find the

00:07:03,639 --> 00:07:09,729
repeating pattern of the original

00:07:06,280 --> 00:07:13,300
signals but it is a combined of the

00:07:09,729 --> 00:07:18,130
three signals about and about three

00:07:13,300 --> 00:07:21,940
signals have very fixed and but

00:07:18,130 --> 00:07:24,340
different repeat pattern but although it

00:07:21,940 --> 00:07:27,820
is not easy to recognize the pattern

00:07:24,340 --> 00:07:29,860
from the original SiC Cirus directly but

00:07:27,820 --> 00:07:33,220
after the transformation of the original

00:07:29,860 --> 00:07:35,650
signal to the frequency domain we can

00:07:33,220 --> 00:07:40,419
easily find that there are three major

00:07:35,650 --> 00:07:44,020
elements of in this series and so this

00:07:40,419 --> 00:07:47,979
is a basic way we do superior detection

00:07:44,020 --> 00:07:50,400
of the workload so and we can turn the

00:07:47,979 --> 00:07:53,680
workload detection period detection

00:07:50,400 --> 00:07:58,110
problem into a power spectrum density

00:07:53,680 --> 00:08:02,320
estimation which means that we need to

00:07:58,110 --> 00:08:07,960
find the most significant repeat pattern

00:08:02,320 --> 00:08:11,770
of the inputs areas of the inputs areas

00:08:07,960 --> 00:08:14,560
it means that to find the repeated

00:08:11,770 --> 00:08:19,960
pattern it means that giving an input

00:08:14,560 --> 00:08:22,780
serious acts effort and the FFT is

00:08:19,960 --> 00:08:26,139
calculated and try to find the major

00:08:22,780 --> 00:08:32,529
frequencies of the of the impurity areas

00:08:26,139 --> 00:08:35,409
and some some criteria are used to d2 to

00:08:32,529 --> 00:08:37,719
try to predict a period workload the

00:08:35,409 --> 00:08:40,630
peer criteria includes the first one is

00:08:37,719 --> 00:08:43,360
that we need to find the top frequencies

00:08:40,630 --> 00:08:47,190
which means that these frequencies as a

00:08:43,360 --> 00:08:50,530
major component in the workload and the

00:08:47,190 --> 00:08:52,800
lowest frequency is a use as a base

00:08:50,530 --> 00:08:56,760
frequencies for pre

00:08:52,800 --> 00:08:59,990
diction we just we just repeat the

00:08:56,760 --> 00:09:05,269
original series in the base frequency as

00:08:59,990 --> 00:09:09,180
their pre prediction here is a just

00:09:05,269 --> 00:09:12,180
example we can see from the picture

00:09:09,180 --> 00:09:15,329
above is a term serious without noises

00:09:12,180 --> 00:09:17,820
and we can see from the left the right

00:09:15,329 --> 00:09:21,480
part of picture that we clearly there

00:09:17,820 --> 00:09:24,000
are three major elements of God and the

00:09:21,480 --> 00:09:27,860
lower picture is a either improve time

00:09:24,000 --> 00:09:31,529
series with noises and which means that

00:09:27,860 --> 00:09:34,200
but also it is but we can still find

00:09:31,529 --> 00:09:38,190
that there are three major elements in

00:09:34,200 --> 00:09:41,310
the here also it is not as clean as a

00:09:38,190 --> 00:09:44,250
picture about because it is a period our

00:09:41,310 --> 00:09:47,130
workload so so we just repeat the last

00:09:44,250 --> 00:09:54,690
period two as a prediction of the future

00:09:47,130 --> 00:09:57,690
network like this because it is an

00:09:54,690 --> 00:10:01,290
estimation so we need a way to estimate

00:09:57,690 --> 00:10:05,010
the accuracy of our prediction for

00:10:01,290 --> 00:10:08,910
simplicity we just use a period of the

00:10:05,010 --> 00:10:13,850
last serial of X and the period before

00:10:08,910 --> 00:10:16,700
last to estimate the accuracy of our our

00:10:13,850 --> 00:10:20,459
estimation as we can see from the

00:10:16,700 --> 00:10:23,670
picture in the below the left picture

00:10:20,459 --> 00:10:26,630
have less noises lanza than the right

00:10:23,670 --> 00:10:30,300
picture and we can see there we become

00:10:26,630 --> 00:10:33,810
there in sample rmse we computed is

00:10:30,300 --> 00:10:39,240
relatively you relate positively or

00:10:33,810 --> 00:10:42,029
crawl in chosen to noise levels and

00:10:39,240 --> 00:10:45,060
these are the two estimation of the real

00:10:42,029 --> 00:10:49,320
way music deterring our cloud the vm1

00:10:45,060 --> 00:10:53,839
have a has the example on sea of 21

00:10:49,320 --> 00:10:58,339
which is very large and we can see that

00:10:53,839 --> 00:11:03,750
from these areas the family the earth

00:10:58,339 --> 00:11:05,390
know from maybe the thumb part and then

00:11:03,750 --> 00:11:08,570
there is a miss me

00:11:05,390 --> 00:11:14,839
prediction of the Vienna and but from

00:11:08,570 --> 00:11:18,430
the VM to which is which is which has a

00:11:14,839 --> 00:11:23,860
small in sample are Mozilla it has only

00:11:18,430 --> 00:11:29,029
0.3 love my RMS ye and we can see that

00:11:23,860 --> 00:11:31,430
the prediction can track the trend of

00:11:29,029 --> 00:11:34,279
the the changing of the original signal

00:11:31,430 --> 00:11:38,410
although there is a little shift in the

00:11:34,279 --> 00:11:41,930
original signal so this so that the

00:11:38,410 --> 00:11:46,310
estimation of the pier della workload

00:11:41,930 --> 00:11:49,130
can be used in this in this in this way

00:11:46,310 --> 00:11:53,450
and by the way the time cost to estimate

00:11:49,130 --> 00:11:56,930
a wholly workers just cost about 10 to

00:11:53,450 --> 00:11:58,790
20 milliseconds compared with the

00:11:56,930 --> 00:12:02,959
machine learning algorithm estimation

00:11:58,790 --> 00:12:05,990
may need 22 hours for training or

00:12:02,959 --> 00:12:10,250
anything else and until now we have

00:12:05,990 --> 00:12:13,010
finished the estimation of the period

00:12:10,250 --> 00:12:16,550
workload in our cloud and for lumpy

00:12:13,010 --> 00:12:18,470
lumpy rat workload and with PL workload

00:12:16,550 --> 00:12:21,079
I will add my colleague Shivan

00:12:18,470 --> 00:12:24,790
introduced his work on these areas so

00:12:21,079 --> 00:12:24,790
how to have helped the live migration

00:12:30,040 --> 00:12:37,339
good afternoon everyone my name is Shiva

00:12:34,459 --> 00:12:41,269
I'm from Alibaba crowd heterogeneous

00:12:37,339 --> 00:12:46,750
computing team my colleague Chao has

00:12:41,269 --> 00:12:50,660
produced how we use FFT to protect our

00:12:46,750 --> 00:12:56,110
periodic we are MOOC loaded but not all

00:12:50,660 --> 00:13:00,410
VM has a overviews predicted periodicity

00:12:56,110 --> 00:13:04,279
so we need other algorithms to predict

00:13:00,410 --> 00:13:07,490
such a which we assume we know that the

00:13:04,279 --> 00:13:11,149
workload of we are MUC load is a charm

00:13:07,490 --> 00:13:15,740
serious model so we use tons the other

00:13:11,149 --> 00:13:18,949
model to predict optimal migration Tam

00:13:15,740 --> 00:13:23,149
we know we actually used to

00:13:18,949 --> 00:13:28,449
different time series model ARIMA and

00:13:23,149 --> 00:13:31,689
last year the to model has their own

00:13:28,449 --> 00:13:37,579
advantages and disadvantages

00:13:31,689 --> 00:13:40,970
first ARIMA model it is an abbreviation

00:13:37,579 --> 00:13:43,329
of autoregressive integrated moving

00:13:40,970 --> 00:13:45,919
average model

00:13:43,329 --> 00:13:51,259
it's a traditional machine learning

00:13:45,919 --> 00:13:53,959
method and it has a advantage of low

00:13:51,259 --> 00:13:59,929
calculator cost and a good performance

00:13:53,959 --> 00:14:04,129
on small data set its disadvantage is it

00:13:59,929 --> 00:14:10,459
is not very high accuracy as high as

00:14:04,129 --> 00:14:13,339
deep learning and then as TM its phoneme

00:14:10,459 --> 00:14:17,720
is long short and memory networks a

00:14:13,339 --> 00:14:21,499
special kind of or it's a deep learning

00:14:17,720 --> 00:14:26,989
method we know the tip learning method

00:14:21,499 --> 00:14:30,679
has very high IQ accuracy but it needed

00:14:26,989 --> 00:14:36,230
new calculation cost and need a large

00:14:30,679 --> 00:14:41,660
data set our goal is to quickly and

00:14:36,230 --> 00:14:46,339
accurately to predict optimal macro

00:14:41,660 --> 00:14:50,860
aging tom-tom window so we use both

00:14:46,339 --> 00:14:58,819
algorithms combined they are respective

00:14:50,860 --> 00:15:02,809
strengths this picture shows how we use

00:14:58,819 --> 00:15:06,410
regression algorithm to predict optimal

00:15:02,809 --> 00:15:10,360
recreation time window first we use a

00:15:06,410 --> 00:15:14,209
Rhema model feet - one more sample

00:15:10,360 --> 00:15:18,679
historical load data then we will

00:15:14,209 --> 00:15:21,919
English evaluation the model if model

00:15:18,679 --> 00:15:24,649
works where we will use the model

00:15:21,919 --> 00:15:28,699
predictor low workload one hour time

00:15:24,649 --> 00:15:32,210
window over the next 24 hours in a

00:15:28,699 --> 00:15:37,160
meantime we use earth year

00:15:32,210 --> 00:15:43,430
model by using one minute somehow the

00:15:37,160 --> 00:15:47,420
historic data so we also evaluation the

00:15:43,430 --> 00:15:53,209
model if the model user has a good like

00:15:47,420 --> 00:15:55,760
accuracy we can use this one if the

00:15:53,209 --> 00:16:02,630
model has a good good precision

00:15:55,760 --> 00:16:07,399
precision one one one one hour time

00:16:02,630 --> 00:16:11,300
window which we predict has come has

00:16:07,399 --> 00:16:15,260
caffeine we can we can use our ASTM

00:16:11,300 --> 00:16:18,410
model to predict terminate time window

00:16:15,260 --> 00:16:20,750
in the one hour time window then we can

00:16:18,410 --> 00:16:27,020
predict our optimal my Croatian time

00:16:20,750 --> 00:16:34,370
window let's look at the regression

00:16:27,020 --> 00:16:37,339
algorithm result this picture shows how

00:16:34,370 --> 00:16:41,020
we use a remote model to predict the

00:16:37,339 --> 00:16:45,529
next 24 hours result and the blue

00:16:41,020 --> 00:16:48,920
represents the real CPU load the red

00:16:45,529 --> 00:16:52,390
represents what we predict binding

00:16:48,920 --> 00:16:55,910
enlarging the picture inside the recycle

00:16:52,390 --> 00:17:01,070
we can see that there are Rema model can

00:16:55,910 --> 00:17:06,470
wear predict lower the Chandan in 24

00:17:01,070 --> 00:17:09,380
hours in next 24 hours and the green

00:17:06,470 --> 00:17:15,699
arrows points to our local or time

00:17:09,380 --> 00:17:22,339
window a code according to test results

00:17:15,699 --> 00:17:26,500
75% of non-periodic we end has a Azariah

00:17:22,339 --> 00:17:30,070
yield less than 10 and certain 9%

00:17:26,500 --> 00:17:33,770
nothing that is 3% of Navarrete now

00:17:30,070 --> 00:17:42,710
periodic VM has this rmse in less than

00:17:33,770 --> 00:17:45,200
50 next arrastia big these two pictures

00:17:42,710 --> 00:17:49,460
shows

00:17:45,200 --> 00:17:53,920
reach ammeter predictor will glow to

00:17:49,460 --> 00:17:57,530
predict in in our Williams one day

00:17:53,920 --> 00:18:01,370
they're about picture is the rear CPU

00:17:57,530 --> 00:18:06,130
workload and the below is the low do we

00:18:01,370 --> 00:18:09,260
predict eighty percent to 8 percent of

00:18:06,130 --> 00:18:12,770
non-periodic p.m. has issue our mercy

00:18:09,260 --> 00:18:15,590
less than five and a 91% of them

00:18:12,770 --> 00:18:21,380
periodically am its Armas is less than

00:18:15,590 --> 00:18:27,050
10 now let's look at the performance of

00:18:21,380 --> 00:18:32,150
the algorithm most of we am has most of

00:18:27,050 --> 00:18:39,080
iam is a strong period we use F of T to

00:18:32,150 --> 00:18:45,200
predict to protect the time window and a

00:18:39,080 --> 00:18:48,530
fatigue can can just use Tom castor 10

00:18:45,200 --> 00:18:51,560
to 30 minute milliseconds and these

00:18:48,530 --> 00:18:55,190
armies is less than here for the order

00:18:51,560 --> 00:18:58,190
to workload type we use a reminder LCM

00:18:55,190 --> 00:19:01,970
to predict their Armour C is less than

00:18:58,190 --> 00:19:07,150
50 and Aramis Tom coaster is less than

00:19:01,970 --> 00:19:07,150
terminate LCM is less than two hours

00:19:11,890 --> 00:19:19,029
as we mentioned before we say we use a

00:19:16,350 --> 00:19:23,110
class efficient algorithm to predict

00:19:19,029 --> 00:19:27,279
whether we are miss migration system if

00:19:23,110 --> 00:19:30,940
the Liam's TomTom is it's less than or

00:19:27,279 --> 00:19:34,510
equal to 100 milliseconds we can mark it

00:19:30,940 --> 00:19:37,809
as Mack regimes at table if the tantrum

00:19:34,510 --> 00:19:42,130
is a Munna 100 milliseconds we can make

00:19:37,809 --> 00:19:46,179
with a market as migration system we

00:19:42,130 --> 00:19:48,519
know we have three main features that

00:19:46,179 --> 00:19:53,620
affect the performance of the live

00:19:48,519 --> 00:19:57,360
migration one our average with CPU

00:19:53,620 --> 00:20:02,260
utilization is one hour before migration

00:19:57,360 --> 00:20:05,200
to amplitude of fluctuation with whisker

00:20:02,260 --> 00:20:10,330
utilization it's a one day before

00:20:05,200 --> 00:20:14,740
vibration and three we are mr. strife

00:20:10,330 --> 00:20:17,710
we made a concern about the with number

00:20:14,740 --> 00:20:21,820
of with view and memory size of the

00:20:17,710 --> 00:20:24,789
watch machine piece art piece or our

00:20:21,820 --> 00:20:28,210
data we can change a model and a used

00:20:24,789 --> 00:20:33,760
model to predict and this algorithm is

00:20:28,210 --> 00:20:37,269
working process the tourism steer being

00:20:33,760 --> 00:20:39,490
tuned so we can we don't kick we don't

00:20:37,269 --> 00:20:46,450
give our rigorous result yet

00:20:39,490 --> 00:20:49,720
now finally the summary this picture

00:20:46,450 --> 00:20:56,440
this flow this flow chart shows how we

00:20:49,720 --> 00:20:57,820
use three algorithm to predict low work

00:20:56,440 --> 00:21:02,519
but low time window

00:20:57,820 --> 00:21:06,070
first we use classification algorithm to

00:21:02,519 --> 00:21:09,610
predict when a weather OPM is migration

00:21:06,070 --> 00:21:13,960
sustained if if we amidst incitive we

00:21:09,610 --> 00:21:16,510
can micro-hdmi Mattia immediately if we

00:21:13,960 --> 00:21:20,340
are miss system we can use half of tea

00:21:16,510 --> 00:21:21,580
to determine whether the we are miss

00:21:20,340 --> 00:21:25,610
periodical

00:21:21,580 --> 00:21:28,460
if yes we can do PR l repeat

00:21:25,610 --> 00:21:31,220
to predict a low workload time window

00:21:28,460 --> 00:21:35,720
even though we use a regression wrexham

00:21:31,220 --> 00:21:56,360
to predict a low workload time window so

00:21:35,720 --> 00:21:58,340
that's all any questions may be

00:21:56,360 --> 00:22:00,020
suggestion rather question so this is

00:21:58,340 --> 00:22:03,679
what this is really this is really cool

00:22:00,020 --> 00:22:06,500
a couple of years ago I looked at one

00:22:03,679 --> 00:22:09,620
tiny piece of this which was signals to

00:22:06,500 --> 00:22:11,570
use to try to to try to predict ahead of

00:22:09,620 --> 00:22:14,179
time what the what the pre copy

00:22:11,570 --> 00:22:15,950
convergence would would look like and

00:22:14,179 --> 00:22:17,900
there I can't remember off the top of my

00:22:15,950 --> 00:22:20,270
head but there's some literature on on

00:22:17,900 --> 00:22:23,720
doing the dirty tracking algorithm

00:22:20,270 --> 00:22:25,190
without actually starting the without

00:22:23,720 --> 00:22:27,530
actually starting the live migration

00:22:25,190 --> 00:22:30,020
process and you you can implement that

00:22:27,530 --> 00:22:31,730
on top of the existing I articles so

00:22:30,020 --> 00:22:36,770
that you you might want to add that to

00:22:31,730 --> 00:22:40,640
your stable of signals so you means that

00:22:36,770 --> 00:22:44,320
we can track the actual 30-page of the

00:22:40,640 --> 00:22:48,770
VM maybe every 5 minutes or every

00:22:44,320 --> 00:22:51,770
terminate so you mean this yeah

00:22:48,770 --> 00:22:54,980
basically you simulate you just do the

00:22:51,770 --> 00:22:56,929
dirty tracking mmm you don't transmit

00:22:54,980 --> 00:22:58,820
any data you don't do the live migration

00:22:56,929 --> 00:23:00,500
but that would that would tell you if

00:22:58,820 --> 00:23:02,809
you were to do the if you were to do the

00:23:00,500 --> 00:23:03,980
live migrations right now or at least

00:23:02,809 --> 00:23:06,440
the dirty fact and what would the

00:23:03,980 --> 00:23:12,440
convergence look like yes but it seems

00:23:06,440 --> 00:23:15,080
that it is a little heavy for us because

00:23:12,440 --> 00:23:18,679
if you want to track the dirty page or

00:23:15,080 --> 00:23:22,630
VM firstly you can now you have to split

00:23:18,679 --> 00:23:26,299
a two megabit page into a 4 kilobyte

00:23:22,630 --> 00:23:30,380
page which can cause maybe nearly about

00:23:26,299 --> 00:23:35,510
10% performance degradation of the VM

00:23:30,380 --> 00:23:39,230
and for some local like Reddy's workload

00:23:35,510 --> 00:23:41,679
is II have very very large memories

00:23:39,230 --> 00:23:45,580
yeah we're remembering intensively and

00:23:41,679 --> 00:23:50,059
this bleed can cause them hurt a lot

00:23:45,580 --> 00:23:54,200
yeah so we we have been trying to like

00:23:50,059 --> 00:23:57,230
talk with inter guys in inter about to

00:23:54,200 --> 00:23:59,570
enable some some hardware feature to

00:23:57,230 --> 00:24:03,799
help us to track the act your dirty page

00:23:59,570 --> 00:24:07,160
but actually currently we have no no

00:24:03,799 --> 00:24:12,410
ties to finite so we we decide to use

00:24:07,160 --> 00:24:19,100
this workload of the VN matrix like the

00:24:12,410 --> 00:24:21,710
CPU and everything else to as a non

00:24:19,100 --> 00:24:24,890
directly way to Marisa accurate early

00:24:21,710 --> 00:24:31,419
page and from our experiments that it

00:24:24,890 --> 00:24:31,419
does works yeah it that works thank you

00:24:39,430 --> 00:24:44,570
so can you talk a little bit about what

00:24:42,110 --> 00:24:46,490
you do with the prediction about when is

00:24:44,570 --> 00:24:52,250
a good time to move a VM I mean you have

00:24:46,490 --> 00:24:55,760
a road load balance roadmap around where

00:24:52,250 --> 00:25:02,330
the VM should be absent week later or

00:24:55,760 --> 00:25:04,010
what exactly is driving all of this you

00:25:02,330 --> 00:25:07,130
know the prediction is being used

00:25:04,010 --> 00:25:10,190
towards whatever okay so your means that

00:25:07,130 --> 00:25:13,160
you see use case or the scenery so why

00:25:10,190 --> 00:25:17,900
do we do perform the migration in our

00:25:13,160 --> 00:25:19,850
cloud yeah there are many cases the most

00:25:17,900 --> 00:25:23,000
important one is about the hardware

00:25:19,850 --> 00:25:26,960
maintenance like if we find the memory

00:25:23,000 --> 00:25:30,200
tends to crack like we have got too much

00:25:26,960 --> 00:25:33,920
ECC errors then we have to prepare to

00:25:30,200 --> 00:25:37,310
migrate VM to just in to prevent the VM

00:25:33,920 --> 00:25:40,160
crash and these cases the VM should be

00:25:37,310 --> 00:25:44,750
migrated immediately but most cases like

00:25:40,160 --> 00:25:47,200
we have been down load balance just

00:25:44,750 --> 00:25:50,990
because the background upgrading of the

00:25:47,200 --> 00:25:55,570
kernel and the software or anything else

00:25:50,990 --> 00:25:55,570
in these cases we do not need to migrate

00:25:55,750 --> 00:26:04,370
immediately so we try to find just plan

00:25:59,720 --> 00:26:06,110
our our way to do the migration to make

00:26:04,370 --> 00:26:10,070
a plan to make it more efficiently

00:26:06,110 --> 00:26:13,480
because if you if we do it in higher

00:26:10,070 --> 00:26:16,520
peak of the period of the workload

00:26:13,480 --> 00:26:19,220
sometimes the user the users complains

00:26:16,520 --> 00:26:23,210
about the performance degradation like

00:26:19,220 --> 00:26:27,230
because why like ready servers the two

00:26:23,210 --> 00:26:30,200
seasons so and it caused and it is it is

00:26:27,230 --> 00:26:32,810
also very expensive for us because too

00:26:30,200 --> 00:26:36,620
many CPUs are used and too many

00:26:32,810 --> 00:26:40,880
bandwidth have been exploited which make

00:26:36,620 --> 00:26:44,720
horse that the background conflict of

00:26:40,880 --> 00:26:48,570
the network because the storage storage

00:26:44,720 --> 00:26:51,330
of the VM and Navia may share the

00:26:48,570 --> 00:26:55,440
the network card so we tries to make the

00:26:51,330 --> 00:27:00,320
nine back attrition as easier as less

00:26:55,440 --> 00:27:02,460
heavier as possible this is why we do it

00:27:00,320 --> 00:27:05,580
thank you so the problem statement could

00:27:02,460 --> 00:27:10,320
be evacuated this node in a week and do

00:27:05,580 --> 00:27:15,120
it the best yeah yeah yeah this form now

00:27:10,320 --> 00:27:19,470
emergency cases even frozen emergency

00:27:15,120 --> 00:27:24,779
cases there are easy way to arrange the

00:27:19,470 --> 00:27:27,509
migration sequence on the host because

00:27:24,779 --> 00:27:29,519
some some waves may be quite easy to

00:27:27,509 --> 00:27:30,690
migrate and after they have been

00:27:29,519 --> 00:27:34,259
migrated Sam

00:27:30,690 --> 00:27:43,700
Daria PCP use left for us to use to

00:27:34,259 --> 00:27:45,930
migrate heavies liam's okay thank you

00:27:43,700 --> 00:27:48,120
thank you

00:27:45,930 --> 00:27:53,900
[Applause]

00:27:48,120 --> 00:27:53,900

YouTube URL: https://www.youtube.com/watch?v=fWqqNYFeNbk


