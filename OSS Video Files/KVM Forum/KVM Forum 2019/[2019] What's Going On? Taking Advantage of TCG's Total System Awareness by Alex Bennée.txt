Title: [2019] What's Going On? Taking Advantage of TCG's Total System Awareness by Alex Bennée
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	When emulating a system using QEMU's Tiny Code Generator we must inspect and translate every single instruction that gets executed. As we completely control the system we should be able to extract some interesting information about how the code executes. While other code instrumentation systems exist (DynamoRIO, Pin, Valgrind) QEMU is unique in supporting system emulation as well as not requiring the host system to have the same instruction set as the guest. In this talk we shall discuss how we can answer some interesting questions about programs running under QEMU. We shall examine some of the drawbacks of QEMU's current introspection support. Finally we shall discuss if a plugin system will allow for more detailed experiments without comprising our ability to continually improve the quality of our emulation code.

---

Alex Bennée
Linaro
Senior Software Engineer

Alex started learning to program in the 80s in an era of classic home computers that allowed you to get down and dirty at the system level. After graduating with a degree in Chemistry he's worked on a variety of projects including Fruit Machines, Line Cards, CCTV recorders and point-to-multipoint wireless microwave systems. Since the turn of the century his primary focus has been working with FLOSS platforms, especially Linux. For the last five years he's been working at Linaro helping improve QEMU's emulation features. A keen Emacs user he will happily answer questions and proselytise for the One True Editor (tm).

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,799 --> 00:00:12,300
morning everybody

00:00:08,429 --> 00:00:15,809
welcome to the last day of KVM forum

00:00:12,300 --> 00:00:19,770
just a few quick introductions my name's

00:00:15,809 --> 00:00:22,170
Alex bene I work for Lennar Oh mostly

00:00:19,770 --> 00:00:24,330
I'm interested in arm stuff I tend to

00:00:22,170 --> 00:00:26,490
spend my time working on TCG so on the

00:00:24,330 --> 00:00:30,869
emulation site but you will find me

00:00:26,490 --> 00:00:33,540
occasionally working on KVM so what are

00:00:30,869 --> 00:00:37,320
we talking about today and TCG plugins

00:00:33,540 --> 00:00:39,390
are a way for people to run experiments

00:00:37,320 --> 00:00:40,710
taking advantage of the fact that when

00:00:39,390 --> 00:00:42,809
you're running stuff under emulation

00:00:40,710 --> 00:00:44,160
under TCG you have complete and utter

00:00:42,809 --> 00:00:46,920
control of the system so you can

00:00:44,160 --> 00:00:50,190
literally examine the system state every

00:00:46,920 --> 00:00:51,989
single instructions do you execute but

00:00:50,190 --> 00:00:53,070
before I go into detail on that I just

00:00:51,989 --> 00:00:55,469
want to talk a little bit about the

00:00:53,070 --> 00:00:58,309
history of plugins in chrome you bit of

00:00:55,469 --> 00:01:02,850
a warning there are some dragons here

00:00:58,309 --> 00:01:04,619
so when Fabrice first wrote creme you he

00:01:02,850 --> 00:01:05,280
didn't really intend to do a plug-in

00:01:04,619 --> 00:01:07,619
system

00:01:05,280 --> 00:01:09,210
he considered plugins something that you

00:01:07,619 --> 00:01:13,110
really need for closed source projects

00:01:09,210 --> 00:01:14,760
and Crimea definitely wasn't and also

00:01:13,110 --> 00:01:16,500
early on in the project he didn't want

00:01:14,760 --> 00:01:18,540
to have the problems of dealing with

00:01:16,500 --> 00:01:21,900
binary compatibility or defining a

00:01:18,540 --> 00:01:24,000
stable API but I mean that statement was

00:01:21,900 --> 00:01:26,430
in 2004 it didn't take long before

00:01:24,000 --> 00:01:30,060
people were suggesting some sort of

00:01:26,430 --> 00:01:32,159
plugins interface when Furlan was an

00:01:30,060 --> 00:01:34,920
example of a fork of creme you that was

00:01:32,159 --> 00:01:36,930
designed to run Windows on on Linux and

00:01:34,920 --> 00:01:39,329
what they've taken is chunks of the

00:01:36,930 --> 00:01:43,110
claim you source code may be able to

00:01:39,329 --> 00:01:46,170
load plugins dynamically and the idea

00:01:43,110 --> 00:01:48,659
that they were going for was to have

00:01:46,170 --> 00:01:51,990
proprietary plugins to emulate bits of

00:01:48,659 --> 00:01:53,130
hardware as you can imagine this caused

00:01:51,990 --> 00:01:55,770
a little bit of discussion on the

00:01:53,130 --> 00:01:57,180
mailing list they weren't actually doing

00:01:55,770 --> 00:01:59,909
anything wrong because back in those

00:01:57,180 --> 00:02:02,310
days the bits of Crimea they've taken to

00:01:59,909 --> 00:02:04,500
build their windfall in projects we're

00:02:02,310 --> 00:02:05,880
all under fairly liberal BSD licenses

00:02:04,500 --> 00:02:08,039
and it's a it's a good lesson in

00:02:05,880 --> 00:02:10,200
reminding yourself of exactly how your

00:02:08,039 --> 00:02:14,849
project is licensed

00:02:10,200 --> 00:02:16,650
but again moving on to 2005 someone

00:02:14,849 --> 00:02:19,319
suggested possibly doing a plug-in

00:02:16,650 --> 00:02:21,530
interface just to mimic the PCI

00:02:19,319 --> 00:02:25,290
interface so it can make it easy to

00:02:21,530 --> 00:02:29,880
trivially do a device model that you

00:02:25,290 --> 00:02:32,489
know followed the standard PCI API and

00:02:29,880 --> 00:02:35,610
by the time we get to 2007 there was a G

00:02:32,489 --> 00:02:37,380
sock project called Piper mu and the

00:02:35,610 --> 00:02:41,099
idea there was you could implement

00:02:37,380 --> 00:02:43,440
machine emulations in Python but the

00:02:41,099 --> 00:02:47,220
response from the community was sorry

00:02:43,440 --> 00:02:49,890
but now so a couple of lessons that we

00:02:47,220 --> 00:02:53,910
can learn from this I mean these are all

00:02:49,890 --> 00:02:55,470
examples of hardware emulation and one

00:02:53,910 --> 00:02:58,380
thing the creamery community is very

00:02:55,470 --> 00:03:00,920
wary about anything that can be used to

00:02:58,380 --> 00:03:03,510
invade the license of the project itself

00:03:00,920 --> 00:03:04,799
there are worries about API stability

00:03:03,510 --> 00:03:05,580
because as soon as you introduce a

00:03:04,799 --> 00:03:07,890
plug-in API

00:03:05,580 --> 00:03:10,319
you know then putting some strictures on

00:03:07,890 --> 00:03:12,810
your own code and giving you no limiting

00:03:10,319 --> 00:03:14,100
what you can do in terms of refactoring

00:03:12,810 --> 00:03:15,480
and doing things internally I mean this

00:03:14,100 --> 00:03:19,230
is one of the arguments the Linux kernel

00:03:15,480 --> 00:03:20,640
has they don't have a API for modules

00:03:19,230 --> 00:03:25,459
they reserve the right to break it all

00:03:20,640 --> 00:03:29,250
the time but this is a soft problem now

00:03:25,459 --> 00:03:31,470
at least for upstream we have enable

00:03:29,250 --> 00:03:33,480
modules which allows you to build the

00:03:31,470 --> 00:03:35,340
the chrome resource tree with all your

00:03:33,480 --> 00:03:37,230
hardware emulation in modules if you

00:03:35,340 --> 00:03:39,090
want and load it up and dynamically

00:03:37,230 --> 00:03:41,850
and I think that Paolo's talk will talk

00:03:39,090 --> 00:03:43,170
about the configurability so we don't

00:03:41,850 --> 00:03:45,660
need to worry about that aspect of it

00:03:43,170 --> 00:03:50,489
now this is not the topic of the talk so

00:03:45,660 --> 00:03:53,310
let's move on this is a banyan tree so

00:03:50,489 --> 00:03:55,079
this is a type of fig that grows on

00:03:53,310 --> 00:03:58,739
other trees so it uses them as

00:03:55,079 --> 00:04:01,799
scaffolding these can get quite big the

00:03:58,739 --> 00:04:04,200
nest of roots and branches can cover a

00:04:01,799 --> 00:04:08,579
couple of acres and often they they

00:04:04,200 --> 00:04:12,090
strangle their host tree so during a

00:04:08,579 --> 00:04:14,400
patch that was suggested back in 2009

00:04:12,090 --> 00:04:15,959
someone wanted to implement instruction

00:04:14,400 --> 00:04:17,519
counting for arm it was a very invasive

00:04:15,959 --> 00:04:18,859
patch it's never going to get upstream

00:04:17,519 --> 00:04:21,670
but there was an interesting comment

00:04:18,859 --> 00:04:24,880
made during the discussion on that

00:04:21,670 --> 00:04:25,900
three users for at least three users for

00:04:24,880 --> 00:04:28,600
chromium so there's people that want

00:04:25,900 --> 00:04:30,910
fast simulation there are people that

00:04:28,600 --> 00:04:32,200
want virtualization that KVM guns and

00:04:30,910 --> 00:04:33,760
there are people that like to use

00:04:32,200 --> 00:04:37,180
chromium for instrumentation and

00:04:33,760 --> 00:04:40,270
research but these three use cases are

00:04:37,180 --> 00:04:42,100
often in conflict people are worried

00:04:40,270 --> 00:04:43,690
about adding in instrumentation

00:04:42,100 --> 00:04:44,830
infrastructure will either slow down the

00:04:43,690 --> 00:04:46,330
common case because most people just

00:04:44,830 --> 00:04:48,400
want it to run as fast as possible

00:04:46,330 --> 00:04:50,560
or you'd end up with a code base that

00:04:48,400 --> 00:04:55,360
was full of if deaths and then it

00:04:50,560 --> 00:04:57,400
becomes a maintainability nightmare but

00:04:55,360 --> 00:05:00,630
the history of crime U is replete with

00:04:57,400 --> 00:05:04,630
lots of Forks most of these come from

00:05:00,630 --> 00:05:08,410
academia so the team you project was

00:05:04,630 --> 00:05:11,170
part of Berkeley's bit blazes for doing

00:05:08,410 --> 00:05:14,830
Taine's and security analysis that was

00:05:11,170 --> 00:05:17,050
based on crime you know point 91 d-caf

00:05:14,830 --> 00:05:20,740
was an evolution of that on a slightly

00:05:17,050 --> 00:05:23,920
newer codebase PEM new was a fork of

00:05:20,740 --> 00:05:27,160
creme you that introduced the pin API so

00:05:23,920 --> 00:05:30,070
pin is a dynamic code instrumentation

00:05:27,160 --> 00:05:32,980
tool I think by Intel originally and

00:05:30,070 --> 00:05:35,650
they bought they bought this into creme

00:05:32,980 --> 00:05:37,210
you so you could run pin tests and cue

00:05:35,650 --> 00:05:38,860
trace was another approach that was more

00:05:37,210 --> 00:05:41,470
of a tracing approach that allowed you

00:05:38,860 --> 00:05:44,500
to trace the execution of in this case

00:05:41,470 --> 00:05:48,540
only x86 so the history of MU is

00:05:44,500 --> 00:05:48,540
littered with these academic Forks

00:05:48,870 --> 00:05:54,160
another example the first creamy users

00:05:52,120 --> 00:05:56,080
formed back in 2011 there are a lot of

00:05:54,160 --> 00:05:57,340
interesting talks if you want to know

00:05:56,080 --> 00:05:58,900
some of the stuff that people were doing

00:05:57,340 --> 00:06:01,090
with it there's an excellent report that

00:05:58,900 --> 00:06:03,100
Peter wrote up and they covered a wide

00:06:01,090 --> 00:06:05,350
variety of tasks but there was

00:06:03,100 --> 00:06:07,420
interesting things like doing cycle

00:06:05,350 --> 00:06:08,920
accurate simulation it's one thing that

00:06:07,420 --> 00:06:11,080
query doesn't really care about when

00:06:08,920 --> 00:06:14,620
it's emulating system is how many cycles

00:06:11,080 --> 00:06:16,030
it takes how many guest cycles it takes

00:06:14,620 --> 00:06:17,530
to do an instruction because we just

00:06:16,030 --> 00:06:18,700
want to run things as fast as possible

00:06:17,530 --> 00:06:20,830
and doing the accounting for that would

00:06:18,700 --> 00:06:23,380
be expensive but there are also people

00:06:20,830 --> 00:06:25,600
doing program instrumentation so they

00:06:23,380 --> 00:06:27,280
wanted to look at how programs ran the

00:06:25,600 --> 00:06:29,290
sort of instructions they're executing

00:06:27,280 --> 00:06:32,390
sort of code passed they were taking and

00:06:29,290 --> 00:06:35,150
also things like cache and pipeline

00:06:32,390 --> 00:06:37,040
so yeah working out what impact a

00:06:35,150 --> 00:06:39,530
program had on its cat on the cache of

00:06:37,040 --> 00:06:41,300
the system and how you could change that

00:06:39,530 --> 00:06:43,670
and of course none of these are things

00:06:41,300 --> 00:06:44,930
that really Crimea as a core project is

00:06:43,670 --> 00:06:48,160
interested in because they will get in

00:06:44,930 --> 00:06:51,910
the way of running as fast as possible

00:06:48,160 --> 00:06:54,530
I'll just mention one of the many

00:06:51,910 --> 00:06:56,660
projects that have were mentioned in

00:06:54,530 --> 00:06:58,240
that talk and that's a toss tools so

00:06:56,660 --> 00:07:00,590
this is something that

00:06:58,240 --> 00:07:02,390
stmicroelectronics developed it's still

00:07:00,590 --> 00:07:03,980
an actively developed project it's

00:07:02,390 --> 00:07:05,360
completely open-source it's an open

00:07:03,980 --> 00:07:09,430
source for you can get it from their

00:07:05,360 --> 00:07:11,900
github and it's about 700 commits

00:07:09,430 --> 00:07:16,790
difference from from the Crimea mainline

00:07:11,900 --> 00:07:19,010
they actively merge to the the current

00:07:16,790 --> 00:07:21,170
state of upstream I think their last

00:07:19,010 --> 00:07:23,420
commit was a month ago so and it can do

00:07:21,170 --> 00:07:24,620
a number of interesting things so one

00:07:23,420 --> 00:07:26,210
thing it can do is it can simulate

00:07:24,620 --> 00:07:28,250
Hardware in userspace

00:07:26,210 --> 00:07:32,060
so they use this so they can write

00:07:28,250 --> 00:07:33,680
drivers using Linux user and developing

00:07:32,060 --> 00:07:37,360
in a sort of more friendly user

00:07:33,680 --> 00:07:40,250
environment before porting it to occur

00:07:37,360 --> 00:07:42,470
another interesting tool is this one

00:07:40,250 --> 00:07:46,310
called die narrow 4 which is basically a

00:07:42,470 --> 00:07:49,600
cache simulator so you can give dynamic

00:07:46,310 --> 00:07:52,190
for information about the size of your

00:07:49,600 --> 00:07:54,860
instruction data cache and it'll track

00:07:52,190 --> 00:07:56,660
all the accesses going through it and

00:07:54,860 --> 00:07:59,000
then giving you information about your

00:07:56,660 --> 00:08:00,470
your cache residency so it's obviously

00:07:59,000 --> 00:08:02,660
very useful for them that's why they

00:08:00,470 --> 00:08:04,490
continue to maintain it one of the

00:08:02,660 --> 00:08:06,200
reasons it's probably never been

00:08:04,490 --> 00:08:09,440
suggested for upstream though is it's

00:08:06,200 --> 00:08:13,310
fairly invasive so all the tools they

00:08:09,440 --> 00:08:15,200
write directly inject TCG operations

00:08:13,310 --> 00:08:17,330
into the into the stream so if you're

00:08:15,200 --> 00:08:21,040
writing a plugin for this you have to

00:08:17,330 --> 00:08:23,450
basically understand how the TCG works

00:08:21,040 --> 00:08:24,620
so what's the conclusion we can take

00:08:23,450 --> 00:08:27,050
from all these examples well there's

00:08:24,620 --> 00:08:29,450
plenty of demand for using Chrome you

00:08:27,050 --> 00:08:31,430
for doing these sort of experiments and

00:08:29,450 --> 00:08:33,680
who can blame them Chrome U is a very

00:08:31,430 --> 00:08:35,570
flexible program it simulates a lot of

00:08:33,680 --> 00:08:37,400
different guest architectures and it's

00:08:35,570 --> 00:08:41,330
one of the faster modeling systems

00:08:37,400 --> 00:08:43,649
around and unlike things like dynamo and

00:08:41,330 --> 00:08:46,019
pin it also works with system emulations

00:08:43,649 --> 00:08:48,119
a lot of these instrumentation systems I

00:08:46,019 --> 00:08:50,759
only really work with use of programs

00:08:48,119 --> 00:08:52,769
and often you have to run on the same

00:08:50,759 --> 00:08:54,600
architecture as well so Chrome is

00:08:52,769 --> 00:08:56,670
flexible but there's a lot of these

00:08:54,600 --> 00:08:58,199
right ones for a lot of the academic

00:08:56,670 --> 00:09:00,179
ones have been written as part of their

00:08:58,199 --> 00:09:02,220
academic research so they're not

00:09:00,179 --> 00:09:04,470
particularly interested in getting stuff

00:09:02,220 --> 00:09:06,389
up streamed and you know you can

00:09:04,470 --> 00:09:08,369
understand if your your job is getting

00:09:06,389 --> 00:09:10,769
research papers out you don't have a lot

00:09:08,369 --> 00:09:13,829
of time to spend talking to upstream and

00:09:10,769 --> 00:09:15,779
molding the character to what upstream

00:09:13,829 --> 00:09:18,959
ones so we've got a lot of code that's

00:09:15,779 --> 00:09:20,999
never going to be up streamed so with

00:09:18,959 --> 00:09:25,019
that let's talk about the path to

00:09:20,999 --> 00:09:33,839
upstream for this and this is the

00:09:25,019 --> 00:09:35,610
boltons grid it's it's this regard it's

00:09:33,839 --> 00:09:38,160
one of the most dangerous rivers in

00:09:35,610 --> 00:09:40,439
Yorkshire because it looks quite easy to

00:09:38,160 --> 00:09:43,110
cross you can actually jump across it

00:09:40,439 --> 00:09:44,490
but you really want to be sure you do it

00:09:43,110 --> 00:09:46,709
right first time because it's a

00:09:44,490 --> 00:09:48,029
deceptively deep and because it's deep

00:09:46,709 --> 00:09:52,220
and fast there's a lot of underwater

00:09:48,029 --> 00:09:56,850
caves that you can get trapped in right

00:09:52,220 --> 00:09:58,980
so the path to upstream I think I'm

00:09:56,850 --> 00:10:02,970
gonna start with Louie Villanova's

00:09:58,980 --> 00:10:05,850
original work he did a lot of work to

00:10:02,970 --> 00:10:07,889
introduce support for the tracing

00:10:05,850 --> 00:10:09,800
infrastructure into TCG so he introduced

00:10:07,889 --> 00:10:12,600
the concept of being able to have

00:10:09,800 --> 00:10:15,720
generation time and execution time

00:10:12,600 --> 00:10:17,730
plugins and as part of that there was a

00:10:15,720 --> 00:10:20,069
bunch of work done to introduce a common

00:10:17,730 --> 00:10:21,389
translator loop so this isn't doesn't

00:10:20,069 --> 00:10:23,610
apply to all the guests but certainly

00:10:21,389 --> 00:10:26,429
all the main guests now use a common

00:10:23,610 --> 00:10:29,399
translator loop to minimize the number

00:10:26,429 --> 00:10:32,399
of places where you need to put put your

00:10:29,399 --> 00:10:36,929
hooks in he also did an instrumentation

00:10:32,399 --> 00:10:39,149
series but that never got merged now you

00:10:36,929 --> 00:10:40,889
can get a long way with with logging I

00:10:39,149 --> 00:10:42,990
mean this is an example of running one

00:10:40,889 --> 00:10:46,290
of our test cases it's a sha-1 test it

00:10:42,990 --> 00:10:48,449
just to show on a block of memory and

00:10:46,290 --> 00:10:51,689
those flags are done if you can see

00:10:48,449 --> 00:10:53,490
there - DCP you will dump the CPU state

00:10:51,689 --> 00:10:56,470
every time we come out of the execution

00:10:53,490 --> 00:10:58,840
loop and no chain basically ensures

00:10:56,470 --> 00:11:01,720
we come out the execution loop for every

00:10:58,840 --> 00:11:03,420
single translated block so this is great

00:11:01,720 --> 00:11:06,130
you can do a lot of analysis with this

00:11:03,420 --> 00:11:08,260
but for that simple test case that

00:11:06,130 --> 00:11:11,350
generates 19 gigabytes of logs so you

00:11:08,260 --> 00:11:13,750
need a lot of disk space and even if you

00:11:11,350 --> 00:11:15,850
compress it comes out about 344

00:11:13,750 --> 00:11:18,420
megabytes right so there's a lot of

00:11:15,850 --> 00:11:20,590
redundant information in that log and

00:11:18,420 --> 00:11:22,270
imagine the sort of logs you generate if

00:11:20,590 --> 00:11:25,150
you were running something in the kernel

00:11:22,270 --> 00:11:29,320
so you really want to be able to process

00:11:25,150 --> 00:11:32,800
this data dynamically I suggested a

00:11:29,320 --> 00:11:36,790
Series in 2018 that basically abused

00:11:32,800 --> 00:11:38,380
trace points so I I allowed you to load

00:11:36,790 --> 00:11:39,730
a plug-in and as long as a plug-in had a

00:11:38,380 --> 00:11:42,040
function that was named the same as a

00:11:39,730 --> 00:11:45,670
trace point it could hook into it and do

00:11:42,040 --> 00:11:48,160
what it wanted wanted at that point it

00:11:45,670 --> 00:11:49,870
was an interesting experiment it didn't

00:11:48,160 --> 00:11:52,300
really go down particularly well with

00:11:49,870 --> 00:11:55,210
with the other developers mainly because

00:11:52,300 --> 00:11:56,980
it introduced a very wide API and so it

00:11:55,210 --> 00:11:58,690
was all very well saying hook into the

00:11:56,980 --> 00:12:00,490
trace points but trace points can change

00:11:58,690 --> 00:12:02,740
so you don't really have any sort of API

00:12:00,490 --> 00:12:05,410
stability and the trace points are quite

00:12:02,740 --> 00:12:07,630
wide and varied so it gives us your

00:12:05,410 --> 00:12:13,270
digging quite deep into the internals of

00:12:07,630 --> 00:12:15,370
how Crimea runs Pavel did a series so

00:12:13,270 --> 00:12:18,520
this was a iteration at the ISP grass

00:12:15,370 --> 00:12:21,220
plug industry which they they had for

00:12:18,520 --> 00:12:24,730
their research I didn't rest introduce

00:12:21,220 --> 00:12:27,520
the idea of having a needs filter so a

00:12:24,730 --> 00:12:29,170
plugin could have a needs function which

00:12:27,520 --> 00:12:32,770
would get called and it would say yes no

00:12:29,170 --> 00:12:35,890
and then it would hook in the helper

00:12:32,770 --> 00:12:39,310
function so directly call a helper in in

00:12:35,890 --> 00:12:42,370
the plugin he presented like these ideas

00:12:39,310 --> 00:12:48,490
back in 2017 and the RFC

00:12:42,370 --> 00:12:52,360
in 2018 and then the next iteration was

00:12:48,490 --> 00:12:54,300
Amelia kata he did a series similar sort

00:12:52,360 --> 00:12:57,280
of approach but he was using it for

00:12:54,300 --> 00:13:00,010
doing his work into parallel computer

00:12:57,280 --> 00:13:02,200
simulation so it supported direct

00:13:00,010 --> 00:13:04,780
helpers again direct out of the TCG code

00:13:02,200 --> 00:13:08,350
as well as inline operations which are

00:13:04,780 --> 00:13:09,830
useful for doing some quick and low-cost

00:13:08,350 --> 00:13:12,220
counting

00:13:09,830 --> 00:13:14,390
you could do instruction granularity

00:13:12,220 --> 00:13:16,370
instrumentation I think one of the

00:13:14,390 --> 00:13:17,720
limitations of the original approach is

00:13:16,370 --> 00:13:20,630
it needed a two pass

00:13:17,720 --> 00:13:23,030
translation so that required a bit of

00:13:20,630 --> 00:13:26,120
tweaking to the translator to support

00:13:23,030 --> 00:13:29,000
that he also had support for doing time

00:13:26,120 --> 00:13:31,880
control because he wanted to make sure

00:13:29,000 --> 00:13:33,440
that the time and simulation was that

00:13:31,880 --> 00:13:36,770
was reported to the guest was actually

00:13:33,440 --> 00:13:38,690
what a guest would see rather than the

00:13:36,770 --> 00:13:41,390
effectively the the the elapsed time

00:13:38,690 --> 00:13:43,300
I'll talk about that later and he also

00:13:41,390 --> 00:13:45,890
had some guest hook so a guest could

00:13:43,300 --> 00:13:48,850
indicate the plug in interesting areas

00:13:45,890 --> 00:13:51,470
of memory that it might want to look at

00:13:48,850 --> 00:13:53,420
so what have we learnt from these

00:13:51,470 --> 00:13:58,640
approaches well the first thing ap eyes

00:13:53,420 --> 00:14:00,560
are hard people want to get a API define

00:13:58,640 --> 00:14:02,360
that's not going to limit your further

00:14:00,560 --> 00:14:07,910
development and not leak too many

00:14:02,360 --> 00:14:10,400
internals is tricky so let's talk about

00:14:07,910 --> 00:14:13,640
the actual implementation that we've got

00:14:10,400 --> 00:14:18,350
now I assume everyone knows what Lego is

00:14:13,640 --> 00:14:19,490
right so the design principles of the

00:14:18,350 --> 00:14:23,330
current plug interface

00:14:19,490 --> 00:14:24,860
low impact so the idea is that it's in

00:14:23,330 --> 00:14:27,160
the minimal case when you're not

00:14:24,860 --> 00:14:29,810
actually doing any instrumentation it's

00:14:27,160 --> 00:14:31,820
barely measurable you can also disable

00:14:29,810 --> 00:14:32,750
it from the build if you want to get rid

00:14:31,820 --> 00:14:34,730
of it all but if you're not actually

00:14:32,750 --> 00:14:38,600
subscribing to any events it's pretty

00:14:34,730 --> 00:14:41,180
low cost it has a very simple non leaky

00:14:38,600 --> 00:14:44,000
API so everything that the plug-in gets

00:14:41,180 --> 00:14:47,420
is in the way of opaque handles which it

00:14:44,000 --> 00:14:50,270
can query bits of information about but

00:14:47,420 --> 00:14:51,680
most importantly for this iteration no

00:14:50,270 --> 00:14:53,300
state modification as well so the

00:14:51,680 --> 00:14:55,550
plugins can't be used to circumnavigate

00:14:53,300 --> 00:14:58,400
any GPL requirements they're purely

00:14:55,550 --> 00:15:00,680
passive monitors of the system so this

00:14:58,400 --> 00:15:03,410
is very much a minimal minimal Viable

00:15:00,680 --> 00:15:06,800
plugin implementation which we can build

00:15:03,410 --> 00:15:09,080
on in future so I'll just quickly run

00:15:06,800 --> 00:15:11,600
through there how it works so we've had

00:15:09,080 --> 00:15:12,830
the normal run loop we we need to do a

00:15:11,600 --> 00:15:15,110
translation if we don't have a

00:15:12,830 --> 00:15:15,810
translation we generate one we insert it

00:15:15,110 --> 00:15:18,990
in our code but

00:15:15,810 --> 00:15:20,790
and then we run it so the way TCG works

00:15:18,990 --> 00:15:24,899
as it works with these things called TCG

00:15:20,790 --> 00:15:26,999
ups so a single arm instruction at 122

00:15:24,899 --> 00:15:29,459
the stack pointer breaks down into a

00:15:26,999 --> 00:15:32,490
number of TCG operations which we can

00:15:29,459 --> 00:15:35,040
then use the code generation so in that

00:15:32,490 --> 00:15:38,040
past for each instruction what we do is

00:15:35,040 --> 00:15:41,639
we add a dummy TCG call at the beginning

00:15:38,040 --> 00:15:43,170
and end of each instruction once we've

00:15:41,639 --> 00:15:45,329
gone through the block we then give the

00:15:43,170 --> 00:15:48,029
plug-in an opportunity to decide which

00:15:45,329 --> 00:15:49,889
events it wants to subscribe to the

00:15:48,029 --> 00:15:51,930
event it doesn't subscribe to we can

00:15:49,889 --> 00:15:54,689
just get dropped those TCG operations

00:15:51,930 --> 00:15:56,730
they won't ever get generated and the

00:15:54,689 --> 00:15:59,910
ones that does want to subscribe to we

00:15:56,730 --> 00:16:01,850
replace those dummy TCG operations with

00:15:59,910 --> 00:16:04,470
real TCG operations to call the helper

00:16:01,850 --> 00:16:06,120
this is the optimization phase and

00:16:04,470 --> 00:16:08,730
there's a chance for the TCG to and

00:16:06,120 --> 00:16:12,029
slightly improve the code and then we

00:16:08,730 --> 00:16:16,230
generate our host code so the plug-in

00:16:12,029 --> 00:16:18,660
API a couple of rules plugins have to be

00:16:16,230 --> 00:16:20,699
threading aware TCG for a long time has

00:16:18,660 --> 00:16:22,199
been multi-threaded we don't do any

00:16:20,699 --> 00:16:24,569
hand-holding for you so if the plug-in

00:16:22,199 --> 00:16:28,350
has shared data structures it needs to

00:16:24,569 --> 00:16:30,089
deal with its own locking the opaque

00:16:28,350 --> 00:16:32,309
handles I've already mentioned these are

00:16:30,089 --> 00:16:34,769
only valid during the callback so any

00:16:32,309 --> 00:16:36,959
information you want to get out you need

00:16:34,769 --> 00:16:40,740
to copy into your own structures so you

00:16:36,959 --> 00:16:42,870
need to do your own housekeeping so all

00:16:40,740 --> 00:16:45,689
plugins will have at least one function

00:16:42,870 --> 00:16:48,269
this chrome you plug-in install and

00:16:45,689 --> 00:16:50,399
guess a few bits of information it gets

00:16:48,269 --> 00:16:53,459
a unique ID you can have as many plugins

00:16:50,399 --> 00:16:55,439
running at a time it gets a little info

00:16:53,459 --> 00:16:57,149
block which tells it a minimal amount of

00:16:55,439 --> 00:16:58,740
information about the system broadly

00:16:57,149 --> 00:17:01,529
it's the architecture you're running on

00:16:58,740 --> 00:17:03,870
and some arguments you can pass

00:17:01,529 --> 00:17:05,370
arguments you plug in it'll then set up

00:17:03,870 --> 00:17:07,199
its bits and they'll be probably at

00:17:05,370 --> 00:17:09,209
least two callbacks it will want to

00:17:07,199 --> 00:17:11,760
register or want to register to the

00:17:09,209 --> 00:17:13,260
translation callback which is the

00:17:11,760 --> 00:17:16,199
jumping-off point for doing additional

00:17:13,260 --> 00:17:19,799
instrumentation and the at exit callback

00:17:16,199 --> 00:17:23,069
so when you get to the end of your run

00:17:19,799 --> 00:17:24,090
you can dump information out so in the

00:17:23,069 --> 00:17:25,950
block

00:17:24,090 --> 00:17:28,410
this is a translation block here it's

00:17:25,950 --> 00:17:30,720
just doing a simple instrumentation of

00:17:28,410 --> 00:17:32,040
each each translation block so at the

00:17:30,720 --> 00:17:34,710
start of the translation block you can

00:17:32,040 --> 00:17:35,850
either jump to a callback or we do

00:17:34,710 --> 00:17:37,680
support this thing called an inline

00:17:35,850 --> 00:17:39,690
operation there's only one inline of

00:17:37,680 --> 00:17:42,150
operation supported at the moment and

00:17:39,690 --> 00:17:45,840
that's the ability to add a 64-bit

00:17:42,150 --> 00:17:47,880
number to a counter somewhere but if

00:17:45,840 --> 00:17:49,200
you're just doing raw counts and you've

00:17:47,880 --> 00:17:53,940
got a single-threaded program that's the

00:17:49,200 --> 00:17:55,290
simplest way to do it a couple of pieces

00:17:53,940 --> 00:17:56,760
of information it can find out the

00:17:55,290 --> 00:18:01,800
program counter that starts the block

00:17:56,760 --> 00:18:03,540
and the number of instructions so if you

00:18:01,800 --> 00:18:05,790
want to instrument the individual

00:18:03,540 --> 00:18:07,860
instructions you can also get a list of

00:18:05,790 --> 00:18:09,960
these instructions again these opaque

00:18:07,860 --> 00:18:11,910
pointers but for each instruction you

00:18:09,960 --> 00:18:13,290
can then make a decision about whether

00:18:11,910 --> 00:18:15,480
or not you want to have a callback

00:18:13,290 --> 00:18:17,730
before it runs or maybe just increment a

00:18:15,480 --> 00:18:19,860
counter so there's a couple of helpers

00:18:17,730 --> 00:18:21,360
that you get for that the instruction

00:18:19,860 --> 00:18:22,950
data so this doesn't give you a peek

00:18:21,360 --> 00:18:26,400
directly into memory it's just a copy

00:18:22,950 --> 00:18:28,220
readable buffer of the decoded

00:18:26,400 --> 00:18:30,540
instruction the size of the instruction

00:18:28,220 --> 00:18:33,330
virtual address and hardware address and

00:18:30,540 --> 00:18:36,390
you can we've also added the ability to

00:18:33,330 --> 00:18:38,190
call chrome use disassembler because we

00:18:36,390 --> 00:18:40,350
don't really want plug-ins to have to

00:18:38,190 --> 00:18:43,650
ship an entire disassembler themselves

00:18:40,350 --> 00:18:45,660
when chrome you can already do it for

00:18:43,650 --> 00:18:47,400
memory accesses much the same sort of

00:18:45,660 --> 00:18:50,010
pattern go through each instruction and

00:18:47,400 --> 00:18:51,660
register a memory call back it doesn't

00:18:50,010 --> 00:18:54,060
matter if the instruction you're

00:18:51,660 --> 00:18:56,340
registering doesn't do any memory

00:18:54,060 --> 00:18:58,140
accesses in those cases those callbacks

00:18:56,340 --> 00:19:00,930
will never to get get generated and

00:18:58,140 --> 00:19:03,690
you'll never get caught so basically you

00:19:00,930 --> 00:19:05,010
just instrument all the ones that you

00:19:03,690 --> 00:19:07,260
want you could always look at the

00:19:05,010 --> 00:19:08,310
instructions if you wanted and then in

00:19:07,260 --> 00:19:10,350
the memory callback

00:19:08,310 --> 00:19:13,650
you'll get another bit of information so

00:19:10,350 --> 00:19:16,920
you'll get the CPU that the access was

00:19:13,650 --> 00:19:18,300
on as an index and then another opaque

00:19:16,920 --> 00:19:21,030
data structure which you can query in

00:19:18,300 --> 00:19:22,890
the virtual address so there's a couple

00:19:21,030 --> 00:19:24,560
of helpers so importantly at the moment

00:19:22,890 --> 00:19:27,570
you don't actually get access to the

00:19:24,560 --> 00:19:29,400
data itself and this is certainly

00:19:27,570 --> 00:19:31,890
something we can look in for for version

00:19:29,400 --> 00:19:33,630
two but at the moment you get the size

00:19:31,890 --> 00:19:35,250
of the access whether it's sign extended

00:19:33,630 --> 00:19:38,130
is it a big endian

00:19:35,250 --> 00:19:39,390
little endian as later restore and with

00:19:38,130 --> 00:19:44,760
that you can actually do quite a lot of

00:19:39,390 --> 00:19:46,740
interesting experiments already for

00:19:44,760 --> 00:19:48,450
system emulation you can also take that

00:19:46,740 --> 00:19:50,820
virtual address and then find out where

00:19:48,450 --> 00:19:53,940
it maps to so it will tell you whether

00:19:50,820 --> 00:19:56,100
it's an i/o access or not and then give

00:19:53,940 --> 00:19:58,020
you the offset into the device so if

00:19:56,100 --> 00:19:59,430
that device happens to be round that

00:19:58,020 --> 00:20:03,810
will just be the offset into your into

00:19:59,430 --> 00:20:07,800
your RAM block couple of other api's

00:20:03,810 --> 00:20:09,690
just to mention there's a quite new

00:20:07,800 --> 00:20:11,580
plug-in out string which just allows the

00:20:09,690 --> 00:20:15,060
plugins to output its information via

00:20:11,580 --> 00:20:17,160
Chrome use debug output so this is just

00:20:15,060 --> 00:20:18,510
better than plug-in spamming standard

00:20:17,160 --> 00:20:22,380
out or standard error with their data

00:20:18,510 --> 00:20:25,080
you can redirect it plug-in reset and

00:20:22,380 --> 00:20:27,840
uninstalled so plugins can optionally

00:20:25,080 --> 00:20:29,460
uninstall themselves at any point so it

00:20:27,840 --> 00:20:32,280
might be that a plug-in has collected

00:20:29,460 --> 00:20:35,300
enough data you can then unregister

00:20:32,280 --> 00:20:38,190
itself will flush all the translations

00:20:35,300 --> 00:20:41,610
and then we'll get there and then you

00:20:38,190 --> 00:20:43,770
can flush all of the translations and

00:20:41,610 --> 00:20:46,010
then you can just wait until the end and

00:20:43,770 --> 00:20:49,020
done the information inflected syscall

00:20:46,010 --> 00:20:51,600
returned for new space and vcp for when

00:20:49,020 --> 00:20:53,820
beach views come in and out so just the

00:20:51,600 --> 00:20:57,540
very last few slides there's a bunch of

00:20:53,820 --> 00:20:59,490
example plugins we've got basic blocks

00:20:57,540 --> 00:21:02,280
instruction counters memory counts and

00:20:59,490 --> 00:21:06,090
then we've hot ones hot blocks allow you

00:21:02,280 --> 00:21:08,220
to measure execution residency hot pages

00:21:06,090 --> 00:21:10,650
you can look at what pages are seeing

00:21:08,220 --> 00:21:12,860
most route and writes and power vac is

00:21:10,650 --> 00:21:16,200
basically an instruction classifier

00:21:12,860 --> 00:21:17,880
future work do we want to access more

00:21:16,200 --> 00:21:19,620
system states at the moment we don't

00:21:17,880 --> 00:21:22,680
access allowed the plugins to access

00:21:19,620 --> 00:21:24,660
system memory we'd also like to access

00:21:22,680 --> 00:21:26,670
registers the trick there is coming up

00:21:24,660 --> 00:21:28,080
with a decent API that's going to be

00:21:26,670 --> 00:21:30,060
nice and generally enough and doesn't

00:21:28,080 --> 00:21:32,460
expose any internal so I think previous

00:21:30,060 --> 00:21:35,750
api's have used things like gdb stub

00:21:32,460 --> 00:21:39,470
register IDs but it's a bit messy

00:21:35,750 --> 00:21:41,760
finally we expect you to be able to use

00:21:39,470 --> 00:21:43,500
use this for developers will be useful

00:21:41,760 --> 00:21:45,060
as well for developers as well so one

00:21:43,500 --> 00:21:48,299
tool that I'd like to write in next

00:21:45,060 --> 00:21:50,489
cycle is a lot step execution

00:21:48,299 --> 00:21:52,379
a TCG developing spend a lot of time

00:21:50,489 --> 00:21:53,639
looking at instruction phrases you spend

00:21:52,379 --> 00:21:56,159
a lot of time trying to work out what

00:21:53,639 --> 00:21:57,839
you broke why the program worked on a

00:21:56,159 --> 00:21:59,789
previous one version and doesn't work on

00:21:57,839 --> 00:22:00,779
another version and you end up doing

00:21:59,789 --> 00:22:03,629
lots of diff

00:22:00,779 --> 00:22:05,309
trace files so with a plug-in it's

00:22:03,629 --> 00:22:06,929
actually be quite trivial just to make

00:22:05,309 --> 00:22:09,889
something that allowed to creamy

00:22:06,929 --> 00:22:13,589
processes to run in in lockstep I

00:22:09,889 --> 00:22:17,729
briefly mentioned time time at the

00:22:13,589 --> 00:22:19,469
moment is a function of the time on the

00:22:17,729 --> 00:22:21,919
host so it means the emulation overhead

00:22:19,469 --> 00:22:24,119
is visible so if you're doing

00:22:21,919 --> 00:22:26,159
experiments that you're trying to look

00:22:24,119 --> 00:22:28,200
at what a real behavior of a real system

00:22:26,159 --> 00:22:30,389
would be you'll find that you know in

00:22:28,200 --> 00:22:32,309
timer interrupts are occurring more

00:22:30,389 --> 00:22:34,559
frequently than you would on a real

00:22:32,309 --> 00:22:36,929
system now we do have a solution for

00:22:34,559 --> 00:22:38,940
this it's called I count but I counts

00:22:36,929 --> 00:22:41,820
not multi-threaded and even then I count

00:22:38,940 --> 00:22:42,899
really as just pegging the amount of

00:22:41,820 --> 00:22:45,599
elapsed time to the number of

00:22:42,899 --> 00:22:49,739
instructions you've executed so if you

00:22:45,599 --> 00:22:51,839
wanted to do real simulation may be the

00:22:49,739 --> 00:22:53,609
option there is to expose that to the

00:22:51,839 --> 00:22:55,619
plugins or even allow the plugins to

00:22:53,609 --> 00:22:57,029
control the passage of time because then

00:22:55,619 --> 00:22:59,219
the plugins can take the time to work

00:22:57,029 --> 00:22:59,749
out exactly how many cycles will have

00:22:59,219 --> 00:23:02,690
passed

00:22:59,749 --> 00:23:05,849
so in summary it's been a long journey

00:23:02,690 --> 00:23:08,639
but we now have a common non-invasive

00:23:05,849 --> 00:23:11,369
interface which is very efficient in the

00:23:08,639 --> 00:23:13,289
null case and is right for expansion I

00:23:11,369 --> 00:23:15,209
don't think this is going to lead to the

00:23:13,289 --> 00:23:17,879
end of all these outer tree Forks but

00:23:15,209 --> 00:23:19,709
I'm hoping now going forward that any

00:23:17,879 --> 00:23:22,409
outer tree Forks will be building on a

00:23:19,709 --> 00:23:26,070
on a common base so their dips will be

00:23:22,409 --> 00:23:32,399
smaller all right sorry for the speed of

00:23:26,070 --> 00:23:35,329
that any questions so we have time for

00:23:32,399 --> 00:23:35,329
one of the questions

00:23:41,880 --> 00:23:49,300
you mentioned in Korean out are three

00:23:44,980 --> 00:23:49,990
plugins so entry it's obvious but out of

00:23:49,300 --> 00:23:52,270
three

00:23:49,990 --> 00:23:54,310
I guess the interface is not stable so

00:23:52,270 --> 00:23:55,180
you're tying yourself to a specific GMO

00:23:54,310 --> 00:23:57,610
version to you

00:23:55,180 --> 00:23:59,920
yeah may other I think with what I don't

00:23:57,610 --> 00:24:02,500
think we're planning to keep changing

00:23:59,920 --> 00:24:05,020
the API interface just just for the hell

00:24:02,500 --> 00:24:07,720
of it it's it's it's fairly simple and

00:24:05,020 --> 00:24:10,450
generally enough but yeah if you if you

00:24:07,720 --> 00:24:14,160
want it to always work I would suggest

00:24:10,450 --> 00:24:16,510
to get it get the plug-in entry but

00:24:14,160 --> 00:24:18,910
there will certainly be academics that

00:24:16,510 --> 00:24:21,130
want to be doing more detailed more

00:24:18,910 --> 00:24:22,420
invasive plugins that maybe want to

00:24:21,130 --> 00:24:25,330
expose more information than we're

00:24:22,420 --> 00:24:27,160
comfortable in the upstream I'm just

00:24:25,330 --> 00:24:29,920
hoping that there DIF will be a minimal

00:24:27,160 --> 00:24:32,740
diff to support that with a common code

00:24:29,920 --> 00:24:35,430
base with basically injecting the

00:24:32,740 --> 00:24:35,430
instrumentation

00:24:38,000 --> 00:24:48,699
[Applause]

00:24:41,440 --> 00:24:48,699

YouTube URL: https://www.youtube.com/watch?v=wxIF0dvGDuM


