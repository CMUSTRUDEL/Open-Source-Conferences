Title: [2019] VirtIO without the Virt - Towards Implementations in Hardware by Michael Tsirkin
Publication date: 2019-11-07
Playlist: KVM Forum 2019
Description: 
	VirtIO was designed to standardize hypervisor interfaces for virtual machines - but we are beginning to see the emergence of Virtio hardware. This talk will answer the questions: why does this make sense, what works and what are the issues hardware implementations of virtio have to overcome?
Topics to be covered:

- What is the difference between hardware virtio devices and virtio data path accelerators?
- What are the minimal requirements of virtio in hardware?
- How can we handle compatibility, including hardware bugs and limitations?
- How to make live migration work? What about overcommit?
- Which changes included in the recent virtio specification help design hardware virtio devices?
- Which known issues remain and how does the Virtio committee plat to address them?
- Why design Virtio in hardware? Are there alternatives?
- Why get involved with the Virtio specification process?

---

Michael S. Tsirkin
Red Hat
Distinguished Engineer

Michael has been with Red Hat for more than 10 years. In his role as a Distinguished Engineer he acts as a chair of the Virtio Technical Committee, overseeing the development of the virtio specification for virtual devices. He also maintains several subsystems in QEMU and Linux and has over the years made multiple contributions to QEMU, Linux and KVM.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,740 --> 00:00:12,870
hi I'm Michael silken welcome to my talk

00:00:09,660 --> 00:00:16,379
I work at Red Hat distinguished engineer

00:00:12,870 --> 00:00:17,520
and the chair of the VA OTC and today

00:00:16,379 --> 00:00:20,160
I'm going to talk about hard

00:00:17,520 --> 00:00:21,840
implementations of your tayo I'm gonna

00:00:20,160 --> 00:00:25,199
describe some interesting challenges

00:00:21,840 --> 00:00:27,510
some best practices and answer some

00:00:25,199 --> 00:00:30,240
frequently asked questions and hopefully

00:00:27,510 --> 00:00:32,219
it's gonna be an interesting study about

00:00:30,240 --> 00:00:34,410
building hardware interfaces software

00:00:32,219 --> 00:00:36,420
interfaces and what happens when you try

00:00:34,410 --> 00:00:40,110
to bring hardware and software and the

00:00:36,420 --> 00:00:43,920
single umbrella just a bit of history I

00:00:40,110 --> 00:00:45,300
think 2012 was the first year when we

00:00:43,920 --> 00:00:47,280
heard the hard implementation of your

00:00:45,300 --> 00:00:49,530
tyonne which was originally designed for

00:00:47,280 --> 00:00:50,850
software for hypervisors and we started

00:00:49,530 --> 00:00:54,570
using that for kernel user space

00:00:50,850 --> 00:00:56,489
interactions with interactions and rasty

00:00:54,570 --> 00:00:59,129
Russell was one of the authors of your

00:00:56,489 --> 00:01:03,840
teo so it's really a random event that

00:00:59,129 --> 00:01:06,119
very cool and then 2017 internet started

00:01:03,840 --> 00:01:08,220
talking about beauty accelerators and

00:01:06,119 --> 00:01:11,580
hardware and now we have lots of people

00:01:08,220 --> 00:01:14,220
doing that so today one of the reasons

00:01:11,580 --> 00:01:16,290
people are doing that is really in

00:01:14,220 --> 00:01:18,900
network effects you have tons of

00:01:16,290 --> 00:01:23,340
software already supporting we're tile

00:01:18,900 --> 00:01:26,310
you have windows drivers Linux drivers

00:01:23,340 --> 00:01:29,189
SP decay dip decay all kinds of firmware

00:01:26,310 --> 00:01:33,180
drivers for all kinds of devices like

00:01:29,189 --> 00:01:35,610
scuzzy network in serial and so if you

00:01:33,180 --> 00:01:39,270
build the device using your tile you get

00:01:35,610 --> 00:01:41,780
to leverage some of this infrastructure

00:01:39,270 --> 00:01:45,210
you don't have to write it from scratch

00:01:41,780 --> 00:01:47,880
that's definitely part of the answer and

00:01:45,210 --> 00:01:51,270
how much you can reuse what kind of

00:01:47,880 --> 00:01:53,430
depend and what kind of device you are

00:01:51,270 --> 00:01:55,229
building but there's just so much out

00:01:53,430 --> 00:01:57,540
there that there is a good chance you

00:01:55,229 --> 00:02:02,009
can leverage it a nice chunk of software

00:01:57,540 --> 00:02:05,210
and don't have to be rated and a large

00:02:02,009 --> 00:02:09,360
part of this has been there for years

00:02:05,210 --> 00:02:11,940
since 2000 really since retire was

00:02:09,360 --> 00:02:13,800
originally introduced and so it's also

00:02:11,940 --> 00:02:16,110
widely deployed so he had a he

00:02:13,800 --> 00:02:19,110
you use bass but that's good so

00:02:16,110 --> 00:02:24,330
standards are good generally but I think

00:02:19,110 --> 00:02:26,340
it's not just that so there's there are

00:02:24,330 --> 00:02:28,470
more reasons in most situations where

00:02:26,340 --> 00:02:31,830
you gain by using bataillon

00:02:28,470 --> 00:02:34,770
in hardware so your space drivers is one

00:02:31,830 --> 00:02:38,070
example and people write it like in rest

00:02:34,770 --> 00:02:41,340
compiled statically or just just linked

00:02:38,070 --> 00:02:43,470
with library and and you deploy and it

00:02:41,340 --> 00:02:46,830
works but then it becomes a challenge to

00:02:43,470 --> 00:02:49,080
upgrade your application any kind of new

00:02:46,830 --> 00:02:51,660
hardware you really need to update at

00:02:49,080 --> 00:02:58,500
least the library and likely also the

00:02:51,660 --> 00:03:00,630
application itself and also Keanu really

00:02:58,500 --> 00:03:05,040
has no visibility into the state of this

00:03:00,630 --> 00:03:07,170
device so normal things that you can

00:03:05,040 --> 00:03:09,270
usually do with user space like snapshot

00:03:07,170 --> 00:03:12,270
and restore also doesn't work don't work

00:03:09,270 --> 00:03:14,510
because there's no no way to save the

00:03:12,270 --> 00:03:19,650
state to be able in the restore it later

00:03:14,510 --> 00:03:21,420
and if you have a standard interface

00:03:19,650 --> 00:03:23,459
that solves it you can have like a

00:03:21,420 --> 00:03:27,810
generic driver that can save restore

00:03:23,459 --> 00:03:30,180
state and you can switch between two

00:03:27,810 --> 00:03:32,040
different hardware cards both of them I

00:03:30,180 --> 00:03:33,810
using standard vida you are and the

00:03:32,040 --> 00:03:37,860
application uses via tie alright so we

00:03:33,810 --> 00:03:41,520
could get upgrade without any need to

00:03:37,860 --> 00:03:44,150
update your software virtual machine

00:03:41,520 --> 00:03:47,130
guess it's kind of the same really

00:03:44,150 --> 00:03:50,430
so people are using pass rule for

00:03:47,130 --> 00:03:54,450
performance so guess get access to the

00:03:50,430 --> 00:03:56,250
hardware directly and but if you do

00:03:54,450 --> 00:04:00,330
hardware right now you really cannot

00:03:56,250 --> 00:04:03,600
move your VMs or yes between VMs running

00:04:00,330 --> 00:04:06,390
on two different costs unless you take

00:04:03,600 --> 00:04:07,290
great pains to make them look exactly

00:04:06,390 --> 00:04:11,760
the same

00:04:07,290 --> 00:04:14,250
and that that's really challenging so if

00:04:11,760 --> 00:04:16,049
if you have a standard interface you can

00:04:14,250 --> 00:04:18,060
standardize on that and hopefully then

00:04:16,049 --> 00:04:19,500
you can move your VMs between hosts and

00:04:18,060 --> 00:04:23,760
I'm going to talk about this a little

00:04:19,500 --> 00:04:26,370
bit more and also again we have the

00:04:23,760 --> 00:04:27,540
standard interface so hypervisor can

00:04:26,370 --> 00:04:30,900
figure out what's going on you

00:04:27,540 --> 00:04:32,250
harder and then it can inspect it for

00:04:30,900 --> 00:04:40,080
debugging it can inspect it for

00:04:32,250 --> 00:04:42,090
migration so usually if you are doing

00:04:40,080 --> 00:04:45,210
things like like pass through direct

00:04:42,090 --> 00:04:47,340
access to hardware then that breaks lots

00:04:45,210 --> 00:04:50,250
of things we like to do with software

00:04:47,340 --> 00:04:54,300
like overcome it and and swap in

00:04:50,250 --> 00:04:55,920
whatever and it's great that if you have

00:04:54,300 --> 00:04:58,140
a standard interface you can kind of

00:04:55,920 --> 00:05:01,890
switch between software and hardware

00:04:58,140 --> 00:05:04,050
limitations so you cannot exactly have

00:05:01,890 --> 00:05:06,090
the boss of both worlds but you can at

00:05:04,050 --> 00:05:09,030
least dynamically adjust and you don't

00:05:06,090 --> 00:05:11,280
have to have downtime for that so you

00:05:09,030 --> 00:05:12,600
you can switch between for example a

00:05:11,280 --> 00:05:14,130
hardware implementation of your Tahoe

00:05:12,600 --> 00:05:21,530
and the software patient will tell you

00:05:14,130 --> 00:05:27,080
that's the thinking goes oh bugs happen

00:05:21,530 --> 00:05:30,000
and if you have a spec and we are taking

00:05:27,080 --> 00:05:32,760
pains and working on it a lot to try and

00:05:30,000 --> 00:05:36,900
make it as specific as we can then we

00:05:32,760 --> 00:05:39,810
can figure out who's to blame unlike

00:05:36,900 --> 00:05:43,110
like I've been in the shoes of a driver

00:05:39,810 --> 00:05:44,460
developer and hardware guys always ship

00:05:43,110 --> 00:05:45,840
to blame to software guys and we

00:05:44,460 --> 00:05:48,090
software guys ship to blame to the

00:05:45,840 --> 00:05:50,100
hardware guys so at least here you can

00:05:48,090 --> 00:05:53,870
figure out the rate so one of the guys

00:05:50,100 --> 00:05:57,180
is violating the spec there are also

00:05:53,870 --> 00:05:59,340
it's also a debugging ed so you can swap

00:05:57,180 --> 00:06:01,590
in a different hardware device that

00:05:59,340 --> 00:06:02,970
adheres to the same interface you can

00:06:01,590 --> 00:06:04,590
possibly swap in a software

00:06:02,970 --> 00:06:08,850
implementation and then we say all right

00:06:04,590 --> 00:06:10,520
I cards and it starts working it's a big

00:06:08,850 --> 00:06:16,880
hint that the problem is in the card

00:06:10,520 --> 00:06:19,800
that's nice and we are also like

00:06:16,880 --> 00:06:21,410
generally trying to fix it in the right

00:06:19,800 --> 00:06:24,780
place

00:06:21,410 --> 00:06:26,340
because any any deviation from spec we

00:06:24,780 --> 00:06:28,260
can see all right the bug isn't

00:06:26,340 --> 00:06:28,950
hypervisor let's just fix it in the

00:06:28,260 --> 00:06:32,120
hypervisor

00:06:28,950 --> 00:06:35,790
so we don't procreate facts the way

00:06:32,120 --> 00:06:39,740
people kind of used to do with ad hoc

00:06:35,790 --> 00:06:39,740
and non-specified interfaces

00:06:41,069 --> 00:06:45,729
then there are some nice properties of

00:06:44,110 --> 00:06:48,190
via tell you I think that actually make

00:06:45,729 --> 00:06:52,569
it as reactive as a hardware software

00:06:48,190 --> 00:06:54,310
interface some of this is our strong

00:06:52,569 --> 00:06:56,319
focus and forward compatibility and

00:06:54,310 --> 00:06:59,740
backward compatibility I'm going to talk

00:06:56,319 --> 00:07:01,360
about this a little bit but generally

00:06:59,740 --> 00:07:05,650
it's attractive right because upgrading

00:07:01,360 --> 00:07:08,680
hardware is is hard then there is use of

00:07:05,650 --> 00:07:12,810
PCI for discovery that's nice because

00:07:08,680 --> 00:07:16,180
lots of people use PCI in the hardware

00:07:12,810 --> 00:07:18,460
our notification mechanism is optimized

00:07:16,180 --> 00:07:22,810
and happens to be efficient for hardware

00:07:18,460 --> 00:07:25,210
as well and then it's also good that we

00:07:22,810 --> 00:07:27,849
have a good specification process in

00:07:25,210 --> 00:07:31,479
place so I'm going to drill down into

00:07:27,849 --> 00:07:33,370
all these things this is this is how

00:07:31,479 --> 00:07:36,159
wilt io tries to achieve compatibility

00:07:33,370 --> 00:07:37,720
generally through feature beads so the

00:07:36,159 --> 00:07:40,479
two of these there's driver features

00:07:37,720 --> 00:07:43,389
there is device features you end these

00:07:40,479 --> 00:07:47,139
guys and both device and Driver did get

00:07:43,389 --> 00:07:49,570
the result and this means that we put

00:07:47,139 --> 00:07:51,520
out a new spec revision and that adds a

00:07:49,570 --> 00:07:53,139
bunch of features there is no like

00:07:51,520 --> 00:07:56,050
version that you increment and you have

00:07:53,139 --> 00:07:58,960
to implement lots of stuff you can

00:07:56,050 --> 00:08:03,360
cherry-pick specific features so that

00:07:58,960 --> 00:08:03,360
that makes for great compatibility story

00:08:04,500 --> 00:08:12,219
now let me talk about the discover

00:08:06,849 --> 00:08:14,830
little bit so this is just LS PCI I ran

00:08:12,219 --> 00:08:18,099
it with an IBM and it shows a bunch of

00:08:14,830 --> 00:08:21,150
PCI devices and among them you can see

00:08:18,099 --> 00:08:25,150
the entire device so record donated

00:08:21,150 --> 00:08:27,069
specific vendor ID device ID a bunch of

00:08:25,150 --> 00:08:29,169
these peers to the eight-hour

00:08:27,069 --> 00:08:31,870
specification and then you build

00:08:29,169 --> 00:08:34,270
hardware that exposes this pair of ideas

00:08:31,870 --> 00:08:39,899
and then existing drivers bind to it

00:08:34,270 --> 00:08:44,079
don't that that's great well what else

00:08:39,899 --> 00:08:47,290
driver binds what happens next it has to

00:08:44,079 --> 00:08:49,959
also work so the all the communication

00:08:47,290 --> 00:08:51,850
is also pci based so this is again this

00:08:49,959 --> 00:08:52,900
is a dump of the PCIe configuration

00:08:51,850 --> 00:08:54,580
space

00:08:52,900 --> 00:08:57,040
device and I highlighted some

00:08:54,580 --> 00:08:59,530
interesting points and one is you see

00:08:57,040 --> 00:09:05,020
the bus master this means that device is

00:08:59,530 --> 00:09:08,350
accessing the memory and so most of the

00:09:05,020 --> 00:09:10,120
state is managed by driver just by

00:09:08,350 --> 00:09:15,160
allocating memory from the kernel and

00:09:10,120 --> 00:09:17,410
giving device access to it and this is

00:09:15,160 --> 00:09:19,480
exactly how hardware devices tend to

00:09:17,410 --> 00:09:24,540
work they this is called DMA direct

00:09:19,480 --> 00:09:27,850
memory access then the other part is

00:09:24,540 --> 00:09:31,210
this the second square you can see some

00:09:27,850 --> 00:09:34,890
device memory so driver can initialize

00:09:31,210 --> 00:09:38,020
the device through this device memory

00:09:34,890 --> 00:09:39,900
again this is very similar to the PC I'm

00:09:38,020 --> 00:09:42,790
gonna talk about this a little bit later

00:09:39,900 --> 00:09:45,010
right and finally we have message signal

00:09:42,790 --> 00:09:52,540
interrupts this means we have signaling

00:09:45,010 --> 00:09:54,850
from the device to the driver let me

00:09:52,540 --> 00:09:57,850
just talk a little bit about device

00:09:54,850 --> 00:10:01,660
memory this is gonna be important so we

00:09:57,850 --> 00:10:04,000
have actually two kinds of configuration

00:10:01,660 --> 00:10:05,770
spaces they have the standard PCI

00:10:04,000 --> 00:10:09,880
configuration we have built I or

00:10:05,770 --> 00:10:12,610
specific configuration space in device

00:10:09,880 --> 00:10:15,130
memory this is used to set up the device

00:10:12,610 --> 00:10:17,830
that's one part of device memory and

00:10:15,130 --> 00:10:20,200
another part of your tayo device memory

00:10:17,830 --> 00:10:22,660
is notifications this is used for

00:10:20,200 --> 00:10:27,010
operation they are kind of kept separate

00:10:22,660 --> 00:10:29,290
and this is is you see as you will see

00:10:27,010 --> 00:10:33,690
this actually is one of the things that

00:10:29,290 --> 00:10:37,660
enables all kind of optimization tricks

00:10:33,690 --> 00:10:40,450
so you have the memory and the device

00:10:37,660 --> 00:10:43,030
but most of the state is not there most

00:10:40,450 --> 00:10:45,700
of the state is in the RAM is just

00:10:43,030 --> 00:10:49,480
accessed by device in structures that we

00:10:45,700 --> 00:10:51,730
call the bird queues and this Q just

00:10:49,480 --> 00:10:55,780
have a bunch of descriptors and each has

00:10:51,730 --> 00:10:58,120
some flags to tell the device that what

00:10:55,780 --> 00:10:59,740
it can use the descriptor for and it has

00:10:58,120 --> 00:11:02,410
an address and a lens and that's like

00:10:59,740 --> 00:11:04,540
bog-standard look at random hardware

00:11:02,410 --> 00:11:06,910
device you typically has something like

00:11:04,540 --> 00:11:10,030
this somewhere in memory

00:11:06,910 --> 00:11:12,580
it's good it's easy for hardware to

00:11:10,030 --> 00:11:20,040
implement your tell you because they

00:11:12,580 --> 00:11:23,140
just used to do in this thing now

00:11:20,040 --> 00:11:28,120
generally hardware accelerators kind of

00:11:23,140 --> 00:11:30,670
tend to use less CPU than software right

00:11:28,120 --> 00:11:33,280
but sometimes there are things that

00:11:30,670 --> 00:11:37,120
where software is faster so one of them

00:11:33,280 --> 00:11:39,610
is when you have to synchronize because

00:11:37,120 --> 00:11:42,580
software it benefits from cache

00:11:39,610 --> 00:11:46,450
synchronization that most CPUs have CP

00:11:42,580 --> 00:11:49,690
and 7p systems where right and if we are

00:11:46,450 --> 00:11:53,770
talking about a device across PCI that's

00:11:49,690 --> 00:11:56,010
not uniformly available so when you are

00:11:53,770 --> 00:11:58,660
talking to a device you have to use some

00:11:56,010 --> 00:12:03,220
special operations to synchronize your

00:11:58,660 --> 00:12:06,460
memory and make any changes to in-memory

00:12:03,220 --> 00:12:09,040
data structures appear in the correct

00:12:06,460 --> 00:12:10,780
order to the device so like you are

00:12:09,040 --> 00:12:12,610
storing a descriptor in memory and you

00:12:10,780 --> 00:12:15,780
made one want to make sure that all of

00:12:12,610 --> 00:12:19,360
it is in there in memory but only

00:12:15,780 --> 00:12:21,490
visible to the device after the data

00:12:19,360 --> 00:12:25,930
that the descriptor describes is visible

00:12:21,490 --> 00:12:29,770
to the device so in this kind of

00:12:25,930 --> 00:12:31,930
situation the software implementation

00:12:29,770 --> 00:12:34,660
actually can be a bit faster so we have

00:12:31,930 --> 00:12:36,400
a special flag and if you have a harder

00:12:34,660 --> 00:12:39,220
implementation you have to say all right

00:12:36,400 --> 00:12:41,020
you have to disable all of the

00:12:39,220 --> 00:12:44,890
optimizations that rely on cache

00:12:41,020 --> 00:12:49,990
coherency that's the other platform flag

00:12:44,890 --> 00:12:52,360
feature flag and then there are

00:12:49,990 --> 00:12:54,970
platforms where you have to work even

00:12:52,360 --> 00:12:56,920
harder so you have to actually copy all

00:12:54,970 --> 00:12:59,470
of your data into a specific bunch of

00:12:56,920 --> 00:13:02,620
addresses which are accessible to device

00:12:59,470 --> 00:13:05,170
or flush some kind of cache or set up

00:13:02,620 --> 00:13:08,050
some mappings in the MMU otherwise the

00:13:05,170 --> 00:13:10,300
data is not visible to the device and

00:13:08,050 --> 00:13:13,570
again that kind of slows the hardware a

00:13:10,300 --> 00:13:15,640
little bit more and we don't want to pay

00:13:13,570 --> 00:13:17,800
this penalty for software devices so

00:13:15,640 --> 00:13:20,230
again we have a feature flag that hard

00:13:17,800 --> 00:13:23,110
implementations set and then

00:13:20,230 --> 00:13:30,070
driver knows that it is to work a bit

00:13:23,110 --> 00:13:32,500
harder so this is just best practices

00:13:30,070 --> 00:13:34,630
you're implementing a device what you

00:13:32,500 --> 00:13:37,750
should do you should definitely

00:13:34,630 --> 00:13:41,440
implement at least 1.0 that's the

00:13:37,750 --> 00:13:43,630
version one flag means 1.0 an app you

00:13:41,440 --> 00:13:46,870
should set the other platform and the

00:13:43,630 --> 00:13:49,270
excess platform flags at this point I'm

00:13:46,870 --> 00:13:52,030
thinking if you're investing engineering

00:13:49,270 --> 00:13:55,390
the Fords and you worry about things

00:13:52,030 --> 00:13:58,300
like well what about OpenBSD they didn't

00:13:55,390 --> 00:14:03,220
update the driver to 1.0 yet just just

00:13:58,300 --> 00:14:06,130
put the engineering there sorry we have

00:14:03,220 --> 00:14:07,030
now great sorry if I was wrong to pick

00:14:06,130 --> 00:14:15,460
on the OpenBSD

00:14:07,030 --> 00:14:17,920
and and some operating system right a

00:14:15,460 --> 00:14:21,430
bunch of reasons not to support legacy

00:14:17,920 --> 00:14:23,580
interface but in particular you cannot

00:14:21,430 --> 00:14:26,950
you cannot expose all these nice flags

00:14:23,580 --> 00:14:29,350
so you don't know that you are not

00:14:26,950 --> 00:14:31,210
running and one of these platforms

00:14:29,350 --> 00:14:34,450
maybe someone plug the card in in one of

00:14:31,210 --> 00:14:37,300
these where you need to work harder for

00:14:34,450 --> 00:14:40,150
the hardware to work on a bunch of

00:14:37,300 --> 00:14:44,590
platforms the legacy the legacy

00:14:40,150 --> 00:14:47,560
interface used IO instead of memory for

00:14:44,590 --> 00:14:51,100
device access and notifications and

00:14:47,560 --> 00:14:57,700
that's that slower generally an x86 it

00:14:51,100 --> 00:15:03,100
causes exit and KVM typically so you do

00:14:57,700 --> 00:15:05,560
all this what what do you then how do

00:15:03,100 --> 00:15:11,290
you use it well first of all you can

00:15:05,560 --> 00:15:14,950
just use pass-through by the vio driver

00:15:11,290 --> 00:15:18,280
to your device right pass the device on

00:15:14,950 --> 00:15:20,410
to the guest and assuming that your card

00:15:18,280 --> 00:15:23,650
has a bunch of virtual functions and

00:15:20,410 --> 00:15:26,680
each virtual function implements the

00:15:23,650 --> 00:15:29,950
Vita aspect correctly right then for

00:15:26,680 --> 00:15:32,170
example within a VM you can just load VL

00:15:29,950 --> 00:15:33,880
driver and in the top box right no

00:15:32,170 --> 00:15:37,810
vendor-specific three

00:15:33,880 --> 00:15:40,690
nothing at least it works and I think

00:15:37,810 --> 00:15:45,910
some people did and it works for them so

00:15:40,690 --> 00:15:49,110
that's that's great so one of the names

00:15:45,910 --> 00:15:52,390
for this sorry is full of lodging

00:15:49,110 --> 00:15:54,670
because you actually put both the

00:15:52,390 --> 00:15:59,860
configuration parts and the datapath

00:15:54,670 --> 00:16:03,300
operation all in hardware so another

00:15:59,860 --> 00:16:06,720
option is to keep some part of the

00:16:03,300 --> 00:16:11,860
functionality in software so we want to

00:16:06,720 --> 00:16:19,510
somehow inject B host M there that

00:16:11,860 --> 00:16:22,350
that's a red square here between your

00:16:19,510 --> 00:16:25,000
guests or your software and the device

00:16:22,350 --> 00:16:28,690
I'm gonna talk about this a bit more

00:16:25,000 --> 00:16:32,290
later but the idea is we just intercept

00:16:28,690 --> 00:16:36,630
the control path of raishin that's why

00:16:32,290 --> 00:16:40,750
people call this data path of loading

00:16:36,630 --> 00:16:43,720
and this this M dev driver can be

00:16:40,750 --> 00:16:46,090
Hardware specific vendor specific it can

00:16:43,720 --> 00:16:53,580
access the VF but can also poke at the

00:16:46,090 --> 00:16:56,230
PF if it needs to and it will intercept

00:16:53,580 --> 00:16:59,800
their control path operation it will

00:16:56,230 --> 00:17:02,770
implement the Vallejo speak just to set

00:16:59,800 --> 00:17:04,240
up arts and software and the data paths

00:17:02,770 --> 00:17:10,720
we want to do it in hardware

00:17:04,240 --> 00:17:14,890
kind of like this so in this example we

00:17:10,720 --> 00:17:17,829
have the configuration memory the PT is

00:17:14,890 --> 00:17:20,589
at the exit in host page tables is

00:17:17,829 --> 00:17:22,630
market not valid so attempts to access

00:17:20,589 --> 00:17:26,490
that trap to the hypervisor and then we

00:17:22,630 --> 00:17:30,190
can forward it to this M deprived and

00:17:26,490 --> 00:17:33,760
the notification memory is backed by a

00:17:30,190 --> 00:17:36,400
valid PT and then it just can go on to

00:17:33,760 --> 00:17:39,610
the hardware without any traps just like

00:17:36,400 --> 00:17:41,620
pass row right and then we have the

00:17:39,610 --> 00:17:45,280
guest Ram as I said most of the

00:17:41,620 --> 00:17:46,780
structures are there and they just need

00:17:45,280 --> 00:17:47,500
to be mapped in the MMU

00:17:46,780 --> 00:17:52,780
made

00:17:47,500 --> 00:17:55,120
estable to the device and then again

00:17:52,780 --> 00:18:01,410
it's exactly like past room you get the

00:17:55,120 --> 00:18:01,410
same performance oops sorry

00:18:03,090 --> 00:18:07,560
what's going on I lost my place

00:18:08,250 --> 00:18:14,950
this one yeah just want you to point out

00:18:12,160 --> 00:18:19,000
something here so what made it easy is

00:18:14,950 --> 00:18:21,490
the fact that most of the configuration

00:18:19,000 --> 00:18:22,750
is in device memory and in an area

00:18:21,490 --> 00:18:25,300
separate from the identification

00:18:22,750 --> 00:18:27,070
identification is kind of controlled and

00:18:25,300 --> 00:18:29,560
very very narrow interface and

00:18:27,070 --> 00:18:31,540
fortunately it depends and there are

00:18:29,560 --> 00:18:35,020
some devices which have like a control

00:18:31,540 --> 00:18:37,000
Viet Kieu and then they need to do some

00:18:35,020 --> 00:18:42,220
configuration through the Viet Kieu as

00:18:37,000 --> 00:18:43,000
well this is harder to intercept well

00:18:42,220 --> 00:18:45,970
it's possible

00:18:43,000 --> 00:18:49,690
like I think the beta a file system for

00:18:45,970 --> 00:18:51,490
example it tends to do its own version

00:18:49,690 --> 00:18:54,220
discovery and configuration but that

00:18:51,490 --> 00:18:56,080
only happens at boot so maybe you can

00:18:54,220 --> 00:18:58,330
start with a software implementation and

00:18:56,080 --> 00:19:01,240
then after everything is set up you

00:18:58,330 --> 00:19:02,650
switch over to the hardware but this is

00:19:01,240 --> 00:19:04,330
something we should keep in mind as we

00:19:02,650 --> 00:19:07,780
are building new software we should try

00:19:04,330 --> 00:19:09,910
to do all of the all of the discovery

00:19:07,780 --> 00:19:12,430
should happen through memory if we can

00:19:09,910 --> 00:19:13,780
that's easier to intercept if we are

00:19:12,430 --> 00:19:17,230
considering supporting hardware

00:19:13,780 --> 00:19:21,460
limitations down the road well once you

00:19:17,230 --> 00:19:23,800
have this vendor-specific am dev device

00:19:21,460 --> 00:19:27,700
in the middle you can do a bunch of

00:19:23,800 --> 00:19:31,200
tricks one interesting possibility is to

00:19:27,700 --> 00:19:35,770
do partitioning so you could have a

00:19:31,200 --> 00:19:37,900
single VF and you have a bunch of visual

00:19:35,770 --> 00:19:40,300
cues and you give some of the virtual

00:19:37,900 --> 00:19:43,990
cues to one VM and you give this nother

00:19:40,300 --> 00:19:46,840
set to a different VM and you can map

00:19:43,990 --> 00:19:51,450
notifications correctly and you have to

00:19:46,840 --> 00:19:53,890
em the devices emulating the vio

00:19:51,450 --> 00:19:57,940
specification just the configuration

00:19:53,890 --> 00:19:59,710
part in software you if you do this you

00:19:57,940 --> 00:20:00,100
need to isolate the verticals from each

00:19:59,710 --> 00:20:01,370
other

00:20:00,100 --> 00:20:04,150
for example maybe you

00:20:01,370 --> 00:20:07,280
do this using the process address space

00:20:04,150 --> 00:20:11,030
identifier extension in the PCI Express

00:20:07,280 --> 00:20:14,240
specification so once we have hardware

00:20:11,030 --> 00:20:16,850
that supports this passive extension we

00:20:14,240 --> 00:20:19,760
can attach different process identifiers

00:20:16,850 --> 00:20:24,760
to different weird queues and then have

00:20:19,760 --> 00:20:26,870
them isolated to two different VMs

00:20:24,760 --> 00:20:31,640
unfortunate slotty at widespread but

00:20:26,870 --> 00:20:36,770
hopefully will be so another use for MTF

00:20:31,640 --> 00:20:41,059
is for migration so if you are gonna use

00:20:36,770 --> 00:20:43,400
if you're gonna move a guest between the

00:20:41,059 --> 00:20:46,270
MS running on two hosts they have to

00:20:43,400 --> 00:20:50,360
appear exactly the same to look it and

00:20:46,270 --> 00:20:53,570
one way to do this would be to have the

00:20:50,360 --> 00:20:57,050
MDF be controlled from kim you for

00:20:53,570 --> 00:20:59,090
example and then you force it to a

00:20:57,050 --> 00:21:01,700
subset of features that can work and

00:20:59,090 --> 00:21:04,640
both the source and the destination so

00:21:01,700 --> 00:21:06,890
Kim you kind of block specific features

00:21:04,640 --> 00:21:08,630
and the source field which done not

00:21:06,890 --> 00:21:11,120
available on the destination and vice

00:21:08,630 --> 00:21:13,520
versa and then once we have this

00:21:11,120 --> 00:21:15,500
compatibility in the configuration we

00:21:13,520 --> 00:21:17,420
can safely move the guest and it will

00:21:15,500 --> 00:21:23,150
not notice that anything happened here

00:21:17,420 --> 00:21:27,800
right again I am dev allows some

00:21:23,150 --> 00:21:30,290
visibility into the state of the device

00:21:27,800 --> 00:21:32,960
so we don't have full introspection in

00:21:30,290 --> 00:21:35,540
the vio spec so you need some kind of

00:21:32,960 --> 00:21:39,080
vendor specific capability in order to

00:21:35,540 --> 00:21:42,080
be lured in order to be able to load the

00:21:39,080 --> 00:21:44,750
state of your device so you would get it

00:21:42,080 --> 00:21:46,400
through the M type driver send it to the

00:21:44,750 --> 00:21:47,870
q mu and then you can send it over to

00:21:46,400 --> 00:21:51,470
the destination and there hopefully

00:21:47,870 --> 00:21:54,320
loaded back into the destination device

00:21:51,470 --> 00:21:56,450
I hope you'll extend with the aspect

00:21:54,320 --> 00:22:00,309
down the road to support this

00:21:56,450 --> 00:22:00,309
introspection but that's where it is now

00:22:01,210 --> 00:22:11,030
device bugs also fondly known as quirks

00:22:05,860 --> 00:22:12,830
so hopefully hopefully you can fix the

00:22:11,030 --> 00:22:15,290
hardware how do I fix the hardware well

00:22:12,830 --> 00:22:18,680
a lot of functionality is gauged

00:22:15,290 --> 00:22:21,140
by feature bits so if you just have just

00:22:18,680 --> 00:22:23,660
the feature beads maybe in some

00:22:21,140 --> 00:22:25,580
programmable memory then you can disable

00:22:23,660 --> 00:22:27,080
parts of hardware hide them from

00:22:25,580 --> 00:22:29,990
software so you find a bug and a

00:22:27,080 --> 00:22:32,410
specific feature you can mask that even

00:22:29,990 --> 00:22:34,790
the whole configuration is not too big

00:22:32,410 --> 00:22:37,160
we switch your bit right now we are kind

00:22:34,790 --> 00:22:39,620
of a bit more than halfway through the

00:22:37,160 --> 00:22:43,070
first 64 bits so I would suggest like

00:22:39,620 --> 00:22:44,510
new devices just do like 128 bits that

00:22:43,070 --> 00:22:49,400
shouldn't be too expensive

00:22:44,510 --> 00:22:51,500
hopefully it's fixable again it's always

00:22:49,400 --> 00:22:52,940
possible to say we cannot fix this

00:22:51,500 --> 00:22:55,070
device let's just use the vendor

00:22:52,940 --> 00:22:57,590
specific driver it's not the end of the

00:22:55,070 --> 00:22:59,060
road doesn't mean that you will have to

00:22:57,590 --> 00:23:01,760
write the whole driver you might use

00:22:59,060 --> 00:23:03,920
them well you know you can copy some

00:23:01,760 --> 00:23:10,640
parts of your little driver we can maybe

00:23:03,920 --> 00:23:14,480
a link it to the library but sometimes

00:23:10,640 --> 00:23:16,610
you might be able to even avoid changing

00:23:14,480 --> 00:23:18,920
the hardware completely so again if you

00:23:16,610 --> 00:23:21,710
have the empty driver right that can

00:23:18,920 --> 00:23:25,070
poke at is VF or the PAF figure out that

00:23:21,710 --> 00:23:27,080
the quark is needed right and then it

00:23:25,070 --> 00:23:28,880
can mask some of the features because

00:23:27,080 --> 00:23:33,370
the feature bits are in configuration

00:23:28,880 --> 00:23:37,070
space so we kind of easy to intercept

00:23:33,370 --> 00:23:40,700
and you might need to actually set some

00:23:37,070 --> 00:23:42,980
feature bits that are missing I think it

00:23:40,700 --> 00:23:46,690
actually I had to talk to a hardware

00:23:42,980 --> 00:23:49,400
vendor and they didn't set the platform

00:23:46,690 --> 00:23:50,150
access flags and then they didn't work

00:23:49,400 --> 00:23:52,940
with the IMU

00:23:50,150 --> 00:23:55,250
so you can you can work around this in

00:23:52,940 --> 00:23:58,430
the MDF you can set the flag and then it

00:23:55,250 --> 00:24:05,240
will be visible to the rest of the VM as

00:23:58,430 --> 00:24:07,100
if the flag has been set well it's an

00:24:05,240 --> 00:24:11,120
interesting question how to detect the

00:24:07,100 --> 00:24:13,460
device normally you'd use just vendor in

00:24:11,120 --> 00:24:17,540
device ID you cannot because you want to

00:24:13,460 --> 00:24:19,550
support the generic driver well maybe

00:24:17,540 --> 00:24:21,680
you can use a subsystem vendor device ID

00:24:19,550 --> 00:24:24,140
you can do this unless you want to

00:24:21,680 --> 00:24:27,290
support legacy people maybe that's

00:24:24,140 --> 00:24:29,149
another reason not to do Lexie but if

00:24:27,290 --> 00:24:31,190
you do want to do legacy

00:24:29,149 --> 00:24:33,830
and we have a proposal on list to like

00:24:31,190 --> 00:24:39,499
add a special capability that allows you

00:24:33,830 --> 00:24:42,589
to show right yes legacy but I so ignore

00:24:39,499 --> 00:24:46,609
the subsystem ID but this is my actual

00:24:42,589 --> 00:24:51,409
ID so we are looking at to make it

00:24:46,609 --> 00:24:55,820
easier hey here's another cute use for

00:24:51,409 --> 00:24:59,749
the M dev device right logging so you

00:24:55,820 --> 00:25:03,849
can you need to know which pages change

00:24:59,749 --> 00:25:07,249
if you want to do a snapshot for example

00:25:03,849 --> 00:25:11,389
right because you don't want to dump all

00:25:07,249 --> 00:25:13,279
of your memory every each time so one

00:25:11,389 --> 00:25:18,080
thing you can do you can have this empty

00:25:13,279 --> 00:25:20,779
of driver allocate a buffer in some

00:25:18,080 --> 00:25:24,379
format you know that hardware knows

00:25:20,779 --> 00:25:26,989
about and then give it to the PF and

00:25:24,379 --> 00:25:29,570
tell it whenever one of your VFS is

00:25:26,989 --> 00:25:33,349
gonna modify memory I want you to record

00:25:29,570 --> 00:25:34,700
this in this buffer and then you can

00:25:33,349 --> 00:25:36,950
figure out alright this is a list of

00:25:34,700 --> 00:25:39,379
change pages that changed since I'd

00:25:36,950 --> 00:25:41,779
previously do the snapshot so I want to

00:25:39,379 --> 00:25:46,909
do this also works for pre copy

00:25:41,779 --> 00:25:48,919
migration doesn't work for them post

00:25:46,909 --> 00:25:51,049
copies all if I have the time I cannot

00:25:48,919 --> 00:25:56,809
talk about post copy but first let's

00:25:51,049 --> 00:26:00,649
just bit of administration so we kind of

00:25:56,809 --> 00:26:03,259
seem to be to have stabilized the spec

00:26:00,649 --> 00:26:06,129
at this point not too much it's going on

00:26:03,259 --> 00:26:08,539
at least with existing devices always

00:26:06,129 --> 00:26:10,879
proposal for new devices to are

00:26:08,539 --> 00:26:12,799
outstanding so I think we should be able

00:26:10,879 --> 00:26:15,529
to find the freezer spec kind of by end

00:26:12,799 --> 00:26:17,839
of November and then we start the public

00:26:15,529 --> 00:26:21,619
review draft and then it all depends if

00:26:17,839 --> 00:26:24,259
people don't find any defects oh five

00:26:21,619 --> 00:26:26,869
minutes all right then we'll finalize it

00:26:24,259 --> 00:26:30,559
and if not we'll do another round of

00:26:26,869 --> 00:26:33,849
reviews all right let's do this is

00:26:30,559 --> 00:26:36,609
important to me so you need help

00:26:33,849 --> 00:26:39,799
implementing the spec what you should do

00:26:36,609 --> 00:26:42,440
first you should student do is mail me

00:26:39,799 --> 00:26:48,110
privately but do mail the meaningly

00:26:42,440 --> 00:26:50,629
and copy me that's great and you you

00:26:48,110 --> 00:26:52,549
want to make a change to spec because

00:26:50,629 --> 00:26:56,720
your device causes you great new feature

00:26:52,549 --> 00:26:58,879
and something not to do is to lock

00:26:56,720 --> 00:27:01,159
yourself up and work on the spec

00:26:58,879 --> 00:27:03,529
proposal for a year and then publish it

00:27:01,159 --> 00:27:07,940
something to do is to start publishers

00:27:03,529 --> 00:27:12,379
early as possible all right let's try to

00:27:07,940 --> 00:27:14,809
skip this one this is just the minimum

00:27:12,379 --> 00:27:16,429
you need to do if you want to make a

00:27:14,809 --> 00:27:18,590
change for the spec just make sure you

00:27:16,429 --> 00:27:21,230
don't conflict with others so for a new

00:27:18,590 --> 00:27:24,039
device allocate a new ID and register it

00:27:21,230 --> 00:27:27,440
with the TC so others don't implement

00:27:24,039 --> 00:27:30,169
different devices the same ID if you are

00:27:27,440 --> 00:27:31,850
extending the spec ask for F it should

00:27:30,169 --> 00:27:33,350
be to be reserved we are not via throat

00:27:31,850 --> 00:27:35,149
on feature bibs will give you a feature

00:27:33,350 --> 00:27:39,679
bit with just a vague description what

00:27:35,149 --> 00:27:43,909
it is and then there won't be a conflict

00:27:39,679 --> 00:27:47,000
and there is IPR compatibility there's a

00:27:43,909 --> 00:27:48,440
lot of lawyers speak but one thing that

00:27:47,000 --> 00:27:50,870
definitely important for us is that

00:27:48,440 --> 00:27:52,700
people declare alright I want to put

00:27:50,870 --> 00:27:55,519
this in the spec and if someone

00:27:52,700 --> 00:28:02,919
implements it I'm not gonna sue them so

00:27:55,519 --> 00:28:02,919
that's that's that I want to talk about

00:28:03,129 --> 00:28:10,250
post copy so let's do this so page

00:28:07,879 --> 00:28:13,269
faults are kind of important and they

00:28:10,250 --> 00:28:15,590
kind of tend not to work for hardware

00:28:13,269 --> 00:28:17,539
but they are nice if you can have them

00:28:15,590 --> 00:28:20,809
because you can do over commit riskier

00:28:17,539 --> 00:28:24,470
salmon swap and you can do recopy

00:28:20,809 --> 00:28:26,149
migration with write faults and you can

00:28:24,470 --> 00:28:31,370
do post copy with read and write false

00:28:26,149 --> 00:28:33,559
it snapshots and stuff so there is

00:28:31,370 --> 00:28:36,250
support for page requests interface even

00:28:33,559 --> 00:28:38,929
if you have hardware that supports that

00:28:36,250 --> 00:28:40,610
it's all kind of assumes that it can

00:28:38,929 --> 00:28:43,070
handle the fault completely in the

00:28:40,610 --> 00:28:47,779
kernel and that means no user fault of G

00:28:43,070 --> 00:28:51,230
so for example no post copy and then all

00:28:47,779 --> 00:28:55,790
the support is very limited something we

00:28:51,230 --> 00:28:58,970
could do is if we taught the MMU drivers

00:28:55,790 --> 00:29:03,560
to individually protect and unprotect

00:28:58,970 --> 00:29:08,200
specific memory pages then we could take

00:29:03,560 --> 00:29:11,060
a page that we want to move out and

00:29:08,200 --> 00:29:12,860
protect it at the immu level then device

00:29:11,060 --> 00:29:14,150
attempts to access it it gets a fault

00:29:12,860 --> 00:29:17,240
normally that's an error

00:29:14,150 --> 00:29:20,200
device enters an error state instead

00:29:17,240 --> 00:29:22,970
they could just pose a specific you

00:29:20,200 --> 00:29:26,540
notify the host through the end of

00:29:22,970 --> 00:29:28,550
driver and then some later point you

00:29:26,540 --> 00:29:31,040
have handled this fault you have a page

00:29:28,550 --> 00:29:34,610
and we can impose the cue and have it

00:29:31,040 --> 00:29:36,200
restart and hopefully go on that would

00:29:34,610 --> 00:29:48,650
be nice if someone wants to implement

00:29:36,200 --> 00:29:52,570
that this okay so this is another

00:29:48,650 --> 00:29:55,550
optimization idea so it turns out that

00:29:52,570 --> 00:29:58,370
software kind of goes through requests

00:29:55,550 --> 00:30:01,400
in the queue and just it has to run them

00:29:58,370 --> 00:30:04,280
anyway right in the old run sequential

00:30:01,400 --> 00:30:06,950
on the CPU but hardware can have lots of

00:30:04,280 --> 00:30:09,560
resources and random in parallel so it's

00:30:06,950 --> 00:30:11,480
very helpful if we can tell Hardware not

00:30:09,560 --> 00:30:14,690
just there is something in the queue go

00:30:11,480 --> 00:30:18,290
and get it instead if we can tell it all

00:30:14,690 --> 00:30:20,060
right and here are 16 requests in the

00:30:18,290 --> 00:30:22,190
queue and then hard we can go fetch them

00:30:20,060 --> 00:30:28,400
in parallel that's something we are

00:30:22,190 --> 00:30:31,880
considering in the spare interrupts

00:30:28,400 --> 00:30:36,440
oppression people are asking to move it

00:30:31,880 --> 00:30:39,230
out of RAM because it's it's hard for

00:30:36,440 --> 00:30:41,450
the PCI card to fetch it from Ram so

00:30:39,230 --> 00:30:45,230
maybe maybe interesting to move it out

00:30:41,450 --> 00:30:48,080
to the hardware if corrupt coalescing is

00:30:45,230 --> 00:30:50,180
kind of irrelevant if you implement it

00:30:48,080 --> 00:30:51,980
in software because well you get

00:30:50,180 --> 00:30:54,980
interrupt from the actual hardware

00:30:51,980 --> 00:30:57,950
anyway you're running stuffin the host

00:30:54,980 --> 00:30:59,990
so he exits it from the VM now we start

00:30:57,950 --> 00:31:02,180
the timer once time it will expire

00:30:59,990 --> 00:31:06,310
you'll interrupt the VM again let's live

00:31:02,180 --> 00:31:09,510
overhead but with an actual hardware

00:31:06,310 --> 00:31:14,030
then that finally becomes relevant so

00:31:09,510 --> 00:31:18,360
we'll add that so you see it's very busy

00:31:14,030 --> 00:31:21,690
space so join the fun

00:31:18,360 --> 00:31:23,870
and let's just leave some time for

00:31:21,690 --> 00:31:23,870
questions

00:31:28,830 --> 00:31:36,210
I believe you mentioned that you're

00:31:33,360 --> 00:31:39,000
looking at getting a M dev support

00:31:36,210 --> 00:31:40,230
something in the spec for migration are

00:31:39,000 --> 00:31:43,560
you looking at something that will also

00:31:40,230 --> 00:31:46,920
actually pause the hardware so get it to

00:31:43,560 --> 00:31:49,470
a quieten point and where it's state can

00:31:46,920 --> 00:31:52,550
be grabbed yeah I'm guessing that that

00:31:49,470 --> 00:31:52,550
should be part of it

00:32:03,990 --> 00:32:10,020
and I have a question on guarding the

00:32:06,420 --> 00:32:12,510
m.div in the pre copy slide so okay you

00:32:10,020 --> 00:32:15,060
are suggesting that you will use em dev

00:32:12,510 --> 00:32:17,670
- to know what is to do the Delta

00:32:15,060 --> 00:32:20,040
tracking of the of the completions of a

00:32:17,670 --> 00:32:23,190
I English package right so we'll be able

00:32:20,040 --> 00:32:24,720
to know which we what were the DMA

00:32:23,190 --> 00:32:26,250
operation that were done by the hardware

00:32:24,720 --> 00:32:28,230
right but yeah

00:32:26,250 --> 00:32:29,670
you will need to intercept the how do

00:32:28,230 --> 00:32:30,960
you plan to do that you need to induce

00:32:29,670 --> 00:32:33,600
you are planning to intercept

00:32:30,960 --> 00:32:35,850
amplification interrupt but what if the

00:32:33,600 --> 00:32:40,880
gas is using a PMD like in the PDK oh

00:32:35,850 --> 00:32:45,390
sorry so at least the idea here was that

00:32:40,880 --> 00:32:47,940
the m.div just programs the PF and tells

00:32:45,390 --> 00:32:50,310
it that you still need this capability

00:32:47,940 --> 00:32:52,170
in the heart okay so the hardware is

00:32:50,310 --> 00:32:57,030
responsible to provide you a dirty log

00:32:52,170 --> 00:33:00,540
oh yeah you know it probably needs to

00:32:57,030 --> 00:33:03,810
translate things back so it it tells the

00:33:00,540 --> 00:33:06,060
host can pocket this buffer which is in

00:33:03,810 --> 00:33:07,650
device specific format and tells the

00:33:06,060 --> 00:33:09,690
host already these were the pages are

00:33:07,650 --> 00:33:17,940
code modified we can hopefully we'll

00:33:09,690 --> 00:33:20,640
standardized it some of this so usually

00:33:17,940 --> 00:33:24,390
when you have via features you disable

00:33:20,640 --> 00:33:25,770
them right in and you so you have a set

00:33:24,390 --> 00:33:28,080
and you can disable all the ones that

00:33:25,770 --> 00:33:30,150
you don't support in this case you have

00:33:28,080 --> 00:33:32,940
a feature where if it's not supported by

00:33:30,150 --> 00:33:35,400
the driver the driver will misbehave and

00:33:32,940 --> 00:33:37,890
will not order the accesses correctly

00:33:35,400 --> 00:33:43,620
and all that so how do you handle all

00:33:37,890 --> 00:33:46,680
drivers running on hardware and how are

00:33:43,620 --> 00:33:50,790
they blacklisted yeah well there are two

00:33:46,680 --> 00:33:53,000
things you can do right so you can just

00:33:50,790 --> 00:33:56,220
figure out that you're running a

00:33:53,000 --> 00:34:02,390
specific architecture that happens to be

00:33:56,220 --> 00:34:02,390
ordered and one I know but it's popular

00:34:02,480 --> 00:34:08,250
and the other thing you can do is just

00:34:05,850 --> 00:34:11,730
fail gracefully so you can have digital

00:34:08,250 --> 00:34:14,880
device that just just to fail feature

00:34:11,730 --> 00:34:16,500
negotiation so at least it won't you

00:34:14,880 --> 00:34:18,899
know race and

00:34:16,500 --> 00:34:20,850
crash in the field and it will be fail

00:34:18,899 --> 00:34:24,090
immediately and someone will say why

00:34:20,850 --> 00:34:27,710
doesn't this work and powerpc and then

00:34:24,090 --> 00:34:27,710
read the manual we'll figure it out

00:34:32,330 --> 00:34:38,010
hey while you have this light on so

00:34:35,879 --> 00:34:40,500
there's a lot done in terms of the

00:34:38,010 --> 00:34:42,720
logging etc for pre copy

00:34:40,500 --> 00:34:44,550
is there anything done for throttling

00:34:42,720 --> 00:34:47,450
when you're thinking about pre copying

00:34:44,550 --> 00:34:48,750
all to converge kind of migration I

00:34:47,450 --> 00:34:51,990
don't know

00:34:48,750 --> 00:34:53,700
yeah we just relying the qmu throttling

00:34:51,990 --> 00:34:58,650
the CPUs would eventually slow the

00:34:53,700 --> 00:35:01,170
device down a lot well most of the

00:34:58,650 --> 00:35:05,880
operations tend to kind of be a software

00:35:01,170 --> 00:35:08,430
driven not all of them so like if you

00:35:05,880 --> 00:35:11,730
slow down the VM the device will tend to

00:35:08,430 --> 00:35:13,620
get eventually slow down I agree it's

00:35:11,730 --> 00:35:15,480
not Universal like like you have a

00:35:13,620 --> 00:35:18,450
networking device you have a bunch of

00:35:15,480 --> 00:35:20,310
buffers there and if you just stop it VM

00:35:18,450 --> 00:35:22,260
it still might take a while for the

00:35:20,310 --> 00:35:23,640
device to exhaust all these buffers and

00:35:22,260 --> 00:35:25,040
then it's not great if you exhaust the

00:35:23,640 --> 00:35:27,480
laser

00:35:25,040 --> 00:35:28,980
probably yeah interesting point

00:35:27,480 --> 00:35:30,690
do you have some protocol extension that

00:35:28,980 --> 00:35:33,020
will let you to tell the device you're

00:35:30,690 --> 00:35:35,820
not allowed to write more than XOR oh

00:35:33,020 --> 00:35:46,080
yeah yeah bucket base thing I don't know

00:35:35,820 --> 00:35:47,460
yeah I hadn't proposed that okay so on

00:35:46,080 --> 00:35:50,730
one of the slides you were mentioning

00:35:47,460 --> 00:35:52,800
that there were use cases for splitting

00:35:50,730 --> 00:35:54,330
a virtual function could you give you

00:35:52,800 --> 00:35:56,250
examples of cases where this would be

00:35:54,330 --> 00:35:59,370
useful and not you run into cases where

00:35:56,250 --> 00:36:06,450
I did have ordering issues in virtual

00:35:59,370 --> 00:36:11,520
functions well okay so it depends on the

00:36:06,450 --> 00:36:13,070
number of VFS that we can have but it

00:36:11,520 --> 00:36:16,179
does allow you to

00:36:13,070 --> 00:36:16,179
[Music]

00:36:17,930 --> 00:36:28,080
kind of do the kind of do a flexible

00:36:22,610 --> 00:36:30,020
configuration of you can do you can do

00:36:28,080 --> 00:36:34,440
the split in a flexible way

00:36:30,020 --> 00:36:38,370
so for example with BFS you have to know

00:36:34,440 --> 00:36:41,100
ahead of the time how many you want but

00:36:38,370 --> 00:36:42,630
in that case wouldn't that be if you

00:36:41,100 --> 00:36:45,690
were going that way wouldn't that be

00:36:42,630 --> 00:36:48,240
easier for the helpers manufacturer to

00:36:45,690 --> 00:36:51,560
create a single VF while you have to

00:36:48,240 --> 00:36:54,630
configure the pSATS

00:36:51,560 --> 00:36:58,050
sorry so why would it make sense in that

00:36:54,630 --> 00:36:59,820
case to have multiple years why would

00:36:58,050 --> 00:37:02,000
you have multiple waves in this case

00:36:59,820 --> 00:37:06,450
yeah it probably probably don't need to

00:37:02,000 --> 00:37:09,090
but you know could be legacy things I

00:37:06,450 --> 00:37:10,950
mean so the PSID has to be supported

00:37:09,090 --> 00:37:13,050
system-wide so basically you're saying

00:37:10,950 --> 00:37:16,200
if you have PS IDs then it makes sense

00:37:13,050 --> 00:37:18,780
to have to no longer use VF but could go

00:37:16,200 --> 00:37:21,660
finer grained using psi the answer like

00:37:18,780 --> 00:37:23,760
if if all these systems do support this

00:37:21,660 --> 00:37:26,450
extension you probably don't really need

00:37:23,760 --> 00:37:26,450
yes

00:37:45,530 --> 00:37:49,400
I could you expand a bit about the

00:37:47,630 --> 00:37:52,280
access platforms the order platform I

00:37:49,400 --> 00:37:57,080
understand sorry which one the access

00:37:52,280 --> 00:38:04,480
platform they access platform we find

00:37:57,080 --> 00:38:10,609
that right so there are lots of systems

00:38:04,480 --> 00:38:13,130
where the CPU is kind of easy so you can

00:38:10,609 --> 00:38:17,359
store something in memory and it's

00:38:13,130 --> 00:38:19,070
visible to another CPU but if you just

00:38:17,359 --> 00:38:21,560
put it in memory and cavity by

00:38:19,070 --> 00:38:23,060
successive it won't see the value that

00:38:21,560 --> 00:38:26,140
they have stored there you need to

00:38:23,060 --> 00:38:31,010
actually flush it out of your cache

00:38:26,140 --> 00:38:34,070
that's one one case another is what I

00:38:31,010 --> 00:38:36,230
brought here bounced buffers so there

00:38:34,070 --> 00:38:39,290
could be specific addresses they are

00:38:36,230 --> 00:38:44,500
accessible to the device and most of the

00:38:39,290 --> 00:38:47,270
memory isn't encrypted VMs come to mind

00:38:44,500 --> 00:38:50,390
you kind of mark specific pages and

00:38:47,270 --> 00:38:55,330
non-encrypted these are accessible but

00:38:50,390 --> 00:38:58,760
most of it most of the state isn't and

00:38:55,330 --> 00:39:01,220
MMU is another case in point so you

00:38:58,760 --> 00:39:03,530
don't you cannot just take a random page

00:39:01,220 --> 00:39:05,780
and just give it to the device it will

00:39:03,530 --> 00:39:07,790
fail it's intentional for security so if

00:39:05,780 --> 00:39:10,220
you want it to actually succeed you need

00:39:07,790 --> 00:39:12,920
to enable this temporary in the MMU

00:39:10,220 --> 00:39:16,970
then device does access then you disable

00:39:12,920 --> 00:39:21,130
it for security again so that what the

00:39:16,970 --> 00:39:24,380
access platform says it really says I

00:39:21,130 --> 00:39:26,270
know if when it was part of the

00:39:24,380 --> 00:39:29,720
hypervisor you didn't need the security

00:39:26,270 --> 00:39:33,560
all of the memories was accessible you

00:39:29,720 --> 00:39:36,710
don't need to work hard but this won't

00:39:33,560 --> 00:39:39,320
apply here you have to work hard disable

00:39:36,710 --> 00:39:43,280
these optimizations please it's

00:39:39,320 --> 00:39:45,440
basically if you don't know and most you

00:39:43,280 --> 00:39:48,440
know independent hardware vendors won't

00:39:45,440 --> 00:39:52,599
know where is the specific card going to

00:39:48,440 --> 00:39:56,900
be plugged you basically just said this

00:39:52,599 --> 00:40:00,190
it was too fast quick question

00:39:56,900 --> 00:40:02,480
what vendors and what's the performance

00:40:00,190 --> 00:40:07,279
what's the performance cost performance

00:40:02,480 --> 00:40:10,880
cost would depend yeah so if if it's an

00:40:07,279 --> 00:40:13,910
embedded system right then you might

00:40:10,880 --> 00:40:17,720
know that your card is actually running

00:40:13,910 --> 00:40:20,390
on PCI bus that has complete complete

00:40:17,720 --> 00:40:24,559
access to all of the memory there's no

00:40:20,390 --> 00:40:27,589
need to for tricky flushes and and there

00:40:24,559 --> 00:40:29,509
is no immu in the system then you don't

00:40:27,589 --> 00:40:32,569
have to set this flag if you are

00:40:29,509 --> 00:40:35,480
building like an unique based on the

00:40:32,569 --> 00:40:37,069
video networking specification then

00:40:35,480 --> 00:40:45,619
you're a vendor that wants to set this

00:40:37,069 --> 00:40:49,369
in the in the future guess I'll have to

00:40:45,619 --> 00:40:52,970
go and look and see whether they gave me

00:40:49,369 --> 00:40:56,089
the permission to kill the names I don't

00:40:52,970 --> 00:40:58,220
know but we have under gravity see we

00:40:56,089 --> 00:41:01,029
have a bunch of vendors participating in

00:40:58,220 --> 00:41:03,860
tell and what we and a bunch of guys

00:41:01,029 --> 00:41:09,090
thank you thank you very great audience

00:41:03,860 --> 00:41:15,949
[Applause]

00:41:09,090 --> 00:41:15,949

YouTube URL: https://www.youtube.com/watch?v=bCOo-WAAZP4


