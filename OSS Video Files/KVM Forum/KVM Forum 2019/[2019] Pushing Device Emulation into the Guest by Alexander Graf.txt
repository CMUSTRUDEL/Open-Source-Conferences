Title: [2019] Pushing Device Emulation into the Guest by Alexander Graf
Publication date: 2019-11-09
Playlist: KVM Forum 2019
Description: 
	Ever since KVM was created, the tenant split has always been very clear: KVM inside the Linux kernel provides an abstraction layer for CPU and close-to-CPU hardware, guests run as if they were on real hardware and user space (QEMU usually) emulates real world hardware.

It's about time we start to reconsider that split though. With spectre mitigations in place, exiting guest context suddenly becomes much more expensive than before. From a general security point of view we ideally want to run as little code as we can in host context. Also, with device assignment becoming commodity, maybe we can build faster virtual devices if we think out of the box.

In this presentation I will introduce a prototype I've been working on that implements legacy device emulation inside guest firmware and explain all the security as well as tenant split benefits that brings.

---

Alexander Graf
Amazon
Principal Software Engineer

Alexander joined Amazon just this year. In his previous life he worked on fancy things like SUSE Studio, QEMU, KVM, openSUSE and SLES on ARM and U-Boot. Whenever something really useful comes to his mind, he tends to implement it. Among others he did Mac OS X virtualization using KVM, nested SVM, KVM on PowerPC, a lot of work in QEMU for openSUSE on ARM and the UEFI compatibility layer in U-Boot.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,770 --> 00:00:12,030
good afternoon welcome back after the

00:00:09,120 --> 00:00:15,089
lunch break and welcome to my amazing

00:00:12,030 --> 00:00:16,770
talk of in guest device emulation was a

00:00:15,089 --> 00:00:18,990
fun pet project that I've started off

00:00:16,770 --> 00:00:20,970
and we're gonna have a golf later on to

00:00:18,990 --> 00:00:23,760
see what we can do out of this I mean

00:00:20,970 --> 00:00:26,789
where can we drag it so first off Who am

00:00:23,760 --> 00:00:31,170
I my name is Roxanne de Graaff I just

00:00:26,789 --> 00:00:33,380
recently switched over to Amazon in May

00:00:31,170 --> 00:00:37,920
this year you might remember me from

00:00:33,380 --> 00:00:40,170
projects like nested SVM or PowerPC KVM

00:00:37,920 --> 00:00:43,170
or random other fun things I've done in

00:00:40,170 --> 00:00:45,629
the KVM world what I'm telling here is

00:00:43,170 --> 00:00:48,180
all my own opinions obviously tipica

00:00:45,629 --> 00:00:49,289
disclaimer so what what is device

00:00:48,180 --> 00:00:51,840
emulation well how do you how does

00:00:49,289 --> 00:00:53,430
device simulation usually work what do

00:00:51,840 --> 00:00:55,920
we do there this is a bare-metal machine

00:00:53,430 --> 00:00:57,570
on a bare-metal machine you have user

00:00:55,920 --> 00:00:58,590
space that talks to kernel space that

00:00:57,570 --> 00:01:00,329
talks to hardware and then you have

00:00:58,590 --> 00:01:03,539
really really normal interfaces as long

00:01:00,329 --> 00:01:06,930
as you have a reasonably non DB d KS PDK

00:01:03,539 --> 00:01:09,060
interface to your to your system when

00:01:06,930 --> 00:01:11,400
you introduce virtualization what we

00:01:09,060 --> 00:01:14,700
usually do is qm you there in a vm world

00:01:11,400 --> 00:01:20,460
introduce virtualization this changes to

00:01:14,700 --> 00:01:22,350
this picture so you still have user

00:01:20,460 --> 00:01:23,850
space I mean kernel space there but when

00:01:22,350 --> 00:01:25,290
the kernel tries to access hardware we

00:01:23,850 --> 00:01:27,840
no longer allowed private access to

00:01:25,290 --> 00:01:30,390
hardware we route that by I K VM into

00:01:27,840 --> 00:01:33,600
device simulation that commonly lives

00:01:30,390 --> 00:01:38,250
inside of Q inside user space on on the

00:01:33,600 --> 00:01:40,189
different world the host host world the

00:01:38,250 --> 00:01:42,450
problem with that is if there's a bug

00:01:40,189 --> 00:01:44,250
inside of that emulation code which

00:01:42,450 --> 00:01:48,780
opportunity ever happens but if there's

00:01:44,250 --> 00:01:52,049
a bug then you suddenly have an enfant

00:01:48,780 --> 00:01:54,420
Store for malicious code in a in another

00:01:52,049 --> 00:01:56,490
area that you did not necessarily expect

00:01:54,420 --> 00:01:58,259
it to be in which means you may get into

00:01:56,490 --> 00:01:59,670
security issues because the attack

00:01:58,259 --> 00:02:01,619
service is just much bigger than what

00:01:59,670 --> 00:02:05,969
the guest had before Brenda was just

00:02:01,619 --> 00:02:07,110
running directly to hardware there's all

00:02:05,969 --> 00:02:08,560
virtualization things actually not

00:02:07,110 --> 00:02:10,810
telling you

00:02:08,560 --> 00:02:14,860
iBM has done it forever and even x86

00:02:10,810 --> 00:02:18,700
it's been around for a while so whom of

00:02:14,860 --> 00:02:20,230
you knows what SMM is who of you

00:02:18,700 --> 00:02:23,950
Schmucks in fear when they hear of as a

00:02:20,230 --> 00:02:25,750
man very good very good

00:02:23,950 --> 00:02:27,430
so as I am I'm has been to use to solve

00:02:25,750 --> 00:02:28,780
a very similar problem on real machines

00:02:27,430 --> 00:02:30,910
on bare metal

00:02:28,780 --> 00:02:32,980
imagine you have a kernel I'm drawing

00:02:30,910 --> 00:02:35,800
Linux here but it is not really meant

00:02:32,980 --> 00:02:38,070
for Linux you have a kernel and that

00:02:35,800 --> 00:02:40,950
kernel wanted to for example talk to

00:02:38,070 --> 00:02:44,010
hardware using a ps2 keyboard controller

00:02:40,950 --> 00:02:47,950
now unfortunately the world moved on and

00:02:44,010 --> 00:02:50,230
we started plugging USB keyboards into

00:02:47,950 --> 00:02:52,000
our systems which don't have a ps2

00:02:50,230 --> 00:02:54,880
keyboard control anymore so how do you

00:02:52,000 --> 00:02:56,290
how do you bridge that gap between an

00:02:54,880 --> 00:02:58,390
operating system that talks to you

00:02:56,290 --> 00:03:01,540
legacy keeper controller and a USB

00:02:58,390 --> 00:03:03,340
device that you need to drive well Intel

00:03:01,540 --> 00:03:04,810
figured SMM is a really smart way we

00:03:03,340 --> 00:03:09,760
introduced a piece of code and firmware

00:03:04,810 --> 00:03:10,989
that simply need to trap into whenever

00:03:09,760 --> 00:03:13,540
you want to talk to your keyboard

00:03:10,989 --> 00:03:16,420
controller and then translates that into

00:03:13,540 --> 00:03:17,799
USB commands down there or arbitrary

00:03:16,420 --> 00:03:25,110
other things there's a lot of value at

00:03:17,799 --> 00:03:27,430
in SMM for definitions of value add so

00:03:25,110 --> 00:03:29,560
how does kme device simulation work I'm

00:03:27,430 --> 00:03:31,420
just be just going through quick history

00:03:29,560 --> 00:03:33,220
101 so that we can combine the different

00:03:31,420 --> 00:03:35,170
pieces of the puzzles puzzle after words

00:03:33,220 --> 00:03:37,510
what is what qmu device simulation look

00:03:35,170 --> 00:03:39,430
like then chemi device simulation we

00:03:37,510 --> 00:03:40,660
went through that earlier right so you

00:03:39,430 --> 00:03:42,250
have user space you have kernel space

00:03:40,660 --> 00:03:44,170
then you have on the host you have KBM

00:03:42,250 --> 00:03:46,329
you have a KVM user space and you have

00:03:44,170 --> 00:03:48,880
hardware that is Inc under control by

00:03:46,329 --> 00:03:50,799
the host so when the guest wants to try

00:03:48,880 --> 00:03:52,930
and actually talk to hardware it instead

00:03:50,799 --> 00:03:56,170
doesn't go to hardware it goes into KVM

00:03:52,930 --> 00:03:58,660
causes a VM exit which flows into user

00:03:56,170 --> 00:04:00,040
space using the octal exit when user

00:03:58,660 --> 00:04:02,470
space can go and actually do an

00:04:00,040 --> 00:04:05,739
operation like a weed it's a suite yes

00:04:02,470 --> 00:04:07,870
like a weed which goes into the host

00:04:05,739 --> 00:04:09,970
kernel which then can transit into into

00:04:07,870 --> 00:04:12,670
real hardware interface like say an nvme

00:04:09,970 --> 00:04:14,079
command down to hardware which then

00:04:12,670 --> 00:04:16,120
returns into the kernel because the

00:04:14,079 --> 00:04:18,820
hardware finished reading that data and

00:04:16,120 --> 00:04:20,650
then you go back into your user space

00:04:18,820 --> 00:04:21,109
which then can run the octal to run the

00:04:20,650 --> 00:04:23,270
guest

00:04:21,109 --> 00:04:25,250
and so you can go back into your guest

00:04:23,270 --> 00:04:28,250
context to finish the operation you were

00:04:25,250 --> 00:04:29,750
just working off it's the simple

00:04:28,250 --> 00:04:31,039
emulation path we always do for pretty

00:04:29,750 --> 00:04:32,569
much every device we have there's a

00:04:31,039 --> 00:04:33,349
couple of alternatives to it and

00:04:32,569 --> 00:04:36,020
sometimes you can do things

00:04:33,349 --> 00:04:39,289
asynchronously but in a nutshell you're

00:04:36,020 --> 00:04:41,719
going through all those layers you can

00:04:39,289 --> 00:04:45,159
do shortcuts if you do direct device

00:04:41,719 --> 00:04:47,360
assignment using say bfayolle instead of

00:04:45,159 --> 00:04:48,889
taking hardware into responsibilities of

00:04:47,360 --> 00:04:50,389
the host you pass it straight on to the

00:04:48,889 --> 00:04:53,509
guest or the guest has full control over

00:04:50,389 --> 00:04:55,729
hardware which means when you now do a

00:04:53,509 --> 00:04:58,490
hardware command that Hardware command

00:04:55,729 --> 00:05:00,699
can actually go to a hardware it sounds

00:04:58,490 --> 00:05:02,779
much easier right well that's a caveat

00:05:00,699 --> 00:05:05,870
the biggest problem that you have there

00:05:02,779 --> 00:05:07,580
is that suddenly you actually talk to

00:05:05,870 --> 00:05:09,139
hardware which means the guest needs to

00:05:07,580 --> 00:05:10,729
be aware of how to talk to that harpy

00:05:09,139 --> 00:05:12,319
you cannot emulate interfaces in between

00:05:10,729 --> 00:05:13,699
you can't just do video on that hardware

00:05:12,319 --> 00:05:19,520
unless you actually own the hardware as

00:05:13,699 --> 00:05:20,599
well you can however combine those two

00:05:19,520 --> 00:05:22,490
approaches even so there have been

00:05:20,599 --> 00:05:24,620
people and approaches you have probably

00:05:22,490 --> 00:05:27,680
seen Felipe's talk on how to accelerate

00:05:24,620 --> 00:05:29,569
device simulation using SPD kay there

00:05:27,680 --> 00:05:32,089
are approaches where you can have user

00:05:29,569 --> 00:05:34,099
space on the host directly on that hard

00:05:32,089 --> 00:05:36,680
race you at least circumvent the kernel

00:05:34,099 --> 00:05:38,599
layer in between and then your device

00:05:36,680 --> 00:05:40,849
simulation still goes from the guest

00:05:38,599 --> 00:05:43,370
kernel into or your device access

00:05:40,849 --> 00:05:45,139
instead of gas kernel onto KVM into that

00:05:43,370 --> 00:05:46,960
user space but then you don't have to go

00:05:45,139 --> 00:05:49,689
all the kernel out on the host again

00:05:46,960 --> 00:05:52,279
which can accelerate things quite a bit

00:05:49,689 --> 00:05:54,080
now if you keep thinking that train of

00:05:52,279 --> 00:05:55,599
thought if you think well I have a user

00:05:54,080 --> 00:05:56,750
space process that can actually

00:05:55,599 --> 00:05:58,430
dedicatedly

00:05:56,750 --> 00:06:00,229
access hardware and I have hardware that

00:05:58,430 --> 00:06:02,569
can be virtualized and so I can have

00:06:00,229 --> 00:06:03,979
different virtual functions for my

00:06:02,569 --> 00:06:06,830
different tenants on my system for my

00:06:03,979 --> 00:06:08,300
virtual machines why don't I just put

00:06:06,830 --> 00:06:10,969
all of that code that still gives me the

00:06:08,300 --> 00:06:14,349
big attack surface why don't just move

00:06:10,969 --> 00:06:17,710
all of this code into the guest the

00:06:14,349 --> 00:06:20,419
interface to have a guest access

00:06:17,710 --> 00:06:24,229
hardware it's already existent we have

00:06:20,419 --> 00:06:26,650
VFL so the piece down here is easy we do

00:06:24,229 --> 00:06:28,969
have traps when we try to access code so

00:06:26,650 --> 00:06:31,399
maybe we can just actually push all that

00:06:28,969 --> 00:06:33,139
X or the emulation code to translate

00:06:31,399 --> 00:06:34,249
from one interface to another into guest

00:06:33,139 --> 00:06:36,169
context itself and nice

00:06:34,249 --> 00:06:39,349
the fit of that would be that if there's

00:06:36,169 --> 00:06:42,079
a buck in their code well your tech

00:06:39,349 --> 00:06:44,209
service kind of is the exact same as if

00:06:42,079 --> 00:06:47,749
the guests had a buck so you don't

00:06:44,209 --> 00:06:50,779
necessarily escape the guest boundary

00:06:47,749 --> 00:06:53,899
into another guest on the same host make

00:06:50,779 --> 00:06:55,699
sense okay let's let's walk through how

00:06:53,899 --> 00:06:58,489
this would work so let's look at a pie

00:06:55,699 --> 00:07:02,299
or request for IO requires typical x86

00:06:58,489 --> 00:07:04,699
thing you have an outlaw out there that

00:07:02,299 --> 00:07:07,909
the Linux kernel would trigger that

00:07:04,699 --> 00:07:09,439
outlaw would go and spawn a VM exit so

00:07:07,909 --> 00:07:11,479
you're running in KVM context now at

00:07:09,439 --> 00:07:14,779
inside of k vm what we can do is we can

00:07:11,479 --> 00:07:16,849
just inject an SMI into the gas instead

00:07:14,779 --> 00:07:17,929
of handing that portal request which

00:07:16,849 --> 00:07:20,329
gets us into a completely different

00:07:17,929 --> 00:07:22,999
context inside of the guest enter SMM

00:07:20,329 --> 00:07:25,969
context inside the guest now once we

00:07:22,999 --> 00:07:26,569
Ness mmm context we can start to do

00:07:25,969 --> 00:07:28,939
whatever we like

00:07:26,569 --> 00:07:32,209
based on that pork request say in mio

00:07:28,939 --> 00:07:36,019
over to hardware that goes into real

00:07:32,209 --> 00:07:37,729
hardware we finish it you spawn an RSM

00:07:36,019 --> 00:07:41,269
at the end to return from that system

00:07:37,729 --> 00:07:45,019
management mode back into normal guest

00:07:41,269 --> 00:07:45,769
operating system and that gets us back

00:07:45,019 --> 00:07:47,599
into the guest

00:07:45,769 --> 00:07:49,039
so there we basically have the same

00:07:47,599 --> 00:07:50,899
switch that we had before with km you

00:07:49,039 --> 00:07:53,839
just that instead of switching from

00:07:50,899 --> 00:07:57,169
guest to host to user space we switch on

00:07:53,839 --> 00:08:03,110
guests to host to guest as a memoed and

00:07:57,169 --> 00:08:06,079
then back Mao is more fun

00:08:03,110 --> 00:08:09,439
Mao same concept you basically have a

00:08:06,079 --> 00:08:13,249
move from some some access to to to

00:08:09,439 --> 00:08:15,169
memory and you want to also trap that

00:08:13,249 --> 00:08:18,619
the way this gets trapped is that in KVM

00:08:15,169 --> 00:08:20,779
we actually have a VM exit on a page

00:08:18,619 --> 00:08:22,219
fault in a nested page fault because the

00:08:20,779 --> 00:08:23,719
way mio gets handled is that we

00:08:22,219 --> 00:08:26,119
basically assume that pages that are not

00:08:23,719 --> 00:08:28,729
backed by memory are all handled by

00:08:26,119 --> 00:08:31,039
hardware so we now have a page fault

00:08:28,729 --> 00:08:32,419
inside of k vm and we don't know

00:08:31,039 --> 00:08:33,800
anything beyond that page what we just

00:08:32,419 --> 00:08:35,990
know somebody was trying to access

00:08:33,800 --> 00:08:37,490
memory at an address that didn't work

00:08:35,990 --> 00:08:41,679
sometimes there's some hints but usually

00:08:37,490 --> 00:08:45,350
it's pretty secretive so we can still

00:08:41,679 --> 00:08:46,819
inject that SMI into the guest but now

00:08:45,350 --> 00:08:47,850
there's this additional piece of code

00:08:46,819 --> 00:08:49,800
that we need to run

00:08:47,850 --> 00:08:51,949
which is called an x86 emulator which

00:08:49,800 --> 00:08:54,480
usually happens to live inside of KVM

00:08:51,949 --> 00:08:56,759
but using the technique we can now move

00:08:54,480 --> 00:08:58,889
it from this really really privileged

00:08:56,759 --> 00:09:01,110
world over here in KVM in the host

00:08:58,889 --> 00:09:02,819
kernel over into this really really

00:09:01,110 --> 00:09:04,230
unprivileged world which is inside the

00:09:02,819 --> 00:09:06,720
guest context and the end life that we

00:09:04,230 --> 00:09:08,430
just created so we put egg a lot of

00:09:06,720 --> 00:09:12,120
attack surface and move it all the way

00:09:08,430 --> 00:09:13,529
into the guest itself that actually x86

00:09:12,120 --> 00:09:14,970
animator can translate it over into a

00:09:13,529 --> 00:09:17,370
request that we can handle the device

00:09:14,970 --> 00:09:19,319
simulation code can parse that can cause

00:09:17,370 --> 00:09:22,050
a reaction say I need to do another mio

00:09:19,319 --> 00:09:25,380
onto my real hardware and then you just

00:09:22,050 --> 00:09:28,170
go back into the host which then does

00:09:25,380 --> 00:09:31,519
using the RSM trap goes back into the

00:09:28,170 --> 00:09:34,110
guest into normal execution mode the

00:09:31,519 --> 00:09:37,319
most interesting part in my book or the

00:09:34,110 --> 00:09:39,690
most surprising one for my for my for my

00:09:37,319 --> 00:09:41,759
point of view was I accused so we also

00:09:39,690 --> 00:09:43,769
have the other path around that a device

00:09:41,759 --> 00:09:45,810
wants to tell you well I do have new

00:09:43,769 --> 00:09:49,110
data you should really pick that up how

00:09:45,810 --> 00:09:51,149
do you pass that on to your to your

00:09:49,110 --> 00:09:52,500
guest when the interface is completely

00:09:51,149 --> 00:09:54,269
different from the real hopper you were

00:09:52,500 --> 00:09:57,810
passing through well it turns out

00:09:54,269 --> 00:09:59,130
there's a nice interface msi axe might

00:09:57,810 --> 00:10:01,709
finish of your hardware these days uses

00:09:59,130 --> 00:10:03,060
em I say MSI X and msi X has a feature

00:10:01,709 --> 00:10:06,420
we can tell msi ax

00:10:03,060 --> 00:10:08,430
well don't target a normal vector just

00:10:06,420 --> 00:10:10,620
hug it a semis right you can actually

00:10:08,430 --> 00:10:14,819
configure your msi I miss our X vector

00:10:10,620 --> 00:10:17,880
to directly inject an SMI into your

00:10:14,819 --> 00:10:20,029
guest well so we inject an SMI based on

00:10:17,880 --> 00:10:22,079
k vm k vm gets that interrupt right and

00:10:20,029 --> 00:10:31,680
injection as a mind to the guest for us

00:10:22,079 --> 00:10:35,100
john deere paulo was asking if you can

00:10:31,680 --> 00:10:41,339
use the IMU to remap the iock you to our

00:10:35,100 --> 00:10:43,560
host iock you wait a second so i got the

00:10:41,339 --> 00:10:44,339
i got this the microphone to to talk for

00:10:43,560 --> 00:10:45,779
for the audience

00:10:44,339 --> 00:10:47,399
however we just do this after the

00:10:45,779 --> 00:10:51,149
presentation and i want to over to you

00:10:47,399 --> 00:10:55,100
and use an ask awesome so we get through

00:10:51,149 --> 00:10:55,100
all 79 slides

00:10:55,430 --> 00:11:00,410
why do you want to do this it's a couple

00:10:58,250 --> 00:11:03,200
of benefits the most obvious one that I

00:11:00,410 --> 00:11:05,450
was stressing all over is security right

00:11:03,200 --> 00:11:07,070
you basically take your evil attacker

00:11:05,450 --> 00:11:08,600
that can go and attack your users place

00:11:07,070 --> 00:11:09,650
so you have to secure two boundaries you

00:11:08,600 --> 00:11:12,260
have to secure the hosts and guests

00:11:09,650 --> 00:11:14,120
boundary as well as the user space host

00:11:12,260 --> 00:11:16,160
kernel boundary you certainly take all

00:11:14,120 --> 00:11:17,840
of that attack surface and push it all

00:11:16,160 --> 00:11:19,430
down into the guest which means you only

00:11:17,840 --> 00:11:21,440
have to worry about a single attack

00:11:19,430 --> 00:11:25,970
surface at this point anymore the host

00:11:21,440 --> 00:11:30,140
guest boundary but there's more so we do

00:11:25,970 --> 00:11:31,880
have things like hyper threats and one

00:11:30,140 --> 00:11:33,950
core usually on x86 happens to have two

00:11:31,880 --> 00:11:35,270
of those so what happens when you have

00:11:33,950 --> 00:11:37,310
two hyper threats and you have a guest

00:11:35,270 --> 00:11:38,810
and the host line well as long as those

00:11:37,310 --> 00:11:40,250
two hyper threading on inside guest

00:11:38,810 --> 00:11:42,770
context everything's fine right the

00:11:40,250 --> 00:11:45,470
guest can possibly like maybe leak data

00:11:42,770 --> 00:11:47,090
or influence the other sibling threat of

00:11:45,470 --> 00:11:49,160
the guest but that's usually okay for me

00:11:47,090 --> 00:11:51,710
from a host point of view the big

00:11:49,160 --> 00:11:55,190
problem is that when you exit that guest

00:11:51,710 --> 00:11:58,400
what happens well as long as you in KVM

00:11:55,190 --> 00:12:00,350
context there are some that's there's

00:11:58,400 --> 00:12:01,790
some progress with advertised isolation

00:12:00,350 --> 00:12:03,590
and such where you can actually be

00:12:01,790 --> 00:12:06,260
reasonably sure that as long as you are

00:12:03,590 --> 00:12:11,030
handling some exit inside of the host

00:12:06,260 --> 00:12:13,610
you are safe but as soon at least I mean

00:12:11,030 --> 00:12:15,500
the the you basically guarantee that as

00:12:13,610 --> 00:12:17,300
soon as you go out of the KVM context

00:12:15,500 --> 00:12:20,750
and the normal general purpose linux and

00:12:17,300 --> 00:12:23,840
even worse in the user space you open up

00:12:20,750 --> 00:12:26,450
spectra edges all over the place and you

00:12:23,840 --> 00:12:28,610
can basically leak data from the whole

00:12:26,450 --> 00:12:29,990
host operating system over into the

00:12:28,610 --> 00:12:33,020
gasps which basically means you could

00:12:29,990 --> 00:12:34,670
possibly leak data from another virtual

00:12:33,020 --> 00:12:36,350
machine from another hole approach

00:12:34,670 --> 00:12:37,940
that's running on the host over into

00:12:36,350 --> 00:12:40,640
your other threat there are some

00:12:37,940 --> 00:12:43,010
mitigation certain you can isolate the

00:12:40,640 --> 00:12:44,390
problem set but the basic fundamental

00:12:43,010 --> 00:12:47,140
problem still stands that device

00:12:44,390 --> 00:12:50,990
simulation code needs to essentially

00:12:47,140 --> 00:12:52,760
move your other sibling hyper thread out

00:12:50,990 --> 00:12:57,500
of execution as long as you're running

00:12:52,760 --> 00:13:00,350
in the host now if we move all the

00:12:57,500 --> 00:13:02,030
simulation code into the guest or worst

00:13:00,350 --> 00:13:04,010
thing that happens is you suddenly leak

00:13:02,030 --> 00:13:05,990
guest data you never have the ability

00:13:04,010 --> 00:13:08,000
even to access anything on the host

00:13:05,990 --> 00:13:09,190
because you're still confined into your

00:13:08,000 --> 00:13:12,890
guest environment

00:13:09,190 --> 00:13:15,050
so security-wise is even better because

00:13:12,890 --> 00:13:19,730
there's simply no Specter left to worry

00:13:15,050 --> 00:13:21,890
about in that path another interesting

00:13:19,730 --> 00:13:23,930
side effect of it is imagine you have

00:13:21,890 --> 00:13:26,180
life migration right you want to move a

00:13:23,930 --> 00:13:28,880
virtual machine from one host to another

00:13:26,180 --> 00:13:30,560
host it usually means that you need to

00:13:28,880 --> 00:13:33,860
serialize all of the information that

00:13:30,560 --> 00:13:35,960
you have that describes device stay that

00:13:33,860 --> 00:13:38,390
divides describe CPU State memory state

00:13:35,960 --> 00:13:41,810
etc etc so you have to serialize guest

00:13:38,390 --> 00:13:43,400
state like CPU memory and such and then

00:13:41,810 --> 00:13:45,830
you also have to serialize device stay

00:13:43,400 --> 00:13:48,680
that lives in that user space piece now

00:13:45,830 --> 00:13:50,780
if you move your device simulation into

00:13:48,680 --> 00:13:52,610
guest context that lives in guest

00:13:50,780 --> 00:13:54,770
register space and that lives in guest

00:13:52,610 --> 00:13:56,420
memory space it basically means you get

00:13:54,770 --> 00:13:58,250
all the live migration abilities for

00:13:56,420 --> 00:13:59,720
free you don't have to see realize your

00:13:58,250 --> 00:14:01,220
device Malaysian code anymore it just

00:13:59,720 --> 00:14:03,050
automatically gets serialized and

00:14:01,220 --> 00:14:05,560
transferred so you don't have to worry

00:14:03,050 --> 00:14:07,880
about live migration it just works

00:14:05,560 --> 00:14:10,820
but it's not all nice and dandy there a

00:14:07,880 --> 00:14:12,860
couple of downsides the most obvious one

00:14:10,820 --> 00:14:16,760
is what happens when you encrypt all

00:14:12,860 --> 00:14:19,400
your memory hmm how do you how do you

00:14:16,760 --> 00:14:21,589
define the trust boundary of I want to

00:14:19,400 --> 00:14:23,330
have a guest kernel that can now define

00:14:21,589 --> 00:14:25,310
that it no longer wants to have anything

00:14:23,330 --> 00:14:27,020
else look at the guest context but then

00:14:25,310 --> 00:14:29,240
we do have to have device simulation

00:14:27,020 --> 00:14:31,400
code in the guest which looks at guest

00:14:29,240 --> 00:14:33,500
context code it gets difficult

00:14:31,400 --> 00:14:34,580
I'm sure to solve the problem we can

00:14:33,500 --> 00:14:38,450
certainly talk about that one on the

00:14:34,580 --> 00:14:42,260
both Nesta virtualization you basically

00:14:38,450 --> 00:14:45,380
need to start introducing nested

00:14:42,260 --> 00:14:47,720
information into your SMM handling so

00:14:45,380 --> 00:14:49,250
that SMM can be potentially triggered

00:14:47,720 --> 00:14:53,870
when your nesting because you might

00:14:49,250 --> 00:14:56,210
trigger an SMM exception say a an MAO

00:14:53,870 --> 00:14:59,060
handling a pareo handling while you are

00:14:56,210 --> 00:15:00,290
inside of a nested guests so that and

00:14:59,060 --> 00:15:01,670
also we assume that again and to

00:15:00,290 --> 00:15:04,610
actually interpret all of the page

00:15:01,670 --> 00:15:06,860
tables within that you need to start

00:15:04,610 --> 00:15:08,780
worry about nesting more than you did

00:15:06,860 --> 00:15:10,820
before and then that's the boob loophole

00:15:08,780 --> 00:15:13,580
problem it's not a really big one you

00:15:10,820 --> 00:15:16,160
can possibly do that before already but

00:15:13,580 --> 00:15:19,420
you essentially give another attack

00:15:16,160 --> 00:15:19,420
vector to an attacker to

00:15:21,590 --> 00:15:29,460
injects code that is invisible from the

00:15:25,560 --> 00:15:30,840
guests itself it's possible without that

00:15:29,460 --> 00:15:31,620
virtualization technique so you can do

00:15:30,840 --> 00:15:34,140
that without as well

00:15:31,620 --> 00:15:35,460
you can run something like a VMware

00:15:34,140 --> 00:15:37,080
binary translator and the guest and it

00:15:35,460 --> 00:15:38,700
wouldn't see that it's actually getting

00:15:37,080 --> 00:15:40,500
better translated but it's this one is

00:15:38,700 --> 00:15:43,740
much more stealthy so it says there's

00:15:40,500 --> 00:15:46,920
some minimal problematic scenario there

00:15:43,740 --> 00:15:49,140
that you can think of the proof of

00:15:46,920 --> 00:15:52,110
concept that I just quickly hacked up is

00:15:49,140 --> 00:15:55,170
an ad ee on nvme emulator so imagine you

00:15:52,110 --> 00:15:57,600
basically want to have an IDE adapter

00:15:55,170 --> 00:16:01,140
and exposed into the guest but the host

00:15:57,600 --> 00:16:02,490
only has an nvme adapter so what this is

00:16:01,140 --> 00:16:04,710
a screenshot of what I did

00:16:02,490 --> 00:16:08,820
you can basically pass through an nvme

00:16:04,710 --> 00:16:11,190
device up there I actually passed

00:16:08,820 --> 00:16:13,290
through a real nvme device using via

00:16:11,190 --> 00:16:16,350
file so this is driving a real nvme

00:16:13,290 --> 00:16:18,270
adapter and inside the guest you can see

00:16:16,350 --> 00:16:20,580
it shows up as SDA so it actually runs

00:16:18,270 --> 00:16:24,810
all of QM use ID emulation code inside

00:16:20,580 --> 00:16:26,160
off guest SMM code to then expose an IDE

00:16:24,810 --> 00:16:28,830
device to the guest without the guest

00:16:26,160 --> 00:16:30,900
even noticing it's just in a film where

00:16:28,830 --> 00:16:32,250
module which I can show you so I have

00:16:30,900 --> 00:16:37,170
another two minutes to get here demo

00:16:32,250 --> 00:16:38,760
let's hope pray to the get demo gods so

00:16:37,170 --> 00:16:40,350
this is the demo it's the exact same

00:16:38,760 --> 00:16:44,310
command line as you saw before same

00:16:40,350 --> 00:16:48,230
machine even I'm basically just running

00:16:44,310 --> 00:16:50,730
a efi module in a normal vaginal machine

00:16:48,230 --> 00:16:54,930
that injects my device simulation code

00:16:50,730 --> 00:16:56,730
and then I just pass through this nvme

00:16:54,930 --> 00:16:58,470
device from the host into the guest

00:16:56,730 --> 00:17:03,090
where I preload it an operating system

00:16:58,470 --> 00:17:06,900
on to so you see EFI boots up it loads

00:17:03,090 --> 00:17:09,270
that efi module from network which then

00:17:06,900 --> 00:17:10,829
gets executed so that one scroll through

00:17:09,270 --> 00:17:13,730
too quickly so they I could execute it

00:17:10,829 --> 00:17:17,130
gives you a bit of debug output and

00:17:13,730 --> 00:17:19,319
inside of the boot manager you can now

00:17:17,130 --> 00:17:22,350
see that we actually have an IDE drive

00:17:19,319 --> 00:17:25,530
exposed inside of efi in the guest equal

00:17:22,350 --> 00:17:29,390
to it is originally an nvme device which

00:17:25,530 --> 00:17:29,390
can boot just fine so

00:17:30,900 --> 00:17:41,080
let me just quickly does it work yeah

00:17:36,570 --> 00:17:42,280
the screen is way too big for me so we

00:17:41,080 --> 00:17:44,110
cannot just boot up a normal in

00:17:42,280 --> 00:17:45,760
operating system hammering on the IDE

00:17:44,110 --> 00:17:48,190
drive it actually looks like a normal

00:17:45,760 --> 00:17:49,750
IDE device it performs about as well as

00:17:48,190 --> 00:17:51,760
you would expect on an IDE device it

00:17:49,750 --> 00:17:55,150
performance-wise IDE is terrible either

00:17:51,760 --> 00:17:58,690
way you don't actually realize emulation

00:17:55,150 --> 00:18:00,610
code in there so with that any questions

00:17:58,690 --> 00:18:02,050
I can run over to you with a microphone

00:18:00,610 --> 00:18:08,140
and then you can have a stencil

00:18:02,050 --> 00:18:12,220
Sao Paulo had the first one so the

00:18:08,140 --> 00:18:14,700
target SMI entry is set in the

00:18:12,220 --> 00:18:19,570
virtualized the messiah x table right

00:18:14,700 --> 00:18:23,400
second so the the target SMI field is

00:18:19,570 --> 00:18:28,990
set in the guests virtual MSI X table

00:18:23,400 --> 00:18:32,650
how is that how does that map to an IRT

00:18:28,990 --> 00:18:35,680
in in the interrupt right in table entry

00:18:32,650 --> 00:18:37,750
it doesn't so for our eyes you cannot do

00:18:35,680 --> 00:18:40,000
Iowa T's because ASA don't get posted

00:18:37,750 --> 00:18:41,970
interrupts for photos SMI vectors that

00:18:40,000 --> 00:18:45,760
was the patch I said a couple weeks ago

00:18:41,970 --> 00:18:47,440
you cannot do SM eyes with i YT because

00:18:45,760 --> 00:18:48,820
I ort can only inject normal into

00:18:47,440 --> 00:18:50,680
effectors so you basically have to

00:18:48,820 --> 00:18:52,780
trampoline that via a host interrupt

00:18:50,680 --> 00:18:54,400
vector that is not as a my okay so

00:18:52,780 --> 00:18:57,460
here's a my part but also this house

00:18:54,400 --> 00:18:59,200
inside of KBM so the the host doesn't

00:18:57,460 --> 00:19:01,630
use the interpreter mapping for this

00:18:59,200 --> 00:19:05,820
correct correct this do not use

00:19:01,630 --> 00:19:05,820
interfacing of my question yeah

00:19:10,090 --> 00:19:15,799
so performance was missing on your

00:19:13,670 --> 00:19:18,230
downsides but you did mention that it

00:19:15,799 --> 00:19:20,540
achieves IDE performance it seems like a

00:19:18,230 --> 00:19:24,380
pretty big latency hit though to trap

00:19:20,540 --> 00:19:26,150
through SMI can you discuss any general

00:19:24,380 --> 00:19:27,860
performance versus direct assignment

00:19:26,150 --> 00:19:31,400
let's let's think this through a bit do

00:19:27,860 --> 00:19:34,040
you have to trap through SMI example

00:19:31,400 --> 00:19:36,620
yeah you have to check my resume for the

00:19:34,040 --> 00:19:39,740
portal week rest that go to KVM but

00:19:36,620 --> 00:19:42,620
that's the exact same like distance as

00:19:39,740 --> 00:19:44,179
the CMU user spaces especially if you

00:19:42,620 --> 00:19:46,220
take all the spectra mitigations into

00:19:44,179 --> 00:19:50,179
account where all those switches become

00:19:46,220 --> 00:19:53,000
much slower again right however for the

00:19:50,179 --> 00:19:55,880
device to guest injection you don't

00:19:53,000 --> 00:19:59,600
necessarily have to you don't

00:19:55,880 --> 00:20:01,700
necessarily have to use in SMI you could

00:19:59,600 --> 00:20:04,160
actually reprogram it as a normal

00:20:01,700 --> 00:20:05,660
interrupt vector inside of the gas

00:20:04,160 --> 00:20:08,179
because you do know that the first

00:20:05,660 --> 00:20:10,070
request you get will be a porter a

00:20:08,179 --> 00:20:11,330
request to figure the device status or

00:20:10,070 --> 00:20:13,309
the interrupts others off the device at

00:20:11,330 --> 00:20:14,809
which point you can lazily adapt to the

00:20:13,309 --> 00:20:17,210
interrupt so it you don't necessarily

00:20:14,809 --> 00:20:19,640
have to you can you can actually inject

00:20:17,210 --> 00:20:21,260
an nvme finish interrupt as a normal

00:20:19,640 --> 00:20:24,610
vector into the guest at which point you

00:20:21,260 --> 00:20:24,610
actually get an IRT mapping again

00:20:28,360 --> 00:20:32,720
correct great so for the Oh myoh and

00:20:30,740 --> 00:20:35,299
podo path is you you have to trap into

00:20:32,720 --> 00:20:37,549
the guest yes there's no way around it

00:20:35,299 --> 00:20:40,220
but again it's the same as trapping into

00:20:37,549 --> 00:20:41,720
key mu and like going back from it it's

00:20:40,220 --> 00:20:44,600
a bit more latency it actually is a

00:20:41,720 --> 00:20:47,540
slowdown in comparison to to just a cure

00:20:44,600 --> 00:20:49,460
user space path the question is just how

00:20:47,540 --> 00:20:50,840
important is that Jesus mostly for

00:20:49,460 --> 00:20:53,480
legacy devices at least that's why I

00:20:50,840 --> 00:20:55,400
envisioned it for in from those

00:20:53,480 --> 00:20:57,110
performance is definitely not on the

00:20:55,400 --> 00:20:58,370
critical path especially not the latency

00:20:57,110 --> 00:21:01,480
of the instructions it's slow either way

00:20:58,370 --> 00:21:01,480
it's even slow on real hardware

00:21:02,140 --> 00:21:06,910
basically a segue into that did you look

00:21:04,250 --> 00:21:08,660
into using something other than SMI

00:21:06,910 --> 00:21:11,179
specifically so that you could enlighten

00:21:08,660 --> 00:21:13,820
the guest and do it direct instead of

00:21:11,179 --> 00:21:16,520
doing the out for example do a direct

00:21:13,820 --> 00:21:18,260
call or jump or some form of control

00:21:16,520 --> 00:21:20,230
transfer sir don't don't take away next

00:21:18,260 --> 00:21:23,300
to us talk

00:21:20,230 --> 00:21:25,070
the reason I asked you guys know that's

00:21:23,300 --> 00:21:27,680
that's a couple very similar code in

00:21:25,070 --> 00:21:32,030
very very similar ways for completely

00:21:27,680 --> 00:21:33,860
different reasons so there are other

00:21:32,030 --> 00:21:36,410
ways you can use it there's a feature in

00:21:33,860 --> 00:21:39,290
on Intel CPUs called what it's called

00:21:36,410 --> 00:21:42,110
you can basically directly inject a

00:21:39,290 --> 00:21:43,460
nested page fault into the violation apt

00:21:42,110 --> 00:21:45,710
violations yes that's the ones you can

00:21:43,460 --> 00:21:47,750
abuse the violations but you can't

00:21:45,710 --> 00:21:50,930
really because apt violations still need

00:21:47,750 --> 00:21:52,820
to inject a normal ADT based vector so

00:21:50,930 --> 00:21:55,850
you need guest enlightenment for it but

00:21:52,820 --> 00:21:57,890
you could only guest if you have ideas

00:21:55,850 --> 00:21:59,840
on how to not have it let me know I

00:21:57,890 --> 00:22:03,200
don't want to be too hacky there so yes

00:21:59,840 --> 00:22:07,000
sure we could trap on any likes load IDT

00:22:03,200 --> 00:22:10,190
instruction and then intercept it like

00:22:07,000 --> 00:22:11,660
but I assume yes I was so you didn't

00:22:10,190 --> 00:22:12,860
have to enlighten but I was curious if

00:22:11,660 --> 00:22:14,210
you've gotten to the point where it

00:22:12,860 --> 00:22:16,430
starts implying that's correct

00:22:14,210 --> 00:22:18,770
SMI this path is basically a drop-in

00:22:16,430 --> 00:22:21,230
thing that just works yeah and then all

00:22:18,770 --> 00:22:23,030
the accelerations can come later so we

00:22:21,230 --> 00:22:25,040
can we can accelerate a lot we could we

00:22:23,030 --> 00:22:26,300
could just give them given the right

00:22:25,040 --> 00:22:29,660
indictments on the guest we could

00:22:26,300 --> 00:22:31,640
essentially make all this a call you

00:22:29,660 --> 00:22:33,380
could even like patch the reads and the

00:22:31,640 --> 00:22:34,520
right like the adults and whatever the

00:22:33,380 --> 00:22:37,420
poor tile things you could just patch

00:22:34,520 --> 00:22:37,420
these alternatives

00:22:42,909 --> 00:22:48,649
hi regarding the second benefit of light

00:22:45,590 --> 00:22:52,159
migration so so you mentioned the the

00:22:48,649 --> 00:22:53,480
the ease of passing the device infirmity

00:22:52,159 --> 00:22:56,509
the back in the best information from

00:22:53,480 --> 00:22:58,519
from the source to destination but the

00:22:56,509 --> 00:23:00,590
the other half of my progression is is

00:22:58,519 --> 00:23:03,379
the you know somehow need to to

00:23:00,590 --> 00:23:05,330
synchronize the the physical device and

00:23:03,379 --> 00:23:08,720
the destination to start from the same

00:23:05,330 --> 00:23:11,119
point yes so so these what was what I

00:23:08,720 --> 00:23:14,480
was working so that the other half of

00:23:11,119 --> 00:23:16,039
the of what happens when it's working

00:23:14,480 --> 00:23:17,869
hypothesis a how how would you address

00:23:16,039 --> 00:23:20,480
it in this case if it doesn't you have

00:23:17,869 --> 00:23:22,999
to have like like my gradable hardware

00:23:20,480 --> 00:23:27,019
devices that unpassed will already allow

00:23:22,999 --> 00:23:28,909
my craft migration so we see the same

00:23:27,019 --> 00:23:31,759
food is still need to pass device device

00:23:28,909 --> 00:23:33,769
state you still need the device state of

00:23:31,759 --> 00:23:35,869
the pass to device but you don't need

00:23:33,769 --> 00:23:44,090
the device state of the emulation device

00:23:35,869 --> 00:23:46,299
I see okay thank you creative stuff I'm

00:23:44,090 --> 00:23:49,369
blaming this on my limited imagination

00:23:46,299 --> 00:23:51,740
but I'm struggling to see the use cases

00:23:49,369 --> 00:23:53,360
where this is desirable instead of just

00:23:51,740 --> 00:23:56,330
passing through the device straightaway

00:23:53,360 --> 00:23:58,879
so if you need a real device to use that

00:23:56,330 --> 00:24:00,559
the idea with what other use cases you

00:23:58,879 --> 00:24:01,789
see that this is more interesting than

00:24:00,559 --> 00:24:06,289
just doing it straight device pass

00:24:01,789 --> 00:24:08,419
through so this is what cases where you

00:24:06,289 --> 00:24:10,190
need to so there's a couple of different

00:24:08,419 --> 00:24:13,879
areas and again we should just do a buff

00:24:10,190 --> 00:24:15,200
later on to stay there a couple of cases

00:24:13,879 --> 00:24:17,779
where this is important or interesting

00:24:15,200 --> 00:24:20,360
say what if you want to move all of the

00:24:17,779 --> 00:24:21,830
x86 emulator out of KVM into some other

00:24:20,360 --> 00:24:23,869
entity what if you want to move the i/o

00:24:21,830 --> 00:24:27,860
a pig out of KBM into some other entity

00:24:23,869 --> 00:24:30,230
what if you want to support a legacy

00:24:27,860 --> 00:24:32,600
device configuration that you don't have

00:24:30,230 --> 00:24:36,499
an Hardware anymore so you'd need to say

00:24:32,600 --> 00:24:38,600
implement vertol 0.9 on top of whatever

00:24:36,499 --> 00:24:44,029
your most amazing Mellanox adapter that

00:24:38,600 --> 00:24:45,830
you got now you you can basically use

00:24:44,029 --> 00:24:48,830
this as a mechanism to do legacy

00:24:45,830 --> 00:24:51,220
emulation without all the attack surface

00:24:48,830 --> 00:24:53,900
that usually drags emulation gets you

00:24:51,220 --> 00:25:00,020
that's that's the big big selling point

00:24:53,900 --> 00:25:01,760
I have got a half question for you Alex

00:25:00,020 --> 00:25:04,070
your slides are missing in the given

00:25:01,760 --> 00:25:05,870
forum site sorry sorry get your slides

00:25:04,070 --> 00:25:10,130
are missing from the caving forum site

00:25:05,870 --> 00:25:14,230
they are all gonna push them like I did

00:25:10,130 --> 00:25:18,830
not want to push incomplete slides okay

00:25:14,230 --> 00:25:20,160
that's not fair okay thank you

00:25:18,830 --> 00:25:23,550
thank you

00:25:20,160 --> 00:25:30,410
[Applause]

00:25:23,550 --> 00:25:30,410

YouTube URL: https://www.youtube.com/watch?v=CT3gfms_Ypo


