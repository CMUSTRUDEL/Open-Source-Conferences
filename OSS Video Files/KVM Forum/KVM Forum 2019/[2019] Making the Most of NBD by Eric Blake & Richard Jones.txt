Title: [2019] Making the Most of NBD by Eric Blake & Richard Jones
Publication date: 2019-11-09
Playlist: KVM Forum 2019
Description: 
	The Network Block Device (NBD) protocol dates back to Linux 2.1.55 in April 1997, pre-dating iSCSI as a means for block device access of remote storage. However, in more recent years, the protocol has seen a revival as virtualization scenarios have used and extended its features for a variety of tasks.

This talk will cover recent developments: new commands (WRITE_ZEROES, BLOCK_STATUS, RESIZE), encryption support (X.509 certificates, TLS PSK), multi-connection throughput enhancement, underlying protocol improvements (structured replies, 64-bit requests), and standardization efforts for a common URI naming representation.

Richard Jones and Eric Blake will also discuss performance improvements, and userspace libraries for easier integration of the NBD protocol into other projects (nbdkit, libnbd). A demonstration of some interesting nbdkit plugins and filters will tie it all together.

---

Richard Jones
Red Hat
Software Engineer

Richard Jones is a software engineer at Red Hat, working on virtualization and emerging technologies. He has contributed extensively to libguestfs and virt-v2v. He has spoken in past KVM Forums, and most recently about nbdkit at FOSDEM Feb 2019.

Eric Blake
Red Hat
Software Engineer

Eric Blake is a software engineer at Red Hat, working on block device management in virtualization. He has contributed extensively to qemu and libvirt. He has spoken in past KVM Forums, most recently about incremental backup through libvirt at KVM Forum Oct 2018.

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,740 --> 00:00:10,849
hi everyone we're gonna start now

00:00:14,150 --> 00:00:19,740
so I'm Richard Jones this is my

00:00:17,460 --> 00:00:20,910
colleague Eric Blake we're both from Red

00:00:19,740 --> 00:00:29,250
Hat's and we're gonna be talking about

00:00:20,910 --> 00:00:31,710
network block device MBD protocol so MBD

00:00:29,250 --> 00:00:36,690
network block device it was added to

00:00:31,710 --> 00:00:40,739
Linux 22 years ago 1997 cast your minds

00:00:36,690 --> 00:00:43,469
back it's very simple on the Left we've

00:00:40,739 --> 00:00:46,649
got a server MBD server and perhaps that

00:00:43,469 --> 00:00:48,710
servers got an extra disk or a spare

00:00:46,649 --> 00:00:51,600
partition and you want to make that

00:00:48,710 --> 00:00:55,410
appear on the client on the right as a

00:00:51,600 --> 00:00:57,480
as a virtual device dev MBD 0 these two

00:00:55,410 --> 00:00:59,160
servers you know they're not virtual

00:00:57,480 --> 00:01:02,340
machines they're real servers separated

00:00:59,160 --> 00:01:05,790
by a bit of Ethernet cable so this very

00:01:02,340 --> 00:01:09,299
simple protocol was added to Linux it

00:01:05,790 --> 00:01:11,580
has literally two commands read a block

00:01:09,299 --> 00:01:14,280
write a block but you can use that to

00:01:11,580 --> 00:01:18,240
make this virtual device appear so let's

00:01:14,280 --> 00:01:19,830
whine forward 22 years to today we've

00:01:18,240 --> 00:01:23,580
got a few more commands but it's still a

00:01:19,830 --> 00:01:25,619
fairly simple protocol we have other

00:01:23,580 --> 00:01:28,610
things that aren't in here like TLS

00:01:25,619 --> 00:01:31,500
support for encryption authentication

00:01:28,610 --> 00:01:33,299
we've got a few more servers these days

00:01:31,500 --> 00:01:36,030
so we probably have about four or five

00:01:33,299 --> 00:01:37,860
servers that implement something like

00:01:36,030 --> 00:01:40,829
the full spec and we have a similar

00:01:37,860 --> 00:01:42,329
number of clients as well but you can

00:01:40,829 --> 00:01:43,649
still use it in the same way if you want

00:01:42,329 --> 00:01:45,780
you can still have two servers you can

00:01:43,649 --> 00:01:47,670
export a block you know a disk from one

00:01:45,780 --> 00:01:50,790
and have it appear as a block device but

00:01:47,670 --> 00:01:53,250
in the virtualization community as a

00:01:50,790 --> 00:01:55,049
whole this isn't really how we use MBD

00:01:53,250 --> 00:01:58,799
these days so I've got a few examples of

00:01:55,049 --> 00:02:01,229
how we actually use MBD here's my first

00:01:58,799 --> 00:02:03,450
example we've got a cure mu virtual

00:02:01,229 --> 00:02:05,420
machine that's running you can use these

00:02:03,450 --> 00:02:09,899
commands to take a point-in-time

00:02:05,420 --> 00:02:12,660
snapshot that appears as an MBD server

00:02:09,899 --> 00:02:13,910
served by q mu and you can connect to it

00:02:12,660 --> 00:02:15,680
your backup

00:02:13,910 --> 00:02:18,680
solution and take a point in time back

00:02:15,680 --> 00:02:21,380
up from that we have a tool called verb

00:02:18,680 --> 00:02:24,920
be to be it's used to convert get

00:02:21,380 --> 00:02:28,250
running on VMware and converting to run

00:02:24,920 --> 00:02:29,840
on kbm and you know to get access to

00:02:28,250 --> 00:02:32,120
vmware we have to use this hideous

00:02:29,840 --> 00:02:34,040
proprietary library called BDD Kay and

00:02:32,120 --> 00:02:35,480
for various legal and licensing reasons

00:02:34,040 --> 00:02:38,390
we're not allowed to link it directly

00:02:35,480 --> 00:02:41,060
into vert b2v so what we do is we link

00:02:38,390 --> 00:02:43,670
it into an MPD server and then we're

00:02:41,060 --> 00:02:45,980
just using MBD as the protocol between

00:02:43,670 --> 00:02:48,680
these two processes running on the same

00:02:45,980 --> 00:02:52,220
machine so it's kind of a loopback NBD

00:02:48,680 --> 00:02:54,860
connection here's another example when

00:02:52,220 --> 00:02:57,230
we want to move workloads from different

00:02:54,860 --> 00:02:59,030
KVM based management system so you've

00:02:57,230 --> 00:03:00,740
got things like over-rev we've got

00:02:59,030 --> 00:03:02,780
things like OpenStack we've got things

00:03:00,740 --> 00:03:05,630
like couvert and we want to move those

00:03:02,780 --> 00:03:09,020
workloads between the systems they all

00:03:05,630 --> 00:03:12,530
use different protocols to access their

00:03:09,020 --> 00:03:15,410
disks and although we can use cue image

00:03:12,530 --> 00:03:16,820
convert to copy the disks from one

00:03:15,410 --> 00:03:19,820
machine to another we have to use

00:03:16,820 --> 00:03:22,730
separate MBD servers to talking with

00:03:19,820 --> 00:03:24,890
custom plugins to those protocols so in

00:03:22,730 --> 00:03:26,090
this case we've got three processes

00:03:24,890 --> 00:03:27,860
running on the same machine and we're

00:03:26,090 --> 00:03:30,980
using MBDA over those de loop back

00:03:27,860 --> 00:03:33,620
connections here's another example we've

00:03:30,980 --> 00:03:35,750
got over to stroke Rev has got a

00:03:33,620 --> 00:03:39,920
component called image i/o which exports

00:03:35,750 --> 00:03:43,550
disks over HTTP but it uses the backend

00:03:39,920 --> 00:03:45,650
QM BD which is QM whose MBD server and

00:03:43,550 --> 00:03:47,930
the reason it's using that simply

00:03:45,650 --> 00:03:49,550
because of the features of QM imbd you

00:03:47,930 --> 00:03:51,800
know it can access blocked devices and

00:03:49,550 --> 00:03:54,740
queue how to files and many other types

00:03:51,800 --> 00:03:56,810
of systems and again two processes

00:03:54,740 --> 00:04:00,320
running together MBD is running over a

00:03:56,810 --> 00:04:01,820
UNIX domain socket between those here's

00:04:00,320 --> 00:04:06,500
an example completely different one

00:04:01,820 --> 00:04:08,930
again this is how you boot a VM which is

00:04:06,500 --> 00:04:11,360
located on a web server like a disk

00:04:08,930 --> 00:04:13,160
image on a web server as X said

00:04:11,360 --> 00:04:16,340
compressed you can use this very long

00:04:13,160 --> 00:04:18,200
MBD kit command to boot it without even

00:04:16,340 --> 00:04:22,210
downloading the file without even

00:04:18,200 --> 00:04:25,430
uncompressing the here's another example

00:04:22,210 --> 00:04:27,169
MBD kit isn't just about getting access

00:04:25,430 --> 00:04:29,599
to existing disk images

00:04:27,169 --> 00:04:33,379
you can use it to create disk images

00:04:29,599 --> 00:04:37,279
from scratch I've got a much longer talk

00:04:33,379 --> 00:04:39,379
about this about writing device about

00:04:37,279 --> 00:04:41,810
writing a block devices in shell script

00:04:39,379 --> 00:04:43,310
if you look on YouTube there's a talk

00:04:41,810 --> 00:04:46,969
called better loot amounts of MBD which

00:04:43,310 --> 00:04:50,539
I gave it falls dem in February so what

00:04:46,969 --> 00:04:52,789
is MBD today if you want to think about

00:04:50,539 --> 00:04:55,460
mb d think about it as a universal

00:04:52,789 --> 00:04:58,060
protocol that you can use whenever you

00:04:55,460 --> 00:05:01,610
need to access a virtual machine disk

00:04:58,060 --> 00:05:04,789
disk image block device between two

00:05:01,610 --> 00:05:06,199
processes and as 22 years ago that might

00:05:04,789 --> 00:05:08,930
be two processes running on different

00:05:06,199 --> 00:05:12,469
machines but it could equally be two

00:05:08,930 --> 00:05:13,610
processes running on the same machine so

00:05:12,469 --> 00:05:16,219
now I'm going to hand it over to Eric

00:05:13,610 --> 00:05:17,840
and he's going to talk about optimizing

00:05:16,219 --> 00:05:19,219
that particular copying case that we

00:05:17,840 --> 00:05:23,360
have between the different KVM based

00:05:19,219 --> 00:05:25,969
management systems thank you well we

00:05:23,360 --> 00:05:29,499
know that cuman image convert takes one

00:05:25,969 --> 00:05:32,060
disk image and copies it to another but

00:05:29,499 --> 00:05:34,219
disk images are usually sparse there's

00:05:32,060 --> 00:05:36,560
usually lots of zeroes so right now I'm

00:05:34,219 --> 00:05:38,930
gonna create a disk image 100 megabytes

00:05:36,560 --> 00:05:40,460
how to be good I'm gonna stripe it I'm

00:05:38,930 --> 00:05:42,500
gonna put data every other megabyte

00:05:40,460 --> 00:05:45,279
leave the other megabytes holes so it

00:05:42,500 --> 00:05:48,620
now has 50 holes 1 megabyte each and

00:05:45,279 --> 00:05:52,039
I've written a little script again using

00:05:48,620 --> 00:05:55,339
NBD kits as our testbed this script

00:05:52,039 --> 00:05:59,060
copies from my source over to an NBD

00:05:55,339 --> 00:06:00,770
destination right now I've got no zero

00:05:59,060 --> 00:06:03,860
detection this is what state of the art

00:06:00,770 --> 00:06:06,169
was cuma three years ago we copied the

00:06:03,860 --> 00:06:08,089
entire disk by reading the source and

00:06:06,169 --> 00:06:11,449
writing the destination it took me about

00:06:08,089 --> 00:06:14,360
eight and a half seconds to do that all

00:06:11,449 --> 00:06:15,289
with 400 writes and we sat there and

00:06:14,360 --> 00:06:18,289
looked through each other and said

00:06:15,289 --> 00:06:20,330
that's a lot of zeros half of my image

00:06:18,289 --> 00:06:22,550
is all zeros and we just sent all of

00:06:20,330 --> 00:06:23,750
those zeros over the network so what if

00:06:22,550 --> 00:06:27,199
we add a new command

00:06:23,750 --> 00:06:28,490
NBD gained the right zeros command now

00:06:27,199 --> 00:06:31,250
all we have to do is send a single

00:06:28,490 --> 00:06:33,409
header and the destination gets that

00:06:31,250 --> 00:06:35,599
header and he can do a constant time

00:06:33,409 --> 00:06:38,000
operation poke a hole in the file and

00:06:35,599 --> 00:06:40,700
we've cut our time nearly in half four

00:06:38,000 --> 00:06:42,890
and a half seconds or maybe

00:06:40,700 --> 00:06:45,320
poking holes isn't efficient we have a

00:06:42,890 --> 00:06:47,960
server that takes that short command

00:06:45,320 --> 00:06:50,030
over the wire fills its own buffer of

00:06:47,960 --> 00:06:53,150
zeros passes it to the right back end

00:06:50,030 --> 00:06:56,420
and the back end

00:06:53,150 --> 00:06:59,000
hey 8.4 seconds 8.5 we did save some

00:06:56,420 --> 00:07:03,020
time we have less network traffic so

00:06:59,000 --> 00:07:05,870
either way we gained speed by adding the

00:07:03,020 --> 00:07:07,700
right zeros command we looked at each

00:07:05,870 --> 00:07:10,190
other and said can we do better than

00:07:07,700 --> 00:07:12,860
that let's add a block status command

00:07:10,190 --> 00:07:16,010
we're going to ask the destination do

00:07:12,860 --> 00:07:18,440
you already read zeroes if so I don't

00:07:16,010 --> 00:07:21,050
have to write to you and when the

00:07:18,440 --> 00:07:23,120
destination was already 0 yay we're just

00:07:21,050 --> 00:07:26,240
as fast or we gained a lot of speed with

00:07:23,120 --> 00:07:28,670
that slow server and then we realized oh

00:07:26,240 --> 00:07:30,590
if the data is there and we do have to

00:07:28,670 --> 00:07:33,620
flush the data out to zero we just

00:07:30,590 --> 00:07:37,750
doubled our i/o or add it a little bit

00:07:33,620 --> 00:07:42,140
or if block status itself is slow ouch

00:07:37,750 --> 00:07:45,320
Linux guys temp FS filesystem else seek

00:07:42,140 --> 00:07:48,590
seek hole is linear in the offset that

00:07:45,320 --> 00:07:51,200
you're probing which turns a linear path

00:07:48,590 --> 00:07:54,410
to the file into a quadratic copy yeah

00:07:51,200 --> 00:07:58,340
we didn't like that so cumin image

00:07:54,410 --> 00:08:00,740
convert does not use block status but

00:07:58,340 --> 00:08:02,510
the extension is used elsewhere in cumin

00:08:00,740 --> 00:08:05,900
we do like the extension we just weren't

00:08:02,510 --> 00:08:08,750
able to use it for our copying then we

00:08:05,900 --> 00:08:10,880
said well if reading whether it's sparse

00:08:08,750 --> 00:08:13,310
is inefficient what if we just make it

00:08:10,880 --> 00:08:16,850
sparse so about a year and a half ago

00:08:13,310 --> 00:08:19,990
qumu 3.1 if I'm remembering my versions

00:08:16,850 --> 00:08:22,370
we added a pass where we said just

00:08:19,990 --> 00:08:24,500
blanket write the entire image to zeroes

00:08:22,370 --> 00:08:28,220
and then go back and write the data in

00:08:24,500 --> 00:08:30,380
place Hey look we got better four and a

00:08:28,220 --> 00:08:33,320
half seconds turned into four point two

00:08:30,380 --> 00:08:34,940
five we shaved some time because instead

00:08:33,320 --> 00:08:37,360
of having to write fifty one megabyte

00:08:34,940 --> 00:08:39,680
holes we just wrote the entire image

00:08:37,360 --> 00:08:41,360
qumu has a limit right now where it does

00:08:39,680 --> 00:08:43,849
32 megabyte writes we have a hundred

00:08:41,360 --> 00:08:47,510
megabyte image thirty-two doesn't quite

00:08:43,849 --> 00:08:50,330
fit in without four rights but we fewer

00:08:47,510 --> 00:08:54,140
i/o over the network bigger writes we

00:08:50,330 --> 00:08:54,390
got faster or so we thought then we push

00:08:54,140 --> 00:08:56,340
the

00:08:54,390 --> 00:08:59,610
out to the users and we got reports hey

00:08:56,340 --> 00:09:01,860
my thing slowed down what'd you do to me

00:08:59,610 --> 00:09:04,530
and we said well it worked faster for us

00:09:01,860 --> 00:09:07,470
oh you must have one of those servers

00:09:04,530 --> 00:09:09,840
that does not have constant time zeroing

00:09:07,470 --> 00:09:11,580
it has the linear time zeroing we went

00:09:09,840 --> 00:09:15,060
from eight point three to twelve point

00:09:11,580 --> 00:09:17,580
five seconds because we're writing zeros

00:09:15,060 --> 00:09:20,460
and then rewriting the data double the

00:09:17,580 --> 00:09:23,850
i/o double the time for the data portion

00:09:20,460 --> 00:09:27,090
of the disk that's unacceptable so we

00:09:23,850 --> 00:09:29,100
had to back that out in queue me 4.0 but

00:09:27,090 --> 00:09:31,770
we looked at it and said well if we

00:09:29,100 --> 00:09:35,160
already knew that we were we don't want

00:09:31,770 --> 00:09:37,200
the slow prezi ruling but please you're

00:09:35,160 --> 00:09:38,970
wrong did speed up the fast what if we

00:09:37,200 --> 00:09:40,740
knew if there was a way so this is

00:09:38,970 --> 00:09:42,480
backing it out what if we knew if we

00:09:40,740 --> 00:09:45,990
were fast then we could get back to our

00:09:42,480 --> 00:09:49,350
fast constant time server and still not

00:09:45,990 --> 00:09:53,430
penalize our slow linear time server q

00:09:49,350 --> 00:09:57,390
you added a new feature in 4.0 and we

00:09:53,430 --> 00:10:00,420
finally implemented it with NBD before q

00:09:57,390 --> 00:10:02,700
mu 4.2 that's coming out soon and when

00:10:00,420 --> 00:10:05,250
we use that feature we can ask the

00:10:02,700 --> 00:10:07,770
server are you fast if it is great we'll

00:10:05,250 --> 00:10:09,900
finish zeroing the disk for fast zeroes

00:10:07,770 --> 00:10:12,600
and we were done we don't have to write

00:10:09,900 --> 00:10:14,910
any more zeroes or we asked the server

00:10:12,600 --> 00:10:17,310
are you fast the server says no but the

00:10:14,910 --> 00:10:19,290
server's answer is fast so we didn't

00:10:17,310 --> 00:10:23,160
lose any time then we proceeded just to

00:10:19,290 --> 00:10:25,710
use write zeros on the holes but 8.4

00:10:23,160 --> 00:10:30,390
seconds we didn't lose any time so this

00:10:25,710 --> 00:10:33,090
new feature was added as I said with key

00:10:30,390 --> 00:10:37,350
mu 4.2 coming out we also added Lib NBD

00:10:33,090 --> 00:10:39,270
that's our brand new user space library

00:10:37,350 --> 00:10:41,910
for connecting as an NBD client that we

00:10:39,270 --> 00:10:45,360
wrote this year we also added an NBD kit

00:10:41,910 --> 00:10:48,270
to a number of the existing plugins the

00:10:45,360 --> 00:10:50,070
noticeable absence the file plug-in does

00:10:48,270 --> 00:10:52,650
not have this and again because the

00:10:50,070 --> 00:10:54,390
kernel folks if you do F allocate to

00:10:52,650 --> 00:10:56,460
punch holes you don't know if it's going

00:10:54,390 --> 00:10:58,920
to punch fast or if the kernel is going

00:10:56,460 --> 00:11:00,660
to be helpful and write zeros on your

00:10:58,920 --> 00:11:03,240
behalf slowly if we could have another

00:11:00,660 --> 00:11:06,240
flag in F allocate or another flag with

00:11:03,240 --> 00:11:06,930
I octal to say do this if you can do it

00:11:06,240 --> 00:11:08,100
fast but

00:11:06,930 --> 00:11:10,709
error out quickly

00:11:08,100 --> 00:11:12,060
you can't it does help the Prezi rolling

00:11:10,709 --> 00:11:13,740
case and with that I'll give it back to

00:11:12,060 --> 00:11:19,589
rich for some more fun we can have with

00:11:13,740 --> 00:11:23,339
MBD kit so Eric actually live demoed

00:11:19,589 --> 00:11:25,380
just they're using MBD kit and MBD kit

00:11:23,339 --> 00:11:27,089
is great for testing and for demoing

00:11:25,380 --> 00:11:29,670
because you can write your own plugins

00:11:27,089 --> 00:11:32,819
or there's a whole ecosystem of plugins

00:11:29,670 --> 00:11:35,279
already for it that allow you to you

00:11:32,819 --> 00:11:38,130
know very flexibly write and test block

00:11:35,279 --> 00:11:41,310
devices so there's like a million things

00:11:38,130 --> 00:11:42,540
I could tell you about MBD kit we'd be

00:11:41,310 --> 00:11:43,380
here all night so I'm not going to do

00:11:42,540 --> 00:11:45,360
that I'm just going to show you some

00:11:43,380 --> 00:11:50,519
really fun strokes deeper stuff that you

00:11:45,360 --> 00:11:53,029
can do with NBD kits so the first one's

00:11:50,519 --> 00:11:56,880
serious the others are frivolous I

00:11:53,029 --> 00:12:02,160
talked before about using MBD kit with

00:11:56,880 --> 00:12:04,019
VDD K what that gives you is an NB d

00:12:02,160 --> 00:12:06,680
endpoint you connect a lot of different

00:12:04,019 --> 00:12:09,420
things to that so let's have a look at

00:12:06,680 --> 00:12:11,880
actually what that looks like so here

00:12:09,420 --> 00:12:16,649
I'm gonna run em BD kit the BD D K

00:12:11,880 --> 00:12:21,000
plugin and a local VMDK file and that

00:12:16,649 --> 00:12:23,880
gives me this m BD endpoint it's located

00:12:21,000 --> 00:12:27,319
at this URI one thing we've standardized

00:12:23,880 --> 00:12:29,790
as well as the protocol is the this URI

00:12:27,319 --> 00:12:31,740
specification so I can now connect m BD

00:12:29,790 --> 00:12:35,430
sure anybody shares a little Python

00:12:31,740 --> 00:12:40,740
shell and you can just type in basically

00:12:35,430 --> 00:12:44,430
m BD raw commands this is the command to

00:12:40,740 --> 00:12:46,589
read the first 512 bytes but it's also

00:12:44,430 --> 00:12:49,620
Python so you can just you can just use

00:12:46,589 --> 00:12:51,060
Python commands as well and you can use

00:12:49,620 --> 00:12:55,380
loops and everything else you need in

00:12:51,060 --> 00:12:56,910
Python I can also of course connect live

00:12:55,380 --> 00:13:00,089
guest refers to an MB the end point

00:12:56,910 --> 00:13:04,470
again using the same URI syntax and you

00:13:00,089 --> 00:13:08,279
can see that it's a fedora 17 guest and

00:13:04,470 --> 00:13:10,620
you can read it even write it and the

00:13:08,279 --> 00:13:14,100
last thing we can do is we can connect

00:13:10,620 --> 00:13:15,800
MVD fuse to the endpoint now MBD fuse

00:13:14,100 --> 00:13:18,650
turns the

00:13:15,800 --> 00:13:22,670
there's the MVD endpoint into a virtual

00:13:18,650 --> 00:13:25,520
file what I've done there is I've

00:13:22,670 --> 00:13:28,010
created this MBD file it's ten gigabytes

00:13:25,520 --> 00:13:30,500
it's a virtual file and you can read and

00:13:28,010 --> 00:13:32,060
write to that file and if you write to

00:13:30,500 --> 00:13:36,620
it the writes get reflected immediately

00:13:32,060 --> 00:13:38,720
back into the VMDK file so let's look at

00:13:36,620 --> 00:13:43,250
another frivolous thing we could do with

00:13:38,720 --> 00:13:48,290
MPD KITT I'm gonna create a directory on

00:13:43,250 --> 00:13:50,840
Eric's laptop here and put busybox in it

00:13:48,290 --> 00:13:53,590
am i doing with all those commands what

00:13:50,840 --> 00:13:55,310
does that look like so that looks like

00:13:53,590 --> 00:13:57,470
UNIX filesystem

00:13:55,310 --> 00:14:00,800
you've got a bin directory it's got a

00:13:57,470 --> 00:14:03,110
dev directory it's got s been busybox

00:14:00,800 --> 00:14:06,950
now what I can do in one single command

00:14:03,110 --> 00:14:09,380
is take that directory turn it into an

00:14:06,950 --> 00:14:12,400
ext4 filesystem put a partition around

00:14:09,380 --> 00:14:16,640
it and give that to Kier mu to boot

00:14:12,400 --> 00:14:20,450
there we go and Here I am in my busy box

00:14:16,640 --> 00:14:22,790
based virtual machine when you have busy

00:14:20,450 --> 00:14:25,040
box you have to run this install command

00:14:22,790 --> 00:14:27,710
which completes the rest of the busy box

00:14:25,040 --> 00:14:32,020
install inside the VM so now it's

00:14:27,710 --> 00:14:32,020
created all these commands from busy box

00:14:32,440 --> 00:14:36,320
next thing I can do here

00:14:34,370 --> 00:14:38,000
we have this concept called data disks

00:14:36,320 --> 00:14:40,490
data disks our disks which are quite

00:14:38,000 --> 00:14:42,620
simply specified entirely on the command

00:14:40,490 --> 00:14:45,170
line on the MVD command line and the way

00:14:42,620 --> 00:14:48,770
you do that is by listing the bytes in

00:14:45,170 --> 00:14:51,950
the disk at the end here you'll notice

00:14:48,770 --> 00:14:56,000
there are two bytes hex by 5 and hex a a

00:14:51,950 --> 00:14:57,620
I can see Kevin smiling there but those

00:14:56,000 --> 00:15:00,760
of you who know about boot sectors will

00:14:57,620 --> 00:15:03,200
know that this is a bootable boot sector

00:15:00,760 --> 00:15:07,010
and then using another MV diecut feature

00:15:03,200 --> 00:15:09,650
I can pass that to Keanu and boot it

00:15:07,010 --> 00:15:11,710
using the HDI option so wonder what this

00:15:09,650 --> 00:15:11,710
does

00:15:11,740 --> 00:15:16,580
interesting huh do you think I'm do you

00:15:14,960 --> 00:15:20,000
think that's a trick do you think I'm

00:15:16,580 --> 00:15:22,280
really doing that this is a demo by a

00:15:20,000 --> 00:15:25,880
very clever guy in cherubic called yank

00:15:22,280 --> 00:15:29,180
ad latch who wrote this as a ms-dos comm

00:15:25,880 --> 00:15:32,030
file in 256 bytes it really

00:15:29,180 --> 00:15:37,690
doing ray-tracing as well all I've done

00:15:32,030 --> 00:15:40,430
is to turn this into a boot sector and

00:15:37,690 --> 00:15:41,810
I'm the similar sort of vein there's

00:15:40,430 --> 00:15:46,600
another thing we can do so this is a

00:15:41,810 --> 00:15:49,550
thing we call reflection now NBD servers

00:15:46,600 --> 00:15:51,620
they don't just serve one disk image

00:15:49,550 --> 00:15:55,810
they can serve multiple disk images and

00:15:51,620 --> 00:15:58,850
the way it works is that you tell MBD

00:15:55,810 --> 00:16:01,820
the MD client tells the server which

00:15:58,850 --> 00:16:04,670
disk image it wants to access by sending

00:16:01,820 --> 00:16:08,660
an export name now using NVDA we can

00:16:04,670 --> 00:16:10,910
abuse this facility and send the send

00:16:08,660 --> 00:16:12,680
the export name to the server and then

00:16:10,910 --> 00:16:14,990
it have MBD kids send the export name

00:16:12,680 --> 00:16:16,190
back as a whole disk image and the

00:16:14,990 --> 00:16:18,710
important point about this is it allows

00:16:16,190 --> 00:16:21,740
us to specify an entire disk image on

00:16:18,710 --> 00:16:24,350
the QM command line so here I'm

00:16:21,740 --> 00:16:26,780
connecting qumu telling it to connect to

00:16:24,350 --> 00:16:30,220
an BD kit which is doing reflection and

00:16:26,780 --> 00:16:34,670
then in the export name here

00:16:30,220 --> 00:16:37,160
that's a base64 encoded disk image all

00:16:34,670 --> 00:16:39,560
of these examples come from Oscar Toledo

00:16:37,160 --> 00:16:43,670
Gutierrez's book about writing boot

00:16:39,560 --> 00:16:47,090
sector games here's one of them space

00:16:43,670 --> 00:16:54,920
invaders put in you actually played this

00:16:47,090 --> 00:16:55,880
game I've got another game because we're

00:16:54,920 --> 00:16:59,870
running out time it's going to very

00:16:55,880 --> 00:17:02,440
quickly show you one more game and let's

00:16:59,870 --> 00:17:02,440
do this one

00:17:04,210 --> 00:17:07,650
[Music]

00:17:10,970 --> 00:17:17,250
this finally handed back to Eric to

00:17:13,890 --> 00:17:22,169
finish off thank you I don't have any

00:17:17,250 --> 00:17:26,189
games here we want to use qko files with

00:17:22,169 --> 00:17:28,350
NBD there are two options we can say

00:17:26,189 --> 00:17:31,530
take my qk2 file

00:17:28,350 --> 00:17:33,059
and parse it with my server into raw

00:17:31,530 --> 00:17:35,429
bytes and those raw bytes over the

00:17:33,059 --> 00:17:38,250
network take those raw bytes and hand

00:17:35,429 --> 00:17:41,400
those raw bytes to the guest or we can

00:17:38,250 --> 00:17:44,940
say take my cue cow to file take those

00:17:41,400 --> 00:17:47,610
bytes as is pass my cue cow to file over

00:17:44,940 --> 00:17:49,530
the network and then at my client parse

00:17:47,610 --> 00:17:51,990
those cue cow to bytes into the raw

00:17:49,530 --> 00:17:53,789
bytes team but I did it now there's

00:17:51,990 --> 00:17:55,710
differences between them one of them if

00:17:53,789 --> 00:17:57,330
you pass a cue cow to data to the client

00:17:55,710 --> 00:17:59,850
then the client has everything cue cow

00:17:57,330 --> 00:18:03,030
to offers backing files you can change

00:17:59,850 --> 00:18:05,909
the guest size bitmaps you name it well

00:18:03,030 --> 00:18:08,100
it has everything insofar as you have

00:18:05,909 --> 00:18:11,760
the space we have this little problem

00:18:08,100 --> 00:18:14,610
where if the guest causes any action

00:18:11,760 --> 00:18:15,299
that needs to write a larger cue cow to

00:18:14,610 --> 00:18:18,240
file

00:18:15,299 --> 00:18:20,190
there's no pushback if you didn't

00:18:18,240 --> 00:18:22,530
precise your cue how to file big enough

00:18:20,190 --> 00:18:25,890
on the source the server says you're out

00:18:22,530 --> 00:18:27,030
of space and you're stuck so 99 percent

00:18:25,890 --> 00:18:28,919
of our documentation right now

00:18:27,030 --> 00:18:31,650
recommends that you export RAW files

00:18:28,919 --> 00:18:34,530
with RAW files well your guest can't

00:18:31,650 --> 00:18:37,470
resize we want to mix those two we want

00:18:34,530 --> 00:18:41,820
to have resize over NBD so the next

00:18:37,470 --> 00:18:45,150
feature we plan on adding to qq2 MBD kit

00:18:41,820 --> 00:18:46,650
to all of these is a resize feature now

00:18:45,150 --> 00:18:48,059
in implementing this we have to make

00:18:46,650 --> 00:18:49,799
some design decisions do we want to

00:18:48,059 --> 00:18:52,320
automatic like a file system where if

00:18:49,799 --> 00:18:54,659
you write beyond the file then the

00:18:52,320 --> 00:18:57,240
server automatically resizes it to care

00:18:54,659 --> 00:18:58,890
for you or may be way more explicit like

00:18:57,240 --> 00:19:00,960
a block device if you write beyond the

00:18:58,890 --> 00:19:04,230
end you fail but you can then use a

00:19:00,960 --> 00:19:06,059
resize command resize it explicitly in

00:19:04,230 --> 00:19:08,250
band or even with an out-of-band means

00:19:06,059 --> 00:19:10,530
have the server do a resize behind the

00:19:08,250 --> 00:19:14,280
behind your back and then when you retry

00:19:10,530 --> 00:19:17,250
now that it's bigger it succeeds we also

00:19:14,280 --> 00:19:18,990
have the MBD protocol the original

00:19:17,250 --> 00:19:20,970
protocol always answered with

00:19:18,990 --> 00:19:23,940
16-byte structure called the simple

00:19:20,970 --> 00:19:26,640
reply that gives you a yes-or-no answer

00:19:23,940 --> 00:19:29,580
I did your command or I failed with this

00:19:26,640 --> 00:19:31,380
err no which isn't very powerful so part

00:19:29,580 --> 00:19:33,210
of the additions we've added in the last

00:19:31,380 --> 00:19:34,860
three years with structured replies it's

00:19:33,210 --> 00:19:37,250
part of how we do block status but we

00:19:34,860 --> 00:19:39,960
would also use a structured reply for

00:19:37,250 --> 00:19:41,490
sizing we can then the server can answer

00:19:39,960 --> 00:19:43,170
and tell you I also have these

00:19:41,490 --> 00:19:45,690
additional eight bytes and that's the

00:19:43,170 --> 00:19:47,760
new size that I'm actually using so if

00:19:45,690 --> 00:19:50,250
the server rounded your request size up

00:19:47,760 --> 00:19:52,500
or even if you could say resize me with

00:19:50,250 --> 00:19:55,559
a delta of zero then the server can tell

00:19:52,500 --> 00:19:57,600
you and here's your current size and

00:19:55,559 --> 00:20:00,090
that structured reply has some cool

00:19:57,600 --> 00:20:02,100
features normally when you send a

00:20:00,090 --> 00:20:04,559
command of the server replies back and

00:20:02,100 --> 00:20:06,720
the transactions done you don't get any

00:20:04,559 --> 00:20:08,970
more information if the server can

00:20:06,720 --> 00:20:10,920
change the size behind your back such as

00:20:08,970 --> 00:20:12,690
an L VM image then that means your

00:20:10,920 --> 00:20:13,890
client has to pull send a new command

00:20:12,690 --> 00:20:15,570
every time I want to say what's your

00:20:13,890 --> 00:20:18,929
size what's your size oh you grew

00:20:15,570 --> 00:20:21,330
finally but it would be nice we could

00:20:18,929 --> 00:20:23,820
say I want to set a notify bit and

00:20:21,330 --> 00:20:26,130
create an open-ended command then the

00:20:23,820 --> 00:20:28,740
server replies and says I have a new

00:20:26,130 --> 00:20:30,809
size for you using the same handle that

00:20:28,740 --> 00:20:33,210
you've started but I have not finished

00:20:30,809 --> 00:20:35,190
the command this command remains open

00:20:33,210 --> 00:20:37,290
and then down the road ten minutes ten

00:20:35,190 --> 00:20:39,390
days later you resize again the server

00:20:37,290 --> 00:20:41,309
passes another reply it could be the

00:20:39,390 --> 00:20:44,340
longest-lived reply out or a command out

00:20:41,309 --> 00:20:47,070
there but you've turned this pulling

00:20:44,340 --> 00:20:49,080
into a notification loop so there's some

00:20:47,070 --> 00:20:51,240
great potential for what we add in the

00:20:49,080 --> 00:20:53,280
resize command and we're sitting there

00:20:51,240 --> 00:20:55,350
saying to ourselves do we want all

00:20:53,280 --> 00:20:56,580
servers to implement the latest and

00:20:55,350 --> 00:20:59,640
greatest and give us this notification

00:20:56,580 --> 00:21:01,770
loop well it comes at a cost

00:20:59,640 --> 00:21:03,120
servers are more complex when they have

00:21:01,770 --> 00:21:05,010
to do a notification loop having an

00:21:03,120 --> 00:21:07,559
open-ended command ties up one of your

00:21:05,010 --> 00:21:09,030
threads if you have a threaded server or

00:21:07,559 --> 00:21:11,160
if you don't have a threaded server if

00:21:09,030 --> 00:21:12,630
everything was in order you can't even

00:21:11,160 --> 00:21:15,360
do it you have to become a threaded

00:21:12,630 --> 00:21:19,440
server so we may need more knobs we may

00:21:15,360 --> 00:21:21,000
need to have some handshakes where the

00:21:19,440 --> 00:21:22,740
server says I'm willing to offer this

00:21:21,000 --> 00:21:25,860
this but not that and the client says

00:21:22,740 --> 00:21:27,570
okay I can deal with that and fall back

00:21:25,860 --> 00:21:29,580
where I don't have it but it makes the

00:21:27,570 --> 00:21:31,909
clients more - more complicated makes

00:21:29,580 --> 00:21:33,949
for more interoperable 'ti testing

00:21:31,909 --> 00:21:35,299
so either way we're going to have some

00:21:33,949 --> 00:21:37,999
fun with the design and you're welcome

00:21:35,299 --> 00:21:40,219
to contribute on the list but we are

00:21:37,999 --> 00:21:41,959
going to be adding resize and with that

00:21:40,219 --> 00:21:44,659
I hope we have a good summary

00:21:41,959 --> 00:21:46,749
NBD is a simple yet flexible protocol

00:21:44,659 --> 00:21:49,249
and has lots of uses in virtualization

00:21:46,749 --> 00:21:53,829
do we have any time for questions or is

00:21:49,249 --> 00:21:53,829
this the end we have time for questions

00:21:59,410 --> 00:22:03,539
you want to see rich do better on F Byrd

00:22:13,300 --> 00:22:21,610
I have one city and the simple question

00:22:16,690 --> 00:22:24,870
for the game encoder your shoulder in

00:22:21,610 --> 00:22:33,040
the demo is easy is that according sauce

00:22:24,870 --> 00:22:34,780
is there any copyright concerns so all

00:22:33,040 --> 00:22:37,360
the demos I showed they are source

00:22:34,780 --> 00:22:41,470
available but they're not open source in

00:22:37,360 --> 00:22:43,000
the licensing however they do they do

00:22:41,470 --> 00:22:45,760
all I mean all of them actually

00:22:43,000 --> 00:22:47,620
including the ray-tracing one come with

00:22:45,760 --> 00:22:50,980
full commented source codes and they're

00:22:47,620 --> 00:22:54,100
quite interesting to read obviously this

00:22:50,980 --> 00:22:57,150
book is the source code for the for this

00:22:54,100 --> 00:22:57,150
second lot of demos

00:23:03,470 --> 00:23:08,559
so thank you all right thanks for your

00:23:06,110 --> 00:23:08,559
attention

00:23:09,560 --> 00:23:16,700

YouTube URL: https://www.youtube.com/watch?v=PMa6KFX9AxM


