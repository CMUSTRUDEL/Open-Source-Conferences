Title: [2019] QEMU-Hexagon: Automatic Translation of the ISA Manual Pseudcode to Tiny Code Instructions
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	Full name: QEMU-Hexagon: Automatic Translation of the ISA Manual Pseudcode to Tiny Code Instructions of a VLIW Architecture - NiccolÃ² Izzo, rev.ng & Taylor Simpson, Qualcomm Innovation Center

The QEMU frontend is automatically generated: the authors have extracted and formalized the pseudocode of each instruction from the ISA reference manual and implemented a translator.
This translator transforms the pseudocode to C code to be embedded directly in QEMU which performs instruction decoding, textual disassembly and generates the equivalent tiny code instructions.
This approach reduces the implementation effort and allows to easily add new instructions.

The other interesting aspect is the fact that Hexagon is a VLIW architecture: it runs bundles composed of up to 4 parallel instructions that might also feature data dependencies.

This talk also wants to be the starting point for upstreaming our frontend, which is now almost feature-complete.

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,950 --> 00:00:11,130
okay so hello everyone thank you for

00:00:09,960 --> 00:00:14,309
being here

00:00:11,130 --> 00:00:17,880
I am Nicola it so I'm a PhD student from

00:00:14,309 --> 00:00:20,430
Politecnico di Milano Italy and I've did

00:00:17,880 --> 00:00:23,820
this project with a company which is

00:00:20,430 --> 00:00:27,050
called the revenge and it's Anita small

00:00:23,820 --> 00:00:31,340
Italian startup whose core product is

00:00:27,050 --> 00:00:35,250
the compiler tool but also they do

00:00:31,340 --> 00:00:38,280
consultants on static and dynamic binary

00:00:35,250 --> 00:00:43,020
translation and other program analysis

00:00:38,280 --> 00:00:45,750
techniques good morning I'm Taylor

00:00:43,020 --> 00:00:49,140
Simpson I run the LLVM compiler and

00:00:45,750 --> 00:00:50,809
tools team at Qualcomm I live in Austin

00:00:49,140 --> 00:00:53,579
Texas

00:00:50,809 --> 00:00:56,190
Niccolo and I found out about each other

00:00:53,579 --> 00:00:58,260
doing the same project independently and

00:00:56,190 --> 00:00:59,699
then decided to come together and do

00:00:58,260 --> 00:01:02,250
this talk and ultimately we want to

00:00:59,699 --> 00:01:07,650
merge our code together and contribute

00:01:02,250 --> 00:01:08,880
it into and get it merged into QEMU okay

00:01:07,650 --> 00:01:12,210
so what are we going to talk about today

00:01:08,880 --> 00:01:13,500
first we'll tell you what hexagon is and

00:01:12,210 --> 00:01:15,210
we'll give you enough of an introduction

00:01:13,500 --> 00:01:16,950
to QEMU so the rest of the talk makes

00:01:15,210 --> 00:01:19,409
sense and then we'll talk about the

00:01:16,950 --> 00:01:21,570
challenges in what we did and then wrap

00:01:19,409 --> 00:01:25,140
things up with some status and next

00:01:21,570 --> 00:01:28,290
steps and actually don't be a demo okay

00:01:25,140 --> 00:01:29,729
so what is hexagon here this is a

00:01:28,290 --> 00:01:33,590
mouthful it's a very long instruction

00:01:29,729 --> 00:01:36,540
word digital signal processor it's a

00:01:33,590 --> 00:01:40,140
processor that's designed by Qualcomm

00:01:36,540 --> 00:01:43,619
and used inside Qualcomm's SOC s the VLA

00:01:40,140 --> 00:01:45,659
w part means that the instructions that

00:01:43,619 --> 00:01:47,790
execute in parallel are actually encoded

00:01:45,659 --> 00:01:49,590
into the binary this is different from a

00:01:47,790 --> 00:01:51,479
superscalar which analyzes the

00:01:49,590 --> 00:01:53,640
instruction stream and determines which

00:01:51,479 --> 00:01:56,280
instructions are independent and can be

00:01:53,640 --> 00:01:58,710
executed in parallel on hexagons it's

00:01:56,280 --> 00:02:01,140
actually encoded into the instruction

00:01:58,710 --> 00:02:04,170
stream and so that reduces area and

00:02:01,140 --> 00:02:06,149
reduces the power consumption processing

00:02:04,170 --> 00:02:08,160
and we call it a digital signal

00:02:06,149 --> 00:02:11,009
processor because it processes lots and

00:02:08,160 --> 00:02:13,019
lots of digital signals within the SOC

00:02:11,009 --> 00:02:15,239
with the digital signal that comes from

00:02:13,019 --> 00:02:18,780
a cell tower to your phone then there's

00:02:15,239 --> 00:02:20,340
also Wi-Fi there's voice there's digital

00:02:18,780 --> 00:02:23,159
signals from your camera and your

00:02:20,340 --> 00:02:27,480
sensors there's lots of these around and

00:02:23,159 --> 00:02:29,970
my phone I have four of them my shirt

00:02:27,480 --> 00:02:31,709
was a commemoration of shipping 10

00:02:29,970 --> 00:02:33,739
billion hexagons

00:02:31,709 --> 00:02:37,650
into the world over the course of about

00:02:33,739 --> 00:02:41,159
1415 years so we're pretty proud of it

00:02:37,650 --> 00:02:43,829
so let's take a look at the what the

00:02:41,159 --> 00:02:45,299
assembly syntax looks like if you don't

00:02:43,829 --> 00:02:48,720
look too closely you might think it's C

00:02:45,299 --> 00:02:50,849
code the instructions are algebraic so

00:02:48,720 --> 00:02:52,709
on the left hand side is a destination

00:02:50,849 --> 00:02:53,549
and there's an equal and then there's

00:02:52,709 --> 00:02:55,920
something that looks kind of like a

00:02:53,549 --> 00:02:58,920
function call with the opcode and then

00:02:55,920 --> 00:03:01,109
the operands in parentheses so the curly

00:02:58,920 --> 00:03:04,500
braces indicate that all those

00:03:01,109 --> 00:03:06,180
instructions execute in parallel and the

00:03:04,500 --> 00:03:08,940
semantics are they all start at the same

00:03:06,180 --> 00:03:11,430
time so effectively in parallel they all

00:03:08,940 --> 00:03:13,680
do the reads of their operands and then

00:03:11,430 --> 00:03:16,010
they do in parallel the operation and

00:03:13,680 --> 00:03:18,989
then in parallel they write the results

00:03:16,010 --> 00:03:20,609
that'll be important later so this

00:03:18,989 --> 00:03:23,160
packet you see here has four

00:03:20,609 --> 00:03:25,019
instructions in it and then an end loop

00:03:23,160 --> 00:03:27,720
at the end which manages the looping

00:03:25,019 --> 00:03:30,959
this is actually one of the packets of

00:03:27,720 --> 00:03:32,340
the inner loop of FFT for hexagon it's

00:03:30,959 --> 00:03:39,419
not the whole inner loop the part of the

00:03:32,340 --> 00:03:42,000
inner loop yeah so since you are here at

00:03:39,419 --> 00:03:46,049
the KVM form you probably know what Q is

00:03:42,000 --> 00:03:48,030
however among among the three possible

00:03:46,049 --> 00:03:49,650
operating mode of Q even the user mode

00:03:48,030 --> 00:03:52,379
the system mode and the virtualization

00:03:49,650 --> 00:03:56,609
will be just focusing on the user mode

00:03:52,379 --> 00:03:59,370
and despite I mean we will be not be

00:03:56,609 --> 00:04:01,980
using the KVM features of Q machines we

00:03:59,370 --> 00:04:04,049
are translating from a different

00:04:01,980 --> 00:04:06,239
architecture the exocrine architecture

00:04:04,049 --> 00:04:08,760
to I mean the native architecture and

00:04:06,239 --> 00:04:11,699
not many of you run Linux on your

00:04:08,760 --> 00:04:15,060
hexagon laptops so because there are

00:04:11,699 --> 00:04:17,489
there aren't any so we are using the TCG

00:04:15,060 --> 00:04:18,739
translation feature of QE mo which

00:04:17,489 --> 00:04:22,170
basically

00:04:18,739 --> 00:04:26,100
has the granularity of a translation rod

00:04:22,170 --> 00:04:28,350
so each translation block is taken is

00:04:26,100 --> 00:04:29,760
decoded I mean the binary instructions

00:04:28,350 --> 00:04:32,520
are decoded to their actual

00:04:29,760 --> 00:04:36,650
representation and they are translated

00:04:32,520 --> 00:04:41,160
to some as sub assembly like

00:04:36,650 --> 00:04:44,070
instructions called GCG ops then the TCG

00:04:41,160 --> 00:04:46,410
ops are finally translated into the

00:04:44,070 --> 00:04:50,310
destination architecture of your the

00:04:46,410 --> 00:04:53,610
machine you're running qmo on it has to

00:04:50,310 --> 00:04:56,030
be said that the translation for each

00:04:53,610 --> 00:04:59,490
translation block is done only once

00:04:56,030 --> 00:05:04,830
except if the block changes so the

00:04:59,490 --> 00:05:08,430
things actually runs pretty fast so to

00:05:04,830 --> 00:05:12,330
give you an example in the TCG ops are

00:05:08,430 --> 00:05:15,780
generated by some C functions inside of

00:05:12,330 --> 00:05:17,790
qumu they look like the one you using

00:05:15,780 --> 00:05:21,990
the top of the slide so you have

00:05:17,790 --> 00:05:25,680
basically the name of the operation for

00:05:21,990 --> 00:05:28,140
example DCG gen ad okay and then some

00:05:25,680 --> 00:05:31,080
suffix about the size of the operation

00:05:28,140 --> 00:05:34,080
in this case T all means target length

00:05:31,080 --> 00:05:37,590
which is the side of the registers of

00:05:34,080 --> 00:05:41,419
the target machine but let me give you

00:05:37,590 --> 00:05:46,530
an example of an example translation of

00:05:41,419 --> 00:05:50,760
x86 assembly to TCG opcode in this case

00:05:46,530 --> 00:05:53,280
we have a single x86 instruction which

00:05:50,760 --> 00:05:57,480
is a call instruction and that gets

00:05:53,280 --> 00:06:00,720
translated into those four TCG ops the

00:05:57,480 --> 00:06:04,350
first one is a subtract operation which

00:06:00,720 --> 00:06:07,260
basically decreases the stack then we

00:06:04,350 --> 00:06:10,380
use a store operation to save the return

00:06:07,260 --> 00:06:14,160
address into the stack and then we

00:06:10,380 --> 00:06:18,030
update the stack pointer and then we

00:06:14,160 --> 00:06:25,380
jump to the target of the call which is

00:06:18,030 --> 00:06:29,010
the address 0 X 2000 in our goal was to

00:06:25,380 --> 00:06:30,810
create the hexagon implementation for

00:06:29,010 --> 00:06:33,900
chemos so to

00:06:30,810 --> 00:06:36,630
feed you emo with hexagon binaries okay

00:06:33,900 --> 00:06:38,940
which after the decoding will look like

00:06:36,630 --> 00:06:42,960
the bundle we see on the left of the

00:06:38,940 --> 00:06:46,980
slide so these curly braces with for up

00:06:42,960 --> 00:06:51,150
to 4x agon assembly instruction in it

00:06:46,980 --> 00:07:01,220
and we had to take that and translate it

00:06:51,150 --> 00:07:03,750
into TCG ops okay so so why is this hard

00:07:01,220 --> 00:07:05,790
the first read first set of reasons come

00:07:03,750 --> 00:07:08,040
from the semantics of the packet or the

00:07:05,790 --> 00:07:12,000
very long instruction word if you

00:07:08,040 --> 00:07:14,669
remember the semantics is not the same

00:07:12,000 --> 00:07:17,160
as executing the instruction serially

00:07:14,669 --> 00:07:18,479
the beginning you do all the reads they

00:07:17,160 --> 00:07:20,250
need you all their operations and then

00:07:18,479 --> 00:07:22,979
you do all the writes so this packet

00:07:20,250 --> 00:07:24,950
that you see here definitely does not

00:07:22,979 --> 00:07:27,150
produce the same result as if you

00:07:24,950 --> 00:07:29,520
executed those instructions sequentially

00:07:27,150 --> 00:07:34,590
it actually does a swap of register r1

00:07:29,520 --> 00:07:38,370
and r2 sorry r0 you can have more than

00:07:34,590 --> 00:07:40,490
one jump in a packet so they don't

00:07:38,370 --> 00:07:43,140
always act like they execute in parallel

00:07:40,490 --> 00:07:46,250
in fact only one of those jumps will get

00:07:43,140 --> 00:07:48,960
executed when you execute that packet

00:07:46,250 --> 00:07:51,240
you can have more than one store in a

00:07:48,960 --> 00:07:53,580
packet and those have to be serialized

00:07:51,240 --> 00:07:56,640
because they can point to the same place

00:07:53,580 --> 00:07:59,400
in this example you see a store of a

00:07:56,640 --> 00:08:01,020
word at the same address as a store of a

00:07:59,400 --> 00:08:03,389
byte so you have to do the word first

00:08:01,020 --> 00:08:07,289
and then the body over writes that one

00:08:03,389 --> 00:08:10,080
the first byte of the word then we have

00:08:07,289 --> 00:08:11,850
something called dot new which takes

00:08:10,080 --> 00:08:14,370
advantage of a forwarding paths in the

00:08:11,850 --> 00:08:16,050
microarchitecture so you you know you've

00:08:14,370 --> 00:08:18,570
done your reads and then you start the

00:08:16,050 --> 00:08:20,310
operation and then this operation has

00:08:18,570 --> 00:08:21,990
produced it's a result it can forward it

00:08:20,310 --> 00:08:24,120
to another one that's executing in

00:08:21,990 --> 00:08:26,039
parallel so we call that dot new so

00:08:24,120 --> 00:08:27,630
you're using the value of one of the

00:08:26,039 --> 00:08:31,979
other produced by one of the other

00:08:27,630 --> 00:08:35,010
instructions in your packet and the

00:08:31,979 --> 00:08:37,289
order that you see them in the serial

00:08:35,010 --> 00:08:39,030
encoding of the packet doesn't have to

00:08:37,289 --> 00:08:41,010
be the order that they need to execute

00:08:39,030 --> 00:08:43,979
when you run TCG so we might have to

00:08:41,010 --> 00:08:45,480
some rearranging in this case the one on

00:08:43,979 --> 00:08:48,060
the right you have to do first to get

00:08:45,480 --> 00:08:52,410
the value of p0 in order to feed that

00:08:48,060 --> 00:08:54,240
into the test there of the if and you

00:08:52,410 --> 00:08:56,699
can have multiple predicate definitions

00:08:54,240 --> 00:09:00,149
in a packet I'd actually forgotten about

00:08:56,699 --> 00:09:02,550
this lamenting last night over dinner so

00:09:00,149 --> 00:09:06,029
in this example I have two rights to p0

00:09:02,550 --> 00:09:11,370
in the same packet and the semantics of

00:09:06,029 --> 00:09:13,170
that is they get ANDed together ok so

00:09:11,370 --> 00:09:15,480
and then it has precise interrupts and

00:09:13,170 --> 00:09:17,880
exceptions so when you have a packet

00:09:15,480 --> 00:09:22,019
either all of the instructions come in

00:09:17,880 --> 00:09:24,930
or none of them come in and last but not

00:09:22,019 --> 00:09:26,459
least there are over 2,000 user-mode

00:09:24,930 --> 00:09:33,480
instructions so that's a lot of

00:09:26,459 --> 00:09:38,100
instructions okay so how do we deal with

00:09:33,480 --> 00:09:39,300
this well for the packet semantics we

00:09:38,100 --> 00:09:40,829
sometimes we have to reorder the

00:09:39,300 --> 00:09:42,449
instructions so there's some analysis

00:09:40,829 --> 00:09:43,949
you do when you've looked at the packet

00:09:42,449 --> 00:09:47,010
to figure out the order you want to

00:09:43,949 --> 00:09:49,170
generate the TCG code in then we use a

00:09:47,010 --> 00:09:51,420
temporary register set for all of the

00:09:49,170 --> 00:09:52,980
destinations and then we process that

00:09:51,420 --> 00:09:54,510
after we've processed all the

00:09:52,980 --> 00:09:57,930
instructions of the packet writing it

00:09:54,510 --> 00:09:59,880
back to the normal state at the end and

00:09:57,930 --> 00:10:04,620
then we commit only if there are no

00:09:59,880 --> 00:10:07,139
exceptions okay so now how do we deal

00:10:04,620 --> 00:10:12,389
with a large number of instructions two

00:10:07,139 --> 00:10:14,220
thousand instructions so I have the

00:10:12,389 --> 00:10:17,880
advantage since I work at Qualcomm I

00:10:14,220 --> 00:10:19,800
have access to the code for the existing

00:10:17,880 --> 00:10:22,589
simulator for hexagon we call that

00:10:19,800 --> 00:10:25,680
hexagon sim and it's an interpreting

00:10:22,589 --> 00:10:27,690
simulator so unlike QEMU which generates

00:10:25,680 --> 00:10:30,329
code for all the instructions and then

00:10:27,690 --> 00:10:32,579
executes it this cut this simulator dis

00:10:30,329 --> 00:10:35,040
interprets it but we have the exact

00:10:32,579 --> 00:10:39,269
semantics of all the instructions

00:10:35,040 --> 00:10:41,430
written in C and that simulator is

00:10:39,269 --> 00:10:44,100
actually used to verify the RTL so we

00:10:41,430 --> 00:10:45,930
know it's very accurate representation

00:10:44,100 --> 00:10:47,519
of what the processor is doing so I

00:10:45,930 --> 00:10:52,520
wanted to leverage as much of that code

00:10:47,519 --> 00:10:56,190
as possible when building QE me for hex

00:10:52,520 --> 00:10:59,760
okay so cute EMU has the concept of a

00:10:56,190 --> 00:11:02,130
helper within TCG so it gives you away

00:10:59,760 --> 00:11:05,790
from within your TCG code to call out to

00:11:02,130 --> 00:11:07,440
a seek function that you write usually

00:11:05,790 --> 00:11:10,130
this is used for very complex things

00:11:07,440 --> 00:11:13,260
that are difficult to represent in TCG

00:11:10,130 --> 00:11:16,680
but as you'll see in a minute we can use

00:11:13,260 --> 00:11:19,170
this very handily for hexagon so every

00:11:16,680 --> 00:11:21,149
helper has three parts and I generate

00:11:19,170 --> 00:11:25,709
them from the architecture specification

00:11:21,149 --> 00:11:28,250
using a Python script so an architecture

00:11:25,709 --> 00:11:30,360
library that is part of the simulator

00:11:28,250 --> 00:11:32,880
for every instruction there are

00:11:30,360 --> 00:11:35,580
effectively two things there's a tag

00:11:32,880 --> 00:11:37,560
which is a unique label for the

00:11:35,580 --> 00:11:39,630
instruction I'm gonna use that to name a

00:11:37,560 --> 00:11:41,610
lot of the things that we generate and

00:11:39,630 --> 00:11:44,399
then there's a little snippet of C code

00:11:41,610 --> 00:11:47,520
that is a semantics so in this case it's

00:11:44,399 --> 00:11:50,730
just an ad and the operands are named in

00:11:47,520 --> 00:11:52,649
a very idiomatic way so the D indicates

00:11:50,730 --> 00:11:56,130
that that's the destination and then s

00:11:52,649 --> 00:11:57,600
and the T indicate that their sources so

00:11:56,130 --> 00:11:59,640
that tells me what the signature of this

00:11:57,600 --> 00:12:02,790
helper function needs to be by two

00:11:59,640 --> 00:12:04,529
operands in one destination so I can use

00:12:02,790 --> 00:12:07,200
Python and generate the three things I

00:12:04,529 --> 00:12:10,440
need for a QEMU helper the first one is

00:12:07,200 --> 00:12:13,230
a prototype and that def helper macro

00:12:10,440 --> 00:12:16,529
there gets expanded twice actually once

00:12:13,230 --> 00:12:21,029
for a function that lets you call that

00:12:16,529 --> 00:12:22,560
function from GCC from TCG excuse me and

00:12:21,029 --> 00:12:27,029
then another one that gives you the

00:12:22,560 --> 00:12:29,130
header for the function itself okay so

00:12:27,029 --> 00:12:32,279
then we can generate the call so we

00:12:29,130 --> 00:12:33,600
start off with some code to pull the

00:12:32,279 --> 00:12:37,200
operands out of the registers that

00:12:33,600 --> 00:12:39,240
they're in then we generate the call to

00:12:37,200 --> 00:12:41,279
the helper that's in the red box there

00:12:39,240 --> 00:12:43,410
and then we generate code to write it

00:12:41,279 --> 00:12:44,790
back into the temporary that we talked

00:12:43,410 --> 00:12:48,480
about earlier and then we free up the

00:12:44,790 --> 00:12:51,029
TCG variables and off we go and then

00:12:48,480 --> 00:12:53,010
finally we generate the implementation

00:12:51,029 --> 00:12:55,410
and you see there in the middle where

00:12:53,010 --> 00:12:58,380
we've just pasted the C code

00:12:55,410 --> 00:12:59,880
representation inside there and the

00:12:58,380 --> 00:13:02,089
python script is generating all the

00:12:59,880 --> 00:13:04,980
stuff around it

00:13:02,089 --> 00:13:07,800
so this approach has some advantages and

00:13:04,980 --> 00:13:10,890
some disadvantages only advantages is

00:13:07,800 --> 00:13:13,350
that I can very quickly get all the

00:13:10,890 --> 00:13:16,440
instructions implemented all 2,000 of

00:13:13,350 --> 00:13:18,810
them we're implemented very quickly and

00:13:16,440 --> 00:13:21,060
I know that has the very same semantics

00:13:18,810 --> 00:13:22,980
as what the simulator does which is I

00:13:21,060 --> 00:13:24,540
said earlier is going to be verified

00:13:22,980 --> 00:13:26,700
against the hardware so it's a very true

00:13:24,540 --> 00:13:29,670
representation of what the processor is

00:13:26,700 --> 00:13:32,820
actually doing now their disadvantage is

00:13:29,670 --> 00:13:34,980
that all those function calls have a lot

00:13:32,820 --> 00:13:37,860
of overhead so that ad you just saw

00:13:34,980 --> 00:13:39,839
that's a lot of work to set up the call

00:13:37,860 --> 00:13:42,660
stack and the registers make function

00:13:39,839 --> 00:13:45,630
call just do an ad and then tear down

00:13:42,660 --> 00:13:48,720
the function on the return it's also a

00:13:45,630 --> 00:13:51,180
barrier to optimizations at TCG can do

00:13:48,720 --> 00:13:54,089
so TCG can do things like constant

00:13:51,180 --> 00:13:56,160
propagation copy folding instruction

00:13:54,089 --> 00:13:58,709
combining things like that but if it's a

00:13:56,160 --> 00:14:01,980
bunch of function calls there's not much

00:13:58,709 --> 00:14:05,580
it can do to optimize so how do we fix

00:14:01,980 --> 00:14:07,230
that problem so I kind of glossed over

00:14:05,580 --> 00:14:10,160
this before but if you notice what I

00:14:07,230 --> 00:14:14,370
generate there's this F R at macro

00:14:10,160 --> 00:14:17,160
around the call to the Gen helper I can

00:14:14,370 --> 00:14:20,010
override that with an actual

00:14:17,160 --> 00:14:22,320
implementation and TCG of the

00:14:20,010 --> 00:14:25,140
instructions so if you're familiar with

00:14:22,320 --> 00:14:28,440
TCG you'll know that an ad is just T CGG

00:14:25,140 --> 00:14:31,400
an ad TL and then the destination and

00:14:28,440 --> 00:14:34,200
the two sources is the operands so now I

00:14:31,400 --> 00:14:36,839
have instead of making a call to a

00:14:34,200 --> 00:14:39,900
helper I've actually generated the ad in

00:14:36,839 --> 00:14:42,089
TCG that I need so this is a good

00:14:39,900 --> 00:14:47,790
lead-in to the approach but the revenge

00:14:42,089 --> 00:14:49,800
guys did yeah so while teller was

00:14:47,790 --> 00:14:52,829
building his own implementation I mean

00:14:49,800 --> 00:14:56,370
having access to all the actual

00:14:52,829 --> 00:14:58,980
description in C of the semantics we

00:14:56,370 --> 00:15:02,940
didn't have any of those material we

00:14:58,980 --> 00:15:06,839
just had the basically the is a manual

00:15:02,940 --> 00:15:09,150
so the is a manual contains for each

00:15:06,839 --> 00:15:12,420
assembly syntax of the architecture

00:15:09,150 --> 00:15:13,480
observer code okay which is meant to be

00:15:12,420 --> 00:15:16,780
read by

00:15:13,480 --> 00:15:19,920
and describes the functionality of the

00:15:16,780 --> 00:15:22,990
instruction for example here we see the

00:15:19,920 --> 00:15:25,570
subtract instruction and corresponding

00:15:22,990 --> 00:15:28,300
silicon so we ask yourself I mean we

00:15:25,570 --> 00:15:31,330
don't want to implement by hand mm

00:15:28,300 --> 00:15:34,300
instructions can we just use can we

00:15:31,330 --> 00:15:38,980
translate this pseudo code snippet into

00:15:34,300 --> 00:15:43,030
actual TCG generation code yes we

00:15:38,980 --> 00:15:46,420
exactly did that by using the fraction

00:15:43,030 --> 00:15:48,820
by some tools and yeah it works

00:15:46,420 --> 00:15:50,920
basically like this I mean we have at

00:15:48,820 --> 00:15:54,160
the top of the slides we have the pseudo

00:15:50,920 --> 00:15:56,500
code so we parse that using flex and

00:15:54,160 --> 00:15:59,040
Mizen we generate the the parsing tree

00:15:56,500 --> 00:16:02,920
you see on the left of the slides and

00:15:59,040 --> 00:16:06,820
then using syntax directed translation

00:16:02,920 --> 00:16:12,880
of bison we are able to actually emit

00:16:06,820 --> 00:16:14,830
some humo code which does the preserve

00:16:12,880 --> 00:16:17,260
has the exact semantics of the

00:16:14,830 --> 00:16:21,550
instruction so that in the end will

00:16:17,260 --> 00:16:24,790
generate some a group of TCG ops which

00:16:21,550 --> 00:16:30,550
will perform the operation of the

00:16:24,790 --> 00:16:32,980
semantics of this instruction so in I

00:16:30,550 --> 00:16:37,660
mean the whole process looks a bit like

00:16:32,980 --> 00:16:40,180
this we have the is a manual the the PDF

00:16:37,660 --> 00:16:43,120
you download from the qualcomm sdk and

00:16:40,180 --> 00:16:45,640
we painfully extracted all the

00:16:43,120 --> 00:16:49,540
information about the encoding of each

00:16:45,640 --> 00:16:54,340
instruction and about the filter code of

00:16:49,540 --> 00:16:56,980
each instruction manually and all the

00:16:54,340 --> 00:16:59,020
resulting or something to to CVS I mean

00:16:56,980 --> 00:17:01,930
the first one the one containing the

00:16:59,020 --> 00:17:04,930
encoding is actually fed into a script

00:17:01,930 --> 00:17:07,660
which automatically generates a decoder

00:17:04,930 --> 00:17:10,540
tree for that and we had to use that

00:17:07,660 --> 00:17:12,250
because the fixed bits inside the

00:17:10,540 --> 00:17:13,690
encoding of each instruction the one

00:17:12,250 --> 00:17:15,820
which determines which kind of

00:17:13,690 --> 00:17:17,920
instruction is that they are not just is

00:17:15,820 --> 00:17:19,810
related in maybe in the first part in

00:17:17,920 --> 00:17:23,650
the first byte they are spread around

00:17:19,810 --> 00:17:26,020
the instruction so we had to figure it

00:17:23,650 --> 00:17:26,730
out automatically which was which were

00:17:26,020 --> 00:17:29,790
the

00:17:26,730 --> 00:17:35,700
beats to disambiguate to build an

00:17:29,790 --> 00:17:38,160
efficient tree then after that we we

00:17:35,700 --> 00:17:42,929
took the pseudocode of which instruction

00:17:38,160 --> 00:17:46,350
and fed it fund them into our parser

00:17:42,929 --> 00:17:50,630
built with flex and bison and our result

00:17:46,350 --> 00:17:54,419
as a result we had these two C files

00:17:50,630 --> 00:17:57,000
which were ready to be compiled in Q emo

00:17:54,419 --> 00:18:00,570
and they provided the semantics for each

00:17:57,000 --> 00:18:04,380
of the I mean most of the 2000

00:18:00,570 --> 00:18:06,330
instructions so which is the current

00:18:04,380 --> 00:18:09,120
status and which are the limitation of

00:18:06,330 --> 00:18:13,169
our implementation we were able to reach

00:18:09,120 --> 00:18:16,190
an astonishing speed at 28 times we were

00:18:13,169 --> 00:18:19,710
28 times faster than the existing

00:18:16,190 --> 00:18:23,490
simulator excellency and we have a

00:18:19,710 --> 00:18:27,150
complete Linux user space support but we

00:18:23,490 --> 00:18:30,900
so yeah we also support the semi Austin

00:18:27,150 --> 00:18:34,169
Cisco system and we extensively tested

00:18:30,900 --> 00:18:37,530
our code I mean we have a 51 unit test

00:18:34,169 --> 00:18:39,990
built into qumu to just verify that the

00:18:37,530 --> 00:18:42,240
semantics of each instruction of main

00:18:39,990 --> 00:18:44,370
instruction is correct but we also have

00:18:42,240 --> 00:18:47,400
some real program which can execute and

00:18:44,370 --> 00:18:50,490
there are we show that in a few moments

00:18:47,400 --> 00:18:54,120
also both our implementation are

00:18:50,490 --> 00:18:58,200
publicly available on github and we

00:18:54,120 --> 00:19:03,809
think that's nice good start to the road

00:18:58,200 --> 00:19:07,590
to up swimming ok so the next steps are

00:19:03,809 --> 00:19:09,450
to merge the two implementations we

00:19:07,590 --> 00:19:11,400
would like it review from the community

00:19:09,450 --> 00:19:13,440
anybody's willing to help please get in

00:19:11,400 --> 00:19:15,840
touch with us and ultimately our goal is

00:19:13,440 --> 00:19:17,610
to get this merged upstream longer-term

00:19:15,840 --> 00:19:20,730
we'd like to see tighter integration

00:19:17,610 --> 00:19:23,070
with the LLVM for hexagon we need to do

00:19:20,730 --> 00:19:25,110
the system mode and since our tool chain

00:19:23,070 --> 00:19:27,690
is based on LLVM we have the LLVM

00:19:25,110 --> 00:19:30,570
debugger so if anyone has experienced

00:19:27,690 --> 00:19:33,740
getting LLVM to talk to the gdb stub and

00:19:30,570 --> 00:19:37,549
qemu I would love to buy you a beer

00:19:33,740 --> 00:19:37,549
ok so let's do a demo

00:19:51,700 --> 00:20:01,770
okay so here I have a little factorial

00:20:00,100 --> 00:20:12,550
program

00:20:01,770 --> 00:20:13,090
it's a Qualcomm DSP binary just computes

00:20:12,550 --> 00:20:14,350
affectaura

00:20:13,090 --> 00:20:17,740
can take an argument from the command

00:20:14,350 --> 00:20:21,540
line okay over in this window I'm gonna

00:20:17,740 --> 00:20:30,700
we have a gzip program so I'm gonna time

00:20:21,540 --> 00:20:32,680
hexagon simulator okay so it's gonna

00:20:30,700 --> 00:20:34,510
print out the size of the file that it's

00:20:32,680 --> 00:20:38,460
reading and then it's gonna tell you as

00:20:34,510 --> 00:20:38,460
it reaches every hundred thousand steps

00:20:43,440 --> 00:20:48,520
there you go Kimmy's already finished it

00:20:45,940 --> 00:20:54,130
whoops I forgot to time it it takes

00:20:48,520 --> 00:20:57,370
about a second and the hexagon SIM

00:20:54,130 --> 00:21:00,370
version takes about 30 seconds so a lot

00:20:57,370 --> 00:21:03,430
faster the next thing I want to point

00:21:00,370 --> 00:21:08,410
out is that from the shell if I say dot

00:21:03,430 --> 00:21:10,570
factorial right now the Linux kernel on

00:21:08,410 --> 00:21:17,020
this machine doesn't know what factorial

00:21:10,570 --> 00:21:19,900
is typed it wrong it doesn't know what

00:21:17,020 --> 00:21:23,310
that binary format is but Q EMU comes

00:21:19,900 --> 00:21:23,310
with a little helper script

00:21:26,730 --> 00:21:31,299
[Music]

00:21:28,259 --> 00:21:37,509
to set up the bin format mistranslation

00:21:31,299 --> 00:21:39,580
for all the targets and see the last

00:21:37,509 --> 00:21:41,889
line there says it's setup QEMU hexagon

00:21:39,580 --> 00:21:47,080
as a bin format interpreter so now I can

00:21:41,889 --> 00:21:48,879
say dot dot factorial this is handy if

00:21:47,080 --> 00:21:53,080
you want to write testing scripts and so

00:21:48,879 --> 00:21:54,669
on now for the really fun part I have a

00:21:53,080 --> 00:21:57,549
root filesystem that's a very basic

00:21:54,669 --> 00:22:01,349
Linux root filesystem four hexagon on

00:21:57,549 --> 00:22:01,349
this machine so I can chroot

00:22:07,640 --> 00:22:12,740
so if you know what chroot does it makes

00:22:10,760 --> 00:22:15,410
that directory the base of your file

00:22:12,740 --> 00:22:19,490
system now and then it executes slash

00:22:15,410 --> 00:22:22,340
bin slash bash from that directory H bin

00:22:19,490 --> 00:22:27,679
slash bash is actually a hexagon version

00:22:22,340 --> 00:22:33,130
of bash so all the utilities LS cat file

00:22:27,679 --> 00:22:33,130
itself is actually a hexagon version

00:22:37,030 --> 00:22:45,080
alright so that there's your description

00:22:40,429 --> 00:22:47,570
of what bash is LS is another utility

00:22:45,080 --> 00:22:50,540
it's compiled for hexagon and using QEMU

00:22:47,570 --> 00:22:56,540
hexagon to execute it so pretty fun

00:22:50,540 --> 00:23:02,030
stuff ok

00:22:56,540 --> 00:23:03,890
so let's wrap things up what did we

00:23:02,030 --> 00:23:06,049
learn we learned that the semantics of a

00:23:03,890 --> 00:23:07,280
voi w processor make for some

00:23:06,049 --> 00:23:10,100
interesting challenges when you're

00:23:07,280 --> 00:23:12,049
trying to generate code the large number

00:23:10,100 --> 00:23:16,400
of instructions of hexagon requires some

00:23:12,049 --> 00:23:17,929
automation in the generation of TCG we

00:23:16,400 --> 00:23:20,270
do believe that this code generator

00:23:17,929 --> 00:23:21,950
approach can be useful for other new

00:23:20,270 --> 00:23:25,340
architectures that want to port

00:23:21,950 --> 00:23:26,750
themselves into QE new and finally we're

00:23:25,340 --> 00:23:29,570
very very very happy about the

00:23:26,750 --> 00:23:32,450
performance as being 28 times faster

00:23:29,570 --> 00:23:35,290
within the current simulator so

00:23:32,450 --> 00:23:35,290
questions

00:23:44,430 --> 00:23:48,670
two quick questions so the the first

00:23:46,840 --> 00:23:51,490
button the demo you were running was

00:23:48,670 --> 00:23:54,100
that the pure TCG version not the helper

00:23:51,490 --> 00:23:56,170
version there was 28 times file it was

00:23:54,100 --> 00:23:58,690
the the helper function the helper

00:23:56,170 --> 00:24:00,580
version with a lot of functions manual a

00:23:58,690 --> 00:24:03,040
lot of instructions manually open also

00:24:00,580 --> 00:24:07,000
emerging the target the second one was

00:24:03,040 --> 00:24:09,730
she said when you do your final commits

00:24:07,000 --> 00:24:12,820
everything has to commit or nothing

00:24:09,730 --> 00:24:15,820
commits if there's a fault so if one of

00:24:12,820 --> 00:24:21,250
one of your instructions faults how do

00:24:15,820 --> 00:24:24,040
you unroll say say this so the the work

00:24:21,250 --> 00:24:26,320
of each instruction is done in a data

00:24:24,040 --> 00:24:28,030
structure on the side that if you don't

00:24:26,320 --> 00:24:30,100
commit you just throw that away

00:24:28,030 --> 00:24:31,570
and if you if you decide at the end of

00:24:30,100 --> 00:24:34,270
the packet that you do want to commit

00:24:31,570 --> 00:24:36,790
that then you there's TCG code to copy

00:24:34,270 --> 00:24:38,650
the temporary state into the permanent

00:24:36,790 --> 00:24:41,380
state Isis just for the registers

00:24:38,650 --> 00:24:45,310
register file so what about stores to

00:24:41,380 --> 00:24:47,290
memory they these are recorded in a site

00:24:45,310 --> 00:24:49,330
data structure as well you record the

00:24:47,290 --> 00:24:51,820
address of the store and the size and

00:24:49,330 --> 00:24:53,500
the value and then in a little data

00:24:51,820 --> 00:24:56,050
structure on the side and then during

00:24:53,500 --> 00:24:58,150
the commit sequence you look at that and

00:24:56,050 --> 00:24:59,980
actually perform this doors to memory so

00:24:58,150 --> 00:25:02,230
it's the third store fails you roll back

00:24:59,980 --> 00:25:03,610
the previous stores that you've done so

00:25:02,230 --> 00:25:05,710
you haven't actually stored anything

00:25:03,610 --> 00:25:07,600
except into a little temporary side data

00:25:05,710 --> 00:25:09,760
structure yeah but you know you commit

00:25:07,600 --> 00:25:11,590
but you don't know whether or not it is

00:25:09,760 --> 00:25:14,170
gonna fault and until you actually try

00:25:11,590 --> 00:25:16,150
and do it right no you can check the

00:25:14,170 --> 00:25:17,560
address whether it's gonna fall I'll so

00:25:16,150 --> 00:25:19,690
you're checking new child address before

00:25:17,560 --> 00:25:21,520
you actually do this tool right sorry I

00:25:19,690 --> 00:25:23,820
didn't understand your question okay

00:25:21,520 --> 00:25:23,820
thanks

00:25:30,670 --> 00:25:35,990
so this is pretty cool stuff but I was

00:25:33,740 --> 00:25:37,790
wondering how you were dealing with the

00:25:35,990 --> 00:25:41,530
predicates you explained that the

00:25:37,790 --> 00:25:43,000
predicates are ANDed together and so

00:25:41,530 --> 00:25:45,860
[Music]

00:25:43,000 --> 00:25:47,720
does your data structure basically set

00:25:45,860 --> 00:25:49,990
a1 for all the predicates and then you

00:25:47,720 --> 00:25:52,870
and as you execute how does that work

00:25:49,990 --> 00:25:55,940
right so the the site data structure

00:25:52,870 --> 00:25:58,580
sets all four predicates as not being

00:25:55,940 --> 00:26:01,040
assigned yet and then on the first

00:25:58,580 --> 00:26:03,830
assignment you copy that value in and

00:26:01,040 --> 00:26:06,350
set the bit that it's assigned on a

00:26:03,830 --> 00:26:08,660
subsequent one you and it in with the

00:26:06,350 --> 00:26:10,180
first value and leave the leave that is

00:26:08,660 --> 00:26:12,770
it set alone

00:26:10,180 --> 00:26:16,310
so between that and the commit logic

00:26:12,770 --> 00:26:20,150
what is the ratio the performance ratio

00:26:16,310 --> 00:26:26,300
between the x86 version for instance of

00:26:20,150 --> 00:26:28,280
the emulated code and the native ESP in

00:26:26,300 --> 00:26:31,670
terms of instructions per cycle these

00:26:28,280 --> 00:26:35,180
kind of things so I haven't measured the

00:26:31,670 --> 00:26:39,680
measured relative to the hardware that's

00:26:35,180 --> 00:26:42,250
an interesting question there's a

00:26:39,680 --> 00:26:42,250
question in the back

00:26:48,600 --> 00:26:56,050
those are two related questions do you

00:26:52,780 --> 00:27:00,880
really have 2000 instructions or do you

00:26:56,050 --> 00:27:10,059
have a regular variation on a small set

00:27:00,880 --> 00:27:14,640
of instruction types the second question

00:27:10,059 --> 00:27:17,890
is have you compared your two

00:27:14,640 --> 00:27:19,720
implementations in any way to ensure

00:27:17,890 --> 00:27:25,780
that they actually generate the same

00:27:19,720 --> 00:27:30,640
result okay so the first question was

00:27:25,780 --> 00:27:33,550
are there really 2,000 instructions if

00:27:30,640 --> 00:27:37,240
you look at the the architecture library

00:27:33,550 --> 00:27:41,559
that I started with there are yes more

00:27:37,240 --> 00:27:42,940
than 2,000 instructions but there are

00:27:41,559 --> 00:27:45,580
lots of patterns you know so there's

00:27:42,940 --> 00:27:47,770
lots of loads and there's variations of

00:27:45,580 --> 00:27:49,270
you know a load of a byte with different

00:27:47,770 --> 00:27:52,920
addressing modes and so forth and those

00:27:49,270 --> 00:27:55,990
are all counted as unique instructions

00:27:52,920 --> 00:27:58,380
about that I mean in the instruction

00:27:55,990 --> 00:28:01,150
manual that I actually grouped up

00:27:58,380 --> 00:28:03,820
typically a couple a pair of instruction

00:28:01,150 --> 00:28:05,500
they are represented by a single method

00:28:03,820 --> 00:28:07,780
instruction for example when two

00:28:05,500 --> 00:28:10,179
instruction one have a not and the other

00:28:07,780 --> 00:28:13,330
haven't or may be one I have have an or

00:28:10,179 --> 00:28:15,280
and the other has an end and basically

00:28:13,330 --> 00:28:17,440
what we do is we translate the

00:28:15,280 --> 00:28:19,990
maintenance traction and then we do a

00:28:17,440 --> 00:28:22,510
pattern matching to actually map each

00:28:19,990 --> 00:28:25,720
instruction to the correct semantics so

00:28:22,510 --> 00:28:29,920
but they are still quite a lot like more

00:28:25,720 --> 00:28:31,330
than one thousand the second question

00:28:29,920 --> 00:28:33,400
was how do we make sure the two

00:28:31,330 --> 00:28:35,380
implementations produce the same result

00:28:33,400 --> 00:28:40,420
so that'll be some work that we have to

00:28:35,380 --> 00:28:43,090
do when we merge them the Rev ng revenge

00:28:40,420 --> 00:28:45,400
implementation uses the standalone

00:28:43,090 --> 00:28:48,460
runtime and the angel semi hosting calls

00:28:45,400 --> 00:28:51,010
and and the Qualcomm implementation uses

00:28:48,460 --> 00:28:52,780
Linux user space so the quickest thing

00:28:51,010 --> 00:28:55,150
would be to have them pull the Linux

00:28:52,780 --> 00:28:57,280
user space and their implementation and

00:28:55,150 --> 00:28:58,900
we can run a lot of programs on top of

00:28:57,280 --> 00:28:59,820
that and make sure they execute the same

00:28:58,900 --> 00:29:03,080
way

00:28:59,820 --> 00:29:06,360
alternatively we could have them

00:29:03,080 --> 00:29:09,450
generate from their flex and bison tree

00:29:06,360 --> 00:29:12,889
the ephah wrap macro definitions that

00:29:09,450 --> 00:29:12,889
you saw earlier in the presentation

00:29:19,369 --> 00:29:22,519
thank you

00:29:22,690 --> 00:29:33,359
[Applause]

00:29:26,510 --> 00:29:33,359

YouTube URL: https://www.youtube.com/watch?v=3EpnTYBOXCI


