Title: [2019] muser: Mediated User Space Device by Thanos Makatos, & Swapnil Ingle
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	Meet muser, a framework built on top of vfio/mdev for implementing PCI devices in userspace. It consists of a kernel module that acts as the mediated device and a userspace library where the core of the device is implemented. Applications using libmuser must only provide a description and callbacks for read/write.

muser abstracts the complexity yet allows tremendous flexibility. It manages interrupts, the PCI config space, memory translation, handles interaction with vfio/mdev and much more. While allowing customization where needed (for power users), it can also offer bindings for various languages. To prove simplicity, we will write and test a device live during the talk!

This is very useful with QEMU, where devices presented via vfio can be directly passed to VMs. It also enables a single userspace process to manage devices for multiple VMs, which has performance benefits.

---

Thanos Makatos
Nutanix
Member of Technical Staff

I'm a software engineer with experience in storage systems, virtualization, software-defined storage, and HCI.

Swapnil Ingle
Nutanix
Member of technical staff

I am a software engineer working with Nutanix on Acropolis hypervisor. I have experience in storage protocols, RDMA, block layer and filesystems.

Note: There's no video recording available for this talk due to technical issues.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,680 --> 00:00:12,080
so when it comes to device

00:00:10,050 --> 00:00:14,370
virtualization the top-of-mind

00:00:12,080 --> 00:00:17,310
undisputable framework to use is of

00:00:14,370 --> 00:00:20,070
course GNU in recent years with the

00:00:17,310 --> 00:00:21,150
advent of low latency i/o devices there

00:00:20,070 --> 00:00:25,730
has been a growth in the use of

00:00:21,150 --> 00:00:28,260
technologies like V hosts which allow

00:00:25,730 --> 00:00:30,439
which allows devices to be virtualized

00:00:28,260 --> 00:00:33,059
from a single process in the hypervisor

00:00:30,439 --> 00:00:36,329
this is critical for efficiency because

00:00:33,059 --> 00:00:36,920
polling can be done from few course to

00:00:36,329 --> 00:00:39,690
many VMs

00:00:36,920 --> 00:00:42,270
however v host is practically limited to

00:00:39,690 --> 00:00:45,500
virtio so a new kind of technology is

00:00:42,270 --> 00:00:45,500
needed for other types of devices

00:00:45,989 --> 00:00:50,370
I'm Thanos and along with my colleague

00:00:48,450 --> 00:00:52,620
Scott Neil will present the EM user

00:00:50,370 --> 00:00:58,440
framework which allows us to virtualize

00:00:52,620 --> 00:01:00,660
devices outside game you so as we said

00:00:58,440 --> 00:01:03,270
if we want to use polling to achieve

00:01:00,660 --> 00:01:07,500
high performance we can either use

00:01:03,270 --> 00:01:10,439
vhosts and Versailles o which doesn't

00:01:07,500 --> 00:01:13,650
see it all types of devices or burn an

00:01:10,439 --> 00:01:17,130
entire core per VM just for polling

00:01:13,650 --> 00:01:19,979
because a VMs virtual device can only be

00:01:17,130 --> 00:01:21,570
emulated by its own kyani process as the

00:01:19,979 --> 00:01:28,320
number of VMs increases this just

00:01:21,570 --> 00:01:31,100
doesn't scale also if emulation for a

00:01:28,320 --> 00:01:33,090
particular device fails in the hole in

00:01:31,100 --> 00:01:34,740
Kenya because of a bug that there's

00:01:33,090 --> 00:01:38,040
nothing we can do to fix it the VM is

00:01:34,740 --> 00:01:40,650
gone bust and finally it is impossible

00:01:38,040 --> 00:01:43,170
to upgrade emulation for a particular

00:01:40,650 --> 00:01:46,439
device and a guest without effectively

00:01:43,170 --> 00:01:48,470
restarting the entire TMU process for

00:01:46,439 --> 00:01:52,920
instance by live migrating the guest and

00:01:48,470 --> 00:01:54,780
this can be a very risky procedure one

00:01:52,920 --> 00:01:57,930
way to solve these problems is to move

00:01:54,780 --> 00:02:01,860
device emulation into a V FIO and dev

00:01:57,930 --> 00:02:04,680
driver in the kernel however moving

00:02:01,860 --> 00:02:06,780
device emulation in the kernel has

00:02:04,680 --> 00:02:10,050
drawbacks it's harder to write kernel

00:02:06,780 --> 00:02:12,030
code it's harder to maintain it and bugs

00:02:10,050 --> 00:02:14,910
can be much more disastrous than users

00:02:12,030 --> 00:02:20,010
face so the question is is there a

00:02:14,910 --> 00:02:23,280
better way to solve these problems let's

00:02:20,010 --> 00:02:25,650
look at the complete picture the FIM Dev

00:02:23,280 --> 00:02:27,900
allows us to virtualize a device in the

00:02:25,650 --> 00:02:30,600
kernel and by virtualized we mean either

00:02:27,900 --> 00:02:31,890
provide a CeraVe capabilities for a

00:02:30,600 --> 00:02:34,950
physical device that does not support

00:02:31,890 --> 00:02:36,930
this ROV or emulate a device from a

00:02:34,950 --> 00:02:39,330
single context which allows for

00:02:36,930 --> 00:02:42,060
efficient polling however as we said

00:02:39,330 --> 00:02:43,580
moving device emulation and the kernel

00:02:42,060 --> 00:02:49,019
has its drawbacks

00:02:43,580 --> 00:02:49,820
now JMU allows us to emulate the device

00:02:49,019 --> 00:02:52,320
in userspace

00:02:49,820 --> 00:02:53,070
but unless we use because user and

00:02:52,320 --> 00:02:55,650
vertigo

00:02:53,070 --> 00:02:57,600
we cannot emulate multiple devices from

00:02:55,650 --> 00:02:59,580
a single process in the hypervisor and

00:02:57,600 --> 00:03:03,230
this makes polling prohibitively

00:02:59,580 --> 00:03:06,030
expensive so what we came up with is

00:03:03,230 --> 00:03:09,450
combining the advantages of BFI undef

00:03:06,030 --> 00:03:10,980
and qmu without the disadvantages and we

00:03:09,450 --> 00:03:13,560
achieve this by creating a framework

00:03:10,980 --> 00:03:17,040
that allows us to move device simulation

00:03:13,560 --> 00:03:20,220
in user space outside kmu without using

00:03:17,040 --> 00:03:22,470
v host user we call this framework M

00:03:20,220 --> 00:03:26,329
user which stands for mediated user

00:03:22,470 --> 00:03:30,720
space device in its core it's

00:03:26,329 --> 00:03:32,640
essentially a VF IO kernel driver that

00:03:30,720 --> 00:03:39,000
simply relays operations into a user

00:03:32,640 --> 00:03:43,350
space process M user is not specific to

00:03:39,000 --> 00:03:46,350
ki nu much like VF I entered but T mu is

00:03:43,350 --> 00:03:50,359
our main use case now Swapnil will

00:03:46,350 --> 00:03:50,359
explain how M user works under the hood

00:03:51,599 --> 00:03:57,480
okay so before going into the

00:03:54,090 --> 00:03:59,159
implementation details of M user let us

00:03:57,480 --> 00:04:01,530
first have a look into the building

00:03:59,159 --> 00:04:04,920
components for M user VF i/o which

00:04:01,530 --> 00:04:08,129
stands for virtual function io v 5o is

00:04:04,920 --> 00:04:10,799
device and iommu agnostic driver

00:04:08,129 --> 00:04:12,629
framework which is used to exist

00:04:10,799 --> 00:04:15,930
physical device directly from user space

00:04:12,629 --> 00:04:18,539
via fire exposes physical device to user

00:04:15,930 --> 00:04:22,349
space in secure iommu enabled

00:04:18,539 --> 00:04:26,490
environment kaymu uses VF IO to expose

00:04:22,349 --> 00:04:28,440
physical device to virtual machine one

00:04:26,490 --> 00:04:31,259
physical device can be passed through to

00:04:28,440 --> 00:04:34,139
one virtual machine physical devices

00:04:31,259 --> 00:04:36,449
which supports SR io v can be passed

00:04:34,139 --> 00:04:39,419
through multiple virtual machines i sir

00:04:36,449 --> 00:04:40,830
io v implements the logic to implement

00:04:39,419 --> 00:04:42,449
multiple instances of the physical

00:04:40,830 --> 00:04:45,150
devices and that can be passed through

00:04:42,449 --> 00:04:47,250
my tipple virtual machines but it is

00:04:45,150 --> 00:04:50,639
limited to the number of virtual

00:04:47,250 --> 00:04:52,770
functions implemented by s RR v so what

00:04:50,639 --> 00:04:56,099
about the devices which does not support

00:04:52,770 --> 00:04:58,530
sr io v VF i am d framework can be used

00:04:56,099 --> 00:05:01,590
by such devices and then those devices

00:04:58,530 --> 00:05:04,770
can also be passed to perch on multiple

00:05:01,590 --> 00:05:09,050
virtual machines M user leverages Wi-Fi

00:05:04,770 --> 00:05:11,789
om do framework so quick takeaways

00:05:09,050 --> 00:05:14,090
single camu process cannot emulate

00:05:11,789 --> 00:05:16,979
device for multiple virtual machines a

00:05:14,090 --> 00:05:18,900
single physical device cannot be passed

00:05:16,979 --> 00:05:23,099
through to multiple virtual machine

00:05:18,900 --> 00:05:25,530
unless it supports SRO v VF I am the

00:05:23,099 --> 00:05:27,479
framework can be used by physical

00:05:25,530 --> 00:05:29,580
devices and then that can be passed

00:05:27,479 --> 00:05:31,770
through to multiple virtual machines but

00:05:29,580 --> 00:05:37,199
it required implementation of vendor

00:05:31,770 --> 00:05:40,889
specific mediated kernel driver VF io m

00:05:37,199 --> 00:05:42,990
de mediated driver implements the logic

00:05:40,889 --> 00:05:45,419
to share the physical device between

00:05:42,990 --> 00:05:47,370
multiple virtual machines but it is not

00:05:45,419 --> 00:05:49,259
necessary that this mediated driver

00:05:47,370 --> 00:05:51,960
should be backed by a real physical

00:05:49,259 --> 00:05:55,289
device it can also be a virtual device

00:05:51,960 --> 00:05:57,360
and there comes M user M user builds on

00:05:55,289 --> 00:06:01,080
top of wave form the framework and

00:05:57,360 --> 00:06:04,889
extends it to write physic virtual

00:06:01,080 --> 00:06:05,550
devices into user space so what is M

00:06:04,889 --> 00:06:07,830
user

00:06:05,550 --> 00:06:10,440
am user is framework for implementing

00:06:07,830 --> 00:06:13,139
PCI device emulation in userspace

00:06:10,440 --> 00:06:15,900
am user mainly consists of two

00:06:13,139 --> 00:06:18,629
components one is M user dot ko which is

00:06:15,900 --> 00:06:22,110
a kernel implemented mediated device

00:06:18,629 --> 00:06:25,259
driver and second is Lib M user which is

00:06:22,110 --> 00:06:27,960
a user space library so what does M user

00:06:25,259 --> 00:06:31,169
offer single process can emulate

00:06:27,960 --> 00:06:33,900
multiple devices this means from single

00:06:31,169 --> 00:06:36,030
process application can pull for

00:06:33,900 --> 00:06:38,250
multiple virtual machines to get the i/o

00:06:36,030 --> 00:06:39,960
request and on the other side the same

00:06:38,250 --> 00:06:41,430
application can also Pole to the

00:06:39,960 --> 00:06:45,990
physical device to get died of

00:06:41,430 --> 00:06:48,690
complications this means that by doing

00:06:45,990 --> 00:06:51,300
this we can say a significant amount of

00:06:48,690 --> 00:06:56,250
CPU cycles another benefit of using M

00:06:51,300 --> 00:06:58,500
user is it completely hides VF IO and PC

00:06:56,250 --> 00:07:01,229
a specification related implementation

00:06:58,500 --> 00:07:03,330
so it is hidden from the device

00:07:01,229 --> 00:07:05,819
emulation application so device

00:07:03,330 --> 00:07:08,819
emulation application just need to link

00:07:05,819 --> 00:07:11,759
to live M user and need to specify some

00:07:08,819 --> 00:07:15,259
device specific data which which is a

00:07:11,759 --> 00:07:18,210
device ID vendor ID PCI region supported

00:07:15,259 --> 00:07:20,069
interrupts PCI capabilities and the

00:07:18,210 --> 00:07:24,180
device emulation also need to provide

00:07:20,069 --> 00:07:25,979
some callbacks for the PC for the

00:07:24,180 --> 00:07:28,139
commands and those callbacks will be

00:07:25,979 --> 00:07:30,719
called by Lib M user so these callbacks

00:07:28,139 --> 00:07:35,610
are like handling PCI regions

00:07:30,719 --> 00:07:37,289
capabilities a map or device reset so

00:07:35,610 --> 00:07:40,409
let us have a detailed look into the

00:07:37,289 --> 00:07:43,529
components of M user M user dot k1 which

00:07:40,409 --> 00:07:46,080
implements the mediated kernel driver so

00:07:43,529 --> 00:07:48,479
it registers with v v md framework and

00:07:46,080 --> 00:07:51,000
also provides the callback which will be

00:07:48,479 --> 00:07:52,770
called back from the FIM the framework

00:07:51,000 --> 00:07:55,349
depending upon the commands coming from

00:07:52,770 --> 00:07:58,340
the kaymu side on the other side M user

00:07:55,349 --> 00:08:02,909
dot KO also creates a character device

00:07:58,340 --> 00:08:05,130
to pass those operations to lip em user

00:08:02,909 --> 00:08:08,930
so the communication between M user dot

00:08:05,130 --> 00:08:12,930
KO and lip M user happens why are this

00:08:08,930 --> 00:08:15,449
user character device so device

00:08:12,930 --> 00:08:16,289
emulation which is libram user it opens

00:08:15,449 --> 00:08:19,319
the MU

00:08:16,289 --> 00:08:21,089
character device and then it passes the

00:08:19,319 --> 00:08:24,089
device emulation information to M user

00:08:21,089 --> 00:08:26,520
dot KO then it waits for command to be

00:08:24,089 --> 00:08:28,949
issued from M user dot KO currently this

00:08:26,520 --> 00:08:31,229
wait is synchronous we want to make it a

00:08:28,949 --> 00:08:33,889
synchronous by making it po level but

00:08:31,229 --> 00:08:37,259
that's one of the items for future work

00:08:33,889 --> 00:08:42,329
the interface between M user dot ko and

00:08:37,259 --> 00:08:44,250
lip M user is custom ioctl so now let us

00:08:42,329 --> 00:08:47,160
have a look into a generic command

00:08:44,250 --> 00:08:49,769
workflow in M user suki mo calls into

00:08:47,160 --> 00:08:52,259
wave 5 m do and passes some command then

00:08:49,769 --> 00:08:55,680
this command is passed further down to M

00:08:52,259 --> 00:08:57,420
user dot k then M user dot KO path says

00:08:55,680 --> 00:09:00,600
this command to Lib am user and

00:08:57,420 --> 00:09:02,759
depending upon the command type lip M

00:09:00,600 --> 00:09:04,920
user calls into device simulation and

00:09:02,759 --> 00:09:09,690
then device emulation can implements it

00:09:04,920 --> 00:09:13,050
own logic there so in order to emulate a

00:09:09,690 --> 00:09:15,209
device some main functionality needs to

00:09:13,050 --> 00:09:18,389
be supported these functionalities are

00:09:15,209 --> 00:09:20,130
like DMA mapping device memory and

00:09:18,389 --> 00:09:22,589
interrupts so now we will have a look

00:09:20,130 --> 00:09:26,459
into detail how M user handles all these

00:09:22,589 --> 00:09:30,360
main functionalities so let's see how do

00:09:26,459 --> 00:09:32,899
you may map happens him a device needs

00:09:30,360 --> 00:09:36,209
to DMA data to and from guest memory

00:09:32,899 --> 00:09:37,589
kimu calls in to verify I am down to

00:09:36,209 --> 00:09:40,319
register test memory

00:09:37,589 --> 00:09:44,370
sorry guest memory for DMA operations in

00:09:40,319 --> 00:09:47,010
order to do that k mu calls map DMA

00:09:44,370 --> 00:09:49,440
Ossetia then this map DMA ioctl

00:09:47,010 --> 00:09:53,100
is pass further down to M user dot K or

00:09:49,440 --> 00:09:55,110
M user dot Q keeps the track of the

00:09:53,100 --> 00:09:57,449
physical pages which are behind the

00:09:55,110 --> 00:09:59,040
guest memory and then this map DME

00:09:57,449 --> 00:10:02,939
command is passed to you the space to

00:09:59,040 --> 00:10:05,970
live M user then leap M user again calls

00:10:02,939 --> 00:10:09,060
back into M user dot KO to set up the D

00:10:05,970 --> 00:10:11,819
mmm memory in order to do that lip M

00:10:09,060 --> 00:10:14,930
user invokes a map system call on the M

00:10:11,819 --> 00:10:18,810
user control device then M user dot ko

00:10:14,930 --> 00:10:21,689
inserts the device memory pages into the

00:10:18,810 --> 00:10:23,759
VMA of device emulation and once this is

00:10:21,689 --> 00:10:26,160
done the control goes back to Kemah

00:10:23,759 --> 00:10:29,759
one important thing to note here is that

00:10:26,160 --> 00:10:31,559
the guest memory pages of

00:10:29,759 --> 00:10:34,049
the guests memory pages are being shared

00:10:31,559 --> 00:10:36,720
with device emulation in order to

00:10:34,049 --> 00:10:38,579
achieve this gem you must be start with

00:10:36,720 --> 00:10:41,069
share is equal to yes operation which

00:10:38,579 --> 00:10:44,369
enables the guests memory shareable em

00:10:41,069 --> 00:10:47,669
user also keeps the tracking of GPA to

00:10:44,369 --> 00:10:52,049
current VM a mapping so device emulation

00:10:47,669 --> 00:10:53,850
can always query for this mapping so let

00:10:52,049 --> 00:10:56,850
us see how mapping of device memory and

00:10:53,850 --> 00:10:59,999
register happens so the PCI regions can

00:10:56,850 --> 00:11:01,619
be mapable or IO accessible it totally

00:10:59,999 --> 00:11:04,439
depends upon the implementation of

00:11:01,619 --> 00:11:06,569
device emulation if the PCI device is IO

00:11:04,439 --> 00:11:08,489
accessible then the device emulation

00:11:06,569 --> 00:11:11,040
needs to implement the read and write

00:11:08,489 --> 00:11:14,850
which comes on the PCI regions from kmol

00:11:11,040 --> 00:11:18,869
and if the PCI regions is mapable then

00:11:14,850 --> 00:11:21,779
chemicals into VF v md framework to map

00:11:18,869 --> 00:11:23,819
the pci region to do this it calls a map

00:11:21,779 --> 00:11:24,959
on the via file device file descriptor

00:11:23,819 --> 00:11:28,019
which is the character device itself

00:11:24,959 --> 00:11:31,499
then this map is sent further down to m

00:11:28,019 --> 00:11:35,100
user dot KO then the user dot KO sends

00:11:31,499 --> 00:11:36,929
this a map to libram user then lib m

00:11:35,100 --> 00:11:39,119
user calls back into the device

00:11:36,929 --> 00:11:42,269
simulation where device emulation can

00:11:39,119 --> 00:11:44,609
implement its own logic and at the end

00:11:42,269 --> 00:11:47,459
it should again call back in to lip M

00:11:44,609 --> 00:11:50,489
user by invoking LM a map API which is

00:11:47,459 --> 00:11:54,149
exposed by Libba user then this LM a map

00:11:50,489 --> 00:11:56,970
calls into a music KO in order to set up

00:11:54,149 --> 00:11:59,339
the device memory to do this call it

00:11:56,970 --> 00:12:01,199
again calls a map on the control device

00:11:59,339 --> 00:12:04,949
which is the character M user device

00:12:01,199 --> 00:12:07,669
then M user dot K allocates pages for

00:12:04,949 --> 00:12:10,230
the device memory then those pages are

00:12:07,669 --> 00:12:13,559
inserted into the VM a of device

00:12:10,230 --> 00:12:15,389
emulation as well as into the VM a which

00:12:13,559 --> 00:12:17,609
is passed by way Phi of M developer

00:12:15,389 --> 00:12:21,779
layer once this setup is done the

00:12:17,609 --> 00:12:23,759
control goes back to kamo so one

00:12:21,779 --> 00:12:26,249
important thing to notice here is like

00:12:23,759 --> 00:12:29,939
the device memory pages stays within

00:12:26,249 --> 00:12:31,829
inside the kernel with M user dot ko so

00:12:29,939 --> 00:12:34,259
even if device emulation crashes

00:12:31,829 --> 00:12:36,359
restarts or some upgrade is needed it

00:12:34,259 --> 00:12:38,189
can always connect back to the device

00:12:36,359 --> 00:12:41,789
memory into the kernel which is with M

00:12:38,189 --> 00:12:43,590
user dot ko we also support sparse a map

00:12:41,789 --> 00:12:45,900
if device emulation

00:12:43,590 --> 00:12:50,610
has interest in using sparse a map it

00:12:45,900 --> 00:12:53,370
can easily use it so let's see how

00:12:50,610 --> 00:12:56,220
interrupts are set up so Khemu passes ir

00:12:53,370 --> 00:12:58,110
qfd this is the file descriptor which is

00:12:56,220 --> 00:12:58,560
used to trigger the interrupts into the

00:12:58,110 --> 00:13:01,589
guest

00:12:58,560 --> 00:13:05,520
then this ir qfd is passed through pass

00:13:01,589 --> 00:13:07,920
to m user dot KO m user dot KO installs

00:13:05,520 --> 00:13:10,800
this ir qfd into the file descriptor

00:13:07,920 --> 00:13:14,220
table of device emulation by doing this

00:13:10,800 --> 00:13:17,310
it is very easy to trigger interruption

00:13:14,220 --> 00:13:19,290
to the guest by device emulation just by

00:13:17,310 --> 00:13:23,430
calling LM iya could trigger ap I

00:13:19,290 --> 00:13:27,300
currently am user supports in tax MSI

00:13:23,430 --> 00:13:30,750
and MSI X interrupts types so AM user

00:13:27,300 --> 00:13:32,940
framework handles all these VF IO and PC

00:13:30,750 --> 00:13:36,630
a specification related implementation

00:13:32,940 --> 00:13:39,150
so this make writing device emulation

00:13:36,630 --> 00:13:42,360
very easy so not tunnels will explain

00:13:39,150 --> 00:13:44,820
more about the aps exposed by Lib M user

00:13:42,360 --> 00:13:47,040
and he will also show us how easy it is

00:13:44,820 --> 00:13:54,750
to write a device emulation in either

00:13:47,040 --> 00:13:58,080
space using amis a framework so what we

00:13:54,750 --> 00:13:59,730
see here is pretty much it we have a

00:13:58,080 --> 00:14:01,760
structure describe fisheye region

00:13:59,730 --> 00:14:03,780
whether it's readable writable size

00:14:01,760 --> 00:14:05,130
pointer to a function that is called

00:14:03,780 --> 00:14:07,560
whenever the ridges is accessed by the

00:14:05,130 --> 00:14:09,960
guest the function looks like this it

00:14:07,560 --> 00:14:11,160
takes a buffer receiving data being read

00:14:09,960 --> 00:14:13,170
or two things that have been written

00:14:11,160 --> 00:14:16,350
whether it's read or write account on an

00:14:13,170 --> 00:14:17,790
offset there can be obviously up to nine

00:14:16,350 --> 00:14:21,120
such regions they're all grouped into

00:14:17,790 --> 00:14:24,600
the Reg info array unused regions are

00:14:21,120 --> 00:14:26,250
left blank in the same struct PCI info

00:14:24,600 --> 00:14:26,760
we also declare the absolute bare

00:14:26,250 --> 00:14:28,920
minimum

00:14:26,760 --> 00:14:31,140
Teesha information we need in order to

00:14:28,920 --> 00:14:35,520
emulate device which is the vendor

00:14:31,140 --> 00:14:39,420
device ID class code etc we also specify

00:14:35,520 --> 00:14:43,350
the number of iron queues for each Erica

00:14:39,420 --> 00:14:46,650
tab type our device supports we can also

00:14:43,350 --> 00:14:47,670
provide PCI capabilities we only need to

00:14:46,650 --> 00:14:49,890
specify the ID

00:14:47,670 --> 00:14:52,500
size and a callback function for the

00:14:49,890 --> 00:14:53,970
capability the content of the capability

00:14:52,500 --> 00:14:54,790
itself is maintained by the device

00:14:53,970 --> 00:14:57,790
simulation

00:14:54,790 --> 00:15:00,250
all this information is grouped into a

00:14:57,790 --> 00:15:02,410
single struct device info which is

00:15:00,250 --> 00:15:05,110
passed to struck to function

00:15:02,410 --> 00:15:07,959
context create which creates an M user

00:15:05,110 --> 00:15:10,389
context this context is then passed to

00:15:07,959 --> 00:15:12,399
function context drive which effectively

00:15:10,389 --> 00:15:14,040
realizes device simulation from this

00:15:12,399 --> 00:15:16,360
point we can start the guest the

00:15:14,040 --> 00:15:19,180
framework also provides a function to

00:15:16,360 --> 00:15:21,790
interrupt the guest and also a set of

00:15:19,180 --> 00:15:23,709
functions used to map guest physical

00:15:21,790 --> 00:15:27,870
addresses into the device emulations

00:15:23,709 --> 00:15:33,250
virtual memory space so here's how

00:15:27,870 --> 00:15:35,800
device looks like in the guest the

00:15:33,250 --> 00:15:38,829
device emulation looks like we have the

00:15:35,800 --> 00:15:42,370
vendor and device ID we only have let's

00:15:38,829 --> 00:15:44,709
say only one PCI region bar 0 it's

00:15:42,370 --> 00:15:48,760
readable writable it's 64 bytes in size

00:15:44,709 --> 00:15:50,829
and accesses to this bar are handled by

00:15:48,760 --> 00:15:54,339
the bar 0 callback which is declared

00:15:50,829 --> 00:15:55,089
here and our device also supports index

00:15:54,339 --> 00:15:57,820
interrupt

00:15:55,089 --> 00:16:00,339
so the only thing now our device

00:15:57,820 --> 00:16:02,620
simulation does is simply receive call

00:16:00,339 --> 00:16:08,980
box whenever the guest reads from all

00:16:02,620 --> 00:16:11,069
rights to this bar the the standard PCI

00:16:08,980 --> 00:16:13,750
header which is the first 64 bytes are

00:16:11,069 --> 00:16:18,699
completely handled by the end-user

00:16:13,750 --> 00:16:20,740
framework now there are many functions M

00:16:18,699 --> 00:16:24,160
user doesn't handle yet most importantly

00:16:20,740 --> 00:16:25,810
live migration there has been some work

00:16:24,160 --> 00:16:28,300
it's not there yet this is the first

00:16:25,810 --> 00:16:30,240
next big thing we need to tackle we

00:16:28,300 --> 00:16:33,430
would also like to make M user

00:16:30,240 --> 00:16:36,160
restartable the framework architecture

00:16:33,430 --> 00:16:38,920
supports this but we haven't yet

00:16:36,160 --> 00:16:41,529
standardized it as a function we will

00:16:38,920 --> 00:16:43,060
also like to make M user Libre user

00:16:41,529 --> 00:16:45,160
multi-threaded and also to be able to

00:16:43,060 --> 00:16:49,240
pull for commands from the kernel rather

00:16:45,160 --> 00:16:51,880
than having to block also never going

00:16:49,240 --> 00:16:55,329
goal of M user is to make implementing a

00:16:51,880 --> 00:16:56,800
PCI device as easy as possible by

00:16:55,329 --> 00:16:58,930
handing as much of the complexity as

00:16:56,800 --> 00:17:00,550
possible from the user for instance

00:16:58,930 --> 00:17:03,519
there is a lot of room for improvement

00:17:00,550 --> 00:17:05,189
in handling PCI capabilities we will

00:17:03,519 --> 00:17:07,870
also like to introduce additional

00:17:05,189 --> 00:17:10,510
language bindings not only see in fact

00:17:07,870 --> 00:17:12,870
we have device emulation implementation

00:17:10,510 --> 00:17:14,919
in Python in less than 10 lines of code

00:17:12,870 --> 00:17:17,199
we would also like to provide more

00:17:14,919 --> 00:17:20,110
examples for instance how ir cues or

00:17:17,199 --> 00:17:22,990
mapping memory mapping a device can be

00:17:20,110 --> 00:17:23,980
used and finally we would also like to

00:17:22,990 --> 00:17:27,189
be able to trap

00:17:23,980 --> 00:17:28,960
memory rights when the device supports

00:17:27,189 --> 00:17:30,640
memory map this is important when

00:17:28,960 --> 00:17:33,730
polling is used because we could

00:17:30,640 --> 00:17:37,480
temporarily suspend polling in periods

00:17:33,730 --> 00:17:42,640
of inactivity to save CPU cycles and now

00:17:37,480 --> 00:17:48,490
we're going to see an actual device

00:17:42,640 --> 00:17:50,110
implementation the device we we will

00:17:48,490 --> 00:17:52,059
show you is a general-purpose in without

00:17:50,110 --> 00:17:53,710
the device it's essentially a PCI card

00:17:52,059 --> 00:17:56,919
with an external pin that can be the one

00:17:53,710 --> 00:18:01,870
on 0 and the kernel driver and the guest

00:17:56,919 --> 00:18:05,650
can read the kernel driver we use used

00:18:01,870 --> 00:18:08,220
is called GPIO PCI ID IO 16 it's a stock

00:18:05,650 --> 00:18:08,220
Linux driver

00:18:09,540 --> 00:18:18,730
so this is our device implementation we

00:18:16,480 --> 00:18:25,740
simply declare the vendor and device ID

00:18:18,730 --> 00:18:25,740
we only have one bar oh thanks

00:18:26,789 --> 00:18:29,299
oops

00:18:30,430 --> 00:18:37,180
okay so we only have one we all have a

00:18:35,020 --> 00:18:39,490
vendor device at the only one bar bar -

00:18:37,180 --> 00:18:42,010
which is readable and writeable 256

00:18:39,490 --> 00:18:45,040
bytes in size and callbacks to this bar

00:18:42,010 --> 00:18:47,830
I access this bar are handled by the bar

00:18:45,040 --> 00:18:51,940
- callback which is declared up here and

00:18:47,830 --> 00:18:54,220
we also support index interrupts now as

00:18:51,940 --> 00:18:57,190
we said the abusive framework entirely

00:18:54,220 --> 00:18:59,740
handles the PCI config space so we don't

00:18:57,190 --> 00:19:02,650
have to declare anything here so the

00:18:59,740 --> 00:19:05,500
behavior our device exhibits which means

00:19:02,650 --> 00:19:09,630
whenever the guest driver leads tries to

00:19:05,500 --> 00:19:12,900
access the pin is to return 1 or 0 and

00:19:09,630 --> 00:19:15,340
specifically we flip between 1 1 & 0

00:19:12,900 --> 00:19:25,870
every three times the guest reads the

00:19:15,340 --> 00:19:28,510
pin and this is we can see here the

00:19:25,870 --> 00:19:31,950
device simulation running so it's just

00:19:28,510 --> 00:19:35,260
the binary we compile and we pass the

00:19:31,950 --> 00:19:37,750
VFL UUID we want em user to tell VF i/o

00:19:35,260 --> 00:19:41,710
to create a device and this is how we

00:19:37,750 --> 00:19:45,100
run cam you there's nothing special

00:19:41,710 --> 00:19:49,890
about it apart from its guest from being

00:19:45,100 --> 00:19:54,930
shared and the VF IO device being passed

00:19:49,890 --> 00:19:54,930
and now in the guest

00:20:06,369 --> 00:20:10,029
let's your device

00:20:13,360 --> 00:20:24,980
there it is and let's read the pin so we

00:20:23,180 --> 00:20:26,810
read it one two three times we get

00:20:24,980 --> 00:20:29,930
zeroes then three times again we get

00:20:26,810 --> 00:20:34,430
once and three more times zero and one

00:20:29,930 --> 00:20:38,180
again and so on so this is it we also

00:20:34,430 --> 00:20:42,230
have similar device implementations in

00:20:38,180 --> 00:20:44,570
Python except that instead of providing

00:20:42,230 --> 00:20:47,930
automatically the pin value we read it

00:20:44,570 --> 00:20:50,210
from the keyboard so thank you very much

00:20:47,930 --> 00:20:59,000
for your interest in M user please go

00:20:50,210 --> 00:21:01,970
ahead and play with it any questions so

00:20:59,000 --> 00:21:04,760
I actually have two questions first Oh

00:21:01,970 --> 00:21:07,280
what's the real use case of this other

00:21:04,760 --> 00:21:09,950
than you changing from the kernel space

00:21:07,280 --> 00:21:12,740
to the user space and there's no real

00:21:09,950 --> 00:21:17,060
device to support so you don't actually

00:21:12,740 --> 00:21:21,800
really have any real DMA or interrupts

00:21:17,060 --> 00:21:25,190
going so it is all software right so

00:21:21,800 --> 00:21:27,380
what's the real cat use case here well

00:21:25,190 --> 00:21:31,550
if your physical device does not support

00:21:27,380 --> 00:21:33,290
this Rav that's one use case or if you

00:21:31,550 --> 00:21:37,160
want to have a very complicated data

00:21:33,290 --> 00:21:39,710
path right but I'll use vo you can do

00:21:37,160 --> 00:21:42,380
that with today's and the framework

00:21:39,710 --> 00:21:43,810
already right well to do this with Md

00:21:42,380 --> 00:21:46,730
framework they need a physical device

00:21:43,810 --> 00:21:48,170
right but in our case we might not need

00:21:46,730 --> 00:21:50,660
a physical device we just need a very

00:21:48,170 --> 00:21:53,900
complicated data path we talks to other

00:21:50,660 --> 00:21:56,570
processes or other components in other

00:21:53,900 --> 00:21:59,450
virtual machines etc so we might not

00:21:56,570 --> 00:22:04,730
even know what the rest of the data path

00:21:59,450 --> 00:22:06,470
is okay so okay so my understanding is

00:22:04,730 --> 00:22:11,270
basically more like a share memory thing

00:22:06,470 --> 00:22:13,010
it's not a good device what we have use

00:22:11,270 --> 00:22:16,010
cases like for instance we would like to

00:22:13,010 --> 00:22:18,800
implement a virtual nvme controller that

00:22:16,010 --> 00:22:20,820
uses speed ekn polling which which came

00:22:18,800 --> 00:22:25,600
you know this this cannot be done

00:22:20,820 --> 00:22:27,700
okay second question is how do you plan

00:22:25,600 --> 00:22:34,860
to support multiple devices inside this

00:22:27,700 --> 00:22:37,210
deep user well the device passed to

00:22:34,860 --> 00:22:40,470
human virtual devices yeah virtual

00:22:37,210 --> 00:22:42,460
device so each device posture guest is

00:22:40,470 --> 00:22:45,040
represented by a control character

00:22:42,460 --> 00:22:46,960
device that's so there can be as many

00:22:45,040 --> 00:22:48,760
many such character devices so your

00:22:46,960 --> 00:22:51,190
process the way you implement it can

00:22:48,760 --> 00:22:53,230
pull or wait for commands for multiple

00:22:51,190 --> 00:22:55,960
devices that's fairly trivial to do so

00:22:53,230 --> 00:23:01,150
one DB use or instance will represent a

00:22:55,960 --> 00:23:05,080
one virtual device it is not necessary

00:23:01,150 --> 00:23:08,770
the device emulation application can

00:23:05,080 --> 00:23:11,530
show two by using lip am user multiple

00:23:08,770 --> 00:23:13,210
devices and from single application you

00:23:11,530 --> 00:23:15,130
can handle multiple devices so you can

00:23:13,210 --> 00:23:18,670
also pull to multiple virtual machines

00:23:15,130 --> 00:23:22,990
to receive the i/o and then you can also

00:23:18,670 --> 00:23:25,630
hold for the completion for clear my

00:23:22,990 --> 00:23:28,270
question the question is busy in one VM

00:23:25,630 --> 00:23:32,370
right if you want to emulate multiple

00:23:28,270 --> 00:23:35,260
virtual device can you support yes yeah

00:23:32,370 --> 00:23:38,140
yeah so for each virtual device there

00:23:35,260 --> 00:23:40,420
would be a mediated device so which is

00:23:38,140 --> 00:23:42,880
like the VF IO device and the VM can use

00:23:40,420 --> 00:23:45,340
that device and the there is one single

00:23:42,880 --> 00:23:49,000
they will use your instance right it is

00:23:45,340 --> 00:23:51,550
not necessary yeah it can be one or

00:23:49,000 --> 00:23:56,100
multiple also it is not necessary on the

00:23:51,550 --> 00:23:56,100
implementation okay

00:23:59,680 --> 00:24:03,820
thank you for the talk I wish that

00:24:02,350 --> 00:24:08,620
function had existed a little bit

00:24:03,820 --> 00:24:12,070
earlier did you does this work when the

00:24:08,620 --> 00:24:16,630
emulated system has an iommu with the

00:24:12,070 --> 00:24:19,510
DMA you were describing sorry again the

00:24:16,630 --> 00:24:25,300
does this work when the emulated system

00:24:19,510 --> 00:24:29,440
has an iommu the DMA does the the

00:24:25,300 --> 00:24:31,270
addresses get translated oh yes and the

00:24:29,440 --> 00:24:34,390
other one you said it's an advantage

00:24:31,270 --> 00:24:36,820
that we can have a single process but

00:24:34,390 --> 00:24:38,560
can we also have multiple processes so

00:24:36,820 --> 00:24:42,880
that we have kind of security boundary

00:24:38,560 --> 00:24:44,680
between the emulator devices yes so

00:24:42,880 --> 00:24:48,690
multiple processes can link to the

00:24:44,680 --> 00:24:54,180
library and they can be started

00:24:48,690 --> 00:24:54,180
individually thank you

00:24:58,980 --> 00:25:02,590
hi um so my question is kind of a

00:25:01,420 --> 00:25:05,500
follow-up to the previous question about

00:25:02,590 --> 00:25:07,570
iommu so one thing is translating the

00:25:05,500 --> 00:25:10,000
addresses but the other question is

00:25:07,570 --> 00:25:12,670
actually enforcing that memory

00:25:10,000 --> 00:25:14,290
protection so that if you have one

00:25:12,670 --> 00:25:16,600
process that's doing devices from

00:25:14,290 --> 00:25:18,850
multiple VMs if this process is

00:25:16,600 --> 00:25:21,160
compromised it doesn't have access to

00:25:18,850 --> 00:25:23,410
the memory full memory space of all VMs

00:25:21,160 --> 00:25:25,120
and said it only has access to what was

00:25:23,410 --> 00:25:28,660
permitted using the iommu

00:25:25,120 --> 00:25:29,740
is that something that's available is

00:25:28,660 --> 00:25:33,270
that something that's possible to

00:25:29,740 --> 00:25:36,190
implement no actually this is one of the

00:25:33,270 --> 00:25:37,990
disadvantages because if you share

00:25:36,190 --> 00:25:41,400
memory we have to have access to the

00:25:37,990 --> 00:25:44,770
entire guest memory in order to DMA so

00:25:41,400 --> 00:25:47,590
yes but you do have the M user kernel

00:25:44,770 --> 00:25:49,060
module so maybe it will be possible to

00:25:47,590 --> 00:25:52,390
do something there so that the users

00:25:49,060 --> 00:25:54,640
based process doesn't get full access to

00:25:52,390 --> 00:25:55,990
all guests RAM all the time I guess

00:25:54,640 --> 00:26:01,120
that's the direction and I'm wondering

00:25:55,990 --> 00:26:02,800
if it's possible it's going to be very

00:26:01,120 --> 00:26:05,980
expensive so our use case is hyper for

00:26:02,800 --> 00:26:08,830
us so we our translation is generally

00:26:05,980 --> 00:26:10,660
just a linear translation of memory

00:26:08,830 --> 00:26:13,180
address if we want to support that there

00:26:10,660 --> 00:26:15,400
will be a cost and it won't perform as

00:26:13,180 --> 00:26:18,420
well but apparently it might be possible

00:26:15,400 --> 00:26:18,420
to do of course

00:26:21,340 --> 00:26:27,830
hi great talk by the way so I have a

00:26:25,550 --> 00:26:30,230
question regarding the ability to

00:26:27,830 --> 00:26:32,720
upgrade the userspace process while the

00:26:30,230 --> 00:26:35,720
VM is still running so because because

00:26:32,720 --> 00:26:39,350
mm usually mediates the slow path the

00:26:35,720 --> 00:26:41,300
control plane then theoretically after

00:26:39,350 --> 00:26:43,640
for example the Rings were set up and

00:26:41,300 --> 00:26:46,280
the fast path was already set up I would

00:26:43,640 --> 00:26:48,380
like for example for the next VM sort on

00:26:46,280 --> 00:26:50,510
the next reboot of the VMS if there is a

00:26:48,380 --> 00:26:52,610
bug there to be able to upgrade that use

00:26:50,510 --> 00:26:55,250
of space process and most of the time

00:26:52,610 --> 00:26:58,520
because the VM has already booted and

00:26:55,250 --> 00:27:00,980
set up the data path and then I don't I

00:26:58,520 --> 00:27:03,920
don't care if I will rip I will be able

00:27:00,980 --> 00:27:05,450
to replace that userspace process so it

00:27:03,920 --> 00:27:07,520
won't disturb the fast path right

00:27:05,450 --> 00:27:09,830
because the resources will still be not

00:27:07,520 --> 00:27:12,260
mediated so do you plan to add some

00:27:09,830 --> 00:27:17,720
ability to upgrade that use of space

00:27:12,260 --> 00:27:20,270
process for maintainability yeah because

00:27:17,720 --> 00:27:22,040
it simulates only the slow path I want

00:27:20,270 --> 00:27:26,510
to do that without the ability without

00:27:22,040 --> 00:27:28,280
the need to to take down the VM so that

00:27:26,510 --> 00:27:37,010
on the next reboot it will walk with the

00:27:28,280 --> 00:27:39,760
walking version because device memory

00:27:37,010 --> 00:27:41,720
pages are inside the kernel and when the

00:27:39,760 --> 00:27:43,910
processor is started it can always

00:27:41,720 --> 00:27:45,470
connect back to the device memory yeah

00:27:43,910 --> 00:27:47,540
so got the old process and pick up the

00:27:45,470 --> 00:27:49,910
new and if the VM restarts yes so it

00:27:47,540 --> 00:27:51,950
will reconnect to the EM diffuser kernel

00:27:49,910 --> 00:27:59,330
model driver yeah so I think that is

00:27:51,950 --> 00:28:02,750
important ok I think the question back

00:27:59,330 --> 00:28:05,090
here during the immu was AV immu in

00:28:02,750 --> 00:28:08,030
which case you do not have the entire

00:28:05,090 --> 00:28:10,850
gas memory mapped through VF io the d f

00:28:08,030 --> 00:28:15,560
io d ma map is the io VA address

00:28:10,850 --> 00:28:18,200
relative to the device so does it

00:28:15,560 --> 00:28:20,680
actually work with a vio member you not

00:28:18,200 --> 00:28:20,680
yet okay

00:28:23,400 --> 00:28:29,350
bit connected to what previous some

00:28:27,160 --> 00:28:35,020
people asked previously so it seems to

00:28:29,350 --> 00:28:42,010
be an obvious overlap here with all the

00:28:35,020 --> 00:28:43,960
process project so have you guys try to

00:28:42,010 --> 00:28:45,880
look into it I'm not aware of how well

00:28:43,960 --> 00:28:48,130
this is progressing etc but I think it's

00:28:45,880 --> 00:28:51,010
definitely much this disaggregated model

00:28:48,130 --> 00:28:53,230
which gives us the benefit of being able

00:28:51,010 --> 00:28:55,590
to upgrade or be more resilient against

00:28:53,230 --> 00:28:55,590
failures

00:28:59,140 --> 00:29:04,880
okay thank you

00:29:02,130 --> 00:29:11,739
[Applause]

00:29:04,880 --> 00:29:11,739

YouTube URL: https://www.youtube.com/watch?v=5p4RcGihI6s


