Title: [2019] Playing Lego with Virtualization Components by Andreea Florescu & Samuel Ortiz
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	rust-vmm is an open-source project that maintains a set of high-quality virtualization building blocks. It allows developers to focus on their VMM key differentiators rather than re-implementing components like KVM API wrappers, virtio devices and memory models.

In this presentation we go over the design and structure of the project, as well as the fundamentals of building VMMs using rust-vmm. We start by describing why we think Rust is the right language. We also highlight the implications of splitting virtualization components into standalone, separate repositories. Next, we look at how rust-vmm is used in practice by Rust based VMMs and what changes are required to make the transition from a single repo model to one where packages are consumed from a shared, multi-repo. Finally, we outline how the modular nature of rust-vmm can be leveraged by non Rust based VMMs like QEMU.

---

Andreea Florescu
Amazon
Software Development Engineer

I am a software engineer with the Amazon Web Services Firecracker team. I am passionate about open source and, beyond Firecracker, I am also contributing to rust-vmm, a community effort to create a shared set of Rust-based Virtual Machine Monitor components. So far I’ve been talking about both rust-vmm and Firecracker at Fosdem, EdgeSys, Open Infrastructure Summit and KubeCon.

Samuel Ortiz
Intel
Principal Software Engineer

I currently work at Intel’s Open Source Technology Center where I’m busy with the cloud-hypervisor and Kata Containers projects. I’ve previously talked at the KVM Forum, the Open Infrastructure Summit, KubeCon and various other random open source conferences.

Note: There's no video recording available for this talk due to technical issues.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,099 --> 00:00:14,250
good morning everyone

00:00:09,559 --> 00:00:16,350
thanks for joining this session today

00:00:14,250 --> 00:00:20,189
Andrea and myself are going to talk

00:00:16,350 --> 00:00:24,570
about Russ vmm which is a recent project

00:00:20,189 --> 00:00:30,210
and how we can build vm M's with raske

00:00:24,570 --> 00:00:36,630
Menn so first one question who was not

00:00:30,210 --> 00:00:42,960
heard about rust as a language paolo of

00:00:36,630 --> 00:00:45,000
course of course okay so I'm assuming

00:00:42,960 --> 00:00:47,640
everyone has heard about Russ but a

00:00:45,000 --> 00:00:53,129
different question who has actually ever

00:00:47,640 --> 00:00:56,070
used rust okay so I was expecting this

00:00:53,129 --> 00:00:59,039
so there's a majority of people here

00:00:56,070 --> 00:01:00,719
that has never used rust so I'm not

00:00:59,039 --> 00:01:03,180
gonna make a presentation about rust but

00:01:00,719 --> 00:01:06,960
just a very quick introduction about why

00:01:03,180 --> 00:01:10,110
we're using rust with raspbian why is we

00:01:06,960 --> 00:01:11,850
think it's a good language and I'm just

00:01:10,110 --> 00:01:14,790
wanna highlight one central feature of

00:01:11,850 --> 00:01:17,970
rust which is ownership and ownership is

00:01:14,790 --> 00:01:21,270
a set of very small set of very simple

00:01:17,970 --> 00:01:23,580
rules of about who owns the data that

00:01:21,270 --> 00:01:26,670
the rust tool chain applies to each and

00:01:23,580 --> 00:01:29,250
every lines of your code so with this

00:01:26,670 --> 00:01:30,630
you can avoid with with rust ownership

00:01:29,250 --> 00:01:35,040
which is very central feature to

00:01:30,630 --> 00:01:36,840
language you avoid most of the use of

00:01:35,040 --> 00:01:38,790
the free double free dangling pointers

00:01:36,840 --> 00:01:42,509
issues that you would find with all the

00:01:38,790 --> 00:01:45,570
languages with C for example so rust

00:01:42,509 --> 00:01:48,329
builds memory safety on top of ownership

00:01:45,570 --> 00:01:50,790
and with ownership you can also because

00:01:48,329 --> 00:01:53,549
rust prevents you from using data that

00:01:50,790 --> 00:01:55,950
you don't own it also brings a much

00:01:53,549 --> 00:01:59,340
safer concurrency and multi-threading

00:01:55,950 --> 00:02:02,280
model so with simple with this simple

00:01:59,340 --> 00:02:07,020
set of rules you get memory safety and

00:02:02,280 --> 00:02:08,429
you also get concurrency safety last but

00:02:07,020 --> 00:02:10,349
not least and the very good thing about

00:02:08,429 --> 00:02:12,530
Russ is that this is all enforced at

00:02:10,349 --> 00:02:14,540
Build time so it's not dynamic it's not

00:02:12,530 --> 00:02:16,670
something that the runtime does so there

00:02:14,540 --> 00:02:19,069
is no garbage collector in interest it's

00:02:16,670 --> 00:02:21,800
not a garbage collected language so you

00:02:19,069 --> 00:02:24,040
get the benefits of safety memory safety

00:02:21,800 --> 00:02:28,250
and and concurrency safety without

00:02:24,040 --> 00:02:30,230
runtime overhead obviously this brings

00:02:28,250 --> 00:02:33,770
some complexity when you actually write

00:02:30,230 --> 00:02:35,360
code so you will find the Russell chain

00:02:33,770 --> 00:02:38,090
not being your best friend at the

00:02:35,360 --> 00:02:41,540
beginning but eventually it becomes

00:02:38,090 --> 00:02:44,360
easier and easier so why are we using

00:02:41,540 --> 00:02:46,430
rust I guess if you understood the

00:02:44,360 --> 00:02:49,880
ownership concept it's kind of obvious

00:02:46,430 --> 00:02:51,680
so if you try to map some of the main

00:02:49,880 --> 00:02:54,110
components and requirements from a vmm

00:02:51,680 --> 00:02:56,000
to the rust feature languages the rest

00:02:54,110 --> 00:02:59,660
language features it's kind of obvious

00:02:56,000 --> 00:03:02,540
so memory safety well I guess a lot of

00:02:59,660 --> 00:03:04,069
the VM components and features and

00:03:02,540 --> 00:03:05,569
requirements would benefit from from

00:03:04,069 --> 00:03:07,489
memory safety especially the memory

00:03:05,569 --> 00:03:09,890
model the vertol implementation for

00:03:07,489 --> 00:03:13,459
example you have a safer concurrency

00:03:09,890 --> 00:03:16,970
with with rust and well with vmm is

00:03:13,459 --> 00:03:18,650
typically multi-threaded binary for vcp

00:03:16,970 --> 00:03:22,160
you are your workers and and you benefit

00:03:18,650 --> 00:03:25,970
from that as well and again BM it that

00:03:22,160 --> 00:03:29,150
doesn't bring latency overhead or or a

00:03:25,970 --> 00:03:31,100
performance impact so we also benefit

00:03:29,150 --> 00:03:33,320
from this from a VM perspective so

00:03:31,100 --> 00:03:37,370
that's why we believe that rust is a

00:03:33,320 --> 00:03:40,070
very good language for building VMs so

00:03:37,370 --> 00:03:43,940
now andrew is going to talk about rugby

00:03:40,070 --> 00:03:46,790
mmm yeah so I want to start with what

00:03:43,940 --> 00:03:49,340
truss VM isn't and what raspbian

00:03:46,790 --> 00:03:51,620
isn't is not a product so you are not

00:03:49,340 --> 00:03:53,150
going to take rusts vmm compile it and

00:03:51,620 --> 00:03:55,970
there you go you can start games this is

00:03:53,150 --> 00:03:58,010
not what Russ vmm is instead you can

00:03:55,970 --> 00:04:00,049
look at Russ vmm as a collection of

00:03:58,010 --> 00:04:02,510
crates or a collection of building

00:04:00,049 --> 00:04:04,400
blocks you just take what you need to

00:04:02,510 --> 00:04:07,790
build a VM em but you will have to build

00:04:04,400 --> 00:04:09,590
your own VM so rust provides

00:04:07,790 --> 00:04:11,359
virtualization components that are

00:04:09,590 --> 00:04:13,760
written in rust and they are called

00:04:11,359 --> 00:04:16,820
crates so rust packages are called

00:04:13,760 --> 00:04:19,640
crates it's also open source so you can

00:04:16,820 --> 00:04:24,620
find it out we do need hub I'm nervous

00:04:19,640 --> 00:04:26,540
and sorry so why would we want to start

00:04:24,620 --> 00:04:30,410
this project

00:04:26,540 --> 00:04:34,160
first it offers faster development for

00:04:30,410 --> 00:04:36,440
new vmm so if you have a particular use

00:04:34,160 --> 00:04:38,570
case for a V mm and you want to write

00:04:36,440 --> 00:04:40,850
your own V mm instead of starting from

00:04:38,570 --> 00:04:42,470
scratch you can start from a set of

00:04:40,850 --> 00:04:47,470
already existing virtualization

00:04:42,470 --> 00:04:51,170
components each component in Rizvi mm is

00:04:47,470 --> 00:04:52,940
very well tested and we also exist very

00:04:51,170 --> 00:04:54,980
much on security because that is very

00:04:52,940 --> 00:04:56,240
important when you have multiple

00:04:54,980 --> 00:04:58,850
projects that are using the same

00:04:56,240 --> 00:05:00,440
components and the third thing is that

00:04:58,850 --> 00:05:02,390
we want to provide a very clean

00:05:00,440 --> 00:05:04,700
interface and by clean interface where I

00:05:02,390 --> 00:05:07,760
really mean is that the interface needs

00:05:04,700 --> 00:05:12,010
to be flexible enough so that multiple

00:05:07,760 --> 00:05:14,480
VMs with different use cases can use it

00:05:12,010 --> 00:05:17,990
one of the projects that is currently

00:05:14,480 --> 00:05:20,840
using res me mmm is firecracker I talked

00:05:17,990 --> 00:05:23,030
about it a bit yesterday just like

00:05:20,840 --> 00:05:26,450
montrezl it's a virtual machine monitor

00:05:23,030 --> 00:05:28,070
and super lightweight and in firecracker

00:05:26,450 --> 00:05:30,140
we have this crate which is called vm

00:05:28,070 --> 00:05:33,980
memory that provides abstraction for

00:05:30,140 --> 00:05:35,630
guest memory and it in vm memory you

00:05:33,980 --> 00:05:38,510
have a few primitives so one of them is

00:05:35,630 --> 00:05:40,520
the guest address then you have a memory

00:05:38,510 --> 00:05:42,710
region it which is basically just a

00:05:40,520 --> 00:05:44,270
guest address which represents the start

00:05:42,710 --> 00:05:45,050
of the memory region and then in

00:05:44,270 --> 00:05:47,620
firecracker

00:05:45,050 --> 00:05:50,900
you have an anonymous shared memory and

00:05:47,620 --> 00:05:53,210
then multiple regions in firecracker

00:05:50,900 --> 00:05:56,840
represent and where anywhere else

00:05:53,210 --> 00:05:58,760
actually represent the guest memory and

00:05:56,840 --> 00:06:01,760
the memory regions are just represented

00:05:58,760 --> 00:06:04,850
as a vector of non-overlapping memory

00:06:01,760 --> 00:06:07,190
regions so now this is very specific to

00:06:04,850 --> 00:06:08,810
firecrackers so when we and these are

00:06:07,190 --> 00:06:11,930
actually implemented with structure so

00:06:08,810 --> 00:06:14,540
just structures with implementations and

00:06:11,930 --> 00:06:16,280
when we moved this crate to res mmmm

00:06:14,540 --> 00:06:20,060
what we actually did is to convert all

00:06:16,280 --> 00:06:22,910
the structures to trace so what is a

00:06:20,060 --> 00:06:24,590
trait as rust puts it a trait is a

00:06:22,910 --> 00:06:27,470
collection of metals defined for an

00:06:24,590 --> 00:06:30,620
unknown type self but in other simpler

00:06:27,470 --> 00:06:33,400
words trait is just an interface so you

00:06:30,620 --> 00:06:35,780
can also call it like an abstract class

00:06:33,400 --> 00:06:37,130
because it's an interface that can also

00:06:35,780 --> 00:06:38,300
have methods with default

00:06:37,130 --> 00:06:41,810
implementations

00:06:38,300 --> 00:06:44,450
which you can override so now let's look

00:06:41,810 --> 00:06:46,340
a bit again at why we actually wanted

00:06:44,450 --> 00:06:47,990
traits we wanted traits because the

00:06:46,340 --> 00:06:49,040
guest memory can be represented in

00:06:47,990 --> 00:06:51,680
multiple ways

00:06:49,040 --> 00:06:53,570
so firecracker just uses one of them but

00:06:51,680 --> 00:06:55,820
then you can also have memory that is

00:06:53,570 --> 00:06:57,530
actually backed by a file in firecracker

00:06:55,820 --> 00:06:59,750
this is not possible at the moment so

00:06:57,530 --> 00:07:04,540
with a trait you have the flexibility of

00:06:59,750 --> 00:07:06,890
implementing your own back-end and

00:07:04,540 --> 00:07:09,410
implementing your custom back-end is not

00:07:06,890 --> 00:07:12,320
the only reason why you want to use

00:07:09,410 --> 00:07:14,270
traits in res mm another reason is that

00:07:12,320 --> 00:07:16,100
even though we strive to have components

00:07:14,270 --> 00:07:19,240
that are independent this in practice

00:07:16,100 --> 00:07:22,400
cannot possibly happen so you will have

00:07:19,240 --> 00:07:25,280
dependencies between components and one

00:07:22,400 --> 00:07:26,870
classic example is the dependency

00:07:25,280 --> 00:07:29,510
between the Linux loader and the vm

00:07:26,870 --> 00:07:31,730
memory linux loader is just a simple

00:07:29,510 --> 00:07:34,340
crate that just loads a kernel image

00:07:31,730 --> 00:07:36,860
into guest memory so because of that it

00:07:34,340 --> 00:07:39,350
obviously needs a reference to the guest

00:07:36,860 --> 00:07:43,600
memory and now if you think about it

00:07:39,350 --> 00:07:46,040
instead of actually depending on the

00:07:43,600 --> 00:07:49,070
guest memory implementation you can just

00:07:46,040 --> 00:07:51,080
depend on a trait which offers end-users

00:07:49,070 --> 00:07:53,180
the possibility to use the Linux loader

00:07:51,080 --> 00:07:55,490
but at the same time not depend on an

00:07:53,180 --> 00:07:58,370
actual implementation of the guest

00:07:55,490 --> 00:08:00,740
memory so you will see like in red there

00:07:58,370 --> 00:08:03,560
is a trait called guest memory and then

00:08:00,740 --> 00:08:07,280
a structure cost called cache memory and

00:08:03,560 --> 00:08:09,800
map which is basically an EM map yes

00:08:07,280 --> 00:08:11,420
memory and then we have implemented an

00:08:09,800 --> 00:08:14,900
implementation for the guest memory

00:08:11,420 --> 00:08:18,380
trait for yes memory M map and in Linux

00:08:14,900 --> 00:08:20,120
loader you will see in red as well that

00:08:18,380 --> 00:08:22,550
Linux loader does not implant on guest

00:08:20,120 --> 00:08:26,680
memory and map but but it depends only

00:08:22,550 --> 00:08:30,350
on the trait so let's talk a bit about

00:08:26,680 --> 00:08:32,930
the irassman development process people

00:08:30,350 --> 00:08:36,340
have ideas we all have ideas and in res

00:08:32,930 --> 00:08:42,020
vmm from idea to an actual component

00:08:36,340 --> 00:08:44,660
it's a bit I don't know let's see you

00:08:42,020 --> 00:08:47,150
first have to submit a github issue you

00:08:44,660 --> 00:08:48,800
have to describe your idea you have to

00:08:47,150 --> 00:08:50,130
describe your component and why is it

00:08:48,800 --> 00:08:53,460
useful form VMs

00:08:50,130 --> 00:08:55,740
in general and fortress vmm and then we

00:08:53,460 --> 00:08:59,130
started design discussion solid of this

00:08:55,740 --> 00:09:02,460
happens on a github issue once we

00:08:59,130 --> 00:09:06,140
decided that this is a useful crate or

00:09:02,460 --> 00:09:09,440
component we create an empty repository

00:09:06,140 --> 00:09:12,630
the next thing is that based on the

00:09:09,440 --> 00:09:14,100
design discussions we actually start

00:09:12,630 --> 00:09:16,620
submitting pull requests in order to

00:09:14,100 --> 00:09:19,320
have a useful crater or a crate in

00:09:16,620 --> 00:09:21,570
development now from a crate in

00:09:19,320 --> 00:09:24,330
development to a crate that is actually

00:09:21,570 --> 00:09:26,490
published on crate IO small post crate

00:09:24,330 --> 00:09:30,660
is a package a rasp package and crate io

00:09:26,490 --> 00:09:34,770
is the wrost crate registry so the place

00:09:30,660 --> 00:09:37,140
where you take crates from so from a

00:09:34,770 --> 00:09:38,550
package in development to a package that

00:09:37,140 --> 00:09:40,200
is actually published there are a few

00:09:38,550 --> 00:09:43,410
things that we want to do so the first

00:09:40,200 --> 00:09:46,050
one is we want to make sure as I said

00:09:43,410 --> 00:09:48,840
before that that packages are very well

00:09:46,050 --> 00:09:51,420
tested and we want to make sure that we

00:09:48,840 --> 00:09:53,910
have the same quality bar set for all

00:09:51,420 --> 00:09:56,220
the packages in res vmm so what we do

00:09:53,910 --> 00:09:58,980
actually is we use the same continuous

00:09:56,220 --> 00:10:01,260
integration system for all packages in

00:09:58,980 --> 00:10:03,140
res vmm and this needs to be set up

00:10:01,260 --> 00:10:06,210
before we actually publish the crate

00:10:03,140 --> 00:10:07,950
then we are really sitting on

00:10:06,210 --> 00:10:09,570
documentation because this is one of the

00:10:07,950 --> 00:10:11,940
problems that most projects out there

00:10:09,570 --> 00:10:13,350
have and if you are going to use this

00:10:11,940 --> 00:10:15,900
component that you didn't develop

00:10:13,350 --> 00:10:19,440
yourself in your vmm you really need to

00:10:15,900 --> 00:10:21,930
know how to use it and this is where the

00:10:19,440 --> 00:10:24,930
documentation comes in and documentation

00:10:21,930 --> 00:10:27,930
also has usage examples then we have

00:10:24,930 --> 00:10:31,320
tests so there are like tests which are

00:10:27,930 --> 00:10:33,510
run for all crates and can be run for

00:10:31,320 --> 00:10:35,160
all crates out there but then we also

00:10:33,510 --> 00:10:38,540
have specialized crates that are

00:10:35,160 --> 00:10:41,850
depending on the implementation so

00:10:38,540 --> 00:10:44,150
integration tests and so on all the

00:10:41,850 --> 00:10:46,920
crates in firecracker and resume

00:10:44,150 --> 00:10:50,960
actually use a license so we have a

00:10:46,920 --> 00:10:50,960
Apache or BSD 3 clause

00:10:51,050 --> 00:10:56,430
currently we have a few crates that are

00:10:54,300 --> 00:10:58,560
still in development I'm not going to

00:10:56,430 --> 00:11:01,770
talk about each of them I just wanted to

00:10:58,560 --> 00:11:02,190
give you a landscape so there are mostly

00:11:01,770 --> 00:11:03,930
most

00:11:02,190 --> 00:11:07,560
we published craze there are bindings or

00:11:03,930 --> 00:11:09,900
that are offering wrappers of over KVM

00:11:07,560 --> 00:11:11,520
and so on then we have crates in

00:11:09,900 --> 00:11:13,710
development so these crates are actually

00:11:11,520 --> 00:11:16,170
they actually need more design

00:11:13,710 --> 00:11:18,210
discussions than anything else so we are

00:11:16,170 --> 00:11:20,790
a bit slower there and we also have

00:11:18,210 --> 00:11:25,500
empty crates so that the development

00:11:20,790 --> 00:11:28,230
didn't start on them and I will talk

00:11:25,500 --> 00:11:32,190
about how our projects using receive and

00:11:28,230 --> 00:11:34,890
practice thanks so how do we use rust

00:11:32,190 --> 00:11:35,850
vmn and before going into concrete

00:11:34,890 --> 00:11:38,610
example

00:11:35,850 --> 00:11:41,600
I just want to describe who is

00:11:38,610 --> 00:11:44,430
contributing right now to browse mmmm

00:11:41,600 --> 00:11:49,560
the kind of the usual suspects

00:11:44,430 --> 00:11:53,130
Red Hat Google Intel then we have AWS as

00:11:49,560 --> 00:11:55,620
well and also cloud base which is small

00:11:53,130 --> 00:11:58,080
company who is contributing to to rugby

00:11:55,620 --> 00:12:00,210
mm for the windows support so they're

00:11:58,080 --> 00:12:02,400
trying to make raspbian crates work on

00:12:00,210 --> 00:12:05,070
Windows as well and Alibaba is one of

00:12:02,400 --> 00:12:08,150
them so those are the contributors if

00:12:05,070 --> 00:12:11,840
you look at who contributes and uses

00:12:08,150 --> 00:12:14,460
raspy mmm it's basically to two entities

00:12:11,840 --> 00:12:16,110
aw yes with the with the Firecracker

00:12:14,460 --> 00:12:18,240
project and Intel with the cloud

00:12:16,110 --> 00:12:22,470
provider project which I will be talking

00:12:18,240 --> 00:12:25,470
about in a few minutes so again before

00:12:22,470 --> 00:12:27,870
going into more details on how you use

00:12:25,470 --> 00:12:31,080
those those crates how would you build a

00:12:27,870 --> 00:12:33,570
VM from rugby mm the first thing you

00:12:31,080 --> 00:12:37,260
have to do is you decide which features

00:12:33,570 --> 00:12:39,630
you want your your bmm to to be using I

00:12:37,260 --> 00:12:41,970
guess this is kind of what Paolo was

00:12:39,630 --> 00:12:44,790
describing before where you decide you

00:12:41,970 --> 00:12:46,920
want to be mmm that only does MMA oh and

00:12:44,790 --> 00:12:48,750
no vfi oh you don't need hot-plug you

00:12:46,920 --> 00:12:50,910
know it you don't need the batch pass

00:12:48,750 --> 00:12:53,460
through you you select your features and

00:12:50,910 --> 00:12:55,680
then from the world view mmm Christ you

00:12:53,460 --> 00:12:57,690
gonna you're gonna cherry-pick the

00:12:55,680 --> 00:13:00,450
crates that you need and merge that into

00:12:57,690 --> 00:13:02,270
something that looks like a B mmm so you

00:13:00,450 --> 00:13:04,830
can use functional rusty mmm crates

00:13:02,270 --> 00:13:06,839
directly from Chris dot IO for those who

00:13:04,830 --> 00:13:09,060
are published in Kratos IO or as a

00:13:06,839 --> 00:13:12,150
github dependency and I will show that

00:13:09,060 --> 00:13:13,930
as an example also later some of the

00:13:12,150 --> 00:13:16,380
raspbian crates are

00:13:13,930 --> 00:13:18,250
complete or sometimes they're complete

00:13:16,380 --> 00:13:19,600
people think they're complete but yet

00:13:18,250 --> 00:13:21,580
they're missing one specific feature

00:13:19,600 --> 00:13:25,149
that you need so you would fork those

00:13:21,580 --> 00:13:29,320
just be mmm crate into your local vmm

00:13:25,149 --> 00:13:32,500
repo or some personal repo and finally a

00:13:29,320 --> 00:13:34,779
Rose VM is missing some crates for what

00:13:32,500 --> 00:13:36,880
you're trying to do and you will have to

00:13:34,779 --> 00:13:38,200
implement those those missing Rose women

00:13:36,880 --> 00:13:42,040
crazy yourself and hopefully

00:13:38,200 --> 00:13:43,930
contributing back to Rizvi mm and last

00:13:42,040 --> 00:13:46,839
but not least you're gonna glue all

00:13:43,930 --> 00:13:51,070
those grades together into a mysterious

00:13:46,839 --> 00:13:54,250
VM and glue code okay so let's take an

00:13:51,070 --> 00:13:58,330
example we want to build vmm based on

00:13:54,250 --> 00:14:02,830
KVM we want to do device pass-through we

00:13:58,330 --> 00:14:05,470
want to do PCI virtio so basically we

00:14:02,830 --> 00:14:07,270
pick all those crates from Rose women

00:14:05,470 --> 00:14:11,320
some of them again are complete some of

00:14:07,270 --> 00:14:14,649
them are not and then add some blue code

00:14:11,320 --> 00:14:16,890
in there and you have a VM M so what is

00:14:14,649 --> 00:14:19,720
what is the glue code I'm talking about

00:14:16,890 --> 00:14:21,220
just one example of the Year the memory

00:14:19,720 --> 00:14:24,480
model that we have in rugby mm and how

00:14:21,220 --> 00:14:26,560
you include that in in in your BM m

00:14:24,480 --> 00:14:29,320
basically you're gonna tell the rust

00:14:26,560 --> 00:14:32,410
tool chain that you're pulling the code

00:14:29,320 --> 00:14:35,200
from rugby man directly the vm memory is

00:14:32,410 --> 00:14:37,240
one example of a great that is complete

00:14:35,200 --> 00:14:39,070
functional but not yet published on

00:14:37,240 --> 00:14:43,089
crazy at i/o so you have to pull it from

00:14:39,070 --> 00:14:44,770
from github directly and well in this

00:14:43,089 --> 00:14:46,870
example we're going to use the the nmap

00:14:44,770 --> 00:14:49,690
back-end as a feature because when do

00:14:46,870 --> 00:14:52,300
you and my base memory then from the

00:14:49,690 --> 00:14:55,300
code you're gonna use specific features

00:14:52,300 --> 00:14:57,520
and and expose structures and interfaces

00:14:55,300 --> 00:15:00,790
from from the memory crate and

00:14:57,520 --> 00:15:03,279
eventually this is rust is very verbose

00:15:00,790 --> 00:15:06,130
so and what we're trying to do here is

00:15:03,279 --> 00:15:08,529
just map some memory into into a guest

00:15:06,130 --> 00:15:10,720
address space create the mappings and

00:15:08,529 --> 00:15:12,700
and and and mapping to add it to the

00:15:10,720 --> 00:15:17,050
guests address space so we're just

00:15:12,700 --> 00:15:20,649
calling into the Rossby mmm creates a

00:15:17,050 --> 00:15:23,550
api and interfaces okay so we have our

00:15:20,649 --> 00:15:25,980
vm m maybe you want to do

00:15:23,550 --> 00:15:28,440
from vmm we want to do we don't need pci

00:15:25,980 --> 00:15:30,660
we don't need pass through so we don't

00:15:28,440 --> 00:15:33,300
need vfi oh we just have to remove some

00:15:30,660 --> 00:15:35,250
of the crates enable the Mme Oh

00:15:33,300 --> 00:15:37,709
transport for the verts are crates and

00:15:35,250 --> 00:15:42,600
we have a different vmn so that's the

00:15:37,709 --> 00:15:44,640
idea and one example of how raspberry

00:15:42,600 --> 00:15:47,010
mem is used is a cloud provider which is

00:15:44,640 --> 00:15:48,089
an Intel project which is why I'm going

00:15:47,010 --> 00:15:50,339
to talk about this because I work on

00:15:48,089 --> 00:15:55,769
this project and you would you could

00:15:50,339 --> 00:15:58,829
call it the cloud vmm if you prefer so

00:15:55,769 --> 00:16:02,820
it's it's kayvyun base we only aim at

00:15:58,829 --> 00:16:04,410
supporting your KBM and it's only its

00:16:02,820 --> 00:16:06,380
aiming at supported cloud workloads and

00:16:04,410 --> 00:16:08,670
by cloud workers we meet workloads that

00:16:06,380 --> 00:16:12,240
potentially can run in a private or

00:16:08,670 --> 00:16:14,700
public cloud provider infrastructure we

00:16:12,240 --> 00:16:18,839
only support x86 for now but we won't

00:16:14,700 --> 00:16:22,140
support arm in the future and since we

00:16:18,839 --> 00:16:24,450
want to support cloud workloads we need

00:16:22,140 --> 00:16:27,630
we need it to be PCI base we want device

00:16:24,450 --> 00:16:29,790
pass-through we want migration HTP IV

00:16:27,630 --> 00:16:31,640
host user because we also going to

00:16:29,790 --> 00:16:36,570
follow the we are following the split

00:16:31,640 --> 00:16:39,170
process model for for IO etc so which

00:16:36,570 --> 00:16:41,880
crates are using and cloud provider

00:16:39,170 --> 00:16:44,490
we're using all the functional reels

00:16:41,880 --> 00:16:48,209
minimum crates so all the ones that we

00:16:44,490 --> 00:16:51,060
think are complete and those one entry

00:16:48,209 --> 00:16:53,010
highlighted are the auto bindings the

00:16:51,060 --> 00:16:56,070
kernel binding is the KVM vertigo and

00:16:53,010 --> 00:16:57,950
PFR by news we use the Cape the KVM

00:16:56,070 --> 00:17:01,500
wrapper or the kayvyun crate which is a

00:16:57,950 --> 00:17:03,570
wrapper on top the KB mio tools we used

00:17:01,500 --> 00:17:07,740
the Rodney memory model the kernel order

00:17:03,570 --> 00:17:10,949
and the the rugby mm toolbox which is

00:17:07,740 --> 00:17:13,829
the EMC to do some of the crates in

00:17:10,949 --> 00:17:15,600
rugby mmm are incomplete as I said this

00:17:13,829 --> 00:17:17,579
is true for the verts are great for the

00:17:15,600 --> 00:17:19,860
the device model so we don't have yet a

00:17:17,579 --> 00:17:22,980
device model the VF i okra is also

00:17:19,860 --> 00:17:26,220
incomplete so we fork them into you into

00:17:22,980 --> 00:17:27,870
the cloud provider repo directly and we

00:17:26,220 --> 00:17:30,380
complete it there and try it we're

00:17:27,870 --> 00:17:34,559
trying to push our code back into the

00:17:30,380 --> 00:17:36,090
raspbian crates and finally some crates

00:17:34,559 --> 00:17:38,640
are missing from rugby mmm

00:17:36,090 --> 00:17:40,920
we don't have a PCI creating rugby mm so

00:17:38,640 --> 00:17:42,690
we have one in clara provider and we're

00:17:40,920 --> 00:17:45,300
also planning to contribute that back to

00:17:42,690 --> 00:17:47,480
you to browse women and hookah the

00:17:45,300 --> 00:17:50,190
migration crate which is a big deal and

00:17:47,480 --> 00:17:54,750
a lot of the architecture specific

00:17:50,190 --> 00:17:57,060
settings so looks looks very nice

00:17:54,750 --> 00:18:00,150
take those crates put them together have

00:17:57,060 --> 00:18:02,520
this very thin glue code and very good

00:18:00,150 --> 00:18:04,680
that's the expectation the reality right

00:18:02,520 --> 00:18:06,330
now is a little different the bras vmm

00:18:04,680 --> 00:18:07,530
is a young project and we're still as i

00:18:06,330 --> 00:18:10,290
said we're still missing some some

00:18:07,530 --> 00:18:12,360
crates so if you look at cloud advisor

00:18:10,290 --> 00:18:14,330
as a project the glue code and talking

00:18:12,360 --> 00:18:19,050
about which is supposed to only be glue

00:18:14,330 --> 00:18:21,180
it's still 40,000 lines of code so we

00:18:19,050 --> 00:18:23,490
were hoping that this would be less and

00:18:21,180 --> 00:18:25,620
the reason why this is 40,000 lines of

00:18:23,490 --> 00:18:27,690
code is because some of the crates are

00:18:25,620 --> 00:18:29,220
missing or incomplete from rusty mm and

00:18:27,690 --> 00:18:32,300
we have to implement that in clara

00:18:29,220 --> 00:18:35,370
provider so looking at where how those

00:18:32,300 --> 00:18:37,350
forty thousand lines of code are a

00:18:35,370 --> 00:18:39,690
dispatch and shared across component is

00:18:37,350 --> 00:18:42,450
a good idea of where we should put our

00:18:39,690 --> 00:18:43,890
efforts in rugby man so if you look at

00:18:42,450 --> 00:18:45,780
those forty thousand lines of code and

00:18:43,890 --> 00:18:49,560
where they are in clarifies ER and you

00:18:45,780 --> 00:18:53,520
can see that more than a third of it is

00:18:49,560 --> 00:18:55,430
actually virtio and vhosts code so if we

00:18:53,520 --> 00:18:57,060
would be able to use a rugby mm

00:18:55,430 --> 00:19:00,540
implementation for virtio

00:18:57,060 --> 00:19:01,260
we would remove a third of the entire

00:19:00,540 --> 00:19:04,260
cloud advisor

00:19:01,260 --> 00:19:06,840
code base same for kernel bindings which

00:19:04,260 --> 00:19:08,700
is even that's even easier so networking

00:19:06,840 --> 00:19:10,440
bindings architecture specific bindings

00:19:08,700 --> 00:19:13,560
this is easier than implementing a

00:19:10,440 --> 00:19:15,810
vertigo crate so and this is this is

00:19:13,560 --> 00:19:19,680
roughly a quarter of the entire code

00:19:15,810 --> 00:19:21,810
base so that gives us an idea of where

00:19:19,680 --> 00:19:23,780
we should put our resources on Brasby mm

00:19:21,810 --> 00:19:25,530
which crate we should work on first and

00:19:23,780 --> 00:19:27,840
as a matter of fact

00:19:25,530 --> 00:19:30,570
couple weeks ago we had a perverse women

00:19:27,840 --> 00:19:33,150
meetup in Bucharest candy I was hit by a

00:19:30,570 --> 00:19:36,660
double yes we had a lot of interesting

00:19:33,150 --> 00:19:38,730
discussion and we decided to put our

00:19:36,660 --> 00:19:41,940
efforts in the short term on the device

00:19:38,730 --> 00:19:46,140
model and on the birds are great as well

00:19:41,940 --> 00:19:47,970
so if we ask Laura provider could use

00:19:46,140 --> 00:19:48,290
the device model from rugby mm and the

00:19:47,970 --> 00:19:50,150
verts

00:19:48,290 --> 00:19:54,320
create from Rose remember basically

00:19:50,150 --> 00:19:58,400
divide our glue code code base code size

00:19:54,320 --> 00:20:01,040
by by 2 and we're done

00:19:58,400 --> 00:20:04,790
this is the github organization for us

00:20:01,040 --> 00:20:08,480
be ma'am she wanna join contributes help

00:20:04,790 --> 00:20:18,430
or use it please come and help thank you

00:20:08,480 --> 00:20:18,430
I think we have time for questions

00:20:29,460 --> 00:20:35,830
thank you

00:20:32,430 --> 00:20:37,630
so besides writing a complete vmm this

00:20:35,830 --> 00:20:40,450
way to also envision the use case of

00:20:37,630 --> 00:20:46,720
having just the device back-end as a

00:20:40,450 --> 00:20:48,460
raspy mmm use case yes actually we yes

00:20:46,720 --> 00:20:51,040
definitely and this is for example in

00:20:48,460 --> 00:20:54,940
Klara professor we have V host user

00:20:51,040 --> 00:20:58,840
device back in and we're also aiming at

00:20:54,940 --> 00:21:01,360
when I was showing the sharp-eyed of

00:20:58,840 --> 00:21:03,640
missing code it was virtually on V host

00:21:01,360 --> 00:21:07,090
and we want to contribute that back to

00:21:03,640 --> 00:21:08,380
to browse vmm as being able to use the

00:21:07,090 --> 00:21:10,630
vertical crate and having an

00:21:08,380 --> 00:21:14,080
implementation for like a tab based

00:21:10,630 --> 00:21:16,240
implementation for a P host user back in

00:21:14,080 --> 00:21:18,700
yes so yes there are different use cases

00:21:16,240 --> 00:21:21,760
V mm is the main one but you could

00:21:18,700 --> 00:21:24,490
implement device back in and maybe do a

00:21:21,760 --> 00:21:27,970
few things you could also envision to

00:21:24,490 --> 00:21:29,650
use like a memory model or virtual crate

00:21:27,970 --> 00:21:32,020
into something like you I mean if you're

00:21:29,650 --> 00:21:35,670
brave willing to do that

00:21:32,020 --> 00:21:35,670
I think Paulo wants to do that

00:21:39,730 --> 00:21:49,440
yeah the FI bindings for for rust are

00:21:43,840 --> 00:21:49,440
pretty good that's the easy part is

00:21:50,190 --> 00:21:54,630
right okay so thank you thank you thank

00:21:54,070 --> 00:21:58,550
you

00:21:54,630 --> 00:22:05,400
[Applause]

00:21:58,550 --> 00:22:05,400

YouTube URL: https://www.youtube.com/watch?v=cKMvcGTK2c0


