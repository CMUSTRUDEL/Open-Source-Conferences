Title: [2019] Moving s390 Kvm-unit-tests up the Stack by Janosch Frank
Publication date: 2019-11-07
Playlist: KVM Forum 2019
Description: 
	Tests from the KVM unit tests framework have been traditionally run on only one hypervisor...KVM. But having a clean and tiny test framework has been so invaluable, we started porting it to all s390 hypervisors that are out there.

This allowed new users like hardware and firmware to use it and with the advent of Protected Virtualization became an important part of software and hardware verification.

This talk concentrates on how we used KVM unit tests in the past, how we're using it right now and what lies in the future for s390 (and maybe also other platforms).

Cross and stacked hypervisor testing to the rescue!

---

Janosch Frank
IBM R&D Germany
Software Engineer

Janosch Frank is a software engineer at IBM Germany and a s390 co-maintainer for KVM. He works on guest memory management and KVM unit testing.

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,440 --> 00:00:16,980
all right let's move on Mike and wittily

00:00:13,950 --> 00:00:19,289
have told you to go deeper when testing

00:00:16,980 --> 00:00:21,840
I'm actually telling you to look up in

00:00:19,289 --> 00:00:27,599
sideways there are way more environments

00:00:21,840 --> 00:00:28,349
to test on then only KVM itself for KVM

00:00:27,599 --> 00:00:31,500
unit tests

00:00:28,349 --> 00:00:36,030
I'm Jana Frank the commentator for kvms

00:00:31,500 --> 00:00:39,450
390 and at the beginning of the year

00:00:36,030 --> 00:00:41,219
I've been pulled into femur testing and

00:00:39,450 --> 00:00:44,760
femur development and I needed a

00:00:41,219 --> 00:00:47,010
testable test vehicle to test on the

00:00:44,760 --> 00:00:49,739
machine and under different hypervisors

00:00:47,010 --> 00:00:56,579
and naturally for me I chose to carry

00:00:49,739 --> 00:00:59,879
immunities so we'll have a look at how

00:00:56,579 --> 00:01:02,730
Kevin unit tests are used at IBM or used

00:00:59,879 --> 00:01:05,909
at all I guess why we want to move to

00:01:02,730 --> 00:01:08,939
other hypervisors and run on the machine

00:01:05,909 --> 00:01:12,450
what we needed to do to make them run

00:01:08,939 --> 00:01:13,799
and what we found in the process and

00:01:12,450 --> 00:01:21,110
then we'll have a short look into the

00:01:13,799 --> 00:01:23,430
future it seems like the audience

00:01:21,110 --> 00:01:25,890
doesn't like cave immunity tests that

00:01:23,430 --> 00:01:28,860
much I really love them they are small

00:01:25,890 --> 00:01:30,900
they are reliable they're very fast and

00:01:28,860 --> 00:01:33,060
they are dead simple to write so when a

00:01:30,900 --> 00:01:35,369
new developer comes to me and asks well

00:01:33,060 --> 00:01:36,930
I need a testing framework I tell them

00:01:35,369 --> 00:01:40,259
if it doesn't need a lot of

00:01:36,930 --> 00:01:42,210
configuration use KVM unit tests you

00:01:40,259 --> 00:01:44,549
will just need half an hour to write a

00:01:42,210 --> 00:01:50,369
test case and you'll be set for life

00:01:44,549 --> 00:01:52,500
hopefully Kevin unit tests on s/390 are

00:01:50,369 --> 00:01:54,810
used to do architecture compliance

00:01:52,500 --> 00:01:57,659
testing testing of new facilities that

00:01:54,810 --> 00:02:01,950
come with new machines the question

00:01:57,659 --> 00:02:04,380
testing sometimes I give out custom unit

00:02:01,950 --> 00:02:07,520
tests for error reproduction so our

00:02:04,380 --> 00:02:12,870
testers can use them in the field and

00:02:07,520 --> 00:02:13,780
also for backboard verification KVM was

00:02:12,870 --> 00:02:17,890
mostly the

00:02:13,780 --> 00:02:18,640
first before I started development on my

00:02:17,890 --> 00:02:22,810
changes

00:02:18,640 --> 00:02:25,030
I'm Kevin unit tests were mostly run in

00:02:22,810 --> 00:02:28,420
a mineral environment by the developers

00:02:25,030 --> 00:02:33,550
when they wrote their new code mostly on

00:02:28,420 --> 00:02:37,920
hyper virtualization about 1% with

00:02:33,550 --> 00:02:41,380
nested virtualization then we also

00:02:37,920 --> 00:02:43,989
integrated CI environment into our build

00:02:41,380 --> 00:02:48,010
environment and we now have automated

00:02:43,989 --> 00:02:51,340
full runs of the KVM unit tests where we

00:02:48,010 --> 00:02:54,040
run the tests on multiple hardware and

00:02:51,340 --> 00:02:56,709
fumer levels and with a nested

00:02:54,040 --> 00:03:00,100
virtualization in between there there's

00:02:56,709 --> 00:03:02,890
also a second hypervisor c vm which acts

00:03:00,100 --> 00:03:06,730
as a host to KBM so we are also testing

00:03:02,890 --> 00:03:09,700
parts of the C VM hypervisor all of that

00:03:06,730 --> 00:03:18,010
is only done on s/390 hardware so no TCG

00:03:09,700 --> 00:03:20,799
tests so why did I want to run on more

00:03:18,010 --> 00:03:23,470
environments that were that we supported

00:03:20,799 --> 00:03:26,920
at the beginning of the year well when I

00:03:23,470 --> 00:03:29,110
came into framer development I saw that

00:03:26,920 --> 00:03:33,820
we had a lot of testing comments like

00:03:29,110 --> 00:03:36,790
really large amounts of them most of

00:03:33,820 --> 00:03:39,489
them don't run on all hypervisors and we

00:03:36,790 --> 00:03:44,829
as KBM try to make some of them run on k

00:03:39,489 --> 00:03:47,579
vm because they provide immense testing

00:03:44,829 --> 00:03:51,010
features which were currently not using

00:03:47,579 --> 00:03:54,519
we have a great architecture compliance

00:03:51,010 --> 00:03:57,370
assurance kernel a fussing kernel which

00:03:54,519 --> 00:04:00,579
is really great to find some some errors

00:03:57,370 --> 00:04:03,130
in stressing situations handwritten loop

00:04:00,579 --> 00:04:06,850
which are loops which are mostly used by

00:04:03,130 --> 00:04:11,500
the FEMA to develop to check specific

00:04:06,850 --> 00:04:14,799
instructions and so on and I think at

00:04:11,500 --> 00:04:19,390
least five frameworks similar to k vm

00:04:14,799 --> 00:04:21,130
unit tests and most of the time one

00:04:19,390 --> 00:04:24,070
person is responsible for the whole

00:04:21,130 --> 00:04:26,139
project and that's that's really bummer

00:04:24,070 --> 00:04:27,939
because you need to know that person to

00:04:26,139 --> 00:04:31,509
get the coat and to get the kernel and

00:04:27,939 --> 00:04:33,520
then be able to run it you're left out

00:04:31,509 --> 00:04:37,020
if there are new versions of that kernel

00:04:33,520 --> 00:04:40,300
it's annoying

00:04:37,020 --> 00:04:44,710
we also have a lot of environments to

00:04:40,300 --> 00:04:47,110
run on we have three hypervisors two

00:04:44,710 --> 00:04:51,729
levels of hardware virtualization we

00:04:47,110 --> 00:04:57,879
have emulation on TCG and on CP DT which

00:04:51,729 --> 00:05:00,729
is also x86 emulation for s/390 we have

00:04:57,879 --> 00:05:04,719
lots of famous emulation and we have

00:05:00,729 --> 00:05:08,349
various femur levels on various hardware

00:05:04,719 --> 00:05:12,340
levels all of them affect how an

00:05:08,349 --> 00:05:15,539
instruction is actually emulated most of

00:05:12,340 --> 00:05:18,490
the time it doesn't change the output of

00:05:15,539 --> 00:05:21,909
instruction or it does in an

00:05:18,490 --> 00:05:23,919
architecture way but sometimes it

00:05:21,909 --> 00:05:27,520
changes the output of an instruction

00:05:23,919 --> 00:05:29,560
where we don't want any change for

00:05:27,520 --> 00:05:31,509
example CBM handles page table

00:05:29,560 --> 00:05:36,659
management for guests way different than

00:05:31,509 --> 00:05:39,219
KVM and so the nesting is bit different

00:05:36,659 --> 00:05:45,250
from our nesting if you have a look at

00:05:39,219 --> 00:05:48,580
it so I set out at the start of the year

00:05:45,250 --> 00:05:50,889
and my goal was to make the kV muna test

00:05:48,580 --> 00:05:53,039
run on as much environments as possible

00:05:50,889 --> 00:05:56,409
as much hypervisors as possible

00:05:53,039 --> 00:06:00,099
hopefully we'll see some testing

00:05:56,409 --> 00:06:04,899
differences between the tests on

00:06:00,099 --> 00:06:08,139
different hypervisors maybe some of them

00:06:04,899 --> 00:06:09,639
our implementation errors in any case we

00:06:08,139 --> 00:06:13,960
learn something about the architecture

00:06:09,639 --> 00:06:15,969
and the hypothesis I also wanted to push

00:06:13,960 --> 00:06:18,789
gave immunity's adoption into the other

00:06:15,969 --> 00:06:21,099
teams so they have something that's open

00:06:18,789 --> 00:06:23,469
source where they can just grab the

00:06:21,099 --> 00:06:28,089
source and run it for their testing

00:06:23,469 --> 00:06:30,399
needs the more people use KVM unit tests

00:06:28,089 --> 00:06:35,110
and hopefully then right back reports

00:06:30,399 --> 00:06:37,330
the more coverage we have so the hardest

00:06:35,110 --> 00:06:40,000
part at the start was getting it to boot

00:06:37,330 --> 00:06:43,450
at all because KVM unit tests

00:06:40,000 --> 00:06:46,930
are booted as by out the kernel direct

00:06:43,450 --> 00:06:48,580
kernel boot with qu and well that

00:06:46,930 --> 00:06:51,990
doesn't work on a machine level the

00:06:48,580 --> 00:06:54,760
machine doesn't understand elf binary is

00:06:51,990 --> 00:06:58,180
so it's very KVM specific how they are

00:06:54,760 --> 00:07:00,760
compiled other hypervisors expect a

00:06:58,180 --> 00:07:04,410
binary to be loaded into memory and then

00:07:00,760 --> 00:07:07,270
in memory at specific offsets there's an

00:07:04,410 --> 00:07:11,110
entry address which is used as the first

00:07:07,270 --> 00:07:14,710
address the booting CPU receives and

00:07:11,110 --> 00:07:19,150
then it starts off from there also we

00:07:14,710 --> 00:07:22,780
have no moving of elfs actions and we

00:07:19,150 --> 00:07:26,950
have no clearing so we needed binary

00:07:22,780 --> 00:07:29,919
test case generation we made the

00:07:26,950 --> 00:07:32,080
assumption that will always run under 64

00:07:29,919 --> 00:07:35,230
bits extended C architecture which is

00:07:32,080 --> 00:07:37,630
not always the case depending on the

00:07:35,230 --> 00:07:39,669
machine you're running on but we also

00:07:37,630 --> 00:07:43,480
want to be able to run the cave in unit

00:07:39,669 --> 00:07:47,260
tests on old machines because sometimes

00:07:43,480 --> 00:07:49,479
for instructions that give information

00:07:47,260 --> 00:07:52,780
about the machine they provide less data

00:07:49,479 --> 00:07:58,479
or they provide strange data which might

00:07:52,780 --> 00:08:01,840
be interesting to test well then the

00:07:58,479 --> 00:08:04,979
tests booted up but unfortunately I was

00:08:01,840 --> 00:08:08,620
created by basically a white screen

00:08:04,979 --> 00:08:11,830
because the console absolutely didn't

00:08:08,620 --> 00:08:15,870
work in the cave immunity test we made

00:08:11,830 --> 00:08:18,570
the assumption that when we set out and

00:08:15,870 --> 00:08:21,669
executed the instruction that's

00:08:18,570 --> 00:08:24,280
responsible for the console we would get

00:08:21,669 --> 00:08:27,040
the interrupt together with the end of

00:08:24,280 --> 00:08:30,880
the emulation of the instruction so we

00:08:27,040 --> 00:08:33,669
never waited for the interrupt that's

00:08:30,880 --> 00:08:36,280
okay for qmu because it's implemented

00:08:33,669 --> 00:08:39,610
that way but on L par on the machine and

00:08:36,280 --> 00:08:43,000
on c vm that's just not the case and the

00:08:39,610 --> 00:08:44,650
test case would just run on at some

00:08:43,000 --> 00:08:46,570
point in the future would receive the

00:08:44,650 --> 00:08:49,860
data and the interrupt would just ignore

00:08:46,570 --> 00:08:52,600
the interrupt and work on zeros that

00:08:49,860 --> 00:08:57,589
didn't work out great

00:08:52,600 --> 00:09:06,860
also we expected that the console is s

00:08:57,589 --> 00:09:09,140
key yeah the mainframe mostly uses EB C

00:09:06,860 --> 00:09:14,180
dick so we needed to create a second

00:09:09,140 --> 00:09:16,339
console stream in addition to the S key

00:09:14,180 --> 00:09:23,149
console so we are now outputting s key

00:09:16,339 --> 00:09:41,860
and hasidic in parallel to actually get

00:09:23,149 --> 00:09:46,040
any output at all yeah it's alright so

00:09:41,860 --> 00:09:48,320
now with being able to to run the tests

00:09:46,040 --> 00:09:52,010
on multiple environments multiple voices

00:09:48,320 --> 00:09:54,170
I set out and the easiest targets to

00:09:52,010 --> 00:09:56,839
have a look at what's the console

00:09:54,170 --> 00:10:00,380
because it's just a massive interface I

00:09:56,839 --> 00:10:06,250
think it's more than 100 or 200 pages of

00:10:00,380 --> 00:10:08,870
documentation it's immensely complex and

00:10:06,250 --> 00:10:13,060
the initial implementation I think was

00:10:08,870 --> 00:10:16,400
just made to make Linux work as a guest

00:10:13,060 --> 00:10:17,150
so I wrote a simple test case for the

00:10:16,400 --> 00:10:20,180
console

00:10:17,150 --> 00:10:22,600
I started it under the L / hypervisor

00:10:20,180 --> 00:10:27,050
and then I started it on the k vm and

00:10:22,600 --> 00:10:31,240
some differences showed up unfortunately

00:10:27,050 --> 00:10:34,339
I didn't have enough time at that point

00:10:31,240 --> 00:10:37,820
to go on so I asked a colleague of mine

00:10:34,339 --> 00:10:40,040
Claudio to go on with testing and

00:10:37,820 --> 00:10:43,970
together we fixed quite a few problems

00:10:40,040 --> 00:10:49,300
where mostly error cases the wrong one

00:10:43,970 --> 00:10:52,930
priority one thing - wrong

00:10:49,300 --> 00:10:52,930
error reports

00:10:53,130 --> 00:11:01,320
so that was really nice to have then as

00:10:57,960 --> 00:11:05,810
I said I started out because I wanted to

00:11:01,320 --> 00:11:09,570
do some help with FEMA development and

00:11:05,810 --> 00:11:14,490
the FEMA developers needed some help

00:11:09,570 --> 00:11:17,400
with pre-release fever and hardware so I

00:11:14,490 --> 00:11:20,280
took the cave-in unit tests and random

00:11:17,400 --> 00:11:22,770
under KVM on the El par and in

00:11:20,280 --> 00:11:26,190
simulation and that was really great

00:11:22,770 --> 00:11:28,230
because under ALPA I found errors in the

00:11:26,190 --> 00:11:30,540
implementation and then I could just

00:11:28,230 --> 00:11:34,380
provide the test case which is really

00:11:30,540 --> 00:11:36,180
small just 100 250 K to the FEMA

00:11:34,380 --> 00:11:39,570
developers and together with them I

00:11:36,180 --> 00:11:41,850
could step through the femur code which

00:11:39,570 --> 00:11:45,990
was run when the instruction was

00:11:41,850 --> 00:11:48,810
emulated but when the instruction was

00:11:45,990 --> 00:11:54,180
being processed in the processor we

00:11:48,810 --> 00:11:57,330
could look at the registers inside of

00:11:54,180 --> 00:12:00,540
the CPU the internal registers the state

00:11:57,330 --> 00:12:06,480
and internal instructions which are used

00:12:00,540 --> 00:12:08,580
to make up one whole instruction also in

00:12:06,480 --> 00:12:12,660
simulation we were able to actually

00:12:08,580 --> 00:12:14,610
update CPU VMware much faster than on

00:12:12,660 --> 00:12:17,040
the machine it only takes a few seconds

00:12:14,610 --> 00:12:20,060
on the machine it takes about two to

00:12:17,040 --> 00:12:24,270
five minutes that depends

00:12:20,060 --> 00:12:26,880
so we improved turnaround times and the

00:12:24,270 --> 00:12:28,910
femur developers were very happy to have

00:12:26,880 --> 00:12:28,910
it

00:12:30,120 --> 00:12:36,630
I made some smaller changes some small

00:12:34,710 --> 00:12:39,330
effects for the stew hypervisor

00:12:36,630 --> 00:12:44,130
information instruction which provides

00:12:39,330 --> 00:12:49,260
information about the environment or SS

00:12:44,130 --> 00:12:51,540
running on the test run in a new

00:12:49,260 --> 00:12:54,810
environment which was previously

00:12:51,540 --> 00:12:57,930
untested it was a very old machine where

00:12:54,810 --> 00:13:02,820
CBM was the first hypervisor and KVM was

00:12:57,930 --> 00:13:05,520
then the nested higher was nested and in

00:13:02,820 --> 00:13:09,540
there the input for that instruction was

00:13:05,520 --> 00:13:12,840
zero but KVM produced zero output and

00:13:09,540 --> 00:13:18,510
then also said well the field is valid

00:13:12,840 --> 00:13:22,110
but serous is not a valid data output

00:13:18,510 --> 00:13:27,480
for that field at that point so I wrote

00:13:22,110 --> 00:13:28,020
at a KVM fix well I also wrote just a

00:13:27,480 --> 00:13:29,970
hypervisor

00:13:28,020 --> 00:13:31,310
instruction emulation so that was

00:13:29,970 --> 00:13:36,120
actually my fault

00:13:31,310 --> 00:13:40,620
then I ran the storage key test under

00:13:36,120 --> 00:13:42,900
CBM and under kbm and I saw some fails

00:13:40,620 --> 00:13:45,420
on the CBM and that's because I made

00:13:42,900 --> 00:13:47,550
some wrong assumptions when I wrote the

00:13:45,420 --> 00:13:51,690
test case so I needed to test case I

00:13:47,550 --> 00:13:55,670
needed to fix the test case I also fixed

00:13:51,690 --> 00:14:04,380
that and now we have much more coverage

00:13:55,670 --> 00:14:05,130
over more environments looking into the

00:14:04,380 --> 00:14:08,010
future

00:14:05,130 --> 00:14:10,530
I have to say covering more environments

00:14:08,010 --> 00:14:12,980
is great but as we had the discussions

00:14:10,530 --> 00:14:17,160
before we need to really automate

00:14:12,980 --> 00:14:20,700
testing under these environments I want

00:14:17,160 --> 00:14:22,860
to have two CI inclusion of alpar c vm

00:14:20,700 --> 00:14:28,260
and nested k vm which is currently not

00:14:22,860 --> 00:14:31,350
the case I want to have CI intuition for

00:14:28,260 --> 00:14:33,000
TCG so I know that people who use TCG

00:14:31,350 --> 00:14:37,800
are not affected by changes to the

00:14:33,000 --> 00:14:41,070
kayvyun unit tests or changes to qu I

00:14:37,800 --> 00:14:44,850
want to push those tests those tests to

00:14:41,070 --> 00:14:48,330
early fever and hardware development so

00:14:44,850 --> 00:14:53,790
I get back reports way earlier than we

00:14:48,330 --> 00:14:57,360
normally use to get them on ok problem

00:14:53,790 --> 00:14:59,340
is integrating these tests is way harder

00:14:57,360 --> 00:15:02,250
than on KVM because we don't have a lot

00:14:59,340 --> 00:15:05,880
of tooling for c vm and for l power or

00:15:02,250 --> 00:15:09,600
for the simulation environments we can

00:15:05,880 --> 00:15:14,070
put those tests under alpha via disk or

00:15:09,600 --> 00:15:15,780
via SFTP which is real pain because we

00:15:14,070 --> 00:15:18,310
need to compile them we need to move

00:15:15,780 --> 00:15:21,520
them to SFTP and then

00:15:18,310 --> 00:15:23,260
put them one by one extracts the console

00:15:21,520 --> 00:15:28,510
output via some really strange

00:15:23,260 --> 00:15:30,880
interfaces and past them CVM could

00:15:28,510 --> 00:15:36,210
actually use a virtual punch card reader

00:15:30,880 --> 00:15:36,210
to execute those tests I'm not joking

00:15:36,390 --> 00:15:46,720
it might actually be a valid use case

00:15:40,600 --> 00:15:49,930
for the punch card reader looking at the

00:15:46,720 --> 00:15:55,210
future of KVM unit tests for s/390 i

00:15:49,930 --> 00:15:58,060
want to add some nested test cases we

00:15:55,210 --> 00:16:01,810
have huge blind blind spot when doing

00:15:58,060 --> 00:16:04,800
Ione problem with iOS it usually needs a

00:16:01,810 --> 00:16:08,560
lot of configuration it's not always

00:16:04,800 --> 00:16:11,680
enough to just append some command-line

00:16:08,560 --> 00:16:14,860
arguments to qmu and just be done with

00:16:11,680 --> 00:16:20,580
it like for SMP when increasing the

00:16:14,860 --> 00:16:25,510
number of CPUs and I wanna do way more

00:16:20,580 --> 00:16:27,760
work under SMP more stressing of CPU

00:16:25,510 --> 00:16:32,190
signaling and building because we had

00:16:27,760 --> 00:16:32,190
problems in the past at these points

00:16:32,640 --> 00:16:40,300
another thing that was also mentioned

00:16:35,860 --> 00:16:43,510
before is if we add new features we

00:16:40,300 --> 00:16:45,700
might add more complexity and that will

00:16:43,510 --> 00:16:49,540
make it harder for new developers to

00:16:45,700 --> 00:16:53,710
come to the KVM unit tests and use them

00:16:49,540 --> 00:16:55,480
as an easy to use test vehicle so really

00:16:53,710 --> 00:17:00,160
we really need to make sure that our

00:16:55,480 --> 00:17:06,550
changes don't affect new users and whole

00:17:00,160 --> 00:17:10,810
library gets too complicated and I I set

00:17:06,550 --> 00:17:14,020
out this presentation to actually ask

00:17:10,810 --> 00:17:18,760
you and maybe also network with some

00:17:14,020 --> 00:17:24,360
with some of you do you actually test on

00:17:18,760 --> 00:17:24,360
multiple platforms multiple hypervisors

00:17:25,380 --> 00:17:30,040
what what kind of differences did you

00:17:28,030 --> 00:17:32,020
find when were testing between these

00:17:30,040 --> 00:17:35,120
hypervisors and

00:17:32,020 --> 00:17:38,450
maybe rather any expectations when

00:17:35,120 --> 00:17:41,780
writing q mu and KVM code which actually

00:17:38,450 --> 00:17:46,400
burn completely right but you made them

00:17:41,780 --> 00:17:50,240
and now something something is wrong in

00:17:46,400 --> 00:17:54,470
the implementation and with the words of

00:17:50,240 --> 00:18:09,880
Linux I'm gonna let you out to lunch go

00:17:54,470 --> 00:18:09,880
out and go out and test questions

00:18:17,770 --> 00:18:26,040
so you mentioned that there were

00:18:20,610 --> 00:18:28,929
approximately five in terminal at least

00:18:26,040 --> 00:18:31,809
test Suites that are similar to KVM unit

00:18:28,929 --> 00:18:34,720
tests and that you want to convince them

00:18:31,809 --> 00:18:37,809
to use something more chrome like heavy

00:18:34,720 --> 00:18:43,090
immunities did you succeed is anybody is

00:18:37,809 --> 00:18:45,250
switching to KBM unit tests no no I had

00:18:43,090 --> 00:18:48,250
a discussion at the beginning of the

00:18:45,250 --> 00:18:51,010
year with Martin tree deskey and I try

00:18:48,250 --> 00:18:55,360
to convince him and he just told me well

00:18:51,010 --> 00:18:58,360
yeah like five years ago I wrote that

00:18:55,360 --> 00:19:02,950
test library and it basically looks

00:18:58,360 --> 00:19:05,170
exactly like heavy immunities I've yet

00:19:02,950 --> 00:19:07,900
to present about the cave immune attest

00:19:05,170 --> 00:19:12,450
within our internal developer meeting

00:19:07,900 --> 00:19:15,450
and I hope to push adoption to the Linux

00:19:12,450 --> 00:19:15,450
developers

00:19:28,929 --> 00:19:37,779
how do these other unit test library

00:19:33,390 --> 00:19:41,549
mechanisms sort of the part of booking

00:19:37,779 --> 00:19:41,549
and getting the output from the bars

00:19:42,010 --> 00:19:45,119
[Music]

00:19:45,299 --> 00:19:54,669
well they were initially written for L

00:19:49,840 --> 00:19:58,779
power and CBM and the problem for us is

00:19:54,669 --> 00:20:06,760
that we don't really have a full pass

00:19:58,779 --> 00:20:09,840
true of a lot of devices it's basically

00:20:06,760 --> 00:20:09,840
the other way around for us

00:20:14,479 --> 00:20:19,139
it has what that question is basically

00:20:16,889 --> 00:20:21,179
or follow up on this one just the other

00:20:19,139 --> 00:20:23,989
way around because you mentioned IO

00:20:21,179 --> 00:20:27,330
testing the further as far as I am aware

00:20:23,989 --> 00:20:31,109
the only implementation of verda on sv

00:20:27,330 --> 00:20:33,960
90 is Q mu or have any of the other

00:20:31,109 --> 00:20:38,539
hypervisors like CM now gained some kind

00:20:33,960 --> 00:20:38,539
of implementation I don't

00:20:48,970 --> 00:20:53,070
it looks like no other questions thank

00:20:50,769 --> 00:20:53,070
you

00:20:56,690 --> 00:21:03,989

YouTube URL: https://www.youtube.com/watch?v=f3TxxX7KNZ8


