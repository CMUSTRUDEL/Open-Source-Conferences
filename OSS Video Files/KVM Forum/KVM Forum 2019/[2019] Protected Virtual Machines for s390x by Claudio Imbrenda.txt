Title: [2019] Protected Virtual Machines for s390x by Claudio Imbrenda
Publication date: 2019-11-09
Playlist: KVM Forum 2019
Description: 
	Traditionally, system administrators have been able to access all data on a running system, including memory belonging to Virtual Machines (VMs). Bugs in the hypervisor have also allowed cross-VM attacks.

A new upcoming feature for the s390x architecture will prevent those security issues, allowing VM guests to be protected from a broken or malicious hypervisor, without using memory encryption, while at the same time requiring a minimum amount of changes in the guest.

This presentation will introduce the technology, the architectural extensions, the unique features, and how KVM and Qemu have been adapted to exploit it. The presentation will also cover the typical lifecycle of host and guest, including interactions with the firmware.

---

Claudio Imbrenda
IBM
Developer

KVM and Qemu developer on s390x for IBM.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,620 --> 00:00:14,190
hello my name is Klaus Jim Brenda I work

00:00:11,040 --> 00:00:16,139
for IBM and a Tokyo mo and KVM

00:00:14,190 --> 00:00:18,810
development and today I'm here to talk

00:00:16,139 --> 00:00:22,769
about our new architecture for protected

00:00:18,810 --> 00:00:27,180
with machines on s 290x or the mainframe

00:00:22,769 --> 00:00:31,260
architecture from IBM this is the

00:00:27,180 --> 00:00:33,899
overview to talk and let's start what is

00:00:31,260 --> 00:00:36,899
this all about this is about protectable

00:00:33,899 --> 00:00:39,149
transition that is to have virtual

00:00:36,899 --> 00:00:44,989
machines whose state cannot be observed

00:00:39,149 --> 00:00:49,500
or altered by the hypervisor so why well

00:00:44,989 --> 00:00:53,129
security if you don't trust your

00:00:49,500 --> 00:00:56,670
operators if you don't trust even your

00:00:53,129 --> 00:00:59,039
cloud operator or if you don't trust the

00:00:56,670 --> 00:01:01,949
hypervisor to not be buggy or if you

00:00:59,039 --> 00:01:04,710
don't care about any of that if you're

00:01:01,949 --> 00:01:07,830
if the law forces you to care then you

00:01:04,710 --> 00:01:11,010
might be interested in this so let's see

00:01:07,830 --> 00:01:16,009
how we do it this is the big picture of

00:01:11,010 --> 00:01:20,220
the whole product of virtualization so

00:01:16,009 --> 00:01:22,380
we have guests we have the hypervisor

00:01:20,220 --> 00:01:24,259
and we have a new entity which we call

00:01:22,380 --> 00:01:27,360
the ultra vires

00:01:24,259 --> 00:01:29,549
the guest is trusted olive oil for

00:01:27,360 --> 00:01:31,920
itself we assume that the guest will not

00:01:29,549 --> 00:01:34,430
shoot itself in the foot but the guest

00:01:31,920 --> 00:01:37,740
is free to shoot itself in the foot if

00:01:34,430 --> 00:01:40,500
they wish we do not assume that the

00:01:37,740 --> 00:01:44,700
guest is not malicious even protected

00:01:40,500 --> 00:01:47,040
guests the hypervisor is untrusted we do

00:01:44,700 --> 00:01:49,729
not assume anything about that and the

00:01:47,040 --> 00:01:54,990
ultra vires are is trusted system-wide

00:01:49,729 --> 00:01:57,299
these arrows here show access patterns

00:01:54,990 --> 00:01:59,040
the hypervisor can of course access the

00:01:57,299 --> 00:02:00,719
memory of normal guests normal guests

00:01:59,040 --> 00:02:02,820
normally cannot access the memory of the

00:02:00,719 --> 00:02:04,469
hypervisor but if the hypervisor is

00:02:02,820 --> 00:02:09,629
buggy or malicious that could be

00:02:04,469 --> 00:02:11,360
possible nobody can read or write into

00:02:09,629 --> 00:02:13,250
the protected guests

00:02:11,360 --> 00:02:14,960
except for the ultra vires and protected

00:02:13,250 --> 00:02:19,670
guests themselves here there's an

00:02:14,960 --> 00:02:22,510
asterisk I will explain later why this

00:02:19,670 --> 00:02:30,190
means that the ultra vires is the

00:02:22,510 --> 00:02:34,580
omnipotent entity above everything yes

00:02:30,190 --> 00:02:36,860
so ultra vires are is a trusted entity

00:02:34,580 --> 00:02:39,380
it's implemented in hardware and few

00:02:36,860 --> 00:02:41,390
more and it needs to take over some of

00:02:39,380 --> 00:02:44,210
the tasks traditionally performed by the

00:02:41,390 --> 00:02:45,770
hypervisor it does decryption and

00:02:44,210 --> 00:02:50,140
verification of the boot image of

00:02:45,770 --> 00:02:52,940
protected guests and protects the guests

00:02:50,140 --> 00:02:56,200
from the hypervisor and from the other

00:02:52,940 --> 00:02:58,520
guests secure and non-secure guests and

00:02:56,200 --> 00:03:05,300
proxies all the interactions between the

00:02:58,520 --> 00:03:08,000
guests and the hypervisor protection

00:03:05,300 --> 00:03:10,460
means that the guest member is not

00:03:08,000 --> 00:03:12,950
accessible by the hypervisor unless it

00:03:10,460 --> 00:03:15,950
is shared and this is the asterisk it

00:03:12,950 --> 00:03:17,980
was in the picture earlier protected

00:03:15,950 --> 00:03:20,330
guests can only access their own memory

00:03:17,980 --> 00:03:22,780
there is no way for but it gets to

00:03:20,330 --> 00:03:25,790
access any other memory except their own

00:03:22,780 --> 00:03:29,020
the guest decides which memory to share

00:03:25,790 --> 00:03:31,460
with the hypervisor for i/o because

00:03:29,020 --> 00:03:36,260
otherwise you have a very secure guest

00:03:31,460 --> 00:03:38,150
but not very useful one important thing

00:03:36,260 --> 00:03:39,350
is it's the guest that decides of course

00:03:38,150 --> 00:03:41,120
which memory to share with the

00:03:39,350 --> 00:03:43,310
hypervisor and that's the only memory

00:03:41,120 --> 00:03:45,020
that the hypervisor the only part of the

00:03:43,310 --> 00:03:48,740
of the protected guest that the

00:03:45,020 --> 00:03:51,860
hypervisor will be able to access the

00:03:48,740 --> 00:03:53,570
guest two hosts mappings are secured

00:03:51,860 --> 00:03:56,570
which means that the hypervisor cannot

00:03:53,570 --> 00:03:59,690
do any tricks of remapping guest pages

00:03:56,570 --> 00:04:03,650
to different addresses that I mean can

00:03:59,690 --> 00:04:05,180
try but it will not work and finally the

00:04:03,650 --> 00:04:06,740
old traveler checks and verifies the

00:04:05,180 --> 00:04:10,550
interaction within the hypervisor on the

00:04:06,740 --> 00:04:14,750
guest it's not just a blind proxy

00:04:10,550 --> 00:04:16,459
between the guests and the hypervisor it

00:04:14,750 --> 00:04:17,750
also performs some verification and

00:04:16,459 --> 00:04:20,150
checking to make sure that the

00:04:17,750 --> 00:04:22,970
hypervisor is not trying to make to do

00:04:20,150 --> 00:04:25,690
anything fishy or violate the

00:04:22,970 --> 00:04:25,690
specifications

00:04:26,230 --> 00:04:32,440
so what's left then in the hypervisor is

00:04:29,770 --> 00:04:34,550
IO and device model so the actual

00:04:32,440 --> 00:04:36,770
reading and writing from the disk for

00:04:34,550 --> 00:04:41,780
example or network traffic all

00:04:36,770 --> 00:04:44,210
scheduling this of course means that we

00:04:41,780 --> 00:04:46,070
are not doing anything against any

00:04:44,210 --> 00:04:48,830
potential that I know service attacks of

00:04:46,070 --> 00:04:51,800
course the hypervisor is free to not

00:04:48,830 --> 00:04:54,200
schedule the guests or the operator

00:04:51,800 --> 00:04:57,350
could just shut down the server or pull

00:04:54,200 --> 00:04:59,330
the plug so that's pointless memory

00:04:57,350 --> 00:05:03,860
management still of course performed by

00:04:59,330 --> 00:05:06,470
the hypervisor housekeeping for some

00:05:03,860 --> 00:05:10,700
instructions as I said before the ultra

00:05:06,470 --> 00:05:12,590
browser takes charge of some of the

00:05:10,700 --> 00:05:14,450
traditional some of the tasks that were

00:05:12,590 --> 00:05:16,400
traditionally done by the hypervisor

00:05:14,450 --> 00:05:18,590
some instructions for example will be

00:05:16,400 --> 00:05:22,700
handled by the ultra vires but in some

00:05:18,590 --> 00:05:25,280
cases some instructions need to be ok

00:05:22,700 --> 00:05:26,810
after they have been handled by the

00:05:25,280 --> 00:05:30,170
advisor the hypervisor needs to be

00:05:26,810 --> 00:05:32,240
notified that they have happened and

00:05:30,170 --> 00:05:35,390
many instructions are still completely

00:05:32,240 --> 00:05:41,390
handled by the hypervisor for example

00:05:35,390 --> 00:05:43,460
but not only all the i/o instructions so

00:05:41,390 --> 00:05:47,480
let's jump and see how this looks like

00:05:43,460 --> 00:05:49,100
in practice let's have a look at the

00:05:47,480 --> 00:05:52,460
life cycle what happens when we try to

00:05:49,100 --> 00:05:57,650
start the hypervisor and when we try to

00:05:52,460 --> 00:06:00,620
start a secure protected guest so the

00:05:57,650 --> 00:06:03,980
first thing is to check if the ultra

00:06:00,620 --> 00:06:06,950
browser is available and queried your

00:06:03,980 --> 00:06:09,050
service or to determine which

00:06:06,950 --> 00:06:11,290
characteristics which feature it has and

00:06:09,050 --> 00:06:17,090
which parameters which will be needed

00:06:11,290 --> 00:06:19,940
for example in step 3 the hypervisor is

00:06:17,090 --> 00:06:21,920
to opt in without this opt in it will

00:06:19,940 --> 00:06:25,730
not be able to start any secure guests

00:06:21,920 --> 00:06:27,200
and to do so it needs to donate some

00:06:25,730 --> 00:06:30,470
memory to the ultra vires the amount of

00:06:27,200 --> 00:06:32,360
memory is communicated exactly in step 2

00:06:30,470 --> 00:06:35,080
during this query with reviser

00:06:32,360 --> 00:06:35,080
among other things

00:06:35,240 --> 00:06:40,770
okay so the hypervisor has started and

00:06:37,860 --> 00:06:44,400
has opted in how do we start to secure

00:06:40,770 --> 00:06:48,479
guests now the secure guest puts in a

00:06:44,400 --> 00:06:52,220
standard non secure mode and then this

00:06:48,479 --> 00:06:56,820
in standard guest will then perform some

00:06:52,220 --> 00:06:59,610
some interesting actions first it will

00:06:56,820 --> 00:07:00,990
need to need to load an encrypted blob

00:06:59,610 --> 00:07:02,970
in memory unless it's already there if

00:07:00,990 --> 00:07:04,680
you start qmo with a - kernel option

00:07:02,970 --> 00:07:07,889
then it will already be memory no need

00:07:04,680 --> 00:07:12,240
to run it then the guest will perform a

00:07:07,889 --> 00:07:15,120
reboot into secure mode it's like a

00:07:12,240 --> 00:07:18,030
reboot except that instead of specifying

00:07:15,120 --> 00:07:21,620
a specific device to boot from it will

00:07:18,030 --> 00:07:26,060
specify kind of that the blob is the

00:07:21,620 --> 00:07:29,010
device to reboot from and then to secure

00:07:26,060 --> 00:07:31,949
a reboot in secure mode or protective

00:07:29,010 --> 00:07:34,800
mode at this point the hypervisor will

00:07:31,949 --> 00:07:38,190
issue the appropriate nutria bicycles to

00:07:34,800 --> 00:07:40,260
set up protected guests for example

00:07:38,190 --> 00:07:45,690
creating a secure configuration which we

00:07:40,260 --> 00:07:48,870
create the instance of the of a

00:07:45,690 --> 00:07:52,139
protected guest create secure virtual

00:07:48,870 --> 00:07:54,659
CPUs or create the single instances of

00:07:52,139 --> 00:07:56,970
each of the virtual CPUs that are needed

00:07:54,659 --> 00:07:59,280
for the protectable transition and then

00:07:56,970 --> 00:08:00,630
set configuration parameters which in

00:07:59,280 --> 00:08:03,900
which basically the hypervisor is

00:08:00,630 --> 00:08:07,110
passing this blob taken from the non

00:08:03,900 --> 00:08:11,220
secure guest directly and basically

00:08:07,110 --> 00:08:15,169
given directly to the old traveller at

00:08:11,220 --> 00:08:22,260
this point the hypervisor will unpack

00:08:15,169 --> 00:08:25,530
the this boot blob which means it will

00:08:22,260 --> 00:08:27,900
ask the ultra vires to decrypt all of

00:08:25,530 --> 00:08:31,669
the blob of course it's not just gonna

00:08:27,900 --> 00:08:34,140
be decrypted it will be protected and

00:08:31,669 --> 00:08:36,150
and then decrypted in this way the

00:08:34,140 --> 00:08:39,760
hypervisor will never be able to read

00:08:36,150 --> 00:08:44,019
the content of the boot block

00:08:39,760 --> 00:08:46,720
which could contain secrets this is done

00:08:44,019 --> 00:08:50,880
with a public key the private key is

00:08:46,720 --> 00:08:53,500
simply safely hidden in the hardware and

00:08:50,880 --> 00:08:55,149
at this point a hypervisor just

00:08:53,500 --> 00:08:58,500
continues running the guest

00:08:55,149 --> 00:09:03,779
it just has to switch the format of the

00:08:58,500 --> 00:09:06,160
CPU control block just for the for the

00:09:03,779 --> 00:09:12,040
religion for for the game start

00:09:06,160 --> 00:09:16,810
basically I talked I talked about a

00:09:12,040 --> 00:09:18,940
memory donation during the lifecycle the

00:09:16,810 --> 00:09:21,910
hypervisor we need to need some blocks a

00:09:18,940 --> 00:09:23,250
memory contiguous memory to the alt

00:09:21,910 --> 00:09:25,570
revisor

00:09:23,250 --> 00:09:28,120
the ultra bastrop a storage in

00:09:25,570 --> 00:09:30,490
particular is can be very big and needs

00:09:28,120 --> 00:09:32,589
to be in absolute storage which means a

00:09:30,490 --> 00:09:36,060
physical memory so it needs to be a big

00:09:32,589 --> 00:09:39,070
block of physically contiguous memory

00:09:36,060 --> 00:09:41,829
the size depends on the size of the

00:09:39,070 --> 00:09:43,930
hosts memory and this can be big so this

00:09:41,829 --> 00:09:47,200
should be done probably at the very

00:09:43,930 --> 00:09:49,420
beginning of the boot process of the

00:09:47,200 --> 00:09:51,910
hypervisor otherwise which will not be

00:09:49,420 --> 00:09:54,190
able to find enough memory to allocate

00:09:51,910 --> 00:09:58,060
this this big block the others ones are

00:09:54,190 --> 00:10:03,399
easy because the one per VM and the one

00:09:58,060 --> 00:10:06,700
per CPU differences are small so it's

00:10:03,399 --> 00:10:09,370
not a problem to have to find them this

00:10:06,700 --> 00:10:11,230
one configuration virtual storage can be

00:10:09,370 --> 00:10:15,579
big but it needs to be contiguous

00:10:11,230 --> 00:10:24,310
in in virtual memory so this is also

00:10:15,579 --> 00:10:27,070
easy to to find during runtime so how do

00:10:24,310 --> 00:10:29,020
we handle instruction interception first

00:10:27,070 --> 00:10:30,820
of all many of the fills in the CPU

00:10:29,020 --> 00:10:33,970
state description who become reserved

00:10:30,820 --> 00:10:36,579
and unused because we don't want the

00:10:33,970 --> 00:10:40,930
hypervisor to be able to look into those

00:10:36,579 --> 00:10:42,610
registers or other state there are

00:10:40,930 --> 00:10:44,829
different interception course the normal

00:10:42,610 --> 00:10:47,520
because we're not performing normal

00:10:44,829 --> 00:10:49,649
interception and normal in instruction

00:10:47,520 --> 00:10:53,319
interpretation but

00:10:49,649 --> 00:10:55,209
protect protected so it's a some things

00:10:53,319 --> 00:10:57,099
need to be done differently so we were

00:10:55,209 --> 00:10:59,259
telling the hypervisor that this is not

00:10:57,099 --> 00:11:00,639
a normal thing in some cases there's a

00:10:59,259 --> 00:11:04,779
differentiation because as I said before

00:11:00,639 --> 00:11:06,609
some instructions have to be handled by

00:11:04,779 --> 00:11:08,499
the hypervisor some will be handled by

00:11:06,609 --> 00:11:11,529
the ultraviolet or but the hypervisor

00:11:08,499 --> 00:11:13,749
habit has to be notified about it like

00:11:11,529 --> 00:11:16,119
it's a store traffic's if you know what

00:11:13,749 --> 00:11:20,139
I'm talking about you will understand

00:11:16,119 --> 00:11:25,979
why on the other hand some instructions

00:11:20,139 --> 00:11:30,099
have small buffers it's not practical to

00:11:25,979 --> 00:11:32,169
expose the whole page because then you

00:11:30,099 --> 00:11:34,509
would expose some other memory that is

00:11:32,169 --> 00:11:38,889
around this small buffers so it would be

00:11:34,509 --> 00:11:43,629
impractical on the other hand forcing

00:11:38,889 --> 00:11:47,279
the guest to to use an explicitly secure

00:11:43,629 --> 00:11:51,459
an explicitly shared page to prefer to

00:11:47,279 --> 00:11:54,579
to store this buffers used for these

00:11:51,459 --> 00:11:56,799
instructions would also be too much of a

00:11:54,579 --> 00:11:59,379
burden on the guest side and one of the

00:11:56,799 --> 00:12:02,559
goals was to minimize the impact also on

00:11:59,379 --> 00:12:04,269
the guest so we have this human

00:12:02,559 --> 00:12:07,449
instruction data area which is some kind

00:12:04,269 --> 00:12:10,379
of small bounce buffer which is used for

00:12:07,449 --> 00:12:14,529
bouncing of the small buffers between

00:12:10,379 --> 00:12:20,169
the guest and the hypervisor and back

00:12:14,529 --> 00:12:23,259
what need it this this secure

00:12:20,169 --> 00:12:30,309
instruction that area is in the

00:12:23,259 --> 00:12:34,719
hypervisor storage interrupt injection

00:12:30,309 --> 00:12:36,249
we usually just read the interrupt

00:12:34,719 --> 00:12:38,559
vector for the interrupt we have to

00:12:36,249 --> 00:12:41,979
serviced and we write in the right

00:12:38,559 --> 00:12:45,729
interrupt return address vector what is

00:12:41,979 --> 00:12:47,169
the return address we have to jump back

00:12:45,729 --> 00:12:51,279
after we don't really interrupt and

00:12:47,169 --> 00:12:53,709
that's how we do interrupts normally we

00:12:51,279 --> 00:12:56,529
cannot read or write in memory anymore

00:12:53,709 --> 00:12:59,920
so this is not possible so

00:12:56,529 --> 00:13:01,329
we have to go ultra buzzer and we do

00:12:59,920 --> 00:13:08,790
this in particular through the state

00:13:01,329 --> 00:13:11,769
description there are specific bits and

00:13:08,790 --> 00:13:15,189
that can be set to indicate to the

00:13:11,769 --> 00:13:17,199
ultraviolet when we resume executing the

00:13:15,189 --> 00:13:19,480
CPU that specific interrupts have to be

00:13:17,199 --> 00:13:21,339
injected and the parameters will be

00:13:19,480 --> 00:13:24,339
placed in the same locations as where

00:13:21,339 --> 00:13:26,319
you find them when you actually get an

00:13:24,339 --> 00:13:28,629
interrupt intercept so when we are going

00:13:26,319 --> 00:13:30,639
in the other direction normally not

00:13:28,629 --> 00:13:33,040
interrupt not all interrupts are always

00:13:30,639 --> 00:13:35,170
allowed the particular program

00:13:33,040 --> 00:13:38,279
interrupts so exceptions are only

00:13:35,170 --> 00:13:40,509
allowed to be injected when we are

00:13:38,279 --> 00:13:44,110
interpreting or emulating a specific

00:13:40,509 --> 00:13:47,410
instructions that we expect that can

00:13:44,110 --> 00:13:48,939
possibly generate those interest

00:13:47,410 --> 00:13:53,379
interrupts and then only those

00:13:48,939 --> 00:13:55,569
interrupts can be injected and of course

00:13:53,379 --> 00:13:57,910
it's not allowed to inject any

00:13:55,569 --> 00:14:03,550
interrupts that has been masked because

00:13:57,910 --> 00:14:07,589
that's the whole point of masking so

00:14:03,550 --> 00:14:07,589
what changes in the state description is

00:14:08,009 --> 00:14:12,790
interception parameters normally you we

00:14:11,019 --> 00:14:18,490
find there the text of the instruction

00:14:12,790 --> 00:14:21,339
that generates the interception this

00:14:18,490 --> 00:14:23,439
would be normalized so if the

00:14:21,339 --> 00:14:26,439
instruction uses register five and six

00:14:23,439 --> 00:14:29,410
and another time it uses registers seven

00:14:26,439 --> 00:14:32,829
and twelve you will always see two and

00:14:29,410 --> 00:14:35,620
three here no matter what the general

00:14:32,829 --> 00:14:40,029
registers are also saved into the state

00:14:35,620 --> 00:14:42,069
description only on a moneda so on a

00:14:40,029 --> 00:14:45,399
case-by-case basis depending on which

00:14:42,069 --> 00:14:49,839
instruction is to be handled by the

00:14:45,399 --> 00:14:51,850
hypervisor those registers are also

00:14:49,839 --> 00:14:54,009
saved a normalized location and it's in

00:14:51,850 --> 00:14:56,829
the same normalized location that is

00:14:54,009 --> 00:15:00,129
indicated in the instruction text so the

00:14:56,829 --> 00:15:01,509
hypervisor will not be confused and when

00:15:00,129 --> 00:15:04,339
appropriate they will be copied back to

00:15:01,509 --> 00:15:08,800
the correct guest registers

00:15:04,339 --> 00:15:11,870
this also means that when exiting from

00:15:08,800 --> 00:15:15,019
from the VM the registers will not

00:15:11,870 --> 00:15:17,420
contain anything the actual registers

00:15:15,019 --> 00:15:22,249
will not contain anything that's it's

00:15:17,420 --> 00:15:25,490
different from what normal that the

00:15:22,249 --> 00:15:28,160
normal emulation works on it's 290

00:15:25,490 --> 00:15:30,649
normally for the control registers we

00:15:28,160 --> 00:15:34,339
only see the interrupts related bits so

00:15:30,649 --> 00:15:36,649
which classes of interrupts are enabled

00:15:34,339 --> 00:15:39,079
because the hypervisor needs to need

00:15:36,649 --> 00:15:42,529
needs to know which interrupt it's

00:15:39,079 --> 00:15:46,519
allowed to inject or not to avoid making

00:15:42,529 --> 00:15:49,100
the ultra vires are unhappy same for the

00:15:46,519 --> 00:15:52,790
program status word only the interrupt

00:15:49,100 --> 00:15:54,620
bits are saved and the wait state the

00:15:52,790 --> 00:15:56,209
wait state is needed because the

00:15:54,620 --> 00:16:00,040
hypervisor needs to know when a CPU

00:15:56,209 --> 00:16:00,040
doesn't need to be scheduled anymore

00:16:00,309 --> 00:16:05,680
another interesting thing is the

00:16:02,209 --> 00:16:08,809
condition code which is right only so

00:16:05,680 --> 00:16:12,379
when an instruction needs to set the

00:16:08,809 --> 00:16:16,279
condition code the hypervisor can just

00:16:12,379 --> 00:16:18,649
set the condition code normally the

00:16:16,279 --> 00:16:22,339
condition code is never saved from the

00:16:18,649 --> 00:16:25,910
secure VM to the hypervisor and it's

00:16:22,339 --> 00:16:28,069
only read from the hypervisor when we

00:16:25,910 --> 00:16:31,309
expect one and even then it's checked

00:16:28,069 --> 00:16:33,079
like you cannot return to if the

00:16:31,309 --> 00:16:37,459
architecture only allows for zero or

00:16:33,079 --> 00:16:39,649
three so this is checked and of course

00:16:37,459 --> 00:16:41,420
the is secure the pointer to the secure

00:16:39,649 --> 00:16:45,889
instruction data area is also in the

00:16:41,420 --> 00:16:51,439
state description so what does the guest

00:16:45,889 --> 00:16:54,550
do first is a good stop which checks if

00:16:51,439 --> 00:16:57,339
these protectors with realization

00:16:54,550 --> 00:16:59,680
enhancements are available lost the

00:16:57,339 --> 00:17:03,370
crypto blow up and and performance if

00:16:59,680 --> 00:17:07,449
reboot as I said before what happens in

00:17:03,370 --> 00:17:09,579
the kernel it checks if the ultra buzzer

00:17:07,449 --> 00:17:12,189
is available and performs a query

00:17:09,579 --> 00:17:15,400
function to discover for example if it's

00:17:12,189 --> 00:17:17,709
running as a host or a guest if the

00:17:15,400 --> 00:17:19,270
guest discovers that or when the guest

00:17:17,709 --> 00:17:24,189
discovers that it's running as a guest

00:17:19,270 --> 00:17:27,189
it needs to set up some shared memory so

00:17:24,189 --> 00:17:29,710
to mark some memory as shared for the

00:17:27,189 --> 00:17:33,640
bounce offer and then use the bounce

00:17:29,710 --> 00:17:40,480
buffer and we we just stab you TLB I

00:17:33,640 --> 00:17:44,169
hope for beta oh let's see which changes

00:17:40,480 --> 00:17:48,070
then we're needed in the end in the

00:17:44,169 --> 00:17:49,870
guest and in a hypervisor ok this small

00:17:48,070 --> 00:17:52,390
change in a bootloader a boot or in the

00:17:49,870 --> 00:17:53,890
bootstrap is ok first loading the blob

00:17:52,390 --> 00:17:57,400
and then performing this transition

00:17:53,890 --> 00:18:00,730
transition in secure mode it's not much

00:17:57,400 --> 00:18:03,400
of a change but it's there changes in

00:18:00,730 --> 00:18:05,140
the guest as I said the Ocotillo have

00:18:03,400 --> 00:18:07,380
been designed for to require them it

00:18:05,140 --> 00:18:10,440
smallest amount to change so apart from

00:18:07,380 --> 00:18:13,419
queer neutralizer and then during this

00:18:10,440 --> 00:18:16,240
shared buffers there's not really much

00:18:13,419 --> 00:18:18,940
to to do one note is that the guest will

00:18:16,240 --> 00:18:21,039
run in keyless mode if you know anything

00:18:18,940 --> 00:18:22,870
about Esther 90 architecture storage is

00:18:21,039 --> 00:18:26,500
a is a very very important part of the

00:18:22,870 --> 00:18:31,270
architecture and secure guests will not

00:18:26,500 --> 00:18:33,309
have storage keys all this has been

00:18:31,270 --> 00:18:41,559
already up streamed this is already

00:18:33,309 --> 00:18:45,159
upstream changes in KDM so this requires

00:18:41,559 --> 00:18:47,260
changing actually the boot process of

00:18:45,159 --> 00:18:50,020
linux itself because we have to do this

00:18:47,260 --> 00:18:51,610
query all provider information a memory

00:18:50,020 --> 00:18:54,480
donation this memory donation has to be

00:18:51,610 --> 00:18:57,299
done very early at boot

00:18:54,480 --> 00:19:02,850
then the memory access is ideas for for

00:18:57,299 --> 00:19:06,480
qmo sometimes qmo will try to write in

00:19:02,850 --> 00:19:09,780
to the guests and it will not write

00:19:06,480 --> 00:19:12,960
directly into into the memory but it

00:19:09,780 --> 00:19:15,240
will pass through the kernel to avoid

00:19:12,960 --> 00:19:17,970
synchronization issues what we are doing

00:19:15,240 --> 00:19:20,370
here is two sheets and qmo we think it's

00:19:17,970 --> 00:19:22,500
writing somewhere but we instead we are

00:19:20,370 --> 00:19:24,590
writing into this secure instruction

00:19:22,500 --> 00:19:27,929
data area

00:19:24,590 --> 00:19:31,200
of course interrupt injection needed to

00:19:27,929 --> 00:19:34,549
be changed and several instruction is a

00:19:31,200 --> 00:19:36,990
special handling in some cases because

00:19:34,549 --> 00:19:39,179
they are handled by the ultra vires but

00:19:36,990 --> 00:19:41,250
just isn't notification that happens in

00:19:39,179 --> 00:19:45,660
some cases because they really need to

00:19:41,250 --> 00:19:48,330
do to behave differently and of course

00:19:45,660 --> 00:19:53,730
the ultra bizarre calls they sprinkled

00:19:48,330 --> 00:19:57,299
all over the lifecycle of the virtual

00:19:53,730 --> 00:20:00,480
machines the patches have been sent to

00:19:57,299 --> 00:20:02,460
the meaning lists last week so there's

00:20:00,480 --> 00:20:04,710
not upstream yet completely but the

00:20:02,460 --> 00:20:09,780
discussion has started we have had some

00:20:04,710 --> 00:20:12,630
some some comments already on it finally

00:20:09,780 --> 00:20:13,980
what needs to be done in qmu is to add

00:20:12,630 --> 00:20:20,580
the support for this reboot in secure

00:20:13,980 --> 00:20:22,980
mode and to fix some some instructions

00:20:20,580 --> 00:20:24,840
because for some instruction Camus was

00:20:22,980 --> 00:20:28,530
actually writing directly to memory and

00:20:24,840 --> 00:20:30,750
this time it needs to go through true

00:20:28,530 --> 00:20:34,309
KBM so that it can write into this

00:20:30,750 --> 00:20:38,370
secure instruction that they are instead

00:20:34,309 --> 00:20:41,390
some conclusions first of all what what

00:20:38,370 --> 00:20:43,860
have you have we learned or what have

00:20:41,390 --> 00:20:48,620
what improvements have we done in

00:20:43,860 --> 00:20:51,679
general since this is a touched a lot of

00:20:48,620 --> 00:20:55,500
points in the architecture we found some

00:20:51,679 --> 00:20:58,570
banks that were there already and we in

00:20:55,500 --> 00:21:07,420
general improve the overall

00:20:58,570 --> 00:21:11,020
compliance of of qmo and KVM and to swap

00:21:07,420 --> 00:21:13,240
on migration which is just two bounded

00:21:11,020 --> 00:21:15,520
points I know but it's a lot of it's a

00:21:13,240 --> 00:21:19,660
lot of work we actually have some some

00:21:15,520 --> 00:21:24,660
idea of how to do swap and we still

00:21:19,660 --> 00:21:33,910
working on migration and that's it

00:21:24,660 --> 00:21:36,520
questions I have two questions one is

00:21:33,910 --> 00:21:38,680
for the normalization and all those

00:21:36,520 --> 00:21:40,390
things how much of that is done by the

00:21:38,680 --> 00:21:43,210
will.traveller and how much of that is

00:21:40,390 --> 00:21:49,570
done by the microprocessor of you or

00:21:43,210 --> 00:21:52,780
Michael code that's implement that's

00:21:49,570 --> 00:21:56,560
implementation detail so as much as

00:21:52,780 --> 00:21:58,360
needed to not make performance I mean

00:21:56,560 --> 00:22:01,660
it's done as much as neatest as you need

00:21:58,360 --> 00:22:03,220
to work yes and and tomorrow today's

00:22:01,660 --> 00:22:06,010
something tomorrow can be something else

00:22:03,220 --> 00:22:08,410
so that's really the difference and then

00:22:06,010 --> 00:22:11,680
the second question can you go one slide

00:22:08,410 --> 00:22:13,800
I think yeah so migration right because

00:22:11,680 --> 00:22:16,600
I forgot myself what I was going to ask

00:22:13,800 --> 00:22:20,230
so for live migration is there already

00:22:16,600 --> 00:22:23,830
some service planned in Delta wiser to

00:22:20,230 --> 00:22:29,380
help with that not really at the moment

00:22:23,830 --> 00:22:30,960
we I mean there's something we want that

00:22:29,380 --> 00:22:34,420
they can tell you we want to do that

00:22:30,960 --> 00:22:36,670
eventually but because I'm thinking of

00:22:34,420 --> 00:22:40,930
x86 and some things that have done in

00:22:36,670 --> 00:22:43,990
much more strict and complete way than

00:22:40,930 --> 00:22:47,250
for example the AMD extensions for

00:22:43,990 --> 00:22:49,510
securitization underhand AMD was already

00:22:47,250 --> 00:22:52,950
planning for a live migration from the

00:22:49,510 --> 00:22:52,950
beginning in the Fiesta station

00:23:00,629 --> 00:23:05,100
I'm their purposes I know nothing about

00:23:02,850 --> 00:23:08,639
s/390 so I apologize if anything is

00:23:05,100 --> 00:23:10,500
stupid you mentioned that you have to

00:23:08,639 --> 00:23:13,110
have the guest share memory to the host

00:23:10,500 --> 00:23:14,570
is there anything there on the KVM

00:23:13,110 --> 00:23:18,210
software side that could possibly be

00:23:14,570 --> 00:23:22,470
reusable for x86 because doing similar

00:23:18,210 --> 00:23:25,830
things requires similar concepts what do

00:23:22,470 --> 00:23:28,590
you mean in the sense of this concept

00:23:25,830 --> 00:23:30,960
that team you can no longer see portions

00:23:28,590 --> 00:23:34,440
of gasps memory but kenzie portions of

00:23:30,960 --> 00:23:35,250
guest memory ok death that's it goes in

00:23:34,440 --> 00:23:39,570
the other direction

00:23:35,250 --> 00:23:43,110
AMD is doing that for a cv using band

00:23:39,570 --> 00:23:44,850
bounce buffers so we'll imagine that you

00:23:43,110 --> 00:23:48,840
need sure but the chasm is hell share

00:23:44,850 --> 00:23:51,149
memory let him told I did to get support

00:23:48,840 --> 00:23:53,879
and basically very piggybacking on the

00:23:51,149 --> 00:23:58,259
infrastructure introduced by AMD so they

00:23:53,879 --> 00:24:01,080
did it first and we are we are pining

00:23:58,259 --> 00:24:03,750
and doing what we need to do differently

00:24:01,080 --> 00:24:06,169
but basically the most work was already

00:24:03,750 --> 00:24:06,169
done

00:24:17,760 --> 00:24:22,420
so a couple of questions and I

00:24:20,620 --> 00:24:25,030
understand that Anzhi you actually have

00:24:22,420 --> 00:24:26,800
two levels of Piper vice you have an L

00:24:25,030 --> 00:24:29,500
per level and then you have KVM running

00:24:26,800 --> 00:24:31,480
on top of that now you were just using

00:24:29,500 --> 00:24:33,460
the term hypervisor and you're talking

00:24:31,480 --> 00:24:36,940
about donating memory that's absolute

00:24:33,460 --> 00:24:39,310
memory is it KVM that knows about

00:24:36,940 --> 00:24:42,280
absolute memory and can donate that or

00:24:39,310 --> 00:24:44,110
is it the l power level its absolute in

00:24:42,280 --> 00:24:48,550
term of the configuration so it's

00:24:44,110 --> 00:24:52,030
absolute for the L per guest it's not

00:24:48,550 --> 00:24:55,960
the system it's not system absolute as

00:24:52,030 --> 00:24:57,490
in in the whole thing absolute okay and

00:24:55,960 --> 00:25:01,960
then the second question is that you

00:24:57,490 --> 00:25:05,320
talked about being able to do I owe now

00:25:01,960 --> 00:25:09,790
is that s3 not a specific IO or is it

00:25:05,320 --> 00:25:12,670
very because we hit ya on pair we have

00:25:09,790 --> 00:25:14,920
yes so it's Bao

00:25:12,670 --> 00:25:18,280
but it's not your thigh your pc i its

00:25:14,920 --> 00:25:21,970
rear tire CCW which is the same concept

00:25:18,280 --> 00:25:23,680
but instead of having a PCI device as a

00:25:21,970 --> 00:25:26,740
proxy you have a channel device as a

00:25:23,680 --> 00:25:29,650
proxy because we don't we must still

00:25:26,740 --> 00:25:32,320
need to have the ring buffers mapped

00:25:29,650 --> 00:25:34,960
with an iommu or something to do the

00:25:32,320 --> 00:25:36,370
bounce buffering on on or to do the

00:25:34,960 --> 00:25:38,320
bounce buffering on all the data that is

00:25:36,370 --> 00:25:40,870
being transferred through the very

00:25:38,320 --> 00:25:44,200
device how do you arrange that bounce

00:25:40,870 --> 00:25:48,040
buffering is that we are using the stop

00:25:44,200 --> 00:25:52,290
you TLB I you're like I am DS doing for

00:25:48,040 --> 00:25:52,290
for bounce buffering it

00:25:52,480 --> 00:25:58,299
I mean he implemented most of it so

00:25:55,779 --> 00:26:00,429
maybe he can tell you more but it's we

00:25:58,299 --> 00:26:03,159
didn't really need to do to do much we

00:26:00,429 --> 00:26:08,169
just reuse the existing infrastructure

00:26:03,159 --> 00:26:10,450
for for for bonds buffering for the

00:26:08,169 --> 00:26:13,779
channel programs we actually don't have

00:26:10,450 --> 00:26:16,749
a one because it's so differently actor

00:26:13,779 --> 00:26:19,210
it actually actually in Hardware I think

00:26:16,749 --> 00:26:21,070
we do have somewhere deep below and I

00:26:19,210 --> 00:26:26,649
wanna move but that's again an

00:26:21,070 --> 00:26:28,989
implementation detail and anyway this

00:26:26,649 --> 00:26:31,389
small any small buffer that is needed

00:26:28,989 --> 00:26:33,190
for this kind of i/o like this

00:26:31,389 --> 00:26:37,690
descriptors that are passed would

00:26:33,190 --> 00:26:40,570
normally describe which kind of of i/o

00:26:37,690 --> 00:26:43,090
is to be performed this is the small

00:26:40,570 --> 00:26:49,450
buffers are actually bounced to and from

00:26:43,090 --> 00:26:52,869
the guest using this small bounce buffer

00:26:49,450 --> 00:26:58,389
that is handled by those revisor so when

00:26:52,869 --> 00:26:59,980
doing like channel operations that small

00:26:58,389 --> 00:27:03,879
buffer that is like a few hundred bytes

00:26:59,980 --> 00:27:06,700
is copy true to and from this small very

00:27:03,879 --> 00:27:10,989
specific bounce buffer this tiny kind of

00:27:06,700 --> 00:27:15,700
bounce buffer thing and by ultraviolet

00:27:10,989 --> 00:27:16,989
or so if that answers a question oh okay

00:27:15,700 --> 00:27:19,239
thank you we're running out of time so

00:27:16,989 --> 00:27:21,639
maybe the next questions gonna be like

00:27:19,239 --> 00:27:24,700
in the hall so I will be around anyway

00:27:21,639 --> 00:27:31,169
and today and tomorrow so if you have

00:27:24,700 --> 00:27:31,169
any question just drop thank you

00:27:32,240 --> 00:27:40,489
you

00:27:33,630 --> 00:27:40,489

YouTube URL: https://www.youtube.com/watch?v=J2YibrLfB4s


