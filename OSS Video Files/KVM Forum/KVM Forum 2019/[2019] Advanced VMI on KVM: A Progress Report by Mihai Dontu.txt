Title: [2019] Advanced VMI on KVM: A Progress Report by Mihai Dontu
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	This talk is a follow-up to our 2017 one called “Bringing Commercial Grade Virtual Machine Introspection to KVM”. Since then we have made a lot of progress with regards to performance and stability, and are also on track to include support for three Intel features that can greatly help with scalability: VMFUNC, #VE and SPP. We also came across a surprise: in our tests, the speed of the more involved guest-to-hypervisor communication channel used on KVM (BSD sockets on top of vhost-vsock) comes very close to Xen’s lightweight event channel. And we have the numbers to prove it.

---

Mihai Donțu
Bitdefender
Engineering Manager

I lead the Linux development team at Bitdefender and I am currently involved in integrating our HVI technology with open source hypervisors like Xen and KVM
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,319 --> 00:00:13,980
hi everyone me hi my name is Mihai Junsu

00:00:10,380 --> 00:00:15,839
I work at the defender and I lead the

00:00:13,980 --> 00:00:21,930
Linux development team that's in charge

00:00:15,839 --> 00:00:23,310
with developing a VM I API for KVM and

00:00:21,930 --> 00:00:26,189
this is a progress report for

00:00:23,310 --> 00:00:29,099
representation that I held in 2017 where

00:00:26,189 --> 00:00:31,380
we laid out an initial plan for VMI it

00:00:29,099 --> 00:00:35,000
was very alpha code not a lot of

00:00:31,380 --> 00:00:37,530
features in it this is a report for the

00:00:35,000 --> 00:00:41,340
two years that have passed since then

00:00:37,530 --> 00:00:43,230
and it's connected to the presentation

00:00:41,340 --> 00:00:47,550
that Juna Kojima and my colleague and I

00:00:43,230 --> 00:00:52,680
had yesterday about vbh and hvi this

00:00:47,550 --> 00:00:56,550
part of this API plugs into that hvi

00:00:52,680 --> 00:01:00,359
technology to to have it work on top of

00:00:56,550 --> 00:01:03,840
KBM this is my agenda it's pretty packed

00:01:00,359 --> 00:01:05,549
I haven't really timed it well so I hope

00:01:03,840 --> 00:01:09,500
I'll be able to go through it I'll just

00:01:05,549 --> 00:01:12,030
compress some slides into one big phrase

00:01:09,500 --> 00:01:15,090
first I'll begin ways be defended

00:01:12,030 --> 00:01:16,590
pursuing VMI well it all started a

00:01:15,090 --> 00:01:20,610
couple of years ago when we got a pretty

00:01:16,590 --> 00:01:22,740
loud confirmation that certain entities

00:01:20,610 --> 00:01:24,409
with financial with serious financial

00:01:22,740 --> 00:01:28,159
backing we're collecting exploits

00:01:24,409 --> 00:01:30,630
critical exploits we called zero days

00:01:28,159 --> 00:01:33,240
they were not disclosing them to the

00:01:30,630 --> 00:01:35,880
public and they were just using it for

00:01:33,240 --> 00:01:41,360
their own purposes these exploits

00:01:35,880 --> 00:01:43,979
managed to subvert all in guests

00:01:41,360 --> 00:01:50,930
security boundaries and be able to

00:01:43,979 --> 00:01:53,939
persist X exfiltrate data and so on the

00:01:50,930 --> 00:01:56,780
majority in the majority of the cases

00:01:53,939 --> 00:02:01,439
the source of these

00:01:56,780 --> 00:02:04,170
of these exploits begins with the

00:02:01,439 --> 00:02:06,149
software itself the problem is that the

00:02:04,170 --> 00:02:08,489
kernel is very complex those people who

00:02:06,149 --> 00:02:11,550
work on the Linux kernel or even kid

00:02:08,489 --> 00:02:14,670
just KVM I have a pretty good image of

00:02:11,550 --> 00:02:16,920
how complex Lennox is these days the

00:02:14,670 --> 00:02:19,230
Windows kernel is just as complex and on

00:02:16,920 --> 00:02:23,480
top of that a couple of years ago with

00:02:19,230 --> 00:02:27,000
Google lyrics in it browsers are

00:02:23,480 --> 00:02:31,400
fantastically complicated pieces of

00:02:27,000 --> 00:02:34,040
software and bugs that appear in these

00:02:31,400 --> 00:02:39,150
United kernel

00:02:34,040 --> 00:02:41,629
various software in many cases managed

00:02:39,150 --> 00:02:45,840
to achieve privileged level

00:02:41,629 --> 00:02:48,390
privilege escalation and take full

00:02:45,840 --> 00:02:53,489
control of the operating system there

00:02:48,390 --> 00:02:57,599
are various processes various methods to

00:02:53,489 --> 00:02:58,920
harden these components however it takes

00:02:57,599 --> 00:03:01,730
a little bit of time and we're looking

00:02:58,920 --> 00:03:05,670
through VMI to take a few steps forward

00:03:01,730 --> 00:03:10,109
until everyone agrees on how to properly

00:03:05,670 --> 00:03:12,030
fix things so what exactly is VMI well

00:03:10,109 --> 00:03:15,989
it's the ability to look from outside

00:03:12,030 --> 00:03:18,389
the operating system and identify it the

00:03:15,989 --> 00:03:21,420
determine whether it's a Windows OS

00:03:18,389 --> 00:03:23,239
whether it's a Linux OS and identify the

00:03:21,420 --> 00:03:25,799
software that is running inside it

00:03:23,239 --> 00:03:28,919
various applications browsers office

00:03:25,799 --> 00:03:30,599
readers all that and also determine if

00:03:28,919 --> 00:03:33,900
there is potentially harmful software

00:03:30,599 --> 00:03:36,599
running inside of it achieve all this

00:03:33,900 --> 00:03:40,470
without the use of any guest tools

00:03:36,599 --> 00:03:42,470
anything you don't need software running

00:03:40,470 --> 00:03:45,599
inside the guest OS to tell you okay

00:03:42,470 --> 00:03:47,099
that process I started that process is

00:03:45,599 --> 00:03:51,090
opening those files or doing

00:03:47,099 --> 00:03:54,090
god-knows-what the advantages of a

00:03:51,090 --> 00:03:56,549
security solution based on VMI is that

00:03:54,090 --> 00:03:58,980
it can achieve better installation right

00:03:56,549 --> 00:04:00,780
the hardware itself basically changes

00:03:58,980 --> 00:04:03,359
personality whatever it enters the guest

00:04:00,780 --> 00:04:05,969
and it provides a pretty solid boundary

00:04:03,359 --> 00:04:07,620
between whatever the guest is running

00:04:05,969 --> 00:04:09,930
the guest itself and the security

00:04:07,620 --> 00:04:11,579
application it also removes the relay

00:04:09,930 --> 00:04:13,230
on the operating system for it to

00:04:11,579 --> 00:04:14,700
function it does not need the

00:04:13,230 --> 00:04:16,259
cooperation of the operating system most

00:04:14,700 --> 00:04:18,600
of the time was security application

00:04:16,259 --> 00:04:21,269
using VM I will completely stop the

00:04:18,600 --> 00:04:23,729
operating system and inspect whatever is

00:04:21,269 --> 00:04:27,180
going on potentially every now and then

00:04:23,729 --> 00:04:30,360
ask it to page in some information and

00:04:27,180 --> 00:04:31,350
it also minimizes the interference with

00:04:30,360 --> 00:04:33,030
the operating system

00:04:31,350 --> 00:04:37,310
you don't need drivers you don't need to

00:04:33,030 --> 00:04:39,720
do any tricks inside of it that in

00:04:37,310 --> 00:04:41,820
future versions of that operating system

00:04:39,720 --> 00:04:45,840
might prove to be a bad idea and crash

00:04:41,820 --> 00:04:48,780
it all what not the typical cases for

00:04:45,840 --> 00:04:52,470
using VMI are detecting memory

00:04:48,780 --> 00:04:55,610
violations okay so using EPT we set some

00:04:52,470 --> 00:04:59,190
hooks right mark certain areas either

00:04:55,610 --> 00:05:02,610
read write read execute or unwritten

00:04:59,190 --> 00:05:04,440
writable and so on and violations that

00:05:02,610 --> 00:05:08,460
can begin with buffer overflows right

00:05:04,440 --> 00:05:12,180
somebody starts writing way beyond the

00:05:08,460 --> 00:05:15,120
normal boundaries and reaches the stack

00:05:12,180 --> 00:05:17,070
page guard and triggers an event that

00:05:15,120 --> 00:05:20,820
then a security application can start

00:05:17,070 --> 00:05:24,750
looking to see what's going on it can be

00:05:20,820 --> 00:05:26,520
used to prevent code injection it's very

00:05:24,750 --> 00:05:29,449
easy to determine which are which

00:05:26,520 --> 00:05:33,210
process inside the guest OS is writing

00:05:29,449 --> 00:05:35,909
where and whether it's allowed to do

00:05:33,210 --> 00:05:39,440
soon or not it can guarantee integrity

00:05:35,909 --> 00:05:42,060
of India security so a security based

00:05:39,440 --> 00:05:46,190
VMI Bay security application cannot for

00:05:42,060 --> 00:05:49,020
example do file inspection that will be

00:05:46,190 --> 00:05:51,440
penalize the performance way too much so

00:05:49,020 --> 00:05:53,400
what it can do is make sure that a

00:05:51,440 --> 00:05:58,740
dedicated security application running

00:05:53,400 --> 00:06:01,560
inside the guest remains remains

00:05:58,740 --> 00:06:03,419
untouched by a potential attacker it can

00:06:01,560 --> 00:06:05,610
also make sure that the drivers and the

00:06:03,419 --> 00:06:07,440
kernel itself is not compromised there's

00:06:05,610 --> 00:06:09,780
no patching there's no tricks there's no

00:06:07,440 --> 00:06:14,039
driver objects being overridden somehow

00:06:09,780 --> 00:06:17,250
or anything and it can also close keep a

00:06:14,039 --> 00:06:22,500
closer close eye on every process being

00:06:17,250 --> 00:06:23,879
spawn inside the operating system so how

00:06:22,500 --> 00:06:28,259
is the defender using vir

00:06:23,879 --> 00:06:32,129
well through hvi and which employees EPT

00:06:28,259 --> 00:06:34,229
in the case of Intel CPUs it essentially

00:06:32,129 --> 00:06:38,189
secures the OS kernel that's pretty

00:06:34,229 --> 00:06:41,969
basic there are many solutions out there

00:06:38,189 --> 00:06:44,849
that try to achieve the same thing it

00:06:41,969 --> 00:06:46,740
does this by enforcing code right it

00:06:44,849 --> 00:06:48,539
remains with execute data remains with

00:06:46,740 --> 00:06:49,860
the right stack read/write heap

00:06:48,539 --> 00:06:53,399
read-only so on

00:06:49,860 --> 00:06:54,839
it protects core pieces of the operating

00:06:53,399 --> 00:06:56,279
system right to interrupt the scripted

00:06:54,839 --> 00:06:59,219
table to global descriptor table the

00:06:56,279 --> 00:07:02,429
system services and so on in the system

00:06:59,219 --> 00:07:04,289
see our three credentials and all that

00:07:02,429 --> 00:07:06,209
it secures the driver object make sure

00:07:04,289 --> 00:07:10,709
that pointers inside every driver object

00:07:06,209 --> 00:07:13,619
which in case of Windows are registered

00:07:10,709 --> 00:07:15,330
and by the driver and the pointers are

00:07:13,619 --> 00:07:18,240
inside the drivers itself so it makes

00:07:15,330 --> 00:07:20,429
sure that remains the same it enforces

00:07:18,240 --> 00:07:23,240
certain hardware features for example a

00:07:20,429 --> 00:07:28,829
supervisory mode execution prevention

00:07:23,240 --> 00:07:31,709
it's not turned off by some malicious

00:07:28,829 --> 00:07:35,300
application or driver it makes sure that

00:07:31,709 --> 00:07:38,069
the the kernel system call entry point

00:07:35,300 --> 00:07:42,209
remains the same exciti six has a number

00:07:38,069 --> 00:07:43,469
of MS stars who indicate where the CPU

00:07:42,209 --> 00:07:50,309
should start executing every time a

00:07:43,469 --> 00:07:52,679
Cisco is is made and it the protection

00:07:50,309 --> 00:07:54,839
can be extended for user mode

00:07:52,679 --> 00:07:55,649
applications as well this is a little

00:07:54,839 --> 00:07:58,469
bit more complicated because

00:07:55,649 --> 00:07:59,879
applications have their own page tables

00:07:58,469 --> 00:08:01,169
have their own memory allocation built

00:07:59,879 --> 00:08:04,740
on top of the operating system memory

00:08:01,169 --> 00:08:06,839
allocation algorithms but it can be

00:08:04,740 --> 00:08:10,469
doable by more closely monitoring the

00:08:06,839 --> 00:08:12,329
always kernel it can then infer what

00:08:10,469 --> 00:08:14,669
users applications are started and

00:08:12,329 --> 00:08:18,329
provide the same security for code data

00:08:14,669 --> 00:08:23,129
prevent code injections prevent dll's

00:08:18,329 --> 00:08:25,550
from being shared up should objects not

00:08:23,129 --> 00:08:27,749
necessarily with no specific even though

00:08:25,550 --> 00:08:29,279
the majority of the Usk stopped talking

00:08:27,749 --> 00:08:31,979
here are pretty connected pretty well

00:08:29,279 --> 00:08:34,900
connected to windows making sure system

00:08:31,979 --> 00:08:37,620
services are not overwritten they don't

00:08:34,900 --> 00:08:40,150
not hooked in any way and you can also

00:08:37,620 --> 00:08:43,419
terminate applications so for example if

00:08:40,150 --> 00:08:45,880
an application is determined to have an

00:08:43,419 --> 00:08:50,140
abnormal behavior or outright malicious

00:08:45,880 --> 00:08:52,390
it can also be terminated so the

00:08:50,140 --> 00:08:55,870
architecture that we are envisioning

00:08:52,390 --> 00:08:58,900
with HDI is looks pretty much in this

00:08:55,870 --> 00:09:01,210
fashion ways the KVM hypervisor is

00:08:58,900 --> 00:09:04,420
running a number of virtual machines but

00:09:01,210 --> 00:09:07,420
one of these virtual machines is has the

00:09:04,420 --> 00:09:10,000
sole purpose to monitor all the others

00:09:07,420 --> 00:09:13,390
right this is a special virtual machine

00:09:10,000 --> 00:09:18,160
its measured booted it's separated from

00:09:13,390 --> 00:09:23,020
the network it has a municipal class

00:09:18,160 --> 00:09:27,760
than all the others alright so for our

00:09:23,020 --> 00:09:30,810
KVM work we the bench series that we're

00:09:27,760 --> 00:09:33,580
working on it's still in RFC we've

00:09:30,810 --> 00:09:37,900
reached the sixth version we started in

00:09:33,580 --> 00:09:42,130
2017 and pretty recently we've published

00:09:37,900 --> 00:09:46,810
the last one in these two years we've

00:09:42,130 --> 00:09:48,970
had a number of difficulties for example

00:09:46,810 --> 00:09:54,100
controlling the extended page tables we

00:09:48,970 --> 00:09:59,290
tried to mimic the behavior on Zen which

00:09:54,100 --> 00:10:02,470
is our first implementation of API by

00:09:59,290 --> 00:10:04,540
simply hooking the page fault handler

00:10:02,470 --> 00:10:06,339
that didn't really work very well

00:10:04,540 --> 00:10:10,240
because there are many places in KVM

00:10:06,339 --> 00:10:11,850
where the EPT is slightly adjusted we

00:10:10,240 --> 00:10:16,450
also had to work around emulator

00:10:11,850 --> 00:10:19,180
limitations the x86 emulator in KVM

00:10:16,450 --> 00:10:20,140
supports as many instructions as they

00:10:19,180 --> 00:10:24,339
were needed at the time

00:10:20,140 --> 00:10:26,950
KVM was developed with VMI almost the

00:10:24,339 --> 00:10:29,650
entire set is required in support for

00:10:26,950 --> 00:10:31,959
the entire x86 instruction set is

00:10:29,650 --> 00:10:34,720
required however there's a workaround

00:10:31,959 --> 00:10:38,020
for it which is single stepping it's a

00:10:34,720 --> 00:10:41,380
pretty straightforward mechanism use VM

00:10:38,020 --> 00:10:43,450
X's monitor trap flag for the V CPU that

00:10:41,380 --> 00:10:46,750
caused the page fault but we wanted to

00:10:43,450 --> 00:10:49,060
move forward without removing

00:10:46,750 --> 00:10:51,370
EPT permission bits we simply

00:10:49,060 --> 00:10:55,030
single-step the periphery CPU while all

00:10:51,370 --> 00:10:56,830
the others are suspended and then after

00:10:55,030 --> 00:11:00,940
single stepping we restore permissions

00:10:56,830 --> 00:11:02,640
in EPT and let the guests go do its

00:11:00,940 --> 00:11:06,760
thing

00:11:02,640 --> 00:11:08,530
another issue we've we're still working

00:11:06,760 --> 00:11:11,680
on it is the inter guest page sharing or

00:11:08,530 --> 00:11:14,950
remote mapping as we call it we've we're

00:11:11,680 --> 00:11:17,340
working I think in a 50 version the

00:11:14,950 --> 00:11:20,370
fourth one being published in August

00:11:17,340 --> 00:11:23,140
whatever we did we simply could not

00:11:20,370 --> 00:11:27,040
manage to get the case I'm general same

00:11:23,140 --> 00:11:31,060
page merging and transparent huge pages

00:11:27,040 --> 00:11:33,300
to cooperate so currently KP my requires

00:11:31,060 --> 00:11:39,790
these two features to be disabled

00:11:33,300 --> 00:11:41,950
another difficult task was doing since

00:11:39,790 --> 00:11:43,420
the security virtual appliance the age

00:11:41,950 --> 00:11:46,710
of the security application communicates

00:11:43,420 --> 00:11:51,690
with the hosts through a bsd socket

00:11:46,710 --> 00:11:56,460
getting code inside the kernel to do

00:11:51,690 --> 00:11:57,640
basic networking tasks without avoiding

00:11:56,460 --> 00:12:02,010
deadlocking

00:11:57,640 --> 00:12:05,310
or doing operations in interrupt context

00:12:02,010 --> 00:12:07,780
illegal operations and internal context

00:12:05,310 --> 00:12:10,000
we also tested a number of versions of

00:12:07,780 --> 00:12:12,940
this algorithm and eventually decided

00:12:10,000 --> 00:12:16,210
that you know while a kernel worker

00:12:12,940 --> 00:12:19,510
receives control commands so to speak

00:12:16,210 --> 00:12:22,510
from the security solution it creates

00:12:19,510 --> 00:12:24,640
queues for every V CPU the problem being

00:12:22,510 --> 00:12:26,440
that at the time the most of the time

00:12:24,640 --> 00:12:28,690
whatever the security application

00:12:26,440 --> 00:12:31,210
requires from the host requires that the

00:12:28,690 --> 00:12:33,910
current PC PU has the V MCS context

00:12:31,210 --> 00:12:36,990
loaded and there's a little sensitive

00:12:33,910 --> 00:12:39,100
making a locking mechanism there that

00:12:36,990 --> 00:12:43,060
you can either do it from a separate

00:12:39,100 --> 00:12:46,150
thread and qmu thread or you either

00:12:43,060 --> 00:12:47,850
create a queue for every V CPU and

00:12:46,150 --> 00:12:50,310
another complicated task was

00:12:47,850 --> 00:12:53,380
exceptionally well exception injection

00:12:50,310 --> 00:12:56,500
we use this to inject page faults for

00:12:53,380 --> 00:12:58,459
example in side a guest for example when

00:12:56,500 --> 00:13:00,500
we need to

00:12:58,459 --> 00:13:03,019
at a certain piece of code however it's

00:13:00,500 --> 00:13:04,579
being paged out we do we inject a page

00:13:03,019 --> 00:13:07,250
fold and tell the guests tell the guest

00:13:04,579 --> 00:13:09,950
operating system to page it in we have

00:13:07,250 --> 00:13:11,899
hooks on the guest page tables and we

00:13:09,950 --> 00:13:16,130
see when the operating system populates

00:13:11,899 --> 00:13:20,570
the required entry exception injection

00:13:16,130 --> 00:13:22,730
is pretty tricky to get right we

00:13:20,570 --> 00:13:25,750
eventually settled for where we believe

00:13:22,730 --> 00:13:28,610
King a KVM to do all its work all its

00:13:25,750 --> 00:13:30,620
internal bookkeeping cue exceptions cue

00:13:28,610 --> 00:13:33,740
interrupts and at the end right before

00:13:30,620 --> 00:13:36,589
we entered the guest if we want to

00:13:33,740 --> 00:13:38,360
inject an exception we'll look at how

00:13:36,589 --> 00:13:40,640
the V CPU has been configured and if

00:13:38,360 --> 00:13:42,649
there's something pending with all the

00:13:40,640 --> 00:13:43,180
security application no no try again

00:13:42,649 --> 00:13:51,019
later

00:13:43,180 --> 00:13:54,050
and that got it work so regarding

00:13:51,019 --> 00:13:55,850
controlling the apt permissions as I

00:13:54,050 --> 00:13:59,149
said there are various parts on the KPM

00:13:55,850 --> 00:14:01,430
which do their own adjustments to EPT

00:13:59,149 --> 00:14:06,140
depending on what they need we decided

00:14:01,430 --> 00:14:09,649
to use some feature from Intel with a

00:14:06,140 --> 00:14:13,760
page tracking eye Intel uses it for

00:14:09,649 --> 00:14:16,160
virtualized GPUs and we extended it with

00:14:13,760 --> 00:14:18,709
for callbacks right pre-read we write we

00:14:16,160 --> 00:14:21,050
exit creates a lot the first four three

00:14:18,709 --> 00:14:24,709
are for validate for validation right

00:14:21,050 --> 00:14:27,019
before an actual operation takes happens

00:14:24,709 --> 00:14:30,019
inside against we validate and have the

00:14:27,019 --> 00:14:32,269
ability to vero it creates what it's

00:14:30,019 --> 00:14:34,760
simply for allowing us to keep a

00:14:32,269 --> 00:14:36,589
consistent a consistent view of the

00:14:34,760 --> 00:14:40,660
permission security application has said

00:14:36,589 --> 00:14:40,660
every time to remove slots around

00:14:41,769 --> 00:14:48,529
regarding the emulator most of the

00:14:44,660 --> 00:14:50,750
faults or cure occur when the guest does

00:14:48,529 --> 00:14:53,600
simple page table working right the page

00:14:50,750 --> 00:14:55,610
the guest page tables are hooked and the

00:14:53,600 --> 00:14:58,100
hardware every now and then will need to

00:14:55,610 --> 00:15:00,740
adjust the accessed and dirty bits in

00:14:58,100 --> 00:15:03,920
the page tables those events those EPT

00:15:00,740 --> 00:15:05,420
violation right violations are of no

00:15:03,920 --> 00:15:08,329
interest for security applications so

00:15:05,420 --> 00:15:11,500
what we do we use another piece of code

00:15:08,329 --> 00:15:18,250
from KVM to simply emulate the

00:15:11,500 --> 00:15:20,650
Paige walk regarding the memory mapping

00:15:18,250 --> 00:15:22,900
were following some advice from I

00:15:20,650 --> 00:15:27,160
believe he's an if I'm pronouncing his

00:15:22,900 --> 00:15:29,350
name correctly Jerome please a and it's

00:15:27,160 --> 00:15:31,210
still in alpha stage I hope you will be

00:15:29,350 --> 00:15:34,000
able to publish something by the end of

00:15:31,210 --> 00:15:36,790
the year and manage to get case and I'm

00:15:34,000 --> 00:15:43,720
working with it 70 it should be working

00:15:36,790 --> 00:15:45,250
with something else that we're working

00:15:43,720 --> 00:15:48,250
on and have not yet published its

00:15:45,250 --> 00:15:50,350
support for VM funk alternate EPT

00:15:48,250 --> 00:15:53,980
reviews in particular and visualized

00:15:50,350 --> 00:15:57,610
exceptions this allowed us to limit the

00:15:53,980 --> 00:16:01,270
number of VM exits from from the guests

00:15:57,610 --> 00:16:03,730
while introspecting yet another feature

00:16:01,270 --> 00:16:10,710
is sub page protection or sub page

00:16:03,730 --> 00:16:14,410
permissions which allow us to monitor

00:16:10,710 --> 00:16:16,120
areas of data that are not paged or not

00:16:14,410 --> 00:16:19,120
aligned to the page size right are

00:16:16,120 --> 00:16:23,820
smaller 16 bytes or whatever but live

00:16:19,120 --> 00:16:26,200
with code that gets frequently modified

00:16:23,820 --> 00:16:29,560
most of the key of I give you my work

00:16:26,200 --> 00:16:32,410
right now happens in-house we're hoping

00:16:29,560 --> 00:16:34,750
that in early 2020 we'll move everything

00:16:32,410 --> 00:16:38,100
out and have all the development in

00:16:34,750 --> 00:16:39,970
public a few words on aim D support

00:16:38,100 --> 00:16:41,470
currently is not possible to do

00:16:39,970 --> 00:16:43,870
introspection the way we want to there

00:16:41,470 --> 00:16:46,800
is real-time introspection mostly

00:16:43,870 --> 00:16:49,750
because the npt is a normal page table

00:16:46,800 --> 00:16:52,300
it has no support for execute only for

00:16:49,750 --> 00:16:53,830
example which we require sometimes to

00:16:52,300 --> 00:16:57,010
trick certain parts of the Windows

00:16:53,830 --> 00:16:59,620
kernel and mostly if one hooks the guest

00:16:57,010 --> 00:17:02,830
page tables every work of the guest page

00:16:59,620 --> 00:17:05,040
level becomes right violation which

00:17:02,830 --> 00:17:07,449
slows everything down terribly

00:17:05,040 --> 00:17:09,430
there's also make no equivalent for

00:17:07,449 --> 00:17:12,820
DMX's

00:17:09,430 --> 00:17:14,470
monitor trap flag maybe something can be

00:17:12,820 --> 00:17:17,140
contracted out of the native division

00:17:14,470 --> 00:17:21,240
debugging features but we didn't get to

00:17:17,140 --> 00:17:25,390
study it well if anyone from MD has

00:17:21,240 --> 00:17:29,290
advices on how to overcome these more

00:17:25,390 --> 00:17:31,510
than appreciated there's also - in words

00:17:29,290 --> 00:17:34,300
and modifications on the QM side they've

00:17:31,510 --> 00:17:36,130
been published on github we haven't yet

00:17:34,300 --> 00:17:38,530
submitted official patches to the chemo

00:17:36,130 --> 00:17:40,660
mailing list mostly hooks that will tell

00:17:38,530 --> 00:17:43,480
your a security solution went to

00:17:40,660 --> 00:17:45,160
disengage right when the VM is migrated

00:17:43,480 --> 00:17:50,200
to be booted suspended something like

00:17:45,160 --> 00:17:52,540
that the way we tasted every combination

00:17:50,200 --> 00:17:54,280
of operating system out there we're

00:17:52,540 --> 00:17:57,610
talking up close to hundred something

00:17:54,280 --> 00:18:00,430
virtual machines and unit tests for

00:17:57,610 --> 00:18:02,830
every attack techniques supported by the

00:18:00,430 --> 00:18:05,860
HPA technology and we do end-to-end

00:18:02,830 --> 00:18:09,070
tests with most which covers 100% or

00:18:05,860 --> 00:18:12,600
very close to it every cave emi code

00:18:09,070 --> 00:18:15,190
path is being exercised in this manner I

00:18:12,600 --> 00:18:17,350
have a few slides on performance numbers

00:18:15,190 --> 00:18:19,960
I don't know if I still have time so

00:18:17,350 --> 00:18:21,580
there's a comparison with Zen then uses

00:18:19,960 --> 00:18:23,740
what I'll call lightweight different

00:18:21,580 --> 00:18:26,890
channels that is there's a ring buffer

00:18:23,740 --> 00:18:29,560
shared by the hypervisor and guest doing

00:18:26,890 --> 00:18:31,780
into the virtual machine in which the

00:18:29,560 --> 00:18:33,520
security application is running this

00:18:31,780 --> 00:18:36,760
ring buffer is accessible from user

00:18:33,520 --> 00:18:38,770
space it simply reads entries from there

00:18:36,760 --> 00:18:42,250
and then notifies the hypervisor when

00:18:38,770 --> 00:18:46,750
the vcp you can continue operation and

00:18:42,250 --> 00:18:47,890
then then there's KPM which for

00:18:46,750 --> 00:18:52,210
introspection we use a

00:18:47,890 --> 00:18:54,310
vertol on top of it it's Bill we we use

00:18:52,210 --> 00:18:57,550
vhosts v stock which is derived from

00:18:54,310 --> 00:19:00,220
VMware's v start and on top of it

00:18:57,550 --> 00:19:03,550
bsd Sockets Layer everything running in

00:19:00,220 --> 00:19:06,400
user space so that's quite a detour

00:19:03,550 --> 00:19:08,410
taken until messages sent from the

00:19:06,400 --> 00:19:13,180
security application to the kernel to

00:19:08,410 --> 00:19:16,330
the host get there with that in mind the

00:19:13,180 --> 00:19:17,890
performance of the k vm i compared to

00:19:16,330 --> 00:19:21,100
the same version which is what we

00:19:17,890 --> 00:19:22,830
consider to be the mature one is very

00:19:21,100 --> 00:19:24,620
close and this is

00:19:22,830 --> 00:19:28,200
with what we find today in mainline

00:19:24,620 --> 00:19:31,049
there are some V hosts with optimization

00:19:28,200 --> 00:19:33,690
optimizations from Red Hat that bring

00:19:31,049 --> 00:19:37,730
the numbers almost identical very close

00:19:33,690 --> 00:19:39,690
to the Zen ones which is weird again the

00:19:37,730 --> 00:19:44,390
communication channel with the Xen

00:19:39,690 --> 00:19:44,390
hypervisor is very very lightweight and

00:19:44,809 --> 00:19:50,399
the KVM one has a number of layers and

00:19:47,940 --> 00:19:56,279
yet somehow the Linux kernel manages to

00:19:50,399 --> 00:19:57,720
to win it is these are these are some

00:19:56,279 --> 00:20:00,539
numbers with a number with a set of

00:19:57,720 --> 00:20:03,210
Windows virtual machines and simply

00:20:00,539 --> 00:20:06,720
testing every browser in how long it

00:20:03,210 --> 00:20:10,970
takes it to to open a number of legs 20

00:20:06,720 --> 00:20:15,480
30 something like that and these are for

00:20:10,970 --> 00:20:19,260
various linux is actually it's woman to

00:20:15,480 --> 00:20:22,110
1800 for running a unix bench again the

00:20:19,260 --> 00:20:23,340
numbers even without the v v host we

00:20:22,110 --> 00:20:29,010
stock patches the numbers are pretty

00:20:23,340 --> 00:20:34,260
close to zone so hv are running on top

00:20:29,010 --> 00:20:36,389
of k vm using k vm y among the all the

00:20:34,260 --> 00:20:40,679
attacks that it can prevent these are

00:20:36,389 --> 00:20:45,450
the most popular ones i guess everybody

00:20:40,679 --> 00:20:48,720
recognizes at least two of these and i

00:20:45,450 --> 00:20:51,169
have to give a shout out to material for

00:20:48,720 --> 00:20:55,289
working on implementing the

00:20:51,169 --> 00:20:57,960
live via my driver for k vm on top of k

00:20:55,289 --> 00:21:02,419
vm i and a number of really nice

00:20:57,960 --> 00:21:05,990
projects is working on and with this

00:21:02,419 --> 00:21:05,990
severely out of time

00:21:07,310 --> 00:21:18,010
[Applause]

00:21:15,010 --> 00:21:18,010
questions

00:21:30,789 --> 00:21:37,269
so not directly related to KVM but do

00:21:34,869 --> 00:21:41,579
you have any trouble identifying those

00:21:37,269 --> 00:21:44,259
attacks that you can mitigate versus

00:21:41,579 --> 00:21:46,900
so-called benign behavior that is

00:21:44,259 --> 00:21:49,409
exposed by typical DRM software

00:21:46,900 --> 00:21:53,940
[Music]

00:21:49,409 --> 00:21:57,070
well DRM software might look malicious

00:21:53,940 --> 00:21:59,249
definitely yes they use a lot of

00:21:57,070 --> 00:22:02,049
techniques that you would explain

00:21:59,249 --> 00:22:03,609
malware yeah exactly unfortunately

00:22:02,049 --> 00:22:06,579
there's a lot of software out there that

00:22:03,609 --> 00:22:08,440
does really dubious things and

00:22:06,579 --> 00:22:11,349
specifically for that we have an

00:22:08,440 --> 00:22:13,690
exception mechanism that is we first let

00:22:11,349 --> 00:22:17,159
it fail terribly then we look at what we

00:22:13,690 --> 00:22:20,169
try to do to do and create a sort of I

00:22:17,159 --> 00:22:26,519
want to say a signature because the AV

00:22:20,169 --> 00:22:26,519
industry has exploited that death a

00:22:27,749 --> 00:22:33,699
fingerprint if you will that will

00:22:30,579 --> 00:22:36,369
determine okay this is DRM just let it

00:22:33,699 --> 00:22:42,219
do its thing and it's accurate enough

00:22:36,369 --> 00:22:44,399
not to not to let actual malware get

00:22:42,219 --> 00:22:44,399
away

00:22:48,059 --> 00:22:54,640
hey thank you

00:22:51,370 --> 00:23:01,489
[Applause]

00:22:54,640 --> 00:23:01,489

YouTube URL: https://www.youtube.com/watch?v=ErGsCo2mX64


