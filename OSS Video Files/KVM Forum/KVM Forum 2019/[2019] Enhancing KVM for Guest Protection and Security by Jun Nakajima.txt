Title: [2019] Enhancing KVM for Guest Protection and Security by Jun Nakajima
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	We have been working on KVM to better protect and isolate guests, and propose a more secure and yet simpler architecture, where 1) guest memory is isolated from the host except the areas for I/O buffers, 2) no MMIO emulation is used. Since it piggybacks on the Linux systems, KVM tends to have more attack surfaces compared with other VMMs, making the guest more vulnerable. For example, the kernel or QEMU can easily access data of the guests today. Even if we have memory encryption technologies, it’s also easy for them to corrupt data of the guests (accidentally or intentionally) or use potential side channels.

In our architecture, we need to make limited changes to guests, but this provides more protection and simplification, compared with other approaches like XPFO, where the user-level still has access to the entire guest memory. We share our experiences and data based on our PoC.

---

Jun Nakajima
Intel Corp.
Sr. Principal Engineer

Jun Nakajima is a Senior Principal Engineer at the Intel Open Source Technology Center, leading open source virtualization, such as KVM and Xen. Recently Jun worked on various security issues, implementing migitations for KVM. Jun presented a number of times at technical conferences, including KVM Forum, Xen Summit, LinuxCon, OpenStack Summit, and USENIX. He has over 20 years of experience with AI, operating system internals, virtualization, distributed systems, and clouds.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,309 --> 00:00:15,470
my name is Jo Nakashima from Intel I'm

00:00:11,580 --> 00:00:19,680
going to talk about how we can enhance

00:00:15,470 --> 00:00:22,859
kbm for guest protection and security

00:00:19,680 --> 00:00:25,320
you know there are many I think talks

00:00:22,859 --> 00:00:27,840
around security at this time so I think

00:00:25,320 --> 00:00:41,120
this is this should be wonderful I think

00:00:27,840 --> 00:00:44,750
a good topic and so I'll start with

00:00:41,120 --> 00:00:48,510
security implication of a KBM but

00:00:44,750 --> 00:00:52,800
probably many people also pointed out

00:00:48,510 --> 00:00:54,750
some advantage or disadvantage of KVM so

00:00:52,800 --> 00:01:02,070
probably or I just go through quickly

00:00:54,750 --> 00:01:06,180
and then introduce securitisation KBM

00:01:02,070 --> 00:01:09,869
secure in terms of our guests protection

00:01:06,180 --> 00:01:12,180
okay not protecting the hosts okay we

00:01:09,869 --> 00:01:17,100
have agreed the protection technology on

00:01:12,180 --> 00:01:22,350
outside and then depending on who you

00:01:17,100 --> 00:01:25,680
trust or who you don't trust the amount

00:01:22,350 --> 00:01:28,560
of protection the degree of protection

00:01:25,680 --> 00:01:30,659
is different so I'll discuss that kind

00:01:28,560 --> 00:01:33,060
of degree of against protection and what

00:01:30,659 --> 00:01:35,460
we have basically do we have a hardware

00:01:33,060 --> 00:01:37,820
support or not and then depending on the

00:01:35,460 --> 00:01:40,439
availability of our hardware software

00:01:37,820 --> 00:01:45,200
the degree of a guest protection is

00:01:40,439 --> 00:01:47,850
different Nano or just to talk about

00:01:45,200 --> 00:01:50,549
where we are you know the proof of a

00:01:47,850 --> 00:01:52,909
concept POC and then discuss the next

00:01:50,549 --> 00:01:52,909
step

00:01:55,130 --> 00:02:02,840
so as many people pointed out there are

00:01:59,580 --> 00:02:06,630
some security implications of KBM

00:02:02,840 --> 00:02:12,750
because the fact the KBM is a type 2

00:02:06,630 --> 00:02:18,120
it's or hosted v mm okay so k BN depends

00:02:12,750 --> 00:02:21,870
on host to linux in various ways right

00:02:18,120 --> 00:02:25,410
and a lot of the dependencies that's

00:02:21,870 --> 00:02:28,500
good and bad good thing is we can

00:02:25,410 --> 00:02:30,660
implement a KBM you know very

00:02:28,500 --> 00:02:34,950
efficiently right we don't need to write

00:02:30,660 --> 00:02:41,760
the code we just use a you know Linux in

00:02:34,950 --> 00:02:45,060
office and but Linux is general

00:02:41,760 --> 00:02:49,850
operating system and as such it tends to

00:02:45,060 --> 00:02:53,970
have a more attack surfaces right so

00:02:49,850 --> 00:02:58,739
that would sometimes made even the guest

00:02:53,970 --> 00:03:04,530
more exposed or barnable and that's the

00:02:58,739 --> 00:03:09,810
kind of downside and also Mauritius

00:03:04,530 --> 00:03:13,410
guest may be able to use user space vmm

00:03:09,810 --> 00:03:17,640
to attack the host or the other guest

00:03:13,410 --> 00:03:20,910
okay the other thing is if you look at

00:03:17,640 --> 00:03:23,730
the KVL imprimatur architecture we have

00:03:20,910 --> 00:03:27,510
a user space vmm you know typically will

00:03:23,730 --> 00:03:30,959
use aq mu and this morning I think

00:03:27,510 --> 00:03:33,660
Parador discussed q and then many people

00:03:30,959 --> 00:03:39,600
are concerned about the size of q mu or

00:03:33,660 --> 00:03:43,739
some security issue with the q mu but q

00:03:39,600 --> 00:03:46,320
mu has basically owns that guest the

00:03:43,739 --> 00:03:49,530
memory right so he can take a look look

00:03:46,320 --> 00:03:54,359
at anyone in the last memory right

00:03:49,530 --> 00:03:56,780
and also he can get registered state of

00:03:54,359 --> 00:03:56,780
the guest

00:03:57,090 --> 00:04:03,930
and then if you look at the rest of the

00:04:01,380 --> 00:04:09,090
kernel the kernel guys can the kernel

00:04:03,930 --> 00:04:12,990
components can access any guest memory

00:04:09,090 --> 00:04:16,109
or any be CPU State so those are kind of

00:04:12,990 --> 00:04:22,820
security implication of kbm so that's

00:04:16,109 --> 00:04:27,710
kind of a motivation what I want to

00:04:22,820 --> 00:04:31,620
introduce proposed securitisation KBM

00:04:27,710 --> 00:04:35,780
it's inspired by memory protection

00:04:31,620 --> 00:04:39,419
technologies such as like I am the SCV

00:04:35,780 --> 00:04:43,440
probably Intel's MK tme and that the

00:04:39,419 --> 00:04:44,790
goal is to protect the BMS from benign

00:04:43,440 --> 00:04:50,250
and vulnerable

00:04:44,790 --> 00:04:54,060
PMS okay and then the grievable

00:04:50,250 --> 00:04:59,510
protection really depends on what kind

00:04:54,060 --> 00:05:05,400
of security attacks we expect right and

00:04:59,510 --> 00:05:08,130
as we stopped trusting the components in

00:05:05,400 --> 00:05:11,940
this case for example user space be mm Q

00:05:08,130 --> 00:05:16,110
mu or kernel hypervisor the attack

00:05:11,940 --> 00:05:18,750
surface will glow right and what we need

00:05:16,110 --> 00:05:21,690
to do will also change and we probably

00:05:18,750 --> 00:05:26,970
need to do more as we stopped trusting

00:05:21,690 --> 00:05:33,030
them okay so I'll discuss in the next so

00:05:26,970 --> 00:05:36,660
like I said as we stopped trusting we

00:05:33,030 --> 00:05:41,070
need to do more things for example the

00:05:36,660 --> 00:05:47,220
user space v mm like Q mu if we don't

00:05:41,070 --> 00:05:52,789
trust then probably it's good to deny

00:05:47,220 --> 00:05:57,720
access to the guest register state and

00:05:52,789 --> 00:05:59,580
also deny access to guess the private

00:05:57,720 --> 00:06:01,560
memory I'll talk about the private

00:05:59,580 --> 00:06:06,750
memory that what's a private really

00:06:01,560 --> 00:06:09,730
means on this page guess the memory I'm

00:06:06,750 --> 00:06:13,570
talking about what the private means

00:06:09,730 --> 00:06:17,350
the guests memory is private by default

00:06:13,570 --> 00:06:21,120
okay so at the boot time all guests

00:06:17,350 --> 00:06:27,090
memory is private and unless guess

00:06:21,120 --> 00:06:33,550
explicitly tells certain pages GPA are

00:06:27,090 --> 00:06:36,880
shared they stay as private memory so if

00:06:33,550 --> 00:06:42,300
we don't trust user space V mmm it's

00:06:36,880 --> 00:06:46,930
good to remove the translation from the

00:06:42,300 --> 00:06:50,920
qmu our user space Bamm until the guest

00:06:46,930 --> 00:06:54,550
is okay with share sharing with up those

00:06:50,920 --> 00:06:57,520
pages now how about the kernel if we

00:06:54,550 --> 00:07:02,560
want to remove the kernel some kernel

00:06:57,520 --> 00:07:07,540
component from TCB then one thing we

00:07:02,560 --> 00:07:11,890
need to do is remove that the private

00:07:07,540 --> 00:07:15,160
memory from direct mapping but that's

00:07:11,890 --> 00:07:19,750
not actually sufficient because kernel

00:07:15,160 --> 00:07:22,450
can sum if it's bad guy he can you know

00:07:19,750 --> 00:07:25,210
construct a page table to point to the

00:07:22,450 --> 00:07:28,600
the physical memory right that we are

00:07:25,210 --> 00:07:34,990
the primary memory is so we need to have

00:07:28,600 --> 00:07:37,840
some way to deny access to the you know

00:07:34,990 --> 00:07:43,480
guess the private memory I'll talk about

00:07:37,840 --> 00:07:51,010
that if I have a time but you know so

00:07:43,480 --> 00:07:54,960
let's see and then if we also if we

00:07:51,010 --> 00:07:57,280
don't trust KVM hypervisor then we need

00:07:54,960 --> 00:08:00,340
you know basically we don't trust us

00:07:57,280 --> 00:08:03,660
soft at all means we need hard air

00:08:00,340 --> 00:08:03,660
technology okay

00:08:05,460 --> 00:08:16,300
so this picture summarizes that the

00:08:13,390 --> 00:08:23,170
secure virtualization for KBM like I

00:08:16,300 --> 00:08:27,430
said the guest memory is ply bait at the

00:08:23,170 --> 00:08:32,010
boot time by their port and guest needs

00:08:27,430 --> 00:08:34,420
to specify which pages are shared

00:08:32,010 --> 00:08:39,040
explicitly okay

00:08:34,420 --> 00:08:42,400
and cue em you can just access share

00:08:39,040 --> 00:08:43,060
memory I think this picture looks

00:08:42,400 --> 00:08:45,670
familiar

00:08:43,060 --> 00:08:50,020
I think to you if you didn't probably

00:08:45,670 --> 00:08:52,840
know about how the AMD SE be supported

00:08:50,020 --> 00:08:56,410
they also need to do this counting and

00:08:52,840 --> 00:08:57,490
that's a reason I said I was inspired by

00:08:56,410 --> 00:09:01,600
memory you know

00:08:57,490 --> 00:09:03,820
encryption technology okay and but this

00:09:01,600 --> 00:09:07,720
is at this point it's we are doing this

00:09:03,820 --> 00:09:13,330
in software okay we don't need hard up

00:09:07,720 --> 00:09:17,230
to this point and kbn if the KBM is the

00:09:13,330 --> 00:09:22,560
TCB it can access the PI memory but only

00:09:17,230 --> 00:09:25,180
KBM I have a way to you know deny access

00:09:22,560 --> 00:09:30,550
from the other component in the kernel

00:09:25,180 --> 00:09:34,540
okay and like I said this one works well

00:09:30,550 --> 00:09:36,880
even we have not not even when we have a

00:09:34,540 --> 00:09:40,110
hardware technology you know encryption

00:09:36,880 --> 00:09:43,750
technology so pride by memory basically

00:09:40,110 --> 00:09:46,360
corresponding responds to the encrypted

00:09:43,750 --> 00:09:51,160
memory if we have memory encryption

00:09:46,360 --> 00:09:56,520
technology okay and then KBM denies

00:09:51,160 --> 00:10:03,400
access to get be CPU state if you know

00:09:56,520 --> 00:10:07,060
the user space is TCP and I think that's

00:10:03,400 --> 00:10:10,830
kind of baseline basically for secure

00:10:07,060 --> 00:10:16,290
virtualization we don't want assume that

00:10:10,830 --> 00:10:16,290
user space bmm is in TCP

00:10:18,760 --> 00:10:28,160
now Vegas EVMs actually in fact donjuan

00:10:25,300 --> 00:10:30,709
insecure virtualization we need to have

00:10:28,160 --> 00:10:37,510
a PB you know indictment in the guests

00:10:30,709 --> 00:10:43,010
okay but fortunately we kind of have

00:10:37,510 --> 00:10:46,640
these enlightenment already thanks to

00:10:43,010 --> 00:10:50,750
the you know the mdac be support because

00:10:46,640 --> 00:10:54,980
they need to do this anyway so one thing

00:10:50,750 --> 00:10:57,410
we need to do is the you know the guests

00:10:54,980 --> 00:11:01,880
and then the holes need to share the

00:10:57,410 --> 00:11:05,120
area for IO okay and for that the guest

00:11:01,880 --> 00:11:07,190
needs to tell which are shared okay so

00:11:05,120 --> 00:11:10,820
for example bounce before guests needs

00:11:07,190 --> 00:11:15,649
to tell there are a couple ways to

00:11:10,820 --> 00:11:18,980
communicate but if you trust the trust

00:11:15,649 --> 00:11:24,290
the KBL probably you can use hyper call

00:11:18,980 --> 00:11:27,230
okay but if the T kbm is not in the TCB

00:11:24,290 --> 00:11:30,649
then you need to use hardware for

00:11:27,230 --> 00:11:33,260
example use a guest page tables set some

00:11:30,649 --> 00:11:35,440
bit or you know some something like that

00:11:33,260 --> 00:11:43,790
right

00:11:35,440 --> 00:11:51,620
and if KBM is now in TCP in this case we

00:11:43,790 --> 00:11:56,000
need a harder support like MD SAV and in

00:11:51,620 --> 00:11:58,699
this case KVM cannot access private you

00:11:56,000 --> 00:12:01,130
know even he tried to access is nothing

00:11:58,699 --> 00:12:08,570
there right he cannot read anything he

00:12:01,130 --> 00:12:11,959
can read but old junk and if he writes

00:12:08,570 --> 00:12:14,300
something that can craft a guest so if

00:12:11,959 --> 00:12:18,110
we have hardware technology data

00:12:14,300 --> 00:12:22,279
encryption technology if KBM can access

00:12:18,110 --> 00:12:23,570
and write to that private memory that

00:12:22,279 --> 00:12:27,670
can crop the guest

00:12:23,570 --> 00:12:31,640
it means encrypted the guest memory so

00:12:27,670 --> 00:12:40,190
in any case I think it's good practice

00:12:31,640 --> 00:12:48,589
for KBM not to look at the guest private

00:12:40,190 --> 00:12:51,949
memory even kbm is in TCB okay so these

00:12:48,589 --> 00:12:55,910
are the additional PP operation so

00:12:51,949 --> 00:13:00,230
because KBM cannot take a look at it

00:12:55,910 --> 00:13:03,440
cannot Amy rate iommu also I'm mio

00:13:00,230 --> 00:13:07,610
operations so we need to replace those

00:13:03,440 --> 00:13:10,730
ways for example hyper code or the guest

00:13:07,610 --> 00:13:14,120
needs to get some notification exception

00:13:10,730 --> 00:13:18,470
to handle internal emulator internally

00:13:14,120 --> 00:13:21,230
and then there's some hyper core or

00:13:18,470 --> 00:13:24,860
something that's kind of a modification

00:13:21,230 --> 00:13:31,430
we need and then again those are kind of

00:13:24,860 --> 00:13:35,709
already done I believe because of a you

00:13:31,430 --> 00:13:35,709
know SAV support okay

00:13:40,579 --> 00:13:53,310
now we we have POC and we needed to

00:13:47,820 --> 00:13:57,839
modify KBM and QM you and I don't talk

00:13:53,310 --> 00:14:02,940
about how we did but this was covered by

00:13:57,839 --> 00:14:05,970
the previous presentation basically what

00:14:02,940 --> 00:14:09,300
we did was removed translation from QM

00:14:05,970 --> 00:14:13,620
you write for the private side and then

00:14:09,300 --> 00:14:17,040
also remove that whose private memory

00:14:13,620 --> 00:14:22,560
from direct memory direct mapping okay

00:14:17,040 --> 00:14:26,459
okay expiry for kind of stuff and we

00:14:22,560 --> 00:14:29,040
also measured that overhead from a

00:14:26,459 --> 00:14:35,399
bounce buffer because we need to copy

00:14:29,040 --> 00:14:42,690
between a bounce buffer so I think those

00:14:35,399 --> 00:14:46,649
are almost kind of a negligible the

00:14:42,690 --> 00:14:49,649
network side the send when you send you

00:14:46,649 --> 00:14:52,500
need to copy your data to the bounce

00:14:49,649 --> 00:14:57,720
buffer so you have to have an extra copy

00:14:52,500 --> 00:15:00,420
okay for when you receive packets you

00:14:57,720 --> 00:15:02,459
can kind of void because the packets is

00:15:00,420 --> 00:15:05,660
already there in the show that's

00:15:02,459 --> 00:15:09,420
possible for so I think you can avoid

00:15:05,660 --> 00:15:13,100
copying for receiving case but this is

00:15:09,420 --> 00:15:16,880
still preliminary data and we can

00:15:13,100 --> 00:15:22,949
improve more so I have a five minutes so

00:15:16,880 --> 00:15:25,860
I can go quickly about this one this is

00:15:22,949 --> 00:15:27,510
what how we can deny access that guess

00:15:25,860 --> 00:15:31,230
the private memory access of body

00:15:27,510 --> 00:15:33,510
colonel I I talked about the

00:15:31,230 --> 00:15:36,410
virtualization based harding so what we

00:15:33,510 --> 00:15:40,199
can do is actually what we're doing is

00:15:36,410 --> 00:15:43,500
we deeply rich the VM of mineral kernel

00:15:40,199 --> 00:15:46,920
then have a three hypervisors it's

00:15:43,500 --> 00:15:51,420
called a vvh so while the kernel of KBM

00:15:46,920 --> 00:15:53,290
is running and we can run the VMS then

00:15:51,420 --> 00:16:00,190
once we get out of

00:15:53,290 --> 00:16:02,949
the KPM mojo then the colonel is gonna

00:16:00,190 --> 00:16:05,800
start running the guest mode then we can

00:16:02,949 --> 00:16:11,670
use the EPT to restrict the memory

00:16:05,800 --> 00:16:17,639
access okay that's what we have this way

00:16:11,670 --> 00:16:19,600
you know we can kind of a make kbm as a

00:16:17,639 --> 00:16:24,160
hypervisor okay

00:16:19,600 --> 00:16:27,670
your hypervisor so this is also kind of

00:16:24,160 --> 00:16:31,089
a research topic but we are working with

00:16:27,670 --> 00:16:35,620
this one but so if you look at this

00:16:31,089 --> 00:16:39,040
picture just to change that you know the

00:16:35,620 --> 00:16:43,389
shape actually if we do this and emerge

00:16:39,040 --> 00:16:46,269
that the vvh and the KBM then we can

00:16:43,389 --> 00:16:49,240
have kind of a real hypervisor then that

00:16:46,269 --> 00:16:51,930
can actually deeply bridge the linux and

00:16:49,240 --> 00:16:57,930
then we can have extra additional

00:16:51,930 --> 00:17:01,180
protection okay then we can have more

00:16:57,930 --> 00:17:09,250
situation protection or guest okay so

00:17:01,180 --> 00:17:12,040
this is the kind of research topic so as

00:17:09,250 --> 00:17:15,400
I said we have some POC and the next

00:17:12,040 --> 00:17:20,770
step we need to complete and then share

00:17:15,400 --> 00:17:25,150
the patches in the community and about a

00:17:20,770 --> 00:17:28,569
modification to the guest like I said

00:17:25,150 --> 00:17:31,120
mdac be support is already there and we

00:17:28,569 --> 00:17:37,960
if we change a little bit I think we can

00:17:31,120 --> 00:17:40,270
cover this case as well okay and we are

00:17:37,960 --> 00:17:43,059
working on how to remove the mapping

00:17:40,270 --> 00:17:47,380
from against memory mapping from user

00:17:43,059 --> 00:17:51,549
space so that's also ongoing I have some

00:17:47,380 --> 00:17:53,280
proposal in backup and then also the do

00:17:51,549 --> 00:17:57,950
POC over that

00:17:53,280 --> 00:18:02,730
making type 1 hypervisor from KBL so

00:17:57,950 --> 00:18:06,170
that's that with this I think I'll want

00:18:02,730 --> 00:18:06,170
to take questions

00:18:19,480 --> 00:18:25,780
so sort of the classic question for all

00:18:22,090 --> 00:18:27,910
these trusted execution thing uses do

00:18:25,780 --> 00:18:28,960
you support or like do you plan or are

00:18:27,910 --> 00:18:31,660
you interested in supporting something

00:18:28,960 --> 00:18:33,490
like quoting sealing attestation stuff

00:18:31,660 --> 00:18:37,720
in general and would you put that into

00:18:33,490 --> 00:18:38,860
the Linux kernel or like it seems not

00:18:37,720 --> 00:18:40,600
like the best place to be do I don't

00:18:38,860 --> 00:18:48,490
know maybe dick who's already there but

00:18:40,600 --> 00:18:53,550
I think at the station is at this point

00:18:48,490 --> 00:18:53,550
outside scope of this one at this point

00:18:56,190 --> 00:19:04,270
you know it's it's a lot of luck to you

00:19:00,820 --> 00:19:06,670
know you need about this station so yeah

00:19:04,270 --> 00:19:09,970
it just it seems like if no one knows

00:19:06,670 --> 00:19:11,560
that you're doing it then anyway we can

00:19:09,970 --> 00:19:13,720
talk about this afterwards even you have

00:19:11,560 --> 00:19:17,730
a hardware support it's you know still

00:19:13,720 --> 00:19:17,730
you need to do many things right

00:19:27,570 --> 00:19:32,980
hi - so it's training performance

00:19:30,190 --> 00:19:37,539
numbers and regarding to the like

00:19:32,980 --> 00:19:44,620
network delay or Pandu is rather than

00:19:37,539 --> 00:19:46,559
the CPU usage thank you that question

00:19:44,620 --> 00:19:49,090
were

00:19:46,559 --> 00:19:52,720
so is there any number of the

00:19:49,090 --> 00:19:55,750
performance side of like vert I'll not

00:19:52,720 --> 00:19:58,659
PCI after you start to switch to

00:19:55,750 --> 00:20:02,399
software out here B yeah okay you're

00:19:58,659 --> 00:20:07,740
talking about the one we measure was the

00:20:02,399 --> 00:20:07,740
CPU kind of overhead you - zation

00:20:08,669 --> 00:20:16,419
performance why I think we saw the

00:20:12,340 --> 00:20:18,370
situation in network if you use right

00:20:16,419 --> 00:20:22,629
now I think we use a four degree or

00:20:18,370 --> 00:20:25,980
something like that but much higher mini

00:20:22,629 --> 00:20:31,539
fast ethernet we may see some

00:20:25,980 --> 00:20:36,879
performance drop but the throughput wise

00:20:31,539 --> 00:20:40,830
to me it's same we just need you know

00:20:36,879 --> 00:20:40,830
you just need extra copy basically

00:20:49,330 --> 00:20:55,960
okay so thank you

00:20:51,950 --> 00:21:02,819
[Applause]

00:20:55,960 --> 00:21:02,819

YouTube URL: https://www.youtube.com/watch?v=t6k7Ne1cboQ


