Title: [2019] Seamless Cloud System Upgrade with VMM Fast Restart by Jason Zeng
Publication date: 2019-11-09
Playlist: KVM Forum 2019
Description: 
	Frequent updates (software and firmware) become a major pain point to Cloud Service Providers. There have been some approaches to address this, for example hot patching, live migration, etc., but there still have some limitations for each of them. VMM fast restart tries to propose an alternative solution, which leverages kexec-based fast rebooting of host machine while keeping VM states in memory across reboot, to achieve short service downtime, high success rate and low management overhead.

This talk will introduce the technical approaches, current status of development, and future plans of VMM fast restart. Related challenges will also be described in this talk.

---

Jason Zeng
Intel
Software Engineer

I am now working for Intel Corp., currently focusing on KVM/Virtualization related projects. I have only internal speaking experiences, don't have previous public speaking experiences.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,099 --> 00:00:15,900
hello everyone thanks for coming I'm

00:00:12,269 --> 00:00:19,830
Jason from Intel Corporation very glad

00:00:15,900 --> 00:00:24,449
to have this sharing to introduce my

00:00:19,830 --> 00:00:29,010
team of teams work today this topic is

00:00:24,449 --> 00:00:32,960
about an approach to system upgrade we

00:00:29,010 --> 00:00:38,910
hope it can benefit some usage scenarios

00:00:32,960 --> 00:00:42,210
especially for cloud vendors when we

00:00:38,910 --> 00:00:44,660
talk about the system upgrade we faces

00:00:42,210 --> 00:00:49,020
some headaches the first one is that

00:00:44,660 --> 00:00:52,920
nowadays we are seeing more and more

00:00:49,020 --> 00:00:55,770
frequent security fixes those secretive

00:00:52,920 --> 00:00:58,609
security fixes are not coming from the

00:00:55,770 --> 00:01:01,770
other side it can also come from

00:00:58,609 --> 00:01:05,159
firmware microcode and other parts of

00:01:01,770 --> 00:01:08,580
the system so we have to do more

00:01:05,159 --> 00:01:13,170
frequent system upgrades nowadays and

00:01:08,580 --> 00:01:17,369
another issue is that usually there's

00:01:13,170 --> 00:01:20,700
just an amputee Maps system reboot and

00:01:17,369 --> 00:01:24,540
the reboot has a pretty long time to

00:01:20,700 --> 00:01:28,380
finish so as a consequence the cloud

00:01:24,540 --> 00:01:32,400
vendor sees more service downtown to

00:01:28,380 --> 00:01:35,430
their customers of course we already

00:01:32,400 --> 00:01:37,770
have some mitigation solutions one is

00:01:35,430 --> 00:01:40,590
the live patching the other one is the

00:01:37,770 --> 00:01:43,619
VM line migration they all have their

00:01:40,590 --> 00:01:47,070
advantages but also they have their

00:01:43,619 --> 00:01:49,049
limitations for life patching it is good

00:01:47,070 --> 00:01:52,710
for small fixes because there was no

00:01:49,049 --> 00:01:55,170
service downtime but when the changes

00:01:52,710 --> 00:01:58,799
are becoming bigger then the failure

00:01:55,170 --> 00:02:01,710
rate are becoming high for live

00:01:58,799 --> 00:02:04,619
migration it is a major feature in most

00:02:01,710 --> 00:02:06,890
hypervisors I think and it typically has

00:02:04,619 --> 00:02:09,599
in less than one second service downtime

00:02:06,890 --> 00:02:13,050
but it also has limitations for example

00:02:09,599 --> 00:02:13,620
it does not support personal device very

00:02:13,050 --> 00:02:17,069
well

00:02:13,620 --> 00:02:21,599
and it is not very friendly to memory

00:02:17,069 --> 00:02:25,019
intensive workloads beside this it also

00:02:21,599 --> 00:02:28,950
requires space machine to migrate the VM

00:02:25,019 --> 00:02:31,319
into also lie migration will involve

00:02:28,950 --> 00:02:34,620
some infrastructure configuration

00:02:31,319 --> 00:02:37,349
changes because we have to migrate VM to

00:02:34,620 --> 00:02:40,230
another machine so the infrastructure

00:02:37,349 --> 00:02:42,510
changes the networking for example the

00:02:40,230 --> 00:02:49,760
network configuration change may impose

00:02:42,510 --> 00:02:53,190
some failure cases so we have another

00:02:49,760 --> 00:02:56,459
approach with just another approach we

00:02:53,190 --> 00:03:00,090
name it we mmm fast restart the main

00:02:56,459 --> 00:03:03,030
idea is to leverage KX a reboot to

00:03:00,090 --> 00:03:07,879
bypass firmware both phase which will

00:03:03,030 --> 00:03:11,220
make the report very fast and also we

00:03:07,879 --> 00:03:15,450
try to put the guest state that gets the

00:03:11,220 --> 00:03:18,600
memory totally in the in in a system

00:03:15,450 --> 00:03:22,079
memory because K accept reboot does not

00:03:18,600 --> 00:03:25,560
power cycle the machine so after the KX

00:03:22,079 --> 00:03:28,170
second reboot the guest have we a memory

00:03:25,560 --> 00:03:32,989
state are still there we can just pick

00:03:28,170 --> 00:03:38,370
up the memory State we also want to

00:03:32,989 --> 00:03:41,730
support personal devices so the main

00:03:38,370 --> 00:03:44,130
goal is to to make sure the possible

00:03:41,730 --> 00:03:50,540
devices still working during the K exit

00:03:44,130 --> 00:03:55,079
and we both so keeping them working

00:03:50,540 --> 00:04:00,389
means that we will need to keep the DMA

00:03:55,079 --> 00:04:10,109
our queue and such things also alive so

00:04:00,389 --> 00:04:13,620
we want to keep the DMA and irq hardware

00:04:10,109 --> 00:04:17,760
resources in intact during the K xx

00:04:13,620 --> 00:04:20,190
reboot and after the K X that reboot the

00:04:17,760 --> 00:04:23,300
new kernel will put up and then pick up

00:04:20,190 --> 00:04:25,600
the hardware DMA and an RQ

00:04:23,300 --> 00:04:27,610
configurations so that the

00:04:25,600 --> 00:04:33,250
the resume to be and can can run

00:04:27,610 --> 00:04:37,720
continuously so we hope this is a new

00:04:33,250 --> 00:04:40,650
option for some use scenarios especially

00:04:37,720 --> 00:04:45,940
for for the case that only OS and

00:04:40,650 --> 00:04:49,690
advisor upgrade is only needed if the

00:04:45,940 --> 00:04:51,700
firmware or microcode also need to be

00:04:49,690 --> 00:04:55,480
upgraded then that would be another

00:04:51,700 --> 00:04:58,030
story so we expect this approach will

00:04:55,480 --> 00:05:01,330
have some benefits the first one is that

00:04:58,030 --> 00:05:04,650
because we do have a reboot so we expect

00:05:01,330 --> 00:05:07,390
it will have a higher success rate than

00:05:04,650 --> 00:05:11,410
previous approaches especially like per

00:05:07,390 --> 00:05:15,310
chip and we also want to have less

00:05:11,410 --> 00:05:16,930
impact to the guest OS although we will

00:05:15,310 --> 00:05:21,430
have because we have rebooted the

00:05:16,930 --> 00:05:23,710
Machine we we may have some relatively

00:05:21,430 --> 00:05:27,970
longer some time that the previous

00:05:23,710 --> 00:05:34,390
approaches and most importantly we want

00:05:27,970 --> 00:05:36,700
to support possible devices so let's

00:05:34,390 --> 00:05:39,640
dive into the technical details a little

00:05:36,700 --> 00:05:44,170
bit more the first question is how we

00:05:39,640 --> 00:05:47,700
put the guest VM state in memory the the

00:05:44,170 --> 00:05:49,270
basic idea is to reserve most of the

00:05:47,700 --> 00:05:52,900
hosts

00:05:49,270 --> 00:05:57,070
diva memory and then make it to be

00:05:52,900 --> 00:06:00,960
emulated as a persistent memory the RAM

00:05:57,070 --> 00:06:03,580
emulate to P man is up streaming feature

00:06:00,960 --> 00:06:06,250
so the code is already there there was

00:06:03,580 --> 00:06:11,160
no change there was no need to change it

00:06:06,250 --> 00:06:15,420
the Linux and also after we reserved the

00:06:11,160 --> 00:06:18,700
persistent memory we make it to be

00:06:15,420 --> 00:06:21,810
passive the memory block device and then

00:06:18,700 --> 00:06:26,740
break create AB file system on the

00:06:21,810 --> 00:06:30,790
possessor memory and we also mount it in

00:06:26,740 --> 00:06:35,110
EAX mode so that when we launch qumu

00:06:30,790 --> 00:06:38,110
when we run the guest VM we run it in

00:06:35,110 --> 00:06:38,930
place in the persistent memory so there

00:06:38,110 --> 00:06:46,009
will be no

00:06:38,930 --> 00:06:49,460
cash and fetch cash evolved so when save

00:06:46,009 --> 00:06:54,410
and restore the VM there is no need to

00:06:49,460 --> 00:06:58,820
copy the guest a memory from memory to

00:06:54,410 --> 00:07:02,210
the file system so in this way we have a

00:06:58,820 --> 00:07:05,900
simplified memory model there's no need

00:07:02,210 --> 00:07:11,000
to modify the Linux memory management

00:07:05,900 --> 00:07:13,130
subsystem and naturally because the KX

00:07:11,000 --> 00:07:16,280
that reboot does not power cycle this

00:07:13,130 --> 00:07:20,919
fashion the the persistent attribute

00:07:16,280 --> 00:07:29,330
makes the VM state stay in memory after

00:07:20,919 --> 00:07:32,330
reboot so another issue is how do we

00:07:29,330 --> 00:07:36,940
save and reloading the VM state across

00:07:32,330 --> 00:07:40,520
before the people and after we vote we

00:07:36,940 --> 00:07:44,539
leverage the reception mechanism from

00:07:40,520 --> 00:07:48,080
human basically we customize the safe we

00:07:44,539 --> 00:07:52,820
M and loudly and comment or option from

00:07:48,080 --> 00:07:55,849
the q2 to achieve an optimal Easter or

00:07:52,820 --> 00:08:00,050
special snapshot because we have been

00:07:55,849 --> 00:08:03,260
running the qumu in text file system in

00:08:00,050 --> 00:08:06,380
place so we don't need to copy the guest

00:08:03,260 --> 00:08:10,060
memory to the disk snapshot we just keep

00:08:06,380 --> 00:08:14,360
it in the memory for non memory state

00:08:10,060 --> 00:08:18,169
they can be either in disk snapshot or

00:08:14,360 --> 00:08:23,419
just in memory the storage is special we

00:08:18,169 --> 00:08:26,960
just flush flush it before we stop at

00:08:23,419 --> 00:08:31,190
the wheel so when we launch in queue we

00:08:26,960 --> 00:08:33,890
will pick up the guest a memory from the

00:08:31,190 --> 00:08:38,919
text file system directory and pre map

00:08:33,890 --> 00:08:46,040
it into the queue and relaunch the guest

00:08:38,919 --> 00:08:49,070
so saving and reloading involves K

00:08:46,040 --> 00:08:51,040
accept report in between so we have to

00:08:49,070 --> 00:08:53,019
pass the information where

00:08:51,040 --> 00:08:56,529
we put where we have reserved the

00:08:53,019 --> 00:08:58,889
dierent memory for the guests and such

00:08:56,529 --> 00:09:03,519
information to the new colonel after

00:08:58,889 --> 00:09:07,209
exit we use the same memory map Linux

00:09:03,519 --> 00:09:09,310
kernel parameter between to pass such

00:09:07,209 --> 00:09:15,310
information from out cannot to the new

00:09:09,310 --> 00:09:18,310
kernel and the past root device support

00:09:15,310 --> 00:09:23,259
we think it it is the most challenging

00:09:18,310 --> 00:09:26,589
part from our view the main goal one of

00:09:23,259 --> 00:09:30,310
the main goal of our approach is to is

00:09:26,589 --> 00:09:33,790
to keep to support the personal device

00:09:30,310 --> 00:09:36,459
but as we know there are bad news and

00:09:33,790 --> 00:09:39,730
good news for passive devices the bad

00:09:36,459 --> 00:09:42,310
news is that from hosts aside we don't

00:09:39,730 --> 00:09:45,550
have much control on the device hardware

00:09:42,310 --> 00:09:49,870
state because it is managed by the guest

00:09:45,550 --> 00:09:52,959
VM driver for the personal devices so it

00:09:49,870 --> 00:09:56,730
is hard for the host to do suspend and

00:09:52,959 --> 00:10:01,569
resume of the device personal device

00:09:56,730 --> 00:10:05,500
without hardware support the good news

00:10:01,569 --> 00:10:13,810
is that unlike live migration we don't

00:10:05,500 --> 00:10:17,139
move the VM to to another machine so we

00:10:13,810 --> 00:10:19,980
don't need move the we don't need to

00:10:17,139 --> 00:10:23,769
save the hardware state machine or

00:10:19,980 --> 00:10:25,990
hardware device hardware state from one

00:10:23,769 --> 00:10:28,149
machine to another machine and restore

00:10:25,990 --> 00:10:33,220
it because we are running on the same

00:10:28,149 --> 00:10:35,829
host so we don't need to have hardware

00:10:33,220 --> 00:10:39,430
support for the device state and we also

00:10:35,829 --> 00:10:45,480
don't need to to have the 30 pay

00:10:39,430 --> 00:10:50,589
checking from the possible devices so

00:10:45,480 --> 00:10:54,160
naturally we we are we are taking the

00:10:50,589 --> 00:10:59,680
approach that just keep the personal

00:10:54,160 --> 00:11:03,709
device alive during the K accept report

00:10:59,680 --> 00:11:06,410
so because the exit report well well

00:11:03,709 --> 00:11:09,560
enough the the new kernel boot up and

00:11:06,410 --> 00:11:14,510
new kernel well Aria numeral eight the

00:11:09,560 --> 00:11:18,950
device and well reinitialize the devices

00:11:14,510 --> 00:11:22,040
so if we want to keep the device alive

00:11:18,950 --> 00:11:23,600
then we will need to avoid clobbering

00:11:22,040 --> 00:11:28,190
the hardware side of the personal

00:11:23,600 --> 00:11:31,310
devices and also we want to keep life

00:11:28,190 --> 00:11:34,029
that passive devices we also need to

00:11:31,310 --> 00:11:36,670
keep the upstream devices of the

00:11:34,029 --> 00:11:40,760
possibility of Isis alive including

00:11:36,670 --> 00:11:46,579
iommu and these are ye switch or Road

00:11:40,760 --> 00:11:48,800
ports etc after we put then the software

00:11:46,579 --> 00:11:53,540
side we'll need to pick up all the

00:11:48,800 --> 00:12:01,339
hardware configurations and then resume

00:11:53,540 --> 00:12:05,149
that be n so for interrupt there's a

00:12:01,339 --> 00:12:08,300
issue in West a interrupt because when

00:12:05,149 --> 00:12:11,390
we do a exit reboot the CPUs are

00:12:08,300 --> 00:12:15,190
undergoing the reboot they are not

00:12:11,390 --> 00:12:20,060
available to respond to the IR cues that

00:12:15,190 --> 00:12:22,790
check out from the IMU or personal

00:12:20,060 --> 00:12:27,370
devices so the approach we take is to

00:12:22,790 --> 00:12:31,120
leverage the posted interrupt mechanism

00:12:27,370 --> 00:12:33,680
the basic idea is that there is a

00:12:31,120 --> 00:12:37,550
suppression notification bit in the

00:12:33,680 --> 00:12:42,199
posting interrupt a descriptor was this

00:12:37,550 --> 00:12:47,209
bit set then the iommu will not send a

00:12:42,199 --> 00:12:49,279
notification interrupt to the CPU so we

00:12:47,209 --> 00:12:53,540
can achieve the goal that we don't

00:12:49,279 --> 00:12:58,579
bother the CPU when the possible devices

00:12:53,540 --> 00:13:03,260
have interrupt and at the same time the

00:12:58,579 --> 00:13:06,260
iommu well record the Gesta irq in the

00:13:03,260 --> 00:13:09,069
posted interruptive descriptor in this

00:13:06,260 --> 00:13:12,260
way hardware will continue using the old

00:13:09,069 --> 00:13:14,660
posting in rap descriptor and

00:13:12,260 --> 00:13:21,890
interrupting mapping table entries from

00:13:14,660 --> 00:13:25,340
for the iommu and the device can still

00:13:21,890 --> 00:13:28,010
Chickering interrupt but the environment

00:13:25,340 --> 00:13:31,910
will not reach to the physical CPU it

00:13:28,010 --> 00:13:32,540
just recorded in the posted interrupt

00:13:31,910 --> 00:13:38,690
descriptor

00:13:32,540 --> 00:13:42,560
after reboot then the KVM and iommu well

00:13:38,690 --> 00:13:46,430
we use such kind of hardware resources

00:13:42,560 --> 00:13:48,670
to reconnect the between the software

00:13:46,430 --> 00:13:54,730
and the hardware

00:13:48,670 --> 00:13:58,850
similarly TM a part we just keep the

00:13:54,730 --> 00:14:02,900
iommu configuration intact during the

00:13:58,850 --> 00:14:05,810
exact reboot the hardware continues

00:14:02,900 --> 00:14:10,460
using the old page table in in in the

00:14:05,810 --> 00:14:13,460
memory so DMA can go on during the

00:14:10,460 --> 00:14:18,040
reboot and after reboot that our main

00:14:13,460 --> 00:14:18,040
driver will pick up the page tables

00:14:18,640 --> 00:14:26,480
there are also some special handling for

00:14:22,580 --> 00:14:29,930
the K exit report processing because

00:14:26,480 --> 00:14:33,050
currently before the reboot it Bell

00:14:29,930 --> 00:14:35,720
called tigris shut down callback so we

00:14:33,050 --> 00:14:38,000
need to skip shutdown of passive devices

00:14:35,720 --> 00:14:40,790
and its upstream devices before they

00:14:38,000 --> 00:14:42,890
exit reboot and we also passed some

00:14:40,790 --> 00:14:45,650
information for some data from out

00:14:42,890 --> 00:14:48,020
kernel to the new Crenn for example and

00:14:45,650 --> 00:14:51,980
the personalized list and memory

00:14:48,020 --> 00:14:55,190
occupations for example the iommu uses

00:14:51,980 --> 00:14:58,100
locates page tables such kind of memory

00:14:55,190 --> 00:15:00,710
occupation need to be passed to the new

00:14:58,100 --> 00:15:03,830
kernel and the new kind of will need to

00:15:00,710 --> 00:15:07,100
reserve it to avoid a location to other

00:15:03,830 --> 00:15:10,940
parts of the new kernel so we may need

00:15:07,100 --> 00:15:13,400
to extend the boot protocol and during

00:15:10,940 --> 00:15:15,380
the new kernel boot up there is a device

00:15:13,400 --> 00:15:18,290
enumeration phase and travel matching

00:15:15,380 --> 00:15:21,440
phase in this phase we also need to

00:15:18,290 --> 00:15:24,160
avoid attaching the native joiner for

00:15:21,440 --> 00:15:26,260
passive device we have to reattach a

00:15:24,160 --> 00:15:29,190
- the be her final German for the

00:15:26,260 --> 00:15:32,020
upstream devices i-i'm you and the

00:15:29,190 --> 00:15:34,420
switch port something like this then

00:15:32,020 --> 00:15:38,880
they will need to pick up the hardware

00:15:34,420 --> 00:15:45,820
state and avoid problem the harbor state

00:15:38,880 --> 00:15:51,700
we also need to reassign the device to

00:15:45,820 --> 00:15:54,070
the guests and the reassigning procedure

00:15:51,700 --> 00:15:59,020
is a little bit different than the

00:15:54,070 --> 00:16:03,250
normal assignment so during the

00:15:59,020 --> 00:16:07,540
reassignment we have to escape the reset

00:16:03,250 --> 00:16:10,570
and PCI initialization we also leverage

00:16:07,540 --> 00:16:13,990
the snapshot mechanism that we mentioned

00:16:10,570 --> 00:16:16,270
earlier - to save and restore the

00:16:13,990 --> 00:16:19,540
internal states of the BFI Oh siren

00:16:16,270 --> 00:16:24,660
including the MSI in MSI X state and the

00:16:19,540 --> 00:16:28,900
TM a mapping so we complete the

00:16:24,660 --> 00:16:31,420
reassignment in two phases firstly the

00:16:28,900 --> 00:16:34,570
usual we have I all realize well

00:16:31,420 --> 00:16:40,000
reattach we have our groups domains etc

00:16:34,570 --> 00:16:47,110
but without Hardware clobbering we then

00:16:40,000 --> 00:16:51,310
at the stage of snapshot reloading we we

00:16:47,110 --> 00:16:53,650
reconnect the DMA mapping and the irq

00:16:51,310 --> 00:16:57,400
state according to the BFI all internal

00:16:53,650 --> 00:17:00,940
states so to achieve this we may need

00:16:57,400 --> 00:17:04,750
new i/o control common or flags to

00:17:00,940 --> 00:17:07,270
indicate this is a reassignment or the

00:17:04,750 --> 00:17:10,630
BFF driver can handle this automatically

00:17:07,270 --> 00:17:15,819
by recognizing the device is in passive

00:17:10,630 --> 00:17:18,910
device list so this is a recap of the

00:17:15,819 --> 00:17:21,880
whole high-level flow the left side is

00:17:18,910 --> 00:17:24,490
the is running in the out column we

00:17:21,880 --> 00:17:27,550
first start we M and save snapshot in

00:17:24,490 --> 00:17:29,470
memory and recall hardware resources

00:17:27,550 --> 00:17:33,310
including memory source of occupation

00:17:29,470 --> 00:17:36,280
and then trigger exec we put when the

00:17:33,310 --> 00:17:39,820
new kernel takes over to control it

00:17:36,280 --> 00:17:44,590
to demise enumeration then in this face

00:17:39,820 --> 00:17:47,620
avoid havoc robbery and avoid negative

00:17:44,590 --> 00:17:51,400
Jarrett at you then they upstream

00:17:47,620 --> 00:17:57,070
devices when the driver will need to

00:17:51,400 --> 00:18:00,190
reload their state after that the the VM

00:17:57,070 --> 00:18:03,030
can be relaunched and its snapshot will

00:18:00,190 --> 00:18:07,720
be reloaded from the tax file system and

00:18:03,030 --> 00:18:10,150
the snapshot reloading phase DMA mapping

00:18:07,720 --> 00:18:15,940
and the MSI and MSI X state whether

00:18:10,150 --> 00:18:20,860
installed so there are still some opens

00:18:15,940 --> 00:18:23,530
actually for example we how we handle

00:18:20,860 --> 00:18:26,400
trusted wiggle can we trust the

00:18:23,530 --> 00:18:30,130
information passed from the LD colonel

00:18:26,400 --> 00:18:33,420
another issue is that how do we resize

00:18:30,130 --> 00:18:38,320
memory when the configuration changed

00:18:33,420 --> 00:18:42,940
and they said open maybe do we want to

00:18:38,320 --> 00:18:47,740
support as I or we usually we assign we

00:18:42,940 --> 00:18:50,530
have to guest VM but for some specific

00:18:47,740 --> 00:18:57,040
devices there are communications between

00:18:50,530 --> 00:19:01,420
we F and P F so in this way we may have

00:18:57,040 --> 00:19:06,700
to some way to save this state of the PF

00:19:01,420 --> 00:19:10,120
or and restore the PF but such kind of

00:19:06,700 --> 00:19:14,050
state saving and restoring is totally

00:19:10,120 --> 00:19:18,100
device specific so this is the openness

00:19:14,050 --> 00:19:23,340
and here is the current development

00:19:18,100 --> 00:19:26,560
status in our plane we split the

00:19:23,340 --> 00:19:31,540
approach into three milestones the first

00:19:26,560 --> 00:19:33,730
one is with do the we mmm fastest and

00:19:31,540 --> 00:19:38,680
without possible devices this has been

00:19:33,730 --> 00:19:41,320
done and the second part is to not

00:19:38,680 --> 00:19:42,480
reboot the host but just we start the

00:19:41,320 --> 00:19:46,630
queue

00:19:42,480 --> 00:19:48,450
with personal devices in this milestone

00:19:46,630 --> 00:19:52,559
we were exercises

00:19:48,450 --> 00:19:58,139
the DMA and irq detaching and

00:19:52,559 --> 00:20:02,159
reattaching so this is this must own POC

00:19:58,139 --> 00:20:06,600
already have done and the third master

00:20:02,159 --> 00:20:08,309
is 2d to implement the full-fledged vmm

00:20:06,600 --> 00:20:14,279
Festival Stan where's personal devices

00:20:08,309 --> 00:20:18,299
and was hostelry this is going on next

00:20:14,279 --> 00:20:22,200
step we hope we can upstream in this

00:20:18,299 --> 00:20:27,899
effort so we need help and we need your

00:20:22,200 --> 00:20:42,359
comments Thanks and this is our priests

00:20:27,899 --> 00:20:45,509
presentation any question thank you for

00:20:42,359 --> 00:20:47,639
your talk when you keep the Iommi mule

00:20:45,509 --> 00:20:52,710
mappings alive how do you prevent the

00:20:47,639 --> 00:20:54,919
kxn colonel from stomping over them we

00:20:52,710 --> 00:20:58,440
there will be some modification in the

00:20:54,919 --> 00:21:01,559
iommu driver so when the new colonel

00:20:58,440 --> 00:21:05,669
boots when the when it reinitialized the

00:21:01,559 --> 00:21:08,309
iommu it will know this and will pick up

00:21:05,669 --> 00:21:12,239
corresponding hardware device how do i I

00:21:08,309 --> 00:21:14,100
mean the apt page tables for for the

00:21:12,239 --> 00:21:16,499
devices they are lying somewhere around

00:21:14,100 --> 00:21:18,450
the Linux memory right yes those

00:21:16,499 --> 00:21:20,999
information are passed from Elcano to

00:21:18,450 --> 00:21:25,409
the new kernel so the new color will not

00:21:20,999 --> 00:21:34,039
reserved such memory region for for the

00:21:25,409 --> 00:21:34,039
iommu usage yeah the pager tables yeah

00:21:39,619 --> 00:21:45,509
thanks for talked about I wonder how

00:21:43,439 --> 00:21:49,049
often do realize that the new kernel is

00:21:45,509 --> 00:21:50,519
not compatible well well then you kernel

00:21:49,049 --> 00:21:53,149
cannot handle the key exec and you

00:21:50,519 --> 00:21:55,979
decide to go through the whole host

00:21:53,149 --> 00:21:58,259
reboot instead of using key exactly even

00:21:55,979 --> 00:22:00,779
though the firmware upgrade isn't

00:21:58,259 --> 00:22:01,409
required and how do they make this

00:22:00,779 --> 00:22:09,029
decision

00:22:01,409 --> 00:22:10,859
Thanks yeah you mean yeah how the new

00:22:09,029 --> 00:22:13,889
kernel cannot handle the key exec and

00:22:10,859 --> 00:22:15,869
you go through the host reboot or is it

00:22:13,889 --> 00:22:19,889
always the case when if you need to

00:22:15,869 --> 00:22:23,519
upgrade the kernel you exactly yeah you

00:22:19,889 --> 00:22:28,199
apply the new kernel right set up the

00:22:23,519 --> 00:22:31,289
boot yes yes and and yeah we we can run

00:22:28,199 --> 00:22:36,059
a Kay exit common to load a new color

00:22:31,289 --> 00:22:38,849
into the memory and then jump to it yeah

00:22:36,059 --> 00:22:41,879
I understand I mean for example if you

00:22:38,849 --> 00:22:44,849
grade from four point I know 14 up to

00:22:41,879 --> 00:22:48,079
five is it always the case when you can

00:22:44,849 --> 00:22:48,079
follow this approach

00:22:51,070 --> 00:22:53,890
there are some updates for which you

00:22:52,750 --> 00:22:55,510
won't want to do that if you need to

00:22:53,890 --> 00:22:57,340
update the BIOS you sometimes you need

00:22:55,510 --> 00:22:58,570
to reboot the house but generally for a

00:22:57,340 --> 00:23:00,190
software update you know you can just go

00:22:58,570 --> 00:23:03,640
exec into the new kernel and it keeps

00:23:00,190 --> 00:23:07,870
going so in one of your early slides you

00:23:03,640 --> 00:23:10,870
had the time yeah I think you said this

00:23:07,870 --> 00:23:14,500
method would take about 10 seconds yes I

00:23:10,870 --> 00:23:20,320
get that number from the 10 seconds is

00:23:14,500 --> 00:23:23,490
mostly the out of box data that we

00:23:20,320 --> 00:23:27,250
gathered without hard tuning of the

00:23:23,490 --> 00:23:32,820
reboot I think we it is possible to

00:23:27,250 --> 00:23:36,600
achieve several seconds after some

00:23:32,820 --> 00:23:41,050
optimization for the K exit reboot and

00:23:36,600 --> 00:23:44,320
with specific server configuration so we

00:23:41,050 --> 00:23:48,340
are using clear Linux which is optimized

00:23:44,320 --> 00:23:51,250
for the for the for the for the boot

00:23:48,340 --> 00:23:55,120
procedure so I think we can achieve

00:23:51,250 --> 00:23:58,830
several seconds time scale I think we

00:23:55,120 --> 00:23:58,830
can do better than that yeah yeah yeah

00:23:58,920 --> 00:24:06,970
so you skip the the firmware by using K

00:24:02,980 --> 00:24:08,700
exact yeah which if the fix that you're

00:24:06,970 --> 00:24:11,020
updating is in the firmware at

00:24:08,700 --> 00:24:13,420
initialization time you're therefore not

00:24:11,020 --> 00:24:15,940
actually rang the new code and likewise

00:24:13,420 --> 00:24:19,540
if the fixes that you're trying to get

00:24:15,940 --> 00:24:21,190
from the update are in the in the

00:24:19,540 --> 00:24:25,240
initialization code in the in the new

00:24:21,190 --> 00:24:27,010
kernel that is say you there's a bug in

00:24:25,240 --> 00:24:29,650
the initialization of the immu you're

00:24:27,010 --> 00:24:32,890
skipping that as well how do you know if

00:24:29,650 --> 00:24:36,460
the update you try to apply has that the

00:24:32,890 --> 00:24:37,750
vital parts of it are in the part that

00:24:36,460 --> 00:24:41,920
you're skipping and therefore won't

00:24:37,750 --> 00:24:44,410
actually get the fix you need I'm not

00:24:41,920 --> 00:24:46,300
sure I understand your question well

00:24:44,410 --> 00:24:47,950
during your re-initialization you're

00:24:46,300 --> 00:24:49,630
deliberately skipping a lot of the

00:24:47,950 --> 00:24:51,940
normal boot process you're skipping yes

00:24:49,630 --> 00:24:53,880
yes you're skipping iron in your

00:24:51,940 --> 00:24:58,630
initialization you're skipping certain

00:24:53,880 --> 00:25:01,180
actions actually for iommu it's not just

00:24:58,630 --> 00:25:02,880
a skipping initialization I think there

00:25:01,180 --> 00:25:06,090
are some modifications

00:25:02,880 --> 00:25:11,160
today i-i'm a driver it will recognize

00:25:06,090 --> 00:25:14,070
this case and try to initialize from

00:25:11,160 --> 00:25:17,310
some hardware configurations short it's

00:25:14,070 --> 00:25:19,710
not just a scheme initialization I think

00:25:17,310 --> 00:25:22,110
it makes sure that the point is you by

00:25:19,710 --> 00:25:24,960
passing a lot of the of the usual

00:25:22,110 --> 00:25:26,460
initialization code for things and if

00:25:24,960 --> 00:25:27,840
the fixes that you are trying to get

00:25:26,460 --> 00:25:29,970
from the system update are in that

00:25:27,840 --> 00:25:31,440
initialization code then you've skipped

00:25:29,970 --> 00:25:34,740
exactly the part of the update that you

00:25:31,440 --> 00:25:37,860
need so how do you know when you find

00:25:34,740 --> 00:25:39,480
get an update where the fixes are that

00:25:37,860 --> 00:25:41,220
you need and whether or not this

00:25:39,480 --> 00:25:43,230
approach is going to be safe because it

00:25:41,220 --> 00:25:49,370
has fixes in the places are you gonna

00:25:43,230 --> 00:25:52,730
skip yes yes actually there are some

00:25:49,370 --> 00:25:56,760
there may be some compatibility issues

00:25:52,730 --> 00:25:59,400
when we post the new kernel up when we

00:25:56,760 --> 00:26:01,740
put the new kernel because the new

00:25:59,400 --> 00:26:04,710
kernel actually has a different version

00:26:01,740 --> 00:26:08,100
than the old colonel so they may have

00:26:04,710 --> 00:26:10,110
some changes in we do know where we may

00:26:08,100 --> 00:26:13,440
not know where the new kernel have

00:26:10,110 --> 00:26:19,710
changed somewhere so I think we the the

00:26:13,440 --> 00:26:25,610
new kernel may need to aware of such use

00:26:19,710 --> 00:26:31,640
case so it can can can can pick up the

00:26:25,610 --> 00:26:31,640
yeah the hardware State

00:26:36,259 --> 00:26:44,190
on a similar vein do you have plans to

00:26:40,489 --> 00:26:46,379
bake anything in to kind of vet the new

00:26:44,190 --> 00:26:47,609
kernel that reloading so that you don't

00:26:46,379 --> 00:26:50,039
end up with a state where you're trying

00:26:47,609 --> 00:26:52,859
to pick up fixes in some iommu and hit

00:26:50,039 --> 00:26:54,209
code and you don't do that you burn your

00:26:52,859 --> 00:26:57,299
whole machine down you lose a bunch of

00:26:54,209 --> 00:27:02,609
guests or your kernel just simply

00:26:57,299 --> 00:27:04,679
doesn't food so rather than relying on

00:27:02,609 --> 00:27:08,159
people to know that they shouldn't try

00:27:04,679 --> 00:27:11,099
and Kay exec from kernel a to kernel be

00:27:08,159 --> 00:27:14,959
having something in kernel a to know

00:27:11,099 --> 00:27:14,959
that oh this is not compatible with me

00:27:17,749 --> 00:27:26,159
yes I think the the that's the same

00:27:21,869 --> 00:27:29,699
issue that the to some extent the kernel

00:27:26,159 --> 00:27:35,309
need to be aware of such a use case I

00:27:29,699 --> 00:27:47,569
think so the later update of the kernel

00:27:35,309 --> 00:27:51,719
will need to say make some to have some

00:27:47,569 --> 00:27:55,889
some some methods to to prepare for such

00:27:51,719 --> 00:27:58,139
kind of a use case do you have plans to

00:27:55,889 --> 00:27:59,940
do that though as opposed to UK exec

00:27:58,139 --> 00:28:03,569
into the new kernel and then you realize

00:27:59,940 --> 00:28:06,179
your hose I think yeah this yeah as you

00:28:03,569 --> 00:28:09,979
mentioned this is the the most

00:28:06,179 --> 00:28:12,569
complicated part of the approach I think

00:28:09,979 --> 00:28:15,539
because there may touch a lot of

00:28:12,569 --> 00:28:19,409
subsystems in the kernel so I think it

00:28:15,539 --> 00:28:21,479
depends on how we do it maybe yeah we

00:28:19,409 --> 00:28:26,129
are still looking at this yeah

00:28:21,479 --> 00:28:29,069
and how we do it yeah you're just a

00:28:26,129 --> 00:28:31,379
follow-up question on another gentleman

00:28:29,069 --> 00:28:32,959
asked about the IOM you and the EPT

00:28:31,379 --> 00:28:35,159
pay-table mappings

00:28:32,959 --> 00:28:37,079
what kind of password devices you have

00:28:35,159 --> 00:28:41,669
it has to be here

00:28:37,079 --> 00:28:45,959
networking what's the gastro RAM size in

00:28:41,669 --> 00:28:49,260
terms of it's a host Ram size in our

00:28:45,959 --> 00:28:51,570
test we just used a small mmm

00:28:49,260 --> 00:28:53,850
sighs for the guests yeah I single if

00:28:51,570 --> 00:28:55,340
you choose close to the house marry

00:28:53,850 --> 00:29:03,770
silence you might see the easy was that

00:28:55,340 --> 00:29:07,010
gentleman just mentioned so you mean the

00:29:03,770 --> 00:29:09,960
iommu state saving and restoring our

00:29:07,010 --> 00:29:11,340
depends on the size of the yes when you

00:29:09,960 --> 00:29:13,260
have a home you when you have a device

00:29:11,340 --> 00:29:16,740
assign erase all the memories we've got

00:29:13,260 --> 00:29:18,420
opinion right then the rest in your

00:29:16,740 --> 00:29:24,450
close memory will be used of all the

00:29:18,420 --> 00:29:27,330
page table reserved right then the page

00:29:24,450 --> 00:29:30,120
table not EPT page table not EPT page

00:29:27,330 --> 00:29:31,980
table those it's it's iommu io page

00:29:30,120 --> 00:29:36,960
table yes but latter has to be reserved

00:29:31,980 --> 00:29:41,010
right yes so but if you whatever size

00:29:36,960 --> 00:29:44,130
your guests have after you restart even

00:29:41,010 --> 00:29:47,400
the normal restart reboot you have to

00:29:44,130 --> 00:29:49,740
use that kind of what my point is that

00:29:47,400 --> 00:29:52,770
will increase your chance to stop on

00:29:49,740 --> 00:29:58,680
those memory so you might see it easier

00:29:52,770 --> 00:30:03,900
there it's better to check that I'm not

00:29:58,680 --> 00:30:06,190
sure you can follow up offline okay okay

00:30:03,900 --> 00:30:09,720
thank you thank you

00:30:06,190 --> 00:30:16,569
[Applause]

00:30:09,720 --> 00:30:16,569

YouTube URL: https://www.youtube.com/watch?v=pBsHnf93tcQ


