Title: [2019] Towards the Higher Level Debugging with QEMU by Pavel Dovgalyuk
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	QEMU includes gdbserver emulator which is capable of debugging the whole emulated system, including firmwares, drivers, and BIOS code. However, debugging with a multi-process operating system is tricky, because GDB does not distinguish the processes within the guest.
In this talk authors discuss the approaches for making the debugging better: detecting the processes, inspection of the address spaces, instrumenting the code, mapping the executables, and so on.

The talk also includes overview of the new debugging stub for QEMU which allows using WinDbg without switching the guest system into the debugging mode.

---

Pavel Dovgalyuk
ISP RAS
Software developer

Pavel Dovgalyuk is a software developer in Institute for System Programming (ISP) of the Russian Academy of Sciences (RAS). The activities of the Institute include fundamental research, software development, applied research for the benefits of the Industry, and education. For the last 9 years he has been working on the project which aim is adding deterministic replay, reverse debugging, instrumentation, instrospection, debugging, and analysis to qemu. Part of this work was already included into mainline QEMU. Pavel presented execution record/replay work at KVM Forum 2014, and instrumentation/introspection approaches at KVM Forum 2017.

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,099 --> 00:00:16,859
okay hello everyone I want to talk about

00:00:13,889 --> 00:00:22,769
debugging and basically it's debugging

00:00:16,859 --> 00:00:26,789
with cameo I walk in the Institute for

00:00:22,769 --> 00:00:31,410
system programming and our team had a

00:00:26,789 --> 00:00:34,800
bunch of related projects part of this

00:00:31,410 --> 00:00:40,590
work was at streamed as a record

00:00:34,800 --> 00:00:47,520
replayed subsystem for emulation we also

00:00:40,590 --> 00:00:51,210
have not up streamed but open source sub

00:00:47,520 --> 00:00:54,960
projects for instrumentation and in

00:00:51,210 --> 00:00:59,059
debug stub in wind about this sub

00:00:54,960 --> 00:00:59,059
projects are published on the github

00:00:59,719 --> 00:01:08,960
window bug stealth debugging means that

00:01:04,430 --> 00:01:12,210
the debugger connects to the emulator

00:01:08,960 --> 00:01:15,960
without switching the system to the

00:01:12,210 --> 00:01:21,479
debug mode so you can even replay its

00:01:15,960 --> 00:01:23,790
behavior in debug window we also have

00:01:21,479 --> 00:01:29,790
reverse debugging or time travel

00:01:23,790 --> 00:01:33,540
debugging patches for gdb that's that

00:01:29,790 --> 00:01:38,340
are supported by gdb protocol so the

00:01:33,540 --> 00:01:42,860
this but we will send these patches to

00:01:38,340 --> 00:01:47,869
the myelination and probably will have

00:01:42,860 --> 00:01:52,110
worst bugging capabilities I want to

00:01:47,869 --> 00:01:56,000
speak about system I debugging

00:01:52,110 --> 00:02:01,259
it's approaches and its problems

00:01:56,000 --> 00:02:06,530
basically when people use system I

00:02:01,259 --> 00:02:11,240
debugging and they use hyperbolas

00:02:06,530 --> 00:02:16,550
and emulators to debug system code or

00:02:11,240 --> 00:02:20,990
malware to isolate it off or in case of

00:02:16,550 --> 00:02:30,130
cameo we can use execution recording to

00:02:20,990 --> 00:02:35,450
reproduce his inbox another big thing is

00:02:30,130 --> 00:02:43,040
cross-platform debugging which allows to

00:02:35,450 --> 00:02:47,170
use many platforms except x86 normally

00:02:43,040 --> 00:02:52,340
debug user wants to the debugger to

00:02:47,170 --> 00:02:57,200
provide many services and when you run

00:02:52,340 --> 00:03:00,100
win-win debug you can have all this

00:02:57,200 --> 00:03:03,080
information about the system you can

00:03:00,100 --> 00:03:06,760
examine processes you can switch between

00:03:03,080 --> 00:03:08,319
them set breakpoints for them you can

00:03:06,760 --> 00:03:11,420
[Music]

00:03:08,319 --> 00:03:18,890
see the symbols symbol names or the

00:03:11,420 --> 00:03:23,950
functions but this approach of course it

00:03:18,890 --> 00:03:23,950
is Windows only and it also requires

00:03:24,489 --> 00:03:33,940
requires the debug mode of the operating

00:03:27,170 --> 00:03:33,940
system in case of

00:03:34,910 --> 00:03:45,060
in case of gdb these things are little

00:03:40,890 --> 00:03:50,250
bit harder to use because when you are

00:03:45,060 --> 00:03:54,950
developer you can run gdb server in

00:03:50,250 --> 00:03:54,950
inside your virtual machine or you can

00:03:55,580 --> 00:04:03,360
attach to the kernel and Lord its debug

00:03:59,730 --> 00:04:06,870
symbols into the debugger but when you

00:04:03,360 --> 00:04:11,910
are reverse' sometimes you don't have

00:04:06,870 --> 00:04:19,650
these capabilities sometimes you can't

00:04:11,910 --> 00:04:24,090
even get the debugging symbols for

00:04:19,650 --> 00:04:31,850
example when the core is built and the

00:04:24,090 --> 00:04:31,850
kernel is pre built for some platform

00:04:31,880 --> 00:04:36,840
the kernel could have some changes you

00:04:34,830 --> 00:04:42,020
don't have SDK for that

00:04:36,840 --> 00:04:50,900
so you can't can figure out the symbols

00:04:42,020 --> 00:04:58,580
you can try if you are Jedi when so the

00:04:50,900 --> 00:05:01,860
gdb couldn't show you anything but

00:04:58,580 --> 00:05:06,420
instruction list of the instructions and

00:05:01,860 --> 00:05:10,260
memory contents it can't detect which

00:05:06,420 --> 00:05:12,090
process is arriving you can't set

00:05:10,260 --> 00:05:15,240
breakpoints on the specific processes

00:05:12,090 --> 00:05:23,290
except for the case if your Jedi you can

00:05:15,240 --> 00:05:28,630
figure out process ID and specify

00:05:23,290 --> 00:05:33,610
the co2 value in the break point but for

00:05:28,630 --> 00:05:43,930
the normal debugging case it is not

00:05:33,610 --> 00:05:46,350
convenient the problem of capturing the

00:05:43,930 --> 00:05:50,910
information about processes usually

00:05:46,350 --> 00:05:59,020
solved by virtual machine introspection

00:05:50,910 --> 00:06:01,750
in which which can extract this

00:05:59,020 --> 00:06:05,580
information required for forces in

00:06:01,750 --> 00:06:09,970
debugging and also another problem which

00:06:05,580 --> 00:06:16,720
occurs when you trying to debug full

00:06:09,970 --> 00:06:21,060
system is that gdb still and explore the

00:06:16,720 --> 00:06:24,570
processes even if you can extract them

00:06:21,060 --> 00:06:25,930
there are several approaches to

00:06:24,570 --> 00:06:28,120
introspection

00:06:25,930 --> 00:06:35,770
the first one is embedded the guest code

00:06:28,120 --> 00:06:38,740
which reads required information from

00:06:35,770 --> 00:06:42,850
the system requested from the kernel or

00:06:38,740 --> 00:06:45,760
something like that this is similar to

00:06:42,850 --> 00:06:51,580
run in gdb in debug server inside a

00:06:45,760 --> 00:06:58,000
machine this approaches was a good but

00:06:51,580 --> 00:07:00,970
it can't be it can be used when for

00:06:58,000 --> 00:07:04,000
example you have a custom some custom

00:07:00,970 --> 00:07:09,060
kernel without is the key to build their

00:07:04,000 --> 00:07:11,740
guest agent whoa and he also can't

00:07:09,060 --> 00:07:15,280
record the execution of the system

00:07:11,740 --> 00:07:18,250
because I guess this gas station works

00:07:15,280 --> 00:07:24,780
with within the system and it also will

00:07:18,250 --> 00:07:30,420
be recorded another popular approach is

00:07:24,780 --> 00:07:33,559
analysis of the dumps will the forensic

00:07:30,420 --> 00:07:33,559
[Music]

00:07:33,840 --> 00:07:42,210
I say dumps but in most cases the dumps

00:07:39,660 --> 00:07:47,820
may be captured in runtime from the

00:07:42,210 --> 00:07:51,090
virtual machine and you can observe the

00:07:47,820 --> 00:07:56,900
system-wide information system specific

00:07:51,090 --> 00:07:59,940
information in the debugger but this

00:07:56,900 --> 00:08:03,480
this approach is too slow for runtime

00:07:59,940 --> 00:08:07,710
events so you can usually observe the

00:08:03,480 --> 00:08:14,510
system only when stopped and of course

00:08:07,710 --> 00:08:14,510
it requires some kernel information to

00:08:15,380 --> 00:08:28,919
pass the dump another similar but more

00:08:23,250 --> 00:08:31,110
lightweight approaches event hooking for

00:08:28,919 --> 00:08:35,760
example Yahoo could process switching

00:08:31,110 --> 00:08:41,969
and then pass go through the list of the

00:08:35,760 --> 00:08:45,600
processes in the kernel it is seen this

00:08:41,969 --> 00:08:49,380
approach is more lightweight than the

00:08:45,600 --> 00:08:59,280
previous one but it still requires some

00:08:49,380 --> 00:09:05,970
knowledge about kernel it is we also

00:08:59,280 --> 00:09:11,100
have some different approach in our SWAT

00:09:05,970 --> 00:09:15,180
repository on github it hopes only

00:09:11,100 --> 00:09:19,310
system calls and extracts information

00:09:15,180 --> 00:09:25,980
about running audit executables and

00:09:19,310 --> 00:09:29,790
dynamic libraries but it also it doesn't

00:09:25,980 --> 00:09:34,770
require tuning for the specific kernel

00:09:29,790 --> 00:09:38,990
but it still we have limited

00:09:34,770 --> 00:09:41,060
capabilities because we don't know

00:09:38,990 --> 00:09:45,920
details of the colonel for example me

00:09:41,060 --> 00:09:47,960
stop cannot cannot iterate through the

00:09:45,920 --> 00:09:58,340
list of the processes because this

00:09:47,960 --> 00:10:06,470
approach is doesn't contribute for the

00:09:58,340 --> 00:10:13,400
specific build keep the project which

00:10:06,470 --> 00:10:18,140
uses introspection for the debugging is

00:10:13,400 --> 00:10:20,540
Python via my debug project it's

00:10:18,140 --> 00:10:27,290
intended to support its intended to

00:10:20,540 --> 00:10:32,060
provide operation system and debug

00:10:27,290 --> 00:10:37,690
agnostic interface to support every

00:10:32,060 --> 00:10:40,370
every hypervisor and every debugger this

00:10:37,690 --> 00:10:46,700
project is still evolving its supports

00:10:40,370 --> 00:10:51,830
on the part of the hypervisors and debug

00:10:46,700 --> 00:10:55,370
protocols however it is it uses live MI

00:10:51,830 --> 00:11:01,490
and eat it seems that it's possible to

00:10:55,370 --> 00:11:03,890
implement wind Ibaka and gdb stops for

00:11:01,490 --> 00:11:13,870
the virtual machines that already

00:11:03,890 --> 00:11:17,240
support live my interface it doesn't

00:11:13,870 --> 00:11:22,550
live when my doesn't still support qmu

00:11:17,240 --> 00:11:27,940
and for the best debugging experience we

00:11:22,550 --> 00:11:30,650
also have to do some instrumental I

00:11:27,940 --> 00:11:38,620
think that instrumenting is required

00:11:30,650 --> 00:11:44,120
because we can't examine the call stack

00:11:38,620 --> 00:11:45,690
of the thread when there's no debug

00:11:44,120 --> 00:11:48,090
confirmation and

00:11:45,690 --> 00:11:51,990
and the frame point is omitted by the

00:11:48,090 --> 00:11:55,070
compiler then the stack then the coaster

00:11:51,990 --> 00:12:02,130
contents is the only sequence of bytes

00:11:55,070 --> 00:12:04,850
we can I get we can we can't even detect

00:12:02,130 --> 00:12:11,520
the return address in this case

00:12:04,850 --> 00:12:14,280
automatically we could intercept calling

00:12:11,520 --> 00:12:19,050
and returning functions operations with

00:12:14,280 --> 00:12:23,340
step point but libram I doesn't allow

00:12:19,050 --> 00:12:27,630
this and this is primarily because it is

00:12:23,340 --> 00:12:31,760
impossible with Hardware hypervisors but

00:12:27,630 --> 00:12:31,760
it is a k4q

00:12:32,960 --> 00:12:44,400
it is why I think that game is the best

00:12:38,370 --> 00:12:51,180
choice for debugging another to this

00:12:44,400 --> 00:12:55,940
less meaningful things that breakpoints

00:12:51,180 --> 00:13:00,270
be used by gdb protocol are too simple

00:12:55,940 --> 00:13:03,650
they for example when you set very point

00:13:00,270 --> 00:13:08,450
in the inner loop you have the stop

00:13:03,650 --> 00:13:10,890
ambulate every time you meet the address

00:13:08,450 --> 00:13:15,390
and check the condition within the

00:13:10,890 --> 00:13:18,510
debugger we have proof of concept

00:13:15,390 --> 00:13:22,200
implementation of emulators emulator

00:13:18,510 --> 00:13:26,190
side breakpoints breakpoint conditions

00:13:22,200 --> 00:13:28,410
to check the brake check these

00:13:26,190 --> 00:13:32,370
conditions within the emulator and make

00:13:28,410 --> 00:13:34,110
debugging faster another problem and

00:13:32,370 --> 00:13:37,380
other possible improvements of

00:13:34,110 --> 00:13:42,360
breakpoints include break point in the

00:13:37,380 --> 00:13:46,430
eye operations which points for the

00:13:42,360 --> 00:13:50,070
larger memory areas then four bytes for

00:13:46,430 --> 00:13:52,790
example for which point in the whole

00:13:50,070 --> 00:13:52,790
race

00:13:52,890 --> 00:13:57,570
and of course great point in specific

00:13:55,560 --> 00:14:08,010
processes but it can be solved by

00:13:57,570 --> 00:14:11,250
conditions when you trying to extend or

00:14:08,010 --> 00:14:16,050
create new virtual device within the

00:14:11,250 --> 00:14:20,900
Cameo you have to explore its device its

00:14:16,050 --> 00:14:24,180
internal state but usually you just run

00:14:20,900 --> 00:14:30,060
the debugger of the guest program and

00:14:24,180 --> 00:14:34,830
get some logs from the virtual device so

00:14:30,060 --> 00:14:39,150
- this is kind of inconvenient because

00:14:34,830 --> 00:14:45,540
you have to match the logs and debugging

00:14:39,150 --> 00:14:49,320
of the guest so it would be more

00:14:45,540 --> 00:14:52,830
friendly to provide some information

00:14:49,320 --> 00:14:59,490
from the device to the debugger and make

00:14:52,830 --> 00:15:02,180
it observable for the user the

00:14:59,490 --> 00:15:05,400
conclusion is that if you want

00:15:02,180 --> 00:15:14,430
system-wide city my debugging you should

00:15:05,400 --> 00:15:17,940
use Windows or you should do anything to

00:15:14,430 --> 00:15:23,460
create you say to my debugger which

00:15:17,940 --> 00:15:28,500
supports instrumentation and it probably

00:15:23,460 --> 00:15:34,260
should be based on qme because it is the

00:15:28,500 --> 00:15:38,240
only cross platform debugger cross

00:15:34,260 --> 00:15:38,240
puffin emulator thank you

00:15:39,440 --> 00:15:44,530
[Applause]

00:15:53,730 --> 00:16:00,640
there are no questions thank you

00:15:57,650 --> 00:16:07,490
[Applause]

00:16:00,640 --> 00:16:07,490

YouTube URL: https://www.youtube.com/watch?v=E2yJL82gJYM


