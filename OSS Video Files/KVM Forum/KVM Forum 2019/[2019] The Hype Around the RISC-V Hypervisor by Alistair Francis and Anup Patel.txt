Title: [2019] The Hype Around the RISC-V Hypervisor by Alistair Francis and Anup Patel
Publication date: 2019-11-07
Playlist: KVM Forum 2019
Description: 
	RISC-V (pronounced "risk-five") is an Instruction Set Architecture (ISA) that's available under open, free and non-restrictive licences. It is a clean and modular ISA where new features are added as optional extensions. The RISC-V hypervisor extension provides virtualisation capabilities to a RISC-V CPU and it is designed considering both Type-1 and Type-2 hypervisors. In this talk Alistair and Anup will explain the RISC-V Hypervisor extension, discuss how it was implemented in QEMU and talk about the RISC-V implementation of KVM.

Alistair will talk about the current state of the RISC-V Hypervisor Extensions in QEMU. This will include details about the implementation and design choices that were made. He will discuss what we currently have upstream and how this compares to the latest and proposed future specification versions. This will include all known limitations and proposed future work in the QEMU implementation. He will also talk about current out of tree work that is not yet ready to be submitted upstream and discuss how this can be upstreamed.

Anup will then explain KVM RISC-V internals and the road ahead for KVM RISC-V. Anup will also show a demo of KVM RISC-V using using KVMTOOL.

---

Alistair Francis
Western Digital
Principal System Engineer

As an engineer working in Western Digital's R&D department I am focused on QEMU and RISC-V enablement. I have previous industry experience working in embedded devices, focused on business facing SoC designs and software stacks. As a QEMU maintainer I am interested in improving QEMU's support for RISC-V. I have recently been working on RISC-V Hypervisors. I have spoken at other conferences on a variety of open source projects, including QEMU and OpenEmbedded.

Anup Patel
Western Digital
Technologist

I am an open-source enthusiast with primary interest in hypervisors and Linux kernel. I work for Western Digital System Software Research group where we do lot of open-source contributions to help RISC-V ecosystem.
Captions: 
	00:00:00,390 --> 00:00:15,030
[Music]

00:00:08,300 --> 00:00:17,340
hi I'm gonna get started so my name is

00:00:15,030 --> 00:00:18,840
Alastair and this is a noop and we're

00:00:17,340 --> 00:00:20,820
from Western Digital is part of the

00:00:18,840 --> 00:00:23,070
research team and we're here today to

00:00:20,820 --> 00:00:27,599
talk about risk five with Kim you and

00:00:23,070 --> 00:00:29,130
KVM so today I'm gonna start with

00:00:27,599 --> 00:00:31,289
talking about the risk five hypervisor

00:00:29,130 --> 00:00:33,750
extensions then I'll go into details

00:00:31,289 --> 00:00:35,399
about the key mu implementation and then

00:00:33,750 --> 00:00:38,670
Anoop will take over and talk about the

00:00:35,399 --> 00:00:40,230
risk five port of KVM and the status in

00:00:38,670 --> 00:00:43,110
future work there and if we have time

00:00:40,230 --> 00:00:49,500
we'll have a KVM in key mu demo and then

00:00:43,110 --> 00:00:51,539
questions so the extension so the

00:00:49,500 --> 00:00:55,260
extension was designed to support both

00:00:51,539 --> 00:00:57,510
bare metal and hosted hypervisors 0.4

00:00:55,260 --> 00:00:59,670
version was released about four months

00:00:57,510 --> 00:01:01,710
ago and today it's mostly what we're

00:00:59,670 --> 00:01:03,989
talking about the zero to five version

00:01:01,710 --> 00:01:06,390
came out today so we haven't updated

00:01:03,989 --> 00:01:08,189
everything yet for that so if you go

00:01:06,390 --> 00:01:09,960
look at the spec don't get confused that

00:01:08,189 --> 00:01:13,500
not everything matches we're talking

00:01:09,960 --> 00:01:15,780
about the 0.4 version and all the

00:01:13,500 --> 00:01:17,100
feedback so far has been included into

00:01:15,780 --> 00:01:19,320
the spec so we had feedback from

00:01:17,100 --> 00:01:23,250
virtualization projects and that's kind

00:01:19,320 --> 00:01:26,250
of created respect today so Western

00:01:23,250 --> 00:01:28,500
Digital initially ported key mu X visor

00:01:26,250 --> 00:01:32,009
and KVM expires when KVM are both

00:01:28,500 --> 00:01:33,869
hypervisors and kim user emulator out on

00:01:32,009 --> 00:01:36,630
the 0 to 3 version we've updated it to

00:01:33,869 --> 00:01:43,110
the 0.4 version and we'll update it to

00:01:36,630 --> 00:01:45,149
the 0.5 version so this is what the

00:01:43,110 --> 00:01:48,149
hypervisor changes for the risk 5 spec

00:01:45,149 --> 00:01:51,030
so risk 5 without the hypervisor

00:01:48,149 --> 00:01:53,009
extension has machine mode s mode for

00:01:51,030 --> 00:01:56,490
supervisor mode and you for user space

00:01:53,009 --> 00:01:58,320
mode this is kind of similar to l-3 l1

00:01:56,490 --> 00:02:00,090
and eels you're in the arm world and

00:01:58,320 --> 00:02:02,100
that's where you run your machine mode

00:02:00,090 --> 00:02:05,430
your firmware which is open spi and the

00:02:02,100 --> 00:02:06,570
rest 5 your OS and your user space so

00:02:05,430 --> 00:02:09,569
with the risk Phi of hypervisor

00:02:06,570 --> 00:02:12,710
extension it kind of splits the user

00:02:09,569 --> 00:02:15,620
space and supervisor in your OS in half

00:02:12,710 --> 00:02:17,660
and it looks like this so your machine

00:02:15,620 --> 00:02:20,210
mode stays the same it's not virtualized

00:02:17,660 --> 00:02:23,270
it it runs as it always does and you

00:02:20,210 --> 00:02:24,410
know your hypervisor runs in HS mode so

00:02:23,270 --> 00:02:26,570
the cool thing about the risk 5

00:02:24,410 --> 00:02:29,600
hypervisor extension is you can use an

00:02:26,570 --> 00:02:31,040
unmodified OS in HS mode and just run as

00:02:29,600 --> 00:02:33,560
you always did you don't have to

00:02:31,040 --> 00:02:35,120
understand the hypervisor extension to

00:02:33,560 --> 00:02:36,350
keep running if you want to if you want

00:02:35,120 --> 00:02:38,480
to use it then you have to understand it

00:02:36,350 --> 00:02:41,570
but you don't have to use it for to just

00:02:38,480 --> 00:02:43,910
boot into hypervisor runs and HS then

00:02:41,570 --> 00:02:46,100
you your non-virtualized user space runs

00:02:43,910 --> 00:02:52,100
in you and your virtualized stuff to

00:02:46,100 --> 00:02:54,200
your guest run in BS and vu mode so the

00:02:52,100 --> 00:02:55,580
hypervisor extension also adds a lot of

00:02:54,200 --> 00:02:58,160
CSRs so

00:02:55,580 --> 00:03:00,080
CSR's the control registers in verse 5

00:02:58,160 --> 00:03:02,900
and they're normally prefixed with the

00:03:00,080 --> 00:03:05,780
privileged mode that accesses them so em

00:03:02,900 --> 00:03:07,430
status is the status for the machine

00:03:05,780 --> 00:03:10,310
mode s status is the status for

00:03:07,430 --> 00:03:13,880
supervisor mode and things like that so

00:03:10,310 --> 00:03:16,130
when virtualization is off in HS mode we

00:03:13,880 --> 00:03:18,680
have all n normal s CSRs and they do the

00:03:16,130 --> 00:03:21,490
same thing as always for supervisors we

00:03:18,680 --> 00:03:23,750
now have these H CSRs and so H CSRs

00:03:21,490 --> 00:03:25,730
specific for the hypervisor the things

00:03:23,750 --> 00:03:27,740
that hypervisors interested in so

00:03:25,730 --> 00:03:30,980
controlling delegation in exceptions

00:03:27,740 --> 00:03:33,710
into the guests things like that and the

00:03:30,980 --> 00:03:36,080
second stage page tables then we have

00:03:33,710 --> 00:03:40,400
these vs CSRs which is the virtualized

00:03:36,080 --> 00:03:42,110
guest s CSRs so the hypervisor can read

00:03:40,400 --> 00:03:43,850
and write these and modify them and use

00:03:42,110 --> 00:03:46,340
it to load and save us all contexts and

00:03:43,850 --> 00:03:48,650
things like that and when you trap or

00:03:46,340 --> 00:03:51,320
change into the hypervisor the hardware

00:03:48,650 --> 00:03:54,140
will automatically alias the s CSRs to

00:03:51,320 --> 00:03:56,330
the vs CSRs and so this is what Kim Yu

00:03:54,140 --> 00:03:59,690
has to do and so this means when your

00:03:56,330 --> 00:04:01,250
guest runs it unmodified accesses s CSRs

00:03:59,690 --> 00:04:03,890
as it always would but this really

00:04:01,250 --> 00:04:05,810
translates to just accessing the vs CSRs

00:04:03,890 --> 00:04:09,140
so your guest can't touch the hypervisor

00:04:05,810 --> 00:04:11,300
s CSRs all the H CSRs and when you swap

00:04:09,140 --> 00:04:14,240
back the hardware swap them back so the

00:04:11,300 --> 00:04:18,080
hypervisor can save or restore the HIVs

00:04:14,240 --> 00:04:20,680
CSRs as it needs to and there's a list

00:04:18,080 --> 00:04:20,680
there what they look like

00:04:22,350 --> 00:04:28,960
so the - I suspect also adds through

00:04:25,030 --> 00:04:30,190
stage mm you sir the two sages kind of

00:04:28,960 --> 00:04:31,840
follow the same as the normal verse five

00:04:30,190 --> 00:04:34,450
stages and we're going to details about

00:04:31,840 --> 00:04:36,430
that but the first stage is when you're

00:04:34,450 --> 00:04:38,470
virtualize the two stages always run so

00:04:36,430 --> 00:04:40,510
the first stage is for the guests so

00:04:38,470 --> 00:04:42,820
Linux programs that as it always would

00:04:40,510 --> 00:04:44,980
and it does your guests virtual address

00:04:42,820 --> 00:04:46,180
your guests physical address and then

00:04:44,980 --> 00:04:48,490
the second stage is controlled by the

00:04:46,180 --> 00:04:50,920
hypervisor and it has to set that up as

00:04:48,490 --> 00:04:52,450
it needs to and that control translates

00:04:50,920 --> 00:04:54,640
your guests physical address into your

00:04:52,450 --> 00:04:56,110
hosts physical address now I'll talk

00:04:54,640 --> 00:04:58,690
about more details about this when I

00:04:56,110 --> 00:05:00,190
talk about employee and Kim you but it's

00:04:58,690 --> 00:05:01,870
kind of if anyone understands there is

00:05:00,190 --> 00:05:03,100
five mm you it kind of follows the same

00:05:01,870 --> 00:05:09,490
way it just loops through twice

00:05:03,100 --> 00:05:11,290
basically so we also have interrupts and

00:05:09,490 --> 00:05:13,150
things like that obviously so virtual

00:05:11,290 --> 00:05:14,890
interrupts are injected to the guests to

00:05:13,150 --> 00:05:16,990
the VSIP register so this is in

00:05:14,890 --> 00:05:18,760
interrupt pending register that's the

00:05:16,990 --> 00:05:20,500
virtual copy for the guests so the

00:05:18,760 --> 00:05:22,270
hypervisor can set that set a bit in

00:05:20,500 --> 00:05:23,710
that for a pending interrupts transition

00:05:22,270 --> 00:05:26,200
to the guest and the guest gets a

00:05:23,710 --> 00:05:29,230
interrupts so we don't need a

00:05:26,200 --> 00:05:31,870
virtualized interrupt controller to for

00:05:29,230 --> 00:05:33,280
the hypervisor to inject in drugs so the

00:05:31,870 --> 00:05:35,740
hypervisor is also in charge of

00:05:33,280 --> 00:05:38,080
emulating spi calls so spi is kind of

00:05:35,740 --> 00:05:40,570
like the the PS CI equivalent in verse 5

00:05:38,080 --> 00:05:43,270
and hypervisor we'll use that for timers

00:05:40,570 --> 00:05:46,419
and things like that and with the two

00:05:43,270 --> 00:05:48,880
stage MMU the hypervisor can turn off

00:05:46,419 --> 00:05:51,010
access on the second stage so accesses

00:05:48,880 --> 00:05:53,710
will Fault into the hypervisor and use

00:05:51,010 --> 00:05:55,600
that to do mm IO emulation so you can

00:05:53,710 --> 00:05:59,350
pretend to give devices to the

00:05:55,600 --> 00:06:01,750
hypervisor and trap and emulate that we

00:05:59,350 --> 00:06:03,460
respect doesn't have an iommu or

00:06:01,750 --> 00:06:07,710
virtualized the interrupt controller yet

00:06:03,460 --> 00:06:07,710
so that's kind of only options you have

00:06:08,400 --> 00:06:14,230
so just a quick comparison to arm which

00:06:11,380 --> 00:06:16,590
is kind of similar so the RISC five half

00:06:14,230 --> 00:06:19,300
rice extension doesn't have a separate

00:06:16,590 --> 00:06:20,770
privilege mode or anything like that for

00:06:19,300 --> 00:06:22,210
hypervisor this is different to arm

00:06:20,770 --> 00:06:24,310
which has l2

00:06:22,210 --> 00:06:27,400
this kind of helps with running both

00:06:24,310 --> 00:06:28,990
type 1 and type 2 hypervisors because

00:06:27,400 --> 00:06:33,189
you don't have to like track back down

00:06:28,990 --> 00:06:34,749
to a 2 below if your operating system

00:06:33,189 --> 00:06:36,909
and like I just talked about the VSIP

00:06:34,749 --> 00:06:38,529
the guess the hypervisor injects

00:06:36,909 --> 00:06:39,909
interrupts to the guest using the VCF

00:06:38,529 --> 00:06:41,709
register so you can set bits in there

00:06:39,909 --> 00:06:43,389
and then transition in so you don't need

00:06:41,709 --> 00:06:49,149
to enter a virtualized interrupt

00:06:43,389 --> 00:06:51,509
controller the risk v extension uses spi

00:06:49,149 --> 00:06:53,559
calls like I said for timers and IP I

00:06:51,509 --> 00:06:55,569
that's different to the army

00:06:53,559 --> 00:06:57,509
implantation and the high risk v

00:06:55,569 --> 00:07:00,009
hypervisor extension supports nested

00:06:57,509 --> 00:07:02,319
virtualization so arm so what's that

00:07:00,009 --> 00:07:06,009
recently but it's there already in the

00:07:02,319 --> 00:07:08,409
respect - I suspect so the VT VM and VT

00:07:06,009 --> 00:07:10,089
s are bits basically tell the hard way

00:07:08,409 --> 00:07:12,279
to trap into the hypervisor when the

00:07:10,089 --> 00:07:15,789
guest does certain things like s threats

00:07:12,279 --> 00:07:17,080
s fences and page table accesses and so

00:07:15,789 --> 00:07:24,490
this allows you to then trap and emulate

00:07:17,080 --> 00:07:27,819
to do nested hypervisors so the

00:07:24,490 --> 00:07:30,309
extensions in key mu so there are

00:07:27,819 --> 00:07:32,259
patches on list now adding support for

00:07:30,309 --> 00:07:34,929
the hypervisor extensions 0 to full

00:07:32,259 --> 00:07:37,899
version - Kim you this works for both

00:07:34,929 --> 00:07:40,599
32-bit and 64-bit everything we talked

00:07:37,899 --> 00:07:42,249
about just then is supported so VST srs

00:07:40,599 --> 00:07:42,699
and swapping those kim you will handle

00:07:42,249 --> 00:07:46,029
that for you

00:07:42,699 --> 00:07:47,289
kim you correctly delegate interrupts to

00:07:46,029 --> 00:07:48,909
the hypervisor which then has to

00:07:47,289 --> 00:07:51,329
delegate them to the guests with the

00:07:48,909 --> 00:07:53,800
VSIP and there's a two stage interview

00:07:51,329 --> 00:07:56,319
so if anyone's interested there's a link

00:07:53,800 --> 00:07:57,879
on the slides of how you can take it you

00:07:56,319 --> 00:08:00,849
can also just get the patches in the

00:07:57,879 --> 00:08:02,949
list if that's easier for you so there's

00:08:00,849 --> 00:08:04,899
a qmu kind of standard thing we're gonna

00:08:02,949 --> 00:08:06,999
go with we're draft specs are going to

00:08:04,899 --> 00:08:09,159
be disabled by default because it's a

00:08:06,999 --> 00:08:11,199
drop spec it's subject to change in not

00:08:09,159 --> 00:08:13,449
backwards compatible ways so you have to

00:08:11,199 --> 00:08:15,909
enable it with the - CPU argument which

00:08:13,449 --> 00:08:18,249
is shown on the slide and we have X - H

00:08:15,909 --> 00:08:19,419
which is a queue of saying it's an

00:08:18,249 --> 00:08:21,189
experimental feature so it's

00:08:19,419 --> 00:08:25,079
experimental feature for the hypervisor

00:08:21,189 --> 00:08:25,079
extension and you can able with true

00:08:27,279 --> 00:08:32,050
so we have some changes made to kill me

00:08:29,319 --> 00:08:33,009
already the first one's actually not I

00:08:32,050 --> 00:08:35,409
thought I was gonna be merged but it's

00:08:33,009 --> 00:08:37,810
not merged yet still but let's just

00:08:35,409 --> 00:08:39,610
pretend it's merged so we're gonna

00:08:37,810 --> 00:08:40,839
remove the requirement on the mips ESR

00:08:39,610 --> 00:08:43,479
to be atomic

00:08:40,839 --> 00:08:46,329
so it's interrupt pending csr for a cpu

00:08:43,479 --> 00:08:49,810
so we previously updated atomically

00:08:46,329 --> 00:08:52,089
because other cpus would inject IP is

00:08:49,810 --> 00:08:55,269
into so they would change the status of

00:08:52,089 --> 00:08:57,250
it and having updated atomically is a

00:08:55,269 --> 00:08:59,589
real pain when you are swapping the

00:08:57,250 --> 00:09:02,709
status all the time as you trap in and

00:08:59,589 --> 00:09:05,199
hypervisors so we now use io thread well

00:09:02,709 --> 00:09:08,110
hopefully we'll use i/o thread so to be

00:09:05,199 --> 00:09:11,230
able to do that which is for QP polat's

00:09:08,110 --> 00:09:13,000
kind of a standard thing Kimmy does so

00:09:11,230 --> 00:09:14,980
we Lassen the essays by the command line

00:09:13,000 --> 00:09:16,300
like I just talked about so that way we

00:09:14,980 --> 00:09:18,069
can disable it by default and I'll have

00:09:16,300 --> 00:09:20,889
people enabling it so we don't break

00:09:18,069 --> 00:09:22,329
everyone who expects to use some old

00:09:20,889 --> 00:09:24,309
version then we updated and things like

00:09:22,329 --> 00:09:28,230
that and we had to consolidate some of

00:09:24,309 --> 00:09:28,230
the floating-point enable/disable logic

00:09:29,189 --> 00:09:33,160
so we had to maintain the hypervisor

00:09:31,420 --> 00:09:34,829
state so Kimmy always has to know if

00:09:33,160 --> 00:09:36,759
we're virtualized we're not virtualized

00:09:34,829 --> 00:09:39,459
this is a pretty straightforward because

00:09:36,759 --> 00:09:41,529
we only ever changes on traps or turns

00:09:39,459 --> 00:09:44,860
so there's only a few a handful places

00:09:41,529 --> 00:09:48,370
where it can change but the weird thing

00:09:44,860 --> 00:09:50,680
is that M mode and HS mode can which are

00:09:48,370 --> 00:09:52,839
not virtualized can both pretend to do

00:09:50,680 --> 00:09:54,399
virtualized accesses and I'll talk about

00:09:52,839 --> 00:09:56,949
this on the next slide with a Tuesday

00:09:54,399 --> 00:09:58,899
Jeremy where it comes up so Q needs to

00:09:56,949 --> 00:10:00,339
know this and handle this so we it's not

00:09:58,899 --> 00:10:03,129
just the straightforward as are we

00:10:00,339 --> 00:10:06,129
virtualized or not and we also need to

00:10:03,129 --> 00:10:09,129
be able to delegate faults to guests so

00:10:06,129 --> 00:10:10,629
some faults that no matter what the

00:10:09,129 --> 00:10:12,910
delegation settings are we have to

00:10:10,629 --> 00:10:15,339
delegate we have to vote to the guest I

00:10:12,910 --> 00:10:18,550
started to fall to the hypervisor and so

00:10:15,339 --> 00:10:21,970
the way EMU works is a second stage

00:10:18,550 --> 00:10:24,309
fault in the Tuesday gem you look up has

00:10:21,970 --> 00:10:26,230
to fall to the guest so that happens in

00:10:24,309 --> 00:10:27,790
the TLB fill which is very different to

00:10:26,230 --> 00:10:29,649
where we handle exceptions in kmu code

00:10:27,790 --> 00:10:31,809
so we some have to maintain the state

00:10:29,649 --> 00:10:34,089
between those two right now we do this

00:10:31,809 --> 00:10:36,819
with a force HS except but that's

00:10:34,089 --> 00:10:37,990
changed in the 0 to 5 version so we'll

00:10:36,819 --> 00:10:39,339
probably be getting rid of that and

00:10:37,990 --> 00:10:40,570
replacing that with a different way in

00:10:39,339 --> 00:10:42,480
0.5

00:10:40,570 --> 00:10:48,520
but that just happened today so that's

00:10:42,480 --> 00:10:50,050
yeah we haven't done it yet so I don't

00:10:48,520 --> 00:10:52,630
know how easy is to see but the true

00:10:50,050 --> 00:10:54,400
sage mmm you it's like I said when your

00:10:52,630 --> 00:10:56,680
virtualize the to say hmm you is always

00:10:54,400 --> 00:10:58,410
on you can do one-to-one mapping if you

00:10:56,680 --> 00:11:03,340
if you're not interested in using it but

00:10:58,410 --> 00:11:06,430
so the M status NPR V and H status SPR V

00:11:03,340 --> 00:11:09,610
of what M mode and HS mode used to turn

00:11:06,430 --> 00:11:11,680
on through stage mm you accesses for

00:11:09,610 --> 00:11:14,020
loads and stores so the reason you'd

00:11:11,680 --> 00:11:16,750
want this is if you trap into the

00:11:14,020 --> 00:11:18,490
firmware or your hypervisor for let's

00:11:16,750 --> 00:11:20,380
say in a legal instruction it's then

00:11:18,490 --> 00:11:21,610
your your hypervisor that your family

00:11:20,380 --> 00:11:23,410
needs to know what that instruction was

00:11:21,610 --> 00:11:25,210
so you can do a load or access on the

00:11:23,410 --> 00:11:28,510
address that you have and get the

00:11:25,210 --> 00:11:31,150
information from that back so that's why

00:11:28,510 --> 00:11:32,980
you would set these bits so the code

00:11:31,150 --> 00:11:35,200
changes to look kind of like this so the

00:11:32,980 --> 00:11:37,330
guest physical address we have to now

00:11:35,200 --> 00:11:39,220
pass in therefore in the first stage or

00:11:37,330 --> 00:11:40,990
not and if we're doing a true sage

00:11:39,220 --> 00:11:42,850
lookup so we need to know if we're doing

00:11:40,990 --> 00:11:44,890
a two stage look up because the page

00:11:42,850 --> 00:11:48,160
table Walker has to go through the two

00:11:44,890 --> 00:11:49,300
stages every access when you're when

00:11:48,160 --> 00:11:50,800
you're doing a virtualized when you're

00:11:49,300 --> 00:11:53,620
looking up from the virtualized state

00:11:50,800 --> 00:11:54,730
and even in the first stage and we need

00:11:53,620 --> 00:11:56,530
to know if it's first the second stage

00:11:54,730 --> 00:11:59,230
because we access different CSRs

00:11:56,530 --> 00:12:02,110
depending on the stages and the TLB fill

00:11:59,230 --> 00:12:03,850
function yeah maybe you can see that but

00:12:02,110 --> 00:12:07,330
the TLB fill function looks changes to

00:12:03,850 --> 00:12:11,110
look like this so if we're virtualized

00:12:07,330 --> 00:12:15,070
or if we're pretending to be M sat at M

00:12:11,110 --> 00:12:16,810
or H s status access to two stage mu X s

00:12:15,070 --> 00:12:18,850
then we go through the two stages so we

00:12:16,810 --> 00:12:23,620
do one and then if that passed we do it

00:12:18,850 --> 00:12:25,840
again and so we can change we change the

00:12:23,620 --> 00:12:27,130
values and reuse them but it gets a

00:12:25,840 --> 00:12:30,100
little more complicated in that again

00:12:27,130 --> 00:12:32,020
because if you're virtualized and on

00:12:30,100 --> 00:12:33,820
your first stage use the SAT Pig

00:12:32,020 --> 00:12:35,830
register which is the guests page they

00:12:33,820 --> 00:12:37,810
will register to do a lookup but if

00:12:35,830 --> 00:12:39,730
you're not virtualized but pretending to

00:12:37,810 --> 00:12:41,950
be to a two stage look up then you have

00:12:39,730 --> 00:12:43,210
to use the V SAT P register so there's

00:12:41,950 --> 00:12:45,100
just all these things you have to keep a

00:12:43,210 --> 00:12:46,870
track of depending on how you're

00:12:45,100 --> 00:12:48,790
accessing it and and what you're trying

00:12:46,870 --> 00:12:50,530
to do and so it's not really any way to

00:12:48,790 --> 00:12:53,230
avoid this you just have to kind of keep

00:12:50,530 --> 00:12:54,490
it eye on it and like I said the second

00:12:53,230 --> 00:12:56,260
stage translations have to

00:12:54,490 --> 00:12:57,459
trap back to the hypervisor so that's

00:12:56,260 --> 00:13:03,220
something else you have to keep an eye

00:12:57,459 --> 00:13:07,000
on so the other hard thing to do in

00:13:03,220 --> 00:13:10,330
Keanu is the register swapping so the

00:13:07,000 --> 00:13:12,310
sum of the CSRs aliased kind of between

00:13:10,330 --> 00:13:14,470
the different privileged modes so M

00:13:12,310 --> 00:13:17,560
status is the overall status of your

00:13:14,470 --> 00:13:20,290
call and s status is just M status with

00:13:17,560 --> 00:13:21,820
masked out so the supervisor doesn't get

00:13:20,290 --> 00:13:23,500
access to everything it gets only these

00:13:21,820 --> 00:13:26,890
sudden bits that are passed along to it

00:13:23,500 --> 00:13:28,839
so Q mu uses M status and some of these

00:13:26,890 --> 00:13:30,279
other CSR's to maintain the state

00:13:28,839 --> 00:13:31,510
there's nowhere that says what

00:13:30,279 --> 00:13:33,580
privileged mode you're in it's kind of

00:13:31,510 --> 00:13:35,080
saved in some of the stuff it's only

00:13:33,580 --> 00:13:36,730
saved in the M status so you have to

00:13:35,080 --> 00:13:38,740
read and read it the value back from M

00:13:36,730 --> 00:13:41,320
status so this gets really difficult

00:13:38,740 --> 00:13:41,800
when you're swapping these bits around

00:13:41,320 --> 00:13:43,360
all the time

00:13:41,800 --> 00:13:46,750
as you enter and exit virtualization

00:13:43,360 --> 00:13:48,220
modes so for M status and mie we use

00:13:46,750 --> 00:13:50,860
pointers and I explain that a little

00:13:48,220 --> 00:13:53,620
more a sec for the other ones we can

00:13:50,860 --> 00:13:56,380
just value swap which is easier and the

00:13:53,620 --> 00:13:58,990
MIPS CSR now let's pretend now that's no

00:13:56,380 --> 00:14:01,180
longer a comically access its value soft

00:13:58,990 --> 00:14:03,550
as well and so it ends up looking like

00:14:01,180 --> 00:14:06,010
this for the pointers so on Hardware if

00:14:03,550 --> 00:14:07,480
you access the s status CSR if you're

00:14:06,010 --> 00:14:10,329
virtualized or not virtualized you'll go

00:14:07,480 --> 00:14:14,050
through s title severe status which is

00:14:10,329 --> 00:14:16,570
backed by a real M status in commute if

00:14:14,050 --> 00:14:19,300
you access M status it had a points to M

00:14:16,570 --> 00:14:21,459
status no vert and M status vert and we

00:14:19,300 --> 00:14:23,680
handles what when they swap copying the

00:14:21,459 --> 00:14:25,089
right values around and if you access s

00:14:23,680 --> 00:14:29,170
status it's the same thing but just

00:14:25,089 --> 00:14:31,660
master so the this is different to the

00:14:29,170 --> 00:14:33,550
other implementations in key mu which

00:14:31,660 --> 00:14:35,050
have arrays and then access indices in

00:14:33,550 --> 00:14:36,700
the arrays so if you're not virtualized

00:14:35,050 --> 00:14:39,610
the virtualized you access the zeroth or

00:14:36,700 --> 00:14:41,950
the first or whatever you see the reason

00:14:39,610 --> 00:14:44,980
we do it like this in CHEM you is that

00:14:41,950 --> 00:14:46,720
the hypervisor extension is because the

00:14:44,980 --> 00:14:48,339
cream is so much so cuz receives the

00:14:46,720 --> 00:14:49,779
modular there's a lot of people who

00:14:48,339 --> 00:14:52,270
don't probably want to use the

00:14:49,779 --> 00:14:53,980
hypervisor extension and if they're

00:14:52,270 --> 00:14:55,300
adding some other extension they don't

00:14:53,980 --> 00:14:56,920
care about the hypervisor extension we

00:14:55,300 --> 00:14:59,320
don't want to have to worry about it so

00:14:56,920 --> 00:15:01,149
in this way M status s status all these

00:14:59,320 --> 00:15:02,380
registers are always correct you just

00:15:01,149 --> 00:15:04,449
access it you don't have to worry about

00:15:02,380 --> 00:15:05,920
which element in the array do you access

00:15:04,449 --> 00:15:08,110
what virtualization murder you in now

00:15:05,920 --> 00:15:09,910
things like that and so

00:15:08,110 --> 00:15:11,260
idea is to help make it easier for other

00:15:09,910 --> 00:15:12,730
people who aren't interested in it to

00:15:11,260 --> 00:15:14,560
use it and we kind of keep all the

00:15:12,730 --> 00:15:16,959
hypervisor stuff self-contained and

00:15:14,560 --> 00:15:19,029
handle swapping there so it makes it Oh

00:15:16,959 --> 00:15:20,740
probably a little messier in some places

00:15:19,029 --> 00:15:21,940
but the ideas that other people don't

00:15:20,740 --> 00:15:26,380
have to deal with it if they know if

00:15:21,940 --> 00:15:27,910
they don't want to so the future work

00:15:26,380 --> 00:15:30,550
so we want to upstream what we currently

00:15:27,910 --> 00:15:32,470
have it's being reviewed if anyone's

00:15:30,550 --> 00:15:35,230
interested in reviewing or the more

00:15:32,470 --> 00:15:38,800
viewers the better we have to implement

00:15:35,230 --> 00:15:40,570
the 0.5 version now as of today so good

00:15:38,800 --> 00:15:43,540
start on that the other thing is

00:15:40,570 --> 00:15:45,670
updating TL B's caching index to to

00:15:43,540 --> 00:15:47,950
include virtualization State so right

00:15:45,670 --> 00:15:51,310
now you can steal

00:15:47,950 --> 00:15:53,560
Kimi cash TL B's and you can flush out

00:15:51,310 --> 00:15:55,810
all of them or certain ones so right now

00:15:53,560 --> 00:15:57,850
we flush everything at pretty much any

00:15:55,810 --> 00:15:59,290
whenever there's any chance something

00:15:57,850 --> 00:16:02,320
could be cached we just something could

00:15:59,290 --> 00:16:03,820
be a problem we just flush which is

00:16:02,320 --> 00:16:06,730
probably performance overhead but more

00:16:03,820 --> 00:16:08,709
importantly it's gonna cover up bugs so

00:16:06,730 --> 00:16:11,410
if your hypervisor doesn't correctly

00:16:08,709 --> 00:16:12,730
flush to your B's then it works in key

00:16:11,410 --> 00:16:13,870
mu but it won't but then you've run a

00:16:12,730 --> 00:16:17,110
hardware and it doesn't work

00:16:13,870 --> 00:16:18,730
so we'd like to change it to flush at

00:16:17,110 --> 00:16:22,360
least the right virtualization mode

00:16:18,730 --> 00:16:24,100
based on s bench or - H vents depending

00:16:22,360 --> 00:16:26,470
on what we can do there so we should be

00:16:24,100 --> 00:16:28,779
able to do that updates all aspects as

00:16:26,470 --> 00:16:30,100
is there again and in the nested

00:16:28,779 --> 00:16:32,199
virtualization so I talked about at the

00:16:30,100 --> 00:16:33,699
start it's in the spec but it's not in

00:16:32,199 --> 00:16:35,980
CHEM you we just haven't connected it

00:16:33,699 --> 00:16:38,589
and we have to test it and then 32v

00:16:35,980 --> 00:16:41,380
guest Linux 32-bit Linux guests don't

00:16:38,589 --> 00:16:42,699
work so it's a figure out why if anyone

00:16:41,380 --> 00:16:45,699
also has an idea on that that's a good

00:16:42,699 --> 00:16:47,380
one in the review so now I'm going to

00:16:45,699 --> 00:16:50,010
hand it over to a new who's going to

00:16:47,380 --> 00:16:50,010
talk about KVM

00:16:53,509 --> 00:17:00,029
thanks a distr so i'm Anoop i'll be

00:16:57,180 --> 00:17:04,199
talking about this five board of the KVM

00:17:00,029 --> 00:17:05,850
hypervisor yeah so it's like the first

00:17:04,199 --> 00:17:09,750
type 2 hypervisor for there is five

00:17:05,850 --> 00:17:11,280
world and and the reason why edge

00:17:09,750 --> 00:17:13,770
extension as I mentioned is very well

00:17:11,280 --> 00:17:15,030
suited for the KVM hyper and partly also

00:17:13,770 --> 00:17:18,839
because we have been giving a lot of

00:17:15,030 --> 00:17:21,809
feedback from the start itself from two

00:17:18,839 --> 00:17:24,209
different hypervisor perspectives so for

00:17:21,809 --> 00:17:27,900
KVM is Phi the host Linux will be

00:17:24,209 --> 00:17:30,780
running unmodified in a chess more only

00:17:27,900 --> 00:17:34,260
the the KVM is Phi kernel model would be

00:17:30,780 --> 00:17:36,630
using the H extension CSRs and the guest

00:17:34,260 --> 00:17:40,410
Linux also will run unmodified in the vs

00:17:36,630 --> 00:17:43,110
mode and yeah these are the same layers

00:17:40,410 --> 00:17:45,030
of the software which he showed and the

00:17:43,110 --> 00:17:49,230
color coding is different based on the

00:17:45,030 --> 00:17:51,720
privilege mode they run in and so some

00:17:49,230 --> 00:17:54,450
of the key aspects of the initial KVM

00:17:51,720 --> 00:17:55,919
report are as follows like so we have

00:17:54,450 --> 00:17:58,620
ensure that we really don't introduce

00:17:55,919 --> 00:18:01,230
any respite specific heavy metal in the

00:17:58,620 --> 00:18:04,049
ABI so far we have tried to ensure that

00:18:01,230 --> 00:18:05,970
and and the world switch is so far

00:18:04,049 --> 00:18:08,070
minimal and we hope that there won't be

00:18:05,970 --> 00:18:08,970
much changes in the world switch in

00:18:08,070 --> 00:18:11,100
future as well

00:18:08,970 --> 00:18:13,740
and most of the savior stories done in

00:18:11,100 --> 00:18:16,110
the load and put interface through the

00:18:13,740 --> 00:18:19,260
load input interface and floating point

00:18:16,110 --> 00:18:22,020
is also saved in a lazy way because the

00:18:19,260 --> 00:18:24,450
architecture supports it so we don't

00:18:22,020 --> 00:18:28,409
need to say a floating point for a guest

00:18:24,450 --> 00:18:30,540
guest we CPU is not using it and we have

00:18:28,409 --> 00:18:33,690
KVM one reg interface for the user space

00:18:30,540 --> 00:18:35,929
so so that user space tools the kqm 1

00:18:33,690 --> 00:18:38,700
km2 can access the vc view context and

00:18:35,929 --> 00:18:41,940
for timer an IP emulation is all done in

00:18:38,700 --> 00:18:43,440
kernel space and the emulation or the

00:18:41,940 --> 00:18:46,049
interrupt controller emulation is as of

00:18:43,440 --> 00:18:47,909
now in the user space we might do it in

00:18:46,049 --> 00:18:51,090
in kernel based on the performance gains

00:18:47,909 --> 00:18:54,419
in future and we have huge paid support

00:18:51,090 --> 00:18:58,470
as well for the VMS it works fine so far

00:18:54,419 --> 00:18:59,630
and we also provide SBI to interface to

00:18:58,470 --> 00:19:02,580
the guest

00:18:59,630 --> 00:19:04,530
immunity in kernel of course and an

00:19:02,580 --> 00:19:06,179
unhandled SBI calls will be definitely

00:19:04,530 --> 00:19:07,500
forwarded to km users pay

00:19:06,179 --> 00:19:10,379
so there are a certain calls which you

00:19:07,500 --> 00:19:12,539
really cannot emulate in kernel space so

00:19:10,379 --> 00:19:17,759
we'll be forwarding such calls to user

00:19:12,539 --> 00:19:21,509
space so this are the SBI calls which

00:19:17,759 --> 00:19:25,679
are in kernel so this is the this table

00:19:21,509 --> 00:19:28,559
shows the 0.1 SBI calls and we also have

00:19:25,679 --> 00:19:30,779
a 0.2 SBI spec in draft stage which is

00:19:28,559 --> 00:19:34,169
much small modular and extensible for

00:19:30,779 --> 00:19:37,320
future butts not respect out actually

00:19:34,169 --> 00:19:38,720
hundred percent so SBI is nothing as

00:19:37,320 --> 00:19:41,250
like he mentioned is the PSC ia

00:19:38,720 --> 00:19:43,110
equivalent of the respire it's a syscall

00:19:41,250 --> 00:19:44,909
style interface between the host in the

00:19:43,110 --> 00:19:47,190
guest and the same interface is also

00:19:44,909 --> 00:19:52,110
provided by the platform specific a mode

00:19:47,190 --> 00:19:54,840
from where to the host kernel so this is

00:19:52,110 --> 00:19:56,309
how the traditional KVM run loop looks

00:19:54,840 --> 00:19:59,580
like it's a nested to run loop which

00:19:56,309 --> 00:20:01,590
looks same on across architectures so I

00:19:59,580 --> 00:20:03,840
would I've tried to show this in more in

00:20:01,590 --> 00:20:05,460
context offer is Phi with the same color

00:20:03,840 --> 00:20:09,779
coding like what part of the run rope

00:20:05,460 --> 00:20:11,429
which runs in which privileged mode it's

00:20:09,779 --> 00:20:16,529
obvious like the user space will be

00:20:11,429 --> 00:20:20,279
continuously doing the octal run and in

00:20:16,529 --> 00:20:22,830
the kernel space will be doing the load

00:20:20,279 --> 00:20:24,539
input once when we enter that and then

00:20:22,830 --> 00:20:27,090
the most important function is the world

00:20:24,539 --> 00:20:29,159
switch that we have which does the host

00:20:27,090 --> 00:20:32,039
- guest and gets to host transitions and

00:20:29,159 --> 00:20:34,950
that the usual exit conditions for the

00:20:32,039 --> 00:20:36,360
KVM race via our host interrupts when we

00:20:34,950 --> 00:20:39,240
get the host interrupts will come out of

00:20:36,360 --> 00:20:40,860
the guest mode or it will come out of

00:20:39,240 --> 00:20:43,860
the cache mode when there is MMI or trap

00:20:40,860 --> 00:20:46,110
or an SBI call or in stage 2 trap so

00:20:43,860 --> 00:20:48,659
most of the exits will try to handle in

00:20:46,110 --> 00:20:50,970
kernel as usual in the internal loop

00:20:48,659 --> 00:20:53,700
itself but sometimes like for the MMR

00:20:50,970 --> 00:20:55,409
exists and for the unhandled SBI calls

00:20:53,700 --> 00:20:56,970
as because which cannot handle in the

00:20:55,409 --> 00:20:59,009
kernel space will be forwarding back to

00:20:56,970 --> 00:21:03,500
the user space so right now there are

00:20:59,009 --> 00:21:07,259
only two such calls which is the console

00:21:03,500 --> 00:21:10,100
from bottoms last so console put car and

00:21:07,259 --> 00:21:13,500
get car so which is like VM specific so

00:21:10,100 --> 00:21:16,320
so these are used for early prints and

00:21:13,500 --> 00:21:18,750
debugging so this cannot be emulated in

00:21:16,320 --> 00:21:20,880
kernel so we forward this right now to

00:21:18,750 --> 00:21:24,150
user space so in future there will be

00:21:20,880 --> 00:21:26,220
vendor extensions in SBI zero to zero or

00:21:24,150 --> 00:21:28,130
to defined so for those kind of SBI

00:21:26,220 --> 00:21:32,370
calls will be forwarding to user space

00:21:28,130 --> 00:21:34,800
and this is another high-level view of

00:21:32,370 --> 00:21:38,880
the internal KVM group mentioned in the

00:21:34,800 --> 00:21:39,990
previous slide so it does lot more

00:21:38,880 --> 00:21:42,000
things than shown over here of course

00:21:39,990 --> 00:21:43,800
but we have tried to highlight the

00:21:42,000 --> 00:21:47,070
important parts of it so first thing it

00:21:43,800 --> 00:21:49,080
does is try to check if the octal run is

00:21:47,070 --> 00:21:51,570
called after an mm IO emulation

00:21:49,080 --> 00:21:53,940
handled in the user space or it was an

00:21:51,570 --> 00:21:58,530
SBI called and handled in the user space

00:21:53,940 --> 00:22:00,840
and then the in the the loop itself we

00:21:58,530 --> 00:22:04,070
flush the interrupts just before

00:22:00,840 --> 00:22:07,080
entering the VM or the guest and and

00:22:04,070 --> 00:22:08,970
when we hit an exit condition we first

00:22:07,080 --> 00:22:11,370
sync up the interest because there are

00:22:08,970 --> 00:22:13,320
certain bits in the vs IP registers what

00:22:11,370 --> 00:22:16,470
he mentioned like the which can be

00:22:13,320 --> 00:22:18,150
updated directly by the guest:we CPU so

00:22:16,470 --> 00:22:24,710
we sync up the interrupts and then

00:22:18,150 --> 00:22:26,850
process the exit so PCP interrupts are

00:22:24,710 --> 00:22:31,260
modeled in a quite unique way at least

00:22:26,850 --> 00:22:33,270
for there is five port of k vm and we

00:22:31,260 --> 00:22:35,490
modeled it around multiple producer

00:22:33,270 --> 00:22:39,540
single consumer it's totally lock lists

00:22:35,490 --> 00:22:43,200
we don't have any locks so basically we

00:22:39,540 --> 00:22:46,260
have two atomic bitmaps which we update

00:22:43,200 --> 00:22:48,330
using B tops atomic power is why so one

00:22:46,260 --> 00:22:51,780
is irq spending we see replacing the

00:22:48,330 --> 00:22:54,180
current state of the interrupts of that

00:22:51,780 --> 00:22:56,630
V CPU and there is ir q pending mass

00:22:54,180 --> 00:22:58,590
which is if there is any changing in the

00:22:56,630 --> 00:23:02,340
previous models ir people means then

00:22:58,590 --> 00:23:05,070
that bit will be set so we have various

00:23:02,340 --> 00:23:07,590
sources of injecting the interrupts one

00:23:05,070 --> 00:23:09,300
is a user space itself where the leak

00:23:07,590 --> 00:23:10,740
emulation or the interpreter emulation

00:23:09,300 --> 00:23:13,710
in the user space wants to trigger an

00:23:10,740 --> 00:23:16,080
interrupt then we have a timer

00:23:13,710 --> 00:23:18,540
even's getting expired in the KVM kernel

00:23:16,080 --> 00:23:22,020
model for the VCO and then we also have

00:23:18,540 --> 00:23:24,840
IP is injected from other VCO vcp of the

00:23:22,020 --> 00:23:26,880
same vm injector using SBI calls so we

00:23:24,840 --> 00:23:29,890
have multiple producers and in future it

00:23:26,880 --> 00:23:32,650
might even increase so

00:23:29,890 --> 00:23:34,240
that's why it's modeled around multiple

00:23:32,650 --> 00:23:36,100
producer and in single consumer the

00:23:34,240 --> 00:23:37,570
consumer is just the run loop the run

00:23:36,100 --> 00:23:39,250
loop will be consuming all the changes

00:23:37,570 --> 00:23:45,010
in the arc is spending and pending mass

00:23:39,250 --> 00:23:45,669
and flashing it to hardware so the wall

00:23:45,010 --> 00:23:47,500
switch

00:23:45,669 --> 00:23:49,150
like I mentioned does the host to guess

00:23:47,500 --> 00:23:51,010
and goes to hoe switching it's totally

00:23:49,150 --> 00:23:52,780
written in assembly it has to be done

00:23:51,010 --> 00:23:56,919
with interrupts disabled to ensure

00:23:52,780 --> 00:23:59,350
atomicity and right now to give some

00:23:56,919 --> 00:24:04,659
numbers the kind of overhead where what

00:23:59,350 --> 00:24:10,120
we have is we save 24 CSR's GPR sorry

00:24:04,659 --> 00:24:12,789
and for CSRs and restore 3 CSRs and 31

00:24:10,120 --> 00:24:14,740
GPRS roughly when we do host to guest

00:24:12,789 --> 00:24:17,440
and the reverse when we do gets to host

00:24:14,740 --> 00:24:20,020
and the most important part is when we

00:24:17,440 --> 00:24:22,900
are in guest mode the HS mode or the

00:24:20,020 --> 00:24:26,049
hypervisor sty points to the return path

00:24:22,900 --> 00:24:28,720
and the Eskridge of the HS mode points

00:24:26,049 --> 00:24:32,620
to the PCP you context so this helps us

00:24:28,720 --> 00:24:35,590
get the register step back and ensure

00:24:32,620 --> 00:24:40,679
that we return to the same place when

00:24:35,590 --> 00:24:43,600
when the exit happens and this is like

00:24:40,679 --> 00:24:46,480
current state of the V CPU context we

00:24:43,600 --> 00:24:48,309
only have GPRS CSRs and some FP races

00:24:46,480 --> 00:24:50,049
but this will definitely grow once we

00:24:48,309 --> 00:24:52,840
have more respire extensions like vector

00:24:50,049 --> 00:24:54,429
extension is already in pipeline so this

00:24:52,840 --> 00:24:55,600
context will keep growing but we don't

00:24:54,429 --> 00:24:59,169
hope that there will be much in this

00:24:55,600 --> 00:25:01,570
with the world switch and like I

00:24:59,169 --> 00:25:04,049
mentioned we are providing one reg

00:25:01,570 --> 00:25:07,480
interface to the user space for

00:25:04,049 --> 00:25:09,490
accessing the V CPU context and we have

00:25:07,480 --> 00:25:13,690
five types of one register was config

00:25:09,490 --> 00:25:16,120
resistor Co registers CSR's fpf and FPSO

00:25:13,690 --> 00:25:18,429
fpf is 32-bit floating point and FPD is

00:25:16,120 --> 00:25:20,230
64-bit floating so most important one is

00:25:18,429 --> 00:25:21,940
the Isaac configuration set which tells

00:25:20,230 --> 00:25:24,070
the capabilities of the VCU that we are

00:25:21,940 --> 00:25:27,820
providing to the VM and this can only be

00:25:24,070 --> 00:25:29,799
written before running that we CPU we

00:25:27,820 --> 00:25:33,340
cannot update it after the vc p is

00:25:29,799 --> 00:25:35,620
already running so current current

00:25:33,340 --> 00:25:37,179
status in future word so patches are

00:25:35,620 --> 00:25:41,740
already sent out the first version was

00:25:37,179 --> 00:25:43,120
sent out in July 29th and then it was

00:25:41,740 --> 00:25:45,940
reviewed quite fast like the

00:25:43,120 --> 00:25:48,490
by v6 we only had most of the pages

00:25:45,940 --> 00:25:54,070
reviews direct and recently we send out

00:25:48,490 --> 00:25:55,900
v9 of the KVM respire and then KVM tool

00:25:54,070 --> 00:25:58,330
and cue matches are still blocked

00:25:55,900 --> 00:26:01,090
because we want KVM respite to be merged

00:25:58,330 --> 00:26:04,000
in colonel first so this is the first

00:26:01,090 --> 00:26:06,430
link is the official location of the our

00:26:04,000 --> 00:26:08,820
km recyclate repo and then we also

00:26:06,430 --> 00:26:11,740
created a wiki which will help users

00:26:08,820 --> 00:26:13,600
right now we just have one useful page

00:26:11,740 --> 00:26:18,390
to help you just start and play around

00:26:13,600 --> 00:26:20,380
with KVM rely on qmo for doing a 64 bit

00:26:18,390 --> 00:26:23,350
yeah there are a lot of things to still

00:26:20,380 --> 00:26:27,570
do actually we have to move to the new

00:26:23,350 --> 00:26:31,210
draft 0.4 0.5 get a two bit working

00:26:27,570 --> 00:26:33,760
bring up on real hardware then SBI 0.2

00:26:31,210 --> 00:26:36,090
is there in pipeline and we need trace

00:26:33,760 --> 00:26:38,380
points upwards KVM unit test support

00:26:36,090 --> 00:26:40,090
vector a constriction shouldn't be

00:26:38,380 --> 00:26:44,920
virtualized when they land in the spec

00:26:40,090 --> 00:26:49,090
so and upstream the KVM tool and qumu

00:26:44,920 --> 00:26:51,400
changes as well in canal accumulation is

00:26:49,090 --> 00:26:53,380
also being considered based on the

00:26:51,400 --> 00:26:55,330
performance gains then eventually

00:26:53,380 --> 00:26:59,860
migration support leeward support and so

00:26:55,330 --> 00:27:08,580
forth yep so i have at my guess we have

00:26:59,860 --> 00:27:12,460
time so i will quickly show running a vm

00:27:08,580 --> 00:27:16,300
on cue with huge position without huge

00:27:12,460 --> 00:27:17,680
pieces so i mean i don't have time to

00:27:16,300 --> 00:27:26,320
just compile everything and it will take

00:27:17,680 --> 00:27:31,530
time so so we just booted a host with

00:27:26,320 --> 00:27:34,420
the k vm patch is applied it's 5.4 rc3

00:27:31,530 --> 00:27:36,490
so when the k vm kernel module is like

00:27:34,420 --> 00:27:39,880
built-in not pluggable but we can just

00:27:36,490 --> 00:27:44,670
even plug it at 11:00 time and will

00:27:39,880 --> 00:27:44,670
create vm with two V CPUs

00:27:46,540 --> 00:27:50,560
and meanwhile weakened equations

00:28:03,460 --> 00:28:08,629
so Eisen as I understand it this is one

00:28:06,769 --> 00:28:11,749
case where we have some sort of hardware

00:28:08,629 --> 00:28:14,440
software core design and I was wondering

00:28:11,749 --> 00:28:18,590
if you had given some consideration to

00:28:14,440 --> 00:28:22,580
having your two-level page having

00:28:18,590 --> 00:28:25,220
basically an 88 2 GPA cache or page

00:28:22,580 --> 00:28:27,679
table or something you know instead of

00:28:25,220 --> 00:28:30,320
having group - it's two levels of look

00:28:27,679 --> 00:28:33,549
at and whether you had tried to evaluate

00:28:30,320 --> 00:28:37,759
whether they this would save time or

00:28:33,549 --> 00:28:39,649
well you know a discussion about that to

00:28:37,759 --> 00:28:41,419
know whether they had considered a cache

00:28:39,649 --> 00:28:44,840
or consider the page table to do that or

00:28:41,419 --> 00:28:45,980
discuss that I guess for that it's kind

00:28:44,840 --> 00:28:50,509
of a bigger change for the spec

00:28:45,980 --> 00:28:53,480
perspective but yeah when it's not

00:28:50,509 --> 00:28:55,700
considered I think and which maybe can

00:28:53,480 --> 00:28:58,940
be brought up actually but I think at

00:28:55,700 --> 00:29:01,639
this stage I don't know how big changes

00:28:58,940 --> 00:29:03,830
the spec folks are ready to take so it's

00:29:01,639 --> 00:29:05,960
almost free they are not doing any

00:29:03,830 --> 00:29:09,080
breaking changes anymore to the spec but

00:29:05,960 --> 00:29:18,200
this hasn't discussed as the spec was

00:29:09,080 --> 00:29:20,179
brought up so the the question is

00:29:18,200 --> 00:29:21,950
whether so from what I saw I think on

00:29:20,179 --> 00:29:28,759
slide 8 or something like that

00:29:21,950 --> 00:29:33,129
the two levels are hva - no so I guess

00:29:28,759 --> 00:29:36,590
VA just yesterday and then I guess PA to

00:29:33,129 --> 00:29:39,019
host PA and I was wondering about a

00:29:36,590 --> 00:29:41,570
cache or a page table maintained by

00:29:39,019 --> 00:29:46,759
software that would do directly guest VA

00:29:41,570 --> 00:29:48,230
to host PA guest we had two hosts PA so

00:29:46,759 --> 00:29:49,509
that the hardware would do only one who

00:29:48,230 --> 00:29:51,740
kept

00:29:49,509 --> 00:29:53,840
so that is possible with unprivileged

00:29:51,740 --> 00:29:56,169
accesses actually so there is something

00:29:53,840 --> 00:29:59,899
called as unprivileged accesses in Y

00:29:56,169 --> 00:30:05,049
where the host or the hypervisor can do

00:29:59,899 --> 00:30:05,049
load stores on behalf of the guest

00:30:05,769 --> 00:30:10,039
not exactly 80 operations of arm but it

00:30:08,539 --> 00:30:11,940
can actually fake the load store

00:30:10,039 --> 00:30:16,020
operations as if been done in the guest

00:30:11,940 --> 00:30:18,540
so that can be used to do full two-stage

00:30:16,020 --> 00:30:22,430
transits from the so that you can access

00:30:18,540 --> 00:30:32,670
the guest vs like a guest would access

00:30:22,430 --> 00:30:36,300
directly and you can okay

00:30:32,670 --> 00:30:41,370
I think the TLB the way the instruction

00:30:36,300 --> 00:30:43,980
set is designed you can have combine

00:30:41,370 --> 00:30:47,790
translations in the TLB I don't know if

00:30:43,980 --> 00:30:49,440
there's any hardware that does that

00:30:47,790 --> 00:30:51,000
actually don't know if there's any

00:30:49,440 --> 00:30:54,180
hardware that does the hypervisor

00:30:51,000 --> 00:30:56,160
extension at all but it's certainly not

00:30:54,180 --> 00:30:58,350
forbidden by the spec to have combined

00:30:56,160 --> 00:31:01,020
translations in the TLB so that you do

00:30:58,350 --> 00:31:05,100
two lookups when you have a TLB means

00:31:01,020 --> 00:31:09,270
but then the TLB does the combine the

00:31:05,100 --> 00:31:11,550
translation and I think that you can

00:31:09,270 --> 00:31:15,210
disable the stage two translation like

00:31:11,550 --> 00:31:18,300
it's always there but the the h g8 p can

00:31:15,210 --> 00:31:19,770
be like no page table yeah and then you

00:31:18,300 --> 00:31:22,440
only have one and you can do shadow

00:31:19,770 --> 00:31:24,060
paging in KVM but it's not done yet and

00:31:22,440 --> 00:31:29,880
then nothing yet you plan to do it I

00:31:24,060 --> 00:31:33,270
guess yeah so the guest is booted like

00:31:29,880 --> 00:31:35,040
we have two V CPUs a very quick question

00:31:33,270 --> 00:31:43,620
are you going to implement this in

00:31:35,040 --> 00:31:45,930
swerve so always like I'm not only CPU

00:31:43,620 --> 00:31:48,770
right now a little bit maybe in future

00:31:45,930 --> 00:31:48,770
they might go that route

00:31:57,560 --> 00:32:02,470
I'll quickly run with huge faces as well

00:32:02,620 --> 00:32:07,820
hi so I think that and maybe some of

00:32:06,230 --> 00:32:09,920
will disagree with me but I think that

00:32:07,820 --> 00:32:12,050
one of the mistakes that we did in a KVM

00:32:09,920 --> 00:32:15,920
Intel model is that currently the only

00:32:12,050 --> 00:32:17,570
way to specify to it which a vm mix

00:32:15,920 --> 00:32:20,390
features with harder virtualization

00:32:17,570 --> 00:32:21,830
extension to use is only based on hard

00:32:20,390 --> 00:32:24,530
work of abilities and current model

00:32:21,830 --> 00:32:26,480
parameters and I I personally dislike

00:32:24,530 --> 00:32:28,850
this because I think it a lot of times

00:32:26,480 --> 00:32:31,910
you want to control it in a per VM basis

00:32:28,850 --> 00:32:35,090
instead from user space so just as a tip

00:32:31,910 --> 00:32:38,090
I think that your KVM risk v model and I

00:32:35,090 --> 00:32:40,910
think you should not control in kV model

00:32:38,090 --> 00:32:43,340
parameters with hardware a hyper hyper

00:32:40,910 --> 00:32:44,990
extensions you use but instead control

00:32:43,340 --> 00:32:48,620
it from user space to not repeat the

00:32:44,990 --> 00:32:50,990
same mistake I guess most of the

00:32:48,620 --> 00:32:53,510
settings are part V M basis through the

00:32:50,990 --> 00:32:56,990
k vm tool and qmo command line itself so

00:32:53,510 --> 00:32:59,390
today i'm not talking about the like

00:32:56,990 --> 00:33:01,070
cpuid like features exposed to the guest

00:32:59,390 --> 00:33:03,050
I'm talking about what are the actual

00:33:01,070 --> 00:33:07,190
hardware features that you use of the H

00:33:03,050 --> 00:33:10,790
extensions okay so as such an extension

00:33:07,190 --> 00:33:13,700
is pretty much a single feature it's not

00:33:10,790 --> 00:33:16,160
a set of feature as of now so how do you

00:33:13,700 --> 00:33:18,230
it's not like in Dell where there is it

00:33:16,160 --> 00:33:21,080
was built over time with gradually with

00:33:18,230 --> 00:33:23,920
more feature bits so right now is just

00:33:21,080 --> 00:33:26,930
extension means you have this set of

00:33:23,920 --> 00:33:28,820
hypervisor capabilities maybe in future

00:33:26,930 --> 00:33:30,530
when some new hypervisor feature is

00:33:28,820 --> 00:33:33,770
added later on then in that case yeah

00:33:30,530 --> 00:33:35,150
makes sense to have a parameters to to

00:33:33,770 --> 00:33:37,400
stop the kernel module you'll only use

00:33:35,150 --> 00:33:40,100
certain features and I have another

00:33:37,400 --> 00:33:41,780
question does risk V stage - mm you

00:33:40,100 --> 00:33:44,630
because I'm not aware of it does it

00:33:41,780 --> 00:33:46,940
support execute bit that depends on the

00:33:44,630 --> 00:33:50,540
guest privilege mode whether it's

00:33:46,940 --> 00:33:53,180
running on you modo S mode or or is it a

00:33:50,540 --> 00:33:55,190
standard execute bit on the that is

00:33:53,180 --> 00:33:58,250
global so all guest pages are triggered

00:33:55,190 --> 00:34:00,770
like user level pages in stage 2 I'm not

00:33:58,250 --> 00:34:03,170
meaning I don't mean like the references

00:34:00,770 --> 00:34:05,870
to the stage - mm you I'm talking about

00:34:03,170 --> 00:34:08,110
whether I can define a physical page in

00:34:05,870 --> 00:34:11,030
the guest physical address space that is

00:34:08,110 --> 00:34:11,419
executable or not based on whether the

00:34:11,030 --> 00:34:15,049
guest

00:34:11,419 --> 00:34:17,990
is running in humidor s1 so right now

00:34:15,049 --> 00:34:20,419
it's like execute or not execute you can

00:34:17,990 --> 00:34:23,059
specify the execute permissions in stage

00:34:20,419 --> 00:34:25,579
2 page table yeah so the resume applies

00:34:23,059 --> 00:34:27,619
to both as as in you yeah so the reason

00:34:25,579 --> 00:34:29,119
I'm raising that is because if you look

00:34:27,619 --> 00:34:30,829
in the future on for example what

00:34:29,119 --> 00:34:33,500
hyper-v is doing with hypervisor code

00:34:30,829 --> 00:34:36,619
integrity that you want to specify that

00:34:33,500 --> 00:34:38,450
the guest Colonel on only have executed

00:34:36,619 --> 00:34:40,399
pages that are signed but in user mode

00:34:38,450 --> 00:34:42,169
you want to allow everything this is why

00:34:40,399 --> 00:34:44,030
Intel created a field called M back

00:34:42,169 --> 00:34:46,010
which is mode based execution control

00:34:44,030 --> 00:34:48,440
that you can control execute ability

00:34:46,010 --> 00:34:50,210
based on the link of the guest so you

00:34:48,440 --> 00:34:53,569
probably want to add something like that

00:34:50,210 --> 00:34:55,730
in risk V so that you will be able to

00:34:53,569 --> 00:34:57,980
also implement in Linux for example in

00:34:55,730 --> 00:35:01,760
the future hypervisor code integrity

00:34:57,980 --> 00:35:05,720
feature you're sure that's a good

00:35:01,760 --> 00:35:07,490
solution now can be discussed yeah yeah

00:35:05,720 --> 00:35:10,119
so these are guest booting with huge

00:35:07,490 --> 00:35:10,119
faces as well

00:35:17,080 --> 00:35:25,270
instead I think there's one question

00:35:18,760 --> 00:35:27,070
there yeah sure sure if you have more

00:35:25,270 --> 00:35:29,310
questions I wanna discuss please please

00:35:27,070 --> 00:35:31,000
caches will be around for two days Moria

00:35:29,310 --> 00:35:37,010
thank you thank you

00:35:31,000 --> 00:35:43,869
[Applause]

00:35:37,010 --> 00:35:43,869

YouTube URL: https://www.youtube.com/watch?v=2MUka4lKGFU


