Title: [2019] Micro-Optimizing KVM VM-Exits by Andrea Arcangeli
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	Many common workloads aren't sensitive to the VM-Exit performance or they can be optimized through device assignment. The focus of this presentation will be on those workloads that are sensitive to the VM-Exit performance and that cannot avoid triggering high frequency VM-Exits. Those workloads aren't common, but they can materialize in the guest with some applications like databases. Incidentally those are also the workloads that show the biggest impact from the software mitigations of some CPU model speculative execution vulnerabilities.

The KVM x86-64 VM-Exits are already highly optimized, but there is still room for improvement. We'll first analyze the impact of various software mitigations on the VM-Exit execution and then how we can change KVM in order to Micro-Optimize the VM-Exit further, with, but also without, the software mitigations enabled.

---

Andrea Arcangeli
Red Hat
Distinguished Engineer

Andrea Arcangeli joined Red Hat in 2008 because of his interest in working on the KVM Virtualization Hypervisor, with a special interest in virtual machine memory management. He worked on many parts of the Linux Kernel, especially on the Virtual Memory subsystem. Andrea started working with Linux in his spare time shortly after first connecting to the internet back in 1996 while studying at University. He enjoys spending most of his time solving software problems and promoting the adoption of Linux and Open Source software everywhere.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,620 --> 00:00:14,849
hi everyone we can start with micro

00:00:10,380 --> 00:00:17,609
optimizing KVM BM exits so what are we

00:00:14,849 --> 00:00:23,279
going to talk about today and the agenda

00:00:17,609 --> 00:00:25,830
is about the optimization of certain

00:00:23,279 --> 00:00:27,810
workloads which are problematic to be

00:00:25,830 --> 00:00:30,570
utilized efficiently because they

00:00:27,810 --> 00:00:32,610
trigger a little too many BM exits and

00:00:30,570 --> 00:00:35,899
we subscribe kb m there may be ways to

00:00:32,610 --> 00:00:39,120
optimize it in the future but right now

00:00:35,899 --> 00:00:42,870
at least with the upstream k vm this is

00:00:39,120 --> 00:00:44,520
very challenging and we'll see also our

00:00:42,870 --> 00:00:46,590
cup of the different kind of speculative

00:00:44,520 --> 00:00:49,079
speculative execution attacks and

00:00:46,590 --> 00:00:50,730
mitigation I won't talk about hyper

00:00:49,079 --> 00:00:54,899
training SMT that will require an

00:00:50,730 --> 00:00:58,530
additional 30 minutes I think minimum or

00:00:54,899 --> 00:01:00,000
maybe an additional day so basically we

00:00:58,530 --> 00:01:02,039
are going to see the benchmarks and the

00:01:00,000 --> 00:01:04,229
factor of the optimization I'm going to

00:01:02,039 --> 00:01:07,770
propose and I'm going to propose

00:01:04,229 --> 00:01:10,140
specifically two changes one is just an

00:01:07,770 --> 00:01:12,450
optimization in KBM the other one is a

00:01:10,140 --> 00:01:17,040
change in the guest default of the

00:01:12,450 --> 00:01:19,560
mitigations the defaults again so let's

00:01:17,040 --> 00:01:22,890
see there are two vertical workload so

00:01:19,560 --> 00:01:25,259
the most effective way to optimize guest

00:01:22,890 --> 00:01:28,770
mode is to reduce the number of VM exits

00:01:25,259 --> 00:01:30,510
of course for device assignment we ask

00:01:28,770 --> 00:01:33,090
user and

00:01:30,510 --> 00:01:36,030
even then so forth crowd will still

00:01:33,090 --> 00:01:39,060
trigger little too many BMX it's one of

00:01:36,030 --> 00:01:43,560
these are caused by guests scheduling

00:01:39,060 --> 00:01:45,300
events so when the guest CPU goes idle a

00:01:43,560 --> 00:01:47,270
little too often so for that we already

00:01:45,300 --> 00:01:50,600
merged upstream from our solute izzati

00:01:47,270 --> 00:01:53,520
thread out is the CPU oddball driver

00:01:50,600 --> 00:01:56,490
which is an either governor it greatly

00:01:53,520 --> 00:01:59,430
reduce the number of VM exit or

00:01:56,490 --> 00:02:01,950
specifically hard VM exits by spinning

00:01:59,430 --> 00:02:04,320
in the gas instead of spinning in KVM

00:02:01,950 --> 00:02:06,930
and of course it has the risk of wasting

00:02:04,320 --> 00:02:10,619
a little bit of CPU and gas mod if the

00:02:06,930 --> 00:02:13,470
horse isn't idle but generally if you

00:02:10,619 --> 00:02:15,930
dedicate a hardier machine to single

00:02:13,470 --> 00:02:17,670
gasses great optimization to deploy and

00:02:15,930 --> 00:02:20,100
you kind of solve all the VM exit for

00:02:17,670 --> 00:02:22,380
the Hult however there are still guest

00:02:20,100 --> 00:02:25,560
higher solution timers you can program

00:02:22,380 --> 00:02:27,690
the Linux kernel to trigger a timer

00:02:25,560 --> 00:02:30,240
every nanosecond or microsecond or

00:02:27,690 --> 00:02:33,450
whatever it's up to you so for example

00:02:30,240 --> 00:02:37,770
this is an example of source code which

00:02:33,450 --> 00:02:41,130
will create a clock real time with TV

00:02:37,770 --> 00:02:43,080
nanosecond one nanosecond of course

00:02:41,130 --> 00:02:45,600
there's no way it can keep up with that

00:02:43,080 --> 00:02:48,750
so it will just fluid systems with

00:02:45,600 --> 00:02:51,360
continuous overrides of T C deadline

00:02:48,750 --> 00:02:54,180
right M stars in the gas which will

00:02:51,360 --> 00:02:56,160
trigger VM exits then of course k vm vm

00:02:54,180 --> 00:02:58,500
x it will program the preemption timer

00:02:56,160 --> 00:03:00,330
and it will enter again in the gas with

00:02:58,500 --> 00:03:02,430
preemption timers that will fire within

00:03:00,330 --> 00:03:04,470
the guest and it will not cause

00:03:02,430 --> 00:03:07,770
additional vm exit but these are still

00:03:04,470 --> 00:03:10,350
way too many so you can see the most

00:03:07,770 --> 00:03:12,180
frequent is the MSL right and since

00:03:10,350 --> 00:03:13,830
there's pending interrupt in a

00:03:12,180 --> 00:03:15,380
preemption interrupts these are the top

00:03:13,830 --> 00:03:19,380
heavy ones

00:03:15,380 --> 00:03:22,860
so some database incidentally tends to

00:03:19,380 --> 00:03:27,209
be doing exactly that and here are some

00:03:22,860 --> 00:03:29,700
other bases very aware about time it

00:03:27,209 --> 00:03:33,000
wants to have our solution of time to do

00:03:29,700 --> 00:03:34,590
its own bookkeeping and so they tend to

00:03:33,000 --> 00:03:35,940
be a problem to be realize with the

00:03:34,590 --> 00:03:39,510
current model of

00:03:35,940 --> 00:03:41,490
epic and Olympic in KVM so even an

00:03:39,510 --> 00:03:44,270
increase of 10% in the computation time

00:03:41,490 --> 00:03:49,320
of the gas mode is still a big problem

00:03:44,270 --> 00:03:52,290
because every 1% matters if the maximum

00:03:49,320 --> 00:03:54,600
you can lose is 10% so you have certain

00:03:52,290 --> 00:03:58,230
threshold to hit before you can get

00:03:54,600 --> 00:04:02,550
certain certifications and make the

00:03:58,230 --> 00:04:06,720
database happy and everything was kind

00:04:02,550 --> 00:04:09,390
of ok before for January in 2018

00:04:06,720 --> 00:04:11,760
not anymore after that and why is that

00:04:09,390 --> 00:04:14,040
well we will see later levels in the

00:04:11,760 --> 00:04:16,320
benchmark of the fact of the specter

00:04:14,040 --> 00:04:19,049
version to default report rep boolean

00:04:16,320 --> 00:04:20,940
mitigation which frankly I don't think

00:04:19,049 --> 00:04:24,030
it's even thinkable to disable because

00:04:20,940 --> 00:04:26,820
in 10 the KPM it can be attack it from

00:04:24,030 --> 00:04:31,320
the gas I mean this is needed so KVM

00:04:26,820 --> 00:04:32,940
becomes immune from a gas attack and we

00:04:31,320 --> 00:04:35,670
don't know any other way to mitigate it

00:04:32,940 --> 00:04:37,650
which is more efficient and sensors are

00:04:35,670 --> 00:04:40,620
out the review with Spector bypass

00:04:37,650 --> 00:04:42,840
disable which by default is set to auto

00:04:40,620 --> 00:04:44,610
which defines to second if you have

00:04:42,840 --> 00:04:45,870
second pin a bleed and you know

00:04:44,610 --> 00:04:47,490
everybody should have the compa

00:04:45,870 --> 00:04:51,390
neighborhood for security it's a

00:04:47,490 --> 00:04:53,850
fundamental feature so we currently have

00:04:51,390 --> 00:04:56,150
six defaults as gas default and three

00:04:53,850 --> 00:05:00,450
are not good I mean it was good when

00:04:56,150 --> 00:05:02,550
this thing was read on Annenberg day so

00:05:00,450 --> 00:05:05,970
it was kind of casual approach to try to

00:05:02,550 --> 00:05:08,280
catch as much as we can enable SSB but

00:05:05,970 --> 00:05:11,580
by now these things should be changed to

00:05:08,280 --> 00:05:13,740
PR steel and we see later why so the

00:05:11,580 --> 00:05:16,740
idea is if somebody needs a speedy if

00:05:13,740 --> 00:05:19,590
somebody needs STI bp3 should use the

00:05:16,740 --> 00:05:22,830
PRC else or the proper PRC API in linux

00:05:19,590 --> 00:05:25,740
so it's time to use it and not slow down

00:05:22,830 --> 00:05:28,190
sack comp and we'll see also all the vm

00:05:25,740 --> 00:05:30,900
exits if you're running it in the guest

00:05:28,190 --> 00:05:34,380
so let's do a cap off for the attacks

00:05:30,900 --> 00:05:37,440
and this is a very basic picture you

00:05:34,380 --> 00:05:39,870
know but it kind of represent the

00:05:37,440 --> 00:05:41,490
runtime you can have in linux where you

00:05:39,870 --> 00:05:43,350
have the kernel and then you have

00:05:41,490 --> 00:05:45,780
threads running on top of the linux

00:05:43,350 --> 00:05:47,970
scheduler and you can have rank you with

00:05:45,780 --> 00:05:48,920
one task which is waiting to run in a

00:05:47,970 --> 00:05:52,250
single

00:05:48,920 --> 00:05:53,750
tread and then you have all the runnable

00:05:52,250 --> 00:05:55,520
tasks which might be running in user

00:05:53,750 --> 00:06:00,860
mode cause he might be running in gas

00:05:55,520 --> 00:06:03,340
mode so in the most dangerous attack

00:06:00,860 --> 00:06:08,240
that can be mounted with these

00:06:03,340 --> 00:06:12,530
speculative execution issues features in

00:06:08,240 --> 00:06:14,630
the cpu is through either the Siskel's

00:06:12,530 --> 00:06:17,960
if you are in user mode or through the

00:06:14,630 --> 00:06:19,700
BMX it if you are in gas mode and this

00:06:17,960 --> 00:06:22,280
is the most dangerous attack because the

00:06:19,700 --> 00:06:26,390
colonel's is always there it's always

00:06:22,280 --> 00:06:30,490
there available to be attacked and so if

00:06:26,390 --> 00:06:33,830
you just find a way to run a gadget and

00:06:30,490 --> 00:06:35,870
be able to execute Specter version to

00:06:33,830 --> 00:06:38,330
attack on the kernel on a specific

00:06:35,870 --> 00:06:40,670
kernel versions and all you need is to

00:06:38,330 --> 00:06:43,550
be able to run some malicious code and

00:06:40,670 --> 00:06:45,770
then it will be vulnerable you don't

00:06:43,550 --> 00:06:47,210
need to know all the other things you

00:06:45,770 --> 00:06:48,800
need to know to do the other kind of

00:06:47,210 --> 00:06:52,130
attacks which are for example contests

00:06:48,800 --> 00:06:54,890
which attack for example cons which

00:06:52,130 --> 00:06:57,620
attack requires the next task to be

00:06:54,890 --> 00:07:00,020
scheduled to be specifically what you

00:06:57,620 --> 00:07:01,850
want to attack and you don't have a

00:07:00,020 --> 00:07:04,940
guarantee that from schedulers that C is

00:07:01,850 --> 00:07:06,830
going to be scheduled next and so this

00:07:04,940 --> 00:07:08,960
is the second kind of attack again which

00:07:06,830 --> 00:07:10,730
is user land against user land or gas

00:07:08,960 --> 00:07:13,400
mode against user land or gas mode

00:07:10,730 --> 00:07:18,020
against against mode and it generally is

00:07:13,400 --> 00:07:19,880
mitigated by IB BB and LSB fill and I

00:07:18,020 --> 00:07:22,400
didn't say it before the mitigation

00:07:19,880 --> 00:07:24,670
generally for the kernel attack rep

00:07:22,400 --> 00:07:27,770
aleene's again the most important and

00:07:24,670 --> 00:07:30,530
three was fabulous which is needed for

00:07:27,770 --> 00:07:35,540
full security on some ships and worthy

00:07:30,530 --> 00:07:37,490
for MDS and PGI from Melda and so if we

00:07:35,540 --> 00:07:40,420
go ahead with the contest which attack

00:07:37,490 --> 00:07:44,530
we have the IBP be and RS be filled and

00:07:40,420 --> 00:07:46,850
HTS empty attack SCA vp or of course

00:07:44,530 --> 00:07:51,050
disabling hyper-threading is required on

00:07:46,850 --> 00:07:53,330
some CPU and si I've seen a presentation

00:07:51,050 --> 00:07:54,650
yesterday very interesting I didn't

00:07:53,330 --> 00:07:57,860
mention the course scheduler here

00:07:54,650 --> 00:08:01,790
because unless you do a IQ binding to

00:07:57,860 --> 00:08:04,070
keep the IQs away from the be CPU gas

00:08:01,790 --> 00:08:06,590
this is not completely equivalent to

00:08:04,070 --> 00:08:10,310
know as some teen and disabling a per

00:08:06,590 --> 00:08:12,200
trailing so I was optimistic that the

00:08:10,310 --> 00:08:15,860
presentations in yesterday also covered

00:08:12,200 --> 00:08:18,470
that with an IP I sending as an IP I

00:08:15,860 --> 00:08:21,380
which could actually fix it is still

00:08:18,470 --> 00:08:24,110
uncertain of us but it is it makes me

00:08:21,380 --> 00:08:26,510
optimistic then a search within process

00:08:24,110 --> 00:08:29,090
G's attack and does SSP D so generally

00:08:26,510 --> 00:08:32,330
you need a speedy when you want to

00:08:29,090 --> 00:08:34,310
prevent a jetted code to attack the G

00:08:32,330 --> 00:08:37,310
itself so it's actually within the

00:08:34,310 --> 00:08:41,150
process and we see later that this is

00:08:37,310 --> 00:08:44,000
quite rare as a use case but these are

00:08:41,150 --> 00:08:50,000
pretty much all the use cases that you

00:08:44,000 --> 00:08:52,790
can worry about and let's see now on KVM

00:08:50,000 --> 00:08:54,740
what happens with reliance so again I

00:08:52,790 --> 00:08:57,710
said rappeling is the highest

00:08:54,740 --> 00:09:00,110
performance mitigation that we can do

00:08:57,710 --> 00:09:03,230
for a specter virtue attack on k vm and

00:09:00,110 --> 00:09:05,170
on some CPU its full fix on some cpu

00:09:03,230 --> 00:09:08,980
just the risk of an attack is low and

00:09:05,170 --> 00:09:13,610
technical jargon is the risk of

00:09:08,980 --> 00:09:15,860
exploiting typical stacks is low so it's

00:09:13,610 --> 00:09:18,110
not zero so in 30p you for example on

00:09:15,860 --> 00:09:20,240
rel you get a warrant in the boot log

00:09:18,110 --> 00:09:22,310
that you can obtain on the specter

00:09:20,240 --> 00:09:24,740
version 2 equal IBRS on your source

00:09:22,310 --> 00:09:27,800
chips where rappeling is not a full fix

00:09:24,740 --> 00:09:29,540
and so it's up to you if you if you want

00:09:27,800 --> 00:09:32,500
to have the full fix of course it

00:09:29,540 --> 00:09:36,530
becomes a bit slower and then k vm a

00:09:32,500 --> 00:09:41,000
course k vm into kb m dot Kyoko's okay

00:09:36,530 --> 00:09:46,160
vm md dot KO at every BMX it multiple

00:09:41,000 --> 00:09:49,820
time and that is because of the k vm x86

00:09:46,160 --> 00:09:51,890
ops structure which is full of pointer

00:09:49,820 --> 00:09:54,800
to functions and all these pointers

00:09:51,890 --> 00:09:58,930
functions in practice they all become

00:09:54,800 --> 00:10:02,840
rap lines so even the highest-performing

00:09:58,930 --> 00:10:06,050
mitigation is still triggering a wall

00:10:02,840 --> 00:10:08,210
lot of rap lines depending of which

00:10:06,050 --> 00:10:12,080
implementation used doesn't matter

00:10:08,210 --> 00:10:14,810
because still the k vm x86 opt structure

00:10:12,080 --> 00:10:17,570
so

00:10:14,810 --> 00:10:21,180
see the result with the current upstream

00:10:17,570 --> 00:10:24,360
5.3 colonel well it's not exactly the

00:10:21,180 --> 00:10:26,339
latest but I ran it like last month so

00:10:24,360 --> 00:10:29,640
you can see there is huge number of

00:10:26,339 --> 00:10:35,610
wrappings happening every second on HD

00:10:29,640 --> 00:10:38,160
timer workload and on SVM is similar so

00:10:35,610 --> 00:10:41,220
what are we doing to optimize is so

00:10:38,160 --> 00:10:45,510
there is to remove completely k vm k and

00:10:41,220 --> 00:10:48,060
k vm x is six ops pv ops could also

00:10:45,510 --> 00:10:51,180
optimize it but it will not optimize the

00:10:48,060 --> 00:10:52,350
itlp cost so and some time people trust

00:10:51,180 --> 00:10:55,019
me well we can do self-modifying code

00:10:52,350 --> 00:10:57,990
yes you can but then you're still having

00:10:55,019 --> 00:11:00,510
two different models and the cpu will

00:10:57,990 --> 00:11:02,730
have to load different I TLB is for when

00:11:00,510 --> 00:11:06,690
depending if you are executing a VM or

00:11:02,730 --> 00:11:08,579
the k vm intel and KVM AMD the only

00:11:06,690 --> 00:11:11,820
downsides really is a few megabytes of

00:11:08,579 --> 00:11:13,560
disk space loss in /lib modules they

00:11:11,820 --> 00:11:15,750
don't think anybody cares but that a

00:11:13,560 --> 00:11:18,300
bigger more about saving half a kilobyte

00:11:15,750 --> 00:11:21,959
of RAM I think which will happen

00:11:18,300 --> 00:11:23,640
so of course was very relevant and so

00:11:21,959 --> 00:11:25,500
that's really what's going to happen

00:11:23,640 --> 00:11:27,690
with modification I'm suggesting and

00:11:25,500 --> 00:11:30,630
it's totally fine because you know you

00:11:27,690 --> 00:11:32,550
cannot Road KVM Intel and KB MD MD at

00:11:30,630 --> 00:11:35,430
the same time anyway there's no way just

00:11:32,550 --> 00:11:38,190
another constraint and sees what happens

00:11:35,430 --> 00:11:40,920
now with my patch applied which will

00:11:38,190 --> 00:11:43,110
simply convert all the pointer to

00:11:40,920 --> 00:11:44,670
function to external calls and it will

00:11:43,110 --> 00:11:46,560
implement it with the same name in the

00:11:44,670 --> 00:11:48,300
two different models of course then the

00:11:46,560 --> 00:11:51,180
question is what happens to kb m dot k

00:11:48,300 --> 00:11:59,850
oh well you just link all the objects to

00:11:51,180 --> 00:12:02,430
both k vm in toe and KVM AMD so there's

00:11:59,850 --> 00:12:05,699
something still to do not enough to just

00:12:02,430 --> 00:12:07,920
remove hold the k vm x86 oops you also

00:12:05,699 --> 00:12:11,430
have to reduce one other case which is

00:12:07,920 --> 00:12:13,290
the BMX handler the vm exit andrew is

00:12:11,430 --> 00:12:15,990
using a pointer to function which is

00:12:13,290 --> 00:12:18,329
actually justified and actually

00:12:15,990 --> 00:12:20,699
transferred without reliance unlike the

00:12:18,329 --> 00:12:23,040
rest that we are optimizing which is

00:12:20,699 --> 00:12:24,959
also good without reliance so what we

00:12:23,040 --> 00:12:26,810
are doing with the k vm monolithic is

00:12:24,959 --> 00:12:30,170
improving performance regardless even

00:12:26,810 --> 00:12:32,900
when ultimate aggression are off while

00:12:30,170 --> 00:12:34,550
this one we are going to use a configure

00:12:32,900 --> 00:12:36,620
Pauline you know we can argue about

00:12:34,550 --> 00:12:40,100
implementation but that's the basic idea

00:12:36,620 --> 00:12:42,230
and we'll just only optimize those exit

00:12:40,100 --> 00:12:44,300
that are the most frequent also the one

00:12:42,230 --> 00:12:45,680
we should optimize is also up to fourth

00:12:44,300 --> 00:12:49,029
discussion but that's the basic idea

00:12:45,680 --> 00:12:53,180
again so we'll see the result with the

00:12:49,029 --> 00:12:57,260
patch applied so these other planes are

00:12:53,180 --> 00:12:59,720
gone and the same is true with SVM

00:12:57,260 --> 00:13:02,089
except the workload changes a little bit

00:12:59,720 --> 00:13:05,720
actually gets even more hits on K time

00:13:02,089 --> 00:13:08,720
get and those BPF I've used vpf tracing

00:13:05,720 --> 00:13:10,520
for measuring C's profiling so the

00:13:08,720 --> 00:13:13,400
profiling is not fully accurate can lose

00:13:10,520 --> 00:13:15,560
man so don't look at the face value of

00:13:13,400 --> 00:13:17,810
the number just the relative number

00:13:15,560 --> 00:13:20,000
especially there's no KBM code left to

00:13:17,810 --> 00:13:22,339
optimize the possible position in the

00:13:20,000 --> 00:13:25,580
kernel to optimize the planes but not in

00:13:22,339 --> 00:13:27,589
KVM and now I'm going to show the result

00:13:25,580 --> 00:13:29,180
with the micro benchmark and maybe you

00:13:27,589 --> 00:13:32,750
should spend one more second on the

00:13:29,180 --> 00:13:35,360
disclaimer which is no these numbers

00:13:32,750 --> 00:13:37,580
should not be taken at face value to see

00:13:35,360 --> 00:13:39,920
our micro benchmark real application

00:13:37,580 --> 00:13:43,130
won't be even close to what this number

00:13:39,920 --> 00:13:44,900
going to show so you cannot assume this

00:13:43,130 --> 00:13:47,240
is real impact of the mitigations it's

00:13:44,900 --> 00:13:49,580
just the impact of the BMX it

00:13:47,240 --> 00:13:51,230
vmx it alone and the BMX it you know can

00:13:49,580 --> 00:13:56,690
be slow the application can still be

00:13:51,230 --> 00:13:58,910
very fast so we are going to do 1

00:13:56,690 --> 00:14:01,640
million cpu instruction I could have

00:13:58,910 --> 00:14:03,710
used out instruction in instruction

00:14:01,640 --> 00:14:05,900
whatever but it just triggering vm exits

00:14:03,710 --> 00:14:08,480
in userland so it's looping in the guest

00:14:05,900 --> 00:14:10,790
user and doing a single instruction CP

00:14:08,480 --> 00:14:12,220
ready there's no kernel running in

00:14:10,790 --> 00:14:15,440
userland here

00:14:12,220 --> 00:14:17,540
sorry no kernel running in the guest and

00:14:15,440 --> 00:14:20,600
let's start with the basic mitigation

00:14:17,540 --> 00:14:23,480
with the defaults so you have the

00:14:20,600 --> 00:14:26,720
defaults in the in the gas and the

00:14:23,480 --> 00:14:30,080
default in the host so you just ran with

00:14:26,720 --> 00:14:32,839
the standard mitigation and you enable

00:14:30,080 --> 00:14:35,660
Specter version 2 equal off in the host

00:14:32,839 --> 00:14:39,540
so KVM is running and protected without

00:14:35,660 --> 00:14:44,009
rebellions and as you can see is default

00:14:39,540 --> 00:14:46,529
is taking 34% longer in the BM exit

00:14:44,009 --> 00:14:49,290
latency then if you disabled rappeling

00:14:46,529 --> 00:14:52,769
so that's really the thing that the kV a

00:14:49,290 --> 00:14:54,959
monolithic is meant to optimize then we

00:14:52,769 --> 00:14:57,120
keep going we also disable Spectre

00:14:54,959 --> 00:14:59,190
bypass and nothing happens because this

00:14:57,120 --> 00:15:02,250
again is would only affect second jail

00:14:59,190 --> 00:15:04,319
and the KVM VM exit code is running in

00:15:02,250 --> 00:15:06,120
the host kernel not under second

00:15:04,319 --> 00:15:07,980
obviously it's in the kernel so it

00:15:06,120 --> 00:15:10,079
doesn't change the thing now you disable

00:15:07,980 --> 00:15:11,639
element you have well why did it get

00:15:10,079 --> 00:15:13,980
slower well there's a good explanation

00:15:11,639 --> 00:15:17,339
for that because by default I want you

00:15:13,980 --> 00:15:19,589
have only does l1 flash conditionally to

00:15:17,339 --> 00:15:23,850
the neither up having happenin tour or a

00:15:19,589 --> 00:15:25,319
heavyweight exit having happen and if

00:15:23,850 --> 00:15:27,269
you disable element you have it will

00:15:25,319 --> 00:15:30,649
start doing instead of l1 flash it will

00:15:27,269 --> 00:15:32,910
start doing an unconditional per beam

00:15:30,649 --> 00:15:34,889
instruction to flush the micro

00:15:32,910 --> 00:15:36,569
architectural buffers and that's

00:15:34,889 --> 00:15:38,130
actually slowing down the VM exit but

00:15:36,569 --> 00:15:39,839
probably the gas will still run faster

00:15:38,130 --> 00:15:42,480
because it still retains the l1 cache

00:15:39,839 --> 00:15:45,120
and then we keep going and then

00:15:42,480 --> 00:15:48,600
immediacy of seeing all the overhead is

00:15:45,120 --> 00:15:50,250
gone we are still going fast again pti

00:15:48,600 --> 00:15:50,760
off obviously doesn't change anything

00:15:50,250 --> 00:15:52,860
either

00:15:50,760 --> 00:15:56,069
and the no specter also doesn't change

00:15:52,860 --> 00:15:59,880
anything so again the impact we get in

00:15:56,069 --> 00:16:02,550
KVM from the mitigation after the fourth

00:15:59,880 --> 00:16:05,970
generous doesn't it in the only one we

00:16:02,550 --> 00:16:09,899
really are heat from is specter version

00:16:05,970 --> 00:16:12,029
to Reliance then I also added some opt

00:16:09,899 --> 00:16:14,010
in just for curiosity it's really not

00:16:12,029 --> 00:16:16,500
important nobody should inspect or

00:16:14,010 --> 00:16:19,230
disable on and element you have full of

00:16:16,500 --> 00:16:21,930
ever sees is a little more concerning I

00:16:19,230 --> 00:16:24,600
mean it makes a little more sense than

00:16:21,930 --> 00:16:27,959
doing specs store bypass disable on

00:16:24,600 --> 00:16:31,949
because C is also avoid to leak it the

00:16:27,959 --> 00:16:34,350
BMX it cache contents the internal KVM

00:16:31,949 --> 00:16:36,350
data to the guest so you could imagine

00:16:34,350 --> 00:16:40,259
some setup somebody really really

00:16:36,350 --> 00:16:42,750
concerned to enable the thing it's an

00:16:40,259 --> 00:16:45,630
opt-in obviously so let's start to do

00:16:42,750 --> 00:16:48,260
the same thing but on the guest so we

00:16:45,630 --> 00:16:51,149
are going to see how the guests

00:16:48,260 --> 00:16:52,019
mitigation impacts the KVM BMX its

00:16:51,149 --> 00:16:53,910
performance

00:16:52,019 --> 00:16:56,610
and if we disable Spectre version two

00:16:53,910 --> 00:16:58,860
obviously I said the guest is never

00:16:56,610 --> 00:17:01,589
running in current mode is running a CPD

00:16:58,860 --> 00:17:03,720
loop in userland and when you have

00:17:01,589 --> 00:17:05,039
repellents running in the guests you run

00:17:03,720 --> 00:17:06,659
in the guest Colonel and the gaps

00:17:05,039 --> 00:17:08,120
currently is not running so disabling

00:17:06,659 --> 00:17:10,890
time doesn't change a thing

00:17:08,120 --> 00:17:13,470
let's try to disable Spectre bypass

00:17:10,890 --> 00:17:15,630
disable off well that makes a huge

00:17:13,470 --> 00:17:18,209
difference and why is that

00:17:15,630 --> 00:17:22,980
it is because ii is used by everything

00:17:18,209 --> 00:17:26,100
now and the very first time you use sac

00:17:22,980 --> 00:17:28,620
comp in the gas which means sshd system

00:17:26,100 --> 00:17:34,110
d.c use second and rightfully so

00:17:28,620 --> 00:17:38,039
however with defaults of sac comp in

00:17:34,110 --> 00:17:42,809
Spectre bypass disable and also expect

00:17:38,039 --> 00:17:47,039
Spectre version two user they eventually

00:17:42,809 --> 00:17:48,630
hit on the spec control amateur and by

00:17:47,039 --> 00:17:51,090
modifying it the first time from that

00:17:48,630 --> 00:17:53,190
point on KBM becomes forever slower it's

00:17:51,090 --> 00:17:55,200
not even enough to reboot it you don't

00:17:53,190 --> 00:17:57,570
need to reboot the gas you need to shut

00:17:55,200 --> 00:17:59,220
down the gas so I start a new one and

00:17:57,570 --> 00:18:03,419
then you you can hope to get the

00:17:59,220 --> 00:18:05,610
performance back and so we need to fix

00:18:03,419 --> 00:18:07,559
this in the guest I'm not going to the

00:18:05,610 --> 00:18:10,409
details there's no much time but if you

00:18:07,559 --> 00:18:12,779
download the presentation you put on

00:18:10,409 --> 00:18:15,270
scat or get C's we'd have much more

00:18:12,779 --> 00:18:16,980
explanation of these details so let's

00:18:15,270 --> 00:18:19,049
keep going and you know nothing else

00:18:16,980 --> 00:18:21,149
changes the performance is just you know

00:18:19,049 --> 00:18:25,590
a matter of not touching spec control

00:18:21,149 --> 00:18:28,350
and not using repo lens and so now we

00:18:25,590 --> 00:18:32,039
are going to apply KVM monolithic on top

00:18:28,350 --> 00:18:33,630
of this and see this is the result so if

00:18:32,039 --> 00:18:36,090
you just apply kvl moralistic patch

00:18:33,630 --> 00:18:39,299
which is on linux kernel and and the KBI

00:18:36,090 --> 00:18:41,100
mailing list and you get ready very

00:18:39,299 --> 00:18:43,620
close to the performance or specter

00:18:41,100 --> 00:18:45,779
version to off and if we do both and we

00:18:43,620 --> 00:18:48,450
also fix the default of the kernel the

00:18:45,779 --> 00:18:51,240
vm exit latency will cut it literally

00:18:48,450 --> 00:18:53,370
more than half and that's I think what

00:18:51,240 --> 00:18:56,730
we should aim for and and that's really

00:18:53,370 --> 00:18:58,799
all I want to the message you want to

00:18:56,730 --> 00:19:00,690
give in since presentation is really we

00:18:58,799 --> 00:19:03,559
need to get there where they are points

00:19:00,690 --> 00:19:05,960
and cut the will be emulating enough

00:19:03,559 --> 00:19:12,019
here again the same thing on SPI

00:19:05,960 --> 00:19:15,169
and in SBI Miss interesting the area I'm

00:19:12,019 --> 00:19:17,690
sure which is still required when the

00:19:15,169 --> 00:19:20,659
guest is using sac comp and it's

00:19:17,690 --> 00:19:22,639
modifying SSP D or is modifying as well

00:19:20,659 --> 00:19:26,509
sirs no SDV piece or even a MIDI but

00:19:22,639 --> 00:19:28,909
there is SSB D and when the gas is

00:19:26,509 --> 00:19:30,259
modifying spec control for it it will

00:19:28,909 --> 00:19:32,570
not slow down

00:19:30,259 --> 00:19:35,749
vmx it's probably because our DMS or

00:19:32,570 --> 00:19:37,159
maybe it's faster so I didn't really

00:19:35,749 --> 00:19:40,909
look into it but the important thing is

00:19:37,159 --> 00:19:44,960
kV a moralistic it's still a significant

00:19:40,909 --> 00:19:47,480
improvement also to ambience p.m. on the

00:19:44,960 --> 00:19:51,200
epic and the interesting thing is also

00:19:47,480 --> 00:19:54,259
making the mitigations of case faster

00:19:51,200 --> 00:19:58,850
which is showing we should never had

00:19:54,259 --> 00:20:01,220
this kbm x86 port ops pointer function

00:19:58,850 --> 00:20:03,470
it has always been slower than it should

00:20:01,220 --> 00:20:06,110
have been frankly it was inefficiency

00:20:03,470 --> 00:20:08,629
hiding in plain sight and you know

00:20:06,110 --> 00:20:10,820
having to deal with these issues and the

00:20:08,629 --> 00:20:14,230
regression made me look at it

00:20:10,820 --> 00:20:16,580
and finally and hopefully I fixed it so

00:20:14,230 --> 00:20:20,360
what the state of the patch is very

00:20:16,580 --> 00:20:23,840
mechanic is a huge patch I did it in in

00:20:20,360 --> 00:20:25,759
the most in the safe as possible way I

00:20:23,840 --> 00:20:27,139
could do it which means try not to

00:20:25,759 --> 00:20:30,259
change the logic just change

00:20:27,139 --> 00:20:31,970
implementation and there's still some

00:20:30,259 --> 00:20:34,070
adjustment needed in the cable but you

00:20:31,970 --> 00:20:36,080
know it's just the build system not

00:20:34,070 --> 00:20:37,820
really my worry I mean it's not the code

00:20:36,080 --> 00:20:40,129
that is running its CPU is just the way

00:20:37,820 --> 00:20:42,169
you build it but it's really you know

00:20:40,129 --> 00:20:44,210
building fine thread the only thing

00:20:42,169 --> 00:20:46,789
really which might be new is through

00:20:44,210 --> 00:20:49,999
some warning from the duplicated exports

00:20:46,789 --> 00:20:52,399
because you still have KBM GT is the GPU

00:20:49,999 --> 00:20:55,249
driver which need to call into the KVM

00:20:52,399 --> 00:20:57,740
model and initially well before the

00:20:55,249 --> 00:21:00,529
change it was calling KPMG oh not the

00:20:57,740 --> 00:21:02,659
KVM Intel or KPI Mehmedi and now we

00:21:00,529 --> 00:21:06,769
still need to all of the KPMG T to call

00:21:02,659 --> 00:21:09,139
into kbm and whoever we need to export

00:21:06,769 --> 00:21:11,330
the same symbol from both KVM Intel and

00:21:09,139 --> 00:21:13,519
KVM MD I'm not sure if this is the first

00:21:11,330 --> 00:21:16,519
in the kernel certainly I insist these

00:21:13,519 --> 00:21:17,789
warnings ever before now I see them but

00:21:16,519 --> 00:21:20,190
because you cannot wrote the

00:21:17,789 --> 00:21:22,409
both mother the same time nothing bad is

00:21:20,190 --> 00:21:25,739
happening so far and so we definitely

00:21:22,409 --> 00:21:27,629
want to hide the maybe say I really know

00:21:25,739 --> 00:21:30,960
what I'm doing just shut out the warning

00:21:27,629 --> 00:21:32,369
on this case but this mind requires more

00:21:30,960 --> 00:21:36,929
discussion but I'm not particularly

00:21:32,369 --> 00:21:40,320
concerned and the final cleanup of KVM

00:21:36,929 --> 00:21:42,840
x86 ops is not done in the initial patch

00:21:40,320 --> 00:21:45,600
in the huge patch and for a good reason

00:21:42,840 --> 00:21:47,489
because I want to be as mechanical as

00:21:45,600 --> 00:21:50,460
possible not to change how the code is

00:21:47,489 --> 00:21:52,289
working and to remove it completely you

00:21:50,460 --> 00:21:54,239
need to change all the code is working

00:21:52,289 --> 00:21:56,489
there are some cases where the function

00:21:54,239 --> 00:21:59,580
is not the pointer function is not in

00:21:56,489 --> 00:22:01,889
Pocket unconditionally often is you

00:21:59,580 --> 00:22:03,989
check if it's set and if it's set you

00:22:01,889 --> 00:22:05,849
call it I didn't change this place so

00:22:03,989 --> 00:22:08,249
unless we change these places we cannot

00:22:05,849 --> 00:22:10,950
completely remove it so the idea is

00:22:08,249 --> 00:22:13,679
applied patch and not change our code

00:22:10,950 --> 00:22:16,349
works so if we do something wrong we can

00:22:13,679 --> 00:22:18,539
be sucked it and we won't have to debug

00:22:16,349 --> 00:22:20,849
the huge patch because finding something

00:22:18,539 --> 00:22:25,019
there becomes like finding a needle in a

00:22:20,849 --> 00:22:31,830
haystack so I think that's all if you

00:22:25,019 --> 00:22:34,129
have any question you work on thank you

00:22:31,830 --> 00:22:34,129
very much

00:22:34,489 --> 00:22:41,519
going back to the fact that the hot

00:22:39,899 --> 00:22:46,919
browser gets slower soon as the guests

00:22:41,519 --> 00:22:48,840
touch the spec control I originally

00:22:46,919 --> 00:22:51,419
designed that so that the moment the

00:22:48,840 --> 00:22:52,619
guest first touches it we stop trapping

00:22:51,419 --> 00:22:54,479
and we put it into pass-through mode

00:22:52,619 --> 00:22:57,450
right and that was the correct thing to

00:22:54,479 --> 00:23:00,779
do when it was just IBRS because we

00:22:57,450 --> 00:23:02,669
assume it's windows well and it will

00:23:00,779 --> 00:23:04,470
always be bashing on it should we

00:23:02,669 --> 00:23:07,320
revisit that and what are the criteria

00:23:04,470 --> 00:23:09,419
we should use for when to have it pass

00:23:07,320 --> 00:23:12,389
through so that it's always a cost on VM

00:23:09,419 --> 00:23:14,039
exit and when to go back to trapping yes

00:23:12,389 --> 00:23:17,279
I thought about that too it's a very

00:23:14,039 --> 00:23:18,960
good question especially if your boot if

00:23:17,279 --> 00:23:21,599
your boot the guests it would be nicer

00:23:18,960 --> 00:23:23,580
to mentally we array accentuates the

00:23:21,599 --> 00:23:26,099
interception of the spec contour amateur

00:23:23,580 --> 00:23:28,320
so at least if your boot and you know we

00:23:26,099 --> 00:23:30,029
can probably drop reboot to if your boot

00:23:28,320 --> 00:23:30,390
you change the option in the gas with

00:23:30,029 --> 00:23:32,460
graph

00:23:30,390 --> 00:23:34,590
at least you get the performance back

00:23:32,460 --> 00:23:37,740
after the reboot so that for me will be

00:23:34,590 --> 00:23:41,580
the minimum optimization we should do in

00:23:37,740 --> 00:23:44,040
that front I was aiming and you know I

00:23:41,580 --> 00:23:46,320
have a very long explanation which we

00:23:44,040 --> 00:23:50,090
are going to post an upstream to explain

00:23:46,320 --> 00:23:53,940
why I think the second default for

00:23:50,090 --> 00:23:57,270
Spectre bypass disabled and a Spectre

00:23:53,940 --> 00:24:00,920
version to user is not buying us any

00:23:57,270 --> 00:24:04,590
security and in fact all the pod man and

00:24:00,920 --> 00:24:07,140
kubernetes face and bug reports saying

00:24:04,590 --> 00:24:09,390
you know SEC comp is so much lower in

00:24:07,140 --> 00:24:11,880
the newer currency you know it's not so

00:24:09,390 --> 00:24:14,670
calm it's just wrong default in the

00:24:11,880 --> 00:24:16,530
kernel which is slowing down everything

00:24:14,670 --> 00:24:17,850
for us the AVP and you know I'm just

00:24:16,530 --> 00:24:19,920
going to say the most basic thing

00:24:17,850 --> 00:24:22,950
because again there are so many reasons

00:24:19,920 --> 00:24:24,630
and there's no point to have a CVP set

00:24:22,950 --> 00:24:26,250
if you didn't save all hyper-threading

00:24:24,630 --> 00:24:29,370
because you're still vulnerable from MDS

00:24:26,250 --> 00:24:30,960
and if you're still vulnerable from

00:24:29,370 --> 00:24:32,610
memory is actually worse because you

00:24:30,960 --> 00:24:36,180
cannot even be mitigated by did

00:24:32,610 --> 00:24:39,600
namespaces and address space layout

00:24:36,180 --> 00:24:41,550
randomization which stvp even if you

00:24:39,600 --> 00:24:44,190
don't use it you're still mitigated from

00:24:41,550 --> 00:24:46,680
hyper shredding inspector to inspect the

00:24:44,190 --> 00:24:48,690
Russian to attack because you have maybe

00:24:46,680 --> 00:24:51,030
bid namespaces if even if you don't have

00:24:48,690 --> 00:24:53,780
it you still have other space layout

00:24:51,030 --> 00:24:56,760
randomization on the victim in tasks so

00:24:53,780 --> 00:24:58,680
basically if we fix the defaults then

00:24:56,760 --> 00:25:01,050
the optimization you are suggesting

00:24:58,680 --> 00:25:02,850
which makes perfect sense becomes a

00:25:01,050 --> 00:25:05,250
second ratio because we will never

00:25:02,850 --> 00:25:07,520
modify spoken for by default anyway the

00:25:05,250 --> 00:25:13,170
only case really becomes I'm suggesting

00:25:07,520 --> 00:25:15,330
for the Java and open JDK to use er Co

00:25:13,170 --> 00:25:18,420
not unconditionally because you don't

00:25:15,330 --> 00:25:22,320
want to have SSB reset if you run

00:25:18,420 --> 00:25:23,310
trusted bytecode a button Java ps4 when

00:25:22,320 --> 00:25:25,290
you have their place and you're done

00:25:23,310 --> 00:25:27,360
learning some Java from from the

00:25:25,290 --> 00:25:29,460
internet and all in that case of PR CL

00:25:27,360 --> 00:25:32,040
but that is kind of a desktop or plot it

00:25:29,460 --> 00:25:35,240
will not have an impact on on-premises

00:25:32,040 --> 00:25:35,240
clouds and public clouds

00:25:37,510 --> 00:25:48,409
there's a question there thanks good

00:25:46,669 --> 00:25:50,389
luck I really like the fact that even

00:25:48,409 --> 00:25:54,799
without the mitigation its improves

00:25:50,389 --> 00:25:55,850
performance in 5% it did well 4% not

00:25:54,799 --> 00:25:58,519
only on AMD

00:25:55,850 --> 00:26:00,830
one thing I did I did think it's worth

00:25:58,519 --> 00:26:02,840
mentioning is that there is the case

00:26:00,830 --> 00:26:06,590
that you modified the main exit handler

00:26:02,840 --> 00:26:08,720
to switch case for the very specific

00:26:06,590 --> 00:26:12,200
cases to not do an indirect branch right

00:26:08,720 --> 00:26:14,899
so correct if you use either ASIO you

00:26:12,200 --> 00:26:16,820
use something like the mem equals x this

00:26:14,899 --> 00:26:18,590
I'm not sure that you even need to

00:26:16,820 --> 00:26:20,570
enabled that pulling to begin with

00:26:18,590 --> 00:26:22,519
because the only thing that can be

00:26:20,570 --> 00:26:23,990
actually leaked is the things that are

00:26:22,519 --> 00:26:25,519
mapped in the virtual address space and

00:26:23,990 --> 00:26:27,409
even if you use something like the

00:26:25,519 --> 00:26:29,179
memory physics that limits the virtual

00:26:27,409 --> 00:26:31,100
address space then there is nothing to

00:26:29,179 --> 00:26:32,389
look to begin with and you and in the

00:26:31,100 --> 00:26:34,700
case that you have a house that is

00:26:32,389 --> 00:26:36,470
dedicated for a VM server then you can

00:26:34,700 --> 00:26:37,909
just disable Red Pony and you have

00:26:36,470 --> 00:26:39,980
certain performance it's about the

00:26:37,909 --> 00:26:42,289
performance so basically if you enable

00:26:39,980 --> 00:26:44,630
ESI is via Mexico gets roar anyway

00:26:42,289 --> 00:26:47,539
because of that so we will have to

00:26:44,630 --> 00:26:49,880
evaluate that yeah so so you can just do

00:26:47,539 --> 00:26:52,730
separate protein in general in that case

00:26:49,880 --> 00:26:55,700
yes we also need to see where ice is

00:26:52,730 --> 00:26:58,789
going so I actually like the is I

00:26:55,700 --> 00:27:00,679
approach because it seems to contemplate

00:26:58,789 --> 00:27:03,049
the idea of fixing the interrupts which

00:27:00,679 --> 00:27:04,700
she didn't see the contemplation because

00:27:03,049 --> 00:27:07,070
you know once you run interrupts you

00:27:04,700 --> 00:27:09,679
touch some skb to decide where to send

00:27:07,070 --> 00:27:11,779
skb and that's enough to activate data

00:27:09,679 --> 00:27:15,590
and say nice try running this be damp or

00:27:11,779 --> 00:27:18,139
somebody else vm instead of yours so

00:27:15,590 --> 00:27:20,059
that's that's not cool and it can't be

00:27:18,139 --> 00:27:20,360
solved with binding which becomes you

00:27:20,059 --> 00:27:21,860
know

00:27:20,360 --> 00:27:23,720
binding again we could lose user CPU

00:27:21,860 --> 00:27:25,639
binding anarchy binding without actually

00:27:23,720 --> 00:27:28,010
doing core scheduling so it's something

00:27:25,639 --> 00:27:30,799
we should look into and definitely

00:27:28,010 --> 00:27:33,590
interested to see the developments in a

00:27:30,799 --> 00:27:36,080
sigh so so actually in the in this use I

00:27:33,590 --> 00:27:37,850
think that my personal views that in ASI

00:27:36,080 --> 00:27:39,620
I think that it's more suitable for

00:27:37,850 --> 00:27:41,360
desktop environment but actually if you

00:27:39,620 --> 00:27:43,309
look at the host that is dedicated for a

00:27:41,360 --> 00:27:45,500
VM server actually something like the

00:27:43,309 --> 00:27:46,970
mimic was a technique that just a most

00:27:45,500 --> 00:27:49,520
things from the way others place because

00:27:46,970 --> 00:27:52,820
they also not using these physical pages

00:27:49,520 --> 00:27:55,600
more performance in that case all right

00:27:52,820 --> 00:27:57,400
we'll follow up upstream and offline

00:27:55,600 --> 00:28:01,940
thank you thank you

00:27:57,400 --> 00:28:02,620
all right enjoy

00:28:01,940 --> 00:28:09,860
[Applause]

00:28:02,620 --> 00:28:09,860

YouTube URL: https://www.youtube.com/watch?v=WgMVyvnbJHk


