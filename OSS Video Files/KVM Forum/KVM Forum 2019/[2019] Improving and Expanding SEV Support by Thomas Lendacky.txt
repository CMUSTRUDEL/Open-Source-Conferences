Title: [2019] Improving and Expanding SEV Support by Thomas Lendacky
Publication date: 2019-11-09
Playlist: KVM Forum 2019
Description: 
	AMD continues to improve and expand the support for SEV in the kernel/hypervisor. This talk will focus on the current development activities around SEV, such as eliminating memory pinning, live migration and SEV-ES.

---

Thomas Lendacky
AMD
PMTS Software Engineer

Tom Lendacky is a member of the Linux OS group at Advanced Micro Devices. He is responsible for enabling and enhancing support for AMD processor features in the Linux kernel. He is currently working on extending the SEV support to enable SEV-ES (Secure Encrypted Virtualization - Encrypted State). He has spoken at various Linux events, most recently at KVM Forum 2018.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,890 --> 00:00:13,080
good afternoon everyone my name is Tom

00:00:09,750 --> 00:00:15,410
Ladakhi I we work at AMD and we're going

00:00:13,080 --> 00:00:17,369
to talk about secure encrypted

00:00:15,410 --> 00:00:20,609
virtualization and what we're currently

00:00:17,369 --> 00:00:26,460
working on for improvements and where

00:00:20,609 --> 00:00:28,109
we're going with it for the agenda I'm

00:00:26,460 --> 00:00:32,279
going to give a quick overview quick

00:00:28,109 --> 00:00:35,010
review of SCV in general we're going to

00:00:32,279 --> 00:00:37,140
talk about live migration which just

00:00:35,010 --> 00:00:39,360
kind of came up in the last presentation

00:00:37,140 --> 00:00:42,780
a little bit what we're doing for live

00:00:39,360 --> 00:00:46,530
migration and then this concept of a

00:00:42,780 --> 00:00:50,239
migration helper and then some of the

00:00:46,530 --> 00:00:53,430
performance work we're doing around SCV

00:00:50,239 --> 00:00:56,690
then I'll move on to se ves and give

00:00:53,430 --> 00:00:59,670
kind of a another review of that and

00:00:56,690 --> 00:01:02,239
where we stand on the submission

00:00:59,670 --> 00:01:07,170
upstream it's more of a status overview

00:01:02,239 --> 00:01:10,530
for se ves and then a very very brief

00:01:07,170 --> 00:01:15,080
mention on the next evolution in SE v

00:01:10,530 --> 00:01:15,080
called SNP or secure nested paging

00:01:23,310 --> 00:01:33,150
for a quick review the idea is that SCV

00:01:28,000 --> 00:01:37,150
protects VMs and containers in VMs from

00:01:33,150 --> 00:01:40,230
other VMs from administrator tampering

00:01:37,150 --> 00:01:44,500
and from untrusted hypervisors through

00:01:40,230 --> 00:01:46,960
encryption isolation we have one key for

00:01:44,500 --> 00:01:51,280
the hypervisor and then we have one key

00:01:46,960 --> 00:01:53,590
for each VM and that allows us to

00:01:51,280 --> 00:01:58,030
cryptographically isolate the hypervisor

00:01:53,590 --> 00:02:00,940
from the VMS and from each VM to two

00:01:58,030 --> 00:02:03,960
other VMs so this all integrates with

00:02:00,940 --> 00:02:09,550
our existing virtualization technology

00:02:03,960 --> 00:02:18,130
you can continue to run standard VMs

00:02:09,550 --> 00:02:21,340
alongside SE B and se BES VMs so one of

00:02:18,130 --> 00:02:25,930
the areas that we're working on is SE v

00:02:21,340 --> 00:02:27,670
live migration right now the existing

00:02:25,930 --> 00:02:31,390
SAV support doesn't support live

00:02:27,670 --> 00:02:34,810
migration because the hypervisor can't

00:02:31,390 --> 00:02:38,980
just move or copy a page from one

00:02:34,810 --> 00:02:41,680
machine to another machine and that's

00:02:38,980 --> 00:02:43,750
for two reasons one the encryption key

00:02:41,680 --> 00:02:46,060
that's associated with the source

00:02:43,750 --> 00:02:50,260
machine isn't migrated to the

00:02:46,060 --> 00:02:55,269
destination machine you get a different

00:02:50,260 --> 00:02:57,850
key at as soon as the VM start up and so

00:02:55,269 --> 00:03:01,480
that would that would cause the

00:02:57,850 --> 00:03:03,700
ciphertext to become all distorted the

00:03:01,480 --> 00:03:07,060
other reason is even if you could

00:03:03,700 --> 00:03:11,410
migrate those keys the physical location

00:03:07,060 --> 00:03:14,290
of the page in memory makes a difference

00:03:11,410 --> 00:03:18,100
so while the guests can see a page of

00:03:14,290 --> 00:03:20,320
zeros that one address as a page of

00:03:18,100 --> 00:03:22,930
zeros at another address from the

00:03:20,320 --> 00:03:25,570
hypervisors point of view he sees two

00:03:22,930 --> 00:03:27,070
different cipher texts so if you were to

00:03:25,570 --> 00:03:29,260
move that page from one machine to

00:03:27,070 --> 00:03:31,780
another machine and it's not in the

00:03:29,260 --> 00:03:33,390
exact same physical location that it was

00:03:31,780 --> 00:03:37,530
on the source machine

00:03:33,390 --> 00:03:40,380
then nothing will work so given that we

00:03:37,530 --> 00:03:44,880
have to use the SE V firmware to move

00:03:40,380 --> 00:03:47,060
the pages right and what we do is have

00:03:44,880 --> 00:03:50,160
the source and destination machines

00:03:47,060 --> 00:03:52,709
negotiate some transport keys and those

00:03:50,160 --> 00:03:56,520
transport keys are then used to wrap the

00:03:52,709 --> 00:03:59,160
data and send it from the source over to

00:03:56,520 --> 00:04:02,310
the destination destination machine then

00:03:59,160 --> 00:04:07,890
unwraps the data and we've migrated the

00:04:02,310 --> 00:04:11,370
page now one of the things we need to

00:04:07,890 --> 00:04:13,560
know and this is part of the support

00:04:11,370 --> 00:04:16,590
that my colleague back in Austin has

00:04:13,560 --> 00:04:19,290
submitted upstream for q mu and for KVM

00:04:16,590 --> 00:04:21,390
support is we need to know what pages

00:04:19,290 --> 00:04:22,980
are actually encrypted because you don't

00:04:21,390 --> 00:04:27,510
want to try and decrypt a page that

00:04:22,980 --> 00:04:30,660
isn't encrypted so we're introducing a

00:04:27,510 --> 00:04:33,419
hyper call from the guest so whenever we

00:04:30,660 --> 00:04:35,700
change the encryption state of a page

00:04:33,419 --> 00:04:38,370
the hypervisor will be made aware of

00:04:35,700 --> 00:04:41,100
that and we'll know when a page is

00:04:38,370 --> 00:04:44,550
encrypted or not encrypted and what we

00:04:41,100 --> 00:04:47,790
need to do appropriately there'll be

00:04:44,550 --> 00:04:50,880
updates made to qmu so that when we see

00:04:47,790 --> 00:04:53,940
a encrypted page we'll call down into

00:04:50,880 --> 00:04:58,050
the kernel and then call into the SE V

00:04:53,940 --> 00:05:01,350
firmware use the SAV api's to then wrap

00:04:58,050 --> 00:05:04,500
that page for transport across the line

00:05:01,350 --> 00:05:07,650
and then there's metadata associated

00:05:04,500 --> 00:05:10,919
with that information as it goes across

00:05:07,650 --> 00:05:14,550
the wire to the destination machine will

00:05:10,919 --> 00:05:17,460
use receive api's to then unwrap it and

00:05:14,550 --> 00:05:20,610
put it into the the guest on the

00:05:17,460 --> 00:05:22,979
destination machine at the end of the

00:05:20,610 --> 00:05:25,919
full migration that guest page

00:05:22,979 --> 00:05:29,460
encryption state is the last one of the

00:05:25,919 --> 00:05:31,919
last things sent so that the guest on

00:05:29,460 --> 00:05:33,810
that side now knows the state of

00:05:31,919 --> 00:05:37,010
everything and it could then be migrated

00:05:33,810 --> 00:05:37,010
yet again if it needs to

00:05:38,659 --> 00:05:45,270
so the problem comes up that we have to

00:05:42,780 --> 00:05:48,300
use the secured processor to move all

00:05:45,270 --> 00:05:52,289
these pages and the secure processor was

00:05:48,300 --> 00:05:55,949
never intended to handle a stream of

00:05:52,289 --> 00:05:58,349
megabytes or gigabytes of data in a

00:05:55,949 --> 00:06:01,620
performant matter so it becomes a

00:05:58,349 --> 00:06:04,319
bottleneck so we started thinking about

00:06:01,620 --> 00:06:06,419
what we could do and we you can think of

00:06:04,319 --> 00:06:08,280
migration being broken down an SCV

00:06:06,419 --> 00:06:11,060
migration being broken down into two

00:06:08,280 --> 00:06:15,030
phases you have an authentication phase

00:06:11,060 --> 00:06:19,020
where the AMD secure processor would be

00:06:15,030 --> 00:06:20,969
used to enforce guest policy on

00:06:19,020 --> 00:06:23,069
migration you know whether or not to

00:06:20,969 --> 00:06:25,349
even allow migration is part of the

00:06:23,069 --> 00:06:28,590
policy right and then a data movement

00:06:25,349 --> 00:06:30,449
phase and the data movement phase is

00:06:28,590 --> 00:06:32,940
where this migration helper comes in

00:06:30,449 --> 00:06:37,199
right it's currently a proof of concept

00:06:32,940 --> 00:06:40,849
that we have you can think of it almost

00:06:37,199 --> 00:06:46,020
as a hidden V CPU but it's basically an

00:06:40,849 --> 00:06:48,300
AMD's talk v MCB that represents

00:06:46,020 --> 00:06:52,229
something that can be run through a VM

00:06:48,300 --> 00:06:55,080
run instruction it would run only the

00:06:52,229 --> 00:06:58,550
migration code and the migration code is

00:06:55,080 --> 00:07:01,650
very small kind of does three things

00:06:58,550 --> 00:07:07,680
initializes the key for migration it can

00:07:01,650 --> 00:07:10,500
encrypt pages and decrypt pages so if we

00:07:07,680 --> 00:07:13,979
look at how this would work what we

00:07:10,500 --> 00:07:17,969
would need to do is we use the the send

00:07:13,979 --> 00:07:20,610
API is the sed firmware to migrate the

00:07:17,969 --> 00:07:23,639
migration helper first all right it's

00:07:20,610 --> 00:07:25,710
very small so we can get that sent

00:07:23,639 --> 00:07:28,440
without you know having a bottleneck

00:07:25,710 --> 00:07:31,259
with with the processor the secure

00:07:28,440 --> 00:07:34,669
processor the destination the hypervisor

00:07:31,259 --> 00:07:37,770
would then receive that migration helper

00:07:34,669 --> 00:07:40,050
that migration helper will have done it

00:07:37,770 --> 00:07:43,259
in it so the key is now transferred from

00:07:40,050 --> 00:07:45,300
the source to the destination and then

00:07:43,259 --> 00:07:47,639
you now have the migration helper

00:07:45,300 --> 00:07:50,070
running on both machines and you would

00:07:47,639 --> 00:07:52,740
then start calling instead of this

00:07:50,070 --> 00:07:58,140
processor you call into the migration

00:07:52,740 --> 00:08:02,250
helper which would be doing CPU x86 CPU

00:07:58,140 --> 00:08:06,450
instructions to migrate the page right

00:08:02,250 --> 00:08:08,940
so we could use AES and do like AES GCM

00:08:06,450 --> 00:08:11,850
so that you can get the encryption and

00:08:08,940 --> 00:08:15,300
integrity support and instead of

00:08:11,850 --> 00:08:19,790
migrating megabits a second we're now

00:08:15,300 --> 00:08:19,790
able to migrate a Giga bits a second

00:08:24,919 --> 00:08:31,729
so that was migration and moving on to

00:08:27,289 --> 00:08:34,940
just performance in general one of the

00:08:31,729 --> 00:08:39,019
other things about sed is we have to pin

00:08:34,940 --> 00:08:41,120
all of the guests memory right as I

00:08:39,019 --> 00:08:43,909
mentioned in migration right physical

00:08:41,120 --> 00:08:48,850
location matters so we can't have the

00:08:43,909 --> 00:08:48,850
hypervisor moving the pages around and

00:08:49,660 --> 00:08:54,640
because we would just run into issues

00:08:51,920 --> 00:08:57,620
when we try to decrypt those pages

00:08:54,640 --> 00:09:01,029
the problem with pinning memories you

00:08:57,620 --> 00:09:03,769
have higher initial resources

00:09:01,029 --> 00:09:07,279
requirements associated with startup and

00:09:03,769 --> 00:09:09,620
depending on the size of the VM right

00:09:07,279 --> 00:09:12,620
you have a slower startup as you're

00:09:09,620 --> 00:09:16,250
pinning all this memory so we're

00:09:12,620 --> 00:09:18,199
investigating a few options one of the

00:09:16,250 --> 00:09:23,410
first ones we're looking at is to just

00:09:18,199 --> 00:09:26,720
prevent page migration for an SAV guest

00:09:23,410 --> 00:09:29,029
we either will mark the page as an SCV

00:09:26,720 --> 00:09:32,110
guest page or determine that the page is

00:09:29,029 --> 00:09:35,209
somehow related to an SE B guest and

00:09:32,110 --> 00:09:37,850
just prevent the page from being

00:09:35,209 --> 00:09:40,970
migrated that would eliminate the need

00:09:37,850 --> 00:09:44,510
to have to pin the memory and therefore

00:09:40,970 --> 00:09:48,350
get kind of a quicker startup the other

00:09:44,510 --> 00:09:51,980
option is we have newer firmware support

00:09:48,350 --> 00:09:55,220
that can kind of do a copy so if you

00:09:51,980 --> 00:09:56,870
really want to rebalance your memory

00:09:55,220 --> 00:10:01,339
across the Numa nodes or things like

00:09:56,870 --> 00:10:03,890
that we can make use of that where we

00:10:01,339 --> 00:10:07,910
can hook into the page migration or

00:10:03,890 --> 00:10:10,130
compaction and swap paths determine

00:10:07,910 --> 00:10:12,410
based on the same bitmap that we would

00:10:10,130 --> 00:10:14,620
use for a live migration as to whether

00:10:12,410 --> 00:10:17,089
or not a page is encrypted or not

00:10:14,620 --> 00:10:19,940
determine whether we need to use this

00:10:17,089 --> 00:10:23,269
copy API and then we could move the page

00:10:19,940 --> 00:10:28,040
through the sed firmware we still don't

00:10:23,269 --> 00:10:30,920
have any or any support for or an API

00:10:28,040 --> 00:10:32,390
for swapping and that's one of the other

00:10:30,920 --> 00:10:33,080
things we're going to be continuing to

00:10:32,390 --> 00:10:39,590
look at

00:10:33,080 --> 00:10:42,950
is swapping support another area

00:10:39,590 --> 00:10:46,240
performance work that we looked at and

00:10:42,950 --> 00:10:49,100
these patches were accepted recently and

00:10:46,240 --> 00:10:52,280
will be in the 5/5 kernel but it deals

00:10:49,100 --> 00:10:54,650
with our acid activation so in our first

00:10:52,280 --> 00:10:58,460
generation of epic machines we supported

00:10:54,650 --> 00:11:01,820
15 concurrent SCBA sets in our second

00:10:58,460 --> 00:11:07,190
generation we bumped that from 15 to 509

00:11:01,820 --> 00:11:09,560
so you can have 509 guests running our

00:11:07,190 --> 00:11:11,990
maximum thread count is 256 so you can

00:11:09,560 --> 00:11:14,090
pretty much run concurrently while the

00:11:11,990 --> 00:11:17,620
button you know all the guests on the

00:11:14,090 --> 00:11:21,290
box full-time but what we were doing in

00:11:17,620 --> 00:11:22,670
previously was in order to ensure that

00:11:21,290 --> 00:11:24,770
we don't get any kind of cache

00:11:22,670 --> 00:11:26,960
corruption or things like that when we

00:11:24,770 --> 00:11:28,820
go to reuse aces we would have to do a

00:11:26,960 --> 00:11:32,540
write back invalidate across all the

00:11:28,820 --> 00:11:36,050
CPUs followed by DF flush these are very

00:11:32,540 --> 00:11:38,930
very expensive operations so you can see

00:11:36,050 --> 00:11:41,840
from the diagram we would find an

00:11:38,930 --> 00:11:46,670
available acid we'd perform this right

00:11:41,840 --> 00:11:48,770
back invalidate DF flush do an activate

00:11:46,670 --> 00:11:50,930
and at that point we would launch the

00:11:48,770 --> 00:11:52,790
guests the guests could run for a while

00:11:50,930 --> 00:11:54,920
do whatever it needs to do but when the

00:11:52,790 --> 00:11:56,960
guest shut down we'd then do a

00:11:54,920 --> 00:12:00,470
deactivate followed by another right

00:11:56,960 --> 00:12:02,360
back invalidate DF flush and then put

00:12:00,470 --> 00:12:10,940
that a Sid back in the available aces

00:12:02,360 --> 00:12:14,150
bitmap so the change was to now track

00:12:10,940 --> 00:12:16,270
these acids that we deactivate as

00:12:14,150 --> 00:12:20,330
reclaim ablations

00:12:16,270 --> 00:12:25,370
so we start with our available acids the

00:12:20,330 --> 00:12:28,010
guest will get a free available acid

00:12:25,370 --> 00:12:31,610
we'll just do an activate the guests can

00:12:28,010 --> 00:12:34,070
run when it shuts down we do a

00:12:31,610 --> 00:12:39,110
deactivate and we freely a sit into the

00:12:34,070 --> 00:12:41,060
reclaimer bowl bitmap now the next time

00:12:39,110 --> 00:12:43,100
a guest starts so we could do this on

00:12:41,060 --> 00:12:47,330
our new machines you know 509

00:12:43,100 --> 00:12:50,210
times when you get to five ten there

00:12:47,330 --> 00:12:52,850
would be no more available aces we'd go

00:12:50,210 --> 00:12:57,320
down we'd do a right back invalidate DF

00:12:52,850 --> 00:13:00,020
flush and that would cover all of the

00:12:57,320 --> 00:13:02,540
aces that have been freed up to that

00:13:00,020 --> 00:13:05,960
point so we would take all the reclaim

00:13:02,540 --> 00:13:09,020
ablai seeds put them back into the

00:13:05,960 --> 00:13:11,450
available assets then continue on so we

00:13:09,020 --> 00:13:13,580
reduce the the performance impact

00:13:11,450 --> 00:13:16,090
associated with that dramatically by

00:13:13,580 --> 00:13:16,090
doing that

00:13:21,330 --> 00:13:29,589
moving on to se BES quick overview we

00:13:26,470 --> 00:13:31,690
build on SE V through guests register

00:13:29,589 --> 00:13:34,930
state protection so the guest register

00:13:31,690 --> 00:13:37,560
state becomes a encrypted it's

00:13:34,930 --> 00:13:40,540
initialized an own state then it's

00:13:37,560 --> 00:13:43,630
measured and encrypted and measured as

00:13:40,540 --> 00:13:46,720
part of the launch process an integrity

00:13:43,630 --> 00:13:51,070
check is performed whenever we do a VM

00:13:46,720 --> 00:13:53,380
run with SE vs and the VM run would fail

00:13:51,070 --> 00:13:57,610
if the hypervisor tried to alter that

00:13:53,380 --> 00:14:01,500
register state and then world switch is

00:13:57,610 --> 00:14:05,380
currently now swap all register state

00:14:01,500 --> 00:14:09,220
the VM control block under SE ves

00:14:05,380 --> 00:14:11,470
changes so where we used to have one

00:14:09,220 --> 00:14:15,100
page that had the control area and the

00:14:11,470 --> 00:14:17,560
save area integrated that now gets split

00:14:15,100 --> 00:14:20,019
so this the control area now points to

00:14:17,560 --> 00:14:22,089
the save area and that save area is a

00:14:20,019 --> 00:14:25,630
page on its own that's and that's what

00:14:22,089 --> 00:14:31,089
gets encrypted and measured it's also

00:14:25,630 --> 00:14:35,230
been expanded to to save more state so

00:14:31,089 --> 00:14:39,880
it uses a little bit more of that 4 K

00:14:35,230 --> 00:14:43,149
page but it's nothing nothing dramatic

00:14:39,880 --> 00:14:47,380
in in the size of memory that has been

00:14:43,149 --> 00:14:49,480
been now used we also have what we call

00:14:47,380 --> 00:14:52,660
a guest hypervisor communication block

00:14:49,480 --> 00:14:54,910
to allow the guest and the hypervisor to

00:14:52,660 --> 00:14:57,310
communicate any state needed to perform

00:14:54,910 --> 00:15:01,810
some functions for the guest

00:14:57,310 --> 00:15:04,510
for example mm IO or MSR reads and

00:15:01,810 --> 00:15:06,730
writes CPUID instruction that type of

00:15:04,510 --> 00:15:08,050
thing it's a shared page between the

00:15:06,730 --> 00:15:11,079
hypervisor and the guest

00:15:08,050 --> 00:15:13,300
so it's unencrypted and there's a

00:15:11,079 --> 00:15:18,640
specification that documents it all and

00:15:13,300 --> 00:15:21,010
some of the protocols around how we do

00:15:18,640 --> 00:15:26,860
guest startup and

00:15:21,010 --> 00:15:30,400
and how we run under se BES so from a

00:15:26,860 --> 00:15:31,990
current status I talked about se BES

00:15:30,400 --> 00:15:33,850
last year and you can look at that

00:15:31,990 --> 00:15:37,230
presentation to kind of see what we're

00:15:33,850 --> 00:15:41,050
doing but from the current status the

00:15:37,230 --> 00:15:43,660
the protocol specification is just about

00:15:41,050 --> 00:15:46,590
final I'm adding just some final cpuid

00:15:43,660 --> 00:15:51,340
and MSR requirements that the guest

00:15:46,590 --> 00:15:53,910
expects to be set the o vmf patches or

00:15:51,340 --> 00:15:59,470
edk two patches were recently submitted

00:15:53,910 --> 00:16:01,420
in RFC in the process of taking all

00:15:59,470 --> 00:16:05,020
those comments in and submitting the

00:16:01,420 --> 00:16:07,450
third version of those kernel batches

00:16:05,020 --> 00:16:13,570
are still being completed there's some

00:16:07,450 --> 00:16:16,360
things like early early exception

00:16:13,570 --> 00:16:20,110
handling that we have to to work on some

00:16:16,360 --> 00:16:23,020
nmi handling things like that to finish

00:16:20,110 --> 00:16:27,400
that out but then hopefully we'll get

00:16:23,020 --> 00:16:29,350
those submitted quickly qmu patches have

00:16:27,400 --> 00:16:31,800
a working qmu but there's still some

00:16:29,350 --> 00:16:35,080
things to investigate there as far as

00:16:31,800 --> 00:16:37,800
how qmu does register accesses right now

00:16:35,080 --> 00:16:40,600
it just says give me all the registers

00:16:37,800 --> 00:16:43,780
we don't supply all those registers on

00:16:40,600 --> 00:16:45,910
exit you only supply what registers are

00:16:43,780 --> 00:16:49,360
required so we have to look at how we go

00:16:45,910 --> 00:16:54,240
about doing that we have a github tree

00:16:49,360 --> 00:16:59,200
with the q mu o vmf and kernel patches

00:16:54,240 --> 00:17:04,300
available so they they can be applied in

00:16:59,200 --> 00:17:05,740
and run and both are naples in our own

00:17:04,300 --> 00:17:11,770
system or our first and

00:17:05,740 --> 00:17:15,070
second-generation epic systems the next

00:17:11,770 --> 00:17:19,170
step and this is kind of a plug for for

00:17:15,070 --> 00:17:21,730
another colleague who will be presenting

00:17:19,170 --> 00:17:26,140
secure nests at paging tomorrow at the

00:17:21,730 --> 00:17:29,080
linux security summit this is the

00:17:26,140 --> 00:17:33,130
secureness of paging is our next step in

00:17:29,080 --> 00:17:35,380
in evolution of SCV where SE v provided

00:17:33,130 --> 00:17:38,620
the confidentiality through encryption

00:17:35,380 --> 00:17:41,740
of memory and then encryption of

00:17:38,620 --> 00:17:44,830
register state SMP is going to build on

00:17:41,740 --> 00:17:47,049
that and add integrity protection so

00:17:44,830 --> 00:17:49,140
this is going to help guard against

00:17:47,049 --> 00:17:52,510
replay attacks corruption attacks

00:17:49,140 --> 00:17:55,450
remapping attacks make sure that when a

00:17:52,510 --> 00:17:59,230
guest writes a value to a page it's

00:17:55,450 --> 00:18:02,350
guaranteed to read that value back so

00:17:59,230 --> 00:18:04,299
some some nice some nice added things

00:18:02,350 --> 00:18:07,059
there from from an integrity protection

00:18:04,299 --> 00:18:09,850
point of view like I said David will be

00:18:07,059 --> 00:18:14,500
talking about that tomorrow we'll have a

00:18:09,850 --> 00:18:17,620
white paper out on that very soon on our

00:18:14,500 --> 00:18:22,409
se B site so if you go to developer

00:18:17,620 --> 00:18:25,480
decom slash SCV and that reference is in

00:18:22,409 --> 00:18:27,429
on the next page on the list of

00:18:25,480 --> 00:18:29,610
references that i have but that that

00:18:27,429 --> 00:18:33,010
paper should hopefully be out tomorrow

00:18:29,610 --> 00:18:34,720
so it would be good to read if not

00:18:33,010 --> 00:18:36,399
tomorrow it'll be very soon after that

00:18:34,720 --> 00:18:40,809
just working through all the details to

00:18:36,399 --> 00:18:44,289
get that all posted here's the list of

00:18:40,809 --> 00:18:47,110
references just added that so that you

00:18:44,289 --> 00:18:51,880
can do that later disclaim barrier don't

00:18:47,110 --> 00:18:54,929
so that's pretty much it is there any

00:18:51,880 --> 00:18:54,929
questions on anything

00:18:57,910 --> 00:19:05,890
I just wondered how does the migration

00:19:00,910 --> 00:19:11,310
help communicate with the qmu migration

00:19:05,890 --> 00:19:15,760
process so the qmu migration process is

00:19:11,310 --> 00:19:17,110
updated so that it it knows about the

00:19:15,760 --> 00:19:20,530
encryption bitmask

00:19:17,110 --> 00:19:22,390
and if it sees that it's a it's an SE B

00:19:20,530 --> 00:19:25,180
gas with an encrypted page it'll call

00:19:22,390 --> 00:19:29,800
down to the kernel right and instead

00:19:25,180 --> 00:19:33,880
instead of going to the SCV api to have

00:19:29,800 --> 00:19:38,290
the page wrapped it'll it'll issue

00:19:33,880 --> 00:19:42,160
basically a VM run into this hidden v

00:19:38,290 --> 00:19:45,300
cpu which is the migration helper that

00:19:42,160 --> 00:19:49,960
will encrypt the page use in x86

00:19:45,300 --> 00:19:52,660
instructions it's a lot faster the pages

00:19:49,960 --> 00:19:54,910
in will be you know wrapped in place

00:19:52,660 --> 00:19:57,520
into a shared memory area that the

00:19:54,910 --> 00:19:59,470
hypervisor can you use it'll pass that

00:19:57,520 --> 00:20:01,770
back up to qmu and that's what qmu will

00:19:59,470 --> 00:20:01,770
send

00:20:07,269 --> 00:20:13,360
sorry um I just acquitted me like while

00:20:11,889 --> 00:20:19,330
thinking about all the SAV stuff what do

00:20:13,360 --> 00:20:21,369
you do on UEFI one time services so the

00:20:19,330 --> 00:20:23,759
migration helper is actually we're

00:20:21,369 --> 00:20:26,259
thinking probably would best live

00:20:23,759 --> 00:20:27,850
question just an anomaly I see be in Eng

00:20:26,259 --> 00:20:30,369
clave you have you if I want some

00:20:27,850 --> 00:20:33,869
services that are provided by the host

00:20:30,369 --> 00:20:36,669
environment right so I as a person as an

00:20:33,869 --> 00:20:37,119
hypervisor provide film where in to my

00:20:36,669 --> 00:20:40,090
guest

00:20:37,119 --> 00:20:42,340
which then lives on inside of my own

00:20:40,090 --> 00:20:44,590
context that is running with secure

00:20:42,340 --> 00:20:46,419
everything enabled so if I take a random

00:20:44,590 --> 00:20:48,519
operating system today and I just this

00:20:46,419 --> 00:20:52,299
is a general-purpose ICP question if I

00:20:48,519 --> 00:20:54,190
take my normal OS and I just have you if

00:20:52,299 --> 00:20:55,450
our internal services pulled in doesn't

00:20:54,190 --> 00:20:57,129
that mean that I can essentially read

00:20:55,450 --> 00:20:59,019
out all that secure data from inside

00:20:57,129 --> 00:21:03,749
that guest

00:20:59,019 --> 00:21:07,450
I think Lea Ron wants to answer it I'm

00:21:03,749 --> 00:21:09,700
trying to follow so I think the question

00:21:07,450 --> 00:21:12,039
is that's because the hypervisor is the

00:21:09,700 --> 00:21:14,110
one that actually provides what what is

00:21:12,039 --> 00:21:16,809
the ovm fum well it can also define what

00:21:14,110 --> 00:21:18,850
out the UEFI runtime services that are

00:21:16,809 --> 00:21:21,279
called inside the guest and therefore if

00:21:18,850 --> 00:21:22,899
I enter a malicious and on-time service

00:21:21,279 --> 00:21:24,490
it can provide me the data for example

00:21:22,899 --> 00:21:26,799
using hyper course or things like that

00:21:24,490 --> 00:21:30,600
but I feel yeah go ahead

00:21:26,799 --> 00:21:36,490
so so the the UEFI is measured at launch

00:21:30,600 --> 00:21:38,559
so as long as you have vetted that code

00:21:36,490 --> 00:21:40,330
and know that you don't have anything

00:21:38,559 --> 00:21:43,960
malicious in there that's just gonna

00:21:40,330 --> 00:21:45,519
pump out data right you know it's it

00:21:43,960 --> 00:21:47,559
becomes something that's measured you

00:21:45,519 --> 00:21:51,039
could validate that measurement and if

00:21:47,559 --> 00:21:54,669
if the measurement doesn't match and

00:21:51,039 --> 00:21:58,409
this goes back to two to SCV in general

00:21:54,669 --> 00:22:01,480
on how we do launching of guests right

00:21:58,409 --> 00:22:03,279
the guest owner can look at that launch

00:22:01,480 --> 00:22:08,080
measurement and decide whether or not to

00:22:03,279 --> 00:22:10,960
continue the boot of the guest so that

00:22:08,080 --> 00:22:13,559
would be a way for it to detect whether

00:22:10,960 --> 00:22:18,299
somebody has inserted

00:22:13,559 --> 00:22:20,280
a malicious UEFI or not I think that in

00:22:18,299 --> 00:22:23,070
general is just an auto auto g''l

00:22:20,280 --> 00:22:25,020
problem that even in standard pieces you

00:22:23,070 --> 00:22:27,000
are afraid that the runtime services of

00:22:25,020 --> 00:22:28,740
Malaysian so like you said you can

00:22:27,000 --> 00:22:30,900
either measure them or for example in

00:22:28,740 --> 00:22:31,380
other cases like in Windows for doing

00:22:30,900 --> 00:22:33,480
VBS

00:22:31,380 --> 00:22:36,000
they isolate them and I can put them in

00:22:33,480 --> 00:22:37,799
video 0 for example so it just

00:22:36,000 --> 00:22:40,500
autocannon to the MDC warka texture in

00:22:37,799 --> 00:22:43,770
general but but I have a different

00:22:40,500 --> 00:22:45,750
question I you said that the SP and the

00:22:43,770 --> 00:22:47,880
film well that actually does the

00:22:45,750 --> 00:22:51,330
encryption doesn't do it fast enough

00:22:47,880 --> 00:22:53,730
like in x86 right but on if I don't

00:22:51,330 --> 00:22:55,830
consider migration for moments isn't

00:22:53,730 --> 00:22:58,260
this exact same formerly used for doing

00:22:55,830 --> 00:23:02,220
the encryption of the guest memory pages

00:22:58,260 --> 00:23:04,559
in general no so so the SUV firmware

00:23:02,220 --> 00:23:09,270
does the initial encryption of like the

00:23:04,559 --> 00:23:12,510
UEFI blob but but after that anything

00:23:09,270 --> 00:23:16,260
that when a page is loaded and written

00:23:12,510 --> 00:23:19,590
it's going through the UMC right so the

00:23:16,260 --> 00:23:23,340
SE B firmware actually routes through

00:23:19,590 --> 00:23:24,720
the the memory controller right and the

00:23:23,340 --> 00:23:27,210
memory controller is the one that's

00:23:24,720 --> 00:23:32,640
doing the actual encryption so whenever

00:23:27,210 --> 00:23:34,350
you read or write to memory it will

00:23:32,640 --> 00:23:37,289
assuming that you have set the

00:23:34,350 --> 00:23:39,419
encryption bit in the guest then it'll

00:23:37,289 --> 00:23:41,700
go through the encryption controller and

00:23:39,419 --> 00:23:44,220
the memory controller which is exactly

00:23:41,700 --> 00:23:46,409
so so what one question that it raised

00:23:44,220 --> 00:23:47,909
for me is why can stay the only thing

00:23:46,409 --> 00:23:49,409
that needs to happen is to encrypt the

00:23:47,909 --> 00:23:51,299
memory page with a different key that

00:23:49,409 --> 00:23:55,440
was a negotiated for the migration

00:23:51,299 --> 00:23:57,299
channel right now the why can't the SP

00:23:55,440 --> 00:23:59,520
ephemeral just because it knows the

00:23:57,299 --> 00:24:01,320
original key of the guess it can ask it

00:23:59,520 --> 00:24:03,390
can read the memory for the memory

00:24:01,320 --> 00:24:05,190
controller and then write for the memory

00:24:03,390 --> 00:24:07,530
controller with the new key that is now

00:24:05,190 --> 00:24:10,110
the transport key that can use that we

00:24:07,530 --> 00:24:12,360
used in the - in the encryption of the

00:24:10,110 --> 00:24:14,730
new key that now I can send the

00:24:12,360 --> 00:24:20,130
emigration pages like use the MC

00:24:14,730 --> 00:24:22,350
existing MCH if I if I understand you're

00:24:20,130 --> 00:24:26,399
you're like saying like putting in a

00:24:22,350 --> 00:24:27,000
second key and so what I somewhere else

00:24:26,399 --> 00:24:29,100
what

00:24:27,000 --> 00:24:31,500
suggesting is that the SPF in well we'll

00:24:29,100 --> 00:24:34,200
just install the new transport key

00:24:31,500 --> 00:24:37,800
inside the MCH like you do for standard

00:24:34,200 --> 00:24:39,900
safe kids and then you wait for the the

00:24:37,800 --> 00:24:43,410
previous key to get the data and then

00:24:39,900 --> 00:24:44,970
rightful the new page that is now

00:24:43,410 --> 00:24:47,880
installed with the transport game and

00:24:44,970 --> 00:24:49,500
now you got the in the the plaintext

00:24:47,880 --> 00:24:53,160
encrypted with the transport key that is

00:24:49,500 --> 00:24:55,020
ready for being transmitted after to

00:24:53,160 --> 00:24:58,970
talk to you after this about what you're

00:24:55,020 --> 00:25:01,440
trying to to get a I'm not quite sure

00:24:58,970 --> 00:25:03,480
where the transport key how we're gonna

00:25:01,440 --> 00:25:07,890
inject that into the memory controllers

00:25:03,480 --> 00:25:12,360
so well I mean the the transport key

00:25:07,890 --> 00:25:16,770
would yeah it would almost need like

00:25:12,360 --> 00:25:18,750
we'd need to double the key space and so

00:25:16,770 --> 00:25:26,550
now you're limiting the number of guests

00:25:18,750 --> 00:25:28,380
that you can have so and and the the UMC

00:25:26,550 --> 00:25:31,110
is still going to be doing the same

00:25:28,380 --> 00:25:35,880
encryption methods so you still have the

00:25:31,110 --> 00:25:38,040
tweak involved that would render it not

00:25:35,880 --> 00:25:42,600
usable if you put it in a different

00:25:38,040 --> 00:25:45,480
location can can I interrupt here I'm

00:25:42,600 --> 00:25:47,220
David Kaplan I'm also from from AMD the

00:25:45,480 --> 00:25:48,990
issue is less about the encryption

00:25:47,220 --> 00:25:51,990
bandwidth it's about the latency between

00:25:48,990 --> 00:25:54,690
the hypervisor and the security

00:25:51,990 --> 00:25:58,110
processor so because we typically

00:25:54,690 --> 00:25:59,550
encrypt one page at a time it's going

00:25:58,110 --> 00:26:01,260
out to there waiting for the interrupt

00:25:59,550 --> 00:26:04,080
to come back there's a very long latency

00:26:01,260 --> 00:26:05,430
there there is fixed function harbor for

00:26:04,080 --> 00:26:06,270
doing the encryption that's a very tiny

00:26:05,430 --> 00:26:09,810
piece of it

00:26:06,270 --> 00:26:11,910
by doing all the operations in the x86

00:26:09,810 --> 00:26:14,610
and the migration helper it cuts down on

00:26:11,910 --> 00:26:16,640
the latency significantly does that make

00:26:14,610 --> 00:26:16,640
sense

00:26:18,320 --> 00:26:27,480
yes yeah yes so the question is is the

00:26:24,450 --> 00:26:28,860
latency about the the time between the

00:26:27,480 --> 00:26:30,809
hypervisor and the security processor

00:26:28,860 --> 00:26:34,230
yes because the security processor looks

00:26:30,809 --> 00:26:38,750
like a PCI device so you're going out

00:26:34,230 --> 00:26:38,750
it's like microseconds right to do that

00:26:41,510 --> 00:26:44,840
okay thank you

00:26:47,020 --> 00:26:58,160
[Applause]

00:26:51,300 --> 00:26:58,160

YouTube URL: https://www.youtube.com/watch?v=rh02gJyKxDo


