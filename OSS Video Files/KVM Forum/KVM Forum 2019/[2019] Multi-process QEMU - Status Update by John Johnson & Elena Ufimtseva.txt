Title: [2019] Multi-process QEMU - Status Update by John Johnson & Elena Ufimtseva
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	QEMU can be susceptible to security attacks on the many interfaces it exposes to a guest VM. Each interface is an exposure point that, if compromised, provides a malign guest the ability to assume the QEMU process's host privileges.

A multi-process QEMU involves separating QEMU services into multiple host processes. Each of these processes can be given only the privileges it needs to provide its service.

We introduced this topic at KVM forum two years ago, and hosted a BoF on it last year. In this presentation, we will introduce the work we've done with an LSI SCSI controller model, including how it performs, and what the next steps will be.

---

John Johnson
Oracle
Senior Software Architect

Currently working on KVM/QEMU projects at Oracle, such as the multi-process QEMU projects. Previously worked on multiple OS and virtualization technologies at Sun Microsystems, including the software and hardware architecture for SPARC LDoms, and the kernel architecture for 64b SPARC. Graduated with a BSEE degree from Purdue University.

Elena Ufimtseva
Oracle
Principal Member of Technical Staff

Currently working at Oracle on QEMU multiprocess disaggregation project. Before was working on the implementation of vNUMA topology for guests in Xen hypervisor, as well as Xen livepatching and working on various Xen hypervisor improvements and issues. Previously had given a talk at XenProject summit on PVH guests. Was part of the 2014 Outreachy (former Outreach Program for Women) where she started the vNUMA work for Xen hypervisor.
Earned her Master Degree in Computer Science in Saint-Petersburg ITMO

Note: We apologize for lower video quality due to technical problems.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:07,370 --> 00:00:13,559
all right good afternoon is everybody

00:00:10,019 --> 00:00:17,699
ready for the last two sessions the home

00:00:13,559 --> 00:00:18,600
stretch for the the conference my name

00:00:17,699 --> 00:00:20,400
is John Johnson

00:00:18,600 --> 00:00:22,439
this is Elena and we're here to talk

00:00:20,400 --> 00:00:24,199
about the multi-process qmu project that

00:00:22,439 --> 00:00:27,119
we've been working on at oracle for last

00:00:24,199 --> 00:00:29,160
bit we have a third member of the of the

00:00:27,119 --> 00:00:32,309
team named jag Ramon and he's

00:00:29,160 --> 00:00:36,690
unfortunately couldn't be with us in in

00:00:32,309 --> 00:00:37,940
France for today first we're gonna do is

00:00:36,690 --> 00:00:40,170
I'm going to give a little bit of a RV

00:00:37,940 --> 00:00:41,760
overview of the architecture and then

00:00:40,170 --> 00:00:44,789
Elena's going to go over to this card

00:00:41,760 --> 00:00:50,610
status and how do you use it and how you

00:00:44,789 --> 00:00:52,910
all can actually add to it so first

00:00:50,610 --> 00:00:56,370
question is why would want to do this

00:00:52,910 --> 00:00:58,140
the answer is you know everybody knows

00:00:56,370 --> 00:01:00,890
this cue music hypervisor of choice and

00:00:58,140 --> 00:01:03,899
a lot of public cloud environments and

00:01:00,890 --> 00:01:05,700
public clouds ganbare can host VMs from

00:01:03,899 --> 00:01:07,770
many many customers most of them are

00:01:05,700 --> 00:01:09,600
just trying to get work done but there's

00:01:07,770 --> 00:01:11,880
a few people who are up there you know

00:01:09,600 --> 00:01:13,439
trying to be malevolent actors who want

00:01:11,880 --> 00:01:16,619
to snoop around either the host data or

00:01:13,439 --> 00:01:18,299
another other tenants of VM data and so

00:01:16,619 --> 00:01:22,290
a public clouds need to plan for the

00:01:18,299 --> 00:01:24,450
worst case situations they do that in

00:01:22,290 --> 00:01:27,110
many ways some of them use a different

00:01:24,450 --> 00:01:30,090
hypervisor the downside of that is that

00:01:27,110 --> 00:01:31,350
q provides a lot of features that's real

00:01:30,090 --> 00:01:33,030
are really desirable in a cloud

00:01:31,350 --> 00:01:35,130
environment from live migration to

00:01:33,030 --> 00:01:36,930
emulating lots and lots of different IO

00:01:35,130 --> 00:01:40,229
devices and having lots and lots of

00:01:36,930 --> 00:01:42,270
different IO backends another option is

00:01:40,229 --> 00:01:44,399
just to minimize qmu reduce the attack

00:01:42,270 --> 00:01:47,159
service by configuring as few as devices

00:01:44,399 --> 00:01:49,259
and services as possible and a lot of

00:01:47,159 --> 00:01:51,240
people just use variety vices and the

00:01:49,259 --> 00:01:54,000
varieties or Damons to further attack

00:01:51,240 --> 00:01:55,439
the reduce the attack service but the

00:01:54,000 --> 00:01:57,540
issue here is that that reduces your

00:01:55,439 --> 00:01:59,820
ability to lift and shift on Prem

00:01:57,540 --> 00:02:01,920
workloads into the end of the cloud

00:01:59,820 --> 00:02:05,790
because some existing OS instances may

00:02:01,920 --> 00:02:10,170
not use Verdi or they may rely on legacy

00:02:05,790 --> 00:02:12,090
interfaces so the last one that a lot of

00:02:10,170 --> 00:02:14,879
cloud vendors are doing is just run each

00:02:12,090 --> 00:02:16,620
qmu inside its own can

00:02:14,879 --> 00:02:19,170
then you've just placed the VMS data in

00:02:16,620 --> 00:02:22,260
the container use selinux or app armor

00:02:19,170 --> 00:02:26,250
policies to restrict the accesses of

00:02:22,260 --> 00:02:28,140
processes within the container but the

00:02:26,250 --> 00:02:33,150
issue here is those policies prior to

00:02:28,140 --> 00:02:36,030
processes and qmu is a single process so

00:02:33,150 --> 00:02:37,799
monolithic qmu as i just said it's a

00:02:36,030 --> 00:02:40,230
monolithic process that has a bunch of

00:02:37,799 --> 00:02:42,930
different functionality and it has a VM

00:02:40,230 --> 00:02:46,530
control plane you give it a wide variety

00:02:42,930 --> 00:02:48,900
of of command line options you can

00:02:46,530 --> 00:02:50,549
monitor it over a qmp socket you can do

00:02:48,900 --> 00:02:54,239
live migration hot blood storage

00:02:50,549 --> 00:02:56,750
snapshots a lot of things second sort of

00:02:54,239 --> 00:02:59,069
big area of functionality is is the KVM

00:02:56,750 --> 00:03:01,920
emulation work for each CPU and your

00:02:59,069 --> 00:03:05,280
guest it fires off a a thread and then

00:03:01,920 --> 00:03:08,250
uses KVM to execute that thread under

00:03:05,280 --> 00:03:09,870
hardware acceleration and this this code

00:03:08,250 --> 00:03:11,940
just basically handles the guest exits

00:03:09,870 --> 00:03:14,480
and the interrupts and the front the

00:03:11,940 --> 00:03:17,609
final one was probably going to be the

00:03:14,480 --> 00:03:20,700
focus of the rest of the presentation is

00:03:17,609 --> 00:03:23,510
a desire of emulation software emulation

00:03:20,700 --> 00:03:26,040
of many many many different IO devices

00:03:23,510 --> 00:03:28,109
all these functionalities require Kim

00:03:26,040 --> 00:03:31,530
you to have a lot of lot of host

00:03:28,109 --> 00:03:33,180
services so any exploit that you do can

00:03:31,530 --> 00:03:36,870
actually allow a malevolent guest to

00:03:33,180 --> 00:03:41,160
gain all of in any of chimneys access

00:03:36,870 --> 00:03:44,639
rights so this is just a picture is

00:03:41,160 --> 00:03:46,410
worth a thousand words of the sort of

00:03:44,639 --> 00:03:48,750
the current monolithic qmu you've got a

00:03:46,410 --> 00:03:51,389
big program the guest is embedded within

00:03:48,750 --> 00:03:53,449
the address space of the of the process

00:03:51,389 --> 00:03:58,859
you've got a bunch of different

00:03:53,449 --> 00:04:01,199
emulation modules in it control plane at

00:03:58,859 --> 00:04:05,449
the top and the chipset emulation which

00:04:01,199 --> 00:04:09,389
uses kmu to to execute the actual guest

00:04:05,449 --> 00:04:11,370
all right so why would we run CMU in

00:04:09,389 --> 00:04:13,680
multiple process as well as I said

00:04:11,370 --> 00:04:15,299
before a lot of security policies are

00:04:13,680 --> 00:04:18,389
our process based

00:04:15,299 --> 00:04:21,510
selinux is basically about rules that

00:04:18,389 --> 00:04:24,719
limit what processes what files and

00:04:21,510 --> 00:04:26,550
device objects can access another one is

00:04:24,719 --> 00:04:30,210
se comm it can limit what process

00:04:26,550 --> 00:04:32,610
- what system calls they can execute so

00:04:30,210 --> 00:04:34,800
what we can do here by running queuing

00:04:32,610 --> 00:04:37,310
multiple processes is we can apply finer

00:04:34,800 --> 00:04:39,379
grained privileges to each process

00:04:37,310 --> 00:04:41,879
example if you've got a disk controller

00:04:39,379 --> 00:04:44,099
you could only give it access to the

00:04:41,879 --> 00:04:45,960
disk images that belong to that guest

00:04:44,099 --> 00:04:47,550
and even if you're using a network

00:04:45,960 --> 00:04:50,659
storage something like I scuzzy you can

00:04:47,550 --> 00:04:53,129
actually use SELinux to keep that

00:04:50,659 --> 00:04:55,409
process from binding any port except the

00:04:53,129 --> 00:04:57,780
I scuzzy port or to accessing or

00:04:55,409 --> 00:05:03,080
connecting to any storage IPs except for

00:04:57,780 --> 00:05:09,210
the ones that are used as storage hosts

00:05:03,080 --> 00:05:11,000
brecci SCC set comp you can use we can

00:05:09,210 --> 00:05:13,229
have the device simulation processes

00:05:11,000 --> 00:05:15,599
limited from using four core exec so if

00:05:13,229 --> 00:05:17,159
you do actually gain access to those you

00:05:15,599 --> 00:05:19,050
can't actually sort of escape out of the

00:05:17,159 --> 00:05:23,940
box and get a host she'll start

00:05:19,050 --> 00:05:26,310
rummaging around that way so as I said

00:05:23,940 --> 00:05:28,440
we're going to use our first cut at this

00:05:26,310 --> 00:05:30,719
was actually put device emulation a

00:05:28,440 --> 00:05:33,900
separate process it's a good place to

00:05:30,719 --> 00:05:35,669
start for a number of reasons the most

00:05:33,900 --> 00:05:37,229
obvious one is that it's the largest

00:05:35,669 --> 00:05:39,090
surface area that I'm 11 guests can

00:05:37,229 --> 00:05:42,180
attack most of the touch points of a

00:05:39,090 --> 00:05:44,969
guest to qmu are via the MM i/o

00:05:42,180 --> 00:05:48,630
operations that that it does to the

00:05:44,969 --> 00:05:49,979
devices that it uses the other one is

00:05:48,630 --> 00:05:52,190
actually just frankly ease of emulation

00:05:49,979 --> 00:05:54,569
if you're you know most of you should be

00:05:52,190 --> 00:05:57,120
familiar with the internals of qmu that

00:05:54,569 --> 00:05:58,919
all these devices immolations are

00:05:57,120 --> 00:06:01,469
actually implemented as objects so we'd

00:05:58,919 --> 00:06:04,080
actually used the object boundary method

00:06:01,469 --> 00:06:06,599
boundaries to as the separation point to

00:06:04,080 --> 00:06:08,870
proxy from the from the community

00:06:06,599 --> 00:06:12,300
process to a remote execution process

00:06:08,870 --> 00:06:14,370
unless one of scalability uni you can

00:06:12,300 --> 00:06:16,620
have the number of processes that use to

00:06:14,370 --> 00:06:19,050
emulate the ear VM can scale up to the

00:06:16,620 --> 00:06:20,279
number of devices in the VM or if you

00:06:19,050 --> 00:06:22,020
want you can actually sort of

00:06:20,279 --> 00:06:24,150
consolidate you can have one process

00:06:22,020 --> 00:06:26,580
that does all of your storage that's

00:06:24,150 --> 00:06:29,849
it's limited only accessing storage

00:06:26,580 --> 00:06:31,650
nodes or a one process that does network

00:06:29,849 --> 00:06:34,589
that's only allowed to use the say the

00:06:31,650 --> 00:06:36,740
tap interface to the outside of the it's

00:06:34,589 --> 00:06:39,119
world

00:06:36,740 --> 00:06:43,949
and again pictures worth 1,000 world

00:06:39,119 --> 00:06:45,149
words this is the the situation we're

00:06:43,949 --> 00:06:48,300
trying to move toward where you've got

00:06:45,149 --> 00:06:51,149
qu just has its control plane in the and

00:06:48,300 --> 00:06:53,610
the KVM management code in it

00:06:51,149 --> 00:06:55,589
and the actual device simulations are

00:06:53,610 --> 00:06:57,779
all done with in separate processes that

00:06:55,589 --> 00:07:02,729
are connected over sockets to the main

00:06:57,779 --> 00:07:04,709
queue process so a little bit about the

00:07:02,729 --> 00:07:07,619
cue music model this is probably a

00:07:04,709 --> 00:07:10,999
review for almost everybody here but the

00:07:07,619 --> 00:07:13,529
the three main class models that we are

00:07:10,999 --> 00:07:15,059
are playing with here is the one is the

00:07:13,529 --> 00:07:17,339
machine class model and that actually

00:07:15,059 --> 00:07:19,529
models the the platform though on board

00:07:17,339 --> 00:07:24,479
it assembles the onboard devices and

00:07:19,529 --> 00:07:25,409
does things like handling or critically

00:07:24,479 --> 00:07:28,199
objects that handle things like

00:07:25,409 --> 00:07:29,699
interrupts the device class model those

00:07:28,199 --> 00:07:32,759
are the actual almost all the work is

00:07:29,699 --> 00:07:34,649
done that's for each device you actually

00:07:32,759 --> 00:07:37,499
have an instantiation of a device class

00:07:34,649 --> 00:07:40,080
for that device where that's where all

00:07:37,499 --> 00:07:42,569
the emulation code lives and finally

00:07:40,080 --> 00:07:44,699
there's bus class models and they auto

00:07:42,569 --> 00:07:46,949
model i/o buses and they're basically

00:07:44,699 --> 00:07:52,099
used to enumerate the child devices of a

00:07:46,949 --> 00:07:54,809
specific i/o bus so what happens when

00:07:52,099 --> 00:07:57,689
queue starts up it obviously starts

00:07:54,809 --> 00:08:02,519
parsing its command lines you know the

00:07:57,689 --> 00:08:05,369
machine argument fires up the machine

00:08:02,519 --> 00:08:08,550
bottle device dude

00:08:05,369 --> 00:08:10,589
model the emulation objects and

00:08:08,550 --> 00:08:13,860
something like block dev to it to create

00:08:10,589 --> 00:08:15,389
a device back-end so the first thing

00:08:13,860 --> 00:08:18,149
that actually happens after it's parsed

00:08:15,389 --> 00:08:20,339
all the command lines is the device back

00:08:18,149 --> 00:08:21,749
and sir initialized and they're just

00:08:20,339 --> 00:08:24,899
placed on list so they can be found by

00:08:21,749 --> 00:08:27,569
their associated devices later on then

00:08:24,899 --> 00:08:29,279
the Machine object is initialized and

00:08:27,569 --> 00:08:32,759
it's sort of handcrafts the the built-in

00:08:29,279 --> 00:08:36,419
devices a an ID device or for our

00:08:32,759 --> 00:08:38,810
purposes the the built-in PCI bus and

00:08:36,419 --> 00:08:41,339
then finally after the machine has

00:08:38,810 --> 00:08:44,180
object is instantiated the machine the

00:08:41,339 --> 00:08:46,439
all the list of device objects are all

00:08:44,180 --> 00:08:47,920
instantiated and they as they're

00:08:46,439 --> 00:08:50,139
instantiated they look up there

00:08:47,920 --> 00:08:53,860
again so they can actually do I owe to

00:08:50,139 --> 00:08:56,320
the host so here it is it just in a

00:08:53,860 --> 00:08:58,779
picture you've got the file back end to

00:08:56,320 --> 00:09:03,329
the to the right which is was you know

00:08:58,779 --> 00:09:07,170
created by a - block dev argument the

00:09:03,329 --> 00:09:11,889
the - machine created a on the left the

00:09:07,170 --> 00:09:14,740
PC I 440 FX machine class which when it

00:09:11,889 --> 00:09:17,850
started up created a PCI bus when when

00:09:14,740 --> 00:09:20,800
it sees the - device LS I scuzzy it

00:09:17,850 --> 00:09:24,459
attaches that emulation model underneath

00:09:20,800 --> 00:09:26,440
that PCI bus and that emulation object

00:09:24,459 --> 00:09:28,540
first thing it does is create a scuzzy

00:09:26,440 --> 00:09:30,790
bus and then finally when you see is -

00:09:28,540 --> 00:09:34,269
device does the ID that scuzzy his home

00:09:30,790 --> 00:09:35,620
office love these scuzzy awesome so keep

00:09:34,269 --> 00:09:40,389
that picture in mind we'll get back to

00:09:35,620 --> 00:09:42,610
it so what do we actually do instead of

00:09:40,389 --> 00:09:44,800
just sort of look around what Hugh is

00:09:42,610 --> 00:09:46,540
doing our emulation process is actually

00:09:44,800 --> 00:09:48,790
running unmodified device and bus

00:09:46,540 --> 00:09:50,589
objects this project does not scale if

00:09:48,790 --> 00:09:52,120
you actually you have to go into the

00:09:50,589 --> 00:09:54,120
device object now there's three things

00:09:52,120 --> 00:09:57,790
you need to change in order to make your

00:09:54,120 --> 00:10:00,279
your device emulation run in a remote

00:09:57,790 --> 00:10:03,070
process so we build it from the same qbo

00:10:00,279 --> 00:10:05,079
source tree we can have a little startup

00:10:03,070 --> 00:10:07,300
handshake to ensure that both qmu and

00:10:05,079 --> 00:10:10,899
the remote process were from the same

00:10:07,300 --> 00:10:12,790
same build same thing goes for the the

00:10:10,899 --> 00:10:14,260
backends they're built from the commute

00:10:12,790 --> 00:10:16,360
tree they use the same command line

00:10:14,260 --> 00:10:19,350
arguments to be instantiated as you do

00:10:16,360 --> 00:10:21,910
in both queue and in in a remote process

00:10:19,350 --> 00:10:23,920
the thing we did new is we have a new

00:10:21,910 --> 00:10:27,910
machine class object this thing

00:10:23,920 --> 00:10:29,620
it replaces the the CPU specific one

00:10:27,910 --> 00:10:32,649
that and platform specific one that's in

00:10:29,620 --> 00:10:34,540
qmu it performs similar set of functions

00:10:32,649 --> 00:10:36,160
it creates the initial machine but

00:10:34,540 --> 00:10:38,920
instead of doing it from command lines

00:10:36,160 --> 00:10:40,870
it does it from you know Jason

00:10:38,920 --> 00:10:46,389
descriptions that are sent from from the

00:10:40,870 --> 00:10:49,810
commute to the need to run a little

00:10:46,389 --> 00:10:51,160
faster and the last thing it does is it

00:10:49,810 --> 00:10:54,399
handles interrupts and I named you

00:10:51,160 --> 00:10:55,959
requests from the device models the

00:10:54,399 --> 00:10:57,160
other thing we add is it needs to

00:10:55,959 --> 00:10:59,679
actually talk to queue muse we have a

00:10:57,160 --> 00:11:03,609
little proxy service to allow it to

00:10:59,679 --> 00:11:04,540
talk back to qu that's what that thing

00:11:03,609 --> 00:11:06,399
is the one that receives the

00:11:04,540 --> 00:11:09,249
configuration message is in Korean Stan

00:11:06,399 --> 00:11:12,639
sheets all the the device objects within

00:11:09,249 --> 00:11:13,839
the emulation process and then actually

00:11:12,639 --> 00:11:16,299
startups it's the one that actually

00:11:13,839 --> 00:11:19,089
routes requests so when the guest

00:11:16,299 --> 00:11:21,819
actually touches the device exits to q

00:11:19,089 --> 00:11:23,679
mu q mu foot well we'll forward and we

00:11:21,819 --> 00:11:27,009
will get to the guest reads and writes

00:11:23,679 --> 00:11:29,339
to the to the emulation process and this

00:11:27,009 --> 00:11:33,129
thing will route them to the correct

00:11:29,339 --> 00:11:35,019
device emulation object same thing for

00:11:33,129 --> 00:11:37,119
the other way so if the machine has a

00:11:35,019 --> 00:11:39,279
request that goes back to mmm you need

00:11:37,119 --> 00:11:42,850
to go back to q mu this thing will route

00:11:39,279 --> 00:11:44,679
it back so here it is as a picture if

00:11:42,850 --> 00:11:47,049
you it looks exactly like the Commuter

00:11:44,679 --> 00:11:49,089
cept the on the Left we have a different

00:11:47,049 --> 00:11:53,160
machine object every everything else you

00:11:49,089 --> 00:11:55,239
see is exactly the same same code same

00:11:53,160 --> 00:11:57,429
same everything is you see inside

00:11:55,239 --> 00:12:01,929
accumulate processes basically a mini

00:11:57,429 --> 00:12:06,730
tamiya process so on the cumene jiz we

00:12:01,929 --> 00:12:10,029
needed we need something to to invoke

00:12:06,730 --> 00:12:12,279
the the thermo processes so when we do

00:12:10,029 --> 00:12:14,350
that with a new - remote command line

00:12:12,279 --> 00:12:18,069
option there are couple flavors of it

00:12:14,350 --> 00:12:20,259
one of them does when you have an

00:12:18,069 --> 00:12:22,149
Orchestrator like the vert it will

00:12:20,259 --> 00:12:26,379
probably went too far off the remote

00:12:22,149 --> 00:12:28,689
processes and it'll tell q mu what's a

00:12:26,379 --> 00:12:31,149
socket path that it's set up so that Q

00:12:28,689 --> 00:12:32,949
can talk to the remote process if you

00:12:31,149 --> 00:12:34,809
don't have an Orchestrator and q mu is

00:12:32,949 --> 00:12:36,790
responsible for setting up the entire

00:12:34,809 --> 00:12:39,129
environment there's a second option that

00:12:36,790 --> 00:12:41,169
that will you can give a command to and

00:12:39,129 --> 00:12:42,730
then the Q mule

00:12:41,169 --> 00:12:45,579
create the sake and execute the given

00:12:42,730 --> 00:12:48,730
command there are no device backends for

00:12:45,579 --> 00:12:50,589
the for the devices that are being

00:12:48,730 --> 00:12:54,549
executed motely they're not needed at

00:12:50,589 --> 00:12:56,319
all within hume you the other big

00:12:54,549 --> 00:12:57,549
changes is what we call proxy objects

00:12:56,319 --> 00:12:58,689
that replace the device emulation

00:12:57,549 --> 00:13:01,720
objects these are the things that

00:12:58,689 --> 00:13:03,459
actually forward the events guest events

00:13:01,720 --> 00:13:05,649
such as MMI is to the emulation process

00:13:03,459 --> 00:13:09,009
the way you specify those is just add a

00:13:05,649 --> 00:13:10,899
new our ad option for the - the - device

00:13:09,009 --> 00:13:12,459
- device everything else looks exactly

00:13:10,899 --> 00:13:15,040
the same

00:13:12,459 --> 00:13:18,010
the RIT basically specifies which of the

00:13:15,040 --> 00:13:20,589
of the remote process managers he's

00:13:18,010 --> 00:13:22,899
going to forward his request via and

00:13:20,589 --> 00:13:25,269
they exact exactly like they do at the

00:13:22,899 --> 00:13:27,779
in the same place in the gym you

00:13:25,269 --> 00:13:30,910
hierarchy both bus and object hierarchy

00:13:27,779 --> 00:13:33,820
so like an LSI is a subclass of a PCI

00:13:30,910 --> 00:13:35,470
device and as a child of a PCI bus other

00:13:33,820 --> 00:13:38,470
thing to note is that not all device

00:13:35,470 --> 00:13:40,390
need only need emulation not need proxy

00:13:38,470 --> 00:13:40,810
objects only those that interact with a

00:13:40,390 --> 00:13:43,329
guest

00:13:40,810 --> 00:13:44,920
so like the scuzzy controller since you

00:13:43,329 --> 00:13:47,200
do MMI operations to this does a

00:13:44,920 --> 00:13:49,079
controller needs one but the actual

00:13:47,200 --> 00:13:53,500
skuzzy device which doesn't directly

00:13:49,079 --> 00:13:58,720
receive indications from the from the

00:13:53,500 --> 00:14:00,760
guest that's not so as far as what the

00:13:58,720 --> 00:14:03,600
proxy objects looks like again we're

00:14:00,760 --> 00:14:06,880
using all sorts of qvo code all of the

00:14:03,600 --> 00:14:09,519
object device and PCI classes are

00:14:06,880 --> 00:14:11,829
exactly what are done within queue right

00:14:09,519 --> 00:14:13,540
now we have a new one for PCI device

00:14:11,829 --> 00:14:15,550
proxy and that's the one that's going to

00:14:13,540 --> 00:14:17,500
forward the guest config space accesses

00:14:15,550 --> 00:14:19,870
I mean for like Bart's we need to be

00:14:17,500 --> 00:14:22,120
able to keep the the PCI address 2

00:14:19,870 --> 00:14:24,250
device mapping the same within qmu and

00:14:22,120 --> 00:14:28,000
within the emulation process so we

00:14:24,250 --> 00:14:31,510
forward bar programming from the from th

00:14:28,000 --> 00:14:34,120
to the to the remote device and then

00:14:31,510 --> 00:14:36,730
finally there's a device specific proxy

00:14:34,120 --> 00:14:39,700
that it knows how big the MM i/o space

00:14:36,730 --> 00:14:43,390
of specific devices and performs those

00:14:39,700 --> 00:14:45,940
operations so what's left behind in qmu

00:14:43,390 --> 00:14:48,970
is very very simple just the you know

00:14:45,940 --> 00:14:53,079
the machine object that was created when

00:14:48,970 --> 00:14:56,829
you fired up qmu it created a PCI bus

00:14:53,079 --> 00:14:58,329
and the proxy is hung underneath it and

00:14:56,829 --> 00:15:02,589
finally just putting those two things

00:14:58,329 --> 00:15:04,990
together on the left is kim you with

00:15:02,589 --> 00:15:06,430
just the the proxy in it the proxy

00:15:04,990 --> 00:15:08,829
service going in between the two and

00:15:06,430 --> 00:15:10,209
then the emulation code on the right

00:15:08,829 --> 00:15:11,410
again the only thing that we've done

00:15:10,209 --> 00:15:14,110
with apart things marked in red

00:15:11,410 --> 00:15:18,699
everything else is just qmu built from

00:15:14,110 --> 00:15:20,199
qmu and an executable by qu and I'm

00:15:18,699 --> 00:15:24,850
gonna hand it over to Elena and she's

00:15:20,199 --> 00:15:25,510
going to talk a little bit about how but

00:15:24,850 --> 00:15:27,100
by now

00:15:25,510 --> 00:15:30,850
you probably all want to see the code in

00:15:27,100 --> 00:15:32,440
play with this remote processes we're

00:15:30,850 --> 00:15:35,200
not gonna review the code now sorry

00:15:32,440 --> 00:15:38,760
there's no time but you still can go and

00:15:35,200 --> 00:15:44,650
play with with the remote devices and

00:15:38,760 --> 00:15:46,690
qmu multi-process and we don't have the

00:15:44,650 --> 00:15:49,780
patches upstream yet we're working on

00:15:46,690 --> 00:15:52,570
that but you can clone the version from

00:15:49,780 --> 00:15:55,470
the public oracle github go ahead and do

00:15:52,570 --> 00:16:00,820
that configured with the MP q mute key

00:15:55,470 --> 00:16:02,350
build it and you can run it so probably

00:16:00,820 --> 00:16:04,780
people are concerned like how many

00:16:02,350 --> 00:16:06,670
options extra options have to use to run

00:16:04,780 --> 00:16:09,760
it multi-process well not really many

00:16:06,670 --> 00:16:13,150
and I have to repeat what JJ said we

00:16:09,760 --> 00:16:15,940
have actually added one everything else

00:16:13,150 --> 00:16:18,370
is pretty much standard you all know of

00:16:15,940 --> 00:16:23,110
them and it's pretty much easy to run

00:16:18,370 --> 00:16:25,180
it's very easy now some people would

00:16:23,110 --> 00:16:27,730
probably think well okay I have a one

00:16:25,180 --> 00:16:29,590
process maybe I can run one device well

00:16:27,730 --> 00:16:33,100
no you can have multiple processes

00:16:29,590 --> 00:16:37,090
multiple multi processes and you can

00:16:33,100 --> 00:16:39,940
have multiple devices for process you

00:16:37,090 --> 00:16:41,950
can actually try it with the other side

00:16:39,940 --> 00:16:46,720
device so this device was picked by us

00:16:41,950 --> 00:16:53,020
as a great use case scenario and we

00:16:46,720 --> 00:16:56,290
decided to do the job on that and you

00:16:53,020 --> 00:16:58,630
can see how you can run this device now

00:16:56,290 --> 00:17:00,910
the functionality which is right now

00:16:58,630 --> 00:17:04,959
implemented for the qmu multi-process

00:17:00,910 --> 00:17:08,079
includes the qqp monitor so if you would

00:17:04,959 --> 00:17:10,930
like to use your standard QP commands

00:17:08,079 --> 00:17:12,820
with q mu multi process then you will

00:17:10,930 --> 00:17:15,100
just have to specify the socket for this

00:17:12,820 --> 00:17:17,860
remote process and use it as you usually

00:17:15,100 --> 00:17:22,110
use the QP commands including the device

00:17:17,860 --> 00:17:25,420
hot dogs and others though we actually

00:17:22,110 --> 00:17:26,620
do use reduced set of QP commands for

00:17:25,420 --> 00:17:31,410
remote process for now

00:17:26,620 --> 00:17:35,140
now also we know that life migration is

00:17:31,410 --> 00:17:38,740
most people is as important feature so

00:17:35,140 --> 00:17:39,530
we added this too so you can also play

00:17:38,740 --> 00:17:42,800
with that

00:17:39,530 --> 00:17:46,520
we did and it worked we also try to

00:17:42,800 --> 00:17:49,070
apply as a concept as a silliness policy

00:17:46,520 --> 00:17:52,130
for a remote process we did have an

00:17:49,070 --> 00:17:54,830
example of that and it also work we also

00:17:52,130 --> 00:17:58,730
implemented Lubert support which no

00:17:54,830 --> 00:18:02,150
one's seen yet it's an older version so

00:17:58,730 --> 00:18:04,630
but we probably gonna work on it now if

00:18:02,150 --> 00:18:07,100
you want to do more than just use

00:18:04,630 --> 00:18:10,580
multi-process what if you want to have

00:18:07,100 --> 00:18:13,370
your own device run in separate process

00:18:10,580 --> 00:18:17,720
then you don't need to do that much Oh

00:18:13,370 --> 00:18:20,600
we hope you just have to add your proxy

00:18:17,720 --> 00:18:24,140
if it's not there yet you have to

00:18:20,600 --> 00:18:26,210
specify the operations which are needed

00:18:24,140 --> 00:18:30,730
for the communication between the remote

00:18:26,210 --> 00:18:34,220
process and their proxy you just have to

00:18:30,730 --> 00:18:39,290
modify the build system in at the QEP

00:18:34,220 --> 00:18:44,090
commands you want to you want to add now

00:18:39,290 --> 00:18:45,770
in the future what we want to do this

00:18:44,090 --> 00:18:48,140
conference was great because we were

00:18:45,770 --> 00:18:50,840
able to talk to so many people and we

00:18:48,140 --> 00:18:53,150
got a great feedback and we're hoping

00:18:50,840 --> 00:18:56,660
that people are gonna take a look at the

00:18:53,150 --> 00:18:58,940
code and give some thoughts and maybe

00:18:56,660 --> 00:19:02,150
review that there's a version for posted

00:18:58,940 --> 00:19:05,780
on the cumulative L and you're welcome

00:19:02,150 --> 00:19:09,320
to take a look at that we would like to

00:19:05,780 --> 00:19:13,540
add more device types and improve

00:19:09,320 --> 00:19:16,580
performance and work and security more

00:19:13,540 --> 00:19:19,750
in probably a deliberate support because

00:19:16,580 --> 00:19:19,750
it just makes sense

00:19:22,100 --> 00:19:30,200
do we have time we did run some

00:19:27,470 --> 00:19:32,840
preliminary performance tests and we

00:19:30,200 --> 00:19:36,500
didn't notice significant performance

00:19:32,840 --> 00:19:38,630
degradation but don't take him very

00:19:36,500 --> 00:19:42,640
seriously because there's more work to

00:19:38,630 --> 00:19:42,640
do on that subject

00:19:45,160 --> 00:19:53,240
yep that's it from me that's right

00:19:50,990 --> 00:19:55,190
and I we thank you for your time if

00:19:53,240 --> 00:20:02,240
there's any questions we can we can take

00:19:55,190 --> 00:20:03,340
them either everybody's asleep of this

00:20:02,240 --> 00:20:06,990
you did a great job

00:20:03,340 --> 00:20:06,990
[Laughter]

00:20:09,220 --> 00:20:17,270
so for devices where you have a proxy in

00:20:13,400 --> 00:20:21,260
the main qmo and the real thing in the

00:20:17,270 --> 00:20:25,760
wrote qmo how does unblock work do you

00:20:21,260 --> 00:20:27,530
need to you CENTAC unblock command to

00:20:25,760 --> 00:20:30,650
the main queue mo or till you send them

00:20:27,530 --> 00:20:31,400
to both for devices we send it to the

00:20:30,650 --> 00:20:35,179
main queue

00:20:31,400 --> 00:20:36,860
there's the remote processes do have a

00:20:35,179 --> 00:20:41,049
kewpie socket but those are mainly for

00:20:36,860 --> 00:20:41,049
to manage the the backends

00:20:41,539 --> 00:20:47,440
so you need to know where the back-end

00:20:44,179 --> 00:20:51,260
leaves so you sent the qumy qumy

00:20:47,440 --> 00:20:54,950
commands to the right q mm right well

00:20:51,260 --> 00:20:56,390
all device q NP debate related QP

00:20:54,950 --> 00:20:59,150
commands need to go to the main Q

00:20:56,390 --> 00:21:01,970
because Q Nene Q mutant selfie has a

00:20:59,150 --> 00:21:03,140
sort of a picture of the of what the

00:21:01,970 --> 00:21:05,659
platform looks like so if you're gonna

00:21:03,140 --> 00:21:09,020
hot ad or hot and we've actually this

00:21:05,659 --> 00:21:10,100
actually does work we you can hot ad or

00:21:09,020 --> 00:21:13,880
hot subtract

00:21:10,100 --> 00:21:15,230
devices from the from Q you okay yeah

00:21:13,880 --> 00:21:17,480
when it does it absolute send that

00:21:15,230 --> 00:21:20,450
you're like a hot idea to summon Jason

00:21:17,480 --> 00:21:23,390
string of the the new device off to the

00:21:20,450 --> 00:21:25,669
de process and what about the backends

00:21:23,390 --> 00:21:29,720
the backends live only in the remote

00:21:25,669 --> 00:21:32,140
yeah and whom do I have to talk to if I

00:21:29,720 --> 00:21:36,080
want to interact with the backends

00:21:32,140 --> 00:21:38,960
repeat that to which q mo do I have to

00:21:36,080 --> 00:21:41,260
talk via qmp to interact to the backends

00:21:38,960 --> 00:21:43,490
that live only in the remote process boy

00:21:41,260 --> 00:21:45,919
for a QP command that applies to a

00:21:43,490 --> 00:21:48,679
back-end you have to apply that to the

00:21:45,919 --> 00:21:50,270
monitor socket of the of the remote

00:21:48,679 --> 00:21:52,570
process that has that back-end in it

00:21:50,270 --> 00:21:52,570
thank you

00:22:02,290 --> 00:22:06,490
cribs are no questions thank you all

00:22:04,809 --> 00:22:08,310
right thank you thank you

00:22:06,490 --> 00:22:15,150
[Applause]

00:22:08,310 --> 00:22:15,150

YouTube URL: https://www.youtube.com/watch?v=lslVYCuk4CQ


