Title: [2019] Building a Firmware for Virtual Machines using Rust by Rob Bradford
Publication date: 2019-11-12
Playlist: KVM Forum 2019
Description: 
	In the recent past there has been an explosion of innovation in the technology area around Virtual Machine Monitors (also known as hypervisors) based around the Rust programming language including Google’s crosvm for ChromeOS, Amazon’s Firecracker for containers and Intel's Cloud Hypervisor project.

One defining aspect of all the Rust hypervisors that are active or under development is that they do not use a traditional firmware for booting the guest operating system and instead boot directly into a Linux kernel under the control of the host. This limitation makes it much harder to use the hypervisor to provide a general purpose Virtual Machine, often known as a “pet”. In order to mitigate this we have developed the Rust Hypervisor Firmware to allow these Rust based hypervisors to load customer controlled operating systems and enable a wider range of uses.

---

Rob Bradford
Intel Corporation
Software Engineer

Rob has worked on Open Source at Intel for over 10 years on a wide variety of projects spanning from client user experiences, to graphics, to system software and now cloud technologies.

In the field of cloud technologies Rob has been a key contributor to the Cloud Integrated Advanced Orchestrator (Ciao) project and is now involved in the Rust-VMM project and Cloud Hypervisor Project.

Note: There's no video recording available for this talk due to technical issues.
Captions: 
	00:00:00,390 --> 00:00:02,750
[Music]

00:00:06,980 --> 00:00:11,670
good afternoon everyone

00:00:09,809 --> 00:00:13,320
you know I know it's getting towards

00:00:11,670 --> 00:00:15,690
their lunch time and everyone's starting

00:00:13,320 --> 00:00:17,820
to get a bit hungry so I'm the last

00:00:15,690 --> 00:00:21,060
session before we can go for lunch and

00:00:17,820 --> 00:00:23,850
my name is Robert Radford and I worked

00:00:21,060 --> 00:00:26,789
in Intel in the open source group and I

00:00:23,850 --> 00:00:28,740
work in the clouds technologies team and

00:00:26,789 --> 00:00:31,320
I've been working on cloud hypervisor

00:00:28,740 --> 00:00:34,770
that Sam just mentioned in the previous

00:00:31,320 --> 00:00:37,380
slides so today I'm going to be talking

00:00:34,770 --> 00:00:41,550
about building a firmware for virtual

00:00:37,380 --> 00:00:43,140
machines using rust so the project in

00:00:41,550 --> 00:00:45,480
particular that I'm talking about is

00:00:43,140 --> 00:00:48,960
protocol the rust hypervisor firmware

00:00:45,480 --> 00:00:51,090
and so the motivation for this is this

00:00:48,960 --> 00:00:53,430
was my this is my first project board

00:00:51,090 --> 00:00:55,770
for learning rust a lot of people might

00:00:53,430 --> 00:00:56,640
go and do a hello world or maybe you

00:00:55,770 --> 00:00:59,660
know if they're really sophisticated

00:00:56,640 --> 00:01:02,250
trying to implement a doubly-linked list

00:00:59,660 --> 00:01:04,110
but mine was to build a firmware because

00:01:02,250 --> 00:01:05,939
the owner that was my choice so I

00:01:04,110 --> 00:01:09,869
started working on this idea of a

00:01:05,939 --> 00:01:12,330
firmware so you know the motivation for

00:01:09,869 --> 00:01:14,460
this was well we should think about

00:01:12,330 --> 00:01:17,790
unity what why would you want to use

00:01:14,460 --> 00:01:19,140
rust for a firmware well exam covered

00:01:17,790 --> 00:01:21,600
this quite well in the previous session

00:01:19,140 --> 00:01:26,180
but I'll just recap it rust is a new

00:01:21,600 --> 00:01:29,670
language and it's really focused on

00:01:26,180 --> 00:01:31,950
correctness and performance and one of

00:01:29,670 --> 00:01:33,030
the big advantages of it compared to

00:01:31,950 --> 00:01:34,470
some of the other new languages that

00:01:33,030 --> 00:01:36,600
have come out is that it can be compiled

00:01:34,470 --> 00:01:39,810
to native code and giving that same

00:01:36,600 --> 00:01:42,000
performance as C but one of the

00:01:39,810 --> 00:01:44,399
differences of the civil similar

00:01:42,000 --> 00:01:45,659
generation credits as they go is that it

00:01:44,399 --> 00:01:48,180
can do all that memory management

00:01:45,659 --> 00:01:50,040
without any garbage collection and the

00:01:48,180 --> 00:01:53,820
heart of that is the system called the

00:01:50,040 --> 00:01:56,610
borrowing mechanics and you know one of

00:01:53,820 --> 00:01:57,719
the things that they promote it for sort

00:01:56,610 --> 00:01:59,189
of Mozilla guys who originally thought

00:01:57,719 --> 00:02:01,320
it was that it was a good tool for

00:01:59,189 --> 00:02:03,060
systems programming and I can't think of

00:02:01,320 --> 00:02:04,799
any other system z-star project other

00:02:03,060 --> 00:02:07,530
than there's more System z i guess then

00:02:04,799 --> 00:02:08,250
a firmware so let's sort of sort of try

00:02:07,530 --> 00:02:09,810
and trend

00:02:08,250 --> 00:02:13,720
dot that

00:02:09,810 --> 00:02:17,170
but you know why buy a new firmware well

00:02:13,720 --> 00:02:21,010
you know maybe a new vmm such as cloud

00:02:17,170 --> 00:02:23,110
hypervisor will deserves a new firmware

00:02:21,010 --> 00:02:25,570
for it and by firmware I'm sort of

00:02:23,110 --> 00:02:28,200
referring to the kind of the BIOS aspect

00:02:25,570 --> 00:02:30,430
the stuff that the first thing that the

00:02:28,200 --> 00:02:33,450
VM em will execute when it starts

00:02:30,430 --> 00:02:36,190
running and in let's put it on away

00:02:33,450 --> 00:02:39,640
hypervisor is a project built on top of

00:02:36,190 --> 00:02:42,670
the rust vmm components it's a sort of

00:02:39,640 --> 00:02:44,500
high performance type ii v mm using k vm

00:02:42,670 --> 00:02:46,959
we're aiming for minimal hardware

00:02:44,500 --> 00:02:50,590
emulation to minimize the tax surface

00:02:46,959 --> 00:02:52,030
I've got two use cases in mind we want

00:02:50,590 --> 00:02:54,070
something the SUDEP are using with cat

00:02:52,030 --> 00:02:57,190
containers which is in a system that

00:02:54,070 --> 00:03:00,250
lets you run your container workloads

00:02:57,190 --> 00:03:01,810
but isolate them inside of a VM so you

00:03:00,250 --> 00:03:05,140
you don't have some of them to worry

00:03:01,810 --> 00:03:08,950
about compromising the host kernel but

00:03:05,140 --> 00:03:11,140
also more pet VM use cases and by pet VM

00:03:08,950 --> 00:03:15,040
use cases I'm talking about systems such

00:03:11,140 --> 00:03:16,840
as a database server or your front-end

00:03:15,040 --> 00:03:18,610
web servers or something like that where

00:03:16,840 --> 00:03:21,010
you need to have some persistence for it

00:03:18,610 --> 00:03:22,090
and it might not necessarily fall into

00:03:21,010 --> 00:03:23,860
the bucket if I'm going to run

00:03:22,090 --> 00:03:26,830
everything here using kubernetes and

00:03:23,860 --> 00:03:28,269
containers and even those sort of

00:03:26,830 --> 00:03:32,140
situations you have more of a generic

00:03:28,269 --> 00:03:34,510
operating system to running them so why

00:03:32,140 --> 00:03:37,840
not open over your mouth is a great

00:03:34,510 --> 00:03:39,790
project it's a piano core based EFI

00:03:37,840 --> 00:03:41,620
solution that you can use with qmu right

00:03:39,790 --> 00:03:42,790
now and we use that with neem you as

00:03:41,620 --> 00:03:46,299
well and I had some experience

00:03:42,790 --> 00:03:48,820
supporting ivmf to run on the knee mover

00:03:46,299 --> 00:03:52,739
platform which was a platform that we

00:03:48,820 --> 00:03:56,530
proposal we proposed that had a minimal

00:03:52,739 --> 00:03:58,510
horror emulation model but one of the

00:03:56,530 --> 00:04:00,400
experiences that I had from trying to

00:03:58,510 --> 00:04:03,340
Porto vmf on to run on that third

00:04:00,400 --> 00:04:06,880
platform was that it had quite a lot of

00:04:03,340 --> 00:04:10,810
expectations about what the the vmm

00:04:06,880 --> 00:04:13,209
would provide the ACPI p.m. time you

00:04:10,810 --> 00:04:15,480
would have CMOS with getting the memory

00:04:13,209 --> 00:04:18,570
information

00:04:15,480 --> 00:04:20,459
and very unlike a CPC ipam probably

00:04:18,570 --> 00:04:22,889
programming various things and I'm sure

00:04:20,459 --> 00:04:24,840
it would be possible to adapt it to not

00:04:22,889 --> 00:04:27,930
expect those things and to work with the

00:04:24,840 --> 00:04:31,020
environment that we've got but this also

00:04:27,930 --> 00:04:33,060
kind of predates the cloud hypervisor

00:04:31,020 --> 00:04:35,130
project this firmware and in fact it was

00:04:33,060 --> 00:04:39,120
developed initially against firecracker

00:04:35,130 --> 00:04:42,360
which is us super minimal model of the

00:04:39,120 --> 00:04:45,000
way that the vmm works and only one of

00:04:42,360 --> 00:04:47,130
the other aspects is that ovm f is

00:04:45,000 --> 00:04:49,169
full-featured so you can do network boot

00:04:47,130 --> 00:04:51,690
you can boot from there HTTP endpoint

00:04:49,169 --> 00:04:53,250
you've got a full UI for controlling all

00:04:51,690 --> 00:04:55,229
these things and that's great but maybe

00:04:53,250 --> 00:04:58,080
that goes beyond what you might mean for

00:04:55,229 --> 00:05:01,530
many sort of cloud cloud-based workloads

00:04:58,080 --> 00:05:03,690
and as we're really interested in Linux

00:05:01,530 --> 00:05:05,550
based workloads and that's all the main

00:05:03,690 --> 00:05:07,199
focus and in particular sort of a subset

00:05:05,550 --> 00:05:09,030
of the next workloads that the cloud

00:05:07,199 --> 00:05:13,110
images that the various destroyers

00:05:09,030 --> 00:05:16,289
provide we kind of were able to expect

00:05:13,110 --> 00:05:18,630
quite like the low expectations from the

00:05:16,289 --> 00:05:21,150
because Linux is super tolerant of a

00:05:18,630 --> 00:05:24,720
poorly configured hardware or poorly

00:05:21,150 --> 00:05:26,370
configured firmware and one of the big

00:05:24,720 --> 00:05:28,110
aspects we weren't arrested in was

00:05:26,370 --> 00:05:30,720
wanted compatibility with the Linux

00:05:28,110 --> 00:05:32,430
loader and this was the this is

00:05:30,720 --> 00:05:35,039
interesting the Linux loader is it

00:05:32,430 --> 00:05:37,710
component existing in our Rus 4mm that

00:05:35,039 --> 00:05:39,570
we pull into hypervisor but by greg

00:05:37,710 --> 00:05:41,849
hassle and cross VM also has something

00:05:39,570 --> 00:05:44,820
very similar and this will just load the

00:05:41,849 --> 00:05:48,030
VM Linux elf binary in set up a zero

00:05:44,820 --> 00:05:49,950
page and when we're doing that we're

00:05:48,030 --> 00:05:51,630
booting into the with and I've already

00:05:49,950 --> 00:05:54,930
got in long mode with an identity

00:05:51,630 --> 00:05:57,780
mapping the LD TGT set and very

00:05:54,930 --> 00:06:01,050
importantly the hypervisor is providing

00:05:57,780 --> 00:06:04,050
the the EA 20 table of how what the

00:06:01,050 --> 00:06:05,639
memory layout should look like and so

00:06:04,050 --> 00:06:07,500
we've already we were can avoid having

00:06:05,639 --> 00:06:09,389
to emulate say the CMOS to get the

00:06:07,500 --> 00:06:10,800
memory information because we can get

00:06:09,389 --> 00:06:13,470
that from the EA 20 tables that we've

00:06:10,800 --> 00:06:15,960
constructed so without hope this gave us

00:06:13,470 --> 00:06:18,330
the ability to have the boot a more

00:06:15,960 --> 00:06:20,910
full-featured environment for touting

00:06:18,330 --> 00:06:23,520
those cloud images and those those pet

00:06:20,910 --> 00:06:25,770
words without having to do any

00:06:23,520 --> 00:06:28,050
specialization in type of EMM to support

00:06:25,770 --> 00:06:30,889
more of a traditional firmware Avery was

00:06:28,050 --> 00:06:33,680
not in real mode and aspects like that

00:06:30,889 --> 00:06:37,800
so if we can already boot a Linux kernel

00:06:33,680 --> 00:06:40,229
why do we need a firmware and Derek

00:06:37,800 --> 00:06:41,610
loading is fantastic for container style

00:06:40,229 --> 00:06:44,460
workloads that you can use with fire

00:06:41,610 --> 00:06:45,810
cracker or cat containers or where

00:06:44,460 --> 00:06:47,310
you're like Chrome OS where you use

00:06:45,810 --> 00:06:50,940
crostini and your full control of the

00:06:47,310 --> 00:06:52,830
stack but the wider use cases where the

00:06:50,940 --> 00:06:55,620
user wants to just take an off-the-shelf

00:06:52,830 --> 00:06:57,360
image and then control their own kernel

00:06:55,620 --> 00:06:59,159
so they can just do you know yum update

00:06:57,360 --> 00:07:00,449
and up get and getting the app get the

00:06:59,159 --> 00:07:03,509
latest kernel be running the latest

00:07:00,449 --> 00:07:05,250
kernel you you can't really do that if

00:07:03,509 --> 00:07:08,039
the kernel is controlled outside by the

00:07:05,250 --> 00:07:09,479
person who controls the VMF so that's

00:07:08,039 --> 00:07:11,699
why we want to be able to encapsulate it

00:07:09,479 --> 00:07:13,050
so you can almost perspective this that

00:07:11,699 --> 00:07:15,509
the firmware that I'm describing here

00:07:13,050 --> 00:07:17,280
it's almost like I'm a sophisticated

00:07:15,509 --> 00:07:21,449
bootloader that's going to run and then

00:07:17,280 --> 00:07:22,409
start the users chosen kernel so a

00:07:21,449 --> 00:07:24,900
little bit of an overview of the

00:07:22,409 --> 00:07:27,629
architecture we have two modes of

00:07:24,900 --> 00:07:29,099
operation we have support for loading

00:07:27,629 --> 00:07:31,710
systems directly using the

00:07:29,099 --> 00:07:33,449
freedesktop.org bootloader specification

00:07:31,710 --> 00:07:35,759
so this is the same thing this is the

00:07:33,449 --> 00:07:37,560
system D or dummy boot uses and it's

00:07:35,759 --> 00:07:39,659
just a set of any file from the efi

00:07:37,560 --> 00:07:41,039
partition the say here's where my kernel

00:07:39,659 --> 00:07:43,229
can be found here's where you can find

00:07:41,039 --> 00:07:46,199
the analogy and please write this kernel

00:07:43,229 --> 00:07:47,310
command line in the right space as well

00:07:46,199 --> 00:07:50,520
as another file saying which of those

00:07:47,310 --> 00:07:52,080
options is your default and then mmm we

00:07:50,520 --> 00:07:53,400
also have so we use that for booting

00:07:52,080 --> 00:07:55,020
clear Linux which is the distribution

00:07:53,400 --> 00:07:58,500
that kind of ships with cloud images

00:07:55,020 --> 00:08:00,810
that use this and for up distributions

00:07:58,500 --> 00:08:03,870
like a bun - and debian we use efi and

00:08:00,810 --> 00:08:06,409
so we load up the boot exit 64 but we

00:08:03,870 --> 00:08:08,479
have a very minimal efi environment

00:08:06,409 --> 00:08:11,400
so kind of from a freedesktop.org

00:08:08,479 --> 00:08:13,319
loading perspective at the heart of it

00:08:11,400 --> 00:08:14,879
we have our versailles transports we

00:08:13,319 --> 00:08:17,159
spoke both booting from mmio

00:08:14,879 --> 00:08:19,830
booting a firecracker or in cloud

00:08:17,159 --> 00:08:21,930
hypervisor in MI a mode and PCI for

00:08:19,830 --> 00:08:23,069
booty on cloud hypervisor and it occurs

00:08:21,930 --> 00:08:24,449
to me that I could probably work on

00:08:23,069 --> 00:08:27,330
cross VM now but I haven't actually

00:08:24,449 --> 00:08:29,639
tested that me something so then a block

00:08:27,330 --> 00:08:33,000
device actually kind of doing the block

00:08:29,639 --> 00:08:36,449
operations and a GPT partition table GPT

00:08:33,000 --> 00:08:38,670
so we can find the efi table if i and

00:08:36,449 --> 00:08:40,170
the FI partitions are fat

00:08:38,670 --> 00:08:41,790
and it's an interesting thing I'd learn

00:08:40,170 --> 00:08:42,870
about so I learned a lot about systems

00:08:41,790 --> 00:08:44,610
lure the very low level systems

00:08:42,870 --> 00:08:46,200
programming from doing this and one of

00:08:44,610 --> 00:08:48,480
the things about the fact file system is

00:08:46,200 --> 00:08:50,460
that the size of the the the the type of

00:08:48,480 --> 00:08:54,000
the fat file system were to be fat12

00:08:50,460 --> 00:08:57,270
fat16 or fat32 is did time in by the

00:08:54,000 --> 00:09:01,050
size of the partition mix with the size

00:08:57,270 --> 00:09:02,310
of the blocks and you have to implement

00:09:01,050 --> 00:09:03,570
all small them you can't just say I'll

00:09:02,310 --> 00:09:06,030
just do fat32 that's nice and easy

00:09:03,570 --> 00:09:07,980
because if you create an image in most

00:09:06,030 --> 00:09:09,150
of the images that you'll get for cloud

00:09:07,980 --> 00:09:11,250
images will actually have a fat12

00:09:09,150 --> 00:09:12,870
filesystem in them and having to deal

00:09:11,250 --> 00:09:17,340
with twelve bits for your cluster

00:09:12,870 --> 00:09:19,800
addresses is really fun but yeah an

00:09:17,340 --> 00:09:22,530
interesting and challenging and then we

00:09:19,800 --> 00:09:23,940
as we load these any files pass them all

00:09:22,530 --> 00:09:25,650
inside this will have any inside your

00:09:23,940 --> 00:09:29,190
firmware and then we will load the B's

00:09:25,650 --> 00:09:32,880
ed image and the unit are they are boot

00:09:29,190 --> 00:09:35,580
into it for the efi approach it's almost

00:09:32,880 --> 00:09:37,470
identical except we're gonna look on a

00:09:35,580 --> 00:09:41,240
file on look on that fat filesystem for

00:09:37,470 --> 00:09:44,640
your boot x64 efi binary and then

00:09:41,240 --> 00:09:47,940
started and in the e ax when you in the

00:09:44,640 --> 00:09:49,530
xq running we will point to a system to

00:09:47,940 --> 00:09:50,700
any fight if i system table which is all

00:09:49,530 --> 00:09:52,620
the function pointers that have all the

00:09:50,700 --> 00:09:55,740
interesting efi functions that we've

00:09:52,620 --> 00:09:58,410
implemented so you know the very basic

00:09:55,740 --> 00:10:00,960
setup the VMM loads us at the one Meg

00:09:58,410 --> 00:10:03,150
point we have to establish a wider

00:10:00,960 --> 00:10:04,830
identity mapping because the VMS don't

00:10:03,150 --> 00:10:06,780
make it big enough for us so that this

00:10:04,830 --> 00:10:09,630
is so we can access any of the vertol um

00:10:06,780 --> 00:10:12,060
my own devices all the PCI devices that

00:10:09,630 --> 00:10:15,960
are in the four up to the 4 gig we pars

00:10:12,060 --> 00:10:17,970
the MM i/o block device details we read

00:10:15,960 --> 00:10:19,500
the e a 20 table from the zero page to

00:10:17,970 --> 00:10:21,570
find out how much Brown we've got and

00:10:19,500 --> 00:10:23,430
then we need to probe for the block

00:10:21,570 --> 00:10:24,960
devices and search for the appropriate

00:10:23,430 --> 00:10:27,180
file system and we can support multiple

00:10:24,960 --> 00:10:30,480
different block devices and search for

00:10:27,180 --> 00:10:33,780
the right one the freedesktop.org

00:10:30,480 --> 00:10:35,370
loading approach again we are now we

00:10:33,780 --> 00:10:36,960
remember where your one Meg space and

00:10:35,370 --> 00:10:40,170
we've done some we're using a bit of a

00:10:36,960 --> 00:10:42,390
space below there for our stack but we

00:10:40,170 --> 00:10:46,050
also have our the frida so we will load

00:10:42,390 --> 00:10:48,930
a target binary at the 2 Meg we led the

00:10:46,050 --> 00:10:51,330
NLD top of mahram populism online we

00:10:48,930 --> 00:10:51,950
update the zero page we just use the one

00:10:51,330 --> 00:10:54,950
that

00:10:51,950 --> 00:10:56,540
we've been given before by the vmm and

00:10:54,950 --> 00:10:58,730
then we jump into the kernel at the

00:10:56,540 --> 00:10:59,720
setup sit it set up 64 entry point and

00:10:58,730 --> 00:11:00,860
then we're done

00:10:59,720 --> 00:11:02,810
there's no more interaction with the

00:11:00,860 --> 00:11:05,149
firmware which we've got running kernel

00:11:02,810 --> 00:11:07,040
kernel reclaim all this all around that

00:11:05,149 --> 00:11:11,480
we said we you could use and

00:11:07,040 --> 00:11:14,209
everything's happy if I support a bit

00:11:11,480 --> 00:11:18,079
more challenging more difficult the

00:11:14,209 --> 00:11:22,670
binary format used for EFI is the p32

00:11:18,079 --> 00:11:24,290
which is what's used on Windows and we

00:11:22,670 --> 00:11:26,480
need to be able to input inside our us

00:11:24,290 --> 00:11:29,149
code we label the functions with win 64

00:11:26,480 --> 00:11:32,029
to say they need to be a chord with the

00:11:29,149 --> 00:11:33,980
win 64 calling convention and so I've

00:11:32,029 --> 00:11:36,110
implanted this EFI compatibility layer

00:11:33,980 --> 00:11:38,810
which is just I said lots lots of

00:11:36,110 --> 00:11:40,310
functions then call in to the existing

00:11:38,810 --> 00:11:43,029
file system structures that I've created

00:11:40,310 --> 00:11:45,440
or the block systems that I already have

00:11:43,029 --> 00:11:49,190
unfortunately I can make use of this

00:11:45,440 --> 00:11:50,930
crate called our EFI and this is a huge

00:11:49,190 --> 00:11:53,839
pile of Struck's

00:11:50,930 --> 00:11:56,540
through air for implementing EFI data

00:11:53,839 --> 00:11:59,510
structures and this was implemented not

00:11:56,540 --> 00:12:00,410
all someone who wanted to write but for

00:11:59,510 --> 00:12:03,100
some people who wanted to write

00:12:00,410 --> 00:12:08,089
applications to run directly on slide

00:12:03,100 --> 00:12:09,649
their EFI environment EFI has you know

00:12:08,089 --> 00:12:11,779
you exposes quite a lot of things as

00:12:09,649 --> 00:12:15,440
runtime services to it and boot time

00:12:11,779 --> 00:12:17,660
services to the host OS so we have to

00:12:15,440 --> 00:12:20,560
have like a memory allocator file system

00:12:17,660 --> 00:12:22,550
abstraction and block abstraction and

00:12:20,560 --> 00:12:24,140
with all this in place

00:12:22,550 --> 00:12:26,209
I've taught been iteratively adding

00:12:24,140 --> 00:12:27,620
things as I need them so a lot of the

00:12:26,209 --> 00:12:29,660
functions initially started as

00:12:27,620 --> 00:12:33,140
completely empty and now they've been

00:12:29,660 --> 00:12:35,810
filled out with implementations they

00:12:33,140 --> 00:12:38,180
able to boot Linux kernel with built

00:12:35,810 --> 00:12:39,949
with config EFI stub so this is kind of

00:12:38,180 --> 00:12:43,069
cool you can build the same Linux kernel

00:12:39,949 --> 00:12:46,190
there's both a be set image and a PE 32

00:12:43,069 --> 00:12:49,130
binary so you can just boot that but

00:12:46,190 --> 00:12:50,180
also can boot shim and grub with the

00:12:49,130 --> 00:12:54,079
wishes were you getting in a bid to

00:12:50,180 --> 00:12:56,449
image shim expects to find user file

00:12:54,079 --> 00:12:58,250
system API is grub expects to use block

00:12:56,449 --> 00:13:00,230
api's and they all expect to be able to

00:12:58,250 --> 00:13:02,660
have this use the device path

00:13:00,230 --> 00:13:04,670
infrastructure which is very challenging

00:13:02,660 --> 00:13:08,300
system for kind of

00:13:04,670 --> 00:13:10,100
working in device information and wasn't

00:13:08,300 --> 00:13:11,180
both wasn't much fun to implement but

00:13:10,100 --> 00:13:11,870
I'm not aiming for full EFI

00:13:11,180 --> 00:13:13,310
functionality

00:13:11,870 --> 00:13:14,750
I'm just enough to be able to boot these

00:13:13,310 --> 00:13:20,450
cloud operating systems that we care

00:13:14,750 --> 00:13:24,170
about so kind of like wasn't my what my

00:13:20,450 --> 00:13:26,330
thoughts my evaluation of how like it

00:13:24,170 --> 00:13:28,550
was to use rust and to build a new

00:13:26,330 --> 00:13:31,640
hypervisor firmware I said it was my

00:13:28,550 --> 00:13:33,140
first project with rust and so I'm sure

00:13:31,640 --> 00:13:35,630
looking back I'm sure I've made loads of

00:13:33,140 --> 00:13:38,180
errors but one of the things that was

00:13:35,630 --> 00:13:39,920
very challenging was there wasn't a huge

00:13:38,180 --> 00:13:43,130
amount of information about how to do

00:13:39,920 --> 00:13:44,570
such low-level things in rust because a

00:13:43,130 --> 00:13:46,040
lot of people talk about you know he's

00:13:44,570 --> 00:13:47,720
got great it's got memory safety and

00:13:46,040 --> 00:13:50,330
you've got all these things but they're

00:13:47,720 --> 00:13:51,860
like oh yeah you know I have to you know

00:13:50,330 --> 00:13:53,900
I have to have low low level memory

00:13:51,860 --> 00:13:57,710
access because I doesn't there's no

00:13:53,900 --> 00:14:00,740
operating system here I am the operating

00:13:57,710 --> 00:14:03,920
system I am running directly on in the

00:14:00,740 --> 00:14:06,620
VM so yes it helps avoid a lot of these

00:14:03,920 --> 00:14:09,700
issues you're constantly having to work

00:14:06,620 --> 00:14:13,280
around to do what you need to do and

00:14:09,700 --> 00:14:16,250
some of that was mitigated by creating

00:14:13,280 --> 00:14:18,080
this sort of safe wrapper too unsafe

00:14:16,250 --> 00:14:20,270
memory access so that I could actually

00:14:18,080 --> 00:14:23,060
make sure that when I said hey I'm gonna

00:14:20,270 --> 00:14:27,050
copy this slice from my from the elf

00:14:23,060 --> 00:14:28,970
binary into into this area here I would

00:14:27,050 --> 00:14:30,590
like to make sure that the bounds of

00:14:28,970 --> 00:14:33,440
correct I'm not going to go outside what

00:14:30,590 --> 00:14:35,270
I've already said I'm going to use but

00:14:33,440 --> 00:14:39,200
you have to be had to create add to

00:14:35,270 --> 00:14:41,150
create new abstractions for that but you

00:14:39,200 --> 00:14:43,760
know there's a lot of interesting

00:14:41,150 --> 00:14:45,470
challenges around kind of bypassing some

00:14:43,760 --> 00:14:49,790
of the behavior but it needs to do I had

00:14:45,470 --> 00:14:52,400
to get by API in particular yeah like

00:14:49,790 --> 00:14:54,710
expects to have that you could just a

00:14:52,400 --> 00:14:57,170
cool thing the static variables out of

00:14:54,710 --> 00:14:59,660
out of out of nowhere because there are

00:14:57,170 --> 00:15:02,440
some functions that don't take a context

00:14:59,660 --> 00:15:06,800
and static variables and rust can't

00:15:02,440 --> 00:15:08,150
really be mutable because there's

00:15:06,800 --> 00:15:09,770
obviously breaks and threading up I know

00:15:08,150 --> 00:15:11,090
I'm not going to be multi-threaded so

00:15:09,770 --> 00:15:13,160
there are sort of workarounds that you

00:15:11,090 --> 00:15:15,560
have to adopt there there are other

00:15:13,160 --> 00:15:17,490
things like I had to find a container of

00:15:15,560 --> 00:15:21,089
style implementation because of

00:15:17,490 --> 00:15:23,880
and more limitation more differences of

00:15:21,089 --> 00:15:25,740
opinion in the bids within the efi api

00:15:23,880 --> 00:15:27,690
to the way that rust would expect things

00:15:25,740 --> 00:15:31,260
to be written and so that's kind of

00:15:27,690 --> 00:15:32,790
quite challenging but it does work but

00:15:31,260 --> 00:15:35,660
one of the cool benefits of rust is it's

00:15:32,790 --> 00:15:38,370
super economic so I use the vs code

00:15:35,660 --> 00:15:40,620
editor now and with the rust language

00:15:38,370 --> 00:15:43,080
server it will dynamically compile the

00:15:40,620 --> 00:15:45,180
code as I type it and then I let me know

00:15:43,080 --> 00:15:47,149
directly navigate which gives a pretty

00:15:45,180 --> 00:15:51,450
good organ Omikron

00:15:47,149 --> 00:15:54,440
but to be able to use builder just this

00:15:51,450 --> 00:15:56,850
sort of operating system less binary I

00:15:54,440 --> 00:16:00,240
have to have a custom compiler target

00:15:56,850 --> 00:16:01,980
that now that's a nightly feature so I

00:16:00,240 --> 00:16:03,959
have to use nightly and sometimes night

00:16:01,980 --> 00:16:06,570
and he doesn't actually compile with

00:16:03,959 --> 00:16:10,500
itself because it's so for the core

00:16:06,570 --> 00:16:13,170
there's this core core compact I guess

00:16:10,500 --> 00:16:15,810
it's not quite a crate but it's instead

00:16:13,170 --> 00:16:17,190
of a the the standard library you have

00:16:15,810 --> 00:16:19,470
core which doesn't depend on your

00:16:17,190 --> 00:16:20,910
operating system features but then when

00:16:19,470 --> 00:16:23,310
you use something that uses core it

00:16:20,910 --> 00:16:24,660
compiles itself into the binary of using

00:16:23,310 --> 00:16:26,160
but sometimes it does get par with the

00:16:24,660 --> 00:16:28,290
nightly compiler even though the core

00:16:26,160 --> 00:16:30,480
came from nightly so that's pretty

00:16:28,290 --> 00:16:31,980
difficult you know you know if you you

00:16:30,480 --> 00:16:35,520
can pin the compiler version you're

00:16:31,980 --> 00:16:37,589
using and that's okay but the firmware

00:16:35,520 --> 00:16:41,550
patterns that you get with doing with

00:16:37,589 --> 00:16:44,010
rust does kind of push rusts to its

00:16:41,550 --> 00:16:45,839
limits I really feel like I have testing

00:16:44,010 --> 00:16:48,630
the boundaries assembly for instance is

00:16:45,839 --> 00:16:50,490
nightly only feature and they're still

00:16:48,630 --> 00:16:51,600
very much experimental and something you

00:16:50,490 --> 00:16:53,339
we don't we only have a little bit of

00:16:51,600 --> 00:16:58,950
assembly code but mostly to kind of

00:16:53,339 --> 00:17:01,230
enable the SSE to so we can do the the

00:16:58,950 --> 00:17:03,839
we're in 64 calling convention for EFI

00:17:01,230 --> 00:17:07,290
and also like to just move the stack

00:17:03,839 --> 00:17:09,300
around but it's got great performance

00:17:07,290 --> 00:17:11,550
the performance is equivalent of using

00:17:09,300 --> 00:17:13,559
anything in C and there is quite a nice

00:17:11,550 --> 00:17:15,510
community of people developing operating

00:17:13,559 --> 00:17:17,370
systems in rust so there's quite a lot

00:17:15,510 --> 00:17:19,770
of information out there about how to

00:17:17,370 --> 00:17:21,630
try doing these things and there's a few

00:17:19,770 --> 00:17:24,510
sort of people doing crates for doing

00:17:21,630 --> 00:17:27,809
low-level io port access and that our

00:17:24,510 --> 00:17:29,940
efi creates really useful but yeah

00:17:27,809 --> 00:17:30,590
there's definitely some things there and

00:17:29,940 --> 00:17:32,179
i you know

00:17:30,590 --> 00:17:34,549
I hope that people will use the project

00:17:32,179 --> 00:17:35,960
that I've got here too as sources to how

00:17:34,549 --> 00:17:37,100
you could build if you know if you want

00:17:35,960 --> 00:17:38,720
to prop reciting what you're looking for

00:17:37,100 --> 00:17:43,880
a vertigo block drive or how you could

00:17:38,720 --> 00:17:44,960
do PCI in rust and yeah and I guess one

00:17:43,880 --> 00:17:46,730
of the areas that I'd like to highlight

00:17:44,960 --> 00:17:50,270
is that you know in terms of kind of

00:17:46,730 --> 00:17:54,220
compactness the entire firmware before I

00:17:50,270 --> 00:17:58,250
added the before I added the support for

00:17:54,220 --> 00:18:01,850
the efi code the the binary blob was up

00:17:58,250 --> 00:18:04,250
was I think a 56k and now it's either

00:18:01,850 --> 00:18:08,000
the EFI stuff and is 106 K so that's our

00:18:04,250 --> 00:18:10,940
entire sort of firmware support and yeah

00:18:08,000 --> 00:18:13,250
I mean in kind in conclusion and sort of

00:18:10,940 --> 00:18:15,890
summarizing the next step this is still

00:18:13,250 --> 00:18:18,529
kind of an experiment it you you could

00:18:15,890 --> 00:18:20,149
use it in limited production I guess but

00:18:18,529 --> 00:18:21,860
I'm not saying if definitely because

00:18:20,149 --> 00:18:23,480
it's still some somewhat and limited

00:18:21,860 --> 00:18:26,149
operations have already supports Ubuntu

00:18:23,480 --> 00:18:27,860
Linux I and I regularly test of

00:18:26,149 --> 00:18:29,419
operating systems unfortunately it can't

00:18:27,860 --> 00:18:34,159
be for the fedora cloud images don't

00:18:29,419 --> 00:18:36,950
support booting on the efi so that's not

00:18:34,159 --> 00:18:38,539
one that supported the moment better so

00:18:36,950 --> 00:18:40,669
it's currently develops and tested

00:18:38,539 --> 00:18:43,640
against hypervisor and fire cracker for

00:18:40,669 --> 00:18:45,320
MOA oh and we're looking for like

00:18:43,640 --> 00:18:47,510
external contributions somebody's

00:18:45,320 --> 00:18:50,480
expressed interest in taking the

00:18:47,510 --> 00:18:52,880
firmware and as I said it's usually

00:18:50,480 --> 00:18:55,159
loaded in as an elf binary in us already

00:18:52,880 --> 00:18:56,929
and 64-bit long mode with everything set

00:18:55,159 --> 00:19:01,159
up and they're interested in adding a

00:18:56,929 --> 00:19:05,059
little bit of pre pre pre execution code

00:19:01,159 --> 00:19:06,350
that would take it from real mode set up

00:19:05,059 --> 00:19:07,640
all those things that it expects and

00:19:06,350 --> 00:19:09,590
then you could just jump straight in and

00:19:07,640 --> 00:19:13,750
you could use it with Q or anything else

00:19:09,590 --> 00:19:17,049
that expects as traditional-style by us

00:19:13,750 --> 00:19:17,049
any questions

00:19:20,980 --> 00:19:25,160
Thanks

00:19:22,490 --> 00:19:29,270
so what percent of your codebase would

00:19:25,160 --> 00:19:30,710
be an unsafe code as in rust oh because

00:19:29,270 --> 00:19:32,570
that's where I would look if I would do

00:19:30,710 --> 00:19:33,800
security review yeah okay so it's really

00:19:32,570 --> 00:19:35,630
critical there that's a really great

00:19:33,800 --> 00:19:37,430
question so you know and I'll just

00:19:35,630 --> 00:19:38,870
declare what the unsafe key to you in

00:19:37,430 --> 00:19:42,350
rust if you want to do anything that the

00:19:38,870 --> 00:19:44,570
rust compile it considers to be here be

00:19:42,350 --> 00:19:46,310
dragons dangerous you use this unsafe

00:19:44,570 --> 00:19:48,740
keyword and then the subsequent block

00:19:46,310 --> 00:19:50,090
that you use is be labeled as unsafe and

00:19:48,740 --> 00:19:52,340
you can in there you can do things like

00:19:50,090 --> 00:19:54,650
pointer arithmetic and things that would

00:19:52,340 --> 00:19:55,970
not normally be allowed but you could it

00:19:54,650 --> 00:19:57,620
still appears to a lot of constraints

00:19:55,970 --> 00:19:59,650
you can't go outside of bounds in memory

00:19:57,620 --> 00:20:03,950
directly and you can't guess I just lice

00:19:59,650 --> 00:20:07,100
so the majority of the unsafe code is

00:20:03,950 --> 00:20:08,450
hidden inside this memory accessing

00:20:07,100 --> 00:20:12,170
crate which has bad does all the bounds

00:20:08,450 --> 00:20:14,510
checking explicitly and then inside the

00:20:12,170 --> 00:20:16,910
efi there's a little bit of assembly

00:20:14,510 --> 00:20:19,480
unsafe code but all the first IO star

00:20:16,910 --> 00:20:23,840
all the fat file system that's all safe

00:20:19,480 --> 00:20:26,420
there is a little bit of a little bit of

00:20:23,840 --> 00:20:30,080
I calling system unsafe core functions

00:20:26,420 --> 00:20:33,530
for being able to turn the ASCII the

00:20:30,080 --> 00:20:36,440
byte array into an ASCII string but

00:20:33,530 --> 00:20:38,870
that's kind of fairly sensible but then

00:20:36,440 --> 00:20:42,410
the efi code has some unsafe stuff

00:20:38,870 --> 00:20:44,390
because i have to do some dealing with

00:20:42,410 --> 00:20:46,640
raw pointers because of like some

00:20:44,390 --> 00:20:48,110
designs of choices in the efi code which

00:20:46,640 --> 00:20:50,030
would work absolutely fine in there c

00:20:48,110 --> 00:20:51,230
environment where inspect you'd have

00:20:50,030 --> 00:20:53,120
stuff variables or you people do things

00:20:51,230 --> 00:20:54,980
like container of or would be able to

00:20:53,120 --> 00:20:56,330
have just brought pointers to things so

00:20:54,980 --> 00:20:59,270
the efi code has a little bit more

00:20:56,330 --> 00:21:01,130
unsafe stuff but it's i've been careful

00:20:59,270 --> 00:21:02,870
I haven't got a particular percentage

00:21:01,130 --> 00:21:04,460
number but it's always something I've

00:21:02,870 --> 00:21:07,600
been conscious of to make sure that you

00:21:04,460 --> 00:21:10,250
can rationalize while doing unsafe code

00:21:07,600 --> 00:21:14,570
but it's in the minority to answer your

00:21:10,250 --> 00:21:18,830
question thank you for the talk as far

00:21:14,570 --> 00:21:19,340
as I can see so what you're doing is you

00:21:18,830 --> 00:21:21,380
have a

00:21:19,340 --> 00:21:24,740
efi stop emulator if a bootloader and

00:21:21,380 --> 00:21:28,400
you have some remaining firmware how

00:21:24,740 --> 00:21:29,110
does your project compared to the oral

00:21:28,400 --> 00:21:31,139
boot

00:21:29,110 --> 00:21:34,600
firmware which is also written in rust

00:21:31,139 --> 00:21:38,200
which one or boot Oh re and then boot

00:21:34,600 --> 00:21:39,129
like the iron or well I'm poppy admit I

00:21:38,200 --> 00:21:42,100
haven't even heard of it

00:21:39,129 --> 00:21:45,249
so there you go I think there are just

00:21:42,100 --> 00:21:48,429
one and a half years old okay so okay

00:21:45,249 --> 00:21:49,749
that's very good well you know I took a

00:21:48,429 --> 00:21:51,909
lot of inspire I haven't heard of that I

00:21:49,749 --> 00:21:52,239
took a lot of inspiration from from you

00:21:51,909 --> 00:21:54,369
bucht

00:21:52,239 --> 00:21:57,749
for working out how to do the efi

00:21:54,369 --> 00:21:57,749
compatibility and that was very valuable

00:22:06,520 --> 00:22:11,030
so one of the things you mentioned is

00:22:08,840 --> 00:22:13,340
that the reason you have this firmware

00:22:11,030 --> 00:22:15,860
at all is to support more traditional

00:22:13,340 --> 00:22:18,410
cloud use cases so things like boot

00:22:15,860 --> 00:22:20,390
order stuff like that would part of your

00:22:18,410 --> 00:22:23,270
sort of things you would want to add be

00:22:20,390 --> 00:22:24,740
things like UEFI variables for

00:22:23,270 --> 00:22:28,730
controlling boot order because I know a

00:22:24,740 --> 00:22:29,960
lot of images will do that so I know

00:22:28,730 --> 00:22:32,450
that's harder because that's a great

00:22:29,960 --> 00:22:34,340
question so I was actually thinking into

00:22:32,450 --> 00:22:35,720
this so one thing that one of the

00:22:34,340 --> 00:22:37,970
challenges that I came up with when I

00:22:35,720 --> 00:22:40,040
was in adding support for the latest of

00:22:37,970 --> 00:22:42,530
interior's release is that they do not

00:22:40,040 --> 00:22:45,980
have the virtio drivers inside their

00:22:42,530 --> 00:22:48,110
init disk instead you have you boot the

00:22:45,980 --> 00:22:49,580
kernel it will fail it will reboot and

00:22:48,110 --> 00:22:52,730
then it will be again with the init room

00:22:49,580 --> 00:22:54,860
disk which is but it will save those

00:22:52,730 --> 00:22:56,870
details inside the grub settings file so

00:22:54,860 --> 00:22:58,549
I had to add support for writing to the

00:22:56,870 --> 00:23:00,110
blog device and writing to the file

00:22:58,549 --> 00:23:03,169
system not something that I had

00:23:00,110 --> 00:23:04,880
originally and and and an exposed to

00:23:03,169 --> 00:23:06,470
through EFI and it wasn't actually quite

00:23:04,880 --> 00:23:08,330
minimal so now I was realizing that I

00:23:06,470 --> 00:23:09,950
should be able to do that and store the

00:23:08,330 --> 00:23:12,530
EFI variables because if you look at the

00:23:09,950 --> 00:23:14,240
way ovm F does efi variables it just

00:23:12,530 --> 00:23:15,860
puts it in a file in the in the efi

00:23:14,240 --> 00:23:16,970
partition so I think that would be the

00:23:15,860 --> 00:23:19,330
way I'd implement it and that seems

00:23:16,970 --> 00:23:19,330
pretty reasonable

00:23:25,210 --> 00:23:29,700
so thank you yeah excellent thank you

00:23:27,430 --> 00:23:29,700
very much

00:23:30,180 --> 00:23:37,019

YouTube URL: https://www.youtube.com/watch?v=UhlHj6-SNwI


