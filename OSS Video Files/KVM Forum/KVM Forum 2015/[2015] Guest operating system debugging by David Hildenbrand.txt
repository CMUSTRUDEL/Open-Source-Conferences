Title: [2015] Guest operating system debugging by David Hildenbrand
Publication date: 2015-09-02
Playlist: KVM Forum 2015
Description: 
	Debugging operating systems is a non-trivial task and requires good tooling support. Access to vital information is often cumbersome or restricted, and areas like early boot code are inaccessible. Classical debugging techniques rely on a still somewhat functioning target system, which makes debugging in some scenarios impossible. But virtualization gives access to a whole new set of debugging techniques, some of them even exploiting specialized hardware support. This talk outlines typical debugging scenarios and identifies areas where virtualization specific debugging techniques, like guest profiling, guest tracing or interactive guest debugging, can be the better choice. KVM on z Systems is used to show what is currently possible, how it is used in practice, and what could be done in that area in the future.

David Hildenbrand
IBM
David has been working as software developer at IBM on QEMU/KVM for Linux on z Systems for ~1.5 years. His projects include hardware support for guest debugging and architecture compliance.

Slides: https://drive.google.com/file/d/0BzyAwvVlQckecGhWVThXZVlKMGM/view?usp=sharing
Captions: 
	00:00:13,880 --> 00:00:19,650
so are welcome everybody my name is

00:00:16,830 --> 00:00:23,730
David hoon blunt I'm working as a

00:00:19,650 --> 00:00:26,880
software engineer at IBM and yeah you

00:00:23,730 --> 00:00:30,320
will usually find me working on KDM m2m

00:00:26,880 --> 00:00:33,300
you for IBM on Sea Systems so f 3 90 x

00:00:30,320 --> 00:00:36,020
yeah today I want to talk about guest

00:00:33,300 --> 00:00:38,399
operating system debugging so basically

00:00:36,020 --> 00:00:40,500
operating system debugging in a

00:00:38,399 --> 00:00:42,809
virtualized environment so which

00:00:40,500 --> 00:00:45,840
different techniques do we have what's

00:00:42,809 --> 00:00:49,320
still missing yeah and like give you a

00:00:45,840 --> 00:00:51,989
good overview of that whole topic so i

00:00:49,320 --> 00:00:54,510
have to say that i have a sore throat so

00:00:51,989 --> 00:00:57,149
i'm sorry if my voice will fail during

00:00:54,510 --> 00:00:58,770
this session I'll them to start like

00:00:57,149 --> 00:01:02,010
with alternative ways to communicate

00:00:58,770 --> 00:01:04,409
with you guys like shake my hands or

00:01:02,010 --> 00:01:08,070
stuff like that so get to see if this

00:01:04,409 --> 00:01:10,200
will work all right then I want to start

00:01:08,070 --> 00:01:12,990
with two quotes some of you might

00:01:10,200 --> 00:01:15,060
already know the first quote it

00:01:12,990 --> 00:01:17,189
basically says that you're not able to

00:01:15,060 --> 00:01:20,040
debug your own code this is some bad

00:01:17,189 --> 00:01:22,770
news the second one is from a friend of

00:01:20,040 --> 00:01:24,299
mine and it basically says that there is

00:01:22,770 --> 00:01:26,670
some code out there that you're

00:01:24,299 --> 00:01:31,140
obviously not in a technical sense

00:01:26,670 --> 00:01:33,329
strong enough to debug I think this

00:01:31,140 --> 00:01:37,170
might be problematic in the real world

00:01:33,329 --> 00:01:40,729
so um we want to do something about it

00:01:37,170 --> 00:01:43,590
to finally be able to debug our code

00:01:40,729 --> 00:01:45,450
well I think personally to overcome

00:01:43,590 --> 00:01:47,220
these definitions we need some pretty

00:01:45,450 --> 00:01:49,560
good debugging tools and techniques to

00:01:47,220 --> 00:01:55,530
make it at least some how feasible to

00:01:49,560 --> 00:01:58,020
debug yeah Oh code alright so in the

00:01:55,530 --> 00:02:01,170
first part of this session I want to

00:01:58,020 --> 00:02:04,020
talk about the basics Oh which debugging

00:02:01,170 --> 00:02:06,329
tools and techniques we have which use

00:02:04,020 --> 00:02:08,670
cases do we have and in the second part

00:02:06,329 --> 00:02:11,039
of this session I am going to go into

00:02:08,670 --> 00:02:12,580
some advanced use cases that are made

00:02:11,039 --> 00:02:16,380
possible with the sim

00:02:12,580 --> 00:02:21,330
ambulation beyond below our our

00:02:16,380 --> 00:02:26,080
operating system also gives to yous yous

00:02:21,330 --> 00:02:29,590
usages examples related to IBS II system

00:02:26,080 --> 00:02:33,850
so how we used it and how you might use

00:02:29,590 --> 00:02:35,830
it in your setup I'll also give you an

00:02:33,850 --> 00:02:38,110
outlook from my point of view what I

00:02:35,830 --> 00:02:40,120
think what's missing and what could be

00:02:38,110 --> 00:02:42,760
done in the whole debugging area in the

00:02:40,120 --> 00:02:44,110
future yeah and hopefully we have some

00:02:42,760 --> 00:02:47,250
time for the tips and tricks section

00:02:44,110 --> 00:02:49,600
which contains some pretty useful stuff

00:02:47,250 --> 00:02:52,150
yeah we'll see if we have enough time

00:02:49,600 --> 00:02:54,400
and maybe you have so much questions

00:02:52,150 --> 00:02:59,560
that we like want to be able to do it

00:02:54,400 --> 00:03:02,860
yeah let's just get started so why would

00:02:59,560 --> 00:03:06,340
we want to debug guests so I was able to

00:03:02,860 --> 00:03:08,590
come up with several use cases the first

00:03:06,340 --> 00:03:10,990
one being of course that we have certain

00:03:08,590 --> 00:03:13,840
paxton can only be triggered in a

00:03:10,990 --> 00:03:15,820
virtualized environment in which case we

00:03:13,840 --> 00:03:17,830
really have to run the operating system

00:03:15,820 --> 00:03:20,440
in our guest and debug our guest of

00:03:17,830 --> 00:03:24,190
course to like track that back down and

00:03:20,440 --> 00:03:25,930
to fix it of course we can use all these

00:03:24,190 --> 00:03:29,860
debugging tools and techniques we have

00:03:25,930 --> 00:03:32,100
also for like general bugs in the

00:03:29,860 --> 00:03:35,470
operating system in the guest Colonel

00:03:32,100 --> 00:03:39,489
yeah just make use of the other tools we

00:03:35,470 --> 00:03:42,970
have in virtualized environment where

00:03:39,489 --> 00:03:46,090
sometimes able to debug our bios or the

00:03:42,970 --> 00:03:49,540
boot loaders which are running in the

00:03:46,090 --> 00:03:52,660
guest and that is usually not possible

00:03:49,540 --> 00:03:56,680
in a ordinary operating system on

00:03:52,660 --> 00:04:02,709
running on like real Hardware another

00:03:56,680 --> 00:04:06,100
use case might be that we want to see if

00:04:02,709 --> 00:04:09,459
we have a back in OV mm say in KML GMU

00:04:06,100 --> 00:04:12,640
we want to see which affected back that

00:04:09,459 --> 00:04:14,880
bark hairs on to our guests so for

00:04:12,640 --> 00:04:17,890
example if we have like a buck in

00:04:14,880 --> 00:04:20,830
intercept handler we can directly see by

00:04:17,890 --> 00:04:24,070
debugging the guest on what went wrong

00:04:20,830 --> 00:04:26,230
at what point in time and of course

00:04:24,070 --> 00:04:28,510
whenever we give our code we

00:04:26,230 --> 00:04:31,060
learn something about the code so it

00:04:28,510 --> 00:04:33,580
really helps to understand the code and

00:04:31,060 --> 00:04:37,570
hopefully it also helps to avoid further

00:04:33,580 --> 00:04:40,380
bugs in the future hopefully yeah so I

00:04:37,570 --> 00:04:43,210
was able to come up with an additional

00:04:40,380 --> 00:04:45,850
use cases some of you might argue that

00:04:43,210 --> 00:04:48,670
it is not really a use case so I think

00:04:45,850 --> 00:04:50,290
that you can like really show your

00:04:48,670 --> 00:04:53,470
colleagues who's the cool guy in the

00:04:50,290 --> 00:04:55,630
office or in the department so yeah just

00:04:53,470 --> 00:04:59,110
ride it out debug some guests and like

00:04:55,630 --> 00:05:06,610
share your experience and yeah let's see

00:04:59,110 --> 00:05:09,820
what the responses will be so these are

00:05:06,610 --> 00:05:14,320
some let's call it categories of box so

00:05:09,820 --> 00:05:16,150
how parks appear in the wild um I didn't

00:05:14,320 --> 00:05:18,550
make this up on my own so I took this

00:05:16,150 --> 00:05:21,130
from the book from Robert love so

00:05:18,550 --> 00:05:23,590
related to operating systems we can have

00:05:21,130 --> 00:05:25,840
parks that lead directly to system

00:05:23,590 --> 00:05:27,810
crashes which is actually pretty bad

00:05:25,840 --> 00:05:30,640
because like that is unrecoverable

00:05:27,810 --> 00:05:33,580
sometimes we simply have a kernel panic

00:05:30,640 --> 00:05:36,340
and like our system is down on let's

00:05:33,580 --> 00:05:39,580
just think about those beautiful windows

00:05:36,340 --> 00:05:43,380
blue screens right with those nice

00:05:39,580 --> 00:05:47,290
messages like explaining everything of

00:05:43,380 --> 00:05:49,570
course sandbox are not that bad they

00:05:47,290 --> 00:05:52,360
might simply like lead to a performance

00:05:49,570 --> 00:05:55,270
degradation for example if we use

00:05:52,360 --> 00:05:56,890
inefficient locking or if you like use

00:05:55,270 --> 00:06:01,050
some oats type hauling in some

00:05:56,890 --> 00:06:03,160
situations or like some bad algorithms

00:06:01,050 --> 00:06:07,330
basically our system wills to continue

00:06:03,160 --> 00:06:09,640
to work hopefully but it's simply too

00:06:07,330 --> 00:06:15,070
slow for our taste so that might be one

00:06:09,640 --> 00:06:16,840
kind of bug incorrect behavior might be

00:06:15,070 --> 00:06:20,530
from my point of view one of the most

00:06:16,840 --> 00:06:22,840
common types of bucks so I mean most of

00:06:20,530 --> 00:06:25,390
the time your system still works but it

00:06:22,840 --> 00:06:27,400
doesn't like behaviors expected for

00:06:25,390 --> 00:06:31,540
example if you like just have some wrong

00:06:27,400 --> 00:06:37,270
calculations in it that locks might be

00:06:31,540 --> 00:06:39,860
really hard to debug as I can say so on

00:06:37,270 --> 00:06:43,189
one hand Tim may not be

00:06:39,860 --> 00:06:46,250
to be reproduced or only really hard to

00:06:43,189 --> 00:06:48,800
be reproduced and most of the time your

00:06:46,250 --> 00:06:51,889
system might stay alive but in some

00:06:48,800 --> 00:06:55,219
situations it will suddenly hang so

00:06:51,889 --> 00:06:58,129
that's crazy and what I think is the

00:06:55,219 --> 00:07:00,379
worst type of park that can happen is

00:06:58,129 --> 00:07:03,500
data corruption related to random memory

00:07:00,379 --> 00:07:06,080
overwrite so could happen that your

00:07:03,500 --> 00:07:08,360
system stays alive for like several days

00:07:06,080 --> 00:07:12,319
and suddenly you have some random trash

00:07:08,360 --> 00:07:15,650
and no way to reproduce it so in that

00:07:12,319 --> 00:07:19,330
case you really will have trouble to

00:07:15,650 --> 00:07:19,330
track that vector at that back down

00:07:19,569 --> 00:07:24,349
related to virtualization we have

00:07:22,039 --> 00:07:26,539
different levels where we can apply or

00:07:24,349 --> 00:07:30,919
debugging techniques so the most common

00:07:26,539 --> 00:07:33,439
one that like I named inbound is or when

00:07:30,919 --> 00:07:35,000
you simply apply the existing debugging

00:07:33,439 --> 00:07:37,490
tools and techniques for example we have

00:07:35,000 --> 00:07:40,939
on linux in the guest let's say you just

00:07:37,490 --> 00:07:43,909
use / in the guest that's it you don't

00:07:40,939 --> 00:07:47,599
need virtualization for that another

00:07:43,909 --> 00:07:50,300
thing is when you try to apply debugging

00:07:47,599 --> 00:07:52,069
techniques from your hypervisor in order

00:07:50,300 --> 00:07:55,339
to debug the guest so on the one hand

00:07:52,069 --> 00:07:57,889
you might simply debug your vm m so we

00:07:55,339 --> 00:07:59,779
could be back um you to find out what's

00:07:57,889 --> 00:08:03,650
wrong about a guest that might work in

00:07:59,779 --> 00:08:07,069
some situations on the other hand most

00:08:03,650 --> 00:08:11,990
be mms for example um you provide a way

00:08:07,069 --> 00:08:14,120
for for outbound debugging for example

00:08:11,990 --> 00:08:16,610
we can what I'm going to talk about

00:08:14,120 --> 00:08:18,349
later attach a debugger directly to the

00:08:16,610 --> 00:08:21,439
guests to buy OEM you which is actually

00:08:18,349 --> 00:08:25,189
pretty cool and yeah the focus of this

00:08:21,439 --> 00:08:27,909
presentation will of course be on guest

00:08:25,189 --> 00:08:31,460
debugging from an out point out born

00:08:27,909 --> 00:08:37,579
point of view and yeah I'll also cover a

00:08:31,460 --> 00:08:41,060
little bit VMM debugging alright so this

00:08:37,579 --> 00:08:44,540
is a big matrix BigTable about the

00:08:41,060 --> 00:08:47,660
current state of the art I'm pretty sure

00:08:44,540 --> 00:08:49,690
that this one is not complete and there

00:08:47,660 --> 00:08:52,420
might be something missing and

00:08:49,690 --> 00:08:55,390
that it's not some like important stuff

00:08:52,420 --> 00:08:57,430
and I'm not going to go over all of this

00:08:55,390 --> 00:09:03,130
because this will like just exceeded

00:08:57,430 --> 00:09:05,200
time too much so on the left side we

00:09:03,130 --> 00:09:08,020
have the inbound techniques that like

00:09:05,200 --> 00:09:11,200
most of you should know when you simply

00:09:08,020 --> 00:09:14,770
debug an operating system in the middle

00:09:11,200 --> 00:09:18,670
we have to be mm debugging so this whole

00:09:14,770 --> 00:09:21,640
column is related to GMU in this example

00:09:18,670 --> 00:09:23,680
so of course we could like directly use

00:09:21,640 --> 00:09:26,140
the log files or the trays and influence

00:09:23,680 --> 00:09:29,020
for our structure from qmu to like see

00:09:26,140 --> 00:09:33,130
what's happening in the B&M interim you

00:09:29,020 --> 00:09:36,460
are in KDM for example we could like

00:09:33,130 --> 00:09:39,430
dumb the VMM so if we have a process

00:09:36,460 --> 00:09:42,160
done and analyze it later on but that's

00:09:39,430 --> 00:09:44,890
most of the 10 that really helpful but

00:09:42,160 --> 00:09:48,160
one cool thing is related to system

00:09:44,890 --> 00:09:50,260
utilities on the perv KDM statue all

00:09:48,160 --> 00:09:52,990
that I'm going to explain later on and

00:09:50,260 --> 00:09:56,470
the QM your monitor so these are some

00:09:52,990 --> 00:09:58,990
specific things that are like added by

00:09:56,470 --> 00:10:03,730
the VMM that allows you to somehow look

00:09:58,990 --> 00:10:06,970
into your vm m related to an outbound

00:10:03,730 --> 00:10:10,720
debugging which is like only provided by

00:10:06,970 --> 00:10:13,690
the vm we have on the right side as far

00:10:10,720 --> 00:10:16,390
as I know no solution for logging which

00:10:13,690 --> 00:10:19,540
might not be that critical but we don't

00:10:16,390 --> 00:10:22,300
have any solution for tracing it might

00:10:19,540 --> 00:10:24,100
be done we are some crazy gdb scripts

00:10:22,300 --> 00:10:28,030
that I'm going to explain it on but

00:10:24,100 --> 00:10:31,510
thats that's not really helpful we have

00:10:28,030 --> 00:10:33,880
of course damping mechanism in ko mu

00:10:31,510 --> 00:10:37,350
which can be used to simply dump your

00:10:33,880 --> 00:10:40,390
guests dump your guests memory and yeah

00:10:37,350 --> 00:10:43,270
we have a profiling mechanism that can

00:10:40,390 --> 00:10:44,950
be used from the hypervisor to profile

00:10:43,270 --> 00:10:46,660
both your host and your guests

00:10:44,950 --> 00:10:50,680
simultaneously I'm going to explain that

00:10:46,660 --> 00:10:52,600
one and one of the next slides yeah and

00:10:50,680 --> 00:10:54,010
which is pretty cool is that we have an

00:10:52,600 --> 00:10:56,260
interactive debugger that's what I

00:10:54,010 --> 00:10:59,440
previously told so we can directly

00:10:56,260 --> 00:11:01,990
attached gdb to a guest and like single

00:10:59,440 --> 00:11:03,370
stab it like insert breakpoint stuff

00:11:01,990 --> 00:11:07,700
like

00:11:03,370 --> 00:11:11,000
of course in order to debug emu and kvm

00:11:07,700 --> 00:11:13,460
we can use make use of all of these in

00:11:11,000 --> 00:11:15,530
both debugging techniques so that should

00:11:13,460 --> 00:11:21,950
be quite common that we can for example

00:11:15,530 --> 00:11:24,380
use perf to debug kvm so what's actually

00:11:21,950 --> 00:11:27,440
the problem of these inbound techniques

00:11:24,380 --> 00:11:29,960
um so if you think about the operating

00:11:27,440 --> 00:11:34,190
system it is something like the heart

00:11:29,960 --> 00:11:36,020
and the soul of your whole system and I

00:11:34,190 --> 00:11:39,770
mean if your operating system mesquite

00:11:36,020 --> 00:11:42,050
is buggy and you have to fix it if you

00:11:39,770 --> 00:11:45,350
some something like an open heart

00:11:42,050 --> 00:11:48,260
surgery but thinking of it about it even

00:11:45,350 --> 00:11:49,970
further it's even worth because I mean

00:11:48,260 --> 00:11:51,820
you're running the debugging tools and

00:11:49,970 --> 00:11:55,100
techniques inside your operating system

00:11:51,820 --> 00:11:59,300
so I mean you can be really lucky if you

00:11:55,100 --> 00:12:02,030
like you survive this situation so what

00:11:59,300 --> 00:12:05,600
else is a problematic about is involved

00:12:02,030 --> 00:12:08,180
debugging techniques of course you need

00:12:05,600 --> 00:12:11,600
a somewhat minimal functional system to

00:12:08,180 --> 00:12:14,720
make use of keys for example to have

00:12:11,600 --> 00:12:17,390
caden mechanism working you need k dump

00:12:14,720 --> 00:12:21,640
in place so early boot code will not be

00:12:17,390 --> 00:12:21,640
able to be debugged by that mechanism

00:12:22,000 --> 00:12:28,460
related to linux we have some pretty

00:12:24,320 --> 00:12:31,640
good to support related to debugging but

00:12:28,460 --> 00:12:33,950
on other systems that might be not that

00:12:31,640 --> 00:12:39,440
good so the quality it really depends on

00:12:33,950 --> 00:12:42,110
the guest OS in general when we are have

00:12:39,440 --> 00:12:44,120
our operating system up and running we

00:12:42,110 --> 00:12:46,340
most of the time can't access all the

00:12:44,120 --> 00:12:48,380
information that we want for example is

00:12:46,340 --> 00:12:51,710
really hard to debug interrupt handlers

00:12:48,380 --> 00:12:54,350
or for example to debug early boot code

00:12:51,710 --> 00:12:56,540
that's almost impossible in addition

00:12:54,350 --> 00:13:00,470
it's also most of the time not possible

00:12:56,540 --> 00:13:04,540
not that I know of to debug bootloaders

00:13:00,470 --> 00:13:07,550
or for example the buyers yeah a

00:13:04,540 --> 00:13:10,130
different thing is that I mean if you

00:13:07,550 --> 00:13:12,230
run a debugging tool on your guest this

00:13:10,130 --> 00:13:14,579
is absolutely not transparent to the

00:13:12,230 --> 00:13:17,699
guest that means

00:13:14,579 --> 00:13:19,980
you guess might behave differently if

00:13:17,699 --> 00:13:22,079
you run these tools for example if you

00:13:19,980 --> 00:13:24,619
think about some crazy debugging

00:13:22,079 --> 00:13:27,660
situations you had where abouts simply

00:13:24,619 --> 00:13:30,329
never appeared again once you started up

00:13:27,660 --> 00:13:34,439
your tracing infrastructure that would

00:13:30,329 --> 00:13:36,749
be one kind of these things of course

00:13:34,439 --> 00:13:38,699
one of the most critical ones if you

00:13:36,749 --> 00:13:40,829
have a system out in production is if

00:13:38,699 --> 00:13:43,319
you don't enable most of these

00:13:40,829 --> 00:13:46,529
techniques in the guest then they are

00:13:43,319 --> 00:13:48,299
not available so if lightning strikes in

00:13:46,529 --> 00:13:50,819
your system for example crashes you

00:13:48,299 --> 00:13:54,720
don't have kadem configured or you're

00:13:50,819 --> 00:13:56,489
left with is like a hanging guess that's

00:13:54,720 --> 00:14:02,369
it you can't do anything about it you

00:13:56,489 --> 00:14:05,569
can't like look into it so I previously

00:14:02,369 --> 00:14:09,029
mentioned a perf kvm which is actually a

00:14:05,569 --> 00:14:12,869
mechanism to profile the guests from the

00:14:09,029 --> 00:14:16,649
hypervisor so I'm what it does basically

00:14:12,869 --> 00:14:19,499
is it on your hypervisor it like samples

00:14:16,649 --> 00:14:22,679
to be the CPU it takes snapshots of the

00:14:19,499 --> 00:14:25,919
CPU it then decide if it currently was

00:14:22,679 --> 00:14:28,110
in virtualization mode if it was in

00:14:25,919 --> 00:14:32,879
virtualization mode you can like have a

00:14:28,110 --> 00:14:35,519
look at the guest cpu vcpu and like

00:14:32,879 --> 00:14:38,129
extract extract information from that

00:14:35,519 --> 00:14:40,799
and like position it into the system

00:14:38,129 --> 00:14:43,769
into the perf system into the buffer if

00:14:40,799 --> 00:14:46,290
not it can just like directly take that

00:14:43,769 --> 00:14:49,619
sample and push it into the perf

00:14:46,290 --> 00:14:51,989
infrastructure what you can then do you

00:14:49,619 --> 00:14:55,980
can like see how a workload in the

00:14:51,989 --> 00:14:58,709
guests into X with the hypervisor so

00:14:55,980 --> 00:15:02,220
what's the overhead of your action in

00:14:58,709 --> 00:15:04,199
the in the in hypervisor so on the left

00:15:02,220 --> 00:15:06,419
side I have a short example where like

00:15:04,199 --> 00:15:10,379
just did some random stuff and you can

00:15:06,419 --> 00:15:13,799
actually even profile interrupt handlers

00:15:10,379 --> 00:15:17,129
for example and you can even like

00:15:13,799 --> 00:15:20,129
annotate stuff in your guest code so

00:15:17,129 --> 00:15:23,689
that's actually pretty nice I think and

00:15:20,129 --> 00:15:23,689
it helped in a lot of situations

00:15:24,970 --> 00:15:31,120
another interesting technique is

00:15:27,449 --> 00:15:34,000
interactive debugging of guests so we

00:15:31,120 --> 00:15:37,269
have a chibi server built into Q mu and

00:15:34,000 --> 00:15:40,060
the chibi server is able to control

00:15:37,269 --> 00:15:45,160
guest execution and to for example read

00:15:40,060 --> 00:15:47,920
and write memory that in turn that you

00:15:45,160 --> 00:15:51,250
DB server allows for remote gdb to

00:15:47,920 --> 00:15:53,889
attach and to like control it so this

00:15:51,250 --> 00:15:56,769
gdb service just like a minimal set of

00:15:53,889 --> 00:15:58,689
operations needed and the remote gdb

00:15:56,769 --> 00:16:02,470
like controls the whole debugging

00:15:58,689 --> 00:16:05,019
process so with this mechanism it is for

00:16:02,470 --> 00:16:07,110
example possible that you have a colonel

00:16:05,019 --> 00:16:10,000
in the guests without debugging symbols

00:16:07,110 --> 00:16:12,100
but you provide the remote gdb the

00:16:10,000 --> 00:16:15,629
symbols and then you're suddenly able to

00:16:12,100 --> 00:16:19,269
like single steps through a source code

00:16:15,629 --> 00:16:21,879
if you want to make use of this Hardware

00:16:19,269 --> 00:16:23,829
debugging future so to say with kvm your

00:16:21,879 --> 00:16:27,189
architecture has to support it right now

00:16:23,829 --> 00:16:30,939
we have support for a thing x86 of

00:16:27,189 --> 00:16:33,699
course with PowerPC we have a 3 3 90 x

00:16:30,939 --> 00:16:38,430
and as polar mentioned today I think we

00:16:33,699 --> 00:16:42,250
also have soon arm support may be

00:16:38,430 --> 00:16:44,949
alright um so what yen's mentioned in

00:16:42,250 --> 00:16:46,899
his talk today is that if you have a

00:16:44,949 --> 00:16:50,620
really big guest and you're not able to

00:16:46,899 --> 00:16:52,959
dump it how would you like look into it

00:16:50,620 --> 00:16:55,329
and what you can do with this approach

00:16:52,959 --> 00:16:57,550
is simply attach to chi to be to the

00:16:55,329 --> 00:17:00,370
system look into it without having to

00:16:57,550 --> 00:17:03,089
dub any memory to the your file system

00:17:00,370 --> 00:17:06,100
which is actually pretty nice i

00:17:03,089 --> 00:17:08,169
previously mentioned that we might do

00:17:06,100 --> 00:17:11,530
some strange kind of tracing and a

00:17:08,169 --> 00:17:18,030
remote gdb side but that's usually too

00:17:11,530 --> 00:17:18,030
slow and not really what we want yeah

00:17:19,049 --> 00:17:26,519
so um this is just a list of like my

00:17:23,129 --> 00:17:28,499
opinion so if you ever come over come

00:17:26,519 --> 00:17:31,799
over one of these problems for example

00:17:28,499 --> 00:17:35,070
dead logs in your guest you might look

00:17:31,799 --> 00:17:38,249
into these techniques if there might be

00:17:35,070 --> 00:17:41,070
a solution for you so if they might like

00:17:38,249 --> 00:17:44,999
provide you to debug it any any faster

00:17:41,070 --> 00:17:47,940
and yeah just try this out I'm not going

00:17:44,999 --> 00:17:50,610
to go of all of these as I said guest

00:17:47,940 --> 00:17:53,489
raising is not yet available but as I'll

00:17:50,610 --> 00:17:56,129
like mention it in several of these

00:17:53,489 --> 00:17:58,440
points I think it would be a really

00:17:56,129 --> 00:18:06,570
important to have to some summer one

00:17:58,440 --> 00:18:08,820
somewhat in the future so thinking about

00:18:06,570 --> 00:18:12,539
this whole emulation and simulation in

00:18:08,820 --> 00:18:14,970
CMU we might come up with some advanced

00:18:12,539 --> 00:18:18,600
use cases so why we would want to debug

00:18:14,970 --> 00:18:21,779
against for example if you get a back

00:18:18,600 --> 00:18:25,200
report and you want to like replay that

00:18:21,779 --> 00:18:27,989
back it might help if you can like

00:18:25,200 --> 00:18:31,440
simulate the exact same hardware that

00:18:27,989 --> 00:18:34,230
the back report was filed for because

00:18:31,440 --> 00:18:36,419
obviously a vm should behave just like

00:18:34,230 --> 00:18:39,090
the real system just like the real

00:18:36,419 --> 00:18:41,519
hardware so that might help that you

00:18:39,090 --> 00:18:43,529
like um just stimulate a hardware debug

00:18:41,519 --> 00:18:45,509
your guests and you're fine so that

00:18:43,529 --> 00:18:48,450
might help we are not quite there yet

00:18:45,509 --> 00:18:52,679
but like we could get there in the

00:18:48,450 --> 00:18:54,869
future another thing is that you can for

00:18:52,679 --> 00:18:56,759
example or that you could debug

00:18:54,869 --> 00:18:59,580
scenarios that can barely seen in real

00:18:56,759 --> 00:19:03,529
life for example and I BMC systems we

00:18:59,580 --> 00:19:07,739
have in general the ability to to have

00:19:03,529 --> 00:19:10,440
broken CPUs that can be like replaced on

00:19:07,739 --> 00:19:14,730
the fly and we could simulate for

00:19:10,440 --> 00:19:16,739
example such broken CPUs and see how the

00:19:14,730 --> 00:19:18,869
system or the guest system reacts and

00:19:16,739 --> 00:19:22,049
then we would even be able to debug that

00:19:18,869 --> 00:19:25,919
code that handles broken CPUs so that

00:19:22,049 --> 00:19:28,470
would be another use case of course we

00:19:25,919 --> 00:19:31,499
could also like use this interactive

00:19:28,470 --> 00:19:32,610
debugging for example to simulate box so

00:19:31,499 --> 00:19:35,070
we could attend

00:19:32,610 --> 00:19:37,350
two guests for example change to return

00:19:35,070 --> 00:19:39,809
values of some functions that we called

00:19:37,350 --> 00:19:42,600
and see how the whole system would

00:19:39,809 --> 00:19:45,570
recover for example if a driver function

00:19:42,600 --> 00:19:48,210
would return some error value we could

00:19:45,570 --> 00:19:50,940
see okay does the whole system crash or

00:19:48,210 --> 00:19:54,620
do we get a nice print out analog fire

00:19:50,940 --> 00:19:57,809
that anything is broken for example

00:19:54,620 --> 00:20:02,760
another thing that might already been

00:19:57,809 --> 00:20:05,640
used in real life is that you use qmu

00:20:02,760 --> 00:20:09,150
for new hardware bring up by simulating

00:20:05,640 --> 00:20:10,980
some parts of the system and I mean if

00:20:09,150 --> 00:20:14,820
you have the simulation in place you can

00:20:10,980 --> 00:20:16,860
directly start to debug to the target

00:20:14,820 --> 00:20:19,710
software that is gonna going to run on

00:20:16,860 --> 00:20:21,809
the hardware by this mechanism that I

00:20:19,710 --> 00:20:24,270
presented from the outside point of view

00:20:21,809 --> 00:20:26,250
because like a new software a new

00:20:24,270 --> 00:20:27,960
operating system in the guest you must

00:20:26,250 --> 00:20:30,150
probably won't have all the debugging

00:20:27,960 --> 00:20:38,040
tools available right from the start of

00:20:30,150 --> 00:20:43,650
course so um I took two real-life

00:20:38,040 --> 00:20:46,710
examples that we had at I at IBM one of

00:20:43,650 --> 00:20:49,980
these was related to early boot code so

00:20:46,710 --> 00:20:51,720
um one day we upgraded our Colonel we

00:20:49,980 --> 00:20:55,049
weren't able to start a corner anymore

00:20:51,720 --> 00:20:57,090
under KTM so it still worked on real

00:20:55,049 --> 00:21:00,690
hardware but it stopped working on the

00:20:57,090 --> 00:21:03,030
kvm so what we did is we simply attached

00:21:00,690 --> 00:21:06,750
a remote debugger to that she'd be

00:21:03,030 --> 00:21:10,230
serving GM you started a guest and

00:21:06,750 --> 00:21:12,780
simply sing except two guests right from

00:21:10,230 --> 00:21:16,260
the start and then we were directly

00:21:12,780 --> 00:21:20,280
pointed at the wrong code so we could

00:21:16,260 --> 00:21:24,540
see we're like broke and we were even

00:21:20,280 --> 00:21:27,299
able to temporarily modify the code to

00:21:24,540 --> 00:21:32,370
see if this was actually like broken at

00:21:27,299 --> 00:21:36,030
that point we could like break position

00:21:32,370 --> 00:21:39,120
brake lines we could like have a look at

00:21:36,030 --> 00:21:41,370
memory at all the registers and that

00:21:39,120 --> 00:21:45,590
really helped to like debug that problem

00:21:41,370 --> 00:21:45,590
in less than half of half an hour

00:21:47,770 --> 00:21:55,640
so in the end it turned out that we had

00:21:50,570 --> 00:22:00,410
a problem in our guests that we checked

00:21:55,640 --> 00:22:04,330
for some wrong CPU features so on on IBM

00:22:00,410 --> 00:22:07,790
Sea Systems a CPU has some features and

00:22:04,330 --> 00:22:09,680
Linux checks for them so that they are

00:22:07,790 --> 00:22:12,740
available so that we can be sure that

00:22:09,680 --> 00:22:15,950
our code can be run so we had a bug in

00:22:12,740 --> 00:22:18,970
there and the strange thing was that

00:22:15,950 --> 00:22:23,630
like normal hardware provided these

00:22:18,970 --> 00:22:26,060
features but KDM did not so we were

00:22:23,630 --> 00:22:29,570
directly able to like have a look which

00:22:26,060 --> 00:22:33,400
ones were the wrong um finder patched it

00:22:29,570 --> 00:22:41,060
like introduced the back and I mean the

00:22:33,400 --> 00:22:46,310
fix was quite easy another problem we

00:22:41,060 --> 00:22:48,590
have when we upgraded our kernel in the

00:22:46,310 --> 00:22:53,650
guest was that we suddenly saw

00:22:48,590 --> 00:22:57,280
performance regression so um at one time

00:22:53,650 --> 00:23:00,880
suddenly we had very long good times

00:22:57,280 --> 00:23:04,340
module loading was extremely slow and

00:23:00,880 --> 00:23:07,700
that all mainly happened when we had a

00:23:04,340 --> 00:23:14,150
lot of cpu / commitment so loads of V

00:23:07,700 --> 00:23:16,220
CPUs what we use 10 was a vm m debugging

00:23:14,150 --> 00:23:22,490
technique that i mentioned previously so

00:23:16,220 --> 00:23:25,870
perf KD instead which basically analyzes

00:23:22,490 --> 00:23:29,180
the vm exits that we have so it like

00:23:25,870 --> 00:23:33,890
like monitors or the vm exits that we

00:23:29,180 --> 00:23:36,350
have calculate some statistics and what

00:23:33,890 --> 00:23:39,170
we did then we compared to the result of

00:23:36,350 --> 00:23:41,840
the kernel that was working with the

00:23:39,170 --> 00:23:45,020
results of the kernel that was somewhat

00:23:41,840 --> 00:23:48,080
broken and we were able to see that like

00:23:45,020 --> 00:23:51,620
we had a different number differing

00:23:48,080 --> 00:23:54,980
number in the diet for phone calls it

00:23:51,620 --> 00:23:57,920
die for for intercept so you have to

00:23:54,980 --> 00:23:59,299
know that Diack 44 is a hyper call on I

00:23:57,920 --> 00:24:02,419
BMC systems

00:23:59,299 --> 00:24:04,879
basically means that vcpu is willing to

00:24:02,419 --> 00:24:08,360
give up his time slice to another vcpu

00:24:04,879 --> 00:24:11,570
so dead Mamet rustic drastically changed

00:24:08,360 --> 00:24:17,899
and that gave us a hint what actually

00:24:11,570 --> 00:24:22,249
was wrong so we found the responsible

00:24:17,899 --> 00:24:25,460
commit and like fixed it and it turned

00:24:22,249 --> 00:24:29,029
out that it like removed those dr for

00:24:25,460 --> 00:24:32,779
phone calls from cpu relax and sip your

00:24:29,029 --> 00:24:36,559
legs is called often when you like wait

00:24:32,779 --> 00:24:38,749
for for spin lock and especially in stop

00:24:36,559 --> 00:24:41,269
machine all of these tubules wait for

00:24:38,749 --> 00:24:44,509
all out of we see you we cpus to enter

00:24:41,269 --> 00:24:46,039
the critical section and of course if we

00:24:44,509 --> 00:24:48,320
see pues are willing to give up their

00:24:46,039 --> 00:24:50,600
time slice type of wise you can schedule

00:24:48,320 --> 00:24:53,299
them much faster and therefore this

00:24:50,600 --> 00:24:56,259
whole mechanism is faster and that's why

00:24:53,299 --> 00:24:59,690
we saw those dis performance degradation

00:24:56,259 --> 00:25:09,529
mainly on food up and for example doing

00:24:59,690 --> 00:25:12,169
what you loading so outlook as a

00:25:09,529 --> 00:25:15,470
previously mentioned guest racing is not

00:25:12,169 --> 00:25:20,419
available yet so there's a way to allow

00:25:15,470 --> 00:25:24,230
the remote gdb to to set trace points

00:25:20,419 --> 00:25:27,139
and the guest and the chi DB server

00:25:24,230 --> 00:25:30,440
basically has to support it so we had

00:25:27,139 --> 00:25:31,820
like i think two attempts at a google

00:25:30,440 --> 00:25:35,389
summer of code to get a soul

00:25:31,820 --> 00:25:37,700
infrastructure in gem um implemented but

00:25:35,389 --> 00:25:40,309
until now i'm not aware that there is

00:25:37,700 --> 00:25:41,989
any implementation so that would be like

00:25:40,309 --> 00:25:47,059
the first step to get this whole thing

00:25:41,989 --> 00:25:49,399
implemented i think that foreign target

00:25:47,059 --> 00:25:52,070
architecture to support this tracing at

00:25:49,399 --> 00:25:54,499
least singer stepping and break points

00:25:52,070 --> 00:25:59,539
are required to like basically support

00:25:54,499 --> 00:26:01,789
tracing of guests what we couldn't could

00:25:59,539 --> 00:26:06,259
do then once we have this infrastructure

00:26:01,789 --> 00:26:08,299
is that we could implement further

00:26:06,259 --> 00:26:12,530
hardware support for example an IBM see

00:26:08,299 --> 00:26:15,320
systems we have some fancy tracing

00:26:12,530 --> 00:26:17,570
it is inbuilt into our hardware and if

00:26:15,320 --> 00:26:24,980
you could make use of them we could like

00:26:17,570 --> 00:26:29,570
even like speed at home tracing up so I

00:26:24,980 --> 00:26:32,810
think most of you should be should know

00:26:29,570 --> 00:26:36,290
the crash tool I guess the crest will

00:26:32,810 --> 00:26:38,840
allows you to analyze guest stumps or

00:26:36,290 --> 00:26:41,450
like ordinary operating system dumps and

00:26:38,840 --> 00:26:43,120
it has actually quite nice feature so

00:26:41,450 --> 00:26:46,460
you can for example list or your

00:26:43,120 --> 00:26:49,580
processes you can list all loaded

00:26:46,460 --> 00:26:51,590
modules and what would be pretty cool

00:26:49,580 --> 00:26:55,340
would be to have something like a life

00:26:51,590 --> 00:26:58,100
crash tool that you can use to attach to

00:26:55,340 --> 00:27:00,140
jamies building g DB server so we you

00:26:58,100 --> 00:27:03,830
would be able to have a look at the

00:27:00,140 --> 00:27:07,040
system from an outside view and for

00:27:03,830 --> 00:27:12,050
example list the processes or some other

00:27:07,040 --> 00:27:14,210
fancy stuff if that is not feasible we

00:27:12,050 --> 00:27:18,380
could think about like moving all this

00:27:14,210 --> 00:27:21,560
functionality that crashed will has into

00:27:18,380 --> 00:27:24,500
some say magic gdb scripts and

00:27:21,560 --> 00:27:26,210
maintaining them at a central point in

00:27:24,500 --> 00:27:29,480
this case we could also like make use of

00:27:26,210 --> 00:27:33,440
all these cool features which would be

00:27:29,480 --> 00:27:35,960
really nice I guess of course what we

00:27:33,440 --> 00:27:41,210
want to see is more architecture support

00:27:35,960 --> 00:27:43,490
for all this outbound debugging and once

00:27:41,210 --> 00:27:45,800
we have architecture support we want to

00:27:43,490 --> 00:27:48,440
exploit even more happy facilities for

00:27:45,800 --> 00:27:50,840
example an ID MC systems we have various

00:27:48,440 --> 00:27:53,090
facilities features we can make use of

00:27:50,840 --> 00:27:57,200
also related to interactive debugging

00:27:53,090 --> 00:27:59,750
that are not used right now at the

00:27:57,200 --> 00:28:03,250
breweries previously set on Hardware

00:27:59,750 --> 00:28:05,900
debugging is not supported by armed yet

00:28:03,250 --> 00:28:11,750
but that would also be like the next

00:28:05,900 --> 00:28:13,910
step to do would be cool that we would

00:28:11,750 --> 00:28:16,220
one day be able to simulate more other

00:28:13,910 --> 00:28:19,490
varieties for example IBM Sea Systems

00:28:16,220 --> 00:28:22,040
the next thing to do would be to support

00:28:19,490 --> 00:28:26,010
CPU models because we could then like

00:28:22,040 --> 00:28:28,800
take that back report example

00:28:26,010 --> 00:28:32,040
simulate a specific CPU how that behave

00:28:28,800 --> 00:28:34,530
so that like what effect it has on the

00:28:32,040 --> 00:28:38,000
operating system running on it and we

00:28:34,530 --> 00:28:40,820
could then like more easily fixed bugs

00:28:38,000 --> 00:28:44,190
another thing we could think about is to

00:28:40,820 --> 00:28:47,160
expose we are the gdb serving GMU some

00:28:44,190 --> 00:28:52,500
fake wreck juices that could allow us to

00:28:47,160 --> 00:28:54,690
look into the GMU process to find out

00:28:52,500 --> 00:28:57,930
some or to get some further information

00:28:54,690 --> 00:29:00,780
on one of these would be a last break

00:28:57,930 --> 00:29:03,180
for example so we could get out of Q mu

00:29:00,780 --> 00:29:05,730
what was the last point where you did a

00:29:03,180 --> 00:29:07,320
break on IBM see systems and they could

00:29:05,730 --> 00:29:10,530
for example help us later on when we

00:29:07,320 --> 00:29:12,960
want to do tracing to find out ok at

00:29:10,530 --> 00:29:16,200
that trace point the last point I did a

00:29:12,960 --> 00:29:23,000
branch was on that instruction so that

00:29:16,200 --> 00:29:25,940
might be pretty helpful alright so that

00:29:23,000 --> 00:29:30,510
would now be the tips and tricks section

00:29:25,940 --> 00:29:35,280
I'm not sure how much time we have or if

00:29:30,510 --> 00:29:37,560
we oh wow or like do you guys have any

00:29:35,280 --> 00:29:43,250
questions so far did I met be able to

00:29:37,560 --> 00:29:46,350
answer so we could do that up front no

00:29:43,250 --> 00:29:50,250
all right so I'll just go over the tips

00:29:46,350 --> 00:29:52,710
and tricks section so to start this

00:29:50,250 --> 00:29:54,870
building 2 mu g DB server we have

00:29:52,710 --> 00:29:57,810
different ways so we can start it

00:29:54,870 --> 00:30:00,180
directly using the command line we can

00:29:57,810 --> 00:30:02,850
start it directly and tell the guests

00:30:00,180 --> 00:30:07,290
not to stop before we tell it to do so

00:30:02,850 --> 00:30:09,360
via the remote gdb and in addition which

00:30:07,290 --> 00:30:12,750
is pretty cool we can start a chill

00:30:09,360 --> 00:30:15,330
peace over into mu lazily using the GMU

00:30:12,750 --> 00:30:17,340
monitor that basically means if you have

00:30:15,330 --> 00:30:19,620
such a situation that your guests

00:30:17,340 --> 00:30:21,870
suddenly crashed and you have no kdump

00:30:19,620 --> 00:30:24,210
in place you didn't enable the chair

00:30:21,870 --> 00:30:27,480
medici DB server you can just like

00:30:24,210 --> 00:30:29,610
lazily enable that g DB server attached

00:30:27,480 --> 00:30:31,380
to remote gdb and you can have a look at

00:30:29,610 --> 00:30:35,850
your guests and that's it you can like

00:30:31,380 --> 00:30:39,720
debug it another cool thing that i found

00:30:35,850 --> 00:30:44,789
is that you can actually use gdb money

00:30:39,720 --> 00:30:49,559
to command to run qmu monitor commands

00:30:44,789 --> 00:30:52,140
from your remote gdb session this is

00:30:49,559 --> 00:30:55,169
actually pretty cool because if you have

00:30:52,140 --> 00:30:58,610
labert running I think you usually can't

00:30:55,169 --> 00:31:03,090
add another qmu monitor if i'm correct

00:30:58,610 --> 00:31:05,070
polar tell me if i'm wrong yeah or

00:31:03,090 --> 00:31:07,650
anybody else tell me if I'm wrong so

00:31:05,070 --> 00:31:10,919
what you can do then is like simply

00:31:07,650 --> 00:31:13,740
start at g DB server attach your remote

00:31:10,919 --> 00:31:16,530
chibi to the gdb server and like heck

00:31:13,740 --> 00:31:22,500
into qmu monitor commands without any

00:31:16,530 --> 00:31:26,429
liberal involved if you want to debug

00:31:22,500 --> 00:31:27,990
any binaries or let's say operating

00:31:26,429 --> 00:31:31,740
systems in the guests that you don't

00:31:27,990 --> 00:31:36,419
have any debugging symbols for what you

00:31:31,740 --> 00:31:40,039
can do is simply force gdb to use the

00:31:36,419 --> 00:31:44,250
specific architecture and then like

00:31:40,039 --> 00:31:46,610
debug on an assembly level so we did

00:31:44,250 --> 00:31:49,460
that once and it worked out quite well

00:31:46,610 --> 00:31:53,309
yeah if you can use make use of that

00:31:49,460 --> 00:31:55,500
might be pretty helpful another thing

00:31:53,309 --> 00:31:59,580
that a colleague of mine shared is that

00:31:55,500 --> 00:32:02,010
the Python binding of gdb are in general

00:31:59,580 --> 00:32:05,870
really powerful so what you can for

00:32:02,010 --> 00:32:09,260
example do is on launch to GD bees and

00:32:05,870 --> 00:32:14,460
connect them via socket for example and

00:32:09,260 --> 00:32:16,289
then like place breakpoints in both for

00:32:14,460 --> 00:32:18,720
example GM use that you are willing to

00:32:16,289 --> 00:32:21,090
debug and you can then verify for

00:32:18,720 --> 00:32:23,010
example on a break point level if for

00:32:21,090 --> 00:32:27,390
example some information you get out of

00:32:23,010 --> 00:32:29,850
your EMU is like the same and that might

00:32:27,390 --> 00:32:32,429
be some helpful really helpful for some

00:32:29,850 --> 00:32:35,820
verification or automatic testing that

00:32:32,429 --> 00:32:39,000
you might want to do if you ever want to

00:32:35,820 --> 00:32:43,200
debug loadable kernel modules in your

00:32:39,000 --> 00:32:47,720
guests um there's some way to tell the

00:32:43,200 --> 00:32:51,110
remote gdb about these symbols just

00:32:47,720 --> 00:32:54,830
scripts called get sims thought as

00:32:51,110 --> 00:32:57,170
age from Kate gdv I used that once it

00:32:54,830 --> 00:33:00,350
worked out quite well but I heard that

00:32:57,170 --> 00:33:03,260
there might be some conflicts with at

00:33:00,350 --> 00:33:05,809
rest faces when loading kernel modules

00:33:03,260 --> 00:33:09,760
so I'm not sure if this will always work

00:33:05,809 --> 00:33:15,920
but it worked for me I told you about

00:33:09,760 --> 00:33:20,030
these this plan to get some life crash

00:33:15,920 --> 00:33:23,600
tool or some like scripts for example to

00:33:20,030 --> 00:33:28,820
list or processes of the guests just

00:33:23,600 --> 00:33:30,770
actually in the linux kernel fire the

00:33:28,820 --> 00:33:33,620
contains and macros that already

00:33:30,770 --> 00:33:35,600
provides such functionality so it's

00:33:33,620 --> 00:33:40,190
located under the documentation kadem

00:33:35,600 --> 00:33:43,160
gdb macros you can ride it out I tried

00:33:40,190 --> 00:33:48,470
one of them and it worked so maybe all

00:33:43,160 --> 00:33:52,010
of them work I'm not sure all right so

00:33:48,470 --> 00:33:55,580
this is another real-life use case at

00:33:52,010 --> 00:33:59,360
some advanced magic but it somehow shows

00:33:55,580 --> 00:34:02,660
which pole we have with gdb so what we

00:33:59,360 --> 00:34:06,260
have on on IBMC systems is that we have

00:34:02,660 --> 00:34:08,990
on KMEL so-called PC BIOS which is

00:34:06,260 --> 00:34:15,070
responsible for loading the colonel and

00:34:08,990 --> 00:34:17,419
the initial ram disk from disk and this

00:34:15,070 --> 00:34:20,450
initial boot device let's call it that

00:34:17,419 --> 00:34:24,649
way is specified on the command line we

00:34:20,450 --> 00:34:27,950
are good index once we put it at kernel

00:34:24,649 --> 00:34:32,200
of course we now have to colonel in our

00:34:27,950 --> 00:34:36,050
main memory and if we do a reboot so

00:34:32,200 --> 00:34:38,629
so-called three IPL we end up at a pc

00:34:36,050 --> 00:34:41,480
bias again because on reboard qemu

00:34:38,629 --> 00:34:45,619
simply reloads the buyers into memory

00:34:41,480 --> 00:34:49,159
and then you are able to like a boot

00:34:45,619 --> 00:34:53,000
from another disk so what you can do in

00:34:49,159 --> 00:34:56,210
your guest is to trigger some como

00:34:53,000 --> 00:34:58,160
command called change we at the El that

00:34:56,210 --> 00:35:00,740
allows you to switch your boot device

00:34:58,160 --> 00:35:02,660
while you're in the colonel so we

00:35:00,740 --> 00:35:03,800
implemented that feature recently if

00:35:02,660 --> 00:35:07,160
okay the M

00:35:03,800 --> 00:35:11,060
and what we wanted to do is to give back

00:35:07,160 --> 00:35:14,030
the transition from your PC BIOS to your

00:35:11,060 --> 00:35:17,540
guests and back so um you would like

00:35:14,030 --> 00:35:20,870
want to see in your TD be the PC BIOS

00:35:17,540 --> 00:35:23,570
code you would then like sing a step it

00:35:20,870 --> 00:35:25,330
to for example the last instruction

00:35:23,570 --> 00:35:27,800
where you do the transition to the guest

00:35:25,330 --> 00:35:29,930
you would do the transition to the guest

00:35:27,800 --> 00:35:32,300
and you would directly stop at the first

00:35:29,930 --> 00:35:35,180
instruction of your guest Colonel in the

00:35:32,300 --> 00:35:38,300
early boot section um we were then able

00:35:35,180 --> 00:35:40,580
to like reboot and do the exact same

00:35:38,300 --> 00:35:44,330
thing so we would like stop at the first

00:35:40,580 --> 00:35:46,580
instruction of our PC buyers and one has

00:35:44,330 --> 00:35:49,400
to know that both binaries are

00:35:46,580 --> 00:35:51,350
overwritten so qmo reloads for example

00:35:49,400 --> 00:35:53,270
the pc buyers and a pc buyers who loads

00:35:51,350 --> 00:35:57,020
to Colonel so that's the tricky stuff

00:35:53,270 --> 00:35:59,960
about that but we were able to to get

00:35:57,020 --> 00:36:03,260
this running so these are the steps that

00:35:59,960 --> 00:36:05,450
you have to do so um first of all you

00:36:03,260 --> 00:36:11,210
have to compile the piece of ice on your

00:36:05,450 --> 00:36:14,750
own once you have that you simply like

00:36:11,210 --> 00:36:18,760
to start creamy with it you tell your

00:36:14,750 --> 00:36:22,750
Chiddy be about your guest Colonel and

00:36:18,760 --> 00:36:25,490
once you have that you can say okay

00:36:22,750 --> 00:36:27,320
she'd be you know about the symbols of

00:36:25,490 --> 00:36:29,870
my kernel and I'm going to tell you

00:36:27,320 --> 00:36:31,760
about my PC BIOS and about that source

00:36:29,870 --> 00:36:35,570
code and that's what you actually do

00:36:31,760 --> 00:36:38,360
with the @ symbol file command and once

00:36:35,570 --> 00:36:40,400
you have that um you can like do what I

00:36:38,360 --> 00:36:42,950
just described you can place break

00:36:40,400 --> 00:36:45,140
points in your buyers you can play spray

00:36:42,950 --> 00:36:47,450
points in your guest Colonel then you

00:36:45,140 --> 00:36:50,720
can just get back to transitions into

00:36:47,450 --> 00:36:54,110
exactly same GDP session which is pretty

00:36:50,720 --> 00:36:57,800
cool so have some screenshots so this is

00:36:54,110 --> 00:36:59,720
for example on like code in the pc bias

00:36:57,800 --> 00:37:03,830
just before the transition we have to

00:36:59,720 --> 00:37:07,130
IPL call which then like um gives

00:37:03,830 --> 00:37:09,800
control to the guest Colonel and if you

00:37:07,130 --> 00:37:12,050
press Continue and you probably place to

00:37:09,800 --> 00:37:14,750
break the breakpoint in your guest

00:37:12,050 --> 00:37:16,430
corner you are at the first instruction

00:37:14,750 --> 00:37:19,490
of your guest Colonel

00:37:16,430 --> 00:37:22,370
and once you do a reboot again you you

00:37:19,490 --> 00:37:25,370
end up in India boils and that helped a

00:37:22,370 --> 00:37:28,730
lot to implement this item on the KTM

00:37:25,370 --> 00:37:35,570
and to debug several scenarios we were

00:37:28,730 --> 00:37:38,180
facing yeah that's it thank you do you

00:37:35,570 --> 00:37:43,790
guys have any questions that I might be

00:37:38,180 --> 00:37:47,800
able to answer no perfect so thank you

00:37:43,790 --> 00:37:47,800

YouTube URL: https://www.youtube.com/watch?v=G8tPLLIgJ4c


