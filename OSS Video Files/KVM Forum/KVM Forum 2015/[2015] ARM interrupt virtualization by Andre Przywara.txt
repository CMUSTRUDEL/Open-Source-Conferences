Title: [2015] ARM interrupt virtualization by Andre Przywara
Publication date: 2015-09-10
Playlist: KVM Forum 2015
Description: 
	With the introduction of the ARM virtualization extension the ARM Generic Interrupt Controller provided also hardware support to help a hypervisor with interrupt virtualization. The talk will briefly describe these capabilities and the original design of the KVM code required to support it. With the advancement of the hardware capabilities however extending the code proved to be challenging, so the talk will then give an overview of the design changes proposed to help current and future extensions, which is an ongoing effort.

Andre Przywara
ARM
Andre Przywara works in the ARM Linux kernel team in Cambridge/UK, primarily on KVM, but also on other parts of the kernel. Recent work included extending the virtualization support for the ARM interrupt controller.
Before joining ARM Andre spent a year in an early-bird ARM server company, while being assigned to the Linaro group.
He gained much experience and knowledge in Linux, KVM, QEMU and Xen while working for AMD in the six years before, mainly, but not exclusively contributing to x86 hardware virtualization code in those projects.

Slides: https://drive.google.com/open?id=0BzyAwvVlQckeRmtnVHlwQWR1dG8
Captions: 
	00:00:16,070 --> 00:00:21,930
my name is Aisha Walla

00:00:18,180 --> 00:00:25,740
I'm Bassam in sunny city of Cambridge

00:00:21,930 --> 00:00:29,519
and I worked in accounting mostly on KBM

00:00:25,740 --> 00:00:32,610
stuff and I'm here today to give you an

00:00:29,519 --> 00:00:36,380
idea of what interrupt virtualization

00:00:32,610 --> 00:00:36,380
how it works and what's it about

00:00:36,980 --> 00:00:43,100
so I am what we're going to do today is

00:00:39,989 --> 00:00:46,200
I give you a quick overview of what the

00:00:43,100 --> 00:00:49,050
current prevalent interrupt controller

00:00:46,200 --> 00:00:51,000
that you have and current I'm chips the

00:00:49,050 --> 00:00:53,550
geek me to is and what it does for

00:00:51,000 --> 00:00:57,210
virtualization and what does it mean for

00:00:53,550 --> 00:00:59,039
KVM so we what we what challenges

00:00:57,210 --> 00:01:02,370
basically we've faced and implementing

00:00:59,039 --> 00:01:05,040
it and then give you an update on what

00:01:02,370 --> 00:01:08,790
geek me three adds to the game and how

00:01:05,040 --> 00:01:13,140
how that resulted in changes in in their

00:01:08,790 --> 00:01:16,680
KBM code and concluding with some kind

00:01:13,140 --> 00:01:19,080
of overview where we came from where we

00:01:16,680 --> 00:01:24,750
currently are and what we are going to

00:01:19,080 --> 00:01:29,939
do so that's from 30,000 feet what a

00:01:24,750 --> 00:01:32,689
geek me too looks like so you have like

00:01:29,939 --> 00:01:35,430
here this green thing is the distributor

00:01:32,689 --> 00:01:38,040
as you can see it tests on a top it has

00:01:35,430 --> 00:01:42,659
many many interrupt lines which are the

00:01:38,040 --> 00:01:47,310
input the architecture supports 988 of

00:01:42,659 --> 00:01:51,079
those so plus 32 plus 4 equals then 10

00:01:47,310 --> 00:01:53,820
bits that was connect to each device

00:01:51,079 --> 00:01:58,770
which wants to send an interrupt to this

00:01:53,820 --> 00:02:01,590
system that sounds quite a lot and at 88

00:01:58,770 --> 00:02:04,530
wires but remember this is an arm sock

00:02:01,590 --> 00:02:06,719
so it's all on one die so it is why is

00:02:04,530 --> 00:02:11,069
actually cheap there because it's on die

00:02:06,719 --> 00:02:13,190
routing middle layers whatever only left

00:02:11,069 --> 00:02:16,220
inside you see

00:02:13,190 --> 00:02:19,130
connections to each core so that's a

00:02:16,220 --> 00:02:21,800
it's an input to the distributor namely

00:02:19,130 --> 00:02:25,130
the private interrupts that each Corgan

00:02:21,800 --> 00:02:27,320
generators namely from the perc or timer

00:02:25,130 --> 00:02:29,420
and also from the performance monitoring

00:02:27,320 --> 00:02:32,380
units which wants to send interrupts

00:02:29,420 --> 00:02:34,670
they need to be accounted for and

00:02:32,380 --> 00:02:37,670
eventually an interrupt has to be

00:02:34,670 --> 00:02:41,120
triggered to a CPU so that also happens

00:02:37,670 --> 00:02:43,250
first CPU but it is too bitter

00:02:41,120 --> 00:02:45,320
it's the interrupt line on the on the

00:02:43,250 --> 00:02:50,210
core so their Co actually takes it into

00:02:45,320 --> 00:02:53,500
it that's the interrupt side of it on

00:02:50,210 --> 00:02:58,550
the bus site which you see on the right

00:02:53,500 --> 00:03:02,060
of the green box there's a bus interface

00:02:58,550 --> 00:03:04,490
so where the control management

00:03:02,060 --> 00:03:09,200
registers of the distributor memory

00:03:04,490 --> 00:03:11,960
mapped and can be accessed by by

00:03:09,200 --> 00:03:15,440
software there's something special about

00:03:11,960 --> 00:03:18,160
it so um SEC first this distributor

00:03:15,440 --> 00:03:22,070
which has registers and then there's

00:03:18,160 --> 00:03:24,290
down there CPU interfaces so there's one

00:03:22,070 --> 00:03:26,870
CPU interface per core that you actually

00:03:24,290 --> 00:03:30,170
implement the interesting thing is that

00:03:26,870 --> 00:03:34,160
the CPU interfaces are all met at the

00:03:30,170 --> 00:03:38,180
same memory-mapped address but they are

00:03:34,160 --> 00:03:40,940
banked per speaker that's that you can

00:03:38,180 --> 00:03:42,800
do because the X I bus transports the

00:03:40,940 --> 00:03:47,510
information from which Corder request

00:03:42,800 --> 00:03:51,260
came and so the logic decoding logic can

00:03:47,510 --> 00:03:53,989
then separate out and access that is

00:03:51,260 --> 00:03:56,510
also true for a certain set of registers

00:03:53,989 --> 00:03:59,450
inside the distributor namely those

00:03:56,510 --> 00:04:01,670
registers that care about procore so

00:03:59,450 --> 00:04:03,680
that each core basically kind of

00:04:01,670 --> 00:04:06,860
automatically only accesses its own

00:04:03,680 --> 00:04:09,170
registers if you do per core interrupt

00:04:06,860 --> 00:04:11,090
management which also means that you

00:04:09,170 --> 00:04:14,950
cannot do it from one core for another

00:04:11,090 --> 00:04:14,950
core each cores are do it for itself

00:04:17,290 --> 00:04:25,070
yeah okay that's just what I said

00:04:23,270 --> 00:04:29,180
basically if you want to read it again

00:04:25,070 --> 00:04:30,920
later so what that's kind of

00:04:29,180 --> 00:04:35,210
virtualization support has it so if you

00:04:30,920 --> 00:04:36,590
if you look at spec it says it has

00:04:35,210 --> 00:04:40,160
virtualization support what we are

00:04:36,590 --> 00:04:42,830
talking about here so if I said CPU

00:04:40,160 --> 00:04:45,740
interface before that actually breaks

00:04:42,830 --> 00:04:48,620
down into three blocks inside the CPU

00:04:45,740 --> 00:04:51,350
interface the first one is to on a very

00:04:48,620 --> 00:04:53,470
write the gig C that's the normal CPU

00:04:51,350 --> 00:04:57,290
interface that you would expect weight

00:04:53,470 --> 00:05:00,310
software talks to and it tells software

00:04:57,290 --> 00:05:03,050
about the state of the interrupts and

00:05:00,310 --> 00:05:05,990
that talks directly to the distributor

00:05:03,050 --> 00:05:08,020
so every time you trigger an interrupt

00:05:05,990 --> 00:05:13,040
or didn't it right blindness asserted

00:05:08,020 --> 00:05:16,820
the buff that gig C actually responds to

00:05:13,040 --> 00:05:20,720
those then there's an gig V interface

00:05:16,820 --> 00:05:24,020
with virtual CPU interface which the

00:05:20,720 --> 00:05:26,720
registers sort of register semantics at

00:05:24,020 --> 00:05:29,600
the layout are exactly the same as the

00:05:26,720 --> 00:05:31,960
gig C only that they don't talk to the

00:05:29,600 --> 00:05:34,850
distributor directly but instead and

00:05:31,960 --> 00:05:37,880
take the information from what we call

00:05:34,850 --> 00:05:40,190
list registers so this the list register

00:05:37,880 --> 00:05:42,050
is basically an idea to to virtualize

00:05:40,190 --> 00:05:44,210
and interrupt so if you want is a

00:05:42,050 --> 00:05:46,280
hypervisor inject and interrupt your

00:05:44,210 --> 00:05:48,830
program list register base to interrupt

00:05:46,280 --> 00:05:52,760
number and to state pending active or

00:05:48,830 --> 00:05:55,550
both and then every time software

00:05:52,760 --> 00:05:56,720
actually access the CPU interface and

00:05:55,550 --> 00:05:58,960
gets the information from the list

00:05:56,720 --> 00:06:01,580
register on from the distributor and

00:05:58,960 --> 00:06:03,790
then there's the gig H which is the

00:06:01,580 --> 00:06:06,650
hypervisor interface which basically

00:06:03,790 --> 00:06:09,020
allows you to program the list registers

00:06:06,650 --> 00:06:15,170
and just another hypervisor related

00:06:09,020 --> 00:06:17,390
things yeah so there's also another

00:06:15,170 --> 00:06:19,370
feature which allows you to once you

00:06:17,390 --> 00:06:23,510
have set up a virtual interrupt to

00:06:19,370 --> 00:06:27,560
connect it to a physical interrupt so if

00:06:23,510 --> 00:06:30,900
the guest then um actually acknowledges

00:06:27,560 --> 00:06:32,759
and eventually you ice

00:06:30,900 --> 00:06:35,880
is interrupted and at the same time the

00:06:32,759 --> 00:06:38,160
physical interruptus cui it it's a

00:06:35,880 --> 00:06:41,310
feature that just lately got supported

00:06:38,160 --> 00:06:44,789
in software and that is for instance

00:06:41,310 --> 00:06:47,100
useful if they have something like a

00:06:44,789 --> 00:06:50,150
time interrupts which you take in the

00:06:47,100 --> 00:06:53,070
host and distributor you set it up you

00:06:50,150 --> 00:06:54,600
want to guess play with it and once the

00:06:53,070 --> 00:06:56,100
guest is done you don't care about it

00:06:54,600 --> 00:07:02,009
anymore and you also want to do such a

00:06:56,100 --> 00:07:04,289
timer interrupt on there on the host so

00:07:02,009 --> 00:07:07,229
you can link this okay how this is

00:07:04,289 --> 00:07:12,840
actually implemented allowed to be make

00:07:07,229 --> 00:07:15,630
use of this in KBM you see that on a on

00:07:12,840 --> 00:07:18,479
a picture on the right-hand side that a

00:07:15,630 --> 00:07:20,550
gig seed and the gig age it's something

00:07:18,479 --> 00:07:23,310
that we don't map to the guests at all

00:07:20,550 --> 00:07:26,010
so the guest does not see this from the

00:07:23,310 --> 00:07:28,620
but instead we met we directly map

00:07:26,010 --> 00:07:32,009
through the gig V interface so the

00:07:28,620 --> 00:07:34,470
physical address is mapped into the

00:07:32,009 --> 00:07:36,419
guests whenever the guests exercise it

00:07:34,470 --> 00:07:38,940
goes through directly to the hardware

00:07:36,419 --> 00:07:40,740
part but only to the gig v which looks

00:07:38,940 --> 00:07:42,389
exactly like the gig see and tell us

00:07:40,740 --> 00:07:45,349
what we tell the guests this is your gig

00:07:42,389 --> 00:07:47,460
seed and I guess things that it is and

00:07:45,349 --> 00:07:48,750
only that doesn't have talked to the

00:07:47,460 --> 00:07:50,430
distributor which would talk to the

00:07:48,750 --> 00:07:52,320
hardware part which we don't want the

00:07:50,430 --> 00:07:53,729
guests to do but instead to the list

00:07:52,320 --> 00:07:54,210
register where we have our virtual

00:07:53,729 --> 00:07:58,889
interwebs

00:07:54,210 --> 00:08:00,840
um the distributor itself is totally

00:07:58,889 --> 00:08:03,060
emulated because it's totally separate

00:08:00,840 --> 00:08:05,400
from the house that there's a total

00:08:03,060 --> 00:08:07,620
different set of devices and you don't

00:08:05,400 --> 00:08:10,289
want the guests to talk to deal with

00:08:07,620 --> 00:08:12,930
host interrupts so that's why it's

00:08:10,289 --> 00:08:16,590
totally emulated in every access so we

00:08:12,930 --> 00:08:21,330
trap this and handle it in a kernel in

00:08:16,590 --> 00:08:23,940
kernel emulation code so we used KVM in

00:08:21,330 --> 00:08:26,220
kernel I acute controller machinery so

00:08:23,940 --> 00:08:29,460
in kernel epoch is that on x86 that we

00:08:26,220 --> 00:08:32,820
have and we used something along those

00:08:29,460 --> 00:08:34,800
lines to have most of the code in there

00:08:32,820 --> 00:08:37,860
in the kernel so that we don't need to

00:08:34,800 --> 00:08:40,610
exist to there to use a lamp to deal

00:08:37,860 --> 00:08:40,610
with interrupts

00:08:43,480 --> 00:08:48,080
yeah

00:08:44,720 --> 00:08:50,300
so um the lifecycle goes like this so

00:08:48,080 --> 00:08:52,040
whenever there's and virtual AIA cube

00:08:50,300 --> 00:08:55,610
which is to be asserted but usually

00:08:52,040 --> 00:09:01,880
comes from qmo it sets the interrupt

00:08:55,610 --> 00:09:04,070
line then yeah we create we create

00:09:01,880 --> 00:09:06,260
appropriate list register entry so we

00:09:04,070 --> 00:09:08,360
say this is the interrupt number 35-foot

00:09:06,260 --> 00:09:11,120
it it just got asserted and the state is

00:09:08,360 --> 00:09:12,860
pending and then we go into the guest

00:09:11,120 --> 00:09:15,530
and I guess these oh there's an

00:09:12,860 --> 00:09:17,840
interrupt X this is the CPU interface

00:09:15,530 --> 00:09:20,210
for what things it's the soup interface

00:09:17,840 --> 00:09:23,570
it gets redirected to the virtual CPU

00:09:20,210 --> 00:09:25,670
interface it sees oh that's interrupts

00:09:23,570 --> 00:09:28,760
35 and it's pending so in didn't in

00:09:25,670 --> 00:09:31,960
moment it reads at 35 did hardware

00:09:28,760 --> 00:09:34,880
changes the state from pending to active

00:09:31,960 --> 00:09:37,010
yeah then the guest deals with interrupt

00:09:34,880 --> 00:09:40,070
and once it done it says I'm finished

00:09:37,010 --> 00:09:41,720
it's in San UI so says I'm finished and

00:09:40,070 --> 00:09:46,040
in this moment the state goes from

00:09:41,720 --> 00:09:47,960
active to nothing basically and the good

00:09:46,040 --> 00:09:49,730
thing is that all those things happen

00:09:47,960 --> 00:09:52,400
was out guest exit

00:09:49,730 --> 00:09:57,380
so we because it's done by hardware

00:09:52,400 --> 00:09:59,780
actually so whenever we we have to deal

00:09:57,380 --> 00:10:02,330
with the interrupts creation and

00:09:59,780 --> 00:10:08,440
injection still in a host but the rest

00:10:02,330 --> 00:10:12,200
happens without host intervention yeah

00:10:08,440 --> 00:10:14,840
so this whole code lives in Bert KVM arm

00:10:12,200 --> 00:10:17,330
the main reason to do it there was to

00:10:14,840 --> 00:10:18,680
share between arm and I'm 64 because

00:10:17,330 --> 00:10:20,690
this hardware has stuff so the gig is

00:10:18,680 --> 00:10:23,660
basically this is the very same between

00:10:20,690 --> 00:10:26,570
the two so there's no difference at the

00:10:23,660 --> 00:10:29,120
coitus minor differences of course is

00:10:26,570 --> 00:10:31,600
here between the two architectures but

00:10:29,120 --> 00:10:31,600
not so much

00:10:33,269 --> 00:10:40,220
all right so what challenges to be faced

00:10:36,449 --> 00:10:43,050
during the implementation of the geek v2

00:10:40,220 --> 00:10:46,980
as I said we have banked MMI away excess

00:10:43,050 --> 00:10:49,920
so some registers are separate depending

00:10:46,980 --> 00:10:51,360
on from which core you came from this is

00:10:49,920 --> 00:10:53,430
something that decay via my robust

00:10:51,360 --> 00:10:54,990
framework which would be the natural

00:10:53,430 --> 00:10:57,930
thing to use for those

00:10:54,990 --> 00:11:00,149
that's not did not support its I say at

00:10:57,930 --> 00:11:05,040
the time so we had invent our own stuff

00:11:00,149 --> 00:11:07,110
so first got separate thing because we

00:11:05,040 --> 00:11:11,059
needed to be CPU basically so tiny

00:11:07,110 --> 00:11:15,240
little thing but didn't support it also

00:11:11,059 --> 00:11:17,490
as this is on the whole mapping is very

00:11:15,240 --> 00:11:20,730
much platform specific so every platform

00:11:17,490 --> 00:11:22,050
there's no fixed value but no fixed

00:11:20,730 --> 00:11:26,839
address where the geek is usually mapped

00:11:22,050 --> 00:11:29,819
at so the user land to queue and this

00:11:26,839 --> 00:11:32,970
thing needs to set up the address so it

00:11:29,819 --> 00:11:34,889
it creates the internal I acute

00:11:32,970 --> 00:11:36,809
controller and then it needs to set up

00:11:34,889 --> 00:11:40,050
to address and it also need to set up

00:11:36,809 --> 00:11:43,559
how many interrupts it support and only

00:11:40,050 --> 00:11:46,319
after the setup is done it can be used

00:11:43,559 --> 00:11:49,230
and it doesn't sound too complicated but

00:11:46,319 --> 00:11:51,089
it has some funny effects because on x86

00:11:49,230 --> 00:11:54,329
you create and drop control and it's

00:11:51,089 --> 00:11:57,540
basically immediately usable and that's

00:11:54,329 --> 00:11:59,430
not the case where some yeah some some

00:11:57,540 --> 00:12:01,680
time frame in between where we are and

00:11:59,430 --> 00:12:04,110
kind of strange state and we have to

00:12:01,680 --> 00:12:06,660
make sure that everything works out fine

00:12:04,110 --> 00:12:11,930
and one one design decision that has

00:12:06,660 --> 00:12:14,129
been made back then was dead

00:12:11,930 --> 00:12:15,720
kotas and code layout was designed

00:12:14,129 --> 00:12:18,269
around I mean my oh and Ling so

00:12:15,720 --> 00:12:20,759
everything was streamlined to have need

00:12:18,269 --> 00:12:23,639
an efficient handling of mm IO excesses

00:12:20,759 --> 00:12:26,579
to the distributor and B basically also

00:12:23,639 --> 00:12:29,269
modeled what hardware does in terms of

00:12:26,579 --> 00:12:32,550
bitmaps on bite maps for everything

00:12:29,269 --> 00:12:34,920
which is nice and the code looks cool

00:12:32,550 --> 00:12:38,459
and it's very efficient but the problem

00:12:34,920 --> 00:12:40,589
is that on interrupt injection or sync

00:12:38,459 --> 00:12:43,170
back we have to iterate through all the

00:12:40,589 --> 00:12:44,790
bitmaps and pipe maps and see what so

00:12:43,170 --> 00:12:45,540
phases if you see if there's an ax drop

00:12:44,790 --> 00:12:47,550
pending

00:12:45,540 --> 00:12:49,110
we have to go through the old into a

00:12:47,550 --> 00:12:51,420
pending bitmap and find out if there

00:12:49,110 --> 00:12:53,220
which interrupt is it and then we have

00:12:51,420 --> 00:12:56,750
the number and then we create a list

00:12:53,220 --> 00:12:59,910
register out of it so it turns out that

00:12:56,750 --> 00:13:02,460
this whole mm IO and Ling is not so much

00:12:59,910 --> 00:13:05,400
performance sensitive if we thought

00:13:02,460 --> 00:13:07,860
because it's happened reservoir II that

00:13:05,400 --> 00:13:10,830
you actually have changed the interrupt

00:13:07,860 --> 00:13:13,670
controller so it would be much smaller

00:13:10,830 --> 00:13:18,030
to actually model the whole I think

00:13:13,670 --> 00:13:20,100
about um interrupts that are actually

00:13:18,030 --> 00:13:22,470
pending or something so we keep a list

00:13:20,100 --> 00:13:25,410
of interrupts something like the list

00:13:22,470 --> 00:13:25,950
registers and software again and then if

00:13:25,410 --> 00:13:29,580
you do

00:13:25,950 --> 00:13:31,950
mm IO handling you can you have yeah you

00:13:29,580 --> 00:13:34,170
could take the extra time to go through

00:13:31,950 --> 00:13:41,250
the list of registers and create a bit

00:13:34,170 --> 00:13:43,500
maps out of the fryer voice yeah um also

00:13:41,250 --> 00:13:44,760
handling of level and edge triggered

00:13:43,500 --> 00:13:46,800
interrupts that proved to be very

00:13:44,760 --> 00:13:48,240
error-prone and we had a lot of bugs in

00:13:46,800 --> 00:13:50,790
there and there's a lot of case

00:13:48,240 --> 00:13:53,850
distinction now so if if H then do this

00:13:50,790 --> 00:13:56,190
if a level then do this and it's kind of

00:13:53,850 --> 00:13:57,780
confusing to read and there I have to

00:13:56,190 --> 00:14:02,250
gut feeling that there should be a

00:13:57,780 --> 00:14:03,920
better way of handling this maybe not

00:14:02,250 --> 00:14:08,730
but I hope so at least

00:14:03,920 --> 00:14:10,380
and also the state saving the state for

00:14:08,730 --> 00:14:14,160
migration proves to be annoying because

00:14:10,380 --> 00:14:16,290
the state of the geek from Xavier site

00:14:14,160 --> 00:14:18,780
includes the distributor and a CPU

00:14:16,290 --> 00:14:20,460
interface but we don't so forth

00:14:18,780 --> 00:14:23,910
distributor it's fine because we have

00:14:20,460 --> 00:14:25,500
all revelation state in software but the

00:14:23,910 --> 00:14:27,060
CPU interfaces virtualized fused to

00:14:25,500 --> 00:14:29,730
virtualize the part of the hardware so

00:14:27,060 --> 00:14:31,230
and the guest the fusel end wants to

00:14:29,730 --> 00:14:35,520
know the state of the geek we have to

00:14:31,230 --> 00:14:40,080
kind of create a state of the CPU

00:14:35,520 --> 00:14:44,490
interface and make it up basically yeah

00:14:40,080 --> 00:14:46,590
it's annoying part okay if there is not

00:14:44,490 --> 00:14:50,940
also complicate it and let's go on to

00:14:46,590 --> 00:14:53,850
gig we three that's that's a nice

00:14:50,940 --> 00:14:55,380
picture of a gig mystery and in reality

00:14:53,850 --> 00:14:58,920
it's much more complicated it's really a

00:14:55,380 --> 00:15:01,660
beast the spec is more than 700 pages

00:14:58,920 --> 00:15:01,990
and so you see the distributors still

00:15:01,660 --> 00:15:04,929
there

00:15:01,990 --> 00:15:06,579
hooray it's the less iuck you lines and

00:15:04,929 --> 00:15:09,819
everything what's what

00:15:06,579 --> 00:15:10,449
guru various what was form on the

00:15:09,819 --> 00:15:13,059
left-hand side

00:15:10,449 --> 00:15:15,819
connection to each core because that got

00:15:13,059 --> 00:15:18,819
moved into a separate entity separate

00:15:15,819 --> 00:15:24,490
register set and which is now powered we

00:15:18,819 --> 00:15:26,790
distributor so every interrupt that is

00:15:24,490 --> 00:15:30,189
per core is now handled there and

00:15:26,790 --> 00:15:36,220
redistribute us and all now mapped on

00:15:30,189 --> 00:15:38,230
separate addresses so we have one so

00:15:36,220 --> 00:15:40,029
it's not it's not all the same same

00:15:38,230 --> 00:15:42,009
address since no longer banked so you

00:15:40,029 --> 00:15:44,589
can access each we're distributor the

00:15:42,009 --> 00:15:46,300
idea behind us that in a large-scale

00:15:44,589 --> 00:15:52,660
system which the gate with three is

00:15:46,300 --> 00:15:54,579
defined actually defined for um you yeah

00:15:52,660 --> 00:15:56,350
you cannot go away with you can't get

00:15:54,579 --> 00:15:58,089
away with Swiss banking because it

00:15:56,350 --> 00:16:00,100
doesn't work across multiple chips for

00:15:58,089 --> 00:16:01,990
instance and so yes but if you have

00:16:00,100 --> 00:16:03,490
proper I'm in my old addresses Bazaar

00:16:01,990 --> 00:16:08,110
which are unique across the whole system

00:16:03,490 --> 00:16:10,179
then this works harder in reality and

00:16:08,110 --> 00:16:12,279
most of the times the real sybilla's are

00:16:10,179 --> 00:16:15,429
just met behind hitch other so you still

00:16:12,279 --> 00:16:18,100
have one start offset and then each

00:16:15,429 --> 00:16:20,980
restore beta takes two pages and goes

00:16:18,100 --> 00:16:23,290
the next one if you look at the KVM DTS

00:16:20,980 --> 00:16:26,920
you see that we distribute arranged is

00:16:23,290 --> 00:16:28,899
pretty large because for each of the 48

00:16:26,920 --> 00:16:35,490
course they have two pages so it's quite

00:16:28,899 --> 00:16:39,009
a large region um yeah so that's the

00:16:35,490 --> 00:16:41,559
easy part of it funny part is there's a

00:16:39,009 --> 00:16:42,819
new completely new block which is called

00:16:41,559 --> 00:16:45,309
the ideas and proper translation

00:16:42,819 --> 00:16:48,549
translation service which basically

00:16:45,309 --> 00:16:51,389
deals with Emma's eyes and it does it in

00:16:48,549 --> 00:16:52,749
a very very fancy way it so it supports

00:16:51,389 --> 00:16:56,740
four billion

00:16:52,749 --> 00:16:59,589
Emma's ice basically interrupts and it

00:16:56,740 --> 00:17:02,079
can do it to two hundred fifty six

00:16:59,589 --> 00:17:04,929
million course so that's really and to

00:17:02,079 --> 00:17:08,079
support this kind of big things they

00:17:04,929 --> 00:17:10,630
introduced basically kind of the usual

00:17:08,079 --> 00:17:11,820
thing level of indirection so basically

00:17:10,630 --> 00:17:13,950
like page tables for intro

00:17:11,820 --> 00:17:15,990
so it's you have all kind of tables

00:17:13,950 --> 00:17:18,780
which map from something they called

00:17:15,990 --> 00:17:20,580
collection to CPUs and then you met from

00:17:18,780 --> 00:17:23,190
devices to interrupts and then your map

00:17:20,580 --> 00:17:26,190
from interrupts to the collection and

00:17:23,190 --> 00:17:28,830
everything and um as it wouldn't be

00:17:26,190 --> 00:17:32,460
enough all those stuff is done in memory

00:17:28,830 --> 00:17:35,880
and physical memory so there are tables

00:17:32,460 --> 00:17:38,550
and memory but also there's the memory

00:17:35,880 --> 00:17:40,140
format is private to the IDS so as a

00:17:38,550 --> 00:17:41,460
software you are not supposed to deal

00:17:40,140 --> 00:17:43,740
with it directly with the memory you

00:17:41,460 --> 00:17:47,580
just give you reserved the memory and

00:17:43,740 --> 00:17:50,940
gift ideas the memory and there's an

00:17:47,580 --> 00:17:53,640
ring buffer command interface which you

00:17:50,940 --> 00:17:55,980
actually use so you set up a comment and

00:17:53,640 --> 00:17:58,650
write it into ring buffer to set up

00:17:55,980 --> 00:18:01,860
those tables and then the IDS goes into

00:17:58,650 --> 00:18:04,530
a memory to actually set it up the data

00:18:01,860 --> 00:18:07,380
the idea behind us that if you have a

00:18:04,530 --> 00:18:10,260
large scale or system you don't want to

00:18:07,380 --> 00:18:14,250
have this all this data that you want to

00:18:10,260 --> 00:18:19,020
and need to save in in big memory you

00:18:14,250 --> 00:18:21,090
want to use system memory for this yeah

00:18:19,020 --> 00:18:22,980
also an important fact that the CPU

00:18:21,090 --> 00:18:27,270
interface that was there before has now

00:18:22,980 --> 00:18:29,220
moved directly into the poor and it's no

00:18:27,270 --> 00:18:32,130
longer mm i/o mapped but instead it's

00:18:29,220 --> 00:18:35,010
uses system register access which is an

00:18:32,130 --> 00:18:36,870
actual thing to have a perk or mmm

00:18:35,010 --> 00:18:38,730
access and it's also much more easier to

00:18:36,870 --> 00:18:42,450
implement for from another point of view

00:18:38,730 --> 00:18:44,820
and it's much quicker and you can yeah

00:18:42,450 --> 00:18:47,000
it have some advantages and you don't

00:18:44,820 --> 00:18:49,140
need to care about mapping anymore

00:18:47,000 --> 00:18:51,270
because the system adjusters

00:18:49,140 --> 00:18:53,550
architecture I defined the address so

00:18:51,270 --> 00:19:00,060
it's always the same it simplifies some

00:18:53,550 --> 00:19:04,320
things yeah again what I just told so

00:19:00,060 --> 00:19:07,460
what does it mean for for KVM so there's

00:19:04,320 --> 00:19:10,470
some gig which the architecture supports

00:19:07,460 --> 00:19:13,800
compatibility for geek v2 but it's

00:19:10,470 --> 00:19:16,850
optional so we cannot rely on it an

00:19:13,800 --> 00:19:20,970
effect our SOC switch do not implement

00:19:16,850 --> 00:19:21,930
compatibility so we have no Bank mm IO

00:19:20,970 --> 00:19:24,780
access anymore

00:19:21,930 --> 00:19:25,740
hooray but it doesn't help us because of

00:19:24,780 --> 00:19:27,780
course we have to support

00:19:25,740 --> 00:19:30,270
give me two in the same codebase so we

00:19:27,780 --> 00:19:32,160
have to now have the problem that we

00:19:30,270 --> 00:19:33,690
have today was Baus so was banked and

00:19:32,160 --> 00:19:39,330
unbanked I mean my oh and they have to

00:19:33,690 --> 00:19:41,130
kind of make it break it the distributor

00:19:39,330 --> 00:19:44,000
and redistribute are split so the

00:19:41,130 --> 00:19:47,490
private and Watson are now redistributed

00:19:44,000 --> 00:19:49,860
system ones and a distributor the

00:19:47,490 --> 00:19:51,510
registers there are a similar but not

00:19:49,860 --> 00:19:54,660
identical also you need some code

00:19:51,510 --> 00:19:57,030
refactoring and stuff it is kind of ok

00:19:54,660 --> 00:19:58,530
but it introduces more than one I'm in

00:19:57,030 --> 00:20:00,330
my own region so formally we had just

00:19:58,530 --> 00:20:02,850
had to do submitter so it was one base

00:20:00,330 --> 00:20:06,900
address and offset just told you to

00:20:02,850 --> 00:20:09,420
register name so now we have more than

00:20:06,900 --> 00:20:12,900
one em in my origin and as we don't use

00:20:09,420 --> 00:20:16,820
KVM i/o bus or we didn't use that was

00:20:12,900 --> 00:20:16,820
more bit challenge to implement them

00:20:17,030 --> 00:20:23,070
yeah

00:20:18,300 --> 00:20:24,929
also the LP is which are the msi the

00:20:23,070 --> 00:20:27,210
name for MSI's that we actually have

00:20:24,929 --> 00:20:30,420
today they have some numbers and there

00:20:27,210 --> 00:20:32,730
can be really large numbers and they can

00:20:30,420 --> 00:20:34,860
also be sparsely allocated so bitmaps is

00:20:32,730 --> 00:20:38,160
no longer a valid data structure to used

00:20:34,860 --> 00:20:39,900
here so for the time being we holding

00:20:38,160 --> 00:20:42,900
them in separate data structures we have

00:20:39,900 --> 00:20:46,800
their anyway and just have two bits in

00:20:42,900 --> 00:20:49,950
there but again it's separate from what

00:20:46,800 --> 00:20:51,510
we have currently for gave me two and

00:20:49,950 --> 00:20:53,520
also as I said I guess they'd have

00:20:51,510 --> 00:20:55,740
structures a hole in physical memory

00:20:53,520 --> 00:20:58,170
which means in our case of immolated and

00:20:55,740 --> 00:21:00,150
guest physical memory so from the host

00:20:58,170 --> 00:21:02,160
code B now from the KVM kernel code we

00:21:00,150 --> 00:21:04,860
have to reach into the guest kernel

00:21:02,160 --> 00:21:07,980
memory fortunately we do not have to do

00:21:04,860 --> 00:21:09,720
this very often because we are allowed

00:21:07,980 --> 00:21:12,780
to catch the architecture allow us to

00:21:09,720 --> 00:21:15,960
cache the information that is held in

00:21:12,780 --> 00:21:19,370
memory and that's what we do that's what

00:21:15,960 --> 00:21:21,900
we utilize much but we waste precious

00:21:19,370 --> 00:21:25,770
guest memory because the guest has to

00:21:21,900 --> 00:21:27,270
allocate those pages and give them to

00:21:25,770 --> 00:21:29,940
the host basically but the host doesn't

00:21:27,270 --> 00:21:31,559
so currently we don't use them so just

00:21:29,940 --> 00:21:33,900
because we have false memory which is

00:21:31,559 --> 00:21:36,210
cheap addresses and from time to time

00:21:33,900 --> 00:21:38,630
you have to do is sync this KVM read

00:21:36,210 --> 00:21:38,630
guest page

00:21:39,570 --> 00:21:48,870
yes so KBM Janus challenges in general

00:21:44,110 --> 00:21:51,990
that we encountered with the V geek

00:21:48,870 --> 00:21:55,060
usual first sentence

00:21:51,990 --> 00:21:58,240
KVM was designed for x86 so we came

00:21:55,060 --> 00:22:01,810
around some limitations so jesus i iack

00:21:58,240 --> 00:22:05,080
you routing which is also acc determines

00:22:01,810 --> 00:22:07,210
and it's an epic x36 term so it's not a

00:22:05,080 --> 00:22:09,040
real treat for us we don't need it

00:22:07,210 --> 00:22:13,450
because we don't need to map numbers

00:22:09,040 --> 00:22:16,450
around but we have to do it for IQ if

00:22:13,450 --> 00:22:21,070
FPS which required so we ended up with

00:22:16,450 --> 00:22:23,560
some identity or simply by offset

00:22:21,070 --> 00:22:26,980
mapping which is ok but it's kind of

00:22:23,560 --> 00:22:28,900
pointless for us to do the LPI for the

00:22:26,980 --> 00:22:31,780
LPI numbers which would be useful to

00:22:28,900 --> 00:22:33,250
after some routing but we do not expose

00:22:31,780 --> 00:22:35,650
them at this level so we do not need

00:22:33,250 --> 00:22:41,590
them the api numbers are never used by

00:22:35,650 --> 00:22:45,490
anyone except the ids internally yeah

00:22:41,590 --> 00:22:47,950
also am ids ms eyes i identified by a

00:22:45,490 --> 00:22:49,690
triple not a pair of information so

00:22:47,950 --> 00:22:51,760
usually we have a doorbell which is an

00:22:49,690 --> 00:22:53,050
address and you have to pay load which

00:22:51,760 --> 00:22:58,840
is the data that you write under that

00:22:53,050 --> 00:23:01,900
address on IDs it's a device ID because

00:22:58,840 --> 00:23:04,660
it is again property of this Amba's that

00:23:01,900 --> 00:23:08,470
you can see where from which device the

00:23:04,660 --> 00:23:11,560
actual what right came from which

00:23:08,470 --> 00:23:13,840
provides really proper isolation so the

00:23:11,560 --> 00:23:17,260
device can no longer trigger kind of

00:23:13,840 --> 00:23:19,480
kind of spurious interrupts because IITs

00:23:17,260 --> 00:23:21,340
knows which device it come which ends up

00:23:19,480 --> 00:23:22,840
that the payload is usually just 0 if

00:23:21,340 --> 00:23:25,000
you have one interrupt per device and

00:23:22,840 --> 00:23:26,770
the actual information is the doorbell

00:23:25,000 --> 00:23:29,350
which is one per system usually or one

00:23:26,770 --> 00:23:32,560
per IDs which means once per system most

00:23:29,350 --> 00:23:34,150
of the times and the device are these

00:23:32,560 --> 00:23:38,440
textual information which is assembled

00:23:34,150 --> 00:23:40,780
from the bus but to go with this we have

00:23:38,440 --> 00:23:43,840
to introduce a device Ardrey device ID

00:23:40,780 --> 00:23:47,020
into all the structures kvms and deals

00:23:43,840 --> 00:23:48,490
basically base MSI's which is something

00:23:47,020 --> 00:23:50,160
we discussed on a list for a while how

00:23:48,490 --> 00:23:53,550
do you do it the best way around

00:23:50,160 --> 00:23:58,470
we have reached conclusion now how to do

00:23:53,550 --> 00:24:00,210
this the best yeah and the payload

00:23:58,470 --> 00:24:02,580
usually on xt6 I think the payload is

00:24:00,210 --> 00:24:05,670
the global interrupts number it's not a

00:24:02,580 --> 00:24:08,330
case that just zero most of the times we

00:24:05,670 --> 00:24:08,330
cannot use this

00:24:09,110 --> 00:24:16,770
okay the we geek evolution so in the

00:24:14,190 --> 00:24:18,840
beginning when there was the first arm

00:24:16,770 --> 00:24:21,000
virtualization support for the V geek

00:24:18,840 --> 00:24:27,780
we had one hardware that was a geek me

00:24:21,000 --> 00:24:29,070
too we could emulate one one geek model

00:24:27,780 --> 00:24:31,380
to the software which possibly gave me

00:24:29,070 --> 00:24:34,800
two so we had one two one basically

00:24:31,380 --> 00:24:37,440
support there was a limit of eight CPUs

00:24:34,800 --> 00:24:41,160
that we easily copied by doing

00:24:37,440 --> 00:24:43,560
everything in bitmaps so it's quite okay

00:24:41,160 --> 00:24:47,180
to one byte per interrupt which gives

00:24:43,560 --> 00:24:50,310
you the CPU number fine and also they'll

00:24:47,180 --> 00:24:51,930
be at only Wyatt and interrupts and the

00:24:50,310 --> 00:24:54,000
number of them was known from the

00:24:51,930 --> 00:24:57,110
beginning was fixed well you could set

00:24:54,000 --> 00:25:00,540
it up and it was contiguous so bitmaps

00:24:57,110 --> 00:25:04,020
it's fine and easy to do

00:25:00,540 --> 00:25:05,730
if you now think about decrease me how

00:25:04,020 --> 00:25:08,070
did everything changes so we have

00:25:05,730 --> 00:25:10,650
multiple hardware devices so we can have

00:25:08,070 --> 00:25:13,860
the geek me too and it gave me sweet and

00:25:10,650 --> 00:25:16,650
I guess in the host so that the code has

00:25:13,860 --> 00:25:18,090
to of course support those so that now

00:25:16,650 --> 00:25:21,030
means the word switch caused that to

00:25:18,090 --> 00:25:22,410
take check now this is the geek me sweet

00:25:21,030 --> 00:25:23,490
and I have to do something different

00:25:22,410 --> 00:25:25,380
because they're registered AI was

00:25:23,490 --> 00:25:28,920
different or they give me two so we

00:25:25,380 --> 00:25:30,990
ended up now with some runtime code

00:25:28,920 --> 00:25:32,370
pitching so at the moment Colonel boots

00:25:30,990 --> 00:25:36,770
up it seizes the geek mystery and

00:25:32,370 --> 00:25:36,770
patches out every geek we to go past now

00:25:36,890 --> 00:25:43,290
yeah also we have not H CPUs but two to

00:25:40,920 --> 00:25:46,500
the power of 32 CPUs oh I think 28

00:25:43,290 --> 00:25:49,140
actually but anyway it's still too much

00:25:46,500 --> 00:25:51,960
for using any kind of bitmaps and stuff

00:25:49,140 --> 00:25:53,570
and we have not only wired IQs but also

00:25:51,960 --> 00:25:56,010
am his eyes and they are no longer

00:25:53,570 --> 00:25:58,680
contiguous and the number can be very

00:25:56,010 --> 00:26:01,850
large so bitmaps are not a bit so it

00:25:58,680 --> 00:26:05,870
looks like the whole regional design

00:26:01,850 --> 00:26:09,600
does not fit very well so that's kind of

00:26:05,870 --> 00:26:11,520
stuff that we did on a way actually to

00:26:09,600 --> 00:26:16,650
get support for geek wispy so the first

00:26:11,520 --> 00:26:18,690
thing was made it easier to for explicit

00:26:16,650 --> 00:26:20,010
we gig set up as I said you have to set

00:26:18,690 --> 00:26:23,490
up the addresses and a number of things

00:26:20,010 --> 00:26:25,680
and we edit and explicit I'm done with

00:26:23,490 --> 00:26:28,290
setting up this kick you can use it now

00:26:25,680 --> 00:26:30,870
which is simplified because before it

00:26:28,290 --> 00:26:33,900
was some kind of guessing or some kind

00:26:30,870 --> 00:26:36,900
of automatic okay you use it so I assume

00:26:33,900 --> 00:26:38,940
you have set it up properly so which

00:26:36,900 --> 00:26:43,050
which had some funny issues with

00:26:38,940 --> 00:26:46,230
migration and stuff so this was the

00:26:43,050 --> 00:26:50,340
cistern and upstream we also extended to

00:26:46,230 --> 00:26:52,860
kV mio bus to take the V CPU to to

00:26:50,340 --> 00:26:55,980
actually pass on the V CPU which request

00:26:52,860 --> 00:26:59,880
came from so we could then move over to

00:26:55,980 --> 00:27:02,760
mmm IO handless to the KB mio bus

00:26:59,880 --> 00:27:07,320
framework and could use that which makes

00:27:02,760 --> 00:27:08,970
it easier to add and other mio region so

00:27:07,320 --> 00:27:11,160
not only distributor but was it real

00:27:08,970 --> 00:27:14,190
stupider in IDs and everything so it

00:27:11,160 --> 00:27:17,640
fits more naturally in there is done an

00:27:14,190 --> 00:27:20,520
upstream we also support what a big geek

00:27:17,640 --> 00:27:22,380
our models at what I said so we can it

00:27:20,520 --> 00:27:24,350
is the same the same kernel support geek

00:27:22,380 --> 00:27:26,220
p3 and geek v2 on a hardware and

00:27:24,350 --> 00:27:29,220
depending on what's actually on the

00:27:26,220 --> 00:27:33,120
system when you boot your kernel that's

00:27:29,220 --> 00:27:35,100
the proper thing we also supported

00:27:33,120 --> 00:27:38,880
multiple emulation models so before it

00:27:35,100 --> 00:27:41,100
was just a KBM create a cute chip I

00:27:38,880 --> 00:27:43,170
think so one one iocked or without any

00:27:41,100 --> 00:27:44,760
parameters which created the I acute

00:27:43,170 --> 00:27:46,880
chip but now you have the choice between

00:27:44,760 --> 00:27:49,680
gave me to give you three and everything

00:27:46,880 --> 00:27:52,740
so there's this k vm create device i up

00:27:49,680 --> 00:27:54,420
to a new one which was used for it's

00:27:52,740 --> 00:27:56,850
useful other architectures as well and

00:27:54,420 --> 00:28:00,390
we piggybacked on this and can now

00:27:56,850 --> 00:28:03,120
properly so allow user learn to set up

00:28:00,390 --> 00:28:07,170
to request which cpu which cake Mauro

00:28:03,120 --> 00:28:09,300
you want to have any guest also all kind

00:28:07,170 --> 00:28:13,140
of cake with three non idea simulation

00:28:09,300 --> 00:28:14,700
it's done an upstream so that works in

00:28:13,140 --> 00:28:17,310
the rare case you have some geek piece

00:28:14,700 --> 00:28:20,010
to be hardware available so currently I

00:28:17,310 --> 00:28:22,680
don't have actually honestly and I do

00:28:20,010 --> 00:28:25,410
everything on the motor which does it

00:28:22,680 --> 00:28:26,210
pretty well I hope it matches hardware

00:28:25,410 --> 00:28:30,120
mm-hm

00:28:26,210 --> 00:28:31,590
okay also do you still eyes the

00:28:30,120 --> 00:28:33,570
connection as I mentioned we're

00:28:31,590 --> 00:28:36,800
beginning between physical and virtual I

00:28:33,570 --> 00:28:39,390
accused so that if you your eye

00:28:36,800 --> 00:28:42,510
mmm Anaya cue which is linked to a

00:28:39,390 --> 00:28:46,560
physical I acute and this gets you I it

00:28:42,510 --> 00:28:48,990
at the same time this has now reached

00:28:46,560 --> 00:28:51,960
conclusion on the list I think and marks

00:28:48,990 --> 00:28:55,320
that he will merge it into next at this

00:28:51,960 --> 00:28:58,380
home page is basically cake with three

00:28:55,320 --> 00:29:02,490
IDs simulation this whole table

00:28:58,380 --> 00:29:06,090
craziness and a Miss ice there's just

00:29:02,490 --> 00:29:08,040
patched by me and the two is on a list

00:29:06,090 --> 00:29:09,540
and under review currently and I think

00:29:08,040 --> 00:29:13,470
it needs some more discussion and some

00:29:09,540 --> 00:29:16,830
more love but we and we ran into some

00:29:13,470 --> 00:29:20,040
funny locking issues so we as I said you

00:29:16,830 --> 00:29:22,110
have to do KVM read cast page which you

00:29:20,040 --> 00:29:25,010
cannot do in a spin lock because it

00:29:22,110 --> 00:29:27,390
could be not mapped and everything so it

00:29:25,010 --> 00:29:29,520
may take an indefinite amount of time

00:29:27,390 --> 00:29:31,620
and you do not want to go to spin look

00:29:29,520 --> 00:29:33,660
at this whole time so there was some

00:29:31,620 --> 00:29:40,500
some looking craziness which I hopefully

00:29:33,660 --> 00:29:45,420
soft yeah then as I said before the

00:29:40,500 --> 00:29:48,570
whole architecture mmm was to was

00:29:45,420 --> 00:29:50,340
designed about mio accesses this may be

00:29:48,570 --> 00:29:52,080
redesigned so they're plans to do this

00:29:50,340 --> 00:29:55,740
but that means that we have to rewrite

00:29:52,080 --> 00:29:58,230
most of the he gate code and it's it's

00:29:55,740 --> 00:30:01,010
it's something that still animals cuz

00:29:58,230 --> 00:30:03,300
inverter but I would be useful to do so

00:30:01,010 --> 00:30:07,200
because it means that you swore waited

00:30:03,300 --> 00:30:13,590
current code which may not be very well

00:30:07,200 --> 00:30:17,100
but yeah it's there and it works yeah

00:30:13,590 --> 00:30:19,830
and we may at the same time like get

00:30:17,100 --> 00:30:23,400
some some learnings about what would we

00:30:19,830 --> 00:30:25,050
currently have and improved the code

00:30:23,400 --> 00:30:25,580
layout to be better scalable for

00:30:25,050 --> 00:30:29,299
instance

00:30:25,580 --> 00:30:31,999
and also equus reason or the end s kick

00:30:29,299 --> 00:30:35,119
before the speckies and basically it's

00:30:31,999 --> 00:30:37,509
the that's the key before specs - it's

00:30:35,119 --> 00:30:40,429
the same as the geekiest respect so this

00:30:37,509 --> 00:30:44,690
this extra PDF covers both versions and

00:30:40,429 --> 00:30:47,299
get before allows you to have virtual LP

00:30:44,690 --> 00:30:50,659
is which can be directly injected into a

00:30:47,299 --> 00:30:52,369
guest so you can have hardware and go

00:30:50,659 --> 00:30:57,470
directly into the guest without the host

00:30:52,369 --> 00:31:00,460
and intervention but it requires to help

00:30:57,470 --> 00:31:05,330
you to tell the 2gig basically which is

00:31:00,460 --> 00:31:06,980
which V CPU or which CPU disappears

00:31:05,330 --> 00:31:08,539
currently running on and all these kind

00:31:06,980 --> 00:31:11,899
of tables and I have to be updated and

00:31:08,539 --> 00:31:14,659
everything and it also goes into the

00:31:11,899 --> 00:31:22,700
core k vm i accused subsystem so it

00:31:14,659 --> 00:31:31,009
sounds like Frank okay yeah that's so

00:31:22,700 --> 00:31:33,230
far am i right any questions the

00:31:31,009 --> 00:31:35,840
doorbell is basically addressed that

00:31:33,230 --> 00:31:39,710
device rights to to trigger an interrupt

00:31:35,840 --> 00:31:41,480
instead of using an extra wire it's an

00:31:39,710 --> 00:31:43,580
it's an address the device knows and it

00:31:41,480 --> 00:31:46,159
does use your bus cycle to write

00:31:43,580 --> 00:31:48,350
something into it and it will not end

00:31:46,159 --> 00:31:52,489
into some register but instead trigger

00:31:48,350 --> 00:31:54,769
an interrupt so that's that's that MSI

00:31:52,489 --> 00:31:57,190
adds the implementation of TMS is

00:31:54,769 --> 00:31:57,190
basically

00:32:02,150 --> 00:32:08,070
yeah we faced exactly the same problem

00:32:05,430 --> 00:32:15,650
on because the data structures used for

00:32:08,070 --> 00:32:15,650
their browsing the Stars yeah very large

00:32:15,770 --> 00:32:21,540
so absolutely affected the current so

00:32:18,300 --> 00:32:34,860
that translation world still exists you

00:32:21,540 --> 00:32:36,750
can plug in functions to do it okay I

00:32:34,860 --> 00:32:40,860
just saw the comments from you guys that

00:32:36,750 --> 00:32:44,850
you said via 4096 but we can have more

00:32:40,860 --> 00:32:48,570
something there was some yeah I just

00:32:44,850 --> 00:32:54,600
read the comments when i when i okay so

00:32:48,570 --> 00:32:56,010
we kind of copy to comment okay yeah

00:32:54,600 --> 00:33:03,120
that's that's interesting I will take a

00:32:56,010 --> 00:33:06,530
look at it Thanks any more questions if

00:33:03,120 --> 00:33:06,530

YouTube URL: https://www.youtube.com/watch?v=BGGbgufgP_Y


