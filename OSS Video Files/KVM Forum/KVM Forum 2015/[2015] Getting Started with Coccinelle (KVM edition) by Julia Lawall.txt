Title: [2015] Getting Started with Coccinelle (KVM edition) by Julia Lawall
Publication date: 2015-09-04
Playlist: KVM Forum 2015
Description: 
	Getting Started with Coccinelle (KVM edition)

Coccinelle is a program matching and transformation tool for C programs that has been extensively applied to the Linux kernel and is used on a number of other C code bases. Coccinelle makes it easy to specify software specific rules for finding bugs and for updating software to use new APIs. These rules can then be applied automatically across an entire code base. Over 40 Coccinelle rules are already available in the Linux kernel source code and Coccinelle has been used in the development of Qemu. The goal of this hands-on tutorial is to enable developers to write their own rules. We will focus on the BiteSizedTasks from the Qemu wiki. Participants should have Coccinelle (available via most Linux distributions) and a recent version of the Qemu source code installed on their machines. 

Julia Lawall, Senior Research Scientist
Inria
France

Julia Lawall is a Senior Research Scientist at Inria. Her research is at the intersection of programming languages and operating systems. She develops the tool Coccinelle and has over 1000 patches in the Linux kernel based on this work. She has presented her work on Coccinelle at numerous events, including FOSDEM, Linux Plumbers, and the Kernel Summit. She has previously mentored two Outreachy (OPW) interns and has been the Linux Kernel Outreachy coordinator since the start of 2015.

Slides: http://www.linux-kvm.org/images/6/66/02x07-Juniper-Julia_Lawall-GettingStartedWithCoccinelleKVVMEdition.pdf
Captions: 
	00:00:20,420 --> 00:00:26,099
so this is a tutorial where I talk some

00:00:24,210 --> 00:00:30,480
of the time and you work in the rest of

00:00:26,099 --> 00:00:33,510
the time so you should have machine or a

00:00:30,480 --> 00:00:36,030
friend with a machine and you're going

00:00:33,510 --> 00:00:40,800
to need the source code of King rule

00:00:36,030 --> 00:00:43,320
version 2.4 point 0 and some version of

00:00:40,800 --> 00:00:44,850
 NL anything is fine whatever if

00:00:43,320 --> 00:00:46,530
you have linux then you probably have

00:00:44,850 --> 00:00:47,910
 and all already in your package

00:00:46,530 --> 00:00:50,820
manager somewhere you can just take

00:00:47,910 --> 00:00:52,829
whatever is there if you don't have

00:00:50,820 --> 00:00:59,670
linux you'll have to download it from

00:00:52,829 --> 00:01:01,920
the website website here or this you can

00:00:59,670 --> 00:01:07,619
search for cox NL and get happen and you

00:01:01,920 --> 00:01:09,510
should find something as well so if

00:01:07,619 --> 00:01:11,840
you're not ready with that now you can

00:01:09,510 --> 00:01:11,840
just

00:01:16,150 --> 00:01:19,620
yeah sure it's fine

00:01:19,979 --> 00:01:25,060
yeah I don't know I'm just telling you

00:01:22,450 --> 00:01:28,210
what I used when I made these slides but

00:01:25,060 --> 00:01:29,500
i guess this release was made quite

00:01:28,210 --> 00:01:31,299
recently because actually when i was

00:01:29,500 --> 00:01:33,189
making the slides it was our c4 or

00:01:31,299 --> 00:01:37,049
something like that so it's probably

00:01:33,189 --> 00:01:37,049
fairly close to what it is with good

00:01:41,470 --> 00:01:46,510
have people used in hell before or

00:01:44,170 --> 00:01:50,590
not could you raise your hand if you

00:01:46,510 --> 00:01:55,420
have it's lots of you who have but

00:01:50,590 --> 00:01:58,510
there's some of you who haven't okay so

00:01:55,420 --> 00:02:02,290
this talk is in two parts the first part

00:01:58,510 --> 00:02:04,150
is easy I think the second part should

00:02:02,290 --> 00:02:06,730
be easy also but the second part is more

00:02:04,150 --> 00:02:08,440
advanced than the first part and so if

00:02:06,730 --> 00:02:11,110
you feel like you're really expert on

00:02:08,440 --> 00:02:12,910
 sanel you can if you like you can

00:02:11,110 --> 00:02:15,070
just completely ignore me and move on to

00:02:12,910 --> 00:02:17,140
the second part I'd be happy to answer

00:02:15,070 --> 00:02:18,790
questions about either part when we have

00:02:17,140 --> 00:02:20,950
the exercise session or you can listen

00:02:18,790 --> 00:02:22,510
to me and then you can do the exercises

00:02:20,950 --> 00:02:24,940
of the second part when it's the

00:02:22,510 --> 00:02:28,690
exercise time or do whatever you find

00:02:24,940 --> 00:02:30,490
convenient and another disclaimer until

00:02:28,690 --> 00:02:33,630
about a week ago I didn't know anything

00:02:30,490 --> 00:02:36,610
about the source code of King moose so

00:02:33,630 --> 00:02:38,230
you it's sort of my perspective on the

00:02:36,610 --> 00:02:40,540
code it might be not really in your

00:02:38,230 --> 00:02:46,940
priority somehow but you'll just play

00:02:40,540 --> 00:02:49,560
along or we'll see what happens okay so

00:02:46,940 --> 00:02:52,790
basically programming problems that

00:02:49,560 --> 00:02:55,350
arise if you want to evolve the code

00:02:52,790 --> 00:02:57,990
maybe you won't have API you want to

00:02:55,350 --> 00:03:00,060
make it better in some way in the case

00:02:57,990 --> 00:03:02,430
of Linux there was recently or a few

00:03:00,060 --> 00:03:04,590
years ago the idea of managed memory you

00:03:02,430 --> 00:03:06,660
would have you would allocate things and

00:03:04,590 --> 00:03:08,670
then they would get free freed by

00:03:06,660 --> 00:03:10,370
themselves that's certainly a benefit

00:03:08,670 --> 00:03:13,020
people don't have the error-prone

00:03:10,370 --> 00:03:16,050
problem of allocating memory and then

00:03:13,020 --> 00:03:17,880
forgetting about the freeze but then if

00:03:16,050 --> 00:03:19,170
you introduce these new API is then you

00:03:17,880 --> 00:03:20,550
have to get people to use them you have

00:03:19,170 --> 00:03:22,620
to get people to use them in the right

00:03:20,550 --> 00:03:24,840
way it's hard to communicate how two

00:03:22,620 --> 00:03:27,060
people have to do that it's hard to

00:03:24,840 --> 00:03:29,660
express exactly the constraints on it in

00:03:27,060 --> 00:03:31,800
words so we have lots of problems

00:03:29,660 --> 00:03:33,570
modernizing the api's can make the code

00:03:31,800 --> 00:03:36,330
more effective but on the other hand

00:03:33,570 --> 00:03:38,640
updating all the parts of the code is on

00:03:36,330 --> 00:03:40,080
the one hand error-prone and on the

00:03:38,640 --> 00:03:43,739
other hand perhaps it's boring you've

00:03:40,080 --> 00:03:47,580
got 5,000 code sites in four thousand

00:03:43,739 --> 00:03:50,040
files it's a lot of work to do I'm then

00:03:47,580 --> 00:03:51,540
on the other hand you end up with since

00:03:50,040 --> 00:03:53,250
people don't like to do all of this then

00:03:51,540 --> 00:03:54,690
you end up with five different ways of

00:03:53,250 --> 00:03:59,150
doing things and that's all so confusing

00:03:54,690 --> 00:04:02,700
and sort of harms your general software

00:03:59,150 --> 00:04:05,700
quality then there's also other kinds of

00:04:02,700 --> 00:04:07,829
robustness problems error handling is a

00:04:05,700 --> 00:04:09,540
continuous problem in C code there's no

00:04:07,829 --> 00:04:11,940
abstractions for it you have to do if

00:04:09,540 --> 00:04:14,010
you have to do three things that you

00:04:11,940 --> 00:04:16,620
allocated there are many mistakes that

00:04:14,010 --> 00:04:18,450
are possible and these errors might not

00:04:16,620 --> 00:04:22,019
occur very often it's hard to find in

00:04:18,450 --> 00:04:23,729
testing and so it's a problem and then

00:04:22,019 --> 00:04:26,580
the third problems just the programmers

00:04:23,729 --> 00:04:28,140
are sloppy they haven't perhaps fully

00:04:26,580 --> 00:04:33,720
understand stood how the C language

00:04:28,140 --> 00:04:35,520
works or they just make some mistakes so

00:04:33,720 --> 00:04:38,700
what we have in general is the need for

00:04:35,520 --> 00:04:40,770
pervasive code changes and we also have

00:04:38,700 --> 00:04:42,180
a sense that having humans do these

00:04:40,770 --> 00:04:44,370
changes that's not always a good thing

00:04:42,180 --> 00:04:47,970
we would like to automate these things

00:04:44,370 --> 00:04:49,530
in someone so here's I'm going to go

00:04:47,970 --> 00:04:51,810
through three examples and then will

00:04:49,530 --> 00:04:54,960
elaborate on these examples later in the

00:04:51,810 --> 00:04:56,640
tutorial so this example so i was saying

00:04:54,960 --> 00:04:57,490
instructed to look at the bite size

00:04:56,640 --> 00:04:59,979
tasks

00:04:57,490 --> 00:05:04,240
Kim oh so that's what I did so some of

00:04:59,979 --> 00:05:06,400
these examples come from that so here we

00:05:04,240 --> 00:05:09,099
have some functions we have the CPU

00:05:06,400 --> 00:05:12,340
physical memory map CPU physical memory

00:05:09,099 --> 00:05:14,470
unmap those I seem to be functions that

00:05:12,340 --> 00:05:16,960
existed in the past and then at some

00:05:14,470 --> 00:05:19,139
point these functions address space map

00:05:16,960 --> 00:05:21,789
address space unmap are introduced and

00:05:19,139 --> 00:05:24,190
these functions did almost the same

00:05:21,789 --> 00:05:25,569
thing this one's a bit more general

00:05:24,190 --> 00:05:27,340
because it seems to have some variable

00:05:25,569 --> 00:05:29,259
here which represents the address space

00:05:27,340 --> 00:05:30,909
that it's supposed to work on and so now

00:05:29,259 --> 00:05:33,639
we have this wrapper function this one

00:05:30,909 --> 00:05:35,650
for that one this one for that one but

00:05:33,639 --> 00:05:37,870
it's just kind of two complete different

00:05:35,650 --> 00:05:40,000
naming strategies for doing exactly the

00:05:37,870 --> 00:05:41,770
same thing so rather than having these

00:05:40,000 --> 00:05:46,509
rappers we would like to just get rid of

00:05:41,770 --> 00:05:49,180
all the calls so there are 28

00:05:46,509 --> 00:05:51,669
occurrences of the first one here in the

00:05:49,180 --> 00:05:53,560
entire chemo code there's 38 occurrences

00:05:51,669 --> 00:05:56,680
of the second one each of them occur in

00:05:53,560 --> 00:05:58,750
15 files so it's a lot of tiresome work

00:05:56,680 --> 00:06:01,000
to go around and make the changes the

00:05:58,750 --> 00:06:02,349
changes are not very complicated but so

00:06:01,000 --> 00:06:07,360
we have to change all the names and we

00:06:02,349 --> 00:06:11,860
have to add this extra argument here's

00:06:07,360 --> 00:06:13,120
another one this is error handling so

00:06:11,860 --> 00:06:16,409
you can look at this one a little bit

00:06:13,120 --> 00:06:16,409
and see if you can find the problem

00:06:27,330 --> 00:06:33,460
get a hint so somebody allocated some

00:06:31,990 --> 00:06:35,860
resource they did some error handling

00:06:33,460 --> 00:06:38,139
check on it that's very good then they

00:06:35,860 --> 00:06:39,669
allocated some other resource and since

00:06:38,139 --> 00:06:41,320
we need error handling check on that too

00:06:39,669 --> 00:06:42,970
we could just copy and paste the code

00:06:41,320 --> 00:06:47,199
from up there and put it down here it

00:06:42,970 --> 00:06:49,600
will surely work just as well and this

00:06:47,199 --> 00:06:51,610
this problem actually what happened it

00:06:49,600 --> 00:06:54,940
seems like this code was also copied and

00:06:51,610 --> 00:06:57,250
pasted in five other files so we

00:06:54,940 --> 00:06:58,780
actually have five occurrences of this

00:06:57,250 --> 00:07:00,610
problem with exactly the same variable

00:06:58,780 --> 00:07:02,199
names and so on but it's a problem that

00:07:00,610 --> 00:07:09,370
occurs over and over again I've seen it

00:07:02,199 --> 00:07:19,780
in the linux kernel as well within your

00:07:09,370 --> 00:07:22,840
source code so it's there yes that's

00:07:19,780 --> 00:07:24,490
okay that's true yes um I mean they the

00:07:22,840 --> 00:07:27,280
person did some work here because here

00:07:24,490 --> 00:07:28,930
here we are checking for the other one

00:07:27,280 --> 00:07:34,780
but they just didn't change the very

00:07:28,930 --> 00:07:36,880
moment okay so here's another one here

00:07:34,780 --> 00:07:38,169
we have about 10 lines of code will

00:07:36,880 --> 00:07:39,280
actually most of its comments but we

00:07:38,169 --> 00:07:42,940
have a certain number of lines of code

00:07:39,280 --> 00:07:46,060
and if you look carefully at this code

00:07:42,940 --> 00:07:47,770
it all does kind of nothing so if we

00:07:46,060 --> 00:07:49,990
start here at the end we have if return

00:07:47,770 --> 00:07:52,960
is not equal to 0 then we want to return

00:07:49,990 --> 00:07:54,639
in red and if return is equal to 0 and

00:07:52,960 --> 00:07:56,740
then we're going to return 0 which is

00:07:54,639 --> 00:07:59,229
the same as red so this can just be

00:07:56,740 --> 00:08:02,380
returned read all down here now we have

00:07:59,229 --> 00:08:05,949
read equals pmac in it return rent so we

00:08:02,380 --> 00:08:08,139
can just do we return pmac in it and now

00:08:05,949 --> 00:08:10,180
we don't need the int ret variable at

00:08:08,139 --> 00:08:14,680
all so this whole function is just one

00:08:10,180 --> 00:08:18,310
line which just returns pmac in it so we

00:08:14,680 --> 00:08:20,770
have n lines to do one line the code is

00:08:18,310 --> 00:08:22,960
more complicated than necessary and then

00:08:20,770 --> 00:08:26,500
it's also may be errors could be

00:08:22,960 --> 00:08:29,139
introduced in some way okay so we're in

00:08:26,500 --> 00:08:32,700
general our goal is to automatically

00:08:29,139 --> 00:08:35,349
find code that contains bugs or defects

00:08:32,700 --> 00:08:37,750
or require some kind of evolution and

00:08:35,349 --> 00:08:39,950
then automatic ideally automatically fix

00:08:37,750 --> 00:08:42,050
the bugs or defects

00:08:39,950 --> 00:08:45,350
perform the evolutions so this kind of

00:08:42,050 --> 00:08:48,980
22 situations one of them is you see a

00:08:45,350 --> 00:08:51,260
problem and you want to see if that

00:08:48,980 --> 00:08:53,450
problem occurs elsewhere in general if

00:08:51,260 --> 00:08:55,520
you have one occurrence of a problem

00:08:53,450 --> 00:08:57,500
probably there's some others as well in

00:08:55,520 --> 00:08:59,330
any large code base and then there's

00:08:57,500 --> 00:09:01,340
some other nice cases where you can

00:08:59,330 --> 00:09:03,560
actually systematize what the solution

00:09:01,340 --> 00:09:04,700
should be so when this window it when

00:09:03,560 --> 00:09:06,830
that occurs then you can make the

00:09:04,700 --> 00:09:08,450
solution automatic if it can't occur

00:09:06,830 --> 00:09:11,060
then it's still useful to have a tool to

00:09:08,450 --> 00:09:13,070
help you find the places where it occurs

00:09:11,060 --> 00:09:14,840
everywhere in the code and our third

00:09:13,070 --> 00:09:17,300
goal is to provide a system that's

00:09:14,840 --> 00:09:19,340
accessible to software developers so

00:09:17,300 --> 00:09:22,460
ideally the learning curve should be

00:09:19,340 --> 00:09:24,710
very low it should be very easy to at

00:09:22,460 --> 00:09:26,810
least get started using the tool and

00:09:24,710 --> 00:09:29,720
then maybe it gets more complicated up

00:09:26,810 --> 00:09:32,890
to that but it should be in terms of

00:09:29,720 --> 00:09:35,270
things that our people are familiar with

00:09:32,890 --> 00:09:36,710
okay so what do we need to do this kind

00:09:35,270 --> 00:09:39,110
of thing the first thing we need is the

00:09:36,710 --> 00:09:41,660
ability to abstract / irrelevant

00:09:39,110 --> 00:09:45,250
information so if you think about our

00:09:41,660 --> 00:09:48,110
call the CPU physical memory unmap thing

00:09:45,250 --> 00:09:50,990
so basically we have a function call and

00:09:48,110 --> 00:09:52,460
it has some things there some elements

00:09:50,990 --> 00:09:54,500
that are important some elements that

00:09:52,460 --> 00:09:57,110
are not important so in this case the

00:09:54,500 --> 00:09:58,370
name of the function is important the

00:09:57,110 --> 00:10:01,190
fact that the function has four

00:09:58,370 --> 00:10:03,170
arguments is sort of important but what

00:10:01,190 --> 00:10:05,360
the actual arguments are doesn't

00:10:03,170 --> 00:10:06,560
actually matter you go back and think to

00:10:05,360 --> 00:10:08,390
the definition of the wrapper function

00:10:06,560 --> 00:10:12,110
all we want to do with this arguments is

00:10:08,390 --> 00:10:13,370
just preserve them another thing we want

00:10:12,110 --> 00:10:16,220
to do we want to be able to transform

00:10:13,370 --> 00:10:18,680
things so in our example with the ofd

00:10:16,220 --> 00:10:21,080
equals whatever if I d e f g equals

00:10:18,680 --> 00:10:24,680
whatever then we just want to replace

00:10:21,080 --> 00:10:26,270
the ifd by 0 ft so we would like to be

00:10:24,680 --> 00:10:28,790
able to do the transformation everywhere

00:10:26,270 --> 00:10:31,370
in the code and have it done right just

00:10:28,790 --> 00:10:33,320
once and then another issue is the

00:10:31,370 --> 00:10:36,590
ability to match scattered to code

00:10:33,320 --> 00:10:38,570
fragments not just atomic things so if

00:10:36,590 --> 00:10:40,130
you can only do atomic things and that's

00:10:38,570 --> 00:10:43,940
basically like what you can do with Sid

00:10:40,130 --> 00:10:46,850
you can replace CPU physical memory

00:10:43,940 --> 00:10:49,850
unmapped by address space test whatever

00:10:46,850 --> 00:10:51,350
it was but if you more for more

00:10:49,850 --> 00:10:52,610
complicated things like the thing where

00:10:51,350 --> 00:10:53,710
we want to get rid of we have the

00:10:52,610 --> 00:10:55,540
variable declaration

00:10:53,710 --> 00:10:57,880
and that turns out that that variable is

00:10:55,540 --> 00:11:00,340
not used anymore then in general the

00:10:57,880 --> 00:11:01,810
declaration can be quite far from the

00:11:00,340 --> 00:11:03,340
place that you were working on before

00:11:01,810 --> 00:11:06,610
where you notice that it's not being

00:11:03,340 --> 00:11:08,560
used so we want to be able to match

00:11:06,610 --> 00:11:11,800
scattered fragments of code and then

00:11:08,560 --> 00:11:15,820
reason about them in different ways okay

00:11:11,800 --> 00:11:17,380
so for this we propose coxon l it

00:11:15,820 --> 00:11:19,870
provides program matching and

00:11:17,380 --> 00:11:22,810
transformation and then it's for

00:11:19,870 --> 00:11:25,840
unprepossessing code so we have our own

00:11:22,810 --> 00:11:29,260
parser and we try to cope with macros in

00:11:25,840 --> 00:11:31,780
some way so the nice thing about that is

00:11:29,260 --> 00:11:34,600
that you can write rules in terms of the

00:11:31,780 --> 00:11:36,430
code that looks like what you see so if

00:11:34,600 --> 00:11:38,140
you have for example in your language in

00:11:36,430 --> 00:11:41,200
your in your program you might have a

00:11:38,140 --> 00:11:43,300
macro for false which is zero so you can

00:11:41,200 --> 00:11:44,830
transform false cinta truth that's what

00:11:43,300 --> 00:11:46,990
you want to do but you're not going to

00:11:44,830 --> 00:11:49,870
be transforming all the zeros into one

00:11:46,990 --> 00:11:55,270
that not all of the zeros represent

00:11:49,870 --> 00:11:57,430
false the idea is that it should fit

00:11:55,270 --> 00:11:59,020
with the sorry another advantage of

00:11:57,430 --> 00:12:01,330
using unprepossessing code is the code

00:11:59,020 --> 00:12:02,920
that comes out looks almost exactly like

00:12:01,330 --> 00:12:05,020
the code that came in except for

00:12:02,920 --> 00:12:07,360
whatever you want it to change so the

00:12:05,020 --> 00:12:09,850
goal is to fit in sort of a continuous

00:12:07,360 --> 00:12:13,930
development which is partly tool based

00:12:09,850 --> 00:12:15,970
and partly human based so we fit with

00:12:13,930 --> 00:12:17,740
the existing habits of C programmers so

00:12:15,970 --> 00:12:20,680
basically the notation that we use is

00:12:17,740 --> 00:12:22,600
like C code basically just make little

00:12:20,680 --> 00:12:24,220
bits of C code that Express the things

00:12:22,600 --> 00:12:27,280
that you want to find and the things

00:12:24,220 --> 00:12:30,190
that you want to produce and it's more

00:12:27,280 --> 00:12:32,560
specifically like patches when you want

00:12:30,190 --> 00:12:34,690
to find something you find some part

00:12:32,560 --> 00:12:36,190
that you find the thing then some parts

00:12:34,690 --> 00:12:38,680
of it you don't like so you put a minus

00:12:36,190 --> 00:12:40,450
in front of them some things you want to

00:12:38,680 --> 00:12:42,280
change those remove things into new

00:12:40,450 --> 00:12:44,200
things so you put plus in front of what

00:12:42,280 --> 00:12:47,050
you want to do so that's kind of the

00:12:44,200 --> 00:12:49,060
whole language at once just fragments of

00:12:47,050 --> 00:12:53,140
code will move some things at some other

00:12:49,060 --> 00:12:54,640
things we have a little bit more we have

00:12:53,140 --> 00:12:56,320
the idea of a meta variable for

00:12:54,640 --> 00:12:58,330
abstracting over sub terms that we're

00:12:56,320 --> 00:13:00,370
not interested in so if you think about

00:12:58,330 --> 00:13:02,440
the first example with the CPU memory

00:13:00,370 --> 00:13:04,370
whatever now we might have for meta

00:13:02,440 --> 00:13:06,230
variables for the four arguments you

00:13:04,370 --> 00:13:10,040
e 2 e 3 E 4 we don't care what they are

00:13:06,230 --> 00:13:11,690
they can be any expression whatsoever we

00:13:10,040 --> 00:13:14,839
have something called a dot for

00:13:11,690 --> 00:13:16,700
abstracting over code sequences so if

00:13:14,839 --> 00:13:19,400
you think you want to maybe reason about

00:13:16,700 --> 00:13:23,240
locks you might be saying lock that that

00:13:19,400 --> 00:13:25,070
unlock so the idea is to somehow fit

00:13:23,240 --> 00:13:26,690
with the way you might write about your

00:13:25,070 --> 00:13:28,040
code when you're describing it to a

00:13:26,690 --> 00:13:30,680
colleague or something like that you

00:13:28,040 --> 00:13:34,100
might write something on paper f of X

00:13:30,680 --> 00:13:35,660
turns into G of X or whatever we have

00:13:34,100 --> 00:13:37,730
the minus and plus and we can also

00:13:35,660 --> 00:13:39,680
search for things if we want to search

00:13:37,730 --> 00:13:49,000
for things that we can put stars on the

00:13:39,680 --> 00:13:49,000
thing so we want to search for yes so

00:13:49,480 --> 00:13:58,190
the parser in general it tries several

00:13:55,040 --> 00:14:00,860
times to parse things and at one of the

00:13:58,190 --> 00:14:04,850
phases of the the first the early thing

00:14:00,860 --> 00:14:07,520
it tries is when it comes to an ifdef it

00:14:04,850 --> 00:14:10,100
tries to sort of make control flow that

00:14:07,520 --> 00:14:11,540
reflects the if def structure so if you

00:14:10,100 --> 00:14:14,060
have nice if that's where it's just

00:14:11,540 --> 00:14:17,270
ifdef and then a statement else a

00:14:14,060 --> 00:14:19,040
statement and effort then it will

00:14:17,270 --> 00:14:21,350
realize that you don't fall through from

00:14:19,040 --> 00:14:25,130
one ifdef to one branch to the other

00:14:21,350 --> 00:14:32,810
branch on the other hand if you like to

00:14:25,130 --> 00:14:35,660
write ifdef and then if else while endif

00:14:32,810 --> 00:14:37,700
and then a test expression and then some

00:14:35,660 --> 00:14:40,310
code it can't really deal with them and

00:14:37,700 --> 00:14:42,500
so actually in that case it would just

00:14:40,310 --> 00:14:47,660
ignore one branch because it just can't

00:14:42,500 --> 00:14:50,180
cope with that at all and so it tries in

00:14:47,660 --> 00:14:52,790
some cases it falls back on throwing

00:14:50,180 --> 00:14:56,089
something away in other cases it falls

00:14:52,790 --> 00:14:57,890
back on just keeping both both branches

00:14:56,089 --> 00:15:01,790
if it can deal with that so the

00:14:57,890 --> 00:15:03,970
advantage of it is that in general it

00:15:01,790 --> 00:15:05,510
can be much more pervasive than a

00:15:03,970 --> 00:15:07,910
situation where you're actually

00:15:05,510 --> 00:15:10,610
selecting some of the branches so if you

00:15:07,910 --> 00:15:13,250
have configurations for x86 and forearm

00:15:10,610 --> 00:15:14,870
then you don't have to select one or the

00:15:13,250 --> 00:15:15,460
other it's going to try and work on both

00:15:14,870 --> 00:15:19,100
of them

00:15:15,460 --> 00:15:21,260
on the other hand it can sometimes make

00:15:19,100 --> 00:15:23,900
false positives because if it thinks one

00:15:21,260 --> 00:15:25,340
branch falls into the other than you

00:15:23,900 --> 00:15:30,550
might be reasoning about the code in the

00:15:25,340 --> 00:15:30,550
wrong way are there other questions

00:15:35,040 --> 00:15:40,949
okay so we can go back to our example we

00:15:37,790 --> 00:15:43,560
had these two functions and our goal is

00:15:40,949 --> 00:15:46,290
to replace the CPU functions by the

00:15:43,560 --> 00:15:51,029
address space functions with the extra

00:15:46,290 --> 00:15:53,940
argument so basically the strategy for

00:15:51,029 --> 00:15:55,500
doing this we can just look around in

00:15:53,940 --> 00:15:57,600
our code and we can take some typical

00:15:55,500 --> 00:16:00,870
examples of code that we would like to

00:15:57,600 --> 00:16:04,949
transform so I found some random calls

00:16:00,870 --> 00:16:06,360
these functions that look like this so

00:16:04,949 --> 00:16:07,740
then as I was saying before we can think

00:16:06,360 --> 00:16:10,860
about what's important what's not

00:16:07,740 --> 00:16:13,050
important so here the names of the

00:16:10,860 --> 00:16:15,600
functions are important this stuff is

00:16:13,050 --> 00:16:17,190
not important that's just our particular

00:16:15,600 --> 00:16:19,350
case there might be some other cases

00:16:17,190 --> 00:16:20,819
where we only want to do this

00:16:19,350 --> 00:16:22,529
transformation when these two arguments

00:16:20,819 --> 00:16:25,019
are zero we want to do something else

00:16:22,529 --> 00:16:26,850
when the situation is different so it's

00:16:25,019 --> 00:16:28,500
not necessarily always the case that the

00:16:26,850 --> 00:16:30,420
function name is important and the rest

00:16:28,500 --> 00:16:34,860
is not it just in this situation that's

00:16:30,420 --> 00:16:38,100
the way it is so we can abstract over

00:16:34,860 --> 00:16:40,889
the names of the arguments so if we look

00:16:38,100 --> 00:16:42,990
back this was just my strategy I took

00:16:40,889 --> 00:16:46,670
the names of the parameters so that I

00:16:42,990 --> 00:16:46,670
would have something meaningful

00:16:49,050 --> 00:16:54,580
so the next thing you can do is write

00:16:52,870 --> 00:16:58,660
down what's the transformation that you

00:16:54,580 --> 00:17:01,269
want so whenever we have a CPU memory

00:16:58,660 --> 00:17:03,430
map call with these arguments now we

00:17:01,269 --> 00:17:07,030
want to make an address space map call

00:17:03,430 --> 00:17:08,679
with always and address space memory as

00:17:07,030 --> 00:17:10,480
the first argument and then we we just

00:17:08,679 --> 00:17:13,120
want to copy down the other arguments in

00:17:10,480 --> 00:17:17,829
the same way and the same thing in the

00:17:13,120 --> 00:17:19,540
unmount case okay but now we have to

00:17:17,829 --> 00:17:20,410
tell Cox NL which are the important

00:17:19,540 --> 00:17:22,660
things in which are they're not

00:17:20,410 --> 00:17:24,220
important things because in just looking

00:17:22,660 --> 00:17:26,679
at this it can't tell buffer might be

00:17:24,220 --> 00:17:28,660
important or might not be important cpu

00:17:26,679 --> 00:17:31,780
the civil memory map might be important

00:17:28,660 --> 00:17:33,460
or it might not be important so that for

00:17:31,780 --> 00:17:37,630
that we have we declare our meta

00:17:33,460 --> 00:17:39,250
variables so basically we had the idea

00:17:37,630 --> 00:17:41,500
that we want these things to look like

00:17:39,250 --> 00:17:43,030
patches patches have a little odd sign

00:17:41,500 --> 00:17:44,890
out sign and then they have some line

00:17:43,030 --> 00:17:48,190
number information and then they have

00:17:44,890 --> 00:17:50,230
code to add and remove so we kept a

00:17:48,190 --> 00:17:52,690
little outside outside at the beginning

00:17:50,230 --> 00:17:56,380
but instead we put our meta variable

00:17:52,690 --> 00:17:58,090
declarations in them so here we just say

00:17:56,380 --> 00:18:01,240
that everything is going to be an

00:17:58,090 --> 00:18:03,340
expression so an expression is a term

00:18:01,240 --> 00:18:06,970
that returns a value so arguments are

00:18:03,340 --> 00:18:08,380
going to be expressions so we declare

00:18:06,970 --> 00:18:10,210
all our meta variables and then we have

00:18:08,380 --> 00:18:12,910
our transformations have our

00:18:10,210 --> 00:18:15,300
transformation in this case any

00:18:12,910 --> 00:18:15,300
questions

00:18:20,070 --> 00:18:23,070
Mary

00:18:23,220 --> 00:18:29,159
yes but it's not because in this

00:18:25,530 --> 00:18:32,100
particular case the address the word

00:18:29,159 --> 00:18:36,179
address space memory is something

00:18:32,100 --> 00:18:39,240
important that's that has to always be

00:18:36,179 --> 00:18:43,860
like that if we went back to the

00:18:39,240 --> 00:18:45,870
original definitions of the functions in

00:18:43,860 --> 00:18:48,240
the cases where we're using the physical

00:18:45,870 --> 00:18:52,220
CPU physical memory map the value that

00:18:48,240 --> 00:18:52,220
we want here is specifically that one

00:18:54,740 --> 00:18:59,400
another way to answer the question is if

00:18:57,270 --> 00:19:01,710
you wanted this to be some random thing

00:18:59,400 --> 00:19:05,280
then you would have to describe how it's

00:19:01,710 --> 00:19:06,870
going to generate that the things that

00:19:05,280 --> 00:19:09,600
you want to add have to come from

00:19:06,870 --> 00:19:11,970
somewhere it has to be it can't make

00:19:09,600 --> 00:19:14,549
that up so this thing that you want to

00:19:11,970 --> 00:19:18,179
add it comes from the minus code here so

00:19:14,549 --> 00:19:22,520
that's fine but the address space memory

00:19:18,179 --> 00:19:22,520
it has to come from somewhere too

00:19:25,530 --> 00:19:34,620
so if we take these two rules then it

00:19:27,720 --> 00:19:37,440
modifies 62 calls ok so if those who did

00:19:34,620 --> 00:19:38,790
a little arithmetic before probably no

00:19:37,440 --> 00:19:43,740
one but I'll tell you this anyway

00:19:38,790 --> 00:19:45,960
they're actually 68 places there's 66

00:19:43,740 --> 00:19:47,550
places where these functions are used if

00:19:45,960 --> 00:19:51,270
you add up the numbers I had before and

00:19:47,550 --> 00:19:53,520
this modifies only 62 calls so then you

00:19:51,270 --> 00:19:56,250
can wonder what happened oh so what

00:19:53,520 --> 00:19:59,370
happened is there are two files that it

00:19:56,250 --> 00:20:01,770
was not able to parse because in key mu

00:19:59,370 --> 00:20:19,530
how do you pronounce this thing that you

00:20:01,770 --> 00:20:24,450
are you doing q mu q mu ok in Q mu okay

00:20:19,530 --> 00:20:25,860
in q mu you use some macros which

00:20:24,450 --> 00:20:27,420
in hell is very oriented toward the

00:20:25,860 --> 00:20:29,790
macros that are used in the linux kernel

00:20:27,420 --> 00:20:31,890
and see you use some macros which are

00:20:29,790 --> 00:20:34,500
not familiar to it and since we're

00:20:31,890 --> 00:20:36,900
working on unprepossessing code we have

00:20:34,500 --> 00:20:39,360
to try to do something with macros we're

00:20:36,900 --> 00:20:41,130
not looking at the definition we are

00:20:39,360 --> 00:20:43,590
just trying to cope with it in some way

00:20:41,130 --> 00:20:46,140
most macro definite most macro uses look

00:20:43,590 --> 00:20:48,240
like function calls or variable names so

00:20:46,140 --> 00:20:49,830
but some of them don't in this

00:20:48,240 --> 00:20:51,810
particular case there's some functions

00:20:49,830 --> 00:20:53,970
that have some macros in the function

00:20:51,810 --> 00:20:56,280
header and so it's not able to parse

00:20:53,970 --> 00:20:58,170
them so we'll see an example later of

00:20:56,280 --> 00:21:00,900
how you can deal with that situation in

00:20:58,170 --> 00:21:04,560
general but basically what would happen

00:21:00,900 --> 00:21:06,600
is you would apply this this wool over

00:21:04,560 --> 00:21:08,100
your entire code base and then if you

00:21:06,600 --> 00:21:10,260
want to be sure that everything is going

00:21:08,100 --> 00:21:12,300
properly then you could grab for these

00:21:10,260 --> 00:21:16,070
functions and see what's left and try to

00:21:12,300 --> 00:21:16,070
deal with those cases afterwards

00:21:16,590 --> 00:21:23,250
okay so in general we have we have a

00:21:20,730 --> 00:21:25,409
semantic patch that is the general

00:21:23,250 --> 00:21:27,539
transformation consists of a number of

00:21:25,409 --> 00:21:30,659
rules each rule can do different things

00:21:27,539 --> 00:21:32,010
and each rule has two parts the meta

00:21:30,659 --> 00:21:35,070
variable declarations and the

00:21:32,010 --> 00:21:36,720
transformation specification the wolves

00:21:35,070 --> 00:21:39,360
are implied in order so you have the

00:21:36,720 --> 00:21:41,940
first rule it's applied everywhere in

00:21:39,360 --> 00:21:43,409
your file Cox now works on one file at a

00:21:41,940 --> 00:21:45,809
time is applied everywhere in the file

00:21:43,409 --> 00:21:47,820
and that moves on to the second rule the

00:21:45,809 --> 00:21:49,260
second rule sees the transformations

00:21:47,820 --> 00:21:55,440
that we're done by the first rule so you

00:21:49,260 --> 00:21:56,520
can do things incrementally so for meta

00:21:55,440 --> 00:21:58,429
variables we have a bunch of different

00:21:56,520 --> 00:22:01,020
kinds of meta variables we have

00:21:58,429 --> 00:22:03,659
expressions which we saw we have

00:22:01,020 --> 00:22:06,480
statements so for example the branch of

00:22:03,659 --> 00:22:09,510
an if might be a statement we have

00:22:06,480 --> 00:22:11,490
identifier so a variable name might be

00:22:09,510 --> 00:22:13,529
an identifier a function name might be

00:22:11,490 --> 00:22:15,570
then identify or structure field name

00:22:13,529 --> 00:22:17,220
might be an identifier and identifies

00:22:15,570 --> 00:22:19,230
the name of something it doesn't have a

00:22:17,220 --> 00:22:23,179
value just representing the name of

00:22:19,230 --> 00:22:27,690
something types integer struct whatever

00:22:23,179 --> 00:22:29,429
constants so we have some kinds of

00:22:27,690 --> 00:22:32,159
materials which are very generic like

00:22:29,429 --> 00:22:34,830
expressions and then constants are a

00:22:32,159 --> 00:22:37,740
restriction of expressions a constant is

00:22:34,830 --> 00:22:42,240
going to be 27 it could be a string

00:22:37,740 --> 00:22:44,640
hello it could be a we follow convention

00:22:42,240 --> 00:22:46,320
if a word has entirely capital letters

00:22:44,640 --> 00:22:51,899
then we assume that it's a hash define

00:22:46,320 --> 00:22:54,360
and the value is a constant and then

00:22:51,899 --> 00:22:58,080
there's something that obscure a local

00:22:54,360 --> 00:23:00,840
ID expression so an ID expression is a

00:22:58,080 --> 00:23:03,720
expression that looks like an identifier

00:23:00,840 --> 00:23:06,320
and then when we say local ID ID

00:23:03,720 --> 00:23:09,929
expression then it's a local variable

00:23:06,320 --> 00:23:11,549
you can also actually combine types with

00:23:09,929 --> 00:23:13,320
that information so you can say a local

00:23:11,549 --> 00:23:16,950
variable of type integer something like

00:23:13,320 --> 00:23:18,510
that yeah that's what I say here we can

00:23:16,950 --> 00:23:21,600
also use any kind of type from source

00:23:18,510 --> 00:23:24,000
program so if you have a struct foo star

00:23:21,600 --> 00:23:25,910
X then you have a meta variable X it

00:23:24,000 --> 00:23:29,530
will only match structs to boost

00:23:25,910 --> 00:23:34,370
and then there's a bunch of other chains

00:23:29,530 --> 00:23:36,590
most that's a bit obscure typedef if you

00:23:34,370 --> 00:23:37,910
need to use some typedef names in your

00:23:36,590 --> 00:23:39,590
semantics patch then it might be

00:23:37,910 --> 00:23:43,960
necessary to tell it it's the type

00:23:39,590 --> 00:23:47,420
definite sometimes it can infer that

00:23:43,960 --> 00:23:50,210
okay and then the transformation so like

00:23:47,420 --> 00:23:54,380
a patch we distinguish the leftmost

00:23:50,210 --> 00:23:55,790
column from the rest sort of so there

00:23:54,380 --> 00:23:57,740
are few characters that have a special

00:23:55,790 --> 00:23:59,120
meaning in the leftmost column although

00:23:57,740 --> 00:24:00,290
you can put other characters and left

00:23:59,120 --> 00:24:02,720
most column and then they will be

00:24:00,290 --> 00:24:04,370
interpreted in the normal way but if you

00:24:02,720 --> 00:24:06,680
have a minus in leftmost column it's

00:24:04,370 --> 00:24:09,740
something to remove a plus in leftmost

00:24:06,680 --> 00:24:12,080
column it's something to add a star in

00:24:09,740 --> 00:24:14,960
the leftmost column is something of

00:24:12,080 --> 00:24:16,700
interest and so what happens if you if

00:24:14,960 --> 00:24:18,980
you make a semantic patch that has stars

00:24:16,700 --> 00:24:20,690
in it then what you get out is something

00:24:18,980 --> 00:24:23,060
that looks like a patch and it has

00:24:20,690 --> 00:24:25,490
minuses on the lines that have the items

00:24:23,060 --> 00:24:28,280
of interest and then at least if you use

00:24:25,490 --> 00:24:34,190
emacs then you can jump from that patch

00:24:28,280 --> 00:24:36,260
to the actual code so so with a star

00:24:34,190 --> 00:24:38,090
that's for searching for the minus and

00:24:36,260 --> 00:24:40,940
plus that's for transformation and so

00:24:38,090 --> 00:24:42,500
you can't mix them and then the

00:24:40,940 --> 00:24:46,250
important thing is that spaces and new

00:24:42,500 --> 00:24:52,010
lines are relevant and so you can put

00:24:46,250 --> 00:24:55,760
them wherever you find convenient so now

00:24:52,010 --> 00:24:57,440
it's almost time for you to work so I'll

00:24:55,760 --> 00:24:59,000
go through these exercises a little bit

00:24:57,440 --> 00:25:01,280
and then there's some hints afterwards

00:24:59,000 --> 00:25:03,680
and then you can actually do some things

00:25:01,280 --> 00:25:06,170
so this is just to take the semantic

00:25:03,680 --> 00:25:07,490
patch that I provided and try it and see

00:25:06,170 --> 00:25:09,200
what happens so I have some questions

00:25:07,490 --> 00:25:11,210
down here did your semantics patch do

00:25:09,200 --> 00:25:12,620
everything it should have they do

00:25:11,210 --> 00:25:14,150
something it should not have so these

00:25:12,620 --> 00:25:16,790
are questions that you can ask yourself

00:25:14,150 --> 00:25:18,140
whenever you use automatic tool the

00:25:16,790 --> 00:25:21,350
automatic tool is not supposed to

00:25:18,140 --> 00:25:23,170
replace your brain it's just supposed to

00:25:21,350 --> 00:25:25,910
help you do things so you should always

00:25:23,170 --> 00:25:29,170
check in question whether the tool

00:25:25,910 --> 00:25:29,170
actually did the right things

00:25:31,060 --> 00:25:36,200
here's some more questions about kind of

00:25:33,680 --> 00:25:39,310
the same thing doing them in slightly

00:25:36,200 --> 00:25:46,280
different ways to see what the effect is

00:25:39,310 --> 00:25:50,710
this one is to do something else you'll

00:25:46,280 --> 00:25:53,330
see event so so some practical issues

00:25:50,710 --> 00:25:58,180
you write your somatic patch you can put

00:25:53,330 --> 00:26:01,070
it in some file called my SP see if

00:25:58,180 --> 00:26:04,700
you want to be sure that your semantics

00:26:01,070 --> 00:26:09,160
patches is incorrect syntactically you

00:26:04,700 --> 00:26:11,540
can say spatchcock see my SPI proxy of

00:26:09,160 --> 00:26:13,640
course if your semantics patch is not

00:26:11,540 --> 00:26:15,590
formed correctly and you try to run it

00:26:13,640 --> 00:26:17,960
on some code it will complain as well so

00:26:15,590 --> 00:26:21,860
it's just up to you whether you want to

00:26:17,960 --> 00:26:23,300
do that step or not to run in semantics

00:26:21,860 --> 00:26:26,330
pets you have two choices you can either

00:26:23,300 --> 00:26:30,730
run it on one file or you can run it on

00:26:26,330 --> 00:26:34,940
a entire directory so you can say spatch

00:26:30,730 --> 00:26:39,670
spfile my SPF eight and then the

00:26:34,940 --> 00:26:39,670
file name or the directory

00:26:41,510 --> 00:26:48,140
in general it's useful so as such it

00:26:45,820 --> 00:26:49,670
generates lots of information or a

00:26:48,140 --> 00:26:51,920
certain amount of information telling

00:26:49,670 --> 00:26:53,960
you what it's doing and it also produces

00:26:51,920 --> 00:26:58,850
a patch like thing which is the output

00:26:53,960 --> 00:27:01,070
and so it's useful to either put the

00:26:58,850 --> 00:27:03,590
patch like thing in a file the standard

00:27:01,070 --> 00:27:07,250
output will always only contain a real

00:27:03,590 --> 00:27:08,660
patch or you can just get rid of all

00:27:07,250 --> 00:27:17,720
that boring stuff that it prints out

00:27:08,660 --> 00:27:19,070
otherwise with the very quiet option one

00:27:17,720 --> 00:27:20,330
thing I should mention about the boring

00:27:19,070 --> 00:27:23,540
stuff that prints out it tells you what

00:27:20,330 --> 00:27:26,060
files it's working and depending on it

00:27:23,540 --> 00:27:28,700
will probably say sometimes it will say

00:27:26,060 --> 00:27:30,290
handling and that's files it's who

00:27:28,700 --> 00:27:33,260
actually thinks it's useful to work on

00:27:30,290 --> 00:27:35,360
sometimes it says skipping so skipping

00:27:33,260 --> 00:27:37,880
should not be alarming just the casino

00:27:35,360 --> 00:27:40,190
does a lot of optimizations to figure

00:27:37,880 --> 00:27:41,930
out where it's useful to do work so it

00:27:40,190 --> 00:27:47,990
skips files where it doesn't think it's

00:27:41,930 --> 00:27:50,510
useful to do work this is not very

00:27:47,990 --> 00:27:52,190
important and then here we have a link

00:27:50,510 --> 00:27:54,380
for the source code and you have the

00:27:52,190 --> 00:27:55,730
link also for these slides so it'd be

00:27:54,380 --> 00:27:57,920
good for you to have the slides on the

00:27:55,730 --> 00:28:04,130
machine so you can look back and forth

00:27:57,920 --> 00:28:05,540
at the explanations and exercises so you

00:28:04,130 --> 00:28:09,950
can just give the slides that this is

00:28:05,540 --> 00:28:13,300
just the kvm forum slides page and then

00:28:09,950 --> 00:28:13,300
you can find in element

00:28:14,919 --> 00:28:16,980
you

00:28:22,680 --> 00:28:24,740
you

00:29:04,450 --> 00:29:12,130
I say okay okay

00:29:18,350 --> 00:29:20,410
you

00:29:23,880 --> 00:29:28,080
so this is to our second example

00:29:30,630 --> 00:29:36,480
in this case we have our assignment ofd

00:29:34,440 --> 00:29:44,100
and then we test something that was

00:29:36,480 --> 00:29:45,510
different than what we assigned so

00:29:44,100 --> 00:29:47,070
that's the thing we want to find out so

00:29:45,510 --> 00:29:52,050
so here we have the idea of something

00:29:47,070 --> 00:29:53,790
being different than something else so

00:29:52,050 --> 00:29:59,370
we could try a semantic patch like this

00:29:53,790 --> 00:30:02,130
so here we have so I mean you can make

00:29:59,370 --> 00:30:04,830
this as specific or as general as you

00:30:02,130 --> 00:30:07,530
want what I've chosen to do is X is the

00:30:04,830 --> 00:30:09,810
result of calling some function so often

00:30:07,530 --> 00:30:12,210
when you call a function it might return

00:30:09,810 --> 00:30:13,800
an error value and you might want to

00:30:12,210 --> 00:30:15,750
test the error value afterwards so

00:30:13,800 --> 00:30:17,400
that's why I was specific in this way if

00:30:15,750 --> 00:30:20,000
you wanted you could just say X is just

00:30:17,400 --> 00:30:22,800
going to be some arbitrary expression

00:30:20,000 --> 00:30:24,810
here I don't care about what the

00:30:22,800 --> 00:30:26,820
arguments are and so I just put that

00:30:24,810 --> 00:30:28,920
data so there might be one argument

00:30:26,820 --> 00:30:33,090
there might be many arguments I don't

00:30:28,920 --> 00:30:35,550
care so I have X that's going to be one

00:30:33,090 --> 00:30:38,790
expression we don't know what it is and

00:30:35,550 --> 00:30:41,370
then I say if Y is less than zero then s

00:30:38,790 --> 00:30:44,610
I say why is going to be another

00:30:41,370 --> 00:30:48,780
expression so this is just the matching

00:30:44,610 --> 00:30:51,030
part so basically this is how I might

00:30:48,780 --> 00:30:52,650
typically make a semantic patch I think

00:30:51,030 --> 00:30:54,090
of some concept i'm interested in i

00:30:52,650 --> 00:30:56,520
might add down some pattern that matches

00:30:54,090 --> 00:30:59,970
that concept and then I think about how

00:30:56,520 --> 00:31:03,020
I want to change that concept so the way

00:30:59,970 --> 00:31:11,040
I want to change the concept is to

00:31:03,020 --> 00:31:14,270
remove y and replace it by X so the

00:31:11,040 --> 00:31:14,270
question does this work

00:31:14,690 --> 00:31:27,800
okay so we have someone who cheated so

00:31:18,620 --> 00:31:31,120
he knows that it works oh yes so but is

00:31:27,800 --> 00:31:31,120
this really the best way to do it

00:31:35,820 --> 00:31:43,620
so I went well yes so that's the problem

00:31:40,950 --> 00:31:45,570
so one might think that we have this

00:31:43,620 --> 00:31:46,950
expression X in this expression Y and

00:31:45,570 --> 00:31:48,360
that those expressions since we gave

00:31:46,950 --> 00:31:49,470
them different meta variable names that

00:31:48,360 --> 00:31:51,090
they might be different from each other

00:31:49,470 --> 00:31:53,400
but there's no reason why they're

00:31:51,090 --> 00:31:56,010
different from each other X is any

00:31:53,400 --> 00:31:57,750
random expression Y is any random

00:31:56,010 --> 00:31:59,300
expression and those can be expressions

00:31:57,750 --> 00:32:01,110
that are the same as each other and

00:31:59,300 --> 00:32:03,450
expressions that are different from each

00:32:01,110 --> 00:32:04,710
other so it's just the fact that it

00:32:03,450 --> 00:32:08,610
works is just so sort of coincidence

00:32:04,710 --> 00:32:10,620
because if we have a test on X then we

00:32:08,610 --> 00:32:12,450
will be removing an X and we will be

00:32:10,620 --> 00:32:16,110
adding back x and so we will be doing

00:32:12,450 --> 00:32:19,740
nothing so it will make changes in a lot

00:32:16,110 --> 00:32:22,920
of code and then but those changes will

00:32:19,740 --> 00:32:25,260
actually be the same thing so it does

00:32:22,920 --> 00:32:31,590
actually work but it's not really the

00:32:25,260 --> 00:32:33,210
best way to do this it actually does not

00:32:31,590 --> 00:32:34,980
generate the patch that doesn't do

00:32:33,210 --> 00:32:36,480
anything doesn't actually print out the

00:32:34,980 --> 00:32:41,130
patch that doesn't do anything because

00:32:36,480 --> 00:32:42,810
it notices that they're the same but

00:32:41,130 --> 00:32:45,120
it's doing all of the work that is

00:32:42,810 --> 00:32:50,310
required to generate the patra justice

00:32:45,120 --> 00:32:51,870
doesn't generate it in the end okay so

00:32:50,310 --> 00:32:53,550
as I said we have expression X

00:32:51,870 --> 00:32:55,530
expression why they both match all

00:32:53,550 --> 00:32:57,120
possible expressions and those all

00:32:55,530 --> 00:32:58,260
possible expressions might be the same

00:32:57,120 --> 00:33:01,530
need to know there might be different

00:32:58,260 --> 00:33:02,940
from each other that's not really what

00:33:01,530 --> 00:33:05,040
we want we only want to do the

00:33:02,940 --> 00:33:08,310
transformation in the case when they are

00:33:05,040 --> 00:33:11,130
actually different so basically we have

00:33:08,310 --> 00:33:13,770
two cases in the first case we have X

00:33:11,130 --> 00:33:16,170
and then we have X that's tested in the

00:33:13,770 --> 00:33:18,960
second case we have X and we have some

00:33:16,170 --> 00:33:23,610
other thing why that's tested and the

00:33:18,960 --> 00:33:26,070
idea is if this one matches then we just

00:33:23,610 --> 00:33:28,750
want to take this case and if it doesn't

00:33:26,070 --> 00:33:34,090
match then we want to consider this case

00:33:28,750 --> 00:33:39,400
so we can express this using what's

00:33:34,090 --> 00:33:41,800
called the disjunction so now we've

00:33:39,400 --> 00:33:44,950
added some new characters that can

00:33:41,800 --> 00:33:47,140
appear in column 0 we have the left

00:33:44,950 --> 00:33:49,060
parenthesis we have the or and we have

00:33:47,140 --> 00:33:51,310
the right parenthesis so you can have

00:33:49,060 --> 00:33:53,320
any number of these or things basically

00:33:51,310 --> 00:33:56,500
you get a different a set of branches

00:33:53,320 --> 00:33:59,440
and it will try them one by one so if

00:33:56,500 --> 00:34:01,480
this one matches that we just stop will

00:33:59,440 --> 00:34:03,970
have matched this and then we match this

00:34:01,480 --> 00:34:06,820
no transformation happens no patch is

00:34:03,970 --> 00:34:10,000
generated everything's fine if this one

00:34:06,820 --> 00:34:12,520
does not match then it will go on and it

00:34:10,000 --> 00:34:13,840
will try to match this one and in that

00:34:12,520 --> 00:34:16,060
case we will actually do a

00:34:13,840 --> 00:34:21,820
transformation and we will generate some

00:34:16,060 --> 00:34:23,679
code as I say up here sometimes you just

00:34:21,820 --> 00:34:25,510
have you have a long statement there's

00:34:23,679 --> 00:34:27,429
some expression it might be 0 it might

00:34:25,510 --> 00:34:30,040
be one you might like to just put your

00:34:27,429 --> 00:34:31,990
disjunction there in line but

00:34:30,040 --> 00:34:33,129
parentheses are used in C from any other

00:34:31,990 --> 00:34:34,899
things so you have to put a little

00:34:33,129 --> 00:34:36,629
backslashes in front of the parentheses

00:34:34,899 --> 00:34:41,220
and the bar and the right parenthesis

00:34:36,629 --> 00:34:44,169
another extremely common error is to

00:34:41,220 --> 00:34:46,720
maybe you have this parenthesis which is

00:34:44,169 --> 00:34:48,850
over here in column whatever and then

00:34:46,720 --> 00:34:50,020
you have some code and then you are done

00:34:48,850 --> 00:34:51,490
with it and so you put a right

00:34:50,020 --> 00:34:55,030
parenthesis you put a right parenthesis

00:34:51,490 --> 00:34:56,889
in column 0 and if it's not matching

00:34:55,030 --> 00:34:59,650
with a left parenthesis in column column

00:34:56,889 --> 00:35:01,090
0 then it will complain so you might see

00:34:59,650 --> 00:35:03,300
some error message about that if you do

00:35:01,090 --> 00:35:03,300
that

00:35:06,390 --> 00:35:14,140
so now you have exercised another

00:35:08,950 --> 00:35:17,530
exercise already so I read up on your

00:35:14,140 --> 00:35:24,160
coding style and you'd like to have

00:35:17,530 --> 00:35:27,730
braces around all of your if branches so

00:35:24,160 --> 00:35:30,400
one thing you could do is you could we

00:35:27,730 --> 00:35:32,080
could do this we could say if e and then

00:35:30,400 --> 00:35:34,300
here we have any random statement and

00:35:32,080 --> 00:35:36,760
then we could put braces around it and

00:35:34,300 --> 00:35:39,040
then we would get braces around all of

00:35:36,760 --> 00:35:41,170
our if branches but unfortunately this

00:35:39,040 --> 00:35:43,210
statement here a random statement is

00:35:41,170 --> 00:35:44,800
also thing with braces and some code

00:35:43,210 --> 00:35:46,300
inside of it and so then you can get

00:35:44,800 --> 00:35:47,650
double bracelets all over the place so

00:35:46,300 --> 00:35:52,840
that's obviously not the thing you want

00:35:47,650 --> 00:35:55,150
to do so the idea is to you need to

00:35:52,840 --> 00:35:56,680
think of there's no meta variable for a

00:35:55,150 --> 00:35:58,210
simple statement or something like that

00:35:56,680 --> 00:36:00,430
so you have to just enumerate the

00:35:58,210 --> 00:36:05,950
possibilities so the idea of the

00:36:00,430 --> 00:36:08,140
exercise is to do them and you want to

00:36:05,950 --> 00:36:09,430
write just one rule use the disjunction

00:36:08,140 --> 00:36:11,950
so you write just one rule to do

00:36:09,430 --> 00:36:14,700
everything yes so it's just one

00:36:11,950 --> 00:36:14,700
exercises

00:36:22,550 --> 00:36:24,610
you

00:36:26,200 --> 00:36:32,490
okay so a number of

00:36:27,869 --> 00:36:34,349
people have tried if and then they have

00:36:32,490 --> 00:36:36,990
their two things for the disjunction and

00:36:34,349 --> 00:36:39,930
the first thing is braised with an s in

00:36:36,990 --> 00:36:43,049
it and the second thing is plus space

00:36:39,930 --> 00:36:44,789
plus brace and then s in it and then

00:36:43,049 --> 00:36:49,529
they're surprised because nothing

00:36:44,789 --> 00:36:51,029
happens so it's not really nothing is

00:36:49,529 --> 00:36:56,249
happening it's working very hard to do

00:36:51,029 --> 00:36:58,740
nothing so you can feel better so what

00:36:56,249 --> 00:37:00,720
happens so coxon all this was I is a

00:36:58,740 --> 00:37:02,279
concept that's supposed to come up later

00:37:00,720 --> 00:37:04,799
but I'll just explain it now because

00:37:02,279 --> 00:37:08,099
comes up now we have this idea of

00:37:04,799 --> 00:37:09,749
isomorphism so the point is that in

00:37:08,099 --> 00:37:12,480
general you're right things that look

00:37:09,749 --> 00:37:14,700
like syntax and then matches things that

00:37:12,480 --> 00:37:16,559
look like what you write so that's sort

00:37:14,700 --> 00:37:20,039
of good but sometimes it's too much

00:37:16,559 --> 00:37:24,900
detail so sometimes you might write if x

00:37:20,039 --> 00:37:27,749
equals equals null but I noticed in qemu

00:37:24,900 --> 00:37:29,299
code oftens the early sometimes people

00:37:27,749 --> 00:37:31,499
write it the other way around in

00:37:29,299 --> 00:37:35,910
forgotten what this is called but null

00:37:31,499 --> 00:37:37,559
equals equals x and so it'd be awfully

00:37:35,910 --> 00:37:40,319
tiresome whenever you want to have a

00:37:37,559 --> 00:37:42,539
null null testing semantic patch to have

00:37:40,319 --> 00:37:44,730
to write x equals equals null and have

00:37:42,539 --> 00:37:46,710
to write nul equals equals x there's

00:37:44,730 --> 00:37:48,720
sort of this concept of testing for null

00:37:46,710 --> 00:37:49,619
you just want to write it once because

00:37:48,720 --> 00:37:51,089
you've probably got some other

00:37:49,619 --> 00:37:52,140
disjunctions you want to do for other

00:37:51,089 --> 00:37:54,359
things you don't want have to think

00:37:52,140 --> 00:37:56,640
about everything so it has a bunch of

00:37:54,359 --> 00:38:00,779
rules and these rules are on a file

00:37:56,640 --> 00:38:03,390
called standard iso for isomorphism and

00:38:00,779 --> 00:38:05,460
these rules are rewriting rules that it

00:38:03,390 --> 00:38:08,369
applies in advance to your semantics

00:38:05,460 --> 00:38:12,509
patch and one of these rewriting rules

00:38:08,369 --> 00:38:13,920
is that most of the time if you have a

00:38:12,509 --> 00:38:15,569
single statement and put people put

00:38:13,920 --> 00:38:17,339
braces around it or if you have a single

00:38:15,569 --> 00:38:21,480
statement people don't put braces around

00:38:17,339 --> 00:38:24,359
it it's not very important so one of the

00:38:21,480 --> 00:38:27,150
isomorphisms is if you see a brace and a

00:38:24,359 --> 00:38:29,339
single statement and a close race then

00:38:27,150 --> 00:38:33,839
let's just match the single statement by

00:38:29,339 --> 00:38:37,259
itself so when you write if e whatever

00:38:33,839 --> 00:38:39,300
brace s close brace then that's the same

00:38:37,259 --> 00:38:42,270
as writing if II

00:38:39,300 --> 00:38:48,480
and then ask any statement at all and so

00:38:42,270 --> 00:38:53,610
it's going to match any any if branch at

00:38:48,480 --> 00:38:56,340
all some people have found that if you

00:38:53,610 --> 00:39:00,740
turn the s into a dot dot dot then

00:38:56,340 --> 00:39:03,120
everything works so you can try that

00:39:00,740 --> 00:39:05,690
because the isomorphism doesn't trigger

00:39:03,120 --> 00:39:05,690
in that case

00:39:07,890 --> 00:39:13,680
yes so is it one thing you can do if you

00:39:11,880 --> 00:39:15,839
just don't like isomorphisms at all you

00:39:13,680 --> 00:39:17,789
can say you can make an empty file you

00:39:15,839 --> 00:39:21,420
can say on the command line you can say

00:39:17,789 --> 00:39:23,579
iso file empty iso and then it will not

00:39:21,420 --> 00:39:24,960
use any isomorphisms another thing you

00:39:23,579 --> 00:39:27,119
can do if you just don't like this one

00:39:24,960 --> 00:39:30,299
so we found this one it's called braces

00:39:27,119 --> 00:39:32,760
for so in between the initial at sign

00:39:30,299 --> 00:39:40,130
out sign you can put disabled braces for

00:39:32,760 --> 00:39:40,130
and then it will not do that one ya

00:39:43,130 --> 00:39:49,670
kicked in any way okay okay

00:39:59,309 --> 00:40:03,480
okay yeah do it with that done

00:40:16,990 --> 00:40:19,990
july

00:40:21,190 --> 00:40:24,060
knuckle

00:40:36,910 --> 00:40:41,590
so it seems actually that nobody did the

00:40:39,190 --> 00:40:47,680
exercise in which in the way in which I

00:40:41,590 --> 00:40:50,710
didn't so the hint is used pretty much

00:40:47,680 --> 00:40:53,680
to no one I think I'm not sure the way I

00:40:50,710 --> 00:40:57,870
did it was I made a big disjunction and

00:40:53,680 --> 00:41:07,090
I put brake and I put return and I put

00:40:57,870 --> 00:41:09,160
okay yes that's true yeah it's reveal

00:41:07,090 --> 00:41:14,080
yeah that's true that's true that's true

00:41:09,160 --> 00:41:16,030
that's true this it's true so this the

00:41:14,080 --> 00:41:17,740
the point I wanted to make is if you do

00:41:16,030 --> 00:41:19,780
it that way then you might feel tempted

00:41:17,740 --> 00:41:21,670
you might see you have this big

00:41:19,780 --> 00:41:24,160
disjunction and we have break and we

00:41:21,670 --> 00:41:25,840
have or we have braces and then break

00:41:24,160 --> 00:41:27,760
and we have braces and then return and

00:41:25,840 --> 00:41:29,020
braces and then whatever and so you

00:41:27,760 --> 00:41:30,940
might feel that you could just take

00:41:29,020 --> 00:41:36,460
those braces and put them on the outside

00:41:30,940 --> 00:41:38,500
of the disjunction but you can't when

00:41:36,460 --> 00:41:41,440
you add things that have to attach to

00:41:38,500 --> 00:41:46,870
actual tokens they can't attach to dis

00:41:41,440 --> 00:41:50,560
junctions I the first one would be okay

00:41:46,870 --> 00:41:53,560
you could be adding it after the if but

00:41:50,560 --> 00:41:56,280
the last one the one in the last one if

00:41:53,560 --> 00:41:58,570
you have parentheses and then plus brace

00:41:56,280 --> 00:42:00,370
this parenthesis is part of the

00:41:58,570 --> 00:42:03,640
disjunction it's not part of your code

00:42:00,370 --> 00:42:06,240
and the brace things you add have to go

00:42:03,640 --> 00:42:06,240
onto the code

00:42:16,530 --> 00:42:18,590
you

00:42:19,750 --> 00:42:30,710
okay so I'm going to go on now ok so the

00:42:27,170 --> 00:42:32,150
third part is the third example I showed

00:42:30,710 --> 00:42:33,680
at the beginning where we have these

00:42:32,150 --> 00:42:37,250
things at the end and we want to make

00:42:33,680 --> 00:42:39,230
them simpler so we thought already just

00:42:37,250 --> 00:42:42,230
to go through it quickly we have if we

00:42:39,230 --> 00:42:44,000
read return ret return 0 so if the only

00:42:42,230 --> 00:42:45,890
way we get to the return 0 is if we're

00:42:44,000 --> 00:42:51,470
at is equal to 0 so we can just return

00:42:45,890 --> 00:42:53,390
wed directly now we have read equals the

00:42:51,470 --> 00:42:56,690
something and then we have returned read

00:42:53,390 --> 00:42:59,060
and so we can simplify that into just

00:42:56,690 --> 00:43:01,940
return something and now we have a

00:42:59,060 --> 00:43:06,860
variable that's not used anywhere and we

00:43:01,940 --> 00:43:11,090
can get rid of that variable so we have

00:43:06,860 --> 00:43:13,850
a much shorter function so most of this

00:43:11,090 --> 00:43:17,450
is pretty straightforward ok so you did

00:43:13,850 --> 00:43:19,130
part of it already as exercise for the

00:43:17,450 --> 00:43:20,900
first part we have if ret return ret

00:43:19,130 --> 00:43:24,890
return 0 and that can all just be

00:43:20,900 --> 00:43:27,260
compressed into return ret and for the

00:43:24,890 --> 00:43:29,930
other part we have wet equals e return

00:43:27,260 --> 00:43:33,380
ret and that can be just compressed into

00:43:29,930 --> 00:43:35,180
return e and so we discuss quite a bit

00:43:33,380 --> 00:43:37,820
previously about whether you have an

00:43:35,180 --> 00:43:41,540
expression and identifier or a local ID

00:43:37,820 --> 00:43:45,140
expression and expression is not going

00:43:41,540 --> 00:43:49,130
to be a good solution for a ret because

00:43:45,140 --> 00:43:51,080
of this case if you have an expression

00:43:49,130 --> 00:43:54,320
and if you get rid of that return then

00:43:51,080 --> 00:43:56,690
you're going to get rid of the updating

00:43:54,320 --> 00:43:59,420
of the state field or where wait filled

00:43:56,690 --> 00:44:04,460
with it so what we would like to do

00:43:59,420 --> 00:44:07,750
instead is this local ID expression then

00:44:04,460 --> 00:44:12,370
everything is going to be as a tribute

00:44:07,750 --> 00:44:12,370
ok questions

00:44:15,600 --> 00:44:20,280
ok so then more interesting part is how

00:44:17,640 --> 00:44:21,720
can we get rid of wet now that's not

00:44:20,280 --> 00:44:24,200
being used anymore in this particular

00:44:21,720 --> 00:44:24,200
case

00:44:31,109 --> 00:44:38,640
so basically our situation is that we

00:44:34,289 --> 00:44:42,989
have a we have some variable which is

00:44:38,640 --> 00:44:46,730
being declared and then we have all of

00:44:42,989 --> 00:44:50,279
the code that gets executed afterwards

00:44:46,730 --> 00:44:52,200
so that can go along many different

00:44:50,279 --> 00:44:54,480
execution paths there can be some ifs

00:44:52,200 --> 00:44:56,249
with several branches we can go in

00:44:54,480 --> 00:44:58,249
different directions we can return all

00:44:56,249 --> 00:45:01,380
different kinds of things can happen and

00:44:58,249 --> 00:45:04,980
what we say is that we can remove this

00:45:01,380 --> 00:45:07,109
declaration of this variable when there

00:45:04,980 --> 00:45:12,319
is no use of the root of that variable

00:45:07,109 --> 00:45:17,130
afterwards in general dot dot you say

00:45:12,319 --> 00:45:18,660
maybe a dot dot B dot dot C so you have

00:45:17,130 --> 00:45:20,400
first you have a then you have be

00:45:18,660 --> 00:45:22,589
somewhere later and then you have see

00:45:20,400 --> 00:45:24,779
somewhere later when you have a

00:45:22,589 --> 00:45:26,489
something that the dot and then nothing

00:45:24,779 --> 00:45:28,890
after it then that goes all the way to

00:45:26,489 --> 00:45:30,119
the end of the function you can also go

00:45:28,890 --> 00:45:32,220
the other way around you can have that

00:45:30,119 --> 00:45:33,960
that that that and then whatever and

00:45:32,220 --> 00:45:37,259
that would go all the way back to the

00:45:33,960 --> 00:45:40,400
beginning of the function so this

00:45:37,259 --> 00:45:42,960
matches some sequence of code and then

00:45:40,400 --> 00:45:45,749
when you have this data that then you

00:45:42,960 --> 00:45:48,150
can it's like you want to match anything

00:45:45,749 --> 00:45:50,730
but use in general you need to put some

00:45:48,150 --> 00:45:53,130
constraints on what gets matched and so

00:45:50,730 --> 00:45:56,160
this is when there is no occurrence of I

00:45:53,130 --> 00:45:58,589
so this means that on every single

00:45:56,160 --> 00:46:00,690
execution path that can come out of the

00:45:58,589 --> 00:46:02,640
variable declaration they all have to

00:46:00,690 --> 00:46:10,230
satisfy that property they all have to

00:46:02,640 --> 00:46:14,940
have no uses of I this is what I just

00:46:10,230 --> 00:46:16,470
said there's one detail here the death a

00:46:14,940 --> 00:46:19,529
thought in general it matches what's

00:46:16,470 --> 00:46:22,170
called the shortest path so if you think

00:46:19,529 --> 00:46:24,210
about if you have lock and unlock often

00:46:22,170 --> 00:46:25,859
in a function if you fairly fine grained

00:46:24,210 --> 00:46:27,900
locking you might have lock unlock

00:46:25,859 --> 00:46:29,609
lock/unlock several times in the

00:46:27,900 --> 00:46:31,349
function and so if you're doing writing

00:46:29,609 --> 00:46:33,089
a semantic patch which is reasoning

00:46:31,349 --> 00:46:35,249
about the relationship between locking

00:46:33,089 --> 00:46:36,749
and unlocking then you probably want to

00:46:35,249 --> 00:46:39,569
match the ones that are closest together

00:46:36,749 --> 00:46:40,760
and not all possible permutations of a

00:46:39,569 --> 00:46:45,130
lock here and

00:46:40,760 --> 00:46:48,740
here so it's not very relevant here

00:46:45,130 --> 00:46:50,390
basically here at some point we have

00:46:48,740 --> 00:46:52,070
we're going to match this to a

00:46:50,390 --> 00:46:54,380
declaration and that's going to

00:46:52,070 --> 00:46:56,150
establish what the very what the type is

00:46:54,380 --> 00:46:59,330
and what the variable name is and

00:46:56,150 --> 00:47:02,020
normally in see we don't we declare

00:46:59,330 --> 00:47:04,610
variables that are already declared so

00:47:02,020 --> 00:47:05,810
the idea of the shortest path doesn't

00:47:04,610 --> 00:47:09,580
matter because this is the only

00:47:05,810 --> 00:47:13,130
declaration that has that form anyway

00:47:09,580 --> 00:47:15,340
and so this is our complete semantic

00:47:13,130 --> 00:47:15,340
patch

00:47:18,359 --> 00:47:24,640
yes so here as I said before we have

00:47:21,910 --> 00:47:27,039
three walls the first rule applies to

00:47:24,640 --> 00:47:29,230
the entire file it's going to make some

00:47:27,039 --> 00:47:30,880
transformations and then the second rule

00:47:29,230 --> 00:47:32,589
is going to apply again to the entire

00:47:30,880 --> 00:47:34,960
file and it will see the changes that

00:47:32,589 --> 00:47:36,369
were made in the first rule and then the

00:47:34,960 --> 00:47:38,799
third rule will see the changes that

00:47:36,369 --> 00:47:41,769
were made by the first two rules and so

00:47:38,799 --> 00:47:45,160
this third woman will be able to remove

00:47:41,769 --> 00:47:52,509
variables that were made unnecessary by

00:47:45,160 --> 00:47:54,220
the previous rules yes right so that's

00:47:52,509 --> 00:47:56,799
that's a that's a good point as well

00:47:54,220 --> 00:48:01,569
this is a little bit doing more I mean

00:47:56,799 --> 00:48:07,660
obviously q mu is well written piece of

00:48:01,569 --> 00:48:09,700
software and so actually I to make

00:48:07,660 --> 00:48:12,579
examples for this talk I tried to find

00:48:09,700 --> 00:48:15,309
some typical bugs in Linux kernel code

00:48:12,579 --> 00:48:19,240
and I didn't find any in here so I think

00:48:15,309 --> 00:48:21,009
you and you gives a good good impression

00:48:19,240 --> 00:48:25,690
but I sexually frustrating for the talk

00:48:21,009 --> 00:48:27,910
writer but so yes so since you have a

00:48:25,690 --> 00:48:30,069
well written piece of software clearly

00:48:27,910 --> 00:48:32,410
you don't have any unused variables and

00:48:30,069 --> 00:48:34,569
so it's not going to be a problem but I

00:48:32,410 --> 00:48:37,150
think there are actually a few unused

00:48:34,569 --> 00:48:39,579
variables lurking in the software and so

00:48:37,150 --> 00:48:41,950
you do actually make a few extra changes

00:48:39,579 --> 00:48:45,569
but in this case won't you be happier to

00:48:41,950 --> 00:48:45,569
be getting rid of them anyway

00:48:47,330 --> 00:48:57,120
so what oh yes right minus W are so

00:48:51,780 --> 00:49:03,750
young so I'm last year I think we have

00:48:57,120 --> 00:49:12,450
switched into talk to yes sorry what was

00:49:03,750 --> 00:49:15,840
the question yeah unfortunately you

00:49:12,450 --> 00:49:20,760
can't mix changing things and searching

00:49:15,840 --> 00:49:22,320
for things so you if you would yes so

00:49:20,760 --> 00:49:24,180
what this is this is supposed to be

00:49:22,320 --> 00:49:25,770
doing it's supposed to be making lots of

00:49:24,180 --> 00:49:27,930
unused variables and then get rid

00:49:25,770 --> 00:49:30,360
getting rid of them but if you want to

00:49:27,930 --> 00:49:32,430
go and monitor your software and just

00:49:30,360 --> 00:49:34,290
see or do we have any unused variables

00:49:32,430 --> 00:49:36,000
and how do we feel about them you can

00:49:34,290 --> 00:49:38,520
just make this fool by itself and you

00:49:36,000 --> 00:49:41,550
can put a star in front of it and it

00:49:38,520 --> 00:49:44,370
will not work okay so the reason why

00:49:41,550 --> 00:49:47,090
does not work is because the semantics

00:49:44,370 --> 00:49:49,350
of changing things and the semantics of

00:49:47,090 --> 00:49:51,240
searching for things is a little bit

00:49:49,350 --> 00:49:53,040
different so when you want to change

00:49:51,240 --> 00:49:56,040
things when you put that thought it

00:49:53,040 --> 00:49:58,020
means all execution paths should have

00:49:56,040 --> 00:50:00,840
this property because usually if you

00:49:58,020 --> 00:50:03,330
change something then you want sort of

00:50:00,840 --> 00:50:05,130
to feel secure about it you want you

00:50:03,330 --> 00:50:08,160
want it to be consistent and coherent

00:50:05,130 --> 00:50:10,560
and otherwise you should think harder

00:50:08,160 --> 00:50:12,030
about your change rule when you put

00:50:10,560 --> 00:50:14,040
stars and you're just searching for

00:50:12,030 --> 00:50:16,350
things often you want to search for

00:50:14,040 --> 00:50:18,720
example for example do we have a Malick

00:50:16,350 --> 00:50:20,550
without a free does there exist an

00:50:18,720 --> 00:50:23,880
execution path that has Melek and

00:50:20,550 --> 00:50:26,520
doesn't have free on it for example so

00:50:23,880 --> 00:50:28,290
then if you just put a star then you get

00:50:26,520 --> 00:50:30,240
searching for things and you'll get

00:50:28,290 --> 00:50:32,760
variables where the variables declared

00:50:30,240 --> 00:50:35,400
and there exists an execution path that

00:50:32,760 --> 00:50:37,260
doesn't use the variable if you want to

00:50:35,400 --> 00:50:38,820
change it so it's star but it's

00:50:37,260 --> 00:50:41,340
searching for places things that are

00:50:38,820 --> 00:50:44,790
never used anywhere then you can say

00:50:41,340 --> 00:50:46,560
when for all and that when for all will

00:50:44,790 --> 00:50:50,240
change the death about some ethics so

00:50:46,560 --> 00:50:50,240
that it checks all the execution paths

00:50:51,440 --> 00:50:57,079
yeah there's actually a bunch of

00:50:53,940 --> 00:50:57,079
different things you can put here

00:51:14,060 --> 00:51:21,150
mm-hmm okay has some heuristics for

00:51:18,480 --> 00:51:22,710
deciding whether you like the comment or

00:51:21,150 --> 00:51:28,260
not I'm a little bit what version of

00:51:22,710 --> 00:51:31,710
 in hell do you have okay I don't

00:51:28,260 --> 00:51:33,570
know it's unfair but I mean the the

00:51:31,710 --> 00:51:36,380
return was still there right you should

00:51:33,570 --> 00:51:42,560
still have returned the function call

00:51:36,380 --> 00:51:45,530
yeah but it got rid of the comment okay

00:51:42,560 --> 00:51:47,910
yeah it has some heuristics for keeping

00:51:45,530 --> 00:51:50,540
keeping things and somehow that doesn't

00:51:47,910 --> 00:51:50,540
satisfy it

00:51:51,770 --> 00:51:55,480
how would I comments

00:51:57,170 --> 00:52:03,900
okay in in hell there's no way to

00:52:00,360 --> 00:52:06,720
match comments and so yeah I'm just

00:52:03,900 --> 00:52:08,070
there's no way to match comments and so

00:52:06,720 --> 00:52:12,540
you can just freely put comments

00:52:08,070 --> 00:52:15,540
wherever you want you can either use / /

00:52:12,540 --> 00:52:17,760
or you can use / star whichever style of

00:52:15,540 --> 00:52:20,940
comments you want on the other hand you

00:52:17,760 --> 00:52:25,460
can add comments you can put plus and

00:52:20,940 --> 00:52:25,460
then a comment so that works too

00:52:30,830 --> 00:52:35,360
yeah so here we have our example and

00:52:32,930 --> 00:52:37,160
it's supposed to do this but it turns

00:52:35,360 --> 00:52:44,620
out it seems that it removes the comment

00:52:37,160 --> 00:52:48,520
as well don't know why so here we have

00:52:44,620 --> 00:52:48,520
two more exercises

00:53:05,840 --> 00:53:10,840
yeah actually we don't have so much time

00:53:08,030 --> 00:53:19,640
left now we only have six more minutes

00:53:10,840 --> 00:53:24,310
and maybe maybe the interested reader

00:53:19,640 --> 00:53:24,310
can do the exercises on his own time

00:53:24,400 --> 00:53:28,070
because there was something that several

00:53:26,600 --> 00:53:33,440
people asked about that I wanted to

00:53:28,070 --> 00:53:38,870
answer and doesn't seem we get the

00:53:33,440 --> 00:53:42,290
answer to it in here so so the thing

00:53:38,870 --> 00:53:45,970
that people asked about was about how do

00:53:42,290 --> 00:53:52,070
we extend the macro file so that it will

00:53:45,970 --> 00:53:53,840
know I think it's here how do we extend

00:53:52,070 --> 00:53:58,070
the macro file so that it knows about

00:53:53,840 --> 00:54:00,080
our macros and so the the case that

00:53:58,070 --> 00:54:03,140
comes up I guess it comes up later on is

00:54:00,080 --> 00:54:05,090
when you have a structure and sometimes

00:54:03,140 --> 00:54:14,200
you have some funny things on the types

00:54:05,090 --> 00:54:16,850
of your structures and so you might have

00:54:14,200 --> 00:54:19,970
it wasn't like this but let's put let's

00:54:16,850 --> 00:54:22,970
say we have int there's like an int but

00:54:19,970 --> 00:54:25,580
it's wrapped around in q something q X Y

00:54:22,970 --> 00:54:28,220
Z so we have a structure field it's got

00:54:25,580 --> 00:54:32,080
Q X Y Z and then parentheses and then

00:54:28,220 --> 00:54:34,130
int and then the field which is our and

00:54:32,080 --> 00:54:37,280
coxon else doesn't know about your

00:54:34,130 --> 00:54:41,210
little Q XYZ thing and so then parsing

00:54:37,280 --> 00:54:42,890
of the structure will fail if you don't

00:54:41,210 --> 00:54:44,480
care at all about the structure for your

00:54:42,890 --> 00:54:47,900
semantics patch if your semantics

00:54:44,480 --> 00:54:50,810
Patrick's changing ABC into MN oh it

00:54:47,900 --> 00:54:52,610
doesn't matter it will just pick up and

00:54:50,810 --> 00:54:54,350
start parsing things in a normal way

00:54:52,610 --> 00:54:55,820
afterwards but if you need the

00:54:54,350 --> 00:54:57,830
information in the structure for

00:54:55,820 --> 00:54:59,780
something then it will not be good if

00:54:57,830 --> 00:55:01,940
it's not able to parse the structure so

00:54:59,780 --> 00:55:03,890
we have the standard iso for

00:55:01,940 --> 00:55:10,160
isomorphisms and we have another file

00:55:03,890 --> 00:55:12,410
called standard h4 macros and one thing

00:55:10,160 --> 00:55:15,710
you could do if you decide you're only

00:55:12,410 --> 00:55:18,260
going to ever you work on um you then

00:55:15,710 --> 00:55:19,880
you can just change standard H

00:55:18,260 --> 00:55:22,220
put in whatever macro definitions you

00:55:19,880 --> 00:55:26,000
like another thing you can do is you can

00:55:22,220 --> 00:55:27,650
make your own file standard QA muah and

00:55:26,000 --> 00:55:29,750
then you can put in your macro

00:55:27,650 --> 00:55:32,330
definitions that are specific for your

00:55:29,750 --> 00:55:35,330
project in there and then there's some

00:55:32,330 --> 00:55:39,220
arguments macro file minus minus macro-

00:55:35,330 --> 00:55:44,030
file so you would say spatch macro file

00:55:39,220 --> 00:55:48,170
my q muah with my definitions and then

00:55:44,030 --> 00:55:49,970
work on your code so if you run across

00:55:48,170 --> 00:55:51,530
this problem in general you might want

00:55:49,970 --> 00:55:54,050
to make your own script that just always

00:55:51,530 --> 00:55:56,450
includes the macro definitions that you

00:55:54,050 --> 00:55:58,880
find convenient and when you put your

00:55:56,450 --> 00:56:00,470
macro definitions in this file you don't

00:55:58,880 --> 00:56:01,370
have to put the wheel definition

00:56:00,470 --> 00:56:03,290
and all doesn't care about the

00:56:01,370 --> 00:56:05,420
definition all you want in general is

00:56:03,290 --> 00:56:08,030
something that will make your code parts

00:56:05,420 --> 00:56:11,840
so in my example where we have the queue

00:56:08,030 --> 00:56:15,140
XYZ thing around end the parcel will be

00:56:11,840 --> 00:56:18,410
happy if the field has typed in and so

00:56:15,140 --> 00:56:22,010
if you can just write your hash define Q

00:56:18,410 --> 00:56:24,880
XYZ and the argument X and then just X

00:56:22,010 --> 00:56:27,620
and then it will just see the internet

00:56:24,880 --> 00:56:31,370
you don't want to overdo this though

00:56:27,620 --> 00:56:33,950
because when coxon l has to resort to

00:56:31,370 --> 00:56:36,290
using your macro definitions it is not

00:56:33,950 --> 00:56:39,440
able to transform the thing that has

00:56:36,290 --> 00:56:41,960
been processed because there's in some

00:56:39,440 --> 00:56:43,810
sense there's two versions of the code

00:56:41,960 --> 00:56:47,030
and it doesn't know how to manage them

00:56:43,810 --> 00:56:49,700
so if you ever end up trying to

00:56:47,030 --> 00:56:51,590
transform something that's the result of

00:56:49,700 --> 00:56:53,560
expanding a macro it's going to crash

00:56:51,590 --> 00:56:56,060
and you're not going to get any results

00:56:53,560 --> 00:56:59,060
and there's another case which is quite

00:56:56,060 --> 00:57:01,850
particular which is sometimes people

00:56:59,060 --> 00:57:05,210
make macros for it look like function

00:57:01,850 --> 00:57:08,870
calls but they put the semicolon inside

00:57:05,210 --> 00:57:10,580
of the macro definition and so if you

00:57:08,870 --> 00:57:11,810
have your semicolon inside your macro

00:57:10,580 --> 00:57:14,960
definition that you have something looks

00:57:11,810 --> 00:57:16,520
like a function call but it's just going

00:57:14,960 --> 00:57:18,130
to kind of run into the next statement

00:57:16,520 --> 00:57:22,610
there won't be any semicolon there and

00:57:18,130 --> 00:57:24,590
so there's a special word that you can

00:57:22,610 --> 00:57:27,200
use for defining macros would like that

00:57:24,590 --> 00:57:30,599
which is called macro statement all in

00:57:27,200 --> 00:57:31,680
capital letters so you probably have

00:57:30,599 --> 00:57:33,900
they've forgotten all of these things

00:57:31,680 --> 00:57:36,539
but if you just look in the standard H

00:57:33,900 --> 00:57:38,700
file then you can see examples and you

00:57:36,539 --> 00:57:44,069
can make something like it that's

00:57:38,700 --> 00:57:46,319
appropriate for your code so are there

00:57:44,069 --> 00:57:49,880
any general questions that we can answer

00:57:46,319 --> 00:57:49,880
in the last two minutes

00:57:59,360 --> 00:58:02,170
mm-hmm

00:58:13,620 --> 00:58:20,230
so I guess I mean it's a project which

00:58:17,740 --> 00:58:21,880
is developed an academic context so you

00:58:20,230 --> 00:58:24,550
could call it academic project there's

00:58:21,880 --> 00:58:27,280
no in from a research point of view

00:58:24,550 --> 00:58:30,040
there's not much left to do but there's

00:58:27,280 --> 00:58:31,480
lots of small details which have not

00:58:30,040 --> 00:58:35,560
been implemented that you may run across

00:58:31,480 --> 00:58:39,970
and so if you complain to the mailing

00:58:35,560 --> 00:58:41,770
list then we will try to extend it with

00:58:39,970 --> 00:58:47,920
the features that you want in a

00:58:41,770 --> 00:58:49,540
reasonable amount of time so many things

00:58:47,920 --> 00:58:51,250
that you might want are actually quite

00:58:49,540 --> 00:58:53,530
simple to add the fact that it's not

00:58:51,250 --> 00:58:55,780
there is not because it's hard and so

00:58:53,530 --> 00:58:58,180
you shouldn't hesitate to ask for

00:58:55,780 --> 00:58:59,680
something just if you think even if you

00:58:58,180 --> 00:59:01,750
think there's not resources for

00:58:59,680 --> 00:59:03,340
something like that so many things are

00:59:01,750 --> 00:59:08,830
quite simple to add and we can just fix

00:59:03,340 --> 00:59:12,160
it quickly so basically at the moment I

00:59:08,830 --> 00:59:14,050
work on it I mostly react to things on a

00:59:12,160 --> 00:59:15,730
mailing list and then I have an engineer

00:59:14,050 --> 00:59:18,220
who works on it and he does more

00:59:15,730 --> 00:59:22,240
long-term things so at the moment his

00:59:18,220 --> 00:59:26,200
goal which is of would be perhaps a

00:59:22,240 --> 00:59:28,060
benefit you his goal is to try to move

00:59:26,200 --> 00:59:30,670
the parser a little bit away from the

00:59:28,060 --> 00:59:33,910
Linux kernel and increase the weight of

00:59:30,670 --> 00:59:35,620
success on other software so we have all

00:59:33,910 --> 00:59:37,870
of the source code which is available in

00:59:35,620 --> 00:59:40,060
debian and we can try to run it on that

00:59:37,870 --> 00:59:43,780
and try to increase our percentage of

00:59:40,060 --> 00:59:46,600
success in general you can if you say

00:59:43,780 --> 00:59:48,910
spatch and you say parse C minus minus

00:59:46,600 --> 00:59:51,820
plus minus C and then your directory and

00:59:48,910 --> 00:59:53,350
it will give you it will print out lots

00:59:51,820 --> 00:59:55,750
of things it will complain about lots of

00:59:53,350 --> 00:59:58,060
things probably but at the very end it

00:59:55,750 --> 01:00:00,460
will give you the top 10 tokens that it

00:59:58,060 --> 01:00:02,260
didn't like and it will give you what

01:00:00,460 --> 01:00:05,470
percentage of tokens it was able to

01:00:02,260 --> 01:00:07,570
parse so if you're at forty percent you

01:00:05,470 --> 01:00:09,790
might find some tokens that are turning

01:00:07,570 --> 01:00:12,310
up over and over again you can make some

01:00:09,790 --> 01:00:14,290
macro definitions and then probably you

01:00:12,310 --> 01:00:16,240
can get to 90 I've tried a bunch of

01:00:14,290 --> 01:00:18,640
different projects at various times and

01:00:16,240 --> 01:00:20,320
I can often get to eighty eighty-five

01:00:18,640 --> 01:00:23,170
ninety percent

01:00:20,320 --> 01:00:26,860
success by adding a few macro

01:00:23,170 --> 01:00:31,480
definitions so that's that's the main

01:00:26,860 --> 01:00:34,120
directions at the moment basically the

01:00:31,480 --> 01:00:36,160
the code is written in no camel and so

01:00:34,120 --> 01:00:38,590
most of the functionality is implemented

01:00:36,160 --> 01:00:42,220
in no camel and we can be fairly

01:00:38,590 --> 01:00:45,160
reactive about Oh camel things there's

01:00:42,220 --> 01:00:49,900
also a whole build system mess on the

01:00:45,160 --> 01:00:51,850
side and people sometimes send patches

01:00:49,900 --> 01:00:54,220
to try to help us improve the build

01:00:51,850 --> 01:00:59,080
system and unfortunately we don't have a

01:00:54,220 --> 01:01:00,460
lot of expertise in that and so I don't

01:00:59,080 --> 01:01:02,440
know I mean if you want to contribute to

01:01:00,460 --> 01:01:04,450
you find something you don't like we're

01:01:02,440 --> 01:01:10,240
kind of happy to have the contributions

01:01:04,450 --> 01:01:15,520
but it kind of makes problems too so

01:01:10,240 --> 01:01:18,610
when ya so there's a if you look on the

01:01:15,520 --> 01:01:21,430
web page there's a contact thing if you

01:01:18,610 --> 01:01:24,030
google for jee main coxon l you can also

01:01:21,430 --> 01:01:27,520
find the archives at the mailing list oh

01:01:24,030 --> 01:01:31,150
so there's also IRC channel and it's

01:01:27,520 --> 01:01:33,930
quite inactive but you can make it more

01:01:31,150 --> 01:01:33,930
active so

01:01:40,390 --> 01:01:49,359
I think so yeah yeah no I'm the coxal

01:01:46,359 --> 01:01:53,019
macro file is totally oriented towards

01:01:49,359 --> 01:01:54,490
Linux so the need has not come up but it

01:01:53,019 --> 01:01:57,960
could be nice for someone just to put

01:01:54,490 --> 01:01:57,960
together a macro file and then

01:02:03,700 --> 01:02:08,880
yeah yeah yeah yeah that's a good idea

01:02:13,400 --> 01:02:16,570
sorry what

01:02:19,880 --> 01:02:26,779
I think no one has been motivated to

01:02:23,539 --> 01:02:30,230
change it in the last eight years or so

01:02:26,779 --> 01:02:32,299
but if you send patches i think i have i

01:02:30,230 --> 01:02:34,910
know someone who's good at MX and he can

01:02:32,299 --> 01:02:38,529
check it if it's okay it's completely

01:02:34,910 --> 01:02:38,529
fine if you want to improve the maxima

01:02:43,610 --> 01:02:46,810
yeah okay

01:02:59,830 --> 01:03:17,670

YouTube URL: https://www.youtube.com/watch?v=qtYuVXidv94


