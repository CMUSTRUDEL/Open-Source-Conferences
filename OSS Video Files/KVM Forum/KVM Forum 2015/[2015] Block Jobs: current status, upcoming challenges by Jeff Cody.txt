Title: [2015] Block Jobs: current status, upcoming challenges by Jeff Cody
Publication date: 2015-09-10
Playlist: KVM Forum 2015
Description: 
	This provides an overview of the current status of live block jobs operations in QEMU, along with challenges facing block operations in the future. This presentation will also provide a small tutorial on the structure of block jobs, and how to implement a sample block job operation.

Jeff Cody
Software Engineer, Red Hat
Jeff is a Senior Software Engineer with Red Hat, currently working in the virtualization group. He currently works on the QEMU block layer, with a focus on live block job operations, and block image formats. Jeff was a presenter at the 2012, 2013, and 2014 KVM Forums. He works remotely from his home in Fort Wayne, Indiana.

Slides: http://qemu.rocks/jtc-kvm2015/
Captions: 
	00:00:14,450 --> 00:00:21,960
my name is Jeff Cody on the senior

00:00:18,779 --> 00:00:24,619
software engineer with red hat working

00:00:21,960 --> 00:00:29,010
in qmu primarily in the block layer and

00:00:24,619 --> 00:00:33,770
i am a sub maintainer for block jobs and

00:00:29,010 --> 00:00:38,010
also some of the network drive image

00:00:33,770 --> 00:00:40,680
drivers for qm you so long to be talking

00:00:38,010 --> 00:00:44,910
about today relates specifically just to

00:00:40,680 --> 00:00:48,000
the block jobs and we're going to go

00:00:44,910 --> 00:00:53,100
over its status and some of the upcoming

00:00:48,000 --> 00:00:55,850
challenges and also at the end we'll go

00:00:53,100 --> 00:01:01,559
over with the structure of the block job

00:00:55,850 --> 00:01:03,359
entails so moving on to the status

00:01:01,559 --> 00:01:06,240
before we get there we'll go ahead and

00:01:03,359 --> 00:01:08,460
just define what a block job is to make

00:01:06,240 --> 00:01:14,880
sure we're all on the same page as far

00:01:08,460 --> 00:01:17,520
as block jobs go they are meant

00:01:14,880 --> 00:01:20,340
primarily to to work with the management

00:01:17,520 --> 00:01:25,049
software layer like libvirt but they can

00:01:20,340 --> 00:01:28,020
also be issued directly by a user but

00:01:25,049 --> 00:01:31,530
the block dogs are defined as qmp

00:01:28,020 --> 00:01:34,619
commands as part of the queue API and so

00:01:31,530 --> 00:01:40,530
all the block jobs are started by Q and

00:01:34,619 --> 00:01:42,000
P or an hmp in some cases command for

00:01:40,530 --> 00:01:44,509
instance if we look at block commit

00:01:42,000 --> 00:01:49,670
here's an example usage of block commit

00:01:44,509 --> 00:01:54,350
that's the JSON that's sent over qmp

00:01:49,670 --> 00:01:54,350
doing black men under verdi of 0 device

00:01:54,409 --> 00:01:58,729
the point of the block jobs is to

00:01:58,850 --> 00:02:08,340
perform IO tasks without having to pause

00:02:03,899 --> 00:02:09,989
to guest so as we're doing a block jobs

00:02:08,340 --> 00:02:12,400
where we execute those in the co routine

00:02:09,989 --> 00:02:15,370
which is essentially a call

00:02:12,400 --> 00:02:20,620
operative multitasking environment used

00:02:15,370 --> 00:02:24,730
inside qmu and this allows us to do you

00:02:20,620 --> 00:02:27,879
know our jobs asynchronously so and we

00:02:24,730 --> 00:02:32,230
can dial and adjust the speed threshold

00:02:27,879 --> 00:02:36,060
that that job runs at to maximize guest

00:02:32,230 --> 00:02:39,909
performance or even the other the host

00:02:36,060 --> 00:02:42,040
requirements and honestly the whole

00:02:39,909 --> 00:02:44,500
point of the block jobs is to do I owe

00:02:42,040 --> 00:02:46,629
on the drive images that might be

00:02:44,500 --> 00:02:49,750
modifying a drive image might be reading

00:02:46,629 --> 00:02:52,799
from it or creating new Drive images or

00:02:49,750 --> 00:02:55,870
shortening the whole drive image change

00:02:52,799 --> 00:02:59,620
so that's just kind of a an overview of

00:02:55,870 --> 00:03:02,920
what bak jobs are will now look at what

00:02:59,620 --> 00:03:08,859
our current status is why I did the

00:03:02,920 --> 00:03:10,659
status from 22 since last kvm forum 22

00:03:08,859 --> 00:03:12,879
came out shortly after that it was it

00:03:10,659 --> 00:03:18,430
was a good starting point for Ford

00:03:12,879 --> 00:03:22,810
status we have four block jobs currently

00:03:18,430 --> 00:03:26,099
in q mu we have backup which as the name

00:03:22,810 --> 00:03:29,290
implies gives you a point I'm back up to

00:03:26,099 --> 00:03:32,530
another image either over a network or

00:03:29,290 --> 00:03:34,959
it could dozen help be over network and

00:03:32,530 --> 00:03:36,489
this is an area it's got a lot of work

00:03:34,959 --> 00:03:39,609
that's ongoing and commune down we'll

00:03:36,489 --> 00:03:42,310
get to that here in a little bit we also

00:03:39,609 --> 00:03:47,769
have blocked stream block streams one

00:03:42,310 --> 00:03:50,199
the earlier one of the older block jobs

00:03:47,769 --> 00:03:53,199
and this is a way to move data around

00:03:50,199 --> 00:03:56,889
inside to chain we can move data in the

00:03:53,199 --> 00:04:01,030
chain up into an overlay from a backing

00:03:56,889 --> 00:04:02,979
file then we a block commit which is

00:04:01,030 --> 00:04:05,139
analogous to block stream but in the

00:04:02,979 --> 00:04:08,489
opposite direction we can move data from

00:04:05,139 --> 00:04:10,840
the overlay down into the backing file

00:04:08,489 --> 00:04:14,560
then we have block mare is our last

00:04:10,840 --> 00:04:17,289
block job and as it sounds like we mayor

00:04:14,560 --> 00:04:18,789
drives right to a new destination and we

00:04:17,289 --> 00:04:22,460
can marriage as new right so we can

00:04:18,789 --> 00:04:24,860
mirror all the all the data

00:04:22,460 --> 00:04:27,139
and we'll also cover in addition to

00:04:24,860 --> 00:04:28,850
those four block jobs and was it

00:04:27,139 --> 00:04:30,319
highlights what's gone on with those

00:04:28,850 --> 00:04:33,830
will also cover some of the block job

00:04:30,319 --> 00:04:38,270
infrastructure changes and stuff to do

00:04:33,830 --> 00:04:44,569
in the future here so if we start

00:04:38,270 --> 00:04:47,419
looking at backup we have the block of

00:04:44,569 --> 00:04:51,410
backup qmp command which was added by

00:04:47,419 --> 00:04:53,030
fam in around two to three i believe is

00:04:51,410 --> 00:04:55,639
when it first the first official release

00:04:53,030 --> 00:04:58,250
where we'll be in the block dev backup

00:04:55,639 --> 00:05:02,419
command allows us to basically specify

00:04:58,250 --> 00:05:04,430
the the image we're going to be

00:05:02,419 --> 00:05:08,750
manipulating not by having to specify

00:05:04,430 --> 00:05:11,360
bite a device string incremental sync

00:05:08,750 --> 00:05:14,479
mode was added so this is a big one into

00:05:11,360 --> 00:05:18,229
the feature that's still ongoing added

00:05:14,479 --> 00:05:20,060
by Jon Snow he gave a talk yesterday a

00:05:18,229 --> 00:05:23,240
presentation on that so a lot of

00:05:20,060 --> 00:05:25,190
information there the intÃ©ressant I'd

00:05:23,240 --> 00:05:26,930
definitely check out his presentation

00:05:25,190 --> 00:05:28,400
his slides are probably online somewhere

00:05:26,930 --> 00:05:32,380
now and the presentation will be

00:05:28,400 --> 00:05:37,490
available sometime soon there's also a

00:05:32,380 --> 00:05:40,960
QM you wit on incremental sync mode an

00:05:37,490 --> 00:05:43,280
email back up but in nutshell it allows

00:05:40,960 --> 00:05:46,699
rather have to do a full backup of

00:05:43,280 --> 00:05:49,460
everything in a drive image allows you

00:05:46,699 --> 00:05:53,000
to do what would be kind of a sane

00:05:49,460 --> 00:05:54,680
rational way of doing backups of doing a

00:05:53,000 --> 00:05:56,630
full backup and then doing incremental

00:05:54,680 --> 00:06:00,889
backups after that of just what's

00:05:56,630 --> 00:06:03,919
changed and we also have some patches on

00:06:00,889 --> 00:06:07,550
the list there's a Colo sport which is

00:06:03,919 --> 00:06:10,539
the coarse grain lock stepping this is

00:06:07,550 --> 00:06:14,960
another area that had a presentation

00:06:10,539 --> 00:06:18,219
yesterday and that of course will be

00:06:14,960 --> 00:06:21,229
online as well but it's a way to provide

00:06:18,219 --> 00:06:24,680
high availability date of replication

00:06:21,229 --> 00:06:30,050
and these patches were smid by winco

00:06:24,680 --> 00:06:33,430
yang and there's also a wiki entry on

00:06:30,050 --> 00:06:33,430
this feature as well

00:06:33,460 --> 00:06:40,010
so if we look at block stream block

00:06:37,340 --> 00:06:41,540
stream didn't have quite as much things

00:06:40,010 --> 00:06:43,100
that made it n QM you but there's some

00:06:41,540 --> 00:06:46,010
stuff going on the list but there were

00:06:43,100 --> 00:06:47,750
some minor bug fixes and clean up in

00:06:46,010 --> 00:06:49,730
there but mainly the stuff that just

00:06:47,750 --> 00:06:51,080
happened two intersecting to block job

00:06:49,730 --> 00:06:54,410
code not necessarily intended

00:06:51,080 --> 00:06:56,720
specifically for blocks screen but we do

00:06:54,410 --> 00:07:00,380
have as far as patches on the list we

00:06:56,720 --> 00:07:04,100
have some intermediate streaming support

00:07:00,380 --> 00:07:05,420
by alberto garcia and he was here

00:07:04,100 --> 00:07:11,540
yesterday by thinking you had to head

00:07:05,420 --> 00:07:14,120
home today but this patch series brings

00:07:11,540 --> 00:07:17,030
some feature parity to block streaming

00:07:14,120 --> 00:07:22,250
similar what was in place for a block

00:07:17,030 --> 00:07:27,170
commit currently when we are doing block

00:07:22,250 --> 00:07:30,050
streaming with what's in qmu now we can

00:07:27,170 --> 00:07:32,360
start from a any given base image in the

00:07:30,050 --> 00:07:35,630
chain but then everything between that

00:07:32,360 --> 00:07:37,820
and active layer gets pushed up into the

00:07:35,630 --> 00:07:41,090
active layer so in this case we can take

00:07:37,820 --> 00:07:42,920
snap a data and snap a and date and snap

00:07:41,090 --> 00:07:48,310
be and we can push that up into the

00:07:42,920 --> 00:07:48,310
active layer but without bare toes

00:07:48,820 --> 00:07:57,710
patches it does what we can start only

00:07:55,160 --> 00:08:00,230
Becca we are able to then just move data

00:07:57,710 --> 00:08:01,730
from snap a from one of the intermediate

00:08:00,230 --> 00:08:03,890
images and move it to another

00:08:01,730 --> 00:08:05,390
intermediate image so if we want to

00:08:03,890 --> 00:08:06,800
reduce the size for a chain we don't

00:08:05,390 --> 00:08:08,990
have to collapse a whole chain all the

00:08:06,800 --> 00:08:12,200
way up to the active layer we can just

00:08:08,990 --> 00:08:16,820
push data from one intermediate layer to

00:08:12,200 --> 00:08:20,300
another and then drop that redundant

00:08:16,820 --> 00:08:23,300
image then so those are patches on the

00:08:20,300 --> 00:08:28,490
list now and I expect those will go in

00:08:23,300 --> 00:08:30,980
pretty early in a 2 dot 5 cycle blocked

00:08:28,490 --> 00:08:33,469
mint this one didn't have a whole lot of

00:08:30,980 --> 00:08:37,870
changes mainly just some minor bug fixes

00:08:33,469 --> 00:08:40,400
and cleanup and that's really about it

00:08:37,870 --> 00:08:42,710
block mayor has some more changes in

00:08:40,400 --> 00:08:47,480
there then the definitely block commit

00:08:42,710 --> 00:08:52,130
did some stuff to made in the team you

00:08:47,480 --> 00:08:54,950
get between 22 and now is a bitmap

00:08:52,130 --> 00:09:00,530
spoiling fix from Vladimir and this

00:08:54,950 --> 00:09:04,460
fixed a bitmap issue when we added

00:09:00,530 --> 00:09:07,000
bitmap support for black mare in black

00:09:04,460 --> 00:09:10,250
America had its own bitmap but was using

00:09:07,000 --> 00:09:12,760
global bitmap manipulation functions for

00:09:10,250 --> 00:09:16,510
an entire block state block driver state

00:09:12,760 --> 00:09:20,000
which then would set or clear or reset

00:09:16,510 --> 00:09:24,200
dirty bitmaps that weren't intended to

00:09:20,000 --> 00:09:26,570
be cleared a recent and fam has patches

00:09:24,200 --> 00:09:30,650
for some bitmap scanning speed up that

00:09:26,570 --> 00:09:33,830
made it in for two dot for dot zero and

00:09:30,650 --> 00:09:36,310
just recently Kevin had a patch and for

00:09:33,830 --> 00:09:40,190
a Cohen co routinely interesting fix

00:09:36,310 --> 00:09:43,940
this was a regression fix to prevent us

00:09:40,190 --> 00:09:45,170
from re-entering the co routine when we

00:09:43,940 --> 00:09:46,850
did not expect to reenter to kill

00:09:45,170 --> 00:09:50,390
routine and re-entering it when we

00:09:46,850 --> 00:09:53,390
actually intended to are resuming it i

00:09:50,390 --> 00:09:56,540
should say and then also other minor bug

00:09:53,390 --> 00:10:00,440
fixes and clean up a curtain block block

00:09:56,540 --> 00:10:04,360
there um as far as block job

00:10:00,440 --> 00:10:04,360
infrastructure for what made it in

00:10:04,420 --> 00:10:11,690
nested pause which has nothing at all do

00:10:07,339 --> 00:10:14,920
with nested verte but it's a patch by

00:10:11,690 --> 00:10:18,110
fam for two dot for and it allows us to

00:10:14,920 --> 00:10:22,730
pair up multiple block job pause and

00:10:18,110 --> 00:10:24,530
block job resume commands and so we have

00:10:22,730 --> 00:10:27,950
future challenges and some things that

00:10:24,530 --> 00:10:32,240
need to improve for two dot five a

00:10:27,950 --> 00:10:35,360
couple of items on this list one is up

00:10:32,240 --> 00:10:37,670
blockers which stands for operational

00:10:35,360 --> 00:10:39,410
blockers when we have block jobs we have

00:10:37,670 --> 00:10:42,280
certain operations that we want to block

00:10:39,410 --> 00:10:45,050
and prevent from happening to keep the

00:10:42,280 --> 00:10:48,170
chain safe we don't want to modify

00:10:45,050 --> 00:10:51,010
contents when it's not expecting to be

00:10:48,170 --> 00:10:53,990
modified or once there's other

00:10:51,010 --> 00:10:56,699
operations or

00:10:53,990 --> 00:10:59,009
items in the chain and expected contents

00:10:56,699 --> 00:11:02,069
to be a certain state and then we modify

00:10:59,009 --> 00:11:04,980
that we do have operational blockers in

00:11:02,069 --> 00:11:07,199
place that in the code that's been

00:11:04,980 --> 00:11:10,139
around for a while but what we would do

00:11:07,199 --> 00:11:11,879
is add some finer granularity to that be

00:11:10,139 --> 00:11:17,490
able to run more block jobs in parallel

00:11:11,879 --> 00:11:21,930
and also improved some the locking

00:11:17,490 --> 00:11:26,810
safety that we currently have in another

00:11:21,930 --> 00:11:29,879
area is a safer commit mode and it's

00:11:26,810 --> 00:11:34,110
really spun from a ir c conversation

00:11:29,879 --> 00:11:37,439
with eric blake but the idea what the

00:11:34,110 --> 00:11:40,079
commit is uncommitted as inherently a

00:11:37,439 --> 00:11:44,040
risky operation just to due to the

00:11:40,079 --> 00:11:47,550
nature of how commit occurs we have

00:11:44,040 --> 00:11:50,100
multiple images in a block device state

00:11:47,550 --> 00:11:52,769
chain and we're taking data from the top

00:11:50,100 --> 00:11:54,709
or from somewhere in that chain and

00:11:52,769 --> 00:11:59,790
we're pushing it down into backing files

00:11:54,709 --> 00:12:01,949
the problem being is that each image in

00:11:59,790 --> 00:12:05,250
that chain is essentially a difference

00:12:01,949 --> 00:12:11,430
file from the image right before it so

00:12:05,250 --> 00:12:14,519
when we push data down images are no

00:12:11,430 --> 00:12:16,050
longer so if we take data that's an

00:12:14,519 --> 00:12:20,189
active here that's different from what's

00:12:16,050 --> 00:12:23,819
in base and we push it down then snap a

00:12:20,189 --> 00:12:26,430
and snap be our most likely invalid

00:12:23,819 --> 00:12:29,610
because there a difference off of

00:12:26,430 --> 00:12:31,889
something that is not expected and this

00:12:29,610 --> 00:12:34,410
is expected behavior however for those

00:12:31,889 --> 00:12:36,720
two images become invalidated because

00:12:34,410 --> 00:12:39,449
they'll get dropped from the chain the

00:12:36,720 --> 00:12:41,970
idea is you're doing this commit so that

00:12:39,449 --> 00:12:44,009
you can push all the data from here here

00:12:41,970 --> 00:12:46,050
and here down into the base and then you

00:12:44,009 --> 00:12:49,649
drop snap a and you drop snap be from

00:12:46,050 --> 00:12:54,180
the chain however you might for instance

00:12:49,649 --> 00:12:57,569
have the block commit operation failed

00:12:54,180 --> 00:12:59,790
from let's say like a disk i/o error or

00:12:57,569 --> 00:13:04,439
if you're doing over network file system

00:12:59,790 --> 00:13:07,420
you have a network error and in that

00:13:04,439 --> 00:13:11,140
failed state everything's okay

00:13:07,420 --> 00:13:13,330
when you're operating from the top of

00:13:11,140 --> 00:13:14,950
the chain because everything down

00:13:13,330 --> 00:13:17,740
through here will be consistent as read

00:13:14,950 --> 00:13:19,510
through active because only it from its

00:13:17,740 --> 00:13:23,650
view everything will sorry everything

00:13:19,510 --> 00:13:29,800
will be the same however it's possible

00:13:23,650 --> 00:13:31,240
that other tools may want to look

00:13:29,800 --> 00:13:33,550
directly one of these other snapshots

00:13:31,240 --> 00:13:36,070
for some reason or it could be the

00:13:33,550 --> 00:13:38,770
outside of the Q mu process you know

00:13:36,070 --> 00:13:41,560
there's another tool or piece of

00:13:38,770 --> 00:13:45,100
software that's looking at or relying on

00:13:41,560 --> 00:13:47,470
these two snapshots that cuum you has no

00:13:45,100 --> 00:13:51,130
way of knowing about and this would

00:13:47,470 --> 00:13:53,200
typically managed by the software

00:13:51,130 --> 00:13:54,910
management layer like libvirt but of

00:13:53,200 --> 00:13:57,760
course users can do things outside of

00:13:54,910 --> 00:14:01,690
any of our software right if they are

00:13:57,760 --> 00:14:03,250
determined enough and so once this

00:14:01,690 --> 00:14:05,440
commit happens these two are no longer

00:14:03,250 --> 00:14:08,410
valid but what we can do to help

00:14:05,440 --> 00:14:09,760
mitigate that to a certain extent is we

00:14:08,410 --> 00:14:11,920
can try to be a little bit safer about

00:14:09,760 --> 00:14:17,650
how we do this by doing a hybrid stream

00:14:11,920 --> 00:14:19,930
and commit now we you know we don't want

00:14:17,650 --> 00:14:24,400
to stream everything in base up to snap

00:14:19,930 --> 00:14:27,430
a because that's slower and it's not

00:14:24,400 --> 00:14:29,440
it's not necessary what we want to do is

00:14:27,430 --> 00:14:31,180
we want to take just the sectors are

00:14:29,440 --> 00:14:35,560
going to be changed from active going

00:14:31,180 --> 00:14:38,500
into base and stream no sectors up in to

00:14:35,560 --> 00:14:41,590
snap a before we commit the sectors from

00:14:38,500 --> 00:14:43,450
active down into the base and then once

00:14:41,590 --> 00:14:47,860
we commit those sectors from active down

00:14:43,450 --> 00:14:51,640
into the base every image in this chain

00:14:47,860 --> 00:14:57,100
right here remains valid they're all

00:14:51,640 --> 00:14:59,440
happy as each one of these is a

00:14:57,100 --> 00:15:01,840
difference from the one previous snap a

00:14:59,440 --> 00:15:03,130
CSL sectors in its side of it so it's

00:15:01,840 --> 00:15:06,340
not going to go and try to fetch those

00:15:03,130 --> 00:15:08,050
from base snap be when it goes to read

00:15:06,340 --> 00:15:12,520
those sectors will go down look at snap

00:15:08,050 --> 00:15:15,400
a snap a will have them and so we won't

00:15:12,520 --> 00:15:18,819
look at the modified sectors on the base

00:15:15,400 --> 00:15:21,129
and of course active after its commit

00:15:18,819 --> 00:15:24,609
well how these two images dropped and be

00:15:21,129 --> 00:15:26,319
looking straight at base or if that's

00:15:24,609 --> 00:15:28,839
not the case it's still only looking at

00:15:26,319 --> 00:15:32,979
its own sectors so everything remains

00:15:28,839 --> 00:15:36,699
valid except for some fringe cases which

00:15:32,979 --> 00:15:39,269
team you has no way of preventing and

00:15:36,699 --> 00:15:42,459
would hopefully be prevented by a

00:15:39,269 --> 00:15:44,289
management software such as libvirt and

00:15:42,459 --> 00:15:48,519
that would be if they were so Nelson

00:15:44,289 --> 00:15:50,649
made outside of Q mu and overlay on base

00:15:48,519 --> 00:15:54,039
that's in parallel to the rest of this

00:15:50,649 --> 00:15:57,999
chain pushing day down here we didn't

00:15:54,039 --> 00:16:00,489
value eight that overlay but we can't

00:15:57,999 --> 00:16:04,029
really do much about that but we can

00:16:00,489 --> 00:16:11,169
help the kind of more standard normal

00:16:04,029 --> 00:16:14,279
use case be a little bit safer there's

00:16:11,169 --> 00:16:16,569
also patches that are on the list I

00:16:14,279 --> 00:16:18,939
don't have a slide up here for but it's

00:16:16,569 --> 00:16:21,429
related to incremental backup there's a

00:16:18,939 --> 00:16:24,129
whole whole area of that on

00:16:21,429 --> 00:16:28,509
transactional support and error handling

00:16:24,129 --> 00:16:31,359
that is most likely i'm expecting to be

00:16:28,509 --> 00:16:35,289
available in two dot five it's my

00:16:31,359 --> 00:16:41,499
assumption so if we look at a structure

00:16:35,289 --> 00:16:43,779
of a block job we have some key

00:16:41,499 --> 00:16:45,279
components of the block up i'll try to

00:16:43,779 --> 00:16:49,799
speed it up here we're running out of

00:16:45,279 --> 00:16:53,139
time block jobs are defined by qmp

00:16:49,799 --> 00:16:58,329
command definition that's a present in a

00:16:53,139 --> 00:17:02,199
JSON a queue API file and also in the

00:16:58,329 --> 00:17:06,250
key of B commands HX files between these

00:17:02,199 --> 00:17:08,980
two this defines the auto-generated code

00:17:06,250 --> 00:17:12,819
that qmu creates for marshalling of the

00:17:08,980 --> 00:17:16,750
data and also where that points to the

00:17:12,819 --> 00:17:18,669
QEP handler functionality then you have

00:17:16,750 --> 00:17:22,120
your key MV command handler which is in

00:17:18,669 --> 00:17:24,419
block dev dot C this is the first piece

00:17:22,120 --> 00:17:27,100
of code that you actually write that

00:17:24,419 --> 00:17:31,080
handles to the actual qmp command that

00:17:27,100 --> 00:17:31,080
comes from lipford or whoever

00:17:31,169 --> 00:17:36,659
and then you have the actual co routine

00:17:32,820 --> 00:17:41,389
itself for instance block stream see is

00:17:36,659 --> 00:17:44,129
the streaming co routine and there are

00:17:41,389 --> 00:17:46,049
some rules need to follow for the co

00:17:44,129 --> 00:17:47,970
routine to make sure you play well since

00:17:46,049 --> 00:17:50,820
it is a cooperative multitasking you

00:17:47,970 --> 00:17:54,239
don't want to hog the entire system part

00:17:50,820 --> 00:17:55,710
entire team you thread there and then I

00:17:54,239 --> 00:17:57,480
need to stretch a schedule your job

00:17:55,710 --> 00:18:01,769
completion and clean up to run in the

00:17:57,480 --> 00:18:06,799
correct I yo context so if we look at a

00:18:01,769 --> 00:18:09,210
sample block job i wrote a block null

00:18:06,799 --> 00:18:11,100
blocked off driver for this presentation

00:18:09,210 --> 00:18:12,509
and I've got some snippets of it on here

00:18:11,100 --> 00:18:15,149
then a link to where you can see it on

00:18:12,509 --> 00:18:17,279
github but all it is it's a it's a

00:18:15,149 --> 00:18:18,809
simple block job that just goes through

00:18:17,279 --> 00:18:22,679
and reads all the sectors and the block

00:18:18,809 --> 00:18:26,759
device chain and just does nothing with

00:18:22,679 --> 00:18:29,279
it but the idea is to have a block job

00:18:26,759 --> 00:18:31,529
with all the as much complexity stripped

00:18:29,279 --> 00:18:34,080
out as possible so that you can and see

00:18:31,529 --> 00:18:41,669
where it goes the codes available on on

00:18:34,080 --> 00:18:45,299
get here on my get server and else will

00:18:41,669 --> 00:18:49,080
have some snippets throughout here but

00:18:45,299 --> 00:18:50,999
for the QP command definition this is

00:18:49,080 --> 00:18:54,859
what it looks like so you have a block

00:18:50,999 --> 00:18:58,529
job type in the end a queue API block or

00:18:54,859 --> 00:19:02,129
JSON file so it just added this null

00:18:58,529 --> 00:19:06,419
command right here for our new null job

00:19:02,129 --> 00:19:09,749
and then we have our block null command

00:19:06,419 --> 00:19:12,509
definition in that same file so those

00:19:09,749 --> 00:19:15,029
are 4th implement a new block job those

00:19:12,509 --> 00:19:18,809
are the only two items for this case

00:19:15,029 --> 00:19:21,450
that needed to be added in here's qmp

00:19:18,809 --> 00:19:24,419
handler i won't i won't dwell on this

00:19:21,450 --> 00:19:27,090
screen that much because we're running

00:19:24,419 --> 00:19:28,619
short on time and we it's a lot of code

00:19:27,090 --> 00:19:30,869
to just kind of stare out at the screen

00:19:28,619 --> 00:19:32,730
but basically all it really does is

00:19:30,869 --> 00:19:34,889
going through this parsing argument from

00:19:32,730 --> 00:19:37,559
the qmp command it's doing some

00:19:34,889 --> 00:19:40,259
validation and then down here we

00:19:37,559 --> 00:19:42,499
actually initiate our co routine right

00:19:40,259 --> 00:19:42,499
there

00:19:42,730 --> 00:19:48,909
and a block job co routine I didn't put

00:19:46,580 --> 00:19:51,320
the function up here because it's rather

00:19:48,909 --> 00:19:53,210
long it's not necessarily complex but

00:19:51,320 --> 00:19:57,740
there's more code and would really fit

00:19:53,210 --> 00:19:59,150
on the just one or two slides so but the

00:19:57,740 --> 00:20:00,770
idea is you have a co-working loop you

00:19:59,150 --> 00:20:04,400
know it's probably a while or a for loop

00:20:00,770 --> 00:20:09,230
or something like that it needs to yield

00:20:04,400 --> 00:20:11,990
and slide they're using generally block

00:20:09,230 --> 00:20:14,630
job sleep as I mentioned before block

00:20:11,990 --> 00:20:16,549
jobs have a speed parameter that are

00:20:14,630 --> 00:20:23,840
passed to it that's a maximum speed it

00:20:16,549 --> 00:20:27,860
kind of for throttling in the sleep time

00:20:23,840 --> 00:20:30,409
that you will yield inside of the

00:20:27,860 --> 00:20:32,779
blocked up will be calculated and

00:20:30,409 --> 00:20:34,970
derived from that prowled speed that's

00:20:32,779 --> 00:20:36,440
that's passed and there's some functions

00:20:34,970 --> 00:20:40,460
to help you calculate that so you can

00:20:36,440 --> 00:20:41,870
just pass that in and of course inside

00:20:40,460 --> 00:20:43,460
your coding you're going to form all the

00:20:41,870 --> 00:20:48,549
i/o you need to do you know read or

00:20:43,460 --> 00:20:51,980
write or even some chain manipulation

00:20:48,549 --> 00:20:54,080
and you can see if this is just a link

00:20:51,980 --> 00:20:56,090
for a route you know if you're looking

00:20:54,080 --> 00:20:57,559
at the slides in line you guys click

00:20:56,090 --> 00:21:03,200
that and I'll show you the whole see

00:20:57,559 --> 00:21:07,130
file for the job and all block job so

00:21:03,200 --> 00:21:09,620
block jobs also have events we have

00:21:07,130 --> 00:21:12,070
block job completed block job cancelled

00:21:09,620 --> 00:21:16,490
block job error and block job ready

00:21:12,070 --> 00:21:19,549
these events are sent from Q mu over

00:21:16,490 --> 00:21:23,210
rtmp and a management software like

00:21:19,549 --> 00:21:26,409
liver oil parties to determine what to

00:21:23,210 --> 00:21:28,789
do or two to see if and says they happen

00:21:26,409 --> 00:21:31,279
they're pretty self-explanatory except

00:21:28,789 --> 00:21:32,600
maybe the last one blocked up completed

00:21:31,279 --> 00:21:34,159
mean to block jobs been completed

00:21:32,600 --> 00:21:36,230
canceled means it's cancelled error

00:21:34,159 --> 00:21:41,720
means there's an error block job-ready

00:21:36,230 --> 00:21:44,029
is emitted for some block jobs where we

00:21:41,720 --> 00:21:47,299
may do some initial setup there might be

00:21:44,029 --> 00:21:50,700
some operations that run before we kick

00:21:47,299 --> 00:21:53,410
off the entire block job so

00:21:50,700 --> 00:21:55,900
Kim you will emit block job ready and

00:21:53,410 --> 00:21:59,490
then the management software will come

00:21:55,900 --> 00:22:02,230
back with a command to initiate and

00:21:59,490 --> 00:22:06,340
complete the block job somewhat

00:22:02,230 --> 00:22:09,310
confusingly it cute the command is

00:22:06,340 --> 00:22:12,160
blocked job complete which is easy to

00:22:09,310 --> 00:22:15,520
confuse with block job complete hood but

00:22:12,160 --> 00:22:17,770
liver will send block job complete to

00:22:15,520 --> 00:22:20,560
initiate the completion of the block job

00:22:17,770 --> 00:22:22,180
bear our active committer are a couple

00:22:20,560 --> 00:22:23,560
examples of ones that would use the

00:22:22,180 --> 00:22:27,550
block job ready and the block job

00:22:23,560 --> 00:22:29,590
complete kind of handshake there so if

00:22:27,550 --> 00:22:34,630
we look at the block job control there

00:22:29,590 --> 00:22:37,800
are some API functions to find B send

00:22:34,630 --> 00:22:40,720
over qmp to control block jobs we can

00:22:37,800 --> 00:22:43,690
set the block job speed set the maximum

00:22:40,720 --> 00:22:46,030
speed of the block job we can cancel the

00:22:43,690 --> 00:22:49,540
block job that will cause block job

00:22:46,030 --> 00:22:53,530
canceled to be emitted we can pause the

00:22:49,540 --> 00:22:56,230
block job we can resume it and then the

00:22:53,530 --> 00:22:57,880
block job complete as the block job

00:22:56,230 --> 00:23:00,130
control command that I mentioned that

00:22:57,880 --> 00:23:01,870
you would send after receiving it block

00:23:00,130 --> 00:23:05,680
to up ready if you are the management

00:23:01,870 --> 00:23:12,480
software or the human writing JSON to

00:23:05,680 --> 00:23:12,480
the TMP that's it you have any questions

00:23:15,830 --> 00:23:22,490
maybe translate but question is a word

00:23:19,100 --> 00:23:26,149
space will require in order to perform a

00:23:22,490 --> 00:23:28,669
blob chock-a-block job can it for

00:23:26,149 --> 00:23:32,120
example if I have a base image of one

00:23:28,669 --> 00:23:35,120
terabyte and active image with one

00:23:32,120 --> 00:23:38,179
terabyte which I do not cover each other

00:23:35,120 --> 00:23:41,179
how much a space i will need to perform

00:23:38,179 --> 00:23:44,210
this job 3 gigabytes or something karate

00:23:41,179 --> 00:23:45,529
too I'm not sure I caught all the

00:23:44,210 --> 00:23:54,139
questions are you wondering if you have

00:23:45,529 --> 00:24:00,169
I would like to tram get active active

00:23:54,139 --> 00:24:04,340
Delta a in progress of commit to

00:24:00,169 --> 00:24:06,559
avoid disk space were stationed ok so so

00:24:04,340 --> 00:24:12,529
you have a block job that you're running

00:24:06,559 --> 00:24:15,169
and you want to truncate that to make I

00:24:12,529 --> 00:24:19,389
would like to keep a large space apart

00:24:15,169 --> 00:24:22,399
by both images around two terabytes I

00:24:19,389 --> 00:24:26,299
don't want to have free throw but it's a

00:24:22,399 --> 00:24:29,389
problem in real life right ok so in that

00:24:26,299 --> 00:24:31,490
case if you're trying to restrain the

00:24:29,389 --> 00:24:35,210
image size when you're doing the block

00:24:31,490 --> 00:24:38,960
MIT some of that's going to depend on

00:24:35,210 --> 00:24:41,240
the image file specification that the

00:24:38,960 --> 00:24:47,120
drive you know whether it's Q Cal to or

00:24:41,240 --> 00:24:48,260
some oral raw image file but some of

00:24:47,120 --> 00:24:50,510
that calculation will have to be done by

00:24:48,260 --> 00:24:52,850
the management software and not a space

00:24:50,510 --> 00:24:58,399
that's free because we don't have any

00:24:52,850 --> 00:25:00,080
way to when we're when we're doing to

00:24:58,399 --> 00:25:02,090
block admit we're going to commit all

00:25:00,080 --> 00:25:04,760
the clusters and sectors that need to be

00:25:02,090 --> 00:25:06,649
written down in there and we're not

00:25:04,760 --> 00:25:09,610
going to stop to commit at some point

00:25:06,649 --> 00:25:12,950
even if we're if we're running out room

00:25:09,610 --> 00:25:18,649
does that make sense yes it should

00:25:12,950 --> 00:25:20,179
truncate active image during the

00:25:18,649 --> 00:25:23,179
progress for example they are driven

00:25:20,179 --> 00:25:25,549
something like recent polls show when

00:25:23,179 --> 00:25:29,059
the commit stood watch us megabytes of

00:25:25,549 --> 00:25:30,050
data gets blood CAC megabytes right from

00:25:29,059 --> 00:25:33,820
dau tranh

00:25:30,050 --> 00:25:38,840
he gets to the word suicide megabytes

00:25:33,820 --> 00:25:41,120
128 sorry but I get 128 megabytes right

00:25:38,840 --> 00:25:43,310
home down drunk eat and something like

00:25:41,120 --> 00:25:46,340
wet what if we want to make this part

00:25:43,310 --> 00:25:51,200
yet what remains faithful yes yes yes

00:25:46,340 --> 00:25:55,370
yes yeah this is exactly what customers

00:25:51,200 --> 00:25:56,870
expects from Elgin right that's it so

00:25:55,370 --> 00:25:58,550
essentially what we want to do is in the

00:25:56,870 --> 00:26:00,620
in the active later when you're doing to

00:25:58,550 --> 00:26:04,070
commit down we want to clear out on you

00:26:00,620 --> 00:26:07,400
suckers and 0 those out inside the

00:26:04,070 --> 00:26:14,420
format so yeah that that's something we

00:26:07,400 --> 00:26:18,100
need to do yeah I am you mentioned block

00:26:14,420 --> 00:26:20,570
stream for intermediate block streaming

00:26:18,100 --> 00:26:23,420
you mentioned intermediate block

00:26:20,570 --> 00:26:25,280
streaming yes is there a specific use

00:26:23,420 --> 00:26:28,340
case for that or is is it to maintain

00:26:25,280 --> 00:26:29,780
symmetry between block stream and block

00:26:28,340 --> 00:26:31,100
comment because block comet allows you

00:26:29,780 --> 00:26:35,630
to commit into any of the intermediate

00:26:31,100 --> 00:26:39,380
images I don't know yeah I'll you said

00:26:35,630 --> 00:26:42,170
yeah dancer that I guess yeah these are

00:26:39,380 --> 00:26:44,450
patches if I can find it there from

00:26:42,170 --> 00:26:47,690
Alberto so I'm assuming that these are

00:26:44,450 --> 00:26:53,300
driven by some in use case not just

00:26:47,690 --> 00:26:54,830
feature parity but yeah it would I don't

00:26:53,300 --> 00:27:00,220
know two adult from a driving factor of

00:26:54,830 --> 00:27:00,220
it yeah

00:27:02,670 --> 00:27:08,430
right yeah yeah yeah

00:27:11,240 --> 00:27:15,340

YouTube URL: https://www.youtube.com/watch?v=XUSESxMgBdM


