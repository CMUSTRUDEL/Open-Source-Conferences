Title: [2015] ARM: Caches that give you enough rope to shoot yourself in the foot by Marc Zyngier
Publication date: 2015-08-27
Playlist: KVM Forum 2015
Description: 
	The ARM architecture allows for a wide variety of cache configurations, levels and features. This enables building systems that will optimally fit power/area budgets set for the target application. A consequence of this is that architecturally compliant software has to cater for a much wider range of behaviours. Enter virtualization and nested page tables, KVM and QEMU, IO coherency (or lack thereof), legacy code, and what you thought you understood of the above becomes even more mind boggling. This presentation will give an overview of how caches behave in the ARM architecture, especially in the context of virtualization. It will discuss various challenges that we have seen with KVM and how they have been solved. It will also outline some of the areas where previous assumptions made by the entire KVM software stack break down on architectures that do not mandate full coherency.

Marc Zyngier
Kernel hacker, ARM

Marc Zyngier has been toying with the Linux kernel since 1993, and has been involved over time with the RAID subsystem (MD) and all kinds of obsolete architectures (by maintaining the EISA bus). He also messed with consumer electronics, and now focuses on the ARM architecture by co-maintaining KVM on ARM(64).
Captions: 
	00:00:20,029 --> 00:00:26,279
good morning everyone I'm marks aren't

00:00:23,039 --> 00:00:30,150
you I'm with um so for those who don't

00:00:26,279 --> 00:00:36,090
know me I maintain kvm with Christopher

00:00:30,150 --> 00:00:38,399
doll hip post office in De Niro and for

00:00:36,090 --> 00:00:43,640
those who do know me yes I've got my

00:00:38,399 --> 00:00:47,820
hair can we get on with it so this

00:00:43,640 --> 00:00:54,690
presentation is the result of this

00:00:47,820 --> 00:00:57,539
exchange back in February which made me

00:00:54,690 --> 00:01:00,559
think do we have a technical issue or do

00:00:57,539 --> 00:01:04,439
we actually have a deep misunderstanding

00:01:00,559 --> 00:01:09,270
understanding of what caches are as the

00:01:04,439 --> 00:01:12,119
kvm am lost in translation so this is

00:01:09,270 --> 00:01:14,310
going to be a fairly short presentation

00:01:12,119 --> 00:01:18,659
it's not there's not a whole lot of

00:01:14,310 --> 00:01:20,250
slides there's I want I want to keep it

00:01:18,659 --> 00:01:22,080
as interactive as possible so if you

00:01:20,250 --> 00:01:24,479
have questions at any point please

00:01:22,080 --> 00:01:27,810
interrupt me there's a microphone in the

00:01:24,479 --> 00:01:30,990
middle of the room and yes it's all

00:01:27,810 --> 00:01:32,790
about caches what does our mothers in

00:01:30,990 --> 00:01:36,420
terms of cash is how they built

00:01:32,790 --> 00:01:40,860
architected how visible are they

00:01:36,420 --> 00:01:43,350
software or how invisible do what do we

00:01:40,860 --> 00:01:46,579
need to do with them when we do more or

00:01:43,350 --> 00:01:49,350
less nasty things a couple of example

00:01:46,579 --> 00:01:57,170
being the local Frenchman I'm going to

00:01:49,350 --> 00:02:01,829
rent a lot and how can we get on with it

00:01:57,170 --> 00:02:05,939
so common misconception about arm this

00:02:01,829 --> 00:02:08,240
is not cache coherent yeah right this is

00:02:05,939 --> 00:02:10,890
obviously wrong

00:02:08,240 --> 00:02:14,790
so armed user is very much a cache

00:02:10,890 --> 00:02:18,870
coherent architecture scales from single

00:02:14,790 --> 00:02:21,290
CPU to relatively massive SMP system you

00:02:18,870 --> 00:02:24,630
can you know almost easily find a

00:02:21,290 --> 00:02:28,800
production system with about 100 calls

00:02:24,630 --> 00:02:32,490
on it with two sockets and the funny

00:02:28,800 --> 00:02:34,950
thing is cash this can be entirely

00:02:32,490 --> 00:02:37,050
visible to software and totally

00:02:34,950 --> 00:02:39,540
invisible to software or any point

00:02:37,050 --> 00:02:42,810
between the two and it is whoever

00:02:39,540 --> 00:02:45,360
actually does the implementation to

00:02:42,810 --> 00:02:48,510
decide which level of visibility

00:02:45,360 --> 00:02:51,680
software is going to have the good news

00:02:48,510 --> 00:02:55,740
is the architecture gives us exactly the

00:02:51,680 --> 00:02:58,640
right level of abstraction to do the

00:02:55,740 --> 00:03:01,680
right thing also why do we have these

00:02:58,640 --> 00:03:05,490
differences well it all comes from the

00:03:01,680 --> 00:03:09,240
fact that the architecture gives you a

00:03:05,490 --> 00:03:12,090
way to create really really small power

00:03:09,240 --> 00:03:14,070
efficient cause we're basically not

00:03:12,090 --> 00:03:15,420
going to have a lot of gates and

00:03:14,070 --> 00:03:19,230
software is going to be a bit more

00:03:15,420 --> 00:03:22,380
involved or something that is much

00:03:19,230 --> 00:03:26,250
larger well yeah you can expand it

00:03:22,380 --> 00:03:28,200
another few million gates to do a cache

00:03:26,250 --> 00:03:33,269
coherency in a completely transparent

00:03:28,200 --> 00:03:37,320
way but that's fine gives you a way to

00:03:33,269 --> 00:03:42,410
run a vm on your SmartWatch yes there's

00:03:37,320 --> 00:03:45,830
some Samsung based SmartWatch with a

00:03:42,410 --> 00:03:48,840
dual cortex a7 yet can run a vm on that

00:03:45,830 --> 00:03:51,000
and you can run the same vm on a rather

00:03:48,840 --> 00:03:54,510
expensive piece of hardware in your data

00:03:51,000 --> 00:03:57,420
center so the object was redesigned for

00:03:54,510 --> 00:04:02,760
to give you as much flexibility in

00:03:57,420 --> 00:04:06,390
hardware so the architecture itself is

00:04:02,760 --> 00:04:08,670
not really innovative in any way it sits

00:04:06,390 --> 00:04:13,730
a little eek white boring you have

00:04:08,670 --> 00:04:16,440
multiple levels of caching you can snoop

00:04:13,730 --> 00:04:19,590
across the different levels we have

00:04:16,440 --> 00:04:21,090
separate int caches no snooping between

00:04:19,590 --> 00:04:23,990
the two

00:04:21,090 --> 00:04:28,010
it's fairly standard on the wrist system

00:04:23,990 --> 00:04:31,169
the cash is either p ipt or non aliasing

00:04:28,010 --> 00:04:32,790
VIP g for the d-side so that's basically

00:04:31,169 --> 00:04:34,919
the same thing as far as software's

00:04:32,790 --> 00:04:38,340
concern it's only year all the hard work

00:04:34,919 --> 00:04:41,190
i saw that out and they meet at what we

00:04:38,340 --> 00:04:43,949
call the point of unification which is

00:04:41,190 --> 00:04:46,190
usually yell too but again that's

00:04:43,949 --> 00:04:52,110
defined by the architecture and you can

00:04:46,190 --> 00:04:53,639
probe that very easily and so the cash

00:04:52,110 --> 00:04:55,680
policies are controlled by attributes in

00:04:53,639 --> 00:04:57,540
the page table so the type of the memory

00:04:55,680 --> 00:04:59,700
whether it's normal memory or device

00:04:57,540 --> 00:05:03,570
memory gives you things like cash

00:04:59,700 --> 00:05:06,150
ability shareability this is otherwise

00:05:03,570 --> 00:05:07,770
controlled by to enable bits I for the

00:05:06,150 --> 00:05:13,919
instruction see for the data I

00:05:07,770 --> 00:05:17,280
convenient and uh yeah there are not

00:05:13,919 --> 00:05:19,979
really enabled bits and despite for the

00:05:17,280 --> 00:05:22,080
name says there are more like global

00:05:19,979 --> 00:05:25,350
override it's been the caches are still

00:05:22,080 --> 00:05:27,740
alive despite the DNA was being off well

00:05:25,350 --> 00:05:30,389
going to see that I can have some effect

00:05:27,740 --> 00:05:32,700
they are generally invisible to software

00:05:30,389 --> 00:05:38,940
while to normal software there's a few

00:05:32,700 --> 00:05:42,450
key exceptions so how do we interact

00:05:38,940 --> 00:05:45,210
with them what's not really surprising

00:05:42,450 --> 00:05:49,260
we have a standard thing invalidates

00:05:45,210 --> 00:05:52,139
clean cleaning and validate we can do

00:05:49,260 --> 00:05:54,090
cash maintenance by virtual address so

00:05:52,139 --> 00:05:56,070
it's really virtual address I mean you

00:05:54,090 --> 00:05:57,960
need to have an existing mapping if you

00:05:56,070 --> 00:06:00,539
don't have the mapping for the address

00:05:57,960 --> 00:06:03,240
you're trying to validate yeah get an

00:06:00,539 --> 00:06:06,060
exception and we have cash mountains by

00:06:03,240 --> 00:06:09,539
set way so it's ever be familiar with

00:06:06,060 --> 00:06:12,930
what cash maintenance by set ways no

00:06:09,539 --> 00:06:15,060
okay so basically it's really exposing

00:06:12,930 --> 00:06:18,990
the Geo Metro of your caches so you have

00:06:15,060 --> 00:06:21,570
never of ways and above sex and you are

00:06:18,990 --> 00:06:26,720
going really too for example clean one

00:06:21,570 --> 00:06:30,990
we're at a time can be quite large but

00:06:26,720 --> 00:06:34,380
it has an number of firm of issues so

00:06:30,990 --> 00:06:36,810
set way operations are local to a cpu

00:06:34,380 --> 00:06:40,770
so if you are if you are in a coherent

00:06:36,810 --> 00:06:43,830
system with more than one cpu you start

00:06:40,770 --> 00:06:46,260
in validating locally well tough you

00:06:43,830 --> 00:06:49,550
lose you're going to break the

00:06:46,260 --> 00:06:52,950
consistency across the your several CPUs

00:06:49,550 --> 00:06:55,830
that's really bad we don't have an

00:06:52,950 --> 00:06:58,560
operation on the d-side we have that on

00:06:55,830 --> 00:07:01,950
the I side not on the d-side so the only

00:06:58,560 --> 00:07:03,750
way you can do an all operation so clean

00:07:01,950 --> 00:07:07,040
all invalidate all is to iterate over

00:07:03,750 --> 00:07:10,490
sideways again you can only do that if

00:07:07,040 --> 00:07:13,640
you only have one cpu running

00:07:10,490 --> 00:07:19,050
effectively you have to restrict that to

00:07:13,640 --> 00:07:23,040
bring up and shut down a cpu even more

00:07:19,050 --> 00:07:26,550
fun not all the levels have to implement

00:07:23,040 --> 00:07:29,910
set of operations so if we go back by

00:07:26,550 --> 00:07:31,860
one slide for example here it's very

00:07:29,910 --> 00:07:34,950
likely that L 3 which is system cache

00:07:31,860 --> 00:07:38,040
won't implement set cooperations which

00:07:34,950 --> 00:07:42,210
means that if you do you try to clean

00:07:38,040 --> 00:07:45,150
everything from the top towards the

00:07:42,210 --> 00:07:46,980
bottom of the of the disk ematic you're

00:07:45,150 --> 00:07:49,830
going to flush everything up to our two

00:07:46,980 --> 00:07:52,920
down two or three but you won't be able

00:07:49,830 --> 00:07:54,870
to flush l3 by that way it will just

00:07:52,920 --> 00:07:59,250
stay there going to see it can be

00:07:54,870 --> 00:08:01,740
annoying this system cache is only know

00:07:59,250 --> 00:08:04,140
about da basically also set to

00:08:01,740 --> 00:08:06,660
operations are simply impossible to

00:08:04,140 --> 00:08:08,970
virtualize you can have you can be

00:08:06,660 --> 00:08:12,120
scheduled out while doing a set of

00:08:08,970 --> 00:08:14,250
operation it's just a nightmare so if

00:08:12,120 --> 00:08:18,450
you are writing arm code at any point in

00:08:14,250 --> 00:08:21,660
your life and if you think of using set

00:08:18,450 --> 00:08:22,950
to operation think twice it's likely

00:08:21,660 --> 00:08:25,140
that what you're trying to do is the

00:08:22,950 --> 00:08:26,910
wrong thing to do unless you're doing

00:08:25,140 --> 00:08:34,890
some really early bring up bring down

00:08:26,910 --> 00:08:37,950
coat so think VA so yeah caches can be

00:08:34,890 --> 00:08:43,500
visible to software and some limited

00:08:37,950 --> 00:08:47,430
cases if you're loading code you know VI

00:08:43,500 --> 00:08:48,620
your data cache or generating code with

00:08:47,430 --> 00:08:52,940
a jit

00:08:48,620 --> 00:08:56,850
why you have the usual data clean

00:08:52,940 --> 00:08:58,350
instruction invalidate which own arm VA

00:08:56,850 --> 00:09:03,839
it is possible directly from user space

00:08:58,350 --> 00:09:04,950
on all the v7 cause 32bit basically you

00:09:03,839 --> 00:09:06,330
need a system tool for that it's a

00:09:04,950 --> 00:09:09,720
privilege operation conduit from user

00:09:06,330 --> 00:09:12,270
space if you're doing DMA with non-cash

00:09:09,720 --> 00:09:14,250
Gurion devices to fairly well known

00:09:12,270 --> 00:09:17,610
problem in Linux we have the DMA API for

00:09:14,250 --> 00:09:19,620
that you do clean invalidate or both

00:09:17,610 --> 00:09:22,980
depending on the direction of the

00:09:19,620 --> 00:09:25,890
transfer more surprising if you're doing

00:09:22,980 --> 00:09:29,670
if you have a cache coherent DMA but

00:09:25,890 --> 00:09:31,440
your caches are off all you need to do

00:09:29,670 --> 00:09:37,260
the same thing because your cache

00:09:31,440 --> 00:09:41,279
coherent are you is going to read or

00:09:37,260 --> 00:09:43,709
write from or to the caches while your

00:09:41,279 --> 00:09:47,520
CPU is going to go directly to run that

00:09:43,709 --> 00:09:48,959
could also be problematic if you have

00:09:47,520 --> 00:09:51,089
things like conflicting memory

00:09:48,959 --> 00:09:53,459
attributes you know writing to an

00:09:51,089 --> 00:09:55,470
uncatchable mapping and trying to write

00:09:53,459 --> 00:09:58,230
from a casual mapping so getting the

00:09:55,470 --> 00:10:02,010
same physical page that's not going to

00:09:58,230 --> 00:10:05,370
work very well and as we're going to see

00:10:02,010 --> 00:10:10,079
it's actually a fairly common case with

00:10:05,370 --> 00:10:12,750
virtualization so stage 2 translation so

00:10:10,079 --> 00:10:16,050
we're definitely in virtualization land

00:10:12,750 --> 00:10:18,870
now so stay tuned translation is

00:10:16,050 --> 00:10:22,470
basically your nested vegetables EPT on

00:10:18,870 --> 00:10:25,380
x86 now they give you a second stage of

00:10:22,470 --> 00:10:28,500
memory attributes and kvm always

00:10:25,380 --> 00:10:32,610
configure the RAM as cacheable at stage

00:10:28,500 --> 00:10:34,320
two of course the guest has its own page

00:10:32,610 --> 00:10:37,950
tables and memory attributes and that

00:10:34,320 --> 00:10:40,260
gets combined into a single set of

00:10:37,950 --> 00:10:43,589
attributes are going to be used to

00:10:40,260 --> 00:10:46,250
access whatever memory or device so the

00:10:43,589 --> 00:10:48,660
strongest memory type with if you have

00:10:46,250 --> 00:10:50,640
one of the two level that says device

00:10:48,660 --> 00:10:56,240
device and the other says normal memory

00:10:50,640 --> 00:10:59,800
it will be device if you have

00:10:56,240 --> 00:11:04,510
conflicting attributes when it comes to

00:10:59,800 --> 00:11:07,870
cash ability the just-released cacheable

00:11:04,510 --> 00:11:10,240
always great though if you host says oh

00:11:07,870 --> 00:11:12,970
this is going to be catchable normal

00:11:10,240 --> 00:11:17,079
memory but your guess as non cashable

00:11:12,970 --> 00:11:18,459
well this will be non casual the

00:11:17,079 --> 00:11:22,089
hypervisor doesn't have much control

00:11:18,459 --> 00:11:24,190
over that it'sit's there's some global

00:11:22,089 --> 00:11:27,550
over right but that's really like

00:11:24,190 --> 00:11:30,610
massive hammer for or something that

00:11:27,550 --> 00:11:35,079
shouldn't require that and yeah it gets

00:11:30,610 --> 00:11:39,490
more complicated so let's take a very

00:11:35,079 --> 00:11:42,730
small example of actual case we fixed a

00:11:39,490 --> 00:11:48,160
few months ago let's say you boot a

00:11:42,730 --> 00:11:51,760
32-bit guest on a fairly sizable 64-bit

00:11:48,160 --> 00:11:54,490
host that has an l3 cache and dalvik

00:11:51,760 --> 00:11:57,370
cache is a system castle remember no

00:11:54,490 --> 00:12:01,570
cetera operations can reach that that

00:11:57,370 --> 00:12:03,670
system cache so the the 32-bit kernel is

00:12:01,570 --> 00:12:07,390
a compressed image without an embedded

00:12:03,670 --> 00:12:09,790
the compressor it's quite funny so you

00:12:07,390 --> 00:12:11,709
know that you jump to it or fine well

00:12:09,790 --> 00:12:15,130
the compressor enables the caches

00:12:11,709 --> 00:12:18,010
decompresses the image but I turns the

00:12:15,130 --> 00:12:21,250
caches off and does a set to operation

00:12:18,010 --> 00:12:25,120
to make sure oh this this is going to be

00:12:21,250 --> 00:12:29,170
in RAM it's all fine and then jumps to

00:12:25,120 --> 00:12:32,170
the payload yeah it's a bad it's really

00:12:29,170 --> 00:12:35,230
bad so what happens here is you've

00:12:32,170 --> 00:12:37,750
cleaned by set way if you see the first

00:12:35,230 --> 00:12:41,589
arrow on the right if cream by set where

00:12:37,750 --> 00:12:42,940
to l-3 or good is that but as your

00:12:41,589 --> 00:12:46,180
caches are off when you're going to

00:12:42,940 --> 00:12:49,540
fetch from memory you are going to fetch

00:12:46,180 --> 00:12:51,790
from Ram yeah it's very unlikely that

00:12:49,540 --> 00:12:54,339
you are actually going to read what

00:12:51,790 --> 00:12:59,110
you've written that's because you've

00:12:54,339 --> 00:13:03,430
frozen by set way stops really at l3 in

00:12:59,110 --> 00:13:05,860
that case your system caches are not are

00:13:03,430 --> 00:13:09,959
not capable of exposing their actual

00:13:05,860 --> 00:13:12,570
geometry so yeah that that doesn't work

00:13:09,959 --> 00:13:15,870
so the solution for that

00:13:12,570 --> 00:13:20,040
is to trap the set to operations and

00:13:15,870 --> 00:13:22,410
actually replace them by a VA operation

00:13:20,040 --> 00:13:25,680
that will have to iterate over the whole

00:13:22,410 --> 00:13:28,020
of the mapped memory space of the guests

00:13:25,680 --> 00:13:30,450
so it's probably a good thing that is

00:13:28,020 --> 00:13:33,900
done fairly early a good time so we

00:13:30,450 --> 00:13:35,940
don't have that many pages mapped so

00:13:33,900 --> 00:13:38,820
it's not too bad but yeah it's good that

00:13:35,940 --> 00:13:44,510
it only happens at good time horrible

00:13:38,820 --> 00:13:47,940
thing yep so why is just the

00:13:44,510 --> 00:13:52,290
decompressor Ronnie the 13 guests yeah

00:13:47,940 --> 00:13:57,120
we were to run that would it be correct

00:13:52,290 --> 00:13:59,670
because yep hey it wouldn't be correct

00:13:57,120 --> 00:14:01,650
either it's an interesting case where

00:13:59,670 --> 00:14:03,420
the decompressor has been written for a

00:14:01,650 --> 00:14:06,480
very very very old version of the

00:14:03,420 --> 00:14:08,930
architecture and we're at the time where

00:14:06,480 --> 00:14:11,550
system cache is simply didn't exist and

00:14:08,930 --> 00:14:13,710
yeah basically this touched a bit code

00:14:11,550 --> 00:14:16,860
is stuck with that so if you have if you

00:14:13,710 --> 00:14:21,050
want to write the decompressor to deal

00:14:16,860 --> 00:14:21,050
with via operations please be my guest

00:14:24,240 --> 00:14:32,620
yes yes so on if you if you have a

00:14:28,680 --> 00:14:35,110
embedded type system either you don't

00:14:32,620 --> 00:14:38,340
have an l2 or l3 cache the system cache

00:14:35,110 --> 00:14:43,420
or you have one that is small enough so

00:14:38,340 --> 00:14:45,130
that you don't see the problem yeah in

00:14:43,420 --> 00:14:50,260
this case we had something like an

00:14:45,130 --> 00:14:53,880
innate Meg l3 which just contains the

00:14:50,260 --> 00:14:53,880
whole guest code yeah

00:15:00,420 --> 00:15:04,380
so just to add to that if you've got an

00:15:02,370 --> 00:15:05,820
external cash on a 32-bit system it's

00:15:04,380 --> 00:15:08,220
probably gonna be saying like the cortex

00:15:05,820 --> 00:15:10,920
a9 with the PL 310 external cash which

00:15:08,220 --> 00:15:12,540
will be off and the 32 bit kernel knows

00:15:10,920 --> 00:15:15,510
how to manage that directly but for

00:15:12,540 --> 00:15:18,420
performance reasons on newer cause the

00:15:15,510 --> 00:15:19,920
external cash doesn't require explicit

00:15:18,420 --> 00:15:23,370
management because it responds to VA

00:15:19,920 --> 00:15:25,230
operations but it means it on by default

00:15:23,370 --> 00:15:33,269
which is where the whole problem comes

00:15:25,230 --> 00:15:37,649
from yeah thanks so yeah not very nice a

00:15:33,269 --> 00:15:39,870
slightly more annoying one which could

00:15:37,649 --> 00:15:42,870
take a look a lot more time to debug so

00:15:39,870 --> 00:15:45,149
imagine you have a vm running on a on a

00:15:42,870 --> 00:15:48,240
rather busy host that is actually

00:15:45,149 --> 00:15:50,370
starting to swap out but off thanks and

00:15:48,240 --> 00:15:53,010
you have a cache coherence are your

00:15:50,370 --> 00:15:56,670
subsystem which actually snoops into

00:15:53,010 --> 00:15:58,709
your caches remember we so the guest has

00:15:56,670 --> 00:16:02,730
its own memory attributes and we never

00:15:58,709 --> 00:16:05,250
pass its page tables it's Tracy it's

00:16:02,730 --> 00:16:08,070
time consuming basically it's it's a lot

00:16:05,250 --> 00:16:11,790
skills so we have no visibility on its

00:16:08,070 --> 00:16:14,880
on its own memory attributes and if the

00:16:11,790 --> 00:16:17,490
guest it could start to write to memory

00:16:14,880 --> 00:16:20,070
from a non cacheable mapping which is

00:16:17,490 --> 00:16:24,570
you know not impossible if you that some

00:16:20,070 --> 00:16:27,930
boot loader repetitive boot loader and

00:16:24,570 --> 00:16:31,110
if we have that while the that page is

00:16:27,930 --> 00:16:34,560
being swapped out the other Colonel

00:16:31,110 --> 00:16:36,540
linear mapping which is cacheable well

00:16:34,560 --> 00:16:40,709
things could be to become interesting as

00:16:36,540 --> 00:16:45,000
well so if you look at the dr on the

00:16:40,709 --> 00:16:47,670
left the the guest writing to some

00:16:45,000 --> 00:16:50,790
memory with its caches off that goes to

00:16:47,670 --> 00:16:56,040
ram and then we having the page we are

00:16:50,790 --> 00:16:58,649
the linear mapping to the caches but as

00:16:56,040 --> 00:17:01,019
a bad idea it's it's possible to just

00:16:58,649 --> 00:17:05,189
miss that's right that the guest has

00:17:01,019 --> 00:17:08,069
made to memory that could be very

00:17:05,189 --> 00:17:10,679
annoying so we're going to write out

00:17:08,069 --> 00:17:13,980
stale data the way we work around that

00:17:10,679 --> 00:17:17,220
is to do a clean and invalidate

00:17:13,980 --> 00:17:21,540
each time we own map a page from stage

00:17:17,220 --> 00:17:25,410
to instruct the MMU notifier calls us to

00:17:21,540 --> 00:17:27,750
say I'm at that page we make sure that

00:17:25,410 --> 00:17:31,169
page is clean and validated make sure

00:17:27,750 --> 00:17:34,350
again so that the the i/o subsystem will

00:17:31,169 --> 00:17:41,250
will missing the cash and read from

00:17:34,350 --> 00:17:43,110
right so yeah this is not the expected

00:17:41,250 --> 00:17:47,100
behavior if you're familiar with an x86

00:17:43,110 --> 00:17:51,360
system at all well again that's not too

00:17:47,100 --> 00:17:55,559
surprising not in tell the real reason

00:17:51,360 --> 00:17:58,830
is that caches are not just here to make

00:17:55,559 --> 00:18:01,770
things faster yes that's a interesting

00:17:58,830 --> 00:18:03,570
goal but that's also how we manage the

00:18:01,770 --> 00:18:06,630
whole coherency protocol between the

00:18:03,570 --> 00:18:08,580
between the CPS if you remove the caches

00:18:06,630 --> 00:18:12,059
yeah that the cost can't talk to each

00:18:08,580 --> 00:18:14,610
other at all so if you use an cache

00:18:12,059 --> 00:18:17,700
memory you are effectively bypassing all

00:18:14,610 --> 00:18:21,120
that logic which means you have in

00:18:17,700 --> 00:18:23,700
software to reproduce it or sort of

00:18:21,120 --> 00:18:28,110
emulate it that's really really no magic

00:18:23,700 --> 00:18:31,049
involved there's strict octet rule to

00:18:28,110 --> 00:18:33,809
that they're not necessarily easy to

00:18:31,049 --> 00:18:36,990
read but they are there and they are

00:18:33,809 --> 00:18:39,240
there to ensure consistency correctness

00:18:36,990 --> 00:18:41,940
across all implementation whether you

00:18:39,240 --> 00:18:44,370
have you know fully transparent caches

00:18:41,940 --> 00:18:45,929
where you're basically your cash

00:18:44,370 --> 00:18:48,809
maintenance operations are at activity

00:18:45,929 --> 00:18:51,660
knobs to something that is a lot more

00:18:48,809 --> 00:18:54,990
what software is a lot more involved you

00:18:51,660 --> 00:18:57,270
issue the same sequences and it will

00:18:54,990 --> 00:19:01,230
just do the right thing and yet as you

00:18:57,270 --> 00:19:06,150
said linux on 32-bit is not actively

00:19:01,230 --> 00:19:08,309
compliant it's not very nice yeah

00:19:06,150 --> 00:19:10,440
there's more to virtualization than the

00:19:08,309 --> 00:19:16,470
CPU and fortunately there is there is a

00:19:10,440 --> 00:19:22,620
0 and that's where I I start renting so

00:19:16,470 --> 00:19:25,470
the the top issue i receive in over the

00:19:22,620 --> 00:19:27,510
past performance may be a bit more is

00:19:25,470 --> 00:19:29,640
yeah my vga adapter from q

00:19:27,510 --> 00:19:34,410
you doesn't work with kvm oh now ah

00:19:29,640 --> 00:19:38,160
that's horrible well it's not people too

00:19:34,410 --> 00:19:39,960
surprising userspace uses caching cat

00:19:38,160 --> 00:19:45,030
cache memory you do any map you get

00:19:39,960 --> 00:19:47,790
cache memory the guest is using and I

00:19:45,030 --> 00:19:50,100
your remap usually two to have access to

00:19:47,790 --> 00:19:53,040
the vga device which is going to be

00:19:50,100 --> 00:19:56,040
uncashed a sort of there's the logic to

00:19:53,040 --> 00:19:58,550
that you never read from a friend but

00:19:56,040 --> 00:20:02,370
father you never read back from that

00:19:58,550 --> 00:20:07,770
makes no sense of course yeah who needs

00:20:02,370 --> 00:20:11,100
a friend before anyway so but it works

00:20:07,770 --> 00:20:14,340
with TCG yet but TCG for those who were

00:20:11,100 --> 00:20:16,980
in them in the multi threading talk

00:20:14,340 --> 00:20:19,440
earlier is doesn't implement anything

00:20:16,980 --> 00:20:22,140
regarding cash cashier's or basically

00:20:19,440 --> 00:20:26,670
doesn't give you an and architectural e

00:20:22,140 --> 00:20:30,270
compliant version up you can't really

00:20:26,670 --> 00:20:32,720
deal with that so something has to be

00:20:30,270 --> 00:20:39,480
done as it is it cannot work on am

00:20:32,720 --> 00:20:42,140
simply not so there's several ways to

00:20:39,480 --> 00:20:46,110
fix that so we've had all kind of

00:20:42,140 --> 00:20:50,430
interesting solutions one is to hack the

00:20:46,110 --> 00:20:54,480
guest tributes by forcing cacheable

00:20:50,430 --> 00:20:57,330
excesses so that would break stuff that

00:20:54,480 --> 00:20:59,160
actually needs and gashed access and

00:20:57,330 --> 00:21:02,540
that way there's a number of cases where

00:20:59,160 --> 00:21:06,300
doing an uncashed access is is required

00:21:02,540 --> 00:21:10,350
you could try and do some cash mountains

00:21:06,300 --> 00:21:13,020
from user space it's not very nice but

00:21:10,350 --> 00:21:16,290
why not that would require a new cisco

00:21:13,020 --> 00:21:21,590
mv7 just to do that not really fond of

00:21:16,290 --> 00:21:26,070
the idea hello in user space to do an

00:21:21,590 --> 00:21:29,700
uncashed their map okay but what if the

00:21:26,070 --> 00:21:31,470
guess maps it as as as cached we were we

00:21:29,700 --> 00:21:34,500
have the opposite problem we're not

00:21:31,470 --> 00:21:37,350
fixing it trap being every possible

00:21:34,500 --> 00:21:40,470
access yeah that would work that will

00:21:37,350 --> 00:21:42,690
work already but very quickly

00:21:40,470 --> 00:21:45,780
the only real solution is to actually

00:21:42,690 --> 00:21:49,890
tell the guests that whatever device we

00:21:45,780 --> 00:21:53,100
put there is cache coherent because that

00:21:49,890 --> 00:21:55,549
really what it is so far we are lying to

00:21:53,100 --> 00:21:58,880
the gas but I'm yeah this is a vga card

00:21:55,549 --> 00:22:01,919
has it's a device don't worry about it

00:21:58,880 --> 00:22:04,590
but really lying to it and we're relying

00:22:01,919 --> 00:22:07,289
on certain properties of a different

00:22:04,590 --> 00:22:10,020
architecture that really don't apply

00:22:07,289 --> 00:22:15,890
here I mean you can turn it upside down

00:22:10,020 --> 00:22:20,280
if you want that fact won't change so

00:22:15,890 --> 00:22:26,820
how did we end up here so vga was

00:22:20,280 --> 00:22:33,020
invented in 87 who was born in 87 ya

00:22:26,820 --> 00:22:36,330
know that many yeah my personal joke is

00:22:33,020 --> 00:22:39,419
you wouldn't plug a PDP Levendi sa

00:22:36,330 --> 00:22:41,580
controller on a xeon would you ok so why

00:22:39,419 --> 00:22:45,020
do I put a vga card in your elimination

00:22:41,580 --> 00:22:47,070
of a vga card on an arm system which is

00:22:45,020 --> 00:22:51,299
completely alien to the to the

00:22:47,070 --> 00:22:54,299
architecture also the arm VMS have

00:22:51,299 --> 00:22:57,600
absolutely absolutely no legacy at all I

00:22:54,299 --> 00:22:59,820
mean the oldest on vm in production is

00:22:57,600 --> 00:23:03,090
probably five months old not more than

00:22:59,820 --> 00:23:06,059
that and I run it but let's really

00:23:03,090 --> 00:23:08,640
really really no legacy at all so why do

00:23:06,059 --> 00:23:10,289
we have to introduce dr. guess if we

00:23:08,640 --> 00:23:13,650
don't even have a standard platform we

00:23:10,289 --> 00:23:16,080
don't even need one I understand that

00:23:13,650 --> 00:23:17,669
for next 86 is fairly standard you know

00:23:16,080 --> 00:23:20,760
it does never well-known peripheral

00:23:17,669 --> 00:23:22,200
sitting at well known addresses in the

00:23:20,760 --> 00:23:25,470
memory map we don't have that

00:23:22,200 --> 00:23:27,750
requirement on our metal and we use /

00:23:25,470 --> 00:23:30,240
virtualized devices for most things you

00:23:27,750 --> 00:23:33,419
know the console a real one the serial

00:23:30,240 --> 00:23:39,000
one we r platform is working for storage

00:23:33,419 --> 00:23:42,059
and now we have vertigo VGA and to me it

00:23:39,000 --> 00:23:45,539
looks absolutely awesome this is what we

00:23:42,059 --> 00:23:48,179
need it we can make sure it doesn't have

00:23:45,539 --> 00:23:50,190
any form of Legation and we don't have

00:23:48,179 --> 00:23:52,380
to lie about the fact that it's a

00:23:50,190 --> 00:23:54,679
virtual devices it you know it's part of

00:23:52,380 --> 00:23:54,679
the name

00:23:56,400 --> 00:24:07,060
so let's look at it who plugged that

00:24:02,350 --> 00:24:09,100
thing on my beautiful vm kayvyun doesn't

00:24:07,060 --> 00:24:11,740
care about any form of emulated devices

00:24:09,100 --> 00:24:14,680
really apart from things out directly in

00:24:11,740 --> 00:24:17,020
the kernel user space weather is cured

00:24:14,680 --> 00:24:20,980
me of kvm today they just do what they

00:24:17,020 --> 00:24:24,360
told you know so what are coming from

00:24:20,980 --> 00:24:27,030
right very likely that high level tools

00:24:24,360 --> 00:24:31,630
are completely oblivious of

00:24:27,030 --> 00:24:33,940
architectural differences and yet if all

00:24:31,630 --> 00:24:39,190
you had this libvirt absolutely

00:24:33,940 --> 00:24:43,260
everything looks like like an x86 that's

00:24:39,190 --> 00:24:46,860
a bit annoying so I would hope that

00:24:43,260 --> 00:24:49,690
someone that is familiar with levert or

00:24:46,860 --> 00:24:53,800
whatever is on top of it which I'd

00:24:49,690 --> 00:24:55,990
rather know will add some form of /

00:24:53,800 --> 00:24:58,960
architecture profile shouldn't be a big

00:24:55,990 --> 00:25:01,720
deal we shouldn't have to you know have

00:24:58,960 --> 00:25:05,200
an arm vm that is basically copy paste

00:25:01,720 --> 00:25:08,880
of an sx x86 vm with just oh yeah let's

00:25:05,200 --> 00:25:15,520
remove the x86 cpu and drop an arm there

00:25:08,880 --> 00:25:20,710
contrary work like that so back to

00:25:15,520 --> 00:25:22,830
coherency free we have different

00:25:20,710 --> 00:25:29,950
requirements really for emulated and

00:25:22,830 --> 00:25:33,190
physical devices you can't really manage

00:25:29,950 --> 00:25:35,730
them the same way they have really they

00:25:33,190 --> 00:25:38,320
really have different requirements so

00:25:35,730 --> 00:25:42,840
it's likely that firmware has a role to

00:25:38,320 --> 00:25:46,540
play in exposing the differences between

00:25:42,840 --> 00:25:49,870
the various devices and there's a

00:25:46,540 --> 00:25:53,260
specialty on armed as a juror need for

00:25:49,870 --> 00:25:56,050
topology information and we have that on

00:25:53,260 --> 00:25:58,300
bare metal we really have to describe

00:25:56,050 --> 00:26:03,100
how our things are interconnected and

00:25:58,300 --> 00:26:07,000
are coherent they are and there's no

00:26:03,100 --> 00:26:10,620
reason why vm should be an exception so

00:26:07,000 --> 00:26:14,380
when we have device tree we have ways to

00:26:10,620 --> 00:26:16,660
to specify the level of coherency so for

00:26:14,380 --> 00:26:21,340
PCI this is done on a per good complex

00:26:16,660 --> 00:26:24,940
basis so if you have two different set

00:26:21,340 --> 00:26:26,890
of devices some coherent likely to be

00:26:24,940 --> 00:26:29,980
emulated and some non-korean likely to

00:26:26,890 --> 00:26:31,840
be physical it means you may have to

00:26:29,980 --> 00:26:35,440
expose them as two different wood

00:26:31,840 --> 00:26:40,060
complexes shouldn't be a big deal q mu

00:26:35,440 --> 00:26:43,420
as enough code to deal with that when it

00:26:40,060 --> 00:26:47,950
comes to a CPI there's also attributes

00:26:43,420 --> 00:26:50,590
to expose that so CCA which is mostly

00:26:47,950 --> 00:26:54,040
supported on x86 but now has also some

00:26:50,590 --> 00:26:57,880
scanning some some support and that's

00:26:54,040 --> 00:27:01,980
the whole iort framework which is really

00:26:57,880 --> 00:27:05,320
extensively described the arm diversity

00:27:01,980 --> 00:27:07,600
when it comes to clarity and the way

00:27:05,320 --> 00:27:14,440
request your IDs three mind is all that

00:27:07,600 --> 00:27:17,650
is transformed so it's not ideal but

00:27:14,440 --> 00:27:20,320
maybe not fine grained enough at the

00:27:17,650 --> 00:27:22,210
root complex levels a bit big but it's a

00:27:20,320 --> 00:27:30,760
lot better than the current status quo

00:27:22,210 --> 00:27:34,450
we have so as a conclusion yeah kvm is

00:27:30,760 --> 00:27:37,480
is really heavy de x86 oriented not real

00:27:34,450 --> 00:27:40,540
surprising Coverly without that trouble

00:27:37,480 --> 00:27:44,440
is not all the solutions that worked on

00:27:40,540 --> 00:27:48,340
x86 make sense or now we end up with off

00:27:44,440 --> 00:27:52,270
with Frank and VMS build with bits of

00:27:48,340 --> 00:27:55,150
foreign architectures glob together we

00:27:52,270 --> 00:27:58,960
have the chance of a clean slate and I

00:27:55,150 --> 00:28:00,460
really wish we we start with that so it

00:27:58,960 --> 00:28:03,370
doesn't take much effort to fix que bien

00:28:00,460 --> 00:28:06,700
I mean the D architectural issues are

00:28:03,370 --> 00:28:10,180
outlined yeah they take a bit of effort

00:28:06,700 --> 00:28:12,550
to fix but once you get the gist of the

00:28:10,180 --> 00:28:14,800
problem you can go and look where

00:28:12,550 --> 00:28:18,000
whether we could do something slightly

00:28:14,800 --> 00:28:21,430
scary and everything is documented I i

00:28:18,000 --> 00:28:24,880
really recommend reading the vr mom so

00:28:21,430 --> 00:28:26,110
architectural reference manual if you if

00:28:24,880 --> 00:28:28,720
you feel like if you have trouble

00:28:26,110 --> 00:28:31,240
sleeping it's really really good it's

00:28:28,720 --> 00:28:33,310
amazing and it's growing yeah there's

00:28:31,240 --> 00:28:38,760
there's additional reading material and

00:28:33,310 --> 00:28:41,260
all that the joke carries on and we are

00:28:38,760 --> 00:28:42,910
you know irrespective of the

00:28:41,260 --> 00:28:47,530
architecture we have really really

00:28:42,910 --> 00:28:49,780
efficient solutions for the 22 to deal

00:28:47,530 --> 00:28:53,590
with virtualization para virtualization

00:28:49,780 --> 00:28:56,050
is really good really efficient the talk

00:28:53,590 --> 00:28:59,860
that's taking place just now at the same

00:28:56,050 --> 00:29:06,430
time is about vertical vga so you should

00:28:59,860 --> 00:29:09,490
go really and the real problems seem to

00:29:06,430 --> 00:29:12,910
be in firmware firmware seems you have

00:29:09,490 --> 00:29:17,320
grown out of x86 as well UEFI is

00:29:12,910 --> 00:29:19,810
extremely eccentric and hopefully there

00:29:17,320 --> 00:29:23,050
are ways to retreat some some

00:29:19,810 --> 00:29:27,280
parameterization support into it and the

00:29:23,050 --> 00:29:29,290
high level tools where ya live bird yeah

00:29:27,280 --> 00:29:32,950
seem to completely ignore any any other

00:29:29,290 --> 00:29:37,090
architecture so I shouldn't be hard to

00:29:32,950 --> 00:29:39,610
fix and but as a general trend I wish

00:29:37,090 --> 00:29:42,550
people wouldn't assume that next X is

00:29:39,610 --> 00:29:44,680
always the model to follow there's a lot

00:29:42,550 --> 00:29:47,410
of good things being done on the

00:29:44,680 --> 00:29:51,160
eccentric side they don't necessarily

00:29:47,410 --> 00:30:01,420
always apply to what arm that or other

00:29:51,160 --> 00:30:04,930
architecture do thank you questions yes

00:30:01,420 --> 00:30:07,870
um i'm working at red hat i just like to

00:30:04,930 --> 00:30:10,510
say that lizard recently does actually

00:30:07,870 --> 00:30:13,420
really support arm very well and only by

00:30:10,510 --> 00:30:14,680
burton store the problem maybe if you're

00:30:13,420 --> 00:30:16,210
using something like a bunty you're

00:30:14,680 --> 00:30:18,070
probably using a really really really

00:30:16,210 --> 00:30:19,690
old version of libvirt or burton store

00:30:18,070 --> 00:30:21,070
and they probably don't have all the

00:30:19,690 --> 00:30:22,810
changes but we do have a developer who

00:30:21,070 --> 00:30:26,010
works full-time on getting on to work

00:30:22,810 --> 00:30:26,010
with verse installed

00:30:27,720 --> 00:30:30,950
he does

00:30:33,380 --> 00:30:37,620
but I mean for example if you use vert

00:30:35,640 --> 00:30:39,390
install to create say an armed guessed

00:30:37,620 --> 00:30:41,070
it won't it won't had a bj adapter

00:30:39,390 --> 00:30:43,110
because it knows that makes no sense and

00:30:41,070 --> 00:30:44,600
all that stuff does okay I stand

00:30:43,110 --> 00:30:55,650
corrected all that from that thank you

00:30:44,600 --> 00:31:00,540
this one just part is that so if if you

00:30:55,650 --> 00:31:03,450
ask um you to instantiate an actual you

00:31:00,540 --> 00:31:07,710
know a proper vga controller that that

00:31:03,450 --> 00:31:10,170
is doomed not necessarily because of kmu

00:31:07,710 --> 00:31:12,150
but because there's all kind of strings

00:31:10,170 --> 00:31:14,870
attached that come to that you know the

00:31:12,150 --> 00:31:19,020
colonel knows that a vga card is a

00:31:14,870 --> 00:31:22,590
device so i can map it uncashed and that

00:31:19,020 --> 00:31:25,110
will work and that on them or the kvm

00:31:22,590 --> 00:31:27,960
side that completely relies on on the

00:31:25,110 --> 00:31:30,060
fact that on x86 writing to a non-cash

00:31:27,960 --> 00:31:33,080
mapping is going to invalidate the cash

00:31:30,060 --> 00:31:33,080
clapping on the other side

00:31:35,220 --> 00:31:43,289
cash because the we have a lot of legacy

00:31:39,570 --> 00:31:47,159
there in both the colonel and EFI we

00:31:43,289 --> 00:31:50,159
assume that a driver return for an

00:31:47,159 --> 00:31:52,320
architecture because it combines for

00:31:50,159 --> 00:31:59,850
another one is just going to work this

00:31:52,320 --> 00:32:01,860
is not the case it is an alternative do

00:31:59,850 --> 00:32:05,419
we really want to go there it requires

00:32:01,860 --> 00:32:08,280
now to pass attributes is this device

00:32:05,419 --> 00:32:11,789
coherent or not that doesn't ever off

00:32:08,280 --> 00:32:15,150
really really annoying details to get

00:32:11,789 --> 00:32:16,860
right across all architectures and for

00:32:15,150 --> 00:32:19,530
in the end something that is not going

00:32:16,860 --> 00:32:23,190
to be really efficient but the point I'm

00:32:19,530 --> 00:32:25,919
trying to make his do we really need to

00:32:23,190 --> 00:32:27,690
go through all that trouble I mean for

00:32:25,919 --> 00:32:31,320
the sake of it fixing it would be good I

00:32:27,690 --> 00:32:33,900
agree but do we really want to do to do

00:32:31,320 --> 00:32:38,059
that why don't we use something that

00:32:33,900 --> 00:32:42,360
will be really efficient and you know

00:32:38,059 --> 00:32:44,970
matches the the clean state we have yes

00:32:42,360 --> 00:32:46,710
so on that should be fixed the driver

00:32:44,970 --> 00:32:49,230
thing it actually comes back to the

00:32:46,710 --> 00:32:51,630
verdi or vga which is definitely great

00:32:49,230 --> 00:32:53,309
way to go but you don't have control

00:32:51,630 --> 00:32:55,770
over the install media for all guests

00:32:53,309 --> 00:32:57,809
types you want to boot and so you can't

00:32:55,770 --> 00:33:01,400
have written io vga in there or a fixed

00:32:57,809 --> 00:33:04,230
driver necessarily in in that guest type

00:33:01,400 --> 00:33:05,970
from the get-go and so you really have

00:33:04,230 --> 00:33:07,590
to have this emulation fall back at

00:33:05,970 --> 00:33:10,919
least for installation before you have a

00:33:07,590 --> 00:33:17,520
chance to install so I have two answers

00:33:10,919 --> 00:33:21,330
to that one I don't really buy the oh

00:33:17,520 --> 00:33:23,760
you but you have an existing guest we

00:33:21,330 --> 00:33:30,840
don't have that many existing guests or

00:33:23,760 --> 00:33:34,409
now really realistically yeah if you if

00:33:30,840 --> 00:33:36,539
you deliver and install media I want to

00:33:34,409 --> 00:33:39,570
my guest I will require that statement

00:33:36,539 --> 00:33:41,250
immediately but i guess the guest type i

00:33:39,570 --> 00:33:48,240
was referring to is more local to

00:33:41,250 --> 00:33:50,909
seattle so the other thing is a deep to

00:33:48,240 --> 00:33:55,470
me that if you're talking install media

00:33:50,909 --> 00:33:58,559
and assuming that the whole that that

00:33:55,470 --> 00:34:04,020
problem you could also install using a

00:33:58,559 --> 00:34:05,520
serial console I don't that the frame

00:34:04,020 --> 00:34:07,679
buffer for I always find the frame

00:34:05,520 --> 00:34:10,919
buffer forum for especially for a server

00:34:07,679 --> 00:34:12,869
that sounds really really scary I mean

00:34:10,919 --> 00:34:16,619
I'm a big fan of something I can

00:34:12,869 --> 00:34:19,080
actually log in and and inspect later

00:34:16,619 --> 00:34:21,060
but yeah I take your point and one other

00:34:19,080 --> 00:34:24,389
thing with reference to slide number two

00:34:21,060 --> 00:34:28,080
ah so can you give you an example of

00:34:24,389 --> 00:34:31,260
where the guest cash attributes you know

00:34:28,080 --> 00:34:33,929
being more strict overriding the second

00:34:31,260 --> 00:34:40,800
stage to page table attributes is a good

00:34:33,929 --> 00:34:43,859
idea and useful well device pastor is

00:34:40,800 --> 00:34:48,179
one reason you don't really have to

00:34:43,859 --> 00:34:51,389
assume what kind of coherency the the

00:34:48,179 --> 00:34:54,260
hose it's going to put there it doesn't

00:34:51,389 --> 00:34:58,859
really know always know you may want to

00:34:54,260 --> 00:35:01,220
sir your last things in RAM for all the

00:34:58,859 --> 00:35:04,560
reasons you can if you have a known

00:35:01,220 --> 00:35:06,390
cache coherent device that is going to

00:35:04,560 --> 00:35:08,960
require that there's going to read

00:35:06,390 --> 00:35:13,530
directly from memory and you don't want

00:35:08,960 --> 00:35:16,200
yeah take for example a bootloader a

00:35:13,530 --> 00:35:18,869
good law that doesn't necessarily need

00:35:16,200 --> 00:35:20,550
to enable the cash is setup page table

00:35:18,869 --> 00:35:23,790
for that it's cumbersome it's

00:35:20,550 --> 00:35:26,790
complicated and they are lazy so they're

00:35:23,790 --> 00:35:30,480
going to say okay this device is not

00:35:26,790 --> 00:35:33,180
cache coherent anyway I'm going to just

00:35:30,480 --> 00:35:34,589
read from memory and it will all be good

00:35:33,180 --> 00:35:36,720
i'm not going to bother with cash

00:35:34,589 --> 00:35:38,490
maintenance operations if you enforce

00:35:36,720 --> 00:35:41,040
cash ability at stage two so you

00:35:38,490 --> 00:35:44,540
override the guest attributes which are

00:35:41,040 --> 00:35:47,730
default non-cash for all of a sudden you

00:35:44,540 --> 00:35:50,550
you will have the guests will read from

00:35:47,730 --> 00:35:55,050
its cash not necessarily from ram and

00:35:50,550 --> 00:35:56,640
you may know simply read stale data so

00:35:55,050 --> 00:36:00,000
you break existing

00:35:56,640 --> 00:36:02,970
good with that it's really important to

00:36:00,000 --> 00:36:05,099
in that kind of situation I mean you

00:36:02,970 --> 00:36:09,349
it's never perfect you will always find

00:36:05,099 --> 00:36:15,329
caller cases where one thing break but

00:36:09,349 --> 00:36:18,750
forcing me allowing the hypervisor to

00:36:15,329 --> 00:36:20,220
enforce casual tributes always it's not

00:36:18,750 --> 00:36:27,990
the Cecilia good idea you can always

00:36:20,220 --> 00:36:30,869
find cases where that breaks I would

00:36:27,990 --> 00:36:34,019
just observe that the lifetime of

00:36:30,869 --> 00:36:35,369
virtual machines significantly exceeds

00:36:34,019 --> 00:36:37,319
the lifetime of a given hardware

00:36:35,369 --> 00:36:41,940
generation but whether we like it or not

00:36:37,319 --> 00:36:43,769
I do like it and it seems like the guest

00:36:41,940 --> 00:36:50,569
needs to be aware of the hardware

00:36:43,769 --> 00:36:50,569
topology no not necessarily

00:36:55,269 --> 00:37:00,969
right so for example I install a nick

00:36:58,989 --> 00:37:02,859
and I pass it through because that's the

00:37:00,969 --> 00:37:05,799
best way to get no network performance

00:37:02,859 --> 00:37:08,939
today and then I want to switch to a

00:37:05,799 --> 00:37:10,869
software backed emulation of this Nick

00:37:08,939 --> 00:37:14,319
does the guests need to be in on the

00:37:10,869 --> 00:37:16,149
joke no the guest doesn't need to know

00:37:14,319 --> 00:37:19,179
anything about that he shouldn't need to

00:37:16,149 --> 00:37:22,029
know about that as long as you will you

00:37:19,179 --> 00:37:23,709
keep the same level of coherency if you

00:37:22,029 --> 00:37:26,439
change the level of coherency between

00:37:23,709 --> 00:37:28,899
the two that could become a problem but

00:37:26,439 --> 00:37:31,749
you are effectively changing the

00:37:28,899 --> 00:37:34,289
hardware whether it's a virtual harder

00:37:31,749 --> 00:37:36,189
or physical hardware you are effectively

00:37:34,289 --> 00:37:41,369
replacing with changing the properties

00:37:36,189 --> 00:37:44,199
of the hardware so migrating VMS on

00:37:41,369 --> 00:37:48,159
different hardware works as long as they

00:37:44,199 --> 00:37:49,899
have the same properties you can't mean

00:37:48,159 --> 00:37:51,880
it's it would be like okay i'm switching

00:37:49,899 --> 00:37:54,009
from a anthracene to type of bus I

00:37:51,880 --> 00:37:56,169
wouldn't work either you should change

00:37:54,009 --> 00:37:57,579
the level of coherency between your

00:37:56,169 --> 00:38:00,189
physical device and you I'm elated

00:37:57,579 --> 00:38:02,969
device you break but you will break on

00:38:00,189 --> 00:38:02,969
any architecture as well

00:38:07,090 --> 00:38:10,840
provided the guest says man

00:38:12,049 --> 00:38:14,979
kind of crazy

00:38:15,500 --> 00:38:22,980
hi I'm names Lazlo and I work on a guest

00:38:19,800 --> 00:38:24,360
you fi former Red Hat and I first I'd

00:38:22,980 --> 00:38:27,440
like to ask how much time we have left

00:38:24,360 --> 00:38:33,290
because my comments could be longer bit

00:38:27,440 --> 00:38:37,350
five mins all right I just do it quick

00:38:33,290 --> 00:38:39,180
otherwise coming simulator um can you

00:38:37,350 --> 00:38:41,250
jump to the last slide oh this is the

00:38:39,180 --> 00:38:44,280
last time I'm panel ultimate slide ok so

00:38:41,250 --> 00:38:46,530
i tried to count the recommendations or

00:38:44,280 --> 00:38:49,770
suggestions you made about possible ways

00:38:46,530 --> 00:38:53,610
to fix this problem and so i think

00:38:49,770 --> 00:38:56,790
number three is here to fix KDM i think

00:38:53,610 --> 00:38:59,280
that means making qm is smarter about

00:38:56,790 --> 00:39:02,790
all that stuff and set up the mappings

00:38:59,280 --> 00:39:06,810
correctly so kim you doesn't have any

00:39:02,790 --> 00:39:11,150
any any sane that really what Kim you

00:39:06,810 --> 00:39:14,130
can can can do is to expose some some

00:39:11,150 --> 00:39:18,420
firmware related information at least

00:39:14,130 --> 00:39:20,580
you say this is coherent yeah okay just

00:39:18,420 --> 00:39:27,350
stop can you go back to one so there was

00:39:20,580 --> 00:39:27,350
add a slide for that blah blah this one

00:39:28,400 --> 00:39:38,280
yeah yeah exactly so what we do now in

00:39:34,730 --> 00:39:40,200
in the firmware is uh okay let me get

00:39:38,280 --> 00:39:42,450
back to the first to the firmware

00:39:40,200 --> 00:39:46,460
interface where all this comes from so

00:39:42,450 --> 00:39:48,570
in you fi when you have a video card

00:39:46,460 --> 00:39:50,850
abstraction basically it's a graphics

00:39:48,570 --> 00:39:54,000
output protocol and it has various

00:39:50,850 --> 00:39:56,820
methods to write to the screen and one

00:39:54,000 --> 00:40:00,240
of them is blit and it would be possible

00:39:56,820 --> 00:40:03,570
to back the bleeped method with a verte

00:40:00,240 --> 00:40:05,940
ivj capable you know implementation so

00:40:03,570 --> 00:40:08,760
it actually speaks vert I oh and then

00:40:05,940 --> 00:40:10,440
all the memory barriers will be inserted

00:40:08,760 --> 00:40:12,360
in the vert I'll protocol itself so that

00:40:10,440 --> 00:40:16,440
that would be one solution the problem

00:40:12,360 --> 00:40:19,500
with that is that once you leave the

00:40:16,440 --> 00:40:22,560
firmware and handoff to the runtime OS

00:40:19,500 --> 00:40:25,980
the protocol becomes unavailable and the

00:40:22,560 --> 00:40:27,720
runtime OS is supposed to use the frame

00:40:25,980 --> 00:40:30,300
buffer it inherits there

00:40:27,720 --> 00:40:34,530
so poke into the frame buffer directly

00:40:30,300 --> 00:40:37,890
and so it wouldn't talk vert I'll until

00:40:34,530 --> 00:40:41,550
you installed the smart runtime of us

00:40:37,890 --> 00:40:44,099
gasps driver it could only use while

00:40:41,550 --> 00:40:46,950
word size XS or something like that and

00:40:44,099 --> 00:40:49,470
so you could either remove the complete

00:40:46,950 --> 00:40:51,630
memory slot packing and then each axis

00:40:49,470 --> 00:40:55,859
would trap but it would be horribly slow

00:40:51,630 --> 00:40:59,430
or or else you could advise the firmware

00:40:55,859 --> 00:41:02,609
to to make realize that it's actually

00:40:59,430 --> 00:41:04,890
coherent device and it shouldn't set up

00:41:02,609 --> 00:41:07,140
a non-cash mapping for that in the

00:41:04,890 --> 00:41:08,849
firmware yeah so that's that's I think

00:41:07,140 --> 00:41:11,730
that's the most portable and best

00:41:08,849 --> 00:41:14,849
solution like just tell the guests the

00:41:11,730 --> 00:41:18,780
device is Corran and if because qmu now

00:41:14,849 --> 00:41:23,250
generates a DT for the firmware to parse

00:41:18,780 --> 00:41:26,160
to know where the MMI ranges are and if

00:41:23,250 --> 00:41:29,220
you don't exactly know how the root

00:41:26,160 --> 00:41:33,359
complexes are represented in the dt but

00:41:29,220 --> 00:41:35,730
if the devices can be grouped into two

00:41:33,359 --> 00:41:38,130
separate root complexes and say that

00:41:35,730 --> 00:41:40,410
these are current these are non car

00:41:38,130 --> 00:41:43,320
that's the other that then that's

00:41:40,410 --> 00:41:45,450
perfectly it can be handled very well

00:41:43,320 --> 00:41:47,089
you know that that's that's one of the

00:41:45,450 --> 00:41:50,660
that's one of the recommendations

00:41:47,089 --> 00:41:55,010
describe your your coherency attributes

00:41:50,660 --> 00:41:59,520
the other thing is why can't we support

00:41:55,010 --> 00:42:04,890
part a or VGA really early on in in your

00:41:59,520 --> 00:42:06,810
protein system that's in it is there ok

00:42:04,890 --> 00:42:08,609
it's fairly recent just got merged but

00:42:06,810 --> 00:42:13,980
hey we like to leave on the bleeding

00:42:08,609 --> 00:42:17,880
edge anyway well you fi internals are so

00:42:13,980 --> 00:42:21,420
they kind of make it heavy or hard to

00:42:17,880 --> 00:42:23,940
choose bird Tyler ty always it depends

00:42:21,420 --> 00:42:25,680
on a lot of stuff that's not very not

00:42:23,940 --> 00:42:28,500
not available very in the very early

00:42:25,680 --> 00:42:30,060
phases of you fi but with virtually g8

00:42:28,500 --> 00:42:34,020
should the real problem with that is

00:42:30,060 --> 00:42:37,260
that it wouldn't allow the guest the

00:42:34,020 --> 00:42:39,990
runtime OS to just inherit the frame

00:42:37,260 --> 00:42:41,190
buffer set up by the by the firmware and

00:42:39,990 --> 00:42:43,650
just poke into

00:42:41,190 --> 00:42:47,609
that until a smart driver comes along I

00:42:43,650 --> 00:42:50,550
know it needs to be the driver yeah so I

00:42:47,609 --> 00:42:53,099
think if I can make up well if I can

00:42:50,550 --> 00:42:55,680
express my preference here I think for

00:42:53,099 --> 00:42:58,050
qmu the best or most portable way for

00:42:55,680 --> 00:43:01,680
work would be to just generate a smart

00:42:58,050 --> 00:43:03,960
dt and explain the gas firmware what is

00:43:01,680 --> 00:43:06,930
supposed to be mapped as cash versus

00:43:03,960 --> 00:43:09,930
device memory uncashed because right now

00:43:06,930 --> 00:43:12,599
it does work I think even with a with

00:43:09,930 --> 00:43:16,470
kvm what we have but it's a hack it's a

00:43:12,599 --> 00:43:18,000
static hack that we just say although we

00:43:16,470 --> 00:43:20,460
should really map this device memory

00:43:18,000 --> 00:43:22,980
because it's vga card we know that it

00:43:20,460 --> 00:43:25,200
doesn't work due to the way that on arm

00:43:22,980 --> 00:43:27,839
the caching attributes are combined with

00:43:25,200 --> 00:43:32,339
the s2 and s1 so if that could be made

00:43:27,839 --> 00:43:34,920
dynamic and the host the QM you dt

00:43:32,339 --> 00:43:37,790
generator could advise I'm all for that

00:43:34,920 --> 00:43:42,150
I mean I don't mind which whichever

00:43:37,790 --> 00:43:45,089
solution you you want to use all I'm

00:43:42,150 --> 00:43:48,510
saying is tell the truth to the guests

00:43:45,089 --> 00:43:49,920
yeah I to it absolutely so what when I

00:43:48,510 --> 00:43:53,490
see the problem here is that just the

00:43:49,920 --> 00:43:58,040
gas lacks sufficient dynamic information

00:43:53,490 --> 00:43:58,040
so when they date oh thank you correct

00:43:58,280 --> 00:44:07,819

YouTube URL: https://www.youtube.com/watch?v=A_zCxzpxzmE


