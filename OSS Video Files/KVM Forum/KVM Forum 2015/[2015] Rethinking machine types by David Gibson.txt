Title: [2015] Rethinking machine types by David Gibson
Publication date: 2015-09-04
Playlist: KVM Forum 2015
Description: 
	qemu's QOM device model can describe virtual hardware in a way which is reasonably discoverable and consistent across devices and and architectures. This exists somewhat uneasily with the code for machine types which implement platform specific initialization, but can impose constraints which are not easily discoverable. Converting machine types to scripts describing the machine's devices has been discussed in the past, but it's not clear that will be practical soon or ever. This presentation suggests approaches for making machine types work better with QOM, based in part on the experience of integrating support for many different embedded machines into the Linux kernel in arch/powerpc. These approaches might also allow improved communication of virtual hardware description outside qemu; both "upwards" to libvirt and management agents, and "downwards" to the virtual guest OS. 

David Gibson
Senior Software Engineer, Red Hat
David is a qemu and Linux kernel developer, currently working at Red Hat on KVM and qemu for IBM Power servers. Previously, while employed by IBM, he was the main author of qemu's 'pseries' machine type. He also wrote the Device Tree Compiler, and has worked on low-level memory management for Power machines, bringup for embedded PowerPC machines and the 'orinoco' wireless driver.
Captions: 
	00:00:20,750 --> 00:00:27,840
hi i'm david gibson from red hat the

00:00:25,830 --> 00:00:29,250
title is rethinking machine types but

00:00:27,840 --> 00:00:32,340
actually i'm talking more generally

00:00:29,250 --> 00:00:35,340
about how you configure what virtual

00:00:32,340 --> 00:00:38,879
hardware you want in your machine it's a

00:00:35,340 --> 00:00:43,110
cluster of related problems in that area

00:00:38,879 --> 00:00:47,610
and some no total solutions but some

00:00:43,110 --> 00:00:51,660
approaches which might help so what's

00:00:47,610 --> 00:00:53,010
the problem I'm going to see them

00:00:51,660 --> 00:00:56,370
everyone's more or less familiar with

00:00:53,010 --> 00:00:58,469
the qu dev model you say no defaults to

00:00:56,370 --> 00:01:00,600
start with to get rid of legacy stuff

00:00:58,469 --> 00:01:02,699
then for every device and you want your

00:01:00,600 --> 00:01:05,129
system you put dash device and various

00:01:02,699 --> 00:01:08,549
options and each one of those becomes a

00:01:05,129 --> 00:01:10,590
device in your virtual machine very

00:01:08,549 --> 00:01:13,080
straightforward very simple very easy to

00:01:10,590 --> 00:01:15,780
understand except of course that won't

00:01:13,080 --> 00:01:18,240
work because you can't do any of this

00:01:15,780 --> 00:01:20,729
until you choose a machine-type and when

00:01:18,240 --> 00:01:24,840
you choose a machine-type you get a

00:01:20,729 --> 00:01:27,780
whole bunch of other devices that are

00:01:24,840 --> 00:01:30,060
standard for that device I've used

00:01:27,780 --> 00:01:33,630
p-series here as an example because

00:01:30,060 --> 00:01:39,150
that's the one I know best but the same

00:01:33,630 --> 00:01:42,750
is true for PC for everything they'll

00:01:39,150 --> 00:01:45,420
add one sort of device or another as

00:01:42,750 --> 00:01:49,799
well as various firmware interfaces and

00:01:45,420 --> 00:01:52,430
so forth so you can't really get away

00:01:49,799 --> 00:01:56,250
without machine type because it performs

00:01:52,430 --> 00:02:00,030
system wave set up across your virtual

00:01:56,250 --> 00:02:02,130
machine that that needs to be done but

00:02:00,030 --> 00:02:04,110
the problem is it also adds a bunch of

00:02:02,130 --> 00:02:07,350
extra devices even when you say no

00:02:04,110 --> 00:02:11,520
defaults exactly what extra devices at

00:02:07,350 --> 00:02:14,819
ads can depend on other options even

00:02:11,520 --> 00:02:19,209
options that aren't obviously related

00:02:14,819 --> 00:02:20,890
and so essentially it's not easy to

00:02:19,209 --> 00:02:22,450
discover what the behavior of the

00:02:20,890 --> 00:02:24,819
machine type is going to be in terms of

00:02:22,450 --> 00:02:27,159
what devices will create which is

00:02:24,819 --> 00:02:33,489
awkward for management layers and so

00:02:27,159 --> 00:02:37,060
forth so going on how do we talk about

00:02:33,489 --> 00:02:40,329
what hardware is in a vm across the

00:02:37,060 --> 00:02:42,610
entire stack so I'm using over here as

00:02:40,329 --> 00:02:44,799
an example but you'll get a similar

00:02:42,610 --> 00:02:49,450
picture with OpenStack or or other

00:02:44,799 --> 00:02:51,459
things we start with entries in the

00:02:49,450 --> 00:02:53,410
overt database which describe the

00:02:51,459 --> 00:02:57,340
virtual machine and say what hard work

00:02:53,410 --> 00:03:00,609
should have it turns them into xml RPC

00:02:57,340 --> 00:03:03,489
parameters that go to the dsm-v dsm

00:03:00,609 --> 00:03:06,790
turns it into liver domain XML XML turns

00:03:03,489 --> 00:03:11,560
it into a QM you command line qmu turns

00:03:06,790 --> 00:03:13,870
it into its internal q om model and QM

00:03:11,560 --> 00:03:16,030
you will then convert that into

00:03:13,870 --> 00:03:18,880
something to tell the guests and the two

00:03:16,030 --> 00:03:20,260
common forms there are lots of forms for

00:03:18,880 --> 00:03:23,200
the many different machine types but the

00:03:20,260 --> 00:03:26,349
two that are common rsap I used on x86

00:03:23,200 --> 00:03:29,440
and some arm and device tree used on

00:03:26,349 --> 00:03:33,220
power and some arm and some other things

00:03:29,440 --> 00:03:35,799
and so problem number two or at least

00:03:33,220 --> 00:03:38,680
ugly thing number two is do we really

00:03:35,799 --> 00:03:41,470
need what is this six different methods

00:03:38,680 --> 00:03:43,209
of describing the virtual hardware as we

00:03:41,470 --> 00:03:49,239
move through the stack all of which are

00:03:43,209 --> 00:03:50,919
really quite different so why are there

00:03:49,239 --> 00:03:53,859
so many formats what's different about

00:03:50,919 --> 00:03:57,720
the different descriptions of the

00:03:53,859 --> 00:04:03,040
hardware moving through the stack here

00:03:57,720 --> 00:04:09,609
the biggest difference is how exactly

00:04:03,040 --> 00:04:10,959
they describe the hardware so what I'm

00:04:09,609 --> 00:04:12,910
what I'm calling the distinction between

00:04:10,959 --> 00:04:15,549
a loose description of the hardware and

00:04:12,910 --> 00:04:17,680
a precise description of the hardware so

00:04:15,549 --> 00:04:19,510
a loose description you know you're just

00:04:17,680 --> 00:04:20,979
saying you want this much disk I don't

00:04:19,510 --> 00:04:24,640
care how you get it you want this much

00:04:20,979 --> 00:04:26,770
disk and at the precise end you say

00:04:24,640 --> 00:04:27,000
everything there is about the disk you

00:04:26,770 --> 00:04:31,360
know

00:04:27,000 --> 00:04:33,850
what model it is it's unique IDs if it

00:04:31,360 --> 00:04:35,800
has those what controller it's attached

00:04:33,850 --> 00:04:37,120
to how the controller is attached any

00:04:35,800 --> 00:04:39,490
bridges there are between the current

00:04:37,120 --> 00:04:43,450
controller and the device at all this

00:04:39,490 --> 00:04:46,210
for every device on the system so the

00:04:43,450 --> 00:04:51,990
various different models we have sort of

00:04:46,210 --> 00:04:54,820
lie at various places along here the

00:04:51,990 --> 00:04:57,390
modes that over and openstack invert

00:04:54,820 --> 00:05:00,220
install use are all fairly loose

00:04:57,390 --> 00:05:02,620
obviously the guest needs to the guest

00:05:00,220 --> 00:05:05,380
and QM you both need to hop need to have

00:05:02,620 --> 00:05:08,770
an exact image of the hardware qmu

00:05:05,380 --> 00:05:10,480
because it is the hardware and the guest

00:05:08,770 --> 00:05:13,720
because it needs to drive that hardware

00:05:10,480 --> 00:05:16,720
and so a CPI and device tree and queued

00:05:13,720 --> 00:05:19,150
overall as as precise as you can get

00:05:16,720 --> 00:05:22,260
essentially qmu command lines almost

00:05:19,150 --> 00:05:27,460
there it just you add a few defaults

00:05:22,260 --> 00:05:30,730
libvirt XML is the weird case because it

00:05:27,460 --> 00:05:32,980
can actually vary depending where it is

00:05:30,730 --> 00:05:35,620
when you create a new vm with libvirt

00:05:32,980 --> 00:05:37,450
XML you'll probably be fairly loose in

00:05:35,620 --> 00:05:41,590
the description just say roughly what

00:05:37,450 --> 00:05:42,940
you want but libvirt that's the only

00:05:41,590 --> 00:05:44,860
description of the hardware that live

00:05:42,940 --> 00:05:47,890
that maintains which means by the time

00:05:44,860 --> 00:05:50,520
it actually runs qmu it modifies that

00:05:47,890 --> 00:05:56,140
XML internally into something that is

00:05:50,520 --> 00:06:01,030
quite precise and as i'll be discussing

00:05:56,140 --> 00:06:02,410
as we go further how precise it is the

00:06:01,030 --> 00:06:04,180
fact that it's sort of not one hundred

00:06:02,410 --> 00:06:10,180
percent precise can cause some

00:06:04,180 --> 00:06:12,340
complications and we do need sort of

00:06:10,180 --> 00:06:14,560
both ends of the spectrum when you're

00:06:12,340 --> 00:06:17,920
creating a vm you don't want to have to

00:06:14,560 --> 00:06:21,700
describe whether you're an actual person

00:06:17,920 --> 00:06:23,080
or whether you're a management layer you

00:06:21,700 --> 00:06:25,990
don't want to have to describe

00:06:23,080 --> 00:06:27,970
absolutely every detail of every device

00:06:25,990 --> 00:06:30,490
on the system in order to create your vm

00:06:27,970 --> 00:06:32,140
so you need the loose description only

00:06:30,490 --> 00:06:33,940
sometimes you do want to control things

00:06:32,140 --> 00:06:37,360
precisely because you want to test

00:06:33,940 --> 00:06:38,830
something specific or you have some

00:06:37,360 --> 00:06:41,580
reason that you want a particular type

00:06:38,830 --> 00:06:41,580
of virtual hardware

00:06:42,560 --> 00:06:48,530
now obviously as I said to me and the

00:06:45,060 --> 00:06:51,510
guests need a precise description and so

00:06:48,530 --> 00:06:54,720
through the stack at various stages as

00:06:51,510 --> 00:06:56,370
you as you move down the stack the

00:06:54,720 --> 00:06:58,230
prasada the loose description is

00:06:56,370 --> 00:07:00,420
converted to a precise description by

00:06:58,230 --> 00:07:04,290
selecting default implementations for

00:07:00,420 --> 00:07:07,380
things by adding standard or default

00:07:04,290 --> 00:07:09,090
devices and by signing addresses there's

00:07:07,380 --> 00:07:11,880
there's other things that can happen but

00:07:09,090 --> 00:07:14,760
they're the three main techniques that

00:07:11,880 --> 00:07:22,730
are used to to make a description

00:07:14,760 --> 00:07:22,730
precise excuse me

00:07:28,830 --> 00:07:36,060
so what happens when we add migration

00:07:32,550 --> 00:07:37,980
into the picture for migration the

00:07:36,060 --> 00:07:39,930
destination has to have identical

00:07:37,980 --> 00:07:43,380
hardware to the source as far as the

00:07:39,930 --> 00:07:45,660
guests can tell but how those devices

00:07:43,380 --> 00:07:47,640
are implemented might vary the simplest

00:07:45,660 --> 00:07:50,160
example of that is if you've got a

00:07:47,640 --> 00:07:53,310
virtual disk image that's on a different

00:07:50,160 --> 00:07:55,380
path on the host on your destination

00:07:53,310 --> 00:07:57,420
from the source no reason you can't

00:07:55,380 --> 00:08:00,050
migrate that you just need to rearrange

00:07:57,420 --> 00:08:02,130
your pointers and that should be fine

00:08:00,050 --> 00:08:03,660
there's other difference as you can

00:08:02,130 --> 00:08:06,320
there can be reasons you could you want

00:08:03,660 --> 00:08:08,550
to change the back end in ways that

00:08:06,320 --> 00:08:12,210
should be invisible to the guests and

00:08:08,550 --> 00:08:14,730
that shouldn't stop you're migrating ah

00:08:12,210 --> 00:08:15,660
so libvirt manages migration at the

00:08:14,730 --> 00:08:18,960
moment although most of the

00:08:15,660 --> 00:08:20,580
implementation is in q mu and that means

00:08:18,960 --> 00:08:22,500
libvirt needs to know the precise

00:08:20,580 --> 00:08:25,350
Hardware description so that it can

00:08:22,500 --> 00:08:28,320
start qmu on the destination host with

00:08:25,350 --> 00:08:31,410
exactly the same guest hardware as it

00:08:28,320 --> 00:08:33,690
had on the source and what that means is

00:08:31,410 --> 00:08:35,670
that although qmu has a bunch of

00:08:33,690 --> 00:08:37,950
perfectly good code for assigning

00:08:35,670 --> 00:08:40,800
addresses to devices when you ask for

00:08:37,950 --> 00:08:42,270
them libvirt duplicates all that because

00:08:40,800 --> 00:08:44,040
it needs to know where all the devices

00:08:42,270 --> 00:08:49,290
are so in creating exactly the same ones

00:08:44,040 --> 00:08:52,560
on the far end and so we have heard

00:08:49,290 --> 00:08:56,370
duplication which is you know generally

00:08:52,560 --> 00:08:59,280
a bad sign so hot plug is another

00:08:56,370 --> 00:09:01,560
complication obviously when you're hot

00:08:59,280 --> 00:09:02,910
plug devices into qmu it has to keep

00:09:01,560 --> 00:09:08,460
track of what they are it has to know

00:09:02,910 --> 00:09:09,930
what the hardware is but the

00:09:08,460 --> 00:09:13,200
complication comes when you combine that

00:09:09,930 --> 00:09:14,520
with migration the destination still

00:09:13,200 --> 00:09:16,080
needs to have all the same hardware

00:09:14,520 --> 00:09:18,180
devices and that includes all the

00:09:16,080 --> 00:09:20,610
devices you hot plugged on the source

00:09:18,180 --> 00:09:23,700
between when you started the VM and when

00:09:20,610 --> 00:09:25,980
you started the migration and that means

00:09:23,700 --> 00:09:28,350
again in a similar way that libvirt

00:09:25,980 --> 00:09:30,720
needs to track all the hot plug devices

00:09:28,350 --> 00:09:32,220
and update its view of the hardware so

00:09:30,720 --> 00:09:35,250
that it will be in sync with what's hot

00:09:32,220 --> 00:09:37,590
blood and again this is more duplicated

00:09:35,250 --> 00:09:39,900
effort q mu and levert or essentially

00:09:37,590 --> 00:09:41,730
tracking the state of the guest hardware

00:09:39,900 --> 00:09:43,879
in parallel sorry I shouldn't say the

00:09:41,730 --> 00:09:46,410
state the

00:09:43,879 --> 00:09:48,899
the configuration of the guest hardware

00:09:46,410 --> 00:09:53,939
in parallel which seems a bit

00:09:48,899 --> 00:09:57,959
unfortunate so to recap we have a bunch

00:09:53,939 --> 00:10:00,029
of problems in well problems or things

00:09:57,959 --> 00:10:03,470
that are seen not as nice as as they'd

00:10:00,029 --> 00:10:06,480
like to be in terms of how we describe

00:10:03,470 --> 00:10:13,339
the guest hardware at various parts of

00:10:06,480 --> 00:10:18,869
the stack so what do we do about it um

00:10:13,339 --> 00:10:23,819
yeah so essentially in qmu in order to

00:10:18,869 --> 00:10:27,410
start fixing this we really need a clear

00:10:23,819 --> 00:10:30,360
break between what parts of the code

00:10:27,410 --> 00:10:31,949
create the device model and the parts of

00:10:30,360 --> 00:10:35,399
the code that use the device model and

00:10:31,949 --> 00:10:38,089
that's mostly true already the actual

00:10:35,399 --> 00:10:41,100
device models just use the device model

00:10:38,089 --> 00:10:42,660
the so essentially what i'm calling the

00:10:41,100 --> 00:10:45,509
emulator runtime here which is all the

00:10:42,660 --> 00:10:49,529
device models the cpu models TCG kvm

00:10:45,509 --> 00:10:51,149
whatever they look at the device model

00:10:49,529 --> 00:10:54,149
but they don't alter the device model

00:10:51,149 --> 00:10:55,829
and then you have the virtual machine

00:10:54,149 --> 00:10:57,629
construction which sets up the device

00:10:55,829 --> 00:10:59,749
model in the first place and that's

00:10:57,629 --> 00:11:03,720
essentially the command line processing

00:10:59,749 --> 00:11:06,319
qmp and hmp can both alter that device

00:11:03,720 --> 00:11:08,879
model when you're hot plug devices and

00:11:06,319 --> 00:11:10,410
you've got the default device processing

00:11:08,879 --> 00:11:13,649
and various legacy options in VA let's

00:11:10,410 --> 00:11:15,239
see the tricky bit is machine type here

00:11:13,649 --> 00:11:18,149
again as I was talking about before

00:11:15,239 --> 00:11:20,040
because machine type both constructs the

00:11:18,149 --> 00:11:22,739
machine to have the default devices and

00:11:20,040 --> 00:11:25,649
then it also does runtime setup which is

00:11:22,739 --> 00:11:27,660
really part of the and does things at

00:11:25,649 --> 00:11:30,480
reset time and so forth which is unsur

00:11:27,660 --> 00:11:35,939
there so what we need to do is to split

00:11:30,480 --> 00:11:38,160
machine type up into these two parts the

00:11:35,939 --> 00:11:42,209
first of those I'm calling the machine

00:11:38,160 --> 00:11:43,559
schema just as a random name to

00:11:42,209 --> 00:11:46,160
distinguish it from the executive new

00:11:43,559 --> 00:11:48,299
teen type and its job would be to

00:11:46,160 --> 00:11:51,209
construct the devices that are essential

00:11:48,299 --> 00:11:54,700
for the platform set their options

00:11:51,209 --> 00:11:56,770
correctly optionally construct

00:11:54,700 --> 00:11:58,300
devices that are usually present on the

00:11:56,770 --> 00:12:00,880
platform even if they don't have to be

00:11:58,300 --> 00:12:02,350
and what those are might depend on a

00:12:00,880 --> 00:12:03,460
bunch of options that might depend on

00:12:02,350 --> 00:12:05,080
whether you've got graphics whether

00:12:03,460 --> 00:12:08,680
you've got other devices so on and so

00:12:05,080 --> 00:12:10,120
forth and it should set up the route bus

00:12:08,680 --> 00:12:12,640
and its class and parameters and the

00:12:10,120 --> 00:12:14,710
significance of that is that I think the

00:12:12,640 --> 00:12:16,090
sensible place to handle the runtime

00:12:14,710 --> 00:12:19,660
logic that's specific to a particular

00:12:16,090 --> 00:12:21,370
platform on machine is in a subclass of

00:12:19,660 --> 00:12:23,110
sis bus this isn't the only way we could

00:12:21,370 --> 00:12:27,370
do it but this is the approach I'm

00:12:23,110 --> 00:12:32,350
suggesting so obvious when you take we

00:12:27,370 --> 00:12:34,660
make sis bus subclass a ball it can

00:12:32,350 --> 00:12:37,000
check device dependencies the code in

00:12:34,660 --> 00:12:39,520
there so the common example would be

00:12:37,000 --> 00:12:41,800
most devices in the system won't operate

00:12:39,520 --> 00:12:43,450
without a system interrupt controller so

00:12:41,800 --> 00:12:45,100
it we might want to verify that if

00:12:43,450 --> 00:12:46,930
there's any interrupt using devices then

00:12:45,100 --> 00:12:49,660
you have a system interrupt controller

00:12:46,930 --> 00:12:52,450
to process those but it should never

00:12:49,660 --> 00:12:54,990
alter them it should just say no you

00:12:52,450 --> 00:12:57,100
can't do that missing device because any

00:12:54,990 --> 00:12:59,290
alteration of the device configuration

00:12:57,100 --> 00:13:02,110
is the job of the Machine construction

00:12:59,290 --> 00:13:03,850
there and this will also do the other

00:13:02,110 --> 00:13:06,250
the other jobs that machine type does

00:13:03,850 --> 00:13:08,260
currently so loading your firmware

00:13:06,250 --> 00:13:10,870
setting it up setting up any CPU and

00:13:08,260 --> 00:13:12,790
memory initial state any other system

00:13:10,870 --> 00:13:16,320
bought a system-wide reset that's

00:13:12,790 --> 00:13:19,210
necessary so that's part one I think of

00:13:16,320 --> 00:13:24,970
cleaning up this handling advice

00:13:19,210 --> 00:13:29,340
configuration part two is to make that

00:13:24,970 --> 00:13:32,530
device configuration visible outside qmu

00:13:29,340 --> 00:13:35,380
so there's two subparts to that so the

00:13:32,530 --> 00:13:38,680
first party is allowing management

00:13:35,380 --> 00:13:39,730
layers or what what have you to extract

00:13:38,680 --> 00:13:42,010
the current state of the hardware

00:13:39,730 --> 00:13:44,470
configuration from qm you and actually

00:13:42,010 --> 00:13:46,930
can do that now by going through all the

00:13:44,470 --> 00:13:49,300
devices using qmp and getting all their

00:13:46,930 --> 00:13:50,770
properties and getting everything there

00:13:49,300 --> 00:13:53,380
is to know about them and pulling them

00:13:50,770 --> 00:13:54,670
out but it's a fairly laborious process

00:13:53,380 --> 00:13:57,370
because you've got to walk through the

00:13:54,670 --> 00:13:59,110
tree and extract everything out what I

00:13:57,370 --> 00:14:00,850
would like to see is something where you

00:13:59,110 --> 00:14:03,280
can just say give me the hardware

00:14:00,850 --> 00:14:07,270
configuration and QM you will spit out

00:14:03,280 --> 00:14:08,350
this club that tells you everything you

00:14:07,270 --> 00:14:14,700
need to know about

00:14:08,350 --> 00:14:17,140
the hardware in the system obviously

00:14:14,700 --> 00:14:19,540
including any devices that the current

00:14:17,140 --> 00:14:21,250
state so anything you started with

00:14:19,540 --> 00:14:24,160
initially and anything you've hot-plug

00:14:21,250 --> 00:14:28,900
since then and then the second part of

00:14:24,160 --> 00:14:30,700
that is our to see a way that you can

00:14:28,900 --> 00:14:33,310
insert that hardware description back

00:14:30,700 --> 00:14:35,290
into Q mu so you can start q mu with

00:14:33,310 --> 00:14:37,120
some kind of special option you feed at

00:14:35,290 --> 00:14:40,060
this Bob of hardware configuration and

00:14:37,120 --> 00:14:42,040
it starts up running on that completely

00:14:40,060 --> 00:14:45,040
bypassing the normal virtual machine

00:14:42,040 --> 00:14:47,620
construction so it bypasses the machine

00:14:45,040 --> 00:14:50,080
schema it bypasses the usual command

00:14:47,620 --> 00:14:52,200
line construction of things and goes

00:14:50,080 --> 00:14:57,220
straight into run time with this

00:14:52,200 --> 00:15:00,970
pre-configured hardware setup so the

00:14:57,220 --> 00:15:08,740
next step from that is one of those just

00:15:00,970 --> 00:15:11,470
happened look that's better is to make

00:15:08,740 --> 00:15:13,000
have libvirt make use of this now I

00:15:11,470 --> 00:15:16,990
don't know libvirt nearly as well as I

00:15:13,000 --> 00:15:20,290
know Q mu so again this is a these are

00:15:16,990 --> 00:15:22,030
all a proposed set of actions which I am

00:15:20,290 --> 00:15:24,970
happy to be corrected on if if people

00:15:22,030 --> 00:15:26,920
have a better approach so at the moment

00:15:24,970 --> 00:15:28,510
as I was saying live votes only view of

00:15:26,920 --> 00:15:32,470
the hardware as the liver is the domain

00:15:28,510 --> 00:15:35,140
XML and I think trying to maintain a

00:15:32,470 --> 00:15:37,840
puter a completely hypervisor agnostic

00:15:35,140 --> 00:15:40,690
description of the hardware is it's not

00:15:37,840 --> 00:15:43,390
really possible because the what what is

00:15:40,690 --> 00:15:45,310
the hybrid what virtual hardware you can

00:15:43,390 --> 00:15:47,920
construct is inherently going to depend

00:15:45,310 --> 00:15:52,120
on your hypervisor back end so I think

00:15:47,920 --> 00:15:55,540
libvirt needs to gain a notion of a

00:15:52,120 --> 00:15:58,390
back-end hypervisor specific hardware

00:15:55,540 --> 00:15:59,440
configuration and that could be a

00:15:58,390 --> 00:16:02,020
different format for different

00:15:59,440 --> 00:16:04,510
hypervisors but obviously I'm interested

00:16:02,020 --> 00:16:08,890
in the common case which is Q mu and kvm

00:16:04,510 --> 00:16:11,130
and so I'm talking about a QM you mortal

00:16:08,890 --> 00:16:11,130
here

00:16:11,800 --> 00:16:16,660
so what I'd like to see is a model where

00:16:14,860 --> 00:16:20,370
when you create a new vm with libvirt

00:16:16,660 --> 00:16:23,410
it'll take domain xml it will convert it

00:16:20,370 --> 00:16:24,519
into qmu command line parameters or

00:16:23,410 --> 00:16:27,910
whatever in much the same way it does

00:16:24,519 --> 00:16:30,820
now it'll start up qmu but then it will

00:16:27,910 --> 00:16:34,660
extract from qmu that precise Hardware

00:16:30,820 --> 00:16:37,120
description and store it and associate

00:16:34,660 --> 00:16:39,190
it with that VM and every subsequent

00:16:37,120 --> 00:16:42,459
time you start the vm it'll just use

00:16:39,190 --> 00:16:44,829
that can description when you migrate it

00:16:42,459 --> 00:16:47,620
will use that can description again so

00:16:44,829 --> 00:16:50,110
it'll always get the same hardware and

00:16:47,620 --> 00:16:52,329
each time you you restart the vm it'll

00:16:50,110 --> 00:16:54,610
use the the same hardware that it

00:16:52,329 --> 00:16:57,760
extraction from qmu bypassing the

00:16:54,610 --> 00:17:00,010
Machine construction now obviously you

00:16:57,760 --> 00:17:03,130
could have the option of reconstructing

00:17:00,010 --> 00:17:04,870
that from the domain XML suppose you the

00:17:03,130 --> 00:17:06,339
defaults changed in levert about what

00:17:04,870 --> 00:17:10,270
devices and you wanted to update your

00:17:06,339 --> 00:17:14,079
machines but that would certainly

00:17:10,270 --> 00:17:16,179
require a guest restart and it might

00:17:14,079 --> 00:17:19,350
even require guest reconfiguration

00:17:16,179 --> 00:17:22,169
depending on how finicky your guest is

00:17:19,350 --> 00:17:25,270
about exactly what hardware it's saying

00:17:22,169 --> 00:17:27,699
most Linux setups these days will adapt

00:17:25,270 --> 00:17:32,980
to new for Hardware pretty well but

00:17:27,699 --> 00:17:34,770
that's not always the case so they're

00:17:32,980 --> 00:17:37,000
the parts I've thought about in detail

00:17:34,770 --> 00:17:39,850
what influence does this have on the

00:17:37,000 --> 00:17:43,059
rest of the stack and I think the answer

00:17:39,850 --> 00:17:45,100
is not a whole lot up into the

00:17:43,059 --> 00:17:48,429
management layers you don't need to do

00:17:45,100 --> 00:17:50,200
anything it can use libvirt just as it

00:17:48,429 --> 00:17:53,710
does now it creates the name XML and

00:17:50,200 --> 00:17:57,910
live that does what I've just described

00:17:53,710 --> 00:17:59,950
and everything keeps going optionally

00:17:57,910 --> 00:18:01,900
management layers could use something

00:17:59,950 --> 00:18:05,410
like this if they wanted more control

00:18:01,900 --> 00:18:08,800
precise control of the hardware or even

00:18:05,410 --> 00:18:10,540
if they wanted to show to the users more

00:18:08,800 --> 00:18:12,760
detailed view of exactly what hardware

00:18:10,540 --> 00:18:16,090
is there they could use a model like

00:18:12,760 --> 00:18:17,980
this but they wouldn't have two guest

00:18:16,090 --> 00:18:19,540
operating systems really nothing to be

00:18:17,980 --> 00:18:22,210
done there they'd get their Hardware

00:18:19,540 --> 00:18:24,490
description from a CPI or device tree

00:18:22,210 --> 00:18:24,820
just as they do now QMI you already has

00:18:24,490 --> 00:18:26,350
the

00:18:24,820 --> 00:18:31,539
to create that for the internal model

00:18:26,350 --> 00:18:35,159
there's not really anything new there so

00:18:31,539 --> 00:18:39,370
what would a format to describe hardware

00:18:35,159 --> 00:18:41,110
like this need to look like and for the

00:18:39,370 --> 00:18:43,240
first thing things here tree structure

00:18:41,110 --> 00:18:46,179
and extensible I don't think there's a

00:18:43,240 --> 00:18:49,330
very controversial it's kind of the only

00:18:46,179 --> 00:18:51,789
natural way to describe a bus bridge

00:18:49,330 --> 00:18:56,830
hierarchy and obviously you need to

00:18:51,789 --> 00:18:59,230
handle future hardware ah now I think it

00:18:56,830 --> 00:19:01,029
should keep guests visible information

00:18:59,230 --> 00:19:03,190
separate from back end so this is like

00:19:01,029 --> 00:19:05,559
four disc guest visible information

00:19:03,190 --> 00:19:07,809
would be the model of the disc the

00:19:05,559 --> 00:19:12,250
published skazhi ID if it's a scuzzy

00:19:07,809 --> 00:19:13,960
disc its size obviously its interface

00:19:12,250 --> 00:19:15,669
where it appears on the bus those are

00:19:13,960 --> 00:19:18,059
all bits of guest visible information

00:19:15,669 --> 00:19:20,559
what's not guest visible information is

00:19:18,059 --> 00:19:22,990
whether that's backed by Gluster an

00:19:20,559 --> 00:19:26,169
image a real disc on the host what the

00:19:22,990 --> 00:19:27,879
path that image is host site

00:19:26,169 --> 00:19:31,870
optimization options about how it's

00:19:27,879 --> 00:19:36,490
accessed for Network the model of the

00:19:31,870 --> 00:19:38,559
neck its MAC address settings those are

00:19:36,490 --> 00:19:40,360
guest visible options but whether it's

00:19:38,559 --> 00:19:44,080
connected to open V switch go to a

00:19:40,360 --> 00:19:46,690
bridge or so on and so forth those are

00:19:44,080 --> 00:19:52,360
what I'm thinking of is back in details

00:19:46,690 --> 00:19:53,980
I think the the guest visible on the

00:19:52,360 --> 00:19:56,139
back end information needs to be get

00:19:53,980 --> 00:19:58,600
separate because there's quite a lot of

00:19:56,139 --> 00:20:01,000
tools that want to deal with one or the

00:19:58,600 --> 00:20:02,950
other and it's a lot easier for them if

00:20:01,000 --> 00:20:06,039
they can do that without having to par

00:20:02,950 --> 00:20:07,570
zor handle the other q mu is already has

00:20:06,039 --> 00:20:10,240
pretty much all the guests visible and

00:20:07,570 --> 00:20:13,059
back-end information separate libvirt

00:20:10,240 --> 00:20:15,850
does not in the domain xml and that

00:20:13,059 --> 00:20:17,890
complicates things a bit

00:20:15,850 --> 00:20:20,680
in different supplements

00:20:17,890 --> 00:20:22,480
yes but you have to know everything

00:20:20,680 --> 00:20:25,090
about every sub element in order to know

00:20:22,480 --> 00:20:26,590
which is which you can't just say from

00:20:25,090 --> 00:20:28,890
the structure of it what is the guest

00:20:26,590 --> 00:20:34,000
visible and what is the backend info in

00:20:28,890 --> 00:20:35,620
general and it would be really nice if

00:20:34,000 --> 00:20:39,220
it was a format that already existed

00:20:35,620 --> 00:20:41,500
because you know there's less to

00:20:39,220 --> 00:20:43,180
implement and usually if you try to make

00:20:41,500 --> 00:20:44,860
a new format to consolidate existing

00:20:43,180 --> 00:20:51,670
ones of course you just end up with more

00:20:44,860 --> 00:20:57,760
formats so what are duplicate a slide

00:20:51,670 --> 00:21:00,040
here oops yes I do what are the options

00:20:57,760 --> 00:21:01,510
well from the precise end before I've

00:21:00,040 --> 00:21:04,570
seen this kind of for down that end

00:21:01,510 --> 00:21:09,490
there's libvirt domain XML in some cases

00:21:04,570 --> 00:21:11,650
there's Q death itself there's a CPI

00:21:09,490 --> 00:21:13,780
which the guest users and their advice

00:21:11,650 --> 00:21:15,280
trees I'm not going to talk about a CPI

00:21:13,780 --> 00:21:17,770
at all because I don't know anything

00:21:15,280 --> 00:21:22,000
about it I suspect it's uncontroversial

00:21:17,770 --> 00:21:24,870
that that's a bad idea um so live that

00:21:22,000 --> 00:21:29,590
domain XML I think this is a bad idea

00:21:24,870 --> 00:21:31,330
but just to talk about it XML has a

00:21:29,590 --> 00:21:33,700
natural hierarchy of course but the X

00:21:31,330 --> 00:21:37,360
the hierarchy in the liver domain XML

00:21:33,700 --> 00:21:38,440
does not match the bus hierarchy instead

00:21:37,360 --> 00:21:40,420
you'd have to construct the bus

00:21:38,440 --> 00:21:42,790
hierarchy by setting the bus addresses

00:21:40,420 --> 00:21:45,040
on your various devices which is a bit

00:21:42,790 --> 00:21:46,960
awkward as I was saying before the

00:21:45,040 --> 00:21:49,900
guests in the back end info is mixed and

00:21:46,960 --> 00:21:52,270
yes if you know all the elements of the

00:21:49,900 --> 00:21:55,090
domain XML then you can identify which

00:21:52,270 --> 00:21:57,760
elements are guest visible and which are

00:21:55,090 --> 00:21:59,290
back in but you have to know that you

00:21:57,760 --> 00:22:01,210
know those are a different set of things

00:21:59,290 --> 00:22:05,050
you need to know about a nic entry or a

00:22:01,210 --> 00:22:07,630
storage entry or so forth are the little

00:22:05,050 --> 00:22:09,970
bit XML even at its precise and even the

00:22:07,630 --> 00:22:12,100
final form before it starts the vm

00:22:09,970 --> 00:22:16,480
doesn't include system devices so here

00:22:12,100 --> 00:22:19,390
I'm thinking things like RTC's system

00:22:16,480 --> 00:22:24,370
clocks things like the root pci bridge

00:22:19,390 --> 00:22:25,660
on most platforms at the x86 and those

00:22:24,370 --> 00:22:27,700
other things that you tend not to think

00:22:25,660 --> 00:22:31,149
about because the the colonel just uses

00:22:27,700 --> 00:22:35,649
them and they're there

00:22:31,149 --> 00:22:37,029
and you know that that that can be an

00:22:35,649 --> 00:22:38,379
issue because you can get different

00:22:37,029 --> 00:22:41,109
variants of the machine which have new

00:22:38,379 --> 00:22:44,639
models change models of those and it

00:22:41,109 --> 00:22:49,239
does matter for migration and so forth

00:22:44,639 --> 00:22:52,839
and another sort of Lusa thing here is

00:22:49,239 --> 00:22:54,999
that if you get a bit of libvirt domain

00:22:52,839 --> 00:22:56,739
xml you don't necessarily know whether

00:22:54,999 --> 00:22:58,029
this is that this is what when into

00:22:56,739 --> 00:23:00,190
libvirt and is a fairly loose

00:22:58,029 --> 00:23:03,099
description or if it's what came out of

00:23:00,190 --> 00:23:06,099
libvirt and had been made as precise as

00:23:03,099 --> 00:23:08,469
as libvirt makes it plus of course some

00:23:06,099 --> 00:23:10,450
people don't like parsing XML so in

00:23:08,469 --> 00:23:13,749
short I don't think Liberty XML is a

00:23:10,450 --> 00:23:15,749
good idea that leaves basically two

00:23:13,749 --> 00:23:19,149
formats which I'm going to talk about

00:23:15,749 --> 00:23:22,259
cued of itself in some linearized form

00:23:19,149 --> 00:23:24,219
and the flattened device tree now I

00:23:22,259 --> 00:23:26,830
don't actually have a recommendation

00:23:24,219 --> 00:23:30,210
here when I was first writing this I

00:23:26,830 --> 00:23:32,830
thought I'd be recommending device tree

00:23:30,210 --> 00:23:34,599
but I am biased of course because I

00:23:32,830 --> 00:23:39,309
wrote tools to do with flattened device

00:23:34,599 --> 00:23:42,009
tree and then I looked at what would be

00:23:39,309 --> 00:23:44,109
involved and half convinced myself that

00:23:42,009 --> 00:23:46,839
it would actually be a lot of work and

00:23:44,109 --> 00:23:48,279
not a very good idea and then I heard

00:23:46,839 --> 00:23:49,950
just the other day that the xilinx

00:23:48,279 --> 00:23:52,659
people are actually doing this already

00:23:49,950 --> 00:23:55,389
ah and that makes it sound a bit more

00:23:52,659 --> 00:23:57,539
plausible again so two possible options

00:23:55,389 --> 00:24:00,159
here I don't know which is the best one

00:23:57,539 --> 00:24:04,929
flattened device tree so it's used by

00:24:00,159 --> 00:24:09,609
all power pc linux kernel's some arm and

00:24:04,929 --> 00:24:12,999
some other architectures as well ah it's

00:24:09,609 --> 00:24:15,519
very easy the pars from machine their

00:24:12,999 --> 00:24:17,830
existing tools it doesn't contain any

00:24:15,519 --> 00:24:19,210
back-end information at all so that

00:24:17,830 --> 00:24:20,499
would how it would have to be augmented

00:24:19,210 --> 00:24:25,239
with extra information on the backend

00:24:20,499 --> 00:24:27,460
and in the easy cases it lines up nicely

00:24:25,239 --> 00:24:30,039
to q om and would be quite easy to

00:24:27,460 --> 00:24:32,469
convert but there can be a bunch of

00:24:30,039 --> 00:24:34,809
harder cases in particular there are

00:24:32,469 --> 00:24:37,179
some awkward places where the device

00:24:34,809 --> 00:24:40,749
tree is a bit redundant and that's and

00:24:37,179 --> 00:24:42,219
redundancy obviously is it something you

00:24:40,749 --> 00:24:44,090
don't want in a format using to

00:24:42,219 --> 00:24:46,370
configure qmu because it

00:24:44,090 --> 00:24:48,049
means that you know you have to set

00:24:46,370 --> 00:24:52,640
things up in two places and that's

00:24:48,049 --> 00:24:55,669
awkward on the other hand so the other I

00:24:52,640 --> 00:24:58,159
guess the simplest approach from qm use

00:24:55,669 --> 00:25:01,669
point of view is just to lunar linearize

00:24:58,159 --> 00:25:03,830
the existing qm info linearizing it

00:25:01,669 --> 00:25:06,730
isn't terribly hard qmu already uses

00:25:03,830 --> 00:25:10,970
jason linearization of various

00:25:06,730 --> 00:25:12,529
structures for qmp and other things so

00:25:10,970 --> 00:25:14,840
you can make something based on that to

00:25:12,529 --> 00:25:17,480
linearize the the existing hardware

00:25:14,840 --> 00:25:21,520
description it already kept the backend

00:25:17,480 --> 00:25:24,350
and guest visible information separate

00:25:21,520 --> 00:25:28,190
included in queue ohms case basically by

00:25:24,350 --> 00:25:30,620
having the tree of guest visible objects

00:25:28,190 --> 00:25:32,960
separate from the other objects that are

00:25:30,620 --> 00:25:35,960
are used by the back end but I'm not

00:25:32,960 --> 00:25:37,820
directly guest visible so queuing me or

00:25:35,960 --> 00:25:39,289
is it has like the drive object which is

00:25:37,820 --> 00:25:41,240
the back end separate from the actual

00:25:39,289 --> 00:25:44,270
skazhi dis got the object which is the

00:25:41,240 --> 00:25:48,770
guest visible device it does obviously

00:25:44,270 --> 00:25:52,070
tie this quite directly to the way qmu

00:25:48,770 --> 00:25:59,059
does things and it might make future

00:25:52,070 --> 00:26:00,860
changes more difficult by a to an extent

00:25:59,059 --> 00:26:02,539
the Kurian model is already an exposed

00:26:00,860 --> 00:26:05,210
interface because a lot of it can be

00:26:02,539 --> 00:26:07,460
examined with qmp but this would make it

00:26:05,210 --> 00:26:09,559
even more exposed and therefore harder

00:26:07,460 --> 00:26:11,240
to change in future I don't think any of

00:26:09,559 --> 00:26:12,980
these are insurmountable problems with

00:26:11,240 --> 00:26:17,480
either of these formats actually but you

00:26:12,980 --> 00:26:19,730
know they are difficulties so almost

00:26:17,480 --> 00:26:23,690
done so the question is how do we get

00:26:19,730 --> 00:26:25,789
from where we are now to somewhere like

00:26:23,690 --> 00:26:27,950
this obviously the first thing is

00:26:25,789 --> 00:26:29,649
consensus amongst developers of Q mu and

00:26:27,950 --> 00:26:33,909
libvirt that this is a good idea or

00:26:29,649 --> 00:26:33,909
another idea that is something like it

00:26:34,240 --> 00:26:41,470
the next step is splitting the machine

00:26:37,880 --> 00:26:44,480
type as described that can be done that

00:26:41,470 --> 00:26:46,100
doesn't depend on exactly how you format

00:26:44,480 --> 00:26:48,140
the information so that that's something

00:26:46,100 --> 00:26:50,779
that could be proceeded with relatively

00:26:48,140 --> 00:26:52,760
directly the biggest problem is just

00:26:50,779 --> 00:26:54,590
finding it does affect a lot of places

00:26:52,760 --> 00:26:55,850
in the tree obviously and given the

00:26:54,590 --> 00:26:56,780
amount of time we've taken just to

00:26:55,850 --> 00:26:59,460
convert

00:26:56,780 --> 00:27:02,160
existing machine types to the QAM model

00:26:59,460 --> 00:27:04,320
you know sort of shows how big how big

00:27:02,160 --> 00:27:05,820
an undertaking is to make tree wide

00:27:04,320 --> 00:27:09,170
changes like that so it's a question of

00:27:05,820 --> 00:27:11,990
having enough people with enough time

00:27:09,170 --> 00:27:14,730
then in a matter of choosing a format

00:27:11,990 --> 00:27:18,090
implementing the import and export of it

00:27:14,730 --> 00:27:20,070
and work out to other work with their

00:27:18,090 --> 00:27:22,950
work outwards to other parts of the

00:27:20,070 --> 00:27:24,720
stack from there this is something I

00:27:22,950 --> 00:27:26,970
certainly hope that I will be able to

00:27:24,720 --> 00:27:30,540
work on but it's not something i could

00:27:26,970 --> 00:27:33,300
do alone and it's not kind of my primary

00:27:30,540 --> 00:27:34,980
work so i don't know how much time i'll

00:27:33,300 --> 00:27:37,230
have for it but it's something i hope

00:27:34,980 --> 00:27:41,070
will happen i hope i can help may happen

00:27:37,230 --> 00:27:44,970
so there we go we do have a few minutes

00:27:41,070 --> 00:27:48,300
left that's where the slides are if you

00:27:44,970 --> 00:27:51,990
want and we have question oh sorry I

00:27:48,300 --> 00:27:54,270
would just say before that Eduardo and I

00:27:51,990 --> 00:27:57,840
are kind of having a joint both on

00:27:54,270 --> 00:27:59,370
roughly this topic well almost

00:27:57,840 --> 00:28:03,450
immediately in fact in the in the boss

00:27:59,370 --> 00:28:06,150
lot so I was wondering if we really need

00:28:03,450 --> 00:28:08,280
libvirt in that whole mechanism because

00:28:06,150 --> 00:28:11,430
I mean the only thing that we want to do

00:28:08,280 --> 00:28:13,710
is to my crate a guest completely right

00:28:11,430 --> 00:28:16,080
so can we like just put that information

00:28:13,710 --> 00:28:18,840
into the migration migration stream

00:28:16,080 --> 00:28:21,690
start um you with the special mode and

00:28:18,840 --> 00:28:24,870
and like do that like without any

00:28:21,690 --> 00:28:27,120
liberal changes necessary just like my

00:28:24,870 --> 00:28:31,380
that would be my take you could

00:28:27,120 --> 00:28:32,640
absolutely you could absolutely and

00:28:31,380 --> 00:28:33,960
putting that information in the

00:28:32,640 --> 00:28:37,290
migration stream i think is a good idea

00:28:33,960 --> 00:28:39,210
arm that wouldn't make no libvirt

00:28:37,290 --> 00:28:40,950
changes necessary in a sense because at

00:28:39,210 --> 00:28:42,570
the very least liver would need to stop

00:28:40,950 --> 00:28:44,730
trying to construct the machine at the

00:28:42,570 --> 00:28:46,790
far end if existing tools are using

00:28:44,730 --> 00:28:49,320
liver to migrate and lots of them are

00:28:46,790 --> 00:28:52,650
libvirt is very well established in a

00:28:49,320 --> 00:28:54,510
bunch of places and i think we need to

00:28:52,650 --> 00:28:58,080
work with libvirt whether or not you

00:28:54,510 --> 00:28:59,740
have to work with libvirt yeah changes

00:28:58,080 --> 00:29:02,230
to make it possible

00:28:59,740 --> 00:29:06,480
now have that much compared to like

00:29:02,230 --> 00:29:09,550
getting full machine description right

00:29:06,480 --> 00:29:11,440
I'm not sure that's true I I don't in

00:29:09,550 --> 00:29:13,090
this information that Google just like

00:29:11,440 --> 00:29:17,890
take it and hand it to a lot of care

00:29:13,090 --> 00:29:22,809
nothing to do so I make sure maybe not

00:29:17,890 --> 00:29:24,040
maybe not Alex so for starters actually

00:29:22,809 --> 00:29:25,570
like the idea that there are multiple

00:29:24,040 --> 00:29:27,160
problems you're trying to solve sorry

00:29:25,570 --> 00:29:28,540
you know there are a multitude of

00:29:27,160 --> 00:29:30,370
problems you're trying to solve yes

00:29:28,540 --> 00:29:32,080
there are there's the the general

00:29:30,370 --> 00:29:34,570
problem that viewing live migration you

00:29:32,080 --> 00:29:35,980
don't know which so why you can save the

00:29:34,570 --> 00:29:37,360
original command line you don't know

00:29:35,980 --> 00:29:39,370
that you buzz your hot plug added and

00:29:37,360 --> 00:29:42,190
removed in between exactly so you need

00:29:39,370 --> 00:29:44,410
to have basically to solve the hot pop

00:29:42,190 --> 00:29:47,679
the hot plug and live migration issue

00:29:44,410 --> 00:29:49,780
you know that we have a a thing in Hulme

00:29:47,679 --> 00:29:52,350
you where you can see realize all of the

00:29:49,780 --> 00:29:55,480
command line switches and read from them

00:29:52,350 --> 00:29:58,270
the the stuff that get I don't know five

00:29:55,480 --> 00:30:00,640
six years ago which basically I forgot

00:29:58,270 --> 00:30:03,670
what it was called safe something right

00:30:00,640 --> 00:30:05,320
we'd config and right config right okay

00:30:03,670 --> 00:30:07,630
so you can did not know about those to

00:30:05,320 --> 00:30:10,809
exist which serialize the config space

00:30:07,630 --> 00:30:13,300
if you could extend those to just take

00:30:10,809 --> 00:30:14,920
hot plug stuff into account maybe you

00:30:13,300 --> 00:30:18,429
could just reuse those it's an existing

00:30:14,920 --> 00:30:20,380
format it's any style it does have

00:30:18,429 --> 00:30:23,410
everything you need to basically create

00:30:20,380 --> 00:30:26,110
command line parameters it basically

00:30:23,410 --> 00:30:30,040
solves the hot plug on migration problem

00:30:26,110 --> 00:30:31,990
it does not yet solve you the I want to

00:30:30,040 --> 00:30:34,059
bundle a machine description and the

00:30:31,990 --> 00:30:35,860
Machine files together problem which is

00:30:34,059 --> 00:30:37,809
another one that actually is really dear

00:30:35,860 --> 00:30:40,990
to me rather most of the other half of

00:30:37,809 --> 00:30:43,330
our visors have a mechanism to give you

00:30:40,990 --> 00:30:45,400
an image and the description on how to

00:30:43,330 --> 00:30:47,110
start this image and in cute in the Q mu

00:30:45,400 --> 00:30:49,150
world you / give people an image and

00:30:47,110 --> 00:30:52,150
then tell them to do something with it

00:30:49,150 --> 00:30:55,000
so yes a shell script for example which

00:30:52,150 --> 00:30:57,010
is usually a pretty bad idea yep so so

00:30:55,000 --> 00:31:00,550
we are definitely liking some mechanism

00:30:57,010 --> 00:31:02,980
to give people something in their hands

00:31:00,550 --> 00:31:04,570
that they can just run a vm without

00:31:02,980 --> 00:31:06,340
worrying about anything at all it will

00:31:04,570 --> 00:31:09,040
just contain information like I need 1

00:31:06,340 --> 00:31:12,190
gig of ram I need any specific case is

00:31:09,040 --> 00:31:13,420
exactly what I'm getting at here um one

00:31:12,190 --> 00:31:16,930
actually potential bone

00:31:13,420 --> 00:31:20,890
to this is it does have the potential to

00:31:16,930 --> 00:31:22,420
make to make it easier to be disciplined

00:31:20,890 --> 00:31:24,520
about machine types at the moment we

00:31:22,420 --> 00:31:26,680
have to be very very careful that for

00:31:24,520 --> 00:31:29,800
any kind of version of qmu that people

00:31:26,680 --> 00:31:31,360
have seen and used the version of

00:31:29,800 --> 00:31:34,540
machine types have to stay the same

00:31:31,360 --> 00:31:38,230
forever now this would potentially make

00:31:34,540 --> 00:31:41,710
it easier to maintain that if the

00:31:38,230 --> 00:31:43,000
version forever versions are I've given

00:31:41,710 --> 00:31:50,220
this detailed description that you're

00:31:43,000 --> 00:31:50,220
putting back in whereas your when you

00:31:51,120 --> 00:31:57,850
sorry I'm just getting myself very

00:31:54,070 --> 00:32:00,010
confused but I think doing this because

00:31:57,850 --> 00:32:02,020
users have the option when they need a

00:32:00,010 --> 00:32:06,010
very precise hardware setup of doing it

00:32:02,020 --> 00:32:10,630
directly it gives you more flexibility

00:32:06,010 --> 00:32:13,720
to be less precise and less exactly the

00:32:10,630 --> 00:32:15,850
same overall time about your easy

00:32:13,720 --> 00:32:17,650
configuration method your your friendly

00:32:15,850 --> 00:32:19,330
and loose configuration method the

00:32:17,650 --> 00:32:21,070
further configuration is really just the

00:32:19,330 --> 00:32:22,690
is the back ends that's all your

00:32:21,070 --> 00:32:25,360
configure you just say my disk image

00:32:22,690 --> 00:32:27,310
called a is there and that is a point of

00:32:25,360 --> 00:32:29,080
year for gaas the vm is set in stone the

00:32:27,310 --> 00:32:32,110
way the way the vm looks like i said on

00:32:29,080 --> 00:32:33,880
the config file right well yes and what

00:32:32,110 --> 00:32:36,370
you would need to do on migration which

00:32:33,880 --> 00:32:38,710
does you would need to provide back in

00:32:36,370 --> 00:32:40,420
information on the destination and you

00:32:38,710 --> 00:32:42,850
then need to validate that it contains

00:32:40,420 --> 00:32:45,940
all the backends that your machine

00:32:42,850 --> 00:32:47,800
description needs yes but you do need to

00:32:45,940 --> 00:32:49,720
do the same if you do read config and

00:32:47,800 --> 00:32:52,270
that's a problem let's face it this is

00:32:49,720 --> 00:32:53,830
roughly where girls stop back then they

00:32:52,270 --> 00:32:55,330
this is actually getting a long

00:32:53,830 --> 00:32:57,100
discussion how about we we can

00:32:55,330 --> 00:32:59,560
definitely take this to the bar but I

00:32:57,100 --> 00:33:01,870
really I would really encourage you I do

00:32:59,560 --> 00:33:03,820
not believe we need to change any q me

00:33:01,870 --> 00:33:06,460
on channels introduce new random buses

00:33:03,820 --> 00:33:08,620
that mutton record anything at all there

00:33:06,460 --> 00:33:10,960
I do believe that should be doable with

00:33:08,620 --> 00:33:12,310
the infrastructure we have today I don't

00:33:10,960 --> 00:33:13,960
think you need you need any any

00:33:12,310 --> 00:33:17,800
intrusive changes you could just use we

00:33:13,960 --> 00:33:20,190
convict right config extend them to take

00:33:17,800 --> 00:33:23,590
somehow the hot plug stuff into account

00:33:20,190 --> 00:33:25,210
and then have some sanity is checking

00:33:23,590 --> 00:33:27,260
mechanism that allows you to verify

00:33:25,210 --> 00:33:29,030
whether you plug all the back

00:33:27,260 --> 00:33:39,980
in on the command line when you booted

00:33:29,030 --> 00:33:41,600
okay well come on otherwise right now

00:33:39,980 --> 00:33:43,760
the passing of the command line

00:33:41,600 --> 00:33:46,250
arguments and the creation of the

00:33:43,760 --> 00:33:49,070
machine is basically intermediate it's

00:33:46,250 --> 00:33:51,290
not easy to get them together this is

00:33:49,070 --> 00:33:52,640
other of the problem that we have now we

00:33:51,290 --> 00:33:55,640
are doing the two things at the same

00:33:52,640 --> 00:33:57,140
time we are not passing all the common

00:33:55,640 --> 00:34:00,050
line all the configuration files

00:33:57,140 --> 00:34:02,980
whatever we create one it infrastructure

00:34:00,050 --> 00:34:05,660
that is the thing that we need to save a

00:34:02,980 --> 00:34:08,120
configuration and then we create from

00:34:05,660 --> 00:34:10,190
there the machine no we are we are doing

00:34:08,120 --> 00:34:13,520
that intermingle that is the problem

00:34:10,190 --> 00:34:15,110
that we have yeah um so this all sounds

00:34:13,520 --> 00:34:17,510
like interesting discussion but however

00:34:15,110 --> 00:34:19,399
we move that to the bath and I actually

00:34:17,510 --> 00:34:21,110
have people whoever questions ask them

00:34:19,399 --> 00:34:23,810
actually I have a very short question

00:34:21,110 --> 00:34:27,110
can you show previous slide please which

00:34:23,810 --> 00:34:31,100
starts a previous one this one yes

00:34:27,110 --> 00:34:35,330
exactly ah not one this one you see

00:34:31,100 --> 00:34:37,970
about point one you should not achieve a

00:34:35,330 --> 00:34:42,010
consensus not between p.m. and live

00:34:37,970 --> 00:34:45,770
third but about people using libvirt

00:34:42,010 --> 00:34:47,899
because you would like to change a wide

00:34:45,770 --> 00:34:50,810
description which is used by OpenStack

00:34:47,899 --> 00:34:53,000
and all other people well they don't

00:34:50,810 --> 00:34:55,159
like I say it doesn't have to be that

00:34:53,000 --> 00:34:56,419
way they could use this if they wanted

00:34:55,159 --> 00:34:57,920
to but that certainly doesn't happen

00:34:56,419 --> 00:34:59,930
happen the shorter and that's kind of

00:34:57,920 --> 00:35:03,530
further in the future if they want to

00:34:59,930 --> 00:35:06,590
change yes and if they are spoken about

00:35:03,530 --> 00:35:08,900
the future we should take into account

00:35:06,590 --> 00:35:15,410
opinion people using this interface

00:35:08,900 --> 00:35:17,360
that's true yes yes so first to comment

00:35:15,410 --> 00:35:19,610
I believe in most places where you've

00:35:17,360 --> 00:35:21,290
actually talked about Q dev and Q dev

00:35:19,610 --> 00:35:23,300
tree I believe you should actually be

00:35:21,290 --> 00:35:25,430
looking at the quam tree instead because

00:35:23,300 --> 00:35:27,260
if you look at the Q dev tree then you

00:35:25,430 --> 00:35:28,910
have a bus only view of the system

00:35:27,260 --> 00:35:34,220
devices and you're gonna miss a bunch of

00:35:28,910 --> 00:35:37,160
modern devices yes possibly sorry i

00:35:34,220 --> 00:35:41,480
haven't been terribly precise in my use

00:35:37,160 --> 00:35:45,859
of q dev vs kom i think initially I was

00:35:41,480 --> 00:35:48,140
I was talking about Q dev to represent

00:35:45,859 --> 00:35:50,180
the the guest visible devices as opposed

00:35:48,140 --> 00:35:55,640
to the QAM objects which are not guests

00:35:50,180 --> 00:35:56,690
visible but that may not be I know I

00:35:55,640 --> 00:35:59,000
don't think I've used those terms

00:35:56,690 --> 00:36:01,550
terribly well so yes sir probably

00:35:59,000 --> 00:36:03,500
apologies for that so and we've been

00:36:01,550 --> 00:36:06,470
trying to actually get rid of that

00:36:03,500 --> 00:36:08,720
strict bus structure in that that could

00:36:06,470 --> 00:36:11,990
have imposed on us so I really second

00:36:08,720 --> 00:36:13,850
the notion that sub classing sis bus is

00:36:11,990 --> 00:36:15,500
not really the way to go when you know

00:36:13,850 --> 00:36:18,200
other people actually trying to actually

00:36:15,500 --> 00:36:20,450
preserve the the cool infrastructure

00:36:18,200 --> 00:36:21,950
that those devices are giving us but not

00:36:20,450 --> 00:36:24,740
really seeing any need for this bus

00:36:21,950 --> 00:36:26,390
anymore ok well let's discuss this upper

00:36:24,740 --> 00:36:29,300
right and above so and then the main

00:36:26,390 --> 00:36:31,609
question is I didn't really understand

00:36:29,300 --> 00:36:33,500
why you feel that you need to export or

00:36:31,609 --> 00:36:35,480
import any file format for this

00:36:33,500 --> 00:36:37,340
representation at all if you actually

00:36:35,480 --> 00:36:39,080
want to know what the guest is doing

00:36:37,340 --> 00:36:40,820
then libvirt can just use the qmp

00:36:39,080 --> 00:36:42,740
interface to get that into that

00:36:40,820 --> 00:36:45,410
information from here you directly and

00:36:42,740 --> 00:36:48,260
we do have lots lots of imposed ABI

00:36:45,410 --> 00:36:50,300
stability rules to to actually make this

00:36:48,260 --> 00:36:52,310
work there were even you know properties

00:36:50,300 --> 00:36:54,410
being added specifically for the broad

00:36:52,310 --> 00:36:59,300
which then somehow the good ended up not

00:36:54,410 --> 00:37:02,750
using yeah it's not essential but i

00:36:59,300 --> 00:37:04,790
think i think the easier it is to get

00:37:02,750 --> 00:37:07,220
this data in and out the more likely

00:37:04,790 --> 00:37:11,510
it's it is to be used correctly or used

00:37:07,220 --> 00:37:13,580
productively likely but could do this or

00:37:11,510 --> 00:37:15,230
any other tool could do this but if it's

00:37:13,580 --> 00:37:16,970
easy to get in and out I think that's

00:37:15,230 --> 00:37:19,100
going to improve the state of affairs

00:37:16,970 --> 00:37:21,170
right what do you need to get it in for

00:37:19,100 --> 00:37:24,109
I mean I would we already have scripts

00:37:21,170 --> 00:37:25,910
that do that in Python to get in so that

00:37:24,109 --> 00:37:27,950
you can construct them so if you've got

00:37:25,910 --> 00:37:29,750
if you've previously extracted the

00:37:27,950 --> 00:37:31,580
precise hardware configuration of a

00:37:29,750 --> 00:37:33,350
machine you can construct a new

00:37:31,580 --> 00:37:35,570
identical machine which you want to do

00:37:33,350 --> 00:37:38,119
in migration for certain and you may

00:37:35,570 --> 00:37:39,590
also want to do in other cases right but

00:37:38,119 --> 00:37:41,240
you can just set the properties directly

00:37:39,590 --> 00:37:43,540
since you already have the objects

00:37:41,240 --> 00:37:47,060
created from the machine construction

00:37:43,540 --> 00:37:49,220
well no but I'm talking about bypassing

00:37:47,060 --> 00:37:52,420
all that logic that sets up and applies

00:37:49,220 --> 00:37:52,420
defaults and all that because

00:37:57,600 --> 00:38:01,540
right again but it's it's a whole

00:38:00,220 --> 00:38:02,890
complicated process you've got to create

00:38:01,540 --> 00:38:05,350
all the devices in the right order

00:38:02,890 --> 00:38:06,820
you've got to set the properties on them

00:38:05,350 --> 00:38:09,160
hope they don't have any old

00:38:06,820 --> 00:38:10,720
interactions if you've got just a blob

00:38:09,160 --> 00:38:13,000
that you can feed it as one unit that's

00:38:10,720 --> 00:38:15,610
a lot easier to work with as an external

00:38:13,000 --> 00:38:17,860
tool or a direct user if you're testing

00:38:15,610 --> 00:38:20,140
it right but that was pretty much what

00:38:17,860 --> 00:38:23,700
the config files please you know these

00:38:20,140 --> 00:38:26,940
are what can also be written by the

00:38:23,700 --> 00:38:29,590
right config and so on was actually an

00:38:26,940 --> 00:38:31,210
Anthony's motivation for writing this

00:38:29,590 --> 00:38:32,890
whole qm think so that you can have a

00:38:31,210 --> 00:38:35,140
config file that describes the machine

00:38:32,890 --> 00:38:36,580
and then creates the devices the way

00:38:35,140 --> 00:38:37,780
they would be swell it absolutely sounds

00:38:36,580 --> 00:38:46,630
like I need to look at that in more

00:38:37,780 --> 00:38:49,560
detail so i believe the problem with the

00:38:46,630 --> 00:38:52,120
weed confined in a white config it

00:38:49,560 --> 00:38:53,890
ignores completely what's done by the

00:38:52,120 --> 00:38:56,110
machine types today so we have lots of

00:38:53,890 --> 00:38:58,330
stuff that's inside machine type code we

00:38:56,110 --> 00:39:01,770
want to bypass that and read config

00:38:58,330 --> 00:39:01,770
right you don't have that information

00:39:02,010 --> 00:39:07,210
you can use the existing format file and

00:39:05,410 --> 00:39:08,860
the existing infrastructure to create

00:39:07,210 --> 00:39:10,810
additional devices that the machine does

00:39:08,860 --> 00:39:12,100
not create as such so there is the

00:39:10,810 --> 00:39:14,110
infrastructure for getting all the

00:39:12,100 --> 00:39:16,240
information in and there is information

00:39:14,110 --> 00:39:17,440
forgetting there's ways for getting the

00:39:16,240 --> 00:39:20,070
information out already without

00:39:17,440 --> 00:39:22,690
inventing any I don't you mentioned some

00:39:20,070 --> 00:39:25,510
flattened or whatever linearized quam

00:39:22,690 --> 00:39:26,950
formats so I well I the way I'm looking

00:39:25,510 --> 00:39:28,660
at that is it sounds like this rate

00:39:26,950 --> 00:39:30,850
there is already a linearized Guam

00:39:28,660 --> 00:39:33,970
format which I was not aware of so it's

00:39:30,850 --> 00:39:41,860
nice to be made aware of that so that is

00:39:33,970 --> 00:39:44,560
absolutely something line okay so well

00:39:41,860 --> 00:39:47,290
you may not be aware of some of the

00:39:44,560 --> 00:39:50,790
history of libvirt but I think if I'm a

00:39:47,290 --> 00:39:54,700
no today yeah if you were if you were

00:39:50,790 --> 00:39:56,320
wanting to propose that libvirt use some

00:39:54,700 --> 00:40:00,010
other method of describing machines

00:39:56,320 --> 00:40:01,630
other than XML you should have done that

00:40:00,010 --> 00:40:05,349
10 years ago

00:40:01,630 --> 00:40:09,549
sickly well bear in mind i'm not i'm not

00:40:05,349 --> 00:40:14,650
suggesting replacing the xml i'm

00:40:09,549 --> 00:40:18,549
suggesting that the xml remain the the

00:40:14,650 --> 00:40:19,930
generic way of describing a machine to

00:40:18,549 --> 00:40:21,940
the extent that it is possible to

00:40:19,930 --> 00:40:24,579
generally describe a machine and that

00:40:21,940 --> 00:40:28,349
the this other thing which might be a

00:40:24,579 --> 00:40:32,920
raid config or whatever are be

00:40:28,349 --> 00:40:34,059
essentially acacia back in its this this

00:40:32,920 --> 00:40:36,490
description would be owned by the

00:40:34,059 --> 00:40:40,480
backend driver but all of that

00:40:36,490 --> 00:40:41,529
information is in the xml or if there's

00:40:40,480 --> 00:40:46,920
something that's missing that's

00:40:41,529 --> 00:40:46,920
necessary then it can be put in but

00:40:57,450 --> 00:41:01,470
but what you're saying then is that you

00:40:59,460 --> 00:41:02,760
want to you want liver to store

00:41:01,470 --> 00:41:05,970
something else in its configuration

00:41:02,760 --> 00:41:09,359
which which 44 libvirt means storing it

00:41:05,970 --> 00:41:11,700
in the XML in some way well the problem

00:41:09,359 --> 00:41:13,950
in this case is is we want to avoid

00:41:11,700 --> 00:41:17,400
tracking things in parallel between Q

00:41:13,950 --> 00:41:19,829
and libvirt and if they're to be stored

00:41:17,400 --> 00:41:21,839
in livered XML really at any stage that

00:41:19,829 --> 00:41:25,230
means extracting the information from Q

00:41:21,839 --> 00:41:27,270
mu and converting it into XML which you

00:41:25,230 --> 00:41:36,030
can do if you really want but it sounds

00:41:27,270 --> 00:41:37,900
like a unpleasant task so you could

00:41:36,030 --> 00:41:44,260
write that into the exam

00:41:37,900 --> 00:41:48,700
if you really it's but the the

00:41:44,260 --> 00:41:51,940
information the necessary information is

00:41:48,700 --> 00:41:53,680
already in the XML no it's not if it

00:41:51,940 --> 00:41:58,780
wasn't it wouldn't be possible to

00:41:53,680 --> 00:42:01,180
migrate it is but only it is but it's

00:41:58,780 --> 00:42:03,100
fragile he is yeah I would agree with

00:42:01,180 --> 00:42:06,660
that and I think that what you're very

00:42:03,100 --> 00:42:09,070
very fragile enabled being able to query

00:42:06,660 --> 00:42:11,500
exactly what his enemy Xin type is a

00:42:09,070 --> 00:42:16,690
very useful thing that that we would

00:42:11,500 --> 00:42:18,130
welcome but and maybe I'm

00:42:16,690 --> 00:42:23,320
misunderstanding a bit of what you're

00:42:18,130 --> 00:42:24,910
saying about that but a well libert is

00:42:23,320 --> 00:42:27,700
still going to have all the information

00:42:24,910 --> 00:42:30,400
about the PCI addresses of every device

00:42:27,700 --> 00:42:35,290
and all of that in its that can't go

00:42:30,400 --> 00:42:45,340
away why not because the information

00:42:35,290 --> 00:42:48,730
that's going to be there I know if you

00:42:45,340 --> 00:42:50,230
don't do it look we're about 10 minutes

00:42:48,730 --> 00:42:52,060
over at this point how about we are

00:42:50,230 --> 00:42:53,380
doing to the other room and begin the

00:42:52,060 --> 00:42:55,390
ball because it sounds like we have

00:42:53,380 --> 00:42:57,700
already XML then the management

00:42:55,390 --> 00:43:02,230
applications don't have access to it it

00:42:57,700 --> 00:43:05,650
has to be there that's you you can't not

00:43:02,230 --> 00:43:07,480
have that what you're saying is the

00:43:05,650 --> 00:43:10,030
tight information you can't not have

00:43:07,480 --> 00:43:14,080
that in the XML I see what you're

00:43:10,030 --> 00:43:17,130
getting at bap bap bap bap bap bap bap

00:43:14,080 --> 00:43:17,130

YouTube URL: https://www.youtube.com/watch?v=kzwhizO1Azs


