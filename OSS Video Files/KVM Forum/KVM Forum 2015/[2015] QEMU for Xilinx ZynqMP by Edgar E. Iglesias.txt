Title: [2015] QEMU for Xilinx ZynqMP by Edgar E. Iglesias
Publication date: 2015-08-27
Playlist: KVM Forum 2015
Description: 
	QEMU for Xilinx ZynqMP QEMU can be a great tool to enable early software development for hardware that is still under design. In this talk, Edgar will cover some of the challenges we faced and the solutions we chose when using QEMU to model the Xilinx ZynqMP SoC. The topics will include:

* ARMv8 TrustZone and Virtualization modeling
* Per CPU/Master address-spaces and Memory Attributes
* Modeling of Heterogeneous CPU architectures
* Real-life Co-simulation of QEMU with System-C and RTL (with open-source tools)
* Machine creation from Flat Device Trees
* Binary tracing and code-coverage

The talk will also go through our collaboration with upstream, upstreams current state and future challenges in these areas. 

Edgar E. Iglesias
Xilinx

Edgar E. Iglesias currently works as a Senior Staff Software Engineer at Xilinx. Some of his areas of interest include computer architecture, emulation, virtualization and low-level software. Edgar is a long time contributor to QEMU and has been involved in various other open-source projects. Edgar has previously spoken at various conferences including the Embedded Linux Conference.
Captions: 
	00:00:00,000 --> 00:00:28,140
by gar Iglesias I work for sigh links

00:00:25,080 --> 00:00:32,870
and I'll be talking today about how we

00:00:28,140 --> 00:00:40,250
use qmo and in our chip development and

00:00:32,870 --> 00:00:48,300
you know early software development okay

00:00:40,250 --> 00:00:50,129
so um I joined Silex early 2013 and at

00:00:48,300 --> 00:00:55,530
that point silence had just started out

00:00:50,129 --> 00:00:58,890
a new chip project and they had pretty

00:00:55,530 --> 00:00:59,690
aggressive targets for how to use qmo

00:00:58,890 --> 00:01:06,990
which was good

00:00:59,690 --> 00:01:10,140
and basically Eamonn was supposed to be

00:01:06,990 --> 00:01:12,590
the first software platform available to

00:01:10,140 --> 00:01:12,590
write software

00:01:13,460 --> 00:01:19,259
and that included boot roms boot loaders

00:01:16,439 --> 00:01:23,150
any kind of firmware hypervisors and

00:01:19,259 --> 00:01:25,350
porting operating systems and so on um

00:01:23,150 --> 00:01:26,580
of course there are a lot of issues with

00:01:25,350 --> 00:01:32,729
this when you're working on an upstream

00:01:26,580 --> 00:01:34,140
project and so schedules if you're if

00:01:32,729 --> 00:01:37,229
you really need to be the first platform

00:01:34,140 --> 00:01:40,040
available um maybe you can't wait until

00:01:37,229 --> 00:01:44,159
things get upstream or there's also

00:01:40,040 --> 00:01:46,770
secrecy involved so and you need to deal

00:01:44,159 --> 00:01:48,600
with kind of these cycles where you hack

00:01:46,770 --> 00:01:51,750
hack hack and then later upstream

00:01:48,600 --> 00:01:55,350
upstream and and so on and that can be

00:01:51,750 --> 00:01:59,610
problematic but um yeah it kind of works

00:01:55,350 --> 00:02:03,740
sometimes sometimes not um there are a

00:01:59,610 --> 00:02:07,079
lot of benefits with using qmo for chip

00:02:03,740 --> 00:02:08,940
development and I mean for software

00:02:07,079 --> 00:02:11,930
development and early when you're

00:02:08,940 --> 00:02:15,090
developing new chips and

00:02:11,930 --> 00:02:16,830
so compared to RTL simulations chiamo is

00:02:15,090 --> 00:02:19,830
much much faster and it's also very easy

00:02:16,830 --> 00:02:23,010
to kind of deploy too many developers

00:02:19,830 --> 00:02:24,570
there's no licensing issues in that

00:02:23,010 --> 00:02:28,890
sense like you have to pay a thousand

00:02:24,570 --> 00:02:30,900
bucks per developer that's like a and I

00:02:28,890 --> 00:02:32,670
want to thank a few people at SCI links

00:02:30,900 --> 00:02:36,180
before I start um

00:02:32,670 --> 00:02:40,470
so John and Peter riser that kind of

00:02:36,180 --> 00:02:44,790
believe in all these projects and been

00:02:40,470 --> 00:02:46,800
supporting us thanks for that and the

00:02:44,790 --> 00:02:49,770
team that has been working I'm styling

00:02:46,800 --> 00:02:52,440
so Alistair is here right there raise

00:02:49,770 --> 00:02:54,780
your hand oh sir doing a lot of good

00:02:52,440 --> 00:02:58,260
stuff and Peter crossed way to the

00:02:54,780 --> 00:03:01,310
unfortunately left stylings so back when

00:02:58,260 --> 00:03:04,590
we started it was Peter and myself and

00:03:01,310 --> 00:03:06,600
Peter did a lot of cool stuff and we did

00:03:04,590 --> 00:03:10,920
a lot of good work there and we're gonna

00:03:06,600 --> 00:03:13,380
miss Peter and sigh who unfortunately

00:03:10,920 --> 00:03:15,959
couldn't come here but he's in our

00:03:13,380 --> 00:03:18,560
Hyderabad office doing a lot of good

00:03:15,959 --> 00:03:22,620
stuff as well so thanks for that

00:03:18,560 --> 00:03:27,090
okay so this is one of the few public

00:03:22,620 --> 00:03:29,280
images of the sink and pee sock and I'm

00:03:27,090 --> 00:03:32,820
sticking to this so I don't leak

00:03:29,280 --> 00:03:37,860
information unintentionally and so if we

00:03:32,820 --> 00:03:39,870
look at it we see that there's a there's

00:03:37,860 --> 00:03:43,340
a real-time processing unit they are PU

00:03:39,870 --> 00:03:47,010
there's an eye a PU and the are PU has

00:03:43,340 --> 00:03:52,320
cortex are 5s and then APU says the

00:03:47,010 --> 00:03:54,930
cortex a53 and then there's you can see

00:03:52,320 --> 00:03:59,220
there's a red box there with a security

00:03:54,930 --> 00:04:00,930
you can unblock and I won't go too much

00:03:59,220 --> 00:04:02,430
into detail there but you can say that

00:04:00,930 --> 00:04:06,480
there's a there's a CPU there a micro

00:04:02,430 --> 00:04:08,280
blaze and there's the the platform

00:04:06,480 --> 00:04:10,830
management unit that has a micro place

00:04:08,280 --> 00:04:14,489
as well and there's a whole bunch of

00:04:10,830 --> 00:04:15,989
devices that need to be modeled and if

00:04:14,489 --> 00:04:19,380
you look at the yellow layer at the

00:04:15,989 --> 00:04:22,810
bottom that's where the FPGA fabric is

00:04:19,380 --> 00:04:27,580
so that's programmable logic

00:04:22,810 --> 00:04:29,500
which ya can't or can or can't model Inc

00:04:27,580 --> 00:04:34,780
um we're depending on what what you want

00:04:29,500 --> 00:04:37,750
to do but so and there are a lot of

00:04:34,780 --> 00:04:39,460
challenges challenges in modeling this

00:04:37,750 --> 00:04:42,250
especially if you look at km in three

00:04:39,460 --> 00:04:44,440
years ago yeah some I'm kind of gonna

00:04:42,250 --> 00:04:46,410
walk through these challenges and how we

00:04:44,440 --> 00:04:51,700
sold them and how we work with upstream

00:04:46,410 --> 00:04:54,220
yeah to realize that um one of the

00:04:51,700 --> 00:04:57,550
things that comes with this you know

00:04:54,220 --> 00:04:59,590
aggressive targets for for the platform

00:04:57,550 --> 00:05:01,800
is that we have few resources you

00:04:59,590 --> 00:05:04,030
basically have to scope out things and

00:05:01,800 --> 00:05:07,030
some things were kind of impossible to

00:05:04,030 --> 00:05:10,800
achieve so we kind of drop those and and

00:05:07,030 --> 00:05:13,600
we targeted some of them depending on

00:05:10,800 --> 00:05:15,100
you know the critic allocate criticality

00:05:13,600 --> 00:05:18,810
of the software we needed to get running

00:05:15,100 --> 00:05:21,190
so there are trade-offs to do there yeah

00:05:18,810 --> 00:05:23,980
so one of the things we'd be using for a

00:05:21,190 --> 00:05:27,460
while that's been quite successful for

00:05:23,980 --> 00:05:31,510
us at least is to not describe the

00:05:27,460 --> 00:05:34,210
machine in code so instead we describe

00:05:31,510 --> 00:05:38,740
the machine in in a device tree file

00:05:34,210 --> 00:05:40,720
basically um and when we started using

00:05:38,740 --> 00:05:42,340
this the goal was actually to use the

00:05:40,720 --> 00:05:45,760
same device tears were passed to the

00:05:42,340 --> 00:05:49,930
kernel and pass that to qmo to

00:05:45,760 --> 00:05:53,979
instantiate the virtual machine there

00:05:49,930 --> 00:05:55,990
are issues with that I mean the

00:05:53,979 --> 00:05:58,570
fundamental issue is that the device to

00:05:55,990 --> 00:06:01,419
be passed to the kernel is mainly used

00:05:58,570 --> 00:06:04,080
to describe the features of the hardware

00:06:01,419 --> 00:06:07,270
that the kernel can probe

00:06:04,080 --> 00:06:10,740
whereas in qmo you need every detail so

00:06:07,270 --> 00:06:14,100
that you can instantiate exactly that

00:06:10,740 --> 00:06:20,050
piece or part or IP block or whatever

00:06:14,100 --> 00:06:21,880
yeah I mean it's pretty idea is pretty

00:06:20,050 --> 00:06:24,270
simple just loop around and check the

00:06:21,880 --> 00:06:29,500
comparability properties and instantiate

00:06:24,270 --> 00:06:31,930
the QM devices for every property in

00:06:29,500 --> 00:06:33,880
device renown we look up you know

00:06:31,930 --> 00:06:36,520
properties in qm

00:06:33,880 --> 00:06:40,030
set those and yeah we can also deal with

00:06:36,520 --> 00:06:42,220
links and connect interrupts and you can

00:06:40,030 --> 00:06:53,380
describe pretty complex stuff with with

00:06:42,220 --> 00:06:56,400
this right so this is a it's a very

00:06:53,380 --> 00:06:59,170
simplified approximation of the bus and

00:06:56,400 --> 00:07:01,150
so I showed the picture before but that

00:06:59,170 --> 00:07:03,880
didn't really show them interconnect in

00:07:01,150 --> 00:07:06,960
any way so I've simplified this but you

00:07:03,880 --> 00:07:10,420
can see that there's this security and

00:07:06,960 --> 00:07:12,730
security configuration which is a little

00:07:10,420 --> 00:07:14,980
bit of a special subsystem with local

00:07:12,730 --> 00:07:17,050
Rams and local devices we have the PMU

00:07:14,980 --> 00:07:22,030
there are fives with local memory a

00:07:17,050 --> 00:07:23,350
bunch of the mas and a 53s the bypass

00:07:22,030 --> 00:07:26,530
the first iommu

00:07:23,350 --> 00:07:28,360
then we actually have something that you

00:07:26,530 --> 00:07:31,120
could say it's another iommu just for

00:07:28,360 --> 00:07:35,020
the discussion site and and then we have

00:07:31,120 --> 00:07:37,150
devices at the bottom yeah so when we

00:07:35,020 --> 00:07:40,270
started working on this qmo had no

00:07:37,150 --> 00:07:44,650
support for describing this kind of you

00:07:40,270 --> 00:07:50,530
know was a symmetric views of the system

00:07:44,650 --> 00:07:53,380
from different CPUs so that was one of

00:07:50,530 --> 00:07:56,020
the first things we we did to implement

00:07:53,380 --> 00:07:59,860
some kind of Perl / master address space

00:07:56,020 --> 00:08:07,240
so we can create different address views

00:07:59,860 --> 00:08:09,010
and yeah for each master and this is

00:08:07,240 --> 00:08:11,220
mostly upstream there's a few things

00:08:09,010 --> 00:08:11,220
missing

00:08:12,630 --> 00:08:17,980
for example the multiple address spaces

00:08:16,240 --> 00:08:23,080
per CPU that's something that Peter is

00:08:17,980 --> 00:08:27,160
working on now or soon or and we're also

00:08:23,080 --> 00:08:29,560
missing and I haven't checked that late

00:08:27,160 --> 00:08:33,430
lately but I think we're missing like a

00:08:29,560 --> 00:08:36,240
unified way of configuring you know

00:08:33,430 --> 00:08:39,070
telling a device use this address space

00:08:36,240 --> 00:08:41,140
and what we want to achieve is basically

00:08:39,070 --> 00:08:43,390
to have a unified way to do that for

00:08:41,140 --> 00:08:47,980
CPUs and devices

00:08:43,390 --> 00:08:49,839
and we have a way in our tree we can

00:08:47,980 --> 00:08:52,450
actually instantiate all of that in the

00:08:49,839 --> 00:08:55,540
device trees so you create the memory

00:08:52,450 --> 00:09:03,839
regions and attach those to devices and

00:08:55,540 --> 00:09:06,640
all of that all right okay so another

00:09:03,839 --> 00:09:10,779
pretty big challenge here back then was

00:09:06,640 --> 00:09:14,560
that neither the a fifty three so there

00:09:10,779 --> 00:09:17,649
are five s were modeled in human so the

00:09:14,560 --> 00:09:22,000
or files were fairly easy cuz we already

00:09:17,649 --> 00:09:26,410
had the RMB seven a big chunk of it at

00:09:22,000 --> 00:09:28,899
least modeled the a fifty three is were

00:09:26,410 --> 00:09:34,510
problematic darkest when we started

00:09:28,899 --> 00:09:37,060
there was nothing merged so there were a

00:09:34,510 --> 00:09:40,209
few patches circulating and Aleksandra

00:09:37,060 --> 00:09:44,769
graph is not here now but thank you very

00:09:40,209 --> 00:09:48,910
much for the initial port for e l0 I

00:09:44,769 --> 00:09:51,519
believe it was Linux user and then Peter

00:09:48,910 --> 00:09:55,899
made L and then I guess some folks at

00:09:51,519 --> 00:09:57,640
lien are oh yeah got the ill one working

00:09:55,899 --> 00:10:00,760
pretty quick and all of that worked very

00:09:57,640 --> 00:10:03,839
well for us yeah so we could quite

00:10:00,760 --> 00:10:06,250
quickly get the kernel and user space

00:10:03,839 --> 00:10:08,980
the problem was that we wanted to run

00:10:06,250 --> 00:10:12,660
more we needed to run you know port San

00:10:08,980 --> 00:10:15,490
and get a VM running on a platform and

00:10:12,660 --> 00:10:17,740
get arm trusted firmware running as well

00:10:15,490 --> 00:10:19,690
and we have a whole bunch of code of

00:10:17,740 --> 00:10:22,480
silence that we write for you know

00:10:19,690 --> 00:10:28,660
validation and all of those guys were

00:10:22,480 --> 00:10:29,800
running code in year three yeah so yeah

00:10:28,660 --> 00:10:33,220
we needed to do something about that

00:10:29,800 --> 00:10:35,980
basically what we did is we scoped it

00:10:33,220 --> 00:10:39,570
down a little bit we put the focus on AR

00:10:35,980 --> 00:10:44,410
64 and kind of bulldoze through that and

00:10:39,570 --> 00:10:45,810
prototyped yeah yell to including you

00:10:44,410 --> 00:10:49,149
know the virtual interrupts the

00:10:45,810 --> 00:10:52,660
two-stage MMU and the exception model

00:10:49,149 --> 00:10:56,370
and the timers and so on basically just

00:10:52,660 --> 00:10:56,370
barely enough to get the salmon caviar

00:10:57,450 --> 00:11:02,560
then it's a few funny things happen

00:11:00,040 --> 00:11:04,420
actually at the Leidner connect we found

00:11:02,560 --> 00:11:06,040
out that no one was working on this but

00:11:04,420 --> 00:11:08,260
then when we started posting patches the

00:11:06,040 --> 00:11:10,900
whole thing exploded and there was this

00:11:08,260 --> 00:11:12,730
guy Fabian from the Czech Republic I

00:11:10,900 --> 00:11:15,190
don't know where he went after that

00:11:12,730 --> 00:11:17,440
because he disappeared but he posted a

00:11:15,190 --> 00:11:20,740
lot of practice and yeah there was a lot

00:11:17,440 --> 00:11:24,880
of collaboration and we've actually come

00:11:20,740 --> 00:11:27,040
quite far on this now yeah so thanks

00:11:24,880 --> 00:11:29,740
again to the llanera people Greg who

00:11:27,040 --> 00:11:32,350
left you know he did a lot of stuff

00:11:29,740 --> 00:11:35,230
there too Fabian and Sergey from Sam

00:11:32,350 --> 00:11:38,350
Soon and more there's still a lot

00:11:35,230 --> 00:11:42,760
missing the speck is humongous like Mark

00:11:38,350 --> 00:11:46,390
said before and but yeah we're getting

00:11:42,760 --> 00:11:51,400
there yeah I think we're actually quite

00:11:46,390 --> 00:11:55,450
close now with them enough yeah three is

00:11:51,400 --> 00:11:59,740
it's quite okay and in el2 maybe in six

00:11:55,450 --> 00:12:01,600
months but it's a feeder yeah we've got

00:11:59,740 --> 00:12:04,420
we're missing the two stage MMU upstream

00:12:01,600 --> 00:12:08,550
and then also the geek stuff I think

00:12:04,420 --> 00:12:10,510
after that we'll probably be able to run

00:12:08,550 --> 00:12:21,100
hypervisors but there's still a lot of

00:12:10,510 --> 00:12:24,340
incompleteness yes it is alright okay so

00:12:21,100 --> 00:12:28,330
another thing that was problematic here

00:12:24,340 --> 00:12:30,820
is the I don't know if you're aware but

00:12:28,330 --> 00:12:34,480
on their arm Buster's the XE buses or

00:12:30,820 --> 00:12:36,430
amber buses yeah so when you you know

00:12:34,480 --> 00:12:40,030
you send transactions you don't only

00:12:36,430 --> 00:12:42,610
send the address read/write and data

00:12:40,030 --> 00:12:44,880
there's there's attributes that are not

00:12:42,610 --> 00:12:48,670
going along with the transactions and

00:12:44,880 --> 00:12:52,540
there's a the non secure bit used for

00:12:48,670 --> 00:12:55,300
trust zone there's also the master IDs

00:12:52,540 --> 00:12:56,140
that are I think they're kind of a hack

00:12:55,300 --> 00:12:57,670
on top of it

00:12:56,140 --> 00:13:01,270
use your baits or something but anyway

00:12:57,670 --> 00:13:04,329
they're used commonly used to you know

00:13:01,270 --> 00:13:06,879
identify what master is accessing you

00:13:04,329 --> 00:13:11,889
you know that's important for the IMM

00:13:06,879 --> 00:13:13,809
use yeah right so actually when we

00:13:11,889 --> 00:13:15,489
started working on this we kind of

00:13:13,809 --> 00:13:18,100
looked at the memory attributes and that

00:13:15,489 --> 00:13:20,019
looks kind of messy and we already had

00:13:18,100 --> 00:13:22,679
the address space is going so case we

00:13:20,019 --> 00:13:24,910
did a first shot at doing kind of the

00:13:22,679 --> 00:13:29,319
security extensions for the gig just

00:13:24,910 --> 00:13:32,649
using address spaces basically having

00:13:29,319 --> 00:13:34,959
the CPU have to address places and for

00:13:32,649 --> 00:13:37,929
secure accesses you would actually

00:13:34,959 --> 00:13:41,860
access a different memory region in the

00:13:37,929 --> 00:13:44,379
gig and that that worked okay but it

00:13:41,860 --> 00:13:47,049
fell apart very badly when you start

00:13:44,379 --> 00:13:48,999
doing the ion use and because you need

00:13:47,049 --> 00:13:50,769
to have a port for every master and if

00:13:48,999 --> 00:13:54,009
it's secure and non-secure and then what

00:13:50,769 --> 00:13:57,279
once you get out of the first immu you

00:13:54,009 --> 00:14:01,989
need it can explodes so the code for an

00:13:57,279 --> 00:14:04,239
iommu is you know the actual code is a

00:14:01,989 --> 00:14:09,839
small part compared to all this decoding

00:14:04,239 --> 00:14:09,839
of address spaces and translation so

00:14:14,189 --> 00:14:18,549
alright so we did a we did actually an

00:14:16,929 --> 00:14:25,509
implementation of the memory attributes

00:14:18,549 --> 00:14:27,429
that we are using Salix today and now

00:14:25,509 --> 00:14:29,379
when I was talking to Peter Lonard

00:14:27,429 --> 00:14:32,860
Connect he was working on an alternative

00:14:29,379 --> 00:14:34,540
and eventually his version got merged

00:14:32,860 --> 00:14:38,919
but we're pretty happy with that so

00:14:34,540 --> 00:14:41,410
that's looking good for our needs may be

00:14:38,919 --> 00:14:44,199
some slight difference that we we have

00:14:41,410 --> 00:14:48,639
the anomic we can add that later an

00:14:44,199 --> 00:14:51,339
option is that we use our memory

00:14:48,639 --> 00:14:53,350
attributes are actually QM objects and

00:14:51,339 --> 00:14:55,480
that's useful for us because it makes it

00:14:53,350 --> 00:14:58,059
very easy to instantiate them in the

00:14:55,480 --> 00:15:03,119
device tree and then just attach them to

00:14:58,059 --> 00:15:03,119
whatever master that means use them

00:15:06,129 --> 00:15:11,600
okay yeah like I mentioned the I am

00:15:08,569 --> 00:15:14,689
amuse were and non-trivial there with

00:15:11,600 --> 00:15:16,459
without attributes it was a bit easier

00:15:14,689 --> 00:15:18,110
with the attributes but there it's still

00:15:16,459 --> 00:15:20,209
quite complex to get this right and

00:15:18,110 --> 00:15:22,279
there were a few things bits and pieces

00:15:20,209 --> 00:15:24,619
missing for doing I am amused behind

00:15:22,279 --> 00:15:28,249
CPUs that still something we need to

00:15:24,619 --> 00:15:30,920
upstream but it was immensely helpful to

00:15:28,249 --> 00:15:34,279
get stuff running we actually had a

00:15:30,920 --> 00:15:36,189
bargain San and and in our RTL that

00:15:34,279 --> 00:15:39,920
would have been so hard to find without

00:15:36,189 --> 00:15:48,860
kind of being able to debug the the

00:15:39,920 --> 00:15:51,429
hardware model and does anyone have any

00:15:48,860 --> 00:15:51,429
questions so far

00:15:54,180 --> 00:16:02,040
and I don't know yeah you were aware

00:15:57,960 --> 00:16:04,380
thanks em and and I think this differs

00:16:02,040 --> 00:16:07,890
from KVM and Sam when you use the SME

00:16:04,380 --> 00:16:12,690
moon on arm you actually share the

00:16:07,890 --> 00:16:14,850
second-stage page table with the cpu and

00:16:12,690 --> 00:16:17,460
the critical thing there is that they

00:16:14,850 --> 00:16:20,850
have match the configuration of those

00:16:17,460 --> 00:16:22,770
page tables have to match and exam they

00:16:20,850 --> 00:16:25,620
were kind of ignoring the topology of

00:16:22,770 --> 00:16:31,340
the smmu when they created those pages

00:16:25,620 --> 00:16:31,340
and assuming that yeah

00:16:32,640 --> 00:16:37,680
assuming they that the SMM you would can

00:16:35,550 --> 00:16:39,900
I be able to use those that

00:16:37,680 --> 00:16:41,910
configuration cannot by default and that

00:16:39,900 --> 00:16:43,590
wasn't the case it was quite true Val

00:16:41,910 --> 00:16:45,750
the trick the fix was trivial basically

00:16:43,590 --> 00:16:49,070
to set up this enemy the same way as the

00:16:45,750 --> 00:16:49,070
second stage enemy

00:16:58,450 --> 00:17:03,910
yes it is but you have to configure the

00:17:01,209 --> 00:17:07,900
smmu in the exact same way you can

00:17:03,910 --> 00:17:10,449
figure the second station of you in in

00:17:07,900 --> 00:17:12,730
the CPU so you know how they for example

00:17:10,449 --> 00:17:15,220
the input size of the address matters

00:17:12,730 --> 00:17:17,230
how you walk it affects how you walk the

00:17:15,220 --> 00:17:19,959
page tables if you don't get all those

00:17:17,230 --> 00:17:22,620
details right you're gonna you're gonna

00:17:19,959 --> 00:17:28,120
walk the page table differently basis

00:17:22,620 --> 00:17:30,730
okay hmm yeah that's yeah that's that's

00:17:28,120 --> 00:17:31,990
part part yeah we fixed some of them to

00:17:30,730 --> 00:17:36,630
get our stuff working but there's still

00:17:31,990 --> 00:17:36,630
some missing that we need to fix

00:17:43,720 --> 00:17:51,759
and now we scoped it down pretty much so

00:17:46,960 --> 00:17:53,559
we did the air to 64 and I think there's

00:17:51,759 --> 00:17:55,899
quite a lot missing a lot of the traps

00:17:53,559 --> 00:17:58,299
we're missing I mean our goal was

00:17:55,899 --> 00:18:00,039
basically to get the exception model

00:17:58,299 --> 00:18:03,610
going so you could do SMC's back and

00:18:00,039 --> 00:18:06,009
forth so we could Co program the

00:18:03,610 --> 00:18:08,799
untrusted firmware and add our additions

00:18:06,009 --> 00:18:10,899
in there stuff beyond that we really

00:18:08,799 --> 00:18:13,929
didn't care of but there's a lot that

00:18:10,899 --> 00:18:19,840
has been done since then by Lennar oh

00:18:13,929 --> 00:18:21,549
and this guy Fabian so yeah it's looking

00:18:19,840 --> 00:18:23,879
pretty good there's still stuff missing

00:18:21,549 --> 00:18:23,879
but

00:18:29,570 --> 00:18:35,400
the second question is did you have any

00:18:32,130 --> 00:18:38,220
trouble modeling both m-series and our

00:18:35,400 --> 00:18:43,560
series CPUs in the same commute and

00:18:38,220 --> 00:18:46,170
statistics cuz there is a metric sorry

00:18:43,560 --> 00:18:48,540
do you mean the modeling there we didn't

00:18:46,170 --> 00:18:50,400
have mm serious or even when we are

00:18:48,540 --> 00:18:52,260
certainly serious the both day series

00:18:50,400 --> 00:18:58,020
and the our series right I'm coming to

00:18:52,260 --> 00:18:59,730
that now okay all right okay so yeah

00:18:58,020 --> 00:19:02,810
another thing you may have noticed here

00:18:59,730 --> 00:19:06,780
is that we had so there's two microplace

00:19:02,810 --> 00:19:11,580
this two or fives and there's for a 53's

00:19:06,780 --> 00:19:14,060
and when you run and when you build and

00:19:11,580 --> 00:19:17,490
run QM today you build it for a specific

00:19:14,060 --> 00:19:23,550
architecture you can't run different

00:19:17,490 --> 00:19:28,380
kinds yeah so actually when we started

00:19:23,550 --> 00:19:31,140
looking at that and then I mean the a

00:19:28,380 --> 00:19:34,910
r64 bill they were permeated build

00:19:31,140 --> 00:19:38,820
that's a it includes all the 32-bit

00:19:34,910 --> 00:19:40,950
machines as well so we did a quick test

00:19:38,820 --> 00:19:44,640
and just you know instantiated they are

00:19:40,950 --> 00:19:46,770
fives we had with the 53's on the same

00:19:44,640 --> 00:19:51,690
machine it actually just worked so that

00:19:46,770 --> 00:19:53,250
wasn't really a problem yeah if I

00:19:51,690 --> 00:19:57,090
remember correctly there was nothing we

00:19:53,250 --> 00:20:01,980
did now the problem comes when you want

00:19:57,090 --> 00:20:03,390
to have the micro basis in there so we

00:20:01,980 --> 00:20:05,070
were looking a little bit of a tree then

00:20:03,390 --> 00:20:09,410
and I was a little bit unsure what the

00:20:05,070 --> 00:20:11,700
state was I know that andreas I think

00:20:09,410 --> 00:20:14,490
undress did a lot of good work and

00:20:11,700 --> 00:20:18,120
trying to you know clean up the code to

00:20:14,490 --> 00:20:22,260
eventually walk towards clean multi arts

00:20:18,120 --> 00:20:24,720
implementation so but back then when I

00:20:22,260 --> 00:20:26,310
looked at it I I yeah I got it

00:20:24,720 --> 00:20:28,290
I didn't think we would make it

00:20:26,310 --> 00:20:31,620
basically with the time constraints we

00:20:28,290 --> 00:20:35,480
had so so we went and did another

00:20:31,620 --> 00:20:38,190
approach having that having said that am

00:20:35,480 --> 00:20:39,240
now very recently so Peter crossbred

00:20:38,190 --> 00:20:42,120
posted some patches

00:20:39,240 --> 00:20:45,270
to to kind of achieve the multi arch

00:20:42,120 --> 00:20:51,150
within the tree in a single qmo instance

00:20:45,270 --> 00:20:53,280
and and silence has been so we partnered

00:20:51,150 --> 00:20:55,230
up with green socks

00:20:53,280 --> 00:20:59,970
fred is there thanks for all the good

00:20:55,230 --> 00:21:02,070
work brother and to do the multi

00:20:59,970 --> 00:21:04,770
threaded TCG cuz once we have both of

00:21:02,070 --> 00:21:07,860
them both of them together it's gonna be

00:21:04,770 --> 00:21:09,780
really good one of them only it's not

00:21:07,860 --> 00:21:11,130
that good for us cuz I mean if you get

00:21:09,780 --> 00:21:13,940
the mood the arts but don't have the

00:21:11,130 --> 00:21:17,250
multi-threading and you're doing a and P

00:21:13,940 --> 00:21:19,980
then you know that CPU is running the

00:21:17,250 --> 00:21:22,290
small kernels that don't do interrupts

00:21:19,980 --> 00:21:24,570
maybe they're gonna consume all that all

00:21:22,290 --> 00:21:25,950
the time and if you have multi-threaded

00:21:24,570 --> 00:21:29,730
but now multi Arts it doesn't help us

00:21:25,950 --> 00:21:32,100
very much so we need both X yeah silence

00:21:29,730 --> 00:21:36,750
the community probably is happy with one

00:21:32,100 --> 00:21:41,510
of them at a time okay yeah so thanks to

00:21:36,750 --> 00:21:46,740
green socks there and thanks to Andreas

00:21:41,510 --> 00:21:48,210
M okay so what did we do we did I've

00:21:46,740 --> 00:21:49,530
heard it mentioned here a few times

00:21:48,210 --> 00:21:54,510
already in this conference we did like

00:21:49,530 --> 00:21:58,500
kind of a cue a mood to qmo proxy and it

00:21:54,510 --> 00:22:02,220
uses shared memory and unique sockets to

00:21:58,500 --> 00:22:05,309
communicate you know actually the first

00:22:02,220 --> 00:22:07,890
version we did we try to use Q test as a

00:22:05,309 --> 00:22:09,270
proof of concept because I figured yeah

00:22:07,890 --> 00:22:12,120
using you test it won't be that

00:22:09,270 --> 00:22:14,460
controversial you know slowly adding a

00:22:12,120 --> 00:22:17,400
few patches the cutest and suddenly will

00:22:14,460 --> 00:22:20,250
sneak in a QAM with the qmo protocol

00:22:17,400 --> 00:22:24,000
into key mo but now we gave up on that

00:22:20,250 --> 00:22:25,890
quite fast and it's so an efficient with

00:22:24,000 --> 00:22:28,530
all the texting and so we did a kind of

00:22:25,890 --> 00:22:35,550
a binary version of it and then we did

00:22:28,530 --> 00:22:38,010
the shared memory and right so you can

00:22:35,550 --> 00:22:41,429
connect you know qmo can be a bus master

00:22:38,010 --> 00:22:43,140
on the Q side accessing slaves on

00:22:41,429 --> 00:22:44,640
another process actually the other

00:22:43,140 --> 00:22:45,220
process doesn't have to run q and what

00:22:44,640 --> 00:22:46,900
can be anything

00:22:45,220 --> 00:22:51,390
as long as you implement the protocol

00:22:46,900 --> 00:22:55,120
and can also do so qmo has slave ports

00:22:51,390 --> 00:22:59,350
you can do GPIO s and we use the DMA

00:22:55,120 --> 00:23:02,590
stream objects or classes in queue I'm

00:22:59,350 --> 00:23:07,960
going to to abstract DMA transactions

00:23:02,590 --> 00:23:09,520
you could say m and there's a bit of

00:23:07,960 --> 00:23:13,000
stuff there for synchronization and

00:23:09,520 --> 00:23:14,980
Tommy cops for example if the micro base

00:23:13,000 --> 00:23:17,559
does an exclusive access and something

00:23:14,980 --> 00:23:21,630
yes you can actually get that working

00:23:17,559 --> 00:23:24,520
between the macro basis and the arm and

00:23:21,630 --> 00:23:27,309
another thing that's that was cool is

00:23:24,520 --> 00:23:29,320
that because they're running in separate

00:23:27,309 --> 00:23:36,159
processes they're actually running real

00:23:29,320 --> 00:23:37,659
really parallel yeah I mean it can get

00:23:36,159 --> 00:23:40,120
very messy if you start thinking about

00:23:37,659 --> 00:23:42,100
where you're gonna do the cuts where are

00:23:40,120 --> 00:23:45,549
you gonna connect the different machines

00:23:42,100 --> 00:23:48,130
that and but we did it just the simplest

00:23:45,549 --> 00:23:52,539
way I guess I it got too messy if you

00:23:48,130 --> 00:23:54,220
try to make the cut you know deep into

00:23:52,539 --> 00:23:56,169
the device land or try to do it

00:23:54,220 --> 00:23:59,679
realistic with the real hardware or

00:23:56,169 --> 00:24:03,720
anything like that and the easiest way

00:23:59,679 --> 00:24:06,220
is just to cut it basically have a CPU

00:24:03,720 --> 00:24:09,400
in the foreign instances and have all

00:24:06,220 --> 00:24:10,870
the devices in one qmo you know that was

00:24:09,400 --> 00:24:13,240
kind of the approach there were a few

00:24:10,870 --> 00:24:14,679
things that sneaked out but basically

00:24:13,240 --> 00:24:16,990
that's the approach we have a big

00:24:14,679 --> 00:24:20,080
instance running all the arm stuff and

00:24:16,990 --> 00:24:25,929
then we have two remote instances

00:24:20,080 --> 00:24:27,159
running the micro places and that worked

00:24:25,929 --> 00:24:32,370
out very well that's what we're using

00:24:27,159 --> 00:24:32,370
today to bring up the entire system

00:24:33,450 --> 00:24:36,720
questions on that

00:24:42,539 --> 00:24:48,850
exactly there's a bit of it's a few

00:24:46,480 --> 00:24:50,950
interrupts going and between the plat

00:24:48,850 --> 00:24:52,779
the P mu is the P mu is actually

00:24:50,950 --> 00:24:56,320
responsible for power management as well

00:24:52,779 --> 00:24:58,000
so if the arm wants to power up

00:24:56,320 --> 00:25:01,149
something or use something it needs to

00:24:58,000 --> 00:25:03,669
signal so it's a bit of let's say yeah

00:25:01,149 --> 00:25:06,700
remote processor communication but it's

00:25:03,669 --> 00:25:08,289
it's not much and even if even if there

00:25:06,700 --> 00:25:09,639
was much it's still quick because we

00:25:08,289 --> 00:25:12,039
were using shell you're not actually

00:25:09,639 --> 00:25:16,110
sending memory transactions on the UNIX

00:25:12,039 --> 00:25:16,110
sockets you're just accessing the memory

00:25:17,250 --> 00:25:25,539
okay

00:25:19,740 --> 00:25:28,809
more questions alright so I talked a

00:25:25,539 --> 00:25:32,559
little bit about this the shared memory

00:25:28,809 --> 00:25:34,690
was quite easy to do actually we already

00:25:32,559 --> 00:25:37,860
have the mem path so we added a shared

00:25:34,690 --> 00:25:40,899
version of that and the mem path

00:25:37,860 --> 00:25:43,870
actually creates files on your file

00:25:40,899 --> 00:25:47,590
system that it Maps in and those files

00:25:43,870 --> 00:25:50,440
are named based on the device the name

00:25:47,590 --> 00:25:53,590
of the RAM in qmo so just making the RAM

00:25:50,440 --> 00:25:57,190
name being the same across all instances

00:25:53,590 --> 00:25:59,440
pretty much solved and and it's nice

00:25:57,190 --> 00:26:03,190
that you can also use any UNIX tool to

00:25:59,440 --> 00:26:05,019
inspect the memory so you don't have to

00:26:03,190 --> 00:26:06,519
use gdb to look at the memory or if you

00:26:05,019 --> 00:26:07,990
want to load something you can use any

00:26:06,519 --> 00:26:14,559
tool to kind of put stuff into the

00:26:07,990 --> 00:26:16,090
memory which is interesting all right we

00:26:14,559 --> 00:26:17,440
didn't implement this is something

00:26:16,090 --> 00:26:20,220
that's missing we're thinking about it

00:26:17,440 --> 00:26:23,980
but we actually need never needed it yet

00:26:20,220 --> 00:26:27,970
and it's the case where one of the

00:26:23,980 --> 00:26:30,250
instances actually touches memory that

00:26:27,970 --> 00:26:32,710
is in qmo cache of the other instance

00:26:30,250 --> 00:26:35,139
that's already been translated so it's

00:26:32,710 --> 00:26:38,250
in the TB cache so if you touch that

00:26:35,139 --> 00:26:42,399
code the other side is cache won't flush

00:26:38,250 --> 00:26:48,070
yeah so we just haven't had that use

00:26:42,399 --> 00:26:56,030
case yet but it is solvable somehow yes

00:26:48,070 --> 00:27:01,670
okay and questions so far so another big

00:26:56,030 --> 00:27:03,680
chunk here that's tricky is the yeah

00:27:01,670 --> 00:27:06,170
it's the yellow part what are we gonna

00:27:03,680 --> 00:27:09,440
do about the pl people that want to run

00:27:06,170 --> 00:27:11,870
some some kind of little RTL down there

00:27:09,440 --> 00:27:20,360
yeah do something with that

00:27:11,870 --> 00:27:22,100
yeah all right okay so you're probably

00:27:20,360 --> 00:27:26,450
familiar this has been on the list many

00:27:22,100 --> 00:27:31,030
times but system C is so that's the it's

00:27:26,450 --> 00:27:34,790
a C++ class library let's say for for

00:27:31,030 --> 00:27:37,610
simulating Hardware kind of like QA

00:27:34,790 --> 00:27:40,760
mousse framework but a little bit more

00:27:37,610 --> 00:27:42,800
low-level and it actually has different

00:27:40,760 --> 00:27:45,110
levels of abstractions you can choose

00:27:42,800 --> 00:27:47,600
from you can choose a very low level

00:27:45,110 --> 00:27:53,060
modeling a kind of gate level or you can

00:27:47,600 --> 00:27:56,150
go up in the abstraction level um and on

00:27:53,060 --> 00:27:58,870
top of system C or kind of sat next to

00:27:56,150 --> 00:28:03,230
system C there's a standard called TLM

00:27:58,870 --> 00:28:05,150
that provides a way to interconnect so

00:28:03,230 --> 00:28:08,300
interoperate models at a very high level

00:28:05,150 --> 00:28:13,460
and this is actually quite similar to qm

00:28:08,300 --> 00:28:16,130
o--'s same memory region and you know

00:28:13,460 --> 00:28:21,470
the whole device model it's different

00:28:16,130 --> 00:28:23,000
but it it's kind of the same thing so

00:28:21,470 --> 00:28:26,150
there's open source simulators for

00:28:23,000 --> 00:28:30,610
system C and T LM the Husky ones and

00:28:26,150 --> 00:28:36,220
they work well and systemctl amazing

00:28:30,610 --> 00:28:38,990
increasingly popular chip design teams

00:28:36,220 --> 00:28:43,070
and it's placed a very important role

00:28:38,990 --> 00:28:45,140
when you want to glue models together

00:28:43,070 --> 00:28:46,700
that may be written in different

00:28:45,140 --> 00:28:49,790
languages and different abstraction

00:28:46,700 --> 00:28:53,000
levels so you can have a model for our

00:28:49,790 --> 00:28:54,920
timer written you know very long and if

00:28:53,000 --> 00:28:57,650
you create a system C glue around that

00:28:54,920 --> 00:28:58,730
you can connect it easily to a model

00:28:57,650 --> 00:29:05,900
reading in VH

00:28:58,730 --> 00:29:11,950
see and so on so what we did was

00:29:05,900 --> 00:29:17,480
basically wrapped the remote port into

00:29:11,950 --> 00:29:19,850
with SystemC ntlm so and what you can I

00:29:17,480 --> 00:29:22,850
mean what you see from the system

00:29:19,850 --> 00:29:24,980
society is basically a TLM compatible

00:29:22,850 --> 00:29:26,630
device and you don't actually need to

00:29:24,980 --> 00:29:31,940
know that there's a qmo on the other

00:29:26,630 --> 00:29:33,890
side and there's a tool called very

00:29:31,940 --> 00:29:36,320
later I know if you heard of that it's

00:29:33,890 --> 00:29:41,090
an open-source tool that translates very

00:29:36,320 --> 00:29:43,600
log two and two systems and it does it

00:29:41,090 --> 00:29:45,950
all just pretty much place together yeah

00:29:43,600 --> 00:29:50,660
so that's pretty cool we actually use

00:29:45,950 --> 00:29:53,179
this in some of the debugging to run we

00:29:50,660 --> 00:29:55,760
run the entire system except one device

00:29:53,179 --> 00:29:59,230
in our tail and if you do that it

00:29:55,760 --> 00:30:01,309
actually models very fast it's it's

00:29:59,230 --> 00:30:04,370
significantly slower than and then a

00:30:01,309 --> 00:30:08,090
pure qmo but maybe times three or you

00:30:04,370 --> 00:30:11,780
know it's not it's not like RTL where

00:30:08,090 --> 00:30:15,440
you wait days for for something so I

00:30:11,780 --> 00:30:18,860
mean fool RTL we're white days and so

00:30:15,440 --> 00:30:20,450
that was good and and the nice thing is

00:30:18,860 --> 00:30:22,910
that it's a full open source flow

00:30:20,450 --> 00:30:26,030
because the whole system sitting is open

00:30:22,910 --> 00:30:30,970
source and the very later is open source

00:30:26,030 --> 00:30:30,970
and right

00:30:32,650 --> 00:30:42,310
okay so some of the details there when

00:30:39,170 --> 00:30:44,150
we rock um oh we run it with I count

00:30:42,310 --> 00:30:46,040
specifically when we were using the

00:30:44,150 --> 00:30:48,500
system see things and that's to control

00:30:46,040 --> 00:30:50,240
the timing and because we don't want to

00:30:48,500 --> 00:30:52,640
UM would kind of running our way too far

00:30:50,240 --> 00:30:55,100
off from the system see time so we want

00:30:52,640 --> 00:30:56,810
to keep them kind of in sync and this in

00:30:55,100 --> 00:30:59,330
system see there's a concept of a

00:30:56,810 --> 00:31:02,060
quantum that allows you to specify how

00:30:59,330 --> 00:31:05,900
far ahead you let different models go

00:31:02,060 --> 00:31:08,330
and if you make the quantum small you

00:31:05,900 --> 00:31:11,210
get kind of quite accurate you know

00:31:08,330 --> 00:31:14,210
lockstep kind of simulations but if you

00:31:11,210 --> 00:31:15,830
make the quantum high things can be far

00:31:14,210 --> 00:31:18,560
apart from each other but you get better

00:31:15,830 --> 00:31:21,140
performance so that's like a knob you

00:31:18,560 --> 00:31:23,360
have to control that yeah and there's

00:31:21,140 --> 00:31:30,500
other ways you can do - can time warping

00:31:23,360 --> 00:31:33,800
- to increase the speed okay and remote

00:31:30,500 --> 00:31:35,390
port is actually having yeah it's not I

00:31:33,800 --> 00:31:40,670
mean we never attempted to upstream it

00:31:35,390 --> 00:31:42,170
but it's out in a public tree yeah it's

00:31:40,670 --> 00:31:43,910
a bit although we haven't rebased it's

00:31:42,170 --> 00:31:46,280
probably two years old explain the tree

00:31:43,910 --> 00:31:48,800
but yeah we'll see what happens with

00:31:46,280 --> 00:31:53,870
that yeah I was talking about very later

00:31:48,800 --> 00:31:57,890
that's a very nice tool right and you

00:31:53,870 --> 00:32:02,690
can use the full open source based flow

00:31:57,890 --> 00:32:05,260
and actually do hardware design which is

00:32:02,690 --> 00:32:09,740
quite cool like you

00:32:05,260 --> 00:32:13,730
okay some of the stuff we did some tools

00:32:09,740 --> 00:32:16,550
to East debugging we added a binary

00:32:13,730 --> 00:32:18,830
tracer that basically dumps the

00:32:16,550 --> 00:32:21,110
execution flow and some other enforce

00:32:18,830 --> 00:32:25,700
well all the interrupts there are signal

00:32:21,110 --> 00:32:28,400
memory accesses and in a kind of

00:32:25,700 --> 00:32:31,720
efficient way binary and then we have an

00:32:28,400 --> 00:32:35,000
external tool that post processes that

00:32:31,720 --> 00:32:37,820
and it can post process the traces or

00:32:35,000 --> 00:32:39,740
connect kind of through a socket to post

00:32:37,820 --> 00:32:42,430
process live and the reason you want a

00:32:39,740 --> 00:32:44,340
post process live is if you're doing

00:32:42,430 --> 00:32:47,040
code coverage

00:32:44,340 --> 00:32:52,800
and running along long runs because the

00:32:47,040 --> 00:32:54,990
traces get quite big quickly yeah right

00:32:52,800 --> 00:32:58,830
so this is the external tool can we

00:32:54,990 --> 00:33:00,930
trace and and you can pass it L files

00:32:58,830 --> 00:33:03,990
with debug info and it'll decode those

00:33:00,930 --> 00:33:06,060
and kind of keep track of which source

00:33:03,990 --> 00:33:09,510
lines that have executed how many times

00:33:06,060 --> 00:33:12,390
and based on that we generate an elk

00:33:09,510 --> 00:33:14,270
Cove info file and from there you can go

00:33:12,390 --> 00:33:23,040
and generate the beautiful web pages and

00:33:14,270 --> 00:33:26,000
yeah yeah some more debugging stuff here

00:33:23,040 --> 00:33:29,640
an interesting thing we use is that we

00:33:26,000 --> 00:33:34,650
if any of the models issues a log guest

00:33:29,640 --> 00:33:38,220
error log we break the GDB GDB sessions

00:33:34,650 --> 00:33:40,320
if there's any attached and that can be

00:33:38,220 --> 00:33:42,570
useful because you get if you're

00:33:40,320 --> 00:33:44,430
debugging the code the debugger will

00:33:42,570 --> 00:33:47,040
actually break on the exact line where

00:33:44,430 --> 00:33:51,770
you commit let's say I memory mm IO

00:33:47,040 --> 00:33:54,210
access that it's it's no good and

00:33:51,770 --> 00:33:56,100
instead of maybe breaking much later

00:33:54,210 --> 00:33:57,720
when you start a DMA transaction or were

00:33:56,100 --> 00:34:00,210
you doing something else and the heart

00:33:57,720 --> 00:34:03,630
starts operating on that bit that you

00:34:00,210 --> 00:34:07,830
miss configured yes that's that can be

00:34:03,630 --> 00:34:10,800
useful in some cases yeah there's a few

00:34:07,830 --> 00:34:14,820
only eight things we did easily switch

00:34:10,800 --> 00:34:20,909
between Els different il views and from

00:34:14,820 --> 00:34:22,590
the gdb such yeah yeah client something

00:34:20,909 --> 00:34:26,159
we have problems with which we haven't

00:34:22,590 --> 00:34:29,550
solved is that it's quite hard to do the

00:34:26,159 --> 00:34:31,770
run state control with the current QM

00:34:29,550 --> 00:34:34,260
Lucas if you start one of the CPUs I

00:34:31,770 --> 00:34:38,310
think we enter this loop and can start

00:34:34,260 --> 00:34:39,840
running all CPUs and it goes a little

00:34:38,310 --> 00:34:43,200
bit crazy I don't know if you know about

00:34:39,840 --> 00:34:46,760
that yeah there's some issues there

00:34:43,200 --> 00:34:46,760
so probably look at that

00:34:46,960 --> 00:34:53,030
and okay yeah this was interesting - we

00:34:51,409 --> 00:34:55,760
did a little bit of work and hopefully

00:34:53,030 --> 00:35:00,760
we'll do more of this with green socks

00:34:55,760 --> 00:35:04,070
and Fred and with the Q testing so we'll

00:35:00,760 --> 00:35:05,890
back then Q test I think Anthony added Q

00:35:04,070 --> 00:35:08,950
test it's a long time I don't know I

00:35:05,890 --> 00:35:12,590
don't know anyway

00:35:08,950 --> 00:35:14,630
it was added so maybe not everyone is

00:35:12,590 --> 00:35:18,160
familiar with it Q test this is a

00:35:14,630 --> 00:35:21,830
protocol in qmo to which you can attach

00:35:18,160 --> 00:35:23,710
another application - and kind of do a

00:35:21,830 --> 00:35:28,480
few things in kind of memory accesses

00:35:23,710 --> 00:35:31,610
you can check the value of an interrupts

00:35:28,480 --> 00:35:34,150
and address anything else you can do

00:35:31,610 --> 00:35:34,150
there do you remember

00:35:41,570 --> 00:35:56,070
right right even kind of single step No

00:35:46,700 --> 00:35:58,230
step one I counter right okay the

00:35:56,070 --> 00:36:00,420
initial intention when it was added

00:35:58,230 --> 00:36:03,350
anyway was to be able to test device

00:36:00,420 --> 00:36:06,150
models from some kind of test really

00:36:03,350 --> 00:36:08,850
like unique unit test for a device model

00:36:06,150 --> 00:36:11,150
and there's many of those now and I know

00:36:08,850 --> 00:36:16,500
Andres has added quite quite a few not

00:36:11,150 --> 00:36:18,890
so right so what we wanted to do was

00:36:16,500 --> 00:36:21,480
actually to use this to test not only

00:36:18,890 --> 00:36:24,210
models are not really models in our case

00:36:21,480 --> 00:36:27,240
but test them this software running the

00:36:24,210 --> 00:36:29,250
embedded software so we added support

00:36:27,240 --> 00:36:31,950
for running queue tests together with

00:36:29,250 --> 00:36:33,960
TCG CPUs and that's upstream now it was

00:36:31,950 --> 00:36:38,250
just a one-liner and then we wrote a

00:36:33,960 --> 00:36:40,260
python class that exposes the qmo

00:36:38,250 --> 00:36:43,290
machine over so you write a Python

00:36:40,260 --> 00:36:46,380
script on the side you connect to qmo

00:36:43,290 --> 00:36:49,740
and then you get a instance let's say we

00:36:46,380 --> 00:36:52,830
call it q mo here and then you can do

00:36:49,740 --> 00:36:54,750
you know 32-bit bus transactions it

00:36:52,830 --> 00:37:05,640
exposes the memory as an array basically

00:36:54,750 --> 00:37:08,910
you just so this line here the next line

00:37:05,640 --> 00:37:12,420
is reading from the same address two

00:37:08,910 --> 00:37:14,790
bytes and we added support for setting

00:37:12,420 --> 00:37:18,510
signals as well so racing artificially

00:37:14,790 --> 00:37:21,030
raising interrupts and we started

00:37:18,510 --> 00:37:23,670
writing tests like this but eventually

00:37:21,030 --> 00:37:25,080
it kind of bit rot and unfortunately but

00:37:23,670 --> 00:37:26,490
this is something we really want to pick

00:37:25,080 --> 00:37:29,700
up again because I think there's a lot

00:37:26,490 --> 00:37:31,770
of value in it where does the APU name

00:37:29,700 --> 00:37:34,080
come from as a field there oh the

00:37:31,770 --> 00:37:37,040
application programming unit that's that

00:37:34,080 --> 00:37:39,120
was the blue box in there with

00:37:37,040 --> 00:37:41,250
understand the abbreviation I'm just

00:37:39,120 --> 00:37:42,990
wondering are you you know parsing the

00:37:41,250 --> 00:37:44,820
the quam tree to actually get those

00:37:42,990 --> 00:37:49,770
names or how do you get those fields

00:37:44,820 --> 00:37:51,810
there no I think that was an now that

00:37:49,770 --> 00:37:54,109
was the script just naming things like

00:37:51,810 --> 00:37:57,060
that so no no parsing

00:37:54,109 --> 00:37:58,740
right but you could do that that's a

00:37:57,060 --> 00:38:01,700
good point you could I guess parse it

00:37:58,740 --> 00:38:06,000
and kind of that's a good point

00:38:01,700 --> 00:38:08,760
mm okay but I think there's a lot of

00:38:06,000 --> 00:38:11,430
potential in this kind of stuff for

00:38:08,760 --> 00:38:14,190
validating you know boot roms and

00:38:11,430 --> 00:38:17,310
sensitive software where may be hard to

00:38:14,190 --> 00:38:19,740
trig yes an example could be lets say

00:38:17,310 --> 00:38:24,450
you have software that reacts on on a

00:38:19,740 --> 00:38:26,340
heat sensor yeah we had some humidity or

00:38:24,450 --> 00:38:28,470
something like that it can be quite hard

00:38:26,340 --> 00:38:30,869
to not to trig all the use cases all the

00:38:28,470 --> 00:38:34,050
corner cases I mean in in the software

00:38:30,869 --> 00:38:35,849
and so by having mechanisms where you

00:38:34,050 --> 00:38:41,790
can trick stuff from the outside in a

00:38:35,849 --> 00:38:42,780
controlled way and together with em so

00:38:41,790 --> 00:38:47,550
this is another thing we wanted to

00:38:42,780 --> 00:38:49,500
connect this to the code coverage so you

00:38:47,550 --> 00:38:52,230
can have a closed loop where you have a

00:38:49,500 --> 00:38:55,560
Python script that can you know trig

00:38:52,230 --> 00:38:58,619
events basically randomly and mess your

00:38:55,560 --> 00:39:00,630
code coverage and you know run that for

00:38:58,619 --> 00:39:05,160
a couple of days and boom yeah I think

00:39:00,630 --> 00:39:10,260
that could be very useful so if people

00:39:05,160 --> 00:39:15,540
want projects the heck on Q test okay

00:39:10,260 --> 00:39:19,320
another thing here the actually the RTL

00:39:15,540 --> 00:39:21,030
designers yeah I guess this happens

00:39:19,320 --> 00:39:23,700
everywhere but yeah

00:39:21,030 --> 00:39:24,810
I mean in their world it's very common

00:39:23,700 --> 00:39:27,540
that you go from some kind of

00:39:24,810 --> 00:39:29,400
specification of registers and you

00:39:27,540 --> 00:39:31,859
generate the RTL you generate

00:39:29,400 --> 00:39:35,040
documentation for the device all from

00:39:31,859 --> 00:39:36,359
one source you know so this was

00:39:35,040 --> 00:39:37,920
something we wanted to use because when

00:39:36,359 --> 00:39:40,020
we started I said we were writing all

00:39:37,920 --> 00:39:41,580
this stuff manually you know that bit is

00:39:40,020 --> 00:39:43,980
read right that bit is read only that

00:39:41,580 --> 00:39:47,910
bits reserved that mean is clear and

00:39:43,980 --> 00:39:49,440
right and you know all of that so we

00:39:47,910 --> 00:39:53,280
wrote a little bit of a back end to our

00:39:49,440 --> 00:39:55,920
tool there to how to generate like like

00:39:53,280 --> 00:39:58,890
a skeleton for a qmo model with all the

00:39:55,920 --> 00:40:01,470
register accesses all the policy is

00:39:58,890 --> 00:40:04,290
basically pre-programmed I mean it's

00:40:01,470 --> 00:40:06,109
it's not it doesn't give you a use a

00:40:04,290 --> 00:40:08,390
useful model to start with

00:40:06,109 --> 00:40:10,099
all you need to do is basically fill in

00:40:08,390 --> 00:40:10,789
the logic the actual logic of your

00:40:10,099 --> 00:40:15,440
device

00:40:10,789 --> 00:40:18,019
yeah so that's useful for some of that

00:40:15,440 --> 00:40:20,480
for example they are messing you we are

00:40:18,019 --> 00:40:22,309
taught to generate it most of the stuff

00:40:20,480 --> 00:40:25,900
and that has that beast has you know

00:40:22,309 --> 00:40:25,900
thousands and thousands of registers

00:40:27,549 --> 00:40:36,109
let's see yeah actually we added support

00:40:33,319 --> 00:40:37,579
for identifying interrupt logic and

00:40:36,109 --> 00:40:39,259
interrupt controllers so you can

00:40:37,579 --> 00:40:41,599
generate an interrupt controller that's

00:40:39,259 --> 00:40:47,989
the only device it can generate fully

00:40:41,599 --> 00:40:50,749
useful from the spec yeah yeah one more

00:40:47,989 --> 00:40:53,690
thing to add here is that there's the

00:40:50,749 --> 00:40:55,309
tool here actually uses the register API

00:40:53,690 --> 00:40:58,009
that's been on list a few times

00:40:55,309 --> 00:41:00,799
that's something peter crosthwaite was

00:40:58,009 --> 00:41:02,630
working on and which is quite a useful

00:41:00,799 --> 00:41:05,720
way of having a data-driven way to

00:41:02,630 --> 00:41:09,759
describe registers and the fields and

00:41:05,720 --> 00:41:09,759
how the access patterns and and so on

00:41:09,970 --> 00:41:15,009
alright that was all I had any more

00:41:12,559 --> 00:41:15,009
questions

00:41:18,109 --> 00:41:20,170
you

00:41:22,779 --> 00:41:27,410
for the stuff you've published work if

00:41:25,430 --> 00:41:30,140
it's not upstream where can I find it

00:41:27,410 --> 00:41:32,089
yeah yeah can I get back to your

00:41:30,140 --> 00:41:33,500
alistair actually because i've been off

00:41:32,089 --> 00:41:35,059
for a month so I've been a little bit

00:41:33,500 --> 00:41:43,119
lost on what's been published lately but

00:41:35,059 --> 00:41:43,119
Alistair has there Thanks

00:41:44,400 --> 00:41:48,599
so Edgar you've been a bit modest in the

00:41:46,619 --> 00:41:50,220
first slide so I wanted to really repeat

00:41:48,599 --> 00:41:53,849
this so that everyone really gets this

00:41:50,220 --> 00:41:56,430
so the work that his team has done was

00:41:53,849 --> 00:41:59,640
actually making a press announcement

00:41:56,430 --> 00:42:03,240
about their new chip model availability

00:41:59,640 --> 00:42:06,390
and they had patches for u-boot the

00:42:03,240 --> 00:42:08,039
Linux kernel and qmu out on like the

00:42:06,390 --> 00:42:10,349
same day or pretty much about really

00:42:08,039 --> 00:42:14,420
that date so really I would like people

00:42:10,349 --> 00:42:14,420
to give a great applause to silence for

00:42:16,670 --> 00:42:28,109
having said that background of what you

00:42:25,859 --> 00:42:32,190
means to darlings because right now it

00:42:28,109 --> 00:42:34,499
seems that you know you're the only trip

00:42:32,190 --> 00:42:36,499
vendor that I know that has embraced GME

00:42:34,499 --> 00:42:39,240
to the same level for instance you know

00:42:36,499 --> 00:42:42,150
your competitor altaira if I may name

00:42:39,240 --> 00:42:45,749
them they stick with the proprietary

00:42:42,150 --> 00:42:47,609
synopsis solution you know arm has their

00:42:45,749 --> 00:42:50,369
proprietary solution that some other

00:42:47,609 --> 00:42:55,759
vendors are using what is the real value

00:42:50,369 --> 00:42:59,549
of using kmu to us Alex all right I

00:42:55,759 --> 00:43:05,849
guess they're kind of multiple fronts on

00:42:59,549 --> 00:43:08,160
that and but this being I guess the

00:43:05,849 --> 00:43:10,920
first project that Cylons were qmo has

00:43:08,160 --> 00:43:13,739
been this heavily used and I feel it's

00:43:10,920 --> 00:43:16,890
been a quite big success so it's been an

00:43:13,739 --> 00:43:19,619
eye-opener for many Alex's and Cylons

00:43:16,890 --> 00:43:21,960
how how I mean how much you can actually

00:43:19,619 --> 00:43:28,230
do with it and how much time you can win

00:43:21,960 --> 00:43:30,630
in the early days and so I think the

00:43:28,230 --> 00:43:32,460
level of importance is very high we have

00:43:30,630 --> 00:43:37,009
vena here also from the selling stream

00:43:32,460 --> 00:43:40,410
and since she can acknowledge that and

00:43:37,009 --> 00:43:42,690
actually this wasn't maybe planned from

00:43:40,410 --> 00:43:45,359
the start the start of the project was

00:43:42,690 --> 00:43:47,339
very focused on getting a platform for

00:43:45,359 --> 00:43:49,950
internal use but now we're actually

00:43:47,339 --> 00:43:51,569
planning to you know work to get this

00:43:49,950 --> 00:43:55,850
out to customers so they can also

00:43:51,569 --> 00:43:59,680
develop and using the same stuff

00:43:55,850 --> 00:44:01,820
now what we have I mean we've been

00:43:59,680 --> 00:44:03,500
haven't been that bad but we haven't

00:44:01,820 --> 00:44:05,480
been very good with the upstream in

00:44:03,500 --> 00:44:10,010
during the process and I hope that's

00:44:05,480 --> 00:44:12,830
gonna improve once you know they're the

00:44:10,010 --> 00:44:15,140
short-term model we actually have other

00:44:12,830 --> 00:44:17,570
modeling solutions now when we quite

00:44:15,140 --> 00:44:19,340
soon are gonna get real hardware I guess

00:44:17,570 --> 00:44:22,460
it's scheduled for early next year no

00:44:19,340 --> 00:44:23,810
availability so once that happens I hope

00:44:22,460 --> 00:44:26,060
we're gonna get more time to you know

00:44:23,810 --> 00:44:27,890
get all of this upstream because what I

00:44:26,060 --> 00:44:29,240
ambition is that next time around for

00:44:27,890 --> 00:44:31,730
the next ship we're gonna be even more

00:44:29,240 --> 00:44:35,330
aggressive and when all of this stuff to

00:44:31,730 --> 00:44:37,100
be available if possible and and

00:44:35,330 --> 00:44:39,290
whatever the community feels is good and

00:44:37,100 --> 00:44:41,000
so next time we don't have to reinvent

00:44:39,290 --> 00:44:46,040
as much and we can focus on the new

00:44:41,000 --> 00:44:47,990
stuff yeah a little further is this

00:44:46,040 --> 00:44:50,600
something that is being driven by your

00:44:47,990 --> 00:44:53,120
customers asking for it or is this

00:44:50,600 --> 00:44:55,250
because you know you offer us better

00:44:53,120 --> 00:44:57,530
feature set or more freedom to to

00:44:55,250 --> 00:44:59,390
implement things than other solutions or

00:44:57,530 --> 00:45:03,350
you know what what is the main motivator

00:44:59,390 --> 00:45:06,590
to go okay yeah so I don't think our

00:45:03,350 --> 00:45:08,840
customers specifically asks for qmo they

00:45:06,590 --> 00:45:17,210
don't really know maybe at that level

00:45:08,840 --> 00:45:21,050
but they some of them do young but they

00:45:17,210 --> 00:45:23,480
do ask for solutions that can be

00:45:21,050 --> 00:45:26,000
achieved with qmo and I mean silence has

00:45:23,480 --> 00:45:28,850
been down the path of trying other

00:45:26,000 --> 00:45:30,170
solutions and that I'm not sure if the

00:45:28,850 --> 00:45:31,640
other solutions are gonna stop but I

00:45:30,170 --> 00:45:36,260
think so we're gonna have multiple ways

00:45:31,640 --> 00:45:38,540
of doing it but the qmo ways it's very

00:45:36,260 --> 00:45:43,760
attractive also because of the licensing

00:45:38,540 --> 00:45:45,230
issue if you if you do yeah I don't know

00:45:43,760 --> 00:45:46,430
I don't want to talk too bad I mean arm

00:45:45,230 --> 00:45:49,250
does a lot of good stuff but for example

00:45:46,430 --> 00:45:51,920
the foundation models or they're the

00:45:49,250 --> 00:45:53,240
first models there's a licensing cost

00:45:51,920 --> 00:45:55,280
involved with that so if you want to

00:45:53,240 --> 00:45:57,070
distribute that to you know 300

00:45:55,280 --> 00:46:00,260
developers it becomes very expensive

00:45:57,070 --> 00:46:04,250
whereas a qmo based solution with system

00:46:00,260 --> 00:46:05,960
C could potentially depending on what

00:46:04,250 --> 00:46:08,010
the IP of course but could potentially

00:46:05,960 --> 00:46:10,800
be very cheap too

00:46:08,010 --> 00:46:15,330
to distribute for a customer and as far

00:46:10,800 --> 00:46:20,190
as I know our plans is to publish QM ooh

00:46:15,330 --> 00:46:21,900
pretty much free yeah because the goal

00:46:20,190 --> 00:46:24,360
is ultimately to sell more chips and to

00:46:21,900 --> 00:46:27,900
enable more people to to do stuff with

00:46:24,360 --> 00:46:30,410
our chips Thanks

00:46:27,900 --> 00:46:30,410
Thanks

00:46:33,990 --> 00:46:43,880
do you have any examples there of the

00:46:36,330 --> 00:46:43,880
fdt files use to configure the yes I do

00:46:44,630 --> 00:46:51,410
I'll scare people away if I serve a year

00:46:47,280 --> 00:46:51,410
but I can do deter

00:47:17,760 --> 00:47:27,550
actually I'm not sure I can I can show

00:47:23,650 --> 00:47:29,860
you a small one there's still a little

00:47:27,550 --> 00:47:35,160
bit of secrecy in there and I'm not sure

00:47:29,860 --> 00:47:35,160
I want to show too much here but

00:47:47,380 --> 00:47:54,520
okay so for example here this and of

00:47:52,720 --> 00:47:58,120
course there's a macro here but if you

00:47:54,520 --> 00:47:59,950
ignore that and this device here will

00:47:58,120 --> 00:48:03,160
actually instantiate a memory attribute

00:47:59,950 --> 00:48:05,950
object the QM object and it will set

00:48:03,160 --> 00:48:08,170
this secure property of that object to

00:48:05,950 --> 00:48:10,360
be secure and you can select the master

00:48:08,170 --> 00:48:14,230
ID and then we use the macro to

00:48:10,360 --> 00:48:22,990
instantiate a few of them can maybe show

00:48:14,230 --> 00:48:27,090
you there yeah I'm not sure what I can

00:48:22,990 --> 00:48:28,890
show you here without a leaking okay

00:48:27,090 --> 00:48:44,650
should be fine

00:48:28,890 --> 00:48:47,220
let's do them all right so here's one so

00:48:44,650 --> 00:48:51,580
here's this basically the PM you block

00:48:47,220 --> 00:48:53,470
instantiating CPUs and as you can see

00:48:51,580 --> 00:48:54,520
here the list of attributes is huge

00:48:53,470 --> 00:49:00,310
because we need all of them to

00:48:54,520 --> 00:49:03,490
instantiate the exact model this big is

00:49:00,310 --> 00:49:04,750
this readable not okay yeah so you see

00:49:03,490 --> 00:49:08,800
that that's just configuration of the

00:49:04,750 --> 00:49:12,460
CPU actually Alistair has been working

00:49:08,800 --> 00:49:14,890
on converting this basically we have all

00:49:12,460 --> 00:49:17,530
of these options in micro place in the

00:49:14,890 --> 00:49:19,660
macro based model of qmo but we didn't

00:49:17,530 --> 00:49:21,940
have them as properties we basically had

00:49:19,660 --> 00:49:26,440
a registers at the board model edit and

00:49:21,940 --> 00:49:29,590
Alistair is converting that map right so

00:49:26,440 --> 00:49:34,090
now they're being converted to proper QM

00:49:29,590 --> 00:49:38,110
properties so when when Anthony came up

00:49:34,090 --> 00:49:40,540
with the QM concept one of his goals had

00:49:38,110 --> 00:49:45,040
been to drive the machine definition

00:49:40,540 --> 00:49:50,230
through config files so I wonder do you

00:49:45,040 --> 00:49:51,440
rely on having the dtb to device

00:49:50,230 --> 00:49:53,780
instantiation

00:49:51,440 --> 00:49:56,960
inside to MU or would it be possible to

00:49:53,780 --> 00:49:58,430
have that as an external tool right so I

00:49:56,960 --> 00:50:01,460
remember that was one of the comments

00:49:58,430 --> 00:50:03,710
when we tried to upstream and we have it

00:50:01,460 --> 00:50:06,530
inside today but there is no reason

00:50:03,710 --> 00:50:10,549
white really needs to be there it could

00:50:06,530 --> 00:50:12,470
very well be I mean if there was a qmp

00:50:10,549 --> 00:50:15,109
way of for example creating the

00:50:12,470 --> 00:50:18,589
connections from a remote let's say a

00:50:15,109 --> 00:50:21,349
Python script that parses device 3 or

00:50:18,589 --> 00:50:24,109
another format and can kind of from

00:50:21,349 --> 00:50:27,440
remote gradually create the machine that

00:50:24,109 --> 00:50:30,589
would work - is that what you meant or

00:50:27,440 --> 00:50:32,420
yeah yeah kind of so I'm guessing what

00:50:30,589 --> 00:50:34,339
was problematic there is probably still

00:50:32,420 --> 00:50:39,849
there's devices with with the memory

00:50:34,339 --> 00:50:39,849
mappings with the memory regions

00:51:00,470 --> 00:51:04,630
well the kid you maybe

00:51:13,240 --> 00:51:18,280
so maybe summarize it as known problems

00:51:16,150 --> 00:51:21,970
that people have somewhere down there to

00:51:18,280 --> 00:51:24,580
do with right but I don't think we have

00:51:21,970 --> 00:51:27,480
awfully many patches to enable this in

00:51:24,580 --> 00:51:32,410
our tree and most of that has been

00:51:27,480 --> 00:51:34,180
upstream this I don't think so I may be

00:51:32,410 --> 00:51:40,120
lying a little bit but I don't think so

00:51:34,180 --> 00:51:43,330
I mean there's this all of their 50 fdt

00:51:40,120 --> 00:51:51,390
parsing but beyond that I don't know I

00:51:43,330 --> 00:51:51,390
don't think there's so much all right

00:51:53,520 --> 00:51:56,830
okay so this is what it looks like and

00:51:55,840 --> 00:51:59,530
when we create them

00:51:56,830 --> 00:52:10,780
the Rams here's a memory region you can

00:51:59,530 --> 00:52:15,030
see the bus for the PMU right right and

00:52:10,780 --> 00:52:15,030
if we have the multi art set up

00:52:24,710 --> 00:52:30,320
this is basically a memory region in

00:52:26,360 --> 00:52:39,190
camo when you're right everything when

00:52:30,320 --> 00:52:45,490
you're right transactions okay

00:52:39,190 --> 00:52:45,490

YouTube URL: https://www.youtube.com/watch?v=L5zG5Aukfek


