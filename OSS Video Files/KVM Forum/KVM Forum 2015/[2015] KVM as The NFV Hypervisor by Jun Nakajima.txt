Title: [2015] KVM as The NFV Hypervisor by Jun Nakajima
Publication date: 2015-09-08
Playlist: KVM Forum 2015
Description: 
	As we have continued on KVM enhancements for NFV since the last KVM Forum, we provide an update and details on the enhancements, focusing on the two top priority features as the NFV hypervisor: deterministic execution and inter-VM (Virtual Machine) communication. Deterministic execution is required to guarantee minimal latency variation for data plane NFV, and there are various factors that contribute to latencies and jitters. We present our solutions, showing how hardware and software enhancements can help when reducing latency variations. To implement inter-VM communication using our memory view switching feature, we employ the vhost-user feature in vswitches. By sharing information with vswitches, the source VM can directly access the destination VM or the shared pages in a protected and efficient fashion. We show an implementation that works with OVS that uses the DPDK netdev.

Jun Nakajima
Intel
Principal Engineer
Jun Nakajima is a Senior Principal Engineer leading open source virtualization and cloud projects, such as, KVM, Xen, and OpenStack at the Intel Open Source Technology Center. Jun has been working on various virtualization projects for almost a decade, and NFV is one of his ongoing projects. Jun presented a number of times at technical conferences, including KVM Forum, Xen Summit, and USENIX. He has over 20 years of experience with operating system internals and virtualization.

Slides: https://drive.google.com/file/d/0BzyAwvVlQckeT1hHTnFLQ29rQVk/view?usp=sharing
Captions: 
	00:00:15,379 --> 00:00:22,580
okay let's get started so I'm a Jew

00:00:18,240 --> 00:00:26,670
nakajima from all intel on you know I

00:00:22,580 --> 00:00:29,310
presented the NFC last year's and so

00:00:26,670 --> 00:00:36,570
i'll talk about the update since last

00:00:29,310 --> 00:00:38,550
year and all sorry all the people here

00:00:36,570 --> 00:00:40,920
are discs you know contribute to this

00:00:38,550 --> 00:00:47,070
project and then this presentation is

00:00:40,920 --> 00:00:50,910
still credit to them so we have a kb m

00:00:47,070 --> 00:00:54,350
enhancement project for NFP at you know

00:00:50,910 --> 00:00:58,320
at the OPN FB so i will talk about

00:00:54,350 --> 00:01:01,289
basically double what we are doing there

00:00:58,320 --> 00:01:04,739
are physically then especially the

00:01:01,289 --> 00:01:07,200
deterministic execution and minimal

00:01:04,739 --> 00:01:10,080
latency and then the other one is the

00:01:07,200 --> 00:01:13,710
Inca BM communication basically we

00:01:10,080 --> 00:01:16,710
propose this one and the name is kind of

00:01:13,710 --> 00:01:22,619
tentative so but it's kind of leaf rag

00:01:16,710 --> 00:01:25,320
how we do that ok just be cap well there

00:01:22,619 --> 00:01:28,909
you know refresh your memory are just in

00:01:25,320 --> 00:01:32,340
case you forgot what enemies but

00:01:28,909 --> 00:01:34,470
essentially this is a you know the

00:01:32,340 --> 00:01:38,220
software ensure software is depressing

00:01:34,470 --> 00:01:42,000
the audio right so you have a today we

00:01:38,220 --> 00:01:45,810
have a hard your network appliance then

00:01:42,000 --> 00:01:48,570
the idea of NFP our vision is to

00:01:45,810 --> 00:01:53,159
consolidate those hard your network

00:01:48,570 --> 00:01:57,649
equipment types in on 2d are you know

00:01:53,159 --> 00:02:00,930
the bottom standard servers using a

00:01:57,649 --> 00:02:05,520
virtualization technology okay so

00:02:00,930 --> 00:02:08,429
typical kind of framework this is a very

00:02:05,520 --> 00:02:11,520
you know kind of conceptual picture but

00:02:08,429 --> 00:02:13,680
it's it's not just a hypervisor you need

00:02:11,520 --> 00:02:17,340
to have an orchestration like

00:02:13,680 --> 00:02:20,519
in stock and also SDN controller you

00:02:17,340 --> 00:02:24,659
know open daylight then you can find

00:02:20,519 --> 00:02:28,939
that NFP infrastructure powered by kvm a

00:02:24,659 --> 00:02:32,250
container and on top of that you have a

00:02:28,939 --> 00:02:34,920
VN apps you know those are the ones that

00:02:32,250 --> 00:02:37,400
the hardware equipment today and that we

00:02:34,920 --> 00:02:42,569
are you know those will be replaced by

00:02:37,400 --> 00:02:44,969
software so there that the latency and

00:02:42,569 --> 00:02:46,560
then high performance or critical

00:02:44,969 --> 00:02:48,480
because they were basically software is

00:02:46,560 --> 00:02:53,030
competing with hardware right otherwise

00:02:48,480 --> 00:03:01,019
we cannot achieve that kind of thing ok

00:02:53,030 --> 00:03:03,150
we start then to accelerate like an infp

00:03:01,019 --> 00:03:06,659
adoption the last year i think the

00:03:03,150 --> 00:03:10,980
october last october OPN FP consortium

00:03:06,659 --> 00:03:14,969
was established then the kb m is a

00:03:10,980 --> 00:03:18,479
critic crucial to the OPN fe because the

00:03:14,969 --> 00:03:22,470
OPN FV depends on those upstream project

00:03:18,479 --> 00:03:27,090
the oxy and a kvm OpenStack and an open

00:03:22,470 --> 00:03:30,359
daylight and as you see them many

00:03:27,090 --> 00:03:33,349
companies out there I think I can't

00:03:30,359 --> 00:03:42,509
believe you guys are they all right so I

00:03:33,349 --> 00:03:46,199
ok now in fact last month you know we

00:03:42,509 --> 00:03:49,139
propose the project which is a kb m

00:03:46,199 --> 00:03:51,959
enhancement will n fe that was approved

00:03:49,139 --> 00:03:56,040
now this is official project at the OPN

00:03:51,959 --> 00:03:59,250
fe ok so we are focusing on basically

00:03:56,040 --> 00:04:01,769
three project one is minimal in

00:03:59,250 --> 00:04:04,439
interpolate AC and Inter BM

00:04:01,769 --> 00:04:08,400
communication then the third one is a

00:04:04,439 --> 00:04:10,409
fast live migration I don't talk about

00:04:08,400 --> 00:04:13,049
first migrated live migration today

00:04:10,409 --> 00:04:17,250
because the next session in a different

00:04:13,049 --> 00:04:21,539
room will how about this one ok and for

00:04:17,250 --> 00:04:26,370
the first one thanks to the rican dia

00:04:21,539 --> 00:04:29,210
yesterday they cover that real-time kbm

00:04:26,370 --> 00:04:32,880
and this one you know the first one

00:04:29,210 --> 00:04:36,449
heavy depends on that real type of kbm

00:04:32,880 --> 00:04:40,949
so i can actually you know save in my

00:04:36,449 --> 00:04:44,850
time skipping the details and just uh

00:04:40,949 --> 00:04:48,510
you know d hbu or at the high level okay

00:04:44,850 --> 00:04:57,350
and also show some number that we have

00:04:48,510 --> 00:05:00,720
ok so again this having a deterministic

00:04:57,350 --> 00:05:09,080
execution or the minimal latency is

00:05:00,720 --> 00:05:15,740
critical for NFP ok so just a recap

00:05:09,080 --> 00:05:18,060
where those are ranges are coming from

00:05:15,740 --> 00:05:22,680
there are synchronous events like a

00:05:18,060 --> 00:05:26,220
interrupt or vm exit or cache misses at

00:05:22,680 --> 00:05:29,250
till mrs. they they can happen at any

00:05:26,220 --> 00:05:33,110
time asynchronous fashion so somehow we

00:05:29,250 --> 00:05:36,330
need to minimize you know those

00:05:33,110 --> 00:05:40,860
asynchronous events if they happen we

00:05:36,330 --> 00:05:44,240
will need to mitigate all that you know

00:05:40,860 --> 00:05:53,760
that the handling of all the TLB misses

00:05:44,240 --> 00:05:55,680
ok now software also can have an issue

00:05:53,760 --> 00:05:57,660
for example if you have a spin locks and

00:05:55,680 --> 00:05:59,490
you don't know how how long it takes to

00:05:57,660 --> 00:06:02,520
get up the spin lock or if you have

00:05:59,490 --> 00:06:04,590
mutex right and Wrigley yesterday also

00:06:02,520 --> 00:06:06,900
talked about or the need for the

00:06:04,590 --> 00:06:10,169
realtime kernel you know linux right so

00:06:06,900 --> 00:06:12,030
the software is also important on also

00:06:10,169 --> 00:06:14,010
your applications right if you your

00:06:12,030 --> 00:06:17,699
applications are not we are Tom ready

00:06:14,010 --> 00:06:20,460
than you know you can expect any real

00:06:17,699 --> 00:06:22,979
time behavior of course right and other

00:06:20,460 --> 00:06:26,180
thing is exit to the user level which

00:06:22,979 --> 00:06:29,940
means for example in case of a kb m if

00:06:26,180 --> 00:06:33,210
you know you exit to the qm you I think

00:06:29,940 --> 00:06:35,310
also people you know people talked about

00:06:33,210 --> 00:06:37,800
I think Leon was somebody talked about

00:06:35,310 --> 00:06:39,660
also Rick talked about the issue with

00:06:37,800 --> 00:06:47,340
God with

00:06:39,660 --> 00:06:50,520
um you right the other thing is a hard

00:06:47,340 --> 00:06:56,640
year so we've also rico so talked about

00:06:50,520 --> 00:07:01,740
SMI oh this is nasty right we really

00:06:56,640 --> 00:07:03,750
need to work with are we really want to

00:07:01,740 --> 00:07:06,960
work with the other vendors make sure

00:07:03,750 --> 00:07:10,650
you know they can disable s my for nfe

00:07:06,960 --> 00:07:13,260
purposes and power management like a cpu

00:07:10,650 --> 00:07:16,530
you know deep state if all processors

00:07:13,260 --> 00:07:18,990
enter the deep state and then it takes a

00:07:16,530 --> 00:07:22,560
properly sub micro second or something

00:07:18,990 --> 00:07:24,870
depending how deep the test data it

00:07:22,560 --> 00:07:27,530
takes some time to get out of the

00:07:24,870 --> 00:07:30,750
daughters you know deep sea state and

00:07:27,530 --> 00:07:33,960
sometimes a neatnik itself can cause

00:07:30,750 --> 00:07:36,990
some our agency before you have you know

00:07:33,960 --> 00:07:40,410
if you don't use a queue as feature of

00:07:36,990 --> 00:07:44,280
the neck especially combined Lisa SRO be

00:07:40,410 --> 00:07:47,160
okay so those are kind of out the cause

00:07:44,280 --> 00:07:49,790
of latency I just want to talk about the

00:07:47,160 --> 00:07:54,750
high level solution then this is a

00:07:49,790 --> 00:07:59,340
summary of what I think of Rick or young

00:07:54,750 --> 00:08:02,010
nation so we need some exclusive

00:07:59,340 --> 00:08:07,440
allocation of resources especially for

00:08:02,010 --> 00:08:12,270
example CPU or memory right so typically

00:08:07,440 --> 00:08:15,030
we need to have a partitioning okay this

00:08:12,270 --> 00:08:18,480
can be done by also CP i-- solo cpu or

00:08:15,030 --> 00:08:21,990
see groups okay and we want to use a

00:08:18,480 --> 00:08:24,630
huge pages to mitigate the TLB miss

00:08:21,990 --> 00:08:27,840
because if you have a large pages then

00:08:24,630 --> 00:08:30,510
deferring a TLB is much faster so you

00:08:27,840 --> 00:08:36,060
would really want to use a huge page

00:08:30,510 --> 00:08:39,120
table of huge pages and software so we

00:08:36,060 --> 00:08:43,320
need a real time okay BM there okay not

00:08:39,120 --> 00:08:47,070
just a host we also we now need a real

00:08:43,320 --> 00:08:49,080
time guest otherwise even the kb m is

00:08:47,070 --> 00:08:50,520
the world you know support real-time its

00:08:49,080 --> 00:08:52,800
guests doesn't

00:08:50,520 --> 00:08:58,680
you know provide real-time capability

00:08:52,800 --> 00:09:01,050
and then you don't get real time the

00:08:58,680 --> 00:09:04,170
other thing is the hardware technology

00:09:01,050 --> 00:09:08,450
we have example the cash allocation take

00:09:04,170 --> 00:09:12,300
technology or the advanced BTW features

00:09:08,450 --> 00:09:16,080
okay probably i don't need to cover this

00:09:12,300 --> 00:09:19,290
one other rick mentioned this one but i

00:09:16,080 --> 00:09:21,950
have a probably picture so then you can

00:09:19,290 --> 00:09:25,350
see the picture it's essentially you can

00:09:21,950 --> 00:09:28,950
you know partition the last level cache

00:09:25,350 --> 00:09:31,980
for applications or BMS so that we can

00:09:28,950 --> 00:09:38,460
you know increase the determinism right

00:09:31,980 --> 00:09:42,450
and what it's really telling is you have

00:09:38,460 --> 00:09:47,490
a two options okay one is limited cash

00:09:42,450 --> 00:09:51,660
or are unlimited cash with noisy

00:09:47,490 --> 00:09:54,810
neighbors so which do you choose okay

00:09:51,660 --> 00:09:59,040
and our test performance measurement

00:09:54,810 --> 00:10:02,310
shows it's better to go with the limited

00:09:59,040 --> 00:10:05,160
cash for you otherwise this you know the

00:10:02,310 --> 00:10:09,980
noisy labels got a noisy neighbors gonna

00:10:05,160 --> 00:10:14,010
take you a cash waiting and consume okay

00:10:09,980 --> 00:10:17,610
so there are many presentations are

00:10:14,010 --> 00:10:21,210
going on we have a IDF right this week

00:10:17,610 --> 00:10:22,830
so if you're interested in look at the

00:10:21,210 --> 00:10:29,690
in a white paper also protect

00:10:22,830 --> 00:10:32,670
presentations so about the data okay

00:10:29,690 --> 00:10:36,360
this is a similar to what the risks

00:10:32,670 --> 00:10:39,690
should of course because we are kind of

00:10:36,360 --> 00:10:42,000
working together so the machines are

00:10:39,690 --> 00:10:48,750
different but we have a very similar

00:10:42,000 --> 00:10:52,980
result and if you look at more than

00:10:48,750 --> 00:10:57,390
ninety seven percent are there right

00:10:52,980 --> 00:11:03,450
here you can see right and there's one

00:10:57,390 --> 00:11:04,120
of the five outliers right which causes

00:11:03,450 --> 00:11:09,040
much

00:11:04,120 --> 00:11:15,279
my latency which is a 5 out of AD medium

00:11:09,040 --> 00:11:19,029
okay this is a total number okay

00:11:15,279 --> 00:11:22,060
basically 80 million so this outer area

00:11:19,029 --> 00:11:25,839
the occurrence of this one is less than

00:11:22,060 --> 00:11:27,790
10 current spot 10 million okay so this

00:11:25,839 --> 00:11:31,600
is a good good number but this is a

00:11:27,790 --> 00:11:40,540
cyclic test and kind of you know not

00:11:31,600 --> 00:11:44,350
really pract mean it's not using device

00:11:40,540 --> 00:11:48,070
pci device or you know when system needs

00:11:44,350 --> 00:11:50,770
to work with the pci nic devices this is

00:11:48,070 --> 00:11:55,180
this may not reflect that what do you

00:11:50,770 --> 00:11:59,279
see now i have a other data that which

00:11:55,180 --> 00:12:03,040
uses audio harder you okay in this case

00:11:59,279 --> 00:12:06,910
what we measure is that the latency in

00:12:03,040 --> 00:12:10,300
the interrupt handler in the guest okay

00:12:06,910 --> 00:12:14,529
so we use a pci device actually this is

00:12:10,300 --> 00:12:16,720
a fpga device and then we program this

00:12:14,529 --> 00:12:20,380
device so that it can generate one

00:12:16,720 --> 00:12:23,940
millisecond timer interim and this is

00:12:20,380 --> 00:12:26,740
very precise okay then we measured the

00:12:23,940 --> 00:12:29,709
latency and actually this is a better

00:12:26,740 --> 00:12:31,150
than cyclic test the reason is the

00:12:29,709 --> 00:12:35,350
cyclic test I think it yesterday

00:12:31,150 --> 00:12:38,260
somebody pointed out but the results

00:12:35,350 --> 00:12:43,120
from psychics test includes that time to

00:12:38,260 --> 00:12:45,790
program that the timer in the guest so

00:12:43,120 --> 00:12:49,540
for example if it uses a Detroit timer

00:12:45,790 --> 00:12:53,290
then that causes a BM exit okay so that

00:12:49,540 --> 00:12:58,529
basically increase the time to program

00:12:53,290 --> 00:13:03,520
that the timer and also the cyclic test

00:12:58,529 --> 00:13:06,520
itself runs in user level okay so the

00:13:03,520 --> 00:13:12,000
sum that you know a schedule in the

00:13:06,520 --> 00:13:14,680
kernel or not we are also included there

00:13:12,000 --> 00:13:16,279
so I'm are now switching gear to the

00:13:14,680 --> 00:13:23,149
antebellum communication

00:13:16,279 --> 00:13:26,689
okay before that I'll want to talk about

00:13:23,149 --> 00:13:30,439
that the communication model lovely we

00:13:26,689 --> 00:13:36,230
have a tunable then so one depending on

00:13:30,439 --> 00:13:39,620
the API the program water you use so if

00:13:36,230 --> 00:13:43,069
your specific API what I have in mind is

00:13:39,620 --> 00:13:45,980
for example I caddy pdk okay and in this

00:13:43,069 --> 00:13:49,759
case this switch directly Turks to the

00:13:45,980 --> 00:13:54,709
neck for example okay then this guy

00:13:49,759 --> 00:13:57,499
provides some shared memory so that the

00:13:54,709 --> 00:14:01,389
processes can talk with you know to the

00:13:57,499 --> 00:14:05,089
suite or BB C but send the packet okay

00:14:01,389 --> 00:14:08,809
so packets go like this you know one it

00:14:05,089 --> 00:14:12,800
won't I just be play okay when the

00:14:08,809 --> 00:14:15,259
packets want to send the vm 12 v m2 you

00:14:12,800 --> 00:14:18,740
go to this switch and like this that's

00:14:15,259 --> 00:14:22,490
when you use the specific API or

00:14:18,740 --> 00:14:25,430
something like a DP DK so deals there

00:14:22,490 --> 00:14:28,160
are other way which basically provides

00:14:25,430 --> 00:14:31,129
and network semantics if we you for

00:14:28,160 --> 00:14:33,949
example use the OS right that provides

00:14:31,129 --> 00:14:39,740
the network semantics then you use a

00:14:33,949 --> 00:14:41,329
networking API so in this case you know

00:14:39,740 --> 00:14:44,540
I'm not recommending this one this is

00:14:41,329 --> 00:14:47,600
the slowest path so that sews very slow

00:14:44,540 --> 00:14:50,540
the reason is you know the packets go

00:14:47,600 --> 00:14:53,569
through this the hypervisor and the V

00:14:50,540 --> 00:14:57,230
switch in that the colonel and then take

00:14:53,569 --> 00:15:00,079
you know causing lots of or transition

00:14:57,230 --> 00:15:03,920
and sometimes copying right so that's

00:15:00,079 --> 00:15:10,059
the slow and in n fe we don't do this

00:15:03,920 --> 00:15:14,870
right so then we have a V host user

00:15:10,059 --> 00:15:21,139
essentially be host user allow this V

00:15:14,870 --> 00:15:25,870
switch to directly access that the

00:15:21,139 --> 00:15:29,710
virtues of the guests okay so that way

00:15:25,870 --> 00:15:35,320
for example if

00:15:29,710 --> 00:15:41,890
bm1 sin or to the the other BM then I'll

00:15:35,320 --> 00:15:47,230
do the epr gain okay sure it hopes this

00:15:41,890 --> 00:15:50,830
is row case and then this is a be host

00:15:47,230 --> 00:15:53,350
to use our case okay well like this so

00:15:50,830 --> 00:15:55,510
we bypassed the colonel and then of

00:15:53,350 --> 00:15:58,030
course the beasts which knows he knows

00:15:55,510 --> 00:16:03,160
about you know that the switching rules

00:15:58,030 --> 00:16:07,620
are saying right and this is a typical

00:16:03,160 --> 00:16:14,010
way of example we have our obsd pdk then

00:16:07,620 --> 00:16:20,440
with be host user what snob switch okay

00:16:14,010 --> 00:16:24,610
now how can we make it even faster okay

00:16:20,440 --> 00:16:28,030
so if we use a special p I what we can

00:16:24,610 --> 00:16:32,590
do is basically I don't talk to the

00:16:28,030 --> 00:16:37,150
switch okay so something like this this

00:16:32,590 --> 00:16:40,810
way the BM one can directly send a

00:16:37,150 --> 00:16:44,220
package to the vm to without talking to

00:16:40,810 --> 00:16:50,410
the wall or bothering that the switch

00:16:44,220 --> 00:16:53,740
okay now if we have a networking API

00:16:50,410 --> 00:16:56,830
than what what needs to happen so what

00:16:53,740 --> 00:17:02,400
we need is something like in vm switch

00:16:56,830 --> 00:17:05,680
okay basically we cannot send the packet

00:17:02,400 --> 00:17:10,480
ignoring that what's which says right so

00:17:05,680 --> 00:17:13,800
we have to have some small cache of you

00:17:10,480 --> 00:17:17,940
know the vm switch will has a cache of

00:17:13,800 --> 00:17:17,940
the beasts which basically

00:17:20,339 --> 00:17:26,730
okay I'll talk about more details later

00:17:22,500 --> 00:17:32,779
okay so in this case the packets go

00:17:26,730 --> 00:17:36,120
right this ok so now I'm talking about

00:17:32,779 --> 00:17:40,650
the implementation and kind of a

00:17:36,120 --> 00:17:43,890
proposal are based on be host user goes

00:17:40,650 --> 00:17:52,309
just to use a be host use a sham sham

00:17:43,890 --> 00:18:00,029
man so what we want one is first of all

00:17:52,309 --> 00:18:01,770
want to add our fast pass nvm to

00:18:00,029 --> 00:18:05,460
optimize that the interview m

00:18:01,770 --> 00:18:11,000
communication that's what we need so you

00:18:05,460 --> 00:18:13,649
see the Emir switch here then also

00:18:11,000 --> 00:18:15,899
whenever you want to send a packet we

00:18:13,649 --> 00:18:19,770
want to direct you know send a packet

00:18:15,899 --> 00:18:23,250
from here to this and if we don't have

00:18:19,770 --> 00:18:27,659
this fast pass what the Beast which does

00:18:23,250 --> 00:18:29,820
is will be host user he just access from

00:18:27,659 --> 00:18:32,059
here to here the support queue here

00:18:29,820 --> 00:18:32,059
right

00:18:36,700 --> 00:18:48,790
then like I said this mbm switch cannot

00:18:42,730 --> 00:18:52,190
ignore what so it says so it must have

00:18:48,790 --> 00:18:55,280
consistent for example row table okay

00:18:52,190 --> 00:19:03,680
that must be consistent and should be

00:18:55,280 --> 00:19:10,010
cash and also if this is a optional

00:19:03,680 --> 00:19:12,640
probably but done yeah when I talked

00:19:10,010 --> 00:19:14,990
about this kind of a you know feature

00:19:12,640 --> 00:19:20,420
people some people said it is great

00:19:14,990 --> 00:19:22,610
because of view bm1 in this case can

00:19:20,420 --> 00:19:25,309
directly access as a billion write this

00:19:22,610 --> 00:19:29,059
this is a kind of dangerous even you

00:19:25,309 --> 00:19:33,460
trust this is dangerous right so somehow

00:19:29,059 --> 00:19:37,340
we need to add some protection to the

00:19:33,460 --> 00:19:43,220
access okay so the idea we have is

00:19:37,340 --> 00:19:47,510
basically we open the window when it's

00:19:43,220 --> 00:19:51,290
needed and we want to close that the

00:19:47,510 --> 00:19:54,770
window if that's you that's done okay

00:19:51,290 --> 00:19:58,490
and of course with without you know

00:19:54,770 --> 00:20:02,240
overhead so you could do this by doing a

00:19:58,490 --> 00:20:05,960
hyper call right before the sending you

00:20:02,240 --> 00:20:07,550
hyper call then copy if you done then

00:20:05,960 --> 00:20:12,679
the hypercore back something like that

00:20:07,550 --> 00:20:15,950
but that'd be you know heavy and so

00:20:12,679 --> 00:20:22,550
we're trying to avoid account or station

00:20:15,950 --> 00:20:25,700
okay so when we design this is a design

00:20:22,550 --> 00:20:29,390
objectives so what we want is first of

00:20:25,700 --> 00:20:32,929
all extend the existing be host to user

00:20:29,390 --> 00:20:35,059
as a transport mechanism and that may

00:20:32,929 --> 00:20:40,040
consume work based on that the shared

00:20:35,059 --> 00:20:42,920
memory or our broad cues so once we have

00:20:40,040 --> 00:20:46,940
this one basically we can send the river

00:20:42,920 --> 00:20:49,700
package to other VMS okay

00:20:46,940 --> 00:20:54,050
and they can access the birth q

00:20:49,700 --> 00:20:57,770
directory and that would require mapping

00:20:54,050 --> 00:21:01,460
you know mapping edition of the guests

00:20:57,770 --> 00:21:06,980
memory and also like I said the

00:21:01,460 --> 00:21:12,290
protection of access then on top of that

00:21:06,980 --> 00:21:15,190
then you can build high-performance or

00:21:12,290 --> 00:21:19,040
network applications for example the

00:21:15,190 --> 00:21:23,540
mbms which is one example okay or you

00:21:19,040 --> 00:21:26,540
can provide our service chaining okay or

00:21:23,540 --> 00:21:32,480
maybe you are application and fe

00:21:26,540 --> 00:21:39,470
application so now i will talk about a

00:21:32,480 --> 00:21:43,340
bit more details okay how it works so

00:21:39,470 --> 00:21:48,310
this is a what we have today I just you

00:21:43,340 --> 00:21:53,090
know I didn't I have a more detail but

00:21:48,310 --> 00:21:56,630
this is the same topological it's same

00:21:53,090 --> 00:22:01,330
thing I just loaded a picture just a

00:21:56,630 --> 00:22:05,600
nine degree 90 so this is basically OBS

00:22:01,330 --> 00:22:10,100
DVD gear you have a B host user support

00:22:05,600 --> 00:22:14,180
and this is a qm you okay this is how we

00:22:10,100 --> 00:22:17,780
host user works okay I didn't add

00:22:14,180 --> 00:22:23,600
anything this shows that how it works

00:22:17,780 --> 00:22:26,540
today okay so what we host the user is

00:22:23,600 --> 00:22:29,480
basically gather the information of a

00:22:26,540 --> 00:22:36,830
memory information from our GM you get

00:22:29,480 --> 00:22:40,130
in qm use q mu has a file descriptor for

00:22:36,830 --> 00:22:42,440
the memory region maybe it's hard to see

00:22:40,130 --> 00:22:45,200
but this is the basically says a base

00:22:42,440 --> 00:22:49,190
point based addressable all gasp of

00:22:45,200 --> 00:22:53,930
paper memory and then lengths so it's

00:22:49,190 --> 00:22:59,030
basically memory map table okay so be

00:22:53,930 --> 00:23:00,230
host your user server okay gathers such

00:22:59,030 --> 00:23:07,580
information

00:23:00,230 --> 00:23:10,700
from qm use okay so in a way this server

00:23:07,580 --> 00:23:13,580
has of course he has a today ability to

00:23:10,700 --> 00:23:20,020
access that you know bm's because he

00:23:13,580 --> 00:23:24,410
needs to access the broad cute okay also

00:23:20,020 --> 00:23:27,919
this is a problem our proposed wonderful

00:23:24,410 --> 00:23:30,830
proposal but he could also allocate his

00:23:27,919 --> 00:23:36,740
own memory then make it shareable you

00:23:30,830 --> 00:23:40,250
know make it you know the export that

00:23:36,740 --> 00:23:44,570
kind of shared memory to the are the gas

00:23:40,250 --> 00:23:51,200
qmu you know instant queue mui VMS okay

00:23:44,570 --> 00:23:56,290
for example he can allocate large pages

00:23:51,200 --> 00:24:03,919
they make it shared among the guests

00:23:56,290 --> 00:24:06,500
okay now this is a bit busy but um the

00:24:03,919 --> 00:24:10,340
only difference is this kind of orangie

00:24:06,500 --> 00:24:13,940
seeing okay in this picture you see this

00:24:10,340 --> 00:24:17,450
orange one orange one is BM too okay so

00:24:13,940 --> 00:24:22,150
this is a memory information or bmt okay

00:24:17,450 --> 00:24:26,870
and we this picture shows that being one

00:24:22,150 --> 00:24:30,590
has the in access to be m2 memory

00:24:26,870 --> 00:24:33,679
basically okay and also the other BM has

00:24:30,590 --> 00:24:42,140
a kind of same thing okay so how does

00:24:33,679 --> 00:24:46,010
this work wow so initially a the host

00:24:42,140 --> 00:24:52,820
the user has this kind of information

00:24:46,010 --> 00:24:55,970
right then he can actually he was sober

00:24:52,820 --> 00:24:59,630
but he can be a crying and then sent

00:24:55,970 --> 00:25:03,950
back or send out of though this

00:24:59,630 --> 00:25:10,580
information to other BM okay so that qm

00:25:03,950 --> 00:25:13,760
you can be a server okay so this allows

00:25:10,580 --> 00:25:18,410
that be host to use a colon to access

00:25:13,760 --> 00:25:22,160
is the world queue of other guests or

00:25:18,410 --> 00:25:27,370
that allows her to have a shared memory

00:25:22,160 --> 00:25:30,050
among the crimes okay so have a more

00:25:27,370 --> 00:25:34,280
example this is a simplest example

00:25:30,050 --> 00:25:37,640
probably so in this picture r BM 1 array

00:25:34,280 --> 00:25:40,520
already talked to this V switch or be

00:25:37,640 --> 00:25:44,030
host to user okay again this is for

00:25:40,520 --> 00:25:48,140
example obsd VT k was an absolute okay

00:25:44,030 --> 00:25:55,430
so he has the memory in for over bm1

00:25:48,140 --> 00:25:59,450
okay now bmt is booted and then he will

00:25:55,430 --> 00:26:02,530
also use this one so first thing is he's

00:25:59,450 --> 00:26:08,090
going to send a memory map memory a

00:26:02,530 --> 00:26:12,070
table to be switch okay then he'll get

00:26:08,090 --> 00:26:16,580
the information okay of a memory map

00:26:12,070 --> 00:26:21,410
then it will send to the ascent to the

00:26:16,580 --> 00:26:27,020
information to the qme who then he can

00:26:21,410 --> 00:26:32,680
now q mu extended mapping and he came up

00:26:27,020 --> 00:26:32,680
this one now the BM one can access bm2

00:26:39,010 --> 00:26:46,720
and we have a device that pci device

00:26:43,510 --> 00:26:49,960
here and that basically ma are showing

00:26:46,720 --> 00:26:54,130
the base address of that shared memory

00:26:49,960 --> 00:27:01,060
ok you can ignore that this the control

00:26:54,130 --> 00:27:07,540
structure for now and once so i'll just

00:27:01,060 --> 00:27:14,170
keep pausing once that qm you add the

00:27:07,540 --> 00:27:23,440
memory are you know to the v m2 memory

00:27:14,170 --> 00:27:27,010
to the BM 1 then sorry qm you inject

00:27:23,440 --> 00:27:29,800
interrupted to the BM then the vm will

00:27:27,010 --> 00:27:31,960
get a notification now you know i have a

00:27:29,800 --> 00:27:39,640
more memory so it's kind of memory hot

00:27:31,960 --> 00:27:42,640
pile or in this case the bicep right so

00:27:39,640 --> 00:27:47,050
this is a now i'll talk about how we can

00:27:42,640 --> 00:27:50,050
add the protected access so this picture

00:27:47,050 --> 00:27:53,350
shows the default EPT pt's extended

00:27:50,050 --> 00:27:55,000
paste our page table that maps that the

00:27:53,350 --> 00:27:59,050
guest of physical gets the physical

00:27:55,000 --> 00:28:03,130
address to machine physical okay and in

00:27:59,050 --> 00:28:06,040
a default view are just a mapping that

00:28:03,130 --> 00:28:09,490
the existing gets the page table and

00:28:06,040 --> 00:28:12,520
then i guess to pay just memory then we

00:28:09,490 --> 00:28:16,290
have a BM funk instruction that's

00:28:12,520 --> 00:28:21,490
available in guest and being Frank 0r

00:28:16,290 --> 00:28:27,550
means switch the EPT and then if that

00:28:21,490 --> 00:28:31,390
the new epd has additional mapping then

00:28:27,550 --> 00:28:38,380
in this case the you can access the

00:28:31,390 --> 00:28:40,990
additional area ok then you can get the

00:28:38,380 --> 00:28:47,570
more memory you know the bmt you can

00:28:40,990 --> 00:28:51,260
access more memory with vm park ok ok

00:28:47,570 --> 00:29:01,640
I have a bit more detail so in a fast

00:28:51,260 --> 00:29:05,570
pass in a default view that memory to

00:29:01,640 --> 00:29:10,940
the other vm memory of other BM is not

00:29:05,570 --> 00:29:15,050
are accessible in a default view and if

00:29:10,940 --> 00:29:18,080
you do vm funk then basically thou leave

00:29:15,050 --> 00:29:24,230
it will be visible or accessible that's

00:29:18,080 --> 00:29:27,950
basically how how we add protection so

00:29:24,230 --> 00:29:33,890
we we are proposing a new I ok BMI of

00:29:27,950 --> 00:29:36,950
control for the qm you to extend that

00:29:33,890 --> 00:29:39,830
the guests memory one is one option is

00:29:36,950 --> 00:29:44,330
without protection in this case you

00:29:39,830 --> 00:29:49,040
trust act BMS ok so the window is always

00:29:44,330 --> 00:29:51,290
open the other option is now we will

00:29:49,040 --> 00:29:54,530
need a protection and extend only in

00:29:51,290 --> 00:29:58,160
alternate apt ok that's the kind of

00:29:54,530 --> 00:30:03,190
proposal we have oh this is a very

00:29:58,160 --> 00:30:09,380
detail oriented so I'll skip this one

00:30:03,190 --> 00:30:14,380
but we use this apt permission to

00:30:09,380 --> 00:30:17,390
control that of example in a default EPT

00:30:14,380 --> 00:30:20,450
you don't have any access here because I

00:30:17,390 --> 00:30:26,050
PT permission is none ok there is a

00:30:20,450 --> 00:30:31,600
trampling code page and this is a

00:30:26,050 --> 00:30:37,300
protected code that has access to

00:30:31,600 --> 00:30:44,180
additional page ok so I have a

00:30:37,300 --> 00:30:47,780
performance data from pills POC and so

00:30:44,180 --> 00:30:50,930
far this is what we get so the orange

00:30:47,780 --> 00:30:52,850
run is just a memory copy ok we don't do

00:30:50,930 --> 00:30:55,100
anything so this is kind of theoretical

00:30:52,850 --> 00:30:57,710
performance we cannot you cannot beat

00:30:55,100 --> 00:31:00,880
this one this is just a memory copy do

00:30:57,710 --> 00:31:05,450
nothing the other one is

00:31:00,880 --> 00:31:09,470
just a vm funk okay no trampling page

00:31:05,450 --> 00:31:12,700
okay then the third one is it's closer

00:31:09,470 --> 00:31:19,730
to actual case where we use a trampling

00:31:12,700 --> 00:31:24,230
code okay then lovely we're getting this

00:31:19,730 --> 00:31:31,279
kind of a performance or you know using

00:31:24,230 --> 00:31:35,090
the small packet like a 64-byte and this

00:31:31,279 --> 00:31:37,850
is something like even this one is reka

00:31:35,090 --> 00:31:42,799
for the gigabit count saying you know 10

00:31:37,850 --> 00:31:45,019
gigabit you get a 14 point 7 mega pocket

00:31:42,799 --> 00:31:50,179
passer and that's the thing a bit with

00:31:45,019 --> 00:31:53,029
the 6000 bite okay so this is a summary

00:31:50,179 --> 00:31:56,919
so I talked about you know quickly go

00:31:53,029 --> 00:32:00,399
through this you know me my latency

00:31:56,919 --> 00:32:04,519
project and then interview communication

00:32:00,399 --> 00:32:06,799
to propose that you know be host to user

00:32:04,519 --> 00:32:09,409
base of shared memory and then showed up

00:32:06,799 --> 00:32:12,919
performance data preliminary performance

00:32:09,409 --> 00:32:17,480
data and we are going to talk about the

00:32:12,919 --> 00:32:28,490
fast live migration next out and it's a

00:32:17,480 --> 00:32:34,000
different room ok any questions is the

00:32:28,490 --> 00:32:34,000
question so I work or IDC

00:32:34,460 --> 00:32:37,460
injected

00:32:37,480 --> 00:32:45,049
I pc okay so in this case are the

00:32:42,440 --> 00:32:50,899
receiver is in this industry you'll see

00:32:45,049 --> 00:32:56,899
the ciba is basically pulling yeah in

00:32:50,899 --> 00:32:59,120
this in this case eventually we are

00:32:56,899 --> 00:33:01,820
going to use for example for setting up

00:32:59,120 --> 00:33:04,429
the tube cake to keep go in a push that

00:33:01,820 --> 00:33:07,159
you know send a notification but right

00:33:04,429 --> 00:33:09,320
now we're using a pouring or two on the

00:33:07,159 --> 00:33:12,320
receiver side but send outside is just a

00:33:09,320 --> 00:33:20,090
post right so that's what what Pierce is

00:33:12,320 --> 00:33:22,970
doing so we have a you know the hardware

00:33:20,090 --> 00:33:25,610
has so-called posted interrupt basically

00:33:22,970 --> 00:33:30,249
that can inject interrupt to the guests

00:33:25,610 --> 00:33:30,249
without causing a BMX it yeah

00:33:34,950 --> 00:33:40,559
anyway or if you guys are interested in

00:33:37,529 --> 00:33:42,600
you know join the top enf project sort

00:33:40,559 --> 00:33:50,490
of good so you're through good numbers

00:33:42,600 --> 00:33:53,429
during latency numbers for the three

00:33:50,490 --> 00:33:58,440
happen we have some numbers to special

00:33:53,429 --> 00:34:01,669
about dinner here it's like pretty close

00:33:58,440 --> 00:34:01,669
to marry couples

00:34:06,650 --> 00:34:11,630

YouTube URL: https://www.youtube.com/watch?v=KMdNCHGlP00


