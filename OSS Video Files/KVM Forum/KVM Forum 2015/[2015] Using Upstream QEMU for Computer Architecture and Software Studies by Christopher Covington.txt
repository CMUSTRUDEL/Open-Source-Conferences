Title: [2015] Using Upstream QEMU for Computer Architecture and Software Studies by Christopher Covington
Publication date: 2015-09-02
Playlist: KVM Forum 2015
Description: 
	There have been repeated efforts to make QEMU useful for computer architecture and software studies, but little of this has successfully been merged upstream. Christopher Covington will discuss example use cases, such as fast forwarding, instruction and data tracing, and basic block vector collection. He will go on to describe past and present efforts to merge such functionality upstream, including ARM PMU and ETM hardware emulation, and solicit suggestions for future work.

Christopher Covington
I am employed by Qualcomm Innovation Center, Inc. but don a Linaro hat for QEMU contributions. My current work involves using the Linux kernel, VirtIO-MMIO, QEMU system emulation, and Checkpoint and Restore In Userspace (CRIU) to enable computer architecture and software optimization studies. I have previously spoken at the Linux Plumbers Conference.

Slides: https://drive.google.com/file/d/0BzyAwvVlQckebHNvSW0tWEtaQzQ/view?usp=sharing
Captions: 
	00:00:15,199 --> 00:00:23,880
all right good afternoon everyone I'll

00:00:19,439 --> 00:00:25,080
begin with a kind of simple analogy you

00:00:23,880 --> 00:00:28,109
know sometimes it's good to have

00:00:25,080 --> 00:00:30,150
different zoom levels if you want to

00:00:28,109 --> 00:00:32,520
know what state you're next to or States

00:00:30,150 --> 00:00:34,230
you know the map on the left tells you

00:00:32,520 --> 00:00:35,940
very clearly if you were to try to

00:00:34,230 --> 00:00:37,950
figure that out with the map on the

00:00:35,940 --> 00:00:41,129
right you have to pan over really far

00:00:37,950 --> 00:00:42,450
but if you want to know what lakes and

00:00:41,129 --> 00:00:45,480
sounds and whatever else you next to

00:00:42,450 --> 00:00:49,520
maybe the zoomed in one gives you a more

00:00:45,480 --> 00:00:55,079
obvious picture of that and so this is

00:00:49,520 --> 00:00:59,340
in part a a story of how i'm using q mu

00:00:55,079 --> 00:01:00,870
2 as one of those zoom levels for

00:00:59,340 --> 00:01:03,359
figuring out computer architecture

00:01:00,870 --> 00:01:08,909
questions and software analysis software

00:01:03,359 --> 00:01:10,229
optimization questions and my name is

00:01:08,909 --> 00:01:12,659
Christopher Covington I'm employed by

00:01:10,229 --> 00:01:16,350
Qualcomm innovation center incorporated

00:01:12,659 --> 00:01:21,680
also sometimes doing activity through

00:01:16,350 --> 00:01:24,630
linaro through an arrangement there and

00:01:21,680 --> 00:01:26,880
i'll be talking today i'll give some

00:01:24,630 --> 00:01:28,860
some brief definitions background where

00:01:26,880 --> 00:01:34,290
I'm coming from definition of things

00:01:28,860 --> 00:01:37,590
that are not common in my estimation in

00:01:34,290 --> 00:01:39,659
the Q mu kvm world I'm going to discuss

00:01:37,590 --> 00:01:42,060
a number of mostly Forks that I've

00:01:39,659 --> 00:01:45,600
encountered of Q mu that took the code

00:01:42,060 --> 00:01:46,970
base and did neat things with it and

00:01:45,600 --> 00:01:50,250
then I'm going to kind of cherry pick

00:01:46,970 --> 00:01:53,549
some of their some of the use cases they

00:01:50,250 --> 00:01:56,700
implemented talk about how I use them

00:01:53,549 --> 00:02:00,270
while I think they're useful and and I

00:01:56,700 --> 00:02:03,420
have implemented a number of these or me

00:02:00,270 --> 00:02:04,979
or colleagues and and sent them out as

00:02:03,420 --> 00:02:07,979
patches but I think it needs a lot more

00:02:04,979 --> 00:02:12,450
work to really get into the right shape

00:02:07,979 --> 00:02:13,850
and during the use cases I think it'd be

00:02:12,450 --> 00:02:17,270
most useful to attack

00:02:13,850 --> 00:02:21,380
each use case as we go with discussion

00:02:17,270 --> 00:02:23,420
so I'd welcome that so I mostly come

00:02:21,380 --> 00:02:27,260
from an Eric 64 background started with

00:02:23,420 --> 00:02:31,760
that out of college if i use weird

00:02:27,260 --> 00:02:35,210
terminology that that's why so also and

00:02:31,760 --> 00:02:37,370
when you're trying to figure out what

00:02:35,210 --> 00:02:40,760
the best microprocessor design to

00:02:37,370 --> 00:02:42,890
implement is you need lots of different

00:02:40,760 --> 00:02:45,710
models and some of them are fast some of

00:02:42,890 --> 00:02:47,270
them are really really really slow and

00:02:45,710 --> 00:02:49,550
so starting with the fast ones you have

00:02:47,270 --> 00:02:52,880
functional models like qm you that

00:02:49,550 --> 00:02:54,830
operate on sort of is a level

00:02:52,880 --> 00:02:57,260
instruction set architecture that you

00:02:54,830 --> 00:02:58,910
know they can count instructions they

00:02:57,260 --> 00:03:00,920
don't really have any clue what a real

00:02:58,910 --> 00:03:03,110
cycle count would be a timing model

00:03:00,920 --> 00:03:06,380
tries to figure out that cycle count may

00:03:03,110 --> 00:03:08,780
be approximately and then you you might

00:03:06,380 --> 00:03:09,950
simulate your your Verilog or VHDL and

00:03:08,780 --> 00:03:12,950
that's probably the really slowest thing

00:03:09,950 --> 00:03:17,270
but I mention it because I try to run

00:03:12,950 --> 00:03:19,910
stuff like that sometimes and cRIO

00:03:17,270 --> 00:03:22,460
checkpoint restore in user space is a

00:03:19,910 --> 00:03:24,200
neat little project it's kind of like vm

00:03:22,460 --> 00:03:27,110
snapshots but you don't have to have a

00:03:24,200 --> 00:03:31,040
vm you just have to have linux and so I

00:03:27,110 --> 00:03:34,130
I use that also i forgot to put on this

00:03:31,040 --> 00:03:36,770
but i'm mostly using qmu right now i'm

00:03:34,130 --> 00:03:37,820
only using qmu in TCG mode it'd be

00:03:36,770 --> 00:03:42,620
interesting to do some of these things

00:03:37,820 --> 00:03:44,120
with kvm perhaps but maybe I I haven't

00:03:42,620 --> 00:03:47,180
thought through how to make that all

00:03:44,120 --> 00:03:50,540
work and then this fast forwarding thing

00:03:47,180 --> 00:03:52,250
I i define it as dumping a checkpoint on

00:03:50,540 --> 00:03:56,090
a fast system and restoring it on a slow

00:03:52,250 --> 00:03:58,640
system so if you're able to run into

00:03:56,090 --> 00:04:01,060
function model orders of magnitude

00:03:58,640 --> 00:04:04,280
faster than your timing model or your

00:04:01,060 --> 00:04:06,260
HDL simulator run up to the middle of

00:04:04,280 --> 00:04:08,150
the program and dump a checkpoint and

00:04:06,260 --> 00:04:09,140
then restore that checkpoint on one of

00:04:08,150 --> 00:04:11,660
the slower systems you have

00:04:09,140 --> 00:04:16,160
fast-forwarded through that first half

00:04:11,660 --> 00:04:17,690
of the program's execution and so first

00:04:16,160 --> 00:04:21,020
of all thank you to everyone who has

00:04:17,690 --> 00:04:23,510
worked on q mu and made these kinds of

00:04:21,020 --> 00:04:26,240
forks possible made the regular use case

00:04:23,510 --> 00:04:29,570
as possible may my work possible it's

00:04:26,240 --> 00:04:32,450
it's really great these are a handful of

00:04:29,570 --> 00:04:33,860
forks that have come across and some of

00:04:32,450 --> 00:04:37,070
them I thought gee wouldn't it be cool

00:04:33,860 --> 00:04:39,740
if I could do that thing but they forked

00:04:37,070 --> 00:04:45,050
off qm you before a guy a are 64 support

00:04:39,740 --> 00:04:50,419
so i can't use it as out of the box so i

00:04:45,050 --> 00:04:52,669
don't have a solution to people for

00:04:50,419 --> 00:04:55,580
kinky mu and then the functionality

00:04:52,669 --> 00:04:57,470
doesn't get upstream but maybe for the

00:04:55,580 --> 00:05:01,850
things I care about I can try to help

00:04:57,470 --> 00:05:03,440
things lean in that direction so imagine

00:05:01,850 --> 00:05:05,690
we have a really long program that we

00:05:03,440 --> 00:05:08,570
want to run we want to study it maybe we

00:05:05,690 --> 00:05:10,640
want to study how CPU implementation

00:05:08,570 --> 00:05:12,979
execute that workload maybe you want to

00:05:10,640 --> 00:05:14,419
study you know how you might be able to

00:05:12,979 --> 00:05:16,460
write a better compiler to make it work

00:05:14,419 --> 00:05:18,020
better but it's really long and it kind

00:05:16,460 --> 00:05:21,650
of has these different phases different

00:05:18,020 --> 00:05:24,380
colors representing different phases if

00:05:21,650 --> 00:05:27,830
it's too long well let's do that fast

00:05:24,380 --> 00:05:30,950
forwarding thing and chop it up and if

00:05:27,830 --> 00:05:32,690
you're able to do a bunch of those you

00:05:30,950 --> 00:05:36,280
can you know in this little example we

00:05:32,690 --> 00:05:38,240
reduce the execution time x 8x and

00:05:36,280 --> 00:05:41,530
you're still doing the same amount of

00:05:38,240 --> 00:05:46,580
work but you're able to paralyze it and

00:05:41,530 --> 00:05:49,160
that's nice because you're your wall

00:05:46,580 --> 00:05:51,410
clock runtime from you know beginning of

00:05:49,160 --> 00:05:55,010
simulation to end of simulation is is so

00:05:51,410 --> 00:05:57,680
much faster so in order to do this we

00:05:55,010 --> 00:05:59,990
need determinism we need checkpointing

00:05:57,680 --> 00:06:03,200
to actually work you know in practice

00:05:59,990 --> 00:06:05,120
these things aren't these assumptions

00:06:03,200 --> 00:06:07,150
are met perfectly but they're met well

00:06:05,120 --> 00:06:13,280
enough for things to mostly work with

00:06:07,150 --> 00:06:17,120
reasonable error so this is how I do it

00:06:13,280 --> 00:06:18,530
in Q mu so I run in Q mu and I have a

00:06:17,120 --> 00:06:20,300
little program that will wait a certain

00:06:18,530 --> 00:06:23,360
number of instructions usually

00:06:20,300 --> 00:06:25,940
denominated millions of instructions and

00:06:23,360 --> 00:06:29,840
so I started Linux process and I run it

00:06:25,940 --> 00:06:34,460
and so in Q mu this is a full system

00:06:29,840 --> 00:06:38,569
emulations TCG mode like eric 64 on x86

00:06:34,460 --> 00:06:41,779
64 host and yeah I run some

00:06:38,569 --> 00:06:43,369
long-running application I wrote this

00:06:41,779 --> 00:06:46,610
little command called ptrace wait it

00:06:43,369 --> 00:06:49,369
just counts instructions and when the

00:06:46,610 --> 00:06:50,929
instruction count is expired you stops

00:06:49,369 --> 00:06:53,659
the process and then I use creative

00:06:50,929 --> 00:06:56,300
curry you saves the application state to

00:06:53,659 --> 00:07:00,319
a pile of files and then on some other

00:06:56,300 --> 00:07:02,929
model I can restore it start up some you

00:07:00,319 --> 00:07:07,209
know record the IPC with / for something

00:07:02,929 --> 00:07:10,219
like that run it for that interval that

00:07:07,209 --> 00:07:12,649
you know it's only responsible for maybe

00:07:10,219 --> 00:07:14,449
one eighth of the overall execution so I

00:07:12,649 --> 00:07:18,199
don't want to have it run the whole time

00:07:14,449 --> 00:07:20,240
but that's that's the basic flow and

00:07:18,199 --> 00:07:21,589
here i'm using architectural execute

00:07:20,240 --> 00:07:27,229
instructions as the basic unit of

00:07:21,589 --> 00:07:29,769
measurement there can be other ways to

00:07:27,229 --> 00:07:34,999
count you can count blocks of

00:07:29,769 --> 00:07:38,089
instructions or function calls but this

00:07:34,999 --> 00:07:43,249
is kind of a nice easy one so it's it's

00:07:38,089 --> 00:07:45,080
the one we ended up doing and what are

00:07:43,249 --> 00:07:47,990
the requirements for getting this to

00:07:45,080 --> 00:07:50,569
work on qmu we need we need the

00:07:47,990 --> 00:07:54,319
performance monitors to work and count

00:07:50,569 --> 00:07:58,039
instructions properly and currently

00:07:54,319 --> 00:08:00,469
that's that's not all in upstream qmu we

00:07:58,039 --> 00:08:01,729
have some patches hopefully we can get

00:08:00,469 --> 00:08:06,229
them into the right state for merging

00:08:01,729 --> 00:08:08,089
but if anyone has you know insights on

00:08:06,229 --> 00:08:13,159
maybe there's just a better way to do

00:08:08,089 --> 00:08:15,769
this entirely or out of curiosity does

00:08:13,159 --> 00:08:20,779
does x86 count instructions correctly or

00:08:15,769 --> 00:08:24,369
powerpc or anything else or would this

00:08:20,779 --> 00:08:24,369
be useful for like other East cases

00:08:26,940 --> 00:08:33,550
but we can also do better than just

00:08:30,389 --> 00:08:37,060
parallelizing brute force if you kind of

00:08:33,550 --> 00:08:38,890
sort these by color you can see that

00:08:37,060 --> 00:08:42,130
some of them are basically exactly the

00:08:38,890 --> 00:08:44,550
same and if you unique fi them then you

00:08:42,130 --> 00:08:47,920
have less work overall to do that's nice

00:08:44,550 --> 00:08:50,140
it's kind of like in my mind I think of

00:08:47,920 --> 00:08:52,900
it as running a lossy compression

00:08:50,140 --> 00:08:54,520
algorithm on the instruction stream at

00:08:52,900 --> 00:08:57,490
you're executing so there are different

00:08:54,520 --> 00:08:59,200
ways to do this sometimes the one

00:08:57,490 --> 00:09:02,110
approach is kind of statistic space the

00:08:59,200 --> 00:09:06,130
other is machine learning cluster

00:09:02,110 --> 00:09:08,890
k-means clustering based but both of

00:09:06,130 --> 00:09:10,690
them require more than just the ability

00:09:08,890 --> 00:09:12,310
to count instructions and get it

00:09:10,690 --> 00:09:16,480
interrupt when a certain number have

00:09:12,310 --> 00:09:20,680
happened so they they need control flow

00:09:16,480 --> 00:09:24,160
tracing so this in addition to helping

00:09:20,680 --> 00:09:26,529
out those sampling methodologies it can

00:09:24,160 --> 00:09:28,750
give you kind of that zoomed out view of

00:09:26,529 --> 00:09:32,260
a program you know you're not counting

00:09:28,750 --> 00:09:34,450
in units of time nanoseconds or whatever

00:09:32,260 --> 00:09:36,520
you're not counting in cpu cycles but if

00:09:34,450 --> 00:09:37,660
you don't mind counting and instructions

00:09:36,520 --> 00:09:42,030
you can get some useful information

00:09:37,660 --> 00:09:44,500
about the software you're running and

00:09:42,030 --> 00:09:47,740
the sim point the machine learning

00:09:44,500 --> 00:09:50,260
sampling methodology uses these things

00:09:47,740 --> 00:09:53,170
they call basic block vectors they don't

00:09:50,260 --> 00:09:57,310
really have to be basic to work that can

00:09:53,170 --> 00:09:59,260
just be blocks of some kind and but

00:09:57,310 --> 00:10:02,890
they're basically a histogram of the

00:09:59,260 --> 00:10:05,970
control flow you take every address say

00:10:02,890 --> 00:10:08,980
the address of every branch you see and

00:10:05,970 --> 00:10:13,150
you whenever you encounter it you

00:10:08,980 --> 00:10:15,040
increment it's it's count by the number

00:10:13,150 --> 00:10:18,580
of instructions since the last branch

00:10:15,040 --> 00:10:22,089
and then you know every time you see it

00:10:18,580 --> 00:10:24,370
that keeps accumulating until you get to

00:10:22,089 --> 00:10:27,339
the end of some fixed length interval

00:10:24,370 --> 00:10:30,160
and these histograms allow you to

00:10:27,339 --> 00:10:33,959
compare phases and sort of detects when

00:10:30,160 --> 00:10:33,959
you have the same colors

00:10:35,690 --> 00:10:44,730
and the exact disassembly dumping debug

00:10:42,390 --> 00:10:48,149
option gets its most of that information

00:10:44,730 --> 00:10:52,740
out to a command-line user of commute

00:10:48,149 --> 00:10:56,040
ECG mode but it'd be nice to know the

00:10:52,740 --> 00:10:59,850
exact length of a block including if

00:10:56,040 --> 00:11:03,300
it's you know partially executed or if

00:10:59,850 --> 00:11:08,250
there is a circular link how many

00:11:03,300 --> 00:11:11,700
iterations that goes through and I think

00:11:08,250 --> 00:11:14,670
so there is this i count mode which has

00:11:11,700 --> 00:11:17,430
some of this information already and

00:11:14,670 --> 00:11:19,260
please feel to occur please feel free to

00:11:17,430 --> 00:11:21,959
correct me if i'm wrong i'm sort of a

00:11:19,260 --> 00:11:28,019
user trying to become a developer in

00:11:21,959 --> 00:11:31,410
order to do these cool things but yeah I

00:11:28,019 --> 00:11:34,620
think eventually so I always think of

00:11:31,410 --> 00:11:37,260
two kinds of interfaces there are

00:11:34,620 --> 00:11:38,820
external interfaces that if you are we

00:11:37,260 --> 00:11:40,260
dealing with the hardware machine you

00:11:38,820 --> 00:11:43,050
would have to hook up like a jtag

00:11:40,260 --> 00:11:47,610
debugger to work with it and there are

00:11:43,050 --> 00:11:49,140
self hosted interfaces that you you can

00:11:47,610 --> 00:11:51,209
do from within the kernel with an

00:11:49,140 --> 00:11:53,070
application software you read some

00:11:51,209 --> 00:11:58,410
registers folks and memory and stuff

00:11:53,070 --> 00:12:00,680
like that and so I think ideally you

00:11:58,410 --> 00:12:03,510
might have both interfaces available

00:12:00,680 --> 00:12:04,829
something external you just run qmu you

00:12:03,510 --> 00:12:07,199
dump it and you get the information out

00:12:04,829 --> 00:12:08,550
on the host but if the guest wants to

00:12:07,199 --> 00:12:12,300
take care of this kind of thing itself

00:12:08,550 --> 00:12:16,100
that's good because in the end if you're

00:12:12,300 --> 00:12:18,600
only looking at one architecture a

00:12:16,100 --> 00:12:21,540
self-hosted interface is portable across

00:12:18,600 --> 00:12:22,649
all the simulators that choose to

00:12:21,540 --> 00:12:26,269
actually implement that much

00:12:22,649 --> 00:12:29,790
functionality and also hardware and

00:12:26,269 --> 00:12:31,470
fpgas and stuff like that so you know

00:12:29,790 --> 00:12:34,589
using what the hardware does is great

00:12:31,470 --> 00:12:36,750
for portability and where architectures

00:12:34,589 --> 00:12:38,790
differ maybe we have some nice

00:12:36,750 --> 00:12:45,839
abstraction layers in the kernel like

00:12:38,790 --> 00:12:47,460
the perfect open system call so yeah if

00:12:45,839 --> 00:12:50,950
anyone has thoughts on

00:12:47,460 --> 00:12:55,000
better ways to do this or if this is

00:12:50,950 --> 00:12:57,220
already there and I'm missing it or if

00:12:55,000 --> 00:13:06,220
there are other reasons to want this I'd

00:12:57,220 --> 00:13:09,930
be interested in hearing and so diving

00:13:06,220 --> 00:13:14,380
into even more detail so control flow is

00:13:09,930 --> 00:13:16,600
program counter counter addresses memory

00:13:14,380 --> 00:13:19,770
accesses are whenever you have a load or

00:13:16,600 --> 00:13:23,590
store to a from memory what is the value

00:13:19,770 --> 00:13:26,620
what is the address virtual address

00:13:23,590 --> 00:13:28,720
physical address and so what can you do

00:13:26,620 --> 00:13:31,180
with that you can drive a cache

00:13:28,720 --> 00:13:34,180
simulator with it that's kind of

00:13:31,180 --> 00:13:36,580
interesting it's a timing model that you

00:13:34,180 --> 00:13:38,500
don't really need a real CPU to model

00:13:36,580 --> 00:13:45,910
some some things at that order of

00:13:38,500 --> 00:13:48,820
magnitude and another use for it is so

00:13:45,910 --> 00:13:50,230
I've talked about these application

00:13:48,820 --> 00:13:52,930
level checkpoints with checkpoint

00:13:50,230 --> 00:13:55,150
restore and user space this is a

00:13:52,930 --> 00:13:56,820
different kind of checkpoint that I've

00:13:55,150 --> 00:14:00,990
been using a little bit recently and

00:13:56,820 --> 00:14:05,410
it's it's an elf it's it's binary that

00:14:00,990 --> 00:14:08,620
restores itself you know running the

00:14:05,410 --> 00:14:11,950
full thing would would do that too but

00:14:08,620 --> 00:14:16,180
this is if there are ways to sort of

00:14:11,950 --> 00:14:19,600
ignore the first five rights to a memory

00:14:16,180 --> 00:14:21,430
address and only take the sixth because

00:14:19,600 --> 00:14:23,320
that's where you're starting from then

00:14:21,430 --> 00:14:27,640
you can you can skip a little bit of

00:14:23,320 --> 00:14:30,400
work there so self restoring checkpoints

00:14:27,640 --> 00:14:33,280
you you would like to be able to see at

00:14:30,400 --> 00:14:36,340
least in I think in this paper and in

00:14:33,280 --> 00:14:38,710
the way that I've done it it's only

00:14:36,340 --> 00:14:40,870
meant to run for a specific duration and

00:14:38,710 --> 00:14:44,110
so you'd like to see what access is

00:14:40,870 --> 00:14:46,660
actually occur during those several

00:14:44,110 --> 00:14:50,890
million instructions and only checkpoint

00:14:46,660 --> 00:14:52,630
those and only restore those so yeah if

00:14:50,890 --> 00:14:54,910
you had memory access tracing you could

00:14:52,630 --> 00:14:57,490
create these little else that you could

00:14:54,910 --> 00:14:59,910
load and they restore all their on state

00:14:57,490 --> 00:15:04,180
and they run they're done and

00:14:59,910 --> 00:15:05,829
they're pretty I found them to be useful

00:15:04,180 --> 00:15:11,019
in some situations although it's it's

00:15:05,829 --> 00:15:13,269
it's a bit of a niche and so I think

00:15:11,019 --> 00:15:16,690
here the requirements become more

00:15:13,269 --> 00:15:19,540
invasive read or write yeah no biggie

00:15:16,690 --> 00:15:22,390
but you want both the virtual and

00:15:19,540 --> 00:15:27,490
physical addresses of the guests or

00:15:22,390 --> 00:15:31,690
target and the value and I actually have

00:15:27,490 --> 00:15:37,079
no idea what weather qmu has this

00:15:31,690 --> 00:15:37,079
already again if it could be yes

00:15:45,350 --> 00:15:51,070
and there is something that they don't

00:15:48,830 --> 00:15:51,070
so

00:15:52,390 --> 00:15:55,390
add

00:15:56,080 --> 00:16:00,230
one if they are to be requirement and

00:15:58,660 --> 00:16:03,230
not

00:16:00,230 --> 00:16:03,230
they

00:16:03,440 --> 00:16:10,220
so the matter

00:16:06,209 --> 00:16:10,220
of ending the park

00:16:10,620 --> 00:16:15,519
okay thank you yeah that sounds great I

00:16:13,480 --> 00:16:18,160
don't know if the recording got that but

00:16:15,519 --> 00:16:22,660
he was just commenting that the the

00:16:18,160 --> 00:16:27,699
tracing infrastructure has ways to work

00:16:22,660 --> 00:16:30,220
inside TCG and in a nice only on when

00:16:27,699 --> 00:16:32,199
you need it kind of way and that sounds

00:16:30,220 --> 00:16:41,769
quite promising for for implementing

00:16:32,199 --> 00:16:45,690
stuff like this thank you yeah and so

00:16:41,769 --> 00:16:49,660
this is a little bit speculative but I

00:16:45,690 --> 00:16:54,819
was thinking the other day what if user

00:16:49,660 --> 00:16:56,709
mode qmu check partner store in user

00:16:54,819 --> 00:16:58,959
space and these kind of self restoring

00:16:56,709 --> 00:17:01,329
checkpoints could interoperate I don't

00:16:58,959 --> 00:17:04,329
know if it would be kind of like babble

00:17:01,329 --> 00:17:07,870
checkpoint conversion tool or however it

00:17:04,329 --> 00:17:10,689
might be implemented but seems like that

00:17:07,870 --> 00:17:13,360
might be kind of interesting at least as

00:17:10,689 --> 00:17:20,230
a thought experiment I thought I'd throw

00:17:13,360 --> 00:17:22,360
that out there but yeah I'm afraid I was

00:17:20,230 --> 00:17:25,299
through my slides much faster than

00:17:22,360 --> 00:17:27,510
anticipated but any questions or

00:17:25,299 --> 00:17:27,510
comments

00:17:33,660 --> 00:17:39,630
if if you happen to be curious about

00:17:36,180 --> 00:17:41,760
curry you and Pete race weight and so

00:17:39,630 --> 00:17:44,310
forth them I'll be diving into a little

00:17:41,760 --> 00:17:46,680
bit more detail at the Linux plumbers

00:17:44,310 --> 00:17:48,630
creer micro conference tomorrow it

00:17:46,680 --> 00:17:56,450
starts at one-thirty but I'm come to me

00:17:48,630 --> 00:17:56,450

YouTube URL: https://www.youtube.com/watch?v=ZhvdzxEXgyE


