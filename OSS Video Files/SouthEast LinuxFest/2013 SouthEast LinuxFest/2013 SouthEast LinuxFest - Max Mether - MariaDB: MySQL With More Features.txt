Title: 2013 SouthEast LinuxFest - Max Mether - MariaDB: MySQL With More Features
Publication date: 2015-04-19
Playlist: 2013 SouthEast LinuxFest
Description: 
	2013 SouthEast LinuxFest
Max Mether
MariaDB: MySQL With More Features
Captions: 
	00:00:00,000 --> 00:00:05,160
the following presentation was recorded

00:00:02,639 --> 00:00:08,280
at the 2013 southeast linux fest in

00:00:05,160 --> 00:00:10,860
charlotte north carolina it is licensed

00:00:08,280 --> 00:00:12,509
under a creative commons license for

00:00:10,860 --> 00:00:16,619
more information about the southeast

00:00:12,509 --> 00:00:19,830
linux fest visit WWF eastland TX phase

00:00:16,619 --> 00:00:21,630
or the southeast linux fest would like

00:00:19,830 --> 00:00:24,000
to thank the following diamond sponsors

00:00:21,630 --> 00:00:26,340
in 2013 for helping make these videos

00:00:24,000 --> 00:00:28,980
possible all right i mean the first

00:00:26,340 --> 00:00:29,939
question it's already so wide so pretty

00:00:28,980 --> 00:00:33,300
much have to go through all the slides

00:00:29,939 --> 00:00:35,820
down doing this because that's pretty

00:00:33,300 --> 00:00:38,399
much what the slides are about right so

00:00:35,820 --> 00:00:41,870
i guess we'll just plug to Eliza all

00:00:38,399 --> 00:00:46,969
right so this is kind of the history of

00:00:41,870 --> 00:00:46,969
if this crooked it is right

00:00:49,610 --> 00:01:03,320
it's supposed to be like this yeah where

00:00:58,640 --> 00:01:11,350
do you change that it's okay i was

00:01:03,320 --> 00:01:11,350
caught no make it sit down school

00:01:11,409 --> 00:01:20,920
yeah a second let's do like but it's

00:01:18,009 --> 00:01:24,299
weird okay oh it seems like it's

00:01:20,920 --> 00:01:27,729
adjusting wrongly maybe it was black

00:01:24,299 --> 00:01:30,189
right I'll just I mean you can read it

00:01:27,729 --> 00:01:34,920
anyway so basically this is just a

00:01:30,189 --> 00:01:37,719
history of MySQL and well and Maria so

00:01:34,920 --> 00:01:41,590
MySQL was created in 83 well initially

00:01:37,719 --> 00:01:43,920
in 83 it was not not nothing close to

00:01:41,590 --> 00:01:47,429
what my sched today back in 83 was a

00:01:43,920 --> 00:01:49,959
one-man project he was using it for his

00:01:47,429 --> 00:01:53,079
his customers he was working as a

00:01:49,959 --> 00:01:55,390
software consulting company so they were

00:01:53,079 --> 00:01:57,759
using this database instead of paying or

00:01:55,390 --> 00:02:00,549
a color or something else they were

00:01:57,759 --> 00:02:02,530
using this and then in the beginning of

00:02:00,549 --> 00:02:03,969
the 90s it was developed on a platform I

00:02:02,530 --> 00:02:06,039
can't even remember which platform do

00:02:03,969 --> 00:02:09,670
you remember they discontinued the

00:02:06,039 --> 00:02:12,190
platform so he was like well okay what I

00:02:09,670 --> 00:02:14,260
do not do now I have to recode the whole

00:02:12,190 --> 00:02:16,660
thing because the platform but it

00:02:14,260 --> 00:02:19,239
existed on didn't didn't what was going

00:02:16,660 --> 00:02:21,760
to be discontinued so i had to redevelop

00:02:19,239 --> 00:02:24,849
the whole it was called Union reg at the

00:02:21,760 --> 00:02:29,019
time but it was what would eventually be

00:02:24,849 --> 00:02:31,450
my MySQL so he recorded it and his good

00:02:29,019 --> 00:02:33,819
friend javadocs mark convinced him to

00:02:31,450 --> 00:02:38,349
let just record it and raise it as open

00:02:33,819 --> 00:02:39,910
source right as open source and well

00:02:38,349 --> 00:02:41,590
they had some discussions and adventures

00:02:39,910 --> 00:02:43,030
okay let's just reach that open source

00:02:41,590 --> 00:02:44,230
they had like five customers or

00:02:43,030 --> 00:02:46,359
something so he was good hey the

00:02:44,230 --> 00:02:48,190
customers well we'll use it for free the

00:02:46,359 --> 00:02:52,209
guy was like you have five customers it

00:02:48,190 --> 00:02:56,290
was like okay yeah your eyes so they

00:02:52,209 --> 00:02:57,579
release that open source in 95 and at

00:02:56,290 --> 00:03:00,569
the same time they founded a company

00:02:57,579 --> 00:03:03,040
mysql and they renamed it to mysql and

00:03:00,569 --> 00:03:05,470
it turned out to be a pretty good time

00:03:03,040 --> 00:03:08,889
because because that's kind of the same

00:03:05,470 --> 00:03:11,169
time the internet kind of boomed so the

00:03:08,889 --> 00:03:13,150
lamp stack became a thing if you had a

00:03:11,169 --> 00:03:14,370
website you had a lamp stack so MySQL

00:03:13,150 --> 00:03:15,780
became

00:03:14,370 --> 00:03:18,209
prominent everywhere where he had a

00:03:15,780 --> 00:03:22,019
website so it was extremely good timing

00:03:18,209 --> 00:03:24,799
for mysql to be found that in 95 and

00:03:22,019 --> 00:03:28,409
then the company slowly grew and in 2001

00:03:24,799 --> 00:03:31,290
in january hired Martyn mcus to be the

00:03:28,409 --> 00:03:33,329
CEO so before that the founder Monty had

00:03:31,290 --> 00:03:35,459
been the CEO of the company so it was

00:03:33,329 --> 00:03:37,349
very technically oriented up to that

00:03:35,459 --> 00:03:40,590
time they hired Morton who was more

00:03:37,349 --> 00:03:43,470
business oriented and the company

00:03:40,590 --> 00:03:45,269
started growing a lot faster that's

00:03:43,470 --> 00:03:50,370
actually when I joined us well 2001 but

00:03:45,269 --> 00:03:53,579
after Morton and then a lot of things

00:03:50,370 --> 00:03:58,319
happened I'm not going to go through

00:03:53,579 --> 00:04:01,560
details but basically son acquired

00:03:58,319 --> 00:04:03,569
mysqli be in 2008 or it was announced

00:04:01,560 --> 00:04:09,239
that son will acquire my schooling in

00:04:03,569 --> 00:04:11,010
January 2008 and then well towards the

00:04:09,239 --> 00:04:14,970
end of the year monte de founder he

00:04:11,010 --> 00:04:18,150
decided to leave the company son took a

00:04:14,970 --> 00:04:20,700
few developers with him and their goal

00:04:18,150 --> 00:04:22,860
was to work for sun on the my square

00:04:20,700 --> 00:04:24,210
project but as an independent company so

00:04:22,860 --> 00:04:26,610
that they wouldn't have all this you

00:04:24,210 --> 00:04:29,580
know big company stuff to worry about

00:04:26,610 --> 00:04:32,370
like processes and things like that I

00:04:29,580 --> 00:04:34,740
mean the loss of good stories I'm like

00:04:32,370 --> 00:04:36,930
you go to a customer trip and you are

00:04:34,740 --> 00:04:38,610
not allowed to get a GPS to your

00:04:36,930 --> 00:04:40,139
computer to your car because it's you

00:04:38,610 --> 00:04:42,570
know the rules are you cannot have a GPS

00:04:40,139 --> 00:04:44,070
so you can't have gps and like how can

00:04:42,570 --> 00:04:45,750
you get to the customers and well the

00:04:44,070 --> 00:04:47,280
rules are rules and they don't bend

00:04:45,750 --> 00:04:49,710
right so this kind of stuff right so

00:04:47,280 --> 00:04:51,360
that's why they left so do you created

00:04:49,710 --> 00:04:55,860
your own company called Monte program

00:04:51,360 --> 00:04:59,550
and they were working for son but then

00:04:55,860 --> 00:05:03,530
in a 2009 oracle announced they would

00:04:59,550 --> 00:05:05,370
acquire son and thus mysql as well and

00:05:03,530 --> 00:05:07,860
among the program pretty much

00:05:05,370 --> 00:05:09,570
immediately decided okay well this

00:05:07,860 --> 00:05:12,419
changes the game completely so let's

00:05:09,570 --> 00:05:15,660
instead of working with son let's create

00:05:12,419 --> 00:05:19,320
a fork or a branch of MySQL and that's

00:05:15,660 --> 00:05:20,669
pretty much why Maria devious born so

00:05:19,320 --> 00:05:23,340
they were already outside they're

00:05:20,669 --> 00:05:23,800
already outside Sun wind acquisition

00:05:23,340 --> 00:05:25,990
have

00:05:23,800 --> 00:05:27,340
they weren't supposed to trade create a

00:05:25,990 --> 00:05:30,090
branch but because of the Oracle

00:05:27,340 --> 00:05:35,199
acquisition they decided to do it and

00:05:30,090 --> 00:05:37,930
then in 2010 the first alpha of marietv

00:05:35,199 --> 00:05:43,180
51 was released which was based on MySQL

00:05:37,930 --> 00:05:49,240
51 and then slowly but surely Oracle

00:05:43,180 --> 00:05:51,909
started doing things like closing

00:05:49,240 --> 00:05:55,650
closing there they added closed source

00:05:51,909 --> 00:06:00,759
modules in the 55 version of MySQL so

00:05:55,650 --> 00:06:02,949
like the thread pooling and the

00:06:00,759 --> 00:06:04,900
authentication plugin you can get those

00:06:02,949 --> 00:06:06,759
from MySQL however you have to pay

00:06:04,900 --> 00:06:08,800
Oracle to get them so if you use the

00:06:06,759 --> 00:06:10,409
community edition of minus QL you don't

00:06:08,800 --> 00:06:12,550
get thread pool and you don't get

00:06:10,409 --> 00:06:14,409
authentication plugin you want to get

00:06:12,550 --> 00:06:17,349
those if you pay for the for the

00:06:14,409 --> 00:06:20,139
commercial version and of course Maria

00:06:17,349 --> 00:06:22,419
DB the first thing they did was to

00:06:20,139 --> 00:06:24,490
recode the same features as open source

00:06:22,419 --> 00:06:28,210
some really be has those features but as

00:06:24,490 --> 00:06:30,729
open source versions and then oracle

00:06:28,210 --> 00:06:32,800
started closing slowly the bugs

00:06:30,729 --> 00:06:37,569
databases they don't release or two old

00:06:32,800 --> 00:06:39,810
test cases anymore and that angered the

00:06:37,569 --> 00:06:41,979
distributions a lot because it kind of

00:06:39,810 --> 00:06:43,569
goes against what unit linux

00:06:41,979 --> 00:06:44,949
distributions do they want they want to

00:06:43,569 --> 00:06:46,719
see all the test case if you have a body

00:06:44,949 --> 00:06:48,250
fix they want to know what body is being

00:06:46,719 --> 00:06:49,539
fixed if you have a security should they

00:06:48,250 --> 00:06:52,509
want to know what's being fixed right so

00:06:49,539 --> 00:06:56,020
they can verify it and test it and by

00:06:52,509 --> 00:06:58,060
closing all that stuff Oracle kind of

00:06:56,020 --> 00:07:00,729
what the distributions weren't happy

00:06:58,060 --> 00:07:05,050
with with the way the bath Moscow was

00:07:00,729 --> 00:07:06,639
taking and then in December so last year

00:07:05,050 --> 00:07:08,229
not very long ago the Marini be

00:07:06,639 --> 00:07:10,300
foundation was announced which is of

00:07:08,229 --> 00:07:13,810
course independent entity which is there

00:07:10,300 --> 00:07:16,900
to to ensure that Marilla Bay stays

00:07:13,810 --> 00:07:20,139
alive even if companies are acquired or

00:07:16,900 --> 00:07:22,029
whatnot so the project stays live stays

00:07:20,139 --> 00:07:25,000
light throughout high position so pretty

00:07:22,029 --> 00:07:26,490
much that the MySQL acquisition Oracle

00:07:25,000 --> 00:07:28,259
acquiring mysql can't happen

00:07:26,490 --> 00:07:32,940
that's pretty much wonderful where you

00:07:28,259 --> 00:07:35,280
be foundation and these things together

00:07:32,940 --> 00:07:37,490
up are the reasons why the distributions

00:07:35,280 --> 00:07:39,870
started switching to Maria so fedora

00:07:37,490 --> 00:07:42,000
they will be switching the next version

00:07:39,870 --> 00:07:45,330
of fedora will have Maria DB as the

00:07:42,000 --> 00:07:48,479
default database right and opensuse has

00:07:45,330 --> 00:07:50,669
always switched I think slackware and

00:07:48,479 --> 00:07:52,919
artwork have switched already and

00:07:50,669 --> 00:07:56,970
there's a few others as well so a lot of

00:07:52,919 --> 00:07:58,410
distributions are switching to Marie and

00:07:56,970 --> 00:08:01,740
not only Murray as an option but Marie

00:07:58,410 --> 00:08:04,319
as a default database and it's kind of

00:08:01,740 --> 00:08:06,210
because Oracle is not really doing stuff

00:08:04,319 --> 00:08:09,389
the open-source way pretty much the main

00:08:06,210 --> 00:08:12,050
reason why they're doing it alright so

00:08:09,389 --> 00:08:14,849
this is a bit of the background history

00:08:12,050 --> 00:08:16,889
I guess we should add the line here of

00:08:14,849 --> 00:08:20,940
course sky is called a company I work

00:08:16,889 --> 00:08:24,120
for now we merged with Monte program in

00:08:20,940 --> 00:08:28,080
April so the market ibid developers they

00:08:24,120 --> 00:08:29,580
not work for us or we work together this

00:08:28,080 --> 00:08:32,810
guy's girl didn't have any engineering

00:08:29,580 --> 00:08:35,099
we were doing services like support

00:08:32,810 --> 00:08:36,719
consulting and training and they were

00:08:35,099 --> 00:08:38,430
doing engineering only so it was a

00:08:36,719 --> 00:08:39,870
pretty good pretty good fit and we were

00:08:38,430 --> 00:08:42,419
have we had a close partnership with

00:08:39,870 --> 00:08:47,910
before them anyways I wasn't a huge huge

00:08:42,419 --> 00:08:53,550
step but but Maria debbie is not only

00:08:47,910 --> 00:08:56,130
tied to one company it differently from

00:08:53,550 --> 00:08:57,570
MySQL even my mysql a be even during the

00:08:56,130 --> 00:08:59,940
early days I mean the early days we got

00:08:57,570 --> 00:09:04,170
some outside contributions but pretty

00:08:59,940 --> 00:09:05,579
soon mysql a be become became pretty

00:09:04,170 --> 00:09:07,740
much the only controlling entity of

00:09:05,579 --> 00:09:11,040
mysql so everything that went into my

00:09:07,740 --> 00:09:14,040
ass girl was coded by engineers at mysql

00:09:11,040 --> 00:09:17,040
a B and this is partly because of the

00:09:14,040 --> 00:09:18,690
licensing scheme because we had dual

00:09:17,040 --> 00:09:23,670
licensing so MySQL was released through

00:09:18,690 --> 00:09:26,430
under the GPL but for people who

00:09:23,670 --> 00:09:29,430
embedded mysql in their own software we

00:09:26,430 --> 00:09:31,500
also saw the commercial license so if

00:09:29,430 --> 00:09:33,270
you made a you had an application that

00:09:31,500 --> 00:09:35,459
you distributed to your customers and my

00:09:33,270 --> 00:09:37,010
scar was embedded and you did not want

00:09:35,459 --> 00:09:38,570
to be GPL

00:09:37,010 --> 00:09:41,240
yourself you could buy a commercial

00:09:38,570 --> 00:09:42,650
license and then you could do it and

00:09:41,240 --> 00:09:44,660
because of this of course we needed to

00:09:42,650 --> 00:09:46,810
own all the source code and we need to

00:09:44,660 --> 00:09:48,890
you know indemnify them that there's no

00:09:46,810 --> 00:09:51,050
infringement and things like that in the

00:09:48,890 --> 00:09:55,970
source code so contributing wasn't easy

00:09:51,050 --> 00:09:57,650
to my mysql ivy and maria DB is actually

00:09:55,970 --> 00:09:59,030
it's a lot easier to contribute amarilla

00:09:57,650 --> 00:10:03,080
deeper than it ever was of my scalp

00:09:59,030 --> 00:10:05,180
because a merrily we will still say GPL

00:10:03,080 --> 00:10:06,530
Marie TV doesn't ella joyce I mean we

00:10:05,180 --> 00:10:08,870
wanted to stay GPL but we don't have a

00:10:06,530 --> 00:10:11,780
choice because we're basing it on GPL

00:10:08,870 --> 00:10:12,770
code so we have to stay GPA which means

00:10:11,780 --> 00:10:17,680
that we don't have to worry about all

00:10:12,770 --> 00:10:20,390
this commercial commercial license stuff

00:10:17,680 --> 00:10:22,660
so we can take contributions and of

00:10:20,390 --> 00:10:31,850
course everything is publicly available

00:10:22,660 --> 00:10:33,890
on launch pad and so forth so this is

00:10:31,850 --> 00:10:36,950
all statistics but but if you look at

00:10:33,890 --> 00:10:38,480
the WDB captain certain people who can

00:10:36,950 --> 00:10:40,850
who can commit code to Marie living

00:10:38,480 --> 00:10:42,800
projects of 54 were inside the monty

00:10:40,850 --> 00:10:46,160
program company which is now part of sky

00:10:42,800 --> 00:10:48,410
scale and 46 were outsiders so a fairly

00:10:46,160 --> 00:10:50,960
large part of the contribution comes

00:10:48,410 --> 00:10:54,620
from outside the company which is good

00:10:50,960 --> 00:10:56,480
because it means that well maybe it's

00:10:54,620 --> 00:10:58,820
not tied to one company and it's not

00:10:56,480 --> 00:11:00,560
titled innovations of just a small set

00:10:58,820 --> 00:11:02,180
of people but pretty much anyone outside

00:11:00,560 --> 00:11:04,820
if the innovate that make something

00:11:02,180 --> 00:11:07,130
useful from our a DB they submit it it

00:11:04,820 --> 00:11:08,720
will get accepted so we have compared

00:11:07,130 --> 00:11:12,140
this lot of companies that develop stuff

00:11:08,720 --> 00:11:13,730
from MySQL like Facebook Google taobao

00:11:12,140 --> 00:11:18,320
the Chinese company and many others

00:11:13,730 --> 00:11:20,510
Twitter Linkedin they all have engineers

00:11:18,320 --> 00:11:24,650
who actually develop patches and things

00:11:20,510 --> 00:11:26,390
to mysql armory a DB and instead of all

00:11:24,650 --> 00:11:28,400
of them having their own patches

00:11:26,390 --> 00:11:31,370
somewhere living they can all contribute

00:11:28,400 --> 00:11:33,200
this to marry a DB and of course it will

00:11:31,370 --> 00:11:34,730
have to be tested and it has to be q8

00:11:33,200 --> 00:11:35,769
and all that stuff but it will get into

00:11:34,730 --> 00:11:37,389
my ADV

00:11:35,769 --> 00:11:39,160
which is a pretty cool thing and that's

00:11:37,389 --> 00:11:40,839
something that you cannot do if you if

00:11:39,160 --> 00:11:42,939
you run it the way my Escalade we used

00:11:40,839 --> 00:11:45,899
to be or oracle is now because you can't

00:11:42,939 --> 00:11:51,369
you just can't take these contributions

00:11:45,899 --> 00:11:54,999
so that's cool any questions about this

00:11:51,369 --> 00:11:56,499
I mean this is just this day in turn

00:11:54,999 --> 00:12:02,559
after you so just going to the features

00:11:56,499 --> 00:12:06,790
I know it's Sunday morning I feel I feel

00:12:02,559 --> 00:12:08,709
safe I feel the same all right all right

00:12:06,790 --> 00:12:14,170
let's continue so I'm going to go

00:12:08,709 --> 00:12:16,959
straight into the features not basic

00:12:14,170 --> 00:12:19,689
what I have here is the features in my

00:12:16,959 --> 00:12:23,279
in my ad that are not in mysql but this

00:12:19,689 --> 00:12:26,589
is not one hundred percent true because

00:12:23,279 --> 00:12:28,179
i've done this in in a kind of

00:12:26,589 --> 00:12:30,339
chronological order so with the

00:12:28,179 --> 00:12:31,929
different madiba versions and some of

00:12:30,339 --> 00:12:36,459
the features that were in meridia be

00:12:31,929 --> 00:12:38,079
before are now in mysql of 56 so pretty

00:12:36,459 --> 00:12:41,110
much none of these features were in

00:12:38,079 --> 00:12:43,179
moscow 55 but some of them are in Moscow

00:12:41,110 --> 00:12:47,649
56 even though they were earlier in my

00:12:43,179 --> 00:12:50,350
ad be so so the comparison is not

00:12:47,649 --> 00:12:52,269
exactly the comparisons work for for the

00:12:50,350 --> 00:12:56,949
versions as we go through them but but

00:12:52,269 --> 00:12:58,589
they don't work with 56 anymore okay I

00:12:56,949 --> 00:13:00,129
know it's a bit confusing but

00:12:58,589 --> 00:13:05,410
unfortunately that's the way it is

00:13:00,129 --> 00:13:07,119
because some of these feature stand back

00:13:05,410 --> 00:13:09,519
from from development projects already

00:13:07,119 --> 00:13:11,679
on going in mysql before the

00:13:09,519 --> 00:13:13,929
acquisitions so some of the features

00:13:11,679 --> 00:13:15,429
developed by maria and mysql actually

00:13:13,929 --> 00:13:17,949
have the same basis because they were

00:13:15,429 --> 00:13:21,240
already half developed before and then

00:13:17,949 --> 00:13:23,529
others don't so this mix of different

00:13:21,240 --> 00:13:25,269
features of features some features

00:13:23,529 --> 00:13:27,879
develop my birria were just so good the

00:13:25,269 --> 00:13:29,439
Oracle had to develop the same but

00:13:27,879 --> 00:13:30,910
because of the issues discussed before

00:13:29,439 --> 00:13:32,230
they can't just take the features

00:13:30,910 --> 00:13:33,999
developed by Maria they have to be

00:13:32,230 --> 00:13:36,759
engineering so they they get the feature

00:13:33,999 --> 00:13:37,749
oh this is great okay let's do the same

00:13:36,759 --> 00:13:39,069
thing and then they're like okay we

00:13:37,749 --> 00:13:40,809
can't look at the code because you know

00:13:39,069 --> 00:13:42,510
it has to be our own so let's develop

00:13:40,809 --> 00:13:43,830
this feature oh no it's too

00:13:42,510 --> 00:13:45,660
okay let her to redevelop you know I

00:13:43,830 --> 00:13:47,210
don't know how it works but you know the

00:13:45,660 --> 00:13:49,380
obviously they can't develop the same

00:13:47,210 --> 00:13:51,600
and I don't know if they don't look at

00:13:49,380 --> 00:13:53,040
the code or if they have to make sure

00:13:51,600 --> 00:13:55,260
it's not too close or what they do but

00:13:53,040 --> 00:13:59,820
but they have a lot of issues with that

00:13:55,260 --> 00:14:01,230
because of the licensing esta right so

00:13:59,820 --> 00:14:08,040
I'm really be 51 was released in

00:14:01,230 --> 00:14:11,160
February 2010 the ga one of the things

00:14:08,040 --> 00:14:13,050
Maria me has had back in back in the day

00:14:11,160 --> 00:14:15,900
and still has is a lot more storage

00:14:13,050 --> 00:14:19,950
engines done than Oracle especially

00:14:15,900 --> 00:14:23,300
community project so these are mainly

00:14:19,950 --> 00:14:25,860
dead like PB XD doesn't exist anymore

00:14:23,300 --> 00:14:29,250
but federated x is an improved version

00:14:25,860 --> 00:14:33,960
of federated this extra DB which at the

00:14:29,250 --> 00:14:38,070
time was very largely superior to innodb

00:14:33,960 --> 00:14:41,880
does anybody know what extra TV is all

00:14:38,070 --> 00:14:43,620
right one guy so you know innodb it's

00:14:41,880 --> 00:14:48,900
the main transactional storage engine

00:14:43,620 --> 00:14:50,520
mysql and obviously it's open source

00:14:48,900 --> 00:14:56,420
like everything else in my skills GPL

00:14:50,520 --> 00:14:59,760
and back in two thousand eight I think

00:14:56,420 --> 00:15:02,040
innodb was designed a long time ago you

00:14:59,760 --> 00:15:04,250
know in the 90s so I wasn't so it was

00:15:02,040 --> 00:15:06,420
not particularly well optimized for

00:15:04,250 --> 00:15:10,140
multi-core environments because well

00:15:06,420 --> 00:15:12,960
they didn't exist back then so like

00:15:10,140 --> 00:15:14,340
around two thousand five six people

00:15:12,960 --> 00:15:16,470
started noticing especially hardcore

00:15:14,340 --> 00:15:17,730
users started noticing that well it

00:15:16,470 --> 00:15:19,260
didn't scare very well when they had

00:15:17,730 --> 00:15:25,140
multi-core environments and in

00:15:19,260 --> 00:15:26,430
particular Google they they did a lot of

00:15:25,140 --> 00:15:27,750
work on this they had issues they

00:15:26,430 --> 00:15:29,700
couldn't scale it as well as they did so

00:15:27,750 --> 00:15:31,610
they actually released some patches that

00:15:29,700 --> 00:15:36,020
made unity be scaled better on

00:15:31,610 --> 00:15:36,020
multi-core environments and

00:15:36,259 --> 00:15:40,579
my Escalade we had the issue with the

00:15:38,839 --> 00:15:42,499
patches google released them most

00:15:40,579 --> 00:15:44,720
believers okay we can't put them into

00:15:42,499 --> 00:15:48,169
phi1 we don't know if we can put them

00:15:44,720 --> 00:15:51,049
into 55 but thank you for your

00:15:48,169 --> 00:15:53,720
contribution right so so what happened

00:15:51,049 --> 00:15:57,169
was that extra DB was released actually

00:15:53,720 --> 00:15:59,720
being initially was in early be with the

00:15:57,169 --> 00:16:01,309
Google patches that was the start of X 2

00:15:59,720 --> 00:16:02,569
DB and then they added more stuff to

00:16:01,309 --> 00:16:04,729
actually but initially it was just the

00:16:02,569 --> 00:16:06,379
google patches on inner DB so that's

00:16:04,729 --> 00:16:09,949
kind of how actually we came to be

00:16:06,379 --> 00:16:11,919
because mysql AV was undone capable of

00:16:09,949 --> 00:16:14,539
doing anything with the google patches

00:16:11,919 --> 00:16:17,600
and exedy we was for a long period of

00:16:14,539 --> 00:16:21,850
time it was superior Tina DB especially

00:16:17,600 --> 00:16:24,769
multi core core environments at

00:16:21,850 --> 00:16:26,839
admiralty we now think that within with

00:16:24,769 --> 00:16:29,959
my school 56 they're pretty much on par

00:16:26,839 --> 00:16:31,759
XVI Nina DB so there's no big difference

00:16:29,959 --> 00:16:33,410
anymore just like some features

00:16:31,759 --> 00:16:35,629
available in one and some of the other

00:16:33,410 --> 00:16:38,389
but on the grand scheme of things are

00:16:35,629 --> 00:16:39,769
pretty much equal so the current plant

00:16:38,389 --> 00:16:41,989
formerly bit 10 which is the next

00:16:39,769 --> 00:16:45,199
version is that in the DB will be the

00:16:41,989 --> 00:16:47,989
default engine and not actually be on on

00:16:45,199 --> 00:16:52,059
my ad be up to 10x Talib has been a

00:16:47,989 --> 00:16:52,059
default engine because it's better

00:16:59,300 --> 00:17:05,579
no on this so if you really really

00:17:03,839 --> 00:17:07,559
simplify how the mouse cursor ever works

00:17:05,579 --> 00:17:10,490
you can say it's like three pieces it's

00:17:07,559 --> 00:17:12,949
the parser optimizer and storage engine

00:17:10,490 --> 00:17:16,020
so the parser process the SQL optimizer

00:17:12,949 --> 00:17:17,670
finds the optimal execution plan and the

00:17:16,020 --> 00:17:20,429
storage engine is the one who decides

00:17:17,670 --> 00:17:22,380
how the data is stored and thus also how

00:17:20,429 --> 00:17:24,270
it's how it's which retrieved so

00:17:22,380 --> 00:17:26,730
everything that has to do with indexes

00:17:24,270 --> 00:17:27,959
storage buff I mean data buffers and

00:17:26,730 --> 00:17:33,299
things like that that's the storage

00:17:27,959 --> 00:17:35,220
engine and in mysql default is in a DB

00:17:33,299 --> 00:17:36,690
which is transactional engine but there

00:17:35,220 --> 00:17:38,309
are others like my Aizen is the

00:17:36,690 --> 00:17:40,890
traditional one which is pretty much

00:17:38,309 --> 00:17:42,540
flat files we don't in dec I mean text

00:17:40,890 --> 00:17:44,100
files with an index file a ticket so you

00:17:42,540 --> 00:17:46,970
can access it and things like that but

00:17:44,100 --> 00:17:49,169
in DB is the more like a normal database

00:17:46,970 --> 00:17:52,730
engine but you can choose on each table

00:17:49,169 --> 00:18:00,840
you can choose which star gently to use

00:17:52,730 --> 00:18:04,350
so it's very flexible right some other

00:18:00,840 --> 00:18:05,970
features in mysql 51 maria b 51 there

00:18:04,350 --> 00:18:09,360
was an initial micro second support

00:18:05,970 --> 00:18:11,750
which didn't exist in in mysql at the

00:18:09,360 --> 00:18:13,890
time it now exists in mysql and i

00:18:11,750 --> 00:18:17,610
believe they're not going to use the one

00:18:13,890 --> 00:18:19,620
from mysql right in murray DB yeah i

00:18:17,610 --> 00:18:23,910
think the taken one mysql because it's

00:18:19,620 --> 00:18:28,380
the same feature they had in 51 they had

00:18:23,910 --> 00:18:30,540
a thread pool so a long time a long time

00:18:28,380 --> 00:18:33,809
before mysql had a thread pool that was

00:18:30,540 --> 00:18:36,390
funny mariadb mysql in 55 released their

00:18:33,809 --> 00:18:38,220
commercial extension thread pool which

00:18:36,390 --> 00:18:40,320
turned out to be better than the one in

00:18:38,220 --> 00:18:42,299
Maria Sol de Maria guys had to recode

00:18:40,320 --> 00:18:44,910
the thread pool because they couldn't be

00:18:42,299 --> 00:18:46,530
worse than mysql so they recorded it and

00:18:44,910 --> 00:18:49,650
then Maria has one that's not better

00:18:46,530 --> 00:18:51,870
than it used to be in 51 that's actually

00:18:49,650 --> 00:18:53,370
a good example of the fact having these

00:18:51,870 --> 00:18:55,740
different entities actually creates

00:18:53,370 --> 00:18:59,360
better products right because they

00:18:55,740 --> 00:18:59,360
recorded their because it was better

00:19:01,980 --> 00:19:07,419
like is there an echo can you can you

00:19:04,990 --> 00:19:08,470
hear I'm saying ok it sounds to me it

00:19:07,419 --> 00:19:17,200
sound like I'm in the church or

00:19:08,470 --> 00:19:21,070
something so in mysql the granular the

00:19:17,200 --> 00:19:22,720
granularity of queries and things were

00:19:21,070 --> 00:19:25,870
second you didn't have anything below

00:19:22,720 --> 00:19:32,230
second and so this goes to micro second

00:19:25,870 --> 00:19:34,419
level the for example the process list

00:19:32,230 --> 00:19:36,039
only had the query execution time in

00:19:34,419 --> 00:19:38,230
seconds and here you get it in

00:19:36,039 --> 00:19:41,169
microseconds instead and same with the

00:19:38,230 --> 00:19:42,880
slow log you couldn't just look very

00:19:41,169 --> 00:19:44,770
long you could only choose ok how many

00:19:42,880 --> 00:19:46,210
seconds so it's a very log is where you

00:19:44,770 --> 00:19:49,120
log queries that are slower than a than

00:19:46,210 --> 00:19:50,740
a certain time and the minimum was one

00:19:49,120 --> 00:19:53,649
second you couldn't go below it so for a

00:19:50,740 --> 00:19:55,899
website where you have 10,000 queries

00:19:53,649 --> 00:19:57,220
per second it's pointless ever anything

00:19:55,899 --> 00:19:58,809
that takes longer than a second is waked

00:19:57,220 --> 00:20:01,049
is low already you want to find have

00:19:58,809 --> 00:20:04,559
like a better ground i return that

00:20:01,049 --> 00:20:04,559
that's why i feel useful

00:20:09,430 --> 00:20:15,370
then so when Monty program was created

00:20:15,910 --> 00:20:22,400
Monty the the initial creator of MySQL

00:20:19,700 --> 00:20:24,560
took with him pretty much whoever of the

00:20:22,400 --> 00:20:28,310
old guard who wanted to come with him

00:20:24,560 --> 00:20:30,080
and incidentally three of the four guys

00:20:28,310 --> 00:20:33,620
of the optimizer team won at the follow

00:20:30,080 --> 00:20:35,600
Monty so MySQL had four had an optimized

00:20:33,620 --> 00:20:38,630
a team of four three joined monty

00:20:35,600 --> 00:20:41,000
program the other guy looked around he

00:20:38,630 --> 00:20:46,400
was like ok and two months later he also

00:20:41,000 --> 00:20:48,680
joined money Monty program so basically

00:20:46,400 --> 00:20:53,360
the whole optimizer team joined joined

00:20:48,680 --> 00:20:54,680
the Maria dbt which meant that well they

00:20:53,360 --> 00:20:56,360
could do a lot of optimizer features

00:20:54,680 --> 00:20:58,730
because they have had all the guys at

00:20:56,360 --> 00:21:00,500
the optimizer team and you will see that

00:20:58,730 --> 00:21:02,030
Maria has a lot of optimizer features

00:21:00,500 --> 00:21:04,100
and that's basically because the whole

00:21:02,030 --> 00:21:05,330
Optimas team joined it's also partly

00:21:04,100 --> 00:21:07,160
because they had already started working

00:21:05,330 --> 00:21:08,900
on some of the features before they

00:21:07,160 --> 00:21:12,980
joined so they just continued to work on

00:21:08,900 --> 00:21:14,870
them at my ad be one of the features one

00:21:12,980 --> 00:21:18,790
of the first features the optimizer team

00:21:14,870 --> 00:21:18,790
did was this table elimination feature

00:21:19,000 --> 00:21:25,040
which is very I mean it's very small

00:21:22,580 --> 00:21:28,820
feature it's only its use case is just

00:21:25,040 --> 00:21:32,660
very particular cases so if you have an

00:21:28,820 --> 00:21:35,680
anchor scheme scheme a kind of setup so

00:21:32,660 --> 00:21:35,680
basically this means that you have

00:21:36,580 --> 00:21:42,620
instead of having one large table where

00:21:38,810 --> 00:21:44,840
install all the attributes you have kind

00:21:42,620 --> 00:21:46,730
of one at one table for attribute and

00:21:44,840 --> 00:21:48,170
this is this might be because not all

00:21:46,730 --> 00:21:49,670
your entities will have all the

00:21:48,170 --> 00:21:53,000
attributes so instead of having a huge

00:21:49,670 --> 00:21:56,440
table with lots of empty empty space you

00:21:53,000 --> 00:21:59,270
have specific tables for each attribute

00:21:56,440 --> 00:22:02,060
and this also means that it easy to add

00:21:59,270 --> 00:22:03,500
and remove attributes rights so you can

00:22:02,060 --> 00:22:04,910
have it makes it flexible you don't have

00:22:03,500 --> 00:22:06,470
to do an alter table if you want to add

00:22:04,910 --> 00:22:09,110
an attribute you just add a new table

00:22:06,470 --> 00:22:10,490
and add attribute add this attribute for

00:22:09,110 --> 00:22:12,710
wherever it makes sense it gives you a

00:22:10,490 --> 00:22:16,490
very flexible schema by having an anchor

00:22:12,710 --> 00:22:18,320
schema the problem is that well because

00:22:16,490 --> 00:22:21,060
you have lots of tables in lots of

00:22:18,320 --> 00:22:22,950
and typically what happens is that you

00:22:21,060 --> 00:22:25,800
would create a view which makes it looks

00:22:22,950 --> 00:22:27,330
like a big table right when you were to

00:22:25,800 --> 00:22:29,070
join all of these tables so you can then

00:22:27,330 --> 00:22:30,630
if you do your queries from this view

00:22:29,070 --> 00:22:35,550
instead of instead of you writing all

00:22:30,630 --> 00:22:39,090
these twenty twenty join Z each time and

00:22:35,550 --> 00:22:41,400
the problem with MySQL was that if you

00:22:39,090 --> 00:22:44,040
do this mysql cannot optimize this

00:22:41,400 --> 00:22:47,460
disjoint it will always join all the

00:22:44,040 --> 00:22:49,350
tables so if you have 30 attributes it

00:22:47,460 --> 00:22:50,280
will do a 30 table join always even if

00:22:49,350 --> 00:22:52,500
you're just looking for one of these

00:22:50,280 --> 00:22:54,210
attributes and that's basically the

00:22:52,500 --> 00:22:55,770
table elimination feature does is that

00:22:54,210 --> 00:23:00,180
it actually only joins the tables

00:22:55,770 --> 00:23:01,590
necessary in this square so I mean you

00:23:00,180 --> 00:23:03,450
would say it's a use case it's no one

00:23:01,590 --> 00:23:04,680
uses no one creates this but it's

00:23:03,450 --> 00:23:06,450
actually not true and especially if you

00:23:04,680 --> 00:23:09,150
give you some kind of middle layer that

00:23:06,450 --> 00:23:10,680
creates your SQL queries they often do

00:23:09,150 --> 00:23:13,440
this type of schema to be more flexible

00:23:10,680 --> 00:23:15,110
because because then in the middle layer

00:23:13,440 --> 00:23:17,400
you can have attributes and stuff and

00:23:15,110 --> 00:23:19,230
the middle layer doesn't does not do all

00:23:17,400 --> 00:23:20,550
the tables they just add add tables in

00:23:19,230 --> 00:23:22,020
you know in an anchor schema so

00:23:20,550 --> 00:23:25,170
especially views middle layers this

00:23:22,020 --> 00:23:26,970
features actually very useful and it

00:23:25,170 --> 00:23:28,590
makes a quiz faster faster out of the

00:23:26,970 --> 00:23:33,210
box you install you have you have this

00:23:28,590 --> 00:23:36,030
yeah might have mysql you stop mysql you

00:23:33,210 --> 00:23:37,770
install maria start it and same query

00:23:36,030 --> 00:23:38,940
will be faster because you don't have to

00:23:37,770 --> 00:23:40,560
change anything it's on a feature you

00:23:38,940 --> 00:23:45,510
turn on and off it's there it works out

00:23:40,560 --> 00:23:47,480
of the wrong so that was maybe 5 1 it

00:23:45,510 --> 00:23:50,400
was the first place maria DB the main

00:23:47,480 --> 00:23:52,470
idea for the market for that reason was

00:23:50,400 --> 00:23:54,090
to just get it out right get a first

00:23:52,470 --> 00:23:57,630
release get Marie to be go and get the

00:23:54,090 --> 00:24:00,030
brown going then for 52 which is still

00:23:57,630 --> 00:24:01,590
based on marietv 51 which is based on my

00:24:00,030 --> 00:24:03,450
squad 51 they added some additional

00:24:01,590 --> 00:24:05,910
features like the pluggable

00:24:03,450 --> 00:24:07,560
authentication which was one of the

00:24:05,910 --> 00:24:13,160
commercial extensions by Oracle which

00:24:07,560 --> 00:24:13,160
murrieta be recorded as open source and

00:24:14,030 --> 00:24:19,170
this actually something that's requested

00:24:16,620 --> 00:24:20,970
a lot by our customers because many cars

00:24:19,170 --> 00:24:22,470
don't want to they have an ldap system

00:24:20,970 --> 00:24:25,470
with authentication and they want to use

00:24:22,470 --> 00:24:28,049
that to authenticate mysql and through

00:24:25,470 --> 00:24:30,399
the pan plugin you can use your el lab

00:24:28,049 --> 00:24:33,309
so you don't have to create new users

00:24:30,399 --> 00:24:36,460
and things like that in mysql you can

00:24:33,309 --> 00:24:40,679
just plug your a left to the pan another

00:24:36,460 --> 00:24:45,220
really cool feature which was created by

00:24:40,679 --> 00:24:47,019
either google or facebook i'm not sure

00:24:45,220 --> 00:24:48,610
which one it's mark Callahan's team but

00:24:47,019 --> 00:24:50,499
i can't remember if it was if he was at

00:24:48,610 --> 00:24:54,610
google or facebook when this was created

00:24:50,499 --> 00:24:57,340
do you know Daniel yeah either Facebook

00:24:54,610 --> 00:24:58,929
or Google it's these uses the physics

00:24:57,340 --> 00:25:02,259
table so in mysql you have any if you

00:24:58,929 --> 00:25:06,869
have the information schema we have lots

00:25:02,259 --> 00:25:09,220
of statistics on things but all

00:25:06,869 --> 00:25:12,850
variables like the statistic variables

00:25:09,220 --> 00:25:16,480
are per server right so you see you see

00:25:12,850 --> 00:25:17,919
how many full index scans you have for

00:25:16,480 --> 00:25:20,499
the whole server for I mean since you

00:25:17,919 --> 00:25:23,200
either we started the statistics or

00:25:20,499 --> 00:25:24,369
since the server restarted and same

00:25:23,200 --> 00:25:27,309
thing with everything else always

00:25:24,369 --> 00:25:29,379
preserve a preserve the server which is

00:25:27,309 --> 00:25:32,559
good for certain things but not so good

00:25:29,379 --> 00:25:35,049
for other things for example if you want

00:25:32,559 --> 00:25:36,909
to know if an index is used or not that

00:25:35,049 --> 00:25:39,789
doesn't help you at all if you want to

00:25:36,909 --> 00:25:41,289
know how many full scans you've done in

00:25:39,789 --> 00:25:44,320
a specific table that doesn't help you

00:25:41,289 --> 00:25:47,710
at all right so what they added was 36 /

00:25:44,320 --> 00:25:48,789
or user / index and / table so when you

00:25:47,710 --> 00:25:51,789
turn this feature on you can actually

00:25:48,789 --> 00:25:53,320
see get very details on each table each

00:25:51,789 --> 00:25:55,929
index and so forth so that's very useful

00:25:53,320 --> 00:26:00,159
feature for dbas like we had a customer

00:25:55,929 --> 00:26:02,889
who has it's very large customer they

00:26:00,159 --> 00:26:05,919
have a small team of DBS maybe ten dbas

00:26:02,889 --> 00:26:07,960
and you know they let their developers

00:26:05,919 --> 00:26:11,859
pretty much I'd create tables and do

00:26:07,960 --> 00:26:13,179
whatever in the database so I was there

00:26:11,859 --> 00:26:16,539
and I was asking them so do you have

00:26:13,179 --> 00:26:18,309
like do you have a documentation about

00:26:16,539 --> 00:26:21,429
the database you know what tables do

00:26:18,309 --> 00:26:24,179
what and and so forth they were like no

00:26:21,429 --> 00:26:26,409
I was like okay so how do you know

00:26:24,179 --> 00:26:27,070
you're like well you know with time you

00:26:26,409 --> 00:26:30,220
learn

00:26:27,070 --> 00:26:31,899
wonderful so I was like okay but what

00:26:30,220 --> 00:26:33,190
how do you know if the table someone

00:26:31,899 --> 00:26:35,289
just creates a table and it just lying

00:26:33,190 --> 00:26:37,450
there forever the guys like well

00:26:35,289 --> 00:26:39,759
actually we don't so I was like so what

00:26:37,450 --> 00:26:41,590
you do is say well if a table looks like

00:26:39,759 --> 00:26:45,029
it's not being used and that's his

00:26:41,590 --> 00:26:47,649
wording looks like it's not being used

00:26:45,029 --> 00:26:52,529
what you do is we rename the table and

00:26:47,649 --> 00:26:52,529
if no one complains in a week we drop it

00:26:53,789 --> 00:27:01,690
I was like okay sounds like maybe you

00:26:59,200 --> 00:27:02,860
guys should use these these tables

00:27:01,690 --> 00:27:05,409
because then you would know if a table

00:27:02,860 --> 00:27:06,519
is used or not right so if you have

00:27:05,409 --> 00:27:07,840
these statistics you don't have that

00:27:06,519 --> 00:27:11,970
issue because then you can see okay this

00:27:07,840 --> 00:27:14,889
table has never been used or something

00:27:11,970 --> 00:27:16,059
so this feature developed by google or

00:27:14,889 --> 00:27:17,289
facebook you can find it in where you

00:27:16,059 --> 00:27:18,730
can actually find it in berk own server

00:27:17,289 --> 00:27:21,639
as well it's one of the features that

00:27:18,730 --> 00:27:27,669
are available in both but it's very

00:27:21,639 --> 00:27:30,309
useful very useful feature some other

00:27:27,669 --> 00:27:34,929
features a very cool feature in my

00:27:30,309 --> 00:27:39,090
devious virtual columns which means that

00:27:34,929 --> 00:27:41,440
you can you can create a column that's

00:27:39,090 --> 00:27:43,299
the the content is automatically

00:27:41,440 --> 00:27:50,019
generated based on functions on the

00:27:43,299 --> 00:27:52,379
other columns right i mean the use case

00:27:50,019 --> 00:27:54,190
for this is in particular if you have

00:27:52,379 --> 00:27:55,600
persistent columns and you create an

00:27:54,190 --> 00:27:58,330
index on the con so you can create an

00:27:55,600 --> 00:28:01,179
index on this column so if you want to

00:27:58,330 --> 00:28:04,929
index something but not the actual value

00:28:01,179 --> 00:28:07,179
in the end in your in your column but

00:28:04,929 --> 00:28:09,009
but some kind of function of the value

00:28:07,179 --> 00:28:11,529
you don't you don't have to actually use

00:28:09,009 --> 00:28:12,879
that function in the database you can

00:28:11,529 --> 00:28:14,710
add an virtual column which

00:28:12,879 --> 00:28:19,960
automatically generates this functional

00:28:14,710 --> 00:28:22,919
value and then you index that like a

00:28:19,960 --> 00:28:22,919
typical example is

00:28:23,040 --> 00:28:34,260
he's a web server name of web when names

00:28:29,100 --> 00:28:36,120
like ww or whatever cloudy skies cool

00:28:34,260 --> 00:28:38,190
calm right if you store the server names

00:28:36,120 --> 00:28:40,590
in this fashion you cannot use an index

00:28:38,190 --> 00:28:41,970
to to find them because you can you

00:28:40,590 --> 00:28:44,520
going to do proximity searches because

00:28:41,970 --> 00:28:47,940
it goes from it goes from the most

00:28:44,520 --> 00:28:50,190
specifically specific right so if you'll

00:28:47,940 --> 00:28:52,560
find all sky school of comm service you

00:28:50,190 --> 00:28:54,960
will do start at Sky whale calm and you

00:28:52,560 --> 00:28:58,110
cannot use an index for that in order to

00:28:54,960 --> 00:29:00,870
cynically have to reverse the you have

00:28:58,110 --> 00:29:02,490
to reverse the name and that's what we

00:29:00,870 --> 00:29:03,540
used to always tell our customers you

00:29:02,490 --> 00:29:05,700
have to reverse the name you have to

00:29:03,540 --> 00:29:07,620
start in your name work the name

00:29:05,700 --> 00:29:08,910
reversed but now you don't actually have

00:29:07,620 --> 00:29:10,410
to storage the words you don't have to

00:29:08,910 --> 00:29:11,700
create a virtual function which reverses

00:29:10,410 --> 00:29:14,220
it and then create the index on that

00:29:11,700 --> 00:29:15,630
virtual function so you can see store

00:29:14,220 --> 00:29:18,330
the name in the right format and then

00:29:15,630 --> 00:29:20,940
use this virtual call several columns

00:29:18,330 --> 00:29:23,880
are useful the only problem with virtual

00:29:20,940 --> 00:29:25,500
college is that you do store the data

00:29:23,880 --> 00:29:27,570
twice you store it in the original

00:29:25,500 --> 00:29:29,790
column and then as a result of the

00:29:27,570 --> 00:29:31,170
function so it's not a true functional

00:29:29,790 --> 00:29:32,490
index because you have to do it in two

00:29:31,170 --> 00:29:34,620
steps you have to do a virtual column

00:29:32,490 --> 00:29:37,590
and then an index but it's very close to

00:29:34,620 --> 00:29:38,970
being a virtual index and my SQL

00:29:37,590 --> 00:29:45,270
standard my square does not have

00:29:38,970 --> 00:29:51,210
anything like this does anyone know it

00:29:45,270 --> 00:29:55,710
stinkses except Daniel yeah it's a text

00:29:51,210 --> 00:30:00,000
search engine mysql has some some

00:29:55,710 --> 00:30:02,940
full-text searching features but they're

00:30:00,000 --> 00:30:04,800
not very good so so if you do some

00:30:02,940 --> 00:30:06,270
simple full-text searching you can use

00:30:04,800 --> 00:30:08,880
mysql if you want to do some serious

00:30:06,270 --> 00:30:10,740
text searching then you pretty much have

00:30:08,880 --> 00:30:12,450
to do is use some some external products

00:30:10,740 --> 00:30:16,680
things being one and losing this is

00:30:12,450 --> 00:30:19,190
another one and things allows you to

00:30:16,680 --> 00:30:23,130
integrate your results with my ass girl

00:30:19,190 --> 00:30:25,630
very closely so I have a things you have

00:30:23,130 --> 00:30:27,980
a sync server running

00:30:25,630 --> 00:30:29,690
in Moorea DB you can connect through a

00:30:27,980 --> 00:30:31,760
swing server through much through Maya

00:30:29,690 --> 00:30:35,330
scale so you can actually query things

00:30:31,760 --> 00:30:37,100
and your mysql tables in one query which

00:30:35,330 --> 00:30:38,540
typically what you would have to do is

00:30:37,100 --> 00:30:40,640
from the application layer first quest

00:30:38,540 --> 00:30:42,230
ings find the primary key and then quite

00:30:40,640 --> 00:30:44,300
mysql but in my readable you can

00:30:42,230 --> 00:30:46,340
actually do it in one query so the

00:30:44,300 --> 00:30:48,200
queries things get to get the primary

00:30:46,340 --> 00:30:49,430
key and then you query in the same query

00:30:48,200 --> 00:30:52,010
you get the results from the table

00:30:49,430 --> 00:30:56,510
actual table as well so if you're using

00:30:52,010 --> 00:30:57,920
things is a cool feature then there's

00:30:56,510 --> 00:31:02,150
one thing called a segment in my eyes

00:30:57,920 --> 00:31:07,270
I'm geekish who uses my eyes on who use

00:31:02,150 --> 00:31:07,270
in a DB who knows what I'm talking about

00:31:07,420 --> 00:31:11,900
okay so that's the storage engine thing

00:31:10,370 --> 00:31:16,220
I was talking about so innodb is the

00:31:11,900 --> 00:31:17,480
transactional storage engine and my eyes

00:31:16,220 --> 00:31:21,230
I miss kind of the traditional one the

00:31:17,480 --> 00:31:22,640
flat file with indexes and I talked

00:31:21,230 --> 00:31:24,470
about extra DB that one of the reasons

00:31:22,640 --> 00:31:27,650
why actually exists came to existence

00:31:24,470 --> 00:31:30,560
was the fact that in early we did not do

00:31:27,650 --> 00:31:32,360
well in a multi-core environment and one

00:31:30,560 --> 00:31:33,500
of the one of the reasons for that there

00:31:32,360 --> 00:31:35,450
were many but one of the thing the

00:31:33,500 --> 00:31:37,220
reason for that was the they have a

00:31:35,450 --> 00:31:44,360
buffer pool where this buffer data pages

00:31:37,220 --> 00:31:45,920
and that becomes I mean it becomes a

00:31:44,360 --> 00:31:47,810
bottleneck getting access to the buffer

00:31:45,920 --> 00:31:51,380
pool becomes a bottleneck because it was

00:31:47,810 --> 00:31:52,790
controlled by one well one piece of code

00:31:51,380 --> 00:31:54,920
right so you have to all ever one had to

00:31:52,790 --> 00:31:56,180
go through which so basically the access

00:31:54,920 --> 00:31:59,000
to the buffer pool pretty much became

00:31:56,180 --> 00:32:02,360
sequential instead of parallel so one of

00:31:59,000 --> 00:32:04,280
the things that innodb did was to split

00:32:02,360 --> 00:32:07,760
this buffer pull up into multiple but

00:32:04,280 --> 00:32:11,230
footballs and myosin had the same

00:32:07,760 --> 00:32:11,230
problem I hasn't had has one

00:32:11,320 --> 00:32:16,310
CashCall key cash which is where all the

00:32:13,580 --> 00:32:17,690
index data is and basically not

00:32:16,310 --> 00:32:20,780
multi-core environment you have the same

00:32:17,690 --> 00:32:22,940
issue if you only have one key cash you

00:32:20,780 --> 00:32:25,220
cannot concurrently access access this

00:32:22,940 --> 00:32:27,560
so what did you do me really really

00:32:25,220 --> 00:32:28,970
speed up to my demise and key cash into

00:32:27,560 --> 00:32:33,770
different segments which is called a

00:32:28,970 --> 00:32:35,300
segmental myosin key cash and here's the

00:32:33,770 --> 00:32:37,480
statistical actually Daniel she say it

00:32:35,300 --> 00:32:40,070
was anyone as Daniel to talk yesterday

00:32:37,480 --> 00:32:42,590
no Daniel had done you how to talk about

00:32:40,070 --> 00:32:44,690
me to be ten years today you went to

00:32:42,590 --> 00:32:46,610
interview and three of you want so you

00:32:44,690 --> 00:32:49,250
actually showed the same graph Daniel

00:32:46,610 --> 00:32:54,710
this is the benefit you get from the

00:32:49,250 --> 00:32:56,990
segmented key cash so so I mean

00:32:54,710 --> 00:32:58,370
basically when you have more concurrent

00:32:56,990 --> 00:33:00,050
threads that's when you see a difference

00:32:58,370 --> 00:33:04,130
if you don't have concurrent threads it

00:33:00,050 --> 00:33:05,810
doesn't matter so the blue line here is

00:33:04,130 --> 00:33:07,250
without the key without the segmented

00:33:05,810 --> 00:33:10,160
key cash you only have one key cash

00:33:07,250 --> 00:33:12,560
right so pretty much when you run

00:33:10,160 --> 00:33:14,270
already we have four threads you start

00:33:12,560 --> 00:33:17,000
running into concurrency issues you

00:33:14,270 --> 00:33:20,000
cannot linearly scale anymore because of

00:33:17,000 --> 00:33:22,940
the key cos key cash access and then of

00:33:20,000 --> 00:33:24,710
course it just it just fades out it

00:33:22,940 --> 00:33:27,260
doesn't by adding threads you don't get

00:33:24,710 --> 00:33:29,060
any benefit anymore however the segment

00:33:27,260 --> 00:33:32,210
that segment the key cash it goes with

00:33:29,060 --> 00:33:34,610
further I'm very different is about

00:33:32,210 --> 00:33:37,670
20,000 to 5,000 queries per second is a

00:33:34,610 --> 00:33:42,020
difference but of course these features

00:33:37,670 --> 00:33:44,870
only useful if used my eyes on in a DB

00:33:42,020 --> 00:33:47,530
and exod we have the same feature as

00:33:44,870 --> 00:33:52,460
well and they are available in all all

00:33:47,530 --> 00:33:54,740
server versions then the next thing is

00:33:52,460 --> 00:33:58,580
maria be 53 and here there is a lot of

00:33:54,740 --> 00:34:00,710
features which are more what a lot of

00:33:58,580 --> 00:34:02,990
good features actually some are no SQL

00:34:00,710 --> 00:34:04,760
type features and others are other

00:34:02,990 --> 00:34:07,100
features so the first feature is a

00:34:04,760 --> 00:34:10,550
handler socket which allows you to

00:34:07,100 --> 00:34:12,650
access the storage layer directly so you

00:34:10,550 --> 00:34:14,600
pretty much bypass the parser when you

00:34:12,650 --> 00:34:16,670
do this you can through the handler

00:34:14,600 --> 00:34:20,710
socket interface you can access the

00:34:16,670 --> 00:34:23,750
storage engine without doing SQL parsing

00:34:20,710 --> 00:34:27,200
and no optimizer you can just use simple

00:34:23,750 --> 00:34:29,510
operations so create replace update

00:34:27,200 --> 00:34:31,639
delete is all you can do so it's not

00:34:29,510 --> 00:34:33,950
very useful but again in very specific

00:34:31,639 --> 00:34:37,069
use cases like say you have a huge batch

00:34:33,950 --> 00:34:38,419
of small operations it will probably

00:34:37,069 --> 00:34:40,849
faster using the handler socket

00:34:38,419 --> 00:34:42,619
interface than doing it through SQL so

00:34:40,849 --> 00:34:48,649
it's for matching or something like that

00:34:42,619 --> 00:34:50,929
where it where it makes sense another

00:34:48,649 --> 00:34:54,740
feature which is a lot cooler is dynamic

00:34:50,929 --> 00:34:59,750
columns so basically it allows you to

00:34:54,740 --> 00:35:02,299
create columns where well it allows you

00:34:59,750 --> 00:35:04,549
to have multiple attributes stored in

00:35:02,299 --> 00:35:08,450
one column from from a schema

00:35:04,549 --> 00:35:11,329
perspective so again think no SQL think

00:35:08,450 --> 00:35:12,619
flexibility so if you want to have a bit

00:35:11,329 --> 00:35:15,970
the same reasons why we have an anchor

00:35:12,619 --> 00:35:18,829
schema we have lots of attributes and

00:35:15,970 --> 00:35:20,440
depending on what Rose we have they will

00:35:18,829 --> 00:35:23,119
have some but not all of the attributes

00:35:20,440 --> 00:35:24,619
so again instead of creating a huge

00:35:23,119 --> 00:35:25,880
table where you have every single

00:35:24,619 --> 00:35:28,069
possible attribute that could

00:35:25,880 --> 00:35:30,980
potentially exist and most of them will

00:35:28,069 --> 00:35:34,900
be empty here you create a dynamic

00:35:30,980 --> 00:35:38,450
column which has all attributes that are

00:35:34,900 --> 00:35:42,069
not necessary for each row so anything p

00:35:38,450 --> 00:35:44,690
for example if you have a web store

00:35:42,069 --> 00:35:46,490
anything that describes the object would

00:35:44,690 --> 00:35:48,859
be in this column like you would have

00:35:46,490 --> 00:35:50,240
the primary key the name and the price

00:35:48,859 --> 00:35:51,470
or something might be in different

00:35:50,240 --> 00:35:53,809
columns but everything else that

00:35:51,470 --> 00:35:55,760
describes the object like color you know

00:35:53,809 --> 00:35:57,349
screen size whatever that really depends

00:35:55,760 --> 00:36:00,589
on what what the object is would be in

00:35:57,349 --> 00:36:03,079
this column and here you can completely

00:36:00,589 --> 00:36:07,220
done dynamically add or remove columns

00:36:03,079 --> 00:36:11,210
each time you insert a row so this is

00:36:07,220 --> 00:36:15,349
how it looks can you see this so you

00:36:11,210 --> 00:36:17,180
create a table you add a column this is

00:36:15,349 --> 00:36:19,520
a medium blob so you add a column which

00:36:17,180 --> 00:36:22,670
is a blob column so just a binary object

00:36:19,520 --> 00:36:24,950
and then when you do operations with

00:36:22,670 --> 00:36:26,210
this column you take these predefined

00:36:24,950 --> 00:36:29,869
functions like

00:36:26,210 --> 00:36:33,230
create and and so forth and with the

00:36:29,869 --> 00:36:35,000
column create you can add any number of

00:36:33,230 --> 00:36:40,820
attributes and give values for these

00:36:35,000 --> 00:36:43,700
attributes okay and before mysql before

00:36:40,820 --> 00:36:46,070
my little bit 10 unfortunately

00:36:43,700 --> 00:36:47,839
attributes are numbered there's no name

00:36:46,070 --> 00:36:50,690
but starting with Maria but then you can

00:36:47,839 --> 00:36:53,530
actually name them as well right so here

00:36:50,690 --> 00:36:56,270
for example in this example we have a

00:36:53,530 --> 00:36:59,000
attribute number one means color so

00:36:56,270 --> 00:37:00,770
every object that has a color will give

00:36:59,000 --> 00:37:02,599
a value to attribute one if just an

00:37:00,770 --> 00:37:07,430
object does tell color well we won't

00:37:02,599 --> 00:37:09,530
give this attribute and we have one

00:37:07,430 --> 00:37:12,619
attribute here number 10 is the shirt

00:37:09,530 --> 00:37:15,530
size so obviously the shirts will have a

00:37:12,619 --> 00:37:18,260
shirt size but the mobile phone won't

00:37:15,530 --> 00:37:20,089
have any any value for this right so you

00:37:18,260 --> 00:37:23,060
complete the dynamic inside which

00:37:20,089 --> 00:37:27,109
attributes each row will have and it's

00:37:23,060 --> 00:37:31,210
stored in a blog and then you can access

00:37:27,109 --> 00:37:31,210
this through these predefined functions

00:37:33,430 --> 00:37:38,869
well there's a column lists with Gibbs

00:37:37,040 --> 00:37:40,760
which gives you which attribute this

00:37:38,869 --> 00:37:43,250
column has and there's some other

00:37:40,760 --> 00:37:46,250
functions like calm get it looked for

00:37:43,250 --> 00:37:54,109
which look look for a specific attribute

00:37:46,250 --> 00:37:55,880
and so forth a question that's often

00:37:54,109 --> 00:37:58,010
asked this world so can you index these

00:37:55,880 --> 00:37:59,720
attributes and the answer is no you

00:37:58,010 --> 00:38:01,880
cannot because it's a blob you cannot be

00:37:59,720 --> 00:38:05,150
next a blob however what you can do is

00:38:01,880 --> 00:38:08,230
you can combine this dynamic column with

00:38:05,150 --> 00:38:11,240
a virtual column and indexed virtual car

00:38:08,230 --> 00:38:15,349
so you can have a virtual for example if

00:38:11,240 --> 00:38:16,580
you want to index the color for some

00:38:15,349 --> 00:38:17,750
reason you want to look at I mean it

00:38:16,580 --> 00:38:18,950
doesn't sound very plausible that you

00:38:17,750 --> 00:38:20,750
would want to have an index on the color

00:38:18,950 --> 00:38:23,210
but let's say you want to have an index

00:38:20,750 --> 00:38:25,609
on the color of object inside inside

00:38:23,210 --> 00:38:28,339
this table so you create a virtual

00:38:25,609 --> 00:38:31,350
column which does this it gets the color

00:38:28,339 --> 00:38:34,260
value of every single object in this

00:38:31,350 --> 00:38:36,960
dynamic well and then you can index on

00:38:34,260 --> 00:38:39,090
this and there you have an index to look

00:38:36,960 --> 00:38:40,830
for the color I mean typically color is

00:38:39,090 --> 00:38:42,930
not white not be what you want to index

00:38:40,830 --> 00:38:44,940
but you might want to index something

00:38:42,930 --> 00:38:47,520
else but but you can do it through the

00:38:44,940 --> 00:38:52,410
virtual calls so that's pretty cool I

00:38:47,520 --> 00:38:55,230
mean it's not it's not exactly Jason but

00:38:52,410 --> 00:38:59,460
it's really kind of close to Jason and

00:38:55,230 --> 00:39:01,410
it's actually actually one of our guys

00:38:59,460 --> 00:39:03,450
who's developing script for converting

00:39:01,410 --> 00:39:06,510
this back and forth through from json

00:39:03,450 --> 00:39:09,540
format this actually there's features

00:39:06,510 --> 00:39:11,810
for getting this out in JSON format I

00:39:09,540 --> 00:39:13,830
think you might be 10 you can actually

00:39:11,810 --> 00:39:15,330
anything you have in a dynamic column

00:39:13,830 --> 00:39:17,580
you can actually get it out in JSON

00:39:15,330 --> 00:39:20,040
format there's no future for getting

00:39:17,580 --> 00:39:21,150
reading Jason forward natively yet but

00:39:20,040 --> 00:39:25,560
there are scripts where you can turn

00:39:21,150 --> 00:39:29,100
where you can convert Jason format into

00:39:25,560 --> 00:39:33,120
this dynamic column format so that's

00:39:29,100 --> 00:39:38,160
pretty cool feature does any more like

00:39:33,120 --> 00:39:46,280
this feature okay I got to like sand one

00:39:38,160 --> 00:39:46,280
maybe that's I like this feature right

00:39:47,280 --> 00:39:52,869
I guess this thing with this feature is

00:39:50,290 --> 00:39:54,130
well if you need to have I mean you

00:39:52,869 --> 00:39:55,510
don't have to go to notice girl just

00:39:54,130 --> 00:39:57,670
because you need flexibility because you

00:39:55,510 --> 00:39:58,720
can get it within Maria baby of course

00:39:57,670 --> 00:40:01,480
there are other reasons for going to

00:39:58,720 --> 00:40:06,670
know SQL solutions but you don't need to

00:40:01,480 --> 00:40:11,290
go for another telescope for this right

00:40:06,670 --> 00:40:13,960
some other features in my Maria b53 some

00:40:11,290 --> 00:40:15,670
replication enhancements check sums for

00:40:13,960 --> 00:40:20,710
binlog events and things like that I

00:40:15,670 --> 00:40:26,920
guess for dbas a really nice features

00:40:20,710 --> 00:40:30,460
feature is this so MySQL the Munchkin

00:40:26,920 --> 00:40:33,369
binlog has two formats right I thought

00:40:30,460 --> 00:40:35,650
you can store store your statements in

00:40:33,369 --> 00:40:39,790
statement based format on your android

00:40:35,650 --> 00:40:41,800
based format and the behavior that

00:40:39,790 --> 00:40:43,180
what's in the bin log is used for for

00:40:41,800 --> 00:40:45,430
replication and also for incremental

00:40:43,180 --> 00:40:47,140
backups because when you take a bag of

00:40:45,430 --> 00:40:49,390
MySQL you synchronize with the bin log

00:40:47,140 --> 00:40:50,859
so that you can replay everything that

00:40:49,390 --> 00:40:52,030
happened in the bin log after your

00:40:50,859 --> 00:40:56,109
backup so it's kind of an incremental

00:40:52,030 --> 00:40:57,460
backup the main lock and traditionally

00:40:56,109 --> 00:40:59,320
you store statements if you write an

00:40:57,460 --> 00:41:00,550
insert you store this insert in the

00:40:59,320 --> 00:41:04,210
binary log the problem with strong

00:41:00,550 --> 00:41:07,630
statements is that some functions are

00:41:04,210 --> 00:41:09,310
non deterministic so if you store if you

00:41:07,630 --> 00:41:11,350
store a statement containing a non

00:41:09,310 --> 00:41:13,630
deterministic function it means that the

00:41:11,350 --> 00:41:15,490
result of this statement depends on

00:41:13,630 --> 00:41:17,530
something else so it means that if you

00:41:15,490 --> 00:41:19,300
run the statement twice you might not

00:41:17,530 --> 00:41:21,880
get exactly the same result which means

00:41:19,300 --> 00:41:23,170
it basically your database will look

00:41:21,880 --> 00:41:26,160
different if you run this a second time

00:41:23,170 --> 00:41:30,400
and this is why we introduced row based

00:41:26,160 --> 00:41:33,730
row based events or row based binary

00:41:30,400 --> 00:41:35,500
logging in my MySQL 51 which means that

00:41:33,730 --> 00:41:37,840
instead of storing a statement you store

00:41:35,500 --> 00:41:39,460
raw images so this is how the row looked

00:41:37,840 --> 00:41:41,470
before the operation this is how the

00:41:39,460 --> 00:41:43,000
road should look after the operation so

00:41:41,470 --> 00:41:45,730
we don't care which statement cause this

00:41:43,000 --> 00:41:46,990
operation we just store how to row

00:41:45,730 --> 00:41:48,850
should look which makes it a much

00:41:46,990 --> 00:41:50,230
completely deterministic we don't care

00:41:48,850 --> 00:41:53,310
which function there was we don't care

00:41:50,230 --> 00:41:55,980
what it did this is how it should look

00:41:53,310 --> 00:41:57,690
and this is great except them endeavor

00:41:55,980 --> 00:41:59,430
bugs in the beginning which is it scary

00:41:57,690 --> 00:42:00,780
but once it once they fixed most of the

00:41:59,430 --> 00:42:05,040
but I mean this was 51 so a long time

00:42:00,780 --> 00:42:07,650
ago but one of one of the main

00:42:05,040 --> 00:42:10,320
complaints we got from some DPAs we're

00:42:07,650 --> 00:42:13,020
like all right this is great but now I

00:42:10,320 --> 00:42:15,210
have a one of my developers who said who

00:42:13,020 --> 00:42:16,770
said that oh I deleted some rows by

00:42:15,210 --> 00:42:20,430
mistake could you please undo that

00:42:16,770 --> 00:42:23,490
statement well if you have if you have a

00:42:20,430 --> 00:42:25,260
binary log in in row based format you

00:42:23,490 --> 00:42:26,850
can't find a statement in the binary log

00:42:25,260 --> 00:42:30,090
anymore because statement is no longer

00:42:26,850 --> 00:42:31,800
there so we actually had one company who

00:42:30,090 --> 00:42:33,870
said that we refuse to change the row

00:42:31,800 --> 00:42:35,310
based format because of this because we

00:42:33,870 --> 00:42:36,660
have developers deleting stuff all the

00:42:35,310 --> 00:42:40,140
time and we want to be able to find

00:42:36,660 --> 00:42:41,700
adjacent happy binary log so what we

00:42:40,140 --> 00:42:44,280
really did was that they actually added

00:42:41,700 --> 00:42:46,710
this statement so there's a business

00:42:44,280 --> 00:42:49,380
option for stores for storing a bun and

00:42:46,710 --> 00:42:52,110
login in row based format but with the

00:42:49,380 --> 00:42:53,850
statement on top in a comment so if you

00:42:52,110 --> 00:42:55,650
apply this log the statement won't be

00:42:53,850 --> 00:42:59,190
used for anything but they're so that

00:42:55,650 --> 00:43:10,260
you can search for it as a DBA so it's a

00:42:59,190 --> 00:43:13,280
cool feature for dbas it's funny you

00:43:10,260 --> 00:43:13,280
know this stuff you hear from customers

00:43:13,370 --> 00:43:21,540
so unless it's such a simple feature but

00:43:16,050 --> 00:43:23,280
that apparently was very important this

00:43:21,540 --> 00:43:24,540
is why it's good to to communicate with

00:43:23,280 --> 00:43:26,250
your customers because you know you

00:43:24,540 --> 00:43:27,510
never know what you think you're you

00:43:26,250 --> 00:43:28,560
think what you think they should be

00:43:27,510 --> 00:43:31,800
doing but they're not doing what you

00:43:28,560 --> 00:43:35,040
think they they are I shouldn't another

00:43:31,800 --> 00:43:36,600
feature which is actually requested by a

00:43:35,040 --> 00:43:39,360
customer as well it's a progress report

00:43:36,600 --> 00:43:46,290
alter table so you know my SQL alter

00:43:39,360 --> 00:43:49,050
table sucks right until five six I mean

00:43:46,290 --> 00:43:51,360
all our tables in MySQL it's like okay

00:43:49,050 --> 00:43:52,740
hold on alter table let's assume that

00:43:51,360 --> 00:43:55,290
he's doing something bad and let's

00:43:52,740 --> 00:43:57,690
create a copy of the table and we lock

00:43:55,290 --> 00:44:00,480
the table we create a new table we copy

00:43:57,690 --> 00:44:03,300
everything from the old table to the new

00:44:00,480 --> 00:44:05,119
table and then release the locks and and

00:44:03,300 --> 00:44:08,410
so forth so even if you do a

00:44:05,119 --> 00:44:11,569
all today will change a column name

00:44:08,410 --> 00:44:13,220
mysql ree copies every single row in the

00:44:11,569 --> 00:44:15,769
table of ternary table which is

00:44:13,220 --> 00:44:19,069
completely useless but that's the way

00:44:15,769 --> 00:44:21,140
it's done right which means all the

00:44:19,069 --> 00:44:22,640
tables are horribly horribly slow in

00:44:21,140 --> 00:44:25,249
mysql so I mean that's probably number

00:44:22,640 --> 00:44:27,049
one we're not fixing this but what we're

00:44:25,249 --> 00:44:28,640
fixing is actually now you're no hustler

00:44:27,049 --> 00:44:30,890
that are going to be so if you do an

00:44:28,640 --> 00:44:32,839
altar table if you do an altar table you

00:44:30,890 --> 00:44:35,599
actually see a progress report so if you

00:44:32,839 --> 00:44:39,619
do it from the really big client you get

00:44:35,599 --> 00:44:41,930
like a row below it saying alright this

00:44:39,619 --> 00:44:43,369
is how long it's this is how much how

00:44:41,930 --> 00:44:46,789
big a percentage of this stage we've

00:44:43,369 --> 00:44:48,890
done I typically here DBA you'd start an

00:44:46,789 --> 00:44:51,559
altar table and then you sit down you

00:44:48,890 --> 00:44:52,940
wait you wait and then it's been like 10

00:44:51,559 --> 00:44:54,349
minutes you're like okay I have to

00:44:52,940 --> 00:44:56,690
cancel this it's been ten minutes one

00:44:54,349 --> 00:44:58,430
table is offline but you like but what

00:44:56,690 --> 00:45:01,039
if it only takes 11 you know you're so

00:44:58,430 --> 00:45:03,109
close so you'd let go for a bit for and

00:45:01,039 --> 00:45:05,150
then 20 minutes later it's like it's

00:45:03,109 --> 00:45:07,730
been half an hour my table is not do it

00:45:05,150 --> 00:45:10,309
it's like but if it's a 35-minute all

00:45:07,730 --> 00:45:11,599
the table I was this close you know but

00:45:10,309 --> 00:45:12,799
it's like really hard to know when

00:45:11,599 --> 00:45:15,170
should you cancel it the one should let

00:45:12,799 --> 00:45:17,210
go well now you know right if you use

00:45:15,170 --> 00:45:18,739
this feature you see you at the five

00:45:17,210 --> 00:45:21,799
minutes you see okay ten percent is

00:45:18,739 --> 00:45:23,779
going to take 50 or or 90 it's going to

00:45:21,799 --> 00:45:27,200
take 60 you know exactly when they

00:45:23,779 --> 00:45:29,420
canceled it so that's good I mean still

00:45:27,200 --> 00:45:30,440
the table all the tables performance

00:45:29,420 --> 00:45:33,499
should be fixed but that's a different

00:45:30,440 --> 00:45:36,380
problem there's actually a feature

00:45:33,499 --> 00:45:37,849
request for fixing it especially some of

00:45:36,380 --> 00:45:40,940
the simpler alter table operations that

00:45:37,849 --> 00:45:43,369
could be done really quickly but it's

00:45:40,940 --> 00:45:51,410
not there yet some of them in 56 innodb

00:45:43,369 --> 00:45:52,880
some of them are online but not all then

00:45:51,410 --> 00:45:57,970
there was a lot of optimizer

00:45:52,880 --> 00:45:57,970
enhancements as well in murrieta be 53

00:45:58,630 --> 00:46:02,089
we're running out of time so I'm not

00:46:00,559 --> 00:46:06,019
going to go through all of these these

00:46:02,089 --> 00:46:08,890
but the main one was the sub query

00:46:06,019 --> 00:46:08,890
optimization so

00:46:10,829 --> 00:46:19,930
in mysql 41 we are the sub queries right

00:46:17,710 --> 00:46:21,099
because people kept complaining you

00:46:19,930 --> 00:46:22,750
don't even have sub queries you don't

00:46:21,099 --> 00:46:25,510
even have subgrade we can't use mysql it

00:46:22,750 --> 00:46:28,000
does not sub queries so in 41 which is

00:46:25,510 --> 00:46:31,270
ok we added sub queries we have sub

00:46:28,000 --> 00:46:32,799
queries checkbox checkbox marks people

00:46:31,270 --> 00:46:35,650
are great job subgrade should be used in

00:46:32,799 --> 00:46:38,760
such garden don't use them because the

00:46:35,650 --> 00:46:42,069
performance is abysmal right because

00:46:38,760 --> 00:46:43,690
like a lot of other things the sub query

00:46:42,069 --> 00:46:46,059
performance was like all right let's

00:46:43,690 --> 00:46:49,270
expect the worst case and let's just do

00:46:46,059 --> 00:46:52,059
the worst gauge and that's it so every

00:46:49,270 --> 00:46:54,640
time you had a sub query we did it based

00:46:52,059 --> 00:46:58,809
on the worst possible combination of

00:46:54,640 --> 00:47:01,359
things so we will always be reissue each

00:46:58,809 --> 00:47:02,740
into each internal query for each row in

00:47:01,359 --> 00:47:04,660
the outer query and things like even if

00:47:02,740 --> 00:47:08,650
we didn't need to just because you know

00:47:04,660 --> 00:47:10,000
there was an optimization so we used to

00:47:08,650 --> 00:47:11,980
have performance tuning gigs at

00:47:10,000 --> 00:47:14,380
customers first thing we did was I using

00:47:11,980 --> 00:47:17,770
sub queries yes ok let's rewrite all of

00:47:14,380 --> 00:47:19,539
them to join all right but now it may

00:47:17,770 --> 00:47:21,039
really be there actually rewritten by

00:47:19,539 --> 00:47:22,450
the optimizer so you don't have to

00:47:21,039 --> 00:47:26,289
rewrite them itself you can actually use

00:47:22,450 --> 00:47:29,230
sub-queries not again it's a feature

00:47:26,289 --> 00:47:31,869
that people who have been using mysql

00:47:29,230 --> 00:47:34,180
ong time they know this so they don't

00:47:31,869 --> 00:47:35,799
use sub queries but people who are new

00:47:34,180 --> 00:47:36,970
to mysql they don't notice so they use

00:47:35,799 --> 00:47:39,160
sub queries and expect them to actually

00:47:36,970 --> 00:47:42,880
perform and day well they didn't but in

00:47:39,160 --> 00:47:45,039
murray navy they do and to be fair mysql

00:47:42,880 --> 00:47:50,410
56 also has some sub query optimization

00:47:45,039 --> 00:47:52,420
so minus 256 they're also optimized they

00:47:50,410 --> 00:47:54,250
don't have all of the optimizations but

00:47:52,420 --> 00:47:57,430
and i haven't seen a benchmark comparing

00:47:54,250 --> 00:47:59,230
the two but in theory the optimizations

00:47:57,430 --> 00:48:01,270
that exist in both should be pretty much

00:47:59,230 --> 00:48:03,549
the same in performance wise but they

00:48:01,270 --> 00:48:03,810
don't have as extensive optimizations as

00:48:03,549 --> 00:48:07,620
my

00:48:03,810 --> 00:48:13,890
that's my baby yet so that's a very cool

00:48:07,620 --> 00:48:16,080
feature if using sub-query and i'm going

00:48:13,890 --> 00:48:19,350
to skip the other ones you can look at

00:48:16,080 --> 00:48:24,960
them later oh yeah a really cool feature

00:48:19,350 --> 00:48:28,680
is a group commit and group commit has

00:48:24,960 --> 00:48:31,350
to do with with disk i/o so if you are

00:48:28,680 --> 00:48:33,930
if your traffic is I are bound that's

00:48:31,350 --> 00:48:38,880
basically in mysql that's basically two

00:48:33,930 --> 00:48:40,710
to two times you have to up to two times

00:48:38,880 --> 00:48:43,890
you have to flush tough to describe so

00:48:40,710 --> 00:48:46,830
if your transaction this is in a DVD

00:48:43,890 --> 00:48:49,590
right so so you have data files the data

00:48:46,830 --> 00:48:53,610
pages you have a buffer of course if you

00:48:49,590 --> 00:48:55,020
do a transaction you write everything in

00:48:53,610 --> 00:48:56,760
the buffer right you don't want to write

00:48:55,020 --> 00:49:02,640
anything to this because this are slow

00:48:56,760 --> 00:49:05,040
and disk seek times even slower you do

00:49:02,640 --> 00:49:07,770
changes you do commit of course if you

00:49:05,040 --> 00:49:09,240
commit transaction your changes should

00:49:07,770 --> 00:49:11,310
be persistent they should be durable

00:49:09,240 --> 00:49:14,970
that's part of being acid your changes

00:49:11,310 --> 00:49:17,310
have to be durable but what you don't

00:49:14,970 --> 00:49:20,190
want to do is flush your your data pages

00:49:17,310 --> 00:49:21,750
to disk because they could be store sort

00:49:20,190 --> 00:49:23,250
all over the place on the list you would

00:49:21,750 --> 00:49:24,750
have to flash one page there one page

00:49:23,250 --> 00:49:26,430
day one page there if you take a long

00:49:24,750 --> 00:49:29,280
time so instead you have what's called a

00:49:26,430 --> 00:49:32,370
redo log and a redo log buffer so what

00:49:29,280 --> 00:49:34,500
you flush the disk is your redo log why

00:49:32,370 --> 00:49:36,510
well because it's sequential so you just

00:49:34,500 --> 00:49:38,280
write sequentially on disk because it's

00:49:36,510 --> 00:49:41,160
small it doesn't have to change you

00:49:38,280 --> 00:49:42,660
don't have to you want to flush the

00:49:41,160 --> 00:49:45,120
whole data page you just flash the

00:49:42,660 --> 00:49:47,550
changes you made your data page so every

00:49:45,120 --> 00:49:49,470
time the transaction is committed you

00:49:47,550 --> 00:49:52,920
flush your reader log log buffer to disk

00:49:49,470 --> 00:49:55,440
okay and this allows you to have this

00:49:52,920 --> 00:49:57,270
allows you to have dirty pages in memory

00:49:55,440 --> 00:49:58,920
so you have changes in memory in your

00:49:57,270 --> 00:50:03,300
data structure that has not been flushed

00:49:58,920 --> 00:50:04,800
to disk because if your server restarts

00:50:03,300 --> 00:50:06,390
well you have the changes here in the

00:50:04,800 --> 00:50:08,610
redo log so you can actually apply the

00:50:06,390 --> 00:50:13,410
changes on this data right so you that's

00:50:08,610 --> 00:50:15,220
enough now if you have a lot of lot of

00:50:13,410 --> 00:50:17,089
concurrent transactions

00:50:15,220 --> 00:50:19,039
this means that you might have a lot of

00:50:17,089 --> 00:50:21,289
transactions being committed here so you

00:50:19,039 --> 00:50:24,799
might have a queue queue of transactions

00:50:21,289 --> 00:50:26,390
being committed and if this done if it's

00:50:24,799 --> 00:50:28,970
done sequentially of course it means

00:50:26,390 --> 00:50:30,589
that it becomes a bottle like so there's

00:50:28,970 --> 00:50:31,999
something called group commit so if you

00:50:30,589 --> 00:50:35,329
have multiple transactions they're

00:50:31,999 --> 00:50:37,789
committed together in one F sink to disk

00:50:35,329 --> 00:50:40,069
and that's that's already existed in

00:50:37,789 --> 00:50:46,190
MySQL before the problem is that you

00:50:40,069 --> 00:50:47,960
also have the binary log in MySQL right

00:50:46,190 --> 00:50:50,059
and the binary log has all your

00:50:47,960 --> 00:50:52,849
transactions which means when you commit

00:50:50,059 --> 00:50:54,259
a transaction I mean if you if you care

00:50:52,849 --> 00:50:56,390
about the integrity of your data when

00:50:54,259 --> 00:50:57,739
you community interaction you not only

00:50:56,390 --> 00:51:00,349
have to flush the redo log buffer to

00:50:57,739 --> 00:51:02,599
disk you also have to flush the

00:51:00,349 --> 00:51:05,329
transaction to the binary log and these

00:51:02,599 --> 00:51:07,819
have to be synced because if your server

00:51:05,329 --> 00:51:10,009
crashes you want to binary log and your

00:51:07,819 --> 00:51:11,239
data on your disk to be in sync right

00:51:10,009 --> 00:51:13,700
you don't want to have an event in the

00:51:11,239 --> 00:51:16,430
binary log that never took place here

00:51:13,700 --> 00:51:19,369
for example if uses for application you

00:51:16,430 --> 00:51:20,779
do an update here you've read it through

00:51:19,369 --> 00:51:22,489
binary log but not here then it means

00:51:20,779 --> 00:51:23,869
that the update will go to the slave but

00:51:22,489 --> 00:51:25,009
it actually won't be on the master

00:51:23,869 --> 00:51:27,950
anymore because the master crashed and

00:51:25,009 --> 00:51:29,359
restarted or the opposite so you have to

00:51:27,950 --> 00:51:31,460
make sure these are think then by

00:51:29,359 --> 00:51:33,410
default it's not synced actually it's an

00:51:31,460 --> 00:51:36,319
option my scope called sync binlog and

00:51:33,410 --> 00:51:38,239
you have to turn this on otherwise the

00:51:36,319 --> 00:51:44,390
bin log and your video logs are not

00:51:38,239 --> 00:51:46,220
necessarily in sync and again this if

00:51:44,390 --> 00:51:50,059
you have a highly concurrent environment

00:51:46,220 --> 00:51:51,440
becomes a bottleneck because you have

00:51:50,059 --> 00:51:53,599
all these transactions having to be

00:51:51,440 --> 00:51:55,730
synced to disk and you might have a long

00:51:53,599 --> 00:51:59,839
queue here so what group come it does is

00:51:55,730 --> 00:52:02,180
that it it commits all of these

00:51:59,839 --> 00:52:04,369
interactions that are in a queue waiting

00:52:02,180 --> 00:52:07,249
to be to be flushed to disk they flush

00:52:04,369 --> 00:52:09,200
them in one go and that's basically all

00:52:07,249 --> 00:52:11,140
it does it's very simple feature but it

00:52:09,200 --> 00:52:13,940
has huge impact

00:52:11,140 --> 00:52:16,220
and this is the first one to one in 53

00:52:13,940 --> 00:52:20,090
which was improved has been improved for

00:52:16,220 --> 00:52:22,480
1008 even better for 10 0 and so

00:52:20,090 --> 00:52:26,270
Facebook had their own group with patch

00:52:22,480 --> 00:52:28,040
which performed worse than the one in

00:52:26,270 --> 00:52:30,500
murrieta be they actually did the second

00:52:28,040 --> 00:52:31,850
one which is somewhere here and then

00:52:30,500 --> 00:52:33,200
they said okay we're never going to be

00:52:31,850 --> 00:52:35,090
as good as my year so that just took the

00:52:33,200 --> 00:52:36,620
one from Maria so Facebook uses the

00:52:35,090 --> 00:52:39,170
group commit feature from my ad but they

00:52:36,620 --> 00:52:41,330
don't use Maria DB per se but they took

00:52:39,170 --> 00:52:45,800
the group coming patch and patch it in

00:52:41,330 --> 00:52:47,300
their own in their own server that's a

00:52:45,800 --> 00:52:49,940
very cool feature if your i/o bound and

00:52:47,300 --> 00:52:51,410
again it's a feature that just there you

00:52:49,940 --> 00:52:52,850
don't have to do anything it would just

00:52:51,410 --> 00:52:56,120
kick in if you have as soon as you have

00:52:52,850 --> 00:53:00,880
a cue for syncing your binary log it

00:52:56,120 --> 00:53:00,880
will cook it'll kick in yeah

00:53:06,450 --> 00:53:12,930
I don't it's um it's some other utter

00:53:10,380 --> 00:53:16,050
bottleneck somewhere I mean I don't know

00:53:12,930 --> 00:53:18,030
why it depends on and it depends this is

00:53:16,050 --> 00:53:19,920
for a fast disk if you look at results

00:53:18,030 --> 00:53:23,010
for the slower disks they're much better

00:53:19,920 --> 00:53:24,810
I mean much better I mean of course the

00:53:23,010 --> 00:53:26,430
florist will be slower but they just

00:53:24,810 --> 00:53:28,079
keep increasing so it's just did you hit

00:53:26,430 --> 00:53:31,010
something else here I'm on a bottleneck

00:53:28,079 --> 00:53:31,010
that's not this guy

00:53:39,120 --> 00:53:47,370
okay we're running out of time so so

00:53:43,530 --> 00:53:49,440
then four maybe five five so they added

00:53:47,370 --> 00:53:51,360
the thread pool implementation as I said

00:53:49,440 --> 00:53:54,840
there was one for my you to be 51 but

00:53:51,360 --> 00:53:56,820
because Oracle made one from MySQL 55

00:53:54,840 --> 00:54:00,050
was better than the one you Maria be 51

00:53:56,820 --> 00:54:03,450
they redid it and have a new one that's

00:54:00,050 --> 00:54:07,140
very good so if you want the thread pool

00:54:03,450 --> 00:54:08,760
you don't have to pay Oracle for for a

00:54:07,140 --> 00:54:12,390
commercial version of MySQL you can get

00:54:08,760 --> 00:54:15,720
it from her UD be theirs atomic right to

00:54:12,390 --> 00:54:19,520
fusion-io who uses fusion-io here no one

00:54:15,720 --> 00:54:23,400
who knows what's fusion I always okay oh

00:54:19,520 --> 00:54:24,840
there you go so that's a I mean if you

00:54:23,400 --> 00:54:27,330
have a lot of customers use fusion-io

00:54:24,840 --> 00:54:30,000
actually or SSDs in general but fusion I

00:54:27,330 --> 00:54:31,680
fusion-io especially so for them this

00:54:30,000 --> 00:54:34,230
helps a lot actually I just spoke to a

00:54:31,680 --> 00:54:35,910
customer two weeks ago who said that

00:54:34,230 --> 00:54:37,800
they change to Maria and they actually

00:54:35,910 --> 00:54:39,120
saw a name its own impacts of this

00:54:37,800 --> 00:54:49,560
feature a tonic white feature in

00:54:39,120 --> 00:54:52,230
performance and another feature which is

00:54:49,560 --> 00:54:55,920
really still it's pretty much useless is

00:54:52,230 --> 00:54:58,800
a limit Rose examined so typical my

00:54:55,920 --> 00:55:00,450
skill has as a limit something to do is

00:54:58,800 --> 00:55:02,820
select limit 10 which means you only get

00:55:00,450 --> 00:55:05,280
10 rows in your select however if

00:55:02,820 --> 00:55:08,340
there's a huge join before it will

00:55:05,280 --> 00:55:10,560
create the joint result before giving

00:55:08,340 --> 00:55:13,860
you the 10 10 rows so now you can have a

00:55:10,560 --> 00:55:15,840
have a limit Rose examined which means

00:55:13,860 --> 00:55:17,310
that is only examine these many rows in

00:55:15,840 --> 00:55:18,780
the joint or whatever and then it will

00:55:17,310 --> 00:55:22,350
stop and gives you whatever result it

00:55:18,780 --> 00:55:23,880
has come to so it's kind of limit 10

00:55:22,350 --> 00:55:25,650
works if you do a single table it means

00:55:23,880 --> 00:55:29,010
you only look at ten rows but if you

00:55:25,650 --> 00:55:30,480
have a complex query it must take till

00:55:29,010 --> 00:55:33,660
take a long time to generate those ten

00:55:30,480 --> 00:55:35,280
rows so by adding this you know it's a

00:55:33,660 --> 00:55:37,400
DBA feature of course you don't use this

00:55:35,280 --> 00:55:40,950
in production anywhere hopefully but

00:55:37,400 --> 00:55:43,059
it's still a cool feature

00:55:40,950 --> 00:55:44,619
alright there's maybe a bigger got out

00:55:43,059 --> 00:55:48,519
of cluster but i already mentioned it

00:55:44,619 --> 00:55:50,950
yesterday daniel already gave a talk

00:55:48,519 --> 00:55:53,410
about maybe 10 so i'm not going to say

00:55:50,950 --> 00:55:55,089
much more about that the only thing I'm

00:55:53,410 --> 00:55:57,039
going to again say then I mean Daniel

00:55:55,089 --> 00:55:58,630
didn't mention is yesterday's these per

00:55:57,039 --> 00:56:02,529
thread memory usage which are really

00:55:58,630 --> 00:56:03,970
cool they're kind of feed into the user

00:56:02,529 --> 00:56:05,950
statistics and things that we talked

00:56:03,970 --> 00:56:10,720
about so you know one of the big issues

00:56:05,950 --> 00:56:12,430
with mysql is that you don't when you

00:56:10,720 --> 00:56:14,109
put memory usage limit they're all

00:56:12,430 --> 00:56:16,599
global the knots per thread you cannot

00:56:14,109 --> 00:56:19,329
say one fit can only use this much you I

00:56:16,599 --> 00:56:20,529
mean you cannot have a global sorry you

00:56:19,329 --> 00:56:24,509
cannot have a global you just have a

00:56:20,529 --> 00:56:26,859
post read limit so like temporary table

00:56:24,509 --> 00:56:28,779
you have a Mac sighs and temporary table

00:56:26,859 --> 00:56:32,710
used for thread so you can say that to

00:56:28,779 --> 00:56:35,109
be say 16 megs but you're there's no

00:56:32,710 --> 00:56:37,450
total usage limit limit which means that

00:56:35,109 --> 00:56:39,099
one query can only use 16 megs which is

00:56:37,450 --> 00:56:42,099
not a lot but if you happen to have a

00:56:39,099 --> 00:56:44,170
thousand threads doing temporary tables

00:56:42,099 --> 00:56:45,940
at the same time it becomes a lot but

00:56:44,170 --> 00:56:48,789
there's no way you can balance that

00:56:45,940 --> 00:56:50,619
that's very annoying in mysql but you

00:56:48,789 --> 00:56:51,789
still can't do it but with this point

00:56:50,619 --> 00:56:53,529
further than where you you can actually

00:56:51,789 --> 00:56:55,329
see how much memory your threads are

00:56:53,529 --> 00:56:59,289
using so you can it makes it easier to

00:56:55,329 --> 00:57:01,329
tune these variables but looking at that

00:56:59,289 --> 00:57:02,920
such a cool feature and there's a lot of

00:57:01,329 --> 00:57:11,789
cool features in 10 but I'm not going to

00:57:02,920 --> 00:57:11,789
go through this all right any questions

00:57:13,110 --> 00:57:19,290
no questions part thank you very much

00:57:22,080 --> 00:57:25,080
yeah

00:57:30,190 --> 00:57:35,240
when we created asterisk over a decade

00:57:32,900 --> 00:57:37,220
ago we could not have imagined that

00:57:35,240 --> 00:57:39,410
asterisk would not only become the most

00:57:37,220 --> 00:57:41,540
widely adopted open source communication

00:57:39,410 --> 00:57:43,580
software on the planet but that it would

00:57:41,540 --> 00:57:46,100
impact the entire industry in the way

00:57:43,580 --> 00:57:48,080
that it has today asterisk has found its

00:57:46,100 --> 00:57:50,720
way into more than 170 countries and

00:57:48,080 --> 00:57:52,670
virtually every fortune 1000 company the

00:57:50,720 --> 00:57:54,770
success of asterisk has enabled a

00:57:52,670 --> 00:57:56,180
transition of power from the hands of

00:57:54,770 --> 00:57:58,460
the traditional proprietary phone

00:57:56,180 --> 00:58:00,830
vendors into the hands of the users and

00:57:58,460 --> 00:58:02,780
administrators of phone systems using

00:58:00,830 --> 00:58:04,010
this power our customers have created

00:58:02,780 --> 00:58:05,960
all sorts of business changing

00:58:04,010 --> 00:58:07,790
applications from small office phone

00:58:05,960 --> 00:58:10,310
systems to mission-critical call centres

00:58:07,790 --> 00:58:11,930
the international carrier networks in

00:58:10,310 --> 00:58:13,700
fact there's even an entire country

00:58:11,930 --> 00:58:16,310
those communications of a structure runs

00:58:13,700 --> 00:58:18,230
on esters the gym has always been about

00:58:16,310 --> 00:58:19,940
creating technology that expands

00:58:18,230 --> 00:58:22,100
communications capabilities in ways that

00:58:19,940 --> 00:58:23,300
we could never have imagined and that's

00:58:22,100 --> 00:58:25,700
part of what's game-changing about

00:58:23,300 --> 00:58:28,400
Digium today we're doing it again this

00:58:25,700 --> 00:58:30,500
time by introducing a new family of HD

00:58:28,400 --> 00:58:32,600
IP phones that extends control of the

00:58:30,500 --> 00:58:34,370
user all the way to the desktop the

00:58:32,600 --> 00:58:36,080
launch of these new products represents

00:58:34,370 --> 00:58:38,180
the next phase indigenous history of

00:58:36,080 --> 00:58:40,580
innovation these are the first and only

00:58:38,180 --> 00:58:42,290
IP phones designed to fully leverage the

00:58:40,580 --> 00:58:43,850
power of estrus when we first discussed

00:58:42,290 --> 00:58:45,860
our expectations for building a family

00:58:43,850 --> 00:58:48,020
of phones for use with asterisk our

00:58:45,860 --> 00:58:49,760
requirements were pretty simple we asked

00:58:48,020 --> 00:58:51,410
the team to build the phones such that

00:58:49,760 --> 00:58:53,600
they were easy to install integrate

00:58:51,410 --> 00:58:55,430
provision and use I think you'll soon

00:58:53,600 --> 00:58:58,010
agree our engineers have delivered on

00:58:55,430 --> 00:58:59,630
that goal user feedback is validating

00:58:58,010 --> 00:59:01,760
that when it comes to operation with

00:58:59,630 --> 00:59:04,160
astro space systems including our own

00:59:01,760 --> 00:59:06,740
Switchvox based product these are the

00:59:04,160 --> 00:59:08,060
easiest to use best integrated most

00:59:06,740 --> 00:59:10,640
interoperable products on the market

00:59:08,060 --> 00:59:12,640
today the digitally phones will

00:59:10,640 --> 00:59:14,690
initially include three IP des hommes

00:59:12,640 --> 00:59:16,640
uniquely designed to complement any

00:59:14,690 --> 00:59:18,500
asterisks or Switchvox based solution

00:59:16,640 --> 00:59:21,170
these phones are different for a number

00:59:18,500 --> 00:59:23,840
of reasons first there is clue sively

00:59:21,170 --> 00:59:25,250
designed for use with esters secondly

00:59:23,840 --> 00:59:26,860
we've made it really easy to

00:59:25,250 --> 00:59:29,270
autodiscover and provision the phones

00:59:26,860 --> 00:59:31,340
next we've made it easy for the phones

00:59:29,270 --> 00:59:32,960
to access information inside of asterisk

00:59:31,340 --> 00:59:34,900
allowing tight coupling

00:59:32,960 --> 00:59:36,859
between an application and the phone

00:59:34,900 --> 00:59:39,020
additionally we've created an

00:59:36,859 --> 00:59:41,150
applications engine that allows users

00:59:39,020 --> 00:59:44,390
and developers to create and run their

00:59:41,150 --> 00:59:46,160
own apps on the phone and finally we've

00:59:44,390 --> 00:59:48,109
done all of this at a very compelling

00:59:46,160 --> 00:59:49,790
price point at Digium we're always

00:59:48,109 --> 00:59:51,890
thinking of ways to give our customers

00:59:49,790 --> 00:59:54,410
the best value in business phone systems

00:59:51,890 --> 00:59:56,000
and also give them the power to create

00:59:54,410 --> 00:59:58,160
their own solutions or any

00:59:56,000 --> 00:59:59,869
communications challenge will continue

00:59:58,160 --> 01:00:01,310
to push the boundaries not only to make

00:59:59,869 --> 01:00:03,380
Astra's cooler faster and more

01:00:01,310 --> 01:00:05,000
technologically feature-rich but to make

01:00:03,380 --> 01:00:07,460
asterisk and what communications even

01:00:05,000 --> 01:00:11,170
easier and together we'll change the way

01:00:07,460 --> 01:00:11,170
the world communicates again

01:00:21,560 --> 01:00:28,380
how's that sigh every way this is the

01:00:25,080 --> 01:00:30,540
way to better utilize all your resources

01:00:28,380 --> 01:00:33,990
and it makes managing all your resources

01:00:30,540 --> 01:00:37,850
pretty easy all of the innovation is

01:00:33,990 --> 01:00:41,310
happening in open source the

01:00:37,850 --> 01:00:43,170
collaborative nature and of the you know

01:00:41,310 --> 01:00:45,270
of the community and the speed at which

01:00:43,170 --> 01:00:47,250
these are these you know these these

01:00:45,270 --> 01:00:49,560
deficiencies these bugs are getting

01:00:47,250 --> 01:00:52,170
discovered and then fixed is it like

01:00:49,560 --> 01:00:54,840
that really shows the power of the you

01:00:52,170 --> 01:00:56,490
know of the open source community it is

01:00:54,840 --> 01:01:00,720
global and it's definitely because of

01:00:56,490 --> 01:01:07,050
the users community people are extremely

01:01:00,720 --> 01:01:08,910
friendly and always ready to help if you

01:01:07,050 --> 01:01:11,220
go on tire see any day you'll see these

01:01:08,910 --> 01:01:12,950
guys helping each other out and they're

01:01:11,220 --> 01:01:15,660
all doing it like in a selfless manner

01:01:12,950 --> 01:01:18,650
the product is transparent for everyone

01:01:15,660 --> 01:01:21,600
everyone can look at the code base

01:01:18,650 --> 01:01:23,310
everyone can see how close darkest is

01:01:21,600 --> 01:01:29,190
being built nothing nothing is

01:01:23,310 --> 01:01:31,830
proprietary everything is open in many

01:01:29,190 --> 01:01:36,030
ways it's absolutely vital to the the

01:01:31,830 --> 01:01:39,780
ongoing health cloudstack the most

01:01:36,030 --> 01:01:43,579
exciting event in recent memory for me

01:01:39,780 --> 01:01:46,339
was our first developer boot camp

01:01:43,579 --> 01:01:48,979
and our call gave people I gave you two

01:01:46,339 --> 01:01:52,940
weeks notice to come attend I was

01:01:48,979 --> 01:01:57,109
expecting 25 or 30 people so we ended up

01:01:52,940 --> 01:01:59,959
with 87 people and had to go get more

01:01:57,109 --> 01:02:02,509
chairs in the room twice everything

01:01:59,959 --> 01:02:05,749
within cloud computing is commodity and

01:02:02,509 --> 01:02:08,809
is open source and so I don't think that

01:02:05,749 --> 01:02:10,549
you will you'll see anywhere where open

01:02:08,809 --> 01:02:13,609
source is not pervasive in cloud

01:02:10,549 --> 01:02:16,309
computing and so i think it's i think

01:02:13,609 --> 01:02:17,660
it's an assumption i think when you talk

01:02:16,309 --> 01:02:21,400
about cloud computing you're really

01:02:17,660 --> 01:02:21,400
talking about a source cloud computing

01:02:21,670 --> 01:02:27,739
cloud zac is a robust solution for large

01:02:24,950 --> 01:02:30,109
deployments you'll have dozens of data

01:02:27,739 --> 01:02:34,069
centers and thousands of servers in each

01:02:30,109 --> 01:02:37,400
data center is these hardware is going

01:02:34,069 --> 01:02:40,609
to fail and CloudStack is designed to

01:02:37,400 --> 01:02:43,099
handle number one that mass scale number

01:02:40,609 --> 01:02:45,829
two it's designed to handle the failure

01:02:43,099 --> 01:02:48,349
that inevitably happens in large

01:02:45,829 --> 01:02:51,890
deployments started working on college

01:02:48,349 --> 01:02:55,249
attack over four years ago and it was

01:02:51,890 --> 01:02:57,920
the original set of people working on it

01:02:55,249 --> 01:03:01,789
had a background of delivering software

01:02:57,920 --> 01:03:06,259
to telcos and service providers lots of

01:03:01,789 --> 01:03:09,890
QA lots of users actually using it hi

01:03:06,259 --> 01:03:12,979
availability is a key feature multiple

01:03:09,890 --> 01:03:14,989
hypervisors support different network

01:03:12,979 --> 01:03:17,660
models you can pick up whatever suits

01:03:14,989 --> 01:03:19,910
you better while step management server

01:03:17,660 --> 01:03:23,599
can be deployed in different physical

01:03:19,910 --> 01:03:25,279
machines it definitely has a huge

01:03:23,599 --> 01:03:30,259
footprint it's being deployed everywhere

01:03:25,279 --> 01:03:32,839
there's a major movie studio that they

01:03:30,259 --> 01:03:36,140
were using cloudstack they were using it

01:03:32,839 --> 01:03:38,119
to transcode video and i thought that

01:03:36,140 --> 01:03:39,769
was terribly fascinating what i found

01:03:38,119 --> 01:03:43,039
more fascinating is what they did during

01:03:39,769 --> 01:03:45,829
lunch where they would spin up you know

01:03:43,039 --> 01:03:47,000
50 or 60 game servers then as soon as

01:03:45,829 --> 01:03:48,800
lunch was over they would

01:03:47,000 --> 01:03:53,060
helping instances and go back to doing

01:03:48,800 --> 01:03:54,560
real work CloudStack is vast it touches

01:03:53,060 --> 01:03:56,660
so many different aspects and there's no

01:03:54,560 --> 01:03:59,030
one person that's kind of like a master

01:03:56,660 --> 01:04:03,140
of all those realms I think clouds stack

01:03:59,030 --> 01:04:05,450
as a project is going to be one of the

01:04:03,140 --> 01:04:09,410
leaders simply because it's some of the

01:04:05,450 --> 01:04:14,870
most feature fallen and and robust

01:04:09,410 --> 01:04:17,770
platforms out they were I don't senior

01:04:14,870 --> 01:04:17,770
living through the clouds dag

01:04:30,650 --> 01:04:35,690
most enterprises today realize that

01:04:33,410 --> 01:04:37,340
usernames and passwords alone aren't

01:04:35,690 --> 01:04:39,710
enough to keep their network saved from

01:04:37,340 --> 01:04:41,780
unauthorized intrusions that's my

01:04:39,710 --> 01:04:43,820
two-factor authentication has gotten so

01:04:41,780 --> 01:04:45,950
popular lately that adds that extra

01:04:43,820 --> 01:04:48,620
layer of protection enterprise networks

01:04:45,950 --> 01:04:50,390
need to stay safe but what you may not

01:04:48,620 --> 01:04:52,580
know is that some two-factor

01:04:50,390 --> 01:04:54,800
authentication solutions they're better

01:04:52,580 --> 01:04:57,830
than others like two-factor strong

01:04:54,800 --> 01:05:00,110
authentication with wicked wicked goes

01:04:57,830 --> 01:05:02,060
beyond other authentication systems by

01:05:00,110 --> 01:05:05,120
being less expensive easier to implement

01:05:02,060 --> 01:05:07,610
and easier to use giving software-based

01:05:05,120 --> 01:05:10,460
token clients built to run on all major

01:05:07,610 --> 01:05:13,060
devices and OSS including iOS and

01:05:10,460 --> 01:05:15,380
Android these tokens utilize a

01:05:13,060 --> 01:05:17,630
public/private key combination that's

01:05:15,380 --> 01:05:19,760
generated and on device so there aren't

01:05:17,630 --> 01:05:22,280
any shared secrets flying around for

01:05:19,760 --> 01:05:25,130
attackers to hijack or which require any

01:05:22,280 --> 01:05:26,990
special handling instead all keys are

01:05:25,130 --> 01:05:29,480
kept secure and private between the

01:05:26,990 --> 01:05:31,640
requesting token and your server which

01:05:29,480 --> 01:05:33,280
you control in house making it the most

01:05:31,640 --> 01:05:35,960
secure way possible to perform

01:05:33,280 --> 01:05:38,750
authentication encryption and with an

01:05:35,960 --> 01:05:41,540
extensive flexible API and support for

01:05:38,750 --> 01:05:43,520
protocols like ldap and radius wicket

01:05:41,540 --> 01:05:45,700
works with any enterprise network

01:05:43,520 --> 01:05:47,400
architecture to protect the IT

01:05:45,700 --> 01:05:50,010
Systems vital to your enterprise

01:05:47,400 --> 01:05:52,000
download your wicked free trial today

01:05:50,010 --> 01:05:53,770
regardless of whether you're considering

01:05:52,000 --> 01:05:55,570
two-factor authentication for the first

01:05:53,770 --> 01:05:58,810
time or just ready to ditch your

01:05:55,570 --> 01:06:01,210
existing expensive key file system we

01:05:58,810 --> 01:06:06,120
can help with easy to implement easy to

01:06:01,210 --> 01:06:06,120
use strong authentication from wicked

01:06:50,490 --> 01:06:54,760
your customers rely on your website or

01:06:53,230 --> 01:06:57,160
application if it's slower

01:06:54,760 --> 01:07:00,100
non-responsive it infuriates your users

01:06:57,160 --> 01:07:01,900
and costs you money keeping your

01:07:00,100 --> 01:07:05,430
business critical systems humming along

01:07:01,900 --> 01:07:08,250
requires insight into what they're doing

01:07:05,430 --> 01:07:10,230
your system metrics tell stories stories

01:07:08,250 --> 01:07:12,480
that can reveal performance bottlenecks

01:07:10,230 --> 01:07:14,670
resource limitations and other problems

01:07:12,480 --> 01:07:16,589
but how do you keep an eye on all of

01:07:14,670 --> 01:07:19,170
your systems performance metrics in

01:07:16,589 --> 01:07:22,020
real-time and record this data for later

01:07:19,170 --> 01:07:24,000
analysis enter longview the new way to

01:07:22,020 --> 01:07:26,040
see what's really going on under the

01:07:24,000 --> 01:07:28,170
hood the longview dashboard lets you

01:07:26,040 --> 01:07:30,150
visualize the status of all your systems

01:07:28,170 --> 01:07:32,880
providing you with a bird's-eye view of

01:07:30,150 --> 01:07:36,000
your entire fleet you can sort by cpu

01:07:32,880 --> 01:07:38,460
memory swap processes load and network

01:07:36,000 --> 01:07:41,040
usage click a specific system to access

01:07:38,460 --> 01:07:43,050
its individual dashboard then click and

01:07:41,040 --> 01:07:46,050
drag to zoom in on chokepoints and get

01:07:43,050 --> 01:07:48,030
more detail comprehensive network data

01:07:46,050 --> 01:07:50,730
including inbound and outbound traffic

01:07:48,030 --> 01:07:52,319
is available on the network tab and disk

01:07:50,730 --> 01:07:54,210
rights and free space on the disk

01:07:52,319 --> 01:07:57,059
stabbed while the process Explorer

01:07:54,210 --> 01:07:59,609
displays usage statistics for individual

01:07:57,059 --> 01:08:01,770
processes the system info tab shows

01:07:59,609 --> 01:08:04,020
listening services active connections

01:08:01,770 --> 01:08:06,150
and available updates adding long view

01:08:04,020 --> 01:08:07,829
to a system is easy just click the

01:08:06,150 --> 01:08:09,990
button copy the one line installation

01:08:07,829 --> 01:08:12,420
command then run the command on your

01:08:09,990 --> 01:08:14,130
linux system to complete the process the

01:08:12,420 --> 01:08:16,319
agent will begin collecting data and

01:08:14,130 --> 01:08:18,170
sending it to longview then the graphs

01:08:16,319 --> 01:08:20,719
start rolling

01:08:18,170 --> 01:08:23,089
used longview to gain visibility into

01:08:20,719 --> 01:08:26,830
your servers so when your website or app

01:08:23,089 --> 01:08:26,830

YouTube URL: https://www.youtube.com/watch?v=XjPUZ0aTbn8


