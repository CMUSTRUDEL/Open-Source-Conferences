Title: 2013 SouthEast LinuxFest - Samy Fodil - How Thin Provisioning Can Be Done From Userspace
Publication date: 2014-07-29
Playlist: 2013 SouthEast LinuxFest
Description: 
	2013 SouthEast LinuxFest
Samy Fodil - How Thin Provisioning Can Be Done From Userspace
Captions: 
	00:00:00,000 --> 00:00:05,160
the following presentation was recorded

00:00:02,639 --> 00:00:08,280
at the 2013 southeast linux fest in

00:00:05,160 --> 00:00:10,860
charlotte north carolina it is licensed

00:00:08,280 --> 00:00:12,509
under a creative commons license for

00:00:10,860 --> 00:00:16,619
more information about the southeast

00:00:12,509 --> 00:00:19,830
linux fest visit WWF eastland TX phase

00:00:16,619 --> 00:00:21,630
or the southeast linux fest would like

00:00:19,830 --> 00:00:24,000
to thank the following diamond sponsors

00:00:21,630 --> 00:00:28,710
in 2013 for helping make these videos

00:00:24,000 --> 00:00:34,410
possible the variability my name is semi

00:00:28,710 --> 00:00:39,360
for dead we present you a new kernel

00:00:34,410 --> 00:00:44,760
module its name is a vm multi-fight and

00:00:39,360 --> 00:00:49,770
it it's a device ma per module and it

00:00:44,760 --> 00:00:52,530
would be or it will be used to to do Tim

00:00:49,770 --> 00:00:58,969
provisioning from user from user space

00:00:52,530 --> 00:01:03,120
so excuse me for my accent and I'm not

00:00:58,969 --> 00:01:06,180
native English speaker and would you

00:01:03,120 --> 00:01:09,140
please when you ask question ask them

00:01:06,180 --> 00:01:14,119
slowly so so I can understand you and

00:01:09,140 --> 00:01:17,369
answer the questions ok first we have to

00:01:14,119 --> 00:01:21,720
understand what is thin provisioning so

00:01:17,369 --> 00:01:25,530
to do that I would just explain that

00:01:21,720 --> 00:01:29,310
with a simple example using VMware

00:01:25,530 --> 00:01:33,750
Workstation perhaps a lot of people are

00:01:29,310 --> 00:01:38,720
used with this product so when we create

00:01:33,750 --> 00:01:43,560
a virtual machine with VMware because we

00:01:38,720 --> 00:01:46,829
select the operating system that we can

00:01:43,560 --> 00:01:51,720
select windows line eggs and a lot of

00:01:46,829 --> 00:01:55,409
other systems it's just them where we'll

00:01:51,720 --> 00:01:59,070
set some settings for example for Linux

00:01:55,409 --> 00:02:03,420
which that one gigabyte for memory and

00:01:59,070 --> 00:02:08,369
other settings default settings and next

00:02:03,420 --> 00:02:11,490
for the hard drive we have the team

00:02:08,369 --> 00:02:15,390
provisioning hard drive so if we

00:02:11,490 --> 00:02:19,890
look if you look more closer you will

00:02:15,390 --> 00:02:23,270
read this file start small and become

00:02:19,890 --> 00:02:26,430
larger as you add application files data

00:02:23,270 --> 00:02:35,760
to your virtual machine so the file will

00:02:26,430 --> 00:02:39,330
become we'll start with to mix and when

00:02:35,760 --> 00:02:45,360
we install a system on it for example

00:02:39,330 --> 00:02:49,620
here it's a red hat enterprise linux so

00:02:45,360 --> 00:02:55,280
we start the installation and when we

00:02:49,620 --> 00:03:08,510
write change on the disk will see the

00:02:55,280 --> 00:03:11,850
file growing so it's 53 megabytes and as

00:03:08,510 --> 00:03:17,510
the installation process goes on at five

00:03:11,850 --> 00:03:25,200
become bigger so it will be 400 600 800

00:03:17,510 --> 00:03:32,040
1 gigabyte and so on but for the OS it's

00:03:25,200 --> 00:03:34,830
always 20 gigabytes and but really it's

00:03:32,040 --> 00:03:39,450
not 20 gigabytes this is tim

00:03:34,830 --> 00:03:42,720
provisioning so we have the the OS or

00:03:39,450 --> 00:03:47,010
the file system we have on our block

00:03:42,720 --> 00:03:49,710
device think things ie his in for exam

00:03:47,010 --> 00:03:54,330
20 gigabytes but it's not really 20

00:03:49,710 --> 00:03:57,600
gigabytes one of the advantage of this

00:03:54,330 --> 00:04:01,800
feature is for example we could for

00:03:57,600 --> 00:04:05,730
example I have five VMs with 100

00:04:01,800 --> 00:04:12,390
gigabytes H and store them in a file

00:04:05,730 --> 00:04:20,239
system with only 50 gigabytes available

00:04:12,390 --> 00:04:23,540
space so this this feature is very used

00:04:20,239 --> 00:04:29,460
in virtualization

00:04:23,540 --> 00:04:37,530
so i abused vmware but this cab this

00:04:29,460 --> 00:04:42,630
feature is available in v kv MQM and you

00:04:37,530 --> 00:04:45,930
have just to use q code to format for

00:04:42,630 --> 00:04:51,630
the disk or the vmware forma so you can

00:04:45,930 --> 00:04:57,360
use both and q me will will do the team

00:04:51,630 --> 00:05:02,370
provision and for you in this case we

00:04:57,360 --> 00:05:06,090
have have a little problem is that the

00:05:02,370 --> 00:05:08,820
vm goes through the filesystem layer and

00:05:06,090 --> 00:05:12,780
then to block the vice layer to access

00:05:08,820 --> 00:05:16,200
their their blocks so so it's it's

00:05:12,780 --> 00:05:22,650
slower better if the vm goes directly to

00:05:16,200 --> 00:05:25,020
the block device so to resolve this

00:05:22,650 --> 00:05:30,480
problem we can use directly a block

00:05:25,020 --> 00:05:34,710
device of an lvm partition or anything

00:05:30,480 --> 00:05:38,010
else any volume up with device mapper

00:05:34,710 --> 00:05:40,920
can be used but the problem here is

00:05:38,010 --> 00:05:45,560
we're going to lose the provisional tip

00:05:40,920 --> 00:05:49,790
provisional capability so we will have a

00:05:45,560 --> 00:05:58,590
volume of for example 20 gigabyte and

00:05:49,790 --> 00:06:03,150
I'm not avoiding will grow as we use the

00:05:58,590 --> 00:06:08,270
file system so hopefully we're only next

00:06:03,150 --> 00:06:15,420
and we can figure this out so we can use

00:06:08,270 --> 00:06:20,400
device mapper and he his functionalities

00:06:15,420 --> 00:06:31,350
so I will begin to explain what's the

00:06:20,400 --> 00:06:32,569
device mapper so the device mapper is a

00:06:31,350 --> 00:06:37,759
Linux

00:06:32,569 --> 00:06:44,679
Colonel feature that will give us the

00:06:37,759 --> 00:06:50,119
possibility to to make a virtual volume

00:06:44,679 --> 00:06:54,469
by mapping other other block devices

00:06:50,119 --> 00:06:57,919
from other rail or or virtual disks so

00:06:54,469 --> 00:07:03,770
let's suppose that we have two SATA disk

00:06:57,919 --> 00:07:06,199
and 2i skazhi disks so we we have to

00:07:03,770 --> 00:07:10,099
create a logical volume and use all of

00:07:06,199 --> 00:07:14,509
them and the problem is I skazhi is

00:07:10,099 --> 00:07:22,369
slower than SATA so if we want to have

00:07:14,509 --> 00:07:25,459
the same speed of performance we can we

00:07:22,369 --> 00:07:30,080
can have a stripping on the two I skazhi

00:07:25,459 --> 00:07:35,349
disks so with the Vice mapper we can do

00:07:30,080 --> 00:07:39,709
lot we can do that so our our volume is

00:07:35,349 --> 00:07:43,249
from from linear mapping to the first

00:07:39,709 --> 00:07:47,330
disc so if a process want the first

00:07:43,249 --> 00:07:50,529
block it will it will be linear map it

00:07:47,330 --> 00:07:54,169
to the first block in the first disc and

00:07:50,529 --> 00:07:57,589
if the second will will be the same and

00:07:54,169 --> 00:08:02,209
the two I skazhi disk will be a muppet

00:07:57,589 --> 00:08:04,339
with the strip target so we write one

00:08:02,209 --> 00:08:07,249
block here one block here one block hair

00:08:04,339 --> 00:08:10,519
one block hair so on so we can read to

00:08:07,249 --> 00:08:16,879
block in same time C so we have the

00:08:10,519 --> 00:08:21,619
speed speed increase by two so how we

00:08:16,879 --> 00:08:23,809
can how we can do that with the command

00:08:21,619 --> 00:08:34,209
line so we use the DM set up command

00:08:23,809 --> 00:08:38,810
line and you can see so this code or

00:08:34,209 --> 00:08:43,370
commands will result in the virtual

00:08:38,810 --> 00:08:47,480
volume so i will explain this in two

00:08:43,370 --> 00:08:52,250
separate slides to keep it simple so d1

00:08:47,480 --> 00:08:56,870
is that its size of dev sdb d1 d2 as

00:08:52,250 --> 00:09:01,130
that is the size of SD cd3 as that if

00:08:56,870 --> 00:09:09,589
the size of I skazhi 1d4 is for I skazhi

00:09:01,130 --> 00:09:18,199
to di as that is SD 3 + d 4 + dl as that

00:09:09,589 --> 00:09:24,439
is T 1 and D 2 so all of this size we

00:09:18,199 --> 00:09:28,850
get the size with block dev ok i miss DC

00:09:24,439 --> 00:09:33,139
so it's block dev get size and it's the

00:09:28,850 --> 00:09:40,000
size of the device in sectors and not

00:09:33,139 --> 00:09:43,540
megabyte or or bite its sectors and then

00:09:40,000 --> 00:09:47,779
we create the table so the table defined

00:09:43,540 --> 00:09:50,329
how the colonel will map the virtual

00:09:47,779 --> 00:09:55,760
block or a virtual block to a rare block

00:09:50,329 --> 00:10:00,290
so from the first block in the virtual

00:09:55,760 --> 00:10:05,059
disk or the first sector to the size of

00:10:00,290 --> 00:10:07,760
SD be in sector we have a linear mapping

00:10:05,059 --> 00:10:13,550
from SD be starting from the first

00:10:07,760 --> 00:10:16,970
sector so it's just like we have SD be

00:10:13,550 --> 00:10:23,540
first and the second line is we start

00:10:16,970 --> 00:10:28,699
from the size of SD be and we go to the

00:10:23,540 --> 00:10:32,509
size of of SDC and we we map from the

00:10:28,699 --> 00:10:36,230
first sector of of SDC and it's just

00:10:32,509 --> 00:10:41,209
like we have sdb and as DC and the

00:10:36,230 --> 00:10:48,100
second line is is a stupid mapping so so

00:10:41,209 --> 00:10:52,610
we have DL DL SZ so it's the size of the

00:10:48,100 --> 00:10:56,510
two first mapping we start at this

00:10:52,610 --> 00:11:00,030
sector and we map di as that is the

00:10:56,510 --> 00:11:05,430
some of the size of the 2i skazhi discs

00:11:00,030 --> 00:11:09,240
so we have a stupid stupid target so

00:11:05,430 --> 00:11:14,760
we'll specify the number of disk is two

00:11:09,240 --> 00:11:18,600
and size of a chunk is 64 sector the

00:11:14,760 --> 00:11:22,620
first and the first disc start from zero

00:11:18,600 --> 00:11:27,840
the second s start from zero so this

00:11:22,620 --> 00:11:33,660
will define the the virtual volume and

00:11:27,840 --> 00:11:42,600
we will have it's not exactly but we can

00:11:33,660 --> 00:11:46,740
say it's the same speed access speed so

00:11:42,600 --> 00:11:52,230
I think at this point every one and

00:11:46,740 --> 00:11:56,100
knows what's the device mapper and the

00:11:52,230 --> 00:11:59,280
second question is is device mapper

00:11:56,100 --> 00:12:03,300
capable of team provisioning and the

00:11:59,280 --> 00:12:07,589
answer is yes he's capable of Tim

00:12:03,300 --> 00:12:11,550
provisioning using by using the tin

00:12:07,589 --> 00:12:22,520
target is a module so it's a damn thing

00:12:11,550 --> 00:12:25,860
and the MTN target is is the target that

00:12:22,520 --> 00:12:30,420
when we use this target we can have thin

00:12:25,860 --> 00:12:34,400
provisioning so how it works so it

00:12:30,420 --> 00:12:43,820
defined pool and the pool it's like in

00:12:34,400 --> 00:12:49,260
lv m it's like a virtual virtual and

00:12:43,820 --> 00:12:52,050
it's like VG a virtual group so in the

00:12:49,260 --> 00:12:55,440
virtual group you you have physical

00:12:52,050 --> 00:12:57,420
extent and the lvm system will get the

00:12:55,440 --> 00:12:59,970
physical extent and create logical

00:12:57,420 --> 00:13:05,970
volumes so in the pool will use the pool

00:12:59,970 --> 00:13:09,209
and create 10 volumes inside the pole so

00:13:05,970 --> 00:13:14,279
the pool is the source of provisioning

00:13:09,209 --> 00:13:17,249
so we'll have this this this game so

00:13:14,279 --> 00:13:20,970
this is an example so we have the first

00:13:17,249 --> 00:13:23,970
volume it's we have linear mapping and a

00:13:20,970 --> 00:13:26,670
10 mapping so we will have linear

00:13:23,970 --> 00:13:31,079
mapping 10 gigabytes pre-allocated and

00:13:26,670 --> 00:13:34,439
20 gigabytes provision and tim provision

00:13:31,079 --> 00:13:40,499
and the second lv is all the Emperor

00:13:34,439 --> 00:13:44,069
vision and in the side of the pool or

00:13:40,499 --> 00:13:48,269
inside the pool will have blocks of lv 1

00:13:44,069 --> 00:13:53,189
and blocks of lv to see we have blocks

00:13:48,269 --> 00:13:57,619
in orange and blocks in blue so and the

00:13:53,189 --> 00:14:01,619
pool will allocate the blocks as we as

00:13:57,619 --> 00:14:07,350
we use the volume so when we write in

00:14:01,619 --> 00:14:14,480
the volume he will allocate blocks here

00:14:07,350 --> 00:14:18,149
we can see a problem it looked like the

00:14:14,480 --> 00:14:22,519
defragment to love Microsoft window see

00:14:18,149 --> 00:14:26,819
and it's the first problem we have

00:14:22,519 --> 00:14:35,160
fragmentation this is the first problem

00:14:26,819 --> 00:14:40,470
we have so and a pool can't be or has

00:14:35,160 --> 00:14:44,639
the size limit is 16 gigabytes so we can

00:14:40,470 --> 00:14:47,970
go for more but we can create a lot of

00:14:44,639 --> 00:14:52,769
pool can create for example 2 3 4 5

00:14:47,970 --> 00:14:55,850
temples no problem another problem is

00:14:52,769 --> 00:15:00,809
that the pool will use the world disk I

00:14:55,850 --> 00:15:04,579
mean if we use 16 gigabytes it will be

00:15:00,809 --> 00:15:09,029
all from for the pool I cannot use the

00:15:04,579 --> 00:15:15,829
60 gigabytes for a static volume static

00:15:09,029 --> 00:15:15,829
lv it can be used and

00:15:15,850 --> 00:15:27,910
what if the post Iran runs out of space

00:15:21,370 --> 00:15:32,889
a user space process it's actually you

00:15:27,910 --> 00:15:38,860
dev D will be notified and we can add

00:15:32,889 --> 00:15:45,959
rules too so we can grow the the growth

00:15:38,860 --> 00:15:50,199
the pool or do something else so let get

00:15:45,959 --> 00:15:53,850
let's get an example of the DMZ in so

00:15:50,199 --> 00:15:58,660
the first step is to create the pool

00:15:53,850 --> 00:16:01,089
it's this slide is is just to see what

00:15:58,660 --> 00:16:07,360
we have to do and it's quite irritable

00:16:01,089 --> 00:16:10,509
so I have to slide so to explain the the

00:16:07,360 --> 00:16:16,779
procedure so pool size is the size of

00:16:10,509 --> 00:16:24,430
the port here i will use dev sdb as the

00:16:16,779 --> 00:16:30,130
source of the pool XD size is the data

00:16:24,430 --> 00:16:33,819
block pool or physical extent size or

00:16:30,130 --> 00:16:37,000
data block size and there are in this

00:16:33,819 --> 00:16:41,829
example it's four megabytes the meta

00:16:37,000 --> 00:16:44,920
size is the size of the meta data so to

00:16:41,829 --> 00:16:49,649
store data where is this blog Muppet to

00:16:44,920 --> 00:16:54,850
wear and this book is not too early so

00:16:49,649 --> 00:16:58,269
the empty needs meta data so method is

00:16:54,850 --> 00:17:00,430
is calculated from this rule and you can

00:16:58,269 --> 00:17:05,620
find this rule in the kernel

00:17:00,430 --> 00:17:11,939
documentation so the meta data size in

00:17:05,620 --> 00:17:16,289
megabyte is this one plus two megabytes

00:17:11,939 --> 00:17:24,370
so we create the we create the metadata

00:17:16,289 --> 00:17:29,350
metadata pool and and next we create the

00:17:24,370 --> 00:17:33,160
pool itself so it starts from 0 to

00:17:29,350 --> 00:17:37,150
full size is the size of SD be it used

00:17:33,160 --> 00:17:40,330
the teen pool target and it will use dev

00:17:37,150 --> 00:17:47,320
volt group and empty pool as the meta

00:17:40,330 --> 00:17:51,640
data device dev sdb as the box store xt

00:17:47,320 --> 00:17:54,809
size is the size of data block and we

00:17:51,640 --> 00:18:00,309
have here the watermark so if we use

00:17:54,809 --> 00:18:05,289
more than eighty percent you dev will be

00:18:00,309 --> 00:18:11,200
notified see we can put hear anything

00:18:05,289 --> 00:18:20,110
else 0 can be more than 80 can be less

00:18:11,200 --> 00:18:24,429
so and then create the teen volume so

00:18:20,110 --> 00:18:29,080
actually damn teen handle what might be

00:18:24,429 --> 00:18:32,830
handled by a user space program so in

00:18:29,080 --> 00:18:37,690
the logic of device mapper it's in user

00:18:32,830 --> 00:18:42,490
space or we allocate blocks or we

00:18:37,690 --> 00:18:46,000
defined table in user space and not in

00:18:42,490 --> 00:18:49,240
the colonel will load the table we have

00:18:46,000 --> 00:18:53,230
defined into the kernel but we don't do

00:18:49,240 --> 00:19:01,720
that into the kernel and the emptying

00:18:53,230 --> 00:19:07,390
actually break this rule so and to

00:19:01,720 --> 00:19:10,450
create to create a thin volume we have

00:19:07,390 --> 00:19:13,809
to send a message to the colonel through

00:19:10,450 --> 00:19:18,580
the am set up so damn set up message dev

00:19:13,809 --> 00:19:22,510
mapper th pool it's our pool and create

00:19:18,580 --> 00:19:27,100
teen 0 and 0 is the idea of the teen

00:19:22,510 --> 00:19:35,669
volume and using the teen volume we will

00:19:27,100 --> 00:19:39,110
create a logical volume so the in size

00:19:35,669 --> 00:19:43,340
we have the teen size and

00:19:39,110 --> 00:19:47,690
in megabyte and we calculate the scene

00:19:43,340 --> 00:19:50,690
size in sectors so we have to create it

00:19:47,690 --> 00:19:54,650
with this this rule so we start from

00:19:50,690 --> 00:19:59,750
zero teen size and the target is thin

00:19:54,650 --> 00:20:06,470
and we will use the teen volume created

00:19:59,750 --> 00:20:09,770
in the th pool with ID 0 and at this

00:20:06,470 --> 00:20:22,460
point point we have a provisional

00:20:09,770 --> 00:20:27,020
provision volume with damp teen and and

00:20:22,460 --> 00:20:31,130
this volume will grow when we write on

00:20:27,020 --> 00:20:36,620
it to the rail sighs yeah and if I get

00:20:31,130 --> 00:20:40,780
back the rail size is HD Teen acid SZ

00:20:36,620 --> 00:20:40,780
it's the rail size

00:20:47,760 --> 00:20:55,240
yeah but when we have a lot of team

00:20:52,450 --> 00:21:00,010
provision provisional volume in the same

00:20:55,240 --> 00:21:02,500
pool it will be a mess like the the

00:21:00,010 --> 00:21:09,310
Microsoft file system see so it will be

00:21:02,500 --> 00:21:19,750
a mess and the performance will be very

00:21:09,310 --> 00:21:22,570
bad we can do snapshot with with Tim

00:21:19,750 --> 00:21:26,610
provisional volume if you we use

00:21:22,570 --> 00:21:29,860
directly the damn mop device mapper

00:21:26,610 --> 00:21:35,740
target it will be very bad for the

00:21:29,860 --> 00:21:38,950
performance but the developers had the

00:21:35,740 --> 00:21:41,730
capability directly for the pool so we

00:21:38,950 --> 00:21:45,070
can snapshot what we have in the pool

00:21:41,730 --> 00:21:51,790
sending a message that tell create

00:21:45,070 --> 00:21:56,770
snapshot it will create snapshot yeah so

00:21:51,790 --> 00:22:02,110
the DM teen is pretty complicated

00:21:56,770 --> 00:22:05,830
solution and it comes to resolve a lot

00:22:02,110 --> 00:22:09,880
of Rob problem and it brings a lot of

00:22:05,830 --> 00:22:16,800
problem so I have the idea to create

00:22:09,880 --> 00:22:25,420
something simple than than the damn

00:22:16,800 --> 00:22:33,100
thing so why if we consider the

00:22:25,420 --> 00:22:37,930
complexity of the MTN and the problem we

00:22:33,100 --> 00:22:43,920
have with this model the model it's not

00:22:37,930 --> 00:22:49,210
yet stable and to resolve this problem i

00:22:43,920 --> 00:22:54,270
had to i just to find a simple way to do

00:22:49,210 --> 00:22:56,320
that so not the complicated solution of

00:22:54,270 --> 00:23:01,360
you know

00:22:56,320 --> 00:23:06,700
damn damn teen something as simple as as

00:23:01,360 --> 00:23:10,330
the 0 target see we read and we get

00:23:06,700 --> 00:23:14,700
zeros okay we write that it will drop

00:23:10,330 --> 00:23:20,769
the right because we can it's always 0

00:23:14,700 --> 00:23:25,649
so after working hard to keep in a way

00:23:20,769 --> 00:23:28,269
complicated solution because at we human

00:23:25,649 --> 00:23:32,110
begins always by the complicated

00:23:28,269 --> 00:23:36,490
solutions so the solutions come to me

00:23:32,110 --> 00:23:42,639
and it's very simple I have just to

00:23:36,490 --> 00:23:46,029
signal a user space process when and out

00:23:42,639 --> 00:23:49,090
of allocated space io comes so if a

00:23:46,029 --> 00:23:51,879
process try to read out of space I have

00:23:49,090 --> 00:23:55,029
to send a signal to a process somewhere

00:23:51,879 --> 00:24:02,500
in the system and the the process will

00:23:55,029 --> 00:24:06,370
grow my volume so but I still have a

00:24:02,500 --> 00:24:10,409
problem the problem is if the process

00:24:06,370 --> 00:24:19,320
across try to do that I have an error

00:24:10,409 --> 00:24:22,299
and the the i/o will be dropped so after

00:24:19,320 --> 00:24:26,649
dissecting the colonel device code you

00:24:22,299 --> 00:24:31,480
know the code the kernel code it's not

00:24:26,649 --> 00:24:34,419
well documented and it's not at all you

00:24:31,480 --> 00:24:38,200
see it's not very documented so I found

00:24:34,419 --> 00:24:44,409
the wick you cap ability so if we return

00:24:38,200 --> 00:24:50,100
the value to in our in our callback

00:24:44,409 --> 00:24:50,100
function that handles the i/o the the

00:24:51,419 --> 00:25:06,029
the i/o will be renewed so I also found

00:24:58,779 --> 00:25:09,990
how to suspend suspend a device yeah and

00:25:06,029 --> 00:25:16,240
I got everything I need to make it

00:25:09,990 --> 00:25:20,610
to make it run so I will and this scheme

00:25:16,240 --> 00:25:26,340
will explain step by step how it will

00:25:20,610 --> 00:25:29,680
how the damn notify works so we have

00:25:26,340 --> 00:25:32,200
notified e as a process that receive

00:25:29,680 --> 00:25:38,380
just a simple signal a real-time signal

00:25:32,200 --> 00:25:44,290
i use the real-time signal as to keep

00:25:38,380 --> 00:25:47,350
the model simple and to keep it fast a

00:25:44,290 --> 00:25:51,850
real signal is faster than a tcp/ip

00:25:47,350 --> 00:25:56,980
connection or a queue or a shared memory

00:25:51,850 --> 00:26:05,470
or something else so when we we have an

00:25:56,980 --> 00:26:08,110
i/o to a DM notify method block so I'm

00:26:05,470 --> 00:26:14,800
up my land linear blocks for example and

00:26:08,110 --> 00:26:26,140
then I have a part with muppet true true

00:26:14,800 --> 00:26:29,710
notified target the colonel will so the

00:26:26,140 --> 00:26:34,840
colonel will accuse I oh you see a date

00:26:29,710 --> 00:26:40,360
in orange in the bi oq the basic irq

00:26:34,840 --> 00:26:45,520
what you use in device mapper and it

00:26:40,360 --> 00:26:51,520
will ask the device table which which

00:26:45,520 --> 00:26:53,410
target can handle this ayo so the AO

00:26:51,520 --> 00:26:57,910
will be handled by the Vice mapper and

00:26:53,410 --> 00:26:59,890
the Vice mapper will will be the day the

00:26:57,910 --> 00:27:06,100
call back of the device matter will be

00:26:59,890 --> 00:27:10,960
executed and the Vice mapa will do these

00:27:06,100 --> 00:27:13,960
three simple tasks it will suspend the

00:27:10,960 --> 00:27:20,440
device send the real-time signal to

00:27:13,960 --> 00:27:25,410
notify d & r eq the i/o so

00:27:20,440 --> 00:27:32,310
we'll have the IRA queued in blue so

00:27:25,410 --> 00:27:37,570
sorry you know we will notify first day

00:27:32,310 --> 00:27:42,460
they the process we can do we can't we

00:27:37,570 --> 00:27:45,040
can do it Riccio and notify because the

00:27:42,460 --> 00:27:50,470
curriculum will be done with by the

00:27:45,040 --> 00:27:55,840
colonel when you return Derek you value

00:27:50,470 --> 00:28:00,430
so we're q with signal we send the

00:27:55,840 --> 00:28:05,080
signal we're acutely the IO and the

00:28:00,430 --> 00:28:10,900
notify d will wait for example one

00:28:05,080 --> 00:28:15,670
millisecond because because as I said we

00:28:10,900 --> 00:28:23,190
can't Rick you before sending the signal

00:28:15,670 --> 00:28:28,890
so it have to to wait and then it will

00:28:23,190 --> 00:28:31,930
fork something for example a script or a

00:28:28,890 --> 00:28:35,890
program that will use for example damn

00:28:31,930 --> 00:28:39,330
set up to update the table and resume

00:28:35,890 --> 00:28:45,820
the device so update the table main grow

00:28:39,330 --> 00:28:48,850
grow the device so damn setup will

00:28:45,820 --> 00:28:59,280
update the table resume the device and

00:28:48,850 --> 00:29:04,480
the i/o will be resumed for the for the

00:28:59,280 --> 00:29:07,440
inside the colonel but the the i/o is in

00:29:04,480 --> 00:29:11,830
the last of the queue so we have to wait

00:29:07,440 --> 00:29:14,890
until it becomes in the head of the

00:29:11,830 --> 00:29:18,190
queue so the M linear for example while

00:29:14,890 --> 00:29:22,120
when I have grown its linear so the m9

00:29:18,190 --> 00:29:27,010
winner with will handle this I oh and

00:29:22,120 --> 00:29:31,710
the process will resume his execution

00:29:27,010 --> 00:29:31,710
since the i/o is done

00:29:32,580 --> 00:29:45,690
yeah and it will be the same if we try

00:29:37,630 --> 00:29:51,580
to do right out of space etc so if we

00:29:45,690 --> 00:29:55,960
let's get an example so this is a simple

00:29:51,580 --> 00:30:01,630
example where I have a volume of for

00:29:55,960 --> 00:30:07,950
example 100 mega mega byte and in the

00:30:01,630 --> 00:30:11,559
last I will put 1 megabyte of modify so

00:30:07,950 --> 00:30:15,270
when the process will try to write and

00:30:11,559 --> 00:30:18,460
then modify the volume will grow its

00:30:15,270 --> 00:30:23,530
time it will grow and each time i will

00:30:18,460 --> 00:30:27,370
put the notify at the end i will grow by

00:30:23,530 --> 00:30:29,800
the size of modify now I can't do dude I

00:30:27,370 --> 00:30:32,679
can't do what whatever whatever I want

00:30:29,800 --> 00:30:37,960
because it's in user space I can for

00:30:32,679 --> 00:30:40,390
example if my host which hosts a vm ran

00:30:37,960 --> 00:30:43,360
out of space i can be great the vm i

00:30:40,390 --> 00:30:46,470
can't do a lot of things because it's in

00:30:43,360 --> 00:30:51,090
your in user space i can for example

00:30:46,470 --> 00:30:56,770
implemented garbage collector which runs

00:30:51,090 --> 00:31:03,059
and try to keep everything not

00:30:56,770 --> 00:31:07,929
fragmented like the microsoft thing so i

00:31:03,059 --> 00:31:12,330
have three or four scripts so the first

00:31:07,929 --> 00:31:16,870
is test grade so it will just create the

00:31:12,330 --> 00:31:22,420
volume and it will be you see from zero

00:31:16,870 --> 00:31:25,630
to base size and it will be mapped to

00:31:22,420 --> 00:31:30,160
zero so it's just an example a simple

00:31:25,630 --> 00:31:35,410
example and from the this size 2 1

00:31:30,160 --> 00:31:38,320
megabyte and i will map this one to

00:31:35,410 --> 00:31:43,590
notify i will give him the PID of the

00:31:38,320 --> 00:31:43,590
notify d since i will use a signal

00:31:44,799 --> 00:31:52,280
the test girl will grow so it will

00:31:47,990 --> 00:31:57,950
replace you see in the third line set as

00:31:52,280 --> 00:32:01,789
/ modify / 0 / so the S is substitute

00:31:57,950 --> 00:32:04,669
and it will replace every notified by

00:32:01,789 --> 00:32:09,250
zero so the last modified I have only

00:32:04,669 --> 00:32:13,970
one notify that not if I will be 0 and

00:32:09,250 --> 00:32:17,630
the Eco so the second echo will inject

00:32:13,970 --> 00:32:21,890
or add another modify at the end of the

00:32:17,630 --> 00:32:25,820
table so I have my last table with the

00:32:21,890 --> 00:32:31,940
notify change it to 0 and I have added

00:32:25,820 --> 00:32:37,130
and modify at the end so I reload the

00:32:31,940 --> 00:32:40,520
map and resume the device so because the

00:32:37,130 --> 00:32:46,429
the kernel module did the unmodified

00:32:40,520 --> 00:32:53,450
suspended they develop and test and is

00:32:46,429 --> 00:32:58,809
when we we are at the max size we can't

00:32:53,450 --> 00:33:02,750
grow more than that the device wheel

00:32:58,809 --> 00:33:07,130
will stop at this size so it is the

00:33:02,750 --> 00:33:12,230
final size we can grow more than more

00:33:07,130 --> 00:33:16,190
than dead sighs and the master script is

00:33:12,230 --> 00:33:22,940
the script wheat which will be called by

00:33:16,190 --> 00:33:27,200
notified d and it will simply grow if if

00:33:22,940 --> 00:33:31,280
if the volume is less than the mugs and

00:33:27,200 --> 00:33:41,360
it will stop the growing if the volume

00:33:31,280 --> 00:33:45,280
is more or exceed the max size so let's

00:33:41,360 --> 00:33:45,280
get a demonstration so

00:33:48,450 --> 00:34:14,830
okay okay so oops I have to see so we

00:34:11,889 --> 00:34:20,710
have first to create the volume so it's

00:34:14,830 --> 00:34:26,350
very simple so test create called test

00:34:20,710 --> 00:34:30,580
one and for example it's this is the

00:34:26,350 --> 00:34:34,870
size in megabytes and I have to give it

00:34:30,580 --> 00:34:40,360
the PID of the notified d so here comes

00:34:34,870 --> 00:34:46,990
the PID so to have the big idea I have

00:34:40,360 --> 00:34:57,419
to start the notified d so they are

00:34:46,990 --> 00:34:57,419
modified II started and TS grab so

00:35:06,970 --> 00:35:21,290
so here the PID is of course this idea

00:35:17,360 --> 00:35:26,030
would be checked by the the kernel

00:35:21,290 --> 00:35:30,860
module so it works and now I have them

00:35:26,030 --> 00:35:40,430
set up table just one now I have zero

00:35:30,860 --> 00:35:44,600
and notify c0 notify ok let let's have a

00:35:40,430 --> 00:35:51,200
watch on this on this one so with a

00:35:44,600 --> 00:35:59,860
watch hair ok so here I have a watch see

00:35:51,200 --> 00:36:04,760
as my test it's 0 notify let's have a

00:35:59,860 --> 00:36:13,910
tail f here because my scripts use the

00:36:04,760 --> 00:36:19,510
logger command to log what is going on

00:36:13,910 --> 00:36:23,060
so we'll write just zeros in the bully

00:36:19,510 --> 00:36:26,080
so the D D command D D input file output

00:36:23,060 --> 00:36:26,080
file block size

00:36:37,440 --> 00:36:49,040
so see here I have a lot of signals and

00:36:42,380 --> 00:36:55,579
go there you see 000 it's expanded see

00:36:49,040 --> 00:37:00,540
the two just one like this see I add

00:36:55,579 --> 00:37:04,410
00000 each time I have arrived in this

00:37:00,540 --> 00:37:09,510
it this zone and one it's finished I

00:37:04,410 --> 00:37:14,990
will just add zero and not notify so

00:37:09,510 --> 00:37:19,170
each time i will have the zero added see

00:37:14,990 --> 00:37:26,750
no this is a simple example and you see

00:37:19,170 --> 00:37:32,490
when I i rh the max is it's a 500

00:37:26,750 --> 00:37:40,560
megabyte i have only 0 and the DD here

00:37:32,490 --> 00:37:45,720
stops see I'm it's done the table is

00:37:40,560 --> 00:37:51,119
created in the user space and the script

00:37:45,720 --> 00:37:56,099
I keep the script as simple as I could

00:37:51,119 --> 00:37:58,470
for example but in a real escape we can

00:37:56,099 --> 00:38:02,790
merge you see we can merge the zero in

00:37:58,470 --> 00:38:05,780
10 and so you can do or make an optimist

00:38:02,790 --> 00:38:13,680
table we can try to do it without

00:38:05,780 --> 00:38:17,280
fragmentation without so so you see we

00:38:13,680 --> 00:38:19,109
don't have to do this thing in the

00:38:17,280 --> 00:38:25,079
kernel and have something very

00:38:19,109 --> 00:38:31,369
complicated like the damn damn thing we

00:38:25,079 --> 00:38:35,880
can have a simple snapshot we can have

00:38:31,369 --> 00:38:38,910
for example can move if the vm grow out

00:38:35,880 --> 00:38:41,970
of the space we have in the horse we can

00:38:38,910 --> 00:38:46,859
move it move it in somewhere we have

00:38:41,970 --> 00:38:49,160
place in the cluster see it will be live

00:38:46,859 --> 00:38:52,280
storage migration

00:38:49,160 --> 00:38:58,220
and it will migrate in other another

00:38:52,280 --> 00:39:02,960
host we can for example charge customers

00:38:58,220 --> 00:39:06,530
for space day they really use for

00:39:02,960 --> 00:39:10,819
example I have a cloud and people will

00:39:06,530 --> 00:39:14,420
buy VMS with with for example unlimited

00:39:10,819 --> 00:39:17,869
space or one terabyte of space but if

00:39:14,420 --> 00:39:20,869
they use only 10 gigabytes they will pay

00:39:17,869 --> 00:39:24,200
only for 10 gigabytes and if they use

00:39:20,869 --> 00:39:27,980
more than we they will pay for more and

00:39:24,200 --> 00:39:31,490
so on the team provisioning is not

00:39:27,980 --> 00:39:37,039
implemented like this this is a simple

00:39:31,490 --> 00:39:39,589
example there is many ways to do it the

00:39:37,039 --> 00:39:43,730
best way to do that is due to have a

00:39:39,589 --> 00:39:46,160
snapshot and grow the co device see in

00:39:43,730 --> 00:39:49,000
the co device we put and notify at the

00:39:46,160 --> 00:39:53,000
end and when the kernel itself try to

00:39:49,000 --> 00:39:57,020
write into the co device into the end of

00:39:53,000 --> 00:40:06,200
the co device the co device will be will

00:39:57,020 --> 00:40:10,960
be a growth by a user space process for

00:40:06,200 --> 00:40:20,960
example script or something like that so

00:40:10,960 --> 00:40:26,720
so this is the simple ID I had and it

00:40:20,960 --> 00:40:31,640
wasn't so so easy because do something

00:40:26,720 --> 00:40:35,599
easy is very complicated so this ID we

00:40:31,640 --> 00:40:39,859
use it in project week we have it called

00:40:35,599 --> 00:40:45,079
if key and it's a virtualization

00:40:39,859 --> 00:40:50,839
solution like HPV or proxmox we have a

00:40:45,079 --> 00:40:53,930
lot of work in it so it can be expected

00:40:50,839 --> 00:40:56,599
in a month or two I don't really now

00:40:53,930 --> 00:41:02,040
because that there is a lot of work in

00:40:56,599 --> 00:41:05,290
it and it works without charge storage

00:41:02,040 --> 00:41:11,590
VMs one comes out of space there

00:41:05,290 --> 00:41:17,890
migrated life migrated and snapshot are

00:41:11,590 --> 00:41:25,210
very really a very yeah we do snapshot

00:41:17,890 --> 00:41:32,470
in a very short time much like what we

00:41:25,210 --> 00:41:37,300
have in red heart or or proxmox and yeah

00:41:32,470 --> 00:41:50,370
if you have questions yeah just access

00:41:37,300 --> 00:41:50,370
them yeah slowly if possible yeah yeah

00:41:50,640 --> 00:42:06,330
yeah how fast when you you try to use

00:41:58,660 --> 00:42:13,090
the damn notify you have to you have to

00:42:06,330 --> 00:42:15,850
now the size of the each grow you see H

00:42:13,090 --> 00:42:20,980
grow that you have to know that it

00:42:15,850 --> 00:42:25,930
depends on what you intended to do with

00:42:20,980 --> 00:42:29,140
the storage so it's the same with the

00:42:25,930 --> 00:42:34,050
empty and you have to know what which

00:42:29,140 --> 00:42:37,900
the size will use for the data blocks so

00:42:34,050 --> 00:42:42,010
yeah if you use big blocks if you use

00:42:37,900 --> 00:42:45,940
you have for example a vm that grow the

00:42:42,010 --> 00:42:51,220
very fast the storage grow very fast you

00:42:45,940 --> 00:42:56,080
can just use a growth size for example 1

00:42:51,220 --> 00:42:59,680
1 gigabyte so so the notification will

00:42:56,080 --> 00:43:03,120
be h 1 gigabyte so you will have a very

00:42:59,680 --> 00:43:09,780
good performance and no fragmentation

00:43:03,120 --> 00:43:09,780
see ya this answer your question

00:43:18,640 --> 00:43:27,849
yeah if if you use the the same size

00:43:24,519 --> 00:43:35,900
yeah I didn't have enough time to

00:43:27,849 --> 00:43:39,079
benchmark that but because because what

00:43:35,900 --> 00:43:43,789
you have said what up showed this is on

00:43:39,079 --> 00:43:48,529
if key and I didn't I didn't compile the

00:43:43,789 --> 00:43:53,809
teen and a kernel so yeah I've tried to

00:43:48,529 --> 00:43:58,839
do it yesterday but I I didn't have

00:43:53,809 --> 00:44:03,650
enough time to compile and you see so

00:43:58,839 --> 00:44:06,950
but features are things you can do it

00:44:03,650 --> 00:44:10,009
there modify our can do a lot of things

00:44:06,950 --> 00:44:14,779
not like the damn thing and damn thing

00:44:10,009 --> 00:44:17,779
is limited in 60 jigar gigabytes so I

00:44:14,779 --> 00:44:23,299
think it's a better solution it's

00:44:17,779 --> 00:44:26,049
simpler and you know you can you you can

00:44:23,299 --> 00:44:29,809
do something complicated or something

00:44:26,049 --> 00:44:32,059
optimized in the allocation so when the

00:44:29,809 --> 00:44:35,749
your process is modified it can it can

00:44:32,059 --> 00:44:40,059
do something very complicated to to have

00:44:35,749 --> 00:44:44,829
to keep everything not fragmented

00:44:40,059 --> 00:44:44,829
fragmented and see ya

00:44:46,480 --> 00:44:55,220
yeah it's a kernel model yeah yeah you

00:44:49,160 --> 00:45:02,720
have to load it so no then then modify

00:44:55,220 --> 00:45:05,360
is a criminal model in the mainstream of

00:45:02,720 --> 00:45:09,260
the colonel no no no it's something I've

00:45:05,360 --> 00:45:12,560
developed and yeah you'll find it soon

00:45:09,260 --> 00:45:15,110
in the FG dot org website you can

00:45:12,560 --> 00:45:17,410
download it download the F key I've told

00:45:15,110 --> 00:45:21,410
you it's a lot of work so we have

00:45:17,410 --> 00:45:29,090
perhaps one more to impress to don't

00:45:21,410 --> 00:45:31,790
know and yes and it's system we we built

00:45:29,090 --> 00:45:37,420
from scratch so it's not far from you

00:45:31,790 --> 00:45:37,420
know proxmox or red hot yeah

00:46:32,770 --> 00:46:37,039
your customers rely on your website or

00:46:35,539 --> 00:46:39,440
application if it's slower

00:46:37,039 --> 00:46:42,380
non-responsive it infuriates your users

00:46:39,440 --> 00:46:44,180
and costs you money keeping your

00:46:42,380 --> 00:46:47,700
business critical systems humming along

00:46:44,180 --> 00:46:50,010
requires insight into what they're doing

00:46:47,700 --> 00:46:51,960
your system metrics tells stories

00:46:50,010 --> 00:46:53,970
stories that can reveal performance

00:46:51,960 --> 00:46:56,310
bottlenecks resource limitations and

00:46:53,970 --> 00:46:57,869
other problems but how do you keep an

00:46:56,310 --> 00:47:00,510
eye on all of your systems performance

00:46:57,869 --> 00:47:03,570
metrics in real-time and record this

00:47:00,510 --> 00:47:05,310
data for later analysis enter longview

00:47:03,570 --> 00:47:07,320
the new way to see what's really going

00:47:05,310 --> 00:47:09,480
on under the hood the long view

00:47:07,320 --> 00:47:11,550
dashboard lets you visualize the status

00:47:09,480 --> 00:47:14,010
of all your systems providing you with a

00:47:11,550 --> 00:47:17,369
bird's-eye view of your entire fleet you

00:47:14,010 --> 00:47:19,950
can sort by cpu memory swap processes

00:47:17,369 --> 00:47:21,720
load and network usage click a specific

00:47:19,950 --> 00:47:24,119
system to access its individual

00:47:21,720 --> 00:47:26,630
dashboard then click and drag to zoom in

00:47:24,119 --> 00:47:29,040
on chokepoints and get more detail

00:47:26,630 --> 00:47:30,720
comprehensive network data including

00:47:29,040 --> 00:47:33,030
inbound and outbound traffic is

00:47:30,720 --> 00:47:34,589
available on the network tab and disk

00:47:33,030 --> 00:47:36,510
rights and free space on the disk

00:47:34,589 --> 00:47:39,359
stabbed while the process Explorer

00:47:36,510 --> 00:47:41,880
displays usage statistics for individual

00:47:39,359 --> 00:47:44,070
processes the system info tab shows

00:47:41,880 --> 00:47:46,290
listening services active connections

00:47:44,070 --> 00:47:48,420
and available updates adding long view

00:47:46,290 --> 00:47:50,130
to a system is easy just click the

00:47:48,420 --> 00:47:52,260
button copy the one line installation

00:47:50,130 --> 00:47:54,720
command then run the command on your

00:47:52,260 --> 00:47:56,430
linux system to complete the process the

00:47:54,720 --> 00:47:58,619
agent will begin collecting data and

00:47:56,430 --> 00:48:00,460
sending it to longview then the graphs

00:47:58,619 --> 00:48:03,010
start rolling

00:48:00,460 --> 00:48:05,380
use longview to gain visibility into

00:48:03,010 --> 00:48:09,119
your servers so when your website or app

00:48:05,380 --> 00:48:09,119
heats up it stays up

00:48:12,289 --> 00:48:17,099
when we created asterisk over a decade

00:48:14,999 --> 00:48:19,319
ago we could not have imagined that

00:48:17,099 --> 00:48:21,539
asterisk would not only become the most

00:48:19,319 --> 00:48:23,670
widely adopted open source communication

00:48:21,539 --> 00:48:25,710
software on the planet but that it would

00:48:23,670 --> 00:48:28,230
impact the entire industry in the way

00:48:25,710 --> 00:48:30,210
that it has today asterisk has found its

00:48:28,230 --> 00:48:32,819
way in the more than 170 countries and

00:48:30,210 --> 00:48:34,799
virtually every fortune 1000 company the

00:48:32,819 --> 00:48:36,900
success of asterisk has enabled a

00:48:34,799 --> 00:48:38,279
transition of power from the hands of

00:48:36,900 --> 00:48:40,559
the traditional proprietary phone

00:48:38,279 --> 00:48:42,960
vendors into the hands of the users and

00:48:40,559 --> 00:48:45,029
administrators of phone systems using

00:48:42,960 --> 00:48:46,680
this power our customers have traded all

00:48:45,029 --> 00:48:48,749
sorts of business changing applications

00:48:46,680 --> 00:48:50,549
from small office phone systems to

00:48:48,749 --> 00:48:52,680
mission-critical call centers to

00:48:50,549 --> 00:48:54,480
international carrier networks in fact

00:48:52,680 --> 00:48:55,950
there's even an entire country those

00:48:54,480 --> 00:48:58,410
communications infrastructure runs on

00:48:55,950 --> 00:49:00,329
esters the gym has always been about

00:48:58,410 --> 00:49:02,039
creating technology that expands

00:49:00,329 --> 00:49:04,230
communications capabilities in ways that

00:49:02,039 --> 00:49:05,430
we could never have imagined and that's

00:49:04,230 --> 00:49:08,160
part of what's game-changing about

00:49:05,430 --> 00:49:10,499
Digium today we're doing it again this

00:49:08,160 --> 00:49:12,599
time by introducing a new family of HD

00:49:10,499 --> 00:49:14,730
IP phones that extends control of the

00:49:12,599 --> 00:49:16,470
user all the way to the desktop the

00:49:14,730 --> 00:49:18,180
launch of these new products represents

00:49:16,470 --> 00:49:20,160
the next phase indigenous history of

00:49:18,180 --> 00:49:22,680
innovation these are the first and only

00:49:20,160 --> 00:49:24,029
IP phones designed to fully leverage the

00:49:22,680 --> 00:49:25,710
power of esther's when we first

00:49:24,029 --> 00:49:27,359
discussed our expectations for building

00:49:25,710 --> 00:49:29,970
a family of phones for use with asterisk

00:49:27,359 --> 00:49:31,739
our requirements were pretty simple we

00:49:29,970 --> 00:49:33,509
asked the team to build the phones such

00:49:31,739 --> 00:49:35,700
that they were easy to install integrate

00:49:33,509 --> 00:49:37,559
provision and use I think you'll soon

00:49:35,700 --> 00:49:40,109
agree our engineers have delivered on

00:49:37,559 --> 00:49:41,759
that goal user feedback is validating

00:49:40,109 --> 00:49:43,859
that when it comes to operation with

00:49:41,759 --> 00:49:46,289
astro space systems including our own

00:49:43,859 --> 00:49:48,869
Switchvox based product these are the

00:49:46,289 --> 00:49:50,160
easiest to use best integrated most

00:49:48,869 --> 00:49:52,769
interoperable products on the market

00:49:50,160 --> 00:49:54,739
today the Digium family of phones will

00:49:52,769 --> 00:49:56,849
initially include three IP des hommes

00:49:54,739 --> 00:49:58,739
uniquely designed to complement any

00:49:56,849 --> 00:50:00,630
asterisks or Switchvox based solution

00:49:58,739 --> 00:50:03,299
these phones are different for a number

00:50:00,630 --> 00:50:05,940
of reasons first there is clue sively

00:50:03,299 --> 00:50:07,380
designed for use with asterisks secondly

00:50:05,940 --> 00:50:08,989
we've made it really easy to

00:50:07,380 --> 00:50:11,369
autodiscover and provision the phones

00:50:08,989 --> 00:50:13,049
next we've made it easy for the phones

00:50:11,369 --> 00:50:15,010
to access information inside of

00:50:13,049 --> 00:50:17,010
asterisks allowing tight coupling

00:50:15,010 --> 00:50:18,970
between an application and the phone

00:50:17,010 --> 00:50:21,130
additionally we've created an

00:50:18,970 --> 00:50:23,260
applications engine that allows users

00:50:21,130 --> 00:50:26,500
and developers to create and run their

00:50:23,260 --> 00:50:28,270
own apps on the phone and finally we've

00:50:26,500 --> 00:50:30,220
done all of this at a very compelling

00:50:28,270 --> 00:50:31,900
price point at digium we're always

00:50:30,220 --> 00:50:34,000
thinking of ways to give our customers

00:50:31,900 --> 00:50:36,520
the best value in business phone systems

00:50:34,000 --> 00:50:38,110
and also give them the power to create

00:50:36,520 --> 00:50:40,270
their own solutions or any

00:50:38,110 --> 00:50:42,010
communications challenge will continue

00:50:40,270 --> 00:50:43,450
to push the boundaries not only to make

00:50:42,010 --> 00:50:45,490
Astra's cooler bastard more

00:50:43,450 --> 00:50:47,230
technologically feature-rich but to make

00:50:45,490 --> 00:50:49,750
asterisk and communications even easier

00:50:47,230 --> 00:50:53,280
and together we'll change the way the

00:50:49,750 --> 00:50:53,280
world communicates again

00:51:03,680 --> 00:51:10,500
how's that sigh every way this is the

00:51:07,290 --> 00:51:12,660
way to better utilize all your resources

00:51:10,500 --> 00:51:16,110
and it makes managing all your resources

00:51:12,660 --> 00:51:19,970
pretty easy all of the innovation is

00:51:16,110 --> 00:51:23,430
happening in open source the

00:51:19,970 --> 00:51:25,290
collaborative nature and of the you know

00:51:23,430 --> 00:51:27,390
of the community and the speed at which

00:51:25,290 --> 00:51:29,369
these are these you know these these

00:51:27,390 --> 00:51:31,680
deficiencies these bugs are getting

00:51:29,369 --> 00:51:34,530
discovered and then fixed is it like

00:51:31,680 --> 00:51:37,530
that really shows the power of the of

00:51:34,530 --> 00:51:39,980
the open source community it is global

00:51:37,530 --> 00:51:43,530
and it's definitely because of the users

00:51:39,980 --> 00:51:49,500
community people are extremely friendly

00:51:43,530 --> 00:51:51,210
and always ready to help if you go on

00:51:49,500 --> 00:51:53,369
tire see any day you'll see these guys

00:51:51,210 --> 00:51:56,070
helping each other out and they're all

00:51:53,369 --> 00:51:57,750
doing it like in a selfless manner the

00:51:56,070 --> 00:52:00,770
product is transparent for everyone

00:51:57,750 --> 00:52:03,960
everyone can look at the code base

00:52:00,770 --> 00:52:06,170
everyone can see how CloudStack is being

00:52:03,960 --> 00:52:11,700
built nothing nothing is proprietary

00:52:06,170 --> 00:52:14,280
everything is open in many ways it's

00:52:11,700 --> 00:52:18,780
absolutely vital to the the unborn

00:52:14,280 --> 00:52:22,980
health plan stack the most exciting

00:52:18,780 --> 00:52:25,819
event in recent memory for me was our

00:52:22,980 --> 00:52:28,459
first developer boot camp

00:52:25,819 --> 00:52:31,099
and our call gave people I gave you two

00:52:28,459 --> 00:52:35,059
weeks notice to come attend I was

00:52:31,099 --> 00:52:39,229
expecting 25 or 30 people so we ended up

00:52:35,059 --> 00:52:42,079
with 87 people and had to go get more

00:52:39,229 --> 00:52:44,599
chairs in the room twice everything

00:52:42,079 --> 00:52:47,930
within cloud computing is commodity and

00:52:44,599 --> 00:52:50,930
is open source and so I don't think that

00:52:47,930 --> 00:52:52,670
you will you'll see anywhere where open

00:52:50,930 --> 00:52:55,699
source is not pervasive in cloud

00:52:52,670 --> 00:52:58,249
computing and so i think it's i think

00:52:55,699 --> 00:52:59,779
it's an assumption i think when you talk

00:52:58,249 --> 00:53:00,890
about cloud computing you're really

00:52:59,779 --> 00:53:06,440
talking about open source cloud

00:53:00,890 --> 00:53:09,469
computing cloud sac is a robust solution

00:53:06,440 --> 00:53:11,630
for large deployments you'll have dozens

00:53:09,469 --> 00:53:15,920
of data centers and thousands of servers

00:53:11,630 --> 00:53:18,559
in each data centers these hardware is

00:53:15,920 --> 00:53:22,069
going to fail and CloudStack is designed

00:53:18,559 --> 00:53:24,769
to handle number one that mass scale

00:53:22,069 --> 00:53:27,920
number two it's designed to handle the

00:53:24,769 --> 00:53:30,469
failure that inevitably happens in large

00:53:27,920 --> 00:53:34,009
deployments started working on pop

00:53:30,469 --> 00:53:37,369
attack over four years ago and it was

00:53:34,009 --> 00:53:40,039
the original set of people working on it

00:53:37,369 --> 00:53:44,150
had a background of delivering software

00:53:40,039 --> 00:53:48,380
telcos and service providers lots of QA

00:53:44,150 --> 00:53:52,009
lots of users actually using it high

00:53:48,380 --> 00:53:55,069
availability is the key feature multiple

00:53:52,009 --> 00:53:57,109
hypervisors support different network

00:53:55,069 --> 00:53:59,779
models you can pick up whatever suits

00:53:57,109 --> 00:54:02,029
you better while staff management server

00:53:59,779 --> 00:54:05,719
can be deployed in different physical

00:54:02,029 --> 00:54:07,369
machines it definitely has a huge

00:54:05,719 --> 00:54:12,380
footprint it's being deployed everywhere

00:54:07,369 --> 00:54:14,959
there's a major movie studio that they

00:54:12,380 --> 00:54:18,140
were using cloudstack they were using it

00:54:14,959 --> 00:54:20,239
to transcode video and i thought that

00:54:18,140 --> 00:54:21,890
was terribly fascinating what i found

00:54:20,239 --> 00:54:25,160
more fascinating is what they did during

00:54:21,890 --> 00:54:27,920
lunch where they would spin up you know

00:54:25,160 --> 00:54:29,299
50 or 60 game servers then as soon as

00:54:27,920 --> 00:54:30,840
lunch was over they would destroy all

00:54:29,299 --> 00:54:34,860
the instances and could back

00:54:30,840 --> 00:54:36,270
doing real work CloudStack is vast it

00:54:34,860 --> 00:54:37,800
touches so many different aspects and

00:54:36,270 --> 00:54:40,020
there's no one person that's kind of

00:54:37,800 --> 00:54:43,500
like a master of all those realms I

00:54:40,020 --> 00:54:46,170
think clouds stack as a project is going

00:54:43,500 --> 00:54:49,970
to be one of the leaders simply because

00:54:46,170 --> 00:54:56,430
it's some of the most feature fallen and

00:54:49,970 --> 00:54:59,870
and robust platforms out they were out

00:54:56,430 --> 00:54:59,870
on senior living through the clouds dag

00:55:12,750 --> 00:55:17,799
most enterprises today realize that

00:55:15,520 --> 00:55:19,450
usernames and passwords alone aren't

00:55:17,799 --> 00:55:21,819
enough to keep their networks saved from

00:55:19,450 --> 00:55:23,890
unauthorized intrusions that's my

00:55:21,819 --> 00:55:25,930
two-factor authentication has gotten so

00:55:23,890 --> 00:55:28,059
popular lately that adds that extra

00:55:25,930 --> 00:55:30,730
layer of protection enterprise networks

00:55:28,059 --> 00:55:32,500
need to stay safe but what you may not

00:55:30,730 --> 00:55:34,690
know is that some two-factor

00:55:32,500 --> 00:55:36,910
authentication solutions they're better

00:55:34,690 --> 00:55:39,940
than others like two-factor strong

00:55:36,910 --> 00:55:42,220
authentication with wicked wicked goes

00:55:39,940 --> 00:55:44,170
beyond other authentication systems by

00:55:42,220 --> 00:55:47,260
being less expensive easier to implement

00:55:44,170 --> 00:55:49,720
and easier to use giving software-based

00:55:47,260 --> 00:55:52,599
token clients built to run on all major

00:55:49,720 --> 00:55:55,170
devices and OSS including iOS and

00:55:52,599 --> 00:55:57,520
Android these tokens utilize a

00:55:55,170 --> 00:55:59,920
public/private key combination that's

00:55:57,520 --> 00:56:01,869
generated on device so there aren't any

00:55:59,920 --> 00:56:04,390
shared secrets flying around for

00:56:01,869 --> 00:56:07,240
attackers to hijack or which require any

00:56:04,390 --> 00:56:09,099
special handling instead all keys are

00:56:07,240 --> 00:56:11,589
kept secure and private between the

00:56:09,099 --> 00:56:13,780
requesting token and your server which

00:56:11,589 --> 00:56:15,390
you control aim house making it the most

00:56:13,780 --> 00:56:18,069
secure way possible to perform

00:56:15,390 --> 00:56:20,859
authentication encryption and with an

00:56:18,069 --> 00:56:23,650
extensive flexible API and support for

00:56:20,859 --> 00:56:25,630
protocols like a lab and radius wicket

00:56:23,650 --> 00:56:28,089
works with any enterprise network

00:56:25,630 --> 00:56:30,760
architecture to protect the IT systems

00:56:28,089 --> 00:56:33,250
vital to your enterprise download your

00:56:30,760 --> 00:56:34,750
wicked free trial today regardless of

00:56:33,250 --> 00:56:36,819
whether you're considering two-factor

00:56:34,750 --> 00:56:38,589
authentication for the first time we're

00:56:36,819 --> 00:56:40,430
just ready to ditch your existing

00:56:38,589 --> 00:56:43,010
expensive key

00:56:40,430 --> 00:56:48,250
we can help with easy to implement easy

00:56:43,010 --> 00:56:48,250

YouTube URL: https://www.youtube.com/watch?v=6zOJ_QXCy2w


