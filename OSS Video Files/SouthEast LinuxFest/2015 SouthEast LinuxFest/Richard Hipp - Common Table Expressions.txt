Title: Richard Hipp - Common Table Expressions
Publication date: 2017-01-25
Playlist: 2015 SouthEast LinuxFest
Description: 
	
Captions: 
	00:10:46,060 --> 00:10:50,020
okay that's good to know SQLite next no

00:10:49,180 --> 00:10:52,050
distinction whatsoever

00:10:50,020 --> 00:10:55,900
there's no optimization hence there is

00:10:52,050 --> 00:10:59,910
optimize it so yeah toes so what Ruth is

00:10:55,900 --> 00:11:02,350
saying is that with Postgres apparently

00:10:59,910 --> 00:11:05,590
you know this is lower expression this

00:11:02,350 --> 00:11:08,280
this right here just select because it's

00:11:05,590 --> 00:11:10,480
a sub query there might be some

00:11:08,280 --> 00:11:12,310
transformations to bring that so query

00:11:10,480 --> 00:11:14,050
up and make it a part of a joint at a

00:11:12,310 --> 00:11:15,850
higher level query which could possibly

00:11:14,050 --> 00:11:18,880
run faster and you're saying in Postgres

00:11:15,850 --> 00:11:20,920
world it deliberately does not do that

00:11:18,880 --> 00:11:23,850
because it considers this common table

00:11:20,920 --> 00:11:45,670
expression to be a intz optimizations

00:11:23,850 --> 00:11:49,630
we've got a question behind you what's

00:11:45,670 --> 00:11:51,640
the difference well well there this all

00:11:49,630 --> 00:11:53,320
is a matter of presentation it's a

00:11:51,640 --> 00:11:56,520
matter of being able to present the code

00:11:53,320 --> 00:12:00,610
in a way that it's easier to maintain

00:11:56,520 --> 00:12:02,830
another way of thinking about common

00:12:00,610 --> 00:12:07,300
table expressions would be this code

00:12:02,830 --> 00:12:10,030
where I've created a temporary you then

00:12:07,300 --> 00:12:17,800
I'm using the view and then I'm dropping

00:12:10,030 --> 00:12:21,400
with you I think the classic later but a

00:12:17,800 --> 00:12:24,330
case we want to compute some result set

00:12:21,400 --> 00:12:28,270
first and reference it multiple times

00:12:24,330 --> 00:12:29,950
right so the idea might be that it's

00:12:28,270 --> 00:12:32,170
going to force it to materialize the

00:12:29,950 --> 00:12:35,770
view and then it'll be used to make your

00:12:32,170 --> 00:12:37,450
warning or something like that or or

00:12:35,770 --> 00:12:38,740
using dissolvable places and so you

00:12:37,450 --> 00:12:41,860
don't have to target one of those sub

00:12:38,740 --> 00:12:46,990
queries yeah yeah no good way of doing

00:12:41,860 --> 00:12:48,850
that well but you can even one clear but

00:12:46,990 --> 00:12:52,200
but in one clear okay

00:12:48,850 --> 00:12:56,230
so logically needs to be equivalent and

00:12:52,200 --> 00:12:59,170
so apart from syntactic sugar

00:12:56,230 --> 00:13:00,300
ordinary common table operations aren't

00:12:59,170 --> 00:13:03,460
all that

00:13:00,300 --> 00:13:05,650
exciting what really gets interesting is

00:13:03,460 --> 00:13:08,290
the recursive common table expressions

00:13:05,650 --> 00:13:12,640
before I get into that let's just pose a

00:13:08,290 --> 00:13:14,890
hypothetical problem I want to fill some

00:13:12,640 --> 00:13:18,190
table with all integer between one and

00:13:14,890 --> 00:13:20,590
five and if you're new to SQL you might

00:13:18,190 --> 00:13:22,300
think that you could do it this way and

00:13:20,590 --> 00:13:23,470
I'll explain in a minute but before I

00:13:22,300 --> 00:13:25,720
even get started let me just go ahead

00:13:23,470 --> 00:13:27,610
and cut off the projections that SQL

00:13:25,720 --> 00:13:29,650
will not work quite like what I'm going

00:13:27,610 --> 00:13:31,270
to tell you it is but if you're new and

00:13:29,650 --> 00:13:33,190
you're just coming to s2o you might

00:13:31,270 --> 00:13:36,340
think it would work this way so we

00:13:33,190 --> 00:13:39,550
create the table and we insert a seed

00:13:36,340 --> 00:13:43,480
value and then we have an insert here

00:13:39,550 --> 00:13:46,510
that selects data from itself and then

00:13:43,480 --> 00:13:50,290
it's sort of a self insert inserted into

00:13:46,510 --> 00:13:52,780
team 1 and select X plus 1 31 so we

00:13:50,290 --> 00:13:55,270
start out and table t1 has a single

00:13:52,780 --> 00:13:57,790
value in it which is the number one and

00:13:55,270 --> 00:14:00,490
it hasn't read anything yet

00:13:57,790 --> 00:14:03,430
so the first thing it does is it reads

00:14:00,490 --> 00:14:06,640
the one up here in the select it reads

00:14:03,430 --> 00:14:10,720
the one mt1 to add one to it and inserts

00:14:06,640 --> 00:14:13,600
it into t1 and so now you've got one two

00:14:10,720 --> 00:14:17,530
in the table okay and then it keeps

00:14:13,600 --> 00:14:19,300
reading it reads the two and adds one to

00:14:17,530 --> 00:14:22,750
it and it inserts of three you can do

00:14:19,300 --> 00:14:27,310
the take and so then the cursor keeps

00:14:22,750 --> 00:14:29,800
reading and it reads a three and then

00:14:27,310 --> 00:14:32,080
add one to it since that you know 4 is

00:14:29,800 --> 00:14:35,670
less than 5 so it serves the four into

00:14:32,080 --> 00:14:38,680
the table it keeps reading and then it

00:14:35,670 --> 00:14:43,570
adds one to four and says is 4 less than

00:14:38,680 --> 00:14:45,730
5 or well notice is 4 less than 5

00:14:43,570 --> 00:14:48,100
minutes of sorts of 5 on the table that

00:14:45,730 --> 00:14:51,400
keeps reading and at that point says

00:14:48,100 --> 00:14:53,080
will find is not less than 5 so it

00:14:51,400 --> 00:14:56,500
doesn't do any more insert in it stops

00:14:53,080 --> 00:14:58,090
and if if you didn't know as you might

00:14:56,500 --> 00:15:03,270
think this would actually happen this

00:14:58,090 --> 00:15:07,060
way but it does in reality an SQL Server

00:15:03,270 --> 00:15:09,220
SQL famous engine will do the entire

00:15:07,060 --> 00:15:11,950
select first and then insert it all at

00:15:09,220 --> 00:15:12,819
once so he would really you can ran this

00:15:11,950 --> 00:15:16,739
from just enough width

00:15:12,819 --> 00:15:20,859
to Cuba now who actually just in one -

00:15:16,739 --> 00:15:23,410
yeah but but this kind of illustrates

00:15:20,859 --> 00:15:26,100
the idea about how you might kind of use

00:15:23,410 --> 00:15:28,539
recursion to do something multiple times

00:15:26,100 --> 00:15:30,999
even though it working it turns out fit

00:15:28,539 --> 00:15:33,639
in a recursion of a common table

00:15:30,999 --> 00:15:37,239
expression is a little bit different and

00:15:33,639 --> 00:15:39,189
it does do what I just showed you so

00:15:37,239 --> 00:15:41,259
let's talk about recursive common table

00:15:39,189 --> 00:15:45,279
expressions they have an unusual floor

00:15:41,259 --> 00:15:49,629
its kind of rigid format it starts with

00:15:45,279 --> 00:15:51,819
the keywords width and sometimes the key

00:15:49,629 --> 00:15:54,309
word recursive I will go into that more

00:15:51,819 --> 00:15:57,129
in a second and then you have the

00:15:54,309 --> 00:16:01,389
regular the name of your little magical

00:15:57,129 --> 00:16:04,689
view and then it's going to be an Indian

00:16:01,389 --> 00:16:06,160
or an Indian all or in some cases that

00:16:04,689 --> 00:16:09,069
always has to be at Union off depending

00:16:06,160 --> 00:16:11,199
on what region you're using and and then

00:16:09,069 --> 00:16:13,569
it's there's two parts of this Union all

00:16:11,199 --> 00:16:15,160
there's this the first query is kind of

00:16:13,569 --> 00:16:16,269
like your initialization epoch of how

00:16:15,160 --> 00:16:18,939
the slides commit this little bit

00:16:16,269 --> 00:16:22,329
clearer and second and then the second

00:16:18,939 --> 00:16:25,509
one is a query that uses the common

00:16:22,329 --> 00:16:29,859
table expression exactly once in its

00:16:25,509 --> 00:16:32,079
front paws we'll see what's coming to me

00:16:29,859 --> 00:16:35,919
so here's an example here's how we load

00:16:32,079 --> 00:16:41,379
the table t1 with the first non pie

00:16:35,919 --> 00:16:42,579
integers so we take with recursive see

00:16:41,379 --> 00:16:45,639
if X I'm just making up something

00:16:42,579 --> 00:16:48,369
whatever they do on C of X as selecting

00:16:45,639 --> 00:16:51,220
one so the selected one is conceding me

00:16:48,369 --> 00:16:54,369
of the recursion so the first value we

00:16:51,220 --> 00:16:56,829
get into one and then we do this the

00:16:54,369 --> 00:17:01,089
second part of the Indian Hall multiple

00:16:56,829 --> 00:17:04,449
times and we say look X plus 1 in front

00:17:01,089 --> 00:17:06,069
of C notice we're using the common table

00:17:04,449 --> 00:17:08,049
it's racing exactly once in the front

00:17:06,069 --> 00:17:11,079
halls it's very important it has in the

00:17:08,049 --> 00:17:14,319
front calls on the top query right there

00:17:11,079 --> 00:17:16,120
and then we we started doing this

00:17:14,319 --> 00:17:18,240
recursion just like we did before where

00:17:16,120 --> 00:17:22,059
it looks like we're moving forward

00:17:18,240 --> 00:17:23,470
but in this case it actually works it

00:17:22,059 --> 00:17:26,380
works just like I showed you before

00:17:23,470 --> 00:17:28,690
where it starts building up the t1 and

00:17:26,380 --> 00:17:33,720
reading keep adding to it and keeps

00:17:28,690 --> 00:17:36,400
clearing itself at the same time okay so

00:17:33,720 --> 00:17:38,500
one he had just exploded in the audience

00:17:36,400 --> 00:17:40,960
but we're going to do some examples and

00:17:38,500 --> 00:17:45,070
hopefully this will become clear as we

00:17:40,960 --> 00:17:47,470
do it and and further down the the body

00:17:45,070 --> 00:17:51,520
of the recursive cocktail expression of

00:17:47,470 --> 00:17:53,380
courses I'm using the cone table

00:17:51,520 --> 00:17:56,890
depression C in a select statement which

00:17:53,380 --> 00:17:58,600
is initializing the table so that really

00:17:56,890 --> 00:18:01,150
is what you would time if you wanted to

00:17:58,600 --> 00:18:05,290
initialize a table with the first five

00:18:01,150 --> 00:18:07,030
integers now quick question what if I

00:18:05,290 --> 00:18:10,030
need one I need I really needed to table

00:18:07,030 --> 00:18:11,620
with the first 5 million integers well

00:18:10,030 --> 00:18:14,680
that's really easy to change you just

00:18:11,620 --> 00:18:17,140
changing the 5 here to 5 maybe I love

00:18:14,680 --> 00:18:19,420
when were in there just to maybe and so

00:18:17,140 --> 00:18:22,450
this is something that I use mainly

00:18:19,420 --> 00:18:25,420
because my main primary use of SQL is

00:18:22,450 --> 00:18:27,640
testing SQLite and that's that's what I

00:18:25,420 --> 00:18:29,560
do on a daily basis into making test

00:18:27,640 --> 00:18:31,030
cases I also wanted to have tables that

00:18:29,560 --> 00:18:31,690
you know have all integers between one

00:18:31,030 --> 00:18:34,270
in a million

00:18:31,690 --> 00:18:38,230
this comes up for me a lot real world

00:18:34,270 --> 00:18:42,400
maybe not so much but but it's fun so

00:18:38,230 --> 00:18:46,270
here's here's the correspondence to that

00:18:42,400 --> 00:18:47,230
little thing I showed you before we're

00:18:46,270 --> 00:18:48,850
gonna write I'll talk about the

00:18:47,230 --> 00:18:52,720
recursion thing I said this is not how

00:18:48,850 --> 00:18:54,280
xql really works but here's kind of the

00:18:52,720 --> 00:18:57,090
correspondence to the syntax or

00:18:54,280 --> 00:19:01,210
recursive common table expressions the

00:18:57,090 --> 00:19:04,450
initial where you initialize the table

00:19:01,210 --> 00:19:09,180
right there is the first part of the

00:19:04,450 --> 00:19:12,550
Union on and then your recursion staff

00:19:09,180 --> 00:19:16,330
is the second part right there so it

00:19:12,550 --> 00:19:18,220
does this first part one time and then

00:19:16,330 --> 00:19:21,460
it starts doing this one over and over

00:19:18,220 --> 00:19:27,220
and over again until it's so it's done

00:19:21,460 --> 00:19:29,320
until there's nothing else to add so how

00:19:27,220 --> 00:19:31,000
is this useful other than I mean suppose

00:19:29,320 --> 00:19:35,470
you wanted to do something other than

00:19:31,000 --> 00:19:37,100
had oh it's the next line is well how

00:19:35,470 --> 00:19:39,470
does this work in other systems okay

00:19:37,100 --> 00:19:42,110
if you're if you're running an Oracle

00:19:39,470 --> 00:19:44,840
the first thing to note is that you

00:19:42,110 --> 00:19:46,779
cannot give Oracle have select and an

00:19:44,840 --> 00:19:51,200
expression without phonecalls

00:19:46,779 --> 00:19:53,779
you have to say from dual and dual is a

00:19:51,200 --> 00:19:57,139
magic table that's in every Oracle

00:19:53,779 --> 00:19:59,870
schema that contains a single row and a

00:19:57,139 --> 00:20:05,960
single column single row does he can

00:19:59,870 --> 00:20:07,220
call them they call it tool I and the

00:20:05,960 --> 00:20:12,440
other thing is that they do not

00:20:07,220 --> 00:20:14,179
recognize the recursive work so you have

00:20:12,440 --> 00:20:21,230
McCants a twittery just a myth

00:20:14,179 --> 00:20:23,570
and so that's oracle Postgres is its

00:20:21,230 --> 00:20:26,809
seemingly dogmatic about following the

00:20:23,570 --> 00:20:28,399
SQL standard and so in order to do a

00:20:26,809 --> 00:20:30,799
recursive common table expression you

00:20:28,399 --> 00:20:33,529
have to use the keyword recursive and

00:20:30,799 --> 00:20:35,330
the keyword also changes the semantics

00:20:33,529 --> 00:20:39,769
of binding and so forth

00:20:35,330 --> 00:20:41,779
but I don't I've never tested how that

00:20:39,769 --> 00:20:43,370
times more concentrate whatever they you

00:20:41,779 --> 00:20:45,379
have to say recursive if you wanted to

00:20:43,370 --> 00:20:47,509
be recursive common table expression you

00:20:45,379 --> 00:20:49,759
also in Postgres are allowed instead of

00:20:47,509 --> 00:20:52,220
just saying you select one you could

00:20:49,759 --> 00:20:53,379
just say values one those are those are

00:20:52,220 --> 00:20:58,970
equivalent

00:20:53,379 --> 00:21:03,980
you cannot say values one in or the

00:20:58,970 --> 00:21:06,470
Upstate select one for dual and and

00:21:03,980 --> 00:21:10,070
Steve will start Ruth you must also omit

00:21:06,470 --> 00:21:13,070
the recursive keyword you cannot say

00:21:10,070 --> 00:21:16,929
values one hits this like one um I

00:21:13,070 --> 00:21:20,000
forgot to mention earlier that the

00:21:16,929 --> 00:21:23,419
recursive cron table expression the the

00:21:20,000 --> 00:21:25,820
join operator the Union or Union all it

00:21:23,419 --> 00:21:27,350
is one it is Union all that means it

00:21:25,820 --> 00:21:29,870
takes everything he gets if it's just

00:21:27,350 --> 00:21:34,129
Union it's going to it's going to filter

00:21:29,870 --> 00:21:36,950
out do units turns out that sequel

00:21:34,129 --> 00:21:38,120
server only accept Union all it doesn't

00:21:36,950 --> 00:21:44,000
have the feature of filtering out

00:21:38,120 --> 00:21:45,649
conjugates so with sequel server you

00:21:44,000 --> 00:21:48,440
have to admit recursive and you have

00:21:45,649 --> 00:21:50,059
here Union Hall and you can't use values

00:21:48,440 --> 00:21:52,879
so those are

00:21:50,059 --> 00:21:55,009
kind of the same text course notice that

00:21:52,879 --> 00:21:55,639
there's no way you can write a recursive

00:21:55,009 --> 00:21:58,190
comment

00:21:55,639 --> 00:22:01,360
oh I've got a skew I yeah when that's

00:21:58,190 --> 00:22:04,159
your like recursive keyword is optional

00:22:01,360 --> 00:22:07,879
you can put it in leave it out as you

00:22:04,159 --> 00:22:09,889
choose and it does accept fabulous so

00:22:07,879 --> 00:22:11,629
notice that there's no way to write a

00:22:09,889 --> 00:22:16,610
recursive common table expression that

00:22:11,629 --> 00:22:19,039
will run on both Oracle and post grass

00:22:16,610 --> 00:22:22,129
or on Oracle than sequel server or on

00:22:19,039 --> 00:22:24,769
sequel certain with Coast grafts but I

00:22:22,129 --> 00:22:26,480
worked really hard with that's to rely

00:22:24,769 --> 00:22:28,250
you can actually write a career person

00:22:26,480 --> 00:22:32,440
pong table they spread to the overall in

00:22:28,250 --> 00:22:34,909
SQLite any one of those other three so

00:22:32,440 --> 00:22:41,929
it's a little bit more forgiving of

00:22:34,909 --> 00:22:45,500
syntax okay so a big use for kana table

00:22:41,929 --> 00:22:46,070
expressions is to use the thing multiple

00:22:45,500 --> 00:22:52,039
times

00:22:46,070 --> 00:22:58,070
so suppose we wanted to produce a grid

00:22:52,039 --> 00:23:00,139
of all possible tuples from where you

00:22:58,070 --> 00:23:03,440
know the values are from 110 we can do

00:23:00,139 --> 00:23:06,470
that this way where the recursive Conn

00:23:03,440 --> 00:23:10,220
table expression is loaded on always

00:23:06,470 --> 00:23:14,629
between 1 and 10 down here I'm using it

00:23:10,220 --> 00:23:18,049
twice in the front calls I'm using C

00:23:14,629 --> 00:23:19,820
twice so it effectively who builds a

00:23:18,049 --> 00:23:22,220
little temporary table that has values

00:23:19,820 --> 00:23:24,320
we want to ten and then just join on

00:23:22,220 --> 00:23:27,320
them to give me a kind of a matrix of

00:23:24,320 --> 00:23:34,279
all possible combinations they're very

00:23:27,320 --> 00:23:36,259
useful property what if you know and all

00:23:34,279 --> 00:23:38,149
the examples I've shown you important

00:23:36,259 --> 00:23:39,889
thing to have is important thing to

00:23:38,149 --> 00:23:46,309
notice there was a termination condition

00:23:39,889 --> 00:23:48,980
on the second clause so for example you

00:23:46,309 --> 00:23:51,799
know I had the where X less than equal

00:23:48,980 --> 00:23:53,659
attend here or X less than 5 here but

00:23:51,799 --> 00:23:58,009
here I've got left at all and I've moved

00:23:53,659 --> 00:24:02,200
it out to the outer expression and so

00:23:58,009 --> 00:24:02,200
the question has will this work

00:24:02,450 --> 00:24:08,180
and the answer is sometimes it will and

00:24:06,920 --> 00:24:10,580
sometimes it won't

00:24:08,180 --> 00:24:14,720
and so it's it's kind of at the

00:24:10,580 --> 00:24:19,280
discretion of the query planner this

00:24:14,720 --> 00:24:24,410
does in fact work when Postgres yes it

00:24:19,280 --> 00:24:26,930
does I try to it does work in SQLite I

00:24:24,410 --> 00:24:28,430
think it I think if I recall correctly

00:24:26,930 --> 00:24:30,530
work will gave me a warning that I

00:24:28,430 --> 00:24:34,070
didn't have a termination recursion

00:24:30,530 --> 00:24:36,830
condition and then maybe a sequel server

00:24:34,070 --> 00:24:40,190
ran for a while and it's a comment table

00:24:36,830 --> 00:24:42,290
expressions too big I don't know so so

00:24:40,190 --> 00:24:44,870
what's happening here is you know what

00:24:42,290 --> 00:24:47,090
when I when I kind of describe what was

00:24:44,870 --> 00:24:51,170
going on conceptually the idea is that

00:24:47,090 --> 00:24:53,960
the this lukrons builds up this table

00:24:51,170 --> 00:24:57,290
and then you use the table of the state

00:24:53,960 --> 00:24:59,930
of blood and conceptually that's what's

00:24:57,290 --> 00:25:04,010
happening but the implementation might

00:24:59,930 --> 00:25:05,540
choose something different in

00:25:04,010 --> 00:25:07,700
particularly the implementation might

00:25:05,540 --> 00:25:10,550
implement this in a way so that it

00:25:07,700 --> 00:25:12,320
doesn't create the entire table if you

00:25:10,550 --> 00:25:13,940
don't use the entire table it only

00:25:12,320 --> 00:25:17,540
creates the parts of the table that you

00:25:13,940 --> 00:25:19,550
actually need now the details of that

00:25:17,540 --> 00:25:21,230
view is the program under overwriting

00:25:19,550 --> 00:25:22,310
the common table train should you have

00:25:21,230 --> 00:25:24,380
to think about that

00:25:22,310 --> 00:25:26,000
this is this is at the discretion of the

00:25:24,380 --> 00:25:30,110
query planner inside your database

00:25:26,000 --> 00:25:34,340
engine but Postgres I think it sets up a

00:25:30,110 --> 00:25:37,730
queue with its sense of a common table

00:25:34,340 --> 00:25:41,000
expression runner thingy object it says

00:25:37,730 --> 00:25:44,960
it's a demand thing it's on demand so

00:25:41,000 --> 00:25:47,960
they the lower query says okay I need

00:25:44,960 --> 00:25:50,090
the first row and then the problem table

00:25:47,960 --> 00:25:52,400
expression runs and generates the first

00:25:50,090 --> 00:25:55,640
row and then this guy says I need the

00:25:52,400 --> 00:25:58,040
second row and so forth and and so it

00:25:55,640 --> 00:26:00,380
eventually figures out that that it's

00:25:58,040 --> 00:26:06,080
going to stop and it doesn't actually

00:26:00,380 --> 00:26:08,720
generate all of the call of the the

00:26:06,080 --> 00:26:11,620
whole thing so but so this is not

00:26:08,720 --> 00:26:14,300
recommended don't do this don't do this

00:26:11,620 --> 00:26:15,500
but it can sometimes get away it might

00:26:14,300 --> 00:26:16,610
here's some example

00:26:15,500 --> 00:26:20,390
how this might be a little bit more

00:26:16,610 --> 00:26:24,860
useful recursive calculations were

00:26:20,390 --> 00:26:28,520
useful for career being rats and I have

00:26:24,860 --> 00:26:31,490
a graph here and I it's an undirected

00:26:28,520 --> 00:26:35,960
graph and I've got the table

00:26:31,490 --> 00:26:40,070
representation of it over on the side so

00:26:35,960 --> 00:26:43,040
we see that we both well so we've got

00:26:40,070 --> 00:26:47,090
the ground and we've got I called the

00:26:43,040 --> 00:26:50,360
fields X from and x2 because from and to

00:26:47,090 --> 00:26:51,860
our keywords and SQL and that would

00:26:50,360 --> 00:26:54,230
cause problems and they have to escape

00:26:51,860 --> 00:26:58,070
them if I just use them very but X from

00:26:54,230 --> 00:27:01,510
a next shoot and so for example we've

00:26:58,070 --> 00:27:05,600
got an arc that goes from node 0 node 2

00:27:01,510 --> 00:27:09,440
which is right here and I've also got an

00:27:05,600 --> 00:27:11,150
arc that goes from node 2 to node 0 so

00:27:09,440 --> 00:27:13,190
this is this is really encoded as a

00:27:11,150 --> 00:27:17,690
directed graph but I've drawn an

00:27:13,190 --> 00:27:19,040
undirected graph but it's a drinking

00:27:17,690 --> 00:27:22,460
craft where the area there's always a

00:27:19,040 --> 00:27:27,680
pair for me to have the direction so the

00:27:22,460 --> 00:27:32,030
question is I want to find all nodes

00:27:27,680 --> 00:27:34,370
that are connected with note not this

00:27:32,030 --> 00:27:37,520
might come out for example in your

00:27:34,370 --> 00:27:38,620
network topology this might come up if

00:27:37,520 --> 00:27:41,810
you're doing an airline reservation

00:27:38,620 --> 00:27:45,110
system and you want to find you know all

00:27:41,810 --> 00:27:48,800
flights that are reachable from both

00:27:45,110 --> 00:27:50,900
returners on the island so all those

00:27:48,800 --> 00:27:52,490
that are connected and this is this is

00:27:50,900 --> 00:27:55,250
the recursion ourselves so we got this

00:27:52,490 --> 00:27:59,300
we're creating a common table it's been

00:27:55,250 --> 00:28:01,970
called Khan or connection and and it's

00:27:59,300 --> 00:28:04,370
got a single field ID and we're starting

00:28:01,970 --> 00:28:06,220
at not that our initialization we select

00:28:04,370 --> 00:28:08,960
9uu

00:28:06,220 --> 00:28:10,880
if there's entering this table or the

00:28:08,960 --> 00:28:13,520
value that means that that node is

00:28:10,880 --> 00:28:18,920
connected to itself we initialize it

00:28:13,520 --> 00:28:22,510
that way and then we say select 2 from

00:28:18,920 --> 00:28:26,810
the connection join to the link

00:28:22,510 --> 00:28:27,840
we're prom is in is in the connection so

00:28:26,810 --> 00:28:32,700
we're just adding

00:28:27,840 --> 00:28:36,110
you know Zn as as we traverse the method

00:28:32,700 --> 00:28:38,370
oh and also we've done Union here

00:28:36,110 --> 00:28:42,299
because we don't want to get going and

00:28:38,370 --> 00:28:44,730
lose if it doesn't Union all it would

00:28:42,299 --> 00:28:46,169
start looping and making multiple

00:28:44,730 --> 00:28:48,890
leaders are the same thing we don't let

00:28:46,169 --> 00:28:52,279
that happen so I didn't use in there and

00:28:48,890 --> 00:28:59,190
so if you run this you will attack yet

00:28:52,279 --> 00:29:01,649
output is nine six eight zero two and

00:28:59,190 --> 00:29:03,809
three and you and that's the order that

00:29:01,649 --> 00:29:06,059
actually comes out in and you can kind

00:29:03,809 --> 00:29:08,039
of see how that happens because you know

00:29:06,059 --> 00:29:10,020
it started at nine so what's connected

00:29:08,039 --> 00:29:12,750
behind six and eight or connected to

00:29:10,020 --> 00:29:15,740
nine to making out next and then what's

00:29:12,750 --> 00:29:18,480
connected to six and a well that's zero

00:29:15,740 --> 00:29:20,450
and what's making to zero two and three

00:29:18,480 --> 00:29:26,460
so you can kind of see what indeed it

00:29:20,450 --> 00:29:28,950
and it doesn't matter doodad um here's a

00:29:26,460 --> 00:29:33,679
slightly different graph I just added a

00:29:28,950 --> 00:29:36,179
single edge goes from zero to three okay

00:29:33,679 --> 00:29:40,140
let's find all those that are within

00:29:36,179 --> 00:29:41,580
four hops of note nine and this is this

00:29:40,140 --> 00:29:43,919
is this would come up and run in an air

00:29:41,580 --> 00:29:46,440
on a reservation system where you want

00:29:43,919 --> 00:29:48,000
to find your leaving Charlotte you want

00:29:46,440 --> 00:29:52,529
to find all the places that you can get

00:29:48,000 --> 00:29:56,520
to with only two connections that would

00:29:52,529 --> 00:29:59,340
be like this so you start with now my

00:29:56,520 --> 00:30:01,470
table is the connection of a kind of

00:29:59,340 --> 00:30:03,330
connection to this is the place where

00:30:01,470 --> 00:30:05,370
connected to this is happy hops we had

00:30:03,330 --> 00:30:07,289
to go through to get there and so I

00:30:05,370 --> 00:30:09,390
initialize Nam we didn't have to go

00:30:07,289 --> 00:30:11,159
through any hops at all begins mines

00:30:09,390 --> 00:30:21,510
with it zero so the initial value is

00:30:11,159 --> 00:30:24,029
nine zero I do it Union all and then I

00:30:21,510 --> 00:30:27,720
say the next link is where we're going

00:30:24,029 --> 00:30:30,000
to we increment the distance join on the

00:30:27,720 --> 00:30:31,950
connection where we're coming from and

00:30:30,000 --> 00:30:33,750
where the connection is less than four

00:30:31,950 --> 00:30:35,260
and there is some duplication here

00:30:33,750 --> 00:30:39,160
preserved multiple passed

00:30:35,260 --> 00:30:41,770
the same spot and so I have to add the

00:30:39,160 --> 00:30:45,580
distinct and here in the bottom and sure

00:30:41,770 --> 00:30:50,560
enough this shows me it says 9 to 6 and

00:30:45,580 --> 00:30:55,300
8 to 0 to 2 to 3 into 7 and then it

00:30:50,560 --> 00:30:59,140
stops and if I sit down here well and if

00:30:55,300 --> 00:31:02,500
I could have said Celeste ID common dist

00:30:59,140 --> 00:31:04,750
from Cohn and it would have shown me all

00:31:02,500 --> 00:31:06,820
of the possible ways to get there with

00:31:04,750 --> 00:31:09,280
with distances but I there's not this

00:31:06,820 --> 00:31:10,660
SQL standard way of saying distinct on I

00:31:09,280 --> 00:31:11,890
mean you can do that in Postgres but I

00:31:10,660 --> 00:31:18,910
don't think you can do it anywhere else

00:31:11,890 --> 00:31:21,160
can you doc yeah distinct what one is a

00:31:18,910 --> 00:31:22,750
Postgres only thing in fact if it had a

00:31:21,160 --> 00:31:25,390
distinct ones yeah I could put a

00:31:22,750 --> 00:31:27,280
distinct one ID comma distance and then

00:31:25,390 --> 00:31:30,130
seen the distance for each one there's a

00:31:27,280 --> 00:31:31,930
way to do that in this cute sqli as well

00:31:30,130 --> 00:31:36,160
but it's also non-standard

00:31:31,930 --> 00:31:39,610
yeah they said it wasn't clear like yeah

00:31:36,160 --> 00:31:45,150
we had this indexed that we did you know

00:31:39,610 --> 00:31:53,040
and that's because well we need to

00:31:45,150 --> 00:31:55,960
because I was thinking suppose you had a

00:31:53,040 --> 00:31:58,780
beginning here because I'm thinking you

00:31:55,960 --> 00:32:03,550
might have a city that's reachable with

00:31:58,780 --> 00:32:04,720
one close to differences and so and this

00:32:03,550 --> 00:32:07,750
would this would get rid of that

00:32:04,720 --> 00:32:10,480
duplication for me right on it and you

00:32:07,750 --> 00:32:13,390
could certainly go ahead and put Union

00:32:10,480 --> 00:32:16,360
here I think what happened was - through

00:32:13,390 --> 00:32:18,670
these slides in the previous one I just

00:32:16,360 --> 00:32:21,400
putting it all because Moses honey put

00:32:18,670 --> 00:32:23,560
Union all here because when you put

00:32:21,400 --> 00:32:24,850
Union that means the database engine has

00:32:23,560 --> 00:32:29,290
to do a little bit of extra work to

00:32:24,850 --> 00:32:31,360
filter out the duplicates so it's not a

00:32:29,290 --> 00:32:34,360
lot of work indefinitely looking so much

00:32:31,360 --> 00:32:35,740
but Indian text to work so to fall to

00:32:34,360 --> 00:32:37,660
eating an all unless you really need and

00:32:35,740 --> 00:32:40,000
so then I came back and change this to

00:32:37,660 --> 00:32:41,760
Union when it's all the duplicates and I

00:32:40,000 --> 00:32:44,940
just didn't change it in the other one

00:32:41,760 --> 00:32:47,530
so here's a real world example of using

00:32:44,940 --> 00:32:49,320
recursive common table expressions this

00:32:47,530 --> 00:32:53,380
is in Firefox

00:32:49,320 --> 00:32:56,410
so you know your all your bookmarks are

00:32:53,380 --> 00:32:59,770
stored and SQLite database in Firefox

00:32:56,410 --> 00:33:02,050
and and and and the table with a sword

00:32:59,770 --> 00:33:06,220
in your bookmarks are organized in a

00:33:02,050 --> 00:33:09,390
tree and a hierarchy and and you can go

00:33:06,220 --> 00:33:11,860
in and and drag things around and put

00:33:09,390 --> 00:33:18,870
bookmarks into different subfolders and

00:33:11,860 --> 00:33:21,640
so forth and this expression is used to

00:33:18,870 --> 00:33:23,710
let's take Vodacom intelligent make sure

00:33:21,640 --> 00:33:26,200
we are not moving a folder into itself

00:33:23,710 --> 00:33:27,460
or in one of its descendants so this is

00:33:26,200 --> 00:33:31,000
part of the operation when you're

00:33:27,460 --> 00:33:32,980
dragging a folder file or folder if you

00:33:31,000 --> 00:33:37,300
don't place to another and it actually

00:33:32,980 --> 00:33:38,950
queries the database that stores all in

00:33:37,300 --> 00:33:41,650
your bookmarks to verify that you're not

00:33:38,950 --> 00:33:43,360
creating a loop and your directory

00:33:41,650 --> 00:33:44,740
hierarchy using your recursive common

00:33:43,360 --> 00:33:47,080
table expression I thought that was

00:33:44,740 --> 00:33:48,840
really cool when I saw this very very

00:33:47,080 --> 00:33:51,250
good

00:33:48,840 --> 00:33:55,590
yeah this would be your opening to do if

00:33:51,250 --> 00:33:59,470
you have to write application code and

00:33:55,590 --> 00:34:02,410
so here's an example for fossil where

00:33:59,470 --> 00:34:05,740
we're finding all of the descendants of

00:34:02,410 --> 00:34:08,050
a check-in and we're storing their IDs

00:34:05,740 --> 00:34:12,010
and a table that already exists called

00:34:08,050 --> 00:34:17,530
okay so actually we're finding the first

00:34:12,010 --> 00:34:21,100
in -1 closest in time and so once again

00:34:17,530 --> 00:34:22,840
work we're running to we're starting in

00:34:21,100 --> 00:34:26,020
a single node in the graph and walking

00:34:22,840 --> 00:34:29,889
through a graph till 3 as we go and our

00:34:26,020 --> 00:34:32,470
Kirk I our termination condition is a

00:34:29,889 --> 00:34:34,480
limit of 30 our limit of enum

00:34:32,470 --> 00:34:36,250
so this is a real world example but I

00:34:34,480 --> 00:34:39,040
want to get in and spend a little time

00:34:36,250 --> 00:34:40,929
talking about this is an academic

00:34:39,040 --> 00:34:43,899
exercise so I'm going to show you how to

00:34:40,929 --> 00:34:46,149
do to solve a Sudoku puzzle using a

00:34:43,899 --> 00:34:48,159
recursive common table expression this

00:34:46,149 --> 00:34:52,419
is an academic exercise in the sense

00:34:48,159 --> 00:34:53,409
that there are this is not something

00:34:52,419 --> 00:34:57,070
that's really going to come up in your

00:34:53,409 --> 00:35:00,340
typical business application but if you

00:34:57,070 --> 00:35:02,690
understand this then you can say that

00:35:00,340 --> 00:35:08,930
you'll understand complicated

00:35:02,690 --> 00:35:10,940
and initially just for explains where

00:35:08,930 --> 00:35:15,559
purses I'm going to start simple with

00:35:10,940 --> 00:35:17,030
just a sort of go puzzle that has only

00:35:15,559 --> 00:35:18,559
two five suite blocks instead of three

00:35:17,030 --> 00:35:20,690
by three and that keeps problem with

00:35:18,559 --> 00:35:21,710
shorter and then if you can't will it's

00:35:20,690 --> 00:35:24,140
just a matter of changing you to

00:35:21,710 --> 00:35:25,970
constants to go to three by three so

00:35:24,140 --> 00:35:29,960
we're going to represent the puzzle as a

00:35:25,970 --> 00:35:34,369
stream with each character in the string

00:35:29,960 --> 00:35:37,730
being a square in the public and we're

00:35:34,369 --> 00:35:40,490
reading right to left top to bottom so

00:35:37,730 --> 00:35:42,020
the first character this tree is one and

00:35:40,490 --> 00:35:47,359
that was blanks who would put a period

00:35:42,020 --> 00:35:49,960
there or a . . . and then we read this

00:35:47,359 --> 00:35:52,910
one this was with bounty two two and

00:35:49,960 --> 00:35:57,349
then three more stops and then two three

00:35:52,910 --> 00:35:59,599
and then the four and then three blanks

00:35:57,349 --> 00:36:02,030
so that's the format of our puzzle and

00:35:59,599 --> 00:36:04,579
we want to fill in the gas and fine

00:36:02,030 --> 00:36:08,480
here's some plum preliminaries we're

00:36:04,579 --> 00:36:10,339
going to need some auxilary tables we

00:36:08,480 --> 00:36:11,779
want to we want to table this just going

00:36:10,339 --> 00:36:15,410
to store our input and i'll call it

00:36:11,779 --> 00:36:18,799
input and we'll want a table that's

00:36:15,410 --> 00:36:20,420
going to give us all of our digits from

00:36:18,799 --> 00:36:23,660
1 to 4 do i need to get back after

00:36:20,420 --> 00:36:26,569
you've got some questions or I'm back up

00:36:23,660 --> 00:36:30,529
I'm going to fast Tom I'm going to next

00:36:26,569 --> 00:36:32,390
time so we for right now this is just a

00:36:30,529 --> 00:36:34,099
temporary step we're going to we're

00:36:32,390 --> 00:36:36,470
going to actually hold us all into the

00:36:34,099 --> 00:36:38,059
single expression in a minute but just

00:36:36,470 --> 00:36:40,130
for conceptual purposes let's start with

00:36:38,059 --> 00:36:44,000
two tables one of them has a single row

00:36:40,130 --> 00:36:45,950
and that is the input problem and then

00:36:44,000 --> 00:36:46,940
the other another table has just our

00:36:45,950 --> 00:36:48,890
digits and we're going to need our

00:36:46,940 --> 00:36:52,670
teaches both as numbers and as

00:36:48,890 --> 00:36:55,029
characters so this table is going to

00:36:52,670 --> 00:36:59,059
have one column for each and I actually

00:36:55,029 --> 00:37:01,880
initialize the digits table with digits

00:36:59,059 --> 00:37:05,599
1 2 3 & 4 using a reverse ative common

00:37:01,880 --> 00:37:07,309
table expression here so those are

00:37:05,599 --> 00:37:10,099
simpler it is the more preliminaries of

00:37:07,309 --> 00:37:12,859
some of the functions that we're going

00:37:10,099 --> 00:37:14,190
to need there's the instr function I

00:37:12,859 --> 00:37:17,840
think this is a

00:37:14,190 --> 00:37:22,290
different post president I think it's

00:37:17,840 --> 00:37:24,600
how does it go it's string you can do

00:37:22,290 --> 00:37:28,140
the same thing but it's spelled out of

00:37:24,600 --> 00:37:31,290
syntax in stir I think is a MySQL ism

00:37:28,140 --> 00:37:33,690
isn't it or is it a gorkel ISM I don't

00:37:31,290 --> 00:37:36,990
know in store takes to secure it takes

00:37:33,690 --> 00:37:41,730
us two strings a and B and it returns an

00:37:36,990 --> 00:37:43,350
integer where the integer is the index

00:37:41,730 --> 00:37:48,210
and the first trait where the second

00:37:43,350 --> 00:37:50,970
string occurs and SQ a little one index

00:37:48,210 --> 00:37:52,770
base so if it occurs the very first

00:37:50,970 --> 00:37:56,130
position it returns 1 if it doesn't find

00:37:52,770 --> 00:37:58,950
it anywhere it returns to zero that's

00:37:56,130 --> 00:38:01,530
the way instr works I didn't make this

00:37:58,950 --> 00:38:06,510
up my cognitive community and so this is

00:38:01,530 --> 00:38:08,760
not an SQL this is not an SQLite ism so

00:38:06,510 --> 00:38:10,920
for example in the first one we're

00:38:08,760 --> 00:38:12,960
asking for the first occurrence of any

00:38:10,920 --> 00:38:14,460
full stop and that's in the second

00:38:12,960 --> 00:38:17,220
character position because the first

00:38:14,460 --> 00:38:18,900
carrier positions taken by one and in

00:38:17,220 --> 00:38:21,480
the second one the first instance is

00:38:18,900 --> 00:38:23,190
that character position 7 and analyze

00:38:21,480 --> 00:38:24,900
when there are no the periods or full

00:38:23,190 --> 00:38:27,300
stops of the entire strains that returns

00:38:24,900 --> 00:38:27,750
zero because that's just in your

00:38:27,300 --> 00:38:30,540
function

00:38:27,750 --> 00:38:33,180
everybody all of the SQL data agents

00:38:30,540 --> 00:38:35,790
have a function like this they sometimes

00:38:33,180 --> 00:38:39,920
call them different names and then we

00:38:35,790 --> 00:38:44,280
have a substr function which takes a

00:38:39,920 --> 00:38:47,370
subset of the stream and the stream is

00:38:44,280 --> 00:38:50,520
if a and B is the first character of the

00:38:47,370 --> 00:38:52,410
substring and see if it exists is the

00:38:50,520 --> 00:38:54,810
number of characters in the substring or

00:38:52,410 --> 00:39:01,020
C is emitted it just returns the rest of

00:38:54,810 --> 00:39:03,750
the string the tail so so here's the

00:39:01,020 --> 00:39:05,040
stream right there we want starting with

00:39:03,750 --> 00:39:07,890
the fourth character we want three

00:39:05,040 --> 00:39:09,240
characters so one two three four and

00:39:07,890 --> 00:39:11,000
then we turn them to three characters

00:39:09,240 --> 00:39:12,900
and sure enough that's what we get now

00:39:11,000 --> 00:39:14,970
likewise here when I'm start on a

00:39:12,900 --> 00:39:16,080
thirteenth character and then return

00:39:14,970 --> 00:39:19,200
everything else and that's the third

00:39:16,080 --> 00:39:22,080
circuit returns everything else so those

00:39:19,200 --> 00:39:25,530
are two functions and they all all the

00:39:22,080 --> 00:39:26,990
databases have these just just sometimes

00:39:25,530 --> 00:39:28,730
it may need differently

00:39:26,990 --> 00:39:31,730
and now I'm going to just for just for

00:39:28,730 --> 00:39:33,500
conceptual purposes for right now let's

00:39:31,730 --> 00:39:37,790
imagine we have a magical function

00:39:33,500 --> 00:39:41,000
called is valid Sudoku and this function

00:39:37,790 --> 00:39:42,380
takes three arguments and the first

00:39:41,000 --> 00:39:45,260
argument is one of those strains that

00:39:42,380 --> 00:39:46,790
represents the Sudoku puzzle and the

00:39:45,260 --> 00:39:49,730
second argument is a character position

00:39:46,790 --> 00:39:52,190
but a second or if it is a character one

00:39:49,730 --> 00:39:53,630
two three or four or five six seven

00:39:52,190 --> 00:39:55,610
eight nine if you're working full slides

00:39:53,630 --> 00:39:58,210
and the third one is an insert point and

00:39:55,610 --> 00:40:01,190
so if you insert that character into the

00:39:58,210 --> 00:40:03,140
middle of the puzzle at that point is it

00:40:01,190 --> 00:40:05,140
still a balance to go it's going to

00:40:03,140 --> 00:40:08,360
return true or false

00:40:05,140 --> 00:40:11,960
it's a magical function so if we have

00:40:08,360 --> 00:40:14,270
all of these things together then this

00:40:11,960 --> 00:40:16,010
is a recursive comma table expression it

00:40:14,270 --> 00:40:22,369
will produce an answer to your Sudoku

00:40:16,010 --> 00:40:27,170
puzzle let's work a trip so the

00:40:22,369 --> 00:40:29,660
recursive expression is Sudoku it's a

00:40:27,170 --> 00:40:31,730
two values which are a puzzle which

00:40:29,660 --> 00:40:34,400
could be incomplete candy slots in it

00:40:31,730 --> 00:40:39,710
and then X and X is going to be the

00:40:34,400 --> 00:40:41,359
index of the first empty slot and our

00:40:39,710 --> 00:40:44,300
goal if you look down here at the bottom

00:40:41,359 --> 00:40:45,680
is return s where X is zero meaning

00:40:44,300 --> 00:40:48,950
there are no agents lost when once we

00:40:45,680 --> 00:40:55,700
turn a completely puzzle so we

00:40:48,950 --> 00:40:58,460
initialize our puzzle to J and the in

00:40:55,700 --> 00:41:00,950
store of J naught from input so that's

00:40:58,460 --> 00:41:02,869
that's our initial state it's the

00:41:00,950 --> 00:41:05,890
initial string that we had plus the

00:41:02,869 --> 00:41:09,350
index of the first unfilled slot and

00:41:05,890 --> 00:41:13,760
then we're here's our recursion staff

00:41:09,350 --> 00:41:19,850
we're going to insert into position X

00:41:13,760 --> 00:41:27,320
minus one are no insert into position X

00:41:19,850 --> 00:41:29,450
a digit and yeah so we're getting all

00:41:27,320 --> 00:41:31,760
characters before X then we're replacing

00:41:29,450 --> 00:41:34,820
X and then here's all the characters

00:41:31,760 --> 00:41:37,670
occur after X so in that blank spot were

00:41:34,820 --> 00:41:39,510
inserting in digit and we're joining the

00:41:37,670 --> 00:41:41,160
input with Allah

00:41:39,510 --> 00:41:44,610
midgets so we're putting all possible

00:41:41,160 --> 00:41:47,100
digits in there but we're wholly

00:41:44,610 --> 00:41:51,000
accepting those which end up being

00:41:47,100 --> 00:41:53,070
balanced vocal puzzles so it starts

00:41:51,000 --> 00:41:54,150
putting putting these strings in here

00:41:53,070 --> 00:41:55,770
and every time it puts in a strain it

00:41:54,150 --> 00:41:57,840
knows it's a balance to duplicate puzzle

00:41:55,770 --> 00:41:59,930
and the extremes keep getting longer and

00:41:57,840 --> 00:42:02,850
longer and probably gets comes in and

00:41:59,930 --> 00:42:05,690
that's our answer of course we can't

00:42:02,850 --> 00:42:08,040
actually run this because there are no

00:42:05,690 --> 00:42:14,690
SQL database engines that have any is

00:42:08,040 --> 00:42:17,190
valid pseudo cout function built-in so

00:42:14,690 --> 00:42:18,900
of course you know we also have there's

00:42:17,190 --> 00:42:21,420
extra external tables we can build them

00:42:18,900 --> 00:42:24,210
as as other common table expressions

00:42:21,420 --> 00:42:26,160
into the same SQL statement so here's

00:42:24,210 --> 00:42:28,260
our definition of inputs right there

00:42:26,160 --> 00:42:30,150
the top line rather than having a

00:42:28,260 --> 00:42:32,880
separate table we're just going to con

00:42:30,150 --> 00:42:35,070
table it's ready here's digits right

00:42:32,880 --> 00:42:36,630
here rather than having a separate table

00:42:35,070 --> 00:42:38,520
we'll just think of another common table

00:42:36,630 --> 00:42:42,000
expression and then down in the Sudoku

00:42:38,520 --> 00:42:45,840
we're using both input and digits and we

00:42:42,000 --> 00:42:47,130
get our answer so if not we would pull

00:42:45,840 --> 00:42:50,760
it all that into one single expression

00:42:47,130 --> 00:42:55,890
and we're still have this pesky is valid

00:42:50,760 --> 00:42:58,130
so who cares the real magic right here

00:42:55,890 --> 00:43:00,960
I'm not really going to go into this oh

00:42:58,130 --> 00:43:03,990
this look this could be your homework

00:43:00,960 --> 00:43:05,610
assignment you can you can go and get

00:43:03,990 --> 00:43:07,950
this and look at this and convince

00:43:05,610 --> 00:43:10,320
yourself that that expression which I

00:43:07,950 --> 00:43:12,500
attended blue I don't know how we can

00:43:10,320 --> 00:43:16,770
read it but this expression right here

00:43:12,500 --> 00:43:18,950
will be true if and only if it's a

00:43:16,770 --> 00:43:24,150
balance with their go expression

00:43:18,950 --> 00:43:26,540
protected modulus yes it is yes it is

00:43:24,150 --> 00:43:30,500
and that's the same in Postgres

00:43:26,540 --> 00:43:35,460
different operator over by minus QL yeah

00:43:30,500 --> 00:43:37,860
so so so yeah it's got the hill we have

00:43:35,460 --> 00:43:41,100
three cases the first case is looking to

00:43:37,860 --> 00:43:42,930
see if it's you know if there's a those

00:43:41,100 --> 00:43:45,030
two two numbers that are the same on the

00:43:42,930 --> 00:43:47,190
same row and if two numbers the same one

00:43:45,030 --> 00:43:49,970
same column and the two numbers the same

00:43:47,190 --> 00:43:49,970
in the same block

00:43:51,220 --> 00:43:56,230
yeah and there would be a lot of good to

00:43:54,849 --> 00:44:00,940
make it work

00:43:56,230 --> 00:44:03,130
my nine not really before yeah well

00:44:00,940 --> 00:44:04,990
there's a few changes but yeah I'll show

00:44:03,130 --> 00:44:07,900
you that in a second so that that

00:44:04,990 --> 00:44:09,309
doesn't fact work and so okay Devon

00:44:07,900 --> 00:44:11,529
Devon I'm gonna make this change them to

00:44:09,309 --> 00:44:13,930
the bottom you know I was clicking just

00:44:11,529 --> 00:44:16,299
the answer or x equals 0 I'm gonna

00:44:13,930 --> 00:44:17,410
actually run this and show you all the

00:44:16,299 --> 00:44:18,880
outfits that you couldn't kind of see

00:44:17,410 --> 00:44:21,369
what happens and this is what actually

00:44:18,880 --> 00:44:23,950
happens so we started out the first one

00:44:21,369 --> 00:44:25,690
and it tried to it'll cut on the first

00:44:23,950 --> 00:44:28,269
iteration healed in two three and four

00:44:25,690 --> 00:44:31,569
and then the next generation they got

00:44:28,269 --> 00:44:33,220
three and fuller or three in a forward

00:44:31,569 --> 00:44:35,200
you can see what's happening here is

00:44:33,220 --> 00:44:39,759
slowly builds it up it's finally at the

00:44:35,200 --> 00:44:41,980
bottom we get a single solution into the

00:44:39,759 --> 00:44:44,200
Sudoku puzzle and had multiple solutions

00:44:41,980 --> 00:44:46,990
you have got multiple entries with here

00:44:44,200 --> 00:44:47,980
at the bottom even had no solutions you

00:44:46,990 --> 00:44:57,519
never would have got any through this

00:44:47,980 --> 00:45:02,859
Europe on this one I guess you would

00:44:57,519 --> 00:45:07,150
have liked again by going back to 1514

00:45:02,859 --> 00:45:11,680
numbers yes I mean it's kinda like

00:45:07,150 --> 00:45:14,579
backtrack so if I started up here to

00:45:11,680 --> 00:45:17,039
we've been done a full stop instead

00:45:14,579 --> 00:45:19,390
period then there would be multiples

00:45:17,039 --> 00:45:20,950
yeah there probably would be multiples

00:45:19,390 --> 00:45:24,039
which I'm guessing we could actually try

00:45:20,950 --> 00:45:27,819
it here engine one there were probably

00:45:24,039 --> 00:45:29,259
multiple solutions and so yeah there the

00:45:27,819 --> 00:45:34,500
list would be longer and have multiple

00:45:29,259 --> 00:45:36,940
answers at the bottom right so this is

00:45:34,500 --> 00:45:40,869
allegedly the world's most difficult to

00:45:36,940 --> 00:45:43,210
though proposal supposed to be really

00:45:40,869 --> 00:45:45,190
really hard I got this out of the

00:45:43,210 --> 00:45:46,869
Guardian newspaper or something it's

00:45:45,190 --> 00:45:48,400
online just look for world's hardest to

00:45:46,869 --> 00:45:52,990
do proposal nights of the air

00:45:48,400 --> 00:45:53,759
they're all equal to me here is the

00:45:52,990 --> 00:45:57,279
change

00:45:53,759 --> 00:45:59,750
put a red tint on the part this is the

00:45:57,279 --> 00:46:01,430
same expression this is the same thing

00:45:59,750 --> 00:46:04,070
go to the smaller font because now we've

00:46:01,430 --> 00:46:05,830
got more stuff and I put a red temple

00:46:04,070 --> 00:46:08,540
the numbers have changed and so

00:46:05,830 --> 00:46:10,520
basically I just had to put in the lava

00:46:08,540 --> 00:46:13,130
stream there this changed from four to

00:46:10,520 --> 00:46:19,820
nine and down here we see lots of

00:46:13,130 --> 00:46:23,480
changes from 3 to 9 3 9 27 okay but it's

00:46:19,820 --> 00:46:29,570
the same same idea the same idea and

00:46:23,480 --> 00:46:32,000
then I ran that and it went on it took

00:46:29,570 --> 00:46:35,200
two hundred and eight seconds it

00:46:32,000 --> 00:46:38,210
generated to over two million

00:46:35,200 --> 00:46:39,859
intermediate solutions but it did come

00:46:38,210 --> 00:46:44,390
up with a unique answer which is shown

00:46:39,859 --> 00:46:46,730
right there okay if but if the human is

00:46:44,390 --> 00:46:58,040
doing this are they just kind of

00:46:46,730 --> 00:47:00,200
guessing you say this number has to be I

00:46:58,040 --> 00:47:03,410
mean there's a lot of there's a lot of

00:47:00,200 --> 00:47:06,440
easy yeah now in the easiest to Demick

00:47:03,410 --> 00:47:08,900
there's usually multiple blocks that you

00:47:06,440 --> 00:47:10,940
can fill in by looking at it and say

00:47:08,900 --> 00:47:12,440
well I've already got a nine up here

00:47:10,940 --> 00:47:14,210
they've already got a nine on this row

00:47:12,440 --> 00:47:16,339
so it's got to go in this problem but

00:47:14,210 --> 00:47:20,270
but this was a specially-designed said

00:47:16,339 --> 00:47:26,150
none of those easy things work you have

00:47:20,270 --> 00:47:30,440
to work through it comedian says yeah

00:47:26,150 --> 00:47:32,780
you got one way now other people have

00:47:30,440 --> 00:47:34,280
published the line similar sort of

00:47:32,780 --> 00:47:37,730
things we can solve the 8 Queens problem

00:47:34,280 --> 00:47:39,200
you think a common table expression on

00:47:37,730 --> 00:47:41,240
our website we have to show you how to

00:47:39,200 --> 00:47:43,190
compute the Mandelbrot set using a

00:47:41,240 --> 00:47:46,820
common table expression and even print

00:47:43,190 --> 00:47:48,470
it out using ASCII art you can do all

00:47:46,820 --> 00:47:50,930
happen things like that they're silly

00:47:48,470 --> 00:47:52,130
examples and these aren't useful but

00:47:50,930 --> 00:47:54,230
useful ones are the ones I showed you

00:47:52,130 --> 00:47:55,369
earlier where it like in Firefox they're

00:47:54,230 --> 00:47:58,760
checking to make sure that you're not

00:47:55,369 --> 00:48:01,190
dragging a holder into itself and that's

00:47:58,760 --> 00:48:05,060
one thing question one little common

00:48:01,190 --> 00:48:09,290
table expression solution your data

00:48:05,060 --> 00:48:13,970
structure and organization

00:48:09,290 --> 00:48:16,340
it has other organizations it point to

00:48:13,970 --> 00:48:20,359
the other so the question is yes so the

00:48:16,340 --> 00:48:23,660
question is would right so the question

00:48:20,359 --> 00:48:28,869
is you have a tree a tree of

00:48:23,660 --> 00:48:31,040
organization think of a high arc of the

00:48:28,869 --> 00:48:33,950
report so you have to be balls at the

00:48:31,040 --> 00:48:36,530
top and then you have vice presidents

00:48:33,950 --> 00:48:38,800
and then you have the exec you know and

00:48:36,530 --> 00:48:43,790
so forth it works on down and then

00:48:38,800 --> 00:48:45,290
Richard hip down here and the yeah and

00:48:43,790 --> 00:48:51,290
so you might want to say well what is

00:48:45,290 --> 00:48:52,580
the total salary are ya what does it

00:48:51,290 --> 00:48:55,270
totals how and everybody in this

00:48:52,580 --> 00:48:59,240
organization work or what does the total

00:48:55,270 --> 00:49:02,359
monthly expense for everybody under john

00:48:59,240 --> 00:49:03,650
smith's organization yes we can you

00:49:02,359 --> 00:49:06,109
could use the recursive common table

00:49:03,650 --> 00:49:08,390
expression to go and walk that that

00:49:06,109 --> 00:49:10,490
graph down and find who all is under him

00:49:08,390 --> 00:49:12,320
both his direct reports to those that

00:49:10,490 --> 00:49:15,859
report him and the ones that reported

00:49:12,320 --> 00:49:18,350
and so forth oh now yes that's exactly

00:49:15,859 --> 00:49:20,510
what his for it's very very good for

00:49:18,350 --> 00:49:26,390
walking a tree that way that's exactly

00:49:20,510 --> 00:49:29,119
what she's more question are here in

00:49:26,390 --> 00:49:31,910
front is this something that people

00:49:29,119 --> 00:49:33,890
would do this all monte carlo modeling

00:49:31,910 --> 00:49:35,869
it the way this is something people

00:49:33,890 --> 00:49:36,920
would do monte carlo modeling i have

00:49:35,869 --> 00:49:40,640
never thought of that

00:49:36,920 --> 00:49:43,130
i doesn't seem to me to be a

00:49:40,640 --> 00:49:46,130
particularly good thing to do right hand

00:49:43,130 --> 00:49:47,660
but if you've got an idea I'm open to

00:49:46,130 --> 00:49:49,940
hearing it may be may be said I don't

00:49:47,660 --> 00:49:52,520
know but mostly it's really used for

00:49:49,940 --> 00:49:59,990
solving hierarchy or walking of grass

00:49:52,520 --> 00:50:04,100
walking a tree I think in a version

00:49:59,990 --> 00:50:05,600
control system you've got a tree of you

00:50:04,100 --> 00:50:07,220
know you've got one check-in and then

00:50:05,600 --> 00:50:09,350
all of its descendants are all of the

00:50:07,220 --> 00:50:14,740
ancestors it's really good at walking

00:50:09,350 --> 00:50:14,740
the tree and finding what they are like

00:50:15,070 --> 00:50:24,960
I'm hearing databases

00:50:18,840 --> 00:50:27,850
perhaps hurt why are graphically a small

00:50:24,960 --> 00:50:29,980
why are the graph databases all the rage

00:50:27,850 --> 00:50:32,950
I haven't heard anything about a crafted

00:50:29,980 --> 00:50:35,050
base and ten years are they are they

00:50:32,950 --> 00:50:39,190
still all the rage am I just missing out

00:50:35,050 --> 00:50:43,350
on it apparently they're coming in yeah

00:50:39,190 --> 00:50:48,160
well you know I don't know maybe people

00:50:43,350 --> 00:50:58,990
do not know about maybe do you have a

00:50:48,160 --> 00:51:01,150
comment on that yeah I think rad store

00:50:58,990 --> 00:51:05,110
and I'm like yeah you know like we can

00:51:01,150 --> 00:51:09,790
do all those I think it's really

00:51:05,110 --> 00:51:11,590
optimized to do the class you know I

00:51:09,790 --> 00:51:14,800
don't think post-christmas will optimize

00:51:11,590 --> 00:51:21,030
because everything comes to her as well

00:51:14,800 --> 00:51:21,030
you've got overhead so the question is

00:51:21,510 --> 00:51:29,680
you know you need something actually or

00:51:27,460 --> 00:51:32,770
you really need something that can do

00:51:29,680 --> 00:51:36,550
all these things together and have you

00:51:32,770 --> 00:51:39,610
know it's really important especially so

00:51:36,550 --> 00:51:52,810
so Bruce's answer was that a graph

00:51:39,610 --> 00:51:56,970
database is a premature optimization oh

00:51:52,810 --> 00:51:59,650
that was a very first one yeah homeboy

00:51:56,970 --> 00:52:02,010
is there a home button here right on the

00:51:59,650 --> 00:52:02,010
keyboard

00:52:10,930 --> 00:52:14,960
for the benefit of those on video

00:52:13,519 --> 00:52:19,519
everybody's taking it make sure that's

00:52:14,960 --> 00:52:21,109
live questions here if you were like if

00:52:19,519 --> 00:52:25,609
you wanted to take everything out of the

00:52:21,109 --> 00:52:27,200
databases take everything out of a

00:52:25,609 --> 00:52:28,249
native agent make it XML why would you

00:52:27,200 --> 00:52:36,019
want to do that

00:52:28,249 --> 00:52:40,670
oh excuse just that was that's so 2008

00:52:36,019 --> 00:52:42,319
on yeah you know I hear a lot of people

00:52:40,670 --> 00:52:45,349
talking up so we're just going to extort

00:52:42,319 --> 00:52:47,420
a smart blossom we're Postgres

00:52:45,349 --> 00:52:50,749
accommodating this now by having be JSON

00:52:47,420 --> 00:52:54,200
data types you know that's but really

00:52:50,749 --> 00:52:56,720
but but I guess there is some argument

00:52:54,200 --> 00:52:58,339
in favor of having higher storage but a

00:52:56,720 --> 00:52:59,839
lot of people that they weren't just go

00:52:58,339 --> 00:53:02,589
stored in JSON a parse it they're

00:52:59,839 --> 00:53:05,359
missing this whole query planner point

00:53:02,589 --> 00:53:06,769
because so many people they're raised on

00:53:05,359 --> 00:53:09,619
everything has to be procedural they

00:53:06,769 --> 00:53:11,779
don't really get the whole concept of of

00:53:09,619 --> 00:53:13,279
a declarative programming language where

00:53:11,779 --> 00:53:15,559
you just throw in the query over the

00:53:13,279 --> 00:53:17,799
wall and letting the database you can do

00:53:15,559 --> 00:53:20,569
all the work of programming for you and

00:53:17,799 --> 00:53:21,769
they feel people just don't think

00:53:20,569 --> 00:53:23,690
they're not comfortable with it they

00:53:21,769 --> 00:53:27,140
weren't thought of the minister told Lou

00:53:23,690 --> 00:53:30,319
and and if all you ever seen in this

00:53:27,140 --> 00:53:34,730
dwell is is pulling out records by their

00:53:30,319 --> 00:53:36,349
primary key yeah and storing things as

00:53:34,730 --> 00:53:39,109
JSON seems like a perfectly reasonable

00:53:36,349 --> 00:53:40,880
solution now there's this infer do an

00:53:39,109 --> 00:53:43,489
actual work this is just a collect like

00:53:40,880 --> 00:53:45,619
removing some some descriptions from one

00:53:43,489 --> 00:53:47,749
place to another and moving descriptions

00:53:45,619 --> 00:53:49,309
from one place to another other way you

00:53:47,749 --> 00:53:54,739
can get kind of an application file

00:53:49,309 --> 00:53:58,549
format I like to this is this is kind of

00:53:54,739 --> 00:54:01,940
getting off topic I like to advocate

00:53:58,549 --> 00:54:05,569
SQLite as an application file format

00:54:01,940 --> 00:54:10,160
with one it is a single Hana updates are

00:54:05,569 --> 00:54:11,839
a tonic transactional so that if your

00:54:10,160 --> 00:54:13,880
navigation file is a big row of juice on

00:54:11,839 --> 00:54:16,800
and you're making a change to it and you

00:54:13,880 --> 00:54:19,170
lose power in the middle of that you

00:54:16,800 --> 00:54:22,290
probably just trashed your application

00:54:19,170 --> 00:54:26,250
file but with the database you don't

00:54:22,290 --> 00:54:28,290
have a comma and come up with depends on

00:54:26,250 --> 00:54:29,580
your file system no probably if it's big

00:54:28,290 --> 00:54:32,370
enough it's going to trash your data

00:54:29,580 --> 00:54:36,870
file and especially if you forget you're

00:54:32,370 --> 00:54:41,100
doing it we have anyway but also you

00:54:36,870 --> 00:54:43,530
could have you tables OpenOffice right

00:54:41,100 --> 00:54:50,810
here you know the font on that program

00:54:43,530 --> 00:54:53,730
office is a zip archive it's it has an

00:54:50,810 --> 00:54:55,890
opt-in on it but it's really easy it

00:54:53,730 --> 00:54:59,070
really should be skipped inside lane

00:54:55,890 --> 00:55:02,220
with a docx it's got a bunch of xpx has

00:54:59,070 --> 00:55:04,500
got a bunch of XML and then like every

00:55:02,220 --> 00:55:06,870
image and all these other resources are

00:55:04,500 --> 00:55:11,220
separate file and then there and so when

00:55:06,870 --> 00:55:14,250
I open an open office document it undoes

00:55:11,220 --> 00:55:16,320
the entire archive and load everything

00:55:14,250 --> 00:55:19,680
in the memory Parsons of all this XML

00:55:16,320 --> 00:55:21,840
and so on most it's not such a big deal

00:55:19,680 --> 00:55:24,900
with these nice modern machines but all

00:55:21,840 --> 00:55:27,540
older machines and the kinds of when I

00:55:24,900 --> 00:55:29,340
do a two hundred slide tall you open it

00:55:27,540 --> 00:55:30,810
I think you just wait even a full bar

00:55:29,340 --> 00:55:33,960
that's good too cause this is a business

00:55:30,810 --> 00:55:38,550
it's updating uploaded and then akt1

00:55:33,960 --> 00:55:41,520
tear during a Chris file Sade and I ever

00:55:38,550 --> 00:55:45,330
write out 30 megabytes or to change one

00:55:41,520 --> 00:55:47,040
character if it's a database though you

00:55:45,330 --> 00:55:49,260
can only just read and what you need

00:55:47,040 --> 00:55:51,960
your queries for the first slide and it

00:55:49,260 --> 00:55:53,160
pops up immediately and then if you

00:55:51,960 --> 00:55:54,960
change the secret character

00:55:53,160 --> 00:55:56,340
it just might tell that you know that

00:55:54,960 --> 00:56:00,570
the one little bit it needs to change

00:55:56,340 --> 00:56:02,040
the rest of the file hasn't changed she

00:56:00,570 --> 00:56:08,100
obtained all the slideshows should be

00:56:02,040 --> 00:56:10,500
SQL a really there was a bug and of an

00:56:08,100 --> 00:56:13,650
office of pernicious bug with one for

00:56:10,500 --> 00:56:17,220
ages and ages where on sometimes when

00:56:13,650 --> 00:56:19,560
you do a file save it would just corrupt

00:56:17,220 --> 00:56:23,400
JPEGs that you had that you were

00:56:19,560 --> 00:56:26,940
inserted for hope everything makes on

00:56:23,400 --> 00:56:28,500
pages that you have not even edited I've

00:56:26,940 --> 00:56:29,280
got two minutes we'll talk about those

00:56:28,500 --> 00:56:34,140
natural to have a

00:56:29,280 --> 00:56:36,120
any other questions not fun question

00:56:34,140 --> 00:56:37,800
look forward profile like these

00:56:36,120 --> 00:56:39,360
recursive common table expression what

00:56:37,800 --> 00:56:40,800
is it if we form this profile like in

00:56:39,360 --> 00:56:43,290
these common tables it's critical

00:56:40,800 --> 00:56:45,800
let's--oh is that including a bunch of

00:56:43,290 --> 00:56:48,510
statements something from the

00:56:45,800 --> 00:56:50,160
probably it will run faster than you

00:56:48,510 --> 00:56:52,680
could do it yourself on the application

00:56:50,160 --> 00:56:55,290
time now if there will be intentions to

00:56:52,680 --> 00:56:57,000
that yeah it's it's kind of a difference

00:56:55,290 --> 00:57:00,900
between a similar language versus the

00:56:57,000 --> 00:57:03,270
high level language okay doing water in

00:57:00,900 --> 00:57:06,600
Python on the application side as a

00:57:03,270 --> 00:57:11,040
simpler language putting it in SQL query

00:57:06,600 --> 00:57:13,140
is a high level language in theory you

00:57:11,040 --> 00:57:15,570
can always do it faster yourself a

00:57:13,140 --> 00:57:17,880
failing language but in practice you've

00:57:15,570 --> 00:57:18,690
got so much of it you'll never beat the

00:57:17,880 --> 00:57:21,180
optimizer

00:57:18,690 --> 00:57:25,170
so just to an SQL it's going to be the

00:57:21,180 --> 00:57:26,040
mean better practice you're doing it

00:57:25,170 --> 00:57:28,140
yourself

00:57:26,040 --> 00:57:30,060
you're a view of the whole round-trip

00:57:28,140 --> 00:57:32,910
network to get it back for through the

00:57:30,060 --> 00:57:34,440
horsemen select whereas when you're

00:57:32,910 --> 00:57:35,340
doing is a common table question that

00:57:34,440 --> 00:57:38,610
whole Lobby

00:57:35,340 --> 00:57:41,670
once it's one transfer to the

00:57:38,610 --> 00:57:43,590
application of your result you never

00:57:41,670 --> 00:57:46,050
going to eat that if you try to walk

00:57:43,590 --> 00:57:49,020
enough and for the audio bruiser

00:57:46,050 --> 00:57:50,910
pointing out that you also if you're

00:57:49,020 --> 00:57:53,040
doing it with common cable expression

00:57:50,910 --> 00:57:54,690
you you don't have the round trip server

00:57:53,040 --> 00:57:57,050
time to take into account in system

00:57:54,690 --> 00:57:59,850
that's that's going to adhere the horns

00:57:57,050 --> 00:58:02,610
so yeah then they usually want a little

00:57:59,850 --> 00:58:04,680
bit go go to knowledge premature

00:58:02,610 --> 00:58:06,360
optimize go with the comment able to

00:58:04,680 --> 00:58:09,630
trace the first it turns out the games

00:58:06,360 --> 00:58:11,300
do slow then you can and we have 30

00:58:09,630 --> 00:58:15,470
seconds one more question

00:58:11,300 --> 00:58:15,470
we're done thank you very much

00:58:32,110 --> 00:58:34,170
you

00:58:36,680 --> 00:58:38,740
you

01:03:07,050 --> 01:03:11,910
access its individual dashboard then

01:03:09,750 --> 01:03:14,610
click and drag to zoom in on chokepoints

01:03:11,910 --> 01:03:16,590
and get more detail comprehensive

01:03:14,610 --> 01:03:18,540
network data including inbound and

01:03:16,590 --> 01:03:20,670
outbound traffic is available on the

01:03:18,540 --> 01:03:22,980
network tab and disk rights and free

01:03:20,670 --> 01:03:25,620
space on the disk stab while the process

01:03:22,980 --> 01:03:28,530
Explorer displays usage statistics for

01:03:25,620 --> 01:03:30,510
individual processes the system info tab

01:03:28,530 --> 01:03:32,820
shows listening services active

01:03:30,510 --> 01:03:35,220
connections and available updates adding

01:03:32,820 --> 01:03:36,720
longview to a system is easy just click

01:03:35,220 --> 01:03:38,610
the button copy the one-line

01:03:36,720 --> 01:03:40,470
installation command then run the

01:03:38,610 --> 01:03:42,510
command on your Linux system to complete

01:03:40,470 --> 01:03:44,370
the process the agent will begin

01:03:42,510 --> 01:03:48,090
collecting data and sending it to long

01:03:44,370 --> 01:03:50,100
view then the graphs start rolling use

01:03:48,090 --> 01:03:52,110
long view to gain visibility into your

01:03:50,100 --> 01:03:56,060
servers so when your website or app

01:03:52,110 --> 01:03:56,060
heats up it stays up

01:05:20,270 --> 01:05:22,330

YouTube URL: https://www.youtube.com/watch?v=MvLJqi0FQoA


