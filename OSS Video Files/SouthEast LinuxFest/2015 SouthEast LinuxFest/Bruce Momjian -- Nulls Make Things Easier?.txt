Title: Bruce Momjian -- Nulls Make Things Easier?
Publication date: 2017-01-25
Playlist: 2015 SouthEast LinuxFest
Description: 
	
Captions: 
	00:08:29,370 --> 00:08:34,320
we have one null it's got to fit all

00:08:31,290 --> 00:08:38,279
three of these cases okay we didn't

00:08:34,320 --> 00:08:42,029
implement more than one no so um those

00:08:38,279 --> 00:08:46,589
can cause their own problems this is the

00:08:42,029 --> 00:08:49,860
famous um you know the the the reason I

00:08:46,589 --> 00:08:51,510
remember this kind of thing is that we I

00:08:49,860 --> 00:08:53,400
used to do repair construction equipment

00:08:51,510 --> 00:08:55,650
and we had like jackhammers was my

00:08:53,400 --> 00:08:57,300
specialty so we have a little chart of

00:08:55,650 --> 00:08:59,880
what to do and there's like a joke chart

00:08:57,300 --> 00:09:01,529
and they had like a nut it was neural

00:08:59,880 --> 00:09:03,870
you know has like little lines on it and

00:09:01,529 --> 00:09:06,360
it said it had a picture the nut said

00:09:03,870 --> 00:09:08,940
knurled for vice grip twerking you know

00:09:06,360 --> 00:09:12,990
so they knurled it just so the vice grip

00:09:08,940 --> 00:09:14,400
could could to get what is really what

00:09:12,990 --> 00:09:15,720
you don't want to do so this is the kind

00:09:14,400 --> 00:09:16,920
of thing don't do that even though it

00:09:15,720 --> 00:09:19,380
looks like that's exactly what it's

00:09:16,920 --> 00:09:20,940
supposed to do that's not actually why

00:09:19,380 --> 00:09:24,810
they have little lines on the on the

00:09:20,940 --> 00:09:26,460
bolt um so again you have to be very

00:09:24,810 --> 00:09:27,660
careful knows only use them in

00:09:26,460 --> 00:09:29,880
situations where you consider

00:09:27,660 --> 00:09:32,070
appropriate in fact I would argue that

00:09:29,880 --> 00:09:33,900
the not null specification for columns

00:09:32,070 --> 00:09:36,779
should be used much more aggressively

00:09:33,900 --> 00:09:39,540
than they do in fact I have another talk

00:09:36,779 --> 00:09:41,100
where I basically say that the common

00:09:39,540 --> 00:09:43,500
pattern that people use with a defined a

00:09:41,100 --> 00:09:45,930
table right create table tablename and

00:09:43,500 --> 00:09:48,120
what do you think and I'm from the 90s

00:09:45,930 --> 00:09:50,370
when we used talk regular databases that

00:09:48,120 --> 00:09:52,080
weren't sophisticated and I don't think

00:09:50,370 --> 00:09:56,730
people can hear me now on my school my

00:09:52,080 --> 00:10:00,959
thing but anyway um so when you say

00:09:56,730 --> 00:10:03,959
column name and then data type your

00:10:00,959 --> 00:10:08,540
natural inclination is to do what comma

00:10:03,959 --> 00:10:12,690
am i right call name data type comma

00:10:08,540 --> 00:10:16,440
come and data type comma and what you're

00:10:12,690 --> 00:10:18,900
losing is a whole expressive language of

00:10:16,440 --> 00:10:22,080
constraints not all check constraints

00:10:18,900 --> 00:10:25,290
primary keys a whole whole language that

00:10:22,080 --> 00:10:27,779
allows you to more accurately lock down

00:10:25,290 --> 00:10:29,279
your data and prevent those weekends

00:10:27,779 --> 00:10:31,980
where we have to figure out why a report

00:10:29,279 --> 00:10:34,920
doesn't balance anymore um those can be

00:10:31,980 --> 00:10:36,600
eliminated if at creation time every

00:10:34,920 --> 00:10:38,280
time you create a column you're thinking

00:10:36,600 --> 00:10:39,750
do I want Knowles in this column do I

00:10:38,280 --> 00:10:41,640
want to check constraint this column is

00:10:39,750 --> 00:10:43,290
this calm unique is calmer primary key

00:10:41,640 --> 00:10:44,940
uh you know there's

00:10:43,290 --> 00:10:47,279
bunch of constraints that postgres

00:10:44,940 --> 00:10:50,730
emotion system support that a lot of

00:10:47,279 --> 00:10:54,120
times don't get added to databases until

00:10:50,730 --> 00:10:56,279
after you've had a couple those

00:10:54,120 --> 00:10:57,839
weekend's where the system doesn't match

00:10:56,279 --> 00:10:59,639
and you can't forget why and then you

00:10:57,839 --> 00:11:01,319
have to figure out how the data got in

00:10:59,639 --> 00:11:06,420
there and you could have prevented all

00:11:01,319 --> 00:11:08,639
along okay so um this is not new I'd

00:11:06,420 --> 00:11:10,170
love to say I am like the person who's

00:11:08,639 --> 00:11:13,370
figured of this all out but it's totally

00:11:10,170 --> 00:11:16,860
not true uh the only reason I wrote this

00:11:13,370 --> 00:11:19,230
this so slide deck is because we have

00:11:16,860 --> 00:11:21,329
hit this so many times with postgres

00:11:19,230 --> 00:11:23,759
users we have it so many it's so

00:11:21,329 --> 00:11:27,120
confusing but in fact the confusion

00:11:23,759 --> 00:11:29,940
dates back to when of the ethical joke

00:11:27,120 --> 00:11:33,120
dates back you get better yeah CJ date

00:11:29,940 --> 00:11:35,720
up there um dates back to these couple

00:11:33,120 --> 00:11:40,350
people are still not sure what I said um

00:11:35,720 --> 00:11:43,829
CJ day was the father SQL and Joe cellco

00:11:40,350 --> 00:11:47,339
here is critiquing his design for nulls

00:11:43,829 --> 00:11:49,139
and in fact right at the top and Joe

00:11:47,339 --> 00:11:50,519
cellco has spoken it postgres

00:11:49,139 --> 00:11:53,819
conferences I think he spoke at it two

00:11:50,519 --> 00:11:56,760
of them actually one in Prague and I

00:11:53,819 --> 00:11:58,920
think he's going to speak this here in

00:11:56,760 --> 00:12:00,930
Ottawa or less this year at least you

00:11:58,920 --> 00:12:02,670
know anyway he's he gets around he's

00:12:00,930 --> 00:12:06,420
very friendly to postgres but he says

00:12:02,670 --> 00:12:08,660
about nulls back in in his book SQL for

00:12:06,420 --> 00:12:10,980
Smarties advances core programming arm

00:12:08,660 --> 00:12:12,690
it is this writer's opinion that nulls

00:12:10,980 --> 00:12:16,319
at least is currently defined and

00:12:12,690 --> 00:12:19,740
implemented in SQL are far more trouble

00:12:16,319 --> 00:12:23,610
than they are worth you gotta love that

00:12:19,740 --> 00:12:26,160
uh and should be avoided they display

00:12:23,610 --> 00:12:28,889
very strange and inconsistent behavior

00:12:26,160 --> 00:12:31,740
and could be a rich rich source of error

00:12:28,889 --> 00:12:36,360
right just I like that rich source of

00:12:31,740 --> 00:12:38,550
error um and confusion yes please note

00:12:36,360 --> 00:12:40,620
that these comments and criticism ply to

00:12:38,550 --> 00:12:42,930
any system that supports SQL style model

00:12:40,620 --> 00:12:44,579
not just SQL Server specifically I guess

00:12:42,930 --> 00:12:47,100
he was talking about something and the

00:12:44,579 --> 00:12:49,709
rest of the book this is this is sort of

00:12:47,100 --> 00:12:52,980
the sausage part in the rest of the book

00:12:49,709 --> 00:12:55,410
I will be urging you not to use them

00:12:52,980 --> 00:12:57,240
which mace I'm sorry in the rest of them

00:12:55,410 --> 00:12:59,550
I will be urging you to use them

00:12:57,240 --> 00:13:02,610
which may seem contradictory but it is

00:12:59,550 --> 00:13:04,980
not think of a null as a drug user

00:13:02,610 --> 00:13:07,370
properly and it works for you uh but

00:13:04,980 --> 00:13:10,410
abuse it and it can ruin everything uh

00:13:07,370 --> 00:13:13,080
your best policy to avoid knows when you

00:13:10,410 --> 00:13:16,529
can and use them properly when you have

00:13:13,080 --> 00:13:18,209
two great great wisdom there um was

00:13:16,529 --> 00:13:21,060
again out of his book i think it's i

00:13:18,209 --> 00:13:22,380
think it just says a lot um and and it

00:13:21,060 --> 00:13:25,050
sort of says we're not this is not

00:13:22,380 --> 00:13:27,480
virgin territory here is this territory

00:13:25,050 --> 00:13:30,990
that that unfortunately all these these

00:13:27,480 --> 00:13:35,160
sort of pillars of relational history

00:13:30,990 --> 00:13:38,010
have also been in our shoes uh so um a

00:13:35,160 --> 00:13:40,200
lot of texts here in this slides so

00:13:38,010 --> 00:13:42,750
you're gonna see a lot of queries when

00:13:40,200 --> 00:13:44,610
you see a query keep your eye on the red

00:13:42,750 --> 00:13:46,709
because that's the point that I'm

00:13:44,610 --> 00:13:49,050
highlighting for you is that the red

00:13:46,709 --> 00:13:50,940
part of the query and the rest of the

00:13:49,050 --> 00:13:54,600
pars just there for kind of window

00:13:50,940 --> 00:13:58,500
dressing um so let's start with a very

00:13:54,600 --> 00:14:00,180
simple case here uh explicit nulls so

00:13:58,500 --> 00:14:02,130
innocent game this is all going to be

00:14:00,180 --> 00:14:05,940
postgres based and again keep your eye

00:14:02,130 --> 00:14:07,950
on the red text arm actually let me ask

00:14:05,940 --> 00:14:11,029
does anybody any questions so far again

00:14:07,950 --> 00:14:13,950
I want to take questions while I go okay

00:14:11,029 --> 00:14:17,220
people are too entertained okay I so

00:14:13,950 --> 00:14:19,380
select null that's an explicit null that

00:14:17,220 --> 00:14:23,160
I'm asking for I'm saying give me a null

00:14:19,380 --> 00:14:26,910
and you get an astounding nothing it's

00:14:23,160 --> 00:14:28,620
just blank arm this actually gets into

00:14:26,910 --> 00:14:31,260
one of the problems I believe that s

00:14:28,620 --> 00:14:33,600
that Oracle has where they considers

00:14:31,260 --> 00:14:36,120
your length strings to be Knowles uh is

00:14:33,600 --> 00:14:38,220
really ugly they look the same so why

00:14:36,120 --> 00:14:40,290
can't we tree in the same uh you know

00:14:38,220 --> 00:14:42,500
there's that logic to that post Chris

00:14:40,290 --> 00:14:46,200
does not do that we're actually very

00:14:42,500 --> 00:14:48,180
finicky about that um almost any place

00:14:46,200 --> 00:14:49,770
where we're going to place a null it

00:14:48,180 --> 00:14:51,360
will be it was always distinguish from

00:14:49,770 --> 00:14:53,730
zero length string for example the copy

00:14:51,360 --> 00:14:56,160
output would use backslash capital in

00:14:53,730 --> 00:15:03,360
for a null versus a zero length string

00:14:56,160 --> 00:15:06,449
yes sir so as a great question so isn't

00:15:03,360 --> 00:15:08,699
a zero length string all terminated it

00:15:06,449 --> 00:15:10,920
is it is and that gets back to that

00:15:08,699 --> 00:15:13,980
slide where I actually

00:15:10,920 --> 00:15:15,480
complain that see kind of has this nulls

00:15:13,980 --> 00:15:18,089
going mobile eight directions at the

00:15:15,480 --> 00:15:21,360
same time um so there is sort of a logic

00:15:18,089 --> 00:15:24,660
to her saying that um but it it bleeds

00:15:21,360 --> 00:15:26,880
to a lot of confusion in in relational

00:15:24,660 --> 00:15:30,779
design when you have that happening arm

00:15:26,880 --> 00:15:34,880
I had one there was one a system I think

00:15:30,779 --> 00:15:37,800
I work with informix when they dumped uh

00:15:34,880 --> 00:15:41,699
no out they dumped it out as a

00:15:37,800 --> 00:15:44,220
zero-length string so when you import is

00:15:41,699 --> 00:15:46,920
your like string it became a null but

00:15:44,220 --> 00:15:51,480
when you out put a zero like string it

00:15:46,920 --> 00:15:54,570
came as a single spaced so no became no

00:15:51,480 --> 00:15:57,380
one out as his ear like string as zero

00:15:54,570 --> 00:16:00,389
like string came out as a single space

00:15:57,380 --> 00:16:03,750
so that works like when you bring it out

00:16:00,389 --> 00:16:07,740
and back in again but a single space

00:16:03,750 --> 00:16:10,050
also came out as a single space and way

00:16:07,740 --> 00:16:13,199
back in his ear like string okay so

00:16:10,050 --> 00:16:15,180
because I so cuz I remember looking this

00:16:13,199 --> 00:16:16,620
is when I in the late nineties i was

00:16:15,180 --> 00:16:18,860
working on postgres we got it from

00:16:16,620 --> 00:16:21,149
berkeley we're looking at the design and

00:16:18,860 --> 00:16:24,630
were like looking at how the nulls are

00:16:21,149 --> 00:16:27,990
handled and I'm like uh this doesn't

00:16:24,630 --> 00:16:29,250
look right like we I had dealt enough

00:16:27,990 --> 00:16:32,130
with informix to know that when a

00:16:29,250 --> 00:16:33,560
database doesn't load dumps out data and

00:16:32,130 --> 00:16:35,670
loaded in differently there went in

00:16:33,560 --> 00:16:38,160
somebody that will bite somebody that's

00:16:35,670 --> 00:16:40,410
just your just don't even go there right

00:16:38,160 --> 00:16:42,630
and when I tested postgres there was

00:16:40,410 --> 00:16:45,720
these really weird edge cases where we

00:16:42,630 --> 00:16:47,970
didn't do it in fact it was a 97 very

00:16:45,720 --> 00:16:50,610
early when I basically implemented the

00:16:47,970 --> 00:16:53,070
backslash capital and for null so you

00:16:50,610 --> 00:16:55,199
always got this unique string out and a

00:16:53,070 --> 00:16:56,819
backslash would be a little back so

00:16:55,199 --> 00:16:59,100
should be double backslash so that we

00:16:56,819 --> 00:17:01,829
already had a backslash but informix

00:16:59,100 --> 00:17:04,949
didn't have that back / escape mechanism

00:17:01,829 --> 00:17:07,020
so like if you had a new lining data

00:17:04,949 --> 00:17:08,790
what would load in anymore because it

00:17:07,020 --> 00:17:10,890
was long was done but it wasn't done

00:17:08,790 --> 00:17:12,630
right suppose Chris when it has new life

00:17:10,890 --> 00:17:15,270
does backslash and so it knows it's not

00:17:12,630 --> 00:17:18,449
a real new line for the copy it's

00:17:15,270 --> 00:17:19,890
actually like part of the data um so I

00:17:18,449 --> 00:17:21,990
would've loved dr. have to implement

00:17:19,890 --> 00:17:23,970
like special home for noel's but you had

00:17:21,990 --> 00:17:24,430
to because you had to make sure you gave

00:17:23,970 --> 00:17:26,950
something

00:17:24,430 --> 00:17:29,980
unique that never could appears data

00:17:26,950 --> 00:17:32,830
because someone will have data someone

00:17:29,980 --> 00:17:34,630
will have that single space that will

00:17:32,830 --> 00:17:36,790
not load in the same and it will do

00:17:34,630 --> 00:17:39,250
something horrific you know so you just

00:17:36,790 --> 00:17:42,550
don't want to do that um one interesting

00:17:39,250 --> 00:17:44,740
thing that you can do in psql you can

00:17:42,550 --> 00:17:47,260
actually ask the system to give you a

00:17:44,740 --> 00:17:49,270
null with a special like flag so a

00:17:47,260 --> 00:17:51,010
special string so instead of writing

00:17:49,270 --> 00:17:52,660
this and getting nothing out you get

00:17:51,010 --> 00:17:55,300
actually the string so here I'm actually

00:17:52,660 --> 00:17:57,640
using say P set null and using this

00:17:55,300 --> 00:18:00,550
special string and again I get the

00:17:57,640 --> 00:18:03,970
special string out right so that you

00:18:00,550 --> 00:18:05,500
know that works really good arm you and

00:18:03,970 --> 00:18:07,960
I'm going to actually use that special

00:18:05,500 --> 00:18:09,690
string most of the slide so kind of like

00:18:07,960 --> 00:18:12,160
when you see a no it's going to come out

00:18:09,690 --> 00:18:14,620
literally just so we can see it because

00:18:12,160 --> 00:18:16,660
again it's got that in ephemeral and I'm

00:18:14,620 --> 00:18:20,440
sure there's some you know Homeric uh

00:18:16,660 --> 00:18:25,270
you know allusion to this or a whole

00:18:20,440 --> 00:18:27,520
bunch of stuff with uh you know the when

00:18:25,270 --> 00:18:30,940
he be strapped to the mast he goes by

00:18:27,520 --> 00:18:33,550
the island with the women and he's got

00:18:30,940 --> 00:18:35,590
the monsters called no body or something

00:18:33,550 --> 00:18:37,720
is the same kind of double meaning kind

00:18:35,590 --> 00:18:40,210
of confusion here that has little

00:18:37,720 --> 00:18:42,130
existed forever so um let's take a look

00:18:40,210 --> 00:18:43,390
at explicit null assignment this is

00:18:42,130 --> 00:18:45,550
where we're actually putting a null in

00:18:43,390 --> 00:18:47,920
the database for for some reason that we

00:18:45,550 --> 00:18:50,290
actually hope is the right reason so

00:18:47,920 --> 00:18:52,420
we're here saying insert into here null

00:18:50,290 --> 00:18:54,460
test we create a table two columns one

00:18:52,420 --> 00:18:56,230
and then the null value and literally

00:18:54,460 --> 00:18:58,300
the null value comes out and again I've

00:18:56,230 --> 00:19:00,520
specially flagged it wouldn't normally

00:18:58,300 --> 00:19:02,320
come out as nothing but we specially

00:19:00,520 --> 00:19:06,010
flagged it here to say now there's

00:19:02,320 --> 00:19:08,020
nothing there okay um another case and

00:19:06,010 --> 00:19:10,960
this is this is an explicit null

00:19:08,020 --> 00:19:12,520
assignment this is an implicit no

00:19:10,960 --> 00:19:14,350
assignment this is where it starts to

00:19:12,520 --> 00:19:17,820
get a little interesting now you don't

00:19:14,350 --> 00:19:20,920
see a null anywhere in this line here

00:19:17,820 --> 00:19:23,110
right remember I said earlier that

00:19:20,920 --> 00:19:27,400
number three the third case of nulls is

00:19:23,110 --> 00:19:29,170
cases where the SQL requires a null you

00:19:27,400 --> 00:19:31,510
don't explicitly put it in it just shows

00:19:29,170 --> 00:19:34,450
up this is a case work shows up the

00:19:31,510 --> 00:19:37,420
reason it shows up is because I have two

00:19:34,450 --> 00:19:38,340
columns in this table but I'm only

00:19:37,420 --> 00:19:41,100
supposed

00:19:38,340 --> 00:19:43,500
being one of them and because the row

00:19:41,100 --> 00:19:45,600
has to have both calm because again it's

00:19:43,500 --> 00:19:48,029
a relational system has every row is the

00:19:45,600 --> 00:19:52,169
same number of columns I did not give a

00:19:48,029 --> 00:19:55,740
value to Y so I have to put something

00:19:52,169 --> 00:19:57,390
there as in SQL is an internal person I

00:19:55,740 --> 00:20:00,299
have to put something in that row I

00:19:57,390 --> 00:20:01,650
could put 0 now that's actually would

00:20:00,299 --> 00:20:03,929
work because it's an integer I could

00:20:01,650 --> 00:20:05,279
probably put 0 but but what would I put

00:20:03,929 --> 00:20:07,950
for a string a while I prettier

00:20:05,279 --> 00:20:09,840
Langstrom what was your date well I

00:20:07,950 --> 00:20:12,270
don't know right so you start to see

00:20:09,840 --> 00:20:14,220
that if I stride to put special values

00:20:12,270 --> 00:20:16,590
in here it might work for some day types

00:20:14,220 --> 00:20:18,240
not others you get this weird kind of

00:20:16,590 --> 00:20:19,820
case and if you think of some of the non

00:20:18,240 --> 00:20:22,049
relational systems out there like

00:20:19,820 --> 00:20:23,520
paradox and some of the older ones I

00:20:22,049 --> 00:20:25,679
like it they always did like weird

00:20:23,520 --> 00:20:27,090
things with when you mr. they have

00:20:25,679 --> 00:20:29,940
something that specializes something

00:20:27,090 --> 00:20:31,169
didn't so relational systems got rid of

00:20:29,940 --> 00:20:34,770
that and you said if the values not

00:20:31,169 --> 00:20:37,100
supplied it's a null okay so that's a

00:20:34,770 --> 00:20:40,260
great case of a null being generated

00:20:37,100 --> 00:20:42,299
dynamically without be specifying it had

00:20:40,260 --> 00:20:43,860
to put something there it logically put

00:20:42,299 --> 00:20:52,490
in all it will put it over every day to

00:20:43,860 --> 00:20:55,590
type no matter what that is okay um so

00:20:52,490 --> 00:20:59,100
what we can do and we talked about this

00:20:55,590 --> 00:21:02,460
already is the idea of restricting

00:20:59,100 --> 00:21:04,830
columns to not have nulls in them okay

00:21:02,460 --> 00:21:06,960
there's some value to this because all

00:21:04,830 --> 00:21:09,299
of a sudden if I have like customer name

00:21:06,960 --> 00:21:11,460
I really don't want to have a record

00:21:09,299 --> 00:21:13,409
with a null customer name I just I'm not

00:21:11,460 --> 00:21:15,090
going to go there because you can

00:21:13,409 --> 00:21:16,500
imagine how you track that back like

00:21:15,090 --> 00:21:19,260
what customer is it you have to guess

00:21:16,500 --> 00:21:20,909
there's nothing there right so what I've

00:21:19,260 --> 00:21:23,039
done here is I've actually used the

00:21:20,909 --> 00:21:24,419
constraints and I've said here my table

00:21:23,039 --> 00:21:26,399
name and i'm going to say not know for

00:21:24,419 --> 00:21:29,370
this comma not off this calm and now if

00:21:26,399 --> 00:21:32,070
i try and explicitly put a null in i get

00:21:29,370 --> 00:21:34,470
an error because of a violation and if i

00:21:32,070 --> 00:21:37,649
try and implicitly put it all in there i

00:21:34,470 --> 00:21:39,179
get in there okay this is a great

00:21:37,649 --> 00:21:40,799
example of its kind of blocking out

00:21:39,179 --> 00:21:44,190
where we want Knowles where we don't I

00:21:40,799 --> 00:21:48,059
would love to have a mode where you have

00:21:44,190 --> 00:21:50,130
to say I want nulls in a column I mean

00:21:48,059 --> 00:21:52,370
wouldn't that be nice so everything

00:21:50,130 --> 00:21:54,890
would default to not null

00:21:52,370 --> 00:22:12,260
but that's not what's a SQL standard is

00:21:54,890 --> 00:22:15,100
there's no mood for that yes so the

00:22:12,260 --> 00:22:17,090
question is if you wanted to implicitly

00:22:15,100 --> 00:22:18,950
explicitly say Knowles are allowed you

00:22:17,090 --> 00:22:21,260
could put the word null after the field

00:22:18,950 --> 00:22:23,600
after the data type to say I do allow

00:22:21,260 --> 00:22:24,980
moles here but because the default is no

00:22:23,600 --> 00:22:28,700
nobody uses it because it doesn't have

00:22:24,980 --> 00:22:31,040
any meaning right um but yeah so that I

00:22:28,700 --> 00:22:33,080
would love to have had the standard the

00:22:31,040 --> 00:22:36,410
other way the reason it's not that way I

00:22:33,080 --> 00:22:38,240
think is because there's a there's

00:22:36,410 --> 00:22:40,730
probably some pretty complex reasons why

00:22:38,240 --> 00:22:42,320
because if you disallowed nulls would be

00:22:40,730 --> 00:22:45,020
a whole bunch of query types that would

00:22:42,320 --> 00:22:49,280
be kind of weird behaviors particularly

00:22:45,020 --> 00:22:59,840
like an outer join so you know I can see

00:22:49,280 --> 00:23:01,309
why they didn't do that yes sir so not

00:22:59,840 --> 00:23:04,309
know should be a default when defining a

00:23:01,309 --> 00:23:06,950
table but you allow the output from a

00:23:04,309 --> 00:23:10,250
column in an outer join to be null yeah

00:23:06,950 --> 00:23:12,410
that would kind of work but the problem

00:23:10,250 --> 00:23:14,510
yeah that would work yeah cuz you're

00:23:12,410 --> 00:23:15,800
right even if you put not know you can

00:23:14,510 --> 00:23:17,510
still do a joint it would still come out

00:23:15,800 --> 00:23:18,980
so you're right i think there's an

00:23:17,510 --> 00:23:22,160
argument to say that we should allow

00:23:18,980 --> 00:23:23,420
nulls we should we should require people

00:23:22,160 --> 00:23:26,390
to suppose you say which columns they

00:23:23,420 --> 00:23:27,679
want to have nulls arm and unfortunately

00:23:26,390 --> 00:23:29,480
that's not the way the language works

00:23:27,679 --> 00:23:31,940
that we have to write a lot of not know

00:23:29,480 --> 00:23:36,320
or we just do what I didn't just hit the

00:23:31,940 --> 00:23:41,590
column I move on um and I think I think

00:23:36,320 --> 00:23:43,880
in some ways in some ways um how do I

00:23:41,590 --> 00:23:47,320
maybe I don't want to be too harsh but

00:23:43,880 --> 00:23:50,570
in some ways when we're creating a table

00:23:47,320 --> 00:23:53,990
that we're going to use for years we

00:23:50,570 --> 00:23:57,830
kind of created in like two minutes I to

00:23:53,990 --> 00:24:00,500
some extent okay because we're looking

00:23:57,830 --> 00:24:01,910
at and we're like oh I need that table

00:24:00,500 --> 00:24:04,130
let me just go crazy and start putting

00:24:01,910 --> 00:24:06,200
data in it and then like a year later

00:24:04,130 --> 00:24:09,560
like well you know maybe that

00:24:06,200 --> 00:24:11,030
I mean what's the best what or maybe I

00:24:09,560 --> 00:24:12,710
should have put it not and all in there

00:24:11,030 --> 00:24:13,880
or maybe I should have been a different

00:24:12,710 --> 00:24:16,010
data type when I had some chicken

00:24:13,880 --> 00:24:17,510
strength and you can go back and change

00:24:16,010 --> 00:24:19,310
it postgres allows you to do a lot of

00:24:17,510 --> 00:24:21,470
that you can rename columns and add

00:24:19,310 --> 00:24:23,750
changed a touch dad check constraints to

00:24:21,470 --> 00:24:25,340
it but it's ideally it's done at the

00:24:23,750 --> 00:24:27,740
beginning so your application has to be

00:24:25,340 --> 00:24:29,810
retested so again maybe a little caution

00:24:27,740 --> 00:24:31,910
there to be a little more careful at the

00:24:29,810 --> 00:24:33,110
front end the versus the back and

00:24:31,910 --> 00:24:35,330
everything richer when I we're talking

00:24:33,110 --> 00:24:36,910
about not only the creation tables with

00:24:35,330 --> 00:24:40,070
the selection a database is sometimes

00:24:36,910 --> 00:24:42,740
happens at the front end where you're

00:24:40,070 --> 00:24:45,290
looking at a very well-defined API of

00:24:42,740 --> 00:24:47,690
what you want database to do but the

00:24:45,290 --> 00:24:49,310
reality is that two years later that a

00:24:47,690 --> 00:24:51,440
what you're going to need that database

00:24:49,310 --> 00:24:53,440
to do is completely different and if

00:24:51,440 --> 00:24:55,730
you've locked yourself into a certain

00:24:53,440 --> 00:24:56,960
little you know database even if it

00:24:55,730 --> 00:24:59,210
isn't relational you're kind of stuck

00:24:56,960 --> 00:25:00,710
there and it's very hard to kind of

00:24:59,210 --> 00:25:03,230
migrate out it's very hard to know the

00:25:00,710 --> 00:25:05,840
future of course but lack of flexibility

00:25:03,230 --> 00:25:08,330
and choice of table and lack of

00:25:05,840 --> 00:25:12,940
flexibility in terms of database product

00:25:08,330 --> 00:25:16,040
is is is is a concern is a concern arm

00:25:12,940 --> 00:25:19,300
so uh usually get it gets a little kind

00:25:16,040 --> 00:25:22,160
of creepy um we start to get a little

00:25:19,300 --> 00:25:24,650
head to the side kind of look what is

00:25:22,160 --> 00:25:27,200
going on here um here's an example where

00:25:24,650 --> 00:25:29,600
we're actually doing some manipulation

00:25:27,200 --> 00:25:32,690
with nulls and this is where we start to

00:25:29,600 --> 00:25:34,790
to get sort of the what we call the 33

00:25:32,690 --> 00:25:36,110
value logic of SQL which I'll talk about

00:25:34,790 --> 00:25:37,820
in a minute but I'm just going to

00:25:36,110 --> 00:25:41,180
highlight right here so if you take a

00:25:37,820 --> 00:25:43,640
null and you add a number to it you

00:25:41,180 --> 00:25:47,510
getting null because unknown plus one is

00:25:43,640 --> 00:25:50,600
unknown kind of makes sense okay unknown

00:25:47,510 --> 00:25:53,600
uh and you a concatenate a letter to the

00:25:50,600 --> 00:25:55,520
end of it is is unknown uh if you take a

00:25:53,600 --> 00:25:58,070
letter and you can't annul to the end of

00:25:55,520 --> 00:26:04,820
it it's still unknown kind of kind of

00:25:58,070 --> 00:26:06,260
works arm so no is actually this unknown

00:26:04,820 --> 00:26:08,570
value that's where you call the three

00:26:06,260 --> 00:26:09,620
logic three types of logic here so here

00:26:08,570 --> 00:26:12,050
we're going to actually create a table

00:26:09,620 --> 00:26:15,160
we're going to insert a null as one of

00:26:12,050 --> 00:26:19,040
the three rows so we have 31 41 and no

00:26:15,160 --> 00:26:19,970
okay are we the curve is this the cursor

00:26:19,040 --> 00:26:22,100
in this present

00:26:19,970 --> 00:26:24,530
a little little sharper here as i go up

00:26:22,100 --> 00:26:27,620
arm so here here's some we're gonna

00:26:24,530 --> 00:26:29,890
actually process this um so here's what

00:26:27,620 --> 00:26:34,640
you start to skip that tree value thing

00:26:29,890 --> 00:26:36,680
doesn't know equal one arm well this

00:26:34,640 --> 00:26:39,890
unknown equal one I don't know that

00:26:36,680 --> 00:26:42,410
makes sense uh this unknown equal is

00:26:39,890 --> 00:26:44,690
your like string I don't know there's an

00:26:42,410 --> 00:26:49,220
unknown equal another unknown well they

00:26:44,690 --> 00:26:53,300
could be different unknowns by so they

00:26:49,220 --> 00:26:58,820
they don't there's no this one this one

00:26:53,300 --> 00:27:02,870
kills me um is a no less they know plus

00:26:58,820 --> 00:27:05,360
one I don't know right this can catch

00:27:02,870 --> 00:27:07,250
you because when you when you think

00:27:05,360 --> 00:27:10,280
logically you're like well I don't care

00:27:07,250 --> 00:27:12,410
what the number is if I add 12 it's

00:27:10,280 --> 00:27:14,150
going to be bigger I don't really

00:27:12,410 --> 00:27:18,260
there's not a lot of variability there

00:27:14,150 --> 00:27:20,770
um but in fact post gritty SQL standard

00:27:18,260 --> 00:27:23,330
does not allow us to make like heuristic

00:27:20,770 --> 00:27:24,770
understanding of these things so

00:27:23,330 --> 00:27:29,000
therefore we just have to return on them

00:27:24,770 --> 00:27:31,040
okay so no represents an unknown not

00:27:29,000 --> 00:27:32,810
applicable or not assigned it is no data

00:27:31,040 --> 00:27:34,730
types of comparing it to fixed values

00:27:32,810 --> 00:27:37,550
always return to the null so just kind

00:27:34,730 --> 00:27:40,190
of put that the back of your head um so

00:27:37,550 --> 00:27:44,750
we can we can actually do comparisons

00:27:40,190 --> 00:27:46,670
here so um the null actually operates as

00:27:44,750 --> 00:27:49,640
though it were false although isn't

00:27:46,670 --> 00:27:51,650
false um so if I say select one where

00:27:49,640 --> 00:27:53,360
true that's going to be one select one

00:27:51,650 --> 00:27:56,180
we're false that's going to be nothing

00:27:53,360 --> 00:27:59,000
which we expect select one where null

00:27:56,180 --> 00:28:01,070
that's also nothing so even though the

00:27:59,000 --> 00:28:02,690
inner where clause the unknown has the

00:28:01,070 --> 00:28:06,740
effect of a null because the where

00:28:02,690 --> 00:28:09,320
Clause only returns true rose only

00:28:06,740 --> 00:28:11,210
returns true rose than you think that

00:28:09,320 --> 00:28:13,250
means it just doesn't return false rose

00:28:11,210 --> 00:28:16,610
no because we have three volleys logic

00:28:13,250 --> 00:28:18,560
right it returns true lows but it

00:28:16,610 --> 00:28:21,770
doesn't return false rose and it doesn't

00:28:18,560 --> 00:28:23,840
return unknown rose tell me how crazy

00:28:21,770 --> 00:28:25,850
would be if we allowed where to return

00:28:23,840 --> 00:28:27,650
unknown roads that would be like I think

00:28:25,850 --> 00:28:30,560
our whole database systems would blow up

00:28:27,650 --> 00:28:32,030
arm but but you're gonna start to see

00:28:30,560 --> 00:28:33,470
where that actually becomes interesting

00:28:32,030 --> 00:28:35,809
in a minute so uh

00:28:33,470 --> 00:28:40,850
here's let's start to actually work with

00:28:35,809 --> 00:28:43,250
um the sort of the logic here um so and

00:28:40,850 --> 00:28:45,140
no is not false and you gotta kind of

00:28:43,250 --> 00:28:48,980
get that out of your head because if I

00:28:45,140 --> 00:28:50,799
say true true and know that would that

00:28:48,980 --> 00:28:53,809
would kind of make sense was true and

00:28:50,799 --> 00:28:56,390
false would be would be null if it

00:28:53,809 --> 00:29:01,640
doesn't mean your turn false it returns

00:28:56,390 --> 00:29:05,000
I don't know okay and not full not null

00:29:01,640 --> 00:29:08,240
also returns I don't know so you know if

00:29:05,000 --> 00:29:09,650
false if no was false then not false

00:29:08,240 --> 00:29:11,510
would be true but if I could always

00:29:09,650 --> 00:29:13,789
involved um yeah this sounds like a

00:29:11,510 --> 00:29:15,650
stand-up routine because not know not as

00:29:13,789 --> 00:29:21,320
in false then it just turns I don't know

00:29:15,650 --> 00:29:24,049
again yes sir so if I done this with

00:29:21,320 --> 00:29:25,700
MySQL any chance i believe i would hope

00:29:24,049 --> 00:29:27,740
that my sequel it turns the exact same

00:29:25,700 --> 00:29:29,600
results um there's going to be some

00:29:27,740 --> 00:29:32,480
crazy stuff toward the end where I'd use

00:29:29,600 --> 00:29:34,400
some postgres specific stuff but I would

00:29:32,480 --> 00:29:35,720
be surprised if anybody does anything

00:29:34,400 --> 00:29:38,750
different than what i'm showing but I've

00:29:35,720 --> 00:29:44,539
never run it myself however I believe I

00:29:38,750 --> 00:29:46,039
have uh I thought I had a script they

00:29:44,539 --> 00:29:47,990
allowed you to run this on your own but

00:29:46,039 --> 00:30:00,490
I guess I don't have it i thought i had

00:29:47,990 --> 00:30:00,490
written it up but maybe yes sir yes yeah

00:30:03,700 --> 00:30:09,530
okay so Richard hip was saying that he

00:30:07,429 --> 00:30:11,090
did some research on this nulls handling

00:30:09,530 --> 00:30:15,039
across all databases the only difference

00:30:11,090 --> 00:30:15,039
he found was that any

00:30:19,650 --> 00:30:25,590
saying that in informix in sybase right

00:30:22,620 --> 00:30:30,330
no remorse and SQL Server sequel server

00:30:25,590 --> 00:30:35,010
arm they retreat nulls as distinct and

00:30:30,330 --> 00:30:41,790
unique indexes on a unique column they

00:30:35,010 --> 00:30:43,440
do not now when you say returning the

00:30:41,790 --> 00:30:45,330
what do you mean by distinct cuz

00:30:43,440 --> 00:30:47,850
postgres will allow multiple moles in

00:30:45,330 --> 00:30:51,090
unique column so that's really what

00:30:47,850 --> 00:30:53,130
we're talking about oyk so inform is a

00:30:51,090 --> 00:30:55,680
sequel server if you create a unique

00:30:53,130 --> 00:30:56,910
index you will get one no and I column

00:30:55,680 --> 00:31:04,560
and once you put that in there you're

00:30:56,910 --> 00:31:06,000
done in terms adding more nulls and the

00:31:04,560 --> 00:31:07,890
SQL standard can go either way that's

00:31:06,000 --> 00:31:09,150
very interesting I don't even I wasn't

00:31:07,890 --> 00:31:12,750
going to cover that but that's a great

00:31:09,150 --> 00:31:16,920
that's a great uh analysis we had people

00:31:12,750 --> 00:31:21,000
ask about that behavior arm and we've

00:31:16,920 --> 00:31:22,500
always been like uh uh yeah we like the

00:31:21,000 --> 00:31:24,360
fact you can put mobile moles in unique

00:31:22,500 --> 00:31:26,490
index ID we just kinda like that because

00:31:24,360 --> 00:31:27,420
they're unknown so we can more one cuz

00:31:26,490 --> 00:31:29,100
you don't really know if their

00:31:27,420 --> 00:31:32,370
conflicting or not I think that's the

00:31:29,100 --> 00:31:34,650
logic behind it uh no operator

00:31:32,370 --> 00:31:36,420
comparisons this is um again kind of

00:31:34,650 --> 00:31:40,110
interesting remember we have our

00:31:36,420 --> 00:31:42,900
original table here 30 40 and null arm

00:31:40,110 --> 00:31:45,030
if I say give me this is this is where

00:31:42,900 --> 00:31:47,790
people get bitten a lot where people are

00:31:45,030 --> 00:31:50,070
starting to think logically arm don't do

00:31:47,790 --> 00:31:52,070
that uh so here for example I say give

00:31:50,070 --> 00:31:54,180
me everything greater than zero that's

00:31:52,070 --> 00:31:56,850
that's pretty clear that's going to be

00:31:54,180 --> 00:31:58,410
30 and 40 we don't know this value so

00:31:56,850 --> 00:32:00,510
we're not going to return it that makes

00:31:58,410 --> 00:32:02,160
sense give me everything less than zero

00:32:00,510 --> 00:32:04,230
so this is greater than equals year this

00:32:02,160 --> 00:32:07,740
is less than C oh this is where a lot of

00:32:04,230 --> 00:32:10,260
reports I'll get lost this were a lot of

00:32:07,740 --> 00:32:13,290
Miss balance reports financial reports I

00:32:10,260 --> 00:32:14,910
can speak from experience um where where

00:32:13,290 --> 00:32:16,590
when you're writing a report you're

00:32:14,910 --> 00:32:19,440
saying okay this is my book if it's all

00:32:16,590 --> 00:32:23,190
greater than or equal to 0 and here's my

00:32:19,440 --> 00:32:26,040
buckets it's all less than 0 and they

00:32:23,190 --> 00:32:29,520
should add up to the total and when they

00:32:26,040 --> 00:32:31,530
don't you're like why don't they where

00:32:29,520 --> 00:32:32,940
are you that's when that weekend over

00:32:31,530 --> 00:32:35,430
time comes in

00:32:32,940 --> 00:32:37,950
worth usually for me with Friday nights

00:32:35,430 --> 00:32:39,840
in the law firm with one of the staff

00:32:37,950 --> 00:32:40,950
trying to figure out why we can't close

00:32:39,840 --> 00:32:43,110
the month because we can't figure out

00:32:40,950 --> 00:32:45,030
why we're balancing because we were

00:32:43,110 --> 00:32:46,920
heuristic we trying to figure out where

00:32:45,030 --> 00:32:48,810
all the numbers are and your costs

00:32:46,920 --> 00:32:54,090
talking about millions of transactions

00:32:48,810 --> 00:32:56,430
and don't do this uh in the last one the

00:32:54,090 --> 00:32:58,950
last one I think is a classic give me

00:32:56,430 --> 00:33:01,560
everything less than 0 or greater than

00:32:58,950 --> 00:33:03,630
equal to 0 right pretty clear you would

00:33:01,560 --> 00:33:06,600
think that would get your whole shebang

00:33:03,630 --> 00:33:10,130
here it does not so just don't be be

00:33:06,600 --> 00:33:12,360
careful of thinking any type of range

00:33:10,130 --> 00:33:13,710
operation that you've got everything if

00:33:12,360 --> 00:33:17,340
you've covered the range cuz you got

00:33:13,710 --> 00:33:19,740
also cover those nulls uh no and not

00:33:17,340 --> 00:33:22,500
equals this is I think kind of a classic

00:33:19,740 --> 00:33:24,750
uh-uh give me everything that is in 10

00:33:22,500 --> 00:33:26,880
or 30 years and ten forty no we don't

00:33:24,750 --> 00:33:29,100
know if it's not 10 so we're just not

00:33:26,880 --> 00:33:30,150
going to tell you about it and again is

00:33:29,100 --> 00:33:32,640
seen people I give me anything that

00:33:30,150 --> 00:33:34,830
isn't ten everything it is 10 again it's

00:33:32,640 --> 00:33:36,660
it's completely you know a wall there um

00:33:34,830 --> 00:33:38,940
because again we're not going to

00:33:36,660 --> 00:33:42,330
heuristic oligo through the the where

00:33:38,940 --> 00:33:43,500
clause and say well by definition and

00:33:42,330 --> 00:33:45,090
unknown would have to fall into one of

00:33:43,500 --> 00:33:47,100
those two buckets we just don't do that

00:33:45,090 --> 00:33:51,600
we're not respect is not I think allow

00:33:47,100 --> 00:33:53,400
us to do that even um a little more

00:33:51,600 --> 00:33:56,940
interesting this is gets a lot of people

00:33:53,400 --> 00:33:59,610
are nulls and not in and up this is just

00:33:56,940 --> 00:34:03,060
an illustration so 1 is not equal to two

00:33:59,610 --> 00:34:05,880
and one is a little three that's true ok

00:34:03,060 --> 00:34:10,080
1 is not equal to two and one is over 3

00:34:05,880 --> 00:34:12,540
and 1 is not equal to no uh it's not

00:34:10,080 --> 00:34:15,090
full it's not true it's not false it's

00:34:12,540 --> 00:34:17,220
no we don't know hey that that when you

00:34:15,090 --> 00:34:19,710
see that it looks pretty easy to

00:34:17,220 --> 00:34:26,550
understand however let me flip it over

00:34:19,710 --> 00:34:30,120
here arm let me stay is a in this null

00:34:26,550 --> 00:34:33,630
output and in fact I don't know is a not

00:34:30,120 --> 00:34:36,720
in this null output and that's also I

00:34:33,630 --> 00:34:39,090
don't know okay because i don't know if

00:34:36,720 --> 00:34:41,970
it's in that if it if it's that thing or

00:34:39,090 --> 00:34:46,440
not arm and then began we're creative is

00:34:41,970 --> 00:34:50,490
a in here uh this one actually

00:34:46,440 --> 00:34:51,720
mark so is a in a or a null well we know

00:34:50,490 --> 00:34:52,889
it's here we don't really care about

00:34:51,720 --> 00:34:57,240
this rest of the part we're gonna say

00:34:52,889 --> 00:35:03,119
true ok this is what gets me is a not in

00:34:57,240 --> 00:35:05,609
an a or is it not in a null and that

00:35:03,119 --> 00:35:08,430
returns false because you know a is

00:35:05,609 --> 00:35:10,800
actually an a so that works you like I

00:35:08,430 --> 00:35:14,119
know I can short-circuit that one is a

00:35:10,800 --> 00:35:17,520
not in B or know that when I don't know

00:35:14,119 --> 00:35:20,700
another is a in B or here I don't know

00:35:17,520 --> 00:35:23,160
and is ain't not in B or not I don't

00:35:20,700 --> 00:35:26,369
know and this again this is a very very

00:35:23,160 --> 00:35:29,609
common case where you're you're you're

00:35:26,369 --> 00:35:32,190
you're doing a knot in sub query but not

00:35:29,609 --> 00:35:34,980
in sub query returns some null values

00:35:32,190 --> 00:35:37,950
and all of a sudden you get wacky

00:35:34,980 --> 00:35:39,480
returns because it doesn't know what

00:35:37,950 --> 00:35:42,510
happened because all of a sudden what

00:35:39,480 --> 00:35:43,980
happens is that every comparison for

00:35:42,510 --> 00:35:46,560
that row that goes into that sub query

00:35:43,980 --> 00:35:49,230
returns null out and they let nulls kind

00:35:46,560 --> 00:35:51,390
of parading around in your rare claws or

00:35:49,230 --> 00:35:53,910
not returning anything and you're like

00:35:51,390 --> 00:35:55,980
where is it can't find it it's because

00:35:53,910 --> 00:35:57,950
you had a null in there and all of a

00:35:55,980 --> 00:35:59,940
sudden all your comparisons are

00:35:57,950 --> 00:36:01,710
returning false so the whole thing just

00:35:59,940 --> 00:36:03,359
fell out the hole it's not a question of

00:36:01,710 --> 00:36:06,300
which values you compare it doesn't

00:36:03,359 --> 00:36:08,910
matter what value compare and for some

00:36:06,300 --> 00:36:11,490
reason in people can get like okay I

00:36:08,910 --> 00:36:13,500
gotta know the not in really throws them

00:36:11,490 --> 00:36:15,990
off so as soon as that sub query returns

00:36:13,500 --> 00:36:18,329
and null every comparison going in is

00:36:15,990 --> 00:36:19,800
going to return and I don't know a null

00:36:18,329 --> 00:36:22,650
which is going to effectively be false

00:36:19,800 --> 00:36:25,050
and then you're then you gotta bug your

00:36:22,650 --> 00:36:26,400
query uh so a lot of these sub queries

00:36:25,050 --> 00:36:29,130
are going to need like a not you know

00:36:26,400 --> 00:36:30,569
not null test in the where clause to

00:36:29,130 --> 00:36:36,980
prevent those nulls from percolating up

00:36:30,569 --> 00:36:39,119
into your query any questions okay um

00:36:36,980 --> 00:36:40,980
expanded the query out a little bit this

00:36:39,119 --> 00:36:43,890
is basically what it's doing so you're

00:36:40,980 --> 00:36:46,440
saying is equal to B or is a equal to

00:36:43,890 --> 00:36:48,450
null that's I don't know but not in is a

00:36:46,440 --> 00:36:52,920
not equal to B or is a not equal to null

00:36:48,450 --> 00:36:54,660
again I don't know arm kind of weird but

00:36:52,920 --> 00:36:56,599
that's effectively not in sub queries

00:36:54,660 --> 00:37:00,239
return dolls are often problematic

00:36:56,599 --> 00:37:02,069
understatement are explicit now compare

00:37:00,239 --> 00:37:05,189
since gets interesting is it all equal

00:37:02,069 --> 00:37:07,589
to no yes arm in fact i don't know when

00:37:05,189 --> 00:37:09,539
you need to compare to a know there is a

00:37:07,589 --> 00:37:11,759
special call it's called is null and is

00:37:09,539 --> 00:37:13,949
not null these are designed not to do a

00:37:11,759 --> 00:37:16,349
quality comparisons but actually do null

00:37:13,949 --> 00:37:17,729
comparisons and this is the type of

00:37:16,349 --> 00:37:19,169
clause you're going to start to need in

00:37:17,729 --> 00:37:20,939
your sub queries if you think yourself

00:37:19,169 --> 00:37:25,129
queries are going to have nulls in them

00:37:20,939 --> 00:37:28,229
so i hear i say is no no is in is null

00:37:25,129 --> 00:37:30,479
yes it is is now this is basically where

00:37:28,229 --> 00:37:33,209
I kind of pull null out of that unknown

00:37:30,479 --> 00:37:36,049
category and I now map it into a

00:37:33,209 --> 00:37:42,029
true/false zone that I can more easily

00:37:36,049 --> 00:37:44,249
understand effectively okay um more

00:37:42,029 --> 00:37:47,219
comparisons here with the knot is is no

00:37:44,249 --> 00:37:49,139
so here I can now break apart my queries

00:37:47,219 --> 00:37:51,419
I can now kind of separate am I going to

00:37:49,139 --> 00:37:53,819
say give me all the rows where it is no

00:37:51,419 --> 00:37:56,249
give me all the rows word is not null

00:37:53,819 --> 00:37:57,869
and this is again if you're thinking of

00:37:56,249 --> 00:37:59,609
breaking it up member greater than 10

00:37:57,869 --> 00:38:01,949
less than 10 greater than equal to 10

00:37:59,609 --> 00:38:04,259
less than 0 whatever you probably also

00:38:01,949 --> 00:38:06,719
going to need an is null test in there

00:38:04,259 --> 00:38:09,929
for that third level logics or even if

00:38:06,719 --> 00:38:11,969
you had you know greater than 10 and

00:38:09,929 --> 00:38:14,699
less than equal to 10 you still need a

00:38:11,969 --> 00:38:17,129
third one say what to do if it's a null

00:38:14,699 --> 00:38:21,689
and that is no test is usually what

00:38:17,129 --> 00:38:24,799
you're going to use comparing nose with

00:38:21,689 --> 00:38:27,149
to false logic um this is a weird

00:38:24,799 --> 00:38:29,399
function that I actually have trouble

00:38:27,149 --> 00:38:33,659
kind of kind of getting my head around

00:38:29,399 --> 00:38:36,989
it is an SQL standard clause um it's a

00:38:33,659 --> 00:38:39,749
way of kind of mapping nulls to true and

00:38:36,989 --> 00:38:41,849
false in a comparison of a number is

00:38:39,749 --> 00:38:43,649
known is not all just saying is it an

00:38:41,849 --> 00:38:47,819
all is it not at all right just pretty

00:38:43,649 --> 00:38:49,919
clear uh but distinct distinct from is

00:38:47,819 --> 00:38:51,839
the full name of the clause so I say is

00:38:49,919 --> 00:38:55,679
two distinct from one well yeah its

00:38:51,839 --> 00:38:59,939
distinct that's different okay um is no

00:38:55,679 --> 00:39:01,859
distinct is no distinct from one I can't

00:38:59,939 --> 00:39:06,839
really give you a good reason to explain

00:39:01,859 --> 00:39:10,859
this but effectively it's true which

00:39:06,839 --> 00:39:13,890
means it's basically allowing you to

00:39:10,859 --> 00:39:15,960
instead of mapping null

00:39:13,890 --> 00:39:19,980
and everything else distinct is

00:39:15,960 --> 00:39:22,380
basically saying is it this constant or

00:39:19,980 --> 00:39:25,770
is it no or any other constant in the

00:39:22,380 --> 00:39:28,470
world right so what I'm saying is no

00:39:25,770 --> 00:39:31,320
this thing for one the only case I'm

00:39:28,470 --> 00:39:34,770
going to get a false here is if this is

00:39:31,320 --> 00:39:37,620
a one if it's anything else if it's 25

00:39:34,770 --> 00:39:40,440
null doesn't matter I'm gonna get a true

00:39:37,620 --> 00:39:42,060
but the problem I have is the distinct

00:39:40,440 --> 00:39:44,910
from is effectively reversed from the

00:39:42,060 --> 00:39:47,520
logic I would normally think of so when

00:39:44,910 --> 00:39:49,440
I really think of it it's it's not

00:39:47,520 --> 00:39:51,720
distinct from he's really the way I

00:39:49,440 --> 00:39:55,020
normally would use it always you know

00:39:51,720 --> 00:39:56,820
isn't is null not distinct from is not

00:39:55,020 --> 00:39:58,800
distinct from like one and then they

00:39:56,820 --> 00:40:00,990
would say true or false it's a really

00:39:58,800 --> 00:40:04,320
awkward I really like they've done it

00:40:00,990 --> 00:40:07,760
better but uh in fact here you can

00:40:04,320 --> 00:40:10,350
compare a null to a null is this

00:40:07,760 --> 00:40:12,900
distinct from that and it says false um

00:40:10,350 --> 00:40:14,820
is null not equal to 1 well that's what

00:40:12,900 --> 00:40:17,130
ever tried no that's you know that's so

00:40:14,820 --> 00:40:19,620
the again it's kind of its kind of

00:40:17,130 --> 00:40:21,510
taking that null miss and kind of

00:40:19,620 --> 00:40:26,580
stripping it away for us for comparison

00:40:21,510 --> 00:40:29,040
to Constance arm as I said with what I

00:40:26,580 --> 00:40:32,220
really prefer is is is not distinct from

00:40:29,040 --> 00:40:34,560
so give me all the rows where X is not

00:40:32,220 --> 00:40:37,020
distinct from 30 which effectively is

00:40:34,560 --> 00:40:40,110
the 30 row give me all the roads where X

00:40:37,020 --> 00:40:43,980
is distinct from 30 that's where you

00:40:40,110 --> 00:40:47,040
start to split it apart I have now my

00:40:43,980 --> 00:40:48,420
role of 30 and i have my row it doesn't

00:40:47,040 --> 00:40:52,650
have to be a constant could be anything

00:40:48,420 --> 00:40:54,840
arm but effectively now i'm doing I've

00:40:52,650 --> 00:40:57,390
got my 30 and I've got my 40 and mine

00:40:54,840 --> 00:40:59,010
all kind of grouped together so again

00:40:57,390 --> 00:41:01,290
that distinct from allows me to take a

00:40:59,010 --> 00:41:06,120
constant put everything in one bucket

00:41:01,290 --> 00:41:08,550
and then the not distinguishing that

00:41:06,120 --> 00:41:13,490
isn't that constant including the nulls

00:41:08,550 --> 00:41:15,720
I find it very awkward personally um

00:41:13,490 --> 00:41:18,090
comparing your nose to other knows this

00:41:15,720 --> 00:41:20,940
is gets kind of interesting so if I

00:41:18,090 --> 00:41:24,120
actually in have a table with 1 1 2 3

00:41:20,940 --> 00:41:27,780
and null null and I say select star from

00:41:24,120 --> 00:41:30,810
using where X is not distinct from

00:41:27,780 --> 00:41:33,450
why cuz members two columns I actually

00:41:30,810 --> 00:41:36,270
say that is not distinct from is saying

00:41:33,450 --> 00:41:38,940
they're the same again it's obviously

00:41:36,270 --> 00:41:41,040
just it's the same or something better I

00:41:38,940 --> 00:41:42,990
think they use the distinct from the

00:41:41,040 --> 00:41:44,700
Select Clause and they just we use the

00:41:42,990 --> 00:41:48,980
keyword but why would we use another

00:41:44,700 --> 00:41:48,980
keyword uh and that's why the guys soon

00:41:50,150 --> 00:41:54,410
yeah you can see yourself lucky

00:42:05,410 --> 00:42:26,620
it is I say so if X is why okay that's

00:42:24,130 --> 00:42:32,170
interesting is does the standard allow

00:42:26,620 --> 00:42:35,140
this to be optional I don't either ok ok

00:42:32,170 --> 00:42:36,880
ok i just don't like it because I they

00:42:35,140 --> 00:42:39,670
reuse the you know you say select

00:42:36,880 --> 00:42:43,540
distinct so they just yeah they just

00:42:39,670 --> 00:42:47,530
reused it yeah this thing from just like

00:42:43,540 --> 00:42:49,690
is yeah right well it's actually you're

00:42:47,530 --> 00:42:52,360
sure you're teasing is null right so

00:42:49,690 --> 00:42:53,920
you're but the problem you might get

00:42:52,360 --> 00:42:57,220
into and I don't I haven't thought about

00:42:53,920 --> 00:43:01,780
this is this case so when you're saying

00:42:57,220 --> 00:43:04,480
null is null right see that the problem

00:43:01,780 --> 00:43:11,260
is that you have is null from way back

00:43:04,480 --> 00:43:12,820
here okay and now you have is no I have

00:43:11,260 --> 00:43:14,950
to I think you need to test a little bit

00:43:12,820 --> 00:43:16,930
to see what it thought that does um so

00:43:14,950 --> 00:43:20,170
that's what that distinct thing does um

00:43:16,930 --> 00:43:22,840
it's very useful for joins actually and

00:43:20,170 --> 00:43:24,490
I know it sounds kind of weird but but

00:43:22,840 --> 00:43:26,380
when you're saying if you want to join

00:43:24,490 --> 00:43:28,870
two columns you want the nulls to kind

00:43:26,380 --> 00:43:30,490
of go together you can say column is not

00:43:28,870 --> 00:43:32,680
distinct from some other column and

00:43:30,490 --> 00:43:35,200
those are going to return true even if

00:43:32,680 --> 00:43:36,790
they're both nulls or if there's no I'm

00:43:35,200 --> 00:43:39,280
saying that's where you kind of it

00:43:36,790 --> 00:43:40,840
starts to get useful I have a cancer

00:43:39,280 --> 00:43:42,910
have completely wrap my head around it

00:43:40,840 --> 00:43:45,880
but that's when we use it usually is in

00:43:42,910 --> 00:43:51,040
a in a join that might have null joins

00:43:45,880 --> 00:43:53,170
in it arm this kind of gets we start to

00:43:51,040 --> 00:43:57,100
kind of go a little a little little off

00:43:53,170 --> 00:43:59,260
the the off the rails here uh ordering

00:43:57,100 --> 00:44:00,670
of nulls well these nulls are unknown

00:43:59,260 --> 00:44:03,010
and we don't know anything about them

00:44:00,670 --> 00:44:04,840
but well we now know something about it

00:44:03,010 --> 00:44:06,970
because we got to order so all of a

00:44:04,840 --> 00:44:08,890
sudden we have a practical requirement

00:44:06,970 --> 00:44:11,050
that we've got to order these things

00:44:08,890 --> 00:44:13,180
that we don't know about so we can't

00:44:11,050 --> 00:44:16,000
just randomly throw him some I'm wearing

00:44:13,180 --> 00:44:18,100
the output and in fact in this query

00:44:16,000 --> 00:44:19,330
here with a common table expression

00:44:18,100 --> 00:44:22,870
which ritual

00:44:19,330 --> 00:44:25,120
covering tomorrow uh in his talk uh we

00:44:22,870 --> 00:44:27,850
actually have a select that has a null a

00:44:25,120 --> 00:44:31,150
201 and a null in it and then we order

00:44:27,850 --> 00:44:34,270
by that column and voila the nulls are

00:44:31,150 --> 00:44:36,490
treated equal for ordering purposes so

00:44:34,270 --> 00:44:39,580
even though they weren't equal for all

00:44:36,490 --> 00:44:41,740
of a sudden we can now put them at the

00:44:39,580 --> 00:44:44,080
bottom or at the top you can actually

00:44:41,740 --> 00:44:46,090
control moles first and last you can

00:44:44,080 --> 00:44:47,620
control where they go okay in fact

00:44:46,090 --> 00:44:49,510
here's the example order by one knows

00:44:47,620 --> 00:44:52,030
first and all of a sudden they percolate

00:44:49,510 --> 00:44:54,460
up to the top so we can actually do

00:44:52,030 --> 00:44:56,080
comparisons with nulls who knew because

00:44:54,460 --> 00:44:57,640
if I can really have to do comparisons

00:44:56,080 --> 00:44:59,550
when we're talking about ordering

00:44:57,640 --> 00:45:02,020
because we don't have a choice so

00:44:59,550 --> 00:45:04,960
practicality rules here and we can

00:45:02,020 --> 00:45:07,750
actually can compare nulls a leak index

00:45:04,960 --> 00:45:09,700
is treating all as unequal this is again

00:45:07,750 --> 00:45:11,470
what Richard was talking about with the

00:45:09,700 --> 00:45:13,060
unique and X you can create unique index

00:45:11,470 --> 00:45:14,550
you can put multiple moles in there

00:45:13,060 --> 00:45:17,590
we're certainly happy to do that

00:45:14,550 --> 00:45:21,130
informix and microsoft sequel server or

00:45:17,590 --> 00:45:23,350
not uh nulls and aggregates this this

00:45:21,130 --> 00:45:26,260
some this is really a little bit of a

00:45:23,350 --> 00:45:28,600
head bender here arm and i'm going to

00:45:26,260 --> 00:45:31,150
walk through some of them there's one or

00:45:28,600 --> 00:45:32,800
two that make no sense but it's kind of

00:45:31,150 --> 00:45:35,770
like the same case where you're like

00:45:32,800 --> 00:45:38,590
well i gotta give the per user some kind

00:45:35,770 --> 00:45:39,820
of number here help me um and and and

00:45:38,590 --> 00:45:41,710
that's kind of what the standard

00:45:39,820 --> 00:45:44,170
requires here so I've created a little

00:45:41,710 --> 00:45:46,630
table called AG test and I've inserted

00:45:44,170 --> 00:45:49,960
into AG tests and value seven eight and

00:45:46,630 --> 00:45:51,670
null and aggregates are I you know

00:45:49,960 --> 00:45:54,550
earlier on it said nulls are a rich

00:45:51,670 --> 00:45:57,160
source of confusion areas are really

00:45:54,550 --> 00:45:59,320
that on steroids I think um any

00:45:57,160 --> 00:46:00,700
aggregate that gets a null in there is

00:45:59,320 --> 00:46:03,220
going to have some really unusual

00:46:00,700 --> 00:46:05,110
behavior and you should start to think

00:46:03,220 --> 00:46:07,870
about like how you're going to behave

00:46:05,110 --> 00:46:09,460
there there is some argument to say you

00:46:07,870 --> 00:46:13,210
shouldn't let not get in your advocates

00:46:09,460 --> 00:46:16,930
but again SQL will has a definition for

00:46:13,210 --> 00:46:20,530
it just make sure you understand it so

00:46:16,930 --> 00:46:22,870
here we have a select of count arm and

00:46:20,530 --> 00:46:26,590
you can see that we actually have two

00:46:22,870 --> 00:46:29,530
counts here one is a count star and the

00:46:26,590 --> 00:46:32,080
other one is account on the X column and

00:46:29,530 --> 00:46:32,230
we also do a sum a min and a max and

00:46:32,080 --> 00:46:35,200
then

00:46:32,230 --> 00:46:36,880
average okay so we're just kind of

00:46:35,200 --> 00:46:38,530
taking these three rows one of which is

00:46:36,880 --> 00:46:42,220
no we're throwing them into an aggregate

00:46:38,530 --> 00:46:45,790
what do we get out our count star we

00:46:42,220 --> 00:46:51,760
have three rows yay three rows I get it

00:46:45,790 --> 00:46:55,630
we put three rows in count of X is 2 2 2

00:46:51,760 --> 00:46:58,359
2 why because we have specified a column

00:46:55,630 --> 00:47:03,130
here instead of as far and count by

00:46:58,359 --> 00:47:06,070
definition will skip counting null rows

00:47:03,130 --> 00:47:07,750
with null values in that column okay so

00:47:06,070 --> 00:47:09,490
count star an account on the column are

00:47:07,750 --> 00:47:12,760
not the same I on a call and we'll skip

00:47:09,490 --> 00:47:16,930
the null values in that call hey some

00:47:12,760 --> 00:47:20,170
okay well we got a 17-8 and no well you

00:47:16,930 --> 00:47:24,369
know back earlier when I had a seven and

00:47:20,170 --> 00:47:28,690
eight and no what did I get no well why

00:47:24,369 --> 00:47:31,510
do I have 15 here well well this is

00:47:28,690 --> 00:47:33,460
called expediency folks uh they just

00:47:31,510 --> 00:47:34,720
figured well you know if we just give

00:47:33,460 --> 00:47:36,160
people nulls all the time you're not

00:47:34,720 --> 00:47:40,810
going to find the function very useful

00:47:36,160 --> 00:47:43,270
so we're just gonna skip it and and we

00:47:40,810 --> 00:47:44,920
kind of skipped it over here so if we

00:47:43,270 --> 00:47:48,040
kind of have the logic that we're

00:47:44,920 --> 00:47:49,720
skipping counting values and ethics then

00:47:48,040 --> 00:47:52,300
there's some logic to say we can skip

00:47:49,720 --> 00:47:53,830
them in slums as well okay if you kind

00:47:52,300 --> 00:47:55,960
of yeah this is where the height starts

00:47:53,830 --> 00:47:59,740
to get a little sideways so there the

00:47:55,960 --> 00:48:02,350
sum is 15 the mean is seven no no

00:47:59,740 --> 00:48:04,480
mention of them all at all the max is

00:48:02,350 --> 00:48:06,940
eight and the average is 7.5 we'll just

00:48:04,480 --> 00:48:10,030
ignore them all there just pretend it

00:48:06,940 --> 00:48:11,830
doesn't exist arm then it gets the more

00:48:10,030 --> 00:48:13,690
interesting we delete all the roads from

00:48:11,830 --> 00:48:18,369
the table we want it again so it on an

00:48:13,690 --> 00:48:20,260
empty table um the there this is kind of

00:48:18,369 --> 00:48:28,869
a select count star from an empty table

00:48:20,260 --> 00:48:32,800
is 0 count on the column x is 0 but the

00:48:28,869 --> 00:48:37,740
sum is null and anum in the maximun all

00:48:32,800 --> 00:48:40,300
an average is null so why is this I

00:48:37,740 --> 00:48:43,920
don't know I i have really trouble

00:48:40,300 --> 00:48:43,920
figuring that out why these aren't 0

00:48:45,640 --> 00:48:51,019
yeah I really this is just basically a

00:48:48,950 --> 00:48:54,829
practical problem of what to do with all

00:48:51,019 --> 00:48:58,369
these cases um so Rhea some of zeros is

00:48:54,829 --> 00:49:02,239
null so okay I don't know why it's not

00:48:58,369 --> 00:49:05,140
zero but I can imagine why a minute max

00:49:02,239 --> 00:49:08,150
would be no cuz like what do you return

00:49:05,140 --> 00:49:11,299
like first string what's a minute what's

00:49:08,150 --> 00:49:13,279
a Mac string like I don't know it's just

00:49:11,299 --> 00:49:15,019
it's just I don't know what you put so I

00:49:13,279 --> 00:49:17,599
think he just kind of punted on this one

00:49:15,019 --> 00:49:19,789
and they said you know we got some we

00:49:17,599 --> 00:49:21,019
could probably return 0 there but then

00:49:19,789 --> 00:49:22,460
the minute max an average you're going

00:49:21,019 --> 00:49:24,559
really a problem the average would

00:49:22,460 --> 00:49:25,789
probably be 20 but minimax are going to

00:49:24,559 --> 00:49:27,950
be a problem so let's just know across

00:49:25,789 --> 00:49:29,210
the whole board their arm and just be

00:49:27,950 --> 00:49:31,430
more and that's that's actually what

00:49:29,210 --> 00:49:32,749
they do arm so then we are going to

00:49:31,430 --> 00:49:34,519
insert again we're going to put two

00:49:32,749 --> 00:49:36,079
nulls in this time it gets a little more

00:49:34,519 --> 00:49:38,239
exciting and see where all the edge of

00:49:36,079 --> 00:49:40,579
your seats so we have to knows which

00:49:38,239 --> 00:49:43,910
you've inserted and then we do the same

00:49:40,579 --> 00:49:48,650
query again um but but in this case we

00:49:43,910 --> 00:49:52,009
actually do a group by and in order by

00:49:48,650 --> 00:49:54,109
and what do you know the system has no

00:49:52,009 --> 00:49:56,809
trouble comparing those two nulls as

00:49:54,109 --> 00:49:58,999
being equal which again we proved

00:49:56,809 --> 00:50:01,549
earlier that it would didn't do in fact

00:49:58,999 --> 00:50:03,170
we she tells us we have we have to this

00:50:01,549 --> 00:50:06,499
is kind of this is kind of interesting

00:50:03,170 --> 00:50:09,589
we have two rows in the table but the

00:50:06,499 --> 00:50:11,210
count on the column is actually 0 even

00:50:09,589 --> 00:50:14,329
though we're showing that we actually do

00:50:11,210 --> 00:50:16,489
have some nulls in there okay and then I

00:50:14,329 --> 00:50:19,759
we have no of the other the other stuff

00:50:16,489 --> 00:50:22,489
is all there almost so again standard

00:50:19,759 --> 00:50:25,190
committee a figured well you know we I

00:50:22,489 --> 00:50:28,460
think it would have made some logic just

00:50:25,190 --> 00:50:31,009
not to show that line at all but for

00:50:28,460 --> 00:50:34,430
some reason group by gets a religion and

00:50:31,009 --> 00:50:36,410
they figure out right now we're going to

00:50:34,430 --> 00:50:38,749
group all these nulls together now that

00:50:36,410 --> 00:50:40,969
will equal and we're going to count them

00:50:38,749 --> 00:50:43,609
and we're going to give you a row so

00:50:40,969 --> 00:50:45,049
again trying to have an arrogant and

00:50:43,609 --> 00:50:47,539
thinking own additives are just going to

00:50:45,049 --> 00:50:50,239
sum them up as though I was doing in SQL

00:50:47,539 --> 00:50:52,849
is not actually true the Savvas islets

00:50:50,239 --> 00:50:55,430
are not behaving the exact same way they

00:50:52,849 --> 00:50:58,990
would if I just ran the SQL tajik to do

00:50:55,430 --> 00:51:01,930
the count or the average okay uh

00:50:58,990 --> 00:51:03,250
so again just expect there's a little

00:51:01,930 --> 00:51:07,300
there's a little bit this is again

00:51:03,250 --> 00:51:08,890
defined by the SQL standard um mapping

00:51:07,300 --> 00:51:10,600
those two strings I'm sorry this is a

00:51:08,890 --> 00:51:12,220
little smaller and tight that I wanted

00:51:10,600 --> 00:51:14,920
but I want to get all in this ring there

00:51:12,220 --> 00:51:16,990
is a function called Cola coalesce I

00:51:14,920 --> 00:51:19,060
have trouble saying it but it actually

00:51:16,990 --> 00:51:23,380
is a function and what it's designed to

00:51:19,060 --> 00:51:26,380
do is to map a null to some constant

00:51:23,380 --> 00:51:28,030
usually in this case so it's kind of

00:51:26,380 --> 00:51:29,470
like a big case state like a big case

00:51:28,030 --> 00:51:31,480
statements except they we've kind of

00:51:29,470 --> 00:51:34,660
whittled it down so it normally say case

00:51:31,480 --> 00:51:36,280
if not you know isn't all do X is not

00:51:34,660 --> 00:51:38,740
null to do something else so here

00:51:36,280 --> 00:51:40,780
they're basically saying give me this

00:51:38,740 --> 00:51:43,180
value but if it's no give me this value

00:51:40,780 --> 00:51:46,570
that's all it really does i think or has

00:51:43,180 --> 00:51:48,430
some weird decode thing which is even

00:51:46,570 --> 00:51:51,550
more crazy than this so am i going to go

00:51:48,430 --> 00:51:53,350
into it but say coalesce if this is null

00:51:51,550 --> 00:51:56,140
then return this value so in fact if

00:51:53,350 --> 00:51:59,140
they coalesce null 0 it gets 0 coalesce

00:51:56,140 --> 00:52:01,480
of null I am null I get I am NOT okay

00:51:59,140 --> 00:52:04,300
now let's run it on a funk a table we're

00:52:01,480 --> 00:52:06,250
going to insert FG and null in here

00:52:04,300 --> 00:52:09,640
we're gonna say give me the field and

00:52:06,250 --> 00:52:12,070
give me the coalesce of X or if that's

00:52:09,640 --> 00:52:14,080
now give me n /a this is where it starts

00:52:12,070 --> 00:52:16,240
to work with reports because again

00:52:14,080 --> 00:52:19,119
showing a blank really doesn't help you

00:52:16,240 --> 00:52:24,130
when you're running a report this allows

00:52:19,119 --> 00:52:26,160
me to map think the the null into some

00:52:24,130 --> 00:52:28,540
type of display that I want to come out

00:52:26,160 --> 00:52:32,080
so here we're saying here we're saying F

00:52:28,540 --> 00:52:34,510
and G and this row which is null is

00:52:32,080 --> 00:52:36,160
actually giving me a nice na here for

00:52:34,510 --> 00:52:39,850
the coalesced home so I'm feeling pretty

00:52:36,160 --> 00:52:41,530
good arm concatenation I remember i

00:52:39,850 --> 00:52:44,560
showed you before you can catenate are

00:52:41,530 --> 00:52:46,440
two things together it was a null you

00:52:44,560 --> 00:52:49,000
get nothing but was at the beginning um

00:52:46,440 --> 00:52:51,910
but here if I say a and I would

00:52:49,000 --> 00:52:53,560
concatenate it with some value and if

00:52:51,910 --> 00:52:57,609
that value is no give me a zero length

00:52:53,560 --> 00:52:59,050
string we're good ok so anytime you

00:52:57,609 --> 00:53:00,670
doing concatenation if any of those

00:52:59,050 --> 00:53:02,440
fields or values might be no you

00:53:00,670 --> 00:53:05,710
probably want to throw a coalesce in

00:53:02,440 --> 00:53:09,730
there I am Not sure all relational

00:53:05,710 --> 00:53:12,330
systems handle this that way i have a a

00:53:09,730 --> 00:53:14,220
memory and David

00:53:12,330 --> 00:53:16,530
will help me that my sequel will lie to

00:53:14,220 --> 00:53:19,590
concatenate a null is that right it will

00:53:16,530 --> 00:53:21,210
entreat is a zero-length string yep so

00:53:19,590 --> 00:53:23,850
my sequel that will treat is zero length

00:53:21,210 --> 00:53:25,380
string in Postgres and I think the SQL

00:53:23,850 --> 00:53:27,210
standard relational system you'll

00:53:25,380 --> 00:53:31,860
actually need to put coalesce in there

00:53:27,210 --> 00:53:34,470
um so here I'm saying a a column or a

00:53:31,860 --> 00:53:36,870
value and be here I'm actually saying I

00:53:34,470 --> 00:53:39,510
want 20 like string there and if I if I

00:53:36,870 --> 00:53:41,760
get a be like this like that um you

00:53:39,510 --> 00:53:43,350
remember I said a sum of a null is a

00:53:41,760 --> 00:53:45,600
null remember i showed you that right

00:53:43,350 --> 00:53:48,450
here um if you don't like that you can

00:53:45,600 --> 00:53:51,390
use coalesce to fix that too so here I'm

00:53:48,450 --> 00:53:54,780
saying instead of saying sum of X I'm

00:53:51,390 --> 00:53:57,270
saying coalesce sum of X and if that's a

00:53:54,780 --> 00:53:59,910
null return 0 and I get that I get the

00:53:57,270 --> 00:54:03,810
mapping I want okay so that's how you

00:53:59,910 --> 00:54:06,720
get around some of the weird uh problems

00:54:03,810 --> 00:54:10,250
you might have with with the Ariat

00:54:06,720 --> 00:54:13,710
that's I think it's kind of useful all

00:54:10,250 --> 00:54:16,290
mapping strings to know um this is the

00:54:13,710 --> 00:54:18,420
opposite I wish you know they would have

00:54:16,290 --> 00:54:19,920
had something that sounds like coalesced

00:54:18,420 --> 00:54:22,890
but it doesn't like there's coalesce and

00:54:19,920 --> 00:54:24,510
then there's no if I don't know I don't

00:54:22,890 --> 00:54:26,640
know why they did that way but that's

00:54:24,510 --> 00:54:27,870
what the SQL standard did so this does

00:54:26,640 --> 00:54:30,930
the opposite direction this takes a

00:54:27,870 --> 00:54:33,630
string and converts it to a null so here

00:54:30,930 --> 00:54:37,590
I'm saying F and G and na in which is my

00:54:33,630 --> 00:54:39,720
special string select X and know if if

00:54:37,590 --> 00:54:42,770
this is an old and give me that string

00:54:39,720 --> 00:54:46,890
and again and na has become a null arm

00:54:42,770 --> 00:54:49,920
this is the double this is this is the

00:54:46,890 --> 00:54:51,270
null turn to na and then null a have

00:54:49,920 --> 00:54:53,850
turned back into a null so that's like

00:54:51,270 --> 00:54:55,260
your your full circle there with the two

00:54:53,850 --> 00:54:59,340
of them you would never write that but

00:54:55,260 --> 00:55:00,930
you get the idea all those enroll

00:54:59,340 --> 00:55:04,050
expressions this might be various

00:55:00,930 --> 00:55:05,460
postgres specific arm but effectively we

00:55:04,050 --> 00:55:08,010
have something called a row expression

00:55:05,460 --> 00:55:10,650
which is sort of a combination a look

00:55:08,010 --> 00:55:13,620
it's like a composite value which

00:55:10,650 --> 00:55:18,300
contains multiple fields arm so in

00:55:13,620 --> 00:55:20,940
Postgres if um if you have this is yeah

00:55:18,300 --> 00:55:22,590
kind of weird if you have a null and you

00:55:20,940 --> 00:55:26,190
can pair it you cast it to an integer

00:55:22,590 --> 00:55:30,000
array and you ask if it's null it's true

00:55:26,190 --> 00:55:32,700
um if you have a zero-length array and

00:55:30,000 --> 00:55:35,340
you cast it to an injury and risk if

00:55:32,700 --> 00:55:39,000
it's null it's a false that's good but

00:55:35,340 --> 00:55:42,930
if you have a null in an integer array

00:55:39,000 --> 00:55:48,630
and you ask is no it's false so a no a

00:55:42,930 --> 00:55:52,860
no in a array is not an all but a null

00:55:48,630 --> 00:55:55,800
itself as an array value is it all yeah

00:55:52,860 --> 00:55:59,130
yeah whatever this mrs. scripts really

00:55:55,800 --> 00:56:02,310
bizarre um if you ask if a row empty row

00:55:59,130 --> 00:56:05,250
is a null it is if you put a null in the

00:56:02,310 --> 00:56:08,310
row it's still no but if you an even put

00:56:05,250 --> 00:56:12,770
two rows in the null it two rows in the

00:56:08,310 --> 00:56:17,160
row it's no but if you put a null and a

00:56:12,770 --> 00:56:18,960
non-null in there then it isn't no so

00:56:17,160 --> 00:56:30,290
two nulls is in all but if you have not

00:56:18,960 --> 00:56:30,290
all there it is yes sir yeah

00:56:37,040 --> 00:56:48,020
right so the question is what if there's

00:56:45,710 --> 00:56:50,360
nulls in every column with the road

00:56:48,020 --> 00:56:52,460
still be counted I've never tested that

00:56:50,360 --> 00:56:54,170
I don't think we would care we would

00:56:52,460 --> 00:56:55,610
still behave the same way because yes

00:56:54,170 --> 00:56:58,550
kill standard pretty is pretty clear on

00:56:55,610 --> 00:57:00,620
that yeah stars a special case that's a

00:56:58,550 --> 00:57:02,900
great question so when your slings count

00:57:00,620 --> 00:57:04,580
star if that expand out to all the

00:57:02,900 --> 00:57:06,290
columns and all columns were no would we

00:57:04,580 --> 00:57:08,240
yet we can't do that cuz the standard

00:57:06,290 --> 00:57:10,430
pretty much says star just count all the

00:57:08,240 --> 00:57:12,110
rows and we can't that would be I would

00:57:10,430 --> 00:57:18,380
say that would make it even harder to

00:57:12,110 --> 00:57:21,110
understand Connor yes Richard I don't

00:57:18,380 --> 00:57:23,330
think it is i think it's i think it's an

00:57:21,110 --> 00:57:25,700
SQL standard thing what's interesting is

00:57:23,330 --> 00:57:28,430
that the system's pretty smart so if I

00:57:25,700 --> 00:57:33,140
say a null and a non-null is that null

00:57:28,430 --> 00:57:35,990
know it isn't but it also is not null so

00:57:33,140 --> 00:57:39,020
again with a multivalued field it's it's

00:57:35,990 --> 00:57:44,330
not know but it also is not not know

00:57:39,020 --> 00:57:47,630
right uh yeah right this kind of

00:57:44,330 --> 00:57:49,010
interesting um where's returning no on

00:57:47,630 --> 00:57:51,560
the target list is kind of interesting

00:57:49,010 --> 00:57:53,540
so if we create a table and we do a

00:57:51,560 --> 00:57:56,210
selecting there's nothing there if you

00:57:53,540 --> 00:57:58,940
actually do a query that returns no rose

00:57:56,210 --> 00:58:00,800
it actually returns a null as the value

00:57:58,940 --> 00:58:03,590
again another case we're generating it

00:58:00,800 --> 00:58:05,540
on the fly arm in fact I can even test

00:58:03,590 --> 00:58:09,080
it i can say is the output of this null

00:58:05,540 --> 00:58:11,150
in fact it will tell me uh that it is to

00:58:09,080 --> 00:58:14,870
change one row that's it's nothing

00:58:11,150 --> 00:58:17,690
nothing in it um so this is my

00:58:14,870 --> 00:58:20,050
conclusion uh this is a jeff davis who's

00:58:17,690 --> 00:58:22,610
one of our sort of back-end engineers uh

00:58:20,050 --> 00:58:25,310
he has this great question oh that makes

00:58:22,610 --> 00:58:28,340
sense when you see individual behaviors

00:58:25,310 --> 00:58:30,200
of know they look systematic and your

00:58:28,340 --> 00:58:32,750
brain quickly sees a pattern and

00:58:30,200 --> 00:58:36,830
extrapolates what might happen in other

00:58:32,750 --> 00:58:39,890
situations often that extrapolation is

00:58:36,830 --> 00:58:41,810
wrong because null semantics are a mix

00:58:39,890 --> 00:58:44,330
of behaviors I think the best way to

00:58:41,810 --> 00:58:46,720
think about null is a Frankenstein

00:58:44,330 --> 00:58:50,960
monster of several philosophies and

00:58:46,720 --> 00:58:53,570
systems stitched together by a series of

00:58:50,960 --> 00:58:55,700
cases I think that sums up what I've

00:58:53,570 --> 00:58:58,790
shown you I promise there be some

00:58:55,700 --> 00:59:00,650
perplexing sort of ideas here and I

00:58:58,790 --> 00:59:05,599
think that really understands it and

00:59:00,650 --> 00:59:07,640
again it's a practical case of what what

00:59:05,599 --> 00:59:10,490
you what behaviors the most reasonable

00:59:07,640 --> 00:59:12,680
for particular query and unfortunately

00:59:10,490 --> 00:59:16,310
it is not always consistent with

00:59:12,680 --> 00:59:19,130
behaviors in other areas so uh that's

00:59:16,310 --> 00:59:20,690
about it the there is a blog entry dared

00:59:19,130 --> 00:59:22,490
at the bottom that actually is a sort of

00:59:20,690 --> 00:59:27,020
description of this presentation as a

00:59:22,490 --> 00:59:30,109
blog um so uh looks like some got cut

00:59:27,020 --> 00:59:35,060
off but that's it's okay um so I

00:59:30,109 --> 00:59:37,670
actually have no time I have no time

00:59:35,060 --> 00:59:40,550
left so um the good thing is we take out

00:59:37,670 --> 00:59:43,580
a chance to ask questions um I could

00:59:40,550 --> 00:59:48,560
trade take one question within the next

00:59:43,580 --> 00:59:50,119
30 seconds I have left and we're good

00:59:48,560 --> 00:59:52,300
okay well thanks very much appreciate

00:59:50,119 --> 00:59:52,300
you guys

01:01:29,620 --> 01:01:54,680
want to stuff on will be managed honey

01:01:52,150 --> 01:02:04,310
that's how you're close to go to your

01:01:54,680 --> 01:02:09,320
suite I just under half an hour crazy

01:02:04,310 --> 01:02:16,100
flight down it was April Hong Kong pro

01:02:09,320 --> 01:02:29,510
here oh no I that's very good [ __ ]

01:02:16,100 --> 01:02:33,380
keep title of everything to be a weird

01:02:29,510 --> 01:02:39,470
question for you let you face your type

01:02:33,380 --> 01:02:43,300
you to clean yourself let's get a

01:02:39,470 --> 01:02:46,040
ciancia why are you going to be rough

01:02:43,300 --> 01:02:49,420
I'm here to London and I'll see it's

01:02:46,040 --> 01:02:56,030
nothing I are good excellent testicles

01:02:49,420 --> 01:03:05,240
should i use this edge yep that's night

01:02:56,030 --> 01:03:06,860
wonders oh yeah you use it let's guess

01:03:05,240 --> 01:03:08,240
what destroy are using these boxes

01:03:06,860 --> 01:03:16,580
because i just realized my talk tomorrow

01:03:08,240 --> 01:03:19,240
i gotta do a live demo dr. stochastic

01:03:16,580 --> 01:03:19,240

YouTube URL: https://www.youtube.com/watch?v=V4eQTKUCqE4


