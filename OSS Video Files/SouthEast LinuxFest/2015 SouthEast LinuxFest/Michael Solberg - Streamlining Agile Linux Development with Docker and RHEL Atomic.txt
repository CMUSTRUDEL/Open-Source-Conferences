Title: Michael Solberg - Streamlining Agile Linux Development with Docker and RHEL Atomic
Publication date: 2017-01-25
Playlist: 2015 SouthEast LinuxFest
Description: 
	
Captions: 
	00:00:02,340 --> 00:00:07,810
great so I good afternoon thank you guys

00:00:04,960 --> 00:00:09,760
for coming I am Michael solberg I am

00:00:07,810 --> 00:00:12,280
what we call a chief field architect at

00:00:09,760 --> 00:00:14,099
Red Hat I am based out of atlanta

00:00:12,280 --> 00:00:17,699
georgia and I cover the Southeast region

00:00:14,099 --> 00:00:20,680
so my job basically is to work with

00:00:17,699 --> 00:00:22,869
large companies or strategic customers

00:00:20,680 --> 00:00:25,960
of red hat to help them implement right

00:00:22,869 --> 00:00:29,019
at set of technologies today I want to

00:00:25,960 --> 00:00:30,670
talk about docker and docker in the

00:00:29,019 --> 00:00:32,710
aspect that it underlies a lot of our

00:00:30,670 --> 00:00:36,430
newer technologies coming out so open

00:00:32,710 --> 00:00:39,579
shift Rella Tomic rel 7 they all have a

00:00:36,430 --> 00:00:41,620
strong basis for using docker working

00:00:39,579 --> 00:00:43,899
with docker and so today's presentation

00:00:41,620 --> 00:00:46,120
is about docker in the CIC d workflow

00:00:43,899 --> 00:00:47,710
because I think that's where it makes

00:00:46,120 --> 00:00:49,840
the most sense to think about docker and

00:00:47,710 --> 00:00:53,440
we'll look at traditional see I CD work

00:00:49,840 --> 00:00:55,840
clothes and new CI CD work clothes using

00:00:53,440 --> 00:00:59,260
docker and compare and contrast a little

00:00:55,840 --> 00:01:00,789
bit right because I think if you guys

00:00:59,260 --> 00:01:03,520
heard Joe's talk did you guys hear Joe's

00:01:00,789 --> 00:01:04,989
talked earlier about atomic so one of

00:01:03,520 --> 00:01:06,070
the things that he said was you talk a

00:01:04,989 --> 00:01:09,689
little bit about the complexity of

00:01:06,070 --> 00:01:09,689
setting things up in docker and I think

00:01:10,200 --> 00:01:13,600
once you've taken a look at some of the

00:01:12,340 --> 00:01:15,790
complexity that was in the original

00:01:13,600 --> 00:01:17,710
pipeline that we already work with and

00:01:15,790 --> 00:01:19,240
then you see the lack of complexity in

00:01:17,710 --> 00:01:21,100
the docker pipeline I think the

00:01:19,240 --> 00:01:23,500
complexity of implementing docker kind

00:01:21,100 --> 00:01:25,240
of gets cancelled out by the previous

00:01:23,500 --> 00:01:26,890
complexity so we'll take a look at that

00:01:25,240 --> 00:01:28,330
hopefully I'll make it look very simple

00:01:26,890 --> 00:01:30,250
I have a simple example today that will

00:01:28,330 --> 00:01:32,020
look at will take a Django application

00:01:30,250 --> 00:01:34,689
and we'll go from source to deploy

00:01:32,020 --> 00:01:38,860
docker and that'll be through the

00:01:34,689 --> 00:01:41,920
pipeline so first thing I want to talk

00:01:38,860 --> 00:01:44,350
about is CI CD it should be a broad

00:01:41,920 --> 00:01:45,399
overview and I apologize for the

00:01:44,350 --> 00:01:46,990
broadness of it but I think it's

00:01:45,399 --> 00:01:49,960
important to talk about it and in the

00:01:46,990 --> 00:01:53,860
context of docker because I think you

00:01:49,960 --> 00:01:55,509
know the use case for docker is CI CD so

00:01:53,860 --> 00:01:57,759
the main tenants why why do we have

00:01:55,509 --> 00:01:59,439
continuous integration continuous

00:01:57,759 --> 00:02:01,240
integration is built to solve the

00:01:59,439 --> 00:02:03,310
problem of did I just break something

00:02:01,240 --> 00:02:04,540
when I committed some code it's doesn't

00:02:03,310 --> 00:02:07,329
necessarily have to be software code

00:02:04,540 --> 00:02:09,250
right so we use CI when we do puppet

00:02:07,329 --> 00:02:10,720
class updates as well throughout the

00:02:09,250 --> 00:02:12,580
infrastructure with some of our

00:02:10,720 --> 00:02:14,150
customers if we're doing like OpenStack

00:02:12,580 --> 00:02:16,340
deployments or something like that

00:02:14,150 --> 00:02:17,989
we'll have a set of unit tests that we

00:02:16,340 --> 00:02:19,849
can run after we deploy systems and

00:02:17,989 --> 00:02:22,640
configure them the same is true for

00:02:19,849 --> 00:02:25,069
software the idea of writing the test

00:02:22,640 --> 00:02:28,430
first implementing the feature and then

00:02:25,069 --> 00:02:30,920
ensuring that the test succeeds these

00:02:28,430 --> 00:02:33,049
are all the things that we do in CI so

00:02:30,920 --> 00:02:35,930
there's kind of three pieces of testing

00:02:33,049 --> 00:02:38,540
and CI there's a test before you push so

00:02:35,930 --> 00:02:40,879
this is where I'm going to run a lint

00:02:38,540 --> 00:02:42,890
test against my particular set of source

00:02:40,879 --> 00:02:44,450
code I want to make sure that you know

00:02:42,890 --> 00:02:47,510
i'm using two spaces instead of a tab

00:02:44,450 --> 00:02:50,569
key of my Python things like that make

00:02:47,510 --> 00:02:52,060
sure that the code compiles syntax and

00:02:50,569 --> 00:02:54,440
then to some extent unit tests as well

00:02:52,060 --> 00:02:56,540
this is all stuff that I do on my

00:02:54,440 --> 00:02:58,760
workstation right so there's not really

00:02:56,540 --> 00:03:00,260
if you look at like opportunities to use

00:02:58,760 --> 00:03:03,379
docker and leverage doctor there really

00:03:00,260 --> 00:03:05,299
is a much darker there but when you get

00:03:03,379 --> 00:03:07,340
into the after the push you do have some

00:03:05,299 --> 00:03:08,569
opportunities right so traditionally

00:03:07,340 --> 00:03:10,370
what we'll do is we'll download source

00:03:08,569 --> 00:03:11,930
code onto a build machine will build it

00:03:10,370 --> 00:03:13,790
there and then we'll run our test there

00:03:11,930 --> 00:03:15,709
what this proves to us is that the code

00:03:13,790 --> 00:03:17,239
that I'm building isn't just code that I

00:03:15,709 --> 00:03:18,859
can build on my own workstation but it's

00:03:17,239 --> 00:03:22,910
good i can build somewhere out in a

00:03:18,859 --> 00:03:24,049
further environment docker can help us

00:03:22,910 --> 00:03:26,540
without reproducibility we'll take a

00:03:24,049 --> 00:03:28,760
look at that and then lastly you know

00:03:26,540 --> 00:03:30,169
the before you deploy so it's important

00:03:28,760 --> 00:03:32,659
to be doing integration testing

00:03:30,169 --> 00:03:34,669
performance testing it's one thing for

00:03:32,659 --> 00:03:36,169
the code to build on a build server and

00:03:34,669 --> 00:03:38,419
work past test out the build server but

00:03:36,169 --> 00:03:39,560
very different to have the code be

00:03:38,419 --> 00:03:40,940
deployed into a production environment

00:03:39,560 --> 00:03:43,849
and have the same performance

00:03:40,940 --> 00:03:45,650
characteristics that you have in the

00:03:43,849 --> 00:03:48,079
current running build so that anybody

00:03:45,650 --> 00:03:50,449
read limoncellos new book cloud system

00:03:48,079 --> 00:03:52,430
administration this is a really good

00:03:50,449 --> 00:03:53,599
book it's out there he wrote the

00:03:52,430 --> 00:03:55,819
practice of networking system

00:03:53,599 --> 00:03:57,319
administration a while back and now he

00:03:55,819 --> 00:03:59,379
has a book around cloud system

00:03:57,319 --> 00:04:02,510
administration and he talks a lot about

00:03:59,379 --> 00:04:03,440
how agile development DevOps some of

00:04:02,510 --> 00:04:04,879
these things have changed the way that

00:04:03,440 --> 00:04:07,069
software is deployed we'll take a look

00:04:04,879 --> 00:04:08,449
at some of these practices later on but

00:04:07,069 --> 00:04:10,879
one of the most important things that he

00:04:08,449 --> 00:04:12,560
talks about is you know not only testing

00:04:10,879 --> 00:04:14,750
functionality not only doing user

00:04:12,560 --> 00:04:16,220
acceptance testing all that but really

00:04:14,750 --> 00:04:18,049
being really careful about performance

00:04:16,220 --> 00:04:20,840
testing right so if you're you know

00:04:18,049 --> 00:04:22,219
Google and all of a sudden your search

00:04:20,840 --> 00:04:23,659
requests take you know a hair of a

00:04:22,219 --> 00:04:25,880
second longer you just you know a

00:04:23,659 --> 00:04:27,389
web-scale it could be a dramatic change

00:04:25,880 --> 00:04:28,680
in the up in

00:04:27,389 --> 00:04:31,439
and you know either the either it works

00:04:28,680 --> 00:04:32,370
or it doesn't work right and then the

00:04:31,439 --> 00:04:33,629
last piece that we would talk about

00:04:32,370 --> 00:04:35,219
you're a little bit is merged testing

00:04:33,629 --> 00:04:37,770
right so if you've got a team of 25

00:04:35,219 --> 00:04:39,689
developers working together all the code

00:04:37,770 --> 00:04:41,340
comes in at the same time anything shows

00:04:39,689 --> 00:04:43,199
you're passing unit tests throughout all

00:04:41,340 --> 00:04:46,469
the developers code as an assembled

00:04:43,199 --> 00:04:49,139
whole this becomes much more important

00:04:46,469 --> 00:04:51,449
when you're working on open-source scale

00:04:49,139 --> 00:04:54,300
projects so this is an example pipeline

00:04:51,449 --> 00:04:55,860
from the OpenStack Nova project where

00:04:54,300 --> 00:04:57,120
you have hundreds of commits right

00:04:55,860 --> 00:04:59,969
coming in from hundreds of developers

00:04:57,120 --> 00:05:02,389
all the time is very important that as

00:04:59,969 --> 00:05:05,189
the code gets merged back to master

00:05:02,389 --> 00:05:07,139
we're doing lots and lots of CI on it to

00:05:05,189 --> 00:05:09,090
make sure that we're passing tests that

00:05:07,139 --> 00:05:11,060
you know this fix over here and that fix

00:05:09,090 --> 00:05:14,610
over there together don't break things

00:05:11,060 --> 00:05:17,699
so you know you see here in the in the

00:05:14,610 --> 00:05:20,479
CI pipeline for Nova code gets moved

00:05:17,699 --> 00:05:22,770
into a local environment than we do

00:05:20,479 --> 00:05:24,960
branching so we do feature branches bug

00:05:22,770 --> 00:05:26,550
fix branches we do all of our testing

00:05:24,960 --> 00:05:28,259
locally to make sure that we haven't

00:05:26,550 --> 00:05:30,659
broken anything they're using devstack

00:05:28,259 --> 00:05:31,979
we push it into Garrett you've got

00:05:30,659 --> 00:05:33,960
humans that take a look at it and

00:05:31,979 --> 00:05:35,969
Garrett do code audits code reviews you

00:05:33,960 --> 00:05:37,830
also have Jenkins do a code review by

00:05:35,969 --> 00:05:40,589
trying to build and pass unit tests and

00:05:37,830 --> 00:05:42,419
Garrett it passes then again to Jenkins

00:05:40,589 --> 00:05:44,360
once everyone has approved the change to

00:05:42,419 --> 00:05:47,250
make sure that all the changes together

00:05:44,360 --> 00:05:49,319
still have a functional whole and only

00:05:47,250 --> 00:05:51,149
then do things get past the gate into

00:05:49,319 --> 00:05:53,460
the master so this is kind of the model

00:05:51,149 --> 00:05:56,430
that I think organizations have

00:05:53,460 --> 00:05:59,370
successfully deployed in CI over the

00:05:56,430 --> 00:06:02,370
last you know SE 5-10 years as CIS

00:05:59,370 --> 00:06:04,259
become really big and become key this is

00:06:02,370 --> 00:06:06,449
a pretty typical CI workflow right has

00:06:04,259 --> 00:06:10,589
the human checks it has code reviews it

00:06:06,449 --> 00:06:13,229
has unit tests all these things now if

00:06:10,589 --> 00:06:15,060
you look at the CI workflow you kind of

00:06:13,229 --> 00:06:16,560
look here and you say is there an

00:06:15,060 --> 00:06:19,469
opportunity for a docker to help out

00:06:16,560 --> 00:06:21,569
here hmm maybe right but this this

00:06:19,469 --> 00:06:22,770
workflow works pretty well just using

00:06:21,569 --> 00:06:24,210
the traditional tooling and it's

00:06:22,770 --> 00:06:26,399
something that we've had for a while so

00:06:24,210 --> 00:06:29,819
what kind of look later i think i think

00:06:26,399 --> 00:06:32,310
the real opportunity for docker you know

00:06:29,819 --> 00:06:33,779
is in CB we talked about that the

00:06:32,310 --> 00:06:36,240
continuous delivery that's where the

00:06:33,779 --> 00:06:37,529
doctor is really key so for our example

00:06:36,240 --> 00:06:40,680
application that we're looking at today

00:06:37,529 --> 00:06:42,840
it's the Django poles application

00:06:40,680 --> 00:06:46,410
I here is a build script that we run in

00:06:42,840 --> 00:06:47,100
Jenkins that just does basic testing I'm

00:06:46,410 --> 00:06:49,160
going to point out a couple

00:06:47,100 --> 00:06:52,110
characteristics about the build script

00:06:49,160 --> 00:06:53,400
and and how the and this is the one

00:06:52,110 --> 00:06:55,740
place where I think docker does make a

00:06:53,400 --> 00:06:57,960
big difference so when you're doing

00:06:55,740 --> 00:06:59,940
builds at least of Python applications

00:06:57,960 --> 00:07:02,610
and someone is true for JE apps and

00:06:59,940 --> 00:07:05,430
other applications as well you want to

00:07:02,610 --> 00:07:07,919
do something you know in Python it's

00:07:05,430 --> 00:07:09,600
using a virtual environment in in Java

00:07:07,919 --> 00:07:10,770
you see people kind of having build

00:07:09,600 --> 00:07:11,699
trees but you want to make sure that you

00:07:10,770 --> 00:07:13,729
have kind of a clean room environment

00:07:11,699 --> 00:07:16,020
where you're pulling requirements and

00:07:13,729 --> 00:07:17,250
for each of the builds on the build

00:07:16,020 --> 00:07:19,740
server right you don't want to have this

00:07:17,250 --> 00:07:21,690
projects build affected by someone

00:07:19,740 --> 00:07:23,849
needing a different version of something

00:07:21,690 --> 00:07:26,490
over here so in Python we solve this

00:07:23,849 --> 00:07:27,539
problem using virtual environments you

00:07:26,490 --> 00:07:28,919
see the first thing that I do in my

00:07:27,539 --> 00:07:30,690
Jenkins build script for the django app

00:07:28,919 --> 00:07:34,860
is that i created a virtual environment

00:07:30,690 --> 00:07:36,419
i install my requirements I validate and

00:07:34,860 --> 00:07:37,710
then sync and then test that's the other

00:07:36,419 --> 00:07:41,400
kind of three steps i'm going to use to

00:07:37,710 --> 00:07:42,300
do testing on my django app right so one

00:07:41,400 --> 00:07:43,860
thing to think about and we'll see this

00:07:42,300 --> 00:07:46,620
when we do Dockers when I do a darker

00:07:43,860 --> 00:07:48,000
deployment of an application I don't

00:07:46,620 --> 00:07:49,260
have to use a virtual environment right

00:07:48,000 --> 00:07:51,360
because I'm running inside of a linux

00:07:49,260 --> 00:07:53,190
container and then another thing that's

00:07:51,360 --> 00:07:54,870
really nice when I'm doing this with

00:07:53,190 --> 00:07:57,960
docker is that you're here i'm doing a

00:07:54,870 --> 00:07:59,909
pip install into my virtual environment

00:07:57,960 --> 00:08:01,470
well how do i know that my production

00:07:59,909 --> 00:08:02,940
environment is using the same versions

00:08:01,470 --> 00:08:05,940
of applications that i'm getting in my

00:08:02,940 --> 00:08:07,380
virtual environment you know inside of

00:08:05,940 --> 00:08:12,449
the unit testing so that's something to

00:08:07,380 --> 00:08:14,669
think about as well so let's talk about

00:08:12,449 --> 00:08:17,340
CD because I think that's where docker

00:08:14,669 --> 00:08:18,389
makes the largest impact and I think

00:08:17,340 --> 00:08:21,090
where we're seeing you know the

00:08:18,389 --> 00:08:22,680
strongest adoption of it so the first

00:08:21,090 --> 00:08:25,830
thing and if you saw Joe's talk earlier

00:08:22,680 --> 00:08:29,820
we talked about packaging formats we

00:08:25,830 --> 00:08:31,770
discuss that a little bit here dark kind

00:08:29,820 --> 00:08:33,750
of obviates the need for packaging

00:08:31,770 --> 00:08:35,610
formats in one hand in that we're

00:08:33,750 --> 00:08:37,620
passing around docker images and we're

00:08:35,610 --> 00:08:38,909
not passing around our pm's anymore but

00:08:37,620 --> 00:08:41,010
on the other hand it leverages it to

00:08:38,909 --> 00:08:42,690
write like when I'm installing code to

00:08:41,010 --> 00:08:44,219
create the docker image I'm still going

00:08:42,690 --> 00:08:45,750
to use pip or I'm going to use our p.m.

00:08:44,219 --> 00:08:50,070
or I'm going to use tools like that jars

00:08:45,750 --> 00:08:52,079
Wars ears tars so to some extent the

00:08:50,070 --> 00:08:53,610
packaging obviated that the differences

00:08:52,079 --> 00:08:54,430
in the languages in ways but on the

00:08:53,610 --> 00:08:57,220
other extent of their

00:08:54,430 --> 00:08:58,960
and even though I have a docker image at

00:08:57,220 --> 00:09:01,029
the end result I'm still using my native

00:08:58,960 --> 00:09:02,649
tooling so the good news there is that

00:09:01,029 --> 00:09:04,420
stuff that I've already done doesn't go

00:09:02,649 --> 00:09:05,440
away when i go to create my docker image

00:09:04,420 --> 00:09:07,000
right i'm still using my yum

00:09:05,440 --> 00:09:10,089
repositories i'm still doing all these

00:09:07,000 --> 00:09:11,740
things but the even better news is that

00:09:10,089 --> 00:09:13,690
my end result isn't something that has

00:09:11,740 --> 00:09:16,120
to be deployed differently so i think

00:09:13,690 --> 00:09:20,110
that's a huge huge advantage of docker

00:09:16,120 --> 00:09:21,430
and CD but in the traditional one we

00:09:20,110 --> 00:09:23,410
still had ways to do this right so you

00:09:21,430 --> 00:09:25,000
think about you know the application

00:09:23,410 --> 00:09:27,339
look at the steps a little bit but you

00:09:25,000 --> 00:09:29,860
take the RPM result out of the build but

00:09:27,339 --> 00:09:33,550
it in the UM repo pull it down so on and

00:09:29,860 --> 00:09:35,560
so forth the trick here is that every

00:09:33,550 --> 00:09:37,029
bill that I'm doing that succeeds passes

00:09:35,560 --> 00:09:38,470
through a gate goes into the repository

00:09:37,029 --> 00:09:40,450
and is coming out into the environment

00:09:38,470 --> 00:09:42,520
for me to test right there's no human

00:09:40,450 --> 00:09:45,760
being picking up a release and sending

00:09:42,520 --> 00:09:47,140
it out so for our application let's look

00:09:45,760 --> 00:09:49,149
at the traditional actual deployment

00:09:47,140 --> 00:09:52,390
process the first thing I might do if

00:09:49,149 --> 00:09:53,860
I'm building it into an RPM maybe I got

00:09:52,390 --> 00:09:55,839
a package dot spec that I'm putting

00:09:53,860 --> 00:09:57,640
inside of the source code repository I'm

00:09:55,839 --> 00:10:00,250
running an RPM build on it getting a

00:09:57,640 --> 00:10:02,890
package artifact taking that artifact

00:10:00,250 --> 00:10:04,450
pushing it into a repository but then

00:10:02,890 --> 00:10:05,770
here's the trick right so now I've got

00:10:04,450 --> 00:10:09,100
that package and it's in the repository

00:10:05,770 --> 00:10:10,660
how do I get it out in the uat right

00:10:09,100 --> 00:10:12,310
well now I have to log into all of my

00:10:10,660 --> 00:10:15,220
uit servers and I have to do a yum

00:10:12,310 --> 00:10:16,570
update how do I roll back the UM up that

00:10:15,220 --> 00:10:18,060
you know I mean kind of you end up in

00:10:16,570 --> 00:10:20,950
all these traditional you know

00:10:18,060 --> 00:10:22,630
complications around the actual pushing

00:10:20,950 --> 00:10:25,600
and pulling down and then you have to

00:10:22,630 --> 00:10:27,370
restart services and this process is

00:10:25,600 --> 00:10:30,430
different for every different type of

00:10:27,370 --> 00:10:32,740
artifact right so this works for rpms

00:10:30,430 --> 00:10:34,779
but it doesn't work for ears doesn't

00:10:32,740 --> 00:10:36,730
work for Wars or jars and so what we

00:10:34,779 --> 00:10:38,920
find is we find people packaging jars as

00:10:36,730 --> 00:10:40,270
rpms or you package wars as rpms or you

00:10:38,920 --> 00:10:42,850
take Python package as you turn them

00:10:40,270 --> 00:10:46,029
into rpms so that you have a consistent

00:10:42,850 --> 00:10:47,200
way to do updates and roll backs but

00:10:46,029 --> 00:10:49,060
there was a lot of engineering that's

00:10:47,200 --> 00:10:50,709
gone into these pipelines right to

00:10:49,060 --> 00:10:53,350
create that kind of ability to do that

00:10:50,709 --> 00:10:54,790
and then you have a lot of people in a

00:10:53,350 --> 00:10:56,230
lot of environments that instead of

00:10:54,790 --> 00:10:58,360
doing this right they just do a kick

00:10:56,230 --> 00:10:59,589
start they just grabbed three virtual

00:10:58,360 --> 00:11:01,660
machines and Kickstarter right they

00:10:59,589 --> 00:11:04,660
might go into OpenStack and do some kick

00:11:01,660 --> 00:11:07,400
start so they might you know bare metal

00:11:04,660 --> 00:11:11,690
kickstart boxes to create

00:11:07,400 --> 00:11:13,460
you know this process of deploying it's

00:11:11,690 --> 00:11:17,120
kind of long and painful and a little

00:11:13,460 --> 00:11:19,190
bit complex lastly let's look at the

00:11:17,120 --> 00:11:20,450
rollout so let's say we get through all

00:11:19,190 --> 00:11:21,770
the testing we've done our continuous

00:11:20,450 --> 00:11:24,080
integration testing we've done our

00:11:21,770 --> 00:11:26,450
continuous delivery the build is out

00:11:24,080 --> 00:11:27,830
into the uat environment and in this

00:11:26,450 --> 00:11:29,750
diagram it's a little small but on the

00:11:27,830 --> 00:11:31,850
left side I've got build 32 running on

00:11:29,750 --> 00:11:33,350
two machines I build 30 running on four

00:11:31,850 --> 00:11:36,320
over here there's a load balancer

00:11:33,350 --> 00:11:38,030
sitting in front if it kind of laughs

00:11:36,320 --> 00:11:39,620
that's the process I have a human user

00:11:38,030 --> 00:11:41,300
looking at build 32 running in that

00:11:39,620 --> 00:11:43,220
testing environment or maybe I switch up

00:11:41,300 --> 00:11:44,960
or a subset of my live users in

00:11:43,220 --> 00:11:46,970
production to that testing environment

00:11:44,960 --> 00:11:48,770
and assuming there's I'm watching the

00:11:46,970 --> 00:11:51,620
logs that there are no failures so you

00:11:48,770 --> 00:11:53,090
know 4 or 4s or five hundreds or if I've

00:11:51,620 --> 00:11:54,080
got a human user they're seeing the

00:11:53,090 --> 00:11:56,960
things that they want to see in the

00:11:54,080 --> 00:11:59,630
application then I slowly start updating

00:11:56,960 --> 00:12:02,030
pull a production box out of out of the

00:11:59,630 --> 00:12:04,430
rotation load balancer I do a yum update

00:12:02,030 --> 00:12:05,900
on it I've restart services and I bring

00:12:04,430 --> 00:12:08,180
it back into the load balance right I

00:12:05,900 --> 00:12:10,730
start you know one by one scooting

00:12:08,180 --> 00:12:13,160
across and using the load balancer to

00:12:10,730 --> 00:12:17,330
bring in boxes up to build 32 instead of

00:12:13,160 --> 00:12:19,730
build 30 and this works right this is a

00:12:17,330 --> 00:12:21,920
tried and true way to do it and you can

00:12:19,730 --> 00:12:25,960
do this without docker right and we do

00:12:21,920 --> 00:12:28,160
this today but let's take a look at

00:12:25,960 --> 00:12:30,140
docker and let's run through the same

00:12:28,160 --> 00:12:34,340
pipeline with docker see how this is

00:12:30,140 --> 00:12:36,650
different right so like we said you know

00:12:34,340 --> 00:12:40,100
that the main advantages of docker the

00:12:36,650 --> 00:12:41,690
consistent delivery format another one

00:12:40,100 --> 00:12:44,150
that we didn't talk about consistent

00:12:41,690 --> 00:12:46,370
packaging definition right so everything

00:12:44,150 --> 00:12:48,950
is stored in the docker file I don't

00:12:46,370 --> 00:12:50,870
have specs I don't have maven build XML

00:12:48,950 --> 00:12:53,000
zor palms or whatever right I have a

00:12:50,870 --> 00:12:54,290
docker file and everyone can learn how

00:12:53,000 --> 00:12:57,080
to write a docker file it's just

00:12:54,290 --> 00:12:58,310
basically shell scripts and so really

00:12:57,080 --> 00:13:00,490
simple and I check it into my code

00:12:58,310 --> 00:13:02,420
repository we'll see how that works and

00:13:00,490 --> 00:13:03,830
then the last piece that's really

00:13:02,420 --> 00:13:06,620
important with docker that we don't talk

00:13:03,830 --> 00:13:09,140
about a lot is that docker has built-in

00:13:06,620 --> 00:13:10,880
deployment infrastructure out-of-the-box

00:13:09,140 --> 00:13:13,220
docker has a way for me to take some

00:13:10,880 --> 00:13:14,870
code turn it into an image push it

00:13:13,220 --> 00:13:18,200
somewhere and then have it immediately

00:13:14,870 --> 00:13:20,120
be available to my environment to pull

00:13:18,200 --> 00:13:21,200
out their kind of like a built-in yum

00:13:20,120 --> 00:13:23,660
repository or

00:13:21,200 --> 00:13:26,840
built in Python package index or things

00:13:23,660 --> 00:13:29,420
like that right and it's across the

00:13:26,840 --> 00:13:31,540
board right so my java apps my python

00:13:29,420 --> 00:13:37,370
apps all that can be in the same

00:13:31,540 --> 00:13:39,320
registry coming back to the idea of

00:13:37,370 --> 00:13:41,630
formats i just wanted to kind of put up

00:13:39,320 --> 00:13:43,580
here i think this is interesting you

00:13:41,630 --> 00:13:44,950
know the way that the formats differ and

00:13:43,580 --> 00:13:47,510
the traditional and the docker

00:13:44,950 --> 00:13:48,740
deployment models you think about the

00:13:47,510 --> 00:13:50,030
bottom half of this you know you have

00:13:48,740 --> 00:13:51,110
your kernel your system libraries in

00:13:50,030 --> 00:13:52,340
your application libraries these

00:13:51,110 --> 00:13:53,930
typically come from your distribution

00:13:52,340 --> 00:13:55,670
vendor right so this is right at

00:13:53,930 --> 00:13:57,350
providing this or sent us providing this

00:13:55,670 --> 00:14:00,740
and it's going to be in the operating

00:13:57,350 --> 00:14:02,960
system format so be RPM or apt right and

00:14:00,740 --> 00:14:04,610
then above that you know your actual

00:14:02,960 --> 00:14:06,170
container is either going to come from a

00:14:04,610 --> 00:14:09,800
vendor like right at it might be jboss

00:14:06,170 --> 00:14:10,850
EAP or it might come from ipoh or it

00:14:09,800 --> 00:14:12,650
might be something that you roll in

00:14:10,850 --> 00:14:14,270
house right that is where we typically

00:14:12,650 --> 00:14:16,940
start to see the package formats diverge

00:14:14,270 --> 00:14:19,580
so a Python container might be installed

00:14:16,940 --> 00:14:21,800
via pip you might have a Java container

00:14:19,580 --> 00:14:26,750
that's downloaded as a zip file you

00:14:21,800 --> 00:14:29,360
might have you know to Ruby however the

00:14:26,750 --> 00:14:30,500
Ruby guys do it with gems right so you

00:14:29,360 --> 00:14:32,030
start to see that divergence are at the

00:14:30,500 --> 00:14:34,700
container level and then at the very top

00:14:32,030 --> 00:14:39,770
you typically see developers yes

00:14:34,700 --> 00:14:41,120
question that's absolutely right yeah

00:14:39,770 --> 00:14:42,440
I'm talking about the layers of the

00:14:41,120 --> 00:14:45,770
application stack for a Django

00:14:42,440 --> 00:14:46,880
application absolutely right so you know

00:14:45,770 --> 00:14:48,140
you think about the top you know the

00:14:46,880 --> 00:14:51,110
developer wants to take his source code

00:14:48,140 --> 00:14:52,460
and drop it in a container right and so

00:14:51,110 --> 00:14:55,520
that'll take a different format right it

00:14:52,460 --> 00:14:57,440
might be a git checkout or it might be a

00:14:55,520 --> 00:15:00,340
tarball or something like that it gets

00:14:57,440 --> 00:15:00,340
dropped into the container

00:15:00,460 --> 00:15:03,770
organizationally this is evolved because

00:15:02,480 --> 00:15:05,750
different people are doing these

00:15:03,770 --> 00:15:07,370
different tasks right so your Linux

00:15:05,750 --> 00:15:08,930
distributor is picking a package format

00:15:07,370 --> 00:15:11,030
to give you the bottom three pieces of

00:15:08,930 --> 00:15:13,190
the stack to write so red hat decided

00:15:11,030 --> 00:15:15,410
our p.m. today and whatever it is

00:15:13,190 --> 00:15:17,720
tomorrow I forget what it is but and

00:15:15,410 --> 00:15:19,400
then you know up higher you know you've

00:15:17,720 --> 00:15:21,890
got an operations engineering team

00:15:19,400 --> 00:15:23,810
that's decided hey everyone in my

00:15:21,890 --> 00:15:25,520
company is going to use Django 16 and

00:15:23,810 --> 00:15:27,620
it's going to be our build of Django 16

00:15:25,520 --> 00:15:29,990
and it's either going to be an RPM or a

00:15:27,620 --> 00:15:31,460
pip or whatever right and then the top

00:15:29,990 --> 00:15:32,990
layer the developer is kind of making

00:15:31,460 --> 00:15:34,520
the decision as far as or at least the

00:15:32,990 --> 00:15:34,819
developers architecture team is making

00:15:34,520 --> 00:15:35,989
it

00:15:34,819 --> 00:15:37,339
is how they're going to deliver coat

00:15:35,989 --> 00:15:39,379
artifacts and that's why the

00:15:37,339 --> 00:15:43,970
segmentation in formats has seemed to be

00:15:39,379 --> 00:15:45,979
okay up to this point but as these roles

00:15:43,970 --> 00:15:48,229
start to merge right you know I kind of

00:15:45,979 --> 00:15:49,549
yeah the container typically comes from

00:15:48,229 --> 00:15:51,529
an engineering team but let's say it

00:15:49,549 --> 00:15:53,929
could be an operational engineering team

00:15:51,529 --> 00:15:55,189
so i can get DevOps into this talk but

00:15:53,929 --> 00:15:56,809
let's say as those roles start to merge

00:15:55,189 --> 00:15:58,249
and you've got application teams that

00:15:56,809 --> 00:15:59,600
are interested in working on engineering

00:15:58,249 --> 00:16:02,059
or you've got engineering teams that are

00:15:59,600 --> 00:16:03,410
going to write some applications the

00:16:02,059 --> 00:16:04,759
disparate package format start to become

00:16:03,410 --> 00:16:06,889
a problem right because the domain

00:16:04,759 --> 00:16:08,809
expert in writing RPM spec files is not

00:16:06,889 --> 00:16:11,809
going to be a domain expert in writing

00:16:08,809 --> 00:16:15,439
maven files and so having consistent

00:16:11,809 --> 00:16:17,119
package format with docker having a

00:16:15,439 --> 00:16:19,519
docker file format that everyone can

00:16:17,119 --> 00:16:21,109
rely on enable some transition and

00:16:19,519 --> 00:16:24,049
crossover between the different roles in

00:16:21,109 --> 00:16:25,879
the organization so you kind of look at

00:16:24,049 --> 00:16:28,970
we had the applications sufficiently

00:16:25,879 --> 00:16:31,189
this is a docker application stack on

00:16:28,970 --> 00:16:34,009
here the bottom I have you know rel

00:16:31,189 --> 00:16:36,019
seven atomic we talked about atomic and

00:16:34,009 --> 00:16:39,069
joe's talk earlier today atomic is Red

00:16:36,019 --> 00:16:41,539
Hat's docker running operating system

00:16:39,069 --> 00:16:44,269
custom tailored for running docker

00:16:41,539 --> 00:16:45,979
containers and it's distributed as a

00:16:44,269 --> 00:16:47,419
binary image right and you roll forward

00:16:45,979 --> 00:16:49,999
in your rollback binary image is just

00:16:47,419 --> 00:16:51,470
like you do with docker images so that's

00:16:49,999 --> 00:16:54,350
provided by the distributor now the

00:16:51,470 --> 00:16:56,149
distributor will also provide you with a

00:16:54,350 --> 00:16:58,189
layer above to do the system libraries

00:16:56,149 --> 00:17:01,100
so in this particular example I've got a

00:16:58,189 --> 00:17:04,339
rel seven atomic colonel I'm running a

00:17:01,100 --> 00:17:07,970
rel 6 system library on top of that with

00:17:04,339 --> 00:17:09,789
a red hat provided rail 6 image and then

00:17:07,970 --> 00:17:13,189
above that you know red hat provides

00:17:09,789 --> 00:17:15,319
images for certain languages in certain

00:17:13,189 --> 00:17:17,720
operating systems as a part of our

00:17:15,319 --> 00:17:20,299
openshift offering this one could also

00:17:17,720 --> 00:17:21,620
be created in-house if you have a you

00:17:20,299 --> 00:17:23,209
know an engineering team that wants to

00:17:21,620 --> 00:17:25,970
create your own Python distribution on

00:17:23,209 --> 00:17:28,610
top of rel six then I have a docker

00:17:25,970 --> 00:17:30,110
image on the top that's Django so this

00:17:28,610 --> 00:17:31,669
maybe is a centralized engineering

00:17:30,110 --> 00:17:33,559
organization so as my django container

00:17:31,669 --> 00:17:36,950
looks like this its version one not six

00:17:33,559 --> 00:17:38,450
dot one here's my image and then lastly

00:17:36,950 --> 00:17:41,809
the developer who's writing the polls

00:17:38,450 --> 00:17:45,830
application his docker file you know

00:17:41,809 --> 00:17:48,410
pulls the Django six docker file which

00:17:45,830 --> 00:17:51,410
creates this heredity so what

00:17:48,410 --> 00:17:54,170
it's neat about this right is you might

00:17:51,410 --> 00:17:55,580
have a developer writing a docker file

00:17:54,170 --> 00:17:57,530
for the container because they're

00:17:55,580 --> 00:17:59,630
working you know in the same technology

00:17:57,530 --> 00:18:01,340
space but you might also use the exact

00:17:59,630 --> 00:18:03,260
same organizational structure that you

00:18:01,340 --> 00:18:05,510
had today right where you have a

00:18:03,260 --> 00:18:09,710
container engineering group that's got

00:18:05,510 --> 00:18:12,290
standards around jboss or or rails or

00:18:09,710 --> 00:18:13,910
whatever and wants to maintain a single

00:18:12,290 --> 00:18:15,560
container image that all the different

00:18:13,910 --> 00:18:16,520
development teams use because

00:18:15,560 --> 00:18:19,040
everybody's speaking the same language

00:18:16,520 --> 00:18:24,650
it doesn't matter so much right you can

00:18:19,040 --> 00:18:26,180
really cross over back and forth so if

00:18:24,650 --> 00:18:28,820
we look before at a deploy process in

00:18:26,180 --> 00:18:30,710
the traditional sense and we'll look at

00:18:28,820 --> 00:18:32,990
this now you know in a minute here with

00:18:30,710 --> 00:18:34,310
the polls application but the deployment

00:18:32,990 --> 00:18:35,450
process is radically different with

00:18:34,310 --> 00:18:37,160
docker and this is where things really

00:18:35,450 --> 00:18:39,650
start to change right so instead of

00:18:37,160 --> 00:18:41,720
packaging up my source code I just drop

00:18:39,650 --> 00:18:43,970
it into the docker image using the

00:18:41,720 --> 00:18:46,340
docker file right so I uses you know add

00:18:43,970 --> 00:18:48,980
dot web apps bowls and take my coat and

00:18:46,340 --> 00:18:51,800
I drop it into the docker image and then

00:18:48,980 --> 00:18:53,630
I build the image right so the first two

00:18:51,800 --> 00:18:54,770
steps here totally the same regardless

00:18:53,630 --> 00:18:56,930
of what kind of source code i'm using

00:18:54,770 --> 00:19:00,650
right doesn't matter could be java could

00:18:56,930 --> 00:19:02,330
be python could be Ruby and then the

00:19:00,650 --> 00:19:04,430
result is a docker image that I can then

00:19:02,330 --> 00:19:06,410
take and deploy so I'll tag it and then

00:19:04,430 --> 00:19:07,910
I push it and it's out in the registry

00:19:06,410 --> 00:19:09,560
there's like three or four commands

00:19:07,910 --> 00:19:12,200
right I already have my source code

00:19:09,560 --> 00:19:13,520
deployed in a way that my you ain t

00:19:12,200 --> 00:19:16,340
environment can go ahead and pull it

00:19:13,520 --> 00:19:17,810
down and then when it pulls it down this

00:19:16,340 --> 00:19:19,760
is where things are really radically

00:19:17,810 --> 00:19:21,770
different right so if you think about

00:19:19,760 --> 00:19:23,750
the traditional deployment model where

00:19:21,770 --> 00:19:25,940
I'm doing a rollout I've got the you

00:19:23,750 --> 00:19:27,710
know Bill 32 on the left I got billed 30

00:19:25,940 --> 00:19:30,080
on the right I'm rolling machines back

00:19:27,710 --> 00:19:32,210
and forth with docker since its

00:19:30,080 --> 00:19:33,980
containers I can simultaneously run both

00:19:32,210 --> 00:19:36,200
builds on all the machines in my

00:19:33,980 --> 00:19:38,210
production environment right I can run

00:19:36,200 --> 00:19:40,370
one build on port 8080 I can run the

00:19:38,210 --> 00:19:43,070
next build on port 8081 the next build

00:19:40,370 --> 00:19:44,930
on port 8080 to and instead of taking

00:19:43,070 --> 00:19:46,640
machines in and out of my load balancer

00:19:44,930 --> 00:19:48,950
pools what I'm doing instead is I'm just

00:19:46,640 --> 00:19:50,510
changing the port's right so let's say

00:19:48,950 --> 00:19:52,550
that everyone's working great on port

00:19:50,510 --> 00:19:53,960
8080 then I can move the load balancer

00:19:52,550 --> 00:19:55,640
to that port everyone starts to work

00:19:53,960 --> 00:19:58,700
really well on 80 81 i move the load

00:19:55,640 --> 00:20:00,740
balancer to that port maybe I found a

00:19:58,700 --> 00:20:02,230
problem you know five minutes ten

00:20:00,740 --> 00:20:04,280
minutes into my deployment on port 80

00:20:02,230 --> 00:20:05,900
no problem I just point the load

00:20:04,280 --> 00:20:08,480
balancer back to 80 80 and I've

00:20:05,900 --> 00:20:09,710
immediately rollback my environment but

00:20:08,480 --> 00:20:11,690
and that is that is the real difference

00:20:09,710 --> 00:20:13,700
right that's why web-scale companies are

00:20:11,690 --> 00:20:16,190
adopting the container format in the

00:20:13,700 --> 00:20:17,750
container deployment model because it's

00:20:16,190 --> 00:20:19,850
so much you know so much radically

00:20:17,750 --> 00:20:24,200
different when I go to actually do the

00:20:19,850 --> 00:20:25,640
roll out in the rollback so it's been a

00:20:24,200 --> 00:20:26,990
long time since I've done a production

00:20:25,640 --> 00:20:29,570
rollout of code but I remember sitting

00:20:26,990 --> 00:20:31,520
for hours with operations teams as we

00:20:29,570 --> 00:20:34,310
kick started boxes trying to get back or

00:20:31,520 --> 00:20:36,590
trying to go forward you know with the

00:20:34,310 --> 00:20:38,030
new model use just seconds right like

00:20:36,590 --> 00:20:42,230
I'm just I'm just moving the stream of

00:20:38,030 --> 00:20:47,270
requests in and out so let's actually go

00:20:42,230 --> 00:20:48,830
to the demo so first of all I'm going to

00:20:47,270 --> 00:20:50,720
start with the Jenkins dashboard so I'm

00:20:48,830 --> 00:20:53,030
using Jenkins which that's you know that

00:20:50,720 --> 00:20:55,190
means you're doing see I right has ever

00:20:53,030 --> 00:20:56,330
been to a tech new there's the joke that

00:20:55,190 --> 00:20:57,890
everyone talks about really like Haiti

00:20:56,330 --> 00:20:59,690
you do see I know oh yeah i'll use

00:20:57,890 --> 00:21:03,080
Jenkins and then actually aren't doing

00:20:59,690 --> 00:21:08,810
CI but I maybe not a funny joke anyway

00:21:03,080 --> 00:21:10,790
here's that here's will continuous

00:21:08,810 --> 00:21:12,710
integration i have i define it as taking

00:21:10,790 --> 00:21:14,990
the source code running tests on it

00:21:12,710 --> 00:21:16,910
getting feedback so it's all about

00:21:14,990 --> 00:21:18,320
feedback it's all about getting the

00:21:16,910 --> 00:21:20,390
feedback before I commit to make sure

00:21:18,320 --> 00:21:22,670
you know hey system tell me did I write

00:21:20,390 --> 00:21:24,560
a mistake getting feedback after the

00:21:22,670 --> 00:21:26,570
commit did my test pass then getting

00:21:24,560 --> 00:21:27,980
feedback as it goes to build and it's

00:21:26,570 --> 00:21:29,450
feedback at all these different levels

00:21:27,980 --> 00:21:30,770
that makes it continuously integrate and

00:21:29,450 --> 00:21:32,030
then also pulling all the commits

00:21:30,770 --> 00:21:34,280
together that's the integration part

00:21:32,030 --> 00:21:37,820
right so my commit pops commit together

00:21:34,280 --> 00:21:39,380
let's get feedback yes the previous

00:21:37,820 --> 00:21:41,030
question was and how do you define

00:21:39,380 --> 00:21:42,950
continuous integration if it's not

00:21:41,030 --> 00:21:44,870
Jenkins right because I think that's the

00:21:42,950 --> 00:21:50,210
joke is someone asked hey what's CI and

00:21:44,870 --> 00:21:53,390
you say oh it's Jenkins but people used

00:21:50,210 --> 00:21:54,740
a close you probably are you probably

00:21:53,390 --> 00:21:56,060
are doing it right and that's why the

00:21:54,740 --> 00:21:58,310
joke is that's why the joke is

00:21:56,060 --> 00:22:00,920
interesting right because it's hard to

00:21:58,310 --> 00:22:02,210
do CI without a tool like Jenkins most

00:22:00,920 --> 00:22:05,900
people that do use Jenkins are doing CI

00:22:02,210 --> 00:22:07,400
but so and actually all of that said

00:22:05,900 --> 00:22:08,960
this particular example that I have up

00:22:07,400 --> 00:22:10,310
here does not provide feedback except

00:22:08,960 --> 00:22:12,590
for the webform so I'm probably not

00:22:10,310 --> 00:22:15,180
actually really doing CI here so but it

00:22:12,590 --> 00:22:16,980
kind of brings it all full circle but

00:22:15,180 --> 00:22:19,650
um let's talk about what I have to find

00:22:16,980 --> 00:22:20,580
her so I have a CI demo this is the

00:22:19,650 --> 00:22:21,900
project that we're going to be looking

00:22:20,580 --> 00:22:24,720
at today we're going to be deploying

00:22:21,900 --> 00:22:26,850
modifying the source code then I have

00:22:24,720 --> 00:22:28,470
two steps I have a package step so this

00:22:26,850 --> 00:22:30,210
takes the CI demo code and actually

00:22:28,470 --> 00:22:32,580
creates a Python archive that we could

00:22:30,210 --> 00:22:35,580
then deploy and a rather cumbersome way

00:22:32,580 --> 00:22:38,010
using the traditional pipeline and then

00:22:35,580 --> 00:22:40,080
I have a docker build as well right so

00:22:38,010 --> 00:22:41,250
if the code completes the first step and

00:22:40,080 --> 00:22:44,070
all the tests pass and everything is

00:22:41,250 --> 00:22:46,800
good and I do my my integration testing

00:22:44,070 --> 00:22:47,970
on the source code there see I demo then

00:22:46,800 --> 00:22:49,740
it moves into these two subsequent

00:22:47,970 --> 00:22:51,810
builds and I have one that does doc or

00:22:49,740 --> 00:22:54,930
packaging and one that creates the

00:22:51,810 --> 00:22:58,050
Python package the docker packaging step

00:22:54,930 --> 00:23:00,420
also deploys the new docker image to my

00:22:58,050 --> 00:23:01,890
daugher registry and what we'll see here

00:23:00,420 --> 00:23:03,540
is once it's deployed to the registry I

00:23:01,890 --> 00:23:07,200
can pull it down on a relative eck host

00:23:03,540 --> 00:23:09,840
and fire it up and start it and then

00:23:07,200 --> 00:23:13,170
also i'm building my docker images from

00:23:09,840 --> 00:23:16,560
CI and that is a probably discussion for

00:23:13,170 --> 00:23:18,090
you know a longer discussion but since

00:23:16,560 --> 00:23:20,340
you chuck our image builds on each other

00:23:18,090 --> 00:23:22,350
you know say i have myrelle six docker

00:23:20,340 --> 00:23:24,990
image and then i have my django image

00:23:22,350 --> 00:23:27,120
and then i have my actual application

00:23:24,990 --> 00:23:28,860
image as we move to the application

00:23:27,120 --> 00:23:30,660
lifecycle of each one I need to rebuild

00:23:28,860 --> 00:23:32,700
my images right so if I get some updates

00:23:30,660 --> 00:23:35,340
from Red Hat and rel six I need to reach

00:23:32,700 --> 00:23:37,260
up date myrelle 6 image then I need to

00:23:35,340 --> 00:23:39,060
update all the images that come beneath

00:23:37,260 --> 00:23:41,190
that so what we do is we use the tool

00:23:39,060 --> 00:23:42,720
like Jenkins to set up these build

00:23:41,190 --> 00:23:44,340
workflows where I can build one image

00:23:42,720 --> 00:23:45,780
after another one gets updated after

00:23:44,340 --> 00:23:47,340
another one and then automatically

00:23:45,780 --> 00:23:51,960
deploy them out to my environment so i

00:23:47,340 --> 00:23:53,370
can switch back and forth right and then

00:23:51,960 --> 00:23:55,260
let's just real quickly look at the

00:23:53,370 --> 00:23:58,140
actual projects so now i'm looking at

00:23:55,260 --> 00:24:00,450
the CI demo project will just look at

00:23:58,140 --> 00:24:04,170
the build script it's the one that we

00:24:00,450 --> 00:24:07,490
had defined before down here right so

00:24:04,170 --> 00:24:09,450
i'm creating a virtual environment i'm

00:24:07,490 --> 00:24:10,860
entering into the virtual environment

00:24:09,450 --> 00:24:13,500
installing my requirements and then I'm

00:24:10,860 --> 00:24:18,480
running the basic tests right validate

00:24:13,500 --> 00:24:19,470
sync TV and then unit test one thing

00:24:18,480 --> 00:24:21,750
though years I do create the virtual

00:24:19,470 --> 00:24:23,700
environment in this step but when we

00:24:21,750 --> 00:24:25,890
look at the darker build that does not

00:24:23,700 --> 00:24:27,150
run in a virtual environment just runs

00:24:25,890 --> 00:24:28,860
natively in the container and the

00:24:27,150 --> 00:24:32,760
container provides the virtual

00:24:28,860 --> 00:24:35,370
virtual environment isolation for us and

00:24:32,760 --> 00:24:38,840
then let's look at the docker project

00:24:35,370 --> 00:24:38,840
and look at its build script real quick

00:24:39,950 --> 00:24:46,049
we scroll down since i'll talk about

00:24:43,650 --> 00:24:49,410
docker being really complicated and hard

00:24:46,049 --> 00:24:51,390
to understand and and complex my build

00:24:49,410 --> 00:24:53,850
scripts are like two lines right this is

00:24:51,390 --> 00:24:55,590
really simple now I took a lot of

00:24:53,850 --> 00:24:57,660
conceptual understanding to figure out

00:24:55,590 --> 00:24:59,309
how to set it all up and had to create a

00:24:57,660 --> 00:25:02,940
build flow to create my docker images

00:24:59,309 --> 00:25:05,520
but going from source code to docker

00:25:02,940 --> 00:25:07,470
image like I said it's two lines right

00:25:05,520 --> 00:25:09,960
first two lines i have docker build and

00:25:07,470 --> 00:25:11,520
docker tag that takes my code it builds

00:25:09,960 --> 00:25:12,929
a docker image and it tags it so I know

00:25:11,520 --> 00:25:15,570
what version attack it with the build

00:25:12,929 --> 00:25:17,190
number from Jenkins and then the next

00:25:15,570 --> 00:25:18,929
script actually pushes it out to the

00:25:17,190 --> 00:25:20,309
registry so I tag it again to tell it

00:25:18,929 --> 00:25:23,220
which registry to send it to and then I

00:25:20,309 --> 00:25:26,850
do it rakesh and with that my code is

00:25:23,220 --> 00:25:29,400
deployed right so you know I think that

00:25:26,850 --> 00:25:32,070
we talk a lot about the barrier adopt to

00:25:29,400 --> 00:25:33,600
adoption of docker and how difficult it

00:25:32,070 --> 00:25:34,980
is for organizations to adopt new

00:25:33,600 --> 00:25:37,230
workflows and things like that but when

00:25:34,980 --> 00:25:38,340
you actually get down to it like I said

00:25:37,230 --> 00:25:39,990
we're talking about two lines of code

00:25:38,340 --> 00:25:42,450
that's very simple example don't get me

00:25:39,990 --> 00:25:46,710
wrong but on the other hand it is not

00:25:42,450 --> 00:25:47,790
complex to get this thing going let's

00:25:46,710 --> 00:25:52,080
take a look real quick with my daugher

00:25:47,790 --> 00:25:56,010
files as well so we can get feel for

00:25:52,080 --> 00:25:57,570
that and like I said they're checked in

00:25:56,010 --> 00:26:00,290
with the code right so this is the

00:25:57,570 --> 00:26:02,490
source code for the polls application

00:26:00,290 --> 00:26:04,080
and we have the requirements that text

00:26:02,490 --> 00:26:05,490
that you'd expect a setup that pie that

00:26:04,080 --> 00:26:08,700
you expect but let's just take a quick

00:26:05,490 --> 00:26:10,470
look at the docker file once again

00:26:08,700 --> 00:26:12,030
there's really not a lot to it right so

00:26:10,470 --> 00:26:14,400
basically I'm doing the same thing that

00:26:12,030 --> 00:26:16,860
I would do in a virtual environment I'm

00:26:14,400 --> 00:26:18,690
creating a code a code directory I'm

00:26:16,860 --> 00:26:20,370
moving into that directory then i'm

00:26:18,690 --> 00:26:22,679
using the same requirements text that i

00:26:20,370 --> 00:26:24,270
use with the pip inside of the virtual

00:26:22,679 --> 00:26:27,840
environments to install my requirements

00:26:24,270 --> 00:26:30,120
i copy my code and and that's it alright

00:26:27,840 --> 00:26:32,520
and now the the image had to be prepared

00:26:30,120 --> 00:26:37,169
so you see at the top I say from you

00:26:32,520 --> 00:26:39,360
know relp I thon to dot 6 it's a

00:26:37,169 --> 00:26:41,580
specially prepared image that has Python

00:26:39,360 --> 00:26:42,490
pip installed from evil but that's

00:26:41,580 --> 00:26:44,320
really it you know

00:26:42,490 --> 00:26:47,770
we're talking about maybe five lines in

00:26:44,320 --> 00:26:48,640
a docker file to get this thing going so

00:26:47,770 --> 00:26:52,990
let's take a look at what it actually

00:26:48,640 --> 00:26:56,380
does let's make a change or two so first

00:26:52,990 --> 00:27:00,190
thing here is i'll edit the default

00:26:56,380 --> 00:27:07,570
index set of hello world i'll have it

00:27:00,190 --> 00:27:10,900
say hello self there we go i'm going to

00:27:07,570 --> 00:27:21,340
add my code here then i'm going to

00:27:10,900 --> 00:27:23,350
commit it and now on push I have a get

00:27:21,340 --> 00:27:25,030
hook that is going to tell Jenkins that

00:27:23,350 --> 00:27:27,460
there's updated code you see that down

00:27:25,030 --> 00:27:29,470
here says it's scheduled CI demo now if

00:27:27,460 --> 00:27:31,059
we go to the Jenkins dashboard you'll

00:27:29,470 --> 00:27:33,720
see that the first it's going to do is

00:27:31,059 --> 00:27:40,780
see I so it'll do my actual integration

00:27:33,720 --> 00:27:42,520
testing which it's already completed and

00:27:40,780 --> 00:27:45,700
then after some of the CI starts to do

00:27:42,520 --> 00:27:47,020
this CD right so it's delivering so it's

00:27:45,700 --> 00:27:48,700
creating the traditional package but

00:27:47,020 --> 00:27:51,010
more importantly it's running the docker

00:27:48,700 --> 00:27:55,420
build and so the doctor bill in the

00:27:51,010 --> 00:28:05,050
docker push are happening now we can

00:27:55,420 --> 00:28:07,240
actually watch the doctor output here it

00:28:05,050 --> 00:28:08,650
is so you can see it's running through

00:28:07,240 --> 00:28:10,540
the steps that I outlined in the docker

00:28:08,650 --> 00:28:12,700
file there the last thing it's doing is

00:28:10,540 --> 00:28:14,470
adding my code the way that docker

00:28:12,700 --> 00:28:18,790
images work each time you run a

00:28:14,470 --> 00:28:20,980
consecutive change via docker file on

00:28:18,790 --> 00:28:22,750
the image it creates a new layer right

00:28:20,980 --> 00:28:25,390
so it can cache layers it can pull

00:28:22,750 --> 00:28:26,890
layers back and forth and you see down

00:28:25,390 --> 00:28:28,120
here at the bottom right that most of

00:28:26,890 --> 00:28:30,550
the layers in this image have already

00:28:28,120 --> 00:28:32,200
been pushed so it's only pushing the

00:28:30,550 --> 00:28:33,429
change right so it's very intelligent

00:28:32,200 --> 00:28:35,110
about the way does it speeds up the

00:28:33,429 --> 00:28:37,059
process a lot and then it allows you

00:28:35,110 --> 00:28:39,730
will take a look at it as well to do

00:28:37,059 --> 00:28:42,190
some inheritance right so I can have one

00:28:39,730 --> 00:28:43,600
rail 6 image from my organization I can

00:28:42,190 --> 00:28:45,760
have a rail 6 Python image from our

00:28:43,600 --> 00:28:47,950
organization and everything is really

00:28:45,760 --> 00:28:50,110
tight right so small space requirements

00:28:47,950 --> 00:28:51,940
full memory footprints and that's what

00:28:50,110 --> 00:28:55,090
allows me to run multiple copies of the

00:28:51,940 --> 00:28:56,730
same application on the same host so it

00:28:55,090 --> 00:29:00,550
looks like we're pushed

00:28:56,730 --> 00:29:10,620
now I'm going to run log into an atomic

00:29:00,550 --> 00:29:10,620
host real quick from the right directory

00:29:13,620 --> 00:29:23,290
let's see here so I'm going to pull

00:29:20,850 --> 00:29:27,070
actually I don't even have to pull but I

00:29:23,290 --> 00:29:29,080
do so the image that we built was called

00:29:27,070 --> 00:29:31,470
polls my daugher registry that I pushed

00:29:29,080 --> 00:29:34,210
to is called em silver docker builder

00:29:31,470 --> 00:29:35,950
it's running on port 5000 so I'm going

00:29:34,210 --> 00:29:41,560
to pull the latest image that we just

00:29:35,950 --> 00:29:43,480
built onto my atomic host and you see

00:29:41,560 --> 00:29:44,760
it's got you know cash layers so the

00:29:43,480 --> 00:29:47,800
poll happens very quick it's like a

00:29:44,760 --> 00:29:51,880
guess if you look some rather large

00:29:47,800 --> 00:29:53,200
image 842 megabytes right but because of

00:29:51,880 --> 00:29:55,290
the layers that knows only to pull the

00:29:53,200 --> 00:29:59,410
last little bit so it happens quicker

00:29:55,290 --> 00:30:01,390
and then we'll run the image right now I

00:29:59,410 --> 00:30:03,010
two opportunities to specify a port

00:30:01,390 --> 00:30:05,620
number here so I can specify the port

00:30:03,010 --> 00:30:08,560
number when I run manage pie I'm going

00:30:05,620 --> 00:30:10,900
to assign it to 80 80 but the real magic

00:30:08,560 --> 00:30:12,790
of docker here is is you see the minus P

00:30:10,900 --> 00:30:15,190
argument here where I'm going to map

00:30:12,790 --> 00:30:17,200
port inside of the container to a port

00:30:15,190 --> 00:30:19,480
outside of the container all right so in

00:30:17,200 --> 00:30:21,610
this example I'm going to run port 8080

00:30:19,480 --> 00:30:23,470
in port 8080 but I could change that I

00:30:21,610 --> 00:30:25,480
can say hey port 8080 inside of my

00:30:23,470 --> 00:30:27,970
docker container let's map that to 80 81

00:30:25,480 --> 00:30:29,020
outside if I'm concurrently wrapped and

00:30:27,970 --> 00:30:32,440
that's it allows me to move their load

00:30:29,020 --> 00:30:39,660
balancer back and forth we'll just start

00:30:32,440 --> 00:30:41,830
this up and then once we've started it

00:30:39,660 --> 00:30:44,520
we should be able to curl that and get

00:30:41,830 --> 00:30:44,520
the updated string

00:30:51,290 --> 00:30:56,160
not to wait a minute so I think it's

00:30:54,930 --> 00:30:58,740
moving eight hundred megabytes into

00:30:56,160 --> 00:31:08,550
memory or something it's also running on

00:30:58,740 --> 00:31:12,060
an openstack cloud so there we go hello

00:31:08,550 --> 00:31:13,830
self so at this point you know I can

00:31:12,060 --> 00:31:15,540
take the load balancer point it at 80 80

00:31:13,830 --> 00:31:17,820
I could do my testing there assuming

00:31:15,540 --> 00:31:19,770
everything passes or assuming that if

00:31:17,820 --> 00:31:21,900
I'm actually continuously delivering to

00:31:19,770 --> 00:31:23,340
production assuming that watching the

00:31:21,900 --> 00:31:25,830
logs and I'm not noticing a usage

00:31:23,340 --> 00:31:28,470
pattern or performance change as users

00:31:25,830 --> 00:31:30,900
move on to that port I can start to you

00:31:28,470 --> 00:31:35,610
know drain sessions off a port 80 79 or

00:31:30,900 --> 00:31:36,960
port 8081 right so that's the

00:31:35,610 --> 00:31:39,120
presentation which questions do we have

00:31:36,960 --> 00:31:40,320
about the workflow we demonstrated a are

00:31:39,120 --> 00:31:41,520
you guys using this seems people that

00:31:40,320 --> 00:31:43,490
were using docker using a similar

00:31:41,520 --> 00:31:46,050
workflow right now to do the delivery

00:31:43,490 --> 00:31:47,580
and do you run concurrent versions on

00:31:46,050 --> 00:31:50,400
the same host or do you spread them out

00:31:47,580 --> 00:31:51,780
and are you doing any so you do both

00:31:50,400 --> 00:31:55,370
okay and then do you use any

00:31:51,780 --> 00:31:55,370
orchestration tools like Cooper Nettie's

00:31:56,240 --> 00:32:05,040
you're not not familiar so mm-hmm okay

00:32:03,330 --> 00:32:06,540
so one of the interesting things you

00:32:05,040 --> 00:32:08,190
know so this example is obviously very

00:32:06,540 --> 00:32:10,830
simplistic right i'm running a single

00:32:08,190 --> 00:32:12,000
container image i think something is

00:32:10,830 --> 00:32:12,960
interesting that comes up is what

00:32:12,000 --> 00:32:15,510
happens when you have dependent

00:32:12,960 --> 00:32:17,520
containers right so i might have h a

00:32:15,510 --> 00:32:20,070
proxy running in a container and it

00:32:17,520 --> 00:32:21,570
needs to talk to tom cat in a container

00:32:20,070 --> 00:32:23,190
or something like that right and so

00:32:21,570 --> 00:32:24,990
that's that's when we want to move a

00:32:23,190 --> 00:32:26,940
step up the chain and we do what we call

00:32:24,990 --> 00:32:28,560
container orchestration and that's where

00:32:26,940 --> 00:32:31,530
it's like Cooper Nettie's comes in right

00:32:28,560 --> 00:32:33,750
I can take a set of images I can run

00:32:31,530 --> 00:32:36,120
them concurrently inside of what we call

00:32:33,750 --> 00:32:38,700
pod in Coober Nettie's and then I can

00:32:36,120 --> 00:32:41,180
manage pod deployments as instead of

00:32:38,700 --> 00:32:43,440
just managing container deployments

00:32:41,180 --> 00:32:46,020
that's the strategy we're using an open

00:32:43,440 --> 00:32:48,060
shift version 3 as well we use Cooper

00:32:46,020 --> 00:32:50,100
Nettie's under the covers some customers

00:32:48,060 --> 00:32:52,230
as well that have adopted may sews it's

00:32:50,100 --> 00:32:53,550
another technology so red hats looking

00:32:52,230 --> 00:32:56,700
kind of looking at the field we want to

00:32:53,550 --> 00:33:00,330
make sure you know that we're being open

00:32:56,700 --> 00:33:01,799
and so we're trying to develop a pod

00:33:00,330 --> 00:33:03,299
definition language

00:33:01,799 --> 00:33:04,649
that could be used outside of just

00:33:03,299 --> 00:33:06,929
Cooper Nettie's and could go to mesa

00:33:04,649 --> 00:33:08,489
sore something like that as well so I

00:33:06,929 --> 00:33:16,739
think it's where the magic happens yes

00:33:08,489 --> 00:33:18,419
question now this registry is insecure

00:33:16,739 --> 00:33:21,119
the question was does the the register

00:33:18,419 --> 00:33:22,830
you have authentication on it now I've

00:33:21,119 --> 00:33:26,820
just set up a simple insecure registry

00:33:22,830 --> 00:33:31,159
it's worth noting that obviously you can

00:33:26,820 --> 00:33:34,649
set up with x509 authentication and you

00:33:31,159 --> 00:33:36,149
should work that is the correct way to

00:33:34,649 --> 00:33:38,100
do it but the other thing that's

00:33:36,149 --> 00:33:40,200
interesting too as well as Red Hat adopt

00:33:38,100 --> 00:33:42,029
stalker throughout our product set is

00:33:40,200 --> 00:33:43,799
that we've included a docker registry in

00:33:42,029 --> 00:33:45,690
our satellite product so if anyone's

00:33:43,799 --> 00:33:47,429
used the Red Hat satellite product for

00:33:45,690 --> 00:33:49,409
systems management rpm rollouts and

00:33:47,429 --> 00:33:51,450
package management things like that the

00:33:49,409 --> 00:33:52,980
latest version 6 dot 1 includes a docker

00:33:51,450 --> 00:33:54,779
registry that you can push and pull two

00:33:52,980 --> 00:33:57,299
that's managed you know the graphical

00:33:54,779 --> 00:33:59,489
user environment and heretical from your

00:33:57,299 --> 00:34:02,970
you know Enterprise directory service

00:33:59,489 --> 00:34:04,499
and things like that so so it's kind of

00:34:02,970 --> 00:34:05,730
it's all coming together right openshift

00:34:04,499 --> 00:34:07,739
version 3 also includes a docker

00:34:05,730 --> 00:34:09,899
registry and we handle setting up

00:34:07,739 --> 00:34:14,490
certificates between the brokers and the

00:34:09,899 --> 00:34:17,369
notes as well there you can use the self

00:34:14,490 --> 00:34:19,470
censored or you can use a corporate

00:34:17,369 --> 00:34:22,500
certificate as well if you have one your

00:34:19,470 --> 00:34:27,299
organization trusts and openshift

00:34:22,500 --> 00:34:32,220
version 3 so other questions about the

00:34:27,299 --> 00:34:34,169
build flow any other questions about

00:34:32,220 --> 00:34:35,819
docker in general is there whenever ins

00:34:34,169 --> 00:34:47,339
bought in now we're all going to go home

00:34:35,819 --> 00:34:49,770
and docker everything yes question sure

00:34:47,339 --> 00:34:51,770
so the question was how would we how

00:34:49,770 --> 00:34:54,929
will we do local development with docker

00:34:51,770 --> 00:34:56,849
that's a great question so if you are

00:34:54,929 --> 00:34:59,309
using obviously using red hat enterprise

00:34:56,849 --> 00:35:04,470
linux 7 on your desktop a problem right

00:34:59,309 --> 00:35:06,540
dockers included in rel 71 so you can

00:35:04,470 --> 00:35:07,890
use that if you're not we were talking a

00:35:06,540 --> 00:35:09,720
little bit about docker on the Mac I

00:35:07,890 --> 00:35:12,869
think dr. is widely adopted throughout a

00:35:09,720 --> 00:35:13,730
lot of platforms these days and so you

00:35:12,869 --> 00:35:17,430
know

00:35:13,730 --> 00:35:18,750
what's up in a virtual machine yeah so

00:35:17,430 --> 00:35:24,990
absolutely you could run linux and a

00:35:18,750 --> 00:35:28,170
virtual machine people is it at Dockers

00:35:24,990 --> 00:35:31,680
only only runs on linux it's interesting

00:35:28,170 --> 00:35:49,589
yeah can you run docker and vagrant on a

00:35:31,680 --> 00:35:52,080
Mac yeah okay gotcha to boot the docker

00:35:49,589 --> 00:35:55,230
sorry I'm gonna disadvantaged I've only

00:35:52,080 --> 00:35:58,470
use Linux so everything just works for

00:35:55,230 --> 00:36:01,050
me but if you don't use linux and maybe

00:35:58,470 --> 00:36:02,460
maybe you have to do it but so uh so you

00:36:01,050 --> 00:36:05,160
know for example when i was developing

00:36:02,460 --> 00:36:07,589
this I wrote my docker file on my

00:36:05,160 --> 00:36:09,150
desktop and I created docker images

00:36:07,589 --> 00:36:11,400
using that and then made sure that that

00:36:09,150 --> 00:36:12,720
work ducker build and then locally have

00:36:11,400 --> 00:36:14,940
the docker image work and then discard

00:36:12,720 --> 00:36:16,680
it and then I check my docker file into

00:36:14,940 --> 00:36:18,390
source and then I let the build system

00:36:16,680 --> 00:36:21,960
create the the docker image that

00:36:18,390 --> 00:36:23,970
actually gets pushed out so I think

00:36:21,960 --> 00:36:30,050
that's the the right way to do it yeah

00:36:23,970 --> 00:36:32,490
question yes the question was about

00:36:30,050 --> 00:36:35,609
alternatives like lxc and rocket so

00:36:32,490 --> 00:36:40,230
that's a great question so I have not

00:36:35,609 --> 00:36:42,270
used rocket and I i think i think i've

00:36:40,230 --> 00:36:45,359
read press about rocket but i don't

00:36:42,270 --> 00:36:46,710
really understand the difference is it

00:36:45,359 --> 00:36:49,800
very different i don't know that it's

00:36:46,710 --> 00:36:54,330
all that different but the LXE is

00:36:49,800 --> 00:36:56,880
important and interesting right so it in

00:36:54,330 --> 00:36:58,470
each successive version of red hat

00:36:56,880 --> 00:37:01,770
enterprise linux five six and seven

00:36:58,470 --> 00:37:04,410
we've had various strategies that we've

00:37:01,770 --> 00:37:06,119
used to containerized applications and

00:37:04,410 --> 00:37:07,970
it started really with Ralph I've when

00:37:06,119 --> 00:37:10,109
the release of the Numa architectures

00:37:07,970 --> 00:37:11,820
where we had a lot of customers coming

00:37:10,109 --> 00:37:13,530
up with performance issues as we were

00:37:11,820 --> 00:37:16,859
doing context switching between memory

00:37:13,530 --> 00:37:18,089
zones and a NUMA box and so one of the

00:37:16,859 --> 00:37:19,470
things that we've worked a lot with on

00:37:18,089 --> 00:37:21,450
those customers it's almost been I guess

00:37:19,470 --> 00:37:23,640
gosh seven or eight years or something

00:37:21,450 --> 00:37:25,859
at this point is finding ways to

00:37:23,640 --> 00:37:26,970
constrain applications first to numa

00:37:25,859 --> 00:37:28,260
zones so that we

00:37:26,970 --> 00:37:30,590
reduce the context switching and the

00:37:28,260 --> 00:37:33,270
performance penalty there so we used

00:37:30,590 --> 00:37:36,800
honey remember what we use cpu said or

00:37:33,270 --> 00:37:38,880
something like that and it wasn't it was

00:37:36,800 --> 00:37:41,190
Numa control or something I got in rel

00:37:38,880 --> 00:37:43,110
five I don't it's been a long time but

00:37:41,190 --> 00:37:45,390
then with rel six we used see groups

00:37:43,110 --> 00:37:47,100
right so see groups were something that

00:37:45,390 --> 00:37:49,200
allows you basically the label processes

00:37:47,100 --> 00:37:51,120
inside of the colonel and then apply

00:37:49,200 --> 00:37:52,890
constraints so in rel six we had full

00:37:51,120 --> 00:37:55,320
support for cpu sets and with that you

00:37:52,890 --> 00:37:56,880
could take processes and constrain them

00:37:55,320 --> 00:38:00,420
into memory regions or you can constrain

00:37:56,880 --> 00:38:01,830
them to devices or repay hey you can

00:38:00,420 --> 00:38:03,780
only use so much memory or you get this

00:38:01,830 --> 00:38:05,880
priority things like that and so we did

00:38:03,780 --> 00:38:09,120
a lot of work with customers in the rail

00:38:05,880 --> 00:38:10,950
six time frame where you had workloads

00:38:09,120 --> 00:38:13,680
that that needed constraints I've gotta

00:38:10,950 --> 00:38:15,150
Marin database concurrently with an

00:38:13,680 --> 00:38:17,160
application server on a physical machine

00:38:15,150 --> 00:38:18,990
on bare metal I want to put this guy

00:38:17,160 --> 00:38:21,180
over here and that guy over there so we

00:38:18,990 --> 00:38:24,480
started using see groups for that we

00:38:21,180 --> 00:38:28,800
also included lxc NRL 60 LXE uses see

00:38:24,480 --> 00:38:31,370
groups to provide the constraint so does

00:38:28,800 --> 00:38:35,580
docker his daugher uses LXE use a secret

00:38:31,370 --> 00:38:37,460
and so I think that you know it's been a

00:38:35,580 --> 00:38:39,960
progression I think they think that in

00:38:37,460 --> 00:38:42,600
lxc was fully supported in row 6 fully

00:38:39,960 --> 00:38:44,910
supported in row seven the thing that is

00:38:42,600 --> 00:38:48,720
really different in rel seven underlying

00:38:44,910 --> 00:38:50,580
everything is that lxc docker and then

00:38:48,720 --> 00:38:52,980
even just process grouping is all run

00:38:50,580 --> 00:38:54,930
out of system d and system d has the

00:38:52,980 --> 00:38:57,300
ability to apply see groups at any level

00:38:54,930 --> 00:38:59,970
of the chain and to kind of divvy up

00:38:57,300 --> 00:39:00,960
system resources there so you know the

00:38:59,970 --> 00:39:02,310
thing that we've kind of gone through

00:39:00,960 --> 00:39:04,110
today about docker that I think is

00:39:02,310 --> 00:39:06,090
interesting is the image format the

00:39:04,110 --> 00:39:08,190
ability to do and that's what directly

00:39:06,090 --> 00:39:09,840
impacts the icd but the performance

00:39:08,190 --> 00:39:13,170
implications all of that can be achieved

00:39:09,840 --> 00:39:14,910
outside of da car using LXE or just with

00:39:13,170 --> 00:39:18,420
see groups right so that the problem

00:39:14,910 --> 00:39:21,120
becomes yes after you can run it out of

00:39:18,420 --> 00:39:23,340
system via so that the the question is

00:39:21,120 --> 00:39:25,710
you know how do i then solve that

00:39:23,340 --> 00:39:28,140
virtual environment problem that i'm

00:39:25,710 --> 00:39:29,850
solving with docker inside of my see

00:39:28,140 --> 00:39:34,230
groups and I think we're we've all kind

00:39:29,850 --> 00:39:36,090
of gotten to is well Dockers fine I'll

00:39:34,230 --> 00:39:38,250
take both I'll take the image thing and

00:39:36,090 --> 00:39:40,859
then I'll also use it to do the the

00:39:38,250 --> 00:39:42,599
process constraints which you know

00:39:40,859 --> 00:39:44,489
there certainly are environments where

00:39:42,599 --> 00:39:47,460
we're seeing adoption of Alexei just as

00:39:44,489 --> 00:39:50,130
LXE there are some advantages like I say

00:39:47,460 --> 00:39:51,390
I want to run I'm going to put a bunch

00:39:50,130 --> 00:39:53,789
of different web servers on different IP

00:39:51,390 --> 00:39:55,319
addresses but I want them all to use

00:39:53,789 --> 00:39:57,180
exactly the same code and I want to be

00:39:55,319 --> 00:39:59,430
able to update that the RPM a perfect

00:39:57,180 --> 00:40:00,809
galaxy use case right but if I'm

00:39:59,430 --> 00:40:02,730
actually doing application development

00:40:00,809 --> 00:40:05,099
and I've got 17 version as I'm an app

00:40:02,730 --> 00:40:06,930
that I want concurrently running that's

00:40:05,099 --> 00:40:08,910
a docker you know solves that problem

00:40:06,930 --> 00:40:11,130
for me perfectly it's very difficult to

00:40:08,910 --> 00:40:26,279
set that up in trees in Alexei

00:40:11,130 --> 00:40:28,920
containers question okay Oh perfect so

00:40:26,279 --> 00:40:31,380
it was a clarification that docker does

00:40:28,920 --> 00:40:36,329
not currently use LXE and it by default

00:40:31,380 --> 00:40:38,249
anymore yeah should i use cgroups yeah

00:40:36,329 --> 00:40:40,019
under the covers right but the interface

00:40:38,249 --> 00:40:42,150
to is it the main in public implication

00:40:40,019 --> 00:40:43,829
might be through libvirt right so we

00:40:42,150 --> 00:40:45,420
have a live or API layer that we can use

00:40:43,829 --> 00:40:46,619
with alexi containers and maybe that's

00:40:45,420 --> 00:40:54,450
no longer applicable to docker

00:40:46,619 --> 00:40:57,989
containers later this week gotcha I

00:40:54,450 --> 00:41:01,130
think oh this so there is yes so there's

00:40:57,989 --> 00:41:03,660
an LX to userspace library available on

00:41:01,130 --> 00:41:07,920
some platforms but on the Red Hat

00:41:03,660 --> 00:41:10,619
platforms we use the lib for commands to

00:41:07,920 --> 00:41:12,630
be able to modify LXE containers so it's

00:41:10,619 --> 00:41:15,420
all done through verse and vert manager

00:41:12,630 --> 00:41:17,220
and OpenStack your kind of know things

00:41:15,420 --> 00:41:22,410
like that talking to libert firing up

00:41:17,220 --> 00:41:23,999
LXE containers exactly yeah oh it has

00:41:22,410 --> 00:41:30,390
its own implementation of LXE libraries

00:41:23,999 --> 00:41:34,099
as shipped by red hat yeah yeah perfect

00:41:30,390 --> 00:41:34,099
but thanks for the clarification there

00:41:44,180 --> 00:41:48,510
yeah I know an early version of docker

00:41:46,380 --> 00:41:52,290
that I used we absolutely you could also

00:41:48,510 --> 00:41:56,730
you know modify it via the LXE lippert

00:41:52,290 --> 00:41:58,860
interface as well linux containers that

00:41:56,730 --> 00:42:01,980
sometimes to be what's the turtle as

00:41:58,860 --> 00:42:06,110
well as alexei the LLC could just be the

00:42:01,980 --> 00:42:08,370
user space part so that the name ease

00:42:06,110 --> 00:42:12,360
yeah i think the other thing it's

00:42:08,370 --> 00:42:15,840
confusing right as we containers as a

00:42:12,360 --> 00:42:18,210
strategy on linux and so we might talk

00:42:15,840 --> 00:42:20,610
about application sandboxing using

00:42:18,210 --> 00:42:23,100
selinux as a container strategy on linux

00:42:20,610 --> 00:42:25,440
totally separate and now that's that's

00:42:23,100 --> 00:42:26,880
privileged isolation right and so that

00:42:25,440 --> 00:42:30,300
and it's a part of the walk right we

00:42:26,880 --> 00:42:32,430
wrap it in selinux as opposed to the

00:42:30,300 --> 00:42:35,100
performance kind of constraints which we

00:42:32,430 --> 00:42:36,540
would implement vsc groups putting them

00:42:35,100 --> 00:42:39,900
together you end up with another

00:42:36,540 --> 00:42:41,790
technology in LX eoran docker or in kvm

00:42:39,900 --> 00:42:43,710
right because at some point all of this

00:42:41,790 --> 00:42:45,420
is just a large spectrum of how much of

00:42:43,710 --> 00:42:47,250
my containing and you know that there's

00:42:45,420 --> 00:42:49,110
a line between am I are we sharing a

00:42:47,250 --> 00:42:50,550
colonel or not and the minute we're not

00:42:49,110 --> 00:42:51,960
sharing a kernel then you're using all

00:42:50,550 --> 00:42:58,860
the same subsystems which you're running

00:42:51,960 --> 00:43:00,660
in a kvm virtual machine yeah absolutely

00:42:58,860 --> 00:43:03,480
see as the new linux containers normally

00:43:00,660 --> 00:43:05,640
what you would think of as lxc is it at

00:43:03,480 --> 00:43:08,130
least in my brain yeah which is c groups

00:43:05,640 --> 00:43:10,320
in selinux yeah and then the networking

00:43:08,130 --> 00:43:12,630
is different right so fluxing containers

00:43:10,320 --> 00:43:16,170
may use libvirt networking whereas

00:43:12,630 --> 00:43:17,340
docker maybe has its own in openshift

00:43:16,170 --> 00:43:19,920
version 3 I think we're going to be

00:43:17,340 --> 00:43:21,900
leveraging open V switch at some point

00:43:19,920 --> 00:43:24,000
on the line so we'll have sdn layers

00:43:21,900 --> 00:43:26,190
inside of the cooper Nettie's controlled

00:43:24,000 --> 00:43:27,540
docker containers so we can be a whole

00:43:26,190 --> 00:43:30,060
lot of different things right and even

00:43:27,540 --> 00:43:31,950
even a docker container running on this

00:43:30,060 --> 00:43:33,210
you know particular environment may not

00:43:31,950 --> 00:43:34,950
look anything like another one if it's

00:43:33,210 --> 00:43:37,350
orchestrated differently with mace or

00:43:34,950 --> 00:43:38,820
something like that right so it becomes

00:43:37,350 --> 00:43:43,920
a big wash right there's a large

00:43:38,820 --> 00:43:45,140
technology wash right now yeah yes

00:43:43,920 --> 00:43:48,799
question

00:43:45,140 --> 00:43:51,710
just give any seeing patterns or best

00:43:48,799 --> 00:43:56,119
practices management with containers

00:43:51,710 --> 00:44:00,910
like what happens those are image with

00:43:56,119 --> 00:44:00,910
them have some environment specific data

00:44:06,010 --> 00:44:10,940
so the question was about best practices

00:44:09,289 --> 00:44:12,769
around configuration management inside

00:44:10,940 --> 00:44:14,180
of the container so that's a great

00:44:12,769 --> 00:44:16,430
question so there there are two

00:44:14,180 --> 00:44:17,599
approaches so the first approach like

00:44:16,430 --> 00:44:21,049
pass environment variables into the

00:44:17,599 --> 00:44:22,369
container and both of these is a doc on

00:44:21,049 --> 00:44:24,349
our knowledge base by the way it is the

00:44:22,369 --> 00:44:26,900
best practices for creating docker

00:44:24,349 --> 00:44:28,549
images on red hat enterprise linux it

00:44:26,900 --> 00:44:30,500
has some of this information but that

00:44:28,549 --> 00:44:31,430
most of that in the atomic space is

00:44:30,500 --> 00:44:32,630
going to be focused around the

00:44:31,430 --> 00:44:35,059
environment variables and being able to

00:44:32,630 --> 00:44:36,529
pass things into the docker image what

00:44:35,059 --> 00:44:38,269
we're doing in the past space with

00:44:36,529 --> 00:44:41,599
openshift version 3 however is we're

00:44:38,269 --> 00:44:43,609
leveraging at CD and so what you do is

00:44:41,599 --> 00:44:45,049
you kind of push configuration

00:44:43,609 --> 00:44:47,630
management into the key value store

00:44:45,049 --> 00:44:49,670
that's distributed via etsy D and then

00:44:47,630 --> 00:44:51,200
as docker images come up inside the

00:44:49,670 --> 00:44:53,630
Cooper Nettie's pod they can reach out

00:44:51,200 --> 00:44:55,490
to xdd get the information and then

00:44:53,630 --> 00:44:56,900
configure themselves that way so there's

00:44:55,490 --> 00:44:59,059
two approaches right so the first would

00:44:56,900 --> 00:45:00,470
be as i run the image i'm passing

00:44:59,059 --> 00:45:02,750
information into it and then the other

00:45:00,470 --> 00:45:04,970
one is already running image reaching

00:45:02,750 --> 00:45:08,390
out to add CD and getting information

00:45:04,970 --> 00:45:10,039
that way yeah but Severin's writing

00:45:08,390 --> 00:45:12,410
stateless services anyway right that

00:45:10,039 --> 00:45:15,319
don't actually need configuration it's

00:45:12,410 --> 00:45:16,369
the joke yeah and then you the other

00:45:15,319 --> 00:45:17,990
question the next follow-on question

00:45:16,369 --> 00:45:21,500
right as well how do I run puppet inside

00:45:17,990 --> 00:45:24,890
of a container all right so which I was

00:45:21,500 --> 00:45:29,990
funny if you ever tried to do it great

00:45:24,890 --> 00:45:31,279
questions any other questions it's good

00:45:29,990 --> 00:45:33,380
well I hope this is a good discussion

00:45:31,279 --> 00:45:34,789
like I said it's high level right but I

00:45:33,380 --> 00:45:37,940
think it is a good framework to think

00:45:34,789 --> 00:45:40,460
about what's different and why it's good

00:45:37,940 --> 00:45:42,440
that things are different so thank you

00:45:40,460 --> 00:45:45,069
for coming this afternoon I never have a

00:45:42,440 --> 00:45:45,069
safe travel back

00:46:44,090 --> 00:46:48,600
Citrix XenServer gives you everything

00:46:46,350 --> 00:46:50,790
you need to integrate manage and

00:46:48,600 --> 00:46:52,950
automate a virtual all on an

00:46:50,790 --> 00:46:55,410
enterprise-class cloud proven virtual

00:46:52,950 --> 00:46:58,200
platform and at a third of the cost of

00:46:55,410 --> 00:46:59,940
other solutions but why even bother with

00:46:58,200 --> 00:47:02,130
virtualizing your server infrastructure

00:46:59,940 --> 00:47:03,990
in the first place well let's say you

00:47:02,130 --> 00:47:06,360
have a traditional one server to one

00:47:03,990 --> 00:47:08,460
application architecture but you're

00:47:06,360 --> 00:47:11,100
running out of resources and performance

00:47:08,460 --> 00:47:13,550
is suffering once you order new server

00:47:11,100 --> 00:47:16,470
hardware you'll wait for delivery

00:47:13,550 --> 00:47:19,350
configure it install your business

00:47:16,470 --> 00:47:21,900
application stage and test the server

00:47:19,350 --> 00:47:24,090
and finally add it to your production

00:47:21,900 --> 00:47:26,310
farm if you've been through this process

00:47:24,090 --> 00:47:28,920
before you know it can take weeks or

00:47:26,310 --> 00:47:30,810
even months you also know it's a

00:47:28,920 --> 00:47:32,520
manually intensive process that will

00:47:30,810 --> 00:47:35,730
burden your team every time you outgrow

00:47:32,520 --> 00:47:37,500
your current setup with a virtual server

00:47:35,730 --> 00:47:40,410
solution you could accomplish all of

00:47:37,500 --> 00:47:43,050
that in less than half a day server

00:47:40,410 --> 00:47:44,940
virtualization software separates the OS

00:47:43,050 --> 00:47:47,460
and application from the underlying

00:47:44,940 --> 00:47:49,650
server hardware and with multiple

00:47:47,460 --> 00:47:51,270
virtual machines on a single server you

00:47:49,650 --> 00:47:54,210
can use each of them to run different

00:47:51,270 --> 00:47:56,010
os's and applications this makes it

00:47:54,210 --> 00:47:57,810
possible to move your virtual machines

00:47:56,010 --> 00:47:59,940
from one piece of hardware to another

00:47:57,810 --> 00:48:02,250
whenever you want to maximize

00:47:59,940 --> 00:48:04,050
utilization simplify maintenance or

00:48:02,250 --> 00:48:06,119
recover from a hardware failure and

00:48:04,050 --> 00:48:09,060
without slowing down your applications

00:48:06,119 --> 00:48:12,119
or users clearly server virtualization

00:48:09,060 --> 00:48:15,150
provides big benefits and Citrix

00:48:12,119 --> 00:48:17,369
XenServer provides even more since it's

00:48:15,150 --> 00:48:19,230
built on an open platform xenserver

00:48:17,369 --> 00:48:21,510
plays well with your existing hardware

00:48:19,230 --> 00:48:23,820
storage systems and IT management

00:48:21,510 --> 00:48:26,520
software as well as with the industry's

00:48:23,820 --> 00:48:28,590
leading cloud service providers best of

00:48:26,520 --> 00:48:30,270
all you can get started by downloading a

00:48:28,590 --> 00:48:33,540
fully functional production-ready

00:48:30,270 --> 00:48:35,760
version of xenserver for free after a

00:48:33,540 --> 00:48:37,859
10-minute installation process you'll

00:48:35,760 --> 00:48:39,900
see how easy it is to start virtualizing

00:48:37,859 --> 00:48:42,330
your workloads and automating your IT

00:48:39,900 --> 00:48:43,950
management processes and when you're

00:48:42,330 --> 00:48:45,869
ready for a richer set of management

00:48:43,950 --> 00:48:48,359
tools just upgrade to one of the premium

00:48:45,869 --> 00:48:50,190
editions of xenserver so whether you're

00:48:48,359 --> 00:48:52,140
interested in virtualizing servers for

00:48:50,190 --> 00:48:54,420
the first time expanding your server

00:48:52,140 --> 00:48:56,490
virtualization footprint or moving

00:48:54,420 --> 00:48:58,770
server workloads to the cloud

00:48:56,490 --> 00:49:01,260
download and install xenserver today and

00:48:58,770 --> 00:49:04,770
see how it can help you simplify your IT

00:49:01,260 --> 00:49:08,180
environment citrix xenserver do more

00:49:04,770 --> 00:49:08,180
don't spend more

00:49:13,420 --> 00:49:17,749
your customers rely on your website or

00:49:16,219 --> 00:49:20,089
application if it's slower

00:49:17,749 --> 00:49:23,029
non-responsive it infuriates your users

00:49:20,089 --> 00:49:24,859
and costs you money keeping your

00:49:23,029 --> 00:49:28,460
business critical systems humming along

00:49:24,859 --> 00:49:30,830
requires insight into what they're doing

00:49:28,460 --> 00:49:32,810
your system metrics tells stories

00:49:30,830 --> 00:49:34,910
stories that can reveal performance

00:49:32,810 --> 00:49:37,250
bottlenecks resource limitations and

00:49:34,910 --> 00:49:38,839
other problems but how do you keep an

00:49:37,250 --> 00:49:41,480
eye on all of your systems performance

00:49:38,839 --> 00:49:44,480
metrics in real-time and record this

00:49:41,480 --> 00:49:46,190
data for leader analysis enter long view

00:49:44,480 --> 00:49:47,960
the new way to see what's really going

00:49:46,190 --> 00:49:50,000
on under the hood the long view

00:49:47,960 --> 00:49:52,040
dashboard lets you visualize the status

00:49:50,000 --> 00:49:54,500
of all your systems providing you with a

00:49:52,040 --> 00:49:57,890
bird's-eye view of your entire fleet you

00:49:54,500 --> 00:50:00,470
can sort by cpu memory swap processes

00:49:57,890 --> 00:50:02,210
load and network usage click a specific

00:50:00,470 --> 00:50:04,609
system to access its individual

00:50:02,210 --> 00:50:07,150
dashboard then click and drag to zoom in

00:50:04,609 --> 00:50:09,650
on chokepoints and get more detail

00:50:07,150 --> 00:50:11,240
comprehensive network data including

00:50:09,650 --> 00:50:13,520
inbound and outbound traffic is

00:50:11,240 --> 00:50:15,530
available on the network tab and disk

00:50:13,520 --> 00:50:17,660
rights and free space on a disk stabbed

00:50:15,530 --> 00:50:19,849
while the process explorer displays

00:50:17,660 --> 00:50:22,369
usage statistics for individual

00:50:19,849 --> 00:50:24,560
processes the system info tab shows

00:50:22,369 --> 00:50:26,810
listening services active connections

00:50:24,560 --> 00:50:28,940
and available updates adding long view

00:50:26,810 --> 00:50:30,619
to a system is easy just click the

00:50:28,940 --> 00:50:32,750
button copy the one line installation

00:50:30,619 --> 00:50:35,210
command then run the command on your

00:50:32,750 --> 00:50:36,920
linux system to complete the process the

00:50:35,210 --> 00:50:39,109
agent will begin collecting data and

00:50:36,920 --> 00:50:40,950
sending it to longview then the graphs

00:50:39,109 --> 00:50:43,500
start rolling

00:50:40,950 --> 00:50:45,869
use longview to gain visibility into

00:50:43,500 --> 00:50:49,609
your servers so when your website or app

00:50:45,869 --> 00:50:49,609
heats up it stays up

00:53:20,090 --> 00:53:22,150

YouTube URL: https://www.youtube.com/watch?v=QGOBSUTl4SY


