Title: Jean Pierre LeJacq - Hardening C++ Applications
Publication date: 2017-01-25
Playlist: 2015 SouthEast LinuxFest
Description: 
	
Captions: 
	00:00:01,500 --> 00:00:08,590
hopefully this is a right right

00:00:04,000 --> 00:00:12,429
presentation we're going to be talking a

00:00:08,590 --> 00:00:16,150
little bit about C C++ development of

00:00:12,429 --> 00:00:18,130
applications on Linux platforms trying

00:00:16,150 --> 00:00:25,240
to do the best practices around

00:00:18,130 --> 00:00:28,330
hardening this there's a lot of material

00:00:25,240 --> 00:00:30,580
to cover so this is a really fast

00:00:28,330 --> 00:00:32,590
overview there there's no way we can

00:00:30,580 --> 00:00:35,290
cover all the topics and any kind of

00:00:32,590 --> 00:00:39,430
depth I'm going to try to hit the

00:00:35,290 --> 00:00:41,950
highlights recent advancements really

00:00:39,430 --> 00:00:44,489
and in charted or try to give you some

00:00:41,950 --> 00:00:48,190
background on experience that we've had

00:00:44,489 --> 00:00:49,930
implementing the new tools changes we're

00:00:48,190 --> 00:00:51,790
also going to be taking a look at some

00:00:49,930 --> 00:00:54,610
of the enhancements in the languages

00:00:51,790 --> 00:00:57,280
there it's moving so fast here as well

00:00:54,610 --> 00:01:00,880
it's difficult for people to keep up

00:00:57,280 --> 00:01:03,550
today and then specifically how do you

00:01:00,880 --> 00:01:09,640
enable some of these features on linux

00:01:03,550 --> 00:01:13,330
platform to improve security so the main

00:01:09,640 --> 00:01:16,270
objectives of usually people our clients

00:01:13,330 --> 00:01:17,950
typically want to talk about security

00:01:16,270 --> 00:01:21,430
that's usually when we come into the

00:01:17,950 --> 00:01:23,890
picture and we always tell them that

00:01:21,430 --> 00:01:26,950
they have to build on top of a good

00:01:23,890 --> 00:01:29,680
solid code base first so you need to

00:01:26,950 --> 00:01:33,310
have reliable code code that works as

00:01:29,680 --> 00:01:35,740
expected it needs to be robust two

00:01:33,310 --> 00:01:39,280
inputs are you doing all the property of

00:01:35,740 --> 00:01:41,799
handling post-process handling things

00:01:39,280 --> 00:01:44,290
like that and then finally you can talk

00:01:41,799 --> 00:01:50,590
about security so we're going to focus a

00:01:44,290 --> 00:01:52,240
lot on the first two here in that and

00:01:50,590 --> 00:01:54,490
we're going to try to guide this through

00:01:52,240 --> 00:01:56,619
some principles but we're going to be

00:01:54,490 --> 00:01:59,950
taking a look at all the tools from

00:01:56,619 --> 00:02:01,619
these basic principles I and and

00:01:59,950 --> 00:02:03,579
hopefully these are fairly

00:02:01,619 --> 00:02:07,950
straightforward and standard for

00:02:03,579 --> 00:02:12,040
everyone it's seven possibly the first

00:02:07,950 --> 00:02:14,760
this is a relying on static verification

00:02:12,040 --> 00:02:17,829
dynamic verification so this is the

00:02:14,760 --> 00:02:19,750
classic argument should I use a type

00:02:17,829 --> 00:02:22,540
lyst language or a dynamically typed

00:02:19,750 --> 00:02:25,180
language or statically typed language I

00:02:22,540 --> 00:02:28,480
definitely fall into the canned but try

00:02:25,180 --> 00:02:32,739
to do as much during static analysis

00:02:28,480 --> 00:02:35,170
compile time instead of run time and the

00:02:32,739 --> 00:02:37,329
languages that were looking at TV a post

00:02:35,170 --> 00:02:39,489
plus definitely phone to that category

00:02:37,329 --> 00:02:43,540
so we're going to be looking at how do

00:02:39,489 --> 00:02:45,639
you enhance that capability will take a

00:02:43,540 --> 00:02:49,420
look at how to default to safe behavior

00:02:45,639 --> 00:02:51,549
or so failsafe essentially least

00:02:49,420 --> 00:02:53,349
privilege when you're writing

00:02:51,549 --> 00:02:55,450
applications you want to make sure that

00:02:53,349 --> 00:02:57,730
you have is a minimal privilege as

00:02:55,450 --> 00:03:02,079
possible reduce your exposure of the

00:02:57,730 --> 00:03:04,569
risk another common one is the attack

00:03:02,079 --> 00:03:06,540
surface that you're exposing and you'll

00:03:04,569 --> 00:03:08,829
see here that Linux has put a

00:03:06,540 --> 00:03:12,299
substantial amount of work in this area

00:03:08,829 --> 00:03:16,500
to try to reduce the attack surface of

00:03:12,299 --> 00:03:18,940
applications defense in depth of

00:03:16,500 --> 00:03:22,510
verification of it was probably everyone

00:03:18,940 --> 00:03:23,829
sees this defense in depth so we're

00:03:22,510 --> 00:03:26,829
going to be showing a whole bunch of

00:03:23,829 --> 00:03:29,769
different techniques not any one of them

00:03:26,829 --> 00:03:33,609
is a silver bullet we lay everything on

00:03:29,769 --> 00:03:37,419
top of the other to get as much security

00:03:33,609 --> 00:03:42,370
as possible another one that is often

00:03:37,419 --> 00:03:44,919
controversial for our clients is we

00:03:42,370 --> 00:03:48,190
advocate failing fast if something goes

00:03:44,919 --> 00:03:50,650
will not find out and stop processing a

00:03:48,190 --> 00:03:54,010
lot of our clients would prefer to keep

00:03:50,650 --> 00:03:58,060
muddling along going into the land of

00:03:54,010 --> 00:03:59,889
undefined behavior so classic example

00:03:58,060 --> 00:04:02,069
for some of our clients is they

00:03:59,889 --> 00:04:05,169
dereference null pointers all the time

00:04:02,069 --> 00:04:07,810
happens to work on their platform what

00:04:05,169 --> 00:04:14,470
the hell it does we don't know but the

00:04:07,810 --> 00:04:18,039
application still run okay a real fast

00:04:14,470 --> 00:04:21,159
quick tour of the new languages and are

00:04:18,039 --> 00:04:23,880
you guys familiar with some some of the

00:04:21,159 --> 00:04:29,430
newer features these

00:04:23,880 --> 00:04:33,270
of C and C++ okay hello on hopefully

00:04:29,430 --> 00:04:36,620
this will be new for you too so the the

00:04:33,270 --> 00:04:40,200
the standards committee have released a

00:04:36,620 --> 00:04:42,540
new version to OC it's taken a while for

00:04:40,200 --> 00:04:46,260
a new version 2c to come out of this is

00:04:42,540 --> 00:04:49,020
a big big deal and then C++ is just been

00:04:46,260 --> 00:04:52,860
cranking out new releases every year

00:04:49,020 --> 00:04:56,520
almost so we have C 11 c 14 the formal

00:04:52,860 --> 00:04:59,340
gown on fully specify a lot of compilers

00:04:56,520 --> 00:05:03,060
fully implement them especially on the

00:04:59,340 --> 00:05:07,190
linux platform and many of the compilers

00:05:03,060 --> 00:05:10,020
also implement c-17 two largest and the

00:05:07,190 --> 00:05:13,200
main goals they had want to get a

00:05:10,020 --> 00:05:16,140
tighter alignment between C and C++ they

00:05:13,200 --> 00:05:19,980
had diverged quite a bit in previous

00:05:16,140 --> 00:05:22,530
versions so we got them back together a

00:05:19,980 --> 00:05:25,680
good example of that is they now have

00:05:22,530 --> 00:05:27,300
the same basic threading model ap lives

00:05:25,680 --> 00:05:30,240
are a little bit different but the

00:05:27,300 --> 00:05:33,480
fundamental memory model is the same

00:05:30,240 --> 00:05:36,150
between us they've improved and tighten

00:05:33,480 --> 00:05:40,260
up the static type checking in some

00:05:36,150 --> 00:05:44,580
runtime checking as well for improving

00:05:40,260 --> 00:05:46,830
the portability and the one major thing

00:05:44,580 --> 00:05:49,620
that everybody has been looking for for

00:05:46,830 --> 00:05:51,900
a long time its native multi-thread

00:05:49,620 --> 00:05:53,910
supporters so you don't have to use all

00:05:51,900 --> 00:05:56,520
these third-party threatening libraries

00:05:53,910 --> 00:05:58,410
anymore there's one standard library

00:05:56,520 --> 00:06:04,380
everybody can use across the industry

00:05:58,410 --> 00:06:07,440
and a lot of opportunity for performance

00:06:04,380 --> 00:06:12,990
optimization especially in the c++ world

00:06:07,440 --> 00:06:16,110
they make dramatic changes there so what

00:06:12,990 --> 00:06:19,680
you and see fuss c11 first like I said

00:06:16,110 --> 00:06:22,230
the problem big big news is

00:06:19,680 --> 00:06:25,740
multi-threaded native support now they

00:06:22,230 --> 00:06:28,920
are using Java memory model for the most

00:06:25,740 --> 00:06:30,780
part what son hopefully fix it because

00:06:28,920 --> 00:06:35,920
the job of memory model had some

00:06:30,780 --> 00:06:38,380
problems originally there

00:06:35,920 --> 00:06:40,690
that memory model is the basis of the

00:06:38,380 --> 00:06:43,600
multi-threaded support they've added

00:06:40,690 --> 00:06:46,000
unicode support when you hear unicode

00:06:43,600 --> 00:06:48,010
it's not really a hundred percent and

00:06:46,000 --> 00:06:52,150
you still have to do want to get

00:06:48,010 --> 00:06:54,880
multi-language support and c NN c plus

00:06:52,150 --> 00:06:59,640
plus for that matter but they started

00:06:54,880 --> 00:07:02,380
adding the basics of it they have a few

00:06:59,640 --> 00:07:04,060
another very important feature i think

00:07:02,380 --> 00:07:06,160
is adding assertions we're going to be

00:07:04,060 --> 00:07:08,470
taking a look at them that you're

00:07:06,160 --> 00:07:10,990
probably all seen the assert statement

00:07:08,470 --> 00:07:16,000
out there is going that's evaluated at

00:07:10,990 --> 00:07:20,800
compile time not run time they have a

00:07:16,000 --> 00:07:23,560
new API for replacing strings than I Oh

00:07:20,800 --> 00:07:26,650
in some kind of a type-safe boundary

00:07:23,560 --> 00:07:29,380
chat with a standard error handling

00:07:26,650 --> 00:07:32,500
model now there's that's a low

00:07:29,380 --> 00:07:33,730
controversial as well most of the

00:07:32,500 --> 00:07:37,900
mentors look like they're going to

00:07:33,730 --> 00:07:41,260
implement that and maybe the most

00:07:37,900 --> 00:07:45,070
surprising to the sea world is they have

00:07:41,260 --> 00:07:48,370
something close to templates they call

00:07:45,070 --> 00:07:52,090
them generics very limited compared to

00:07:48,370 --> 00:07:54,940
C++ templates but it's there and you can

00:07:52,090 --> 00:07:57,130
now overload math functions that's why

00:07:54,940 --> 00:08:00,520
they added this is for menswear you can

00:07:57,130 --> 00:08:05,860
do absolute on doubles and floats and

00:08:00,520 --> 00:08:07,510
complex and they all work this in the

00:08:05,860 --> 00:08:10,060
other thing they did and this is the

00:08:07,510 --> 00:08:12,430
alignment with c plus plus is there

00:08:10,060 --> 00:08:15,300
there now made certain features that

00:08:12,430 --> 00:08:17,890
were never a bounded by the c++ world as

00:08:15,300 --> 00:08:25,270
optional probably the biggest one is a

00:08:17,890 --> 00:08:27,900
variable length array syntax see those

00:08:25,270 --> 00:08:31,540
buses a lot larger is home going to

00:08:27,900 --> 00:08:35,410
spend a little more time here and but

00:08:31,540 --> 00:08:39,220
still go real fast again they have the

00:08:35,410 --> 00:08:41,880
comment settings with c11 standard

00:08:39,220 --> 00:08:44,950
memory model native multithreading

00:08:41,880 --> 00:08:47,170
unicode support and Static instructions

00:08:44,950 --> 00:08:48,040
those old came from c11 they're exactly

00:08:47,170 --> 00:08:50,920
the same

00:08:48,040 --> 00:08:52,660
so then that's great it makes

00:08:50,920 --> 00:08:55,180
interoperability between the two

00:08:52,660 --> 00:08:58,230
languages really nice the one

00:08:55,180 --> 00:09:02,170
disadvantage and maybe with the changes

00:08:58,230 --> 00:09:05,560
at Apple objective-c really hasn't come

00:09:02,170 --> 00:09:07,000
along with this at all so with apples

00:09:05,560 --> 00:09:13,360
change in direction it might not be

00:09:07,000 --> 00:09:16,600
important anymore beyond that basics

00:09:13,360 --> 00:09:18,940
they started adding some fairly dramatic

00:09:16,600 --> 00:09:23,009
changes to language probably the biggest

00:09:18,940 --> 00:09:25,750
one that affects you as developers is

00:09:23,009 --> 00:09:28,810
etter support for functional style

00:09:25,750 --> 00:09:32,800
programming they have type inference

00:09:28,810 --> 00:09:35,529
anow if ever done haskell programming

00:09:32,800 --> 00:09:39,040
list programming where you get even in a

00:09:35,529 --> 00:09:42,069
strongly typed language like Haskell you

00:09:39,040 --> 00:09:45,579
rarely see a type declaration if you

00:09:42,069 --> 00:09:48,250
don't leave it that's now true in C++ as

00:09:45,579 --> 00:09:52,120
well it changes the language quite

00:09:48,250 --> 00:09:55,360
dramatically they have the land of

00:09:52,120 --> 00:09:57,490
functions so if you've done job or again

00:09:55,360 --> 00:10:02,800
list based program and you can write a

00:09:57,490 --> 00:10:04,569
function just in line instead of having

00:10:02,800 --> 00:10:06,760
the declarative first and then write an

00:10:04,569 --> 00:10:08,319
implementation in the Nazi fob you don't

00:10:06,760 --> 00:10:10,000
have to do that anymore you can write

00:10:08,319 --> 00:10:15,100
little snippets of code just about

00:10:10,000 --> 00:10:17,980
anyplace there is also type deduction

00:10:15,100 --> 00:10:20,139
now so most compilers have had this

00:10:17,980 --> 00:10:22,300
facility it's now standardized you have

00:10:20,139 --> 00:10:24,610
a dekko type you can give it an

00:10:22,300 --> 00:10:28,269
expression and it's as old as a double

00:10:24,610 --> 00:10:33,339
or that's an integer or a complex

00:10:28,269 --> 00:10:35,620
function of major improvements in the

00:10:33,339 --> 00:10:39,040
static analysis and this will help us a

00:10:35,620 --> 00:10:42,819
lot in writing secure code static

00:10:39,040 --> 00:10:45,550
assertions like c11 they face the broken

00:10:42,819 --> 00:10:48,880
enumerations so you have strongly typed

00:10:45,550 --> 00:10:50,829
of informations now and i'm going to

00:10:48,880 --> 00:10:52,420
show you examples of a lot of these in

00:10:50,829 --> 00:10:54,939
just a minute i'm going to go fast

00:10:52,420 --> 00:10:57,699
through these they have explicit

00:10:54,939 --> 00:10:59,529
conversion operators before you find a

00:10:57,699 --> 00:11:00,819
convert an operating it got fired off

00:10:59,529 --> 00:11:05,239
whenever

00:11:00,819 --> 00:11:08,269
implicitly now you can control then they

00:11:05,239 --> 00:11:10,850
got rid of the no throw and added no

00:11:08,269 --> 00:11:13,489
except no accept and there's a lot of

00:11:10,850 --> 00:11:15,769
technical reasons why they did that it's

00:11:13,489 --> 00:11:18,529
a much cleaner approach to know through

00:11:15,769 --> 00:11:21,499
and another thing I'm going to be

00:11:18,529 --> 00:11:24,169
advocating a lot is generalized answer

00:11:21,499 --> 00:11:27,259
these so old compilers had a way of

00:11:24,169 --> 00:11:29,269
expanding the language so in the

00:11:27,259 --> 00:11:33,529
Microsoft world you've probably all seen

00:11:29,269 --> 00:11:35,779
deco type in in GCC they've had a

00:11:33,529 --> 00:11:40,009
visibility interview there is now

00:11:35,779 --> 00:11:41,959
standard syntax for expressing them and

00:11:40,009 --> 00:11:45,259
and they have a standard set of

00:11:41,959 --> 00:11:49,539
attributes man and then again now it

00:11:45,259 --> 00:11:49,539
makes it much more portable your code

00:11:50,019 --> 00:11:55,959
some usability what I call usability

00:11:53,389 --> 00:11:58,819
enhancements they have much nicer

00:11:55,959 --> 00:12:00,649
initializer list initialization has been

00:11:58,819 --> 00:12:02,809
standardized there's not ten different

00:12:00,649 --> 00:12:06,980
ways to initialize anymore that's just

00:12:02,809 --> 00:12:09,259
one way there's range based loops this

00:12:06,980 --> 00:12:12,919
is part of the type deduction type

00:12:09,259 --> 00:12:14,839
inferencing they got null pointer

00:12:12,919 --> 00:12:17,749
literals they don't have 0 and not

00:12:14,839 --> 00:12:21,850
understanding with zero leads and then a

00:12:17,749 --> 00:12:21,850
whole new function declarations intense

00:12:22,179 --> 00:12:31,309
the library if gotten extended this way

00:12:26,029 --> 00:12:35,359
a new a whole new error handling system

00:12:31,309 --> 00:12:37,999
has been added this is true in c11 as

00:12:35,359 --> 00:12:40,910
well and see close causes more extensive

00:12:37,999 --> 00:12:43,249
it citizen parallel with the exception

00:12:40,910 --> 00:12:46,399
so exceptions haven't gone away but

00:12:43,249 --> 00:12:48,829
there is a standard way of communicating

00:12:46,399 --> 00:12:51,889
error codes outside of exceptions and

00:12:48,829 --> 00:12:53,959
the primary reason it was introduced was

00:12:51,889 --> 00:12:57,679
to support multi-threaded programming

00:12:53,959 --> 00:12:59,629
and asynchronous programming which both

00:12:57,679 --> 00:13:03,470
of those are now standard parts of the

00:12:59,629 --> 00:13:07,759
language smart pointers are now standard

00:13:03,470 --> 00:13:09,439
it basically to boost library regular

00:13:07,759 --> 00:13:12,199
expression same thing that took the

00:13:09,439 --> 00:13:13,850
moose library they have hand shifts and

00:13:12,199 --> 00:13:16,220
tuples tuples

00:13:13,850 --> 00:13:18,290
have a dramatic impact again and on the

00:13:16,220 --> 00:13:20,920
program in style not really going to get

00:13:18,290 --> 00:13:24,680
into that too much but it's pretty cool

00:13:20,920 --> 00:13:26,180
they have a nice random number facility

00:13:24,680 --> 00:13:29,750
much much better than what was there

00:13:26,180 --> 00:13:34,399
before either in POSIX or this c plus

00:13:29,750 --> 00:13:36,800
plus there's optional this is again if

00:13:34,399 --> 00:13:39,410
you've done haskell kind of programming

00:13:36,800 --> 00:13:42,110
that's a standard part of the language

00:13:39,410 --> 00:13:43,490
here now if you want to return a tight

00:13:42,110 --> 00:13:47,240
where you don't know if you're going to

00:13:43,490 --> 00:13:51,889
get a value you can say it's optional as

00:13:47,240 --> 00:13:56,899
I said asynchronous i/o and networking

00:13:51,889 --> 00:13:59,899
go together these last two I think are

00:13:56,899 --> 00:14:02,990
real winners and we've been using

00:13:59,899 --> 00:14:05,660
asynchronous audio quite a bit in our

00:14:02,990 --> 00:14:08,149
programs in fact we're converting lots

00:14:05,660 --> 00:14:10,910
of our threaded applications to

00:14:08,149 --> 00:14:19,009
asynchronous i/o is dramatically simpler

00:14:10,910 --> 00:14:20,660
and performs better performance related

00:14:19,009 --> 00:14:23,329
changes are not going to get too much

00:14:20,660 --> 00:14:26,889
into this they have a new whole new kind

00:14:23,329 --> 00:14:32,300
of reference called an r-value reference

00:14:26,889 --> 00:14:35,769
with move semantics so when before you

00:14:32,300 --> 00:14:38,870
have the options of cotton data or

00:14:35,769 --> 00:14:41,389
passing a pointer around it now have the

00:14:38,870 --> 00:14:44,449
ability to move data very very

00:14:41,389 --> 00:14:46,670
efficiently this is going to have a very

00:14:44,449 --> 00:14:48,920
big impact on the performance

00:14:46,670 --> 00:14:50,689
characteristics of the language they're

00:14:48,920 --> 00:14:53,779
seeing when the standard library is

00:14:50,689 --> 00:14:57,980
being updated to move semantics there's

00:14:53,779 --> 00:15:02,240
a 15-percent performance improvements in

00:14:57,980 --> 00:15:08,120
general final day the name is more broad

00:15:02,240 --> 00:15:11,660
definition they have a more generic way

00:15:08,120 --> 00:15:14,360
of expressing constants you can declare

00:15:11,660 --> 00:15:15,889
much more complex types of constants it

00:15:14,360 --> 00:15:19,089
don't just have to be integers or

00:15:15,889 --> 00:15:22,130
strings and then a way of externalizing

00:15:19,089 --> 00:15:26,000
templates for better performance you

00:15:22,130 --> 00:15:27,350
don't get code bloat ok so that's a

00:15:26,000 --> 00:15:29,510
quick tour I'm going to

00:15:27,350 --> 00:15:31,790
show you pieces of what I just spoke

00:15:29,510 --> 00:15:33,560
about I'm going to focus now on the

00:15:31,790 --> 00:15:38,150
language features that would be helpful

00:15:33,560 --> 00:15:40,510
for hardening your applications and the

00:15:38,150 --> 00:15:42,860
first one is use of Hispanic

00:15:40,510 --> 00:15:44,900
verification santak verification

00:15:42,860 --> 00:15:46,550
wherever possible so here are some

00:15:44,900 --> 00:15:48,590
guidelines that I generally recommend

00:15:46,550 --> 00:15:51,650
we're going to see how you can implement

00:15:48,590 --> 00:15:54,200
them in some of the new features of the

00:15:51,650 --> 00:15:56,570
language so first take advantage of to

00:15:54,200 --> 00:15:59,030
type checking system and use stronger

00:15:56,570 --> 00:16:02,090
types wherever possible I'll show you a

00:15:59,030 --> 00:16:03,890
simple example then in a minute you can

00:16:02,090 --> 00:16:06,890
extend the type checking with

00:16:03,890 --> 00:16:09,350
generalized xantra Buse so the type of

00:16:06,890 --> 00:16:11,420
system can say i am the pointer of a

00:16:09,350 --> 00:16:14,210
certain type you'll be guaranteed that

00:16:11,420 --> 00:16:16,040
busy pointing to that type but you won't

00:16:14,210 --> 00:16:19,250
get other guarantees like it's not

00:16:16,040 --> 00:16:22,520
enough you can express that generalized

00:16:19,250 --> 00:16:26,060
attributes static assert is a way of

00:16:22,520 --> 00:16:29,770
doing compile-time assertions a certain

00:16:26,060 --> 00:16:32,840
is runtime assertions remember to

00:16:29,770 --> 00:16:36,440
continue to use your console antics and

00:16:32,840 --> 00:16:41,980
you should consider aliasing semantics

00:16:36,440 --> 00:16:44,570
aliasing has is a common source of both

00:16:41,980 --> 00:16:49,160
performance problems and security

00:16:44,570 --> 00:16:52,340
problems there's a lot of difference of

00:16:49,160 --> 00:16:53,900
opinions in the C and C++ world's a lot

00:16:52,340 --> 00:16:55,940
of people say don't worry about the

00:16:53,900 --> 00:16:58,720
aliasing others say you have to be very

00:16:55,940 --> 00:17:01,340
careful about I'll show you something

00:16:58,720 --> 00:17:08,780
alternatives so I'm going to show you a

00:17:01,340 --> 00:17:12,820
little example here some code and point

00:17:08,780 --> 00:17:12,820
out can you guys see them

00:17:14,780 --> 00:17:20,459
so what I'm going to do is to find a

00:17:18,180 --> 00:17:22,680
function that can takes a nun song and

00:17:20,459 --> 00:17:25,110
convert it to a char i'm going to show

00:17:22,680 --> 00:17:27,839
you different ways of doing that so the

00:17:25,110 --> 00:17:33,450
first thing i do is have a bunch of

00:17:27,839 --> 00:17:38,600
declaration to your char is 0 0 204 they

00:17:33,450 --> 00:17:41,580
have slightly different syntaxes and

00:17:38,600 --> 00:17:44,490
i-44 just petted logical reasons i'm

00:17:41,580 --> 00:17:46,830
passing even by reference so the first

00:17:44,490 --> 00:17:51,900
one is a pointer the next one it's just

00:17:46,830 --> 00:17:54,570
a reference the next the charge there

00:17:51,900 --> 00:17:59,010
are two is showing some use of syntax

00:17:54,570 --> 00:18:02,460
and semantics so the you can now show

00:17:59,010 --> 00:18:04,800
the return type of a function after the

00:18:02,460 --> 00:18:08,190
function argument list with an arrow

00:18:04,800 --> 00:18:10,710
syntax and they've overloaded the auto

00:18:08,190 --> 00:18:13,020
key word or a better weapon where yet

00:18:10,710 --> 00:18:16,200
what they've done is remove the previous

00:18:13,020 --> 00:18:19,440
semantics of auto and now assign did it

00:18:16,200 --> 00:18:22,140
use semantics and this is one of them it

00:18:19,440 --> 00:18:26,910
is mainly used for type deduction so

00:18:22,140 --> 00:18:31,290
this is another way to declare 02 is

00:18:26,910 --> 00:18:34,140
exactly like 01 but with you syntax the

00:18:31,290 --> 00:18:37,830
fourth one is a little more complicated

00:18:34,140 --> 00:18:40,590
here we say auto but we don't specify

00:18:37,830 --> 00:18:42,510
the type the function is going to figure

00:18:40,590 --> 00:18:45,840
out the type by looking at the

00:18:42,510 --> 00:18:49,620
definition this is auto type deduction

00:18:45,840 --> 00:18:52,170
or type inferencing and i'll show you

00:18:49,620 --> 00:18:56,160
examples of those and then the fourth

00:18:52,170 --> 00:19:00,690
one is an example of the new syntax for

00:18:56,160 --> 00:19:10,710
andrews so before you probably saw

00:19:00,690 --> 00:19:14,910
something like this no but there was GCC

00:19:10,710 --> 00:19:18,930
specific didn't work with thing work

00:19:14,910 --> 00:19:22,110
with windows compilers for the most part

00:19:18,930 --> 00:19:25,500
almost unix compilers they accepted it

00:19:22,110 --> 00:19:27,420
but now this is and a hannah two square

00:19:25,500 --> 00:19:29,700
braces

00:19:27,420 --> 00:19:31,980
so specifiers saying what the main it

00:19:29,700 --> 00:19:34,170
comes from we're using don't mean

00:19:31,980 --> 00:19:37,430
there's some standard ones that you use

00:19:34,170 --> 00:19:41,550
STD we're using windows and you win

00:19:37,430 --> 00:19:46,650
something like that and we're saying the

00:19:41,550 --> 00:19:49,470
argument is not unknown ok so here are

00:19:46,650 --> 00:19:51,270
some implementations the first one and

00:19:49,470 --> 00:19:54,330
what I'm going to do is show you the

00:19:51,270 --> 00:19:57,870
least amount of checking to the

00:19:54,330 --> 00:20:00,330
strictest checking okay so the first

00:19:57,870 --> 00:20:02,730
thing I want to do here is have a

00:20:00,330 --> 00:20:06,240
runtime check to make sure the argument

00:20:02,730 --> 00:20:08,940
isn't it no and then I also have to make

00:20:06,240 --> 00:20:12,570
sure i don't have an overflow in integer

00:20:08,940 --> 00:20:16,950
overflow so i use the null pointer this

00:20:12,570 --> 00:20:20,280
is a new type and i have just using the

00:20:16,950 --> 00:20:26,070
numerical limits library everyone cement

00:20:20,280 --> 00:20:31,110
when is that evaluated at runtime it

00:20:26,070 --> 00:20:32,820
isn't evaluated at compile time I then

00:20:31,110 --> 00:20:35,670
have to be reference your argument and

00:20:32,820 --> 00:20:38,340
return the result the other thing I'm

00:20:35,670 --> 00:20:41,580
showing here is notice the keyword auto

00:20:38,340 --> 00:20:45,330
here I didn't have to put int a char

00:20:41,580 --> 00:20:49,730
there if figuring out the type by

00:20:45,330 --> 00:20:53,190
looking at the right side of the

00:20:49,730 --> 00:20:55,830
assignment operator so it said oh this

00:20:53,190 --> 00:20:58,500
this type is a chart that's the type of

00:20:55,830 --> 00:21:03,630
the variable so it's very much like a

00:20:58,500 --> 00:21:05,310
school if you use Haskell before here's

00:21:03,630 --> 00:21:08,220
a straighter one with what's the

00:21:05,310 --> 00:21:10,260
standard thing in in C++ me know if you

00:21:08,220 --> 00:21:14,150
know you want to pass by reference but

00:21:10,260 --> 00:21:17,490
the one guarantee is not known a

00:21:14,150 --> 00:21:19,560
reference the reference type which isn't

00:21:17,490 --> 00:21:23,670
available in see what they didn't c plus

00:21:19,560 --> 00:21:25,830
plus i can now draw i assert what's the

00:21:23,670 --> 00:21:28,170
advantage of doing that well it's

00:21:25,830 --> 00:21:30,900
evaluated a compile-time not run time

00:21:28,170 --> 00:21:34,350
that's the big that's the big one the

00:21:30,900 --> 00:21:36,750
compiler will now check for me not the

00:21:34,350 --> 00:21:40,500
runtime and passing in the set of tests

00:21:36,750 --> 00:21:43,110
I still have this chart for

00:21:40,500 --> 00:21:47,670
a numeric overflow though and again one

00:21:43,110 --> 00:21:51,410
is that evaluated again at runtime can I

00:21:47,670 --> 00:21:58,140
evaluate that I come at compile time

00:21:51,410 --> 00:22:04,140
sure yeah all I need to see is Oh before

00:21:58,140 --> 00:22:08,670
I go there notice now I'm using another

00:22:04,140 --> 00:22:12,650
feature to determine the type of the

00:22:08,670 --> 00:22:18,870
expression so I'm saying the type of

00:22:12,650 --> 00:22:21,120
variable result is this expression

00:22:18,870 --> 00:22:23,610
someone could not call it looks like i'm

00:22:21,120 --> 00:22:25,740
calling the same function but really

00:22:23,610 --> 00:22:27,840
that's evaluated at compile time so the

00:22:25,740 --> 00:22:31,050
compiler can't figure out oh this

00:22:27,840 --> 00:22:35,640
function returns a charm ok so there's

00:22:31,050 --> 00:22:38,490
only one point of maintenance now here's

00:22:35,640 --> 00:22:41,970
the alternate syntax it's exactly the

00:22:38,490 --> 00:22:47,940
same but here I'm going to a stand and

00:22:41,970 --> 00:22:49,950
caserta for evaluating the weather I'm

00:22:47,940 --> 00:22:53,790
going to get an America float overflow

00:22:49,950 --> 00:23:01,560
or not so you see what I'm doing is is

00:22:53,790 --> 00:23:04,860
mine and am I going to get is charming

00:23:01,560 --> 00:23:07,590
enough to hold an unsigned obviously it

00:23:04,860 --> 00:23:10,200
isn't it so it's kind of fit on most

00:23:07,590 --> 00:23:12,270
platforms but if I wanted to be able to

00:23:10,200 --> 00:23:16,500
do then this would be one mechanism to

00:23:12,270 --> 00:23:19,770
do it so there's a new standard operator

00:23:16,500 --> 00:23:21,990
in the language called static assert its

00:23:19,770 --> 00:23:24,180
defined for what CL evidence apropos

00:23:21,990 --> 00:23:33,840
weather and anything is it's about

00:23:24,180 --> 00:23:37,350
waited upon time and then and this one

00:23:33,840 --> 00:23:41,940
is the autotype deduction so char three

00:23:37,350 --> 00:23:45,900
I don't specify a type notice that I

00:23:41,940 --> 00:23:49,440
don't specify any kind of them here and

00:23:45,900 --> 00:23:52,070
not specifying that cold hype the

00:23:49,440 --> 00:23:56,050
compiler figures out by evaluating

00:23:52,070 --> 00:23:59,090
the type of result and now I have a type

00:23:56,050 --> 00:24:02,660
the function type so this is like

00:23:59,090 --> 00:24:09,440
templates but a very very simple way of

00:24:02,660 --> 00:24:12,910
expressing templates and now let me so I

00:24:09,440 --> 00:24:16,370
wrote a little test case let me run it

00:24:12,910 --> 00:24:21,830
compile and run it and the other thing I

00:24:16,370 --> 00:24:24,110
want to show you is how to actually run

00:24:21,830 --> 00:24:27,440
these things so I'm going to use a clan

00:24:24,110 --> 00:24:32,270
compiler I'm going to tell it to

00:24:27,440 --> 00:24:36,320
implement the c++ 17 standard it already

00:24:32,270 --> 00:24:38,890
supports major parts of 17 I'm turning

00:24:36,320 --> 00:24:41,980
on every single check that it can do

00:24:38,890 --> 00:24:45,080
they have an option called everything

00:24:41,980 --> 00:24:48,050
and the only thing I don't want it I

00:24:45,080 --> 00:24:49,970
don't care about is 98 compatibility

00:24:48,050 --> 00:24:51,530
backward compatibility so it turned that

00:24:49,970 --> 00:24:55,400
off and then I'm going to run the

00:24:51,530 --> 00:24:57,890
application so so the first thing to

00:24:55,400 --> 00:25:02,210
notice is I'm now going to get at

00:24:57,890 --> 00:25:06,200
compile-time spanic assert verification

00:25:02,210 --> 00:25:07,640
so the program compiles stopped I don't

00:25:06,200 --> 00:25:11,360
know if I have to write a unit test case

00:25:07,640 --> 00:25:16,760
for that again that's a unit test case I

00:25:11,360 --> 00:25:25,250
don't need to worry about to the other

00:25:16,760 --> 00:25:28,100
thing and is this the other thing that I

00:25:25,250 --> 00:25:31,430
want to show is this one comparison of

00:25:28,100 --> 00:25:37,540
the non null pointer I got that warning

00:25:31,430 --> 00:25:41,930
from the compiler because I annotated

00:25:37,540 --> 00:25:44,870
char 04 with the nominal and the

00:25:41,930 --> 00:25:48,530
compiler was able to do a a flow

00:25:44,870 --> 00:25:51,530
analysis and said hey it's impossible to

00:25:48,530 --> 00:25:54,950
pass no you never passed a note in here

00:25:51,530 --> 00:25:57,920
that assert is completely useless don't

00:25:54,950 --> 00:25:59,930
bother putting it in and the compiler is

00:25:57,920 --> 00:26:02,930
helping you discover that kind of thing

00:25:59,930 --> 00:26:03,860
now if I left it out which I did on the

00:26:02,930 --> 00:26:09,500
other ones I don't

00:26:03,860 --> 00:26:11,000
good morning okay so that's why that's

00:26:09,500 --> 00:26:13,940
what standard assertions have been

00:26:11,000 --> 00:26:18,170
enabling the compiler company helping

00:26:13,940 --> 00:26:20,450
you find of either any kind of error

00:26:18,170 --> 00:26:31,160
that you're introducing at compile time

00:26:20,450 --> 00:26:33,080
not one time the other principle we're

00:26:31,160 --> 00:26:36,530
going to try to use is to fall to say

00:26:33,080 --> 00:26:38,990
behavior in C++ the product when the

00:26:36,530 --> 00:26:42,010
primary mechanisms are doing that is to

00:26:38,990 --> 00:26:45,559
use what's called the RA on pattern

00:26:42,010 --> 00:26:48,320
basic idea here is if you allocate any

00:26:45,559 --> 00:26:51,740
kind of resource you want to make sure

00:26:48,320 --> 00:26:54,760
that by the fall no matter what happens

00:26:51,740 --> 00:26:58,520
that resource gets properly cleaned up

00:26:54,760 --> 00:27:02,140
so with automatic variables that happens

00:26:58,520 --> 00:27:06,080
for you or automatically but for

00:27:02,140 --> 00:27:11,030
dynamically manage resources that

00:27:06,080 --> 00:27:13,700
doesn't luckily we have our aai with

00:27:11,030 --> 00:27:17,210
smart pointers that allow us to manage

00:27:13,700 --> 00:27:20,450
the memory and other dynamic resources

00:27:17,210 --> 00:27:24,640
automatically and I have another simple

00:27:20,450 --> 00:27:24,640
example for you to look at

00:27:30,910 --> 00:27:38,480
so here's your to function on met

00:27:34,760 --> 00:27:44,630
manages memory and another that's going

00:27:38,480 --> 00:27:48,380
to manage a file so we're we're using a

00:27:44,630 --> 00:27:52,430
new a new library future something

00:27:48,380 --> 00:27:55,750
there's a smart pointers now one of the

00:27:52,430 --> 00:27:58,910
smart pointers is called unique PTR

00:27:55,750 --> 00:28:03,320
there's a standard function called make

00:27:58,910 --> 00:28:06,170
unique that will do the call to you for

00:28:03,320 --> 00:28:09,620
you automatically if it fails it will

00:28:06,170 --> 00:28:13,270
throw an exception and you you can then

00:28:09,620 --> 00:28:16,450
can't and be some kind of handling

00:28:13,270 --> 00:28:19,970
however even after the allocation

00:28:16,450 --> 00:28:23,720
happens automatically if something bad

00:28:19,970 --> 00:28:27,170
happens the unique pointer destructor

00:28:23,720 --> 00:28:29,320
will guarantee for you that the delete

00:28:27,170 --> 00:28:31,220
will get cold for that memory

00:28:29,320 --> 00:28:33,260
automatically you don't need to worry

00:28:31,220 --> 00:28:35,870
about it so you don't need to clean up

00:28:33,260 --> 00:28:38,030
memory here at the end of the try and

00:28:35,870 --> 00:28:41,630
you don't need to clean it up in the

00:28:38,030 --> 00:28:45,650
catch it's just completely handled for

00:28:41,630 --> 00:28:49,220
you automatically you can do this

00:28:45,650 --> 00:28:52,220
technique with any kind of resource not

00:28:49,220 --> 00:28:54,680
just memory so you know memory managed

00:28:52,220 --> 00:28:58,850
linkages like Java do this for you

00:28:54,680 --> 00:29:01,280
already but what C++ has that those

00:28:58,850 --> 00:29:04,550
languages phone is a generic way of

00:29:01,280 --> 00:29:08,450
handling all resources so a classic

00:29:04,550 --> 00:29:12,170
example is a file pointer so say for

00:29:08,450 --> 00:29:16,970
example I want to use the standard fo NF

00:29:12,170 --> 00:29:20,330
clothes CAAP on fon dynamically

00:29:16,970 --> 00:29:22,370
allocates a five-pointer there's a whole

00:29:20,330 --> 00:29:24,530
bunch of data structures associated with

00:29:22,370 --> 00:29:28,300
that and I have to remember to call

00:29:24,530 --> 00:29:32,260
close on it otherwise again memory leak

00:29:28,300 --> 00:29:36,740
not a memory leak a file descriptor week

00:29:32,260 --> 00:29:40,040
so what I can do is use standard unique

00:29:36,740 --> 00:29:41,159
pointer it has an overloaded constructor

00:29:40,040 --> 00:29:43,710
where

00:29:41,159 --> 00:29:48,059
you can pass in a custom the allocator

00:29:43,710 --> 00:29:50,419
so in this case I'm allocating with F

00:29:48,059 --> 00:29:55,169
open so that's what's going to actually

00:29:50,419 --> 00:30:00,809
make a mix of the object and when I'm

00:29:55,169 --> 00:30:02,940
finished with it calls an F close and it

00:30:00,809 --> 00:30:05,190
will automatically no matter what an

00:30:02,940 --> 00:30:08,309
exception gets thrown or I reach the end

00:30:05,190 --> 00:30:11,159
of the block or whenever wherever the

00:30:08,309 --> 00:30:13,950
scope a unique pointer in this case the

00:30:11,159 --> 00:30:15,989
variable file we reach the end of the

00:30:13,950 --> 00:30:20,460
scope would guarantee that it gets

00:30:15,989 --> 00:30:23,330
cleaned up so as you know use this

00:30:20,460 --> 00:30:28,739
liquid the latest unless mentions over

00:30:23,330 --> 00:30:31,200
if I said I'll do another variable yep

00:30:28,739 --> 00:30:36,529
can keep track of that for me yes it

00:30:31,200 --> 00:30:39,869
does so the new pointer types have

00:30:36,529 --> 00:30:42,989
ownership semantics so if you assign one

00:30:39,869 --> 00:30:45,899
to another you're transferring ownership

00:30:42,989 --> 00:30:48,720
to the second variable and it's

00:30:45,899 --> 00:30:53,309
automatic is completely transparent to

00:30:48,720 --> 00:30:55,289
you good if anyone has a question ask an

00:30:53,309 --> 00:31:00,570
open mic maneuver so that you're all

00:30:55,289 --> 00:31:03,629
here will grew up on our live stream so

00:31:00,570 --> 00:31:08,690
let me uh let me show you an example of

00:31:03,629 --> 00:31:08,690
that so I'm going to compile this guy

00:31:11,659 --> 00:31:18,779
same with the same kind of defaults and

00:31:15,590 --> 00:31:24,599
you see everything passed now the main

00:31:18,779 --> 00:31:27,149
thing I want to show is a go off i'm

00:31:24,599 --> 00:31:31,710
going to use the memory verification

00:31:27,149 --> 00:31:38,029
tool Val grunted and you folks use

00:31:31,710 --> 00:31:38,029
Meldrum it's just an amazing tool

00:31:42,650 --> 00:31:50,040
so I'm just going to run valbonne can do

00:31:47,460 --> 00:31:52,710
a number of different checks when we're

00:31:50,040 --> 00:31:55,500
going to use as a memory check but at

00:31:52,710 --> 00:31:58,080
the same time in your check all the file

00:31:55,500 --> 00:32:01,050
descriptors so it can do a bunch of

00:31:58,080 --> 00:32:03,270
different kinds of resource checking

00:32:01,050 --> 00:32:05,550
whether the way it works is like a

00:32:03,270 --> 00:32:07,230
little virtual machine and they tracked

00:32:05,550 --> 00:32:11,340
every single thing I don't have to

00:32:07,230 --> 00:32:15,060
compile the code any special way it just

00:32:11,340 --> 00:32:19,430
runs it transparent way so I'm going to

00:32:15,060 --> 00:32:22,890
run it and I get this report at the end

00:32:19,430 --> 00:32:27,410
so it's saying I got three file

00:32:22,890 --> 00:32:30,870
descriptors at the exit the standard

00:32:27,410 --> 00:32:33,960
standard in and out and error that would

00:32:30,870 --> 00:32:38,610
expect so that's okay those aren't

00:32:33,960 --> 00:32:43,320
really leaves it then checked my memory

00:32:38,610 --> 00:32:45,540
and you can see I nothing is lost I do

00:32:43,320 --> 00:32:47,790
have some reachable memory but that's

00:32:45,540 --> 00:32:51,690
okay too and there's nothing really

00:32:47,790 --> 00:32:53,810
wrong there again and notice I don't

00:32:51,690 --> 00:32:56,100
have a delete I don't have a free

00:32:53,810 --> 00:32:58,620
exceptions to get thrown doesn't matter

00:32:56,100 --> 00:33:05,750
it it's all handled automatically for

00:32:58,620 --> 00:33:10,880
you this makes C and C++ much closer to

00:33:05,750 --> 00:33:13,970
manage languages like Java and C sharp

00:33:10,880 --> 00:33:16,970
but with much better performance

00:33:13,970 --> 00:33:16,970
characteristics

00:33:26,560 --> 00:33:34,760
okay let's go a little further another

00:33:30,140 --> 00:33:40,220
feature and this is a feature that a lot

00:33:34,760 --> 00:33:42,560
of languages are introducing and that's

00:33:40,220 --> 00:33:46,700
some of the concepts from functional

00:33:42,560 --> 00:33:49,610
programming as he is C++ is going in a

00:33:46,700 --> 00:33:51,890
major way towards this in both the

00:33:49,610 --> 00:33:55,070
language has some native facilities for

00:33:51,890 --> 00:33:58,010
it and the libraries are being built for

00:33:55,070 --> 00:34:01,280
it the one I'm going to show you is the

00:33:58,010 --> 00:34:05,210
concept of a pure function and these on

00:34:01,280 --> 00:34:08,720
I bring it up is a bunkie you should be

00:34:05,210 --> 00:34:11,420
designing your your applications line

00:34:08,720 --> 00:34:13,940
raised to have a few side effects as

00:34:11,420 --> 00:34:16,370
possible so you define a function but

00:34:13,940 --> 00:34:17,930
one thing and one thing only and doesn't

00:34:16,370 --> 00:34:20,990
have lots of different kinds of side

00:34:17,930 --> 00:34:22,930
effects you can now get the compiler to

00:34:20,990 --> 00:34:26,450
check for you that you've actually

00:34:22,930 --> 00:34:28,400
implemented that contract so the idea of

00:34:26,450 --> 00:34:30,680
a pure function it's a function that

00:34:28,400 --> 00:34:33,110
returns a value it's like a mathematical

00:34:30,680 --> 00:34:35,480
function you give it an argument it

00:34:33,110 --> 00:34:37,360
gives you a result you don't get

00:34:35,480 --> 00:34:42,130
anything else it doesn't modify the

00:34:37,360 --> 00:34:42,130
state of the operating system in any way

00:34:43,150 --> 00:34:56,750
let me uh let me shift and show you a

00:34:46,370 --> 00:34:59,570
simple example event and here here is

00:34:56,750 --> 00:35:02,240
you're going we're going to be using the

00:34:59,570 --> 00:35:04,880
attributes and tanukhs or the language

00:35:02,240 --> 00:35:07,760
so I'm going to define a function called

00:35:04,880 --> 00:35:09,620
turtle and the syntax really gets

00:35:07,760 --> 00:35:12,680
different so I'm going to use thi

00:35:09,620 --> 00:35:15,970
productions excuse me the new sentence

00:35:12,680 --> 00:35:19,520
so auto here's a function named tripled

00:35:15,970 --> 00:35:22,700
here's the attribute that says this

00:35:19,520 --> 00:35:26,720
function is a pure function called

00:35:22,700 --> 00:35:28,930
there's two variants in GCC constant

00:35:26,720 --> 00:35:32,349
pure we're going to use the consequent

00:35:28,930 --> 00:35:34,440
and here's the implementation of the

00:35:32,349 --> 00:35:39,069
function now notice I'm actually

00:35:34,440 --> 00:35:42,400
violating the constant rule that i just

00:35:39,069 --> 00:35:47,020
put and we'll see what the compiler says

00:35:42,400 --> 00:35:49,930
when i do that and the little test i

00:35:47,020 --> 00:36:03,030
have i'm going to call triple twice with

00:35:49,930 --> 00:36:08,040
the same argument what should happen yup

00:36:03,030 --> 00:36:08,040
let me compile it with climbing again

00:36:08,819 --> 00:36:17,920
okay so compiled safe and notice i only

00:36:13,030 --> 00:36:21,250
get it printed once okay even though i

00:36:17,920 --> 00:36:24,400
called the function twice and the reason

00:36:21,250 --> 00:36:27,550
why is i told the company i told the

00:36:24,400 --> 00:36:31,839
compiler this is a side-effect free

00:36:27,550 --> 00:36:36,220
function if you know if you've got the

00:36:31,839 --> 00:36:38,079
value of a call with the argument set to

00:36:36,220 --> 00:36:40,000
a previous value and you called it in

00:36:38,079 --> 00:36:43,109
with the same value go ahead and

00:36:40,000 --> 00:36:46,329
optimize and use the previous value and

00:36:43,109 --> 00:36:49,960
GCC and clang and all of the powers will

00:36:46,329 --> 00:36:53,230
aggressively do that so when you use

00:36:49,960 --> 00:36:57,339
cons you really need to be constant now

00:36:53,230 --> 00:37:00,609
unfortunately TCC and clanging don't

00:36:57,339 --> 00:37:03,400
check for that but we use a commercial

00:37:00,609 --> 00:37:05,770
static analysis tool called flex line

00:37:03,400 --> 00:37:08,859
that will actually warn you it doesn't

00:37:05,770 --> 00:37:10,690
flow analysis and say hey there's a side

00:37:08,859 --> 00:37:14,230
effect in this function that you declare

00:37:10,690 --> 00:37:17,010
pure and you get a compile-time morning

00:37:14,230 --> 00:37:17,010
at that level

00:37:22,780 --> 00:37:33,440
okay though i think i'm going to show in

00:37:28,190 --> 00:37:36,620
the c++ world is the new error handling

00:37:33,440 --> 00:37:38,450
of facility that's available and i'm

00:37:36,620 --> 00:37:41,630
going to show you another feature the

00:37:38,450 --> 00:37:46,400
language it hasn't been adopted formally

00:37:41,630 --> 00:37:48,560
yet by by the committee or mostly

00:37:46,400 --> 00:37:50,900
compiler vendors have not implemented so

00:37:48,560 --> 00:37:54,820
what I'm going to show you is the most

00:37:50,900 --> 00:37:58,640
version of this it's called boost asio

00:37:54,820 --> 00:38:01,250
and as I said this whole new system

00:37:58,640 --> 00:38:05,050
error handling approach was introduced

00:38:01,250 --> 00:38:08,000
to help on multi-threaded applications

00:38:05,050 --> 00:38:11,810
so what happens when you have two

00:38:08,000 --> 00:38:15,800
threads running simultaneously and one

00:38:11,810 --> 00:38:18,020
of them throws an exception how do you

00:38:15,800 --> 00:38:20,930
who catches and then how do you handle

00:38:18,020 --> 00:38:25,580
it well the rules get really complicated

00:38:20,930 --> 00:38:28,040
and in some ways a simpler approach is

00:38:25,580 --> 00:38:31,010
to use error code an error code approach

00:38:28,040 --> 00:38:34,690
and that's what the C++ committee has

00:38:31,010 --> 00:38:34,690
decided as well

00:38:40,070 --> 00:38:47,700
so here's a little example that what I'm

00:38:43,890 --> 00:38:51,180
going to do is I have a function called

00:38:47,700 --> 00:38:56,670
print and all it does is it printf hello

00:38:51,180 --> 00:39:00,840
world if everything went ok now and then

00:38:56,670 --> 00:39:05,640
i'm going to set up an ace of a timer

00:39:00,840 --> 00:39:09,270
that says launch call print in five

00:39:05,640 --> 00:39:13,950
seconds and then while that's going on I

00:39:09,270 --> 00:39:17,490
can do something else like read an HTTP

00:39:13,950 --> 00:39:19,110
request and handle it and new and launch

00:39:17,490 --> 00:39:20,880
other kinds of things so in the

00:39:19,110 --> 00:39:23,640
background while I'm waiting for this

00:39:20,880 --> 00:39:26,100
thing to finish I'll keep going into

00:39:23,640 --> 00:39:29,070
other stuff that's the basic idea behind

00:39:26,100 --> 00:39:32,040
this I'm just showing you the one little

00:39:29,070 --> 00:39:34,980
thing that's going to print so what I do

00:39:32,040 --> 00:39:37,590
is I create something called an IO

00:39:34,980 --> 00:39:40,820
service that's what that's the magic

00:39:37,590 --> 00:39:43,260
that pieces all is simultaneously

00:39:40,820 --> 00:39:46,440
simultaneous activities going on in the

00:39:43,260 --> 00:39:48,980
background asynchronously the first

00:39:46,440 --> 00:39:52,620
thing I do is create a deadline timer i

00:39:48,980 --> 00:39:55,350
associated with that I 0 service and I

00:39:52,620 --> 00:39:57,900
tell it what the deadline of what the

00:39:55,350 --> 00:40:01,830
timeout is and then I tell it

00:39:57,900 --> 00:40:05,550
asynchronously wait till this occurs

00:40:01,830 --> 00:40:09,630
what that means is go ahead and Q this

00:40:05,550 --> 00:40:12,480
thing up and then keep going keep

00:40:09,630 --> 00:40:17,340
executing so it's not going to block

00:40:12,480 --> 00:40:22,700
here this call is not going to block so

00:40:17,340 --> 00:40:22,700
i can i can

00:40:26,300 --> 00:40:36,390
let me just run it first just to show

00:40:29,130 --> 00:40:39,780
you it so I'm going to compile it oh I

00:40:36,390 --> 00:40:42,890
forgot I have to link in the boots

00:40:39,780 --> 00:40:42,890
library here

00:41:14,119 --> 00:41:19,309
okay it was waiting five seconds and

00:41:16,759 --> 00:41:22,849
they came out so that's all you need to

00:41:19,309 --> 00:41:26,089
do so I I've set up in a few months of

00:41:22,849 --> 00:41:28,309
code I've set up an asynchronous program

00:41:26,089 --> 00:41:29,980
that behind the scenes of doing whole

00:41:28,309 --> 00:41:33,470
bunch of multi-threading it's

00:41:29,980 --> 00:41:35,599
unbelievably simple it said you do have

00:41:33,470 --> 00:41:40,099
to worry about what if something went

00:41:35,599 --> 00:41:43,640
wrong and the problem is is I launched a

00:41:40,099 --> 00:41:47,509
program here and how do I report back to

00:41:43,640 --> 00:41:50,779
that protocol a handler that something

00:41:47,509 --> 00:41:54,829
went wrong and that's coming and this

00:41:50,779 --> 00:41:57,380
new system error code is the mechanism

00:41:54,829 --> 00:42:01,309
for them so you see the callback

00:41:57,380 --> 00:42:04,190
function takes a new parameter of

00:42:01,309 --> 00:42:07,789
reference to an error code that's the

00:42:04,190 --> 00:42:10,400
mechanism for i 0 service to say hey

00:42:07,789 --> 00:42:14,240
something went wrong don't just print

00:42:10,400 --> 00:42:15,769
out hello world try to handle it so in

00:42:14,240 --> 00:42:18,769
this case we're just going to print it

00:42:15,769 --> 00:42:22,910
out and keep going you don't have to

00:42:18,769 --> 00:42:25,430
worry about coordinating exceptions or a

00:42:22,910 --> 00:42:27,619
community communicating an exception

00:42:25,430 --> 00:42:31,999
from one thread to another thread all of

00:42:27,619 --> 00:42:34,609
that difficulty goes away because we've

00:42:31,999 --> 00:42:37,910
been using the boost asio library a lot

00:42:34,609 --> 00:42:40,279
it really is quite nice I think I'm

00:42:37,910 --> 00:42:45,289
looking forward to becoming part of the

00:42:40,279 --> 00:42:50,809
c++ standard and visit aspect of it the

00:42:45,289 --> 00:42:58,400
error handling is very nice okay am I

00:42:50,809 --> 00:43:03,559
looking for time I'm waiting over yeah

00:42:58,400 --> 00:43:05,749
so let me let me just go real quick i'll

00:43:03,559 --> 00:43:07,369
just mention a few things about and this

00:43:05,749 --> 00:43:09,410
is really maybe the most important we

00:43:07,369 --> 00:43:11,660
went over the language feature the

00:43:09,410 --> 00:43:14,779
language is changing unbelievably fast

00:43:11,660 --> 00:43:18,799
but the tooling is changing just as fast

00:43:14,779 --> 00:43:23,029
as well so I shown you Val grind the new

00:43:18,799 --> 00:43:27,069
compiler clang in particular is just

00:43:23,029 --> 00:43:30,839
amazingly good in GCC with it

00:43:27,069 --> 00:43:34,589
competition is also increasingly good to

00:43:30,839 --> 00:43:49,930
the primary thing i would like to

00:43:34,589 --> 00:43:53,199
appoint you at is um is this here of the

00:43:49,930 --> 00:43:56,910
new tool chain have provided i showed

00:43:53,199 --> 00:44:00,489
you valendron but the new compilers

00:43:56,910 --> 00:44:04,150
sponsored primarily on Apple in Google a

00:44:00,489 --> 00:44:07,420
developed of checkers for these tools

00:44:04,150 --> 00:44:10,329
the ones that are most impressive or the

00:44:07,420 --> 00:44:12,640
sand sanitizers they having that address

00:44:10,329 --> 00:44:16,359
and the times were thread and undefined

00:44:12,640 --> 00:44:18,489
behavior they are a little bit different

00:44:16,359 --> 00:44:20,650
than L growing Val run as a virtual

00:44:18,489 --> 00:44:22,839
machine it will run anything here you

00:44:20,650 --> 00:44:26,410
have to actually compile your code and

00:44:22,839 --> 00:44:28,959
then especially and then executed two

00:44:26,410 --> 00:44:31,690
standalone executable at that time but

00:44:28,959 --> 00:44:35,589
it checks an unbelievable range of

00:44:31,690 --> 00:44:38,499
errors we combine both bound Rhine and

00:44:35,589 --> 00:44:42,339
they same teasing and the undefined

00:44:38,499 --> 00:44:44,410
behavior is another very nice one so by

00:44:42,339 --> 00:44:47,410
undefined behavior is what if you get an

00:44:44,410 --> 00:44:50,739
integer overflow what happens then right

00:44:47,410 --> 00:44:53,529
now the thing just keeps running with an

00:44:50,739 --> 00:44:57,209
unfun behavior sanitizer it will see

00:44:53,529 --> 00:45:02,140
that and report that as an error to you

00:44:57,209 --> 00:45:04,749
and with that I'd again anywhere close

00:45:02,140 --> 00:45:08,609
to finishing if you want the rest of the

00:45:04,749 --> 00:45:14,589
presentation will make it available to

00:45:08,609 --> 00:45:16,719
go go oh I do okay okay done I thought

00:45:14,589 --> 00:45:21,630
I'd only have it now Oh what started a

00:45:16,719 --> 00:45:21,630
top 30 yeah okay let me keep going again

00:45:23,130 --> 00:45:29,769
ok so the tooling I kind of went through

00:45:26,709 --> 00:45:33,059
them as i said the tooling is is staying

00:45:29,769 --> 00:45:35,799
up unlike previous versions of C and C++

00:45:33,059 --> 00:45:37,569
where you got a standard nobody

00:45:35,799 --> 00:45:40,300
implemented them that's not the case

00:45:37,569 --> 00:45:42,520
anymore usually the

00:45:40,300 --> 00:45:44,890
our vendors or ahead of the standards

00:45:42,520 --> 00:45:52,870
committee so you're getting the new

00:45:44,890 --> 00:45:54,520
standard it right away the we already

00:45:52,870 --> 00:45:58,180
went through some of the annotation

00:45:54,520 --> 00:46:00,910
support so I'm not going to go in I will

00:45:58,180 --> 00:46:05,200
point out a few the other ones that I

00:46:00,910 --> 00:46:07,510
haven't used so far some of the most

00:46:05,200 --> 00:46:10,480
important ones or the format especially

00:46:07,510 --> 00:46:13,060
if you're doing C programming and some

00:46:10,480 --> 00:46:17,250
of our clients have large c code bases

00:46:13,060 --> 00:46:19,720
and we very effectively use this if you

00:46:17,250 --> 00:46:23,800
annotate the functions that take

00:46:19,720 --> 00:46:25,870
variable arguments the compiler will be

00:46:23,800 --> 00:46:30,550
able to check them in compile time

00:46:25,870 --> 00:46:37,180
instead of run time using the form and

00:46:30,550 --> 00:46:40,270
attribute the the other one that's not

00:46:37,180 --> 00:46:43,330
exactly related to robustness is the

00:46:40,270 --> 00:46:46,210
visibility attribute it has a critical

00:46:43,330 --> 00:46:51,310
impact on the overall performance of

00:46:46,210 --> 00:46:55,840
your applications this controls if I

00:46:51,310 --> 00:46:58,960
compile a program that has multiple Nazi

00:46:55,840 --> 00:47:01,450
files to the library on compiling the

00:46:58,960 --> 00:47:04,750
library I only want a subset of those

00:47:01,450 --> 00:47:07,150
exported not the full set but there's no

00:47:04,750 --> 00:47:10,930
way of expressing that in the language

00:47:07,150 --> 00:47:13,960
this visibility attribute goes beyond

00:47:10,930 --> 00:47:16,570
the language and says export only these

00:47:13,960 --> 00:47:20,080
symbols all these others are private it

00:47:16,570 --> 00:47:25,860
reduces a focus the surface area of your

00:47:20,080 --> 00:47:29,670
lime erase here are some basic

00:47:25,860 --> 00:47:32,230
recommendations around these annotations

00:47:29,670 --> 00:47:34,330
visibility is just a must-have in any

00:47:32,230 --> 00:47:38,080
real world applications as far as i can

00:47:34,330 --> 00:47:40,090
see unsurprised that lot of open source

00:47:38,080 --> 00:47:44,080
projects still don't use this as a

00:47:40,090 --> 00:47:47,350
resident is it really should the

00:47:44,080 --> 00:47:51,580
annotations in general is a very simple

00:47:47,350 --> 00:47:52,670
low-cost effort to put in that gives you

00:47:51,580 --> 00:47:54,920
lots of wind

00:47:52,670 --> 00:47:58,250
in terms of not having the right as many

00:47:54,920 --> 00:48:00,500
unit test cases just us putting in the

00:47:58,250 --> 00:48:06,130
non null attribute has saved us

00:48:00,500 --> 00:48:10,130
countless hours debugging add pointers

00:48:06,130 --> 00:48:13,190
one thing to take maximal advantage of

00:48:10,130 --> 00:48:16,369
this is if the compiler can see more the

00:48:13,190 --> 00:48:19,339
program as its analyzing it it can do

00:48:16,369 --> 00:48:21,470
more flow analysis so it showed you a

00:48:19,339 --> 00:48:23,869
little program where it could deduce

00:48:21,470 --> 00:48:26,089
that I had a function with the non null

00:48:23,869 --> 00:48:28,819
and I never saw any place that could be

00:48:26,089 --> 00:48:31,760
called without a null argument and it

00:48:28,819 --> 00:48:36,650
can it can only do that if it sees all

00:48:31,760 --> 00:48:39,849
the program I will focus mostly on open

00:48:36,650 --> 00:48:42,710
source but there there's a very wide

00:48:39,849 --> 00:48:45,230
availability of commercial tools some of

00:48:42,710 --> 00:48:48,829
them very very good we've been using

00:48:45,230 --> 00:48:51,170
Gimple Switzerland for many years and it

00:48:48,829 --> 00:48:55,309
has excellent support for annotations

00:48:51,170 --> 00:48:58,579
that go way beyond with GCC and clang

00:48:55,309 --> 00:49:04,130
provided so that would be something to

00:48:58,579 --> 00:49:06,589
take a look at next the next kind of

00:49:04,130 --> 00:49:08,299
thing is I'm going to focus get out of

00:49:06,589 --> 00:49:12,380
the language you get into the build

00:49:08,299 --> 00:49:15,440
process and what we need to do to

00:49:12,380 --> 00:49:18,410
protect your applications to the large

00:49:15,440 --> 00:49:22,400
extent possible and there's a surprising

00:49:18,410 --> 00:49:24,200
lot that can be done at this point so

00:49:22,400 --> 00:49:27,530
first and I'm going to go through a

00:49:24,200 --> 00:49:29,869
standard set a list fortunately a lot of

00:49:27,530 --> 00:49:33,530
the Linux distributions are implementing

00:49:29,869 --> 00:49:35,780
these things by policy now it's a little

00:49:33,530 --> 00:49:39,079
uneven and I'll show you an example of

00:49:35,780 --> 00:49:40,790
that in just a little bit and depending

00:49:39,079 --> 00:49:42,589
on which distribution you might want to

00:49:40,790 --> 00:49:46,160
go and check to see how good you are

00:49:42,589 --> 00:49:50,420
looking and push your your distribution

00:49:46,160 --> 00:49:53,000
to adopt this first one is the standard

00:49:50,420 --> 00:49:56,750
C and C++ libraries have a whole bunch

00:49:53,000 --> 00:49:59,150
of checks enabled internally that you

00:49:56,750 --> 00:50:01,280
can turn on or turn off by default

00:49:59,150 --> 00:50:03,770
they're off you actually have to turn

00:50:01,280 --> 00:50:05,690
them on and you do them with this

00:50:03,770 --> 00:50:08,390
fortify source and cons

00:50:05,690 --> 00:50:10,640
checks flags during the compilation

00:50:08,390 --> 00:50:14,750
process this will look for buffer

00:50:10,640 --> 00:50:17,840
overflows or man strength misuse whole

00:50:14,750 --> 00:50:20,120
range of errors so I had an interesting

00:50:17,840 --> 00:50:25,370
experience recently where we switched

00:50:20,120 --> 00:50:28,820
from open suse a 11 to 13 2 they enabled

00:50:25,370 --> 00:50:32,540
this check and when we try to run maycon

00:50:28,820 --> 00:50:36,020
on a may file that has run for years if

00:50:32,540 --> 00:50:39,350
found several buffer overflows so we had

00:50:36,020 --> 00:50:41,900
to move up to the next release of myth

00:50:39,350 --> 00:50:45,170
that had never found they've corrected

00:50:41,900 --> 00:50:47,360
all the defects so so these cats real

00:50:45,170 --> 00:50:49,970
errors in real production code code that

00:50:47,360 --> 00:50:52,040
has been used like you cannot believe

00:50:49,970 --> 00:50:57,050
when could you make has had that error

00:50:52,040 --> 00:51:01,940
forever in other words and it only was

00:50:57,050 --> 00:51:05,630
enabled by this check stack overflow so

00:51:01,940 --> 00:51:08,380
you know a standard attack is a pro

00:51:05,630 --> 00:51:14,680
someone's going to get into your program

00:51:08,380 --> 00:51:17,780
pass in a like a sequel sprint that were

00:51:14,680 --> 00:51:20,390
some type of input string that you're

00:51:17,780 --> 00:51:24,850
going to parse and they're hoping to get

00:51:20,390 --> 00:51:27,980
past the stack and put their own mega

00:51:24,850 --> 00:51:30,530
memory there and then jump to them and

00:51:27,980 --> 00:51:33,200
start executing their own code that's

00:51:30,530 --> 00:51:36,710
called a sax finishing intent there's

00:51:33,200 --> 00:51:39,290
Andrew tools now for protecting against

00:51:36,710 --> 00:51:42,320
them so what they basically news put

00:51:39,290 --> 00:51:45,080
sentinels around the span to see if the

00:51:42,320 --> 00:51:47,600
stack has gotten compromised all of the

00:51:45,080 --> 00:51:50,870
powers now enable that with some type of

00:51:47,600 --> 00:51:53,840
stack smashing in the GCC and climb

00:51:50,870 --> 00:51:55,460
world that's what stack protector option

00:51:53,840 --> 00:52:05,350
you want to make sure that that's

00:51:55,460 --> 00:52:05,350
enabled okay oops

00:52:05,380 --> 00:52:12,980
the the next one is you want to get

00:52:11,300 --> 00:52:17,690
protect yourself against buffer

00:52:12,980 --> 00:52:22,910
overflows and this this is with address

00:52:17,690 --> 00:52:25,850
space randomization this alone the idea

00:52:22,910 --> 00:52:28,670
here is attackers can learn the usage

00:52:25,850 --> 00:52:31,130
pattern of memory over time and again

00:52:28,670 --> 00:52:34,580
insert some of their code that can

00:52:31,130 --> 00:52:37,130
hijack the application so what was done

00:52:34,580 --> 00:52:40,190
by modern compilers and operating

00:52:37,130 --> 00:52:43,910
systems is randomization of the memory

00:52:40,190 --> 00:52:46,340
you have to enable it though again this

00:52:43,910 --> 00:52:48,950
this should be standard when you're

00:52:46,340 --> 00:52:51,680
compiling and executable you always want

00:52:48,950 --> 00:53:00,740
to compile it with a tiny option when

00:52:51,680 --> 00:53:03,140
you're when you're compiling a library

00:53:00,740 --> 00:53:08,840
you always want to compile with a pic

00:53:03,140 --> 00:53:10,730
option I'm going to go through a few

00:53:08,840 --> 00:53:14,600
more and then we'll actually show how to

00:53:10,730 --> 00:53:17,600
evaluate programs the next one is when

00:53:14,600 --> 00:53:22,670
your application is starting up how do

00:53:17,600 --> 00:53:24,290
you prevent someone from overriding one

00:53:22,670 --> 00:53:27,020
of the memory segments in the lower

00:53:24,290 --> 00:53:29,240
section that's another common kind of

00:53:27,020 --> 00:53:32,150
attack so this is during load up on

00:53:29,240 --> 00:53:34,940
during normal execution so what they've

00:53:32,150 --> 00:53:37,430
done is they placed a trojan on your

00:53:34,940 --> 00:53:39,440
machine they're waiting for you to start

00:53:37,430 --> 00:53:42,440
up an application when the application

00:53:39,440 --> 00:53:44,870
starts up they insert their code as part

00:53:42,440 --> 00:53:47,630
of the loader you can protect yourself

00:53:44,870 --> 00:53:50,510
against them by making those lower

00:53:47,630 --> 00:53:52,760
segments read-only you just can't right

00:53:50,510 --> 00:53:56,360
into them that it's just impossible to

00:53:52,760 --> 00:54:03,260
do and that's with a special link option

00:53:56,360 --> 00:54:08,890
cold relocation read-only a similar a

00:54:03,260 --> 00:54:12,230
similar kind of someone kind of thing is

00:54:08,890 --> 00:54:13,630
making sure you bind to all the

00:54:12,230 --> 00:54:16,850
libraries you're going to load

00:54:13,630 --> 00:54:17,960
immediately to prevent instead of doing

00:54:16,850 --> 00:54:20,540
a lazy load

00:54:17,960 --> 00:54:24,050
and that prevents someone from inserting

00:54:20,540 --> 00:54:27,080
than a new version of the library and

00:54:24,050 --> 00:54:30,740
hijacking the library in other words so

00:54:27,080 --> 00:54:37,700
that's done with linking now instead of

00:54:30,740 --> 00:54:41,510
during during the load process there you

00:54:37,700 --> 00:54:45,410
can then these these are a little bit

00:54:41,510 --> 00:54:50,270
more advanced you can have a checking a

00:54:45,410 --> 00:54:54,619
very common error for example the the

00:54:50,270 --> 00:54:57,200
sei secure coding guidelines warn you

00:54:54,619 --> 00:54:59,480
about integer overflow and they they

00:54:57,200 --> 00:55:01,730
have an excellent section about how a

00:54:59,480 --> 00:55:04,040
different attacks that have been done by

00:55:01,730 --> 00:55:05,599
doing it if your overflow you can

00:55:04,040 --> 00:55:08,869
protect yourself to a certain degree

00:55:05,599 --> 00:55:12,050
with the compilers by enabling the

00:55:08,869 --> 00:55:15,170
strict overflow checks so this is a

00:55:12,050 --> 00:55:17,810
runtime check the runtime will now

00:55:15,170 --> 00:55:19,820
evaluate for any integer float and

00:55:17,810 --> 00:55:23,210
you'll get an error instead of muddling

00:55:19,820 --> 00:55:26,900
along and getting compromised and same

00:55:23,210 --> 00:55:30,740
kind of thing with the aliasing so let

00:55:26,900 --> 00:55:35,210
me show you an example of that how you

00:55:30,740 --> 00:55:37,430
can evaluate this we I'm using the W

00:55:35,210 --> 00:55:39,290
distribution here in the layer last

00:55:37,430 --> 00:55:42,260
release they went through a major effort

00:55:39,290 --> 00:55:45,109
of trying to implement a lot of these it

00:55:42,260 --> 00:55:47,000
was pretty uneven unfortunately in the

00:55:45,109 --> 00:55:49,940
major problem is some of the program

00:55:47,000 --> 00:55:53,420
simply can't compiled with these options

00:55:49,940 --> 00:55:58,250
yet not clean enough to do it they did

00:55:53,420 --> 00:56:02,810
provide a tool called check-up hardening

00:55:58,250 --> 00:56:05,420
check and what you do it is is give it

00:56:02,810 --> 00:56:07,790
an executable so I'm going to check how

00:56:05,420 --> 00:56:12,080
is my bash shell looking do I have

00:56:07,790 --> 00:56:15,170
another bash use last year about the

00:56:12,080 --> 00:56:18,560
batch exploit coming out they certainly

00:56:15,170 --> 00:56:21,589
could use some help unfinished so how

00:56:18,560 --> 00:56:26,080
many of these recommendations i put were

00:56:21,589 --> 00:56:30,660
implemented well they didn't do the time

00:56:26,080 --> 00:56:32,880
one it's not a PI executable

00:56:30,660 --> 00:56:36,330
normal executable them beans that's

00:56:32,880 --> 00:56:38,940
honorable to that kind of attack it is

00:56:36,330 --> 00:56:42,330
compiled woods back protection so at

00:56:38,940 --> 00:56:45,510
least we have that part they do have

00:56:42,330 --> 00:56:48,420
some of the some of the fortifications

00:56:45,510 --> 00:56:58,110
enabled and I can actually get more

00:56:48,420 --> 00:57:02,100
details on that so you can see stir copy

00:56:58,110 --> 00:57:08,700
is protected but f gets s is not as an

00:57:02,100 --> 00:57:10,710
example and the last check they have

00:57:08,700 --> 00:57:15,120
read only in relocations that's great

00:57:10,710 --> 00:57:17,010
but it's not immediately found so so we

00:57:15,120 --> 00:57:28,380
can get a hijacked of the sea laundry

00:57:17,010 --> 00:57:32,730
for example so doing well maybe i'll

00:57:28,380 --> 00:57:34,320
leave it there there's well let me do

00:57:32,730 --> 00:57:38,690
just give these are just simple

00:57:34,320 --> 00:57:40,830
guidelines for at a much higher level of

00:57:38,690 --> 00:57:42,510
compilation best practices so you've

00:57:40,830 --> 00:57:44,100
seen some of the language is seeing some

00:57:42,510 --> 00:57:48,120
of the compilation tools that are

00:57:44,100 --> 00:57:52,620
available my experience is putting these

00:57:48,120 --> 00:57:56,070
in after the fact is very difficult is

00:57:52,620 --> 00:57:58,590
not impossible or takes many years again

00:57:56,070 --> 00:58:01,950
in place so retrofitting after the fact

00:57:58,590 --> 00:58:04,380
is is just too hard trying to get it in

00:58:01,950 --> 00:58:07,140
early in the development phase now I

00:58:04,380 --> 00:58:10,530
know most of us case legacy code bases

00:58:07,140 --> 00:58:13,050
so this is easier said than done and we

00:58:10,530 --> 00:58:15,420
had lots of techniques and tricks to

00:58:13,050 --> 00:58:17,100
help help get this into installed code

00:58:15,420 --> 00:58:21,360
basically but it's much harder it's

00:58:17,100 --> 00:58:24,360
better if you can get it in something

00:58:21,360 --> 00:58:27,090
that's often not well understood is a

00:58:24,360 --> 00:58:30,000
lot of these checks can only be done

00:58:27,090 --> 00:58:32,760
when the compiler is actually optimizing

00:58:30,000 --> 00:58:34,860
the code that's when the curb Tyler is

00:58:32,760 --> 00:58:37,860
actually doing more thorough path

00:58:34,860 --> 00:58:41,100
analysis primarily to check to see oh

00:58:37,860 --> 00:58:42,680
this this there's a mismatch here and I

00:58:41,100 --> 00:58:44,660
need to

00:58:42,680 --> 00:58:49,310
and you only get that kind of analysis

00:58:44,660 --> 00:58:51,710
one optimization then you want to always

00:58:49,310 --> 00:58:53,600
check and we've learned this from hard

00:58:51,710 --> 00:58:56,690
experience we put in a lot of these

00:58:53,600 --> 00:58:59,090
processes and tools and then the

00:58:56,690 --> 00:59:01,130
development staff doesn't use them so

00:58:59,090 --> 00:59:03,890
you have to have as part of the build

00:59:01,130 --> 00:59:05,780
process of verification so tools like

00:59:03,890 --> 00:59:10,510
this little thing that it will show you

00:59:05,780 --> 00:59:10,510
hardening check is a really useful thing

00:59:12,220 --> 00:59:17,960
ok I'm going to just highlight a few

00:59:15,440 --> 00:59:20,930
things that I'm not going to be able to

00:59:17,960 --> 00:59:23,660
get to if you want to we can discuss

00:59:20,930 --> 00:59:25,640
separately a major feature on that I

00:59:23,660 --> 00:59:30,200
hoped have covered with some of the

00:59:25,640 --> 00:59:32,240
Linux kernel level capabilities or new

00:59:30,200 --> 00:59:36,110
things that are coming up and the

00:59:32,240 --> 00:59:38,720
primary things there is you probably all

00:59:36,110 --> 00:59:42,260
heard of containers and systems like

00:59:38,720 --> 00:59:44,780
darker well what is the technology that

00:59:42,260 --> 00:59:47,000
those are implemented on and there's

00:59:44,780 --> 00:59:48,830
three main things that you guys should

00:59:47,000 --> 00:59:51,290
know because you don't need to go to the

00:59:48,830 --> 00:59:54,020
docker containers there those are fairly

00:59:51,290 --> 00:59:56,420
heavy weight and and there's some

00:59:54,020 --> 00:59:58,370
trade-offs there you can use all the

00:59:56,420 --> 01:00:00,740
other technologies in your programs

00:59:58,370 --> 01:00:04,160
right away now today and without having

01:00:00,740 --> 01:00:06,800
to go the donker first one is what's

01:00:04,160 --> 01:00:11,870
called namespaces that's like change

01:00:06,800 --> 01:00:15,710
route on jails on on steroids it's a

01:00:11,870 --> 01:00:17,720
much more complete isolation of your

01:00:15,710 --> 01:00:20,090
program to the resources that are

01:00:17,720 --> 01:00:24,140
available the second thing your seed

01:00:20,090 --> 01:00:27,380
roots a short it's in radiation for

01:00:24,140 --> 01:00:30,230
control groups that's a better mechanism

01:00:27,380 --> 01:00:33,470
for controlling access to the resources

01:00:30,230 --> 01:00:36,350
you so you can say that CPU can have ten

01:00:33,470 --> 01:00:38,630
percent of this network this other front

01:00:36,350 --> 01:00:41,270
of this other process can only have

01:00:38,630 --> 01:00:44,960
thirty percent of the memory a very fine

01:00:41,270 --> 01:00:48,440
granularity of the previous way of doing

01:00:44,960 --> 01:00:52,720
that with was POSIX are limits and that

01:00:48,440 --> 01:00:57,000
wasn't very complete miss major features

01:00:52,720 --> 01:01:01,180
oh and then though the last feature is

01:00:57,000 --> 01:01:04,570
what's called sitcom something developed

01:01:01,180 --> 01:01:07,810
by the Google team for chromium and this

01:01:04,570 --> 01:01:11,290
is sandbox into the colonel so when you

01:01:07,810 --> 01:01:16,450
start up an application of demons a an

01:01:11,290 --> 01:01:19,560
HTTP server what can it do what what

01:01:16,450 --> 01:01:22,770
features of the kernel can it access the

01:01:19,560 --> 01:01:26,290
answer mail is every single feature

01:01:22,770 --> 01:01:28,660
which is probably not what you want they

01:01:26,290 --> 01:01:32,560
used to try they had a system called

01:01:28,660 --> 01:01:35,470
capabilities to try to management but

01:01:32,560 --> 01:01:39,280
that did not work out frankly was too

01:01:35,470 --> 01:01:41,740
complex and wasn't useful enough sci

01:01:39,280 --> 01:01:44,170
comp is it seems to be a practical

01:01:41,740 --> 01:01:47,560
solution you have very fine granularity

01:01:44,170 --> 01:01:49,900
you can say this process I want to have

01:01:47,560 --> 01:01:53,980
only the ability to call these three

01:01:49,900 --> 01:01:56,590
system calls like fon open and close on

01:01:53,980 --> 01:01:59,770
this phone and that's it it can call

01:01:56,590 --> 01:02:03,220
anything else in the kernel and you can

01:01:59,770 --> 01:02:07,230
do that on a case-by-case basis so this

01:02:03,220 --> 01:02:10,210
is like the closest comparable thing is

01:02:07,230 --> 01:02:13,000
it the way works actually make it by the

01:02:10,210 --> 01:02:15,580
way to explain it is a demon when you

01:02:13,000 --> 01:02:19,660
start up a team and you usually start up

01:02:15,580 --> 01:02:22,570
as rude you these holy resources we walk

01:02:19,660 --> 01:02:24,640
yourself into a portion of the file

01:02:22,570 --> 01:02:28,330
system and then you call change written

01:02:24,640 --> 01:02:30,730
and that point you can't get back out

01:02:28,330 --> 01:02:32,950
you have to draw privilege an end point

01:02:30,730 --> 01:02:35,730
and you can't get that gap but the only

01:02:32,950 --> 01:02:39,130
thing you've protected is a file system

01:02:35,730 --> 01:02:41,410
with set com you protect everything in

01:02:39,130 --> 01:02:44,920
the kernel on just the final system and

01:02:41,410 --> 01:02:47,680
it's a one kind of one-time thing so you

01:02:44,920 --> 01:02:49,990
say uncle I start up the application as

01:02:47,680 --> 01:02:53,560
rude you say I want to drop all these

01:02:49,990 --> 01:02:55,960
accesses to the colonel you execute that

01:02:53,560 --> 01:03:00,670
and you're done you can never get them

01:02:55,960 --> 01:03:03,730
back so the way chrome is built or

01:03:00,670 --> 01:03:06,640
Firefox is what they do is have lots of

01:03:03,730 --> 01:03:09,779
little child processes at each

01:03:06,640 --> 01:03:16,380
one does only one thing like the PDF

01:03:09,779 --> 01:03:19,720
displayer has just one set of CENTCOM

01:03:16,380 --> 01:03:23,190
system calls it can make the renderer

01:03:19,720 --> 01:03:28,869
has another and they they don't enter

01:03:23,190 --> 01:03:34,140
intercept at all okay so that was a

01:03:28,869 --> 01:03:34,140
whirlwind tour any questions

01:03:53,819 --> 01:03:58,119
your customers rely on your website or

01:03:56,619 --> 01:04:00,489
application if it's slower

01:03:58,119 --> 01:04:03,429
non-responsive it infuriates your users

01:04:00,489 --> 01:04:05,229
and costs you money keeping your

01:04:03,429 --> 01:04:08,770
business critical systems humming along

01:04:05,229 --> 01:04:11,050
requires insight into what they're doing

01:04:08,770 --> 01:04:13,000
your system metrics tells stories

01:04:11,050 --> 01:04:15,010
stories that can reveal performance

01:04:13,000 --> 01:04:17,350
bottlenecks resource limitations and

01:04:15,010 --> 01:04:18,910
other problems but how do you keep an

01:04:17,350 --> 01:04:21,550
eye on all of your systems performance

01:04:18,910 --> 01:04:24,610
metrics in real-time and record this

01:04:21,550 --> 01:04:26,560
data for a liter analysis enter longview

01:04:24,610 --> 01:04:28,960
the new way to see what's really going

01:04:26,560 --> 01:04:30,880
on under the hood the longview dashboard

01:04:28,960 --> 01:04:32,590
lets you visualize the status of all

01:04:30,880 --> 01:04:35,020
your systems providing you with a

01:04:32,590 --> 01:04:38,410
bird's-eye view of your entire fleet you

01:04:35,020 --> 01:04:40,990
can sort by cpu memory swap processes

01:04:38,410 --> 01:04:42,730
load and network usage click a specific

01:04:40,990 --> 01:04:45,130
system to access its individual

01:04:42,730 --> 01:04:47,670
dashboard then click and drag to zoom in

01:04:45,130 --> 01:04:50,050
on chokepoints and get more detail

01:04:47,670 --> 01:04:51,730
comprehensive network data including

01:04:50,050 --> 01:04:54,040
inbound and outbound traffic is

01:04:51,730 --> 01:04:55,600
available on the network tab and disk

01:04:54,040 --> 01:04:57,520
rights and free space on the disk

01:04:55,600 --> 01:05:00,370
stabbed while the process Explorer

01:04:57,520 --> 01:05:02,890
displays usage statistics for individual

01:05:00,370 --> 01:05:05,080
processes the system info tab shows

01:05:02,890 --> 01:05:07,300
listening services active connections

01:05:05,080 --> 01:05:09,460
and available updates adding long view

01:05:07,300 --> 01:05:11,140
to a system is easy just click the

01:05:09,460 --> 01:05:13,300
button copy the one line installation

01:05:11,140 --> 01:05:15,730
command then run the command on your

01:05:13,300 --> 01:05:17,440
linux system to complete the process the

01:05:15,730 --> 01:05:19,630
agent will begin collecting data and

01:05:17,440 --> 01:05:21,440
sending it to longview then the graphs

01:05:19,630 --> 01:05:24,020
start rolling

01:05:21,440 --> 01:05:26,390
use longview to gain visibility into

01:05:24,020 --> 01:05:30,099
your servers so when your website or app

01:05:26,390 --> 01:05:30,099
heats up it stays up

01:07:53,460 --> 01:07:57,820
Citrix XenServer gives you everything

01:07:55,660 --> 01:08:00,820
you need to integrate manage and

01:07:57,820 --> 01:08:02,950
automate a virtual data center all on an

01:08:00,820 --> 01:08:05,320
enterprise-class cloud proven virtual

01:08:02,950 --> 01:08:08,080
platform and at a third of the cost of

01:08:05,320 --> 01:08:09,760
other solutions but why even bother with

01:08:08,080 --> 01:08:11,950
virtualizing your server infrastructure

01:08:09,760 --> 01:08:13,900
in the first place well let's say you

01:08:11,950 --> 01:08:16,180
have a traditional one server to one

01:08:13,900 --> 01:08:18,130
application architecture but you're

01:08:16,180 --> 01:08:20,710
running out of resources and performance

01:08:18,130 --> 01:08:23,010
is suffering once you order new server

01:08:20,710 --> 01:08:25,900
hardware you'll wait for delivery

01:08:23,010 --> 01:08:28,780
configure it install your business

01:08:25,900 --> 01:08:31,540
application stage and test the server

01:08:28,780 --> 01:08:33,730
and finally add it to your production

01:08:31,540 --> 01:08:35,950
farm if you've been through this process

01:08:33,730 --> 01:08:38,440
before you know it can take weeks or

01:08:35,950 --> 01:08:40,300
even months you also know it's a

01:08:38,440 --> 01:08:42,280
manually intensive process that will

01:08:40,300 --> 01:08:45,580
burden your team every time you outgrow

01:08:42,280 --> 01:08:47,350
your current setup with a virtual server

01:08:45,580 --> 01:08:50,140
solution you could accomplish all of

01:08:47,350 --> 01:08:52,720
that in less than half a day server

01:08:50,140 --> 01:08:54,550
virtualization software separates the OS

01:08:52,720 --> 01:08:56,980
and application from the underlying

01:08:54,550 --> 01:08:59,109
server hardware and with multiple

01:08:56,980 --> 01:09:00,819
virtual machines on a single server you

01:08:59,109 --> 01:09:03,790
can use each of them to run different

01:09:00,819 --> 01:09:05,589
os's and applications this makes it

01:09:03,790 --> 01:09:07,359
possible to move your virtual machines

01:09:05,589 --> 01:09:09,430
from one piece of hardware to another

01:09:07,359 --> 01:09:11,710
whenever you want to maximize

01:09:09,430 --> 01:09:13,660
utilization simplify maintenance or

01:09:11,710 --> 01:09:15,970
recover from a hardware failure and

01:09:13,660 --> 01:09:19,300
without slowing down your applications

01:09:15,970 --> 01:09:21,970
or users clearly server virtualization

01:09:19,300 --> 01:09:25,000
provides big benefits and Citrix

01:09:21,970 --> 01:09:27,220
XenServer provides even more since it's

01:09:25,000 --> 01:09:29,080
built on an open platform xenserver

01:09:27,220 --> 01:09:31,359
plays well with your existing hardware

01:09:29,080 --> 01:09:33,670
storage systems and IT management

01:09:31,359 --> 01:09:36,400
software as well as with the industry's

01:09:33,670 --> 01:09:38,440
leading cloud service providers best of

01:09:36,400 --> 01:09:40,120
all you can get started by downloading a

01:09:38,440 --> 01:09:43,119
fully functional production-ready

01:09:40,120 --> 01:09:44,769
version of xenserver for free

01:09:43,119 --> 01:09:47,019
after a 10-minute installation process

01:09:44,769 --> 01:09:48,579
you'll see how easy it is to start

01:09:47,019 --> 01:09:50,889
virtualizing your workloads and

01:09:48,579 --> 01:09:53,199
automating your IT management processes

01:09:50,889 --> 01:09:55,209
and when you're ready for a richer set

01:09:53,199 --> 01:09:57,760
of management tools just upgrade to one

01:09:55,209 --> 01:09:58,840
of the premium editions of xenserver so

01:09:57,760 --> 01:10:00,599
whether you're interested in

01:09:58,840 --> 01:10:02,499
virtualizing servers for the first time

01:10:00,599 --> 01:10:05,289
expanding your server virtualization

01:10:02,499 --> 01:10:07,689
footprint or moving server workloads to

01:10:05,289 --> 01:10:09,789
the cloud download and install zend

01:10:07,689 --> 01:10:12,729
server today and see how it can help you

01:10:09,789 --> 01:10:18,059
simplify your IT environment citrix

01:10:12,729 --> 01:10:18,059
xenserver do more don't spend more

01:10:23,260 --> 01:10:25,320
you

01:31:04,190 --> 01:31:06,250

YouTube URL: https://www.youtube.com/watch?v=kneA17vxk-o


