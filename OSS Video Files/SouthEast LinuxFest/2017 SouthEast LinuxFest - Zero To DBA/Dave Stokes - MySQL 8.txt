Title: Dave Stokes - MySQL 8
Publication date: 2018-04-23
Playlist: 2017 SouthEast LinuxFest - Zero To DBA
Description: 
	2017 SouthEast LinuxFest
Zero To DBA
Dave Stokes - MySQL 8
Captions: 
	00:00:00,240 --> 00:00:05,190
the following presentation was recorded

00:00:02,669 --> 00:00:07,980
at the southeast linux fest in charlotte

00:00:05,190 --> 00:00:10,679
north carolina it is licensed under a

00:00:07,980 --> 00:00:12,570
Creative Commons license for more

00:00:10,679 --> 00:00:22,470
information about the south east linux

00:00:12,570 --> 00:00:25,590
fest please visit www.flexsim.com sir to

00:00:22,470 --> 00:00:30,689
helping make these videos possible by

00:00:25,590 --> 00:00:35,610
oracle been working around some last ql

00:00:30,689 --> 00:00:39,870
oracle for god going on 11 years now

00:00:35,610 --> 00:00:41,579
and here's my contact information the

00:00:39,870 --> 00:00:46,590
slides are up at slideshare.net slash

00:00:41,579 --> 00:00:53,840
david m stokes that's my email on my

00:00:46,590 --> 00:00:53,840
twitter handle and the slides inside

00:00:55,340 --> 00:01:00,420
safe harbor agreement oracle wants me to

00:00:58,250 --> 00:01:02,100
let you know that anything that's not

00:01:00,420 --> 00:01:09,090
officially generally available release

00:01:02,100 --> 00:01:10,860
software is anything i say about that

00:01:09,090 --> 00:01:14,070
type of software take with a grain of

00:01:10,860 --> 00:01:17,220
salt we might make revisions changes or

00:01:14,070 --> 00:01:18,270
omissions in the future but the idea is

00:01:17,220 --> 00:01:22,290
to let you know this is what we're

00:01:18,270 --> 00:01:23,850
planning on doing and unless i say it's

00:01:22,290 --> 00:01:25,229
definitely a positive one half percent

00:01:23,850 --> 00:01:27,509
thing to be sure that's going to be

00:01:25,229 --> 00:01:31,049
there take out the grain of salt

00:01:27,509 --> 00:01:32,520
might change just a little bit so for

00:01:31,049 --> 00:01:36,170
those human following rescue out we're

00:01:32,520 --> 00:01:38,310
now 22 years old oracle zone is 4/7

00:01:36,170 --> 00:01:40,890
we're doing very good at oracle by the

00:01:38,310 --> 00:01:42,570
way last go 5 7 is are currently

00:01:40,890 --> 00:01:44,970
generally available release it's been

00:01:42,570 --> 00:01:46,649
out for a year and a half has a lot of

00:01:44,970 --> 00:01:50,759
interesting features like a json data

00:01:46,649 --> 00:01:54,000
type i enhanced security at risk at risk

00:01:50,759 --> 00:01:55,250
at rest encryption and much better

00:01:54,000 --> 00:01:57,420
performance

00:01:55,250 --> 00:01:59,009
we're also decoupling some of our

00:01:57,420 --> 00:02:00,299
features away from the big server

00:01:59,009 --> 00:02:03,090
releases because they're just getting

00:02:00,299 --> 00:02:06,229
too big here I'm talking about the

00:02:03,090 --> 00:02:09,000
document store which allows you to do

00:02:06,229 --> 00:02:11,160
create replace update delete to a

00:02:09,000 --> 00:02:13,830
database without having to actually no

00:02:11,160 --> 00:02:15,270
SQL it's a

00:02:13,830 --> 00:02:17,760
turn out to be very popular feature and

00:02:15,270 --> 00:02:21,300
group replication this is our active

00:02:17,760 --> 00:02:23,160
active master master replication you'll

00:02:21,300 --> 00:02:24,660
also see this paired with some other

00:02:23,160 --> 00:02:27,360
things like mascara router to give you

00:02:24,660 --> 00:02:34,650
high availability by the way we're

00:02:27,360 --> 00:02:36,560
hiring and we're doing very well so we

00:02:34,650 --> 00:02:39,330
announced that we were going to MySQL 8

00:02:36,560 --> 00:02:42,030
the big question for a lot of people was

00:02:39,330 --> 00:02:44,760
what happened to MySQL 6 and what

00:02:42,030 --> 00:02:46,710
happened to MySQL femine well back in

00:02:44,760 --> 00:02:50,610
the pre Sunday so we had a version of

00:02:46,710 --> 00:02:53,910
MySQL 6 like PHP had a version of PHP 6

00:02:50,610 --> 00:02:55,920
I had a lot of neat features but due to

00:02:53,910 --> 00:02:58,860
some political infighting and corporate

00:02:55,920 --> 00:03:00,870
changes and all that 6 never really came

00:02:58,860 --> 00:03:03,440
to fruition and a lot of neat features

00:03:00,870 --> 00:03:07,380
were back ported into the MySQL 5 line

00:03:03,440 --> 00:03:11,040
also the cluster series our high

00:03:07,380 --> 00:03:16,230
availability active active booster

00:03:11,040 --> 00:03:19,620
master geode replicate between separated

00:03:16,230 --> 00:03:21,930
data centers that was using the 7 Series

00:03:19,620 --> 00:03:24,000
still is lots mainly used for these

00:03:21,930 --> 00:03:26,010
things as you move between a cell phone

00:03:24,000 --> 00:03:28,519
tower and cell phone tower your track

00:03:26,010 --> 00:03:31,950
and information is kept in a MySQL NDB

00:03:28,519 --> 00:03:34,500
format database also these are used by a

00:03:31,950 --> 00:03:35,910
lot of big programming online games and

00:03:34,500 --> 00:03:38,850
by the US Navy during carrier your

00:03:35,910 --> 00:03:40,410
flight operations so the engineers

00:03:38,850 --> 00:03:41,790
looked at all these things you wanted to

00:03:40,410 --> 00:03:43,230
do for the next version of MySQL and I

00:03:41,790 --> 00:03:45,200
said you know we're doing enough to

00:03:43,230 --> 00:03:47,190
really call it the next big release

00:03:45,200 --> 00:03:53,400
we're going to call it last few all

00:03:47,190 --> 00:03:56,060
eight as I mentioned current a generally

00:03:53,400 --> 00:03:58,410
available release is Lascaux five seven

00:03:56,060 --> 00:04:01,500
cluster is now seven five four

00:03:58,410 --> 00:04:04,140
and as I mentioned there was a MySQL six

00:04:01,500 --> 00:04:05,519
in the pre Sundays anyway the the big

00:04:04,140 --> 00:04:07,920
feature coming out is a new data

00:04:05,519 --> 00:04:10,950
dictionary and that is enough of a big

00:04:07,920 --> 00:04:15,360
jump that engineering said blow let's

00:04:10,950 --> 00:04:18,000
just call it remember eight so what do I

00:04:15,360 --> 00:04:21,150
mean by data dictionary well if you've

00:04:18,000 --> 00:04:24,000
ever gone to your var Lib MySQL database

00:04:21,150 --> 00:04:26,610
directly and looked under there there's

00:04:24,000 --> 00:04:27,600
a whole bunch of files you'll have one

00:04:26,610 --> 00:04:30,120
directory for every day

00:04:27,600 --> 00:04:33,180
and then under that you'll have a dot of

00:04:30,120 --> 00:04:36,030
a bunch of frm my DS and my eyes o

00:04:33,180 --> 00:04:39,030
peepees whole bunch of other files out

00:04:36,030 --> 00:04:42,900
there these are the metadata for your

00:04:39,030 --> 00:04:47,340
database and in the old days 20 years

00:04:42,900 --> 00:04:49,470
ago if you lost an inode it happened not

00:04:47,340 --> 00:04:50,580
when your database went to heck and we

00:04:49,470 --> 00:04:53,250
had a whole bunch of tools to take care

00:04:50,580 --> 00:04:55,050
of it well over the past couple years we

00:04:53,250 --> 00:04:57,630
realized we don't really need to carry

00:04:55,050 --> 00:05:02,130
all this crud with us we're going to put

00:04:57,630 --> 00:05:06,210
all the metadata into and in order to be

00:05:02,130 --> 00:05:08,520
set of tables and run it that way by the

00:05:06,210 --> 00:05:11,000
way when we did this to our replication

00:05:08,520 --> 00:05:13,500
information our replication logs

00:05:11,000 --> 00:05:16,740
replication stability went way way way

00:05:13,500 --> 00:05:22,140
way up so it's actually a very good

00:05:16,740 --> 00:05:25,500
thing we're doing this the the big

00:05:22,140 --> 00:05:28,080
benefit for most of you is that you can

00:05:25,500 --> 00:05:30,840
now have millions of tables within a

00:05:28,080 --> 00:05:34,140
schema you're no longer tied to the file

00:05:30,840 --> 00:05:37,790
system the bad news is you can now have

00:05:34,140 --> 00:05:37,790
millions of tables within a database

00:05:38,870 --> 00:05:47,040
yeah yeah what could go wrong why would

00:05:45,120 --> 00:05:52,560
you ever need more than 640k to program

00:05:47,040 --> 00:06:09,410
in eccentrics the 8-bit graphics were

00:05:52,560 --> 00:06:17,070
good enough for everyone else yeah yeah

00:06:09,410 --> 00:06:18,900
yeah these the basically the other good

00:06:17,070 --> 00:06:21,810
thing is you'll be able to do alter

00:06:18,900 --> 00:06:25,410
table and add delete columns do whatever

00:06:21,810 --> 00:06:27,930
you want to do and have it take action

00:06:25,410 --> 00:06:31,970
atomically no longer waiting for an hour

00:06:27,930 --> 00:06:33,900
2 hours in the evening a weekend a week

00:06:31,970 --> 00:06:36,630
usually you're fired after a week while

00:06:33,900 --> 00:06:39,620
alter table runs or you haven't used the

00:06:36,630 --> 00:06:41,529
kind of toolkits schema tool to run this

00:06:39,620 --> 00:06:43,839
so

00:06:41,529 --> 00:06:46,179
that will probably be the most dramatic

00:06:43,839 --> 00:06:49,479
change you'll see with MySQL 8 although

00:06:46,179 --> 00:06:56,969
if you're just a tertiary user you may

00:06:49,479 --> 00:07:00,309
not actually see that five years ago I

00:06:56,969 --> 00:07:01,479
think it wasn't this no I don't think I

00:07:00,309 --> 00:07:05,079
was in this room I think was over with

00:07:01,479 --> 00:07:06,519
the Drake Hotel Oh God you were who have

00:07:05,079 --> 00:07:09,309
been here difficult to the show before

00:07:06,519 --> 00:07:11,109
and remember the Drake Hotel you're

00:07:09,309 --> 00:07:14,049
wincing a little bit

00:07:11,109 --> 00:07:16,119
I was asked when was MySQL gonna have Ct

00:07:14,049 --> 00:07:18,759
ease and windowing functions by doctor

00:07:16,119 --> 00:07:21,849
hip of equal light well I'd like to say

00:07:18,759 --> 00:07:22,989
we're finally going to have them common

00:07:21,849 --> 00:07:28,629
table expressions and windowing

00:07:22,989 --> 00:07:32,289
functions have a lot of X uses awesome

00:07:28,629 --> 00:07:35,139
examples here CTS are handy sub-query

00:07:32,289 --> 00:07:36,839
like statements before my co 5/7 and

00:07:35,139 --> 00:07:40,749
some curries weren't really handled well

00:07:36,839 --> 00:07:43,509
with MySQL 8 we're doing a lot of things

00:07:40,749 --> 00:07:45,119
in temporary tables that are much more

00:07:43,509 --> 00:07:50,829
efficient so we're able to finally get

00:07:45,119 --> 00:07:53,139
CPS and windowing function is working so

00:07:50,829 --> 00:07:55,809
what is it windowing function well the

00:07:53,139 --> 00:07:58,689
key word in a sequel statement is you'll

00:07:55,809 --> 00:08:01,209
see over and here we're selecting name

00:07:58,689 --> 00:08:03,729
Department ID salary and adding up

00:08:01,209 --> 00:08:05,079
salary over our partition and here the

00:08:03,729 --> 00:08:08,499
partition is going to be the department

00:08:05,079 --> 00:08:09,519
ID and then for every grouping of that

00:08:08,499 --> 00:08:15,939
you're going to have a departmental

00:08:09,519 --> 00:08:18,309
total so this lets you do sort of pivot

00:08:15,939 --> 00:08:20,319
table ish like stuff from your

00:08:18,309 --> 00:08:23,289
information without having to try to

00:08:20,319 --> 00:08:28,239
seven and a third party tool to do that

00:08:23,289 --> 00:08:30,369
type of work a lot of folks who are used

00:08:28,239 --> 00:08:32,199
to using this from say like sequel

00:08:30,369 --> 00:08:35,110
server will tell you this has a

00:08:32,199 --> 00:08:37,089
gazillion uses unfortunately I grew up

00:08:35,110 --> 00:08:39,219
without this in my databasing background

00:08:37,089 --> 00:08:42,719
so I really am not the expert on this

00:08:39,219 --> 00:08:42,719
I'm fully getting there

00:08:50,410 --> 00:08:53,529
sort of like a group by kind of okay

00:08:52,120 --> 00:08:57,610
here we're going to take every

00:08:53,529 --> 00:09:00,069
department ID and and use that as our

00:08:57,610 --> 00:09:01,540
partitioning thing unfortunately it's

00:09:00,069 --> 00:09:03,190
going to get confused with the data

00:09:01,540 --> 00:09:05,290
partitioning where you chop up your data

00:09:03,190 --> 00:09:12,670
into different sub groups and put them

00:09:05,290 --> 00:09:15,189
on different disk drives so so this

00:09:12,670 --> 00:09:16,540
example of a windowing function is

00:09:15,189 --> 00:09:17,680
probably not the best one out there but

00:09:16,540 --> 00:09:19,089
it's the only one I can find that that

00:09:17,680 --> 00:09:22,509
was clear enough for a simple

00:09:19,089 --> 00:09:23,980
explanation but the idea is you can't

00:09:22,509 --> 00:09:25,269
kind of do a group by but this is

00:09:23,980 --> 00:09:26,949
supposed to be a little more efficient

00:09:25,269 --> 00:09:31,660
and you don't have to do the roll-ups

00:09:26,949 --> 00:09:34,899
and all the other stuff here's another

00:09:31,660 --> 00:09:36,670
example a windowing function we're

00:09:34,899 --> 00:09:39,910
selecting data mount some of you mouse

00:09:36,670 --> 00:09:42,730
over which is again of the keyword from

00:09:39,910 --> 00:09:45,970
payments and what we do is we window it

00:09:42,730 --> 00:09:49,110
where we go for every date and we have a

00:09:45,970 --> 00:09:52,449
range of one week preceding in one week

00:09:49,110 --> 00:09:54,209
or we proceed what we're doing now so

00:09:52,449 --> 00:10:00,300
you can actually go out and get

00:09:54,209 --> 00:10:00,300
breakdowns of who's paying what when

00:10:03,779 --> 00:10:07,360
it's supposed to be easy to read for

00:10:05,860 --> 00:10:10,630
most people I grew up doing that in a

00:10:07,360 --> 00:10:12,850
where class but the the idea is you have

00:10:10,630 --> 00:10:16,560
these little windows in here data and if

00:10:12,850 --> 00:10:18,579
you're doing data warehousing type stuff

00:10:16,560 --> 00:10:21,310
you're breaking down customer shipment

00:10:18,579 --> 00:10:23,740
by quarters you'd be able to get that

00:10:21,310 --> 00:10:26,110
more easily than having to do played

00:10:23,740 --> 00:10:31,660
eight games with it you just kinda give

00:10:26,110 --> 00:10:35,139
it the interval in a way it goes now

00:10:31,660 --> 00:10:37,449
common table expressions use the with

00:10:35,139 --> 00:10:38,829
keyword so if you see a sequel statement

00:10:37,449 --> 00:10:43,059
starting with with you automatically

00:10:38,829 --> 00:10:45,399
know it's a tte and they're like derive

00:10:43,059 --> 00:10:47,079
tables but the declaration is before the

00:10:45,399 --> 00:10:48,970
query so if you're used to sub queries

00:10:47,079 --> 00:10:51,790
where you have your main query than the

00:10:48,970 --> 00:10:53,709
sub query underneath flip it around with

00:10:51,790 --> 00:10:57,579
the sub query at the top give that an

00:10:53,709 --> 00:11:01,059
alias and then fetch from that so here

00:10:57,579 --> 00:11:03,850
we have with something we're calling Q n

00:11:01,059 --> 00:11:06,279
for query n and finding that

00:11:03,850 --> 00:11:12,850
select key one from a table and then you

00:11:06,279 --> 00:11:16,449
do the select from QM it's very similar

00:11:12,850 --> 00:11:19,420
to a view and once again I grew up

00:11:16,449 --> 00:11:24,819
without this I'm not the most person

00:11:19,420 --> 00:11:25,630
with these now here's a an example of a

00:11:24,819 --> 00:11:28,540
recursive

00:11:25,630 --> 00:11:31,930
CTE where we're actually selecting the

00:11:28,540 --> 00:11:34,720
number one and then we go through and we

00:11:31,930 --> 00:11:47,920
actually add up from one to ten and you

00:11:34,720 --> 00:11:50,199
know that together and call it in yeah

00:11:47,920 --> 00:11:52,569
I'm I'm just waiting for someone to try

00:11:50,199 --> 00:11:55,680
to introduce the sequence that way I

00:11:52,569 --> 00:11:55,680
don't see how that breaks

00:11:57,870 --> 00:12:07,509
well our optimizer and parser team are

00:12:01,600 --> 00:12:09,550
very heavily driven engineers they have

00:12:07,509 --> 00:12:10,360
a way they want to see the world and

00:12:09,550 --> 00:12:13,089
they're finally getting to the point

00:12:10,360 --> 00:12:18,130
where they're getting there in the past

00:12:13,089 --> 00:12:21,550
if you specified a descending index we

00:12:18,130 --> 00:12:24,399
cheated we actually had an ascending

00:12:21,550 --> 00:12:27,279
index for you and then pulled some

00:12:24,399 --> 00:12:30,000
strings behind the scenes to make it

00:12:27,279 --> 00:12:32,259
look like it's a true be sending index

00:12:30,000 --> 00:12:34,149
as you can probably imagine all those

00:12:32,259 --> 00:12:37,750
are dirty tricks that they were doing

00:12:34,149 --> 00:12:39,310
cause you performance time losses so we

00:12:37,750 --> 00:12:42,939
fixed that you have a true descending

00:12:39,310 --> 00:12:44,410
index also the optimizer trace now has

00:12:42,939 --> 00:12:48,699
more information about file store

00:12:44,410 --> 00:12:51,970
operations such as key sizes and payload

00:12:48,699 --> 00:12:53,980
sizes and why some things are arranged

00:12:51,970 --> 00:12:57,069
the way they are this means the

00:12:53,980 --> 00:12:58,600
optimizer is a lot smarter it won't

00:12:57,069 --> 00:13:01,389
throw it out to a file sort if it knows

00:12:58,600 --> 00:13:05,350
I can use an index that will speed

00:13:01,389 --> 00:13:08,560
things up also you can give it hints use

00:13:05,350 --> 00:13:13,230
this index over that you just collation

00:13:08,560 --> 00:13:16,029
over this makes things a lot easier also

00:13:13,230 --> 00:13:17,860
we have a new variable a lot to keep

00:13:16,029 --> 00:13:20,980
track of records that

00:13:17,860 --> 00:13:22,329
deleted by another user so as it goes

00:13:20,980 --> 00:13:24,399
through to figure out how to run your

00:13:22,329 --> 00:13:25,510
query and it goes through and said oh

00:13:24,399 --> 00:13:29,589
this person's going out and believe

00:13:25,510 --> 00:13:30,880
those records I'm gonna go with the new

00:13:29,589 --> 00:13:33,390
information rather than all the

00:13:30,880 --> 00:13:35,800
statistics I had and when that person

00:13:33,390 --> 00:13:39,220
terminates and rolls back their

00:13:35,800 --> 00:13:43,890
information your query plan is trash but

00:13:39,220 --> 00:13:43,890
their server will try to run it that way

00:13:44,640 --> 00:13:50,940
also on select statements you can do a

00:13:47,829 --> 00:13:54,209
select no wait or a select skip to lock

00:13:50,940 --> 00:13:56,410
lock to bypass records that are locked

00:13:54,209 --> 00:13:58,269
so if you have something you have to get

00:13:56,410 --> 00:13:59,649
done and you know that there's gonna be

00:13:58,269 --> 00:14:00,970
some records out there you may not touch

00:13:59,649 --> 00:14:05,279
and you have a way to go back and get

00:14:00,970 --> 00:14:05,279
them that's gonna make life a lot easier

00:14:05,459 --> 00:14:12,720
we're also interesting a rolls rolls are

00:14:09,190 --> 00:14:16,060
a collection of privileges and grants

00:14:12,720 --> 00:14:18,070
for a certain function so if you're

00:14:16,060 --> 00:14:20,440
adding a new accountant and you have an

00:14:18,070 --> 00:14:22,000
accounting rule now you sign them that

00:14:20,440 --> 00:14:24,120
and they get all the privileges and

00:14:22,000 --> 00:14:29,320
grants needed to do the accounting work

00:14:24,120 --> 00:14:31,089
if you have a a QA person and you want

00:14:29,320 --> 00:14:34,870
them only locked down to the test

00:14:31,089 --> 00:14:37,480
instances you can set that up to now the

00:14:34,870 --> 00:14:39,640
great news about this is Billy from

00:14:37,480 --> 00:14:42,370
accountant counting goes off on a

00:14:39,640 --> 00:14:45,850
six-month sabbatical you flag his

00:14:42,370 --> 00:14:47,199
account is inactive but someone else

00:14:45,850 --> 00:14:48,820
comes along and they're making Billy's

00:14:47,199 --> 00:14:51,190
job you don't have to give him Billy's

00:14:48,820 --> 00:14:53,110
account you say ok build a role like

00:14:51,190 --> 00:14:55,480
Billy and they have the same privileges

00:14:53,110 --> 00:14:57,220
and when Billy comes back you give him

00:14:55,480 --> 00:14:59,350
back his old privileges and everything's

00:14:57,220 --> 00:15:01,510
hunky-dory so you now have a way of

00:14:59,350 --> 00:15:05,730
saying ok let's class the user is the

00:15:01,510 --> 00:15:05,730
set of rights do what they need to do

00:15:24,120 --> 00:15:28,600
hopefully unfortunately a lot of

00:15:27,250 --> 00:15:30,010
projects and well we'll just run

00:15:28,600 --> 00:15:31,750
everything is rooted in the way we go

00:15:30,010 --> 00:15:40,899
and never never worry about it

00:15:31,750 --> 00:15:44,470
oh yeah concern with we can lock down to

00:15:40,899 --> 00:15:47,529
the column for read privileges now or

00:15:44,470 --> 00:16:06,370
update privilege should be able to get

00:15:47,529 --> 00:16:07,959
more of this yes sir yeah now that's why

00:16:06,370 --> 00:16:10,779
a lot of people view used views before

00:16:07,959 --> 00:16:13,240
we say this view runs as issues there

00:16:10,779 --> 00:16:14,560
with the set of privileges but hopefully

00:16:13,240 --> 00:16:16,839
with rules we'll be able to make this a

00:16:14,560 --> 00:16:17,800
little more flexible say okay there's an

00:16:16,839 --> 00:16:19,509
accounting group

00:16:17,800 --> 00:16:26,500
this is accounting information they

00:16:19,509 --> 00:16:28,000
should see all this so knock on wood if

00:16:26,500 --> 00:16:29,949
you don't have permission to read a call

00:16:28,000 --> 00:16:46,509
the others back and so if you don't have

00:16:29,949 --> 00:16:48,339
permission to read this column I'd have

00:16:46,509 --> 00:16:50,529
to check the index code because I'm not

00:16:48,339 --> 00:16:52,029
sure if the index carries the same

00:16:50,529 --> 00:16:59,250
permission of the actual column but it

00:16:52,029 --> 00:16:59,250
should so I'll do don't take a look at

00:16:59,519 --> 00:17:06,250
as I mentioned earlier all the system

00:17:02,319 --> 00:17:08,069
tables are now in in ODB previously

00:17:06,250 --> 00:17:15,880
these are all in my I Sam

00:17:08,069 --> 00:17:17,260
non-transactional so technically you'd

00:17:15,880 --> 00:17:23,799
have several people updating user

00:17:17,260 --> 00:17:26,049
information at the same time which it

00:17:23,799 --> 00:17:33,059
has potential it has potential to blow

00:17:26,049 --> 00:17:33,059
up in your face so be careful oh yeah

00:17:36,640 --> 00:17:39,760
the trouble with ORM is you're always

00:17:38,559 --> 00:17:42,029
adding at least two layers of

00:17:39,760 --> 00:17:44,860
abstraction whenever you use one and

00:17:42,029 --> 00:17:48,519
usually it's faster if you just learn to

00:17:44,860 --> 00:17:51,370
write SQL in the original place it's

00:17:48,519 --> 00:17:54,760
also a less lessens the lawyer

00:17:51,370 --> 00:17:58,000
complexity but here we're just talking

00:17:54,760 --> 00:18:01,600
about the system tables especially the

00:17:58,000 --> 00:18:12,389
proof tables multiple people being able

00:18:01,600 --> 00:18:12,389
to play with them at the same time yes

00:18:13,529 --> 00:18:17,289
yeah and whatever thing I'm talking

00:18:15,760 --> 00:18:19,179
about unless I explicitly say this is

00:18:17,289 --> 00:18:24,279
the enterprise only just the community

00:18:19,179 --> 00:18:26,799
version well big change will probably

00:18:24,279 --> 00:18:33,340
get most of you is MySQL eight will you

00:18:26,799 --> 00:18:35,500
be will be utf-8 and B for now fifteen

00:18:33,340 --> 00:18:37,809
years ago I used to compile my my asked

00:18:35,500 --> 00:18:40,750
you all to use only Latin one it's a one

00:18:37,809 --> 00:18:42,340
bit character set without a lot of

00:18:40,750 --> 00:18:44,019
relations of different character sets

00:18:42,340 --> 00:18:47,740
that actually ran marginally faster or

00:18:44,019 --> 00:18:50,230
smaller memory footprint great well why

00:18:47,740 --> 00:18:51,730
is that changed 15 years later well

00:18:50,230 --> 00:18:56,470
because everyone wants to put the poop

00:18:51,730 --> 00:18:58,510
emoji in their data someplace and to do

00:18:56,470 --> 00:19:02,019
that fully and it gets the port for all

00:18:58,510 --> 00:19:05,950
the Oriental languages we need UTF and B

00:19:02,019 --> 00:19:08,080
for also people jumping on the JSON

00:19:05,950 --> 00:19:11,470
bandwagon will tell you that everything

00:19:08,080 --> 00:19:15,269
has to be you TFM before so to make life

00:19:11,470 --> 00:19:18,909
easier for us everything's going to be

00:19:15,269 --> 00:19:22,840
utf-8 MD for which I will not be able to

00:19:18,909 --> 00:19:25,929
see every three drinks previously our

00:19:22,840 --> 00:19:28,120
utf-8 was three bytes and so three byes

00:19:25,929 --> 00:19:30,899
sorry about that

00:19:28,120 --> 00:19:34,090
so that didn't mean that meant no emojis

00:19:30,899 --> 00:19:37,510
also the Supplemental multi lingual

00:19:34,090 --> 00:19:39,760
plane support was kind of weak and we

00:19:37,510 --> 00:19:42,279
did have a lot of support for the

00:19:39,760 --> 00:19:44,830
Chinese Japanese Korean video graph

00:19:42,279 --> 00:19:47,770
extensions but they're all in and before

00:19:44,830 --> 00:19:49,360
rather than this before also MySQL so

00:19:47,770 --> 00:19:50,179
far as I know is also the only database

00:19:49,360 --> 00:19:52,820
that supports the

00:19:50,179 --> 00:19:57,499
dat no 30 character set which is the

00:19:52,820 --> 00:19:59,419
official character set for China so if

00:19:57,499 --> 00:20:01,730
you're saying me how does it start off

00:19:59,419 --> 00:20:04,669
after your conversations you're gonna

00:20:01,730 --> 00:20:08,840
wanna switch to that the other thing

00:20:04,669 --> 00:20:11,629
with you TF is as in the past we've

00:20:08,840 --> 00:20:14,990
always had case insensitive in case

00:20:11,629 --> 00:20:19,190
sensitive collation of data you're also

00:20:14,990 --> 00:20:21,919
going to now have a accent insensitive

00:20:19,190 --> 00:20:24,019
version of the same thing so instead of

00:20:21,919 --> 00:20:25,879
just case sensitive case insensitive now

00:20:24,019 --> 00:20:32,690
you're going to have accent sensitive

00:20:25,879 --> 00:20:33,950
and insensitive invisible index first

00:20:32,690 --> 00:20:35,659
time I heard of this feature it kind of

00:20:33,950 --> 00:20:41,289
made me wonder what they were talking

00:20:35,659 --> 00:20:45,169
about when you're profiling a MySQL

00:20:41,289 --> 00:20:47,059
query the traditional way to see what

00:20:45,169 --> 00:20:50,840
the optimizer wants to do is put the

00:20:47,059 --> 00:20:51,889
word explain and from that query and it

00:20:50,840 --> 00:20:53,749
cuts back with a whole bunch of

00:20:51,889 --> 00:20:56,629
information tells you what indexes at

00:20:53,749 --> 00:20:59,360
once well sometimes you don't know if

00:20:56,629 --> 00:21:01,360
that index is helping you or not and

00:20:59,360 --> 00:21:04,100
what you could do is delete that index

00:21:01,360 --> 00:21:05,899
run explain on that query again and find

00:21:04,100 --> 00:21:07,850
out yes that is a very valuable index

00:21:05,899 --> 00:21:11,570
and then spend all weekend rebuilding

00:21:07,850 --> 00:21:14,419
that index what we've done with eight is

00:21:11,570 --> 00:21:16,909
you can now type alter index that

00:21:14,419 --> 00:21:19,940
another invisible and suddenly the

00:21:16,909 --> 00:21:21,499
optimizer cannot see that so you run

00:21:19,940 --> 00:21:25,070
your explain and it comes you can

00:21:21,499 --> 00:21:26,899
compare the before and after results to

00:21:25,070 --> 00:21:30,619
see if your query plan is any better for

00:21:26,899 --> 00:21:33,610
you if it is maybe you blow away that

00:21:30,619 --> 00:21:36,529
query or that index

00:21:33,610 --> 00:21:43,789
maybe you don't but this gives you a way

00:21:36,529 --> 00:21:50,049
to definitively test for how many were

00:21:43,789 --> 00:21:50,049
running my skill in the cloud who is it

00:21:51,639 --> 00:21:55,070
what what happens in the cloud

00:21:53,450 --> 00:21:57,200
environments or environments where you

00:21:55,070 --> 00:22:00,190
have lots of people adjusting the server

00:21:57,200 --> 00:22:02,330
is that someone changes the variable

00:22:00,190 --> 00:22:04,070
someone else changes is another variable

00:22:02,330 --> 00:22:06,770
and then reboot

00:22:04,070 --> 00:22:09,170
comes six weeks eight weeks six months a

00:22:06,770 --> 00:22:11,300
year later and things run like heck and

00:22:09,170 --> 00:22:12,620
you can't figure out why I remember

00:22:11,300 --> 00:22:14,180
changing your variable you know I

00:22:12,620 --> 00:22:15,890
changed I very well what did you change

00:22:14,180 --> 00:22:19,490
I don't remember what did you change it

00:22:15,890 --> 00:22:23,780
to I don't remember well with set

00:22:19,490 --> 00:22:26,590
persist it will take that change and it

00:22:23,780 --> 00:22:32,210
will write it out there to a log file a

00:22:26,590 --> 00:22:36,350
dot CNF file which we call mysqld Otto

00:22:32,210 --> 00:22:38,540
and the information is out there so when

00:22:36,350 --> 00:22:41,510
the server reboots it knows that this

00:22:38,540 --> 00:22:45,440
change was made and implements it also

00:22:41,510 --> 00:22:47,210
logs who did it and at what time so if

00:22:45,440 --> 00:22:49,010
you're changing something at 8 a.m. in

00:22:47,210 --> 00:22:50,510
the morning to get better performance in

00:22:49,010 --> 00:23:00,500
the night shift comes in they change it

00:22:50,510 --> 00:23:01,970
back you can actually track that down as

00:23:00,500 --> 00:23:03,890
I mentioned earlier we realized the

00:23:01,970 --> 00:23:06,020
server releases by themselves are

00:23:03,890 --> 00:23:08,150
getting larger and larger and larger and

00:23:06,020 --> 00:23:13,130
it's getting harder and harder to

00:23:08,150 --> 00:23:15,440
swallow the elephant one pipe we also

00:23:13,130 --> 00:23:17,270
know that there's a lot of stuff in the

00:23:15,440 --> 00:23:19,730
cloud that you can actually go change

00:23:17,270 --> 00:23:21,950
the major release number or the minor

00:23:19,730 --> 00:23:23,540
release number so what we're doing is

00:23:21,950 --> 00:23:27,830
we're decoupling a lot of our features

00:23:23,540 --> 00:23:30,620
and making them plugins so you as root

00:23:27,830 --> 00:23:33,530
or some other super privilege user go in

00:23:30,620 --> 00:23:38,600
install a shared object boom that new

00:23:33,530 --> 00:23:42,880
feature is working now we've done this

00:23:38,600 --> 00:23:48,740
with group replication document store

00:23:42,880 --> 00:23:52,250
our handler socket type thing that we

00:23:48,740 --> 00:23:54,470
call forget the name but it actually

00:23:52,250 --> 00:23:55,520
writes straight to the inner DB data

00:23:54,470 --> 00:23:58,760
store without going through the

00:23:55,520 --> 00:24:00,380
optimizer and Parsons SQL so if you have

00:23:58,760 --> 00:24:03,650
any of you ever see our new software

00:24:00,380 --> 00:24:04,700
coming out and we're trying to make

00:24:03,650 --> 00:24:06,920
things more modular

00:24:04,700 --> 00:24:08,510
be advised we'll try it on the current

00:24:06,920 --> 00:24:10,250
release by just installing the plug-in

00:24:08,510 --> 00:24:14,020
but we're trying to make things much

00:24:10,250 --> 00:24:14,020
more modular than they are currently I

00:24:14,620 --> 00:24:18,880
love that quote from Governor

00:24:16,640 --> 00:24:18,880
Schwarzenegger

00:24:21,220 --> 00:24:29,300
well up until five six and five seven

00:24:24,800 --> 00:24:30,650
our GIS sport was pretty bad and as I

00:24:29,300 --> 00:24:32,690
told Jim earlier I had some friends and

00:24:30,650 --> 00:24:35,210
said hey once you guys get to 2d support

00:24:32,690 --> 00:24:38,450
will done post GIS and go over to MySQL

00:24:35,210 --> 00:24:42,250
totally well with five seven we had 2d

00:24:38,450 --> 00:24:46,270
support and it works pretty good

00:24:42,250 --> 00:24:48,920
unfortunately we live in a 3d world so

00:24:46,270 --> 00:24:52,100
by working with the boost geometry folks

00:24:48,920 --> 00:24:58,460
and open gid we're going to be able to

00:24:52,100 --> 00:24:59,690
give you a world that is curved and the

00:24:58,460 --> 00:25:04,220
current recording system will wrap

00:24:59,690 --> 00:25:07,610
around and you'll be able to say okay

00:25:04,220 --> 00:25:09,260
I'm at location X within three miles of

00:25:07,610 --> 00:25:13,700
me where's all the pizza joints where's

00:25:09,260 --> 00:25:17,390
all the ATMs you know whatever else I

00:25:13,700 --> 00:25:19,370
want to be able to do so this work is

00:25:17,390 --> 00:25:22,190
going to be done at the nodb

00:25:19,370 --> 00:25:24,770
storage engine layer not at the top

00:25:22,190 --> 00:25:26,059
level last QL server layer so we're

00:25:24,770 --> 00:25:28,880
pushing down a lot of that work down to

00:25:26,059 --> 00:25:37,580
the storage engine which should make it

00:25:28,880 --> 00:25:38,690
more efficient and quicker for you one

00:25:37,580 --> 00:25:41,270
of the reasons a lot of folks have

00:25:38,690 --> 00:25:45,740
switched to MySQL five seven has been

00:25:41,270 --> 00:25:48,679
the JSON column type previously for 578

00:25:45,740 --> 00:25:50,900
store JSON data in a text string then I

00:25:48,679 --> 00:25:52,250
troubles you couldn't do stuff with it

00:25:50,900 --> 00:25:53,690
in place you couldn't update you

00:25:52,250 --> 00:25:56,240
couldn't delete you can search for

00:25:53,690 --> 00:25:58,490
certain things without using reg X's and

00:25:56,240 --> 00:26:00,860
there it was pretty nasty

00:25:58,490 --> 00:26:03,170
well five-sevenths been very popular a

00:26:00,860 --> 00:26:05,510
lot of developers of demand switches

00:26:03,170 --> 00:26:06,740
over switch over to it so companies have

00:26:05,510 --> 00:26:10,370
upgraded to five something to get to the

00:26:06,740 --> 00:26:12,559
JSON column now as more and more people

00:26:10,370 --> 00:26:16,940
use it we start realizing that there is

00:26:12,559 --> 00:26:18,950
a need for shortcuts when you pull

00:26:16,940 --> 00:26:23,450
something from a JSON column it usually

00:26:18,950 --> 00:26:26,240
comes out in quotes so we came up with

00:26:23,450 --> 00:26:31,250
an arrow operator to let you do JSON

00:26:26,240 --> 00:26:33,380
the stuff in blue words this JSON

00:26:31,250 --> 00:26:36,680
direct my column if you go down the

00:26:33,380 --> 00:26:38,810
second line you can see my column arrow

00:26:36,680 --> 00:26:39,980
operator dollar drop my path dollars

00:26:38,810 --> 00:26:43,490
feel like a hero operator for the

00:26:39,980 --> 00:26:45,880
current document my path is the object

00:26:43,490 --> 00:26:49,670
you're searching for well we now have a

00:26:45,880 --> 00:26:51,080
double arrow operator that Inc that

00:26:49,670 --> 00:26:52,040
pulls the quotes off that so you don't

00:26:51,080 --> 00:26:59,770
have to strip it off with some other

00:26:52,040 --> 00:27:03,920
program we also came up with a

00:26:59,770 --> 00:27:07,610
beautifier for JSON if you have heavily

00:27:03,920 --> 00:27:10,340
nested JSON data it gets very messy to

00:27:07,610 --> 00:27:12,080
read on a command-line so we actually

00:27:10,340 --> 00:27:13,970
have a JSON owners who are pretty

00:27:12,080 --> 00:27:21,950
command it goes through and beautifies

00:27:13,970 --> 00:27:28,810
it you can also aggregate arrays so if

00:27:21,950 --> 00:27:32,270
you know you have some data here we have

00:27:28,810 --> 00:27:34,400
select column from t1 you can see that

00:27:32,270 --> 00:27:37,100
we have one record starts with t1 and

00:27:34,400 --> 00:27:39,260
other one starts with key a and here

00:27:37,100 --> 00:27:42,740
we'll actually aggregate all that

00:27:39,260 --> 00:27:43,880
information and put it into an array if

00:27:42,740 --> 00:27:45,020
you're not used to playing with JSON

00:27:43,880 --> 00:27:46,220
through either Messick if you have a

00:27:45,020 --> 00:27:49,040
raise with an object you can have

00:27:46,220 --> 00:27:51,140
objects within its arrays it's kind of a

00:27:49,040 --> 00:27:54,140
who's on fruits situation it gets very

00:27:51,140 --> 00:27:56,320
messy but if you have a bunch of data

00:27:54,140 --> 00:28:00,830
you need to output in an array format

00:27:56,320 --> 00:28:03,620
this will do it for you and of course we

00:28:00,830 --> 00:28:10,060
have the object routing or analogue of

00:28:03,620 --> 00:28:13,820
that where we have the information and I

00:28:10,060 --> 00:28:16,240
you know row of data here we have a

00:28:13,820 --> 00:28:19,850
probably an integer and then the JSON

00:28:16,240 --> 00:28:22,220
column and we have an ID of 1 and 2 for

00:28:19,850 --> 00:28:25,550
the integers and we say ok we're going

00:28:22,220 --> 00:28:27,950
to make a object aggregating all the

00:28:25,550 --> 00:28:31,460
information from key 1 and we get it out

00:28:27,950 --> 00:28:32,840
all a lot in one object unless you're

00:28:31,460 --> 00:28:33,950
doing a lot of processing with JSON

00:28:32,840 --> 00:28:35,960
that's probably not gonna make you go

00:28:33,950 --> 00:28:38,260
wow if you are that saves you a lot of

00:28:35,960 --> 00:28:38,260
time

00:28:42,640 --> 00:28:50,060
so let's create a table called J table

00:28:47,240 --> 00:28:53,090
it has one column in it of type JSON and

00:28:50,060 --> 00:28:59,420
into that J table we insert the data see

00:28:53,090 --> 00:29:01,910
there on the second bolded line and then

00:28:59,420 --> 00:29:05,120
we come out we say okay how much

00:29:01,910 --> 00:29:07,850
information in there now right now the

00:29:05,120 --> 00:29:09,980
way it's written your limitation is the

00:29:07,850 --> 00:29:11,510
maximum packet size into the MySQL

00:29:09,980 --> 00:29:13,580
server

00:29:11,510 --> 00:29:15,830
you heard the thing of 10 pounds of

00:29:13,580 --> 00:29:18,140
you-know-what and a five-pound sack well

00:29:15,830 --> 00:29:21,170
the the choke point here is actually the

00:29:18,140 --> 00:29:24,290
network packet going through there and

00:29:21,170 --> 00:29:27,970
ironically you can actually have a JSON

00:29:24,290 --> 00:29:29,930
document in memory larger than that size

00:29:27,970 --> 00:29:31,430
unfortunately to write it out to disk

00:29:29,930 --> 00:29:33,440
and store it that's gonna have to be

00:29:31,430 --> 00:29:36,890
that size that size is roughly a

00:29:33,440 --> 00:29:38,900
gigabyte once again I know gigabyte it's

00:29:36,890 --> 00:29:40,430
big but as I said earlier we used to be

00:29:38,900 --> 00:29:43,280
told you they need more than 640 K to

00:29:40,430 --> 00:29:47,090
program in by the way if you need more

00:29:43,280 --> 00:29:51,620
than I gigabyte JSON data two columns of

00:29:47,090 --> 00:29:53,990
JSON data or more that unfortunate

00:29:51,620 --> 00:29:57,890
that's not always obvious so we've had a

00:29:53,990 --> 00:30:00,590
couple of supporting functions JSON

00:29:57,890 --> 00:30:02,090
storage size and JSON storage free to

00:30:00,590 --> 00:30:03,620
tell you how much you're consuming and

00:30:02,090 --> 00:30:06,860
how much you're freeing up as you do

00:30:03,620 --> 00:30:09,440
various operations at this point I don't

00:30:06,860 --> 00:30:10,670
expect a lot of people of using this two

00:30:09,440 --> 00:30:14,030
years from now I'm sure I'm gonna have

00:30:10,670 --> 00:30:16,970
someone saying well I've got all my my

00:30:14,030 --> 00:30:18,830
friends and my emojis and I'm trying to

00:30:16,970 --> 00:30:20,360
save it out there but it's telling me

00:30:18,830 --> 00:30:28,550
it's too big how do I can find out how

00:30:20,360 --> 00:30:31,730
big it really is what's the so please go

00:30:28,550 --> 00:30:35,120
out and test this today it's available

00:30:31,730 --> 00:30:38,600
for Windows Linux Macs

00:30:35,120 --> 00:30:41,060
also the source code is out there and

00:30:38,600 --> 00:30:42,290
this is all the community version if you

00:30:41,060 --> 00:30:43,430
want to just the enterprise version I

00:30:42,290 --> 00:30:45,680
don't know who the enterprise version

00:30:43,430 --> 00:30:48,440
have this out for test right now

00:30:45,680 --> 00:30:54,350
download it retires if you find a book

00:30:48,440 --> 00:30:56,070
please submit a bug report if you don't

00:30:54,350 --> 00:30:58,619
really want to

00:30:56,070 --> 00:31:00,779
maybe want to try one or two things with

00:30:58,619 --> 00:31:06,590
it you go out and get docker images

00:31:00,779 --> 00:31:08,820
where vagrant issue vagrant or

00:31:06,590 --> 00:31:16,759
VirtualBox images of it and play with it

00:31:08,820 --> 00:31:19,139
now well one of my counterparts from the

00:31:16,759 --> 00:31:21,899
surfer team actually has gone out there

00:31:19,139 --> 00:31:24,600
and created the unofficial masculine guy

00:31:21,899 --> 00:31:26,909
where he goes into lots of details about

00:31:24,600 --> 00:31:30,419
everything I've been high I've just been

00:31:26,909 --> 00:31:33,330
highlighting today good details on how

00:31:30,419 --> 00:31:36,539
the server architecture is changing with

00:31:33,330 --> 00:31:38,340
the data dictionary so if you want to

00:31:36,539 --> 00:31:40,580
see how they're doing Atomics ultra

00:31:38,340 --> 00:31:44,460
tables he goes into details about that

00:31:40,580 --> 00:31:48,119
also be plus tree indexes MySQL fishes

00:31:44,460 --> 00:31:49,859
use be tree indexes but be trees you're

00:31:48,119 --> 00:31:53,609
coming in for some things like a lot of

00:31:49,859 --> 00:31:56,629
the GIS information I talked about the

00:31:53,609 --> 00:31:58,619
changes in explain and optimizer trace

00:31:56,629 --> 00:32:01,470
we're also making changes to the

00:31:58,619 --> 00:32:03,840
optimizer all the way - qaul here's out

00:32:01,470 --> 00:32:05,549
how to best run a query is it goes

00:32:03,840 --> 00:32:08,759
through statistics and figures out ok

00:32:05,549 --> 00:32:10,499
it's gonna cost me X to get where to get

00:32:08,759 --> 00:32:13,679
this information it's like a GI it's

00:32:10,499 --> 00:32:17,340
like a GPS in your car the only trouble

00:32:13,679 --> 00:32:19,470
is as you know if you've a run into a

00:32:17,340 --> 00:32:21,389
traffic jam it's just 20 minutes down

00:32:19,470 --> 00:32:23,340
the road according your GPS traffic jam

00:32:21,389 --> 00:32:24,299
is reality you have an hour wait before

00:32:23,340 --> 00:32:26,190
you even get to the part where it's

00:32:24,299 --> 00:32:28,080
starting to count the 20 minutes so

00:32:26,190 --> 00:32:30,269
there's some things we're changing on

00:32:28,080 --> 00:32:32,369
the optimizer also with the optimizer

00:32:30,269 --> 00:32:34,440
which used to be based on the cost of

00:32:32,369 --> 00:32:36,869
reading a piece of information off a

00:32:34,440 --> 00:32:38,369
disk reading something off the disk is a

00:32:36,869 --> 00:32:40,859
hundred thousand times slower than

00:32:38,369 --> 00:32:42,539
reading out our memory what if we have

00:32:40,859 --> 00:32:44,639
the same information in two locations

00:32:42,539 --> 00:32:47,720
one of them is a super solid state disk

00:32:44,639 --> 00:32:52,009
and the other one is a spinning disk

00:32:47,720 --> 00:32:53,909
well this will know which one's the more

00:32:52,009 --> 00:32:59,009
cost-effective wanted to go through I

00:32:53,909 --> 00:33:01,259
also talked more about the the hints to

00:32:59,009 --> 00:33:05,429
the optimizer we force the TVs various

00:33:01,259 --> 00:33:09,619
indexes also talked about the

00:33:05,429 --> 00:33:12,059
improvement sub-query CTS and views and

00:33:09,619 --> 00:33:14,970
where your rewrite if you know someone's

00:33:12,059 --> 00:33:16,139
writing bad queries in their code but

00:33:14,970 --> 00:33:18,419
you can't get them to change them you

00:33:16,139 --> 00:33:22,799
can actually have the server change it

00:33:18,419 --> 00:33:25,109
for you on the fly so if you really want

00:33:22,799 --> 00:33:32,039
more details seeming afterwards or go

00:33:25,109 --> 00:33:33,600
through this so this is just an overview

00:33:32,039 --> 00:33:38,489
of eight

00:33:33,600 --> 00:33:39,929
I want to plenty of time for Q&A or if

00:33:38,489 --> 00:33:41,999
you want to see it in action we can go

00:33:39,929 --> 00:33:46,200
back to the my skills booth and take a

00:33:41,999 --> 00:33:48,590
look at that so if you have any

00:33:46,200 --> 00:33:52,470
questions don't hesitate to contact me

00:33:48,590 --> 00:33:54,599
as I said the slides are up and actually

00:33:52,470 --> 00:33:57,710
the the blog should be elephant dolphin

00:33:54,599 --> 00:34:00,899
blogger.com about elephant and dolphin

00:33:57,710 --> 00:34:02,639
but with that if you have any other

00:34:00,899 --> 00:34:05,519
questions about this or anything Lascaux

00:34:02,639 --> 00:34:06,989
related I can answer it if it's Oracle

00:34:05,519 --> 00:34:11,579
related I might be able to answer it but

00:34:06,989 --> 00:34:13,440
or hold me to that so so are we going

00:34:11,579 --> 00:34:15,089
the right way with eight they're going

00:34:13,440 --> 00:34:15,919
to fix a lot of your problems you're

00:34:15,089 --> 00:34:19,069
happy with it

00:34:15,919 --> 00:34:19,069
yes sir

00:34:20,849 --> 00:34:28,559
you actually now do output equals JSON

00:34:24,470 --> 00:34:36,059
and that's been out since five seven so

00:34:28,559 --> 00:34:39,379
yes sir how many rows we're dependent

00:34:36,059 --> 00:34:41,790
with the type of row and and how much

00:34:39,379 --> 00:34:45,540
you're usually limited to I think right

00:34:41,790 --> 00:34:47,549
now like 250 columns so the number of

00:34:45,540 --> 00:34:50,480
rows probably depends more on your disk

00:34:47,549 --> 00:34:50,480

YouTube URL: https://www.youtube.com/watch?v=hD-L9HQCAks


