Title: 2011 SouthEast LinuxFest - Nathaniel McCallum - Secure Flexible Javascript Ecosystem
Publication date: 2012-03-21
Playlist: 2011 SouthEast LinuxFest
Description: 
	2011 SouthEast LinuxFest - Nathaniel McCallum - Building A Secure, Flexible Javascript Ecosystem

This video is licensed under Creative Commons Attribution 3.0 Unported License.
Captions: 
	00:00:01,220 --> 00:00:07,350
the following presentation was recorded

00:00:04,259 --> 00:00:09,929
at the 2011 southeast linux fest in

00:00:07,350 --> 00:00:11,429
Spartanburg South Carolina it is

00:00:09,929 --> 00:00:14,250
licensed under a creative commons

00:00:11,429 --> 00:00:18,840
license for more information about the

00:00:14,250 --> 00:00:22,260
southeast linux fest visit w wh linux

00:00:18,840 --> 00:00:24,090
fest org the southeast linux fest would

00:00:22,260 --> 00:00:27,269
like to thank the following diamond and

00:00:24,090 --> 00:00:52,110
platinum sponsors in 2011 for helping

00:00:27,269 --> 00:00:55,590
make these videos thank you very much

00:00:52,110 --> 00:00:57,300
can everybody hear me okay great thank

00:00:55,590 --> 00:01:01,379
you all for coming i know it's extremely

00:00:57,300 --> 00:01:03,719
early and if i am too loud just cover

00:01:01,379 --> 00:01:06,119
your ears hide under your desks that'd

00:01:03,719 --> 00:01:08,909
be fine so today we're going to talk

00:01:06,119 --> 00:01:12,090
about building a secure and flexible

00:01:08,909 --> 00:01:14,159
JavaScript ecosystem now probably from

00:01:12,090 --> 00:01:15,299
the title of this a lot of you have come

00:01:14,159 --> 00:01:18,299
here thinking that you're going to see

00:01:15,299 --> 00:01:21,000
lots of JavaScript code today and you're

00:01:18,299 --> 00:01:22,950
not add this was my devilish plan to get

00:01:21,000 --> 00:01:25,979
lots of people interested in JavaScript

00:01:22,950 --> 00:01:27,780
to actually show up and he here what

00:01:25,979 --> 00:01:29,159
we're really going to talk about which

00:01:27,780 --> 00:01:33,119
is something very cool but I'm not going

00:01:29,159 --> 00:01:34,290
to spoil the beans just yet so let's

00:01:33,119 --> 00:01:37,110
talk a little bit about JavaScript

00:01:34,290 --> 00:01:40,320
history I was first developed by

00:01:37,110 --> 00:01:43,920
Netscape in 1995 and was added in

00:01:40,320 --> 00:01:45,049
internet explorer in 1996 it rapidly

00:01:43,920 --> 00:01:47,070
went through a series of

00:01:45,049 --> 00:01:49,140
standardizations because people realize

00:01:47,070 --> 00:01:51,689
that it sort of needs to be standardized

00:01:49,140 --> 00:01:53,759
in order for websites to be able to work

00:01:51,689 --> 00:01:56,549
on all the different browsers so the

00:01:53,759 --> 00:02:01,430
first three iterations of the ECMO spec

00:01:56,549 --> 00:02:04,560
work we're done each year in 97 98 99

00:02:01,430 --> 00:02:07,140
then we sort of had this lull in

00:02:04,560 --> 00:02:10,319
javascript activity for a really almost

00:02:07,140 --> 00:02:13,040
about 10 years I guess that you could

00:02:10,319 --> 00:02:15,319
say eight years there

00:02:13,040 --> 00:02:17,299
and mostly this was because JavaScript

00:02:15,319 --> 00:02:19,099
just kind of worked it worked in the

00:02:17,299 --> 00:02:22,400
browser people were using it they were

00:02:19,099 --> 00:02:24,170
at least back in the 90s using it to to

00:02:22,400 --> 00:02:28,430
make little funky animations of people

00:02:24,170 --> 00:02:30,260
digging out things and all of a sudden

00:02:28,430 --> 00:02:32,659
we start seeing some increase in

00:02:30,260 --> 00:02:36,470
activity here in the in the late 2000s

00:02:32,659 --> 00:02:38,239
with QT script was the was the first to

00:02:36,470 --> 00:02:42,170
my knowledge attempts to actually

00:02:38,239 --> 00:02:43,549
integrate JavaScript into another

00:02:42,170 --> 00:02:45,470
project as sort of like a scripting

00:02:43,549 --> 00:02:47,959
language right so this is sort of the

00:02:45,470 --> 00:02:50,810
first out of the browser attempt at

00:02:47,959 --> 00:02:53,090
doing javascript in 2008 and 2 we saw

00:02:50,810 --> 00:02:57,530
the release of two projects very similar

00:02:53,090 --> 00:02:58,909
to QT script gjs and seed and these two

00:02:57,530 --> 00:03:01,430
projects attempt to do the same thing

00:02:58,909 --> 00:03:04,129
that the QT script does for cutie but to

00:03:01,430 --> 00:03:08,989
do it for the g object type system which

00:03:04,129 --> 00:03:12,139
most commonly used is gtk in 2009 we saw

00:03:08,989 --> 00:03:15,230
a even further flurry of activity we saw

00:03:12,139 --> 00:03:17,599
ECMO version 5 as interest in JavaScript

00:03:15,230 --> 00:03:19,310
began to pick back up we saw something

00:03:17,599 --> 00:03:20,870
called common j/s developed which we're

00:03:19,310 --> 00:03:22,549
going to talk about in a minute and we

00:03:20,870 --> 00:03:25,400
also saw this really interesting project

00:03:22,549 --> 00:03:28,909
get founded called nodejs how many of

00:03:25,400 --> 00:03:32,989
you know what no date nodejs is how many

00:03:28,909 --> 00:03:37,250
of you have played with nodejs how many

00:03:32,989 --> 00:03:39,919
of you like nodejs okay so what we're

00:03:37,250 --> 00:03:41,359
going to talk about that in a minute so

00:03:39,919 --> 00:03:44,239
basically what's happening is we've

00:03:41,359 --> 00:03:45,650
we've had this this resurgence and most

00:03:44,239 --> 00:03:47,510
of the resurgence in the last few years

00:03:45,650 --> 00:03:48,949
we're all this sort of real innovation

00:03:47,510 --> 00:03:52,370
around javascript is happening is

00:03:48,949 --> 00:03:53,870
actually outside of the browser for a

00:03:52,370 --> 00:03:55,459
long time it was sort of trapped in this

00:03:53,870 --> 00:03:57,650
browser land and the only way you could

00:03:55,459 --> 00:03:59,659
ever deploy a javascript on something or

00:03:57,650 --> 00:04:01,750
use it was to put javascript on a web

00:03:59,659 --> 00:04:04,519
page and deploy it out to the browser

00:04:01,750 --> 00:04:07,010
well people got this brilliant idea that

00:04:04,519 --> 00:04:08,810
you know let's look at the language it's

00:04:07,010 --> 00:04:10,909
actually got some really great features

00:04:08,810 --> 00:04:13,400
the first thing is that it's the most

00:04:10,909 --> 00:04:15,079
secure language ever right and the

00:04:13,400 --> 00:04:16,639
reason for this is really quite simple

00:04:15,079 --> 00:04:18,349
it's not because it has a ton of

00:04:16,639 --> 00:04:21,620
security features it's because it's a

00:04:18,349 --> 00:04:24,590
language that's designed to only put

00:04:21,620 --> 00:04:26,600
into a sandbox the data that you want to

00:04:24,590 --> 00:04:29,600
manipulate in that sandbox so

00:04:26,600 --> 00:04:30,770
by design it's inherently secure and the

00:04:29,600 --> 00:04:33,080
reason why I say it's the most secure

00:04:30,770 --> 00:04:35,690
language ever is because when you think

00:04:33,080 --> 00:04:38,480
about it javascript every single day is

00:04:35,690 --> 00:04:42,290
running trillions upon trillions of

00:04:38,480 --> 00:04:44,270
lines of untrusted code can you name any

00:04:42,290 --> 00:04:46,760
other language that runs that much

00:04:44,270 --> 00:04:49,760
untrusted code on a daily basis I can't

00:04:46,760 --> 00:04:51,230
think of any the other thing there's a

00:04:49,760 --> 00:04:52,310
few other features that are really

00:04:51,230 --> 00:04:53,930
interesting about JavaScript it's

00:04:52,310 --> 00:04:55,940
available pretty much everywhere pretty

00:04:53,930 --> 00:04:58,310
much every operating system every

00:04:55,940 --> 00:05:01,040
architecture and it works pretty well

00:04:58,310 --> 00:05:03,230
everywhere it's lightweight you know you

00:05:01,040 --> 00:05:05,030
may think oh man my browser it just

00:05:03,230 --> 00:05:07,310
sucks up the memory usage I know that on

00:05:05,030 --> 00:05:09,140
my system the browser and eclipses are

00:05:07,310 --> 00:05:11,150
pretty much the two biggest memory hugs

00:05:09,140 --> 00:05:14,570
well you've got to think about this i've

00:05:11,150 --> 00:05:15,860
probably got 100 tabs open and each one

00:05:14,570 --> 00:05:18,410
of them is rendering an extremely

00:05:15,860 --> 00:05:20,060
complex document and actually when you

00:05:18,410 --> 00:05:21,230
pull out just the javascript part of it

00:05:20,060 --> 00:05:24,170
itself that's actually really really

00:05:21,230 --> 00:05:26,800
lightweight it's also really fast and

00:05:24,170 --> 00:05:29,630
this is thanks to some research by

00:05:26,800 --> 00:05:32,090
google for instance when they introduced

00:05:29,630 --> 00:05:33,770
their v8 engine it really sort of kicked

00:05:32,090 --> 00:05:35,390
everybody in the pants and there's now

00:05:33,770 --> 00:05:36,920
this performance war between all the

00:05:35,390 --> 00:05:38,840
different JavaScript implementations of

00:05:36,920 --> 00:05:41,180
who can be the fastest and they are

00:05:38,840 --> 00:05:43,010
rapidly increasing to the point where

00:05:41,180 --> 00:05:47,540
somebody actually just released a blog

00:05:43,010 --> 00:05:51,260
yesterday we're in certain instances v8

00:05:47,540 --> 00:05:55,190
can actually make JavaScript faster than

00:05:51,260 --> 00:05:56,630
a native function compiled by GCC that's

00:05:55,190 --> 00:06:00,260
pretty incredible for our scripting

00:05:56,630 --> 00:06:03,110
language it's also embeddable right a

00:06:00,260 --> 00:06:04,850
lot of the embedded market is exploding

00:06:03,110 --> 00:06:07,100
I don't know how many of you have a

00:06:04,850 --> 00:06:10,220
mobile device of some sort in your

00:06:07,100 --> 00:06:12,410
pocket right the one of the biggest

00:06:10,220 --> 00:06:14,090
features of these devices is that they

00:06:12,410 --> 00:06:15,500
can run JavaScript which means that they

00:06:14,090 --> 00:06:17,570
can access all of those trillions upon

00:06:15,500 --> 00:06:19,430
trillions of lines of untrusted code

00:06:17,570 --> 00:06:21,830
that are out there on the web but not

00:06:19,430 --> 00:06:23,510
only just on the web a lot of these a

00:06:21,830 --> 00:06:25,010
lot of these products actually are using

00:06:23,510 --> 00:06:28,160
javascript pretty heavily internally one

00:06:25,010 --> 00:06:29,360
I can think of explicitly is HP's webos

00:06:28,160 --> 00:06:31,520
I don't know if you've played with that

00:06:29,360 --> 00:06:33,290
at all or heard anything about it but

00:06:31,520 --> 00:06:35,030
when you if you're not doing native

00:06:33,290 --> 00:06:37,669
development code on that platform which

00:06:35,030 --> 00:06:39,470
very few people are you are doing

00:06:37,669 --> 00:06:40,730
completely javascript programming

00:06:39,470 --> 00:06:42,080
and that has nothing to do with the

00:06:40,730 --> 00:06:45,710
browser you're just programming in

00:06:42,080 --> 00:06:47,480
JavaScript the the user interface so

00:06:45,710 --> 00:06:49,700
it's embeddable there's also a couple

00:06:47,480 --> 00:06:51,320
really great products out there like

00:06:49,700 --> 00:06:53,390
titanium I don't love you in front of

00:06:51,320 --> 00:06:57,410
that which is a JavaScript API for doing

00:06:53,390 --> 00:06:58,610
Android and and iOS development in

00:06:57,410 --> 00:07:01,850
JavaScript so you don't have to learn

00:06:58,610 --> 00:07:03,230
Objective C and Java right and they do

00:07:01,850 --> 00:07:05,720
really well it's a great product i

00:07:03,230 --> 00:07:08,930
highly recommend it but one of the

00:07:05,720 --> 00:07:10,370
coolest features of javascript is it has

00:07:08,930 --> 00:07:11,840
this concept called closures and now

00:07:10,370 --> 00:07:14,240
closures have been around in languages

00:07:11,840 --> 00:07:15,680
for a while but they were introduced

00:07:14,240 --> 00:07:18,380
pretty much at the beginning of

00:07:15,680 --> 00:07:20,840
JavaScript which and what this means is

00:07:18,380 --> 00:07:22,130
that you can pass a functioning as an

00:07:20,840 --> 00:07:24,920
object and that function can be called

00:07:22,130 --> 00:07:27,080
back later and actually have a set of

00:07:24,920 --> 00:07:29,930
state with it right that it can detta

00:07:27,080 --> 00:07:32,690
can finish up and so this leads to

00:07:29,930 --> 00:07:35,419
JavaScript being a pretty event-driven

00:07:32,690 --> 00:07:37,850
language you'll say I want to fetch a

00:07:35,419 --> 00:07:40,220
web page and here's a function and call

00:07:37,850 --> 00:07:42,860
me call that function when when the web

00:07:40,220 --> 00:07:45,440
page is done loading so the one of the

00:07:42,860 --> 00:07:47,419
great things about that is that if you

00:07:45,440 --> 00:07:50,990
if you spend any time sort of watching

00:07:47,419 --> 00:07:53,180
on development you know if like the

00:07:50,990 --> 00:07:55,430
gnome planet or things like that what

00:07:53,180 --> 00:07:56,840
you will immediately see is that there's

00:07:55,430 --> 00:07:59,030
a lot of talk about asynchronous

00:07:56,840 --> 00:08:02,120
programming asynchronous programming is

00:07:59,030 --> 00:08:03,410
really hard and what about what you want

00:08:02,120 --> 00:08:04,760
to do is you don't want to say okay I

00:08:03,410 --> 00:08:06,200
want to read this file and sort of wait

00:08:04,760 --> 00:08:07,729
till the read happens because you can't

00:08:06,200 --> 00:08:10,220
do anything else while you're doing that

00:08:07,729 --> 00:08:12,290
you want to say I want I want you to

00:08:10,220 --> 00:08:13,580
read this file but just sort of do it in

00:08:12,290 --> 00:08:14,900
the background let me know let me know

00:08:13,580 --> 00:08:17,690
when it comes back and is ready to be

00:08:14,900 --> 00:08:19,550
read so so this is a huge push in

00:08:17,690 --> 00:08:22,010
programming as a whole we want we want

00:08:19,550 --> 00:08:23,840
more a sink this interfaces and actually

00:08:22,010 --> 00:08:25,910
that's one of my jobs at Red Hat my job

00:08:23,840 --> 00:08:28,100
is to actually bring asynchronous

00:08:25,910 --> 00:08:29,330
programming to a whole variety of stack

00:08:28,100 --> 00:08:31,370
their work on the free IP a project

00:08:29,330 --> 00:08:33,169
which is really cool and so I got to

00:08:31,370 --> 00:08:35,360
make it really fast and and my job is to

00:08:33,169 --> 00:08:36,650
make it event-driven so the but this is

00:08:35,360 --> 00:08:38,180
one of the great features of JavaScript

00:08:36,650 --> 00:08:41,510
that out of the box it is an

00:08:38,180 --> 00:08:43,520
event-driven language so a lot of people

00:08:41,510 --> 00:08:45,920
thought you know JavaScript can have a

00:08:43,520 --> 00:08:47,720
lot of great functionality outside of

00:08:45,920 --> 00:08:49,730
the browser so the first thing that they

00:08:47,720 --> 00:08:52,850
do is they look around and they pick an

00:08:49,730 --> 00:08:53,089
engine so that they'll build pick one of

00:08:52,850 --> 00:08:54,350
the

00:08:53,089 --> 00:08:55,939
I'm going to actually go through the

00:08:54,350 --> 00:08:58,069
engines here we're going to talk about a

00:08:55,939 --> 00:08:59,720
little bit about each of the JavaScript

00:08:58,069 --> 00:09:02,449
engines that are available the first

00:08:59,720 --> 00:09:04,100
engine is spider monkey and this is the

00:09:02,449 --> 00:09:06,980
first JavaScript engine that was ever

00:09:04,100 --> 00:09:10,160
written remember remember JavaScript was

00:09:06,980 --> 00:09:12,139
created by Netscape in 1995 the Netscape

00:09:10,160 --> 00:09:13,730
codebase eventually became the Mozilla

00:09:12,139 --> 00:09:16,519
code base which eventually became the

00:09:13,730 --> 00:09:18,259
Firefox code base so spider monkey is

00:09:16,519 --> 00:09:20,300
actually that original JavaScript

00:09:18,259 --> 00:09:22,459
implementation that's been improved over

00:09:20,300 --> 00:09:25,189
an over the years it is used mainly by

00:09:22,459 --> 00:09:29,540
Firefox there are a few other products

00:09:25,189 --> 00:09:32,779
that use it but we'll see down on the

00:09:29,540 --> 00:09:34,699
bottom exactly what that means it has a

00:09:32,779 --> 00:09:38,240
few pros the first is it's a feature

00:09:34,699 --> 00:09:39,949
driven JavaScript engine it has advanced

00:09:38,240 --> 00:09:41,839
features that are not standardized

00:09:39,949 --> 00:09:43,879
they're trying to sort of push the

00:09:41,839 --> 00:09:46,160
envelope on the standard of what things

00:09:43,879 --> 00:09:47,689
good could be like there's three

00:09:46,160 --> 00:09:50,899
features that are probably the most

00:09:47,689 --> 00:09:52,309
critical the first is it has support for

00:09:50,899 --> 00:09:55,100
a little keyword called let and let

00:09:52,309 --> 00:09:56,839
allows you to declare a variable in a

00:09:55,100 --> 00:09:58,490
local scope for those of you who have

00:09:56,839 --> 00:10:00,679
done any javascript programming you know

00:09:58,490 --> 00:10:02,870
that most variables that you create end

00:10:00,679 --> 00:10:05,899
up in the global scope and so you can

00:10:02,870 --> 00:10:07,670
get a lot of stomping over variable

00:10:05,899 --> 00:10:09,829
names as your program gets larger and

00:10:07,670 --> 00:10:12,470
larger well the let keyword allows you

00:10:09,829 --> 00:10:14,269
to create a variable that is just local

00:10:12,470 --> 00:10:16,929
in scope when you've returned from the

00:10:14,269 --> 00:10:20,779
function that variable no longer exists

00:10:16,929 --> 00:10:22,040
you have a feature called yield and for

00:10:20,779 --> 00:10:24,199
those of you who are familiar with

00:10:22,040 --> 00:10:25,879
asynchronous programming yield is a

00:10:24,199 --> 00:10:29,059
really great piece of functionality what

00:10:25,879 --> 00:10:30,980
allows you to do is you can instead of

00:10:29,059 --> 00:10:32,990
typing return to return a value from a

00:10:30,980 --> 00:10:35,870
function you can type yield and it will

00:10:32,990 --> 00:10:37,819
return that value but then the person

00:10:35,870 --> 00:10:40,370
who called the function can actually

00:10:37,819 --> 00:10:42,949
resume the function at the yield and

00:10:40,370 --> 00:10:44,629
continue processing so you can actually

00:10:42,949 --> 00:10:47,089
have 10 yield statements in a single

00:10:44,629 --> 00:10:49,879
function and call that function 10 times

00:10:47,089 --> 00:10:51,379
each time it will resume a processing

00:10:49,879 --> 00:10:53,089
where that last yield statement was

00:10:51,379 --> 00:10:55,399
until it gets all the way to the bottom

00:10:53,089 --> 00:10:56,990
now why would that be useful you think

00:10:55,399 --> 00:10:58,519
you just want to get one value from a

00:10:56,990 --> 00:11:00,199
function right well imagine you're

00:10:58,519 --> 00:11:03,069
trying to do again asynchronous

00:11:00,199 --> 00:11:06,529
programming in asynchronous programming

00:11:03,069 --> 00:11:06,950
you can return this value which might be

00:11:06,529 --> 00:11:09,080
a

00:11:06,950 --> 00:11:11,360
descriptor and the file descriptor gets

00:11:09,080 --> 00:11:12,950
added into a loop and waits until the

00:11:11,360 --> 00:11:15,290
file descriptor has something available

00:11:12,950 --> 00:11:16,880
to read and then it calls back the

00:11:15,290 --> 00:11:19,070
function function and resumes where you

00:11:16,880 --> 00:11:20,720
left off so rather than having ten

00:11:19,070 --> 00:11:23,000
different functions that respond to ten

00:11:20,720 --> 00:11:25,400
different events in the asynchronous

00:11:23,000 --> 00:11:28,040
model you have one function with ten

00:11:25,400 --> 00:11:29,300
yield statements and so the flow of what

00:11:28,040 --> 00:11:30,620
you're actually trying to accomplish is

00:11:29,300 --> 00:11:33,230
all right in a row it makes for really

00:11:30,620 --> 00:11:36,560
easy programming the last feature that

00:11:33,230 --> 00:11:41,090
spider monkey introduces is called efore

00:11:36,560 --> 00:11:42,920
X which stands for ECMO script for XML

00:11:41,090 --> 00:11:47,270
and what it actually does is it makes

00:11:42,920 --> 00:11:49,460
XML a JavaScript object so you can

00:11:47,270 --> 00:11:51,830
literally just type raw XML into a

00:11:49,460 --> 00:11:53,270
JavaScript file and it's an object and

00:11:51,830 --> 00:11:56,440
you can parse it and pass it around just

00:11:53,270 --> 00:11:59,270
like any other object in JavaScript

00:11:56,440 --> 00:12:02,870
another the last two pros of spider

00:11:59,270 --> 00:12:05,090
monkey is that it's fast in fact spider

00:12:02,870 --> 00:12:08,420
monkey in recent builds is pretty much

00:12:05,090 --> 00:12:10,490
as fast as all of the other engines with

00:12:08,420 --> 00:12:12,830
of course each engine has you know some

00:12:10,490 --> 00:12:14,150
some positives and some drawbacks in

00:12:12,830 --> 00:12:16,220
terms of its speed but spider monkeys

00:12:14,150 --> 00:12:18,230
really fast it also has brought

00:12:16,220 --> 00:12:19,670
architecture support and this is due to

00:12:18,230 --> 00:12:22,160
the fact that it's one of the oldest

00:12:19,670 --> 00:12:23,540
implementations and it's been around for

00:12:22,160 --> 00:12:26,210
a long time and people are using it on

00:12:23,540 --> 00:12:29,720
every architecture imaginable x86 you

00:12:26,210 --> 00:12:32,900
know MIPS arm and then even the really

00:12:29,720 --> 00:12:35,600
execute obscure ones as well it does

00:12:32,900 --> 00:12:38,600
have some cons them the older versions

00:12:35,600 --> 00:12:40,730
are slower so if you don't have the sort

00:12:38,600 --> 00:12:43,820
of you know most crack induced release

00:12:40,730 --> 00:12:46,070
of spider monkey then you are going to

00:12:43,820 --> 00:12:49,310
get slower performance it has no

00:12:46,070 --> 00:12:51,950
unbundled releases and this is with the

00:12:49,310 --> 00:12:55,280
next one probably the most significant

00:12:51,950 --> 00:12:57,670
drawback to spider monkey how many of

00:12:55,280 --> 00:12:59,720
you know that that Firefox has rapidly

00:12:57,670 --> 00:13:00,950
increase their release schedule they're

00:12:59,720 --> 00:13:03,890
now going to be and I believe it's a six

00:13:00,950 --> 00:13:06,170
month schedule is that right in order to

00:13:03,890 --> 00:13:08,120
do that they have basically said to

00:13:06,170 --> 00:13:12,620
anyone that's using any of the Mozilla

00:13:08,120 --> 00:13:14,030
components shove off the reason for that

00:13:12,620 --> 00:13:16,400
is they don't want to commit to API

00:13:14,030 --> 00:13:18,290
stability at all they want to be able to

00:13:16,400 --> 00:13:20,270
change the library as often as they want

00:13:18,290 --> 00:13:23,480
in backwards incompatible way

00:13:20,270 --> 00:13:25,790
and they don't care about anyone that's

00:13:23,480 --> 00:13:28,190
outside of Firefox they only care about

00:13:25,790 --> 00:13:31,550
the Firefox ecosystem and that is their

00:13:28,190 --> 00:13:34,430
prerogative but spider monkeys cool and

00:13:31,550 --> 00:13:37,610
I want to use it outside of Firefox so

00:13:34,430 --> 00:13:38,960
what should I do if you're a library

00:13:37,610 --> 00:13:40,520
that's trying to depend on spider monkey

00:13:38,960 --> 00:13:41,780
you're going to have a hard time as they

00:13:40,520 --> 00:13:43,490
continue to make these backwards

00:13:41,780 --> 00:13:46,840
incompatible changes to actually

00:13:43,490 --> 00:13:49,010
maintain your support for spider monkey

00:13:46,840 --> 00:13:50,990
one of the other drawbacks is that

00:13:49,010 --> 00:13:53,720
spider monkey is most often bundled with

00:13:50,990 --> 00:13:54,980
zool runner now actually this is one of

00:13:53,720 --> 00:13:58,330
the things that has changed for the

00:13:54,980 --> 00:14:01,100
positive lately there is one guy who is

00:13:58,330 --> 00:14:03,110
creating individual releases of just the

00:14:01,100 --> 00:14:05,750
spider monkey engine several

00:14:03,110 --> 00:14:09,140
distributions pack package it I know

00:14:05,750 --> 00:14:10,550
that fedora ships it so that's nice

00:14:09,140 --> 00:14:11,720
because it doesn't necessarily have to

00:14:10,550 --> 00:14:13,610
be bundled with zool runner which is a

00:14:11,720 --> 00:14:16,790
pretty big package has a pretty big

00:14:13,610 --> 00:14:18,800
memory footprint but for those of you

00:14:16,790 --> 00:14:21,260
who are stuck with being integrated with

00:14:18,800 --> 00:14:22,910
zool runner you have a memory hit as you

00:14:21,260 --> 00:14:25,210
have to load in this big library that

00:14:22,910 --> 00:14:28,010
really has nothing to do with JavaScript

00:14:25,210 --> 00:14:31,160
the second engine we'll talk about here

00:14:28,010 --> 00:14:33,620
is v8 v8 is used mainly by the chrome or

00:14:31,160 --> 00:14:35,780
chromium browser how many of you have

00:14:33,620 --> 00:14:38,870
used that browser it's actually pretty

00:14:35,780 --> 00:14:40,460
nice browser and it's extremely fast the

00:14:38,870 --> 00:14:42,170
reason it's extremely fast is because

00:14:40,460 --> 00:14:45,320
the JavaScript engine as you can see in

00:14:42,170 --> 00:14:47,390
the pros is focused on speed and like I

00:14:45,320 --> 00:14:49,340
already said there was a blog post just

00:14:47,390 --> 00:14:51,620
this weekend about how in some instances

00:14:49,340 --> 00:14:56,180
JavaScript on v8 is actually faster than

00:14:51,620 --> 00:14:58,250
native code compiled with GCC one of the

00:14:56,180 --> 00:14:59,960
other neat features about v8 is that it

00:14:58,250 --> 00:15:01,670
allows you to manage the scope of the

00:14:59,960 --> 00:15:03,020
objects on the stack now this is

00:15:01,670 --> 00:15:05,150
actually talking about on the native

00:15:03,020 --> 00:15:06,440
side of things right not the not inside

00:15:05,150 --> 00:15:09,760
the JavaScript sandbox but when you're

00:15:06,440 --> 00:15:12,920
programming in C++ rather than having to

00:15:09,760 --> 00:15:14,750
do all kinds of funky reference counting

00:15:12,920 --> 00:15:17,510
to make sure that your objects are still

00:15:14,750 --> 00:15:19,370
around when you need them the scope is

00:15:17,510 --> 00:15:21,080
managed on the stack which means you can

00:15:19,370 --> 00:15:22,130
just pass it like a normal parameter and

00:15:21,080 --> 00:15:26,000
it just sort of keeps track of

00:15:22,130 --> 00:15:27,920
everything on its own v8 does have some

00:15:26,000 --> 00:15:30,560
cons the architecture support is uneven

00:15:27,920 --> 00:15:32,510
it's newer it's a newer JavaScript

00:15:30,560 --> 00:15:33,560
engine and one of the biggest problems

00:15:32,510 --> 00:15:37,750
is that

00:15:33,560 --> 00:15:40,520
because v8 is so performance optimized

00:15:37,750 --> 00:15:42,950
but there are there are large chunks of

00:15:40,520 --> 00:15:44,150
it written in assembly and so for those

00:15:42,950 --> 00:15:46,520
of you who know how to program in

00:15:44,150 --> 00:15:48,890
assembly you know that it's really not

00:15:46,520 --> 00:15:50,810
very portable so what happens is that

00:15:48,890 --> 00:15:53,510
every time you want to introduce it to a

00:15:50,810 --> 00:15:57,080
new architecture you have to essentially

00:15:53,510 --> 00:15:58,910
rewrite that core part of v8 now the two

00:15:57,080 --> 00:16:02,779
the two architectures that are probably

00:15:58,910 --> 00:16:04,760
most common right now x86 and arm for

00:16:02,779 --> 00:16:07,730
all your mobile devices all about

00:16:04,760 --> 00:16:10,190
supported by v8 and their v8 is a pretty

00:16:07,730 --> 00:16:16,250
good choice but if you want to run it

00:16:10,190 --> 00:16:18,529
anywhere else good luck and so it does

00:16:16,250 --> 00:16:21,260
have some cons or some further cons

00:16:18,529 --> 00:16:23,750
there's no capi so if you are writing a

00:16:21,260 --> 00:16:27,529
see application not a C++ application

00:16:23,750 --> 00:16:31,370
you're pretty much also out of luck only

00:16:27,529 --> 00:16:34,670
the C++ API supported just like spider

00:16:31,370 --> 00:16:36,589
monkey v8 has no api stability and again

00:16:34,670 --> 00:16:38,450
they do change things pretty often

00:16:36,589 --> 00:16:41,750
they're probably a little bit better

00:16:38,450 --> 00:16:43,430
than mozilla is but but there have been

00:16:41,750 --> 00:16:49,640
some changes that have have caught

00:16:43,430 --> 00:16:51,290
people in the butt can you say handle

00:16:49,640 --> 00:16:54,710
scope has anybody actually programmed

00:16:51,290 --> 00:16:56,089
with the v8 API okay so they have this

00:16:54,710 --> 00:16:57,800
thing called handle scope and this is

00:16:56,089 --> 00:17:00,800
the way that you actually get to manage

00:16:57,800 --> 00:17:02,810
the variables on the stack which is

00:17:00,800 --> 00:17:05,480
which is a pro the problem is you have

00:17:02,810 --> 00:17:09,439
to have handle scope everywhere and the

00:17:05,480 --> 00:17:11,510
problem is it's a little buggy sometimes

00:17:09,439 --> 00:17:14,900
you'll pass an object to a function and

00:17:11,510 --> 00:17:16,939
you don't actually get the same exact

00:17:14,900 --> 00:17:18,980
object now it looks pretty much the same

00:17:16,939 --> 00:17:21,560
but one of the bugs I ran into when

00:17:18,980 --> 00:17:22,970
using it was that the private pointers

00:17:21,560 --> 00:17:25,579
that I actually stored in that object

00:17:22,970 --> 00:17:28,150
we're gone so it's a little buggy and

00:17:25,579 --> 00:17:31,070
it's really really hard to sort of debug

00:17:28,150 --> 00:17:32,990
v8 also has no innovative language

00:17:31,070 --> 00:17:35,690
features unlike spider monkey spider

00:17:32,990 --> 00:17:38,540
monkey has the features like XML and

00:17:35,690 --> 00:17:40,340
JavaScript and others but v8 does not

00:17:38,540 --> 00:17:42,140
they have no intention of pushing the

00:17:40,340 --> 00:17:44,540
envelope whatsoever they just want it to

00:17:42,140 --> 00:17:47,370
be fast and lean

00:17:44,540 --> 00:17:50,820
javascriptcore sort of represents the

00:17:47,370 --> 00:17:55,020
in-between of those two it is used

00:17:50,820 --> 00:17:57,840
mainly by WebKit and Safari and it's

00:17:55,020 --> 00:17:59,250
developed primarily by Apple it does

00:17:57,840 --> 00:18:02,730
have some pros that the others don't

00:17:59,250 --> 00:18:04,890
have it does have a stable capi it also

00:18:02,730 --> 00:18:06,360
has broad architecture support I can't

00:18:04,890 --> 00:18:08,550
think of any architecture where it

00:18:06,360 --> 00:18:11,460
doesn't work it's available by default

00:18:08,550 --> 00:18:13,950
on modern Mac and Linux which is end

00:18:11,460 --> 00:18:16,860
mobile devices as well including

00:18:13,950 --> 00:18:19,950
including iOS devices but unfortunately

00:18:16,860 --> 00:18:24,570
not android which means that if you

00:18:19,950 --> 00:18:26,370
wanted to use AC JavaScript capi and you

00:18:24,570 --> 00:18:28,140
wanted to have you know pretty much be

00:18:26,370 --> 00:18:32,429
available everywhere web kits your only

00:18:28,140 --> 00:18:34,980
choice however it also has integration

00:18:32,429 --> 00:18:38,120
with with cute from version 4.3 that's

00:18:34,980 --> 00:18:41,610
the cute script I was talking about and

00:18:38,120 --> 00:18:44,280
then some of the cons it is tightly

00:18:41,610 --> 00:18:46,410
coupled with WebKit gtk cutie and core

00:18:44,280 --> 00:18:48,570
foundation what this means is that if

00:18:46,410 --> 00:18:51,240
you do want to use JavaScript core you

00:18:48,570 --> 00:18:54,120
have to pull in the entire gtk stack or

00:18:51,240 --> 00:18:57,080
you have to pull in the entire QT stack

00:18:54,120 --> 00:19:00,630
or the entire core foundation stack

00:18:57,080 --> 00:19:02,400
that's not terrible but again like zool

00:19:00,630 --> 00:19:03,660
runner that's a lot of memory for

00:19:02,400 --> 00:19:06,020
something that you're probably not going

00:19:03,660 --> 00:19:08,460
to use if you just want JavaScript

00:19:06,020 --> 00:19:11,250
another con is that it's not as fast as

00:19:08,460 --> 00:19:13,350
spider monkey or v8 I know that Apple is

00:19:11,250 --> 00:19:15,390
working on this to get it faster but

00:19:13,350 --> 00:19:18,059
they they still haven't gotten there

00:19:15,390 --> 00:19:19,800
quite yet no innovative lingua language

00:19:18,059 --> 00:19:21,150
features just like v8 they have no

00:19:19,800 --> 00:19:22,620
intention of pushing the barrier they

00:19:21,150 --> 00:19:24,870
just want to support what is the

00:19:22,620 --> 00:19:26,640
baseline echamos script there's another

00:19:24,870 --> 00:19:31,140
con that's not listed here that I should

00:19:26,640 --> 00:19:33,480
probably mention and that is Apple has a

00:19:31,140 --> 00:19:36,360
nasty habit of not releasing the source

00:19:33,480 --> 00:19:38,580
code for javascriptcore so they'll do a

00:19:36,360 --> 00:19:40,590
whole bunch of performance improvements

00:19:38,580 --> 00:19:43,679
and then not actually release them until

00:19:40,590 --> 00:19:46,530
six months to a year later and so this

00:19:43,679 --> 00:19:48,870
basically means that if you do want you

00:19:46,530 --> 00:19:50,670
know that new cool feature or that

00:19:48,870 --> 00:19:53,070
awesome new speed improvement that came

00:19:50,670 --> 00:19:54,300
out in v8 or spider monkey well you're

00:19:53,070 --> 00:19:55,980
probably going to have to wait a year

00:19:54,300 --> 00:19:56,980
and a half to two years before you can

00:19:55,980 --> 00:20:02,590
actually you

00:19:56,980 --> 00:20:04,840
that on any given platform one last

00:20:02,590 --> 00:20:08,290
engine which is sort of the oddball out

00:20:04,840 --> 00:20:10,299
here is Rhino & Reinbold is rhino is

00:20:08,290 --> 00:20:13,270
used in the Java world and it's

00:20:10,299 --> 00:20:16,270
developed by Mozilla since its developed

00:20:13,270 --> 00:20:18,400
by Mozilla it also is very future full

00:20:16,270 --> 00:20:21,790
it can contain support for let yield and

00:20:18,400 --> 00:20:23,799
e 4x it has broad architecture support

00:20:21,790 --> 00:20:25,630
the reason for this is because it's on

00:20:23,799 --> 00:20:28,630
the JVM right so it will run anywhere

00:20:25,630 --> 00:20:30,070
that the JVM runs one of the really nice

00:20:28,630 --> 00:20:32,740
features of rhino is that it has a

00:20:30,070 --> 00:20:34,270
transparent bridge to java classes so if

00:20:32,740 --> 00:20:36,610
you want to you know if you've got a big

00:20:34,270 --> 00:20:38,890
job application and you want to make it

00:20:36,610 --> 00:20:42,130
JavaScript compatible you can just plug

00:20:38,890 --> 00:20:43,840
in rhino and rhino can buy a javascript

00:20:42,130 --> 00:20:44,770
nip you laid all those java objects for

00:20:43,840 --> 00:20:46,600
you and you don't really have to do

00:20:44,770 --> 00:20:48,100
anything you get it for free the

00:20:46,600 --> 00:20:53,110
downside of rhino is that it is

00:20:48,100 --> 00:20:55,690
extremely slow I for one am not the

00:20:53,110 --> 00:20:59,020
opinion that the JVM is really a great

00:20:55,690 --> 00:21:00,330
platform for for JavaScript i think that

00:20:59,020 --> 00:21:03,120
there's sort of an impedance mismatch

00:21:00,330 --> 00:21:05,740
with some of the language design choices

00:21:03,120 --> 00:21:07,510
and the other the other downside is that

00:21:05,740 --> 00:21:10,900
Rhino pretty much lives in a Java ghetto

00:21:07,510 --> 00:21:13,390
so if you're doing Java and JavaScript

00:21:10,900 --> 00:21:15,610
you're using rhino and if you're doing

00:21:13,390 --> 00:21:18,130
JavaScript but not using Java you're not

00:21:15,610 --> 00:21:21,760
using right now so that's that's pretty

00:21:18,130 --> 00:21:23,410
much the the major downside to rhino so

00:21:21,760 --> 00:21:25,179
as we've gone through these engines

00:21:23,410 --> 00:21:27,340
something should pretty clearly come to

00:21:25,179 --> 00:21:29,200
your mind and that is if you do want to

00:21:27,340 --> 00:21:30,730
use JavaScript outside of the browser

00:21:29,200 --> 00:21:33,220
you have to pick an engine but there's

00:21:30,730 --> 00:21:36,130
not really a universal best solution

00:21:33,220 --> 00:21:38,919
right there's a best solution perhaps on

00:21:36,130 --> 00:21:43,540
Android and there's a best solution on

00:21:38,919 --> 00:21:46,419
iOS or on Mac and maybe on Linux but

00:21:43,540 --> 00:21:51,309
maybe even not there right so which

00:21:46,419 --> 00:21:52,809
engine do you use well most of these

00:21:51,309 --> 00:21:55,690
projects that are doing out of the

00:21:52,809 --> 00:21:57,130
browser javascript stuff they just go

00:21:55,690 --> 00:21:58,870
ahead and pick one of the engines and

00:21:57,130 --> 00:22:00,549
they accept that there's pros and cons

00:21:58,870 --> 00:22:04,450
and those pros and cons just get

00:22:00,549 --> 00:22:06,880
inherited by the project itself the next

00:22:04,450 --> 00:22:09,400
step that they do is they say oh my god

00:22:06,880 --> 00:22:10,809
we need to have modules right so this is

00:22:09,400 --> 00:22:12,879
pretty much like any language where you

00:22:10,809 --> 00:22:15,220
an import statement or an include

00:22:12,879 --> 00:22:17,019
statement and you can pull in other

00:22:15,220 --> 00:22:18,399
stuff and the reason that this is really

00:22:17,019 --> 00:22:21,580
handy of course is that you can actually

00:22:18,399 --> 00:22:24,039
create reusable code I can I can make

00:22:21,580 --> 00:22:25,870
module and that you know connects to a

00:22:24,039 --> 00:22:29,169
web server and download the file and

00:22:25,870 --> 00:22:31,389
someone else can make a module that that

00:22:29,169 --> 00:22:33,850
downloads or that connects to IRC and

00:22:31,389 --> 00:22:35,860
sends jack messages and then I can hook

00:22:33,850 --> 00:22:37,269
those two modules together and i can

00:22:35,860 --> 00:22:39,309
download something from a website and

00:22:37,269 --> 00:22:42,129
paste it in an IRC chatroom alright so

00:22:39,309 --> 00:22:43,480
modules are really really handy so the

00:22:42,129 --> 00:22:45,570
that's the very first thing that I now

00:22:43,480 --> 00:22:47,980
is out of browser javascript problem

00:22:45,570 --> 00:22:50,860
program does is they say we need to have

00:22:47,980 --> 00:22:53,169
a way to load modules the third thing

00:22:50,860 --> 00:22:54,879
that the out of the browser project does

00:22:53,169 --> 00:22:57,460
is they tightly couple with their niche

00:22:54,879 --> 00:23:03,190
so in the case of nodejs does anybody

00:22:57,460 --> 00:23:04,840
know what nodejs is niches ok what's the

00:23:03,190 --> 00:23:11,289
tagline when you go to the nodejs

00:23:04,840 --> 00:23:13,899
website anybody now invented io for

00:23:11,289 --> 00:23:17,080
javascript right is that sound familiar

00:23:13,899 --> 00:23:20,679
to anybody that's what they do they do

00:23:17,080 --> 00:23:24,159
event at i/o and if you want to do gtk

00:23:20,679 --> 00:23:27,700
and nodejs sorry not supported if you

00:23:24,159 --> 00:23:31,450
want to do cute in a no Jess sorry not

00:23:27,700 --> 00:23:34,360
supported if you want to program a Mac

00:23:31,450 --> 00:23:35,320
user interface sorry not support it you

00:23:34,360 --> 00:23:37,809
sort of get where I'm going with this

00:23:35,320 --> 00:23:39,700
they've picked the Mitch and that niche

00:23:37,809 --> 00:23:41,590
is probably a pretty good niche and has

00:23:39,700 --> 00:23:43,570
a lot of people that are interested but

00:23:41,590 --> 00:23:45,820
it means that if you want to then expand

00:23:43,570 --> 00:23:47,710
beyond what that niche is you face a lot

00:23:45,820 --> 00:23:49,659
of pain because there's a lot of things

00:23:47,710 --> 00:23:51,700
that they've made design choices where

00:23:49,659 --> 00:23:52,899
you can't actually Mitch it mix and

00:23:51,700 --> 00:23:55,240
match from all of those different

00:23:52,899 --> 00:23:58,059
programming areas so imagine the case

00:23:55,240 --> 00:24:00,129
and perhaps my HTTP and IRC example is a

00:23:58,059 --> 00:24:04,779
bad one but imagine in a case where you

00:24:00,129 --> 00:24:07,119
had no DJ s with a HTTP module and you

00:24:04,779 --> 00:24:09,059
had some other project with an IRC

00:24:07,119 --> 00:24:11,710
module and you can't use them together

00:24:09,059 --> 00:24:13,389
right that that cool hack that you did

00:24:11,710 --> 00:24:15,789
to download something from a website and

00:24:13,389 --> 00:24:18,820
post it to an IRC channel can't work

00:24:15,789 --> 00:24:23,259
because you have these separate our

00:24:18,820 --> 00:24:24,320
setup so here's just a list of some of

00:24:23,259 --> 00:24:26,659
the more prominent

00:24:24,320 --> 00:24:27,740
out of browser JavaScript projects and

00:24:26,659 --> 00:24:30,620
you can see that there's actually quite

00:24:27,740 --> 00:24:32,360
a few of them each one of them has their

00:24:30,620 --> 00:24:34,130
own niche I'll just pick out a few of

00:24:32,360 --> 00:24:35,990
them I've already mentioned nodejs and

00:24:34,130 --> 00:24:39,409
their niche is a vented io for

00:24:35,990 --> 00:24:45,919
JavaScript you have underneath it v8 cgi

00:24:39,409 --> 00:24:49,669
can anybody guess what v8 cgi does it

00:24:45,919 --> 00:24:53,809
does cgi its javascript for cgi right

00:24:49,669 --> 00:24:58,190
and if you want to use v8 cgi to do a

00:24:53,809 --> 00:25:00,769
vented io for JavaScript can you kind of

00:24:58,190 --> 00:25:02,950
maybe but you're not gonna be able to

00:25:00,769 --> 00:25:06,710
use all the cool stuff from no das ok

00:25:02,950 --> 00:25:09,049
what about MongoDB mongodb by the way is

00:25:06,710 --> 00:25:10,759
a project that I'm particularly a fan of

00:25:09,049 --> 00:25:12,830
it's a database that allows you to

00:25:10,759 --> 00:25:14,600
school store Jason objects and they have

00:25:12,830 --> 00:25:16,789
a nice little JavaScript shell that does

00:25:14,600 --> 00:25:19,309
a bunch of stuff so let's say I'm

00:25:16,789 --> 00:25:23,169
running MongoDB and I want to import

00:25:19,309 --> 00:25:27,769
that cool module that I had on v8 CGI oh

00:25:23,169 --> 00:25:30,679
I can so you can see sort of the problem

00:25:27,769 --> 00:25:32,389
here there's a lot of fragmentation each

00:25:30,679 --> 00:25:35,330
one of these has a different engine and

00:25:32,389 --> 00:25:37,309
a different module loader which means

00:25:35,330 --> 00:25:39,830
that none of them are compatible with

00:25:37,309 --> 00:25:42,139
one another does this remind you of a

00:25:39,830 --> 00:25:43,460
certain day back in the 70s when your

00:25:42,139 --> 00:25:45,620
computer's wouldn't talk to one another

00:25:43,460 --> 00:25:47,419
I mean really are we going to accept

00:25:45,620 --> 00:25:52,220
this in our modern age I I would really

00:25:47,419 --> 00:25:54,320
hope not so returning to this we see

00:25:52,220 --> 00:25:56,029
that the the top priorities for these

00:25:54,320 --> 00:25:57,919
projects on the bottom or really don't

00:25:56,029 --> 00:25:59,779
make sense you don't want to pick an

00:25:57,919 --> 00:26:03,379
engine and you don't want to just pick a

00:25:59,779 --> 00:26:05,389
module loader out of nowhere so

00:26:03,379 --> 00:26:07,759
fortunately there's this project called

00:26:05,389 --> 00:26:09,409
commonjs and you can get two more

00:26:07,759 --> 00:26:13,370
information about common jas at common

00:26:09,409 --> 00:26:16,159
J's org it was founded in 2009 and the

00:26:13,370 --> 00:26:18,440
goal of junk come and Jas is to develop

00:26:16,159 --> 00:26:20,600
a standard module system this is the

00:26:18,440 --> 00:26:23,000
module loader itself that loads the

00:26:20,600 --> 00:26:24,980
modules and the goal here is that all

00:26:23,000 --> 00:26:28,850
the modules from one project should work

00:26:24,980 --> 00:26:30,500
on another project it also attempts to

00:26:28,850 --> 00:26:33,590
establish a standard library

00:26:30,500 --> 00:26:35,240
specification now you would think that

00:26:33,590 --> 00:26:36,920
because there's a standard library

00:26:35,240 --> 00:26:39,530
specification and a common

00:26:36,920 --> 00:26:41,810
dual system that you could use all of

00:26:39,530 --> 00:26:43,220
the modules on any of the other projects

00:26:41,810 --> 00:26:45,680
we're going to find out that that's not

00:26:43,220 --> 00:26:48,740
true here in a moment come and Jas is

00:26:45,680 --> 00:26:50,000
gaining fairly broad adoption but i

00:26:48,740 --> 00:26:52,580
think that the adoption that it's

00:26:50,000 --> 00:26:54,650
receiving is not really based upon the

00:26:52,580 --> 00:26:57,650
fact that it's a good standard but that

00:26:54,650 --> 00:27:00,200
it's the only standard it's focused on

00:26:57,650 --> 00:27:04,190
non native code which means that if you

00:27:00,200 --> 00:27:06,170
write a module in pure JavaScript in one

00:27:04,190 --> 00:27:07,460
place you can import it in another and

00:27:06,170 --> 00:27:09,440
that actually is a big benefit

00:27:07,460 --> 00:27:11,990
unfortunately it's not the hard problem

00:27:09,440 --> 00:27:14,420
that's the easy problem it's easy to

00:27:11,990 --> 00:27:17,360
open a file and evaluate javascript

00:27:14,420 --> 00:27:19,700
that's super simple what's hard is

00:27:17,360 --> 00:27:21,500
actually making compatibility for the

00:27:19,700 --> 00:27:24,710
native layer underneath it and

00:27:21,500 --> 00:27:26,720
unfortunately commonjs is very

00:27:24,710 --> 00:27:29,600
minimalistic and it's under documented

00:27:26,720 --> 00:27:31,430
at times it alleviates somewhat but it

00:27:29,600 --> 00:27:33,920
doesn't solve the fragmentation problems

00:27:31,430 --> 00:27:35,930
and it's mostly focused on synchronous

00:27:33,920 --> 00:27:39,020
operations I forgot to mention its

00:27:35,930 --> 00:27:40,520
focused on focus on non native code like

00:27:39,020 --> 00:27:42,650
I said you can load a JavaScript module

00:27:40,520 --> 00:27:44,390
but there for common J's there is no

00:27:42,650 --> 00:27:46,130
specification for what should happen if

00:27:44,390 --> 00:27:51,200
that module needs to interact with I

00:27:46,130 --> 00:27:53,270
don't know say C or C++ now how much how

00:27:51,200 --> 00:27:55,990
many out of the browser modules are

00:27:53,270 --> 00:27:59,060
there in JavaScript well there's some

00:27:55,990 --> 00:28:02,810
how many see libraries are there out

00:27:59,060 --> 00:28:04,280
there right there's a lot of C code out

00:28:02,810 --> 00:28:06,050
there and if you think we're going to

00:28:04,280 --> 00:28:08,630
re-implement all of that C code in

00:28:06,050 --> 00:28:10,790
JavaScript you're absolutely nuts the

00:28:08,630 --> 00:28:13,340
real problem we have to solve is not

00:28:10,790 --> 00:28:16,220
just simply loading some JavaScript and

00:28:13,340 --> 00:28:19,820
evaluating it we have to solve the the

00:28:16,220 --> 00:28:24,650
native API so the current state of our

00:28:19,820 --> 00:28:26,420
ecosystem is engine fragmentation let's

00:28:24,650 --> 00:28:28,310
take let's take one particular example

00:28:26,420 --> 00:28:30,500
of this and that is we want to write a

00:28:28,310 --> 00:28:32,720
javascript application that connects to

00:28:30,500 --> 00:28:34,040
my sequel pretty straightforward right a

00:28:32,720 --> 00:28:36,680
lot of people are going to want to do

00:28:34,040 --> 00:28:37,790
this so they pick one of their going

00:28:36,680 --> 00:28:40,640
back here they pick one of their

00:28:37,790 --> 00:28:42,170
projects and how many of these by the

00:28:40,640 --> 00:28:47,330
way do you think actually have my sequel

00:28:42,170 --> 00:28:49,580
modules I think it's only two I think

00:28:47,330 --> 00:28:51,010
it's only two right so what's let's

00:28:49,580 --> 00:28:53,090
assume that you have

00:28:51,010 --> 00:28:54,290
lets you assume you've chosen one of

00:28:53,090 --> 00:28:56,240
these projects to work with and it

00:28:54,290 --> 00:28:58,910
doesn't have a my sequel module well

00:28:56,240 --> 00:29:00,140
let's write one and normally we would

00:28:58,910 --> 00:29:01,700
write one and then we would share it

00:29:00,140 --> 00:29:03,620
everywhere in the ecosystem right this

00:29:01,700 --> 00:29:06,590
is the way Python works this is the way

00:29:03,620 --> 00:29:08,480
Ruby works this is the way PHP works but

00:29:06,590 --> 00:29:11,000
why doesn't JavaScript work this way

00:29:08,480 --> 00:29:12,320
well the first problem is remember will

00:29:11,000 --> 00:29:14,990
the first thing they did was pick an

00:29:12,320 --> 00:29:17,600
engine well what that means that each of

00:29:14,990 --> 00:29:19,490
these projects is tied to the engine v8

00:29:17,600 --> 00:29:21,200
spidermonkey javascriptcore or rhino

00:29:19,490 --> 00:29:23,690
that means you get to write the module

00:29:21,200 --> 00:29:25,790
four times I don't know how many of you

00:29:23,690 --> 00:29:27,470
but if are going to write a module four

00:29:25,790 --> 00:29:29,330
times and then try to keep it actually

00:29:27,470 --> 00:29:31,790
maintained that that's never going to

00:29:29,330 --> 00:29:34,240
scale not in a volunteer environment the

00:29:31,790 --> 00:29:36,890
problem is it actually gets worse

00:29:34,240 --> 00:29:39,920
because because each project has

00:29:36,890 --> 00:29:41,330
basically said okay we're going to we're

00:29:39,920 --> 00:29:44,020
going to create a module loader which is

00:29:41,330 --> 00:29:47,360
that ability to import import modules

00:29:44,020 --> 00:29:49,670
they're all different and so in the case

00:29:47,360 --> 00:29:51,830
of our mics my sequel database driver

00:29:49,670 --> 00:29:54,770
each JavaScript project has its own

00:29:51,830 --> 00:29:58,040
module loader and common jf says nothing

00:29:54,770 --> 00:30:00,950
about native code interop so what this

00:29:58,040 --> 00:30:03,260
means is that you have a vastly

00:30:00,950 --> 00:30:05,000
expanding number of my sequel modules

00:30:03,260 --> 00:30:06,440
that you need to write so the number of

00:30:05,000 --> 00:30:08,090
my sequel modules that you need to write

00:30:06,440 --> 00:30:12,530
is actually the number of engines that

00:30:08,090 --> 00:30:14,840
are available times the number of module

00:30:12,530 --> 00:30:17,090
loader implementations that there are so

00:30:14,840 --> 00:30:20,120
in our case let's go back to this list

00:30:17,090 --> 00:30:22,460
there's at least ten projects here right

00:30:20,120 --> 00:30:23,750
you have four engines times 10 projects

00:30:22,460 --> 00:30:27,470
means you have to write the my sequel

00:30:23,750 --> 00:30:29,180
module 40 times does anybody know

00:30:27,470 --> 00:30:33,290
anywhere where there's somebody doing

00:30:29,180 --> 00:30:35,540
this successfully no it doesn't work ok

00:30:33,290 --> 00:30:38,210
so maybe it's not that bad you could

00:30:35,540 --> 00:30:41,420
actually perhaps you know right a module

00:30:38,210 --> 00:30:43,070
and native code on one engine and then

00:30:41,420 --> 00:30:45,350
maybe have some if deaths to handle a

00:30:43,070 --> 00:30:46,910
couple different module loaders so maybe

00:30:45,350 --> 00:30:50,290
it's not as bad as the picture that I've

00:30:46,910 --> 00:30:54,350
painted here but it is still pretty bad

00:30:50,290 --> 00:30:56,090
we also have another problem here does

00:30:54,350 --> 00:30:57,650
anybody remember what the number one

00:30:56,090 --> 00:31:02,120
feature was that I touted about

00:30:57,650 --> 00:31:04,610
JavaScript security it's the most secure

00:31:02,120 --> 00:31:06,890
language ever it runs trillions upon

00:31:04,610 --> 00:31:09,049
millions of lines of untrusted code and

00:31:06,890 --> 00:31:10,400
so people when they have decided they

00:31:09,049 --> 00:31:13,160
want to use JavaScript outside of the

00:31:10,400 --> 00:31:14,750
browser they say the first thing they

00:31:13,160 --> 00:31:18,020
say is yeah we want to have modules so

00:31:14,750 --> 00:31:21,020
they say yeah we broke the sandbox oh my

00:31:18,020 --> 00:31:22,100
god we just broke the sandbox right

00:31:21,020 --> 00:31:24,080
because they haven't thought about

00:31:22,100 --> 00:31:26,360
security up front they haven't thought

00:31:24,080 --> 00:31:28,700
about what happens if you can just load

00:31:26,360 --> 00:31:31,490
native code into your sandbox at any

00:31:28,700 --> 00:31:32,470
time with no restrictions and to my

00:31:31,490 --> 00:31:34,820
knowledge there is not a single

00:31:32,470 --> 00:31:36,890
JavaScript out of the browser JavaScript

00:31:34,820 --> 00:31:38,960
project that has any restrictions

00:31:36,890 --> 00:31:43,309
whatsoever on how modules are loaded

00:31:38,960 --> 00:31:45,380
that is a security nightmare we need a

00:31:43,309 --> 00:31:48,140
policy for which modules are allowed in

00:31:45,380 --> 00:31:51,559
the sandbox and what they are allowed to

00:31:48,140 --> 00:31:53,679
do and how to configure them let's give

00:31:51,559 --> 00:31:57,350
an example going back to our my sequel

00:31:53,679 --> 00:31:58,790
example here we we require the my sequel

00:31:57,350 --> 00:32:01,040
module and this imports the the my

00:31:58,790 --> 00:32:03,110
sequel module and then we want to

00:32:01,040 --> 00:32:04,940
connect to a database so how many people

00:32:03,110 --> 00:32:07,429
have seen something like this in code

00:32:04,940 --> 00:32:09,049
somewhere right if you're a PHP

00:32:07,429 --> 00:32:11,660
programmer you've probably seen this

00:32:09,049 --> 00:32:13,490
pattern everywhere we want to connect to

00:32:11,660 --> 00:32:15,850
a database so write our password into

00:32:13,490 --> 00:32:17,900
the source code should that be allowed

00:32:15,850 --> 00:32:20,030
that's ridiculous why would you put a

00:32:17,900 --> 00:32:21,140
password in source code check it into a

00:32:20,030 --> 00:32:22,910
revision control what happens if

00:32:21,140 --> 00:32:24,230
somebody hacks your revision control now

00:32:22,910 --> 00:32:26,960
they have the password for your database

00:32:24,230 --> 00:32:28,730
that's utterly ridiculous so should the

00:32:26,960 --> 00:32:30,200
should the anti-pattern be allowed no

00:32:28,730 --> 00:32:32,840
absolutely not you should design for

00:32:30,200 --> 00:32:36,290
security up front so in this example

00:32:32,840 --> 00:32:39,200
here this does the exact same thing but

00:32:36,290 --> 00:32:40,429
where'd all that configuration go we've

00:32:39,200 --> 00:32:42,890
actually made the configuration

00:32:40,429 --> 00:32:45,620
orthogonal to the code right so that

00:32:42,890 --> 00:32:47,450
when you run this you specify here is my

00:32:45,620 --> 00:32:48,740
my sequel configuration and then when it

00:32:47,450 --> 00:32:50,450
gets to the point where it connects to

00:32:48,740 --> 00:32:52,490
my sequel it just calls connect and

00:32:50,450 --> 00:32:57,620
doesn't need to have passwords and

00:32:52,490 --> 00:32:59,990
usernames and ports inside the code we

00:32:57,620 --> 00:33:03,169
also have a problem of native type

00:32:59,990 --> 00:33:06,140
security all engines allow private

00:33:03,169 --> 00:33:08,660
pointers and the idea here is that when

00:33:06,140 --> 00:33:10,370
you are interacting with native code you

00:33:08,660 --> 00:33:12,650
will have some kind of a pointer that

00:33:10,370 --> 00:33:14,720
represents state and you need to pass

00:33:12,650 --> 00:33:17,059
that state around inside the JavaScript

00:33:14,720 --> 00:33:17,910
sandbox but putting the actual pointer

00:33:17,059 --> 00:33:19,410
in

00:33:17,910 --> 00:33:20,720
meet the JavaScript sandbox has all

00:33:19,410 --> 00:33:25,410
kinds of really bad security

00:33:20,720 --> 00:33:26,910
implications and so one of the things

00:33:25,410 --> 00:33:29,460
that allows you to do is that from the

00:33:26,910 --> 00:33:31,290
capi you can actually hide a pointer

00:33:29,460 --> 00:33:32,730
inside an object now when you're messing

00:33:31,290 --> 00:33:36,690
around with that object inside

00:33:32,730 --> 00:33:37,800
JavaScript all that you can see is the

00:33:36,690 --> 00:33:38,910
object you can't see that there's a

00:33:37,800 --> 00:33:40,530
pointer you don't even know that there's

00:33:38,910 --> 00:33:42,060
a pointer actually there but what

00:33:40,530 --> 00:33:44,430
happens is then you can pass that

00:33:42,060 --> 00:33:46,050
JavaScript object into a function and if

00:33:44,430 --> 00:33:47,910
that function is native code it can

00:33:46,050 --> 00:33:49,890
actually pull out that pointer and

00:33:47,910 --> 00:33:53,100
resume the state of whatever the

00:33:49,890 --> 00:33:56,310
operation was so in the case we have

00:33:53,100 --> 00:33:58,560
here usually it's just you have some

00:33:56,310 --> 00:34:00,720
JavaScript object on the top and you

00:33:58,560 --> 00:34:02,250
call get pointer and it gives you the

00:34:00,720 --> 00:34:06,210
pointer because you can only generally

00:34:02,250 --> 00:34:09,080
store one pointer in a given object well

00:34:06,210 --> 00:34:12,770
this has huge security implement

00:34:09,080 --> 00:34:15,500
implications what type is the pointer

00:34:12,770 --> 00:34:18,900
given given the example I've shown here

00:34:15,500 --> 00:34:22,080
let's say that you import the XML object

00:34:18,900 --> 00:34:23,580
and you make a new XML object so you

00:34:22,080 --> 00:34:27,150
have that object there at stored in in

00:34:23,580 --> 00:34:29,790
obj and then you import my sequel and

00:34:27,150 --> 00:34:35,250
you connect and you pass the object as

00:34:29,790 --> 00:34:38,070
this into the connect function does that

00:34:35,250 --> 00:34:41,640
native code have any understanding of

00:34:38,070 --> 00:34:44,940
what type that pointer is not at all so

00:34:41,640 --> 00:34:47,820
if you're lucky if you're lucky you'll

00:34:44,940 --> 00:34:49,470
get a crash and that's it and that's a

00:34:47,820 --> 00:34:51,480
that's it by the way if you've not done

00:34:49,470 --> 00:34:53,400
all kinds of checking which is usually

00:34:51,480 --> 00:34:56,070
like 20 lines of checking for every

00:34:53,400 --> 00:34:58,260
pointer you want to manage if you're

00:34:56,070 --> 00:35:01,530
lucky you get a crash if you're unlucky

00:34:58,260 --> 00:35:04,440
you have a security breach right because

00:35:01,530 --> 00:35:07,530
all of a sudden i have written text

00:35:04,440 --> 00:35:09,450
inside of my xml objects and i pass it

00:35:07,530 --> 00:35:11,130
in to the my sequel object and the my

00:35:09,450 --> 00:35:15,300
sequel objects attempts to execute that

00:35:11,130 --> 00:35:17,550
text so the problem here is that because

00:35:15,300 --> 00:35:20,040
people haven't thought ahead of how they

00:35:17,550 --> 00:35:21,780
should implement their pointers you have

00:35:20,040 --> 00:35:23,220
a huge security problem that if they if

00:35:21,780 --> 00:35:26,310
the program are using the JavaScript

00:35:23,220 --> 00:35:28,200
engine is not entirely vigilant at every

00:35:26,310 --> 00:35:29,850
single step of the way with every

00:35:28,200 --> 00:35:31,160
pointer that they manage which is by the

00:35:29,850 --> 00:35:32,510
way a lot

00:35:31,160 --> 00:35:34,400
then they're going to have security

00:35:32,510 --> 00:35:38,510
holes and that and that needs to be

00:35:34,400 --> 00:35:42,380
fixed so coming to a conclusion here the

00:35:38,510 --> 00:35:44,420
ecosystem is has is highly fragmented

00:35:42,380 --> 00:35:47,810
and it makes code reuse impossible

00:35:44,420 --> 00:35:49,340
module loaders also break the number one

00:35:47,810 --> 00:35:51,950
feature of JavaScript which is the

00:35:49,340 --> 00:35:54,260
sandbox and generally speaking security

00:35:51,950 --> 00:35:56,570
is an afterthought so this to me is a

00:35:54,260 --> 00:35:58,130
really romantic estate for a language

00:35:56,570 --> 00:36:04,430
that's really the most secure language

00:35:58,130 --> 00:36:07,040
ever hi this is natty natty is not

00:36:04,430 --> 00:36:08,360
related to a narwhal so you should just

00:36:07,040 --> 00:36:11,510
you should be aware of that right there

00:36:08,360 --> 00:36:12,830
Nattie is the mascot for my pet project

00:36:11,510 --> 00:36:16,640
which I'm here to talk to you about

00:36:12,830 --> 00:36:19,400
which is called not choose not to is a

00:36:16,640 --> 00:36:22,010
secure by design JavaScript meta engine

00:36:19,400 --> 00:36:24,680
it's MIT licensed and you can see the

00:36:22,010 --> 00:36:30,220
website they're not use projects calm

00:36:24,680 --> 00:36:32,030
and the code is on github com /not tous

00:36:30,220 --> 00:36:33,590
we're going to talk a little bit about

00:36:32,030 --> 00:36:35,060
how knox works let me get through this

00:36:33,590 --> 00:36:37,160
and we'll sort of circle back and talk

00:36:35,060 --> 00:36:40,160
about the items in detail it's in its

00:36:37,160 --> 00:36:42,220
engine agnostic C++ Java Script API and

00:36:40,160 --> 00:36:44,570
I hope to get stable pretty soon

00:36:42,220 --> 00:36:46,640
everything does work right now and

00:36:44,570 --> 00:36:48,680
there's still a little bit of cleanup I

00:36:46,640 --> 00:36:51,440
want to do but for the most part the

00:36:48,680 --> 00:36:53,530
core is pretty stable it supports

00:36:51,440 --> 00:36:56,420
spidermonkey javascriptcore and v8

00:36:53,530 --> 00:36:58,430
doesn't support rhino but if somebody

00:36:56,420 --> 00:37:03,620
wanted to write that patch I'd probably

00:36:58,430 --> 00:37:06,350
be willing to take it it is if you're

00:37:03,620 --> 00:37:09,650
using the C++ API by the way I have both

00:37:06,350 --> 00:37:12,200
AC and a C++ API in it and it follows

00:37:09,650 --> 00:37:15,290
native conventions for both languages if

00:37:12,200 --> 00:37:17,540
you're using the C++ API just like v8

00:37:15,290 --> 00:37:19,250
the scope is managed on the stack which

00:37:17,540 --> 00:37:21,080
allows you to not have to worry about

00:37:19,250 --> 00:37:24,920
things it means that the C++ program

00:37:21,080 --> 00:37:27,590
feels very scripted it also has a red

00:37:24,920 --> 00:37:29,390
line enable repple aka a JavaScript

00:37:27,590 --> 00:37:31,460
shell this is what allows you to

00:37:29,390 --> 00:37:37,220
actually you know type in JavaScript on

00:37:31,460 --> 00:37:38,720
your linux box or your mac box we have

00:37:37,220 --> 00:37:40,670
language bindings actually this

00:37:38,720 --> 00:37:42,770
statement is a lie we do have python

00:37:40,670 --> 00:37:44,090
bindings but i broke some stuff in the

00:37:42,770 --> 00:37:45,770
latest version and i need to

00:37:44,090 --> 00:37:49,550
stem so they're currently broken but

00:37:45,770 --> 00:37:52,400
they'll be fixed shortish it has a

00:37:49,550 --> 00:37:54,130
secure by design module loader the

00:37:52,400 --> 00:37:56,990
module loader permits things like

00:37:54,130 --> 00:37:58,940
whitelisting we do out of band

00:37:56,990 --> 00:38:01,310
configuration so this is where you take

00:37:58,940 --> 00:38:02,840
the passwords out of your code right

00:38:01,310 --> 00:38:04,940
store them in a net and out of band

00:38:02,840 --> 00:38:07,460
configuration and then when you when you

00:38:04,940 --> 00:38:09,020
call that connect function you just you

00:38:07,460 --> 00:38:10,670
just connect it and modules can use that

00:38:09,020 --> 00:38:12,110
out of band configuration right so they

00:38:10,670 --> 00:38:15,890
can propose their own configuration

00:38:12,110 --> 00:38:17,660
going forward we have names the name

00:38:15,890 --> 00:38:20,330
spaced and typed pointers which we're

00:38:17,660 --> 00:38:22,640
going to talk about in a moment and we

00:38:20,330 --> 00:38:27,470
are slowly implementing Common j/s

00:38:22,640 --> 00:38:29,930
modules so this is this is how not to

00:38:27,470 --> 00:38:31,790
sparks on the bottom you have the three

00:38:29,930 --> 00:38:33,530
main engines that we've talked about v8

00:38:31,790 --> 00:38:36,080
JavaScript core and spider monkey and

00:38:33,530 --> 00:38:38,900
the first thing that not to stus in lib

00:38:36,080 --> 00:38:40,370
mateus is provide an API abstraction now

00:38:38,900 --> 00:38:42,740
if you're an application and you don't

00:38:40,370 --> 00:38:44,900
care about modules all you want to do is

00:38:42,740 --> 00:38:46,760
provide some in scripting for your

00:38:44,900 --> 00:38:48,230
application built in scripting for your

00:38:46,760 --> 00:38:50,030
application in JavaScript but you don't

00:38:48,230 --> 00:38:51,800
want the ability to load modules you can

00:38:50,030 --> 00:38:55,970
use this API abstraction layer directly

00:38:51,800 --> 00:38:57,500
in your application however as most

00:38:55,970 --> 00:38:59,180
people are probably going to want to do

00:38:57,500 --> 00:39:01,850
they'll probably going to want to use

00:38:59,180 --> 00:39:03,230
modules right and then really nice thing

00:39:01,850 --> 00:39:05,270
is that you should be able to use those

00:39:03,230 --> 00:39:06,230
modules in the not-too shell you should

00:39:05,270 --> 00:39:07,610
be able to use them in custom

00:39:06,230 --> 00:39:09,650
applications that are built on top of

00:39:07,610 --> 00:39:12,020
not tues and you should be able to use

00:39:09,650 --> 00:39:15,680
them in things like mod not tues for for

00:39:12,020 --> 00:39:18,080
apache or or any other place so we've

00:39:15,680 --> 00:39:20,510
also developed a module loader and the

00:39:18,080 --> 00:39:24,200
module loader does try as best as we are

00:39:20,510 --> 00:39:25,790
able to comply to the commonjs spec but

00:39:24,200 --> 00:39:28,010
the really really interesting thing is

00:39:25,790 --> 00:39:30,710
that the module loader uses the not use

00:39:28,010 --> 00:39:32,690
API abstraction layer this means that if

00:39:30,710 --> 00:39:35,990
you write on my sequel module how many

00:39:32,690 --> 00:39:39,170
times you have to write it once and it

00:39:35,990 --> 00:39:40,580
runs on all the engines and in so you

00:39:39,170 --> 00:39:43,190
don't have this this huge amount of

00:39:40,580 --> 00:39:45,830
fragmentation then built on top of that

00:39:43,190 --> 00:39:47,360
you can implement your modules and you

00:39:45,830 --> 00:39:49,490
can have a JavaScript shell and then you

00:39:47,360 --> 00:39:50,660
can run applications up on top of there

00:39:49,490 --> 00:39:53,540
as well so you could have an application

00:39:50,660 --> 00:39:58,450
that runs in the shell it will and uses

00:39:53,540 --> 00:39:58,450
the modules any questions about this

00:39:58,720 --> 00:40:03,050
so here's an example and this is the the

00:40:01,520 --> 00:40:06,470
biggest code example you're going to get

00:40:03,050 --> 00:40:08,690
for the day this is an example of how to

00:40:06,470 --> 00:40:11,840
use not to so we create this engine

00:40:08,690 --> 00:40:15,890
object on the top this is the C++ API by

00:40:11,840 --> 00:40:17,450
the way and then we initialize it notice

00:40:15,890 --> 00:40:21,230
that we're passing in a string that says

00:40:17,450 --> 00:40:22,670
v8 you can pass in here a string that

00:40:21,230 --> 00:40:24,380
says spidermonkey you can pass in a

00:40:22,670 --> 00:40:26,480
string that says javascriptcore or you

00:40:24,380 --> 00:40:29,060
can actually pass null here and not

00:40:26,480 --> 00:40:31,240
juice will do some pretty cool stuff the

00:40:29,060 --> 00:40:33,710
first thing that will actually do is

00:40:31,240 --> 00:40:36,530
attempt to determine if you're already

00:40:33,710 --> 00:40:38,630
linked to a JavaScript library through

00:40:36,530 --> 00:40:41,420
any other mechanism right so let's say

00:40:38,630 --> 00:40:44,420
in my application I've linked against

00:40:41,420 --> 00:40:46,730
WebKit because I want to use the webkit

00:40:44,420 --> 00:40:49,520
browser but then I also want to use not

00:40:46,730 --> 00:40:51,020
use modules if you pass null here not

00:40:49,520 --> 00:40:53,090
tues will detect that you're already

00:40:51,020 --> 00:40:55,130
linked against WebKit and then we'll

00:40:53,090 --> 00:40:59,150
choose the JavaScript core module for

00:40:55,130 --> 00:41:01,280
you then what you do once you have an

00:40:59,150 --> 00:41:04,400
engine this engine is is the context for

00:41:01,280 --> 00:41:07,070
a particular engine on the bottom there

00:41:04,400 --> 00:41:09,350
in the previous slide you create a new

00:41:07,070 --> 00:41:10,850
global and a new global is a global

00:41:09,350 --> 00:41:12,650
object and that represents a sandbox

00:41:10,850 --> 00:41:14,810
anything you put inside of the sandbox

00:41:12,650 --> 00:41:17,840
is available to JavaScript anything

00:41:14,810 --> 00:41:20,720
that's not inside the sandbox is is is

00:41:17,840 --> 00:41:22,880
that not in the global so here we use

00:41:20,720 --> 00:41:25,430
our global to evaluate some JavaScript

00:41:22,880 --> 00:41:27,290
we create a variable that X that's equal

00:41:25,430 --> 00:41:29,270
to 15 and the interesting thing is that

00:41:27,290 --> 00:41:32,180
we get a result back and we can convert

00:41:29,270 --> 00:41:36,590
that that result into a negative or a

00:41:32,180 --> 00:41:38,090
native integer in C++ we also have a

00:41:36,590 --> 00:41:40,040
require system remember I talked about

00:41:38,090 --> 00:41:44,150
the module loader it's called require

00:41:40,040 --> 00:41:45,950
and you initialize the module system and

00:41:44,150 --> 00:41:47,510
that that second line is the important

00:41:45,950 --> 00:41:48,950
one for that out-of-band configuration

00:41:47,510 --> 00:41:50,150
where it says my config we're going to

00:41:48,950 --> 00:41:53,210
talk about this in detail in a minute

00:41:50,150 --> 00:41:54,860
but the my config represents that

00:41:53,210 --> 00:41:57,080
out-of-band configuration that you can

00:41:54,860 --> 00:41:58,700
pass in that configuration can be used

00:41:57,080 --> 00:42:02,990
by any of the modules that are actually

00:41:58,700 --> 00:42:04,520
loaded into the system so in this

00:42:02,990 --> 00:42:07,160
example we're going to load a module and

00:42:04,520 --> 00:42:08,630
then the last one on the bottom we're

00:42:07,160 --> 00:42:10,410
going to load that same exact module

00:42:08,630 --> 00:42:12,390
we're going to do it using

00:42:10,410 --> 00:42:14,490
do it using javascript rather than

00:42:12,390 --> 00:42:19,410
native code so those last two statements

00:42:14,490 --> 00:42:21,869
are the same overall it's pretty simple

00:42:19,410 --> 00:42:25,369
I mean we we booted up a JavaScript

00:42:21,869 --> 00:42:28,829
environment in what four lines of code

00:42:25,369 --> 00:42:31,049
but that's not bad and it's compatible

00:42:28,829 --> 00:42:36,180
it works on all the engines and we have

00:42:31,049 --> 00:42:37,559
any questions about this I'll leave it

00:42:36,180 --> 00:42:39,150
up here for a second just to sort of let

00:42:37,559 --> 00:42:52,549
it soak in I know I know people are

00:42:39,150 --> 00:42:55,470
reading it yeah the this one here sure

00:42:52,549 --> 00:42:58,890
these slides will be available on my

00:42:55,470 --> 00:43:00,030
blog by the way actually I should

00:42:58,890 --> 00:43:01,890
probably just put up on the website I'll

00:43:00,030 --> 00:43:13,099
put them up on the website in the next

00:43:01,890 --> 00:43:13,099
24 hours or so not use project com yeah

00:43:14,450 --> 00:43:19,799
okay so one of the things that we do is

00:43:17,700 --> 00:43:21,299
namespace pointers and if you remember

00:43:19,799 --> 00:43:22,440
back to the exemplar was talking about

00:43:21,299 --> 00:43:24,210
before in all of the underlying

00:43:22,440 --> 00:43:26,250
JavaScript engines you can save a

00:43:24,210 --> 00:43:28,289
pointer into an object but you lose the

00:43:26,250 --> 00:43:30,809
type of the pointer and because there's

00:43:28,289 --> 00:43:33,480
only one in most of the engines there's

00:43:30,809 --> 00:43:35,910
only one pointer private plaintiff per

00:43:33,480 --> 00:43:37,829
object if somebody passes in an object

00:43:35,910 --> 00:43:40,260
with some pointer that to some memory

00:43:37,829 --> 00:43:41,549
that you don't know what what it is you

00:43:40,260 --> 00:43:43,440
have a real security problem and you're

00:43:41,549 --> 00:43:46,950
probably going to get crashes and you're

00:43:43,440 --> 00:43:49,230
probably going to get security holes so

00:43:46,950 --> 00:43:53,190
not to save this by putting every

00:43:49,230 --> 00:43:54,750
pointer into a namespace and so if you

00:43:53,190 --> 00:43:56,160
want to store five different pointers

00:43:54,750 --> 00:43:59,369
just give them five different namespaces

00:43:56,160 --> 00:44:01,859
and then you can pull out that pointer

00:43:59,369 --> 00:44:03,750
by the namespace later on this means

00:44:01,859 --> 00:44:06,299
that the pointer is always the pointer

00:44:03,750 --> 00:44:08,640
you expect it to be and this is just a

00:44:06,299 --> 00:44:10,589
native part of the API right you don't

00:44:08,640 --> 00:44:13,730
have to do any extra coat on top of it

00:44:10,589 --> 00:44:18,119
we basically given you security for free

00:44:13,730 --> 00:44:20,309
however that's not all in 0 to 1 our

00:44:18,119 --> 00:44:22,799
latest release we also just released a

00:44:20,309 --> 00:44:24,320
typed pointer implementation and you can

00:44:22,799 --> 00:44:28,070
see here on the top example we

00:44:24,320 --> 00:44:32,840
store AG object pointer and then later

00:44:28,070 --> 00:44:34,910
we retrieve that G object pointer notice

00:44:32,840 --> 00:44:38,300
the last line on the bottom when we try

00:44:34,910 --> 00:44:39,650
to get a char star pointer there is no

00:44:38,300 --> 00:44:41,900
pointer of that type it just returns

00:44:39,650 --> 00:44:44,690
null because we've never stored one in

00:44:41,900 --> 00:44:47,270
there so this is really helpful because

00:44:44,690 --> 00:44:48,680
it gives you again security up front and

00:44:47,270 --> 00:44:51,800
allow also it allows you to store

00:44:48,680 --> 00:44:53,360
multiple pointers in an object VA does

00:44:51,800 --> 00:44:55,070
allow them does allow you to store

00:44:53,360 --> 00:44:57,560
multiple pointers in an object but

00:44:55,070 --> 00:44:59,750
they're just an array and so you don't

00:44:57,560 --> 00:45:03,380
get any type information like this so

00:44:59,750 --> 00:45:04,850
you don't get the security benefit not

00:45:03,380 --> 00:45:08,300
just also supports out-of-band

00:45:04,850 --> 00:45:09,920
configuration so if we go back to this

00:45:08,300 --> 00:45:13,130
this big example here remember where we

00:45:09,920 --> 00:45:15,080
initialize the module system here and we

00:45:13,130 --> 00:45:17,030
pass in config here we're now going to

00:45:15,080 --> 00:45:25,130
look at exactly what's inside this Mike

00:45:17,030 --> 00:45:27,140
and fig my config is a JSON string so

00:45:25,130 --> 00:45:30,080
most of you are probably familiar we're

00:45:27,140 --> 00:45:31,850
over at least heard of Jason right this

00:45:30,080 --> 00:45:34,460
is a json string and you basically

00:45:31,850 --> 00:45:36,440
create a you basically create a

00:45:34,460 --> 00:45:39,110
hierarchy of jason that gets passed in

00:45:36,440 --> 00:45:40,490
and then modules in their native code we

00:45:39,110 --> 00:45:44,270
don't expose the configuration in the

00:45:40,490 --> 00:45:46,370
sandbox but but the native native code

00:45:44,270 --> 00:45:48,890
can read this configuration as just

00:45:46,370 --> 00:45:50,330
normal JavaScript objects and can

00:45:48,890 --> 00:45:52,370
interact with it now there's there's a

00:45:50,330 --> 00:45:53,900
there's two ways you can actually pass

00:45:52,370 --> 00:45:55,370
in this configuration the first example

00:45:53,900 --> 00:45:57,710
here is if you were to hard code it in

00:45:55,370 --> 00:45:59,900
native code so when you and when you

00:45:57,710 --> 00:46:03,320
initialize that require system you pass

00:45:59,900 --> 00:46:04,880
in manually some JSON data now that's

00:46:03,320 --> 00:46:06,200
not the way most people are going to use

00:46:04,880 --> 00:46:08,210
it and it's not really the most

00:46:06,200 --> 00:46:10,640
interesting part of the functionality

00:46:08,210 --> 00:46:13,430
but it is therefore betters if you want

00:46:10,640 --> 00:46:14,480
that kind of stuff the way most people

00:46:13,430 --> 00:46:16,010
are going to use it is that they're

00:46:14,480 --> 00:46:18,470
going to be able to set their

00:46:16,010 --> 00:46:20,480
configuration at runtime so in the

00:46:18,470 --> 00:46:24,860
second example here you can see the dash

00:46:20,480 --> 00:46:27,890
C option is my sequel dot host and then

00:46:24,860 --> 00:46:31,040
some Jason value and what will happen

00:46:27,890 --> 00:46:33,740
here is that my sequel dot host will

00:46:31,040 --> 00:46:36,860
actually be set to want the string 127

00:46:33,740 --> 00:46:37,600
dot 0 to 0 dot one user will be set to

00:46:36,860 --> 00:46:39,970
root

00:46:37,600 --> 00:46:42,130
we'll be set to password are to pass and

00:46:39,970 --> 00:46:44,620
port will be set to 3306 and then we

00:46:42,130 --> 00:46:47,440
execute the script right so when that

00:46:44,620 --> 00:46:49,870
script then calls imports the record the

00:46:47,440 --> 00:46:51,070
my sequel module and calls connect it's

00:46:49,870 --> 00:46:53,790
just going to connect to this

00:46:51,070 --> 00:46:57,660
configuration that we've passed it

00:46:53,790 --> 00:46:57,660
everybody in the questions about this

00:46:59,550 --> 00:47:03,820
not juice also has an origin system the

00:47:02,410 --> 00:47:07,960
way that security works in a web browser

00:47:03,820 --> 00:47:09,910
is that the web browser will fetch a

00:47:07,960 --> 00:47:12,370
javascript file that javascript file can

00:47:09,910 --> 00:47:16,420
also do HTTP requests but it is only

00:47:12,370 --> 00:47:18,610
permitted to HTTP request from where the

00:47:16,420 --> 00:47:20,830
pages were fetched from and that's a

00:47:18,610 --> 00:47:23,110
really good security model it doesn't

00:47:20,830 --> 00:47:25,600
exactly translate 100% to not tues but

00:47:23,110 --> 00:47:27,580
we liked the idea of being able to lock

00:47:25,600 --> 00:47:30,580
something down to only talking to a few

00:47:27,580 --> 00:47:32,320
amount of things so normally when you

00:47:30,580 --> 00:47:35,290
execute not use the code runs completely

00:47:32,320 --> 00:47:38,710
unconstrained if you want to connect to

00:47:35,290 --> 00:47:41,170
my sequel you can however you can also

00:47:38,710 --> 00:47:43,170
lock things down notice that we're just

00:47:41,170 --> 00:47:46,330
standing specifying a standard

00:47:43,170 --> 00:47:49,150
configuration mechanism here right c

00:47:46,330 --> 00:47:52,000
dash capital c not to origins dot

00:47:49,150 --> 00:47:56,890
whitelist so we're inserting into the

00:47:52,000 --> 00:48:00,160
origins whitelist this item tcp 1270 20

00:47:56,890 --> 00:48:03,280
colon 1 2 3 4 this means that all

00:48:00,160 --> 00:48:07,300
modules can only because it's a

00:48:03,280 --> 00:48:12,640
whitelist can only connect to local host

00:48:07,300 --> 00:48:14,620
port 1 2 3 4 okay now notice the third

00:48:12,640 --> 00:48:19,150
block here when we try to connect to my

00:48:14,620 --> 00:48:21,940
sequel on port 3306 what do we get we

00:48:19,150 --> 00:48:24,700
don't get success we actually get an

00:48:21,940 --> 00:48:26,710
exception which is a security error it's

00:48:24,700 --> 00:48:28,830
a security error because you that module

00:48:26,710 --> 00:48:31,450
is attempting to communicate with

00:48:28,830 --> 00:48:35,950
something that is that is a that is

00:48:31,450 --> 00:48:37,480
filtered out by the whitelist in the

00:48:35,950 --> 00:48:39,040
native code how this looks and this is

00:48:37,480 --> 00:48:42,160
just an example here on the bottom of

00:48:39,040 --> 00:48:43,660
what this looks like in native code the

00:48:42,160 --> 00:48:44,980
point is if security is hard to

00:48:43,660 --> 00:48:47,110
implement people are going to do it

00:48:44,980 --> 00:48:48,370
wrong so what we what we attempt to do

00:48:47,110 --> 00:48:51,220
is we attempt to make it really really

00:48:48,370 --> 00:48:53,440
easy so we have not to check

00:48:51,220 --> 00:48:56,320
origin and we know that the final name

00:48:53,440 --> 00:48:58,540
that's going to be passed in is in the

00:48:56,320 --> 00:49:01,270
first argument so argument 0 we're going

00:48:58,540 --> 00:49:04,420
to convert it to a C string and we are

00:49:01,270 --> 00:49:07,380
going to join it to the file prefix so

00:49:04,420 --> 00:49:09,369
what this is saying is this function is

00:49:07,380 --> 00:49:11,770
getting a file name in the first

00:49:09,369 --> 00:49:15,340
argument and we want to check with the

00:49:11,770 --> 00:49:18,490
origin system whether or not that that

00:49:15,340 --> 00:49:21,520
file access should be allowed and if not

00:49:18,490 --> 00:49:24,280
it will automatically throw a security

00:49:21,520 --> 00:49:26,740
error for us so you gain security with

00:49:24,280 --> 00:49:27,880
one line again if security is hard to

00:49:26,740 --> 00:49:29,859
implement people are going to do it

00:49:27,880 --> 00:49:35,560
wrong so I figure with one line that's

00:49:29,859 --> 00:49:38,080
about as small as I can make it to go a

00:49:35,560 --> 00:49:39,700
little bit over not tues history we've

00:49:38,080 --> 00:49:42,910
been rapidly developing our first

00:49:39,700 --> 00:49:44,950
release was in December we have four

00:49:42,910 --> 00:49:47,560
releases in december two in February one

00:49:44,950 --> 00:49:50,920
in April one in May and we will probably

00:49:47,560 --> 00:49:53,790
have one in June as well so you can see

00:49:50,920 --> 00:49:55,839
things are developing pretty rapidly

00:49:53,790 --> 00:49:58,780
just to give you an idea of some recent

00:49:55,839 --> 00:50:03,040
history this is just in the last month

00:49:58,780 --> 00:50:04,750
or so 20 was a full rewrite which

00:50:03,040 --> 00:50:07,750
decreased memory usage by seventy five

00:50:04,750 --> 00:50:09,190
percent it's a major new API and it

00:50:07,750 --> 00:50:12,520
should be much easier to use this is

00:50:09,190 --> 00:50:14,170
hopefully the last API rewrite I haven't

00:50:12,520 --> 00:50:15,339
seen any problems so far that would

00:50:14,170 --> 00:50:18,720
indicate to me that we need to do

00:50:15,339 --> 00:50:18,720
anything major from this point forward

00:50:18,869 --> 00:50:24,400
we have a full test suite coverage this

00:50:22,270 --> 00:50:26,920
means that every change in not tus is

00:50:24,400 --> 00:50:28,630
actually run through unit tests and this

00:50:26,920 --> 00:50:32,950
is really important to keep high quality

00:50:28,630 --> 00:50:35,170
in to maintain security modules were

00:50:32,950 --> 00:50:37,420
moved to a separate package in 02 they

00:50:35,170 --> 00:50:40,210
have rotted a little bit my plan is to

00:50:37,420 --> 00:50:42,790
fix them up as soon as i get 0 to 2 out

00:50:40,210 --> 00:50:44,619
the door so right now there's not a huge

00:50:42,790 --> 00:50:48,400
module community but why do you think

00:50:44,619 --> 00:50:51,760
I'm here talking to you and then we also

00:50:48,400 --> 00:50:55,270
introduced in 02 Mac OS X support but it

00:50:51,760 --> 00:50:57,400
does support javascript encore only it's

00:50:55,270 --> 00:50:58,930
not that the others can't be built it's

00:50:57,400 --> 00:51:01,930
just that I there's not really a

00:50:58,930 --> 00:51:04,210
standard way to do it on LSX so if you

00:51:01,930 --> 00:51:04,990
would like to submit patches to support

00:51:04,210 --> 00:51:06,700
the other engines

00:51:04,990 --> 00:51:10,480
gladly i will take them they should be

00:51:06,700 --> 00:51:12,760
pretty small and then in zero dot to

00:51:10,480 --> 00:51:14,830
that one we have vastly improved tab

00:51:12,760 --> 00:51:17,680
completion and this means that pretty

00:51:14,830 --> 00:51:20,290
much any object that you want to do tab

00:51:17,680 --> 00:51:22,360
completion in the shell just works we

00:51:20,290 --> 00:51:24,070
also added the type pointer support

00:51:22,360 --> 00:51:26,520
which i already talked about and we also

00:51:24,070 --> 00:51:28,660
rewrote the require system to make it

00:51:26,520 --> 00:51:30,790
comply to the standard a little bit

00:51:28,660 --> 00:51:32,590
better in an area where the standard was

00:51:30,790 --> 00:51:35,619
not clear but where most of the

00:51:32,590 --> 00:51:37,869
implementations did it one way so it

00:51:35,619 --> 00:51:41,080
should not too should integrate better

00:51:37,869 --> 00:51:44,740
with other require systems as of zero to

00:51:41,080 --> 00:51:48,490
that one our current status is that we

00:51:44,740 --> 00:51:50,830
have zero to one is our latest release

00:51:48,490 --> 00:51:53,260
our roadmap is that we are going to have

00:51:50,830 --> 00:51:55,930
zero to two that to sort lee hopefully

00:51:53,260 --> 00:51:57,910
in the next couple weeks this is mostly

00:51:55,930 --> 00:52:00,460
API clean up and we're going to remove

00:51:57,910 --> 00:52:02,740
the module system to a separate library

00:52:00,460 --> 00:52:04,780
this is so that applications who do not

00:52:02,740 --> 00:52:07,210
want the module system can load just the

00:52:04,780 --> 00:52:11,080
abstraction layer and all but then also

00:52:07,210 --> 00:52:14,800
optionally link to the module system 0

00:52:11,080 --> 00:52:16,420
is in 03 we're going to do some a little

00:52:14,800 --> 00:52:19,210
bit of a radical change I hope it

00:52:16,420 --> 00:52:20,590
shouldn't change the API too much but

00:52:19,210 --> 00:52:22,390
we're actually going to do main loop

00:52:20,590 --> 00:52:23,950
integration like I said before one of

00:52:22,390 --> 00:52:26,710
the things that I work on at Red Hat is

00:52:23,950 --> 00:52:29,440
doing vented main loop integrations for

00:52:26,710 --> 00:52:32,260
a variety of software projects and we

00:52:29,440 --> 00:52:34,480
are working on a solution to the problem

00:52:32,260 --> 00:52:36,640
of the fact that there's about six major

00:52:34,480 --> 00:52:38,020
main loops that applications use and

00:52:36,640 --> 00:52:40,810
they're all incompatible with one

00:52:38,020 --> 00:52:44,550
another which means that if you want to

00:52:40,810 --> 00:52:47,830
use an event loop in in one application

00:52:44,550 --> 00:52:49,840
and another application uses a different

00:52:47,830 --> 00:52:51,940
event loop and then you try to mix stuff

00:52:49,840 --> 00:52:53,800
it just doesn't work at all so we're

00:52:51,940 --> 00:52:55,000
going to solve that problem in fact I've

00:52:53,800 --> 00:52:57,910
already got real code that actually

00:52:55,000 --> 00:52:59,890
works and I'm going to be integrating

00:52:57,910 --> 00:53:01,780
that into not tues so that we can

00:52:59,890 --> 00:53:04,540
provide a default main loop similar to

00:53:01,780 --> 00:53:06,310
what nodejs does for a vented I oh but

00:53:04,540 --> 00:53:07,750
our implementation is not going to be

00:53:06,310 --> 00:53:09,010
locked down to a particular event loop

00:53:07,750 --> 00:53:13,840
which means we're going to be compatible

00:53:09,010 --> 00:53:17,230
with cute and with and with gtk and with

00:53:13,840 --> 00:53:18,370
nodejs once that's in place one of the

00:53:17,230 --> 00:53:20,410
really

00:53:18,370 --> 00:53:23,050
one of the ideas i would like to do is

00:53:20,410 --> 00:53:26,050
I'd like to look into how to actually

00:53:23,050 --> 00:53:28,750
support nodejs on top of not tues

00:53:26,050 --> 00:53:30,040
because it is possible the question is

00:53:28,750 --> 00:53:31,450
what would that take and I haven't

00:53:30,040 --> 00:53:34,890
researched that yet so that will

00:53:31,450 --> 00:53:39,070
probably come in maybe the DA for range

00:53:34,890 --> 00:53:40,690
and then the in the dot 9 range will be

00:53:39,070 --> 00:53:42,460
our beta and that will be a proposed

00:53:40,690 --> 00:53:43,960
stable AP I'm when we do at one point

00:53:42,460 --> 00:53:47,040
out we will have a stable API and

00:53:43,960 --> 00:53:51,430
hopefully never change it so help me God

00:53:47,040 --> 00:53:53,710
we need help if you want to help in any

00:53:51,430 --> 00:53:56,920
way we could use evangelist telling

00:53:53,710 --> 00:53:59,710
people hey don't use v8 natively or

00:53:56,920 --> 00:54:01,210
don't use a you know some other project

00:53:59,710 --> 00:54:03,070
for something niche let's let's try to

00:54:01,210 --> 00:54:04,870
use not to sand and build up an

00:54:03,070 --> 00:54:07,210
ecosystem around out of the browser

00:54:04,870 --> 00:54:09,970
JavaScript one of the cool things by the

00:54:07,210 --> 00:54:11,470
way that I like to give as an example

00:54:09,970 --> 00:54:14,500
the people is that you could use not

00:54:11,470 --> 00:54:16,050
tues to build a browser okay and you can

00:54:14,500 --> 00:54:18,100
have v8 running in one tab

00:54:16,050 --> 00:54:20,110
javascriptcore running in another and

00:54:18,100 --> 00:54:22,030
spider monkey running in another for

00:54:20,110 --> 00:54:23,830
that sort of the web programmers like

00:54:22,030 --> 00:54:25,390
perfect situation right where you can

00:54:23,830 --> 00:54:28,360
actually test against all the engines in

00:54:25,390 --> 00:54:31,210
a single browser we need help with

00:54:28,360 --> 00:54:33,070
documentation I've been pretty lacks at

00:54:31,210 --> 00:54:36,280
doing documentation the website is up

00:54:33,070 --> 00:54:37,900
and provide some stuff with the next

00:54:36,280 --> 00:54:39,580
release I'm going to really work heavily

00:54:37,900 --> 00:54:42,160
on getting stuff documented but we could

00:54:39,580 --> 00:54:44,800
always use more help if you are an

00:54:42,160 --> 00:54:47,530
infrastructure guy a system admin we do

00:54:44,800 --> 00:54:49,210
have a website up and running but we

00:54:47,530 --> 00:54:50,830
really we really do need a mailing list

00:54:49,210 --> 00:54:52,660
and stuff like that and I just haven't

00:54:50,830 --> 00:54:53,950
had the time to look into it so if

00:54:52,660 --> 00:54:55,900
you're somebody that likes to help with

00:54:53,950 --> 00:54:59,020
that kind of stuff I would love to talk

00:54:55,900 --> 00:55:00,610
to you we definitely need core hackers

00:54:59,020 --> 00:55:03,280
so people who are interested in and

00:55:00,610 --> 00:55:06,340
actually working on not tus coding in c

00:55:03,280 --> 00:55:08,110
and c++ we could use that we and we also

00:55:06,340 --> 00:55:10,780
want people to just build modules on top

00:55:08,110 --> 00:55:12,340
of not tues we want the whole goal of

00:55:10,780 --> 00:55:15,040
this is to make a reusable

00:55:12,340 --> 00:55:16,840
infrastructure so that people can you

00:55:15,040 --> 00:55:19,600
know take code make it available and

00:55:16,840 --> 00:55:21,700
that other people can use it the last

00:55:19,600 --> 00:55:24,280
thing is bindings we would love to be

00:55:21,700 --> 00:55:25,570
able to support not to see lots of

00:55:24,280 --> 00:55:27,910
different languages by the way the

00:55:25,570 --> 00:55:29,950
python bindings are really cool you can

00:55:27,910 --> 00:55:31,869
actually pass JavaScript objects into

00:55:29,950 --> 00:55:34,269
Python and Python objects back into John

00:55:31,869 --> 00:55:36,880
script and you can completely mix them

00:55:34,269 --> 00:55:39,869
around and it just sort of works if you

00:55:36,880 --> 00:55:42,519
don't care about your memory usage

00:55:39,869 --> 00:55:43,599
mixing two dynamic languages is cool and

00:55:42,519 --> 00:55:45,609
concept but if you're going to build

00:55:43,599 --> 00:55:47,170
like a big project on it the problem is

00:55:45,609 --> 00:55:48,819
you have reference counting in Python

00:55:47,170 --> 00:55:51,339
and reference counting in JavaScript and

00:55:48,819 --> 00:55:52,930
you get cross references and they never

00:55:51,339 --> 00:55:56,740
resolve so your objects are never freed

00:55:52,930 --> 00:55:59,380
so you just leak memory continuously but

00:55:56,740 --> 00:56:01,779
it is cool for small projects so thank

00:55:59,380 --> 00:56:04,029
you very much check out Nazis project

00:56:01,779 --> 00:56:18,329
calm and in our cute little mascot natty

00:56:04,029 --> 00:56:20,859
and any questions yes the answer is no

00:56:18,329 --> 00:56:24,160
not that I'm opposed to such a thing

00:56:20,859 --> 00:56:30,579
I've used swig and a couple projects and

00:56:24,160 --> 00:56:31,990
my my opinion of swig is that it's it's

00:56:30,579 --> 00:56:35,980
quick to get up and running but it's

00:56:31,990 --> 00:56:37,509
very hard to maintain I find that I find

00:56:35,980 --> 00:56:38,859
that writing them native natively is

00:56:37,509 --> 00:56:40,749
hard to maintain but if somebody wants

00:56:38,859 --> 00:56:44,739
to add support to swig for not tues I'm

00:56:40,749 --> 00:56:47,140
all for generally speaking I advise

00:56:44,739 --> 00:56:49,960
people use the C++ API it's a little bit

00:56:47,140 --> 00:56:51,970
it's a little bit cleaner and writing

00:56:49,960 --> 00:56:56,109
modules and C++ is really a pretty

00:56:51,970 --> 00:56:57,279
trivial task so but yeah that's if you

00:56:56,109 --> 00:56:59,739
want to write that i will i'll gladly

00:56:57,279 --> 00:57:02,999
accept the patch if i need to or if so

00:56:59,739 --> 00:57:02,999
it needs to i will lean on people

00:57:10,580 --> 00:57:29,150
yeah sure um so I think that you are

00:57:20,480 --> 00:57:30,920
thinking of what's it called now what is

00:57:29,150 --> 00:57:32,540
that library that there's a library for

00:57:30,920 --> 00:57:35,090
that a native library to help with

00:57:32,540 --> 00:57:36,260
native library loading your I think

00:57:35,090 --> 00:57:38,210
you're thinking of like ctypes and

00:57:36,260 --> 00:57:42,470
Python or something like that is that is

00:57:38,210 --> 00:57:44,750
that Oakland so yes I'm hesitant to

00:57:42,470 --> 00:57:49,430
introduce it up front and the reason for

00:57:44,750 --> 00:57:51,980
that is not to siz designed for security

00:57:49,430 --> 00:57:52,910
and if you if you haven't if you haven't

00:57:51,980 --> 00:57:56,360
picked that up you haven't been

00:57:52,910 --> 00:57:57,680
listening it i can give you that module

00:57:56,360 --> 00:58:00,380
and it's really cool but what it means

00:57:57,680 --> 00:58:03,440
is that it essentially breaks the

00:58:00,380 --> 00:58:06,710
sandbox again because you can do native

00:58:03,440 --> 00:58:07,910
code directly from javascript means that

00:58:06,710 --> 00:58:09,620
all of the problems that we've worked

00:58:07,910 --> 00:58:11,180
very hard to solve and make sure that

00:58:09,620 --> 00:58:15,260
they don't happen essentially go out the

00:58:11,180 --> 00:58:18,140
window it is better for you to rather

00:58:15,260 --> 00:58:20,630
than writing pure JavaScript on top of

00:58:18,140 --> 00:58:21,620
something like a sea types library it's

00:58:20,630 --> 00:58:23,330
better for you to write a native

00:58:21,620 --> 00:58:25,760
implementation that way you can preserve

00:58:23,330 --> 00:58:28,550
the sandbox it also allows you to do

00:58:25,760 --> 00:58:30,950
things like take advantage of the

00:58:28,550 --> 00:58:32,150
configuration system if you're

00:58:30,950 --> 00:58:33,260
attempting to you see types you're not

00:58:32,150 --> 00:58:36,230
going to have any access to the

00:58:33,260 --> 00:58:37,850
configuration so doing the cool things

00:58:36,230 --> 00:58:41,510
like my sequel connect will not be

00:58:37,850 --> 00:58:44,540
available to you so I'm not opposed to

00:58:41,510 --> 00:58:46,340
it but it just comes with a bunch of big

00:58:44,540 --> 00:58:53,630
warnings and and if I could make them

00:58:46,340 --> 00:58:56,410
flash in HTML i would actually you can

00:58:53,630 --> 00:58:56,410
but yeah

00:58:59,690 --> 00:59:06,180
any other questions I know I've sort of

00:59:02,040 --> 00:59:09,270
fire hosed you a bit but it's a lot of

00:59:06,180 --> 00:59:11,880
fun and I have fun working on it oh well

00:59:09,270 --> 00:59:14,070
let me give you a demo I forgot about

00:59:11,880 --> 00:59:15,450
this so I don't have any modules

00:59:14,070 --> 00:59:19,530
installed right now so the demo is going

00:59:15,450 --> 00:59:21,480
to be not very good but there's not too

00:59:19,530 --> 00:59:26,010
by the way is anybody know what the word

00:59:21,480 --> 00:59:30,930
not to means no Latin scholars I means

00:59:26,010 --> 00:59:32,850
birth means birth so anyway so here's

00:59:30,930 --> 00:59:34,770
not tus you'll notice that it shows the

00:59:32,850 --> 00:59:37,110
version right at the top and it shows me

00:59:34,770 --> 00:59:39,240
what engine we're using right I'm going

00:59:37,110 --> 00:59:40,830
to type tab here and you can actually

00:59:39,240 --> 00:59:41,970
get a tab completion of all of the

00:59:40,830 --> 00:59:44,010
objects that are currently in the

00:59:41,970 --> 00:59:45,600
sandbox now right now there's really

00:59:44,010 --> 00:59:47,490
nothing in the sandbox except for this

00:59:45,600 --> 00:59:49,290
these are all the standard objects that

00:59:47,490 --> 00:59:51,780
you get any time you initialize a

00:59:49,290 --> 00:59:55,320
JavaScript environment but you can do

00:59:51,780 --> 00:59:57,000
tab completion on these objects so i

00:59:55,320 --> 01:00:03,870
just did tab completion on Jason for

00:59:57,000 --> 01:00:06,330
instance I can create let's so let's

01:00:03,870 --> 01:00:10,530
create a variable called D and will

01:00:06,330 --> 01:00:14,340
create a new date so that that's the new

01:00:10,530 --> 01:00:15,960
date that we've just created there now

01:00:14,340 --> 01:00:19,280
the interesting thing is we've got tab

01:00:15,960 --> 01:00:21,990
completion so all of the functions for

01:00:19,280 --> 01:00:23,550
for the data object are all there so if

01:00:21,990 --> 01:00:30,030
i wanted to for instance convert it to

01:00:23,550 --> 01:00:31,350
jason there it isn't jason so and the

01:00:30,030 --> 01:00:32,820
type of completion all works and it will

01:00:31,350 --> 01:00:36,720
work with any objects that you create

01:00:32,820 --> 01:00:40,680
and put in the sandbox so any last

01:00:36,720 --> 01:00:42,330
questions thank you all very much for

01:00:40,680 --> 01:00:47,630
coming I hope it did not put you to

01:00:42,330 --> 01:00:47,630
sleep and appreciate it very much thanks

01:01:18,720 --> 01:01:22,680
what about this I can help you like it

01:01:20,640 --> 01:01:26,540
we have the same problem or would have

01:01:22,680 --> 01:01:26,540
become a few years you gave me I found

01:01:28,440 --> 01:01:32,860
that's not the word out

01:01:30,800 --> 01:01:32,860
you

01:02:40,660 --> 01:02:47,480
as a service leader in cloud computing

01:02:44,359 --> 01:02:49,069
all we do is hosted computing to us the

01:02:47,480 --> 01:02:51,020
cloud is just the next generation of

01:02:49,069 --> 01:02:52,970
hosting and if someone who's been in the

01:02:51,020 --> 01:02:54,920
hosting industry for 12 years we feel

01:02:52,970 --> 01:02:56,089
worth in a unique position to really

01:02:54,920 --> 01:02:58,220
help bring these two worlds together

01:02:56,089 --> 01:03:00,529
these different sets of technologies and

01:02:58,220 --> 01:03:02,869
to help companies embrace this new world

01:03:00,529 --> 01:03:04,880
in this great new tool that allows

01:03:02,869 --> 01:03:07,430
faster innovation not only is it about

01:03:04,880 --> 01:03:12,500
us being responsive and accountable but

01:03:07,430 --> 01:03:15,230
it's about us doing more for you whether

01:03:12,500 --> 01:03:19,250
less an OS that works the way that you

01:03:15,230 --> 01:03:23,020
do across all your devices HP Slate and

01:03:19,250 --> 01:03:23,020

YouTube URL: https://www.youtube.com/watch?v=GKJjtStG7yo


