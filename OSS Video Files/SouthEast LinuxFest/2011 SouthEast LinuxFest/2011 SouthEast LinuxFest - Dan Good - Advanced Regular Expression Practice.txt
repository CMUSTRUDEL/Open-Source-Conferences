Title: 2011 SouthEast LinuxFest - Dan Good - Advanced Regular Expression Practice
Publication date: 2012-03-13
Playlist: 2011 SouthEast LinuxFest
Description: 
	2011 SouthEast LinuxFest - Dan Good - Advanced Regular Expression Practice

This video is licensed under Creative Commons Attribution 3.0 Unported License.
Captions: 
	00:00:01,159 --> 00:00:07,290
the following presentation was recorded

00:00:03,810 --> 00:00:09,870
at the 2011 southeast linux Fest in

00:00:07,290 --> 00:00:11,370
Spartanburg South Carolina it is

00:00:09,870 --> 00:00:14,190
licensed under a Creative Commons

00:00:11,370 --> 00:00:17,359
license for more information about the

00:00:14,190 --> 00:00:21,900
south east linux fest visit

00:00:17,359 --> 00:00:23,070
www.ccltss.org the south east linux fest

00:00:21,900 --> 00:00:26,430
would like to thank the following

00:00:23,070 --> 00:00:30,320
diamond and platinum sponsors in 2011

00:00:26,430 --> 00:00:30,320
for helping make these videos possible

00:00:37,370 --> 00:00:43,910
we got more people in here so I'm gonna

00:00:39,540 --> 00:00:46,640
do my poll over again how many people

00:00:43,910 --> 00:00:49,890
have written regular expressions before

00:00:46,640 --> 00:00:52,610
okay how many people have written

00:00:49,890 --> 00:00:59,300
regular expressions for more than a year

00:00:52,610 --> 00:00:59,300
more than five more than ten

00:01:00,180 --> 00:01:08,480
okay okay all right you with your hand

00:01:04,290 --> 00:01:08,480
up still you come you come do this okay

00:01:08,870 --> 00:01:15,530
I'm not an expert either this is notice

00:01:11,460 --> 00:01:18,810
it says practice it does not say expert

00:01:15,530 --> 00:01:21,300
also when I submitted to talk I use the

00:01:18,810 --> 00:01:25,040
word advance but I realized that that's

00:01:21,300 --> 00:01:31,410
a really unfortunate choice of words

00:01:25,040 --> 00:01:33,150
because advanced is a relative term all

00:01:31,410 --> 00:01:35,070
I can really say is that the regular

00:01:33,150 --> 00:01:37,560
expressions I write these days are a lot

00:01:35,070 --> 00:01:41,160
more advanced than the ones I wrote 20

00:01:37,560 --> 00:01:45,000
years ago I think I've advanced along

00:01:41,160 --> 00:01:45,990
some some scale but I can't tell you

00:01:45,000 --> 00:01:48,450
whether or not these are going to be

00:01:45,990 --> 00:01:49,700
advanced for the rest of you but we're

00:01:48,450 --> 00:01:51,990
gonna give it a try

00:01:49,700 --> 00:01:56,670
so my name is Dan good and I've been

00:01:51,990 --> 00:01:59,009
working with UNIX and regular

00:01:56,670 --> 00:02:04,290
expressions for 20 years something like

00:01:59,009 --> 00:02:05,850
that and I am a programmer by trade I'm

00:02:04,290 --> 00:02:08,369
a professional program or what I'm not

00:02:05,850 --> 00:02:11,550
is a professional speaker I'm not a

00:02:08,369 --> 00:02:13,650
professional presenter so this is just

00:02:11,550 --> 00:02:17,340
we're just gonna try this out and see

00:02:13,650 --> 00:02:20,430
how this works and it might be it might

00:02:17,340 --> 00:02:22,019
be dull as dirt I like this stuff I hope

00:02:20,430 --> 00:02:24,450
you guys do too but it might be dull

00:02:22,019 --> 00:02:25,890
astir so if you want to talk about

00:02:24,450 --> 00:02:28,410
something else or you want to ask a

00:02:25,890 --> 00:02:31,410
question please be my guest

00:02:28,410 --> 00:02:35,450
alright let's get started okay

00:02:31,410 --> 00:02:37,830
first thing this is easier than it looks

00:02:35,450 --> 00:02:39,630
this is repelling and you know in

00:02:37,830 --> 00:02:42,600
repelling gravity does all the work well

00:02:39,630 --> 00:02:43,980
in regular expressions the regular

00:02:42,600 --> 00:02:45,420
expression engine does all the work we

00:02:43,980 --> 00:02:50,730
just got to tell it what work we want it

00:02:45,420 --> 00:02:54,299
to do this is a little preview I tried

00:02:50,730 --> 00:02:58,040
to get something for everybody so we've

00:02:54,299 --> 00:03:00,110
got some said little see little pearl

00:02:58,040 --> 00:03:05,670
little what is that

00:03:00,110 --> 00:03:09,000
Python and some Ruby so we're gonna try

00:03:05,670 --> 00:03:11,770
and hit all of this but first we're

00:03:09,000 --> 00:03:16,400
gonna warm up with some lights it

00:03:11,770 --> 00:03:18,670
how many people you said yeah all right

00:03:16,400 --> 00:03:21,830
who said said it's dead sit is not dead

00:03:18,670 --> 00:03:25,760
said is cool so let me tell you the

00:03:21,830 --> 00:03:29,510
background for this I use vim who uses

00:03:25,760 --> 00:03:33,739
them yes all right these are my people

00:03:29,510 --> 00:03:36,110
here so them and I'm a programmer so I

00:03:33,739 --> 00:03:37,790
use tags files right because you know

00:03:36,110 --> 00:03:40,550
you love to be able to pop on that tee

00:03:37,790 --> 00:03:42,230
and jump to some other file and some

00:03:40,550 --> 00:03:44,720
other find out what that function

00:03:42,230 --> 00:03:47,060
actually does but one of the things that

00:03:44,720 --> 00:03:50,299
annoys me about tags files is that

00:03:47,060 --> 00:03:53,480
they're not very versatile you build it

00:03:50,299 --> 00:03:55,959
once and then you either have to tell

00:03:53,480 --> 00:04:01,040
them this is where the tags file lives

00:03:55,959 --> 00:04:03,560
or or you have to copy the tags file to

00:04:01,040 --> 00:04:06,860
your current directory so you might be

00:04:03,560 --> 00:04:09,170
in some tree five levels deep and you

00:04:06,860 --> 00:04:10,819
want to look up a tag and the tags file

00:04:09,170 --> 00:04:12,980
you've got in this directory is only for

00:04:10,819 --> 00:04:15,170
the files here but you want to look up

00:04:12,980 --> 00:04:19,609
at across the whole source tree that

00:04:15,170 --> 00:04:21,680
tags file is for directories back so

00:04:19,609 --> 00:04:22,880
this is a problem I've had if you can't

00:04:21,680 --> 00:04:24,950
relate to the problem that's ok but

00:04:22,880 --> 00:04:27,740
let's jump to the regular expression

00:04:24,950 --> 00:04:29,360
what I wanted to do is I wanted to take

00:04:27,740 --> 00:04:32,690
a tags file in the top-level directory

00:04:29,360 --> 00:04:35,080
and make a symlink to that tags file in

00:04:32,690 --> 00:04:38,300
every child directory and every child

00:04:35,080 --> 00:04:39,710
grandchild and so on and so forth and

00:04:38,300 --> 00:04:45,070
that's actually pretty straightforward

00:04:39,710 --> 00:04:49,510
to do with find and a little bit of said

00:04:45,070 --> 00:04:57,740
so first let's talk about a said idiom

00:04:49,510 --> 00:05:01,100
this is the HG s newline idiom so quick

00:04:57,740 --> 00:05:02,690
hands anybody know this one alright so I

00:05:01,100 --> 00:05:06,800
can teach you at least something all

00:05:02,690 --> 00:05:09,169
right this is good H overwrites the

00:05:06,800 --> 00:05:11,840
whole space with the current line so CID

00:05:09,169 --> 00:05:14,419
has two spaces it has the pattern space

00:05:11,840 --> 00:05:18,350
or what I call the current line and then

00:05:14,419 --> 00:05:21,680
it has the whole space and 99.9% of all

00:05:18,350 --> 00:05:23,000
said program said scripts only use the

00:05:21,680 --> 00:05:25,370
pattern space they don't use the whole

00:05:23,000 --> 00:05:28,449
space but the whole space

00:05:25,370 --> 00:05:31,070
you can do so much stuff with it so H

00:05:28,449 --> 00:05:34,610
copies this current line into that whole

00:05:31,070 --> 00:05:37,669
space and G takes what's in the whole

00:05:34,610 --> 00:05:40,669
space and puts it on the end of the

00:05:37,669 --> 00:05:43,270
pattern space separated by a new line so

00:05:40,669 --> 00:05:46,370
I tried to kind of make this visual

00:05:43,270 --> 00:05:50,449
let's say our let's say we had source

00:05:46,370 --> 00:05:53,720
common in our current line we do H now

00:05:50,449 --> 00:05:57,620
they have hold is a duplicate of that we

00:05:53,720 --> 00:06:00,740
do G hold stays the same but now current

00:05:57,620 --> 00:06:03,560
has source common new line source common

00:06:00,740 --> 00:06:05,300
and then since we don't really want the

00:06:03,560 --> 00:06:08,510
new line anymore we want to do something

00:06:05,300 --> 00:06:09,949
else we almost always replace the new

00:06:08,510 --> 00:06:12,729
line with something in this case

00:06:09,949 --> 00:06:16,539
trivially I'm replacing it with a space

00:06:12,729 --> 00:06:20,090
so how do we use that in this script

00:06:16,539 --> 00:06:21,949
this script is does it find I don't care

00:06:20,090 --> 00:06:25,880
about CBS and SVN so we throw those away

00:06:21,949 --> 00:06:30,500
and this is an example of what the fine

00:06:25,880 --> 00:06:32,570
line might produce some of you might

00:06:30,500 --> 00:06:35,330
recognize this as some Apache

00:06:32,570 --> 00:06:39,979
directories not all of them I actually

00:06:35,330 --> 00:06:44,840
trim the list so this is what the first

00:06:39,979 --> 00:06:47,690
bit of said does we trim off that we

00:06:44,840 --> 00:06:51,010
trim off this first line the dot so line

00:06:47,690 --> 00:06:55,580
beginning with a literal dot deleted

00:06:51,010 --> 00:06:57,520
then we use that H so we copied this

00:06:55,580 --> 00:07:02,270
portion into the whole space

00:06:57,520 --> 00:07:05,870
after that we're using we're getting rid

00:07:02,270 --> 00:07:08,360
of the dot slash because that's not very

00:07:05,870 --> 00:07:10,669
useful now here we're using commas I

00:07:08,360 --> 00:07:13,160
know that looks a little weird but I do

00:07:10,669 --> 00:07:15,880
this a lot with said you can use any

00:07:13,160 --> 00:07:19,070
characters the delimiter after the S and

00:07:15,880 --> 00:07:21,289
since I will have slashes in my pattern

00:07:19,070 --> 00:07:22,910
I'm using the comma instead of the slash

00:07:21,289 --> 00:07:27,440
so I don't have to put a backslash in

00:07:22,910 --> 00:07:28,849
front the slash are we good there buddy

00:07:27,440 --> 00:07:34,210
with me all right

00:07:28,849 --> 00:07:37,130
you sure okay we'll keep going so next

00:07:34,210 --> 00:07:38,270
we're taking everything that's not a

00:07:37,130 --> 00:07:41,139
slash

00:07:38,270 --> 00:07:45,250
that's this character class right here

00:07:41,139 --> 00:07:48,229
open bracket carrot flash close bracket

00:07:45,250 --> 00:07:51,560
star everything that's not a slash and

00:07:48,229 --> 00:07:55,430
we're placing with two dots so this is

00:07:51,560 --> 00:07:58,490
the before and this is the after server

00:07:55,430 --> 00:08:01,430
slash MPM comes dot dot slash dot dot

00:07:58,490 --> 00:08:05,330
now is that particularly useful no but

00:08:01,430 --> 00:08:06,770
there's more to come so we are kind of

00:08:05,330 --> 00:08:08,479
flying by the seat of our pants right

00:08:06,770 --> 00:08:12,259
here I think I'm the only person here

00:08:08,479 --> 00:08:15,710
who's using Google Docs for my for my

00:08:12,259 --> 00:08:18,440
presentation so cross your fingers that

00:08:15,710 --> 00:08:20,509
this works but on the plus side this is

00:08:18,440 --> 00:08:22,490
not live I'm not actually going to try

00:08:20,509 --> 00:08:24,470
and type out any regular expressions for

00:08:22,490 --> 00:08:27,500
you because that would certainly fail

00:08:24,470 --> 00:08:29,889
major so the next thing we're going to

00:08:27,500 --> 00:08:32,360
do is we're going to just simply insert

00:08:29,889 --> 00:08:35,959
Ln - yes at the beginning of the line

00:08:32,360 --> 00:08:39,279
and tags at the end of the line so now

00:08:35,959 --> 00:08:45,910
our lines look like this the path is

00:08:39,279 --> 00:08:50,029
turned into part of a command and then

00:08:45,910 --> 00:08:52,490
we use our G remember our hold space to

00:08:50,029 --> 00:08:53,200
pull that back throw it on the end of

00:08:52,490 --> 00:08:55,610
the line

00:08:53,200 --> 00:08:59,029
we're placing our new line with space

00:08:55,610 --> 00:09:03,500
and then just simply adding a slash dot

00:08:59,029 --> 00:09:08,570
at the end what we have now is a command

00:09:03,500 --> 00:09:11,990
that in each subdirectory will link back

00:09:08,570 --> 00:09:15,829
to that parent tags and the deeper the

00:09:11,990 --> 00:09:19,399
subdirectory the more dot dots we have

00:09:15,829 --> 00:09:23,000
so the paths all work and we just pipe

00:09:19,399 --> 00:09:24,440
this to sh and we're done and that's

00:09:23,000 --> 00:09:26,570
what the script does so that's our

00:09:24,440 --> 00:09:29,959
warm-up okay we're done with that I

00:09:26,570 --> 00:09:31,910
think all right we're gonna stretch just

00:09:29,959 --> 00:09:34,700
a little bit I'm gonna try something a

00:09:31,910 --> 00:09:36,440
little a little more involved let's see

00:09:34,700 --> 00:09:41,779
how this works see how I am doing on

00:09:36,440 --> 00:09:48,869
time yeah okay

00:09:41,779 --> 00:09:51,779
some see we got C programmers this is

00:09:48,869 --> 00:09:53,249
this is how I would do a regular

00:09:51,779 --> 00:09:55,889
expression in return

00:09:53,249 --> 00:09:58,799
the first argument or excuse me the

00:09:55,889 --> 00:10:01,559
first capture in C and this is again

00:09:58,799 --> 00:10:07,129
throw a throwback to the Apache days I'm

00:10:01,559 --> 00:10:12,089
using ap I've lost it

00:10:07,129 --> 00:10:14,220
ap rig exact an AP question dope to do

00:10:12,089 --> 00:10:16,379
this work but we're not really going to

00:10:14,220 --> 00:10:17,819
talk about this the main reason I threw

00:10:16,379 --> 00:10:21,829
this slide in here was to kind of make a

00:10:17,819 --> 00:10:26,639
point regular expressions are everywhere

00:10:21,829 --> 00:10:28,319
it's probably the only thing that I've

00:10:26,639 --> 00:10:31,619
used over the course of twenty years

00:10:28,319 --> 00:10:33,569
which I still use today I used them in

00:10:31,619 --> 00:10:37,410
every language I use them in my editors

00:10:33,569 --> 00:10:41,220
I use them in Apache config files I use

00:10:37,410 --> 00:10:45,689
them in make files that's a bad idea and

00:10:41,220 --> 00:10:48,889
make files just about everywhere and you

00:10:45,689 --> 00:10:51,269
can even use them in C believe it or not

00:10:48,889 --> 00:10:52,529
and let me tell you the the industry

00:10:51,269 --> 00:10:54,720
I've been in for the last six years

00:10:52,529 --> 00:10:57,299
which is the security industry we do

00:10:54,720 --> 00:10:59,879
deep packet inspection and you better

00:10:57,299 --> 00:11:03,559
believe we do regular expressions and we

00:10:59,879 --> 00:11:06,239
do them in C they're very important so

00:11:03,559 --> 00:11:08,759
our second example

00:11:06,239 --> 00:11:10,369
forget the C just wanted to kind of make

00:11:08,759 --> 00:11:14,369
that point

00:11:10,369 --> 00:11:17,910
scrubbing bash style variables so I'll

00:11:14,369 --> 00:11:21,480
give you the back story for this when we

00:11:17,910 --> 00:11:23,129
write software or in the course of my

00:11:21,480 --> 00:11:25,169
career when I written software and we

00:11:23,129 --> 00:11:27,899
needed to configure something we

00:11:25,169 --> 00:11:29,579
frequently wanted to do or I frequently

00:11:27,899 --> 00:11:31,619
wanted to do the simplest thing possible

00:11:29,579 --> 00:11:34,980
so the simplest thing might be to have a

00:11:31,619 --> 00:11:38,910
single config file and to use bash style

00:11:34,980 --> 00:11:40,679
key value pairs that's simple right then

00:11:38,910 --> 00:11:42,869
for your bash scripts you can just

00:11:40,679 --> 00:11:44,699
source the file and for your other

00:11:42,869 --> 00:11:46,739
programs you can parse it because

00:11:44,699 --> 00:11:51,949
parsing it's trivial right it's just key

00:11:46,739 --> 00:11:55,680
value pairs well then you get co-workers

00:11:51,949 --> 00:11:58,410
and they mess up your config file they

00:11:55,680 --> 00:11:59,850
start doing quoting in things inside

00:11:58,410 --> 00:12:02,220
your config file and it becomes a little

00:11:59,850 --> 00:12:04,230
harder so now you got to do a little bit

00:12:02,220 --> 00:12:07,439
more work to parse it so that's what

00:12:04,230 --> 00:12:10,709
we're going to talk about this time so

00:12:07,439 --> 00:12:14,069
what I'm trying to show here is a sort

00:12:10,709 --> 00:12:18,809
of a progression let's say in my file

00:12:14,069 --> 00:12:20,160
I had this stuff here dot star is a

00:12:18,809 --> 00:12:23,850
regular expression which will match

00:12:20,160 --> 00:12:26,490
everything now let's say I don't want

00:12:23,850 --> 00:12:27,990
the comments so ultimately I want the

00:12:26,490 --> 00:12:29,790
key value pairs but let's say I don't

00:12:27,990 --> 00:12:32,850
want the comments so what regular

00:12:29,790 --> 00:12:35,490
expression could I use to get rid of the

00:12:32,850 --> 00:12:40,379
comments here I'm using the character

00:12:35,490 --> 00:12:42,540
class not pound star and that does a

00:12:40,379 --> 00:12:44,660
good job of giving me just the key value

00:12:42,540 --> 00:12:48,389
pairs and getting rid of the comments

00:12:44,660 --> 00:12:52,170
but it doesn't work if it's slightly

00:12:48,389 --> 00:12:55,709
more involved let's say I have a pound

00:12:52,170 --> 00:13:01,769
sign inside one of my values that's a

00:12:55,709 --> 00:13:05,360
legitimate thing to happen right so this

00:13:01,769 --> 00:13:05,360
isn't gonna give me what I want anymore

00:13:05,600 --> 00:13:09,839
yeah I didn't actually put an example of

00:13:08,100 --> 00:13:13,470
what that would give you but what it

00:13:09,839 --> 00:13:16,110
would give you is up to here and you'd

00:13:13,470 --> 00:13:17,970
lose the trailing three dots and the

00:13:16,110 --> 00:13:20,910
quote sign I should have brought a laser

00:13:17,970 --> 00:13:24,839
pointer so what can we do to make that

00:13:20,910 --> 00:13:27,990
better here I've got an expression that

00:13:24,839 --> 00:13:31,740
matches a quoted string we've got the

00:13:27,990 --> 00:13:35,339
opening quote not quote star and the

00:13:31,740 --> 00:13:40,259
close quote this expression is gonna

00:13:35,339 --> 00:13:44,730
match a quoted a single quoted string so

00:13:40,259 --> 00:13:47,279
we've got an expression here which will

00:13:44,730 --> 00:13:49,769
match a key value pair and get rid of a

00:13:47,279 --> 00:13:52,259
comment and we've got an expression here

00:13:49,769 --> 00:13:53,879
that'll match a single quoted string so

00:13:52,259 --> 00:13:57,029
if we could get those two expressions to

00:13:53,879 --> 00:13:59,939
work together then we would get what we

00:13:57,029 --> 00:14:02,959
wanted the key value pair without the

00:13:59,939 --> 00:14:02,959
without the comments

00:14:06,470 --> 00:14:12,180
all right so let's try it

00:14:09,769 --> 00:14:15,589
here's try number one this is using

00:14:12,180 --> 00:14:20,430
alternation alternation is our or bar

00:14:15,589 --> 00:14:22,170
does I want to match this or that so in

00:14:20,430 --> 00:14:24,060
this first example I just put the dot

00:14:22,170 --> 00:14:28,709
star up here to remind us what our input

00:14:24,060 --> 00:14:31,319
is so this is our input in our first

00:14:28,709 --> 00:14:33,689
example we're saying not comment star or

00:14:31,319 --> 00:14:37,920
single quoted string and this is what we

00:14:33,689 --> 00:14:40,759
get back we still losing the pound dot

00:14:37,920 --> 00:14:43,350
dot dot out of the single quoted string

00:14:40,759 --> 00:14:46,160
there's the order matter may be the

00:14:43,350 --> 00:14:48,959
order matters so let's switch it around

00:14:46,160 --> 00:14:52,399
right here we're matching the single

00:14:48,959 --> 00:14:56,160
quoted string followed by the knot pound

00:14:52,399 --> 00:14:58,220
but we get the exact same output so this

00:14:56,160 --> 00:15:00,990
doesn't work and what this tells us is

00:14:58,220 --> 00:15:03,810
the order doesn't matter what's

00:15:00,990 --> 00:15:09,629
happening here is that the knot pound is

00:15:03,810 --> 00:15:14,009
reading it's when it starts matching it

00:15:09,629 --> 00:15:15,509
continues matching so since carrot

00:15:14,009 --> 00:15:18,449
excuse me since single quote doesn't

00:15:15,509 --> 00:15:20,610
start matching on any of these they all

00:15:18,449 --> 00:15:23,550
default to this expression that not

00:15:20,610 --> 00:15:26,300
pound so we need to we need something

00:15:23,550 --> 00:15:29,790
better a better way to put this together

00:15:26,300 --> 00:15:32,339
alright this is one of my favorite

00:15:29,790 --> 00:15:34,110
tricks of all time and I didn't invent

00:15:32,339 --> 00:15:37,170
this right so this is this is something

00:15:34,110 --> 00:15:39,360
handed down to me and this is when I

00:15:37,170 --> 00:15:41,519
first knew that I loved regular

00:15:39,360 --> 00:15:46,769
expressions because I thought this was

00:15:41,519 --> 00:15:50,370
so cool that's the geek in me this this

00:15:46,769 --> 00:15:54,899
I think this is cool what we're doing

00:15:50,370 --> 00:16:00,439
here is we're moving the star around so

00:15:54,899 --> 00:16:05,220
before we had that star on non pound

00:16:00,439 --> 00:16:07,800
instead we've made this a group and

00:16:05,220 --> 00:16:10,290
we've moved the star outside of the

00:16:07,800 --> 00:16:14,329
group so what this does is this waits

00:16:10,290 --> 00:16:16,170
the whole expression in favor of this

00:16:14,329 --> 00:16:21,930
this says

00:16:16,170 --> 00:16:28,390
match a-hole single coded string or a

00:16:21,930 --> 00:16:32,680
single non pound character that whole

00:16:28,390 --> 00:16:38,310
expression should occur zero or more

00:16:32,680 --> 00:16:41,010
times so when we use this are not pound

00:16:38,310 --> 00:16:44,170
matches for each character of that one

00:16:41,010 --> 00:16:50,890
on the next line are not pound matches

00:16:44,170 --> 00:16:53,200
once again again again and then the

00:16:50,890 --> 00:16:55,870
first part of the expression matches and

00:16:53,200 --> 00:16:59,740
consumes the whole single quoted string

00:16:55,870 --> 00:17:03,070
and now we've got our pound captured

00:16:59,740 --> 00:17:06,040
inside of our single quoted string so

00:17:03,070 --> 00:17:07,270
that's how that works I it's kind of

00:17:06,040 --> 00:17:09,160
hard to talk about this we don't really

00:17:07,270 --> 00:17:10,840
have a terminology associated with it

00:17:09,160 --> 00:17:13,720
but I like to call this weighting the

00:17:10,840 --> 00:17:19,960
expression weight as in terms of

00:17:13,720 --> 00:17:22,180
assigning a heavier value okay but you

00:17:19,960 --> 00:17:23,340
know life is not life isn't that easy

00:17:22,180 --> 00:17:25,570
right

00:17:23,340 --> 00:17:27,570
double quoted strings what do we talk

00:17:25,570 --> 00:17:31,690
about double quoted strings

00:17:27,570 --> 00:17:34,090
well we can try the same thing right so

00:17:31,690 --> 00:17:35,410
here's the corresponding regular

00:17:34,090 --> 00:17:40,630
expression to match a double quoted

00:17:35,410 --> 00:17:44,470
strength quote not quote star quote when

00:17:40,630 --> 00:17:47,980
we try it against this input all we get

00:17:44,470 --> 00:17:50,460
is quote backslash quote now I guess

00:17:47,980 --> 00:17:52,900
I'll I'll go over this quickly for the

00:17:50,460 --> 00:17:57,400
anybody in here who's not familiar with

00:17:52,900 --> 00:17:59,740
- single poet strings you can't put an

00:17:57,400 --> 00:18:02,230
escape single quote in them but double

00:17:59,740 --> 00:18:04,660
quote strings you can put an escaped

00:18:02,230 --> 00:18:06,730
double quote in them and that's what's

00:18:04,660 --> 00:18:10,060
going on here we've got a double quoted

00:18:06,730 --> 00:18:12,850
string with two escaped double quotes

00:18:10,060 --> 00:18:15,850
and the method of escaping is basically

00:18:12,850 --> 00:18:18,790
putting a backslash so the literal value

00:18:15,850 --> 00:18:25,560
there is quote don't panic quote in

00:18:18,790 --> 00:18:25,560
large print letters here is

00:18:26,400 --> 00:18:33,630
what is this okay

00:18:33,720 --> 00:18:40,570
here's it so here's here's an analogy to

00:18:37,660 --> 00:18:46,690
our use of alternation what we've got

00:18:40,570 --> 00:18:52,180
here we want to match up an escaped

00:18:46,690 --> 00:18:54,280
quote or a not quote an escape so here

00:18:52,180 --> 00:18:58,990
we have to use two backslashes because

00:18:54,280 --> 00:19:00,370
we want to match a literal backslash we

00:18:58,990 --> 00:19:03,100
want to match that character or

00:19:00,370 --> 00:19:05,880
something that's not a quote and we want

00:19:03,100 --> 00:19:10,720
to use that group zero or more times

00:19:05,880 --> 00:19:13,960
when we do that we can actually capture

00:19:10,720 --> 00:19:16,720
the whole double quoted string so the

00:19:13,960 --> 00:19:19,750
first quote matches literally the quote

00:19:16,720 --> 00:19:22,420
here the backslash quote is consumed

00:19:19,750 --> 00:19:26,230
here and it doesn't terminate the string

00:19:22,420 --> 00:19:29,470
or terminate the match excuse me the D

00:19:26,230 --> 00:19:32,260
matches not quote and so on and so forth

00:19:29,470 --> 00:19:35,440
until we get to our next backslash quote

00:19:32,260 --> 00:19:36,880
that matches here and then we continue

00:19:35,440 --> 00:19:38,710
until we get to the final literal quote

00:19:36,880 --> 00:19:40,120
so now we have a regular expression that

00:19:38,710 --> 00:19:43,030
we can use to match double-quoted

00:19:40,120 --> 00:19:45,040
strings but we still need to match

00:19:43,030 --> 00:19:46,540
single quoted strings and the key value

00:19:45,040 --> 00:19:49,540
pairs so let's try and put it all

00:19:46,540 --> 00:19:51,270
together putting it all together

00:19:49,540 --> 00:19:55,480
all right I'm using Perl for this one

00:19:51,270 --> 00:19:58,960
this is the whole expression okay can

00:19:55,480 --> 00:20:02,530
you see it here so the first part of

00:19:58,960 --> 00:20:04,720
this grouping is our our match for

00:20:02,530 --> 00:20:07,690
double quoted strings then there's our

00:20:04,720 --> 00:20:09,970
or bar then there's our single quoted

00:20:07,690 --> 00:20:13,690
strings then and there's our or bar and

00:20:09,970 --> 00:20:15,610
then there's our NOK pound and a newline

00:20:13,690 --> 00:20:20,740
I threw that in there see if you're

00:20:15,610 --> 00:20:23,500
awake so this whole expression if we

00:20:20,740 --> 00:20:25,450
give it this input gives us this output

00:20:23,500 --> 00:20:25,960
and this is exactly what we were hoping

00:20:25,450 --> 00:20:27,670
for

00:20:25,960 --> 00:20:31,530
we've getting all the key value pairs

00:20:27,670 --> 00:20:34,440
including backslash quotes including

00:20:31,530 --> 00:20:37,140
pounds that are part of literal values

00:20:34,440 --> 00:20:40,440
without getting the trailing comments so

00:20:37,140 --> 00:20:43,020
this works but we built it up peace

00:20:40,440 --> 00:20:46,290
watts and that's a major point that I

00:20:43,020 --> 00:20:49,530
want to make that expression if you just

00:20:46,290 --> 00:20:51,960
look at it day one that's hard to read

00:20:49,530 --> 00:20:55,320
that's hard to parse that's hard to it's

00:20:51,960 --> 00:20:57,960
like what what is that but if you attack

00:20:55,320 --> 00:21:01,160
it a little piece at a time

00:20:57,960 --> 00:21:04,800
and then you put those pieces together

00:21:01,160 --> 00:21:08,820
you can get very long complicated

00:21:04,800 --> 00:21:10,770
expressions that work and you know what

00:21:08,820 --> 00:21:13,170
they do because you can see each of the

00:21:10,770 --> 00:21:18,690
pieces present that you put together

00:21:13,170 --> 00:21:21,810
like building with Legos so now this is

00:21:18,690 --> 00:21:25,410
a stricter version and this is a

00:21:21,810 --> 00:21:29,540
technique that I like a lot what I'm

00:21:25,410 --> 00:21:32,490
doing here is I'm taking this expression

00:21:29,540 --> 00:21:35,640
compiling it and assigning that compiled

00:21:32,490 --> 00:21:37,920
regular expression into a variable then

00:21:35,640 --> 00:21:39,930
I'm making another regular expression

00:21:37,920 --> 00:21:45,320
and part of the value of that regular

00:21:39,930 --> 00:21:49,880
expression is this variable here so this

00:21:45,320 --> 00:21:53,760
substitutes all of that not as a string

00:21:49,880 --> 00:21:56,370
but as a compiled regular expression so

00:21:53,760 --> 00:21:59,520
you can build regular expressions that

00:21:56,370 --> 00:22:01,770
contain compiled regular expressions and

00:21:59,520 --> 00:22:04,920
when you do that you can build them

00:22:01,770 --> 00:22:07,950
together piecewise not in your head but

00:22:04,920 --> 00:22:10,050
actually in your code and that makes it

00:22:07,950 --> 00:22:12,390
easy to write very complicated regular

00:22:10,050 --> 00:22:16,560
expressions and we're gonna I'm going to

00:22:12,390 --> 00:22:18,930
show you that at the end so this one's a

00:22:16,560 --> 00:22:22,050
little more strict in that I actually

00:22:18,930 --> 00:22:25,320
wanted to match the leading key value

00:22:22,050 --> 00:22:30,240
pair so this expression says some bit of

00:22:25,320 --> 00:22:33,630
space followed by an alphanumeric - the

00:22:30,240 --> 00:22:36,240
numeric part followed by word characters

00:22:33,630 --> 00:22:38,850
a literal equals and then that

00:22:36,240 --> 00:22:40,350
expression that we used before so this

00:22:38,850 --> 00:22:42,300
one you could run against a whole bash

00:22:40,350 --> 00:22:45,220
source file and the only things you get

00:22:42,300 --> 00:22:47,859
back are the variables

00:22:45,220 --> 00:22:49,359
okay that's enough of this one oh the

00:22:47,859 --> 00:22:52,359
original version alright so this is what

00:22:49,359 --> 00:22:55,690
I actually wrote in the original script

00:22:52,359 --> 00:22:58,720
and it's slightly different but it's

00:22:55,690 --> 00:23:00,999
about the same what I actually wrote was

00:22:58,720 --> 00:23:04,119
something that would modify a variable

00:23:00,999 --> 00:23:07,659
in place it uses pearls idea of dollar

00:23:04,119 --> 00:23:09,419
under which is the default variable for

00:23:07,659 --> 00:23:14,470
any regular expression operation and

00:23:09,419 --> 00:23:16,869
this one uses question :

00:23:14,470 --> 00:23:19,090
to say I don't actually want to capture

00:23:16,869 --> 00:23:22,119
something so you can insert that in any

00:23:19,090 --> 00:23:25,570
grouping and the only reason to really

00:23:22,119 --> 00:23:27,999
do that is to say is to make it clear

00:23:25,570 --> 00:23:31,599
what you do want to capture if you're

00:23:27,999 --> 00:23:33,909
using a lot of her ends then dollar one

00:23:31,599 --> 00:23:36,970
is going to be something this time and

00:23:33,909 --> 00:23:40,690
something else that time if you put this

00:23:36,970 --> 00:23:42,249
question : in your paren you can say

00:23:40,690 --> 00:23:44,289
don't capture that don't capture the

00:23:42,249 --> 00:23:47,259
other I really only want in this case

00:23:44,289 --> 00:23:48,669
the whole thing so that was the original

00:23:47,259 --> 00:23:51,299
version and I thought I'd throw that up

00:23:48,669 --> 00:23:54,220
there just to show you that I'm lazy

00:23:51,299 --> 00:23:55,690
because that's not nearly as strict

00:23:54,220 --> 00:23:58,539
diversion as the version on the last

00:23:55,690 --> 00:24:01,779
slide but you know Larry wall would say

00:23:58,539 --> 00:24:05,919
lazy laziness is a virtue of a

00:24:01,779 --> 00:24:07,570
programmer okay so stick with this you

00:24:05,919 --> 00:24:08,950
got this this is this is not hard

00:24:07,570 --> 00:24:12,599
remember we said it's easier that looks

00:24:08,950 --> 00:24:12,599
so hang in there we're gonna keep going

00:24:12,869 --> 00:24:21,879
this this is this is an ugly path right

00:24:17,789 --> 00:24:23,379
you probably never in your life type

00:24:21,879 --> 00:24:26,710
something like that in unless you were

00:24:23,379 --> 00:24:28,720
trying to break into something but a

00:24:26,710 --> 00:24:32,259
fact of life is people actually do try

00:24:28,720 --> 00:24:34,179
to break into things they try to break

00:24:32,259 --> 00:24:36,820
in they try to break web servers by

00:24:34,179 --> 00:24:39,099
putting interesting things in the URL

00:24:36,820 --> 00:24:40,599
say to get back to Etsy password or

00:24:39,099 --> 00:24:43,419
something at least they used to try and

00:24:40,599 --> 00:24:44,950
do that they try and break other things

00:24:43,419 --> 00:24:48,269
and one of the ways they try and break

00:24:44,950 --> 00:24:51,429
things is by using an obfuscated path

00:24:48,269 --> 00:24:54,869
this is an obfuscated path that consists

00:24:51,429 --> 00:24:56,700
of extra slashes it consists of

00:24:54,869 --> 00:24:58,650
references to the parent

00:24:56,700 --> 00:25:02,190
it consists of references to the same

00:24:58,650 --> 00:25:04,290
directory so what what does this

00:25:02,190 --> 00:25:06,210
actually anyone who parse this in their

00:25:04,290 --> 00:25:08,100
head what is this actually a quite -

00:25:06,210 --> 00:25:10,740
does it equate to home DG does it equate

00:25:08,100 --> 00:25:12,450
the user share fonts x11 is it equate to

00:25:10,740 --> 00:25:15,090
use your local bin use a local at sea

00:25:12,450 --> 00:25:19,860
just Etsy well let's try and do this

00:25:15,090 --> 00:25:23,790
programmatically hahaha so I'm I'm a sea

00:25:19,860 --> 00:25:27,510
guy this is actually how I solve this

00:25:23,790 --> 00:25:28,590
problem in C he used three character

00:25:27,510 --> 00:25:31,260
pointers and they move in different

00:25:28,590 --> 00:25:33,990
directions so when it consumes a dot dot

00:25:31,260 --> 00:25:35,400
it actually consumes the adjacent parent

00:25:33,990 --> 00:25:38,820
directory and then it repeats this

00:25:35,400 --> 00:25:42,420
process that's how I solved it in C but

00:25:38,820 --> 00:25:45,990
this isn't about C this is about regular

00:25:42,420 --> 00:25:53,160
expressions so I reimplemented that code

00:25:45,990 --> 00:25:56,490
in Python to show you today now here's

00:25:53,160 --> 00:25:58,410
what's different about this most people

00:25:56,490 --> 00:26:01,380
would say you couldn't solve this

00:25:58,410 --> 00:26:04,800
problem with regular expressions and

00:26:01,380 --> 00:26:06,870
they'd probably be right if they

00:26:04,800 --> 00:26:10,440
attempted to do it with a single regular

00:26:06,870 --> 00:26:12,240
expression because you can't solve some

00:26:10,440 --> 00:26:13,590
problems with just one regular

00:26:12,240 --> 00:26:15,900
expression no matter how good you are

00:26:13,590 --> 00:26:18,540
well maybe if you're a lot better than I

00:26:15,900 --> 00:26:20,970
know about you can I can't solve it with

00:26:18,540 --> 00:26:23,880
one right expression the problem is

00:26:20,970 --> 00:26:26,280
those parent directories that dot dot

00:26:23,880 --> 00:26:29,220
and the corresponding parent you want to

00:26:26,280 --> 00:26:31,650
take them away in pairs this dot dot and

00:26:29,220 --> 00:26:35,400
this parent go together the next dot dot

00:26:31,650 --> 00:26:36,360
and that parent go together now if you

00:26:35,400 --> 00:26:38,220
try and write a regular expression

00:26:36,360 --> 00:26:40,410
you're tempted to say well I can clip

00:26:38,220 --> 00:26:42,900
one out and then you're going to apply

00:26:40,410 --> 00:26:45,330
that globally and you'll end up clipping

00:26:42,900 --> 00:26:49,080
out the wrong things and you won't get a

00:26:45,330 --> 00:26:52,530
path that's actually accurate so the

00:26:49,080 --> 00:26:56,010
trick well I guess it's a trick the way

00:26:52,530 --> 00:26:59,870
to do this is to do it stepwise if you

00:26:56,010 --> 00:27:04,500
put your brain back into said mode said

00:26:59,870 --> 00:27:06,120
encourages you to do things in steps if

00:27:04,500 --> 00:27:07,600
you can't write a regular expression to

00:27:06,120 --> 00:27:11,049
do everything at once

00:27:07,600 --> 00:27:13,419
make it simpler right and s slash

00:27:11,049 --> 00:27:15,399
something slash something that takes

00:27:13,419 --> 00:27:18,070
something complicated and makes it

00:27:15,399 --> 00:27:20,649
simpler and then write another one that

00:27:18,070 --> 00:27:22,889
makes it simpler so that's what we're

00:27:20,649 --> 00:27:25,239
doing here but we're doing it in a loop

00:27:22,889 --> 00:27:28,889
so let me cover these two real quick

00:27:25,239 --> 00:27:32,679
these are simple this says take any

00:27:28,889 --> 00:27:35,470
slash followed by a literal dot and

00:27:32,679 --> 00:27:37,929
replace it with nothing but it also has

00:27:35,470 --> 00:27:41,320
this one little trick in here this is a

00:27:37,929 --> 00:27:47,049
forward assertion who's used forward

00:27:41,320 --> 00:27:50,529
assertions before one to really that's

00:27:47,049 --> 00:27:52,720
good because they're worthless I almost

00:27:50,529 --> 00:27:54,369
never found an occasion where I really

00:27:52,720 --> 00:27:56,830
wanted to use the forward assertion and

00:27:54,369 --> 00:27:58,960
sure enough when I wrote this up I found

00:27:56,830 --> 00:28:01,779
it found an occasion where I really

00:27:58,960 --> 00:28:04,090
wanted a forward assertion the forward

00:28:01,779 --> 00:28:07,029
assertion here says it must be followed

00:28:04,090 --> 00:28:08,919
by a slash because in a path you could

00:28:07,029 --> 00:28:11,349
have dot and some letters and that would

00:28:08,919 --> 00:28:14,049
be a file or directory' not a reference

00:28:11,349 --> 00:28:16,059
to the current directory and if I put

00:28:14,049 --> 00:28:19,389
that slash in the literal regular

00:28:16,059 --> 00:28:21,999
expression itself then when this does

00:28:19,389 --> 00:28:25,710
its global over the string it would end

00:28:21,999 --> 00:28:28,479
up consuming a slash which I wish to be

00:28:25,710 --> 00:28:30,639
heart which I wish to appear here in the

00:28:28,479 --> 00:28:33,489
next match of the regular expression so

00:28:30,639 --> 00:28:35,979
this is exactly the case where a forward

00:28:33,489 --> 00:28:39,399
assertion does you some good and that's

00:28:35,979 --> 00:28:41,710
what I used it for here and used one

00:28:39,399 --> 00:28:43,509
when I never use them and almost almost

00:28:41,710 --> 00:28:45,940
would have sworn they should just be

00:28:43,509 --> 00:28:48,999
abandoned because nobody uses it so this

00:28:45,940 --> 00:28:51,429
next one says slash fall followed by one

00:28:48,999 --> 00:28:54,179
or more slashes replace it with a single

00:28:51,429 --> 00:28:57,249
slash now UNIX actually does this if you

00:28:54,179 --> 00:29:00,099
say CB space slash slash slash slash

00:28:57,249 --> 00:29:02,799
slash slash Etsy you end up in slash

00:29:00,099 --> 00:29:05,320
Etsy because inside the kernel it says

00:29:02,799 --> 00:29:07,929
slash slash slash slash slash is the

00:29:05,320 --> 00:29:09,279
same as one slash so that's what we're

00:29:07,929 --> 00:29:11,529
doing here we're just doing it on

00:29:09,279 --> 00:29:15,369
purpose rather than waiting for the

00:29:11,529 --> 00:29:17,889
kernel of do it for us this next part

00:29:15,369 --> 00:29:20,500
this is our loop and this time I'm using

00:29:17,889 --> 00:29:24,520
the version of the Python command

00:29:20,500 --> 00:29:27,130
actually returns to values a tuple I'm

00:29:24,520 --> 00:29:29,410
getting back the path and I'm getting

00:29:27,130 --> 00:29:31,570
back the return bout or rather the

00:29:29,410 --> 00:29:34,600
number of replacements that were made

00:29:31,570 --> 00:29:37,180
and that's how I can bound this loop so

00:29:34,600 --> 00:29:40,390
this loop while true is an infinite loop

00:29:37,180 --> 00:29:43,480
now this is a Python idiom if I were to

00:29:40,390 --> 00:29:47,170
do this in Perl I would just say while s

00:29:43,480 --> 00:29:48,790
slash blah slash and then put an empty

00:29:47,170 --> 00:29:50,350
pair of braces after my purl loop

00:29:48,790 --> 00:29:52,900
because there's nothing actually to do

00:29:50,350 --> 00:29:55,540
in the body of that but this is the

00:29:52,900 --> 00:29:58,090
Python idiom for doing that Python idiom

00:29:55,540 --> 00:30:01,810
is an infinite loop while true and then

00:29:58,090 --> 00:30:03,670
if some expression break so that some

00:30:01,810 --> 00:30:06,550
expression here is returned equal zero

00:30:03,670 --> 00:30:08,590
meaning we made no replacements so what

00:30:06,550 --> 00:30:11,370
it's going to do it's going to consume

00:30:08,590 --> 00:30:15,070
and we have to bound this with a 1 here

00:30:11,370 --> 00:30:17,860
otherwise it runs roughshod and we get

00:30:15,070 --> 00:30:20,910
the wrong path out we want it to consume

00:30:17,860 --> 00:30:25,810
a single parent directory followed by

00:30:20,910 --> 00:30:30,190
slash dot dot we consume the innermost

00:30:25,810 --> 00:30:32,140
one get away from that speaker then the

00:30:30,190 --> 00:30:34,600
loop iterates again and we consume the

00:30:32,140 --> 00:30:37,240
next innermost one but because we're

00:30:34,600 --> 00:30:38,470
reassigning path we're using the same

00:30:37,240 --> 00:30:41,110
variable each time we're actually

00:30:38,470 --> 00:30:44,440
changing the same string so we're

00:30:41,110 --> 00:30:46,900
consuming it in place and as we pull

00:30:44,440 --> 00:30:48,970
them in the loop we're mashing that

00:30:46,900 --> 00:30:52,630
together and what we end up with well I

00:30:48,970 --> 00:30:57,460
think about it in the next slide yeah so

00:30:52,630 --> 00:31:01,720
I brought this into pythons interpreter

00:30:57,460 --> 00:31:05,280
so I could show you this here's the

00:31:01,720 --> 00:31:09,130
first step where we're throwing away

00:31:05,280 --> 00:31:11,140
slash dots and I think here's one and

00:31:09,130 --> 00:31:13,140
here's one and they go away here's the

00:31:11,140 --> 00:31:15,870
next left step where we're throwing away

00:31:13,140 --> 00:31:20,520
mini slashes together and you can see

00:31:15,870 --> 00:31:20,520
mini slashes turn into a single slash

00:31:21,420 --> 00:31:27,450
and here's the loop so the first

00:31:24,810 --> 00:31:31,020
iteration of the loop got rid of the DG

00:31:27,450 --> 00:31:33,480
slash dot dot that was here and this is

00:31:31,020 --> 00:31:37,080
a this is a this is a line continuation

00:31:33,480 --> 00:31:40,470
by the way that's not very clear the

00:31:37,080 --> 00:31:43,950
next iteration got rid of home dot dot

00:31:40,470 --> 00:31:46,590
so that's gone from the front the next

00:31:43,950 --> 00:31:49,320
iteration is getting rid of the x11 dot

00:31:46,590 --> 00:31:52,380
dot then it's getting rid of fonts dot

00:31:49,320 --> 00:31:54,570
dot we're just getting rid of share and

00:31:52,380 --> 00:31:58,800
you know you can see jumping to the end

00:31:54,570 --> 00:32:01,020
that path actually is slash Etsy real

00:31:58,800 --> 00:32:03,330
world stuff here we actually wrote this

00:32:01,020 --> 00:32:05,940
code not the Python version for the C

00:32:03,330 --> 00:32:07,670
version so regular expressions you can

00:32:05,940 --> 00:32:11,370
use them for so many things

00:32:07,670 --> 00:32:18,060
all right go big or go home let's let's

00:32:11,370 --> 00:32:19,800
do something hard so once upon a time I

00:32:18,060 --> 00:32:22,260
worked for a company and we wanted to do

00:32:19,800 --> 00:32:23,810
some fun stuff with Chrome we actually

00:32:22,260 --> 00:32:28,140
wanted to manage crontab

00:32:23,810 --> 00:32:31,710
programmatically and this is what I

00:32:28,140 --> 00:32:35,130
wrote so do you remember earlier I said

00:32:31,710 --> 00:32:37,620
you can use variables you can assign a

00:32:35,130 --> 00:32:40,380
variable with a compiled regular

00:32:37,620 --> 00:32:41,850
expression and then later in another

00:32:40,380 --> 00:32:43,650
regular expression you can reference

00:32:41,850 --> 00:32:45,450
that compiled regular expression to

00:32:43,650 --> 00:32:48,060
build up a more complex regular

00:32:45,450 --> 00:32:50,460
expression that's what we're doing here

00:32:48,060 --> 00:32:52,320
now this is Ruby so the other time I was

00:32:50,460 --> 00:32:55,710
showing you in Perl this is Ruby and you

00:32:52,320 --> 00:32:57,270
can do it in Ruby too so let's see

00:32:55,710 --> 00:32:59,520
what's my next slide I think I start

00:32:57,270 --> 00:33:03,120
breaking this down a little bit no no I

00:32:59,520 --> 00:33:07,200
would give you a cron tap of course so

00:33:03,120 --> 00:33:09,660
this is some example input here and the

00:33:07,200 --> 00:33:13,010
only thing to note about this we

00:33:09,660 --> 00:33:15,810
actually applied a little bit of logical

00:33:13,010 --> 00:33:19,680
interpretation on this I'm gonna check

00:33:15,810 --> 00:33:21,660
my time real quick here Wow a little bit

00:33:19,680 --> 00:33:24,420
of logical interpretation on this to say

00:33:21,660 --> 00:33:27,090
that what we wanted was key value pairs

00:33:24,420 --> 00:33:28,860
so that I could say throw away the

00:33:27,090 --> 00:33:30,260
mailto ticket paragraph or throw away

00:33:28,860 --> 00:33:35,030
the Fred gin

00:33:30,260 --> 00:33:37,250
or change it in this way so the the

00:33:35,030 --> 00:33:41,630
logical interpretation we gave to it was

00:33:37,250 --> 00:33:45,260
a comment preceding a set of Chron lines

00:33:41,630 --> 00:33:47,780
crontab lines the comment is the key and

00:33:45,260 --> 00:33:50,540
the crontab lines of the value so we're

00:33:47,780 --> 00:33:53,570
getting we're getting a key value pair

00:33:50,540 --> 00:33:56,419
interpretation onto this and this stuff

00:33:53,570 --> 00:33:58,280
at the top we're calling the header so

00:33:56,419 --> 00:34:02,480
the header consists of either comments

00:33:58,280 --> 00:34:09,560
or variable settings and this bit at the

00:34:02,480 --> 00:34:13,700
bottom we're calling the tail alright so

00:34:09,560 --> 00:34:15,530
this was the first part of that class we

00:34:13,700 --> 00:34:18,409
have a regular expression to match a

00:34:15,530 --> 00:34:20,149
blank line and Ruby I think it's the

00:34:18,409 --> 00:34:22,010
craziest thing in the world but the

00:34:20,149 --> 00:34:24,889
whitespace character set in Ruby

00:34:22,010 --> 00:34:26,659
includes a new line so since I didn't

00:34:24,889 --> 00:34:29,149
want to match new lines except at the

00:34:26,659 --> 00:34:31,580
end of a line I had to write all these

00:34:29,149 --> 00:34:35,869
character classes to be open bracket

00:34:31,580 --> 00:34:37,879
space tab closed bracket in Perl which

00:34:35,869 --> 00:34:40,940
doesn't include a new line in the

00:34:37,879 --> 00:34:42,320
whitespace I just say backslash ass that

00:34:40,940 --> 00:34:45,350
would be a lot simpler and easier to

00:34:42,320 --> 00:34:47,359
read but this was a ruby so blank line

00:34:45,350 --> 00:34:51,010
that's a regular expression to match a

00:34:47,359 --> 00:34:54,320
blank line comment line some white space

00:34:51,010 --> 00:34:56,240
followed by a pound followed by some

00:34:54,320 --> 00:34:59,530
more white space that's a comment line

00:34:56,240 --> 00:35:03,230
so the tail regular expression is either

00:34:59,530 --> 00:35:08,630
blank lines or comment lines so there's

00:35:03,230 --> 00:35:12,470
the alternation in there zero or more of

00:35:08,630 --> 00:35:14,420
those and again I'm using the question

00:35:12,470 --> 00:35:16,790
colon here to say I don't actually want

00:35:14,420 --> 00:35:18,410
to capture this since this is a parsing

00:35:16,790 --> 00:35:20,570
example what I do want to capture is

00:35:18,410 --> 00:35:23,109
actually pretty critical to me and I

00:35:20,570 --> 00:35:26,840
don't want to capture extraneous stuff

00:35:23,109 --> 00:35:28,790
so the next pair of expressions here's

00:35:26,840 --> 00:35:32,630
one to match a variable line and it's

00:35:28,790 --> 00:35:37,280
quite simply some white space followed

00:35:32,630 --> 00:35:38,020
by some non-white space followed by an

00:35:37,280 --> 00:35:40,090
equals

00:35:38,020 --> 00:35:44,520
I'm followed by some more non-white

00:35:40,090 --> 00:35:48,370
space so the head of that file is either

00:35:44,520 --> 00:35:51,670
blank lines or comment lines or variable

00:35:48,370 --> 00:35:53,860
lines and when we put that input through

00:35:51,670 --> 00:35:57,130
the regular expressions this is what we

00:35:53,860 --> 00:36:01,930
match we match the comment the variables

00:35:57,130 --> 00:36:04,120
oh and we matched our first key Marquis

00:36:01,930 --> 00:36:06,910
value pair so that's a problem right

00:36:04,120 --> 00:36:10,840
well actually it turns out it's not a

00:36:06,910 --> 00:36:13,810
problem because of backtracking when we

00:36:10,840 --> 00:36:15,630
actually use the code the later regular

00:36:13,810 --> 00:36:19,480
expressions to match the key value pair

00:36:15,630 --> 00:36:23,920
force backtracking and when it starts

00:36:19,480 --> 00:36:26,590
backtracking this comment ceases to be a

00:36:23,920 --> 00:36:29,520
part of the head match and then becomes

00:36:26,590 --> 00:36:35,020
a part of the later key value pair match

00:36:29,520 --> 00:36:38,350
all right all of this code is just to

00:36:35,020 --> 00:36:40,330
match that part of the crontab we've got

00:36:38,350 --> 00:36:46,420
something to match a number range a

00:36:40,330 --> 00:36:51,100
number list a step this is a step days

00:36:46,420 --> 00:36:54,040
of them are months days of the week Paul

00:36:51,100 --> 00:36:55,900
vixy's extensions which are at and then

00:36:54,040 --> 00:36:57,730
one of these words reboot so you can say

00:36:55,900 --> 00:37:00,370
you can a vixy cron you can say do this

00:36:57,730 --> 00:37:03,220
only on reboot do this only yearly and

00:37:00,370 --> 00:37:04,840
such and such and then all of those will

00:37:03,220 --> 00:37:07,590
be put together and I called it a run

00:37:04,840 --> 00:37:11,130
spec so a run spec is either an

00:37:07,590 --> 00:37:13,710
extension or it's the number spec

00:37:11,130 --> 00:37:18,130
followed by some white space three times

00:37:13,710 --> 00:37:21,370
cover these first three fields a number

00:37:18,130 --> 00:37:23,410
spec or a month for this next field and

00:37:21,370 --> 00:37:25,420
a number spec or a day for that last

00:37:23,410 --> 00:37:28,210
view so that's a lot of regular

00:37:25,420 --> 00:37:30,010
expression just a match that little bit

00:37:28,210 --> 00:37:33,280
but we're parsing so we want to be able

00:37:30,010 --> 00:37:39,130
to take every kind of combination and

00:37:33,280 --> 00:37:41,290
understand it then I have command line

00:37:39,130 --> 00:37:43,990
this is what I called it that's just the

00:37:41,290 --> 00:37:46,570
run spec followed by some non whitespace

00:37:43,990 --> 00:37:48,680
and when we run that input or at least

00:37:46,570 --> 00:37:50,690
here's a one-line of input

00:37:48,680 --> 00:37:52,460
would match that expression you can see

00:37:50,690 --> 00:37:54,500
here's the part that specifies when to

00:37:52,460 --> 00:37:56,329
do it and there's what to do so the user

00:37:54,500 --> 00:37:59,540
to run this as and in the command that

00:37:56,329 --> 00:38:01,579
was wrong I'm losing the RNA all right

00:37:59,540 --> 00:38:04,010
I'll step it up I'll step it up I'm

00:38:01,579 --> 00:38:07,480
sorry I knew this was gonna yeah

00:38:04,010 --> 00:38:10,309
sorry okay so here's some more of that

00:38:07,480 --> 00:38:13,819
command paragraph to match more than one

00:38:10,309 --> 00:38:17,450
at a time key so this this one's cut

00:38:13,819 --> 00:38:18,950
this one's kind of important so key is

00:38:17,450 --> 00:38:21,710
going to capture this part this is

00:38:18,950 --> 00:38:24,530
basically a non blank comment followed

00:38:21,710 --> 00:38:27,260
by command paragraph this time I'm

00:38:24,530 --> 00:38:29,720
actually using the parens without the

00:38:27,260 --> 00:38:32,420
question quotes in them because this is

00:38:29,720 --> 00:38:35,319
the capture that matters this is what I

00:38:32,420 --> 00:38:39,440
actually want to pull from the file and

00:38:35,319 --> 00:38:43,450
then all so now this is this is the big

00:38:39,440 --> 00:38:45,770
payoff right this is parsing all

00:38:43,450 --> 00:38:48,079
backslash a means start at the beginning

00:38:45,770 --> 00:38:49,819
of the string backslash Z means anchor

00:38:48,079 --> 00:38:53,720
to the end of the string in ruby

00:38:49,819 --> 00:38:55,700
parlance anyway head followed by some

00:38:53,720 --> 00:38:58,400
number of key value pairs followed by

00:38:55,700 --> 00:39:00,799
tails that's a regular expression right

00:38:58,400 --> 00:39:03,109
there and when you use it it matches the

00:39:00,799 --> 00:39:08,119
whole file and if it doesn't match the

00:39:03,109 --> 00:39:13,220
whole file the file is not valid this is

00:39:08,119 --> 00:39:16,369
the rest of that class by the way and if

00:39:13,220 --> 00:39:18,530
you read ruby this is basically just

00:39:16,369 --> 00:39:21,109
three functions the first function

00:39:18,530 --> 00:39:23,839
initialize takes a cron tab in and it

00:39:21,109 --> 00:39:25,910
basically runs it through all tries to

00:39:23,839 --> 00:39:29,750
match that string to all and if that

00:39:25,910 --> 00:39:32,420
fails it raises an error if it doesn't

00:39:29,750 --> 00:39:35,059
fail it uses the captures from the match

00:39:32,420 --> 00:39:36,230
data part of it goes into the head part

00:39:35,059 --> 00:39:38,960
of it goes into the body part of it goes

00:39:36,230 --> 00:39:41,059
in the tail and then the body we rescan

00:39:38,960 --> 00:39:44,030
with the cap regular expression to

00:39:41,059 --> 00:39:46,400
actually get each sub record and here

00:39:44,030 --> 00:39:48,980
we're using a block to pull off the

00:39:46,400 --> 00:39:51,500
comment and take the key and the value

00:39:48,980 --> 00:39:53,599
and basically make a hash of that so now

00:39:51,500 --> 00:39:54,319
we have a class that represents a

00:39:53,599 --> 00:39:57,680
crontab

00:39:54,319 --> 00:40:01,700
as a hash table and then two more

00:39:57,680 --> 00:40:03,230
functions to s basically takes that hash

00:40:01,700 --> 00:40:08,390
and turns it back into the original

00:40:03,230 --> 00:40:10,309
crontab and does this well I was really

00:40:08,390 --> 00:40:13,849
in the one liner mode that day it does

00:40:10,309 --> 00:40:17,299
this with reject and sort and map and

00:40:13,849 --> 00:40:20,269
flatten and join and basically all of

00:40:17,299 --> 00:40:23,240
that comes up with a single string valid

00:40:20,269 --> 00:40:26,660
I like this valid basically says run two

00:40:23,240 --> 00:40:29,380
strings what you got Mac is empty that's

00:40:26,660 --> 00:40:33,380
valid because empty is a valid crontab

00:40:29,380 --> 00:40:35,420
otherwise run the all match and say did

00:40:33,380 --> 00:40:37,309
it match anything if it doesn't match

00:40:35,420 --> 00:40:39,920
anything it's not a valid crontab

00:40:37,309 --> 00:40:41,450
otherwise it is a valid crontab so

00:40:39,920 --> 00:40:46,930
that's a little bit of twisted logic for

00:40:41,450 --> 00:40:49,910
you the summit we're done that was it

00:40:46,930 --> 00:40:52,760
okay so I write a blog or I'm trying to

00:40:49,910 --> 00:40:55,279
write a blog this is my son my son draws

00:40:52,760 --> 00:40:57,230
anime and stuff so this is his picture

00:40:55,279 --> 00:41:00,799
of me and I put it on my blog and this

00:40:57,230 --> 00:41:02,869
blog is about regular expressions so if

00:41:00,799 --> 00:41:06,140
any of this was fun for you or even just

00:41:02,869 --> 00:41:08,750
a little bit you know Dan can code calm

00:41:06,140 --> 00:41:10,819
I'm Dan good I can code sometimes or I

00:41:08,750 --> 00:41:12,470
like to think that I can Dan can code

00:41:10,819 --> 00:41:14,660
calm okay

00:41:12,470 --> 00:41:18,069
where am I on time I threw some extra

00:41:14,660 --> 00:41:22,190
stuff in here just in case I ran short

00:41:18,069 --> 00:41:25,329
I've got 10 minutes left so tell you

00:41:22,190 --> 00:41:30,049
what when I asked if there any questions

00:41:25,329 --> 00:41:32,619
and then ask if you want more does

00:41:30,049 --> 00:41:32,619
anybody have any questions

00:41:32,740 --> 00:41:37,869
crickets yeah oh there's one what's up

00:41:48,830 --> 00:41:57,540
do you see the name of my blog regular

00:41:54,060 --> 00:42:01,410
expressions are largely right only no

00:41:57,540 --> 00:42:03,690
seriously though the way I deal with

00:42:01,410 --> 00:42:06,000
documentation if I really want somebody

00:42:03,690 --> 00:42:08,490
to try and support it later is I do a

00:42:06,000 --> 00:42:10,200
lot of this because what I'm trying to

00:42:08,490 --> 00:42:12,510
do here is instead of writing that

00:42:10,200 --> 00:42:13,320
really long regular expression I'm

00:42:12,510 --> 00:42:15,720
trying to write

00:42:13,320 --> 00:42:19,020
little bitty ones because pretty much

00:42:15,720 --> 00:42:22,620
anyone can pull out the MRE book and say

00:42:19,020 --> 00:42:24,950
oh that's one or more digits followed by

00:42:22,620 --> 00:42:28,920
add at optionally followed by a dash and

00:42:24,950 --> 00:42:32,070
some digits and when they see that and

00:42:28,920 --> 00:42:35,340
see that it's a number range and see

00:42:32,070 --> 00:42:39,840
that a list is just a range maybe a

00:42:35,340 --> 00:42:42,540
comma and another range that's that sort

00:42:39,840 --> 00:42:44,250
of self documenting and that's about as

00:42:42,540 --> 00:42:47,460
good as I think it yes with regular

00:42:44,250 --> 00:42:54,300
expressions frankly I don't usually go

00:42:47,460 --> 00:42:58,670
to that much trouble because because

00:42:54,300 --> 00:43:01,800
none of my co-workers ever asked me to

00:42:58,670 --> 00:43:03,950
to break down regular expressions for

00:43:01,800 --> 00:43:06,540
them they just asked me to write them so

00:43:03,950 --> 00:43:10,620
if you if you follow down this path

00:43:06,540 --> 00:43:12,270
beware this could happen to you but you

00:43:10,620 --> 00:43:13,760
won't need teaching regular expressions

00:43:12,270 --> 00:43:21,860
you'll just be writing

00:43:13,760 --> 00:43:21,860
do we have any other questions please

00:44:02,499 --> 00:44:08,390
that's great this the the shell will let

00:44:06,559 --> 00:44:10,400
you put a literal tab in which I'm sure

00:44:08,390 --> 00:44:12,380
you figured out the control V and then

00:44:10,400 --> 00:44:14,900
the tab but you know you get that into

00:44:12,380 --> 00:44:18,249
an editor and editors like to take tabs

00:44:14,900 --> 00:44:20,839
and turn them to white space for you

00:44:18,249 --> 00:44:22,609
just all the joys

00:44:20,839 --> 00:44:24,789
all right I'll throw this out here just

00:44:22,609 --> 00:44:27,739
in case anybody wants to hear it so

00:44:24,789 --> 00:44:32,209
snort snort rules anybody runs snort

00:44:27,739 --> 00:44:36,920
snorts big and me yeah snort rules does

00:44:32,209 --> 00:44:38,449
this fun thing content and you can put a

00:44:36,920 --> 00:44:43,940
literal string in here but you can also

00:44:38,449 --> 00:44:47,390
put hex hex values to represent

00:44:43,940 --> 00:44:48,709
characters and if you put hex values in

00:44:47,390 --> 00:44:51,199
there let's say you want to convert that

00:44:48,709 --> 00:44:53,479
back to the literal to the literal

00:44:51,199 --> 00:44:56,839
characters I can't do this in my head I

00:44:53,479 --> 00:45:00,079
really can't so I don't know what c2 is

00:44:56,839 --> 00:45:01,969
so I wrote something to do this and of

00:45:00,079 --> 00:45:03,229
course because I've been doing Perl

00:45:01,969 --> 00:45:04,699
longer than I've been doing most of

00:45:03,229 --> 00:45:07,849
these other languages that's what I fell

00:45:04,699 --> 00:45:10,459
back to and this is what I wrote to do

00:45:07,849 --> 00:45:11,869
it and this uses some of my favorite

00:45:10,459 --> 00:45:13,219
pearl isms and that's what I want to

00:45:11,869 --> 00:45:15,799
throw out not so much the regular

00:45:13,219 --> 00:45:19,099
expression but just some one more

00:45:15,799 --> 00:45:22,400
favorite pearl ism and that is the EEG

00:45:19,099 --> 00:45:25,390
or II really does anybody use the e

00:45:22,400 --> 00:45:30,109
switch for your replacements in pearl

00:45:25,390 --> 00:45:32,809
what the e switch does it says alright

00:45:30,109 --> 00:45:36,079
so everybody knows s slash pattern slash

00:45:32,809 --> 00:45:37,999
string and then we put a G on the end

00:45:36,079 --> 00:45:40,289
and that says do that as many times as

00:45:37,999 --> 00:45:44,170
possible on a given string

00:45:40,289 --> 00:45:47,829
the e says take the string part of that

00:45:44,170 --> 00:45:52,089
replacement and use it as code evaluate

00:45:47,829 --> 00:45:55,569
it as courage so in this case what I did

00:45:52,089 --> 00:45:58,089
is I said match the content part and I'm

00:45:55,569 --> 00:45:59,349
using percents here instead of slashes

00:45:58,089 --> 00:46:02,980
because percents look kind of like

00:45:59,349 --> 00:46:04,450
slashes again the whole said thing using

00:46:02,980 --> 00:46:08,079
commas and set of slashes when you have

00:46:04,450 --> 00:46:11,470
slashes to match so for sense here match

00:46:08,079 --> 00:46:13,809
the content portion and then take that

00:46:11,470 --> 00:46:17,200
match and run this piece of code on it

00:46:13,809 --> 00:46:21,250
well you can nest this believe it or not

00:46:17,200 --> 00:46:23,410
so what I did is I nested it in order to

00:46:21,250 --> 00:46:25,900
nest it though you need to you need to

00:46:23,410 --> 00:46:28,119
use a temporary variable to capture what

00:46:25,900 --> 00:46:29,170
the dollar one pointed to because

00:46:28,119 --> 00:46:31,599
otherwise dollar one's going to point

00:46:29,170 --> 00:46:33,970
something new so I'm capturing the

00:46:31,599 --> 00:46:36,240
dollar one into m and then I'm using M

00:46:33,970 --> 00:46:40,329
in another expression and that

00:46:36,240 --> 00:46:44,559
expression actually also uses the e

00:46:40,329 --> 00:46:48,359
switch and it does the hex the hex

00:46:44,559 --> 00:46:48,359
conversion to a real character again

00:47:52,200 --> 00:47:58,730
what about this I can help the legged we

00:47:54,780 --> 00:47:58,730
have the same problem or whatever to do

00:48:01,940 --> 00:48:04,990
that's not the word out

00:49:14,310 --> 00:49:20,920
as a service leader in cloud computing

00:49:17,410 --> 00:49:22,510
all we do is hosted computing to us the

00:49:20,920 --> 00:49:24,520
cloud is just the next generation of

00:49:22,510 --> 00:49:26,380
hosting and if someone who's been in the

00:49:24,520 --> 00:49:28,360
hosting industry for 12 years we feel

00:49:26,380 --> 00:49:29,530
we're in a unique position to really

00:49:28,360 --> 00:49:31,660
help bring these two worlds together

00:49:29,530 --> 00:49:34,000
these different sets of technologies and

00:49:31,660 --> 00:49:36,310
to help companies embrace this new world

00:49:34,000 --> 00:49:38,380
and this great new tool that allows

00:49:36,310 --> 00:49:40,930
faster innovation not only is it about

00:49:38,380 --> 00:49:46,330
us being responsive and accountable but

00:49:40,930 --> 00:49:49,140
it's about us doing more for you rev OS

00:49:46,330 --> 00:49:52,720
an OS that works the way that you do

00:49:49,140 --> 00:49:56,850
across all your devices HP Slate and

00:49:52,720 --> 00:49:56,850

YouTube URL: https://www.youtube.com/watch?v=u5fOApt9Pi4


