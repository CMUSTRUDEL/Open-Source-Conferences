Title: 2011 SouthEast LinuxFest - Steven King - Configuration Management and Consistency
Publication date: 2012-03-24
Playlist: 2011 SouthEast LinuxFest
Description: 
	2011 SouthEast LinuxFest - Steven King - Configuration Management and Environment Consistency

This video is licensed under Creative Commons Attribution 3.0 Unported License.
Captions: 
	00:00:01,159 --> 00:00:07,319
the following presentation was recorded

00:00:04,230 --> 00:00:09,900
at the 2011 southeast linux fest in

00:00:07,319 --> 00:00:11,400
Spartanburg South Carolina it is

00:00:09,900 --> 00:00:14,219
licensed under a creative commons

00:00:11,400 --> 00:00:18,390
license for more information about the

00:00:14,219 --> 00:00:21,869
southeast linux fest visit www southeast

00:00:18,390 --> 00:00:23,100
linux fest org the southeast linux fest

00:00:21,869 --> 00:00:26,460
would like to thank the following

00:00:23,100 --> 00:00:30,380
diamond and platinum sponsors in 2011

00:00:26,460 --> 00:00:30,380
for helping make these videos possible

00:03:45,190 --> 00:04:18,190
hello hello this work should i make the

00:04:13,430 --> 00:04:18,190
print bigger yeah

00:04:30,400 --> 00:04:32,460
you

00:04:35,630 --> 00:04:47,690
you guys in the back ready hello I love

00:04:42,170 --> 00:04:52,220
Ruby hello hello we're going to talk

00:04:47,690 --> 00:04:55,010
about Ruby today now soon we're going to

00:04:52,220 --> 00:04:59,900
talk about Ruby my favorite language

00:04:55,010 --> 00:05:01,880
okay well hello everybody we're finally

00:04:59,900 --> 00:05:05,690
ready to begin and I'm going to talk

00:05:01,880 --> 00:05:07,640
about my favorite language Ruby I have a

00:05:05,690 --> 00:05:11,230
little slideshow prepared on my Mac but

00:05:07,640 --> 00:05:11,230
I'm running my boon to vm on the Mac

00:05:13,150 --> 00:05:17,300
first of all I'm a software developer i

00:05:15,110 --> 00:05:19,430
live in the Washington DC area I've done

00:05:17,300 --> 00:05:22,010
a lot of Java work and before that C++

00:05:19,430 --> 00:05:23,930
and before that see now I'm into Ruby a

00:05:22,010 --> 00:05:27,650
little bit of Android I have some other

00:05:23,930 --> 00:05:33,050
interests as well and just so we can

00:05:27,650 --> 00:05:34,730
have a little bit of levity here a DBA

00:05:33,050 --> 00:05:41,770
walks into a bar steps in front of two

00:05:34,730 --> 00:05:41,770
tables and says anybody may I join you

00:05:45,580 --> 00:05:56,900
ok so like this full screen and so ask

00:05:54,980 --> 00:05:58,550
me to slow down if you need me to ask

00:05:56,900 --> 00:06:01,340
questions if you have something that you

00:05:58,550 --> 00:06:05,270
are confused about feel free to share

00:06:01,340 --> 00:06:07,040
your own observations an overview of

00:06:05,270 --> 00:06:09,650
what i love about ruby is i came from

00:06:07,040 --> 00:06:11,960
about 10 years of java development and

00:06:09,650 --> 00:06:13,520
you know in the end it was so painful i

00:06:11,960 --> 00:06:16,820
was doing anything I could to avoid it

00:06:13,520 --> 00:06:20,360
trying to sneak Ruby into my work for

00:06:16,820 --> 00:06:23,660
unit testing or or scripting or things

00:06:20,360 --> 00:06:26,300
like that what I love about Ruby

00:06:23,660 --> 00:06:28,370
includes its conciseness and clarity

00:06:26,300 --> 00:06:29,690
it's very concise there are other

00:06:28,370 --> 00:06:34,300
languages that are concise but they're

00:06:29,690 --> 00:06:34,300
not necessarily clear ruby is both

00:06:34,360 --> 00:06:42,050
devoid of ceremony ceremony is the kind

00:06:38,900 --> 00:06:44,840
of the it's a low signal-to-noise reach

00:06:42,050 --> 00:06:46,880
ratio it's the presence of code that you

00:06:44,840 --> 00:06:48,860
have to write to get the language to do

00:06:46,880 --> 00:06:49,430
something there really has nothing to do

00:06:48,860 --> 00:06:52,100
with the business

00:06:49,430 --> 00:06:55,090
problem and feels unnecessary there's a

00:06:52,100 --> 00:06:59,120
lot of that with Java and get into that

00:06:55,090 --> 00:07:01,310
expressive syntax you can write Ruby in

00:06:59,120 --> 00:07:04,430
such a way that the reader can Intuit

00:07:01,310 --> 00:07:07,010
what it is that you mean powerful

00:07:04,430 --> 00:07:08,510
innumerable processing there are many

00:07:07,010 --> 00:07:11,600
functions that you can call on

00:07:08,510 --> 00:07:14,240
innumerable such as a raise that make

00:07:11,600 --> 00:07:17,380
your work much clearer and more succinct

00:07:14,240 --> 00:07:21,380
and make the language much more powerful

00:07:17,380 --> 00:07:23,390
code blocks and closures code blocks are

00:07:21,380 --> 00:07:25,420
little fragments of code that you can

00:07:23,390 --> 00:07:27,800
pass to a function you can pass around

00:07:25,420 --> 00:07:29,630
closures our code blocks which carry

00:07:27,800 --> 00:07:33,170
with them the context in which they were

00:07:29,630 --> 00:07:37,220
created so you can create a code block

00:07:33,170 --> 00:07:41,450
that says puts foo the variable foo my

00:07:37,220 --> 00:07:43,190
quotes the variable foo and you can pass

00:07:41,450 --> 00:07:45,560
that to a function and that function

00:07:43,190 --> 00:07:47,600
will know what foo is even though it

00:07:45,560 --> 00:07:50,510
wasn't defined in its scope and that's

00:07:47,600 --> 00:07:52,610
how a closure is kind of a subset of a

00:07:50,510 --> 00:07:55,940
code block and both are supported in

00:07:52,610 --> 00:07:59,570
Ruby everything is an object in Ruby

00:07:55,940 --> 00:08:04,910
even one even nil even true and false

00:07:59,570 --> 00:08:06,500
they're all objects ranges ranges our

00:08:04,910 --> 00:08:08,720
first class objects you can define a

00:08:06,500 --> 00:08:11,800
range and put it literally in your code

00:08:08,720 --> 00:08:14,540
and use it you pass it to a function

00:08:11,800 --> 00:08:16,400
regular expressions are also first class

00:08:14,540 --> 00:08:19,310
objects that you can express as literals

00:08:16,400 --> 00:08:21,110
which is very handy and by the way i

00:08:19,310 --> 00:08:23,000
realized that i'm at a linux conference

00:08:21,110 --> 00:08:25,730
and a lot of you guys are into perl and

00:08:23,000 --> 00:08:28,040
python so forgive me if you know this

00:08:25,730 --> 00:08:29,510
stuff is is not you know i know that a

00:08:28,040 --> 00:08:32,000
lot of this stuff is also common to

00:08:29,510 --> 00:08:33,890
Python and Perl but I'm not really very

00:08:32,000 --> 00:08:35,420
familiar with those so I'm just telling

00:08:33,890 --> 00:08:37,010
you what I love about Ruby and maybe

00:08:35,420 --> 00:08:40,730
what I would love about Python and Perl

00:08:37,010 --> 00:08:42,350
as well jruby is an implementation of

00:08:40,730 --> 00:08:47,540
Ruby that runs on a Java Virtual Machine

00:08:42,350 --> 00:08:50,960
and this can be really powerful for many

00:08:47,540 --> 00:08:54,110
reasons first of all Java can perform

00:08:50,960 --> 00:08:57,200
better than the native see Ruby because

00:08:54,110 --> 00:08:58,910
it has a hotspot compiler while as our

00:08:57,200 --> 00:09:00,470
program is running the Java Virtual

00:08:58,910 --> 00:09:01,880
Machine is watching it to see what it's

00:09:00,470 --> 00:09:02,450
doing and if it does the same thing

00:09:01,880 --> 00:09:05,210
10,000

00:09:02,450 --> 00:09:06,290
x it figures out a way or sometimes

00:09:05,210 --> 00:09:10,760
figures out a way to do it more quickly

00:09:06,290 --> 00:09:14,330
and bypass steps and save time that way

00:09:10,760 --> 00:09:16,120
also you have access to a multitude of

00:09:14,330 --> 00:09:18,590
Java libraries that are out there

00:09:16,120 --> 00:09:20,810
another reason jruby can be handy is

00:09:18,590 --> 00:09:23,150
there are a lot of shops that would be

00:09:20,810 --> 00:09:24,980
very resistant to bring in a new

00:09:23,150 --> 00:09:28,280
language and all the installation

00:09:24,980 --> 00:09:30,200
administration overhead JRuby comes to

00:09:28,280 --> 00:09:32,660
you in the form of a single jar file of

00:09:30,200 --> 00:09:35,180
course you have to have a Java Runtime

00:09:32,660 --> 00:09:37,100
on your machine but basically it's one

00:09:35,180 --> 00:09:42,800
jar file that you can install and then

00:09:37,100 --> 00:09:44,990
use IRB IRB is interactive shell in

00:09:42,800 --> 00:09:49,940
which you can run Ruby and it's very

00:09:44,990 --> 00:09:51,920
handy for testing concepts out testing

00:09:49,940 --> 00:09:54,500
minimal things out and experimenting

00:09:51,920 --> 00:09:58,210
with the language and we'll see some

00:09:54,500 --> 00:10:01,310
more of that later OS scripting support

00:09:58,210 --> 00:10:03,770
I use Ruby as a shell scripting language

00:10:01,310 --> 00:10:05,690
sometimes and I'm not really that

00:10:03,770 --> 00:10:08,000
familiar with shell scripting you know

00:10:05,690 --> 00:10:09,350
the regular shell scripting but it's an

00:10:08,000 --> 00:10:10,610
awesome shell scripting language and

00:10:09,350 --> 00:10:17,870
you'll see a little bit of that later

00:10:10,610 --> 00:10:19,580
too so I have some examples and I'm

00:10:17,870 --> 00:10:22,640
sorry about the screen it's a little bit

00:10:19,580 --> 00:10:25,040
cut off of the verbosity of Java versus

00:10:22,640 --> 00:10:27,950
the conciseness of Ruby and here's one

00:10:25,040 --> 00:10:29,360
example the Java program that you would

00:10:27,950 --> 00:10:31,700
have to write to just print to the

00:10:29,360 --> 00:10:33,310
screen hello world look at that there

00:10:31,700 --> 00:10:36,440
are so many things about it that are

00:10:33,310 --> 00:10:38,630
inscrutable to the beginning user what

00:10:36,440 --> 00:10:40,630
is public what a static what is void you

00:10:38,630 --> 00:10:42,680
know and what is the meaning of main and

00:10:40,630 --> 00:10:46,100
remember you can just say puts hello

00:10:42,680 --> 00:10:49,130
world I'm going to change this a little

00:10:46,100 --> 00:10:55,520
bit and see if it works better okay I

00:10:49,130 --> 00:10:56,990
think that's better another thing in

00:10:55,520 --> 00:10:58,250
Java that's really frustrating is that

00:10:56,990 --> 00:10:59,960
you have to define your getters and

00:10:58,250 --> 00:11:04,010
setters you don't have to do that in

00:10:59,960 --> 00:11:05,810
ruby ruby has meta programming which

00:11:04,010 --> 00:11:08,750
allows you to create functions on the

00:11:05,810 --> 00:11:11,420
fly and so what you have here is

00:11:08,750 --> 00:11:12,650
attribute access ER under the covers

00:11:11,420 --> 00:11:14,180
that's really a function and you're

00:11:12,650 --> 00:11:16,070
passing it a symbol which is kind of

00:11:14,180 --> 00:11:18,410
like a string in turn the

00:11:16,070 --> 00:11:20,000
an intern string and what it does is it

00:11:18,410 --> 00:11:22,130
defines the getter function and a center

00:11:20,000 --> 00:11:27,470
function for that property it does all

00:11:22,130 --> 00:11:30,560
that for you here's a case of

00:11:27,470 --> 00:11:32,330
subtracting 1 array from another it's

00:11:30,560 --> 00:11:35,090
amazing how we're both you have to be in

00:11:32,330 --> 00:11:37,520
Java the top is Java and the bottom is

00:11:35,090 --> 00:11:42,200
Ruby you remember you can just say one

00:11:37,520 --> 00:11:44,890
or a minus another array by the way how

00:11:42,200 --> 00:11:47,450
many of you folks are Java developers

00:11:44,890 --> 00:11:49,460
probably this okay so this isn't really

00:11:47,450 --> 00:11:53,240
relevant to too many of you but I'll

00:11:49,460 --> 00:11:54,620
pass through this quickly here's another

00:11:53,240 --> 00:11:57,340
case where are you just defining a

00:11:54,620 --> 00:12:00,440
function that returns a list that

00:11:57,340 --> 00:12:04,730
doubles the original list and another

00:12:00,440 --> 00:12:06,500
example of Ruby's conciseness in clarity

00:12:04,730 --> 00:12:09,670
other than the new block syntax which

00:12:06,500 --> 00:12:09,670
might be a little confusing at first

00:12:09,910 --> 00:12:16,010
multi-line strings it's very easy to

00:12:13,580 --> 00:12:18,740
define a multi-line string and if you

00:12:16,010 --> 00:12:21,380
use double quotes in Ruby then the

00:12:18,740 --> 00:12:24,710
string will substitute values that it

00:12:21,380 --> 00:12:26,120
sees in pound curly brace for the result

00:12:24,710 --> 00:12:32,420
of the expression within those braces

00:12:26,120 --> 00:12:35,660
and so this is a template that can be

00:12:32,420 --> 00:12:38,450
evaluated and in Java you have to define

00:12:35,660 --> 00:12:41,450
each string literal individually for

00:12:38,450 --> 00:12:45,860
each line and so this is much easier to

00:12:41,450 --> 00:12:50,270
work with and you can put any arbitrary

00:12:45,860 --> 00:12:52,940
function in there mots the guy he rode

00:12:50,270 --> 00:12:55,850
Ruby he tried to make it really clear he

00:12:52,940 --> 00:12:58,220
took it from parts from see Preston

00:12:55,850 --> 00:12:59,600
pearl parts from small talk but he

00:12:58,220 --> 00:13:01,040
thought well what would I like to see in

00:12:59,600 --> 00:13:02,690
a language and so there are a lot of

00:13:01,040 --> 00:13:05,480
things in Ruby that are just there

00:13:02,690 --> 00:13:07,130
because it's kind of like well this this

00:13:05,480 --> 00:13:10,280
makes sense to me this makes it simple

00:13:07,130 --> 00:13:12,380
to use so because numbers number of

00:13:10,280 --> 00:13:14,210
literals are objects you can do stuff

00:13:12,380 --> 00:13:16,760
like this you can say three times and

00:13:14,210 --> 00:13:21,620
then pass it a block and then that block

00:13:16,760 --> 00:13:25,910
will be executed three times arrays can

00:13:21,620 --> 00:13:27,770
be defined either this way or if their

00:13:25,910 --> 00:13:29,740
words separated by spaces there's a

00:13:27,770 --> 00:13:34,220
shortcut you can do it this way

00:13:29,740 --> 00:13:38,360
you have hashes so these are key value

00:13:34,220 --> 00:13:40,340
pairs you have negative sub scripting

00:13:38,360 --> 00:13:43,250
which will subscript from the end of the

00:13:40,340 --> 00:13:44,990
Ray backwards which can be handy and

00:13:43,250 --> 00:13:50,060
they're also convenience functions like

00:13:44,990 --> 00:13:52,010
first and last for arrays and we went

00:13:50,060 --> 00:13:55,340
the over the attribute accessor another

00:13:52,010 --> 00:13:57,200
nice touch is that once every once or

00:13:55,340 --> 00:13:59,450
twice a year I come up with a situation

00:13:57,200 --> 00:14:00,710
where I have to define us a numeric

00:13:59,450 --> 00:14:02,270
literal that's really long like a

00:14:00,710 --> 00:14:06,200
million or ten million or something like

00:14:02,270 --> 00:14:07,820
that and I always break it down into

00:14:06,200 --> 00:14:10,850
like a thousand times a thousand because

00:14:07,820 --> 00:14:11,960
I know that it's not going to be you

00:14:10,850 --> 00:14:13,040
know it's only going to be negligible

00:14:11,960 --> 00:14:14,660
cost but it's going to make it a lot

00:14:13,040 --> 00:14:15,710
more readable well you don't have to do

00:14:14,660 --> 00:14:17,980
that in Ruby you can just use

00:14:15,710 --> 00:14:20,390
underscores as thousand separators and

00:14:17,980 --> 00:14:24,110
when Ruby sees those it'll just throw

00:14:20,390 --> 00:14:34,370
them away so it's just another nice

00:14:24,110 --> 00:14:38,350
touch any questions so far sure good

00:14:34,370 --> 00:14:46,420
yeah it's good to go to IRB a lot so

00:14:38,350 --> 00:14:50,930
let's go to IRB here and we can see that

00:14:46,420 --> 00:14:53,060
this is the it's it's IRB will show

00:14:50,930 --> 00:14:55,730
you the result of the expression on the

00:14:53,060 --> 00:14:58,550
line after you've typed it so whatever

00:14:55,730 --> 00:15:02,180
this expression evaluates to will be

00:14:58,550 --> 00:15:05,030
displayed if I ask it what is the class

00:15:02,180 --> 00:15:08,810
of this thing it'll show me that it's a

00:15:05,030 --> 00:15:09,860
fixed numb now the underscores our kind

00:15:08,810 --> 00:15:11,840
of arbitrary you can put them anywhere

00:15:09,860 --> 00:15:19,400
you want even where they don't make

00:15:11,840 --> 00:15:24,410
sense and they will be ignored they're

00:15:19,400 --> 00:15:28,700
just totally ignored okay any any other

00:15:24,410 --> 00:15:31,490
questions okay so I was talking about

00:15:28,700 --> 00:15:34,760
ranges before so we have this range here

00:15:31,490 --> 00:15:36,710
where we have 12 12 you can convert a

00:15:34,760 --> 00:15:39,200
lot of objects can be converted to

00:15:36,710 --> 00:15:41,360
arrays if it makes sense that one can

00:15:39,200 --> 00:15:43,400
convert this object to an array then the

00:15:41,360 --> 00:15:46,220
author of the class will write it to a

00:15:43,400 --> 00:15:48,530
function and arrays are no exception you

00:15:46,220 --> 00:15:52,540
can create you can convert a range to an

00:15:48,530 --> 00:15:54,380
array and that can be handy another I

00:15:52,540 --> 00:15:56,780
talked about a numeral reprocessing

00:15:54,380 --> 00:15:59,300
before we have here at a map function

00:15:56,780 --> 00:16:02,630
which is really really powerful and what

00:15:59,300 --> 00:16:04,520
the map function does is it says with

00:16:02,630 --> 00:16:10,280
this innumerable that I'm calling the

00:16:04,520 --> 00:16:12,350
map function on return an array for

00:16:10,280 --> 00:16:15,470
which each new element and each element

00:16:12,350 --> 00:16:19,730
in the new array will take the old array

00:16:15,470 --> 00:16:22,010
and then apply this expression to it so

00:16:19,730 --> 00:16:25,430
what this is doing here is it saying

00:16:22,010 --> 00:16:29,540
take the numbs the input array and for

00:16:25,430 --> 00:16:32,210
each element in it call it n and perform

00:16:29,540 --> 00:16:35,690
this evaluate this expression on it so

00:16:32,210 --> 00:16:50,630
what this returns is an array I'm sorry

00:16:35,690 --> 00:16:55,250
what oh thank you ok thanks gosh how'd

00:16:50,630 --> 00:16:57,470
that happen anyway so as you see you're

00:16:55,250 --> 00:16:59,570
getting oh this isn't doubling I'm sorry

00:16:57,470 --> 00:17:03,760
it's squaring it so this is returning an

00:16:59,570 --> 00:17:03,760
array same size as the original array

00:17:06,160 --> 00:17:14,690
same size of the original right but

00:17:09,530 --> 00:17:25,690
squares array subtraction ok so we we're

00:17:14,690 --> 00:17:25,690
getting ed even let's see here it's good

00:17:33,360 --> 00:17:40,230
yeah it's snug

00:17:52,340 --> 00:17:55,970
we're all let's try that

00:18:05,420 --> 00:18:13,470
so we've seen the squares to get the

00:18:11,100 --> 00:18:16,020
even numbers we're taking the input

00:18:13,470 --> 00:18:18,720
array and calling the Select function

00:18:16,020 --> 00:18:20,910
which filters the input array and only

00:18:18,720 --> 00:18:22,440
allows into the output array those

00:18:20,910 --> 00:18:25,980
elements for which the expression

00:18:22,440 --> 00:18:29,100
evaluates to true so the expression is

00:18:25,980 --> 00:18:32,790
the number in the input array mod 2

00:18:29,100 --> 00:18:35,490
should equal zero so it'll only let the

00:18:32,790 --> 00:18:37,020
even numbers in and to get the odd

00:18:35,490 --> 00:18:39,540
numbers we can just subtract the even

00:18:37,020 --> 00:18:40,890
numbers from all the numbers that's one

00:18:39,540 --> 00:18:45,210
way we can do it we could also of course

00:18:40,890 --> 00:18:46,770
du equals 1 instead of equals 0 another

00:18:45,210 --> 00:18:50,250
innumerable function that can be really

00:18:46,770 --> 00:18:53,040
powerful this inject inject will create

00:18:50,250 --> 00:18:58,050
a single value from the input array and

00:18:53,040 --> 00:19:00,930
you you have an executable piece of code

00:18:58,050 --> 00:19:05,340
that carries a value with it through

00:19:00,930 --> 00:19:07,860
each iteration and does something useful

00:19:05,340 --> 00:19:12,360
for you in this case we're just getting

00:19:07,860 --> 00:19:16,640
a sum and so we have a sum and we're

00:19:12,360 --> 00:19:16,640
just adding to the sum at each iteration

00:19:18,890 --> 00:19:22,790
I'm going to touch this very carefully

00:19:23,780 --> 00:19:29,370
functions can have code blocks past to

00:19:26,220 --> 00:19:31,830
them this was kind of weird for me at

00:19:29,370 --> 00:19:34,770
first you can pass a code block to a

00:19:31,830 --> 00:19:37,770
function and the function can execute

00:19:34,770 --> 00:19:41,250
that code block on your behalf it does

00:19:37,770 --> 00:19:42,690
so using the yield keyword and the

00:19:41,250 --> 00:19:44,910
mechanics are a little bit confusing at

00:19:42,690 --> 00:19:47,030
first but once you've done a little bit

00:19:44,910 --> 00:19:50,460
it gets a lot easier to understand

00:19:47,030 --> 00:19:52,320
here's an example of a function and this

00:19:50,460 --> 00:19:53,790
def is the beginning of a function

00:19:52,320 --> 00:19:56,970
definition so we're defining a function

00:19:53,790 --> 00:19:58,890
named foo and it's just going to be this

00:19:56,970 --> 00:20:02,610
one line because this end terminates the

00:19:58,890 --> 00:20:05,430
function definition and in the function

00:20:02,610 --> 00:20:10,740
we're saying is it was a blot given to

00:20:05,430 --> 00:20:13,710
me if so then yield that is executed if

00:20:10,740 --> 00:20:16,290
not then just put city is standard out

00:20:13,710 --> 00:20:17,840
Knobloch given it's very simple but it

00:20:16,290 --> 00:20:20,419
illustrates to the

00:20:17,840 --> 00:20:22,130
power of your functions can behave

00:20:20,419 --> 00:20:25,700
differently depending on whether or not

00:20:22,130 --> 00:20:28,669
a block has been passed to it so here's

00:20:25,700 --> 00:20:32,539
an example of passing a block to that

00:20:28,669 --> 00:20:35,960
function and it executes the code that

00:20:32,539 --> 00:20:45,159
you passed it or not passing a code

00:20:35,960 --> 00:20:45,159
block to it everybody okay so far okay

00:20:48,130 --> 00:20:56,510
yes ruby has a special convenience

00:20:53,750 --> 00:21:00,230
whereby if a block is the last argument

00:20:56,510 --> 00:21:02,360
it's not a named argument you could of

00:21:00,230 --> 00:21:03,620
course create a code block a scientific

00:21:02,360 --> 00:21:10,159
variable and pass it as any other

00:21:03,620 --> 00:21:13,279
argument if you wanted to so and as I

00:21:10,159 --> 00:21:15,890
mentioned before closures are a subset

00:21:13,279 --> 00:21:18,980
of code blocks and closures carry the

00:21:15,890 --> 00:21:22,750
scope with them so here I'm defining a

00:21:18,980 --> 00:21:26,899
variable name that has the value Joe and

00:21:22,750 --> 00:21:28,460
saying hi Joe three times now what's

00:21:26,899 --> 00:21:32,630
happening here is that the times

00:21:28,460 --> 00:21:35,480
function of the object three is being

00:21:32,630 --> 00:21:37,940
called with a code block so if you think

00:21:35,480 --> 00:21:39,260
about it usually inside a class method

00:21:37,940 --> 00:21:41,690
somewhere you don't have scope to

00:21:39,260 --> 00:21:43,399
somebody else is stacked right but what

00:21:41,690 --> 00:21:44,779
Ruby does is it passes a binding which

00:21:43,399 --> 00:21:46,580
has a lot of information about the

00:21:44,779 --> 00:21:49,580
context of where the code block was

00:21:46,580 --> 00:21:58,399
created so that in the function it has

00:21:49,580 --> 00:22:00,529
access to that variable and this is one

00:21:58,399 --> 00:22:02,360
of my favorite features of code blocks

00:22:00,529 --> 00:22:04,610
it's just awesome because in your

00:22:02,360 --> 00:22:06,440
program how many times have you had to

00:22:04,610 --> 00:22:08,510
really be concerned about am i closing

00:22:06,440 --> 00:22:11,600
all the files i'm opening am I releasing

00:22:08,510 --> 00:22:14,360
all the resources I'm allocating using

00:22:11,600 --> 00:22:16,789
this block mechanism you can guarantee

00:22:14,360 --> 00:22:20,240
it so you don't have to think about it

00:22:16,789 --> 00:22:24,049
anymore the ruby file that open command

00:22:20,240 --> 00:22:26,090
if you pass it a block this is the block

00:22:24,049 --> 00:22:28,659
that you want it to execute with the

00:22:26,090 --> 00:22:31,280
open file it will open the file for you

00:22:28,659 --> 00:22:31,640
pass the file handle to your block so

00:22:31,280 --> 00:22:32,900
you can

00:22:31,640 --> 00:22:37,220
whatever you want to do with that file

00:22:32,900 --> 00:22:39,380
and then close the file for you and it's

00:22:37,220 --> 00:22:41,600
calling block given so that if you don't

00:22:39,380 --> 00:22:43,850
pass it a block it says oh I guess you

00:22:41,600 --> 00:22:45,530
just want a file handle and it gives you

00:22:43,850 --> 00:22:48,350
a file handle and you do what you want

00:22:45,530 --> 00:22:50,420
with it and you close it yourself but

00:22:48,350 --> 00:22:54,560
this is really cool I think so anyway

00:22:50,420 --> 00:22:56,900
and in when I use Ruby for kind of shell

00:22:54,560 --> 00:22:59,390
scripting i use the dirt changed or

00:22:56,900 --> 00:23:01,550
function which does a similar thing it

00:22:59,390 --> 00:23:03,410
changes to the name directory performs

00:23:01,550 --> 00:23:05,840
the code in your code block and then

00:23:03,410 --> 00:23:11,840
pops back to the directory that you

00:23:05,840 --> 00:23:14,330
began in yeah yes yes there they're

00:23:11,840 --> 00:23:16,280
synonyms the convention in ruby is that

00:23:14,330 --> 00:23:17,990
if your code fits on a single line you

00:23:16,280 --> 00:23:20,000
use the curly braces if it doesn't you

00:23:17,990 --> 00:23:27,110
used you end but yeah they're really the

00:23:20,000 --> 00:23:28,910
same same thing so as I mentioned before

00:23:27,110 --> 00:23:31,730
everything is an object and here are

00:23:28,910 --> 00:23:35,420
some examples number one this is an

00:23:31,730 --> 00:23:39,410
empty array this is an empty hash this

00:23:35,420 --> 00:23:41,240
is an empty regular expression this is

00:23:39,410 --> 00:23:42,800
self which if you're familiar with

00:23:41,240 --> 00:23:44,180
object if you know another object

00:23:42,800 --> 00:23:45,590
oriented programming language so I'm

00:23:44,180 --> 00:23:49,250
sure you have something like it it might

00:23:45,590 --> 00:23:50,660
be called this and of course it can

00:23:49,250 --> 00:23:53,840
represent a different class depending on

00:23:50,660 --> 00:23:59,320
the context Neal is a class arranged as

00:23:53,840 --> 00:24:01,610
a class so here's something about ranges

00:23:59,320 --> 00:24:03,830
you can convert them to arrays as we

00:24:01,610 --> 00:24:06,170
mentioned if you use three dots instead

00:24:03,830 --> 00:24:09,350
of two then it'll exclude the higher

00:24:06,170 --> 00:24:11,120
bound which is handy for those minus one

00:24:09,350 --> 00:24:14,060
situations where we have to say for i

00:24:11,120 --> 00:24:15,470
equals 0 to something minus 1 you know

00:24:14,060 --> 00:24:22,310
how to do that anymore it can just use

00:24:15,470 --> 00:24:27,770
the three-dot range and you can also

00:24:22,310 --> 00:24:34,760
slice an array and you can you can pass

00:24:27,770 --> 00:24:36,650
a range to slice that array and regular

00:24:34,760 --> 00:24:38,090
expressions you can use you can specify

00:24:36,650 --> 00:24:38,960
a regular expression as a literal you

00:24:38,090 --> 00:24:43,550
don't have to assign it to a variable

00:24:38,960 --> 00:24:45,620
first this operator here the equal chill

00:24:43,550 --> 00:24:47,660
de returns in index into

00:24:45,620 --> 00:24:50,210
the string of the first occurrence of

00:24:47,660 --> 00:24:53,930
the regular expression or an L if it

00:24:50,210 --> 00:24:56,600
doesn't occur the triple equal returns a

00:24:53,930 --> 00:24:58,520
true or false true if the regular

00:24:56,600 --> 00:25:02,059
expression matches it all false if it

00:24:58,520 --> 00:25:04,160
doesn't at all and we'll see you later

00:25:02,059 --> 00:25:06,610
there there's a way to use this in a

00:25:04,160 --> 00:25:12,110
case statement that's very concise and

00:25:06,610 --> 00:25:15,250
readable so here we have a sample array

00:25:12,110 --> 00:25:19,460
or defining an array with a % w and

00:25:15,250 --> 00:25:24,080
we're repping the array for Strings that

00:25:19,460 --> 00:25:26,059
begin with p and we get this result and

00:25:24,080 --> 00:25:27,500
we're doing the same thing here but

00:25:26,059 --> 00:25:34,850
we're assigning the regular expression

00:25:27,500 --> 00:25:37,640
to a variable first okay and here's an

00:25:34,850 --> 00:25:41,390
example using the triple equals you do

00:25:37,640 --> 00:25:44,240
reg ex triple equals string now the way

00:25:41,390 --> 00:25:46,880
operators are in Ruby is that most of

00:25:44,240 --> 00:25:49,130
them are function calls and so you can

00:25:46,880 --> 00:25:51,890
like C++ you can override these

00:25:49,130 --> 00:25:54,290
operators and of course that can be

00:25:51,890 --> 00:25:57,050
dangerous so you need to use them with

00:25:54,290 --> 00:25:59,600
care because of that if you would

00:25:57,050 --> 00:26:03,140
reverse the arguments and say peach

00:25:59,600 --> 00:26:05,090
triple equals regular expression care p

00:26:03,140 --> 00:26:10,340
you get a different result probably an

00:26:05,090 --> 00:26:13,280
error or maybe a false but anyway those

00:26:10,340 --> 00:26:15,890
operators are bound to the thing to the

00:26:13,280 --> 00:26:18,140
left of them so this would execute the

00:26:15,890 --> 00:26:22,400
triple equals function on the regular

00:26:18,140 --> 00:26:29,720
expression and so we have a true in a

00:26:22,400 --> 00:26:36,170
false example here we get the number or

00:26:29,720 --> 00:26:38,240
the nil for this operator here and here

00:26:36,170 --> 00:26:40,580
we have a case statement it's not really

00:26:38,240 --> 00:26:42,590
that interesting but we say case word

00:26:40,580 --> 00:26:44,360
and then it when you have a when

00:26:42,590 --> 00:26:46,820
expression it looks to see if the

00:26:44,360 --> 00:26:52,160
regular expression in the when matches

00:26:46,820 --> 00:26:55,790
the word and you have else's and that

00:26:52,160 --> 00:26:58,420
kind of thing and here's an example of

00:26:55,790 --> 00:26:58,420
using the

00:26:59,950 --> 00:27:08,780
jruby JRuby is really cool I mentioned

00:27:04,640 --> 00:27:11,330
some of the reasons that I like it it

00:27:08,780 --> 00:27:15,290
can be a better Java than Java and that

00:27:11,330 --> 00:27:21,170
for example you can run Java in your IRB

00:27:15,290 --> 00:27:23,390
shell using jruby and I'll show you an

00:27:21,170 --> 00:27:28,460
example of that later you can unit test

00:27:23,390 --> 00:27:31,280
Java code with JRuby one of my previous

00:27:28,460 --> 00:27:35,360
jobs that I was working with Java and I

00:27:31,280 --> 00:27:38,240
used Ruby to create a crude library to

00:27:35,360 --> 00:27:39,410
access the Oracle database and I knew

00:27:38,240 --> 00:27:40,850
that I didn't have a whole lot of

00:27:39,410 --> 00:27:44,420
objects so they would fit in memory and

00:27:40,850 --> 00:27:46,810
and so I could pull objects into a ruby

00:27:44,420 --> 00:27:49,670
array and manipulate them and then Duke

00:27:46,810 --> 00:27:51,560
do things that would just be too

00:27:49,670 --> 00:27:54,250
difficult to do with the sequel plus or

00:27:51,560 --> 00:27:56,780
you know the conventional Java JDBC

00:27:54,250 --> 00:27:58,700
thing it was just would have been really

00:27:56,780 --> 00:28:02,000
awkward so review is very helpful in

00:27:58,700 --> 00:28:04,340
that case jruby complete that jar is a

00:28:02,000 --> 00:28:05,900
single file that has JRuby itself plus

00:28:04,340 --> 00:28:08,900
some of the executables that go along

00:28:05,900 --> 00:28:13,040
with the Ruby environment Jam IRB rake

00:28:08,900 --> 00:28:14,510
our dock and our I and I haven't looked

00:28:13,040 --> 00:28:15,380
this up but i think they removed one or

00:28:14,510 --> 00:28:17,600
two of these from the most recent

00:28:15,380 --> 00:28:19,460
version but anyway what it means is that

00:28:17,600 --> 00:28:23,120
you can just copy that one file

00:28:19,460 --> 00:28:25,220
somewhere and then run those executables

00:28:23,120 --> 00:28:28,550
from the jar it's kind of a

00:28:25,220 --> 00:28:31,760
self-contained Ruby and in that sense

00:28:28,550 --> 00:28:34,610
it's much much easier to install than a

00:28:31,760 --> 00:28:41,630
regular Ruby as long as you have a JVM

00:28:34,610 --> 00:28:47,180
on your system java runtime so here's an

00:28:41,630 --> 00:28:50,090
example of using JRuby as a Java shell

00:28:47,180 --> 00:28:51,890
they look how one of the other benefits

00:28:50,090 --> 00:28:55,340
of using JRuby is that it has very good

00:28:51,890 --> 00:28:56,960
internationalization support so if if

00:28:55,340 --> 00:28:58,100
you want to do something that you're

00:28:56,960 --> 00:29:00,650
going to be distributing to other

00:28:58,100 --> 00:29:03,530
countries or you know or and/or other

00:29:00,650 --> 00:29:06,650
languages it's really good I mean it has

00:29:03,530 --> 00:29:08,830
a way to substitute different strings of

00:29:06,650 --> 00:29:10,690
course but it also has a lot of numeric

00:29:08,830 --> 00:29:14,320
formats date formats currency formats

00:29:10,690 --> 00:29:18,370
that kind of thing so this is a way to

00:29:14,320 --> 00:29:21,130
display each locale that the JVM

00:29:18,370 --> 00:29:29,500
supports and here's a way to print out

00:29:21,130 --> 00:29:32,890
the system properties so we mentioned

00:29:29,500 --> 00:29:35,190
shell scripting here's a what you could

00:29:32,890 --> 00:29:38,350
do on the UNIX command line using find

00:29:35,190 --> 00:29:41,470
Ruby lets you as in shell scripting put

00:29:38,350 --> 00:29:44,080
back tix around something and will

00:29:41,470 --> 00:29:46,210
return to you to stand it out that was

00:29:44,080 --> 00:29:47,769
produced by that command of course it

00:29:46,210 --> 00:29:49,960
will execute it but it also returned to

00:29:47,769 --> 00:29:52,320
you to stand it out and that can be

00:29:49,960 --> 00:29:57,010
really handy so here's the way you might

00:29:52,320 --> 00:30:01,240
delete all the unjust temp files in a

00:29:57,010 --> 00:30:03,750
directory tree you can do that but if

00:30:01,240 --> 00:30:05,500
you have any concern about portability

00:30:03,750 --> 00:30:10,059
especially if you have to support

00:30:05,500 --> 00:30:13,000
Windows systems you can do that at Ruby

00:30:10,059 --> 00:30:17,019
instead so ruby has a lot of functions

00:30:13,000 --> 00:30:20,679
that mimic the unix functions and Duroc

00:30:17,019 --> 00:30:28,330
lob will do directory and their various

00:30:20,679 --> 00:30:30,519
file functions likely you may have heard

00:30:28,330 --> 00:30:33,159
about meta programming using meta

00:30:30,519 --> 00:30:35,769
programming you can you can use Ruby to

00:30:33,159 --> 00:30:37,870
create other languages puppet I guess

00:30:35,769 --> 00:30:41,230
was written in Ruby is a domain-specific

00:30:37,870 --> 00:30:42,399
language that was written in Ruby and

00:30:41,230 --> 00:30:44,320
there are certain features that a

00:30:42,399 --> 00:30:46,450
language has to have medical meta

00:30:44,320 --> 00:30:51,490
programming capabilities in order to

00:30:46,450 --> 00:30:53,529
create such a DSL Ruby for example can

00:30:51,490 --> 00:31:00,250
create functions on the fly can create

00:30:53,529 --> 00:31:02,350
classes and well as you saw that

00:31:00,250 --> 00:31:05,889
attribute accessor creates functions for

00:31:02,350 --> 00:31:07,779
you the method missing that Ruby will

00:31:05,889 --> 00:31:09,850
let you catch a method missing exception

00:31:07,779 --> 00:31:11,559
and handle it where as with most

00:31:09,850 --> 00:31:13,360
languages if you call a method that

00:31:11,559 --> 00:31:15,490
doesn't exist on the object that you're

00:31:13,360 --> 00:31:18,970
calling it on it's just an error that's

00:31:15,490 --> 00:31:21,279
it you're done but with Ruby if your

00:31:18,970 --> 00:31:22,700
class contains a method missing function

00:31:21,279 --> 00:31:26,240
a function named method

00:31:22,700 --> 00:31:28,340
sing it gets two arguments it gets the

00:31:26,240 --> 00:31:29,630
function name that was called and then

00:31:28,340 --> 00:31:32,840
the list of arguments that were passed

00:31:29,630 --> 00:31:35,870
to it with that information you can do

00:31:32,840 --> 00:31:38,300
whatever you want you can just handle

00:31:35,870 --> 00:31:40,580
those things right there in other words

00:31:38,300 --> 00:31:42,950
you can just do the things that the user

00:31:40,580 --> 00:31:44,780
intended to do or you can define a

00:31:42,950 --> 00:31:47,600
function that does those things for the

00:31:44,780 --> 00:31:49,670
next time around and then call it or you

00:31:47,600 --> 00:31:52,280
can say well this doesn't make sense and

00:31:49,670 --> 00:31:54,770
raise an error so you have a lot of

00:31:52,280 --> 00:31:56,570
flexibility there and that in particular

00:31:54,770 --> 00:32:00,290
is something that makes Ruby very

00:31:56,570 --> 00:32:02,450
powerful rails is a domain-specific

00:32:00,290 --> 00:32:05,000
language for Ruby it makes heavy use of

00:32:02,450 --> 00:32:09,190
stuff like this active record which is a

00:32:05,000 --> 00:32:16,580
component of rails lets you access

00:32:09,190 --> 00:32:18,800
database record fields by name and rails

00:32:16,580 --> 00:32:20,480
active record will it'll find out what

00:32:18,800 --> 00:32:22,990
that really means in the context of that

00:32:20,480 --> 00:32:26,980
record and it'll do the right thing so

00:32:22,990 --> 00:32:30,020
this is a very powerful concept and

00:32:26,980 --> 00:32:33,890
there are other uses of that too like

00:32:30,020 --> 00:32:35,840
your XML builders where you can call a

00:32:33,890 --> 00:32:38,210
method you can have an XML builder

00:32:35,840 --> 00:32:39,460
object and then call a method on it

00:32:38,210 --> 00:32:43,340
which is really the element name and

00:32:39,460 --> 00:32:45,170
then underneath it'll method missing own

00:32:43,340 --> 00:32:47,120
cash as oh ok this is an element name

00:32:45,170 --> 00:32:50,750
i'm going to create an element of this

00:32:47,120 --> 00:32:52,340
name here and i'll do that for you now i

00:32:50,750 --> 00:32:55,130
want to show you something that um I

00:32:52,340 --> 00:32:59,360
guess I one more slide does that say Oh

00:32:55,130 --> 00:33:01,280
yet but it's not the end I have more I

00:32:59,360 --> 00:33:02,870
wanted to show you something that is

00:33:01,280 --> 00:33:05,780
really cool I think it's really cool

00:33:02,870 --> 00:33:13,760
anyway there is a gem for Ruby called

00:33:05,780 --> 00:33:20,570
Sinatra Sinatra is a minimal Sinatra is

00:33:13,760 --> 00:33:22,030
a very minimal web server web framework

00:33:20,570 --> 00:33:24,050
although is is tiny this tiny thing

00:33:22,030 --> 00:33:26,270
that's a program right there from

00:33:24,050 --> 00:33:28,370
require to end that is a program that

00:33:26,270 --> 00:33:31,310
you can access with your web browser and

00:33:28,370 --> 00:33:34,950
see hello world that's all you need to

00:33:31,310 --> 00:33:39,039
do and that is

00:33:34,950 --> 00:33:41,409
because it means that the cost of

00:33:39,039 --> 00:33:44,470
creating something that responds to a

00:33:41,409 --> 00:33:47,110
web client or or curl client or you know

00:33:44,470 --> 00:33:49,840
and a web services client it's so small

00:33:47,110 --> 00:33:52,480
that you can now do lots more stuff like

00:33:49,840 --> 00:33:55,480
that that was previously prohibitively

00:33:52,480 --> 00:34:03,460
expensive to do so just for kicks i put

00:33:55,480 --> 00:34:07,799
this this little thing together this is

00:34:03,460 --> 00:34:07,799
really small let me do another way

00:34:25,110 --> 00:34:30,270
well

00:34:26,820 --> 00:34:31,680
oh there we go okay well this is like

00:34:30,270 --> 00:34:35,780
the one that we saw on the screen but

00:34:31,680 --> 00:34:35,780
i'll show you another one that's better

00:34:46,190 --> 00:34:57,570
okay we'll forget about this okay can

00:34:53,790 --> 00:35:01,710
you see this yeah okay so this is a

00:34:57,570 --> 00:35:04,410
simple simple thing that is going to get

00:35:01,710 --> 00:35:06,660
us the users on a unix system and the

00:35:04,410 --> 00:35:08,490
uptime and if it's in java it's going to

00:35:06,660 --> 00:35:10,860
show us if if we're running JRuby it'll

00:35:08,490 --> 00:35:15,480
show us the languages that are supported

00:35:10,860 --> 00:35:25,130
by by the runtime so let's run it see

00:35:15,480 --> 00:35:29,460
what happens so first I'm going to see

00:35:25,130 --> 00:35:31,440
which Ruby I have it started let me talk

00:35:29,460 --> 00:35:35,370
about our vm a little bit if you decide

00:35:31,440 --> 00:35:37,050
that you would like to use Ruby and you

00:35:35,370 --> 00:35:39,200
would like to have some flexibility as

00:35:37,050 --> 00:35:42,180
to which Ruby distributions to use I

00:35:39,200 --> 00:35:45,720
highly recommend our vm it runs on any

00:35:42,180 --> 00:35:48,840
unix including Mac OS and Linux and all

00:35:45,720 --> 00:35:53,040
kinds of unities not on Windows rvm lets

00:35:48,840 --> 00:35:55,560
you easily install and manage many

00:35:53,040 --> 00:35:57,470
different distributions of Ruby as you

00:35:55,560 --> 00:36:00,240
can see here I have I have four of them

00:35:57,470 --> 00:36:03,810
re is the Ruby Enterprise Edition which

00:36:00,240 --> 00:36:09,330
is kind of a souped-up better supported

00:36:03,810 --> 00:36:11,100
Ruby 18 Ruby 192 is the latest or close

00:36:09,330 --> 00:36:14,010
to the latest Ruby that's out there and

00:36:11,100 --> 00:36:15,510
19 is significantly different from 18 so

00:36:14,010 --> 00:36:19,230
you have to think about which one you

00:36:15,510 --> 00:36:22,410
want to use jruby is the Ruby that runs

00:36:19,230 --> 00:36:24,630
on a jb m and then Ruby 18 is is the

00:36:22,410 --> 00:36:27,320
plain vanilla Ruby that sometimes you

00:36:24,630 --> 00:36:33,630
call it MRI Ruby a matzo ruby

00:36:27,320 --> 00:36:37,140
implementation I guess so using using

00:36:33,630 --> 00:36:41,630
our vm you can easily switch back and

00:36:37,140 --> 00:36:41,630
forth so if I were to say JRuby

00:36:41,930 --> 00:36:48,270
and then list them it would show me that

00:36:45,870 --> 00:36:50,850
I have switched now this might not seem

00:36:48,270 --> 00:36:55,430
that special to you but if you try doing

00:36:50,850 --> 00:36:58,650
this without rvm you'll be a big deal

00:36:55,430 --> 00:37:00,420
this does things like it'll change the

00:36:58,650 --> 00:37:03,500
value of your gem home to point to a

00:37:00,420 --> 00:37:06,180
different thing it creates a dot rvm

00:37:03,500 --> 00:37:07,320
directory in your home directory which

00:37:06,180 --> 00:37:09,930
contains all of these Ruby

00:37:07,320 --> 00:37:11,400
implementations the gems for all for

00:37:09,930 --> 00:37:14,360
each implementation and they're separate

00:37:11,400 --> 00:37:17,340
they have to be because many of them are

00:37:14,360 --> 00:37:20,070
natively compiled and forge a ruby that

00:37:17,340 --> 00:37:22,650
doesn't always work and vice versa so

00:37:20,070 --> 00:37:25,050
anyway our vm is good and it's it's

00:37:22,650 --> 00:37:27,540
pretty easy to install two very easy to

00:37:25,050 --> 00:37:30,110
work with so we were going to run that

00:37:27,540 --> 00:37:30,110
program

00:37:38,330 --> 00:37:43,310
I must be in JRuby here because it's

00:37:40,160 --> 00:37:50,530
taking a long time yeah is this here

00:37:43,310 --> 00:37:57,050
Java so let's point our browser here and

00:37:50,530 --> 00:38:00,410
let's try the users okay so we have a

00:37:57,050 --> 00:38:01,970
list of the users on on the server on

00:38:00,410 --> 00:38:05,000
the OS that the server is running on

00:38:01,970 --> 00:38:08,000
okay now let me show you the code that

00:38:05,000 --> 00:38:15,440
produced that because it's surprisingly

00:38:08,000 --> 00:38:27,440
small it's this one line let me see if I

00:38:15,440 --> 00:38:28,880
can make the text bigger for you so we

00:38:27,440 --> 00:38:33,410
just read from left to right and it's

00:38:28,880 --> 00:38:36,170
not so bad okay the file class has a

00:38:33,410 --> 00:38:37,880
method read lines which reads the

00:38:36,170 --> 00:38:40,940
contents of the file into an array of

00:38:37,880 --> 00:38:43,970
lines so each line is is one string

00:38:40,940 --> 00:38:46,490
element in an array and we're reading

00:38:43,970 --> 00:38:49,940
this file and then we're sorting it

00:38:46,490 --> 00:38:51,500
defaulting to alphabetically and then on

00:38:49,940 --> 00:38:54,070
the resulting array we're calling the

00:38:51,500 --> 00:38:57,070
map function remember what that does

00:38:54,070 --> 00:38:57,070
anybody

00:39:01,859 --> 00:39:08,230
yes it will produce a new array with the

00:39:05,740 --> 00:39:10,089
elements of the input array applying

00:39:08,230 --> 00:39:13,540
that block to the illness of the imperor

00:39:10,089 --> 00:39:17,079
e ok so what is it doing its splitting

00:39:13,540 --> 00:39:19,540
that line using the colon as a separator

00:39:17,079 --> 00:39:22,420
and then getting the first thing in the

00:39:19,540 --> 00:39:25,839
resulting array so in the etsy password

00:39:22,420 --> 00:39:28,839
you have named name colon and a bunch of

00:39:25,839 --> 00:39:31,510
other things so that's all you have to

00:39:28,839 --> 00:39:34,480
do an early to get the users a lot is it

00:39:31,510 --> 00:39:36,220
can be very dense but yet fairly

00:39:34,480 --> 00:39:40,390
readable once you get over that code

00:39:36,220 --> 00:39:43,359
block thing and then here we have that

00:39:40,390 --> 00:39:45,579
we've talked about the multi-line string

00:39:43,359 --> 00:39:47,650
literal this is the multilang string

00:39:45,579 --> 00:39:52,630
string literal and we just it's a

00:39:47,650 --> 00:39:55,170
template and we take that array of users

00:39:52,630 --> 00:40:01,420
and we join them with the HTML break and

00:39:55,170 --> 00:40:03,880
my brakes similarly we can just we could

00:40:01,420 --> 00:40:06,460
just run a unix command and using the

00:40:03,880 --> 00:40:15,910
back tix we get the standard out so if

00:40:06,460 --> 00:40:20,440
we test that out we will get what you

00:40:15,910 --> 00:40:23,770
would expect again now this doesn't seem

00:40:20,440 --> 00:40:26,230
like it's that big a deal but the reason

00:40:23,770 --> 00:40:27,940
that I think it's a big deal is that

00:40:26,230 --> 00:40:29,910
it's so easy to do that if you have a

00:40:27,940 --> 00:40:32,140
one-off thing that you need to do and

00:40:29,910 --> 00:40:33,940
you know some machine is doing something

00:40:32,140 --> 00:40:35,740
somewhere and because this is Ruby yeah

00:40:33,940 --> 00:40:37,660
but you have alternative flexibility you

00:40:35,740 --> 00:40:40,810
can you can test for certain conditions

00:40:37,660 --> 00:40:43,300
and email out so do this net of course

00:40:40,810 --> 00:40:44,440
you know if you have a serious thing

00:40:43,300 --> 00:40:45,250
that's repeated many times you would

00:40:44,440 --> 00:40:48,750
probably want to use something like

00:40:45,250 --> 00:40:52,859
puppet or something more you know but

00:40:48,750 --> 00:40:58,319
for one of things this is really handy

00:40:52,859 --> 00:40:58,319
so I'll show you then the language is 12

00:41:03,570 --> 00:41:13,210
okay so let's see what we had to do to

00:41:07,390 --> 00:41:15,370
get that when you program JRuby and you

00:41:13,210 --> 00:41:17,470
want to use something from Java you have

00:41:15,370 --> 00:41:21,580
to say required Java and then you have

00:41:17,470 --> 00:41:27,130
access to the Java libraries and classes

00:41:21,580 --> 00:41:29,650
so this is just saying on the java.util

00:41:27,130 --> 00:41:35,170
locale java class call the class method

00:41:29,650 --> 00:41:38,980
get available locales and convert it to

00:41:35,170 --> 00:41:40,810
an array don't remember why that was

00:41:38,980 --> 00:41:45,250
necessary I think oh because it returns

00:41:40,810 --> 00:41:46,750
a Java array not a ruby array and I had

00:41:45,250 --> 00:41:49,540
trouble calling the innumerable Zhaan a

00:41:46,750 --> 00:41:52,360
Java array so I just used to a to

00:41:49,540 --> 00:41:53,530
convert that to a ruby ray so once in a

00:41:52,360 --> 00:41:54,880
while you have these Java Ruby

00:41:53,530 --> 00:41:59,850
integration issues you have to figure

00:41:54,880 --> 00:42:02,020
out and then on that list of languages

00:41:59,850 --> 00:42:07,600
I'm sorry on that list of locales

00:42:02,020 --> 00:42:09,520
extract the languages and there are

00:42:07,600 --> 00:42:10,840
language codes the ISO codes for

00:42:09,520 --> 00:42:13,060
languages but they're also display

00:42:10,840 --> 00:42:15,070
languages display strings so we get the

00:42:13,060 --> 00:42:17,260
displaying language to display languages

00:42:15,070 --> 00:42:18,220
and we sort them and we call unique on

00:42:17,260 --> 00:42:24,370
them so you see you have a lot of

00:42:18,220 --> 00:42:27,550
unix-like things that you can use in in

00:42:24,370 --> 00:42:30,100
Ruby and in fact mots probably he I

00:42:27,550 --> 00:42:32,980
believe he's using linux as his main

00:42:30,100 --> 00:42:36,940
development language so he's very Linux

00:42:32,980 --> 00:42:38,710
friendly and in Ruby the the last

00:42:36,940 --> 00:42:41,650
expression in a function is the thing

00:42:38,710 --> 00:42:46,360
that gets returned so you won't see any

00:42:41,650 --> 00:42:48,550
explicit return key words unless it's a

00:42:46,360 --> 00:42:52,270
Java programmer who wrote it then you

00:42:48,550 --> 00:42:53,920
might see it of course you may see it if

00:42:52,270 --> 00:42:56,200
it's further up in the function if it's

00:42:53,920 --> 00:42:58,090
you know but yeah generally if you see a

00:42:56,200 --> 00:43:01,180
return statement you know you saw a

00:42:58,090 --> 00:43:03,430
programmer with it so this is the last

00:43:01,180 --> 00:43:06,100
expression in the function and this is

00:43:03,430 --> 00:43:07,810
what has been returned we're just taking

00:43:06,100 --> 00:43:13,460
the array of languages and joining them

00:43:07,810 --> 00:43:28,770
with the HTML break any questions

00:43:13,460 --> 00:43:30,780
yeah it includes it it's not really

00:43:28,770 --> 00:43:34,200
including any particular packages it's

00:43:30,780 --> 00:43:35,880
including the Java integration so once

00:43:34,200 --> 00:43:37,980
you do the required Java you can get to

00:43:35,880 --> 00:43:47,130
anything that's available through your

00:43:37,980 --> 00:43:49,079
jvm yeah a block is kind of a it's like

00:43:47,130 --> 00:43:50,970
a function except it's not named it's

00:43:49,079 --> 00:43:56,190
not a function object it's kind of a

00:43:50,970 --> 00:43:58,410
little different gems thanks for

00:43:56,190 --> 00:44:02,570
mentioning that that's important gems

00:43:58,410 --> 00:44:06,089
are basically libraries of Ruby code

00:44:02,570 --> 00:44:09,150
like jar files and java or perl has

00:44:06,089 --> 00:44:11,430
Sipan where you can get stuff right it's

00:44:09,150 --> 00:44:14,099
that that's really what a gem is if you

00:44:11,430 --> 00:44:17,160
have code that you think will be usable

00:44:14,099 --> 00:44:19,500
in other applications more than one

00:44:17,160 --> 00:44:21,810
application then it's a good idea to put

00:44:19,500 --> 00:44:24,569
it in a gym and in a gym you can specify

00:44:21,810 --> 00:44:27,060
dependencies on other libraries you can

00:44:24,569 --> 00:44:30,540
specify j'en versions that is dependent

00:44:27,060 --> 00:44:33,839
on and it makes it very easy to to pass

00:44:30,540 --> 00:44:37,579
around to other people and in the Ruby

00:44:33,839 --> 00:44:42,089
world people use github an awful lot and

00:44:37,579 --> 00:44:44,310
there's just well there's get out

00:44:42,089 --> 00:44:48,530
there's ruby gem I'm sorry Ruby Forge

00:44:44,310 --> 00:44:51,089
which is a kind of a dispenser of gems

00:44:48,530 --> 00:44:52,740
but there's just a lot of support for

00:44:51,089 --> 00:44:56,910
for gems in it it's a good way to

00:44:52,740 --> 00:44:58,200
package your code it doesn't have

00:44:56,910 --> 00:45:00,900
anything to do with any particular kind

00:44:58,200 --> 00:45:05,750
of code it's any code at all rails is

00:45:00,900 --> 00:45:05,750
packaged in the form of gems for example

00:45:06,740 --> 00:45:14,520
any other questions anybody want to try

00:45:10,710 --> 00:45:16,760
something Brian you look like you're up

00:45:14,520 --> 00:45:16,760
for adventure

00:45:23,480 --> 00:45:30,840
let's see well is there anything you'd

00:45:28,080 --> 00:45:36,270
like to try an IRB because IRB is really

00:45:30,840 --> 00:45:39,060
cool oh look at that oh because I'm

00:45:36,270 --> 00:45:44,970
already an IRB yes IRB is that is the

00:45:39,060 --> 00:45:47,130
Ruby interactive shell and if you are

00:45:44,970 --> 00:45:51,240
studying Ruby it's a good idea to use it

00:45:47,130 --> 00:45:53,280
a lot because you can if you can well

00:45:51,240 --> 00:45:56,460
your question down to a single code

00:45:53,280 --> 00:45:58,890
fragment or a liner to a code it's so so

00:45:56,460 --> 00:46:01,890
easy to do it in IRB as opposed to

00:45:58,890 --> 00:46:04,440
writing something and running it so like

00:46:01,890 --> 00:46:06,570
for example I i recently had a question

00:46:04,440 --> 00:46:09,240
well how would I extract the dot XML

00:46:06,570 --> 00:46:11,940
from the end of a file spec like what's

00:46:09,240 --> 00:46:13,380
the exact syntax because I often you

00:46:11,940 --> 00:46:18,240
know have off by one error so for

00:46:13,380 --> 00:46:32,210
example we can do that and then would it

00:46:18,240 --> 00:46:32,210
be this or would it be that any guesses

00:46:34,970 --> 00:46:45,570
whoa oh you know why because i forgot

00:46:37,740 --> 00:46:47,250
the minus sign there so i mean just go

00:46:45,570 --> 00:46:48,630
an IRB to get information like that as

00:46:47,250 --> 00:46:50,940
opposed to trying to run your program

00:46:48,630 --> 00:46:54,990
with it either way is a really good idea

00:46:50,940 --> 00:46:56,640
and it's one reason why Ruby programming

00:46:54,990 --> 00:46:58,170
is just a lot more productive than

00:46:56,640 --> 00:46:59,730
programming in a line was like Java

00:46:58,170 --> 00:47:05,580
because it's just the ceremony and

00:46:59,730 --> 00:47:07,770
overhead of job and it's just crazy but

00:47:05,580 --> 00:47:10,770
if you have to use Java you should user

00:47:07,770 --> 00:47:15,300
be too so i'll show you how if i were to

00:47:10,770 --> 00:47:16,770
change to jruby and then I run IRB and

00:47:15,300 --> 00:47:24,720
you see that it takes longer start-up

00:47:16,770 --> 00:47:30,380
because JVM takes a while so it's an

00:47:24,720 --> 00:47:33,750
import java.util locale

00:47:30,380 --> 00:47:37,020
okay and let's get the locales that are

00:47:33,750 --> 00:47:42,810
available I think I don't need to

00:47:37,020 --> 00:47:46,110
specify the java.util and JRuby will

00:47:42,810 --> 00:47:50,490
convert the camel case java functions to

00:47:46,110 --> 00:47:54,720
snake case for you so in Java it's this

00:47:50,490 --> 00:47:59,150
and you can call it that way if you want

00:47:54,720 --> 00:47:59,150
to but you can also call it like this

00:48:01,550 --> 00:48:07,050
because Ruby developers are very fond of

00:48:04,080 --> 00:48:09,660
snake case and don't like to do it any

00:48:07,050 --> 00:48:13,590
other way so now we have a list of

00:48:09,660 --> 00:48:15,150
locales and when you're here you like

00:48:13,590 --> 00:48:17,490
let's say you have this library that you

00:48:15,150 --> 00:48:18,990
java library you have to learn about you

00:48:17,490 --> 00:48:23,240
know there are objects you can call you

00:48:18,990 --> 00:48:27,240
can get a list of stuff by the way this

00:48:23,240 --> 00:48:31,320
you'll notice is not a ruby array if I

00:48:27,240 --> 00:48:37,530
do this I can do I get that but if I do

00:48:31,320 --> 00:48:39,930
this Oh what do you know this is an

00:48:37,530 --> 00:48:44,760
interesting point JRuby is migrating

00:48:39,930 --> 00:48:46,410
slowly but surely to ruby 1.9 and it's

00:48:44,760 --> 00:48:51,830
been kind of difficult they have to work

00:48:46,410 --> 00:48:53,880
really hard to support java and so I

00:48:51,830 --> 00:48:56,070
forgive what the replacement for that is

00:48:53,880 --> 00:48:59,970
because I'm always using 1.8 but anyway

00:48:56,070 --> 00:49:04,980
I guess it worked and so here you could

00:48:59,970 --> 00:49:08,520
say map and the way this this notation

00:49:04,980 --> 00:49:11,370
works and this was hard for me at first

00:49:08,520 --> 00:49:12,780
to get through is the curly brace

00:49:11,370 --> 00:49:15,150
defines the beginning of a code block

00:49:12,780 --> 00:49:16,800
and what's in those vertical bars is

00:49:15,150 --> 00:49:18,470
nothing more than the naming of the

00:49:16,800 --> 00:49:21,990
parameters that the code block gets

00:49:18,470 --> 00:49:23,700
you're just saying the thing that you're

00:49:21,990 --> 00:49:29,330
going to get caught locale that's its

00:49:23,700 --> 00:49:33,110
name okay so let's get the display

00:49:29,330 --> 00:49:33,110
language codes

00:49:57,530 --> 00:50:03,120
I think it's just that I don't remember

00:50:00,210 --> 00:50:13,800
the locale function name so i think i

00:50:03,120 --> 00:50:17,250
have it to him here oh i forgot to start

00:50:13,800 --> 00:50:20,640
my internet going anyway let's forget

00:50:17,250 --> 00:50:22,560
about that but yeah it says undefined

00:50:20,640 --> 00:50:26,550
method get' language so you know

00:50:22,560 --> 00:50:32,880
somewhere there's a there's a function

00:50:26,550 --> 00:50:34,530
of their of the number of functions you

00:50:32,880 --> 00:50:35,970
can call on the locale class just pretty

00:50:34,530 --> 00:50:43,140
cool ice to do internationalization and

00:50:35,970 --> 00:50:48,170
it was kind of interesting so yes good

00:50:43,140 --> 00:50:51,810
okay so give me a class named locale oh

00:50:48,170 --> 00:50:56,160
yeah good thinking I like the way he

00:50:51,810 --> 00:51:02,030
things let's see if we can do it on a

00:50:56,160 --> 00:51:07,950
Java actually would be instance methods

00:51:02,030 --> 00:51:13,500
and I like to sort them hmm if you were

00:51:07,950 --> 00:51:16,770
to do this oh wait a minute I mean that

00:51:13,500 --> 00:51:20,550
? thing sometimes when you when you're

00:51:16,770 --> 00:51:22,590
working with IRB it gets into a kind of

00:51:20,550 --> 00:51:33,710
pushes onto a stack kind of thing let's

00:51:22,590 --> 00:51:33,710
try it again require a Java do I need

00:51:38,099 --> 00:51:41,239
ok and

00:51:45,100 --> 00:51:59,320
aha good Megan so get displayname

00:51:54,810 --> 00:52:01,660
language oh I guess get country to get

00:51:59,320 --> 00:52:03,930
the code you just say get the thing like

00:52:01,660 --> 00:52:08,650
country or language that was my mistake

00:52:03,930 --> 00:52:12,220
so if I were to say locales equals

00:52:08,650 --> 00:52:15,190
locale dot and the dot operator is for

00:52:12,220 --> 00:52:17,860
functions but it uses the c++ double

00:52:15,190 --> 00:52:19,210
colon for variables if their class

00:52:17,860 --> 00:52:23,970
variables as opposed to instance

00:52:19,210 --> 00:52:33,820
variables so let's get available locales

00:52:23,970 --> 00:52:39,360
and then Oh kalsi countries are let's

00:52:33,820 --> 00:52:39,360
say country codes equals locales dot map

00:52:40,260 --> 00:52:51,940
locale locale that get country and we'll

00:52:45,580 --> 00:52:58,060
use the release snake case here we go so

00:52:51,940 --> 00:53:00,040
we get country codes there and was a

00:52:58,060 --> 00:53:03,100
country name I forget yeah I'm not going

00:53:00,040 --> 00:53:07,770
to do that but I guess it would be

00:53:03,100 --> 00:53:07,770
languages to same thing

00:53:19,940 --> 00:53:30,680
yeah so now remember too that we're in

00:53:28,360 --> 00:53:32,300
we're an IRB and that's why you see

00:53:30,680 --> 00:53:35,540
these values printed here because it's

00:53:32,300 --> 00:53:37,900
printing the evaluation of the

00:53:35,540 --> 00:53:40,250
expression that we've typed hear

00:53:37,900 --> 00:53:45,320
something that's surprising to beginners

00:53:40,250 --> 00:53:47,990
as if I do puts hello it puts hello but

00:53:45,320 --> 00:53:49,970
then it says nil and Anil is like well

00:53:47,990 --> 00:53:53,420
what's new well puts returns nil which

00:53:49,970 --> 00:54:01,940
is a function that returns nil so that's

00:53:53,420 --> 00:54:10,850
what ya in IRB probably but I don't know

00:54:01,940 --> 00:54:17,510
what it is well you know what I do in a

00:54:10,850 --> 00:54:19,580
case like that this is what I do it

00:54:17,510 --> 00:54:21,620
works the semi colon operator and Ruby

00:54:19,580 --> 00:54:25,130
will let you execute another command on

00:54:21,620 --> 00:54:27,740
the same line and that can be handy

00:54:25,130 --> 00:54:30,380
sometimes sometimes if something's

00:54:27,740 --> 00:54:32,480
really really minimal I'll do it online

00:54:30,380 --> 00:54:39,830
a set of multiple lines but that's you

00:54:32,480 --> 00:54:43,070
know usually to be avoided okay are

00:54:39,830 --> 00:54:45,370
there any questions I think you like to

00:54:43,070 --> 00:54:45,370
see

00:54:51,000 --> 00:54:55,799
can you be more specific scale how

00:55:09,079 --> 00:55:17,369
yeah yeah that's a good point Ruby like

00:55:14,780 --> 00:55:20,700
Java and so many languages is not really

00:55:17,369 --> 00:55:22,980
very good for concurrent processing as

00:55:20,700 --> 00:55:28,130
our languages like Haskell and her lying

00:55:22,980 --> 00:55:31,230
and closure Ruby 18 supports threads

00:55:28,130 --> 00:55:33,390
Ruby 19 has improved they have what they

00:55:31,230 --> 00:55:35,569
call fibers i believe which are better

00:55:33,390 --> 00:55:40,099
but i don't really know the details I

00:55:35,569 --> 00:55:42,960
like for that kind of job using JRuby

00:55:40,099 --> 00:55:46,200
because using JRuby you have access to

00:55:42,960 --> 00:55:48,119
Java threads and the JVM has been tuned

00:55:46,200 --> 00:55:49,619
and optimized to death you know I mean

00:55:48,119 --> 00:55:53,160
they've been working on that thing for

00:55:49,619 --> 00:55:56,609
years and so you have access to Java

00:55:53,160 --> 00:56:00,569
threads you have access to profiling

00:55:56,609 --> 00:56:03,540
tools there's a tool called J visualvm

00:56:00,569 --> 00:56:06,660
that comes with Java distributions where

00:56:03,540 --> 00:56:09,060
you can just want it and watch a program

00:56:06,660 --> 00:56:11,670
and you can see the threads and you know

00:56:09,060 --> 00:56:13,530
you can get a lot of runtime information

00:56:11,670 --> 00:56:14,819
about it and it's free it comes of the

00:56:13,530 --> 00:56:16,680
program so if you're doing anything

00:56:14,819 --> 00:56:18,180
that's multi-threaded and you're having

00:56:16,680 --> 00:56:19,410
any kind of situation even if you're

00:56:18,180 --> 00:56:21,210
doing something written brooby that's

00:56:19,410 --> 00:56:22,980
multi-threaded and you're having some

00:56:21,210 --> 00:56:25,619
Freddy problems it might be worthwhile

00:56:22,980 --> 00:56:27,990
to run it in JRuby and observe it with j

00:56:25,619 --> 00:56:29,190
visual vm to see what because it'll show

00:56:27,990 --> 00:56:30,630
you if the threads are stopped if

00:56:29,190 --> 00:56:33,420
they're running if they're waiting you

00:56:30,630 --> 00:56:35,480
know that kind of thing it's it's really

00:56:33,420 --> 00:56:37,680
handy i mean g ruby is kind of like a

00:56:35,480 --> 00:56:40,319
forgotten child of the Ruby world you

00:56:37,680 --> 00:56:41,849
know a lot of because Ruby the Ruby

00:56:40,319 --> 00:56:44,880
culture has this anti enterprise

00:56:41,849 --> 00:56:47,670
orientation you know they and so they

00:56:44,880 --> 00:56:48,960
kind of look down on Java but I have a

00:56:47,670 --> 00:56:50,910
huge amount of respect for the

00:56:48,960 --> 00:56:53,369
developers of JRuby they're working

00:56:50,910 --> 00:56:58,890
really brilliant and they're doing a

00:56:53,369 --> 00:57:00,300
great job and and although obviously as

00:56:58,890 --> 00:57:02,099
you've heard me say it you know I

00:57:00,300 --> 00:57:05,010
despise the Java language as a language

00:57:02,099 --> 00:57:07,380
I have a lot of respect for the JVM and

00:57:05,010 --> 00:57:09,510
I think it's a great platform because I

00:57:07,380 --> 00:57:12,270
really value portability you know i use

00:57:09,510 --> 00:57:14,819
linux a lot i use mac OS a lot I don't

00:57:12,270 --> 00:57:17,790
use windows unless I really really have

00:57:14,819 --> 00:57:19,829
to but Java gives you that I mean Ruby

00:57:17,790 --> 00:57:21,640
gives you that too but Java gives you

00:57:19,829 --> 00:57:24,979
that too and

00:57:21,640 --> 00:57:28,190
and a lot of the problems of heavy-duty

00:57:24,979 --> 00:57:29,660
computing have been really the lot of

00:57:28,190 --> 00:57:32,089
time and energy and money about into

00:57:29,660 --> 00:57:38,420
them in the Java world so using jruby

00:57:32,089 --> 00:57:41,829
you can exploit that anything else well

00:57:38,420 --> 00:57:41,829
thanks for coming I appreciate your time

00:57:59,610 --> 00:58:03,780
what about this I can help you like it

00:58:01,920 --> 00:58:07,790
we have the same problem what would

00:58:03,780 --> 00:58:07,790
happen to do you think the iphone

00:58:09,660 --> 00:58:14,270
let's put the word out

00:58:12,210 --> 00:58:14,270
you

00:59:21,989 --> 00:59:28,749
as a service leader in cloud computing

00:59:25,239 --> 00:59:30,309
all we do is hosting computing to us the

00:59:28,749 --> 00:59:32,289
cloud is just the next generation of

00:59:30,309 --> 00:59:34,239
hosting and if someone who's been in the

00:59:32,289 --> 00:59:36,189
hosting industry for 12 years we feel

00:59:34,239 --> 00:59:37,359
we're in a unique position to really

00:59:36,189 --> 00:59:39,489
help bring these two worlds together

00:59:37,359 --> 00:59:41,799
these different sets of technologies and

00:59:39,489 --> 00:59:44,140
to help companies embrace this new world

00:59:41,799 --> 00:59:46,150
in this great new tool that allows

00:59:44,140 --> 00:59:48,699
faster innovation not only is it about

00:59:46,150 --> 00:59:53,769
us being responsive and accountable but

00:59:48,699 --> 00:59:56,499
it's about us doing more for you whether

00:59:53,769 --> 01:00:00,519
less an OS that works the way that you

00:59:56,499 --> 01:00:04,319
do across all your devices HP Slate and

01:00:00,519 --> 01:00:04,319

YouTube URL: https://www.youtube.com/watch?v=QV0CtSHf6Yo


