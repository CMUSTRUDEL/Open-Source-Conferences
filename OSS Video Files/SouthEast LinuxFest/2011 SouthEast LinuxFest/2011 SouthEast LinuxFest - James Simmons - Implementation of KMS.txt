Title: 2011 SouthEast LinuxFest - James Simmons - Implementation of KMS
Publication date: 2012-03-12
Playlist: 2011 SouthEast LinuxFest
Description: 
	2011 SouthEast LinuxFest - James Simmons - Implementation of KMS and GEM/TTM

This video is licensed under Creative Commons Attribution 3.0 Unported License.
Captions: 
	00:00:01,159 --> 00:00:07,319
the following presentation was recorded

00:00:04,230 --> 00:00:09,900
at the 2011 southeast linux fest in

00:00:07,319 --> 00:00:11,400
Spartanburg South Carolina it is

00:00:09,900 --> 00:00:14,219
licensed under a creative commons

00:00:11,400 --> 00:00:18,779
license for more information about the

00:00:14,219 --> 00:00:22,199
southeast linux fest visit wwcc linux

00:00:18,779 --> 00:00:24,060
fest org the southeast linux fest would

00:00:22,199 --> 00:01:14,150
like to thank the following diamond and

00:00:24,060 --> 00:01:25,890
platinum sponsors in here to talk about

00:01:14,150 --> 00:01:27,659
hey ms can you hear me okay all right

00:01:25,890 --> 00:01:29,880
thank you for coming to this talk today

00:01:27,659 --> 00:01:31,740
one of the things that's going on in the

00:01:29,880 --> 00:01:34,259
last couple years in links development

00:01:31,740 --> 00:01:36,090
is this new API layer as we all know

00:01:34,259 --> 00:01:37,680
that the frame buffer layer was

00:01:36,090 --> 00:01:39,270
developed a few years ago but it had

00:01:37,680 --> 00:01:41,670
some shortcomings so a whole new layer

00:01:39,270 --> 00:01:44,850
was developed to do memory management

00:01:41,670 --> 00:01:47,729
and handle modern architecture of video

00:01:44,850 --> 00:01:49,950
of graphics hardware the thing is

00:01:47,729 --> 00:01:51,720
there's no documentation or anything

00:01:49,950 --> 00:01:54,020
like that and there are very few drivers

00:01:51,720 --> 00:01:56,939
that exist that show you how to do it

00:01:54,020 --> 00:02:00,149
basically the radeon and the nvidia

00:01:56,939 --> 00:02:02,549
chipset there is actually another anna

00:02:00,149 --> 00:02:04,049
as well as the intel chipset well

00:02:02,549 --> 00:02:06,570
there's a fourth chipset that's in the

00:02:04,049 --> 00:02:08,959
market that's very common in the asian

00:02:06,570 --> 00:02:11,970
markets and that's the vi a chipset and

00:02:08,959 --> 00:02:13,300
so the problem is in there it's lagging

00:02:11,970 --> 00:02:16,180
the development

00:02:13,300 --> 00:02:17,530
about in about january i got a

00:02:16,180 --> 00:02:19,780
motherboard they actually had this

00:02:17,530 --> 00:02:22,510
chipset and when i set it up i was doing

00:02:19,780 --> 00:02:24,460
it for other types of development it

00:02:22,510 --> 00:02:27,250
didn't work so at this point i decided

00:02:24,460 --> 00:02:29,290
to actually make it work and this is the

00:02:27,250 --> 00:02:31,900
experiences I had at this and I'm giving

00:02:29,290 --> 00:02:33,880
this talk so that other people who are

00:02:31,900 --> 00:02:36,130
looking at the right now the embedded

00:02:33,880 --> 00:02:39,550
market is looking to poor things like Oh

00:02:36,130 --> 00:02:41,590
map and other drivers to this layer but

00:02:39,550 --> 00:02:43,930
there's a lot of mystery about how it

00:02:41,590 --> 00:02:45,730
actually works and what it does so this

00:02:43,930 --> 00:02:48,760
is my experiences with the open Chrome

00:02:45,730 --> 00:02:50,710
project on this okay we all know the

00:02:48,760 --> 00:02:53,050
history of the Linux stack it's it was

00:02:50,710 --> 00:02:57,940
start when Linux first started out it

00:02:53,050 --> 00:03:00,900
was a basically an x86 I 386 system and

00:02:57,940 --> 00:03:03,160
it used vga text console mold only and

00:03:00,900 --> 00:03:06,250
the graphic stack was basically the

00:03:03,160 --> 00:03:10,240
xfree86 drivers which were all user mode

00:03:06,250 --> 00:03:12,790
space-based well and that dry and the

00:03:10,240 --> 00:03:16,090
xorg free was designed such they could

00:03:12,790 --> 00:03:18,610
operate on many operating systems also

00:03:16,090 --> 00:03:21,459
around the early days the Mesa stack was

00:03:18,610 --> 00:03:23,290
also started by Brian Paul now at this

00:03:21,459 --> 00:03:24,880
time they were all separate projects and

00:03:23,290 --> 00:03:27,550
this was in the days when you could

00:03:24,880 --> 00:03:29,860
bring up your Linux system and it would

00:03:27,550 --> 00:03:31,660
work fine and the xorg systems if you

00:03:29,860 --> 00:03:35,890
didn't tune it right it would take out

00:03:31,660 --> 00:03:38,590
your system well by the mid 90s the

00:03:35,890 --> 00:03:40,720
first ports to Linux tune on intel

00:03:38,590 --> 00:03:43,750
platform started to happen and what we

00:03:40,720 --> 00:03:45,400
begin to see is that the vga this text

00:03:43,750 --> 00:03:48,160
hardware mode doesn't exist on these

00:03:45,400 --> 00:03:50,580
other platforms so what they realized

00:03:48,160 --> 00:03:52,780
that they had they were pixel based

00:03:50,580 --> 00:03:54,850
systems so they realized they had to

00:03:52,780 --> 00:03:56,620
create console systems for this and out

00:03:54,850 --> 00:03:59,410
of this came the frame buffer council

00:03:56,620 --> 00:04:02,440
layer to handle it was the m68k s and

00:03:59,410 --> 00:04:04,330
the doc alpha ceph first came out but at

00:04:02,440 --> 00:04:07,150
this even though with this development

00:04:04,330 --> 00:04:10,440
the xfree86 org driver still existed and

00:04:07,150 --> 00:04:13,180
didn't use it too much later well in

00:04:10,440 --> 00:04:15,970
1999 i got involved with this actually

00:04:13,180 --> 00:04:18,459
this work because as i said it none of

00:04:15,970 --> 00:04:21,310
it were i had issues with getting things

00:04:18,459 --> 00:04:24,039
like the ex 386 driver working my system

00:04:21,310 --> 00:04:25,660
and so and it lacked the performance at

00:04:24,039 --> 00:04:26,550
that time and a lot of support for a lot

00:04:25,660 --> 00:04:29,290
of hardware

00:04:26,550 --> 00:04:30,880
so I started working on that and I got

00:04:29,290 --> 00:04:34,240
involved in the frame buffer API layer

00:04:30,880 --> 00:04:37,300
and discovered that because it was so

00:04:34,240 --> 00:04:39,670
text-based console a lot of the systems

00:04:37,300 --> 00:04:41,980
were intertwined and it made development

00:04:39,670 --> 00:04:45,490
driver writing extremely difficult and

00:04:41,980 --> 00:04:48,580
because of the difficulty often very few

00:04:45,490 --> 00:04:50,500
drivers were written so I set out to

00:04:48,580 --> 00:04:53,920
rewrite the API to make it extremely

00:04:50,500 --> 00:04:56,260
simple to write it and so that's what

00:04:53,920 --> 00:04:58,600
happened there and that became it became

00:04:56,260 --> 00:05:00,520
separated out at the same time another

00:04:58,600 --> 00:05:02,610
solution was developed called dri which

00:05:00,520 --> 00:05:05,230
was aimed at handling the 3d engines

00:05:02,610 --> 00:05:06,940
which didn't want to deal with any of

00:05:05,230 --> 00:05:11,980
the most fitting stuff to make the

00:05:06,940 --> 00:05:14,830
xfree86 org drivers more portable well

00:05:11,980 --> 00:05:16,390
as time moved on about 2000 and so in

00:05:14,830 --> 00:05:19,090
the industry we began to see the

00:05:16,390 --> 00:05:22,030
embedded system and we began to see

00:05:19,090 --> 00:05:23,920
changes in the embedded system that also

00:05:22,030 --> 00:05:27,880
started to leak over into laptops we've

00:05:23,920 --> 00:05:30,640
seen the development of DVI also of hdmi

00:05:27,880 --> 00:05:32,650
and other AP is coming from the consumer

00:05:30,640 --> 00:05:35,710
electronics world to the laptop and the

00:05:32,650 --> 00:05:38,230
desktop systems because of this changes

00:05:35,710 --> 00:05:40,300
a lot of the standard models of what we

00:05:38,230 --> 00:05:44,440
had in the the frame buffer layer was

00:05:40,300 --> 00:05:48,040
has become deprecated so we headed a new

00:05:44,440 --> 00:05:51,520
api's had to be developed the old model

00:05:48,040 --> 00:05:54,820
was one analog CRT display you had your

00:05:51,520 --> 00:05:57,010
video RAM on the bus and in those days I

00:05:54,820 --> 00:05:59,920
if your old timer you'll remember there

00:05:57,010 --> 00:06:01,780
were 64 K of Windows that you had a flip

00:05:59,920 --> 00:06:05,770
with the memory to do the super vga

00:06:01,780 --> 00:06:08,620
modes and then you had the FIFO or the

00:06:05,770 --> 00:06:10,330
DMA to move it over the bus today we

00:06:08,620 --> 00:06:12,250
have many display outputs you can do

00:06:10,330 --> 00:06:16,180
simultaneously you can clone the

00:06:12,250 --> 00:06:18,010
displays also the system memory at one

00:06:16,180 --> 00:06:20,350
time the embedded platform developers

00:06:18,010 --> 00:06:22,240
realize that video memory is expensive

00:06:20,350 --> 00:06:24,850
so they realized that they wanted to

00:06:22,240 --> 00:06:27,580
take memory from the system and actually

00:06:24,850 --> 00:06:30,370
used it so the old idea of dedicated

00:06:27,580 --> 00:06:34,900
video RAM on the bus began to break down

00:06:30,370 --> 00:06:37,419
and then and also to it but to address

00:06:34,900 --> 00:06:39,630
that system memory they developed a

00:06:37,419 --> 00:06:41,850
system called graphics addressing

00:06:39,630 --> 00:06:44,820
mapping table I don't know if any of you

00:06:41,850 --> 00:06:47,220
have ever worked with types of NAND

00:06:44,820 --> 00:06:49,830
cards or flash drives it has a similar

00:06:47,220 --> 00:06:51,510
idea of mapping so you know where things

00:06:49,830 --> 00:06:54,960
are on the system as they move around

00:06:51,510 --> 00:06:56,730
and as time also moved on you began to

00:06:54,960 --> 00:06:58,350
see more graphics pipes where you could

00:06:56,730 --> 00:07:00,890
pipeline graphics commands into the

00:06:58,350 --> 00:07:03,750
system executing several at a time

00:07:00,890 --> 00:07:05,400
hot-plug support if your monitor fell

00:07:03,750 --> 00:07:08,010
out in the old days you never got it

00:07:05,400 --> 00:07:09,540
back today it can detect if it's in

00:07:08,010 --> 00:07:12,420
there and you plug in a new monitor it

00:07:09,540 --> 00:07:15,030
can adapt to it you get and one of the

00:07:12,420 --> 00:07:18,330
biggest developments today is the the

00:07:15,030 --> 00:07:20,250
use of shaders for people who are

00:07:18,330 --> 00:07:22,200
familiar with it today they began to

00:07:20,250 --> 00:07:25,590
realize the Kate they took the idea of

00:07:22,200 --> 00:07:27,690
jitters from Java which was precompiled

00:07:25,590 --> 00:07:30,870
bike code and that you could inject it

00:07:27,690 --> 00:07:32,520
into these GPU units and render things

00:07:30,870 --> 00:07:34,980
and they found this to be much more

00:07:32,520 --> 00:07:39,420
flexible than the old style of phila

00:07:34,980 --> 00:07:43,650
rectangle copyin area so shader

00:07:39,420 --> 00:07:47,130
technology is also came into okay so

00:07:43,650 --> 00:07:50,850
this is the basic driver core for the

00:07:47,130 --> 00:07:52,890
drm layer it's wrapped around like all

00:07:50,850 --> 00:07:57,180
Linux drivers it uses the PCI driver

00:07:52,890 --> 00:08:00,180
which you have your PC ID tables to tell

00:07:57,180 --> 00:08:02,100
you what the devices are and of course

00:08:00,180 --> 00:08:05,190
you named your driver so it shows up in

00:08:02,100 --> 00:08:07,350
sis FS sense things like that this is

00:08:05,190 --> 00:08:09,720
pretty these are pretty standard things

00:08:07,350 --> 00:08:13,470
that you will always do for writing a

00:08:09,720 --> 00:08:15,750
core driver with minimum features KMS

00:08:13,470 --> 00:08:19,620
also provides a probe and remove

00:08:15,750 --> 00:08:21,180
function for this in the old days the

00:08:19,620 --> 00:08:24,240
reason for this was because the frame

00:08:21,180 --> 00:08:26,580
buffer layer existed and the dr i layer

00:08:24,240 --> 00:08:29,670
existed at the same time but only one

00:08:26,580 --> 00:08:33,090
device structure PCI driver can be

00:08:29,670 --> 00:08:36,180
mapped to a device a driver structure at

00:08:33,090 --> 00:08:40,560
a time so because of this the dr layer

00:08:36,180 --> 00:08:43,289
did not really register the device but

00:08:40,560 --> 00:08:45,030
that now that now that has changed with

00:08:43,289 --> 00:08:47,460
the emulation of the frame buffer layer

00:08:45,030 --> 00:08:50,610
in the dri layer you can actually

00:08:47,460 --> 00:08:51,930
register it with the PCI layer and these

00:08:50,610 --> 00:08:56,540
are the commands that you

00:08:51,930 --> 00:08:59,370
do it with DRM PCI in it and exit and

00:08:56,540 --> 00:09:01,050
you get the there are actually parent

00:08:59,370 --> 00:09:04,410
functions on the embedded platform as

00:09:01,050 --> 00:09:08,910
well crm platform in it and drm platform

00:09:04,410 --> 00:09:12,149
exit the core structure once you have

00:09:08,910 --> 00:09:14,610
your regular pci driver up the core

00:09:12,149 --> 00:09:18,630
structure is the struct drm driver and

00:09:14,610 --> 00:09:21,380
this is where it sets up for the things

00:09:18,630 --> 00:09:25,380
the handle to open the device on the DRI

00:09:21,380 --> 00:09:27,149
you have things like you have hooks in

00:09:25,380 --> 00:09:29,279
there for the load and the unloading

00:09:27,149 --> 00:09:31,890
which brings the driver up and takes it

00:09:29,279 --> 00:09:34,620
down you have the fill ops for the

00:09:31,890 --> 00:09:37,050
memory maps for the clothes and the

00:09:34,620 --> 00:09:42,270
opening of the DRI if you look in / dev

00:09:37,050 --> 00:09:44,580
you'll see a dr i0 file you also have

00:09:42,270 --> 00:09:46,770
other hooks in there for things like

00:09:44,580 --> 00:09:49,470
first open last close these were things

00:09:46,770 --> 00:09:51,930
were if for example if the let if your

00:09:49,470 --> 00:09:56,610
ex server toppled over it would clean up

00:09:51,930 --> 00:09:58,589
after itself you also have an important

00:09:56,610 --> 00:10:01,050
thing called the driver features and

00:09:58,589 --> 00:10:03,990
that's your flags does it support DMA

00:10:01,050 --> 00:10:05,760
does it support mode setting and those

00:10:03,990 --> 00:10:08,190
things will tell you you will use those

00:10:05,760 --> 00:10:10,890
features and throughout the driver to

00:10:08,190 --> 00:10:14,550
know what to do and I example the open

00:10:10,890 --> 00:10:17,520
chrome project we did a we did we are

00:10:14,550 --> 00:10:19,290
supporting both KMS and non KMS at the

00:10:17,520 --> 00:10:22,050
same time so that way we don't smash the

00:10:19,290 --> 00:10:24,360
xorg drivers which are accessing the

00:10:22,050 --> 00:10:28,020
registers and doing the mode setting and

00:10:24,360 --> 00:10:31,529
user land still there are also i octo

00:10:28,020 --> 00:10:34,529
hooks that's for if you want to do your

00:10:31,529 --> 00:10:39,089
own whatever commands you want to do

00:10:34,529 --> 00:10:41,220
some drivers do blitz some do the most

00:10:39,089 --> 00:10:44,550
common use in our cases to do memory

00:10:41,220 --> 00:10:46,500
allocation we also do video blanking

00:10:44,550 --> 00:10:48,810
handling that's for the case the same

00:10:46,500 --> 00:10:52,680
for synchronization they will send you

00:10:48,810 --> 00:10:54,899
an event when when the the tracer

00:10:52,680 --> 00:10:58,410
reaches the end and of course we have

00:10:54,899 --> 00:11:00,600
irq handling and for to handle things

00:10:58,410 --> 00:11:04,380
like when the DNA engine is completed

00:11:00,600 --> 00:11:05,730
its task and other things such as hot

00:11:04,380 --> 00:11:09,870
plug is often handled by

00:11:05,730 --> 00:11:11,310
irq now in graphics and graphics

00:11:09,870 --> 00:11:13,500
hardware there are two problems that

00:11:11,310 --> 00:11:16,860
have to be solved one is the memory

00:11:13,500 --> 00:11:18,899
management and the other is is dealing

00:11:16,860 --> 00:11:22,139
with the mode setting itself setting up

00:11:18,899 --> 00:11:23,910
display so in the system as you can see

00:11:22,139 --> 00:11:26,279
in the in your regular system you have

00:11:23,910 --> 00:11:28,860
your CPU and you have your cash and your

00:11:26,279 --> 00:11:32,120
main memory and you has you you have

00:11:28,860 --> 00:11:34,320
your IO am em you and your i/o bus

00:11:32,120 --> 00:11:36,449
usually in a video card that has

00:11:34,320 --> 00:11:40,560
dedicated likes a video memory it's on

00:11:36,449 --> 00:11:43,500
the i/o bus and for your modern systems

00:11:40,560 --> 00:11:45,360
you have your main memory but as I was

00:11:43,500 --> 00:11:46,649
saying before you can have hardware

00:11:45,360 --> 00:11:49,740
systems which use some of the main

00:11:46,649 --> 00:11:52,290
memory as if it was the video memory so

00:11:49,740 --> 00:11:54,570
that's where the iommu comes from it

00:11:52,290 --> 00:11:56,820
maps that in fact that's where that GART

00:11:54,570 --> 00:11:59,160
that I discussed earlier for the mapping

00:11:56,820 --> 00:12:01,410
that's its job is to point those two

00:11:59,160 --> 00:12:03,959
together so that way you don't have the

00:12:01,410 --> 00:12:06,680
penalty of going to quit so it becomes

00:12:03,959 --> 00:12:10,440
visible to the card for in its bus space

00:12:06,680 --> 00:12:13,260
now on x86 the bus address space and the

00:12:10,440 --> 00:12:15,180
main space is actually equal but that's

00:12:13,260 --> 00:12:17,250
not usually that is not true on other

00:12:15,180 --> 00:12:20,339
platforms anyone who's ever worked with

00:12:17,250 --> 00:12:25,860
a mips or an arm would really they've

00:12:20,339 --> 00:12:28,110
come across this issue and as i was

00:12:25,860 --> 00:12:31,639
saying earlier in the some of the early

00:12:28,110 --> 00:12:34,260
embedded systems and laptops such as the

00:12:31,639 --> 00:12:39,329
system main memory instead of any video

00:12:34,260 --> 00:12:42,000
ram that's devoted and remember those

00:12:39,329 --> 00:12:44,310
64k pages this is another reason why you

00:12:42,000 --> 00:12:47,880
need memory management well today the

00:12:44,310 --> 00:12:51,089
pcr bars only expose 256 megabytes of

00:12:47,880 --> 00:12:52,740
space to the system at any one time so

00:12:51,089 --> 00:12:55,110
you have to shuffle your memory around

00:12:52,740 --> 00:13:01,290
since modern video cards will have to

00:12:55,110 --> 00:13:02,940
eva 4 gigabytes of ram on them so in

00:13:01,290 --> 00:13:05,339
order to solve the memory management

00:13:02,940 --> 00:13:07,620
problem there was two solutions that

00:13:05,339 --> 00:13:12,890
ended up becoming they had to come to

00:13:07,620 --> 00:13:15,660
the forefront actually first was TTM and

00:13:12,890 --> 00:13:17,819
later Intel said that it was too

00:13:15,660 --> 00:13:19,560
complicated so they decided to make

00:13:17,819 --> 00:13:21,750
their own and they called it gem

00:13:19,560 --> 00:13:25,050
and they both have their strengths and

00:13:21,750 --> 00:13:27,870
their weaknesses for the open Chrome

00:13:25,050 --> 00:13:30,360
project we realized actually the best

00:13:27,870 --> 00:13:33,840
solution was to use both you can

00:13:30,360 --> 00:13:38,040
actually get quote Gemma Phi the TTM

00:13:33,840 --> 00:13:40,080
layer as you can see the pros of the gem

00:13:38,040 --> 00:13:43,620
layer is it's a pretty simple and

00:13:40,080 --> 00:13:45,839
minimum API it's designed to such that

00:13:43,620 --> 00:13:48,720
you can do what you want to do in this

00:13:45,839 --> 00:13:51,510
in a lot of ways without being bounded

00:13:48,720 --> 00:13:53,790
to very restrictions and the TTM layer

00:13:51,510 --> 00:13:57,839
is various restrict and what its

00:13:53,790 --> 00:13:59,070
requirements are yeah the other thing

00:13:57,839 --> 00:14:01,560
that's nice about the gym later is that

00:13:59,070 --> 00:14:04,890
you can actually make it swappable it

00:14:01,560 --> 00:14:08,000
has a Shem layer to it that you can back

00:14:04,890 --> 00:14:10,920
back all the devices so when you do a

00:14:08,000 --> 00:14:12,960
when you power down your system you can

00:14:10,920 --> 00:14:16,560
actually for hibernation it will

00:14:12,960 --> 00:14:19,770
actually save it to regular memory it

00:14:16,560 --> 00:14:22,290
actually I five my in my personal

00:14:19,770 --> 00:14:24,620
opinion gem actually works better for

00:14:22,290 --> 00:14:26,970
user land interfaces it has a better

00:14:24,620 --> 00:14:29,180
interface for that it has a hint a

00:14:26,970 --> 00:14:31,560
concept of a handle which is basically a

00:14:29,180 --> 00:14:33,990
like a file descriptor so you can

00:14:31,560 --> 00:14:39,420
perform operations on the gem device on

00:14:33,990 --> 00:14:42,390
the gem memory allocation and also Jam

00:14:39,420 --> 00:14:46,110
is designed to try to avoid mapping

00:14:42,390 --> 00:14:48,330
these buffers into users user space it

00:14:46,110 --> 00:14:51,000
uses read and write calls which is I

00:14:48,330 --> 00:14:53,520
found to be a somewhat of a drawback and

00:14:51,000 --> 00:14:56,490
then they have this concept of domains

00:14:53,520 --> 00:14:58,470
and relocations and the reason they have

00:14:56,490 --> 00:15:01,440
this domains is basically where do you

00:14:58,470 --> 00:15:04,350
want to grab your memory pool from this

00:15:01,440 --> 00:15:07,020
concept and this is this hat infects the

00:15:04,350 --> 00:15:09,060
way the caching is different on the

00:15:07,020 --> 00:15:12,540
video memory onboard versus the system

00:15:09,060 --> 00:15:14,670
memory so in domains you can specify if

00:15:12,540 --> 00:15:17,250
you want to grab it from the AGP memory

00:15:14,670 --> 00:15:19,560
or from the video or from the system it

00:15:17,250 --> 00:15:22,290
allows you control it also allows you to

00:15:19,560 --> 00:15:25,620
select try to grab from all three based

00:15:22,290 --> 00:15:28,080
on what the best criteria is there's

00:15:25,620 --> 00:15:30,140
also the concept of relocations which

00:15:28,080 --> 00:15:32,730
basically is moving your memory around

00:15:30,140 --> 00:15:35,850
depending on the situation consider

00:15:32,730 --> 00:15:37,709
you only have X amount of RAM and you

00:15:35,850 --> 00:15:39,779
start doing memory pressures for say

00:15:37,709 --> 00:15:41,279
texture maps some of it has to be

00:15:39,779 --> 00:15:45,600
swapped out and you're going to have to

00:15:41,279 --> 00:15:47,519
grab it from a different place so that's

00:15:45,600 --> 00:15:49,769
the gem API the other layers so that

00:15:47,519 --> 00:15:53,040
called the translation table Maps layer

00:15:49,769 --> 00:15:55,980
and as I said it's a much it's a more

00:15:53,040 --> 00:15:58,019
complicated API but it's a much it's a

00:15:55,980 --> 00:16:02,399
very powerful API that does a lot for

00:15:58,019 --> 00:16:04,529
you it has much one of the strengths is

00:16:02,399 --> 00:16:08,600
it's much finer grain lock jim has a

00:16:04,529 --> 00:16:12,120
tendency to lock on a higher level and

00:16:08,600 --> 00:16:15,329
the biggest benefit of the TTM layer is

00:16:12,120 --> 00:16:17,459
actually the concept of fences which I

00:16:15,329 --> 00:16:21,360
will go over with you offenses is a way

00:16:17,459 --> 00:16:26,990
to allow synchronization for memory to

00:16:21,360 --> 00:16:26,990
be moved around and things like that so

00:16:27,560 --> 00:16:33,630
I'm going to first go over the TTM layer

00:16:30,540 --> 00:16:35,550
the and how to set it up and to do it

00:16:33,630 --> 00:16:36,870
and build it so when you do your driver

00:16:35,550 --> 00:16:38,490
the first thing you want to do is you

00:16:36,870 --> 00:16:41,220
want to create this thing called a TT

00:16:38,490 --> 00:16:43,889
embo device it's it's the global view of

00:16:41,220 --> 00:16:45,810
your your physical device and it

00:16:43,889 --> 00:16:47,370
contains that it's basically a

00:16:45,810 --> 00:16:49,769
containment of all the address spaces

00:16:47,370 --> 00:16:53,459
you're going to have and use video RAM

00:16:49,769 --> 00:16:55,529
system ram etc it's also going to be an

00:16:53,459 --> 00:16:57,959
array of memory managers what you're

00:16:55,529 --> 00:17:01,649
going to find is this memory manager

00:16:57,959 --> 00:17:03,750
will represent what memory you have do

00:17:01,649 --> 00:17:06,630
you have video RAM do you have a GP

00:17:03,750 --> 00:17:10,020
memory that's allocated to the side do

00:17:06,630 --> 00:17:12,120
you have pcie scattered a term memory

00:17:10,020 --> 00:17:13,470
these things are set up in this

00:17:12,120 --> 00:17:18,419
structure and it tells you how much of

00:17:13,470 --> 00:17:20,250
it you have and other and it and how

00:17:18,419 --> 00:17:24,059
much you're using and a key it's a

00:17:20,250 --> 00:17:26,220
tracker of the system and the other

00:17:24,059 --> 00:17:29,220
importance inside that structure of

00:17:26,220 --> 00:17:31,980
course is your TT embo driver your TT

00:17:29,220 --> 00:17:34,580
embo driver is this the hooks for your

00:17:31,980 --> 00:17:38,400
personal device how to manage the memory

00:17:34,580 --> 00:17:41,460
the so that's the structure you have to

00:17:38,400 --> 00:17:43,650
have inside your code there you have you

00:17:41,460 --> 00:17:45,809
create one of these TT embo devices and

00:17:43,650 --> 00:17:46,530
you render stir it through the TTM Bo

00:17:45,809 --> 00:17:49,830
device

00:17:46,530 --> 00:17:52,830
init function and this will bring it up

00:17:49,830 --> 00:17:56,040
for you now one of the things you will

00:17:52,830 --> 00:17:58,110
notice is it does this complex coating

00:17:56,040 --> 00:18:01,800
that most drivers kind of duplicated in

00:17:58,110 --> 00:18:05,090
our project we created pretty generic

00:18:01,800 --> 00:18:08,790
code that can be shared by other drivers

00:18:05,090 --> 00:18:11,610
one of my goals is to genera size a lot

00:18:08,790 --> 00:18:13,050
of the codes so that way it's driver

00:18:11,610 --> 00:18:15,980
writers want to be able to bring a

00:18:13,050 --> 00:18:20,280
driver up pretty quickly in the industry

00:18:15,980 --> 00:18:22,590
now that dryer that bow driver contains

00:18:20,280 --> 00:18:25,770
a lot of structures for the memory

00:18:22,590 --> 00:18:28,770
management the firt one and it's broken

00:18:25,770 --> 00:18:31,740
in two different pieces the first one is

00:18:28,770 --> 00:18:34,130
the TTM back end this is the function

00:18:31,740 --> 00:18:37,590
that manages your your guard and

00:18:34,130 --> 00:18:43,170
transferring your memory to your system

00:18:37,590 --> 00:18:45,630
between areas it handles a excuse me one

00:18:43,170 --> 00:18:48,330
of the things for example like scatter

00:18:45,630 --> 00:18:50,910
gather it has a populate and a clear

00:18:48,330 --> 00:18:55,560
function so you can get you can allocate

00:18:50,910 --> 00:18:57,270
the scatter gather memory and for usage

00:18:55,560 --> 00:18:59,270
for the driver so that memory is set

00:18:57,270 --> 00:19:03,000
aside and allocated in a pool for you

00:18:59,270 --> 00:19:04,740
for optimization and then from there you

00:19:03,000 --> 00:19:06,390
can buy knit I'm buying because the

00:19:04,740 --> 00:19:08,130
thing is is you can allocate a huge pool

00:19:06,390 --> 00:19:09,570
but you're not going two most most

00:19:08,130 --> 00:19:10,890
buffers you're going to allocate you

00:19:09,570 --> 00:19:12,720
don't know how big they're going to be

00:19:10,890 --> 00:19:14,790
so the buying and I'm bind function

00:19:12,720 --> 00:19:17,130
allocates a segment in there and it

00:19:14,790 --> 00:19:18,930
binds the pages to them so it does the

00:19:17,130 --> 00:19:21,240
mapping from the space so when the video

00:19:18,930 --> 00:19:23,160
card looks at a texture that's been

00:19:21,240 --> 00:19:25,560
uploaded it can look at it in its own

00:19:23,160 --> 00:19:27,840
space and that's what the binding does

00:19:25,560 --> 00:19:29,760
where you can write it to the system

00:19:27,840 --> 00:19:31,800
memory and you can access the system

00:19:29,760 --> 00:19:34,230
memory and it thinks it's in system

00:19:31,800 --> 00:19:36,150
memory but the video card sees it is in

00:19:34,230 --> 00:19:41,250
video card memory when it's really not

00:19:36,150 --> 00:19:44,250
the we also have the mapping we also

00:19:41,250 --> 00:19:46,890
have the anit mem type and this is the

00:19:44,250 --> 00:19:51,990
mapping the behavior this of the bus

00:19:46,890 --> 00:19:55,500
space for a GP v ram it sets things such

00:19:51,990 --> 00:19:58,590
as the caching caching is different for

00:19:55,500 --> 00:20:01,780
these properties

00:19:58,590 --> 00:20:05,919
for example when you have vram and you

00:20:01,780 --> 00:20:08,320
memory map it to the system memory the

00:20:05,919 --> 00:20:11,080
problem is is if you're writing to say

00:20:08,320 --> 00:20:13,299
it's a DMA space sorry let me rephrase

00:20:11,080 --> 00:20:15,160
it if if team a space that doesn't mean

00:20:13,299 --> 00:20:16,480
because it's done independent say it's

00:20:15,160 --> 00:20:19,210
downloaded from the video cards of the

00:20:16,480 --> 00:20:20,950
DMA space the problem is it might not it

00:20:19,210 --> 00:20:23,650
probably will not be updated in the cash

00:20:20,950 --> 00:20:26,799
and the CPU so the memory will be out of

00:20:23,650 --> 00:20:28,600
sync of the CPU cache so we you have to

00:20:26,799 --> 00:20:30,280
be aware of this functionality and you

00:20:28,600 --> 00:20:32,980
have to do things such as invalidate the

00:20:30,280 --> 00:20:35,980
cash isn't that so this is handled by

00:20:32,980 --> 00:20:38,350
that and there's various flags for it to

00:20:35,980 --> 00:20:40,870
another thing is some on some systems

00:20:38,350 --> 00:20:43,090
such as the video cards that have

00:20:40,870 --> 00:20:45,400
devoted video ram that memory is

00:20:43,090 --> 00:20:47,980
actually located in a specific area can

00:20:45,400 --> 00:20:50,730
be fixed on some hardware that memory is

00:20:47,980 --> 00:20:53,860
actually relocatable so it moves around

00:20:50,730 --> 00:20:57,570
some DNA mappings can be created or

00:20:53,860 --> 00:21:01,900
destroyed at limb at various locations

00:20:57,570 --> 00:21:04,750
so so that's so that manages that that

00:21:01,900 --> 00:21:08,590
structure and then we have some

00:21:04,750 --> 00:21:11,770
functions in here that set this up the

00:21:08,590 --> 00:21:14,350
anit mem type is is the method in that

00:21:11,770 --> 00:21:17,620
in the bow driver that sets up all these

00:21:14,350 --> 00:21:19,270
flags of that if you look at the open

00:21:17,620 --> 00:21:21,910
chrome project or the radeon driver

00:21:19,270 --> 00:21:25,390
you'll see examples thats can be pretty

00:21:21,910 --> 00:21:28,570
made pretty generic actually I found

00:21:25,390 --> 00:21:32,890
it's mostly repetitive code the IO mem

00:21:28,570 --> 00:21:35,260
reserve and the IO mem unreserved those

00:21:32,890 --> 00:21:38,260
are functions I don't know how many are

00:21:35,260 --> 00:21:39,549
familiar with Colonel colonel

00:21:38,260 --> 00:21:42,910
programming but when you reserve a

00:21:39,549 --> 00:21:45,850
memory region you grab that region so no

00:21:42,910 --> 00:21:48,040
other driver can access it while you're

00:21:45,850 --> 00:21:49,780
using it and you can release it that

00:21:48,040 --> 00:21:52,540
function has to say it's actually a

00:21:49,780 --> 00:21:56,679
wrapper for that function around there

00:21:52,540 --> 00:22:00,549
and if that function takes this region

00:21:56,679 --> 00:22:03,250
the TTM mem region tells you what region

00:22:00,549 --> 00:22:05,290
you want in that space so you can do

00:22:03,250 --> 00:22:08,230
fine grain grabbing a certain X amount

00:22:05,290 --> 00:22:09,910
of its measured in pages you will find

00:22:08,230 --> 00:22:14,620
that you can grab

00:22:09,910 --> 00:22:17,530
a page 5 from the AGP space to the

00:22:14,620 --> 00:22:22,270
10,000 page you can do this with this

00:22:17,530 --> 00:22:24,870
this function also this this function

00:22:22,270 --> 00:22:28,180
also fills in in the TTM bus placement

00:22:24,870 --> 00:22:30,520
and that's all the bus information about

00:22:28,180 --> 00:22:33,670
where is the real memory from respective

00:22:30,520 --> 00:22:36,880
of the video card and from the system so

00:22:33,670 --> 00:22:39,010
it tells you stuff like that and then

00:22:36,880 --> 00:22:42,220
there's an another function that is

00:22:39,010 --> 00:22:45,150
pretty much I've never seen anybody

00:22:42,220 --> 00:22:47,980
really do is for a memory mapping it's

00:22:45,150 --> 00:22:49,930
usually it's just an empty function it's

00:22:47,980 --> 00:22:52,420
actually to test permission for when you

00:22:49,930 --> 00:22:54,850
do memory when you met map this to

00:22:52,420 --> 00:22:56,290
userspace these buffer objects it can

00:22:54,850 --> 00:22:58,990
tell you what / if you really have

00:22:56,290 --> 00:23:01,060
permission to access it it's a method to

00:22:58,990 --> 00:23:03,610
one of the goals is to be able to share

00:23:01,060 --> 00:23:06,280
buffers between applications right now

00:23:03,610 --> 00:23:07,960
buffered a lot I from what I've seen as

00:23:06,280 --> 00:23:11,770
most applications just allow their

00:23:07,960 --> 00:23:13,690
buffers to be shared everywhere yeah so

00:23:11,770 --> 00:23:18,160
when you set it up for every type of

00:23:13,690 --> 00:23:20,860
memory region for the bow device you're

00:23:18,160 --> 00:23:26,890
going to use this TTM bowed device in it

00:23:20,860 --> 00:23:30,250
in oops sorry yeah the the Bo driver has

00:23:26,890 --> 00:23:32,230
to be also registered separately as well

00:23:30,250 --> 00:23:34,740
it's very similar to the bow device

00:23:32,230 --> 00:23:37,260
there's just one of them for your driver

00:23:34,740 --> 00:23:40,180
it's kind of similar to like the PCI

00:23:37,260 --> 00:23:43,150
driver structure and how its registered

00:23:40,180 --> 00:23:44,710
and you can also release it when you're

00:23:43,150 --> 00:23:49,230
done with the device when you unload the

00:23:44,710 --> 00:23:52,090
module so those are only called once

00:23:49,230 --> 00:23:54,250
when the dry when the module is loaded

00:23:52,090 --> 00:23:57,370
and when it's released now the function

00:23:54,250 --> 00:24:00,550
that's called also at that time is the

00:23:57,370 --> 00:24:04,720
memory regions itself the TTM bow in it

00:24:00,550 --> 00:24:08,200
memory mmmm function and the TTM bo

00:24:04,720 --> 00:24:09,900
clean mmmm function those set up your

00:24:08,200 --> 00:24:12,760
memory regents it goes over each one

00:24:09,900 --> 00:24:15,520
such as your video RAM and sets up the

00:24:12,760 --> 00:24:19,630
parameters and what its be it sets it up

00:24:15,520 --> 00:24:22,920
for be used and initialize it so it's

00:24:19,630 --> 00:24:22,920
usable to the driver

00:24:23,260 --> 00:24:29,380
so those are the structures but now we

00:24:27,790 --> 00:24:31,990
have to actually look at how do we use

00:24:29,380 --> 00:24:34,210
these structures the way memory is

00:24:31,990 --> 00:24:36,550
handled is it it's pretty object

00:24:34,210 --> 00:24:38,920
orientated and the reason for this is if

00:24:36,550 --> 00:24:42,460
you le in the old days of the xorg

00:24:38,920 --> 00:24:44,500
drivers the you hadda allocate a chunk

00:24:42,460 --> 00:24:46,360
of video ram and then you had to know

00:24:44,500 --> 00:24:48,370
where the offset was and you allocated a

00:24:46,360 --> 00:24:51,580
chunk for the cursor and then you

00:24:48,370 --> 00:24:52,990
allocated a chunk for the DMA q you

00:24:51,580 --> 00:24:54,340
would do things like this and you had to

00:24:52,990 --> 00:24:56,260
move all these pointers around know

00:24:54,340 --> 00:24:58,330
where it is at any time and you had a

00:24:56,260 --> 00:25:01,450
you can basically do it all in the

00:24:58,330 --> 00:25:04,050
driver this is to be able to just

00:25:01,450 --> 00:25:06,460
allocate a chunk of memory and you it

00:25:04,050 --> 00:25:07,980
makes your life a lot easier not having

00:25:06,460 --> 00:25:10,150
to worry about where it's going to move

00:25:07,980 --> 00:25:14,170
it's just you have to be aware that the

00:25:10,150 --> 00:25:17,280
object can move on you do to memory

00:25:14,170 --> 00:25:19,930
pressures and other things like that so

00:25:17,280 --> 00:25:21,970
we have to be aware of that for the

00:25:19,930 --> 00:25:23,350
memory displacement now the first thing

00:25:21,970 --> 00:25:25,960
you'll notice is that when you do

00:25:23,350 --> 00:25:30,160
allocate a memory internally in the

00:25:25,960 --> 00:25:32,350
driver for a buffer allocation creation

00:25:30,160 --> 00:25:35,320
you'll notice that the first place is

00:25:32,350 --> 00:25:37,660
created as quote in system memory so

00:25:35,320 --> 00:25:40,090
when you actually go to use the driver

00:25:37,660 --> 00:25:41,200
it's going to displace the memory and

00:25:40,090 --> 00:25:44,500
it's going to move it to its proper

00:25:41,200 --> 00:25:46,560
location so in order to do this you have

00:25:44,500 --> 00:25:49,840
to have things like the fault reserved

00:25:46,560 --> 00:25:53,680
notification function that is a hook to

00:25:49,840 --> 00:25:55,990
when a page fall happens now usually

00:25:53,680 --> 00:25:57,520
that's a very basic function but I

00:25:55,990 --> 00:26:02,110
remember how saying that you had these

00:25:57,520 --> 00:26:04,150
PCI windows of 256 megs you actually use

00:26:02,110 --> 00:26:06,580
this function for when you are accessing

00:26:04,150 --> 00:26:09,280
the memory outside of that region and

00:26:06,580 --> 00:26:12,190
then you have to actually swap around

00:26:09,280 --> 00:26:15,010
the RAM the mapping so you can actually

00:26:12,190 --> 00:26:16,540
still use what as much as you can so you

00:26:15,010 --> 00:26:19,050
have to look over the table saying who's

00:26:16,540 --> 00:26:22,690
not using their memory swap it out and

00:26:19,050 --> 00:26:28,620
swap the one you want into the PCI bar

00:26:22,690 --> 00:26:28,620
space so

00:26:29,290 --> 00:26:35,090
so that's one of them and we also have a

00:26:31,910 --> 00:26:38,240
swap notify function so that's for the

00:26:35,090 --> 00:26:40,360
people for the people who want to write

00:26:38,240 --> 00:26:43,010
applications and have their texture maps

00:26:40,360 --> 00:26:44,300
usually in the old days you would break

00:26:43,010 --> 00:26:45,620
down the title you would free these

00:26:44,300 --> 00:26:48,320
buffers in that before you go into

00:26:45,620 --> 00:26:50,150
hibernation but now you can actually

00:26:48,320 --> 00:26:52,370
save them to swap so you don't have to

00:26:50,150 --> 00:26:55,430
regenerate these images and things like

00:26:52,370 --> 00:26:57,170
that so that's what the swap

00:26:55,430 --> 00:26:59,690
notification function is a hook though

00:26:57,170 --> 00:27:04,250
they'll let you know we're about to swap

00:26:59,690 --> 00:27:06,950
and then so that's the that's the

00:27:04,250 --> 00:27:09,890
problem for out of what causes memory

00:27:06,950 --> 00:27:11,510
displace displacement where doesn't what

00:27:09,890 --> 00:27:14,690
causes what can make it move to

00:27:11,510 --> 00:27:17,000
different places now there are functions

00:27:14,690 --> 00:27:18,830
to move the buffers around you can

00:27:17,000 --> 00:27:24,740
actually force the moving of the buffers

00:27:18,830 --> 00:27:28,310
too if you if you so desire usually it

00:27:24,740 --> 00:27:30,740
has to deal with tiling functions the

00:27:28,310 --> 00:27:34,250
move notify function is used to set up

00:27:30,740 --> 00:27:36,470
your tiling before a move happens it's a

00:27:34,250 --> 00:27:38,510
hook to that and the reason is tiling is

00:27:36,470 --> 00:27:41,120
a special way to format the data instead

00:27:38,510 --> 00:27:44,300
of a linear buffer a formats it so it

00:27:41,120 --> 00:27:46,340
minimizes the cache line mrs. to

00:27:44,300 --> 00:27:48,410
increase performance but in order to do

00:27:46,340 --> 00:27:51,830
that you have to arrange the memory such

00:27:48,410 --> 00:27:53,870
or sometimes even program the memory the

00:27:51,830 --> 00:27:57,680
register so that when it goes to memory

00:27:53,870 --> 00:27:59,870
it sees it as that tiling format the

00:27:57,680 --> 00:28:04,460
other thing is you have to deal with is

00:27:59,870 --> 00:28:07,970
evictions there are times when then Sid

00:28:04,460 --> 00:28:09,260
modern games and modern systems a lot of

00:28:07,970 --> 00:28:10,670
modern applications that are going to

00:28:09,260 --> 00:28:13,010
really push the limits on how much

00:28:10,670 --> 00:28:14,900
memory they're going to use so in that

00:28:13,010 --> 00:28:16,070
case the memory is going to be moved and

00:28:14,900 --> 00:28:18,350
you're going to have to deal with that

00:28:16,070 --> 00:28:19,940
and where are you going to place that so

00:28:18,350 --> 00:28:21,800
there might be times that your textures

00:28:19,940 --> 00:28:24,020
might be booted out of the video RAM

00:28:21,800 --> 00:28:26,000
where is it going to go next will it be

00:28:24,020 --> 00:28:29,840
put in a GPA will be put in system

00:28:26,000 --> 00:28:32,020
memory so those flags tell you what

00:28:29,840 --> 00:28:34,520
would you prefer because there's many

00:28:32,020 --> 00:28:36,580
options now it's not like the old days

00:28:34,520 --> 00:28:39,890
of just dumping it to your system memory

00:28:36,580 --> 00:28:41,789
so you have to so this way it allows you

00:28:39,890 --> 00:28:48,779
to control what is the best optimize

00:28:41,789 --> 00:28:51,409
station in fact we use you can use that

00:28:48,779 --> 00:28:54,690
for the best like for example to move

00:28:51,409 --> 00:28:57,239
memory from the system to the video RAM

00:28:54,690 --> 00:28:59,639
you often move it to the AGP space and

00:28:57,239 --> 00:29:01,019
then to the video RAM so these eviction

00:28:59,639 --> 00:29:05,190
flags can be set up such that it

00:29:01,019 --> 00:29:08,309
controls that flow the other function is

00:29:05,190 --> 00:29:10,859
the move function which is actually a

00:29:08,309 --> 00:29:14,639
very large function and it deals with

00:29:10,859 --> 00:29:16,590
this how to move the memory from the dma

00:29:14,639 --> 00:29:18,599
to system memory what if you're moving

00:29:16,590 --> 00:29:21,720
from system memory to system memory

00:29:18,599 --> 00:29:23,759
sometimes you do that so it controls and

00:29:21,720 --> 00:29:27,899
it allows you to do acceleration

00:29:23,759 --> 00:29:29,909
functions for that and of course after

00:29:27,899 --> 00:29:32,190
you're done moving the memory you want

00:29:29,909 --> 00:29:33,929
to do you want to invalidate the caches

00:29:32,190 --> 00:29:42,659
as I was saying you can become out of

00:29:33,929 --> 00:29:46,499
sync with the CPU cache ok this is the

00:29:42,659 --> 00:29:48,479
core object for this system this is what

00:29:46,499 --> 00:29:50,489
usually internally the driver is going

00:29:48,479 --> 00:29:53,789
to allocate one's a user requests a

00:29:50,489 --> 00:29:56,669
memory a memory buffer and it's called

00:29:53,789 --> 00:29:58,019
the TTM buffer object it could be

00:29:56,669 --> 00:30:01,799
possibly it can be shared with other

00:29:58,019 --> 00:30:04,470
applications it's created by the TTM bow

00:30:01,799 --> 00:30:06,090
and it function that's the function

00:30:04,470 --> 00:30:07,950
you'll call on your driver to do this

00:30:06,090 --> 00:30:11,190
usually you'll write an I octal function

00:30:07,950 --> 00:30:14,609
it comes in you specify parameters what

00:30:11,190 --> 00:30:16,889
size it is what tiling format do you

00:30:14,609 --> 00:30:20,309
want it you can even specify what

00:30:16,889 --> 00:30:23,669
domains this for example the intel

00:30:20,309 --> 00:30:27,899
driver does that it says do grab it from

00:30:23,669 --> 00:30:30,509
the AGP or from the video ram so so that

00:30:27,899 --> 00:30:33,179
you can specify that it comes into this

00:30:30,509 --> 00:30:34,529
function now the most important thing is

00:30:33,179 --> 00:30:38,249
this placement that I'm talking about

00:30:34,529 --> 00:30:41,940
where do you want it which memory pool

00:30:38,249 --> 00:30:43,590
to get it from some put and the way it's

00:30:41,940 --> 00:30:45,720
written actually there's a structure

00:30:43,590 --> 00:30:48,509
that you define is called the TTM

00:30:45,720 --> 00:30:50,009
placement buff structure and this

00:30:48,509 --> 00:30:52,710
structure actually allows multiple

00:30:50,009 --> 00:30:54,299
placements so and the reason for this is

00:30:52,710 --> 00:30:55,440
because some buffers might be actually

00:30:54,299 --> 00:30:56,820
busy

00:30:55,440 --> 00:30:59,159
so you might not be able to use that

00:30:56,820 --> 00:31:01,620
buffer right there so you use the next

00:30:59,159 --> 00:31:04,289
best thing it might be under memory

00:31:01,620 --> 00:31:05,639
pressure say you prefer the AGP space

00:31:04,289 --> 00:31:07,200
but there's so many textures you don't

00:31:05,639 --> 00:31:08,669
have memory so you need to have a

00:31:07,200 --> 00:31:12,899
fallback because you don't want to just

00:31:08,669 --> 00:31:16,289
fail on the user so in that case you you

00:31:12,899 --> 00:31:18,690
would have these other busy these other

00:31:16,289 --> 00:31:22,190
flags there's an array of flags in it

00:31:18,690 --> 00:31:25,799
that you can tell which one to use next

00:31:22,190 --> 00:31:28,559
you can also another feature it has is

00:31:25,799 --> 00:31:31,169
the ability to select where in that pool

00:31:28,559 --> 00:31:33,570
you can do that normally you don't set

00:31:31,169 --> 00:31:36,539
the which page to do the first you can

00:31:33,570 --> 00:31:38,129
specify the first and last page normally

00:31:36,539 --> 00:31:40,620
you don't specify them it will pick

00:31:38,129 --> 00:31:42,899
wherever it feels is best suited but you

00:31:40,620 --> 00:31:44,639
can actually fine grain it now if you do

00:31:42,899 --> 00:31:47,190
that you have to be careful you lose the

00:31:44,639 --> 00:31:49,049
ability to do multiple pools to pick

00:31:47,190 --> 00:31:53,129
from because you might send a range

00:31:49,049 --> 00:31:55,200
that's outside of that pool and it also

00:31:53,129 --> 00:31:57,509
handles another issue which is very

00:31:55,200 --> 00:32:01,559
critical and that's alignment handling a

00:31:57,509 --> 00:32:04,980
lot of hardware is set up for example on

00:32:01,559 --> 00:32:08,100
our our open chrome on the VA hardware

00:32:04,980 --> 00:32:11,009
you have to do 16-bit alignment for data

00:32:08,100 --> 00:32:13,710
transfer there's no way around that if

00:32:11,009 --> 00:32:15,629
you don't the hardware gets confused so

00:32:13,710 --> 00:32:17,730
you have to deal with alignment issues

00:32:15,629 --> 00:32:19,379
where do you put the inside the page

00:32:17,730 --> 00:32:23,460
where do you line to write the data

00:32:19,379 --> 00:32:25,080
where do you start and of course the

00:32:23,460 --> 00:32:28,740
other thing that you specify when you

00:32:25,080 --> 00:32:31,110
allocate is of course the size there are

00:32:28,740 --> 00:32:33,210
actually two structures two variables

00:32:31,110 --> 00:32:36,600
for the size you have normal size which

00:32:33,210 --> 00:32:39,960
is your your regular size and then you

00:32:36,600 --> 00:32:41,580
have your acc sighs and that size is

00:32:39,960 --> 00:32:44,610
actually to grab it from the system heap

00:32:41,580 --> 00:32:46,580
your normal system memory and the reason

00:32:44,610 --> 00:32:50,370
for that is it's actually useful for

00:32:46,580 --> 00:32:52,799
example if a user land wants to set up

00:32:50,370 --> 00:32:55,320
in the kernel system you want to do it

00:32:52,799 --> 00:32:57,269
get get users pages it transfers the

00:32:55,320 --> 00:32:59,669
memory from user land to the kernel

00:32:57,269 --> 00:33:01,649
space so it can be used and this can

00:32:59,669 --> 00:33:06,929
actually that is actually used for that

00:33:01,649 --> 00:33:09,059
to allocate that heap also who's going

00:33:06,929 --> 00:33:14,490
to use this you have

00:33:09,059 --> 00:33:17,970
TTM bow types that disc that is

00:33:14,490 --> 00:33:20,340
basically in the TTM layer you can the

00:33:17,970 --> 00:33:22,409
user can allocate a buffer but so can

00:33:20,340 --> 00:33:26,309
the internal kernel driver allocate the

00:33:22,409 --> 00:33:28,080
buffer also the buffer can be allocated

00:33:26,309 --> 00:33:30,809
inside the kernel driver but can be

00:33:28,080 --> 00:33:32,789
mapped to user space but the reverse is

00:33:30,809 --> 00:33:35,999
also true the user can allocate memory

00:33:32,789 --> 00:33:38,279
and then say I want to use this to

00:33:35,999 --> 00:33:40,620
transfer memory to the to the graphics

00:33:38,279 --> 00:33:44,309
card or to be used in some way so you

00:33:40,620 --> 00:33:47,100
can also actually do that as well the

00:33:44,309 --> 00:33:49,440
other but of course in all in doing all

00:33:47,100 --> 00:33:53,249
this and transferring memory around you

00:33:49,440 --> 00:33:55,159
have the issues of interrupt ability do

00:33:53,249 --> 00:33:57,629
you want to wait it might be busy the

00:33:55,159 --> 00:34:01,799
graphics card the DMA engine might be

00:33:57,629 --> 00:34:04,110
busy so or is it interrupted can this

00:34:01,799 --> 00:34:06,509
actually can you when you do finally

00:34:04,110 --> 00:34:08,520
send it up do you want to cut it off can

00:34:06,509 --> 00:34:10,440
it be interrupted or does it have to

00:34:08,520 --> 00:34:13,409
stall the engine until it's completed

00:34:10,440 --> 00:34:17,310
some hardware can't handle data being

00:34:13,409 --> 00:34:19,589
sent up and then it stops and of course

00:34:17,310 --> 00:34:21,929
if you're using a gem back-end you have

00:34:19,589 --> 00:34:25,859
your swap space which can actually be

00:34:21,929 --> 00:34:28,950
passed to the TTM layer as it so it

00:34:25,859 --> 00:34:32,669
allows it to be interoperable okay and

00:34:28,950 --> 00:34:35,490
our you will find that there are a lot

00:34:32,669 --> 00:34:39,030
of pointer structures with the TTM

00:34:35,490 --> 00:34:42,030
placement that most drivers do these

00:34:39,030 --> 00:34:45,000
fancy allocation I realize that actually

00:34:42,030 --> 00:34:46,800
extremely complicated and you can do

00:34:45,000 --> 00:34:49,460
lots of memory leaks so and are in the

00:34:46,800 --> 00:34:52,829
open chrome project we developed a

00:34:49,460 --> 00:34:55,290
function that will allocate the memory

00:34:52,829 --> 00:34:57,569
and keep track of it for you for the

00:34:55,290 --> 00:35:00,990
placements so you don't have to worry

00:34:57,569 --> 00:35:05,490
about string raise of integers there

00:35:00,990 --> 00:35:07,410
defines flags so now that we've created

00:35:05,490 --> 00:35:12,000
it the next thing to do is we have to

00:35:07,410 --> 00:35:13,980
deal with its actual usage like a object

00:35:12,000 --> 00:35:16,740
since its shared between Apple you can

00:35:13,980 --> 00:35:18,599
be shared between applications and even

00:35:16,740 --> 00:35:20,040
in the future they want to be able to

00:35:18,599 --> 00:35:22,109
share this memory actually with

00:35:20,040 --> 00:35:24,989
different devices this is one

00:35:22,109 --> 00:35:27,359
goals the project so but in order to do

00:35:24,989 --> 00:35:30,839
that of course we have to be able to

00:35:27,359 --> 00:35:33,390
reserve it so we have a reserved and

00:35:30,839 --> 00:35:36,420
unreserved function so basically it's a

00:35:33,390 --> 00:35:38,730
locking mechanism to make sure and of

00:35:36,420 --> 00:35:40,499
course that locking mechanism there's a

00:35:38,730 --> 00:35:45,660
lot of different behaviors that can be

00:35:40,499 --> 00:35:47,849
defined you can see for example if you

00:35:45,660 --> 00:35:50,190
grab it can you sleep on that function

00:35:47,849 --> 00:35:52,289
sometimes if you're writing and the

00:35:50,190 --> 00:35:54,960
scheduler goes out do you want to be

00:35:52,289 --> 00:35:57,109
able to sleep and if it is sleeping do

00:35:54,960 --> 00:36:00,720
you want to be able to wake it up again

00:35:57,109 --> 00:36:04,759
do you want to interrupt able so and

00:36:00,720 --> 00:36:07,200
also do you want to do a no wait state

00:36:04,759 --> 00:36:09,450
sometimes you want to be able to just

00:36:07,200 --> 00:36:12,869
keep waiting on to the dma engine is

00:36:09,450 --> 00:36:15,150
ready or some other suit and then if it

00:36:12,869 --> 00:36:16,559
is it ready you cut you can return so

00:36:15,150 --> 00:36:19,980
you can actually specify either to

00:36:16,559 --> 00:36:23,489
return or just to keep waiting and we

00:36:19,980 --> 00:36:25,920
also have the sequence now the first

00:36:23,489 --> 00:36:28,559
time you look at that you what's the

00:36:25,920 --> 00:36:30,989
sequence well sequences actually I don't

00:36:28,559 --> 00:36:33,630
know you probably are familiar with the

00:36:30,989 --> 00:36:35,789
nice command it gives you some some

00:36:33,630 --> 00:36:37,650
applications the preference over others

00:36:35,789 --> 00:36:40,680
well you can actually do the same thing

00:36:37,650 --> 00:36:42,869
here you can actually tell in the usage

00:36:40,680 --> 00:36:45,660
where do you want the reserve if it's

00:36:42,869 --> 00:36:49,069
backlogged who gets first prior you can

00:36:45,660 --> 00:36:52,829
control to some degree the priority so

00:36:49,069 --> 00:36:56,430
now you now after you've set up your

00:36:52,829 --> 00:36:57,749
memory and you've reserved it now that

00:36:56,430 --> 00:36:59,730
another issue you're going to come with

00:36:57,749 --> 00:37:02,400
is sometimes you want to change the

00:36:59,730 --> 00:37:06,720
placement behavior as well and that's

00:37:02,400 --> 00:37:10,349
the TTM bo validate function this is for

00:37:06,720 --> 00:37:12,599
to move the data around it also deals

00:37:10,349 --> 00:37:15,029
also with thee you can also change the

00:37:12,599 --> 00:37:16,890
state to waiting and to interrupt

00:37:15,029 --> 00:37:19,410
ability so you can kind of think of the

00:37:16,890 --> 00:37:23,069
bow validate is a way to alter the

00:37:19,410 --> 00:37:26,279
behavior of the buffer object you can

00:37:23,069 --> 00:37:30,390
actually see examples of that in the set

00:37:26,279 --> 00:37:32,730
base for example um I if you do video

00:37:30,390 --> 00:37:34,950
pana you grab a chunk of my video memory

00:37:32,730 --> 00:37:35,759
and you tell the video card this is the

00:37:34,950 --> 00:37:37,439
start of the memory

00:37:35,759 --> 00:37:40,529
and you'll see that you can actually

00:37:37,439 --> 00:37:42,239
move it along so this we actually using

00:37:40,529 --> 00:37:45,449
the bow validate and that function to

00:37:42,239 --> 00:37:51,359
say oh it's scrolling here it is at this

00:37:45,449 --> 00:37:55,229
point now and another function is also

00:37:51,359 --> 00:37:56,759
to make it non evict able as I was

00:37:55,229 --> 00:38:00,209
saying before you can have things go out

00:37:56,759 --> 00:38:02,329
to swap there are times when you do not

00:38:00,209 --> 00:38:05,189
want your stuff to go out to swap that

00:38:02,329 --> 00:38:07,439
would be extremely bad if for example

00:38:05,189 --> 00:38:09,029
your video memory you don't want to go

00:38:07,439 --> 00:38:11,369
out to swap that's being displayed on

00:38:09,029 --> 00:38:13,499
your console under memory pressure

00:38:11,369 --> 00:38:17,130
otherwise your screen would disappear

00:38:13,499 --> 00:38:19,079
and you would scratch your head okay now

00:38:17,130 --> 00:38:21,809
one of the nother nice functions that we

00:38:19,079 --> 00:38:25,049
have internally in the driver is the

00:38:21,809 --> 00:38:28,349
k-map and k on map function this allows

00:38:25,049 --> 00:38:30,689
you to IO remap the memory area that you

00:38:28,349 --> 00:38:34,109
want to use this is all internal for the

00:38:30,689 --> 00:38:37,709
colonel examples of this actually I made

00:38:34,109 --> 00:38:41,369
it so that the the mem the mi the mm I

00:38:37,709 --> 00:38:43,619
Oh was actually mappable and I mapped it

00:38:41,369 --> 00:38:46,769
so I could use it internally and I use

00:38:43,619 --> 00:38:49,229
the TTM layer to do that you will find

00:38:46,769 --> 00:38:51,269
also for the frame buffer emulations you

00:38:49,229 --> 00:38:54,089
will need to use this function to memory

00:38:51,269 --> 00:39:00,719
map so you the frame buffer council can

00:38:54,089 --> 00:39:08,179
write to it now that's the TTM layer do

00:39:00,719 --> 00:39:08,179
you have any questions yes

00:39:13,630 --> 00:39:21,049
yes there's a TTM boat underscore bow

00:39:18,470 --> 00:39:23,930
underscore type underscore user and

00:39:21,049 --> 00:39:29,809
there's actually a function in TTM

00:39:23,930 --> 00:39:32,329
underscore t TT m dot C that does this

00:39:29,809 --> 00:39:34,520
for you actually no one is actually

00:39:32,329 --> 00:39:37,130
trying to use it and recently I try to

00:39:34,520 --> 00:39:40,069
use it but I found there was one little

00:39:37,130 --> 00:39:43,030
problem that I need to report about it

00:39:40,069 --> 00:39:45,170
it only writes one direction right now

00:39:43,030 --> 00:39:49,040
it would be nice to be able to download

00:39:45,170 --> 00:39:55,490
it but you can't write to it I mean you

00:39:49,040 --> 00:39:58,540
yeah it only goes in one direction okay

00:39:55,490 --> 00:40:01,190
and I will try to implement that soon

00:39:58,540 --> 00:40:04,640
alright so now this is the Intel

00:40:01,190 --> 00:40:07,069
solution it was developed it can be used

00:40:04,640 --> 00:40:09,829
completely it does not depend on TTM in

00:40:07,069 --> 00:40:14,869
any way in fact the intel driver does

00:40:09,829 --> 00:40:16,910
not use TTM and as I saying before it

00:40:14,869 --> 00:40:18,740
uses a handle which behaves like a file

00:40:16,910 --> 00:40:21,200
descriptor it uses the classic UNIX

00:40:18,740 --> 00:40:24,950
model you can do all the behaviors like

00:40:21,200 --> 00:40:27,859
you normally do there is no Universal

00:40:24,950 --> 00:40:32,230
gem creation routine you can close it

00:40:27,859 --> 00:40:35,270
you can memory map it you can do

00:40:32,230 --> 00:40:36,740
symlinks but you can not there's no

00:40:35,270 --> 00:40:39,349
universal creation the problem is

00:40:36,740 --> 00:40:43,549
graphics hardware is way too complicated

00:40:39,349 --> 00:40:45,589
there are too many different the tiling

00:40:43,549 --> 00:40:47,660
structures are different z-buffer

00:40:45,589 --> 00:40:53,720
stencil buffers they're all different

00:40:47,660 --> 00:40:55,880
formats so that's so there's no way for

00:40:53,720 --> 00:41:00,010
we have the same issue we had to develop

00:40:55,880 --> 00:41:02,750
our own they now one of the interesting

00:41:00,010 --> 00:41:04,490
challenges that we discovered is when we

00:41:02,750 --> 00:41:08,059
were implementing this because they are

00:41:04,490 --> 00:41:10,280
independent in that struck drm driver

00:41:08,059 --> 00:41:12,319
there's an actually em the memory map

00:41:10,280 --> 00:41:14,480
routine that you fill in for the file

00:41:12,319 --> 00:41:17,030
operations while they both implement

00:41:14,480 --> 00:41:19,970
their own memory mapping routine which

00:41:17,030 --> 00:41:23,310
don't play nicely together if they

00:41:19,970 --> 00:41:25,860
expect either one or the other so

00:41:23,310 --> 00:41:29,250
I had to do something a little magic to

00:41:25,860 --> 00:41:34,160
make that work but you can do it and

00:41:29,250 --> 00:41:38,690
basically I Gemma fide the TTM mm map

00:41:34,160 --> 00:41:42,300
again so that's how we got around that

00:41:38,690 --> 00:41:46,290
you can see that in our the C file TTM

00:41:42,300 --> 00:41:48,030
underscore gem dot C and the nice way

00:41:46,290 --> 00:41:51,210
the reason I could do this because in

00:41:48,030 --> 00:41:54,180
the the drm driver structure you

00:41:51,210 --> 00:41:57,810
actually have the ability to control the

00:41:54,180 --> 00:42:00,090
vm operations for the virtual memory it

00:41:57,810 --> 00:42:03,210
has a for the page fault in the via the

00:42:00,090 --> 00:42:06,240
vm open VM closed its NT TM those are

00:42:03,210 --> 00:42:09,870
defiant you can't set those they're

00:42:06,240 --> 00:42:12,240
already predefined so that was a

00:42:09,870 --> 00:42:14,430
interesting there's also hooks you have

00:42:12,240 --> 00:42:19,320
to implement the gem in it object and

00:42:14,430 --> 00:42:21,450
gem and free object in it object was one

00:42:19,320 --> 00:42:23,010
of those really great ideas that they

00:42:21,450 --> 00:42:26,130
were going to actually create things

00:42:23,010 --> 00:42:27,720
inside there but nobody's ever used it

00:42:26,130 --> 00:42:29,670
for that so it's an empty function

00:42:27,720 --> 00:42:31,500
everybody's nobody's ever tried to use

00:42:29,670 --> 00:42:34,050
it and there's reasons because the way

00:42:31,500 --> 00:42:36,930
that there are some code the way the

00:42:34,050 --> 00:42:39,870
code is written to create to open a gem

00:42:36,930 --> 00:42:42,060
object it doesn't fit quite nicely to

00:42:39,870 --> 00:42:44,730
the code would have to be rearranged to

00:42:42,060 --> 00:42:47,010
properly use it now Jim free object is

00:42:44,730 --> 00:42:51,290
quite used and in our case we freed the

00:42:47,010 --> 00:42:51,290
TTM object that's located underneath it

00:42:51,740 --> 00:42:57,720
okay now with all now one of the

00:42:55,260 --> 00:43:00,750
greatest problems is with all these

00:42:57,720 --> 00:43:02,610
mappings is that a lot of people's what

00:43:00,750 --> 00:43:05,310
happened was they created the lib drm

00:43:02,610 --> 00:43:07,680
library which is used by a lot of the

00:43:05,310 --> 00:43:08,970
drivers you begin it was basically it's

00:43:07,680 --> 00:43:10,920
a library to control the buffer

00:43:08,970 --> 00:43:12,840
management for the specific types of

00:43:10,920 --> 00:43:14,490
hardware well let's start getting

00:43:12,840 --> 00:43:17,490
extremely complicated and extremely

00:43:14,490 --> 00:43:18,870
crazy and start diverging everywhere so

00:43:17,490 --> 00:43:21,690
what happened is a lot of people said

00:43:18,870 --> 00:43:26,100
well look here okay the tiling stuff is

00:43:21,690 --> 00:43:27,690
all over the map so but there are linear

00:43:26,100 --> 00:43:29,760
frame buffers out there and a lot of

00:43:27,690 --> 00:43:33,060
embedded devices you still linear frame

00:43:29,760 --> 00:43:35,910
buffers so after a lot of arguing and

00:43:33,060 --> 00:43:36,690
stuff they said let's make a basic API

00:43:35,910 --> 00:43:39,540
that

00:43:36,690 --> 00:43:41,910
we could make it so live drm and you

00:43:39,540 --> 00:43:44,130
could get an ex org driver up and going

00:43:41,910 --> 00:43:47,339
right away once you have the kernel mode

00:43:44,130 --> 00:43:50,730
setting going so this is basically a

00:43:47,339 --> 00:43:54,510
very basic API to handle a linear non

00:43:50,730 --> 00:43:56,339
tiled buffer for us and like most

00:43:54,510 --> 00:43:59,310
drivers almost every driver you'll see

00:43:56,339 --> 00:44:01,710
it's a wrapper around the gem layer it

00:43:59,310 --> 00:44:03,750
also takes a handle from user space and

00:44:01,710 --> 00:44:07,440
it just passes it down to a gem object

00:44:03,750 --> 00:44:10,319
that's created you'll see in this and

00:44:07,440 --> 00:44:13,740
the structure drm driver there's also

00:44:10,319 --> 00:44:16,800
folks for DRM create and the to create

00:44:13,740 --> 00:44:19,619
it also to free it and also do do memory

00:44:16,800 --> 00:44:21,240
memory map offsets because once you

00:44:19,619 --> 00:44:22,980
memory map it that way you can control

00:44:21,240 --> 00:44:27,480
where in the memory map you want it

00:44:22,980 --> 00:44:31,140
right to it okay so that's all the

00:44:27,480 --> 00:44:32,609
memory management system actually

00:44:31,140 --> 00:44:35,130
believe it or not the memory management

00:44:32,609 --> 00:44:38,460
system it's a more complicated API but

00:44:35,130 --> 00:44:40,920
it's easier to write to develop because

00:44:38,460 --> 00:44:42,569
it's very well defined and the other

00:44:40,920 --> 00:44:44,310
thing is if you screw it up it doesn't

00:44:42,569 --> 00:44:46,020
give you the same result when you do

00:44:44,310 --> 00:44:48,329
kernel mode setting which is just a

00:44:46,020 --> 00:44:51,119
blank screen no matter what you do wrong

00:44:48,329 --> 00:44:52,530
it gives you a blank screen it's one of

00:44:51,119 --> 00:44:56,400
the most difficult things to actually

00:44:52,530 --> 00:44:58,550
debug now this was one of the

00:44:56,400 --> 00:45:01,319
controversial things when it came in and

00:44:58,550 --> 00:45:03,930
the reason this was developed was the

00:45:01,319 --> 00:45:06,660
frame buffer layer it was was built

00:45:03,930 --> 00:45:09,569
around the idea of a simple VGA monitor

00:45:06,660 --> 00:45:13,109
just hooked to your display well that's

00:45:09,569 --> 00:45:16,640
changed drastically there are lots of

00:45:13,109 --> 00:45:20,220
things you can control and manipulate so

00:45:16,640 --> 00:45:22,349
so they developed this API and now the

00:45:20,220 --> 00:45:26,010
currently there are three drivers that

00:45:22,349 --> 00:45:30,270
use use this API the Intel Radeon and

00:45:26,010 --> 00:45:32,690
the the Nauvoo driver use this we are

00:45:30,270 --> 00:45:35,760
implementing it's partially implemented

00:45:32,690 --> 00:45:38,430
still debugging it and basically we have

00:45:35,760 --> 00:45:40,950
you have to work the top structure is

00:45:38,430 --> 00:45:45,200
the struck mode config and that's also

00:45:40,950 --> 00:45:48,270
located inside your drm driver structure

00:45:45,200 --> 00:45:52,110
that lists all your device component

00:45:48,270 --> 00:45:56,820
it's everything your encoders your your

00:45:52,110 --> 00:46:00,990
connectors your CRTC's everything it

00:45:56,820 --> 00:46:02,900
also has a frame buffer create API which

00:46:00,990 --> 00:46:06,870
actually now there's frame buffer create

00:46:02,900 --> 00:46:10,050
two API just coming out dealing with

00:46:06,870 --> 00:46:13,040
that allows you to create add a source

00:46:10,050 --> 00:46:16,170
you memory allocate for a gem object and

00:46:13,040 --> 00:46:19,380
then at this point you actually have to

00:46:16,170 --> 00:46:21,300
bind it to something this memory this

00:46:19,380 --> 00:46:23,130
allows the ability to clone your display

00:46:21,300 --> 00:46:25,500
so you can do mirroring so you have this

00:46:23,130 --> 00:46:28,320
frame buffer structure and it goes to

00:46:25,500 --> 00:46:31,410
your display one and your display too or

00:46:28,320 --> 00:46:33,330
you can create or you can even move it

00:46:31,410 --> 00:46:35,040
around you can detach it and attach it

00:46:33,330 --> 00:46:37,560
to another display so you can do screen

00:46:35,040 --> 00:46:39,840
migration you can do all kinds of things

00:46:37,560 --> 00:46:42,450
like that the other thing that has to

00:46:39,840 --> 00:46:45,930
handle this structure is the it pulls

00:46:42,450 --> 00:46:48,030
for changes so if your plug falls out

00:46:45,930 --> 00:46:50,460
and you plug it back in it will know

00:46:48,030 --> 00:46:52,590
that you plugged it back in if you put a

00:46:50,460 --> 00:46:54,800
new monitor in it will know it has to

00:46:52,590 --> 00:46:57,720
change the resolution on the fly it

00:46:54,800 --> 00:46:59,520
actually does this the other nice thing

00:46:57,720 --> 00:47:03,210
it does is it actually sends user land

00:46:59,520 --> 00:47:06,210
events as well and it'll tell it look

00:47:03,210 --> 00:47:09,930
the monitor is changed do not believe

00:47:06,210 --> 00:47:12,570
anything you have so ill know to update

00:47:09,930 --> 00:47:14,580
the software now of course in all these

00:47:12,570 --> 00:47:17,760
structures you have three components

00:47:14,580 --> 00:47:21,210
that define the screen in this model you

00:47:17,760 --> 00:47:25,050
have the or drm CRTC which represents

00:47:21,210 --> 00:47:27,000
your CRT controller types which nowadays

00:47:25,050 --> 00:47:29,370
applies to all types of displays but

00:47:27,000 --> 00:47:31,650
it's your traditional what would control

00:47:29,370 --> 00:47:34,170
the frequency going to your monitor it

00:47:31,650 --> 00:47:36,600
also controls a few other Universal

00:47:34,170 --> 00:47:42,390
functionalities which we'll go over we

00:47:36,600 --> 00:47:45,600
also have the drm encoder is the encoder

00:47:42,390 --> 00:47:47,700
it handles the signal going to the

00:47:45,600 --> 00:47:49,650
display it has to the display has to it

00:47:47,700 --> 00:47:51,690
has to be included usually the

00:47:49,650 --> 00:47:54,510
traditional thing is the DAC and the

00:47:51,690 --> 00:47:56,730
traditional VGA monitor you had your I

00:47:54,510 --> 00:47:58,950
had to go to digital to analog you how

00:47:56,730 --> 00:48:01,210
to convert it another good example is

00:47:58,950 --> 00:48:04,060
hdmi it's encrypted

00:48:01,210 --> 00:48:07,720
you you should really encrypt the screen

00:48:04,060 --> 00:48:10,630
stream going into the to the display and

00:48:07,720 --> 00:48:12,610
your drm connector is actually your

00:48:10,630 --> 00:48:16,930
display itself and usually that

00:48:12,610 --> 00:48:20,170
information comes from the i2c bus so

00:48:16,930 --> 00:48:23,320
we're going to look at the CRTC which is

00:48:20,170 --> 00:48:26,410
this is the hint this is universal to

00:48:23,320 --> 00:48:30,930
all types of displays things that are

00:48:26,410 --> 00:48:35,010
handled by all I'll display all displays

00:48:30,930 --> 00:48:37,780
is color map handling usually gamma sets

00:48:35,010 --> 00:48:40,810
for modern displays in the old days it

00:48:37,780 --> 00:48:44,110
was the you could program the cut color

00:48:40,810 --> 00:48:47,620
maps and soodhu colors cursor handling

00:48:44,110 --> 00:48:49,930
it doesn't matter if you have a digital

00:48:47,620 --> 00:48:51,460
display or CRT you're going to have

00:48:49,930 --> 00:48:55,320
cursors you're going to move it around

00:48:51,460 --> 00:48:58,810
and you're going to turn them on and off

00:48:55,320 --> 00:49:00,820
you also have this destroy function of

00:48:58,810 --> 00:49:04,180
course when you create this class you

00:49:00,820 --> 00:49:06,250
have to clean up after yourself and of

00:49:04,180 --> 00:49:09,580
course there's the set config function

00:49:06,250 --> 00:49:13,590
now set config is what actually programs

00:49:09,580 --> 00:49:17,590
the frequencies to go to your display so

00:49:13,590 --> 00:49:20,140
we like a lot of drivers a lot of code

00:49:17,590 --> 00:49:21,550
was written such that you could use a

00:49:20,140 --> 00:49:25,600
function that calls a lot of other

00:49:21,550 --> 00:49:29,380
functions to share code and for in the

00:49:25,600 --> 00:49:33,910
case of dr the dri api it's the the drm

00:49:29,380 --> 00:49:37,300
CRTC helper set config you will see the

00:49:33,910 --> 00:49:40,090
concept in the KMS layer is you'll have

00:49:37,300 --> 00:49:44,140
these structures like drm CRT and then

00:49:40,090 --> 00:49:46,570
you'll have dr m's CRT helpers which are

00:49:44,140 --> 00:49:49,300
these hooks to supposedly to make your

00:49:46,570 --> 00:49:52,300
life easier but it gives you more

00:49:49,300 --> 00:49:54,340
fine-grained control and you'll see that

00:49:52,300 --> 00:49:56,500
this function this is a good example is

00:49:54,340 --> 00:50:00,210
this is quote a generic function but it

00:49:56,500 --> 00:50:03,810
actually uses the CRT helper functions

00:50:00,210 --> 00:50:06,610
so what are these helper functions and

00:50:03,810 --> 00:50:08,590
the previous slide we saw that you could

00:50:06,610 --> 00:50:11,380
do things like the color map but here we

00:50:08,590 --> 00:50:13,270
can actually load the lookup table which

00:50:11,380 --> 00:50:14,710
refreshes the entire color map the

00:50:13,270 --> 00:50:17,140
previous function could

00:50:14,710 --> 00:50:19,390
change Pacific colors this one actually

00:50:17,140 --> 00:50:21,849
reloads it for example when you actually

00:50:19,390 --> 00:50:23,920
go to a lot of times a classic example

00:50:21,849 --> 00:50:26,260
is when you when you power down your

00:50:23,920 --> 00:50:29,050
display for hibernation you're going to

00:50:26,260 --> 00:50:31,510
a lot of time some empty the color map

00:50:29,050 --> 00:50:33,970
you have to reset the color map your

00:50:31,510 --> 00:50:40,240
classic DPMS functions you want to power

00:50:33,970 --> 00:50:41,770
it up and power it down you also those

00:50:40,240 --> 00:50:44,140
are the classic functions now the other

00:50:41,770 --> 00:50:47,230
thing of course the CRT does all the

00:50:44,140 --> 00:50:49,510
mode settings so you have the mode

00:50:47,230 --> 00:50:51,400
fix-up function now the thing is is

00:50:49,510 --> 00:50:52,570
because you have a nice monitor doesn't

00:50:51,400 --> 00:50:55,270
mean your video card is going to support

00:50:52,570 --> 00:50:57,369
it that's just the reality if you have

00:50:55,270 --> 00:50:59,349
specially older video cards there are

00:50:57,369 --> 00:51:01,930
now monitors out there there are 4000

00:50:59,349 --> 00:51:03,640
pixels some video cars i'm not going to

00:51:01,930 --> 00:51:06,250
like that so that function actually

00:51:03,640 --> 00:51:08,770
picks that up and says wow this monitor

00:51:06,250 --> 00:51:11,020
is too good for me or it could be the

00:51:08,770 --> 00:51:15,670
opposite the monitor could be too low of

00:51:11,020 --> 00:51:17,560
quality so it won't pick it up we also

00:51:15,670 --> 00:51:19,210
have the set-based function and that's

00:51:17,560 --> 00:51:21,280
the one where you tell where in the

00:51:19,210 --> 00:51:23,200
memory what memory region you want to

00:51:21,280 --> 00:51:26,740
use to write to to display in your

00:51:23,200 --> 00:51:29,920
system so that's your basic scrolling

00:51:26,740 --> 00:51:33,910
pan function us i'll have mode prepare

00:51:29,920 --> 00:51:36,310
you this these functions mo prepare mode

00:51:33,910 --> 00:51:39,640
commit mote set if anyone's ever

00:51:36,310 --> 00:51:42,250
familiar with ex or driver writing you

00:51:39,640 --> 00:51:46,210
will see these functions in the in their

00:51:42,250 --> 00:51:47,890
XFX 86 CRT functions structure so they

00:51:46,210 --> 00:51:51,369
just basically took it out and threw it

00:51:47,890 --> 00:51:53,349
in here so the prepare structure

00:51:51,369 --> 00:51:56,500
actually sets up the graphic state for

00:51:53,349 --> 00:51:57,820
mode setting so before use video mode

00:51:56,500 --> 00:52:00,430
you change your video mode there are

00:51:57,820 --> 00:52:03,430
certain things you got to do a good

00:52:00,430 --> 00:52:05,770
example of that is you need to stop your

00:52:03,430 --> 00:52:09,160
view blah the video blanking interrupts

00:52:05,770 --> 00:52:13,119
you don't want to you don't care about

00:52:09,160 --> 00:52:15,250
that during that time also the other

00:52:13,119 --> 00:52:16,990
thing you want to do which most driver

00:52:15,250 --> 00:52:19,119
writers do is they power down their

00:52:16,990 --> 00:52:22,000
screen you don't want to see your screen

00:52:19,119 --> 00:52:23,770
scribbled for a few seconds so you turn

00:52:22,000 --> 00:52:26,920
off your screen

00:52:23,770 --> 00:52:29,320
the commit function is the opposite it

00:52:26,920 --> 00:52:30,940
actually resets for example the video

00:52:29,320 --> 00:52:35,500
blanking interrupts and it will actually

00:52:30,940 --> 00:52:37,150
reset your screen and turn it back on so

00:52:35,500 --> 00:52:39,430
those are the things you want to do so

00:52:37,150 --> 00:52:42,280
this way it doesn't blind you or you

00:52:39,430 --> 00:52:45,760
don't have a pokeyman seizure now mode

00:52:42,280 --> 00:52:48,400
set is a the mode set is actually what

00:52:45,760 --> 00:52:51,730
does the real work it's the engine that

00:52:48,400 --> 00:52:54,490
displays it it sets the PLL it sets the

00:52:51,730 --> 00:52:57,760
clock and it does all the program it

00:52:54,490 --> 00:53:00,520
does all the frequency stuff so it

00:52:57,760 --> 00:53:02,470
handles all that now this code is

00:53:00,520 --> 00:53:05,050
extracted out you'll notice it doesn't

00:53:02,470 --> 00:53:07,390
handle things like what is the bits per

00:53:05,050 --> 00:53:09,310
pixel and things like that these things

00:53:07,390 --> 00:53:12,010
can be changed without modifying the

00:53:09,310 --> 00:53:15,730
entire graphics engine that's why it's

00:53:12,010 --> 00:53:17,470
sort it that way now you can do all that

00:53:15,730 --> 00:53:20,710
but actually you have to know how to

00:53:17,470 --> 00:53:22,870
talk to the display even with the

00:53:20,710 --> 00:53:24,610
frequencies coming in the displays

00:53:22,870 --> 00:53:27,730
handle those frequencies differently

00:53:24,610 --> 00:53:30,970
good example is LCD you can set a mode

00:53:27,730 --> 00:53:33,640
on it it has a lcds normally have a

00:53:30,970 --> 00:53:36,250
fixed resolution so what you do is you

00:53:33,640 --> 00:53:38,350
have to scale it up those are the kind

00:53:36,250 --> 00:53:41,020
of things you have to do when you set it

00:53:38,350 --> 00:53:45,430
up so the encoder tells you how to talk

00:53:41,020 --> 00:53:48,700
to the display so the function the

00:53:45,430 --> 00:53:50,950
actually the drm encoder is actually

00:53:48,700 --> 00:53:54,280
pretty simple has two functions as the

00:53:50,950 --> 00:53:56,650
reset functions that's like it says

00:53:54,280 --> 00:53:58,630
that's when things go really bad you

00:53:56,650 --> 00:54:01,980
reset your system and destroy us of

00:53:58,630 --> 00:54:05,260
course when you're done using it now

00:54:01,980 --> 00:54:08,530
like all like as I point out earlier k

00:54:05,260 --> 00:54:12,220
km s is lots of helpers and again we

00:54:08,530 --> 00:54:15,100
have helpers here in this case and the

00:54:12,220 --> 00:54:17,020
and here we have again power management

00:54:15,100 --> 00:54:19,480
as you will see power management's

00:54:17,020 --> 00:54:22,480
handled at various levels because it's

00:54:19,480 --> 00:54:24,190
handled a little differently so when you

00:54:22,480 --> 00:54:25,840
when you actually power down your

00:54:24,190 --> 00:54:28,810
monitor it actually goes through these

00:54:25,840 --> 00:54:31,300
layers it's kind of like the root and

00:54:28,810 --> 00:54:33,400
that's because well as we all know GPUs

00:54:31,300 --> 00:54:36,430
are in graphics cards are the most

00:54:33,400 --> 00:54:37,570
complex instruments today when we power

00:54:36,430 --> 00:54:39,400
down our systems we

00:54:37,570 --> 00:54:40,960
downer hard drives in there you go

00:54:39,400 --> 00:54:44,410
through the same routine on a graphics

00:54:40,960 --> 00:54:47,020
card just with different components so

00:54:44,410 --> 00:54:51,120
you have that and also you have your

00:54:47,020 --> 00:54:53,470
mode fix up again it's the same issue

00:54:51,120 --> 00:54:56,500
your graphics card might be able to

00:54:53,470 --> 00:54:59,050
program the mode but the signal going

00:54:56,500 --> 00:55:03,220
out might not like it classic examples

00:54:59,050 --> 00:55:05,440
of that inter interlace it might not

00:55:03,220 --> 00:55:06,880
support that or the classic one I don't

00:55:05,440 --> 00:55:11,110
know if any of you have encountered that

00:55:06,880 --> 00:55:14,230
a lot of hdtvs have do not handle over

00:55:11,110 --> 00:55:17,080
scan the same way yeah you say okay

00:55:14,230 --> 00:55:18,820
you've seen that yeah so these are

00:55:17,080 --> 00:55:21,760
things you have to actually catch in the

00:55:18,820 --> 00:55:25,180
encoder and say whoa we don't handle the

00:55:21,760 --> 00:55:27,060
overscan very well on the HDTV so we're

00:55:25,180 --> 00:55:31,060
going to have to try to behave properly

00:55:27,060 --> 00:55:32,830
so now in the function just like the

00:55:31,060 --> 00:55:35,290
other one you have the prepare commit

00:55:32,830 --> 00:55:37,840
and mode set which is the same now in

00:55:35,290 --> 00:55:41,910
the encoders mode set is very specific

00:55:37,840 --> 00:55:44,500
to what it is and the for digital

00:55:41,910 --> 00:55:47,350
because the way program and analog port

00:55:44,500 --> 00:55:50,010
and a digital port is very different so

00:55:47,350 --> 00:55:54,160
the mode set handles those intricacies

00:55:50,010 --> 00:55:57,130
now and commit is of course what what

00:55:54,160 --> 00:55:59,110
you do after you're done and prepare is

00:55:57,130 --> 00:56:01,240
of course what you do before you do so

00:55:59,110 --> 00:56:04,720
you set the hardware state in such they

00:56:01,240 --> 00:56:06,910
can handle what's about to occur because

00:56:04,720 --> 00:56:08,740
then well today it's a little bit better

00:56:06,910 --> 00:56:10,930
but I remember in the old days sometimes

00:56:08,740 --> 00:56:16,000
you had a decoy your son monitors if you

00:56:10,930 --> 00:56:18,990
did it wrong okay the and then the final

00:56:16,000 --> 00:56:21,580
structure is the actual display itself

00:56:18,990 --> 00:56:24,720
this is a little tricky because some

00:56:21,580 --> 00:56:27,160
monitors are smart some monitors are

00:56:24,720 --> 00:56:30,010
impaired and then some monitors don't

00:56:27,160 --> 00:56:32,560
talk to you your classic is embedded

00:56:30,010 --> 00:56:34,420
devices you don't know what the display

00:56:32,560 --> 00:56:38,110
really is or what it can really support

00:56:34,420 --> 00:56:41,890
so you have to hard-code it some use EDD

00:56:38,110 --> 00:56:44,980
EDID blocks to tell you what the monitor

00:56:41,890 --> 00:56:47,170
supports sometimes it's it tells you the

00:56:44,980 --> 00:56:48,760
truth sometimes it lies to you so you

00:56:47,170 --> 00:56:51,550
actually have to handle all that stuff

00:56:48,760 --> 00:56:53,740
here so in the canoe

00:56:51,550 --> 00:56:55,840
after format you have again you have

00:56:53,740 --> 00:56:57,400
your state management and here with

00:56:55,840 --> 00:57:00,220
connectors you can actually save the

00:56:57,400 --> 00:57:02,380
state restore the state or reset the

00:57:00,220 --> 00:57:05,680
state so if your monitor gets really

00:57:02,380 --> 00:57:07,390
jammed you can reinitialize it of course

00:57:05,680 --> 00:57:09,670
you have your classic destroy function

00:57:07,390 --> 00:57:12,010
which cleans it up after you unplug it

00:57:09,670 --> 00:57:16,150
and then when you plug it back in you

00:57:12,010 --> 00:57:18,190
can recreate it and you have your DPMS

00:57:16,150 --> 00:57:21,370
course for power management you actually

00:57:18,190 --> 00:57:23,950
want to turn off your screen and there's

00:57:21,370 --> 00:57:26,830
of course the infamous detect are we

00:57:23,950 --> 00:57:28,510
there so you want to know actually is

00:57:26,830 --> 00:57:30,910
something attached now the thing is a

00:57:28,510 --> 00:57:33,880
lot of hardware cards like this laptop

00:57:30,910 --> 00:57:35,620
has a hdmi port but I don't have an HDMI

00:57:33,880 --> 00:57:39,310
monitor plugged in so it actually has

00:57:35,620 --> 00:57:40,870
this routine goes are you there well if

00:57:39,310 --> 00:57:43,450
it's not there doesn't do anything now

00:57:40,870 --> 00:57:45,250
if it is there it fills up the modes so

00:57:43,450 --> 00:57:48,060
it goes through and says oh this is what

00:57:45,250 --> 00:57:51,640
it displays and it will tell you now

00:57:48,060 --> 00:57:54,850
usually monitors will tell you with that

00:57:51,640 --> 00:57:56,320
now what modes are supported and for

00:57:54,850 --> 00:57:58,270
embedded platforms you actually got a

00:57:56,320 --> 00:58:01,390
hardco dead in there and fill it so when

00:57:58,270 --> 00:58:03,670
you say Phil modes it gets it now set

00:58:01,390 --> 00:58:06,550
properties is the properties to the

00:58:03,670 --> 00:58:09,430
monitors handles every monitors

00:58:06,550 --> 00:58:13,330
different DVI a good example is think of

00:58:09,430 --> 00:58:16,000
DVI analog dvi-d very similar but very

00:58:13,330 --> 00:58:18,670
very different how they handle things so

00:58:16,000 --> 00:58:22,030
these are specific properties that these

00:58:18,670 --> 00:58:23,980
monitors will have hdmi for example it's

00:58:22,030 --> 00:58:26,440
a digital system like dbi but it

00:58:23,980 --> 00:58:28,060
supports audio over the channel you can

00:58:26,440 --> 00:58:29,830
send audio signals as well as video

00:58:28,060 --> 00:58:33,310
signals over so these are the things you

00:58:29,830 --> 00:58:37,690
can actually see as properties and of

00:58:33,310 --> 00:58:40,450
course there's the force option that one

00:58:37,690 --> 00:58:44,320
is that's when you take a hammer to it

00:58:40,450 --> 00:58:46,450
when all else fails thats that's the one

00:58:44,320 --> 00:58:50,080
it will select usually sometimes

00:58:46,450 --> 00:58:51,580
monitors you can say you have a monitor

00:58:50,080 --> 00:58:54,340
you have one display and you can plug in

00:58:51,580 --> 00:58:56,470
the analog and digital it'll pick one

00:58:54,340 --> 00:58:59,110
and you can only see one at a time so

00:58:56,470 --> 00:59:01,060
which one do you want to see that's what

00:58:59,110 --> 00:59:03,790
that that will tell you it will have a

00:59:01,060 --> 00:59:04,880
get you can control the preference and

00:59:03,790 --> 00:59:07,670
of course

00:59:04,880 --> 00:59:11,870
we have helpers again we have the

00:59:07,670 --> 00:59:14,810
ability to get the modes then that one

00:59:11,870 --> 00:59:18,340
will actually retrieve it it's very

00:59:14,810 --> 00:59:21,530
similar to fill modes actually actually

00:59:18,340 --> 00:59:24,470
helpers of course is called inside Phil

00:59:21,530 --> 00:59:26,210
modes so the the reason for get modes it

00:59:24,470 --> 00:59:28,100
might seem similar to fill modes but

00:59:26,210 --> 00:59:30,830
Phil modes are usually implemented such

00:59:28,100 --> 00:59:32,090
that they call get modes now you're

00:59:30,830 --> 00:59:35,480
probably saying why not just have one

00:59:32,090 --> 00:59:39,050
function the reason why is they say for

00:59:35,480 --> 00:59:41,170
things like the LVDS the embedded

00:59:39,050 --> 00:59:44,780
display sometimes they do have ed DS

00:59:41,170 --> 00:59:46,010
sometimes they're not hooked up so what

00:59:44,780 --> 00:59:49,820
happens is you can have the same

00:59:46,010 --> 00:59:51,560
hardware on a vendor and the driver will

00:59:49,820 --> 00:59:54,260
go and I'll try the EDD and they'll say

00:59:51,560 --> 00:59:56,480
oh ok I've got modes but then on some

00:59:54,260 --> 00:59:57,710
platforms it will not be hooked up and

00:59:56,480 --> 01:00:00,620
you'll say oh I'm not getting anything

00:59:57,710 --> 01:00:03,500
so or it could be busted so then it'll

01:00:00,620 --> 01:00:05,420
have to fill in modes in another way so

01:00:03,500 --> 01:00:09,350
that's why you do that that's why that's

01:00:05,420 --> 01:00:13,550
handled and best encoder and that tells

01:00:09,350 --> 01:00:15,800
you which signal do you prefer to send

01:00:13,550 --> 01:00:18,740
over like I said you can actually have

01:00:15,800 --> 01:00:20,690
multiple displays we have these you see

01:00:18,740 --> 01:00:22,670
these wires that are split and you can

01:00:20,690 --> 01:00:25,850
plug in your analog and digital you can

01:00:22,670 --> 01:00:28,310
pick which one you want what is the best

01:00:25,850 --> 01:00:31,490
encoder for that for connected to the

01:00:28,310 --> 01:00:33,560
connect to the connectors digital

01:00:31,490 --> 01:00:37,280
signals you can choose between DVI and

01:00:33,560 --> 01:00:39,320
HDMI which one would you rather have so

01:00:37,280 --> 01:00:41,860
that's all the memory management and

01:00:39,320 --> 01:00:47,450
that's all and then is also all the

01:00:41,860 --> 01:00:49,520
essence of mode setting number now we're

01:00:47,450 --> 01:00:52,430
going to the traditional functionality

01:00:49,520 --> 01:00:56,000
of the drivers this is stuff that pre

01:00:52,430 --> 01:00:58,370
KMS drivers have done and the one of the

01:00:56,000 --> 01:01:01,010
most important functionalities is irq

01:00:58,370 --> 01:01:04,220
handling actually and this is actually

01:01:01,010 --> 01:01:07,250
what drove the use of KMS actually is

01:01:04,220 --> 01:01:09,440
because our queue handling is very

01:01:07,250 --> 01:01:11,540
painful to go to user land you have a

01:01:09,440 --> 01:01:14,120
severe penalty cost which you just

01:01:11,540 --> 01:01:16,310
cannot handle in graphics drivers so

01:01:14,120 --> 01:01:17,670
this entire system was developed to

01:01:16,310 --> 01:01:19,980
handle this kind of stuff

01:01:17,670 --> 01:01:23,609
including also the issue with SMP

01:01:19,980 --> 01:01:25,829
systems so for your regular driver

01:01:23,609 --> 01:01:29,720
there's a rapper the drm layer provides

01:01:25,829 --> 01:01:34,980
a CRM irq you can install or install it

01:01:29,720 --> 01:01:37,799
the routines are broken up you can you

01:01:34,980 --> 01:01:39,270
can prayers a pre install and that's to

01:01:37,799 --> 01:01:40,740
configure your hardware usually you have

01:01:39,270 --> 01:01:44,549
to program some register and say use

01:01:40,740 --> 01:01:47,640
this irq don't use this irq some usually

01:01:44,549 --> 01:01:49,650
bit mask and irq uninstall is the same

01:01:47,640 --> 01:01:52,349
it is the opposite that's when you want

01:01:49,650 --> 01:01:54,630
to disable it usually it's on a module

01:01:52,349 --> 01:01:56,160
loading and unloading but sometimes you

01:01:54,630 --> 01:01:58,109
actually want to turn off I are cues if

01:01:56,160 --> 01:02:01,710
you get a higher Q storm or things like

01:01:58,109 --> 01:02:03,990
that so your system it was funky now

01:02:01,710 --> 01:02:06,150
there's also the post install which

01:02:03,990 --> 01:02:10,710
handles the state and setting up

01:02:06,150 --> 01:02:13,200
structures it's a hook for after you get

01:02:10,710 --> 01:02:15,299
a irq request if anyone has done kernel

01:02:13,200 --> 01:02:16,950
driver development there's a function in

01:02:15,299 --> 01:02:21,119
the clinics curdle that actually

01:02:16,950 --> 01:02:23,819
requests it I usually post installs

01:02:21,119 --> 01:02:26,220
deals with the new stuff like MSI and

01:02:23,819 --> 01:02:28,799
you can register handles with it and

01:02:26,220 --> 01:02:30,660
stuff and the reason is because we're

01:02:28,799 --> 01:02:34,589
coming to the point where I are queues

01:02:30,660 --> 01:02:37,290
are being shared between the acpi layer

01:02:34,589 --> 01:02:40,020
and the graphics drivers so it's now

01:02:37,290 --> 01:02:41,339
it's getting really complicated so now

01:02:40,020 --> 01:02:43,829
you have to manage the state make sure

01:02:41,339 --> 01:02:45,210
it doesn't get out of sync you can see

01:02:43,829 --> 01:02:46,530
that with light especially with

01:02:45,210 --> 01:02:48,230
backlight issues there's three different

01:02:46,530 --> 01:02:50,790
ways you can set your backlight now and

01:02:48,230 --> 01:02:55,200
you have to make them all keep together

01:02:50,790 --> 01:02:58,859
oooo am i running over okay thank you

01:02:55,200 --> 01:03:00,990
okay and of course video blanking video

01:02:58,859 --> 01:03:04,470
blanking is of course to prevent things

01:03:00,990 --> 01:03:06,660
like sharing on your screen this has a

01:03:04,470 --> 01:03:10,170
basic function it's pretty easy to do

01:03:06,660 --> 01:03:13,349
this this is also a pre KMS feature the

01:03:10,170 --> 01:03:15,180
behavior of it it's a little changed due

01:03:13,349 --> 01:03:18,690
to KMS because you'd be for you had to

01:03:15,180 --> 01:03:22,290
specify what your CRT was by an index

01:03:18,690 --> 01:03:24,240
and now you can do more and the thing is

01:03:22,290 --> 01:03:26,670
is when you know internally the CRT

01:03:24,240 --> 01:03:29,760
functionality you actually know what the

01:03:26,670 --> 01:03:30,980
frequencies are so without knowing what

01:03:29,760 --> 01:03:32,359
the CRT is with

01:03:30,980 --> 01:03:35,150
blanking you kind of didn't know what

01:03:32,359 --> 01:03:36,740
the real timing was and especially

01:03:35,150 --> 01:03:39,260
nowadays with hot plug and you can

01:03:36,740 --> 01:03:41,180
switch your monitors out how long is it

01:03:39,260 --> 01:03:45,050
going to be to the thinking next time

01:03:41,180 --> 01:03:46,369
you don't know so the API on the surface

01:03:45,050 --> 01:03:48,050
looks similar but then there is

01:03:46,369 --> 01:03:50,570
enhancements done to deal with these

01:03:48,050 --> 01:03:53,540
things with hot plug in and modern

01:03:50,570 --> 01:03:56,750
monitors so the basic functionality was

01:03:53,540 --> 01:03:58,490
to enable it to disable it there is a

01:03:56,750 --> 01:04:00,920
hook furred they get the video blank

01:03:58,490 --> 01:04:04,030
counter that's where how many have

01:04:00,920 --> 01:04:07,640
occurred the other thing is the

01:04:04,030 --> 01:04:09,230
timestamp some people actually want to

01:04:07,640 --> 01:04:11,030
know when the video blanking happens

01:04:09,230 --> 01:04:14,359
because sometimes it takes a while to

01:04:11,030 --> 01:04:15,650
get to you even if you even under the

01:04:14,359 --> 01:04:18,950
best circumstances your machines under

01:04:15,650 --> 01:04:20,720
load you're going to say you're running

01:04:18,950 --> 01:04:22,400
blender or something and it's processing

01:04:20,720 --> 01:04:24,859
and creating the see my its displaying

01:04:22,400 --> 01:04:26,450
it you might loose and get out of sync

01:04:24,859 --> 01:04:31,250
and then it's up to the user application

01:04:26,450 --> 01:04:33,920
do I honor this sink so and in the KMS

01:04:31,250 --> 01:04:35,960
version you can use the CRT frequency

01:04:33,920 --> 01:04:39,170
settings to calculate what is the real

01:04:35,960 --> 01:04:41,450
time stand so it gets a better time

01:04:39,170 --> 01:04:42,890
stamp and there's an actual function

01:04:41,450 --> 01:04:44,119
that they provide that does a lot of the

01:04:42,890 --> 01:04:45,710
math for you so you don't have to

01:04:44,119 --> 01:04:50,000
twiddle your thumbs and reinvent the

01:04:45,710 --> 01:04:53,180
wheel that's drm calc v blank stamp from

01:04:50,000 --> 01:04:58,070
scan outpost yeah i know it's really

01:04:53,180 --> 01:05:00,410
long so as I said KMS had to do more

01:04:58,070 --> 01:05:03,140
actually no because now you do things

01:05:00,410 --> 01:05:05,330
like power management you change your

01:05:03,140 --> 01:05:07,820
video mode so you actually have to

01:05:05,330 --> 01:05:09,950
handle the video blanking in a state

01:05:07,820 --> 01:05:11,690
during those things because now it

01:05:09,950 --> 01:05:13,880
doesn't matter it doesn't matter if

01:05:11,690 --> 01:05:15,890
you're halfway through a sink when you

01:05:13,880 --> 01:05:17,570
change your video mode you're going to

01:05:15,890 --> 01:05:19,760
have to deal with that or you can

01:05:17,570 --> 01:05:22,070
actually sync it to the video mode the

01:05:19,760 --> 01:05:25,040
the video blinking there's different

01:05:22,070 --> 01:05:28,220
things you can do you also have

01:05:25,040 --> 01:05:31,190
functions put and get everybody loves

01:05:28,220 --> 01:05:34,820
those terms you can actually control the

01:05:31,190 --> 01:05:38,540
ownership of those irqs of the video of

01:05:34,820 --> 01:05:42,140
the V blank count there's a way to do

01:05:38,540 --> 01:05:44,060
referencing on it because you could have

01:05:42,140 --> 01:05:44,630
a horde of people wanting to know what

01:05:44,060 --> 01:05:46,490
is the video

01:05:44,630 --> 01:05:50,540
you what's what state is the video

01:05:46,490 --> 01:05:53,960
blanking in so you have to deal with who

01:05:50,540 --> 01:05:57,710
who's most important to deal with it if

01:05:53,960 --> 01:06:00,050
you have a hundred opengl apps who want

01:05:57,710 --> 01:06:01,670
to sync up to share somebody's got to

01:06:00,050 --> 01:06:06,230
come first and somebody's going to come

01:06:01,670 --> 01:06:08,660
last okay and of course when you shut it

01:06:06,230 --> 01:06:10,640
down you have the video blank off that

01:06:08,660 --> 01:06:12,770
will flush your queue so they'll all get

01:06:10,640 --> 01:06:15,740
to trample out and then it'll shut it

01:06:12,770 --> 01:06:19,730
down and of course you have your v blank

01:06:15,740 --> 01:06:22,970
handle that's your what you do that's um

01:06:19,730 --> 01:06:25,580
that's a way that's the way to handle

01:06:22,970 --> 01:06:28,580
the KMS layer within the video in the

01:06:25,580 --> 01:06:30,280
irq bottom handler it does a lot of

01:06:28,580 --> 01:06:35,770
bookkeeping for you so you don't have to

01:06:30,280 --> 01:06:35,770
reinvent the wheel and that's it's a

01:06:36,940 --> 01:06:45,050
questions i know it was a lot to digest

01:06:41,230 --> 01:06:47,030
it's a very complicated AP a complicated

01:06:45,050 --> 01:06:50,630
API but i hope this gives you an idea

01:06:47,030 --> 01:06:53,120
how to do this so I'm hoping that

01:06:50,630 --> 01:06:58,720
embedded developers can move to this API

01:06:53,120 --> 01:06:58,720
and have some idea how to do it thank

01:07:17,160 --> 01:07:20,940
what about this I can help you like it

01:07:19,079 --> 01:07:22,650
we have the same problem what would

01:07:20,940 --> 01:07:24,980
happen up a few haters you gave me I

01:07:22,650 --> 01:07:24,980
found

01:07:26,840 --> 01:07:31,410
let's put the word out

01:07:29,349 --> 01:07:31,410
you

01:08:39,150 --> 01:08:45,910
as a service leader in cloud computing

01:08:42,790 --> 01:08:47,500
all we do is hosting computing to us the

01:08:45,910 --> 01:08:49,450
cloud is just the next generation of

01:08:47,500 --> 01:08:51,400
hosting and if someone who's been in the

01:08:49,450 --> 01:08:53,440
hosting industry for 12 years we feel

01:08:51,400 --> 01:08:54,520
we're in a unique position to really

01:08:53,440 --> 01:08:56,650
help bring these two worlds together

01:08:54,520 --> 01:08:58,990
these different sets of technologies and

01:08:56,650 --> 01:09:01,300
to help companies embrace this new world

01:08:58,990 --> 01:09:03,310
in this great new tool that allows

01:09:01,300 --> 01:09:05,890
faster innovation not only is it about

01:09:03,310 --> 01:09:11,290
us being responsive and accountable but

01:09:05,890 --> 01:09:14,130
it's about us doing more for you webos

01:09:11,290 --> 01:09:17,680
an OS that works the way that you do

01:09:14,130 --> 01:09:21,840
across all your devices HP Slate and

01:09:17,680 --> 01:09:21,840

YouTube URL: https://www.youtube.com/watch?v=smBaqKWpCSQ


