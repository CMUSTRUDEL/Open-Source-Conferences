Title: 2012 SouthEast LinuxFest - MySQL Training - Jimmy Yang - NoSQL with MySQL - Best of Both Worlds
Publication date: 2014-01-16
Playlist: 2012 SouthEast LinuxFest - MySQL Training - Advanced
Description: 
	2012 SouthEast LinuxFest
MySQL Training - Advanced
Jimmy Yang
NoSQL with MySQL:  Best of Both Worlds
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:07,980
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:07,980 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:17,609
more information about the southeast

00:00:12,090 --> 00:00:19,439
linux fest visit WWDC linux bez org the

00:00:17,609 --> 00:00:22,320
southeast linux fest would like to thank

00:00:19,439 --> 00:00:25,070
the following diamond sponsors in 2012

00:00:22,320 --> 00:00:33,989
for helping make these videos possible

00:00:25,070 --> 00:00:37,050
all right okay his tia agenda we first

00:00:33,989 --> 00:00:38,160
talked a little bit about no sequel

00:00:37,050 --> 00:00:40,260
what's the difference between those

00:00:38,160 --> 00:00:43,500
seeking to my sequel and relational

00:00:40,260 --> 00:00:48,390
database so why no seeker is kind of a

00:00:43,500 --> 00:00:51,329
hot topic right now and we also talked

00:00:48,390 --> 00:00:54,210
about some another solution that we are

00:00:51,329 --> 00:00:56,820
currently a lot of web company is

00:00:54,210 --> 00:01:01,260
dealing with this no sequel they use my

00:00:56,820 --> 00:01:05,549
sequel plus some friends front end such

00:01:01,260 --> 00:01:07,110
as memcache d then we talk as though

00:01:05,549 --> 00:01:10,229
about the problem with those two

00:01:07,110 --> 00:01:14,880
solution so what's anything that the

00:01:10,229 --> 00:01:18,350
particular that we can explore so then i

00:01:14,880 --> 00:01:23,250
bring out our solution which is memcache

00:01:18,350 --> 00:01:26,580
d+ nodb all eventually the memcached you

00:01:23,250 --> 00:01:28,680
can extend to any no sequel database so

00:01:26,580 --> 00:01:34,350
it's the best of the both words it saw

00:01:28,680 --> 00:01:36,180
solves problems then i will talk a

00:01:34,350 --> 00:01:40,229
little bit how we're going to use the

00:01:36,180 --> 00:01:42,150
nodb memcache d and also i will go

00:01:40,229 --> 00:01:43,950
through a memcache d with my sequel

00:01:42,150 --> 00:01:50,430
cluster which is different from my

00:01:43,950 --> 00:01:58,409
sequel okay so let's start with no

00:01:50,430 --> 00:02:03,140
sequel so no sequel is becoming a hot

00:01:58,409 --> 00:02:06,810
topic recently I in the past two years

00:02:03,140 --> 00:02:10,520
mainly for the a key value store for the

00:02:06,810 --> 00:02:13,020
a lot of Internet company so last year

00:02:10,520 --> 00:02:13,860
probably two years ago I start to hear

00:02:13,020 --> 00:02:17,430
about no see

00:02:13,860 --> 00:02:20,160
and it's gaining a momentum so the

00:02:17,430 --> 00:02:23,670
reason is being that is a lot of social

00:02:20,160 --> 00:02:27,630
network company it shows up they are

00:02:23,670 --> 00:02:30,840
dealing with a lot of simple data of all

00:02:27,630 --> 00:02:34,520
text data so what they need to do is

00:02:30,840 --> 00:02:37,110
really not to do any kind of relational

00:02:34,520 --> 00:02:40,500
explore of the data rather than they

00:02:37,110 --> 00:02:42,150
just want the data fast so it's like you

00:02:40,500 --> 00:02:44,670
have a friends and you like these

00:02:42,150 --> 00:02:46,070
friends and make some comments and you

00:02:44,670 --> 00:02:48,510
just want those information right away

00:02:46,070 --> 00:02:52,200
there's not much a very complex

00:02:48,510 --> 00:02:55,709
relationship those are users and users

00:02:52,200 --> 00:02:59,820
friends and those kind of comments it's

00:02:55,709 --> 00:03:04,440
very simple so the relation model are

00:02:59,820 --> 00:03:09,930
the relationship between those items are

00:03:04,440 --> 00:03:12,800
not that important so then it our

00:03:09,930 --> 00:03:17,850
performance so the no sequel database

00:03:12,800 --> 00:03:21,000
currently can up performs a DBMS mainly

00:03:17,850 --> 00:03:24,350
because they are simple just simple they

00:03:21,000 --> 00:03:28,110
are just designed to handle such kind of

00:03:24,350 --> 00:03:34,170
tax queries they are designed to handle

00:03:28,110 --> 00:03:38,280
this fast and with less overhead so

00:03:34,170 --> 00:03:43,019
overhead mainly comes from the arm rdbms

00:03:38,280 --> 00:03:45,600
query processing and the optimizer so

00:03:43,019 --> 00:03:48,420
let's take a look at what a relational

00:03:45,600 --> 00:03:51,840
database will do to process a query so

00:03:48,420 --> 00:03:54,989
it's a whole list of the agenda it needs

00:03:51,840 --> 00:03:58,799
to do so first they need to accept the

00:03:54,989 --> 00:04:01,440
query of the network then it started

00:03:58,799 --> 00:04:03,600
passing okay so we have supported a lot

00:04:01,440 --> 00:04:06,600
of complex query so you have to go

00:04:03,600 --> 00:04:10,620
through the passing part then optimize a

00:04:06,600 --> 00:04:15,600
generator plan then query processing

00:04:10,620 --> 00:04:18,540
going to process the plan so then enters

00:04:15,600 --> 00:04:21,630
to the storage engine then it gets to

00:04:18,540 --> 00:04:24,710
the data then for the data because we

00:04:21,630 --> 00:04:28,040
support all kinds of transactional

00:04:24,710 --> 00:04:31,770
queries so we have to lock the table

00:04:28,040 --> 00:04:34,830
then use index fund the row then start

00:04:31,770 --> 00:04:37,710
to either lock the rows as well then

00:04:34,830 --> 00:04:40,470
extract the colon then packaged it they

00:04:37,710 --> 00:04:42,450
turn to the query processing layer then

00:04:40,470 --> 00:04:44,400
query processing layer decides what they

00:04:42,450 --> 00:04:47,870
need to do a further action whether it

00:04:44,400 --> 00:04:50,970
need to be order by needed to sort them

00:04:47,870 --> 00:04:53,760
then unlock the table close the table

00:04:50,970 --> 00:04:56,250
then return the result because that's a

00:04:53,760 --> 00:04:59,730
whole lot of things need to be for each

00:04:56,250 --> 00:05:04,260
you query so even if you want just say

00:04:59,730 --> 00:05:06,210
select from user table where a name ID

00:05:04,260 --> 00:05:10,770
is 10 and you go through all those

00:05:06,210 --> 00:05:14,280
processes so when we do Oh profiling

00:05:10,770 --> 00:05:17,190
okay we just do a profiling look at here

00:05:14,280 --> 00:05:20,460
what that it does so on the top you can

00:05:17,190 --> 00:05:23,130
see the passer you can see the optimizer

00:05:20,460 --> 00:05:26,220
it's on all the top and you also do a

00:05:23,130 --> 00:05:30,300
lot of mem copy between the storage

00:05:26,220 --> 00:05:35,430
layer to the query processing layer so

00:05:30,300 --> 00:05:39,540
that's all costing time and you don't

00:05:35,430 --> 00:05:43,110
see any of those in ODB kind of function

00:05:39,540 --> 00:05:44,880
here it's all on the topless it's all in

00:05:43,110 --> 00:05:46,830
the Mexico query processing later

00:05:44,880 --> 00:05:51,050
optimizer layer so it's in the upper

00:05:46,830 --> 00:05:57,690
layer the lower level it's fairly

00:05:51,050 --> 00:05:59,730
negligible ok so for no sequel database

00:05:57,690 --> 00:06:02,400
and because they are simple their

00:05:59,730 --> 00:06:05,220
commands are simple they just found the

00:06:02,400 --> 00:06:08,010
key maybe it's a hash table on what then

00:06:05,220 --> 00:06:10,950
just achieved a value right away they

00:06:08,010 --> 00:06:13,080
don't need to copy between storage layer

00:06:10,950 --> 00:06:14,700
and query processing linear they don't

00:06:13,080 --> 00:06:18,630
need to generate our plans you just

00:06:14,700 --> 00:06:23,010
retrieve the value also they are have

00:06:18,630 --> 00:06:26,940
very simple command so for example we do

00:06:23,010 --> 00:06:30,330
a select just for getting a user ID or

00:06:26,940 --> 00:06:34,110
tapping slack stall over there from the

00:06:30,330 --> 00:06:37,260
user table where I didn't is 10 so

00:06:34,110 --> 00:06:39,840
that's a very long string so those

00:06:37,260 --> 00:06:43,850
string parts are through the network

00:06:39,840 --> 00:06:47,850
it's quite a bit overhead and for the

00:06:43,850 --> 00:06:52,680
noke sequel such as memcache d we'll

00:06:47,850 --> 00:06:55,290
just say get 10 so that that's as simple

00:06:52,680 --> 00:06:58,340
as that so there's no not much overhead

00:06:55,290 --> 00:07:00,750
in terms of the aquarius string itself

00:06:58,340 --> 00:07:05,389
because a lot of things happening over

00:07:00,750 --> 00:07:09,449
the network so those are also are not

00:07:05,389 --> 00:07:13,139
eligible right now so even a short

00:07:09,449 --> 00:07:16,830
command give you an edge for those kind

00:07:13,139 --> 00:07:19,260
of query so again there's no arm

00:07:16,830 --> 00:07:23,160
overhead on the optimizer and inquiry so

00:07:19,260 --> 00:07:25,050
we just talked about that so countries

00:07:23,160 --> 00:07:28,110
you're a bunch of those no sequel

00:07:25,050 --> 00:07:34,020
database MongoDB is gaining a lot of

00:07:28,110 --> 00:07:42,180
momentum Facebook Twitter all those have

00:07:34,020 --> 00:07:45,840
MongoDB installations okay so there's a

00:07:42,180 --> 00:07:48,570
lot of also a lot of company that mainly

00:07:45,840 --> 00:07:51,330
rely on my sequel they provide

00:07:48,570 --> 00:07:57,599
alternative solution so the solution is

00:07:51,330 --> 00:08:03,570
a beauty on top of the my sequel so

00:07:57,599 --> 00:08:07,500
memcache t itself is a memory key value

00:08:03,570 --> 00:08:12,180
store so most Hastings is hashtag memory

00:08:07,500 --> 00:08:15,620
it has a hash table on the key so it was

00:08:12,180 --> 00:08:19,590
developed by dongha interactive for its

00:08:15,620 --> 00:08:22,979
livejournal com so then it gets popular

00:08:19,590 --> 00:08:25,830
so it's one of the most widely used in

00:08:22,979 --> 00:08:29,669
memory cache implementation for social

00:08:25,830 --> 00:08:33,990
networks so almost all those internet

00:08:29,669 --> 00:08:38,789
company has such kind of setup for

00:08:33,990 --> 00:08:41,820
memcache d so we will see a little bit

00:08:38,789 --> 00:08:45,870
later mamuka she has very simple and

00:08:41,820 --> 00:08:50,970
open protocol a very simple commands to

00:08:45,870 --> 00:08:53,730
get the results so this is the existing

00:08:50,970 --> 00:08:56,639
setup most of them are talk to

00:08:53,730 --> 00:09:00,029
my sequel with complex query once it

00:08:56,639 --> 00:09:02,670
gets the result it just catch them into

00:09:00,029 --> 00:09:05,279
memcache d so the next time in the query

00:09:02,670 --> 00:09:08,699
comes seeing it goes to memcache d and

00:09:05,279 --> 00:09:12,300
fetch directly so for example the the

00:09:08,699 --> 00:09:15,240
user ID part so once they get the ax

00:09:12,300 --> 00:09:18,930
from the database like a name from the

00:09:15,240 --> 00:09:21,990
user table where ID equal to 10 then

00:09:18,930 --> 00:09:27,690
after gets the name as a Peter then it

00:09:21,990 --> 00:09:31,769
was set set keep the key value is 10

00:09:27,690 --> 00:09:34,410
then the name Peter so to memcache d so

00:09:31,769 --> 00:09:38,459
next time I want to gather this name I

00:09:34,410 --> 00:09:40,730
just get 10 that's the command so we'll

00:09:38,459 --> 00:09:43,649
get from em catch you right away

00:09:40,730 --> 00:09:45,810
countryman Cassidy is all you memory so

00:09:43,649 --> 00:09:53,399
it's a hash table so a hash the value

00:09:45,810 --> 00:09:56,160
goes there and fetch the data so we talk

00:09:53,399 --> 00:10:00,000
a then with the a problem with those

00:09:56,160 --> 00:10:02,490
kind of set up even with no sequel so

00:10:00,000 --> 00:10:04,860
for the setup would just talk about my

00:10:02,490 --> 00:10:09,180
sequin memcache d basically you have to

00:10:04,860 --> 00:10:11,510
keep to data in sync so memcache d

00:10:09,180 --> 00:10:17,100
providing you some kind of expiration

00:10:11,510 --> 00:10:22,560
time so you can see I have this data

00:10:17,100 --> 00:10:24,720
expiring 10 seconds so if I change on

00:10:22,560 --> 00:10:28,670
the disc on the relational table or

00:10:24,720 --> 00:10:31,850
particular this key value then the

00:10:28,670 --> 00:10:35,279
memcached you had to read again from the

00:10:31,850 --> 00:10:37,380
frontier database it needs to be reset

00:10:35,279 --> 00:10:40,230
so if there will be difference between

00:10:37,380 --> 00:10:45,089
them memcache d data and in the on-disk

00:10:40,230 --> 00:10:50,040
table you need to refresh it every once

00:10:45,089 --> 00:10:51,750
a while so that keep them in sync the

00:10:50,040 --> 00:10:53,519
other way is that every time you update

00:10:51,750 --> 00:10:55,889
the on the on the database you have to

00:10:53,519 --> 00:10:58,470
update into memcache d so that's two

00:10:55,889 --> 00:11:00,120
updates so you have to update both so

00:10:58,470 --> 00:11:03,810
that's that's something that you need to

00:11:00,120 --> 00:11:05,490
keep them in sync also memcache d is now

00:11:03,810 --> 00:11:07,980
transactional

00:11:05,490 --> 00:11:10,350
can all go back if you put something

00:11:07,980 --> 00:11:13,020
round there it will be there so you

00:11:10,350 --> 00:11:15,089
cannot just slow back it's not like my

00:11:13,020 --> 00:11:16,860
secret transactional so keep coming

00:11:15,089 --> 00:11:19,380
sinkage the problem because my circle

00:11:16,860 --> 00:11:21,120
can roll back sings memcache do you can

00:11:19,380 --> 00:11:24,839
so you have the spec so specifically

00:11:21,120 --> 00:11:27,420
beauty sound mechanism in the web

00:11:24,839 --> 00:11:30,209
service saying well I if I this

00:11:27,420 --> 00:11:34,200
operation rollback I need to collect

00:11:30,209 --> 00:11:38,040
them in da memcache d so a problem with

00:11:34,200 --> 00:11:39,420
no sequel no sequences are not

00:11:38,040 --> 00:11:44,330
transactional it doesn't have the

00:11:39,420 --> 00:11:48,570
transaction properties so it's now crash

00:11:44,330 --> 00:11:51,990
safe so sometimes it crashes you don't

00:11:48,570 --> 00:11:55,350
have a copy of it you then lost it so a

00:11:51,990 --> 00:11:59,880
lot of those design are distributed so

00:11:55,350 --> 00:12:03,420
they have multiple nodes maybe keep the

00:11:59,880 --> 00:12:06,810
same data so just 24 safe if a crash on

00:12:03,420 --> 00:12:08,550
one node is a copy on the other note so

00:12:06,810 --> 00:12:11,970
you want to track your email on those

00:12:08,550 --> 00:12:14,820
and no sequel database then you you

00:12:11,970 --> 00:12:16,980
might sometimes at this system crash you

00:12:14,820 --> 00:12:20,790
lost an email but they deal with this

00:12:16,980 --> 00:12:23,520
with duplication to have clusters so

00:12:20,790 --> 00:12:26,540
that in case this in OneNote crashed

00:12:23,520 --> 00:12:29,760
there's another copy somewhere but

00:12:26,540 --> 00:12:32,910
ensure it doesn't guarantees you right

00:12:29,760 --> 00:12:34,709
it's not like a bank bank transaction if

00:12:32,910 --> 00:12:37,020
you put twenty dollars in yesterday's it

00:12:34,709 --> 00:12:39,000
must be it doesn't have that if

00:12:37,020 --> 00:12:41,130
something crashed you might make pasta

00:12:39,000 --> 00:12:45,149
your email you may lost your your

00:12:41,130 --> 00:12:48,120
information so that's one big problem so

00:12:45,149 --> 00:12:50,940
also elect the acid property which is a

00:12:48,120 --> 00:12:55,260
basic property for a full relational

00:12:50,940 --> 00:12:57,690
database so they are doing something now

00:12:55,260 --> 00:12:59,339
moving a little bit toward a relational

00:12:57,690 --> 00:13:02,339
database as well they are providing

00:12:59,339 --> 00:13:05,820
logging they are providing replication

00:13:02,339 --> 00:13:08,899
so this kind of converge into some

00:13:05,820 --> 00:13:12,930
middle ground between the no sequel and

00:13:08,899 --> 00:13:16,040
relational database so this do want to

00:13:12,930 --> 00:13:19,519
make sure that data is there you

00:13:16,040 --> 00:13:27,070
it used found the user experience point

00:13:19,519 --> 00:13:32,050
of view so for us we see this kind of

00:13:27,070 --> 00:13:35,810
trend and we think we want to provide

00:13:32,050 --> 00:13:39,199
some best of the both work that's

00:13:35,810 --> 00:13:43,579
something that relational database can

00:13:39,199 --> 00:13:48,220
do for the text for the data Henry we

00:13:43,579 --> 00:13:53,199
can do that as well so the idea is that

00:13:48,220 --> 00:13:57,829
we have a front end of a new sequel

00:13:53,199 --> 00:14:03,550
products so it speaks no sequel protocol

00:13:57,829 --> 00:14:05,750
simple and easy and it goes around our

00:14:03,550 --> 00:14:09,199
optimizer and acquired processing

00:14:05,750 --> 00:14:11,209
directly diving to the storage apart so

00:14:09,199 --> 00:14:14,060
you fetch the data right away because

00:14:11,209 --> 00:14:17,259
those are simple queries so we don't

00:14:14,060 --> 00:14:19,730
need to pass them we know what that is

00:14:17,259 --> 00:14:22,910
for example memcache do you probably

00:14:19,730 --> 00:14:26,260
have ten commands we don't have it that

00:14:22,910 --> 00:14:30,350
doesn't have any complex query to pass

00:14:26,260 --> 00:14:33,260
so we just know that is so it goes to

00:14:30,350 --> 00:14:35,870
storage your engine right away then we

00:14:33,260 --> 00:14:42,350
provide all the best for the relational

00:14:35,870 --> 00:14:45,470
database we support the acid we have the

00:14:42,350 --> 00:14:48,500
our index on the key Collins for fast

00:14:45,470 --> 00:14:52,399
access we have application will have

00:14:48,500 --> 00:14:55,100
recovery crash safe and in the meantime

00:14:52,399 --> 00:14:57,380
it's dual dual accessible so you can

00:14:55,100 --> 00:15:00,019
access the same set of data from sequel

00:14:57,380 --> 00:15:03,980
or you can also access from the memcache

00:15:00,019 --> 00:15:07,880
d so this is a new feature that we can

00:15:03,980 --> 00:15:12,350
to avoid bullying my sequel 5.6 so this

00:15:07,880 --> 00:15:15,319
is a graph showing you that weather

00:15:12,350 --> 00:15:18,259
looks like so you have an application on

00:15:15,319 --> 00:15:20,959
top of it you can access it Jesus

00:15:18,259 --> 00:15:24,529
through the sequel or from the memcache

00:15:20,959 --> 00:15:27,709
d and the endpoint of the lower point is

00:15:24,529 --> 00:15:29,779
inaudible storage engine and we build a

00:15:27,709 --> 00:15:33,829
wrap on our functions

00:15:29,779 --> 00:15:35,569
other nodb ap is I used to be embedded

00:15:33,829 --> 00:15:38,120
in ODB I'm not sure people knows

00:15:35,569 --> 00:15:42,110
embedded in ODB it's a kind of a wrap on

00:15:38,120 --> 00:15:43,550
the our storage engine doesn't have a

00:15:42,110 --> 00:15:47,149
current processing doesn't have

00:15:43,550 --> 00:15:51,589
optimized apart but so that's a set of

00:15:47,149 --> 00:15:54,559
APR builder along the hour in ODB then

00:15:51,589 --> 00:15:59,209
on top of that we have the memcache be

00:15:54,559 --> 00:16:02,930
plugging and no debe memcache is working

00:15:59,209 --> 00:16:07,459
as a engine for that particular memcache

00:16:02,930 --> 00:16:14,120
debugging so we make a memcache itself a

00:16:07,459 --> 00:16:19,720
plug-in for my sequel so this memcache

00:16:14,120 --> 00:16:19,720
Dean can be anything yeah go ahead yeah

00:16:23,379 --> 00:16:31,009
you can install that plug-in just like

00:16:25,850 --> 00:16:33,860
it in od be plugging yeah okay so so so

00:16:31,009 --> 00:16:37,639
you think you see that again the you say

00:16:33,860 --> 00:16:40,939
how to enable this proggy that's the

00:16:37,639 --> 00:16:46,970
question okay so it's it's like a nodb

00:16:40,939 --> 00:16:50,269
mexico has this kind of command say well

00:16:46,970 --> 00:16:55,069
install a particular plug-in so even in

00:16:50,269 --> 00:16:57,410
ODB was plugging a self to DMI sequel so

00:16:55,069 --> 00:17:00,850
my suco support multiple engines used to

00:16:57,410 --> 00:17:04,880
be like a storage engines my eyes on

00:17:00,850 --> 00:17:10,100
will have this in ODB those our plugins

00:17:04,880 --> 00:17:13,370
to to my sequel so the command our show

00:17:10,100 --> 00:17:17,809
later how to use section and just say

00:17:13,370 --> 00:17:21,699
install plugging the this particular

00:17:17,809 --> 00:17:21,699
memcache the library name

00:17:25,149 --> 00:17:32,960
so this memcache d plugging can be

00:17:29,179 --> 00:17:35,840
anything and we can have different no

00:17:32,960 --> 00:17:37,820
sequel database frog and speak a

00:17:35,840 --> 00:17:41,600
different protocol so this is just an

00:17:37,820 --> 00:17:44,240
example are using in ODB api's to

00:17:41,600 --> 00:17:48,909
directly diving to storage engine and go

00:17:44,240 --> 00:17:48,909
around go bad Pisces my sequel server

00:17:50,409 --> 00:17:59,240
okay so this is a little bit more detail

00:17:54,370 --> 00:18:03,350
so issues that the libname the memcache

00:17:59,240 --> 00:18:06,889
d we call the liber memcache dsl it's a

00:18:03,350 --> 00:18:10,429
shared library and memcache d providing

00:18:06,889 --> 00:18:12,769
you also the mechanism to have a

00:18:10,429 --> 00:18:16,370
different engine because memcache d

00:18:12,769 --> 00:18:18,860
itself works it has a gig memory storage

00:18:16,370 --> 00:18:20,750
engine so it has a store in ginger but

00:18:18,860 --> 00:18:23,330
it provides you a different way to

00:18:20,750 --> 00:18:27,230
install different engines so that's

00:18:23,330 --> 00:18:30,850
that's a bridge between nodb and the

00:18:27,230 --> 00:18:33,830
memcache d called in ODB memcached eng

00:18:30,850 --> 00:18:36,169
so this to to action would did it here

00:18:33,830 --> 00:18:40,159
first thing is memcache de were made it

00:18:36,169 --> 00:18:42,590
a plug-in of my sequel so it can run as

00:18:40,159 --> 00:18:45,919
a separate thread being stored it

00:18:42,590 --> 00:18:49,879
advancing the other as in the background

00:18:45,919 --> 00:18:52,909
a surprise thread and then we make nodb

00:18:49,879 --> 00:18:57,860
memcache d to an engine of memcache d

00:18:52,909 --> 00:19:00,769
then it starts to access the nodb so

00:18:57,860 --> 00:19:02,419
there are two shared library here you

00:19:00,769 --> 00:19:05,809
don't need to worry about the in ODB

00:19:02,419 --> 00:19:07,940
engine dot so that one is installed

00:19:05,809 --> 00:19:11,440
automatically when you install the lib

00:19:07,940 --> 00:19:11,440
memcache DSO

00:19:16,780 --> 00:19:21,340
okay so that's that's the commander you

00:19:19,330 --> 00:19:23,920
were asking how are we going to install

00:19:21,340 --> 00:19:26,830
that so the commander is saying install

00:19:23,920 --> 00:19:29,860
plugin demo memcached e s own name

00:19:26,830 --> 00:19:32,560
memcached eso so the last one is the

00:19:29,860 --> 00:19:37,330
shared library would be so if you

00:19:32,560 --> 00:19:40,600
download our download our production

00:19:37,330 --> 00:19:42,880
whatever the package in the plugging

00:19:40,600 --> 00:19:47,170
directly you will see this little

00:19:42,880 --> 00:19:50,290
memcache two dollar so so just putting

00:19:47,170 --> 00:19:55,120
the plugging a directory then just issue

00:19:50,290 --> 00:19:58,710
this command of course before that if

00:19:55,120 --> 00:20:02,380
you need to config the table with some

00:19:58,710 --> 00:20:06,580
some information in in ODB memcached

00:20:02,380 --> 00:20:08,860
assistant tables so then you can start

00:20:06,580 --> 00:20:11,200
to use the memcache d is it managed to

00:20:08,860 --> 00:20:15,010
catch the director boots up your lesson

00:20:11,200 --> 00:20:18,580
a lessons on this port 211 211 is by

00:20:15,010 --> 00:20:24,120
default then you can start to store

00:20:18,580 --> 00:20:27,400
things and get things ok so before that

00:20:24,120 --> 00:20:31,450
you need to configure the memcache t2

00:20:27,400 --> 00:20:35,560
tells you what's the mapping so how this

00:20:31,450 --> 00:20:42,970
our memcache the maps to watch in 0 DB

00:20:35,560 --> 00:20:46,030
table so there are three tables in a

00:20:42,970 --> 00:20:49,950
database called in 0 DB and the score

00:20:46,030 --> 00:20:49,950
memcache yeah

00:20:54,810 --> 00:21:05,200
it's just all arms yes yes yes so you

00:21:01,870 --> 00:21:13,900
ask whether it's a single user a server

00:21:05,200 --> 00:21:18,100
port yeah so so the magic here we need

00:21:13,900 --> 00:21:20,710
to tell the memcache d2 exactly what

00:21:18,100 --> 00:21:24,180
table in maps to so there are three

00:21:20,710 --> 00:21:27,880
necessary tables we created is a script

00:21:24,180 --> 00:21:29,920
in the script session called nodb

00:21:27,880 --> 00:21:32,770
memcache the underscore config the

00:21:29,920 --> 00:21:34,990
sequel so you have the co package and

00:21:32,770 --> 00:21:39,910
you go to the scripts directory there's

00:21:34,990 --> 00:21:42,670
a sequel sequel file there just just run

00:21:39,910 --> 00:21:45,090
this sequel Phi it will automatically

00:21:42,670 --> 00:21:49,390
create a database called nodb memcache

00:21:45,090 --> 00:21:51,330
then it will create three tables the

00:21:49,390 --> 00:21:57,760
first the table called the containers

00:21:51,330 --> 00:22:00,670
the name is we give this name actually

00:21:57,760 --> 00:22:02,980
this name comes from NDB and memcache d

00:22:00,670 --> 00:22:05,770
so we want to keep everything the same

00:22:02,980 --> 00:22:09,070
so this will be another support for the

00:22:05,770 --> 00:22:11,320
NDB is the my super cluster so also

00:22:09,070 --> 00:22:13,780
memcache d is supported in my super

00:22:11,320 --> 00:22:16,120
cluster so we keep everything in sync I

00:22:13,780 --> 00:22:18,210
always have the same name so the

00:22:16,120 --> 00:22:21,960
continuous table basically tells you

00:22:18,210 --> 00:22:27,010
what's most important the table that

00:22:21,960 --> 00:22:31,120
memcache the commands work goes into so

00:22:27,010 --> 00:22:37,720
first you give him a name then tells

00:22:31,120 --> 00:22:43,000
this table schema oh sorry my computer

00:22:37,720 --> 00:22:47,770
crashes for some reason now the computer

00:22:43,000 --> 00:22:52,270
crash so maybe over here or whatever so

00:22:47,770 --> 00:22:54,810
anyway any questions so far that's let's

00:22:52,270 --> 00:22:54,810
start with

00:22:56,680 --> 00:23:02,750
yeah well I present some windows but but

00:23:00,320 --> 00:23:05,600
most of them worry yeah yeah most of

00:23:02,750 --> 00:23:08,030
time we do only next time so so yeah

00:23:05,600 --> 00:23:17,300
okay yeah it is windows run running

00:23:08,030 --> 00:23:19,550
right now yeah go ahead huh well yeah we

00:23:17,300 --> 00:23:22,160
are making slides on using windows so

00:23:19,550 --> 00:23:27,650
that's that's the only thing it's good

00:23:22,160 --> 00:23:34,600
at yeah yeah shoes why windows sucks

00:23:27,650 --> 00:23:34,600
right so okay yeah you have question

00:23:36,460 --> 00:23:46,520
yeah it is oh it is open source plugging

00:23:42,890 --> 00:23:49,370
yes it is open open source plugging so

00:23:46,520 --> 00:23:55,780
you can look at a code how we increment

00:23:49,370 --> 00:23:55,780
this and and it's all open source yes

00:24:04,410 --> 00:24:19,770
ok any other questions while waiting

00:24:07,320 --> 00:24:22,110
this yeah you can store any war

00:24:19,770 --> 00:24:26,130
basically text value so you have a

00:24:22,110 --> 00:24:29,160
character cha cha cha broth those kind

00:24:26,130 --> 00:24:30,930
of value so you can store integer of

00:24:29,160 --> 00:24:37,350
those kind you have to cover it before

00:24:30,930 --> 00:24:40,200
you store it if there is need and we can

00:24:37,350 --> 00:24:42,600
we consistently support other type but

00:24:40,200 --> 00:24:45,860
certainly right now it's a char baj

00:24:42,600 --> 00:24:45,860
housings yeah

00:24:52,700 --> 00:25:02,930
uh-huh currently well you can all have

00:24:59,270 --> 00:25:22,390
multiple memcache using multiple

00:25:02,930 --> 00:25:22,390
memcache memcache DS uh-huh yes yes yes

00:25:23,290 --> 00:25:38,330
yes yes another sir yeah yeah okay well

00:25:34,870 --> 00:25:41,960
well you can actually do that well in

00:25:38,330 --> 00:25:45,020
the the memcache d has those options

00:25:41,960 --> 00:25:48,020
right you say start how many memcache d

00:25:45,020 --> 00:25:51,020
at the beginning right those options are

00:25:48,020 --> 00:25:55,340
you need to set those options in my

00:25:51,020 --> 00:25:58,460
sequel configure options so these are my

00:25:55,340 --> 00:26:01,100
synchro configure options says a nodb

00:25:58,460 --> 00:26:05,390
memcache d and the score options you

00:26:01,100 --> 00:26:08,780
need to have this in the with the

00:26:05,390 --> 00:26:11,960
memcache the options in the mass equal

00:26:08,780 --> 00:26:15,170
config option so when you started my

00:26:11,960 --> 00:26:19,270
sequel database it gets those options

00:26:15,170 --> 00:26:23,270
and directly set to the memcache d

00:26:19,270 --> 00:26:26,750
engine will talk about the pops ooh then

00:26:23,270 --> 00:26:28,700
it will start multiple memcache d but it

00:26:26,750 --> 00:26:32,920
all direct to the same my sequel

00:26:28,700 --> 00:26:36,410
database so you need to direct those

00:26:32,920 --> 00:26:38,390
commands to actually to my sequel config

00:26:36,410 --> 00:26:41,170
options this is one my super configure

00:26:38,390 --> 00:26:41,170
option to do that

00:26:50,760 --> 00:27:00,960
okay so any other questions so far these

00:26:56,680 --> 00:27:04,750
are clear how we doing this basically we

00:27:00,960 --> 00:27:08,920
hijack one of those no sequel database

00:27:04,750 --> 00:27:11,230
become plugging of my sequel then using

00:27:08,920 --> 00:27:26,470
some callback function and start to

00:27:11,230 --> 00:27:28,780
access in lgb right right away yeah so

00:27:26,470 --> 00:27:36,280
what's the benefit of a handle of socket

00:27:28,780 --> 00:27:42,700
so yeah yeah so I think it is 11 also

00:27:36,280 --> 00:27:49,750
the graph we have the handler socket is

00:27:42,700 --> 00:27:54,280
layer okay so you see the handle AP is

00:27:49,750 --> 00:27:56,500
so this is a another Japanese some kind

00:27:54,280 --> 00:27:59,920
of company they do a handle or socket so

00:27:56,500 --> 00:28:05,400
they directly talk to the handler API in

00:27:59,920 --> 00:28:08,680
that layer so the actual ed action are

00:28:05,400 --> 00:28:11,830
similar but handle a socket that way or

00:28:08,680 --> 00:28:14,590
it's incorporating pecan as well but I

00:28:11,830 --> 00:28:19,990
was talking to them this morning it it

00:28:14,590 --> 00:28:23,080
has very messy ap is so if you want to

00:28:19,990 --> 00:28:26,130
really use handle socket a the command

00:28:23,080 --> 00:28:29,500
it's it's not as clean as memcache d

00:28:26,130 --> 00:28:32,890
it's very messy it's very hard to use

00:28:29,500 --> 00:28:35,590
you have to know a lot of my database

00:28:32,890 --> 00:28:38,020
you have to say well I use this index do

00:28:35,590 --> 00:28:41,110
this query so it's kind of a lot of

00:28:38,020 --> 00:28:44,170
instruction to tell how the it storage

00:28:41,110 --> 00:28:52,320
engine runs so that's very hard to for

00:28:44,170 --> 00:28:52,320
you that you use and also yeah

00:28:54,800 --> 00:29:00,900
hey

00:28:56,250 --> 00:29:03,510
oh well yes from some point and rocket

00:29:00,900 --> 00:29:07,020
give you the capability of more complex

00:29:03,510 --> 00:29:10,860
query like a foreign key those kind of

00:29:07,020 --> 00:29:14,520
thing so that's once one difference

00:29:10,860 --> 00:29:16,920
maybe not the memcached you cannot do

00:29:14,520 --> 00:29:19,740
those kind of complex query but we'll

00:29:16,920 --> 00:29:23,130
we'll think of ways to to a balance

00:29:19,740 --> 00:29:28,080
between a simpler command and also

00:29:23,130 --> 00:29:30,300
compact query so maybe we can extend the

00:29:28,080 --> 00:29:32,670
command for the memcache d but but

00:29:30,300 --> 00:29:34,710
that's that's difference so from the

00:29:32,670 --> 00:29:42,120
performance standpoint yeah they are

00:29:34,710 --> 00:29:45,390
similar ok so we go through this

00:29:42,120 --> 00:29:47,550
continual table quickly it tells you you

00:29:45,390 --> 00:29:51,420
you want to tell it which database

00:29:47,550 --> 00:29:55,580
database a DB scheme d be a table name

00:29:51,420 --> 00:29:59,070
and what the key valuable key columns

00:29:55,580 --> 00:30:03,840
it's mapping into and what's the value

00:29:59,070 --> 00:30:06,300
of value of columns then just flag cs6

00:30:03,840 --> 00:30:09,750
part-time construing and uniquely index

00:30:06,300 --> 00:30:12,690
those are all required by memcache d so

00:30:09,750 --> 00:30:15,240
the most important one is saying when I

00:30:12,690 --> 00:30:18,360
do memcache the operation what's what

00:30:15,240 --> 00:30:21,540
stable it goes into that's the DB name

00:30:18,360 --> 00:30:23,760
and the deep and the DB table so and

00:30:21,540 --> 00:30:27,180
what's the key key Colin what's the

00:30:23,760 --> 00:30:31,280
value column so you can put the multiple

00:30:27,180 --> 00:30:34,350
value Colin you can put a string of

00:30:31,280 --> 00:30:37,440
multiple color in this value Colin says

00:30:34,350 --> 00:30:42,710
I want to map a value to five different

00:30:37,440 --> 00:30:42,710
columns so they can separated by a comma

00:30:43,280 --> 00:30:49,500
okay so that's just repeated what I did

00:30:46,050 --> 00:30:52,860
what's just I said also you can tell

00:30:49,500 --> 00:30:56,330
what index on this key Colin you want to

00:30:52,860 --> 00:30:56,330
actually use

00:30:59,550 --> 00:31:06,760
so flags is also for memcache T&CS is a

00:31:03,970 --> 00:31:09,550
unique number identify using by the

00:31:06,760 --> 00:31:13,480
memcache d so that's also something that

00:31:09,550 --> 00:31:15,940
you need to supply or you can you can

00:31:13,480 --> 00:31:20,200
leave it empty but then I won't have

00:31:15,940 --> 00:31:23,080
Flag return okay the second table is

00:31:20,200 --> 00:31:26,170
called a cache policy cache policy

00:31:23,080 --> 00:31:28,930
basically have you say so when I have

00:31:26,170 --> 00:31:31,720
this memcache the engine it has a

00:31:28,930 --> 00:31:34,980
default engine which is the one that

00:31:31,720 --> 00:31:38,350
used about memcache d so it's a memory

00:31:34,980 --> 00:31:42,280
cache everything hashing to you memory

00:31:38,350 --> 00:31:44,320
hash table and also we support that as

00:31:42,280 --> 00:31:47,920
well so you can say well whether you

00:31:44,320 --> 00:31:50,140
want to use any ODB as a back-end or you

00:31:47,920 --> 00:31:53,320
want to use the original memcache as it

00:31:50,140 --> 00:31:57,880
is all you want to use both so you can

00:31:53,320 --> 00:32:01,060
use says it's in is a nodb only cash

00:31:57,880 --> 00:32:04,420
only or caching so the caching is saying

00:32:01,060 --> 00:32:08,250
if I get something not in the memcache

00:32:04,420 --> 00:32:12,840
the cash i can get it directly from a

00:32:08,250 --> 00:32:16,920
sequel server similar for the right i

00:32:12,840 --> 00:32:22,110
right into a memcache our right to the

00:32:16,920 --> 00:32:26,140
also to the nodb so that tells you which

00:32:22,110 --> 00:32:27,880
witch storage you want to use well

00:32:26,140 --> 00:32:30,250
configure option is give you the

00:32:27,880 --> 00:32:34,060
capability same apps that are different

00:32:30,250 --> 00:32:36,310
collins to the value so because it's key

00:32:34,060 --> 00:32:39,010
value i can map like 10 different

00:32:36,310 --> 00:32:41,670
columns to the value value part of the

00:32:39,010 --> 00:32:41,670
memcache d

00:32:45,840 --> 00:32:54,540
so how it operates so one we boot nodb

00:32:51,270 --> 00:32:58,300
when you install this plug-in the

00:32:54,540 --> 00:33:04,450
plug-in will start to buddhist memcache

00:32:58,300 --> 00:33:07,150
d as a demon then it will read a

00:33:04,450 --> 00:33:09,640
configure table we just talked about so

00:33:07,150 --> 00:33:11,740
it brings those information ings and it

00:33:09,640 --> 00:33:19,140
knows which particular table I try to

00:33:11,740 --> 00:33:23,770
map to then we'll start a transaction so

00:33:19,140 --> 00:33:26,170
this some some difference between you

00:33:23,770 --> 00:33:28,750
know DB and memcache d as we said the

00:33:26,170 --> 00:33:30,790
memcache d is non-transactional so it

00:33:28,750 --> 00:33:33,640
doesn't have the concept of transaction

00:33:30,790 --> 00:33:37,630
but for nodb we must start transaction

00:33:33,640 --> 00:33:40,270
for doing anything so we will overlay a

00:33:37,630 --> 00:33:42,820
transaction for itself but this

00:33:40,270 --> 00:33:45,370
transaction can commit to like every

00:33:42,820 --> 00:33:49,000
once a while it doesn't need to commit

00:33:45,370 --> 00:33:52,060
every operation so by default they are

00:33:49,000 --> 00:33:55,030
both one but for better performance we

00:33:52,060 --> 00:33:58,750
usually give it a very large number so

00:33:55,030 --> 00:34:01,960
when you do set set set with memcache d

00:33:58,750 --> 00:34:04,630
they may now commit every time they mean

00:34:01,960 --> 00:34:08,560
come in and come to you batch so after

00:34:04,630 --> 00:34:12,330
maybe 10,000 set you commit it then you

00:34:08,560 --> 00:34:12,330
give you a better performance yeah

00:34:20,650 --> 00:34:28,220
yes well the question is why you batch

00:34:24,800 --> 00:34:31,460
the transaction can you still read the

00:34:28,220 --> 00:34:35,750
value that before they commit right

00:34:31,460 --> 00:34:38,440
before they come in so the default we

00:34:35,750 --> 00:34:41,030
also have provided isolation level

00:34:38,440 --> 00:34:44,200
through memcache d the default is a

00:34:41,030 --> 00:34:47,420
leader really dirty so read uncommitted

00:34:44,200 --> 00:34:50,930
so if you saying I want to write

00:34:47,420 --> 00:34:52,670
something to this the other connection

00:34:50,930 --> 00:34:55,640
come seeing is to can read it because

00:34:52,670 --> 00:34:58,430
it's the default transaction level is

00:34:55,640 --> 00:35:00,680
really dirty so you like something it's

00:34:58,430 --> 00:35:05,530
not committed the other guy can still

00:35:00,680 --> 00:35:05,530
read it yeah

00:35:10,270 --> 00:35:21,910
ah well no that's something that we

00:35:17,530 --> 00:35:24,610
didn't so the idea there was a

00:35:21,910 --> 00:35:29,020
suggestion so i will have a background

00:35:24,610 --> 00:35:32,680
thread learning everyone's while we will

00:35:29,020 --> 00:35:34,840
commit it so you don't have like it you

00:35:32,680 --> 00:35:37,450
have must have I really want to commit

00:35:34,840 --> 00:35:41,680
it but I have to wait until 10,000

00:35:37,450 --> 00:35:43,240
command so that's kind of someone want

00:35:41,680 --> 00:35:45,400
to go around it they already some

00:35:43,240 --> 00:35:49,000
requests to go around this so Curren is

00:35:45,400 --> 00:35:50,710
thinking is that we have to have some

00:35:49,000 --> 00:35:53,130
background thread come into every once

00:35:50,710 --> 00:35:56,620
while like every 1 second test thinking

00:35:53,130 --> 00:35:59,410
we are hesitating to extend memcache d

00:35:56,620 --> 00:36:03,460
command there's some approval or

00:35:59,410 --> 00:36:06,300
whatever we need to go through but that

00:36:03,460 --> 00:36:08,950
was one option we're thinking about

00:36:06,300 --> 00:36:13,570
extending but apparently the process is

00:36:08,950 --> 00:36:16,830
longer so it's fairly simple to actually

00:36:13,570 --> 00:36:21,610
change the addict amounts to memcache d

00:36:16,830 --> 00:36:27,460
but if it's a lot of requests then we

00:36:21,610 --> 00:36:28,900
probably can't do that ok so that's the

00:36:27,460 --> 00:36:33,640
for the transaction batching the

00:36:28,900 --> 00:36:36,610
transaction ok so that's a list of the

00:36:33,640 --> 00:36:40,060
year actually the memcache d commands

00:36:36,610 --> 00:36:44,220
and how it maps to in ODB actions so

00:36:40,060 --> 00:36:48,280
most of them get is actually that value

00:36:44,220 --> 00:36:51,310
so it's become a search a select from

00:36:48,280 --> 00:36:53,760
the analogy so get mikey mikey is the

00:36:51,310 --> 00:36:58,690
key returns the value whatever

00:36:53,760 --> 00:37:01,170
corresponding to mikey so set set is set

00:36:58,690 --> 00:37:07,300
a is actually insert so you enjoyed a

00:37:01,170 --> 00:37:10,000
value map to key mikey the last number

00:37:07,300 --> 00:37:15,730
five is actually saying how long the

00:37:10,000 --> 00:37:20,260
actually idea that string will be so

00:37:15,730 --> 00:37:23,530
it's 55 character lens then you type you

00:37:20,260 --> 00:37:29,070
typing your value then will be stored

00:37:23,530 --> 00:37:32,260
the 60 is a flag used for whatever

00:37:29,070 --> 00:37:35,020
neither you want it doesn't well define

00:37:32,260 --> 00:37:40,990
but you want a store like some values

00:37:35,020 --> 00:37:43,870
there will be there and add add is added

00:37:40,990 --> 00:37:47,320
a new key if it's not there if it's not

00:37:43,870 --> 00:37:50,710
there then we add this new key the place

00:37:47,320 --> 00:37:54,040
is a replace existing keys so that's

00:37:50,710 --> 00:37:58,270
math to an update a panda is append data

00:37:54,040 --> 00:38:01,030
to existing key that's an update pre

00:37:58,270 --> 00:38:03,700
panda is also same thing prepend it's

00:38:01,030 --> 00:38:07,030
also update then they have increment and

00:38:03,700 --> 00:38:08,890
decrement then it goes to delete delete

00:38:07,030 --> 00:38:11,110
is delete the key were that we have so

00:38:08,890 --> 00:38:13,450
it goes to map to delete and it also has

00:38:11,110 --> 00:38:15,910
a command color flush all basically

00:38:13,450 --> 00:38:18,010
flush everything in memory it's mapped

00:38:15,910 --> 00:38:21,820
to us to a truncate so we truncated

00:38:18,010 --> 00:38:29,620
table so chunk it is the only addl it

00:38:21,820 --> 00:38:34,060
has ours our DM else so you can have

00:38:29,620 --> 00:38:35,770
multiple tables in memcache d mapping so

00:38:34,060 --> 00:38:39,790
in the continuous table we'll just talk

00:38:35,770 --> 00:38:42,220
about you can have a lot of table setup

00:38:39,790 --> 00:38:44,380
then when you want to switch to

00:38:42,220 --> 00:38:46,830
different table just use these at a

00:38:44,380 --> 00:38:50,020
single say I want to switch a new table

00:38:46,830 --> 00:38:55,450
I want to query a new table instead of

00:38:50,020 --> 00:38:58,270
this table so you only need to specify

00:38:55,450 --> 00:39:02,830
that once then are disconnecting the

00:38:58,270 --> 00:39:06,040
mapping switch to a different table so

00:39:02,830 --> 00:39:10,870
we also supported beam log the only

00:39:06,040 --> 00:39:15,220
thing is that bing logger years is a

00:39:10,870 --> 00:39:16,660
handler its interfaces in handler so we

00:39:15,220 --> 00:39:20,110
need to call back to the handle

00:39:16,660 --> 00:39:21,880
interface to to do that so that's one I

00:39:20,110 --> 00:39:25,180
think we want to probably looking at

00:39:21,880 --> 00:39:27,460
improve it because it's an overhead to

00:39:25,180 --> 00:39:29,950
call back to the hangar interface to to

00:39:27,460 --> 00:39:32,290
access pin lock so essentially anything

00:39:29,950 --> 00:39:34,990
value doing the memcache d it will be

00:39:32,290 --> 00:39:38,790
locked so you can bring up into two

00:39:34,990 --> 00:39:38,790
different a different server

00:39:40,910 --> 00:39:47,760
so that's some detail sayings how we

00:39:44,160 --> 00:39:49,680
actually you call back to the handler we

00:39:47,760 --> 00:39:53,160
need to look at or create a fake a

00:39:49,680 --> 00:39:58,950
thread THD instance then we call back

00:39:53,160 --> 00:40:03,240
use the my sequel table structure so if

00:39:58,950 --> 00:40:04,769
you just look at how to use it

00:40:03,240 --> 00:40:10,200
standpoint don't need to know those

00:40:04,769 --> 00:40:15,150
details how we implement it so we only

00:40:10,200 --> 00:40:18,210
supported role-based are logging okay so

00:40:15,150 --> 00:40:20,430
there is a talk seeing this is a worry

00:40:18,210 --> 00:40:23,519
saying well I open a door for an

00:40:20,430 --> 00:40:29,700
unsecured connection to my sequel server

00:40:23,519 --> 00:40:31,890
so all the sequel interface or the

00:40:29,700 --> 00:40:34,859
sequel queries you need to have possible

00:40:31,890 --> 00:40:37,200
or they would have set up so how about

00:40:34,859 --> 00:40:40,349
we have this memcache these things don't

00:40:37,200 --> 00:40:44,039
have any kind of security so will that

00:40:40,349 --> 00:40:49,920
be actually messing up the database you

00:40:44,039 --> 00:40:52,109
have so that's two to set up answer on

00:40:49,920 --> 00:40:54,630
that one thing is that we have this

00:40:52,109 --> 00:40:57,569
restriction on the table you can map to

00:40:54,630 --> 00:41:00,990
so whoever access through the memcache t

00:40:57,569 --> 00:41:02,940
can only access those tables so if the

00:41:00,990 --> 00:41:05,519
DBA says just like we talked about

00:41:02,940 --> 00:41:07,650
continuous table they didn't put this

00:41:05,519 --> 00:41:11,190
particular table in that continuous you

00:41:07,650 --> 00:41:14,400
won't be able to access it so that's one

00:41:11,190 --> 00:41:18,269
one potted so it has limited access to

00:41:14,400 --> 00:41:21,900
memcache d the second is that we also

00:41:18,269 --> 00:41:24,299
support ssas ASL it's simple

00:41:21,900 --> 00:41:27,240
authentication and secure layer so

00:41:24,299 --> 00:41:31,410
that's also building memcache d as well

00:41:27,240 --> 00:41:37,200
as seeing our memcache d plugin so if

00:41:31,410 --> 00:41:39,359
you have this sasl in a bowl at this

00:41:37,200 --> 00:41:43,200
library basically it provides

00:41:39,359 --> 00:41:45,619
authentication support so it will give

00:41:43,200 --> 00:41:48,470
you some kind of a security support

00:41:45,619 --> 00:41:50,780
through the memcache declined

00:41:48,470 --> 00:41:52,640
so the only thing about this is the

00:41:50,780 --> 00:41:56,480
memcache decline to need to have this

00:41:52,640 --> 00:41:59,300
sasl support as well then not many SAS

00:41:56,480 --> 00:42:04,580
support a client right now but let's

00:41:59,300 --> 00:42:10,930
give you the option so that's the last

00:42:04,580 --> 00:42:14,090
we just give some performance overview

00:42:10,930 --> 00:42:17,200
that's comparison hand-roll socket on

00:42:14,090 --> 00:42:21,440
the right that's down by you should nori

00:42:17,200 --> 00:42:25,160
he's the one that talked about Henry

00:42:21,440 --> 00:42:27,859
Osaka first one has bring up this no

00:42:25,160 --> 00:42:33,770
sequel you memcache no sequel with my

00:42:27,859 --> 00:42:40,849
sequel so if we just look at it fairly

00:42:33,770 --> 00:42:42,500
good result so it goes to a lot of

00:42:40,849 --> 00:42:46,540
clients you can see is three times

00:42:42,500 --> 00:42:49,880
better than just equal in terms of reads

00:42:46,540 --> 00:42:54,410
right with being Lago we have some

00:42:49,880 --> 00:42:58,400
problem to solve so that we don't think

00:42:54,410 --> 00:43:01,099
it's any of any problem but we are still

00:42:58,400 --> 00:43:03,680
doing performance enhancement so how do

00:43:01,099 --> 00:43:06,140
you see a lot better number after we

00:43:03,680 --> 00:43:11,380
down through those performance studies

00:43:06,140 --> 00:43:11,380
and the enhancement yeah

00:43:14,630 --> 00:43:27,289
yes so they have native support because

00:43:18,170 --> 00:43:29,990
the interface is in angelo api ok so i

00:43:27,289 --> 00:43:35,839
have one slides mentioning the mmm cash

00:43:29,990 --> 00:43:40,190
seeing the mysql cluster the NDB server

00:43:35,839 --> 00:43:45,109
so if you look at it the cluster can

00:43:40,190 --> 00:43:49,400
talk to the memcache tea as well just

00:43:45,109 --> 00:43:54,049
similar to win ODB I has this API

00:43:49,400 --> 00:43:57,349
building and it's fairly straightforward

00:43:54,049 --> 00:44:00,410
when you have because the memcache tu

00:43:57,349 --> 00:44:03,619
was distributed so it's kind of a very

00:44:00,410 --> 00:44:05,630
good fit with this my sequel cluster

00:44:03,619 --> 00:44:08,480
because my super cluster is distributed

00:44:05,630 --> 00:44:11,450
as well so it's it's a good thing that

00:44:08,480 --> 00:44:14,839
you can have both distributed meet

00:44:11,450 --> 00:44:23,869
together put together and you can just

00:44:14,839 --> 00:44:27,230
starting to get a benefit of it ok so

00:44:23,869 --> 00:44:30,890
that's a quick summary just summarize

00:44:27,230 --> 00:44:33,740
the our effort here I'm putting a no

00:44:30,890 --> 00:44:38,750
sequel into my sequel so it gives you

00:44:33,740 --> 00:44:40,880
just let's take home a point that we can

00:44:38,750 --> 00:44:44,170
skip the optimizer query processing yeah

00:44:40,880 --> 00:44:44,170
your question

00:44:48,740 --> 00:44:54,750
the question is does the nodb memcache

00:44:51,900 --> 00:44:57,630
the offer expression the short answer is

00:44:54,750 --> 00:45:03,410
now not know we don't offer expression

00:44:57,630 --> 00:45:03,410
so we don't support complex query

00:45:04,370 --> 00:45:12,690
exploration yes your exploration yes you

00:45:08,400 --> 00:45:15,420
can spy a specified expert in time but

00:45:12,690 --> 00:45:18,600
actually we don't actually delete it

00:45:15,420 --> 00:45:21,540
we'll just have a criteria saying well

00:45:18,600 --> 00:45:24,260
from the time it puts seeing and the

00:45:21,540 --> 00:45:28,290
current time we'll compare it if it's

00:45:24,260 --> 00:45:35,580
exceeded exploration then then we won't

00:45:28,290 --> 00:45:38,280
return that as a result well we these

00:45:35,580 --> 00:45:40,700
are planning of this a backgrounds flood

00:45:38,280 --> 00:45:42,870
going to run this and all see all those

00:45:40,700 --> 00:45:47,340
expanded roles we're going to delete it

00:45:42,870 --> 00:45:50,130
in the background yeah we're going to

00:45:47,340 --> 00:45:58,140
it's not there yet but it's going to be

00:45:50,130 --> 00:46:01,800
there yes future future yeah you

00:45:58,140 --> 00:46:05,400
currently know but we're going to a pas

00:46:01,800 --> 00:46:09,720
de ba yeah the question is whether those

00:46:05,400 --> 00:46:13,230
expired roles whatever get deleted so

00:46:09,720 --> 00:46:16,470
current rings implementation don't

00:46:13,230 --> 00:46:20,490
delete them you can do that through

00:46:16,470 --> 00:46:22,350
sequel that's the one go-round currently

00:46:20,490 --> 00:46:24,810
you offer to you you just do a sequel

00:46:22,350 --> 00:46:26,610
say delete the web expiration longer

00:46:24,810 --> 00:46:29,040
than this number but we actually store

00:46:26,610 --> 00:46:31,620
their singer you know Colin so you know

00:46:29,040 --> 00:46:35,190
what time they're supposed to expire so

00:46:31,620 --> 00:46:40,380
I give you a numerical number there says

00:46:35,190 --> 00:46:42,540
this is a second from the 1971 it's

00:46:40,380 --> 00:46:44,910
going to expire so you can delete it

00:46:42,540 --> 00:46:51,150
from the seeker layer say delete all the

00:46:44,910 --> 00:46:52,680
rows larger than this so but eventually

00:46:51,150 --> 00:46:56,840
we're going to have a background strata

00:46:52,680 --> 00:46:56,840
doing that automatically for you

00:46:57,640 --> 00:47:06,950
okay so so then that's the list of the

00:47:04,130 --> 00:47:09,619
benefits we have and give you persistent

00:47:06,950 --> 00:47:11,900
storage and have a simple command it

00:47:09,619 --> 00:47:17,030
goes give you faster access to the data

00:47:11,900 --> 00:47:23,230
and also the in this case but Excel for

00:47:17,030 --> 00:47:25,849
Excel behave like a memory store so the

00:47:23,230 --> 00:47:27,319
nodb buffer would become a memory story

00:47:25,849 --> 00:47:29,240
if you everything you can fit in the

00:47:27,319 --> 00:47:31,010
memory it looks like it's just an

00:47:29,240 --> 00:47:34,280
in-memory database just like a memcache

00:47:31,010 --> 00:47:38,990
d so it provides almost similar

00:47:34,280 --> 00:47:43,010
performance as a memcache to yourself so

00:47:38,990 --> 00:47:45,319
that's my presentation so yeah well they

00:47:43,010 --> 00:47:49,059
have so there are some broad posts that

00:47:45,319 --> 00:47:53,569
we plotted on the y no debe com Brock's

00:47:49,059 --> 00:47:55,400
dyno tv.com tells almost repeat all why

00:47:53,569 --> 00:47:59,300
would I said here how tells you

00:47:55,400 --> 00:48:02,990
step-by-step how to use it so we'll be

00:47:59,300 --> 00:48:06,109
in five dot six turn turn we have it

00:48:02,990 --> 00:48:10,460
available in lab release so it will be

00:48:06,109 --> 00:48:13,010
released in five six all right so that's

00:48:10,460 --> 00:48:19,849
for my presentation any more questions

00:48:13,010 --> 00:48:25,099
and it's it's kind of a temp so you guys

00:48:19,849 --> 00:48:29,270
can give us any suggestion for example

00:48:25,099 --> 00:48:33,440
this one talk about whether one more

00:48:29,270 --> 00:48:37,010
complex query to be accessible by pasta

00:48:33,440 --> 00:48:40,490
optimizer so that's something also JSON

00:48:37,010 --> 00:48:44,680
right just some we can't you support

00:48:40,490 --> 00:48:44,680
that as well so yeah

00:49:03,390 --> 00:49:09,220
so I need to understand your question

00:49:07,540 --> 00:49:12,700
you're saying that you for the

00:49:09,220 --> 00:49:14,740
transaction part ok so the for the

00:49:12,700 --> 00:49:19,090
transaction party you can some kind of

00:49:14,740 --> 00:49:26,350
signal saying committed transaction how

00:49:19,090 --> 00:49:28,930
we do that from the memcache the side ok

00:49:26,350 --> 00:49:31,450
yeah yeah yeah yeah so I think we can

00:49:28,930 --> 00:49:34,630
yeah it's a good idea we can actually do

00:49:31,450 --> 00:49:37,000
the flag part maybe we have a special

00:49:34,630 --> 00:49:42,240
number saying well there's a special

00:49:37,000 --> 00:49:42,240
number that tells me to to commit it

00:49:47,350 --> 00:49:52,670
okay good yeah yeah that's something

00:49:50,750 --> 00:49:56,620
that it just like always how I switch

00:49:52,670 --> 00:49:59,330
table yes that's a good good good point

00:49:56,620 --> 00:50:05,510
although we'll do that just like you

00:49:59,330 --> 00:50:10,340
said that's yes so this is something

00:50:05,510 --> 00:50:12,380
that when you've always think memcached

00:50:10,340 --> 00:50:13,940
is non-transactional say that when it

00:50:12,380 --> 00:50:16,700
talks transaction it doesn't make sense

00:50:13,940 --> 00:50:21,020
to memcache to yourself so where to kind

00:50:16,700 --> 00:50:24,230
of compromise between you two how often

00:50:21,020 --> 00:50:29,030
get trying to commit and also what do

00:50:24,230 --> 00:50:32,030
you mean from the isolation level so if

00:50:29,030 --> 00:50:34,310
you have a large batch of the

00:50:32,030 --> 00:50:36,980
transaction some time from a single

00:50:34,310 --> 00:50:38,870
standpoint if it doesn't read dirty it

00:50:36,980 --> 00:50:42,110
really committed it won't see them so

00:50:38,870 --> 00:50:43,910
people will say well I put something

00:50:42,110 --> 00:50:47,090
from em touch to you I don't see it from

00:50:43,910 --> 00:50:49,700
the sequel a sequel side because the

00:50:47,090 --> 00:50:52,280
dispatch thing that's why we said it by

00:50:49,700 --> 00:50:53,990
D for the 21 even though it's not good

00:50:52,280 --> 00:50:58,790
at it from a performance standpoint

00:50:53,990 --> 00:51:01,790
because you're committing every exert

00:50:58,790 --> 00:51:04,220
every set but you can adjust it to a

00:51:01,790 --> 00:51:06,170
large number then you be aware from the

00:51:04,220 --> 00:51:08,660
sea copilot use you need to set our

00:51:06,170 --> 00:51:11,060
solution level 2 leader li literally

00:51:08,660 --> 00:51:16,490
read uncommitted then you will see the

00:51:11,060 --> 00:51:22,000
data from and catch design so that says

00:51:16,490 --> 00:51:22,000
that's any more question yeah

00:51:22,940 --> 00:51:30,330
you say Larry arcing is a I never saw

00:51:28,080 --> 00:51:32,940
him so someone saw I mean the elevator

00:51:30,330 --> 00:51:38,220
but I never saw him I can't come any

00:51:32,940 --> 00:51:43,010
further because that's that's I think

00:51:38,220 --> 00:51:43,010
the coding is still running right yeah

00:51:43,640 --> 00:51:51,290
yeah yeah stop there okay thank you

00:52:23,830 --> 00:52:25,890
you

00:52:29,060 --> 00:52:33,870
when we created asterisk over a decade

00:52:31,800 --> 00:52:36,090
ago we could not have imagined that

00:52:33,870 --> 00:52:38,310
asterisk would not only become the most

00:52:36,090 --> 00:52:40,440
widely adopted open source communication

00:52:38,310 --> 00:52:42,480
software on the planet but that it would

00:52:40,440 --> 00:52:45,000
impact the entire industry in the way

00:52:42,480 --> 00:52:46,980
that it has today asterisk has found its

00:52:45,000 --> 00:52:49,620
way in the more than 170 countries and

00:52:46,980 --> 00:52:51,570
virtually every fortune 1000 company the

00:52:49,620 --> 00:52:53,670
success of asterisk has enabled a

00:52:51,570 --> 00:52:55,050
transition of power from the hands of

00:52:53,670 --> 00:52:57,330
the traditional proprietary phone

00:52:55,050 --> 00:52:59,730
vendors into the hands of the users and

00:52:57,330 --> 00:53:01,680
administrators of phone systems using

00:52:59,730 --> 00:53:02,910
this power our customers have created

00:53:01,680 --> 00:53:04,830
all sorts of business changing

00:53:02,910 --> 00:53:06,690
applications from small office phone

00:53:04,830 --> 00:53:09,210
systems to mission-critical call centres

00:53:06,690 --> 00:53:10,800
to international carrier networks in

00:53:09,210 --> 00:53:12,600
fact there's even an entire country

00:53:10,800 --> 00:53:15,210
those communications infrastructure runs

00:53:12,600 --> 00:53:17,130
on esters the gym has always been about

00:53:15,210 --> 00:53:18,840
creating technology that expands

00:53:17,130 --> 00:53:21,000
communications capabilities in ways that

00:53:18,840 --> 00:53:22,200
we could never have imagined and that's

00:53:21,000 --> 00:53:24,960
part of what's game-changing about

00:53:22,200 --> 00:53:27,300
Digium today we're doing it again this

00:53:24,960 --> 00:53:29,370
time by introducing a new family of HD

00:53:27,300 --> 00:53:31,500
IP phones that extends control of the

00:53:29,370 --> 00:53:33,270
user all the way to the desktop the

00:53:31,500 --> 00:53:34,980
launch of these new products represents

00:53:33,270 --> 00:53:37,080
the next phase indigenous history of

00:53:34,980 --> 00:53:39,480
innovation these are the first and only

00:53:37,080 --> 00:53:41,190
IP phones designed to fully leverage the

00:53:39,480 --> 00:53:42,870
power of esters when we first discussed

00:53:41,190 --> 00:53:44,760
our expectations for building a family

00:53:42,870 --> 00:53:46,920
of phones for use with asterisk our

00:53:44,760 --> 00:53:48,660
requirements were pretty simple we asked

00:53:46,920 --> 00:53:50,280
the team to build the phones such that

00:53:48,660 --> 00:53:52,500
they were easy to install integrate

00:53:50,280 --> 00:53:54,330
provision and use I think you'll soon

00:53:52,500 --> 00:53:56,910
agree our engineers have delivered on

00:53:54,330 --> 00:53:58,530
that goal user feedback is validating

00:53:56,910 --> 00:54:00,660
that when it comes to operation with

00:53:58,530 --> 00:54:03,060
astro space systems including our own

00:54:00,660 --> 00:54:05,640
switchvox based product these are the

00:54:03,060 --> 00:54:06,960
easiest to use best integrated most

00:54:05,640 --> 00:54:09,540
interoperable products on the market

00:54:06,960 --> 00:54:11,520
today the Digium family of phones will

00:54:09,540 --> 00:54:13,590
initially include three IP des hommes

00:54:11,520 --> 00:54:15,540
uniquely designed to complement any

00:54:13,590 --> 00:54:17,400
asterisk or switch box based solution

00:54:15,540 --> 00:54:20,070
these phones are different for a number

00:54:17,400 --> 00:54:22,710
of reasons first there is clue sively

00:54:20,070 --> 00:54:24,150
designed for use with esters secondly

00:54:22,710 --> 00:54:25,760
we've made it really easy to

00:54:24,150 --> 00:54:28,140
autodiscover and provision the phones

00:54:25,760 --> 00:54:29,850
next we've made it easy for the phones

00:54:28,140 --> 00:54:31,780
to access information inside of

00:54:29,850 --> 00:54:33,780
asterisks allowing tight coupling

00:54:31,780 --> 00:54:35,770
between an application and the phone

00:54:33,780 --> 00:54:37,930
additionally we've created an

00:54:35,770 --> 00:54:40,060
applications engineer that allows users

00:54:37,930 --> 00:54:43,270
and developers to create and run their

00:54:40,060 --> 00:54:45,040
own apps on the phone and finally we've

00:54:43,270 --> 00:54:46,990
done all of this at a very compelling

00:54:45,040 --> 00:54:48,670
price point at Digium we're always

00:54:46,990 --> 00:54:50,770
thinking of ways to give our customers

00:54:48,670 --> 00:54:53,350
the best value in business phone systems

00:54:50,770 --> 00:54:54,910
and also give them the power to create

00:54:53,350 --> 00:54:57,040
their own solutions or any

00:54:54,910 --> 00:54:58,780
communications challenge well continue

00:54:57,040 --> 00:55:00,220
to push the boundaries not only to make

00:54:58,780 --> 00:55:02,260
Astros cooler bastard more

00:55:00,220 --> 00:55:03,880
technologically feature-rich but to make

00:55:02,260 --> 00:55:06,340
asterisk and web communications even

00:55:03,880 --> 00:55:10,050
easier and together we'll change the way

00:55:06,340 --> 00:55:10,050
the world communicates again

00:55:20,449 --> 00:55:27,269
how's that sigh every way this is the

00:55:24,059 --> 00:55:29,459
way to better utilize all your resources

00:55:27,269 --> 00:55:32,909
and it makes managing all your resources

00:55:29,459 --> 00:55:36,739
pretty easy all of the innovation is

00:55:32,909 --> 00:55:40,229
happening in open source the

00:55:36,739 --> 00:55:42,059
collaborative nature and of the you know

00:55:40,229 --> 00:55:44,159
of the community and the speed at which

00:55:42,059 --> 00:55:46,140
these are these you know these these

00:55:44,159 --> 00:55:48,419
deficiencies these bugs are getting

00:55:46,140 --> 00:55:51,299
discovered and then fixed is it I think

00:55:48,419 --> 00:55:54,299
that really shows the power of the of

00:55:51,299 --> 00:55:56,749
the open source community it is global

00:55:54,299 --> 00:56:00,299
and it's definitely because of the users

00:55:56,749 --> 00:56:06,269
community people are extremely friendly

00:56:00,299 --> 00:56:08,009
and always ready to help if you go on

00:56:06,269 --> 00:56:10,199
tire see any day you'll see these guys

00:56:08,009 --> 00:56:12,839
helping each other out and they're all

00:56:10,199 --> 00:56:14,549
doing it like in a selfless manner the

00:56:12,839 --> 00:56:17,539
product is transparent for everyone

00:56:14,549 --> 00:56:20,729
everyone can look at the code base

00:56:17,539 --> 00:56:22,969
everyone can see how cloud dark is being

00:56:20,729 --> 00:56:28,469
built nothing nothing is proprietary

00:56:22,969 --> 00:56:31,139
everything is open in many ways it's

00:56:28,469 --> 00:56:35,549
absolutely vital to the the ongoing

00:56:31,139 --> 00:56:39,749
health cloudstack the most exciting

00:56:35,549 --> 00:56:42,599
event in recent memory for me was our

00:56:39,749 --> 00:56:45,239
first developer boot camp

00:56:42,599 --> 00:56:47,880
and our call gay people adding maybe two

00:56:45,239 --> 00:56:51,839
weeks notice to come attend I was

00:56:47,880 --> 00:56:56,009
expecting 25 or 30 people so we ended up

00:56:51,839 --> 00:56:58,859
with 87 people and had to go get more

00:56:56,009 --> 00:57:01,380
chairs into the room twice everything

00:56:58,859 --> 00:57:04,650
within cloud computing is commodity and

00:57:01,380 --> 00:57:07,710
is open source and so I don't think that

00:57:04,650 --> 00:57:09,450
you will you'll see anywhere where open

00:57:07,710 --> 00:57:12,479
source is not pervasive in cloud

00:57:09,450 --> 00:57:15,029
computing and so i think it's i think

00:57:12,479 --> 00:57:16,559
it's an assumption i think when you talk

00:57:15,029 --> 00:57:17,670
about cloud computing you're really

00:57:16,559 --> 00:57:23,220
talking about open source cloud

00:57:17,670 --> 00:57:26,249
computing cloud sac is a robust solution

00:57:23,220 --> 00:57:28,410
for large deployments you'll have dozens

00:57:26,249 --> 00:57:32,700
of data centers and thousands of servers

00:57:28,410 --> 00:57:35,339
in each data center is these hardware is

00:57:32,700 --> 00:57:38,849
going to fail and CloudStack is designed

00:57:35,339 --> 00:57:41,549
to handle number one that mass scale

00:57:38,849 --> 00:57:44,700
number two it's designed to handle the

00:57:41,549 --> 00:57:47,249
failure that inevitably happens in large

00:57:44,700 --> 00:57:51,779
deployments we started working on pod

00:57:47,249 --> 00:57:55,049
tech over four years ago and it was the

00:57:51,779 --> 00:57:56,819
original set of people working on it had

00:57:55,049 --> 00:58:00,930
a background of delivering software

00:57:56,819 --> 00:58:05,160
telcos and service providers lots of QA

00:58:00,930 --> 00:58:08,789
lots of users actually using it high

00:58:05,160 --> 00:58:11,849
availability is the key feature multiple

00:58:08,789 --> 00:58:13,859
hypervisors support different network

00:58:11,849 --> 00:58:16,559
models you can pick up whatever suits

00:58:13,859 --> 00:58:18,809
you better while step management server

00:58:16,559 --> 00:58:22,499
can be deployed in different physical

00:58:18,809 --> 00:58:24,150
machines it definitely has a huge

00:58:22,499 --> 00:58:29,160
footprint it's being deployed everywhere

00:58:24,150 --> 00:58:31,739
there's a major movie studio that they

00:58:29,160 --> 00:58:35,039
were using cloudstack they were using it

00:58:31,739 --> 00:58:37,019
to transcode video and i thought that

00:58:35,039 --> 00:58:38,670
was terribly fascinating what i found

00:58:37,019 --> 00:58:41,940
more fascinating is what they did during

00:58:38,670 --> 00:58:44,700
lunch where they would spin up you know

00:58:41,940 --> 00:58:45,930
50 or 60 game servers then as soon as

00:58:44,700 --> 00:58:48,000
lunch was over they would destroy

00:58:45,930 --> 00:58:52,140
the instances and go back to doing real

00:58:48,000 --> 00:58:53,460
work CloudStack is vast it touches so

00:58:52,140 --> 00:58:55,559
many different aspects and there's no

00:58:53,460 --> 00:58:57,930
one person that's kind of like a master

00:58:55,559 --> 00:59:02,010
of all those realms I think cloudstack

00:58:57,930 --> 00:59:04,260
as a project is going to be one of the

00:59:02,010 --> 00:59:08,309
leaders simply because it's some of the

00:59:04,260 --> 00:59:13,740
most feature folan and and robust

00:59:08,309 --> 00:59:16,670
platforms out they were Adam senior

00:59:13,740 --> 00:59:16,670
living through the clouds dag

00:59:26,060 --> 00:59:28,120

YouTube URL: https://www.youtube.com/watch?v=eG-0TiiHlEo


