Title: 2012 SouthEast LinuxFest - MySQL Training - Max Mether - MySQL Cluster
Publication date: 2013-08-28
Playlist: 2012 SouthEast LinuxFest - MySQL Training - Advanced
Description: 
	2012 SouthEast LinuxFest
Advanced MySQL Training
Max Mether
MySQL Cluster - When To Use And When Not
Captions: 
	00:00:00,000 --> 00:00:05,310
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,310 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:17,609
more information about the southeast

00:00:12,090 --> 00:00:19,439
linux fest visit WWDC linux pc org the

00:00:17,609 --> 00:00:22,320
southeast linux fest would like to thank

00:00:19,439 --> 00:00:26,090
the following diamond sponsors in 2012

00:00:22,320 --> 00:00:26,090
for helping make these videos possible

00:00:26,810 --> 00:00:33,059
hello everyone so first of all this is

00:00:30,330 --> 00:00:35,640
about mysql cluster there's been a

00:00:33,059 --> 00:00:38,879
change in the schedule so anyone looking

00:00:35,640 --> 00:00:40,649
for I don't even know what I'm replacing

00:00:38,879 --> 00:00:46,559
but anyone looking for something else

00:00:40,649 --> 00:00:47,760
this is not the place no one is leaving

00:00:46,559 --> 00:00:51,090
all right so I'm going to talk about

00:00:47,760 --> 00:00:54,180
mysql cluster a bit the details kind of

00:00:51,090 --> 00:00:57,750
about the the architecture behind

00:00:54,180 --> 00:00:59,579
cluster what basically what goes on how

00:00:57,750 --> 00:01:01,559
cluster is well what's the basic

00:00:59,579 --> 00:01:03,059
architecture and also what goes on a bit

00:01:01,559 --> 00:01:06,420
behind the scenes because most of what

00:01:03,059 --> 00:01:08,369
happens inside a cluster is completely

00:01:06,420 --> 00:01:10,650
transparent to the end user so you don't

00:01:08,369 --> 00:01:13,020
know what's going on behind the scenes

00:01:10,650 --> 00:01:14,250
and here I'll talk about what actually

00:01:13,020 --> 00:01:17,040
goes on behind the scenes so you'll get

00:01:14,250 --> 00:01:19,830
a deeper insight into into the

00:01:17,040 --> 00:01:22,770
architecture and well the title is when

00:01:19,830 --> 00:01:24,439
to use and when not to but it kind of

00:01:22,770 --> 00:01:30,900
threw understanding the architecture

00:01:24,439 --> 00:01:33,259
that you'll get that understanding and

00:01:30,900 --> 00:01:36,450
we're a small group here so feel free to

00:01:33,259 --> 00:01:42,509
ask questions at any point in time and

00:01:36,450 --> 00:01:46,380
i'll try to answer they are not

00:01:42,509 --> 00:01:49,710
available yet but they will be as if

00:01:46,380 --> 00:01:51,060
someone asks me for those i mean if the

00:01:49,710 --> 00:01:53,369
organizers asked for him I mean I

00:01:51,060 --> 00:01:56,939
haven't sent them anywhere yet so they

00:01:53,369 --> 00:01:58,030
should be available all right so let's

00:01:56,939 --> 00:02:01,170
start

00:01:58,030 --> 00:02:01,170
the first slide

00:02:05,680 --> 00:02:11,190
I got anything here either that's not a

00:02:08,979 --> 00:02:11,190
good sign

00:02:28,750 --> 00:02:34,500
but

00:02:30,960 --> 00:02:37,770
so first of all has anyone here used

00:02:34,500 --> 00:02:41,640
cluster before my so cluster before no

00:02:37,770 --> 00:02:45,510
one all right that's that's good that's

00:02:41,640 --> 00:02:49,200
good well who uses mysql before who has

00:02:45,510 --> 00:02:52,200
used MySQL before okay so number one

00:02:49,200 --> 00:02:53,940
thing mysql cluster is completely

00:02:52,200 --> 00:02:57,330
different from mysql it's not the same

00:02:53,940 --> 00:02:59,100
product so the name is in a way a bit

00:02:57,330 --> 00:03:01,710
misleading because it's not a cluster of

00:02:59,100 --> 00:03:04,950
mysql servers it's a different product

00:03:01,710 --> 00:03:07,230
it it's it uses mysql as the front end

00:03:04,950 --> 00:03:09,480
but it's implemented as a storage engine

00:03:07,230 --> 00:03:10,920
on the back end which means that for

00:03:09,480 --> 00:03:12,690
example if you're using in the DB or

00:03:10,920 --> 00:03:15,630
something like that you will have to

00:03:12,690 --> 00:03:17,880
migrate to use mysql cluster you can't

00:03:15,630 --> 00:03:22,740
just it's not a cluster of normal mice

00:03:17,880 --> 00:03:25,250
go service so- quick cluster has a lot

00:03:22,740 --> 00:03:27,480
of nice features a lot of Lies promises

00:03:25,250 --> 00:03:29,460
so for example there's synchronous

00:03:27,480 --> 00:03:33,300
replication between nodes acid

00:03:29,460 --> 00:03:34,680
transactions rollover locking so as it

00:03:33,300 --> 00:03:38,790
transaction and Rover locking are

00:03:34,680 --> 00:03:42,680
similar features to a nerdy be right who

00:03:38,790 --> 00:03:46,410
uses innodb who knows what innodb is

00:03:42,680 --> 00:03:49,040
okay so it is transactional cluster eise

00:03:46,410 --> 00:03:51,540
transactional with rollover locking

00:03:49,040 --> 00:03:54,240
however cluster only supports one

00:03:51,540 --> 00:03:56,850
isolation level read committed so no

00:03:54,240 --> 00:04:00,480
repeatable read or or or anything else

00:03:56,850 --> 00:04:03,840
so it's only really committed cluster

00:04:00,480 --> 00:04:05,310
has a shared nothing architecture which

00:04:03,840 --> 00:04:06,630
means that you don't need a son or

00:04:05,310 --> 00:04:08,040
anything like that it's runs on

00:04:06,630 --> 00:04:10,530
commodity hardware right so that's a

00:04:08,040 --> 00:04:12,240
good part and it's automatic fail of it

00:04:10,530 --> 00:04:14,070
so everything are most things in the

00:04:12,240 --> 00:04:16,950
cluster are automatic they happen behind

00:04:14,070 --> 00:04:18,870
the scenes you don't know notice

00:04:16,950 --> 00:04:21,210
anything about replication about nodes

00:04:18,870 --> 00:04:23,850
failing and start restarting so for the

00:04:21,210 --> 00:04:28,260
end user it's all transparent which is

00:04:23,850 --> 00:04:33,150
good cluster has some more features it's

00:04:28,260 --> 00:04:35,550
basically an in memory storage engine in

00:04:33,150 --> 00:04:37,590
the beginning it was only an in memory

00:04:35,550 --> 00:04:39,419
storage engine so so everything is

00:04:37,590 --> 00:04:41,910
stored in the cluster was in memory only

00:04:39,419 --> 00:04:45,430
now it's been extended so that you can

00:04:41,910 --> 00:04:48,500
store some of the data on the disk

00:04:45,430 --> 00:04:50,540
but it's kind of actually funny in a way

00:04:48,500 --> 00:04:53,570
because we started by storing everything

00:04:50,540 --> 00:04:55,370
in memory in cluster and at the time

00:04:53,570 --> 00:04:58,250
people didn't tell about memory so

00:04:55,370 --> 00:05:00,440
people come well I have like 12 weeks of

00:04:58,250 --> 00:05:03,200
data and how can I store that in my in

00:05:00,440 --> 00:05:07,490
RAM because at the time four gigs of ram

00:05:03,200 --> 00:05:12,650
was a lot and so we decide all day my

00:05:07,490 --> 00:05:14,120
engineers decided to add disk capability

00:05:12,650 --> 00:05:16,400
so you can store some columns on disk

00:05:14,120 --> 00:05:17,750
but not when you can do it no one wants

00:05:16,400 --> 00:05:21,980
to do it anymore because now Ram is

00:05:17,750 --> 00:05:23,750
abundant but so even if you can store

00:05:21,980 --> 00:05:27,070
some of the stuff on disk note that

00:05:23,750 --> 00:05:30,770
cluster was developed to be an MMA and

00:05:27,070 --> 00:05:32,930
database which means that basically

00:05:30,770 --> 00:05:34,820
means that performance is much better

00:05:32,930 --> 00:05:36,290
for the in-memory part if you store some

00:05:34,820 --> 00:05:38,750
of the data on disk it has to be data

00:05:36,290 --> 00:05:41,360
that's not access to all the time or has

00:05:38,750 --> 00:05:43,130
a less frequent access pattern than

00:05:41,360 --> 00:05:45,530
other data but I mean there are some

00:05:43,130 --> 00:05:48,440
very good use cases for this for example

00:05:45,530 --> 00:05:50,900
if you have blobs or something like that

00:05:48,440 --> 00:05:52,820
which you access very rarely then you

00:05:50,900 --> 00:05:54,410
can store the blobs on disk and had the

00:05:52,820 --> 00:05:58,880
rest of the data in memory for example

00:05:54,410 --> 00:06:01,610
so there are use cases for it cluster

00:05:58,880 --> 00:06:02,600
does have checkpointing to disk so even

00:06:01,610 --> 00:06:04,880
though everything is stored in memory

00:06:02,600 --> 00:06:07,220
they still checkpoints within two discs

00:06:04,880 --> 00:06:10,040
so that the data is synchronized to disk

00:06:07,220 --> 00:06:12,710
in case of a complete cluster failure or

00:06:10,040 --> 00:06:14,200
in case of when you shut down nodes and

00:06:12,710 --> 00:06:16,310
restart them so they wouldn't have to

00:06:14,200 --> 00:06:22,130
restart from scratch they have stuff on

00:06:16,310 --> 00:06:24,650
disk as well cluster supports internally

00:06:22,130 --> 00:06:28,880
two types of indexes there's unique hash

00:06:24,650 --> 00:06:30,230
indexes and ordered tea tree indexes and

00:06:28,880 --> 00:06:32,870
we'll get to that later but basically

00:06:30,230 --> 00:06:36,560
you can have either unique hash indexes

00:06:32,870 --> 00:06:38,000
or or a tea tree indexes and the cool

00:06:36,560 --> 00:06:41,540
thing we plus three is there's a few

00:06:38,000 --> 00:06:43,940
online operations for example you can do

00:06:41,540 --> 00:06:47,020
software upgrades without without taking

00:06:43,940 --> 00:06:49,370
down the cluster so because you have a

00:06:47,020 --> 00:06:51,200
cluster with lots of nodes you can

00:06:49,370 --> 00:06:53,900
upgrade one note at a time and your

00:06:51,200 --> 00:06:55,700
cluster stays online the whole time so

00:06:53,900 --> 00:06:57,050
for the end user again they don't

00:06:55,700 --> 00:06:57,470
actually see that you're upgrading stuff

00:06:57,050 --> 00:07:01,430
because

00:06:57,470 --> 00:07:03,200
stays online all the time and cluster

00:07:01,430 --> 00:07:05,180
actually has some some additional

00:07:03,200 --> 00:07:07,550
features that no other storage engine

00:07:05,180 --> 00:07:09,920
has yet so some of the altar table

00:07:07,550 --> 00:07:11,780
operations can be done online in the

00:07:09,920 --> 00:07:14,330
cluster and with online we mean that the

00:07:11,780 --> 00:07:17,840
table is accessible by other are there

00:07:14,330 --> 00:07:20,510
other threads so MySQL has the has the

00:07:17,840 --> 00:07:24,110
annoying feature of altar tables by

00:07:20,510 --> 00:07:26,000
default means we start by locking the

00:07:24,110 --> 00:07:28,310
table second thing we start by making a

00:07:26,000 --> 00:07:30,260
copy of the table and then we copy all

00:07:28,310 --> 00:07:32,390
the old data to the new definition and

00:07:30,260 --> 00:07:34,670
stuff like that which is very slow all

00:07:32,390 --> 00:07:37,820
the table in mysql is really badly

00:07:34,670 --> 00:07:39,410
optimized and because the table is

00:07:37,820 --> 00:07:42,200
locked during the operation it can

00:07:39,410 --> 00:07:44,210
actually be pretty bad but cluster

00:07:42,200 --> 00:07:46,850
supports some of the table operations

00:07:44,210 --> 00:07:48,560
online such as adding columns adding

00:07:46,850 --> 00:07:51,370
indexes and stuff like that so you can

00:07:48,560 --> 00:07:54,050
actually add an index to a cluster table

00:07:51,370 --> 00:07:56,360
in the background so index is being

00:07:54,050 --> 00:07:58,400
added added and wild index is being

00:07:56,360 --> 00:08:00,950
added all your clients can still access

00:07:58,400 --> 00:08:03,950
to data so that's pretty cool and this

00:08:00,950 --> 00:08:07,910
is currently only in cluster all right

00:08:03,950 --> 00:08:09,380
let's look at the architecture so the

00:08:07,910 --> 00:08:10,910
cluster architecture differs quite

00:08:09,380 --> 00:08:13,190
heavily from a standard micro

00:08:10,910 --> 00:08:14,630
architecture because the number one

00:08:13,190 --> 00:08:19,070
point is that there is a separation

00:08:14,630 --> 00:08:23,390
between the SQL layer and the storage

00:08:19,070 --> 00:08:26,240
layer so what you see here is well you

00:08:23,390 --> 00:08:28,820
have your end users here and they talk

00:08:26,240 --> 00:08:31,070
to which could be you know Apache

00:08:28,820 --> 00:08:33,890
servers or whatever talking to MySQL

00:08:31,070 --> 00:08:37,190
servers and then separately there's a

00:08:33,890 --> 00:08:38,539
storage layer so you have your mysql

00:08:37,190 --> 00:08:40,729
server somewhere but they don't actually

00:08:38,539 --> 00:08:43,880
store any of the data but the data is

00:08:40,729 --> 00:08:47,750
stored in this storage layer which is

00:08:43,880 --> 00:08:50,030
which consists of data nodes and these

00:08:47,750 --> 00:08:52,180
data nodes are separate processes so you

00:08:50,030 --> 00:08:54,260
have each data node would be a process

00:08:52,180 --> 00:08:55,610
most likely running on a separate

00:08:54,260 --> 00:08:59,930
machine so you would have one machine

00:08:55,610 --> 00:09:01,760
per per node normally you can also run

00:08:59,930 --> 00:09:04,570
multiple nodes on the same machine but

00:09:01,760 --> 00:09:04,570
it's not recommended

00:09:05,410 --> 00:09:10,040
so that's the basic of the cluster you

00:09:07,759 --> 00:09:13,160
have my school servers and you have

00:09:10,040 --> 00:09:14,899
storage nodes or data nodes and of

00:09:13,160 --> 00:09:17,629
course the storage nodes or data nodes

00:09:14,899 --> 00:09:20,059
is where all the synchronous replication

00:09:17,629 --> 00:09:22,189
and all that stuff takes place the MySQL

00:09:20,059 --> 00:09:24,559
servers well in theory you don't really

00:09:22,189 --> 00:09:26,179
need them you actually have direct

00:09:24,559 --> 00:09:28,519
access to the data node this there's a

00:09:26,179 --> 00:09:30,499
capi a native capi so you can actually

00:09:28,519 --> 00:09:34,249
access the NATO notes directly and

00:09:30,499 --> 00:09:35,839
they're also other AP is Java API and so

00:09:34,249 --> 00:09:39,379
forth to access their notes directly so

00:09:35,839 --> 00:09:40,939
you don't even have to use MySQL servers

00:09:39,379 --> 00:09:44,029
you're going to use you can use the data

00:09:40,939 --> 00:09:46,429
nodes as kind of like a no SQL solution

00:09:44,029 --> 00:09:48,170
as well so you can actually combine you

00:09:46,429 --> 00:09:49,759
can have some part that's kind of a no

00:09:48,170 --> 00:09:53,089
SQL solution on some part you use to my

00:09:49,759 --> 00:09:57,019
escrow service or something another cool

00:09:53,089 --> 00:09:59,149
thing with this with this architecture

00:09:57,019 --> 00:10:00,920
is of course the flexibility you can

00:09:59,149 --> 00:10:04,489
have one cluster with four data nodes

00:10:00,920 --> 00:10:07,999
and you can add my escrow service to it

00:10:04,489 --> 00:10:09,439
if you need right so what do the Moscow

00:10:07,999 --> 00:10:10,970
servers do well they parse the query

00:10:09,439 --> 00:10:15,049
they optimize the query in the process

00:10:10,970 --> 00:10:16,069
the data so you can have two of these

00:10:15,049 --> 00:10:18,559
you're going to force these you can have

00:10:16,069 --> 00:10:20,929
ten you can have 12 basically the number

00:10:18,559 --> 00:10:22,999
of MySQL servers has nothing to do with

00:10:20,929 --> 00:10:27,309
the number of data nodes so you can

00:10:22,999 --> 00:10:27,309
change very eight here yeah

00:10:31,100 --> 00:10:37,140
so do to do the SQL nodes store any data

00:10:35,010 --> 00:10:39,780
so no they don't store any data they

00:10:37,140 --> 00:10:41,370
have they have metadata like the table

00:10:39,780 --> 00:10:44,670
structures and stuff like that but it's

00:10:41,370 --> 00:10:48,030
updated from the data nodes so if this

00:10:44,670 --> 00:10:50,550
guy changes doesn't alter table this guy

00:10:48,030 --> 00:10:54,000
will get the change from from the data

00:10:50,550 --> 00:11:00,930
nodes but basically all the data is

00:10:54,000 --> 00:11:04,590
stored here yes so you query cache you

00:11:00,930 --> 00:11:06,330
can actually have it and it used to not

00:11:04,590 --> 00:11:08,280
work because it's used to not be

00:11:06,330 --> 00:11:09,450
invalidated now it's invalid the problem

00:11:08,280 --> 00:11:11,430
of course is that when you start having

00:11:09,450 --> 00:11:13,230
many MySQL servers and many accesses if

00:11:11,430 --> 00:11:15,660
you'll be invalidated so often so it

00:11:13,230 --> 00:11:19,050
doesn't make sense to use but remember

00:11:15,660 --> 00:11:20,550
that this is stored in memory right so

00:11:19,050 --> 00:11:27,720
what do you need a query cache or not

00:11:20,550 --> 00:11:29,370
this is also questionable I mean for the

00:11:27,720 --> 00:11:31,200
disc date that there is a there is a

00:11:29,370 --> 00:11:33,630
buffer and but they're storing the data

00:11:31,200 --> 00:11:34,890
nodes nothing to MySQL servers so if you

00:11:33,630 --> 00:11:37,800
actually store something on d6 there's

00:11:34,890 --> 00:11:40,770
actually a buffer for or cash for a disk

00:11:37,800 --> 00:11:45,750
data as well but its total akola

00:11:40,770 --> 00:11:49,710
knowledge then there's something you

00:11:45,750 --> 00:11:51,330
call the management node which seems

00:11:49,710 --> 00:11:53,220
like it would be a fairly important note

00:11:51,330 --> 00:11:56,070
because it's called management node but

00:11:53,220 --> 00:11:59,820
it's actually not the management node is

00:11:56,070 --> 00:12:03,270
only used for for what kind of used for

00:11:59,820 --> 00:12:05,670
three things number one is configuration

00:12:03,270 --> 00:12:06,840
so when you configure a cluster the

00:12:05,670 --> 00:12:08,010
management node controls the

00:12:06,840 --> 00:12:11,160
configuration so this is where you

00:12:08,010 --> 00:12:12,960
create you create the configuration file

00:12:11,160 --> 00:12:14,250
where you define the number of data

00:12:12,960 --> 00:12:17,250
nodes you want to have that stuff like

00:12:14,250 --> 00:12:19,560
that and that's the management node who

00:12:17,250 --> 00:12:21,390
owns that file so when your cluster

00:12:19,560 --> 00:12:23,340
starts up for the first time or every

00:12:21,390 --> 00:12:24,990
time a node starts up the first thing

00:12:23,340 --> 00:12:27,270
they do is they contact the management

00:12:24,990 --> 00:12:30,750
note and said all right I'm coming from

00:12:27,270 --> 00:12:32,640
this host I'm node 4 or whatever what is

00:12:30,750 --> 00:12:35,610
my configuration and the management nerd

00:12:32,640 --> 00:12:36,930
will give its configuration or if it's a

00:12:35,610 --> 00:12:38,160
node that doesn't exist in the

00:12:36,930 --> 00:12:40,020
configuration it will tell the node

00:12:38,160 --> 00:12:41,200
sorry you don't we don't need you here

00:12:40,020 --> 00:12:42,880
shut down and I will shut

00:12:41,200 --> 00:12:46,090
so the management node controls the

00:12:42,880 --> 00:12:50,200
configuration apart from that the

00:12:46,090 --> 00:12:53,290
management node also controls a log file

00:12:50,200 --> 00:12:54,370
so the data nodes they send event to the

00:12:53,290 --> 00:12:56,910
management note in the management no

00:12:54,370 --> 00:12:59,650
then stores these events in a log file

00:12:56,910 --> 00:13:01,300
but but when you actually run queries

00:12:59,650 --> 00:13:03,370
and stuff the management no it is not

00:13:01,300 --> 00:13:05,980
needed for anything if the management

00:13:03,370 --> 00:13:09,640
not crashes there's no effect whatsoever

00:13:05,980 --> 00:13:11,950
on the cluster but you can also have

00:13:09,640 --> 00:13:15,030
multiple management nodes as well but

00:13:11,950 --> 00:13:21,250
but it doesn't take part in any of the

00:13:15,030 --> 00:13:23,220
data access at all right so this is the

00:13:21,250 --> 00:13:29,050
number one thing to remember the

00:13:23,220 --> 00:13:31,030
architecture of the classroom then I'll

00:13:29,050 --> 00:13:32,860
go into how the data a bit of the

00:13:31,030 --> 00:13:35,190
internal handlings in the we in the data

00:13:32,860 --> 00:13:38,830
nodes here so number one thing is that

00:13:35,190 --> 00:13:42,730
in mysql cluster there's an automatic

00:13:38,830 --> 00:13:45,310
partitioning of the data so depending on

00:13:42,730 --> 00:13:48,280
how many data nodes you have every

00:13:45,310 --> 00:13:50,740
single table is partitioned into as many

00:13:48,280 --> 00:13:52,900
partitions as you have data nodes so if

00:13:50,740 --> 00:13:55,090
you have two data nodes here like we

00:13:52,900 --> 00:13:59,650
have here every single table we will be

00:13:55,090 --> 00:14:01,810
partitioned into two buckets and one

00:13:59,650 --> 00:14:02,980
node will own one of the partitions and

00:14:01,810 --> 00:14:07,660
the other node will own the other

00:14:02,980 --> 00:14:09,040
partition right and this partition you

00:14:07,660 --> 00:14:12,310
can actually control how the data is

00:14:09,040 --> 00:14:14,170
partitioned but by default it's based on

00:14:12,310 --> 00:14:17,820
the primary key and it's based on a hash

00:14:14,170 --> 00:14:20,290
value of the primary key so the cluster

00:14:17,820 --> 00:14:22,840
calculates a hash value on your primary

00:14:20,290 --> 00:14:24,550
key and then that's a simple mod on this

00:14:22,840 --> 00:14:27,370
hash value and that's how it decides

00:14:24,550 --> 00:14:30,460
which node or which partition each row

00:14:27,370 --> 00:14:33,040
will go into and this is transparent and

00:14:30,460 --> 00:14:35,440
automatic so you don't know you don't

00:14:33,040 --> 00:14:39,030
know which which partition heater will

00:14:35,440 --> 00:14:39,030
go into it's just done automatically

00:14:41,500 --> 00:14:46,370
so that's a good question so what

00:14:44,900 --> 00:14:48,200
happens when you have more nodes so if

00:14:46,370 --> 00:14:53,300
you would have three nodes well first of

00:14:48,200 --> 00:14:54,560
all actually does i need to say one more

00:14:53,300 --> 00:14:57,950
thing before I can answer your questions

00:14:54,560 --> 00:14:59,390
so hold on alright so the pro this is

00:14:57,950 --> 00:15:01,820
good but but there's one thing missing

00:14:59,390 --> 00:15:04,640
and of course if node 4 goes down we

00:15:01,820 --> 00:15:06,860
lose the green partition and we're dead

00:15:04,640 --> 00:15:09,110
because we lost half of the data so it's

00:15:06,860 --> 00:15:13,430
actually also replication between

00:15:09,110 --> 00:15:15,560
between the nodes so each partition will

00:15:13,430 --> 00:15:17,990
exist in one node but it will also be

00:15:15,560 --> 00:15:20,660
replicated to a different node so if you

00:15:17,990 --> 00:15:24,790
have two nodes well both nodes will

00:15:20,660 --> 00:15:28,520
contain the whole of the data however

00:15:24,790 --> 00:15:30,440
one of the one of the copies of the

00:15:28,520 --> 00:15:33,470
partition is a primary replica and one

00:15:30,440 --> 00:15:35,120
is a secondary and this is important

00:15:33,470 --> 00:15:37,460
when you process queries because all

00:15:35,120 --> 00:15:39,770
query processing will go first to the

00:15:37,460 --> 00:15:42,230
primary version so this is kind of only

00:15:39,770 --> 00:15:44,450
a backup it's not really used it's only

00:15:42,230 --> 00:15:50,810
part of right transactions and only as a

00:15:44,450 --> 00:15:53,480
safety net right so now I can answer

00:15:50,810 --> 00:15:55,880
your question so if you have three nodes

00:15:53,480 --> 00:15:58,340
so first of all you can actually define

00:15:55,880 --> 00:16:00,110
here there's something called number of

00:15:58,340 --> 00:16:03,260
replicas which defines how many copies

00:16:00,110 --> 00:16:05,540
of each partition do you keep there is

00:16:03,260 --> 00:16:07,490
no default but the recommended value is

00:16:05,540 --> 00:16:10,250
2 which means that every partition will

00:16:07,490 --> 00:16:14,120
exist in two different nodes but you can

00:16:10,250 --> 00:16:17,390
actually change it it can be one which

00:16:14,120 --> 00:16:18,800
means this which means you're not run

00:16:17,390 --> 00:16:22,190
using high it's not high highly

00:16:18,800 --> 00:16:26,450
available so never use this it can in

00:16:22,190 --> 00:16:30,040
theory be three or four but this will

00:16:26,450 --> 00:16:33,200
make your plastic extremely slow because

00:16:30,040 --> 00:16:36,160
we go into how the right quiz to take

00:16:33,200 --> 00:16:38,900
place but it will add more latency and

00:16:36,160 --> 00:16:40,760
another thing is that three or four are

00:16:38,900 --> 00:16:43,100
not very tested because no one actually

00:16:40,760 --> 00:16:44,840
uses them so most people will just run

00:16:43,100 --> 00:16:48,080
with two copies of everything and that's

00:16:44,840 --> 00:16:50,440
it but theoretically you can use three

00:16:48,080 --> 00:16:50,440
or four

00:16:54,490 --> 00:16:59,870
yes so if you have a transaction when

00:16:57,500 --> 00:17:01,070
you're running a right transaction we

00:16:59,870 --> 00:17:02,720
will actually go through exactly how

00:17:01,070 --> 00:17:04,040
it's done but basically it will ensure

00:17:02,720 --> 00:17:06,200
that when you get the committee it's

00:17:04,040 --> 00:17:07,610
being committed on both nodes unless of

00:17:06,200 --> 00:17:08,990
course one node went down during the

00:17:07,610 --> 00:17:10,850
process or something like that but but

00:17:08,990 --> 00:17:15,440
as long as all nodes are there it should

00:17:10,850 --> 00:17:17,840
be committed on both places but so this

00:17:15,440 --> 00:17:18,770
number of replicas so if it said 22 this

00:17:17,840 --> 00:17:22,280
means that you can only have a

00:17:18,770 --> 00:17:23,840
combination of a multiple of two data

00:17:22,280 --> 00:17:26,660
nodes you cannot have three you can have

00:17:23,840 --> 00:17:29,480
two or four or six or eight but you can

00:17:26,660 --> 00:17:33,620
never have three no data nodes because

00:17:29,480 --> 00:17:36,260
it wouldn't work if you have for data

00:17:33,620 --> 00:17:38,780
nodes well basically the table is

00:17:36,260 --> 00:17:41,720
partitioned into four tables each data

00:17:38,780 --> 00:17:44,720
node will get one one partition at its

00:17:41,720 --> 00:17:46,280
primary and then there there will be a

00:17:44,720 --> 00:17:49,220
backup on a different note and the note

00:17:46,280 --> 00:17:51,470
will actually work in pairs which means

00:17:49,220 --> 00:17:54,890
that note 5 and 6 will replicate each

00:17:51,470 --> 00:17:57,320
other and this is a design choice which

00:17:54,890 --> 00:18:03,170
has it could be done differently but

00:17:57,320 --> 00:18:11,330
this is the way it's done and this has

00:18:03,170 --> 00:18:14,780
implications for for for performance for

00:18:11,330 --> 00:18:18,020
example if a node goes down a standard 5

00:18:14,780 --> 00:18:20,090
goes down this means that node 6 the the

00:18:18,020 --> 00:18:22,730
yellow yellow partition here will become

00:18:20,090 --> 00:18:25,190
the primary way just the secondary

00:18:22,730 --> 00:18:27,760
previously which means that node 6 will

00:18:25,190 --> 00:18:30,020
have twice the traffic it had before

00:18:27,760 --> 00:18:31,640
because everything going to the blue

00:18:30,020 --> 00:18:33,740
partition and everything going to yellow

00:18:31,640 --> 00:18:36,620
will go only to note sick it won't be

00:18:33,740 --> 00:18:39,410
exactly twice because the rot the reeds

00:18:36,620 --> 00:18:42,770
won't go twice but all the rights I mean

00:18:39,410 --> 00:18:45,080
sorry the because the right one we're

00:18:42,770 --> 00:18:47,180
already here but all the reads if you

00:18:45,080 --> 00:18:49,310
have more reads and writes it will now

00:18:47,180 --> 00:18:52,490
how twice the amount of reeds on this

00:18:49,310 --> 00:18:54,350
node which means that when you kind of

00:18:52,490 --> 00:18:57,470
configure your cluster you have to be

00:18:54,350 --> 00:18:59,480
able to each machine or each node has to

00:18:57,470 --> 00:19:02,940
be able to withstand twice the amount of

00:18:59,480 --> 00:19:05,610
traffic you have it in normal

00:19:02,940 --> 00:19:07,020
normal circumstances so if you see that

00:19:05,610 --> 00:19:08,610
you're running your machine your nodes

00:19:07,020 --> 00:19:10,920
unlike above fifty percent of

00:19:08,610 --> 00:19:13,950
utilization it means that if you have a

00:19:10,920 --> 00:19:15,450
crash you won't be able to handle your

00:19:13,950 --> 00:19:18,050
load because one of your servers will be

00:19:15,450 --> 00:19:18,050
overloaded

00:19:24,000 --> 00:19:29,230
so the group is depends on this number

00:19:26,860 --> 00:19:31,150
of replicas variable so it's

00:19:29,230 --> 00:19:37,290
configurable but by default is always

00:19:31,150 --> 00:19:37,290
two years so if what

00:19:38,390 --> 00:19:43,280
you can but then you have to have three

00:19:41,540 --> 00:19:53,390
in each group but it's not recommended

00:19:43,280 --> 00:19:55,550
but you can theoretically you can so so

00:19:53,390 --> 00:19:56,840
the number of replicas is kind of the

00:19:55,550 --> 00:19:58,700
minimum amount of knowledge you have to

00:19:56,840 --> 00:20:00,530
have so if you said number of replicas

00:19:58,700 --> 00:20:02,510
22 you have to have at least two nodes

00:20:00,530 --> 00:20:05,690
and then you can have two four six and

00:20:02,510 --> 00:20:13,670
each time you add nodes you add a group

00:20:05,690 --> 00:20:17,450
of nodes no you need to add as many

00:20:13,670 --> 00:20:19,910
notes as there are notes per group so

00:20:17,450 --> 00:20:26,510
like here I have I have four nodes now I

00:20:19,910 --> 00:20:28,910
could add two more nodes to have six you

00:20:26,510 --> 00:20:30,410
can you can't do that you can't add

00:20:28,910 --> 00:20:33,860
notes to 16 groups you can only add

00:20:30,410 --> 00:20:37,580
groups so what happens when you add

00:20:33,860 --> 00:20:39,440
groups is that if I had a new group here

00:20:37,580 --> 00:20:41,420
let's say I'm running I'm using this and

00:20:39,440 --> 00:20:43,790
I'm starting to run out of disk or so

00:20:41,420 --> 00:20:46,010
out of memory of my machines so I want

00:20:43,790 --> 00:20:48,860
to add another node group so I add two

00:20:46,010 --> 00:20:51,530
more machines and then the tables will

00:20:48,860 --> 00:20:54,290
be partitioned into six partition

00:20:51,530 --> 00:20:56,140
instead of eight and well these new

00:20:54,290 --> 00:20:58,220
partitions will come here by default

00:20:56,140 --> 00:21:02,180
when you actually do the process of

00:20:58,220 --> 00:21:04,190
adding nodes the old tables won't be

00:21:02,180 --> 00:21:05,750
Reaper reorganized until you you have to

00:21:04,190 --> 00:21:07,940
do a command to do it but every new

00:21:05,750 --> 00:21:10,070
table will automatically be in in in six

00:21:07,940 --> 00:21:12,080
so when you if you add nodes to a

00:21:10,070 --> 00:21:13,880
running cluster the new nodes will be

00:21:12,080 --> 00:21:16,430
empty at first and you have to table by

00:21:13,880 --> 00:21:19,250
table do this altar table reorganized

00:21:16,430 --> 00:21:22,060
partition it's an online operation so

00:21:19,250 --> 00:21:22,060
it's done in the background

00:21:34,960 --> 00:21:41,419
yeah so yeah doesn't mean that your data

00:21:39,470 --> 00:21:44,870
is some your access is somehow skewed to

00:21:41,419 --> 00:21:46,370
justice some rows and stuff so you if

00:21:44,870 --> 00:21:48,020
you see that there's a lot of access to

00:21:46,370 --> 00:21:52,549
these nodes it means that they're

00:21:48,020 --> 00:21:53,600
accessing only certain rose right so one

00:21:52,549 --> 00:21:56,390
thing you could try doing is just

00:21:53,600 --> 00:21:57,590
changing the partitioning key instead of

00:21:56,390 --> 00:22:01,070
partitioning on the whole primary key

00:21:57,590 --> 00:22:02,779
partition on something else but you you

00:22:01,070 --> 00:22:05,450
can also add another node group because

00:22:02,779 --> 00:22:07,309
then because then the data would be V

00:22:05,450 --> 00:22:09,679
partitioned so then that would

00:22:07,309 --> 00:22:16,940
potentially split up the rows that are

00:22:09,679 --> 00:22:19,220
accessed a lot all right any other

00:22:16,940 --> 00:22:21,409
questions but this how the data is pit

00:22:19,220 --> 00:22:24,409
up so and then so this is all automatic

00:22:21,409 --> 00:22:28,850
you don't even see it if you do a create

00:22:24,409 --> 00:22:29,870
table with engine cluster in MySQL this

00:22:28,850 --> 00:22:33,260
would be done automatically you don't

00:22:29,870 --> 00:22:36,679
have to worry about it unless you have

00:22:33,260 --> 00:22:38,510
some problem and when you insert rows

00:22:36,679 --> 00:22:47,570
update rose you don't see any of this

00:22:38,510 --> 00:22:50,419
it's automatically right so some of the

00:22:47,570 --> 00:22:52,210
features in the classes so when you in

00:22:50,419 --> 00:22:53,960
general when you have an h eight

00:22:52,210 --> 00:22:57,679
solution based on a shared nothing

00:22:53,960 --> 00:22:59,960
architecture one of the main problems is

00:22:57,679 --> 00:23:03,980
is the so-called split brain scenario

00:22:59,960 --> 00:23:06,950
right and the split brain scenario has

00:23:03,980 --> 00:23:08,090
to do with the fact that when a pro when

00:23:06,950 --> 00:23:11,320
you when you have a share nothing

00:23:08,090 --> 00:23:13,580
architecture everything depends on

00:23:11,320 --> 00:23:16,940
communication over the network right

00:23:13,580 --> 00:23:19,820
notes communicating and the problem

00:23:16,940 --> 00:23:22,429
arises when a node doesn't answer so

00:23:19,820 --> 00:23:24,020
node is not answering communication you

00:23:22,429 --> 00:23:26,029
are no way of knowing is this node

00:23:24,020 --> 00:23:30,830
actually down or is it just a

00:23:26,029 --> 00:23:33,289
communication problem somewhere so any

00:23:30,830 --> 00:23:35,360
type of age a solution share nothing you

00:23:33,289 --> 00:23:37,100
have to have some kind of mechanism for

00:23:35,360 --> 00:23:40,010
dealing with this what do we do when I

00:23:37,100 --> 00:23:41,720
know it is not responding so you will

00:23:40,010 --> 00:23:44,289
find out in different scenarios they use

00:23:41,720 --> 00:23:44,289
different things

00:23:45,250 --> 00:23:49,039
cluster has this thing called network

00:23:47,539 --> 00:23:54,260
partitioning protocol which is there to

00:23:49,039 --> 00:23:56,000
kind of take care of this scenario so as

00:23:54,260 --> 00:23:59,179
soon as there's a communication problem

00:23:56,000 --> 00:24:00,650
one node is not communicating to others

00:23:59,179 --> 00:24:01,970
on many nodes and not communicating

00:24:00,650 --> 00:24:05,150
basically any kind of communication

00:24:01,970 --> 00:24:06,679
problem in a cluster the data nodes

00:24:05,150 --> 00:24:08,870
launch this network partitioning

00:24:06,679 --> 00:24:14,390
protocol which is designed to to

00:24:08,870 --> 00:24:15,679
basically avoid split-brain so basically

00:24:14,390 --> 00:24:18,620
they have a few questions they ask

00:24:15,679 --> 00:24:20,059
themselves or the nodes and and that's

00:24:18,620 --> 00:24:21,440
then determines whether the nodes can

00:24:20,059 --> 00:24:26,690
continue I will whether they will

00:24:21,440 --> 00:24:29,630
actually commit suicide so the first

00:24:26,690 --> 00:24:32,059
thing the nodes do is that if they have

00:24:29,630 --> 00:24:33,799
a communication problem is the V group

00:24:32,059 --> 00:24:35,570
so the nodes that can communicate they

00:24:33,799 --> 00:24:37,880
regroup and say alright we can

00:24:35,570 --> 00:24:39,169
communicate let's do the net for

00:24:37,880 --> 00:24:41,419
positioning protocol so the first thing

00:24:39,169 --> 00:24:44,240
they do is all right do we have at least

00:24:41,419 --> 00:24:46,970
one node group from each at least one

00:24:44,240 --> 00:24:48,850
node from each node group so do we have

00:24:46,970 --> 00:24:52,700
at least one from each of these groups

00:24:48,850 --> 00:24:55,100
right if the answer is yes then we're

00:24:52,700 --> 00:24:58,159
good to go to the next phase if the

00:24:55,100 --> 00:25:00,500
answer is no let's say node 6 somehow it

00:24:58,159 --> 00:25:02,240
gets cut off from the network so node 6

00:25:00,500 --> 00:25:03,470
will launch the same protocol it will

00:25:02,240 --> 00:25:05,929
say all right do I have one note from

00:25:03,470 --> 00:25:09,500
each node group no it's alone it will

00:25:05,929 --> 00:25:10,850
actually commit suicide so this means

00:25:09,500 --> 00:25:12,559
that you don't need an external process

00:25:10,850 --> 00:25:13,850
for shutting down stuff when they're

00:25:12,559 --> 00:25:15,260
split brain snarls because they will

00:25:13,850 --> 00:25:19,539
actually commit suicide so this guy will

00:25:15,260 --> 00:25:19,539
kill itself say okay I can't continue

00:25:21,100 --> 00:25:25,700
then if they pass this the second

00:25:23,840 --> 00:25:27,049
question they ask is okay are all nodes

00:25:25,700 --> 00:25:30,409
present too many of the neural groups

00:25:27,049 --> 00:25:33,799
and if the answer is yes then the nodes

00:25:30,409 --> 00:25:36,980
know that no other network position can

00:25:33,799 --> 00:25:38,900
pass phase one which means they know

00:25:36,980 --> 00:25:43,970
that they are they can continue as the

00:25:38,900 --> 00:25:45,110
only viable cluster so I mean the kind

00:25:43,970 --> 00:25:46,880
of the problem here is that we would

00:25:45,110 --> 00:25:48,049
potentially have two partitions of the

00:25:46,880 --> 00:25:50,090
clusters both saying that they are a

00:25:48,049 --> 00:25:51,559
cluster which means that you would write

00:25:50,090 --> 00:25:52,789
some rights here some rights there and

00:25:51,559 --> 00:25:54,530
there's no one I shrink then it's kind

00:25:52,789 --> 00:25:54,720
of game over so that's why we have to

00:25:54,530 --> 00:25:59,070
make

00:25:54,720 --> 00:26:03,630
sure only one stays up so that's the

00:25:59,070 --> 00:26:05,340
second question if they can't answer yes

00:26:03,630 --> 00:26:07,049
to this question this means we have an

00:26:05,340 --> 00:26:14,309
even split so for example if you have

00:26:07,049 --> 00:26:15,990
two nodes so this scenario here if one

00:26:14,309 --> 00:26:17,610
of the node crashes or there's a

00:26:15,990 --> 00:26:20,520
communication problem you always have an

00:26:17,610 --> 00:26:23,880
even split right you always have one

00:26:20,520 --> 00:26:26,570
node and one node so the first quote to

00:26:23,880 --> 00:26:29,370
questions won't help either of these

00:26:26,570 --> 00:26:31,950
because they kind of determine the

00:26:29,370 --> 00:26:34,080
neither will have all the nodes from

00:26:31,950 --> 00:26:37,250
another group and both of them will have

00:26:34,080 --> 00:26:40,409
well one node from each not good and

00:26:37,250 --> 00:26:42,210
this is where phase 3 comes in we ask

00:26:40,409 --> 00:26:45,690
the arbitrator so we need a third

00:26:42,210 --> 00:26:50,940
external process that determines who can

00:26:45,690 --> 00:26:52,799
live and who can die and this external

00:26:50,940 --> 00:26:55,080
process could be the management server

00:26:52,799 --> 00:26:58,440
it could be any of the MySQL servers the

00:26:55,080 --> 00:27:01,200
only rule is that the arbitrator is

00:26:58,440 --> 00:27:02,460
decided it's decided early and during

00:27:01,200 --> 00:27:05,280
the network perdition protocol the

00:27:02,460 --> 00:27:06,570
arbitrator cannot be changed so they are

00:27:05,280 --> 00:27:08,610
stuck with the obturator they had before

00:27:06,570 --> 00:27:10,890
they had a communication problem which

00:27:08,610 --> 00:27:12,840
means that both will ask the same and

00:27:10,890 --> 00:27:16,440
the arbitrator has a simple actually

00:27:12,840 --> 00:27:18,890
rule the first ones who ask will get a

00:27:16,440 --> 00:27:21,480
yes the second ones we're gonna know and

00:27:18,890 --> 00:27:23,039
this basically process ensures that we

00:27:21,480 --> 00:27:30,620
will never have a split brain scenario

00:27:23,039 --> 00:27:30,620
in the cluster you guys follow

00:27:31,730 --> 00:27:39,530
no one understood a thing now you

00:27:35,090 --> 00:27:40,790
understood it okay cool so I mean its

00:27:39,530 --> 00:27:42,230
built-in McCluster again you don't have

00:27:40,790 --> 00:27:43,280
to worry about it it's automatic but

00:27:42,230 --> 00:27:44,870
it's just something you need to be aware

00:27:43,280 --> 00:27:46,820
if you will see in the log sometime when

00:27:44,870 --> 00:27:48,770
you're in a cluster so net for

00:27:46,820 --> 00:27:50,810
positioning protocol launched the last

00:27:48,770 --> 00:27:54,230
arbitrator arbitration one and stuff

00:27:50,810 --> 00:27:55,760
like that and again if you have just two

00:27:54,230 --> 00:27:57,950
data nodes which is like the minimal

00:27:55,760 --> 00:28:00,140
configuration you will have this every

00:27:57,950 --> 00:28:03,700
time there's a problem it will go to the

00:28:00,140 --> 00:28:03,700
arbitrator and they will ask you I know

00:28:24,010 --> 00:28:29,720
all of your Oliver data will be

00:28:26,300 --> 00:28:33,350
available that's the whole point I mean

00:28:29,720 --> 00:28:35,090
that's the whole point is I mean I mean

00:28:33,350 --> 00:28:36,470
that's why we we have replication

00:28:35,090 --> 00:28:39,140
between necessary have these new groups

00:28:36,470 --> 00:28:42,980
right so if we have an uneven split like

00:28:39,140 --> 00:28:45,110
this node 6 goes out no tix will commit

00:28:42,980 --> 00:28:46,790
suicide but the other three will

00:28:45,110 --> 00:28:50,390
continue and you still have all of your

00:28:46,790 --> 00:28:52,330
data because node 5 node 5 has the blue

00:28:50,390 --> 00:28:54,350
partition that node 6 was the owner of

00:28:52,330 --> 00:28:58,280
so you have all your data and your

00:28:54,350 --> 00:28:59,810
cluster will continue and I mean if you

00:28:58,280 --> 00:29:01,130
have an even split it's the same thing

00:28:59,810 --> 00:29:03,680
it's just that this time it's the

00:29:01,130 --> 00:29:05,840
arbitrator who has to decide but the

00:29:03,680 --> 00:29:07,130
data is still there so even if you would

00:29:05,840 --> 00:29:08,570
have a network partitioning well half of

00:29:07,130 --> 00:29:12,800
your nodes can't communicate with the

00:29:08,570 --> 00:29:14,180
other half so they would have to ask the

00:29:12,800 --> 00:29:16,250
arbitrator nah be tradable actually say

00:29:14,180 --> 00:29:18,170
notice to one of these partitions and

00:29:16,250 --> 00:29:19,730
those nodes will commit suicide and stop

00:29:18,170 --> 00:29:21,230
stay there and then then you have to

00:29:19,730 --> 00:29:22,430
then they have to be restarted and then

00:29:21,230 --> 00:29:25,850
they will rejoin the cluster night it's

00:29:22,430 --> 00:29:27,050
a new process but but for time being

00:29:25,850 --> 00:29:29,200
there down because they can't

00:29:27,050 --> 00:29:29,200
communicate

00:29:31,320 --> 00:29:36,660
but it has no implication in that sense

00:29:33,750 --> 00:29:39,300
for your applications at all because

00:29:36,660 --> 00:29:41,370
this is all behind the scenes I mean the

00:29:39,300 --> 00:29:46,140
the protocol itself I mean running the

00:29:41,370 --> 00:29:47,910
protocol will take a few milliseconds so

00:29:46,140 --> 00:29:50,580
during that time they cannot process any

00:29:47,910 --> 00:29:53,400
transactions so there will be a small

00:29:50,580 --> 00:29:55,680
few millisecond slight glitch delaying

00:29:53,400 --> 00:29:59,790
transaction processing because but I

00:29:55,680 --> 00:30:01,200
mean it's already there is a problem

00:29:59,790 --> 00:30:03,180
something either crushed or there's a

00:30:01,200 --> 00:30:04,620
communication problem so it's I mean

00:30:03,180 --> 00:30:07,230
it's better to have it resolved properly

00:30:04,620 --> 00:30:14,670
than to continue and get some weird

00:30:07,230 --> 00:30:16,890
results afterwards right so how do we

00:30:14,670 --> 00:30:19,290
detect that a node is not communicating

00:30:16,890 --> 00:30:21,120
well first of all in every single

00:30:19,290 --> 00:30:23,490
transaction of course nodes are involved

00:30:21,120 --> 00:30:25,770
so during a transaction even though is

00:30:23,490 --> 00:30:28,430
not responding when it should be the

00:30:25,770 --> 00:30:30,600
node that notices this will raise a flag

00:30:28,430 --> 00:30:32,370
but there's also a heartbeat circle

00:30:30,600 --> 00:30:34,230
between nodes so the node sends send

00:30:32,370 --> 00:30:36,570
each other heartbeats and as soon as one

00:30:34,230 --> 00:30:39,660
node hasn't sent these heart beats for

00:30:36,570 --> 00:30:41,430
33 consecutive times the receiving node

00:30:39,660 --> 00:30:43,350
will raise a flag again a second node 6

00:30:41,430 --> 00:30:48,000
is not sending its heart beats let's

00:30:43,350 --> 00:30:49,590
exclude it and this is when they start

00:30:48,000 --> 00:30:50,910
the network partition protocol they

00:30:49,590 --> 00:30:53,190
basically the first thing they do is to

00:30:50,910 --> 00:30:55,170
exclude the node from thunder from the

00:30:53,190 --> 00:30:56,670
heartbeat circle then they do the

00:30:55,170 --> 00:30:58,940
network partitioning and see if they can

00:30:56,670 --> 00:30:58,940
continue

00:31:03,929 --> 00:31:11,190
and so basically the heartbeat circle is

00:31:08,129 --> 00:31:13,289
kind of the last line of defense if for

00:31:11,190 --> 00:31:14,850
some reason during transaction

00:31:13,289 --> 00:31:16,889
processing you don't notice that the

00:31:14,850 --> 00:31:19,559
note is actually down its correction is

00:31:16,889 --> 00:31:20,909
just hanging or something weird then the

00:31:19,559 --> 00:31:23,639
heartbeat is kind of the last line of

00:31:20,909 --> 00:31:25,529
defense so the longest time it takes to

00:31:23,639 --> 00:31:27,330
detect a node failure is three

00:31:25,529 --> 00:31:29,610
heartbeats by default the heartbeat is I

00:31:27,330 --> 00:31:31,110
think two seconds so six seconds is kind

00:31:29,610 --> 00:31:33,480
of the long as it can take to detect a

00:31:31,110 --> 00:31:35,399
failure node failed node and this again

00:31:33,480 --> 00:31:39,659
can be tuned up or down depending on

00:31:35,399 --> 00:31:47,220
your systems but you can detect a node

00:31:39,659 --> 00:31:48,990
failure earlier as well right so let's

00:31:47,220 --> 00:31:53,580
look at how transactions are actually

00:31:48,990 --> 00:31:55,919
processed within the nodes so what

00:31:53,580 --> 00:31:59,490
happens is that your client whatever it

00:31:55,919 --> 00:32:03,059
is sends a request transaction request

00:31:59,490 --> 00:32:08,249
to a mysql server and the mysql server

00:32:03,059 --> 00:32:10,379
will then talk to the data nodes so

00:32:08,249 --> 00:32:14,039
MySQL server or the SQL node here sends

00:32:10,379 --> 00:32:16,019
a transaction requests out and one of

00:32:14,039 --> 00:32:17,669
your data nodes will become the

00:32:16,019 --> 00:32:19,559
transaction coordinator for this

00:32:17,669 --> 00:32:21,690
transaction so every single transaction

00:32:19,559 --> 00:32:24,539
always has a transaction coordinate

00:32:21,690 --> 00:32:26,429
coordinator but your transaction

00:32:24,539 --> 00:32:29,309
coordinator here is actually one of the

00:32:26,429 --> 00:32:31,429
nodes so every node has the capacity of

00:32:29,309 --> 00:32:34,379
becoming a transaction coordinator and

00:32:31,429 --> 00:32:36,869
well they will be and how this is

00:32:34,379 --> 00:32:39,110
selected how this exaction coordinator

00:32:36,869 --> 00:32:41,429
is selected depends there's a few ways

00:32:39,110 --> 00:32:43,080
there's a few ways the mysql server can

00:32:41,429 --> 00:32:45,240
select the transaction coordinator but

00:32:43,080 --> 00:32:47,039
the kind of the easiest to understand is

00:32:45,240 --> 00:32:50,399
to run round robin so there's a few

00:32:47,039 --> 00:32:52,889
options depending on whether the mysql

00:32:50,399 --> 00:32:55,499
server and data node processes live on

00:32:52,889 --> 00:32:58,200
the same machine or not and stuff but

00:32:55,499 --> 00:32:59,669
let's say that default I mean the

00:32:58,200 --> 00:33:02,460
easiest is just round robin it is just

00:32:59,669 --> 00:33:04,049
one of the nodes right you don't control

00:33:02,460 --> 00:33:05,249
it you can't control if you have simple

00:33:04,049 --> 00:33:08,009
queries you can try to control it to

00:33:05,249 --> 00:33:10,019
optimize stuff but but you don't have to

00:33:08,009 --> 00:33:13,249
worry about it so one of the nodes

00:33:10,019 --> 00:33:13,249
becomes a production coordinator

00:33:13,590 --> 00:33:20,730
right so this is the right transaction

00:33:16,750 --> 00:33:22,630
because a really difficult is simple so

00:33:20,730 --> 00:33:23,770
the first thing to do is that the

00:33:22,630 --> 00:33:25,690
deduction coordinator looks at your

00:33:23,770 --> 00:33:28,210
query which row are you going to write

00:33:25,690 --> 00:33:30,670
to and of course a production

00:33:28,210 --> 00:33:33,010
coordinator it knows the hash function

00:33:30,670 --> 00:33:35,200
so it knows in which partition these ro

00:33:33,010 --> 00:33:38,800
lives so it will send the request

00:33:35,200 --> 00:33:40,360
onwards to the node who is the primary

00:33:38,800 --> 00:33:43,030
it has the primary replica of this

00:33:40,360 --> 00:33:46,240
partition so let's say we did an update

00:33:43,030 --> 00:33:48,670
on a row that row exists in the green

00:33:46,240 --> 00:33:51,160
partition we send it to note 3 because

00:33:48,670 --> 00:33:54,370
note 3 has the primary replica of the

00:33:51,160 --> 00:34:01,870
green partition right everyone is okay

00:33:54,370 --> 00:34:03,010
so far yes if you're if you're right you

00:34:01,870 --> 00:34:06,970
mean you're writing based on something

00:34:03,010 --> 00:34:09,340
else i'll get i'll get to that but I'll

00:34:06,970 --> 00:34:11,320
get to that I'll get that it it makes a

00:34:09,340 --> 00:34:13,240
bit more complicated but basically the

00:34:11,320 --> 00:34:14,500
end result will be the same if you just

00:34:13,240 --> 00:34:19,390
make it a little more complicated

00:34:14,500 --> 00:34:21,520
transaction that's all right so this is

00:34:19,390 --> 00:34:25,149
a transaction where we were in base it

00:34:21,520 --> 00:34:27,340
on the primary key alright so the

00:34:25,149 --> 00:34:29,290
transaction goes to the primary to

00:34:27,340 --> 00:34:31,090
denote with the primary replica and this

00:34:29,290 --> 00:34:32,890
is where the locks are now taken so the

00:34:31,090 --> 00:34:35,440
primary replica will actually lock this

00:34:32,890 --> 00:34:36,850
row now because we're doing a right so

00:34:35,440 --> 00:34:39,460
the road needs to be locked to this is

00:34:36,850 --> 00:34:41,620
where it's locked once the operation is

00:34:39,460 --> 00:34:44,260
done here it goes it goes to the

00:34:41,620 --> 00:34:46,390
secondary same thing Rose a lot

00:34:44,260 --> 00:34:48,760
operation is performed then when the

00:34:46,390 --> 00:34:51,220
secondary is done it goes back to the

00:34:48,760 --> 00:34:54,669
transaction coordinator saying alright

00:34:51,220 --> 00:34:57,450
we've basically completed the operation

00:34:54,669 --> 00:34:59,890
but this is called a prepare phase

00:34:57,450 --> 00:35:02,170
because it's actually not validated yet

00:34:59,890 --> 00:35:05,410
it's not committed yet and the idea here

00:35:02,170 --> 00:35:07,510
is in order to commit the transaction we

00:35:05,410 --> 00:35:11,020
have to make sure it actually passes in

00:35:07,510 --> 00:35:13,570
both the primary and the secondary right

00:35:11,020 --> 00:35:16,450
so once it once it's passed then we can

00:35:13,570 --> 00:35:19,090
commit the transaction so we go back the

00:35:16,450 --> 00:35:21,580
other way around say okay validate this

00:35:19,090 --> 00:35:23,560
is action and it validates

00:35:21,580 --> 00:35:24,820
the primary validates and this is where

00:35:23,560 --> 00:35:26,530
the locks are released as well that's

00:35:24,820 --> 00:35:30,000
why we go the other way around so the

00:35:26,530 --> 00:35:32,830
locks are not released until until

00:35:30,000 --> 00:35:40,210
distraction has been validated also on

00:35:32,830 --> 00:35:42,520
the on the secondary what it could it's

00:35:40,210 --> 00:35:44,710
just that we want to basically the point

00:35:42,520 --> 00:35:46,420
here is to make the preparer face go a

00:35:44,710 --> 00:35:48,580
whole full circle before we validate

00:35:46,420 --> 00:35:49,930
that's basically the point here with the

00:35:48,580 --> 00:35:51,790
two-phase commit I mean it's a two phase

00:35:49,930 --> 00:35:53,800
commit protocol that's why the button

00:35:51,790 --> 00:35:56,320
but the point is to make sure that all

00:35:53,800 --> 00:35:58,870
of the replicas pass the value the

00:35:56,320 --> 00:36:04,060
preparer face and that's kind of why we

00:35:58,870 --> 00:36:06,450
do it in two phases yeah xxi uses some

00:36:04,060 --> 00:36:10,090
kind of version of two-phase commit I

00:36:06,450 --> 00:36:16,600
mean yeah so we have to prepare face and

00:36:10,090 --> 00:36:19,090
then the committee face and once it's

00:36:16,600 --> 00:36:20,980
once it's committed on the on the on the

00:36:19,090 --> 00:36:22,420
primary it goes back to instruction

00:36:20,980 --> 00:36:24,130
coordinator and then selected coordinate

00:36:22,420 --> 00:36:27,670
this is okay transaction was successful

00:36:24,130 --> 00:36:29,340
to to your SQL node so there's a few

00:36:27,670 --> 00:36:31,990
thing here to note this here one is

00:36:29,340 --> 00:36:35,110
there's a lot of messages this is one

00:36:31,990 --> 00:36:37,120
primary key right and every single one

00:36:35,110 --> 00:36:40,810
of these arrows are potentially network

00:36:37,120 --> 00:36:44,890
hops and they're sequential which means

00:36:40,810 --> 00:36:46,630
that the latency can be somewhat worse

00:36:44,890 --> 00:36:48,370
than than doing this in local memory on

00:36:46,630 --> 00:36:49,870
the machine right so that is the number

00:36:48,370 --> 00:36:52,900
one performance potential performance

00:36:49,870 --> 00:36:54,370
issue with cluster is latency right

00:36:52,900 --> 00:36:59,050
because you have to do all these steps

00:36:54,370 --> 00:37:02,950
in sequence and this is also where so I

00:36:59,050 --> 00:37:04,600
mean basically each each arrow here is

00:37:02,950 --> 00:37:05,830
as long as it takes for you to

00:37:04,600 --> 00:37:07,330
communicate between the machine so you

00:37:05,830 --> 00:37:08,980
can easily easily look at the network

00:37:07,330 --> 00:37:12,220
latency between machines and take that

00:37:08,980 --> 00:37:14,320
times 6 and you'll get what the time it

00:37:12,220 --> 00:37:16,210
will take to perform each operation plus

00:37:14,320 --> 00:37:18,120
of course what it does internally but

00:37:16,210 --> 00:37:21,280
but that's fairly fast compared to

00:37:18,120 --> 00:37:23,290
compared to network latency this also

00:37:21,280 --> 00:37:24,700
means that if you move you have one node

00:37:23,290 --> 00:37:27,460
in the US and you put the other one in

00:37:24,700 --> 00:37:29,590
China it's going to be very slow because

00:37:27,460 --> 00:37:31,440
going to be six times the communication

00:37:29,590 --> 00:37:35,339
within the US and China

00:37:31,440 --> 00:37:37,359
and this is for a simple operation so

00:37:35,339 --> 00:37:38,770
basically it means that you don't want

00:37:37,359 --> 00:37:40,660
to have your you normally don't wanna

00:37:38,770 --> 00:37:42,369
have a geographical distance between

00:37:40,660 --> 00:37:46,740
your nodes you wanted to be closed by

00:37:42,369 --> 00:37:46,740
network wise close by because of this

00:37:48,480 --> 00:37:54,220
that's one thing to notice and then I

00:37:52,240 --> 00:37:57,820
guess the second thing a second thing

00:37:54,220 --> 00:38:00,849
here is that in case of a failure during

00:37:57,820 --> 00:38:02,530
a transaction what happens and the

00:38:00,849 --> 00:38:05,470
answer it depends on which fate which

00:38:02,530 --> 00:38:08,290
stage the transaction is in so basically

00:38:05,470 --> 00:38:10,750
as long as the prepare face face has

00:38:08,290 --> 00:38:13,869
been completed your transaction will

00:38:10,750 --> 00:38:16,359
actually be completed the cluster nodes

00:38:13,869 --> 00:38:17,890
have protocols for taking over half done

00:38:16,359 --> 00:38:19,119
transactions and stuff like that so once

00:38:17,890 --> 00:38:21,250
the network partitioning protocol is

00:38:19,119 --> 00:38:23,680
done then they will look at ok which

00:38:21,250 --> 00:38:25,420
transactions are half done and which for

00:38:23,680 --> 00:38:27,250
food validated and stuff like that so

00:38:25,420 --> 00:38:29,680
basically all validate all transactions

00:38:27,250 --> 00:38:31,570
that have done the prepare circle will

00:38:29,680 --> 00:38:33,700
actually be validated transactions that

00:38:31,570 --> 00:38:35,710
are not done somewhere here where

00:38:33,700 --> 00:38:38,800
there's a where there's a failure will

00:38:35,710 --> 00:38:42,690
actually be aborted you will get a the

00:38:38,800 --> 00:38:42,690
client will get an error

00:38:49,430 --> 00:39:03,930
any questions about this right so that's

00:38:57,030 --> 00:39:05,070
a two-phase commit so so I already

00:39:03,930 --> 00:39:07,290
talked about this these two types of

00:39:05,070 --> 00:39:09,720
indexes I'm running out of time here so

00:39:07,290 --> 00:39:14,280
I'm gonna do this quickly the big thing

00:39:09,720 --> 00:39:15,750
to notice here is that it goes to

00:39:14,280 --> 00:39:19,410
cluster is because the data is

00:39:15,750 --> 00:39:22,200
distributed having a global index is

00:39:19,410 --> 00:39:24,060
actually not that easy because well how

00:39:22,200 --> 00:39:25,920
do you update how do you maintain it and

00:39:24,060 --> 00:39:28,860
stuff like that so that's why if you

00:39:25,920 --> 00:39:30,090
want to use an ordered index so ordered

00:39:28,860 --> 00:39:32,340
of course meaning that the structure

00:39:30,090 --> 00:39:34,350
doesn't you can do it use it to do range

00:39:32,340 --> 00:39:37,020
queries and stuff like that but the

00:39:34,350 --> 00:39:40,080
cluster does is that it creates locally

00:39:37,020 --> 00:39:44,700
index so each node we have it we have a

00:39:40,080 --> 00:39:49,290
tree index which is only covering the

00:39:44,700 --> 00:39:51,060
rows that exists on this node right this

00:39:49,290 --> 00:39:53,490
means that if you used if you use this

00:39:51,060 --> 00:39:55,230
index to search for rose you will have

00:39:53,490 --> 00:39:56,670
to launch this search on every single

00:39:55,230 --> 00:39:57,660
node because you don't know which node

00:39:56,670 --> 00:40:01,410
will actually have the rose and which

00:39:57,660 --> 00:40:02,970
won't so that's the drawback but the

00:40:01,410 --> 00:40:07,830
good part is quite easy to maintain and

00:40:02,970 --> 00:40:10,800
it doesn't cost a lot then there are

00:40:07,830 --> 00:40:12,360
unique hash indexes as well and they are

00:40:10,800 --> 00:40:16,770
implemented in the clusters hidden

00:40:12,360 --> 00:40:22,110
tables it's fairly complex way of doing

00:40:16,770 --> 00:40:25,080
it basically if you create unique hash

00:40:22,110 --> 00:40:27,960
index on a column the cluster will

00:40:25,080 --> 00:40:29,610
create a hidden table where the indexed

00:40:27,960 --> 00:40:31,160
column is the primary key and the

00:40:29,610 --> 00:40:33,630
primary key of the original table

00:40:31,160 --> 00:40:34,890
becomes the columns in the table and

00:40:33,630 --> 00:40:36,930
then it will easily do this

00:40:34,890 --> 00:40:39,360
transparently you won't see this but

00:40:36,930 --> 00:40:40,980
when you do a lookup using the unique

00:40:39,360 --> 00:40:42,990
hash index if you first do one look up

00:40:40,980 --> 00:40:44,880
in the unique hash index hidden table

00:40:42,990 --> 00:40:46,290
define the primary key values of the

00:40:44,880 --> 00:40:49,200
original table and then the second look

00:40:46,290 --> 00:40:51,970
up to find actual rose all right okay

00:40:49,200 --> 00:40:54,320
you will see how it works

00:40:51,970 --> 00:40:58,040
so basically internally the cluster

00:40:54,320 --> 00:41:00,470
supports for native operations when as a

00:40:58,040 --> 00:41:02,150
internal this is basically the engine

00:41:00,470 --> 00:41:04,730
the storage engine supports for

00:41:02,150 --> 00:41:08,450
operations and the mysql server has to

00:41:04,730 --> 00:41:10,610
transform anything you say in SQL the

00:41:08,450 --> 00:41:14,330
mysql server has to transform into these

00:41:10,610 --> 00:41:16,940
four operations right so if you do what

00:41:14,330 --> 00:41:18,710
you do i write a 9 table join with where

00:41:16,940 --> 00:41:21,260
clauses and whatnot the mysql server has

00:41:18,710 --> 00:41:25,130
to boil them down to this operation then

00:41:21,260 --> 00:41:26,660
combine them so hot somehow so the first

00:41:25,130 --> 00:41:30,320
operation is of course primary key

00:41:26,660 --> 00:41:32,600
operations so reads and writes the

00:41:30,320 --> 00:41:34,190
second is unique index operations or the

00:41:32,600 --> 00:41:36,050
next guns and full table scans and

00:41:34,190 --> 00:41:38,810
that's all that's the only thing to

00:41:36,050 --> 00:41:41,600
cluster support internally so everything

00:41:38,810 --> 00:41:42,950
else is a combination of this so I'm

00:41:41,600 --> 00:41:48,560
going to show now basically how these

00:41:42,950 --> 00:41:50,090
operations happen inside the cluster so

00:41:48,560 --> 00:41:54,470
first if you a primary key right we

00:41:50,090 --> 00:41:55,940
already saw this but here I only have

00:41:54,470 --> 00:42:00,290
the nodes I don't actually have a

00:41:55,940 --> 00:42:02,060
logical separation here so if you're a

00:42:00,290 --> 00:42:04,460
primary key right we contact the

00:42:02,060 --> 00:42:06,530
transaction coordinator this is actually

00:42:04,460 --> 00:42:09,470
coordinated then goes to so these all

00:42:06,530 --> 00:42:11,060
these things are blocks in some modules

00:42:09,470 --> 00:42:13,450
inside the data nodes each did not

00:42:11,060 --> 00:42:16,490
consist of modules and they kind of run

00:42:13,450 --> 00:42:17,810
independently inside a dinner and

00:42:16,490 --> 00:42:24,980
there's a messaging service between

00:42:17,810 --> 00:42:27,170
these these modules right right so the

00:42:24,980 --> 00:42:29,720
maximizing server contacted transaction

00:42:27,170 --> 00:42:31,700
coordinator module and you will see that

00:42:29,720 --> 00:42:34,370
when you run when you run multi-threaded

00:42:31,700 --> 00:42:37,700
a cluster so you'd run there's a nut

00:42:34,370 --> 00:42:42,110
milk 3d version of the cluster what you

00:42:37,700 --> 00:42:43,490
what you run more of these modules so in

00:42:42,110 --> 00:42:45,230
a multi-threaded data node you will have

00:42:43,490 --> 00:42:48,970
more transaction coordinators per node

00:42:45,230 --> 00:42:51,680
or more local quarry handlers per node

00:42:48,970 --> 00:42:54,320
right so you conduct a transaction

00:42:51,680 --> 00:42:56,030
coordinator then the deduction

00:42:54,320 --> 00:42:58,460
coordinator to contact the local query

00:42:56,030 --> 00:43:01,940
handler of the node where the where the

00:42:58,460 --> 00:43:04,400
road resides who then goes to the ACC

00:43:01,940 --> 00:43:05,080
block and the two block to acc block is

00:43:04,400 --> 00:43:06,490
where

00:43:05,080 --> 00:43:09,100
the primary key values are in the two

00:43:06,490 --> 00:43:12,460
block is where actual rows are so it's

00:43:09,100 --> 00:43:15,100
just two blocks handling data once

00:43:12,460 --> 00:43:18,850
that's done we go to the secondary do

00:43:15,100 --> 00:43:19,960
the same thing we go back to the

00:43:18,850 --> 00:43:23,680
transaction coordinator just say all

00:43:19,960 --> 00:43:25,990
right prepare face is done and then we

00:43:23,680 --> 00:43:27,370
do the circle backwards and validate the

00:43:25,990 --> 00:43:31,060
stuff right the same thing we just saw a

00:43:27,370 --> 00:43:33,670
moment ago except that here we have also

00:43:31,060 --> 00:43:37,240
the internal messages being done between

00:43:33,670 --> 00:43:42,640
the blocks and that's a primary key

00:43:37,240 --> 00:43:45,820
right if you're a primary key vide it's

00:43:42,640 --> 00:43:47,800
a lot simpler because we go to the

00:43:45,820 --> 00:43:49,420
deduction coordinator we go to the local

00:43:47,800 --> 00:43:52,090
query handler where the row is and

00:43:49,420 --> 00:43:55,930
that's it we find the road through the

00:43:52,090 --> 00:43:58,690
ACC module that has a primary key we go

00:43:55,930 --> 00:44:00,940
to the tup module two for two people

00:43:58,690 --> 00:44:02,650
actually where all the rows are and then

00:44:00,940 --> 00:44:05,080
we're done this data node will actually

00:44:02,650 --> 00:44:08,020
send the answer to the mysql server

00:44:05,080 --> 00:44:09,250
directly so we don't have to go back we

00:44:08,020 --> 00:44:10,450
don't have to go to the secondary we

00:44:09,250 --> 00:44:12,070
don't have to go back to the transaction

00:44:10,450 --> 00:44:17,760
coordinator we just in do this all

00:44:12,070 --> 00:44:17,760
straight to the mysql server right

00:44:19,170 --> 00:44:22,890
that's a primary QV so a primary key

00:44:21,210 --> 00:44:26,549
Reed is fairly optimized in my

00:44:22,890 --> 00:44:28,440
skullbuster and that's actually normally

00:44:26,549 --> 00:44:29,700
if you look at performance benchmarks

00:44:28,440 --> 00:44:31,770
for Michael clustering looks really good

00:44:29,700 --> 00:44:33,660
it's mostly primary key weeds that's

00:44:31,770 --> 00:44:40,260
what it's optimized for because there's

00:44:33,660 --> 00:44:41,730
really fast at primary weeds and in

00:44:40,260 --> 00:44:43,740
particular when you run multiple data

00:44:41,730 --> 00:44:45,390
nodes the whole point is with the

00:44:43,740 --> 00:44:48,930
primary key villages that you only need

00:44:45,390 --> 00:44:51,599
to access the data node with that row

00:44:48,930 --> 00:44:53,640
when is your primary key read which

00:44:51,599 --> 00:44:55,559
means if you have eight nodes you can

00:44:53,640 --> 00:44:57,660
actually run eight primary key reads at

00:44:55,559 --> 00:45:01,530
the same time I mean exactly at the same

00:44:57,660 --> 00:45:03,690
time because each node you only need to

00:45:01,530 --> 00:45:05,369
access the node with the row which is

00:45:03,690 --> 00:45:13,609
the cool feature with with with the

00:45:05,369 --> 00:45:15,809
primaries if you do a unique index read

00:45:13,609 --> 00:45:17,309
it's basically the same thing as doing

00:45:15,809 --> 00:45:19,710
two primary key weeds as I said before

00:45:17,309 --> 00:45:24,980
because unique index is implemented as a

00:45:19,710 --> 00:45:26,790
hidden table so it's the same as doing

00:45:24,980 --> 00:45:32,730
primary key rates if you want to do a

00:45:26,790 --> 00:45:35,930
rights you can actually unique index

00:45:32,730 --> 00:45:38,309
rights if you just use the unique index

00:45:35,930 --> 00:45:40,140
if you basically do the same thing in

00:45:38,309 --> 00:45:41,730
the first we read and then right values

00:45:40,140 --> 00:45:47,119
through a unique index so it's similar

00:45:41,730 --> 00:45:47,119
to a primary key right yeah

00:45:49,740 --> 00:45:55,150
so again it from sequel perfectly it

00:45:52,510 --> 00:45:56,830
looks the same you're right you say you

00:45:55,150 --> 00:45:58,540
have a unique index on a column and you

00:45:56,830 --> 00:46:00,940
do a lookup where is it where a where

00:45:58,540 --> 00:46:02,770
clause on that column and the mysql

00:46:00,940 --> 00:46:05,380
server will then transform this into a

00:46:02,770 --> 00:46:11,200
unique index operation on the cluster

00:46:05,380 --> 00:46:12,430
level it has to be in equality yes

00:46:11,200 --> 00:46:16,480
that's why it's called unique key I mean

00:46:12,430 --> 00:46:18,520
that's why it's only unique now if you

00:46:16,480 --> 00:46:20,859
use a range gun unique index is useless

00:46:18,520 --> 00:46:22,480
because the hash index so then you will

00:46:20,859 --> 00:46:26,410
have to have ordered indexes or done

00:46:22,480 --> 00:46:28,210
otherwise it's full table scans so I

00:46:26,410 --> 00:46:32,380
mean the unique hash enix is a bit

00:46:28,210 --> 00:46:34,630
peculiar for the cluster but but it's

00:46:32,380 --> 00:46:36,849
that it has to be unique first of all so

00:46:34,630 --> 00:46:39,880
you can't even have a collisions to

00:46:36,849 --> 00:46:41,349
create a unique cash index so it's not

00:46:39,880 --> 00:46:44,080
that often ajumma you can actually

00:46:41,349 --> 00:46:46,540
create one so most of your indexes in

00:46:44,080 --> 00:46:48,609
you will have the primary key and then

00:46:46,540 --> 00:46:53,170
you'll have ordered indexes on the rest

00:46:48,609 --> 00:46:55,270
of the column most of the time so if you

00:46:53,170 --> 00:46:57,940
have an ordered index read what happens

00:46:55,270 --> 00:47:00,369
well the deduction coordinator will have

00:46:57,940 --> 00:47:02,140
to contact all of the data nodes here it

00:47:00,369 --> 00:47:03,869
is only two but if you have eight it

00:47:02,140 --> 00:47:07,480
will contact all of the eight nodes and

00:47:03,869 --> 00:47:09,520
each node will then use the local index

00:47:07,480 --> 00:47:11,890
to find a rose that match on this node

00:47:09,520 --> 00:47:13,270
and send them over so the cool thing

00:47:11,890 --> 00:47:16,119
with this is that it's actually done in

00:47:13,270 --> 00:47:17,410
parallel as a b'day sequence so you

00:47:16,119 --> 00:47:19,030
don't have to wait for node one to send

00:47:17,410 --> 00:47:20,109
results and then you go to know too but

00:47:19,030 --> 00:47:22,480
so the contact transaction coordinator

00:47:20,109 --> 00:47:25,480
contacts all of the nodes and they

00:47:22,480 --> 00:47:27,010
independently work so I guess similar to

00:47:25,480 --> 00:47:29,380
I don't know I'm not produced or

00:47:27,010 --> 00:47:31,540
anything that's distributed basically so

00:47:29,380 --> 00:47:33,339
they independently do their look up I

00:47:31,540 --> 00:47:35,050
send the results and then the mask is

00:47:33,339 --> 00:47:37,750
server here gets the results and then

00:47:35,050 --> 00:47:39,460
make sure that in a buffer and basically

00:47:37,750 --> 00:47:41,859
waits until all the nodes have answers

00:47:39,460 --> 00:47:44,280
and the answered and then it creates

00:47:41,859 --> 00:47:44,280
result

00:47:45,080 --> 00:47:51,690
can you yes but they're done by the

00:47:47,310 --> 00:47:54,000
MySQL server but my aggregation is

00:47:51,690 --> 00:47:55,500
always done by the MySQL server so

00:47:54,000 --> 00:47:59,280
cluster doesn't cost doesn't have any

00:47:55,500 --> 00:48:00,480
internal aggregation functions but but

00:47:59,280 --> 00:48:03,920
this would still be fast because you're

00:48:00,480 --> 00:48:03,920
using the index to access to Rose right

00:48:03,980 --> 00:48:08,460
well if you do a full table scan it's

00:48:06,540 --> 00:48:09,660
actually the same thing except that you

00:48:08,460 --> 00:48:15,900
don't have any index to find rose you

00:48:09,660 --> 00:48:19,950
just send everything right what's not

00:48:15,900 --> 00:48:23,550
said here is that MySQL has something

00:48:19,950 --> 00:48:25,440
called a push down condition so

00:48:23,550 --> 00:48:28,740
basically if you have we're into a full

00:48:25,440 --> 00:48:31,020
table scan with a where clause the where

00:48:28,740 --> 00:48:32,970
clause is actually pushed to the data

00:48:31,020 --> 00:48:35,880
node so they actually filter the Rose

00:48:32,970 --> 00:48:37,830
already here so it didn't send

00:48:35,880 --> 00:48:39,960
everything to the MySQL server and this

00:48:37,830 --> 00:48:41,310
I'm pointing this out because this was

00:48:39,960 --> 00:48:44,040
not always the case in the first version

00:48:41,310 --> 00:48:45,690
of cluster this didn't exist and a

00:48:44,040 --> 00:48:48,300
cluster had the functionality but it

00:48:45,690 --> 00:48:49,500
wasn't used so if you did a filter if

00:48:48,300 --> 00:48:51,660
you do the full table scan with a where

00:48:49,500 --> 00:48:54,330
clause every single notes and everything

00:48:51,660 --> 00:48:55,650
they've got which could take a view on

00:48:54,330 --> 00:48:56,880
time because it's over the network and

00:48:55,650 --> 00:48:59,190
then the MySQL server had to do the

00:48:56,880 --> 00:49:01,200
filtering which made a full table scan

00:48:59,190 --> 00:49:03,390
quiz really really slow because you have

00:49:01,200 --> 00:49:04,860
to send everything over the network but

00:49:03,390 --> 00:49:06,510
because now you can now you're actually

00:49:04,860 --> 00:49:08,490
this is on by default now you actually

00:49:06,510 --> 00:49:09,630
filter them on the node so you don't

00:49:08,490 --> 00:49:12,470
have to send everything on the network

00:49:09,630 --> 00:49:12,470
which is good

00:49:14,319 --> 00:49:18,969
and that's basically it these four

00:49:17,170 --> 00:49:21,069
operations is only thing clusters

00:49:18,969 --> 00:49:25,739
support supports internally and

00:49:21,069 --> 00:49:25,739
everything else is a combination right

00:49:26,430 --> 00:49:30,999
so some optimizations you can do is

00:49:29,440 --> 00:49:32,920
first of all condition pushed on I just

00:49:30,999 --> 00:49:34,150
mentioned because you have to then you

00:49:32,920 --> 00:49:36,390
don't have to send everything you send

00:49:34,150 --> 00:49:41,440
less data and this is done automatically

00:49:36,390 --> 00:49:44,019
batching why well because everything is

00:49:41,440 --> 00:49:46,630
done in a sequence the latency is a

00:49:44,019 --> 00:49:48,729
problem if you have 100 queries let's

00:49:46,630 --> 00:49:50,049
say a thousand queries per second okay

00:49:48,729 --> 00:49:54,430
maybe that's too much but 200 queries

00:49:50,049 --> 00:49:58,349
per second if you send each operation is

00:49:54,430 --> 00:50:00,279
each request individually each

00:49:58,349 --> 00:50:01,449
individual will have a sequence and they

00:50:00,279 --> 00:50:02,920
will be done in sequence and it will

00:50:01,449 --> 00:50:04,809
take time because it network ops in

00:50:02,920 --> 00:50:06,579
between but you can do is you can batch

00:50:04,809 --> 00:50:09,549
the queries send a bunch of of

00:50:06,579 --> 00:50:11,019
transactions as one to the transaction

00:50:09,549 --> 00:50:13,569
coordinator and stuff and Michael

00:50:11,019 --> 00:50:16,509
actually has does this automatically say

00:50:13,569 --> 00:50:19,119
batches quays has a small window it

00:50:16,509 --> 00:50:20,650
waits for wait for this window and then

00:50:19,119 --> 00:50:24,130
it batches all the quest the same time

00:50:20,650 --> 00:50:25,989
so the individual query might actually

00:50:24,130 --> 00:50:28,749
be a bit slower because it had to wait

00:50:25,989 --> 00:50:31,660
the a few microseconds before the batch

00:50:28,749 --> 00:50:33,219
window was full however the overall

00:50:31,660 --> 00:50:34,959
throughput of the cluster increases

00:50:33,219 --> 00:50:37,180
because you can do more of these at the

00:50:34,959 --> 00:50:39,459
same time so the cluster is all about

00:50:37,180 --> 00:50:40,930
throughput throughput will be great but

00:50:39,459 --> 00:50:42,339
in some cases individual queries might

00:50:40,930 --> 00:50:44,469
be slow because of the latency between

00:50:42,339 --> 00:50:49,239
the network ops but the throughput will

00:50:44,469 --> 00:50:51,099
be great all right but batching in most

00:50:49,239 --> 00:50:56,739
cases will make cluster better work

00:50:51,099 --> 00:50:58,900
better to feel much better so one of the

00:50:56,739 --> 00:51:01,049
problems with cluster previously until

00:50:58,900 --> 00:51:05,199
the latest version was complex queries

00:51:01,049 --> 00:51:08,739
so for example a simple join so here we

00:51:05,199 --> 00:51:13,329
have a joint of two table we're joining

00:51:08,739 --> 00:51:18,099
them on something which is a primary key

00:51:13,329 --> 00:51:19,599
in the second table and it is and we

00:51:18,099 --> 00:51:21,339
have a where clause on a column on the

00:51:19,599 --> 00:51:22,619
first table right which could be the

00:51:21,339 --> 00:51:25,779
primary key or something

00:51:22,619 --> 00:51:27,759
or it could be aware class where it's

00:51:25,779 --> 00:51:31,059
arranged whatever it is so the problem

00:51:27,759 --> 00:51:33,460
here is that the way mysql used to joins

00:51:31,059 --> 00:51:35,829
is mysql had one way of doing joins and

00:51:33,460 --> 00:51:38,710
one way only and that's nested loop

00:51:35,829 --> 00:51:40,660
joints which is basically for loops

00:51:38,710 --> 00:51:44,049
nested for loops each table will have

00:51:40,660 --> 00:51:46,390
its own for loop and then we so we start

00:51:44,049 --> 00:51:48,460
by looking at one we'd get one row from

00:51:46,390 --> 00:51:50,259
the last table then we go start looking

00:51:48,460 --> 00:51:52,599
all combination of rows for this table

00:51:50,259 --> 00:51:55,119
let me move up to back one step and get

00:51:52,599 --> 00:51:57,249
the combination of avoir so the problem

00:51:55,119 --> 00:51:59,859
with this for cluster is because it's

00:51:57,249 --> 00:52:02,920
done in sequence every time there's a

00:51:59,859 --> 00:52:04,390
network hop in between so you can

00:52:02,920 --> 00:52:07,900
imagine if you have ten tables with

00:52:04,390 --> 00:52:09,960
millions of rows you do join I mean the

00:52:07,900 --> 00:52:12,609
operation might be fast but you add

00:52:09,960 --> 00:52:16,420
network latency between each operation

00:52:12,609 --> 00:52:18,609
which means you know a few a few hundred

00:52:16,420 --> 00:52:20,739
thousand times milliseconds means a lot

00:52:18,609 --> 00:52:25,900
of seconds so joints could be really

00:52:20,739 --> 00:52:27,670
really slow in a cluster another kind of

00:52:25,900 --> 00:52:31,359
fundamental flaw with the cluster for

00:52:27,670 --> 00:52:33,969
until the until this very 7.2 so

00:52:31,359 --> 00:52:36,400
basically join every type of join would

00:52:33,969 --> 00:52:41,859
be cut into these steps and you would be

00:52:36,400 --> 00:52:45,039
latency between them 7.2 so the latest

00:52:41,859 --> 00:52:48,249
GE use of cluster added basically one

00:52:45,039 --> 00:52:50,559
main major improvement which is that

00:52:48,249 --> 00:52:53,049
operations can be linked on the data

00:52:50,559 --> 00:52:54,849
nodes so this means that these four

00:52:53,049 --> 00:52:57,849
operations we saw the native operations

00:52:54,849 --> 00:52:59,969
there's still the same however what you

00:52:57,849 --> 00:53:01,839
can do is that you can combine

00:52:59,969 --> 00:53:05,979
operations so that you say that all

00:53:01,839 --> 00:53:07,420
right I only this operation and based on

00:53:05,979 --> 00:53:09,789
the result on this operation I didn't

00:53:07,420 --> 00:53:11,739
want to do dis oppression so previously

00:53:09,789 --> 00:53:13,869
you can only do one operation at a time

00:53:11,739 --> 00:53:16,359
or you could match them but the results

00:53:13,869 --> 00:53:18,609
could not be linked which means that for

00:53:16,359 --> 00:53:21,309
example if I do a join where I look up

00:53:18,609 --> 00:53:22,630
one row in one table and then based on

00:53:21,309 --> 00:53:24,940
the row I find in this table I will look

00:53:22,630 --> 00:53:27,640
up another another table I had you know

00:53:24,940 --> 00:53:29,140
get the results process them in the SQL

00:53:27,640 --> 00:53:32,410
node and then send them back now I can

00:53:29,140 --> 00:53:34,059
actually do this on on the data node so

00:53:32,410 --> 00:53:35,770
I say that okay these two will be linked

00:53:34,059 --> 00:53:40,780
get this result and then do

00:53:35,770 --> 00:53:42,280
separation and that has in many cases

00:53:40,780 --> 00:53:45,990
improve the joint performance quite a

00:53:42,280 --> 00:53:47,920
bit for cluster so that's a cool thing

00:53:45,990 --> 00:53:50,770
there are some limitations to the

00:53:47,920 --> 00:53:52,420
current implementation for example as

00:53:50,770 --> 00:53:55,390
long as you only use primary key

00:53:52,420 --> 00:53:59,130
operations this will work and you can

00:53:55,390 --> 00:54:01,390
combine the primary operations with one

00:53:59,130 --> 00:54:03,430
ordered or full table scan if you have

00:54:01,390 --> 00:54:06,010
more than one order index of full table

00:54:03,430 --> 00:54:09,700
scans then you cannot use is linking

00:54:06,010 --> 00:54:13,270
anymore and it won't be fast but I've

00:54:09,700 --> 00:54:15,040
seen join improvements of actually over

00:54:13,270 --> 00:54:21,640
a hundred so one joined us over 100

00:54:15,040 --> 00:54:28,530
times faster innocent again no it

00:54:21,640 --> 00:54:28,530
doesn't assume anything yeah so

00:54:30,589 --> 00:54:33,900
well if you're still get in because you

00:54:32,609 --> 00:54:35,670
don't have to send the results back to

00:54:33,900 --> 00:54:36,869
the mysql server so i mean that's kind

00:54:35,670 --> 00:54:38,369
of the problem previous you have to send

00:54:36,869 --> 00:54:41,550
every single middle step had to be sent

00:54:38,369 --> 00:54:43,349
through my SQL server so now it would be

00:54:41,550 --> 00:54:44,970
communication between the data know the

00:54:43,349 --> 00:54:47,150
look the transaction coordinator will

00:54:44,970 --> 00:54:49,890
will coordinate this instead of the

00:54:47,150 --> 00:54:51,839
mysql server so it's less network ops

00:54:49,890 --> 00:54:53,760
and of course for all the rows that are

00:54:51,839 --> 00:54:57,270
on the same node it's even faster

00:54:53,760 --> 00:54:59,070
because it's a local messages so it will

00:54:57,270 --> 00:55:03,690
make it faster in all cases and really

00:54:59,070 --> 00:55:05,369
fast in many and but not all and you can

00:55:03,690 --> 00:55:08,010
actually improve the inferior you can

00:55:05,369 --> 00:55:09,720
actually help this because as I said the

00:55:08,010 --> 00:55:14,070
partitioning is by default the primary

00:55:09,720 --> 00:55:17,339
key but you can change partitioning for

00:55:14,070 --> 00:55:18,720
some tables for example if you have a

00:55:17,339 --> 00:55:20,369
table with a primary key you have

00:55:18,720 --> 00:55:22,619
another table with the composite primary

00:55:20,369 --> 00:55:24,240
key where one of the columns is the

00:55:22,619 --> 00:55:25,470
primary key of the first table you can

00:55:24,240 --> 00:55:28,290
actually change the partitioning of the

00:55:25,470 --> 00:55:34,980
second table to be only of the same

00:55:28,290 --> 00:55:36,390
color so that for example let's find

00:55:34,980 --> 00:55:38,940
something quickly let's say you have a

00:55:36,390 --> 00:55:40,619
social network you have accounts and you

00:55:38,940 --> 00:55:44,310
have accounts the friends of each

00:55:40,619 --> 00:55:46,910
account right in a secondary table so

00:55:44,310 --> 00:55:49,619
you can have the secondary table to be

00:55:46,910 --> 00:55:52,260
to be partitioned only on the on the

00:55:49,619 --> 00:55:53,550
account part not on the friend not on

00:55:52,260 --> 00:55:56,520
the whole combination of account and

00:55:53,550 --> 00:55:58,530
friend which means that my max account

00:55:56,520 --> 00:56:00,210
in the secondary table all the rows

00:55:58,530 --> 00:56:01,950
containing my friends will be on the

00:56:00,210 --> 00:56:05,700
same partition as my account so i can

00:56:01,950 --> 00:56:07,859
get my account and the list of my

00:56:05,700 --> 00:56:09,270
friends on one partition then if i want

00:56:07,859 --> 00:56:10,770
to go more details about my friends then

00:56:09,270 --> 00:56:12,330
i have to go elsewhere but basically

00:56:10,770 --> 00:56:14,190
i'll get the basics from just one

00:56:12,330 --> 00:56:20,220
partition which means stuff like that

00:56:14,190 --> 00:56:24,570
you can do to make it even fast right so

00:56:20,220 --> 00:56:27,390
let's look at a simple query so the same

00:56:24,570 --> 00:56:31,109
query we just saw and we can see with

00:56:27,390 --> 00:56:33,540
explain you guys know explain good so we

00:56:31,109 --> 00:56:36,270
will explain you actually see stuff here

00:56:33,540 --> 00:56:38,010
does anyone see this so in the extra

00:56:36,270 --> 00:56:40,380
column you see stuff and I've actually

00:56:38,010 --> 00:56:41,430
magnified it so I removed all the other

00:56:40,380 --> 00:56:42,900
columns

00:56:41,430 --> 00:56:44,660
right we only have the xicon so the

00:56:42,900 --> 00:56:48,089
other columns would just show normal

00:56:44,660 --> 00:56:51,089
normal explain stuff but in the extra

00:56:48,089 --> 00:56:57,290
column you actually see this stuff that

00:56:51,089 --> 00:56:57,290
has to do with the cluster join linkage

00:56:57,440 --> 00:57:03,180
so here I have two different two

00:56:59,790 --> 00:57:05,880
different two different queries one is

00:57:03,180 --> 00:57:07,559
doing a primary key primary key look up

00:57:05,880 --> 00:57:11,280
so very efficient and the other one is

00:57:07,559 --> 00:57:14,250
doing a an order index can combine with

00:57:11,280 --> 00:57:19,109
a primary key look up and both of these

00:57:14,250 --> 00:57:21,720
can can can use this this new feature of

00:57:19,109 --> 00:57:29,579
7.2 so you get this stuff in the extra

00:57:21,720 --> 00:57:32,540
call so far so good so basically if you

00:57:29,579 --> 00:57:35,940
haven't used cluster before start at 72

00:57:32,540 --> 00:57:39,030
don't go and use the versions that don't

00:57:35,940 --> 00:57:41,220
have this feature all right is there

00:57:39,030 --> 00:57:44,099
anything else well so if you use the

00:57:41,220 --> 00:57:45,930
mouth red version so the customer comes

00:57:44,099 --> 00:57:48,329
in to order data nodes come in two

00:57:45,930 --> 00:57:51,000
versions this one that's single threaded

00:57:48,329 --> 00:57:52,710
and one else multi-threaded if used

00:57:51,000 --> 00:57:56,940
multi-server version actually everything

00:57:52,710 --> 00:58:00,299
you saw up to now is wrong well actually

00:57:56,940 --> 00:58:03,390
I did not exactly but if used

00:58:00,299 --> 00:58:08,059
multithread version basically the notion

00:58:03,390 --> 00:58:08,059
of data node becomes a bit fluid because

00:58:08,299 --> 00:58:12,450
in the multi-threaded version you will

00:58:10,530 --> 00:58:13,859
have even it launches is that it

00:58:12,450 --> 00:58:16,650
launches several transaction

00:58:13,859 --> 00:58:18,540
coordinators per node process several

00:58:16,650 --> 00:58:22,020
local quarry handlers permit process and

00:58:18,540 --> 00:58:24,270
so forth however the tables are

00:58:22,020 --> 00:58:25,680
partitioned based on the amount of local

00:58:24,270 --> 00:58:28,109
query handlers not the amount of data

00:58:25,680 --> 00:58:29,400
nodes right so you could just change how

00:58:28,109 --> 00:58:31,410
many partitions you have and stuff like

00:58:29,400 --> 00:58:33,890
that so if you're using the

00:58:31,410 --> 00:58:36,660
multi-threaded version of MySQL Uster

00:58:33,890 --> 00:58:38,460
you will actually get a lot more

00:58:36,660 --> 00:58:42,540
partitions than what you have data nodes

00:58:38,460 --> 00:58:44,369
and in 7.2 the latest well this is not

00:58:42,540 --> 00:58:47,329
the latest anymore but basically you can

00:58:44,369 --> 00:58:50,339
have up to 36 threads per data node and

00:58:47,329 --> 00:58:53,369
you can actually specify how you want

00:58:50,339 --> 00:58:54,030
these threads to be divided amongst the

00:58:53,369 --> 00:58:55,560
different blocks

00:58:54,030 --> 00:58:58,020
say okay I want 10 transaction

00:58:55,560 --> 00:58:59,370
coordinators per node and 20 local query

00:58:58,020 --> 00:59:02,490
handlers for example or something like

00:58:59,370 --> 00:59:06,560
that so you can really confined June hi

00:59:02,490 --> 00:59:06,560
one this multi-threaded thing to work

00:59:09,500 --> 00:59:13,680
right so it makes it even more complex

00:59:12,120 --> 00:59:17,360
but again all this is transparent you

00:59:13,680 --> 00:59:20,070
don't you mean you don't see any of this

00:59:17,360 --> 00:59:22,110
it just helps in understanding what goes

00:59:20,070 --> 00:59:24,810
on and why cluster is slow in some case

00:59:22,110 --> 00:59:28,350
and whites not in others all right so to

00:59:24,810 --> 00:59:30,420
summarize where does my SQ feet cluster

00:59:28,350 --> 00:59:33,690
fit well high demands availability so

00:59:30,420 --> 00:59:35,460
this is still by far the solution with

00:59:33,690 --> 00:59:36,590
the highest availability out there so if

00:59:35,460 --> 00:59:39,870
you need really high availability

00:59:36,590 --> 00:59:42,180
cluster is the only one that provides

00:59:39,870 --> 00:59:43,680
five nines it's also the only one who

00:59:42,180 --> 00:59:45,180
actually scales right because of the

00:59:43,680 --> 00:59:46,890
distribution of the data it

00:59:45,180 --> 00:59:49,920
automatically scales rights primary key

00:59:46,890 --> 00:59:53,160
operation rights will always be just to

00:59:49,920 --> 00:59:54,660
to the node where data is so it actually

00:59:53,160 --> 00:59:59,130
has true right scalability all the

00:59:54,660 --> 01:00:01,110
others don't and the problem is if you

00:59:59,130 --> 01:00:03,840
have a fully normalized normalized

01:00:01,110 --> 01:00:05,280
schema with lots of data well then you

01:00:03,840 --> 01:00:07,350
will run up into these issues with

01:00:05,280 --> 01:00:08,820
latency because you have to join most of

01:00:07,350 --> 01:00:11,430
tables and stuff like that so that's

01:00:08,820 --> 01:00:14,010
when the perhaps does not work so well

01:00:11,430 --> 01:00:16,350
of course the data should also more or

01:00:14,010 --> 01:00:18,660
less fit into memory so if you're having

01:00:16,350 --> 01:00:19,980
terabytes of data Michael cluster is

01:00:18,660 --> 01:00:23,310
probably not the right solution for you

01:00:19,980 --> 01:00:24,990
but memory these days is not a big

01:00:23,310 --> 01:00:29,940
problem so you can have several hundred

01:00:24,990 --> 01:00:32,310
gigs of data and it was to fit so one

01:00:29,940 --> 01:00:34,080
one big thing also when it doesn't fit

01:00:32,310 --> 01:00:36,090
is the network because everything is

01:00:34,080 --> 01:00:38,100
done on the network so you have to

01:00:36,090 --> 01:00:39,900
control be able to control the network

01:00:38,100 --> 01:00:41,550
you want to have a dedicated network

01:00:39,900 --> 01:00:43,910
first of all for cluster internal

01:00:41,550 --> 01:00:47,790
communication you don't want to add

01:00:43,910 --> 01:00:48,870
random HTTP access stuff going on the

01:00:47,790 --> 01:00:50,760
same network you wanna have a dedicated

01:00:48,870 --> 01:00:53,100
net for just for the cluster internal

01:00:50,760 --> 01:00:55,080
communication and this is also why

01:00:53,100 --> 01:00:56,490
you're the cluster does not fit into the

01:00:55,080 --> 01:00:59,930
cloud so well because you don't really

01:00:56,490 --> 01:00:59,930
control the network in the cloud

01:01:01,390 --> 01:01:05,230
and at the moment you don't it does not

01:01:03,460 --> 01:01:07,690
support foreign Keys it supports blobs

01:01:05,230 --> 01:01:09,880
but not very efficiently so you have to

01:01:07,690 --> 01:01:13,180
if you want to use blobs and the cluster

01:01:09,880 --> 01:01:15,910
you can do it but beware that it will be

01:01:13,180 --> 01:01:17,170
slow and it basically you should store

01:01:15,910 --> 01:01:25,300
them on disc and nothing memory if you

01:01:17,170 --> 01:01:26,980
do and that's about it is there any

01:01:25,300 --> 01:01:28,450
questions I'll be here of course now and

01:01:26,980 --> 01:01:29,590
i'll be at the booth but otherwise

01:01:28,450 --> 01:01:34,890
you're going to send me an email or

01:01:29,590 --> 01:01:34,890
something any questions right now yes

01:01:43,520 --> 01:01:51,240
yeah i mean the cluster will most cases

01:01:48,060 --> 01:01:55,830
be slower but not significantly slower

01:01:51,240 --> 01:01:58,110
but it will be slower yeah I mean we're

01:01:55,830 --> 01:02:00,150
a cluster will win and end it will by

01:01:58,110 --> 01:02:03,660
far beat beat in a DB is when you start

01:02:00,150 --> 01:02:05,100
having more than two nodes and again we

01:02:03,660 --> 01:02:14,340
need these simple operations like you do

01:02:05,100 --> 01:02:15,690
because the throughput well the thing

01:02:14,340 --> 01:02:18,120
with classes that you can have multiple

01:02:15,690 --> 01:02:20,520
MySQL servers so and that's where

01:02:18,120 --> 01:02:24,240
exactly in a DB we run into problems in

01:02:20,520 --> 01:02:25,530
a DB won't be able to utilize I mean the

01:02:24,240 --> 01:02:26,760
fact that you can't parallel complete to

01:02:25,530 --> 01:02:30,060
do its stuff in parallel on the cluster

01:02:26,760 --> 01:02:33,660
I mean they did benchmarks recently

01:02:30,060 --> 01:02:35,010
where they got up to what did I say 1

01:02:33,660 --> 01:02:38,490
billion queries per minute which is

01:02:35,010 --> 01:02:42,240
basically whatever it is 27 I mean

01:02:38,490 --> 01:02:44,730
something 20 million queries per second

01:02:42,240 --> 01:02:45,840
I mean it's weeds and stuff but still 20

01:02:44,730 --> 01:02:49,260
million per second it's pretty

01:02:45,840 --> 01:02:51,810
impressive even writes they were rights

01:02:49,260 --> 01:02:53,670
there were two million writes per second

01:02:51,810 --> 01:02:55,320
so to me I mean primary key operation is

01:02:53,670 --> 01:02:56,850
still two million writes per second

01:02:55,320 --> 01:02:59,670
that's pretty impressive and it's with

01:02:56,850 --> 01:03:01,860
one just one cluster so I mean you get

01:02:59,670 --> 01:03:06,290
to stuff for you it's unbeatable in

01:03:01,860 --> 01:03:06,290
throughput but but

01:03:13,150 --> 01:03:18,920
yes these ones are like if you send me

01:03:17,150 --> 01:03:20,840
an email or something I can send you the

01:03:18,920 --> 01:03:21,800
links i don't have them here on me but i

01:03:20,840 --> 01:03:33,470
can send you some links of some

01:03:21,800 --> 01:03:35,300
benchmarks yes yeah yeah yeah but I mean

01:03:33,470 --> 01:03:36,950
the problem is that it depends so

01:03:35,300 --> 01:03:40,340
heavily on the types of queries you use

01:03:36,950 --> 01:03:42,290
right I mean simple queries will this is

01:03:40,340 --> 01:03:43,610
really excels and then when you start

01:03:42,290 --> 01:03:45,200
going to more complex stuff then you

01:03:43,610 --> 01:03:47,690
start running issues with latency of

01:03:45,200 --> 01:03:56,200
messaging waiting for waiting for some

01:03:47,690 --> 01:03:56,200
note I mean the problems yeah

01:04:00,059 --> 01:04:11,859
yeah that's this is doesn't it's not

01:04:02,710 --> 01:04:14,349
good for us yeah yeah definitely I mean

01:04:11,859 --> 01:04:16,270
in theory if you think about using you

01:04:14,349 --> 01:04:18,910
if you think about using a key value

01:04:16,270 --> 01:04:20,770
some kind of key value store this is

01:04:18,910 --> 01:04:24,040
will be better because it will be

01:04:20,770 --> 01:04:26,980
forgiving the same performance with high

01:04:24,040 --> 01:04:28,660
availability and you get the SQL acid

01:04:26,980 --> 01:04:36,819
stuff which you don't always give it the

01:04:28,660 --> 01:04:38,500
key value stores it's durable well I

01:04:36,819 --> 01:04:41,140
mean it's just my SQL queries so it's

01:04:38,500 --> 01:04:42,400
it's you I mean if you send mysql that's

01:04:41,140 --> 01:04:43,960
that's the beauty of it it's just my

01:04:42,400 --> 01:04:45,700
squirrel queries but behind us behind

01:04:43,960 --> 01:04:48,400
the scenes it's the is this thing the

01:04:45,700 --> 01:04:50,290
problem is that it's not the easiest to

01:04:48,400 --> 01:04:51,819
administer and control I mean it's a bit

01:04:50,290 --> 01:05:04,059
more complicated than setting up

01:04:51,819 --> 01:05:05,470
something simple yeah yeah I mean we

01:05:04,059 --> 01:05:08,170
have customers who use this for storing

01:05:05,470 --> 01:05:09,700
just session data and things that stuff

01:05:08,170 --> 01:05:14,020
like simple really simple things but

01:05:09,700 --> 01:05:15,369
they just have so many they just have so

01:05:14,020 --> 01:05:17,500
many simultaneous sessions that they

01:05:15,369 --> 01:05:21,390
need something that scales and they use

01:05:17,500 --> 01:05:21,390
it store session data like the cluster

01:05:22,349 --> 01:05:30,839
yeah yeah well I'm available for

01:05:26,380 --> 01:05:30,839
questions than it answered thank you

01:05:37,070 --> 01:05:43,550
how's that sigh every way this is the

01:05:40,250 --> 01:05:45,710
way to better utilize all your resources

01:05:43,550 --> 01:05:49,190
and it makes managing all your resources

01:05:45,710 --> 01:05:53,020
pretty easy all of the innovation is

01:05:49,190 --> 01:05:56,510
happening in open source the

01:05:53,020 --> 01:05:58,340
collaborative nature and of the you know

01:05:56,510 --> 01:06:00,650
of the community and the speed at which

01:05:58,340 --> 01:06:02,420
these are these you know these these

01:06:00,650 --> 01:06:04,730
deficiencies these bugs are getting

01:06:02,420 --> 01:06:07,580
discovered and then fixed is it like

01:06:04,730 --> 01:06:10,580
that really shows the power of the of

01:06:07,580 --> 01:06:13,030
the open source community it is global

01:06:10,580 --> 01:06:16,580
and it's definitely because of the users

01:06:13,030 --> 01:06:22,550
community people are extremely friendly

01:06:16,580 --> 01:06:24,290
and always ready to help if you go on

01:06:22,550 --> 01:06:26,480
tire see any day you'll see these guys

01:06:24,290 --> 01:06:29,120
helping each other out and they're all

01:06:26,480 --> 01:06:30,800
doing it like in a selfless manner the

01:06:29,120 --> 01:06:33,820
product is transparent for everyone

01:06:30,800 --> 01:06:36,980
everyone can look at the code base

01:06:33,820 --> 01:06:39,220
everyone can see how cloud that is being

01:06:36,980 --> 01:06:44,720
built nothing nothing is proprietary

01:06:39,220 --> 01:06:47,330
everything is open in many ways it's

01:06:44,720 --> 01:06:51,830
absolutely vital to the the unborn

01:06:47,330 --> 01:06:56,030
health plan stack the most exciting

01:06:51,830 --> 01:06:58,880
event in recent memory for me was our

01:06:56,030 --> 01:07:01,519
first developer boot camp

01:06:58,880 --> 01:07:04,160
and our call gave people I gave you two

01:07:01,519 --> 01:07:08,119
weeks notice to come attend I was

01:07:04,160 --> 01:07:12,289
expecting 25 or 30 people so we ended up

01:07:08,119 --> 01:07:15,140
with 87 people and had to go get more

01:07:12,289 --> 01:07:17,660
chairs in the room twice everything

01:07:15,140 --> 01:07:20,990
within cloud computing is commodity and

01:07:17,660 --> 01:07:23,960
is open source and so I don't think that

01:07:20,990 --> 01:07:25,730
you will you'll see anywhere where open

01:07:23,960 --> 01:07:28,759
source is not pervasive in cloud

01:07:25,730 --> 01:07:31,490
computing and so i think it's i think

01:07:28,759 --> 01:07:32,839
it's an assumption i think when you talk

01:07:31,490 --> 01:07:33,950
about cloud computing you're really

01:07:32,839 --> 01:07:39,500
talking about open source cloud

01:07:33,950 --> 01:07:42,650
computing cloud sac is a robust solution

01:07:39,500 --> 01:07:45,049
for large deployments you have dozens of

01:07:42,650 --> 01:07:48,950
data centers and thousands of servers in

01:07:45,049 --> 01:07:51,619
each data centers these hardware is

01:07:48,950 --> 01:07:55,099
going to fail and CloudStack is designed

01:07:51,619 --> 01:07:57,799
to handle number one that mass scale

01:07:55,099 --> 01:08:00,980
number two it's designed to handle the

01:07:57,799 --> 01:08:03,529
failure that inevitably happens in large

01:08:00,980 --> 01:08:07,069
deployments started working on college

01:08:03,529 --> 01:08:10,400
attack over four years ago and it was

01:08:07,069 --> 01:08:13,099
the original set of people working on it

01:08:10,400 --> 01:08:17,210
had a background of delivering software

01:08:13,099 --> 01:08:21,440
telcos and service providers lots of QA

01:08:17,210 --> 01:08:25,040
lots of users actually using it high

01:08:21,440 --> 01:08:28,130
availability is the key feature multiple

01:08:25,040 --> 01:08:30,139
hypervisors support different network

01:08:28,130 --> 01:08:32,839
models you can pick up whatever suits

01:08:30,139 --> 01:08:35,089
you better while step management server

01:08:32,839 --> 01:08:38,779
can be deployed in different physical

01:08:35,089 --> 01:08:40,429
machines it definitely has a huge

01:08:38,779 --> 01:08:45,409
footprint it's being deployed everywhere

01:08:40,429 --> 01:08:47,989
there's a major movie studio that they

01:08:45,409 --> 01:08:51,199
were using cloudstack they were using it

01:08:47,989 --> 01:08:53,270
to transcode video and i thought that

01:08:51,199 --> 01:08:54,920
was terribly fascinating what i found

01:08:53,270 --> 01:08:58,190
more fascinating is what they did during

01:08:54,920 --> 01:09:00,980
lunch where they would spin up you know

01:08:58,190 --> 01:09:02,359
50 or 60 game servers then as soon as

01:09:00,980 --> 01:09:05,060
lunch was over they would destroy all

01:09:02,359 --> 01:09:08,460
the instances and go back to doing

01:09:05,060 --> 01:09:09,989
cloudstack is vast it touches so many

01:09:08,460 --> 01:09:11,850
different aspects and there's no one

01:09:09,989 --> 01:09:15,080
person that's kind of like a master of

01:09:11,850 --> 01:09:18,299
all those realms I think cloudstack as a

01:09:15,080 --> 01:09:20,520
project is going to be one of the

01:09:18,299 --> 01:09:24,600
leaders simply because it's some of the

01:09:20,520 --> 01:09:30,150
most feature Folan and and robust

01:09:24,600 --> 01:09:32,929
platforms out favor adam senior living

01:09:30,150 --> 01:09:32,929
through the clouds dag

01:09:45,730 --> 01:09:47,790
you

01:09:51,109 --> 01:09:56,190
when we created asterisk over a decade

01:09:53,850 --> 01:09:58,140
ago we could not have imagined that

01:09:56,190 --> 01:10:00,360
asterisk would not only become the most

01:09:58,140 --> 01:10:02,490
widely adopted open source communication

01:10:00,360 --> 01:10:04,530
software on the planet but that it would

01:10:02,490 --> 01:10:07,050
impact the entire industry in the way

01:10:04,530 --> 01:10:09,030
that it has today asterisk has found its

01:10:07,050 --> 01:10:11,670
way in the more than 170 countries and

01:10:09,030 --> 01:10:13,620
virtually every fortune 1000 company the

01:10:11,670 --> 01:10:15,690
success of asterisk has enabled a

01:10:13,620 --> 01:10:17,100
transition of power from the hands of

01:10:15,690 --> 01:10:19,380
the traditional proprietary phone

01:10:17,100 --> 01:10:21,780
vendors into the hands of the users and

01:10:19,380 --> 01:10:23,730
administrators of phone systems using

01:10:21,780 --> 01:10:24,960
this power our customers have created

01:10:23,730 --> 01:10:26,880
all sorts of business changing

01:10:24,960 --> 01:10:28,740
applications from small office phone

01:10:26,880 --> 01:10:31,230
systems to mission-critical call centers

01:10:28,740 --> 01:10:32,850
the international carrier networks in

01:10:31,230 --> 01:10:34,650
fact there's even an entire country

01:10:32,850 --> 01:10:37,020
those communications infrastructure runs

01:10:34,650 --> 01:10:39,180
on esters the gym has always been about

01:10:37,020 --> 01:10:40,890
creating technology that expands

01:10:39,180 --> 01:10:43,050
communications capabilities in ways that

01:10:40,890 --> 01:10:44,250
we could never have imagined and that's

01:10:43,050 --> 01:10:46,650
part of what's game-changing about

01:10:44,250 --> 01:10:49,320
Digium today we're doing it again this

01:10:46,650 --> 01:10:51,420
time by introducing a new family of HD

01:10:49,320 --> 01:10:53,550
IP phones that extends control of the

01:10:51,420 --> 01:10:55,290
user all the way to the desktop the

01:10:53,550 --> 01:10:57,000
launch of these new products represents

01:10:55,290 --> 01:10:59,100
the next phase indigenous history of

01:10:57,000 --> 01:11:01,500
innovation these are the first and only

01:10:59,100 --> 01:11:02,880
IP phones designed to fully leverage the

01:11:01,500 --> 01:11:04,530
power of esther's when we first

01:11:02,880 --> 01:11:06,180
discussed our expectations for building

01:11:04,530 --> 01:11:08,790
a family of phones for use with asterisk

01:11:06,180 --> 01:11:10,590
our requirements were pretty simple we

01:11:08,790 --> 01:11:12,330
asked the team to build the phones such

01:11:10,590 --> 01:11:14,550
that they were easy to install integrate

01:11:12,330 --> 01:11:16,380
provision and use I think you'll soon

01:11:14,550 --> 01:11:18,960
agree our engineers have delivered on

01:11:16,380 --> 01:11:20,580
that goal user feedback is validating

01:11:18,960 --> 01:11:22,680
that when it comes to operation with

01:11:20,580 --> 01:11:25,110
astro space systems including our own

01:11:22,680 --> 01:11:27,690
Switchvox based product these are the

01:11:25,110 --> 01:11:28,980
easiest to use best integrated most

01:11:27,690 --> 01:11:31,590
interoperable products on the market

01:11:28,980 --> 01:11:33,560
today the Digium family of phones will

01:11:31,590 --> 01:11:35,640
initially include three IP des hommes

01:11:33,560 --> 01:11:37,560
uniquely designed to complement any

01:11:35,640 --> 01:11:39,450
asterisk or switch box based solution

01:11:37,560 --> 01:11:42,120
these phones are different for a number

01:11:39,450 --> 01:11:44,760
of reasons first there is clue sively

01:11:42,120 --> 01:11:46,200
designed for use with esters secondly

01:11:44,760 --> 01:11:47,810
we've made it really easy to

01:11:46,200 --> 01:11:50,190
autodiscover and provision the phones

01:11:47,810 --> 01:11:52,290
next we've made it easy for the phones

01:11:50,190 --> 01:11:53,909
to access information inside of asterisk

01:11:52,290 --> 01:11:55,849
allowing tight coupling

01:11:53,909 --> 01:11:57,809
between an application and the phone

01:11:55,849 --> 01:11:59,969
additionally we've created an

01:11:57,809 --> 01:12:02,099
applications engine that allows users

01:11:59,969 --> 01:12:05,309
and developers to create and run their

01:12:02,099 --> 01:12:07,110
own apps on the phone and finally we've

01:12:05,309 --> 01:12:09,059
done all of this at a very compelling

01:12:07,110 --> 01:12:10,739
price point at Digium we're always

01:12:09,059 --> 01:12:12,840
thinking of ways to give our customers

01:12:10,739 --> 01:12:15,389
the best value in business phone systems

01:12:12,840 --> 01:12:16,949
and also give them the power to create

01:12:15,389 --> 01:12:19,079
their own solutions or any

01:12:16,949 --> 01:12:20,820
communications challenge well continue

01:12:19,079 --> 01:12:22,229
to push the boundaries not only to make

01:12:20,820 --> 01:12:24,269
Astra's cooler faster and more

01:12:22,229 --> 01:12:25,919
technologically feature-rich but to make

01:12:24,269 --> 01:12:28,409
asterisk and what communications even

01:12:25,919 --> 01:12:31,489
easier and together we'll change the way

01:12:28,409 --> 01:12:31,489
the world communication again

01:13:07,570 --> 01:13:09,630

YouTube URL: https://www.youtube.com/watch?v=Z8_nvt-ECsg


