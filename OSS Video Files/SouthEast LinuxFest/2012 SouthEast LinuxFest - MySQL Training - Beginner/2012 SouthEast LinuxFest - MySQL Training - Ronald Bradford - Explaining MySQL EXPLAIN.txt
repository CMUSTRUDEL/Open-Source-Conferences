Title: 2012 SouthEast LinuxFest - MySQL Training - Ronald Bradford - Explaining MySQL EXPLAIN
Publication date: 2013-12-02
Playlist: 2012 SouthEast LinuxFest - MySQL Training - Beginner
Description: 
	2012 SouthEast LinuxFest
MySQL Beginner Training
Ronald Bradford
Explaining MySQL EXPLAIN
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:07,980
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:07,980 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,279
thank the following diamond sponsors in

00:00:21,320 --> 00:00:28,320
2012 for helping make these videos

00:00:23,279 --> 00:00:32,340
possible can everybody hear me okay

00:00:28,320 --> 00:00:36,899
that's great we're all good to go I get

00:00:32,340 --> 00:00:39,030
a thumbs up hi welcome hope you're

00:00:36,899 --> 00:00:41,190
enjoying southeast linux fest this is

00:00:39,030 --> 00:00:45,390
actually my first time here so hopefully

00:00:41,190 --> 00:00:48,660
most of you are more alumni and can show

00:00:45,390 --> 00:00:50,280
me the ropes during the day my name is

00:00:48,660 --> 00:00:52,920
ronald radford and as i just mentioned

00:00:50,280 --> 00:00:56,250
earlier i'm going to be giving a talk on

00:00:52,920 --> 00:00:58,859
explain today in lieu of our previous

00:00:56,250 --> 00:01:01,800
presenter who due to unfortunate

00:00:58,859 --> 00:01:03,840
circumstances is not here and I know his

00:01:01,800 --> 00:01:06,990
talk was going to talk more about the

00:01:03,840 --> 00:01:09,780
mysql 5.6 features of explain so i'll

00:01:06,990 --> 00:01:11,490
touch on those as well however the

00:01:09,780 --> 00:01:13,860
purpose of this presentation is more

00:01:11,490 --> 00:01:16,320
about explaining how to use the mysql

00:01:13,860 --> 00:01:20,670
explain how many people here actually

00:01:16,320 --> 00:01:22,229
use mysql more than nothing okay good

00:01:20,670 --> 00:01:24,750
and hopefully some of you have actually

00:01:22,229 --> 00:01:27,330
looked at explain try to work out how to

00:01:24,750 --> 00:01:28,439
use it in terms of improving the

00:01:27,330 --> 00:01:30,930
performance of queries so i'm going to

00:01:28,439 --> 00:01:33,150
go through today how to read and how to

00:01:30,930 --> 00:01:36,290
use this tool so that you can work on

00:01:33,150 --> 00:01:38,579
improving performance in in your systems

00:01:36,290 --> 00:01:40,140
so i'm going to go through and i'm going

00:01:38,579 --> 00:01:42,270
to describe some of the options in the

00:01:40,140 --> 00:01:44,549
syntax that's possible with this command

00:01:42,270 --> 00:01:47,009
i'm going to go through the attributes

00:01:44,549 --> 00:01:49,079
that you see is the result of the

00:01:47,009 --> 00:01:50,970
explain command and then i'm going to

00:01:49,079 --> 00:01:53,909
talk about how you can read and

00:01:50,970 --> 00:01:57,930
interpret those results known as the

00:01:53,909 --> 00:01:59,070
query execution plan or qep at the same

00:01:57,930 --> 00:02:00,950
point in time i'm going to talk a little

00:01:59,070 --> 00:02:03,840
bit about some of the limitations that

00:02:00,950 --> 00:02:05,070
this command has particularly if you're

00:02:03,840 --> 00:02:07,409
comparing it with a different database

00:02:05,070 --> 00:02:09,920
product to postgres or at oracle et

00:02:07,409 --> 00:02:09,920
cetera so

00:02:11,370 --> 00:02:19,049
this is what explain can do it can tell

00:02:16,110 --> 00:02:20,280
you what the optimizer intends to do

00:02:19,049 --> 00:02:23,370
with the query that you're about to

00:02:20,280 --> 00:02:25,349
execute there isn't an absolute

00:02:23,370 --> 00:02:27,269
guarantee that this is what it will do

00:02:25,349 --> 00:02:29,579
but it's generally the case so when you

00:02:27,269 --> 00:02:32,670
see the explain plan you can look at

00:02:29,579 --> 00:02:35,220
that the explain plan if you reverse

00:02:32,670 --> 00:02:38,370
engineer it helps you determine how the

00:02:35,220 --> 00:02:40,829
up my SQL optimizer works the optimizer

00:02:38,370 --> 00:02:42,750
is a very complex piece of code which

00:02:40,829 --> 00:02:45,480
given an SQL statement goes through all

00:02:42,750 --> 00:02:47,790
the possible pubs of the types of

00:02:45,480 --> 00:02:49,440
options that could use with the data it

00:02:47,790 --> 00:02:51,450
has to retrieve the indexes that are

00:02:49,440 --> 00:02:54,090
available the conditions that you've

00:02:51,450 --> 00:02:55,769
said to try and work out the best way to

00:02:54,090 --> 00:02:59,549
give you the result in the shortest

00:02:55,769 --> 00:03:02,280
period of time now if the optimizer

00:02:59,549 --> 00:03:03,590
chooses a different path it doesn't mean

00:03:02,280 --> 00:03:06,329
the results are going to be different

00:03:03,590 --> 00:03:08,819
what it does mean is is that it may take

00:03:06,329 --> 00:03:11,159
longer to execute and in you know any

00:03:08,819 --> 00:03:13,109
particular application you want SQL to

00:03:11,159 --> 00:03:16,889
run as efficiently as possible so that

00:03:13,109 --> 00:03:18,900
your users are happy with the result the

00:03:16,889 --> 00:03:22,260
purpose of this presentation is not to

00:03:18,900 --> 00:03:24,389
help you to improve your SQL statements

00:03:22,260 --> 00:03:26,549
the purposes presentation is to give you

00:03:24,389 --> 00:03:29,220
all the tools the information so that

00:03:26,549 --> 00:03:30,780
you can interpret that properly with

00:03:29,220 --> 00:03:32,849
other types of data and then make

00:03:30,780 --> 00:03:38,280
informed decisions about making

00:03:32,849 --> 00:03:39,299
improvements so just the slide about

00:03:38,280 --> 00:03:40,919
myself I'm not going to spend much

00:03:39,299 --> 00:03:43,949
detail on it I've been working with

00:03:40,919 --> 00:03:45,900
MySQL for quite some time now I'm

00:03:43,949 --> 00:03:48,810
recognized as the all-time top bloggers

00:03:45,900 --> 00:03:50,579
in MySQL I've written a few books I've

00:03:48,810 --> 00:03:52,859
actually worked for MySQL link the

00:03:50,579 --> 00:03:57,569
company and and while I don't work for

00:03:52,859 --> 00:04:00,329
MySQL or Oracle now I'm very open in the

00:03:57,569 --> 00:04:01,829
community so you know where this as a

00:04:00,329 --> 00:04:03,329
badge to represent my school the

00:04:01,829 --> 00:04:06,599
community as a company not in terms of

00:04:03,329 --> 00:04:08,459
any official relationships and I live

00:04:06,599 --> 00:04:09,930
here in the US and I do independent

00:04:08,459 --> 00:04:14,010
consulting and mysql that's what my day

00:04:09,930 --> 00:04:16,650
job actually is this presentation is

00:04:14,010 --> 00:04:18,000
going to talk about how to optimize

00:04:16,650 --> 00:04:19,620
statements and some of the things that

00:04:18,000 --> 00:04:22,500
I'll talk about you and actually find in

00:04:19,620 --> 00:04:23,170
one of my previous books on optimizing

00:04:22,500 --> 00:04:26,890
sqlstate

00:04:23,170 --> 00:04:28,660
so that's there for reference as well so

00:04:26,890 --> 00:04:32,230
just some background about the my SQL

00:04:28,660 --> 00:04:34,510
optimizer it's a cost-based optimizer so

00:04:32,230 --> 00:04:37,270
it's going to make a decision based on

00:04:34,510 --> 00:04:40,600
how much it express expects it will cost

00:04:37,270 --> 00:04:42,820
the crew to execute and basically that

00:04:40,600 --> 00:04:44,710
comes down to how much disk i/o you're

00:04:42,820 --> 00:04:47,290
going to do there are some other

00:04:44,710 --> 00:04:49,030
indicators but effectively cost means

00:04:47,290 --> 00:04:52,350
how expensive is it going to be for me

00:04:49,030 --> 00:04:56,140
to retrieve the information from disk in

00:04:52,350 --> 00:04:59,110
MySQL there is no way for you to pin a

00:04:56,140 --> 00:05:01,660
query execution plan what that means is

00:04:59,110 --> 00:05:03,850
that every time an SQL statement runs it

00:05:01,660 --> 00:05:07,060
will calculate a new query execution

00:05:03,850 --> 00:05:09,340
plan for every statement if you run a

00:05:07,060 --> 00:05:10,930
thousand statements that are the same

00:05:09,340 --> 00:05:13,690
every single second it will do it a

00:05:10,930 --> 00:05:17,440
thousand times mysql has no way to keep

00:05:13,690 --> 00:05:19,360
a copy of what should be executed mysql

00:05:17,440 --> 00:05:21,850
provides some hints that enables you to

00:05:19,360 --> 00:05:23,920
sort of like inform the optimizer of

00:05:21,850 --> 00:05:25,480
certain things you might want to do in

00:05:23,920 --> 00:05:27,370
other database products particularly

00:05:25,480 --> 00:05:29,350
oracle there are a large number of hints

00:05:27,370 --> 00:05:31,180
where between different versions you can

00:05:29,350 --> 00:05:34,060
say I really want you to do it this way

00:05:31,180 --> 00:05:35,530
or really want you to do it this way and

00:05:34,060 --> 00:05:38,320
as I mentioned it's calculated every

00:05:35,530 --> 00:05:40,780
time the only exception is in MySQL if

00:05:38,320 --> 00:05:42,730
you re run a statement and the results

00:05:40,780 --> 00:05:44,920
have been put into MySQL query cache

00:05:42,730 --> 00:05:47,380
which is a very optimized way to

00:05:44,920 --> 00:05:50,500
retrieve data from a query very quickly

00:05:47,380 --> 00:05:52,450
that's been executed multiple times that

00:05:50,500 --> 00:05:53,830
information is already predefined in

00:05:52,450 --> 00:05:58,270
network packets so it doesn't actually

00:05:53,830 --> 00:06:00,760
have to go through the plan there are

00:05:58,270 --> 00:06:03,940
three types of syntax for the explain

00:06:00,760 --> 00:06:06,490
command there's the traditional explain

00:06:03,940 --> 00:06:09,000
select statement and then there are two

00:06:06,490 --> 00:06:12,310
extended attributes for this extreme

00:06:09,000 --> 00:06:14,050
permission petitions and explain

00:06:12,310 --> 00:06:17,440
extended and I'm going to go through

00:06:14,050 --> 00:06:19,900
each one of these at a later time now

00:06:17,440 --> 00:06:22,590
when I wrote these slides originally and

00:06:19,900 --> 00:06:24,790
when I actually published the book on

00:06:22,590 --> 00:06:27,370
optimizing SQL statements which includes

00:06:24,790 --> 00:06:29,470
Lord detail about explain it was only

00:06:27,370 --> 00:06:33,250
possible to do an explain statement on a

00:06:29,470 --> 00:06:35,310
select statement now what's quite

00:06:33,250 --> 00:06:36,860
important is is that in your system

00:06:35,310 --> 00:06:38,840
inserts

00:06:36,860 --> 00:06:40,520
generally quite efficient but update

00:06:38,840 --> 00:06:42,289
statements and delete statements can

00:06:40,520 --> 00:06:44,629
actually take a long time to execute and

00:06:42,289 --> 00:06:47,449
you should also you should always look

00:06:44,629 --> 00:06:48,770
at running and explain plan on those to

00:06:47,449 --> 00:06:51,349
determine if they're efficient or not

00:06:48,770 --> 00:06:54,050
and historically you have to rewrite the

00:06:51,349 --> 00:06:56,900
SQL statement as a select now one of the

00:06:54,050 --> 00:06:59,629
features in my school 5.6 is that you

00:06:56,900 --> 00:07:02,150
can now run explain on insert update and

00:06:59,629 --> 00:07:03,469
delete this is important because of an

00:07:02,150 --> 00:07:05,360
update you want to know that if you're

00:07:03,469 --> 00:07:07,580
not doing any work with the primary key

00:07:05,360 --> 00:07:08,990
that you're using an index for example

00:07:07,580 --> 00:07:11,449
the most efficient way to access your

00:07:08,990 --> 00:07:16,789
data so that's a 5.6 feature which is

00:07:11,449 --> 00:07:19,819
very good to know this presentation is

00:07:16,789 --> 00:07:21,949
about describing explain this is just

00:07:19,819 --> 00:07:25,310
one of the commands that you as a

00:07:21,949 --> 00:07:28,129
developer or a DBA will use in terms of

00:07:25,310 --> 00:07:29,810
gathering information to make a better

00:07:28,129 --> 00:07:32,509
decision about improving your SQL

00:07:29,810 --> 00:07:34,069
statements I'm not going to go in much

00:07:32,509 --> 00:07:35,779
detail but these are some of the other

00:07:34,069 --> 00:07:38,270
commands that you really need to know

00:07:35,779 --> 00:07:39,889
about so that you can like take all

00:07:38,270 --> 00:07:43,610
information available and make a good

00:07:39,889 --> 00:07:46,009
decision show create table is going to

00:07:43,610 --> 00:07:48,169
give you the full DDL definition of the

00:07:46,009 --> 00:07:50,870
table it's going to list all the columns

00:07:48,169 --> 00:07:52,339
the column data types no liability it's

00:07:50,870 --> 00:07:54,139
going to list the primary key and the

00:07:52,339 --> 00:07:55,819
indexes these are all important things

00:07:54,139 --> 00:07:59,389
that you need to know when you're

00:07:55,819 --> 00:08:01,789
reading a query execution plan the show

00:07:59,389 --> 00:08:04,460
indexes command lists the indexes that

00:08:01,789 --> 00:08:06,139
are on a given table and it has one

00:08:04,460 --> 00:08:09,409
particular column which is of value

00:08:06,139 --> 00:08:11,479
which is known as cardinality and this

00:08:09,409 --> 00:08:14,270
is an indication of the statistics that

00:08:11,479 --> 00:08:17,270
are available to you to determine how

00:08:14,270 --> 00:08:20,839
unique the value is in the individual

00:08:17,270 --> 00:08:23,360
columns in an index so a higher number

00:08:20,839 --> 00:08:26,150
shows a much more uniqueness generally a

00:08:23,360 --> 00:08:27,620
primary key will show you the total

00:08:26,150 --> 00:08:30,740
amount of uniqueness because every row

00:08:27,620 --> 00:08:31,969
is actually unique and then columns that

00:08:30,740 --> 00:08:34,699
our index that have a very low

00:08:31,969 --> 00:08:37,310
cardinality means that many rows will be

00:08:34,699 --> 00:08:41,029
matched when you use that value and so

00:08:37,310 --> 00:08:43,610
that may not be an effective index the

00:08:41,029 --> 00:08:46,520
show table status command provides

00:08:43,610 --> 00:08:47,840
additional information about the storage

00:08:46,520 --> 00:08:49,670
engine that's used the

00:08:47,840 --> 00:08:53,270
version of the storage engine and it

00:08:49,670 --> 00:08:55,040
also shows the size of the table this is

00:08:53,270 --> 00:08:57,230
important if you want to modify the

00:08:55,040 --> 00:08:59,870
table to alter the table to change the

00:08:57,230 --> 00:09:01,400
indexes because under normal

00:08:59,870 --> 00:09:03,800
circumstances this is what's known as a

00:09:01,400 --> 00:09:06,260
blocking operation and it will take time

00:09:03,800 --> 00:09:08,450
to execute and if you're unfamiliar with

00:09:06,260 --> 00:09:11,680
the size of the table this can really

00:09:08,450 --> 00:09:14,900
cause problems with your application

00:09:11,680 --> 00:09:17,270
Maya school also has an ANSI standard

00:09:14,900 --> 00:09:19,660
information schema this is a set of

00:09:17,270 --> 00:09:21,950
tables that give you meta information

00:09:19,660 --> 00:09:23,780
all the data that you can get from the

00:09:21,950 --> 00:09:25,910
show commands you can also retrieve from

00:09:23,780 --> 00:09:28,670
an SQL statement using information

00:09:25,910 --> 00:09:31,370
schema and show variables and show

00:09:28,670 --> 00:09:33,410
status shows the actual session and

00:09:31,370 --> 00:09:35,540
global variables that my our school is

00:09:33,410 --> 00:09:37,610
configured some of those are important

00:09:35,540 --> 00:09:39,830
for some types of queries and show

00:09:37,610 --> 00:09:42,740
status gives you incremental counters of

00:09:39,830 --> 00:09:44,330
what's happening inside the database so

00:09:42,740 --> 00:09:46,700
when you actually execute an SQL

00:09:44,330 --> 00:09:48,800
statement you can use this to say did I

00:09:46,700 --> 00:09:50,780
create a temporary table how many rows

00:09:48,800 --> 00:09:54,740
that I actually read how many pages did

00:09:50,780 --> 00:09:57,050
I read and there is a new feature that

00:09:54,740 --> 00:09:59,810
again in terms of talking about the new

00:09:57,050 --> 00:10:02,080
5.6 features there are three of them the

00:09:59,810 --> 00:10:04,550
first is that you can run an explain on

00:10:02,080 --> 00:10:06,830
more than an SQL a select state which we

00:10:04,550 --> 00:10:10,100
talked about the second is what's known

00:10:06,830 --> 00:10:12,650
as optimize a trace and this is a great

00:10:10,100 --> 00:10:16,130
tool to expose what the optimizer

00:10:12,650 --> 00:10:18,950
actually does explain only gives you

00:10:16,130 --> 00:10:20,480
what it intends to do we optimize a

00:10:18,950 --> 00:10:23,210
trace actually goes through and shows

00:10:20,480 --> 00:10:25,370
you all the pubs that the database

00:10:23,210 --> 00:10:27,710
considered to execute if you have

00:10:25,370 --> 00:10:30,230
multiple table joins it will show you

00:10:27,710 --> 00:10:32,300
those all those joins so you can see

00:10:30,230 --> 00:10:33,740
what prune operations were done to

00:10:32,300 --> 00:10:35,630
determine the career want to execute

00:10:33,740 --> 00:10:37,580
will also give you more information

00:10:35,630 --> 00:10:39,980
about the rose it's going to access the

00:10:37,580 --> 00:10:42,680
better detail of the statistics that you

00:10:39,980 --> 00:10:44,090
have against the column the show indexes

00:10:42,680 --> 00:10:46,310
command is the only other command that

00:10:44,090 --> 00:10:47,810
gives you an approximation of that so

00:10:46,310 --> 00:10:50,300
now the optimizer trace has given you

00:10:47,810 --> 00:10:51,740
better access still not as good as a

00:10:50,300 --> 00:10:53,210
histogram of all the information that

00:10:51,740 --> 00:10:58,580
you actually want but a little bit

00:10:53,210 --> 00:11:00,499
better and the third thing that is

00:10:58,580 --> 00:11:03,439
available in 5.6 is some

00:11:00,499 --> 00:11:06,259
talk about in a second actually so in

00:11:03,439 --> 00:11:08,869
general rules an explain statement will

00:11:06,259 --> 00:11:11,089
not actually run your query it will

00:11:08,869 --> 00:11:12,829
actually go through the parsing and

00:11:11,089 --> 00:11:15,139
optimizing process to determine how it

00:11:12,829 --> 00:11:17,419
would run the query there are some

00:11:15,139 --> 00:11:19,579
exceptions to this when you're using

00:11:17,419 --> 00:11:23,719
certain types of correlated sub queries

00:11:19,579 --> 00:11:25,789
or derived tables for my SQL statements

00:11:23,719 --> 00:11:27,949
the optimizer may have to actually

00:11:25,789 --> 00:11:30,289
execute that in order to determine what

00:11:27,949 --> 00:11:33,739
the best path is to then determine the

00:11:30,289 --> 00:11:35,299
best path of the entire query now in 5.6

00:11:33,739 --> 00:11:37,489
again there have been improvements in

00:11:35,299 --> 00:11:39,919
these areas and only just on tuesday at

00:11:37,489 --> 00:11:41,029
the mysql innovation day in san

00:11:39,919 --> 00:11:43,099
francisco where they're talking about

00:11:41,029 --> 00:11:46,189
some of the significant improvements

00:11:43,099 --> 00:11:49,779
here in terms of the explain

00:11:46,189 --> 00:11:51,859
improvements for these types of queries

00:11:49,779 --> 00:11:55,669
so what do you do when you get an

00:11:51,859 --> 00:11:57,109
explain statement what do you see these

00:11:55,669 --> 00:12:00,439
are the two outputs that you would

00:11:57,109 --> 00:12:02,959
generally see the new output which I

00:12:00,439 --> 00:12:04,879
haven't got in my slides is a 5.6

00:12:02,959 --> 00:12:09,049
feature which provides this output in

00:12:04,879 --> 00:12:13,459
JSON format so before 5.6 what you would

00:12:09,049 --> 00:12:16,789
see is these 10 attributes and generally

00:12:13,459 --> 00:12:19,489
you'll see them in column format normal

00:12:16,789 --> 00:12:21,919
SQL statement but in MySQL there is also

00:12:19,489 --> 00:12:24,679
this nice little syntax called backslash

00:12:21,919 --> 00:12:27,739
uppercase G and what it does it provides

00:12:24,679 --> 00:12:28,729
the output and vertical format now when

00:12:27,739 --> 00:12:30,019
you're looking at this and you're

00:12:28,729 --> 00:12:32,029
looking at an explained plan that has

00:12:30,019 --> 00:12:33,470
lots of rows you're probably going to

00:12:32,029 --> 00:12:36,859
want to use the first format but

00:12:33,470 --> 00:12:40,519
particularly for presentations and for

00:12:36,859 --> 00:12:42,319
book content and for scripting the

00:12:40,519 --> 00:12:44,899
vertical format is very handy to be able

00:12:42,319 --> 00:12:51,409
to extract information so don't forget

00:12:44,899 --> 00:12:53,989
that that option actually exists so what

00:12:51,409 --> 00:12:55,279
is in the in explain these are the 10

00:12:53,989 --> 00:12:59,179
attributes that I'm going to talk about

00:12:55,279 --> 00:13:01,849
they go through and give you information

00:12:59,179 --> 00:13:02,989
that you need to be able to interpret to

00:13:01,849 --> 00:13:07,579
be able to improve the queries that

00:13:02,989 --> 00:13:09,589
you're running now if someone here in

00:13:07,579 --> 00:13:11,779
the room was not using MySQL I'm not

00:13:09,589 --> 00:13:12,750
familiar with MySQL or familiar with

00:13:11,779 --> 00:13:15,180
another relational database

00:13:12,750 --> 00:13:18,660
and they knew the concept of explain and

00:13:15,180 --> 00:13:20,010
they said what's most important if you

00:13:18,660 --> 00:13:21,930
will need to look at what were the most

00:13:20,010 --> 00:13:26,600
important things then there are two to

00:13:21,930 --> 00:13:30,030
look at that's the key and the rose if

00:13:26,600 --> 00:13:32,670
you see this if you see that a key is

00:13:30,030 --> 00:13:34,350
being used then that means an index for

00:13:32,670 --> 00:13:36,720
the particular row in the explain plan

00:13:34,350 --> 00:13:40,020
and the explain plan has one row per

00:13:36,720 --> 00:13:42,060
table of your query now a table may be

00:13:40,020 --> 00:13:45,390
an actual real table that you've done

00:13:42,060 --> 00:13:48,210
and join on or it may be a drive table

00:13:45,390 --> 00:13:51,660
or a created table in terms of my

00:13:48,210 --> 00:13:53,700
school's processing you can see key and

00:13:51,660 --> 00:13:55,860
if you see Rose equals one that

00:13:53,700 --> 00:14:00,330
statistics saying that I'm going to use

00:13:55,860 --> 00:14:01,770
a key and I expect to find one row this

00:14:00,330 --> 00:14:03,150
is basically the best that you can

00:14:01,770 --> 00:14:08,040
actually get when you want to retrieve

00:14:03,150 --> 00:14:10,050
data correspondingly if your query

00:14:08,040 --> 00:14:12,530
showed you that it wasn't using a key

00:14:10,050 --> 00:14:15,090
and it showed a large number of rows

00:14:12,530 --> 00:14:18,690
then effectively what you're doing is a

00:14:15,090 --> 00:14:23,130
full table scan of that table under

00:14:18,690 --> 00:14:25,820
normal operating procedures that is

00:14:23,130 --> 00:14:29,010
usually a candidate for improvements

00:14:25,820 --> 00:14:30,930
there are some special edge cases

00:14:29,010 --> 00:14:32,850
particularly with very large data sets

00:14:30,930 --> 00:14:35,280
where it's more efficient to scan the

00:14:32,850 --> 00:14:37,170
whole table but generally speaking if

00:14:35,280 --> 00:14:40,230
you see no key and you see a large

00:14:37,170 --> 00:14:41,640
number of rows red flag to go there's

00:14:40,230 --> 00:14:44,160
probably an improvement that can be made

00:14:41,640 --> 00:14:47,700
here to make that better so this is not

00:14:44,160 --> 00:14:51,420
what you want to see and this is what

00:14:47,700 --> 00:14:55,140
you want to see okay we're all still

00:14:51,420 --> 00:14:58,200
with it so the key attribute as i

00:14:55,140 --> 00:14:59,850
mentioned gives you the index name

00:14:58,200 --> 00:15:03,960
that's being used for that particular

00:14:59,850 --> 00:15:07,740
row now in general terms you will only

00:15:03,960 --> 00:15:11,070
see one index used per table in an SQL

00:15:07,740 --> 00:15:13,650
query whether there is actually used for

00:15:11,070 --> 00:15:15,520
the wear of the join the order by other

00:15:13,650 --> 00:15:18,220
group by there's generally only one

00:15:15,520 --> 00:15:19,690
being used there are a couple of

00:15:18,220 --> 00:15:22,360
exceptions to those and I'll show you

00:15:19,690 --> 00:15:24,820
one of those in a minute but if you're

00:15:22,360 --> 00:15:26,350
designing your database and you're

00:15:24,820 --> 00:15:30,190
optimizing your SQL statements you

00:15:26,350 --> 00:15:31,690
should stick with that rule now two

00:15:30,190 --> 00:15:33,130
other attributes which I'm going to go

00:15:31,690 --> 00:15:35,740
through their important when you're

00:15:33,130 --> 00:15:40,690
talking about the key one is possible

00:15:35,740 --> 00:15:42,300
keys and one is the key length so here's

00:15:40,690 --> 00:15:44,980
the example that we're talking about

00:15:42,300 --> 00:15:47,920
here's an example where two indexes were

00:15:44,980 --> 00:15:52,570
actually used introduced in MySQL

00:15:47,920 --> 00:15:54,310
five-point of range of where the

00:15:52,570 --> 00:15:57,400
optimizer could choose more than one

00:15:54,310 --> 00:15:59,640
index and merge them together to provide

00:15:57,400 --> 00:16:02,800
a quicker way to produce the results and

00:15:59,640 --> 00:16:05,110
this particular case we have two indexes

00:16:02,800 --> 00:16:07,900
on the first name and the last name and

00:16:05,110 --> 00:16:10,660
because we're doing a join on that query

00:16:07,900 --> 00:16:12,070
with an or statement the optimizer said

00:16:10,660 --> 00:16:14,740
well I've got two indexes that are

00:16:12,070 --> 00:16:16,150
roughly have the same cardinality but I

00:16:14,740 --> 00:16:18,760
can actually join them together to give

00:16:16,150 --> 00:16:21,400
me a better result because if you had an

00:16:18,760 --> 00:16:23,860
index on first and last or index one

00:16:21,400 --> 00:16:26,140
last and first it's not actually going

00:16:23,860 --> 00:16:28,720
to work because of the or in your where

00:16:26,140 --> 00:16:30,640
statement so the optimizer can actually

00:16:28,720 --> 00:16:32,710
join those together and there are a

00:16:30,640 --> 00:16:35,650
couple other examples the sort sort

00:16:32,710 --> 00:16:38,110
merge as an example generally speaking

00:16:35,650 --> 00:16:40,900
if you see that you should determine if

00:16:38,110 --> 00:16:42,460
you can create a better index first when

00:16:40,900 --> 00:16:44,920
these first came out in my school five

00:16:42,460 --> 00:16:47,650
point five point zero some queries

00:16:44,920 --> 00:16:50,230
actually ran worse I mentioned before

00:16:47,650 --> 00:16:52,300
that the optimizer will make a decision

00:16:50,230 --> 00:16:53,860
on which path to choose and the results

00:16:52,300 --> 00:16:57,220
are going to be the same but one query

00:16:53,860 --> 00:16:58,390
maybe style or faster your goal with the

00:16:57,220 --> 00:17:01,120
explain plan is to always get the

00:16:58,390 --> 00:17:03,190
fastest query but early on sometimes has

00:17:01,120 --> 00:17:04,900
actually made queries 12 slower and it

00:17:03,190 --> 00:17:06,130
wasn't until five point one where you're

00:17:04,900 --> 00:17:08,709
able to actually disable these

00:17:06,130 --> 00:17:10,720
particular optimizer cases and now you

00:17:08,709 --> 00:17:13,360
can choose if you want to turn this

00:17:10,720 --> 00:17:19,120
particular rule on or off at a global

00:17:13,360 --> 00:17:21,670
level now keys tells you what was used

00:17:19,120 --> 00:17:24,699
possible keys tells you what the

00:17:21,670 --> 00:17:27,160
optimizer considered to use these are

00:17:24,699 --> 00:17:27,939
part of the different types of tree

00:17:27,160 --> 00:17:29,980
traversal that

00:17:27,939 --> 00:17:31,870
going through and the pruning that it's

00:17:29,980 --> 00:17:34,090
going to do to eliminate these indexes

00:17:31,870 --> 00:17:38,950
as less efficient to retrieve the data

00:17:34,090 --> 00:17:40,720
that you want so if you see some

00:17:38,950 --> 00:17:43,090
possible index values and then you see

00:17:40,720 --> 00:17:45,129
no key value then you can see that the

00:17:43,090 --> 00:17:46,720
optimizer made a choice that have

00:17:45,129 --> 00:17:48,970
decided it was better not to use it

00:17:46,720 --> 00:17:52,509
index and sometimes you may have to ask

00:17:48,970 --> 00:17:54,129
a question why generally speaking is not

00:17:52,509 --> 00:17:56,559
good to have too many values here

00:17:54,129 --> 00:17:58,960
because remember the query goes through

00:17:56,559 --> 00:18:00,610
this process every single time and if

00:17:58,960 --> 00:18:02,860
you have a large number of values then

00:18:00,610 --> 00:18:06,460
MySQL has to make a lot of decisions to

00:18:02,860 --> 00:18:09,850
eliminate those so here is an example

00:18:06,460 --> 00:18:12,250
where in the first query we see that it

00:18:09,850 --> 00:18:15,669
had a choice to choose a key and it

00:18:12,250 --> 00:18:17,230
elected not to choose that key now there

00:18:15,669 --> 00:18:18,960
are various circumstances for that and

00:18:17,230 --> 00:18:21,340
that can be quite in-depth conversation

00:18:18,960 --> 00:18:23,409
but in the second example you can see

00:18:21,340 --> 00:18:26,019
where it it looked at using the key and

00:18:23,409 --> 00:18:27,570
it actually used the key so these are

00:18:26,019 --> 00:18:34,600
the things that you want to look out for

00:18:27,570 --> 00:18:35,919
if you're running the same query here is

00:18:34,600 --> 00:18:37,600
an example where in this particular

00:18:35,919 --> 00:18:40,629
query there are a large number of

00:18:37,600 --> 00:18:42,450
indexes this is a common problem if

00:18:40,629 --> 00:18:45,909
people not familiar with how to design

00:18:42,450 --> 00:18:49,620
to work optimally with MySQL or they're

00:18:45,909 --> 00:18:52,600
using some ORM tool some of those will

00:18:49,620 --> 00:18:54,669
leave as unnamed for this conversation

00:18:52,600 --> 00:19:00,250
those that use Ruby on Rails or

00:18:54,669 --> 00:19:09,980
hibernate not good no no no if you have

00:19:00,250 --> 00:19:12,750
any questions please which ones suck yes

00:19:09,980 --> 00:19:21,600
I'm not too sure if the I'm not sure in

00:19:12,750 --> 00:19:25,530
this presentation or us so the question

00:19:21,600 --> 00:19:27,330
was which orm czar bad and i'm not sure

00:19:25,530 --> 00:19:29,160
if it's in these slides or in a similar

00:19:27,330 --> 00:19:31,740
presentation that in my conclusion i

00:19:29,160 --> 00:19:35,580
have a slide and basically it's AIT's it

00:19:31,740 --> 00:19:38,400
states frameworks generally suck as a

00:19:35,580 --> 00:19:41,310
global statement all frameworks without

00:19:38,400 --> 00:19:43,140
exception so Ruby on Rails and hibernate

00:19:41,310 --> 00:19:45,990
and I baddest or any others that you can

00:19:43,140 --> 00:19:48,210
think of I guess sequel alchemy and

00:19:45,990 --> 00:19:50,670
these sort of things generally they're

00:19:48,210 --> 00:19:53,460
designed to improve the development

00:19:50,670 --> 00:19:56,160
process they are never database friendly

00:19:53,460 --> 00:20:00,120
and this is a goodie this is not an

00:19:56,160 --> 00:20:02,430
example of a our end product but when

00:20:00,120 --> 00:20:04,080
you see lots of single columns in this

00:20:02,430 --> 00:20:05,490
case it is some some multiple columns

00:20:04,080 --> 00:20:07,080
which is you know someone's made an

00:20:05,490 --> 00:20:08,910
attempt to do it there's actually a

00:20:07,080 --> 00:20:11,520
duplicate index in here which is like an

00:20:08,910 --> 00:20:13,800
overhead that you should be avoiding so

00:20:11,520 --> 00:20:15,870
if you have like a table and you have

00:20:13,800 --> 00:20:17,970
like ten single columns that are indexed

00:20:15,870 --> 00:20:20,490
quite often no one's considered what

00:20:17,970 --> 00:20:22,830
really should be used and because they

00:20:20,490 --> 00:20:24,150
go you know where column a equals this

00:20:22,830 --> 00:20:26,100
or column B equals this two column

00:20:24,150 --> 00:20:29,370
sequences they'll create an index on a

00:20:26,100 --> 00:20:30,690
and B and C separately not really not

00:20:29,370 --> 00:20:33,360
realizing that the optimizer will

00:20:30,690 --> 00:20:34,770
generally choose just one index and by

00:20:33,360 --> 00:20:39,540
combining them you actually get a better

00:20:34,770 --> 00:20:43,830
index so both normal design and RMS can

00:20:39,540 --> 00:20:46,050
cannot help in this situation now I

00:20:43,830 --> 00:20:48,090
mentioned rose earlier Rose tells you

00:20:46,050 --> 00:20:51,180
the approximate number of rows it

00:20:48,090 --> 00:20:54,300
expects to actually use when execute the

00:20:51,180 --> 00:20:57,120
query I say a proximate because it's

00:20:54,300 --> 00:20:59,270
based on statistics which may not be

00:20:57,120 --> 00:21:02,640
completely accurate in the table and

00:20:59,270 --> 00:21:04,410
also you've got to realize that the

00:21:02,640 --> 00:21:06,810
statistics may not show a good

00:21:04,410 --> 00:21:09,510
distribution if you have four or five

00:21:06,810 --> 00:21:11,580
values but ninety percent of them are

00:21:09,510 --> 00:21:12,010
one value and one percenter dollar value

00:21:11,580 --> 00:21:14,140
monster

00:21:12,010 --> 00:21:21,520
value the Rose may not be a true

00:21:14,140 --> 00:21:23,320
indicator as well as possible so there

00:21:21,520 --> 00:21:25,930
the basic things but if you really want

00:21:23,320 --> 00:21:28,450
to understand there are some more come

00:21:25,930 --> 00:21:30,850
out there are some more attributes that

00:21:28,450 --> 00:21:34,240
really hope and this is one of the key

00:21:30,850 --> 00:21:35,830
attributes that as a consultant that I'm

00:21:34,240 --> 00:21:38,470
going to look at when I review your

00:21:35,830 --> 00:21:40,540
system after making sure the schema is

00:21:38,470 --> 00:21:42,220
ok and the SQL statements are executing

00:21:40,540 --> 00:21:44,020
things appropriately and they can be

00:21:42,220 --> 00:21:46,060
cached between deterministic and non

00:21:44,020 --> 00:21:48,730
deterministic and I see that you're

00:21:46,060 --> 00:21:51,180
using indexes what I'm going to do is

00:21:48,730 --> 00:21:54,310
see how effective your indexes are and

00:21:51,180 --> 00:21:57,160
the key link tells me when I'm talking

00:21:54,310 --> 00:21:58,570
about a concatenated index or you know

00:21:57,160 --> 00:22:00,460
multi-column index where there's more

00:21:58,570 --> 00:22:03,550
than one column in the index how

00:22:00,460 --> 00:22:05,770
efficient that index actually is the key

00:22:03,550 --> 00:22:08,950
length will tell me how many bytes are

00:22:05,770 --> 00:22:10,690
actually being used in the index and i

00:22:08,950 --> 00:22:13,600
have several examples to go through here

00:22:10,690 --> 00:22:18,520
because this is a good advanced topic to

00:22:13,600 --> 00:22:20,320
work with there is no absolute answer as

00:22:18,520 --> 00:22:22,390
to what the number means in fact it can

00:22:20,320 --> 00:22:24,640
be a complicated calculation to work out

00:22:22,390 --> 00:22:26,400
what the number actually is here are the

00:22:24,640 --> 00:22:28,720
common things that should look at

00:22:26,400 --> 00:22:32,260
different data types four columns will

00:22:28,720 --> 00:22:34,270
have different values and then the

00:22:32,260 --> 00:22:37,450
difference between a character and a

00:22:34,270 --> 00:22:38,980
varchar field a null field will add

00:22:37,450 --> 00:22:40,780
different bites of this and when you

00:22:38,980 --> 00:22:43,240
choose different character sets they

00:22:40,780 --> 00:22:47,500
will also change the value of the key

00:22:43,240 --> 00:22:49,870
length column so here is an example of

00:22:47,500 --> 00:22:51,430
an explain plan and I can look in the

00:22:49,870 --> 00:22:53,920
explain plan before I even look at the

00:22:51,430 --> 00:22:56,680
table I can see I'm using a primary key

00:22:53,920 --> 00:22:58,240
I can see I'm using one constant value

00:22:56,680 --> 00:23:00,790
and I can see the key length is 8 bytes

00:22:58,240 --> 00:23:02,560
so I can tell you with extreme

00:23:00,790 --> 00:23:05,470
confidence that you're using a big int

00:23:02,560 --> 00:23:08,680
data type unless your column is char 8

00:23:05,470 --> 00:23:10,570
which is unlikely and I can also tell

00:23:08,680 --> 00:23:14,230
that generally when people use begin

00:23:10,570 --> 00:23:15,820
they use it with auto increment now the

00:23:14,230 --> 00:23:17,950
goal of this presentation is not to give

00:23:15,820 --> 00:23:21,220
you tips on how to improve your queries

00:23:17,950 --> 00:23:25,059
but here's one tip to take away when I

00:23:21,220 --> 00:23:29,230
see this in practically every case

00:23:25,059 --> 00:23:32,289
big in is an over statement for what you

00:23:29,230 --> 00:23:34,889
need to do the int DITA type is actually

00:23:32,289 --> 00:23:37,809
4 bytes long and begin as 8 bytes long

00:23:34,889 --> 00:23:41,919
now an end unsigned column can store a

00:23:37,809 --> 00:23:43,629
value to 4.3 billion so if you're

00:23:41,919 --> 00:23:47,110
inserting rows in a table and getting a

00:23:43,629 --> 00:23:48,460
new column if 4.3 billion you generally

00:23:47,110 --> 00:23:50,889
have a different problem that you need

00:23:48,460 --> 00:23:53,889
to solve so enters more than sufficient

00:23:50,889 --> 00:23:56,139
than begins now what's even better is is

00:23:53,889 --> 00:23:58,419
that people will use foreign keys and

00:23:56,139 --> 00:24:00,009
foreign keys will also be big in you

00:23:58,419 --> 00:24:02,230
convert all of those who begin to win

00:24:00,009 --> 00:24:06,940
you reduce the size of all your indexes

00:24:02,230 --> 00:24:09,759
by 50% that means less index space on

00:24:06,940 --> 00:24:11,799
disk more stuff available of memory that

00:24:09,759 --> 00:24:18,039
one change alone can make a big

00:24:11,799 --> 00:24:22,659
difference in performance varchar is a

00:24:18,039 --> 00:24:24,759
variable character length on disk VAR

00:24:22,659 --> 00:24:27,460
char is not a variable character length

00:24:24,759 --> 00:24:30,600
in the memory inside mysql when it's

00:24:27,460 --> 00:24:34,509
used so for all those people that go

00:24:30,600 --> 00:24:37,720
varchar 255 is ok or ruby on rails say

00:24:34,509 --> 00:24:39,850
that bar chart 255 is ok it is if you're

00:24:37,720 --> 00:24:41,950
any storing a few bites on disks but if

00:24:39,850 --> 00:24:44,559
you use that information in memory in

00:24:41,950 --> 00:24:47,320
some type of operation my escarole will

00:24:44,559 --> 00:24:48,909
expand it to be fixed width so there's

00:24:47,320 --> 00:24:50,259
another one to consider when you have a

00:24:48,909 --> 00:24:52,389
limited amount of memory and you have

00:24:50,259 --> 00:24:55,720
thousands of connections to be able to

00:24:52,389 --> 00:24:58,480
improve your definition of the table so

00:24:55,720 --> 00:25:01,269
you can see 32 bytes which we can refer

00:24:58,480 --> 00:25:02,740
to as being a varchar 30 and two extra

00:25:01,269 --> 00:25:07,210
bytes for the actual length of the

00:25:02,740 --> 00:25:09,309
column now if you use the default

00:25:07,210 --> 00:25:13,299
character set of that in one it's going

00:25:09,309 --> 00:25:14,830
to be 32 if you use utf-8 then mysql is

00:25:13,299 --> 00:25:18,190
going to continue to expand that so it's

00:25:14,830 --> 00:25:20,379
fixed width so now you'll see 92 for the

00:25:18,190 --> 00:25:23,049
same table definition and the same index

00:25:20,379 --> 00:25:24,700
but because it's using a UTF character

00:25:23,049 --> 00:25:29,019
set it's actually going to be using more

00:25:24,700 --> 00:25:32,019
memory here is an example from the

00:25:29,019 --> 00:25:33,869
popular wordpress tool on the shore some

00:25:32,019 --> 00:25:36,129
of you probably heard of that before and

00:25:33,869 --> 00:25:38,419
here's one of the indexes in wordpress

00:25:36,129 --> 00:25:40,669
where it has four columns

00:25:38,419 --> 00:25:42,379
and I've given you down here the bite

00:25:40,669 --> 00:25:44,570
length of each column so we can work out

00:25:42,379 --> 00:25:47,419
how long actually years if we were to

00:25:44,570 --> 00:25:48,799
use the entire index and here's an

00:25:47,419 --> 00:25:50,659
explain plan where a curry has been

00:25:48,799 --> 00:25:53,090
executed is looking for particular posts

00:25:50,659 --> 00:25:55,129
and we can see it uses post type and

00:25:53,090 --> 00:25:58,580
post date which are in the index but the

00:25:55,129 --> 00:26:01,669
key length is only 62 it's not actually

00:25:58,580 --> 00:26:03,409
the total key length of the index so I

00:26:01,669 --> 00:26:05,869
can tell by looking at the key length

00:26:03,409 --> 00:26:08,960
the index of 62 and then looking at the

00:26:05,869 --> 00:26:11,299
index that the SQL statement is not

00:26:08,960 --> 00:26:13,279
using all of the columns and index it's

00:26:11,299 --> 00:26:15,619
only using the leftmost portion of

00:26:13,279 --> 00:26:17,739
columns and even though the query is

00:26:15,619 --> 00:26:20,989
using column 1 and column 3 in

00:26:17,739 --> 00:26:22,759
relational database theory indexes whoo

00:26:20,989 --> 00:26:26,809
from the left the right in terms of

00:26:22,759 --> 00:26:29,450
definition so if the query had been

00:26:26,809 --> 00:26:33,109
written like this where it included the

00:26:29,450 --> 00:26:35,029
second column then you can see the key

00:26:33,109 --> 00:26:37,609
length is now a hundred and thirty two

00:26:35,029 --> 00:26:39,679
bytes so it's using the first part of

00:26:37,609 --> 00:26:41,989
the index the second part of the index

00:26:39,679 --> 00:26:44,960
and the third part of the index to

00:26:41,989 --> 00:26:46,369
satisfy the queries needs so this is the

00:26:44,960 --> 00:26:49,279
difference between the key length where

00:26:46,369 --> 00:26:50,809
I see 62 and if I looked at all of the

00:26:49,279 --> 00:26:52,850
SQL statements that were executed this

00:26:50,809 --> 00:26:55,489
is only one and it's important when you

00:26:52,850 --> 00:26:57,080
tune an SQL statement that you may be

00:26:55,489 --> 00:26:58,399
improving one query but not improving

00:26:57,080 --> 00:27:00,739
others so you're ready to look at all of

00:26:58,399 --> 00:27:03,619
the SQL statements in your application

00:27:00,739 --> 00:27:06,830
but if all the SQL statements was just

00:27:03,619 --> 00:27:08,539
one query and it was 62 bytes then i

00:27:06,830 --> 00:27:10,700
would say that these three columns are

00:27:08,539 --> 00:27:12,769
not needed and so that will actually

00:27:10,700 --> 00:27:16,850
take more disk space it will actually

00:27:12,769 --> 00:27:18,049
slow down inserts updates and deletes so

00:27:16,850 --> 00:27:22,609
this is where the key length could come

00:27:18,049 --> 00:27:24,889
in handy now some of the other

00:27:22,609 --> 00:27:27,109
attributes that you may not look at in

00:27:24,889 --> 00:27:29,029
great detail but can help you in

00:27:27,109 --> 00:27:32,090
determining how the optimizer working

00:27:29,029 --> 00:27:33,700
one is select type this will actually go

00:27:32,090 --> 00:27:37,989
through and tell you the type of

00:27:33,700 --> 00:27:37,989
operation that's actually happening and

00:27:39,700 --> 00:27:45,230
these are the primary things that you'd

00:27:41,989 --> 00:27:47,899
see select a simple primary sub-query

00:27:45,230 --> 00:27:50,059
derives Union what that means is it's a

00:27:47,899 --> 00:27:52,060
simple query when you have multiple

00:27:50,059 --> 00:27:53,350
tables the primary table

00:27:52,060 --> 00:27:55,350
that's generally used wish on his

00:27:53,350 --> 00:27:57,130
primary in the rest were shown a simple

00:27:55,350 --> 00:27:58,990
sub-query it's executing sub-period

00:27:57,130 --> 00:28:01,630
arrived in Union there are some other

00:27:58,990 --> 00:28:03,190
data types which become more descriptive

00:28:01,630 --> 00:28:08,470
as you look at different types of

00:28:03,190 --> 00:28:11,770
obscure statements so in this example we

00:28:08,470 --> 00:28:17,260
can see a query that does join between

00:28:11,770 --> 00:28:19,390
two tables when I talked earlier about a

00:28:17,260 --> 00:28:21,550
line and the execution plan could be a

00:28:19,390 --> 00:28:23,560
physical table or a derived table and

00:28:21,550 --> 00:28:25,480
the first query you can see the first

00:28:23,560 --> 00:28:27,670
one is actually a primary table and the

00:28:25,480 --> 00:28:30,540
second line is referred to the dr table

00:28:27,670 --> 00:28:34,720
table that's generated on the fly and

00:28:30,540 --> 00:28:37,360
the number in the table along the sec

00:28:34,720 --> 00:28:39,550
type so you can see that this means you

00:28:37,360 --> 00:28:41,800
know row 2 is a dr table and the table

00:28:39,550 --> 00:28:45,220
over here is actually using the derived

00:28:41,800 --> 00:28:47,110
table from Row 2 correspondingly in the

00:28:45,220 --> 00:28:50,130
union statement you can see even though

00:28:47,110 --> 00:28:52,360
you know we've got a query between one

00:28:50,130 --> 00:28:54,430
select statement Union another select

00:28:52,360 --> 00:28:56,110
statement mysql is actually giving you

00:28:54,430 --> 00:28:58,630
three lines of outputting on two lines

00:28:56,110 --> 00:29:00,340
of output because internally it's

00:28:58,630 --> 00:29:03,340
creating another table to combine those

00:29:00,340 --> 00:29:05,320
results so the Select type can give you

00:29:03,340 --> 00:29:07,720
additional information if you're getting

00:29:05,320 --> 00:29:11,650
more lines and you would expect in terms

00:29:07,720 --> 00:29:15,340
of numbers of tables here is an example

00:29:11,650 --> 00:29:18,550
of the same query written three

00:29:15,340 --> 00:29:20,710
different ways now I mentioned to you

00:29:18,550 --> 00:29:22,150
that you could write a query and the

00:29:20,710 --> 00:29:24,940
crew execution plan could produce

00:29:22,150 --> 00:29:26,950
different explain plans here's an

00:29:24,940 --> 00:29:28,780
example of a query that is looking

00:29:26,950 --> 00:29:30,520
between a master and a child table

00:29:28,780 --> 00:29:33,400
looking for all master records or

00:29:30,520 --> 00:29:35,650
parents that have no children and I've

00:29:33,400 --> 00:29:37,600
written at three different ways the

00:29:35,650 --> 00:29:40,110
results are exactly the same but the

00:29:37,600 --> 00:29:48,660
explain plan is different in all three

00:29:40,110 --> 00:29:48,660
which one is best he take us no takers

00:29:50,240 --> 00:29:56,040
the second one because it's too simple

00:29:52,620 --> 00:30:02,130
tables well the correct answer is it

00:29:56,040 --> 00:30:04,500
depends it depends on many see it

00:30:02,130 --> 00:30:07,530
depends on many factors particularly the

00:30:04,500 --> 00:30:12,120
size of the data that you have in

00:30:07,530 --> 00:30:14,070
question however you are correct and I

00:30:12,120 --> 00:30:15,360
have some copies of my book so

00:30:14,070 --> 00:30:17,700
afterwards you're welcome to a free copy

00:30:15,360 --> 00:30:19,440
of my book for saying that by looking at

00:30:17,700 --> 00:30:24,630
this you would indicate the second query

00:30:19,440 --> 00:30:26,970
is actually the better one and while the

00:30:24,630 --> 00:30:29,280
answer looks at two simples seem to be

00:30:26,970 --> 00:30:31,050
the way to look at it it's actually the

00:30:29,280 --> 00:30:34,440
inverse if you look at the other queries

00:30:31,050 --> 00:30:38,550
we see dependent sub-query now in MySQL

00:30:34,440 --> 00:30:39,630
sub queries are not that performance and

00:30:38,550 --> 00:30:40,860
so quite often it's better to actually

00:30:39,630 --> 00:30:43,290
rewrite your curiously don't use a

00:30:40,860 --> 00:30:45,720
sub-query there is an exception in that

00:30:43,290 --> 00:30:48,180
sometimes when you do not inquiries they

00:30:45,720 --> 00:30:49,890
can be very performant so depending on

00:30:48,180 --> 00:30:52,320
the other career you're running you know

00:30:49,890 --> 00:30:54,720
you may find that a sub queries actually

00:30:52,320 --> 00:30:56,700
is good but what's important is that

00:30:54,720 --> 00:30:58,590
even though you have written an SQL

00:30:56,700 --> 00:31:01,380
statement and then you've looked at the

00:30:58,590 --> 00:31:03,060
explain plan there may be other ways in

00:31:01,380 --> 00:31:05,040
which you can actually write the SQL

00:31:03,060 --> 00:31:06,570
statement I know I'm only talking about

00:31:05,040 --> 00:31:08,640
explained here but it's an important

00:31:06,570 --> 00:31:10,710
thing to realize that if you can't get

00:31:08,640 --> 00:31:13,080
what's exactly right maybe there's a

00:31:10,710 --> 00:31:15,090
better way to write the query just a

00:31:13,080 --> 00:31:16,680
little tip to take away to to mess with

00:31:15,090 --> 00:31:20,580
your mind about I thought I could just

00:31:16,680 --> 00:31:22,620
tune the SQL statements the extra column

00:31:20,580 --> 00:31:24,120
which is the last of the columns is one

00:31:22,620 --> 00:31:26,400
of those things at the bucket that fills

00:31:24,120 --> 00:31:28,080
everything and so you get lots of

00:31:26,400 --> 00:31:29,460
information there you get lots of values

00:31:28,080 --> 00:31:30,450
they can be combined and some of them

00:31:29,460 --> 00:31:33,330
are good and some of them are not so

00:31:30,450 --> 00:31:38,760
good and I'm going to go through each

00:31:33,330 --> 00:31:41,670
one of these separately so first one is

00:31:38,760 --> 00:31:45,060
using temporary what this means is that

00:31:41,670 --> 00:31:46,560
MySQL internally had to take the results

00:31:45,060 --> 00:31:49,040
of something that it was doing and

00:31:46,560 --> 00:31:51,090
create an internal temporary table

00:31:49,040 --> 00:31:55,140
internal temporary table is very much

00:31:51,090 --> 00:31:57,270
like MySQL memory table and you can

00:31:55,140 --> 00:32:00,780
actually have many temporary tables in a

00:31:57,270 --> 00:32:01,960
complicated query so these are not

00:32:00,780 --> 00:32:03,940
always bad

00:32:01,960 --> 00:32:05,950
they needed there are you know 10 or 15

00:32:03,940 --> 00:32:07,450
different types of operations where you

00:32:05,950 --> 00:32:09,549
just have to have a temporary table and

00:32:07,450 --> 00:32:11,950
can't avoid it if you're ordering by

00:32:09,549 --> 00:32:13,870
different columns across tables or or so

00:32:11,950 --> 00:32:15,789
forth and this wiki page could give you

00:32:13,870 --> 00:32:17,200
the in-depth analysis if you really want

00:32:15,789 --> 00:32:20,830
to understand how the optimizer works of

00:32:17,200 --> 00:32:23,200
those the issue of a temporary table is

00:32:20,830 --> 00:32:25,179
that sometimes a temporary table can't

00:32:23,200 --> 00:32:28,179
fit in memory for certain certain

00:32:25,179 --> 00:32:30,580
reasons and is written to disk and a

00:32:28,179 --> 00:32:33,039
created temporary table status variable

00:32:30,580 --> 00:32:35,500
is sometimes acceptable but a created

00:32:33,039 --> 00:32:37,000
disk temporary table is an impact on

00:32:35,500 --> 00:32:39,610
your system and when you see lots of

00:32:37,000 --> 00:32:41,289
those when you see 20 30 60 a second

00:32:39,610 --> 00:32:43,510
that's a lot of disk i/o that may be

00:32:41,289 --> 00:32:45,159
able to be eliminated there are two

00:32:43,510 --> 00:32:47,890
causes of why you have a created

00:32:45,159 --> 00:32:49,929
temporary table first core the first

00:32:47,890 --> 00:32:52,870
cause is the data that is joining

00:32:49,929 --> 00:32:56,080
together is it's working with a texture

00:32:52,870 --> 00:32:57,700
of blob column so all those ORM products

00:32:56,080 --> 00:32:59,590
out there I have to keep back in our RM

00:32:57,700 --> 00:33:00,850
now you mentioned it they just go I'm

00:32:59,590 --> 00:33:03,279
going to create the column called text

00:33:00,850 --> 00:33:05,260
and text and text and not vouch our if

00:33:03,279 --> 00:33:07,419
internally mysql has to join that data

00:33:05,260 --> 00:33:09,279
together or do any work and it needs a

00:33:07,419 --> 00:33:10,600
temporary table it will go I can't

00:33:09,279 --> 00:33:12,429
actually do that in memory I have to

00:33:10,600 --> 00:33:14,710
write at the desk I have to read it back

00:33:12,429 --> 00:33:17,020
from disk and automatic your query is a

00:33:14,710 --> 00:33:18,730
hundred times slower the other

00:33:17,020 --> 00:33:21,039
recurrence is is that if you exceed the

00:33:18,730 --> 00:33:23,710
size of the table which is the minimum

00:33:21,039 --> 00:33:26,200
of these two variables then my us will

00:33:23,710 --> 00:33:28,809
go it's too large now you can change

00:33:26,200 --> 00:33:30,880
those variables on a per SQL statement

00:33:28,809 --> 00:33:32,830
basis so if one query is joining a lot

00:33:30,880 --> 00:33:35,289
of data together you may say just give a

00:33:32,830 --> 00:33:37,510
little bit more memory but combined with

00:33:35,289 --> 00:33:39,549
that show status command that I

00:33:37,510 --> 00:33:41,590
mentioned earlier you can look at that

00:33:39,549 --> 00:33:43,299
in conjunction with running a query and

00:33:41,590 --> 00:33:45,970
you could see some of the internal

00:33:43,299 --> 00:33:48,760
things in addition to when it says using

00:33:45,970 --> 00:33:49,570
temporary the explain pain won't tell

00:33:48,760 --> 00:33:51,669
you whether it's going to write it to

00:33:49,570 --> 00:33:57,039
disk or not the status variables will

00:33:51,669 --> 00:33:58,990
tell you that using filesort as the name

00:33:57,039 --> 00:34:01,270
describes is I have to sort the data

00:33:58,990 --> 00:34:03,429
that I've been given into the order in

00:34:01,270 --> 00:34:06,789
which you want it generally in order by

00:34:03,429 --> 00:34:08,919
statement and this is generally okay

00:34:06,789 --> 00:34:11,320
this is you know this is just part of

00:34:08,919 --> 00:34:12,820
life but it can become cpu intensive if

00:34:11,320 --> 00:34:14,270
you're running hundreds and hundreds of

00:34:12,820 --> 00:34:16,250
queries per second at how

00:34:14,270 --> 00:34:17,810
to sort a certain amount of data you can

00:34:16,250 --> 00:34:20,179
actually see the cpu load in the system

00:34:17,810 --> 00:34:21,679
go up sometimes that's not really that

00:34:20,179 --> 00:34:24,110
important these days because machines

00:34:21,679 --> 00:34:27,290
have so many cause you can afford to get

00:34:24,110 --> 00:34:31,250
away with that there are two ways to

00:34:27,290 --> 00:34:32,600
improve a using filesort one is to ask

00:34:31,250 --> 00:34:35,300
the question do you need to sort the

00:34:32,600 --> 00:34:36,770
data maybe the data doesn't have to be

00:34:35,300 --> 00:34:39,020
sorted maybe the application or the

00:34:36,770 --> 00:34:41,000
client can actually sort it well the

00:34:39,020 --> 00:34:44,630
other way is can you use an index to

00:34:41,000 --> 00:34:47,060
sort the data now I go back to the

00:34:44,630 --> 00:34:49,850
earlier rules generally mysql will use

00:34:47,060 --> 00:34:53,030
one index per table and an index can be

00:34:49,850 --> 00:34:56,480
used in the where join qualifications

00:34:53,030 --> 00:34:59,390
the order by and the group by so it's

00:34:56,480 --> 00:35:03,710
going to choose one or the other here is

00:34:59,390 --> 00:35:05,810
an example of a query where I gave you

00:35:03,710 --> 00:35:07,730
the answer here's an example of query

00:35:05,810 --> 00:35:09,770
where you can see that i'm joining two

00:35:07,730 --> 00:35:12,620
tables together i can see that i'm using

00:35:09,770 --> 00:35:14,150
keys so in this particular case i'm

00:35:12,620 --> 00:35:20,030
using a primary key and the customer ID

00:35:14,150 --> 00:35:22,370
and then from the from the table itself

00:35:20,030 --> 00:35:27,200
i'm actually sorting the results of the

00:35:22,370 --> 00:35:30,440
data now if only I improve my indexes so

00:35:27,200 --> 00:35:32,630
what I've done is I've created a a in

00:35:30,440 --> 00:35:35,060
this case an index that has an

00:35:32,630 --> 00:35:37,070
additional column but I'm able to

00:35:35,060 --> 00:35:40,490
leverage the index now both in the where

00:35:37,070 --> 00:35:44,810
clause and in the sorting so I'm able to

00:35:40,490 --> 00:35:46,370
remove the using filesort if you can do

00:35:44,810 --> 00:35:48,110
this this is a big win it can be a

00:35:46,370 --> 00:35:50,390
little bit complicated to do depends on

00:35:48,110 --> 00:35:52,070
how complicated your ordering is but

00:35:50,390 --> 00:35:55,460
this is one way to actually eliminate

00:35:52,070 --> 00:35:57,590
file sorting the benefit is is that the

00:35:55,460 --> 00:35:59,810
data is sorted on disk when the rows are

00:35:57,590 --> 00:36:01,070
inserted and updated and deleted my

00:35:59,810 --> 00:36:02,240
school's done it once and it doesn't

00:36:01,070 --> 00:36:08,480
have to bother about sorting the data

00:36:02,240 --> 00:36:10,280
every time now I talked about the key

00:36:08,480 --> 00:36:13,010
attribute and the key attribute tells

00:36:10,280 --> 00:36:16,520
you which index was going to be used by

00:36:13,010 --> 00:36:19,910
the query now the extra column also has

00:36:16,520 --> 00:36:21,920
a value called using index and you may

00:36:19,910 --> 00:36:24,110
go well why are you telling me you're

00:36:21,920 --> 00:36:25,329
using index because the key says you're

00:36:24,110 --> 00:36:28,029
using the index

00:36:25,329 --> 00:36:31,390
what it really means is that I am only

00:36:28,029 --> 00:36:32,709
using the index now for those people

00:36:31,390 --> 00:36:35,440
enough for me with this is what's known

00:36:32,709 --> 00:36:37,869
as a covering index and I have an entire

00:36:35,440 --> 00:36:40,599
presentation of an hour that describes

00:36:37,869 --> 00:36:41,769
how you would find a situation where you

00:36:40,599 --> 00:36:44,289
could actually use a covering it

00:36:41,769 --> 00:36:46,749
exciting go through a single table join

00:36:44,289 --> 00:36:50,349
and a 2 table joint and a 13 table join

00:36:46,749 --> 00:36:52,059
of how good this actually is what this

00:36:50,349 --> 00:36:55,599
means is that when it's joining two

00:36:52,059 --> 00:36:57,640
tables together and it uses it index to

00:36:55,599 --> 00:37:00,069
work out what types of rows at once in

00:36:57,640 --> 00:37:01,900
the join it then does not have to go

00:37:00,069 --> 00:37:04,839
look at the data that matches those rows

00:37:01,900 --> 00:37:07,410
the index itself satisfies all the

00:37:04,839 --> 00:37:10,029
information that you want for the query

00:37:07,410 --> 00:37:11,859
basically if you see the words using

00:37:10,029 --> 00:37:13,539
index that's about the best you can get

00:37:11,859 --> 00:37:16,930
if you're actually using an index this

00:37:13,539 --> 00:37:19,420
is the way to go here is an example of a

00:37:16,930 --> 00:37:22,660
query that I work with a client and it

00:37:19,420 --> 00:37:25,930
would ran 25,000 times per second across

00:37:22,660 --> 00:37:28,900
their servers and they thought that they

00:37:25,930 --> 00:37:31,449
were running the query really well they

00:37:28,900 --> 00:37:35,349
tune the query they'd created a key

00:37:31,449 --> 00:37:37,599
column on every table of the 13 table

00:37:35,349 --> 00:37:39,160
join and they were convinced that they

00:37:37,599 --> 00:37:42,969
couldn't make the query run any better

00:37:39,160 --> 00:37:46,509
and so it took 175 milliseconds to run

00:37:42,969 --> 00:37:49,959
but as being executed no many thousands

00:37:46,509 --> 00:37:51,430
of times per second I simply took the

00:37:49,959 --> 00:37:53,289
query I never changed the code and

00:37:51,430 --> 00:37:56,920
change the configuration I just improved

00:37:53,289 --> 00:37:58,420
the indexes this one tip of trying to

00:37:56,920 --> 00:38:00,999
create what's known as a covering index

00:37:58,420 --> 00:38:03,430
by adding additional columns two indexes

00:38:00,999 --> 00:38:05,949
so that MySQL didn't have to do joint

00:38:03,430 --> 00:38:07,690
didn't have to find the index values I'm

00:38:05,949 --> 00:38:09,759
doing a joint I find ten rows and then

00:38:07,690 --> 00:38:12,029
I've got to do sequential lookups to

00:38:09,759 --> 00:38:16,329
look at the values of those ten roads

00:38:12,029 --> 00:38:17,949
135 milliseconds five milliseconds now

00:38:16,329 --> 00:38:24,069
you might go that's okay but remember

00:38:17,949 --> 00:38:27,999
this is 135 milliseconds x 25,000 so a

00:38:24,069 --> 00:38:30,069
huge win so as I said there's another

00:38:27,999 --> 00:38:32,049
presentation about this so using indexes

00:38:30,069 --> 00:38:34,599
something that if you really want to

00:38:32,049 --> 00:38:37,110
expand how to understand and optimize

00:38:34,599 --> 00:38:40,380
queries with indexes doing that

00:38:37,110 --> 00:38:42,600
I also want to point out that I'm

00:38:40,380 --> 00:38:45,390
explaining how to use the explain plan

00:38:42,600 --> 00:38:47,430
and I'm talking about creating indexes

00:38:45,390 --> 00:38:49,530
and improving indexes and I talked

00:38:47,430 --> 00:38:51,750
before about maybe rewriting queries may

00:38:49,530 --> 00:38:54,810
be efficient it's important to realize

00:38:51,750 --> 00:38:57,420
that creating and adding or changing

00:38:54,810 --> 00:39:00,750
indexes is not the only way to optimize

00:38:57,420 --> 00:39:02,520
an SQL query and quite often it's not

00:39:00,750 --> 00:39:05,250
the only way to do it and it's not the

00:39:02,520 --> 00:39:07,260
best way so again we're talking about

00:39:05,250 --> 00:39:09,510
one particular case but realize in terms

00:39:07,260 --> 00:39:12,810
of larger design there are often other

00:39:09,510 --> 00:39:14,520
ways to improve things here's one of

00:39:12,810 --> 00:39:17,310
those other extra value is called using

00:39:14,520 --> 00:39:18,600
join buffer what this means is that I

00:39:17,310 --> 00:39:20,940
have some data and I want to try and

00:39:18,600 --> 00:39:22,620
join to another table but I can't find

00:39:20,940 --> 00:39:24,630
the key to you so you can see the other

00:39:22,620 --> 00:39:26,910
attributes I was telling you about we

00:39:24,630 --> 00:39:28,850
can see the possible key there but we

00:39:26,910 --> 00:39:31,800
could see the actual key used was null

00:39:28,850 --> 00:39:33,930
so here's an indicator that it's doing a

00:39:31,800 --> 00:39:35,460
scan and joining data together and in

00:39:33,930 --> 00:39:40,200
there's a room for improvement with an

00:39:35,460 --> 00:39:42,420
index there there are some other less

00:39:40,200 --> 00:39:46,440
common types of values that you'll see

00:39:42,420 --> 00:39:48,210
from time to time this is one of my ones

00:39:46,440 --> 00:39:50,160
I like to see a lot of people people go

00:39:48,210 --> 00:39:53,370
what does that really mean slick tables

00:39:50,160 --> 00:39:55,680
have been optimized away you don't need

00:39:53,370 --> 00:39:57,960
a table anymore well in this case what

00:39:55,680 --> 00:40:00,660
happens is is that the actual second

00:39:57,960 --> 00:40:02,370
table which is a drive table satisfies

00:40:00,660 --> 00:40:04,500
the results it doesn't actually need the

00:40:02,370 --> 00:40:08,760
first table anymore it's sort of like a

00:40:04,500 --> 00:40:11,970
using index value I mentioned earlier

00:40:08,760 --> 00:40:15,510
that there are a couple of exceptions to

00:40:11,970 --> 00:40:18,090
that one index per table rule you may

00:40:15,510 --> 00:40:20,340
see these particular sin taxes using

00:40:18,090 --> 00:40:22,920
sort join sort Union Union intersect

00:40:20,340 --> 00:40:27,660
that it's using more than one index per

00:40:22,920 --> 00:40:29,520
table now when I first these these types

00:40:27,660 --> 00:40:33,060
of operations came out in mysql

00:40:29,520 --> 00:40:36,840
five-point go well now you can use two

00:40:33,060 --> 00:40:38,310
indexes in a particular table and it

00:40:36,840 --> 00:40:40,290
wasn't until I was actually writing the

00:40:38,310 --> 00:40:42,720
book about this that I was actually able

00:40:40,290 --> 00:40:44,730
to find an example where mysql would

00:40:42,720 --> 00:40:47,640
actually join three indexes on one

00:40:44,730 --> 00:40:48,930
particular table now I can't say that's

00:40:47,640 --> 00:40:49,770
going to be more efficient than not

00:40:48,930 --> 00:40:51,270
doing it

00:40:49,770 --> 00:40:54,450
but but the thing is is that you can

00:40:51,270 --> 00:40:58,500
actually see further complexity in this

00:40:54,450 --> 00:41:00,720
particular merging of indexes now there

00:40:58,500 --> 00:41:02,820
are two other extensions to the explain

00:41:00,720 --> 00:41:05,040
command there's the explain petitions

00:41:02,820 --> 00:41:07,470
command which will give you an extra

00:41:05,040 --> 00:41:10,020
attribute and lo and behold it's called

00:41:07,470 --> 00:41:11,490
petitions and it will describe the

00:41:10,020 --> 00:41:13,950
petitions that is actually using for a

00:41:11,490 --> 00:41:17,300
petition table so no rocket science

00:41:13,950 --> 00:41:20,640
necessary there the second example is

00:41:17,300 --> 00:41:23,070
explained extended now this produces an

00:41:20,640 --> 00:41:24,930
extra column called filtered which can

00:41:23,070 --> 00:41:26,280
help in terms of giving you a better

00:41:24,930 --> 00:41:29,820
estimate of the number of rows it's

00:41:26,280 --> 00:41:32,700
looking at in reality I've rarely seen

00:41:29,820 --> 00:41:35,220
it not be a hundred and I don't find the

00:41:32,700 --> 00:41:38,940
great value and actually looking at that

00:41:35,220 --> 00:41:40,860
particular information however explain

00:41:38,940 --> 00:41:42,720
extended does something very important

00:41:40,860 --> 00:41:45,900
in that it actually gives you a warning

00:41:42,720 --> 00:41:49,200
and if you actually heed the advice and

00:41:45,900 --> 00:41:52,440
look at the warning you will find that

00:41:49,200 --> 00:41:54,240
it will show you the rewrite of the SQL

00:41:52,440 --> 00:41:57,570
statement that the pars and the

00:41:54,240 --> 00:41:59,970
optimizer under talk now this is not

00:41:57,570 --> 00:42:01,800
common practice you don't generally have

00:41:59,970 --> 00:42:03,620
to look at this and experience dba's

00:42:01,800 --> 00:42:06,270
sometimes don't even know about this and

00:42:03,620 --> 00:42:07,920
here's an actual example where a

00:42:06,270 --> 00:42:09,750
colleague who was an experienced DBA

00:42:07,920 --> 00:42:11,580
said I don't know what's wrong with this

00:42:09,750 --> 00:42:14,850
query I've looked at the explain plan

00:42:11,580 --> 00:42:17,100
I've looked at the show create table I

00:42:14,850 --> 00:42:18,540
have 10 million rows here I have 20

00:42:17,100 --> 00:42:21,150
million rows here I'm joining two

00:42:18,540 --> 00:42:24,390
primary keys why is it not using the

00:42:21,150 --> 00:42:25,800
index because it would show that it

00:42:24,390 --> 00:42:28,950
would looked at the index and it should

00:42:25,800 --> 00:42:31,590
have discarded them explained extended

00:42:28,950 --> 00:42:34,230
can help show you what it rewrote the

00:42:31,590 --> 00:42:35,790
query to do if you're using a view for

00:42:34,230 --> 00:42:37,980
example other types operations you can

00:42:35,790 --> 00:42:41,190
see what's expanded in here what

00:42:37,980 --> 00:42:42,990
happened was the career was being

00:42:41,190 --> 00:42:45,270
written to actually do a scalar function

00:42:42,990 --> 00:42:48,420
a convert on the particular column was

00:42:45,270 --> 00:42:49,920
converting the column to utf-8 and if

00:42:48,420 --> 00:42:51,600
you actually went back and looked at the

00:42:49,920 --> 00:42:54,090
table definition one was defined as

00:42:51,600 --> 00:42:56,700
Latin one wonders to find his utf-8 and

00:42:54,090 --> 00:42:59,040
even they were were both columns to join

00:42:56,700 --> 00:43:00,720
together mysql couldn't handle it so i

00:42:59,040 --> 00:43:02,390
had to convert one had to like do a

00:43:00,720 --> 00:43:04,069
conversion of the column

00:43:02,390 --> 00:43:06,260
and because there's no scalar functions

00:43:04,069 --> 00:43:08,750
in MySQL indexes it basically get the

00:43:06,260 --> 00:43:11,180
scan the entire table to convert the

00:43:08,750 --> 00:43:12,799
actual column to the right data type so

00:43:11,180 --> 00:43:15,019
here's one of those examples where

00:43:12,799 --> 00:43:17,930
explain extended is sort of like a less

00:43:15,019 --> 00:43:19,760
commonly used syntax but can provide a

00:43:17,930 --> 00:43:21,829
little bit of help when you when you

00:43:19,760 --> 00:43:24,400
sort of wonder why the explain plan it's

00:43:21,829 --> 00:43:26,359
not actually doing what it wants I

00:43:24,400 --> 00:43:29,289
mentioned earlier there are some hints

00:43:26,359 --> 00:43:33,890
these are things that you can use to

00:43:29,289 --> 00:43:36,410
give that query optimizer a hint to say

00:43:33,890 --> 00:43:38,089
I want you to do this and there are

00:43:36,410 --> 00:43:40,160
certain types of general hints on

00:43:38,089 --> 00:43:42,440
indexes you can say I've lucky to use

00:43:40,160 --> 00:43:44,480
this index I'd like you to ignore this

00:43:42,440 --> 00:43:48,079
index or I really really want you to use

00:43:44,480 --> 00:43:49,400
this index and as I mentioned before you

00:43:48,079 --> 00:43:51,079
know your next is a use in the join

00:43:49,400 --> 00:43:52,430
order buying group by you can say I want

00:43:51,079 --> 00:43:57,619
to use it in one particular type or the

00:43:52,430 --> 00:43:59,420
other there is another hint which

00:43:57,619 --> 00:44:02,720
sometimes becomes beneficial called

00:43:59,420 --> 00:44:04,760
straight join when used with the Select

00:44:02,720 --> 00:44:06,440
statement this actually says the order

00:44:04,760 --> 00:44:08,720
of which i'm giving you the tables in

00:44:06,440 --> 00:44:11,029
that in the actual query that's the

00:44:08,720 --> 00:44:13,839
order I want you to process them in so

00:44:11,029 --> 00:44:15,829
sometimes this can actually be hopeful

00:44:13,839 --> 00:44:17,930
there are some other ones that deal with

00:44:15,829 --> 00:44:20,029
caching with whether you want to case

00:44:17,930 --> 00:44:22,130
the result in the query cache whether

00:44:20,029 --> 00:44:23,480
you want to buffer the information on

00:44:22,130 --> 00:44:25,700
the server before so any of the client

00:44:23,480 --> 00:44:29,299
change the priority there's also one

00:44:25,700 --> 00:44:30,950
called SQL cult found rose and for some

00:44:29,299 --> 00:44:33,829
applications this is beneficial because

00:44:30,950 --> 00:44:37,039
people will do a select information from

00:44:33,829 --> 00:44:39,019
table limit a certain number of rows put

00:44:37,039 --> 00:44:41,180
those 20 rows on the page of your web

00:44:39,019 --> 00:44:42,799
page but then have to run another query

00:44:41,180 --> 00:44:44,779
to work out how many rows are in the

00:44:42,799 --> 00:44:47,240
query so you can say this is page 1 of

00:44:44,779 --> 00:44:50,029
10 and so you see you're running the

00:44:47,240 --> 00:44:53,779
query twice you can actually use select

00:44:50,029 --> 00:44:55,250
SQL cockburn rose to actually give you

00:44:53,779 --> 00:44:58,250
that number without have to actually run

00:44:55,250 --> 00:45:00,380
the full query so i can say i'm getting

00:44:58,250 --> 00:45:03,920
10 rows back but then i can actually go

00:45:00,380 --> 00:45:06,170
how many rows that i actually find now

00:45:03,920 --> 00:45:08,210
while this is good you have to realize

00:45:06,170 --> 00:45:09,650
that sometimes the time it takes to do

00:45:08,210 --> 00:45:12,710
this was actually longer than running

00:45:09,650 --> 00:45:14,839
both queries so I show you as the hint

00:45:12,710 --> 00:45:15,440
to go this exists for people sometimes

00:45:14,839 --> 00:45:19,040
don't know about

00:45:15,440 --> 00:45:20,720
but use with appropriate testing and

00:45:19,040 --> 00:45:22,700
verification when you start running

00:45:20,720 --> 00:45:24,800
several hundreds of these per second

00:45:22,700 --> 00:45:29,330
you'll find it's far less efficient than

00:45:24,800 --> 00:45:33,110
you think so wrapping up and I'm almost

00:45:29,330 --> 00:45:35,390
out of time you have to know how to use

00:45:33,110 --> 00:45:36,830
explain in this presentation I've just

00:45:35,390 --> 00:45:38,930
gone through and given you an overview

00:45:36,830 --> 00:45:41,390
of what's important how to read it

00:45:38,930 --> 00:45:42,890
because how to read it will help you in

00:45:41,390 --> 00:45:45,380
determining how your system is working

00:45:42,890 --> 00:45:46,880
and how you can make improvements it's

00:45:45,380 --> 00:45:48,560
not the only information you need there

00:45:46,880 --> 00:45:50,420
are other commands and other values that

00:45:48,560 --> 00:45:52,490
when you combine together the table

00:45:50,420 --> 00:45:54,110
definition how well the index card in

00:45:52,490 --> 00:45:56,330
allender years maybe some of the

00:45:54,110 --> 00:45:58,760
statistics that show status all those

00:45:56,330 --> 00:46:01,400
things can help you interpret with the

00:45:58,760 --> 00:46:03,020
explain plan there are some other

00:46:01,400 --> 00:46:04,340
presentations that I have that are

00:46:03,020 --> 00:46:06,320
related to this topic so if you want to

00:46:04,340 --> 00:46:08,600
understand a little bit more there's an

00:46:06,320 --> 00:46:11,750
entire presentation just on the

00:46:08,600 --> 00:46:14,060
internals of indexes because in mysql

00:46:11,750 --> 00:46:17,360
there's general people known as a b-tree

00:46:14,060 --> 00:46:19,310
index there's a hash index now even if

00:46:17,360 --> 00:46:21,800
you know how a b-tree index works in

00:46:19,310 --> 00:46:24,530
theory in Maya stroll as a b-tree index

00:46:21,800 --> 00:46:26,660
which works with a clustered key there's

00:46:24,530 --> 00:46:29,090
a b-tree index in a storage engine of my

00:46:26,660 --> 00:46:31,010
I Sam and as a b-tree index and storage

00:46:29,090 --> 00:46:32,960
engine of nodb both for secondary

00:46:31,010 --> 00:46:35,000
indexes their implementation is

00:46:32,960 --> 00:46:36,050
different the columns and the values

00:46:35,000 --> 00:46:37,970
that it uses our difference so

00:46:36,050 --> 00:46:39,890
understanding internally can help you

00:46:37,970 --> 00:46:41,720
improve things and the other in other

00:46:39,890 --> 00:46:44,180
career other presentation I talked about

00:46:41,720 --> 00:46:48,980
about particularly about how to see the

00:46:44,180 --> 00:46:52,340
using extra is beneficial as well and I

00:46:48,980 --> 00:46:54,470
think that's all I had so are there any

00:46:52,340 --> 00:47:03,580
questions that you would like to know

00:46:54,470 --> 00:47:03,580
about the MySQL explain plan yes yes

00:47:06,310 --> 00:47:11,119
that the question is an explaining

00:47:08,660 --> 00:47:14,690
standard does it actually show you the

00:47:11,119 --> 00:47:16,250
change query good question I believe it

00:47:14,690 --> 00:47:18,680
will always show you the query that it

00:47:16,250 --> 00:47:20,570
used but it may be exactly the same you

00:47:18,680 --> 00:47:22,250
may not actually know it's different the

00:47:20,570 --> 00:47:23,780
warning will always be there and I think

00:47:22,250 --> 00:47:25,250
it'll to show you the act basically

00:47:23,780 --> 00:47:26,810
shows you the The Courier is working

00:47:25,250 --> 00:47:35,980
with so you then have to like compare

00:47:26,810 --> 00:47:38,480
them anybody else nope sorry what's the

00:47:35,980 --> 00:47:40,130
okay so the things in 5.6 or

00:47:38,480 --> 00:47:42,220
improvements are one you can run an

00:47:40,130 --> 00:47:45,350
explain plan on insert update and delete

00:47:42,220 --> 00:47:47,060
the optimizer trace is a new command

00:47:45,350 --> 00:47:49,609
that will give you the full detail of

00:47:47,060 --> 00:47:51,619
information in JSON format you can also

00:47:49,609 --> 00:47:53,990
X you can also run the explain plan and

00:47:51,619 --> 00:47:55,490
give you a JSON output so I've shown you

00:47:53,990 --> 00:47:56,840
the output and columns of variables but

00:47:55,490 --> 00:47:59,270
now it can actually give you Jason

00:47:56,840 --> 00:48:02,240
output and actually the fourth thing is

00:47:59,270 --> 00:48:04,190
is that the operations that sometimes

00:48:02,240 --> 00:48:06,020
require you to execute sub queries to

00:48:04,190 --> 00:48:07,609
derive tables there have been some very

00:48:06,020 --> 00:48:09,380
good improvement in the time that it

00:48:07,609 --> 00:48:10,970
takes that so sometimes you do

00:48:09,380 --> 00:48:12,440
unexplained you expect immediate result

00:48:10,970 --> 00:48:14,869
but it takes 30 seconds and you wonder

00:48:12,440 --> 00:48:16,670
why there been some improvements there

00:48:14,869 --> 00:48:18,350
as well the third one that was really

00:48:16,670 --> 00:48:20,180
like they explained output can now be

00:48:18,350 --> 00:48:31,190
written in a JSON output so you can use

00:48:20,180 --> 00:48:32,660
other tools to parse that yes yes the

00:48:31,190 --> 00:48:34,730
question is if you're running and

00:48:32,660 --> 00:48:37,940
explain that has a query that has an

00:48:34,730 --> 00:48:42,230
update in the sub-query I'm not familiar

00:48:37,940 --> 00:48:43,880
with that syntax so I don't know what

00:48:42,230 --> 00:48:45,080
the output actually look like maybe we

00:48:43,880 --> 00:48:47,270
can take them on a flying you can show

00:48:45,080 --> 00:48:49,700
me one of those are you running a slack

00:48:47,270 --> 00:48:51,980
state with an update inside I derived

00:48:49,700 --> 00:48:54,619
table or something or a sub-query okay i

00:48:51,980 --> 00:48:56,359
can't say i've seen that so i won't

00:48:54,619 --> 00:49:01,670
comment on what the output would look

00:48:56,359 --> 00:49:02,690
like it does so new about my school

00:49:01,670 --> 00:49:07,100
running on the machine want to pick it

00:49:02,690 --> 00:49:08,090
up and try it out on there's a big cloud

00:49:07,100 --> 00:49:09,380
thing happening that everyone should

00:49:08,090 --> 00:49:10,670
know better how to run something in the

00:49:09,380 --> 00:49:14,720
cloud which one should be at a fire up

00:49:10,670 --> 00:49:20,420
their AWS instance 60 seconds no

00:49:14,720 --> 00:49:21,770
okay well thank you very much so if you

00:49:20,420 --> 00:49:25,460
come up here I have a book that I

00:49:21,770 --> 00:49:27,650
grabbed out of my bag as a brave soul

00:49:25,460 --> 00:49:31,270
for giving an actually reasonably

00:49:27,650 --> 00:49:31,270
correct answer great

00:49:42,360 --> 00:49:44,420
you

00:50:01,770 --> 00:50:03,830
you

00:50:07,040 --> 00:50:11,849
when we created asterisk over a decade

00:50:09,780 --> 00:50:14,070
ago we could not have imagined that

00:50:11,849 --> 00:50:16,290
asterisk would not only become the most

00:50:14,070 --> 00:50:18,420
widely adopted open source communication

00:50:16,290 --> 00:50:20,460
software on the planet but that it would

00:50:18,420 --> 00:50:22,980
impact the entire industry in the way

00:50:20,460 --> 00:50:24,960
that it has today asterisk has found its

00:50:22,980 --> 00:50:27,599
way in the more than 170 countries and

00:50:24,960 --> 00:50:29,550
virtually every fortune 1000 company the

00:50:27,599 --> 00:50:31,619
success of asterisk has enabled a

00:50:29,550 --> 00:50:33,030
transition of power from the hands of

00:50:31,619 --> 00:50:35,310
the traditional proprietary phone

00:50:33,030 --> 00:50:37,710
vendors into the hands of the users and

00:50:35,310 --> 00:50:39,660
administrators of phone systems using

00:50:37,710 --> 00:50:40,890
this power our customers have created

00:50:39,660 --> 00:50:42,810
all sorts of business changing

00:50:40,890 --> 00:50:44,670
applications from small office phone

00:50:42,810 --> 00:50:47,190
systems to mission-critical call centers

00:50:44,670 --> 00:50:48,780
the international carrier networks in

00:50:47,190 --> 00:50:50,580
fact there's even an entire country

00:50:48,780 --> 00:50:52,980
those communications infrastructure runs

00:50:50,580 --> 00:50:55,109
on esters the gym has always been about

00:50:52,980 --> 00:50:56,820
creating technology that expands

00:50:55,109 --> 00:50:58,980
communications capabilities in ways that

00:50:56,820 --> 00:51:00,180
we could never have imagined and that's

00:50:58,980 --> 00:51:02,940
part of what's game-changing about

00:51:00,180 --> 00:51:05,280
Digium today we're doing it again this

00:51:02,940 --> 00:51:07,349
time by introducing a new family of HD

00:51:05,280 --> 00:51:09,480
IP phones that extends control of the

00:51:07,349 --> 00:51:11,220
user all the way to the desktop the

00:51:09,480 --> 00:51:12,960
launch of these new products represents

00:51:11,220 --> 00:51:14,940
the next phase indigenous history of

00:51:12,960 --> 00:51:17,460
innovation these are the first and only

00:51:14,940 --> 00:51:19,140
IP phones designed to fully leverage the

00:51:17,460 --> 00:51:20,700
power of estrus when we first discussed

00:51:19,140 --> 00:51:22,740
our expectations for building a family

00:51:20,700 --> 00:51:24,900
of phones for use with asterisk our

00:51:22,740 --> 00:51:26,640
requirements were pretty simple we asked

00:51:24,900 --> 00:51:28,260
the team to build the phones such that

00:51:26,640 --> 00:51:30,480
they were easy to install integrate

00:51:28,260 --> 00:51:32,310
provision and use I think you'll soon

00:51:30,480 --> 00:51:34,890
agree our engineers have delivered on

00:51:32,310 --> 00:51:36,510
that goal user feedback is validating

00:51:34,890 --> 00:51:38,609
that when it comes to operation with

00:51:36,510 --> 00:51:41,040
astro space systems including our own

00:51:38,609 --> 00:51:43,619
Switchvox based product these are the

00:51:41,040 --> 00:51:44,940
easiest to use best integrated most

00:51:43,619 --> 00:51:47,520
interoperable products on the market

00:51:44,940 --> 00:51:49,500
today the digitally phones will

00:51:47,520 --> 00:51:51,570
initially include three IP desk phones

00:51:49,500 --> 00:51:53,390
uniquely designed to complement any

00:51:51,570 --> 00:51:55,380
asterisk or switch box base solution

00:51:53,390 --> 00:51:57,960
these phones are different for a number

00:51:55,380 --> 00:52:00,690
of reasons first there is conclusively

00:51:57,960 --> 00:52:02,130
designed for use with esters secondly

00:52:00,690 --> 00:52:03,740
we've made it really easy to

00:52:02,130 --> 00:52:06,119
autodiscover and provision the phones

00:52:03,740 --> 00:52:08,190
next we've made it easy for the phones

00:52:06,119 --> 00:52:10,140
to access information inside of estrus

00:52:08,190 --> 00:52:11,760
allowing tight coupling between the

00:52:10,140 --> 00:52:13,750
application and the

00:52:11,760 --> 00:52:15,910
additionally we've created an

00:52:13,750 --> 00:52:18,010
applications engineer that allows users

00:52:15,910 --> 00:52:21,250
and developers to create and run their

00:52:18,010 --> 00:52:23,020
own apps on the phone and finally we've

00:52:21,250 --> 00:52:24,970
done all of this at a very compelling

00:52:23,020 --> 00:52:26,650
price point at digium we're always

00:52:24,970 --> 00:52:28,750
thinking of ways to give our customers

00:52:26,650 --> 00:52:31,330
the best value in business phone systems

00:52:28,750 --> 00:52:32,890
and also give them the power to create

00:52:31,330 --> 00:52:35,020
their own solutions or any

00:52:32,890 --> 00:52:36,760
communications challenge well continue

00:52:35,020 --> 00:52:38,170
to push the boundaries not only to make

00:52:36,760 --> 00:52:40,240
Astra's cooler faster and more

00:52:38,170 --> 00:52:41,859
technologically feature-rich but to make

00:52:40,240 --> 00:52:44,320
asterisk and web communications even

00:52:41,859 --> 00:52:47,820
easier and together we'll change the way

00:52:44,320 --> 00:52:47,820
the world communication again

00:52:53,250 --> 00:52:55,310
you

00:52:58,400 --> 00:53:05,550
how stats that every way this is the way

00:53:02,070 --> 00:53:07,440
to better utilize all your resources and

00:53:05,550 --> 00:53:10,890
it makes managing all your resources

00:53:07,440 --> 00:53:14,720
pretty easy all of the innovation is

00:53:10,890 --> 00:53:18,240
happening in open source the

00:53:14,720 --> 00:53:20,010
collaborative nature and of the you know

00:53:18,240 --> 00:53:21,960
of the community and then the speed at

00:53:20,010 --> 00:53:23,850
which these are these you know these

00:53:21,960 --> 00:53:25,800
these deficiencies these bugs are

00:53:23,850 --> 00:53:28,140
getting discovered and then fixed is

00:53:25,800 --> 00:53:29,820
that I think that really shows the power

00:53:28,140 --> 00:53:32,580
of the you know of the open source

00:53:29,820 --> 00:53:34,730
community it is global and it's

00:53:32,580 --> 00:53:38,280
definitely because of the users

00:53:34,730 --> 00:53:43,920
community people are extremely friendly

00:53:38,280 --> 00:53:45,810
and they're always ready to help if you

00:53:43,920 --> 00:53:48,090
go on tire see any day you'll see these

00:53:45,810 --> 00:53:49,820
guys helping each other out and they're

00:53:48,090 --> 00:53:52,530
all doing it like in a selfless manner

00:53:49,820 --> 00:53:55,520
the product is transparent for everyone

00:53:52,530 --> 00:53:58,710
everyone can look at the code base

00:53:55,520 --> 00:54:00,950
everyone can see how close duck is being

00:53:58,710 --> 00:54:06,450
built nothing nothing is proprietary

00:54:00,950 --> 00:54:09,090
everything is open in many ways it's

00:54:06,450 --> 00:54:13,530
absolutely vital to the the ongoing

00:54:09,090 --> 00:54:17,730
health cloudstack the most exciting

00:54:13,530 --> 00:54:20,570
event in recent memory for he was our

00:54:17,730 --> 00:54:23,210
first developer boot camp

00:54:20,570 --> 00:54:25,850
and our call gave people I gave you two

00:54:23,210 --> 00:54:29,720
weeks notice to come attend I was

00:54:25,850 --> 00:54:34,010
expecting 25 or 30 people so if we ended

00:54:29,720 --> 00:54:36,830
up with 87 people and had to go get more

00:54:34,010 --> 00:54:39,380
chairs into the room twice everything

00:54:36,830 --> 00:54:42,620
within cloud computing is commodity and

00:54:39,380 --> 00:54:45,680
is open source and so I don't think that

00:54:42,620 --> 00:54:47,450
you will you'll see anywhere where open

00:54:45,680 --> 00:54:50,480
source is not pervasive in cloud

00:54:47,450 --> 00:54:53,030
computing and so i think it's i think

00:54:50,480 --> 00:54:54,530
it's an assumption i think when you talk

00:54:53,030 --> 00:54:55,670
about cloud computing you're really

00:54:54,530 --> 00:55:01,190
talking about open source cloud

00:54:55,670 --> 00:55:04,250
computing cloud sac is a robust solution

00:55:01,190 --> 00:55:06,380
for large deployments you'll have dozens

00:55:04,250 --> 00:55:10,640
of data centers and thousands of servers

00:55:06,380 --> 00:55:13,340
in each data centers these hardware is

00:55:10,640 --> 00:55:16,820
going to fail and CloudStack is designed

00:55:13,340 --> 00:55:19,520
to handle number one that mass scale

00:55:16,820 --> 00:55:22,700
number two it's designed to handle the

00:55:19,520 --> 00:55:25,520
failure that inevitably happens in large

00:55:22,700 --> 00:55:29,750
deployments started working on pod tech

00:55:25,520 --> 00:55:33,020
over four years ago and it was the

00:55:29,750 --> 00:55:34,790
original set of people working on it had

00:55:33,020 --> 00:55:38,900
a background of delivering software

00:55:34,790 --> 00:55:43,130
telcos and service providers lots of QA

00:55:38,900 --> 00:55:46,760
lots of users actually using it high

00:55:43,130 --> 00:55:49,850
availability is the key feature multiple

00:55:46,760 --> 00:55:51,860
hypervisors support different network

00:55:49,850 --> 00:55:54,530
models you can pick up whatever suits

00:55:51,860 --> 00:55:56,780
you better while step management server

00:55:54,530 --> 00:56:00,470
can be deployed in different physical

00:55:56,780 --> 00:56:02,150
machines it definitely has a huge

00:56:00,470 --> 00:56:07,130
footprint it's being deployed everywhere

00:56:02,150 --> 00:56:09,710
there's a major movie studio that they

00:56:07,130 --> 00:56:12,890
were using cloudstack they were using it

00:56:09,710 --> 00:56:14,990
to transcode video and i thought that

00:56:12,890 --> 00:56:16,640
was terribly fascinating what i found

00:56:14,990 --> 00:56:19,910
more fascinating is what they did during

00:56:16,640 --> 00:56:22,700
lunch where they would spin up you know

00:56:19,910 --> 00:56:23,849
50 or 60 game servers then as soon as

00:56:22,700 --> 00:56:25,680
lunch was over they would dis

00:56:23,849 --> 00:56:29,940
all the instances and go back to doing

00:56:25,680 --> 00:56:31,440
real work CloudStack is vast it touches

00:56:29,940 --> 00:56:33,539
so many different aspects and there's no

00:56:31,440 --> 00:56:35,910
one person that's kind of like a master

00:56:33,539 --> 00:56:40,019
of all those realms I think cloudstack

00:56:35,910 --> 00:56:42,239
as a project is going to be one of the

00:56:40,019 --> 00:56:46,289
leaders simply because it's some of the

00:56:42,239 --> 00:56:51,720
most feature fallen and and robust

00:56:46,289 --> 00:56:54,619
platforms out they were Adam senior

00:56:51,720 --> 00:56:54,619

YouTube URL: https://www.youtube.com/watch?v=qaB85pMVNJU


