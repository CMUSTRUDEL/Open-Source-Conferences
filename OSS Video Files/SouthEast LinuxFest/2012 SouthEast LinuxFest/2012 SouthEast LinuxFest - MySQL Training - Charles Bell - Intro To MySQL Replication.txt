Title: 2012 SouthEast LinuxFest - MySQL Training - Charles Bell - Intro To MySQL Replication
Publication date: 2013-12-02
Playlist: 2012 SouthEast LinuxFest
Description: 
	2012 SouthEast LinuxFest
MySQL Beginner Training
Charles Bell
Introduction To MySQL Replication
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,279
thank the following diamond sponsors in

00:00:21,320 --> 00:00:28,500
2012 for helping make these videos

00:00:23,279 --> 00:00:31,050
possible hello everyone welcome to

00:00:28,500 --> 00:00:33,690
introduction to mysql replication in

00:00:31,050 --> 00:00:36,450
this session i'll talk a lot about mysql

00:00:33,690 --> 00:00:39,270
replication what it is why you would use

00:00:36,450 --> 00:00:41,100
it a little bit about the details but

00:00:39,270 --> 00:00:44,640
again this is an introduction how many

00:00:41,100 --> 00:00:47,460
people use mysql now dude about

00:00:44,640 --> 00:00:48,480
replication how about people who wants

00:00:47,460 --> 00:00:51,030
you to replicate you but don't know what

00:00:48,480 --> 00:00:55,800
it is ah there you go that's what this

00:00:51,030 --> 00:00:57,960
session is for you ok standard

00:00:55,800 --> 00:01:02,070
disclaimer you everything I'm about to

00:00:57,960 --> 00:01:04,890
talk about may or may not be true check

00:01:02,070 --> 00:01:07,470
out oracle online to verify before you

00:01:04,890 --> 00:01:10,530
use it my name is Chuck bell i am the

00:01:07,470 --> 00:01:12,570
mysql utilities team lead i've been

00:01:10,530 --> 00:01:15,750
working with my escuela over eight years

00:01:12,570 --> 00:01:20,430
now a variety of things back up

00:01:15,750 --> 00:01:23,520
connectors replication utilities go on

00:01:20,430 --> 00:01:25,860
and on about it some of my interests or

00:01:23,520 --> 00:01:29,009
cloud computing replication so on and so

00:01:25,860 --> 00:01:33,060
forth there's a couple books you might

00:01:29,009 --> 00:01:35,250
want to check out today we're going to

00:01:33,060 --> 00:01:39,479
talk about again terminology basic

00:01:35,250 --> 00:01:41,640
things about mysql replication the using

00:01:39,479 --> 00:01:45,780
replication for scale out in other words

00:01:41,640 --> 00:01:47,549
to scale out your reads to allow your

00:01:45,780 --> 00:01:50,759
application to read more data more

00:01:47,549 --> 00:01:52,560
quickly and a little bit about high

00:01:50,759 --> 00:01:55,110
availability i actually did a a

00:01:52,560 --> 00:01:57,840
high-availability session two sessions

00:01:55,110 --> 00:01:59,520
ago but I some of the slides are in here

00:01:57,840 --> 00:02:01,829
because it is pertinent to replication

00:01:59,520 --> 00:02:04,200
which replication is a huge part of high

00:02:01,829 --> 00:02:05,700
availability then I'll talk about the

00:02:04,200 --> 00:02:07,590
binary log and won't go in too much

00:02:05,700 --> 00:02:10,349
detail there because I want to talk

00:02:07,590 --> 00:02:11,510
about mysql utilities a little bit and

00:02:10,349 --> 00:02:14,090
utilities or just

00:02:11,510 --> 00:02:19,159
among many things to make replication

00:02:14,090 --> 00:02:21,620
easier to manage so what is this this is

00:02:19,159 --> 00:02:23,629
mysql replication by the end of this

00:02:21,620 --> 00:02:30,349
session you'll be able to understand

00:02:23,629 --> 00:02:32,480
that drawing so some terminology mysql

00:02:30,349 --> 00:02:35,000
why would you use mysql replication well

00:02:32,480 --> 00:02:38,750
first and foremost we're looking at high

00:02:35,000 --> 00:02:42,200
availability if you use the latest

00:02:38,750 --> 00:02:45,109
version of mysql 5.6 which is actually a

00:02:42,200 --> 00:02:47,420
developer milestone release and think of

00:02:45,109 --> 00:02:50,810
it as a beta it's available for download

00:02:47,420 --> 00:02:52,849
for you to evaluate mysql 5.6 has a lot

00:02:50,810 --> 00:02:54,889
of advanced features particularly having

00:02:52,849 --> 00:02:57,230
to do with replication and i'll talk a

00:02:54,889 --> 00:03:00,230
little about those when i talk about the

00:02:57,230 --> 00:03:02,329
failover utility-scale out is the

00:03:00,230 --> 00:03:03,799
primary reason you would use mysql

00:03:02,329 --> 00:03:05,900
replication and i'll go into that a

00:03:03,799 --> 00:03:10,040
little bit so you spread your read

00:03:05,900 --> 00:03:12,590
queries out over many servers off-site

00:03:10,040 --> 00:03:16,129
processing perhaps you want to create a

00:03:12,590 --> 00:03:18,829
replicant a copy of your databases for

00:03:16,129 --> 00:03:21,829
you somewhere else maybe in a developer

00:03:18,829 --> 00:03:23,480
forum maybe in an engineering form

00:03:21,829 --> 00:03:24,919
something like that that needs a copy of

00:03:23,480 --> 00:03:27,049
the light data but you don't actually

00:03:24,919 --> 00:03:30,829
want anything that they do to affect

00:03:27,049 --> 00:03:32,389
your live data that's one way maybe for

00:03:30,829 --> 00:03:36,230
reporting so maybe you want to do some

00:03:32,389 --> 00:03:38,720
offline reports or something do kind of

00:03:36,230 --> 00:03:41,209
data warehousing kind of thing lastly

00:03:38,720 --> 00:03:43,160
Lionel replication is also a disaster

00:03:41,209 --> 00:03:45,639
recovery tool because it makes a

00:03:43,160 --> 00:03:48,769
replicant a copy of all your databases

00:03:45,639 --> 00:03:51,290
it's a great way to keep a backup in

00:03:48,769 --> 00:03:53,780
fact there's a strategy i'll show you of

00:03:51,290 --> 00:03:57,290
taking setting up replication for the

00:03:53,780 --> 00:03:59,930
sole purpose of creating a backup it

00:03:57,290 --> 00:04:02,599
allows you to do an online backup which

00:03:59,930 --> 00:04:05,030
is really cool because typically you

00:04:02,599 --> 00:04:08,000
need a special tool for that now how you

00:04:05,030 --> 00:04:11,569
would do this snapshots is one way of

00:04:08,000 --> 00:04:14,959
doing that I'll disaster recovery either

00:04:11,569 --> 00:04:16,459
making a backup or using the binary log

00:04:14,959 --> 00:04:18,739
to record changes that have happened

00:04:16,459 --> 00:04:21,500
these are the the individual changes

00:04:18,739 --> 00:04:23,990
inserts up deletes deletes that kind of

00:04:21,500 --> 00:04:27,190
thing or MySQL dumps too

00:04:23,990 --> 00:04:31,039
aight just a raw sequel version of your

00:04:27,190 --> 00:04:33,169
data or i should add the slide mysql DB

00:04:31,039 --> 00:04:35,569
export is one of the utilities which

00:04:33,169 --> 00:04:38,120
will allow you to export in SQL

00:04:35,569 --> 00:04:43,819
statements like mysql dump or comma

00:04:38,120 --> 00:04:45,590
separated values tabbed files and even

00:04:43,819 --> 00:04:47,620
grid format if you want to be able to

00:04:45,590 --> 00:04:50,120
look at the data in a grid offline

00:04:47,620 --> 00:04:51,860
binary long as I mentioned it is used

00:04:50,120 --> 00:04:55,069
for replication but its primary purpose

00:04:51,860 --> 00:04:57,080
is to record changes so when you think

00:04:55,069 --> 00:04:58,520
of the binary log is replication and

00:04:57,080 --> 00:05:00,409
reputation is binary annoyed well that's

00:04:58,520 --> 00:05:02,300
not necessarily true replication

00:05:00,409 --> 00:05:04,360
includes the binary log but you can use

00:05:02,300 --> 00:05:06,800
the binary log without using replication

00:05:04,360 --> 00:05:08,840
because the binary log again just

00:05:06,800 --> 00:05:11,979
records this changes the changes to the

00:05:08,840 --> 00:05:14,750
actual rose so if you think about that

00:05:11,979 --> 00:05:16,610
in the backup sense you want to take a

00:05:14,750 --> 00:05:18,229
backup your data you could do that say

00:05:16,610 --> 00:05:19,940
at midnight between midnight and 5am

00:05:18,229 --> 00:05:21,940
when there's no users on your system

00:05:19,940 --> 00:05:24,080
maybe you how have that policy in place

00:05:21,940 --> 00:05:26,120
but what do you do about the changes

00:05:24,080 --> 00:05:29,240
that happened during the day so what

00:05:26,120 --> 00:05:31,430
happens if someone mentioned earlier

00:05:29,240 --> 00:05:34,310
someone does a delete from without a

00:05:31,430 --> 00:05:35,750
where clause and they have the

00:05:34,310 --> 00:05:39,469
permission to do so in one of your

00:05:35,750 --> 00:05:40,880
tables the data is gone oh by all the

00:05:39,469 --> 00:05:42,889
changes for the entire day are gone

00:05:40,880 --> 00:05:45,320
because you did your backup at midnight

00:05:42,889 --> 00:05:47,120
the dank before if you had binary

00:05:45,320 --> 00:05:51,110
logging turned on you would record all

00:05:47,120 --> 00:05:53,780
those events including the delete so

00:05:51,110 --> 00:05:56,360
then you could restore your data replay

00:05:53,780 --> 00:05:59,030
the binary log up into and before or

00:05:56,360 --> 00:06:01,669
skip that delete and now your data is

00:05:59,030 --> 00:06:05,419
back up to the minute we call it point

00:06:01,669 --> 00:06:07,610
in time recovery so here is just a

00:06:05,419 --> 00:06:09,699
sampling of some of our customers you

00:06:07,610 --> 00:06:13,099
might recognize a few of these logos

00:06:09,699 --> 00:06:16,030
anybody from one of these logos that's

00:06:13,099 --> 00:06:19,520
always an interesting question okay good

00:06:16,030 --> 00:06:23,240
then I can talk about them okay

00:06:19,520 --> 00:06:26,960
terminology we call the originator the

00:06:23,240 --> 00:06:30,020
source of a replication pair replication

00:06:26,960 --> 00:06:32,810
is between two servers it turns out you

00:06:30,020 --> 00:06:35,690
can do many of one kind of server so

00:06:32,810 --> 00:06:36,370
replication is from one server to one or

00:06:35,690 --> 00:06:38,889
more other

00:06:36,370 --> 00:06:41,740
that originated server or a source we

00:06:38,889 --> 00:06:45,479
call the master and that's where your

00:06:41,740 --> 00:06:50,050
changes are recorded in the binary log

00:06:45,479 --> 00:06:52,300
those recipients the destination we call

00:06:50,050 --> 00:06:54,669
the slaves and you can have again one or

00:06:52,300 --> 00:06:58,350
more what they do is retrieve the events

00:06:54,669 --> 00:07:01,990
from the master the other binary log and

00:06:58,350 --> 00:07:03,910
replay them on the slave so they execute

00:07:01,990 --> 00:07:06,850
the events actually happened on the

00:07:03,910 --> 00:07:08,919
master so there's an interesting point

00:07:06,850 --> 00:07:11,710
here you would only do your rights on

00:07:08,919 --> 00:07:14,289
the master you would not do write some

00:07:11,710 --> 00:07:16,320
slaves so you're doing on a slave no

00:07:14,289 --> 00:07:19,389
other slave would know about that right

00:07:16,320 --> 00:07:21,160
she's in the rights to the master those

00:07:19,389 --> 00:07:23,919
were complicated operations typically

00:07:21,160 --> 00:07:26,650
take longer so your masters typically

00:07:23,919 --> 00:07:28,330
more powerful system and then you can

00:07:26,650 --> 00:07:32,199
use less powerful systems for slaves

00:07:28,330 --> 00:07:34,090
which only do reads and you can have

00:07:32,199 --> 00:07:36,130
more than one slave you can divide your

00:07:34,090 --> 00:07:38,680
application over many slaves and

00:07:36,130 --> 00:07:44,169
therefore get much faster throughput or

00:07:38,680 --> 00:07:46,090
reads we call that read scale out so the

00:07:44,169 --> 00:07:47,500
binary log holds their change for

00:07:46,090 --> 00:07:50,530
everything that happens on your master

00:07:47,500 --> 00:07:51,660
it is split if you use a transactional

00:07:50,530 --> 00:07:54,580
storage engine it's split into

00:07:51,660 --> 00:07:57,580
transactions so we'll actually only

00:07:54,580 --> 00:07:59,590
execute on the slave transactions as a

00:07:57,580 --> 00:08:01,389
whole so if something happens on the

00:07:59,590 --> 00:08:03,280
master during it during a long running

00:08:01,389 --> 00:08:05,889
transaction and something bad happens

00:08:03,280 --> 00:08:07,599
there goes go wonky you can be sure that

00:08:05,889 --> 00:08:09,280
that's not going to happen on slaves

00:08:07,599 --> 00:08:13,169
this lady's only going to execute

00:08:09,280 --> 00:08:16,090
transactions that complete on the master

00:08:13,169 --> 00:08:19,360
there are a couple kinds of replication

00:08:16,090 --> 00:08:22,750
the default kind of replication in mysql

00:08:19,360 --> 00:08:24,880
5.5 5.1 and so on is asynchronous

00:08:22,750 --> 00:08:27,580
replication and that's where

00:08:24,880 --> 00:08:29,650
transactions are committed immediately

00:08:27,580 --> 00:08:32,020
so so as the tribe it happens is

00:08:29,650 --> 00:08:35,950
actually written and then shred by the

00:08:32,020 --> 00:08:38,620
slaves and execute it it is faster but

00:08:35,950 --> 00:08:41,260
it is vulnerable to server crashes so if

00:08:38,620 --> 00:08:43,839
something happens you know the event

00:08:41,260 --> 00:08:46,030
gets the transaction gets executed on

00:08:43,839 --> 00:08:48,500
the master that is recorded binary log

00:08:46,030 --> 00:08:50,510
gets sent to the sleigh but some

00:08:48,500 --> 00:08:51,950
happens to it on the way the slave

00:08:50,510 --> 00:08:54,380
doesn't know anything about it anymore

00:08:51,950 --> 00:08:55,490
so it's kind of lost I transacted it

00:08:54,380 --> 00:08:59,840
that's one of the problems with

00:08:55,490 --> 00:09:02,450
asynchronous trent replication so some

00:08:59,840 --> 00:09:04,580
of our customers helped us through their

00:09:02,450 --> 00:09:06,620
own idea and this is an excellent

00:09:04,580 --> 00:09:09,950
example of how community has given back

00:09:06,620 --> 00:09:11,660
to mysql or i should say oracle is semi

00:09:09,950 --> 00:09:13,940
synchronous replication it's

00:09:11,660 --> 00:09:16,330
asynchronous replication with the

00:09:13,940 --> 00:09:19,220
ability to acknowledge to send an ack

00:09:16,330 --> 00:09:21,890
back to the master to say hey this has

00:09:19,220 --> 00:09:23,900
actually been received by a number of

00:09:21,890 --> 00:09:26,240
slaves and therefore it commits the

00:09:23,900 --> 00:09:27,770
transaction once it's a certain that

00:09:26,240 --> 00:09:30,560
threshold is reached so that's called

00:09:27,770 --> 00:09:32,600
semi synchronous there is another form

00:09:30,560 --> 00:09:34,850
that you might imagine synchronous

00:09:32,600 --> 00:09:37,490
replication where the transactions are

00:09:34,850 --> 00:09:40,970
not committed until everybody in the

00:09:37,490 --> 00:09:43,670
topology that was the set of mastering

00:09:40,970 --> 00:09:46,820
slaves is aware of it and have at least

00:09:43,670 --> 00:09:49,460
two replicas now this is provided in a

00:09:46,820 --> 00:09:51,200
product called MySQL cluster so if you

00:09:49,460 --> 00:09:52,730
need synchronous replications where

00:09:51,200 --> 00:09:55,970
you've got to make sure that whatever

00:09:52,730 --> 00:09:58,220
happens gets replicated everywhere and

00:09:55,970 --> 00:10:02,839
at no point is there any possibility of

00:09:58,220 --> 00:10:04,160
having a stale read or a lost read then

00:10:02,839 --> 00:10:08,120
you're going to look at our MySQL

00:10:04,160 --> 00:10:09,410
cluster replication so keep that keep

00:10:08,120 --> 00:10:12,050
that in mind but I'm going to be talking

00:10:09,410 --> 00:10:15,620
about asynchronous replication for this

00:10:12,050 --> 00:10:18,560
talk so what happens here this is a

00:10:15,620 --> 00:10:21,860
drawing of the simplified drawing of the

00:10:18,560 --> 00:10:24,350
architecture these boxes along the top

00:10:21,860 --> 00:10:26,990
row there it says session dump I oh and

00:10:24,350 --> 00:10:29,089
SQL you can think of those as threats

00:10:26,990 --> 00:10:31,760
because they actually are threads inside

00:10:29,089 --> 00:10:34,670
the server and this shows two servers a

00:10:31,760 --> 00:10:37,190
master and a slate so on a master these

00:10:34,670 --> 00:10:39,620
sessions threads are your connections

00:10:37,190 --> 00:10:43,280
say from a application or someone

00:10:39,620 --> 00:10:45,110
running the MySQL client to trivia

00:10:43,280 --> 00:10:47,450
question what was the MySQL client tool

00:10:45,110 --> 00:10:52,760
called before we started coming at the

00:10:47,450 --> 00:10:54,420
last call it client to it's called the

00:10:52,760 --> 00:10:57,810
MySQL monitor

00:10:54,420 --> 00:11:00,930
there's a ten-dollar answer huh so once

00:10:57,810 --> 00:11:03,959
you use the bicycle client or an

00:11:00,930 --> 00:11:07,889
application to write data to the master

00:11:03,959 --> 00:11:09,420
it is recorded in its binary log then

00:11:07,889 --> 00:11:11,220
there's another thread called the dump

00:11:09,420 --> 00:11:13,560
thread and there's one dump thread for

00:11:11,220 --> 00:11:15,600
each slave that's connected so when it's

00:11:13,560 --> 00:11:18,180
late clicks so a master a dump thread it

00:11:15,600 --> 00:11:21,449
started for it and its label requests

00:11:18,180 --> 00:11:25,320
entries from the master spy nary law and

00:11:21,449 --> 00:11:27,209
it does that in mysql 5.5 and before by

00:11:25,320 --> 00:11:31,110
specifying the name of the binary log

00:11:27,209 --> 00:11:32,820
and the position okay so when you

00:11:31,110 --> 00:11:35,970
connect a slave to a master you were

00:11:32,820 --> 00:11:37,459
provided the dog name and position of

00:11:35,970 --> 00:11:39,779
the master where you want it to start

00:11:37,459 --> 00:11:44,010
and you would get that on the master by

00:11:39,779 --> 00:11:46,079
executing show master status on the

00:11:44,010 --> 00:11:48,269
slave the hest every slave has two

00:11:46,079 --> 00:11:50,070
threats and io thread which is

00:11:48,269 --> 00:11:52,440
responsible for requesting the events

00:11:50,070 --> 00:11:54,750
from the master via the Masters dump

00:11:52,440 --> 00:11:57,180
thread and an SQL thread which is

00:11:54,750 --> 00:12:02,490
responsible for executing it and the way

00:11:57,180 --> 00:12:05,640
it works is this the master i write

00:12:02,490 --> 00:12:09,390
occurs on the master the session thread

00:12:05,640 --> 00:12:12,740
writes it to the binary log the dump

00:12:09,390 --> 00:12:15,360
thread then reads it from the binary log

00:12:12,740 --> 00:12:17,820
sends it across the wire to slay which

00:12:15,360 --> 00:12:20,130
is received by the io thread which then

00:12:17,820 --> 00:12:22,709
writes it into yet another log called

00:12:20,130 --> 00:12:24,510
the relay log which is the same form as

00:12:22,709 --> 00:12:28,370
a buyer log because it's the same data

00:12:24,510 --> 00:12:31,589
and then the SQL thread on the slave

00:12:28,370 --> 00:12:34,890
execute that event so there is a loop

00:12:31,589 --> 00:12:37,589
here where you can see how things go

00:12:34,890 --> 00:12:40,260
through so if something goes wrong and

00:12:37,589 --> 00:12:42,449
any one of these steps once you have

00:12:40,260 --> 00:12:44,910
knowledge of where how the process works

00:12:42,449 --> 00:12:47,430
and you know where the problem could be

00:12:44,910 --> 00:12:50,010
for example if you issue show slave

00:12:47,430 --> 00:12:53,100
status and you see the io thread is down

00:12:50,010 --> 00:12:57,510
or has an error you would automatically

00:12:53,100 --> 00:13:00,899
know that you can't get any more events

00:12:57,510 --> 00:13:02,610
from the master similarly if the SQL

00:13:00,899 --> 00:13:04,440
thread is down but the io thread is up

00:13:02,610 --> 00:13:04,680
you know you're accumulating events in

00:13:04,440 --> 00:13:07,980
the

00:13:04,680 --> 00:13:10,260
they log that's independent of the SQL

00:13:07,980 --> 00:13:12,750
thread but you'd also know that they

00:13:10,260 --> 00:13:15,330
aren't executing and also in show sleep

00:13:12,750 --> 00:13:19,050
state is is the position of the relay

00:13:15,330 --> 00:13:21,149
log where the SQL thread last red so all

00:13:19,050 --> 00:13:22,770
that diagnostic information as a lot of

00:13:21,149 --> 00:13:25,110
people think it's a mystery and it is

00:13:22,770 --> 00:13:26,399
some sort of art it's not it's all the

00:13:25,110 --> 00:13:28,800
all that information is there for you

00:13:26,399 --> 00:13:30,209
you just have to understand the path I

00:13:28,800 --> 00:13:32,520
know that's a lot to come at you at one

00:13:30,209 --> 00:13:34,290
time but I want to plant that seed so

00:13:32,520 --> 00:13:36,420
when you work with replication and you

00:13:34,290 --> 00:13:39,750
look at oh so your sleeves days and you

00:13:36,420 --> 00:13:41,399
see really real a long position what

00:13:39,750 --> 00:13:43,890
does that mean well that simply means

00:13:41,399 --> 00:13:45,930
that's the last position at the SQL

00:13:43,890 --> 00:13:50,430
thread read from that particular relay

00:13:45,930 --> 00:13:54,000
law so let's look at this a little bit

00:13:50,430 --> 00:13:56,880
more io thread and SQL thread only two

00:13:54,000 --> 00:13:59,850
threads on the slate what do you think

00:13:56,880 --> 00:14:02,100
happens when you have a lot of Rights

00:13:59,850 --> 00:14:06,209
coming to the master like 10,000 and

00:14:02,100 --> 00:14:07,620
within in a few seconds well that could

00:14:06,209 --> 00:14:10,110
be from ten down the connections on the

00:14:07,620 --> 00:14:12,480
master if theoretically that could

00:14:10,110 --> 00:14:15,750
happen instantaneously it's going to

00:14:12,480 --> 00:14:17,160
happen one at a time on the slave and we

00:14:15,750 --> 00:14:19,020
have an answer to this it's called a

00:14:17,160 --> 00:14:21,570
multi-threaded slave and that's part of

00:14:19,020 --> 00:14:24,209
our MySQL 5.6 and hands with the package

00:14:21,570 --> 00:14:25,380
and you can get that off with a DMR if

00:14:24,209 --> 00:14:27,570
you go out there look at that's actually

00:14:25,380 --> 00:14:29,970
part of the DMR multi-threaded slate and

00:14:27,570 --> 00:14:34,440
what that does in short is divided up

00:14:29,970 --> 00:14:39,029
the events by database so it parallels

00:14:34,440 --> 00:14:41,100
the the i/o and SQL execution based on

00:14:39,029 --> 00:14:46,230
database that's pretty neat there is a

00:14:41,100 --> 00:14:48,750
good improvement that way okay binary

00:14:46,230 --> 00:14:50,730
logs binary logs are named a little

00:14:48,750 --> 00:14:53,190
strange they are named whatever name

00:14:50,730 --> 00:14:54,870
that you tell it there's a way to tell

00:14:53,190 --> 00:14:58,110
the divine Harry normal name but by

00:14:54,870 --> 00:15:00,709
default is called MySQL dash bin and the

00:14:58,110 --> 00:15:07,620
file extension for your windows folks is

00:15:00,709 --> 00:15:10,260
a numeric it's six positions and starts

00:15:07,620 --> 00:15:14,279
at zero or whatever position you tell it

00:15:10,260 --> 00:15:17,010
to start and it increments as it creates

00:15:14,279 --> 00:15:18,329
a new binary log now there are several

00:15:17,010 --> 00:15:20,660
events that can

00:15:18,329 --> 00:15:24,540
cause the master to create a new log

00:15:20,660 --> 00:15:27,929
flushed binary logs is one flesh tables

00:15:24,540 --> 00:15:29,790
with with read like all those event

00:15:27,929 --> 00:15:31,319
kinds of things will cause the master to

00:15:29,790 --> 00:15:35,239
create a new law and why would you want

00:15:31,319 --> 00:15:37,499
to do that well if you periodically

00:15:35,239 --> 00:15:39,689
rotate that it's called rotating logs

00:15:37,499 --> 00:15:41,459
then you can take those logs off the

00:15:39,689 --> 00:15:44,970
master somewhere and store them safe

00:15:41,459 --> 00:15:47,160
place like with your backups and that

00:15:44,970 --> 00:15:49,920
way if you need to go back something

00:15:47,160 --> 00:15:52,379
terrible happen three weeks ago for a

00:15:49,920 --> 00:15:55,199
particular table you can go back and

00:15:52,379 --> 00:15:57,179
rebuild a rerun that scenario and

00:15:55,199 --> 00:16:00,059
recover that event and find out what

00:15:57,179 --> 00:16:02,970
happened if you store them the old

00:16:00,059 --> 00:16:05,160
binary logs along with your backups so

00:16:02,970 --> 00:16:08,569
this takeaway here for backup and

00:16:05,160 --> 00:16:12,689
recovery is use the binary log as your

00:16:08,569 --> 00:16:15,540
daily perhaps incremental backup that's

00:16:12,689 --> 00:16:17,279
essentially what you're getting now in

00:16:15,540 --> 00:16:19,790
the case of the binary log there's also

00:16:17,279 --> 00:16:23,879
a second file called the index the index

00:16:19,790 --> 00:16:26,069
contains the name of the the most recent

00:16:23,879 --> 00:16:28,589
binary log so you have a lot of log

00:16:26,069 --> 00:16:30,119
files over time you don't necessarily

00:16:28,589 --> 00:16:32,339
know which one is particularly if you

00:16:30,119 --> 00:16:35,220
have a habit and some people do of

00:16:32,339 --> 00:16:36,480
renaming the logs so there you stop the

00:16:35,220 --> 00:16:38,309
server and we started again with a new

00:16:36,480 --> 00:16:40,529
name they might want to do that for

00:16:38,309 --> 00:16:42,540
various reasons in which case you may

00:16:40,529 --> 00:16:45,809
not know which one is the latest one but

00:16:42,540 --> 00:16:49,319
you can look at the mysql bin index file

00:16:45,809 --> 00:16:52,679
and find out the buyer log contains

00:16:49,319 --> 00:16:56,040
those log events it is not readable by

00:16:52,679 --> 00:16:58,410
humans but fortunately we have a client

00:16:56,040 --> 00:17:00,660
tool called MySQL binlog which will

00:16:58,410 --> 00:17:02,699
allow you to dump the contents as it

00:17:00,660 --> 00:17:05,159
been long search the binlog for

00:17:02,699 --> 00:17:06,959
different things and depending on what

00:17:05,159 --> 00:17:08,819
you're looking for and what kind of

00:17:06,959 --> 00:17:10,679
replication you use and I'll get into

00:17:08,819 --> 00:17:13,620
that in a moment some of it may actually

00:17:10,679 --> 00:17:15,149
be readable so you it is possible in

00:17:13,620 --> 00:17:18,059
what's called statement based

00:17:15,149 --> 00:17:20,100
replication to actually see the SQL that

00:17:18,059 --> 00:17:23,659
executed but if you use row based

00:17:20,100 --> 00:17:27,299
replication you would only see you know

00:17:23,659 --> 00:17:30,179
binary data something interesting about

00:17:27,299 --> 00:17:31,830
the binary log if you do an extract of

00:17:30,179 --> 00:17:34,409
the ice cube in LA or

00:17:31,830 --> 00:17:37,019
an entire binary log and you open MySQL

00:17:34,409 --> 00:17:39,029
client you can actually copy the events

00:17:37,019 --> 00:17:42,149
from the binary log and play them to the

00:17:39,029 --> 00:17:45,510
MySQL client so this one way of

00:17:42,149 --> 00:17:47,850
replaying your bind their logs to

00:17:45,510 --> 00:17:49,830
coordinate positions of logs i mentioned

00:17:47,850 --> 00:17:51,720
log binary log name and position

00:17:49,830 --> 00:17:53,640
position is simply the offset from the

00:17:51,720 --> 00:17:56,059
start of the file of where that event is

00:17:53,640 --> 00:17:59,100
and since events have different sizes

00:17:56,059 --> 00:18:00,659
that number could be different from time

00:17:59,100 --> 00:18:03,210
to time it's not necessarily always

00:18:00,659 --> 00:18:05,370
going to be say 106 for example for

00:18:03,210 --> 00:18:09,419
starting it could be different depending

00:18:05,370 --> 00:18:11,909
on the event that happened okay switch

00:18:09,419 --> 00:18:15,510
to a little bit more about basic

00:18:11,909 --> 00:18:18,690
replication a basic replication when you

00:18:15,510 --> 00:18:20,190
have again one master one slave you

00:18:18,690 --> 00:18:24,029
might want to use it in this scenario

00:18:20,190 --> 00:18:26,130
for offloading processing on the master

00:18:24,029 --> 00:18:27,990
simply want to split your reads and

00:18:26,130 --> 00:18:31,139
writes the rights go to the master

00:18:27,990 --> 00:18:33,990
riesgo to the slave you may want to

00:18:31,139 --> 00:18:36,510
create a master and a single slave in

00:18:33,990 --> 00:18:39,389
order to do backups so if you have the

00:18:36,510 --> 00:18:41,700
need to never lock any tables ever for

00:18:39,389 --> 00:18:44,190
more than a few milliseconds so you have

00:18:41,700 --> 00:18:45,720
something that's truly online how in the

00:18:44,190 --> 00:18:49,909
world you ever take that down to do a

00:18:45,720 --> 00:18:52,470
backup here's how use replication

00:18:49,909 --> 00:18:57,059
replicate to a slave at the appropriate

00:18:52,470 --> 00:19:01,980
time you issue a lock tables on the

00:18:57,059 --> 00:19:05,639
slave to your backup record it's relay

00:19:01,980 --> 00:19:09,809
logs start to slave now you're done a

00:19:05,639 --> 00:19:12,149
back up online you've never stopped the

00:19:09,809 --> 00:19:13,350
master or interrupted your apps ever so

00:19:12,149 --> 00:19:17,570
that's one reason you might want to use

00:19:13,350 --> 00:19:20,899
replication we have a tool called MySQL

00:19:17,570 --> 00:19:24,440
enterprise backup it's part of our paid

00:19:20,899 --> 00:19:27,059
application suite so if you buy our

00:19:24,440 --> 00:19:29,850
services you get that as part of the

00:19:27,059 --> 00:19:33,260
package mysql backup also has a

00:19:29,850 --> 00:19:36,409
non-blocking backup that you could use

00:19:33,260 --> 00:19:36,409
yes sir

00:19:37,599 --> 00:19:45,229
well sure you would why would you want

00:19:40,279 --> 00:19:47,269
to oh you mean a consistent read you

00:19:45,229 --> 00:19:48,979
would lock it with a consistent read so

00:19:47,269 --> 00:19:51,739
your issue start a consistent read yes

00:19:48,979 --> 00:19:53,869
so if you're purely nodb tables and

00:19:51,739 --> 00:19:56,509
you're only ever using GWT nor does the

00:19:53,869 --> 00:19:58,609
images only know to be and yes you can

00:19:56,509 --> 00:20:00,769
but if you have any other table in the

00:19:58,609 --> 00:20:04,849
mix any other storage engine and yeah

00:20:00,769 --> 00:20:07,309
you've got to do some mock yeah ok so my

00:20:04,849 --> 00:20:10,309
Eskimo enterprise backup is a very

00:20:07,309 --> 00:20:11,929
interesting tool it works with nodb for

00:20:10,309 --> 00:20:15,079
online backup it also works with my I

00:20:11,929 --> 00:20:20,029
Sam but it's not truly online not truly

00:20:15,079 --> 00:20:23,659
hot backup for my exam so how would you

00:20:20,029 --> 00:20:25,009
add a slave so you've got one master and

00:20:23,659 --> 00:20:28,789
one slave but you want to add another

00:20:25,009 --> 00:20:32,539
one well you're going to find out where

00:20:28,789 --> 00:20:35,509
the master is currently right so you

00:20:32,539 --> 00:20:37,820
would bootstrap the slave you would have

00:20:35,509 --> 00:20:41,959
to restore your latest backup from your

00:20:37,820 --> 00:20:45,320
master and that latest backup would have

00:20:41,959 --> 00:20:47,450
what included when you do a backup you

00:20:45,320 --> 00:20:50,119
also record the current masters of

00:20:47,450 --> 00:20:51,589
binary log and position so when you

00:20:50,119 --> 00:20:53,450
provision a slave this what's called

00:20:51,589 --> 00:20:55,669
provisioning and slay you restore that

00:20:53,450 --> 00:20:58,099
backup you know the Masters binary log

00:20:55,669 --> 00:21:00,679
file in its position you issue the

00:20:58,099 --> 00:21:03,440
command change master to and part of the

00:21:00,679 --> 00:21:06,109
criteria is the Masters binary log in

00:21:03,440 --> 00:21:08,359
this position you start to slave slave

00:21:06,109 --> 00:21:10,369
will request from the master that binary

00:21:08,359 --> 00:21:14,179
log in position and start reading events

00:21:10,369 --> 00:21:18,379
from then on so the master does not have

00:21:14,179 --> 00:21:20,629
to be stopped to use it master can

00:21:18,379 --> 00:21:22,669
continue to continue receiving rights

00:21:20,629 --> 00:21:24,619
there's a tool to make this a little

00:21:22,669 --> 00:21:26,869
easier that's part of the MySQL

00:21:24,619 --> 00:21:29,450
utilities it's called MySQL replicate

00:21:26,869 --> 00:21:31,700
and you can see a tiny example that I

00:21:29,450 --> 00:21:33,409
apologize for font size right there

00:21:31,700 --> 00:21:36,169
where you see my ass will replicate we

00:21:33,409 --> 00:21:38,209
tell it the repple user and its password

00:21:36,169 --> 00:21:40,009
that the co in there separates the

00:21:38,209 --> 00:21:42,169
username and password we tell it the

00:21:40,009 --> 00:21:43,969
master we tell it to slave and it goes

00:21:42,169 --> 00:21:45,649
off and does everything for you and

00:21:43,969 --> 00:21:46,700
there are different ways that you can

00:21:45,649 --> 00:21:48,440
tell it to

00:21:46,700 --> 00:21:51,710
to the master you can tell it to connect

00:21:48,440 --> 00:21:54,170
at a particular minor login position so

00:21:51,710 --> 00:21:56,930
tell a specific position you can tell

00:21:54,170 --> 00:21:58,850
the start replication with a very start

00:21:56,930 --> 00:22:01,280
in other words it requests all the

00:21:58,850 --> 00:22:04,370
events from the master so that could be

00:22:01,280 --> 00:22:05,960
you know time good to me well you can

00:22:04,370 --> 00:22:08,810
tell it to start from the current

00:22:05,960 --> 00:22:11,060
position so if you have a the luxury of

00:22:08,810 --> 00:22:13,550
being able to stop your master you could

00:22:11,060 --> 00:22:15,290
stop the master provision your slave and

00:22:13,550 --> 00:22:16,430
just tell my school replicate to start

00:22:15,290 --> 00:22:20,870
from the current and then you start

00:22:16,430 --> 00:22:23,510
anything back up again here's another

00:22:20,870 --> 00:22:26,510
one standby master so let's say you have

00:22:23,510 --> 00:22:28,220
a master slave or maybe one or more

00:22:26,510 --> 00:22:31,220
slaves but you want to make sure that

00:22:28,220 --> 00:22:34,910
you have a backup alive backup in case

00:22:31,220 --> 00:22:38,420
the master goes down well that standby

00:22:34,910 --> 00:22:41,330
is actually a special form of slave it

00:22:38,420 --> 00:22:43,490
is a slave but it's a slave that doesn't

00:22:41,330 --> 00:22:45,590
have any activity on it it is connected

00:22:43,490 --> 00:22:47,480
to the master as a slave it's getting

00:22:45,590 --> 00:22:51,530
all the events it's replaying them

00:22:47,480 --> 00:22:54,230
everything is cool but it allows you to

00:22:51,530 --> 00:22:56,390
isolate a particular slave for the

00:22:54,230 --> 00:22:59,540
purpose of switching the role from the

00:22:56,390 --> 00:23:02,180
old master to the standby and the way

00:22:59,540 --> 00:23:05,410
you would do this is very important that

00:23:02,180 --> 00:23:09,080
fourth board their log slave updates

00:23:05,410 --> 00:23:12,020
when an event is read from the master

00:23:09,080 --> 00:23:15,620
via the i/o threat and recorded in a

00:23:12,020 --> 00:23:20,120
real a log it is not recorded on in that

00:23:15,620 --> 00:23:22,430
slaves binary log if you want to use a

00:23:20,120 --> 00:23:25,630
standby master the difference between a

00:23:22,430 --> 00:23:28,580
a normal slave and a standby master is

00:23:25,630 --> 00:23:30,460
log slave updates what that means is

00:23:28,580 --> 00:23:34,250
when it reads an event from the master

00:23:30,460 --> 00:23:36,710
and writes it to its real a log the SQL

00:23:34,250 --> 00:23:39,680
thread reads it executes it and then

00:23:36,710 --> 00:23:42,770
writes it to its binary log why do you

00:23:39,680 --> 00:23:45,110
need that you need that because if that

00:23:42,770 --> 00:23:47,990
bastard role needs to change the standby

00:23:45,110 --> 00:23:51,320
you need to connect the slave to the new

00:23:47,990 --> 00:23:53,390
master slave needs the read events from

00:23:51,320 --> 00:23:55,970
the new masters binary log if you don't

00:23:53,390 --> 00:23:57,430
use log slave updates you can't use that

00:23:55,970 --> 00:24:00,120
slave

00:23:57,430 --> 00:24:00,120
a new master

00:24:02,319 --> 00:24:08,539
yeah typically don't slave or designed

00:24:05,239 --> 00:24:10,879
to be read only slate so there's no

00:24:08,539 --> 00:24:12,799
reason to have a binary law but in

00:24:10,879 --> 00:24:14,899
special situations like this and other

00:24:12,799 --> 00:24:16,939
more complex topologies you would

00:24:14,899 --> 00:24:19,219
definitely turn on fact most people who

00:24:16,939 --> 00:24:22,309
have advanced replicated apologies will

00:24:19,219 --> 00:24:25,039
turn on by default and indeed in mysql

00:24:22,309 --> 00:24:28,879
5.6 what we use global transaction

00:24:25,039 --> 00:24:30,889
identifier it's required and you if i

00:24:28,879 --> 00:24:34,309
don't explain why it be again when i

00:24:30,889 --> 00:24:37,129
come back to that slide so for

00:24:34,309 --> 00:24:38,509
synchronizing your switch over there are

00:24:37,129 --> 00:24:40,129
several commands you want to be able to

00:24:38,509 --> 00:24:42,819
show master status to find out whether

00:24:40,129 --> 00:24:47,869
current master is start slave until

00:24:42,819 --> 00:24:51,679
sells this slave to start and execute

00:24:47,869 --> 00:24:55,339
events until a certain point master

00:24:51,679 --> 00:24:58,549
position weight tells it to execute to

00:24:55,339 --> 00:24:59,989
that certain position in wait so you

00:24:58,549 --> 00:25:03,759
find out more about these commands in

00:24:59,989 --> 00:25:06,949
the online reference manual so

00:25:03,759 --> 00:25:09,199
replication for scale out in this case

00:25:06,949 --> 00:25:11,929
I've been talking about rights to the

00:25:09,199 --> 00:25:15,079
master recently many slaves great

00:25:11,929 --> 00:25:17,899
throughput well here's an example you

00:25:15,079 --> 00:25:20,419
would have a client rights only to the

00:25:17,899 --> 00:25:23,859
master and it could read from one or

00:25:20,419 --> 00:25:26,179
more slaves so you could potentially

00:25:23,859 --> 00:25:29,719
distribute your read query processing

00:25:26,179 --> 00:25:32,419
over many different slaves you're right

00:25:29,719 --> 00:25:34,519
still go to master but your clients need

00:25:32,419 --> 00:25:36,859
to send simply the reek where is the

00:25:34,519 --> 00:25:39,669
slave and rights to the master but how

00:25:36,859 --> 00:25:42,439
do you know which Slade to read from hmm

00:25:39,669 --> 00:25:44,839
well you could do some sort of load

00:25:42,439 --> 00:25:47,779
balancing let's say you have a client

00:25:44,839 --> 00:25:50,029
that is writing to the master but you

00:25:47,779 --> 00:25:53,949
don't know necessarily witchslayer to

00:25:50,029 --> 00:25:56,239
read from but maybe you've created a

00:25:53,949 --> 00:25:58,279
application that's going to do load

00:25:56,239 --> 00:26:01,099
balancing maybe it's executing a round

00:25:58,279 --> 00:26:03,349
robin algorithm something like that

00:26:01,099 --> 00:26:05,779
we're simply rotating is group which

00:26:03,349 --> 00:26:08,089
reads or you've done some sort of more

00:26:05,779 --> 00:26:09,349
sophisticated type of thing but the

00:26:08,089 --> 00:26:11,479
point is that you can do load balancing

00:26:09,349 --> 00:26:13,610
across your slaves you could perhaps

00:26:11,479 --> 00:26:15,620
even write an application and

00:26:13,610 --> 00:26:18,130
monitors to performance as a slave's and

00:26:15,620 --> 00:26:21,799
reads from the stay that is least busy

00:26:18,130 --> 00:26:25,250
that would be handy so how does it a

00:26:21,799 --> 00:26:27,650
client nowhere well you could use

00:26:25,250 --> 00:26:31,730
intermediate proxy an actual load

00:26:27,650 --> 00:26:33,530
balancer advantage is its transparent to

00:26:31,730 --> 00:26:37,790
the client plan only collects to one

00:26:33,530 --> 00:26:40,070
particular server so that load balancer

00:26:37,790 --> 00:26:42,370
takes care of the sending the rights to

00:26:40,070 --> 00:26:44,929
master and reading from various late

00:26:42,370 --> 00:26:48,860
disadvantage is the query analysis will

00:26:44,929 --> 00:26:51,380
add processing time add delay as well as

00:26:48,860 --> 00:26:53,270
the fact is necessarily because it can't

00:26:51,380 --> 00:26:56,290
be exhaustive or else it would delay

00:26:53,270 --> 00:26:59,270
everything it's sometimes in perfect and

00:26:56,290 --> 00:27:02,030
the application can't provide any hints

00:26:59,270 --> 00:27:04,640
to it in order to tell it how to do you

00:27:02,030 --> 00:27:06,169
know where to go from there on the other

00:27:04,640 --> 00:27:08,179
hand if you write your own load

00:27:06,169 --> 00:27:10,040
balancing since you writing your

00:27:08,179 --> 00:27:12,200
application you know it intimately well

00:27:10,040 --> 00:27:14,600
you also know the access patterns of

00:27:12,200 --> 00:27:16,250
your of your users in other words what

00:27:14,600 --> 00:27:19,250
databases and tables they access the

00:27:16,250 --> 00:27:21,290
most for example you can write it to

00:27:19,250 --> 00:27:22,850
provide those kind of hints directly to

00:27:21,290 --> 00:27:25,040
the application was the application can

00:27:22,850 --> 00:27:28,880
know if I want to read a particular

00:27:25,040 --> 00:27:31,580
article of a particular table and have

00:27:28,880 --> 00:27:33,470
to do some sort of range query then

00:27:31,580 --> 00:27:34,790
another user does a similar range query

00:27:33,470 --> 00:27:37,490
you might not want to run those queries

00:27:34,790 --> 00:27:40,190
on the same slave now they might delay

00:27:37,490 --> 00:27:42,260
each other because of potentially query

00:27:40,190 --> 00:27:46,010
processing heavy you could send them out

00:27:42,260 --> 00:27:47,470
I'll aware but today astonish courses is

00:27:46,010 --> 00:27:49,760
you going to write all that stuff but

00:27:47,470 --> 00:27:51,140
the good news is you can and the

00:27:49,760 --> 00:27:55,640
replication topology is nothing there is

00:27:51,140 --> 00:27:57,200
stopping you from doing that so when you

00:27:55,640 --> 00:27:59,360
talk about distributing queries there's

00:27:57,200 --> 00:28:03,470
some caveats horse read/write split

00:27:59,360 --> 00:28:05,570
drill that into a boy's head the session

00:28:03,470 --> 00:28:08,059
stickiness this is interesting if you

00:28:05,570 --> 00:28:11,450
decide to do your own load balancing for

00:28:08,059 --> 00:28:16,000
reads you should stick your reads to a

00:28:11,450 --> 00:28:20,419
particular slave why is that important

00:28:16,000 --> 00:28:22,580
two words query cache if you rotated

00:28:20,419 --> 00:28:24,760
your query the same query over every

00:28:22,580 --> 00:28:27,430
slave every slave has to recast

00:28:24,760 --> 00:28:29,680
that query if you do that enough times

00:28:27,430 --> 00:28:31,690
the cash becomes emptied and then you

00:28:29,680 --> 00:28:33,970
got to do it all over again so if you

00:28:31,690 --> 00:28:36,490
have a repeating query aha there's a

00:28:33,970 --> 00:28:38,530
hint you can send it all to one slave

00:28:36,490 --> 00:28:41,470
and it would be potentially faster than

00:28:38,530 --> 00:28:42,640
sending it 10 equals thing again the

00:28:41,470 --> 00:28:46,450
smile gorillas you might want to

00:28:42,640 --> 00:28:49,600
consider around robbing random even hash

00:28:46,450 --> 00:28:51,310
perhaps by IP address of course least

00:28:49,600 --> 00:28:53,980
number of connections as I mentioned the

00:28:51,310 --> 00:28:55,060
least busy slave fastest response time

00:28:53,980 --> 00:28:58,770
that kind of thing all this is

00:28:55,060 --> 00:28:58,770
application level stuff that you can do

00:28:59,280 --> 00:29:05,560
let's talk about another one a real a

00:29:01,840 --> 00:29:08,680
slave a real a slave is a slave in the

00:29:05,560 --> 00:29:11,710
middle that is both a master and a slave

00:29:08,680 --> 00:29:13,900
why would hold relays like it is a slave

00:29:11,710 --> 00:29:17,680
to the original master but it's also a

00:29:13,900 --> 00:29:19,750
master to all the slaves what it does is

00:29:17,680 --> 00:29:22,660
allow you to reduce the load on the

00:29:19,750 --> 00:29:27,760
master so that it can concentrate on the

00:29:22,660 --> 00:29:29,530
rights and then you store the binary log

00:29:27,760 --> 00:29:31,300
on the relay so it's the similar thing

00:29:29,530 --> 00:29:35,370
by the standby you want to log slave

00:29:31,300 --> 00:29:37,600
updates on your relay law you can do it

00:29:35,370 --> 00:29:41,740
for another reason and this is most

00:29:37,600 --> 00:29:44,890
popular you might want to only replicate

00:29:41,740 --> 00:29:47,200
certain databases so rather than filter

00:29:44,890 --> 00:29:49,150
at the master which you could do but

00:29:47,200 --> 00:29:51,040
it's not recommended so you filter out

00:29:49,150 --> 00:29:53,830
the master then the only copy is ever on

00:29:51,040 --> 00:29:57,760
the master but if you filter on this

00:29:53,830 --> 00:30:00,460
side of the real a slave now you have a

00:29:57,760 --> 00:30:03,610
copy of all your databases on the real a

00:30:00,460 --> 00:30:06,160
slave so it could still be be there for

00:30:03,610 --> 00:30:08,380
redundancy and backup purposes but you

00:30:06,160 --> 00:30:10,900
only replicate certain things so you

00:30:08,380 --> 00:30:13,180
filter at the relay slaves very nice and

00:30:10,900 --> 00:30:15,430
we have some tools again the matter my

00:30:13,180 --> 00:30:17,530
new enterprise monitor and my school

00:30:15,430 --> 00:30:18,550
proxy allow you to do that thing so if

00:30:17,530 --> 00:30:20,250
you're interested that kind of thing

00:30:18,550 --> 00:30:24,430
take a look at some of those products

00:30:20,250 --> 00:30:26,380
the way it does this is interesting

00:30:24,430 --> 00:30:28,480
there is a storage in called the black

00:30:26,380 --> 00:30:29,620
hole storage engine it's called the

00:30:28,480 --> 00:30:31,930
black hole storage in it because

00:30:29,620 --> 00:30:36,640
anything is written to it gets deleted

00:30:31,930 --> 00:30:38,380
it stores absolutely no data that's

00:30:36,640 --> 00:30:41,020
useful because on in this

00:30:38,380 --> 00:30:43,510
when you use the real a slave again it

00:30:41,020 --> 00:30:45,760
requires the event from the master via

00:30:43,510 --> 00:30:48,640
the Masters dump thread it writes it to

00:30:45,760 --> 00:30:51,220
its real a thread a really real a log

00:30:48,640 --> 00:30:54,040
the sequel said reads it from the real a

00:30:51,220 --> 00:30:55,270
log and execute it and executed from the

00:30:54,040 --> 00:30:57,610
black hole engine which means it doesn't

00:30:55,270 --> 00:31:00,850
store anything at all did you lose

00:30:57,610 --> 00:31:02,320
anything in the real a log that means

00:31:00,850 --> 00:31:05,890
that that relay Slade doesn't have to

00:31:02,320 --> 00:31:08,020
have much disk space all we have to have

00:31:05,890 --> 00:31:10,180
a disk space for the size of the relay

00:31:08,020 --> 00:31:13,960
log that you want to store very

00:31:10,180 --> 00:31:17,020
interesting you might want to have

00:31:13,960 --> 00:31:19,270
special slaves you might have several

00:31:17,020 --> 00:31:22,420
applications running you might want to

00:31:19,270 --> 00:31:23,800
do a message board on one may be some

00:31:22,420 --> 00:31:26,050
sort of application that monitors

00:31:23,800 --> 00:31:28,150
friends on another in which case you

00:31:26,050 --> 00:31:30,460
could tell the friends application don't

00:31:28,150 --> 00:31:32,560
look at certain slaves a message board

00:31:30,460 --> 00:31:34,120
look at others if you're getting ahead

00:31:32,560 --> 00:31:37,300
of me that also means you could use

00:31:34,120 --> 00:31:40,000
filtering to filter the database is

00:31:37,300 --> 00:31:43,630
associated with one app to sunset some

00:31:40,000 --> 00:31:45,970
subset of slaves and replicate filter

00:31:43,630 --> 00:31:48,160
the others to the other so it's

00:31:45,970 --> 00:31:49,780
scale-out dependent on the role you can

00:31:48,160 --> 00:31:54,010
only store those tables that are needed

00:31:49,780 --> 00:31:56,980
through filtering and you do it reduces

00:31:54,010 --> 00:31:58,960
the right load I don't necessarily agree

00:31:56,980 --> 00:32:02,290
with that but it can reduce the right

00:31:58,960 --> 00:32:04,330
load in certain situations but it does

00:32:02,290 --> 00:32:05,860
feel throughout China's filter out

00:32:04,330 --> 00:32:07,780
things but the question is where do you

00:32:05,860 --> 00:32:09,790
filter on the master side or on the

00:32:07,780 --> 00:32:12,250
slave shot again if you filter on the

00:32:09,790 --> 00:32:14,170
slave it's possible the event could live

00:32:12,250 --> 00:32:16,810
in the real a log but not actually

00:32:14,170 --> 00:32:22,240
execute I'll show you some of those a

00:32:16,810 --> 00:32:24,630
moment master side filtering again on

00:32:22,240 --> 00:32:29,110
the binary log there two parameters

00:32:24,630 --> 00:32:31,960
binlog do DB binlog ignore DB if you

00:32:29,110 --> 00:32:34,900
live in LA dudee be empty which is the

00:32:31,960 --> 00:32:36,670
default then it binary log for blogs in

00:32:34,900 --> 00:32:39,940
the binary log all changes to all

00:32:36,670 --> 00:32:44,710
databases if you put any database name

00:32:39,940 --> 00:32:49,510
in there it will only log changes for

00:32:44,710 --> 00:32:51,690
that list of databases similarly if you

00:32:49,510 --> 00:32:55,409
say binlog ignore DB

00:32:51,690 --> 00:32:57,419
it's playing it will not ignore any DV

00:32:55,409 --> 00:33:00,080
if you put any list in there it will

00:32:57,419 --> 00:33:02,490
ignore all those DB all those databases

00:33:00,080 --> 00:33:05,220
the reason why is not recommended

00:33:02,490 --> 00:33:06,600
because if you filter those it's not

00:33:05,220 --> 00:33:10,500
being written to the binary at all at

00:33:06,600 --> 00:33:12,960
all ever gone in the case of ignored e

00:33:10,500 --> 00:33:14,850
beef and doo doo dee be the opposite is

00:33:12,960 --> 00:33:16,470
true it's long everything for that list

00:33:14,850 --> 00:33:19,679
of databases and nothing for anything

00:33:16,470 --> 00:33:22,710
it's not in the list what you should do

00:33:19,679 --> 00:33:24,149
instead and you slave side filter yes

00:33:22,710 --> 00:33:25,889
that means the events are still being

00:33:24,149 --> 00:33:27,600
transferred over the wire still being

00:33:25,889 --> 00:33:30,539
read by the io thread still be written

00:33:27,600 --> 00:33:33,000
to the relay low but we have these

00:33:30,539 --> 00:33:36,570
parameters replicate do d be same as

00:33:33,000 --> 00:33:38,129
been low DB it's not either going to

00:33:36,570 --> 00:33:40,529
write those to the real a dog or it's

00:33:38,129 --> 00:33:41,759
not ignore DB same thing it sees we're

00:33:40,529 --> 00:33:43,740
going to ignore those written to the

00:33:41,759 --> 00:33:45,840
three late log or if it's blank is it's

00:33:43,740 --> 00:33:47,909
not going to ignore anything you could

00:33:45,840 --> 00:33:51,299
do it at table level two that's another

00:33:47,909 --> 00:33:53,220
interesting granularity here so the

00:33:51,299 --> 00:33:58,409
point is if you want to do filtering do

00:33:53,220 --> 00:34:00,629
it on your slaves not on the master okay

00:33:58,409 --> 00:34:04,500
any questions so far I'm not to switch

00:34:00,629 --> 00:34:07,590
into some more heady stuff huh okay

00:34:04,500 --> 00:34:09,960
we'll stop me anytime replication for

00:34:07,590 --> 00:34:13,980
high availability let's gets us some

00:34:09,960 --> 00:34:15,750
more advanced replication scenarios in a

00:34:13,980 --> 00:34:18,419
case of high availability what you're

00:34:15,750 --> 00:34:20,669
after is you never want the app to go

00:34:18,419 --> 00:34:22,919
down for example you never want to have

00:34:20,669 --> 00:34:25,290
to take the app down in case anything

00:34:22,919 --> 00:34:28,139
bad happens to one of your servers so

00:34:25,290 --> 00:34:32,460
the most simplest form is having two

00:34:28,139 --> 00:34:35,129
masters so if you have two masters you

00:34:32,460 --> 00:34:37,020
could write to any the master and

00:34:35,129 --> 00:34:39,589
eventually you'll get updated on the

00:34:37,020 --> 00:34:44,129
other master how does it do that well

00:34:39,589 --> 00:34:47,369
the master becomes a slave of the other

00:34:44,129 --> 00:34:49,290
master and vice versa so it forms a

00:34:47,369 --> 00:34:51,899
simplest of circular replication

00:34:49,290 --> 00:34:54,480
topologies therefore you have two

00:34:51,899 --> 00:34:55,940
masters it's not the same as multi

00:34:54,480 --> 00:34:58,380
master you may hear that phrase

00:34:55,940 --> 00:35:00,900
multimaster means that a slave can

00:34:58,380 --> 00:35:04,380
accept updates from one more than one

00:35:00,900 --> 00:35:05,369
master in a case of mysql is true that

00:35:04,380 --> 00:35:08,249
slaves only

00:35:05,369 --> 00:35:10,079
except events from one and only one

00:35:08,249 --> 00:35:12,569
master and it's still true in this

00:35:10,079 --> 00:35:14,549
scenario because the other master is

00:35:12,569 --> 00:35:18,329
simply a slave of the first master and

00:35:14,549 --> 00:35:19,769
vice versa again log slave updates you

00:35:18,329 --> 00:35:23,519
need that in order to be able to afford

00:35:19,769 --> 00:35:26,999
the things on later so that means your

00:35:23,519 --> 00:35:29,279
client or your slave would be a slave of

00:35:26,999 --> 00:35:36,329
either the first master or the second

00:35:29,279 --> 00:35:38,519
master but not both question auto

00:35:36,329 --> 00:35:40,920
increment is as part of the events that

00:35:38,519 --> 00:35:43,589
are stored in the binary log so is

00:35:40,920 --> 00:35:45,630
random numbers so if you if you do a

00:35:43,589 --> 00:35:47,249
query that generates a random number on

00:35:45,630 --> 00:35:56,029
the master how do you know that it's the

00:35:47,249 --> 00:35:56,029
same random number on the sleigh yeah

00:35:56,200 --> 00:36:00,470
you could have a collision you couldn't

00:35:58,790 --> 00:36:04,970
you which in that case you would

00:36:00,470 --> 00:36:07,900
intentionally set up the auto increment

00:36:04,970 --> 00:36:10,310
to be different on each one so hot even

00:36:07,900 --> 00:36:11,570
you know that kind of thing so yeah

00:36:10,310 --> 00:36:16,610
there is there's a way around that a

00:36:11,570 --> 00:36:19,580
very safe way of doing it okay Duel

00:36:16,610 --> 00:36:23,630
Masters again Master is also a slave it

00:36:19,580 --> 00:36:26,060
sees its own events how does no events

00:36:23,630 --> 00:36:28,310
came from itself or the other master

00:36:26,060 --> 00:36:30,260
well we have something called server ID

00:36:28,310 --> 00:36:32,570
which is part of the configurations is

00:36:30,260 --> 00:36:34,970
setup replication each server has to

00:36:32,570 --> 00:36:37,370
have its own unique ID and that's part

00:36:34,970 --> 00:36:40,850
of the event it's toward an event so the

00:36:37,370 --> 00:36:43,280
master knows this you know the a server

00:36:40,850 --> 00:36:44,840
I think as a master knows where the

00:36:43,280 --> 00:36:48,530
event came from and well it knows where

00:36:44,840 --> 00:36:53,030
it came from it or not that's way we

00:36:48,530 --> 00:36:55,130
avoid re executing its own events I'm

00:36:53,030 --> 00:36:57,500
surprised nobody asked me that okay in

00:36:55,130 --> 00:36:59,870
circular replication this is another

00:36:57,500 --> 00:37:02,110
interesting scenario in this case you

00:36:59,870 --> 00:37:04,670
have many masters potentially involved

00:37:02,110 --> 00:37:06,350
each one is a master of the previous one

00:37:04,670 --> 00:37:09,140
and I'm actually seen a double ring here

00:37:06,350 --> 00:37:11,330
but this is just a single ring so it

00:37:09,140 --> 00:37:14,990
goes around clockwise each one has its

00:37:11,330 --> 00:37:17,390
unique ID so if a right comes in on say

00:37:14,990 --> 00:37:19,760
master with server ID 1 and then later

00:37:17,390 --> 00:37:23,780
gets executed on master server ID three

00:37:19,760 --> 00:37:25,670
and it gets right there it's not going

00:37:23,780 --> 00:37:27,770
to replay its own event it's going to

00:37:25,670 --> 00:37:28,940
die or drop or fall off the vine however

00:37:27,770 --> 00:37:32,570
you like to describe it when it gets

00:37:28,940 --> 00:37:35,120
back around the ring it's not

00:37:32,570 --> 00:37:36,980
necessarily a recommended set up and it

00:37:35,120 --> 00:37:39,110
can be fairly complicated to maintain

00:37:36,980 --> 00:37:42,680
the reason you might want to use

00:37:39,110 --> 00:37:44,240
circular replication is if you have and

00:37:42,680 --> 00:37:47,320
this let's say you have four

00:37:44,240 --> 00:37:50,210
applications they're all right intensive

00:37:47,320 --> 00:37:52,670
but you want to be able to have the data

00:37:50,210 --> 00:37:57,500
available at any time you could split

00:37:52,670 --> 00:37:59,450
the rights up among those four then

00:37:57,500 --> 00:38:03,470
means each master would have his own set

00:37:59,450 --> 00:38:05,330
of slaves I've seen that done before but

00:38:03,470 --> 00:38:08,150
so it's in short it would be a

00:38:05,330 --> 00:38:09,589
specialized purpose to use the circular

00:38:08,150 --> 00:38:15,230
replication

00:38:09,589 --> 00:38:15,230
okay the guts and gore of binary logs

00:38:17,210 --> 00:38:22,950
there are different kinds of logging

00:38:19,849 --> 00:38:26,190
their statement base row based and

00:38:22,950 --> 00:38:29,460
there's mixed statement based uses

00:38:26,190 --> 00:38:32,369
queries the same SQL that your users

00:38:29,460 --> 00:38:36,030
issued is stored in the buyer log along

00:38:32,369 --> 00:38:39,510
with additional metadata their log

00:38:36,030 --> 00:38:42,839
verbatim but there are some extensions I

00:38:39,510 --> 00:38:45,000
don't recall exact examples but in the

00:38:42,839 --> 00:38:49,700
manual there they list several queries

00:38:45,000 --> 00:38:52,130
that are not stored directly in it I

00:38:49,700 --> 00:38:56,359
almost have one I may think about it

00:38:52,130 --> 00:39:00,990
there is some non determinism involved

00:38:56,359 --> 00:39:05,160
it has to do with the context so you use

00:39:00,990 --> 00:39:08,520
database the command news database if

00:39:05,160 --> 00:39:10,230
you have queries intermixed you've got

00:39:08,520 --> 00:39:13,470
to use here and use here and they get

00:39:10,230 --> 00:39:16,410
mixed you know you could have the wrong

00:39:13,470 --> 00:39:18,329
database being the current database so

00:39:16,410 --> 00:39:21,030
the moral of the story is always always

00:39:18,329 --> 00:39:24,210
always always beat your users into

00:39:21,030 --> 00:39:27,540
submission to use database table or

00:39:24,210 --> 00:39:30,839
database object don't ever ever ever you

00:39:27,540 --> 00:39:33,780
know use the whip book that's one way to

00:39:30,839 --> 00:39:36,180
avoid that it does provide compacts more

00:39:33,780 --> 00:39:39,569
compact logs because it's not storing

00:39:36,180 --> 00:39:41,790
the entire binary row so statement based

00:39:39,569 --> 00:39:43,410
logging is readable by humans so you

00:39:41,790 --> 00:39:45,020
could actually print out the binary

00:39:43,410 --> 00:39:46,950
logon except for the additional metadata

00:39:45,020 --> 00:39:50,609
you would actually see the query

00:39:46,950 --> 00:39:53,220
statements row based on the other hand

00:39:50,609 --> 00:39:58,049
we've introduced in 5.1 is a more

00:39:53,220 --> 00:39:59,490
efficient way of executing the event and

00:39:58,049 --> 00:40:01,140
reason why it's more efficient is

00:39:59,490 --> 00:40:04,319
because it stores the internal row

00:40:01,140 --> 00:40:07,980
format so it has a before-and-after

00:40:04,319 --> 00:40:10,500
image for updates or our new image for

00:40:07,980 --> 00:40:12,480
firm inserts which means when it gets to

00:40:10,500 --> 00:40:14,609
the slave and the SQL thread reads it

00:40:12,480 --> 00:40:21,170
from the real a loan it doesn't have to

00:40:14,609 --> 00:40:21,170
rerun the optimizer it just applies it

00:40:21,319 --> 00:40:25,859
it can handle those more difficult

00:40:23,849 --> 00:40:29,579
statements that SQL doesn't oh here we

00:40:25,859 --> 00:40:32,160
are user divine functions uuid that kind

00:40:29,579 --> 00:40:34,770
of thing it allows for automatic

00:40:32,160 --> 00:40:37,049
switching so whatever is best if happens

00:40:34,770 --> 00:40:40,319
to be a simple SQL statements it could

00:40:37,049 --> 00:40:42,750
store it is a statement based so Row is

00:40:40,319 --> 00:40:46,349
possible store things a statement base I

00:40:42,750 --> 00:40:49,109
can store partially executed statements

00:40:46,349 --> 00:40:50,790
and it is required from mysql cluster

00:40:49,109 --> 00:40:52,589
replication so if you're interested in

00:40:50,790 --> 00:40:56,490
mysql clustering Wendy replication

00:40:52,589 --> 00:40:58,559
amongst different clusters so my scale

00:40:56,490 --> 00:41:00,900
cluster has its own internal replication

00:40:58,559 --> 00:41:03,270
what I'm talking about is the cus is

00:41:00,900 --> 00:41:08,210
replication between two separate MySQL

00:41:03,270 --> 00:41:10,740
clusters you want row base for that so

00:41:08,210 --> 00:41:14,400
statement everything is replicated as a

00:41:10,740 --> 00:41:17,010
statement and that's available since for

00:41:14,400 --> 00:41:22,349
something but is in five point 0 mixed

00:41:17,010 --> 00:41:25,799
is a says you seek used a statement base

00:41:22,349 --> 00:41:28,260
unless it's too complicated then use Row

00:41:25,799 --> 00:41:30,000
foma so it's which this row fat format

00:41:28,260 --> 00:41:33,420
for unsafe statements so what's an

00:41:30,000 --> 00:41:35,280
example of an unsafe statement let's say

00:41:33,420 --> 00:41:40,280
you have a transaction that involves a

00:41:35,280 --> 00:41:42,270
hmong IM table that's unsafe isn't it

00:41:40,280 --> 00:41:44,730
because it's not part of the transaction

00:41:42,270 --> 00:41:49,790
he can't undo it so that's an example

00:41:44,730 --> 00:41:49,790
where my youth it row based again the

00:41:49,940 --> 00:41:54,809
DML is replicated in raw format but the

00:41:52,530 --> 00:41:57,809
ddl was potentially in statement based

00:41:54,809 --> 00:42:00,089
so if you create a table you may see

00:41:57,809 --> 00:42:02,190
that create table in the binary log for

00:42:00,089 --> 00:42:06,770
example but if you do an insert you're

00:42:02,190 --> 00:42:09,180
going to see that as a binary row i

00:42:06,770 --> 00:42:11,040
mentioned the mysql been long tool that

00:42:09,180 --> 00:42:13,260
is your primary tool for dealing with

00:42:11,040 --> 00:42:15,599
the binary log will relay log depending

00:42:13,260 --> 00:42:17,790
on with your needs you can decode the

00:42:15,599 --> 00:42:20,280
events you can look at them and will try

00:42:17,790 --> 00:42:23,130
to tell you all the metadata that's

00:42:20,280 --> 00:42:25,529
involved it doesn't currently have make

00:42:23,130 --> 00:42:27,390
this human readable format possibility

00:42:25,529 --> 00:42:30,180
but there have been some suggestions for

00:42:27,390 --> 00:42:31,330
adding that feature you can use it for

00:42:30,180 --> 00:42:32,830
auditing

00:42:31,330 --> 00:42:37,480
and most importantly you can use it for

00:42:32,830 --> 00:42:39,400
recovery so you can actually create a

00:42:37,480 --> 00:42:42,130
segment of the binary law to be replayed

00:42:39,400 --> 00:42:45,250
on your master or other really loud play

00:42:42,130 --> 00:42:48,640
on your slave you can decode by events

00:42:45,250 --> 00:42:50,410
by position or even date time so you can

00:42:48,640 --> 00:42:52,450
tell it to dump all the events prior to

00:42:50,410 --> 00:42:54,760
a date time and it will show you all

00:42:52,450 --> 00:42:57,070
those events up to that so if you know

00:42:54,760 --> 00:42:59,290
when somebody issued the horrible delete

00:42:57,070 --> 00:43:03,400
from with nowhere cause then you can get

00:42:59,290 --> 00:43:05,860
everything prior to that here's what the

00:43:03,400 --> 00:43:09,310
microbe in law tool would look like when

00:43:05,860 --> 00:43:11,860
it's dumping a binary log in this case

00:43:09,310 --> 00:43:13,570
we are looking at statement based I can

00:43:11,860 --> 00:43:16,270
tell very quickly because I can read

00:43:13,570 --> 00:43:18,220
what the statement is if it were a row

00:43:16,270 --> 00:43:20,050
based all you would see is binary data

00:43:18,220 --> 00:43:21,820
that you might be able to recognize some

00:43:20,050 --> 00:43:24,670
of the character data character strings

00:43:21,820 --> 00:43:26,980
the rest of it would be gibberish in

00:43:24,670 --> 00:43:29,650
this case we have some metadata you see

00:43:26,980 --> 00:43:31,540
the start position there at 265 this

00:43:29,650 --> 00:43:32,920
actually tells you what so if you're

00:43:31,540 --> 00:43:35,410
looking at the binary law to try to

00:43:32,920 --> 00:43:38,830
figure out when to recover from event

00:43:35,410 --> 00:43:41,020
it's right there ready for you it also

00:43:38,830 --> 00:43:43,660
tells you the event type in this case

00:43:41,020 --> 00:43:46,840
it's a query if there was an error

00:43:43,660 --> 00:43:49,030
that's also provided and if it executed

00:43:46,840 --> 00:43:51,040
more than a few milliseconds it would

00:43:49,030 --> 00:43:53,560
have some time in there as well even it

00:43:51,040 --> 00:43:56,050
shows you the thread ID look at the set

00:43:53,560 --> 00:43:59,500
time stamp wonder why that's there

00:43:56,050 --> 00:44:01,090
that's there because that table I have

00:43:59,500 --> 00:44:04,960
to know but because I know what that

00:44:01,090 --> 00:44:06,520
table is it has a time step column so

00:44:04,960 --> 00:44:08,320
you want the time stamp on the sleigh to

00:44:06,520 --> 00:44:11,410
be the same time stamp that was on the

00:44:08,320 --> 00:44:14,020
master right well that's how it doesn't

00:44:11,410 --> 00:44:17,140
it actually sets the time stamp prior to

00:44:14,020 --> 00:44:18,910
executing that query and the optimizer

00:44:17,140 --> 00:44:21,610
is smart enough to be able to pick that

00:44:18,910 --> 00:44:25,330
up and stored in that that column for

00:44:21,610 --> 00:44:29,920
you so things like auto increment that's

00:44:25,330 --> 00:44:32,650
how that's stored as well so so the size

00:44:29,920 --> 00:44:34,480
of the event then is the end position

00:44:32,650 --> 00:44:37,380
which is not listed here it's actually

00:44:34,480 --> 00:44:41,470
down further minus the start position

00:44:37,380 --> 00:44:43,030
simple math there ok let's talk about

00:44:41,470 --> 00:44:44,440
MySQL utilities things that make your

00:44:43,030 --> 00:44:45,849
life a little easier i mentioned all

00:44:44,440 --> 00:44:48,040
things like oh you gotta use change

00:44:45,849 --> 00:44:50,050
master oh you gotta do start all you can

00:44:48,040 --> 00:44:51,490
do show slate oh you got to remember the

00:44:50,050 --> 00:44:54,609
binary log all right there's got to be

00:44:51,490 --> 00:44:56,500
an easier way right well there is the

00:44:54,609 --> 00:44:59,200
biosecurity utilities which is a team I

00:44:56,500 --> 00:45:02,020
lead it's designed to automate a lot of

00:44:59,200 --> 00:45:04,089
those tasks for you particularly

00:45:02,020 --> 00:45:07,690
replication for provisioning setting of

00:45:04,089 --> 00:45:09,160
a master slave testing it monitoring and

00:45:07,690 --> 00:45:11,589
make sure that it's okay or in the case

00:45:09,160 --> 00:45:14,740
when we you'll see in a moment something

00:45:11,589 --> 00:45:17,050
called failover you can do comparisons

00:45:14,740 --> 00:45:18,520
of databases so if you have a table on

00:45:17,050 --> 00:45:20,770
one server on a table on another you

00:45:18,520 --> 00:45:22,210
want to know what's different I have a

00:45:20,770 --> 00:45:24,130
utility that will actually tell you

00:45:22,210 --> 00:45:27,400
what's different in fact that it is

00:45:24,130 --> 00:45:30,250
different either in structure schema or

00:45:27,400 --> 00:45:32,619
in data and you can tell it to generate

00:45:30,250 --> 00:45:34,329
the changes so we'll generate the altar

00:45:32,619 --> 00:45:36,670
table statements for you it will

00:45:34,329 --> 00:45:39,609
generate generate the insert updates and

00:45:36,670 --> 00:45:42,730
deletes to transform the data very

00:45:39,609 --> 00:45:45,609
powerful tool you can do administrative

00:45:42,730 --> 00:45:48,640
tasks with users connections tables and

00:45:45,609 --> 00:45:51,369
so on there's even a utility to create a

00:45:48,640 --> 00:45:53,740
new instance of a running server why

00:45:51,369 --> 00:45:55,930
would you want to do that well if you're

00:45:53,740 --> 00:45:58,450
in a cloud environment you have a very

00:45:55,930 --> 00:46:02,710
large cloud instance and you want to

00:45:58,450 --> 00:46:05,890
spawn a new server rather than having to

00:46:02,710 --> 00:46:08,230
copy the binary figure out a new day

00:46:05,890 --> 00:46:11,680
directory do all that stuff install a

00:46:08,230 --> 00:46:14,200
new instance whatever it is use MySQL

00:46:11,680 --> 00:46:17,980
server clone clone the existing server

00:46:14,200 --> 00:46:20,079
on that cloud instance as many times as

00:46:17,980 --> 00:46:24,480
you'd like and now you have multiple

00:46:20,079 --> 00:46:24,480
instances running on it yes sir

00:46:25,700 --> 00:46:35,340
no no my SQL instance yeah so what it

00:46:31,200 --> 00:46:38,610
does since you asked it will execute a

00:46:35,340 --> 00:46:40,350
new process new mysqld process and you

00:46:38,610 --> 00:46:42,030
have to tell it a new data directory or

00:46:40,350 --> 00:46:45,600
create a new data directory and run the

00:46:42,030 --> 00:46:49,350
install DB scripts so it sets up a new

00:46:45,600 --> 00:46:51,780
one from scratch be very handy in scale

00:46:49,350 --> 00:46:52,950
out like I just mentioned also handy for

00:46:51,780 --> 00:46:57,180
development and testing or

00:46:52,950 --> 00:46:59,810
experimentation I use it as part of a I

00:46:57,180 --> 00:47:03,450
mean I use it daily I mean I created a

00:46:59,810 --> 00:47:05,040
dozens of them running at one time mysql

00:47:03,450 --> 00:47:09,330
utilities is written purely in python

00:47:05,040 --> 00:47:13,440
anybody speak python hey guess what you

00:47:09,330 --> 00:47:15,540
can download this it's GPL you want to

00:47:13,440 --> 00:47:17,190
create your own utilities from one hand

00:47:15,540 --> 00:47:18,570
say it's got a utility does sort of what

00:47:17,190 --> 00:47:23,700
you want but if it only had this feature

00:47:18,570 --> 00:47:25,950
hey have at it develop it have fun it is

00:47:23,700 --> 00:47:27,750
available from launch pad but I did

00:47:25,950 --> 00:47:30,150
mention it's part of the or if I didn't

00:47:27,750 --> 00:47:33,180
mention mysql utilities is part of the

00:47:30,150 --> 00:47:35,220
mysql workbench GUI tool so if you

00:47:33,180 --> 00:47:37,890
download mysql workbench you will get

00:47:35,220 --> 00:47:39,930
mysql utilities do you want mysql attila

00:47:37,890 --> 00:47:42,420
t is what outlook bench you can get it

00:47:39,930 --> 00:47:43,650
from the launchpad and I've got a slide

00:47:42,420 --> 00:47:45,690
that shows you where to get that and

00:47:43,650 --> 00:47:46,980
there's a couple references there you

00:47:45,690 --> 00:47:50,100
might want to start to read more about

00:47:46,980 --> 00:47:53,700
utilities let's go through a workflow

00:47:50,100 --> 00:47:56,370
for replication now we have four stages

00:47:53,700 --> 00:47:58,680
checking to actually doing the

00:47:56,370 --> 00:48:03,570
replication showing the results or the

00:47:58,680 --> 00:48:05,940
status and then fail oh so here's an

00:48:03,570 --> 00:48:09,030
example of checking there's a utility

00:48:05,940 --> 00:48:12,750
called Moscow RPL check it's designed to

00:48:09,030 --> 00:48:14,460
make sure that a existing relationship

00:48:12,750 --> 00:48:17,160
between a master and slave is not only

00:48:14,460 --> 00:48:20,010
viable was without errors why would that

00:48:17,160 --> 00:48:22,470
be important well if you have a large

00:48:20,010 --> 00:48:24,960
topology with many masters and thousands

00:48:22,470 --> 00:48:26,940
of slaves at any one point in time if

00:48:24,960 --> 00:48:29,190
somebody asked you what's the master for

00:48:26,940 --> 00:48:31,350
that slave and you say well I think it's

00:48:29,190 --> 00:48:33,120
this one well that one's down what was

00:48:31,350 --> 00:48:34,630
his master before went down you know

00:48:33,120 --> 00:48:36,640
it's hard drive crash

00:48:34,630 --> 00:48:39,220
I don't know it's a hard drive crashed

00:48:36,640 --> 00:48:41,049
well you could start it up if you have

00:48:39,220 --> 00:48:43,779
any kind of way of retrieving any about

00:48:41,049 --> 00:48:44,980
information you could run Ruppel check

00:48:43,779 --> 00:48:47,500
and it will tell you whether that

00:48:44,980 --> 00:48:49,359
particular master is right one or not so

00:48:47,500 --> 00:48:51,730
it checks things like the binary log is

00:48:49,359 --> 00:48:54,309
enabled on a master a lot of sanity

00:48:51,730 --> 00:48:56,079
checks there believe it or not there are

00:48:54,309 --> 00:48:57,759
different ways of setting up replication

00:48:56,079 --> 00:49:00,789
some of which aren't all together

00:48:57,759 --> 00:49:02,890
necessarily good practices this

00:49:00,789 --> 00:49:06,519
implements the best practices and checks

00:49:02,890 --> 00:49:09,220
it for you so here's an example of it

00:49:06,519 --> 00:49:11,170
running in this case it's doing all

00:49:09,220 --> 00:49:14,349
these tests and in this example

00:49:11,170 --> 00:49:16,960
everything passed all utilities are

00:49:14,349 --> 00:49:18,789
written with our varsity mode so if you

00:49:16,960 --> 00:49:21,430
need to find more information you simply

00:49:18,789 --> 00:49:25,150
provide a parameter dash dash verbosity

00:49:21,430 --> 00:49:27,549
or simply dash vvv I'll give you a

00:49:25,150 --> 00:49:29,250
shortcut you can and that says a

00:49:27,549 --> 00:49:31,750
provocative a paucity of our varsity

00:49:29,250 --> 00:49:33,549
give me all the information if you ran

00:49:31,750 --> 00:49:36,940
it with this one it would show you for

00:49:33,549 --> 00:49:40,299
example the Masters log in position the

00:49:36,940 --> 00:49:41,890
slave status additional information the

00:49:40,299 --> 00:49:44,829
information you use to determine whether

00:49:41,890 --> 00:49:48,220
it was a pass or fail all utilities are

00:49:44,829 --> 00:49:50,200
written that way okay the replicate

00:49:48,220 --> 00:49:52,240
utility is the one we use to actually

00:49:50,200 --> 00:49:54,970
set up replication between a master and

00:49:52,240 --> 00:49:56,559
slave it simplifies everything because

00:49:54,970 --> 00:49:58,450
all you have to do is tell it the master

00:49:56,559 --> 00:50:02,410
what you want to be the master and what

00:49:58,450 --> 00:50:04,509
you want to be the slave and although it

00:50:02,410 --> 00:50:07,269
has a default the replication user the

00:50:04,509 --> 00:50:09,609
user to use to create on the master to

00:50:07,269 --> 00:50:11,410
allow replication that's it very fast

00:50:09,609 --> 00:50:14,410
very quick and here's an example of it

00:50:11,410 --> 00:50:16,450
running doesn't do a whole lot you say

00:50:14,410 --> 00:50:18,579
well turn velocity on you'll see it does

00:50:16,450 --> 00:50:20,589
actually a whole lot it does all the

00:50:18,579 --> 00:50:22,660
steps for you there's no change master

00:50:20,589 --> 00:50:24,069
in that list you just give it a mass

00:50:22,660 --> 00:50:27,279
name of the master and name of the slave

00:50:24,069 --> 00:50:29,710
have at it whoo course there are other

00:50:27,279 --> 00:50:32,200
options you can use like I was mentioned

00:50:29,710 --> 00:50:34,329
before about where to start the binary

00:50:32,200 --> 00:50:36,400
log you're reading in the binary log I

00:50:34,329 --> 00:50:38,890
had a particular log in position from

00:50:36,400 --> 00:50:43,890
the beginning or from current default is

00:50:38,890 --> 00:50:47,109
from current position this is a neat one

00:50:43,890 --> 00:50:48,170
mysql RPL show i created it because

00:50:47,109 --> 00:50:50,180
somebody asked me to

00:50:48,170 --> 00:50:51,920
and I thought oh this will be a utility

00:50:50,180 --> 00:50:54,500
that would be kind of handy but I'm not

00:50:51,920 --> 00:50:56,359
sure anybody necessarily wants it it's

00:50:54,500 --> 00:50:59,210
one of our most top sellers you might

00:50:56,359 --> 00:51:02,420
say everybody loves it what it does is

00:50:59,210 --> 00:51:05,990
you give it the name of a master I need

00:51:02,420 --> 00:51:08,210
to tell you all the slaves again if you

00:51:05,990 --> 00:51:10,250
have hundreds of servers to deal with

00:51:08,210 --> 00:51:11,750
you may not necessarily know how many

00:51:10,250 --> 00:51:13,400
slaves are connected to any one master

00:51:11,750 --> 00:51:15,740
because there's not a quick way of

00:51:13,400 --> 00:51:19,670
finding out you can do show process this

00:51:15,740 --> 00:51:22,040
and start counting the connections but

00:51:19,670 --> 00:51:25,460
there's possible for a client and kind

00:51:22,040 --> 00:51:26,839
of sort of look like a slave and there

00:51:25,460 --> 00:51:29,089
are other tools it can connect like a

00:51:26,839 --> 00:51:31,160
binary API tools that you could connect

00:51:29,089 --> 00:51:33,290
which actually looks like a slave the

00:51:31,160 --> 00:51:35,359
MySQL proxy can connect which looks like

00:51:33,290 --> 00:51:37,430
a slave but it's not really a slave and

00:51:35,359 --> 00:51:39,799
as long as you give it the topmost

00:51:37,430 --> 00:51:43,099
master it will it will and tell it to

00:51:39,799 --> 00:51:46,460
recurse it will find all of the servers

00:51:43,099 --> 00:51:50,299
in your topology so in this case this

00:51:46,460 --> 00:51:53,119
example shows the master at 3306 has two

00:51:50,299 --> 00:51:56,329
slaves one of those slaves is a master

00:51:53,119 --> 00:51:59,510
to yet another slave so that's why I

00:51:56,329 --> 00:52:00,920
says slave plus master there and the

00:51:59,510 --> 00:52:02,839
reason why this is popular is because

00:52:00,920 --> 00:52:05,540
people will go out and make changes from

00:52:02,839 --> 00:52:08,450
the replication topology and new slaves

00:52:05,540 --> 00:52:09,680
drop old slaves and then say my wonder

00:52:08,450 --> 00:52:12,049
what it looks like and they run this

00:52:09,680 --> 00:52:14,930
very quick and it shows them what they

00:52:12,049 --> 00:52:17,990
need to know the way this works is that

00:52:14,930 --> 00:52:20,059
each slave has to be started with report

00:52:17,990 --> 00:52:23,240
host till you give it the hostname and

00:52:20,059 --> 00:52:25,839
report port near the port name there's

00:52:23,240 --> 00:52:30,440
no other way to discover the slaves if

00:52:25,839 --> 00:52:31,940
any other way except through that so

00:52:30,440 --> 00:52:33,530
what that means is those parameters are

00:52:31,940 --> 00:52:35,569
used when the slave connects to the

00:52:33,530 --> 00:52:37,700
master says how I almost lave start

00:52:35,569 --> 00:52:40,280
sending me your events it says here's my

00:52:37,700 --> 00:52:42,799
hostname here's my port and the master

00:52:40,280 --> 00:52:46,160
records it you can see that information

00:52:42,799 --> 00:52:48,710
raw if you issue a command show slave

00:52:46,160 --> 00:52:51,380
host so now i'm giving you the secret of

00:52:48,710 --> 00:52:53,690
how this works that's all it does show

00:52:51,380 --> 00:52:56,839
slaver host and then it converts it to a

00:52:53,690 --> 00:52:59,359
graph so gee whiz right but it's one

00:52:56,839 --> 00:53:00,580
those time-saving things now let's look

00:52:59,359 --> 00:53:04,580
at failover

00:53:00,580 --> 00:53:07,820
there's a reference to GT ID here global

00:53:04,580 --> 00:53:13,930
transaction identifier every event in

00:53:07,820 --> 00:53:16,970
mysql 5.5 and before every event had

00:53:13,930 --> 00:53:21,530
associated with it a binary log in

00:53:16,970 --> 00:53:24,770
position when an event gets propagated

00:53:21,530 --> 00:53:30,310
to the slaves all that information is

00:53:24,770 --> 00:53:33,410
stored but what happens if some events

00:53:30,310 --> 00:53:35,840
go from the master to some slaves and

00:53:33,410 --> 00:53:37,700
yet other events go from that same

00:53:35,840 --> 00:53:42,560
master to other slave and the master

00:53:37,700 --> 00:53:44,930
goes away how do you know what events

00:53:42,560 --> 00:53:47,990
were executed on a particular slave and

00:53:44,930 --> 00:53:49,760
not another you can look at the Masters

00:53:47,990 --> 00:53:52,100
log in position we'll give you a general

00:53:49,760 --> 00:53:54,740
idea of whether you know particular

00:53:52,100 --> 00:53:56,690
slave is ahead or behind the master and

00:53:54,740 --> 00:53:59,540
which one is necessarily ahead or behind

00:53:56,690 --> 00:54:01,430
the other but it won't tell you whether

00:53:59,540 --> 00:54:03,830
all the events got executed on a

00:54:01,430 --> 00:54:06,350
particular slave or not global

00:54:03,830 --> 00:54:09,800
transaction identifier simply appends a

00:54:06,350 --> 00:54:12,680
good so 128 bit unique identifier each

00:54:09,800 --> 00:54:15,410
event now we don't have to remember

00:54:12,680 --> 00:54:18,080
anything about binary log names or

00:54:15,410 --> 00:54:20,780
positions because each event is unique

00:54:18,080 --> 00:54:23,350
on the topology it also means we don't

00:54:20,780 --> 00:54:25,220
have to worry necessarily whether some

00:54:23,350 --> 00:54:29,540
events get executed on a particular

00:54:25,220 --> 00:54:33,560
slave or not on another site because you

00:54:29,540 --> 00:54:36,830
through this failover a tool allows you

00:54:33,560 --> 00:54:40,340
to take and if a master goes offline it

00:54:36,830 --> 00:54:43,510
takes a slave and makes that slave a

00:54:40,340 --> 00:54:46,190
slave of every other slave there by

00:54:43,510 --> 00:54:49,370
accumulating all the global transaction

00:54:46,190 --> 00:54:51,530
identifier that are unique so do you

00:54:49,370 --> 00:54:53,630
have my global Boyd anywhere you do okay

00:54:51,530 --> 00:54:56,750
yeah oh you don't have that okay give me

00:54:53,630 --> 00:54:59,720
that you know and it acquires all the

00:54:56,750 --> 00:55:03,260
events and therefore becomes the

00:54:59,720 --> 00:55:05,510
replacement slave so in a nutshell my

00:55:03,260 --> 00:55:08,150
escrow will fail over utility was

00:55:05,510 --> 00:55:10,280
designed to monitor master and if the

00:55:08,150 --> 00:55:12,390
master goes offline execute that

00:55:10,280 --> 00:55:16,519
procedure I just told you about

00:55:12,390 --> 00:55:21,059
and automatically switch to a new master

00:55:16,519 --> 00:55:23,400
cool there are some pre and post

00:55:21,059 --> 00:55:24,630
failover scripts that you can execute to

00:55:23,400 --> 00:55:26,819
allow you to communicate with an

00:55:24,630 --> 00:55:29,789
application so if your application once

00:55:26,819 --> 00:55:31,440
you want to use failover your

00:55:29,789 --> 00:55:34,019
application be aware of when the

00:55:31,440 --> 00:55:41,250
failover actually occurs in a way that

00:55:34,019 --> 00:55:43,619
works yes sir yeah yeah yeah yeahs

00:55:41,250 --> 00:55:46,589
mindful failover in this case i'm using

00:55:43,619 --> 00:55:48,240
discover slaves login remember i

00:55:46,589 --> 00:55:50,609
mentioned report hose for port port

00:55:48,240 --> 00:55:53,069
discover slaves well that functionality

00:55:50,609 --> 00:55:54,510
is in MySQL failover to you don't have

00:55:53,069 --> 00:55:57,059
to know all the slaves just tell it to

00:55:54,510 --> 00:55:59,400
discover if you use report host at Fort

00:55:57,059 --> 00:56:01,640
Point and in this case by default it

00:55:59,400 --> 00:56:05,339
shows you a health status of all your

00:56:01,640 --> 00:56:06,809
servers mysql failover works on master

00:56:05,339 --> 00:56:09,450
basis so if you have multiple masters

00:56:06,809 --> 00:56:11,519
say a tiered hierarchy kind of thing you

00:56:09,450 --> 00:56:14,339
would run one instance of mysql failover

00:56:11,519 --> 00:56:18,059
for each master it only does one master

00:56:14,339 --> 00:56:20,400
and its slaves it will tell you whether

00:56:18,059 --> 00:56:22,109
global transaction IDs are on or not and

00:56:20,400 --> 00:56:24,930
in this case to be fully functional it

00:56:22,109 --> 00:56:28,410
has to be on and whether the slave is

00:56:24,930 --> 00:56:30,960
the server is up or not if failover

00:56:28,410 --> 00:56:32,400
occurs it will it will actually start

00:56:30,960 --> 00:56:34,680
telling you what's going on and it will

00:56:32,400 --> 00:56:37,140
list all the steps that happen once it

00:56:34,680 --> 00:56:40,170
switches control to the new master it

00:56:37,140 --> 00:56:43,470
then displays the health again with a

00:56:40,170 --> 00:56:46,259
new master as the root now i should say

00:56:43,470 --> 00:56:47,700
that the this happens on an interval and

00:56:46,259 --> 00:56:50,099
it's adjustable you can tell it how many

00:56:47,700 --> 00:56:52,410
seconds hours days whatever to wait to

00:56:50,099 --> 00:56:55,200
check the master what it does is it says

00:56:52,410 --> 00:56:57,630
okay master attempts to issue a query

00:56:55,200 --> 00:57:00,210
show databases that successful mastered

00:56:57,630 --> 00:57:02,549
obviously up that's not successful it

00:57:00,210 --> 00:57:06,329
says okay let me try connecting to it

00:57:02,549 --> 00:57:08,460
again if it connects masters up it can't

00:57:06,329 --> 00:57:10,589
connect it says okay wait a minute that

00:57:08,460 --> 00:57:12,180
hangs it if it can't ping it can connect

00:57:10,589 --> 00:57:15,509
to it can run a query the Masters dead

00:57:12,180 --> 00:57:18,059
then it runs failover so that's how that

00:57:15,509 --> 00:57:20,190
works the replication administration

00:57:18,059 --> 00:57:22,890
utility is an interesting one allows you

00:57:20,190 --> 00:57:24,029
to switch over or fail over the

00:57:22,890 --> 00:57:25,019
difference between switch over and

00:57:24,029 --> 00:57:27,329
failover is this

00:57:25,019 --> 00:57:30,269
switch over you simply switch the role

00:57:27,329 --> 00:57:32,489
from the master to another slave masters

00:57:30,269 --> 00:57:35,189
still alive which means you can tell the

00:57:32,489 --> 00:57:36,719
master to stop accepting rights or tell

00:57:35,189 --> 00:57:38,759
your application to stop writing to it

00:57:36,719 --> 00:57:41,029
and that way you don't lose any

00:57:38,759 --> 00:57:43,919
transactions when you switch the role

00:57:41,029 --> 00:57:45,390
failover is the master is completing on

00:57:43,919 --> 00:57:47,489
you have no idea what happened to it

00:57:45,390 --> 00:57:50,039
it's out in la la land and now you need

00:57:47,489 --> 00:57:51,839
to get another master back online so

00:57:50,039 --> 00:57:53,729
this is the difference between those two

00:57:51,839 --> 00:57:57,749
and ripple admin will allow you to

00:57:53,729 --> 00:57:59,549
either on demand ok here's an example of

00:57:57,749 --> 00:58:02,039
switch over running one of the things

00:57:59,549 --> 00:58:05,189
you might want to know about is that the

00:58:02,039 --> 00:58:07,319
demote master allows you to take the

00:58:05,189 --> 00:58:10,019
master take it offline as a master

00:58:07,319 --> 00:58:12,239
switch the role bring it back up along

00:58:10,019 --> 00:58:14,779
as a slave so if you simply want to

00:58:12,239 --> 00:58:19,679
rotate the role of Master among servers

00:58:14,779 --> 00:58:21,599
this tool will do that ok here's how you

00:58:19,679 --> 00:58:23,789
get it again it's available on launch

00:58:21,599 --> 00:58:26,069
pad if you want to get it from launch

00:58:23,789 --> 00:58:28,439
pad you have to have the Keth on

00:58:26,069 --> 00:58:30,239
connector that's also on launch pad or

00:58:28,439 --> 00:58:32,999
you can get it directly as part of the

00:58:30,239 --> 00:58:38,630
mile squall workbench and there are so

00:58:32,999 --> 00:58:42,059
URLs there as well ok so in short

00:58:38,630 --> 00:58:45,209
replication is flexible allows you to do

00:58:42,059 --> 00:58:47,899
scale out it's asynchronous you have a

00:58:45,209 --> 00:58:49,409
master in many slaves it's a

00:58:47,899 --> 00:58:52,259
architectural building block for

00:58:49,409 --> 00:58:55,049
high-availability solutions various use

00:58:52,259 --> 00:58:57,449
cases you use it again the various row

00:58:55,049 --> 00:59:00,149
formats you might want to use row mix

00:58:57,449 --> 00:59:05,309
statement and mysql utilities can make

00:59:00,149 --> 00:59:09,299
your life easier any questions we got

00:59:05,309 --> 00:59:13,139
about 15 seconds that doesn't mean don't

00:59:09,299 --> 00:59:15,180
ask me that just means we cook about yes

00:59:13,139 --> 00:59:20,369
sir

00:59:15,180 --> 00:59:22,410
are there utilities utilities are GPL

00:59:20,369 --> 00:59:23,730
they're separate from the server but

00:59:22,410 --> 00:59:25,859
they are part of bio school workbench

00:59:23,730 --> 00:59:31,770
which is also GPL and separate from the

00:59:25,859 --> 00:59:33,869
server oh yes yes the only caveat is the

00:59:31,770 --> 00:59:37,230
MySQL failover and the failover in

00:59:33,869 --> 00:59:39,690
general requires the new 5.6 DMR to work

00:59:37,230 --> 00:59:41,730
but eventually you know 5.6 will be

00:59:39,690 --> 00:59:49,280
released and as you can see utilities is

00:59:41,730 --> 00:59:49,280
ready for it okay yes sir

00:59:53,769 --> 00:59:59,989
sometime soon we don't we don't have an

00:59:57,079 --> 01:00:02,479
actual hard release release date yet but

00:59:59,989 --> 01:00:03,979
will probably come MySQL connect oracle

01:00:02,479 --> 01:00:09,920
openworld they'll be an announcement for

01:00:03,979 --> 01:00:12,369
it so stay tuned it's coming alright

01:00:09,920 --> 01:00:12,369
thanks

01:00:19,670 --> 01:00:24,480
when we created asterisk over a decade

01:00:22,380 --> 01:00:26,700
ago we could not have imagined that

01:00:24,480 --> 01:00:28,890
asterisk would not only become the most

01:00:26,700 --> 01:00:31,050
widely adopted open source communication

01:00:28,890 --> 01:00:33,060
software on the planet but that it would

01:00:31,050 --> 01:00:35,580
impact the entire industry in the way

01:00:33,060 --> 01:00:37,560
that it has today asterisk has found its

01:00:35,580 --> 01:00:40,200
way into more than 170 countries and

01:00:37,560 --> 01:00:42,150
virtually every fortune 1000 company the

01:00:40,200 --> 01:00:44,250
success of asterisk has enabled a

01:00:42,150 --> 01:00:45,660
transition of power from the hands of

01:00:44,250 --> 01:00:47,940
the traditional proprietary phone

01:00:45,660 --> 01:00:50,340
vendors into the hands of the users and

01:00:47,940 --> 01:00:52,410
administrators of phone systems using

01:00:50,340 --> 01:00:54,060
this power our customers have traded all

01:00:52,410 --> 01:00:56,130
sorts of business changing applications

01:00:54,060 --> 01:00:57,930
from small office phone systems to

01:00:56,130 --> 01:01:00,030
mission-critical call centers the

01:00:57,930 --> 01:01:01,860
international carrier networks in fact

01:01:00,030 --> 01:01:03,330
there's even an entire country those

01:01:01,860 --> 01:01:05,580
communications infrastructure runs on

01:01:03,330 --> 01:01:07,710
esters the gym has always been about

01:01:05,580 --> 01:01:09,420
creating technology that expands

01:01:07,710 --> 01:01:11,610
communications capabilities in ways that

01:01:09,420 --> 01:01:12,780
we could never have imagined and that's

01:01:11,610 --> 01:01:15,180
part of what's game-changing about

01:01:12,780 --> 01:01:17,880
Digium today we're doing it again this

01:01:15,180 --> 01:01:19,980
time by introducing a new family of HD

01:01:17,880 --> 01:01:22,080
IP phones that extends control of the

01:01:19,980 --> 01:01:23,850
user all the way to the desktop the

01:01:22,080 --> 01:01:25,560
launch of these new products represents

01:01:23,850 --> 01:01:27,510
the next phase indigenous history of

01:01:25,560 --> 01:01:30,060
innovation these are the first and only

01:01:27,510 --> 01:01:31,770
IP phones designed to fully leverage the

01:01:30,060 --> 01:01:33,330
power of Astra's when we first discussed

01:01:31,770 --> 01:01:35,340
our expectations for building a family

01:01:33,330 --> 01:01:37,500
of phones for use with asterisk our

01:01:35,340 --> 01:01:39,240
requirements were pretty simple we asked

01:01:37,500 --> 01:01:40,890
the team to build the phones such that

01:01:39,240 --> 01:01:43,080
they were easy to install integrate

01:01:40,890 --> 01:01:44,940
provision and use I think you'll soon

01:01:43,080 --> 01:01:47,490
agree our engineers have delivered on

01:01:44,940 --> 01:01:49,110
that goal user feedback is validating

01:01:47,490 --> 01:01:51,240
that when it comes to operation with

01:01:49,110 --> 01:01:53,670
astro space systems including our own

01:01:51,240 --> 01:01:56,250
Switchvox based product these are the

01:01:53,670 --> 01:01:57,540
easiest to use best integrated most

01:01:56,250 --> 01:02:00,150
interoperable products on the market

01:01:57,540 --> 01:02:02,120
today the digitally of phones will

01:02:00,150 --> 01:02:04,170
initially include three IP des hommes

01:02:02,120 --> 01:02:06,120
uniquely designed to complement any

01:02:04,170 --> 01:02:07,980
asterisks or Switchvox based solution

01:02:06,120 --> 01:02:10,650
these phones are different for a number

01:02:07,980 --> 01:02:13,320
of reasons first there is clue sively

01:02:10,650 --> 01:02:14,730
designed for use with esters secondly

01:02:13,320 --> 01:02:16,340
we've made it really easy to

01:02:14,730 --> 01:02:18,750
autodiscover and provision the phones

01:02:16,340 --> 01:02:20,430
next we've made it easy for the phones

01:02:18,750 --> 01:02:22,140
to access information inside of

01:02:20,430 --> 01:02:23,640
asterisks allowing tight coupling

01:02:22,140 --> 01:02:26,370
between an application

01:02:23,640 --> 01:02:28,500
the phone additionally we've created an

01:02:26,370 --> 01:02:30,630
applications engine that allows users

01:02:28,500 --> 01:02:33,870
and developers to create and run their

01:02:30,630 --> 01:02:35,640
own apps on the phone and finally we've

01:02:33,870 --> 01:02:37,590
done all of this at a very compelling

01:02:35,640 --> 01:02:39,270
price point at Digium we're always

01:02:37,590 --> 01:02:41,370
thinking of ways to give our customers

01:02:39,270 --> 01:02:43,890
the best value in business phone systems

01:02:41,370 --> 01:02:45,480
and also give them the power to create

01:02:43,890 --> 01:02:47,640
their own solutions or any

01:02:45,480 --> 01:02:49,380
communications challenge will continue

01:02:47,640 --> 01:02:50,820
to push the boundaries not only to make

01:02:49,380 --> 01:02:52,860
Astra's cooler bastard more

01:02:50,820 --> 01:02:54,600
technologically feature-rich but to make

01:02:52,860 --> 01:02:57,120
asterisk and communications even easier

01:02:54,600 --> 01:03:00,650
and together we'll change the way the

01:02:57,120 --> 01:03:00,650
world communicates again

01:03:36,110 --> 01:03:38,170
you

01:03:42,040 --> 01:03:48,550
how's that sigh every way this is the

01:03:45,220 --> 01:03:50,710
way to better utilize all your resources

01:03:48,550 --> 01:03:54,160
and it makes managing all your resources

01:03:50,710 --> 01:03:57,990
pretty easy all of the innovation is

01:03:54,160 --> 01:04:01,510
happening in open source the

01:03:57,990 --> 01:04:03,310
collaborative nature and of the you know

01:04:01,510 --> 01:04:05,230
of the community and the speed at which

01:04:03,310 --> 01:04:07,420
these are these you know these

01:04:05,230 --> 01:04:09,730
deficiencies these bugs are getting

01:04:07,420 --> 01:04:12,310
discovered and then fixed is it like

01:04:09,730 --> 01:04:15,040
that really shows the power of the you

01:04:12,310 --> 01:04:16,660
know of the open source community it is

01:04:15,040 --> 01:04:20,860
global and it's definitely because of

01:04:16,660 --> 01:04:27,190
the users community people are extremely

01:04:20,860 --> 01:04:29,080
friendly and always ready to help if you

01:04:27,190 --> 01:04:31,360
go on tire see any day you'll see these

01:04:29,080 --> 01:04:33,090
guys helping each other out and they're

01:04:31,360 --> 01:04:35,800
all doing it like in a selfless manner

01:04:33,090 --> 01:04:38,790
the product is transparent for everyone

01:04:35,800 --> 01:04:42,010
everyone can look at the code base

01:04:38,790 --> 01:04:44,220
everyone can see how close that is being

01:04:42,010 --> 01:04:49,720
built nothing nothing is proprietary

01:04:44,220 --> 01:04:52,390
everything is open in many ways it's

01:04:49,720 --> 01:04:56,800
absolutely vital to the the ongoing

01:04:52,390 --> 01:05:01,000
health cloudstack the most exciting

01:04:56,800 --> 01:05:03,840
event in recent memory for me was our

01:05:01,000 --> 01:05:06,480
first developer boot camp

01:05:03,840 --> 01:05:09,150
and our call gave people I gave you two

01:05:06,480 --> 01:05:13,110
weeks notice to come attend I was

01:05:09,150 --> 01:05:17,280
expecting 25 or 30 people so we ended up

01:05:13,110 --> 01:05:20,100
with 87 people and had to go get more

01:05:17,280 --> 01:05:22,650
chairs in the room twice everything

01:05:20,100 --> 01:05:25,980
within cloud computing is commodity and

01:05:22,650 --> 01:05:28,950
is open source and so I don't think that

01:05:25,980 --> 01:05:30,720
you will you'll see anywhere where open

01:05:28,950 --> 01:05:33,750
source is not pervasive in cloud

01:05:30,720 --> 01:05:36,450
computing and so i think it's i think

01:05:33,750 --> 01:05:37,830
it's an assumption i think when you talk

01:05:36,450 --> 01:05:38,940
about cloud computing you're really

01:05:37,830 --> 01:05:44,490
talking about open source cloud

01:05:38,940 --> 01:05:47,640
computing cloud sac is a robust solution

01:05:44,490 --> 01:05:50,040
for large deployments you have dozens of

01:05:47,640 --> 01:05:53,940
data centers and thousands of servers in

01:05:50,040 --> 01:05:56,610
each data centers these hardware is

01:05:53,940 --> 01:06:00,090
going to fail and CloudStack is designed

01:05:56,610 --> 01:06:02,790
to handle number one that mass scale

01:06:00,090 --> 01:06:05,970
number two it's designed to handle the

01:06:02,790 --> 01:06:08,850
failure that inevitably happens in large

01:06:05,970 --> 01:06:13,020
deployments started working on contact

01:06:08,850 --> 01:06:16,290
over four years ago and it was the

01:06:13,020 --> 01:06:18,090
original set of people working on it had

01:06:16,290 --> 01:06:22,170
a background of delivering software

01:06:18,090 --> 01:06:26,430
telcos and service providers lots of QA

01:06:22,170 --> 01:06:30,030
lots of users actually using it high

01:06:26,430 --> 01:06:33,120
availability is the key feature multiple

01:06:30,030 --> 01:06:35,280
hypervisors support different network

01:06:33,120 --> 01:06:38,310
models we can pick up whatever suits you

01:06:35,280 --> 01:06:40,080
better while step management server can

01:06:38,310 --> 01:06:43,770
be deployed in different physical

01:06:40,080 --> 01:06:45,420
machines it definitely has a huge

01:06:43,770 --> 01:06:50,400
footprint it's being deployed everywhere

01:06:45,420 --> 01:06:52,980
there's a major movie studio that they

01:06:50,400 --> 01:06:56,280
were using cloudstack they were using it

01:06:52,980 --> 01:06:58,260
to transcode video and i thought that

01:06:56,280 --> 01:06:59,910
was terribly fascinating what i found

01:06:58,260 --> 01:07:03,180
more fascinating is what they did during

01:06:59,910 --> 01:07:05,970
lunch where they would spin up you know

01:07:03,180 --> 01:07:07,120
50 or 60 game servers then as soon as

01:07:05,970 --> 01:07:08,980
lunch was over they would dis

01:07:07,120 --> 01:07:13,090
all the instances and go back to doing

01:07:08,980 --> 01:07:14,710
real work CloudStack is vast it touches

01:07:13,090 --> 01:07:16,810
so many different aspects and there's no

01:07:14,710 --> 01:07:19,180
one person that's kind of like a master

01:07:16,810 --> 01:07:23,290
of all those realms I think clouds stack

01:07:19,180 --> 01:07:25,600
as a project is going to be one of the

01:07:23,290 --> 01:07:29,590
leaders simply because it's some of the

01:07:25,600 --> 01:07:35,020
most feature fallen and and robust

01:07:29,590 --> 01:07:37,920
platforms out they learn I don't senior

01:07:35,020 --> 01:07:37,920
living through the clouds dag

01:07:50,700 --> 01:07:52,760

YouTube URL: https://www.youtube.com/watch?v=47kV0ImtYH8


