Title: 2012 SouthEast LinuxFest - Bruce Momjian - MVCC Unmasked
Publication date: 2014-01-03
Playlist: 2012 SouthEast LinuxFest
Description: 
	2012 SouthEast LinuxFest
Bruce Momjian
MVCC Unmasked
Captions: 
	00:00:00,060 --> 00:00:05,279
the following presentation was recorded

00:00:02,100 --> 00:00:07,980
the 2012 southeast Linux Fest in

00:00:05,279 --> 00:00:10,410
Charlotte North Carolina it is licensed

00:00:07,980 --> 00:00:12,090
under a Creative Commons license for

00:00:10,410 --> 00:00:17,609
more information about the south east

00:00:12,090 --> 00:00:19,230
linux fest visit www.ccltss.org the

00:00:17,609 --> 00:00:21,320
south east linux best would like to

00:00:19,230 --> 00:00:23,460
thank the following diamond sponsors in

00:00:21,320 --> 00:00:28,019
2012 for helping make these videos

00:00:23,460 --> 00:00:32,430
possible I'd like to introduce Bruce mom

00:00:28,019 --> 00:00:35,690
John multi-version concurrency control

00:00:32,430 --> 00:00:38,690
and here's the co-founder of the

00:00:35,690 --> 00:00:46,739
PostgreSQL global development group

00:00:38,690 --> 00:00:48,480
everyone welcome Bruce okay thank you if

00:00:46,739 --> 00:00:49,950
you guys want to move ahead if you can't

00:00:48,480 --> 00:00:52,680
sleep feel free I'm not gonna be up on

00:00:49,950 --> 00:00:55,050
the podium I'm gonna be down here and

00:00:52,680 --> 00:00:59,039
the reason is because if I'm up on the

00:00:55,050 --> 00:01:00,690
podium I can't point the slides and I

00:00:59,039 --> 00:01:02,070
cannot give this presentation without

00:01:00,690 --> 00:01:04,890
pointing at the slides because it will

00:01:02,070 --> 00:01:07,320
be just impossible to understand I'm

00:01:04,890 --> 00:01:09,030
afraid so feel free to move up if you

00:01:07,320 --> 00:01:11,070
need to you don't have to but anyway I

00:01:09,030 --> 00:01:15,380
can't stand up there because of the way

00:01:11,070 --> 00:01:18,509
that this slide thing is so forward the

00:01:15,380 --> 00:01:21,630
all right so yeah my name's Bruce mom

00:01:18,509 --> 00:01:23,280
Jen I worked for enterprise DB one of

00:01:21,630 --> 00:01:26,400
the posters for team members been

00:01:23,280 --> 00:01:29,369
working with Postgres since 1996 I am

00:01:26,400 --> 00:01:31,740
giving this talk obviously right now I

00:01:29,369 --> 00:01:34,710
have a talk tomorrow after the keynote

00:01:31,740 --> 00:01:38,100
11:15 10:15 I believe about home

00:01:34,710 --> 00:01:40,560
automation I'll be giving a talk of some

00:01:38,100 --> 00:01:43,409
unknown nature on Sunday because we have

00:01:40,560 --> 00:01:46,140
a an SQL sort of unconference here at

00:01:43,409 --> 00:01:48,659
the at the same venue at the Blake hotel

00:01:46,140 --> 00:01:51,060
and then on Monday I will actually

00:01:48,659 --> 00:01:53,729
giving a full-day training class in

00:01:51,060 --> 00:01:55,979
Postgres if you look at the bottom of

00:01:53,729 --> 00:01:58,049
your sunday schedule to see a little URL

00:01:55,979 --> 00:02:00,270
that talks about the conference if you

00:01:58,049 --> 00:02:02,909
go to my website there's also a link to

00:02:00,270 --> 00:02:04,590
the training on Monday as well this

00:02:02,909 --> 00:02:07,409
slide deck along with about 30 other

00:02:04,590 --> 00:02:11,069
slide decks are available in PDF format

00:02:07,409 --> 00:02:13,470
at that website that is my home page and

00:02:11,069 --> 00:02:16,050
as my blog has all the conferences I

00:02:13,470 --> 00:02:17,520
and has a you know sort of contact

00:02:16,050 --> 00:02:18,690
information stuff like that

00:02:17,520 --> 00:02:20,430
feel free to look through the

00:02:18,690 --> 00:02:21,900
presentations there's a lot more stuff

00:02:20,430 --> 00:02:24,210
than just this up there obviously

00:02:21,900 --> 00:02:26,850
there's also recordings of a lot of my

00:02:24,210 --> 00:02:28,320
presentations on that website as well so

00:02:26,850 --> 00:02:31,590
it is really kind of a treasure trove of

00:02:28,320 --> 00:02:34,110
information all these presentations are

00:02:31,590 --> 00:02:35,940
Creative Commons Attribution license I

00:02:34,110 --> 00:02:39,030
do have people who do use these

00:02:35,940 --> 00:02:41,370
presentations to give at other

00:02:39,030 --> 00:02:43,740
conferences and for other trainings for

00:02:41,370 --> 00:02:46,050
customers it prevents me from having to

00:02:43,740 --> 00:02:49,140
go to all these places so it does make

00:02:46,050 --> 00:02:51,110
my life a little easier any questions

00:02:49,140 --> 00:02:53,190
before we get started again this is

00:02:51,110 --> 00:02:55,020
somebody asked me how hard is this going

00:02:53,190 --> 00:02:56,760
to be it's not going to be like you have

00:02:55,020 --> 00:02:59,310
to know a huge amount about Postgres but

00:02:56,760 --> 00:03:00,900
you have to be willing to learn about

00:02:59,310 --> 00:03:03,650
Postgres and be willing to kind of

00:03:00,900 --> 00:03:07,650
stretch your mind I gave this talk about

00:03:03,650 --> 00:03:09,840
two years ago in Europe I had to do it

00:03:07,650 --> 00:03:12,390
also in an hour and somebody said it was

00:03:09,840 --> 00:03:13,530
like a wild roller coaster ride so be

00:03:12,390 --> 00:03:16,320
prepared for something that's going to

00:03:13,530 --> 00:03:17,970
be kind of challenging if you're gonna

00:03:16,320 --> 00:03:19,470
have to think about it a lot of people

00:03:17,970 --> 00:03:21,630
have said they've attended the clamp

00:03:19,470 --> 00:03:23,820
this session this presentation multiple

00:03:21,630 --> 00:03:25,830
times they said the second and third

00:03:23,820 --> 00:03:28,050
time kind of really gelled it for them

00:03:25,830 --> 00:03:29,220
so just to give you an idea of what

00:03:28,050 --> 00:03:31,140
we're actually gonna be talking about

00:03:29,220 --> 00:03:33,540
this slide deck is actually a little

00:03:31,140 --> 00:03:35,400
heavy on text I will obviously not be

00:03:33,540 --> 00:03:37,530
reading all the text on these slides but

00:03:35,400 --> 00:03:39,300
the text is there so if at some point

00:03:37,530 --> 00:03:41,100
you want to look at it later you can go

00:03:39,300 --> 00:03:43,640
to that URL look through the slides

00:03:41,100 --> 00:03:45,810
again and kind of refresh yourself I

00:03:43,640 --> 00:03:49,560
will be taking questions during the

00:03:45,810 --> 00:03:51,120
session I do apologize to the person who

00:03:49,560 --> 00:03:52,470
has to move the microphone around to do

00:03:51,120 --> 00:03:54,780
that but I will be repeating your

00:03:52,470 --> 00:03:56,549
question so hopefully we can do a quick

00:03:54,780 --> 00:03:58,350
you know question answer as we go

00:03:56,549 --> 00:04:00,870
because it is yeah very easy to get

00:03:58,350 --> 00:04:02,940
confused with this stuff yes so the

00:04:00,870 --> 00:04:05,910
question no okay

00:04:02,940 --> 00:04:07,739
let's start it off unmasked what does

00:04:05,910 --> 00:04:09,720
unmask mean who are these people I

00:04:07,739 --> 00:04:13,830
actually saw this picture in a

00:04:09,720 --> 00:04:15,360
restaurant today in Charlotte when I

00:04:13,830 --> 00:04:15,900
went out to lunch it was in the men's

00:04:15,360 --> 00:04:20,609
room

00:04:15,900 --> 00:04:22,349
naima hotel of the restaurant it was a

00:04:20,609 --> 00:04:24,400
restaurant in the epicenter if you've

00:04:22,349 --> 00:04:27,430
ever been there

00:04:24,400 --> 00:04:29,979
who are these people why is it important

00:04:27,430 --> 00:04:33,130
what is unmasking me this is one of the

00:04:29,979 --> 00:04:35,229
odd pictures because you know all of

00:04:33,130 --> 00:04:38,229
these actors but you only probably

00:04:35,229 --> 00:04:41,710
recognize three of the faces it turns

00:04:38,229 --> 00:04:45,520
out that they are the original Star Wars

00:04:41,710 --> 00:04:49,180
cast and what's interesting is that they

00:04:45,520 --> 00:04:51,789
all three of the six people were masks

00:04:49,180 --> 00:04:54,280
in the presentation I mean I'm sorry

00:04:51,789 --> 00:04:55,750
we're mists in the in the film so you

00:04:54,280 --> 00:04:58,000
don't recognize them of course

00:04:55,750 --> 00:05:00,009
Chewbacca being the tall one next to him

00:04:58,000 --> 00:05:03,099
Darth Vader and then r2d2 down at the

00:05:00,009 --> 00:05:04,870
bottom there so why is it important to

00:05:03,099 --> 00:05:07,330
understand something that's it's what is

00:05:04,870 --> 00:05:08,590
unmasking mean it basically means that

00:05:07,330 --> 00:05:11,169
you're now seeing something that you

00:05:08,590 --> 00:05:13,720
didn't see before and I think by

00:05:11,169 --> 00:05:15,099
understanding what that unmasking by

00:05:13,720 --> 00:05:16,590
going through that I'm asking process

00:05:15,099 --> 00:05:18,729
you get a deeper understanding of

00:05:16,590 --> 00:05:20,830
exactly how something's made how

00:05:18,729 --> 00:05:24,220
something's done how a movie is made and

00:05:20,830 --> 00:05:25,110
so forth okay so why is it important to

00:05:24,220 --> 00:05:29,409
understand

00:05:25,110 --> 00:05:32,050
nbcc NBCC obviously means multi-version

00:05:29,409 --> 00:05:33,969
concurrency control we say that a

00:05:32,050 --> 00:05:35,979
mouthful a lot when we worked with

00:05:33,969 --> 00:05:37,570
Postgres i'm going to be explaining what

00:05:35,979 --> 00:05:41,199
it is in a minute why is it important to

00:05:37,570 --> 00:05:43,150
understand this MVCC thing it helps you

00:05:41,199 --> 00:05:46,060
to predict query behavior it helps you

00:05:43,150 --> 00:05:48,130
to better manage performance effects and

00:05:46,060 --> 00:05:49,030
it helps you understand per for space

00:05:48,130 --> 00:05:52,599
reuse it

00:05:49,030 --> 00:05:54,759
okay so what are they talking about

00:05:52,599 --> 00:05:57,460
today in the next hour introduction I'm

00:05:54,759 --> 00:05:58,840
gonna talk about what mvcc is again

00:05:57,460 --> 00:06:01,750
that's pretty simplistic then I'm gonna

00:05:58,840 --> 00:06:03,340
talk about the implementation details of

00:06:01,750 --> 00:06:05,590
nbcc and then finally I'm would have

00:06:03,340 --> 00:06:08,770
talked about clean up because there are

00:06:05,590 --> 00:06:13,389
some cleanup aspects of MVCC that do

00:06:08,770 --> 00:06:15,219
affect basically how MVCC works okay so

00:06:13,389 --> 00:06:18,069
let's get started at NBC see what is it

00:06:15,219 --> 00:06:19,860
multi-version concurrency control allows

00:06:18,069 --> 00:06:22,419
post-arrest to offer high concurrency

00:06:19,860 --> 00:06:24,789
even during significant database

00:06:22,419 --> 00:06:28,500
readwrite activity many of you may know

00:06:24,789 --> 00:06:30,789
Postgres has a reputation for being very

00:06:28,500 --> 00:06:32,620
performant when there's a lot of

00:06:30,789 --> 00:06:34,930
concurrent activity going on in the

00:06:32,620 --> 00:06:35,760
system obviously that's one of the very

00:06:34,930 --> 00:06:38,400
important

00:06:35,760 --> 00:06:41,130
specs of database systems these the

00:06:38,400 --> 00:06:42,870
ability to handle high concurrency while

00:06:41,130 --> 00:06:44,760
everyone's sort of running at the same

00:06:42,870 --> 00:06:47,480
records or reading and writing at the

00:06:44,760 --> 00:06:50,730
same time that's really what MVCC does

00:06:47,480 --> 00:06:52,650
probably the big moniker for MVCC is

00:06:50,730 --> 00:06:55,320
that readers never block writers and

00:06:52,650 --> 00:06:57,180
writers never block readers that seems

00:06:55,320 --> 00:06:58,860
impossible but in fact I'm going to

00:06:57,180 --> 00:07:01,890
explain why it is not you know why it is

00:06:58,860 --> 00:07:07,050
possible in Postgres you have to kind of

00:07:01,890 --> 00:07:09,720
leave the traditional locking concussed

00:07:07,050 --> 00:07:12,480
assumptions that you made with older

00:07:09,720 --> 00:07:14,970
systems older database systems pre MVCC

00:07:12,480 --> 00:07:17,010
had one copy of a record if somebody

00:07:14,970 --> 00:07:19,800
changed it nobody could really read it

00:07:17,010 --> 00:07:22,410
while it was being modified that

00:07:19,800 --> 00:07:23,820
assumption is really washed away with NB

00:07:22,410 --> 00:07:26,130
C C and that's really I think the big

00:07:23,820 --> 00:07:28,650
takeaway in terms of understanding why

00:07:26,130 --> 00:07:32,460
Postgres does so well in a multi

00:07:28,650 --> 00:07:36,120
concurrency environment okay what

00:07:32,460 --> 00:07:39,270
database system support nbcc Postgres of

00:07:36,120 --> 00:07:42,390
course Oracle does db2 has a partial

00:07:39,270 --> 00:07:45,350
implementation in a DB part of my sequel

00:07:42,390 --> 00:07:49,110
also does and forwards in Firebird does

00:07:45,350 --> 00:07:50,940
Microsoft not so much it's an option so

00:07:49,110 --> 00:07:55,770
again kind of a there is this is

00:07:50,940 --> 00:07:57,690
actually a very common now internal

00:07:55,770 --> 00:07:59,340
capability of databases wasn't common

00:07:57,690 --> 00:08:01,620
obviously in the 90s when I started with

00:07:59,340 --> 00:08:03,390
databases but in the past five ten years

00:08:01,620 --> 00:08:05,430
it's really kind of taken the system by

00:08:03,390 --> 00:08:06,990
storm and I today I'm going to be

00:08:05,430 --> 00:08:10,200
talking about how Postgres actually

00:08:06,990 --> 00:08:14,670
implements that okay any questions

00:08:10,200 --> 00:08:16,740
before we move on great okay this is I

00:08:14,670 --> 00:08:21,080
think one of the key slides of the whole

00:08:16,740 --> 00:08:24,630
presentation what it's showing you is

00:08:21,080 --> 00:08:28,050
the internal representation of MVCC for

00:08:24,630 --> 00:08:31,200
Postgres basically you see three types

00:08:28,050 --> 00:08:34,979
of commands there insert delete and

00:08:31,200 --> 00:08:39,180
update I have actually put them in that

00:08:34,979 --> 00:08:42,120
order for a reason okay let's look at

00:08:39,180 --> 00:08:44,040
insert insert basically obviously adds

00:08:42,120 --> 00:08:45,870
the rotor the database you'll notice

00:08:44,040 --> 00:08:49,050
that there are actually two internal

00:08:45,870 --> 00:08:51,120
fields inside the row that we've

00:08:49,050 --> 00:08:55,110
that pink block basically represents a

00:08:51,120 --> 00:08:57,570
new Row one is the creation transaction

00:08:55,110 --> 00:09:01,320
ID in this case transaction 40 has

00:08:57,570 --> 00:09:03,120
created this row and then we this were

00:09:01,320 --> 00:09:05,420
always not been expired yet so it's an

00:09:03,120 --> 00:09:09,269
active row basically so that's an insert

00:09:05,420 --> 00:09:10,970
the lien is similar basically has the

00:09:09,269 --> 00:09:13,920
same pattern you have a creation

00:09:10,970 --> 00:09:16,529
transaction ID but effectively deleting

00:09:13,920 --> 00:09:19,320
a row merely means that you put a

00:09:16,529 --> 00:09:23,130
transaction ID into that expired field

00:09:19,320 --> 00:09:24,810
all right so again when you think of

00:09:23,130 --> 00:09:27,390
somebody sort of deleting a row or

00:09:24,810 --> 00:09:29,640
racing it from the system doesn't really

00:09:27,390 --> 00:09:31,380
work that way so much at MVCC you

00:09:29,640 --> 00:09:34,230
basically market is to leave it and then

00:09:31,380 --> 00:09:35,790
you move on and then later on post chris

00:09:34,230 --> 00:09:38,459
is going to come and clean that up

00:09:35,790 --> 00:09:42,360
but that row has to remain around so

00:09:38,459 --> 00:09:43,890
that we can we can honor the promise

00:09:42,360 --> 00:09:45,450
that we've made that readers don't block

00:09:43,890 --> 00:09:47,250
writers and writers don't block readers

00:09:45,450 --> 00:09:50,700
and I'm going to show actually how that

00:09:47,250 --> 00:09:53,579
works in this particular case okay third

00:09:50,700 --> 00:09:57,060
example is really a combination the

00:09:53,579 --> 00:09:59,610
update case is basically an insert I'm

00:09:57,060 --> 00:10:01,950
sorry a delete followed by an insert and

00:09:59,610 --> 00:10:02,700
you can see I've actually even marked

00:10:01,950 --> 00:10:05,250
them that way

00:10:02,700 --> 00:10:07,500
so when you update a row in an MVC

00:10:05,250 --> 00:10:09,390
system at least in a Postgres MVCC

00:10:07,500 --> 00:10:11,490
system what you're doing is you're

00:10:09,390 --> 00:10:13,560
deleting the old version of the row and

00:10:11,490 --> 00:10:15,390
you're creating a new version of the

00:10:13,560 --> 00:10:21,839
read hence the name multi-version

00:10:15,390 --> 00:10:23,339
concurrency control yes sir so the

00:10:21,839 --> 00:10:26,010
question is is the new row creative

00:10:23,339 --> 00:10:28,620
right next to the old one Postgres will

00:10:26,010 --> 00:10:31,410
try and create the new row in the same

00:10:28,620 --> 00:10:33,810
page as the old row there are some

00:10:31,410 --> 00:10:36,449
optimizations that we can do if the new

00:10:33,810 --> 00:10:38,760
and old row exists in the same page if

00:10:36,449 --> 00:10:41,070
we cannot fit in the same page we will

00:10:38,760 --> 00:10:42,180
spill over to another page we will lose

00:10:41,070 --> 00:10:43,500
the ability to do some of the

00:10:42,180 --> 00:10:47,040
optimizations but we will continue

00:10:43,500 --> 00:10:51,060
running just fine okay good question

00:10:47,040 --> 00:10:53,070
so basically we can replay this in a in

00:10:51,060 --> 00:10:55,980
an update case we're deleting this

00:10:53,070 --> 00:10:58,860
version of the row with 78 and then

00:10:55,980 --> 00:11:01,050
we're creating a new row also with

00:10:58,860 --> 00:11:02,820
transaction 78 but this time the the

00:11:01,050 --> 00:11:04,140
transaction number is the creation

00:11:02,820 --> 00:11:08,190
the fact that these two numbers are the

00:11:04,140 --> 00:11:10,410
same is is recalled a requirement of an

00:11:08,190 --> 00:11:13,500
MVC C system because we've basically

00:11:10,410 --> 00:11:15,120
added this we've expired with one

00:11:13,500 --> 00:11:17,280
transaction then created in with another

00:11:15,120 --> 00:11:19,050
transaction okay that kind of links them

00:11:17,280 --> 00:11:22,350
together in terms of that's an update to

00:11:19,050 --> 00:11:24,060
the Postgres alright I'm going to show

00:11:22,350 --> 00:11:28,440
you some specific examples obviously

00:11:24,060 --> 00:11:30,240
this is just a diagram all right another

00:11:28,440 --> 00:11:33,230
term and I'm not gonna read all this

00:11:30,240 --> 00:11:35,310
text is the idea of an MVC see snapshot

00:11:33,230 --> 00:11:37,710
I'm not sure how many of you have heard

00:11:35,310 --> 00:11:40,050
the term snapshot before we use it all

00:11:37,710 --> 00:11:44,070
the time in Postgres actually it

00:11:40,050 --> 00:11:46,710
basically represents a view a set of

00:11:44,070 --> 00:11:49,650
rules that define your view of the

00:11:46,710 --> 00:11:51,510
database so if I'm in a specific session

00:11:49,650 --> 00:11:56,220
and I have a snapshot that I'm working

00:11:51,510 --> 00:11:57,960
with that defines what rows I can see in

00:11:56,220 --> 00:12:00,210
that snapshot if somebody else is

00:11:57,960 --> 00:12:01,770
running a different snapshot they might

00:12:00,210 --> 00:12:03,750
they have looking at the same database

00:12:01,770 --> 00:12:06,540
but they get a different view perhaps of

00:12:03,750 --> 00:12:09,990
the data than I would that's what they

00:12:06,540 --> 00:12:11,280
we mean by the term snapshot again not

00:12:09,990 --> 00:12:14,220
very relevant

00:12:11,280 --> 00:12:15,750
prior to MVC see because it per for MBC

00:12:14,220 --> 00:12:18,000
see there was no really concept of

00:12:15,750 --> 00:12:21,030
snapshot there at least not the same

00:12:18,000 --> 00:12:22,890
power that we have now this snapshot

00:12:21,030 --> 00:12:25,710
idea basically gives you the ability

00:12:22,890 --> 00:12:27,840
gives different people idea ability to

00:12:25,710 --> 00:12:30,060
see different things at the same time in

00:12:27,840 --> 00:12:32,910
the same database and that's part of the

00:12:30,060 --> 00:12:36,480
way again that nbcc system works one

00:12:32,910 --> 00:12:39,180
example that might be practical how many

00:12:36,480 --> 00:12:41,220
of you have heard of serializable

00:12:39,180 --> 00:12:46,260
isolation level or transaction isolation

00:12:41,220 --> 00:12:48,810
levels okay when you are to running in

00:12:46,260 --> 00:12:50,730
the default transaction isolation level

00:12:48,810 --> 00:12:53,220
for Postgres is recommitted you're

00:12:50,730 --> 00:12:55,050
getting a new snapshot every time you

00:12:53,220 --> 00:12:58,010
run a new statement and a multi

00:12:55,050 --> 00:13:00,690
statement transaction if you're running

00:12:58,010 --> 00:13:04,290
serializable mode which actually is a

00:13:00,690 --> 00:13:06,510
more powerful way of doing transactions

00:13:04,290 --> 00:13:09,210
you actually you actually keep the same

00:13:06,510 --> 00:13:11,640
snapshot through your entire multi

00:13:09,210 --> 00:13:12,960
statement transaction okay and what that

00:13:11,640 --> 00:13:13,710
effectively means is you don't see any

00:13:12,960 --> 00:13:15,570
changes

00:13:13,710 --> 00:13:17,580
the database look static to you as

00:13:15,570 --> 00:13:19,589
you're running through this Multi

00:13:17,580 --> 00:13:21,390
statement transaction again that's not

00:13:19,589 --> 00:13:23,760
the default mode for some reasons I

00:13:21,390 --> 00:13:26,640
won't go into but again it is of

00:13:23,760 --> 00:13:28,410
user-visible kind of concept that if

00:13:26,640 --> 00:13:30,660
you've ever seen serializable or

00:13:28,410 --> 00:13:32,490
understand what it means to take a new

00:13:30,660 --> 00:13:34,440
snapshot every time you get a new

00:13:32,490 --> 00:13:36,480
command that's effectively what you're

00:13:34,440 --> 00:13:38,670
doing here and when you take that new

00:13:36,480 --> 00:13:40,440
snapshot you basically are seeing new

00:13:38,670 --> 00:13:42,600
committed transactions that happened

00:13:40,440 --> 00:13:43,620
while one of your statements was running

00:13:42,600 --> 00:13:46,920
even though you're in a larger

00:13:43,620 --> 00:13:49,440
transaction again not really germane

00:13:46,920 --> 00:13:51,209
doing this but it's kind of a concrete

00:13:49,440 --> 00:13:54,060
example I think people have seen before

00:13:51,209 --> 00:13:57,390
if you've ever dealt with this before

00:13:54,060 --> 00:13:59,580
so um honestly this is kind of the key I

00:13:57,390 --> 00:14:02,640
think and understanding a lot of this

00:13:59,580 --> 00:14:04,470
snapshot information what I basically

00:14:02,640 --> 00:14:07,709
produced here and I'm sorry the colors

00:14:04,470 --> 00:14:09,149
are a little weak I I did my best but

00:14:07,709 --> 00:14:10,770
the projector is a little a little

00:14:09,149 --> 00:14:12,630
finicky but I think you can kind of see

00:14:10,770 --> 00:14:15,300
it you notice that these are bold right

00:14:12,630 --> 00:14:17,220
here okay and these are much lighter can

00:14:15,300 --> 00:14:20,310
you see that so they're different colors

00:14:17,220 --> 00:14:22,140
okay and what I'm showing you here is

00:14:20,310 --> 00:14:26,850
really I think the fundamentals of the

00:14:22,140 --> 00:14:30,060
MVCC system the idea is that we have six

00:14:26,850 --> 00:14:31,980
individual data rows in the system but

00:14:30,060 --> 00:14:34,850
you will notice that some of them are

00:14:31,980 --> 00:14:39,060
visible and some of them are invisible

00:14:34,850 --> 00:14:42,779
depending upon our snapshot that we have

00:14:39,060 --> 00:14:44,490
for this particular session okay and I'm

00:14:42,779 --> 00:14:48,420
gonna walk through this with you real

00:14:44,490 --> 00:14:52,010
fast effectively our snapshot here is

00:14:48,420 --> 00:14:54,750
defined as 100 being the highest

00:14:52,010 --> 00:14:56,850
committed transaction so when we started

00:14:54,750 --> 00:14:58,829
our session 100 was the highest

00:14:56,850 --> 00:15:01,230
committed transaction and then we have

00:14:58,829 --> 00:15:03,720
transactions 25 50 and 75 which are

00:15:01,230 --> 00:15:06,089
basically open transactions meaning

00:15:03,720 --> 00:15:08,190
they're in process so at the time we

00:15:06,089 --> 00:15:10,500
take our snapshot which is which is

00:15:08,190 --> 00:15:14,040
basically at the time we start our

00:15:10,500 --> 00:15:17,130
statement we have highest transaction

00:15:14,040 --> 00:15:19,740
number 125 50 and 75 are currently

00:15:17,130 --> 00:15:20,850
executing okay so if we - and we assume

00:15:19,740 --> 00:15:22,190
everything else is committed so let's

00:15:20,850 --> 00:15:23,390
actually walk through this

00:15:22,190 --> 00:15:24,710
and if you can kind of pull that

00:15:23,390 --> 00:15:26,060
together I think we'll be in good shape

00:15:24,710 --> 00:15:28,310
so let's take a look at the first one

00:15:26,060 --> 00:15:30,110
the first one says I've been created by

00:15:28,310 --> 00:15:33,040
transaction 30 I have not been expired

00:15:30,110 --> 00:15:36,170
and that's a fairly easy one because

00:15:33,040 --> 00:15:38,510
transaction 30 is certainly a lot

00:15:36,170 --> 00:15:40,760
smaller than a hundred which means it

00:15:38,510 --> 00:15:42,800
was it was in the past it was before a

00:15:40,760 --> 00:15:45,260
hundred because it's 30 it's less right

00:15:42,800 --> 00:15:47,440
and also um it's not one of these

00:15:45,260 --> 00:15:49,160
running transactions so it's done and

00:15:47,440 --> 00:15:50,870
again we assumed everything was

00:15:49,160 --> 00:15:53,270
committed so it's a simple case its

00:15:50,870 --> 00:15:54,350
visible we could see that row the next

00:15:53,270 --> 00:15:57,770
one's a little different

00:15:54,350 --> 00:16:00,140
this one's created by transaction 50 now

00:15:57,770 --> 00:16:01,810
50 is less than 100 so we're good there

00:16:00,140 --> 00:16:05,480
but 50 is one of those running

00:16:01,810 --> 00:16:07,730
transactions that is still going at the

00:16:05,480 --> 00:16:09,620
time we took our snapshot now even if it

00:16:07,730 --> 00:16:12,200
commits later it doesn't matter because

00:16:09,620 --> 00:16:15,050
we have to give the user consistent view

00:16:12,200 --> 00:16:17,720
and therefore we take the two we take

00:16:15,050 --> 00:16:19,280
the snapshot at the time we start our

00:16:17,720 --> 00:16:22,190
statement and we never change it as we

00:16:19,280 --> 00:16:24,380
go okay so in this case this row is not

00:16:22,190 --> 00:16:27,830
visible because he didn't commit at the

00:16:24,380 --> 00:16:31,070
time we took our snapshot all right this

00:16:27,830 --> 00:16:33,880
third one 110 that one's not visible

00:16:31,070 --> 00:16:37,930
because it's it's higher than 100

00:16:33,880 --> 00:16:40,490
meaning it had it started after my

00:16:37,930 --> 00:16:42,560
transaction started it started after my

00:16:40,490 --> 00:16:43,820
snapshot so therefore I certainly can't

00:16:42,560 --> 00:16:44,930
see it because this is something to

00:16:43,820 --> 00:16:46,970
happen in the future

00:16:44,930 --> 00:16:48,890
relative to the time it took my snapshot

00:16:46,970 --> 00:16:51,590
again we don't guarantee we're gonna

00:16:48,890 --> 00:16:53,600
you're gonna get up-to-date information

00:16:51,590 --> 00:16:55,220
opposed to course we give you consistent

00:16:53,600 --> 00:16:58,010
information we give you information

00:16:55,220 --> 00:16:59,720
that's consistent at a point in time if

00:16:58,010 --> 00:17:01,910
somebody's changing the database wall

00:16:59,720 --> 00:17:03,080
your statements running you don't want

00:17:01,910 --> 00:17:05,630
it believe me you don't want to see

00:17:03,080 --> 00:17:07,189
those changes it would be something

00:17:05,630 --> 00:17:09,650
called a dirty read or so if you

00:17:07,189 --> 00:17:11,540
familiar with those things they will

00:17:09,650 --> 00:17:14,120
offer it what that will cause you havoc

00:17:11,540 --> 00:17:16,189
if you actually saw those things going

00:17:14,120 --> 00:17:18,579
on while you were trying to sum up

00:17:16,189 --> 00:17:21,290
something or lock something or whatever

00:17:18,579 --> 00:17:23,000
again there are some some some

00:17:21,290 --> 00:17:25,040
sophisticated things we do if you were

00:17:23,000 --> 00:17:26,990
trying to update that row but again in

00:17:25,040 --> 00:17:27,949
general you want to see a consistent

00:17:26,990 --> 00:17:30,470
view and that's what that snapshot

00:17:27,949 --> 00:17:31,880
system does now looking down here you'll

00:17:30,470 --> 00:17:35,670
notice the differences these all have

00:17:31,880 --> 00:17:38,310
expire values okay so if we look at this

00:17:35,670 --> 00:17:41,430
again create it with transaction 30

00:17:38,310 --> 00:17:43,440
which is good but it also is expired by

00:17:41,430 --> 00:17:46,620
transaction 80 and that's also good

00:17:43,440 --> 00:17:48,090
we're bad meaning that it's expired we

00:17:46,620 --> 00:17:50,790
can't see that row because it's been

00:17:48,090 --> 00:17:54,440
deleted by US corn Doris snapshot that

00:17:50,790 --> 00:17:56,910
Rose delete it if you can't see it okay

00:17:54,440 --> 00:17:59,340
on the flip side this one has been

00:17:56,910 --> 00:18:01,440
created by the same transaction expired

00:17:59,340 --> 00:18:04,770
to write transaction 75 but transaction

00:18:01,440 --> 00:18:06,690
75 isn't done it was running at the time

00:18:04,770 --> 00:18:10,310
we took our snapshot therefore the

00:18:06,690 --> 00:18:14,520
delete doesn't really apply there for

00:18:10,310 --> 00:18:17,820
this row I can see same thing down here

00:18:14,520 --> 00:18:19,380
110 deleted by a future transaction a

00:18:17,820 --> 00:18:21,930
transaction that started after it took

00:18:19,380 --> 00:18:24,510
my snapshot again I can't see I can't

00:18:21,930 --> 00:18:26,580
see that delete therefore I can see the

00:18:24,510 --> 00:18:37,890
answer and therefore that rose visible

00:18:26,580 --> 00:18:39,420
to me any questions yes so the question

00:18:37,890 --> 00:18:41,220
is when did the expire ones get cleaned

00:18:39,420 --> 00:18:43,490
up the third part of the session

00:18:41,220 --> 00:18:46,530
actually talks about the cleanup process

00:18:43,490 --> 00:18:48,150
there's there's basically a couple of

00:18:46,530 --> 00:18:51,240
fundamental ways that these rows get

00:18:48,150 --> 00:18:52,410
cleaned up and the the the major aspect

00:18:51,240 --> 00:18:54,360
is that they don't clean it cleaned up

00:18:52,410 --> 00:18:56,760
at the leat time to get cleaned up when

00:18:54,360 --> 00:18:58,860
no one else cares about them and that's

00:18:56,760 --> 00:19:01,200
really one of the NBCC kind of things

00:18:58,860 --> 00:19:04,370
that we do for the user we kind of keep

00:19:01,200 --> 00:19:07,740
around some old data to allow existing

00:19:04,370 --> 00:19:14,480
snapshots to all have a consistent view

00:19:07,740 --> 00:19:17,910
of the database other questions okay so

00:19:14,480 --> 00:19:21,150
confused yet yes probably this is

00:19:17,910 --> 00:19:23,220
actually a source code comment from one

00:19:21,150 --> 00:19:27,090
of the Berkeley developers it actually

00:19:23,220 --> 00:19:29,310
happens to be my Colson who was the one

00:19:27,090 --> 00:19:33,600
of the guys from Berkeley DB if you ever

00:19:29,310 --> 00:19:35,790
met him and he this is actually a

00:19:33,600 --> 00:19:38,070
comment explaining how the system works

00:19:35,790 --> 00:19:39,390
any basic says to test this routine are

00:19:38,070 --> 00:19:41,460
correct if you think they're not you're

00:19:39,390 --> 00:19:44,340
wrong and should think about it again I

00:19:41,460 --> 00:19:47,100
know it happened to me so so there is a

00:19:44,340 --> 00:19:47,700
quite a bit of sort of mind stretching

00:19:47,100 --> 00:19:50,100
you have

00:19:47,700 --> 00:19:53,700
do to really think about this and kind

00:19:50,100 --> 00:19:55,860
of kind of get in your head what's going

00:19:53,700 --> 00:20:00,240
on I can I can't see that I can see it

00:19:55,860 --> 00:20:01,799
it is really complicated okay so let's

00:20:00,240 --> 00:20:03,179
talk about implementation details we're

00:20:01,799 --> 00:20:05,250
now in the second part we're done with

00:20:03,179 --> 00:20:07,500
the introduction what I'm actually gonna

00:20:05,250 --> 00:20:10,769
show you is effectively I want to show

00:20:07,500 --> 00:20:12,299
you the system running I'm gonna show

00:20:10,769 --> 00:20:12,590
you running queries and I'm gonna show

00:20:12,299 --> 00:20:15,539
you

00:20:12,590 --> 00:20:17,429
MVCC as it actually looks in Postgres is

00:20:15,539 --> 00:20:19,409
and this is using an unmodified version

00:20:17,429 --> 00:20:22,320
of Postgres I did install one or two

00:20:19,409 --> 00:20:25,710
little contribs but in general this is

00:20:22,320 --> 00:20:28,230
all stock Postgres basically I create a

00:20:25,710 --> 00:20:30,539
little a little demo table that we're

00:20:28,230 --> 00:20:33,539
gonna use for this session and I also

00:20:30,539 --> 00:20:35,820
create a special view that again relies

00:20:33,539 --> 00:20:38,700
on one of those contribs we'll see this

00:20:35,820 --> 00:20:42,570
used a little later I make sure this is

00:20:38,700 --> 00:20:45,090
stock Postgres that URL basically has

00:20:42,570 --> 00:20:46,889
the SQL code that I'm gonna be running

00:20:45,090 --> 00:20:50,190
for this session so if you ever want to

00:20:46,889 --> 00:20:52,500
run and see this presentation live you

00:20:50,190 --> 00:20:54,659
download the SQL file you install page

00:20:52,500 --> 00:20:56,159
inspect you run it and it will basically

00:20:54,659 --> 00:20:59,309
see it in fact when I wrote this

00:20:56,159 --> 00:21:00,539
presentation I wrote the SQL this is I

00:20:59,309 --> 00:21:03,210
have a couple presentation where I

00:21:00,539 --> 00:21:05,279
basically write the SQL I run it I

00:21:03,210 --> 00:21:07,850
capture it I put it into an editor and

00:21:05,279 --> 00:21:10,649
then I write a presentation around that

00:21:07,850 --> 00:21:13,080
saves me a lot of typing make sure it

00:21:10,649 --> 00:21:15,600
all works but again it gives it a sort

00:21:13,080 --> 00:21:17,789
of a grounding so that we're you know

00:21:15,600 --> 00:21:19,200
I'm actually showing you I'm not making

00:21:17,789 --> 00:21:20,610
anything up this is exactly what it

00:21:19,200 --> 00:21:23,250
would look like

00:21:20,610 --> 00:21:25,769
second thing procedural I there is a lot

00:21:23,250 --> 00:21:27,480
of text on this screen I've highlighted

00:21:25,769 --> 00:21:28,740
a bunch of stuff in red so if you're

00:21:27,480 --> 00:21:30,539
looking at a present hey if you're

00:21:28,740 --> 00:21:32,309
looking at it query you're like what

00:21:30,539 --> 00:21:34,590
should I be looking at look at the red

00:21:32,309 --> 00:21:37,460
right that's really where you want to

00:21:34,590 --> 00:21:39,960
look because it's actually showing you

00:21:37,460 --> 00:21:42,590
the important part of that particular

00:21:39,960 --> 00:21:46,769
query in this case the red area actually

00:21:42,590 --> 00:21:48,450
represents a creation transaction ID

00:21:46,769 --> 00:21:50,370
remember I mentioned there was creation

00:21:48,450 --> 00:21:52,500
and expire we you know we don't call

00:21:50,370 --> 00:21:56,460
creation expire in Postgres we call them

00:21:52,500 --> 00:21:58,440
X min x max I don't know why they call

00:21:56,460 --> 00:22:00,050
them that I guess I kind of know why

00:21:58,440 --> 00:22:02,300
it's trained X means

00:22:00,050 --> 00:22:04,730
transaction I don't know why X and trans

00:22:02,300 --> 00:22:07,280
go together but they always do and then

00:22:04,730 --> 00:22:09,740
the X min is the minimum crea minimum is

00:22:07,280 --> 00:22:13,460
creation and for some reason max is

00:22:09,740 --> 00:22:14,660
expire to them so effectively what I do

00:22:13,460 --> 00:22:18,020
is I delete all the rows in the table

00:22:14,660 --> 00:22:20,870
I'm certain one row and I select two

00:22:18,020 --> 00:22:24,440
fields that are in every day every row

00:22:20,870 --> 00:22:26,750
but you don't normally see them if you

00:22:24,440 --> 00:22:29,000
try and create an X min or x max column

00:22:26,750 --> 00:22:30,380
in your table you'll get an error and if

00:22:29,000 --> 00:22:33,080
you get in there is because these

00:22:30,380 --> 00:22:35,600
invisible tape columns are in every row

00:22:33,080 --> 00:22:38,480
and these invisible columns basically

00:22:35,600 --> 00:22:41,090
represent these fields right here so

00:22:38,480 --> 00:22:44,390
this is X min this is X Max this is X

00:22:41,090 --> 00:22:46,820
min this is x max okay they just kind of

00:22:44,390 --> 00:22:48,380
make that transition there so what we're

00:22:46,820 --> 00:22:49,790
doing is we're basically inserting a row

00:22:48,380 --> 00:22:52,010
and then we're looking at the row which

00:22:49,790 --> 00:22:53,530
happens to be a1 it's the same value but

00:22:52,010 --> 00:22:55,460
we're now looking at the creation

00:22:53,530 --> 00:22:59,060
transaction ID for that row which

00:22:55,460 --> 00:23:02,030
happens to be 54 or not okay so so far

00:22:59,060 --> 00:23:06,830
I'm not making it up that's indicating

00:23:02,030 --> 00:23:08,990
who created that row all right what if I

00:23:06,830 --> 00:23:11,630
do a delete well LK I'm gonna insert a

00:23:08,990 --> 00:23:12,950
row and I'm going to actually do a

00:23:11,630 --> 00:23:15,710
select and I'm going to see the

00:23:12,950 --> 00:23:17,360
transaction creation right here then I'm

00:23:15,710 --> 00:23:18,710
gonna start what we call a multi

00:23:17,360 --> 00:23:20,690
statement transaction I'm going to

00:23:18,710 --> 00:23:22,670
delete the row and then from another

00:23:20,690 --> 00:23:25,220
session you know how this is sort of

00:23:22,670 --> 00:23:28,010
indented so I basically indented this

00:23:25,220 --> 00:23:30,560
little section here okay and I'm running

00:23:28,010 --> 00:23:32,660
this in another another session and I'm

00:23:30,560 --> 00:23:34,390
actually doing the Select now if I do

00:23:32,660 --> 00:23:38,690
the Select in the same session

00:23:34,390 --> 00:23:42,340
there's no lo cuz I deleted it my

00:23:38,690 --> 00:23:46,340
snapshot says I can't see that row

00:23:42,340 --> 00:23:48,470
alright my snapshots in my current

00:23:46,340 --> 00:23:50,450
session says I can't see that row

00:23:48,470 --> 00:23:53,090
because I deleted it in my own session

00:23:50,450 --> 00:23:54,620
however if I just sort a new session and

00:23:53,090 --> 00:23:57,170
I run a query and again I remember I

00:23:54,620 --> 00:23:58,970
talked about the fact that with NBC see

00:23:57,170 --> 00:24:01,880
different snapshots show different

00:23:58,970 --> 00:24:03,050
values or different give a different

00:24:01,880 --> 00:24:06,620
view of the database depending on your

00:24:03,050 --> 00:24:09,400
snapshot in this case this tree this

00:24:06,620 --> 00:24:12,500
outer transaction has not committed yet

00:24:09,400 --> 00:24:14,390
to this running session

00:24:12,500 --> 00:24:19,100
remember I told you that remember this

00:24:14,390 --> 00:24:20,659
example here where we had 110 and this

00:24:19,100 --> 00:24:22,340
this actually was visible because this

00:24:20,659 --> 00:24:23,929
was this was not committed yet or

00:24:22,340 --> 00:24:25,909
actually was this one I think which

00:24:23,929 --> 00:24:27,559
isn't committed still running so we

00:24:25,909 --> 00:24:28,460
don't honor the delete well it's the

00:24:27,559 --> 00:24:31,580
same thing here

00:24:28,460 --> 00:24:33,710
we're basically haven't deleted it yet

00:24:31,580 --> 00:24:36,080
so this row is still here's my creation

00:24:33,710 --> 00:24:38,900
here's my delete and then actually I can

00:24:36,080 --> 00:24:41,030
confirm if I run this statement that in

00:24:38,900 --> 00:24:44,330
fact the transaction ID for this outer

00:24:41,030 --> 00:24:47,090
transaction is indeed 550 for 12 okay

00:24:44,330 --> 00:24:48,950
once I commit the transaction then

00:24:47,090 --> 00:24:50,600
there's actually no well anymore and it

00:24:48,950 --> 00:24:52,400
goes away and everyone sees it as

00:24:50,600 --> 00:24:54,140
deleted okay

00:24:52,400 --> 00:24:57,140
but again while it's running other

00:24:54,140 --> 00:25:05,720
sessions wouldn't see the delete yet how

00:24:57,140 --> 00:25:07,220
does it I'm sorry so the question is is

00:25:05,720 --> 00:25:10,640
there any ever cases where it's about

00:25:07,220 --> 00:25:15,530
useful to use the xmin xmax when you're

00:25:10,640 --> 00:25:21,500
working with a database I would probably

00:25:15,530 --> 00:25:25,419
say no i don't i have not there really

00:25:21,500 --> 00:25:27,919
is no functionality that would be

00:25:25,419 --> 00:25:29,990
available by doing it that you couldn't

00:25:27,919 --> 00:25:31,940
do in a more skew all standard way

00:25:29,990 --> 00:25:37,700
wouldn't be my answer yeah i've never

00:25:31,940 --> 00:25:40,549
heard of one so let's take a look at

00:25:37,700 --> 00:25:42,740
update now remember i said i mentioned

00:25:40,549 --> 00:25:45,710
that update is a delete followed by an

00:25:42,740 --> 00:25:48,590
insert remember that so if I look at

00:25:45,710 --> 00:25:50,630
update I basically insert a row

00:25:48,590 --> 00:25:52,940
there's the row right there I begin a

00:25:50,630 --> 00:25:56,390
multi statement transaction I then

00:25:52,940 --> 00:25:58,429
update the row from one to two okay and

00:25:56,390 --> 00:26:02,630
if I look at my current session I see

00:25:58,429 --> 00:26:06,169
two but if I look in another session

00:26:02,630 --> 00:26:07,789
running at the same time I see a 1 and

00:26:06,169 --> 00:26:10,250
again this is a classic example of

00:26:07,789 --> 00:26:11,630
snapshot showing different values for

00:26:10,250 --> 00:26:14,450
the same database from different

00:26:11,630 --> 00:26:17,179
sessions here you can see here's the

00:26:14,450 --> 00:26:20,330
creation here's the expire and here's

00:26:17,179 --> 00:26:21,789
the same transaction ID again being used

00:26:20,330 --> 00:26:24,610
for the creation

00:26:21,789 --> 00:26:32,710
exactly what this slide is showing

00:26:24,610 --> 00:26:34,900
right here okay any questions still

00:26:32,710 --> 00:26:38,770
everyone's here that's good okay so what

00:26:34,900 --> 00:26:41,620
if I a board a transaction so insert a

00:26:38,770 --> 00:26:42,280
row begin delete the row and I roll it

00:26:41,620 --> 00:26:44,590
back

00:26:42,280 --> 00:26:47,770
so I've I've committed transaction I

00:26:44,590 --> 00:26:49,990
roll it back what happens to that what

00:26:47,770 --> 00:26:51,549
happens to the delete okay because

00:26:49,990 --> 00:26:53,710
remember the insert was committed but

00:26:51,549 --> 00:26:56,080
the lead got rolled back in fact it

00:26:53,710 --> 00:26:59,200
looks like this it turns out that even

00:26:56,080 --> 00:27:04,450
though that xmax is there the system

00:26:59,200 --> 00:27:06,400
actually has a set a file called PG

00:27:04,450 --> 00:27:08,710
underscore C log I don't know how many

00:27:06,400 --> 00:27:12,100
of you seen that before it's in the data

00:27:08,710 --> 00:27:14,770
directory and it contains two bits for

00:27:12,100 --> 00:27:17,020
every transaction and it basically

00:27:14,770 --> 00:27:21,790
represents whether that transaction is

00:27:17,020 --> 00:27:24,580
in progress aborted or committed okay so

00:27:21,790 --> 00:27:29,230
in this case when I rolled back this

00:27:24,580 --> 00:27:33,820
transaction 54 16 was marked with an o1

00:27:29,230 --> 00:27:35,890
and anybody looking at that row will

00:27:33,820 --> 00:27:37,780
look at that number will look at the C

00:27:35,890 --> 00:27:39,340
log will see that that particular

00:27:37,780 --> 00:27:43,330
transaction was not committed but in

00:27:39,340 --> 00:27:44,260
fact aborted and will ignore the xmax in

00:27:43,330 --> 00:27:46,360
that field now there are some

00:27:44,260 --> 00:27:48,880
optimizations that reduce the number of

00:27:46,360 --> 00:27:51,240
C log lookups in the future but in

00:27:48,880 --> 00:27:57,490
general that's how the process works

00:27:51,240 --> 00:27:58,900
okay so that 54 is 16 is never erased we

00:27:57,490 --> 00:28:00,669
don't have to erase it we don't have to

00:27:58,900 --> 00:28:02,410
go back and undo anything when we delete

00:28:00,669 --> 00:28:04,299
anything all we do is just mark is

00:28:02,410 --> 00:28:07,470
deleted in that one those two bits and

00:28:04,299 --> 00:28:07,470
we're done yes sir

00:28:07,710 --> 00:28:13,120
what if two transactions try and delete

00:28:10,210 --> 00:28:14,620
the same row well as I said readers

00:28:13,120 --> 00:28:16,570
never block writers and writers never

00:28:14,620 --> 00:28:19,090
block readers but I didn't say writers

00:28:16,570 --> 00:28:20,559
don't bra block writers so they were

00:28:19,090 --> 00:28:22,570
they're gonna block yeah the first

00:28:20,559 --> 00:28:23,980
person is going to wait for the second

00:28:22,570 --> 00:28:25,630
person to come along and he's going to

00:28:23,980 --> 00:28:27,580
wait to see if that transaction commits

00:28:25,630 --> 00:28:28,660
or aborts and then depending on whether

00:28:27,580 --> 00:28:32,220
the commits are aborts it will then

00:28:28,660 --> 00:28:32,220
continue with this transaction

00:28:39,130 --> 00:28:45,200
so so the question is if you seen xmax

00:28:42,050 --> 00:28:47,990
that's in flight do you stop and wait

00:28:45,200 --> 00:28:50,000
yes you would you would basically you

00:28:47,990 --> 00:28:51,950
would basically look at this if you were

00:28:50,000 --> 00:28:54,610
going to update that row you would look

00:28:51,950 --> 00:28:57,500
here it would show is in progress and

00:28:54,610 --> 00:28:59,720
effectively I have another locking talk

00:28:57,500 --> 00:29:02,570
that I'm obviously not giving here but

00:28:59,720 --> 00:29:04,520
effectively what happens is that the

00:29:02,570 --> 00:29:07,970
session it's waiting for that to

00:29:04,520 --> 00:29:11,630
complete is going to go to sleep on the

00:29:07,970 --> 00:29:13,340
lock that that transaction holds and

00:29:11,630 --> 00:29:16,940
then use that transaction either

00:29:13,340 --> 00:29:19,130
completes or commits or aborts that lock

00:29:16,940 --> 00:29:21,620
on that virtual transaction ID is gonna

00:29:19,130 --> 00:29:23,150
go away and that transaction

00:29:21,620 --> 00:29:26,930
automatically be woken up and it will

00:29:23,150 --> 00:29:29,510
now then recheck the row to see if it

00:29:26,930 --> 00:29:29,830
committed or aborted and then go either

00:29:29,510 --> 00:29:33,530
way

00:29:29,830 --> 00:29:36,100
okay if the system was to crash while

00:29:33,530 --> 00:29:38,780
it's locked the system will come up

00:29:36,100 --> 00:29:42,080
replay the right ahead log will

00:29:38,780 --> 00:29:44,030
basically mark all of this of these

00:29:42,080 --> 00:29:47,390
transactions that were in progress as

00:29:44,030 --> 00:29:49,700
aborted and it's part of the replay and

00:29:47,390 --> 00:29:52,490
then when that position comes along it

00:29:49,700 --> 00:29:54,020
will basically know that this is a board

00:29:52,490 --> 00:29:55,730
of transaction and they just run right

00:29:54,020 --> 00:30:00,140
away because there's nobody holding that

00:29:55,730 --> 00:30:02,900
block anymore as you can see it's quite

00:30:00,140 --> 00:30:07,430
a bit there you know that sort of keeps

00:30:02,900 --> 00:30:09,310
it going we also use this xmax field for

00:30:07,430 --> 00:30:12,050
row box I know that's sort of like

00:30:09,310 --> 00:30:13,970
adding you know piling complexity on

00:30:12,050 --> 00:30:18,020
complexity but we had to do it that way

00:30:13,970 --> 00:30:20,510
so for example if you do a select for

00:30:18,020 --> 00:30:22,160
update related to a little bit related

00:30:20,510 --> 00:30:25,310
to what you talked about select for

00:30:22,160 --> 00:30:28,430
update and I do I actually look at the

00:30:25,310 --> 00:30:30,970
row you can't see anything but if I go

00:30:28,430 --> 00:30:33,260
if I look now after I've done the Select

00:30:30,970 --> 00:30:36,380
it's kind of weird because the Select

00:30:33,260 --> 00:30:40,790
for update doesn't show the xmax but the

00:30:36,380 --> 00:30:42,770
next run of the same select does and I'm

00:30:40,790 --> 00:30:44,410
not sure why I guess it's the way we did

00:30:42,770 --> 00:30:46,060
the logic is we bring

00:30:44,410 --> 00:30:48,010
and then we lock them I guess that's how

00:30:46,060 --> 00:30:51,820
we did it so you can actually see that

00:30:48,010 --> 00:30:55,900
that's a 54:17 that happens to be my

00:30:51,820 --> 00:30:58,990
transaction ID but that's not really an

00:30:55,900 --> 00:31:01,360
expire see that's a little hard there's

00:30:58,990 --> 00:31:03,520
a there's an invisible field that we set

00:31:01,360 --> 00:31:05,260
on the row which says you know you see

00:31:03,520 --> 00:31:08,350
that xmax there that really isn't a

00:31:05,260 --> 00:31:10,300
delete that's really a row lock and

00:31:08,350 --> 00:31:12,220
therefore like you're gonna have to go

00:31:10,300 --> 00:31:14,380
to sleep if you want to change it again

00:31:12,220 --> 00:31:16,480
it was it was done that way because we

00:31:14,380 --> 00:31:18,400
had limited space in the row and it you

00:31:16,480 --> 00:31:22,120
can't lock a row and to lead at the same

00:31:18,400 --> 00:31:24,340
time or not normally anyway so we

00:31:22,120 --> 00:31:28,860
basically sort of overrode that field

00:31:24,340 --> 00:31:31,990
with with with that with that with that

00:31:28,860 --> 00:31:36,370
we overrode the xmax field to allow for

00:31:31,990 --> 00:31:38,890
rowlocks technically exclusive rowlocks

00:31:36,370 --> 00:31:41,080
a share for updater locks for share

00:31:38,890 --> 00:31:44,080
locks actually has their own separate

00:31:41,080 --> 00:31:46,140
table which actually allows us to store

00:31:44,080 --> 00:31:48,400
multiple because you can ship multiple

00:31:46,140 --> 00:31:50,200
transactions can share lock a row and

00:31:48,400 --> 00:31:52,960
you obviously can't shoehorn into one

00:31:50,200 --> 00:31:54,040
field so but that was implemented like

00:31:52,960 --> 00:31:57,160
five years ago

00:31:54,040 --> 00:32:01,530
okay again yeah this is actually the

00:31:57,160 --> 00:32:03,970
internal field that represents the

00:32:01,530 --> 00:32:05,530
that let me throw on the road to say you

00:32:03,970 --> 00:32:09,150
know that xmax it's not really good

00:32:05,530 --> 00:32:12,340
believe so go treat it that way okay

00:32:09,150 --> 00:32:15,010
multi statement transactions I'm gonna

00:32:12,340 --> 00:32:17,320
spend too much time on this but I'm

00:32:15,010 --> 00:32:20,170
gonna kind of give you a flavor of of

00:32:17,320 --> 00:32:22,600
how we handle some of the complexities

00:32:20,170 --> 00:32:24,550
for multi statement transactions we

00:32:22,600 --> 00:32:27,160
basically have two fields called seaman

00:32:24,550 --> 00:32:28,510
and C Max and they allow us to do multi

00:32:27,160 --> 00:32:30,010
statement work and I'm gonna show you

00:32:28,510 --> 00:32:32,680
some examples so here I have an example

00:32:30,010 --> 00:32:36,610
if I insert three rows into the database

00:32:32,680 --> 00:32:39,070
one two three okay if I actually look at

00:32:36,610 --> 00:32:41,950
those rows I look at the seamen field

00:32:39,070 --> 00:32:43,630
you can see that I had no side mill xmax

00:32:41,950 --> 00:32:47,230
I didn't believe it but I have this seam

00:32:43,630 --> 00:32:50,170
in and the seaman allows me to sort of

00:32:47,230 --> 00:32:52,330
separate out the rows that were added by

00:32:50,170 --> 00:32:56,110
one statement in a multi transaction

00:32:52,330 --> 00:32:57,090
from rows added from another back query

00:32:56,110 --> 00:32:59,460
in the same

00:32:57,090 --> 00:33:01,830
the statement transaction why is that

00:32:59,460 --> 00:33:03,540
important well if I have a mobile

00:33:01,830 --> 00:33:07,080
statement transaction and I'm doing

00:33:03,540 --> 00:33:08,940
insert insert insert or I'm doing an

00:33:07,080 --> 00:33:10,680
update let's say so I have anoying

00:33:08,940 --> 00:33:13,170
insert insert and I'm doing an update I

00:33:10,680 --> 00:33:16,110
don't I want to make sure as I process

00:33:13,170 --> 00:33:18,720
those rows that I don't see any of the

00:33:16,110 --> 00:33:20,880
rows that I myself have already updated

00:33:18,720 --> 00:33:22,560
there's some recursion possibilities

00:33:20,880 --> 00:33:24,870
that would really mess you up so

00:33:22,560 --> 00:33:27,120
effectively we have this sort of third

00:33:24,870 --> 00:33:29,610
Field called seaman which allows us to

00:33:27,120 --> 00:33:32,160
kind of identify you know that was done

00:33:29,610 --> 00:33:35,820
by the third in this case it starts at

00:33:32,160 --> 00:33:39,800
zero so the third statement of that

00:33:35,820 --> 00:33:42,450
transaction all right

00:33:39,800 --> 00:33:44,820
same thing if I do deletes insert insert

00:33:42,450 --> 00:33:47,400
insert you can see here's my one two

00:33:44,820 --> 00:33:50,090
three it's a little more tricky I have

00:33:47,400 --> 00:33:53,310
to declare a cursor to make this work

00:33:50,090 --> 00:33:55,710
but effectively if I do a delete on all

00:33:53,310 --> 00:33:59,490
the rows and I look at my cursor I can

00:33:55,710 --> 00:34:03,030
actually see who did the deletes for

00:33:59,490 --> 00:34:05,520
that particular particular case so here

00:34:03,030 --> 00:34:09,300
I'm doing let's see here Oh doing delete

00:34:05,520 --> 00:34:10,950
and yeah this is a little it's a little

00:34:09,300 --> 00:34:13,460
awkward to understand because again I'm

00:34:10,950 --> 00:34:17,250
deleting and inserting in the same

00:34:13,460 --> 00:34:19,800
transaction there actually isn't the

00:34:17,250 --> 00:34:22,680
c-max field that semen and c-max kind of

00:34:19,800 --> 00:34:24,360
combined together so it's really kind of

00:34:22,680 --> 00:34:26,040
awkward but again I'm just giving you a

00:34:24,360 --> 00:34:26,550
highlight of sort of what's going on

00:34:26,040 --> 00:34:28,500
there

00:34:26,550 --> 00:34:32,100
there is another field out there that we

00:34:28,500 --> 00:34:34,770
use updates using c-man here insert one

00:34:32,100 --> 00:34:36,750
two three there's the traditional output

00:34:34,770 --> 00:34:39,990
I declare a cursor so I can see my data

00:34:36,750 --> 00:34:42,240
if ice multiply them all by ten you can

00:34:39,990 --> 00:34:44,670
see I've gone in this current session

00:34:42,240 --> 00:34:48,150
I've done ten twenty thirty and they've

00:34:44,670 --> 00:34:51,210
all been done by the fourth starting at

00:34:48,150 --> 00:34:54,240
zero so the fourth statement of this

00:34:51,210 --> 00:34:57,300
transaction has has basically created

00:34:54,240 --> 00:35:00,030
all these rows and the old rows were

00:34:57,300 --> 00:35:03,000
created by one two and three of that

00:35:00,030 --> 00:35:05,220
transaction you get kind of idea there

00:35:03,000 --> 00:35:07,280
how that how that sort of flag and stuff

00:35:05,220 --> 00:35:09,630
as we go

00:35:07,280 --> 00:35:11,190
modifying those industries actually this

00:35:09,630 --> 00:35:14,190
is just sort of throwing some stuff out

00:35:11,190 --> 00:35:16,830
so if I insert in this transaction and

00:35:14,190 --> 00:35:19,230
then I add three more rows in another

00:35:16,830 --> 00:35:20,730
transaction I actually look you can

00:35:19,230 --> 00:35:22,800
actually see here this is getting a

00:35:20,730 --> 00:35:24,390
little more complicated I'm showing you

00:35:22,800 --> 00:35:26,670
a mix of rows from different

00:35:24,390 --> 00:35:29,010
transactions now okay

00:35:26,670 --> 00:35:32,010
I'm showing you this row which was

00:35:29,010 --> 00:35:33,810
created by five four two four and then

00:35:32,010 --> 00:35:37,770
I'm showing you three more rows which

00:35:33,810 --> 00:35:41,610
created by five four two five and again

00:35:37,770 --> 00:35:44,610
zero one and two or one two three of

00:35:41,610 --> 00:35:46,380
that particular multi statement

00:35:44,610 --> 00:35:49,290
transaction and then if I multiply them

00:35:46,380 --> 00:35:50,880
by ten I can see that we now have ten to

00:35:49,290 --> 00:35:53,730
forty and they've all been done by the

00:35:50,880 --> 00:35:55,620
fourth one and then you can go to

00:35:53,730 --> 00:35:57,690
another session and this is a little

00:35:55,620 --> 00:35:58,560
awkward I only see one row out here and

00:35:57,690 --> 00:36:01,050
why is that

00:35:58,560 --> 00:36:10,200
anyone want to tell me why don't we only

00:36:01,050 --> 00:36:11,730
see one row I'm sorry thank you he what

00:36:10,200 --> 00:36:15,000
he's saying is that I have not committed

00:36:11,730 --> 00:36:19,230
the transaction that inserted two three

00:36:15,000 --> 00:36:23,370
four because that's still running this

00:36:19,230 --> 00:36:25,290
one got committed right completely but

00:36:23,370 --> 00:36:28,220
remember this is only going to see

00:36:25,290 --> 00:36:30,090
committed data and this true outer

00:36:28,220 --> 00:36:32,100
transaction is still the one who

00:36:30,090 --> 00:36:34,590
inserted two three four therefore I

00:36:32,100 --> 00:36:35,940
don't see two three four there again I

00:36:34,590 --> 00:36:37,890
threw this example in there just to

00:36:35,940 --> 00:36:39,960
store to throw your curveball and say

00:36:37,890 --> 00:36:42,030
you know there aren't yeah there's more

00:36:39,960 --> 00:36:44,280
than one transaction at a table usually

00:36:42,030 --> 00:36:48,420
right so you start to see it can get

00:36:44,280 --> 00:36:51,900
pretty complicated the good news is this

00:36:48,420 --> 00:36:54,410
all works you don't think you bug it you

00:36:51,900 --> 00:36:54,410
just use it

00:36:54,980 --> 00:36:58,800
there is something called a combo

00:36:56,910 --> 00:37:01,680
command ID I'm not gonna go over that a

00:36:58,800 --> 00:37:04,860
huge amount effectively there were there

00:37:01,680 --> 00:37:07,200
are cases where if you create and delete

00:37:04,860 --> 00:37:10,220
a row in the same Multi statement

00:37:07,200 --> 00:37:13,350
transaction there's no way to put both

00:37:10,220 --> 00:37:15,600
creation and deletion command counters

00:37:13,350 --> 00:37:17,820
we call them in the same field because

00:37:15,600 --> 00:37:19,950
XC min and C Max are effectively a

00:37:17,820 --> 00:37:23,190
single field on disk even though we call

00:37:19,950 --> 00:37:26,280
them two different names so effectively

00:37:23,190 --> 00:37:27,030
what happens in this case and again

00:37:26,280 --> 00:37:30,620
we're getting a little more

00:37:27,030 --> 00:37:35,070
sophisticated is that I basically have

00:37:30,620 --> 00:37:38,190
in the same transaction okay I basically

00:37:35,070 --> 00:37:40,500
have created three rows but I've also

00:37:38,190 --> 00:37:42,840
deleted them in the same older statement

00:37:40,500 --> 00:37:45,990
transaction and we have a combo command

00:37:42,840 --> 00:37:47,790
ID that we use to basically mult it's

00:37:45,990 --> 00:37:51,540
called multi exact that we actually

00:37:47,790 --> 00:37:54,090
allow us to put two command IDs in the

00:37:51,540 --> 00:37:56,130
same field and again it's one of those

00:37:54,090 --> 00:37:59,160
sort of flags that we throw on the row

00:37:56,130 --> 00:38:01,230
and say hey this is a special phantom ID

00:37:59,160 --> 00:38:06,330
and don't look somewhere else to look it

00:38:01,230 --> 00:38:09,570
up okay so in summary xmin xmax seaman

00:38:06,330 --> 00:38:13,260
c-max x-men creation done by insert

00:38:09,570 --> 00:38:15,990
update x max expire done by update and

00:38:13,260 --> 00:38:18,510
delete and then C min and see max which

00:38:15,990 --> 00:38:21,180
are used mostly for your cases where you

00:38:18,510 --> 00:38:26,540
got you know encounters multi-state new

00:38:21,180 --> 00:38:26,540
transactions any questions yes sir

00:38:27,819 --> 00:38:35,299
so when I talk about a tuple am I

00:38:30,140 --> 00:38:38,900
talking about a row that is a good

00:38:35,299 --> 00:38:43,730
question a tuple is basically a

00:38:38,900 --> 00:38:45,680
relational algebra concept we have a

00:38:43,730 --> 00:38:48,500
tuple in a row or effectively the same

00:38:45,680 --> 00:38:50,839
in common English usage we have a

00:38:48,500 --> 00:38:52,160
tendency to talk about a tuple more when

00:38:50,839 --> 00:38:54,319
we're talking about physical

00:38:52,160 --> 00:38:57,020
representation on disk because for

00:38:54,319 --> 00:38:59,720
example a physical row that a user might

00:38:57,020 --> 00:39:02,930
see might have two tuples or four tuples

00:38:59,720 --> 00:39:04,640
depending on difference thank you

00:39:02,930 --> 00:39:08,030
because of the different states that you

00:39:04,640 --> 00:39:10,150
have that raw may be represented by

00:39:08,030 --> 00:39:13,250
multiple physical tuples on disk and

00:39:10,150 --> 00:39:17,390
different snapshots will see different

00:39:13,250 --> 00:39:21,369
tuples as the same row kind of yeah

00:39:17,390 --> 00:39:21,369
question here yes sir

00:39:24,990 --> 00:39:29,730
okay so why am i using begin work and

00:39:27,550 --> 00:39:32,560
commit work instead of normal begin

00:39:29,730 --> 00:39:34,720
that's actually because begin work I

00:39:32,560 --> 00:39:39,400
believe is more SQL standard than begin

00:39:34,720 --> 00:39:41,170
begin is a Postgres ism in fact I

00:39:39,400 --> 00:39:42,940
believe the way the standard normally

00:39:41,170 --> 00:39:45,730
wants you to do it is to say start

00:39:42,940 --> 00:39:48,400
transaction and commit transaction but

00:39:45,730 --> 00:39:50,560
that's those are really long so I had is

00:39:48,400 --> 00:39:54,070
shortened it a little bit to make say

00:39:50,560 --> 00:39:56,200
begin work and and commit but but yeah

00:39:54,070 --> 00:39:57,250
the SQL standard even wants more verbose

00:39:56,200 --> 00:40:10,660
words in some cases

00:39:57,250 --> 00:40:13,330
oh I've mixed them up oh I'm sorry yes

00:40:10,660 --> 00:40:16,540
this so this is yes just as the delete

00:40:13,330 --> 00:40:19,300
has this output the the begin work has

00:40:16,540 --> 00:40:20,740
begin and it's it's you're right we

00:40:19,300 --> 00:40:23,080
guess we should say begin work but we

00:40:20,740 --> 00:40:24,520
just say begin as an output thank you so

00:40:23,080 --> 00:40:28,710
the question was really yeah the output

00:40:24,520 --> 00:40:28,710
thing is yeah other questions okay

00:40:28,810 --> 00:40:32,800
so now we're gonna get into cleanup

00:40:30,850 --> 00:40:34,390
which was your question right and again

00:40:32,800 --> 00:40:35,970
a little more practical I think for

00:40:34,390 --> 00:40:38,290
people who are using Postgres so

00:40:35,970 --> 00:40:43,210
obviously you've got this case where

00:40:38,290 --> 00:40:45,100
you're now generating extra rows right I

00:40:43,210 --> 00:40:48,220
mean particularly the update case you're

00:40:45,100 --> 00:40:50,410
generating a new row for an update now

00:40:48,220 --> 00:40:52,590
that's normally not done in databases

00:40:50,410 --> 00:40:54,850
normally you replace the row in place

00:40:52,590 --> 00:40:56,200
but when you replace the role in place

00:40:54,850 --> 00:40:59,190
all of a sudden you cannot take

00:40:56,200 --> 00:41:02,260
advantage of the sort of plethora of

00:40:59,190 --> 00:41:04,780
goodness that NBC gives you so therefore

00:41:02,260 --> 00:41:06,340
we have to create that new row but we

00:41:04,780 --> 00:41:10,000
got to clean it up so how do we do that

00:41:06,340 --> 00:41:11,170
right well the bottom line is the

00:41:10,000 --> 00:41:13,150
Postgres would have to do clean up

00:41:11,170 --> 00:41:15,580
anyway even if rivet word for NBC see

00:41:13,150 --> 00:41:17,260
you still got a clean stuff up and I

00:41:15,580 --> 00:41:19,090
think every database calls it something

00:41:17,260 --> 00:41:21,490
different but they all got a goo clean

00:41:19,090 --> 00:41:24,640
up somehow okay for example if you

00:41:21,490 --> 00:41:26,440
delete a row well we got it we got it we

00:41:24,640 --> 00:41:30,940
use that space somehow right so we got

00:41:26,440 --> 00:41:33,520
to clean it up somehow also if you board

00:41:30,940 --> 00:41:37,490
a transaction again there's going to be

00:41:33,520 --> 00:41:40,760
some gravitation to clean up right

00:41:37,490 --> 00:41:43,640
MVCC just add some additional ones so

00:41:40,760 --> 00:41:47,720
it's adding the need to clean up these

00:41:43,640 --> 00:41:49,369
updated rows and also it can delay the

00:41:47,720 --> 00:41:51,110
clean up a little bit we can't clean it

00:41:49,369 --> 00:41:52,610
up at the time we to leave it because

00:41:51,110 --> 00:41:54,410
there might be some snapshot that needs

00:41:52,610 --> 00:41:57,200
it so all of a sudden that a lot of the

00:41:54,410 --> 00:42:00,140
cleanup has to happen asynchronously in

00:41:57,200 --> 00:42:01,760
other sessions okay and post Chris has

00:42:00,140 --> 00:42:03,170
gotten really good at this we weren't

00:42:01,760 --> 00:42:04,880
very good ten years ago but now we're

00:42:03,170 --> 00:42:06,530
really good so again most of these

00:42:04,880 --> 00:42:09,619
things don't affect you but you should

00:42:06,530 --> 00:42:13,340
know probably what they do so how do we

00:42:09,619 --> 00:42:15,800
do it - two ways first way is something

00:42:13,340 --> 00:42:17,510
called an on-demand cleanup of a single

00:42:15,800 --> 00:42:20,060
page remember somebody asked me they

00:42:17,510 --> 00:42:21,800
said do you always put the update like

00:42:20,060 --> 00:42:24,290
near the old row remember that was you I

00:42:21,800 --> 00:42:26,390
think right so actually that's actually

00:42:24,290 --> 00:42:28,220
part of how we do this on-demand clips

00:42:26,390 --> 00:42:30,350
one single page cleanup there are some

00:42:28,220 --> 00:42:32,900
optimizations we can do if the update is

00:42:30,350 --> 00:42:35,780
on the same page that we can't do if the

00:42:32,900 --> 00:42:38,330
updates on a different page okay and

00:42:35,780 --> 00:42:40,730
then we also have this bulk cleanup that

00:42:38,330 --> 00:42:42,560
is basically something called auto

00:42:40,730 --> 00:42:44,810
vacuum this basically runs through the

00:42:42,560 --> 00:42:46,220
database and kind of just cleans up

00:42:44,810 --> 00:42:48,200
everything and remembers where all the

00:42:46,220 --> 00:42:51,500
free space is and then allows you to

00:42:48,200 --> 00:42:52,760
reuse it okay and I'm going to go into

00:42:51,500 --> 00:42:55,340
detail about each of these

00:42:52,760 --> 00:42:57,859
so aspects of clean ups there's three

00:42:55,340 --> 00:43:02,810
things we can clean up we can clean up

00:42:57,859 --> 00:43:05,540
the data okay we call that the heap

00:43:02,810 --> 00:43:07,190
tuples or the rows then we can also

00:43:05,540 --> 00:43:10,100
clean up something called item pointers

00:43:07,190 --> 00:43:12,740
and then index entries and each of those

00:43:10,100 --> 00:43:14,359
have a different method to clean up now

00:43:12,740 --> 00:43:17,600
that maybe I've kind of abstract for you

00:43:14,359 --> 00:43:20,030
so I've provided a slide right basically

00:43:17,600 --> 00:43:23,540
this is a heap page all of our heap

00:43:20,030 --> 00:43:26,450
pages happen to be 8k in size okay

00:43:23,540 --> 00:43:29,450
and as you can see up at the top they

00:43:26,450 --> 00:43:32,570
have item pointers and these item

00:43:29,450 --> 00:43:35,210
pointers basically point to data rows or

00:43:32,570 --> 00:43:37,190
tuples okay again as I said we have a

00:43:35,210 --> 00:43:40,760
tendency to use tuple or talking about

00:43:37,190 --> 00:43:42,800
on disk storage what about item pointers

00:43:40,760 --> 00:43:44,119
I mean what about indexes well one of

00:43:42,800 --> 00:43:45,530
the interesting things about Postgres

00:43:44,119 --> 00:43:48,380
and again this came from the berkeley

00:43:45,530 --> 00:43:49,290
folks is that the indexes themselves

00:43:48,380 --> 00:43:51,270
don't point

00:43:49,290 --> 00:43:53,880
to the rose they don't point to the

00:43:51,270 --> 00:43:56,040
tuples they point to the item pointers

00:43:53,880 --> 00:43:58,500
and the item pointers point to the

00:43:56,040 --> 00:44:00,720
tuples they may think well it's just

00:43:58,500 --> 00:44:04,200
stupid like why do you doe double

00:44:00,720 --> 00:44:07,680
indirection like that well what we can

00:44:04,200 --> 00:44:11,550
do is we can move rows around on this

00:44:07,680 --> 00:44:14,340
page without having to touch the indexes

00:44:11,550 --> 00:44:15,240
because as you may realize index cleanup

00:44:14,340 --> 00:44:17,940
and index

00:44:15,240 --> 00:44:20,610
sort of wholesale is just really

00:44:17,940 --> 00:44:23,340
expensive right they're randomly spread

00:44:20,610 --> 00:44:25,890
all over their be tree or whatever hat

00:44:23,340 --> 00:44:28,080
is just hash it's a mess so the legal

00:44:25,890 --> 00:44:30,390
the more we can do without touching the

00:44:28,080 --> 00:44:32,250
indexes the happier we are and that's

00:44:30,390 --> 00:44:34,260
why these indexes always point to the

00:44:32,250 --> 00:44:36,840
item pointers and not to the actual data

00:44:34,260 --> 00:44:40,410
rows okay so let's let's let's get some

00:44:36,840 --> 00:44:43,500
concrete stuff here so what happens if

00:44:40,410 --> 00:44:45,900
tuple 1 and tuple 2 are no longer needed

00:44:43,500 --> 00:44:47,370
we can expire those when basically what

00:44:45,900 --> 00:44:51,630
we're saying is not only are they

00:44:47,370 --> 00:44:54,930
deleted but no existing snapshot can see

00:44:51,630 --> 00:44:56,550
them and that's really the key not that

00:44:54,930 --> 00:44:57,990
they're deleted the delete it just means

00:44:56,550 --> 00:45:00,510
okay they're going to be removed

00:44:57,990 --> 00:45:02,910
eventually but we have to also know that

00:45:00,510 --> 00:45:04,620
nobody wants to see them and as soon as

00:45:02,910 --> 00:45:06,660
we know nobody wants to see that meaning

00:45:04,620 --> 00:45:10,040
nobody has a snapshot that they can see

00:45:06,660 --> 00:45:13,350
then we can then recycle that space and

00:45:10,040 --> 00:45:15,600
because the index doesn't point to the

00:45:13,350 --> 00:45:17,460
rows we can basically just get rid of

00:45:15,600 --> 00:45:19,830
them and we don't have to do that in any

00:45:17,460 --> 00:45:22,200
fancy way we can just as we're looking

00:45:19,830 --> 00:45:23,790
at the page we're like hey did you see

00:45:22,200 --> 00:45:26,220
those rows there no nobody sees those

00:45:23,790 --> 00:45:28,380
anymore let's just get rid of them right

00:45:26,220 --> 00:45:30,600
and then with an insert or somebody

00:45:28,380 --> 00:45:31,950
wants to update on that page we now have

00:45:30,600 --> 00:45:34,260
from some free space available so

00:45:31,950 --> 00:45:36,300
effectively what happens is we can mark

00:45:34,260 --> 00:45:38,280
the item pointers is dead and then we

00:45:36,300 --> 00:45:40,320
can just recycle the space on the spot

00:45:38,280 --> 00:45:43,220
that's part of that sort of single page

00:45:40,320 --> 00:45:43,220
cleanup by talking about

00:45:44,000 --> 00:45:47,030
you get to move tuple three while you do

00:45:46,400 --> 00:45:49,790
it right

00:45:47,030 --> 00:45:52,010
so tuple three you item pointer you

00:45:49,790 --> 00:45:54,530
start well I eat employer three used to

00:45:52,010 --> 00:45:56,090
point to tuple three now item pointer

00:45:54,530 --> 00:45:59,060
three points of tuple three but now in a

00:45:56,090 --> 00:46:00,230
different spot the index doesn't know

00:45:59,060 --> 00:46:02,090
because it's only point at the

00:46:00,230 --> 00:46:03,710
unemployed and these are basically

00:46:02,090 --> 00:46:05,150
marked as dead and they be just put a

00:46:03,710 --> 00:46:06,650
little flag in their tiny little field

00:46:05,150 --> 00:46:08,720
to me just basically say you know the

00:46:06,650 --> 00:46:16,369
second pointer don't go there there's

00:46:08,720 --> 00:46:17,930
nothing there right it's done so the

00:46:16,369 --> 00:46:19,280
tuples variable size should they contain

00:46:17,930 --> 00:46:21,320
all the data they normally contain all

00:46:19,280 --> 00:46:24,380
the data although although there is a

00:46:21,320 --> 00:46:26,690
toast system which will handle values

00:46:24,380 --> 00:46:28,849
over about 2k in length because again

00:46:26,690 --> 00:46:30,830
the page is only 8k so we can't get that

00:46:28,849 --> 00:46:33,080
our rows get too big so we basically

00:46:30,830 --> 00:46:34,790
have this toast system where we'll take

00:46:33,080 --> 00:46:36,500
any of the longer values we'll push them

00:46:34,790 --> 00:46:37,970
off somewhere else there's a whole lot

00:46:36,500 --> 00:46:40,640
of advantages to that I do have some

00:46:37,970 --> 00:46:42,650
blog entries about it I'm not going to

00:46:40,640 --> 00:46:45,530
go into it here but effectively it gives

00:46:42,650 --> 00:46:47,420
us kind of a storage system where we

00:46:45,530 --> 00:46:49,820
have all the short values kind of

00:46:47,420 --> 00:46:51,770
together and then long images or long

00:46:49,820 --> 00:46:53,990
documents are now stored in these backup

00:46:51,770 --> 00:46:57,520
tables that happens automatically you

00:46:53,990 --> 00:46:57,520
don't do anything to have that happen

00:47:04,160 --> 00:47:09,060
so that the point was right if you have

00:47:06,840 --> 00:47:10,530
a four byte four character field it's

00:47:09,060 --> 00:47:12,750
it's going to be in line it's going to

00:47:10,530 --> 00:47:14,790
be in the heap if you have a whole essay

00:47:12,750 --> 00:47:17,100
the system's automatically you're gonna

00:47:14,790 --> 00:47:18,990
trigger it's going to put a pointer here

00:47:17,100 --> 00:47:21,090
and then it's gonna put the data app out

00:47:18,990 --> 00:47:23,340
in this longer text a little song or

00:47:21,090 --> 00:47:25,380
heap it's on the toast area and then

00:47:23,340 --> 00:47:27,120
when your sequential scanning it unless

00:47:25,380 --> 00:47:28,800
you're interested in that long field you

00:47:27,120 --> 00:47:31,260
won't see it you'll just kind of hop

00:47:28,800 --> 00:47:32,930
over it right and I have written some

00:47:31,260 --> 00:47:35,370
blog entries about it like for example

00:47:32,930 --> 00:47:36,960
don't do select star unless you want all

00:47:35,370 --> 00:47:38,250
the fields like the people don't think

00:47:36,960 --> 00:47:41,070
about that I'll just do select start

00:47:38,250 --> 00:47:42,720
well yeah except if it's there's some

00:47:41,070 --> 00:47:43,800
long fields in there you're now access

00:47:42,720 --> 00:47:45,630
to the toast table if you don't want

00:47:43,800 --> 00:47:47,960
that value don't ask for it because that

00:47:45,630 --> 00:47:51,030
can be quite expensive for long fields

00:47:47,960 --> 00:47:52,890
so it's actually so transparent that

00:47:51,030 --> 00:47:54,840
people don't think about it yeah this

00:47:52,890 --> 00:47:58,350
was a you know it's I know it's

00:47:54,840 --> 00:48:08,450
transparent but can you can you not can

00:47:58,350 --> 00:48:08,450
you not do that to me right I'm sorry

00:48:12,050 --> 00:48:16,760
so if the select star was inside a

00:48:14,340 --> 00:48:19,230
sub-query would that get optimized away

00:48:16,760 --> 00:48:28,290
yeah nobody really does select star

00:48:19,230 --> 00:48:31,410
inside a sub-query I don't know I don't

00:48:28,290 --> 00:48:33,560
know okay I can't remember how we do

00:48:31,410 --> 00:48:33,560
that

00:48:34,610 --> 00:48:47,090
I don't think it would yeah something to

00:48:38,720 --> 00:48:48,950
keep in mind yeah okay so we also have

00:48:47,090 --> 00:48:52,520
that vacuum process I mentioned it runs

00:48:48,950 --> 00:48:54,470
automatically and it would allow us to

00:48:52,520 --> 00:48:55,940
then clean out the indexes and again

00:48:54,470 --> 00:48:59,000
cleaning the index is sort of a

00:48:55,940 --> 00:49:00,350
wholesale process that we do and it

00:48:59,000 --> 00:49:02,510
would then allow us to clean out the

00:49:00,350 --> 00:49:05,630
indexes and then we can mark these item

00:49:02,510 --> 00:49:11,450
pointers is unused and then reuse them

00:49:05,630 --> 00:49:14,030
for you know for for other data that's

00:49:11,450 --> 00:49:16,100
coming in okay so you can see it's kind

00:49:14,030 --> 00:49:18,440
of a tiered thing we're clearing out the

00:49:16,100 --> 00:49:19,970
data which is the most the biggest then

00:49:18,440 --> 00:49:21,710
we kind of hit the item pointers and

00:49:19,970 --> 00:49:26,960
then the index is kind of in a wholesale

00:49:21,710 --> 00:49:29,840
matter here's an example here I truncate

00:49:26,960 --> 00:49:31,970
the table I kind of fill it up so it's

00:49:29,840 --> 00:49:34,670
like less than 10% full

00:49:31,970 --> 00:49:38,570
listen there's an empty and then I

00:49:34,670 --> 00:49:41,270
basically it's enacted 6% empty and I

00:49:38,570 --> 00:49:44,780
insert one more row and then I can kind

00:49:41,270 --> 00:49:46,820
of see the row and if I delete the row

00:49:44,780 --> 00:49:49,640
and I added two so I delete the one I

00:49:46,820 --> 00:49:52,160
added too you can see here's the item

00:49:49,640 --> 00:49:54,410
pointer for the first row and you can

00:49:52,160 --> 00:49:57,260
see it's deleted and here's the item

00:49:54,410 --> 00:49:59,030
pointer for the second row and if I

00:49:57,260 --> 00:50:02,000
actually delete the two and insert a

00:49:59,030 --> 00:50:05,210
three you can actually see that first

00:50:02,000 --> 00:50:07,640
row is now marked as dead meaning that

00:50:05,210 --> 00:50:11,120
the data is gone but the item pointers

00:50:07,640 --> 00:50:13,640
still there okay and here's two which

00:50:11,120 --> 00:50:16,340
will be getting in there's three and

00:50:13,640 --> 00:50:18,110
then if I do a select again just to

00:50:16,340 --> 00:50:20,210
select I'm not even updating the day I

00:50:18,110 --> 00:50:21,710
just do a select you can see I've now

00:50:20,210 --> 00:50:24,290
marked both of these is dead

00:50:21,710 --> 00:50:25,790
so the system even in a select if it's

00:50:24,290 --> 00:50:28,070
looking at their row and it's done the

00:50:25,790 --> 00:50:30,530
lookup information it'll basically say

00:50:28,070 --> 00:50:32,480
okay I'm now identifying these two guys

00:50:30,530 --> 00:50:36,590
are dead let's get rid of them

00:50:32,480 --> 00:50:39,380
okay and that that's actually what it

00:50:36,590 --> 00:50:41,300
would look like and then if I didn't run

00:50:39,380 --> 00:50:45,020
a vacuum you can see that they're now

00:50:41,300 --> 00:50:46,560
marked as unused okay so again that's

00:50:45,020 --> 00:50:49,230
part of that cleanup

00:50:46,560 --> 00:50:51,960
we have and again it would look like

00:50:49,230 --> 00:50:54,420
that we have something called a free

00:50:51,960 --> 00:50:57,390
space map it's basically a place that

00:50:54,420 --> 00:50:59,280
Postgres stores how much free space

00:50:57,390 --> 00:51:01,920
you're having your table so for example

00:50:59,280 --> 00:51:03,840
if you've got you know a hundred blocks

00:51:01,920 --> 00:51:05,220
in your table and you want to do an

00:51:03,840 --> 00:51:06,840
insert well where do you put it the

00:51:05,220 --> 00:51:08,430
tables got a hundred blocks which block

00:51:06,840 --> 00:51:12,630
do you put it in you look at the free

00:51:08,430 --> 00:51:16,080
space map hey page number twelve has a

00:51:12,630 --> 00:51:18,060
lot of free space go there so what that

00:51:16,080 --> 00:51:19,890
vacuum effectively is doing is it's not

00:51:18,060 --> 00:51:22,260
only clearing out that data but it's

00:51:19,890 --> 00:51:24,120
recording where the free space is so

00:51:22,260 --> 00:51:26,550
that other sessions can reference it

00:51:24,120 --> 00:51:29,120
very quickly and then reuse the space

00:51:26,550 --> 00:51:31,770
efficiently all right

00:51:29,120 --> 00:51:34,230
here's an example I can't get the table

00:51:31,770 --> 00:51:36,150
I vacuum it in fact you can see it

00:51:34,230 --> 00:51:37,530
actually if there's no data in the table

00:51:36,150 --> 00:51:39,900
of the vacuum will actually shrink the

00:51:37,530 --> 00:51:42,570
table too but the data has to be dead it

00:51:39,900 --> 00:51:43,860
has to be in a whole empty page and it

00:51:42,570 --> 00:51:46,860
has to be at the end of the table those

00:51:43,860 --> 00:51:48,390
Golgo we have to leave a vacuum full

00:51:46,860 --> 00:51:50,070
which lets you rewrite the table but

00:51:48,390 --> 00:51:51,630
again that's not something it's gonna

00:51:50,070 --> 00:51:54,660
lock the table not something gonna do a

00:51:51,630 --> 00:51:57,900
normal usage of another free space map

00:51:54,660 --> 00:52:00,300
example here fill up the table insert a

00:51:57,900 --> 00:52:03,450
1 insert of 2 you can see actually the

00:52:00,300 --> 00:52:05,310
free space going down and then it's back

00:52:03,450 --> 00:52:07,200
up again once I've deleted the row again

00:52:05,310 --> 00:52:10,280
sort of like you can kind of see the

00:52:07,200 --> 00:52:13,350
free space getting bigger and smaller

00:52:10,280 --> 00:52:14,930
again if you've got empty pages at the

00:52:13,350 --> 00:52:19,230
end of the table we'll just truncate it

00:52:14,930 --> 00:52:21,150
so here we actually deleted it here we

00:52:19,230 --> 00:52:22,500
select free space map it's nothing there

00:52:21,150 --> 00:52:24,360
and you can see it's just shrunk the

00:52:22,500 --> 00:52:32,600
table and again vacuumed full we'll

00:52:24,360 --> 00:52:35,600
rewrite the whole questions good okay so

00:52:32,600 --> 00:52:35,600
yeah

00:52:39,880 --> 00:52:48,170
yeah it's basically you you store so the

00:52:43,790 --> 00:52:50,150
question is are these pages on disk are

00:52:48,170 --> 00:52:53,240
they in RAM you know how do they get

00:52:50,150 --> 00:52:54,650
there so effectively you have you know

00:52:53,240 --> 00:52:57,740
your data directory which has all the

00:52:54,650 --> 00:52:58,940
physical pages and then as you need them

00:52:57,740 --> 00:53:01,190
they'll be loaded into an area called

00:52:58,940 --> 00:53:03,230
shared buffers and then we'll do all of

00:53:01,190 --> 00:53:04,850
our reading writing locking in that

00:53:03,230 --> 00:53:07,220
shared buffer area and then

00:53:04,850 --> 00:53:10,010
asynchronously that will be written back

00:53:07,220 --> 00:53:11,660
down to the storage we also have a right

00:53:10,010 --> 00:53:13,400
ahead log which will record all the

00:53:11,660 --> 00:53:15,350
changes and get committed to disk and

00:53:13,400 --> 00:53:17,630
often that'll happen before we actually

00:53:15,350 --> 00:53:20,180
write the physical page back to disk so

00:53:17,630 --> 00:53:22,100
you're almost doing a double double

00:53:20,180 --> 00:53:23,780
right in a way and that's traditionally

00:53:22,100 --> 00:53:32,150
the way that databases have dealt with

00:53:23,780 --> 00:53:34,460
that kind of problem so so the question

00:53:32,150 --> 00:53:36,320
is that sounds a lot like the way the

00:53:34,460 --> 00:53:41,030
kernel does what it's doing yeah it's

00:53:36,320 --> 00:53:49,550
exactly the same yeah it's very similar

00:53:41,030 --> 00:53:50,630
to a journaling file system yeah yeah so

00:53:49,550 --> 00:53:52,700
the question is would it be better these

00:53:50,630 --> 00:53:54,980
are wall block device in fact the

00:53:52,700 --> 00:53:58,400
Postgres documentation recommends that

00:53:54,980 --> 00:54:02,060
you mount your you were journaling file

00:53:58,400 --> 00:54:05,870
system volumes with data equal write

00:54:02,060 --> 00:54:07,370
back which minimizes the amount of

00:54:05,870 --> 00:54:09,440
journaling that happens in those file

00:54:07,370 --> 00:54:10,970
systems because effectively because of

00:54:09,440 --> 00:54:13,580
the right head log you'd be double

00:54:10,970 --> 00:54:16,340
journaling and you're gonna see maybe a

00:54:13,580 --> 00:54:20,210
three percent win by mounting them with

00:54:16,340 --> 00:54:21,950
a lower overhead journaling option for

00:54:20,210 --> 00:54:27,410
file systems that you use for Postgres

00:54:21,950 --> 00:54:30,860
yep okay so almost well we're kind of

00:54:27,410 --> 00:54:32,690
done not almost on a single page cleanup

00:54:30,860 --> 00:54:34,850
I talked about how that works there is a

00:54:32,690 --> 00:54:36,110
little bit more to this and it really

00:54:34,850 --> 00:54:39,260
relates to the question about having

00:54:36,110 --> 00:54:43,940
updates on the same row okay so here we

00:54:39,260 --> 00:54:47,150
have a row the one data row and an index

00:54:43,940 --> 00:54:49,789
pointing to it okay if we then do

00:54:47,150 --> 00:54:51,710
and update okay remember I said there

00:54:49,789 --> 00:54:53,420
can be multiple versions of the rose so

00:54:51,710 --> 00:54:56,720
I basically create a new version of the

00:54:53,420 --> 00:54:58,970
row and what you're going to notice here

00:54:56,720 --> 00:55:00,920
is I've got a pointer on the row which

00:54:58,970 --> 00:55:03,109
points from the version first version

00:55:00,920 --> 00:55:04,609
the second version but what's the real

00:55:03,109 --> 00:55:07,490
key is that there's only one index

00:55:04,609 --> 00:55:10,009
pointer here this is what we call a heap

00:55:07,490 --> 00:55:14,140
only tuple feature added I believe in

00:55:10,009 --> 00:55:17,630
Postgres 8/3 which basically allows us

00:55:14,140 --> 00:55:19,789
to do updates without bloating the index

00:55:17,630 --> 00:55:21,890
or without adding additional index

00:55:19,789 --> 00:55:24,499
entries and it actually improves our

00:55:21,890 --> 00:55:26,569
clean up puts a potential pretty much

00:55:24,499 --> 00:55:29,690
for example when I get to version 3 of

00:55:26,569 --> 00:55:33,589
the data I effectively have removed

00:55:29,690 --> 00:55:35,930
version 1 on my own and I can repoint

00:55:33,589 --> 00:55:37,549
the item pointer over here remember one

00:55:35,930 --> 00:55:40,819
of the things that really limits our

00:55:37,549 --> 00:55:45,289
recycling are these item pointers so if

00:55:40,819 --> 00:55:47,630
we can chain the item pointers in the

00:55:45,289 --> 00:55:49,460
heap page and only have one an important

00:55:47,630 --> 00:55:51,890
it allows us to recycle much more

00:55:49,460 --> 00:55:54,829
aggressively because we don't need to go

00:55:51,890 --> 00:55:56,210
to the index to clean anything up and

00:55:54,829 --> 00:55:58,789
that's exactly what's going on here

00:55:56,210 --> 00:56:01,009
first item pointer is no longer pointing

00:55:58,789 --> 00:56:02,690
to data but it's now pointing to two two

00:56:01,009 --> 00:56:06,650
is pointing to two to three is pointing

00:56:02,690 --> 00:56:08,210
to 3 version four version item pointer

00:56:06,650 --> 00:56:11,019
one which is still the one the index

00:56:08,210 --> 00:56:13,609
knows about is now pointing to three and

00:56:11,019 --> 00:56:15,410
version 3 is now pointing to version 4

00:56:13,609 --> 00:56:18,440
which happens to be on item pointer to

00:56:15,410 --> 00:56:20,269
now all right again because of this item

00:56:18,440 --> 00:56:23,809
because those indexes are not locking us

00:56:20,269 --> 00:56:27,319
into into reusing these item pointers we

00:56:23,809 --> 00:56:30,019
can be fairly aggressive so just to

00:56:27,319 --> 00:56:32,539
think that I'm making this up basically

00:56:30,019 --> 00:56:34,249
when you get to version 4 and it knows

00:56:32,539 --> 00:56:36,049
that there's no more versions visible

00:56:34,249 --> 00:56:38,029
it'll actually just unmarked this as

00:56:36,049 --> 00:56:40,849
unused it'll read out their act number

00:56:38,029 --> 00:56:42,289
one to number two and then we're done ok

00:56:40,849 --> 00:56:44,329
so let's take a look at what this looks

00:56:42,289 --> 00:56:47,390
like here's a kit example I'm kind of

00:56:44,329 --> 00:56:50,450
filling up the page here's one day to

00:56:47,390 --> 00:56:55,299
row that's basically deleted here's a

00:56:50,450 --> 00:56:57,710
second data row if I do an update again

00:56:55,299 --> 00:56:59,380
and this is a this is literally what it

00:56:57,710 --> 00:57:01,840
will show you in

00:56:59,380 --> 00:57:04,390
in the output so it basically says white

00:57:01,840 --> 00:57:08,230
employer one or two 41 is now pointing

00:57:04,390 --> 00:57:11,350
to two and two is really dead but points

00:57:08,230 --> 00:57:14,350
to three then which is basically this

00:57:11,350 --> 00:57:17,170
case when we then do an update again now

00:57:14,350 --> 00:57:20,290
one points to three which happens to be

00:57:17,170 --> 00:57:22,930
deleted which points to two and then

00:57:20,290 --> 00:57:25,450
which is this case and then finally if

00:57:22,930 --> 00:57:27,790
we just do a select just to look at the

00:57:25,450 --> 00:57:30,220
rows you can see now one points to two

00:57:27,790 --> 00:57:34,030
two is now our normal pointer and three

00:57:30,220 --> 00:57:35,710
has been recycled so thank you so what

00:57:34,030 --> 00:57:39,040
you can see here is basically that we've

00:57:35,710 --> 00:57:40,450
gotten much better if we can keep the

00:57:39,040 --> 00:57:43,420
update on the same page we get much

00:57:40,450 --> 00:57:45,070
better at recycling these things hot so

00:57:43,420 --> 00:57:46,870
the classic example of Postgres would

00:57:45,070 --> 00:57:49,360
not be good in the past we've got a

00:57:46,870 --> 00:57:50,800
counter one row a counter just goes one

00:57:49,360 --> 00:57:52,210
two three four five six seven eight they

00:57:50,800 --> 00:57:54,400
used to be terrible with Postgres

00:57:52,210 --> 00:57:56,650
because effectively we couldn't get that

00:57:54,400 --> 00:57:59,110
vacuum in there fast enough to recycle

00:57:56,650 --> 00:58:00,730
them now the system's like well soon as

00:57:59,110 --> 00:58:03,100
I can get rid of these every time I go

00:58:00,730 --> 00:58:05,080
to update a row I'm gonna recycle that

00:58:03,100 --> 00:58:07,180
row and I'm gonna make sure that that

00:58:05,080 --> 00:58:12,430
counter that that row doesn't get

00:58:07,180 --> 00:58:14,500
bloated up okay effectively what's

00:58:12,430 --> 00:58:20,620
what's what's going on here let's clean

00:58:14,500 --> 00:58:22,300
up so we can run vacuum that actually

00:58:20,620 --> 00:58:25,030
allows us to do some pretty cool stuff

00:58:22,300 --> 00:58:28,030
so here we've got a bunch of sort of

00:58:25,030 --> 00:58:30,010
deleted rows I run vacuum and again it

00:58:28,030 --> 00:58:32,410
just gets rid of all so vacuum still has

00:58:30,010 --> 00:58:34,540
the cool stuff but one one thing that we

00:58:32,410 --> 00:58:37,630
can't do is if you have if you update

00:58:34,540 --> 00:58:40,650
indexed columns we can't do this

00:58:37,630 --> 00:58:45,000
recycling because remember we can't

00:58:40,650 --> 00:58:47,710
share let me get a slide here nope sorry

00:58:45,000 --> 00:58:51,400
so the problem is if you want if you

00:58:47,710 --> 00:58:53,080
update an index column we can't have the

00:58:51,400 --> 00:58:56,250
same index pointer point because we

00:58:53,080 --> 00:59:00,010
needed separate index for the new value

00:58:56,250 --> 00:59:04,570
right so the problem we're actually

00:59:00,010 --> 00:59:06,280
showing you here is that if you create

00:59:04,570 --> 00:59:08,440
an index and you're all updating the

00:59:06,280 --> 00:59:09,940
index what you're going to notice is

00:59:08,440 --> 00:59:12,240
this kind of pattern you got a dead one

00:59:09,940 --> 00:59:15,690
to normal I have

00:59:12,240 --> 00:59:17,970
two dead ones I have three dead ones I

00:59:15,690 --> 00:59:19,920
can still update I can still delete the

00:59:17,970 --> 00:59:22,290
data rows but the pointers are gonna

00:59:19,920 --> 00:59:24,900
stay around because I've now got indexes

00:59:22,290 --> 00:59:27,060
pointing to them okay

00:59:24,900 --> 00:59:29,610
filing when we do vacuum those can be

00:59:27,060 --> 00:59:31,440
those can be cleared out so you guys you

00:59:29,610 --> 00:59:34,410
can see Postgres is fairly aggressive in

00:59:31,440 --> 00:59:37,500
its ability to clean stuff out it's now

00:59:34,410 --> 00:59:41,460
a very mature bus system works really

00:59:37,500 --> 00:59:43,410
well we didn't when we before we had a

00:59:41,460 --> 00:59:45,930
lot of these features there were some

00:59:43,410 --> 00:59:48,720
pathological cases but that I don't

00:59:45,930 --> 00:59:50,460
think post Chris handled well at all at

00:59:48,720 --> 00:59:53,460
this point it's really something you

00:59:50,460 --> 00:59:57,950
don't really need to worry about single

00:59:53,460 --> 01:00:00,720
page vacuums are very effective deleting

00:59:57,950 --> 01:00:02,400
the the vacuum system itself is very

01:00:00,720 --> 01:00:04,890
efficient at knowing which pages are

01:00:02,400 --> 01:00:06,960
dirty and which pages aren't and I think

01:00:04,890 --> 01:00:09,620
that works really well so we ended with

01:00:06,960 --> 01:00:12,200
this slide which i think is is very

01:00:09,620 --> 01:00:14,910
apropos to what we're doing here

01:00:12,200 --> 01:00:16,950
it's an Escher relativity and you can

01:00:14,910 --> 01:00:20,460
see I think sort of talking about

01:00:16,950 --> 01:00:22,950
snapshots that from your perspective you

01:00:20,460 --> 01:00:26,460
see different things and each each

01:00:22,950 --> 01:00:32,370
person thinks they are sort of seeing

01:00:26,460 --> 01:00:34,680
the right view of the data there is no

01:00:32,370 --> 01:00:36,660
one set of data exactly well thanks a

01:00:34,680 --> 01:00:38,490
lot I'm undone again I'll be talking

01:00:36,660 --> 01:00:40,590
tomorrow morning and on Sunday and

01:00:38,490 --> 01:00:42,120
certainly I have that class on Monday so

01:00:40,590 --> 01:00:43,410
I've enjoyed it thank you very much I

01:00:42,120 --> 01:00:45,390
hope if you have any questions I'll be

01:00:43,410 --> 01:00:47,840
up here but again I'm out of time

01:00:45,390 --> 01:00:47,840
thanks

01:00:48,549 --> 01:00:50,609
you

01:00:54,960 --> 01:00:59,739
when we created asterisk over a decade

01:00:57,670 --> 01:01:01,989
ago we could not have imagined that

01:00:59,739 --> 01:01:04,180
asterisk would not only become the most

01:01:01,989 --> 01:01:06,309
widely adopted open-source communication

01:01:04,180 --> 01:01:08,349
software on the planet but that it would

01:01:06,309 --> 01:01:09,700
impact the entire industry in the way

01:01:08,349 --> 01:01:11,349
that it has today

01:01:09,700 --> 01:01:13,720
asterisk has found its way in the more

01:01:11,349 --> 01:01:15,970
than 170 countries and virtually every

01:01:13,720 --> 01:01:18,099
fortune 1000 company the success of

01:01:15,970 --> 01:01:20,200
Astra's has enabled a transition of

01:01:18,099 --> 01:01:22,420
power from the hands of the traditional

01:01:20,200 --> 01:01:24,249
proprietary phone vendors into the hands

01:01:22,420 --> 01:01:27,099
of the users and administrators of phone

01:01:24,249 --> 01:01:28,450
systems using this power our customers

01:01:27,099 --> 01:01:30,549
have created all sorts of business

01:01:28,450 --> 01:01:32,229
changing applications from small office

01:01:30,549 --> 01:01:34,150
phone systems to mission-critical call

01:01:32,229 --> 01:01:36,190
centers the international carrier

01:01:34,150 --> 01:01:37,779
networks in fact there's even an entire

01:01:36,190 --> 01:01:39,789
country those communications

01:01:37,779 --> 01:01:41,140
infrastructure runs on asters the Jim

01:01:39,789 --> 01:01:43,690
has always been about creating

01:01:41,140 --> 01:01:45,369
technology that expands communications

01:01:43,690 --> 01:01:47,349
capabilities in ways that we could never

01:01:45,369 --> 01:01:49,690
have imagined and that's part of what's

01:01:47,349 --> 01:01:50,440
game-changing about Digium today we're

01:01:49,690 --> 01:01:52,720
doing it again

01:01:50,440 --> 01:01:55,269
this time by introducing a new family of

01:01:52,720 --> 01:01:57,369
HD IP phones that extends control of the

01:01:55,269 --> 01:01:59,140
user all the way to the desktop the

01:01:57,369 --> 01:02:00,849
launch of these new products represents

01:01:59,140 --> 01:02:02,979
the next phase indigenous history of

01:02:00,849 --> 01:02:05,349
innovation these are the first and only

01:02:02,979 --> 01:02:07,059
IP phones designed to fully leverage the

01:02:05,349 --> 01:02:08,739
power of esters when we first discussed

01:02:07,059 --> 01:02:10,239
our expectations for building a family

01:02:08,739 --> 01:02:12,640
of phones for use with esters

01:02:10,239 --> 01:02:14,410
our requirements were pretty simple we

01:02:12,640 --> 01:02:16,180
asked the team to build the phones such

01:02:14,410 --> 01:02:18,369
that they were easy to install integrate

01:02:16,180 --> 01:02:20,229
provision and use I think you'll soon

01:02:18,369 --> 01:02:22,779
agree our engineers have delivered on

01:02:20,229 --> 01:02:24,640
that goal user feedback is validating

01:02:22,779 --> 01:02:26,680
that when it comes to operation with a

01:02:24,640 --> 01:02:28,960
sure space systems including our own

01:02:26,680 --> 01:02:31,539
Switchvox based product these are the

01:02:28,960 --> 01:02:33,069
easiest to use best integrated most

01:02:31,539 --> 01:02:33,309
interoperable products on the market

01:02:33,069 --> 01:02:35,410
today

01:02:33,309 --> 01:02:37,420
the Digium family of phones will

01:02:35,410 --> 01:02:39,460
initially include three IP desk phones

01:02:37,420 --> 01:02:41,410
uniquely designed to complement any

01:02:39,460 --> 01:02:43,390
asterisk or switch box based solution

01:02:41,410 --> 01:02:44,019
these phones are different for a number

01:02:43,390 --> 01:02:46,779
of reasons

01:02:44,019 --> 01:02:49,180
first there is cluesive ly designed for

01:02:46,779 --> 01:02:50,829
use with esters secondly we've made it

01:02:49,180 --> 01:02:53,289
really easy to auto discover and

01:02:50,829 --> 01:02:54,640
provision the phones next we've made it

01:02:53,289 --> 01:02:56,920
easy for the phones to access

01:02:54,640 --> 01:02:58,130
information inside of asterisk allowing

01:02:56,920 --> 01:03:00,680
tight coupling

01:02:58,130 --> 01:03:02,569
allocation and the phone additionally

01:03:00,680 --> 01:03:04,849
we've created an applications engine

01:03:02,569 --> 01:03:07,039
that allows users and developers to

01:03:04,849 --> 01:03:09,890
create and run their own apps on the

01:03:07,039 --> 01:03:11,900
phone and finally we've done all of this

01:03:09,890 --> 01:03:14,029
at a very compelling price point at

01:03:11,900 --> 01:03:15,829
Digium we're always thinking of ways to

01:03:14,029 --> 01:03:18,170
give our customers the best value in

01:03:15,829 --> 01:03:19,460
business phone systems and also give

01:03:18,170 --> 01:03:21,559
them the power to create their own

01:03:19,460 --> 01:03:23,359
solutions for eating communications

01:03:21,559 --> 01:03:25,039
challenge well continue to push the

01:03:23,359 --> 01:03:26,750
boundaries not only to make Astra's

01:03:25,039 --> 01:03:28,700
cooler faster and more technologically

01:03:26,750 --> 01:03:30,259
feature-rich but to make asterisk and

01:03:28,700 --> 01:03:32,569
web communications even easier and

01:03:30,259 --> 01:03:35,950
together we'll change the way the world

01:03:32,569 --> 01:03:35,950
communicates again

01:04:17,470 --> 01:04:24,070
but on stats that every way this is the

01:04:20,710 --> 01:04:26,230
way to better utilize all your resources

01:04:24,070 --> 01:04:29,560
and it makes managing all your resources

01:04:26,230 --> 01:04:33,420
pretty easy all of the innovation is

01:04:29,560 --> 01:04:36,910
happening in open source the

01:04:33,420 --> 01:04:38,680
collaborative nature and of the you know

01:04:36,910 --> 01:04:40,630
of the community and and the speed at

01:04:38,680 --> 01:04:42,520
which these are these you know these

01:04:40,630 --> 01:04:44,470
these deficiencies these bugs are

01:04:42,520 --> 01:04:46,570
getting discovered and then fixed is

01:04:44,470 --> 01:04:48,490
there anything that really shows the

01:04:46,570 --> 01:04:51,250
power of the you know of the open source

01:04:48,490 --> 01:04:53,430
community it is global and it's

01:04:51,250 --> 01:04:56,950
definitely because of the users

01:04:53,430 --> 01:05:02,590
community people are extremely friendly

01:04:56,950 --> 01:05:04,450
and they're always ready to help if you

01:05:02,590 --> 01:05:06,760
go an entire CNE day you'll see these

01:05:04,450 --> 01:05:08,490
guys helping each other out and they're

01:05:06,760 --> 01:05:11,200
all doing it like in a selfless manner

01:05:08,490 --> 01:05:14,190
the product is transparent for everyone

01:05:11,200 --> 01:05:16,810
everyone can look at the codebase

01:05:14,190 --> 01:05:18,880
everyone can see how cloud stack is

01:05:16,810 --> 01:05:19,690
being built nothing nothing is

01:05:18,880 --> 01:05:25,119
proprietary

01:05:19,690 --> 01:05:27,520
everything is open in many ways it's

01:05:25,119 --> 01:05:32,200
absolutely vital to the be ongoing

01:05:27,520 --> 01:05:36,400
health of cloud stack the most exciting

01:05:32,200 --> 01:05:39,280
event in recent memory for me was our

01:05:36,400 --> 01:05:42,100
first developer boot camp

01:05:39,280 --> 01:05:45,520
our call gave people and maybe two weeks

01:05:42,100 --> 01:05:49,840
notice to come attend I was expecting 25

01:05:45,520 --> 01:05:53,800
or 30 people so we ended up with 87

01:05:49,840 --> 01:05:56,200
people and had to go get more chairs in

01:05:53,800 --> 01:05:58,300
the room twice everything within cloud

01:05:56,200 --> 01:06:01,360
computing is commodity and is

01:05:58,300 --> 01:06:04,360
open-source and so I don't think that

01:06:01,360 --> 01:06:06,100
you will you'll see anywhere where open

01:06:04,360 --> 01:06:09,130
source is not pervasive in cloud

01:06:06,100 --> 01:06:11,830
computing and so I think it's I think

01:06:09,130 --> 01:06:13,210
it's an assumption I think when you talk

01:06:11,830 --> 01:06:14,380
about cloud computing you're really

01:06:13,210 --> 01:06:19,300
talking about it in source cloud

01:06:14,380 --> 01:06:22,480
computing cloud sack is a robust

01:06:19,300 --> 01:06:24,760
solution for large deployments you have

01:06:22,480 --> 01:06:28,080
dozens of data centers and thousands of

01:06:24,760 --> 01:06:31,330
servers in each data centers these

01:06:28,080 --> 01:06:34,660
hardware is gonna fail and cloud stack

01:06:31,330 --> 01:06:37,630
is designed to handle number one that

01:06:34,660 --> 01:06:39,610
mass scale number two it's designed to

01:06:37,630 --> 01:06:43,270
handle the failure that inevitably

01:06:39,610 --> 01:06:46,290
happens in large deployments we started

01:06:43,270 --> 01:06:50,110
working on contact over four years ago

01:06:46,290 --> 01:06:52,540
it was the original set of people

01:06:50,110 --> 01:06:54,460
working on it and a background of

01:06:52,540 --> 01:06:58,270
delivering software to telcos and

01:06:54,460 --> 01:07:01,810
service providers lots of QA lots of

01:06:58,270 --> 01:07:05,710
users actually using it high

01:07:01,810 --> 01:07:08,500
availability is a key feature multiple

01:07:05,710 --> 01:07:10,690
hypervisor support different network

01:07:08,500 --> 01:07:11,230
models we can pick up whatever suits you

01:07:10,690 --> 01:07:13,870
better

01:07:11,230 --> 01:07:17,040
well that management server can be

01:07:13,870 --> 01:07:19,840
deployed in different physical machines

01:07:17,040 --> 01:07:21,490
it definitely has a huge footprint it's

01:07:19,840 --> 01:07:26,890
being deployed everywhere there's a

01:07:21,490 --> 01:07:28,620
major movie studio that they were using

01:07:26,890 --> 01:07:31,840
cloud stack they were using it to

01:07:28,620 --> 01:07:33,970
transcribe video and I thought that was

01:07:31,840 --> 01:07:35,350
terribly fascinating what I found more

01:07:33,970 --> 01:07:38,560
fascinating is what they did during

01:07:35,350 --> 01:07:41,350
lunch where they would spin up you know

01:07:38,560 --> 01:07:42,730
50 or 60 game servers then as soon as

01:07:41,350 --> 01:07:44,190
lunch was over they would destroy all

01:07:42,730 --> 01:07:47,880
the instances and

01:07:44,190 --> 01:07:49,680
doing real work CloudStack is vast

01:07:47,880 --> 01:07:51,240
it touches so many different aspects and

01:07:49,680 --> 01:07:53,400
there's no one person that's kind of

01:07:51,240 --> 01:07:56,970
like a master of all those realms

01:07:53,400 --> 01:07:59,609
I think CloudStack as a project is going

01:07:56,970 --> 01:08:03,410
to be one of the leaders simply because

01:07:59,609 --> 01:08:09,930
it's some of the most feature fully and

01:08:03,410 --> 01:08:13,310
and robust platforms out there I don't

01:08:09,930 --> 01:08:13,310
see your limits for the clouds dag

01:08:26,130 --> 01:08:28,190

YouTube URL: https://www.youtube.com/watch?v=byl_CoucJE0


