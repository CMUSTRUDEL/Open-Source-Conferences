Title: 2012 SouthEast LinuxFest - ODBC - Sheeri Cabral - Optimizing Queries with MySQL Explain
Publication date: 2014-06-30
Playlist: 2012 SouthEast LinuxFest - ODBC Un-Conference
Description: 
	2012 SouthEast LinuxFest
Open Database Camp (ODBC)

Sheeri Cabral - Optimizing Queries with MySQL Explain
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,449
thank the following diamond sponsors in

00:00:21,320 --> 00:00:26,970
2012 for helping make these videos

00:00:23,449 --> 00:00:29,820
possible so optimizing queries with

00:00:26,970 --> 00:00:32,219
mysql explain explain is an SQL

00:00:29,820 --> 00:00:34,860
extension yeah see that's gonna just lop

00:00:32,219 --> 00:00:37,469
it off the Firefox logo it's an SQL

00:00:34,860 --> 00:00:40,020
extension its select only except in 5.6

00:00:37,469 --> 00:00:42,090
and mysql 5.6 you can actually do and

00:00:40,020 --> 00:00:45,390
explain on inserts updates and deletes

00:00:42,090 --> 00:00:47,670
as well before mysql 5.6 since that's

00:00:45,390 --> 00:00:49,379
not even in beta yet you can modify

00:00:47,670 --> 00:00:50,700
other statements like you can modify an

00:00:49,379 --> 00:00:53,070
update statement to be a select

00:00:50,700 --> 00:00:54,780
statement you put the word explain right

00:00:53,070 --> 00:00:57,690
in front of the Select statement and

00:00:54,780 --> 00:01:00,000
that's how it happens what it shows it

00:00:57,690 --> 00:01:01,770
shows how many tables are used how many

00:01:00,000 --> 00:01:03,329
tables are joined how ta de is looked up

00:01:01,770 --> 00:01:05,880
and if there are sub queries unions and

00:01:03,329 --> 00:01:08,100
sorts it shows if you use a where clause

00:01:05,880 --> 00:01:10,140
it shows if use the word distinct it

00:01:08,100 --> 00:01:11,880
shows a possible and actual indexes use

00:01:10,140 --> 00:01:14,040
the length of the index that's actually

00:01:11,880 --> 00:01:17,430
used the approximate number of records

00:01:14,040 --> 00:01:19,259
examined and then it uses metadata about

00:01:17,430 --> 00:01:22,350
cardinality and stuff so if you are

00:01:19,259 --> 00:01:23,729
using an storage engine like you know DB

00:01:22,350 --> 00:01:25,710
that has approximate metadata you're

00:01:23,729 --> 00:01:27,900
going to get not as good of an

00:01:25,710 --> 00:01:30,090
optimization plan is if you use mice and

00:01:27,900 --> 00:01:33,840
with exact data of course my Isom has

00:01:30,090 --> 00:01:35,460
its own problems so this is what the

00:01:33,840 --> 00:01:38,960
output of explain looks like is this

00:01:35,460 --> 00:01:43,500
similar to what you you're used to

00:01:38,960 --> 00:01:45,149
seeing yeah and yeah so this is what it

00:01:43,500 --> 00:01:47,130
looks like the first row is just the ID

00:01:45,149 --> 00:01:48,840
starts with one then goes to two three

00:01:47,130 --> 00:01:51,000
four that kind of thing select type

00:01:48,840 --> 00:01:53,159
we'll talk about that that's just so

00:01:51,000 --> 00:01:55,320
it's a sequential identifier select type

00:01:53,159 --> 00:01:57,420
is either simple it's either one table

00:01:55,320 --> 00:01:59,189
or you know joins then you could have

00:01:57,420 --> 00:02:01,079
primary which is the first select in the

00:01:59,189 --> 00:02:04,200
union or the outer query of a sub query

00:02:01,079 --> 00:02:07,350
and have Union and union result and

00:02:04,200 --> 00:02:09,149
things like so that's what like a union

00:02:07,350 --> 00:02:11,140
would look like it has primary union and

00:02:09,149 --> 00:02:14,319
then union result is like the third

00:02:11,140 --> 00:02:15,700
and a ghost table there other ones are

00:02:14,319 --> 00:02:18,760
dependent Union dependent sub-query

00:02:15,700 --> 00:02:20,920
derived and on cacheable sub-query the

00:02:18,760 --> 00:02:22,959
table is the table name or alias used so

00:02:20,920 --> 00:02:25,360
one thing is I a lot of people in their

00:02:22,959 --> 00:02:27,310
code well at least things like t1 and t2

00:02:25,360 --> 00:02:28,209
and that gets really tough in an

00:02:27,310 --> 00:02:31,870
explaining plan I feel like I've got

00:02:28,209 --> 00:02:33,850
seven things here what's PQRS again and

00:02:31,870 --> 00:02:35,530
you know you'll have a null table if you

00:02:33,850 --> 00:02:37,989
don't actually have a table reference

00:02:35,530 --> 00:02:39,340
type is the data access method this is

00:02:37,989 --> 00:02:40,930
what you want to get as good as possible

00:02:39,340 --> 00:02:42,760
and this is where you look at a

00:02:40,930 --> 00:02:44,440
reference sheet or this is where the

00:02:42,760 --> 00:02:46,630
presentation gets to be an hour long of

00:02:44,440 --> 00:02:48,250
explaining all the different types so

00:02:46,630 --> 00:02:49,900
you have all which is a full table scan

00:02:48,250 --> 00:02:52,300
index which is full in next scan range

00:02:49,900 --> 00:02:54,340
you know so I go through all this kind

00:02:52,300 --> 00:02:56,440
of stuff one important thing about MySQL

00:02:54,340 --> 00:02:58,630
so here's an example of a range query

00:02:56,440 --> 00:03:00,700
you know we're rental date between this

00:02:58,630 --> 00:03:03,010
and that but why isn't this one a range

00:03:00,700 --> 00:03:07,739
query do you do either of you guys know

00:03:03,010 --> 00:03:07,739
why this bottom one is not a range query

00:03:12,990 --> 00:03:15,870
she said because it doesn't know to

00:03:14,460 --> 00:03:17,340
transform one query do you ever know I

00:03:15,870 --> 00:03:19,860
mean if you type this in and explain

00:03:17,340 --> 00:03:23,850
select rental ID from rental it wouldn't

00:03:19,860 --> 00:03:26,880
show you range nope not times on

00:03:23,850 --> 00:03:30,600
dependent someone who's a MySQL Tim do

00:03:26,880 --> 00:03:33,140
you know I this bottom one isn't that's

00:03:30,600 --> 00:03:35,430
because MySQL does not have materialized

00:03:33,140 --> 00:03:37,560
views and therefore it also does not

00:03:35,430 --> 00:03:40,040
have functional indexes so it cannot

00:03:37,560 --> 00:03:42,780
actually take this date of rental date

00:03:40,040 --> 00:03:45,090
this this is just it has to go through

00:03:42,780 --> 00:03:49,070
every single rental date apply the date

00:03:45,090 --> 00:03:49,070
function so we can't use an index on it

00:03:50,660 --> 00:03:56,250
Maria DB does have what it's called

00:03:53,640 --> 00:03:58,020
virtual columns right which can be

00:03:56,250 --> 00:03:59,700
persistent or not so it does have

00:03:58,020 --> 00:04:01,620
materialized views in that kind of a way

00:03:59,700 --> 00:04:03,510
it materializes and you can use

00:04:01,620 --> 00:04:05,940
functional indexes in Maria DB that was

00:04:03,510 --> 00:04:08,610
the comment so MySQL doesn't have this

00:04:05,940 --> 00:04:12,980
yet but I don't see on the road map for

00:04:08,610 --> 00:04:16,920
56 but Maria DB does have it in version

00:04:12,980 --> 00:04:21,120
52 which is a five dot one compatible

00:04:16,920 --> 00:04:22,590
MySQL so more types index sub-query

00:04:21,120 --> 00:04:24,300
unique sub-query these are things you

00:04:22,590 --> 00:04:27,740
might see index merge you know this is

00:04:24,300 --> 00:04:31,110
all going you know refere null full-text

00:04:27,740 --> 00:04:32,460
ref eq ref this is all going in terms of

00:04:31,110 --> 00:04:34,440
worst to best the worst of the full

00:04:32,460 --> 00:04:37,440
table scan I talked about that first the

00:04:34,440 --> 00:04:39,210
fastest one is constant system there's

00:04:37,440 --> 00:04:41,610
also constant propagation so for example

00:04:39,210 --> 00:04:43,200
in here we haven't explained says

00:04:41,610 --> 00:04:44,700
returned a explain returned a first name

00:04:43,200 --> 00:04:46,170
us and from rental inter joined customer

00:04:44,700 --> 00:04:48,780
using customer ID wear rental ID equals

00:04:46,170 --> 00:04:50,700
1 35 34 so what it does is it looks at

00:04:48,780 --> 00:04:52,230
the rental table first it uses the

00:04:50,700 --> 00:04:55,350
primary key which happens to be on

00:04:52,230 --> 00:04:57,330
rental ID it reads one row and then what

00:04:55,350 --> 00:04:59,310
it does is then it joins it to the

00:04:57,330 --> 00:05:01,500
customer table but because this is on a

00:04:59,310 --> 00:05:03,900
primary key so at max it's going to

00:05:01,500 --> 00:05:05,310
return one row the explain plan actually

00:05:03,900 --> 00:05:08,550
knows that it's going to have a constant

00:05:05,310 --> 00:05:11,100
here because it knows at most it's going

00:05:08,550 --> 00:05:13,740
to have one row returned from this part

00:05:11,100 --> 00:05:15,450
of the query so it's this called

00:05:13,740 --> 00:05:17,280
constant propagation because the

00:05:15,450 --> 00:05:19,230
constant is propagated because if

00:05:17,280 --> 00:05:20,820
there's a most one customer ID because

00:05:19,230 --> 00:05:26,379
it's a primary key which is unique not

00:05:20,820 --> 00:05:28,460
no nude I'm sorry

00:05:26,379 --> 00:05:29,990
the con was there's no increase in

00:05:28,460 --> 00:05:32,720
carnality right because this is a

00:05:29,990 --> 00:05:34,669
primary key if this was not a primary

00:05:32,720 --> 00:05:37,310
key if it was just an index then it

00:05:34,669 --> 00:05:38,810
wouldn't it wouldn't be a constant

00:05:37,310 --> 00:05:40,280
propagation but it would know that it

00:05:38,810 --> 00:05:41,870
would it would only propagate an X

00:05:40,280 --> 00:05:50,990
number of rows you know depending on the

00:05:41,870 --> 00:05:55,849
metadata right it's it's basically like

00:05:50,990 --> 00:05:58,280
it finds it would yeah it would find it

00:05:55,849 --> 00:06:00,889
would find the customer ID let's say the

00:05:58,280 --> 00:06:02,810
customer ID with this rental ideas to it

00:06:00,889 --> 00:06:03,919
would then basically do the query

00:06:02,810 --> 00:06:05,900
instead of doing a joint that's

00:06:03,919 --> 00:06:07,129
absolutely right the comment was it

00:06:05,900 --> 00:06:08,900
doesn't do a joint and he's right it

00:06:07,129 --> 00:06:11,389
doesn't instead of doing a joint they'll

00:06:08,900 --> 00:06:12,680
find the customer ID and then look in

00:06:11,389 --> 00:06:14,539
the table for that customer ID so it

00:06:12,680 --> 00:06:16,909
actually removes the need to the joint

00:06:14,539 --> 00:06:18,229
there's also no data access strategy

00:06:16,909 --> 00:06:19,789
which is technically the fastest so if

00:06:18,229 --> 00:06:21,560
you do again like select one plus two

00:06:19,789 --> 00:06:24,289
that doesn't have a data access strategy

00:06:21,560 --> 00:06:25,969
because not accessing any data there are

00:06:24,289 --> 00:06:28,310
indexes it shows you the possible keys

00:06:25,969 --> 00:06:30,169
the actual key used and then the key

00:06:28,310 --> 00:06:31,639
length so one of the ways that you can

00:06:30,169 --> 00:06:33,620
debug a query is you can say why isn't

00:06:31,639 --> 00:06:35,330
even trying to use why is this index

00:06:33,620 --> 00:06:37,279
that I think it should use it's not even

00:06:35,330 --> 00:06:41,060
in the possible keys you kind of debug

00:06:37,279 --> 00:06:43,000
it that way and then the number of rows

00:06:41,060 --> 00:06:45,110
is approximate number of rows examined

00:06:43,000 --> 00:06:47,000
and if you use a limit it doesn't

00:06:45,110 --> 00:06:49,069
actually change that even though like if

00:06:47,000 --> 00:06:50,419
you did limit ten here it would stop

00:06:49,069 --> 00:06:52,460
after got 210 row so it would only

00:06:50,419 --> 00:06:55,250
examine X number of rows until got so

00:06:52,460 --> 00:06:56,870
the 10 that that do it in this case

00:06:55,250 --> 00:06:59,839
there's no where clause so we know that

00:06:56,870 --> 00:07:01,279
it would examine 10 at most right so

00:06:59,839 --> 00:07:02,120
yeah so if even though it affects the

00:07:01,279 --> 00:07:06,460
number of rows that are actually

00:07:02,120 --> 00:07:06,460
examined in the explain that doesn't

00:07:10,710 --> 00:07:15,160
right limit is the comment is limited

00:07:13,600 --> 00:07:16,360
was applied afterward so you might

00:07:15,160 --> 00:07:18,190
actually have to do that in this query

00:07:16,360 --> 00:07:19,780
it's not because there is no sorting or

00:07:18,190 --> 00:07:21,490
filtering but that you're absolutely

00:07:19,780 --> 00:07:25,210
right and that's why I explained doesn't

00:07:21,490 --> 00:07:26,620
show that because it can't does it

00:07:25,210 --> 00:07:28,419
change the plan if there is a limit no

00:07:26,620 --> 00:07:30,880
because the limit is applied afterwards

00:07:28,419 --> 00:07:33,370
or rather it's applied after the plan is

00:07:30,880 --> 00:07:35,530
made the plan is made without regards to

00:07:33,370 --> 00:07:36,850
limit and then when the execution

00:07:35,530 --> 00:07:38,650
happens the limit is applied so you

00:07:36,850 --> 00:07:40,690
don't actually have to do all of it so

00:07:38,650 --> 00:07:44,530
you can kind of get a false execute a

00:07:40,690 --> 00:07:46,090
query plan because of that limit yeah

00:07:44,530 --> 00:07:47,650
and then there's extra there's more

00:07:46,090 --> 00:07:49,150
stuff there's a field called extra which

00:07:47,650 --> 00:07:51,100
you know has a bunch of stuff whether

00:07:49,150 --> 00:07:52,750
you wear weddings indistinct whether

00:07:51,100 --> 00:07:55,240
using no tables whether you have

00:07:52,750 --> 00:07:57,250
impossible where notice after reading

00:07:55,240 --> 00:07:58,570
console tables what that means if you

00:07:57,250 --> 00:08:00,880
have something where like you have an

00:07:58,570 --> 00:08:04,090
auto increment ID and you say like where

00:08:00,880 --> 00:08:07,000
ID is negative for it will know that the

00:08:04,090 --> 00:08:09,190
ID values go from 1 to 100 so negative 4

00:08:07,000 --> 00:08:10,720
is even a possible value it'll say

00:08:09,190 --> 00:08:12,669
impossible where notice after reading

00:08:10,720 --> 00:08:14,530
cons tables that doesn't mean it's bad

00:08:12,669 --> 00:08:17,289
it just means I know that I won't be

00:08:14,530 --> 00:08:18,520
able to satisfy your query without even

00:08:17,289 --> 00:08:20,530
having to go to the data there's some

00:08:18,520 --> 00:08:22,539
not exists all this kind of stuff

00:08:20,530 --> 00:08:24,220
there's lots and lots of stuff where you

00:08:22,539 --> 00:08:25,870
should you know you'll just look at the

00:08:24,220 --> 00:08:27,610
manual because I just wanted to give in

00:08:25,870 --> 00:08:29,289
a short example before we talk about

00:08:27,610 --> 00:08:32,440
like the limit the limitations and all

00:08:29,289 --> 00:08:34,180
that kind of stuff my school isn't so

00:08:32,440 --> 00:08:37,810
good with sub queries back 14 sub

00:08:34,180 --> 00:08:39,729
queries were first put in in 4.1 mysql

00:08:37,810 --> 00:08:41,950
treated every single sub query as a

00:08:39,729 --> 00:08:43,779
dependent sub query which means that for

00:08:41,950 --> 00:08:46,750
every row in the outer query it ran the

00:08:43,779 --> 00:08:48,220
inner query wants which is usually not

00:08:46,750 --> 00:08:49,390
how you want it especially because it

00:08:48,220 --> 00:08:50,589
has kind of the inner query has

00:08:49,390 --> 00:08:52,450
parentheses around it so you kind of

00:08:50,589 --> 00:08:55,480
wanted to be mathematical you wanted to

00:08:52,450 --> 00:08:58,140
say oh well I will I will run this

00:08:55,480 --> 00:09:00,550
statement once and then go to and then

00:08:58,140 --> 00:09:03,250
get the answer and do kind of like the

00:09:00,550 --> 00:09:07,750
constant propagation that's kind of how

00:09:03,250 --> 00:09:09,640
you want it to be so sub queries are

00:09:07,750 --> 00:09:11,320
getting better all the time Maria DB has

00:09:09,640 --> 00:09:15,120
some really good sub query optimizations

00:09:11,320 --> 00:09:18,880
in 53 which is again a 5-1 compatible

00:09:15,120 --> 00:09:20,890
mysql and you can also explain

00:09:18,880 --> 00:09:23,170
partitions to explain extended explain

00:09:20,890 --> 00:09:24,100
extent it adds a filtered field it's

00:09:23,170 --> 00:09:26,170
called filtered

00:09:24,100 --> 00:09:27,550
which is an approximate percent of how

00:09:26,170 --> 00:09:29,769
many's the exam and rose will be

00:09:27,550 --> 00:09:33,040
returned so for example here's an

00:09:29,769 --> 00:09:35,500
explain extended you know rose 326 but

00:09:33,040 --> 00:09:37,660
filtered is 70 5.15 so it's about how

00:09:35,500 --> 00:09:39,970
many about 75% of the Rose it actually

00:09:37,660 --> 00:09:41,350
looks like will be returned if that

00:09:39,970 --> 00:09:42,819
filtered is low you might want to be

00:09:41,350 --> 00:09:44,290
like well why wouldn't you return most

00:09:42,819 --> 00:09:48,399
of what you're using is there not a good

00:09:44,290 --> 00:09:52,600
index that kind of thing so yeah there's

00:09:48,399 --> 00:09:54,459
more information in other places so

00:09:52,600 --> 00:09:56,740
that's all I have on that the I do have

00:09:54,459 --> 00:09:58,480
some of the optimizations in 56 I

00:09:56,740 --> 00:10:02,079
already said the insert updates and

00:09:58,480 --> 00:10:04,029
deletes can be used as select queries

00:10:02,079 --> 00:10:06,130
you can also instead of getting in that

00:10:04,029 --> 00:10:09,190
table format that i showed you can get

00:10:06,130 --> 00:10:10,930
in JSON format which would be nice if

00:10:09,190 --> 00:10:12,819
you are a developer and want to kind of

00:10:10,930 --> 00:10:14,680
put that in some kind of I don't know

00:10:12,819 --> 00:10:18,190
you want to do something JSON II with it

00:10:14,680 --> 00:10:20,620
you can do that there's also a better

00:10:18,190 --> 00:10:23,980
sub query optimization so it's coming in

00:10:20,620 --> 00:10:26,410
56 it's already in Maria TV 53 and then

00:10:23,980 --> 00:10:28,810
you also have with one of the biggest

00:10:26,410 --> 00:10:30,550
ones is having an optimizer trace so

00:10:28,810 --> 00:10:32,620
what you can do is you can run a query

00:10:30,550 --> 00:10:35,319
and it will tell you every possible plan

00:10:32,620 --> 00:10:38,259
it looked at so you can see like to look

00:10:35,319 --> 00:10:40,120
at this plan but not actually not

00:10:38,259 --> 00:10:42,910
actually implement it let me see if I

00:10:40,120 --> 00:10:44,829
can find a manual page on it you also

00:10:42,910 --> 00:10:46,360
have better statistics you can see did

00:10:44,829 --> 00:10:48,009
it consider joining this today

00:10:46,360 --> 00:10:50,110
considered doing a prune what did it

00:10:48,009 --> 00:10:54,069
consider so you could do something like

00:10:50,110 --> 00:10:55,750
run on mysql 5.6 slave that's not in

00:10:54,069 --> 00:10:57,100
production it's just a slave and then

00:10:55,750 --> 00:11:00,339
you can kind of run queries against it

00:10:57,100 --> 00:11:01,810
to say you know what the optimization

00:11:00,339 --> 00:11:04,029
for it would be in 56 and then you can

00:11:01,810 --> 00:11:05,439
apply it back even if your masters 51 or

00:11:04,029 --> 00:11:09,180
something like that so you can kind of

00:11:05,439 --> 00:11:13,990
use it as a DBA slave my SQL optimizer

00:11:09,180 --> 00:11:16,290
trace explain I should probably put 5.6

00:11:13,990 --> 00:11:16,290
in there

00:11:16,760 --> 00:11:21,000
nice cool internals optimizer training

00:11:19,230 --> 00:11:22,320
here we go yeah tracing capability has

00:11:21,000 --> 00:11:24,440
been added to the mysql optimizer let's

00:11:22,320 --> 00:11:30,630
see if we can find a quick example

00:11:24,440 --> 00:11:36,960
you're welcome have a good one let's see

00:11:30,630 --> 00:11:39,570
if I've internets I do have internets so

00:11:36,960 --> 00:11:41,550
here's a trace table you get the query

00:11:39,570 --> 00:11:43,560
the trace and race in JSON format

00:11:41,550 --> 00:11:48,420
missing bytes beyond maximum size

00:11:43,560 --> 00:11:50,220
missing privileges so here's how let's

00:11:48,420 --> 00:11:53,280
see just trying to see if we can get an

00:11:50,220 --> 00:11:55,850
example have an example here's an

00:11:53,280 --> 00:11:58,950
example tracing of order and group by

00:11:55,850 --> 00:12:00,750
simplification so here's an insert

00:11:58,950 --> 00:12:06,090
inserts a bunch of things creates

00:12:00,750 --> 00:12:07,290
inserts now we look at the trace so yeah

00:12:06,090 --> 00:12:09,660
it looks like you have to kind of spend

00:12:07,290 --> 00:12:13,650
some time with it it's definitely JSON

00:12:09,660 --> 00:12:15,240
format join preparation condition

00:12:13,650 --> 00:12:17,910
processing original condition

00:12:15,240 --> 00:12:19,230
transformation so it's a lot of

00:12:17,910 --> 00:12:21,960
information here that you didn't get

00:12:19,230 --> 00:12:23,940
before which is kind of neat but now I

00:12:21,960 --> 00:12:25,890
want to turn it over you if you want to

00:12:23,940 --> 00:12:28,370
talk a little bit about explaining

00:12:25,890 --> 00:12:28,370
postgres

00:12:38,180 --> 00:12:41,180
sure

00:13:14,160 --> 00:13:18,870
so the question is if you're you know

00:13:16,620 --> 00:13:21,509
doing say load testing and you fire this

00:13:18,870 --> 00:13:26,430
fire the same query over and over and

00:13:21,509 --> 00:13:28,740
over does MySQL redo the execution plan

00:13:26,430 --> 00:13:30,449
or the optimizer stuff for every single

00:13:28,740 --> 00:13:34,399
time you run that I believe the answers

00:13:30,449 --> 00:13:36,720
yes I believe it does every single time

00:13:34,399 --> 00:13:39,870
every single time you do it I believe

00:13:36,720 --> 00:13:41,399
that happens there's no compilation or

00:13:39,870 --> 00:13:42,750
anything like that unless you're using

00:13:41,399 --> 00:13:46,889
the query cache but then it doesn't do

00:13:42,750 --> 00:13:48,240
any execution every month if it's the

00:13:46,889 --> 00:13:52,250
exact same query yeah there's no kind of

00:13:48,240 --> 00:13:52,250
compiling of the query plan that it does

00:13:53,149 --> 00:13:58,740
there's parameterised queries but that's

00:13:55,829 --> 00:14:00,439
different and that does cash it but

00:13:58,740 --> 00:14:03,870
there but that's only once per session

00:14:00,439 --> 00:14:05,670
anyway so if you if there's a like you

00:14:03,870 --> 00:14:07,139
have not using connection pooling so

00:14:05,670 --> 00:14:08,670
you're doing like you know PHP or Python

00:14:07,139 --> 00:14:10,740
without connection pools you just

00:14:08,670 --> 00:14:14,930
connect run the query and go back you're

00:14:10,740 --> 00:14:18,110
actually going to have extra overhead so

00:14:14,930 --> 00:14:18,110
so great

00:14:29,500 --> 00:14:31,560
you

00:14:49,200 --> 00:14:51,260
you

00:14:54,459 --> 00:14:59,540
when we created asterisk over a decade

00:14:57,170 --> 00:15:01,490
ago we could not have imagined that

00:14:59,540 --> 00:15:03,709
asterisk would not only become the most

00:15:01,490 --> 00:15:05,839
widely adopted open source communication

00:15:03,709 --> 00:15:07,880
software on the planet but that it would

00:15:05,839 --> 00:15:10,399
impact the entire industry in the way

00:15:07,880 --> 00:15:12,380
that it has today asterisk has found its

00:15:10,399 --> 00:15:15,019
way in the more than 170 countries and

00:15:12,380 --> 00:15:16,970
virtually every fortune 1000 company the

00:15:15,019 --> 00:15:19,040
success of asterisk has enabled a

00:15:16,970 --> 00:15:20,449
transition of power from the hands of

00:15:19,040 --> 00:15:22,730
the traditional proprietary phone

00:15:20,449 --> 00:15:25,130
vendors into the hands of the users and

00:15:22,730 --> 00:15:27,199
administrators of phone systems using

00:15:25,130 --> 00:15:28,850
this power our customers have traded all

00:15:27,199 --> 00:15:30,949
sorts of business changing applications

00:15:28,850 --> 00:15:32,720
from small office phone systems to

00:15:30,949 --> 00:15:34,819
mission-critical call centers the

00:15:32,720 --> 00:15:36,649
international carrier networks in fact

00:15:34,819 --> 00:15:38,120
there's even an entire country those

00:15:36,649 --> 00:15:40,579
communications infrastructure runs on

00:15:38,120 --> 00:15:42,529
esters the gym has always been about

00:15:40,579 --> 00:15:44,240
creating technology that expands

00:15:42,529 --> 00:15:46,399
communications capabilities in ways that

00:15:44,240 --> 00:15:47,600
we could never have imagined and that's

00:15:46,399 --> 00:15:50,000
part of what's game-changing about

00:15:47,600 --> 00:15:52,670
Digium today we're doing it again this

00:15:50,000 --> 00:15:54,769
time by introducing a new family of HD

00:15:52,670 --> 00:15:56,899
IP phones that extends control of the

00:15:54,769 --> 00:15:58,639
user all the way to the desktop the

00:15:56,899 --> 00:16:00,350
launch of these new products represents

00:15:58,639 --> 00:16:02,449
the next phase indigenous history of

00:16:00,350 --> 00:16:04,850
innovation these are the first and only

00:16:02,449 --> 00:16:06,199
IP phones designed to fully leverage the

00:16:04,850 --> 00:16:07,880
power of esther's when we first

00:16:06,199 --> 00:16:09,529
discussed our expectations for building

00:16:07,880 --> 00:16:12,139
a family of phones for use with asterisk

00:16:09,529 --> 00:16:13,939
our requirements were pretty simple we

00:16:12,139 --> 00:16:15,680
asked the team to build the phones such

00:16:13,939 --> 00:16:17,870
that they were easy to install integrate

00:16:15,680 --> 00:16:19,730
provision and use I think you'll soon

00:16:17,870 --> 00:16:22,279
agree our engineers have delivered on

00:16:19,730 --> 00:16:23,930
that goal user feedback is validating

00:16:22,279 --> 00:16:26,029
that when it comes to operation with

00:16:23,930 --> 00:16:28,459
astro space systems including our own

00:16:26,029 --> 00:16:31,040
Switchvox based product these are the

00:16:28,459 --> 00:16:32,329
easiest to use best integrated most

00:16:31,040 --> 00:16:34,939
interoperable products on the market

00:16:32,329 --> 00:16:36,910
today the Digium family of phones will

00:16:34,939 --> 00:16:39,019
initially include three IP des hommes

00:16:36,910 --> 00:16:40,910
uniquely designed to complement any

00:16:39,019 --> 00:16:42,800
asterisk or switch box based solution

00:16:40,910 --> 00:16:45,470
these phones are different for a number

00:16:42,800 --> 00:16:48,110
of reasons first there is clue sively

00:16:45,470 --> 00:16:49,550
designed for use with esters secondly

00:16:48,110 --> 00:16:51,160
we've made it really easy to

00:16:49,550 --> 00:16:53,540
autodiscover and provision the phones

00:16:51,160 --> 00:16:55,639
next we've made it easy for the phones

00:16:53,540 --> 00:16:57,589
to access information inside of asterisk

00:16:55,639 --> 00:16:59,170
allowing tight coupling between an

00:16:57,589 --> 00:17:01,160
application and the

00:16:59,170 --> 00:17:03,320
additionally we've created an

00:17:01,160 --> 00:17:05,450
applications engineer that allows users

00:17:03,320 --> 00:17:08,660
and developers to create and run their

00:17:05,450 --> 00:17:10,430
own apps on the phone and finally we've

00:17:08,660 --> 00:17:12,410
done all of this at a very compelling

00:17:10,430 --> 00:17:14,090
price point at Digium we're always

00:17:12,410 --> 00:17:16,190
thinking of ways to give our customers

00:17:14,090 --> 00:17:18,740
the best value in business phone systems

00:17:16,190 --> 00:17:20,300
and also give them the power to create

00:17:18,740 --> 00:17:22,430
their own solutions or any

00:17:20,300 --> 00:17:24,170
communications challenge well continue

00:17:22,430 --> 00:17:25,580
to push the boundaries not only to make

00:17:24,170 --> 00:17:27,650
Astra's cooler faster and more

00:17:25,580 --> 00:17:29,270
technologically feature-rich but to make

00:17:27,650 --> 00:17:31,730
asterisk employed communications even

00:17:29,270 --> 00:17:34,870
easier and together we'll change the way

00:17:31,730 --> 00:17:34,870
the world communication again

00:17:45,860 --> 00:17:52,679
how's that sigh every way this is the

00:17:49,380 --> 00:17:54,840
way to better utilize all your resources

00:17:52,679 --> 00:17:58,320
and it makes managing all your resources

00:17:54,840 --> 00:18:02,150
pretty easy all of the innovation is

00:17:58,320 --> 00:18:05,640
happening in open source the

00:18:02,150 --> 00:18:07,470
collaborative nature and of the you know

00:18:05,640 --> 00:18:09,570
of the community and the speed at which

00:18:07,470 --> 00:18:11,549
these are these you know these these

00:18:09,570 --> 00:18:13,860
deficiencies these bugs are getting

00:18:11,549 --> 00:18:16,710
discovered and then fixed is the thing

00:18:13,860 --> 00:18:19,710
that really shows the power of the of

00:18:16,710 --> 00:18:22,159
the open source community it is global

00:18:19,710 --> 00:18:25,710
and it's definitely because of the users

00:18:22,159 --> 00:18:31,679
community people are extremely friendly

00:18:25,710 --> 00:18:33,419
and always ready to help if you go on

00:18:31,679 --> 00:18:35,549
tire see any day you'll see these guys

00:18:33,419 --> 00:18:38,250
helping each other out and they're all

00:18:35,549 --> 00:18:39,929
doing it like in a selfless manner the

00:18:38,250 --> 00:18:42,950
product is transparent for everyone

00:18:39,929 --> 00:18:46,110
everyone can look at the code base

00:18:42,950 --> 00:18:48,350
everyone can see how cloud that is being

00:18:46,110 --> 00:18:53,880
built nothing nothing is proprietary

00:18:48,350 --> 00:18:56,460
everything is open in many ways it's

00:18:53,880 --> 00:19:00,960
absolutely vital to the the unborn

00:18:56,460 --> 00:19:05,159
health CloudStack the most exciting

00:19:00,960 --> 00:19:07,950
event in recent memory for me was our

00:19:05,159 --> 00:19:10,649
first developer boot camp

00:19:07,950 --> 00:19:13,289
and our call gave people I gave you two

00:19:10,649 --> 00:19:17,250
weeks notice to come attend I was

00:19:13,289 --> 00:19:21,480
expecting 25 or 30 people so we ended up

00:19:17,250 --> 00:19:24,269
with 87 people and had to go get board

00:19:21,480 --> 00:19:26,789
chairs in the room twice everything

00:19:24,269 --> 00:19:30,029
within cloud computing is commodity and

00:19:26,789 --> 00:19:33,090
is open source and so I don't think that

00:19:30,029 --> 00:19:34,860
you will you'll see anywhere where open

00:19:33,090 --> 00:19:37,889
source is not pervasive in cloud

00:19:34,860 --> 00:19:40,620
computing and so i think it's i think

00:19:37,889 --> 00:19:41,970
it's an assumption i think when you talk

00:19:40,620 --> 00:19:45,679
about cloud computing you're really

00:19:41,970 --> 00:19:45,679
talking about a source cloud computing

00:19:45,980 --> 00:19:52,019
cloud sac is a robust solution for large

00:19:49,260 --> 00:19:54,419
deployments you'll have dozens of data

00:19:52,019 --> 00:19:58,440
centers and thousands of servers in each

00:19:54,419 --> 00:20:01,710
data centers these hardware is going to

00:19:58,440 --> 00:20:04,919
fail and CloudStack is designed to

00:20:01,710 --> 00:20:07,380
handle number one that mass scale number

00:20:04,919 --> 00:20:10,110
two it's designed to handle the failure

00:20:07,380 --> 00:20:12,389
that inevitably happens in large

00:20:10,110 --> 00:20:15,640
deployments we started working on

00:20:12,389 --> 00:20:18,700
college attack over four years ago

00:20:15,640 --> 00:20:21,310
it was the original set of people

00:20:18,700 --> 00:20:23,500
working on it had a background of

00:20:21,310 --> 00:20:27,310
delivering software telcos and service

00:20:23,500 --> 00:20:31,690
providers lots of QA lots of users

00:20:27,310 --> 00:20:34,840
actually using it high availability is

00:20:31,690 --> 00:20:38,410
the key feature multiple hypervisors

00:20:34,840 --> 00:20:40,840
support different network models you can

00:20:38,410 --> 00:20:42,880
pick up whatever suits you better while

00:20:40,840 --> 00:20:46,780
step management server can be deployed

00:20:42,880 --> 00:20:48,580
in different physical machines it

00:20:46,780 --> 00:20:50,230
definitely has a huge footprint it's

00:20:48,580 --> 00:20:55,630
being deployed everywhere there's a

00:20:50,230 --> 00:20:57,360
major movie studio that they were using

00:20:55,630 --> 00:21:00,550
cloudstack they were using it to

00:20:57,360 --> 00:21:02,740
transcode video and I thought that was

00:21:00,550 --> 00:21:04,060
terribly fascinating what I found more

00:21:02,740 --> 00:21:07,330
fascinating is what they did during

00:21:04,060 --> 00:21:10,120
lunch where they would spin up you know

00:21:07,330 --> 00:21:11,470
50 or 60 game servers then as soon as

00:21:10,120 --> 00:21:13,420
lunch was over they would destroy all

00:21:11,470 --> 00:21:17,530
the instances and get back to doing real

00:21:13,420 --> 00:21:18,880
work cloudstack is vast it touches so

00:21:17,530 --> 00:21:20,950
many different aspects and there's no

00:21:18,880 --> 00:21:23,320
one person that's kind of like a master

00:21:20,950 --> 00:21:27,400
of all those realms I think CloudStack

00:21:23,320 --> 00:21:29,650
as a project is going to be one of the

00:21:27,400 --> 00:21:33,730
leaders simply because it's some of the

00:21:29,650 --> 00:21:39,160
most feature fallen and and robust

00:21:33,730 --> 00:21:42,060
platforms out they were Adam senior

00:21:39,160 --> 00:21:42,060
living through the clouds dag

00:21:54,890 --> 00:21:56,950

YouTube URL: https://www.youtube.com/watch?v=wMLUl5GCofs


