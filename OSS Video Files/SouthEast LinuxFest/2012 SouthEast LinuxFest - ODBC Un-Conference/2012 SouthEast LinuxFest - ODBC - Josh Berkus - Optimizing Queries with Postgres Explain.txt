Title: 2012 SouthEast LinuxFest - ODBC - Josh Berkus - Optimizing Queries with Postgres Explain
Publication date: 2014-06-30
Playlist: 2012 SouthEast LinuxFest - ODBC Un-Conference
Description: 
	2012 SouthEast LinuxFest
Open Database Camp (ODBC)

Josh Berkus - Optimizing Queries with Postgres Explain
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,449
thank the following diamond sponsors in

00:00:21,320 --> 00:00:37,520
2012 for helping make these videos

00:00:23,449 --> 00:00:40,469
possible ok yep yeah so the reason yep

00:00:37,520 --> 00:00:42,200
the reason I have a concern about making

00:00:40,469 --> 00:00:45,270
explain accessible to users is because

00:00:42,200 --> 00:00:48,180
postgresql supports a lot more complex

00:00:45,270 --> 00:00:50,039
query syntax than MySQL does and with

00:00:48,180 --> 00:00:53,579
this complex query syntax comes

00:00:50,039 --> 00:00:56,570
additional explained output to the point

00:00:53,579 --> 00:01:02,000
where for example we're seeing here is

00:00:56,570 --> 00:01:05,850
Hubert from Poland we're seeing his eye

00:01:02,000 --> 00:01:08,490
his PHP thing designed to help digest

00:01:05,850 --> 00:01:10,770
your explain plan because for example

00:01:08,490 --> 00:01:14,610
for a sufficiently complicated query

00:01:10,770 --> 00:01:18,509
this is the explain plan in sort of text

00:01:14,610 --> 00:01:20,460
reform and you can see it sort of runs

00:01:18,509 --> 00:01:21,930
off the screen here because this

00:01:20,460 --> 00:01:24,960
particular query I don't know who's this

00:01:21,930 --> 00:01:27,390
is this is off of the the log on there

00:01:24,960 --> 00:01:29,939
this particular query is using some

00:01:27,390 --> 00:01:31,770
common table expressions in it and they

00:01:29,939 --> 00:01:37,710
look to be reasonably complex common

00:01:31,770 --> 00:01:40,290
table expressions the postgres is

00:01:37,710 --> 00:01:42,479
showing you a lot of the similar things

00:01:40,290 --> 00:01:43,970
that my askew all is showing you only

00:01:42,479 --> 00:01:46,020
showing you a little bit more detail

00:01:43,970 --> 00:01:47,460
it's not showing you a couple of other

00:01:46,020 --> 00:01:50,869
things it's not showing you you know

00:01:47,460 --> 00:01:55,250
keys that it considered and didn't use I

00:01:50,869 --> 00:01:57,390
but you know first so for example here

00:01:55,250 --> 00:01:58,860
the whole thing is sort of pictures an

00:01:57,390 --> 00:02:03,600
inverted tree and so for example here

00:01:58,860 --> 00:02:05,670
you get well let's do much simpler

00:02:03,600 --> 00:02:08,220
example when I actually give it but but

00:02:05,670 --> 00:02:10,770
you can actually sort of see the level

00:02:08,220 --> 00:02:12,900
of complexity in here which is why I'm

00:02:10,770 --> 00:02:15,989
concerned about you know how

00:02:12,900 --> 00:02:18,930
we actually represent this to users in a

00:02:15,989 --> 00:02:20,220
way that they can understand it and so

00:02:18,930 --> 00:02:30,920
we're as though there's the terminal

00:02:20,220 --> 00:02:30,920
okay so what happened there

00:02:37,260 --> 00:02:39,920
so

00:02:57,120 --> 00:03:11,069
oh we oh that's why who what happened

00:03:04,739 --> 00:03:15,720
there see if I in try it again so we've

00:03:11,069 --> 00:03:16,980
got lots of options for explain which

00:03:15,720 --> 00:03:21,599
hopefully boots will go in till later

00:03:16,980 --> 00:03:26,480
but i'll do a json format so little heed

00:03:21,599 --> 00:03:26,480
the easier to read on a blown-up screen

00:03:43,010 --> 00:03:46,090
okay what is it

00:03:51,860 --> 00:03:57,340
why is it blowin up oh right don't use

00:03:54,620 --> 00:03:57,340
the equal signs

00:04:16,870 --> 00:04:20,519
can't see for the rapid

00:04:28,550 --> 00:04:34,990
there we go so for example this would

00:04:32,720 --> 00:04:37,010
actually be sort of your simplest plan

00:04:34,990 --> 00:04:40,240
except that we're getting bizarre

00:04:37,010 --> 00:04:40,240
wrapping so homo

00:04:52,240 --> 00:05:04,090
fat well see if I can make this

00:04:56,560 --> 00:05:07,479
cooperate yeah oops and then of course

00:05:04,090 --> 00:05:15,190
it shrinks and then it shrinks in ways I

00:05:07,479 --> 00:05:16,660
don't want it to shrink the other hand

00:05:15,190 --> 00:05:19,539
my linux machine is having issues with

00:05:16,660 --> 00:05:34,360
the projector so you we have our choice

00:05:19,539 --> 00:05:36,610
of Evil's well right because we're

00:05:34,360 --> 00:05:38,560
making it up so so for example here we

00:05:36,610 --> 00:05:41,229
have like your simplest query plan which

00:05:38,560 --> 00:05:44,319
is we're just doing a sec I scan over

00:05:41,229 --> 00:05:49,330
one table to look for a particular value

00:05:44,319 --> 00:05:51,310
so here we have I so for postgres you

00:05:49,330 --> 00:05:53,620
have these different nodes because is

00:05:51,310 --> 00:05:55,360
representing how the planner actually or

00:05:53,620 --> 00:05:58,509
how the executor actually am actually

00:05:55,360 --> 00:06:00,580
execute stuff which is it's just sort of

00:05:58,509 --> 00:06:02,680
functional handing off to independent

00:06:00,580 --> 00:06:04,240
notes and so we're getting the output

00:06:02,680 --> 00:06:06,400
from each different query node that

00:06:04,240 --> 00:06:10,479
executes is a different step in the

00:06:06,400 --> 00:06:12,370
query so this note is what's called a

00:06:10,479 --> 00:06:14,259
sex can which means a full table scan

00:06:12,370 --> 00:06:17,110
the reasons doing a full table scan is

00:06:14,259 --> 00:06:19,539
this tables only about four kilobytes in

00:06:17,110 --> 00:06:24,039
size so it wouldn't really make sense to

00:06:19,539 --> 00:06:28,630
do anything else so and the name of the

00:06:24,039 --> 00:06:30,490
tables product versions and sometimes

00:06:28,630 --> 00:06:34,419
stuff gets alias within the query either

00:06:30,490 --> 00:06:36,270
by the user or automatically if you know

00:06:34,419 --> 00:06:40,120
you've got like a sub query or something

00:06:36,270 --> 00:06:41,469
and then we get a bunch of costing

00:06:40,120 --> 00:06:44,500
information because post chris has a

00:06:41,469 --> 00:06:46,569
cost-based optimizer and so it wants to

00:06:44,500 --> 00:06:47,979
show you the information about the cost

00:06:46,569 --> 00:06:51,909
of the various nodes which is how it

00:06:47,979 --> 00:06:55,479
decided what to do so the startup costs

00:06:51,909 --> 00:06:56,740
for a table scan is nothing because

00:06:55,479 --> 00:06:59,229
there's no calculation that has to be

00:06:56,740 --> 00:07:04,479
done ahead of time the total estimated

00:06:59,229 --> 00:07:06,020
cost is 9.5 for cost units which are not

00:07:04,479 --> 00:07:09,830
related to anything else in Rio

00:07:06,020 --> 00:07:11,599
so there is a setting within postcodes

00:07:09,830 --> 00:07:12,620
where people try to calibrate cost units

00:07:11,599 --> 00:07:14,990
so that they actually relate to

00:07:12,620 --> 00:07:17,770
milliseconds of execution time but

00:07:14,990 --> 00:07:19,879
that's always going to be approximate

00:07:17,770 --> 00:07:21,259
then the number of rows is going to

00:07:19,879 --> 00:07:27,949
return because that's all the roads are

00:07:21,259 --> 00:07:29,479
in this table 93 the and then we get

00:07:27,949 --> 00:07:32,150
some because I'm doing it with the

00:07:29,479 --> 00:07:33,740
analyzed setting the analyzed setting

00:07:32,150 --> 00:07:40,009
actually runs the query and finds out

00:07:33,740 --> 00:07:41,810
what it did so it took point three mil

00:07:40,009 --> 00:07:44,599
at point O 3 milliseconds to get back

00:07:41,810 --> 00:07:48,530
the first row and point 6 milliseconds

00:07:44,599 --> 00:07:51,620
to get back the last row out of ninety

00:07:48,530 --> 00:07:52,819
four rows so this here you're seeing so

00:07:51,620 --> 00:07:55,699
one of the things that you're looking

00:07:52,819 --> 00:07:57,860
for in Postgres plans is does the query

00:07:55,699 --> 00:08:00,409
planners estimation of how the query

00:07:57,860 --> 00:08:02,810
would run match how the query actually

00:08:00,409 --> 00:08:05,060
ran so for example it estimated that we

00:08:02,810 --> 00:08:06,530
can get ninety three rows back and we

00:08:05,060 --> 00:08:09,280
got ninety four rows back so that's

00:08:06,530 --> 00:08:11,780
pretty pretty darn accurate actually

00:08:09,280 --> 00:08:15,259
generally from my perspective any or all

00:08:11,780 --> 00:08:18,380
within a multiple of five is actually

00:08:15,259 --> 00:08:20,389
reasonably accurate so one fifth 25

00:08:18,380 --> 00:08:24,830
times the estimated amount on a

00:08:20,389 --> 00:08:27,400
complicated query it only executed the

00:08:24,830 --> 00:08:31,400
scan once here's the filter for the scan

00:08:27,400 --> 00:08:33,260
looking for that product name this would

00:08:31,400 --> 00:08:35,120
this bit would indicate whether or not

00:08:33,260 --> 00:08:38,450
there are any triggers that got fired in

00:08:35,120 --> 00:08:42,380
the course of executing this it's only

00:08:38,450 --> 00:08:44,390
valid for write queries you know and

00:08:42,380 --> 00:08:45,800
then we get our total run time and and

00:08:44,390 --> 00:08:49,060
this is actually pretty easy to

00:08:45,800 --> 00:08:51,890
understand for this simple of a query

00:08:49,060 --> 00:08:53,930
for for users and that sort of thing the

00:08:51,890 --> 00:08:55,730
problem is the queries that the users

00:08:53,930 --> 00:08:58,000
actually have problems with are not that

00:08:55,730 --> 00:08:58,000
simple

00:09:01,160 --> 00:09:05,600
this is the explain plan of the sort of

00:09:03,399 --> 00:09:08,300
the sort of query that users actually

00:09:05,600 --> 00:09:13,300
have problems with and the problem with

00:09:08,300 --> 00:09:15,410
this is it becomes more or less

00:09:13,300 --> 00:09:19,399
unreadable there's way too much

00:09:15,410 --> 00:09:22,699
information there and like I mean this

00:09:19,399 --> 00:09:23,930
is the the sort of nested text format so

00:09:22,699 --> 00:09:26,300
like for example one of the things

00:09:23,930 --> 00:09:27,889
that's indicating is anytime we do an

00:09:26,300 --> 00:09:30,560
operation that has to bring two pieces

00:09:27,889 --> 00:09:32,540
of data together like right here we're

00:09:30,560 --> 00:09:34,730
doing in a pinned and that's where you

00:09:32,540 --> 00:09:37,220
stick one bit of data onto the end of

00:09:34,730 --> 00:09:44,089
the other those are done in partitioning

00:09:37,220 --> 00:09:45,860
those are done I when doing unions you

00:09:44,089 --> 00:09:48,319
know you get into penn so we've got an

00:09:45,860 --> 00:09:50,860
append here and one part of the append

00:09:48,319 --> 00:09:55,459
is a sequential scan on the facts table

00:09:50,860 --> 00:09:58,699
and the second part is an index scan on

00:09:55,459 --> 00:10:00,709
a second portion of the facts table so

00:09:58,699 --> 00:10:02,240
they're they're actually putting they're

00:10:00,709 --> 00:10:06,620
doing two different criteria over the

00:10:02,240 --> 00:10:10,730
facts table and union it to itself then

00:10:06,620 --> 00:10:15,199
here's your index condition and the

00:10:10,730 --> 00:10:16,939
filter so actually in sample must be not

00:10:15,199 --> 00:10:21,110
true for most rose if we're using an

00:10:16,939 --> 00:10:22,310
index on a boolean column the so you

00:10:21,110 --> 00:10:23,449
know and looking to stir these

00:10:22,310 --> 00:10:24,709
individual things but if you look at

00:10:23,449 --> 00:10:28,839
this in general you say this query is

00:10:24,709 --> 00:10:34,699
running really slow why it's not very

00:10:28,839 --> 00:10:36,920
helpful except to sort of I mean even

00:10:34,699 --> 00:10:41,360
for me this this particular things going

00:10:36,920 --> 00:10:43,880
to be a little bit baffling so we have

00:10:41,360 --> 00:10:45,949
sort of our start of some stuff you know

00:10:43,880 --> 00:10:48,110
more accessible because I mean Hubert

00:10:45,949 --> 00:10:50,680
constructed this thing and it actually

00:10:48,110 --> 00:10:54,170
parses that output and breaks it up and

00:10:50,680 --> 00:10:56,630
actually tries to figure out where

00:10:54,170 --> 00:10:58,009
you're spending your time God's given

00:10:56,630 --> 00:11:01,430
the complexity of that query that seems

00:10:58,009 --> 00:11:04,160
to two seconds 2.5 seconds seems pretty

00:11:01,430 --> 00:11:05,750
fast actually but whoever was doing this

00:11:04,160 --> 00:11:08,029
was clearly not happy with it or they

00:11:05,750 --> 00:11:11,449
wouldn't have put this on the on the

00:11:08,029 --> 00:11:13,309
explain plan so he's breaking this up

00:11:11,449 --> 00:11:13,790
and trying to actually highlight some of

00:11:13,309 --> 00:11:18,550
the common

00:11:13,790 --> 00:11:20,990
problem conditions like showing the

00:11:18,550 --> 00:11:22,520
exclusive and inclusive times for

00:11:20,990 --> 00:11:24,170
queries so like actually the funny thing

00:11:22,520 --> 00:11:26,120
about this query is it's doing all this

00:11:24,170 --> 00:11:29,750
complicated stuff and all that

00:11:26,120 --> 00:11:32,390
complicated stuff only takes a couple

00:11:29,750 --> 00:11:34,430
hundred milliseconds and most of our

00:11:32,390 --> 00:11:37,460
time as far as I can tell is being spent

00:11:34,430 --> 00:11:41,540
on doing the last sort and you nikka

00:11:37,460 --> 00:11:59,120
fying of the output data which is

00:11:41,540 --> 00:12:06,800
interesting but ah okay yeah right yeah

00:11:59,120 --> 00:12:08,300
but so we're trying to show oh yeah for

00:12:06,800 --> 00:12:10,250
the mic yeah sorry i was getting the

00:12:08,300 --> 00:12:12,710
inclusive and exclusive columns mixed up

00:12:10,250 --> 00:12:13,940
on Hubert's output so with that one

00:12:12,710 --> 00:12:15,950
actually it was only taking five

00:12:13,940 --> 00:12:17,210
milliseconds to do the last step and the

00:12:15,950 --> 00:12:21,530
rest of it was for the rest of the query

00:12:17,210 --> 00:12:23,900
which makes more sense if you're looking

00:12:21,530 --> 00:12:26,240
here unc is trying to highlight common

00:12:23,900 --> 00:12:29,690
problems like for example one of the

00:12:26,240 --> 00:12:31,940
common problems is when the estimate for

00:12:29,690 --> 00:12:35,240
the amount of data that's going to be

00:12:31,940 --> 00:12:37,970
returned from a particular step is very

00:12:35,240 --> 00:12:39,980
different from the actual from the

00:12:37,970 --> 00:12:41,750
reality because then often the QWERTY

00:12:39,980 --> 00:12:46,190
planner will choose a different plan

00:12:41,750 --> 00:12:47,210
than the one that would be optimal you

00:12:46,190 --> 00:12:49,430
know if it thinks it's going to return

00:12:47,210 --> 00:12:52,460
five rows and it actually returns five

00:12:49,430 --> 00:12:53,720
hundred thousand rows or vice versa it's

00:12:52,460 --> 00:12:54,740
going to choose a different query plan

00:12:53,720 --> 00:12:56,960
and the different query plan won't

00:12:54,740 --> 00:12:58,810
necessarily be the one that would be

00:12:56,960 --> 00:13:00,650
best for the data that you have and so

00:12:58,810 --> 00:13:04,490
Hubert here is trying to highlight

00:13:00,650 --> 00:13:09,620
things like you know here's a multiple

00:13:04,490 --> 00:13:16,280
what to saying it's 400 and 425 X off in

00:13:09,620 --> 00:13:18,200
the upwards direction so the you know

00:13:16,280 --> 00:13:21,560
and that's a little bit helpful to spot

00:13:18,200 --> 00:13:24,410
common problems but it's not quite

00:13:21,560 --> 00:13:26,120
adequate and one of the things that this

00:13:24,410 --> 00:13:27,699
view doesn't really help you with is

00:13:26,120 --> 00:13:29,139
figuring out

00:13:27,699 --> 00:13:34,290
which steps are part of which other

00:13:29,139 --> 00:13:34,290
steps yeah

00:13:43,180 --> 00:13:52,220
yes actually extremely similar in fact

00:13:48,020 --> 00:13:55,630
it's even called analyze so what you

00:13:52,220 --> 00:13:55,630
would do actually here would be

00:14:05,120 --> 00:14:10,880
like that for analyst table there's a

00:14:08,390 --> 00:14:14,029
demon that runs in the background that

00:14:10,880 --> 00:14:15,460
actually keeps track of rights to tables

00:14:14,029 --> 00:14:18,050
and when you hit a certain threshold

00:14:15,460 --> 00:14:20,660
it'll it'll automatically analyze them

00:14:18,050 --> 00:14:22,930
in the background and then that all goes

00:14:20,660 --> 00:14:22,930
into

00:14:31,970 --> 00:14:37,790
it all goes into system catalog and this

00:14:35,180 --> 00:14:39,980
is actually a simplified summary view of

00:14:37,790 --> 00:14:43,689
that system catalog that has all kinds

00:14:39,980 --> 00:14:43,689
of statistics on tables including

00:14:44,019 --> 00:14:58,250
including it's actually hold on let's do

00:14:47,300 --> 00:14:59,629
this so what you get here is whether or

00:14:58,250 --> 00:15:01,819
not the tables inherited from another

00:14:59,629 --> 00:15:04,220
table the fraction this is for a

00:15:01,819 --> 00:15:07,730
particular column here the fraction of

00:15:04,220 --> 00:15:10,879
nulls the average width of that column

00:15:07,730 --> 00:15:13,579
the indistinct estimate that is the

00:15:10,879 --> 00:15:16,250
number of distinct values as a factor of

00:15:13,579 --> 00:15:17,899
the it'll either be an absolute number

00:15:16,250 --> 00:15:19,399
if it's positive and here's here we're

00:15:17,899 --> 00:15:21,560
doing magic numbers actually in the

00:15:19,399 --> 00:15:23,240
system catalogs if it's positive it's an

00:15:21,560 --> 00:15:25,519
absolute number if it's negative that's

00:15:23,240 --> 00:15:27,079
actually a fraction so for example this

00:15:25,519 --> 00:15:30,170
is saying that basically approximately

00:15:27,079 --> 00:15:38,269
eighty percent of the table are distinct

00:15:30,170 --> 00:15:41,420
values the and the rest are not yeah I

00:15:38,269 --> 00:15:46,120
think so anyway the and then here we've

00:15:41,420 --> 00:15:46,120
got our most common values histogram and

00:15:47,500 --> 00:15:55,009
the frequencies of those most common

00:15:49,970 --> 00:15:59,259
values and then histogram bounds for

00:15:55,009 --> 00:15:59,259
bukkit bukkit the table

00:16:03,260 --> 00:16:21,170
yeah yeah yeah yes

00:16:38,790 --> 00:16:43,060
no isn't I mean I mean thing obviously

00:16:41,140 --> 00:16:45,850
is the asynchronous thing of that it

00:16:43,060 --> 00:16:47,740
tries to keep track of table activity

00:16:45,850 --> 00:16:49,930
and trigger analyzes to refresh the

00:16:47,740 --> 00:16:51,850
statistics but if that's not working for

00:16:49,930 --> 00:16:56,350
some reason like such as users are

00:16:51,850 --> 00:16:58,390
turned it off then there isn't really a

00:16:56,350 --> 00:17:02,950
way in post grads we've talked a number

00:16:58,390 --> 00:17:04,720
of times about doing say some form of

00:17:02,950 --> 00:17:07,930
query abort that is if you start in a

00:17:04,720 --> 00:17:09,670
query and you start on a you plan out

00:17:07,930 --> 00:17:12,670
the planner plans the query and it

00:17:09,670 --> 00:17:15,910
starts on a step and it's expecting 50

00:17:12,670 --> 00:17:18,700
rows back from something and it gets 50

00:17:15,910 --> 00:17:20,800
million rows that at that point maybe we

00:17:18,700 --> 00:17:22,870
should abort and replan the problem is

00:17:20,800 --> 00:17:25,360
that we boarded me planned what would we

00:17:22,870 --> 00:17:27,100
abort and we plan based on you know at

00:17:25,360 --> 00:17:29,140
that point the only thing that would be

00:17:27,100 --> 00:17:31,300
sensible to do to actually get a new

00:17:29,140 --> 00:17:36,370
good plan would be to in fact analyze

00:17:31,300 --> 00:17:38,470
every table touched by the query which

00:17:36,370 --> 00:17:41,740
might be a good feature to have but we

00:17:38,470 --> 00:17:42,730
don't have it yet the the other thing

00:17:41,740 --> 00:17:44,530
that we've actually talked about a

00:17:42,730 --> 00:17:46,750
number of times but because of the

00:17:44,530 --> 00:17:49,240
complexity that haven't implemented is

00:17:46,750 --> 00:17:50,710
this idea of not just having a

00:17:49,240 --> 00:17:52,240
statistical cost of plans but also

00:17:50,710 --> 00:17:55,840
having a statistic of the level of risk

00:17:52,240 --> 00:18:01,060
of plans that is how risky is this

00:17:55,840 --> 00:18:03,630
particular plan choice if it turns out

00:18:01,060 --> 00:18:05,650
that I'm wrong about what's in the table

00:18:03,630 --> 00:18:07,210
because there's certain things that post

00:18:05,650 --> 00:18:08,380
goes does to optimize performance that

00:18:07,210 --> 00:18:10,030
when they're right makes things much

00:18:08,380 --> 00:18:12,340
faster but when the wrong links then

00:18:10,030 --> 00:18:15,700
it's much much slower like we have this

00:18:12,340 --> 00:18:17,230
thing called index can abort where say

00:18:15,700 --> 00:18:19,000
that you're actually returning something

00:18:17,230 --> 00:18:22,090
in the order that a particular indexes

00:18:19,000 --> 00:18:24,100
in and you put a limit 20 on it and post

00:18:22,090 --> 00:18:27,280
grows assumes that that particular value

00:18:24,100 --> 00:18:29,320
that you're looking for is extremely

00:18:27,280 --> 00:18:32,410
that your filter condition is extremely

00:18:29,320 --> 00:18:34,720
frequent in the table you know so so

00:18:32,410 --> 00:18:37,600
you're saying we're status equals active

00:18:34,720 --> 00:18:38,800
and according to post mystics seventy

00:18:37,600 --> 00:18:40,840
percent of the rows have static it was

00:18:38,800 --> 00:18:42,130
active so it's only going to have to

00:18:40,840 --> 00:18:43,990
scan the index for a couple of

00:18:42,130 --> 00:18:47,560
milliseconds to find those first 20 rows

00:18:43,990 --> 00:18:49,150
and return them right but if it turns

00:18:47,560 --> 00:18:52,470
out to be wrong what if it turns out

00:18:49,150 --> 00:18:57,280
that only two percent of the table

00:18:52,470 --> 00:18:59,260
has I you know has status equals active

00:18:57,280 --> 00:19:02,050
then it's going to all of a sudden be

00:18:59,260 --> 00:19:03,190
scanning and checking a large portion of

00:19:02,050 --> 00:19:05,950
the index which is going to be extremely

00:19:03,190 --> 00:19:07,930
slow and so that's actually kind of it's

00:19:05,950 --> 00:19:09,880
a high-risk plan that is if it turns out

00:19:07,930 --> 00:19:11,770
your statistics are wrong the penalty

00:19:09,880 --> 00:19:13,870
for using that plan in terms of

00:19:11,770 --> 00:19:18,040
exclusion times can be very high problem

00:19:13,870 --> 00:19:21,820
is that cost based the cost of a planner

00:19:18,040 --> 00:19:24,520
is difficult and complicated enough

00:19:21,820 --> 00:19:27,000
having only one metric of query

00:19:24,520 --> 00:19:30,310
estimation which is the estimated cost

00:19:27,000 --> 00:19:33,220
if we add a second metric the estimated

00:19:30,310 --> 00:19:37,270
risk then we've just at least doubled

00:19:33,220 --> 00:19:38,710
the complexity of the planner so we

00:19:37,270 --> 00:19:40,240
don't really have a solution for that I

00:19:38,710 --> 00:19:44,650
mean it's a real problem and that sort

00:19:40,240 --> 00:19:47,590
of thing we've done a few things to fix

00:19:44,650 --> 00:19:49,150
common cases like for a pinned only

00:19:47,590 --> 00:19:50,980
table one of the chronic problems that

00:19:49,150 --> 00:19:52,300
we had for app end only tables is for

00:19:50,980 --> 00:19:56,320
append only tables you're often actually

00:19:52,300 --> 00:19:58,660
searching for the rows that happen that

00:19:56,320 --> 00:20:00,640
have been inserted most recently because

00:19:58,660 --> 00:20:07,720
you often want to see the most in recent

00:20:00,640 --> 00:20:09,100
data but then but then that's the data

00:20:07,720 --> 00:20:10,990
that's the least likely to be analyzed

00:20:09,100 --> 00:20:13,600
because it just went into the table and

00:20:10,990 --> 00:20:15,970
so it used to be that you would do a

00:20:13,600 --> 00:20:18,760
search on that and what it would return

00:20:15,970 --> 00:20:20,320
would be it would estimate that there

00:20:18,760 --> 00:20:21,730
were no Rose matching your query and

00:20:20,320 --> 00:20:23,620
therefore it would use a plan like an S

00:20:21,730 --> 00:20:25,240
loop that's very appropriate for for

00:20:23,620 --> 00:20:29,920
something that doesn't think is going to

00:20:25,240 --> 00:20:32,830
return any rows so we did do a bypass in

00:20:29,920 --> 00:20:34,840
that case which is if you ask if the

00:20:32,830 --> 00:20:36,640
users running in query were there there

00:20:34,840 --> 00:20:38,410
have a filter condition that's

00:20:36,640 --> 00:20:40,510
deliberately asking for rows that post

00:20:38,410 --> 00:20:44,290
Chris think is past the last bucket of

00:20:40,510 --> 00:20:48,040
the histogram bounds first step is the

00:20:44,290 --> 00:20:50,170
planner checks the index actually the

00:20:48,040 --> 00:20:52,690
optimizer checks the index on the table

00:20:50,170 --> 00:20:54,610
to say hey are there any rows past the

00:20:52,690 --> 00:20:57,220
end of the system and bucket and then

00:20:54,610 --> 00:20:58,690
the index will return in answer of that

00:20:57,220 --> 00:21:01,390
because we have the index statistics

00:20:58,690 --> 00:21:03,400
which are going to be up to date and

00:21:01,390 --> 00:21:05,190
then we're going to use that instead for

00:21:03,400 --> 00:21:07,080
the plan and so that we

00:21:05,190 --> 00:21:09,210
the help that particular case but it's

00:21:07,080 --> 00:21:11,820
not generalized to other cases of having

00:21:09,210 --> 00:21:13,320
the wrong statistics the other thing

00:21:11,820 --> 00:21:16,190
that we haven't implemented and I think

00:21:13,320 --> 00:21:18,480
Oracle may have done a better job on is

00:21:16,190 --> 00:21:20,520
going beyond the histogram bucket

00:21:18,480 --> 00:21:22,800
mama'll to actually understand certain

00:21:20,520 --> 00:21:27,570
common patterns with data like for

00:21:22,800 --> 00:21:30,950
example normal distributions postgres

00:21:27,570 --> 00:21:33,780
treats all data as if it was randomized

00:21:30,950 --> 00:21:35,940
in terms of the query planning which

00:21:33,780 --> 00:21:38,760
works for a lot of data but doesn't work

00:21:35,940 --> 00:21:43,410
for data that follows say a linear

00:21:38,760 --> 00:21:46,290
progression or or normal form or

00:21:43,410 --> 00:21:48,930
whatever that those it ends up still

00:21:46,290 --> 00:21:52,470
making no better and in fact sometimes

00:21:48,930 --> 00:21:53,730
worse estimates on data that have the

00:21:52,470 --> 00:21:55,650
sort of predictable mathematical

00:21:53,730 --> 00:21:59,910
patterns as it doesn't data that's

00:21:55,650 --> 00:22:03,570
randomized these are all areas to work

00:21:59,910 --> 00:22:05,400
on and our primary limitation is it's

00:22:03,570 --> 00:22:07,890
very hard to find people who want to

00:22:05,400 --> 00:22:09,810
hack on the query planner because it's

00:22:07,890 --> 00:22:12,830
really complicated and most of the time

00:22:09,810 --> 00:22:12,830
when you try things they don't work

00:22:15,590 --> 00:22:18,340
so

00:22:22,350 --> 00:22:28,110
okay yeah so I mean that's the basic

00:22:25,470 --> 00:22:29,610
idea and I feel like you know things

00:22:28,110 --> 00:22:32,640
like this like Hubert's is sort of a

00:22:29,610 --> 00:22:35,100
first step but I feel like we're getting

00:22:32,640 --> 00:22:37,380
to a point where we have explained

00:22:35,100 --> 00:22:38,850
output you know and I'm beginning to see

00:22:37,380 --> 00:22:41,280
this with MySQL now having better

00:22:38,850 --> 00:22:45,600
explain output that that's very useful

00:22:41,280 --> 00:22:47,520
for me and cheery and you and not useful

00:22:45,600 --> 00:22:49,820
for the majority of our users because

00:22:47,520 --> 00:22:52,320
they're drowning in too much information

00:22:49,820 --> 00:22:55,010
that requires way too much knowledge to

00:22:52,320 --> 00:22:55,010
make any sense out of

00:23:28,429 --> 00:23:32,340
yeah I don't know there would be because

00:23:30,660 --> 00:23:34,049
the problem is that what's actually

00:23:32,340 --> 00:23:37,080
wrong in the query what's actually

00:23:34,049 --> 00:23:39,780
taking time is often other sonos the net

00:23:37,080 --> 00:24:00,110
before is often pretty far down in the

00:23:39,780 --> 00:24:00,110
query somewhere yeah yeah

00:24:01,480 --> 00:24:16,360
yeah yeah i mean the problem is the in a

00:24:14,350 --> 00:24:18,070
lot of cases in Postgres what the user

00:24:16,360 --> 00:24:20,320
really wants to know is what action can

00:24:18,070 --> 00:24:22,270
I take to fix this query so for example

00:24:20,320 --> 00:24:24,220
often what you'll have this will come

00:24:22,270 --> 00:24:27,970
down you'll find the really slow step is

00:24:24,220 --> 00:24:30,220
a sort somewhere and and if for example

00:24:27,970 --> 00:24:31,900
this actually said sort method it

00:24:30,220 --> 00:24:34,690
actually said tape sort which would mean

00:24:31,900 --> 00:24:36,160
a non disc sort you know and that it

00:24:34,690 --> 00:24:39,160
required you know and that the space

00:24:36,160 --> 00:24:43,150
required was say you know forty

00:24:39,160 --> 00:24:45,130
megabytes then the user you know then

00:24:43,150 --> 00:24:47,080
the conclusion of somebody like me is

00:24:45,130 --> 00:24:50,020
that woken Venice arrow a hey Ray's work

00:24:47,080 --> 00:24:51,490
mem to 64 megabytes and then this will

00:24:50,020 --> 00:24:55,330
go back to an in-memory sort it will be

00:24:51,490 --> 00:24:58,720
much faster the problem is that the

00:24:55,330 --> 00:25:02,350
users interface to that is me or some

00:24:58,720 --> 00:25:04,600
other post was expert and you know and

00:25:02,350 --> 00:25:06,640
and we've been sort of starting to talk

00:25:04,600 --> 00:25:09,100
about you know how do we actually get

00:25:06,640 --> 00:25:10,900
beyond I mean we still need this output

00:25:09,100 --> 00:25:13,809
for the experts for when things really

00:25:10,900 --> 00:25:18,190
go wrong but we need a different form of

00:25:13,809 --> 00:25:19,390
output that that basically I mean

00:25:18,190 --> 00:25:21,070
essentially i mean my first thought is

00:25:19,390 --> 00:25:23,320
something that's like offer suggestions

00:25:21,070 --> 00:25:24,700
that doesn't analyze you know that goes

00:25:23,320 --> 00:25:27,850
through all the different parts and

00:25:24,700 --> 00:25:30,549
looks for common patterns and says you

00:25:27,850 --> 00:25:33,250
might need to analyze table x or you

00:25:30,549 --> 00:25:34,660
might need one of the really complicated

00:25:33,250 --> 00:25:36,520
ones to figure out at least in Postgres

00:25:34,660 --> 00:25:39,240
is you might need an index on this

00:25:36,520 --> 00:25:39,240
particular column

00:26:06,840 --> 00:26:11,500
yeah I don't know it's sort of me to

00:26:09,880 --> 00:26:14,890
believe that that this problem isn't

00:26:11,500 --> 00:26:18,460
solvable I just haven't seen a good

00:26:14,890 --> 00:26:21,990
example of it from any other database in

00:26:18,460 --> 00:26:23,680
terms of providing users with

00:26:21,990 --> 00:26:25,810
easy-to-understand information that they

00:26:23,680 --> 00:26:27,010
can immediately take action on like the

00:26:25,810 --> 00:26:28,900
Oracle stuff is actually much worse

00:26:27,010 --> 00:26:30,580
because it supplies much more data

00:26:28,900 --> 00:26:36,090
without making that data anymore

00:26:30,580 --> 00:26:36,090
digested than it is for postgres yeah

00:26:55,240 --> 00:26:57,270
Oh

00:27:03,590 --> 00:27:08,760
yeah yeah the problem is that that even

00:27:07,710 --> 00:27:11,190
that because I've looked at that I

00:27:08,760 --> 00:27:13,169
actually supply some simple queries to

00:27:11,190 --> 00:27:14,850
look at that and they're on my blog and

00:27:13,169 --> 00:27:18,539
that sort of thing it would be useful to

00:27:14,850 --> 00:27:20,580
actually put this together in a tool but

00:27:18,539 --> 00:27:21,809
even then one of the problems we learn

00:27:20,580 --> 00:27:24,659
to do in the communities with arguments

00:27:21,809 --> 00:27:26,970
over the algorithm because it's easy to

00:27:24,659 --> 00:27:29,159
say the part of the index is never used

00:27:26,970 --> 00:27:32,909
is easy but what about an index that's

00:27:29,159 --> 00:27:34,799
extremely seldom used you know at what

00:27:32,909 --> 00:27:37,049
level of seldom do you recommend to the

00:27:34,799 --> 00:27:38,730
user that they get rid of it because the

00:27:37,049 --> 00:27:40,500
thing is that I mean what if the index

00:27:38,730 --> 00:27:44,309
has only been scammed five times in the

00:27:40,500 --> 00:27:45,900
last year well then it becomes relative

00:27:44,309 --> 00:27:47,909
if it was scanned five times but if the

00:27:45,900 --> 00:27:49,320
table was never updated in the last year

00:27:47,909 --> 00:27:51,539
then keeping it around was probably

00:27:49,320 --> 00:27:54,419
actors probably actually makes sense you

00:27:51,539 --> 00:27:55,830
know but if it was scanned five times in

00:27:54,419 --> 00:27:58,770
the last year and the table was updated

00:27:55,830 --> 00:28:00,900
20 times and you know how do you decide

00:27:58,770 --> 00:28:02,220
it where you draw the line of I'm going

00:28:00,900 --> 00:28:04,460
to recommend to the user that they drop

00:28:02,220 --> 00:28:04,460
with us

00:28:11,500 --> 00:28:18,100
yeah in in postcodes you actually have

00:28:14,570 --> 00:28:18,100
some stats on that

00:28:55,549 --> 00:29:01,769
but yeah why isn't it why is it keeping

00:28:59,549 --> 00:29:03,799
even just like the timestamp and when it

00:29:01,769 --> 00:29:03,799
was

00:29:11,559 --> 00:29:17,929
yeah yet one of the things Baron

00:29:15,259 --> 00:29:19,700
complaint one of these that Baron

00:29:17,929 --> 00:29:21,080
complains about a lot is that the

00:29:19,700 --> 00:29:24,549
default of what's available both in

00:29:21,080 --> 00:29:26,539
posters in mysql is counters and

00:29:24,549 --> 00:29:29,899
counters have a certain limited amount

00:29:26,539 --> 00:29:32,240
of usefulness because like you know here

00:29:29,899 --> 00:29:34,340
i can take a look at this and i can say

00:29:32,240 --> 00:29:36,350
hey you know this index has not been

00:29:34,340 --> 00:29:39,529
scanned any time since whatever it was i

00:29:36,350 --> 00:29:40,940
last reset the counters well it doesn't

00:29:39,529 --> 00:29:43,759
tell me is when i last reset the

00:29:40,940 --> 00:29:45,230
counters and particularly one of the

00:29:43,759 --> 00:29:46,700
things off I want to know is how many

00:29:45,230 --> 00:29:48,350
times does index used in the last day

00:29:46,700 --> 00:29:50,029
how many was used in the last week oh I

00:29:48,350 --> 00:29:55,210
just ran a performance test how many

00:29:50,029 --> 00:29:55,210
times was it used in the last hour Yeah

00:29:55,840 --> 00:30:06,740
Yeah right yeah and the and and that's I

00:30:05,929 --> 00:30:08,029
mean it's actually clearly very

00:30:06,740 --> 00:30:09,710
important here because I can say hey

00:30:08,029 --> 00:30:13,970
this index has been used eleven thousand

00:30:09,710 --> 00:30:15,950
times which would be a lot if it was in

00:30:13,970 --> 00:30:19,149
the last day but if it's in the last

00:30:15,950 --> 00:30:19,149
year and a half it's not a lot

00:30:41,480 --> 00:30:47,130
right you know so we have some we have

00:30:45,300 --> 00:30:49,620
some add-on tools to deal with this

00:30:47,130 --> 00:30:55,980
there's um what is the japanese one

00:30:49,620 --> 00:30:59,610
christophe PG stad it's the one that

00:30:55,980 --> 00:31:04,500
actually does a you know snapshot of

00:30:59,610 --> 00:31:06,860
your statistics every period but yeah

00:31:04,500 --> 00:31:06,860
okay

00:31:57,460 --> 00:32:08,720
yes well the other thing is users like

00:32:06,409 --> 00:32:11,389
and now why is my database 500 gigabytes

00:32:08,720 --> 00:32:20,860
well you got 120 gigabytes of data and

00:32:11,389 --> 00:32:27,169
300 80 gigabytes of indexes yeah yeah

00:32:20,860 --> 00:32:30,109
yeah yeah so it's sort of a general

00:32:27,169 --> 00:32:32,059
problem in the the I mean one of your

00:32:30,109 --> 00:32:36,950
issues becomes but I mean one of the

00:32:32,059 --> 00:32:38,239
issues is you know is I mean I don't

00:32:36,950 --> 00:32:40,070
feel like I have a good grasp to begin

00:32:38,239 --> 00:32:41,419
with we have sort of an assortment of

00:32:40,070 --> 00:32:45,080
tools and generally those tools are

00:32:41,419 --> 00:32:47,450
useful for one problem and they don't

00:32:45,080 --> 00:32:48,889
really sort of i mean even aside from

00:32:47,450 --> 00:32:52,429
the fact that a lot of people don't know

00:32:48,889 --> 00:32:55,850
about them and can't find them figuring

00:32:52,429 --> 00:32:58,039
out making use figuring out whether or

00:32:55,850 --> 00:33:06,700
not your problem is the problem

00:32:58,039 --> 00:33:06,700
addressed by the tool yeah

00:33:35,470 --> 00:33:47,270
yeah yeah yeah I mean one of the

00:33:45,530 --> 00:33:48,650
problems that we run into there is that

00:33:47,270 --> 00:33:52,970
obviously maintaining all these

00:33:48,650 --> 00:33:54,860
statistics isn't free and in any

00:33:52,970 --> 00:33:57,350
individual statistic is relatively cheap

00:33:54,860 --> 00:33:59,330
but we keep adding things and it becomes

00:33:57,350 --> 00:34:03,440
you know an issue to the point where in

00:33:59,330 --> 00:34:06,320
what was it nine dot 0920 we had to

00:34:03,440 --> 00:34:10,100
basically allow you to move the

00:34:06,320 --> 00:34:15,050
statistics file to an in-memory you know

00:34:10,100 --> 00:34:16,280
a non you know a non file handle because

00:34:15,050 --> 00:34:17,810
too much riding happening because in

00:34:16,280 --> 00:34:18,889
some databases look particularly data

00:34:17,810 --> 00:34:20,030
and databases where they don't care

00:34:18,889 --> 00:34:22,460
about to the legacy this particularly as

00:34:20,030 --> 00:34:25,940
databases back in cuse so you've got a

00:34:22,460 --> 00:34:28,070
big celery implementation or or Apache

00:34:25,940 --> 00:34:29,360
mq that's being backed by postgres they

00:34:28,070 --> 00:34:32,119
don't really care about the statistics

00:34:29,360 --> 00:34:36,110
because they're just adding in a pending

00:34:32,119 --> 00:34:37,850
and moving and but they're pending and

00:34:36,110 --> 00:34:38,960
moving very fast and so the statistics

00:34:37,850 --> 00:34:40,550
being updated all the time and pretty

00:34:38,960 --> 00:34:43,190
soon you look and you say hey the

00:34:40,550 --> 00:34:48,169
majority of my rights to disk are the

00:34:43,190 --> 00:34:49,790
statistics file you know by like ten

00:34:48,169 --> 00:34:52,550
times as much as actually writing a need

00:34:49,790 --> 00:34:55,129
out because mostly data ceases to exist

00:34:52,550 --> 00:34:59,139
before it hits desk but the statistics

00:34:55,129 --> 00:34:59,139
still get updated the

00:35:22,960 --> 00:35:26,859
I enterprisedb has their Enterprise

00:35:25,089 --> 00:35:28,300
Manager thing but its performance

00:35:26,859 --> 00:35:31,180
recommendations are relatively

00:35:28,300 --> 00:35:33,550
rudimentary you know on the level of

00:35:31,180 --> 00:35:35,800
this index has never been used or this

00:35:33,550 --> 00:35:39,430
table has no indexes you know that sort

00:35:35,800 --> 00:35:40,690
of thing yeah although the enterprise

00:35:39,430 --> 00:35:42,790
manager you can use separately and

00:35:40,690 --> 00:35:45,130
against it with postgres it's not

00:35:42,790 --> 00:35:48,990
however I don't think it's free that I

00:35:45,130 --> 00:35:55,210
think its proprietary I'm not sure the

00:35:48,990 --> 00:35:56,770
so there is some of that stuff and it's

00:35:55,210 --> 00:36:00,010
certainly but that doesn't help you with

00:35:56,770 --> 00:36:05,470
the the problem you know that I wanted

00:36:00,010 --> 00:36:09,369
to bring up which was you know this

00:36:05,470 --> 00:36:15,010
problem the you know why is this query

00:36:09,369 --> 00:36:17,080
taking five seconds because you know I

00:36:15,010 --> 00:36:18,160
mean you look at this giant complicated

00:36:17,080 --> 00:36:20,859
query I'll put in that sort of thing and

00:36:18,160 --> 00:36:25,240
I can take a look at it and I can say

00:36:20,859 --> 00:36:28,450
for some strange reason this particular

00:36:25,240 --> 00:36:30,730
right here and actually go all the way

00:36:28,450 --> 00:36:33,250
actually so this is one of the problems

00:36:30,730 --> 00:36:37,359
is even looking at the digested output I

00:36:33,250 --> 00:36:43,119
have to go all the way down here and say

00:36:37,359 --> 00:36:46,720
oh hey this hash joint is really slow

00:36:43,119 --> 00:36:49,030
for some reason and then try to figure

00:36:46,720 --> 00:36:51,220
out what that reason is which I can't

00:36:49,030 --> 00:36:57,230
really because on the blown-up screen

00:36:51,220 --> 00:37:01,550
it's wrapping the text what

00:36:57,230 --> 00:37:08,900
I can't actually given the way he's done

00:37:01,550 --> 00:37:10,160
the layout the well I don't know what I

00:37:08,900 --> 00:37:11,420
don't actually have the original query

00:37:10,160 --> 00:37:37,730
because you don't have to post if you've

00:37:11,420 --> 00:37:39,440
explained yeah yo the some of it I mean

00:37:37,730 --> 00:37:41,150
input in Postgres land there are

00:37:39,440 --> 00:37:46,880
legitimate reasons to write queries this

00:37:41,150 --> 00:37:53,810
complicated the and and and we have many

00:37:46,880 --> 00:37:55,070
in socorro actually the yeah well

00:37:53,810 --> 00:37:59,800
because we're doing complicated things

00:37:55,070 --> 00:38:02,540
where you're doing multiple rankings of

00:37:59,800 --> 00:38:04,280
rows based on different characteristics

00:38:02,540 --> 00:38:07,160
and so you have to do common table

00:38:04,280 --> 00:38:08,750
expressions where you sort the rows over

00:38:07,160 --> 00:38:14,890
different windows and give the rankings

00:38:08,750 --> 00:38:17,450
of them and that sort of thing the so

00:38:14,890 --> 00:38:19,490
but you know the same thing is that you

00:38:17,450 --> 00:38:21,380
know when when one of those is slow and

00:38:19,490 --> 00:38:23,060
I mean it's actually some of this

00:38:21,380 --> 00:38:24,920
actually takes me quite a bit of time to

00:38:23,060 --> 00:38:29,030
actually look at it and say why is it

00:38:24,920 --> 00:38:30,740
slow and we can't possibly cover all

00:38:29,030 --> 00:38:32,570
cases but it seems like you know we

00:38:30,740 --> 00:38:34,070
could take an approach a simpler one to

00:38:32,570 --> 00:38:36,680
say okay here's the different cases what

00:38:34,070 --> 00:38:38,180
queries are slow and we'll come up with

00:38:36,680 --> 00:38:40,940
these patterns that we can search for

00:38:38,180 --> 00:38:43,130
within the query and say you know come

00:38:40,940 --> 00:38:46,520
back and I think that's where we need to

00:38:43,130 --> 00:38:48,170
go but since I don't have any example so

00:38:46,520 --> 00:38:51,080
I can't look at another database and say

00:38:48,170 --> 00:38:53,540
Oracle does this db2 does this at least

00:38:51,080 --> 00:38:55,850
not in the item looked at the Oracle

00:38:53,540 --> 00:38:57,770
Enterprise Manager because i don't want

00:38:55,850 --> 00:39:03,340
to pay a million dollars to get access

00:38:57,770 --> 00:39:06,560
to it the you know look at those and say

00:39:03,340 --> 00:39:08,869
you know is that a good way to help

00:39:06,560 --> 00:39:11,380
average users you know or do we need to

00:39:08,869 --> 00:39:11,380
do something different

00:39:12,220 --> 00:39:16,750
that's what I was wondering if anybody

00:39:14,060 --> 00:39:16,750
had any ideas about

00:40:00,139 --> 00:40:04,949
yeah yeah well that's what I morning is

00:40:03,299 --> 00:40:06,959
that maybe it's no do we need to focus

00:40:04,949 --> 00:40:08,939
on the sort of ultimate you know sort of

00:40:06,959 --> 00:40:10,589
actionable output and say come up with a

00:40:08,939 --> 00:40:14,369
recommend or algorithm that basically

00:40:10,589 --> 00:40:16,169
says oh you know estimates for table

00:40:14,369 --> 00:40:21,749
acts are way off you probably want to

00:40:16,169 --> 00:40:26,609
analyze that table you know or oh you

00:40:21,749 --> 00:40:30,809
are doing an on disk sort you're doing

00:40:26,609 --> 00:40:31,949
on this sword I you know 418 megabytes

00:40:30,809 --> 00:40:34,589
of data so you'll probably want to

00:40:31,949 --> 00:40:36,689
increase work memory you know the

00:40:34,589 --> 00:40:38,489
problem with that sort of thing with

00:40:36,689 --> 00:40:43,169
taking that approach is that none of

00:40:38,489 --> 00:40:45,449
these things are free so for example the

00:40:43,169 --> 00:40:48,029
work memory increase for example works

00:40:45,449 --> 00:40:49,739
great on individual query but that's a

00:40:48,029 --> 00:40:51,449
resource limit in Postgres and if you

00:40:49,739 --> 00:40:53,819
increase it for the database system in

00:40:51,449 --> 00:40:54,899
general you may discover that yes you've

00:40:53,819 --> 00:40:57,149
made so many of you do queries run

00:40:54,899 --> 00:41:00,019
faster but on the whole you've just run

00:40:57,149 --> 00:41:00,019
your system out of memory

00:41:05,690 --> 00:41:09,480
well I'm thinking yeah I'm thinking

00:41:07,440 --> 00:41:12,480
about making it more approachable to

00:41:09,480 --> 00:41:14,280
developers because right now with the

00:41:12,480 --> 00:41:15,390
this you know the minute of developers

00:41:14,280 --> 00:41:35,610
see something like this they just give

00:41:15,390 --> 00:41:37,410
up well except that that in most cases

00:41:35,610 --> 00:41:39,390
the case I'm really trying to solve its

00:41:37,410 --> 00:41:42,590
weather isn't a DBA because that's

00:41:39,390 --> 00:41:47,790
actually the majority case these days

00:41:42,590 --> 00:41:50,700
the so you know because if there is a

00:41:47,790 --> 00:41:52,080
DBA if there is a DBA then then

00:41:50,700 --> 00:41:55,590
presumably they can understand this

00:41:52,080 --> 00:41:57,150
output and and you know and so the

00:41:55,590 --> 00:41:59,670
answer is they say my query is slow and

00:41:57,150 --> 00:42:01,350
the DBA says give me your query a copy

00:41:59,670 --> 00:42:02,970
of your query and I'll try it out and

00:42:01,350 --> 00:42:05,400
come back and say okay I added some

00:42:02,970 --> 00:42:06,660
indexes index recommendation is actually

00:42:05,400 --> 00:42:08,280
one of those things when I look in the

00:42:06,660 --> 00:42:09,480
recommendations often the solution to

00:42:08,280 --> 00:42:11,700
make McQueary fastest they had a

00:42:09,480 --> 00:42:14,460
particular index but when you get into

00:42:11,700 --> 00:42:17,820
multi-column indexes I can't even

00:42:14,460 --> 00:42:20,870
imagine a programmed algorithm that

00:42:17,820 --> 00:42:24,450
would work for recommending those

00:42:20,870 --> 00:42:26,100
because I do it sort of I do it by a

00:42:24,450 --> 00:42:28,620
combination of instinct and trial and

00:42:26,100 --> 00:42:30,570
error that has I've gotten sort of a

00:42:28,620 --> 00:42:34,980
feel for what multi-column indexes

00:42:30,570 --> 00:42:37,760
really help on complex queries and I'm

00:42:34,980 --> 00:42:40,140
right about fifty percent of the time

00:42:37,760 --> 00:42:41,220
you know and the other fifty percent of

00:42:40,140 --> 00:42:44,790
time I had the monthly column in essence

00:42:41,220 --> 00:42:46,890
doesn't help at all move it again so

00:42:44,790 --> 00:42:49,170
it's hard for me to imagine like some

00:42:46,890 --> 00:42:54,690
things like you need to analyze you need

00:42:49,170 --> 00:42:56,100
more work memory the this table going as

00:42:54,690 --> 00:43:00,030
far as saying this table might need an

00:42:56,100 --> 00:43:02,010
index is easy enough but actually

00:43:00,030 --> 00:43:05,990
recommending which what it needs an

00:43:02,010 --> 00:43:05,990
index on is is a lot more complicated

00:43:34,130 --> 00:43:46,220
well we did which it is with us west but

00:43:36,510 --> 00:43:46,220
yeah yeah

00:43:52,390 --> 00:43:55,390
yes

00:44:07,839 --> 00:44:12,220
mm-hmm yeah

00:44:14,040 --> 00:44:20,190
yeah so in that case being able to start

00:44:17,100 --> 00:44:22,050
out with a recommendation of yours doing

00:44:20,190 --> 00:44:23,970
a full scan of this large table you

00:44:22,050 --> 00:44:26,790
might need an index would actually be

00:44:23,970 --> 00:44:28,080
enough or and for that matter and

00:44:26,790 --> 00:44:30,720
posters we have to recommend we would

00:44:28,080 --> 00:44:33,090
want to recommend things like you're

00:44:30,720 --> 00:44:35,250
doing this expensive sort if there were

00:44:33,090 --> 00:44:38,190
an index in those conditions it might be

00:44:35,250 --> 00:44:41,900
faster you know you know work or

00:44:38,190 --> 00:44:41,900
aggregation you know that sort of thing

00:45:10,330 --> 00:45:12,390
you

00:45:15,610 --> 00:45:20,690
when we created asterisk over a decade

00:45:18,320 --> 00:45:22,640
ago we could not have imagined that

00:45:20,690 --> 00:45:24,830
asterisk would not only become the most

00:45:22,640 --> 00:45:26,990
widely adopted open source communication

00:45:24,830 --> 00:45:29,000
software on the planet but that it would

00:45:26,990 --> 00:45:31,520
impact the entire industry in the way

00:45:29,000 --> 00:45:33,530
that it has today asterisk has found its

00:45:31,520 --> 00:45:36,140
way in the more than 170 countries and

00:45:33,530 --> 00:45:38,090
virtually every fortune 1000 company the

00:45:36,140 --> 00:45:40,190
success of asterisk has enabled a

00:45:38,090 --> 00:45:41,600
transition of power from the hands of

00:45:40,190 --> 00:45:43,880
the traditional proprietary phone

00:45:41,600 --> 00:45:46,280
vendors into the hands of the users and

00:45:43,880 --> 00:45:48,350
administrators of phone systems using

00:45:46,280 --> 00:45:50,000
this power our customers have traded all

00:45:48,350 --> 00:45:52,070
sorts of business changing applications

00:45:50,000 --> 00:45:53,870
from small office phone systems to

00:45:52,070 --> 00:45:55,970
mission-critical call centers the

00:45:53,870 --> 00:45:57,800
international carrier networks in fact

00:45:55,970 --> 00:45:59,270
there's even an entire country those

00:45:57,800 --> 00:46:01,520
communications infrastructure runs on

00:45:59,270 --> 00:46:03,650
esters the gym has always been about

00:46:01,520 --> 00:46:05,360
creating technology that expands

00:46:03,650 --> 00:46:07,550
communications capabilities in ways that

00:46:05,360 --> 00:46:08,720
we could never have imagined and that's

00:46:07,550 --> 00:46:11,120
part of what's game-changing about

00:46:08,720 --> 00:46:13,820
Digium today we're doing it again this

00:46:11,120 --> 00:46:15,920
time by introducing a new family of HD

00:46:13,820 --> 00:46:18,020
IP phones that extends control of the

00:46:15,920 --> 00:46:19,790
user all the way to the desktop the

00:46:18,020 --> 00:46:21,500
launch of these new products represents

00:46:19,790 --> 00:46:23,600
the next phase indigenous history of

00:46:21,500 --> 00:46:26,000
innovation these are the first and only

00:46:23,600 --> 00:46:27,710
IP phones designed to fully leverage the

00:46:26,000 --> 00:46:29,270
power of Astra's when we first discussed

00:46:27,710 --> 00:46:31,310
our expectations for building a family

00:46:29,270 --> 00:46:33,440
of phones for use with asterisk our

00:46:31,310 --> 00:46:35,180
requirements were pretty simple we asked

00:46:33,440 --> 00:46:36,830
the team to build the phones such that

00:46:35,180 --> 00:46:39,020
they were easy to install integrate

00:46:36,830 --> 00:46:40,880
provision in use I think you'll soon

00:46:39,020 --> 00:46:43,430
agree our engineers have delivered on

00:46:40,880 --> 00:46:45,050
that goal user feedback is validating

00:46:43,430 --> 00:46:47,180
that when it comes to operation with

00:46:45,050 --> 00:46:49,610
Astra space systems including our own

00:46:47,180 --> 00:46:52,190
switchvox based product these are the

00:46:49,610 --> 00:46:53,480
easiest to use best integrated most

00:46:52,190 --> 00:46:56,060
interoperable products on the market

00:46:53,480 --> 00:46:58,060
today the digitally phones will

00:46:56,060 --> 00:47:00,110
initially include three IP des hommes

00:46:58,060 --> 00:47:02,060
uniquely designed to complement any

00:47:00,110 --> 00:47:03,920
asterisks or Switchvox based solution

00:47:02,060 --> 00:47:06,590
these phones are different for a number

00:47:03,920 --> 00:47:09,260
of reasons first there is clue sively

00:47:06,590 --> 00:47:10,670
designed for use with esters secondly

00:47:09,260 --> 00:47:12,280
we've made it really easy to

00:47:10,670 --> 00:47:14,690
autodiscover and provision the phones

00:47:12,280 --> 00:47:16,370
next we've made it easy for the phones

00:47:14,690 --> 00:47:18,080
to access information inside of

00:47:16,370 --> 00:47:18,810
asterisks allowing tight coupling

00:47:18,080 --> 00:47:21,330
between

00:47:18,810 --> 00:47:23,220
application and the phone additionally

00:47:21,330 --> 00:47:25,500
we've created an applications engine

00:47:23,220 --> 00:47:27,690
that allows users and developers to

00:47:25,500 --> 00:47:30,570
create and run their own apps on the

00:47:27,690 --> 00:47:32,550
phone and finally we've done all of this

00:47:30,570 --> 00:47:34,260
at a very compelling price point at

00:47:32,550 --> 00:47:36,450
Digium we're always thinking of ways to

00:47:34,260 --> 00:47:38,820
give our customers the best value in

00:47:36,450 --> 00:47:40,110
business phone systems and also give

00:47:38,820 --> 00:47:42,210
them the power to create their own

00:47:40,110 --> 00:47:44,010
solutions or any communications

00:47:42,210 --> 00:47:45,690
challenge will continue to push the

00:47:44,010 --> 00:47:47,400
boundaries not only to make Astra's

00:47:45,690 --> 00:47:49,380
cooler bastard more technologically

00:47:47,400 --> 00:47:50,910
feature-rich but to make asterisk and

00:47:49,380 --> 00:47:53,100
what communications even easier and

00:47:50,910 --> 00:47:56,600
together we'll change the way the world

00:47:53,100 --> 00:47:56,600
communicates again

00:48:07,299 --> 00:48:14,479
prospects I every way this is the way to

00:48:10,789 --> 00:48:16,400
better utilize all your resources and it

00:48:14,479 --> 00:48:19,459
makes managing all your resources pretty

00:48:16,400 --> 00:48:24,349
easy all of the innovation is happening

00:48:19,459 --> 00:48:27,650
in open source the collaborative nature

00:48:24,349 --> 00:48:30,349
and of the you know of the community and

00:48:27,650 --> 00:48:32,239
the speed at which these are these you

00:48:30,349 --> 00:48:34,369
know these these deficiencies these bugs

00:48:32,239 --> 00:48:37,099
are getting discovered and then fixed is

00:48:34,369 --> 00:48:40,309
it like that really shows the power of

00:48:37,099 --> 00:48:41,930
the of the open source community it is

00:48:40,309 --> 00:48:46,130
global and it's definitely because of

00:48:41,930 --> 00:48:52,459
the users community people are extremely

00:48:46,130 --> 00:48:54,229
friendly and always ready to help if you

00:48:52,459 --> 00:48:55,910
go an entire see any day you'll see

00:48:54,229 --> 00:48:57,799
these guys helping each other out and

00:48:55,910 --> 00:49:00,680
they're all doing it like in a selfless

00:48:57,799 --> 00:49:02,509
manner the product is transparent for

00:49:00,680 --> 00:49:06,709
everyone everyone can look at the code

00:49:02,509 --> 00:49:08,749
base everyone can see how close dark is

00:49:06,709 --> 00:49:14,599
being built nothing nothing is

00:49:08,749 --> 00:49:17,269
proprietary everything is open in many

00:49:14,599 --> 00:49:21,469
ways it's absolutely vital to the the

00:49:17,269 --> 00:49:25,219
unborn health card stack the most

00:49:21,469 --> 00:49:29,090
exciting event in recent memory for he

00:49:25,219 --> 00:49:31,760
was our first developer boot camp

00:49:29,090 --> 00:49:34,430
and our call gave people I gave you two

00:49:31,760 --> 00:49:38,390
weeks notice to come attend I was

00:49:34,430 --> 00:49:42,560
expecting 25 or 30 people so we ended up

00:49:38,390 --> 00:49:45,410
with 87 people and had to go get more

00:49:42,560 --> 00:49:47,930
chairs in the room twice everything

00:49:45,410 --> 00:49:51,260
within cloud computing is commodity and

00:49:47,930 --> 00:49:54,230
is open source and so I don't think that

00:49:51,260 --> 00:49:56,000
you will you'll see anywhere where open

00:49:54,230 --> 00:49:59,030
source is not pervasive in cloud

00:49:56,000 --> 00:50:01,580
computing and so i think it's i think

00:49:59,030 --> 00:50:03,110
it's an assumption i think when you talk

00:50:01,580 --> 00:50:06,820
about cloud computing you're really

00:50:03,110 --> 00:50:06,820
talking about it source cloud computing

00:50:07,090 --> 00:50:13,160
cloud sac is a robust solution for large

00:50:10,400 --> 00:50:15,530
deployments you'll have dozens of data

00:50:13,160 --> 00:50:19,580
centers and thousands of servers in each

00:50:15,530 --> 00:50:22,820
data centers these hardware is going to

00:50:19,580 --> 00:50:26,060
fail and CloudStack is designed to

00:50:22,820 --> 00:50:28,520
handle number one that mass scale number

00:50:26,060 --> 00:50:31,250
two it's designed to handle the failure

00:50:28,520 --> 00:50:34,130
that inevitably happens in large

00:50:31,250 --> 00:50:38,300
deployments started working on cog deck

00:50:34,130 --> 00:50:41,540
over four years ago and it was the

00:50:38,300 --> 00:50:43,370
original set of people working on it add

00:50:41,540 --> 00:50:47,450
a background of delivering software

00:50:43,370 --> 00:50:51,710
telcos and service providers lots of QA

00:50:47,450 --> 00:50:55,310
lots of users actually using it high

00:50:51,710 --> 00:50:58,400
availability is a key feature multiple

00:50:55,310 --> 00:51:00,560
hypervisors support different network

00:50:58,400 --> 00:51:03,590
models we can pick up whatever suits you

00:51:00,560 --> 00:51:05,360
better while step management server can

00:51:03,590 --> 00:51:09,050
be deployed in different physical

00:51:05,360 --> 00:51:10,700
machines it definitely has a huge

00:51:09,050 --> 00:51:15,680
footprint it's being deployed everywhere

00:51:10,700 --> 00:51:18,290
there's a major movie studio that they

00:51:15,680 --> 00:51:21,560
were using cloudstack they were using it

00:51:18,290 --> 00:51:23,540
to transcode video and i thought that

00:51:21,560 --> 00:51:25,190
was terribly fascinating what i found

00:51:23,540 --> 00:51:28,460
more fascinating is what they did during

00:51:25,190 --> 00:51:31,250
lunch where they would spin up you know

00:51:28,460 --> 00:51:32,420
50 or 60 game servers then as soon as

00:51:31,250 --> 00:51:34,250
lunch was over they would

00:51:32,420 --> 00:51:38,390
all the instances and go back to doing

00:51:34,250 --> 00:51:40,010
real work CloudStack is vast it touches

00:51:38,390 --> 00:51:42,080
so many different aspects and there's no

00:51:40,010 --> 00:51:44,480
one person that's kind of like a master

00:51:42,080 --> 00:51:48,560
of all those realms I think clouds stack

00:51:44,480 --> 00:51:50,780
as a project is going to be one of the

00:51:48,560 --> 00:51:54,860
leaders simply because it's some of the

00:51:50,780 --> 00:52:00,410
most feature fallen and and robust

00:51:54,860 --> 00:52:03,190
platforms out there Adam senior living

00:52:00,410 --> 00:52:03,190

YouTube URL: https://www.youtube.com/watch?v=cH9vvM6DwpM


