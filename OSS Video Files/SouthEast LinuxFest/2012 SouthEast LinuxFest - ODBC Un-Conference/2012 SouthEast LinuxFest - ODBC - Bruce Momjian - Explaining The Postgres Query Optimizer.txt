Title: 2012 SouthEast LinuxFest - ODBC - Bruce Momjian - Explaining The Postgres Query Optimizer
Publication date: 2014-06-30
Playlist: 2012 SouthEast LinuxFest - ODBC Un-Conference
Description: 
	2012 SouthEast LinuxFest
Open Database Camp (ODBC)

Bruce Momjian - Explaining the Postgres Query Optimizer
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,279
thank the following diamond sponsors in

00:00:21,320 --> 00:00:27,449
2012 for helping make these videos

00:00:23,279 --> 00:00:30,570
possible the press room the presentation

00:00:27,449 --> 00:00:32,279
I'm giving it a less common actually and

00:00:30,570 --> 00:00:37,440
the reason I wrote this presentation was

00:00:32,279 --> 00:00:40,489
because well as a trainer there's just

00:00:37,440 --> 00:00:44,460
too many cases ride to kind of explain

00:00:40,489 --> 00:00:45,840
what was happening in the system and the

00:00:44,460 --> 00:00:48,480
post Chris talks is grizzly I really

00:00:45,840 --> 00:00:50,760
don't cover it in enough detail it

00:00:48,480 --> 00:00:53,010
doesn't have any of the diagrams and

00:00:50,760 --> 00:00:54,780
there's some sort of finesse here so

00:00:53,010 --> 00:00:56,219
people coming from other databases seem

00:00:54,780 --> 00:00:58,289
to have no trouble understanding what

00:00:56,219 --> 00:00:59,850
post gross was doing but people coming

00:00:58,289 --> 00:01:02,039
from other databases were kind of liked

00:00:59,850 --> 00:01:05,700
or didn't have database background we're

00:01:02,039 --> 00:01:07,380
like exactly what is it doing and there

00:01:05,700 --> 00:01:09,330
was like a couple demos I used to do as

00:01:07,380 --> 00:01:12,840
a trainer but you know they really

00:01:09,330 --> 00:01:14,880
didn't they were really kind of half

00:01:12,840 --> 00:01:16,710
done so I figured I really need to write

00:01:14,880 --> 00:01:20,520
something conclusive that actually shows

00:01:16,710 --> 00:01:22,560
people what is happening in a very clear

00:01:20,520 --> 00:01:24,479
way because it is kind of behind the

00:01:22,560 --> 00:01:26,310
scenes and and invisible what I think I

00:01:24,479 --> 00:01:27,869
wrote it what well this is the update in

00:01:26,310 --> 00:01:29,939
januari but I think I blew it last year

00:01:27,869 --> 00:01:33,350
the presentation actually is available

00:01:29,939 --> 00:01:36,600
at this website as well as 30 other

00:01:33,350 --> 00:01:41,400
presentations related to postgres and

00:01:36,600 --> 00:01:43,619
three on home automation so basically

00:01:41,400 --> 00:01:46,170
what we're going to be talking about is

00:01:43,619 --> 00:01:47,549
some of the internals of postgres again

00:01:46,170 --> 00:01:49,290
you don't really have to understand this

00:01:47,549 --> 00:01:50,700
but it does help you I know some people

00:01:49,290 --> 00:01:52,530
were asking about how do you understand

00:01:50,700 --> 00:01:56,189
explain unfortunately they've left for

00:01:52,530 --> 00:01:59,790
the day but again you get the idea the

00:01:56,189 --> 00:02:01,170
idea is that this president this this is

00:01:59,790 --> 00:02:03,570
going to help you understand what

00:02:01,170 --> 00:02:05,850
explain is showing to you and it kind of

00:02:03,570 --> 00:02:07,890
also helps you to understand what

00:02:05,850 --> 00:02:11,220
postgres is doing behind the scenes for

00:02:07,890 --> 00:02:12,900
you that might not be obvious and also

00:02:11,220 --> 00:02:13,670
there are some things that you can do to

00:02:12,900 --> 00:02:17,030
kind of help

00:02:13,670 --> 00:02:18,739
postgres optimizer and and those will be

00:02:17,030 --> 00:02:21,530
clear to you once we go through the

00:02:18,739 --> 00:02:23,840
presentation so just to give you a sort

00:02:21,530 --> 00:02:26,959
of a large you know 10,000 foot view

00:02:23,840 --> 00:02:30,800
here we basically have the postgres

00:02:26,959 --> 00:02:33,950
server over here in red in blue and then

00:02:30,800 --> 00:02:35,390
we got effectively the queries coming

00:02:33,950 --> 00:02:37,610
from an application which is

00:02:35,390 --> 00:02:39,110
communicating with limb PQ and then it's

00:02:37,610 --> 00:02:41,450
sending the query to the database and

00:02:39,110 --> 00:02:43,970
then sitting the results back now inside

00:02:41,450 --> 00:02:45,769
that blue box we basically have a whole

00:02:43,970 --> 00:02:47,959
bunch of stages that postgres goes

00:02:45,769 --> 00:02:50,450
through I did put out a blog entry i

00:02:47,959 --> 00:02:51,950
believe on Friday explaining those

00:02:50,450 --> 00:02:54,260
stages and seeing how you can actually

00:02:51,950 --> 00:02:56,660
time them how many of any of you see it

00:02:54,260 --> 00:02:59,720
so great could somebody's looking good

00:02:56,660 --> 00:03:02,390
so effectively what the blog showed was

00:02:59,720 --> 00:03:04,519
that you can actually see the different

00:03:02,390 --> 00:03:06,410
stages in time how long each stage is

00:03:04,519 --> 00:03:09,769
taking so the first stage is the parser

00:03:06,410 --> 00:03:12,049
then the second the stage underneath the

00:03:09,769 --> 00:03:13,700
traffic cop is the rewriter and then the

00:03:12,049 --> 00:03:16,519
next two stages are basically the

00:03:13,700 --> 00:03:19,100
planner and then at the bottom is the

00:03:16,519 --> 00:03:20,780
executor and of course what we're really

00:03:19,100 --> 00:03:23,989
going to be talking about is that is

00:03:20,780 --> 00:03:25,130
that's that optimizer plan or part which

00:03:23,989 --> 00:03:26,480
is right here in the middle again

00:03:25,130 --> 00:03:28,730
optimizer plan or kind of

00:03:26,480 --> 00:03:31,459
interchangeable words the reason it's

00:03:28,730 --> 00:03:35,150
called a planner frankly is because the

00:03:31,459 --> 00:03:38,000
planner actually outputs a plan really

00:03:35,150 --> 00:03:40,190
very creative so the planner outputs a

00:03:38,000 --> 00:03:42,530
plan and the plan is what the executor

00:03:40,190 --> 00:03:45,380
does so but down here it's basically

00:03:42,530 --> 00:03:47,930
saying execute plan when the executor is

00:03:45,380 --> 00:03:50,870
running it's really just following the

00:03:47,930 --> 00:03:52,640
plan that the optimizer provided ok

00:03:50,870 --> 00:03:53,989
we're going to basically in this

00:03:52,640 --> 00:03:57,350
presentation we're going to highlight

00:03:53,989 --> 00:04:00,380
what is it that how does that optimizer

00:03:57,350 --> 00:04:06,470
get that plan why is that plan important

00:04:00,380 --> 00:04:08,120
to us and and why what what is the

00:04:06,470 --> 00:04:10,850
optimal you're really doing to make our

00:04:08,120 --> 00:04:12,380
job easier by creating this plan which

00:04:10,850 --> 00:04:14,510
would about be kind of what i want to

00:04:12,380 --> 00:04:17,539
say so how what does that optimize

00:04:14,510 --> 00:04:20,359
you're doing for our query it's giving

00:04:17,539 --> 00:04:23,210
us a benefit and the benefit is really

00:04:20,359 --> 00:04:24,409
pretty big yellow hey Chris so up this

00:04:23,210 --> 00:04:26,060
is actually a blow-up is just that

00:04:24,409 --> 00:04:27,280
section again we're going to be

00:04:26,060 --> 00:04:31,069
highlighting that

00:04:27,280 --> 00:04:32,870
optimizer area which i think is which i

00:04:31,069 --> 00:04:36,949
really think of as the brains of the

00:04:32,870 --> 00:04:39,500
system so this is really where a sort of

00:04:36,949 --> 00:04:41,120
the smarts of the system comes when i

00:04:39,500 --> 00:04:42,710
started getting involved with postgres

00:04:41,120 --> 00:04:45,409
one of the reasons that i got involved

00:04:42,710 --> 00:04:47,389
was an interest in really understanding

00:04:45,409 --> 00:04:52,370
that optimizer and understanding what

00:04:47,389 --> 00:04:54,020
happens inside the system before i start

00:04:52,370 --> 00:04:57,949
with postgres that you work with ingress

00:04:54,020 --> 00:05:00,860
and I worked with informix and I could

00:04:57,949 --> 00:05:03,080
basically ask the optimizer to see the

00:05:00,860 --> 00:05:04,969
plan that it was generating and same

00:05:03,080 --> 00:05:06,949
with ingress and you could get like a

00:05:04,969 --> 00:05:09,830
little tree and it would show you how it

00:05:06,949 --> 00:05:11,539
was executing the query but what's

00:05:09,830 --> 00:05:14,389
always fascinated me was how does it

00:05:11,539 --> 00:05:16,960
find that query like how does it

00:05:14,389 --> 00:05:19,460
actually figure out the best

00:05:16,960 --> 00:05:20,930
optimization so it would tell me what

00:05:19,460 --> 00:05:24,469
the plan is but it wouldn't tell me how

00:05:20,930 --> 00:05:26,150
it found it right and and my curiosity

00:05:24,469 --> 00:05:27,860
as a programmer was like okay I know

00:05:26,150 --> 00:05:29,539
it's I'm setting these queries it's

00:05:27,860 --> 00:05:33,080
giving me results back but how does it

00:05:29,539 --> 00:05:34,849
know what that great plan is and and and

00:05:33,080 --> 00:05:38,180
if you study it you can actually kind of

00:05:34,849 --> 00:05:39,889
see different style if you rearrange the

00:05:38,180 --> 00:05:41,659
query a little bit you get a little

00:05:39,889 --> 00:05:43,639
different plan coming out if you change

00:05:41,659 --> 00:05:44,810
some of the constants you get a little

00:05:43,639 --> 00:05:46,400
different plane coming out is that

00:05:44,810 --> 00:05:50,180
familiar with people you've ever tried

00:05:46,400 --> 00:05:51,949
this kind of thing and and and and with

00:05:50,180 --> 00:05:53,750
the older databases that this was

00:05:51,949 --> 00:05:55,669
actually an issue that you really had to

00:05:53,750 --> 00:05:57,830
work with because the you know the

00:05:55,669 --> 00:05:59,750
they're optimized would often go out to

00:05:57,830 --> 00:06:02,509
lunch you know and just really not do a

00:05:59,750 --> 00:06:04,310
good job and and you had to kind of say

00:06:02,509 --> 00:06:06,830
oh my goodness this report used to take

00:06:04,310 --> 00:06:08,629
you know tens 10 seconds or 10 minutes

00:06:06,830 --> 00:06:11,479
now is taking two hours what happened

00:06:08,629 --> 00:06:13,069
and you find out that something happened

00:06:11,479 --> 00:06:15,440
in the optimizers caused it to kind of

00:06:13,069 --> 00:06:17,589
just go away beserk and then you have to

00:06:15,440 --> 00:06:19,610
kind of you know rein it in somehow

00:06:17,589 --> 00:06:21,560
postgres doesn't have that much of a

00:06:19,610 --> 00:06:24,110
problem in terms of the optimizer going

00:06:21,560 --> 00:06:26,060
wacky but again it is always useful kind

00:06:24,110 --> 00:06:29,509
of understanding and also again as I

00:06:26,060 --> 00:06:31,339
said to help help give the optimizer as

00:06:29,509 --> 00:06:33,589
much information as it can to make the

00:06:31,339 --> 00:06:34,909
best plans and once you kind of

00:06:33,589 --> 00:06:36,319
understand the background I think it

00:06:34,909 --> 00:06:39,110
starts to make sense so let's uh let's

00:06:36,319 --> 00:06:40,639
actually look at what actually goes on

00:06:39,110 --> 00:06:42,560
the question here

00:06:40,639 --> 00:06:44,930
pop what decisions does the optimizer

00:06:42,560 --> 00:06:47,120
have to make and they're fundamentally

00:06:44,930 --> 00:06:51,229
three decisions that postgres optimizer

00:06:47,120 --> 00:06:53,659
makes one is the scan method and I'm

00:06:51,229 --> 00:06:55,310
going to be talking about that a second

00:06:53,659 --> 00:06:56,900
is a joint method I'm going to be talked

00:06:55,310 --> 00:07:00,590
about that and then finally join order

00:06:56,900 --> 00:07:01,819
which which I'll cover very briefly but

00:07:00,590 --> 00:07:04,879
these are the sort of the three

00:07:01,819 --> 00:07:06,469
fundamental things and and in fact when

00:07:04,879 --> 00:07:08,270
I started with postgres this is one of

00:07:06,469 --> 00:07:09,979
the I'd say one of the early areas we

00:07:08,270 --> 00:07:12,020
actually did some serious work in I

00:07:09,979 --> 00:07:14,389
remember talking to tom lane on the

00:07:12,020 --> 00:07:16,069
phone when we were trying to Tom

00:07:14,389 --> 00:07:17,689
actually got involved with postgres

00:07:16,069 --> 00:07:19,759
really being interested in the optimizer

00:07:17,689 --> 00:07:22,669
and we did couple phone calls back and

00:07:19,759 --> 00:07:24,949
forth trying to figure out well what is

00:07:22,669 --> 00:07:26,240
it doing why is it taking so long you

00:07:24,949 --> 00:07:28,370
know when does it make these crazy

00:07:26,240 --> 00:07:32,330
decisions and again this was in the in

00:07:28,370 --> 00:07:36,169
the mid 90s late 90s but it is really a

00:07:32,330 --> 00:07:37,819
fascinating area so which scan methods

00:07:36,169 --> 00:07:41,029
are possible for postgres we actually

00:07:37,819 --> 00:07:43,879
have three we actually will have a

00:07:41,029 --> 00:07:46,039
fourth in Postgres 92 which will be call

00:07:43,879 --> 00:07:48,710
index only scans which which obviously

00:07:46,039 --> 00:07:51,770
doesn't appear here yet the first ones

00:07:48,710 --> 00:07:53,449
pretty simple sequential scan the other

00:07:51,770 --> 00:07:55,279
two you might not have seen before index

00:07:53,449 --> 00:07:56,930
scan you might be aware of btree kind of

00:07:55,279 --> 00:07:59,389
index and again i'm going to show you

00:07:56,930 --> 00:08:02,210
specific examples of that about this but

00:07:59,389 --> 00:08:03,830
let's first set up a little test case

00:08:02,210 --> 00:08:05,810
here what we're going to do is we're

00:08:03,830 --> 00:08:08,479
going to pull some data from the PG

00:08:05,810 --> 00:08:10,580
class table which happens to be a system

00:08:08,479 --> 00:08:12,560
table in Postgres again just has a whole

00:08:10,580 --> 00:08:13,699
bunch of junk in it and what we're going

00:08:12,560 --> 00:08:17,000
to do is just going to pull the first

00:08:13,699 --> 00:08:19,399
letter off of that table so again I'm

00:08:17,000 --> 00:08:20,899
just creating some dummy data here I'm

00:08:19,399 --> 00:08:23,060
going to pull the first letter off of

00:08:20,899 --> 00:08:24,979
the PG class table and then I'm going to

00:08:23,060 --> 00:08:27,469
create a temporary table that's made up

00:08:24,979 --> 00:08:30,080
of that first letter and then a whole

00:08:27,469 --> 00:08:32,510
bunch of junk in fact I call it junk

00:08:30,080 --> 00:08:34,250
literally in in the field I hope

00:08:32,510 --> 00:08:37,039
burkitt's would approve of that label

00:08:34,250 --> 00:08:39,880
there it's not junk so I guess I got

00:08:37,039 --> 00:08:42,019
that part right and there's no what says

00:08:39,880 --> 00:08:43,760
he is not a reserved word there's no

00:08:42,019 --> 00:08:47,060
camel case in there so I think we're

00:08:43,760 --> 00:08:49,699
okay uh-huh then I actually order them

00:08:47,060 --> 00:08:52,130
randomly which is actually important for

00:08:49,699 --> 00:08:53,460
postgres because postgres understands

00:08:52,130 --> 00:08:55,500
when something is

00:08:53,460 --> 00:08:57,270
mustard and in some way you want to make

00:08:55,500 --> 00:08:59,220
sure they don't get clustered so you

00:08:57,270 --> 00:09:00,840
kind of throw some randomness in there

00:08:59,220 --> 00:09:02,040
and then we're just basically the Lotus

00:09:00,840 --> 00:09:03,870
table called sample we're going to

00:09:02,040 --> 00:09:05,400
cradle an index on there and if if

00:09:03,870 --> 00:09:07,020
you're curious you can actually look at

00:09:05,400 --> 00:09:09,420
the SQL that I use for this whole

00:09:07,020 --> 00:09:11,730
presentation so if you download that SQL

00:09:09,420 --> 00:09:15,480
that is literally SQL that that goes

00:09:11,730 --> 00:09:16,380
with this presentation okay so the other

00:09:15,480 --> 00:09:18,090
thing I'm going to do is I'm gonna

00:09:16,380 --> 00:09:20,820
create a function called letter look up

00:09:18,090 --> 00:09:23,580
letter which actually does and explain

00:09:20,820 --> 00:09:25,500
inside of a function I know it's kind of

00:09:23,580 --> 00:09:27,510
awkward but again you'll see it later it

00:09:25,500 --> 00:09:31,200
kind of makes the output look nice and

00:09:27,510 --> 00:09:33,630
pretty so the first thing we're going to

00:09:31,200 --> 00:09:35,250
do is we're going to actually use a set

00:09:33,630 --> 00:09:37,680
returning function or common table

00:09:35,250 --> 00:09:39,450
expression not know this is this is this

00:09:37,680 --> 00:09:41,460
is not a turn upon this is a common

00:09:39,450 --> 00:09:43,620
table expression we're basically going

00:09:41,460 --> 00:09:45,030
to create a little query that counts

00:09:43,620 --> 00:09:46,950
everything up and then we're going to

00:09:45,030 --> 00:09:48,870
basically do some statistical analysis

00:09:46,950 --> 00:09:52,470
on it and what it's going to show us is

00:09:48,870 --> 00:09:54,750
the distribution of letters within this

00:09:52,470 --> 00:09:57,120
sample table that we've created so as

00:09:54,750 --> 00:10:01,650
you can see seventy-eight percent of the

00:09:57,120 --> 00:10:04,320
letters the letters in that table RP it

00:10:01,650 --> 00:10:06,390
drops very quickly to three percent and

00:10:04,320 --> 00:10:07,950
then goes all the way down to 0.4

00:10:06,390 --> 00:10:11,670
percent and again this might seem kind

00:10:07,950 --> 00:10:12,690
of arbitrary to you but in fact there

00:10:11,670 --> 00:10:14,460
isn't a whole lot of difference between

00:10:12,690 --> 00:10:16,410
seventy eight percent and forty percent

00:10:14,460 --> 00:10:19,890
it's really down here we start to see a

00:10:16,410 --> 00:10:21,810
lot of variability so again there's no

00:10:19,890 --> 00:10:23,760
real definition of this order except

00:10:21,810 --> 00:10:25,200
that I've basically ordered them and you

00:10:23,760 --> 00:10:27,510
can see these are effectively unique

00:10:25,200 --> 00:10:31,320
here in the table where's these these

00:10:27,510 --> 00:10:34,530
obviously or not okay so let's uh let's

00:10:31,320 --> 00:10:35,790
just do a real crude example here again

00:10:34,530 --> 00:10:37,680
I think you talked about the explain

00:10:35,790 --> 00:10:39,840
command this morning and what it does so

00:10:37,680 --> 00:10:40,740
let's actually take a look at that what

00:10:39,840 --> 00:10:43,020
we're actually going to do is we're

00:10:40,740 --> 00:10:46,920
going to issue explain on a very simple

00:10:43,020 --> 00:10:48,690
query for this actual sample table and

00:10:46,920 --> 00:10:50,760
we're just going to look up the letter P

00:10:48,690 --> 00:10:52,860
so we're just going to basically say you

00:10:50,760 --> 00:10:54,810
know if I'm going to look up litter p

00:10:52,860 --> 00:10:56,490
what are you going to do that's what the

00:10:54,810 --> 00:10:58,050
explain command does where it says it

00:10:56,490 --> 00:11:00,420
says okay what is the point what is the

00:10:58,050 --> 00:11:02,370
optimizer what is the planner going to

00:11:00,420 --> 00:11:05,520
output for that particular query and in

00:11:02,370 --> 00:11:06,410
this case a letter P is outputting

00:11:05,520 --> 00:11:09,829
something called

00:11:06,410 --> 00:11:11,810
scam that's actually a little surprising

00:11:09,829 --> 00:11:13,759
and I'm going to explain a wall in a

00:11:11,810 --> 00:11:16,819
minute why but let's just go with that

00:11:13,759 --> 00:11:18,560
right now okay so we put the letter P in

00:11:16,819 --> 00:11:21,589
it says it wants to do an index skin it

00:11:18,560 --> 00:11:24,560
tells us how expensive it is it says it

00:11:21,589 --> 00:11:28,069
expects one raw which also seems kind of

00:11:24,560 --> 00:11:29,660
kooky to me but but let's just let's

00:11:28,069 --> 00:11:31,579
just go wit and pit and see what happens

00:11:29,660 --> 00:11:33,980
ok so then I'm also going to ask her the

00:11:31,579 --> 00:11:37,279
letter D which you might remember was

00:11:33,980 --> 00:11:39,680
was down here one-point-six percent of

00:11:37,279 --> 00:11:43,550
table and it also does an index cam

00:11:39,680 --> 00:11:45,709
which again is ok I guess I also also

00:11:43,550 --> 00:11:48,769
expect one row not really great and then

00:11:45,709 --> 00:11:51,529
also try the letter K which you might

00:11:48,769 --> 00:11:53,839
remember was was a unique letter in our

00:11:51,529 --> 00:11:55,759
inner test and that's all she doing

00:11:53,839 --> 00:11:57,740
index here right now basically optimizer

00:11:55,759 --> 00:11:59,029
is not impressing me it doesn't really

00:11:57,740 --> 00:12:01,160
know how many rows are coming out and

00:11:59,029 --> 00:12:02,959
thinks it's always one it's always doing

00:12:01,160 --> 00:12:06,110
an index scan is this really really

00:12:02,959 --> 00:12:07,519
great no it actually is terrible and I'm

00:12:06,110 --> 00:12:10,670
going to I'm gonna explain why right

00:12:07,519 --> 00:12:14,899
here okay the reason the optimizer is

00:12:10,670 --> 00:12:17,209
doing this sort of very consistent but

00:12:14,899 --> 00:12:19,160
wrong that I think is because we've not

00:12:17,209 --> 00:12:21,110
given it any analyzed statistics on this

00:12:19,160 --> 00:12:24,529
particular table so this is the

00:12:21,110 --> 00:12:26,300
optimizer has no idea if there's that

00:12:24,529 --> 00:12:30,769
doesn't know there's seventy percent of

00:12:26,300 --> 00:12:32,810
the roads your pee okay it assumes that

00:12:30,769 --> 00:12:35,360
every lookup is unique because in fact

00:12:32,810 --> 00:12:37,939
you can see that right here for one okay

00:12:35,360 --> 00:12:41,209
so it doesn't really know until we run

00:12:37,939 --> 00:12:43,970
analyze or until the oil vacuum system

00:12:41,209 --> 00:12:45,230
runs and sees this or some data in the

00:12:43,970 --> 00:12:47,689
table and sees that there's no

00:12:45,230 --> 00:12:50,569
statistics or sees it that that

00:12:47,689 --> 00:12:52,459
statistical data is old and then one is

00:12:50,569 --> 00:12:55,220
an auto analyze on that if you've ever

00:12:52,459 --> 00:12:57,439
heard of auto analyze that's kind of

00:12:55,220 --> 00:12:59,500
another feature so the bottom line is

00:12:57,439 --> 00:13:02,420
that we don't really have any statistics

00:12:59,500 --> 00:13:04,399
until we won this analyzed command or

00:13:02,420 --> 00:13:07,009
until all the vacuum is actually run to

00:13:04,399 --> 00:13:12,590
give us some statistics on that table

00:13:07,009 --> 00:13:17,840
are there any questions so far okay

00:13:12,590 --> 00:13:19,790
so once we run the analyze you can see

00:13:17,840 --> 00:13:22,730
we actually get some significantly

00:13:19,790 --> 00:13:25,820
different output so when we now look up

00:13:22,730 --> 00:13:28,520
the letter P we're now seeing something

00:13:25,820 --> 00:13:30,200
called a sequential scan okay and this

00:13:28,520 --> 00:13:33,140
is actually what we want it to do

00:13:30,200 --> 00:13:35,300
because the letter P is very common an

00:13:33,140 --> 00:13:37,790
index look up that's not very

00:13:35,300 --> 00:13:39,530
restrictive like the letter P is

00:13:37,790 --> 00:13:41,570
effectively better done using a

00:13:39,530 --> 00:13:44,720
sequential scan then bouncing around and

00:13:41,570 --> 00:13:46,280
index and then getting to the data it's

00:13:44,720 --> 00:13:48,500
just easier to read the data right

00:13:46,280 --> 00:13:50,600
because the index we know by definition

00:13:48,500 --> 00:13:53,930
the index is only going to remove

00:13:50,600 --> 00:13:57,110
twenty-two percent of the rose okay and

00:13:53,930 --> 00:13:58,460
the odds that with it those twenty two

00:13:57,110 --> 00:14:00,380
percent of the roads aren't also going

00:13:58,460 --> 00:14:02,480
to be on pages that also have data is

00:14:00,380 --> 00:14:04,160
pretty slim so odds are structure we

00:14:02,480 --> 00:14:08,360
don't the whole pay toll table anyway

00:14:04,160 --> 00:14:10,490
right so an index being sort of randomly

00:14:08,360 --> 00:14:12,380
bounced around and you know a lot of

00:14:10,490 --> 00:14:14,030
random i/o is just really expensive to

00:14:12,380 --> 00:14:16,340
do sequential scans are much quicker I

00:14:14,030 --> 00:14:19,670
mean you know by definitely I think I

00:14:16,340 --> 00:14:22,070
think if you actually do some timing you

00:14:19,670 --> 00:14:26,420
know a sequential skin is often like a

00:14:22,070 --> 00:14:28,250
hundred times faster okay I know we have

00:14:26,420 --> 00:14:31,850
a random page cost of four but if you

00:14:28,250 --> 00:14:35,030
actually run the actual test random is

00:14:31,850 --> 00:14:36,950
just way slower and you can see that

00:14:35,030 --> 00:14:42,530
when you're on benchmarks on the drive

00:14:36,950 --> 00:14:44,150
seen a raw raw numbers well I so the

00:14:42,530 --> 00:14:46,160
question is how is that vary among

00:14:44,150 --> 00:14:47,930
different types of drives it varies

00:14:46,160 --> 00:14:52,030
quite a bit so for example if we're

00:14:47,930 --> 00:14:54,410
running on an SSD instead of a number of

00:14:52,030 --> 00:14:56,660
44 random page cross roommates we might

00:14:54,410 --> 00:14:58,250
want to take it to like 1.2 or something

00:14:56,660 --> 00:15:01,450
like that we still wouldn't take it all

00:14:58,250 --> 00:15:04,730
the way to Juan but but even if I mean

00:15:01,450 --> 00:15:07,310
this is a great point even if the random

00:15:04,730 --> 00:15:10,100
cost was just as it was just the same

00:15:07,310 --> 00:15:11,360
cost as a sequential we still would want

00:15:10,100 --> 00:15:14,240
to do the sequential because there's no

00:15:11,360 --> 00:15:16,160
sense in reading the whole index and

00:15:14,240 --> 00:15:18,650
then the whole table when we could just

00:15:16,160 --> 00:15:20,990
read the whole table and obviously do

00:15:18,650 --> 00:15:23,030
much less io that we would need to touch

00:15:20,990 --> 00:15:24,620
that index and that's really one of the

00:15:23,030 --> 00:15:25,430
fundamental things of that optimizers

00:15:24,620 --> 00:15:28,279
doing

00:15:25,430 --> 00:15:30,050
and what you can also see the optimizer

00:15:28,279 --> 00:15:36,200
now has a very good estimate the number

00:15:30,050 --> 00:15:38,260
of rows so it's same 199 I think that it

00:15:36,200 --> 00:15:41,210
actually matches it right on the dot

00:15:38,260 --> 00:15:43,670
okay so instead of sort of throwing out

00:15:41,210 --> 00:15:46,220
one row which is what it did hear it now

00:15:43,670 --> 00:15:48,980
kind of knows yeah I'm going after 199

00:15:46,220 --> 00:15:52,970
rose right and it's even telling us what

00:15:48,980 --> 00:15:54,800
it's using as a filter alright in this

00:15:52,970 --> 00:15:56,180
effective what a sequential skin is it's

00:15:54,800 --> 00:15:58,850
just read from the front to the back

00:15:56,180 --> 00:16:01,370
right just and and the the file system

00:15:58,850 --> 00:16:03,200
kernel does read ahead for us so it

00:16:01,370 --> 00:16:05,570
knows we're going sequentially and it's

00:16:03,200 --> 00:16:08,300
it's prefetching all that stuff from the

00:16:05,570 --> 00:16:11,870
drive and and and you know we're home at

00:16:08,300 --> 00:16:15,080
this point all right what about the

00:16:11,870 --> 00:16:17,540
letter D now letter D was a little less

00:16:15,080 --> 00:16:20,120
likely in fact I know right now it's

00:16:17,540 --> 00:16:23,390
four because the optimizer seems to know

00:16:20,120 --> 00:16:25,160
exactly how many letters are okay so we

00:16:23,390 --> 00:16:28,970
know there's actually four DS in there

00:16:25,160 --> 00:16:30,920
and 44 it's not going to do a sequential

00:16:28,970 --> 00:16:32,029
scan because again it's pretty rare but

00:16:30,920 --> 00:16:34,279
it's going to do something called a

00:16:32,029 --> 00:16:36,560
bitmap heap scan which looks like this

00:16:34,279 --> 00:16:38,630
now this is a little kind of a unusual

00:16:36,560 --> 00:16:40,730
diagram it's actually showing two

00:16:38,630 --> 00:16:41,660
indexes being combined but effectively

00:16:40,730 --> 00:16:43,670
what it's going to do it's going to

00:16:41,660 --> 00:16:45,230
create a bitmap so it's going to bounce

00:16:43,670 --> 00:16:47,750
around the index is going to find all

00:16:45,230 --> 00:16:51,380
four of those entries and it's going to

00:16:47,750 --> 00:16:53,029
create a bitmap of the pages and it's

00:16:51,380 --> 00:16:54,320
kind of a one for every page that has a

00:16:53,029 --> 00:16:57,860
possible match on it's going to read

00:16:54,320 --> 00:16:58,940
that bitmap and then go to the heap and

00:16:57,860 --> 00:17:00,380
what that's going to do it's going to

00:16:58,940 --> 00:17:02,029
aggregate some of the things so we're

00:17:00,380 --> 00:17:04,309
not going to go to page 12 and then page

00:17:02,029 --> 00:17:06,290
10 and then page 12 then page 10 and

00:17:04,309 --> 00:17:08,630
then page 12 of page 10 we're

00:17:06,290 --> 00:17:11,240
effectively going to go to a page 10 do

00:17:08,630 --> 00:17:14,120
everything go to page 12 do everything

00:17:11,240 --> 00:17:18,189
okay so when you start to see indexes

00:17:14,120 --> 00:17:21,500
that actually match multiple multiple

00:17:18,189 --> 00:17:25,160
index values you do start to see this

00:17:21,500 --> 00:17:29,300
bitmap index can you know become become

00:17:25,160 --> 00:17:32,240
it popular the letter K which you may

00:17:29,300 --> 00:17:35,600
remember has one matching row does a

00:17:32,240 --> 00:17:37,280
very traditional bitmap index scan so

00:17:35,600 --> 00:17:38,220
it's going to go three index it's going

00:17:37,280 --> 00:17:39,840
to look for the match and it's

00:17:38,220 --> 00:17:42,120
going to be told exactly where that

00:17:39,840 --> 00:17:44,220
particular role is one particular page

00:17:42,120 --> 00:17:45,419
and it's going to pull the row out so

00:17:44,220 --> 00:17:47,760
this is obviously one thing the

00:17:45,419 --> 00:17:50,789
optimizer is doing for us it knows based

00:17:47,760 --> 00:17:53,700
on the constant will be passed to it how

00:17:50,789 --> 00:17:55,740
to most efficiently access that data but

00:17:53,700 --> 00:17:59,870
it will only do that assuming it has the

00:17:55,740 --> 00:18:05,850
analyzed statistics to enable that good

00:17:59,870 --> 00:18:09,809
okay so let's look at a little more sort

00:18:05,850 --> 00:18:11,340
of a varied example here basically what

00:18:09,809 --> 00:18:12,630
i'm going to do and this is where we

00:18:11,340 --> 00:18:14,190
start to use that little function i

00:18:12,630 --> 00:18:16,440
created what i'm going to do is I'm

00:18:14,190 --> 00:18:17,640
going to use a common table expression

00:18:16,440 --> 00:18:19,350
is everyone good with common table

00:18:17,640 --> 00:18:20,909
expressions is that kind of so we

00:18:19,350 --> 00:18:21,929
basically haven't talked about comic

00:18:20,909 --> 00:18:24,870
table expressions if we're interested

00:18:21,929 --> 00:18:28,470
but effectively what we do is we we sort

00:18:24,870 --> 00:18:32,100
of create a pseudo table up here called

00:18:28,470 --> 00:18:33,330
letter okay and here's this is a classic

00:18:32,100 --> 00:18:35,669
I've got the name of the table and a

00:18:33,330 --> 00:18:38,669
column exactly the same so burkas might

00:18:35,669 --> 00:18:42,960
be upset but yeah I actually this is

00:18:38,669 --> 00:18:46,980
this is going to get a win here yeah so

00:18:42,960 --> 00:18:49,440
um so effectively that may be something

00:18:46,980 --> 00:18:51,510
to add to the presentation we can look

00:18:49,440 --> 00:18:52,980
at that so effectively we got this

00:18:51,510 --> 00:18:55,860
letter and now we're going to basically

00:18:52,980 --> 00:18:57,600
run through all the letters and their

00:18:55,860 --> 00:19:00,450
counts and we're going to basically do

00:18:57,600 --> 00:19:01,590
and explain on each one okay now what

00:19:00,450 --> 00:19:03,450
does that look like it actually looks

00:19:01,590 --> 00:19:05,190
like something like this however this is

00:19:03,450 --> 00:19:07,320
kind of a boast and I don't want to see

00:19:05,190 --> 00:19:11,429
this line so we're going to basically do

00:19:07,320 --> 00:19:13,830
a limit one here to kind of trim off

00:19:11,429 --> 00:19:15,990
what's coming out of the function and

00:19:13,830 --> 00:19:17,940
we're going to get this and to me this

00:19:15,990 --> 00:19:19,919
is the you know this is the rosetta

00:19:17,940 --> 00:19:22,880
stone this is the money shot for this

00:19:19,919 --> 00:19:26,070
presentation because what it's showing

00:19:22,880 --> 00:19:29,280
yes i did look that up and it actually

00:19:26,070 --> 00:19:32,640
is not always the way we might assume it

00:19:29,280 --> 00:19:36,570
is so I did a little Google on that so

00:19:32,640 --> 00:19:42,120
supposedly money shot is is okay yeah

00:19:36,570 --> 00:19:43,679
yeah see what's this you're not buying

00:19:42,120 --> 00:19:46,830
that all right maybe I need to pull that

00:19:43,679 --> 00:19:47,820
out then but you think I do okay it's

00:19:46,830 --> 00:19:49,950
too

00:19:47,820 --> 00:19:51,750
you tainted to really use all right well

00:19:49,950 --> 00:19:53,910
that's a shame because I really think

00:19:51,750 --> 00:19:55,260
this is a good shot good well we'll call

00:19:53,910 --> 00:19:56,970
this the rosetta stone and then but I

00:19:55,260 --> 00:20:00,420
need some other terminology I'm open to

00:19:56,970 --> 00:20:06,180
suggestions so effectively what we have

00:20:00,420 --> 00:20:08,970
here is a display of how the optimizer

00:20:06,180 --> 00:20:12,840
chooses different plans based on the

00:20:08,970 --> 00:20:14,760
frequency of the constant supplied and

00:20:12,840 --> 00:20:18,330
you just don't see this a lot you might

00:20:14,760 --> 00:20:21,300
see a query what's this well if you had

00:20:18,330 --> 00:20:24,330
been watching the presentation you would

00:20:21,300 --> 00:20:26,190
have seen that i created a function at

00:20:24,330 --> 00:20:29,570
the beginning that doesn't explain and

00:20:26,190 --> 00:20:32,280
then i basically go and create a little

00:20:29,570 --> 00:20:33,990
pseudo table a common table expression

00:20:32,280 --> 00:20:36,810
and then I run the function on it and

00:20:33,990 --> 00:20:38,940
then I trim off the bottom part I just

00:20:36,810 --> 00:20:41,090
get the top part right so the cool thing

00:20:38,940 --> 00:20:43,290
about this is that it's like all here

00:20:41,090 --> 00:20:44,850
sometimes if you're running a test and

00:20:43,290 --> 00:20:46,410
you're like you run a query and you'll

00:20:44,850 --> 00:20:47,700
go retype it or your edit and you'll

00:20:46,410 --> 00:20:49,650
change your constant you see the plan

00:20:47,700 --> 00:20:51,180
change you're like okay the plan change

00:20:49,650 --> 00:20:52,440
because I use a different constant this

00:20:51,180 --> 00:20:54,900
is the cool thing because it gets it all

00:20:52,440 --> 00:20:56,760
on one slide right so what you can see

00:20:54,900 --> 00:20:58,620
you can see a couple interesting things

00:20:56,760 --> 00:21:00,270
here so the first thing is that

00:20:58,620 --> 00:21:03,330
obviously in red we have all the

00:21:00,270 --> 00:21:05,700
sequential scans right and you can see

00:21:03,330 --> 00:21:07,260
up until you get 27 you were going to do

00:21:05,700 --> 00:21:09,270
a sequential skin which is fairly low

00:21:07,260 --> 00:21:15,480
because remember there's two hundred and

00:21:09,270 --> 00:21:18,300
some rows in here right but still the

00:21:15,480 --> 00:21:19,980
the cutoff for doing a sequential on

00:21:18,300 --> 00:21:22,320
sequential skin is much lower than

00:21:19,980 --> 00:21:24,870
people think right because I think we

00:21:22,320 --> 00:21:29,970
decided this table had and I'm going to

00:21:24,870 --> 00:21:36,750
back up here uh where is it where are

00:21:29,970 --> 00:21:40,050
you oh oh I guess I trimmed off that I

00:21:36,750 --> 00:21:44,400
trim off my counts on this I might have

00:21:40,050 --> 00:21:48,780
oh that's nasty Oh 253 there we go so we

00:21:44,400 --> 00:21:50,940
have 250 three rows the r which i think

00:21:48,780 --> 00:21:54,600
is where we cut off is two point eight

00:21:50,940 --> 00:21:55,980
percent okay so one really interesting

00:21:54,600 --> 00:21:57,990
thing here remember I got this junk

00:21:55,980 --> 00:22:00,120
field in there so it's kind of fleshing

00:21:57,990 --> 00:22:01,420
out the role it's not just the number

00:22:00,120 --> 00:22:03,820
okay but what's

00:22:01,420 --> 00:22:05,410
interesting is that your you're only

00:22:03,820 --> 00:22:07,120
looking at two point eight percent of

00:22:05,410 --> 00:22:09,610
the rose and the system still wants to

00:22:07,120 --> 00:22:12,340
do a sequential scan that's really low

00:22:09,610 --> 00:22:14,950
but if you and i'm going to show you

00:22:12,340 --> 00:22:17,740
later once you if you actually try

00:22:14,950 --> 00:22:20,560
forcing it to do an index scan it will

00:22:17,740 --> 00:22:22,930
be slower so the number is usually the

00:22:20,560 --> 00:22:27,490
numbers we usually see are in the five

00:22:22,930 --> 00:22:30,690
percent range so in a constant its past

00:22:27,490 --> 00:22:32,440
really has to be under five percent

00:22:30,690 --> 00:22:42,610
before we're going to consider a

00:22:32,440 --> 00:22:44,320
non-sequential skin yes um no I mean

00:22:42,610 --> 00:22:51,160
historically we see it in the five

00:22:44,320 --> 00:22:52,510
percent range it's more percentage based

00:22:51,160 --> 00:22:55,750
yeah it's really going to be

00:22:52,510 --> 00:22:57,370
percentage-based because again um the

00:22:55,750 --> 00:23:00,970
num I'm and then the heuristics are

00:22:57,370 --> 00:23:02,590
really complicated but but this is not a

00:23:00,970 --> 00:23:04,930
super tiny table because they're each

00:23:02,590 --> 00:23:06,970
one has like 200 each row is like 250

00:23:04,930 --> 00:23:08,590
bytes or to 60 bytes or something like

00:23:06,970 --> 00:23:14,320
that so you're getting I guess you're

00:23:08,590 --> 00:23:17,500
getting about eight rows now you get 32

00:23:14,320 --> 00:23:19,690
rose on a page something like that I was

00:23:17,500 --> 00:23:22,720
eight times for so yeah like 32 rose on

00:23:19,690 --> 00:23:25,750
my page so yeah it's you know it's it's

00:23:22,720 --> 00:23:27,790
not it's pretty small but effectively

00:23:25,750 --> 00:23:29,920
when posters going to do its computation

00:23:27,790 --> 00:23:33,190
it's really going to be based on right

00:23:29,920 --> 00:23:41,430
how how what the percentage is and it is

00:23:33,190 --> 00:23:41,430
going to be around five percent of right

00:24:07,450 --> 00:24:14,380
I'm sorry yeah the weight values are

00:24:11,679 --> 00:24:17,769
really going to yeah so in fact i have

00:24:14,380 --> 00:24:20,889
an example here which i think is kind of

00:24:17,769 --> 00:24:22,870
useful so I I basically have the rosetta

00:24:20,889 --> 00:24:25,600
stone right which which kind of shows

00:24:22,870 --> 00:24:29,860
everything and what I actually did was I

00:24:25,600 --> 00:24:33,909
actually turned off sequential scan and

00:24:29,860 --> 00:24:35,500
bitmap skin and I ran it again okay so

00:24:33,909 --> 00:24:37,600
just as you would have done it when you

00:24:35,500 --> 00:24:39,909
were testing you're basically forcing

00:24:37,600 --> 00:24:43,600
the system to do an index scan all right

00:24:39,909 --> 00:24:48,820
and now I'm running the same query okay

00:24:43,600 --> 00:24:53,789
and what you basically see is that the

00:24:48,820 --> 00:24:59,740
total cost for this P which used to be

00:24:53,789 --> 00:25:02,679
13 okay has now gone up to 39 at least

00:24:59,740 --> 00:25:04,779
in the costing system so it considers

00:25:02,679 --> 00:25:06,850
this index look up to find all the piece

00:25:04,779 --> 00:25:08,889
to be about three times as expensive as

00:25:06,850 --> 00:25:11,049
the sequential scan what you're fat

00:25:08,889 --> 00:25:12,159
about seems what we think it was and

00:25:11,049 --> 00:25:13,779
then if we actually start to look

00:25:12,159 --> 00:25:15,639
farther down you can see these numbers

00:25:13,779 --> 00:25:18,850
have grown all the way up so it goes

00:25:15,639 --> 00:25:21,490
from eight to 12 to 15 to 19 all the way

00:25:18,850 --> 00:25:23,529
up as the table gets bigger or as that

00:25:21,490 --> 00:25:27,130
it gets less restrictive you get more it

00:25:23,529 --> 00:25:28,960
gets more and more expensive yeah what's

00:25:27,130 --> 00:25:32,169
really interesting here is that the

00:25:28,960 --> 00:25:35,370
numbers seem stay fairly low this is

00:25:32,169 --> 00:25:35,370
what I was going to point out

00:25:52,780 --> 00:25:59,010
yep yep yeah

00:26:25,760 --> 00:26:35,730
Yeah right here right here yeah and

00:26:29,910 --> 00:26:37,740
right here yeah yeah yeah what's really

00:26:35,730 --> 00:26:39,090
i mean what's really bizarre is when i

00:26:37,740 --> 00:26:40,920
wrote this when i wrote this

00:26:39,090 --> 00:26:43,470
presentation as when I wrote the mvcc

00:26:40,920 --> 00:26:46,050
presentation I basically just wrote the

00:26:43,470 --> 00:26:47,010
queries okay so there's a whole actually

00:26:46,050 --> 00:26:49,290
I've got probably three or four

00:26:47,010 --> 00:26:54,330
presentations now well I basically write

00:26:49,290 --> 00:26:57,210
the SQL and then I drag it into licks

00:26:54,330 --> 00:26:59,670
with the editor and then I mark it up

00:26:57,210 --> 00:27:01,140
right so as I showed you that query that

00:26:59,670 --> 00:27:02,460
I had the beginning you could be run

00:27:01,140 --> 00:27:04,920
this you'll get the exact same numbers

00:27:02,460 --> 00:27:07,320
okay but what's also interesting is I

00:27:04,920 --> 00:27:08,790
didn't jury this at all like I said I

00:27:07,320 --> 00:27:11,190
we're ever gonna get some freak data

00:27:08,790 --> 00:27:12,780
that has a distribution that I'm going

00:27:11,190 --> 00:27:15,420
to it's going to be interesting right

00:27:12,780 --> 00:27:16,890
have some variability in terms of common

00:27:15,420 --> 00:27:19,140
values non-convex well it's just the

00:27:16,890 --> 00:27:20,640
tables boom PG class great all right

00:27:19,140 --> 00:27:22,920
it's small enough I can kind of work

00:27:20,640 --> 00:27:25,410
with it I didn't look around for

00:27:22,920 --> 00:27:27,480
something like this I mean you know how

00:27:25,410 --> 00:27:29,700
much better could I get then to be able

00:27:27,480 --> 00:27:32,370
to see all three distributions in pretty

00:27:29,700 --> 00:27:34,230
nice groupings you know but the pump the

00:27:32,370 --> 00:27:37,710
boys I didn't do anything fancy to do

00:27:34,230 --> 00:27:39,390
this this was my first attempt okay when

00:27:37,710 --> 00:27:40,890
I said I wanted some variable

00:27:39,390 --> 00:27:43,050
distributions and pull off the first

00:27:40,890 --> 00:27:46,980
letter that's what I got I didn't have

00:27:43,050 --> 00:27:49,200
to do anything fancy to get this which

00:27:46,980 --> 00:27:50,880
which surprised me because I thought

00:27:49,200 --> 00:27:53,160
that it would take a lot more work to

00:27:50,880 --> 00:27:56,280
get something that really Illustrated so

00:27:53,160 --> 00:27:59,880
clearly right but you're right these

00:27:56,280 --> 00:28:01,770
numbers just keep shooting up and

00:27:59,880 --> 00:28:04,500
obviously it's because we haven't given

00:28:01,770 --> 00:28:06,420
the optimizer any kind of any kind of

00:28:04,500 --> 00:28:08,520
you know chance to improve things and

00:28:06,420 --> 00:28:10,560
you can see these basically are very

00:28:08,520 --> 00:28:13,530
gradual in terms of how they increase

00:28:10,560 --> 00:28:20,640
they do increase but again in a very in

00:28:13,530 --> 00:28:22,830
a very marginal way this is basically

00:28:20,640 --> 00:28:25,020
the original query which again shows you

00:28:22,830 --> 00:28:28,230
the 13 all the way down to the eight

00:28:25,020 --> 00:28:29,610
basically so the the 39 with with the

00:28:28,230 --> 00:28:34,890
optimizer working fully

00:28:29,610 --> 00:28:36,690
is now one third the time basically any

00:28:34,890 --> 00:28:37,950
questions before we move off that's the

00:28:36,690 --> 00:28:39,330
scan type now we're going to look at

00:28:37,950 --> 00:28:41,549
joins and this is where we kind of just

00:28:39,330 --> 00:28:43,590
have some diagrams post chris has four

00:28:41,549 --> 00:28:46,110
different join types nested loop it has

00:28:43,590 --> 00:28:47,220
sort of two and then hash to run emerge

00:28:46,110 --> 00:28:50,309
when I'm going to show you some examples

00:28:47,220 --> 00:28:52,140
of each of these again using some tables

00:28:50,309 --> 00:28:54,570
from the system tables and I actually

00:28:52,140 --> 00:28:56,400
pulled my data here from the PG proc

00:28:54,570 --> 00:28:58,559
table again another system table a

00:28:56,400 --> 00:29:00,330
little bigger and I basically just

00:28:58,559 --> 00:29:02,700
pulled some numbers off the PG proc

00:29:00,330 --> 00:29:05,160
table and I pulled some numbers off the

00:29:02,700 --> 00:29:08,970
PG class table so I basically grabbed

00:29:05,160 --> 00:29:12,059
the OID from the PG class table and the

00:29:08,970 --> 00:29:15,169
OID from the proc table and kind of

00:29:12,059 --> 00:29:17,340
loaded in two temporary tables okay and

00:29:15,169 --> 00:29:19,200
again i'm not using letters now i'm

00:29:17,340 --> 00:29:22,140
using numbers these are now unique

00:29:19,200 --> 00:29:24,690
numbers so it makes it a little a little

00:29:22,140 --> 00:29:27,690
cleaner to do a joint and a little more

00:29:24,690 --> 00:29:30,110
predictable I think okay and one

00:29:27,690 --> 00:29:33,179
highlight you should see is that this

00:29:30,110 --> 00:29:36,240
sample one is our big table will based

00:29:33,179 --> 00:29:39,059
on PG proc which is larger and the

00:29:36,240 --> 00:29:44,160
sample two is only 260 rose so it's

00:29:39,059 --> 00:29:45,720
gotten obviously smaller okay and we are

00:29:44,160 --> 00:29:48,540
going to randomly get those in there so

00:29:45,720 --> 00:29:49,740
we were sure that there's no so

00:29:48,540 --> 00:29:52,830
optimizers doesn't do anything fancy

00:29:49,740 --> 00:29:54,660
okay and we also have no indexes and no

00:29:52,830 --> 00:29:57,870
optimize your statistics on these right

00:29:54,660 --> 00:30:00,330
so this is very crude if we just join

00:29:57,870 --> 00:30:02,730
the two tables together using Nancy join

00:30:00,330 --> 00:30:04,169
and we actually restrict it to a certain

00:30:02,730 --> 00:30:06,900
constant we get something called a

00:30:04,169 --> 00:30:08,640
nested loop and the nested loop is

00:30:06,900 --> 00:30:11,220
actually really good for sort of really

00:30:08,640 --> 00:30:13,830
small result sets very short joins

00:30:11,220 --> 00:30:17,010
there's no set up for it it can

00:30:13,830 --> 00:30:19,080
basically sequential scan the one table

00:30:17,010 --> 00:30:21,030
and then basically just pull off things

00:30:19,080 --> 00:30:23,549
from the other table the reason this is

00:30:21,030 --> 00:30:26,400
quick is because we are only really

00:30:23,549 --> 00:30:28,500
pulling one value off of or it's

00:30:26,400 --> 00:30:30,360
assuming one value because uh no

00:30:28,500 --> 00:30:31,830
actually it isn't look it's these are

00:30:30,360 --> 00:30:33,809
the estimates of how much it thinks it's

00:30:31,830 --> 00:30:35,700
getting 50 it thinks from this one and

00:30:33,809 --> 00:30:37,590
it thinks it's getting six again there's

00:30:35,700 --> 00:30:40,830
no optimizer statistics so it doesn't

00:30:37,590 --> 00:30:43,050
know okay nested loop actually looks

00:30:40,830 --> 00:30:43,500
like this it's basically every row is

00:30:43,050 --> 00:30:46,970
touch

00:30:43,500 --> 00:30:49,470
every other row again completely bizarre

00:30:46,970 --> 00:30:52,200
but it's basically comparing every row

00:30:49,470 --> 00:30:54,000
to every other row and this is what the

00:30:52,200 --> 00:30:57,360
pseudocode looks like a very very

00:30:54,000 --> 00:31:00,210
trivial if I do a different type of join

00:30:57,360 --> 00:31:02,370
and now instead of saying equal 33 they

00:31:00,210 --> 00:31:05,310
say greater than 33 so now I'm I'm

00:31:02,370 --> 00:31:08,100
pulling a much larger section of sample

00:31:05,310 --> 00:31:10,920
one from might from my query I actually

00:31:08,100 --> 00:31:12,900
see something called a hash join and

00:31:10,920 --> 00:31:15,990
effectively hash joint is where you take

00:31:12,900 --> 00:31:18,030
one side and you hash it and then you

00:31:15,990 --> 00:31:21,300
join the other side you guys you look

00:31:18,030 --> 00:31:23,190
you look ups from the one table into the

00:31:21,300 --> 00:31:27,120
other table and as you can see here they

00:31:23,190 --> 00:31:29,520
basically used the large table to do the

00:31:27,120 --> 00:31:30,870
lookups and they've hashed the smaller

00:31:29,520 --> 00:31:32,400
table which is something you'll see all

00:31:30,870 --> 00:31:34,440
the time it's it's going to hash the

00:31:32,400 --> 00:31:37,020
smaller one because that's an expensive

00:31:34,440 --> 00:31:39,240
operation and then just do a sequential

00:31:37,020 --> 00:31:41,940
scan across the larger one and and and

00:31:39,240 --> 00:31:44,430
then do this restriction okay you can

00:31:41,940 --> 00:31:45,960
see the restriction right here that's

00:31:44,430 --> 00:31:50,070
what the pseudocode looks like for that

00:31:45,960 --> 00:31:53,070
this is the hashing parked here if you

00:31:50,070 --> 00:31:56,040
do a query with no restriction so we

00:31:53,070 --> 00:31:57,930
haven't restricted either table the

00:31:56,040 --> 00:32:01,080
system kind of thinks a lot of stuff's

00:31:57,930 --> 00:32:04,680
going on it's looking at nine thousand

00:32:01,080 --> 00:32:08,370
rows it guesses here it's guessing 1200

00:32:04,680 --> 00:32:12,720
up here it thinks it's returning 61,000

00:32:08,370 --> 00:32:14,550
again it doesn't know okay and it's

00:32:12,720 --> 00:32:16,170
basically going to sort the two sides

00:32:14,550 --> 00:32:18,270
and then do a merger and this is what it

00:32:16,170 --> 00:32:20,220
looks like effectively you sort the two

00:32:18,270 --> 00:32:23,550
sides and then you basically compare in

00:32:20,220 --> 00:32:25,470
lockstep as you go down so you say okay

00:32:23,550 --> 00:32:30,240
is this match this yes as much this no

00:32:25,470 --> 00:32:32,870
ok can move down match match no match no

00:32:30,240 --> 00:32:36,870
and you basically again are walking down

00:32:32,870 --> 00:32:39,240
through the through the comparison ok

00:32:36,870 --> 00:32:41,760
really good for big tables but again you

00:32:39,240 --> 00:32:44,460
have the overhead of having to sort the

00:32:41,760 --> 00:32:48,540
two sides it's you know it's the best we

00:32:44,460 --> 00:32:50,790
can do and and this is this is not know

00:32:48,540 --> 00:32:54,029
this is postgres specific i believe all

00:32:50,790 --> 00:33:01,729
the enterprise databases have the same

00:32:54,029 --> 00:33:01,729
join types as far as I know no well

00:33:10,099 --> 00:33:17,609
right I was really we're talking about

00:33:14,009 --> 00:33:21,929
oracle and informix ingress you know so

00:33:17,609 --> 00:33:23,969
traditional enterprise ah databases yeah

00:33:21,929 --> 00:33:26,879
so these are these are these are very

00:33:23,969 --> 00:33:30,389
well understood you know concepts of how

00:33:26,879 --> 00:33:31,799
to join stuff together um that's what

00:33:30,389 --> 00:33:35,580
the pseudocode looks like again a little

00:33:31,799 --> 00:33:38,909
more complicated if you do in at if you

00:33:35,580 --> 00:33:41,009
do if you if you do to join a different

00:33:38,909 --> 00:33:43,879
order so you put sample one second and

00:33:41,009 --> 00:33:46,919
sample to first it has no effect on how

00:33:43,879 --> 00:33:49,320
the system works so it's it doesn't it

00:33:46,919 --> 00:33:51,659
isn't what we call rules-based optimizer

00:33:49,320 --> 00:33:54,450
which I believe was the original Oracle

00:33:51,659 --> 00:33:56,729
optimizers rules obeys optimizer it's a

00:33:54,450 --> 00:33:57,989
cost-based optimizer so again it's going

00:33:56,729 --> 00:34:03,089
to it doesn't really care how you

00:33:57,989 --> 00:34:05,339
express it so let's throw some actual

00:34:03,089 --> 00:34:07,529
smarts in there let's actually allow it

00:34:05,339 --> 00:34:09,659
to have statistics on these things and

00:34:07,529 --> 00:34:12,529
we now start to see some radically

00:34:09,659 --> 00:34:15,659
different output so here's our same join

00:34:12,529 --> 00:34:17,750
using with no restrictions this used to

00:34:15,659 --> 00:34:21,179
be a merge joined now it's a hash joint

00:34:17,750 --> 00:34:23,210
okay and it actually knows really well

00:34:21,179 --> 00:34:27,210
how many rows it's going to get right to

00:34:23,210 --> 00:34:30,270
6222 256 it assumes a one-to-one join

00:34:27,210 --> 00:34:32,309
and assumes a 260 are coming out ok so

00:34:30,270 --> 00:34:35,760
again great example add the analyzed

00:34:32,309 --> 00:34:39,690
statistics BAM we get our results really

00:34:35,760 --> 00:34:43,200
quick in a much more efficient manner if

00:34:39,690 --> 00:34:45,149
we do a right outer join this is

00:34:43,200 --> 00:34:48,750
actually kind of a new postgres 91

00:34:45,149 --> 00:34:50,789
feature in the past outer joins we're

00:34:48,750 --> 00:34:53,700
not certain types of joins were not

00:34:50,789 --> 00:34:57,869
possible when you did an outer join or a

00:34:53,700 --> 00:35:00,960
full join for example in this case we

00:34:57,869 --> 00:35:03,210
actually have a way of doing a hash join

00:35:00,960 --> 00:35:05,880
even with an outer join which was kind

00:35:03,210 --> 00:35:06,920
of a radical thing because as you can

00:35:05,880 --> 00:35:09,049
imagine it's kind of hard

00:35:06,920 --> 00:35:11,089
do that because you're you've got a hash

00:35:09,049 --> 00:35:14,270
and you're not seeing all the rows in

00:35:11,089 --> 00:35:16,730
the same way so effectively as you can

00:35:14,270 --> 00:35:19,849
see it's doing a hash joint sequential

00:35:16,730 --> 00:35:23,599
scan on table 2 and then it's basically

00:35:19,849 --> 00:35:25,299
joining it into the hash of table 1 okay

00:35:23,599 --> 00:35:29,740
and I believe it had to do it that way

00:35:25,299 --> 00:35:29,740
based on the order we did the outers

00:35:34,089 --> 00:35:38,920
yeah so the question is anything older

00:35:36,319 --> 00:35:41,599
that would be a significantly slower yes

00:35:38,920 --> 00:35:42,829
hash room would not be available to an

00:35:41,599 --> 00:35:45,470
earlier version of post Krista would

00:35:42,829 --> 00:35:49,280
probably would do a merge join in my

00:35:45,470 --> 00:35:54,349
guess nested loop is going to be really

00:35:49,280 --> 00:35:55,910
expensive here because the it's going to

00:35:54,349 --> 00:35:59,150
compare every row to every rather row so

00:35:55,910 --> 00:36:01,369
you just have to multiply 2 60 x 22 56

00:35:59,150 --> 00:36:03,890
and you're like that's getting pretty

00:36:01,369 --> 00:36:07,640
big right it's you're looking at 500,000

00:36:03,890 --> 00:36:11,299
comparisons it would not I can't do and

00:36:07,640 --> 00:36:13,190
it can't do a nested loop with an index

00:36:11,299 --> 00:36:15,589
scan because we haven't created an index

00:36:13,190 --> 00:36:17,210
yet so again there wouldn't be any way

00:36:15,589 --> 00:36:19,790
for it to take that as an option so it

00:36:17,210 --> 00:36:21,170
would have to be a merge joined and we

00:36:19,790 --> 00:36:24,049
were pretty excited about this because

00:36:21,170 --> 00:36:26,210
again you know as I said earlier

00:36:24,049 --> 00:36:29,619
postgres optimized when we originally

00:36:26,210 --> 00:36:31,730
started wasn't that good right and

00:36:29,619 --> 00:36:33,980
because we've been able to track some

00:36:31,730 --> 00:36:38,030
really smart people and we've been able

00:36:33,980 --> 00:36:40,970
to work in a really close way with our

00:36:38,030 --> 00:36:42,500
users so when a user reports a problem

00:36:40,970 --> 00:36:44,990
or a query that isn't running as well as

00:36:42,500 --> 00:36:47,089
they like we work with them directly

00:36:44,990 --> 00:36:49,460
versus the way a company would have to

00:36:47,089 --> 00:36:51,589
do it going through you know levels of

00:36:49,460 --> 00:36:52,849
support and as a whole you know and then

00:36:51,589 --> 00:36:55,430
even if you fix it you have to go

00:36:52,849 --> 00:36:58,369
through a whole QA to do the whole you

00:36:55,430 --> 00:37:00,049
know round circuit it just it's very

00:36:58,369 --> 00:37:02,690
hard for commercial vendors to improve

00:37:00,049 --> 00:37:04,339
these really complex cases we're

00:37:02,690 --> 00:37:07,520
actually gotten really good at it so

00:37:04,339 --> 00:37:09,470
this has come out of as many other

00:37:07,520 --> 00:37:11,510
optimizer improvements which we get in

00:37:09,470 --> 00:37:14,359
every every major release has optimized

00:37:11,510 --> 00:37:16,819
improvements this actually came out of

00:37:14,359 --> 00:37:18,829
some work where some people were

00:37:16,819 --> 00:37:20,300
complaining about the speed of some

00:37:18,829 --> 00:37:22,610
queries that they felt should

00:37:20,300 --> 00:37:24,620
faster and often they were comparisons

00:37:22,610 --> 00:37:26,780
with other enterprise databases that

00:37:24,620 --> 00:37:28,880
could generate them fast during and it

00:37:26,780 --> 00:37:32,090
was pretty clear to us by looking at our

00:37:28,880 --> 00:37:35,060
plan that oh we're doing a merge-join

00:37:32,090 --> 00:37:36,830
here oh we really should couldn't we you

00:37:35,060 --> 00:37:38,990
know and then we we kind of get on their

00:37:36,830 --> 00:37:40,700
to-do list and then we see two or three

00:37:38,990 --> 00:37:42,410
cases of that and then we roll up our

00:37:40,700 --> 00:37:44,480
sleeves or like wow we're going to make

00:37:42,410 --> 00:37:46,430
it happen you know i think this is

00:37:44,480 --> 00:37:49,730
robert house and tom lane who worked on

00:37:46,430 --> 00:37:52,790
this one primarily but again it's you

00:37:49,730 --> 00:37:53,990
get major stuff in every release and you

00:37:52,790 --> 00:37:56,630
don't even see it a lot of times because

00:37:53,990 --> 00:37:59,300
a lot of this stuff is so internal to

00:37:56,630 --> 00:38:00,530
postgres that you know you don't it's

00:37:59,300 --> 00:38:02,780
not worth trying to explain in the

00:38:00,530 --> 00:38:05,450
release notes because how many people

00:38:02,780 --> 00:38:07,520
really can understand it you know we

00:38:05,450 --> 00:38:11,740
have we understand that we know you're

00:38:07,520 --> 00:38:11,740
going to get better you know plans but

00:38:13,000 --> 00:38:18,440
it's it's really not a user visible

00:38:16,160 --> 00:38:20,030
change you know it's just like wow

00:38:18,440 --> 00:38:29,960
postcards got faster with me you know

00:38:20,030 --> 00:38:32,000
and yeah i got this yet right right so

00:38:29,960 --> 00:38:35,080
we do have cases where we will make a

00:38:32,000 --> 00:38:37,700
change like this will go into beta a

00:38:35,080 --> 00:38:40,010
wall you know will go down that road and

00:38:37,700 --> 00:38:41,690
they'll be like okay you know beta

00:38:40,010 --> 00:38:43,490
testers are telling us now this is

00:38:41,690 --> 00:38:45,860
slower than it was the previous release

00:38:43,490 --> 00:38:47,540
and then we you know we can get that and

00:38:45,860 --> 00:38:53,650
usually where it's always fixed pretty

00:38:47,540 --> 00:38:53,650
much by the time right where we had

00:39:06,130 --> 00:39:09,130
right

00:39:12,250 --> 00:39:26,380
Oh so what do we do okay yeah and again

00:39:24,430 --> 00:39:28,930
these users have a tendency to keep

00:39:26,380 --> 00:39:32,830
reappearing so they eventually get what

00:39:28,930 --> 00:39:34,300
they want so we'll figure out a way and

00:39:32,830 --> 00:39:38,170
you're right after a while you do see

00:39:34,300 --> 00:39:39,820
patterns so you're basically it's kind

00:39:38,170 --> 00:39:41,830
of like you know you've got the Holy

00:39:39,820 --> 00:39:43,270
Grail over there you know and you're

00:39:41,830 --> 00:39:45,040
basically like walking in that direction

00:39:43,270 --> 00:39:46,660
then somebody kind of hits you in the

00:39:45,040 --> 00:39:48,190
head oh I better guy went too far that

00:39:46,660 --> 00:39:50,550
you know you're you're basically doing

00:39:48,190 --> 00:39:52,900
this sort of drunk and walk to get there

00:39:50,550 --> 00:39:54,550
and we're never going to get there but

00:39:52,900 --> 00:39:58,210
we do have people continually hitting us

00:39:54,550 --> 00:39:59,740
on the head so if we get too far off one

00:39:58,210 --> 00:40:01,630
direction you know we get a good shot

00:39:59,740 --> 00:40:03,910
and then we're like okay so we're

00:40:01,630 --> 00:40:07,390
getting much you know again I think I

00:40:03,910 --> 00:40:10,240
think we're I think we're definitely on

00:40:07,390 --> 00:40:12,850
par with the enterprise optimizers that

00:40:10,240 --> 00:40:15,030
are out there now if not better in some

00:40:12,850 --> 00:40:18,000
cases and probably not as good in others

00:40:15,030 --> 00:40:20,590
again that wasn't always the case but

00:40:18,000 --> 00:40:22,740
you know we're definitely respectable

00:40:20,590 --> 00:40:27,760
and we see fewer and fewer complaints

00:40:22,740 --> 00:40:30,670
from from comparisons to other databases

00:40:27,760 --> 00:40:34,420
where were dramatically slower we're now

00:40:30,670 --> 00:40:35,680
seeing kind of cases where where it's

00:40:34,420 --> 00:40:36,850
not so much a comparison against

00:40:35,680 --> 00:40:38,770
somebody else because they've kind of

00:40:36,850 --> 00:40:40,720
given up on that other thing whatever

00:40:38,770 --> 00:40:42,340
that was and it's basically like you

00:40:40,720 --> 00:40:44,560
know this queer is really fast but this

00:40:42,340 --> 00:40:46,540
other query where you you know when i

00:40:44,560 --> 00:40:47,800
change this little thing become slower

00:40:46,540 --> 00:40:50,530
so we're now competing against ourselves

00:40:47,800 --> 00:40:51,730
in some ways as wrong as josh was saying

00:40:50,530 --> 00:40:53,680
where we had this thing made it real

00:40:51,730 --> 00:40:55,750
fast but then there's this the thing

00:40:53,680 --> 00:40:57,400
that made it slow and probably over time

00:40:55,750 --> 00:40:59,020
the way we'll fix this is to create a

00:40:57,400 --> 00:41:00,700
separate node type and restructure what

00:40:59,020 --> 00:41:02,260
we're doing and so for sometimes we

00:41:00,700 --> 00:41:03,700
can't do that when we're in data as well

00:41:02,260 --> 00:41:05,680
as we could when we're developing so

00:41:03,700 --> 00:41:09,720
what kind of okay we'll come back to it

00:41:05,680 --> 00:41:09,720
and the guys that work on our optimizer

00:41:10,680 --> 00:41:16,930
you know a really cutting edge in terms

00:41:13,870 --> 00:41:20,200
of what they can do so and the really

00:41:16,930 --> 00:41:23,020
responsive tease or so it would seem

00:41:20,200 --> 00:41:25,540
like we never get there but we actually

00:41:23,020 --> 00:41:28,600
no we actually have gone really fun yeah

00:41:25,540 --> 00:41:32,250
we've actually come really far and you

00:41:28,600 --> 00:41:32,250
can see in this Lodge is pretty amazing

00:41:47,549 --> 00:42:04,269
yeah yeah you're stuck there yeah in

00:42:02,859 --> 00:42:06,609
fact you know one of the things that

00:42:04,269 --> 00:42:08,920
I've always been really cautious about

00:42:06,609 --> 00:42:14,140
as a developer and having seen other

00:42:08,920 --> 00:42:16,420
databases do this is databases have a

00:42:14,140 --> 00:42:19,299
tendency particularly the commercial

00:42:16,420 --> 00:42:22,029
ones have a tendency to get into the you

00:42:19,299 --> 00:42:23,529
know fix one thing break another fix one

00:42:22,029 --> 00:42:27,400
thing break another kind of release

00:42:23,529 --> 00:42:29,650
cycle I've also seen them do the this is

00:42:27,400 --> 00:42:31,240
faster now this is slower now this is

00:42:29,650 --> 00:42:35,049
faster now this is slower now kind of

00:42:31,240 --> 00:42:36,880
release cycle we've always been kind of

00:42:35,049 --> 00:42:39,789
Pat well I personally have always been

00:42:36,880 --> 00:42:42,849
paranoid about that and the good news is

00:42:39,789 --> 00:42:44,079
that I guess you know now you know 16

00:42:42,849 --> 00:42:46,150
years into it I guess I shouldn't be

00:42:44,079 --> 00:42:48,279
worried anymore but we've managed to

00:42:46,150 --> 00:42:52,420
really never do that that I can remember

00:42:48,279 --> 00:42:54,279
at least in recent memory where the only

00:42:52,420 --> 00:42:56,980
case I can remember where we actually

00:42:54,279 --> 00:42:58,569
took some a little slower was in 83

00:42:56,980 --> 00:43:01,930
where we increase the number of

00:42:58,569 --> 00:43:06,579
statistics targets from 10 to 100 now

00:43:01,930 --> 00:43:09,609
1010 analyzed buckets and ten distinct

00:43:06,579 --> 00:43:13,170
buckets of statistics for the optimizer

00:43:09,609 --> 00:43:15,130
was way too small but a hundred is

00:43:13,170 --> 00:43:16,599
probably where it needs to be but there

00:43:15,130 --> 00:43:18,609
were some very simple queries that

00:43:16,599 --> 00:43:20,980
looking up those statistics became a

00:43:18,609 --> 00:43:23,380
little slower than it used to be and we

00:43:20,980 --> 00:43:24,940
did hear about it you know we don't hear

00:43:23,380 --> 00:43:26,739
about it as much now because again all

00:43:24,940 --> 00:43:28,989
of the complex queries tremendously

00:43:26,739 --> 00:43:30,160
benefited from from that but that was it

00:43:28,989 --> 00:43:32,499
that was one of the few cases where

00:43:30,160 --> 00:43:35,559
we've really had you know where we

00:43:32,499 --> 00:43:37,630
really had to take a hit on some classic

00:43:35,559 --> 00:43:41,079
queries to make what we consider the

00:43:37,630 --> 00:43:43,989
majority queries definitely faster we

00:43:41,079 --> 00:43:45,759
did leave that at 100 now users can

00:43:43,989 --> 00:43:48,249
change those numbers for particular

00:43:45,759 --> 00:43:50,670
tables if they want to but that was

00:43:48,249 --> 00:43:52,710
again that was an 83 so that was I guess

00:43:50,670 --> 00:43:59,070
four years ago three

00:43:52,710 --> 00:44:00,570
years ago and uh it was one of the few

00:43:59,070 --> 00:44:03,210
cases where we had to do we had to do a

00:44:00,570 --> 00:44:05,280
trade off in almost every other case we

00:44:03,210 --> 00:44:06,630
finally we managed to figure out how to

00:44:05,280 --> 00:44:08,490
get a win across the board without

00:44:06,630 --> 00:44:10,470
affecting everyone else although again

00:44:08,490 --> 00:44:11,940
Josh had that other case where where we

00:44:10,470 --> 00:44:13,890
had a king so we're actually really

00:44:11,940 --> 00:44:16,020
cautious about that I don't think the

00:44:13,890 --> 00:44:18,270
commercial databases do that at all well

00:44:16,020 --> 00:44:20,070
I think primarily because of the lack of

00:44:18,270 --> 00:44:21,540
communication between and lack of

00:44:20,070 --> 00:44:23,130
feedback it's not so much the

00:44:21,540 --> 00:44:26,450
communication with the lack of feedback

00:44:23,130 --> 00:44:26,450
to the developers and what they're doing

00:44:28,369 --> 00:44:35,280
that's right way before they make it

00:44:31,349 --> 00:44:36,900
into an official release um you know the

00:44:35,280 --> 00:44:40,260
classic you know the classic ace from my

00:44:36,900 --> 00:44:42,869
history was in formics 5 that went to

00:44:40,260 --> 00:44:45,510
formic six informix 6 was an aborted

00:44:42,869 --> 00:44:47,970
release everyone went back to five when

00:44:45,510 --> 00:44:49,980
they went to seven it took about two

00:44:47,970 --> 00:44:54,240
years for informix to shake out the bugs

00:44:49,980 --> 00:44:57,599
in that and by that point I think people

00:44:54,240 --> 00:44:59,400
had become so and lost so much trust in

00:44:57,599 --> 00:45:00,660
what informix was doing that they really

00:44:59,400 --> 00:45:01,710
started to look at other options that I

00:45:00,660 --> 00:45:03,210
think it hurt the company tremendously

00:45:01,710 --> 00:45:05,280
now of course there were other problems

00:45:03,210 --> 00:45:06,930
with the company there was a counting

00:45:05,280 --> 00:45:08,210
problem and you know there were some

00:45:06,930 --> 00:45:11,580
business problems as well but

00:45:08,210 --> 00:45:12,869
engineering-wise and that's just obvious

00:45:11,580 --> 00:45:14,940
ly an example that I think repeats

00:45:12,869 --> 00:45:16,560
across the industry the commercial

00:45:14,940 --> 00:45:19,280
industry of the at least where where

00:45:16,560 --> 00:45:22,020
it's just really hard for engineers to

00:45:19,280 --> 00:45:24,089
to do the type of sort of cutting-edge

00:45:22,020 --> 00:45:25,710
stuff that they like to do and it's

00:45:24,089 --> 00:45:28,470
always a risk forward thing where it's

00:45:25,710 --> 00:45:30,660
for us it's like there's not a whole lot

00:45:28,470 --> 00:45:32,760
of risk because we got four or five six

00:45:30,660 --> 00:45:35,250
months of beta this gives go for the

00:45:32,760 --> 00:45:37,859
reward you know and and we're very

00:45:35,250 --> 00:45:39,780
nimble at doing stuff whereas the

00:45:37,859 --> 00:45:43,230
commercial companies were very onion oh

00:45:39,780 --> 00:45:45,450
very rigid and that really works against

00:45:43,230 --> 00:45:46,920
it has some advantages I'm sure but but

00:45:45,450 --> 00:45:50,660
it really works against them i think in

00:45:46,920 --> 00:45:50,660
trying to do good engineering

00:45:53,260 --> 00:45:57,950
yeah it's it's it's really a different

00:45:56,510 --> 00:46:00,830
it's really an engineer's driven

00:45:57,950 --> 00:46:02,390
development and and I think that's you

00:46:00,830 --> 00:46:04,880
know if part of the reason Linux was

00:46:02,390 --> 00:46:06,800
succeeded and a lot of the other stuff

00:46:04,880 --> 00:46:09,050
you know I mean you know the classic

00:46:06,800 --> 00:46:10,910
case to me is is we've got postgres

00:46:09,050 --> 00:46:13,760
we've got people coming from other

00:46:10,910 --> 00:46:16,310
databases you know on a daily basis and

00:46:13,760 --> 00:46:17,510
regular basis leaving leaving software

00:46:16,310 --> 00:46:19,310
even if it's free for that they're

00:46:17,510 --> 00:46:20,600
leaving from first grass because they

00:46:19,310 --> 00:46:22,400
find they're more effective they're

00:46:20,600 --> 00:46:24,920
post-crisis easier to administer it's

00:46:22,400 --> 00:46:26,840
more reliable and more robust turquoise

00:46:24,920 --> 00:46:28,670
less administration you know but again

00:46:26,840 --> 00:46:31,040
the cut the software that they're

00:46:28,670 --> 00:46:33,530
leaving has been developed by you know

00:46:31,040 --> 00:46:35,930
billion dollar companies with hundreds

00:46:33,530 --> 00:46:38,150
of thousands of people all behind that

00:46:35,930 --> 00:46:40,760
software and you know what are we that

00:46:38,150 --> 00:46:44,090
that that were somehow attracting these

00:46:40,760 --> 00:46:47,060
people you know and it's really just I

00:46:44,090 --> 00:46:49,490
think the it's sort of the end it's it's

00:46:47,060 --> 00:46:51,350
sort of like even though these companies

00:46:49,490 --> 00:46:54,320
are so large there is such an impedance

00:46:51,350 --> 00:46:57,080
myths mismatch between the engineering

00:46:54,320 --> 00:46:59,210
or trying to do and the actual result

00:46:57,080 --> 00:47:01,130
that comes out that even the billion

00:46:59,210 --> 00:47:03,530
dollars doesn't save them you know I

00:47:01,130 --> 00:47:07,130
mean classic case would be you know how

00:47:03,530 --> 00:47:10,730
does linux you know really is a ragtag

00:47:07,130 --> 00:47:15,920
group you know basically take on solaris

00:47:10,730 --> 00:47:18,170
AIX hp-ux you know sco all these really

00:47:15,920 --> 00:47:19,910
big players from the 90s and effectively

00:47:18,170 --> 00:47:23,420
just you know they pretty much end up

00:47:19,910 --> 00:47:24,680
you know just shadows of themselves you

00:47:23,420 --> 00:47:28,100
would think it would that was impossible

00:47:24,680 --> 00:47:30,770
as well so you know it's it's sort of

00:47:28,100 --> 00:47:32,810
your common sense says that this can't

00:47:30,770 --> 00:47:36,220
work but you're on your engineering says

00:47:32,810 --> 00:47:39,020
what it does so let's just keep doing it

00:47:36,220 --> 00:47:41,570
yeah eventually yeah eventually you get

00:47:39,020 --> 00:47:45,670
to Anu Anu common sense but it's still

00:47:41,570 --> 00:47:48,200
it still seems a little surprising and

00:47:45,670 --> 00:47:50,900
so anyway that's my that's my kind of

00:47:48,200 --> 00:47:52,400
soap box example of some of the stuff

00:47:50,900 --> 00:47:54,170
that's going on here and it's sort of

00:47:52,400 --> 00:47:56,660
some background in how this process

00:47:54,170 --> 00:48:00,530
works and how you get those kind of new

00:47:56,660 --> 00:48:02,300
features in Postgres

00:48:00,530 --> 00:48:04,160
if we take if we do something called

00:48:02,300 --> 00:48:06,800
cross joint I bet you've never done this

00:48:04,160 --> 00:48:08,900
before it's basically a joint everything

00:48:06,800 --> 00:48:10,900
it's a cartesian product right so that's

00:48:08,900 --> 00:48:19,450
always going to be nested loop because

00:48:10,900 --> 00:48:19,450
right yes right so yes

00:48:22,580 --> 00:48:28,160
okay okay so all right so this is an s

00:48:26,690 --> 00:48:30,410
this is a cross joint again join

00:48:28,160 --> 00:48:33,020
everything everything else if we add

00:48:30,410 --> 00:48:34,370
indexes to this so now we have some

00:48:33,020 --> 00:48:37,730
additional options because we have an

00:48:34,370 --> 00:48:40,700
index here we now for this particular

00:48:37,730 --> 00:48:46,640
query are able to do a nested loop with

00:48:40,700 --> 00:48:48,050
index can because again yes no you do

00:48:46,640 --> 00:48:49,400
not need to analyze so the questions you

00:48:48,050 --> 00:48:52,640
need to analyze the after the index know

00:48:49,400 --> 00:48:55,330
the analyze is done the exact same way

00:48:52,640 --> 00:48:58,400
where the index exists or not good point

00:48:55,330 --> 00:48:59,660
so basically be nested loop with an

00:48:58,400 --> 00:49:04,880
index scan which again was not possible

00:48:59,660 --> 00:49:07,700
before this is what that index loop

00:49:04,880 --> 00:49:12,020
looks like that's the that's the

00:49:07,700 --> 00:49:15,560
pseudocode for that if we do a join on

00:49:12,020 --> 00:49:17,990
the junk-filled it actually knows that

00:49:15,560 --> 00:49:21,530
the junk field has x is in it and not

00:49:17,990 --> 00:49:23,870
ace so when I look at all my a's I'm

00:49:21,530 --> 00:49:25,610
leading okay how you know and it just

00:49:23,870 --> 00:49:27,290
does it's like well i think i'm going to

00:49:25,610 --> 00:49:28,400
get one row i'm going to give you the

00:49:27,290 --> 00:49:29,570
benefit of the doubt I don't think

00:49:28,400 --> 00:49:30,980
there's anything there but i'm going to

00:49:29,570 --> 00:49:32,180
assume there's one row and i'm just

00:49:30,980 --> 00:49:35,960
going to do a nested loop because that's

00:49:32,180 --> 00:49:37,490
the fastest thing i can do okay but it

00:49:35,960 --> 00:49:41,750
knows there's not much going on here

00:49:37,490 --> 00:49:44,330
okay if i look for actual X's then I

00:49:41,750 --> 00:49:46,340
start to see some heavy lifting it's now

00:49:44,330 --> 00:49:47,930
going to do a hash join it's going to

00:49:46,340 --> 00:49:50,780
hatch the one side because it knows

00:49:47,930 --> 00:49:52,070
we're in for some serious work and it

00:49:50,780 --> 00:49:59,080
knows that these tables are going to

00:49:52,070 --> 00:49:59,080
return a lot of rose okay

00:50:18,410 --> 00:50:21,010
ok

00:50:25,310 --> 00:50:29,500
no it's always known about those oh yeah

00:50:42,760 --> 00:50:47,740
yeah query hands

00:51:13,780 --> 00:51:16,780
right

00:51:29,350 --> 00:51:36,530
um so what if we use i'm going to show

00:51:35,180 --> 00:51:39,710
you one last thing here and that's the

00:51:36,530 --> 00:51:42,230
limit clause this is this is a query

00:51:39,710 --> 00:51:44,330
that just joining the whole whole set

00:51:42,230 --> 00:51:46,130
basically with no restriction and you

00:51:44,330 --> 00:51:50,120
can see that it actually does generate a

00:51:46,130 --> 00:51:52,550
hash join but if you add a limit clause

00:51:50,120 --> 00:51:55,520
to the same query you notice that it

00:51:52,550 --> 00:51:58,640
changes from hash join actually to a

00:51:55,520 --> 00:52:01,940
nested loop and the reason it does that

00:51:58,640 --> 00:52:03,110
is because the limit Klaus knows that

00:52:01,940 --> 00:52:05,990
we're only going to be returning a

00:52:03,110 --> 00:52:08,150
subset of the rose so if it can get at

00:52:05,990 --> 00:52:12,320
those rows quicker if you can get to a

00:52:08,150 --> 00:52:13,790
set that subset quicker it will do it so

00:52:12,320 --> 00:52:17,210
what it's effectively doing is it's

00:52:13,790 --> 00:52:20,150
doing an index scan again allowing me to

00:52:17,210 --> 00:52:22,640
pull off the first couple rows from that

00:52:20,150 --> 00:52:24,500
particular table here it's going to it's

00:52:22,640 --> 00:52:26,180
going to sample too so it's it's

00:52:24,500 --> 00:52:31,520
basically going to do an index skin a

00:52:26,180 --> 00:52:34,870
sample to pull off one row ok and then

00:52:31,520 --> 00:52:37,160
return it real quick right and

00:52:34,870 --> 00:52:40,520
effectively here's here's how it's going

00:52:37,160 --> 00:52:42,440
to do it so so it's kind of give you an

00:52:40,520 --> 00:52:44,270
idea of how the system kind of knows

00:52:42,440 --> 00:52:46,640
when you do limit now I'm doing limit

00:52:44,270 --> 00:52:48,950
one year even if I do a limit 10 it's

00:52:46,640 --> 00:52:50,330
still doing a nested loop ok because

00:52:48,950 --> 00:52:53,000
again it knows it's not going to run

00:52:50,330 --> 00:52:55,970
through the whole result set if we go to

00:52:53,000 --> 00:52:59,660
a limit 100 now we're starting to get

00:52:55,970 --> 00:53:02,660
more data here and we actually start to

00:52:59,660 --> 00:53:04,280
do a hash joint ok so we're like ok now

00:53:02,660 --> 00:53:05,810
we're going to be going through a

00:53:04,280 --> 00:53:10,100
significant amount of data and we have

00:53:05,810 --> 00:53:12,680
to start doing that so that is actually

00:53:10,100 --> 00:53:15,080
all I had again we had some good

00:53:12,680 --> 00:53:18,770
questions I appreciate that as you can

00:53:15,080 --> 00:53:20,360
see the system is pretty complicated but

00:53:18,770 --> 00:53:22,280
i think this presentation does

00:53:20,360 --> 00:53:24,260
illustrate kind of what's going on in

00:53:22,280 --> 00:53:26,870
there and how that optimizer is helping

00:53:24,260 --> 00:53:29,360
you so you can just basically throw the

00:53:26,870 --> 00:53:31,400
query at their other at the at post

00:53:29,360 --> 00:53:32,150
grass and postgres is doing a lot of

00:53:31,400 --> 00:53:33,230
this back

00:53:32,150 --> 00:53:36,890
stuff that would be virtually impossible

00:53:33,230 --> 00:53:40,359
for you to do in application and getting

00:53:36,890 --> 00:53:40,359
you that data as quickly as they can

00:53:40,779 --> 00:53:45,260
exactly one of the great exam antigen

00:53:43,400 --> 00:53:47,720
using sequel in the first place is

00:53:45,260 --> 00:53:49,220
having that optimizer there so that you

00:53:47,720 --> 00:53:50,690
don't have to do a lot of that planning

00:53:49,220 --> 00:53:53,589
in your application which is what i used

00:53:50,690 --> 00:53:58,210
to have to do before SQ all the course

00:53:53,589 --> 00:53:58,210
great well thank you

00:54:11,060 --> 00:54:19,140
okay that is not so the question is do

00:54:17,490 --> 00:54:21,300
we have the ability to freeze statistics

00:54:19,140 --> 00:54:23,850
so they don't change that actually is

00:54:21,300 --> 00:54:27,780
not we feel that the freezing statistics

00:54:23,850 --> 00:54:30,090
would act freezing of statistics in most

00:54:27,780 --> 00:54:32,280
cases would obviously work against the

00:54:30,090 --> 00:54:35,100
user because of course it would change

00:54:32,280 --> 00:54:39,390
it would not allow us to adapt as the

00:54:35,100 --> 00:54:41,040
data changed we have had some requests

00:54:39,390 --> 00:54:43,530
from a small minority of users who are

00:54:41,040 --> 00:54:51,000
basically saying don't change the plan I

00:54:43,530 --> 00:54:54,350
don't care what happens and we right so

00:54:51,000 --> 00:55:03,690
we've kind of we're actually trying to

00:54:54,350 --> 00:55:08,100
go re right unless you use prepared

00:55:03,690 --> 00:55:10,430
statements right so it would be long

00:55:08,100 --> 00:55:10,430
term

00:55:18,170 --> 00:55:21,170
right

00:56:36,920 --> 00:57:14,130
that's the examples right here that's

00:56:40,380 --> 00:57:16,080
all we got yeah from from from the

00:57:14,130 --> 00:57:20,160
10,000 foot view we understand what

00:57:16,080 --> 00:57:22,200
users are trying to achieve right the

00:57:20,160 --> 00:57:24,360
real thing we haven't figured out or

00:57:22,200 --> 00:57:26,850
we're still work we're still trying to

00:57:24,360 --> 00:57:28,200
triangulate on is exactly how to give

00:57:26,850 --> 00:57:30,240
that to them in the best way possible

00:57:28,200 --> 00:57:33,150
because we're having a lot of people

00:57:30,240 --> 00:57:36,570
coming from other systems saying I need

00:57:33,150 --> 00:57:38,640
to achieve plan stability so give me

00:57:36,570 --> 00:57:41,190
hints I need to plan chief plan

00:57:38,640 --> 00:57:43,470
stability so freeze my stats I need to

00:57:41,190 --> 00:57:45,510
change foot so so the problem is that

00:57:43,470 --> 00:57:47,880
when we look at these other solutions

00:57:45,510 --> 00:57:49,290
that people have come to the solutions

00:57:47,880 --> 00:57:52,140
to a particular problem which is

00:57:49,290 --> 00:57:54,510
planning stability we're not really

00:57:52,140 --> 00:57:56,190
happy engineering-wise with some of

00:57:54,510 --> 00:57:57,810
these solutions because we feel that

00:57:56,190 --> 00:57:59,960
there's a lot of downside that can come

00:57:57,810 --> 00:57:59,960
with

00:58:02,620 --> 00:58:07,700
when we created asterisk over a decade

00:58:05,330 --> 00:58:09,650
ago we could not have imagined that

00:58:07,700 --> 00:58:11,840
asterisk would not only become the most

00:58:09,650 --> 00:58:14,000
widely adopted open source communication

00:58:11,840 --> 00:58:16,040
software on the planet but that it would

00:58:14,000 --> 00:58:18,560
impact the entire industry in the way

00:58:16,040 --> 00:58:20,510
that it has today asterisk has found its

00:58:18,560 --> 00:58:23,150
way into more than 170 countries and

00:58:20,510 --> 00:58:25,130
virtually every fortune 1000 company the

00:58:23,150 --> 00:58:27,230
success of asterisk has enabled a

00:58:25,130 --> 00:58:28,610
transition of power from the hands of

00:58:27,230 --> 00:58:30,890
the traditional proprietary phone

00:58:28,610 --> 00:58:33,290
vendors into the hands of the users and

00:58:30,890 --> 00:58:35,210
administrators of phone systems using

00:58:33,290 --> 00:58:36,440
this power our customers have created

00:58:35,210 --> 00:58:38,390
all sorts of business changing

00:58:36,440 --> 00:58:40,250
applications from small office phone

00:58:38,390 --> 00:58:42,740
systems to mission-critical call centres

00:58:40,250 --> 00:58:44,360
the international carrier networks in

00:58:42,740 --> 00:58:46,160
fact there's even an entire country

00:58:44,360 --> 00:58:48,530
those communications infrastructure runs

00:58:46,160 --> 00:58:50,660
on Astra's the gym has always been about

00:58:48,530 --> 00:58:52,370
creating technology that expands

00:58:50,660 --> 00:58:54,560
communications capabilities in ways that

00:58:52,370 --> 00:58:55,760
we could never have imagined and that's

00:58:54,560 --> 00:58:58,490
part of what's game-changing about

00:58:55,760 --> 00:59:00,830
Digium today we're doing it again this

00:58:58,490 --> 00:59:02,930
time by introducing a new family of HD

00:59:00,830 --> 00:59:05,060
IP phones that extends control of the

00:59:02,930 --> 00:59:06,800
user all the way to the desktop the

00:59:05,060 --> 00:59:08,510
launch of these new products represents

00:59:06,800 --> 00:59:10,610
the next phase indigenous history of

00:59:08,510 --> 00:59:13,010
innovation these are the first and only

00:59:10,610 --> 00:59:14,360
IP phones designed to fully leverage the

00:59:13,010 --> 00:59:16,010
power of esther's when we first

00:59:14,360 --> 00:59:17,270
discussed our expectations for building

00:59:16,010 --> 00:59:19,160
a family of phones for use with

00:59:17,270 --> 00:59:21,380
asterisks our requirements were pretty

00:59:19,160 --> 00:59:22,730
simple we asked the team to build the

00:59:21,380 --> 00:59:25,040
phones such that they were easy to

00:59:22,730 --> 00:59:27,290
install integrate provision and use I

00:59:25,040 --> 00:59:29,300
think you'll soon agree our engineers

00:59:27,290 --> 00:59:31,100
have delivered on that goal user

00:59:29,300 --> 00:59:32,720
feedback is validating that when it

00:59:31,100 --> 00:59:35,150
comes to operation with astro space

00:59:32,720 --> 00:59:37,100
systems including our own Switchvox

00:59:35,150 --> 00:59:39,770
based product these are the easiest to

00:59:37,100 --> 00:59:41,750
use best integrated most interoperable

00:59:39,770 --> 00:59:43,490
products on the market today the

00:59:41,750 --> 00:59:46,070
digitally of phones will initially

00:59:43,490 --> 00:59:47,900
include three IP desk phones uniquely

00:59:46,070 --> 00:59:50,120
designed to complement any asterisk or

00:59:47,900 --> 00:59:51,400
Switchvox based solution these phones

00:59:50,120 --> 00:59:54,470
are different for a number of reasons

00:59:51,400 --> 00:59:56,750
first there is clue sively designed for

00:59:54,470 --> 00:59:58,490
use with asterisks secondly we've made

00:59:56,750 --> 01:00:00,950
it really easy to autodiscover and

00:59:58,490 --> 01:00:02,060
provision the phones next we've made it

01:00:00,950 --> 01:00:04,580
easy for the phones to access

01:00:02,060 --> 01:00:05,329
information inside of asterisks allowing

01:00:04,580 --> 01:00:07,329
tight coupling

01:00:05,329 --> 01:00:09,289
between an application and the phone

01:00:07,329 --> 01:00:11,479
additionally we've created an

01:00:09,289 --> 01:00:13,579
applications engine that allows users

01:00:11,479 --> 01:00:16,190
and developers to create and run their

01:00:13,579 --> 01:00:18,259
own apps on the following and finally

01:00:16,190 --> 01:00:20,329
we've done all of this at a very

01:00:18,259 --> 01:00:22,009
compelling price point at digium we're

01:00:20,329 --> 01:00:23,779
always thinking of ways to give our

01:00:22,009 --> 01:00:26,150
customers the best value in business

01:00:23,779 --> 01:00:28,069
phone systems and also give them the

01:00:26,150 --> 01:00:30,170
power to create their own solutions or

01:00:28,069 --> 01:00:31,969
any communications challenge well

01:00:30,170 --> 01:00:33,739
continue to push the boundaries not only

01:00:31,969 --> 01:00:35,809
to make Astra's cooler faster and more

01:00:33,739 --> 01:00:37,549
technologically feature-rich but to make

01:00:35,809 --> 01:00:40,099
asterisk and communications even easier

01:00:37,549 --> 01:00:43,599
and together we'll change the way the

01:00:40,099 --> 01:00:43,599
world communicates again

01:01:24,680 --> 01:01:31,500
how's that sigh every way this is the

01:01:28,200 --> 01:01:33,660
way to better utilize all your resources

01:01:31,500 --> 01:01:37,110
and it makes managing all your resources

01:01:33,660 --> 01:01:40,940
pretty easy all of the innovation is

01:01:37,110 --> 01:01:44,430
happening in open source the

01:01:40,940 --> 01:01:46,260
collaborative nature and of the you know

01:01:44,430 --> 01:01:48,180
of the community and the speed at which

01:01:46,260 --> 01:01:50,370
these are these you know these

01:01:48,180 --> 01:01:52,680
deficiencies these bugs are getting

01:01:50,370 --> 01:01:55,290
discovered and then fixed is it like

01:01:52,680 --> 01:01:57,990
that really shows the power of the you

01:01:55,290 --> 01:01:59,610
know of the open source community it is

01:01:57,990 --> 01:02:03,810
global and it's definitely because of

01:01:59,610 --> 01:02:10,140
the users community people are extremely

01:02:03,810 --> 01:02:12,030
friendly and always ready to help if you

01:02:10,140 --> 01:02:14,340
go on tire see any day you'll see these

01:02:12,030 --> 01:02:16,070
guys helping each other out and they're

01:02:14,340 --> 01:02:18,750
all doing it like in a selfless manner

01:02:16,070 --> 01:02:21,740
the product is transparent for everyone

01:02:18,750 --> 01:02:24,960
everyone can look at the code base

01:02:21,740 --> 01:02:27,170
everyone can see how close that is being

01:02:24,960 --> 01:02:32,670
built nothing nothing is proprietary

01:02:27,170 --> 01:02:35,280
everything is open in many ways it's

01:02:32,670 --> 01:02:39,750
absolutely vital to the the unborn

01:02:35,280 --> 01:02:43,980
health CloudStack the most exciting

01:02:39,750 --> 01:02:46,810
event in recent memory for he was our

01:02:43,980 --> 01:02:49,450
first developer boot camp

01:02:46,810 --> 01:02:52,090
and our call gave people I gave you two

01:02:49,450 --> 01:02:56,050
weeks notice to come attend I was

01:02:52,090 --> 01:03:00,220
expecting 25 or 30 people so we ended up

01:02:56,050 --> 01:03:03,070
with 87 people and had to go get more

01:03:00,220 --> 01:03:05,590
chairs in the room twice everything

01:03:03,070 --> 01:03:08,860
within cloud computing is commodity and

01:03:05,590 --> 01:03:11,920
is open source and so I don't think that

01:03:08,860 --> 01:03:13,660
you will you'll see anywhere where open

01:03:11,920 --> 01:03:16,690
source is not pervasive in cloud

01:03:13,660 --> 01:03:19,270
computing and so i think it's i think

01:03:16,690 --> 01:03:20,770
it's an assumption i think when you talk

01:03:19,270 --> 01:03:21,880
about cloud computing you're really

01:03:20,770 --> 01:03:27,430
talking about open source cloud

01:03:21,880 --> 01:03:30,460
computing cloud zac is a robust solution

01:03:27,430 --> 01:03:32,620
for large deployments you'll have dozens

01:03:30,460 --> 01:03:36,910
of data centers and thousands of servers

01:03:32,620 --> 01:03:39,550
in each data centers these hardware is

01:03:36,910 --> 01:03:43,060
going to fail and CloudStack is designed

01:03:39,550 --> 01:03:45,760
to handle number one that mass scale

01:03:43,060 --> 01:03:48,940
number two it's designed to handle the

01:03:45,760 --> 01:03:51,790
failure that inevitably happens in large

01:03:48,940 --> 01:03:55,990
deployments started working on contact

01:03:51,790 --> 01:03:59,260
over four years ago and it was the

01:03:55,990 --> 01:04:01,030
original set of people working on it had

01:03:59,260 --> 01:04:05,140
a background of delivering software

01:04:01,030 --> 01:04:09,370
telcos and service providers lots of QA

01:04:05,140 --> 01:04:13,000
lots of users actually using it high

01:04:09,370 --> 01:04:16,060
availability is a key feature multiple

01:04:13,000 --> 01:04:18,100
hypervisors support different network

01:04:16,060 --> 01:04:20,770
models you can pick up whatever suits

01:04:18,100 --> 01:04:23,020
you better well step management server

01:04:20,770 --> 01:04:26,710
can be deployed in different physical

01:04:23,020 --> 01:04:28,390
machines it definitely has a huge

01:04:26,710 --> 01:04:33,370
footprint it's being deployed everywhere

01:04:28,390 --> 01:04:35,950
there's a major movie studio that they

01:04:33,370 --> 01:04:39,130
were using cloudstack they were using it

01:04:35,950 --> 01:04:41,230
to transcode video and i thought that

01:04:39,130 --> 01:04:42,880
was terribly fascinating what i found

01:04:41,230 --> 01:04:46,150
more fascinating is what they did during

01:04:42,880 --> 01:04:48,910
lunch where they would spin up you know

01:04:46,150 --> 01:04:50,290
50 or 60 game servers then as soon as

01:04:48,910 --> 01:04:50,820
lunch was over they would destroy all

01:04:50,290 --> 01:04:53,000
fiesta

01:04:50,820 --> 01:04:56,400
Susan compactor doing a little work

01:04:53,000 --> 01:04:57,930
cloudstack is vast it touches so many

01:04:56,400 --> 01:04:59,790
different aspects and there's no one

01:04:57,930 --> 01:05:02,750
person that's kind of like a master of

01:04:59,790 --> 01:05:06,240
all those realms I think CloudStack as a

01:05:02,750 --> 01:05:08,460
project is going to be one of the

01:05:06,240 --> 01:05:12,540
leaders simply because it's some of the

01:05:08,460 --> 01:05:17,970
most feature fallen and and robust

01:05:12,540 --> 01:05:20,870
platforms out they were Adam senior

01:05:17,970 --> 01:05:20,870
living through the clouds dag

01:05:33,700 --> 01:05:35,760

YouTube URL: https://www.youtube.com/watch?v=xwxFx1FlbQI


