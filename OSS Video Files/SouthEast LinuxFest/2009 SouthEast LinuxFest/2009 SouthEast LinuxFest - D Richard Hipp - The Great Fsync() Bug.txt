Title: 2009 SouthEast LinuxFest - D Richard Hipp - The Great Fsync() Bug
Publication date: 2012-02-13
Playlist: 2009 SouthEast LinuxFest
Description: 
	2009 SouthEast LinuxFest - D Richard Hipp - The Great Fsync() Bug

This video is licensed under Creative Commons Attribution 3.0 Unported License.
Captions: 
	00:00:00,000 --> 00:00:04,110
the following presentation was recorded

00:00:02,040 --> 00:00:06,390
by view digital media at the inaugural

00:00:04,110 --> 00:00:10,769
southeast linux fest in clemson south

00:00:06,390 --> 00:00:13,080
carolina on jun 13 2004 more information

00:00:10,769 --> 00:00:16,529
about the southeast linux fest visit

00:00:13,080 --> 00:00:18,270
southeast linux fest org thank you very

00:00:16,529 --> 00:00:22,289
much thank you for let me come and speak

00:00:18,270 --> 00:00:25,680
today but it's been a great show our

00:00:22,289 --> 00:00:27,810
fest I mean you really I gotta I gotta

00:00:25,680 --> 00:00:30,630
hand it to the folks who put this

00:00:27,810 --> 00:00:33,360
together i am usually the especially for

00:00:30,630 --> 00:00:35,579
a first-time event like this it's like

00:00:33,360 --> 00:00:37,559
you know 35 people gather together in a

00:00:35,579 --> 00:00:39,000
room and this has meant the attendance

00:00:37,559 --> 00:00:40,230
has been great it's been well organized

00:00:39,000 --> 00:00:42,239
a couple bumps here and there but

00:00:40,230 --> 00:00:43,260
nothing nothing like you'd normally get

00:00:42,239 --> 00:00:46,440
with the first time show they've done a

00:00:43,260 --> 00:00:47,610
great job it said in the printed program

00:00:46,440 --> 00:00:49,680
that the title of this was asked you

00:00:47,610 --> 00:00:55,140
alive but i changed the title to on

00:00:49,680 --> 00:00:56,789
monday to the great f sync bug and i let

00:00:55,140 --> 00:00:57,750
Jeremy know about that and he's all

00:00:56,789 --> 00:00:59,070
that's too like that's too bad because

00:00:57,750 --> 00:01:02,520
the programs have already been printed

00:00:59,070 --> 00:01:04,260
so but what is the great f sync bug this

00:01:02,520 --> 00:01:06,240
this came this really came to my

00:01:04,260 --> 00:01:08,909
attention about a little over a year ago

00:01:06,240 --> 00:01:11,700
when they were trying to get firefox 3

00:01:08,909 --> 00:01:15,180
out the door and this bug came up that

00:01:11,700 --> 00:01:16,920
said basically that firefox 3 was

00:01:15,180 --> 00:01:18,780
calling F sink too much and that was

00:01:16,920 --> 00:01:24,780
causing it to become very unresponsive

00:01:18,780 --> 00:01:26,340
and this was a problem because there

00:01:24,780 --> 00:01:28,500
would be this IO storm that would last

00:01:26,340 --> 00:01:30,390
for two or three minutes and the whole

00:01:28,500 --> 00:01:32,130
system and especially Firefox would be

00:01:30,390 --> 00:01:34,350
pretty much unresponsive for that and

00:01:32,130 --> 00:01:37,710
they traced the problem too sometimes

00:01:34,350 --> 00:01:41,130
the f sync system call would take over

00:01:37,710 --> 00:01:43,890
30 seconds to complete and this is being

00:01:41,130 --> 00:01:47,729
called from the UI thread which was a

00:01:43,890 --> 00:01:50,579
bad thing so you know people were

00:01:47,729 --> 00:01:52,619
reporting that this bug was you know

00:01:50,579 --> 00:01:55,619
really causing a lot of problems for a

00:01:52,619 --> 00:01:56,909
bun to Hardy and that it was really

00:01:55,619 --> 00:02:00,030
going to be a PR disaster if they

00:01:56,909 --> 00:02:03,180
released with this now Mozilla is a big

00:02:00,030 --> 00:02:05,610
customer of mine and so this they were

00:02:03,180 --> 00:02:07,530
like leaning on me to help them fix this

00:02:05,610 --> 00:02:09,420
quickly so this was like we were in big

00:02:07,530 --> 00:02:10,709
panic mode when this was happening

00:02:09,420 --> 00:02:13,440
because really the problem was traced

00:02:10,709 --> 00:02:13,870
where Firefox was calling SQLite which

00:02:13,440 --> 00:02:15,930
is Mike

00:02:13,870 --> 00:02:17,920
product and sqlite was calling s inc

00:02:15,930 --> 00:02:21,310
ascending that down to the colonel and

00:02:17,920 --> 00:02:24,310
which was telling the linux kernel to

00:02:21,310 --> 00:02:26,440
send the data onto the disk surface and

00:02:24,310 --> 00:02:29,080
that's what was really causing the

00:02:26,440 --> 00:02:30,459
underlying problem that called to FC now

00:02:29,080 --> 00:02:32,799
lest you think this is entirely

00:02:30,459 --> 00:02:35,500
restricted to being a problem in SQL I I

00:02:32,799 --> 00:02:39,040
I bring your attention to this issue

00:02:35,500 --> 00:02:40,900
that came up with KDE a year later which

00:02:39,040 --> 00:02:43,299
is really boils down to the same problem

00:02:40,900 --> 00:02:46,000
and I'll come back to that later on in

00:02:43,299 --> 00:02:48,190
the talk but let's start with a little

00:02:46,000 --> 00:02:51,280
bit of background what is asked you're

00:02:48,190 --> 00:02:54,160
like what is f sync why does that you're

00:02:51,280 --> 00:02:58,379
like all F sink and why should you care

00:02:54,160 --> 00:03:03,370
about any of this look at what is SQLite

00:02:58,379 --> 00:03:05,799
escalates an SQL database engine oh well

00:03:03,370 --> 00:03:07,480
do we really need another one aren't

00:03:05,799 --> 00:03:08,530
there enough of those already well

00:03:07,480 --> 00:03:10,359
that's true lies a little bit different

00:03:08,530 --> 00:03:12,909
from the others they're like five

00:03:10,359 --> 00:03:14,590
properties that I like to bring out as

00:03:12,909 --> 00:03:17,470
distinguishing features of which set

00:03:14,590 --> 00:03:19,959
sqlite apart from everybody else we'll

00:03:17,470 --> 00:03:23,079
start with Tony not serverless SQLite

00:03:19,959 --> 00:03:25,810
has no server most the SQL database

00:03:23,079 --> 00:03:27,609
engines have a server which runs as a

00:03:25,810 --> 00:03:29,980
separate process often on a separate

00:03:27,609 --> 00:03:33,519
machine and the clients talk usually via

00:03:29,980 --> 00:03:35,260
tcp/ip but by other IPC mechanisms to

00:03:33,519 --> 00:03:37,180
the server and the server does all the

00:03:35,260 --> 00:03:40,030
work and does the communications the

00:03:37,180 --> 00:03:41,590
disk with sqlite it's it's just a

00:03:40,030 --> 00:03:43,599
library that links into the client

00:03:41,590 --> 00:03:45,579
application and enables the clients to

00:03:43,599 --> 00:03:49,030
talk directly to the disks themselves

00:03:45,579 --> 00:03:50,859
there's no server in the middle now

00:03:49,030 --> 00:03:52,480
there are advantages to being surplus

00:03:50,859 --> 00:03:54,459
there are also disadvantages but since

00:03:52,480 --> 00:03:56,980
i'm talking about SQLite i'll ignore

00:03:54,459 --> 00:03:59,680
those for the moment if you want to know

00:03:56,980 --> 00:04:01,750
the disadvantages there's a fellow

00:03:59,680 --> 00:04:03,069
manning a postgres booth up in the

00:04:01,750 --> 00:04:04,840
exhibit area i'm sure he can brief you

00:04:03,069 --> 00:04:07,640
on those

00:04:04,840 --> 00:04:09,860
but the among the advantages is there's

00:04:07,640 --> 00:04:11,599
no background server process which means

00:04:09,860 --> 00:04:12,920
there's no configuration files you have

00:04:11,599 --> 00:04:14,390
to worry about there's no inter process

00:04:12,920 --> 00:04:17,269
communication that you have to worry

00:04:14,390 --> 00:04:18,889
about since there's no IPC you don't

00:04:17,269 --> 00:04:21,019
have to worry about leaving a tcp/ip

00:04:18,889 --> 00:04:23,810
port open on your firewall and allowing

00:04:21,019 --> 00:04:25,729
the world to be exposed directly to your

00:04:23,810 --> 00:04:28,580
server there's nothing to shutdown

00:04:25,729 --> 00:04:32,120
reboot reset maintain there's nothing to

00:04:28,580 --> 00:04:33,770
go wrong it just it just works and we

00:04:32,120 --> 00:04:34,940
can combine all that together and we

00:04:33,770 --> 00:04:36,740
call the whole concept zero

00:04:34,940 --> 00:04:39,470
administration which happens to be the

00:04:36,740 --> 00:04:42,620
next distinguishing characteristic you

00:04:39,470 --> 00:04:44,930
know most database engines come with a

00:04:42,620 --> 00:04:46,400
database administrator and this person's

00:04:44,930 --> 00:04:47,810
job is to keep the database running and

00:04:46,400 --> 00:04:50,330
there's actually things that you have to

00:04:47,810 --> 00:04:52,550
do to keep the database running and

00:04:50,330 --> 00:04:54,290
these are very important people and if

00:04:52,550 --> 00:04:55,820
you run in a large database installation

00:04:54,290 --> 00:04:58,070
you definitely need good administrators

00:04:55,820 --> 00:04:59,780
but sometimes you don't want an

00:04:58,070 --> 00:05:01,340
administrator I mean it's just not what

00:04:59,780 --> 00:05:02,960
you're wanting to do to help give you

00:05:01,340 --> 00:05:05,300
the concept let me tell you a little bit

00:05:02,960 --> 00:05:07,460
about how I originally came to write SQL

00:05:05,300 --> 00:05:08,750
I I was working on a project I was just

00:05:07,460 --> 00:05:11,389
doing freelance programming this is in

00:05:08,750 --> 00:05:14,180
the 90s and there was this big

00:05:11,389 --> 00:05:17,330
industrial plant this is one diagram of

00:05:14,180 --> 00:05:19,010
seven hundred and some odd that we're

00:05:17,330 --> 00:05:20,660
describing all the plumbing in this

00:05:19,010 --> 00:05:24,770
plant and there it was moving around

00:05:20,660 --> 00:05:26,510
steam and chilled water and oil and all

00:05:24,770 --> 00:05:29,600
kinds of stuff pumps valves everywhere

00:05:26,510 --> 00:05:32,120
and I had to do all this graphic

00:05:29,600 --> 00:05:33,770
software to show the state of the plant

00:05:32,120 --> 00:05:37,340
now all of this data was coming out of

00:05:33,770 --> 00:05:39,440
an informant database and this was

00:05:37,340 --> 00:05:41,570
running on an HP ux system standalone

00:05:39,440 --> 00:05:43,520
system that was operated by basically

00:05:41,570 --> 00:05:45,620
high school graduates and they would

00:05:43,520 --> 00:05:49,010
occasionally come around and reboot the

00:05:45,620 --> 00:05:50,840
server and when they would do that about

00:05:49,010 --> 00:05:51,950
half the time in foreign to come back up

00:05:50,840 --> 00:05:53,360
and everything worked great and about

00:05:51,950 --> 00:05:55,630
half the times and formics would decide

00:05:53,360 --> 00:05:57,950
that it didn't want to come back up and

00:05:55,630 --> 00:05:59,180
usually it would decide it did not want

00:05:57,950 --> 00:06:01,010
to come back up like at two in the

00:05:59,180 --> 00:06:02,660
morning and when it when in four weeks

00:06:01,010 --> 00:06:03,800
didn't come up then they would double

00:06:02,660 --> 00:06:05,419
click on the icon to bring up my

00:06:03,800 --> 00:06:07,389
application and I would pay in a dialog

00:06:05,419 --> 00:06:10,039
box that looked something like this and

00:06:07,389 --> 00:06:11,870
because my application was the one

00:06:10,039 --> 00:06:12,919
painting the dialog box I got the

00:06:11,870 --> 00:06:16,070
maintenance call at two in the morning

00:06:12,919 --> 00:06:17,360
so that was not good and the reason of

00:06:16,070 --> 00:06:18,080
course that this was happening was that

00:06:17,360 --> 00:06:20,270
before

00:06:18,080 --> 00:06:21,919
server wasn't there and took the clients

00:06:20,270 --> 00:06:23,659
couldn't operate and so my idea was why

00:06:21,919 --> 00:06:27,319
don't I just write a new database engine

00:06:23,659 --> 00:06:29,629
that can go directly to the disk even if

00:06:27,319 --> 00:06:32,210
the server is not there that way if the

00:06:29,629 --> 00:06:33,770
computer is healthy enough to bring up

00:06:32,210 --> 00:06:35,479
my application I know it's going to be

00:06:33,770 --> 00:06:37,909
able to get to its database there's

00:06:35,479 --> 00:06:39,979
never any question about that and so

00:06:37,909 --> 00:06:43,009
that was really what inspired me to

00:06:39,979 --> 00:06:47,000
write SQLite in the first place version

00:06:43,009 --> 00:06:49,159
one came out in two thousand another way

00:06:47,000 --> 00:06:51,139
to think of SQLite in relation to other

00:06:49,159 --> 00:06:54,919
databases is by analogy here's a picture

00:06:51,139 --> 00:06:56,240
of a recording studio big complex think

00:06:54,919 --> 00:06:57,740
this is where you'd go if you want to

00:06:56,240 --> 00:06:59,180
make recording for the next great boy

00:06:57,740 --> 00:07:03,800
band or something I mean you've got lots

00:06:59,180 --> 00:07:05,599
of knobs and dials cables do an

00:07:03,800 --> 00:07:07,430
incredible amount with this this

00:07:05,599 --> 00:07:11,210
recording studio but it also requires a

00:07:07,430 --> 00:07:13,430
lot of specialized knowledge this is a

00:07:11,210 --> 00:07:16,939
personal music listening device any

00:07:13,430 --> 00:07:19,159
six-year-old can operate this uh you

00:07:16,939 --> 00:07:21,889
know a client server databases to SQL I

00:07:19,159 --> 00:07:24,529
as a recording studio is an iPod really

00:07:21,889 --> 00:07:25,759
I mean you can do so much more with the

00:07:24,529 --> 00:07:29,240
studio but sometimes you just wanna

00:07:25,759 --> 00:07:30,860
listen to a tune you know so sqlite

00:07:29,240 --> 00:07:32,930
isn't really competing with oracle or a

00:07:30,860 --> 00:07:38,599
postgres or minus QL it's competing with

00:07:32,930 --> 00:07:40,639
F open the way to think about SQLite is

00:07:38,599 --> 00:07:42,259
too it's sort of a filter in between

00:07:40,639 --> 00:07:44,629
your application code and the disk drive

00:07:42,259 --> 00:07:46,580
which is translating high-level SQL

00:07:44,629 --> 00:07:48,830
statements into simple read and write

00:07:46,580 --> 00:07:51,440
requests that's what we're trying to do

00:07:48,830 --> 00:07:54,919
it's not a server all right fifth third

00:07:51,440 --> 00:07:56,330
of five points which kind of set SQLite

00:07:54,919 --> 00:07:58,159
part is that it has a portable file

00:07:56,330 --> 00:08:00,139
format and I'll come back to this and

00:07:58,159 --> 00:08:02,479
mint I mean a database file in SQLite is

00:08:00,139 --> 00:08:05,139
just an ordinary file on disk if you if

00:08:02,479 --> 00:08:07,940
you've got a database in MySQL or

00:08:05,139 --> 00:08:11,150
postgres or Oracle whatever the database

00:08:07,940 --> 00:08:13,550
is a bunch of files and they're often

00:08:11,150 --> 00:08:16,099
some hidden folder someplace that only

00:08:13,550 --> 00:08:18,500
the administrator has access to it's all

00:08:16,099 --> 00:08:19,969
very mysterious and spooky but an

00:08:18,500 --> 00:08:21,560
estimate like the file is just a single

00:08:19,969 --> 00:08:23,240
file on disk and you stick it on your

00:08:21,560 --> 00:08:24,379
your stick or whatever you want there no

00:08:23,240 --> 00:08:27,740
special naming conventions it's

00:08:24,379 --> 00:08:29,959
completely cross-platform a cross

00:08:27,740 --> 00:08:31,370
operating systems called hog where it's

00:08:29,959 --> 00:08:32,419
completely backwards compatible

00:08:31,370 --> 00:08:33,289
going to keep it backwards compat law

00:08:32,419 --> 00:08:35,690
it's not tied to any particular

00:08:33,289 --> 00:08:37,789
programming language so it's a really

00:08:35,690 --> 00:08:40,310
kind of universal medium for exchanging

00:08:37,789 --> 00:08:41,960
information you can take your SQL SQLite

00:08:40,310 --> 00:08:43,460
database and move them a lot across

00:08:41,960 --> 00:08:47,120
different media and read it on different

00:08:43,460 --> 00:08:49,700
devices so we combine the ideas of 0

00:08:47,120 --> 00:08:51,290
administration and portable file format

00:08:49,700 --> 00:08:53,779
and we say SQLite makes a great

00:08:51,290 --> 00:08:55,250
application file format what do we mean

00:08:53,779 --> 00:08:57,320
by that well I mean if you're writing a

00:08:55,250 --> 00:08:59,890
new application and you the first thing

00:08:57,320 --> 00:09:02,240
you do is a file open type thing and

00:08:59,890 --> 00:09:04,220
when you do file open what people

00:09:02,240 --> 00:09:06,350
normally do is f open the file and then

00:09:04,220 --> 00:09:08,029
read it in somehow and it might be XML

00:09:06,350 --> 00:09:09,650
and maybe comma separated values it

00:09:08,029 --> 00:09:10,970
might be some binary thing it might be

00:09:09,650 --> 00:09:13,070
some homegroup it doesn't really matter

00:09:10,970 --> 00:09:15,200
but wouldn't be much better if instead

00:09:13,070 --> 00:09:16,520
of reading in this proprietary format

00:09:15,200 --> 00:09:19,400
and writing all this code to interpret

00:09:16,520 --> 00:09:22,100
it just connect to an SQLite database

00:09:19,400 --> 00:09:23,630
and then you've got a query language

00:09:22,100 --> 00:09:25,550
built in the parcel is already built in

00:09:23,630 --> 00:09:28,700
when you go to save the file you get

00:09:25,550 --> 00:09:31,339
atomic updates you get a fast searching

00:09:28,700 --> 00:09:35,050
capability built-in you get a cool add

00:09:31,339 --> 00:09:37,250
on features like full text search

00:09:35,050 --> 00:09:38,959
archery indexing and that sort of thing

00:09:37,250 --> 00:09:43,400
and you've got all sorts of third-party

00:09:38,959 --> 00:09:46,580
tools that can access your data a fourth

00:09:43,400 --> 00:09:49,700
point very small footprint sqlite is

00:09:46,580 --> 00:09:53,270
less than 300 k if you compile optimized

00:09:49,700 --> 00:09:54,980
for size if you give it minus 0 3 which

00:09:53,270 --> 00:09:56,660
does lots of loop unrolling and function

00:09:54,980 --> 00:09:58,130
inlining and you naval all the optional

00:09:56,660 --> 00:10:01,250
features we're still less than a

00:09:58,130 --> 00:10:05,990
megabyte oracle client libraries are

00:10:01,250 --> 00:10:09,709
larger so the SQLite comes as a single

00:10:05,990 --> 00:10:11,060
file of ansi c code one file well

00:10:09,709 --> 00:10:12,380
there's a second file which is the

00:10:11,060 --> 00:10:13,820
header file which defines the interface

00:10:12,380 --> 00:10:15,830
but it's just one file so if you want to

00:10:13,820 --> 00:10:17,630
include this into your product all you

00:10:15,830 --> 00:10:18,560
have to do is take out one file and drop

00:10:17,630 --> 00:10:20,089
it down in the middle of your code

00:10:18,560 --> 00:10:22,130
compile it along with the rest of your C

00:10:20,089 --> 00:10:23,570
and it goes now it is a big file it's

00:10:22,130 --> 00:10:25,459
three a half megabytes but it's still

00:10:23,570 --> 00:10:28,670
just one file and it doesn't have any

00:10:25,459 --> 00:10:32,120
dependencies you don't have to download

00:10:28,670 --> 00:10:34,670
all of gtk in order to run sq like I

00:10:32,120 --> 00:10:36,770
mean it's just some simple of utilities

00:10:34,670 --> 00:10:38,300
are available almost any development

00:10:36,770 --> 00:10:40,640
environment such as you know mem coffee

00:10:38,300 --> 00:10:43,280
and mallet that's all you really need so

00:10:40,640 --> 00:10:44,990
you can take SQLite for example this one

00:10:43,280 --> 00:10:47,000
file in his header

00:10:44,990 --> 00:10:48,860
drop it into the middle of some much

00:10:47,000 --> 00:10:51,290
larger project in Shazam you've got an

00:10:48,860 --> 00:10:52,930
SQL database built-in it's compiled in

00:10:51,290 --> 00:10:56,779
there's nothing to add there's no

00:10:52,930 --> 00:10:58,459
dependencies and finally sq lights in

00:10:56,779 --> 00:11:01,040
the public domain there's no copyright

00:10:58,459 --> 00:11:04,010
at all had some interesting discussions

00:11:01,040 --> 00:11:05,930
yesterday with with Wendy cette Fleur

00:11:04,010 --> 00:11:07,399
about you know the whole thing this was

00:11:05,930 --> 00:11:08,930
probably a mistake on public domain

00:11:07,399 --> 00:11:11,899
rather than apache license but in two

00:11:08,930 --> 00:11:13,420
thousand there really wasn't I didn't

00:11:11,899 --> 00:11:16,760
have as many options as there are today

00:11:13,420 --> 00:11:18,230
but we do have signed copyright releases

00:11:16,760 --> 00:11:20,899
or signed copyright Disclaimer from

00:11:18,230 --> 00:11:24,200
everybody who's contributed any bit of

00:11:20,899 --> 00:11:27,320
code to sqlite and all of those are kept

00:11:24,200 --> 00:11:29,899
in a fire safe in my office so it is one

00:11:27,320 --> 00:11:31,730
hundred percent public domain you can

00:11:29,899 --> 00:11:32,870
use it for whatever you want there's

00:11:31,730 --> 00:11:34,790
lots of other features that we go into

00:11:32,870 --> 00:11:37,070
but this is this is talk about f sync

00:11:34,790 --> 00:11:38,180
not about SQLite so I'll skip over these

00:11:37,070 --> 00:11:39,830
really quick cuz you can have

00:11:38,180 --> 00:11:43,459
application defined functions and

00:11:39,830 --> 00:11:47,110
full-text search our trees you can utf-8

00:11:43,459 --> 00:11:49,730
utf-16 either way so forth and so on so

00:11:47,110 --> 00:11:52,160
it turns out that a lot of companies and

00:11:49,730 --> 00:11:56,329
a lot of projects are using SQLite for

00:11:52,160 --> 00:11:58,010
example a Dobby Photoshop uses the

00:11:56,329 --> 00:11:59,959
Lightroom product in Adobe Photoshop

00:11:58,010 --> 00:12:03,410
users SQLite as their application file

00:11:59,959 --> 00:12:05,360
format it's used in Adobe Reader somehow

00:12:03,410 --> 00:12:08,750
I'm not real sure how but apparently it

00:12:05,360 --> 00:12:10,430
is a mozilla firefox uses sqlite to

00:12:08,750 --> 00:12:14,320
store just about everything to get

00:12:10,430 --> 00:12:18,440
stored it's in every nokia cell phone

00:12:14,320 --> 00:12:23,060
it's in the google android phone it's in

00:12:18,440 --> 00:12:27,410
the iphone it's in iPod and iTunes it's

00:12:23,060 --> 00:12:30,140
in all kinds of other I stuff it's in

00:12:27,410 --> 00:12:32,690
the blackberry apparently it's in the

00:12:30,140 --> 00:12:37,220
new palm webos palm pre is what they're

00:12:32,690 --> 00:12:40,130
calling it now tin skype it's in the

00:12:37,220 --> 00:12:43,250
Sony Playstation it's in all kinds of

00:12:40,130 --> 00:12:45,680
consumer electronic devices and it's

00:12:43,250 --> 00:12:48,589
also used a lot in open source it's a it

00:12:45,680 --> 00:12:51,290
comes included with Python it's what

00:12:48,589 --> 00:12:53,839
Jung uses built in the PHP subversion

00:12:51,290 --> 00:12:55,579
requires it now as a version 1.6 its

00:12:53,839 --> 00:12:57,720
tracks built on it comes with rails

00:12:55,579 --> 00:13:02,079
monotone requires it

00:12:57,720 --> 00:13:06,089
so it's very widely used now I mentioned

00:13:02,079 --> 00:13:08,800
earlier about the the file format the

00:13:06,089 --> 00:13:13,089
SQLite database is a single ordinary

00:13:08,800 --> 00:13:16,450
file on disk and it's organized as a

00:13:13,089 --> 00:13:19,180
bunch of pages uniform size pages now

00:13:16,450 --> 00:13:20,800
the default size is 1k but it can be

00:13:19,180 --> 00:13:22,600
something different a power to but a

00:13:20,800 --> 00:13:27,459
database consists of a bunch of pages

00:13:22,600 --> 00:13:29,860
like this now at a lower level each of

00:13:27,459 --> 00:13:32,320
these pages go together into form be

00:13:29,860 --> 00:13:34,690
trees and be trees give you a key value

00:13:32,320 --> 00:13:37,000
pair type mechanism and the higher

00:13:34,690 --> 00:13:38,769
levels give you the the schema layer and

00:13:37,000 --> 00:13:41,140
all that other stuff I'm not going to go

00:13:38,769 --> 00:13:42,670
into the details you can go in and get

00:13:41,140 --> 00:13:45,880
coffee canoes and read about be trees

00:13:42,670 --> 00:13:48,279
all you want be trees of course just

00:13:45,880 --> 00:13:49,959
give you an efficient way of storing

00:13:48,279 --> 00:13:53,230
unlimited amounts of data and look it up

00:13:49,959 --> 00:13:55,240
very quickly in on external media it's

00:13:53,230 --> 00:13:58,060
it's page oriented so it fits nicely

00:13:55,240 --> 00:14:01,029
into that page type metaphor that we

00:13:58,060 --> 00:14:02,589
have how do we map the be trees into

00:14:01,029 --> 00:14:04,420
these individual pages of three well

00:14:02,589 --> 00:14:05,980
it's very simple each part of the b-tree

00:14:04,420 --> 00:14:08,589
gets mapped into one page of the

00:14:05,980 --> 00:14:11,350
database file very simple and

00:14:08,589 --> 00:14:13,269
straightforward arm we won't go to the

00:14:11,350 --> 00:14:14,620
details here but it's it's you can kind

00:14:13,269 --> 00:14:17,709
of get the idea of what's going on under

00:14:14,620 --> 00:14:19,180
the covers there the other key point

00:14:17,709 --> 00:14:22,240
about SQL light that comes into play in

00:14:19,180 --> 00:14:24,010
this discussion is that it's acid acid

00:14:22,240 --> 00:14:26,470
is you know property of all SQL

00:14:24,010 --> 00:14:29,350
databases atomic consistent isolated and

00:14:26,470 --> 00:14:33,610
durable what people mostly care about

00:14:29,350 --> 00:14:35,170
there is a tonic which means that when

00:14:33,610 --> 00:14:37,420
you make a change to the database a

00:14:35,170 --> 00:14:39,579
group of changes that are related all of

00:14:37,420 --> 00:14:41,199
them happen together they all happen at

00:14:39,579 --> 00:14:43,930
once or appear to happen all at once you

00:14:41,199 --> 00:14:45,490
can't get a partial change in the middle

00:14:43,930 --> 00:14:47,019
and this in other words you've got

00:14:45,490 --> 00:14:48,610
transactions and this is true even if

00:14:47,019 --> 00:14:50,709
you cut the power in the middle of that

00:14:48,610 --> 00:14:53,140
change which is an interesting property

00:14:50,709 --> 00:14:56,320
so if you make a change to the database

00:14:53,140 --> 00:15:00,310
it might need to update say three pages

00:14:56,320 --> 00:15:02,890
of the file and now you need to change

00:15:00,310 --> 00:15:05,949
all three pages on the disc at the same

00:15:02,890 --> 00:15:08,230
time how do you really do that what if

00:15:05,949 --> 00:15:09,790
you write the first page and then

00:15:08,230 --> 00:15:11,379
somebody cuts the power how does that

00:15:09,790 --> 00:15:14,019
work really how do you make this

00:15:11,379 --> 00:15:18,279
happen atomically well I'm about to

00:15:14,019 --> 00:15:19,509
explain to you how that works when you

00:15:18,279 --> 00:15:20,859
start up you booted up the machine this

00:15:19,509 --> 00:15:24,459
is sort of a diagram showing what is

00:15:20,859 --> 00:15:26,769
happening inside the computer on the on

00:15:24,459 --> 00:15:28,029
the far right you've got sort of the

00:15:26,769 --> 00:15:29,619
information that's on the disk I'm

00:15:28,029 --> 00:15:31,449
representing that in blue that's real

00:15:29,619 --> 00:15:34,720
information and you got a disk cache in

00:15:31,449 --> 00:15:36,369
in the linux kernel it's a Kashyap stuff

00:15:34,720 --> 00:15:37,479
because the discus really very slow and

00:15:36,369 --> 00:15:38,769
the only way you're running a decent

00:15:37,479 --> 00:15:41,109
performance out of a disk drive is to

00:15:38,769 --> 00:15:43,329
cash a lot of information in the colonel

00:15:41,109 --> 00:15:45,459
if you look and if you ever on top and

00:15:43,329 --> 00:15:47,470
you look and typically at least half of

00:15:45,459 --> 00:15:49,569
your ram is converted as devoted to cash

00:15:47,470 --> 00:15:51,039
so you first boot up there's nothing in

00:15:49,569 --> 00:15:52,779
cash you want to read from the database

00:15:51,039 --> 00:15:55,329
you read three pages you do a read

00:15:52,779 --> 00:15:56,949
system call and it pulls three pages off

00:15:55,329 --> 00:15:58,449
the disk it also stores them in cash in

00:15:56,949 --> 00:16:02,109
case you might want to reuse them again

00:15:58,449 --> 00:16:04,479
later so if first loads the pages into

00:16:02,109 --> 00:16:06,220
the operating systems address space in

00:16:04,479 --> 00:16:07,749
cash and then move them over to user

00:16:06,220 --> 00:16:09,399
space where you can get that to them and

00:16:07,749 --> 00:16:11,559
then you say well if I want to update

00:16:09,399 --> 00:16:14,319
this these three pages I want to perform

00:16:11,559 --> 00:16:16,600
a transaction what SQLite does is

00:16:14,319 --> 00:16:18,839
there's a right system call to write the

00:16:16,600 --> 00:16:21,009
original unmodified changes in

00:16:18,839 --> 00:16:23,399
unmodified content of those three pages

00:16:21,009 --> 00:16:25,600
into a rollback journal a separate file

00:16:23,399 --> 00:16:28,479
this in the same directory as the

00:16:25,600 --> 00:16:30,879
original database file and then it

00:16:28,479 --> 00:16:33,309
updates the three pages with the new

00:16:30,879 --> 00:16:37,449
content I'm showing the updates in sort

00:16:33,309 --> 00:16:39,129
of a pink color there but now notice

00:16:37,449 --> 00:16:43,299
when we did the right system call in the

00:16:39,129 --> 00:16:47,589
previous step when the information was

00:16:43,299 --> 00:16:49,539
only copied into ram in the operating

00:16:47,589 --> 00:16:50,979
system kernel it did not actually go to

00:16:49,539 --> 00:16:52,720
the disk well it might have gone the

00:16:50,979 --> 00:16:55,089
disk but probably not it was probably

00:16:52,720 --> 00:16:57,279
just went to cache the operating system

00:16:55,089 --> 00:17:00,069
weights and writes things out to disk as

00:16:57,279 --> 00:17:01,299
it has opportunity as its able just

00:17:00,069 --> 00:17:02,709
because you did a right in the right

00:17:01,299 --> 00:17:06,309
return does not mean the information

00:17:02,709 --> 00:17:08,500
actually went to the disk so after we

00:17:06,309 --> 00:17:09,939
get at before we're ready to start

00:17:08,500 --> 00:17:11,319
committing this we have to make sure

00:17:09,939 --> 00:17:13,449
that the information on that roll back

00:17:11,319 --> 00:17:16,000
journal actually gets out to disk and

00:17:13,449 --> 00:17:18,730
that is what the f sync system call does

00:17:16,000 --> 00:17:21,220
this forces the content of the file

00:17:18,730 --> 00:17:23,350
that's in this cashton memory to

00:17:21,220 --> 00:17:25,860
actually go out and be written onto the

00:17:23,350 --> 00:17:28,059
oxide of the disk platter

00:17:25,860 --> 00:17:29,860
that's the only way to really accomplish

00:17:28,059 --> 00:17:32,170
that is to call F sync well you call

00:17:29,860 --> 00:17:34,900
that data singing it or sink too but FF

00:17:32,170 --> 00:17:37,990
sink is what's designed to do that we

00:17:34,900 --> 00:17:41,860
have to do that and then we do a right

00:17:37,990 --> 00:17:43,210
system call to send our changes out to

00:17:41,860 --> 00:17:45,010
the disk and of course when you just do

00:17:43,210 --> 00:17:46,300
right it only goes to the cash it

00:17:45,010 --> 00:17:48,340
doesn't really write it out to the disk

00:17:46,300 --> 00:17:51,160
so we have to do another F sync to force

00:17:48,340 --> 00:17:54,790
those changes out to the disk and then

00:17:51,160 --> 00:17:56,170
we do a delete or a nun link on the

00:17:54,790 --> 00:17:58,900
rollback journal and this is what

00:17:56,170 --> 00:18:00,520
actually commits the transaction and

00:17:58,900 --> 00:18:02,040
you'll see why in just a second so after

00:18:00,520 --> 00:18:05,500
the the rollback journal has been

00:18:02,040 --> 00:18:07,120
deleted the transaction is committed and

00:18:05,500 --> 00:18:11,830
the changes are safely on disk now why

00:18:07,120 --> 00:18:13,030
is this atomic suppose that you were

00:18:11,830 --> 00:18:16,690
half way in the middle of this process

00:18:13,030 --> 00:18:18,220
and you're lost power and one of the

00:18:16,690 --> 00:18:20,170
three pages was completely right now

00:18:18,220 --> 00:18:22,770
another one was not written at all and

00:18:20,170 --> 00:18:25,210
the third was sort of halfway written

00:18:22,770 --> 00:18:26,830
when you rebooted and the next time

00:18:25,210 --> 00:18:28,240
somebody tried to open that dailies file

00:18:26,830 --> 00:18:30,309
it would notice that there was a

00:18:28,240 --> 00:18:32,650
rollback journal sitting there beside it

00:18:30,309 --> 00:18:34,570
and automatically read all of the

00:18:32,650 --> 00:18:36,580
content out of the rollback journal and

00:18:34,570 --> 00:18:38,590
write it back into the database file

00:18:36,580 --> 00:18:41,140
just backing out all of the partial

00:18:38,590 --> 00:18:42,990
changes that had been made so it makes

00:18:41,140 --> 00:18:47,050
it look like this is an atomic update

00:18:42,990 --> 00:18:50,470
now recall that first F sync was to get

00:18:47,050 --> 00:18:52,750
the information in the rollback journal

00:18:50,470 --> 00:18:54,970
and make sure it got out onto oxide what

00:18:52,750 --> 00:18:56,350
if we omitted that F sync what would

00:18:54,970 --> 00:18:59,080
happen then well you could get into a

00:18:56,350 --> 00:19:00,940
situation there where you would wear the

00:18:59,080 --> 00:19:04,179
operating system it started to write

00:19:00,940 --> 00:19:06,730
information to the disk drive before

00:19:04,179 --> 00:19:09,460
that it's before the original data had

00:19:06,730 --> 00:19:12,910
gotten out to the disk so here we've got

00:19:09,460 --> 00:19:14,590
a situation where on one of the pages in

00:19:12,910 --> 00:19:16,870
the robot journal didn't quite get out

00:19:14,590 --> 00:19:20,740
to the disk before the power was lost

00:19:16,870 --> 00:19:22,390
but some of the modified content did get

00:19:20,740 --> 00:19:23,950
into the original database file well

00:19:22,390 --> 00:19:25,210
when you go to roll that back you're

00:19:23,950 --> 00:19:26,890
going to be rolling back in complete

00:19:25,210 --> 00:19:28,809
dicta and that's going to put that

00:19:26,890 --> 00:19:32,290
incomplete data into your database file

00:19:28,809 --> 00:19:34,420
thus corrupting it what about the second

00:19:32,290 --> 00:19:37,420
of sync why do we need that one well in

00:19:34,420 --> 00:19:38,830
that case if you were busy writing

00:19:37,420 --> 00:19:42,039
things out to disk

00:19:38,830 --> 00:19:43,120
and you lost power it could be that your

00:19:42,039 --> 00:19:45,190
rollback journal had already been

00:19:43,120 --> 00:19:46,870
deleted before all the information got

00:19:45,190 --> 00:19:49,480
to disk and so there would be no

00:19:46,870 --> 00:19:51,519
rollback journal there to roll the

00:19:49,480 --> 00:19:55,809
partial rights back and to recover the

00:19:51,519 --> 00:19:57,519
data so key points the calls to F sync

00:19:55,809 --> 00:19:59,919
are required if the database is going to

00:19:57,519 --> 00:20:01,690
survive a power loss or an operating

00:19:59,919 --> 00:20:04,710
system crash of course it's linux the

00:20:01,690 --> 00:20:06,880
operating system crashes right but

00:20:04,710 --> 00:20:10,539
sometimes you know your two-year-old

00:20:06,880 --> 00:20:12,490
will punch the power button and the

00:20:10,539 --> 00:20:14,559
other thing is that effing only writes a

00:20:12,490 --> 00:20:17,350
few pages to the disk and it shouldn't

00:20:14,559 --> 00:20:19,809
take very much time at all well actually

00:20:17,350 --> 00:20:22,929
xing should only write a few pages to

00:20:19,809 --> 00:20:26,860
the disk and should be very fast let's

00:20:22,929 --> 00:20:28,750
talk a little bit about ext3 which is I

00:20:26,860 --> 00:20:31,539
guess pretty much the file system that

00:20:28,750 --> 00:20:36,370
everybody uses now I guess my primary

00:20:31,539 --> 00:20:39,639
development desktop ism azusa 10.1 which

00:20:36,370 --> 00:20:45,669
you still using ricer but other than me

00:20:39,639 --> 00:20:47,590
everybody using EST 3 right yeah the and

00:20:45,669 --> 00:20:50,230
i would i'd be using probably using xt

00:20:47,590 --> 00:20:52,299
32 it's just when i buy a new linux box

00:20:50,230 --> 00:20:54,279
I I call Phil at computer gallery and

00:20:52,299 --> 00:20:55,630
say send me a new box and he sends it to

00:20:54,279 --> 00:20:58,539
me I take it out my plug-in and i use it

00:20:55,630 --> 00:21:01,090
i mean i don't spend a lot of time I

00:20:58,539 --> 00:21:03,010
used to just like build my own and you

00:21:01,090 --> 00:21:04,690
know hand compile my own kernels with

00:21:03,010 --> 00:21:07,059
just the options that I want and all

00:21:04,690 --> 00:21:09,669
that stuff but after a while that gets

00:21:07,059 --> 00:21:14,500
old and you just get filled to do it for

00:21:09,669 --> 00:21:15,850
you so an extreme xt3 journaling works

00:21:14,500 --> 00:21:16,899
something like what we saw with this

00:21:15,850 --> 00:21:17,830
cannot but it's a little bit different

00:21:16,899 --> 00:21:19,510
there's there's a different twist on

00:21:17,830 --> 00:21:21,279
suppose you've got some here I've just

00:21:19,510 --> 00:21:23,620
got the colonel in the the disk because

00:21:21,279 --> 00:21:26,649
when applications aren't involved with

00:21:23,620 --> 00:21:28,179
ext3 you've got three changes and you

00:21:26,649 --> 00:21:30,970
want to write them to the disk the way

00:21:28,179 --> 00:21:32,470
txt three will went the wrong way wants

00:21:30,970 --> 00:21:35,230
to do this is it first writes the

00:21:32,470 --> 00:21:36,940
changes to the journal which I've got

00:21:35,230 --> 00:21:40,000
represented as the small box down the

00:21:36,940 --> 00:21:43,299
bottom and then it writes a commit

00:21:40,000 --> 00:21:45,190
record into that journal and that's the

00:21:43,299 --> 00:21:47,289
point that the change actually commits

00:21:45,190 --> 00:21:48,970
because ext3 is using a roll forward

00:21:47,289 --> 00:21:51,639
journal rather than a rollback journal

00:21:48,970 --> 00:21:52,640
Oh what two pages and so then it writes

00:21:51,639 --> 00:21:53,930
all of the content

00:21:52,640 --> 00:21:56,360
and out to the desk after it's been

00:21:53,930 --> 00:21:59,030
committed so that it it's where it

00:21:56,360 --> 00:22:01,070
should be now if you lost power at any

00:21:59,030 --> 00:22:03,470
point there when the power is restored

00:22:01,070 --> 00:22:05,180
what happens is that the roll forward

00:22:03,470 --> 00:22:07,700
journal is red and the changes are

00:22:05,180 --> 00:22:09,770
written out to the disc rather than

00:22:07,700 --> 00:22:14,360
under so that the changes are rolled

00:22:09,770 --> 00:22:15,620
forward rather than rolled back so the

00:22:14,360 --> 00:22:17,840
other concept that you need to be aware

00:22:15,620 --> 00:22:19,550
of in order to understand the great f

00:22:17,840 --> 00:22:25,340
sync bug is the difference between

00:22:19,550 --> 00:22:27,200
metadata and content metadata is as your

00:22:25,340 --> 00:22:29,150
inode information it's the that the

00:22:27,200 --> 00:22:30,770
times that are on the file the last

00:22:29,150 --> 00:22:32,600
modification time the creation time the

00:22:30,770 --> 00:22:34,100
last access time the file size the

00:22:32,600 --> 00:22:37,370
permissions access permissions on the

00:22:34,100 --> 00:22:39,200
file and also the location on the disk

00:22:37,370 --> 00:22:41,810
where the content of the file is and of

00:22:39,200 --> 00:22:44,420
course the content of the file is well

00:22:41,810 --> 00:22:46,850
the content of the file now there are

00:22:44,420 --> 00:22:48,920
three journaling modes in ext3 date

00:22:46,850 --> 00:22:50,480
equal journal means that all the content

00:22:48,920 --> 00:22:53,330
and all the metadata is always journaled

00:22:50,480 --> 00:22:55,640
on every right data equals ordered means

00:22:53,330 --> 00:22:57,680
the metadata journal but the content is

00:22:55,640 --> 00:22:59,330
not that the content is it takes care to

00:22:57,680 --> 00:23:01,460
write the content before it right before

00:22:59,330 --> 00:23:04,760
it commits the metadata and then data

00:23:01,460 --> 00:23:06,650
equals right back is it journals the

00:23:04,760 --> 00:23:09,200
metadata and it just writes the content

00:23:06,650 --> 00:23:11,960
whenever it feels like it now the

00:23:09,200 --> 00:23:13,700
default option is data equals order

00:23:11,960 --> 00:23:15,050
that's probably what everybody here is

00:23:13,700 --> 00:23:16,760
running on their linux systems data

00:23:15,050 --> 00:23:19,400
equals order does anybody know if you're

00:23:16,760 --> 00:23:22,490
running something different what are you

00:23:19,400 --> 00:23:27,470
running are you and is it because of the

00:23:22,490 --> 00:23:30,050
FC bug oh ok solid-state disk ok so

00:23:27,470 --> 00:23:31,430
anyway and data equal ordered the the

00:23:30,050 --> 00:23:33,530
writing operation is a little bit

00:23:31,430 --> 00:23:35,840
different because it's just going to

00:23:33,530 --> 00:23:38,990
write the metadata out to the rollback

00:23:35,840 --> 00:23:40,790
journal and then after it gets the

00:23:38,990 --> 00:23:43,820
metadata there before it commits it it

00:23:40,790 --> 00:23:47,300
then writes the content directly to the

00:23:43,820 --> 00:23:50,090
disk and then up then it writes the

00:23:47,300 --> 00:23:53,270
commit record and then it writes the

00:23:50,090 --> 00:23:55,250
metadata out there and so the content is

00:23:53,270 --> 00:23:57,830
always on the disk by the time the

00:23:55,250 --> 00:24:00,650
metadata gets there now with data equal

00:23:57,830 --> 00:24:02,300
right back well the content might be

00:24:00,650 --> 00:24:06,020
there are at minot and so if you had a

00:24:02,300 --> 00:24:08,930
crash when you came back up your

00:24:06,020 --> 00:24:11,630
10th might be stale your content mind

00:24:08,930 --> 00:24:13,790
consists of content that was previously

00:24:11,630 --> 00:24:16,070
in some other file that was deleted and

00:24:13,790 --> 00:24:18,770
that other file that was deleted might

00:24:16,070 --> 00:24:20,930
been somebody's private social security

00:24:18,770 --> 00:24:22,510
number or password or it might been the

00:24:20,930 --> 00:24:24,890
NC password file or something like that

00:24:22,510 --> 00:24:26,930
so there was a security problem with

00:24:24,890 --> 00:24:31,220
with dating right back and that's why

00:24:26,930 --> 00:24:36,500
most people now use data equals ordered

00:24:31,220 --> 00:24:38,120
uh because and with data equal ordered

00:24:36,500 --> 00:24:40,010
because the content always gets to disk

00:24:38,120 --> 00:24:41,720
before the metadata and the metadata

00:24:40,010 --> 00:24:43,550
says where the content is that means

00:24:41,720 --> 00:24:46,010
that if once the metadata is committed

00:24:43,550 --> 00:24:48,050
the content is going to be correct which

00:24:46,010 --> 00:24:50,870
is important so now let's think about s

00:24:48,050 --> 00:24:52,640
sink under data equals order now what FC

00:24:50,870 --> 00:24:57,500
does is it commits the inode the

00:24:52,640 --> 00:24:58,730
metadata and the journal in ext3 is

00:24:57,500 --> 00:25:01,460
linear I mean there's just a single

00:24:58,730 --> 00:25:02,900
journal and so when you commit any part

00:25:01,460 --> 00:25:04,820
of it you have to commit everything

00:25:02,900 --> 00:25:08,990
that's been put into the journal so far

00:25:04,820 --> 00:25:11,600
and then that means that all pending

00:25:08,990 --> 00:25:14,960
content changes must be written to the

00:25:11,600 --> 00:25:16,430
disk before an inode commits but now if

00:25:14,960 --> 00:25:18,650
you're going to commit just a one I node

00:25:16,430 --> 00:25:20,000
and there happen to be you know 30 or 40

00:25:18,650 --> 00:25:21,200
different I know changes in the journal

00:25:20,000 --> 00:25:25,430
I means you have to write the content

00:25:21,200 --> 00:25:27,860
for all of those I notes hence an F sink

00:25:25,430 --> 00:25:30,740
call and the ext three plushies all

00:25:27,860 --> 00:25:33,080
changes to the disk from all processes

00:25:30,740 --> 00:25:35,060
that are running on the machine not just

00:25:33,080 --> 00:25:37,970
from your one little process in other

00:25:35,060 --> 00:25:42,640
words s sink is the same as sync with

00:25:37,970 --> 00:25:45,740
data equal ordered under txt three so

00:25:42,640 --> 00:25:48,740
here were where you were s sinking stuff

00:25:45,740 --> 00:25:49,940
in our and our SQLite database and we

00:25:48,740 --> 00:25:51,350
thought that we were writing just three

00:25:49,940 --> 00:25:52,820
pages out the disk if you happen to have

00:25:51,350 --> 00:25:54,800
another process running in the

00:25:52,820 --> 00:25:56,480
background which is doing a lot of disk

00:25:54,800 --> 00:25:58,550
activities writing a lot of things to

00:25:56,480 --> 00:26:00,290
the disk unpacking a tarball or

00:25:58,550 --> 00:26:01,880
something like that that s think that

00:26:00,290 --> 00:26:03,440
would have should have just done three

00:26:01,880 --> 00:26:05,120
pages and quit is actually might be

00:26:03,440 --> 00:26:07,160
doing hundreds or even thousands of

00:26:05,120 --> 00:26:10,250
pages sinking it out to disk hence it

00:26:07,160 --> 00:26:15,290
might take 30 seconds or so this is the

00:26:10,250 --> 00:26:16,470
great F sink bug how do you work around

00:26:15,290 --> 00:26:19,270
it

00:26:16,470 --> 00:26:21,280
well one suggestion is to F data sync

00:26:19,270 --> 00:26:23,140
instead of F sync f davison just pushes

00:26:21,280 --> 00:26:26,740
the the content and doesn't bother with

00:26:23,140 --> 00:26:28,840
the inode under the theory that you know

00:26:26,740 --> 00:26:31,420
people really care if they're em time is

00:26:28,840 --> 00:26:33,190
out of date now the thing is f data sync

00:26:31,420 --> 00:26:35,490
will revert automatically revert to an F

00:26:33,190 --> 00:26:37,930
sink if the size of the file has changed

00:26:35,490 --> 00:26:40,660
so it's not a one hundred percent

00:26:37,930 --> 00:26:42,880
solution and also SQLite is

00:26:40,660 --> 00:26:46,450
cross-platform we have to run on lots of

00:26:42,880 --> 00:26:50,470
different platforms and on a lot of non

00:26:46,450 --> 00:26:53,020
Linux UNIX operating systems f data sync

00:26:50,470 --> 00:26:54,580
is a no op I mean it's there you can

00:26:53,020 --> 00:26:58,930
call it but it doesn't really do

00:26:54,580 --> 00:27:00,700
anything and so that's not good the

00:26:58,930 --> 00:27:03,190
other thing that another thing that we

00:27:00,700 --> 00:27:05,800
consider doing was in SQLite you can do

00:27:03,190 --> 00:27:08,670
set a pragma that disables those FC

00:27:05,800 --> 00:27:10,990
calls it just turns them off completely

00:27:08,670 --> 00:27:13,240
the trouble with that is if without

00:27:10,990 --> 00:27:16,330
doing F sinks if you lost power in the

00:27:13,240 --> 00:27:19,060
middle of the transaction then that

00:27:16,330 --> 00:27:21,400
could cause database corruption we call

00:27:19,060 --> 00:27:25,240
this the live fast and die young

00:27:21,400 --> 00:27:26,890
approach to data integrity it will cause

00:27:25,240 --> 00:27:30,130
things to run it will make things seem

00:27:26,890 --> 00:27:32,260
to run faster but it can have bad

00:27:30,130 --> 00:27:33,910
consequences you could change your

00:27:32,260 --> 00:27:36,820
applications so that it commits less

00:27:33,910 --> 00:27:38,530
often so for example you could modify

00:27:36,820 --> 00:27:40,990
your application so it does not do a

00:27:38,530 --> 00:27:45,340
complete transaction every time a person

00:27:40,990 --> 00:27:46,630
presses a key in the awesome bar you

00:27:45,340 --> 00:27:48,400
could limit your commits to when they do

00:27:46,630 --> 00:27:49,960
a file save and then if it took a few

00:27:48,400 --> 00:27:54,250
seconds when the system was busy people

00:27:49,960 --> 00:27:55,960
kind of understand that or you could you

00:27:54,250 --> 00:27:57,670
could keep running your entire session

00:27:55,960 --> 00:28:03,300
as a single transaction and you save

00:27:57,670 --> 00:28:06,850
points instead of using begin and commit

00:28:03,300 --> 00:28:09,700
you could move move your database work

00:28:06,850 --> 00:28:11,380
out of the main UI thread and put it

00:28:09,700 --> 00:28:13,030
into a background thread and now in

00:28:11,380 --> 00:28:13,870
recent versions of SQLite we have an

00:28:13,030 --> 00:28:15,640
option that you can do this

00:28:13,870 --> 00:28:16,720
automatically so if you have a just a

00:28:15,640 --> 00:28:18,190
single threaded program you can start

00:28:16,720 --> 00:28:20,320
another thread just to run the database

00:28:18,190 --> 00:28:22,030
and and move all the operations over

00:28:20,320 --> 00:28:25,420
there Firefox is kind of move into that

00:28:22,030 --> 00:28:27,340
too the problem with this approach is

00:28:25,420 --> 00:28:28,870
that threads are evil and we don't want

00:28:27,340 --> 00:28:31,020
to encourage them so

00:28:28,870 --> 00:28:38,620
I'm not going to recommend this to you

00:28:31,020 --> 00:28:40,360
there you go question yeah we tried to

00:28:38,620 --> 00:28:45,550
direct actually that slowed it down by

00:28:40,360 --> 00:28:47,050
about half um you could change your the

00:28:45,550 --> 00:28:50,050
way you mounted ext3 because if you do

00:28:47,050 --> 00:28:51,940
data equals right back then f sinks do

00:28:50,050 --> 00:28:53,080
what fc's are supposed to do just doing

00:28:51,940 --> 00:28:54,640
their loma handle because they don't

00:28:53,080 --> 00:28:56,380
have to sink all of that extra well they

00:28:54,640 --> 00:28:57,580
when you do an F sink with dating what's

00:28:56,380 --> 00:28:58,990
right back it does have to synchronize

00:28:57,580 --> 00:29:00,580
all the other I notes that are changing

00:28:58,990 --> 00:29:02,350
but that's not normally a problem it's

00:29:00,580 --> 00:29:04,090
it's really all the other content that's

00:29:02,350 --> 00:29:07,540
changed that's the problem or you can do

00:29:04,090 --> 00:29:09,970
de equals journal I guess that kind of

00:29:07,540 --> 00:29:11,320
forces things too but really making

00:29:09,970 --> 00:29:13,090
changes to the way you've managed your

00:29:11,320 --> 00:29:15,280
operating system is an unreasonable

00:29:13,090 --> 00:29:17,380
expectation to force upon Firefox

00:29:15,280 --> 00:29:19,809
shooters users most of whom do not know

00:29:17,380 --> 00:29:22,000
what a file system is much less how to

00:29:19,809 --> 00:29:24,640
change the mountain options or you could

00:29:22,000 --> 00:29:27,000
change to using ext4 it's c4 has a new

00:29:24,640 --> 00:29:31,390
feature called them delayed allocation

00:29:27,000 --> 00:29:33,809
so with the late allocation the location

00:29:31,390 --> 00:29:37,090
information that's in the end the inode

00:29:33,809 --> 00:29:39,400
is not a sign until you actually write

00:29:37,090 --> 00:29:41,890
that data and so with the late

00:29:39,400 --> 00:29:44,950
allocation when you do an F sink it's

00:29:41,890 --> 00:29:47,440
not necessary to sink all the content to

00:29:44,950 --> 00:29:48,850
disk because when you think the inode

00:29:47,440 --> 00:29:54,400
because the island doesn't contain the

00:29:48,850 --> 00:29:56,679
content information other you know a lot

00:29:54,400 --> 00:30:01,300
of people I say well why are we using an

00:29:56,679 --> 00:30:02,440
acid SQL database to store stuff in the

00:30:01,300 --> 00:30:04,270
first place why can't we just write

00:30:02,440 --> 00:30:06,790
everything into a big file using F open

00:30:04,270 --> 00:30:09,730
and close it like we've been doing for

00:30:06,790 --> 00:30:14,140
the past 40 years I mean what's why is

00:30:09,730 --> 00:30:15,460
the big worry with databases well you

00:30:14,140 --> 00:30:17,650
know a lot of people do just write a

00:30:15,460 --> 00:30:19,540
bunch of information into files we call

00:30:17,650 --> 00:30:21,700
this the pile of files approach to

00:30:19,540 --> 00:30:24,220
database design and that's works well

00:30:21,700 --> 00:30:26,920
but you know people are demanding more

00:30:24,220 --> 00:30:29,260
and and that is in fact what of the

00:30:26,920 --> 00:30:31,390
desktops pretty much do I mean you've

00:30:29,260 --> 00:30:33,070
got a dot KDE file and your home

00:30:31,390 --> 00:30:34,540
directory in a doc kinome finally home

00:30:33,070 --> 00:30:35,800
directory he's got just tons of

00:30:34,540 --> 00:30:40,390
configuration things in there and as you

00:30:35,800 --> 00:30:42,190
set up your desktop is riding those into

00:30:40,390 --> 00:30:45,580
those folders lots of little files

00:30:42,190 --> 00:30:48,429
in various formats a pile of files

00:30:45,580 --> 00:30:50,649
database but as things have become as we

00:30:48,429 --> 00:30:53,409
advance in the art people are expecting

00:30:50,649 --> 00:30:56,080
more robustness it used to be that

00:30:53,409 --> 00:30:58,210
people you wouldn't think of running a

00:30:56,080 --> 00:30:59,769
desktop that didn't have a UPS attached

00:30:58,210 --> 00:31:02,259
to it I mean that was just unthinkable

00:30:59,769 --> 00:31:04,210
to do such a thing certainly a desktop

00:31:02,259 --> 00:31:07,870
that had critical information you would

00:31:04,210 --> 00:31:10,570
always have ups these days who nobody

00:31:07,870 --> 00:31:14,049
uses a UPS UPS much anymore except for

00:31:10,570 --> 00:31:15,940
in a big data center maybe and people

00:31:14,049 --> 00:31:17,409
are expecting much people are storing

00:31:15,940 --> 00:31:19,779
much more critical data on their

00:31:17,409 --> 00:31:21,519
computers now than they were before it

00:31:19,779 --> 00:31:23,350
used to be you know if you lost a file

00:31:21,519 --> 00:31:26,559
okay so you lost your game history you

00:31:23,350 --> 00:31:28,840
know but now people are storing lots of

00:31:26,559 --> 00:31:30,610
financial information lots of critical

00:31:28,840 --> 00:31:33,039
information there that they have to keep

00:31:30,610 --> 00:31:34,360
so using the old pile of files database

00:31:33,039 --> 00:31:38,409
approach it really is just another

00:31:34,360 --> 00:31:41,259
variation on live fast and die young so

00:31:38,409 --> 00:31:44,230
and and this this problem really came up

00:31:41,259 --> 00:31:46,690
recently here of March 11th there was a

00:31:44,230 --> 00:31:49,899
thing on slashdot about how if you cut

00:31:46,690 --> 00:31:51,279
the power to KDE at the wrong moment it

00:31:49,899 --> 00:31:54,039
will corrupt some of its configuration

00:31:51,279 --> 00:31:57,519
files and once the configuration files

00:31:54,039 --> 00:32:01,120
are corrupt it will not boot up and I

00:31:57,519 --> 00:32:03,460
guess you could you know go into just a

00:32:01,120 --> 00:32:04,570
single user mode and kind of recover

00:32:03,460 --> 00:32:06,879
things that way if you knew what you

00:32:04,570 --> 00:32:08,320
were doing but certainly your

00:32:06,879 --> 00:32:10,960
grandmother does not know how to do this

00:32:08,320 --> 00:32:12,399
and and even even a lot of hackers would

00:32:10,960 --> 00:32:13,659
have after it's been a couple of hours

00:32:12,399 --> 00:32:15,190
trying to figure out how to recover from

00:32:13,659 --> 00:32:17,409
such a situation like this this was a

00:32:15,190 --> 00:32:19,620
bad thing what was happening with KDE

00:32:17,409 --> 00:32:22,600
this this is also problem with genome

00:32:19,620 --> 00:32:25,389
they were saving their pile of files

00:32:22,600 --> 00:32:28,029
data this way they would open a new file

00:32:25,389 --> 00:32:29,409
and then they would write their content

00:32:28,029 --> 00:32:31,929
into the new file then they would close

00:32:29,409 --> 00:32:35,590
the new file then they would rename the

00:32:31,929 --> 00:32:38,649
new file on top of the old one and this

00:32:35,590 --> 00:32:41,230
was assumed to be a tonic but it was not

00:32:38,649 --> 00:32:42,789
never has been the way to do this

00:32:41,230 --> 00:32:47,769
correctly is that you have to call F

00:32:42,789 --> 00:32:50,559
sink before the rename if you don't call

00:32:47,769 --> 00:32:53,710
the F think then it could be that the

00:32:50,559 --> 00:32:55,210
old file is deleted before the new file

00:32:53,710 --> 00:32:59,960
has been created

00:32:55,210 --> 00:33:02,420
and when that happens you end up with

00:32:59,960 --> 00:33:07,010
corruption and it's and nobody has a

00:33:02,420 --> 00:33:08,420
good day now the the lot of developer

00:33:07,010 --> 00:33:11,090
has been leaving out the F sink because

00:33:08,420 --> 00:33:14,300
of this myth that F sink causes a lot of

00:33:11,090 --> 00:33:17,420
extra io truth is f sink causes no

00:33:14,300 --> 00:33:20,150
additional IO at all it merely forces

00:33:17,420 --> 00:33:22,040
all of the IO to happen now rather than

00:33:20,150 --> 00:33:24,830
it's some specified point in the future

00:33:22,040 --> 00:33:26,840
it's working as a barrier operation to

00:33:24,830 --> 00:33:29,300
make sure that the things you that they

00:33:26,840 --> 00:33:31,640
do that are written before the F sink

00:33:29,300 --> 00:33:34,970
make it to disk before the things that

00:33:31,640 --> 00:33:36,290
are written after the F sink and the

00:33:34,970 --> 00:33:38,870
other myth is that well hey it's always

00:33:36,290 --> 00:33:41,210
worked for me before right why should I

00:33:38,870 --> 00:33:44,540
change now well in the past people been

00:33:41,210 --> 00:33:47,060
running ext3 and ext3 actually flushes

00:33:44,540 --> 00:33:49,970
everything to disk at five-second

00:33:47,060 --> 00:33:52,340
intervals anyway and so with things like

00:33:49,970 --> 00:33:54,140
Katie Ingham you had a five second

00:33:52,340 --> 00:33:56,540
window of vulnerability where you were

00:33:54,140 --> 00:33:59,720
vulnerable to crashes but now as people

00:33:56,540 --> 00:34:01,580
are moving to ext4 the the delay in

00:33:59,720 --> 00:34:03,530
sinking is much larger this is a

00:34:01,580 --> 00:34:05,570
performance optimization it makes things

00:34:03,530 --> 00:34:07,460
go a lot faster but you have a much

00:34:05,570 --> 00:34:11,090
larger window of vulnerability one to

00:34:07,460 --> 00:34:12,950
two minutes so if you if you cut power

00:34:11,090 --> 00:34:16,160
within one to two minutes after making a

00:34:12,950 --> 00:34:18,290
configuration change run a significant

00:34:16,160 --> 00:34:22,040
risk of damaging your configuration

00:34:18,290 --> 00:34:25,250
files so I don't know if you saw the

00:34:22,040 --> 00:34:27,550
announcement Wednesday is it that there

00:34:25,250 --> 00:34:31,100
is a new kernel that came out version

00:34:27,550 --> 00:34:33,710
2.6 point 30 you might have read this

00:34:31,100 --> 00:34:35,240
announcement and if you look down on the

00:34:33,710 --> 00:34:39,170
bullet list of changes there was one

00:34:35,240 --> 00:34:41,570
that said um an implicit internal f sync

00:34:39,170 --> 00:34:45,620
of a file after a rename or truncating

00:34:41,570 --> 00:34:48,190
ext three and four and in the btrfs file

00:34:45,620 --> 00:34:50,660
systems and this was marketed as

00:34:48,190 --> 00:34:53,540
performance optimization what's really

00:34:50,660 --> 00:34:56,690
happening here is that they hacked the

00:34:53,540 --> 00:34:58,730
file system code so that if you omit the

00:34:56,690 --> 00:35:03,260
F sink that really should be required

00:34:58,730 --> 00:35:06,400
according to POSIX it will be inserted

00:35:03,260 --> 00:35:08,700
for you automatically when you rename

00:35:06,400 --> 00:35:10,890
it's all that is

00:35:08,700 --> 00:35:13,050
so that's the back story behind that

00:35:10,890 --> 00:35:17,609
little bullet that appeared in the

00:35:13,050 --> 00:35:20,400
release from Wednesday what can you take

00:35:17,609 --> 00:35:22,290
away from this talk I hope that you've

00:35:20,400 --> 00:35:24,630
learned that crash robustness is really

00:35:22,290 --> 00:35:26,099
hard to get right there's been a lot of

00:35:24,630 --> 00:35:28,440
people really spend a lot of time

00:35:26,099 --> 00:35:30,119
working on this if your application is

00:35:28,440 --> 00:35:33,839
not playing paying very close attention

00:35:30,119 --> 00:35:36,359
to crash robustness it's probably doing

00:35:33,839 --> 00:35:38,880
it wrong and there's a tension between

00:35:36,359 --> 00:35:41,220
crashing robustness and speed a lot of

00:35:38,880 --> 00:35:42,540
people they want to cut some corners

00:35:41,220 --> 00:35:45,150
because it seems to make things go

00:35:42,540 --> 00:35:47,099
faster most of the time but on that day

00:35:45,150 --> 00:35:50,220
when they app when when you lose power

00:35:47,099 --> 00:35:52,020
you could you wish you'd you're taking

00:35:50,220 --> 00:35:55,410
the time to do an F sync don't fear the

00:35:52,020 --> 00:35:57,859
f sync it it's gotten a reputation

00:35:55,410 --> 00:36:00,450
because of ext3 of being a very

00:35:57,859 --> 00:36:04,050
experienced of system call but in fact

00:36:00,450 --> 00:36:06,450
it's in most cases it's not and in the

00:36:04,050 --> 00:36:10,680
lighter kernels it's not and finally the

00:36:06,450 --> 00:36:12,270
the infrastructure in UNIX and all the

00:36:10,680 --> 00:36:15,930
applications is getting better and

00:36:12,270 --> 00:36:22,680
better every time and that is my talk do

00:36:15,930 --> 00:36:36,630
I are there questions up front first do

00:36:22,680 --> 00:36:39,540
I need to back up correct the this new

00:36:36,630 --> 00:36:42,300
the some this new thing they inserted

00:36:39,540 --> 00:36:47,040
here that this does slow down EXT for a

00:36:42,300 --> 00:36:50,400
little bit and it's a hack and it was

00:36:47,040 --> 00:36:53,460
put in there because it's really too

00:36:50,400 --> 00:36:55,339
difficult to go back and change all of

00:36:53,460 --> 00:36:57,930
the applications that are doing it wrong

00:36:55,339 --> 00:36:59,730
now what needs to happen I in and this

00:36:57,930 --> 00:37:01,560
is just an ongoing debate within the

00:36:59,730 --> 00:37:03,510
community but what needs to happen is

00:37:01,560 --> 00:37:05,670
that that you know Linus or somebody

00:37:03,510 --> 00:37:07,680
needs to say look on such-and-such a

00:37:05,670 --> 00:37:10,290
date in 2010 we're going to take this

00:37:07,680 --> 00:37:11,609
hack out fix your applications now while

00:37:10,290 --> 00:37:13,380
you have a chance because it's going

00:37:11,609 --> 00:37:15,150
away now whether or not that actually

00:37:13,380 --> 00:37:16,950
happens is a big political thing I get

00:37:15,150 --> 00:37:18,750
it we may be stuck with this hack

00:37:16,950 --> 00:37:20,310
forever I understand that there's a

00:37:18,750 --> 00:37:22,260
compile-time option maybe is a runtime

00:37:20,310 --> 00:37:23,940
option to disable it if you have

00:37:22,260 --> 00:37:27,930
all of your applications do the right

00:37:23,940 --> 00:37:30,600
thing but do you know that really so I I

00:37:27,930 --> 00:37:32,250
don't know other questions on the red

00:37:30,600 --> 00:37:36,840
shirt yeah what did they do to work

00:37:32,250 --> 00:37:37,890
around in fire you know I asked so many

00:37:36,840 --> 00:37:39,920
times and I got so many different

00:37:37,890 --> 00:37:41,940
answers I'm not real clear on exactly

00:37:39,920 --> 00:37:43,560
what they did is they did a lot less

00:37:41,940 --> 00:37:45,660
commits they did many fewer commits they

00:37:43,560 --> 00:37:48,150
were doing a complete transaction every

00:37:45,660 --> 00:37:50,010
time you press the key while typing into

00:37:48,150 --> 00:37:52,950
the URL bar at the top of the browser

00:37:50,010 --> 00:37:54,990
and that was in a transaction was

00:37:52,950 --> 00:37:57,750
actually doing two or three F sinks per

00:37:54,990 --> 00:37:58,470
transaction and so they change things

00:37:57,750 --> 00:38:00,090
around little bit so they're

00:37:58,470 --> 00:38:02,880
accumulating and doing much bigger

00:38:00,090 --> 00:38:05,820
transactions less frequently and that

00:38:02,880 --> 00:38:07,800
helped a lot and later versions there

00:38:05,820 --> 00:38:09,780
they're doing a lot of their data

00:38:07,800 --> 00:38:11,310
management in temporary databases and a

00:38:09,780 --> 00:38:13,440
temporary database is not going to be

00:38:11,310 --> 00:38:14,940
around when you reboot right so you

00:38:13,440 --> 00:38:16,770
don't care if you lose power there if

00:38:14,940 --> 00:38:18,630
the iOS crashes and so temporary

00:38:16,770 --> 00:38:20,520
databases never f sync so there's a lot

00:38:18,630 --> 00:38:22,170
of work in those and then every

00:38:20,520 --> 00:38:24,780
periodically moving the data out of the

00:38:22,170 --> 00:38:27,000
temporary databases into the permanent

00:38:24,780 --> 00:38:29,070
persistent databases every minute or so

00:38:27,000 --> 00:38:30,930
and so if you crash you might lose the

00:38:29,070 --> 00:38:35,040
last minute or so of your bookmarks but

00:38:30,930 --> 00:38:36,750
does anybody really care and they're

00:38:35,040 --> 00:38:39,030
doing other things I'm not sure of all

00:38:36,750 --> 00:38:41,490
the details that they're doing but they

00:38:39,030 --> 00:38:43,230
take they spent a lot of time to work

00:38:41,490 --> 00:38:45,330
around this issue notice that it's not

00:38:43,230 --> 00:38:48,510
really a bug in effing s ink is doing

00:38:45,330 --> 00:38:50,580
all the right things it's looking after

00:38:48,510 --> 00:38:52,320
your data it's just that it was taking

00:38:50,580 --> 00:38:55,100
longer to do things because it was being

00:38:52,320 --> 00:38:57,440
very secure as being very cautious

00:38:55,100 --> 00:39:00,950
question this may be a stupid question

00:38:57,440 --> 00:39:00,950
there are no stupid questions

00:39:03,930 --> 00:39:08,730
sink is just the wrong API design from

00:39:06,930 --> 00:39:10,860
the need would it make more sense for

00:39:08,730 --> 00:39:13,590
there to be a colonel interface to do

00:39:10,860 --> 00:39:14,820
atomic transit you need a well the right

00:39:13,590 --> 00:39:17,070
thing to do is I have some sort of

00:39:14,820 --> 00:39:19,470
barrier operation so that all the rights

00:39:17,070 --> 00:39:20,760
that occur before the barrier happen

00:39:19,470 --> 00:39:22,410
before any of the rights that occur

00:39:20,760 --> 00:39:25,950
after and then it could delay them for

00:39:22,410 --> 00:39:27,990
as long as it wanted to my understanding

00:39:25,950 --> 00:39:29,190
is that well first of all that would not

00:39:27,990 --> 00:39:31,470
be POSIX there's nothing like that in

00:39:29,190 --> 00:39:32,610
posix and said well right and it has

00:39:31,470 --> 00:39:34,380
that ever stopped them before but

00:39:32,610 --> 00:39:36,360
apparently that was sufficient to stop

00:39:34,380 --> 00:39:37,920
the colonel people this time they said

00:39:36,360 --> 00:39:40,980
they've made it pretty clear that there

00:39:37,920 --> 00:39:43,110
is no barrier operation coming anytime

00:39:40,980 --> 00:39:44,640
soon in the colonel so we have to do

00:39:43,110 --> 00:40:07,920
what we have to do I've got two minutes

00:39:44,640 --> 00:40:10,380
in the back with the white hat well

00:40:07,920 --> 00:40:11,430
thank you my head thank you my head is

00:40:10,380 --> 00:40:16,890
swelling I'm not gonna be able to get

00:40:11,430 --> 00:40:31,380
other room thank you what what was your

00:40:16,890 --> 00:40:34,170
question we have 60 seconds well you

00:40:31,380 --> 00:40:35,100
know it i'm not i try not to tell people

00:40:34,170 --> 00:40:36,900
what to do i mean if you want to use

00:40:35,100 --> 00:40:39,450
tokyo cabinet that's fine I i looked at

00:40:36,900 --> 00:40:42,450
the tokyo cabinet code and i didn't see

00:40:39,450 --> 00:40:44,400
any f sinks in anywhere I you know I

00:40:42,450 --> 00:40:46,230
just I don't know I haven't tested it

00:40:44,400 --> 00:40:48,090
thoroughly but I looked at the code and

00:40:46,230 --> 00:40:49,590
I didn't find any comments anywhere in

00:40:48,090 --> 00:40:54,540
the code I didn't find a lot of test

00:40:49,590 --> 00:40:56,250
cases and it's pretty spare and you know

00:40:54,540 --> 00:40:57,630
I'm sure it works great as long as

00:40:56,250 --> 00:41:00,180
everything's are working it doesn't have

00:40:57,630 --> 00:41:01,650
the robustness sqlite designed to work

00:41:00,180 --> 00:41:03,900
on cell phones where if you run out of

00:41:01,650 --> 00:41:05,940
memory it handles that gracefully that

00:41:03,900 --> 00:41:07,350
never happens on workstations but on

00:41:05,940 --> 00:41:08,550
cell phones it happens all the time

00:41:07,350 --> 00:41:11,310
you're forever running out of memory

00:41:08,550 --> 00:41:13,610
does Tokyo cabinet recover gracefully

00:41:11,310 --> 00:41:16,020
from an outofmemory error I don't know

00:41:13,610 --> 00:41:17,070
these are things that you might want to

00:41:16,020 --> 00:41:19,000
ask

00:41:17,070 --> 00:41:28,630
one more question is so I haven't got

00:41:19,000 --> 00:41:30,760
the 30-second mark so yeah right i have

00:41:28,630 --> 00:41:36,130
30 seconds to answer the basic idea is

00:41:30,760 --> 00:41:38,740
that as sqlite is it assumes that the AP

00:41:36,130 --> 00:41:41,350
is that you call do what they advertise

00:41:38,740 --> 00:41:43,960
that they will do and so when I F sink

00:41:41,350 --> 00:41:45,580
or create a lock on the file that really

00:41:43,960 --> 00:41:48,220
is that sinking or really is locking the

00:41:45,580 --> 00:41:49,990
file and very often the network file

00:41:48,220 --> 00:41:52,330
systems are not implemented quite right

00:41:49,990 --> 00:41:54,280
and there are bugs and so these things

00:41:52,330 --> 00:41:55,990
don't do at what they're advertised to

00:41:54,280 --> 00:41:57,700
do and that can lead to problems that's

00:41:55,990 --> 00:42:00,190
the short answer which is probably all I

00:41:57,700 --> 00:42:02,500
have time for but I'll be here if you

00:42:00,190 --> 00:42:04,390
want to ask me privately any last minute

00:42:02,500 --> 00:42:06,220
questions in the ten seconds that remain

00:42:04,390 --> 00:42:11,230
no questions thank you very much for

00:42:06,220 --> 00:42:13,390
coming this work was recorded by view

00:42:11,230 --> 00:42:15,400
digital media and is licensed under a

00:42:13,390 --> 00:42:18,220
creative commons attribution share-alike

00:42:15,400 --> 00:42:20,770
version 3.4 more information about the

00:42:18,220 --> 00:42:24,240
southeast linux fest visit southeast

00:42:20,770 --> 00:42:24,240

YouTube URL: https://www.youtube.com/watch?v=TxXROT_nHqo


