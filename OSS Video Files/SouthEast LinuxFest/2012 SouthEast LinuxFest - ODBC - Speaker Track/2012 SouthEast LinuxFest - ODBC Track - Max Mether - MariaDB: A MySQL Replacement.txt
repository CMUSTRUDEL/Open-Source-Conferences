Title: 2012 SouthEast LinuxFest - ODBC Track - Max Mether - MariaDB: A MySQL Replacement
Publication date: 2013-04-06
Playlist: 2012 SouthEast LinuxFest - ODBC - Speaker Track
Description: 
	2012 SouthEast LinuxFest
Open Database Speaker Track
Max Mether
MariaDB: A MySQL Replacement
Captions: 
	00:00:00,000 --> 00:00:05,279
the following presentation was recorded

00:00:02,490 --> 00:00:08,040
the 2012 southeast linux fest in

00:00:05,279 --> 00:00:10,410
charlotte north carolina it is licensed

00:00:08,040 --> 00:00:12,090
under a creative commons license for

00:00:10,410 --> 00:00:16,859
more information about the southeast

00:00:12,090 --> 00:00:19,230
linux fest visit www.lend expense org

00:00:16,859 --> 00:00:21,320
the southeast linux fest would like to

00:00:19,230 --> 00:00:23,279
thank the following diamond sponsors in

00:00:21,320 --> 00:00:37,070
2012 for helping make these videos

00:00:23,279 --> 00:00:39,950
possible yes with a question mark so

00:00:37,070 --> 00:00:43,140
yeah I'm going to talk about Maria DB

00:00:39,950 --> 00:00:45,989
and actually before I start talking with

00:00:43,140 --> 00:00:48,870
Maria DB so my name is max i'm from

00:00:45,989 --> 00:00:52,260
finland originally I now live in in

00:00:48,870 --> 00:00:53,730
Georgia so not very far from here and I

00:00:52,260 --> 00:00:54,870
work for a company called scious grill

00:00:53,730 --> 00:01:01,520
and I used to work for a company called

00:00:54,870 --> 00:01:06,810
MySQL since a long time before I start

00:01:01,520 --> 00:01:09,900
who here has used Maria DB I get like

00:01:06,810 --> 00:01:15,390
three people okay not a lot who has used

00:01:09,900 --> 00:01:17,250
MySQL okay who has not used MySQL one

00:01:15,390 --> 00:01:21,720
guy okay good so I don't have to explain

00:01:17,250 --> 00:01:24,630
what mysql is done so basically in this

00:01:21,720 --> 00:01:26,939
talk i'm going to talk about a bit

00:01:24,630 --> 00:01:28,979
generically stuff about Maria DB how it

00:01:26,939 --> 00:01:31,650
came to be and stuff and then I'm going

00:01:28,979 --> 00:01:35,460
to focus on technical features that are

00:01:31,650 --> 00:01:39,420
present in Maria DB and not in mysql

00:01:35,460 --> 00:01:41,939
well yet at least in moscow so first of

00:01:39,420 --> 00:01:46,140
all a really quick introduction what is

00:01:41,939 --> 00:01:47,729
maria DB it's a branch of mysql its

00:01:46,140 --> 00:01:50,070
backward compatible it's a drop-in

00:01:47,729 --> 00:01:52,380
replacements if you're running mysql you

00:01:50,070 --> 00:01:54,810
can stop your server put merely be on

00:01:52,380 --> 00:01:58,219
the same data and it will work so it's a

00:01:54,810 --> 00:01:58,219
drop in replacement of mysql

00:01:59,340 --> 00:02:05,470
does it use the same configuration file

00:02:01,750 --> 00:02:06,850
yes I mean if you go from one version to

00:02:05,470 --> 00:02:09,460
the other you will have the same

00:02:06,850 --> 00:02:11,680
potential version incompatibilities that

00:02:09,460 --> 00:02:15,820
you would have with MySQL but other than

00:02:11,680 --> 00:02:17,590
that yes it works Maria DB is truly open

00:02:15,820 --> 00:02:21,970
source so the source code is available

00:02:17,590 --> 00:02:23,440
in launchpad everything that's ever in

00:02:21,970 --> 00:02:26,040
murray DB is open source there's no

00:02:23,440 --> 00:02:28,960
closed source modules like in mysql and

00:02:26,040 --> 00:02:32,350
the bugs database is open as well so all

00:02:28,960 --> 00:02:35,410
bugs in Mario DB are accessible to the

00:02:32,350 --> 00:02:36,490
public in a public database alright

00:02:35,410 --> 00:02:39,970
that's the background that doesn't

00:02:36,490 --> 00:02:45,880
really bees right so now a bit of

00:02:39,970 --> 00:02:47,860
history so- girl was created well the

00:02:45,880 --> 00:02:49,959
first version of what would eventually

00:02:47,860 --> 00:02:52,480
become mysql was created a long long

00:02:49,959 --> 00:02:56,050
time ago by one guy called monteverdi

00:02:52,480 --> 00:02:59,440
news who was then living in sweden but

00:02:56,050 --> 00:03:03,130
he's finished if anyone cares and this

00:02:59,440 --> 00:03:07,330
isn't back in 83 so a long time ago and

00:03:03,130 --> 00:03:09,400
this thing it was called uni reg at the

00:03:07,330 --> 00:03:12,400
time was very far from mysql because of

00:03:09,400 --> 00:03:15,060
database he created it for his own needs

00:03:12,400 --> 00:03:17,350
he was working as a software consultant

00:03:15,060 --> 00:03:19,330
doing well software development for

00:03:17,350 --> 00:03:21,489
clients so he could have database that

00:03:19,330 --> 00:03:24,190
he would then install at clients places

00:03:21,489 --> 00:03:25,930
and stuff like that and this first

00:03:24,190 --> 00:03:28,360
version was created on a very specific

00:03:25,930 --> 00:03:30,670
platform platform is not open source or

00:03:28,360 --> 00:03:34,450
not not in C or anything like that so it

00:03:30,670 --> 00:03:38,170
was very far from mysql and then later

00:03:34,450 --> 00:03:41,709
on the platform where it is mysql

00:03:38,170 --> 00:03:43,420
prequel was living was actually ended in

00:03:41,709 --> 00:03:44,980
the end of life so they were saying all

00:03:43,420 --> 00:03:46,269
right we're gonna the platform is going

00:03:44,980 --> 00:03:49,570
to go away we don't have enough

00:03:46,269 --> 00:03:53,200
customers so we had to do something with

00:03:49,570 --> 00:03:54,880
his his you near I got it was called so

00:03:53,200 --> 00:04:01,450
he decided to record the whole thing in

00:03:54,880 --> 00:04:05,799
to see and he also decided to release as

00:04:01,450 --> 00:04:07,450
pub as open source and well it was a

00:04:05,799 --> 00:04:10,150
hard decision actually because he was

00:04:07,450 --> 00:04:12,129
selling his thing for customers

00:04:10,150 --> 00:04:13,510
and he was scared of doing this open

00:04:12,129 --> 00:04:17,019
source he was like well if I open source

00:04:13,510 --> 00:04:18,880
this why would anyone ever pay but his

00:04:17,019 --> 00:04:21,549
friend javadocs not convinced him that

00:04:18,880 --> 00:04:23,080
it's the right thing to do and partly

00:04:21,549 --> 00:04:25,270
because they had been using open source

00:04:23,080 --> 00:04:26,500
tools in their development they said

00:04:25,270 --> 00:04:27,940
okay well maybe it's time we give

00:04:26,500 --> 00:04:29,770
something back to the community let's

00:04:27,940 --> 00:04:32,740
release his open source and see what

00:04:29,770 --> 00:04:34,710
happens and it happened well it turned

00:04:32,740 --> 00:04:37,449
out to be quite a good thing so MySQL

00:04:34,710 --> 00:04:39,250
the product was released in 95 at the

00:04:37,449 --> 00:04:41,110
same time the company my Escalade be was

00:04:39,250 --> 00:04:46,570
created there were three in the

00:04:41,110 --> 00:04:47,830
beginning well a few years later the

00:04:46,570 --> 00:04:50,740
company was acquired for 1 billion

00:04:47,830 --> 00:04:53,710
dollars by Sun so it was a good good

00:04:50,740 --> 00:04:56,669
idea I in my girl was in the right place

00:04:53,710 --> 00:04:59,320
the right time right he was raised in 95

00:04:56,669 --> 00:05:01,630
basically when internet was rising and

00:04:59,320 --> 00:05:03,190
the lamp stack became a thing and

00:05:01,630 --> 00:05:07,210
everyone had a lamp stack and including

00:05:03,190 --> 00:05:09,160
including mysql and so forth right so we

00:05:07,210 --> 00:05:12,520
first forward a bit my Escalade be is

00:05:09,160 --> 00:05:15,060
acquired by sun the company was around

00:05:12,520 --> 00:05:18,970
500 people at the time my scopus was

00:05:15,060 --> 00:05:21,669
acquired so it was already growing into

00:05:18,970 --> 00:05:23,650
a larger organization but still 500 is

00:05:21,669 --> 00:05:29,400
nothing compared to son who was whatever

00:05:23,650 --> 00:05:32,740
son was at a time 50,000 or something so

00:05:29,400 --> 00:05:35,229
quite a few people actually left when

00:05:32,740 --> 00:05:37,240
when mysql was acquired by sun including

00:05:35,229 --> 00:05:39,760
the original creator Monty veden years

00:05:37,240 --> 00:05:41,199
so he left son he took many of the core

00:05:39,760 --> 00:05:43,120
developers with him or well they

00:05:41,199 --> 00:05:44,500
followed I guess he didn't take them he

00:05:43,120 --> 00:05:47,110
didn't force them but but they

00:05:44,500 --> 00:05:49,780
volunteered and joined him they created

00:05:47,110 --> 00:05:52,360
a company called Monte program and the

00:05:49,780 --> 00:05:54,760
original plan was to do a development

00:05:52,360 --> 00:05:56,229
for mysql so they wanted to do

00:05:54,760 --> 00:05:59,349
development for mysql but they didn't

00:05:56,229 --> 00:06:03,729
want to work for a big company another's

00:05:59,349 --> 00:06:07,900
original plan then oracle acquired son

00:06:03,729 --> 00:06:09,310
in april 2009 and well they decided to

00:06:07,900 --> 00:06:11,650
change their plant instead of just doing

00:06:09,310 --> 00:06:13,659
development for my girl they decided to

00:06:11,650 --> 00:06:16,810
create a branch or a fork of mysql and

00:06:13,659 --> 00:06:18,820
then Maria db5 one was released in

00:06:16,810 --> 00:06:21,110
February 2010 so the first version of

00:06:18,820 --> 00:06:23,670
Maria DB

00:06:21,110 --> 00:06:28,590
that's kind of the history behind Maria

00:06:23,670 --> 00:06:34,470
DB yeah well I'm very sure a very brief

00:06:28,590 --> 00:06:36,420
version of the history so who's behind

00:06:34,470 --> 00:06:38,190
me really well Monty program so the

00:06:36,420 --> 00:06:40,500
company I talked about the developed

00:06:38,190 --> 00:06:44,130
core developers of MySQL former core

00:06:40,500 --> 00:06:45,660
developers mysql and they had the same

00:06:44,130 --> 00:06:48,210
kind of development model as my escrow

00:06:45,660 --> 00:06:50,340
used to have people work from home they

00:06:48,210 --> 00:06:53,760
communicate through IRC and skype and so

00:06:50,340 --> 00:06:56,190
forth however they're by far not the

00:06:53,760 --> 00:06:58,560
only contributors to maria DB maria de

00:06:56,190 --> 00:07:01,500
is true kind of open source projects in

00:06:58,560 --> 00:07:03,960
the sense that a lot of the development

00:07:01,500 --> 00:07:08,280
is also from people outside the multi

00:07:03,960 --> 00:07:10,560
program company many of the features

00:07:08,280 --> 00:07:12,420
that you will I will talk about later

00:07:10,560 --> 00:07:15,180
were actually originally developed by

00:07:12,420 --> 00:07:18,090
someone else and then Monty program just

00:07:15,180 --> 00:07:19,590
for it to marry a DB some other features

00:07:18,090 --> 00:07:24,080
were actually created by others outside

00:07:19,590 --> 00:07:24,080
the company directly into Maria baby so

00:07:24,110 --> 00:07:28,620
they have a so it's an launchpad and

00:07:27,060 --> 00:07:32,130
they have captain's who basically

00:07:28,620 --> 00:07:34,830
allowed to are allowed to commit code to

00:07:32,130 --> 00:07:37,950
the Maria TV projects and while these

00:07:34,830 --> 00:07:40,110
statistics was like six months ago so

00:07:37,950 --> 00:07:42,650
sixty-four percent of the captains were

00:07:40,110 --> 00:07:45,810
from on the program and 36 were

00:07:42,650 --> 00:07:48,840
community people from outside the

00:07:45,810 --> 00:07:51,150
company so it's a true even though it's

00:07:48,840 --> 00:07:52,980
largely dominated by Monte program it's

00:07:51,150 --> 00:07:54,870
still it through a true open source

00:07:52,980 --> 00:07:58,050
project so there are people outside the

00:07:54,870 --> 00:08:00,690
company who commit code and who are

00:07:58,050 --> 00:08:05,430
allowed to to accept commits to the tree

00:08:00,690 --> 00:08:08,640
right so that's one of the girls more ad

00:08:05,430 --> 00:08:13,170
b2b community developed stable and free

00:08:08,640 --> 00:08:15,480
so free in the sense of open source not

00:08:13,170 --> 00:08:18,560
free beer but it's also free of course

00:08:15,480 --> 00:08:18,560
you don't have to pay for it

00:08:19,930 --> 00:08:23,960
alright that's kind of the background

00:08:22,160 --> 00:08:27,860
now I'm going to start talking about

00:08:23,960 --> 00:08:29,720
features so well if you have any

00:08:27,860 --> 00:08:34,099
questions about these features feel free

00:08:29,720 --> 00:08:37,070
to interrupt me but but one hour is kind

00:08:34,099 --> 00:08:39,110
of short so I have here a list of

00:08:37,070 --> 00:08:42,969
features which is not all the features

00:08:39,110 --> 00:08:46,970
that differ between MariaDB and mysql

00:08:42,969 --> 00:08:49,340
it's kind of the major features but

00:08:46,970 --> 00:08:51,950
there are others as well and also note

00:08:49,340 --> 00:08:53,720
that I have the features in kind of in

00:08:51,950 --> 00:08:57,320
the order they were introduced into

00:08:53,720 --> 00:09:00,710
Maria DB so the the GI version of my a

00:08:57,320 --> 00:09:03,800
DB is Maria DB 55 which is based on

00:09:00,710 --> 00:09:05,540
MySQL 55 but here these features will be

00:09:03,800 --> 00:09:06,950
in like kind of chronological order when

00:09:05,540 --> 00:09:09,440
they were introduced so I'm going to

00:09:06,950 --> 00:09:13,339
start with features introduced in maybe

00:09:09,440 --> 00:09:16,910
5 1 and these features are still present

00:09:13,339 --> 00:09:19,130
in in 55 except if there's something

00:09:16,910 --> 00:09:23,690
here like this star here p v xt is no

00:09:19,130 --> 00:09:24,980
longer there by default for example so

00:09:23,690 --> 00:09:30,830
the first reason for you babe is we need

00:09:24,980 --> 00:09:32,839
to be 51 so it was based on mysql 51 it

00:09:30,830 --> 00:09:37,820
had a few new features storage engines

00:09:32,839 --> 00:09:41,990
that weren't in in mysql notably extra

00:09:37,820 --> 00:09:46,310
DB which who knows what extra DB is no

00:09:41,990 --> 00:09:52,060
one who knows what innodb is okay in a

00:09:46,310 --> 00:09:54,320
divot yeah so extra DB is actually an

00:09:52,060 --> 00:09:58,130
open source version of equal energy is

00:09:54,320 --> 00:10:00,440
also open source but it's just a fork or

00:09:58,130 --> 00:10:05,960
a branch of energy be so it's in a DB

00:10:00,440 --> 00:10:12,110
with some added features back in mysql

00:10:05,960 --> 00:10:14,300
50 google released patches 22 innodb

00:10:12,110 --> 00:10:17,330
that made innodb more usable for

00:10:14,300 --> 00:10:21,260
multi-core environments and because of

00:10:17,330 --> 00:10:24,050
various reasons my Achilles was unable

00:10:21,260 --> 00:10:28,730
to to include these patches into the

00:10:24,050 --> 00:10:31,130
inner db3 so so basically mysql if you

00:10:28,730 --> 00:10:32,990
download the moscow 50 or and five

00:10:31,130 --> 00:10:35,180
you didn't have these improvements and

00:10:32,990 --> 00:10:37,520
that's how extra DB was was created

00:10:35,180 --> 00:10:39,380
originally so it was basically an

00:10:37,520 --> 00:10:40,940
open-source version of inner DB with the

00:10:39,380 --> 00:10:46,280
Google patches that make unity be more

00:10:40,940 --> 00:10:50,000
usable for four well multi-core

00:10:46,280 --> 00:10:52,910
environments and now XD has evolved it's

00:10:50,000 --> 00:10:54,650
maintained not by percona and they've

00:10:52,910 --> 00:10:57,050
all added some instrumentation and other

00:10:54,650 --> 00:10:59,450
features to you know dbx to DB is very

00:10:57,050 --> 00:11:00,830
close to unity be but with some small

00:10:59,450 --> 00:11:03,560
differences when exedy was first

00:11:00,830 --> 00:11:05,150
introduced there was a big gap between a

00:11:03,560 --> 00:11:07,910
DB an extra day be now there's a much

00:11:05,150 --> 00:11:16,040
smaller gap but just still a bit of a

00:11:07,910 --> 00:11:19,670
gap between the two yes it's transparent

00:11:16,040 --> 00:11:22,400
in my ID be 55 the default this extra DB

00:11:19,670 --> 00:11:24,080
so it looks like using unity which are

00:11:22,400 --> 00:11:26,420
actually using extra DB but you can

00:11:24,080 --> 00:11:28,850
actually switch and use in a DBA if you

00:11:26,420 --> 00:11:30,530
prefer using the same inner DBS in my

00:11:28,850 --> 00:11:32,210
skull 55 but by default it would be

00:11:30,530 --> 00:11:34,280
actually be but you won't notice the

00:11:32,210 --> 00:11:36,650
difference because it's ninety-nine

00:11:34,280 --> 00:11:41,750
percent of the code is the same just a

00:11:36,650 --> 00:11:45,290
few a few add-ons there were a few more

00:11:41,750 --> 00:11:47,620
storage engines one is federated x does

00:11:45,290 --> 00:11:51,170
anyone know what what federate it is

00:11:47,620 --> 00:11:52,280
okay the usual suspects so it's a

00:11:51,170 --> 00:11:55,400
storage engine that allows you to

00:11:52,280 --> 00:11:59,120
connect to remote MySQL servers through

00:11:55,400 --> 00:12:00,260
you have like a local kind of a view but

00:11:59,120 --> 00:12:03,290
it's actually a connection to remote

00:12:00,260 --> 00:12:04,610
server and stuff and federal rate that

00:12:03,290 --> 00:12:07,460
has been in my school for quite a while

00:12:04,610 --> 00:12:09,170
and it's a fairly broken feature it's

00:12:07,460 --> 00:12:12,080
there but it doesn't work well and

00:12:09,170 --> 00:12:14,300
federated eggs is kind of a conclusion

00:12:12,080 --> 00:12:18,650
of federated so it's a community-driven

00:12:14,300 --> 00:12:21,230
open source and improved then the

00:12:18,650 --> 00:12:24,080
storage engine called Aria I guess

00:12:21,230 --> 00:12:26,510
that's how you pronounce it does anyone

00:12:24,080 --> 00:12:31,970
know what our eyes does anyone know my

00:12:26,510 --> 00:12:34,490
eyes on is three nods so my eyes I'm is

00:12:31,970 --> 00:12:36,710
kind of the traditional traditional

00:12:34,490 --> 00:12:39,620
engine from MySQL no transactions

00:12:36,710 --> 00:12:41,360
nothing so basically you have historian

00:12:39,620 --> 00:12:43,370
a very simple format and then you have

00:12:41,360 --> 00:12:46,790
indexes in a different file

00:12:43,370 --> 00:12:48,980
to to access the data the problem with

00:12:46,790 --> 00:12:50,390
my eyes on is that there's no crash

00:12:48,980 --> 00:12:53,630
recovery no safety if your server

00:12:50,390 --> 00:12:57,290
crashes doing during a right your table

00:12:53,630 --> 00:12:58,940
will be in a state of well in between of

00:12:57,290 --> 00:13:00,529
right so you will have some rows updated

00:12:58,940 --> 00:13:02,930
some notes and not then you have to do

00:13:00,529 --> 00:13:06,350
some kind of recovery process to be able

00:13:02,930 --> 00:13:08,930
to use those tables again so Aria is

00:13:06,350 --> 00:13:11,360
kind of the same thing except that it

00:13:08,930 --> 00:13:15,200
has crash recovery so it's kind of

00:13:11,360 --> 00:13:17,830
crushed safe it does not do transaction

00:13:15,200 --> 00:13:20,320
is just crush safe one state but it's

00:13:17,830 --> 00:13:22,520
crush safe / statement so one statement

00:13:20,320 --> 00:13:25,010
will be if it's crushed during the

00:13:22,520 --> 00:13:27,380
statement it will be rolled back but so

00:13:25,010 --> 00:13:34,430
it's not transactional but its statement

00:13:27,380 --> 00:13:36,830
safe kind of yes it's stable level

00:13:34,430 --> 00:13:40,370
locking so it's the same it's not much

00:13:36,830 --> 00:13:42,260
better it's just a crush safe it's there

00:13:40,370 --> 00:13:44,089
are plans to expand this to make it more

00:13:42,260 --> 00:13:48,589
transactional in the future but it's not

00:13:44,089 --> 00:13:51,410
done and it might never happen but still

00:13:48,589 --> 00:13:53,150
it does improve a bit from having an

00:13:51,410 --> 00:13:58,670
engine as not crushed says it's

00:13:53,150 --> 00:14:00,320
questions all right I'm by the way what

00:13:58,670 --> 00:14:02,510
some of many of these features are added

00:14:00,320 --> 00:14:04,720
by the multi program team some are added

00:14:02,510 --> 00:14:06,740
by others and stuff so I'm not going to

00:14:04,720 --> 00:14:08,390
I'm not saying that all of these

00:14:06,740 --> 00:14:09,950
features were added by multi program but

00:14:08,390 --> 00:14:11,930
all these features are present in my ad

00:14:09,950 --> 00:14:15,560
be so someone traded them and then they

00:14:11,930 --> 00:14:17,450
were added another feature added in

00:14:15,560 --> 00:14:20,810
might maybe be 51 was micro second

00:14:17,450 --> 00:14:23,990
support so MySQL until now does not

00:14:20,810 --> 00:14:26,240
support any generality below seconds in

00:14:23,990 --> 00:14:28,640
for example process list or the slow

00:14:26,240 --> 00:14:32,360
query log and stuff like that and this

00:14:28,640 --> 00:14:34,040
is Adam 51 amore adb so here I do a

00:14:32,360 --> 00:14:35,300
process list well actually it's an

00:14:34,040 --> 00:14:37,250
information schema dog process this

00:14:35,300 --> 00:14:39,830
command and I see the time execution

00:14:37,250 --> 00:14:41,089
time of a query with millisecond

00:14:39,830 --> 00:14:42,709
position instead of seeing it with

00:14:41,089 --> 00:14:44,540
second position because of course a

00:14:42,709 --> 00:14:48,080
second position on database is not very

00:14:44,540 --> 00:14:49,339
precise so that's a very good add on so

00:14:48,080 --> 00:14:53,020
you get it in the process based in a

00:14:49,339 --> 00:14:53,020
query slow query log and other things

00:14:53,769 --> 00:14:59,749
another edition in 51 was a thread pool

00:14:56,920 --> 00:15:01,129
it has a star here because there's

00:14:59,749 --> 00:15:04,610
actually a funny story related to this

00:15:01,129 --> 00:15:08,240
so the Margaret t DB team added a thread

00:15:04,610 --> 00:15:11,149
pool in 51 I mean the idea of a thread

00:15:08,240 --> 00:15:15,290
pool is too by default the MySQL every

00:15:11,149 --> 00:15:17,300
connection is a thread which works to a

00:15:15,290 --> 00:15:18,860
certain extent the problem is if you

00:15:17,300 --> 00:15:21,470
have a lot of connections and they're

00:15:18,860 --> 00:15:23,329
really small they do really small

00:15:21,470 --> 00:15:26,329
operations it means that you will have a

00:15:23,329 --> 00:15:28,309
lot of context switches on the cpu level

00:15:26,329 --> 00:15:30,199
right because you have to switch between

00:15:28,309 --> 00:15:31,490
the different threads and you don't have

00:15:30,199 --> 00:15:32,540
as many courses you have thread if you

00:15:31,490 --> 00:15:35,089
have a thousand threads you're not gonna

00:15:32,540 --> 00:15:39,249
have a thousand course and that creates

00:15:35,089 --> 00:15:41,779
create some weights on the cpu level so

00:15:39,249 --> 00:15:43,429
instead of having the cpu do the context

00:15:41,779 --> 00:15:45,079
switching you can't pull your

00:15:43,429 --> 00:15:47,329
connections into a specific set of

00:15:45,079 --> 00:15:48,860
threads so that the cpu doesn't have to

00:15:47,329 --> 00:15:50,149
do a context switching because but

00:15:48,860 --> 00:15:54,589
normally you would have as many threads

00:15:50,149 --> 00:15:56,329
as you have CP cores pretty much but it

00:15:54,589 --> 00:15:58,189
only works if you have this specific

00:15:56,329 --> 00:16:01,299
scenario have small transaction small

00:15:58,189 --> 00:16:04,129
operations and a lot of a lot of

00:16:01,299 --> 00:16:08,179
connections well anyway so this was

00:16:04,129 --> 00:16:11,059
added in in 512 MariaDB then later on

00:16:08,179 --> 00:16:14,990
when my SQL oracle came out with Moscow

00:16:11,059 --> 00:16:19,189
55 they added a thread pool as a close

00:16:14,990 --> 00:16:21,889
source plugging so if you get the the

00:16:19,189 --> 00:16:23,660
enterprise edition of MySQL you have to

00:16:21,889 --> 00:16:25,730
pay for it then you also get this close

00:16:23,660 --> 00:16:29,509
source thread thread pool as a plugin

00:16:25,730 --> 00:16:31,730
that you can use this is all fine except

00:16:29,509 --> 00:16:33,529
for one problem this closer threadpool

00:16:31,730 --> 00:16:35,869
actually worked better than the one in

00:16:33,529 --> 00:16:37,759
my ad be and this infuriated amarilla DB

00:16:35,869 --> 00:16:39,769
developers so they actually had to

00:16:37,759 --> 00:16:41,779
recreate the thread pool and in Moorea

00:16:39,769 --> 00:16:44,179
DB 55 there's a new version that is

00:16:41,779 --> 00:16:46,160
equal to the one in the enterprise

00:16:44,179 --> 00:16:48,439
version of mysql so that's what is a

00:16:46,160 --> 00:16:51,110
starter because they added it in 51 and

00:16:48,439 --> 00:16:54,860
then they had to re-engineer it because

00:16:51,110 --> 00:16:57,559
they were outperformed by by Oracle it

00:16:54,860 --> 00:17:01,519
is it is I mean so proud it's hold this

00:16:57,559 --> 00:17:04,549
whole a project I mean or product is a

00:17:01,519 --> 00:17:06,350
good example of I don't know how the

00:17:04,549 --> 00:17:08,569
MySQL ecosystem is

00:17:06,350 --> 00:17:11,689
thriving since since the acquisition of

00:17:08,569 --> 00:17:14,799
Oracle now there's much more competition

00:17:11,689 --> 00:17:19,220
out there on different products instance

00:17:14,799 --> 00:17:20,829
all right then the mayor the mega TV the

00:17:19,220 --> 00:17:24,410
multi program team also had a lot of

00:17:20,829 --> 00:17:26,959
optimizer features this well had to

00:17:24,410 --> 00:17:29,270
develop with the fact that the whole

00:17:26,959 --> 00:17:30,770
optimizer team actually joined Monte in

00:17:29,270 --> 00:17:33,830
Monte program so there was an optimized

00:17:30,770 --> 00:17:35,510
a team of around four guys and three of

00:17:33,830 --> 00:17:36,860
them joined Monte as soon as he created

00:17:35,510 --> 00:17:38,630
a company and then the fourth guy

00:17:36,860 --> 00:17:40,159
eventually joined as well I mean there

00:17:38,630 --> 00:17:42,770
are now others working optimizes team at

00:17:40,159 --> 00:17:44,179
Oracle but of the original team they all

00:17:42,770 --> 00:17:45,590
join Monte so it was easy to add

00:17:44,179 --> 00:17:49,280
optimizer features because they were all

00:17:45,590 --> 00:17:53,090
there so one of the optimizer features

00:17:49,280 --> 00:17:55,460
here is called table elimination it's a

00:17:53,090 --> 00:17:57,590
feature that that's useful in only

00:17:55,460 --> 00:17:59,419
specific cases and well that specific

00:17:57,590 --> 00:18:03,679
cases if you have this type of anchor

00:17:59,419 --> 00:18:06,710
schema so an anchor schema is is a

00:18:03,679 --> 00:18:10,940
database that's extremely normalized so

00:18:06,710 --> 00:18:12,530
instead of storing like it's almost like

00:18:10,940 --> 00:18:14,179
going beyond robust to column based

00:18:12,530 --> 00:18:17,059
accepted you are in a row based database

00:18:14,179 --> 00:18:19,760
so you don't store all your attributes

00:18:17,059 --> 00:18:25,100
for for entity in a table but just you

00:18:19,760 --> 00:18:28,250
have a table for each attribute right so

00:18:25,100 --> 00:18:30,140
this makes the for example here we have

00:18:28,250 --> 00:18:32,750
an actor is the entity instead of having

00:18:30,140 --> 00:18:35,000
a table with each actor a column for

00:18:32,750 --> 00:18:37,159
name a column for rating and column for

00:18:35,000 --> 00:18:39,409
birth date you have a specific table for

00:18:37,159 --> 00:18:42,020
each of these attributes the reason for

00:18:39,409 --> 00:18:43,429
doing this is to be able to have more

00:18:42,020 --> 00:18:45,799
flexibility and adding and removing

00:18:43,429 --> 00:18:47,210
attributes and you might have some

00:18:45,799 --> 00:18:48,620
entities that have certain attributes

00:18:47,210 --> 00:18:49,549
and other entities that don't have this

00:18:48,620 --> 00:18:51,950
attribute so you get a lot of

00:18:49,549 --> 00:18:54,590
flexibility but of course it's a

00:18:51,950 --> 00:18:56,179
nightmare to maintain its an not to

00:18:54,590 --> 00:18:59,120
maintain its nightmare to query because

00:18:56,179 --> 00:19:01,010
you have to do joints of 400 tables or

00:18:59,120 --> 00:19:02,840
whatever you have so not only what you

00:19:01,010 --> 00:19:07,400
would have is here we have a view that

00:19:02,840 --> 00:19:10,490
makes this into one table and then you

00:19:07,400 --> 00:19:12,710
create that view right the problem is

00:19:10,490 --> 00:19:16,250
Adam is co optimizer when you query this

00:19:12,710 --> 00:19:17,240
view it will join all these tables every

00:19:16,250 --> 00:19:19,520
single time any queries

00:19:17,240 --> 00:19:21,320
view because that's how the optimizer

00:19:19,520 --> 00:19:24,620
does it even though you're only looking

00:19:21,320 --> 00:19:26,300
for certain attributes if you still make

00:19:24,620 --> 00:19:28,160
the joint algorithm with all all the

00:19:26,300 --> 00:19:31,160
tables and that's where table

00:19:28,160 --> 00:19:34,040
elimination comes in the picture it will

00:19:31,160 --> 00:19:36,200
actually remove remove the tables that

00:19:34,040 --> 00:19:39,790
you're not using in this join if you

00:19:36,200 --> 00:19:43,190
remove them from the joint process so

00:19:39,790 --> 00:19:45,710
it's something that's useful mainly if

00:19:43,190 --> 00:19:47,180
you have well actually this is something

00:19:45,710 --> 00:19:49,010
that you could have if you use some kind

00:19:47,180 --> 00:19:50,810
of machine generated queries so if you

00:19:49,010 --> 00:19:51,890
have you don't actually write your

00:19:50,810 --> 00:19:54,290
queries you have some kind of middle

00:19:51,890 --> 00:19:55,730
layer that right squares for you because

00:19:54,290 --> 00:19:57,260
the middle layers oven always have to be

00:19:55,730 --> 00:19:59,000
flexible they might actually have an

00:19:57,260 --> 00:20:01,220
anchor schema behind behind the scenes

00:19:59,000 --> 00:20:04,730
and do queries like this in this case

00:20:01,220 --> 00:20:07,070
this will help you a lot so basically it

00:20:04,730 --> 00:20:10,190
will notice that this birth date table

00:20:07,070 --> 00:20:16,610
is not used in this query we want to

00:20:10,190 --> 00:20:18,350
look at we want to look at the rating

00:20:16,610 --> 00:20:20,180
and we're looking we're looking for a

00:20:18,350 --> 00:20:21,830
specific actor from for the name so we

00:20:20,180 --> 00:20:25,220
don't actually use the birth date a

00:20:21,830 --> 00:20:28,310
table so it's eliminated from the query

00:20:25,220 --> 00:20:31,040
process that's basically been done by

00:20:28,310 --> 00:20:32,780
the optimizer if you stand the MySQL it

00:20:31,040 --> 00:20:38,360
will include all the tables on this

00:20:32,780 --> 00:20:43,220
moment yeah i mean its specific for this

00:20:38,360 --> 00:20:46,300
anchor schema whatever quality schema

00:20:43,220 --> 00:20:46,300
anchor schema schema

00:20:49,580 --> 00:20:52,580
sled

00:20:56,600 --> 00:21:01,790
yeah so this is this is the column that

00:20:59,240 --> 00:21:11,990
exists in the actor table but not in a

00:21:01,790 --> 00:21:13,730
birthday table yeah I mean yeah I mean

00:21:11,990 --> 00:21:15,500
it basically only worked if you create

00:21:13,730 --> 00:21:16,730
this view I mean it basically use cases

00:21:15,500 --> 00:21:18,170
when you have a view and you accessed

00:21:16,730 --> 00:21:20,720
through the view because the view will

00:21:18,170 --> 00:21:30,020
be a set of left joins because I was a

00:21:20,720 --> 00:21:31,730
view wouldn't work right if you go to

00:21:30,020 --> 00:21:33,470
trouble creating with you first we have

00:21:31,730 --> 00:21:36,500
a lot of individuals where otherwise

00:21:33,470 --> 00:21:40,640
doing the same joints on getting more

00:21:36,500 --> 00:21:42,140
efficient no you would get more

00:21:40,640 --> 00:21:46,040
efficiency out of doing the joints

00:21:42,140 --> 00:21:47,960
yourself but so normally I mean often

00:21:46,040 --> 00:21:49,220
this is created by middle layer you

00:21:47,960 --> 00:21:50,360
don't actually write the queries it's

00:21:49,220 --> 00:21:54,080
the middle layer that writes them for

00:21:50,360 --> 00:21:55,790
you and so this you would if you instead

00:21:54,080 --> 00:21:57,020
of you just switch to Maria you would

00:21:55,790 --> 00:21:58,700
just suddenly order cuers would be

00:21:57,020 --> 00:22:00,590
faster and you don't even write the

00:21:58,700 --> 00:22:02,420
query as yourself I mean it's rare to

00:22:00,590 --> 00:22:03,470
use an anchor schema that's created by

00:22:02,420 --> 00:22:04,700
hand because I mean that you actually

00:22:03,470 --> 00:22:07,400
have to write all this quiz yourself

00:22:04,700 --> 00:22:08,810
have to figure out it you know so it's

00:22:07,400 --> 00:22:14,770
mostly created by some kind of middle

00:22:08,810 --> 00:22:14,770
layer yeah

00:22:18,710 --> 00:22:24,980
yeah they were yeah there were

00:22:21,270 --> 00:22:24,980
particular customers who had this color

00:22:26,600 --> 00:22:36,360
no I know I actually don't know I can't

00:22:35,010 --> 00:22:47,780
remember I've heard it but I can't

00:22:36,360 --> 00:22:50,640
remember so I can't tell you okay yeah

00:22:47,780 --> 00:22:56,460
something yeah I I don't remember i

00:22:50,640 --> 00:22:59,790
can't i can't give you the answer this

00:22:56,460 --> 00:23:01,740
is an administrative perspective yeah a

00:22:59,790 --> 00:23:04,710
lot more likely to be monitoring and

00:23:01,740 --> 00:23:08,310
running applications like hannah top and

00:23:04,710 --> 00:23:11,100
i am ii actually act included myself if

00:23:08,310 --> 00:23:12,810
some say somebody then create an exactly

00:23:11,100 --> 00:23:14,850
this view you got on the board here and

00:23:12,810 --> 00:23:16,740
we're running queries in their

00:23:14,850 --> 00:23:18,270
application against that view is your

00:23:16,740 --> 00:23:20,550
showing in that last braid out of the

00:23:18,270 --> 00:23:22,320
bottom if I wasn't on bringing it on top

00:23:20,550 --> 00:23:24,270
what I see the query at the bottom of

00:23:22,320 --> 00:23:26,460
what I be seeing you know the raw burger

00:23:24,270 --> 00:23:29,480
joint no you would see this at the

00:23:26,460 --> 00:23:32,480
bottom so you wouldn't see the view

00:23:29,480 --> 00:23:32,480
basically

00:23:33,260 --> 00:23:39,060
yeah I mean you don't know if it's a

00:23:37,380 --> 00:24:02,730
view our table it looks like a table but

00:23:39,060 --> 00:24:04,380
it's actually a view yeah typically go

00:24:02,730 --> 00:24:06,060
to code I don't tend to get involved

00:24:04,380 --> 00:24:08,090
when they could result in the corner

00:24:06,060 --> 00:24:10,470
don't know how to get out of it

00:24:08,090 --> 00:24:16,320
troubleshooter code myself I can

00:24:10,470 --> 00:24:18,030
frequently draw a big circle well sorry

00:24:16,320 --> 00:24:19,680
if you guys are having slow queries and

00:24:18,030 --> 00:24:26,280
it's because of this install my ad been

00:24:19,680 --> 00:24:27,510
it will go away that's the remedy all

00:24:26,280 --> 00:24:30,690
right this is other features so

00:24:27,510 --> 00:24:34,230
pluggable authentication was added

00:24:30,690 --> 00:24:35,520
merely b-52 so you can actually well you

00:24:34,230 --> 00:24:39,660
can use plugins to alton gate

00:24:35,520 --> 00:24:43,890
authenticate users and the creative plan

00:24:39,660 --> 00:24:46,470
plugging as well a pretty cool feature

00:24:43,890 --> 00:24:48,690
is used as statistics so in mysql you

00:24:46,470 --> 00:24:50,430
have lots of statistics but it's all in

00:24:48,690 --> 00:24:52,050
server level you can't get it on a

00:24:50,430 --> 00:24:54,270
session level but it's on the same

00:24:52,050 --> 00:24:55,830
session you're in and that's basically

00:24:54,270 --> 00:24:57,360
it you can get service statistics or

00:24:55,830 --> 00:25:02,370
session statistics and that's all you

00:24:57,360 --> 00:25:05,340
have so this patch was originally

00:25:02,370 --> 00:25:06,810
created by either Google or Facebook in

00:25:05,340 --> 00:25:08,520
any way mark Callahan's team are nervous

00:25:06,810 --> 00:25:12,600
before he moved or after he moved but

00:25:08,520 --> 00:25:14,340
one of the other and it was then refined

00:25:12,600 --> 00:25:16,410
and so forth but it's now in in Moorea

00:25:14,340 --> 00:25:19,680
so basically it gives you information

00:25:16,410 --> 00:25:23,670
schema tables where get information on

00:25:19,680 --> 00:25:24,780
per client so per kind of / host how

00:25:23,670 --> 00:25:28,620
many connections you get from this

00:25:24,780 --> 00:25:30,120
client how much data access and stuff

00:25:28,620 --> 00:25:32,390
like that how many rows how many bytes

00:25:30,120 --> 00:25:35,520
sent and stuff like very specific

00:25:32,390 --> 00:25:38,940
statistics on each client on his user

00:25:35,520 --> 00:25:40,860
account and then statistics / index and

00:25:38,940 --> 00:25:43,950
/ table as well so very useful for

00:25:40,860 --> 00:25:44,970
monitoring how much well what costs what

00:25:43,950 --> 00:25:47,700
client is using what

00:25:44,970 --> 00:25:49,350
how much usage for each client and what

00:25:47,700 --> 00:25:51,299
tables are being used which indexes are

00:25:49,350 --> 00:25:55,020
being used and which use cases and so

00:25:51,299 --> 00:26:06,330
forth so this is stuff you don't have in

00:25:55,020 --> 00:26:09,330
mysql you wish your app servers like

00:26:06,330 --> 00:26:12,059
what it's doing her so it's per the

00:26:09,330 --> 00:26:15,360
primary key for the client is the

00:26:12,059 --> 00:26:18,090
hostname if I'm remember correctly the

00:26:15,360 --> 00:26:20,220
the primary key for user is the user

00:26:18,090 --> 00:26:21,929
account in mysql and if i remember

00:26:20,220 --> 00:26:33,720
correctly the client it's the hostname

00:26:21,929 --> 00:26:34,860
its / hostname yes if so this index the

00:26:33,720 --> 00:26:37,110
district's table will tell you how many

00:26:34,860 --> 00:26:38,669
times each inch each index has been used

00:26:37,110 --> 00:26:40,950
so also if your index is never used you

00:26:38,669 --> 00:26:44,850
level 0 there so it's very useful as

00:26:40,950 --> 00:26:46,020
well of course you shouldn't start the

00:26:44,850 --> 00:26:49,530
server and look at this and remove

00:26:46,020 --> 00:26:53,520
indexes but after a few days right so

00:26:49,530 --> 00:26:58,380
these are fairly useful stuff other

00:26:53,520 --> 00:27:01,020
things need to be 52 virtual columns so

00:26:58,380 --> 00:27:03,240
it's it's kind of similar to well Anna

00:27:01,020 --> 00:27:05,880
it's basically creating a column as a

00:27:03,240 --> 00:27:07,230
function of well other columns or other

00:27:05,880 --> 00:27:09,210
things so you have a kind of a

00:27:07,230 --> 00:27:11,909
functional column you have a column in

00:27:09,210 --> 00:27:14,250
the table and the value of this column

00:27:11,909 --> 00:27:16,740
is based on some kind of functions and

00:27:14,250 --> 00:27:18,419
the other columns in the table and they

00:27:16,740 --> 00:27:20,010
can be either virtual or persistent

00:27:18,419 --> 00:27:21,330
which with the difference being of

00:27:20,010 --> 00:27:23,220
course persistence is actually stored

00:27:21,330 --> 00:27:27,570
and the virtual is calculated on the run

00:27:23,220 --> 00:27:31,559
and that's a fairly simple feature to

00:27:27,570 --> 00:27:33,860
add but it's been asked for for quite a

00:27:31,559 --> 00:27:33,860
few years

00:27:34,369 --> 00:27:40,710
yes yeah you don't have to worry about

00:27:36,989 --> 00:27:43,320
updating its update automatically so the

00:27:40,710 --> 00:27:44,879
persistent they're persistent and the

00:27:43,320 --> 00:27:53,940
virtual our car calculate when you

00:27:44,879 --> 00:27:57,389
access the columns yeah and the cool i

00:27:53,940 --> 00:27:58,559
mean the yeah okay i was going to say

00:27:57,389 --> 00:28:09,779
something but i'm a ton he wasn't sure

00:27:58,559 --> 00:28:10,679
so i'm not going to say it yeah like you

00:28:09,779 --> 00:28:16,710
knew you're gonna be constantly

00:28:10,679 --> 00:28:18,480
summoning the road you might if you're

00:28:16,710 --> 00:28:20,399
something feels in a row then yes for

00:28:18,480 --> 00:28:22,320
example so it this can be used for me in

00:28:20,399 --> 00:28:24,509
amount of you know a lot of things if

00:28:22,320 --> 00:28:26,399
you for some reason want to store I

00:28:24,509 --> 00:28:28,559
don't know host names in reverse order

00:28:26,399 --> 00:28:30,539
you can now store them in both you have

00:28:28,559 --> 00:28:31,980
them in the real real former and in

00:28:30,539 --> 00:28:35,369
Reverse as a function so you don't have

00:28:31,980 --> 00:28:36,960
to and we'd remove some some logic from

00:28:35,369 --> 00:28:38,429
the application layer and put it in the

00:28:36,960 --> 00:28:39,840
pretties in the database so it cannot

00:28:38,429 --> 00:28:42,600
kind of be useful depending on your

00:28:39,840 --> 00:28:44,220
youth cares man I mean pretty much all

00:28:42,600 --> 00:28:49,710
of this you could also use it do it on

00:28:44,220 --> 00:28:53,009
the fly in your application layer or

00:28:49,710 --> 00:28:55,139
exactly exactly exactly so I mean it's a

00:28:53,009 --> 00:28:57,080
cool feature but you don't have to use

00:28:55,139 --> 00:29:00,090
it right it's their users if you want

00:28:57,080 --> 00:29:03,299
another thing is the sting storage

00:29:00,090 --> 00:29:06,359
engine who knows what's things is three

00:29:03,299 --> 00:29:09,480
people okay things is a kind of a full

00:29:06,359 --> 00:29:12,179
text search so MySQL has full text

00:29:09,480 --> 00:29:16,889
search but it's only available for my

00:29:12,179 --> 00:29:19,909
eyes on and it sucks I mean frankly it's

00:29:16,889 --> 00:29:19,909
not very good right

00:29:25,370 --> 00:29:36,510
five six right yeah well so it's not

00:29:30,180 --> 00:29:38,430
there yet but anyway have six mess yeah

00:29:36,510 --> 00:29:40,110
so anyway but this was in december two

00:29:38,430 --> 00:29:42,810
thousand ten so we're talking two years

00:29:40,110 --> 00:29:47,040
ago and five sick is not out yet anyway

00:29:42,810 --> 00:29:48,360
so things well well the implementation

00:29:47,040 --> 00:29:50,430
of full text in dexter's in my ass and

00:29:48,360 --> 00:29:52,440
has sucked pretty much since it was

00:29:50,430 --> 00:29:54,360
there it was used in the beginning but

00:29:52,440 --> 00:29:57,330
but quite a lot of people who had heavy

00:29:54,360 --> 00:29:58,410
use for full-text searches regular that

00:29:57,330 --> 00:30:01,680
it wasn't good enough and they use

00:29:58,410 --> 00:30:06,360
something else things so thinks it's a

00:30:01,680 --> 00:30:08,460
full-text indexing utility so you you

00:30:06,360 --> 00:30:09,930
have it you use mysql and use things and

00:30:08,460 --> 00:30:11,880
then your full text search engines

00:30:09,930 --> 00:30:13,740
things and then you get back your

00:30:11,880 --> 00:30:14,910
results I mean a bit like key value

00:30:13,740 --> 00:30:17,100
store except that it's a full-text

00:30:14,910 --> 00:30:18,750
indexing store you get your results back

00:30:17,100 --> 00:30:21,060
and then you get the actual row from

00:30:18,750 --> 00:30:22,590
MySQL right so you need you need two

00:30:21,060 --> 00:30:24,110
steps you go things get the results and

00:30:22,590 --> 00:30:27,930
then you go to my school to get a row

00:30:24,110 --> 00:30:32,040
what they are in Moorea DB was access to

00:30:27,930 --> 00:30:33,720
things through the MySQL layer so you

00:30:32,040 --> 00:30:35,520
don't have to do two steps you don't

00:30:33,720 --> 00:30:37,710
have to first access things through a

00:30:35,520 --> 00:30:38,760
native Sphinx call and then go to mysql

00:30:37,710 --> 00:30:40,860
but you can access both through the

00:30:38,760 --> 00:30:42,930
MySQL calls and that's basically the

00:30:40,860 --> 00:30:45,810
idea so things looks like a storage

00:30:42,930 --> 00:30:47,850
engine and you access it with SQL it's a

00:30:45,810 --> 00:30:49,440
slightly modified version of SQL to

00:30:47,850 --> 00:30:53,940
access the Sphinx engine but you get

00:30:49,440 --> 00:30:55,500
results query result set and furthermore

00:30:53,940 --> 00:30:56,910
you can actually do joints between us

00:30:55,500 --> 00:30:59,490
things storage engine and the MySQL so

00:30:56,910 --> 00:31:02,010
you can do one query and use things as a

00:30:59,490 --> 00:31:06,150
full text engine and get the results in

00:31:02,010 --> 00:31:09,960
the same query yes the back end is still

00:31:06,150 --> 00:31:11,820
are actually things so I just you still

00:31:09,960 --> 00:31:14,210
have to install both and use both it's

00:31:11,820 --> 00:31:17,720
just that you have easier access to it

00:31:14,210 --> 00:31:19,070
11 point of access in stead of two

00:31:17,720 --> 00:31:21,260
connections to stings in your

00:31:19,070 --> 00:31:27,530
application you can reuse your existing

00:31:21,260 --> 00:31:29,720
must equal measure yes all right another

00:31:27,530 --> 00:31:31,760
thing added was to my segment in Maya

00:31:29,720 --> 00:31:32,600
some key cash pretty much no one uses my

00:31:31,760 --> 00:31:36,590
eyes and ears i'm not going to go

00:31:32,600 --> 00:31:38,870
through it but the idea is the key my

00:31:36,590 --> 00:31:40,730
verizon has a key cash and well there's

00:31:38,870 --> 00:31:43,400
one key cash which means that it's kind

00:31:40,730 --> 00:31:45,680
of a has a mutex which on multi-core

00:31:43,400 --> 00:31:48,560
systems becomes easily a bottleneck so

00:31:45,680 --> 00:31:51,530
now you can segment it into up to 64

00:31:48,560 --> 00:31:55,040
segments to be able to use multiple

00:31:51,530 --> 00:31:56,720
cores better he's a nice graph the guys

00:31:55,040 --> 00:31:58,940
have Maria did a pretty sincere pretty

00:31:56,720 --> 00:32:00,770
serious benchmarks with lots of

00:31:58,940 --> 00:32:02,330
different options I just show one of

00:32:00,770 --> 00:32:05,750
them but this is kind of the order of

00:32:02,330 --> 00:32:09,860
magnitude you can gain on a system with

00:32:05,750 --> 00:32:12,200
multiple cores and lots of threads but

00:32:09,860 --> 00:32:14,420
of course only these myosin II Madiba

00:32:12,200 --> 00:32:16,280
had similar problems and they did

00:32:14,420 --> 00:32:19,270
similar things to their inner d buffer

00:32:16,280 --> 00:32:24,500
pool as well but that's included in 55

00:32:19,270 --> 00:32:29,840
so both mysql and marietta v5 fun right

00:32:24,500 --> 00:32:35,630
then there was merely be 53 where they

00:32:29,840 --> 00:32:39,890
added quite a few other features so

00:32:35,630 --> 00:32:42,620
first of all some that you could call no

00:32:39,890 --> 00:32:46,540
SQL features so the first one is handler

00:32:42,620 --> 00:32:49,310
sockets and this is created by a

00:32:46,540 --> 00:32:52,640
japanese company or a Japanese guy we

00:32:49,310 --> 00:32:54,470
used to be a MySQL consultant basically

00:32:52,640 --> 00:32:57,200
channel circuit does is that it allows

00:32:54,470 --> 00:33:01,550
you to directly access in a divinity be

00:32:57,200 --> 00:33:06,740
engine so by passing the SQL layer in

00:33:01,550 --> 00:33:08,000
MySQL you know which can be good and can

00:33:06,740 --> 00:33:10,640
be bad the idea is that it would be

00:33:08,000 --> 00:33:12,050
faster to access it but the problem is

00:33:10,640 --> 00:33:14,420
that you can of course because since you

00:33:12,050 --> 00:33:15,920
the bypass the SQL layer you can't do

00:33:14,420 --> 00:33:19,450
complicated stuff you can do simple

00:33:15,920 --> 00:33:22,700
stuff so crude operations create replace

00:33:19,450 --> 00:33:26,000
update and delete so simple operations

00:33:22,700 --> 00:33:27,710
and you talk directly to the API so

00:33:26,000 --> 00:33:29,929
again this is very useful if you're

00:33:27,710 --> 00:33:32,149
running a lot of simple operation so

00:33:29,929 --> 00:33:33,980
kind of a batch of inserts or lots of

00:33:32,149 --> 00:33:35,330
operations on one table then this will

00:33:33,980 --> 00:33:43,190
be much faster than passing through the

00:33:35,330 --> 00:33:44,809
SQL layer well no it still has the story

00:33:43,190 --> 00:33:46,220
the storage is the same it's just a

00:33:44,809 --> 00:33:49,490
different access method you don't have

00:33:46,220 --> 00:33:51,139
to use SQL it's kind of it's still not

00:33:49,490 --> 00:33:52,909
another scale is still a database acid

00:33:51,139 --> 00:33:55,029
fully acid and all that stuff it's just

00:33:52,909 --> 00:33:57,950
that you access it through a simplified

00:33:55,029 --> 00:33:59,779
API so just access method that's

00:33:57,950 --> 00:34:01,700
different which removes some of the

00:33:59,779 --> 00:34:03,019
layers like you know key cache

00:34:01,700 --> 00:34:05,629
invalidation whatever you would have

00:34:03,019 --> 00:34:07,970
there in MySQL so it makes it faster but

00:34:05,629 --> 00:34:10,879
I mean it's marginally faster so it's

00:34:07,970 --> 00:34:12,500
not going to it's not like oh you should

00:34:10,879 --> 00:34:14,720
instead of using SQL you should write

00:34:12,500 --> 00:34:16,490
everything in this no it's specific

00:34:14,720 --> 00:34:19,010
types of operations where it might make

00:34:16,490 --> 00:34:20,929
sense like small operations and large

00:34:19,010 --> 00:34:27,919
batches of these small operations in one

00:34:20,929 --> 00:34:32,929
go another cool feature maybe 53 is

00:34:27,919 --> 00:34:36,950
dynamic columns basically dynamic

00:34:32,929 --> 00:34:39,169
columns is is kind of like now we're

00:34:36,950 --> 00:34:45,049
coming close to like a document store it

00:34:39,169 --> 00:34:49,069
allows you to store attributes in a

00:34:45,049 --> 00:34:50,990
column where basically for each row you

00:34:49,069 --> 00:34:53,750
decide which attributes apply to this

00:34:50,990 --> 00:34:57,200
row so it's kind of I guess like an

00:34:53,750 --> 00:34:58,760
array or something but but you define

00:34:57,200 --> 00:35:00,650
yourself how many attributes will this

00:34:58,760 --> 00:35:03,940
row have so basically create a blob okay

00:35:00,650 --> 00:35:08,299
I'll show an example you create a blob

00:35:03,940 --> 00:35:10,400
here's a table we have a blob and then

00:35:08,299 --> 00:35:12,680
we use functions to access stuff inside

00:35:10,400 --> 00:35:17,780
the blob and its functions allow us to

00:35:12,680 --> 00:35:19,640
to define attributes and give them

00:35:17,780 --> 00:35:23,480
values so for example that tributes have

00:35:19,640 --> 00:35:25,250
numbers so at the moment we only see

00:35:23,480 --> 00:35:27,650
three different attributes but you could

00:35:25,250 --> 00:35:32,720
have any any amount of attributes and

00:35:27,650 --> 00:35:35,510
then each row can have any number of

00:35:32,720 --> 00:35:37,099
these attributes right so for example

00:35:35,510 --> 00:35:40,549
here we have some kind of store web

00:35:37,099 --> 00:35:42,700
store and basically each row correspond

00:35:40,549 --> 00:35:45,110
to corresponds to a product

00:35:42,700 --> 00:35:48,470
but because we sell pretty much

00:35:45,110 --> 00:35:51,380
everything not all attributes will apply

00:35:48,470 --> 00:35:53,420
to all products so for example we have

00:35:51,380 --> 00:35:55,280
one attribute desc that corresponds to

00:35:53,420 --> 00:35:57,590
color not virtue with number one is the

00:35:55,280 --> 00:35:59,770
color of the product well pretty much

00:35:57,590 --> 00:36:02,150
all of our products we have a color so

00:35:59,770 --> 00:36:05,690
every row be insured will have some

00:36:02,150 --> 00:36:07,610
value for attribute one however the

00:36:05,690 --> 00:36:10,910
second attribute not at with number 10

00:36:07,610 --> 00:36:13,730
is size and well only the clothes will

00:36:10,910 --> 00:36:15,350
have a size a size then we have one

00:36:13,730 --> 00:36:17,570
attribute which is the operating system

00:36:15,350 --> 00:36:18,770
and well the t-shirts won't have an

00:36:17,570 --> 00:36:20,870
operating system so they will have no

00:36:18,770 --> 00:36:25,940
entry for for this attribute and so

00:36:20,870 --> 00:36:27,770
forth so it allows you to have a huge

00:36:25,940 --> 00:36:30,500
amounts of different attributes per row

00:36:27,770 --> 00:36:33,850
without creating a table with a huge

00:36:30,500 --> 00:36:39,440
amount of columns so it's close to a

00:36:33,850 --> 00:36:40,990
document store I guess and you can then

00:36:39,440 --> 00:36:42,920
access these values through these

00:36:40,990 --> 00:36:44,180
functions column lists and there are

00:36:42,920 --> 00:36:46,820
other functions for accessing stuff

00:36:44,180 --> 00:36:51,440
accessing the Israel get column and

00:36:46,820 --> 00:36:54,110
stuff right so here we've created this

00:36:51,440 --> 00:36:56,660
table we've inserted these rows and that

00:36:54,110 --> 00:36:59,420
we can do searches for example okay give

00:36:56,660 --> 00:37:01,820
me all the products where the color is

00:36:59,420 --> 00:37:04,550
black and we find all the product with

00:37:01,820 --> 00:37:09,200
color black because attribute one was

00:37:04,550 --> 00:37:11,420
color and well okay the other example is

00:37:09,200 --> 00:37:13,220
just give me all the different colors in

00:37:11,420 --> 00:37:14,720
the table but so you can do any type of

00:37:13,220 --> 00:37:18,650
search you just have to define okay

00:37:14,720 --> 00:37:22,020
which attribute am I am I looking for

00:37:18,650 --> 00:37:26,040
and what the one is attribute to be

00:37:22,020 --> 00:37:31,200
you're in a dream texts online it's

00:37:26,040 --> 00:37:34,140
integers only but the what you store I

00:37:31,200 --> 00:37:35,730
mean here we store strings but in theory

00:37:34,140 --> 00:37:37,650
you could soar anything but because it's

00:37:35,730 --> 00:37:39,300
a blood back end is a blob so you couldn

00:37:37,650 --> 00:37:44,910
t restore anything with your restoring

00:37:39,300 --> 00:37:46,170
strings well actually decides what what

00:37:44,910 --> 00:37:55,500
would in terms it was a string as well

00:37:46,170 --> 00:37:57,720
as well so if you want to do that then

00:37:55,500 --> 00:37:59,520
you create a lookup table and you're

00:37:57,720 --> 00:38:14,340
close to actually having a database real

00:37:59,520 --> 00:38:15,960
database so I mean you know if you you

00:38:14,340 --> 00:38:18,210
gettin all our empty string I can't

00:38:15,960 --> 00:38:24,030
remember can you remember Daniel no it's

00:38:18,210 --> 00:38:27,150
not our empty string I'm not sure no at

00:38:24,030 --> 00:38:29,940
least not at the moment so you can't

00:38:27,150 --> 00:38:31,500
index the the you mean that reviews

00:38:29,940 --> 00:38:45,360
inside the corner you can't pin clicks

00:38:31,500 --> 00:38:49,950
and which ones I mean you mean how

00:38:45,360 --> 00:38:52,140
creating this at all so so so if you

00:38:49,950 --> 00:38:54,270
could table for this the problem is if

00:38:52,140 --> 00:38:56,580
you have a wide diversity of products

00:38:54,270 --> 00:38:57,750
and you have the attributes depend on

00:38:56,580 --> 00:39:01,050
the product you have to either create

00:38:57,750 --> 00:39:02,370
different table / product right so you

00:39:01,050 --> 00:39:05,340
would put all your phones in one table

00:39:02,370 --> 00:39:06,930
or your t-shirts in one table or you

00:39:05,340 --> 00:39:08,610
care the table with lots of columns were

00:39:06,930 --> 00:39:12,360
most are not used which is not very

00:39:08,610 --> 00:39:14,400
optimal or you use an anchor schema kind

00:39:12,360 --> 00:39:15,930
of style where you have a highly normal

00:39:14,400 --> 00:39:20,570
those are kind of the three options you

00:39:15,930 --> 00:39:23,840
have most web companies would use

00:39:20,570 --> 00:39:24,950
a a document store for this instead of

00:39:23,840 --> 00:39:26,360
even it wouldn't even look at this

00:39:24,950 --> 00:39:28,550
because it's easier to use of document

00:39:26,360 --> 00:39:30,290
so but this is kind of the SQL version

00:39:28,550 --> 00:39:32,060
of a document store kind of gives you

00:39:30,290 --> 00:39:35,300
the flexibility of a document store

00:39:32,060 --> 00:39:36,440
while still having SQL and then being

00:39:35,300 --> 00:39:43,700
able to combine it with actual

00:39:36,440 --> 00:39:45,440
relational stuff so that's a neat

00:39:43,700 --> 00:39:52,870
feature i don't know how used it is so

00:39:45,440 --> 00:39:52,870
far but yeah it's official yep

00:39:56,040 --> 00:40:05,410
sorry no I mean it's like a documents so

00:40:04,540 --> 00:40:07,150
the question is whether this is

00:40:05,410 --> 00:40:08,950
efficient then answer is no it's like a

00:40:07,150 --> 00:40:10,510
document store you don't index what's in

00:40:08,950 --> 00:40:15,810
the documents are either inside the

00:40:10,510 --> 00:40:18,370
vehicle right yeah it's no SQL like

00:40:15,810 --> 00:40:20,920
right it's not if you want it to be

00:40:18,370 --> 00:40:23,490
indexable and really fast then you do

00:40:20,920 --> 00:40:27,700
the anchor schema and then you can do it

00:40:23,490 --> 00:40:30,360
can you next these things you mean like

00:40:27,700 --> 00:40:35,380
an attribute eNOS no not at the moment

00:40:30,360 --> 00:40:41,350
no I don't think so I don't think so but

00:40:35,380 --> 00:40:43,780
I haven't tried it so I don't know some

00:40:41,350 --> 00:40:46,510
answer is I don't think so feel free to

00:40:43,780 --> 00:40:56,650
try it and let me know what the results

00:40:46,510 --> 00:41:01,620
are all right where am i right so still

00:40:56,650 --> 00:41:05,020
on my 53 some other features added a few

00:41:01,620 --> 00:41:08,740
replication enhancements so one actually

00:41:05,020 --> 00:41:11,400
pretty cool things who knows about who

00:41:08,740 --> 00:41:13,900
knows about the binary log in mysql

00:41:11,400 --> 00:41:19,180
quite a few people who knows about the

00:41:13,900 --> 00:41:21,790
different format of the binary log ok so

00:41:19,180 --> 00:41:23,230
the binary log can be the content of the

00:41:21,790 --> 00:41:26,110
binary log can be stored in two formats

00:41:23,230 --> 00:41:29,440
right you can store statements or row

00:41:26,110 --> 00:41:30,430
images so the binary log by the way for

00:41:29,440 --> 00:41:36,190
those who don't know what it is it's

00:41:30,430 --> 00:41:38,350
it's kind of redo log or or or it's a

00:41:36,190 --> 00:41:40,420
redo log of all statements that change

00:41:38,350 --> 00:41:42,730
stuff on the server right so if I do an

00:41:40,420 --> 00:41:44,140
update the changes of this update will

00:41:42,730 --> 00:41:45,880
be stored in the log so i can later use

00:41:44,140 --> 00:41:47,290
it is used for replication we could also

00:41:45,880 --> 00:41:52,330
be used for incremental backups and

00:41:47,290 --> 00:41:54,220
stuff like that so in mysql i can choose

00:41:52,330 --> 00:41:56,320
whether to store the statements so if i

00:41:54,220 --> 00:41:58,780
make an update I store the update in

00:41:56,320 --> 00:42:01,360
text format well it's actually in binary

00:41:58,780 --> 00:42:02,740
format but it's it reverts to a text

00:42:01,360 --> 00:42:06,430
format so I store the actual update

00:42:02,740 --> 00:42:08,800
statement and this is

00:42:06,430 --> 00:42:09,760
good and all except for the fact that

00:42:08,800 --> 00:42:11,500
there are there are quite a few

00:42:09,760 --> 00:42:13,540
statements that are non deterministic

00:42:11,500 --> 00:42:16,300
right so have a statement to use

00:42:13,540 --> 00:42:18,849
functions the funk the result of the

00:42:16,300 --> 00:42:21,280
function depends on conditions on the

00:42:18,849 --> 00:42:22,540
server so if I rerun the query later if

00:42:21,280 --> 00:42:25,599
you actually produce a different result

00:42:22,540 --> 00:42:27,099
and because the idea with the binary log

00:42:25,599 --> 00:42:29,200
is to be able to use it for application

00:42:27,099 --> 00:42:32,500
under backups I want the results to be

00:42:29,200 --> 00:42:34,480
the same every time I run the query so

00:42:32,500 --> 00:42:36,550
in mysql traditionally we only have

00:42:34,480 --> 00:42:39,250
statements so we've used a lot of weird

00:42:36,550 --> 00:42:41,140
fixes to do this we had like set

00:42:39,250 --> 00:42:42,940
timestamp before so we fool the server

00:42:41,140 --> 00:42:44,650
thing that it was actually this time we

00:42:42,940 --> 00:42:47,410
execute the query we go back to normal

00:42:44,650 --> 00:42:49,809
time and stuff like that but it's

00:42:47,410 --> 00:42:51,400
impossible to catch every single non

00:42:49,809 --> 00:42:52,690
deterministic function and you can have

00:42:51,400 --> 00:42:55,540
your own functions and stuff like that

00:42:52,690 --> 00:42:58,210
so instead of worrying about this the

00:42:55,540 --> 00:42:59,790
row based format was introduced so

00:42:58,210 --> 00:43:04,240
instead of storing the update statement

00:42:59,790 --> 00:43:05,680
for every single row we store the image

00:43:04,240 --> 00:43:07,569
of the row before the change and the

00:43:05,680 --> 00:43:08,980
image of the row after the change so we

00:43:07,569 --> 00:43:10,390
don't worry about which statement

00:43:08,980 --> 00:43:11,980
actually caused this change or we care

00:43:10,390 --> 00:43:14,650
about this this is how to roll looked

00:43:11,980 --> 00:43:16,780
this is how it now should look so it's

00:43:14,650 --> 00:43:18,549
completely deterministic we don't care

00:43:16,780 --> 00:43:23,319
about the function right so this was

00:43:18,549 --> 00:43:24,640
introduced in Moscow 51 and it well of

00:43:23,319 --> 00:43:25,960
course had a few bugs initially but

00:43:24,640 --> 00:43:28,000
eventually it's fairly it was very

00:43:25,960 --> 00:43:30,490
stable but then we started getting

00:43:28,000 --> 00:43:34,000
complaints from customer like all right

00:43:30,490 --> 00:43:36,819
so I had a guy who who didn't delete and

00:43:34,000 --> 00:43:38,950
now I want to you know restore from

00:43:36,819 --> 00:43:40,839
backup stew and not do this delete and

00:43:38,950 --> 00:43:44,079
I'm looking at this robust binary log

00:43:40,839 --> 00:43:46,359
and well it's all raw images I can't

00:43:44,079 --> 00:43:47,859
find the delete so that was kind of a

00:43:46,359 --> 00:43:50,559
problem because you didn't get the

00:43:47,859 --> 00:43:52,359
statement anymore and again it's very

00:43:50,559 --> 00:43:54,490
simple thing it was asked by customers

00:43:52,359 --> 00:43:57,760
so basically what what really be what

00:43:54,490 --> 00:43:59,559
did was the DHing introduced the also

00:43:57,760 --> 00:44:01,059
story statement but in a commented

00:43:59,559 --> 00:44:03,460
fashion so it will not be used however

00:44:01,059 --> 00:44:06,760
you can actually now search for this

00:44:03,460 --> 00:44:11,160
statement inside the binary log so

00:44:06,760 --> 00:44:15,240
that's a simple but useful feature and

00:44:11,160 --> 00:44:19,130
some other features about replication

00:44:15,240 --> 00:44:23,230
some extensions to open GIS and so forth

00:44:19,130 --> 00:44:26,000
another really really cool feature again

00:44:23,230 --> 00:44:28,340
does anyone know you know alter tables

00:44:26,000 --> 00:44:29,960
right in mysql if you do an altar table

00:44:28,340 --> 00:44:32,210
first of all the first thing to know is

00:44:29,960 --> 00:44:36,470
that there the performance of an altar

00:44:32,210 --> 00:44:39,620
table in Moscow is as low as it can be

00:44:36,470 --> 00:44:40,850
right so the first tip my school does

00:44:39,620 --> 00:44:43,340
when you do an altar table is all right

00:44:40,850 --> 00:44:45,320
let's lock everything let's create a new

00:44:43,340 --> 00:44:47,480
table and let's copy everything from the

00:44:45,320 --> 00:44:49,580
old to the new table independently of

00:44:47,480 --> 00:44:51,050
what you alter table actually does even

00:44:49,580 --> 00:44:54,080
if it just says all right I want to

00:44:51,050 --> 00:44:55,730
change the name of a column we still do

00:44:54,080 --> 00:44:58,070
a copy of everything right you have a

00:44:55,730 --> 00:44:59,630
table with 10 gigs of data it's going to

00:44:58,070 --> 00:45:00,980
take a while to copy the table right and

00:44:59,630 --> 00:45:03,620
your table will be locked during this

00:45:00,980 --> 00:45:08,570
operation so all the tables in mysql are

00:45:03,620 --> 00:45:11,600
slow but Pauline number two is when you

00:45:08,570 --> 00:45:13,370
do an altar table in mysql you know that

00:45:11,600 --> 00:45:15,410
slow but you know how slow it is right

00:45:13,370 --> 00:45:18,650
so you want to do an altar table you do

00:45:15,410 --> 00:45:23,030
it and after 10 minutes you like there

00:45:18,650 --> 00:45:25,070
hmm it's not done yet however if my

00:45:23,030 --> 00:45:26,720
statement will only take 11 minutes and

00:45:25,070 --> 00:45:28,010
I'm already done 10 I shouldn't I

00:45:26,720 --> 00:45:31,250
shouldn't cancer it now right so you

00:45:28,010 --> 00:45:33,590
wait okay wait then it's 30 minutes like

00:45:31,250 --> 00:45:35,540
all right 30 minutes I have to cancel it

00:45:33,590 --> 00:45:38,900
now but what if it's 33 and I'm so close

00:45:35,540 --> 00:45:40,670
and I cancel it so you start with a

00:45:38,900 --> 00:45:44,390
dilemma when should you cancel and stuff

00:45:40,670 --> 00:45:45,950
like that well in Moorea db5 three we

00:45:44,390 --> 00:45:48,290
actually introduced or they include a

00:45:45,950 --> 00:45:50,030
progress report for out the table so you

00:45:48,290 --> 00:45:53,900
don't you will actually know how much

00:45:50,030 --> 00:45:56,330
how big a big how much of the other

00:45:53,900 --> 00:45:58,190
table is actually done so you get it

00:45:56,330 --> 00:45:59,960
first of all on the command line so if

00:45:58,190 --> 00:46:01,970
you do it in the client you actually get

00:45:59,960 --> 00:46:06,110
on the command line you get the

00:46:01,970 --> 00:46:07,940
percentage of of the operation and you

00:46:06,110 --> 00:46:10,070
also get it in the process list so if

00:46:07,940 --> 00:46:11,960
you look at the process list you

00:46:10,070 --> 00:46:14,030
actually see the progress for our table

00:46:11,960 --> 00:46:16,730
statement so now you wait your 10

00:46:14,030 --> 00:46:18,770
minutes and you look at your processes

00:46:16,730 --> 00:46:20,330
all right I've only done five percent so

00:46:18,770 --> 00:46:22,940
you can extrapolate okay it's going to

00:46:20,330 --> 00:46:24,230
be 20 times ten minutes this statement

00:46:22,940 --> 00:46:26,300
so now you know okay should you cancel

00:46:24,230 --> 00:46:28,430
the statement or wait for it to complete

00:46:26,300 --> 00:46:31,540
so that's a pretty cool feature I mean

00:46:28,430 --> 00:46:31,540
DBA is a scries feature

00:46:36,950 --> 00:46:41,400
it's pretty much immediate because the

00:46:39,240 --> 00:46:43,230
so what it does the off the table so it

00:46:41,400 --> 00:46:44,340
it first of all it locks everything so

00:46:43,230 --> 00:46:48,360
no one can write to the table while

00:46:44,340 --> 00:46:50,280
you're doing this so so everything data

00:46:48,360 --> 00:46:52,590
is still there and then it has their it

00:46:50,280 --> 00:46:53,880
creates a copy with off the tail I mean

00:46:52,590 --> 00:46:56,400
it creates a new table with the new

00:46:53,880 --> 00:46:58,770
format and then it's not copying copying

00:46:56,400 --> 00:47:00,270
data from the old to the new table so

00:46:58,770 --> 00:47:06,060
the old table is constantly there and it

00:47:00,270 --> 00:47:10,410
never changes the old table so now it's

00:47:06,060 --> 00:47:16,620
the same altar table is as bad as Maria

00:47:10,410 --> 00:47:17,640
as in MySQL yes as bad it's just that

00:47:16,620 --> 00:47:21,860
you get a progress report that's the

00:47:17,640 --> 00:47:21,860
only difference yeah

00:47:31,110 --> 00:47:36,280
is that a question its honor questions I

00:47:33,610 --> 00:47:43,500
can't repeat it it's a state it's a safe

00:47:36,280 --> 00:47:46,960
manner all right thank you for that and

00:47:43,500 --> 00:47:50,680
then they induce quite a few optimizer

00:47:46,960 --> 00:47:52,030
enhancement in my school 53 I don't have

00:47:50,680 --> 00:47:54,640
time to actually talk about all of these

00:47:52,030 --> 00:47:58,690
but i'll just mention so number one is

00:47:54,640 --> 00:48:02,530
sub query optimization so my subway is

00:47:58,690 --> 00:48:03,910
introduced to mysql 41 and you know it

00:48:02,530 --> 00:48:05,440
doesn't feature everyone was sitting

00:48:03,910 --> 00:48:07,720
over my square it's not a real database

00:48:05,440 --> 00:48:09,640
they don't have sub queries right so

00:48:07,720 --> 00:48:11,470
something that my school had to

00:48:09,640 --> 00:48:13,750
introduce so we put sub queries they're

00:48:11,470 --> 00:48:15,550
good check box top queries done we have

00:48:13,750 --> 00:48:17,800
them we were all great chefs upgrade

00:48:15,550 --> 00:48:20,200
should be used and we gardener the

00:48:17,800 --> 00:48:23,620
performance is abysmal and it was

00:48:20,200 --> 00:48:26,470
abysmal so the sub queries in mysql well

00:48:23,620 --> 00:48:29,200
up to mariadb 53 perform really badly

00:48:26,470 --> 00:48:30,550
and what everyone knew that's because we

00:48:29,200 --> 00:48:32,080
were honest we told people i mean if

00:48:30,550 --> 00:48:36,670
don'ts please don't use software that

00:48:32,080 --> 00:48:38,860
there but please don't use them however

00:48:36,670 --> 00:48:41,200
of course some people still use them and

00:48:38,860 --> 00:48:43,480
would complain about the performance and

00:48:41,200 --> 00:48:45,340
and also if you use middle layers they

00:48:43,480 --> 00:48:49,030
might actually have sub queries there

00:48:45,340 --> 00:48:50,830
and they would just be bad so maybe

00:48:49,030 --> 00:48:54,640
being used a lot of sub query

00:48:50,830 --> 00:48:55,900
optimizations number one is well just to

00:48:54,640 --> 00:48:57,460
go through this briefly number one is

00:48:55,900 --> 00:49:00,250
that if the subway can be rewritten to

00:48:57,460 --> 00:49:02,800
join it will actually be written to join

00:49:00,250 --> 00:49:04,990
by the optimizer and perform like a

00:49:02,800 --> 00:49:07,380
joint that was the number one thing we

00:49:04,990 --> 00:49:10,060
used to say to customers back in the day

00:49:07,380 --> 00:49:12,130
don't ever use sub-queries use joins if

00:49:10,060 --> 00:49:13,270
you can right now you don't have to

00:49:12,130 --> 00:49:16,840
worry about it because the optimizer

00:49:13,270 --> 00:49:19,000
will do it for you another thing is if

00:49:16,840 --> 00:49:20,440
you have non-correlated inquiry Eve

00:49:19,000 --> 00:49:22,120
actually materialize the result instead

00:49:20,440 --> 00:49:25,030
of react securing the result each time

00:49:22,120 --> 00:49:27,250
and there's also some quick cash so the

00:49:25,030 --> 00:49:29,470
subway actually has a cash instead of

00:49:27,250 --> 00:49:29,890
having to reiax acute each time you have

00:49:29,470 --> 00:49:32,230
a cash

00:49:29,890 --> 00:49:34,750
we can access all right I'm running out

00:49:32,230 --> 00:49:36,940
of time so they added some joint

00:49:34,750 --> 00:49:39,550
algorithms as well traditional my skill

00:49:36,940 --> 00:49:44,950
only has nested loop joints and Maria BB

00:49:39,550 --> 00:49:46,540
has added a few more and yeah all right

00:49:44,950 --> 00:49:50,290
I'm not going to go through is some

00:49:46,540 --> 00:49:54,730
other optimizations for dr tables this

00:49:50,290 --> 00:49:57,580
is also sub-query so if you have a table

00:49:54,730 --> 00:50:01,600
like in the from clause there's

00:49:57,580 --> 00:50:04,180
optimizations for making this faster so

00:50:01,600 --> 00:50:06,670
basically if the table in the from

00:50:04,180 --> 00:50:09,340
clause is mirja below basically we do

00:50:06,670 --> 00:50:11,260
with the main query it's actually merge

00:50:09,340 --> 00:50:13,030
merge into one query process like one

00:50:11,260 --> 00:50:15,490
query instead of first executing the

00:50:13,030 --> 00:50:17,020
drive stable and then the other and a

00:50:15,490 --> 00:50:18,880
second optimization is that you can

00:50:17,020 --> 00:50:21,520
actually have an index so if you cannot

00:50:18,880 --> 00:50:22,570
merge the two tables you have to first

00:50:21,520 --> 00:50:25,210
create a temporary table with the

00:50:22,570 --> 00:50:26,590
results of the first query the optimizer

00:50:25,210 --> 00:50:28,300
can choose the create an index on this

00:50:26,590 --> 00:50:30,070
temporary table and then use this index

00:50:28,300 --> 00:50:32,440
when the results are merged so another

00:50:30,070 --> 00:50:35,620
thing and then if you disk access

00:50:32,440 --> 00:50:38,850
optimizations index condition push down

00:50:35,620 --> 00:50:41,740
so basically if you have where clause

00:50:38,850 --> 00:50:44,560
you can I that's not on an index you can

00:50:41,740 --> 00:50:46,630
actually push it down to the two to your

00:50:44,560 --> 00:50:48,610
index asset access algorithm so instead

00:50:46,630 --> 00:50:50,650
of retrieving all the rows first with

00:50:48,610 --> 00:50:52,360
with the index and then filtering them

00:50:50,650 --> 00:50:54,700
on the additional where clause you're

00:50:52,360 --> 00:50:56,740
going to filter them already when you're

00:50:54,700 --> 00:50:58,300
looking through the index which for

00:50:56,740 --> 00:51:00,930
queries where you get a huge result set

00:50:58,300 --> 00:51:04,440
from the index look up this is useful

00:51:00,930 --> 00:51:08,610
anthem others and I don't have time

00:51:04,440 --> 00:51:13,180
another big feature this group commit

00:51:08,610 --> 00:51:21,820
and this perhaps the number one kind of

00:51:13,180 --> 00:51:26,980
performance feature for Maria DB so so

00:51:21,820 --> 00:51:31,150
groove commit basically this is innodb

00:51:26,980 --> 00:51:33,790
here so just tell you the background for

00:51:31,150 --> 00:51:36,340
group commit so basically you know DB

00:51:33,790 --> 00:51:38,200
has stuff stored on disk right there's a

00:51:36,340 --> 00:51:39,760
buffer things are in the memory and of

00:51:38,200 --> 00:51:43,210
course when you do transactions you work

00:51:39,760 --> 00:51:45,010
on the memory part right the problem is

00:51:43,210 --> 00:51:46,810
that when you commit this has to be

00:51:45,010 --> 00:51:50,830
durables if you have a server crash the

00:51:46,810 --> 00:51:53,200
changes have to be durable so flushing

00:51:50,830 --> 00:51:54,610
your buffer buffers to disk will take a

00:51:53,200 --> 00:51:56,320
lot of time because you know you have

00:51:54,610 --> 00:51:58,300
lots of data blocks and stuff so instead

00:51:56,320 --> 00:52:00,450
of doing that what you do is you have a

00:51:58,300 --> 00:52:03,070
redo log so you keep your transaction

00:52:00,450 --> 00:52:04,720
you keep a log of your transaction

00:52:03,070 --> 00:52:06,810
changes and instead of flushing the

00:52:04,720 --> 00:52:09,310
actual changes this you just flash your

00:52:06,810 --> 00:52:13,180
redo log to disk so every time you

00:52:09,310 --> 00:52:15,880
commit a transaction in innodb it has to

00:52:13,180 --> 00:52:19,360
flush the log discs to make sure that if

00:52:15,880 --> 00:52:21,220
there's a crash even though the data on

00:52:19,360 --> 00:52:22,900
disk does not contain these changes we

00:52:21,220 --> 00:52:24,490
can actually reproduce these changes by

00:52:22,900 --> 00:52:28,570
going through the video log and that's

00:52:24,490 --> 00:52:33,670
how how innodb achieves durability said

00:52:28,570 --> 00:52:36,940
in very few sentences all right but then

00:52:33,670 --> 00:52:39,850
there's a second thing the famous binary

00:52:36,940 --> 00:52:42,790
log right because the binary log

00:52:39,850 --> 00:52:44,770
contains all the changes that we do due

00:52:42,790 --> 00:52:46,630
to the to the data we have to make sure

00:52:44,770 --> 00:52:49,750
that the what's in the binary log is

00:52:46,630 --> 00:52:54,000
soon what's on the disk right so if you

00:52:49,750 --> 00:52:56,590
do a commit it's not enough to to flush

00:52:54,000 --> 00:52:59,650
the video to disk we also have to flush

00:52:56,590 --> 00:53:02,440
the binary log to describe because in

00:52:59,650 --> 00:53:04,360
order for this final log to be useful if

00:53:02,440 --> 00:53:05,560
you have a crush and we recover they

00:53:04,360 --> 00:53:07,240
have to match the binder work has to

00:53:05,560 --> 00:53:10,420
match was on in the dead otherwise of

00:53:07,240 --> 00:53:11,620
course it's not useful anymore so we

00:53:10,420 --> 00:53:14,920
have to make sure these are synchronized

00:53:11,620 --> 00:53:16,180
and this basically causes it's a long

00:53:14,920 --> 00:53:17,830
story of how it's actually done you have

00:53:16,180 --> 00:53:19,120
to prepare and make sure we have to make

00:53:17,830 --> 00:53:20,650
sure that you don't think one and not

00:53:19,120 --> 00:53:22,900
the other because then they're not in

00:53:20,650 --> 00:53:24,550
sync right so basically it boils down to

00:53:22,900 --> 00:53:27,860
approximately 3 f's links per

00:53:24,550 --> 00:53:29,970
transaction right

00:53:27,860 --> 00:53:32,940
this means that if you have a system

00:53:29,970 --> 00:53:36,150
that I are based I mean I oh I oh is

00:53:32,940 --> 00:53:38,880
your performance limit I about thank you

00:53:36,150 --> 00:53:41,610
I'm losing my words here so if you have

00:53:38,880 --> 00:53:42,630
an i/o bound system you want to do

00:53:41,610 --> 00:53:43,860
something this is the problem right

00:53:42,630 --> 00:53:46,350
because you have to do for each one's

00:53:43,860 --> 00:53:48,450
actually have to do 3 f things so and

00:53:46,350 --> 00:53:51,930
the group quick feature what it does is

00:53:48,450 --> 00:53:54,480
that it groups multiple transaction

00:53:51,930 --> 00:53:57,210
commits that are waiting to be soon it

00:53:54,480 --> 00:54:00,360
group limbs together as one operation

00:53:57,210 --> 00:54:02,760
and that's basically what it does not

00:54:00,360 --> 00:54:04,640
beauty and there's been many

00:54:02,760 --> 00:54:09,600
implementations of of group commit

00:54:04,640 --> 00:54:11,930
facebook did a few Maria BB did one the

00:54:09,600 --> 00:54:16,620
facebook version did not perform as well

00:54:11,930 --> 00:54:19,470
he is actually a he is actually

00:54:16,620 --> 00:54:22,350
Facebook's benchmark so they made their

00:54:19,470 --> 00:54:24,510
own patch this is MySQL with no group

00:54:22,350 --> 00:54:25,830
commit right so normally it's not a

00:54:24,510 --> 00:54:27,210
problem until you start having lots of

00:54:25,830 --> 00:54:29,190
concurrent transactions right so here's

00:54:27,210 --> 00:54:32,030
the number of threads is the x-axis and

00:54:29,190 --> 00:54:36,510
the commits per second is is the y-axis

00:54:32,030 --> 00:54:40,950
so Facebook made a patch the performance

00:54:36,510 --> 00:54:42,900
was far below the mega DB patch the

00:54:40,950 --> 00:54:45,870
Facebook made another patch which is not

00:54:42,900 --> 00:54:47,400
on this graph it was somewhere here so

00:54:45,870 --> 00:54:49,800
still far below my really be and that's

00:54:47,400 --> 00:54:51,240
after that Facebook stopped making their

00:54:49,800 --> 00:54:53,700
own patch and said okay we'll use Maria

00:54:51,240 --> 00:54:55,770
be so Facebook actually they don't use

00:54:53,700 --> 00:54:58,920
my ID be but they use the group commit

00:54:55,770 --> 00:55:00,390
feature from rarity right and well

00:54:58,920 --> 00:55:02,460
actually the MySQL team is now also

00:55:00,390 --> 00:55:04,200
working on their on their own

00:55:02,460 --> 00:55:06,750
implementation of a group commit feature

00:55:04,200 --> 00:55:08,400
but it's just been released in our labs

00:55:06,750 --> 00:55:11,010
version so I haven't seen any benchmarks

00:55:08,400 --> 00:55:13,530
comparing these but but this has been GA

00:55:11,010 --> 00:55:16,610
for a while already so it's out there

00:55:13,530 --> 00:55:20,970
already p53 and Marie to be 55 has this

00:55:16,610 --> 00:55:23,400
feature so if you're I are bound well

00:55:20,970 --> 00:55:25,570
this can improve your system quite a bit

00:55:23,400 --> 00:55:31,870
if you look at the difference here

00:55:25,570 --> 00:55:33,400
you go from yes of course normally if

00:55:31,870 --> 00:55:34,780
you're I want your right our bond

00:55:33,400 --> 00:55:36,640
because the Reeves you don't have to

00:55:34,780 --> 00:55:38,530
actually you can actually use the

00:55:36,640 --> 00:55:40,870
buffers right you don't need to read

00:55:38,530 --> 00:55:43,480
from disk well depending on your side

00:55:40,870 --> 00:55:46,840
yeah okay I guess depending on the size

00:55:43,480 --> 00:55:48,750
and all that stuff here but I mean let's

00:55:46,840 --> 00:55:51,820
say most of many of our web customers

00:55:48,750 --> 00:55:54,040
make sure that the RAM is as big as

00:55:51,820 --> 00:55:55,420
their what they have on disk I mean of

00:55:54,040 --> 00:55:57,490
course that doesn't apply to all

00:55:55,420 --> 00:55:59,800
customers and you know data warehouses

00:55:57,490 --> 00:56:01,720
and stuff it's impossible but we have a

00:55:59,800 --> 00:56:04,450
lot of web customers that prefer

00:56:01,720 --> 00:56:06,820
charting their data so that on every

00:56:04,450 --> 00:56:08,980
machine it will fit in memory what the

00:56:06,820 --> 00:56:12,550
app but you still have to write of

00:56:08,980 --> 00:56:19,600
course all all your rights to disk all

00:56:12,550 --> 00:56:21,190
right so I'm really be 55 includes

00:56:19,600 --> 00:56:23,080
everything we've seen so far plus a few

00:56:21,190 --> 00:56:24,850
other feature but not nothing really

00:56:23,080 --> 00:56:27,910
major the one major feature is the

00:56:24,850 --> 00:56:30,460
rewrite off off the thread pool right

00:56:27,910 --> 00:56:32,230
because because the closed source

00:56:30,460 --> 00:56:34,800
version from Oracle was better than one

00:56:32,230 --> 00:56:40,120
more year they had to rewrite it and

00:56:34,800 --> 00:56:42,460
some other features like well yeah it's

00:56:40,120 --> 00:56:46,180
text too long let me draw is examined

00:56:42,460 --> 00:56:49,210
and stuff like that so then next maria

00:56:46,180 --> 00:56:52,600
DB what's the next thing this is kind of

00:56:49,210 --> 00:56:55,210
a wish list maybe 55 was released in

00:56:52,600 --> 00:56:56,980
april so it's fairly new this is kind of

00:56:55,210 --> 00:56:59,680
the idea of which features will go in

00:56:56,980 --> 00:57:02,080
but it's not by far done yet and there's

00:56:59,680 --> 00:57:04,060
also there's also some speculation on

00:57:02,080 --> 00:57:07,150
how the versioning will go and so forth

00:57:04,060 --> 00:57:10,840
because maria b would like to release

00:57:07,150 --> 00:57:13,240
fairly often but with maria is kind of

00:57:10,840 --> 00:57:16,270
bond by by oracle villas in mysql and

00:57:13,240 --> 00:57:17,980
stuff so so there's a possibility that

00:57:16,270 --> 00:57:20,200
maria DB will not diverge a bit in

00:57:17,980 --> 00:57:22,930
version numbering from oracle and also

00:57:20,200 --> 00:57:25,080
many of these features we saw here that

00:57:22,930 --> 00:57:27,610
exists in my adb are now being

00:57:25,080 --> 00:57:31,840
implemented by oracle into the standard

00:57:27,610 --> 00:57:33,190
mysql but not in the same way right so

00:57:31,840 --> 00:57:36,520
they will do the same feature but a bit

00:57:33,190 --> 00:57:37,710
differently and if the mega TV feature

00:57:36,520 --> 00:57:41,520
is better

00:57:37,710 --> 00:57:43,710
what do you do right so do you take the

00:57:41,520 --> 00:57:45,300
worst feature from Oracle to be to be

00:57:43,710 --> 00:57:46,830
compatible or do you take the better

00:57:45,300 --> 00:57:48,440
feature and say we're no longer

00:57:46,830 --> 00:57:51,630
compatible and that's kind of the

00:57:48,440 --> 00:57:53,490
dilemma mariadb sad now should it stay a

00:57:51,630 --> 00:57:56,970
branch or should it become a true fork

00:57:53,490 --> 00:57:58,800
with no reemerging so one of the

00:57:56,970 --> 00:58:01,230
possibility is that it would say if you

00:57:58,800 --> 00:58:03,750
use specific features from the coming

00:58:01,230 --> 00:58:05,580
versions of Oracle MySQL but not all of

00:58:03,750 --> 00:58:06,900
them because some of them will be the

00:58:05,580 --> 00:58:14,450
same that have already been implemented

00:58:06,900 --> 00:58:19,589
by maybe and where can you get me a DB

00:58:14,450 --> 00:58:22,020
you can get it on these systems and

00:58:19,589 --> 00:58:23,970
Marie DB also has its own yum and apt

00:58:22,020 --> 00:58:26,580
repos so you can go to marry DB you can

00:58:23,970 --> 00:58:31,710
put these Reapers in your systems and

00:58:26,580 --> 00:58:36,660
download them and right we have five

00:58:31,710 --> 00:58:42,330
seconds for questions and we have above

00:58:36,660 --> 00:58:44,339
tonight at seven-thirty where HP is the

00:58:42,330 --> 00:58:50,289
room right if anyone has any questions I

00:58:44,339 --> 00:58:52,419
have not a lot of time but go ahead yeah

00:58:50,289 --> 00:58:54,729
saw some stuff momentum blueprint on

00:58:52,419 --> 00:58:59,469
making variety be available in their

00:58:54,729 --> 00:59:01,029
equal reposes my sequel alternative well

00:58:59,469 --> 00:59:03,160
that's basically the last I heard as

00:59:01,029 --> 00:59:06,910
well so the question was about it won't

00:59:03,160 --> 00:59:09,390
do whether Maria DB will be there as an

00:59:06,910 --> 00:59:11,380
option and the latest i've heard is that

00:59:09,390 --> 00:59:13,449
that's what they're aiming to do have an

00:59:11,380 --> 00:59:20,019
option you could choose between the

00:59:13,449 --> 00:59:50,259
Oracle version and Maria DB yeah an

00:59:20,019 --> 00:59:53,690
alternative any other questions have my

00:59:50,259 --> 00:59:57,190
sequel can't say ye my single

00:59:53,690 --> 01:00:02,240
it's already used in cats and dogs play

00:59:57,190 --> 01:00:08,710
but that should be fixed bloomin fix

01:00:02,240 --> 01:00:08,710
that Murray as my success

01:00:10,140 --> 01:00:16,060
yeah but but it's already available in

01:00:13,540 --> 01:00:19,330
Saudi systems now it works already now

01:00:16,060 --> 01:00:22,770
in this system right all right I guess I

01:00:19,330 --> 01:00:22,770
have to end so thank you and uh

01:00:27,680 --> 01:00:29,740
you

01:00:39,010 --> 01:00:44,090
when we created asterisk over a decade

01:00:41,720 --> 01:00:46,040
ago we could not have imagined that

01:00:44,090 --> 01:00:48,230
asterisk would not only become the most

01:00:46,040 --> 01:00:50,390
widely adopted open source communication

01:00:48,230 --> 01:00:52,400
software on the planet but that it would

01:00:50,390 --> 01:00:54,920
impact the entire industry in the way

01:00:52,400 --> 01:00:56,900
that it has today asterisk has found its

01:00:54,920 --> 01:00:59,540
way into more than 170 countries and

01:00:56,900 --> 01:01:01,490
virtually every fortune 1000 company the

01:00:59,540 --> 01:01:03,590
success of asterisk has enabled a

01:01:01,490 --> 01:01:05,000
transition of power from the hands of

01:01:03,590 --> 01:01:07,280
the traditional proprietary phone

01:01:05,000 --> 01:01:09,680
vendors into the hands of the users and

01:01:07,280 --> 01:01:11,750
administrators of phone systems using

01:01:09,680 --> 01:01:13,400
this power our customers have traded all

01:01:11,750 --> 01:01:15,470
sorts of business changing applications

01:01:13,400 --> 01:01:17,270
from small office phone systems to

01:01:15,470 --> 01:01:19,370
mission-critical call centers the

01:01:17,270 --> 01:01:21,200
international carrier networks in fact

01:01:19,370 --> 01:01:22,670
there's even an entire country those

01:01:21,200 --> 01:01:24,920
communications infrastructure runs on

01:01:22,670 --> 01:01:27,050
esters the gym has always been about

01:01:24,920 --> 01:01:28,760
creating technology that expands

01:01:27,050 --> 01:01:30,950
communications capabilities in ways that

01:01:28,760 --> 01:01:32,120
we could never have imagined and that's

01:01:30,950 --> 01:01:34,880
part of what's game-changing about

01:01:32,120 --> 01:01:37,220
Digium today we're doing it again this

01:01:34,880 --> 01:01:39,320
time by introducing a new family of HD

01:01:37,220 --> 01:01:41,420
IP phones that extends control of the

01:01:39,320 --> 01:01:43,190
user all the way to the desktop the

01:01:41,420 --> 01:01:44,900
launch of these new products represents

01:01:43,190 --> 01:01:47,000
the next phase indigenous history of

01:01:44,900 --> 01:01:49,400
innovation these are the first and only

01:01:47,000 --> 01:01:51,110
IP phones designed to fully leverage the

01:01:49,400 --> 01:01:52,790
power of Astra's when we first discussed

01:01:51,110 --> 01:01:54,680
our expectations for building a family

01:01:52,790 --> 01:01:56,840
of phones for use with asterisk our

01:01:54,680 --> 01:01:58,580
requirements were pretty simple we asked

01:01:56,840 --> 01:02:00,230
the team to build the phones such that

01:01:58,580 --> 01:02:02,420
they were easy to install integrate

01:02:00,230 --> 01:02:04,280
provision and use I think you'll soon

01:02:02,420 --> 01:02:06,830
agree our engineers have delivered on

01:02:04,280 --> 01:02:08,450
that goal user feedback is validating

01:02:06,830 --> 01:02:10,580
that when it comes to operation with

01:02:08,450 --> 01:02:13,010
Astra space systems including our own

01:02:10,580 --> 01:02:15,560
Switchvox based product these are the

01:02:13,010 --> 01:02:16,880
easiest to use best integrated most

01:02:15,560 --> 01:02:19,460
interoperable products on the market

01:02:16,880 --> 01:02:21,460
today the digitally of phones will

01:02:19,460 --> 01:02:23,510
initially include three IP des hommes

01:02:21,460 --> 01:02:25,460
uniquely designed to complement any

01:02:23,510 --> 01:02:27,320
asterisks or Switchvox based solution

01:02:25,460 --> 01:02:29,990
these phones are different for a number

01:02:27,320 --> 01:02:32,660
of reasons first there is clue sively

01:02:29,990 --> 01:02:34,070
designed for use with esters secondly

01:02:32,660 --> 01:02:35,680
we've made it really easy to

01:02:34,070 --> 01:02:38,090
autodiscover and provision the phones

01:02:35,680 --> 01:02:39,770
next we've made it easy for the phones

01:02:38,090 --> 01:02:41,480
to access information inside of

01:02:39,770 --> 01:02:43,099
asterisks allowing tight coupling

01:02:41,480 --> 01:02:45,680
between an application and

01:02:43,099 --> 01:02:47,839
phone additionally we've created an

01:02:45,680 --> 01:02:49,970
applications engine that allows users

01:02:47,839 --> 01:02:53,210
and developers to create and run their

01:02:49,970 --> 01:02:54,979
own apps on the phone and finally we've

01:02:53,210 --> 01:02:56,930
done all of this at a very compelling

01:02:54,979 --> 01:02:58,609
price point at Digium we're always

01:02:56,930 --> 01:03:00,710
thinking of ways to give our customers

01:02:58,609 --> 01:03:03,229
the best value in business phone systems

01:03:00,710 --> 01:03:04,819
and also give them the power to create

01:03:03,229 --> 01:03:06,979
their own solutions or any

01:03:04,819 --> 01:03:08,720
communications challenge will continue

01:03:06,979 --> 01:03:10,160
to push the boundaries not only to make

01:03:08,720 --> 01:03:12,200
Astra's cooler bastard more

01:03:10,160 --> 01:03:13,940
technologically feature-rich but to make

01:03:12,200 --> 01:03:16,460
asterisk and communications even easier

01:03:13,940 --> 01:03:19,989
and together we'll change the way the

01:03:16,460 --> 01:03:19,989
world communicates again

01:03:30,410 --> 01:03:37,200
how's that sigh every way this is the

01:03:33,900 --> 01:03:39,390
way to better utilize all your resources

01:03:37,200 --> 01:03:42,840
and it makes managing all your resources

01:03:39,390 --> 01:03:46,670
pretty easy all of the innovation is

01:03:42,840 --> 01:03:50,160
happening in open source the

01:03:46,670 --> 01:03:51,990
collaborative nature and of the you know

01:03:50,160 --> 01:03:53,910
of the community and the speed at which

01:03:51,990 --> 01:03:56,070
these are these you know these

01:03:53,910 --> 01:03:58,380
deficiencies these bugs are getting

01:03:56,070 --> 01:04:01,230
discovered and then fixed is the thing

01:03:58,380 --> 01:04:04,230
that really shows the power of the of

01:04:01,230 --> 01:04:06,710
the open source community it is global

01:04:04,230 --> 01:04:10,230
and it's definitely because of the users

01:04:06,710 --> 01:04:15,869
community people are extremely friendly

01:04:10,230 --> 01:04:17,760
and they're always ready to help if you

01:04:15,869 --> 01:04:20,040
go on tire see any day you'll see these

01:04:17,760 --> 01:04:21,770
guys helping each other out and they're

01:04:20,040 --> 01:04:24,480
all doing it like in a selfless manner

01:04:21,770 --> 01:04:27,470
the product is transparent for everyone

01:04:24,480 --> 01:04:30,660
everyone can look at the code base

01:04:27,470 --> 01:04:32,900
everyone can see how close that is being

01:04:30,660 --> 01:04:38,400
built nothing nothing is proprietary

01:04:32,900 --> 01:04:41,040
everything is open in many ways it's

01:04:38,400 --> 01:04:45,480
absolutely vital to the the ongoing

01:04:41,040 --> 01:04:49,680
health plan stack the most exciting

01:04:45,480 --> 01:04:52,530
event in recent memory for me was our

01:04:49,680 --> 01:04:55,170
first developer boot camp

01:04:52,530 --> 01:04:57,810
and our call gave people activity two

01:04:55,170 --> 01:05:01,770
weeks notice to come attend I was

01:04:57,810 --> 01:05:05,940
expecting 25 or 30 people so we ended up

01:05:01,770 --> 01:05:08,790
with 87 people and had to go get more

01:05:05,940 --> 01:05:11,310
chairs in the room twice everything

01:05:08,790 --> 01:05:14,580
within cloud computing is commodity and

01:05:11,310 --> 01:05:17,640
is open source and so I don't think that

01:05:14,580 --> 01:05:19,380
you will you'll see anywhere where open

01:05:17,640 --> 01:05:22,410
source is not pervasive in cloud

01:05:19,380 --> 01:05:24,960
computing and so i think it's i think

01:05:22,410 --> 01:05:26,490
it's an assumption i think when you talk

01:05:24,960 --> 01:05:27,600
about cloud computing you're really

01:05:26,490 --> 01:05:33,150
talking about open source cloud

01:05:27,600 --> 01:05:36,180
computing cloud sac is a robust solution

01:05:33,150 --> 01:05:38,340
for large deployments you'll have dozens

01:05:36,180 --> 01:05:42,630
of data centers and thousands of servers

01:05:38,340 --> 01:05:45,270
in each data centers these hardware is

01:05:42,630 --> 01:05:48,780
going to fail and CloudStack is designed

01:05:45,270 --> 01:05:51,480
to handle number one that mass scale

01:05:48,780 --> 01:05:54,630
number two it's designed to handle the

01:05:51,480 --> 01:05:56,910
failure that inevitably happens in large

01:05:54,630 --> 01:06:00,120
deployments we started working on

01:05:56,910 --> 01:06:02,910
contact over four years ago

01:06:00,120 --> 01:06:05,850
you know it was the original set of

01:06:02,910 --> 01:06:08,040
people working on it had a background of

01:06:05,850 --> 01:06:11,850
delivering software telcos and service

01:06:08,040 --> 01:06:16,440
providers lots of QA lots of users

01:06:11,850 --> 01:06:20,480
actually using it availability is the

01:06:16,440 --> 01:06:23,250
key feature multiple hypervisors support

01:06:20,480 --> 01:06:25,650
different network models you can pick up

01:06:23,250 --> 01:06:27,810
whatever suits you better while step

01:06:25,650 --> 01:06:31,320
management server can be deployed in

01:06:27,810 --> 01:06:33,120
different physical machines it

01:06:31,320 --> 01:06:34,740
definitely has a huge footprint it's

01:06:33,120 --> 01:06:40,170
being deployed everywhere there's a

01:06:34,740 --> 01:06:41,900
major movie studio that they were using

01:06:40,170 --> 01:06:45,090
cloudstack they were using it to

01:06:41,900 --> 01:06:47,280
transcode video and I thought that was

01:06:45,090 --> 01:06:48,600
terribly fascinating what I found more

01:06:47,280 --> 01:06:51,870
fascinating is what they did during

01:06:48,600 --> 01:06:54,630
lunch where they would spin up you know

01:06:51,870 --> 01:06:56,010
50 or 60 game servers then as soon as

01:06:54,630 --> 01:06:57,930
lunch was over they would destroy all

01:06:56,010 --> 01:07:02,070
the instances and go back to doing real

01:06:57,930 --> 01:07:03,390
work cloudstack is vast it touches so

01:07:02,070 --> 01:07:05,490
many different aspects and there's no

01:07:03,390 --> 01:07:07,860
one person that's kind of like a master

01:07:05,490 --> 01:07:11,940
of all those realms I think CloudStack

01:07:07,860 --> 01:07:14,190
as a project is going to be one of the

01:07:11,940 --> 01:07:18,240
leaders simply because it's some of the

01:07:14,190 --> 01:07:23,670
most feature fallen and and robust

01:07:18,240 --> 01:07:26,600
platforms out they were Adam senior

01:07:23,670 --> 01:07:26,600

YouTube URL: https://www.youtube.com/watch?v=jE6yjtA6Kdk


