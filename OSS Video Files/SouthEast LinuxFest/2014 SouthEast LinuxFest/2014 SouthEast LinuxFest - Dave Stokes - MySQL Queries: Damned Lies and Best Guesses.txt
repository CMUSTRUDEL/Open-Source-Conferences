Title: 2014 SouthEast LinuxFest - Dave Stokes - MySQL Queries: Damned Lies and Best Guesses
Publication date: 2015-05-18
Playlist: 2014 SouthEast LinuxFest
Description: 
	2014 SouthEast LinuxFest
Dave Stokes
MySQL Queries: Damned Lies and Best Guesses
Captions: 
	00:00:00,000 --> 00:00:05,339
the following presentation was recorded

00:00:02,490 --> 00:00:08,189
the 2014 southeast linux fest in

00:00:05,339 --> 00:00:11,070
charlotte north carolina it is licensed

00:00:08,189 --> 00:00:14,880
under a creative commons license for

00:00:11,070 --> 00:00:18,180
more information visit www selfies linux

00:00:14,880 --> 00:00:19,710
pc org the southeast linux fest would

00:00:18,180 --> 00:00:22,740
like to thank the following diamond

00:00:19,710 --> 00:00:25,050
sponsors in 2014 for helping make these

00:00:22,740 --> 00:00:27,300
videos possible i'm assuming that most

00:00:25,050 --> 00:00:30,480
you in here are developers of some sort

00:00:27,300 --> 00:00:33,180
and that you've been using databases for

00:00:30,480 --> 00:00:35,730
a while and it's still kind of a dark

00:00:33,180 --> 00:00:38,010
art what's going on in the internal dark

00:00:35,730 --> 00:00:38,820
recesses of the database and you're

00:00:38,010 --> 00:00:41,219
trying to get a little bit better

00:00:38,820 --> 00:00:43,680
performance out of your queries now

00:00:41,219 --> 00:00:45,270
after i get done Peter Zaitsev for

00:00:43,680 --> 00:00:48,000
Briona who's in the back will be talking

00:00:45,270 --> 00:00:53,629
about MySQL application architect

00:00:48,000 --> 00:00:53,629
architecture and what's the full title

00:00:57,469 --> 00:01:02,460
okay so take what I have what he has and

00:01:00,930 --> 00:01:10,159
you'll walk out of here programming god

00:01:02,460 --> 00:01:14,310
ooh no problem a lot of programmers

00:01:10,159 --> 00:01:17,700
don't have any training in set theory or

00:01:14,310 --> 00:01:20,189
relational calculus or anything similar

00:01:17,700 --> 00:01:22,320
and they've really only written one

00:01:20,189 --> 00:01:24,330
mysql query in their life they've just

00:01:22,320 --> 00:01:32,220
tinkered with it as the applications

00:01:24,330 --> 00:01:35,070
keep growing now SQL looks funny it was

00:01:32,220 --> 00:01:38,640
designed in the 60s and 70s for specific

00:01:35,070 --> 00:01:41,340
reason the idea was to get the most

00:01:38,640 --> 00:01:44,009
efficient way to pull data off of a

00:01:41,340 --> 00:01:48,509
discount a computer and into memory or

00:01:44,009 --> 00:01:50,939
into an application now it's divided up

00:01:48,509 --> 00:01:52,320
into two parts ddl and DML data

00:01:50,939 --> 00:01:54,060
description language and data

00:01:52,320 --> 00:01:55,290
manipulation language and this is where

00:01:54,060 --> 00:01:57,619
the most of the programmers will start

00:01:55,290 --> 00:01:57,619
snoring

00:01:58,820 --> 00:02:04,640
if you remember Venn diagrams from

00:02:01,100 --> 00:02:07,360
school if you do anything download these

00:02:04,640 --> 00:02:10,250
slide sets and print out this page

00:02:07,360 --> 00:02:12,140
people often don't understand well I

00:02:10,250 --> 00:02:14,180
want the stuff from this table and the

00:02:12,140 --> 00:02:15,740
matches from the other table or I want

00:02:14,180 --> 00:02:19,190
the stuff that doesn't match this table

00:02:15,740 --> 00:02:22,550
from the other table sequel Jones are

00:02:19,190 --> 00:02:24,980
definitely a black art to a lot of

00:02:22,550 --> 00:02:32,600
developers if that's the case for you

00:02:24,980 --> 00:02:35,780
please grab a copy of this so the lower

00:02:32,600 --> 00:02:38,840
query you wrote for your application

00:02:35,780 --> 00:02:41,330
goes down the wire turns left into the

00:02:38,840 --> 00:02:43,910
processor and the my sequel demon grabs

00:02:41,330 --> 00:02:48,260
at and the first thing it wants to do is

00:02:43,910 --> 00:02:50,150
make sure that it's valid SQL then from

00:02:48,260 --> 00:02:52,400
there on it takes a look at that and

00:02:50,150 --> 00:02:54,230
tries to figure out how am I going to

00:02:52,400 --> 00:02:56,780
take this and actually do anything out

00:02:54,230 --> 00:03:01,370
of it that's called generating a query

00:02:56,780 --> 00:03:04,760
plan mysql unlike other databases like

00:03:01,370 --> 00:03:07,010
oracle wants to take that statement and

00:03:04,760 --> 00:03:08,959
optimize it every time it sees it we're

00:03:07,010 --> 00:03:10,730
in oracle you can lock it down so once

00:03:08,959 --> 00:03:14,170
you figure out how to do it right you

00:03:10,730 --> 00:03:18,079
have the formula mysql isn't that way so

00:03:14,170 --> 00:03:20,450
it's very important that you get a query

00:03:18,079 --> 00:03:22,400
that's fairly optimized upfront

00:03:20,450 --> 00:03:25,970
otherwise the system will chase its own

00:03:22,400 --> 00:03:28,519
tail so after it figures out how it's

00:03:25,970 --> 00:03:33,459
going to go out to grab the data it does

00:03:28,519 --> 00:03:36,110
just that and then returns the data now

00:03:33,459 --> 00:03:37,489
we have a no SQL approach to go straight

00:03:36,110 --> 00:03:40,010
to the data store and there's other no

00:03:37,489 --> 00:03:41,480
SQL databases out there that don't go

00:03:40,010 --> 00:03:44,150
through this and in many cases that

00:03:41,480 --> 00:03:48,380
approach is much faster but the trick is

00:03:44,150 --> 00:03:53,209
the power of SQL back here to do things

00:03:48,380 --> 00:03:55,400
like this pay off you can't do and Zhou

00:03:53,209 --> 00:03:58,579
roars with a lot of know SQL databases

00:03:55,400 --> 00:04:01,880
or if you do it's terribly expensive so

00:03:58,579 --> 00:04:04,340
if you start thinking of sets of data

00:04:01,880 --> 00:04:06,470
instead of just one line of data out of

00:04:04,340 --> 00:04:11,110
a big file and iterating over that

00:04:06,470 --> 00:04:11,110
the times this is where SQL pays off

00:04:13,030 --> 00:04:19,549
first goal a lot of programmers the

00:04:17,090 --> 00:04:23,170
first thing they see in SQL code is

00:04:19,549 --> 00:04:25,190
select asterisk from whatever table

00:04:23,170 --> 00:04:27,050
that's a shorthand for grabbing

00:04:25,190 --> 00:04:29,180
everything that's really great when

00:04:27,050 --> 00:04:30,140
you're playing with baby tables but what

00:04:29,180 --> 00:04:33,710
do you do when you have something that's

00:04:30,140 --> 00:04:35,330
400 columns wide this really gets

00:04:33,710 --> 00:04:37,940
expensive especially if you just want

00:04:35,330 --> 00:04:39,770
two or three columns so the first thing

00:04:37,940 --> 00:04:46,150
I want to do is slap your hands and say

00:04:39,770 --> 00:04:46,150
no more select stars the other thing is

00:04:46,540 --> 00:04:52,580
disk and memory reads well disagrees are

00:04:50,510 --> 00:04:55,490
terribly expensive they're 100 * hundred

00:04:52,580 --> 00:04:58,550
thousand times more intensive for time

00:04:55,490 --> 00:05:00,500
than out of memory so if you started

00:04:58,550 --> 00:05:02,870
doing a hundred thousand backflips here

00:05:00,500 --> 00:05:05,090
a second we didn't come back in 72 days

00:05:02,870 --> 00:05:09,919
and you just be finishing up that gives

00:05:05,090 --> 00:05:13,180
you an idea of the scale the other thing

00:05:09,919 --> 00:05:16,370
is especially with a lot of PHP CMS is

00:05:13,180 --> 00:05:18,380
everything is to find that's an integer

00:05:16,370 --> 00:05:23,570
as a big int and everything is

00:05:18,380 --> 00:05:26,050
characters of our car 255 well you can

00:05:23,570 --> 00:05:28,340
get away with that but the trouble is

00:05:26,050 --> 00:05:30,979
every big inch you have when you only

00:05:28,340 --> 00:05:32,600
need this big has to come off disk or

00:05:30,979 --> 00:05:35,210
out of memory gets transferred over a

00:05:32,600 --> 00:05:38,930
wire and into your application and when

00:05:35,210 --> 00:05:41,450
something's this big x 100000 versus

00:05:38,930 --> 00:05:47,650
this big x 100000 it goes much faster

00:05:41,450 --> 00:05:51,169
the smaller you make it mysql uses a

00:05:47,650 --> 00:05:52,580
cost-based optimizer if you heard my

00:05:51,169 --> 00:05:54,140
talk yesterday in the future this is

00:05:52,580 --> 00:05:56,390
going to change because we're basing the

00:05:54,140 --> 00:06:00,590
cost on has had its foundations chain

00:05:56,390 --> 00:06:05,510
change right now it's the cost of disk

00:06:00,590 --> 00:06:09,880
i/o so MySQL is trying to figure out how

00:06:05,510 --> 00:06:09,880
do I do this query with the least cost

00:06:11,480 --> 00:06:17,070
once again the query pant plan is not

00:06:13,980 --> 00:06:18,180
lockable with MySQL other databases you

00:06:17,070 --> 00:06:21,090
get the formula you get the recipe

00:06:18,180 --> 00:06:23,460
you're good to go last q I'll seize your

00:06:21,090 --> 00:06:27,630
your statement and wants to optimize it

00:06:23,460 --> 00:06:29,850
every time now to help it out it builds

00:06:27,630 --> 00:06:31,850
up statistics about where things are

00:06:29,850 --> 00:06:34,740
buried out there in the beech tree

00:06:31,850 --> 00:06:36,060
tables so it knows how to get there a

00:06:34,740 --> 00:06:49,230
little bit faster a little more

00:06:36,060 --> 00:06:53,910
economical good news yes sir in some

00:06:49,230 --> 00:06:56,100
cases yes if you do the same query now

00:06:53,910 --> 00:06:58,880
and then five minutes later it might

00:06:56,100 --> 00:07:07,500
have a slightly different query plan yes

00:06:58,880 --> 00:07:10,530
is the answer now the statistics do help

00:07:07,500 --> 00:07:12,840
but the only trouble is if you repower

00:07:10,530 --> 00:07:15,360
the system you lose the statistical

00:07:12,840 --> 00:07:17,400
information it's kind like you know a

00:07:15,360 --> 00:07:19,290
traffic out front on the main road is

00:07:17,400 --> 00:07:21,360
busiest between four and six in the

00:07:19,290 --> 00:07:22,680
afternoon and suddenly you forget that

00:07:21,360 --> 00:07:27,570
you're trying to get get out at five

00:07:22,680 --> 00:07:28,980
thirty so with 56 we gave the ability to

00:07:27,570 --> 00:07:31,020
be able to store off this information

00:07:28,980 --> 00:07:33,120
when you bring down a server and reload

00:07:31,020 --> 00:07:36,090
it the next time it comes up so if

00:07:33,120 --> 00:07:43,620
you're not running five six please

00:07:36,090 --> 00:07:44,700
consider switching over I don't think

00:07:43,620 --> 00:07:50,930
it's the default I think you have to

00:07:44,700 --> 00:07:50,930
turn it on yeah

00:07:52,750 --> 00:07:59,860
now this is where things get kind of

00:07:55,450 --> 00:08:03,040
darker murky for a lot of non dbas or

00:07:59,860 --> 00:08:05,050
sequel type folks there's something you

00:08:03,040 --> 00:08:07,720
prepend to prepend to queries called

00:08:05,050 --> 00:08:11,080
explain so if you have your select star

00:08:07,720 --> 00:08:13,330
from City you put in explain select star

00:08:11,080 --> 00:08:17,910
from City and it will tell you what the

00:08:13,330 --> 00:08:17,910
system wants to do solve your query

00:08:18,240 --> 00:08:24,940
here's an example table this is from the

00:08:21,270 --> 00:08:27,760
world database that we've used MySQL for

00:08:24,940 --> 00:08:29,770
decades for examples it's in our

00:08:27,760 --> 00:08:33,340
documentation in our man pages it's all

00:08:29,770 --> 00:08:38,229
over the place it's easy to download so

00:08:33,340 --> 00:08:41,800
it's a simple to City table it has an ID

00:08:38,229 --> 00:08:44,020
number a name for the city country code

00:08:41,800 --> 00:08:47,440
for you know which countries in a

00:08:44,020 --> 00:08:48,490
district and a population fairly simple

00:08:47,440 --> 00:08:51,390
you've probably seen something like this

00:08:48,490 --> 00:08:56,530
and everything from Drupal Joomla

00:08:51,390 --> 00:09:00,370
whatever else you're using so let's have

00:08:56,530 --> 00:09:04,300
a query select everything from City and

00:09:00,370 --> 00:09:06,430
we gave it a limit so in this case it

00:09:04,300 --> 00:09:09,780
gave us the ID number the name the

00:09:06,430 --> 00:09:11,770
country code district in population

00:09:09,780 --> 00:09:14,140
forgive me for being pedantic at the

00:09:11,770 --> 00:09:19,300
start but I need to get you all the same

00:09:14,140 --> 00:09:24,070
base so if we run explain on this it

00:09:19,300 --> 00:09:28,810
tells us that we had a simple query on

00:09:24,070 --> 00:09:31,960
the city table and that there was no

00:09:28,810 --> 00:09:35,050
keys or indexes who could use and to get

00:09:31,960 --> 00:09:40,150
those three records it estimated it was

00:09:35,050 --> 00:09:42,330
going to have to read 3839 lines in the

00:09:40,150 --> 00:09:42,330
table

00:09:45,819 --> 00:09:51,410
if you've never seen a query post pended

00:09:49,220 --> 00:09:53,059
with a backslash deep it just changes

00:09:51,410 --> 00:09:54,949
the format out to make a little bit read

00:09:53,059 --> 00:10:01,819
more readable and you'll see a little

00:09:54,949 --> 00:10:03,559
more of that going on now indexes let

00:10:01,819 --> 00:10:06,980
you go right to the records or records

00:10:03,559 --> 00:10:10,040
you want imagine having a dictionary

00:10:06,980 --> 00:10:12,230
that's not an A to Z format and things

00:10:10,040 --> 00:10:13,669
are repeated here and there and it's not

00:10:12,230 --> 00:10:16,249
an order and you have to look up the

00:10:13,669 --> 00:10:18,919
plural for the word mousse which means

00:10:16,249 --> 00:10:21,169
you have to start it the first page go

00:10:18,919 --> 00:10:23,449
to last page and keep looking because

00:10:21,169 --> 00:10:25,759
you might have more than one definition

00:10:23,449 --> 00:10:33,109
for the plural of moose in there with

00:10:25,759 --> 00:10:34,790
indexes you go right to it the other

00:10:33,109 --> 00:10:36,499
thing is there is some overhead two

00:10:34,790 --> 00:10:38,059
indexes on reads and writes it has to

00:10:36,499 --> 00:10:40,459
actually write off the statistics and

00:10:38,059 --> 00:10:42,499
that information in the table as it

00:10:40,459 --> 00:10:45,549
writes out the data so there is a slight

00:10:42,499 --> 00:10:48,019
cost to it but it usually pays off so

00:10:45,549 --> 00:10:50,419
this time I usually say well we save

00:10:48,019 --> 00:10:52,399
everything out in a bee tree and I start

00:10:50,419 --> 00:10:54,739
seeing the programmers going what's the

00:10:52,399 --> 00:10:58,249
bee tree and why are there bees around

00:10:54,739 --> 00:11:01,009
my database and what's going on bee tree

00:10:58,249 --> 00:11:03,769
is basically a binary tree cleve things

00:11:01,009 --> 00:11:06,559
in half so that you either have records

00:11:03,769 --> 00:11:11,540
into this case before king or after king

00:11:06,559 --> 00:11:13,790
and by splitting things down you can get

00:11:11,540 --> 00:11:15,319
down to the records now the optimizer

00:11:13,790 --> 00:11:18,379
when it comes through and it does its

00:11:15,319 --> 00:11:21,350
estimates is figuring if I need to get

00:11:18,379 --> 00:11:25,399
down here I have to read all this so the

00:11:21,350 --> 00:11:29,029
cost estimate that you'll see is from

00:11:25,399 --> 00:11:31,879
the bee tree of information and of

00:11:29,029 --> 00:11:33,589
course we have dozens of select types so

00:11:31,879 --> 00:11:36,379
if you're not used to explain all this

00:11:33,589 --> 00:11:37,549
is all gibberish to you it takes a

00:11:36,379 --> 00:11:40,579
little bit of reading of the manual and

00:11:37,549 --> 00:11:42,789
playing with it too to fully ingest

00:11:40,579 --> 00:11:42,789
these

00:11:46,190 --> 00:11:52,290
yeah the index you talked about

00:11:49,530 --> 00:11:54,840
previously it's actually indexed to be

00:11:52,290 --> 00:11:57,000
true so you can go the optimizer you go

00:11:54,840 --> 00:11:59,340
down the index did not necessarily enter

00:11:57,000 --> 00:12:05,850
the truth yeah it ever did some other

00:11:59,340 --> 00:12:08,460
point yes okay the question was how to

00:12:05,850 --> 00:12:09,780
replace it the index for the b-tree is

00:12:08,460 --> 00:12:11,520
it actually digging through the b-tree

00:12:09,780 --> 00:12:13,290
but actually has entry points buried it

00:12:11,520 --> 00:12:18,870
within their that it knows to jump to so

00:12:13,290 --> 00:12:21,150
it knows how to skip certain things so

00:12:18,870 --> 00:12:23,700
here's another select a little more

00:12:21,150 --> 00:12:26,790
complicated select everything from city

00:12:23,700 --> 00:12:28,980
where the country code equals USA and

00:12:26,790 --> 00:12:31,740
when you prepend explain on to it it

00:12:28,980 --> 00:12:33,690
comes out and will tell you once again

00:12:31,740 --> 00:12:36,510
it's a simple select we're hitting the

00:12:33,690 --> 00:12:39,990
city table and we have a reference in

00:12:36,510 --> 00:12:43,650
here the reference is we're looking for

00:12:39,990 --> 00:12:47,490
something that compares to something

00:12:43,650 --> 00:12:50,280
else it's a benchmark marker our index

00:12:47,490 --> 00:12:53,340
that we're using here and in this case

00:12:50,280 --> 00:12:56,160
we're lucky in that it's a constant it's

00:12:53,340 --> 00:12:58,500
not a function it's not a subroutine

00:12:56,160 --> 00:13:02,300
some like that we know that we only want

00:12:58,500 --> 00:13:05,430
to look for stuff that says USA now

00:13:02,300 --> 00:13:06,480
earlier you saw that it was three

00:13:05,430 --> 00:13:10,850
thousand eight hundred and some-odd

00:13:06,480 --> 00:13:13,170
records well now explain only wants to

00:13:10,850 --> 00:13:15,300
it tells us that the optimizers think

00:13:13,170 --> 00:13:18,180
it's only have to read 274 records to

00:13:15,300 --> 00:13:22,740
get to everything you want so by using

00:13:18,180 --> 00:13:30,420
an index we want from 3839 down to 274

00:13:22,740 --> 00:13:33,530
records much much much faster that's a

00:13:30,420 --> 00:13:33,530
secret coming up later okay

00:13:34,310 --> 00:13:43,170
okay so if we get rid of that index and

00:13:38,550 --> 00:13:46,110
we try it again you see the output is

00:13:43,170 --> 00:13:50,820
somewhat similar but now it's coming

00:13:46,110 --> 00:13:54,270
back and telling us that instead of 3868

00:13:50,820 --> 00:13:56,040
records it wants to read 4188 records

00:13:54,270 --> 00:13:58,980
where those extra records come from

00:13:56,040 --> 00:14:01,470
what's going on well this is the case

00:13:58,980 --> 00:14:10,980
where the statistics are lying to us and

00:14:01,470 --> 00:14:12,870
explained therefore lives back to us so

00:14:10,980 --> 00:14:16,590
if you have a table and you want to use

00:14:12,870 --> 00:14:19,950
the index how do you find it one simple

00:14:16,590 --> 00:14:23,010
way is do a described on the table or a

00:14:19,950 --> 00:14:24,620
show create table in this example and it

00:14:23,010 --> 00:14:28,680
tells us that when the table is created

00:14:24,620 --> 00:14:35,510
it had a primary key of ID and also has

00:14:28,680 --> 00:14:35,510
a key on the country code line there and

00:14:36,170 --> 00:14:40,620
for those you who don't play with

00:14:37,950 --> 00:14:42,810
foreign keys we also have another key in

00:14:40,620 --> 00:14:44,820
here that's a foreign key which means it

00:14:42,810 --> 00:14:48,360
points to a foreign table or a different

00:14:44,820 --> 00:14:51,180
table what's the power there is that you

00:14:48,360 --> 00:14:52,920
can say any changes I make to this table

00:14:51,180 --> 00:14:55,710
that's reference to that table

00:14:52,920 --> 00:14:57,420
automatically cascade them over so if

00:14:55,710 --> 00:15:00,270
i'm updating information bleeding

00:14:57,420 --> 00:15:01,440
records you take care of it for me mr.

00:15:00,270 --> 00:15:07,320
database I don't want to write the

00:15:01,440 --> 00:15:11,370
sequel for that the other way to find an

00:15:07,320 --> 00:15:15,780
index is type show index from and then

00:15:11,370 --> 00:15:18,360
your table name in this case you can see

00:15:15,780 --> 00:15:26,120
that we have the one for the country

00:15:18,360 --> 00:15:26,120
code which is right there

00:15:26,320 --> 00:15:33,850
and then we have the other one for the

00:15:28,890 --> 00:15:37,180
primary key for the ID number nodb will

00:15:33,850 --> 00:15:40,120
assign a primary key for you if you

00:15:37,180 --> 00:15:44,140
don't give it one so do yourself a favor

00:15:40,120 --> 00:15:46,930
if you're using my nodb which i highly

00:15:44,140 --> 00:15:49,600
recommend give all your tables a key

00:15:46,930 --> 00:15:54,730
that you you can use on something that

00:15:49,600 --> 00:15:58,060
you want to use well if you don't have

00:15:54,730 --> 00:15:59,290
one it assumes it should make one up but

00:15:58,060 --> 00:16:01,480
it's hidden from you and you don't see

00:15:59,290 --> 00:16:02,950
it so I'd rather create one that I know

00:16:01,480 --> 00:16:06,160
about them have it behind the scenes

00:16:02,950 --> 00:16:08,020
that I can't see explain doesn't

00:16:06,160 --> 00:16:11,590
actually execute agree right so we did

00:16:08,020 --> 00:16:15,280
there explain does not execute the query

00:16:11,590 --> 00:16:16,600
in most cases in some cases will

00:16:15,280 --> 00:16:18,850
actually run it like if you have a

00:16:16,600 --> 00:16:21,580
sub-query it will actually fire off the

00:16:18,850 --> 00:16:23,950
sub query to get some data there so

00:16:21,580 --> 00:16:27,610
sometimes on highly busy systems you

00:16:23,950 --> 00:16:34,780
don't want to run explained during the

00:16:27,610 --> 00:16:39,390
busy hours okay a little more complex

00:16:34,780 --> 00:16:42,520
example here we're collecting the name

00:16:39,390 --> 00:16:45,100
from the city table the name from the

00:16:42,520 --> 00:16:48,040
country table and we're ilya singh those

00:16:45,100 --> 00:16:51,730
so we have name is city from the country

00:16:48,040 --> 00:16:54,490
table the name for the country the

00:16:51,730 --> 00:16:56,620
population from the city table and we're

00:16:54,490 --> 00:16:58,540
going to pull it from the city table and

00:16:56,620 --> 00:17:01,300
we're going to join that on the country

00:16:58,540 --> 00:17:04,000
table and where we tell the the two

00:17:01,300 --> 00:17:07,480
tables to scissor up earlier matchup is

00:17:04,000 --> 00:17:09,670
the country code column from the city

00:17:07,480 --> 00:17:11,500
table and the code table from the

00:17:09,670 --> 00:17:12,790
country table which is a lot harder to

00:17:11,500 --> 00:17:16,449
say three times fast and you can ever

00:17:12,790 --> 00:17:20,130
imagine so we look at this query and we

00:17:16,449 --> 00:17:24,329
know it's going to do it in two parts

00:17:20,130 --> 00:17:27,459
the first one is table B and table B is

00:17:24,329 --> 00:17:29,860
our country table so it's going to want

00:17:27,459 --> 00:17:32,320
to go through and for every country it

00:17:29,860 --> 00:17:36,820
estimates that's going to do roughly 239

00:17:32,320 --> 00:17:39,040
reads for every country now the second

00:17:36,820 --> 00:17:40,000
query it figures it could find all the

00:17:39,040 --> 00:17:42,490
cities and I match

00:17:40,000 --> 00:17:45,640
of eight reads it's like the old game

00:17:42,490 --> 00:17:47,320
name that tune where they gave people X

00:17:45,640 --> 00:17:50,140
amount of notes from the melody of a

00:17:47,320 --> 00:17:53,290
tune to pick out its identification so

00:17:50,140 --> 00:17:56,260
what's our worst case number here well

00:17:53,290 --> 00:18:04,270
it's 239 times 8 which is almost two

00:17:56,260 --> 00:18:07,890
thousand records to read so you don't

00:18:04,270 --> 00:18:10,300
really care about two thousand records

00:18:07,890 --> 00:18:12,700
you're a smart program where you realize

00:18:10,300 --> 00:18:14,740
you know the apple iphone screen that

00:18:12,700 --> 00:18:16,480
you have your user it uses in front of

00:18:14,740 --> 00:18:18,490
you doesn't have that screen beginner

00:18:16,480 --> 00:18:24,010
for two thousand columns of data or rows

00:18:18,490 --> 00:18:25,690
of data so you only want 20 and by the

00:18:24,010 --> 00:18:28,330
way you don't want every little potom

00:18:25,690 --> 00:18:29,740
city you only want the big cities so

00:18:28,330 --> 00:18:32,200
we're going to look at the cities that

00:18:29,740 --> 00:18:34,660
have was that three million or more

00:18:32,200 --> 00:18:36,250
population and you don't want to send

00:18:34,660 --> 00:18:37,720
anyone to a real rat hole so you only

00:18:36,250 --> 00:18:42,120
want the cities where the average life

00:18:37,720 --> 00:18:45,040
expectancy is greater than 66 years and

00:18:42,120 --> 00:18:47,410
you kind of want that sorted you want to

00:18:45,040 --> 00:18:49,600
know you don't have them in alphabetical

00:18:47,410 --> 00:18:51,820
order for the name and then sort by

00:18:49,600 --> 00:18:56,200
population but then you want to want 20

00:18:51,820 --> 00:19:01,710
records how many of you think this makes

00:18:56,200 --> 00:19:03,970
a major change to the query plan okay

00:19:01,710 --> 00:19:08,860
come back and we put in all these

00:19:03,970 --> 00:19:13,810
qualifiers and guess what 239 times

00:19:08,860 --> 00:19:16,390
eight this is the reason why this is

00:19:13,810 --> 00:19:18,130
such a boring dry talk is this is the

00:19:16,390 --> 00:19:20,980
thing that I have a hard time getting

00:19:18,130 --> 00:19:26,490
into the brains of programmers all these

00:19:20,980 --> 00:19:29,230
little qualifications happen after mysql

00:19:26,490 --> 00:19:36,230
does everything to the left hand side of

00:19:29,230 --> 00:19:38,929
the we're in this case so yes sir

00:19:36,230 --> 00:19:41,120
able to think of this you run the query

00:19:38,929 --> 00:19:42,919
it returns to pilot a than the

00:19:41,120 --> 00:19:47,540
qualifications essentially go through

00:19:42,919 --> 00:19:49,250
the data and select what you want it's

00:19:47,540 --> 00:19:51,169
very reasonable to expect that it

00:19:49,250 --> 00:19:53,360
returns all the information you want and

00:19:51,169 --> 00:19:59,900
then does the sorting of the information

00:19:53,360 --> 00:20:02,780
that you yeah believe it or not this is

00:19:59,900 --> 00:20:05,059
like teaching a third grader about

00:20:02,780 --> 00:20:07,010
reproductive and why mommy has that big

00:20:05,059 --> 00:20:09,799
bump in front of her it's a hard concept

00:20:07,010 --> 00:20:11,510
for a lot of programmers to get if I've

00:20:09,799 --> 00:20:13,700
lost any of you in the weeds please let

00:20:11,510 --> 00:20:15,860
me know I'm being very pedantic here

00:20:13,700 --> 00:20:18,530
because this is time and time again I've

00:20:15,860 --> 00:20:22,970
just seen programmers two of their toll

00:20:18,530 --> 00:20:25,210
on it so how do we make this a little

00:20:22,970 --> 00:20:29,600
bit easier a little bit better to read

00:20:25,210 --> 00:20:34,340
well with MySQL 56 and 57 and the latest

00:20:29,600 --> 00:20:36,530
version or workbench we got smart we

00:20:34,340 --> 00:20:39,890
parted started putting out output from

00:20:36,530 --> 00:20:41,630
explain in JSON format and then we have

00:20:39,890 --> 00:20:45,669
some pretty parsers that will go through

00:20:41,630 --> 00:20:51,110
and give you pictures of what's going on

00:20:45,669 --> 00:20:52,309
so here's our query again and this is

00:20:51,110 --> 00:20:54,830
telling us where it has to order using

00:20:52,309 --> 00:20:57,740
the sort and it's doing less that loop

00:20:54,830 --> 00:21:01,280
join between the two tables the city and

00:20:57,740 --> 00:21:03,080
the country what keys are choosing to do

00:21:01,280 --> 00:21:05,260
that and that tells you it has the

00:21:03,080 --> 00:21:07,460
conditions that it runs afterwards I

00:21:05,260 --> 00:21:13,390
don't know about you but I like reading

00:21:07,460 --> 00:21:13,390
that a lot better than reading that

00:21:20,550 --> 00:21:24,100
I'm thinking it was more worried about

00:21:22,660 --> 00:21:25,570
matching up all the cities in the

00:21:24,100 --> 00:21:27,840
countries and then figuring that when it

00:21:25,570 --> 00:21:38,470
comes secondarily it'd be much cheaper

00:21:27,840 --> 00:21:40,090
to go through and do that way yeah yeah

00:21:38,470 --> 00:21:43,290
it doesn't have any nicks on there now

00:21:40,090 --> 00:21:43,290
you can force indexes

00:21:47,549 --> 00:21:53,850
yeah the life expectancy like he said

00:21:50,940 --> 00:21:55,769
was an indexed and the other thing is if

00:21:53,850 --> 00:21:58,470
we want to we went through and we index

00:21:55,769 --> 00:22:01,080
that column and we forced it to use that

00:21:58,470 --> 00:22:03,419
the optimizer might choose to follow

00:22:01,080 --> 00:22:04,559
that path or it might not it's one of

00:22:03,419 --> 00:22:06,210
those things were if you're really

00:22:04,559 --> 00:22:08,549
trying to get the last little iota of

00:22:06,210 --> 00:22:13,470
information speed out of your query that

00:22:08,549 --> 00:22:16,590
you end up playing with so visual

00:22:13,470 --> 00:22:18,989
explain if you want a better demo come

00:22:16,590 --> 00:22:21,600
out to the table a couple you've seen it

00:22:18,989 --> 00:22:23,369
is it's rather impressive if you mouse

00:22:21,600 --> 00:22:24,809
over one of the boxes like the red one

00:22:23,369 --> 00:22:30,570
there will tell you what's going on and

00:22:24,809 --> 00:22:33,690
how you can improve the query so now

00:22:30,570 --> 00:22:36,029
that I've got you let's say going into

00:22:33,690 --> 00:22:40,649
the high school level of SQL let's go to

00:22:36,029 --> 00:22:42,720
a little more complex query this is

00:22:40,649 --> 00:22:45,149
using one of our other test basis test

00:22:42,720 --> 00:22:48,389
database is called sakila also free from

00:22:45,149 --> 00:22:54,330
mysql it's like you have your own movie

00:22:48,389 --> 00:22:56,220
rental business it's nice because it has

00:22:54,330 --> 00:22:58,169
a lot of complexity built-in for

00:22:56,220 --> 00:23:00,269
illustrating the type of stuff I want to

00:22:58,169 --> 00:23:03,119
show you folks so here we're going to

00:23:00,269 --> 00:23:05,369
grab the customer name their phone

00:23:03,119 --> 00:23:08,820
number the film title from what they

00:23:05,369 --> 00:23:14,009
rented and we're going to do joins on

00:23:08,820 --> 00:23:17,539
all these different tables and I'm sorry

00:23:14,009 --> 00:23:21,149
you have to tilt your head over one way

00:23:17,539 --> 00:23:22,200
this is where DBAs you see them you

00:23:21,149 --> 00:23:24,149
think they're falling asleep at their

00:23:22,200 --> 00:23:25,019
head hits the table now they're they're

00:23:24,149 --> 00:23:28,409
banging their head against the table

00:23:25,019 --> 00:23:32,909
very slowly over stuff like this he's

00:23:28,409 --> 00:23:35,389
laughing because he's a DBA i find this

00:23:32,909 --> 00:23:37,889
much much much easier to understand and

00:23:35,389 --> 00:23:40,470
what's great is that's wonderful tip for

00:23:37,889 --> 00:23:43,789
documentation and it gives you the nice

00:23:40,470 --> 00:23:48,149
visual representation that we're doing

00:23:43,789 --> 00:23:51,869
the join on a dress and the join on

00:23:48,149 --> 00:23:55,109
inventory and the joint on film so you

00:23:51,869 --> 00:24:00,019
can see that we're joining on inventory

00:23:55,109 --> 00:24:00,019
and the rental ID and the customer firm

00:24:02,980 --> 00:24:07,730
okay compound indexes this is something

00:24:06,500 --> 00:24:12,529
where you can make your life a lot

00:24:07,730 --> 00:24:19,149
easier here we have an index that we

00:24:12,529 --> 00:24:19,149
created for the address information

00:24:19,899 --> 00:24:26,179
character 34 an address character 31st

00:24:23,509 --> 00:24:30,139
city two character for state and a zip

00:24:26,179 --> 00:24:34,070
code and let's say most of your searches

00:24:30,139 --> 00:24:35,450
are going to be on city state zip now if

00:24:34,070 --> 00:24:38,539
you have this index what's great about

00:24:35,450 --> 00:24:43,220
it is that you can search on city state

00:24:38,539 --> 00:24:46,279
zip or city and state or city you can't

00:24:43,220 --> 00:24:52,279
use that index to search on zip or state

00:24:46,279 --> 00:24:54,830
or state and zip and what's really great

00:24:52,279 --> 00:24:57,049
about this is it really speeds things up

00:24:54,830 --> 00:24:59,269
so if you're doing a customer service

00:24:57,049 --> 00:25:01,820
desk and you have the customer ID number

00:24:59,269 --> 00:25:03,139
and the company name and maybe their

00:25:01,820 --> 00:25:04,759
contract number you don't always get the

00:25:03,139 --> 00:25:06,470
contract number the same index covers

00:25:04,759 --> 00:25:09,230
all the information one index to

00:25:06,470 --> 00:25:13,639
maintain when indexed update makes life

00:25:09,230 --> 00:25:19,070
a lot better covering index is a similar

00:25:13,639 --> 00:25:23,330
ID our similar idea in this case on the

00:25:19,070 --> 00:25:26,629
city table we're always looking up the

00:25:23,330 --> 00:25:27,529
population for a country code we want to

00:25:26,629 --> 00:25:32,240
know how many people live in that

00:25:27,529 --> 00:25:35,929
country but we don't want to overextend

00:25:32,240 --> 00:25:38,059
ourselves so we created an index here

00:25:35,929 --> 00:25:39,620
using alter table syntax I would say

00:25:38,059 --> 00:25:43,940
okay we're adding index called entry

00:25:39,620 --> 00:25:46,039
index on country code and population so

00:25:43,940 --> 00:25:48,230
as you use this index and you put in the

00:25:46,039 --> 00:25:49,399
country code when it makes a match it

00:25:48,230 --> 00:25:52,009
will automatically pull up the

00:25:49,399 --> 00:25:55,269
population for you saving a whole bunch

00:25:52,009 --> 00:25:55,269
of reading into the database

00:25:59,029 --> 00:26:13,649
ok you have a index that has the country

00:26:10,019 --> 00:26:16,469
code and it's related population so if

00:26:13,649 --> 00:26:18,209
you want to look it up and just use the

00:26:16,469 --> 00:26:20,399
index rather than going into the table

00:26:18,209 --> 00:26:26,369
to look for it this saves you a whole

00:26:20,399 --> 00:26:27,749
bunch of reads into the table it's not

00:26:26,369 --> 00:26:30,839
really join but it's a hell of a

00:26:27,749 --> 00:26:33,869
shortcut yeah it's a heck of a short cut

00:26:30,839 --> 00:26:35,609
into your data programmers if you can do

00:26:33,869 --> 00:26:38,759
this for stuff were you doing to item

00:26:35,609 --> 00:26:41,419
lookups it really saves massive massive

00:26:38,759 --> 00:26:41,419
amounts of i/o

00:26:48,800 --> 00:26:53,450
join cacho that's what he's done is not

00:26:50,930 --> 00:26:55,460
a compound index you didn't want to

00:26:53,450 --> 00:26:58,100
screw the search on the index and if the

00:26:55,460 --> 00:27:00,200
query completely resolves by the index

00:26:58,100 --> 00:27:08,120
it doesn't even have to hit all the data

00:27:00,200 --> 00:27:10,970
tables that's part of the the joint

00:27:08,120 --> 00:27:13,610
analogy now it's not a good joint

00:27:10,970 --> 00:27:15,980
analogy and like you said this this only

00:27:13,610 --> 00:27:17,750
drags the stuff from the same table now

00:27:15,980 --> 00:27:20,750
if you want to do something like that

00:27:17,750 --> 00:27:22,160
you can use a view and the only trouble

00:27:20,750 --> 00:27:24,110
with views in MySQL they're not

00:27:22,160 --> 00:27:25,580
materialized so as things change they

00:27:24,110 --> 00:27:31,490
don't get updated so you have to kind of

00:27:25,580 --> 00:27:32,960
force reading things okay if you're a

00:27:31,490 --> 00:27:36,230
programmer and you really want to get

00:27:32,960 --> 00:27:37,820
serious about improving your queries the

00:27:36,230 --> 00:27:39,860
best thing you can do is print out

00:27:37,820 --> 00:27:44,150
chapter 8 from the mask yo man Ewell and

00:27:39,860 --> 00:27:46,400
put it in your bathroom and do it the

00:27:44,150 --> 00:27:50,330
old programmer way and read a couple

00:27:46,400 --> 00:27:53,210
pages at a time the other thing is when

00:27:50,330 --> 00:27:56,240
you're joining tables do it on like data

00:27:53,210 --> 00:27:58,700
types don't try to get a char with an

00:27:56,240 --> 00:28:03,890
int try to go same size every time you

00:27:58,700 --> 00:28:05,390
can casting isn't that expensive but if

00:28:03,890 --> 00:28:08,290
you do something a hundred thousand

00:28:05,390 --> 00:28:12,770
times a minute it gets more and more

00:28:08,290 --> 00:28:15,260
costly also keep your columns as small

00:28:12,770 --> 00:28:17,330
as practical we have something called

00:28:15,260 --> 00:28:19,640
procedure analyze that will look at your

00:28:17,330 --> 00:28:22,430
information and it will suggest that you

00:28:19,640 --> 00:28:23,390
don't need 7 characters for zip code but

00:28:22,430 --> 00:28:24,590
then the back of your mind you might

00:28:23,390 --> 00:28:25,760
live in a country you might have some

00:28:24,590 --> 00:28:27,740
customers that live in a country that

00:28:25,760 --> 00:28:30,290
have 7 characters so again you have to

00:28:27,740 --> 00:28:31,940
know your data be able out rule that but

00:28:30,290 --> 00:28:34,190
sometimes you'll have something like

00:28:31,940 --> 00:28:35,920
savarkar 255 and you find out the

00:28:34,190 --> 00:28:41,300
longest entry and there's 50 characters

00:28:35,920 --> 00:28:42,830
so save yourself 205 characters also I

00:28:41,300 --> 00:28:44,930
recommend running analyzed table are we

00:28:42,830 --> 00:28:46,670
so often when things are quiescent that

00:28:44,930 --> 00:28:48,080
redoes the statistics and keeps

00:28:46,670 --> 00:28:53,000
everything reshuffling the way you want

00:28:48,080 --> 00:28:54,940
them to go and the other thing is keep

00:28:53,000 --> 00:28:57,590
looking for improvements in your code

00:28:54,940 --> 00:28:58,910
it's an iterative process if you're

00:28:57,590 --> 00:29:00,179
starting out and proving your your

00:28:58,910 --> 00:29:01,919
queries

00:29:00,179 --> 00:29:03,210
and there it's like programming stuff

00:29:01,919 --> 00:29:06,480
that you were up two years ago you look

00:29:03,210 --> 00:29:09,419
at it now and you kind of grimace and if

00:29:06,480 --> 00:29:11,549
you can read it same with sequel as you

00:29:09,419 --> 00:29:13,110
get better you'll find out that it takes

00:29:11,549 --> 00:29:17,909
a little bit experience to do some

00:29:13,110 --> 00:29:20,519
really good stuff now it's hard to teach

00:29:17,909 --> 00:29:22,799
people how to write great SQL in a

00:29:20,519 --> 00:29:27,690
couple you know in a 40 minute session

00:29:22,799 --> 00:29:33,320
or so the two books I really really

00:29:27,690 --> 00:29:40,470
recommend our high-performance mysql

00:29:33,320 --> 00:29:42,419
which is now third edition first edition

00:29:40,470 --> 00:29:47,039
is about that big second step big third

00:29:42,419 --> 00:29:50,730
edition is rather massive it's worth

00:29:47,039 --> 00:29:54,350
reading through it has a lot of detail

00:29:50,730 --> 00:29:57,690
now if you want a simpler path to go on

00:29:54,350 --> 00:29:59,759
effective mysql optimization much

00:29:57,690 --> 00:30:02,220
smaller book it's about 120 pages it's

00:29:59,759 --> 00:30:05,220
just on query optimization where the

00:30:02,220 --> 00:30:07,919
other one deals a lot with server tuning

00:30:05,220 --> 00:30:12,869
a lot of other stuff they're both good

00:30:07,919 --> 00:30:16,919
books and i highly recommend both if you

00:30:12,869 --> 00:30:22,230
get a chance we have our own show it's a

00:30:16,919 --> 00:30:24,629
part of oracle openworld we have five

00:30:22,230 --> 00:30:27,509
days in san francisco and you're going

00:30:24,629 --> 00:30:29,639
to be able to talk to the folks are the

00:30:27,509 --> 00:30:32,190
engineers who write this code some of

00:30:29,639 --> 00:30:36,210
the customers percona is going to be

00:30:32,190 --> 00:30:38,730
their Facebook LinkedIn Twitter and you

00:30:36,210 --> 00:30:40,740
can see what people are doing if you get

00:30:38,730 --> 00:30:42,659
a chance to go hit the playful play

00:30:40,740 --> 00:30:45,090
session they run the biggest online game

00:30:42,659 --> 00:30:46,590
in Central and South America the stuff

00:30:45,090 --> 00:30:48,539
they do is absolutely amazing they do

00:30:46,590 --> 00:30:53,190
with a very small staff on very limited

00:30:48,539 --> 00:30:54,980
budget early bird registration ends july

00:30:53,190 --> 00:30:57,269
eight teams and saves five hundred bucks

00:30:54,980 --> 00:30:58,799
this is your chance to talk to the top

00:30:57,269 --> 00:31:01,379
mysql folks and we have a lot of

00:30:58,799 --> 00:31:03,419
tutorials including a lot of query

00:31:01,379 --> 00:31:07,230
tuning or one big query tuning tutorial

00:31:03,419 --> 00:31:08,129
that i'm aware of now now i want to

00:31:07,230 --> 00:31:10,240
thank you all for going through this

00:31:08,129 --> 00:31:14,530
this is dry as hell

00:31:10,240 --> 00:31:17,470
I know it's boring as heck but it pays

00:31:14,530 --> 00:31:20,470
off and it's hard to get programmers to

00:31:17,470 --> 00:31:21,550
try to change their ways so I really

00:31:20,470 --> 00:31:24,340
appreciate you all coming out and

00:31:21,550 --> 00:31:34,480
listening to me so what questions do we

00:31:24,340 --> 00:31:41,290
have oh yes sir and index I'm expression

00:31:34,480 --> 00:31:43,929
I lower lower probably it's going to be

00:31:41,290 --> 00:31:45,550
restricted to just the column I know ask

00:31:43,929 --> 00:31:47,559
you all you're going to only have

00:31:45,550 --> 00:31:50,020
indexes on columns I don't know about

00:31:47,559 --> 00:31:52,170
other databases it's kind of hard to

00:31:50,020 --> 00:31:54,160
index something that's non deterministic

00:31:52,170 --> 00:31:59,020
or you don't already know where you're

00:31:54,160 --> 00:32:02,710
going to leap when you it's a function

00:31:59,020 --> 00:32:11,320
of functionally calling off I don't

00:32:02,710 --> 00:32:13,710
Peter you can't do that kidding postgres

00:32:11,320 --> 00:32:13,710
yeah

00:32:17,040 --> 00:32:22,580
yes sir ok

00:32:23,059 --> 00:32:25,090
Oh

00:32:36,580 --> 00:32:40,560
explain just doesn't

00:32:38,130 --> 00:32:42,780
okay you put all the qualifications on

00:32:40,560 --> 00:32:45,570
the query and you have the population

00:32:42,780 --> 00:32:49,820
age and all that stuff is there overhead

00:32:45,570 --> 00:32:49,820
to all that stuff afterwards yes

00:33:00,860 --> 00:33:04,670
can I paraphrase and say if you don't

00:33:03,170 --> 00:33:07,480
put all the qualifications on can I get

00:33:04,670 --> 00:33:09,380
the data back faster from the server yes

00:33:07,480 --> 00:33:11,750
the trouble is if you want all those

00:33:09,380 --> 00:33:13,250
qualifications it's a lot easier to have

00:33:11,750 --> 00:33:14,540
the power of the database do that for

00:33:13,250 --> 00:33:16,790
you than it is to feed it into your

00:33:14,540 --> 00:33:18,370
application and iterate over that data

00:33:16,790 --> 00:33:20,570
to cut out the stuff you don't want

00:33:18,370 --> 00:33:23,770
that's where the database power works

00:33:20,570 --> 00:33:28,610
for you unfortunately if you want speed

00:33:23,770 --> 00:33:30,380
you kind of have to do that and the time

00:33:28,610 --> 00:33:32,030
can actually be pretty harness because

00:33:30,380 --> 00:33:33,980
sometimes you have one or two temp

00:33:32,030 --> 00:33:35,270
tables that have to be created that

00:33:33,980 --> 00:33:36,950
means you might have to go after the

00:33:35,270 --> 00:33:40,880
operating system and say hey get me a

00:33:36,950 --> 00:33:49,130
temp table and and it can get pretty

00:33:40,880 --> 00:33:54,860
massive yes sir joining so clear is

00:33:49,130 --> 00:33:58,669
there some way to in effect index that

00:33:54,860 --> 00:34:01,940
sound query so that I can be joining out

00:33:58,669 --> 00:34:04,340
an index index well the old joke used to

00:34:01,940 --> 00:34:06,919
be that post-crescent do joins and we

00:34:04,340 --> 00:34:08,690
didn't do some queries that's changed a

00:34:06,919 --> 00:34:13,340
lot the last couple of releases for both

00:34:08,690 --> 00:34:17,510
postgres in mysql with 57 you actually

00:34:13,340 --> 00:34:19,490
do get an index out of the sub-query it

00:34:17,510 --> 00:34:20,629
may not still be as fast as a join if

00:34:19,490 --> 00:34:22,790
you do a straight join rather than a

00:34:20,629 --> 00:34:24,859
sub-query you have to play with that but

00:34:22,790 --> 00:34:27,460
you do get the benefits of indexes out

00:34:24,859 --> 00:34:27,460
of sub queries now

00:34:30,200 --> 00:34:37,050
was it clear do you think to everybody

00:34:32,460 --> 00:34:40,980
on why the extra where clauses were not

00:34:37,050 --> 00:34:43,830
counted until the end I'm hoping the

00:34:40,980 --> 00:34:45,900
where Clause stuff let's go back and say

00:34:43,830 --> 00:34:48,420
if it's a simple query the where Clause

00:34:45,900 --> 00:34:52,100
elements will of course reduce the

00:34:48,420 --> 00:34:52,100
number yeah

00:34:54,400 --> 00:34:59,390
ya if ya this is this is where dba's

00:34:57,980 --> 00:35:01,520
really earned their money at the big

00:34:59,390 --> 00:35:03,350
shops is because they're saying well

00:35:01,520 --> 00:35:06,080
maybe I don't want to index all a

00:35:03,350 --> 00:35:09,440
population maybe I just want to index

00:35:06,080 --> 00:35:10,730
the leading four numbers so I make sure

00:35:09,440 --> 00:35:13,100
that I get the folks who are in the

00:35:10,730 --> 00:35:14,840
millions instead of all that there's all

00:35:13,100 --> 00:35:18,110
sorts of games you can play with indexes

00:35:14,840 --> 00:35:20,300
to guess at what's real funny in the

00:35:18,110 --> 00:35:21,890
Western world rather than search on

00:35:20,300 --> 00:35:23,750
someone's entire last name you can

00:35:21,890 --> 00:35:25,250
usually get eighty five percent accuracy

00:35:23,750 --> 00:35:28,370
with the first four or five letters of

00:35:25,250 --> 00:35:30,590
their name does not work in China does

00:35:28,370 --> 00:35:33,160
not work in Japan and I've been told it

00:35:30,590 --> 00:35:35,330
doesn't work in some parts of Africa but

00:35:33,160 --> 00:35:38,620
there are little games like that you can

00:35:35,330 --> 00:35:38,620
play with your data to speed things up

00:35:47,150 --> 00:35:55,050
well until 56 57 we told people take

00:35:51,330 --> 00:35:57,150
your sub queries that you you have and

00:35:55,050 --> 00:36:01,440
turn them into joints because we didn't

00:35:57,150 --> 00:36:05,450
do sub queries very well 56 especially

00:36:01,440 --> 00:36:07,950
57 really do sub query optimization now

00:36:05,450 --> 00:36:09,900
in the past was kind of like oh we've

00:36:07,950 --> 00:36:11,280
got down to the one you put you outline

00:36:09,900 --> 00:36:13,290
on the football field we're just going

00:36:11,280 --> 00:36:17,730
to cut because we don't know how to do

00:36:13,290 --> 00:36:27,420
that once brute force the rest so it

00:36:17,730 --> 00:36:32,369
doesn't now 56 and 57 yeah yes sir the

00:36:27,420 --> 00:36:36,030
test databases if you go to

00:36:32,369 --> 00:36:38,460
documentation dev classical com search

00:36:36,030 --> 00:36:43,310
down at the bottom or the easiest thing

00:36:38,460 --> 00:36:43,310
is type in MySQL rural database in 0 DB

00:36:47,840 --> 00:36:50,990
yes sir

00:36:53,290 --> 00:36:58,350
try to create you a sub-query

00:37:00,150 --> 00:37:10,269
yeah because we're creating a view with

00:37:08,289 --> 00:37:14,199
a sub-query I don't know how well that

00:37:10,269 --> 00:37:15,789
perform and the trouble is 51 doesn't

00:37:14,199 --> 00:37:18,400
really do sub queries all that well and

00:37:15,789 --> 00:37:21,130
we don't handle materialized views even

00:37:18,400 --> 00:37:23,829
in 57 so I'd have to see the code and

00:37:21,130 --> 00:37:27,640
play with it to be able to tell you how

00:37:23,829 --> 00:37:34,809
it goes is there any way we get you two

00:37:27,640 --> 00:37:36,400
up to 55 56 yeah a couple months ago I

00:37:34,809 --> 00:37:38,289
ran to someone who stuck on for one

00:37:36,400 --> 00:37:40,059
because the contract wrote an explicitly

00:37:38,289 --> 00:37:45,489
this will be written on top of my school

00:37:40,059 --> 00:37:47,440
for one and well it's a very good paying

00:37:45,489 --> 00:37:51,459
job in the guys close to retirement and

00:37:47,440 --> 00:37:54,880
really doesn't as a matter anything else

00:37:51,459 --> 00:37:56,650
sir once again I thank you because I

00:37:54,880 --> 00:37:59,499
know this is the driest talk in the

00:37:56,650 --> 00:38:03,789
entire weekend series and it's hard to

00:37:59,499 --> 00:38:05,890
convey to programmers the value of this

00:38:03,789 --> 00:38:08,529
because this saves you so much time and

00:38:05,890 --> 00:38:10,119
effort later on and it's a real pain the

00:38:08,529 --> 00:38:12,609
butt to get started but it does pay off

00:38:10,119 --> 00:38:15,099
yes sir one one thing I was going to

00:38:12,609 --> 00:38:16,390
point out earlier when you were showing

00:38:15,099 --> 00:38:18,279
you know like for example a simple

00:38:16,390 --> 00:38:20,019
prairie you know and it showed the

00:38:18,279 --> 00:38:22,380
execution time and then you got two more

00:38:20,019 --> 00:38:24,950
complicated query that was similar

00:38:22,380 --> 00:38:27,410
unfortunately the execution time with 0

00:38:24,950 --> 00:38:28,579
zero I was going to point out that

00:38:27,410 --> 00:38:30,619
people should look of course at the

00:38:28,579 --> 00:38:31,910
execution time in addition to of course

00:38:30,619 --> 00:38:36,760
the number of rows in things like that

00:38:31,910 --> 00:38:39,829
but because it's an agree cash yeah it's

00:38:36,760 --> 00:38:43,010
it explains the writing the query that

00:38:39,829 --> 00:38:45,680
way yeah i'm sure this case side but at

00:38:43,010 --> 00:38:47,119
the same time too if you are running the

00:38:45,680 --> 00:38:49,369
period oh and you're trying to look at

00:38:47,119 --> 00:38:50,540
the execution time you know like the

00:38:49,369 --> 00:38:53,109
second time through you could always

00:38:50,540 --> 00:38:55,760
reset the pre-attached not busy server

00:38:53,109 --> 00:38:59,960
because otherwise you know that results

00:38:55,760 --> 00:39:03,890
that yeah there's a whole bunch of work

00:38:59,960 --> 00:39:05,780
on statistical testing of queries we

00:39:03,890 --> 00:39:08,510
have a lovely gentleman named Dimitri

00:39:05,780 --> 00:39:11,660
cava Chuck who works for us and he

00:39:08,510 --> 00:39:13,339
retrieved me runs these things many

00:39:11,660 --> 00:39:15,050
iterations just to make sure that the

00:39:13,339 --> 00:39:18,020
query times the response times he's

00:39:15,050 --> 00:39:20,869
saying you know there's you know someone

00:39:18,020 --> 00:39:22,160
hasn't popped an ldap query or mail

00:39:20,869 --> 00:39:24,740
hasn't gone through a system make sure

00:39:22,160 --> 00:39:27,109
they balance out and to get that

00:39:24,740 --> 00:39:36,650
consistent as a is a also a work of art

00:39:27,109 --> 00:39:38,780
to get that really well we don't

00:39:36,650 --> 00:39:40,369
formally have a set of tests queries to

00:39:38,780 --> 00:39:42,020
go with our test databases but if you

00:39:40,369 --> 00:39:44,030
look at our documentation you'll see a

00:39:42,020 --> 00:39:47,480
whole bunch of you know do this do this

00:39:44,030 --> 00:39:56,170
don't do this type of examples but as a

00:39:47,480 --> 00:39:56,170
formal set of queries no yes Peter

00:40:03,370 --> 00:40:09,040
can make sure what the my school

00:40:13,119 --> 00:40:20,330
yes thank you for the planted question

00:40:17,500 --> 00:40:22,160
last two weeks I've been able to sit

00:40:20,330 --> 00:40:24,410
next to a gentleman named Jim Miller

00:40:22,160 --> 00:40:28,010
who's one of our engineers and he's our

00:40:24,410 --> 00:40:30,970
quality engineer guru he runs thousands

00:40:28,010 --> 00:40:32,869
of tests each night on a whole slew of

00:40:30,970 --> 00:40:37,339
queries he's picked up over the years

00:40:32,869 --> 00:40:40,490
and anytime there's a patch made to the

00:40:37,339 --> 00:40:43,460
to MySQL he runs regression tests

00:40:40,490 --> 00:40:45,470
against that and we have roughly 40

00:40:43,460 --> 00:40:47,300
other people who work with him that once

00:40:45,470 --> 00:40:50,300
he finds something's running slower or

00:40:47,300 --> 00:40:52,880
not as fast as it should they mainly dig

00:40:50,300 --> 00:40:55,430
into it to try to do it and every night

00:40:52,880 --> 00:40:57,680
I forget how many thousands of queries

00:40:55,430 --> 00:40:59,570
they run and he has a beautiful displays

00:40:57,680 --> 00:41:02,450
he developed I wish I could show it all

00:40:59,570 --> 00:41:04,880
so there's something even off by a tenth

00:41:02,450 --> 00:41:11,359
of a percent he knows about it as soon

00:41:04,880 --> 00:41:12,650
as the test finishes a lot of me

00:41:11,359 --> 00:41:13,849
probably wouldn't want to see because a

00:41:12,650 --> 00:41:17,869
lot of those queries are probably like

00:41:13,849 --> 00:41:21,890
TPC benchmarks ordering customer data

00:41:17,869 --> 00:41:25,369
that's way out of date it's one of those

00:41:21,890 --> 00:41:27,349
things where we know where the queries

00:41:25,369 --> 00:41:29,150
that hurt us are and the sweet spot

00:41:27,349 --> 00:41:30,560
queries are and we keep testing over and

00:41:29,150 --> 00:41:34,599
over again to make sure we don't regress

00:41:30,560 --> 00:41:34,599
anywhere so

00:41:36,160 --> 00:41:40,940
they're not available and they'd be

00:41:38,119 --> 00:41:46,609
probably boring as hell am NOT useful to

00:41:40,940 --> 00:41:48,710
anyone else but him so you just need

00:41:46,609 --> 00:41:51,579
thousands of queries if you want to use

00:41:48,710 --> 00:41:51,579
for tests or something like that

00:42:04,650 --> 00:42:13,829
yeah when I worked for another database

00:42:09,270 --> 00:42:15,180
company we were looking through all

00:42:13,829 --> 00:42:18,119
sorts of different data sets and just

00:42:15,180 --> 00:42:19,710
making up stuff all the time and I never

00:42:18,119 --> 00:42:21,869
really found a good sweet of just open

00:42:19,710 --> 00:42:24,299
queries of stuff to try out for

00:42:21,869 --> 00:42:31,079
examining and if you do find one please

00:42:24,299 --> 00:42:33,230
let me know any other questions or yes

00:42:31,079 --> 00:42:33,230
sir

00:42:35,010 --> 00:42:41,560
these guys looking to switch oh you're

00:42:39,970 --> 00:42:49,030
welcome you're welcome them yes thank

00:42:41,560 --> 00:42:50,170
you yeah well the first step is to admit

00:42:49,030 --> 00:42:55,350
that you have a problem and you're

00:42:50,170 --> 00:42:55,350
coming to mysql is the first step okay

00:42:59,310 --> 00:43:13,600
yes yeah okay the first thing I suggest

00:43:11,440 --> 00:43:16,390
is get a copy of masculine twitch is

00:43:13,600 --> 00:43:18,700
free and it has a conversion tool that I

00:43:16,390 --> 00:43:20,590
know works with sequel server and I

00:43:18,700 --> 00:43:23,220
think it runs with sybase but I'm not a

00:43:20,590 --> 00:43:23,220
hundred percent sure

00:43:35,060 --> 00:43:40,310
so what I am hoping is mostly rod

00:43:38,660 --> 00:43:42,830
without me having to go back and change

00:43:40,310 --> 00:43:45,050
things yeah if you keep to the answering

00:43:42,830 --> 00:43:46,490
standard mostly run it's the stuff that

00:43:45,050 --> 00:43:53,170
doesn't fit in the mostly that's going

00:43:46,490 --> 00:43:53,170
to make you earn your paycheck yes

00:43:57,180 --> 00:44:04,120
please try me no TV for all your tables

00:44:01,690 --> 00:44:08,400
should always be in LED unless you

00:44:04,120 --> 00:44:08,400
really know you

00:44:11,630 --> 00:44:17,549
he is my sequel danger yes yeah you

00:44:16,170 --> 00:44:20,579
should even said it the figuration

00:44:17,549 --> 00:44:22,529
father DePaul engine type is in MVP so

00:44:20,579 --> 00:44:24,900
if somebody accidentally creates a table

00:44:22,529 --> 00:44:28,529
and doesn't specify the engine because

00:44:24,900 --> 00:44:30,869
otherwise it's going to default yeah

00:44:28,529 --> 00:44:35,369
well 56 and later which hopefully he's

00:44:30,869 --> 00:44:38,069
going to 56 or 57 the other gentleman or

00:44:35,369 --> 00:44:41,299
a table if you talk to him are you local

00:44:38,069 --> 00:44:43,799
to this area or raleigh or greenville

00:44:41,299 --> 00:44:46,079
well he's in raleigh and he can easily

00:44:43,799 --> 00:44:48,479
make the drive and he does a lot of

00:44:46,079 --> 00:44:50,999
conversions the conversion itself i'm

00:44:48,479 --> 00:44:52,799
doing a lot of microsoft stuff lately it

00:44:50,999 --> 00:44:54,680
goes very well except for the stuff that

00:44:52,799 --> 00:44:56,640
fits in that one two percent and

00:44:54,680 --> 00:44:58,440
unfortunately sometimes that one two

00:44:56,640 --> 00:45:00,799
percent is a onerous mountain of stuff

00:44:58,440 --> 00:45:00,799
decline

00:45:12,260 --> 00:45:19,160
and we have exactly one story okay you

00:45:17,100 --> 00:45:23,760
should be good there no trigger is no

00:45:19,160 --> 00:45:27,470
actually we have turn that triggers okay

00:45:23,760 --> 00:45:30,360
so correct I don't know about my skillet

00:45:27,470 --> 00:45:32,940
about side base but sequel server has a

00:45:30,360 --> 00:45:40,010
weird quoting thing remains in square

00:45:32,940 --> 00:45:40,010
brackets donít even support that um no

00:45:42,590 --> 00:45:49,560
yeah yeah Microsoft decided to form at

00:45:47,940 --> 00:45:51,060
some of their stuff different from the

00:45:49,560 --> 00:45:56,370
original sybase product just to show

00:45:51,060 --> 00:45:58,410
that they were different that's yeah I'm

00:45:56,370 --> 00:46:00,450
sure sequel server and one other

00:45:58,410 --> 00:46:02,790
database that's written in Loris LeBeau

00:46:00,450 --> 00:46:05,420
via that you need the lower suburbian

00:46:02,790 --> 00:46:10,430
dialect character set to to actually

00:46:05,420 --> 00:46:14,040
take advantage of that but it's it's a

00:46:10,430 --> 00:46:15,930
microsoft ism the funny thing for me is

00:46:14,040 --> 00:46:18,090
I'm getting a lot of Microsoft shows now

00:46:15,930 --> 00:46:20,460
and Microsoft just went to an open

00:46:18,090 --> 00:46:22,890
source open source programming framework

00:46:20,460 --> 00:46:25,380
based on laravel which is a PHP

00:46:22,890 --> 00:46:27,600
framework and you go to these shows and

00:46:25,380 --> 00:46:31,680
you say well if you're running an open

00:46:27,600 --> 00:46:35,610
source framework on PHP why are you not

00:46:31,680 --> 00:46:37,170
running an open source database yeah

00:46:35,610 --> 00:46:38,760
they're their new framework

00:46:37,170 --> 00:46:39,960
unfortunately the name escapes me right

00:46:38,760 --> 00:46:42,330
now I want to call it entity or

00:46:39,960 --> 00:46:44,900
something like that it's basically

00:46:42,330 --> 00:46:44,900
laravel

00:46:48,370 --> 00:46:54,880
are they just where he asked when we do

00:46:52,670 --> 00:46:57,920
agree table statement but yeah or

00:46:54,880 --> 00:46:59,360
queries well that's part of the ANSI

00:46:57,920 --> 00:47:01,070
standard you can't put single quotes or

00:46:59,360 --> 00:47:10,760
double quotes around when you create

00:47:01,070 --> 00:47:12,080
fail it's what yeah you you don't you

00:47:10,760 --> 00:47:13,790
don't have to but some of the microsoft

00:47:12,080 --> 00:47:17,360
stuff has brackets in there that kind of

00:47:13,790 --> 00:47:20,300
freaks everybody out the i double quote

00:47:17,360 --> 00:47:22,100
should parse right through now that what

00:47:20,300 --> 00:47:25,100
really hurts is you have programmers

00:47:22,100 --> 00:47:26,600
like me that do one back single quote

00:47:25,100 --> 00:47:28,040
and then a regular single quote and they

00:47:26,600 --> 00:47:32,830
can't figure out for two hours what he

00:47:28,040 --> 00:47:32,830
did wrong but that's just me

00:47:42,700 --> 00:47:46,440
nice visuals down

00:47:49,200 --> 00:47:53,010
that was just a question about single

00:47:51,720 --> 00:47:55,829
quotes versus double quotes versus

00:47:53,010 --> 00:47:59,640
brackets and queries so nothing too

00:47:55,829 --> 00:48:01,020
amazing well bless you all for sitting

00:47:59,640 --> 00:48:03,980
through this i know it's drier than heck

00:48:01,020 --> 00:48:03,980
and thank you for coming

00:48:34,510 --> 00:48:38,780
your customers rely on your website or

00:48:37,280 --> 00:48:41,180
application if it's slower

00:48:38,780 --> 00:48:44,120
non-responsive it infuriates your users

00:48:41,180 --> 00:48:45,950
and costs you money keeping your

00:48:44,120 --> 00:48:49,430
business critical systems humming along

00:48:45,950 --> 00:48:52,280
requires insight into what they're doing

00:48:49,430 --> 00:48:54,260
your system metrics tell stories stories

00:48:52,280 --> 00:48:56,750
that can reveal performance bottlenecks

00:48:54,260 --> 00:48:58,670
resource limitations and other problems

00:48:56,750 --> 00:49:00,589
but how do you keep an eye on all of

00:48:58,670 --> 00:49:03,200
your systems performance metrics in

00:49:00,589 --> 00:49:06,050
real-time and record this data for later

00:49:03,200 --> 00:49:08,030
analysis enter longview the new way to

00:49:06,050 --> 00:49:10,069
see what's really going on under the

00:49:08,030 --> 00:49:12,170
hood the longview dashboard lets you

00:49:10,069 --> 00:49:14,180
visualize the status of all your systems

00:49:12,170 --> 00:49:16,910
providing you with a bird's-eye view of

00:49:14,180 --> 00:49:20,030
your entire fleet you can sort by cpu

00:49:16,910 --> 00:49:22,490
memory swap processes load and network

00:49:20,030 --> 00:49:25,069
usage click a specific system to access

00:49:22,490 --> 00:49:27,079
its individual dashboard then click and

00:49:25,069 --> 00:49:30,079
drag to zoom in on chokepoints and get

00:49:27,079 --> 00:49:32,059
more detail comprehensive network data

00:49:30,079 --> 00:49:34,760
including inbound and outbound traffic

00:49:32,059 --> 00:49:36,349
is available on the network tab and disk

00:49:34,760 --> 00:49:38,240
rights and free space on the disk

00:49:36,349 --> 00:49:41,089
stabbed while the process Explorer

00:49:38,240 --> 00:49:43,640
displays usage statistics for individual

00:49:41,089 --> 00:49:45,800
processes the system info tab shows

00:49:43,640 --> 00:49:48,050
listening services active connections

00:49:45,800 --> 00:49:50,180
and available updates adding long view

00:49:48,050 --> 00:49:51,859
to a system is easy just click the

00:49:50,180 --> 00:49:54,020
button copy the one line installation

00:49:51,859 --> 00:49:56,450
command then run the command on your

00:49:54,020 --> 00:49:58,160
linux system to complete the process the

00:49:56,450 --> 00:50:00,349
agent will begin collecting data and

00:49:58,160 --> 00:50:02,190
sending it to longview then the graphs

00:50:00,349 --> 00:50:04,740
start rolling

00:50:02,190 --> 00:50:07,140
use longview to gain visibility into

00:50:04,740 --> 00:50:10,850
your servers so when your website or app

00:50:07,140 --> 00:50:10,850

YouTube URL: https://www.youtube.com/watch?v=A6hpKyW49jY


