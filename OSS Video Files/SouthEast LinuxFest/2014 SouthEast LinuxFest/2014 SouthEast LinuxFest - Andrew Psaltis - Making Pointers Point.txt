Title: 2014 SouthEast LinuxFest - Andrew Psaltis - Making Pointers Point
Publication date: 2015-05-18
Playlist: 2014 SouthEast LinuxFest
Description: 
	2014 SouthEast LinuxFest
Andrew Psaltis
Making Pointers Point
Captions: 
	00:00:00,000 --> 00:00:05,339
the following presentation was recorded

00:00:02,490 --> 00:00:08,189
the 2014 southeast linux fest in

00:00:05,339 --> 00:00:11,070
charlotte north carolina it is licensed

00:00:08,189 --> 00:00:15,150
under a creative commons license for

00:00:11,070 --> 00:00:18,330
more information visit www.fcn expense

00:00:15,150 --> 00:00:20,310
org the southeast linux fest would like

00:00:18,330 --> 00:00:22,769
to thank the following diamond sponsors

00:00:20,310 --> 00:00:26,189
in 2014 for helping make these videos

00:00:22,769 --> 00:00:29,960
possible i like to introduce mr. andrew

00:00:26,189 --> 00:00:32,790
Psaltis a software engineer for akamai

00:00:29,960 --> 00:00:37,850
incorporated assault to Psaltis I'm

00:00:32,790 --> 00:00:41,790
sorry I we know him on IRC by his

00:00:37,850 --> 00:00:44,820
chemical formula but anyway andrew is a

00:00:41,790 --> 00:00:47,460
good speaker and a good good friend and

00:00:44,820 --> 00:00:53,120
also good shot with his nerf gun so

00:00:47,460 --> 00:00:59,730
watch out and for reference it's uh it's

00:00:53,120 --> 00:01:01,440
right here okay so i am going to i as

00:00:59,730 --> 00:01:03,059
well as i said i am major consult this

00:01:01,440 --> 00:01:05,309
and i'm going to be talking to a little

00:01:03,059 --> 00:01:07,860
bit about making pointers point in

00:01:05,309 --> 00:01:11,909
reference to pointers one of the very

00:01:07,860 --> 00:01:14,520
common things and see i have slides it

00:01:11,909 --> 00:01:18,180
goes so first things first to be a

00:01:14,520 --> 00:01:20,220
little bit about see since um maybe not

00:01:18,180 --> 00:01:24,750
all you know it actually before how you

00:01:20,220 --> 00:01:27,000
actually do know Cee Lo's to you that's

00:01:24,750 --> 00:01:31,140
affected how people taking a computer

00:01:27,000 --> 00:01:33,869
architecture class at some point about

00:01:31,140 --> 00:01:35,100
the same okay well I'm going to be

00:01:33,869 --> 00:01:36,150
getting into a little bit about see I

00:01:35,100 --> 00:01:38,159
want to be take getting into what about

00:01:36,150 --> 00:01:40,110
computer architecture it's going to be

00:01:38,159 --> 00:01:43,350
probably sound like a bunch of college

00:01:40,110 --> 00:01:45,119
lectures smashed together unfortunately

00:01:43,350 --> 00:01:46,799
a lot of stuff is kind of academic and

00:01:45,119 --> 00:01:50,070
it can't really be avoid I'll try to

00:01:46,799 --> 00:01:52,409
make it funny when I can so um Cece was

00:01:50,070 --> 00:01:54,840
a programming language written by a dude

00:01:52,409 --> 00:01:57,240
named dennis ritchie at bell labs in the

00:01:54,840 --> 00:02:01,469
late 60s and early 70s he did a lot of

00:01:57,240 --> 00:02:06,119
other things too and like chunks of unix

00:02:01,469 --> 00:02:07,829
if not all of it and it's very old and

00:02:06,119 --> 00:02:11,630
still around today because it is very

00:02:07,829 --> 00:02:14,540
easy to take c code and convert it into

00:02:11,630 --> 00:02:16,840
computer machine instructions since most

00:02:14,540 --> 00:02:19,730
of that is just about doing math and

00:02:16,840 --> 00:02:23,210
computing memory address offsets most of

00:02:19,730 --> 00:02:25,870
C is somehow encapsulation of doing math

00:02:23,210 --> 00:02:28,250
and computing memory address offsets

00:02:25,870 --> 00:02:30,320
because of it because of the ease of

00:02:28,250 --> 00:02:32,060
conversion between it and machine

00:02:30,320 --> 00:02:33,590
language instructions it is very fast

00:02:32,060 --> 00:02:36,350
and that's a lot of performant

00:02:33,590 --> 00:02:38,680
performance applications are written to

00:02:36,350 --> 00:02:41,570
it written with it such as openssl

00:02:38,680 --> 00:02:44,960
networking damon's other programming

00:02:41,570 --> 00:02:47,120
languages and this is just really really

00:02:44,960 --> 00:02:51,080
common in fact a lot of many programming

00:02:47,120 --> 00:02:52,640
languages you see to bind or you see as

00:02:51,080 --> 00:02:54,170
a binding language say you need to make

00:02:52,640 --> 00:02:55,850
a make up for in function call it's

00:02:54,170 --> 00:03:03,380
almost always goes to see it's like a

00:02:55,850 --> 00:03:05,660
universal barrier sorts all right that

00:03:03,380 --> 00:03:09,290
out of the way well that's a school a

00:03:05,660 --> 00:03:12,320
question what's a pointer well example

00:03:09,290 --> 00:03:14,360
of a pointer would be it would look

00:03:12,320 --> 00:03:22,040
better if a colors weren't inverted but

00:03:14,360 --> 00:03:27,260
a pointer such as this it points or

00:03:22,040 --> 00:03:29,780
would point so it's kind of ghostly but

00:03:27,260 --> 00:03:31,490
that's supposed to be a pointer dog I

00:03:29,780 --> 00:03:35,330
have a pointer here i'm going to go

00:03:31,490 --> 00:03:37,670
point at the pointer so it's all

00:03:35,330 --> 00:03:40,400
pointing it's all pointing all the way

00:03:37,670 --> 00:03:43,310
down so let's give you a little better

00:03:40,400 --> 00:03:45,230
answer here the pointer is a value and

00:03:43,310 --> 00:03:47,840
most often case is an integer that

00:03:45,230 --> 00:03:52,970
contains a memory address that points to

00:03:47,840 --> 00:03:54,350
another value for the for the person who

00:03:52,970 --> 00:03:56,900
first sees that excavation the first

00:03:54,350 --> 00:03:59,200
time it just doesn't make any sense it

00:03:56,900 --> 00:04:01,610
didn't make any sense to me so i was

00:03:59,200 --> 00:04:03,560
things like so how many of you don't

00:04:01,610 --> 00:04:11,000
know what pointers already were before i

00:04:03,560 --> 00:04:12,709
keep in here okay well um generally it's

00:04:11,000 --> 00:04:15,290
that is not a useful answer so I'm just

00:04:12,709 --> 00:04:19,820
going to I'm going to be explaining more

00:04:15,290 --> 00:04:21,410
about that later but first let's get a

00:04:19,820 --> 00:04:23,280
little outline here I want to be talking

00:04:21,410 --> 00:04:25,889
to a little bit thing a little bit of

00:04:23,280 --> 00:04:27,810
computer memory getting into the meat of

00:04:25,889 --> 00:04:30,240
things like point exactly what pointers

00:04:27,810 --> 00:04:34,080
are as a explanation that you already

00:04:30,240 --> 00:04:37,830
know generally how some schemes on

00:04:34,080 --> 00:04:40,830
memory allocation and otherwise to do it

00:04:37,830 --> 00:04:46,650
other than the two main ones and some

00:04:40,830 --> 00:04:48,480
resources and details so you know I

00:04:46,650 --> 00:04:49,740
didn't know I wasn't planning I having

00:04:48,480 --> 00:04:54,060
to invert the color so everything looks

00:04:49,740 --> 00:04:56,310
really rolled ghostly so typically when

00:04:54,060 --> 00:05:00,300
one thinks of memory one inevitably goes

00:04:56,310 --> 00:05:02,880
and thinks of just Ram however it's a

00:05:00,300 --> 00:05:05,880
lot more complicated it's a bit more

00:05:02,880 --> 00:05:08,640
complicated than that however it's still

00:05:05,880 --> 00:05:10,980
a big chunk of it so um first things

00:05:08,640 --> 00:05:13,770
let's get down to a word hero a come

00:05:10,980 --> 00:05:15,360
whenever you hear start dealing with the

00:05:13,770 --> 00:05:18,690
complexities mariola start hearing that

00:05:15,360 --> 00:05:23,520
word locality and it means when you have

00:05:18,690 --> 00:05:25,770
a you have a work if you were to access

00:05:23,520 --> 00:05:28,110
a point in memory you are going you are

00:05:25,770 --> 00:05:30,210
likely to deuce access that same point

00:05:28,110 --> 00:05:32,729
in memory again in the near future and

00:05:30,210 --> 00:05:34,919
also these stuff around it in the near

00:05:32,729 --> 00:05:36,840
future this makes sense this was useful

00:05:34,919 --> 00:05:39,630
if you just go instead of pulling just a

00:05:36,840 --> 00:05:42,180
single chunk of stuff you need off of

00:05:39,630 --> 00:05:44,190
disk said you just pull a larger chunk

00:05:42,180 --> 00:05:45,300
of it because you will double certainly

00:05:44,190 --> 00:05:46,890
use the stuff around it in the near

00:05:45,300 --> 00:05:48,240
future say you're not going to say if

00:05:46,890 --> 00:05:49,830
you have a program there you have a

00:05:48,240 --> 00:05:52,650
program you don't want to just load the

00:05:49,830 --> 00:05:55,950
individual instructions one at a time it

00:05:52,650 --> 00:05:58,169
would take forever so you just load jump

00:05:55,950 --> 00:06:02,940
to the program actually cuz is usually

00:05:58,169 --> 00:06:06,630
done in what's called pages and leads us

00:06:02,940 --> 00:06:08,370
to this this little handy dandy thing

00:06:06,630 --> 00:06:10,830
everyone likes to call memory hierarchy

00:06:08,370 --> 00:06:12,720
this is in this is often in operating

00:06:10,830 --> 00:06:17,039
systems and computer architecture text

00:06:12,720 --> 00:06:20,010
books so what how this has played out is

00:06:17,039 --> 00:06:23,669
that often you start from everything is

00:06:20,010 --> 00:06:27,630
on disk of some sort of like wha a large

00:06:23,669 --> 00:06:29,940
persistent storage it moves up into less

00:06:27,630 --> 00:06:32,210
per system storage at gets smaller as it

00:06:29,940 --> 00:06:41,180
go to the way up up

00:06:32,210 --> 00:06:43,340
what gets he's getting its so as you get

00:06:41,180 --> 00:06:45,979
further up capacity goes down

00:06:43,340 --> 00:06:47,930
significantly so you disc can be if

00:06:45,979 --> 00:06:50,990
these days can be consist of hundreds of

00:06:47,930 --> 00:06:54,199
gigabytes of terabytes ram is gigabytes

00:06:50,990 --> 00:06:56,660
cash is usually charge you starting to

00:06:54,199 --> 00:06:58,610
the kilobytes range and when you get to

00:06:56,660 --> 00:07:01,550
the CPU registers you are usually home

00:06:58,610 --> 00:07:04,550
only limited to a relatively small

00:07:01,550 --> 00:07:06,889
number of bites you you will certainly

00:07:04,550 --> 00:07:10,099
cannot fit a full program into the

00:07:06,889 --> 00:07:11,660
registers and register journals from our

00:07:10,099 --> 00:07:13,699
persistent storage so everything you

00:07:11,660 --> 00:07:15,560
have to get everything from the disk and

00:07:13,699 --> 00:07:19,070
get it into the register so what the CPU

00:07:15,560 --> 00:07:22,849
can go and twiddle the bits and do math

00:07:19,070 --> 00:07:38,169
and all the stuff that CPUs are ought to

00:07:22,849 --> 00:07:41,750
do so the term actual memory could be in

00:07:38,169 --> 00:07:44,570
actually many places so so in Linux you

00:07:41,750 --> 00:07:47,449
often have a swap file so you could have

00:07:44,570 --> 00:07:49,820
memory you cadet memory I'm actually

00:07:47,449 --> 00:07:52,430
random memory on the disk and every

00:07:49,820 --> 00:07:55,250
memory here remembering in here this is

00:07:52,430 --> 00:07:58,610
all made so it is transparent to the

00:07:55,250 --> 00:08:00,409
user applications because that as you

00:07:58,610 --> 00:08:04,130
can probably guess it as a very messy

00:08:00,409 --> 00:08:05,690
subject so these days every we all let

00:08:04,130 --> 00:08:08,810
the operating system kernel do it in it

00:08:05,690 --> 00:08:13,430
is done often using a scheme called

00:08:08,810 --> 00:08:18,020
virtual memory so what if you have a

00:08:13,430 --> 00:08:20,419
while addition to having the process of

00:08:18,020 --> 00:08:23,030
getting information from disk and moving

00:08:20,419 --> 00:08:24,380
it up to the CPU you also have to worry

00:08:23,030 --> 00:08:26,060
about the fact that there are other

00:08:24,380 --> 00:08:28,280
things running on total things that need

00:08:26,060 --> 00:08:32,649
to be running on that cpu GPU is our

00:08:28,280 --> 00:08:34,969
timeshare you can't just you just can't

00:08:32,649 --> 00:08:36,770
so you can't just make assumptions about

00:08:34,969 --> 00:08:39,169
what memory is being used by each

00:08:36,770 --> 00:08:41,240
application you can't either you can't

00:08:39,169 --> 00:08:43,430
set that initially in the application

00:08:41,240 --> 00:08:45,260
because you don't necessarily know what

00:08:43,430 --> 00:08:48,530
the memory usage is going to be

00:08:45,260 --> 00:08:51,770
at runtime you can never you can never

00:08:48,530 --> 00:08:54,980
really tell that in general so what

00:08:51,770 --> 00:08:58,520
happened to what is to assume is that

00:08:54,980 --> 00:09:01,160
the operating system this or the program

00:08:58,520 --> 00:09:02,390
assumes that it has all the memory

00:09:01,160 --> 00:09:05,600
available in the world to it you can

00:09:02,390 --> 00:09:07,220
take whatever it can take like it has a

00:09:05,600 --> 00:09:09,440
full addressable space in the memory in

00:09:07,220 --> 00:09:13,490
case of 32-bit systems this is a

00:09:09,440 --> 00:09:18,460
four-figure bytes up 22 to 32 with

00:09:13,490 --> 00:09:20,900
64-bit systems it is a 2 2 64 which is

00:09:18,460 --> 00:09:22,640
more yeah more memory that you can

00:09:20,900 --> 00:09:28,280
generally put into a computer these days

00:09:22,640 --> 00:09:31,550
or single computer these days so there

00:09:28,280 --> 00:09:32,990
are times when you have like the

00:09:31,550 --> 00:09:35,870
physical memory can be of a different

00:09:32,990 --> 00:09:37,610
size say say if you are bringing a

00:09:35,870 --> 00:09:40,880
32-bit system with only 4 gigabytes of

00:09:37,610 --> 00:09:42,890
memory then you were in Linux who

00:09:40,880 --> 00:09:44,660
generally have a swap partition so you

00:09:42,890 --> 00:09:46,520
would so we actually have more memory

00:09:44,660 --> 00:09:48,470
available than just the four gigabytes

00:09:46,520 --> 00:09:50,210
that would be available to the

00:09:48,470 --> 00:09:52,340
application and thus when the

00:09:50,210 --> 00:09:54,770
application requests requests its memory

00:09:52,340 --> 00:09:59,180
it is up to the operating system to go

00:09:54,770 --> 00:10:01,700
and give it the memory so i might and it

00:09:59,180 --> 00:10:06,500
also might not necessarily be a direct

00:10:01,700 --> 00:10:10,040
mapping into thanks Alma mind Anjali be

00:10:06,500 --> 00:10:11,900
a crack rapping it might not be the

00:10:10,040 --> 00:10:13,130
visual personal murders might not be the

00:10:11,900 --> 00:10:15,110
same as the address in the physical

00:10:13,130 --> 00:10:18,800
memory for example it might be in swap

00:10:15,110 --> 00:10:19,940
this blocked out here might be and might

00:10:18,800 --> 00:10:21,680
be and swap might be interpret for our

00:10:19,940 --> 00:10:25,340
disk is a job the operating system and

00:10:21,680 --> 00:10:28,430
with some hardware assistance to be able

00:10:25,340 --> 00:10:30,800
to map virtual addresses to physical

00:10:28,430 --> 00:10:33,680
addresses as else and as a side effect

00:10:30,800 --> 00:10:35,810
of this it makes application come makes

00:10:33,680 --> 00:10:38,600
compiling applications much simpler you

00:10:35,810 --> 00:10:40,130
don't have to worry about any any

00:10:38,600 --> 00:10:45,110
absolute memory addresses everything is

00:10:40,130 --> 00:10:47,930
done relative to the value another of

00:10:45,110 --> 00:10:51,020
our servers call a stack pointer which

00:10:47,930 --> 00:10:54,020
brings us to this we have a they're

00:10:51,020 --> 00:10:55,310
typically you allocate memory and raise

00:10:54,020 --> 00:10:57,020
alchy an application in two ways

00:10:55,310 --> 00:10:58,430
statically which is done as a part of

00:10:57,020 --> 00:11:01,790
program execution

00:10:58,430 --> 00:11:05,570
if you say you want an integer value X

00:11:01,790 --> 00:11:08,600
if you go and say into x equals 42 you

00:11:05,570 --> 00:11:11,029
would go and that value 42 would be put

00:11:08,600 --> 00:11:15,670
on the stack above the current function

00:11:11,029 --> 00:11:17,990
hall and it's called the stack for

00:11:15,670 --> 00:11:19,310
reasons is actually the Today Show feel

00:11:17,990 --> 00:11:21,050
like kind of resembles a stack I can get

00:11:19,310 --> 00:11:24,709
into that later but it's also it's also

00:11:21,050 --> 00:11:26,930
kind of complicated and also dynamic

00:11:24,709 --> 00:11:28,700
application dynamic allocation of this

00:11:26,930 --> 00:11:30,770
case it is allocated as a part of

00:11:28,700 --> 00:11:32,540
requests at the operating system these

00:11:30,770 --> 00:11:35,240
are done usually using system calls this

00:11:32,540 --> 00:11:38,149
goes on to the heat the heap is not

00:11:35,240 --> 00:11:41,120
necess is like is not necessarily

00:11:38,149 --> 00:11:44,000
contiguous you just say I need a point I

00:11:41,120 --> 00:11:45,860
need a need 16 bike tubes you ask the

00:11:44,000 --> 00:11:48,440
colonel using a function I need 16 bytes

00:11:45,860 --> 00:11:51,529
of space and it says and either gives

00:11:48,440 --> 00:11:53,779
you back 16 bytes of space or it says no

00:11:51,529 --> 00:11:55,610
you don't have 16 bytes of space I just

00:11:53,779 --> 00:11:57,860
explosive space available to you so I

00:11:55,610 --> 00:12:00,170
will return you a value indicating at

00:11:57,860 --> 00:12:05,300
this case this case that is the value

00:12:00,170 --> 00:12:08,180
zero well one thing that is a relatively

00:12:05,300 --> 00:12:12,170
common thing that happens so these

00:12:08,180 --> 00:12:15,080
addresses are are mapped in map using

00:12:12,170 --> 00:12:16,430
offsets so it is possible in C since

00:12:15,080 --> 00:12:18,640
there isn't necessarily near balance

00:12:16,430 --> 00:12:22,100
checking you could access memory say

00:12:18,640 --> 00:12:23,510
here and you might not so sir your apple

00:12:22,100 --> 00:12:27,860
case you might necessarily be able to

00:12:23,510 --> 00:12:32,180
allow to access memory here and what

00:12:27,860 --> 00:12:34,760
when the what happens there is a in

00:12:32,180 --> 00:12:36,860
units land that is generally what causes

00:12:34,760 --> 00:12:40,250
a segmentation fault a accessing

00:12:36,860 --> 00:12:42,770
protected memory that is not for your

00:12:40,250 --> 00:12:45,950
mental reapplication so for help is for

00:12:42,770 --> 00:12:49,850
security and I just actually see mostly

00:12:45,950 --> 00:12:54,339
sanity reasons also another common

00:12:49,850 --> 00:12:57,980
segmentation fault cause is accessing

00:12:54,339 --> 00:13:00,589
the null pointer itself that is reserved

00:12:57,980 --> 00:13:02,029
by the operating system kernel d'ivoire

00:13:00,589 --> 00:13:03,800
fencing net there's never anything at

00:13:02,029 --> 00:13:07,610
that you are never allowed to access it

00:13:03,800 --> 00:13:09,710
so your program global program will

00:13:07,610 --> 00:13:13,760
always die

00:13:09,710 --> 00:13:15,950
even somewhat spectacularly actually you

00:13:13,760 --> 00:13:17,390
can always do also instead of signal

00:13:15,950 --> 00:13:19,160
handler so your program doesn't die so

00:13:17,390 --> 00:13:21,230
expect suddenly in spectacularly so it

00:13:19,160 --> 00:13:23,540
doesn't so you can police recover

00:13:21,230 --> 00:13:29,090
something before you fall over but this

00:13:23,540 --> 00:13:32,380
is generally a fatal condition all right

00:13:29,090 --> 00:13:36,590
so let's get into the meat of things

00:13:32,380 --> 00:13:39,530
okay so let's go for the question again

00:13:36,590 --> 00:13:42,350
what's the pointer so um say we have

00:13:39,530 --> 00:13:45,290
this value here this value is say you

00:13:42,350 --> 00:13:46,940
have integer experts taking it 15 this

00:13:45,290 --> 00:13:49,190
down here is the it's a hexadecimal

00:13:46,940 --> 00:13:54,500
representation of how it might be stored

00:13:49,190 --> 00:13:57,800
in memory oh this is big endian if on

00:13:54,500 --> 00:14:02,750
other machines it's the border of these

00:13:57,800 --> 00:14:05,510
blocks would be flipped so in general

00:14:02,750 --> 00:14:06,980
for the case they'll just just up

00:14:05,510 --> 00:14:10,820
diagramming it out it doesn't really

00:14:06,980 --> 00:14:12,950
matter what the order is so you have

00:14:10,820 --> 00:14:15,680
this value right this value has got to

00:14:12,950 --> 00:14:19,400
be somewhere it's got to sit somewhere a

00:14:15,680 --> 00:14:22,430
memory right so let's just say it it's

00:14:19,400 --> 00:14:26,150
at for get goals address 64 it starts at

00:14:22,430 --> 00:14:29,210
64 so this bike containing 0 is 64 this

00:14:26,150 --> 00:14:33,040
one's its 65 this one's at 66 this one's

00:14:29,210 --> 00:14:35,990
at 67 into sense integers to integers uh

00:14:33,040 --> 00:14:41,330
generally take up in 32-bit systems four

00:14:35,990 --> 00:14:48,400
bytes that is that as X X is X is at 64

00:14:41,330 --> 00:14:52,640
and goes until 67 so um the cases that

00:14:48,400 --> 00:14:53,990
said where is it there is a clearly a

00:14:52,640 --> 00:15:00,320
bun there's clearly a bunch of numbers

00:14:53,990 --> 00:15:06,290
above the other numbers so it is at the

00:15:00,320 --> 00:15:12,010
value 64 so if there's a sucker integer

00:15:06,290 --> 00:15:12,010
size value here this is 64 x sm 0 64 and

00:15:12,130 --> 00:15:17,300
yeah that is actually pretty much it it

00:15:15,350 --> 00:15:20,560
just is the value that points at the

00:15:17,300 --> 00:15:20,560
start of the

00:15:20,890 --> 00:15:33,980
object you're looking for yes sir

00:15:25,100 --> 00:15:36,470
question this is the question was do

00:15:33,980 --> 00:15:39,010
pointers a point to the most significant

00:15:36,470 --> 00:15:43,790
or be a bit or the least significant it

00:15:39,010 --> 00:15:46,790
the bowl we've malcolm shabazz it points

00:15:43,790 --> 00:15:48,530
to the start for what was depending on a

00:15:46,790 --> 00:15:50,540
system endianness like the most

00:15:48,530 --> 00:15:53,360
significant bit in some systems would be

00:15:50,540 --> 00:16:00,200
or bite would be here in other cases it

00:15:53,360 --> 00:16:01,820
would be here yes it is pointing at the

00:16:00,200 --> 00:16:03,530
lowest value data because if you would

00:16:01,820 --> 00:16:06,260
because as I'll get to later you can

00:16:03,530 --> 00:16:07,700
have stuff behind this that can just get

00:16:06,260 --> 00:16:09,440
bigger so you would want so it just

00:16:07,700 --> 00:16:16,190
stopped behind so you need that point at

00:16:09,440 --> 00:16:18,410
the start I'm a total if anyone gets

00:16:16,190 --> 00:16:25,940
that joke at the top there they watch

00:16:18,410 --> 00:16:29,750
too much Star Trek yeah Darmok and Jalad

00:16:25,940 --> 00:16:34,820
at Tanagra so let's get into a little

00:16:29,750 --> 00:16:38,450
bit of code so um say so just a general

00:16:34,820 --> 00:16:40,850
use case of pointers or how to get stuff

00:16:38,450 --> 00:16:43,880
out of them say you have an integer X

00:16:40,850 --> 00:16:45,620
you declare to the value 42 in some

00:16:43,880 --> 00:16:48,550
cases you won't want to make a pointer

00:16:45,620 --> 00:16:51,560
to the value X so to do this you use the

00:16:48,550 --> 00:16:53,810
is this is the unary am president right

00:16:51,560 --> 00:16:55,790
and here is the deeper is the reference

00:16:53,810 --> 00:17:01,340
operator you're taking the reference of

00:16:55,790 --> 00:17:05,810
X the pointer to X and then you declare

00:17:01,340 --> 00:17:08,270
it as int star XP for this case I just

00:17:05,810 --> 00:17:09,770
named it as a pointer to X and a lot of

00:17:08,270 --> 00:17:12,830
cases you won't necessarily even need to

00:17:09,770 --> 00:17:13,970
say expat if you pass a passing

00:17:12,830 --> 00:17:15,950
foreigner to a function you wouldn't

00:17:13,970 --> 00:17:17,930
necessarily need to say XP you just pass

00:17:15,950 --> 00:17:23,470
that into the function it's just an

00:17:17,930 --> 00:17:28,030
integer it's small it it's cheap

00:17:23,470 --> 00:17:30,340
oh man what the and then thing the real

00:17:28,030 --> 00:17:32,559
use case of pointers that you can go say

00:17:30,340 --> 00:17:35,440
you have a pointer to a value you want

00:17:32,559 --> 00:17:39,070
to go and set you want to change

00:17:35,440 --> 00:17:41,710
something at that pointer so this Excel

00:17:39,070 --> 00:17:45,400
here you would set the you would set the

00:17:41,710 --> 00:17:48,580
dereference value of XP to 100 so since

00:17:45,400 --> 00:17:53,020
X since XP was pointing to X you chain

00:17:48,580 --> 00:17:54,280
also changed the value of x I will get a

00:17:53,020 --> 00:17:56,830
flight demonstration that brief

00:17:54,280 --> 00:17:59,080
confusion that shortly so and also you

00:17:56,830 --> 00:18:00,760
can go and you can also go and

00:17:59,080 --> 00:18:02,020
dereference develop you reference the

00:18:00,760 --> 00:18:04,780
values of pointers of stores I'm

00:18:02,020 --> 00:18:07,390
directly so you have you can say in text

00:18:04,780 --> 00:18:09,370
to is XP is the reference value of x p

00:18:07,390 --> 00:18:12,340
reference operator being the asterisk

00:18:09,370 --> 00:18:16,179
and dereference operator being the

00:18:12,340 --> 00:18:20,350
asterisk carry on for there so I have a

00:18:16,179 --> 00:18:23,400
little example here so can you all read

00:18:20,350 --> 00:18:26,770
this why do you make the font bigger

00:18:23,400 --> 00:18:29,320
okay so let me start out with the

00:18:26,770 --> 00:18:32,789
introductory was 42 before you know

00:18:29,320 --> 00:18:36,520
print statement saying before i take the

00:18:32,789 --> 00:18:39,280
pointer to X set d and i set the value

00:18:36,520 --> 00:18:44,500
of the thing pointed at by XP which is x

00:18:39,280 --> 00:18:47,460
2 100 and then I deuce then I do some

00:18:44,500 --> 00:18:47,460
more printing so

00:18:53,910 --> 00:19:04,860
and for just stay with the program is so

00:19:01,440 --> 00:19:06,540
just as in trouble reading that or

00:19:04,860 --> 00:19:12,360
should I go and I can go and flip the

00:19:06,540 --> 00:19:14,820
collar shirt too okay so as I said the

00:19:12,360 --> 00:19:18,120
value is initially step 242 and then i

00:19:14,820 --> 00:19:22,920
set the reference value to 100 and then

00:19:18,120 --> 00:19:26,610
it both shows 100 because of this what

00:19:22,920 --> 00:19:31,110
if you are often used in c functions as

00:19:26,610 --> 00:19:34,950
arguments if so if you pass a pointer to

00:19:31,110 --> 00:19:36,900
a function sometimes the out sometimes

00:19:34,950 --> 00:19:38,280
the function might go and change the

00:19:36,900 --> 00:19:40,500
value associated with that pointer it

00:19:38,280 --> 00:19:42,990
might set something in or at that

00:19:40,500 --> 00:19:44,460
pointer and this would persist outside

00:19:42,990 --> 00:19:47,160
the function call sense in general

00:19:44,460 --> 00:19:49,430
things in c don't last outside of

00:19:47,160 --> 00:19:53,190
function calls so if this is a way of

00:19:49,430 --> 00:19:56,850
making in place in place changes to

00:19:53,190 --> 00:19:58,590
Paris out to objects and see there are

00:19:56,850 --> 00:20:00,240
other most often you wouldn't just

00:19:58,590 --> 00:20:01,830
really pass integers like that as

00:20:00,240 --> 00:20:04,500
pointers you would pass the things

00:20:01,830 --> 00:20:07,230
called struts which are aggregate type

00:20:04,500 --> 00:20:10,110
some i can go discuss those a little

00:20:07,230 --> 00:20:14,730
more later we get some time but it's

00:20:10,110 --> 00:20:17,940
fundamentally the same sort of thing so

00:20:14,730 --> 00:20:21,390
um as just a nice summer right here we

00:20:17,940 --> 00:20:23,790
have a it's just that the you've given

00:20:21,390 --> 00:20:26,130
the pointer the actress operator gets

00:20:23,790 --> 00:20:29,640
you the value the ampersand operator on

00:20:26,130 --> 00:20:31,350
this gives you the point drop gives you

00:20:29,640 --> 00:20:34,230
back the pointer and you can actually

00:20:31,350 --> 00:20:36,480
call this many times you can get the so

00:20:34,230 --> 00:20:37,800
once you have if you have this value the

00:20:36,480 --> 00:20:40,440
stored memory you can get a pointer to

00:20:37,800 --> 00:20:42,840
this too and it might say in it also

00:20:40,440 --> 00:20:45,300
could you speak anywhere and think how

00:20:42,840 --> 00:20:48,420
that come i'll get that to moment

00:20:45,300 --> 00:20:50,460
actually so one of the things but if you

00:20:48,420 --> 00:20:53,040
will see when they're writing C code is

00:20:50,460 --> 00:20:55,950
the or the asterisk goes regarding in

00:20:53,040 --> 00:20:58,920
the when you're making pointers i gave

00:20:55,950 --> 00:21:00,300
this way early by doing it all like this

00:20:58,920 --> 00:21:01,740
but this kind of makes sense while

00:21:00,300 --> 00:21:03,870
you're saying it's you're making the

00:21:01,740 --> 00:21:06,730
type is an end pointer right all right

00:21:03,870 --> 00:21:08,470
that's not how she does it

00:21:06,730 --> 00:21:11,320
because you can do things like that you

00:21:08,470 --> 00:21:15,040
happen or if you say this the asterisk

00:21:11,320 --> 00:21:17,049
is bound to the variable it is next to

00:21:15,040 --> 00:21:19,510
so you can't so if you put the star with

00:21:17,049 --> 00:21:21,220
int it would only make this X a pointer

00:21:19,510 --> 00:21:22,780
here and that wasn't there just why

00:21:21,220 --> 00:21:28,870
would be an integral plain old is your

00:21:22,780 --> 00:21:30,130
instead so as I was just let's came back

00:21:28,870 --> 00:21:32,530
here so you can have pointers to

00:21:30,130 --> 00:21:36,429
pointers to pointers pointers all the

00:21:32,530 --> 00:21:38,830
way down so say you can have a pointer

00:21:36,429 --> 00:21:42,190
to act if it x 42 you can have a pointer

00:21:38,830 --> 00:21:44,530
to make a pointer to X you can pointer

00:21:42,190 --> 00:21:48,340
to XP you can make a pointer to X PEP

00:21:44,530 --> 00:21:50,080
and then you can dereference them you

00:21:48,340 --> 00:21:55,510
dereference them two or three times you

00:21:50,080 --> 00:21:59,620
get back the original value of 42 the so

00:21:55,510 --> 00:22:03,220
you might be wondering why can't we just

00:21:59,620 --> 00:22:07,900
put three ampersands there why can't we

00:22:03,220 --> 00:22:10,150
just have a you can't stack the amp you

00:22:07,900 --> 00:22:13,299
why can't we stacking ampersands you

00:22:10,150 --> 00:22:16,299
cannot stack the ampersands because this

00:22:13,299 --> 00:22:18,640
this operator returns a number and if

00:22:16,299 --> 00:22:20,620
you have a number the numbers are just

00:22:18,640 --> 00:22:24,490
are not necessarily in memory at their

00:22:20,620 --> 00:22:26,020
not being save anywhere if you do sorry

00:22:24,490 --> 00:22:28,480
to start stacking ampersand sector each

00:22:26,020 --> 00:22:32,290
other GCC you actually spit out an error

00:22:28,480 --> 00:22:34,720
saying you can't take you can't take a

00:22:32,290 --> 00:22:36,790
reference of a number yes it has to be a

00:22:34,720 --> 00:22:39,190
value node that's be a value stored

00:22:36,790 --> 00:22:41,200
memory summer so this case it would just

00:22:39,190 --> 00:22:43,210
be this case is just making i'm

00:22:41,200 --> 00:22:48,340
referencing XP which is a point or two x

00:22:43,210 --> 00:22:50,320
but is itself not checked in memory this

00:22:48,340 --> 00:22:54,429
is one of the things that threw me off a

00:22:50,320 --> 00:22:57,700
bit it makes like often people describe

00:22:54,429 --> 00:23:01,090
a metaphor for pointers as addresses

00:22:57,700 --> 00:23:03,370
except that addresses themselves are

00:23:01,090 --> 00:23:06,610
just but where are the it but the

00:23:03,370 --> 00:23:09,010
addresses can be somewhere too so i can

00:23:06,610 --> 00:23:13,450
i can give you a little metaphor

00:23:09,010 --> 00:23:18,039
actually yeah have time for that

00:23:13,450 --> 00:23:20,919
so um say you're looking for your car

00:23:18,039 --> 00:23:23,889
keys you think you left your you have a

00:23:20,919 --> 00:23:26,799
note on your bedside table saying you

00:23:23,889 --> 00:23:28,750
left your car keys by the front door so

00:23:26,799 --> 00:23:31,090
you walk to your front door you find a

00:23:28,750 --> 00:23:32,919
little post-it note saying oh ya know

00:23:31,090 --> 00:23:35,950
your car keys weren't aren't here

00:23:32,919 --> 00:23:38,470
they're in your refrigerator so you go

00:23:35,950 --> 00:23:40,870
to your refrigerator you look inside you

00:23:38,470 --> 00:23:46,960
find other Pacific note saying oh yeah

00:23:40,870 --> 00:23:49,720
um you your your car keys aren't here

00:23:46,960 --> 00:23:51,220
you should go look on your dining room

00:23:49,720 --> 00:23:52,899
table and say it so you walk your dining

00:23:51,220 --> 00:23:55,419
room table and lo and behold there your

00:23:52,899 --> 00:23:59,139
car keys that in this case that is a

00:23:55,419 --> 00:24:02,549
point that is a a tuna stood pointer and

00:23:59,139 --> 00:24:04,809
we are referencing and referencing

00:24:02,549 --> 00:24:08,470
dereferencing it until we get to the

00:24:04,809 --> 00:24:12,610
value in question so every is everything

00:24:08,470 --> 00:24:14,470
is just pointing things you're pointing

00:24:12,610 --> 00:24:19,840
at things until you get the value your

00:24:14,470 --> 00:24:21,730
own so one thing you also may notice

00:24:19,840 --> 00:24:24,460
that all these pointers have associated

00:24:21,730 --> 00:24:26,080
types so in this case uh we all have

00:24:24,460 --> 00:24:28,179
like these are all integer pointers or

00:24:26,080 --> 00:24:30,730
integer pointer pointers or point your

00:24:28,179 --> 00:24:33,370
pointer pointers so when you have

00:24:30,730 --> 00:24:35,289
sometimes you have a need for a generic

00:24:33,370 --> 00:24:38,470
pointer you need a pointer to some sort

00:24:35,289 --> 00:24:42,039
of space this is actually very important

00:24:38,470 --> 00:24:44,230
so um you make it so if you need if you

00:24:42,039 --> 00:24:46,960
if you need a typist pointer say you

00:24:44,230 --> 00:24:49,000
have a function call that you have a bit

00:24:46,960 --> 00:24:52,269
of a function callback that needs to

00:24:49,000 --> 00:24:54,240
take a generic argument just say a bunch

00:24:52,269 --> 00:24:56,470
of opaque data that don't we the

00:24:54,240 --> 00:24:57,760
callback function we know about you

00:24:56,470 --> 00:24:59,500
would pass it as a void pointer because

00:24:57,760 --> 00:25:03,820
you don't know what the type is it just

00:24:59,500 --> 00:25:05,169
data there's a there's a very important

00:25:03,820 --> 00:25:07,389
function that uses VoIP oi nurse I'll

00:25:05,169 --> 00:25:10,990
get to that soon another thing you can

00:25:07,389 --> 00:25:15,179
do with pointers is that you can have

00:25:10,990 --> 00:25:18,669
stuff behind pointers so you can have a

00:25:15,179 --> 00:25:22,120
um the thing about see is that there are

00:25:18,669 --> 00:25:25,450
see strings are in fact arrays or

00:25:22,120 --> 00:25:26,880
pointers had things so this case B this

00:25:25,450 --> 00:25:30,990
case the string pointer here

00:25:26,880 --> 00:25:33,360
is just the it's just this will just

00:25:30,990 --> 00:25:37,200
that those sequence of eight characters

00:25:33,360 --> 00:25:39,420
you have to have the that null

00:25:37,200 --> 00:25:41,220
terminator on that that thing on the end

00:25:39,420 --> 00:25:43,590
there the backslash zero is a was

00:25:41,220 --> 00:25:46,710
calling null terminator is a the way

00:25:43,590 --> 00:25:50,940
that she knows that this string is done

00:25:46,710 --> 00:25:55,290
this bit string or this cases character

00:25:50,940 --> 00:25:57,450
string is done here without it see us

00:25:55,290 --> 00:25:59,280
there what without it there you would

00:25:57,450 --> 00:26:01,620
not be able to know where this string

00:25:59,280 --> 00:26:03,540
and the less you had a associated a

00:26:01,620 --> 00:26:04,800
blank with it there is no bounce there

00:26:03,540 --> 00:26:09,180
is no balance checking and see unless

00:26:04,800 --> 00:26:10,560
you explicitly edit it so if so there's

00:26:09,180 --> 00:26:12,270
a function say called the function

00:26:10,560 --> 00:26:14,730
called sterline which gets us the length

00:26:12,270 --> 00:26:17,070
of the string so it does it goes and

00:26:14,730 --> 00:26:20,010
starts here and then goes all the way

00:26:17,070 --> 00:26:23,250
until it finds this and says your string

00:26:20,010 --> 00:26:27,090
is like seven so it goes from zero to

00:26:23,250 --> 00:26:29,910
six and if it this isn't here it would

00:26:27,090 --> 00:26:31,320
keep on going until it started accessing

00:26:29,910 --> 00:26:33,150
memory your application was not allowed

00:26:31,320 --> 00:26:35,340
to access or it might start accessing

00:26:33,150 --> 00:26:38,520
memory of your of your application that

00:26:35,340 --> 00:26:40,380
is not in the string which is you can do

00:26:38,520 --> 00:26:44,310
all sorts of funny things if you could

00:26:40,380 --> 00:26:46,440
do that and it would go and back to come

00:26:44,310 --> 00:26:49,890
bring your program would explode with

00:26:46,440 --> 00:26:51,510
signal 11 and die violently these are

00:26:49,890 --> 00:26:54,300
also what is it really called arrays

00:26:51,510 --> 00:26:58,130
there is a another seat thing to see

00:26:54,300 --> 00:27:01,350
called an array I will get to that soon

00:26:58,130 --> 00:27:03,300
so when you have say you need to

00:27:01,350 --> 00:27:05,580
allocate a pretty get to memory

00:27:03,300 --> 00:27:08,820
allocation you have to get to a to

00:27:05,580 --> 00:27:10,260
figure out how large things are because

00:27:08,820 --> 00:27:13,320
you need one you each allocate a

00:27:10,260 --> 00:27:16,860
specific number of bytes for a specific

00:27:13,320 --> 00:27:20,580
number for specific number of things so

00:27:16,860 --> 00:27:22,520
to get so to get the number the how are

00:27:20,580 --> 00:27:26,010
things are typically you would use the

00:27:22,520 --> 00:27:27,420
sizeof operator it just goes and it goes

00:27:26,010 --> 00:27:30,420
and happens to know ahead of time

00:27:27,420 --> 00:27:32,970
exactly what the size of things are but

00:27:30,420 --> 00:27:34,350
size of types are rather before at

00:27:32,970 --> 00:27:35,530
compile time so we're just translate

00:27:34,350 --> 00:27:38,950
that to

00:27:35,530 --> 00:27:43,060
integer and then unsigned unsigned

00:27:38,950 --> 00:27:45,550
integer and that's pretty from there um

00:27:43,060 --> 00:27:49,510
give you the example of that will show

00:27:45,550 --> 00:27:50,770
an example that soon and then yet

00:27:49,510 --> 00:27:55,810
another thing you can do with pointers

00:27:50,770 --> 00:27:57,280
that you can add to them so or you can

00:27:55,810 --> 00:27:59,620
do arithmetic with you can you can add

00:27:57,280 --> 00:28:01,690
in add and subtract you can't multiply

00:27:59,620 --> 00:28:05,950
doesn't make any sense I'll tell you why

00:28:01,690 --> 00:28:09,340
so say you make a string called pointer

00:28:05,950 --> 00:28:10,930
as periods before so I'm here I have to

00:28:09,340 --> 00:28:13,600
print functions this one here is

00:28:10,930 --> 00:28:15,910
printing out the character followed by

00:28:13,600 --> 00:28:18,070
the pointer value so I'm dereferencing

00:28:15,910 --> 00:28:20,800
I'm dereferencing essence as is the OS

00:28:18,070 --> 00:28:22,450
is the pointer to the first value of the

00:28:20,800 --> 00:28:26,620
straight first character in the string

00:28:22,450 --> 00:28:28,660
it will undoubtedly return p the capital

00:28:26,620 --> 00:28:30,880
p however the next one I'm doing the

00:28:28,660 --> 00:28:35,470
same thing but I'm adding 2 to all the

00:28:30,880 --> 00:28:40,600
values this is a Tiffany what different

00:28:35,470 --> 00:28:42,400
here is that when you give a particular

00:28:40,600 --> 00:28:46,420
with pointers it will advance the

00:28:42,400 --> 00:28:48,390
pointer the size of the value in

00:28:46,420 --> 00:28:52,780
question so this case this will advance

00:28:48,390 --> 00:28:55,270
go two elements forward in the string to

00:28:52,780 --> 00:28:57,640
the eye and print that out instead put

00:28:55,270 --> 00:29:01,390
that up to if this was say an integer

00:28:57,640 --> 00:29:03,250
array instead of advancing eventing just

00:29:01,390 --> 00:29:05,470
two bytes since a character is one bike

00:29:03,250 --> 00:29:10,630
it would advance a eight bytes since

00:29:05,470 --> 00:29:14,250
integer in 32-bit land is four bytes so

00:29:10,630 --> 00:29:14,250
i have this example to

00:29:21,730 --> 00:29:27,110
so I have the subs them there's the

00:29:25,550 --> 00:29:29,240
program it's the same except it has some

00:29:27,110 --> 00:29:39,440
comments that pretty much I said exactly

00:29:29,240 --> 00:29:42,140
what I discussed and bam just as I said

00:29:39,440 --> 00:29:45,740
it would so it's printing out the P fall

00:29:42,140 --> 00:29:48,080
by the pointer to the P which is at the

00:29:45,740 --> 00:29:51,380
start of the string at some address

00:29:48,080 --> 00:29:53,810
determined by by the kernel and the

00:29:51,380 --> 00:29:56,090
program and then it advance to forward

00:29:53,810 --> 00:30:00,950
this is these are all accessible values

00:29:56,090 --> 00:30:05,480
so c plus so it goes from 0 to 9 a b c d

00:30:00,950 --> 00:30:10,250
e f and then back to 10 again it's sub a

00:30:05,480 --> 00:30:13,190
16 i should have said that first so c

00:30:10,250 --> 00:30:18,890
plus 2 equals e advanced two positions

00:30:13,190 --> 00:30:20,690
forward has a expected so when you just

00:30:18,890 --> 00:30:22,460
look at s if you just have a function

00:30:20,690 --> 00:30:26,740
that just contains this random s you

00:30:22,460 --> 00:30:29,210
don't necessarily know what s is uh so

00:30:26,740 --> 00:30:31,370
they asset you have this big function

00:30:29,210 --> 00:30:34,760
you don't know what s is esque so you're

00:30:31,370 --> 00:30:38,630
so just adding 2 s like okay you're

00:30:34,760 --> 00:30:40,850
adding a number 2's I'd there were other

00:30:38,630 --> 00:30:43,580
clues a giveaway as a pointer but this

00:30:40,850 --> 00:30:45,200
is kind it's this kind of makes things

00:30:43,580 --> 00:30:48,200
hard to read so there is a specific

00:30:45,200 --> 00:30:55,750
operator there's a there is an operator

00:30:48,200 --> 00:30:58,700
that specifically does this and it is

00:30:55,750 --> 00:31:02,710
the was called the air raid a right to

00:30:58,700 --> 00:31:08,770
reference operator so as case is the

00:31:02,710 --> 00:31:12,730
square bracket so cold if it it goes the

00:31:08,770 --> 00:31:15,860
does the exact same thing as

00:31:12,730 --> 00:31:23,120
dereferencing the pointer plus an offset

00:31:15,860 --> 00:31:24,770
so s so this is equivalent to s the

00:31:23,120 --> 00:31:29,890
referencing the value of s plus 0 which

00:31:24,770 --> 00:31:33,750
is X which is the array index here it's

00:31:29,890 --> 00:31:36,840
and these actually produce a the

00:31:33,750 --> 00:31:44,850
the pretty much the precise the exact

00:31:36,840 --> 00:31:46,620
same program one output so so or is that

00:31:44,850 --> 00:31:57,530
there's the same program again with the

00:31:46,620 --> 00:32:00,360
same information and I can't type so

00:31:57,530 --> 00:32:02,960
these values so it's the same results

00:32:00,360 --> 00:32:07,220
and actually in fact it's the exact same

00:32:02,960 --> 00:32:11,040
results as you can see in the top there

00:32:07,220 --> 00:32:12,750
so it's very immersed in Kota there's a

00:32:11,040 --> 00:32:15,660
way if you want to examine this further

00:32:12,750 --> 00:32:21,840
there is a mode for GCC that can print

00:32:15,660 --> 00:32:24,390
out the assembly code it is this file

00:32:21,840 --> 00:32:26,490
name it oldest up print dill print out a

00:32:24,390 --> 00:32:30,240
film write a foul call it will print out

00:32:26,490 --> 00:32:32,040
s file instead of a eight hour or

00:32:30,240 --> 00:32:34,920
whatever that you wanted to call it and

00:32:32,040 --> 00:32:36,060
then you can use it to start to be study

00:32:34,920 --> 00:32:38,970
the assembly code and figure out

00:32:36,060 --> 00:32:42,840
precisely where it's doing one thing to

00:32:38,970 --> 00:32:45,440
know is that in like a lot of text books

00:32:42,840 --> 00:32:47,400
on the subject you won't see a lot of a

00:32:45,440 --> 00:32:51,480
lot of the code you'll see is either

00:32:47,400 --> 00:32:53,490
done in nips or 32-bit x86 these days

00:32:51,480 --> 00:32:57,090
and a lot of systems the default the

00:32:53,490 --> 00:33:00,150
default defaults to compiling 64-bit x86

00:32:57,090 --> 00:33:04,790
which is much more complicated than the

00:33:00,150 --> 00:33:09,420
thinnest 32-bit predecessor so or and

00:33:04,790 --> 00:33:10,650
yeah predecessor so and do that you

00:33:09,420 --> 00:33:17,130
would have to make sure you have a 30 to

00:33:10,650 --> 00:33:19,140
pick up our support around and do em 30m

00:33:17,130 --> 00:33:21,660
32 on the end to make sure it compiles

00:33:19,140 --> 00:33:23,970
to 30 give it just for setting purposes

00:33:21,660 --> 00:33:26,190
the code the code should be equivalent

00:33:23,970 --> 00:33:27,630
otherwise the compiler or functional

00:33:26,190 --> 00:33:31,400
equivalent otherwise the compiler is

00:33:27,630 --> 00:33:36,600
broken and that's really bad and the

00:33:31,400 --> 00:33:38,810
system is a useful study aid it's a way

00:33:36,600 --> 00:33:43,620
it was put to me when I learn this stuff

00:33:38,810 --> 00:33:46,410
so as I said in like three times those

00:33:43,620 --> 00:33:47,190
two are the same thing the driver

00:33:46,410 --> 00:33:51,320
singing

00:33:47,190 --> 00:33:56,310
the DRA dereference is the same as

00:33:51,320 --> 00:33:57,750
radioreference is the same as ray at the

00:33:56,310 --> 00:33:59,280
regular ones the same ways to

00:33:57,750 --> 00:34:01,860
referencing a pointer and adding the

00:33:59,280 --> 00:34:03,330
offset to it using our friend pointer

00:34:01,860 --> 00:34:04,860
arithmetic there are plenty of use cases

00:34:03,330 --> 00:34:09,420
for pointer arithmetic they're just

00:34:04,860 --> 00:34:13,350
generally more advanced up you'll if you

00:34:09,420 --> 00:34:15,810
need them you will you will in if you

00:34:13,350 --> 00:34:17,070
need it you'll probably know if you need

00:34:15,810 --> 00:34:19,920
to like advance more than just one

00:34:17,070 --> 00:34:23,370
position in the array you would need to

00:34:19,920 --> 00:34:24,990
use a pointer arithmetic if you're if

00:34:23,370 --> 00:34:26,760
you're doing if you're just visiting the

00:34:24,990 --> 00:34:28,710
individual almost the very one at a time

00:34:26,760 --> 00:34:30,450
as opposed to just iterating through the

00:34:28,710 --> 00:34:35,970
array and there are some use cases for

00:34:30,450 --> 00:34:37,470
that so another thing is that there is

00:34:35,970 --> 00:34:39,960
the Commission before there is a

00:34:37,470 --> 00:34:46,380
difference between arrays and pointers

00:34:39,960 --> 00:34:51,380
so typically arrays like this referred

00:34:46,380 --> 00:34:51,380
to just are used like buffers these are

00:34:52,430 --> 00:34:57,330
these are generally put on these you

00:34:55,830 --> 00:35:00,030
generally you put a number in here

00:34:57,330 --> 00:35:04,230
specifying the size and this would go

00:35:00,030 --> 00:35:05,370
and be there be a say you put four and

00:35:04,230 --> 00:35:07,920
there you would have an interest you

00:35:05,370 --> 00:35:10,160
would have a space for four integers on

00:35:07,920 --> 00:35:12,660
the stack ready for use pre-allocated

00:35:10,160 --> 00:35:14,490
just take them take it and run with it

00:35:12,660 --> 00:35:17,490
when you have a pointer however the

00:35:14,490 --> 00:35:19,770
pointer is not initial is just a pointer

00:35:17,490 --> 00:35:21,150
it's an integer mind you nisht when he

00:35:19,770 --> 00:35:22,860
said then when you create variables and

00:35:21,150 --> 00:35:24,750
see you need to set them to something

00:35:22,860 --> 00:35:27,810
otherwise they will point off into space

00:35:24,750 --> 00:35:30,000
or sort of some random value that is

00:35:27,810 --> 00:35:31,800
likely not a part of your program so if

00:35:30,000 --> 00:35:34,590
you try ready reference a pointer but

00:35:31,800 --> 00:35:36,810
you just made by saying in star X its

00:35:34,590 --> 00:35:39,570
most like it's more most likely going to

00:35:36,810 --> 00:35:41,460
cause a segmentation fault so you often

00:35:39,570 --> 00:35:42,720
need to have that actually point at

00:35:41,460 --> 00:35:45,540
something either by dereferencing a

00:35:42,720 --> 00:35:49,470
value or allocating memory to it so um

00:35:45,540 --> 00:35:52,320
that is something that's going to be

00:35:49,470 --> 00:35:55,140
coming up right now

00:35:52,320 --> 00:35:58,740
let's talk about a raise first so as I

00:35:55,140 --> 00:36:00,840
said you could have a raise you can

00:35:58,740 --> 00:36:04,530
create a raise that are uninitialized

00:36:00,840 --> 00:36:06,120
with the value of four say if you want

00:36:04,530 --> 00:36:08,310
space for four inch that's initialize

00:36:06,120 --> 00:36:11,880
you want to set them later you would go

00:36:08,310 --> 00:36:15,150
and do something like this if you wanted

00:36:11,880 --> 00:36:17,460
a array with pre-initialized values if

00:36:15,150 --> 00:36:21,930
you if you have an initial value set you

00:36:17,460 --> 00:36:23,400
can go and set this to you can see you

00:36:21,930 --> 00:36:27,500
can set initial values by using this

00:36:23,400 --> 00:36:29,970
handy dandy well bracket notation there

00:36:27,500 --> 00:36:31,530
typically once you make them you would

00:36:29,970 --> 00:36:35,640
do something with them you would excuse

00:36:31,530 --> 00:36:37,370
me fast them to other functions and once

00:36:35,640 --> 00:36:39,690
you leave the function they are

00:36:37,370 --> 00:36:41,340
effectively freed you do not have to

00:36:39,690 --> 00:36:43,740
worry about doing any memory me any

00:36:41,340 --> 00:36:46,200
complex memory management tasks with

00:36:43,740 --> 00:36:49,610
things on the stack once you leave the

00:36:46,200 --> 00:36:52,080
function they are up they are gone

00:36:49,610 --> 00:36:53,970
effectively terror they're still in

00:36:52,080 --> 00:36:58,380
memory but they are not really

00:36:53,970 --> 00:37:00,660
accessible anymore that's a it's as they

00:36:58,380 --> 00:37:02,610
say popping off the stack if I can get

00:37:00,660 --> 00:37:07,440
into more detail about that at the end

00:37:02,610 --> 00:37:08,580
there that is plenty well documented so

00:37:07,440 --> 00:37:10,920
let's get the dynamic allocation

00:37:08,580 --> 00:37:12,840
everyone's favorite part of everyone's

00:37:10,920 --> 00:37:16,560
favorite part of C is dynamically

00:37:12,840 --> 00:37:17,850
allocating variable memory so you would

00:37:16,560 --> 00:37:19,080
have there are two functions that are

00:37:17,850 --> 00:37:21,630
typically used for this there were

00:37:19,080 --> 00:37:23,280
actually more than just these two but

00:37:21,630 --> 00:37:26,280
the serve their only each have their own

00:37:23,280 --> 00:37:27,840
will use if you woke up if you look up

00:37:26,280 --> 00:37:31,560
one they all start referencing all the

00:37:27,840 --> 00:37:33,570
other ones so I'm the two big ones are

00:37:31,560 --> 00:37:37,140
malloc and free mallet or memory

00:37:33,570 --> 00:37:39,300
allocate is a you give it a bite you

00:37:37,140 --> 00:37:41,970
give it a number of bytes and it were

00:37:39,300 --> 00:37:43,890
trended gasps the colonel give me give

00:37:41,970 --> 00:37:48,540
me a memory space for this many bytes

00:37:43,890 --> 00:37:51,300
and then it will give you a pointer to

00:37:48,540 --> 00:37:52,860
that space since this since you can't it

00:37:51,300 --> 00:37:55,140
can't know what you're going to be using

00:37:52,860 --> 00:37:57,990
it for beforehand this will return a

00:37:55,140 --> 00:38:00,180
void pointer and you would have to cast

00:37:57,990 --> 00:38:02,289
it implicitly or otherwise to the actual

00:38:00,180 --> 00:38:07,839
tyco you would need to use it for

00:38:02,289 --> 00:38:09,849
and free fries that memory why do we

00:38:07,839 --> 00:38:12,009
need to have free here so when you make

00:38:09,849 --> 00:38:17,559
them request to the colonel to allocate

00:38:12,009 --> 00:38:20,339
memory that and so it just gives you the

00:38:17,559 --> 00:38:23,859
memories like okay you want your you

00:38:20,339 --> 00:38:26,229
threat you program I process ID blah

00:38:23,859 --> 00:38:29,229
blah blah want this not every okay i

00:38:26,229 --> 00:38:31,599
will give it to you then accept it is

00:38:29,229 --> 00:38:34,359
not the colonel doesn't really track how

00:38:31,599 --> 00:38:36,400
that memory is really being used it just

00:38:34,359 --> 00:38:39,699
saying saying it the application owns it

00:38:36,400 --> 00:38:41,319
so if you happen to lose the pointer to

00:38:39,699 --> 00:38:43,749
that memory that you know the colonel

00:38:41,319 --> 00:38:46,299
will still think that it is allocated

00:38:43,749 --> 00:38:50,019
and is being it used so if you happen to

00:38:46,299 --> 00:38:53,679
make many calls to malloc without

00:38:50,019 --> 00:38:55,359
freeing them say if you have a if you

00:38:53,679 --> 00:38:59,890
have a long-running program it doesn't

00:38:55,359 --> 00:39:01,539
that goes just creates a bit sets up a

00:38:59,890 --> 00:39:03,669
bunch of resources and then doesn't it

00:39:01,539 --> 00:39:05,799
doesn't allocate them all at the right

00:39:03,669 --> 00:39:08,169
time you all of you'll have a problem

00:39:05,799 --> 00:39:11,650
that is a commonly referred to as a

00:39:08,169 --> 00:39:13,869
memory leak and these are these can

00:39:11,650 --> 00:39:16,390
often be very very hard to find who are

00:39:13,869 --> 00:39:19,869
specialized tools such as bal grind on

00:39:16,390 --> 00:39:21,999
called dal grind that can go and think

00:39:19,869 --> 00:39:23,769
of that can go and up help detect those

00:39:21,999 --> 00:39:26,199
no really sometimes these can be really

00:39:23,769 --> 00:39:28,769
really small so won't even really notice

00:39:26,199 --> 00:39:34,569
them until your programs in running for

00:39:28,769 --> 00:39:37,809
day days and in some cases it's actually

00:39:34,569 --> 00:39:40,179
more economical to just restart to the

00:39:37,809 --> 00:39:43,419
restart server as opposed to having to

00:39:40,179 --> 00:39:47,009
go to supposed to fixing the leak say if

00:39:43,419 --> 00:39:47,009
you're writing dealing with a lot of a

00:39:47,880 --> 00:39:54,309
pearl pearl and see binding sconces it's

00:39:52,239 --> 00:39:57,339
very possible to go and it's just create

00:39:54,309 --> 00:40:02,499
references and then lose them you don't

00:39:57,339 --> 00:40:04,869
correctly track so as an example to use

00:40:02,499 --> 00:40:07,109
Malik Malik is in the C standard library

00:40:04,869 --> 00:40:10,980
header you have 200 that for the thumb

00:40:07,109 --> 00:40:15,420
to be available then you go and create a

00:40:10,980 --> 00:40:17,999
create the pointer that with the width

00:40:15,420 --> 00:40:21,599
as allocated to the this is pretty much

00:40:17,999 --> 00:40:22,920
the same as the first is the right

00:40:21,599 --> 00:40:24,720
temple with the array first sample to

00:40:22,920 --> 00:40:26,220
raise X where you just allocated a bunch

00:40:24,720 --> 00:40:29,849
where's made an array with a bunch of

00:40:26,220 --> 00:40:32,369
empty space so this would make a space

00:40:29,849 --> 00:40:35,940
for memory that is the size of four

00:40:32,369 --> 00:40:38,789
integers so you could go and to do

00:40:35,940 --> 00:40:40,880
preference it you can pass it to a

00:40:38,789 --> 00:40:43,019
function you can do whatever to it

00:40:40,880 --> 00:40:45,859
commonly what people so what some people

00:40:43,019 --> 00:40:48,299
do is that they will go and have a

00:40:45,859 --> 00:40:51,119
they'll have functions that go and call

00:40:48,299 --> 00:40:53,749
malloc and just now call malloc gift you

00:40:51,119 --> 00:40:56,700
populate a bunch of populated a bunch of

00:40:53,749 --> 00:41:00,809
base memory with values never turn the

00:40:56,700 --> 00:41:03,630
pointer to them and then it then that is

00:41:00,809 --> 00:41:06,599
the only way for pointers to really

00:41:03,630 --> 00:41:11,279
survive function calls or rather memory

00:41:06,599 --> 00:41:13,259
to survive the pointers to member of

00:41:11,279 --> 00:41:15,059
values to survive between functions that

00:41:13,259 --> 00:41:17,249
you have you keep track of the memory

00:41:15,059 --> 00:41:21,599
address where of where they are if

00:41:17,249 --> 00:41:24,989
values on the stack are effectively lost

00:41:21,599 --> 00:41:27,589
on Blossom the function call we use this

00:41:24,989 --> 00:41:30,420
does not happen in the salute to all the

00:41:27,589 --> 00:41:32,849
memory leaking problems and the free at

00:41:30,420 --> 00:41:35,220
the end is just as an example if you're

00:41:32,849 --> 00:41:37,200
just doing this in Maine and just ending

00:41:35,220 --> 00:41:38,999
right there you don't need it it's just

00:41:37,200 --> 00:41:42,180
the good practice to get into because if

00:41:38,999 --> 00:41:45,480
we forget even one it could cause a big

00:41:42,180 --> 00:41:47,400
problems down the line so I'm going to

00:41:45,480 --> 00:41:48,569
get into a little bit of a getting

00:41:47,400 --> 00:41:50,009
towards the end here so I can get into a

00:41:48,569 --> 00:41:52,589
little bit of Heather ways and people

00:41:50,009 --> 00:41:54,150
without handle memory I was originally

00:41:52,589 --> 00:41:55,619
planning to talk about garbage a little

00:41:54,150 --> 00:41:58,950
bit of a garbage collection here it's a

00:41:55,619 --> 00:42:00,900
rather complicated topic so if i get

00:41:58,950 --> 00:42:03,029
some time with in a public will alwa can

00:42:00,900 --> 00:42:06,779
go and discuss that a little bit but

00:42:03,029 --> 00:42:10,140
first off um region-based allocation so

00:42:06,779 --> 00:42:13,170
so a problem where you have many things

00:42:10,140 --> 00:42:14,549
you need to know you just need to keep

00:42:13,170 --> 00:42:16,529
track of them all and then free them all

00:42:14,549 --> 00:42:19,619
create a memory object many objects and

00:42:16,529 --> 00:42:20,610
then freedom all what happened was some

00:42:19,619 --> 00:42:24,330
way some people solved

00:42:20,610 --> 00:42:25,770
problem is that they go and have a they

00:42:24,330 --> 00:42:29,730
have a data to make a data structure

00:42:25,770 --> 00:42:32,070
that contains a list of pointers that

00:42:29,730 --> 00:42:35,190
have been allocated associated with this

00:42:32,070 --> 00:42:37,590
object in this the case of Apache the

00:42:35,190 --> 00:42:39,770
Apache portable runtime library which it

00:42:37,590 --> 00:42:43,440
is because the Apache web server uses

00:42:39,770 --> 00:42:46,050
heavily this is called a memory pool in

00:42:43,440 --> 00:42:49,080
although it's not accidentally what a

00:42:46,050 --> 00:42:52,500
memory pool is that's also rather

00:42:49,080 --> 00:42:54,240
complicated just go we just go and make

00:42:52,500 --> 00:42:55,770
a pool you allocate stuff to the pool

00:42:54,240 --> 00:42:58,800
and we're done with the pool you call a

00:42:55,770 --> 00:43:01,140
function on the pool that goes in delete

00:42:58,800 --> 00:43:02,490
that freeze all murmuring the result

00:43:01,140 --> 00:43:06,570
memory associate with a pool and then

00:43:02,490 --> 00:43:09,980
destroyed the pool brim said it's a it's

00:43:06,570 --> 00:43:12,090
a nice and simple and gets the job done

00:43:09,980 --> 00:43:14,310
some people would argue that it's not

00:43:12,090 --> 00:43:17,660
worth dealing with if you just happen if

00:43:14,310 --> 00:43:19,710
it can just solve the human being have a

00:43:17,660 --> 00:43:21,210
if a human got everything right the

00:43:19,710 --> 00:43:22,620
first time wouldn't be a problem I'm

00:43:21,210 --> 00:43:25,260
sure there are other reasons for this

00:43:22,620 --> 00:43:28,080
and not completely aware of them at this

00:43:25,260 --> 00:43:29,760
time so another way people handle

00:43:28,080 --> 00:43:32,130
memories like so you have a problem

00:43:29,760 --> 00:43:35,970
where you have many resources access to

00:43:32,130 --> 00:43:37,950
the same time so you have a so you have

00:43:35,970 --> 00:43:39,570
to have many threads accessing the same

00:43:37,950 --> 00:43:41,610
bit of memory and threads occasionally

00:43:39,570 --> 00:43:44,220
die and get brought up again they all

00:43:41,610 --> 00:43:46,740
are accessing the same shared resource

00:43:44,220 --> 00:43:48,900
at some point you need to know when that

00:43:46,740 --> 00:43:50,760
resource can be safely allocated because

00:43:48,900 --> 00:43:53,040
if UD allocate the resource to Berlin

00:43:50,760 --> 00:43:56,430
try to use it again that will cause

00:43:53,040 --> 00:43:58,950
death destruction war in horror if you

00:43:56,430 --> 00:44:00,600
also if you happen to deallocate if you

00:43:58,950 --> 00:44:03,840
happen to free the same thing twice that

00:44:00,600 --> 00:44:05,100
also gives that causes actually the

00:44:03,840 --> 00:44:08,670
colonel spit out some very interesting

00:44:05,100 --> 00:44:10,740
messages double double fries are also

00:44:08,670 --> 00:44:13,920
that and that's also conservative fatal

00:44:10,740 --> 00:44:17,400
condition so what you do is that you

00:44:13,920 --> 00:44:22,680
have a associated with your pointer to

00:44:17,400 --> 00:44:24,450
whatever you have a you have a just a

00:44:22,680 --> 00:44:28,380
number a number keeps track of how many

00:44:24,450 --> 00:44:31,650
times this object is being used

00:44:28,380 --> 00:44:33,329
and then when the when the reference is

00:44:31,650 --> 00:44:36,029
just the reference count and when this

00:44:33,329 --> 00:44:39,210
gets to die gets down to zero it is

00:44:36,029 --> 00:44:42,390
considered safe to be freed and often is

00:44:39,210 --> 00:44:44,579
done so this is actually how like I've

00:44:42,390 --> 00:44:48,089
if you've ever look at how we'll get

00:44:44,579 --> 00:44:51,210
Python see bindings they have reference

00:44:48,089 --> 00:44:54,630
counted pointers inside python that can

00:44:51,210 --> 00:44:56,279
be used to track see objects if you need

00:44:54,630 --> 00:44:58,819
to do that sort of thing either need

00:44:56,279 --> 00:45:02,490
opaque Python objects that's a

00:44:58,819 --> 00:45:06,210
moderately common use case I believe so

00:45:02,490 --> 00:45:08,369
now we're at the end or near the end we

00:45:06,210 --> 00:45:10,519
have some time for questions and garbage

00:45:08,369 --> 00:45:13,859
collection if you want to hear it so

00:45:10,519 --> 00:45:17,390
this is the very complicate Appa come

00:45:13,859 --> 00:45:20,940
there are many books written on it so

00:45:17,390 --> 00:45:23,009
first one a computer this is a typical

00:45:20,940 --> 00:45:25,859
computer architecture textbook computer

00:45:23,009 --> 00:45:27,450
organization design it's not the third

00:45:25,859 --> 00:45:31,220
edition more select maybe the fifth one

00:45:27,450 --> 00:45:33,750
is edition this contains a lot of

00:45:31,220 --> 00:45:35,490
information on how well computers will

00:45:33,750 --> 00:45:37,319
compute how the things that get from

00:45:35,490 --> 00:45:39,450
memory into the processor how processors

00:45:37,319 --> 00:45:42,329
are kind of our sort of laid out

00:45:39,450 --> 00:45:44,299
remember the memory hierarchy sort of

00:45:42,329 --> 00:45:48,630
thing it's mostly based on the

00:45:44,299 --> 00:45:50,400
instruction set calm it's the last thing

00:45:48,630 --> 00:45:53,509
I remember being used on that was common

00:45:50,400 --> 00:45:57,450
was the PlayStation 2 but is compared to

00:45:53,509 --> 00:46:00,059
x86 the door even 32-bit x86 it's much

00:45:57,450 --> 00:46:03,029
easier to understand there are men there

00:46:00,059 --> 00:46:06,990
are many emulators for it well common

00:46:03,029 --> 00:46:10,589
one is called spin and operating systems

00:46:06,990 --> 00:46:12,900
the common book for that is it's called

00:46:10,589 --> 00:46:14,069
the dinosaur book it has dinosaurs on

00:46:12,900 --> 00:46:16,680
every single dish soap has headed

00:46:14,069 --> 00:46:19,740
dinosaurs on the cover for no known

00:46:16,680 --> 00:46:22,859
reason and this is a just contains

00:46:19,740 --> 00:46:25,049
suffering about how operating systems do

00:46:22,859 --> 00:46:27,740
their thing like virtual memory even

00:46:25,049 --> 00:46:31,410
some stuff about of a memory hierarchy

00:46:27,740 --> 00:46:33,839
file io thread locking context switching

00:46:31,410 --> 00:46:37,259
that sort of thing that one of the

00:46:33,839 --> 00:46:39,390
authors of this book silver shots also

00:46:37,259 --> 00:46:41,759
made a book also does a database that

00:46:39,390 --> 00:46:42,390
one the comment databases book that also

00:46:41,759 --> 00:46:44,460
annex book

00:46:42,390 --> 00:46:46,289
also has always has sailboats in the

00:46:44,460 --> 00:46:51,630
cover so it's always called the sailboat

00:46:46,289 --> 00:46:55,170
book right I'm trivia also if you happen

00:46:51,630 --> 00:46:58,289
to feel inclined to be more about

00:46:55,170 --> 00:47:01,440
processors there's this book I didn't

00:46:58,289 --> 00:47:03,750
really read too much into it it's a it's

00:47:01,440 --> 00:47:05,430
much more low level than the operating

00:47:03,750 --> 00:47:09,839
system higher level operating systems

00:47:05,430 --> 00:47:14,760
book or a computer general computer

00:47:09,839 --> 00:47:16,079
architecture book for functions if you

00:47:14,760 --> 00:47:18,450
need to figure out how a function

00:47:16,079 --> 00:47:19,890
particular member likes you as c

00:47:18,450 --> 00:47:22,170
function works often these are

00:47:19,890 --> 00:47:26,309
documented in man pages under section 3

00:47:22,170 --> 00:47:29,039
of the or should i not sure exactly what

00:47:26,309 --> 00:47:31,109
that's called with just a part 3 of the

00:47:29,039 --> 00:47:33,000
man pages directory if you go if you

00:47:31,109 --> 00:47:34,559
just type in man free in there it will

00:47:33,000 --> 00:47:35,940
go with searching for searches up

00:47:34,559 --> 00:47:37,049
through the numbers and the man pages

00:47:35,940 --> 00:47:40,019
directory and the first thing that will

00:47:37,049 --> 00:47:41,309
find is the program free that is uh not

00:47:40,019 --> 00:47:44,579
what you're looking for so yeah that

00:47:41,309 --> 00:47:46,500
specify three there to get two free like

00:47:44,579 --> 00:47:48,539
all the standard c library functions are

00:47:46,500 --> 00:47:50,369
documented in there in somewhere server

00:47:48,539 --> 00:47:54,900
for also gives you caveat sand a lot of

00:47:50,369 --> 00:47:57,329
times use cases and furthermore um this

00:47:54,900 --> 00:47:58,859
is a topic that is a people many people

00:47:57,329 --> 00:48:01,319
I've asked questions about so if you

00:47:58,859 --> 00:48:02,579
start if you have a problem and you need

00:48:01,319 --> 00:48:04,349
to figure and you have a question for

00:48:02,579 --> 00:48:05,519
there's almost certainly well certainly

00:48:04,349 --> 00:48:07,650
someone has asked that question on Stack

00:48:05,519 --> 00:48:09,420
Overflow before or say in some other

00:48:07,650 --> 00:48:15,619
form so you can go and look that up and

00:48:09,420 --> 00:48:17,579
get a pretty actually very very

00:48:15,619 --> 00:48:19,380
elaborate answers written by people

00:48:17,579 --> 00:48:20,309
actually it's quite impressive there

00:48:19,380 --> 00:48:24,839
something there and some of the stuff

00:48:20,309 --> 00:48:27,539
I've said here so um that's all I got

00:48:24,839 --> 00:48:29,849
for you so I can answer questions I can

00:48:27,539 --> 00:48:35,509
talk a little bit about a garbage

00:48:29,849 --> 00:48:35,509
collection or are weary folks

00:48:36,670 --> 00:48:43,990
alright i have about 10 mins right so

00:48:41,960 --> 00:48:55,300
i'll go let's go and talk a little about

00:48:43,990 --> 00:48:55,300
garbage collection so no

00:48:59,300 --> 00:49:05,120
so problem is when you have a lot of

00:49:03,500 --> 00:49:06,680
when you have a lot of programming

00:49:05,120 --> 00:49:09,200
language when you have a lot of lot of

00:49:06,680 --> 00:49:12,740
stuff handling memories hard and

00:49:09,200 --> 00:49:15,230
complicated so these days a lot of

00:49:12,740 --> 00:49:18,080
languages have stuff built in that goes

00:49:15,230 --> 00:49:21,860
and keeps track of all the memory as

00:49:18,080 --> 00:49:27,320
being either process so I think you

00:49:21,860 --> 00:49:29,030
might have a say this is your heap

00:49:27,320 --> 00:49:32,920
memory this is yours is the dynamic

00:49:29,030 --> 00:49:37,130
memory of all the stuff you've a Malik

00:49:32,920 --> 00:49:42,710
example and then you have all this other

00:49:37,130 --> 00:49:44,810
stuff this is your stack and your

00:49:42,710 --> 00:49:47,870
registers r all the known values are in

00:49:44,810 --> 00:49:50,210
the well we're all the pro all the

00:49:47,870 --> 00:49:54,950
values you're currently know about or

00:49:50,210 --> 00:50:01,370
can access so there's a lot of stuff in

00:49:54,950 --> 00:50:05,600
here so say you scan all these and you

00:50:01,370 --> 00:50:12,260
find out that you can access this one

00:50:05,600 --> 00:50:14,540
and this one means they are somehow

00:50:12,260 --> 00:50:18,380
guaranteed there's some how do there's

00:50:14,540 --> 00:50:20,480
somehow still in use so you just go look

00:50:18,380 --> 00:50:24,010
at all this other space and like oh wait

00:50:20,480 --> 00:50:29,300
I don't need to hold on to this anymore

00:50:24,010 --> 00:50:30,650
so it can go and do allocate them if it

00:50:29,300 --> 00:50:32,840
want to generally it doesn't actually

00:50:30,650 --> 00:50:34,820
gallic ate them well it does that just

00:50:32,840 --> 00:50:38,210
sets them it just sets the memory as

00:50:34,820 --> 00:50:40,790
unused and if you need to access it if

00:50:38,210 --> 00:50:44,120
you need say say you are calling a

00:50:40,790 --> 00:50:48,980
function that makes a lot of arrays to a

00:50:44,120 --> 00:50:50,930
lot of lists of objects and you they are

00:50:48,980 --> 00:50:53,600
all a proc they're all like the same so

00:50:50,930 --> 00:50:55,130
you're always reducing a 16-6 you're

00:50:53,600 --> 00:50:57,680
overusing 16 of the same thing you're

00:50:55,130 --> 00:50:59,720
always the allocated you're always don't

00:50:57,680 --> 00:51:02,300
need any more it will just go and they

00:50:59,720 --> 00:51:04,190
could go and use this block of memory

00:51:02,300 --> 00:51:06,370
again and not have to worry about

00:51:04,190 --> 00:51:10,600
requesting it from the colonel it's dumb

00:51:06,370 --> 00:51:10,600
recycle recycle space

00:51:11,130 --> 00:51:19,680
is a some people some people call this

00:51:14,430 --> 00:51:21,150
the memory allocator not allocator like

00:51:19,680 --> 00:51:22,800
I've seen like sometimes seen

00:51:21,150 --> 00:51:25,080
applications go let's go in to take up

00:51:22,800 --> 00:51:27,210
memory and I used like stay at a

00:51:25,080 --> 00:51:29,130
particular usage in memory after a long

00:51:27,210 --> 00:51:32,130
period of time this might be what this

00:51:29,130 --> 00:51:35,340
might be what they're doing here this is

00:51:32,130 --> 00:51:39,060
a general the what a garbage flutter for

00:51:35,340 --> 00:51:42,750
see written by a guy named think this

00:51:39,060 --> 00:51:47,490
how you spell it Hans balm I think sags

00:51:42,750 --> 00:51:50,330
moment this is fame yeah so this guy i

00:51:47,490 --> 00:51:52,530
wrote a garbage collector for see it's

00:51:50,330 --> 00:51:56,580
pretty complicated works on similar

00:51:52,530 --> 00:51:59,760
principle of this it sweeps it marks

00:51:56,580 --> 00:52:02,490
stuff in memory that is in those in use

00:51:59,760 --> 00:52:05,700
goes through the heap then sweeps for

00:52:02,490 --> 00:52:08,610
values that it can believe it can no

00:52:05,700 --> 00:52:10,320
longer access it does this it by finding

00:52:08,610 --> 00:52:12,800
values that things look like pointers

00:52:10,320 --> 00:52:15,150
i'm not sure exactly how it does this i

00:52:12,800 --> 00:52:16,770
had sighs wearily originally set up at

00:52:15,150 --> 00:52:21,570
the explanation of how it worked was

00:52:16,770 --> 00:52:23,250
black magic it might as well be and is

00:52:21,570 --> 00:52:24,780
this if you actually days if you

00:52:23,250 --> 00:52:26,940
actually want a garbage collection you

00:52:24,780 --> 00:52:28,740
would use a language that support it

00:52:26,940 --> 00:52:32,190
beautifully and not have to worry about

00:52:28,740 --> 00:52:35,370
this other complex stuff other sometimes

00:52:32,190 --> 00:52:37,680
you can use the bangor bone pain garbage

00:52:35,370 --> 00:52:42,210
collector as a memory leak checking tool

00:52:37,680 --> 00:52:44,460
and that's a also that they also talk

00:52:42,210 --> 00:52:45,810
here in how to use it is that so I never

00:52:44,460 --> 00:52:48,510
actually tried use tried using it

00:52:45,810 --> 00:52:49,980
because I haven't had any be any real

00:52:48,510 --> 00:52:51,380
big application for that we r memory

00:52:49,980 --> 00:52:55,920
leaks were up ended up being a problem

00:52:51,380 --> 00:53:02,700
so I'm just summoned something to

00:52:55,920 --> 00:53:04,150
consider yeah all right now I have five

00:53:02,700 --> 00:53:21,849
minutes

00:53:04,150 --> 00:53:25,230
so any questions comments turns yes the

00:53:21,849 --> 00:53:28,599
question was what are my use cases for

00:53:25,230 --> 00:53:31,410
balga or using a like a memory lychee

00:53:28,599 --> 00:53:33,640
butter often this thing's it gets I

00:53:31,410 --> 00:53:34,960
haven't actually used it myself yet I

00:53:33,640 --> 00:53:37,390
just still that big actually I used it

00:53:34,960 --> 00:53:38,470
like once and I never and I was just to

00:53:37,390 --> 00:53:40,750
figure out the memorization of an

00:53:38,470 --> 00:53:43,779
application I just know it exists I know

00:53:40,750 --> 00:53:46,180
a lot of people use it typically it's

00:53:43,779 --> 00:53:47,970
used for big things out run for a lot of

00:53:46,180 --> 00:53:50,380
time so presumably it would already

00:53:47,970 --> 00:53:52,690
exists we've already exists need to

00:53:50,380 --> 00:53:55,619
track it in it usually to track it and

00:53:52,690 --> 00:53:58,329
through an accurate of execution

00:53:55,619 --> 00:54:01,119
something like that just a theory i

00:53:58,329 --> 00:54:02,680
haven't had to I think you're having

00:54:01,119 --> 00:54:04,329
good enough not to create any memory

00:54:02,680 --> 00:54:06,520
leaks or I haven't done anything is big

00:54:04,329 --> 00:54:07,990
enough to have a warrant at debugging

00:54:06,520 --> 00:54:13,569
them in touch away or I couldn't just

00:54:07,990 --> 00:54:15,609
use a say gdb oh yeah GDB GDB is a nice

00:54:13,569 --> 00:54:18,430
tool for debugging your C programs they

00:54:15,609 --> 00:54:23,680
can go if you compile your programs with

00:54:18,430 --> 00:54:25,089
the G flag your program will become a

00:54:23,680 --> 00:54:27,579
lot bigger and contain a lot of

00:54:25,089 --> 00:54:30,490
debugging information that if so that if

00:54:27,579 --> 00:54:34,299
it were to crash and produced a core

00:54:30,490 --> 00:54:36,819
dump file you could go and run GDP gdb

00:54:34,299 --> 00:54:39,970
on the core don't file in the program

00:54:36,819 --> 00:54:42,069
and get a trace of precisely where thing

00:54:39,970 --> 00:54:44,980
of the trace of the function that led to

00:54:42,069 --> 00:54:47,410
your programs demise you can also run

00:54:44,980 --> 00:54:50,920
gdb inside your we run your program with

00:54:47,410 --> 00:54:53,859
gb and just in step through it see what

00:54:50,920 --> 00:54:55,630
up see what today we're doing a funky

00:54:53,859 --> 00:54:58,059
behavior you can print out values from

00:54:55,630 --> 00:55:01,569
their registers you can print out values

00:54:58,059 --> 00:55:03,250
from variables you can print pointers

00:55:01,569 --> 00:55:04,950
you can attempt to dereference pointers

00:55:03,250 --> 00:55:06,640
and see that some of them are null

00:55:04,950 --> 00:55:09,010
reporting off into space where they

00:55:06,640 --> 00:55:11,140
shouldn't and you can also actually see

00:55:09,010 --> 00:55:14,020
us we can sexually see assembly as it's

00:55:11,140 --> 00:55:15,910
being executed two if

00:55:14,020 --> 00:55:18,370
think you can do that I'd be surprised

00:55:15,910 --> 00:55:20,410
if we could in a few if you wanted to

00:55:18,370 --> 00:55:29,070
you could go and compile the assembly

00:55:20,410 --> 00:55:29,070
into binary anyway using uh that

00:55:30,560 --> 00:55:35,510
anything else I fan all be if there's

00:55:33,650 --> 00:55:38,600
anything I'll be around all day today

00:55:35,510 --> 00:55:50,900
and a bit of tomorrow yep questions or

00:55:38,600 --> 00:55:53,360
want to pick my brain your customers

00:55:50,900 --> 00:55:55,730
rely on your website or application if

00:55:53,360 --> 00:55:59,120
it's slower non-responsive it infuriates

00:55:55,730 --> 00:56:00,830
your users and costs you money keeping

00:55:59,120 --> 00:56:02,810
your business critical systems humming

00:56:00,830 --> 00:56:04,570
along requires insight into what they're

00:56:02,810 --> 00:56:06,880
doing

00:56:04,570 --> 00:56:08,830
your system metrics tells stories

00:56:06,880 --> 00:56:10,840
stories that can reveal performance

00:56:08,830 --> 00:56:13,180
bottlenecks resource limitations and

00:56:10,840 --> 00:56:14,740
other problems but how do you keep an

00:56:13,180 --> 00:56:17,380
eye on all of your systems performance

00:56:14,740 --> 00:56:20,410
metrics in real-time and record this

00:56:17,380 --> 00:56:22,390
data for later analysis enter longview

00:56:20,410 --> 00:56:24,190
the new way to see what's really going

00:56:22,390 --> 00:56:26,350
on under the hood the long view

00:56:24,190 --> 00:56:28,420
dashboard lets you visualize the status

00:56:26,350 --> 00:56:30,880
of all your systems providing you with a

00:56:28,420 --> 00:56:34,240
bird's-eye view of your entire fleet you

00:56:30,880 --> 00:56:36,820
can sort by cpu memory swap processes

00:56:34,240 --> 00:56:38,590
load and network usage click a specific

00:56:36,820 --> 00:56:40,990
system to access its individual

00:56:38,590 --> 00:56:43,500
dashboard then click and drag to zoom in

00:56:40,990 --> 00:56:45,910
on chokepoints and get more detail

00:56:43,500 --> 00:56:47,560
comprehensive network data including

00:56:45,910 --> 00:56:49,900
inbound and outbound traffic is

00:56:47,560 --> 00:56:51,460
available on the network tab and disk

00:56:49,900 --> 00:56:53,380
rights and free space on the disk

00:56:51,460 --> 00:56:56,230
stabbed while the process Explorer

00:56:53,380 --> 00:56:58,750
displays usage statistics for individual

00:56:56,230 --> 00:57:00,910
processes the system info tab shows

00:56:58,750 --> 00:57:03,160
listening services active connections

00:57:00,910 --> 00:57:05,290
and available updates adding long view

00:57:03,160 --> 00:57:07,000
to a system is easy just click the

00:57:05,290 --> 00:57:09,130
button copy the one line installation

00:57:07,000 --> 00:57:11,590
command then run the command on your

00:57:09,130 --> 00:57:13,270
linux system to complete the process the

00:57:11,590 --> 00:57:15,460
agent will begin collecting data and

00:57:13,270 --> 00:57:17,319
sending it to longview then the graph

00:57:15,460 --> 00:57:19,869
start rolling

00:57:17,319 --> 00:57:22,239
used longview to gain visibility into

00:57:19,869 --> 00:57:25,979
your servers so when your website or app

00:57:22,239 --> 00:57:25,979

YouTube URL: https://www.youtube.com/watch?v=M7rlIeYGkco


