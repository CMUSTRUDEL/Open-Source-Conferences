Title: 2014 SouthEast LinuxFest - Nik Everett - Tour of an Elasticsearch Application
Publication date: 2015-04-26
Playlist: 2014 SouthEast LinuxFest
Description: 
	2014 SouthEast LinuxFest
Nik Everett
Tour of an Elasticsearch Application
Captions: 
	00:00:00,000 --> 00:00:05,339
the following presentation was recorded

00:00:02,490 --> 00:00:08,250
the 2014 southeast linux fest in

00:00:05,339 --> 00:00:11,070
charlotte north carolina it is licensed

00:00:08,250 --> 00:00:14,880
under a creative commons license for

00:00:11,070 --> 00:00:18,180
more information visit www selfies linux

00:00:14,880 --> 00:00:19,710
pc org the southeast linux fest would

00:00:18,180 --> 00:00:22,740
like to thank the following diamond

00:00:19,710 --> 00:00:28,890
sponsors in 2014 for helping make these

00:00:22,740 --> 00:00:30,330
videos pause so i'm nick everett and six

00:00:28,890 --> 00:00:33,239
months ago when the call for submissions

00:00:30,330 --> 00:00:35,160
came out i was this tour of an elastic

00:00:33,239 --> 00:00:36,510
search application the presentation is

00:00:35,160 --> 00:00:38,160
sort of changed in a little bit in the

00:00:36,510 --> 00:00:41,550
past six months though there's tour in

00:00:38,160 --> 00:00:43,170
there I promise so what I'm actually

00:00:41,550 --> 00:00:45,050
going to do in the presentation I'm

00:00:43,170 --> 00:00:49,890
going to define some basic terms

00:00:45,050 --> 00:00:53,789
elasticsearch make a great week and ed

00:00:49,890 --> 00:00:55,770
foundation things like that I am going

00:00:53,789 --> 00:00:57,539
to present some of basic development

00:00:55,770 --> 00:00:59,969
workflow for elastic search I'm going to

00:00:57,539 --> 00:01:03,989
define all the terms that I say again in

00:00:59,969 --> 00:01:05,189
a workflow and get a relate that to see

00:01:03,989 --> 00:01:08,520
research and then I'm going to answer

00:01:05,189 --> 00:01:11,640
some wonderful insightful questions from

00:01:08,520 --> 00:01:14,580
you in fact you can ask me questions

00:01:11,640 --> 00:01:16,560
anytime you like I promise to repeat the

00:01:14,580 --> 00:01:19,370
question so that it gets recorded I

00:01:16,560 --> 00:01:22,050
don't shout at me

00:01:19,370 --> 00:01:24,450
raise your hand or shout or whatever and

00:01:22,050 --> 00:01:25,830
if I make some horrible mistake like one

00:01:24,450 --> 00:01:28,410
presentation i forgot to find

00:01:25,830 --> 00:01:30,330
elasticsearch and a guy shouted at me

00:01:28,410 --> 00:01:33,270
and told me to do that if you save the

00:01:30,330 --> 00:01:38,160
presentation so if I make such a mistake

00:01:33,270 --> 00:01:41,100
again save the presentation one ok so

00:01:38,160 --> 00:01:43,710
I'm Nick Everett my job is to replace

00:01:41,100 --> 00:01:47,810
the on site search used at the wikimedia

00:01:43,710 --> 00:01:52,470
foundation so that's wikis like

00:01:47,810 --> 00:01:56,420
Wikipedia Commons what all right there's

00:01:52,470 --> 00:01:58,470
Italian German French I mean there's a

00:01:56,420 --> 00:02:01,500
right and there's tons of other things

00:01:58,470 --> 00:02:04,710
wiktionary wiki source wikinews lots of

00:02:01,500 --> 00:02:07,050
it yeah so the process I've become an

00:02:04,710 --> 00:02:10,170
elastic search contributor and a minor

00:02:07,050 --> 00:02:12,150
contributor to see and also to elastica

00:02:10,170 --> 00:02:16,160
which is a PHP library these communicate

00:02:12,150 --> 00:02:16,160
with elastic search

00:02:16,470 --> 00:02:25,360
so who's used a less attention one happy

00:02:21,940 --> 00:02:28,210
that's cool we used it in production

00:02:25,360 --> 00:02:30,120
okay great so I I'm going to try to

00:02:28,210 --> 00:02:33,640
customize the talk a little bit for

00:02:30,120 --> 00:02:37,930
given that data but I'm not very good at

00:02:33,640 --> 00:02:39,850
sneaking so I don't promise much so you

00:02:37,930 --> 00:02:41,290
can think of elasticsearch as a

00:02:39,850 --> 00:02:42,520
multi-tenant Charlotte replicated

00:02:41,290 --> 00:02:45,910
restful document store with full text

00:02:42,520 --> 00:02:48,100
circuit that's a lot of stuff mogly

00:02:45,910 --> 00:02:50,860
pennant means that there are multiple

00:02:48,100 --> 00:02:53,500
indexes served out of the same cluster

00:02:50,860 --> 00:02:57,430
so these are like totally separate sets

00:02:53,500 --> 00:03:02,500
of documents chardon means that each

00:02:57,430 --> 00:03:05,470
index is broken up into multiple broken

00:03:02,500 --> 00:03:08,290
up into multiple chars and put on open

00:03:05,470 --> 00:03:09,580
with machines replicated means the

00:03:08,290 --> 00:03:11,200
shards are replicated on a multiple

00:03:09,580 --> 00:03:13,450
machine so you have some degree of fault

00:03:11,200 --> 00:03:16,540
tolerance you could lose actually all of

00:03:13,450 --> 00:03:19,530
the nodes all of the servers that serve

00:03:16,540 --> 00:03:21,580
a particular shard and you could still

00:03:19,530 --> 00:03:23,950
reply with the sharts that you have

00:03:21,580 --> 00:03:28,690
still run you get an error message but

00:03:23,950 --> 00:03:31,720
you can still get some documents russell

00:03:28,690 --> 00:03:34,989
documents or means yesh of JSON in it

00:03:31,720 --> 00:03:37,150
with HTTP and a sauna JSON pasta with

00:03:34,989 --> 00:03:40,150
HTTP that's probably an abuse of the

00:03:37,150 --> 00:03:43,150
term restful but it's good enough and

00:03:40,150 --> 00:03:44,620
people kind of get the point full text

00:03:43,150 --> 00:03:48,870
search means it has those things

00:03:44,620 --> 00:03:51,130
language analysis relevancy sorting i

00:03:48,870 --> 00:03:54,549
can describe them sort of more

00:03:51,130 --> 00:03:55,630
intimately later let's search also has a

00:03:54,549 --> 00:03:59,680
bunch of other stuff that's really cool

00:03:55,630 --> 00:04:01,780
that you can look up if you want so your

00:03:59,680 --> 00:04:06,280
search is the meeting if you plug in and

00:04:01,780 --> 00:04:09,450
I work on and it takes data from me wiki

00:04:06,280 --> 00:04:12,370
and squishes it into elasticsearch and

00:04:09,450 --> 00:04:14,700
then takes requests from mediawiki like

00:04:12,370 --> 00:04:16,660
search requests and turns them into

00:04:14,700 --> 00:04:19,510
requests to elasticsearch and then

00:04:16,660 --> 00:04:22,090
pushes them back out to the rest of

00:04:19,510 --> 00:04:23,590
mediawiki the idea is that elastic

00:04:22,090 --> 00:04:25,690
search and mediawiki you should not know

00:04:23,590 --> 00:04:29,260
about each other and so supposedly

00:04:25,690 --> 00:04:31,180
mediawiki is the simple rapper between

00:04:29,260 --> 00:04:32,979
them but as you can see you know there's

00:04:31,180 --> 00:04:34,840
basic searches that it has to serve like

00:04:32,979 --> 00:04:36,680
Nobel Prize winners but there's also

00:04:34,840 --> 00:04:38,270
some relatively complicated

00:04:36,680 --> 00:04:41,449
it queries that it has to serve like

00:04:38,270 --> 00:04:42,740
this query here is a person looking to

00:04:41,449 --> 00:04:44,479
find pictures of cats that are not in

00:04:42,740 --> 00:04:46,340
the category pictures of cats so that

00:04:44,479 --> 00:04:47,979
they can put them in the category

00:04:46,340 --> 00:04:51,320
pictures of cats this is something that

00:04:47,979 --> 00:04:54,919
people do when they maintain the

00:04:51,320 --> 00:04:56,750
category hierarchy almonds I have a guy

00:04:54,919 --> 00:04:58,610
that talks me all the time about it sira

00:04:56,750 --> 00:05:00,289
search is named after cloud because

00:04:58,610 --> 00:05:02,240
clouds are buzzwords and we couldn't

00:05:00,289 --> 00:05:03,860
think of a good name that is a picture

00:05:02,240 --> 00:05:06,370
of a cirrus cloud that it's way too

00:05:03,860 --> 00:05:10,190
small for you to see I'm very sorry but

00:05:06,370 --> 00:05:12,830
it's the long stringy kind sort of a

00:05:10,190 --> 00:05:14,180
fluffy kind at the top the neat thing

00:05:12,830 --> 00:05:16,490
about wikimedia foundation is that most

00:05:14,180 --> 00:05:18,800
of the work we do is public the public

00:05:16,490 --> 00:05:20,780
configuration is public the monitoring

00:05:18,800 --> 00:05:23,690
configuration is public and all the

00:05:20,780 --> 00:05:26,720
source of mediawiki itself Cirrus search

00:05:23,690 --> 00:05:29,960
we have an elastic search extension that

00:05:26,720 --> 00:05:31,729
we use is also public an elastic

00:05:29,960 --> 00:05:34,280
searches public scenes public and all

00:05:31,729 --> 00:05:35,479
the libraries on down our public and

00:05:34,280 --> 00:05:37,610
everything else as we do some way

00:05:35,479 --> 00:05:39,970
there's no secret sauce the only secrets

00:05:37,610 --> 00:05:41,990
are the database passwords very much

00:05:39,970 --> 00:05:44,780
well actually there are three secret

00:05:41,990 --> 00:05:48,110
sauces for database passwords logstash

00:05:44,780 --> 00:05:51,080
log files in a single so our monitoring

00:05:48,110 --> 00:05:54,470
we don't have a tool to anonymize the

00:05:51,080 --> 00:05:55,880
logs so we have a privacy policy that

00:05:54,470 --> 00:05:58,070
has a snoot them after certain period of

00:05:55,880 --> 00:05:59,150
time and we only a lot of people that

00:05:58,070 --> 00:06:00,979
have signed in gates to look at them

00:05:59,150 --> 00:06:05,810
thus I cannot show you our beautiful

00:06:00,979 --> 00:06:09,050
beautiful log stash installed sorry so I

00:06:05,810 --> 00:06:11,930
just to find a bunch of terms this is a

00:06:09,050 --> 00:06:15,680
basic development workflow it's my

00:06:11,930 --> 00:06:18,259
opinion it's not necessarily what you're

00:06:15,680 --> 00:06:22,360
going to always follow or maybe you

00:06:18,259 --> 00:06:22,360
think I feel but what I did

00:06:23,139 --> 00:06:27,810
you dump documents in the index which

00:06:25,300 --> 00:06:30,520
means you build the mattress or system

00:06:27,810 --> 00:06:33,909
you write some queries and if you're

00:06:30,520 --> 00:06:36,009
right sweet you go there if they don't

00:06:33,909 --> 00:06:38,379
spout the right answer there are four

00:06:36,009 --> 00:06:39,999
things that you might have to change if

00:06:38,379 --> 00:06:44,229
you're lucky you just change the word

00:06:39,999 --> 00:06:45,849
easy if you're really unlucky you change

00:06:44,229 --> 00:06:47,439
the documents and regenerating with the

00:06:45,849 --> 00:06:49,419
sources in the piston back in the into

00:06:47,439 --> 00:06:52,539
elasticsearch if you're somewhere in

00:06:49,419 --> 00:06:56,650
between you change the analysis or the

00:06:52,539 --> 00:06:59,919
mapping and what our mapping and

00:06:56,650 --> 00:07:02,860
analysis you ask well I will define them

00:06:59,919 --> 00:07:08,050
right here first of all documents I said

00:07:02,860 --> 00:07:11,169
they're JSON you shove them in in single

00:07:08,050 --> 00:07:14,409
or in bulk and they sort of spring to

00:07:11,169 --> 00:07:17,039
life they spring to searchability after

00:07:14,409 --> 00:07:19,839
a certain configured period of time

00:07:17,039 --> 00:07:21,430
there are reasons but it's not worth

00:07:19,839 --> 00:07:24,779
going into now you can look it up if you

00:07:21,430 --> 00:07:30,069
want it's called a mere real time anyway

00:07:24,779 --> 00:07:32,529
the queries are opposed to json yay they

00:07:30,069 --> 00:07:35,199
can get really really big the one that I

00:07:32,529 --> 00:07:38,710
send for a regular user text search is a

00:07:35,199 --> 00:07:40,089
couple of months I mean you would think

00:07:38,710 --> 00:07:44,110
that this is a problem and they have a

00:07:40,089 --> 00:07:46,060
feature that lets you use templates on

00:07:44,110 --> 00:07:47,409
the server side and it like evaluates a

00:07:46,060 --> 00:07:49,240
mustache template and then builds the

00:07:47,409 --> 00:07:51,689
crazy way but it really hasn't been an

00:07:49,240 --> 00:07:54,279
issue for us the size of the requests

00:07:51,689 --> 00:07:55,770
any post them anyway so it's not like

00:07:54,279 --> 00:07:57,260
you're going to hit some weird limit

00:07:55,770 --> 00:08:01,850
like

00:07:57,260 --> 00:08:03,200
there's something odd so mapping of

00:08:01,850 --> 00:08:09,020
course you want to note mapping it said

00:08:03,200 --> 00:08:12,860
that word so elastic search has types so

00:08:09,020 --> 00:08:21,500
let's go look at a document the document

00:08:12,860 --> 00:08:24,050
are you video in that thing when you put

00:08:21,500 --> 00:08:27,920
a document in the index this thing right

00:08:24,050 --> 00:08:29,960
here is the indus right that's that's

00:08:27,920 --> 00:08:31,070
how it smells lieutenant you just choose

00:08:29,960 --> 00:08:34,130
a different one you want a different

00:08:31,070 --> 00:08:37,220
different index this is the time this is

00:08:34,130 --> 00:08:38,990
the type the type is used for

00:08:37,220 --> 00:08:44,390
segregating different kinds of documents

00:08:38,990 --> 00:08:47,870
and so say I want to index licky ages

00:08:44,390 --> 00:08:49,490
what to do and say I also wanted to

00:08:47,870 --> 00:08:51,050
index pictures and they're actually a

00:08:49,490 --> 00:08:54,350
different thing in my case they're not

00:08:51,050 --> 00:08:55,760
but say they wore then I would have a

00:08:54,350 --> 00:09:00,710
different type i would have a picture

00:08:55,760 --> 00:09:02,510
pipe in decide whatever and so each type

00:09:00,710 --> 00:09:04,280
is a key into different kind of map it

00:09:02,510 --> 00:09:07,340
each type has a napping right and those

00:09:04,280 --> 00:09:12,830
mappings define what the fields are on

00:09:07,340 --> 00:09:15,470
the document stop it would i go there

00:09:12,830 --> 00:09:18,710
you so see how there's a phrase field in

00:09:15,470 --> 00:09:20,480
that JSON so that's one of the fields on

00:09:18,710 --> 00:09:23,390
that on a mapping there can be bunches

00:09:20,480 --> 00:09:24,740
of them that it can be nested the sort

00:09:23,390 --> 00:09:26,120
of funkiness that goes along in your

00:09:24,740 --> 00:09:28,700
nest things you can in both devalued

00:09:26,120 --> 00:09:30,620
fields it's all great so the upshot is

00:09:28,700 --> 00:09:32,350
that elastic search will create the

00:09:30,620 --> 00:09:34,940
fields on the fly when you add them in

00:09:32,350 --> 00:09:37,370
that's really useful because in a lot of

00:09:34,940 --> 00:09:39,050
cases the default analysis works great

00:09:37,370 --> 00:09:42,710
it splits on spaces and things like that

00:09:39,050 --> 00:09:46,810
and it lower cases the words right

00:09:42,710 --> 00:09:46,810
that's often what you want to do

00:09:48,560 --> 00:09:55,980
okay so analysis is how the strings are

00:09:52,589 --> 00:09:57,180
tokenized I have another pretty picture

00:09:55,980 --> 00:09:59,730
that i didn't put in this presentation

00:09:57,180 --> 00:10:01,440
that i should have which shows you steps

00:09:59,730 --> 00:10:03,839
like if you have a sentence it's broken

00:10:01,440 --> 00:10:05,790
up into words and in the words or lower

00:10:03,839 --> 00:10:07,410
case you can also configure the

00:10:05,790 --> 00:10:10,290
analyzers to be more complicated to do

00:10:07,410 --> 00:10:11,880
things like flattened out like high

00:10:10,290 --> 00:10:13,829
ASCII characters into the low ASCII

00:10:11,880 --> 00:10:16,560
characters you can do things like stem

00:10:13,829 --> 00:10:19,220
the words take conjugated English and

00:10:16,560 --> 00:10:21,350
turn it into it's sort of its root form

00:10:19,220 --> 00:10:24,269
just a lot of stuff you can do with

00:10:21,350 --> 00:10:26,220
analysis it's done it both index of

00:10:24,269 --> 00:10:29,100
query time so when you type your query

00:10:26,220 --> 00:10:31,440
the query is analyzed and it's compared

00:10:29,100 --> 00:10:34,889
it's analyzed with the same or probably

00:10:31,440 --> 00:10:37,079
the same indexer as you or analyzer as

00:10:34,889 --> 00:10:39,000
you index the documents and then it just

00:10:37,079 --> 00:10:41,790
sort of does a look up to find the text

00:10:39,000 --> 00:10:43,589
that you're looking for so the basic

00:10:41,790 --> 00:10:45,060
workflow is send documents let the

00:10:43,589 --> 00:10:46,500
fields be created on the fly right some

00:10:45,060 --> 00:10:49,920
queries that's what I said right that's

00:10:46,500 --> 00:10:52,019
the first first way down and that's good

00:10:49,920 --> 00:10:55,410
enough sometimes for me it is totally

00:10:52,019 --> 00:10:58,740
not and I lost people it won't be but

00:10:55,410 --> 00:10:59,970
it's a great way to get started so when

00:10:58,740 --> 00:11:01,889
you want to change the mapping if

00:10:59,970 --> 00:11:05,850
there's a new field that you haven't

00:11:01,889 --> 00:11:07,949
already sent then just tell it you can

00:11:05,850 --> 00:11:14,339
configure a new mapping with this post

00:11:07,949 --> 00:11:15,899
here put I guess I never remember and if

00:11:14,339 --> 00:11:17,279
it's a new field you can just put it in

00:11:15,899 --> 00:11:23,250
if you haven't said that field before

00:11:17,279 --> 00:11:25,380
you can also add a sort of a subfield

00:11:23,250 --> 00:11:27,089
under the same field that analyzes that

00:11:25,380 --> 00:11:30,269
one field in a different way that's for

00:11:27,089 --> 00:11:31,819
you can do it at any time and well not

00:11:30,269 --> 00:11:33,930
quite any time but you can do it and

00:11:31,819 --> 00:11:38,339
then update the documents and it all

00:11:33,930 --> 00:11:39,720
works if you'll already exists you

00:11:38,339 --> 00:11:44,750
pretty much have to rebuild the in this

00:11:39,720 --> 00:11:48,930
so what you do is this mostly atomic

00:11:44,750 --> 00:11:50,910
alias swap where you have an alias to

00:11:48,930 --> 00:11:52,470
one index the index that you're actually

00:11:50,910 --> 00:11:54,300
serve in production for you stream the

00:11:52,470 --> 00:11:56,610
documents from that index into another

00:11:54,300 --> 00:11:58,920
one with the new configuration and then

00:11:56,610 --> 00:12:02,430
you say and you switch the alias

00:11:58,920 --> 00:12:04,350
that's it's a distributed system and its

00:12:02,430 --> 00:12:08,850
I've never I've never ever seen it not

00:12:04,350 --> 00:12:13,399
be like perfectly like clunk swap but so

00:12:08,850 --> 00:12:15,660
I I think it's quite atomic in any case

00:12:13,399 --> 00:12:18,029
when change analysis it's the same thing

00:12:15,660 --> 00:12:20,519
as changing Maddox same general idea

00:12:18,029 --> 00:12:23,130
like there are a few little tiny

00:12:20,519 --> 00:12:26,579
differences but you can look them up on

00:12:23,130 --> 00:12:29,550
in the documentation but that's def shot

00:12:26,579 --> 00:12:32,070
of it time series data has a neat out in

00:12:29,550 --> 00:12:34,709
that if you are indexing time series

00:12:32,070 --> 00:12:37,889
data you tend to create a new index

00:12:34,709 --> 00:12:39,389
every day so just put your new settings

00:12:37,889 --> 00:12:41,850
on the newnan decks and the old settings

00:12:39,389 --> 00:12:44,070
on the open decks done the nice part

00:12:41,850 --> 00:12:46,800
about this is that when you build

00:12:44,070 --> 00:12:51,079
queries the analyzer that's used to

00:12:46,800 --> 00:12:55,050
analyze the text for the query is often

00:12:51,079 --> 00:12:57,329
configured at index creation time that

00:12:55,050 --> 00:13:00,180
means that it's internally consistent in

00:12:57,329 --> 00:13:01,589
the old index and in the new index if

00:13:00,180 --> 00:13:05,269
you did it right and if you have a bug

00:13:01,589 --> 00:13:07,560
we need to go fix it right but hey

00:13:05,269 --> 00:13:10,230
that's no fun for me because I don't

00:13:07,560 --> 00:13:12,810
have that kind of data and it's a little

00:13:10,230 --> 00:13:13,920
easier if a little headachy because you

00:13:12,810 --> 00:13:16,829
have to worry about different kinds of

00:13:13,920 --> 00:13:18,209
indexes instead I have to reinvent my

00:13:16,829 --> 00:13:21,300
data when i change the mapping because

00:13:18,209 --> 00:13:24,660
wiki pages aren't time time series data

00:13:21,300 --> 00:13:27,449
right I can't store them in dates so i

00:13:24,660 --> 00:13:30,390
have to do this rebuild and swap that I

00:13:27,449 --> 00:13:32,160
talked about before or insert the insert

00:13:30,390 --> 00:13:34,380
all the documents newly built from the

00:13:32,160 --> 00:13:37,140
source system these may collapse if your

00:13:34,380 --> 00:13:38,640
source is quite fast then you can just

00:13:37,140 --> 00:13:41,220
create the new index and jam it in there

00:13:38,640 --> 00:13:43,800
really quickly my search system is rusev

00:13:41,220 --> 00:13:46,699
so I can't do that I have to stream them

00:13:43,800 --> 00:13:48,899
from elasticsearch so that's what I do

00:13:46,699 --> 00:13:50,279
it takes somewhere between minutes and

00:13:48,899 --> 00:13:52,470
hours for me it's about two hours for

00:13:50,279 --> 00:13:54,149
english wikipedia i typically start the

00:13:52,470 --> 00:13:57,870
process for all eight hundred of my

00:13:54,149 --> 00:14:00,360
cookies with bed and then in the morning

00:13:57,870 --> 00:14:01,860
I watch them somewhere in like the jeans

00:14:00,360 --> 00:14:03,839
and then it takes

00:14:01,860 --> 00:14:05,850
what days to cover all of them that's

00:14:03,839 --> 00:14:07,260
okay it does sort of make the monitoring

00:14:05,850 --> 00:14:11,850
scripts complain while I do it but

00:14:07,260 --> 00:14:12,600
that's too damn bad anyway um oh the

00:14:11,850 --> 00:14:13,620
other thing you have to be really

00:14:12,600 --> 00:14:15,360
careful when you're doing this that you

00:14:13,620 --> 00:14:17,310
don't sort of just smash the server

00:14:15,360 --> 00:14:18,870
because you can configure this to be

00:14:17,310 --> 00:14:21,720
really really really fast much faster

00:14:18,870 --> 00:14:24,390
than I'm doing but at the cost of

00:14:21,720 --> 00:14:25,709
hurting search performance and you don't

00:14:24,390 --> 00:14:29,700
want that because you've got people

00:14:25,709 --> 00:14:32,339
using music man that right maybe that

00:14:29,700 --> 00:14:33,209
depends on how how you work yeah the

00:14:32,339 --> 00:14:34,980
other thing is that because you're

00:14:33,209 --> 00:14:37,200
making two copies of everything you're

00:14:34,980 --> 00:14:38,130
doubling your space usage right you have

00:14:37,200 --> 00:14:39,720
to maintain you have to keep your old

00:14:38,130 --> 00:14:41,850
copy in your new copy until the swap and

00:14:39,720 --> 00:14:43,290
then you can delete the old copy wait

00:14:41,850 --> 00:14:46,649
and keep the old copy for a while in

00:14:43,290 --> 00:14:48,779
case you want to roll back inserting new

00:14:46,649 --> 00:14:51,300
documents is obviously limited by the

00:14:48,779 --> 00:14:56,670
source system and for me its way slowly

00:14:51,300 --> 00:14:58,950
like 10 days slow closest look so search

00:14:56,670 --> 00:15:00,660
has to work and it has to work when you

00:14:58,950 --> 00:15:05,399
have multiple different kinds of

00:15:00,660 --> 00:15:10,640
documents in the system and you have to

00:15:05,399 --> 00:15:14,459
live with it so the nearly atomic ones

00:15:10,640 --> 00:15:19,220
yeah I said all that stuff sweet I can

00:15:14,459 --> 00:15:19,220
skip this one right gonna say wassup

00:15:20,360 --> 00:15:25,399
oh well I guess when you release if you

00:15:23,089 --> 00:15:27,350
plan on doing the the nearly atomic like

00:15:25,399 --> 00:15:29,300
index into the other index and then swap

00:15:27,350 --> 00:15:31,670
there is a period where your application

00:15:29,300 --> 00:15:34,130
is deployed talking to the old index

00:15:31,670 --> 00:15:37,700
right and because you deployed your

00:15:34,130 --> 00:15:39,589
application to know how to reindex into

00:15:37,700 --> 00:15:41,510
the new one which is why you really want

00:15:39,589 --> 00:15:43,640
to make the old and the index is sort of

00:15:41,510 --> 00:15:45,350
internally consistent and so you end up

00:15:43,640 --> 00:15:47,240
with things like features that are

00:15:45,350 --> 00:15:48,980
disabled with some feature flag it says

00:15:47,240 --> 00:15:52,160
when I have finished the indexing I can

00:15:48,980 --> 00:15:54,410
do this and that's actually not all that

00:15:52,160 --> 00:15:57,350
common because mostly you get I've

00:15:54,410 --> 00:15:58,550
gotten to the point where i set the

00:15:57,350 --> 00:16:00,440
indexes up so that they're internally

00:15:58,550 --> 00:16:01,910
consistent by setting search analyzers

00:16:00,440 --> 00:16:05,660
on the fields that i want to query and

00:16:01,910 --> 00:16:08,720
so then it just works with the new index

00:16:05,660 --> 00:16:12,470
in the old one testing is kind of hard

00:16:08,720 --> 00:16:14,450
like that um so I've talked about two

00:16:12,470 --> 00:16:16,839
different kinds of ways to sort of bulk

00:16:14,450 --> 00:16:20,930
build your data but that's not really

00:16:16,839 --> 00:16:22,430
good enough cool hip whatever you really

00:16:20,930 --> 00:16:25,430
want to get your changes into the system

00:16:22,430 --> 00:16:26,660
fast like so that people can see it

00:16:25,430 --> 00:16:27,949
that's one of the big selling points of

00:16:26,660 --> 00:16:29,240
the project I'm working on the old

00:16:27,949 --> 00:16:32,149
system would rebuild me index every

00:16:29,240 --> 00:16:34,339
couple of days this one if you edit a

00:16:32,149 --> 00:16:39,800
page within about a minute the search

00:16:34,339 --> 00:16:41,269
index has it and that's really nice the

00:16:39,800 --> 00:16:44,390
thing you have to do is to make sure

00:16:41,269 --> 00:16:47,120
that your real time one capital for

00:16:44,390 --> 00:16:48,230
changes which can be hard and to you

00:16:47,120 --> 00:16:50,570
have to make sure that the documents

00:16:48,230 --> 00:16:52,070
that it build that it builds are exactly

00:16:50,570 --> 00:16:58,279
the same as the documents that you build

00:16:52,070 --> 00:17:01,459
in bulk and this turned out to be really

00:16:58,279 --> 00:17:03,769
important for us a fork that index

00:17:01,459 --> 00:17:05,660
update some users requests always always

00:17:03,769 --> 00:17:08,299
always looking like be really really

00:17:05,660 --> 00:17:09,980
careful make sure you book because it's

00:17:08,299 --> 00:17:11,689
really nice especially when you're first

00:17:09,980 --> 00:17:14,150
trying out if you blow up the system

00:17:11,689 --> 00:17:16,310
accidentally you want to be able to

00:17:14,150 --> 00:17:18,480
retry these things

00:17:16,310 --> 00:17:21,270
with a you know with a message queue or

00:17:18,480 --> 00:17:23,280
job thing job queue thing you can do

00:17:21,270 --> 00:17:28,770
that right if it blows up try again keep

00:17:23,280 --> 00:17:29,940
going and also if it takes your source

00:17:28,770 --> 00:17:31,650
system a long time to generate the

00:17:29,940 --> 00:17:34,610
document you don't want the user to sit

00:17:31,650 --> 00:17:37,260
around and wait for that I work in PHP

00:17:34,610 --> 00:17:39,600
like it's a single process I can't

00:17:37,260 --> 00:17:41,640
there's no threads none of that so the

00:17:39,600 --> 00:17:45,180
only threat i have is this job do you

00:17:41,640 --> 00:17:46,560
think so you might you might have

00:17:45,180 --> 00:17:51,050
different abilities depending on where

00:17:46,560 --> 00:17:53,880
what framework what language you work in

00:17:51,050 --> 00:17:56,930
so anyway I put all of that picture

00:17:53,880 --> 00:18:01,170
which I will go back to you and show you

00:17:56,930 --> 00:18:03,360
so now you should know all the words in

00:18:01,170 --> 00:18:07,130
this picture this should all make sense

00:18:03,360 --> 00:18:07,130
and if they don't make sense

00:18:10,119 --> 00:18:12,779
ok

00:18:16,240 --> 00:18:22,870
so now I'm going to relate what I said

00:18:18,910 --> 00:18:25,679
all that that first picture to see

00:18:22,870 --> 00:18:29,290
research the application that we have

00:18:25,679 --> 00:18:31,870
well happy faces mediawiki and he is our

00:18:29,290 --> 00:18:33,910
user stand-in because you translates

00:18:31,870 --> 00:18:36,220
user requests like either actually

00:18:33,910 --> 00:18:39,309
search requests fine head and you like

00:18:36,220 --> 00:18:45,160
finest you type requests or API requests

00:18:39,309 --> 00:18:48,490
translate them all into queries the

00:18:45,160 --> 00:18:50,770
query builder box send sins queries to

00:18:48,490 --> 00:18:53,500
elasticsearch it uses we in our case we

00:18:50,770 --> 00:18:55,540
have different kinds of results so we

00:18:53,500 --> 00:18:59,410
have these results type things that no

00:18:55,540 --> 00:19:02,020
have to tell elasticsearch what portions

00:18:59,410 --> 00:19:03,940
to highlight and what portions of the

00:19:02,020 --> 00:19:06,580
document to return because because I

00:19:03,940 --> 00:19:07,809
skipped by but elasticsearch can filter

00:19:06,580 --> 00:19:09,760
the source documents so if you have a

00:19:07,809 --> 00:19:12,429
giant page if you have a megabyte of

00:19:09,760 --> 00:19:14,980
source document you probably don't want

00:19:12,429 --> 00:19:16,840
you know the huge megabyte of text to

00:19:14,980 --> 00:19:19,570
come back you only want the ID and the

00:19:16,840 --> 00:19:21,220
tiger whatever and then what you can do

00:19:19,570 --> 00:19:22,960
is highlight the megabyte of text so

00:19:21,220 --> 00:19:24,309
find the hits that you have and you only

00:19:22,960 --> 00:19:26,440
present the user with the interesting

00:19:24,309 --> 00:19:28,809
things right so this is all stuff that

00:19:26,440 --> 00:19:29,980
the results type configures and

00:19:28,809 --> 00:19:31,390
sometimes if you're fine two-headed you

00:19:29,980 --> 00:19:33,010
type you don't want to go in highlight

00:19:31,390 --> 00:19:36,670
that takes time right so you just want

00:19:33,010 --> 00:19:39,760
to spit out the title right so that's

00:19:36,670 --> 00:19:42,270
pluggable there we also have it so going

00:19:39,760 --> 00:19:44,920
left to this index settings updater

00:19:42,270 --> 00:19:49,150
that's green but impossible to read

00:19:44,920 --> 00:19:51,640
green it is a page research for me yeah

00:19:49,150 --> 00:19:53,470
and I'm pretty firmly in the camp that

00:19:51,640 --> 00:19:56,440
this should be a script that you run me

00:19:53,470 --> 00:19:58,690
and you should be able to watch it log

00:19:56,440 --> 00:20:01,210
it watch it do its thing it's it

00:19:58,690 --> 00:20:02,860
shouldn't be some sort of thing that

00:20:01,210 --> 00:20:03,970
happens when you deploy and just happen

00:20:02,860 --> 00:20:05,409
on everything because you want to be

00:20:03,970 --> 00:20:07,730
able to save season

00:20:05,409 --> 00:20:10,429
so this is by the way the thing that

00:20:07,730 --> 00:20:12,409
changes the mapping maybe so you know in

00:20:10,429 --> 00:20:14,539
my case it builds that extra index and

00:20:12,409 --> 00:20:15,799
then does the sucked out of the old one

00:20:14,539 --> 00:20:19,210
I push into the new one and then the

00:20:15,799 --> 00:20:22,490
swap so that's all a page from Sir right

00:20:19,210 --> 00:20:24,679
going left again there's the real time

00:20:22,490 --> 00:20:26,450
update or component technically the

00:20:24,679 --> 00:20:31,340
little happy face talk to the real time

00:20:26,450 --> 00:20:32,809
update or two arrows missing sorry so I

00:20:31,340 --> 00:20:35,750
try to notice all the document changes

00:20:32,809 --> 00:20:39,590
thinks of page moves page renames which

00:20:35,750 --> 00:20:41,450
are different things and you know page

00:20:39,590 --> 00:20:43,760
changes changes to the templates that

00:20:41,450 --> 00:20:47,390
are included in pages deletions all that

00:20:43,760 --> 00:20:49,070
stuff right so this relatively large

00:20:47,390 --> 00:20:51,020
amount of things that I have to try to

00:20:49,070 --> 00:20:53,779
notice in my system that real-time

00:20:51,020 --> 00:20:56,330
updater always always always pushes the

00:20:53,779 --> 00:20:58,820
the update into the job queue they're

00:20:56,330 --> 00:21:01,820
going left again there's a bulk indexer

00:20:58,820 --> 00:21:03,950
the bulk indexer uses virtually the same

00:21:01,820 --> 00:21:04,909
cost as the real time updater it can

00:21:03,950 --> 00:21:10,429
either push them in the job to your

00:21:04,909 --> 00:21:12,679
executed in process we use the job queue

00:21:10,429 --> 00:21:15,620
almost exclusively but in test and

00:21:12,679 --> 00:21:17,029
development and I suppose any other

00:21:15,620 --> 00:21:18,350
users or sierras probably wouldn't use

00:21:17,029 --> 00:21:21,110
because they don't have as big of a job

00:21:18,350 --> 00:21:23,750
shoes that foundation does um the

00:21:21,110 --> 00:21:27,710
updater dude over here above the job

00:21:23,750 --> 00:21:30,350
queues database see dis key circle the

00:21:27,710 --> 00:21:32,210
updater guy he knows how to send

00:21:30,350 --> 00:21:34,850
documents to elasticsearch send deletes

00:21:32,210 --> 00:21:37,100
all that stuff and he dealt gates over

00:21:34,850 --> 00:21:41,240
to other classes to actually build the

00:21:37,100 --> 00:21:42,830
documents it's it's too much code to

00:21:41,240 --> 00:21:45,110
find out how to build the documents

00:21:42,830 --> 00:21:47,029
correctly as well as communicate to

00:21:45,110 --> 00:21:49,520
elasticsearch it's just too too much all

00:21:47,029 --> 00:21:51,350
at once so and all often you end up with

00:21:49,520 --> 00:21:53,990
documents that vary slightly depending

00:21:51,350 --> 00:21:56,149
on their contents and you want different

00:21:53,990 --> 00:22:00,309
fields or different whatever right and

00:21:56,149 --> 00:22:00,309
so you want to be able to plug that in

00:22:00,549 --> 00:22:06,370
so

00:22:03,100 --> 00:22:06,370
does that make sense

00:22:09,389 --> 00:22:16,559
no one said no so I'm going to go with

00:22:11,999 --> 00:22:18,479
yes so exactly what I thought I've run

00:22:16,559 --> 00:22:22,349
through everything I wanted to say in 35

00:22:18,479 --> 00:22:27,479
minutes and now I will hopefully answer

00:22:22,349 --> 00:22:29,549
questions for the next 25 here are some

00:22:27,479 --> 00:22:33,719
examples wonderful insightful questions

00:22:29,549 --> 00:22:36,440
you can ask me you can't think of any so

00:22:33,719 --> 00:22:36,440
please go ahead

00:22:38,390 --> 00:22:48,080
yes hello hello are you aware of the

00:22:44,980 --> 00:22:49,310
call me maybe blog posts I saw the call

00:22:48,080 --> 00:22:52,040
me maybe blog post last night it was

00:22:49,310 --> 00:22:53,360
really I'm hard to read I'm trying to

00:22:52,040 --> 00:22:54,680
speed with you right now as I hadn't

00:22:53,360 --> 00:22:57,140
caught up but I get the sense that the

00:22:54,680 --> 00:23:00,080
he's pointing out some potential issues

00:22:57,140 --> 00:23:02,000
with a network failures is have you had

00:23:00,080 --> 00:23:04,430
any issues with network failures and how

00:23:02,000 --> 00:23:05,660
you deal with them no okay I've

00:23:04,430 --> 00:23:08,390
literally had no issues with network

00:23:05,660 --> 00:23:11,150
failures in my production environment we

00:23:08,390 --> 00:23:12,740
have a we don't like we we don't use

00:23:11,150 --> 00:23:16,460
virtual machines right we're entirely

00:23:12,740 --> 00:23:19,550
physical our network is hardware so the

00:23:16,460 --> 00:23:23,720
call me maybe post is something some guy

00:23:19,550 --> 00:23:25,880
posted a couple of days ago yeah um and

00:23:23,720 --> 00:23:27,800
it's really really hard to read and that

00:23:25,880 --> 00:23:30,590
there are dancing shifts and off to the

00:23:27,800 --> 00:23:33,710
side of Barbies and stuff but his point

00:23:30,590 --> 00:23:38,000
is that elasticsearch does not do a

00:23:33,710 --> 00:23:39,350
great job of quorum management and it

00:23:38,000 --> 00:23:44,420
doesn't handle network partitions

00:23:39,350 --> 00:23:46,940
particularly well guilty yeah I mean it

00:23:44,420 --> 00:23:49,280
doesn't it does not do like for example

00:23:46,940 --> 00:23:52,100
if you have two shards a quorum of two

00:23:49,280 --> 00:23:56,920
is actually one in the current code and

00:23:52,100 --> 00:23:56,920
that's silly but may be useful

00:23:57,100 --> 00:24:02,540
realistically like the takeaway from

00:24:00,260 --> 00:24:05,600
from that if from the call me maybe blog

00:24:02,540 --> 00:24:07,760
post and again i steamed it last night

00:24:05,600 --> 00:24:09,650
and I was up late and tired and right

00:24:07,760 --> 00:24:12,050
implementation so maybe I lost a lot of

00:24:09,650 --> 00:24:16,480
it but the takeaway is if there is a

00:24:12,050 --> 00:24:16,480
network failure you will lose data and

00:24:16,570 --> 00:24:21,880
you really should be able to regenerate

00:24:19,250 --> 00:24:25,130
that data if you use the system right

00:24:21,880 --> 00:24:27,910
elasticsearch is not a Thor ative data

00:24:25,130 --> 00:24:31,160
source it is not a relational database

00:24:27,910 --> 00:24:35,840
yeah they do f sync your rights and they

00:24:31,160 --> 00:24:38,420
do have warm but at least with what he's

00:24:35,840 --> 00:24:43,820
posted it looks like I wouldn't trust it

00:24:38,420 --> 00:24:45,400
for that and so to be fair to the

00:24:43,820 --> 00:24:48,370
elastic search folks and

00:24:45,400 --> 00:24:49,960
as it as a contributor I kind of want to

00:24:48,370 --> 00:24:52,960
defend it a little bit I don't work on

00:24:49,960 --> 00:24:55,990
that section but whatever there are two

00:24:52,960 --> 00:24:57,550
like they well two points elasticsearch

00:24:55,990 --> 00:25:00,190
is actually one of the best tested

00:24:57,550 --> 00:25:01,840
applications I've ever seen leucine

00:25:00,190 --> 00:25:03,670
maybe leucine I think it's slightly

00:25:01,840 --> 00:25:05,680
better tested but its scope is a lot

00:25:03,670 --> 00:25:08,950
smaller it's a job a library not a Java

00:25:05,680 --> 00:25:10,360
system like that does all this stuff so

00:25:08,950 --> 00:25:14,920
the scope of elasticsearch sort of

00:25:10,360 --> 00:25:16,990
encompasses it in a way and we've seen

00:25:14,920 --> 00:25:18,460
came up with some great testing trips

00:25:16,990 --> 00:25:19,660
right they use randomized testing

00:25:18,460 --> 00:25:22,990
they're the ones that find all these

00:25:19,660 --> 00:25:25,210
bugs in the JDM an elastic search uses

00:25:22,990 --> 00:25:27,940
those and it's very elastic search is

00:25:25,210 --> 00:25:29,290
very integration testy so if you want to

00:25:27,940 --> 00:25:31,570
test something they typically spin up

00:25:29,290 --> 00:25:33,100
three nodes and then want queries at it

00:25:31,570 --> 00:25:36,250
sometimes it's frustrating because it's

00:25:33,100 --> 00:25:38,500
a little slow to run the tests but you

00:25:36,250 --> 00:25:41,410
really do get a good sort of sense of

00:25:38,500 --> 00:25:43,840
the system right and they have haven't

00:25:41,410 --> 00:25:48,460
have been for months working on

00:25:43,840 --> 00:25:50,400
improving then the the the fault system

00:25:48,460 --> 00:25:53,170
that handles that quorum and handles

00:25:50,400 --> 00:25:55,750
communicating that data so they've been

00:25:53,170 --> 00:25:57,760
working they've been working on this you

00:25:55,750 --> 00:25:58,840
know they have things in this branch

00:25:57,760 --> 00:26:01,600
that they're working on it they have a

00:25:58,840 --> 00:26:04,780
test that simulates catastrophic network

00:26:01,600 --> 00:26:05,830
failures and things like that I'm

00:26:04,780 --> 00:26:08,260
frankly I don't know where they are on

00:26:05,830 --> 00:26:10,870
that I haven't asked we haven't seen it

00:26:08,260 --> 00:26:15,160
there are two elastic search plugins

00:26:10,870 --> 00:26:20,260
that offer three that offer that offer a

00:26:15,160 --> 00:26:22,690
different cluster state management

00:26:20,260 --> 00:26:26,680
systems or rather cluster state

00:26:22,690 --> 00:26:29,380
management communications and quorum

00:26:26,680 --> 00:26:31,360
reaching systems the clusters so you can

00:26:29,380 --> 00:26:33,160
actually the cluster say itself is a big

00:26:31,360 --> 00:26:35,760
immutable Java object that's sort of

00:26:33,160 --> 00:26:38,680
serializing throwing across the wire

00:26:35,760 --> 00:26:41,650
there there that it's plausible right

00:26:38,680 --> 00:26:44,110
how the throw across the wire and

00:26:41,650 --> 00:26:46,300
determined that that that that new

00:26:44,110 --> 00:26:49,360
cluster state is valid pneus is a

00:26:46,300 --> 00:26:52,330
pluggable thing so there's a version of

00:26:49,360 --> 00:26:53,470
it that works with Amazon I don't

00:26:52,330 --> 00:26:55,810
remember whether that's still a plugin

00:26:53,470 --> 00:26:57,070
or whether that's filton now there's the

00:26:55,810 --> 00:26:59,889
one that's built in San which

00:26:57,070 --> 00:27:01,720
uses our IP multicast a unicast to

00:26:59,889 --> 00:27:05,259
discover friends and then they shout at

00:27:01,720 --> 00:27:07,389
each other on port 9300 though were

00:27:05,259 --> 00:27:10,120
there abouts there's another one that

00:27:07,389 --> 00:27:12,429
uses zookeeper which is very strong for

00:27:10,120 --> 00:27:16,570
quorum and there's another one that uses

00:27:12,429 --> 00:27:18,549
a scale a quorum maintenance system that

00:27:16,570 --> 00:27:20,649
a guy's been using and he actually

00:27:18,549 --> 00:27:22,299
commented on the call me maybe blog post

00:27:20,649 --> 00:27:26,860
and said I don't see these problems with

00:27:22,299 --> 00:27:27,700
my with my farm maintance thing now keep

00:27:26,860 --> 00:27:28,929
in mind they're they're actually two

00:27:27,700 --> 00:27:30,399
kinds of corners that you have to reach

00:27:28,929 --> 00:27:33,399
an elastic search is kind of kind of

00:27:30,399 --> 00:27:37,360
weird there's cluster state forum and

00:27:33,399 --> 00:27:41,919
that's things like what shard is on what

00:27:37,360 --> 00:27:44,740
machine and which of the replicas of

00:27:41,919 --> 00:27:46,899
that shard is the master for that shot

00:27:44,740 --> 00:27:48,580
and then there are then there's actual

00:27:46,899 --> 00:27:51,669
shard quorum which is like when you

00:27:48,580 --> 00:27:53,169
write a document to the index if you've

00:27:51,669 --> 00:27:57,759
got rights can figure for quorum then it

00:27:53,169 --> 00:28:00,759
has to hit a number of replicas over 2

00:27:57,759 --> 00:28:04,960
plus 1 right or number of replicas

00:28:00,759 --> 00:28:06,460
roundup knows except as I said when you

00:28:04,960 --> 00:28:07,840
have to apparently it's one and

00:28:06,460 --> 00:28:09,820
someone's been complaining about that

00:28:07,840 --> 00:28:14,950
and frankly that is a little weird to me

00:28:09,820 --> 00:28:17,139
but hey we use we keep two replicas and

00:28:14,950 --> 00:28:19,809
so that means three total copies of the

00:28:17,139 --> 00:28:22,480
data so we don't we don't at least see

00:28:19,809 --> 00:28:27,669
that problem but yeah they call me maybe

00:28:22,480 --> 00:28:31,149
blog post is read that man if only you'd

00:28:27,669 --> 00:28:34,269
spent that much time writing a usable

00:28:31,149 --> 00:28:37,480
test case as opposed to this other

00:28:34,269 --> 00:28:39,669
sandwich right if if you had written a

00:28:37,480 --> 00:28:42,580
usable reproducible test case or maybe

00:28:39,669 --> 00:28:44,830
he has I don't know because it looks

00:28:42,580 --> 00:28:46,029
relatively reproducible then you know

00:28:44,830 --> 00:28:50,350
it's something that people can work on

00:28:46,029 --> 00:28:52,360
right and it yeah but that's where I am

00:28:50,350 --> 00:28:55,659
on that and we haven't even had any

00:28:52,360 --> 00:28:59,080
problems with it but and we know that

00:28:55,659 --> 00:29:02,250
it's possible right and we have we have

00:28:59,080 --> 00:29:02,250
system like oh

00:29:03,560 --> 00:29:09,750
sita bulk indexer his he has settings so

00:29:07,770 --> 00:29:11,100
he can index the whole wiki he can index

00:29:09,750 --> 00:29:13,230
pages that have changed since a certain

00:29:11,100 --> 00:29:15,240
day indexes are pages that have deleted

00:29:13,230 --> 00:29:16,320
since a certain date he's got all this

00:29:15,240 --> 00:29:18,060
stuff and that was the first thing I

00:29:16,320 --> 00:29:19,290
built when I when I started working on

00:29:18,060 --> 00:29:21,680
the bulk and director which was actually

00:29:19,290 --> 00:29:24,210
the first thing I built in the project

00:29:21,680 --> 00:29:25,970
which probably is what you should do too

00:29:24,210 --> 00:29:27,780
if you start using lassie search um

00:29:25,970 --> 00:29:30,480
because you want to get that data in

00:29:27,780 --> 00:29:34,560
there to query um and you can query

00:29:30,480 --> 00:29:35,550
using like just curl anyway um that was

00:29:34,560 --> 00:29:40,610
one of the first things I built because

00:29:35,550 --> 00:29:43,290
I figured I would make some mistake and

00:29:40,610 --> 00:29:47,040
screw up the index and it would be would

00:29:43,290 --> 00:29:48,450
go in some unrideable state and I mean I

00:29:47,040 --> 00:29:50,400
did at some point I had configured

00:29:48,450 --> 00:29:51,600
elasticsearch two halves or replicas and

00:29:50,400 --> 00:29:53,340
then I shut down a machine without

00:29:51,600 --> 00:29:57,390
moving all the shards off a bit

00:29:53,340 --> 00:29:58,650
oh god we lost everything like we lost

00:29:57,390 --> 00:30:01,830
everything that was on that and that

00:29:58,650 --> 00:30:03,720
note in fact I was repartitioning that

00:30:01,830 --> 00:30:05,580
node right so we deleted everything on

00:30:03,720 --> 00:30:08,040
it we didn't even restart the machine he

00:30:05,580 --> 00:30:11,670
nuked it before I realize the problem so

00:30:08,040 --> 00:30:12,900
I mean I guess let that be a lesson to

00:30:11,670 --> 00:30:18,860
you make sure that you actually have

00:30:12,900 --> 00:30:18,860
replicas because I didn't once once

00:30:19,310 --> 00:30:26,829
never I have replicas two replicas all

00:30:23,280 --> 00:30:31,309
the time now three total pockets

00:30:26,829 --> 00:30:32,959
any other questions do I see code do you

00:30:31,309 --> 00:30:37,209
want to ask me one of these questions

00:30:32,959 --> 00:30:44,539
that I so insightfully put on there

00:30:37,209 --> 00:30:47,599
because I expected no a short so I got

00:30:44,539 --> 00:30:49,819
our pink question so what one of the

00:30:47,599 --> 00:30:52,369
issues that I've seen with are you fine

00:30:49,819 --> 00:30:56,389
elasticsearch is running out of I love

00:30:52,369 --> 00:30:59,239
stickers so tell me anything about

00:30:56,389 --> 00:31:01,799
tuning are there ways to love it and

00:30:59,239 --> 00:31:03,509
make it take longer

00:31:01,799 --> 00:31:06,929
you have accessed through a palace

00:31:03,509 --> 00:31:11,759
burger or that just not people it is

00:31:06,929 --> 00:31:15,239
tunable uh but of course oh sorry repeat

00:31:11,759 --> 00:31:17,549
this I see I promise I even said it so

00:31:15,239 --> 00:31:18,779
the question is elasticsearch can has

00:31:17,549 --> 00:31:21,809
problem trouble with running out of file

00:31:18,779 --> 00:31:23,100
descriptors he's seen it happen I've

00:31:21,809 --> 00:31:24,330
seen people complain about it on the

00:31:23,100 --> 00:31:27,779
Internet I've never seen it happen

00:31:24,330 --> 00:31:29,460
personally I am reasonably sure the

00:31:27,779 --> 00:31:32,369
reason I've never seen it personally is

00:31:29,460 --> 00:31:34,109
that i use the dev insulation for the

00:31:32,369 --> 00:31:37,499
debian package for elasticsearch and

00:31:34,109 --> 00:31:39,299
that comes with the appropriate raise

00:31:37,499 --> 00:31:43,710
the file descriptors to some egregious

00:31:39,299 --> 00:31:48,899
level setting in you know etsy sis

00:31:43,710 --> 00:31:50,220
whatever's and honestly that's the

00:31:48,899 --> 00:31:51,509
easiest way to handle it this is just

00:31:50,220 --> 00:31:52,679
raise raise the number of file

00:31:51,509 --> 00:31:54,690
descriptors to an egregious level

00:31:52,679 --> 00:31:57,450
because that's leucine likes file

00:31:54,690 --> 00:31:59,879
descriptors and elasticsearch sort of

00:31:57,450 --> 00:32:02,759
compounds that by having by being multi

00:31:59,879 --> 00:32:05,850
tenants and multi shard and so each of

00:32:02,759 --> 00:32:07,590
each one of those shards is in fact a

00:32:05,850 --> 00:32:09,330
leucine index from Lucien's perspective

00:32:07,590 --> 00:32:13,230
and each one of those likes to have lots

00:32:09,330 --> 00:32:16,950
of files and so each each leucine index

00:32:13,230 --> 00:32:19,789
is often made up of you know 10 15 20 30

00:32:16,950 --> 00:32:22,739
segments and each of those segments is

00:32:19,789 --> 00:32:24,029
568 files sometimes sometimes they're

00:32:22,739 --> 00:32:25,799
one file if they want to save file

00:32:24,029 --> 00:32:26,970
descriptors so there's a there's a tweak

00:32:25,799 --> 00:32:28,710
that you can do that says hey

00:32:26,970 --> 00:32:30,629
elasticsearch the segment's really

00:32:28,710 --> 00:32:33,239
should be one file rather than eight

00:32:30,629 --> 00:32:35,309
files and that'll save you about an

00:32:33,239 --> 00:32:37,980
order of magnitude on file descriptors

00:32:35,309 --> 00:32:40,019
and it's called compound index format

00:32:37,980 --> 00:32:43,649
that's the thing to google or to search

00:32:40,019 --> 00:32:45,659
on their site just raise a number files

00:32:43,649 --> 00:32:50,610
it's slower to use the compound index

00:32:45,659 --> 00:32:54,630
format that's

00:32:50,610 --> 00:32:57,559
next solar brushes elasticsearch good

00:32:54,630 --> 00:33:01,670
job thank you did I have that up there

00:32:57,559 --> 00:33:04,260
what I did whatever there it is um so I

00:33:01,670 --> 00:33:09,780
had actually using we've seen directly

00:33:04,260 --> 00:33:11,460
um so solar is a very very is a project

00:33:09,780 --> 00:33:13,350
that's very very close to a patch in the

00:33:11,460 --> 00:33:15,720
scene when you check out apache Lucene

00:33:13,350 --> 00:33:18,990
which is the upstream of elasticsearch

00:33:15,720 --> 00:33:20,610
apache Lucene actually implements half

00:33:18,990 --> 00:33:22,190
those things three-quarters of the

00:33:20,610 --> 00:33:24,179
things that i put on the first slot and

00:33:22,190 --> 00:33:26,850
less of the things on the second slide

00:33:24,179 --> 00:33:28,559
that I skipping really bad but we've

00:33:26,850 --> 00:33:32,460
seen as a Java library that does this

00:33:28,559 --> 00:33:34,559
full-text indexing stuff and so solar

00:33:32,460 --> 00:33:38,070
actually lives in the same source tree

00:33:34,559 --> 00:33:39,270
as we've seen I mean ESPN check out boom

00:33:38,070 --> 00:33:40,799
they're so low right there and you

00:33:39,270 --> 00:33:46,650
compile them at the same time if you

00:33:40,799 --> 00:33:49,320
want we can't great so solar is at least

00:33:46,650 --> 00:33:51,059
when I when I was playing with it nine

00:33:49,320 --> 00:33:54,480
months ago and I don't know exactly if

00:33:51,059 --> 00:33:56,669
it's changed a lot Solar is is more

00:33:54,480 --> 00:33:58,500
based on like when you can figure that

00:33:56,669 --> 00:33:59,940
mapping and that analysis stuff that you

00:33:58,500 --> 00:34:02,549
do with elasticsearch so the way the

00:33:59,940 --> 00:34:05,190
fields are laid out and the way the

00:34:02,549 --> 00:34:07,020
fields are split into words that's

00:34:05,190 --> 00:34:09,119
configured by dumping an xml file on the

00:34:07,020 --> 00:34:13,590
hard disk and solar and that's

00:34:09,119 --> 00:34:19,260
significantly more painful from my

00:34:13,590 --> 00:34:21,419
perspective to work with so like that

00:34:19,260 --> 00:34:24,300
right there was sort of like one nail in

00:34:21,419 --> 00:34:26,100
the coffin for me for solar interesting

00:34:24,300 --> 00:34:27,990
is solid very good it's very fancy has

00:34:26,100 --> 00:34:29,730
lots of nice things about it and in many

00:34:27,990 --> 00:34:31,820
cases they sort of take ideas from one

00:34:29,730 --> 00:34:34,409
another you know things like

00:34:31,820 --> 00:34:35,940
elasticsearch has a restore hadrosaurs

00:34:34,409 --> 00:34:40,500
and that flowed back into leucine which

00:34:35,940 --> 00:34:41,909
flowed back into solar give things like

00:34:40,500 --> 00:34:45,750
that elasticsearch comes with deb

00:34:41,909 --> 00:34:50,250
packages and RPM packages and a nice

00:34:45,750 --> 00:34:53,190
slice windows installer there is so it's

00:34:50,250 --> 00:34:54,140
a little I think the sort of assisted

00:34:53,190 --> 00:34:56,090
mint sauce

00:34:54,140 --> 00:34:58,580
was a little better for it the other

00:34:56,090 --> 00:35:02,030
thing is that citizen men folks really

00:34:58,580 --> 00:35:07,490
like long / gabbana which are log

00:35:02,030 --> 00:35:10,610
viewers they're a lot like splunk and so

00:35:07,490 --> 00:35:12,500
I actually had I actually started the

00:35:10,610 --> 00:35:16,190
project using solar cloud his wife's

00:35:12,500 --> 00:35:18,290
it's a cloud solar cloud has similar

00:35:16,190 --> 00:35:20,120
capabilities to elasticsearch weekend so

00:35:18,290 --> 00:35:22,790
if I was just like a solar future that

00:35:20,120 --> 00:35:24,140
is in the newer version of solar and I

00:35:22,790 --> 00:35:25,370
switched to elasticsearch if just sort

00:35:24,140 --> 00:35:27,110
of working with it and seeing the pote

00:35:25,370 --> 00:35:31,670
like the posts to update the settings

00:35:27,110 --> 00:35:33,230
and well actually after having after

00:35:31,670 --> 00:35:34,280
submitting a patch to elasticsearch and

00:35:33,230 --> 00:35:35,960
the fact that they jumped on it really

00:35:34,280 --> 00:35:39,680
like they work with me when that was

00:35:35,960 --> 00:35:45,440
really wonderful so you know I like that

00:35:39,680 --> 00:35:47,030
community so the other thing is that cut

00:35:45,440 --> 00:35:48,880
sort of comparing solar and elastic

00:35:47,030 --> 00:35:51,290
search versus using a leucine directly

00:35:48,880 --> 00:35:52,880
if you directly using the scene you can

00:35:51,290 --> 00:35:54,920
actually take a few shortcuts and make

00:35:52,880 --> 00:35:56,360
something faster by sort of like oh I

00:35:54,920 --> 00:35:57,950
don't need to do this thing if I found

00:35:56,360 --> 00:35:59,360
this because I'm a really you know I'm

00:35:57,950 --> 00:36:01,520
actually writing Java code to

00:35:59,360 --> 00:36:02,870
communicate with it the trick is one you

00:36:01,520 --> 00:36:05,390
have to write Java and if you don't like

00:36:02,870 --> 00:36:06,650
that well you have to write in the JVM

00:36:05,390 --> 00:36:07,940
and if you don't like any of the JVM

00:36:06,650 --> 00:36:12,170
languages and it's not going to work out

00:36:07,940 --> 00:36:13,790
for you secondly there's a lot of sort

00:36:12,170 --> 00:36:15,920
of debugging stuff that you can do with

00:36:13,790 --> 00:36:17,120
elasticsearch that's really really nice

00:36:15,920 --> 00:36:18,770
and you wouldn't be able to do if you

00:36:17,120 --> 00:36:19,910
just wrapped solo yourself or rather you

00:36:18,770 --> 00:36:22,670
have to go to a lot of effort and

00:36:19,910 --> 00:36:24,440
elastic search you can just use it like

00:36:22,670 --> 00:36:28,370
a document store like you can just get a

00:36:24,440 --> 00:36:30,560
document via its ID I just write this is

00:36:28,370 --> 00:36:32,030
really really useful for debugging like

00:36:30,560 --> 00:36:33,410
why can't why is this thing not showing

00:36:32,030 --> 00:36:35,660
up in the search result why is it being

00:36:33,410 --> 00:36:37,430
highlighted funny why is it a day right

00:36:35,660 --> 00:36:39,140
and its really nice to be able to just

00:36:37,430 --> 00:36:43,370
go get can we do that with solar as well

00:36:39,140 --> 00:36:45,560
right and so like that is that's a

00:36:43,370 --> 00:36:47,570
pretty killer difference compared to

00:36:45,560 --> 00:36:49,910
just hand rolling something with elastic

00:36:47,570 --> 00:36:51,920
search the other thing is is the ability

00:36:49,910 --> 00:36:52,930
to sort of modify the queries on the fly

00:36:51,920 --> 00:36:56,109
and buy that

00:36:52,930 --> 00:36:58,650
type them straight into like a browser

00:36:56,109 --> 00:37:01,150
plugin that communicates with it or

00:36:58,650 --> 00:37:04,210
deploy new PHP application with

00:37:01,150 --> 00:37:06,339
different queries that's a lot faster

00:37:04,210 --> 00:37:12,760
than deploying a new we've seen

00:37:06,339 --> 00:37:16,180
application so that's that I filled up

00:37:12,760 --> 00:37:18,099
49 minutes pretty good we want to be

00:37:16,180 --> 00:37:24,790
done you can be or I can ring another

00:37:18,099 --> 00:37:30,700
question yes what's the future roadmap

00:37:24,790 --> 00:37:36,040
for elasticsearch I don't know they so

00:37:30,700 --> 00:37:37,809
elasticsearch jack elasticsearch all of

00:37:36,040 --> 00:37:39,970
the murderers for license which work for

00:37:37,809 --> 00:37:44,650
the work for elasticsearch the company

00:37:39,970 --> 00:37:49,690
right so as far as I as far as i know

00:37:44,650 --> 00:37:52,599
that they're doing things like I sort of

00:37:49,690 --> 00:37:54,099
can only infer from the past right they

00:37:52,599 --> 00:37:56,559
may have a road map but I do not know

00:37:54,099 --> 00:38:00,190
what it is my relationship with them has

00:37:56,559 --> 00:38:03,309
been I want this thing i would go post a

00:38:00,190 --> 00:38:06,520
post a github issue and they will either

00:38:03,309 --> 00:38:08,730
implement it or i will implement it and

00:38:06,520 --> 00:38:10,450
they will work with me to get emerged so

00:38:08,730 --> 00:38:12,609
at least from my perspective

00:38:10,450 --> 00:38:15,220
elasticsearch as roadmap is what i want

00:38:12,609 --> 00:38:19,089
it today if I'm willing to sort of work

00:38:15,220 --> 00:38:21,609
on it'll work with them to get it in so

00:38:19,089 --> 00:38:22,990
I know that they are working on because

00:38:21,609 --> 00:38:27,430
I have to talk to them I know that they

00:38:22,990 --> 00:38:28,750
are working on assists so one of the

00:38:27,430 --> 00:38:30,700
complaints about elasticsearch is that

00:38:28,750 --> 00:38:33,130
when you restart a node it takes quite a

00:38:30,700 --> 00:38:35,130
while to recover the shard back to

00:38:33,130 --> 00:38:38,170
itself and they're working on a system

00:38:35,130 --> 00:38:42,190
that should make that significantly

00:38:38,170 --> 00:38:44,140
faster sequence IDs for updates and

00:38:42,190 --> 00:38:46,720
things like that that should help a lot

00:38:44,140 --> 00:38:50,049
and and that is actually one of my pain

00:38:46,720 --> 00:38:52,559
points and so I'm very glad they're

00:38:50,049 --> 00:38:52,559
working on that

00:38:52,600 --> 00:38:57,640
beyond that the new vertical axis search

00:38:55,180 --> 00:38:58,900
is going to shift to groovy as a

00:38:57,640 --> 00:39:00,400
scripting language because it's much

00:38:58,900 --> 00:39:04,270
better sandbox than M bail and is

00:39:00,400 --> 00:39:06,340
actually a ton faster right now I used

00:39:04,270 --> 00:39:07,840
to like I used to think of groovy a sort

00:39:06,340 --> 00:39:09,220
of a slow cousin of all of those other

00:39:07,840 --> 00:39:11,170
ones but it's gotten a little way way

00:39:09,220 --> 00:39:14,380
faster so it's the default scripting

00:39:11,170 --> 00:39:15,490
language that they're moving to but

00:39:14,380 --> 00:39:16,960
again this is sort of near certain

00:39:15,490 --> 00:39:19,090
near-term stuff like this is sort of

00:39:16,960 --> 00:39:20,800
what's coming in elasticsearch 1 dot 3

00:39:19,090 --> 00:39:22,630
which is coming at some on a date in the

00:39:20,800 --> 00:39:27,100
future a couple of months something like

00:39:22,630 --> 00:39:28,450
that right so you know they I know that

00:39:27,100 --> 00:39:30,220
they do not have things like you know

00:39:28,450 --> 00:39:33,190
mandatory monthly releases and things

00:39:30,220 --> 00:39:34,840
like that you know they release things

00:39:33,190 --> 00:39:48,640
when they're ready and when they have

00:39:34,840 --> 00:39:50,140
good enough important things in them so

00:39:48,640 --> 00:39:51,910
I know you can't show a specific

00:39:50,140 --> 00:39:54,370
information because the privacy policy

00:39:51,910 --> 00:39:55,900
but could you show us Cabana or anything

00:39:54,370 --> 00:39:57,880
about it and how it plugs saying cuz i

00:39:55,900 --> 00:39:59,800
played with it but i'd like to see a

00:39:57,880 --> 00:40:02,560
little more than just a demo package if

00:39:59,800 --> 00:40:04,930
you have that no i can't show you that

00:40:02,560 --> 00:40:07,420
because that's it made it literally like

00:40:04,930 --> 00:40:08,890
it the first view you go to it is here

00:40:07,420 --> 00:40:11,980
are all the exceptions that come up and

00:40:08,890 --> 00:40:16,090
those potentially could contain user

00:40:11,980 --> 00:40:17,170
names and IP addresses if depending on

00:40:16,090 --> 00:40:22,620
how they're written right because we're

00:40:17,170 --> 00:40:22,620
again we're not super clean about it so

00:40:22,740 --> 00:40:30,390
that is literally the thing i cannot

00:40:25,030 --> 00:40:30,390
show you I'm graph I'm sorry

00:40:32,910 --> 00:40:38,430
maybe I can show you the one in laps but

00:40:35,560 --> 00:40:42,369
I don't remember how to log into it um

00:40:38,430 --> 00:40:44,230
but and again I actually don't know Labs

00:40:42,369 --> 00:40:48,369
is said instead of a weird environment

00:40:44,230 --> 00:40:50,230
that we had so i'm not sure that i could

00:40:48,369 --> 00:40:52,270
even show you that because of the

00:40:50,230 --> 00:40:57,730
because it's it's technically an open

00:40:52,270 --> 00:41:01,829
beta environment and again um I don't

00:40:57,730 --> 00:41:05,650
think I can help I'm really sorry but I

00:41:01,829 --> 00:41:07,300
could tell you that we use it every time

00:41:05,650 --> 00:41:09,790
we deploy to check to see if we've

00:41:07,300 --> 00:41:11,920
deployed something that's broken it's

00:41:09,790 --> 00:41:13,780
updated again because if you've been

00:41:11,920 --> 00:41:18,130
near real-time stuff like it's updated

00:41:13,780 --> 00:41:20,710
every second so you know I so we push

00:41:18,130 --> 00:41:23,579
code three times three or maybe four or

00:41:20,710 --> 00:41:27,099
five times a day four days a week

00:41:23,579 --> 00:41:29,470
sometimes I push the code right we have

00:41:27,099 --> 00:41:31,599
a deploy that happens for bug fixes in

00:41:29,470 --> 00:41:33,970
in the morning San Francisco times quite

00:41:31,599 --> 00:41:38,470
early their time so I typically do it

00:41:33,970 --> 00:41:40,569
here and not I don't always do it but

00:41:38,470 --> 00:41:42,730
any case I do it enough that you know

00:41:40,569 --> 00:41:46,119
the first thing I do is open up Qabbani

00:41:42,730 --> 00:41:49,119
and look at it and check to see what the

00:41:46,119 --> 00:41:51,550
baseline is for things going wrong

00:41:49,119 --> 00:41:57,040
because there's always a little bit

00:41:51,550 --> 00:42:00,280
going wrong too great right and then I

00:41:57,040 --> 00:42:03,640
push the code and I'll know whether it

00:42:00,280 --> 00:42:05,650
got better got worse and most cases it

00:42:03,640 --> 00:42:06,609
doesn't change which is good that's

00:42:05,650 --> 00:42:10,540
exactly what you want you don't want

00:42:06,609 --> 00:42:16,560
more things going wrong so we we use it

00:42:10,540 --> 00:42:16,560
it works yeah

00:42:20,500 --> 00:42:26,020
yeah more yeah so I see that question

00:42:24,130 --> 00:42:28,150
and it's kind of making me think what

00:42:26,020 --> 00:42:30,370
which list elasticsearch API should I

00:42:28,150 --> 00:42:32,410
use so what's available because I've

00:42:30,370 --> 00:42:34,770
been feeding it manually so so there are

00:42:32,410 --> 00:42:37,360
three there are three lines to search

00:42:34,770 --> 00:42:39,160
api's and by that i mean there are three

00:42:37,360 --> 00:42:40,540
ways that you can wire protocol

00:42:39,160 --> 00:42:41,590
communicate with elastic search and

00:42:40,540 --> 00:42:43,720
that's a lie they're actually more than

00:42:41,590 --> 00:42:45,940
three but the only three of them are

00:42:43,720 --> 00:42:47,380
actually widely use and realistically

00:42:45,940 --> 00:42:48,910
only tool for them are widely used the

00:42:47,380 --> 00:42:53,350
third one is you can you can send it

00:42:48,910 --> 00:42:55,120
thrift which I've had bad experiences

00:42:53,350 --> 00:42:59,290
with drips they love stripped good for

00:42:55,120 --> 00:43:00,790
them it this is there's a face below

00:42:59,290 --> 00:43:03,130
there's a plugin for elastic search that

00:43:00,790 --> 00:43:06,070
implements thrift and this supposed to

00:43:03,130 --> 00:43:08,860
be quite low overhead but I don't see a

00:43:06,070 --> 00:43:11,500
lot of people use it you can communicate

00:43:08,860 --> 00:43:14,500
with elastic search using its native API

00:43:11,500 --> 00:43:16,210
or with JSON most of the examples are

00:43:14,500 --> 00:43:18,240
written in JSON about eighty percent of

00:43:16,210 --> 00:43:20,770
the test so it using the native API and

00:43:18,240 --> 00:43:26,530
a lot of them are written also using

00:43:20,770 --> 00:43:28,240
JSON twenty percent right and so the

00:43:26,530 --> 00:43:30,370
choice is really really easy between the

00:43:28,240 --> 00:43:32,530
two if you're not using a JVM

00:43:30,370 --> 00:43:35,320
application you're not using a JVM

00:43:32,530 --> 00:43:39,460
application you're using JSON because

00:43:35,320 --> 00:43:42,070
you can't use the native API because the

00:43:39,460 --> 00:43:43,720
native API is literally boot a small

00:43:42,070 --> 00:43:46,330
copy of elastic search inside your

00:43:43,720 --> 00:43:48,040
application and connect to an elastic

00:43:46,330 --> 00:43:49,810
search node and when you do that you

00:43:48,040 --> 00:43:51,610
sniff cluster information from it and

00:43:49,810 --> 00:43:54,550
the native API can do things like more

00:43:51,610 --> 00:43:56,280
intelligently we're out your your

00:43:54,550 --> 00:43:58,780
documents into the appropriate place

00:43:56,280 --> 00:44:00,550
like the JSON API when you submit a

00:43:58,780 --> 00:44:02,200
document that dot the server that you

00:44:00,550 --> 00:44:05,080
submitted to has to then route it to the

00:44:02,200 --> 00:44:07,900
appropriate machines right but you're

00:44:05,080 --> 00:44:10,930
the native API can snip the cluster

00:44:07,900 --> 00:44:13,690
state and it knows what the appropriate

00:44:10,930 --> 00:44:16,120
machines to route the requests to are so

00:44:13,690 --> 00:44:18,670
when you do it it's emits directly there

00:44:16,120 --> 00:44:20,860
the trouble with the native API is that

00:44:18,670 --> 00:44:24,280
it is a small version of elastic search

00:44:20,860 --> 00:44:25,330
and so you have to do things like you

00:44:24,280 --> 00:44:26,680
have to worry about wire protocol

00:44:25,330 --> 00:44:28,420
compatibility and the last the search is

00:44:26,680 --> 00:44:32,740
actually quite good about wire protocol

00:44:28,420 --> 00:44:33,640
compatibility but like for example you

00:44:32,740 --> 00:44:36,099
don't want to run different

00:44:33,640 --> 00:44:38,319
versions of the jvm you have to run the

00:44:36,099 --> 00:44:39,940
same version of jva on the client-side

00:44:38,319 --> 00:44:41,529
and server-side similarly after on the

00:44:39,940 --> 00:44:44,049
same version JVM on all the elastic

00:44:41,529 --> 00:44:45,970
search nodes and technically it's okay

00:44:44,049 --> 00:44:47,710
to do like a rolling restart to get the

00:44:45,970 --> 00:44:49,750
new versions of the JPM on there right

00:44:47,710 --> 00:44:51,339
is this how you upgraded I suppose you

00:44:49,750 --> 00:44:54,819
don't want to shoot all the nodes and

00:44:51,339 --> 00:44:57,279
then bring them all back up you do them

00:44:54,819 --> 00:44:59,559
one of the time right and a rolling

00:44:57,279 --> 00:45:02,260
restart is okay it's just that sometimes

00:44:59,559 --> 00:45:04,000
exceptions sometimes errors are not

00:45:02,260 --> 00:45:06,039
thrown between the servers correctly if

00:45:04,000 --> 00:45:13,299
you're not on the same versions jbo the

00:45:06,039 --> 00:45:17,470
other thing is that the D they take care

00:45:13,299 --> 00:45:20,769
to make the the native API compatible

00:45:17,470 --> 00:45:22,480
but if you don't want to upgrade your

00:45:20,769 --> 00:45:25,480
application whenever you upgrade

00:45:22,480 --> 00:45:28,420
elasticsearch like if you want those to

00:45:25,480 --> 00:45:31,210
be very broken like very distinct

00:45:28,420 --> 00:45:33,970
operations that you should you certainly

00:45:31,210 --> 00:45:35,619
use the JSON API if you are okay with a

00:45:33,970 --> 00:45:36,549
rolling restored of elastic search and

00:45:35,619 --> 00:45:39,400
then a rolling resource of your

00:45:36,549 --> 00:45:42,700
application then native API is great

00:45:39,400 --> 00:45:44,289
it's fact and instead of performance

00:45:42,700 --> 00:45:47,589
difference between native versus JSON

00:45:44,289 --> 00:45:49,539
yeah the native API is faster it's again

00:45:47,589 --> 00:45:50,559
there's lower overhead on the nodes that

00:45:49,539 --> 00:45:51,819
you communicate with because you always

00:45:50,559 --> 00:45:54,250
communicate to the right one you don't

00:45:51,819 --> 00:45:55,869
have to use one as a forwarder you can

00:45:54,250 --> 00:45:59,529
sort of get around that by spawning a

00:45:55,869 --> 00:46:01,119
small note that is not a data node and

00:45:59,529 --> 00:46:04,329
is not a master node or cannot be either

00:46:01,119 --> 00:46:06,130
one of them on your on your server and

00:46:04,329 --> 00:46:07,779
then you can send requests directly bit

00:46:06,130 --> 00:46:11,319
and then it will sort of act like the

00:46:07,779 --> 00:46:12,730
native API which is actually like when

00:46:11,319 --> 00:46:16,599
you use a native API you're doing just

00:46:12,730 --> 00:46:19,420
that but inside the JVM so again it's

00:46:16,599 --> 00:46:22,750
lower overhead to use the native API but

00:46:19,420 --> 00:46:24,190
I'm not sure how significant it is it

00:46:22,750 --> 00:46:27,430
would be things like lower round trip

00:46:24,190 --> 00:46:29,349
times and slightly decrease load on the

00:46:27,430 --> 00:46:32,019
elastic search servers but I don't know

00:46:29,349 --> 00:46:33,609
how slight so it's basically it's a

00:46:32,019 --> 00:46:34,990
lower low it versus a loser loser

00:46:33,609 --> 00:46:37,869
coupling between the application and the

00:46:34,990 --> 00:46:40,900
yes it's just it is an exchange of tibor

00:46:37,869 --> 00:46:43,539
coupling with for giving exchange of

00:46:40,900 --> 00:46:44,390
tighter coupling for some speed that I

00:46:43,539 --> 00:46:47,029
don't actually know

00:46:44,390 --> 00:46:48,529
much it is it could be pretty

00:46:47,029 --> 00:46:53,059
significant if you have tons and tons of

00:46:48,529 --> 00:46:55,819
data log stash I believe uses the native

00:46:53,059 --> 00:46:59,599
API but now that I say that I'm not

00:46:55,819 --> 00:47:05,590
actually sure if mo but a log stash is a

00:46:59,599 --> 00:47:09,220
java application jruby

00:47:05,590 --> 00:47:11,260
yes give it Mike I'll repeat the

00:47:09,220 --> 00:47:14,470
question or no I won't have to repeat

00:47:11,260 --> 00:47:16,680
question sorry can you talk a little bit

00:47:14,470 --> 00:47:19,990
about load balancing the json interface

00:47:16,680 --> 00:47:22,510
yeah so we actually put elasticsearch

00:47:19,990 --> 00:47:24,580
behind a load balancer because that

00:47:22,510 --> 00:47:27,010
makes it really easy for us to add new

00:47:24,580 --> 00:47:30,760
nodes to the elastic search cluster and

00:47:27,010 --> 00:47:31,990
then they'll sort of automatically the

00:47:30,760 --> 00:47:33,670
request will automatically get round

00:47:31,990 --> 00:47:36,520
robin doubt to them you're going to use

00:47:33,670 --> 00:47:38,590
the native API your application sort of

00:47:36,520 --> 00:47:43,120
load balances on its own right it knows

00:47:38,590 --> 00:47:44,980
which machines to talk to so great if

00:47:43,120 --> 00:47:47,290
you don't you if you're using the JSON

00:47:44,980 --> 00:47:49,360
interface you your application has to

00:47:47,290 --> 00:47:50,560
pick a server to talk to or your

00:47:49,360 --> 00:47:51,910
application has to talk to a load

00:47:50,560 --> 00:47:56,020
balancer that picks is over to talk to

00:47:51,910 --> 00:47:58,180
in our case right and then that server

00:47:56,020 --> 00:47:59,650
will receive your request and it forward

00:47:58,180 --> 00:48:03,010
it out to the appropriate service so if

00:47:59,650 --> 00:48:04,750
you have 25 that little on 20 servers it

00:48:03,010 --> 00:48:07,270
had four forwards your request 02

00:48:04,750 --> 00:48:09,280
servers and it pretty much for words the

00:48:07,270 --> 00:48:11,320
same request down verbatim right and

00:48:09,280 --> 00:48:17,050
then they know how to execute the thing

00:48:11,320 --> 00:48:20,380
right the search so there are some folks

00:48:17,050 --> 00:48:23,470
that use nodes like I said they run a

00:48:20,380 --> 00:48:25,450
non data non master node so a node that

00:48:23,470 --> 00:48:30,250
can't be elected a cluster master and a

00:48:25,450 --> 00:48:32,050
no that cannot that cannot hold data on

00:48:30,250 --> 00:48:33,640
its disk right you did these are just

00:48:32,050 --> 00:48:35,650
configuration things you can do and then

00:48:33,640 --> 00:48:37,690
you can forward all your requests to

00:48:35,650 --> 00:48:41,590
those nodes right and then they will do

00:48:37,690 --> 00:48:43,870
the load balancing for you if if load

00:48:41,590 --> 00:48:45,640
balancing looks like a problem and I'm

00:48:43,870 --> 00:48:49,360
actually not sure how you'd know that it

00:48:45,640 --> 00:48:51,370
is then that's something you should

00:48:49,360 --> 00:48:53,680
really look at you should look at either

00:48:51,370 --> 00:48:56,140
getting a little stable of these these

00:48:53,680 --> 00:48:58,720
things are running one directly in on

00:48:56,140 --> 00:49:00,130
the machine right so in my case I'd run

00:48:58,720 --> 00:49:01,180
it next every Apache but we're not going

00:49:00,130 --> 00:49:02,590
to do that because we've hundreds of

00:49:01,180 --> 00:49:04,150
Apaches and you don't feel like giving

00:49:02,590 --> 00:49:07,240
them two gigs of ram to run

00:49:04,150 --> 00:49:09,630
elasticsearch and again the actual ram

00:49:07,240 --> 00:49:12,160
requirements and dis requirements vary

00:49:09,630 --> 00:49:15,490
so this if you have one of these notes

00:49:12,160 --> 00:49:17,400
that's in a non data my master node then

00:49:15,490 --> 00:49:18,780
it's CP

00:49:17,400 --> 00:49:20,400
and this requirements are going to be

00:49:18,780 --> 00:49:22,020
totally different from the data notes

00:49:20,400 --> 00:49:24,000
because the data nodes are doing things

00:49:22,020 --> 00:49:25,800
like scraping that like reading the disk

00:49:24,000 --> 00:49:28,200
to get the appropriate things they're

00:49:25,800 --> 00:49:29,820
doing things like you know writing

00:49:28,200 --> 00:49:31,320
writing new index files they're merging

00:49:29,820 --> 00:49:32,940
the index files together they're doing

00:49:31,320 --> 00:49:34,290
quite a lot with their disk these these

00:49:32,940 --> 00:49:37,170
query notes wouldn't be doing anything

00:49:34,290 --> 00:49:39,750
with a disk but they would do they would

00:49:37,170 --> 00:49:41,220
combine like there is that second phase

00:49:39,750 --> 00:49:42,720
right when you send request off the 20

00:49:41,220 --> 00:49:45,510
service you have to combine the request

00:49:42,720 --> 00:49:47,400
back together and pretty much every

00:49:45,510 --> 00:49:49,650
request will asset search has this this

00:49:47,400 --> 00:49:52,170
thing where there's a combined phase and

00:49:49,650 --> 00:49:55,650
if you use a query node than it would do

00:49:52,170 --> 00:49:59,160
that they would do you're combining so

00:49:55,650 --> 00:50:02,370
that's an option I've never been able to

00:49:59,160 --> 00:50:05,130
find out I've never found out when is

00:50:02,370 --> 00:50:08,430
the time that you need that thing right

00:50:05,130 --> 00:50:11,810
a last-start has a great API where you

00:50:08,430 --> 00:50:14,610
can look at hot threads and it will do a

00:50:11,810 --> 00:50:17,580
like a sort of self inspection on the

00:50:14,610 --> 00:50:19,530
JVM and it'll find out which threads are

00:50:17,580 --> 00:50:22,320
consuming lots of resources and it'll do

00:50:19,530 --> 00:50:24,120
it'll take snapshots of them and then

00:50:22,320 --> 00:50:28,110
collapse them together instead of a

00:50:24,120 --> 00:50:30,060
useful way of seeing things and so you

00:50:28,110 --> 00:50:32,160
can tell things like wow this machine is

00:50:30,060 --> 00:50:34,380
spending a lot of time merging some

00:50:32,160 --> 00:50:37,170
things or wow this query is taking a

00:50:34,380 --> 00:50:39,750
really really long time and then you can

00:50:37,170 --> 00:50:41,460
go in and debug it it's really great for

00:50:39,750 --> 00:50:43,320
debugging things that seem to take a lot

00:50:41,460 --> 00:50:46,650
longer than you expect but it's not

00:50:43,320 --> 00:50:48,390
quite as useful for when lots of tiny

00:50:46,650 --> 00:50:49,920
things are coming in figuring out what

00:50:48,390 --> 00:50:52,200
the expensive thing is there then

00:50:49,920 --> 00:50:56,100
standard JVM profiling stuff is what you

00:50:52,200 --> 00:50:59,400
have to do but I have not seen any of

00:50:56,100 --> 00:51:03,410
the merge or the load balancing actions

00:50:59,400 --> 00:51:03,410
be high on that list in my system

00:51:05,970 --> 00:51:08,780
other questions

00:51:10,730 --> 00:51:14,869
why not that's cool too

00:51:16,620 --> 00:51:27,090
okay well I'm done then oh ha i have

00:51:23,520 --> 00:51:29,580
stuff i put it there both the foundation

00:51:27,090 --> 00:51:33,300
and elasticsearch sent me some nice up

00:51:29,580 --> 00:51:36,900
sticker easy postcards and buttons you

00:51:33,300 --> 00:51:39,360
know you want a button and the standard

00:51:36,900 --> 00:51:42,330
things the the wikimedia foundation is

00:51:39,360 --> 00:51:46,110
always hiring and elasticsearch I

00:51:42,330 --> 00:51:48,770
imagine is as well now I'm done in the

00:51:46,110 --> 00:51:48,770
class please

00:52:26,960 --> 00:52:31,230
your customers rely on your website or

00:52:29,730 --> 00:52:33,599
application if it's slower

00:52:31,230 --> 00:52:36,540
non-responsive it infuriates your users

00:52:33,599 --> 00:52:38,369
and costs you money keeping your

00:52:36,540 --> 00:52:41,850
business critical systems humming along

00:52:38,369 --> 00:52:44,190
requires insight into what they're doing

00:52:41,850 --> 00:52:46,140
your system metrics tells stories

00:52:44,190 --> 00:52:48,150
stories that can reveal performance

00:52:46,140 --> 00:52:50,490
bottlenecks resource limitations and

00:52:48,150 --> 00:52:52,050
other problems but how do you keep an

00:52:50,490 --> 00:52:54,690
eye on all of your systems performance

00:52:52,050 --> 00:52:57,750
metrics in real-time and record this

00:52:54,690 --> 00:52:59,490
data for later analysis enter longview

00:52:57,750 --> 00:53:01,500
the new way to see what's really going

00:52:59,490 --> 00:53:03,660
on under the hood the long view

00:53:01,500 --> 00:53:05,730
dashboard lets you visualize the status

00:53:03,660 --> 00:53:08,190
of all your systems providing you with a

00:53:05,730 --> 00:53:11,550
bird's-eye view of your entire fleet you

00:53:08,190 --> 00:53:14,130
can sort by cpu memory swap processes

00:53:11,550 --> 00:53:15,900
load and network usage click a specific

00:53:14,130 --> 00:53:18,300
system to access its individual

00:53:15,900 --> 00:53:20,810
dashboard then click and drag to zoom in

00:53:18,300 --> 00:53:23,220
on chokepoints and get more detail

00:53:20,810 --> 00:53:24,870
comprehensive network data including

00:53:23,220 --> 00:53:27,180
inbound and outbound traffic is

00:53:24,870 --> 00:53:28,770
available on the network tab and disk

00:53:27,180 --> 00:53:30,690
rights and free space on the disk

00:53:28,770 --> 00:53:33,510
stabbed while the process Explorer

00:53:30,690 --> 00:53:36,060
displays usage statistics for individual

00:53:33,510 --> 00:53:38,220
processes the system info tab shows

00:53:36,060 --> 00:53:40,470
listening services active connections

00:53:38,220 --> 00:53:42,600
and available updates adding long view

00:53:40,470 --> 00:53:44,310
to a system is easy just click the

00:53:42,600 --> 00:53:46,440
button copy the one line installation

00:53:44,310 --> 00:53:48,900
command then run the command on your

00:53:46,440 --> 00:53:50,580
linux system to complete the process the

00:53:48,900 --> 00:53:52,770
agent will begin collecting data and

00:53:50,580 --> 00:53:54,609
sending it to longview then the graph

00:53:52,770 --> 00:53:57,190
start rolling

00:53:54,609 --> 00:53:59,559
use longview to gain visibility into

00:53:57,190 --> 00:54:03,299
your servers so when your website or app

00:53:59,559 --> 00:54:03,299

YouTube URL: https://www.youtube.com/watch?v=Kg-zvZ_B_Hs


