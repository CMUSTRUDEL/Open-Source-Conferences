Title: 2014 SouthEast LinuxFest - C. Thomas Stover - A Case for Erlang
Publication date: 2015-05-04
Playlist: 2014 SouthEast LinuxFest
Description: 
	2014 SouthEast LinuxFest
C. Thomas Stover
A Case for Erlang
Captions: 
	00:00:00,000 --> 00:00:05,339
the following presentation was recorded

00:00:02,490 --> 00:00:08,189
the 2014 southeast linux fest in

00:00:05,339 --> 00:00:11,070
charlotte north carolina it is licensed

00:00:08,189 --> 00:00:15,150
under a creative commons license for

00:00:11,070 --> 00:00:18,330
more information visit www.fcn expense

00:00:15,150 --> 00:00:20,310
org the southeast linux fest would like

00:00:18,330 --> 00:00:22,859
to thank the following diamond sponsors

00:00:20,310 --> 00:00:25,980
in 2014 for helping make these videos

00:00:22,859 --> 00:00:29,910
possible okay so you guys are like the

00:00:25,980 --> 00:00:31,800
hardcore linux fest people so that we

00:00:29,910 --> 00:00:34,380
actually show up at the nine o'clock

00:00:31,800 --> 00:00:37,469
sunday slot so and we have another one

00:00:34,380 --> 00:00:38,670
yay so if you made it out you know god

00:00:37,469 --> 00:00:43,410
bless you thanks for coming out this

00:00:38,670 --> 00:00:45,660
morning yes so those so if I can stay

00:00:43,410 --> 00:00:50,640
awake maybe we all maybe you have a

00:00:45,660 --> 00:00:54,300
chance to okay so so Who am I briefly so

00:00:50,640 --> 00:00:57,629
I am a software engineer for this outfit

00:00:54,300 --> 00:00:59,910
called alert logic I live in houston my

00:00:57,629 --> 00:01:02,239
background is primarily in systems

00:00:59,910 --> 00:01:06,450
programming and native code with see

00:01:02,239 --> 00:01:09,990
actually went to Erlang factory this

00:01:06,450 --> 00:01:12,780
this past event they had they have their

00:01:09,990 --> 00:01:15,030
own conference and that was kind of my

00:01:12,780 --> 00:01:16,560
presentation was from the perspective of

00:01:15,030 --> 00:01:19,650
someone coming from that background to

00:01:16,560 --> 00:01:22,049
this background and it's different than

00:01:19,650 --> 00:01:26,970
two decades on it gives me a unique

00:01:22,049 --> 00:01:28,950
angle I suppose in some okay so we'll

00:01:26,970 --> 00:01:31,740
just kind of jump in here and raise your

00:01:28,950 --> 00:01:35,490
hand if you got a question so okay let's

00:01:31,740 --> 00:01:38,369
like just kind of scope erling a little

00:01:35,490 --> 00:01:41,670
bit so it does it's a virtual machine

00:01:38,369 --> 00:01:43,350
architecture but you do compile things

00:01:41,670 --> 00:01:47,399
to buy codes so at least you get the

00:01:43,350 --> 00:01:48,720
benefits of and it's better now that has

00:01:47,399 --> 00:01:52,049
been in the past with some static

00:01:48,720 --> 00:01:54,689
analysis go on the input side you do

00:01:52,049 --> 00:01:56,280
have dynamic typing which depending on

00:01:54,689 --> 00:01:59,520
how you're looking things is a pro or

00:01:56,280 --> 00:02:03,659
con it's a functional programming

00:01:59,520 --> 00:02:05,040
paradigm which is the most difficult for

00:02:03,659 --> 00:02:06,360
me your most difficult people probably

00:02:05,040 --> 00:02:09,660
not coming from that we'll talk about

00:02:06,360 --> 00:02:12,410
that you have really outstanding pattern

00:02:09,660 --> 00:02:14,190
matching facilities which is a big plus

00:02:12,410 --> 00:02:17,400
we can talk about that

00:02:14,190 --> 00:02:18,950
and the what makes this special makes it

00:02:17,400 --> 00:02:21,110
a little bit different than other

00:02:18,950 --> 00:02:24,510
functional programming environments is

00:02:21,110 --> 00:02:27,590
the unified i/o and concurrency and

00:02:24,510 --> 00:02:30,780
distribution model that it gives you and

00:02:27,590 --> 00:02:34,260
it also has interactive console like you

00:02:30,780 --> 00:02:37,980
know python or several of things and

00:02:34,260 --> 00:02:42,000
then I like to think of it as this idea

00:02:37,980 --> 00:02:45,740
of an entire simplified operating system

00:02:42,000 --> 00:02:48,510
that you can use as a library in your

00:02:45,740 --> 00:02:50,670
application so you're in result of what

00:02:48,510 --> 00:02:53,700
it is you're doing is not so much an

00:02:50,670 --> 00:02:56,070
individual program but it is a system of

00:02:53,700 --> 00:02:59,610
multiple programs that function as a

00:02:56,070 --> 00:03:03,920
whole what you do anyway but this is on

00:02:59,610 --> 00:03:06,810
a little bit different take on it so

00:03:03,920 --> 00:03:09,300
Erlang originally is from erickson this

00:03:06,810 --> 00:03:11,760
goes back to the 80s they used it in

00:03:09,300 --> 00:03:15,000
house it was a experimental proof of

00:03:11,760 --> 00:03:17,730
concept it had its own neglect finally

00:03:15,000 --> 00:03:19,140
came out open source world it's used all

00:03:17,730 --> 00:03:22,700
over the place and a lot of places as

00:03:19,140 --> 00:03:26,780
big it's got a big industrial following

00:03:22,700 --> 00:03:29,160
more in Europe and North America but it

00:03:26,780 --> 00:03:30,750
cool thing it's kind of nice to see how

00:03:29,160 --> 00:03:32,430
it's kind of an obscure when people

00:03:30,750 --> 00:03:34,290
don't notice much but it's gotten a

00:03:32,430 --> 00:03:37,700
resurgence it's kind of a renaissance

00:03:34,290 --> 00:03:40,950
but it's still very much alive and well

00:03:37,700 --> 00:03:42,870
so if you're if you take anything out of

00:03:40,950 --> 00:03:45,920
this you need to go watch this youtube

00:03:42,870 --> 00:03:48,480
video which will prematurely

00:03:45,920 --> 00:03:51,180
incapacitated with laughter unless you

00:03:48,480 --> 00:03:53,760
just don't get anything so just just a

00:03:51,180 --> 00:03:57,090
good YouTube this sometime this guy made

00:03:53,760 --> 00:04:00,570
this a kind of as a joke promotional

00:03:57,090 --> 00:04:03,450
video for for Erlang trying to make fun

00:04:00,570 --> 00:04:06,480
of how 80s it is and try to like give it

00:04:03,450 --> 00:04:08,970
a modern take and he makes fun of nodejs

00:04:06,480 --> 00:04:12,630
and Ruby know so it's just hysterical so

00:04:08,970 --> 00:04:14,250
has zero tentacle you know benefits

00:04:12,630 --> 00:04:15,540
watching that but just you just have to

00:04:14,250 --> 00:04:17,970
that should especially give you all the

00:04:15,540 --> 00:04:20,660
background information you need so like

00:04:17,970 --> 00:04:23,810
probably the two in the in

00:04:20,660 --> 00:04:25,070
open-source universe big examples that

00:04:23,810 --> 00:04:28,580
we think of that are getting a lot of

00:04:25,070 --> 00:04:30,890
attention for Erlang lately and they

00:04:28,580 --> 00:04:32,870
have outfits so it otherwise never even

00:04:30,890 --> 00:04:34,790
consider erling they're having people

00:04:32,870 --> 00:04:40,850
kind of learn it and use it for these

00:04:34,790 --> 00:04:45,800
two things rabbitmq is a generic message

00:04:40,850 --> 00:04:47,930
passing bus framework and you if you

00:04:45,800 --> 00:04:50,360
know Erlang you can give an additional

00:04:47,930 --> 00:04:54,200
level of customization with it and it's

00:04:50,360 --> 00:04:56,510
just an example of an amazing generic

00:04:54,200 --> 00:04:59,900
component that you can build with it and

00:04:56,510 --> 00:05:03,050
then rya'c is a distributed database

00:04:59,900 --> 00:05:04,700
systems no sequel front and it's one of

00:05:03,050 --> 00:05:07,220
the cool things about it it's a little

00:05:04,700 --> 00:05:10,070
bit different is the is the geographic

00:05:07,220 --> 00:05:12,470
dispersion concept so that actually will

00:05:10,070 --> 00:05:13,880
have you can have network splits and

00:05:12,470 --> 00:05:17,720
things like that so that's kind of it's

00:05:13,880 --> 00:05:21,470
in my mind it's unique attribute but

00:05:17,720 --> 00:05:22,910
that's all built with Erling on the top

00:05:21,470 --> 00:05:24,080
layer has obviously though that these

00:05:22,910 --> 00:05:26,890
things have other components for

00:05:24,080 --> 00:05:29,750
sciences so let's talk about some Neenah

00:05:26,890 --> 00:05:32,420
pros okay like so this is time-tested

00:05:29,750 --> 00:05:36,290
and by that i mean the the code base is

00:05:32,420 --> 00:05:38,960
is been tested for a long time but the

00:05:36,290 --> 00:05:42,340
the paradigms and the models that it

00:05:38,960 --> 00:05:45,260
uses have been exercised every time so a

00:05:42,340 --> 00:05:48,320
lot of idea the original ideas have been

00:05:45,260 --> 00:05:51,100
let go and many of the core ones that

00:05:48,320 --> 00:05:53,690
actually are acquitted and held on to

00:05:51,100 --> 00:05:55,190
it's just it's just a rock-solid thing

00:05:53,690 --> 00:05:57,230
has just been around for you know if you

00:05:55,190 --> 00:05:58,700
think of an example like UNIX been

00:05:57,230 --> 00:06:01,280
around for a long time we even though

00:05:58,700 --> 00:06:04,790
it's different we get the ideas we get

00:06:01,280 --> 00:06:06,980
to the concepts they work very good you

00:06:04,790 --> 00:06:10,630
can do rapid so it's a great great way

00:06:06,980 --> 00:06:14,660
to to explore ideas prototype things

00:06:10,630 --> 00:06:17,440
make production systems quickly it's a

00:06:14,660 --> 00:06:22,250
high-level tool but a very powerful one

00:06:17,440 --> 00:06:23,690
in compared to many things and depending

00:06:22,250 --> 00:06:26,330
on what you're talking about that

00:06:23,690 --> 00:06:28,610
performance is outstanding one of the

00:06:26,330 --> 00:06:30,229
reasons to use it is excellent

00:06:28,610 --> 00:06:35,000
performance characteristics especially

00:06:30,229 --> 00:06:36,710
with parallel ISM if you watch the video

00:06:35,000 --> 00:06:40,250
get the joke about get the girls get the

00:06:36,710 --> 00:06:44,750
boys it's also very different i put that

00:06:40,250 --> 00:06:46,430
as a pro because it actually was here it

00:06:44,750 --> 00:06:50,030
was at the southeast linux fest in

00:06:46,430 --> 00:06:52,750
spartanburg couple there was a great

00:06:50,030 --> 00:06:55,880
presentation the guy was talking about

00:06:52,750 --> 00:06:57,770
don't stagnate you know the if you work

00:06:55,880 --> 00:06:59,750
on the same thing for you know ten years

00:06:57,770 --> 00:07:02,570
or longer you know you get it you get

00:06:59,750 --> 00:07:04,400
really good at that but it also limits

00:07:02,570 --> 00:07:06,140
you and inhibits you from from other

00:07:04,400 --> 00:07:08,540
growth that you otherwise when I haven't

00:07:06,140 --> 00:07:10,580
so try things that are different explore

00:07:08,540 --> 00:07:13,370
them play with them and it even if you

00:07:10,580 --> 00:07:16,460
don't fully go on board or fully use

00:07:13,370 --> 00:07:17,750
them it will help you to expand your

00:07:16,460 --> 00:07:20,090
mind expand the way you look at things

00:07:17,750 --> 00:07:21,800
and in the tools that you normally use

00:07:20,090 --> 00:07:22,880
and you think that you understand very

00:07:21,800 --> 00:07:24,470
well you look at them with a new

00:07:22,880 --> 00:07:26,810
perspective so it's very good and

00:07:24,470 --> 00:07:30,560
portability so that's less of a concern

00:07:26,810 --> 00:07:35,540
now but it is possible to run this on a

00:07:30,560 --> 00:07:40,070
variety of operating systems and and

00:07:35,540 --> 00:07:43,460
architectures so it was the historical

00:07:40,070 --> 00:07:45,320
that made more big deal on the cons I

00:07:43,460 --> 00:07:48,710
put some of the same exact ones you know

00:07:45,320 --> 00:07:50,479
the portability is is a negative in the

00:07:48,710 --> 00:07:53,840
sense that there are some things that

00:07:50,479 --> 00:07:56,479
could be done in a more linux way but

00:07:53,840 --> 00:07:58,760
that abstracting the sorts of things

00:07:56,479 --> 00:08:02,030
like threading models console i/o stuff

00:07:58,760 --> 00:08:04,580
like that but still it's cool and the

00:08:02,030 --> 00:08:07,940
very different is also a problem in the

00:08:04,580 --> 00:08:10,419
sense that it's it's just different it's

00:08:07,940 --> 00:08:12,320
weird you know it leaves for me

00:08:10,419 --> 00:08:14,510
obviously there are performance

00:08:12,320 --> 00:08:17,060
downsides both to a virtual machine and

00:08:14,510 --> 00:08:19,310
to functional programming in general

00:08:17,060 --> 00:08:23,419
don't kill me if you're big long story

00:08:19,310 --> 00:08:25,850
and the syntax is is bad but II have an

00:08:23,419 --> 00:08:28,729
example there you can terminate a line

00:08:25,850 --> 00:08:31,729
for different ways you can terminate it

00:08:28,729 --> 00:08:33,950
with space with a period with a comma or

00:08:31,729 --> 00:08:36,080
semicolon and you have to use the right

00:08:33,950 --> 00:08:37,099
one depending on the context so they're

00:08:36,080 --> 00:08:38,270
like if you go in there and say I want

00:08:37,099 --> 00:08:40,159
to tweak this a little bit let me just

00:08:38,270 --> 00:08:42,289
insert a line or take it you're gonna

00:08:40,159 --> 00:08:44,240
sort of the line above it the line you

00:08:42,289 --> 00:08:46,040
just added and the one that below it now

00:08:44,240 --> 00:08:49,100
probably has to have

00:08:46,040 --> 00:08:52,550
all the determination change just things

00:08:49,100 --> 00:08:56,269
like that okay so like I said so in the

00:08:52,550 --> 00:08:57,470
original use case was with Erickson and

00:08:56,269 --> 00:09:00,199
they were making you know telecom

00:08:57,470 --> 00:09:04,870
switches which is a heavily I owe

00:09:00,199 --> 00:09:07,339
intensive environment and so one of the

00:09:04,870 --> 00:09:10,310
whole reasons to use Erlang and consider

00:09:07,339 --> 00:09:12,259
it is for iof locations so I it's worth

00:09:10,310 --> 00:09:14,630
taking a step back and taking a little

00:09:12,259 --> 00:09:18,560
bit of an overview of what we mean by I

00:09:14,630 --> 00:09:20,389
oh we won't harp on this forever but

00:09:18,560 --> 00:09:22,639
just to consider for a second at the

00:09:20,389 --> 00:09:27,050
lowest level away things mostly work now

00:09:22,639 --> 00:09:30,350
is you have your core cpu with your

00:09:27,050 --> 00:09:33,709
registers and stuff and then any at this

00:09:30,350 --> 00:09:37,569
level i 0 means anything going in and

00:09:33,709 --> 00:09:39,829
out of that core so anytime you writing

00:09:37,569 --> 00:09:42,170
instructions to fetch things out of RAM

00:09:39,829 --> 00:09:45,709
set things in RAM that's an i/o

00:09:42,170 --> 00:09:47,769
operation and all rely on other which

00:09:45,709 --> 00:09:51,350
device oo is actually just mapped into

00:09:47,769 --> 00:09:53,180
memory address regions so it's you have

00:09:51,350 --> 00:09:54,829
this abstraction to we're at a certain

00:09:53,180 --> 00:09:57,880
level all you're ever doing is just

00:09:54,829 --> 00:10:00,740
fetching and setting doing assignments

00:09:57,880 --> 00:10:02,779
from memory addresses and then the other

00:10:00,740 --> 00:10:06,019
big component of that is you have an

00:10:02,779 --> 00:10:08,060
interrupt model which is obviously how

00:10:06,019 --> 00:10:10,100
you tell it when it is that you need to

00:10:08,060 --> 00:10:14,209
handle the different external stimulus

00:10:10,100 --> 00:10:18,339
and internal stimulus okay so what that

00:10:14,209 --> 00:10:20,360
gives you is that gives you a means to

00:10:18,339 --> 00:10:21,920
abstract I owe to the point where you

00:10:20,360 --> 00:10:24,130
can say to regardless of what kind of

00:10:21,920 --> 00:10:28,730
i/o it is we can handle it in the same

00:10:24,130 --> 00:10:30,500
same path so what are you know what are

00:10:28,730 --> 00:10:32,449
some ways that people have handled

00:10:30,500 --> 00:10:36,339
concurrent io the current meaning you've

00:10:32,449 --> 00:10:38,689
got more than one source of something so

00:10:36,339 --> 00:10:41,870
NFU if i was actually a minute

00:10:38,689 --> 00:10:44,209
presentation on friday about historical

00:10:41,870 --> 00:10:45,589
systems which is another fascination of

00:10:44,209 --> 00:10:47,000
mine and and one of the things that came

00:10:45,589 --> 00:10:50,959
up in that research that applies to this

00:10:47,000 --> 00:10:52,699
is this monotonic concept so some of the

00:10:50,959 --> 00:10:55,790
original time-sharing systems some of

00:10:52,699 --> 00:10:57,649
the original main Francis systems they

00:10:55,790 --> 00:10:58,520
work simply by saying they had a fixed

00:10:57,649 --> 00:11:01,040
amount of time

00:10:58,520 --> 00:11:04,850
and you would rotate for intervals

00:11:01,040 --> 00:11:06,290
around and if you used it all gray if

00:11:04,850 --> 00:11:09,380
you didn't use it all it's ok we just

00:11:06,290 --> 00:11:11,150
there was no there was no extra logic of

00:11:09,380 --> 00:11:12,320
wind to go to another thing you just had

00:11:11,150 --> 00:11:13,910
a finite amount I'm shuffled around

00:11:12,320 --> 00:11:17,660
there's actually still some systems to

00:11:13,910 --> 00:11:19,610
work like that today excuse me so

00:11:17,660 --> 00:11:22,520
another one is of there are systems

00:11:19,610 --> 00:11:26,240
older ones that have I Oh done with

00:11:22,520 --> 00:11:28,220
completely different hardware so that

00:11:26,240 --> 00:11:29,780
you can make that mainly Kristen

00:11:28,220 --> 00:11:32,120
mainframe world where you say okay we'll

00:11:29,780 --> 00:11:34,010
take all our terminal I oh that's in a

00:11:32,120 --> 00:11:37,910
whole separate subsystem and then we

00:11:34,010 --> 00:11:41,960
batch that out to actual actual core put

00:11:37,910 --> 00:11:46,100
the you know there is still signal based

00:11:41,960 --> 00:11:47,930
I oh and Linux I guess more in the

00:11:46,100 --> 00:11:49,970
cameras on Windows background you would

00:11:47,930 --> 00:11:53,390
call it overlapped I oh that's kind of

00:11:49,970 --> 00:11:54,530
another one but it's not really relevant

00:11:53,390 --> 00:11:56,710
to where you're just pointed out that

00:11:54,530 --> 00:11:58,820
exists you can also just have

00:11:56,710 --> 00:12:00,500
traditional multi-process so in a sense

00:11:58,820 --> 00:12:02,960
that we have a single process is just

00:12:00,500 --> 00:12:05,150
just handling one piece of i/o blocking

00:12:02,960 --> 00:12:07,100
on that and we'll multiplex that whole

00:12:05,150 --> 00:12:08,420
concept with the OS and then we can

00:12:07,100 --> 00:12:14,210
design all T threaded now put that on

00:12:08,420 --> 00:12:16,910
there because sadly the way that a lot

00:12:14,210 --> 00:12:19,940
of things worked out you had this

00:12:16,910 --> 00:12:22,100
situation where we were doing

00:12:19,940 --> 00:12:24,380
multi-threaded programming explicitly to

00:12:22,100 --> 00:12:26,360
handle i/o which is really disappointing

00:12:24,380 --> 00:12:28,130
because that's a terrible way to have to

00:12:26,360 --> 00:12:30,260
handle IO multi-threading in the

00:12:28,130 --> 00:12:32,630
abstract has some advantages for certain

00:12:30,260 --> 00:12:37,070
problems but just to solve i/o is I

00:12:32,630 --> 00:12:39,350
think sad and multiplex meaning so we'll

00:12:37,070 --> 00:12:41,840
say well you select or a pole or

00:12:39,350 --> 00:12:44,870
something like that so we'll have you

00:12:41,840 --> 00:12:47,390
say i have x number of i/o stimulus let

00:12:44,870 --> 00:12:52,130
me know if any of those can be operated

00:12:47,390 --> 00:12:53,180
upon and ok and what you see is a the

00:12:52,130 --> 00:12:54,890
efficiency point is when you actually

00:12:53,180 --> 00:12:56,300
use a combination a multi-process

00:12:54,890 --> 00:12:57,590
multithread which could be the same

00:12:56,300 --> 00:12:59,930
thing depending on what's environmental

00:12:57,590 --> 00:13:02,300
on and then multiplexing this with in

00:12:59,930 --> 00:13:04,920
this suit each thread handles a certain

00:13:02,300 --> 00:13:08,130
number of i/o jobs

00:13:04,920 --> 00:13:10,010
bitter multiplex which is the ER line

00:13:08,130 --> 00:13:13,019
model that's what it gives you for free

00:13:10,010 --> 00:13:14,519
if using it okay so then you also have

00:13:13,019 --> 00:13:16,380
this other concept of we're not

00:13:14,519 --> 00:13:18,269
necessarily trying to do concurrent io

00:13:16,380 --> 00:13:19,320
jobs whether the night we're not

00:13:18,269 --> 00:13:21,120
necessarily trying to do parallel

00:13:19,320 --> 00:13:23,699
processing although we might but we

00:13:21,120 --> 00:13:25,139
still have just different narratives

00:13:23,699 --> 00:13:26,310
with our logic we're trying to solve

00:13:25,139 --> 00:13:27,149
this problem here and we're also trying

00:13:26,310 --> 00:13:28,560
to solve this problem here and these

00:13:27,149 --> 00:13:31,620
things have to be thought about at the

00:13:28,560 --> 00:13:33,690
same time so and you know traditionally

00:13:31,620 --> 00:13:35,010
you have like in the sea background

00:13:33,690 --> 00:13:36,420
usually what you're doing is state

00:13:35,010 --> 00:13:39,029
switching of some kind we have some kind

00:13:36,420 --> 00:13:41,130
of context we save information to that

00:13:39,029 --> 00:13:43,199
and as we go to different jobs we go

00:13:41,130 --> 00:13:46,079
back to that that's also what happens at

00:13:43,199 --> 00:13:47,430
the OS level or again you can say you're

00:13:46,079 --> 00:13:50,250
going to split the problem out entirely

00:13:47,430 --> 00:13:51,810
separate programs and chain them

00:13:50,250 --> 00:13:52,829
together somehow you can you can use

00:13:51,810 --> 00:13:54,690
pipes whatever where you just actually

00:13:52,829 --> 00:13:57,060
have a true multiprocessor system again

00:13:54,690 --> 00:13:58,889
the multi-threaded explicitly for logic

00:13:57,060 --> 00:14:03,240
makes a little more sense a little more

00:13:58,889 --> 00:14:06,209
justifiable the historic one that is the

00:14:03,240 --> 00:14:07,860
I think really the superior model and a

00:14:06,209 --> 00:14:09,779
lot of ways is the co routine concept

00:14:07,860 --> 00:14:14,190
where you you're not actually getting

00:14:09,779 --> 00:14:16,110
things in parallel at runtime but if the

00:14:14,190 --> 00:14:18,839
logic is parallel you can manually

00:14:16,110 --> 00:14:23,430
switch between context without without

00:14:18,839 --> 00:14:26,910
all the demanding of state that is what

00:14:23,430 --> 00:14:28,890
Erlin gives you for free and then

00:14:26,910 --> 00:14:30,990
another model it would be you could say

00:14:28,890 --> 00:14:33,540
that things like will service one

00:14:30,990 --> 00:14:35,279
request the internet requests a

00:14:33,540 --> 00:14:38,540
stateless and beyond to another like you

00:14:35,279 --> 00:14:41,870
see in like web server logic sometimes

00:14:38,540 --> 00:14:44,310
you could say that's another paradigm

00:14:41,870 --> 00:14:45,930
okay then the other concept as well

00:14:44,310 --> 00:14:47,279
we're not just trying to hamiltoe I aww

00:14:45,930 --> 00:14:49,670
and we're not just trying to handle

00:14:47,279 --> 00:14:52,890
multiple narratives of logic we also

00:14:49,670 --> 00:14:54,360
actually have parallel processing

00:14:52,890 --> 00:14:56,839
hardware of different kinds and we want

00:14:54,360 --> 00:14:59,100
to find some way to leverage that so

00:14:56,839 --> 00:14:59,910
okay you've got vector operations and we

00:14:59,100 --> 00:15:03,480
as

00:14:59,910 --> 00:15:05,340
I've got a single or single operation

00:15:03,480 --> 00:15:09,930
that I want to perform on multiple units

00:15:05,340 --> 00:15:11,550
of data like a GPU erling is not going

00:15:09,930 --> 00:15:14,610
to help you with that that would be an

00:15:11,550 --> 00:15:18,960
example of you want to go back to native

00:15:14,610 --> 00:15:20,070
code other one that's this odd that kind

00:15:18,960 --> 00:15:23,280
of comes own conversation I think is

00:15:20,070 --> 00:15:25,500
fascinating is i'll call it optimistic

00:15:23,280 --> 00:15:28,170
branch prediction in a sense that in any

00:15:25,500 --> 00:15:29,340
kind of pipeline processor one of the

00:15:28,170 --> 00:15:32,190
things that's one of the tricks is doing

00:15:29,340 --> 00:15:34,020
a try to make things go faster is you

00:15:32,190 --> 00:15:35,820
have a branch and conditional you'll

00:15:34,020 --> 00:15:40,110
have an if statement and the processor

00:15:35,820 --> 00:15:41,340
can say I don't know which path code

00:15:40,110 --> 00:15:42,150
path is going to be taken because we

00:15:41,340 --> 00:15:44,100
don't know what the value of that

00:15:42,150 --> 00:15:45,750
conditional is yet but what i can do is

00:15:44,100 --> 00:15:47,280
i can actually run i can either just

00:15:45,750 --> 00:15:48,870
pick one that i think it's going to be

00:15:47,280 --> 00:15:51,450
or go ahead and run both of them at the

00:15:48,870 --> 00:15:53,100
same time and then later on when we

00:15:51,450 --> 00:15:54,840
figure out which code path needs to be

00:15:53,100 --> 00:15:56,430
run we'll just kill the other one and

00:15:54,840 --> 00:15:58,080
this all happens behind the scenes but

00:15:56,430 --> 00:16:00,420
ok so that's more of a hardware

00:15:58,080 --> 00:16:03,330
discussion except for the fact that you

00:16:00,420 --> 00:16:04,830
had the whole itanium thing we're part

00:16:03,330 --> 00:16:06,560
of that model was to expose that to the

00:16:04,830 --> 00:16:08,970
programmer and you actually were

00:16:06,560 --> 00:16:10,890
supposed to put these branch prediction

00:16:08,970 --> 00:16:12,480
hints what you still have but they're

00:16:10,890 --> 00:16:13,590
not used as much to actually say this is

00:16:12,480 --> 00:16:17,850
what I think you're supposed to do and

00:16:13,590 --> 00:16:21,090
that model didn't pan out so well other

00:16:17,850 --> 00:16:22,560
one like OpenMP would be an example I

00:16:21,090 --> 00:16:24,330
think of annotated code sections where

00:16:22,560 --> 00:16:26,400
you take a just serialized linear

00:16:24,330 --> 00:16:28,470
program but then you take one specific

00:16:26,400 --> 00:16:30,960
part like a loop and you say ok we can

00:16:28,470 --> 00:16:33,030
paralyze this it's kind of a retrofit

00:16:30,960 --> 00:16:37,530
technique but that is uh that's another

00:16:33,030 --> 00:16:38,550
good one then you can have the more

00:16:37,530 --> 00:16:40,770
traditional approach or what we call

00:16:38,550 --> 00:16:43,710
traditional now where you actually just

00:16:40,770 --> 00:16:46,500
do atomic commits to memory you know you

00:16:43,710 --> 00:16:48,330
have locks and things like that and what

00:16:46,500 --> 00:16:51,990
else a threaded programming and then the

00:16:48,330 --> 00:16:54,740
other model is just send IO between

00:16:51,990 --> 00:16:58,980
programs are between program units or

00:16:54,740 --> 00:17:00,210
message passing like an NPI or a message

00:16:58,980 --> 00:17:02,550
blush like the rabbit in queues only

00:17:00,210 --> 00:17:04,470
that that's the early model that's what

00:17:02,550 --> 00:17:06,519
our lang is giving you it's based on

00:17:04,470 --> 00:17:09,559
message passing

00:17:06,519 --> 00:17:10,939
okay then you know one further you say

00:17:09,559 --> 00:17:13,760
ok well now we actually want to throw

00:17:10,939 --> 00:17:17,240
more than one box at the problem so

00:17:13,760 --> 00:17:19,929
either because we want failover or I'll

00:17:17,240 --> 00:17:24,079
because we want to have capability to do

00:17:19,929 --> 00:17:25,640
more processing batch farm you know good

00:17:24,079 --> 00:17:27,289
idea week that can be fine grained it

00:17:25,640 --> 00:17:30,200
can be land can be coarse grain you can

00:17:27,289 --> 00:17:32,870
say we have a lot of work to do let's

00:17:30,200 --> 00:17:35,299
farm it out to different servers it's

00:17:32,870 --> 00:17:39,019
still use that's the original pros Numa

00:17:35,299 --> 00:17:40,820
is I guess the more prominent example

00:17:39,019 --> 00:17:43,549
you see now would be the Oracle

00:17:40,820 --> 00:17:46,549
Enterprise notion on this where you

00:17:43,549 --> 00:17:50,059
actually can do a memory mapping and two

00:17:46,549 --> 00:17:52,460
remote machines kind of thing and then

00:17:50,059 --> 00:17:55,549
of course message passing MPI being

00:17:52,460 --> 00:17:57,139
probably more famous example but or you

00:17:55,549 --> 00:17:58,399
can just write sockets well you know do

00:17:57,139 --> 00:18:00,230
yourself but that's what erlan gives you

00:17:58,399 --> 00:18:02,269
so that's also the early model so that's

00:18:00,230 --> 00:18:05,840
what you say you have this unified model

00:18:02,269 --> 00:18:09,049
of a solving kind of all these problems

00:18:05,840 --> 00:18:12,230
in the same way so you have a nice range

00:18:09,049 --> 00:18:18,110
to work with all right so hello world ok

00:18:12,230 --> 00:18:21,590
so there is a one-to-one relationship

00:18:18,110 --> 00:18:25,580
between source files and modules in

00:18:21,590 --> 00:18:27,769
Erlang so your erling source file is

00:18:25,580 --> 00:18:31,850
always going to say a module and then

00:18:27,769 --> 00:18:36,169
what the name of it is then you have to

00:18:31,850 --> 00:18:38,840
explicitly say the functions within that

00:18:36,169 --> 00:18:40,669
module that you export or you can

00:18:38,840 --> 00:18:42,500
actually say don't do that I'm going to

00:18:40,669 --> 00:18:45,710
be lazy and sloppy and export everything

00:18:42,500 --> 00:18:48,169
don't do that and then you define your

00:18:45,710 --> 00:18:50,630
functions in this case we just have

00:18:48,169 --> 00:18:55,370
hello world the way that this actually

00:18:50,630 --> 00:18:59,389
is working is we are saying the process

00:18:55,370 --> 00:19:01,519
that runs this send a message to our

00:18:59,389 --> 00:19:03,860
console process or the process its

00:19:01,519 --> 00:19:07,460
handling I oh and send this message

00:19:03,860 --> 00:19:08,929
which console daioh prog the system io

00:19:07,460 --> 00:19:11,389
process ends up being the console and

00:19:08,929 --> 00:19:13,230
you get this message so let's take a

00:19:11,389 --> 00:19:18,410
look

00:19:13,230 --> 00:19:18,410
at if I can hit the right button here

00:19:23,270 --> 00:19:27,550
that's sad what's right in

00:19:27,820 --> 00:19:37,630
skate maybe seriously ok your back area

00:19:34,890 --> 00:19:40,300
no time I haven't okay so let's kill

00:19:37,630 --> 00:19:46,510
this so oh wait I don't want to kill

00:19:40,300 --> 00:19:51,730
that okay let's go back to here I'm

00:19:46,510 --> 00:19:54,850
sorry yes okay anybody know what that

00:19:51,730 --> 00:19:56,530
keyboard shortcut is in Nome terminal

00:19:54,850 --> 00:20:02,230
with zooms in on your text otherwise i

00:19:56,530 --> 00:20:04,770
can just do this ctrl shift ah there we

00:20:02,230 --> 00:20:04,770
go that's cool

00:20:05,680 --> 00:20:10,840
this is I just said this laptop up

00:20:07,750 --> 00:20:13,960
pretty quick to get this okay so we will

00:20:10,840 --> 00:20:17,940
we'll just close out of that alright so

00:20:13,960 --> 00:20:17,940
what we've got we got the that hello

00:20:18,330 --> 00:20:22,690
program in a file server in this so so a

00:20:21,250 --> 00:20:24,190
lot of the examples and tutorials they

00:20:22,690 --> 00:20:26,530
give you are entirely based inside the

00:20:24,190 --> 00:20:28,240
ER line console which is which and you

00:20:26,530 --> 00:20:29,170
learn but i think it's hard i would i

00:20:28,240 --> 00:20:31,570
would have rather when I was first

00:20:29,170 --> 00:20:33,760
learning to have someone show me this so

00:20:31,570 --> 00:20:35,470
we're back in the you know real world of

00:20:33,760 --> 00:20:37,510
Linux all right we're in real

00:20:35,470 --> 00:20:40,480
development right we have text files

00:20:37,510 --> 00:20:43,630
that we can use version control on and

00:20:40,480 --> 00:20:46,270
then we do regular development type

00:20:43,630 --> 00:20:49,900
stuff like we have a compiler and we can

00:20:46,270 --> 00:20:58,450
say here is the name of our source right

00:20:49,900 --> 00:21:00,370
and then the output on that is it

00:20:58,450 --> 00:21:03,400
created this file called a beam file and

00:21:00,370 --> 00:21:05,320
a beam is actually the initials of the

00:21:03,400 --> 00:21:09,760
other engineers that came up with the

00:21:05,320 --> 00:21:11,140
runtime engine so that's what that is so

00:21:09,760 --> 00:21:12,580
now what we can use weekends we can run

00:21:11,140 --> 00:21:14,410
this thing so we can actually come in

00:21:12,580 --> 00:21:15,430
here and this is a little to run it in

00:21:14,410 --> 00:21:17,200
the console like we think of a regular

00:21:15,430 --> 00:21:18,460
program it so it's a little bit awkward

00:21:17,200 --> 00:21:19,750
that's why they don't show you first but

00:21:18,460 --> 00:21:22,660
I think they should show you first so

00:21:19,750 --> 00:21:24,640
I'm going to do that you could say this

00:21:22,660 --> 00:21:27,270
and you can say if i can remember this

00:21:24,640 --> 00:21:27,270
off my head

00:21:28,580 --> 00:21:33,690
so what that is is the I'm asking it to

00:21:32,039 --> 00:21:37,260
start and I'm getting it the module name

00:21:33,690 --> 00:21:40,350
function name we can talk about this

00:21:37,260 --> 00:21:42,870
other part later and that's what we got

00:21:40,350 --> 00:21:45,480
into the console so one reason that was

00:21:42,870 --> 00:21:47,370
a little bit strange because the default

00:21:45,480 --> 00:21:48,950
behavior is to start this this virtual

00:21:47,370 --> 00:21:51,690
machine and spun up all these other

00:21:48,950 --> 00:21:53,130
background processes within this virtual

00:21:51,690 --> 00:21:56,490
machines there's a multi-process virtual

00:21:53,130 --> 00:21:58,230
machine they do that are geared to spin

00:21:56,490 --> 00:21:59,520
up to do all kinds of cool stuff which

00:21:58,230 --> 00:22:02,039
we don't do because we're just printing

00:21:59,520 --> 00:22:04,049
on hello world and so we've manually

00:22:02,039 --> 00:22:06,240
specified that I want to run this module

00:22:04,049 --> 00:22:07,980
this function and then I want another

00:22:06,240 --> 00:22:11,640
module in this one in this case this

00:22:07,980 --> 00:22:12,840
module controls startup and shutdown and

00:22:11,640 --> 00:22:15,360
we're just setting it to stop so that's

00:22:12,840 --> 00:22:18,150
how we made it actually turn itself off

00:22:15,360 --> 00:22:20,280
after we run that and then the no shell

00:22:18,150 --> 00:22:22,400
thing is normally if you want like this

00:22:20,280 --> 00:22:25,530
we're going to be in an interactive

00:22:22,400 --> 00:22:26,640
Erling console which we didn't want to

00:22:25,530 --> 00:22:28,919
do in this case we actually wanted to

00:22:26,640 --> 00:22:30,659
demonstrate that the i/o can be routed

00:22:28,919 --> 00:22:32,070
up to the real system and use it in the

00:22:30,659 --> 00:22:34,740
way that you think of as real programs

00:22:32,070 --> 00:22:36,120
so like the traditional way that

00:22:34,740 --> 00:22:38,190
somebody would show you that is just

00:22:36,120 --> 00:22:39,570
bring up there erling console you

00:22:38,190 --> 00:22:42,510
actually can do the compilation inside

00:22:39,570 --> 00:22:43,799
of the console but that's confusing

00:22:42,510 --> 00:22:45,630
because you still want traditional

00:22:43,799 --> 00:22:46,770
regular comp what we actually call the

00:22:45,630 --> 00:22:48,450
compiler because I can still put that in

00:22:46,770 --> 00:22:53,429
a make file a script you know regular

00:22:48,450 --> 00:22:57,000
normal stuff but whatever so we can we

00:22:53,429 --> 00:23:01,520
can call the module name and the

00:22:57,000 --> 00:23:04,300
function name well if I can

00:23:01,520 --> 00:23:09,490
type on it yep

00:23:04,300 --> 00:23:14,380
okay so so when go one further we can

00:23:09,490 --> 00:23:17,500
say we can say this we can do this with

00:23:14,380 --> 00:23:23,920
two connections to remote connections so

00:23:17,500 --> 00:23:26,320
let's say that we we start the start

00:23:23,920 --> 00:23:27,610
with the Erlang virtual machine and we

00:23:26,320 --> 00:23:29,710
want to enable the networking

00:23:27,610 --> 00:23:31,030
capabilities so you can do long names

00:23:29,710 --> 00:23:32,050
short names will give this short name

00:23:31,030 --> 00:23:35,680
will call it stopped because it's the

00:23:32,050 --> 00:23:38,730
window on top come down here will close

00:23:35,680 --> 00:23:41,320
this will start another erling process

00:23:38,730 --> 00:23:46,030
will call this one the bottom because

00:23:41,320 --> 00:23:47,770
it's on the bottom now normally on one

00:23:46,030 --> 00:23:49,900
single compute node you would just run

00:23:47,770 --> 00:23:51,310
one instance of Erling so we can just

00:23:49,900 --> 00:23:53,860
imagine that these are on different

00:23:51,310 --> 00:23:55,330
computers but it's works the same way

00:23:53,860 --> 00:23:56,500
there are sometimes there's reasons to

00:23:55,330 --> 00:23:58,840
do this sort of thing you can mix and

00:23:56,500 --> 00:24:01,960
match to everyone so we can actually go

00:23:58,840 --> 00:24:03,940
in here and we can say i actually think

00:24:01,960 --> 00:24:05,560
i have it cheated if I just scroll up

00:24:03,940 --> 00:24:09,910
somewhere make sure I type in the right

00:24:05,560 --> 00:24:12,130
way yeah so you can get to this RPC

00:24:09,910 --> 00:24:16,890
module this is one way of doing things

00:24:12,130 --> 00:24:20,710
and I can say hey what I'd like to do is

00:24:16,890 --> 00:24:24,580
I want to I want to call and I can give

00:24:20,710 --> 00:24:26,740
it this is the name of another node I

00:24:24,580 --> 00:24:29,020
want you to I want you to go to this

00:24:26,740 --> 00:24:31,660
module this function with these function

00:24:29,020 --> 00:24:34,300
parameters run that and redirect the

00:24:31,660 --> 00:24:36,460
output back here which is what they did

00:24:34,300 --> 00:24:40,720
so in this case the reason why we say

00:24:36,460 --> 00:24:43,510
the hello world still here is because it

00:24:40,720 --> 00:24:47,470
actually ran inside the vm running on

00:24:43,510 --> 00:24:49,360
here but it the console aya was set up

00:24:47,470 --> 00:24:52,500
to go to hear by default because the it

00:24:49,360 --> 00:24:52,500
figured out where we've come from

00:24:52,840 --> 00:24:58,480
okay if I go to back here

00:25:02,450 --> 00:25:07,010
alright so yeah as I was leading to so

00:25:05,270 --> 00:25:09,430
you have you still have a regular

00:25:07,010 --> 00:25:12,440
operating system in this case linux and

00:25:09,430 --> 00:25:14,690
their regular operating system processes

00:25:12,440 --> 00:25:17,390
that are going on the entire erling

00:25:14,690 --> 00:25:19,160
virtual machine is a single regular

00:25:17,390 --> 00:25:20,870
operating system process it doesn't have

00:25:19,160 --> 00:25:22,280
to be it actually there are

00:25:20,870 --> 00:25:23,450
implementations of it where it is its

00:25:22,280 --> 00:25:25,370
own operating system that was the

00:25:23,450 --> 00:25:27,800
original use was it would be the

00:25:25,370 --> 00:25:31,610
firmware on a switch that that stuff

00:25:27,800 --> 00:25:35,270
still happens there are projects to run

00:25:31,610 --> 00:25:36,920
or natively on Zen for example so we can

00:25:35,270 --> 00:25:39,020
strip out stuff and do something to that

00:25:36,920 --> 00:25:40,790
but then you lose the leverage to mix

00:25:39,020 --> 00:25:43,730
and match regular Linux with our lines

00:25:40,790 --> 00:25:46,670
so but that's there and then within

00:25:43,730 --> 00:25:48,680
inside that world that the virtual

00:25:46,670 --> 00:25:51,050
machine gives you it has its own

00:25:48,680 --> 00:25:54,230
processes which can also be called

00:25:51,050 --> 00:25:57,160
actors so the in if you want to

00:25:54,230 --> 00:25:59,780
disambiguate the notion between a

00:25:57,160 --> 00:26:01,250
process that's inside the early a.m and

00:25:59,780 --> 00:26:04,520
when it's outside you can use the word

00:26:01,250 --> 00:26:05,930
actor although sometimes people don't

00:26:04,520 --> 00:26:07,790
say that it gets confusing which I

00:26:05,930 --> 00:26:14,210
processes what are you talking about and

00:26:07,790 --> 00:26:17,510
and these are their implemented as as co

00:26:14,210 --> 00:26:19,280
routines in the sense that they each

00:26:17,510 --> 00:26:21,560
have their own they don't actually not

00:26:19,280 --> 00:26:24,170
using the stack hardware for the system

00:26:21,560 --> 00:26:25,430
so you can actually have hundreds and

00:26:24,170 --> 00:26:27,980
literally hundreds and hundreds of

00:26:25,430 --> 00:26:30,650
thousands of processes inside here and

00:26:27,980 --> 00:26:31,970
you or you're not overflowing the stack

00:26:30,650 --> 00:26:34,340
and I having to do manual stack

00:26:31,970 --> 00:26:37,790
switching of any kind it's just the way

00:26:34,340 --> 00:26:39,110
the vm implements it and so in this case

00:26:37,790 --> 00:26:41,510
though and so the other mop thing about

00:26:39,110 --> 00:26:44,480
the model is the way that you can expose

00:26:41,510 --> 00:26:48,440
i owe to the outside world is you have

00:26:44,480 --> 00:26:50,630
these port actors and i push it online

00:26:48,440 --> 00:26:51,980
but so in this case the other external

00:26:50,630 --> 00:26:54,110
process we had would be the one that was

00:26:51,980 --> 00:26:56,140
running bash and the console and there's

00:26:54,110 --> 00:27:00,230
pipes that connect that back to the

00:26:56,140 --> 00:27:02,390
Erling beam and then inside there when

00:27:00,230 --> 00:27:04,010
when we for example we sent the hello

00:27:02,390 --> 00:27:07,010
world message we're actually sending

00:27:04,010 --> 00:27:09,680
that over to another actor we're inside

00:27:07,010 --> 00:27:10,240
the DM and said ok you do something with

00:27:09,680 --> 00:27:12,490
this

00:27:10,240 --> 00:27:13,720
and it knows what to do which is to send

00:27:12,490 --> 00:27:16,500
it back out the outside world so that

00:27:13,720 --> 00:27:20,590
it's kind of the model for how you can

00:27:16,500 --> 00:27:22,390
connect to other things and then also we

00:27:20,590 --> 00:27:26,740
had the interactive shell that we're

00:27:22,390 --> 00:27:28,360
looking at was running there also ok so

00:27:26,740 --> 00:27:30,700
now more about like what is the actual

00:27:28,360 --> 00:27:32,530
programming lang so with functional

00:27:30,700 --> 00:27:34,600
programming there's is this notion of

00:27:32,530 --> 00:27:36,010
immutable data is that everyone know

00:27:34,600 --> 00:27:40,210
what that is a totally new to everybody

00:27:36,010 --> 00:27:43,030
right okay so um depending on your

00:27:40,210 --> 00:27:44,920
background you love that and you think

00:27:43,030 --> 00:27:47,110
it's a fanatic your fanatic about it or

00:27:44,920 --> 00:27:49,720
you despise it think it's a stupidest

00:27:47,110 --> 00:27:52,300
thing ever I still think it's a stupid

00:27:49,720 --> 00:27:55,179
thing ever but I will concede that there

00:27:52,300 --> 00:27:56,830
actually is a number of problems where

00:27:55,179 --> 00:27:58,780
that is that's the appropriate way to

00:27:56,830 --> 00:28:00,940
solve them didn't really understand what

00:27:58,780 --> 00:28:03,070
those problems were until I had you know

00:28:00,940 --> 00:28:04,780
started learning this and many am I

00:28:03,070 --> 00:28:06,640
still don't but anyway the point is that

00:28:04,780 --> 00:28:08,260
when you do a variable assignment like

00:28:06,640 --> 00:28:12,880
let's say we take a and then we assign a

00:28:08,260 --> 00:28:14,770
five okay that is now fixed at five and

00:28:12,880 --> 00:28:16,780
we want to reassign it to something else

00:28:14,770 --> 00:28:20,020
and it's going to Seth I you can't do

00:28:16,780 --> 00:28:22,440
that so that's cute and all I mean

00:28:20,020 --> 00:28:27,100
that's sort of the semantics we get from

00:28:22,440 --> 00:28:28,920
math but how do you write a program to

00:28:27,100 --> 00:28:32,050
do anything like that how can you

00:28:28,920 --> 00:28:33,880
conceivably do anything so if you think

00:28:32,050 --> 00:28:35,920
about it for a little while yeah there

00:28:33,880 --> 00:28:37,660
actually is no answer to that so you

00:28:35,920 --> 00:28:39,850
cheat so that's not really the full

00:28:37,660 --> 00:28:43,720
story so first of all those assignments

00:28:39,850 --> 00:28:45,309
are on a per function / process basis so

00:28:43,720 --> 00:28:48,610
you every time you run that function

00:28:45,309 --> 00:28:53,800
again you can give new values to those

00:28:48,610 --> 00:28:55,420
variables and in the Erlang world where

00:28:53,800 --> 00:28:56,830
you actually have multiple processes

00:28:55,420 --> 00:28:58,450
that also part of the reason why you

00:28:56,830 --> 00:29:00,309
have that is to kind of mitigate that

00:28:58,450 --> 00:29:02,470
also so I can be running the same

00:29:00,309 --> 00:29:04,720
function multiple times in different

00:29:02,470 --> 00:29:07,330
processes and those local variables can

00:29:04,720 --> 00:29:10,150
be whatever they want and the other one

00:29:07,330 --> 00:29:12,490
is that there's a use linked lists

00:29:10,150 --> 00:29:15,429
heavily and the functional programming

00:29:12,490 --> 00:29:19,030
world in general but Erling also so here

00:29:15,429 --> 00:29:20,950
we make a list we'll call it C I'll give

00:29:19,030 --> 00:29:24,220
you three integers 16 15

00:29:20,950 --> 00:29:25,690
and we can I probably should have shown

00:29:24,220 --> 00:29:28,269
full Melissa manipulation but you can

00:29:25,690 --> 00:29:30,159
dissect that list you easily so there's

00:29:28,269 --> 00:29:33,669
operators built into the syntax of the

00:29:30,159 --> 00:29:36,429
language to say things like excuse me

00:29:33,669 --> 00:29:38,850
just just give me a portion of this so

00:29:36,429 --> 00:29:41,350
in this case we're having the variable D

00:29:38,850 --> 00:29:45,190
we want that to be assigned just to the

00:29:41,350 --> 00:29:47,740
head of the list and in just one so you

00:29:45,190 --> 00:29:51,730
can do these concepts of rearranging

00:29:47,740 --> 00:29:53,559
list elements to kind of give some of

00:29:51,730 --> 00:29:56,889
the ways that you would have of reassign

00:29:53,559 --> 00:29:58,360
data but from this where you just call

00:29:56,889 --> 00:29:59,799
another function will talk about that in

00:29:58,360 --> 00:30:02,710
the next slide the other thing we see

00:29:59,799 --> 00:30:05,620
here is an underscore that's an example

00:30:02,710 --> 00:30:07,470
of pattern matching so the pattern

00:30:05,620 --> 00:30:09,880
matching thing is kind of almost like

00:30:07,470 --> 00:30:12,309
the way you would think our way I would

00:30:09,880 --> 00:30:15,700
think of as a preprocessor macro logic

00:30:12,309 --> 00:30:17,649
but it's done at runtime so it's just

00:30:15,700 --> 00:30:19,720
fascinating it can do some really cool

00:30:17,649 --> 00:30:21,970
stuff and the underscore is sort of a

00:30:19,720 --> 00:30:24,519
special pattern match it means anything

00:30:21,970 --> 00:30:27,970
it's like the wild-card the glob

00:30:24,519 --> 00:30:32,019
operator you think if there's a stars so

00:30:27,970 --> 00:30:34,080
but the better way that you would

00:30:32,019 --> 00:30:36,039
actually sell these problems is when you

00:30:34,080 --> 00:30:39,669
call it functions they were never again

00:30:36,039 --> 00:30:44,289
yet the introduces discussion so a

00:30:39,669 --> 00:30:47,830
normal normal recursive function calls

00:30:44,289 --> 00:30:51,610
like let's take on the left there we've

00:30:47,830 --> 00:30:54,669
got AC function and we'd do something

00:30:51,610 --> 00:30:56,950
pointless we will just recursively call

00:30:54,669 --> 00:30:59,740
ourselves over and over and over again

00:30:56,950 --> 00:31:02,580
adding 1 to this value until that value

00:30:59,740 --> 00:31:07,419
is 100 and then we collapse the

00:31:02,580 --> 00:31:11,019
recursion stack so what happens here is

00:31:07,419 --> 00:31:13,899
every single time that you do this we're

00:31:11,019 --> 00:31:17,769
creating a separate storage location for

00:31:13,899 --> 00:31:19,600
that variable a on the stack and so when

00:31:17,769 --> 00:31:22,389
you learn this kind of stuff you learn

00:31:19,600 --> 00:31:24,100
don't do that you can have a stack

00:31:22,389 --> 00:31:25,539
overflow it will eventually just clap

00:31:24,100 --> 00:31:27,519
but you're just wasting memory yet that

00:31:25,539 --> 00:31:28,909
some means of controlling this and be

00:31:27,519 --> 00:31:32,580
careful about it now

00:31:28,909 --> 00:31:34,769
if you are in assembly language one of

00:31:32,580 --> 00:31:37,860
the tricks that you can do is you can

00:31:34,769 --> 00:31:39,029
say all right we want to call the same

00:31:37,860 --> 00:31:41,460
function that we're in right now

00:31:39,029 --> 00:31:44,249
recursively but we want to call it in a

00:31:41,460 --> 00:31:47,220
different way we actually don't need to

00:31:44,249 --> 00:31:49,289
maintain a separate copy of these local

00:31:47,220 --> 00:31:50,970
variables we just want to update the

00:31:49,289 --> 00:31:53,879
value of the local variable and then

00:31:50,970 --> 00:31:56,100
enter into ourselves again and they call

00:31:53,879 --> 00:31:58,529
it tail recursion in some languages

00:31:56,100 --> 00:32:01,769
natively support this in the example

00:31:58,529 --> 00:32:04,340
here we have C depending on the compiler

00:32:01,769 --> 00:32:06,779
implementation and optimizations is

00:32:04,340 --> 00:32:08,249
probably smart enough to do that for you

00:32:06,779 --> 00:32:11,159
in this function because there's no real

00:32:08,249 --> 00:32:13,049
purpose of having a separate copy of the

00:32:11,159 --> 00:32:16,429
valuation does it run so it might be

00:32:13,049 --> 00:32:18,179
smart to do that in the case of erling I

00:32:16,429 --> 00:32:19,499
kind of think it would be probably

00:32:18,179 --> 00:32:20,759
better if there was a way to explicitly

00:32:19,499 --> 00:32:25,950
say that that's what you're doing but

00:32:20,759 --> 00:32:28,259
you can have both ways so because we're

00:32:25,950 --> 00:32:29,429
not calling it and we haven't designed

00:32:28,259 --> 00:32:31,019
this function in such a way that you

00:32:29,429 --> 00:32:33,360
actually would have to have a separate

00:32:31,019 --> 00:32:35,730
copy of a it automatically does this and

00:32:33,360 --> 00:32:39,090
this is built into the language as a

00:32:35,730 --> 00:32:42,149
means of working around that paradigm

00:32:39,090 --> 00:32:44,759
that you can't reassign a value a so

00:32:42,149 --> 00:32:48,179
just like in math we can call a function

00:32:44,759 --> 00:32:51,029
as many times we want to with different

00:32:48,179 --> 00:32:52,590
unique parameters and it should get the

00:32:51,029 --> 00:32:55,139
same thing each time you call the same

00:32:52,590 --> 00:32:57,119
parameter but each invocation of it

00:32:55,139 --> 00:32:59,610
separately so that's that's how you

00:32:57,119 --> 00:33:02,610
there so that model comes from you don't

00:32:59,610 --> 00:33:04,080
use there is an if and Erling but you

00:33:02,610 --> 00:33:05,879
pretty much don't ever use it because

00:33:04,080 --> 00:33:07,049
it's strange and it's kind of not the

00:33:05,879 --> 00:33:09,119
way they want you to do thing you end up

00:33:07,049 --> 00:33:12,029
using a switch case with it which i call

00:33:09,119 --> 00:33:14,070
it case block / never again so in this

00:33:12,029 --> 00:33:16,980
case we're saying another example of

00:33:14,070 --> 00:33:19,830
pattern matching so what this does is it

00:33:16,980 --> 00:33:21,419
says all right on our function we're

00:33:19,830 --> 00:33:26,450
going to we're going to do a switch case

00:33:21,419 --> 00:33:29,899
of a and the first one we have is

00:33:26,450 --> 00:33:32,369
anytime a is less than 100 then we will

00:33:29,899 --> 00:33:34,740
recursively call it into ourselves add

00:33:32,369 --> 00:33:37,050
one to it and then the

00:33:34,740 --> 00:33:40,110
autumn pattern match so we have the both

00:33:37,050 --> 00:33:43,440
of the two statements the two the two

00:33:40,110 --> 00:33:45,570
cases that it could be are both pattern

00:33:43,440 --> 00:33:48,390
matched on the wild card meaning

00:33:45,570 --> 00:33:51,059
anything but the first one has the wind

00:33:48,390 --> 00:33:53,520
and the a is lesson that's it's called a

00:33:51,059 --> 00:33:57,120
guard so you can just add these other

00:33:53,520 --> 00:34:00,050
expressions to sort of say I only go in

00:33:57,120 --> 00:34:03,510
here so it's it's different than saying

00:34:00,050 --> 00:34:08,639
if or just have sit but whatever that's

00:34:03,510 --> 00:34:09,750
way to do it okay yeah oh so the other

00:34:08,639 --> 00:34:12,840
thing that you have to deal with is

00:34:09,750 --> 00:34:15,000
there's no like wild loops and for loops

00:34:12,840 --> 00:34:17,040
so you say well how do you do anything

00:34:15,000 --> 00:34:18,750
again and the answer is the same model

00:34:17,040 --> 00:34:21,450
you do that tail recursion model so if

00:34:18,750 --> 00:34:25,260
you're iterating over an array or a list

00:34:21,450 --> 00:34:27,720
or is you know in a comparative program

00:34:25,260 --> 00:34:30,119
paradigm you would do some kind of

00:34:27,720 --> 00:34:31,500
iteration loop and this you're just

00:34:30,119 --> 00:34:33,450
going to do that those tail recursive

00:34:31,500 --> 00:34:35,280
calls / never again but the other one

00:34:33,450 --> 00:34:38,850
that you have that it also gives you a

00:34:35,280 --> 00:34:41,460
way to do what amounts to looping is a

00:34:38,850 --> 00:34:46,889
list comprehension this comprehension is

00:34:41,460 --> 00:34:50,960
sort of an amalgam of these linked lists

00:34:46,889 --> 00:34:53,820
in syntax operations mixed with the

00:34:50,960 --> 00:34:56,490
pattern matching facilities so an

00:34:53,820 --> 00:34:58,890
example right here is we have a list one

00:34:56,490 --> 00:35:01,640
two three four and what we what we're

00:34:58,890 --> 00:35:04,350
saying by that double pipe operator is

00:35:01,640 --> 00:35:06,690
what we're going to do is we want to

00:35:04,350 --> 00:35:08,850
take each element that's in that list

00:35:06,690 --> 00:35:10,140
representatives X and then we want to

00:35:08,850 --> 00:35:12,210
perform an operation on in this case

00:35:10,140 --> 00:35:14,970
we're going to take x times X and we're

00:35:12,210 --> 00:35:18,060
going to create a new list from that so

00:35:14,970 --> 00:35:19,140
this has the same effect of iterating

00:35:18,060 --> 00:35:20,790
over a loop and you can actually do

00:35:19,140 --> 00:35:22,770
things like call functions in here and

00:35:20,790 --> 00:35:26,310
other kinds of complex stuff but we end

00:35:22,770 --> 00:35:28,350
up with the list squares so those are

00:35:26,310 --> 00:35:32,490
the kind of the model for how you get

00:35:28,350 --> 00:35:34,530
around immutable data alright so let's

00:35:32,490 --> 00:35:36,990
actually look at something else so the

00:35:34,530 --> 00:35:39,780
way that in the Erling world okay it's

00:35:36,990 --> 00:35:42,000
the way that their message passing and

00:35:39,780 --> 00:35:43,800
the multi-process works is really three

00:35:42,000 --> 00:35:47,910
low level concepts one is the spawn

00:35:43,800 --> 00:35:48,880
operator and where you actually can

00:35:47,910 --> 00:35:51,430
create new process

00:35:48,880 --> 00:35:53,440
actors the other one is this receive

00:35:51,430 --> 00:35:56,589
block concept which is similar to the

00:35:53,440 --> 00:35:59,289
case which are but you're you're saying

00:35:56,589 --> 00:36:00,849
okay when I receive a message what I

00:35:59,289 --> 00:36:02,500
wanted to do which messages specifically

00:36:00,849 --> 00:36:05,109
do I want to handle and welcome to them

00:36:02,500 --> 00:36:07,690
and then you have this ! operator which

00:36:05,109 --> 00:36:13,180
is that way to say send a message to

00:36:07,690 --> 00:36:16,410
something so let's take a look at what

00:36:13,180 --> 00:36:16,410
did I hit last time to make this work

00:36:34,589 --> 00:36:40,019
alright so this is a little program

00:36:36,690 --> 00:36:43,200
right here again we start with the the

00:36:40,019 --> 00:36:47,450
module name definition which is called

00:36:43,200 --> 00:36:51,660
NP 14 message press 1 and so this is a

00:36:47,450 --> 00:36:53,579
very primitive server will call it an

00:36:51,660 --> 00:36:54,869
echo server so we'll take your messages

00:36:53,579 --> 00:36:57,479
that we see them we'll send them back to

00:36:54,869 --> 00:36:59,819
whoever sent them to us and we'll put

00:36:57,479 --> 00:37:01,259
some also some trace debugging messages

00:36:59,819 --> 00:37:04,380
in here so we can illustrate what's

00:37:01,259 --> 00:37:08,099
happening so there's this function

00:37:04,380 --> 00:37:10,650
called self which does what is the

00:37:08,099 --> 00:37:14,190
process identifier of the program were

00:37:10,650 --> 00:37:17,160
running right now and we can use that so

00:37:14,190 --> 00:37:20,759
then we have our receive block which

00:37:17,160 --> 00:37:22,589
says okay wait basically block for a

00:37:20,759 --> 00:37:25,650
message when we receive a message try to

00:37:22,589 --> 00:37:27,809
do a pattern match on these outputs so

00:37:25,650 --> 00:37:29,039
the first one we could say if I'm

00:37:27,809 --> 00:37:31,289
literally sitting it with a call these

00:37:29,039 --> 00:37:34,710
atom which is a string that gets hash

00:37:31,289 --> 00:37:37,579
maps back to an integer so if it matches

00:37:34,710 --> 00:37:40,349
that just sent out this message and

00:37:37,579 --> 00:37:42,210
don't do anything else and but don't not

00:37:40,349 --> 00:37:44,549
doing anything else that means that this

00:37:42,210 --> 00:37:46,799
function is finished and when this

00:37:44,549 --> 00:37:48,420
function is finished that was a Z that

00:37:46,799 --> 00:37:52,140
was what this process was running so the

00:37:48,420 --> 00:37:55,789
process itself expires the other thing

00:37:52,140 --> 00:37:59,029
we could do is if I'm sent a tubal I

00:37:55,789 --> 00:38:02,700
think that just like tuples in Python

00:37:59,029 --> 00:38:05,069
where I want the two variables I want

00:38:02,700 --> 00:38:07,170
one of them will be the from address of

00:38:05,069 --> 00:38:09,920
the processes synthesia and another one

00:38:07,170 --> 00:38:12,269
will be so the generic word for

00:38:09,920 --> 00:38:15,239
variables and earliest terms these are

00:38:12,269 --> 00:38:16,529
Erling terms it send me something and

00:38:15,239 --> 00:38:20,400
I'm gonna send it back I'll do my I Oh

00:38:16,529 --> 00:38:22,229
format saying okay I got here does

00:38:20,400 --> 00:38:24,119
somebody send me a message this is the

00:38:22,229 --> 00:38:26,039
message we'll just print that out and

00:38:24,119 --> 00:38:29,609
then then will actually send it back to

00:38:26,039 --> 00:38:33,049
them so we'll take the process

00:38:29,609 --> 00:38:35,880
identifier of who sent to us we use the

00:38:33,049 --> 00:38:38,910
! operator and then we send back to them

00:38:35,880 --> 00:38:41,999
what they just sent us and then we're

00:38:38,910 --> 00:38:44,729
going to use the tail recursion to enter

00:38:41,999 --> 00:38:46,010
in this loop all over again so we repeat

00:38:44,729 --> 00:38:48,320
the process

00:38:46,010 --> 00:38:52,490
so it's effective like having a while

00:38:48,320 --> 00:38:53,630
forever loop but you would in other

00:38:52,490 --> 00:38:55,220
languages if you do this you would be

00:38:53,630 --> 00:38:57,020
you'll build accumulating stack forever

00:38:55,220 --> 00:38:59,450
but you're not and then we'll just have

00:38:57,020 --> 00:39:01,130
to catch all it says all right something

00:38:59,450 --> 00:39:05,660
in workout so let's actually try to run

00:39:01,130 --> 00:39:08,690
this see what happens real quick so we

00:39:05,660 --> 00:39:12,280
can go back start the start or two

00:39:08,690 --> 00:39:16,330
processes again it's our two two VMs and

00:39:12,280 --> 00:39:18,760
we can say we can demonstrate that self

00:39:16,330 --> 00:39:25,730
thing so that's our process identifier

00:39:18,760 --> 00:39:28,840
for WoW ok for ourselves so let's try to

00:39:25,730 --> 00:39:33,350
do quick so let's make a variable PID

00:39:28,840 --> 00:39:36,470
equal will do a spawn and we will say

00:39:33,350 --> 00:39:38,840
the name of the module and we will say

00:39:36,470 --> 00:39:44,270
the name of the function and will say

00:39:38,840 --> 00:39:46,970
the parameters and bam so what this is

00:39:44,270 --> 00:39:49,040
is this is the return value of the spawn

00:39:46,970 --> 00:39:51,500
command which is the PID of the new one

00:39:49,040 --> 00:39:53,930
and this is the message from inside

00:39:51,500 --> 00:39:55,970
there so we want to send it a message

00:39:53,930 --> 00:39:57,080
but you can say PID we're going to send

00:39:55,970 --> 00:40:02,180
you a message will give it something

00:39:57,080 --> 00:40:04,790
like hello and so what we see here was

00:40:02,180 --> 00:40:06,560
oh I called it wrong because what we're

00:40:04,790 --> 00:40:09,140
actually supposed to do is we were

00:40:06,560 --> 00:40:14,870
supposed to send it a tuple containing a

00:40:09,140 --> 00:40:17,780
payload and our process identifier for

00:40:14,870 --> 00:40:20,030
who we were calling it from so that

00:40:17,780 --> 00:40:22,090
should work so what we see here is this

00:40:20,030 --> 00:40:25,400
is the debug message from the program

00:40:22,090 --> 00:40:27,890
this is the return value for this

00:40:25,400 --> 00:40:31,520
function call which is going to be this

00:40:27,890 --> 00:40:33,110
tuple here and this is the debug value

00:40:31,520 --> 00:40:34,550
did it get to the top of the loop again

00:40:33,110 --> 00:40:35,870
so we said how where did the actual

00:40:34,550 --> 00:40:37,520
message go so you can use this to

00:40:35,870 --> 00:40:39,290
diagnose things or just play with things

00:40:37,520 --> 00:40:41,540
in the console uses think I'll flush and

00:40:39,290 --> 00:40:46,160
this shows the backlog of messages that

00:40:41,540 --> 00:40:47,960
are in my inbox message queue so that's

00:40:46,160 --> 00:40:50,660
what I guess okay so

00:40:47,960 --> 00:40:53,630
we have less time than I imagined we

00:40:50,660 --> 00:40:54,859
would so I will normally like we can

00:40:53,630 --> 00:41:01,280
heritage time so we'll get back to this

00:40:54,859 --> 00:41:02,450
and we'll come back all right now so if

00:41:01,280 --> 00:41:03,650
you're doing well what I was going to

00:41:02,450 --> 00:41:05,450
show you in that last demo but I raced

00:41:03,650 --> 00:41:06,950
through quickly was actually show do

00:41:05,450 --> 00:41:09,170
that that same exact operation between

00:41:06,950 --> 00:41:10,730
the two processes we can still come back

00:41:09,170 --> 00:41:12,290
do that but the point is that you're

00:41:10,730 --> 00:41:14,690
still ways of doing regular sockets

00:41:12,290 --> 00:41:16,460
programming there's ways of doing HTTP

00:41:14,690 --> 00:41:18,080
endpoints you don't have to you're not

00:41:16,460 --> 00:41:19,580
limited to just a distribution protocol

00:41:18,080 --> 00:41:22,520
but that is there's advantages their

00:41:19,580 --> 00:41:25,160
pros and cons for that to another

00:41:22,520 --> 00:41:27,440
concert makeup of closures this is

00:41:25,160 --> 00:41:29,060
another functional programming paradigm

00:41:27,440 --> 00:41:33,770
that you see in a lot of languages and

00:41:29,060 --> 00:41:35,510
basically the idea here is will say okay

00:41:33,770 --> 00:41:37,550
we can have another function will call

00:41:35,510 --> 00:41:40,940
us to take takes a function that you

00:41:37,550 --> 00:41:44,260
give the function as a parameter another

00:41:40,940 --> 00:41:46,430
function to run and then beyond that

00:41:44,260 --> 00:41:48,109
well which you can select like a

00:41:46,430 --> 00:41:50,720
function pointer but what's even cooler

00:41:48,109 --> 00:41:53,180
is that the functions that we can give

00:41:50,720 --> 00:41:55,430
it are these nested functions inside

00:41:53,180 --> 00:41:57,349
other functions that have scoped through

00:41:55,430 --> 00:42:00,619
local variables in the parent function

00:41:57,349 --> 00:42:03,800
so for example what is what happening is

00:42:00,619 --> 00:42:05,540
you call this thing and get an answer of

00:42:03,800 --> 00:42:06,980
17 I'll put these slides on the thing

00:42:05,540 --> 00:42:08,210
you can work to yourself but the way

00:42:06,980 --> 00:42:11,510
that would work is we end up here would

00:42:08,210 --> 00:42:12,950
say function of function we initial C

00:42:11,510 --> 00:42:13,970
value was five but then this local

00:42:12,950 --> 00:42:16,220
variable that we had in the entire time

00:42:13,970 --> 00:42:17,780
was one to the sides that's what I get

00:42:16,220 --> 00:42:20,030
17 so I was like a simplest example that

00:42:17,780 --> 00:42:22,490
come with and sorry to pick up the pace

00:42:20,030 --> 00:42:25,810
a little bit but we're trying to do and

00:42:22,490 --> 00:42:27,710
so if you look at like an analogy in a

00:42:25,810 --> 00:42:29,480
imperative programming language backe

00:42:27,710 --> 00:42:33,349
and see because again see rules the

00:42:29,480 --> 00:42:35,210
world this way God made it so you can

00:42:33,349 --> 00:42:36,890
look at this would just be the same

00:42:35,210 --> 00:42:39,140
thing with with function pointers now

00:42:36,890 --> 00:42:40,760
yes you can use a global variables but

00:42:39,140 --> 00:42:42,710
you don't want to do that so you end up

00:42:40,760 --> 00:42:45,140
doing it more modern style where you

00:42:42,710 --> 00:42:46,820
actually have a state for context that

00:42:45,140 --> 00:42:48,380
you have to pass around so you remember

00:42:46,820 --> 00:42:50,780
the same exact program here but now

00:42:48,380 --> 00:42:54,170
we're saying all right we manually are

00:42:50,780 --> 00:42:56,359
having to pass a state around a B we had

00:42:54,170 --> 00:42:58,210
the functions external to that so we can

00:42:56,359 --> 00:43:00,839
do it that's not quite the same thing

00:42:58,210 --> 00:43:03,960
but I should point out in the

00:43:00,839 --> 00:43:06,599
newer GCC stuff you can do exactly the

00:43:03,960 --> 00:43:12,359
same there is this concept in the GCC

00:43:06,599 --> 00:43:13,799
see gccc of nested functions so actually

00:43:12,359 --> 00:43:17,719
what I've got here is I've got a this is

00:43:13,799 --> 00:43:20,099
much cleaner and I've got this idea of a

00:43:17,719 --> 00:43:22,950
nessa for so this function the scope of

00:43:20,099 --> 00:43:26,130
this function can only be referenced

00:43:22,950 --> 00:43:28,170
with inside this function but yet inside

00:43:26,130 --> 00:43:30,359
this function we have access to other

00:43:28,170 --> 00:43:32,729
local variables outside of it so you can

00:43:30,359 --> 00:43:34,380
do the exact same problem that way so

00:43:32,729 --> 00:43:36,749
although that was just interesting

00:43:34,380 --> 00:43:37,680
interesting to me so there's a couple of

00:43:36,749 --> 00:43:39,900
their projects that are inching there's

00:43:37,680 --> 00:43:42,660
one called a lick sir which is a

00:43:39,900 --> 00:43:45,119
different language it's not erling that

00:43:42,660 --> 00:43:49,140
is compiled and runs on the Erlang

00:43:45,119 --> 00:43:50,660
runtime I have not personally used it it

00:43:49,140 --> 00:43:53,849
sounds exciting I think a lot of these

00:43:50,660 --> 00:43:56,969
same concepts we talked about they would

00:43:53,849 --> 00:43:59,960
map directly to that I think it's an

00:43:56,969 --> 00:44:03,630
attempt to use probably a nicer syntax

00:43:59,960 --> 00:44:04,769
I'm we know where I inherited a lot of

00:44:03,630 --> 00:44:06,059
airline code that's why I'm still

00:44:04,769 --> 00:44:09,410
learning that world but that's

00:44:06,059 --> 00:44:12,029
definitely take a look at another one is

00:44:09,410 --> 00:44:12,989
Earl Jang which is an example of doing

00:44:12,029 --> 00:44:17,119
the other way around we're going take

00:44:12,989 --> 00:44:17,119
the Erlang language and run another

00:44:49,370 --> 00:44:54,320
which is big this built on top of this

00:44:52,100 --> 00:44:56,960
language and these libraries and runtime

00:44:54,320 --> 00:45:01,150
is this framework for these generic ways

00:44:56,960 --> 00:45:03,290
that you would solve repeatable problems

00:45:01,150 --> 00:45:06,290
the one that we didn't talk about that

00:45:03,290 --> 00:45:08,480
it gives a huge benefit to using early

00:45:06,290 --> 00:45:09,590
in first place is this supervisory

00:45:08,480 --> 00:45:12,400
infrastructure so there's all these

00:45:09,590 --> 00:45:15,200
built-in language facilities we can say

00:45:12,400 --> 00:45:18,650
let me know whether or not this process

00:45:15,200 --> 00:45:20,450
is still alive and I can monitor that

00:45:18,650 --> 00:45:21,560
and then you can do your own low level

00:45:20,450 --> 00:45:23,960
logic but they've got all this other

00:45:21,560 --> 00:45:25,340
higher level logic where you can really

00:45:23,960 --> 00:45:27,770
quickly whip up these thinkers say if

00:45:25,340 --> 00:45:29,480
this ever dies restarted or if this ever

00:45:27,770 --> 00:45:31,820
dies kills this entire process tree and

00:45:29,480 --> 00:45:33,560
restart it or do any other combination

00:45:31,820 --> 00:45:39,260
of logic and you can build these highly

00:45:33,560 --> 00:45:44,330
sophisticated means of recovery failure

00:45:39,260 --> 00:45:47,210
recovery and an adaptive healing across

00:45:44,330 --> 00:45:49,220
numbers of machines so if there are

00:45:47,210 --> 00:45:51,350
there are applications where the only

00:45:49,220 --> 00:45:52,700
thing you do with Erlang is that and

00:45:51,350 --> 00:45:54,290
then you can actually call other coding

00:45:52,700 --> 00:45:56,300
languages for other word work if you

00:45:54,290 --> 00:45:57,920
wanted to it's actually that worthwhile

00:45:56,300 --> 00:46:01,490
to go to that trouble cool

00:45:57,920 --> 00:46:03,500
recommendations on the web this guy has

00:46:01,490 --> 00:46:05,570
his book for free and that's where I

00:46:03,500 --> 00:46:07,520
started going to learn you some Erlang

00:46:05,570 --> 00:46:09,860
com you can actually just you can buy

00:46:07,520 --> 00:46:13,370
the book but you just reading tythias

00:46:09,860 --> 00:46:14,900
website it's really cool a little bit of

00:46:13,370 --> 00:46:19,220
constructive criticism the target

00:46:14,900 --> 00:46:21,080
audience is probably newer to to some of

00:46:19,220 --> 00:46:22,520
these concepts in general so which is

00:46:21,080 --> 00:46:23,510
probably good if you're if you're

00:46:22,520 --> 00:46:25,750
depending where you're coming from but

00:46:23,510 --> 00:46:28,490
he goes into a lot of detail explaining

00:46:25,750 --> 00:46:31,870
some of these concepts a little this

00:46:28,490 --> 00:46:34,100
little wordy for me on the other hand if

00:46:31,870 --> 00:46:35,420
you've programmed for a long time and

00:46:34,100 --> 00:46:37,340
you're just looking for something a

00:46:35,420 --> 00:46:40,850
little more technical to just make it

00:46:37,340 --> 00:46:42,110
easier this one is this recently came

00:46:40,850 --> 00:46:44,930
out as a second ition this is one of the

00:46:42,110 --> 00:46:46,910
actual original authors of our language

00:46:44,930 --> 00:46:50,330
new project I would recommend this book

00:46:46,910 --> 00:46:52,330
I the ones I see the Erlang may enlist

00:46:50,330 --> 00:46:56,180
is definitely the way to go they

00:46:52,330 --> 00:46:59,000
cooperate with you and it's a small

00:46:56,180 --> 00:47:00,890
enough community that people look out

00:46:59,000 --> 00:47:02,109
for each other's interest and they want

00:47:00,890 --> 00:47:04,720
to try to promote their

00:47:02,109 --> 00:47:06,700
their brand name so to speak and and

00:47:04,720 --> 00:47:11,109
they what they're really friendly and

00:47:06,700 --> 00:47:13,200
answer definitely at least reading and

00:47:11,109 --> 00:47:16,329
they don't listen to play with it I also

00:47:13,200 --> 00:47:17,739
have put my own YouTube video on here

00:47:16,329 --> 00:47:20,170
from the early in factory if you would

00:47:17,739 --> 00:47:23,470
like even more geeking out about even

00:47:20,170 --> 00:47:25,630
more you know imaginative concepts with

00:47:23,470 --> 00:47:28,269
computers and and how the stuff

00:47:25,630 --> 00:47:31,859
interrelates with each other please go

00:47:28,269 --> 00:47:43,059
watch that if you know very interested

00:47:31,859 --> 00:47:44,019
so we've got an exercise you know how

00:47:43,059 --> 00:47:47,829
would you solve some of these problems

00:47:44,019 --> 00:47:48,970
and to imagine how well you can easily

00:47:47,829 --> 00:47:53,650
solve them and hurling these are kind of

00:47:48,970 --> 00:47:57,369
use cases so excuse me if you imagine

00:47:53,650 --> 00:48:00,880
the you know let's say we had a single

00:47:57,369 --> 00:48:03,940
integer maybe it's the the next unique

00:48:00,880 --> 00:48:06,849
number for something like that that we

00:48:03,940 --> 00:48:08,019
needed to keep this across the entire

00:48:06,849 --> 00:48:11,380
internet and actually make an

00:48:08,019 --> 00:48:12,700
authoritative source for this you can

00:48:11,380 --> 00:48:15,970
make that in anything that they then

00:48:12,700 --> 00:48:17,619
erling is you have most the problem

00:48:15,970 --> 00:48:19,210
solved already you can just work on the

00:48:17,619 --> 00:48:21,430
logic of how you want this to work how

00:48:19,210 --> 00:48:23,319
you want to do your elections when you

00:48:21,430 --> 00:48:25,150
have network splits and stuff like that

00:48:23,319 --> 00:48:26,950
you can just go straight to that logic

00:48:25,150 --> 00:48:29,109
instead of actually trying to code up

00:48:26,950 --> 00:48:31,089
all this networking code and all this

00:48:29,109 --> 00:48:32,710
failover coronal all the stuff which you

00:48:31,089 --> 00:48:35,380
can still do but I mean that's not a

00:48:32,710 --> 00:48:38,049
performance sensitive task at all just

00:48:35,380 --> 00:48:40,839
do that it's great Savior save your life

00:48:38,049 --> 00:48:42,220
you know in the 99 so you know when

00:48:40,839 --> 00:48:43,720
you're trying to make a system that

00:48:42,220 --> 00:48:46,749
really should stay up you know for the

00:48:43,720 --> 00:48:48,009
point nine nine nine nine how do you do

00:48:46,749 --> 00:48:52,509
that how do you actually make something

00:48:48,009 --> 00:48:53,829
does that the obviously Linux right but

00:48:52,509 --> 00:48:55,839
you know you need more than that evening

00:48:53,829 --> 00:48:59,109
your logic and your application code

00:48:55,839 --> 00:49:00,910
erling is that's where it's for I mean

00:48:59,109 --> 00:49:02,410
it's made for there was original problem

00:49:00,910 --> 00:49:05,739
trying to solve telecom systems that do

00:49:02,410 --> 00:49:08,739
not ever break and so another one that

00:49:05,739 --> 00:49:10,119
we use it for where work is we use it

00:49:08,739 --> 00:49:14,769
for a lot of things but let's say you've

00:49:10,119 --> 00:49:15,630
got just a web browser type at what you

00:49:14,769 --> 00:49:18,330
I

00:49:15,630 --> 00:49:20,700
and we want to hit our back-end restful

00:49:18,330 --> 00:49:24,660
endpoints are going to hit something and

00:49:20,700 --> 00:49:26,700
that needs to be able to do some work

00:49:24,660 --> 00:49:28,050
might be worked it takes a few seconds

00:49:26,700 --> 00:49:30,720
might be worked it takes let's say an

00:49:28,050 --> 00:49:31,890
hour or a few minutes and we might want

00:49:30,720 --> 00:49:32,970
to do some things we want to monitor

00:49:31,890 --> 00:49:34,110
that we want to have some kind of

00:49:32,970 --> 00:49:36,480
control over that when we go do some

00:49:34,110 --> 00:49:38,310
feedback with that I know that there's

00:49:36,480 --> 00:49:40,080
some I understand that there's some

00:49:38,310 --> 00:49:41,220
facilities and rails that let you do

00:49:40,080 --> 00:49:43,860
said let's say you wanted to do this

00:49:41,220 --> 00:49:45,570
with multiple nodes unless that you want

00:49:43,860 --> 00:49:49,230
to use you know some other

00:49:45,570 --> 00:49:52,430
infrastructure are lying and then the

00:49:49,230 --> 00:49:54,840
big one or a big one one of the big ones

00:49:52,430 --> 00:49:56,610
watch salt logic so we'd like we're just

00:49:54,840 --> 00:49:58,950
alluded to with the Supervisory

00:49:56,610 --> 00:50:00,480
infrastructure you know this concept is

00:49:58,950 --> 00:50:04,920
let's just say you want to have a

00:50:00,480 --> 00:50:07,130
program that stays up and running can be

00:50:04,920 --> 00:50:11,070
complicated a lot of little details

00:50:07,130 --> 00:50:16,770
systemd though pretty neat I would

00:50:11,070 --> 00:50:20,120
definitely okay so any system d is so

00:50:16,770 --> 00:50:22,110
when you so that's that was it to have a

00:50:20,120 --> 00:50:23,280
submerged themes here from this

00:50:22,110 --> 00:50:27,240
conference to me one of the ones that's

00:50:23,280 --> 00:50:30,090
so like a lot of the things that you

00:50:27,240 --> 00:50:33,060
would try to do with erling supervisory

00:50:30,090 --> 00:50:36,810
infrastructure are being done with

00:50:33,060 --> 00:50:38,370
system d and so not that you don't get

00:50:36,810 --> 00:50:39,930
is complicated logic i don't know i need

00:50:38,370 --> 00:50:44,670
to look at smart but that is if you're

00:50:39,930 --> 00:50:47,280
back to one machine or even you go to

00:50:44,670 --> 00:50:48,750
like coriolis and you can use multiple

00:50:47,280 --> 00:50:50,460
machines i think they have some rapper

00:50:48,750 --> 00:50:53,370
that's interesting so that's that would

00:50:50,460 --> 00:50:55,410
be a more modern approach if you're on

00:50:53,370 --> 00:50:56,880
linux so something to think about the

00:50:55,410 --> 00:50:59,970
man thing but so i can see they're just

00:50:56,880 --> 00:51:02,940
the disdain for systemd i was i was so

00:50:59,970 --> 00:51:04,440
anti systemd until recently and i'm

00:51:02,940 --> 00:51:07,920
really excited about trying it for some

00:51:04,440 --> 00:51:12,500
things actually anyway so comments

00:51:07,920 --> 00:51:12,500
questions yes

00:51:16,759 --> 00:51:25,339
yes that's true I forgot that's a given

00:51:31,530 --> 00:51:43,930
those are their excellent examples so

00:51:40,630 --> 00:51:46,090
the first comment was about CouchDB

00:51:43,930 --> 00:51:47,530
being an excellent another example of

00:51:46,090 --> 00:51:51,250
something cooler is built with Erlang

00:51:47,530 --> 00:51:54,070
and the other comment was the jabber d

00:51:51,250 --> 00:51:56,020
which was the free was originally

00:51:54,070 --> 00:51:58,750
written in it was it always an early i

00:51:56,020 --> 00:52:01,150
begin with oh okay it was always in

00:51:58,750 --> 00:52:05,020
Erlang i know that the that's another

00:52:01,150 --> 00:52:07,510
famous example and then the facebook

00:52:05,020 --> 00:52:09,070
chat server is always so it's your

00:52:07,510 --> 00:52:11,440
writing a chat server is like a fun

00:52:09,070 --> 00:52:13,030
exercise just to do i mean that's like

00:52:11,440 --> 00:52:14,230
you could be the second or third day

00:52:13,030 --> 00:52:16,300
you're playing with this you can make

00:52:14,230 --> 00:52:20,770
here in chat server it's just like I

00:52:16,300 --> 00:52:22,180
mean it's for academic teaching or just

00:52:20,770 --> 00:52:25,080
experimenting or learning or playing

00:52:22,180 --> 00:52:27,310
around this is fun I mean this is like a

00:52:25,080 --> 00:52:29,530
chemistry set that you can just blow

00:52:27,310 --> 00:52:32,470
stuff up with it's fun it's a really fun

00:52:29,530 --> 00:52:35,080
thing I mean if I wish a long long time

00:52:32,470 --> 00:52:37,330
ago when I was learning to do sockets

00:52:35,080 --> 00:52:38,770
some of the stuff the hard way if I'd

00:52:37,330 --> 00:52:44,350
had this I probably would never even I

00:52:38,770 --> 00:52:47,640
learned it would spoiled me so anyway ok

00:52:44,350 --> 00:52:47,640
any other yes

00:52:56,470 --> 00:53:09,080
yes so so the question is about

00:53:06,400 --> 00:53:13,100
distributed Erlang applications to an

00:53:09,080 --> 00:53:15,050
end customer so that has not been one of

00:53:13,100 --> 00:53:18,050
the strong spots and so some of these

00:53:15,050 --> 00:53:18,980
other things we talked about like react

00:53:18,050 --> 00:53:22,250
for example that's one of the problems

00:53:18,980 --> 00:53:25,850
you get into is how do I make this work

00:53:22,250 --> 00:53:29,360
it's actually solvable in a few ways one

00:53:25,850 --> 00:53:31,460
of them is just try to make your code

00:53:29,360 --> 00:53:34,670
work well enough to where you can use

00:53:31,460 --> 00:53:37,700
use your linux distributions packages of

00:53:34,670 --> 00:53:38,750
it and her lying itself and then just

00:53:37,700 --> 00:53:40,640
try to make it work with the different

00:53:38,750 --> 00:53:42,770
ones there's limited reasons to actually

00:53:40,640 --> 00:53:44,660
make it work on specific versions of

00:53:42,770 --> 00:53:46,730
erling that's a that would just be in

00:53:44,660 --> 00:53:48,910
general but there's this facility they

00:53:46,730 --> 00:53:51,620
called a release facility so you can

00:53:48,910 --> 00:53:53,930
using that OTP framework where you can

00:53:51,620 --> 00:53:56,480
make these text files to sort of explain

00:53:53,930 --> 00:53:58,490
what the dependencies are that you're in

00:53:56,480 --> 00:54:00,620
your early application you run through

00:53:58,490 --> 00:54:03,110
this procedure and it creates what's

00:54:00,620 --> 00:54:04,790
called a boot scrip and some other

00:54:03,110 --> 00:54:06,050
things and so you can act it will you go

00:54:04,790 --> 00:54:08,510
through and actually can make a

00:54:06,050 --> 00:54:11,090
directory with everything you need in it

00:54:08,510 --> 00:54:15,520
all the Erling dependencies and it is it

00:54:11,090 --> 00:54:18,320
is redeploy about in that sense but then

00:54:15,520 --> 00:54:21,050
if you're actually talking about I have

00:54:18,320 --> 00:54:22,010
a customer and there you know I've

00:54:21,050 --> 00:54:24,050
written something for him that I would

00:54:22,010 --> 00:54:25,340
deploy it at this point in time I would

00:54:24,050 --> 00:54:27,770
I would take seriously take a look at

00:54:25,340 --> 00:54:29,270
some of these more cutting-edge setting

00:54:27,770 --> 00:54:32,000
out like delivery technologies like a

00:54:29,270 --> 00:54:33,260
docker or a container of something like

00:54:32,000 --> 00:54:35,630
that I mean I think that if you're

00:54:33,260 --> 00:54:37,910
delivering you're finished in result

00:54:35,630 --> 00:54:39,080
binary i would i would investigate so

00:54:37,910 --> 00:54:40,460
these are some just visitors with

00:54:39,080 --> 00:54:42,560
anything in general these are some kind

00:54:40,460 --> 00:54:45,290
of new ways of looking at things but if

00:54:42,560 --> 00:54:46,820
you're like not I've made it more

00:54:45,290 --> 00:54:51,860
complex but I actually think that would

00:54:46,820 --> 00:54:54,020
simplify X no no no stack linking is the

00:54:51,860 --> 00:54:56,800
devil's where you know don't have her no

00:54:54,020 --> 00:55:00,020
static linking no one ever wants to

00:54:56,800 --> 00:55:02,290
there is no foolproof there's there's no

00:55:00,020 --> 00:55:05,620
foolproof and static linking is

00:55:02,290 --> 00:55:05,620
deceptive you know

00:55:06,000 --> 00:55:12,640
yes for example so like yeah yeah that

00:55:10,780 --> 00:55:15,970
hits close to home you know that's just

00:55:12,640 --> 00:55:19,839
one so but you know the containerized

00:55:15,970 --> 00:55:21,160
deployment approach in a sense is still

00:55:19,839 --> 00:55:23,440
gives you those restrictions of static

00:55:21,160 --> 00:55:27,880
linking so you still need to do updates

00:55:23,440 --> 00:55:29,680
but as far as I don't know it's five

00:55:27,880 --> 00:55:31,450
those in a situation today where I was

00:55:29,680 --> 00:55:33,130
actually deploying like a finished

00:55:31,450 --> 00:55:35,140
binary to the customer i would i would

00:55:33,130 --> 00:55:36,849
find some way to deliver it as that

00:55:35,140 --> 00:55:39,160
because there's just there's just too

00:55:36,849 --> 00:55:40,450
many things you don't control and if you

00:55:39,160 --> 00:55:42,490
want something like idiot-proof that

00:55:40,450 --> 00:55:45,069
would either just a vm even at that

00:55:42,490 --> 00:55:46,420
point but you know if you have more

00:55:45,069 --> 00:55:48,059
technical customer and they actually

00:55:46,420 --> 00:55:50,829
you're delivering them source code

00:55:48,059 --> 00:55:52,510
that's different didn't you two solution

00:55:50,829 --> 00:55:54,940
is you deliver them source code that's

00:55:52,510 --> 00:55:57,960
the whole point there that one the best

00:55:54,940 --> 00:55:57,960
answer but yes

00:56:04,060 --> 00:56:08,200
plus no space that's like

00:56:12,589 --> 00:56:19,259
extra precautious party nomination

00:56:17,819 --> 00:56:20,729
if you do that that means that when you

00:56:19,259 --> 00:56:22,769
actually employ upgrades to your

00:56:20,729 --> 00:56:26,959
customer they don't have to stop restart

00:56:22,769 --> 00:56:26,959
the service they just say you version

00:56:27,120 --> 00:56:35,040
yeah so the comment was there is this

00:56:32,280 --> 00:56:39,170
other external tool called rebar which

00:56:35,040 --> 00:56:43,170
is a general purpose erling build system

00:56:39,170 --> 00:56:45,480
which does several things for you one of

00:56:43,170 --> 00:56:48,030
which is allows you to have erling build

00:56:45,480 --> 00:56:49,440
system another one is that it is a

00:56:48,030 --> 00:56:51,000
wrapper around that release

00:56:49,440 --> 00:56:53,190
infrastructure we're talking about where

00:56:51,000 --> 00:56:56,130
it lets you distribute things with all

00:56:53,190 --> 00:56:57,150
the all the dependencies with it and the

00:56:56,130 --> 00:56:58,440
other one to let you do is there's other

00:56:57,150 --> 00:57:02,010
feature we didn't talk about erling has

00:56:58,440 --> 00:57:03,210
we can do hot code loading so you can

00:57:02,010 --> 00:57:06,210
actually set things up in such a way to

00:57:03,210 --> 00:57:08,460
where you say excuse me similar the way

00:57:06,210 --> 00:57:10,680
you would do with a kernel module

00:57:08,460 --> 00:57:12,630
loading I'm actually our we have a piece

00:57:10,680 --> 00:57:14,940
of code that's in use it's live and I'd

00:57:12,630 --> 00:57:17,280
like to send an updated version of that

00:57:14,940 --> 00:57:20,340
code in line and as soon as all the

00:57:17,280 --> 00:57:23,010
older users of that no longer using it

00:57:20,340 --> 00:57:26,760
it just goes away but all the new users

00:57:23,010 --> 00:57:28,920
new requests go to the new code and to

00:57:26,760 --> 00:57:31,650
do that it is possible you have to

00:57:28,920 --> 00:57:33,360
obviously make the logic of the program

00:57:31,650 --> 00:57:35,670
code itself still work which is the

00:57:33,360 --> 00:57:38,580
hardest part but other than that there's

00:57:35,670 --> 00:57:41,460
some procedures yet file and the rebar

00:57:38,580 --> 00:57:51,180
infrastructure facilitates doing that

00:57:41,460 --> 00:57:55,890
easier all right well I'm won't you so

00:57:51,180 --> 00:57:57,840
yes so there have been at least two kima

00:57:55,890 --> 00:57:59,520
I'm not the world's biggest Erlang

00:57:57,840 --> 00:58:03,690
historical expert because I've been on

00:57:59,520 --> 00:58:05,340
this for about 10 months now is what did

00:58:03,690 --> 00:58:07,440
you ask me oh yeah native cotu to

00:58:05,340 --> 00:58:12,060
actually take our lane code and compile

00:58:07,440 --> 00:58:13,470
that into into a native machine code and

00:58:12,060 --> 00:58:15,030
those efforts have actually been

00:58:13,470 --> 00:58:16,470
abandoned in this fardling tell they're

00:58:15,030 --> 00:58:17,880
still sort of there there was another

00:58:16,470 --> 00:58:20,640
one one of them was just more of

00:58:17,880 --> 00:58:22,380
just-in-time compilation where we still

00:58:20,640 --> 00:58:23,610
have that excellent code is still there

00:58:22,380 --> 00:58:26,250
I don't believe it actually gets used

00:58:23,610 --> 00:58:30,150
it's kind of a side discussion on wide

00:58:26,250 --> 00:58:35,790
just-in-time compilation as a school of

00:58:30,150 --> 00:58:41,370
thought I think is played out but you

00:58:35,790 --> 00:58:43,050
know the the beam stuff is very fast if

00:58:41,370 --> 00:58:45,840
you need something faster just go to

00:58:43,050 --> 00:58:49,980
regular see you know I mean at that

00:58:45,840 --> 00:58:52,380
point use the right tool for the job so

00:58:49,980 --> 00:58:53,760
there is no such thing that's like this

00:58:52,380 --> 00:58:57,110
is the thing that solves every problem

00:58:53,760 --> 00:59:00,270
all the time anybody tells you that is

00:58:57,110 --> 00:59:02,550
ignorant okay now there are ways that

00:59:00,270 --> 00:59:05,190
you can do stuff all the time but it's

00:59:02,550 --> 00:59:12,860
suboptimal or its quickest trade-offs

00:59:05,190 --> 00:59:12,860
yes good that's just one example yeah

00:59:15,990 --> 00:59:21,160
and such a way that your C code fails

00:59:18,940 --> 00:59:25,530
that it past summer subscribe to their

00:59:21,160 --> 00:59:25,530
lab supervisor solutrean

00:59:28,510 --> 00:59:36,170
yes so the so the comment was that

00:59:32,230 --> 00:59:38,240
number one that and you can use you can

00:59:36,170 --> 00:59:39,590
you can interact with Erlang in all

00:59:38,240 --> 00:59:42,440
these other languages almost any other

00:59:39,590 --> 00:59:44,480
language in many different ways one way

00:59:42,440 --> 00:59:45,620
like said was using the distribution

00:59:44,480 --> 00:59:47,720
protocol natively there's other ways we

00:59:45,620 --> 00:59:50,210
can just spawn other processes and route

00:59:47,720 --> 00:59:53,030
them to ports and stuff but in a case of

00:59:50,210 --> 00:59:54,320
C code for example that's actually at

00:59:53,030 --> 00:59:57,140
our office that's one things we have now

00:59:54,320 --> 01:00:00,050
so we have you can put C code in process

00:59:57,140 --> 01:00:02,150
with a r1 then in process with the with

01:00:00,050 --> 01:00:03,140
the beam and there's some efficiency to

01:00:02,150 --> 01:00:05,150
be gained because you want to copy

01:00:03,140 --> 01:00:06,230
messages on the other hand if you crash

01:00:05,150 --> 01:00:07,280
or anything you bring down the whole

01:00:06,230 --> 01:00:10,220
beam and that's part of the reason why

01:00:07,280 --> 01:00:12,400
you want erling is for the rock solid so

01:00:10,220 --> 01:00:14,630
you can take you make your C program

01:00:12,400 --> 01:00:16,730
separate process to the side and you can

01:00:14,630 --> 01:00:18,770
still use these monitoring facilities to

01:00:16,730 --> 01:00:20,990
where if your su programa crashes the

01:00:18,770 --> 01:00:23,390
Erlang supervisory logic is well aware

01:00:20,990 --> 01:00:27,320
of that and you can act accordingly and

01:00:23,390 --> 01:00:30,140
so it is very well designed with that

01:00:27,320 --> 01:00:31,970
the intention that you are going to be

01:00:30,140 --> 01:00:34,070
probably using heterogeneous technology

01:00:31,970 --> 01:00:36,080
it does a very good job of gluing these

01:00:34,070 --> 01:00:38,450
is a good glue language it blues these

01:00:36,080 --> 01:00:40,730
things together very well so I think

01:00:38,450 --> 01:00:42,050
we're out of time and I will be here for

01:00:40,730 --> 01:00:45,440
a little bit before I have to run to the

01:00:42,050 --> 01:00:46,760
airport but thank you very much for your

01:00:45,440 --> 01:00:48,470
attention and for coming out this early

01:00:46,760 --> 01:00:58,220
time slot and take your sponsors and

01:00:48,470 --> 01:00:59,960
everyone else thank you so much your

01:00:58,220 --> 01:01:01,490
customers rely on your website or

01:00:59,960 --> 01:01:03,860
application if it's slower

01:01:01,490 --> 01:01:06,830
non-responsive it infuriates your users

01:01:03,860 --> 01:01:08,630
and costs you money keeping your

01:01:06,830 --> 01:01:12,150
business critical systems humming along

01:01:08,630 --> 01:01:14,460
requires insight into what they're doing

01:01:12,150 --> 01:01:16,410
your system metrics tells stories

01:01:14,460 --> 01:01:18,420
stories that can reveal performance

01:01:16,410 --> 01:01:20,760
bottlenecks resource limitations and

01:01:18,420 --> 01:01:22,319
other problems but how do you keep an

01:01:20,760 --> 01:01:24,960
eye on all of your systems performance

01:01:22,319 --> 01:01:27,990
metrics in real-time and record this

01:01:24,960 --> 01:01:29,760
data for later analysis enter longview

01:01:27,990 --> 01:01:31,770
the new way to see what's really going

01:01:29,760 --> 01:01:33,930
on under the hood the long view

01:01:31,770 --> 01:01:36,000
dashboard lets you visualize the status

01:01:33,930 --> 01:01:38,460
of all your systems providing you with a

01:01:36,000 --> 01:01:41,819
bird's-eye view of your entire fleet you

01:01:38,460 --> 01:01:44,400
can sort by cpu memory swap processes

01:01:41,819 --> 01:01:46,170
load and network usage click a specific

01:01:44,400 --> 01:01:48,569
system to access its individual

01:01:46,170 --> 01:01:51,079
dashboard then click and drag to zoom in

01:01:48,569 --> 01:01:53,490
on chokepoints and get more detail

01:01:51,079 --> 01:01:55,170
comprehensive network data including

01:01:53,490 --> 01:01:57,480
inbound and outbound traffic is

01:01:55,170 --> 01:01:59,430
available on the network tab and disk

01:01:57,480 --> 01:02:01,589
rights and free space on the disks tab

01:01:59,430 --> 01:02:03,809
while the process Explorer displays

01:02:01,589 --> 01:02:06,329
usage statistics for individual

01:02:03,809 --> 01:02:08,490
processes the system info tab shows

01:02:06,329 --> 01:02:10,740
listening services active connections

01:02:08,490 --> 01:02:12,869
and available updates adding long view

01:02:10,740 --> 01:02:14,579
to a system is easy just click the

01:02:12,869 --> 01:02:16,710
button copy the one line installation

01:02:14,579 --> 01:02:19,170
command then run the command on your

01:02:16,710 --> 01:02:20,849
linux system to complete the process the

01:02:19,170 --> 01:02:23,039
agent will begin collecting data and

01:02:20,849 --> 01:02:24,890
sending it to longview then the graph

01:02:23,039 --> 01:02:27,470
start rolling

01:02:24,890 --> 01:02:29,840
use longview to gain visibility into

01:02:27,470 --> 01:02:33,550
your servers so when your website or app

01:02:29,840 --> 01:02:33,550

YouTube URL: https://www.youtube.com/watch?v=2EchMyc7Y74


