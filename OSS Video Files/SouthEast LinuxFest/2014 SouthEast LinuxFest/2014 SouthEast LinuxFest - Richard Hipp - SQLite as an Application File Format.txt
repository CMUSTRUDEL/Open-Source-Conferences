Title: 2014 SouthEast LinuxFest - Richard Hipp - SQLite as an Application File Format
Publication date: 2015-05-18
Playlist: 2014 SouthEast LinuxFest
Description: 
	2014 SouthEast LinuxFest
Richard Hipp
SQLite as an Application File Format
Captions: 
	00:00:00,060 --> 00:00:05,339
the following presentation was recorded

00:00:02,490 --> 00:00:08,189
the 2014 southeast linux fest in

00:00:05,339 --> 00:00:10,320
charlotte north carolina it is licensed

00:00:08,189 --> 00:00:15,890
under a Creative Commons license

00:00:10,320 --> 00:00:18,480
for more information visit www.mchcp.org

00:00:15,890 --> 00:00:20,750
the south east linux fest would like to

00:00:18,480 --> 00:00:23,189
thank the following diamond sponsors in

00:00:20,750 --> 00:00:25,740
2014 for helping make these videos

00:00:23,189 --> 00:00:27,980
possible can everybody hear me great

00:00:25,740 --> 00:00:30,990
thanks for coming on name is Richard hip

00:00:27,980 --> 00:00:32,160
this is a talk for developers I hope

00:00:30,990 --> 00:00:33,329
you're all developers if you're not

00:00:32,160 --> 00:00:35,489
developers that's okay you're welcome to

00:00:33,329 --> 00:00:39,450
stay but just to talk about programmers

00:00:35,489 --> 00:00:42,030
or talk targeting programmers like me I

00:00:39,450 --> 00:00:45,030
wanted to talk a little bit about SG on

00:00:42,030 --> 00:00:47,280
today I want to talk about how you ought

00:00:45,030 --> 00:00:50,090
to be using how and why you ought to be

00:00:47,280 --> 00:00:52,379
using SQLite in your applications and

00:00:50,090 --> 00:00:54,390
but I also want to clear up some

00:00:52,379 --> 00:00:57,840
misconceptions I you know when I talk to

00:00:54,390 --> 00:01:00,359
people and listen to people a lot of

00:00:57,840 --> 00:01:04,229
people really don't get what SQLite is

00:01:00,359 --> 00:01:05,610
about they they try and use it in their

00:01:04,229 --> 00:01:07,770
application but they use it in ways that

00:01:05,610 --> 00:01:13,020
it was never really intended to be used

00:01:07,770 --> 00:01:14,790
and and then they complain about it they

00:01:13,020 --> 00:01:16,290
criticize SQLite well it's not solving

00:01:14,790 --> 00:01:18,810
my problem even though the problem was

00:01:16,290 --> 00:01:21,330
not one that SQLite was ever intended to

00:01:18,810 --> 00:01:22,710
solve but they try and deploy it anyway

00:01:21,330 --> 00:01:24,869
and it doesn't work out as well as

00:01:22,710 --> 00:01:27,210
they'd hoped it would and they're bummed

00:01:24,869 --> 00:01:28,740
about that so I wanted to really spend a

00:01:27,210 --> 00:01:30,360
lot of time talking about what sq of the

00:01:28,740 --> 00:01:31,950
problem that SQLite is trying to solve

00:01:30,360 --> 00:01:33,450
and how it's very different from a lot

00:01:31,950 --> 00:01:35,610
of other database engines now if you're

00:01:33,450 --> 00:01:37,310
not even familiar with what SQLite is

00:01:35,610 --> 00:01:40,920
I'll give you a brief introduction

00:01:37,310 --> 00:01:44,549
SQLite is an SQL database engine there

00:01:40,920 --> 00:01:46,710
are a lot of these out there we're

00:01:44,549 --> 00:01:51,210
you're probably familiar with MySQL

00:01:46,710 --> 00:01:52,200
Postgres imma ride to the sequel server

00:01:51,210 --> 00:01:54,960
these sorts of things

00:01:52,200 --> 00:01:56,430
ask your lights among these but it's

00:01:54,960 --> 00:01:58,439
fundamentally different from the others

00:01:56,430 --> 00:02:02,729
and and that's what I want to kind of

00:01:58,439 --> 00:02:05,850
get into SQLite is an embedded database

00:02:02,729 --> 00:02:07,590
engine whereas mostly this is our client

00:02:05,850 --> 00:02:09,210
server database engines you've got a

00:02:07,590 --> 00:02:12,150
separate server that's in a different

00:02:09,210 --> 00:02:15,380
Sheen esculent embedded it's a library

00:02:12,150 --> 00:02:18,570
that links with your application and

00:02:15,380 --> 00:02:21,270
writes directly to the disk and it's and

00:02:18,570 --> 00:02:23,880
used in a lot of applications that

00:02:21,270 --> 00:02:25,530
you're using every day for example your

00:02:23,880 --> 00:02:29,520
web browser is probably storing

00:02:25,530 --> 00:02:31,830
bookmarks in an SQLite database your

00:02:29,520 --> 00:02:33,140
your playlists are stored in an SQLite

00:02:31,830 --> 00:02:35,760
database

00:02:33,140 --> 00:02:39,020
you know everybody your call history on

00:02:35,760 --> 00:02:44,240
skype is stored in an SQLite database

00:02:39,020 --> 00:02:46,800
etc etc Excel uses X SQLite databases

00:02:44,240 --> 00:02:49,650
it's also used in a lot of gadgets

00:02:46,800 --> 00:02:51,450
because it's small and lightweight so

00:02:49,650 --> 00:02:52,680
everybody's cell phone and we learned in

00:02:51,450 --> 00:02:54,900
the last lecture that everybody here has

00:02:52,680 --> 00:02:56,940
a cell phone right a smart phone all

00:02:54,900 --> 00:03:03,110
your smart phone data is stored in an

00:02:56,940 --> 00:03:05,910
SQLite database your contact lists your

00:03:03,110 --> 00:03:07,350
you know any all your call history and

00:03:05,910 --> 00:03:09,570
all of that it's it's really interesting

00:03:07,350 --> 00:03:12,600
I'm just referencing the preview the

00:03:09,570 --> 00:03:14,130
keynote we get inquiries a lot and

00:03:12,600 --> 00:03:16,650
there's actually a lot of courses out

00:03:14,130 --> 00:03:20,430
there where you can take on forensics

00:03:16,650 --> 00:03:22,950
and how to decode SQLite database files

00:03:20,430 --> 00:03:26,430
at a byte level so that they can pull

00:03:22,950 --> 00:03:28,440
out you know your your browse history

00:03:26,430 --> 00:03:31,350
we've actually been contacted by police

00:03:28,440 --> 00:03:33,450
agencies trying to decode the Browse

00:03:31,350 --> 00:03:35,370
histories out of out of web browsers

00:03:33,450 --> 00:03:38,880
that were stored in SQLite databases and

00:03:35,370 --> 00:03:41,690
so forth so SQLite is used in a lot of

00:03:38,880 --> 00:03:44,790
places like this now it is open source I

00:03:41,690 --> 00:03:47,430
it's in the public domain actually so we

00:03:44,790 --> 00:03:48,570
don't really know how many places SQL

00:03:47,430 --> 00:03:50,850
that's being used because anybody can

00:03:48,570 --> 00:03:54,870
download and use it for free but by

00:03:50,850 --> 00:03:57,510
counting up the number of applications

00:03:54,870 --> 00:04:00,150
that use SQLite or the or the places

00:03:57,510 --> 00:04:01,950
that we just know about and how many

00:04:00,150 --> 00:04:04,950
places are uses we estimate that there's

00:04:01,950 --> 00:04:08,180
over two billion running instances of

00:04:04,950 --> 00:04:10,910
SQLite right now and it's used in over

00:04:08,180 --> 00:04:13,890
500,000 different applications

00:04:10,910 --> 00:04:15,500
most of those are smartphone apps but

00:04:13,890 --> 00:04:18,840
it's also used in other things as well

00:04:15,500 --> 00:04:20,760
we're used in big things too SQLite is

00:04:18,840 --> 00:04:27,300
in the avionics on

00:04:20,760 --> 00:04:30,510
the new a350 that airbus a350 it's used

00:04:27,300 --> 00:04:33,900
in some big companies to run big things

00:04:30,510 --> 00:04:35,880
but it's usually in gadgets so the what

00:04:33,900 --> 00:04:38,310
I want to talk about today is to make a

00:04:35,880 --> 00:04:40,020
distinction here and to talk about how

00:04:38,310 --> 00:04:42,510
SQLite is different many others its

00:04:40,020 --> 00:04:45,840
distinguish between an enterprise data

00:04:42,510 --> 00:04:47,460
Depot versus an application file format

00:04:45,840 --> 00:04:50,910
a lot of people they say they hear

00:04:47,460 --> 00:04:54,680
SQLite is SQL their their their brain

00:04:50,910 --> 00:04:57,210
immediately connects SQL with big data

00:04:54,680 --> 00:04:58,710
because all of your life anytime you're

00:04:57,210 --> 00:05:01,260
dealing with an SQL database you're

00:04:58,710 --> 00:05:06,240
dealing large quantities of data and the

00:05:01,260 --> 00:05:08,520
SQL database is concerned with being an

00:05:06,240 --> 00:05:10,590
enterprise data Depot now what what do I

00:05:08,520 --> 00:05:14,130
mean about the difference here the

00:05:10,590 --> 00:05:15,990
cursor out of the way the an enterprise

00:05:14,130 --> 00:05:19,560
data Depot is the big central repository

00:05:15,990 --> 00:05:21,000
for data in in your application it's

00:05:19,560 --> 00:05:23,190
it's typically remote from the

00:05:21,000 --> 00:05:27,440
application itself whereas an

00:05:23,190 --> 00:05:30,420
application file format it's it's local

00:05:27,440 --> 00:05:32,880
an enterprise data eto stores the

00:05:30,420 --> 00:05:34,620
information that's global the entire

00:05:32,880 --> 00:05:36,870
enterprise has access to it whereas an

00:05:34,620 --> 00:05:38,430
application form file format stores

00:05:36,870 --> 00:05:41,670
information that's private to the

00:05:38,430 --> 00:05:46,620
particular application if you're drawing

00:05:41,670 --> 00:05:49,920
pictures of your topology or your system

00:05:46,620 --> 00:05:52,020
you tend to with the the ant enterprise

00:05:49,920 --> 00:05:54,540
data Depot you make a cloud and that's

00:05:52,020 --> 00:05:57,360
where the data goes whereas in an

00:05:54,540 --> 00:06:04,680
application for file format the data is

00:05:57,360 --> 00:06:08,580
a document the an application format

00:06:04,680 --> 00:06:10,620
file format is is separate distribute

00:06:08,580 --> 00:06:16,590
amongst all your devices whereas an

00:06:10,620 --> 00:06:18,510
enterprise data Depot is centralized so

00:06:16,590 --> 00:06:21,470
application for file formats are kind of

00:06:18,510 --> 00:06:26,820
different from the enterprise data Depot

00:06:21,470 --> 00:06:29,250
an application file it stores a complete

00:06:26,820 --> 00:06:31,350
bit of information about stand alone in

00:06:29,250 --> 00:06:33,030
information we use the document metaphor

00:06:31,350 --> 00:06:37,170
for that anything that could be a doc

00:06:33,030 --> 00:06:39,150
it might be an application file it could

00:06:37,170 --> 00:06:41,220
not have a complex internal structure

00:06:39,150 --> 00:06:44,160
and it might mix text and images and so

00:06:41,220 --> 00:06:47,180
forth but it's a document as opposed to

00:06:44,160 --> 00:06:50,760
the cloud and sometimes people store

00:06:47,180 --> 00:06:52,230
documents as a single entry in your

00:06:50,760 --> 00:06:54,330
enterprise database in fact we have a

00:06:52,230 --> 00:06:58,920
whole class of database engines you know

00:06:54,330 --> 00:07:00,960
document databases MongoDB sometimes

00:06:58,920 --> 00:07:02,520
people will take a document and they'll

00:07:00,960 --> 00:07:04,080
tear it all apart and extract the

00:07:02,520 --> 00:07:06,360
individual pieces of information and

00:07:04,080 --> 00:07:08,880
then store it in their enterprise data

00:07:06,360 --> 00:07:10,830
Depot as fields scattered all over the

00:07:08,880 --> 00:07:13,080
place or other times you'll have a

00:07:10,830 --> 00:07:14,580
massive to enterprise database which say

00:07:13,080 --> 00:07:16,290
maybe it has all the sales history from

00:07:14,580 --> 00:07:19,170
the entire data in or for your entire

00:07:16,290 --> 00:07:22,260
enterprise and you want to extract a

00:07:19,170 --> 00:07:23,520
document from that which is just the

00:07:22,260 --> 00:07:26,580
sales information for a particular

00:07:23,520 --> 00:07:28,560
customer you might pull out a slice so

00:07:26,580 --> 00:07:31,050
there is some intermingling between the

00:07:28,560 --> 00:07:32,940
ideas of an application file and an

00:07:31,050 --> 00:07:36,960
enterprise data Depot but they're really

00:07:32,940 --> 00:07:40,200
very distinct so here's some examples of

00:07:36,960 --> 00:07:42,270
application files a presentation this uh

00:07:40,200 --> 00:07:44,580
you know what I'm presenting to you here

00:07:42,270 --> 00:07:47,520
it's a it's a document on my desktop and

00:07:44,580 --> 00:07:49,860
it it that's an application a

00:07:47,520 --> 00:07:51,900
spreadsheet if you're in a laboratory

00:07:49,860 --> 00:07:53,400
environment you might be running

00:07:51,900 --> 00:07:57,990
experiments and collecting the data

00:07:53,400 --> 00:08:00,330
there and then as the data is you know

00:07:57,990 --> 00:08:02,280
analyzed by members of your team you

00:08:00,330 --> 00:08:04,380
know they'll add annotations to the data

00:08:02,280 --> 00:08:07,250
and so forth and itinerary an expense

00:08:04,380 --> 00:08:09,810
report a quality assurance report

00:08:07,250 --> 00:08:13,040
financial model shipping manifests and

00:08:09,810 --> 00:08:15,570
so configuration files an e-book a

00:08:13,040 --> 00:08:18,510
flight plan not necessarily a flight

00:08:15,570 --> 00:08:21,830
plan for a an airliner but maybe this is

00:08:18,510 --> 00:08:24,000
a flight plan that you upload to your

00:08:21,830 --> 00:08:26,640
quadcopter and you know which is going

00:08:24,000 --> 00:08:30,200
to fly over Allen Hicks's house and take

00:08:26,640 --> 00:08:32,970
pictures or something I don't know they

00:08:30,200 --> 00:08:37,590
so all of these things are examples of

00:08:32,970 --> 00:08:39,120
application files and installer and the

00:08:37,590 --> 00:08:42,450
key thing that I wanted to point out

00:08:39,120 --> 00:08:44,460
here is that the whole point of this

00:08:42,450 --> 00:08:46,290
lecture is to say that

00:08:44,460 --> 00:08:48,480
whereas the other database engines are

00:08:46,290 --> 00:08:52,350
really trying to be an enterprise data

00:08:48,480 --> 00:08:54,450
Depot SQLite wants to be an application

00:08:52,350 --> 00:08:58,380
file format it's a completely it's

00:08:54,450 --> 00:08:59,760
solving a completely different problem

00:08:58,380 --> 00:09:00,870
that's your lights not trying to replace

00:08:59,760 --> 00:09:02,730
these of the guys it's not trying to

00:09:00,870 --> 00:09:05,820
read compete with them SQLite is trying

00:09:02,730 --> 00:09:08,640
to compete with F open now I'm using F

00:09:05,820 --> 00:09:11,190
open here as a metaphor you know I do a

00:09:08,640 --> 00:09:14,070
lot of programming at C F open and C of

00:09:11,190 --> 00:09:16,560
course is the function call you use to

00:09:14,070 --> 00:09:17,850
open a file on the disk because that you

00:09:16,560 --> 00:09:21,420
can just start reading and writing from

00:09:17,850 --> 00:09:23,820
it now in your language of choice that

00:09:21,420 --> 00:09:25,410
might be a different routine but I'm

00:09:23,820 --> 00:09:27,090
going to use F open because that's what

00:09:25,410 --> 00:09:28,860
I'm comfortable with so SQLite is really

00:09:27,090 --> 00:09:35,700
a replacement for F open it's not a

00:09:28,860 --> 00:09:38,900
replacement for MySQL or Postgres just

00:09:35,700 --> 00:09:38,900
to drill this home a little bit further

00:09:39,710 --> 00:09:42,930
suppose you're making a desktop

00:09:41,970 --> 00:09:44,490
application it'll be any type of

00:09:42,930 --> 00:09:47,070
application really but here's a desktop

00:09:44,490 --> 00:09:49,700
application and typically you know

00:09:47,070 --> 00:09:53,700
you'll have a file save or a file open

00:09:49,700 --> 00:09:55,200
menu option and if you're making

00:09:53,700 --> 00:09:58,050
something new what most people do is

00:09:55,200 --> 00:09:59,610
they will do F open when the when you do

00:09:58,050 --> 00:10:04,010
file open and then they'll either read

00:09:59,610 --> 00:10:07,470
or write maybe some XML or some JSON

00:10:04,010 --> 00:10:10,740
from yeah Mille maybe you're if you're

00:10:07,470 --> 00:10:13,920
in Python you it's a pickle file maybe

00:10:10,740 --> 00:10:16,590
some custom binary format the real

00:10:13,920 --> 00:10:20,390
popular choice if you're just doing it

00:10:16,590 --> 00:10:23,130
yourself is what I call a pile of files

00:10:20,390 --> 00:10:25,170
this is where it's your your application

00:10:23,130 --> 00:10:26,820
data is not stored in one file but you

00:10:25,170 --> 00:10:28,290
create a directory and maybe sub

00:10:26,820 --> 00:10:30,660
directories under that and you put lots

00:10:28,290 --> 00:10:32,640
of little files and this comes up a lot

00:10:30,660 --> 00:10:36,720
if your application needs to store both

00:10:32,640 --> 00:10:39,120
text and take images you want to keep

00:10:36,720 --> 00:10:40,860
those images as separate JPEGs as you

00:10:39,120 --> 00:10:42,840
write them out and then the text is in

00:10:40,860 --> 00:10:45,480
some other file might be encoded it's

00:10:42,840 --> 00:10:46,680
XML or JSON or something and that's a

00:10:45,480 --> 00:10:48,630
really popular thing to do but you

00:10:46,680 --> 00:10:50,400
create a pile of files that way that's a

00:10:48,630 --> 00:10:52,830
really popular way to doing it and my

00:10:50,400 --> 00:10:55,410
the point of this whole talk is to

00:10:52,830 --> 00:10:57,629
convince you that it would be better you

00:10:55,410 --> 00:11:00,750
be much better off if instead of doing

00:10:57,629 --> 00:11:02,459
this yourself you would just open a

00:11:00,750 --> 00:11:05,550
connection to an SQLite database and

00:11:02,459 --> 00:11:09,240
bright all of your information into the

00:11:05,550 --> 00:11:13,139
database and so here are the top 10

00:11:09,240 --> 00:11:18,120
reasons why you should be using SQLite

00:11:13,139 --> 00:11:20,399
as an application file format reason

00:11:18,120 --> 00:11:24,720
number 1 SQL gives you a high level

00:11:20,399 --> 00:11:32,060
schema and a complex query language you

00:11:24,720 --> 00:11:35,670
know the big the quote is the essence of

00:11:32,060 --> 00:11:38,339
computer representation is the essence

00:11:35,670 --> 00:11:41,100
of computer program anybody ever heard

00:11:38,339 --> 00:11:41,779
that before ever read the mythical

00:11:41,100 --> 00:11:46,970
man-month

00:11:41,779 --> 00:11:48,750
fred brooks show me your flowchart

00:11:46,970 --> 00:11:50,550
representation is the essence of

00:11:48,750 --> 00:11:52,350
computer program show me your flow talk

00:11:50,550 --> 00:11:54,629
charts and conceal your tables and I

00:11:52,350 --> 00:11:56,819
shall continue to be mystified show me

00:11:54,629 --> 00:11:59,269
your tables and I won't usually need

00:11:56,819 --> 00:12:02,040
your flow charts they'll be obvious

00:11:59,269 --> 00:12:06,000
that's amazing he used the word flow

00:12:02,040 --> 00:12:10,350
charts okay to be fair to Fred when he

00:12:06,000 --> 00:12:12,360
wrote this in 1973 flow charts were

00:12:10,350 --> 00:12:14,310
state of the art and software

00:12:12,360 --> 00:12:15,899
development technology this is what

00:12:14,310 --> 00:12:19,110
everybody did whoever here has ever

00:12:15,899 --> 00:12:21,240
written a flow chart okay yeah a few of

00:12:19,110 --> 00:12:22,980
you may be human you at least know what

00:12:21,240 --> 00:12:25,110
a flow chart is so we don't really do

00:12:22,980 --> 00:12:27,779
flow charts anymore but this isn't but

00:12:25,110 --> 00:12:30,569
but but the but what he's saying is a

00:12:27,779 --> 00:12:34,829
timeless truth representation how you

00:12:30,569 --> 00:12:36,959
represent your data is much more

00:12:34,829 --> 00:12:40,050
important than how you implement the

00:12:36,959 --> 00:12:41,519
algorithm now moving forward in time Rob

00:12:40,050 --> 00:12:43,769
Pike says essentially the same thing

00:12:41,519 --> 00:12:45,269
data dominates if you've chosen the

00:12:43,769 --> 00:12:46,740
right data structures and organized

00:12:45,269 --> 00:12:49,290
things well algorithms will almost

00:12:46,740 --> 00:12:51,509
always be self-evident data structures

00:12:49,290 --> 00:12:57,300
not algorithms are central to

00:12:51,509 --> 00:12:58,980
programming and this is a Linux

00:12:57,300 --> 00:13:02,129
conference after all so of course we

00:12:58,980 --> 00:13:04,139
need to come quote leanness Torvalds bad

00:13:02,129 --> 00:13:06,120
programmers worried about the code good

00:13:04,139 --> 00:13:07,020
programmers worry about data structures

00:13:06,120 --> 00:13:09,420
and there

00:13:07,020 --> 00:13:12,000
relationships so how does this relate to

00:13:09,420 --> 00:13:14,160
SQL I you've got a schema you've got an

00:13:12,000 --> 00:13:16,080
SQL schema that carefully defines all of

00:13:14,160 --> 00:13:20,850
your tables and typically it's self

00:13:16,080 --> 00:13:22,860
documenting so if you write something

00:13:20,850 --> 00:13:25,500
and hand it off somebody else to

00:13:22,860 --> 00:13:26,970
maintain or if somebody else for it

00:13:25,500 --> 00:13:29,160
something and they hand it off to you to

00:13:26,970 --> 00:13:32,280
maintain you can typical ook look at the

00:13:29,160 --> 00:13:34,620
schema if it's in it if it uses an SQL

00:13:32,280 --> 00:13:37,920
database and get a good idea of what's

00:13:34,620 --> 00:13:40,260
going on especially if maybe they were

00:13:37,920 --> 00:13:42,660
thoughtful and included maybe a one-line

00:13:40,260 --> 00:13:45,060
comment on each column of each table

00:13:42,660 --> 00:13:46,320
telling you what it was supposed to mean

00:13:45,060 --> 00:13:48,510
you can usually figure that out pretty

00:13:46,320 --> 00:13:51,210
well on the other hand if they've just

00:13:48,510 --> 00:13:53,820
given you a custom pile of files format

00:13:51,210 --> 00:13:55,890
that they invented themselves unless it

00:13:53,820 --> 00:13:56,970
includes a document you're gonna have a

00:13:55,890 --> 00:14:03,150
hard time figuring out what it's

00:13:56,970 --> 00:14:05,190
supposed to do so it so SQLite gives you

00:14:03,150 --> 00:14:06,890
this schema right away you don't have to

00:14:05,190 --> 00:14:09,120
spend a lot of time writing

00:14:06,890 --> 00:14:13,680
documentation on what your file format

00:14:09,120 --> 00:14:15,840
is or conversely you can omit that skip

00:14:13,680 --> 00:14:17,100
and then the person who comes after you

00:14:15,840 --> 00:14:18,720
have to maintain this doesn't have to

00:14:17,100 --> 00:14:20,760
spend a lot of time trying to reverse

00:14:18,720 --> 00:14:21,540
engineer your file format it's it's

00:14:20,760 --> 00:14:25,800
self-evident

00:14:21,540 --> 00:14:27,300
so SQLite also provides you the SQL

00:14:25,800 --> 00:14:29,730
query language which is really a

00:14:27,300 --> 00:14:31,530
programming language that it's a very

00:14:29,730 --> 00:14:35,340
very powerful thing that will reduce

00:14:31,530 --> 00:14:37,470
your workload substantially SQL is an

00:14:35,340 --> 00:14:40,500
interesting language in that you don't

00:14:37,470 --> 00:14:42,600
specify how to compute something you

00:14:40,500 --> 00:14:47,160
specify what it is you want to compute

00:14:42,600 --> 00:14:51,450
and what I found is that if you've never

00:14:47,160 --> 00:14:53,880
done SQL before it takes your mind some

00:14:51,450 --> 00:14:55,380
time to get to really understand this

00:14:53,880 --> 00:14:57,240
concept you have to really work with

00:14:55,380 --> 00:14:59,010
this for a while before you can grok

00:14:57,240 --> 00:15:03,180
what I mean by this but it's a very

00:14:59,010 --> 00:15:05,820
powerful metaphor we find that 10 lines

00:15:03,180 --> 00:15:08,610
of SQL will typically replace a thousand

00:15:05,820 --> 00:15:09,780
lines of procedural code that means

00:15:08,610 --> 00:15:12,570
you'd work faster

00:15:09,780 --> 00:15:16,020
fewer opportunities for error errors bug

00:15:12,570 --> 00:15:17,910
density is is pretty much constant per

00:15:16,020 --> 00:15:20,380
line of code regardless of your choice

00:15:17,910 --> 00:15:21,850
of language and so if you

00:15:20,380 --> 00:15:23,710
choose a language that has fewer lines

00:15:21,850 --> 00:15:26,710
of code you're going to have fewer bugs

00:15:23,710 --> 00:15:28,570
in general you get all sorts of

00:15:26,710 --> 00:15:31,390
automatic constrain enforcement and get

00:15:28,570 --> 00:15:33,790
acid transactions you get access to a

00:15:31,390 --> 00:15:36,970
full-text search engine you get access

00:15:33,790 --> 00:15:38,620
to a geospatial search engine there's

00:15:36,970 --> 00:15:42,540
lots of things that are going on here

00:15:38,620 --> 00:15:47,590
with SQL that you don't get for free so

00:15:42,540 --> 00:15:49,510
here's um there's a Alexander Lloyd gave

00:15:47,590 --> 00:15:51,700
this talk at Berlin buzzwords a couple

00:15:49,510 --> 00:15:55,360
years ago and he was talking about some

00:15:51,700 --> 00:16:00,250
this was a talk on Google's global scale

00:15:55,360 --> 00:16:02,230
SQL database called um spanner and it's

00:16:00,250 --> 00:16:03,730
kind of internal to Google I don't know

00:16:02,230 --> 00:16:05,890
nobody really knows anything about it

00:16:03,730 --> 00:16:06,820
unless you're a Google employee but he

00:16:05,890 --> 00:16:10,090
was talking about it it says there's

00:16:06,820 --> 00:16:12,580
been a big cultural shift at Google the

00:16:10,090 --> 00:16:15,460
SQL based analytics engine Dremel made a

00:16:12,580 --> 00:16:18,070
lot of SQL converts an engine at Google

00:16:15,460 --> 00:16:20,680
people realized it's incredibly powerful

00:16:18,070 --> 00:16:23,170
just to push the semantics of your query

00:16:20,680 --> 00:16:25,750
down into the storage system and let it

00:16:23,170 --> 00:16:27,880
figure out what to do this is the point

00:16:25,750 --> 00:16:29,680
when you're writing a program when

00:16:27,880 --> 00:16:32,380
you're writing an application you want

00:16:29,680 --> 00:16:34,450
to focus on what your end user needs and

00:16:32,380 --> 00:16:36,430
what the end user is is going to be

00:16:34,450 --> 00:16:38,590
experiencing and how you can best serve

00:16:36,430 --> 00:16:41,800
your end user you don't want to spend a

00:16:38,590 --> 00:16:43,390
lot of time messing with bits and bytes

00:16:41,800 --> 00:16:45,460
and how you're going to get it back and

00:16:43,390 --> 00:16:50,020
forth off the disk let the database

00:16:45,460 --> 00:16:51,700
engine worry about that for you now so

00:16:50,020 --> 00:16:55,170
that's not reason number one reason

00:16:51,700 --> 00:16:55,170
number two is the content is accessible

00:16:56,310 --> 00:17:04,020
by that I mean that it's likely to

00:17:00,610 --> 00:17:07,810
endure you can it's an SQL database SQL

00:17:04,020 --> 00:17:10,540
according to a Riley Tim O'Reilly of

00:17:07,810 --> 00:17:12,600
O'Reilly & Associates is the most widely

00:17:10,540 --> 00:17:16,000
known programming language in the world

00:17:12,600 --> 00:17:20,380
more people know SQL than any other

00:17:16,000 --> 00:17:24,610
programming language so it's sort of a

00:17:20,380 --> 00:17:29,110
universal and it's also very searchable

00:17:24,610 --> 00:17:31,600
accessible with SQL I'd especially if

00:17:29,110 --> 00:17:34,120
you're if you're working on a Mac or a

00:17:31,600 --> 00:17:36,100
Linux box the the tool

00:17:34,120 --> 00:17:39,070
to access an SQLite database is normally

00:17:36,100 --> 00:17:41,020
built-in by default it should SQLite 3

00:17:39,070 --> 00:17:43,420
database name and you got it now on

00:17:41,020 --> 00:17:44,860
Windows it's not built in by default but

00:17:43,420 --> 00:17:47,020
it's an easy download it's just a single

00:17:44,860 --> 00:17:49,600
XE file you download it put it somewhere

00:17:47,020 --> 00:17:51,460
and you can go after it and so the

00:17:49,600 --> 00:17:56,110
content is very accessible it's long

00:17:51,460 --> 00:17:58,780
lived if the contents also easily

00:17:56,110 --> 00:18:00,460
extensible and I don't remember what

00:17:58,780 --> 00:18:04,420
your next slide is yeah here we go that

00:18:00,460 --> 00:18:06,660
content is easily extensible in that you

00:18:04,420 --> 00:18:09,280
first write a new program or application

00:18:06,660 --> 00:18:11,920
and you think oh this is great if it's

00:18:09,280 --> 00:18:13,300
going to be any good at all then it's

00:18:11,920 --> 00:18:15,700
some point you're going to want to

00:18:13,300 --> 00:18:17,110
enhance it extend it modify it and prove

00:18:15,700 --> 00:18:20,170
it and when you do that you're gonna

00:18:17,110 --> 00:18:21,940
have to start storing more stuff if

00:18:20,170 --> 00:18:23,050
you've written a custom format that

00:18:21,940 --> 00:18:25,450
means you've got to have upgrade

00:18:23,050 --> 00:18:28,120
procedures etc etc and it's a real

00:18:25,450 --> 00:18:30,190
hassle if you've got an SQL database you

00:18:28,120 --> 00:18:33,880
can normally do your extensions simply

00:18:30,190 --> 00:18:35,800
by adding new tables or adding columns

00:18:33,880 --> 00:18:37,570
into existing tables and it's completely

00:18:35,800 --> 00:18:44,800
backwards compatible it takes no time

00:18:37,570 --> 00:18:48,340
it's very easy to extend with an SQLite

00:18:44,800 --> 00:18:52,050
database you get the the database file

00:18:48,340 --> 00:18:55,510
is a single dot is a single file on disk

00:18:52,050 --> 00:18:58,780
now with an enterprise database like say

00:18:55,510 --> 00:19:01,090
MySQL when you create a database it's a

00:18:58,780 --> 00:19:02,440
bunch of mysterious files off in some

00:19:01,090 --> 00:19:05,320
directory somewhere on your computer

00:19:02,440 --> 00:19:07,540
that only your DBA knows about I don't

00:19:05,320 --> 00:19:09,940
know where they're kept but it's a bunch

00:19:07,540 --> 00:19:11,800
of files it's not a document whereas the

00:19:09,940 --> 00:19:13,480
SQLite database it's a single file the

00:19:11,800 --> 00:19:19,900
document is something that you can take

00:19:13,480 --> 00:19:21,880
and send as an email attachment or send

00:19:19,900 --> 00:19:23,590
somebody through chat is it's it's a

00:19:21,880 --> 00:19:25,300
document that you can send around that's

00:19:23,590 --> 00:19:26,559
a very important concept that isn't

00:19:25,300 --> 00:19:28,660
available in other database engines

00:19:26,559 --> 00:19:35,040
SQLite is cross-platform and

00:19:28,660 --> 00:19:40,990
cross-language it runs on on big-endian

00:19:35,040 --> 00:19:43,179
little-endian 32-bit 64-bit the same

00:19:40,990 --> 00:19:45,850
database file is portable between all of

00:19:43,179 --> 00:19:47,429
these things so say you're in a lab

00:19:45,850 --> 00:19:49,379
environment

00:19:47,429 --> 00:19:51,749
and you've got some instrument making

00:19:49,379 --> 00:19:55,019
measurements and it's a MIPS processor

00:19:51,749 --> 00:19:56,669
which is big endian 32-bit and it's

00:19:55,019 --> 00:19:58,589
writing the database file and that's

00:19:56,669 --> 00:20:00,389
fine and it's putting integer raw

00:19:58,589 --> 00:20:02,219
integer data in there and that's fine

00:20:00,389 --> 00:20:04,859
and then you pull it off and you're

00:20:02,219 --> 00:20:08,190
doing it on your Linux Intel based

00:20:04,859 --> 00:20:09,869
workstation a 64-bit and you read that

00:20:08,190 --> 00:20:11,729
in those integers are gonna be byte

00:20:09,869 --> 00:20:13,200
swapped automatically you don't have to

00:20:11,729 --> 00:20:18,149
worry about Indian issues you don't have

00:20:13,200 --> 00:20:20,359
to worry about word length issues you

00:20:18,149 --> 00:20:24,389
don't have to worry about if the text is

00:20:20,359 --> 00:20:27,210
utf-16 or utf-8 all of these conversions

00:20:24,389 --> 00:20:29,399
happen automatically and then if you're

00:20:27,210 --> 00:20:30,839
working in an environment where you have

00:20:29,399 --> 00:20:34,440
lots of different teams that are using

00:20:30,839 --> 00:20:36,749
the same data your different teams can

00:20:34,440 --> 00:20:40,769
you choose whatever programming language

00:20:36,749 --> 00:20:41,909
they want so say you take some

00:20:40,769 --> 00:20:43,529
measurements and it's stored in a

00:20:41,909 --> 00:20:45,960
database file and then there's a team of

00:20:43,529 --> 00:20:47,429
here and they were responsible with with

00:20:45,960 --> 00:20:50,279
sanitizing the data and they like to

00:20:47,429 --> 00:20:52,259
program in Perl well that's fine it's a

00:20:50,279 --> 00:20:53,309
that Perl can access an SQLite database

00:20:52,259 --> 00:20:56,119
and then you pass it on to some other

00:20:53,309 --> 00:20:58,589
team and they like to program in Java

00:20:56,119 --> 00:21:00,659
well no worries because they can still

00:20:58,589 --> 00:21:02,609
access the same data and use it the same

00:21:00,659 --> 00:21:03,869
way and then there's another kind of

00:21:02,609 --> 00:21:06,869
team over here and they're doing some

00:21:03,869 --> 00:21:09,629
detail analysis in Fortran for and you

00:21:06,869 --> 00:21:11,129
can still read an X right access the

00:21:09,629 --> 00:21:14,909
same database without each one of these

00:21:11,129 --> 00:21:17,129
teams having to recreate the same io

00:21:14,909 --> 00:21:21,359
code and understand the file format in

00:21:17,129 --> 00:21:22,769
detail you get atomic transactions when

00:21:21,359 --> 00:21:27,330
you're working with an SQLite database

00:21:22,769 --> 00:21:27,899
this is this is this is near and dear to

00:21:27,330 --> 00:21:32,719
my heart

00:21:27,899 --> 00:21:37,799
you know I develop my primary desktop is

00:21:32,719 --> 00:21:41,489
is a boon to Linux I'm not real fond of

00:21:37,799 --> 00:21:45,269
been to per se but the guy that sells me

00:21:41,489 --> 00:21:48,809
my computers the only Linux option he

00:21:45,269 --> 00:21:51,599
has is a boon too so that's what I take

00:21:48,809 --> 00:21:53,700
and I used to be years ago I would build

00:21:51,599 --> 00:21:55,570
up my own hardware and install my own OS

00:21:53,700 --> 00:21:58,060
and configure it the way I wanted to

00:21:55,570 --> 00:22:00,250
these days I just you know place the

00:21:58,060 --> 00:22:02,770
order and it comes in a box and the root

00:22:00,250 --> 00:22:04,540
password is taped on the box and I just

00:22:02,770 --> 00:22:07,390
plug it in and then start using it and

00:22:04,540 --> 00:22:08,560
that that's what I do now and so he

00:22:07,390 --> 00:22:11,710
ships it with the boom - and I use it

00:22:08,560 --> 00:22:13,600
but anyway this is libera

00:22:11,710 --> 00:22:16,180
Libre Office do you say Libre Office or

00:22:13,600 --> 00:22:18,270
Auto had he pronounced it it opened all

00:22:16,180 --> 00:22:22,840
of us what yo Open Office used to be

00:22:18,270 --> 00:22:24,640
yeah the the the desktop the desktop

00:22:22,840 --> 00:22:27,580
environment formerly known as Open

00:22:24,640 --> 00:22:29,140
Office what is it called now anyway

00:22:27,580 --> 00:22:34,870
that's what this presentations in and

00:22:29,140 --> 00:22:36,760
this is um what it does here and you

00:22:34,870 --> 00:22:39,220
know whenever you do file save you've

00:22:36,760 --> 00:22:42,190
got this little bar that moves across

00:22:39,220 --> 00:22:45,520
the bottom and it shows you it's writing

00:22:42,190 --> 00:22:48,540
all the stuff out to disk I you know I

00:22:45,520 --> 00:22:53,880
find that exceedingly annoying I have

00:22:48,540 --> 00:22:58,210
you know 32gb bytes of RAM and an SSD

00:22:53,880 --> 00:22:59,350
SSD drive and it what am I waiting for

00:22:58,210 --> 00:23:02,710
this thing - right why isn't it

00:22:59,350 --> 00:23:09,010
instantaneous well doing it because of

00:23:02,710 --> 00:23:10,540
you know there it has to uh slowly write

00:23:09,010 --> 00:23:13,150
all this stuff out to disk and it

00:23:10,540 --> 00:23:15,100
doesn't all in one one bunch if you had

00:23:13,150 --> 00:23:18,490
an SQL up if it needed uses an SQLite

00:23:15,100 --> 00:23:21,070
database every time I press the key it

00:23:18,490 --> 00:23:23,380
could make that change and make it

00:23:21,070 --> 00:23:24,850
atomically and it would be pretty much

00:23:23,380 --> 00:23:26,950
instantaneously there would there

00:23:24,850 --> 00:23:29,380
wouldn't be no need for a file save at

00:23:26,950 --> 00:23:35,590
all because it would automatically save

00:23:29,380 --> 00:23:38,110
as I typed atomic transactions

00:23:35,590 --> 00:23:43,090
incremental and continuous updating same

00:23:38,110 --> 00:23:44,650
idea OpenOffice it requires you to save

00:23:43,090 --> 00:23:46,930
this big thing out to disk it's a ride

00:23:44,650 --> 00:23:49,780
operation it takes time whereas with an

00:23:46,930 --> 00:23:51,760
a database you can make individual

00:23:49,780 --> 00:23:54,130
changes as they occur and their gear

00:23:51,760 --> 00:23:56,620
interviewed to be atomic you're not if

00:23:54,130 --> 00:23:58,480
you lose power in the middle of writing

00:23:56,620 --> 00:24:01,210
you're not going to corrupt the file

00:23:58,480 --> 00:24:05,130
it'll automatically recover there's no

00:24:01,210 --> 00:24:05,130
recovery process that has to occur

00:24:05,160 --> 00:24:09,550
picking on OpenOffice some more which

00:24:07,960 --> 00:24:11,559
this presentation is done in that

00:24:09,550 --> 00:24:13,300
picking on it's more if you do lose

00:24:11,559 --> 00:24:18,010
power in the middle of saving an

00:24:13,300 --> 00:24:20,050
OpenOffice I don't know if whoever who

00:24:18,010 --> 00:24:22,630
your uses that if you if you lose power

00:24:20,050 --> 00:24:24,130
you know that then when the next time

00:24:22,630 --> 00:24:29,140
you bring up the document you have to go

00:24:24,130 --> 00:24:33,370
through a recovery procedure is beyond

00:24:29,140 --> 00:24:34,750
annoying if it were a database file

00:24:33,370 --> 00:24:36,220
none of that would be necessary because

00:24:34,750 --> 00:24:40,900
recovery would be automatic and pretty

00:24:36,220 --> 00:24:42,460
much instantaneous there if you if you

00:24:40,900 --> 00:24:43,120
use SQLite as your application file

00:24:42,460 --> 00:24:45,970
format

00:24:43,120 --> 00:24:51,520
there's no parsing code to write or

00:24:45,970 --> 00:24:53,230
debug that saves you work and that also

00:24:51,520 --> 00:24:56,650
means that there's less bugs in your

00:24:53,230 --> 00:24:59,850
program well I guess I've got another

00:24:56,650 --> 00:24:59,850
slide coming up on that in a minute

00:25:01,679 --> 00:25:04,660
SQLite

00:25:02,800 --> 00:25:06,970
is multi process and multi thread safe

00:25:04,660 --> 00:25:09,970
that means that if you're using SQLite

00:25:06,970 --> 00:25:13,600
is your application file format two or

00:25:09,970 --> 00:25:15,520
three or ten different processes can all

00:25:13,600 --> 00:25:19,120
be trying to access the same application

00:25:15,520 --> 00:25:21,750
file at the same time and all that will

00:25:19,120 --> 00:25:24,040
be taken care of for you automatically

00:25:21,750 --> 00:25:26,800
what if you try to bring up two

00:25:24,040 --> 00:25:28,690
instances of your other of some other

00:25:26,800 --> 00:25:30,070
desktop program and access the same file

00:25:28,690 --> 00:25:32,350
at the same time that would create

00:25:30,070 --> 00:25:35,290
problems probably but here it's taking

00:25:32,350 --> 00:25:36,910
care of automatically thread safe is it

00:25:35,290 --> 00:25:38,170
you can also access it from multiple

00:25:36,910 --> 00:25:39,910
threads and not have to worry about any

00:25:38,170 --> 00:25:41,800
of the locking issues not have to worry

00:25:39,910 --> 00:25:45,220
about overrides and finally you get

00:25:41,800 --> 00:25:49,210
improved performance here is a chart

00:25:45,220 --> 00:25:52,120
showing read times for blobs out of

00:25:49,210 --> 00:25:55,990
SQLite versus out of a file system out

00:25:52,120 --> 00:25:58,300
of xt4 just to just open the file and

00:25:55,990 --> 00:26:02,230
read it versus read it as a blob out of

00:25:58,300 --> 00:26:08,080
SQLite and so if you know an entry right

00:26:02,230 --> 00:26:13,060
here so for a 10k blob with a page size

00:26:08,080 --> 00:26:14,679
of 81 92 you though you can read the

00:26:13,060 --> 00:26:15,130
information out of an SQLite database

00:26:14,679 --> 00:26:19,360
too

00:26:15,130 --> 00:26:25,000
point to four times faster than you can

00:26:19,360 --> 00:26:26,380
open a file and read it off the disk now

00:26:25,000 --> 00:26:27,910
this is true for smaller blobs as you

00:26:26,380 --> 00:26:30,580
can see if you get out for larger ones

00:26:27,910 --> 00:26:34,060
you eventually lose time and I think the

00:26:30,580 --> 00:26:36,550
difference here is that just the simple

00:26:34,060 --> 00:26:39,910
overhead of calling F open and opening

00:26:36,550 --> 00:26:41,140
the file descriptor takes time whereas

00:26:39,910 --> 00:26:42,790
if you've got the database file already

00:26:41,140 --> 00:26:46,000
open it can just reach in and grab it

00:26:42,790 --> 00:26:48,010
this interesting fact that that SQLite

00:26:46,000 --> 00:26:51,400
is actually faster up to twice as fast

00:26:48,010 --> 00:26:53,820
at reading data off of disk than out of

00:26:51,400 --> 00:26:58,710
the file system was first discovered by

00:26:53,820 --> 00:27:01,660
Adobe this is an example of a real-world

00:26:58,710 --> 00:27:04,720
application that uses SQLite is an

00:27:01,660 --> 00:27:06,880
application file Adobe Lightroom any

00:27:04,720 --> 00:27:09,940
photography people in here do you use

00:27:06,880 --> 00:27:13,300
Lightroom you've heard of it though yeah

00:27:09,940 --> 00:27:17,430
it's it's kind of a high end of photo

00:27:13,300 --> 00:27:20,020
analysis and processing application and

00:27:17,430 --> 00:27:21,580
it's R it uses SQLite is this

00:27:20,020 --> 00:27:23,440
application file format and they came to

00:27:21,580 --> 00:27:25,180
me years ago and said hey we were

00:27:23,440 --> 00:27:27,670
looking at that they store the images

00:27:25,180 --> 00:27:30,430
the RAW images are stored in separate

00:27:27,670 --> 00:27:32,440
files but they were wondering well

00:27:30,430 --> 00:27:34,420
should we keep thumbnails in the

00:27:32,440 --> 00:27:37,270
database or should we store them as

00:27:34,420 --> 00:27:40,690
separate files too and they ran the

00:27:37,270 --> 00:27:42,750
experiment basically this experiment and

00:27:40,690 --> 00:27:45,010
discovered that for thumbnail size blobs

00:27:42,750 --> 00:27:47,800
it's actually faster to store them in

00:27:45,010 --> 00:27:49,960
the database I didn't design SQLite to

00:27:47,800 --> 00:27:52,570
do that it just worked out but it is

00:27:49,960 --> 00:27:54,370
faster so adobe is an example of a real

00:27:52,570 --> 00:27:57,130
application that uses SQLite it's an

00:27:54,370 --> 00:28:04,420
application file format another example

00:27:57,130 --> 00:28:06,820
would be Firefox actually all most of

00:28:04,420 --> 00:28:08,590
the major web browsers do it here's but

00:28:06,820 --> 00:28:11,020
here's an example of how Firefox uses it

00:28:08,590 --> 00:28:12,730
if you use Firefox they have this thing

00:28:11,020 --> 00:28:14,890
called the awesome bar where you start

00:28:12,730 --> 00:28:17,620
typing into the URL thing and it it

00:28:14,890 --> 00:28:20,320
gives you suggestions and I use this all

00:28:17,620 --> 00:28:22,750
the time because rather than setting

00:28:20,320 --> 00:28:24,910
bookmarks you know it knows what

00:28:22,750 --> 00:28:27,280
websites I go to a lot and so I can type

00:28:24,910 --> 00:28:29,470
the first one or two characters of the

00:28:27,280 --> 00:28:33,760
the rest a lot of complete it's really

00:28:29,470 --> 00:28:35,500
nice every time you press a key in but

00:28:33,760 --> 00:28:37,030
that's hard to figure out you know what

00:28:35,500 --> 00:28:39,460
what websites you're typing so every

00:28:37,030 --> 00:28:44,080
time you press a key in the URL bar or

00:28:39,460 --> 00:28:49,210
Firefox that SQL query runs or something

00:28:44,080 --> 00:28:52,380
like that now you're not expected to

00:28:49,210 --> 00:28:56,850
understand what this means simply

00:28:52,380 --> 00:29:05,320
recognize that this bit of SQL replaces

00:28:56,850 --> 00:29:08,350
thousands of lines of C++ so in a so

00:29:05,320 --> 00:29:11,530
SQLite is used a lot as an application

00:29:08,350 --> 00:29:14,560
found for file format in in applications

00:29:11,530 --> 00:29:16,810
that you use every day now even in India

00:29:14,560 --> 00:29:18,040
there's a it's I find that issues done a

00:29:16,810 --> 00:29:23,080
lot of applications that I don't even

00:29:18,040 --> 00:29:28,080
know about as I was making up these

00:29:23,080 --> 00:29:30,790
slides somebody tweeted that this

00:29:28,080 --> 00:29:35,110
application called locus which is a map

00:29:30,790 --> 00:29:38,380
thing used SQLite and I checked and it

00:29:35,110 --> 00:29:40,780
does in fact and and I bring this up

00:29:38,380 --> 00:29:42,460
only because this this this came up as I

00:29:40,780 --> 00:29:44,410
was actually making these slides and

00:29:42,460 --> 00:29:46,810
what they do is this is up some kind of

00:29:44,410 --> 00:29:50,170
mapping application for your smartphone

00:29:46,810 --> 00:29:53,620
and when they're transferring the data

00:29:50,170 --> 00:29:55,480
from their server to your phone they're

00:29:53,620 --> 00:29:58,330
really just sending down an SQLite

00:29:55,480 --> 00:30:00,280
database file and all of their map data

00:29:58,330 --> 00:30:02,080
is stored in an SQLite database file so

00:30:00,280 --> 00:30:04,930
that is their file format for transfer

00:30:02,080 --> 00:30:06,670
purposes never heard of them don't know

00:30:04,930 --> 00:30:09,790
anything about them really so let's play

00:30:06,670 --> 00:30:11,680
some what-if scenarios I've been I love

00:30:09,790 --> 00:30:13,360
OpenOffice or Libre Office or whatever

00:30:11,680 --> 00:30:16,660
they're calling it now I use it all the

00:30:13,360 --> 00:30:18,850
time but let's let's pretend that and

00:30:16,660 --> 00:30:23,500
and and oh in the file format for

00:30:18,850 --> 00:30:25,450
OpenOffice is a zip archive containing

00:30:23,500 --> 00:30:28,210
XML files I don't know if you've ever

00:30:25,450 --> 00:30:30,430
noticed this if you make an application

00:30:28,210 --> 00:30:33,610
with or make up presentation with

00:30:30,430 --> 00:30:36,130
OpenOffice and you it says ODP is the

00:30:33,610 --> 00:30:38,530
extension but you can unzip it and you

00:30:36,130 --> 00:30:39,520
get lots of content files out of it so

00:30:38,530 --> 00:30:40,870
that's the kind of a common things a

00:30:39,520 --> 00:30:42,760
pile of files format

00:30:40,870 --> 00:30:44,830
what if instead of doing that that he'd

00:30:42,760 --> 00:30:48,250
done it with an SQLite database now to

00:30:44,830 --> 00:30:50,440
be fair to OpenOffice their file format

00:30:48,250 --> 00:30:53,320
has existed longer than SQLite so this

00:30:50,440 --> 00:30:57,840
is not that they made a bad choice but

00:30:53,320 --> 00:31:00,700
what if it were that way so instead of

00:30:57,840 --> 00:31:03,970
sq want we could you the fast low i/o

00:31:00,700 --> 00:31:07,690
saves you know OpenOffice tends to crash

00:31:03,970 --> 00:31:11,530
a lot and so as a consequence of this

00:31:07,690 --> 00:31:13,179
every some number of keystrokes they

00:31:11,530 --> 00:31:15,580
will do a complete backup of what you're

00:31:13,179 --> 00:31:18,970
working on and while they're doing that

00:31:15,580 --> 00:31:20,410
backup which can take two to ten seconds

00:31:18,970 --> 00:31:23,080
depending on how fast your machine is

00:31:20,410 --> 00:31:26,080
and how big your presentation is it

00:31:23,080 --> 00:31:27,760
locks up so you're typing along typing

00:31:26,080 --> 00:31:29,260
something in and suddenly it's sized to

00:31:27,760 --> 00:31:31,570
do a save in the middle of what you're

00:31:29,260 --> 00:31:33,220
typing and everything locks up and you

00:31:31,570 --> 00:31:35,380
see the little blue bar go across the

00:31:33,220 --> 00:31:37,000
bottom and and the reason it's making

00:31:35,380 --> 00:31:38,590
these backups is it tends to crash a lot

00:31:37,000 --> 00:31:41,800
and lose your data and it doesn't want

00:31:38,590 --> 00:31:43,240
to do that so but if it were an SQLite

00:31:41,800 --> 00:31:44,920
database it could say it has you typing

00:31:43,240 --> 00:31:47,230
every time for us a key it could save

00:31:44,920 --> 00:31:48,730
that key and you'd be up to date and and

00:31:47,230 --> 00:31:50,370
then if it crashed you'd still have

00:31:48,730 --> 00:31:52,690
everything right there in front of you

00:31:50,370 --> 00:31:55,630
you get much faster startup right now

00:31:52,690 --> 00:31:58,390
when OpenOffice starts up it has to read

00:31:55,630 --> 00:31:59,530
the entire file parse the entire file

00:31:58,390 --> 00:32:02,380
load the whole thing in the memory

00:31:59,530 --> 00:32:04,059
figure it all out whereas if it were a

00:32:02,380 --> 00:32:07,150
database it could just query for the

00:32:04,059 --> 00:32:09,610
first screen and be done it doesn't have

00:32:07,150 --> 00:32:12,160
to parse the whole thing reduce memory

00:32:09,610 --> 00:32:13,480
usage it only has to hold in memory the

00:32:12,160 --> 00:32:15,460
part of the document that you're

00:32:13,480 --> 00:32:16,179
currently working on the rest can be

00:32:15,460 --> 00:32:17,830
held one disk

00:32:16,179 --> 00:32:20,020
there's no I've already mentioned

00:32:17,830 --> 00:32:22,450
there's no recovery process required

00:32:20,020 --> 00:32:25,300
after crash there's no need for a file

00:32:22,450 --> 00:32:26,590
save or a file open menu option well I

00:32:25,300 --> 00:32:29,110
guess you need file open to tell it

00:32:26,590 --> 00:32:30,910
which database to connect to and then

00:32:29,110 --> 00:32:34,120
it'll be filed disconnect maybe I'm not

00:32:30,910 --> 00:32:36,280
sure but it would be different

00:32:34,120 --> 00:32:37,720
you could have undo across sessions you

00:32:36,280 --> 00:32:39,490
could set up triggers in your database

00:32:37,720 --> 00:32:41,910
file to automatically record every

00:32:39,490 --> 00:32:44,770
change and store it in a log file and

00:32:41,910 --> 00:32:48,280
then your undo could just undo those

00:32:44,770 --> 00:32:52,960
changes and that means that you could be

00:32:48,280 --> 00:32:54,759
editing shutdown move the fun email the

00:32:52,960 --> 00:32:57,399
file to somebody else

00:32:54,759 --> 00:32:59,679
and then our email the file to yourself

00:32:57,399 --> 00:33:01,719
on a different machine open it again on

00:32:59,679 --> 00:33:03,429
a different version of a software and

00:33:01,719 --> 00:33:06,309
then start undoing things you had done

00:33:03,429 --> 00:33:08,829
in the previous session cross session on

00:33:06,309 --> 00:33:12,940
do you get a large searchable database

00:33:08,829 --> 00:33:14,529
here's some one of the bugs that came up

00:33:12,940 --> 00:33:16,299
as I was editing this very same

00:33:14,529 --> 00:33:18,159
presentation then this comes up

00:33:16,299 --> 00:33:19,839
periodically for me in OpenOffice is

00:33:18,159 --> 00:33:24,070
that sometimes when you do a file save

00:33:19,839 --> 00:33:25,599
it corrupts some of the images now these

00:33:24,070 --> 00:33:27,489
are separate images that are stored in

00:33:25,599 --> 00:33:29,109
the zip archive and it did it when I was

00:33:27,489 --> 00:33:31,959
actually I did a file say when I was

00:33:29,109 --> 00:33:34,690
preparing this very presentation and

00:33:31,959 --> 00:33:37,929
this is a screenshot from my room to

00:33:34,690 --> 00:33:40,479
desktop where it it when I brought it

00:33:37,929 --> 00:33:42,249
back up you can see that the image of

00:33:40,479 --> 00:33:46,629
the Firefox browser that we saw a couple

00:33:42,249 --> 00:33:48,819
slides ago is corrupted and it made this

00:33:46,629 --> 00:33:51,279
corruption even though the edits that I

00:33:48,819 --> 00:33:53,829
were saving and absolutely nothing to do

00:33:51,279 --> 00:33:55,989
with that particular page but in

00:33:53,829 --> 00:34:00,489
OpenOffice because it's because there's

00:33:55,989 --> 00:34:01,629
a pile of file format it has to every

00:34:00,489 --> 00:34:03,869
time you press file save it has to

00:34:01,629 --> 00:34:07,899
rewrite the entire file

00:34:03,869 --> 00:34:11,529
you know thus consuming 10 megabytes of

00:34:07,899 --> 00:34:13,539
your finite life SSD drive and and

00:34:11,529 --> 00:34:14,829
taking a long time and potentially

00:34:13,539 --> 00:34:16,539
corrupting things when there are bugs

00:34:14,829 --> 00:34:17,799
and the thing if this had been an SQLite

00:34:16,539 --> 00:34:20,279
database this bug would have never

00:34:17,799 --> 00:34:23,769
happened so what if the ePub format

00:34:20,279 --> 00:34:26,109
that's it was an SQLite database epub is

00:34:23,769 --> 00:34:29,470
the format that's used by nuke and other

00:34:26,109 --> 00:34:32,799
kinds of Eire eaters it's a file format

00:34:29,470 --> 00:34:35,559
used for eBook readers other than the

00:34:32,799 --> 00:34:37,059
one from Amazon okay they have their own

00:34:35,559 --> 00:34:38,829
proprietary format that they will not

00:34:37,059 --> 00:34:41,470
share with anyone but all the others use

00:34:38,829 --> 00:34:44,589
epub and is also a zip archive of XML

00:34:41,470 --> 00:34:50,470
files epub is gray except it's a really

00:34:44,589 --> 00:34:53,200
slow to load because being a a pile of

00:34:50,470 --> 00:34:55,750
files in a pile of files you want each

00:34:53,200 --> 00:34:57,490
file will be relatively big and so they

00:34:55,750 --> 00:34:59,380
put an entire chapter in each file so it

00:34:57,490 --> 00:35:01,680
has to read and parse the entire chapter

00:34:59,380 --> 00:35:04,000
that you're on report displays anything

00:35:01,680 --> 00:35:05,710
whereas if it were a database file it

00:35:04,000 --> 00:35:06,740
could potentially store individual

00:35:05,710 --> 00:35:08,420
paragraphs

00:35:06,740 --> 00:35:10,730
and separate records and it can only

00:35:08,420 --> 00:35:13,580
need to load in the three paragraphs

00:35:10,730 --> 00:35:14,540
that were on-screen at that point it

00:35:13,580 --> 00:35:17,150
wouldn't have to load in the entire

00:35:14,540 --> 00:35:19,250
chapter come up very much quicker use

00:35:17,150 --> 00:35:20,690
less memory you could have full-text

00:35:19,250 --> 00:35:22,460
search the epub readers are really

00:35:20,690 --> 00:35:24,560
annoying when you try and search because

00:35:22,460 --> 00:35:27,950
they're basically grepping the entire

00:35:24,560 --> 00:35:29,960
document but you can have full text

00:35:27,950 --> 00:35:33,350
search full Google style search to find

00:35:29,960 --> 00:35:38,510
things in your book if you had it stored

00:35:33,350 --> 00:35:41,119
as an SQLite database just you know as

00:35:38,510 --> 00:35:46,400
an experiment I wrote this little

00:35:41,119 --> 00:35:50,330
program that what what if you wanted to

00:35:46,400 --> 00:35:52,730
convert say an ePub or an OpenOffice

00:35:50,330 --> 00:35:54,560
document into an SQLite database it's

00:35:52,730 --> 00:35:57,110
already kind of engineered to be a pile

00:35:54,560 --> 00:36:00,470
of files what what if we built an

00:35:57,110 --> 00:36:02,600
archive or a zip like program that

00:36:00,470 --> 00:36:05,150
stored its data in an SQLite database

00:36:02,600 --> 00:36:06,770
here's the schema for such a thing we've

00:36:05,150 --> 00:36:09,710
got the name of the file as the first

00:36:06,770 --> 00:36:11,720
field it's access permissions and the is

00:36:09,710 --> 00:36:14,480
modification time the original file size

00:36:11,720 --> 00:36:17,510
and then a big blob that can stores that

00:36:14,480 --> 00:36:19,340
stores the compressed content and I

00:36:17,510 --> 00:36:20,630
actually have this there's a website

00:36:19,340 --> 00:36:21,740
there you can go and download the code

00:36:20,630 --> 00:36:23,270
if you want to play with it I'm not

00:36:21,740 --> 00:36:27,590
suggesting this is useful for anything

00:36:23,270 --> 00:36:28,700
this is merely a proof of concept the

00:36:27,590 --> 00:36:30,890
advantages there were something like it

00:36:28,700 --> 00:36:32,570
is it's now transactional if you lose

00:36:30,890 --> 00:36:33,530
power in the middle of a save it doesn't

00:36:32,570 --> 00:36:36,050
corrupt the old copy

00:36:33,530 --> 00:36:37,220
it's concurrent it's random access you

00:36:36,050 --> 00:36:39,650
can update it without having to rewrite

00:36:37,220 --> 00:36:41,960
the entire file and what was really

00:36:39,650 --> 00:36:47,060
surprising to me is that the file sizes

00:36:41,960 --> 00:36:49,760
are no bigger this is actual data this

00:36:47,060 --> 00:36:52,100
is the top line is this presentation

00:36:49,760 --> 00:36:53,750
that you're looking at prior to

00:36:52,100 --> 00:36:56,330
inserting the slide of course I mean

00:36:53,750 --> 00:36:58,640
this is an older version of it and it's

00:36:56,330 --> 00:37:01,220
just over ten megabytes and what I did

00:36:58,640 --> 00:37:05,119
was I unzipped it and then I used that

00:37:01,220 --> 00:37:07,220
SQL archival utility to re to insert it

00:37:05,119 --> 00:37:09,500
all into an SQLite database and the SQL

00:37:07,220 --> 00:37:13,280
database was actually slightly smaller

00:37:09,500 --> 00:37:17,649
by half percent which I found difficult

00:37:13,280 --> 00:37:20,089
to believe excuse me

00:37:17,649 --> 00:37:22,189
so I thought something must be wrong I

00:37:20,089 --> 00:37:24,079
took the same files and I re archive

00:37:22,189 --> 00:37:26,630
them with zip and it was slightly

00:37:24,079 --> 00:37:29,719
smaller still so what this tells me is

00:37:26,630 --> 00:37:31,219
that Open Office the zip archive er

00:37:29,719 --> 00:37:33,619
that's kind of built into it is not

00:37:31,219 --> 00:37:35,149
doing the best job of compression maybe

00:37:33,619 --> 00:37:36,949
it have the compression turned down on

00:37:35,149 --> 00:37:38,599
it or something I'm not sure but anyway

00:37:36,949 --> 00:37:40,849
we can see that in SQLite databases

00:37:38,599 --> 00:37:46,639
really know much is not significantly

00:37:40,849 --> 00:37:49,880
larger than a zip archive so what use it

00:37:46,639 --> 00:37:52,489
get yeah we got getting users rent you

00:37:49,880 --> 00:37:54,829
know get its file format is a pile of

00:37:52,489 --> 00:37:56,599
files right I mean you got the dot git

00:37:54,829 --> 00:37:58,519
folder and then you have a bunch of

00:37:56,599 --> 00:38:00,499
files in there which are maybe your

00:37:58,519 --> 00:38:04,429
content unless they're packed files in

00:38:00,499 --> 00:38:09,019
which case there's some binary format

00:38:04,429 --> 00:38:11,749
that is only known to get and so what if

00:38:09,019 --> 00:38:15,799
instead of using a pile of files get had

00:38:11,749 --> 00:38:17,209
used an SQLite database there's a lot of

00:38:15,799 --> 00:38:20,809
advantages that would come out of this

00:38:17,209 --> 00:38:23,899
you get much richer user interface for a

00:38:20,809 --> 00:38:30,109
lot less work and I've got some examples

00:38:23,899 --> 00:38:32,989
of that if if it's um if you lost power

00:38:30,109 --> 00:38:34,519
in the middle of a git GC it wouldn't

00:38:32,989 --> 00:38:38,029
corrupt your data it wouldn't corrupt

00:38:34,519 --> 00:38:40,099
your repository okay it automatically

00:38:38,029 --> 00:38:42,679
rollback it makes it really easy to add

00:38:40,099 --> 00:38:44,569
things like wiki and tickets to the

00:38:42,679 --> 00:38:46,729
repository which are completely missing

00:38:44,569 --> 00:38:48,979
now you get concurrent access but

00:38:46,729 --> 00:38:50,329
multiple processes can be checking

00:38:48,979 --> 00:38:54,709
things in and checking things out at the

00:38:50,329 --> 00:38:56,899
same time on the same repository if you

00:38:54,709 --> 00:39:00,259
make an error in coding say that right

00:38:56,899 --> 00:39:07,039
now get reproduce realize it's it's a

00:39:00,259 --> 00:39:08,839
it's the get relies on the code being

00:39:07,039 --> 00:39:10,939
correct for not corrupting your

00:39:08,839 --> 00:39:12,739
repository if there's a bug in the code

00:39:10,939 --> 00:39:16,130
and you do a commit it could seriously

00:39:12,739 --> 00:39:18,439
corrupt what you have but if you had a

00:39:16,130 --> 00:39:19,759
database with transactions you could you

00:39:18,439 --> 00:39:21,619
could start a transaction make what

00:39:19,759 --> 00:39:23,059
changes you needed to the repository and

00:39:21,619 --> 00:39:24,679
then go back and double-check and make

00:39:23,059 --> 00:39:26,119
sure everything was still accessible and

00:39:24,679 --> 00:39:28,729
everything still worked before you

00:39:26,119 --> 00:39:31,460
committed and if something was wrong you

00:39:28,729 --> 00:39:33,620
could just roll back and nothing was

00:39:31,460 --> 00:39:37,820
you get on the fly compression instead

00:39:33,620 --> 00:39:40,130
of having to run get GC and your

00:39:37,820 --> 00:39:42,590
repositories now a single file so you

00:39:40,130 --> 00:39:44,570
can email your repository to somebody I

00:39:42,590 --> 00:39:46,850
guess you can email your repository now

00:39:44,570 --> 00:39:49,430
but first you have to tar it up into a

00:39:46,850 --> 00:39:51,980
tar ball or something but with this way

00:39:49,430 --> 00:39:55,040
it's just a single file so here's an

00:39:51,980 --> 00:39:56,540
example of what you know you know the

00:39:55,040 --> 00:39:59,860
kinds of things that you might come out

00:39:56,540 --> 00:40:02,780
with the user interface here's a

00:39:59,860 --> 00:40:07,700
timeline graph of a repository not yet

00:40:02,780 --> 00:40:10,250
and this timeline from a historical

00:40:07,700 --> 00:40:13,850
timeline like that is actually generated

00:40:10,250 --> 00:40:17,000
by that bit of SQL well okay we add to

00:40:13,850 --> 00:40:20,420
that about 520 lines of C code to

00:40:17,000 --> 00:40:22,910
convert the output into the JavaScript

00:40:20,420 --> 00:40:24,850
that actually jaws draws the graph but

00:40:22,910 --> 00:40:28,070
this is extracting all the information

00:40:24,850 --> 00:40:30,950
now if you're familiar with yet and you

00:40:28,070 --> 00:40:32,300
know the repository format and you might

00:40:30,950 --> 00:40:33,980
look at this and say okay well in order

00:40:32,300 --> 00:40:35,600
to extract that information from the git

00:40:33,980 --> 00:40:38,210
repository this is what I would have to

00:40:35,600 --> 00:40:39,950
do and you start thinking threat you

00:40:38,210 --> 00:40:42,800
know the get LOD utilities that you'd

00:40:39,950 --> 00:40:45,410
call to to to extract this information

00:40:42,800 --> 00:40:46,730
and if you did that instinctively you're

00:40:45,410 --> 00:40:48,110
doing it wrong because you shouldn't

00:40:46,730 --> 00:40:49,820
have to think about that you should be

00:40:48,110 --> 00:40:52,520
thinking about what the user experiences

00:40:49,820 --> 00:40:55,240
and then you just write down what it is

00:40:52,520 --> 00:41:02,030
you want and let the database engine

00:40:55,240 --> 00:41:03,530
figure out what to do so you could you

00:41:02,030 --> 00:41:06,500
could add lots of interesting reports

00:41:03,530 --> 00:41:11,980
here's a report I did I transferred the

00:41:06,500 --> 00:41:15,470
Postgres git repository into a different

00:41:11,980 --> 00:41:16,970
repository that used SQL I and I you

00:41:15,470 --> 00:41:18,380
know just to find out who in the

00:41:16,970 --> 00:41:20,090
Postgres community was doing off to

00:41:18,380 --> 00:41:23,810
commit and Tom is number one and Bruce

00:41:20,090 --> 00:41:25,670
is number two okay and and you think

00:41:23,810 --> 00:41:27,320
well I think you can you can get this

00:41:25,670 --> 00:41:29,420
sort of same information off of github

00:41:27,320 --> 00:41:30,980
can you not doesn't get hub have some

00:41:29,420 --> 00:41:33,170
graphs like this so who the who the

00:41:30,980 --> 00:41:34,760
committers are and a repository you know

00:41:33,170 --> 00:41:36,620
now think about how you how would you do

00:41:34,760 --> 00:41:37,910
that if you had a git repository you'd

00:41:36,620 --> 00:41:39,470
well and then already people are

00:41:37,910 --> 00:41:40,900
starting to think well I make these

00:41:39,470 --> 00:41:43,749
particular calls it know

00:41:40,900 --> 00:41:44,079
you're doing it wrong that's how you do

00:41:43,749 --> 00:41:46,900
it

00:41:44,079 --> 00:41:48,490
that's the query that gives you the

00:41:46,900 --> 00:41:50,289
answer okay

00:41:48,490 --> 00:41:52,089
don't worry about how you go about

00:41:50,289 --> 00:41:53,529
accessing the data just take the data

00:41:52,089 --> 00:41:58,440
and then display it in a way that's

00:41:53,529 --> 00:42:01,630
useful to the end-user here's an example

00:41:58,440 --> 00:42:05,109
here's just an outrageous example of an

00:42:01,630 --> 00:42:08,950
SQ this is a query in SQL if you take

00:42:05,109 --> 00:42:13,930
this you copy it and paste it into the

00:42:08,950 --> 00:42:20,289
SQLite 3 dot exe command-line shell this

00:42:13,930 --> 00:42:23,380
is what you get no joke you could try

00:42:20,289 --> 00:42:25,269
this at home now there are actually much

00:42:23,380 --> 00:42:28,660
faster ways to compute the Mandelbrot

00:42:25,269 --> 00:42:31,119
set but and this is not a this is not a

00:42:28,660 --> 00:42:33,130
practical thing to do in SQL my point is

00:42:31,119 --> 00:42:35,289
it didn't take that many lines of code

00:42:33,130 --> 00:42:39,549
it was very compact and it would

00:42:35,289 --> 00:42:43,240
actually do it and and so SQL gives you

00:42:39,549 --> 00:42:45,609
all of this power this for free and so

00:42:43,240 --> 00:42:47,859
you can spend all of your your time

00:42:45,609 --> 00:42:50,460
focusing on providing value to your

00:42:47,859 --> 00:42:53,619
users rather than having to spend time

00:42:50,460 --> 00:42:58,299
figuring out how to move bits on and off

00:42:53,619 --> 00:43:04,930
the disk I'm going the wrong way

00:42:58,299 --> 00:43:06,249
sorry so in summary I see a lot of

00:43:04,930 --> 00:43:09,579
people getting really confused they see

00:43:06,249 --> 00:43:11,859
SQLite has SQL in the name therefore it

00:43:09,579 --> 00:43:14,680
must be something to store enterprise

00:43:11,859 --> 00:43:16,779
data and they try and do that I think

00:43:14,680 --> 00:43:19,269
SQLite is now the default when you

00:43:16,779 --> 00:43:21,099
install Ruby on Rails and they try and

00:43:19,269 --> 00:43:23,849
do massive Ruby on Rails websites with

00:43:21,099 --> 00:43:26,289
SQLite and it falls down badly because

00:43:23,849 --> 00:43:28,119
that's not what it's designed to do you

00:43:26,289 --> 00:43:30,369
know it's really convenient in Ruby on

00:43:28,119 --> 00:43:31,900
Rails when you're prototyping to have

00:43:30,369 --> 00:43:34,900
something handy not have to set up a

00:43:31,900 --> 00:43:36,249
separate server but it's not what it's

00:43:34,900 --> 00:43:37,989
designed to do it's designed to be a

00:43:36,249 --> 00:43:44,079
file format it's designed to replace F

00:43:37,989 --> 00:43:45,480
open not MySQL or Postgres top ten

00:43:44,079 --> 00:43:49,170
reasons

00:43:45,480 --> 00:43:49,170
remember these will be a quiz later

00:43:49,319 --> 00:43:55,990
three truths representation is the

00:43:53,080 --> 00:43:57,700
of computer programming it's really all

00:43:55,990 --> 00:43:59,560
about how you store your data the data

00:43:57,700 --> 00:44:01,270
is going to live longer than from the

00:43:59,560 --> 00:44:02,680
code think about how you're going to

00:44:01,270 --> 00:44:03,340
store your data because that's really

00:44:02,680 --> 00:44:05,830
important

00:44:03,340 --> 00:44:09,190
don't just be making a random pile of

00:44:05,830 --> 00:44:16,960
files and premature optimization is the

00:44:09,190 --> 00:44:19,090
root of all evil Donald Knuth so I ask

00:44:16,960 --> 00:44:22,630
you I implore you the next time your

00:44:19,090 --> 00:44:25,480
fingers start typing F open stop and

00:44:22,630 --> 00:44:28,830
think would it be better to use an

00:44:25,480 --> 00:44:34,390
SQLite database in this for this context

00:44:28,830 --> 00:44:35,770
usually the answer will be yes thank you

00:44:34,390 --> 00:44:38,110
for your attention I don't know how much

00:44:35,770 --> 00:44:44,380
time I used but I imagine we have a lot

00:44:38,110 --> 00:44:47,430
of time left for questions yeah we got

00:44:44,380 --> 00:44:57,010
15 minutes for questions if you have any

00:44:47,430 --> 00:44:58,330
yes sir I'll repeat the question yes he

00:44:57,010 --> 00:45:00,960
was thanking me for the great product

00:44:58,330 --> 00:45:00,960
thank you

00:45:13,440 --> 00:45:18,089
and it's great for a place to call home

00:45:15,780 --> 00:45:25,260
is there a minimum about like when does

00:45:18,089 --> 00:45:28,170
it too much to use as opposed to okay so

00:45:25,260 --> 00:45:30,420
the question is what's the threshold how

00:45:28,170 --> 00:45:32,940
much day do you need do you need to

00:45:30,420 --> 00:45:39,150
store before you need to move to a

00:45:32,940 --> 00:45:40,500
client server database engine or oh how

00:45:39,150 --> 00:45:44,820
much data do you need still reports

00:45:40,500 --> 00:45:56,220
useful to use SQLite I never thought of

00:45:44,820 --> 00:45:58,349
it in those terms all right so yeah

00:45:56,220 --> 00:45:59,790
so you know I advocate using SQLite for

00:45:58,349 --> 00:46:01,230
configuration files and I get a lot of

00:45:59,790 --> 00:46:02,310
pushback on that I'm surprised that

00:46:01,230 --> 00:46:04,740
nobody objected when I actually

00:46:02,310 --> 00:46:06,210
mentioned that earlier because a lot of

00:46:04,740 --> 00:46:07,710
people in this room in particular you're

00:46:06,210 --> 00:46:10,530
used to editing saying Apache

00:46:07,710 --> 00:46:12,030
configuration file or an in Jeanette's

00:46:10,530 --> 00:46:14,040
configuration file and you're like that

00:46:12,030 --> 00:46:16,080
text format is really accessible and I

00:46:14,040 --> 00:46:19,050
get that and there are places where an

00:46:16,080 --> 00:46:22,170
ASCII text configuration file works

00:46:19,050 --> 00:46:24,869
great where you'd want to consider using

00:46:22,170 --> 00:46:26,430
an SQLite for an application for a

00:46:24,869 --> 00:46:29,430
configuration file is where you're

00:46:26,430 --> 00:46:33,540
mixing binary data in with the

00:46:29,430 --> 00:46:34,710
configuration file so you know that

00:46:33,540 --> 00:46:36,270
doesn't work as well then you have to

00:46:34,710 --> 00:46:38,089
split the binary data into separate

00:46:36,270 --> 00:46:40,320
files and that doesn't work as well or

00:46:38,089 --> 00:46:42,720
where the application file is not

00:46:40,320 --> 00:46:45,990
intended to be edited by humans I mean

00:46:42,720 --> 00:46:48,390
my phone is full of configuration files

00:46:45,990 --> 00:46:49,800
and I don't edit any one of them in the

00:46:48,390 --> 00:46:53,250
text editor in fact I don't even have

00:46:49,800 --> 00:46:55,650
that capability so all of your like a

00:46:53,250 --> 00:46:56,820
phone application the configuration

00:46:55,650 --> 00:46:59,099
files for that are going to be done by

00:46:56,820 --> 00:47:02,070
program control and it's usually much

00:46:59,099 --> 00:47:06,000
better to do that with SQLite because

00:47:02,070 --> 00:47:08,250
it's much easier for a program to use

00:47:06,000 --> 00:47:11,310
SQLite than it is to do an ASCII text

00:47:08,250 --> 00:47:13,800
format it's also reusable that way yeah

00:47:11,310 --> 00:47:16,349
I get the idea though that Apache I'm

00:47:13,800 --> 00:47:17,820
not I'm not recommending the Apache

00:47:16,349 --> 00:47:19,440
change to an SQLite database for the

00:47:17,820 --> 00:47:20,760
configuration file though there are some

00:47:19,440 --> 00:47:23,550
interesting things that could be done if

00:47:20,760 --> 00:47:25,410
they were to do that but I do I get that

00:47:23,550 --> 00:47:28,230
yes yes

00:47:25,410 --> 00:47:35,100
like my my own like a small framework

00:47:28,230 --> 00:47:36,450
yes and your versioning it right and and

00:47:35,100 --> 00:47:38,910
if what you cuz you can you can also

00:47:36,450 --> 00:47:41,070
version a database but you can't dip it

00:47:38,910 --> 00:47:42,990
is the problem yeah and so there there

00:47:41,070 --> 00:47:46,320
are there are there are cases where a

00:47:42,990 --> 00:47:49,170
simple text file will still do was still

00:47:46,320 --> 00:47:51,240
better but there's also a lot of cases

00:47:49,170 --> 00:47:52,620
the majority of cases the ones you're

00:47:51,240 --> 00:47:54,300
not thinking about like the ones on the

00:47:52,620 --> 00:47:59,280
phone are the ones on any kind of

00:47:54,300 --> 00:48:00,570
Windows box they were done by program

00:47:59,280 --> 00:48:12,120
control and you want this in a database

00:48:00,570 --> 00:48:13,380
question right here alright so the

00:48:12,120 --> 00:48:15,810
comment is if you can't change the

00:48:13,380 --> 00:48:18,750
configuration was said he's not putting

00:48:15,810 --> 00:48:21,480
it on his system yeah I get a lot of

00:48:18,750 --> 00:48:23,970
pushback about that yeah as a server as

00:48:21,480 --> 00:48:25,590
a server administrator well you know and

00:48:23,970 --> 00:48:27,240
and that's what you're used to used to

00:48:25,590 --> 00:48:31,020
using said or whatever to change your

00:48:27,240 --> 00:48:32,550
configuration files you've got the tools

00:48:31,020 --> 00:48:33,660
in place and that's what you're doing

00:48:32,550 --> 00:48:36,660
and you know I'm not trying to push you

00:48:33,660 --> 00:48:39,210
to change but if you had grown up doing

00:48:36,660 --> 00:48:43,320
them all with SQL commands you would be

00:48:39,210 --> 00:48:49,230
doing less work today okay I'm just

00:48:43,320 --> 00:48:50,670
saying you've got to learn a new schema

00:48:49,230 --> 00:48:53,090
for every text file that you're editing

00:48:50,670 --> 00:48:53,090
to

00:49:02,710 --> 00:49:09,369
couldn't be no you're right you're right

00:49:05,580 --> 00:49:12,490
and as long as I have a sequel binary

00:49:09,369 --> 00:49:14,650
that I could and there's a there's an

00:49:12,490 --> 00:49:20,770
SQLite binary that you can run on every

00:49:14,650 --> 00:49:22,869
machine that you got okay I'm okay I get

00:49:20,770 --> 00:49:24,400
I do get a little bit of skepticism from

00:49:22,869 --> 00:49:26,050
from the configuration management people

00:49:24,400 --> 00:49:31,060
who are used to bringing up to the I and

00:49:26,050 --> 00:49:33,190
going to town I get that I really do but

00:49:31,060 --> 00:49:37,540
have you ever ever emanuelly edited the

00:49:33,190 --> 00:49:41,500
configuration file for Firefox yes okay

00:49:37,540 --> 00:49:48,220
you are hardcore not many people have

00:49:41,500 --> 00:49:49,960
actually done that yes you you can

00:49:48,220 --> 00:49:51,760
actually do things in Firefox by

00:49:49,960 --> 00:49:53,619
manually editing the configuration files

00:49:51,760 --> 00:49:55,570
that you cannot do from the graphical

00:49:53,619 --> 00:50:07,990
interface I don't even know where that

00:49:55,570 --> 00:50:10,660
file is on my computer okay and there is

00:50:07,990 --> 00:50:14,020
user level configuration and then there

00:50:10,660 --> 00:50:17,800
is user data for application level

00:50:14,020 --> 00:50:20,369
configuration I would argue still use

00:50:17,800 --> 00:50:24,300
flat text files user level configuration

00:50:20,369 --> 00:50:24,300
stuff them in sequel Lite

00:50:32,860 --> 00:50:38,060
it's a hard line to draw bottom I don't

00:50:36,170 --> 00:50:39,350
have an easy answer pets it's an actor

00:50:38,060 --> 00:50:41,660
problem yeah

00:50:39,350 --> 00:50:45,590
if it's a user stuff gonna see boy if

00:50:41,660 --> 00:50:47,330
it's an administrator okay yeah now

00:50:45,590 --> 00:50:48,410
Chris I'm biased toward SQLite I mean

00:50:47,330 --> 00:50:51,680
you know if you have a Hammer Every

00:50:48,410 --> 00:50:53,000
Problem looks like a nail so so I tend

00:50:51,680 --> 00:50:55,550
to put everything in SEO life but that's

00:50:53,000 --> 00:50:57,050
just me alright the brown the guy with

00:50:55,550 --> 00:50:58,520
the brown - yeah that use you the ones

00:50:57,050 --> 00:51:13,520
looking around yet you had your hand up

00:50:58,520 --> 00:51:14,390
first that's great oh yeah do it do it

00:51:13,520 --> 00:51:16,850
do it

00:51:14,390 --> 00:51:19,850
absolutely um some database engines

00:51:16,850 --> 00:51:23,450
don't do real well with binary I went to

00:51:19,850 --> 00:51:25,820
the talk yesterday on it was the for

00:51:23,450 --> 00:51:30,470
Mirai DB and it's the the fast way of

00:51:25,820 --> 00:51:33,110
getting data in and out is called handle

00:51:30,470 --> 00:51:35,900
or socket and it will not do bind your

00:51:33,110 --> 00:51:37,970
data for example because apparently if

00:51:35,900 --> 00:51:42,560
you're in the - cure world you only

00:51:37,970 --> 00:51:47,060
store numbers and text I I don't know

00:51:42,560 --> 00:51:48,230
why that is apart me Oh but and the

00:51:47,060 --> 00:51:49,640
reason that is it because you store

00:51:48,230 --> 00:51:52,070
anything bigger than numbers and text it

00:51:49,640 --> 00:51:54,230
loses it okay I don't know about that I

00:51:52,070 --> 00:51:58,360
don't have any information on that but

00:51:54,230 --> 00:52:03,080
yeah I mean it's no problem to store

00:51:58,360 --> 00:52:05,000
truly massive binaries blobs in SQLite

00:52:03,080 --> 00:52:10,010
and it stores them reliably megabytes

00:52:05,000 --> 00:52:12,170
tens of megabytes formas tends to go

00:52:10,010 --> 00:52:14,630
down off of just if you store 10

00:52:12,170 --> 00:52:15,710
megabyte blob I mean if you're just

00:52:14,630 --> 00:52:17,420
reading one blob it's still

00:52:15,710 --> 00:52:19,670
instantaneous with modern hardware okay

00:52:17,420 --> 00:52:21,380
but it's still slower than if you were

00:52:19,670 --> 00:52:27,470
to open it and read it directly off the

00:52:21,380 --> 00:52:29,570
disk but you but at the same time it you

00:52:27,470 --> 00:52:31,310
get transactions so that if you're

00:52:29,570 --> 00:52:34,820
you're riding - if you're riding that

00:52:31,310 --> 00:52:37,369
blob back out and you lose power you've

00:52:34,820 --> 00:52:40,849
not corrupted it

00:52:37,369 --> 00:52:42,619
you've not corrupted the blob well if it

00:52:40,849 --> 00:52:44,180
you either you either have the old

00:52:42,619 --> 00:52:46,579
version and you have the new version you

00:52:44,180 --> 00:52:49,609
don't have anything in between it's an

00:52:46,579 --> 00:52:50,960
atomic operation which is depending on

00:52:49,609 --> 00:52:52,369
what that blob is can be an important

00:52:50,960 --> 00:52:55,430
thing

00:52:52,369 --> 00:52:57,489
so certainly smaller blocks like

00:52:55,430 --> 00:52:59,180
thumbnails you know up to 100 K

00:52:57,489 --> 00:53:12,829
definitely store them in your database

00:52:59,180 --> 00:53:14,749
that's the right thing to do no writing

00:53:12,829 --> 00:53:16,279
blobs to the database file does not slow

00:53:14,749 --> 00:53:18,920
down access to other fields in the

00:53:16,279 --> 00:53:21,499
database well I say that if you've got a

00:53:18,920 --> 00:53:23,599
blob and other data on the same row in

00:53:21,499 --> 00:53:26,479
the same table you want to put the big

00:53:23,599 --> 00:53:28,779
blob at the end otherwise it has to seek

00:53:26,479 --> 00:53:31,549
past the blob to get to your other data

00:53:28,779 --> 00:53:32,900
so other than that fact if they're

00:53:31,549 --> 00:53:35,029
throwing different tables or on

00:53:32,900 --> 00:53:39,309
different rows of the same table it

00:53:35,029 --> 00:53:41,660
doesn't effect impact in it does not

00:53:39,309 --> 00:53:47,259
detract from the performance in any way

00:53:41,660 --> 00:53:51,019
okay question and the light green shirt

00:53:47,259 --> 00:53:53,200
okay more more configuration file push

00:53:51,019 --> 00:53:53,200
back

00:54:03,520 --> 00:54:18,410
yeah and so you're storing user

00:54:06,380 --> 00:54:21,220
documents the comment is that that you

00:54:18,410 --> 00:54:29,630
know storing configuration files that's

00:54:21,220 --> 00:54:31,910
yeah yeah but if I if we run if you were

00:54:29,630 --> 00:54:35,320
gonna write a website or a desktop

00:54:31,910 --> 00:54:38,480
application to say configure X I NAT D

00:54:35,320 --> 00:54:40,130
wouldn't you rather be able to just poke

00:54:38,480 --> 00:54:41,750
into a database rather than having to

00:54:40,130 --> 00:54:44,600
read and parse these database files I

00:54:41,750 --> 00:54:55,420
mean the text files for X X on it D for

00:54:44,600 --> 00:54:55,420
example yeah

00:55:06,710 --> 00:55:12,450
so you're looking at the set the the

00:55:09,420 --> 00:55:15,240
files and antia scripts as opposed to

00:55:12,450 --> 00:55:21,170
code as opposed to data they're scripts

00:55:15,240 --> 00:55:21,170
I get that yeah yeah all right

00:55:43,080 --> 00:55:47,970
yes the comment was yeah if it's

00:55:46,320 --> 00:55:51,390
changing at runtime you want a database

00:55:47,970 --> 00:55:53,210
and if it's constant possibly in the

00:55:51,390 --> 00:55:56,580
read-only layer of your puppy

00:55:53,210 --> 00:56:32,910
distribution then leave it as a text one

00:55:56,580 --> 00:56:35,130
in the back yes all right so the

00:56:32,910 --> 00:56:40,760
question is can you encrypt an SQLite

00:56:35,130 --> 00:56:43,350
database and in fact you can and in fact

00:56:40,760 --> 00:56:46,080
some of those applications that I showed

00:56:43,350 --> 00:56:48,960
you up there in addition to having the

00:56:46,080 --> 00:56:52,620
public SQLite databases that you can

00:56:48,960 --> 00:56:54,330
read using cryptid databases I won't

00:56:52,620 --> 00:56:55,500
name particular applications you can go

00:56:54,330 --> 00:56:59,070
back and figure it out for yourself

00:56:55,500 --> 00:57:01,140
which ones encrypt their data we said

00:56:59,070 --> 00:57:03,240
with the encryption part is not public

00:57:01,140 --> 00:57:05,070
domain we sell that as an extension

00:57:03,240 --> 00:57:08,130
that's one of the one of the one of the

00:57:05,070 --> 00:57:10,200
ways we you know support the business in

00:57:08,130 --> 00:57:11,460
our business there's I've got three guys

00:57:10,200 --> 00:57:14,880
working on this maintaining it for

00:57:11,460 --> 00:57:17,370
everybody in the world and we sell you

00:57:14,880 --> 00:57:19,080
know paid support and then we got these

00:57:17,370 --> 00:57:22,200
extensions like like an encryption

00:57:19,080 --> 00:57:23,910
extension but even if it's not encrypted

00:57:22,200 --> 00:57:25,890
the people to doing that are doing

00:57:23,910 --> 00:57:27,690
forensic analysis they tend to need a

00:57:25,890 --> 00:57:29,610
lot of help in figuring out what what

00:57:27,690 --> 00:57:30,870
the bits actually mean because when

00:57:29,610 --> 00:57:32,580
they're doing the forensic analysis I'm

00:57:30,870 --> 00:57:35,460
not getting an intact database what

00:57:32,580 --> 00:57:38,460
they've done is they've gone and and an

00:57:35,460 --> 00:57:40,470
image to disk and found some sectors in

00:57:38,460 --> 00:57:42,660
there that have been deleted but not

00:57:40,470 --> 00:57:44,280
overwritten and there's you know well

00:57:42,660 --> 00:57:46,260
this must be part of an SQLite database

00:57:44,280 --> 00:57:47,460
and then they're trying to decode what

00:57:46,260 --> 00:57:48,840
that means it doesn't have the complete

00:57:47,460 --> 00:57:50,580
context you can't just put it into the

00:57:48,840 --> 00:57:53,220
browser and are

00:57:50,580 --> 00:57:54,660
I put it into sqlite3 and into queries

00:57:53,220 --> 00:57:56,930
against him because it's incomplete I

00:57:54,660 --> 00:58:24,480
have two minutes left

00:57:56,930 --> 00:58:26,910
yes sir yeah so the question is does

00:58:24,480 --> 00:58:29,730
SQLite support caching so that if you

00:58:26,910 --> 00:58:31,830
repeat a query it remembers the previous

00:58:29,730 --> 00:58:36,870
query in cash and just returns the

00:58:31,830 --> 00:58:38,310
cached version yeah you there are

00:58:36,870 --> 00:58:40,770
facilities to do that but the

00:58:38,310 --> 00:58:42,090
application needs to to get involved a

00:58:40,770 --> 00:58:44,130
little bit there are facilities that

00:58:42,090 --> 00:58:45,660
enable that and I get a lot of I've been

00:58:44,130 --> 00:58:46,650
getting a lot of pressure I have one

00:58:45,660 --> 00:58:48,810
minute left I'm getting a lot of

00:58:46,650 --> 00:58:50,160
pressure to build that in and make it

00:58:48,810 --> 00:58:51,600
automatic so that your application

00:58:50,160 --> 00:58:53,970
doesn't have to worry about it but yeah

00:58:51,600 --> 00:58:55,290
that can be done and but the it because

00:58:53,970 --> 00:58:58,320
you're not going across a network to a

00:58:55,290 --> 00:58:59,430
server it's pretty quick and also

00:58:58,320 --> 00:59:01,920
because you're only got a single

00:58:59,430 --> 00:59:04,290
application working on it you tend not

00:59:01,920 --> 00:59:05,310
to get repeated queries because that

00:59:04,290 --> 00:59:07,380
application already knows the answer

00:59:05,310 --> 00:59:09,000
it's really handy with a client server

00:59:07,380 --> 00:59:11,670
we have multiple clients are asking the

00:59:09,000 --> 00:59:13,410
same thing but here it's just a single

00:59:11,670 --> 00:59:14,520
client so you don't ok we're probably I

00:59:13,410 --> 00:59:16,140
think we're pretty much out of set out

00:59:14,520 --> 00:59:19,260
of time but I'm happy to I'll be around

00:59:16,140 --> 00:59:20,580
all day and we can talk later if anybody

00:59:19,260 --> 00:59:22,410
is interested thank you very much for

00:59:20,580 --> 00:59:24,620
coming and being attentive thank you so

00:59:22,410 --> 00:59:24,620
much

01:00:01,800 --> 01:00:06,070
your customers rely on your website or

01:00:04,570 --> 01:00:08,440
application if it's slower

01:00:06,070 --> 01:00:11,410
non-responsive it infuriates your users

01:00:08,440 --> 01:00:13,210
and costs you money keeping your

01:00:11,410 --> 01:00:16,700
business critical systems humming along

01:00:13,210 --> 01:00:19,550
requires insight into what they're doing

01:00:16,700 --> 01:00:21,560
your system metrics tell stories stories

01:00:19,550 --> 01:00:23,810
that can reveal performance bottlenecks

01:00:21,560 --> 01:00:26,089
resource limitations and other problems

01:00:23,810 --> 01:00:28,190
but how do you keep an eye on all of

01:00:26,089 --> 01:00:30,470
your systems performance metrics in real

01:00:28,190 --> 01:00:33,320
time and record this data for a liter

01:00:30,470 --> 01:00:35,300
analysis enter long view the new way to

01:00:33,320 --> 01:00:37,339
see what's really going on under the

01:00:35,300 --> 01:00:39,530
hood the long view dashboard lets you

01:00:37,339 --> 01:00:41,450
visualize the status of all your systems

01:00:39,530 --> 01:00:44,359
providing you with a bird's-eye view of

01:00:41,450 --> 01:00:47,300
your entire fleet you can sort by CPU

01:00:44,359 --> 01:00:50,000
memory swap processes load and network

01:00:47,300 --> 01:00:52,339
usage click a specific system to access

01:00:50,000 --> 01:00:54,349
its individual dashboard then click and

01:00:52,339 --> 01:00:57,349
drag to zoom in on chokepoints and get

01:00:54,349 --> 01:00:59,329
more detail comprehensive Network data

01:00:57,349 --> 01:01:02,030
including inbound and outbound traffic

01:00:59,329 --> 01:01:04,010
is available on the network tab and disk

01:01:02,030 --> 01:01:06,170
writes and free space on the disk stab

01:01:04,010 --> 01:01:08,359
while the process Explorer displays

01:01:06,170 --> 01:01:10,940
usage statistics for individual

01:01:08,359 --> 01:01:13,070
processes the system info tab shows

01:01:10,940 --> 01:01:15,470
listening services active connections

01:01:13,070 --> 01:01:17,599
and available updates adding longview to

01:01:15,470 --> 01:01:19,849
a system is easy just click the button

01:01:17,599 --> 01:01:21,650
copy the one-line installation command

01:01:19,849 --> 01:01:24,170
then run the command on your Linux

01:01:21,650 --> 01:01:26,060
system to complete the process the agent

01:01:24,170 --> 01:01:27,950
will begin collecting data and sending

01:01:26,060 --> 01:01:29,490
it to long view then the graphs start

01:01:27,950 --> 01:01:32,040
rolling

01:01:29,490 --> 01:01:34,200
use Longview to gain visibility into

01:01:32,040 --> 01:01:38,150
your servers so when your website or app

01:01:34,200 --> 01:01:38,150

YouTube URL: https://www.youtube.com/watch?v=8y_ABXwYtuc


