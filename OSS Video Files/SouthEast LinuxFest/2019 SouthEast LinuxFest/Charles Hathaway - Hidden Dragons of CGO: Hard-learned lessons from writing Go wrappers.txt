Title: Charles Hathaway - Hidden Dragons of CGO: Hard-learned lessons from writing Go wrappers
Publication date: 2019-06-18
Playlist: 2019 SouthEast LinuxFest
Description: 
	SouthEast Linux Fest 2019
Go ([https://golang.org](https://golang.org)) is a popular language for writing highly concurrent software, and works well when used in isolation.
Using Go alongside software written in other languages (such as C) can be done, but there are some hidden dragons to keep an eye out for.
At YottaDB we've encountered a few of them while writing our wrappers; hopefully we can steer the next adventure on the right path!
Captions: 
	00:00:00,030 --> 00:00:08,700
yeah morning everybody thank you for

00:00:06,750 --> 00:00:12,269
coming out for this chat I'll be talking

00:00:08,700 --> 00:00:14,610
about Sego which is the goal library for

00:00:12,269 --> 00:00:16,410
accessing C code for those who don't

00:00:14,610 --> 00:00:17,369
know I'm Charles Hathaway I work at Yana

00:00:16,410 --> 00:00:19,740
dB

00:00:17,369 --> 00:00:21,570
one thing we do a yachtie DP is write

00:00:19,740 --> 00:00:23,400
wrappers for our database engine in a

00:00:21,570 --> 00:00:25,320
variety of languages one of those

00:00:23,400 --> 00:00:28,109
languages is go it has been a

00:00:25,320 --> 00:00:30,210
challenging road I'll be the first to

00:00:28,109 --> 00:00:32,189
come out and say we still have a little

00:00:30,210 --> 00:00:34,950
bit of distance left to travel on the

00:00:32,189 --> 00:00:37,380
road so if anybody here is a Sego expert

00:00:34,950 --> 00:00:39,270
and wants to comment or ask questions it

00:00:37,380 --> 00:00:41,730
may help us in solving some problems we

00:00:39,270 --> 00:00:42,930
continue to have if you can't do that

00:00:41,730 --> 00:00:44,820
that's totally fine

00:00:42,930 --> 00:00:46,829
I still love questions so feel free to

00:00:44,820 --> 00:00:47,370
ask them as I'm presenting just raise

00:00:46,829 --> 00:00:53,820
your hand

00:00:47,370 --> 00:00:55,140
shout out good all right so I'm gonna

00:00:53,820 --> 00:00:57,930
start by doing a quick review of what

00:00:55,140 --> 00:01:00,289
Yana DB is what NGO is and what C is

00:00:57,930 --> 00:01:03,979
does anybody here not know what C is

00:01:00,289 --> 00:01:06,900
does anybody here not know what NGO is

00:01:03,979 --> 00:01:10,260
okay great

00:01:06,900 --> 00:01:12,900
yada DB is a no sequel database engine

00:01:10,260 --> 00:01:14,460
it's a hierarchical key value store that

00:01:12,900 --> 00:01:16,920
does very very good with transaction

00:01:14,460 --> 00:01:18,299
processing operates on a single node

00:01:16,920 --> 00:01:20,670
rather than a cluster so that we can

00:01:18,299 --> 00:01:23,939
have strong acid guarantees which are

00:01:20,670 --> 00:01:25,200
valuable to very many applications it's

00:01:23,939 --> 00:01:27,360
deployed in a number of industries

00:01:25,200 --> 00:01:29,640
healthcare finance leading among them

00:01:27,360 --> 00:01:31,290
where it's been for quite some time or

00:01:29,640 --> 00:01:32,299
where it's code base has been for some

00:01:31,290 --> 00:01:34,799
time

00:01:32,299 --> 00:01:38,600
although yadda DB is young our code base

00:01:34,799 --> 00:01:42,060
has a long strong lineage starting as a

00:01:38,600 --> 00:01:43,710
product which I shall not name and so we

00:01:42,060 --> 00:01:46,259
know that the product works because it's

00:01:43,710 --> 00:01:48,450
been powering applications for many many

00:01:46,259 --> 00:01:51,119
years all right

00:01:48,450 --> 00:01:55,700
go is a little bit newer I think it came

00:01:51,119 --> 00:01:55,700
out in the early 2010's it is a

00:01:55,759 --> 00:02:01,680
garbage-collected programming language

00:01:57,930 --> 00:02:03,030
with static typing one big thing that it

00:02:01,680 --> 00:02:06,000
does that it's very well known for is

00:02:03,030 --> 00:02:07,590
very good concurrency paradigms so what

00:02:06,000 --> 00:02:10,170
it does is take some ideas from ear lang

00:02:07,590 --> 00:02:12,060
where we have multiple threads that

00:02:10,170 --> 00:02:14,370
communicate amongst each other and the

00:02:12,060 --> 00:02:16,860
they do multi-threading by passing

00:02:14,370 --> 00:02:20,310
information between them and it mixes

00:02:16,860 --> 00:02:21,480
that with a little bit of C ish code so

00:02:20,310 --> 00:02:24,000
you're laying for those who don't know

00:02:21,480 --> 00:02:26,280
is functional C is not a functional

00:02:24,000 --> 00:02:29,310
language and turns out people kind of

00:02:26,280 --> 00:02:31,650
like non functional paradigms because

00:02:29,310 --> 00:02:35,760
they're a little bit easier to use so go

00:02:31,650 --> 00:02:38,940
is this mix of all these I don't know

00:02:35,760 --> 00:02:40,890
best parts worst parts of C ear laying

00:02:38,940 --> 00:02:43,770
Java take your pick

00:02:40,890 --> 00:02:45,300
we have a fake inheritance type thing we

00:02:43,770 --> 00:02:49,110
can do where we implement traits on

00:02:45,300 --> 00:02:51,989
certain data types to allow you to

00:02:49,110 --> 00:02:54,300
perform class-based

00:02:51,989 --> 00:02:56,040
type things but that's not really what

00:02:54,300 --> 00:02:58,680
it is so it's it's a language in of

00:02:56,040 --> 00:03:00,690
itself and it's it's all kind of fun

00:02:58,680 --> 00:03:02,970
the big thing it has going for you for

00:03:00,690 --> 00:03:04,769
it is the cooperative multi-threading so

00:03:02,970 --> 00:03:06,989
the idea is that it spawns off six

00:03:04,769 --> 00:03:09,810
system threads and then you can spawn

00:03:06,989 --> 00:03:12,030
off as many go routines which can

00:03:09,810 --> 00:03:14,910
execute on an arbitrary thread as you

00:03:12,030 --> 00:03:17,430
want as in hundreds of thousands or

00:03:14,910 --> 00:03:22,049
millions and it doesn't care right so

00:03:17,430 --> 00:03:24,180
that's its strong point C is a low-level

00:03:22,049 --> 00:03:27,209
programming language which started life

00:03:24,180 --> 00:03:29,190
in the 1970s I believe it's a little bit

00:03:27,209 --> 00:03:32,970
older than go a little bit older than

00:03:29,190 --> 00:03:38,670
the ahta DB it's everywhere all right

00:03:32,970 --> 00:03:40,049
so Linux is written in C yes all right

00:03:38,670 --> 00:03:42,329
and then we all know what that is

00:03:40,049 --> 00:03:44,989
we have other important projects written

00:03:42,329 --> 00:03:48,269
in C including Apache including uh I

00:03:44,989 --> 00:03:50,730
don't know I hear something about an NTP

00:03:48,269 --> 00:03:53,880
program that was once written NC things

00:03:50,730 --> 00:03:55,440
like that one of the strong benefits of

00:03:53,880 --> 00:03:56,820
C is it's relatively close to the

00:03:55,440 --> 00:03:59,820
hardware so you have a lot of control

00:03:56,820 --> 00:04:02,250
over how you do access to the data types

00:03:59,820 --> 00:04:05,340
right so you can cast a 32 bit integer

00:04:02,250 --> 00:04:07,380
as a four byte character array and then

00:04:05,340 --> 00:04:09,000
from there you can access each byte of

00:04:07,380 --> 00:04:11,459
the integer directly and perform

00:04:09,000 --> 00:04:13,440
manipulation on that so being so close

00:04:11,459 --> 00:04:15,000
to the language to the to the hardware

00:04:13,440 --> 00:04:18,030
you get a lot of power

00:04:15,000 --> 00:04:20,099
it's very expressive just don't screw up

00:04:18,030 --> 00:04:22,109
right if you screw up you can shoot

00:04:20,099 --> 00:04:24,510
yourself in the foot see it'll say good

00:04:22,109 --> 00:04:26,840
keep on doing that and when you get out

00:04:24,510 --> 00:04:29,540
of the hospital let me know

00:04:26,840 --> 00:04:30,770
it does do static typing however it does

00:04:29,540 --> 00:04:35,210
not have any kind of garbage collection

00:04:30,770 --> 00:04:37,640
you use system calls like malloc and

00:04:35,210 --> 00:04:39,050
free in order to allocate memory and

00:04:37,640 --> 00:04:41,350
then you are responsible for later

00:04:39,050 --> 00:04:46,790
freeing it should you fail to free it

00:04:41,350 --> 00:04:48,020
memory leak write questions on C we all

00:04:46,790 --> 00:04:55,700
know it so I'm gonna keep going

00:04:48,020 --> 00:04:57,500
alright so golang calling in to C so one

00:04:55,700 --> 00:05:00,890
reason we want to do this for yadda DB

00:04:57,500 --> 00:05:02,330
specifically is we exposed AC API which

00:05:00,890 --> 00:05:04,130
allows you to interface with the

00:05:02,330 --> 00:05:08,540
database engine directly as if it was a

00:05:04,130 --> 00:05:11,870
library in addition I mean you have a

00:05:08,540 --> 00:05:14,090
whole bunch of C applications that have

00:05:11,870 --> 00:05:15,680
a lot of functionality and it would be

00:05:14,090 --> 00:05:17,900
wonderful to be able to access those

00:05:15,680 --> 00:05:20,180
from go so the go dev team made

00:05:17,900 --> 00:05:23,570
something called C go which is a very

00:05:20,180 --> 00:05:27,650
creative name which gives you a way to

00:05:23,570 --> 00:05:30,860
call C code at runtime and it does this

00:05:27,650 --> 00:05:32,690
by allowing you to link against C code

00:05:30,860 --> 00:05:34,520
during their compilation process they

00:05:32,690 --> 00:05:36,260
have some additional hooks in there to

00:05:34,520 --> 00:05:39,440
give you the opportunity to include

00:05:36,260 --> 00:05:41,180
things like package library paths

00:05:39,440 --> 00:05:43,340
include directories things like that

00:05:41,180 --> 00:05:44,510
those are handled by comments I don't

00:05:43,340 --> 00:05:46,430
actually spend a lot of time on those

00:05:44,510 --> 00:05:49,419
because we have plenty to talk about and

00:05:46,430 --> 00:05:53,210
they're kind of the busywork of the day

00:05:49,419 --> 00:05:55,400
all right more interesting challenge

00:05:53,210 --> 00:05:57,950
here is that go is garbage collected

00:05:55,400 --> 00:05:59,390
which means you know when you're done

00:05:57,950 --> 00:06:02,060
with an object it eventually gets

00:05:59,390 --> 00:06:04,700
cleaned up and freed C is not garbage

00:06:02,060 --> 00:06:07,010
collected so resolving the conflict in

00:06:04,700 --> 00:06:13,360
those two paradigms makes for some

00:06:07,010 --> 00:06:16,940
interesting work C go has a very long

00:06:13,360 --> 00:06:19,220
webpage that is a wall of text and it

00:06:16,940 --> 00:06:21,169
establishes a lot of rules about how you

00:06:19,220 --> 00:06:23,680
use C go what kind of additional

00:06:21,169 --> 00:06:28,610
utilities it provides in addition to say

00:06:23,680 --> 00:06:31,100
just calling it one of the things that

00:06:28,610 --> 00:06:34,360
goes over very very clearly is the rules

00:06:31,100 --> 00:06:37,210
by which you may pass things into C go

00:06:34,360 --> 00:06:39,910
I'm going to read this

00:06:37,210 --> 00:06:41,800
and my point in reading this is that it

00:06:39,910 --> 00:06:45,370
is a block of text which is a little bit

00:06:41,800 --> 00:06:48,190
hard to parse and hard to remember go

00:06:45,370 --> 00:06:50,470
code may pass a go pointer to C provided

00:06:48,190 --> 00:06:53,020
the go memory to which appoints does not

00:06:50,470 --> 00:06:54,190
contain any go pointers the C code must

00:06:53,020 --> 00:06:56,080
preserve this property

00:06:54,190 --> 00:06:58,539
it must not store any Co pointers and go

00:06:56,080 --> 00:07:00,460
memory even temporarily when passing a

00:06:58,539 --> 00:07:01,810
pointer to a field and instruct the go

00:07:00,460 --> 00:07:03,850
memory in question is the memory

00:07:01,810 --> 00:07:06,130
occupied by the field not the entire

00:07:03,850 --> 00:07:08,169
struct when passing a pointer to an

00:07:06,130 --> 00:07:10,060
element in an array or slice the go

00:07:08,169 --> 00:07:13,800
memory in question is the entire array

00:07:10,060 --> 00:07:20,199
or the entire backing array of the slice

00:07:13,800 --> 00:07:22,020
okay the gist gist is that we're not

00:07:20,199 --> 00:07:25,240
supposed to pass pointers to goal and

00:07:22,020 --> 00:07:28,120
the idea is that we want to allow go to

00:07:25,240 --> 00:07:30,190
perform memory management so we want to

00:07:28,120 --> 00:07:32,289
avoid passing embedded pointers because

00:07:30,190 --> 00:07:34,479
things may be garbage collected they may

00:07:32,289 --> 00:07:37,479
be moved around and they may just kind

00:07:34,479 --> 00:07:39,039
of vanish right and if we pass pointer

00:07:37,479 --> 00:07:42,039
to those things C tries to write to that

00:07:39,039 --> 00:07:44,110
memory location bad things happen so I'm

00:07:42,039 --> 00:07:47,139
going to go over a bunch of examples of

00:07:44,110 --> 00:07:48,789
things you can and can't do and go in C

00:07:47,139 --> 00:07:51,460
go and as we do this we start to see

00:07:48,789 --> 00:07:56,250
some of the Dragons that are hidden

00:07:51,460 --> 00:07:59,860
within the depths of go and see go

00:07:56,250 --> 00:08:02,470
here's kind of the most simple example

00:07:59,860 --> 00:08:04,510
of seiga that I could find or that I

00:08:02,470 --> 00:08:06,099
could make we declare a function in C

00:08:04,510 --> 00:08:08,949
called my func

00:08:06,099 --> 00:08:12,159
which takes an integer argument adds 42

00:08:08,949 --> 00:08:15,820
and returns the value and then and go we

00:08:12,159 --> 00:08:20,320
import C and we call that function this

00:08:15,820 --> 00:08:23,020
is super easy right no problems we could

00:08:20,320 --> 00:08:24,430
also do this with characters and in this

00:08:23,020 --> 00:08:27,639
case the character will be interpreted

00:08:24,430 --> 00:08:30,250
as an integer but nobody really uses

00:08:27,639 --> 00:08:32,529
characters for integers because we have

00:08:30,250 --> 00:08:36,190
integers instead we tend to use

00:08:32,529 --> 00:08:38,289
characters for Strings unfortunately

00:08:36,190 --> 00:08:41,260
those notion of a string is different

00:08:38,289 --> 00:08:43,029
than seas ocean of a string one reason

00:08:41,260 --> 00:08:46,420
why is it uses you I believe it supports

00:08:43,029 --> 00:08:49,940
utf-8 stuff and C that gets a little bit

00:08:46,420 --> 00:08:53,510
more fun so if we try passing a

00:08:49,940 --> 00:08:56,780
go string into AC function we get a

00:08:53,510 --> 00:08:59,840
compilation error cannot use hello world

00:08:56,780 --> 00:09:07,570
type string as type star C type char in

00:08:59,840 --> 00:09:09,950
argument to see funk my funk alright so

00:09:07,570 --> 00:09:11,690
yeah we can't just pass strings like

00:09:09,950 --> 00:09:14,420
that we got to find a way to work around

00:09:11,690 --> 00:09:17,000
it there's a few different ways we can

00:09:14,420 --> 00:09:18,890
do this I'm gonna start kind of taking a

00:09:17,000 --> 00:09:22,250
iterative approach we work our way to a

00:09:18,890 --> 00:09:25,130
solution that makes sense and is a

00:09:22,250 --> 00:09:26,720
little bit robust first thing we could

00:09:25,130 --> 00:09:28,940
try doing is moving the string into a

00:09:26,720 --> 00:09:30,320
variable you get the same thing that's

00:09:28,940 --> 00:09:33,020
not really different but it helps me in

00:09:30,320 --> 00:09:40,420
reorganizing my code a smidgen then

00:09:33,020 --> 00:09:43,130
let's take a pointer to the string right

00:09:40,420 --> 00:09:44,960
so what we do here is we interpret the

00:09:43,130 --> 00:09:47,870
string as an array of bytes which is

00:09:44,960 --> 00:09:50,990
basically what it is we do an unsafe

00:09:47,870 --> 00:09:55,330
pointer to the first to a reference to

00:09:50,990 --> 00:09:58,670
the first element in the array that

00:09:55,330 --> 00:10:02,300
represents the string anybody here

00:09:58,670 --> 00:10:03,920
familiar with ghost slices anybody want

00:10:02,300 --> 00:10:10,010
to speculate on why we can't just pass a

00:10:03,920 --> 00:10:15,710
slice in slices and the data itself

00:10:10,010 --> 00:10:17,300
right it's a pointer and it also has the

00:10:15,710 --> 00:10:20,060
length of the point of the thing that

00:10:17,300 --> 00:10:23,090
points to and the length available of

00:10:20,060 --> 00:10:25,220
the thing appoints to but it contains a

00:10:23,090 --> 00:10:26,600
go pointer so we can't pass a slice

00:10:25,220 --> 00:10:28,610
directly instead we have to do this

00:10:26,600 --> 00:10:30,350
funny little thing where we get the

00:10:28,610 --> 00:10:32,030
first element in the underlying array

00:10:30,350 --> 00:10:37,100
and then take the memory address of that

00:10:32,030 --> 00:10:40,720
and pass that in to C go so this is a

00:10:37,100 --> 00:10:44,810
good first go at attempting to pass

00:10:40,720 --> 00:10:47,150
string into C go important things to

00:10:44,810 --> 00:10:51,220
note is that the string is still garbage

00:10:47,150 --> 00:10:51,220
collected so C go will

00:10:59,150 --> 00:11:06,590
who is we

00:11:00,780 --> 00:11:06,590
and which was okay and you're referring

00:11:26,110 --> 00:11:34,150
what is the Mac OS six memory model okay

00:12:03,460 --> 00:12:15,740
that's I'm not I'm not sure that what

00:12:14,240 --> 00:12:18,290
you're saying map to exactly what

00:12:15,740 --> 00:12:19,640
happens and go but I'm interested in

00:12:18,290 --> 00:12:21,890
what you mean by you when you say

00:12:19,640 --> 00:12:24,610
mistake are you saying that that methods

00:12:21,890 --> 00:12:24,610
too complex

00:12:33,370 --> 00:12:49,029
ah that's called rust that's really hard

00:12:44,620 --> 00:12:52,390
as it turns out for a lot of reasons yes

00:12:49,029 --> 00:12:55,570
super hard go doesn't do that as you

00:12:52,390 --> 00:12:57,400
know go keeps track of what pointers are

00:12:55,570 --> 00:12:59,860
alive a lot like the JVM and it does a

00:12:57,400 --> 00:13:01,089
sweeping cleanup kind of deal right so

00:12:59,860 --> 00:13:02,800
it will mark things as ready for

00:13:01,089 --> 00:13:06,010
deletion it will free them and then it

00:13:02,800 --> 00:13:10,270
will continue along and the go garbage

00:13:06,010 --> 00:13:15,420
collector yeah all right

00:13:10,270 --> 00:13:18,029
so slices which are pointers to pointers

00:13:15,420 --> 00:13:20,680
which represent data and go space

00:13:18,029 --> 00:13:24,580
there's some hidden dragons we got going

00:13:20,680 --> 00:13:26,589
here first off you can't pass this in to

00:13:24,580 --> 00:13:29,940
C go for the obvious reason that it's a

00:13:26,589 --> 00:13:32,440
slice but you could totally pass this

00:13:29,940 --> 00:13:34,210
the difference is that slight change in

00:13:32,440 --> 00:13:37,240
syntax where we give a fixed size

00:13:34,210 --> 00:13:39,010
changes it from a slice to an array all

00:13:37,240 --> 00:13:40,480
right so now we can totally pass that

00:13:39,010 --> 00:13:44,910
because it's not a pointer it's a

00:13:40,480 --> 00:13:48,130
contiguous array of memory all right and

00:13:44,910 --> 00:13:50,589
as I mentioned we get to do this fun

00:13:48,130 --> 00:13:52,570
thing and the important thing to

00:13:50,589 --> 00:13:56,050
remember here is that a slice is simply

00:13:52,570 --> 00:13:57,190
a wrapper for a in array and we want to

00:13:56,050 --> 00:14:00,610
take the memory address of the first

00:13:57,190 --> 00:14:03,010
element what happens if we start talking

00:14:00,610 --> 00:14:06,520
about more complex data structures right

00:14:03,010 --> 00:14:11,170
say a struct which contains a pointer to

00:14:06,520 --> 00:14:14,430
a string we can easily declare a see my

00:14:11,170 --> 00:14:18,279
struct and put it in a string and

00:14:14,430 --> 00:14:19,690
compilation error right we went over

00:14:18,279 --> 00:14:21,459
this so let's try using the same

00:14:19,690 --> 00:14:23,740
approach we used to fix this just a

00:14:21,459 --> 00:14:26,260
minute ago to try and put a character

00:14:23,740 --> 00:14:28,540
string in here all right this looks

00:14:26,260 --> 00:14:31,440
familiar well I have good news for you

00:14:28,540 --> 00:14:35,709
this will totally compile not a problem

00:14:31,440 --> 00:14:39,400
but any observant people want to point

00:14:35,709 --> 00:14:43,089
out what's wrong with this all right we

00:14:39,400 --> 00:14:45,339
have a pointer to a go item inside a

00:14:43,089 --> 00:14:46,150
structure which we are taking a pointer

00:14:45,339 --> 00:14:50,350
of and pass

00:14:46,150 --> 00:14:51,850
into see function so we compile because

00:14:50,350 --> 00:14:53,950
go doesn't know this at compile time

00:14:51,850 --> 00:14:57,520
because it's not quite as strict about

00:14:53,950 --> 00:15:00,940
these things as rust but when we try to

00:14:57,520 --> 00:15:02,529
run it it will fail it might take some

00:15:00,940 --> 00:15:09,250
time you might have to run it many times

00:15:02,529 --> 00:15:11,560
but it will fail right we could do this

00:15:09,250 --> 00:15:13,630
we could use C dot C string which is a

00:15:11,560 --> 00:15:17,320
helper that go provides in order to

00:15:13,630 --> 00:15:19,180
create a C style character string which

00:15:17,320 --> 00:15:23,470
means it's terminated in a null

00:15:19,180 --> 00:15:27,790
character backslash is 0 and this will

00:15:23,470 --> 00:15:29,800
also compile and it runs however

00:15:27,790 --> 00:15:33,910
speaking of things we're still working

00:15:29,800 --> 00:15:36,910
on learning this as written leaks memory

00:15:33,910 --> 00:15:38,950
all over the place when you do C dot C

00:15:36,910 --> 00:15:40,870
string or you do C dot malloc you are

00:15:38,950 --> 00:15:43,600
now responsible for freeing the memory

00:15:40,870 --> 00:15:46,180
that you allocated which makes goes

00:15:43,600 --> 00:15:50,830
garbage collector not super helpful

00:15:46,180 --> 00:15:53,529
right so can you get around this you

00:15:50,830 --> 00:15:55,630
could manually free it and by manually I

00:15:53,529 --> 00:15:57,279
mean defer C dot freeze that even if

00:15:55,630 --> 00:16:00,339
your exception panics you still know

00:15:57,279 --> 00:16:05,860
your memory is getting freed this is

00:16:00,339 --> 00:16:07,900
kind of mmm because now you know you

00:16:05,860 --> 00:16:09,880
have to remember to do it and I for one

00:16:07,900 --> 00:16:12,010
am horrible at that and I'll forget it

00:16:09,880 --> 00:16:14,350
all the time which is why I like garbage

00:16:12,010 --> 00:16:16,720
collected memories programming languages

00:16:14,350 --> 00:16:20,080
or programming languages which is smart

00:16:16,720 --> 00:16:22,450
about calling malloc for me and you know

00:16:20,080 --> 00:16:25,839
if you have kind of a more complex data

00:16:22,450 --> 00:16:27,610
flow where you may allocate something

00:16:25,839 --> 00:16:30,430
which gets used in the calling function

00:16:27,610 --> 00:16:32,260
this gets kind of ugly or if you have an

00:16:30,430 --> 00:16:34,930
object that lives for a little while in

00:16:32,260 --> 00:16:36,430
a structure that gets passed around it

00:16:34,930 --> 00:16:38,709
gets kind of ugly and it's kind of hard

00:16:36,430 --> 00:16:42,180
to know when to free it and this is

00:16:38,709 --> 00:16:45,550
exactly why go has a garbage collection

00:16:42,180 --> 00:16:47,800
function it would be absolutely

00:16:45,550 --> 00:16:49,510
wonderful if we could somehow utilize

00:16:47,800 --> 00:16:53,589
that to ensure that our memory gets

00:16:49,510 --> 00:16:54,780
freed go has a notion of something

00:16:53,589 --> 00:16:57,040
called a finalizer

00:16:54,780 --> 00:16:58,760
family who speaks go know what a

00:16:57,040 --> 00:17:02,020
finalizer is

00:16:58,760 --> 00:17:04,120
there's no Gophers in here good because

00:17:02,020 --> 00:17:06,500
finalizes makeover is very very angry

00:17:04,120 --> 00:17:08,630
they get very grumpy at people who use

00:17:06,500 --> 00:17:11,120
them the reason is that they're a little

00:17:08,630 --> 00:17:13,130
bit abusive the way it works is that

00:17:11,120 --> 00:17:15,560
when go detects an object is ready to be

00:17:13,130 --> 00:17:17,959
freed if it sees a finalizar set on the

00:17:15,560 --> 00:17:18,890
object rather than freeing that it calls

00:17:17,959 --> 00:17:21,350
the finalizer

00:17:18,890 --> 00:17:23,959
sets the finalizar to nil and then

00:17:21,350 --> 00:17:25,459
copies object over and the next time

00:17:23,959 --> 00:17:29,300
that we go to free we actually do the

00:17:25,459 --> 00:17:30,830
free right so when we know we no longer

00:17:29,300 --> 00:17:32,840
have any pointers to it we call the

00:17:30,830 --> 00:17:36,130
finalizar and then the next time there's

00:17:32,840 --> 00:17:38,300
a garbage collection event we free it

00:17:36,130 --> 00:17:41,810
something which I believe was stolen

00:17:38,300 --> 00:17:45,860
from c-sharp I believe I'm not a c-sharp

00:17:41,810 --> 00:17:49,970
extra expert and this makes Gophers very

00:17:45,860 --> 00:17:53,840
angry because it's very impure the idea

00:17:49,970 --> 00:17:56,780
is that it's a kind of it's it's

00:17:53,840 --> 00:18:02,480
something you don't expect and it's it's

00:17:56,780 --> 00:18:06,620
not a fun place to be you know it works

00:18:02,480 --> 00:18:08,420
right sure sounds good

00:18:06,620 --> 00:18:10,670
it works I don't have to worry about

00:18:08,420 --> 00:18:11,420
calling a seed out free my memory

00:18:10,670 --> 00:18:14,720
doesn't get leaked

00:18:11,420 --> 00:18:17,120
life goes on all right

00:18:14,720 --> 00:18:19,490
but there's a problem all right so

00:18:17,120 --> 00:18:24,830
here's a slightly modified example where

00:18:19,490 --> 00:18:27,620
I the myfunc to take a pointer to the

00:18:24,830 --> 00:18:30,470
character string which underlies which

00:18:27,620 --> 00:18:31,090
is embedded inside my C structure all

00:18:30,470 --> 00:18:33,830
right

00:18:31,090 --> 00:18:39,680
problem here is a little bit nuanced and

00:18:33,830 --> 00:18:42,890
it's it's kind of annoying remember how

00:18:39,680 --> 00:18:46,520
I said go has a garbage collector in

00:18:42,890 --> 00:18:49,730
this case go if C da my funk takes a

00:18:46,520 --> 00:18:54,140
long time may observe that message does

00:18:49,730 --> 00:18:58,130
not get used later so it will say hey I

00:18:54,140 --> 00:18:59,660
will free message and this may not be

00:18:58,130 --> 00:19:02,120
the behavior you want if you have

00:18:59,660 --> 00:19:04,360
certain assumptions in your C code so we

00:19:02,120 --> 00:19:07,919
need some way of telling go to keep

00:19:04,360 --> 00:19:09,630
message alive msg alive

00:19:07,919 --> 00:19:11,400
you could do this by just putting a

00:19:09,630 --> 00:19:13,140
reference to it later in the function it

00:19:11,400 --> 00:19:15,419
gets kind of hard to manage because it

00:19:13,140 --> 00:19:18,120
turns out pilers optimize things and if

00:19:15,419 --> 00:19:21,510
you just do like you know a set and

00:19:18,120 --> 00:19:23,250
later no retrieval ever it'll just take

00:19:21,510 --> 00:19:25,650
that away and then do the garbage

00:19:23,250 --> 00:19:28,679
collection on you anyway instead what

00:19:25,650 --> 00:19:31,110
you can do is oh geez I already

00:19:28,679 --> 00:19:33,270
explained that instead what you can do

00:19:31,110 --> 00:19:35,700
is import runtime and call a function

00:19:33,270 --> 00:19:38,159
called keepalive I don't know what this

00:19:35,700 --> 00:19:39,929
does behind the scenes in the back code

00:19:38,159 --> 00:19:43,980
I haven't looked but I'm really hoping

00:19:39,929 --> 00:19:47,429
it keeps msg alive right it seems

00:19:43,980 --> 00:19:49,980
reasonable and we hope that that

00:19:47,429 --> 00:19:55,049
prevents go from freeing things we don't

00:19:49,980 --> 00:19:57,840
want it to go so without that we call

00:19:55,049 --> 00:20:00,570
the finalizar we free the C memory as

00:19:57,840 --> 00:20:03,029
the C code is still running and bad

00:20:00,570 --> 00:20:04,590
things happen with that we don't call

00:20:03,029 --> 00:20:12,649
the finalizer until we go out of this

00:20:04,590 --> 00:20:16,020
function right any questions so far okay

00:20:12,649 --> 00:20:21,890
so I'm going to talk about the next

00:20:16,020 --> 00:20:24,330
thing we had to overcome callbacks

00:20:21,890 --> 00:20:26,580
anybody who's worked in C has seen a

00:20:24,330 --> 00:20:30,539
function which takes a pointer to a void

00:20:26,580 --> 00:20:32,970
star I'm sorry a function which takes an

00:20:30,539 --> 00:20:36,630
argument which is a pointer to a

00:20:32,970 --> 00:20:40,200
function that returns void and takes a

00:20:36,630 --> 00:20:43,169
void star argument that is a callback

00:20:40,200 --> 00:20:45,179
and C that is how you do it that's how

00:20:43,169 --> 00:20:46,830
everybody does it it's C you don't have

00:20:45,179 --> 00:20:48,809
a choice you can't pass functions

00:20:46,830 --> 00:20:52,140
directly you can only only pass these

00:20:48,809 --> 00:20:54,510
pointers to the functions you see them a

00:20:52,140 --> 00:20:57,059
lot in UI frameworks you see them a lot

00:20:54,510 --> 00:21:00,960
in certain database engines which have

00:20:57,059 --> 00:21:02,669
strong transaction guarantees and it's

00:21:00,960 --> 00:21:05,370
kind of a useful mechanism for

00:21:02,669 --> 00:21:07,350
controlling the scope of starting and

00:21:05,370 --> 00:21:09,080
restarting transactions if they fail to

00:21:07,350 --> 00:21:15,950
commit because there was contention

00:21:09,080 --> 00:21:15,950
so we use it in in yada DB and

00:21:16,410 --> 00:21:20,789
it's hard when you start talking about

00:21:18,870 --> 00:21:23,370
go this took us a little while to figure

00:21:20,789 --> 00:21:27,030
out so the first thing we're gonna do is

00:21:23,370 --> 00:21:29,610
define a function which takes that void

00:21:27,030 --> 00:21:31,530
pointer I'm sorry the pointer to the

00:21:29,610 --> 00:21:33,990
function which returns void and is a

00:21:31,530 --> 00:21:35,429
function and we're going to just call it

00:21:33,990 --> 00:21:37,980
it doesn't actually do anything I

00:21:35,429 --> 00:21:40,110
suppose it's supposed to print here but

00:21:37,980 --> 00:21:45,120
unfortunately this does not compile

00:21:40,110 --> 00:21:48,690
right we get an error because see you

00:21:45,120 --> 00:21:50,400
can't pass a pointer to a go thing to

00:21:48,690 --> 00:21:54,390
see you can't pass a pointer to the go

00:21:50,400 --> 00:21:56,400
function to see instead you have to do

00:21:54,390 --> 00:22:00,650
something pretty kind of hacky in my

00:21:56,400 --> 00:22:03,539
opinion you have to a create a new file

00:22:00,650 --> 00:22:04,860
where you put your function declaration

00:22:03,539 --> 00:22:07,380
you have to do this prevent linker

00:22:04,860 --> 00:22:09,750
problems related to the way go actually

00:22:07,380 --> 00:22:12,270
exports the function and then you have

00:22:09,750 --> 00:22:16,260
to add this magic comment export

00:22:12,270 --> 00:22:19,710
callback or export function game more

00:22:16,260 --> 00:22:21,809
generally in the second file and by the

00:22:19,710 --> 00:22:23,700
way you also need to put import C

00:22:21,809 --> 00:22:25,799
somewhere in that file and if you forget

00:22:23,700 --> 00:22:27,390
that you will be tearing your hair out

00:22:25,799 --> 00:22:30,000
trying to figure out why your linker

00:22:27,390 --> 00:22:33,409
isn't resolving things and then you have

00:22:30,000 --> 00:22:35,730
to declare it as an extern in the C code

00:22:33,409 --> 00:22:47,039
in the function and what you intend to

00:22:35,730 --> 00:22:48,630
use it does this cross go package or

00:22:47,039 --> 00:22:52,380
does this only work within a single go

00:22:48,630 --> 00:22:59,360
package are you referring to exposing

00:22:52,380 --> 00:22:59,360
the call back yeah

00:23:06,540 --> 00:23:12,730
so yet yes it could this goes down to

00:23:10,300 --> 00:23:14,890
kind of a sea thing and see you can

00:23:12,730 --> 00:23:16,600
declare an extern and you're promising

00:23:14,890 --> 00:23:18,730
the compiler that that will be resolved

00:23:16,600 --> 00:23:21,160
by the time you finish linking so as

00:23:18,730 --> 00:23:23,110
long as the extern gets resolved when

00:23:21,160 --> 00:23:25,180
you finish linking it doesn't matter

00:23:23,110 --> 00:23:28,000
where it's actually defined so you could

00:23:25,180 --> 00:23:30,940
totally define it another function but

00:23:28,000 --> 00:23:39,940
you could not refer to it in your go

00:23:30,940 --> 00:23:41,230
code directly right okay so the question

00:23:39,940 --> 00:23:42,670
was what happens if you have two

00:23:41,230 --> 00:23:44,890
different packages in the export the

00:23:42,670 --> 00:23:46,840
same named function the same thing that

00:23:44,890 --> 00:23:49,200
always happens with C you get a linker

00:23:46,840 --> 00:24:02,170
error because there's no name spacing

00:23:49,200 --> 00:24:04,480
right so you have a problem yeah I'm not

00:24:02,170 --> 00:24:05,710
super familiar with the problem you're

00:24:04,480 --> 00:24:08,250
talking about but I could totally see

00:24:05,710 --> 00:24:08,250
that in Python

00:24:17,050 --> 00:24:20,050
right

00:24:21,590 --> 00:24:27,140
it's yes it's later yeah yeah now you'll

00:24:25,490 --> 00:24:28,640
get a compilation error here and you'll

00:24:27,140 --> 00:24:30,590
tear your hair out because the error

00:24:28,640 --> 00:24:33,380
message is actually not very helpful

00:24:30,590 --> 00:24:35,510
because it refers to AC file which is

00:24:33,380 --> 00:24:39,320
generated by the go compiler which you

00:24:35,510 --> 00:24:46,510
can't see so you don't do that please

00:24:39,320 --> 00:24:49,730
that make me very sad yeah that's true

00:24:46,510 --> 00:24:51,470
so yeah there's like a lot of tricks to

00:24:49,730 --> 00:24:52,880
this you guys are asking some of them

00:24:51,470 --> 00:24:57,470
it's good questions I love questions

00:24:52,880 --> 00:24:59,360
please but this means that if we want

00:24:57,470 --> 00:25:01,400
the users to use our code which would be

00:24:59,360 --> 00:25:03,220
nice we do like users please use our

00:25:01,400 --> 00:25:05,510
code let us know what you think about it

00:25:03,220 --> 00:25:07,910
they have to write all of the stuff that

00:25:05,510 --> 00:25:09,410
they're doing transactions this tends to

00:25:07,910 --> 00:25:13,550
be a bit error-prone I can tell you I

00:25:09,410 --> 00:25:15,500
have lost many hours tracking down me

00:25:13,550 --> 00:25:18,020
forgetting to put this statement the

00:25:15,500 --> 00:25:20,450
import C statement I forgot I didn't

00:25:18,020 --> 00:25:21,800
think about it and I wasted like four or

00:25:20,450 --> 00:25:23,720
five hours trying to figure out why my

00:25:21,800 --> 00:25:30,230
code was linking wrong you google it you

00:25:23,720 --> 00:25:33,350
get nothing helpful there's not a lot of

00:25:30,230 --> 00:25:34,850
linters for c go okay so like go has a

00:25:33,350 --> 00:25:43,790
bunch of tools that does some amount of

00:25:34,850 --> 00:25:45,740
linting yeah we see go isn't super

00:25:43,790 --> 00:25:49,970
popular it's kind of abuse to work with

00:25:45,740 --> 00:25:51,800
and the people that use it I don't know

00:25:49,970 --> 00:25:53,420
I we didn't find any linters I found

00:25:51,800 --> 00:25:55,910
that for us if you know if any will be

00:25:53,420 --> 00:25:57,290
glad to use it feel free to run it on

00:25:55,910 --> 00:25:58,430
our code base and let us know what it

00:25:57,290 --> 00:25:59,560
turns up maybe it'll give us some

00:25:58,430 --> 00:26:04,280
answers

00:25:59,560 --> 00:26:06,650
alright but yeah we don't have litters

00:26:04,280 --> 00:26:09,290
it's an error-prone process the other

00:26:06,650 --> 00:26:12,410
thing worth mention is you can't import

00:26:09,290 --> 00:26:14,660
see in go test files for those who don't

00:26:12,410 --> 00:26:16,970
know how go does testing i have packaged

00:26:14,660 --> 00:26:19,280
main here i can declare package main

00:26:16,970 --> 00:26:20,930
underscore test in the same folder is

00:26:19,280 --> 00:26:22,280
the only case where I'm allowed to do

00:26:20,930 --> 00:26:25,310
that where I'm allowed to have two

00:26:22,280 --> 00:26:26,660
packages in the same folder and the

00:26:25,310 --> 00:26:30,410
thing is go looks for that underscore

00:26:26,660 --> 00:26:32,809
test keyword and says ah it's a test

00:26:30,410 --> 00:26:35,059
if I do that I am not allowed to import

00:26:32,809 --> 00:26:37,790
see so now I have to create some kind of

00:26:35,059 --> 00:26:40,040
infrastructure to allow me to import AC

00:26:37,790 --> 00:26:42,050
function into my testing code so that I

00:26:40,040 --> 00:26:43,610
can verify my callback function works as

00:26:42,050 --> 00:26:46,309
expected

00:26:43,610 --> 00:26:49,190
gets kind of ugly it gets kind of

00:26:46,309 --> 00:26:50,450
annoying to manage this also requires

00:26:49,190 --> 00:26:52,600
that you have some knowledge of C

00:26:50,450 --> 00:26:55,910
because you have to declare a

00:26:52,600 --> 00:26:58,970
intermediary function which takes your

00:26:55,910 --> 00:27:03,140
thing and it returns the callback go

00:26:58,970 --> 00:27:05,480
programmers may or may not know C we are

00:27:03,140 --> 00:27:07,340
I don't know we're trying to give them a

00:27:05,480 --> 00:27:10,280
go API so why do we require them to know

00:27:07,340 --> 00:27:12,559
C it seems kind of silly so we got to

00:27:10,280 --> 00:27:14,179
find a way to work around this without

00:27:12,559 --> 00:27:20,020
requiring users to do a lot of manual

00:27:14,179 --> 00:27:22,670
things our first attempt was we added a

00:27:20,020 --> 00:27:25,730
we had a tool which would generate your

00:27:22,670 --> 00:27:27,140
cease your go scaffolding for you and

00:27:25,730 --> 00:27:29,390
the idea was you would include that

00:27:27,140 --> 00:27:31,370
using go generate which is another

00:27:29,390 --> 00:27:33,590
special go comment that gets run when

00:27:31,370 --> 00:27:35,690
you run the go tool with the generate

00:27:33,590 --> 00:27:39,590
argument it still required you to

00:27:35,690 --> 00:27:42,050
manually run go generate still produce C

00:27:39,590 --> 00:27:45,710
files still had some kind of problems

00:27:42,050 --> 00:27:50,480
and you still can't test it so you know

00:27:45,710 --> 00:27:52,400
it wasn't great eventually we figured

00:27:50,480 --> 00:27:54,530
out that you could write a callback

00:27:52,400 --> 00:27:57,140
function we could write a callback

00:27:54,530 --> 00:28:00,710
function which would call a go routine

00:27:57,140 --> 00:28:03,710
and it can find that go routine by when

00:28:00,710 --> 00:28:07,760
you wrap the yata DB TP function

00:28:03,710 --> 00:28:09,740
storing the callback in a hash hash map

00:28:07,760 --> 00:28:12,610
or in array except there's some little

00:28:09,740 --> 00:28:16,280
tricks to that we just used a hash map

00:28:12,610 --> 00:28:17,840
so this is kind of a mind-blowing for C

00:28:16,280 --> 00:28:20,000
developers because now we are not

00:28:17,840 --> 00:28:22,610
passing a pointer to a function but

00:28:20,000 --> 00:28:26,720
we're passing the function itself right

00:28:22,610 --> 00:28:29,240
this is a new and exciting areas all

00:28:26,720 --> 00:28:32,270
right this is what our TP wrapper looks

00:28:29,240 --> 00:28:34,960
like this is the callback so we have a

00:28:32,270 --> 00:28:38,270
TP index which is a unique number

00:28:34,960 --> 00:28:40,640
representing the latest available TP

00:28:38,270 --> 00:28:43,240
function we have the map where we store

00:28:40,640 --> 00:28:45,640
things and then we have code

00:28:43,240 --> 00:28:50,350
this gets called from our sea library

00:28:45,640 --> 00:28:55,240
and it's passed a few arguments a TP

00:28:50,350 --> 00:28:58,420
token and arrow string a TP FN parm and

00:28:55,240 --> 00:29:00,400
see that's your void star thing and what

00:28:58,420 --> 00:29:04,660
we're passing as the void star thing is

00:29:00,400 --> 00:29:06,460
just a integer so we cast it to an

00:29:04,660 --> 00:29:11,800
integer and then we retrieve the

00:29:06,460 --> 00:29:14,380
function from our map and we run it all

00:29:11,800 --> 00:29:16,990
right and this seems to work pretty well

00:29:14,380 --> 00:29:21,520
for most of our users it does have some

00:29:16,990 --> 00:29:23,410
kind of things a there's a small

00:29:21,520 --> 00:29:25,990
performance it because you have to deal

00:29:23,410 --> 00:29:28,420
with taking that that map you have to

00:29:25,990 --> 00:29:30,490
lock the map increment your counter

00:29:28,420 --> 00:29:33,280
assign your function and then unlock the

00:29:30,490 --> 00:29:35,260
map using a mutex and see and go it's

00:29:33,280 --> 00:29:36,820
not as horrible as it could be things we

00:29:35,260 --> 00:29:39,250
have the cooperative multi-threading

00:29:36,820 --> 00:29:41,950
thing it's a little bit weird to think

00:29:39,250 --> 00:29:46,350
about if you're somebody from C or any

00:29:41,950 --> 00:29:49,630
other kind of older compiled language

00:29:46,350 --> 00:29:51,100
but you know we can get over that that

00:29:49,630 --> 00:29:52,890
kind of more interesting question is how

00:29:51,100 --> 00:29:55,660
do we pass arguments to the callback

00:29:52,890 --> 00:29:58,570
because we can't have the callback take

00:29:55,660 --> 00:30:00,370
an arbitrary number of arguments since

00:29:58,570 --> 00:30:05,280
we have to declare the expected

00:30:00,370 --> 00:30:05,280
prototype in our go code right

00:30:06,030 --> 00:30:13,950
anybody have thoughts on this one hmm

00:30:14,730 --> 00:30:19,710
sure so passing an array is a

00:30:17,110 --> 00:30:19,710
possibility

00:30:24,730 --> 00:30:30,080
okay and then the other suggestion was

00:30:27,140 --> 00:30:32,530
go offers very very Arctic arguments and

00:30:30,080 --> 00:30:35,840
they all have to be the same type and

00:30:32,530 --> 00:30:38,150
yeah so what you could do is pass an

00:30:35,840 --> 00:30:39,800
array of interface with that empty curly

00:30:38,150 --> 00:30:43,970
brace things and you could pass things

00:30:39,800 --> 00:30:45,350
that way we looked into that ended up

00:30:43,970 --> 00:30:48,770
being kind of annoying I forget exactly

00:30:45,350 --> 00:30:52,640
why what we ended up thinking out was

00:30:48,770 --> 00:30:55,220
closures so you know when you declare an

00:30:52,640 --> 00:30:56,990
anonymous function and go it looks to

00:30:55,220 --> 00:30:59,060
its parents scope and resolving

00:30:56,990 --> 00:31:03,560
variables I can't find so we can do

00:30:59,060 --> 00:31:05,720
something like this and now this funk

00:31:03,560 --> 00:31:08,060
has access to I which is declared in the

00:31:05,720 --> 00:31:11,570
parent scope and this ended up working

00:31:08,060 --> 00:31:12,770
pretty well because it takes care of the

00:31:11,570 --> 00:31:14,690
complexity of dealing with that

00:31:12,770 --> 00:31:16,520
interface object and dealing with the

00:31:14,690 --> 00:31:17,840
array and things like that and might be

00:31:16,520 --> 00:31:21,110
worth mentioning actually those are the

00:31:17,840 --> 00:31:23,780
same solution because behind the scenes

00:31:21,110 --> 00:31:29,930
the very attic thing just gets converted

00:31:23,780 --> 00:31:33,590
to it alright right so and you know work

00:31:29,930 --> 00:31:35,000
we did some testing on how how horrible

00:31:33,590 --> 00:31:36,890
this performs that it doesn't seem to be

00:31:35,000 --> 00:31:40,970
ridiculous so we're kind of going with

00:31:36,890 --> 00:31:43,130
that and hoping it works out but you

00:31:40,970 --> 00:31:44,840
know the time will tell and as I

00:31:43,130 --> 00:31:46,610
mentioned we are we are looking for

00:31:44,840 --> 00:31:49,610
feedback because we have a mysterious

00:31:46,610 --> 00:31:51,920
bug that manifests once every 24 hours

00:31:49,610 --> 00:31:55,640
or so that crash is the runtime system

00:31:51,920 --> 00:31:56,690
with all kinds of fun errors so anybody

00:31:55,640 --> 00:31:58,610
who wants to charge running your code

00:31:56,690 --> 00:32:03,980
for 24 hours and you get this error let

00:31:58,610 --> 00:32:06,140
us know so the last part of this talk

00:32:03,980 --> 00:32:10,250
I'm going to talk a little bit about the

00:32:06,140 --> 00:32:12,380
garbage collection problems like I said

00:32:10,250 --> 00:32:14,270
we don't have it all figured out

00:32:12,380 --> 00:32:16,610
but what we know now is how to kind of

00:32:14,270 --> 00:32:19,130
make things trigger problems more often

00:32:16,610 --> 00:32:20,900
not to say we can do it 100% of the time

00:32:19,130 --> 00:32:23,450
but we know how to make it happen more

00:32:20,900 --> 00:32:26,150
often generally if you do something

00:32:23,450 --> 00:32:27,410
wrong and see go it may not show up

00:32:26,150 --> 00:32:29,960
until a garbage collection has been

00:32:27,410 --> 00:32:31,430
triggered which means it doesn't happen

00:32:29,960 --> 00:32:33,730
to the applications been running for a

00:32:31,430 --> 00:32:33,730
little while

00:32:33,750 --> 00:32:37,560
so trying to help the garbage collection

00:32:35,640 --> 00:32:40,170
happen more often allows us to create

00:32:37,560 --> 00:32:43,170
more reproducible cases there's kind of

00:32:40,170 --> 00:32:44,340
two ish things that we know that you can

00:32:43,170 --> 00:32:47,430
do and there's actually a little bit

00:32:44,340 --> 00:32:49,530
more you can do with the C compiler

00:32:47,430 --> 00:32:52,830
flags which allow you to verify that C

00:32:49,530 --> 00:32:55,980
isn't doing bad things to memory but if

00:32:52,830 --> 00:32:57,960
you use this export go GC equals one in

00:32:55,980 --> 00:33:00,420
your environment it sets the go garbage

00:32:57,960 --> 00:33:03,420
collection rate really high and it will

00:33:00,420 --> 00:33:06,180
run all the time very aggressively so

00:33:03,420 --> 00:33:08,010
this helps you kind of cause a lot of

00:33:06,180 --> 00:33:09,420
garbage collections so you can verify

00:33:08,010 --> 00:33:11,760
your code as working as expected

00:33:09,420 --> 00:33:14,610
the other thing you could do is set the

00:33:11,760 --> 00:33:17,340
C go check equal to two and what this

00:33:14,610 --> 00:33:19,380
will do is have C go look very carefully

00:33:17,340 --> 00:33:21,660
at all pointers that are passed to all

00:33:19,380 --> 00:33:26,220
functions and see that it calls and look

00:33:21,660 --> 00:33:29,550
for go looking memory addresses you may

00:33:26,220 --> 00:33:31,230
get a few false positives with this but

00:33:29,550 --> 00:33:33,570
you know it's better to be safe than

00:33:31,230 --> 00:33:36,930
sorry that should be a lowercase e by

00:33:33,570 --> 00:33:42,030
the way capital e export is in a shell

00:33:36,930 --> 00:33:44,700
command in bash sorry about that and you

00:33:42,030 --> 00:33:46,800
know with these two things we can cause

00:33:44,700 --> 00:33:48,600
problems for ourselves and we hope that

00:33:46,800 --> 00:33:53,520
by resolving them we make progress and

00:33:48,600 --> 00:33:56,340
make a more solid product but really

00:33:53,520 --> 00:33:58,620
really the only way to verify that your

00:33:56,340 --> 00:34:02,310
code actually works is to use it one way

00:33:58,620 --> 00:34:04,250
to use it in a way that is verifying

00:34:02,310 --> 00:34:07,380
functionality is writing a lot of tests

00:34:04,250 --> 00:34:12,179
we've written some horrible mean very

00:34:07,380 --> 00:34:14,340
ugly very long running tests and still

00:34:12,179 --> 00:34:16,350
about 12 hours later we get an error

00:34:14,340 --> 00:34:18,840
message and things break and we get sad

00:34:16,350 --> 00:34:21,419
but you know at least we're detecting it

00:34:18,840 --> 00:34:27,360
rather than you guys detecting it all

00:34:21,419 --> 00:34:33,410
right yeah so that's all I've got any

00:34:27,360 --> 00:34:33,410
questions anybody have any answers

00:34:40,700 --> 00:34:43,700
okay

00:35:07,120 --> 00:35:10,120
okay

00:35:43,190 --> 00:35:53,010
yep so it's interesting that you started

00:35:50,850 --> 00:35:55,170
by saying don't do that because that's

00:35:53,010 --> 00:35:57,780
what everybody's told us online in the

00:35:55,170 --> 00:36:00,090
forums that we post to unfortunately

00:35:57,780 --> 00:36:01,920
we're gonna do it yeah we're gonna do it

00:36:00,090 --> 00:36:03,150
we got to do it we have things we have

00:36:01,920 --> 00:36:05,100
to do and we have to get this product

00:36:03,150 --> 00:36:08,280
done and out the door so we will do it

00:36:05,100 --> 00:36:09,750
and all we can do right now is look very

00:36:08,280 --> 00:36:11,520
very carefully at the Segoe

00:36:09,750 --> 00:36:13,650
documentation make sure that we are

00:36:11,520 --> 00:36:15,360
following all the rules and then we post

00:36:13,650 --> 00:36:16,740
questions to the mailing list we post

00:36:15,360 --> 00:36:18,390
questions to the forum where you go on

00:36:16,740 --> 00:36:21,690
reddit we go on discord we ask questions

00:36:18,390 --> 00:36:23,070
and everybody looks at our code says

00:36:21,690 --> 00:36:24,810
don't do that and then once they get

00:36:23,070 --> 00:36:27,030
over that they they kind of go well I

00:36:24,810 --> 00:36:29,100
have no idea and unfortunately because

00:36:27,030 --> 00:36:31,680
it takes 12 hours to reproduce this

00:36:29,100 --> 00:36:34,860
problem the Seco developers or the NGO

00:36:31,680 --> 00:36:37,080
developers can't just look at it so

00:36:34,860 --> 00:36:39,830
we're in a rock and a hard place until

00:36:37,080 --> 00:36:39,830
we find that bug

00:36:53,980 --> 00:36:57,090
[Music]

00:37:26,660 --> 00:37:54,920
yes oh I would never so that's a yes

00:38:03,040 --> 00:38:24,460
I I appreciate that

00:38:21,340 --> 00:38:26,470
and you know okay so I understand where

00:38:24,460 --> 00:38:29,170
you're coming from and you know yada DB

00:38:26,470 --> 00:38:30,940
we run the process space of the the

00:38:29,170 --> 00:38:32,790
application so that we have low latency

00:38:30,940 --> 00:38:34,480
so it can do transactions really fast

00:38:32,790 --> 00:38:37,180
unfortunately we can't get away from

00:38:34,480 --> 00:38:39,160
that easily right it's one of our big

00:38:37,180 --> 00:38:40,480
selling points and you're right other

00:38:39,160 --> 00:38:42,460
databases don't have this problem

00:38:40,480 --> 00:38:44,890
because they have a separate application

00:38:42,460 --> 00:38:47,320
that talks over a tcp sock or UNIX

00:38:44,890 --> 00:38:49,630
socket and you know they just talk for

00:38:47,320 --> 00:38:51,790
the best and I will point out you're

00:38:49,630 --> 00:38:53,050
also more right than you know because

00:38:51,790 --> 00:38:55,090
there's a whole bunch of things in the

00:38:53,050 --> 00:38:58,780
go runtime related to signal handling

00:38:55,090 --> 00:39:14,530
that present issues for us so one

00:38:58,780 --> 00:39:17,040
hundred percent more dragons see all I

00:39:14,530 --> 00:39:17,040
like it

00:39:27,850 --> 00:39:39,280
ooh so ok so it's interesting you say

00:39:34,930 --> 00:39:42,460
that I say so dependency manager for

00:39:39,280 --> 00:39:44,260
yada DB specifically initially we didn't

00:39:42,460 --> 00:39:46,870
have a plan and you know and go you just

00:39:44,260 --> 00:39:51,610
kind of put the URL up there you just

00:39:46,870 --> 00:39:54,700
put the URL yeah so what what we did is

00:39:51,610 --> 00:39:56,680
we put a URL which goes to our server

00:39:54,700 --> 00:39:59,020
Apache web server and put some meta

00:39:56,680 --> 00:40:01,540
flags in the HTML file to point you to

00:39:59,020 --> 00:40:03,820
the go repo so we have control over

00:40:01,540 --> 00:40:06,430
where it is and also that we have a

00:40:03,820 --> 00:40:09,430
consistent URL and so that we can kind

00:40:06,430 --> 00:40:12,010
of do things and then we have to figure

00:40:09,430 --> 00:40:14,080
out you know some of the Segoe changes

00:40:12,010 --> 00:40:15,850
some of the yada DB go wrapper changes

00:40:14,080 --> 00:40:19,000
are dependent upon the next version the

00:40:15,850 --> 00:40:23,620
oddity be database so now we can't just

00:40:19,000 --> 00:40:25,600
put it in the master branch because you

00:40:23,620 --> 00:40:27,070
you know we don't have a new version of

00:40:25,600 --> 00:40:29,680
the database out yet we released once

00:40:27,070 --> 00:40:31,390
every few months so now if we put it

00:40:29,680 --> 00:40:33,010
there we merge it in suddenly users

00:40:31,390 --> 00:40:35,370
download yada DB go over a prett it

00:40:33,010 --> 00:40:35,370
doesn't work

00:40:47,370 --> 00:41:05,160
mm-hmm it's getting better but yes yeah

00:41:00,760 --> 00:41:05,160
can you speak up can you speak up

00:41:07,320 --> 00:41:16,590
well that's against my point yeah I did

00:41:13,630 --> 00:41:19,830
say that I I like gum dip in it okay

00:41:16,590 --> 00:41:19,830
that's right

00:41:58,759 --> 00:43:10,319
Yeah right yes that dude who was

00:42:31,740 --> 00:43:14,759
watching yeah that dude yes this one

00:43:10,319 --> 00:43:16,349
yeah and by the way this took me like 40

00:43:14,759 --> 00:43:19,259
minutes to get the compiled last night

00:43:16,349 --> 00:43:27,119
to make sure I had it right yeah now

00:43:19,259 --> 00:43:29,309
look so let me let me step back for a

00:43:27,119 --> 00:43:30,660
minute and say something because you had

00:43:29,309 --> 00:43:32,579
an interest a very good point

00:43:30,660 --> 00:43:35,519
right so the NGO community is very very

00:43:32,579 --> 00:43:40,579
opinionated right oh just you yelling

00:43:35,519 --> 00:43:40,579
about dependency management right and

00:43:41,989 --> 00:43:48,480
yeah well yes anyway so like they're

00:43:47,160 --> 00:43:50,339
very opinionated we have some people on

00:43:48,480 --> 00:43:52,880
the team who are not fans of go because

00:43:50,339 --> 00:43:55,380
of how opinionated they are but also

00:43:52,880 --> 00:43:58,140
Python was run by one dude he had

00:43:55,380 --> 00:43:58,859
opinions right everyone yeah and

00:43:58,140 --> 00:44:06,140
everybody

00:43:58,859 --> 00:44:08,699
seems to like Python Oh No

00:44:06,140 --> 00:44:28,709
didn't you stay well that's discussion

00:44:08,699 --> 00:44:29,759
later just that the the the dichotomy

00:44:28,709 --> 00:44:32,880
was so weird I'm looking for that

00:44:29,759 --> 00:44:35,309
there's people who like have very strong

00:44:32,880 --> 00:44:37,529
opinions and they get very engulfed in

00:44:35,309 --> 00:44:38,969
flame wars very easily and in the NGO

00:44:37,529 --> 00:44:43,140
community I've observed that that's

00:44:38,969 --> 00:44:46,380
doubly true and I think the NGO creators

00:44:43,140 --> 00:44:49,380
have to kind of pick and choose their

00:44:46,380 --> 00:44:52,549
battles and unfortunately if they don't

00:44:49,380 --> 00:44:55,549
choose a battle they just don't fight it

00:44:52,549 --> 00:44:55,549
yes

00:45:47,860 --> 00:45:55,220
so really well what we get in trouble

00:45:51,830 --> 00:45:56,540
for is the finalizar that's what we get

00:45:55,220 --> 00:45:58,100
in trouble for and the go people get

00:45:56,540 --> 00:46:10,330
really really angry with us

00:45:58,100 --> 00:46:10,330
but like this is a place yeah yeah yeah

00:47:40,539 --> 00:47:43,539
okay

00:47:55,880 --> 00:48:00,990
yes so there's a in 2c go and that's a

00:47:59,210 --> 00:48:03,330
interesting point right if you use and

00:48:00,990 --> 00:48:05,010
go callbacks are super easy right but

00:48:03,330 --> 00:48:12,950
when you go in to see go you enter this

00:48:05,010 --> 00:48:12,950
space where yeah yes

00:48:23,640 --> 00:48:26,640
yes

00:48:44,900 --> 00:48:51,119
so let me just say something really

00:48:47,250 --> 00:48:54,390
quick all right so the the Segoe

00:48:51,119 --> 00:48:55,260
community the the developers we post on

00:48:54,390 --> 00:48:56,880
going nuts

00:48:55,260 --> 00:49:00,210
Google mailing lists and we usually get

00:48:56,880 --> 00:49:02,250
responses that are pretty good right and

00:49:00,210 --> 00:49:03,960
we actually haven't had much issues with

00:49:02,250 --> 00:49:06,900
our or at least we don't think we've had

00:49:03,960 --> 00:49:09,390
issues with our callback function

00:49:06,900 --> 00:49:10,560
mechanism that we have going here once

00:49:09,390 --> 00:49:12,750
we got it in place it just kind of

00:49:10,560 --> 00:49:15,060
worked so we moved on not our problem

00:49:12,750 --> 00:49:17,160
anymore it's now somebody else's problem

00:49:15,060 --> 00:49:18,859
I am telling you how we fixed it and

00:49:17,160 --> 00:49:25,140
maybe that will save you some pain but

00:49:18,859 --> 00:49:26,430
yes yes we don't know why we don't think

00:49:25,140 --> 00:49:29,060
it's a function calls but you're right

00:49:26,430 --> 00:49:29,060
we don't know why

00:49:37,680 --> 00:50:10,010
a lot of other people have seen this bug

00:49:42,170 --> 00:50:10,010
yeah busker

00:50:20,200 --> 00:50:24,740
yes yeah yeah so we've narrowed it down

00:50:22,670 --> 00:50:25,880
we're you know whenever you have a

00:50:24,740 --> 00:50:29,810
problem like this you have to do kind of

00:50:25,880 --> 00:50:31,340
a search we've removed a lot of our more

00:50:29,810 --> 00:50:32,750
complicated functionality and it still

00:50:31,340 --> 00:50:34,610
fails so we're pretty sure it's not the

00:50:32,750 --> 00:50:36,170
problem there could still be a problem

00:50:34,610 --> 00:50:39,950
there but it's not the problem we're

00:50:36,170 --> 00:50:44,260
hunting today so like I said this we we

00:50:39,950 --> 00:50:44,260
did it it worked we moved out so

00:50:47,020 --> 00:50:55,010
unfortunately unfortunately I take pride

00:50:52,250 --> 00:51:06,580
in it because it was my idea so I love

00:50:55,010 --> 00:51:06,580
it absolutely they're not very what

00:51:21,470 --> 00:51:27,250
yeah yeah

00:51:29,160 --> 00:51:39,829
sure I'm gonna move away from that slide

00:51:36,680 --> 00:51:39,829
all right

00:51:52,310 --> 00:51:54,940
right

00:51:55,890 --> 00:53:03,450
yeah there are two separate problems yes

00:52:02,749 --> 00:53:04,859
it works right so yeah yeah no it works

00:53:03,450 --> 00:53:07,140
really well for our problem and it works

00:53:04,859 --> 00:53:09,960
really well if you're wrapping a library

00:53:07,140 --> 00:53:11,430
interface but yeah if if I'm using AC

00:53:09,960 --> 00:53:16,769
library with no intentions of wrapping

00:53:11,430 --> 00:53:18,390
it then it's a clunky mechanism and yeah

00:53:16,769 --> 00:53:19,859
and and so kind of I think what you're

00:53:18,390 --> 00:53:21,420
trying to say and boskar did has

00:53:19,859 --> 00:53:25,200
something to say but what you're kind of

00:53:21,420 --> 00:53:28,650
trying to say is you see a problem with

00:53:25,200 --> 00:53:30,539
an underlying issue with the way the NGO

00:53:28,650 --> 00:53:33,089
community handles things or maybe

00:53:30,539 --> 00:53:35,970
communities in general in that we put a

00:53:33,089 --> 00:53:38,549
bandaid on right I get my case to work

00:53:35,970 --> 00:53:42,049
and then I move on but the next guy who

00:53:38,549 --> 00:53:42,049
comes along finds all those same issues

00:53:46,210 --> 00:54:02,160
okay right

00:54:17,340 --> 00:54:20,419
[Music]

00:54:56,559 --> 00:54:59,269
right

00:54:57,890 --> 00:55:01,519
you just gotta go fight another dragon

00:54:59,269 --> 00:55:04,180
it's it's like playing Elder Scrolls and

00:55:01,519 --> 00:55:35,349
every time you fast travel those dragons

00:55:04,180 --> 00:55:39,339
dark souls oh all right

00:55:35,349 --> 00:55:39,339
Bhaskar keeps raising his answer

00:57:21,840 --> 00:57:26,410
so here's the thing though the people

00:57:24,490 --> 00:57:27,760
who wrote see are the different people

00:57:26,410 --> 00:57:30,970
who wrote Java are different the people

00:57:27,760 --> 00:57:33,700
who wrote going and and writing down the

00:57:30,970 --> 00:57:35,290
lessons we learned in a cohesive manner

00:57:33,700 --> 00:57:40,800
that doesn't require me to read

00:57:35,290 --> 00:57:40,800
textbooks of data like every day is hard

00:57:41,850 --> 00:57:47,430
okay so they have no excuses that shame

00:57:45,010 --> 00:57:47,430
on them

00:58:09,720 --> 00:58:19,080
yep and yeah and part of it though

00:58:32,480 --> 00:58:50,360

YouTube URL: https://www.youtube.com/watch?v=rpCOosL21p0


