Title: Jean Pierre LeJacq - C best and worst security practices
Publication date: 2019-06-19
Playlist: 2019 SouthEast LinuxFest
Description: 
	2019 SouthEast LinuxFest; C is the basis of much of the Linux and embedded ecosystem despite it's reputation as the source for security lapses. This talk goes over common bad practices and anti-patterns from years working in commercial and open-source projects. We then cover best practices and patterns based on security guidelines such as CERT and MISRA. Topics includes large scale physical and API design, error handling, enhanced security features of C11 an C17, and usage of increasing sophisticated static and dynamic tools to assure security.
Captions: 
	00:00:03,120 --> 00:00:12,760
okay so I'm gonna start even though we

00:00:07,210 --> 00:00:15,940
don't have someone and then you just do

00:00:12,760 --> 00:00:19,079
some introductions and I get a sense of

00:00:15,940 --> 00:00:24,130
what you guys know which are interested

00:00:19,079 --> 00:00:27,339
Brisson Chocolate Chunk programming in C

00:00:24,130 --> 00:00:30,359
C++ for quite a long time so this is

00:00:27,339 --> 00:00:33,220
this presentation more lessons learned

00:00:30,359 --> 00:00:40,510
there's not a lot of original research

00:00:33,220 --> 00:00:45,270
here lessons learned so folks the folks

00:00:40,510 --> 00:00:45,270
out here who is using C evening

00:00:45,490 --> 00:00:54,800
doing it for embedded applications or

00:00:48,890 --> 00:01:02,360
the performance do you do C++ as well

00:00:54,800 --> 00:01:06,830
were strictly civilly do a combination

00:01:02,360 --> 00:01:09,710
of the two C and C++ I've developed a

00:01:06,830 --> 00:01:13,250
software for just about anything you can

00:01:09,710 --> 00:01:16,970
think of embedded to defense systems

00:01:13,250 --> 00:01:25,130
where performance man alive ridden or so

00:01:16,970 --> 00:01:28,190
much kernels of either folks interested

00:01:25,130 --> 00:01:37,729
primarily and is there a particular

00:01:28,190 --> 00:01:40,430
topic you want to try to okay so just

00:01:37,729 --> 00:01:44,549
jump in and in employment and ask

00:01:40,430 --> 00:01:49,270
questions like to be interactive we can

00:01:44,549 --> 00:01:50,799
again disclaimer this is fairly so again

00:01:49,270 --> 00:01:54,069
the disclaimer this is fairly

00:01:50,799 --> 00:01:56,619
opinionated point of view so there's not

00:01:54,069 --> 00:01:58,240
a lot of original research to back up

00:01:56,619 --> 00:02:00,090
some of the claims here I'd be

00:01:58,240 --> 00:02:03,819
interesting to see what everybody else's

00:02:00,090 --> 00:02:08,170
opinions of some of these things are so

00:02:03,819 --> 00:02:10,299
we're going to mainly before what I've

00:02:08,170 --> 00:02:15,519
observed in the real production

00:02:10,299 --> 00:02:18,700
environments both open source going to

00:02:15,519 --> 00:02:21,519
try to talk about common patterns of

00:02:18,700 --> 00:02:23,290
people like to use that are actually

00:02:21,519 --> 00:02:27,040
effective and then the university in

00:02:23,290 --> 00:02:35,170
Japan hopefully that term common things

00:02:27,040 --> 00:02:36,970
that are advocated that actually just a

00:02:35,170 --> 00:02:40,540
little bit balcony it was one of the

00:02:36,970 --> 00:02:43,709
founders of coining software consultancy

00:02:40,540 --> 00:02:50,670
we got headquarters in Davidson and

00:02:43,709 --> 00:02:50,670
Austin in The Chronicle we've been doing

00:02:50,700 --> 00:02:58,200
primarily in UNIX systems all types of

00:02:55,150 --> 00:02:58,200
UNIX systems are

00:03:00,320 --> 00:03:07,620
and I contributed to a lot of different

00:03:03,120 --> 00:03:09,630
things I was a deputy of maintainer I'm

00:03:07,620 --> 00:03:11,310
trying to get back in if there are any

00:03:09,630 --> 00:03:18,270
deputy and maintain errs I'd love to get

00:03:11,310 --> 00:03:20,180
my key sign first what makes these

00:03:18,270 --> 00:03:23,400
different and why do people use City

00:03:20,180 --> 00:03:25,620
there are a lot of words on them you

00:03:23,400 --> 00:03:27,510
know there are a lot of alternative

00:03:25,620 --> 00:03:31,140
language everyday this is the language

00:03:27,510 --> 00:03:34,590
and that's true for things that C is

00:03:31,140 --> 00:03:36,330
specifically targeted to so compiled

00:03:34,590 --> 00:03:43,500
languages that are meant and

00:03:36,330 --> 00:03:45,360
high-performance things like the rust so

00:03:43,500 --> 00:03:47,730
the big things about C is you get direct

00:03:45,360 --> 00:03:49,680
access to hardware there's one so when

00:03:47,730 --> 00:03:52,500
you're writing admitted advocacy is a

00:03:49,680 --> 00:04:00,420
kind of national choice high performance

00:03:52,500 --> 00:04:03,939
also nowadays you can argue that C++ as

00:04:00,420 --> 00:04:07,000
kitchen areas when you really really

00:04:03,939 --> 00:04:12,159
need to get high performance C is right

00:04:07,000 --> 00:04:14,220
before assembler the one thing that the

00:04:12,159 --> 00:04:19,320
encounter into or

00:04:14,220 --> 00:04:22,560
heresy online if you need to write high

00:04:19,320 --> 00:04:27,240
reliability on applications that have

00:04:22,560 --> 00:04:30,540
with performance whatever choices and

00:04:27,240 --> 00:04:33,150
one advantage of CD it is that it has a

00:04:30,540 --> 00:04:35,640
pretty good time checking capabilities

00:04:33,150 --> 00:04:37,440
that can be verified can verify or

00:04:35,640 --> 00:04:41,820
eliminate a whole class of errors that

00:04:37,440 --> 00:04:45,000
you just can't we're going to emphasize

00:04:41,820 --> 00:04:50,280
that a lot you can see trying to take

00:04:45,000 --> 00:04:52,590
advantage of that the other and the

00:04:50,280 --> 00:04:56,540
other thing that's very attractive so

00:04:52,590 --> 00:05:01,170
for example the Linux kernel community

00:04:56,540 --> 00:05:04,590
they might see this like C++ because too

00:05:01,170 --> 00:05:06,630
much magic happens you look at a piece

00:05:04,590 --> 00:05:11,190
of code gazillion things could be

00:05:06,630 --> 00:05:14,970
executed he is not like you see a line

00:05:11,190 --> 00:05:18,090
of code you know what now you can't bend

00:05:14,970 --> 00:05:22,140
the rules you can have crime dings of

00:05:18,090 --> 00:05:24,510
function all kinds of craziness but for

00:05:22,140 --> 00:05:27,990
the most part it's a pretty transparent

00:05:24,510 --> 00:05:31,640
what's going on when you're maintaining

00:05:27,990 --> 00:05:31,640
a large code it is that's a

00:05:35,720 --> 00:05:42,920
so I'm going to go through some process

00:05:37,790 --> 00:05:45,290
issues first just things that are issues

00:05:42,920 --> 00:05:49,400
to come up with anyone right it's not

00:05:45,290 --> 00:05:56,030
specific and a lot of this is gleaned

00:05:49,400 --> 00:05:58,880
from commercial so at the top level a

00:05:56,030 --> 00:06:03,020
lot of commercial companies for the most

00:05:58,880 --> 00:06:05,180
part agonize about what methodology over

00:06:03,020 --> 00:06:09,050
the years and it's constantly changed of

00:06:05,180 --> 00:06:12,230
every every couple of years I found

00:06:09,050 --> 00:06:15,140
almost no difference among them it can

00:06:12,230 --> 00:06:19,130
be successful portable it can have a

00:06:15,140 --> 00:06:23,380
disaster with agile so I don't see much

00:06:19,130 --> 00:06:26,510
difference in honestly sanguine tools

00:06:23,380 --> 00:06:29,360
companies Intendant agonize or any tool

00:06:26,510 --> 00:06:31,040
selection and they're constantly

00:06:29,360 --> 00:06:33,700
switching out their issue tracking

00:06:31,040 --> 00:06:33,700
system

00:06:35,870 --> 00:06:40,620
[Music]

00:06:38,000 --> 00:06:42,480
documentation again they're all

00:06:40,620 --> 00:06:44,190
basically the same I don't see the whole

00:06:42,480 --> 00:06:50,910
time and different and they don't have a

00:06:44,190 --> 00:06:52,380
significant value even as even then this

00:06:50,910 --> 00:06:56,130
might be a little more controversial

00:06:52,380 --> 00:07:00,990
even source control systems can be

00:06:56,130 --> 00:07:08,240
effective so a good example of that is a

00:07:00,990 --> 00:07:13,050
deadly have you ever had to use their

00:07:08,240 --> 00:07:14,430
defect tracking system so their defect

00:07:13,050 --> 00:07:17,790
tracking system should have been around

00:07:14,430 --> 00:07:25,260
a long long time incredibly effective

00:07:17,790 --> 00:07:28,020
doesn't have a web interface works great

00:07:25,260 --> 00:07:29,850
people it works very well every so often

00:07:28,020 --> 00:07:34,200
someone comes up and say well we should

00:07:29,850 --> 00:07:38,640
switch to JIRA there's so little

00:07:34,200 --> 00:07:40,440
battling and then the thing that

00:07:38,640 --> 00:07:44,790
actually the most is the gardener

00:07:40,440 --> 00:07:46,440
reports here is the new tool it's in the

00:07:44,790 --> 00:07:54,390
upper right part and everyone should

00:07:46,440 --> 00:07:56,820
switch but that is work is and we're

00:07:54,390 --> 00:07:58,700
going to talk a lot more about different

00:07:56,820 --> 00:08:02,090
techniques try to get

00:07:58,700 --> 00:08:04,790
if you got have leads and management

00:08:02,090 --> 00:08:06,080
that really advocated for what managers

00:08:04,790 --> 00:08:08,210
like that

00:08:06,080 --> 00:08:12,050
if that isn't there it's very hard to

00:08:08,210 --> 00:08:16,280
make significant improvements in your

00:08:12,050 --> 00:08:23,690
probability and security that's probably

00:08:16,280 --> 00:08:26,630
obvious but another thing I've seen this

00:08:23,690 --> 00:08:32,360
end is more in the commercial realm in

00:08:26,630 --> 00:08:34,970
the open source a lot of the lines on

00:08:32,360 --> 00:08:38,120
high level architecture society points

00:08:34,970 --> 00:08:42,380
so you know one at one point it was

00:08:38,120 --> 00:08:44,960
client-server then the web services and

00:08:42,380 --> 00:08:47,810
keeps changing over and over again and

00:08:44,960 --> 00:08:52,640
there's not enough emphasis on lower

00:08:47,810 --> 00:08:56,370
level design comments this is the lower

00:08:52,640 --> 00:09:01,280
level detail design is super important

00:08:56,370 --> 00:09:10,020
see you can hurt yourself so bad not

00:09:01,280 --> 00:09:13,800
understanding teachers the other thing

00:09:10,020 --> 00:09:16,770
in again are unfortunately our industry

00:09:13,800 --> 00:09:19,890
is parallel vanish so that's constantly

00:09:16,770 --> 00:09:22,440
you quote-unquote to do stuff coming out

00:09:19,890 --> 00:09:24,930
at the time essentially I don't think

00:09:22,440 --> 00:09:26,120
much has changed since Dykstra started a

00:09:24,930 --> 00:09:34,710
little kids

00:09:26,120 --> 00:09:38,160
ABT's and structure so probably of the

00:09:34,710 --> 00:09:42,470
folks in the using C++ have you started

00:09:38,160 --> 00:09:48,770
he was in continuation yeah that's a new

00:09:42,470 --> 00:09:51,850
that's a new mechanism for implementing

00:09:48,770 --> 00:09:56,380
an alternative to further

00:09:51,850 --> 00:09:59,500
it's been around since Lisp essentially

00:09:56,380 --> 00:10:05,830
for it and again is considered a brand

00:09:59,500 --> 00:10:09,970
new probably this is the most

00:10:05,830 --> 00:10:12,940
controversial spot testing so you've

00:10:09,970 --> 00:10:15,100
probably all read the trade writings and

00:10:12,940 --> 00:10:17,020
folks and saying how important testing

00:10:15,100 --> 00:10:19,960
is and hardly the testing and unit

00:10:17,020 --> 00:10:23,200
testing in particular completely in the

00:10:19,960 --> 00:10:25,780
rate however I attend very little

00:10:23,200 --> 00:10:28,990
success in commercial enterprises of

00:10:25,780 --> 00:10:32,020
having testing doctor unit level testing

00:10:28,990 --> 00:10:35,380
they always rely on management testing

00:10:32,020 --> 00:10:39,910
and as a separate team it's incredibly

00:10:35,380 --> 00:10:42,250
expensive and very ineffective for the

00:10:39,910 --> 00:10:45,190
most part the only exception to this

00:10:42,250 --> 00:10:47,500
rule is when he did work in the defense

00:10:45,190 --> 00:10:57,100
industry they or they take it very very

00:10:47,500 --> 00:11:00,460
seriously so sale ends in the ending

00:10:57,100 --> 00:11:02,440
pattern sizing testing however you

00:11:00,460 --> 00:11:04,180
really didn't need to do it is really a

00:11:02,440 --> 00:11:09,250
question of how do you get it into your

00:11:04,180 --> 00:11:14,850
enterprise and make it effective the

00:11:09,250 --> 00:11:14,850
probably the most important

00:11:16,510 --> 00:11:24,410
just just as examples of some more some

00:11:20,720 --> 00:11:27,800
more stories I've seen very large code

00:11:24,410 --> 00:11:30,649
bases that initially had the right

00:11:27,800 --> 00:11:34,510
intention that broke very good quality

00:11:30,649 --> 00:11:37,670
test has fairly good code coverage and

00:11:34,510 --> 00:11:40,250
two three years later the majority of

00:11:37,670 --> 00:11:44,120
the tests are coming to them because the

00:11:40,250 --> 00:11:47,750
solution for a test family is am I going

00:11:44,120 --> 00:11:49,480
to spend some more time fixing this I

00:11:47,750 --> 00:11:57,260
just kind of comment to that and

00:11:49,480 --> 00:11:59,839
unfortunately and I see this both been

00:11:57,260 --> 00:12:03,529
in commercial and 420 and sort of

00:11:59,839 --> 00:12:06,880
support so I help submit a lot of

00:12:03,529 --> 00:12:06,880
patches that good people make

00:12:10,020 --> 00:12:16,630
they actually have a fairly extensive

00:12:12,100 --> 00:12:21,670
test but for years it was not executed

00:12:16,630 --> 00:12:25,540
completely languishing for a good 10

00:12:21,670 --> 00:12:27,730
years they've brought it back up think

00:12:25,540 --> 00:12:31,030
of how important our canoeing negatives

00:12:27,730 --> 00:12:38,820
to the open source community think that

00:12:31,030 --> 00:12:42,220
that did not happen at it with Tesla as

00:12:38,820 --> 00:12:45,180
as a counter to this and what I'm going

00:12:42,220 --> 00:12:49,450
to be provided to mark on this slide is

00:12:45,180 --> 00:12:54,060
reliance on static analysis taking

00:12:49,450 --> 00:12:54,060
advantage of the language features as

00:12:55,110 --> 00:13:03,310
the air you don't have to write in code

00:12:57,760 --> 00:13:06,520
any special code you don't have to brow

00:13:03,310 --> 00:13:08,740
the people to run their tests if you're

00:13:06,520 --> 00:13:12,480
going to compile the project you have to

00:13:08,740 --> 00:13:12,480
pass the static analysis

00:13:13,630 --> 00:13:18,660
[Music]

00:13:15,470 --> 00:13:21,630
documentation is another issue that

00:13:18,660 --> 00:13:25,430
comes up I've seen both ends of the

00:13:21,630 --> 00:13:29,430
spectrum where you have order for

00:13:25,430 --> 00:13:32,370
sdlc types of development processes that

00:13:29,430 --> 00:13:36,300
have very detailed documents they have

00:13:32,370 --> 00:13:37,920
50 different document types what they

00:13:36,300 --> 00:13:43,050
spend a lot of money putting them

00:13:37,920 --> 00:13:48,000
together either bit ronic or get lost in

00:13:43,050 --> 00:13:52,650
the SharePoint world or or they're never

00:13:48,000 --> 00:13:56,600
updated even when you have pretty good

00:13:52,650 --> 00:13:59,430
documentation smile unfortunate

00:13:56,600 --> 00:14:01,530
experiences is that people rarely read

00:13:59,430 --> 00:14:04,740
them anyway it's only as a last resort

00:14:01,530 --> 00:14:11,010
kind of thing people recode developers

00:14:04,740 --> 00:14:13,710
become much less what what I wrongly

00:14:11,010 --> 00:14:18,360
recommend here is keeping the

00:14:13,710 --> 00:14:20,610
documentation alongside the code and

00:14:18,360 --> 00:14:23,430
fortunately the open-source community

00:14:20,610 --> 00:14:26,640
has been very good at doing that and

00:14:23,430 --> 00:14:28,649
then the other part is document with

00:14:26,640 --> 00:14:36,930
the code itself so tools like oxygen

00:14:28,649 --> 00:14:40,370
everyone uses stunts that's your best

00:14:36,930 --> 00:14:47,570
chance of happening having decent

00:14:40,370 --> 00:14:52,500
documentation it's essentially you know

00:14:47,570 --> 00:14:54,660
annotated comments that are parsed long

00:14:52,500 --> 00:15:05,190
during the compile phase and you can

00:14:54,660 --> 00:15:07,500
generate HTML continuous integration

00:15:05,190 --> 00:15:15,450
probably everyone and realized it was

00:15:07,500 --> 00:15:16,890
everyone you see on the I think that's a

00:15:15,450 --> 00:15:18,810
great idea the basic idea behind

00:15:16,890 --> 00:15:21,980
continuous integration as you're

00:15:18,810 --> 00:15:26,579
constantly building your applications

00:15:21,980 --> 00:15:30,540
identify a compiler ideally test very

00:15:26,579 --> 00:15:33,329
elusive sense possible had very good

00:15:30,540 --> 00:15:37,380
success both commercial and open source

00:15:33,329 --> 00:15:41,550
projects on using C on the only thing I

00:15:37,380 --> 00:15:44,339
would warn about is often is kind of a

00:15:41,550 --> 00:15:48,300
to the spectrum in one ways they don't

00:15:44,339 --> 00:15:51,690
use it enough we should be using C on to

00:15:48,300 --> 00:15:54,029
have various tests various types of

00:15:51,690 --> 00:15:57,519
bearing builds as well as different

00:15:54,029 --> 00:16:01,429
platforms so in an example

00:15:57,519 --> 00:16:03,649
highly recommended is always target the

00:16:01,429 --> 00:16:05,239
next environment that you're going to

00:16:03,649 --> 00:16:07,129
deploy units if you have your current

00:16:05,239 --> 00:16:14,359
production environment is that you are

00:16:07,129 --> 00:16:17,329
on linux 4.5 that kernel and GCC a6

00:16:14,359 --> 00:16:21,169
you should also be compiling the current

00:16:17,329 --> 00:16:23,660
authenticity not just so you're ready

00:16:21,169 --> 00:16:25,869
and then maybe more importantly you can

00:16:23,660 --> 00:16:28,759
take advantage of all the ended

00:16:25,869 --> 00:16:39,290
functionality that is not on robotics

00:16:28,759 --> 00:16:41,499
which is astonishing quick thank yous on

00:16:39,290 --> 00:16:47,419
standard we're going to talk a little

00:16:41,499 --> 00:16:50,679
detail on C Sanders here a common thing

00:16:47,419 --> 00:16:54,189
I see and warn the commercials

00:16:50,679 --> 00:16:58,220
honestly a little bit in the open source

00:16:54,189 --> 00:17:00,859
is that don't really mean them people

00:16:58,220 --> 00:17:05,600
already know how to program and why do I

00:17:00,859 --> 00:17:07,669
need to solve for C program so do you

00:17:05,600 --> 00:17:09,970
guys have a coding guidelines or either

00:17:07,669 --> 00:17:09,970
John

00:17:10,490 --> 00:17:16,760
and something the other thing that I

00:17:14,390 --> 00:17:19,460
think is problematic is the inverse tank

00:17:16,760 --> 00:17:23,000
well you need a polygon let me start

00:17:19,460 --> 00:17:24,980
from scratch it's like it's like

00:17:23,000 --> 00:17:31,310
companies I want to write their own

00:17:24,980 --> 00:17:34,370
crypto software to go look for what's

00:17:31,310 --> 00:17:47,150
out there unfortunately there are some

00:17:34,370 --> 00:17:48,890
excellent guidelines many freely the

00:17:47,150 --> 00:17:51,350
other thing is it's really important if

00:17:48,890 --> 00:17:53,060
you have a large two-month you can't

00:17:51,350 --> 00:17:58,160
assume anyone's going to read you guys

00:17:53,060 --> 00:18:00,320
like say the only place I see guidelines

00:17:58,160 --> 00:18:03,500
really effective I want you to encode

00:18:00,320 --> 00:18:05,810
reviews or you're saying why the static

00:18:03,500 --> 00:18:08,260
analysis tool is projecting your code

00:18:05,810 --> 00:18:12,620
you can go and say look at the cert

00:18:08,260 --> 00:18:17,260
guidelines on initialization number five

00:18:12,620 --> 00:18:17,260
four and then they will read it at that

00:18:18,850 --> 00:18:28,460
problem is you don't want to constantly

00:18:21,410 --> 00:18:30,260
get into arguments coding this way for

00:18:28,460 --> 00:18:36,680
ten years and this is the right thing to

00:18:30,260 --> 00:18:43,820
do versus another want to have an

00:18:36,680 --> 00:18:46,400
authoritative source okay so that's kind

00:18:43,820 --> 00:18:48,290
of high-level issues from defects any

00:18:46,400 --> 00:18:50,240
language I have to see much difference

00:18:48,290 --> 00:18:52,130
appropriate than a whole bunch of

00:18:50,240 --> 00:18:57,290
languages all those kind of issues come

00:18:52,130 --> 00:19:01,490
up so I'm going to down into a specific

00:18:57,290 --> 00:19:07,190
sense here's a here's a list of things

00:19:01,490 --> 00:19:11,120
I'm going to try to cover first what

00:19:07,190 --> 00:19:14,660
what see are you going to use so you

00:19:11,120 --> 00:19:18,110
guys program to see eleven anyone

00:19:14,660 --> 00:19:25,330
program to see eleven do people know

00:19:18,110 --> 00:19:29,870
that see no do you know what's in C 22 X

00:19:25,330 --> 00:19:33,800
no most people see programmers I see

00:19:29,870 --> 00:19:37,190
it's fairly up to see

00:19:33,800 --> 00:19:40,010
and there so so for example can you

00:19:37,190 --> 00:19:42,460
declare where can you declare variables

00:19:40,010 --> 00:19:42,460
in the function

00:19:45,089 --> 00:19:52,979
that's right exactly and you've been

00:19:50,309 --> 00:19:55,229
able to mix your declaration vast

00:19:52,979 --> 00:19:57,869
majority to see code that sees both

00:19:55,229 --> 00:20:03,449
tanks on all the variables that are very

00:19:57,869 --> 00:20:07,139
Tom why - have a problem well you're

00:20:03,449 --> 00:20:09,599
increasing the scope of the variables

00:20:07,139 --> 00:20:12,209
unnecessarily and you can't initialize

00:20:09,599 --> 00:20:15,119
them to a sensible value so everything

00:20:12,209 --> 00:20:18,809
gets initialized to zero or am i right

00:20:15,119 --> 00:20:21,799
or I'd like to initialize my pointers to

00:20:18,809 --> 00:20:21,799
AI

00:20:26,340 --> 00:20:33,580
so in some ways

00:20:30,519 --> 00:20:37,139
see it's not trapped into one of the

00:20:33,580 --> 00:20:41,200
nice things about see that it's a it's a

00:20:37,139 --> 00:20:44,499
stable language that people know and

00:20:41,200 --> 00:20:46,989
that it is available on any platform you

00:20:44,499 --> 00:20:50,529
can think of and they think well to

00:20:46,989 --> 00:20:55,989
maximize that I will stick to

00:20:50,529 --> 00:20:58,929
K&R I think that's changed now you can

00:20:55,989 --> 00:21:02,559
get GCC or climbing on just about

00:20:58,929 --> 00:21:13,239
anything and if your vendor doesn't

00:21:02,559 --> 00:21:19,960
support you now I know I know there are

00:21:13,239 --> 00:21:21,639
good reasons to really think about

00:21:19,960 --> 00:21:27,309
can I take advantage of some of the new

00:21:21,639 --> 00:21:32,200
language so just go go through the list

00:21:27,309 --> 00:21:41,559
so what does C 1999 inline functions to

00:21:32,200 --> 00:21:43,610
use macros or to use options and there's

00:21:41,559 --> 00:21:48,010
no good reason to do that

00:21:43,610 --> 00:21:51,880
you get complete with functions

00:21:48,010 --> 00:21:51,880
available forever

00:22:01,130 --> 00:22:07,190
you can internet with all declaration to

00:22:03,470 --> 00:22:10,430
code whole bunch of you types all fine

00:22:07,190 --> 00:22:17,600
wait we have a rule we don't have to be

00:22:10,430 --> 00:22:20,120
embarrassed using C right we don't

00:22:17,600 --> 00:22:36,550
invent your own type tips for different

00:22:20,120 --> 00:22:40,760
solids of integers it all you should

00:22:36,550 --> 00:22:44,450
that's what that does it determines the

00:22:40,760 --> 00:22:50,650
aliasing of pointers and that makes a

00:22:44,450 --> 00:22:50,650
tremendous difference in performance

00:22:52,180 --> 00:22:58,010
that's a one big advantage for training

00:22:55,160 --> 00:23:01,400
hands about overseas is that everything

00:22:58,010 --> 00:23:04,790
is on alias and Fortran and C you have

00:23:01,400 --> 00:23:12,680
to default assume everything is elegant

00:23:04,790 --> 00:23:15,830
so you can see library is full of cons

00:23:12,680 --> 00:23:21,230
and respect to savor the POSIX library

00:23:15,830 --> 00:23:22,670
is almost fully positive you can write

00:23:21,230 --> 00:23:25,040
code it's not that hard

00:23:22,670 --> 00:23:27,020
there are a lot of guidelines that say

00:23:25,040 --> 00:23:33,560
this trick is to complicated but if

00:23:27,020 --> 00:23:37,340
you're using senior anyone though can

00:23:33,560 --> 00:23:57,200
you can use the clear of function where

00:23:37,340 --> 00:24:02,660
you can ensure that you have a jump

00:23:57,200 --> 00:24:05,500
around so here's a little fun is that

00:24:02,660 --> 00:24:05,500
reasonable to know

00:24:11,600 --> 00:24:19,490
accumulators of functions that takes an

00:24:15,620 --> 00:24:22,430
array of on signs and I want to ensure

00:24:19,490 --> 00:24:27,230
that I get a certain number at least

00:24:22,430 --> 00:24:31,640
five elements in the array the syntax to

00:24:27,230 --> 00:24:35,390
do that as you declare inside the square

00:24:31,640 --> 00:24:38,210
phrase you use a static keyword and then

00:24:35,390 --> 00:24:41,180
the song that had the minimum size that

00:24:38,210 --> 00:24:43,850
it has to have the compiler would then

00:24:41,180 --> 00:24:46,460
check that you're not passing a pointer

00:24:43,850 --> 00:24:53,300
actually passing an array and the array

00:24:46,460 --> 00:24:56,720
at least has at least I don't know one

00:24:53,300 --> 00:24:59,720
I've never seen real code with so it's

00:24:56,720 --> 00:25:03,710
been around since you know twenty years

00:24:59,720 --> 00:25:06,230
ago I just I just simply don't

00:25:03,710 --> 00:25:11,450
understand why this isn't you would

00:25:06,230 --> 00:25:15,410
eliminate my agent resource of family to

00:25:11,450 --> 00:25:17,870
errors security-related buffer overflows

00:25:15,410 --> 00:25:20,800
just by this simple thing and is caught

00:25:17,870 --> 00:25:20,800
at compile time

00:25:22,000 --> 00:25:27,040
I think so

00:25:25,030 --> 00:25:29,380
I think so world we have more

00:25:27,040 --> 00:25:32,050
presentations right I don't know what it

00:25:29,380 --> 00:25:34,150
takes to do now there is one

00:25:32,050 --> 00:25:37,600
disadvantage to that so that and I

00:25:34,150 --> 00:25:41,470
sometimes don't use it for this this is

00:25:37,600 --> 00:25:43,870
not in the season the C++ language so

00:25:41,470 --> 00:25:45,820
this is one of the incompatibilities and

00:25:43,870 --> 00:25:49,920
they're not many but this is one of them

00:25:45,820 --> 00:25:49,920
in compatibilities between C and C++

00:25:53,580 --> 00:25:59,620
this is not legal sometimes in C++ so

00:25:57,190 --> 00:26:06,100
let me show you what the compiler will

00:25:59,620 --> 00:26:08,910
do so I'm going to use clang you can use

00:26:06,100 --> 00:26:08,910
Jesus in

00:26:21,070 --> 00:26:26,149
so I'm just going to run through these

00:26:24,710 --> 00:26:30,039
options are going to go into this a

00:26:26,149 --> 00:26:36,799
little bit more client understands

00:26:30,039 --> 00:26:42,769
actually the closes 17:17 clang

00:26:36,799 --> 00:26:45,169
implements see each so if there is no

00:26:42,769 --> 00:26:49,279
reasoning on test or an item these

00:26:45,169 --> 00:26:51,080
pictures claim has incredible static

00:26:49,279 --> 00:26:55,490
analysis I'm going to turn all of the

00:26:51,080 --> 00:26:58,369
month everything to get maximum coverage

00:26:55,490 --> 00:27:03,309
of Hispanic analysis you have to use

00:26:58,369 --> 00:27:10,820
optimization that Annie of Oslo control

00:27:03,309 --> 00:27:14,419
has also going to enable the interests

00:27:10,820 --> 00:27:17,259
and undefined sanitizers people use

00:27:14,419 --> 00:27:17,259
sanitizer

00:27:23,610 --> 00:27:29,490
the sanitizers or bound rhymes on

00:27:26,039 --> 00:27:32,909
steroids so for example Valentine can

00:27:29,490 --> 00:27:35,730
only check dynamic memory errors the

00:27:32,909 --> 00:27:40,230
anthros sanitizer checked any kind of

00:27:35,730 --> 00:27:45,980
memory error so Stan based variable

00:27:40,230 --> 00:27:45,980
radius that you overflow:visible Canton

00:27:51,799 --> 00:28:04,580
I'd have kind of 7mm sold here okay so

00:27:59,700 --> 00:28:04,580
let me clean that up so you can see it

00:28:09,720 --> 00:28:17,440
okay morning from this colleague

00:28:14,590 --> 00:28:20,170
requires at least five elements so I've

00:28:17,440 --> 00:28:29,710
passed in and the rate that was too

00:28:20,170 --> 00:28:31,690
small line 41 so here

00:28:29,710 --> 00:28:35,980
here I have an array that's too small

00:28:31,690 --> 00:28:39,190
just writing not really too big it's big

00:28:35,980 --> 00:28:41,830
an array but bigger than the minimum is

00:28:39,190 --> 00:28:45,460
fine you can pass that in and I got a

00:28:41,830 --> 00:28:54,700
standard check of two small eliminated a

00:28:45,460 --> 00:28:57,280
buffer overrun and this is the point I

00:28:54,700 --> 00:29:00,850
want to try to make is he has a bomb and

00:28:57,280 --> 00:29:04,150
where it's a bombing is to get more and

00:29:00,850 --> 00:29:06,309
more testing enabled at compile time in

00:29:04,150 --> 00:29:10,890
the language both for performance

00:29:06,309 --> 00:29:10,890
reasons and for correctness and security

00:29:12,179 --> 00:29:18,010
c11 added a whole slew of new features

00:29:15,390 --> 00:29:22,210
people are familiar with the assert

00:29:18,010 --> 00:29:24,960
teacher from Caitlyn people use

00:29:22,210 --> 00:29:24,960
Hispanics

00:29:25,410 --> 00:29:31,590
because Hispanic assert was a not

00:29:28,020 --> 00:29:35,340
different C++ it's a compile-time

00:29:31,590 --> 00:29:38,790
assertion or something so for example if

00:29:35,340 --> 00:29:41,040
you want to guarantee that your unsigned

00:29:38,790 --> 00:29:44,180
is a certain number of bits you can do

00:29:41,040 --> 00:29:49,350
that at compile time not at run time

00:29:44,180 --> 00:29:54,290
they have theirs multi-threaded support

00:29:49,350 --> 00:29:56,640
so he now has entered cross-platform

00:29:54,290 --> 00:29:59,280
threading available you don't have to

00:29:56,640 --> 00:30:03,830
rely on POSIX threads on one for one

00:29:59,280 --> 00:30:03,830
time for Windows threads on another

00:30:04,370 --> 00:30:15,780
thread in the library people familiar

00:30:07,710 --> 00:30:17,550
with templates plus positive as

00:30:15,780 --> 00:30:19,980
templates for many many years almost

00:30:17,550 --> 00:30:22,410
from the beginning till now has

00:30:19,980 --> 00:30:25,530
something almost equivalent and they

00:30:22,410 --> 00:30:27,960
call them generic functions and it's a

00:30:25,530 --> 00:30:30,840
general mechanism where you can now

00:30:27,960 --> 00:30:39,330
function overloading so you may have

00:30:30,840 --> 00:30:41,940
seen in the c99 that you have different

00:30:39,330 --> 00:30:44,820
kinds of floating-point types but

00:30:41,940 --> 00:30:48,060
they're named the same before you have a

00:30:44,820 --> 00:30:50,160
palpable penalty paddle LD you don't

00:30:48,060 --> 00:30:53,250
have to do that anymore so you have the

00:30:50,160 --> 00:30:54,539
equivalent of functional and city this

00:30:53,250 --> 00:30:59,519
is a feature

00:30:54,539 --> 00:31:02,940
for us the song library for the

00:30:59,519 --> 00:31:05,579
performance-related folks or the system

00:31:02,940 --> 00:31:09,449
there is now a standard way of

00:31:05,579 --> 00:31:11,940
specifying memory again this is a

00:31:09,449 --> 00:31:14,909
gigantic when you I was having a whole

00:31:11,940 --> 00:31:16,949
bunch of uglies hacks at each compiler

00:31:14,909 --> 00:31:22,409
vendor provided now there's a nice thing

00:31:16,949 --> 00:31:24,869
that didn't that there's also functions

00:31:22,409 --> 00:31:27,539
as Connor no return is the most

00:31:24,869 --> 00:31:30,299
important one they're starting to him

00:31:27,539 --> 00:31:34,940
they started even at this point to

00:31:30,299 --> 00:31:34,940
implement the concept of attributes

00:31:36,979 --> 00:31:42,449
these are decorations that you see

00:31:39,959 --> 00:31:44,819
sianis and adopted by almost all the

00:31:42,449 --> 00:31:50,429
compilers Microsoft has something

00:31:44,819 --> 00:31:53,789
equivalent that that you can say in your

00:31:50,429 --> 00:31:57,269
code something about a function or a

00:31:53,789 --> 00:31:59,819
title so never simple example in GCC you

00:31:57,269 --> 00:32:05,759
can say a pointer parameter cannot be

00:31:59,819 --> 00:32:08,459
not something somewhere you can say this

00:32:05,759 --> 00:32:13,159
function doesn't return and the compiler

00:32:08,459 --> 00:32:13,159
can do extra checks and optimization

00:32:13,369 --> 00:32:22,849
people use berries the length of rays

00:32:17,419 --> 00:32:26,829
good they were introduced in 99 they are

00:32:22,849 --> 00:32:32,359
now marked as deprecated from c11 and

00:32:26,829 --> 00:32:34,609
c18 and hopefully it will be gone they

00:32:32,359 --> 00:32:37,489
now have an updated memory model that's

00:32:34,609 --> 00:32:40,519
very similar to the Java memory model so

00:32:37,489 --> 00:32:42,320
we now have a well-defined memory model

00:32:40,519 --> 00:32:46,519
that's incredibly important for

00:32:42,320 --> 00:32:52,129
threading especially again we should be

00:32:46,519 --> 00:32:54,499
using them and it's also and in general

00:32:52,129 --> 00:33:01,519
there's just better compatibility C++

00:32:54,499 --> 00:33:03,769
tried to there is he a team that mainly

00:33:01,519 --> 00:33:06,049
above techs are really no new features

00:33:03,769 --> 00:33:13,759
in it so if you didn't know about the 18

00:33:06,049 --> 00:33:17,479
that's okay see 2x his coding for the

00:33:13,759 --> 00:33:20,179
next release that's coming along fairly

00:33:17,479 --> 00:33:23,269
quickly they've already approved a lot

00:33:20,179 --> 00:33:27,109
of features for example anyone in the

00:33:23,269 --> 00:33:33,039
financial industry know Constantine is

00:33:27,109 --> 00:33:33,039
so how do you do calculations in money

00:33:34,950 --> 00:33:46,539
with integers and you usually have to

00:33:37,600 --> 00:33:50,400
manage so first never use down integers

00:33:46,539 --> 00:33:53,429
are okay but you have to manage a lot of

00:33:50,400 --> 00:33:58,080
semantics yourself there's a new type of

00:33:53,429 --> 00:34:06,539
binary floating-point which implement

00:33:58,080 --> 00:34:06,539
correct semantics for money and gigantic

00:34:06,809 --> 00:34:16,389
financial risk usable in the financial

00:34:11,889 --> 00:34:19,899
world particularly important I know like

00:34:16,389 --> 00:34:23,919
xlc supports this now not 100% sure of

00:34:19,899 --> 00:34:28,629
GCC I don't think lying goes JCCC might

00:34:23,919 --> 00:34:30,369
have an implementation as well finally

00:34:28,629 --> 00:34:36,700
they're going to get rid of KN our

00:34:30,369 --> 00:34:41,409
function declaration maybe the most

00:34:36,700 --> 00:34:43,570
interesting thing is they are now

00:34:41,409 --> 00:34:47,139
considering adding a new calling

00:34:43,570 --> 00:34:51,429
convention for functions where you can

00:34:47,139 --> 00:34:54,580
use the return not overload the return

00:34:51,429 --> 00:34:57,339
to both return the real value in

00:34:54,580 --> 00:35:00,130
indicate an error which is was always

00:34:57,339 --> 00:35:02,260
constantly done and seeing them there is

00:35:00,130 --> 00:35:04,370
a number of different proposals to do

00:35:02,260 --> 00:35:06,590
this is a very similar to

00:35:04,370 --> 00:35:09,650
happening in the C++ world that they're

00:35:06,590 --> 00:35:13,280
exploring a similar thing to replace

00:35:09,650 --> 00:35:16,340
exceptions or reporte to as an adjunct

00:35:13,280 --> 00:35:21,920
to exception this is I would love dearly

00:35:16,340 --> 00:35:25,700
loved happiness so any of you

00:35:21,920 --> 00:35:27,620
appropriate system okay so if you know

00:35:25,700 --> 00:35:29,060
if you don't go with this is some this

00:35:27,620 --> 00:35:32,150
kind of concept you can have multiple

00:35:29,060 --> 00:35:33,830
return values that traditionally use it

00:35:32,150 --> 00:35:36,620
that one of the things you return is

00:35:33,830 --> 00:35:44,150
some kind of error indicator this will

00:35:36,620 --> 00:35:48,100
be there's better in integer constants

00:35:44,150 --> 00:35:50,960
so if I have a constant and C I

00:35:48,100 --> 00:35:57,620
initialize it cannot use it to declare

00:35:50,960 --> 00:36:02,480
the song is open or agency can I do that

00:35:57,620 --> 00:36:05,450
I suppose yes and that's because there's

00:36:02,480 --> 00:36:07,870
a different interpretation of what is

00:36:05,450 --> 00:36:10,250
considered an integer constant

00:36:07,870 --> 00:36:12,410
expression when they're trying to look

00:36:10,250 --> 00:36:14,690
line at Morewood see this is one of the

00:36:12,410 --> 00:36:23,980
few places where you still need to use

00:36:14,690 --> 00:36:26,480
macros it's just another thing they're

00:36:23,980 --> 00:36:30,300
considering bringing in is the tie

00:36:26,480 --> 00:36:32,830
production facility that C and

00:36:30,300 --> 00:36:39,030
although I know people probably remember

00:36:32,830 --> 00:36:42,160
Otto from can our Auto and C++ has been

00:36:39,030 --> 00:36:44,290
repurposed it's no longer the original

00:36:42,160 --> 00:36:47,140
meaning it's now used for technical

00:36:44,290 --> 00:36:48,880
duction they're considering bringing

00:36:47,140 --> 00:36:57,130
that and say that would be a

00:36:48,880 --> 00:36:59,490
game-changer - and anyone heard of an

00:36:57,130 --> 00:36:59,490
annex

00:37:03,600 --> 00:37:10,960
that King comes Microsoft world so it's

00:37:07,470 --> 00:37:14,050
stores for copy for example how many

00:37:10,960 --> 00:37:17,050
ways can you misuse her confidence a

00:37:14,050 --> 00:37:20,470
loss in life and this was an attempt to

00:37:17,050 --> 00:37:23,200
make it safer a sacred earth copy but it

00:37:20,470 --> 00:37:26,830
has had almost no adoption because of

00:37:23,200 --> 00:37:29,380
some major design errors of frankly I

00:37:26,830 --> 00:37:32,820
don't recommend using it myself either

00:37:29,380 --> 00:37:32,820
so they're considering dropping

00:37:34,300 --> 00:37:40,580
okay so which line will be which family

00:37:37,850 --> 00:37:44,890
into the language of many years I would

00:37:40,580 --> 00:37:53,020
recommend at least using c99

00:37:44,890 --> 00:37:57,800
you can get will switch the guidelines

00:37:53,020 --> 00:38:00,110
there are unlike the dark ages of scene

00:37:57,800 --> 00:38:02,660
there were really excellent coding

00:38:00,110 --> 00:38:07,420
guidelines I put four different ones

00:38:02,660 --> 00:38:18,680
here kind of an order of preference

00:38:07,420 --> 00:38:21,860
everyone's familiar with my CW those are

00:38:18,680 --> 00:38:23,840
you know you always see news articles

00:38:21,860 --> 00:38:27,050
coming back this hacker took advantage

00:38:23,840 --> 00:38:29,600
of this vulnerability and see those get

00:38:27,050 --> 00:38:34,840
a number and the number comes from the

00:38:29,600 --> 00:38:34,840
minor CW reading database they can

00:38:41,080 --> 00:38:55,280
so it here is an example of whole list

00:38:46,670 --> 00:38:57,820
of honor abilities that he has so far

00:38:55,280 --> 00:38:57,820
under Rights

00:39:00,310 --> 00:39:04,440
they've itemized this they have

00:39:02,170 --> 00:39:08,920
recommendations on how to prevent them

00:39:04,440 --> 00:39:10,270
fantastic information the one I like the

00:39:08,920 --> 00:39:13,300
best and the one I would recommend

00:39:10,270 --> 00:39:16,980
everyone based on this is this is

00:39:13,300 --> 00:39:19,990
available free anyone you can contribute

00:39:16,980 --> 00:39:22,480
to the discussions what kinds of

00:39:19,990 --> 00:39:32,680
features and the cross reference all the

00:39:22,480 --> 00:39:36,940
other standards and that's the property

00:39:32,680 --> 00:39:39,430
court just a fantastic Pope when we hire

00:39:36,940 --> 00:39:46,660
new developers s the one book I make

00:39:39,430 --> 00:39:52,150
everybody and he had its organized like

00:39:46,660 --> 00:39:57,690
this there is rules and recommendations

00:39:52,150 --> 00:39:57,690
oh I will just go to one and

00:40:01,059 --> 00:40:05,169
so here's a here's a credibly common

00:40:04,179 --> 00:40:10,059
error

00:40:05,169 --> 00:40:12,039
you take the size of an array so they

00:40:10,059 --> 00:40:20,319
give you the rule that show you an

00:40:12,039 --> 00:40:24,880
example and an example of how to do it

00:40:20,319 --> 00:40:28,209
the right way and then the last thing is

00:40:24,880 --> 00:40:32,919
they do several examples is they have a

00:40:28,209 --> 00:40:35,130
risk assessment so when when you're when

00:40:32,919 --> 00:40:40,719
you're maintaining an existing code base

00:40:35,130 --> 00:40:44,409
say the Linux kernel some networking

00:40:40,719 --> 00:40:46,659
library if you run a static analysis

00:40:44,409 --> 00:40:48,369
tools on half you won't believe how many

00:40:46,659 --> 00:40:52,269
warnings and errors you're going to get

00:40:48,369 --> 00:40:54,400
how do you begin to tackle them and they

00:40:52,269 --> 00:40:57,939
provide a mechanism of doing this by

00:40:54,400 --> 00:41:00,849
giving a risk assessment report thing to

00:40:57,939 --> 00:41:06,239
give the severity if this happens how

00:41:00,849 --> 00:41:10,059
bad is the engine fall off the plane

00:41:06,239 --> 00:41:14,469
Dinah's control system the car shuts

00:41:10,059 --> 00:41:16,839
down that'd be really really severe how

00:41:14,469 --> 00:41:19,059
likely is it to happen and how much does

00:41:16,839 --> 00:41:21,160
it cost to fix it and they give a score

00:41:19,059 --> 00:41:23,230
a priority

00:41:21,160 --> 00:41:30,160
and then you you can now write your

00:41:23,230 --> 00:41:34,059
defects many of the commercial tools and

00:41:30,160 --> 00:41:36,579
they actually list what tool captures

00:41:34,059 --> 00:41:39,250
this so you can see there are quite a

00:41:36,579 --> 00:41:41,559
few commercial tools that one thing and

00:41:39,250 --> 00:41:44,829
this is something I've been attempting

00:41:41,559 --> 00:41:49,660
to get to is they focus on commercial

00:41:44,829 --> 00:41:52,480
tools and I would love to see here's the

00:41:49,660 --> 00:41:55,869
GCC client to enable to counter this

00:41:52,480 --> 00:42:01,589
arrow and you can of GCC is capable of

00:41:55,869 --> 00:42:01,589
catching many of these in that first

00:42:05,750 --> 00:42:16,040
secure coding and C programming language

00:42:11,590 --> 00:42:18,830
go to my dress make sure you get the

00:42:16,040 --> 00:42:24,560
latest edition they guide you through

00:42:18,830 --> 00:42:26,720
how an attack and a real attack

00:42:24,560 --> 00:42:29,810
something that was actually and used how

00:42:26,720 --> 00:42:32,150
it's done how do you get from buffer

00:42:29,810 --> 00:42:34,040
overflow he shows how that's done

00:42:32,150 --> 00:42:37,430
and then how do you protect against it

00:42:34,040 --> 00:42:41,020
it's just a fantastic book question they

00:42:37,430 --> 00:42:41,020
keep some chapter number

00:42:43,940 --> 00:42:46,690
that way

00:42:46,859 --> 00:42:51,089
to the main page

00:42:54,820 --> 00:43:08,410
I don't know what is it that door

00:43:04,050 --> 00:43:16,750
they're reserved for yes they don't have

00:43:08,410 --> 00:43:19,600
Mac OS iOS they do they do their POSIX

00:43:16,750 --> 00:43:21,940
rules head isn't great they could do

00:43:19,600 --> 00:43:23,380
more Windows as much weaker -

00:43:21,940 --> 00:43:29,980
unfortunately they really should have

00:43:23,380 --> 00:43:32,650
along but in general it's it's really

00:43:29,980 --> 00:43:35,200
comprehensive and they have their wiki

00:43:32,650 --> 00:43:36,880
allows you to enter comments as have you

00:43:35,200 --> 00:43:39,640
know I strongly disagree with this

00:43:36,880 --> 00:43:49,290
here's a better way of expressing this

00:43:39,640 --> 00:43:51,850
rule maestro is the Leon motor industry

00:43:49,290 --> 00:43:53,700
software reliability or substitution

00:43:51,850 --> 00:43:57,130
that's what that stands for they

00:43:53,700 --> 00:43:59,860
published a very good standard they have

00:43:57,130 --> 00:44:01,750
one go through C and C++ it's nowhere

00:43:59,860 --> 00:44:05,770
near as good

00:44:01,750 --> 00:44:08,440
yes young and it cost a bit of money

00:44:05,770 --> 00:44:10,690
I so it's also problematic than that you

00:44:08,440 --> 00:44:13,390
have to pay a couple hundred dollars to

00:44:10,690 --> 00:44:23,349
actually get this back for a company

00:44:13,390 --> 00:44:25,480
it's cheap okay so coding guidelines try

00:44:23,349 --> 00:44:27,580
to adopt a coding on don't wing it

00:44:25,480 --> 00:44:31,840
yourself there's been an enormous amount

00:44:27,580 --> 00:44:36,970
of research effort and I have to say

00:44:31,840 --> 00:44:38,890
this government sponsors these through

00:44:36,970 --> 00:44:41,520
this has been an extraordinary they've

00:44:38,890 --> 00:44:44,520
really done an excellent job to help

00:44:41,520 --> 00:44:44,520
protect

00:44:47,170 --> 00:44:51,170
now we're going to go through some

00:44:49,100 --> 00:44:54,470
things and see that are really

00:44:51,170 --> 00:44:57,080
problematic trying to kind of go through

00:44:54,470 --> 00:44:59,180
this in order or what I find most

00:44:57,080 --> 00:45:01,700
problematic about open source of

00:44:59,180 --> 00:45:04,120
commercials and probably the number one

00:45:01,700 --> 00:45:07,310
thing is error handling in C is just

00:45:04,120 --> 00:45:11,050
farting it's just atrocious

00:45:07,310 --> 00:45:13,550
she doesn't have any standard wave

00:45:11,050 --> 00:45:16,130
signaling that an error has it doesn't

00:45:13,550 --> 00:45:19,160
have exceptions it doesn't have any of

00:45:16,130 --> 00:45:23,570
this based approach as you can take it

00:45:19,160 --> 00:45:30,830
doesn't have go to the go features of

00:45:23,570 --> 00:45:33,470
having multiple return types on top of

00:45:30,830 --> 00:45:37,130
that there's nothing forcing the caller

00:45:33,470 --> 00:45:41,480
to pay attention to a possible error say

00:45:37,130 --> 00:45:45,650
and if there's I would say the number

00:45:41,480 --> 00:45:50,660
one cause reliability and security issue

00:45:45,650 --> 00:45:52,820
is not checking over time if a function

00:45:50,660 --> 00:45:58,100
succeeded properly

00:45:52,820 --> 00:46:01,670
that happens all the time in both the

00:45:58,100 --> 00:46:04,010
commercial and open source and then the

00:46:01,670 --> 00:46:07,970
other part that you do if you are

00:46:04,010 --> 00:46:12,940
careful about handling the code becomes

00:46:07,970 --> 00:46:12,940
unbelievably more boss so it's not

00:46:13,570 --> 00:46:18,980
something where you have a try

00:46:16,280 --> 00:46:22,220
have a whole bunch of function calls and

00:46:18,980 --> 00:46:25,790
bunch of caches that you end up with

00:46:22,220 --> 00:46:28,970
code that into everything we intermingle

00:46:25,790 --> 00:46:39,830
with the mainline business functionality

00:46:28,970 --> 00:46:45,220
of yes that's right in a major kind a

00:46:39,830 --> 00:46:47,750
major complaint about C++ is you have to

00:46:45,220 --> 00:46:50,750
the exception handler which and

00:46:47,750 --> 00:46:54,560
main problems there is you don't have a

00:46:50,750 --> 00:46:58,940
guarantee execution times and the

00:46:54,560 --> 00:47:02,270
overhead is just too hard so I would say

00:46:58,940 --> 00:47:05,600
the majority of in bed people and game

00:47:02,270 --> 00:47:07,370
developers as another area and maybe a

00:47:05,600 --> 00:47:09,170
little more and also in the high

00:47:07,370 --> 00:47:11,770
performance community they don't use

00:47:09,170 --> 00:47:11,770
exception

00:47:17,370 --> 00:47:24,970
so so you have a trade-off here

00:47:21,390 --> 00:47:25,990
what am I going to emphasize yeah and

00:47:24,970 --> 00:47:27,610
now I'm going to show you some

00:47:25,990 --> 00:47:31,540
techniques and try to get around that

00:47:27,610 --> 00:47:33,130
but it's not pretty for honest so here

00:47:31,540 --> 00:47:34,750
are some different alternatives and

00:47:33,130 --> 00:47:38,830
getting back to okay I don't have

00:47:34,750 --> 00:47:41,230
exceptions what do I have a very common

00:47:38,830 --> 00:47:42,970
paradigm in the sea world in the end

00:47:41,230 --> 00:47:45,610
you'll see this above the sea long ever

00:47:42,970 --> 00:47:52,270
in the context library windows library

00:47:45,610 --> 00:47:55,710
is function to return error codes all

00:47:52,270 --> 00:47:59,440
over the place however you'll often see

00:47:55,710 --> 00:48:04,840
that a function will overload what it's

00:47:59,440 --> 00:48:07,030
returning a real useful value with some

00:48:04,840 --> 00:48:10,210
kind of way of signaling that error has

00:48:07,030 --> 00:48:14,140
happened this is called this is

00:48:10,210 --> 00:48:17,620
sometimes overloading another the return

00:48:14,140 --> 00:48:21,550
channel I'll show you some examples of

00:48:17,620 --> 00:48:24,820
how hideously overly that becomes see in

00:48:21,550 --> 00:48:28,150
the standard library the other common

00:48:24,820 --> 00:48:30,450
thing is to use a global variable error

00:48:28,150 --> 00:48:30,450
note

00:48:32,070 --> 00:48:38,970
that's been uniformly can as a bad idea

00:48:36,210 --> 00:48:41,370
now sound they like a good idea long

00:48:38,970 --> 00:48:43,800
time ago from a performance point of

00:48:41,370 --> 00:48:46,680
view is very problematic because you

00:48:43,800 --> 00:48:50,520
can't find pure functions all your

00:48:46,680 --> 00:48:52,020
functions have side effects because of

00:48:50,520 --> 00:48:57,540
that the compiler can make certain

00:48:52,020 --> 00:48:59,670
optimizations and then some more people

00:48:57,540 --> 00:49:02,580
have tried to do is to use callback

00:48:59,670 --> 00:49:04,080
functions and the annex K attempted to

00:49:02,580 --> 00:49:21,350
do that and I think that's a major

00:49:04,080 --> 00:49:21,350
reason ok so did it give some

00:49:21,740 --> 00:49:28,020
examinations here and show you some code

00:49:24,680 --> 00:49:31,200
if I was to focus on one area to improve

00:49:28,020 --> 00:49:33,780
the security profile of my programs that

00:49:31,200 --> 00:49:36,420
would win does define a good error

00:49:33,780 --> 00:49:37,920
strategy what is the model are you

00:49:36,420 --> 00:49:40,020
venting usually always going to return

00:49:37,920 --> 00:49:42,420
an error are you going to designate a

00:49:40,020 --> 00:49:44,430
parameter as return to your network are

00:49:42,420 --> 00:49:47,130
you gonna draw an error something like

00:49:44,430 --> 00:49:51,420
that just be tip 1 be consistent and

00:49:47,130 --> 00:49:53,760
music music consistently if you do

00:49:51,420 --> 00:49:59,140
decide to

00:49:53,760 --> 00:50:01,780
to return a narrow Valley consider use

00:49:59,140 --> 00:50:08,740
of the GCC warned and use for salt

00:50:01,780 --> 00:50:11,920
handed have you turned on the warning

00:50:08,740 --> 00:50:13,390
level - GCC that you get a trigger on

00:50:11,920 --> 00:50:16,150
this and your laundry

00:50:13,390 --> 00:50:19,120
the Jesus the J Lipsy

00:50:16,150 --> 00:50:22,510
almost all the functions that return an

00:50:19,120 --> 00:50:26,350
error code are now annotated with this

00:50:22,510 --> 00:50:29,560
so you will get a compiler warning which

00:50:26,350 --> 00:50:33,310
I highly recommend promoting - an error

00:50:29,560 --> 00:50:40,060
saying you ignored a possible error in

00:50:33,310 --> 00:50:43,240
this function there's a certain idioms

00:50:40,060 --> 00:50:45,370
and then considered a one of maybe the

00:50:43,240 --> 00:50:48,990
most controversial but interesting one

00:50:45,370 --> 00:50:55,150
is the go-to in the Linux kernel

00:50:48,990 --> 00:50:58,330
community and one fan so what they're

00:50:55,150 --> 00:51:00,300
trying to do is implement our API on a

00:50:58,330 --> 00:51:03,610
resource acquisition is initialization

00:51:00,300 --> 00:51:08,110
from the c++ where you get automatically

00:51:03,610 --> 00:51:09,640
enough by simulating and oco-2 I'll show

00:51:08,110 --> 00:51:12,380
more examples of that

00:51:09,640 --> 00:51:14,000
and the other big thing you really think

00:51:12,380 --> 00:51:18,020
about what's an error and what's not

00:51:14,000 --> 00:51:22,210
this is that's probably more than we can

00:51:18,020 --> 00:51:22,210
do so let me switch bad

00:51:27,710 --> 00:51:38,540
so here's some example ok so here's an

00:51:32,990 --> 00:51:41,000
example what if I what if I have a

00:51:38,540 --> 00:51:41,599
string that I want to convert to an

00:51:41,000 --> 00:51:48,320
integer

00:51:41,599 --> 00:51:51,580
what if folks use a or why everyone uses

00:51:48,320 --> 00:52:02,330
a dime and you won't use something else

00:51:51,580 --> 00:52:03,800
okay what if I pass it on to find the

00:52:02,330 --> 00:52:05,720
undefined behavior you don't know what

00:52:03,800 --> 00:52:09,140
you get you don't get an indication that

00:52:05,720 --> 00:52:14,630
it failed it just returns you some the

00:52:09,140 --> 00:52:18,619
energy exceeds comfort so let me show

00:52:14,630 --> 00:52:23,920
you that by and this is an example of

00:52:18,619 --> 00:52:23,920
the disaster that error handling is in C

00:52:36,239 --> 00:52:42,609
yes that's the that's the recommended

00:52:39,249 --> 00:52:47,499
officials interlibrary approach but I'm

00:52:42,609 --> 00:52:51,249
going to show you how to do but let me

00:52:47,499 --> 00:52:56,199
compile it I got a little warning here

00:52:51,249 --> 00:52:59,109
but I'm going to run this now you

00:52:56,199 --> 00:53:03,640
compiled no problems right the codes

00:52:59,109 --> 00:53:08,199
been worried I'm going to pass in and I

00:53:03,640 --> 00:53:10,479
think this takes two arguments okay I

00:53:08,199 --> 00:53:14,140
got a deadly signal from the anthro

00:53:10,479 --> 00:53:16,839
sanitizers here let me let me comment

00:53:14,140 --> 00:53:19,380
out that code just so you can see the

00:53:16,839 --> 00:53:19,380
idea hi

00:53:23,460 --> 00:53:26,270
by the way

00:53:27,350 --> 00:53:37,100
by the way time to go through this the

00:53:33,110 --> 00:53:40,700
address sanitizer shows exactly where

00:53:37,100 --> 00:53:48,770
the memory error happened you don't have

00:53:40,700 --> 00:53:51,590
to hunt it's all 100% reliable like they

00:53:48,770 --> 00:53:57,800
talked with him reliable it's incredible

00:53:51,590 --> 00:54:00,230
how good and kind

00:53:57,800 --> 00:54:06,440
so there's no reason you shouldn't be

00:54:00,230 --> 00:54:08,750
using them definitely please please okay

00:54:06,440 --> 00:54:14,450
so I got it so I'm going to run it now

00:54:08,750 --> 00:54:17,810
so it's pokemon crib that works I'm

00:54:14,450 --> 00:54:22,270
going to panic anybody see and I got

00:54:17,810 --> 00:54:26,660
bangs of course I am Turk zebra right

00:54:22,270 --> 00:54:28,490
what if I gave it really monstrously

00:54:26,660 --> 00:54:34,520
long number

00:54:28,490 --> 00:54:37,760
Oh gives me minus one now okay and your

00:54:34,520 --> 00:54:40,750
code just keeps going on it thinks

00:54:37,760 --> 00:54:40,750
everything's okay

00:54:40,760 --> 00:54:47,780
the alternative and the recommended

00:54:43,579 --> 00:54:53,420
approach and even the sei recommendation

00:54:47,780 --> 00:54:56,839
is used is to replace a 2l with int

00:54:53,420 --> 00:54:59,140
along with skirt together and spur to

00:54:56,839 --> 00:55:04,670
element there's no number of families

00:54:59,140 --> 00:55:08,570
but the area is just atrocious because

00:55:04,670 --> 00:55:11,329
you get an integer back but to figure

00:55:08,570 --> 00:55:15,079
out if an error occurred you have to go

00:55:11,329 --> 00:55:18,260
through this machination first you pass

00:55:15,079 --> 00:55:23,119
in the pointer as one of the arguments

00:55:18,260 --> 00:55:26,030
check to see if is at the beginning if

00:55:23,119 --> 00:55:28,820
it is didn't pass in the number has been

00:55:26,030 --> 00:55:30,740
something else okay that's good I caught

00:55:28,820 --> 00:55:34,550
that but that's not it

00:55:30,740 --> 00:55:36,740
what if there was junk at the end of the

00:55:34,550 --> 00:55:40,849
numbers so I started with one two three

00:55:36,740 --> 00:55:45,349
four and put a name for that I'm going

00:55:40,849 --> 00:55:47,970
to report that as a different error what

00:55:45,349 --> 00:55:52,380
if I've passed in a real

00:55:47,970 --> 00:55:55,230
number that can't be helped by us well

00:55:52,380 --> 00:55:58,800
the way you do that is check to see if

00:55:55,230 --> 00:56:01,950
the value is equal to either min or max

00:55:58,800 --> 00:56:06,810
and then check that air nose was set to

00:56:01,950 --> 00:56:09,390
hearing now who's going to do this the

00:56:06,810 --> 00:56:13,080
answer is nobody does this it's just

00:56:09,390 --> 00:56:16,440
it's just for instance to expect to

00:56:13,080 --> 00:56:19,020
design a standard library or maybe

00:56:16,440 --> 00:56:24,020
better I think of it you're designing an

00:56:19,020 --> 00:56:24,020
API for you don't write code like this

00:56:36,560 --> 00:56:42,119
basically came from the sei

00:56:39,170 --> 00:56:43,980
cert coding guidelines no one is going

00:56:42,119 --> 00:56:46,410
to do with this or what you would do is

00:56:43,980 --> 00:56:54,000
write a wrapper around it and put

00:56:46,410 --> 00:56:57,710
incense of malaria or the art

00:56:54,000 --> 00:56:57,710
back-rubbing that have you brought

00:57:02,760 --> 00:57:16,180
yes here's here's what I would recommend

00:57:12,039 --> 00:57:17,829
is putting on wrapper around horrible

00:57:16,180 --> 00:57:19,680
functions like that so folks are

00:57:17,829 --> 00:57:24,520
familiar with the system called the

00:57:19,680 --> 00:57:25,329
standard library it's just calling a

00:57:24,520 --> 00:57:27,490
function by you

00:57:25,329 --> 00:57:42,760
launches another process anyone ever

00:57:27,490 --> 00:57:46,119
look at the how you signal errors first

00:57:42,760 --> 00:57:54,819
call system first check to see if - one

00:57:46,119 --> 00:57:57,130
was returns excuse me not return then at

00:57:54,819 --> 00:58:00,369
least the system makes it worth of

00:57:57,130 --> 00:58:04,900
cabinets you may need to see get the

00:58:00,369 --> 00:58:08,319
exit status these are three different

00:58:04,900 --> 00:58:12,099
macros respond by the POSIX API exit

00:58:08,319 --> 00:58:14,890
status exited and signaled because while

00:58:12,099 --> 00:58:17,349
the program was processing it might have

00:58:14,890 --> 00:58:18,589
gotten interrupted by signal and we need

00:58:17,349 --> 00:58:21,140
to know that because it

00:58:18,589 --> 00:58:25,009
didn't do what you asked it to do but it

00:58:21,140 --> 00:58:27,200
returned anyway so what do you get back

00:58:25,009 --> 00:58:32,630
you don't get an error you get this

00:58:27,200 --> 00:58:35,599
funky craze with many so here's what I

00:58:32,630 --> 00:58:38,989
recommend and this shows you how to use

00:58:35,599 --> 00:58:42,469
Doc's as well tentative code we wrote a

00:58:38,989 --> 00:58:46,460
little wrapper function called Q on each

00:58:42,469 --> 00:58:50,269
system for the prefix so it's not

00:58:46,460 --> 00:58:53,239
overloading and what it does it takes a

00:58:50,269 --> 00:58:57,259
command to execute and now it returns an

00:58:53,239 --> 00:59:01,269
error of Nealon which is a type that

00:58:57,259 --> 00:59:01,269
comes from the c11

00:59:01,960 --> 00:59:06,440
it's and that's all it is but it's

00:59:04,849 --> 00:59:08,619
indicating that you're returning an

00:59:06,440 --> 00:59:08,619

YouTube URL: https://www.youtube.com/watch?v=nS4MzJC7c8A


