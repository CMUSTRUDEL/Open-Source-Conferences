Title: Ivan Čukić - For a Brighter QFuture - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	The QFuture class has been moved from Qt Concurrent to Qt Core with the release of Qt 5.0 with the aim to make it useful for arbitrary asynchronous operations.

This seems like the last time anyone cared about it - it lives in Qt Core, but nothing in Qt Core uses it. And more importantly, nothing in Qt Core is able to create a new QFuture instance. We can not even model our own asynchronous operations with QFutures, since this requires using private classes in Qt.

ivan|home
Captions: 
	00:00:03,440 --> 00:00:14,610
as you can see my name is even I'm not

00:00:07,980 --> 00:00:17,930
even going to pronounce my surname some

00:00:14,610 --> 00:00:20,490
time ago I started working in KDE and

00:00:17,930 --> 00:00:23,699
that's mostly my background as far as

00:00:20,490 --> 00:00:26,250
cute is concerned I love giving talks a

00:00:23,699 --> 00:00:27,900
lot of teaching and obviously I'm a

00:00:26,250 --> 00:00:30,570
functional programming guy if you ever

00:00:27,900 --> 00:00:34,290
saw any of the presentations I hear that

00:00:30,570 --> 00:00:38,520
cute delays or meeting C++ or somewhere

00:00:34,290 --> 00:00:40,730
else so first a couple of disclaimers I

00:00:38,520 --> 00:00:47,039
you usually start my presentations with

00:00:40,730 --> 00:00:52,020
the hell okay so at least you can you

00:00:47,039 --> 00:00:54,210
can read what's written so this language

00:00:52,020 --> 00:00:57,059
that you should make your code readable

00:00:54,210 --> 00:00:59,010
because somebody who can read your code

00:00:57,059 --> 00:01:01,789
afterwards my dear psycho bed and you

00:00:59,010 --> 00:01:04,159
know where you where you're located it

00:01:01,789 --> 00:01:07,140
that doesn't mean that you should

00:01:04,159 --> 00:01:09,840
actually write the code like you're

00:01:07,140 --> 00:01:12,960
writing for a high schooler you should

00:01:09,840 --> 00:01:16,409
write advanced code and proper code just

00:01:12,960 --> 00:01:20,040
don't Nielsen you will start that nobody

00:01:16,409 --> 00:01:22,830
will understand ever the second part is

00:01:20,040 --> 00:01:27,140
that these are slides visit this is not

00:01:22,830 --> 00:01:29,970
production code and blah blah blah so

00:01:27,140 --> 00:01:33,270
why I decided to talk about the cute

00:01:29,970 --> 00:01:35,820
future quite a long time ago the first

00:01:33,270 --> 00:01:37,890
time when I was a kid to dev days I was

00:01:35,820 --> 00:01:42,659
talking about something related to

00:01:37,890 --> 00:01:44,280
futures and I mentioned q future and

00:01:42,659 --> 00:01:46,530
everybody started laughing because we

00:01:44,280 --> 00:01:51,570
all all know that QE it's a really

00:01:46,530 --> 00:01:54,750
crappy class and because of that from

00:01:51,570 --> 00:01:56,729
that point on I always put some code

00:01:54,750 --> 00:02:00,390
snippet of q future so that the audience

00:01:56,729 --> 00:02:02,640
can laugh and always I say okay we are

00:02:00,390 --> 00:02:04,649
not going to go into a rant about the Q

00:02:02,640 --> 00:02:08,129
future and this time I decided to

00:02:04,649 --> 00:02:11,400
actually do rent about Q future and you

00:02:08,129 --> 00:02:13,890
will see why so first let's talk about

00:02:11,400 --> 00:02:17,040
the future concept itself

00:02:13,890 --> 00:02:19,500
in essence the normal way to call a

00:02:17,040 --> 00:02:21,990
function is you call a function when the

00:02:19,500 --> 00:02:24,720
function completes whatever it is

00:02:21,990 --> 00:02:29,400
intended to do it will return a value

00:02:24,720 --> 00:02:31,260
and then you can use that value but what

00:02:29,400 --> 00:02:34,110
if that function takes a lot a lot of

00:02:31,260 --> 00:02:37,500
time to complete what if the function is

00:02:34,110 --> 00:02:39,390
for example I oh you're asking the user

00:02:37,500 --> 00:02:42,540
to type you something you're reading

00:02:39,390 --> 00:02:45,000
something from the drive it can be slow

00:02:42,540 --> 00:02:47,160
you you do network communication which

00:02:45,000 --> 00:02:51,300
again you cannot guarantee that it will

00:02:47,160 --> 00:02:54,180
happen quickly instead of having a

00:02:51,300 --> 00:02:57,450
function which returns an actual value

00:02:54,180 --> 00:02:59,940
what is a cure what is the future okay

00:02:57,450 --> 00:03:03,030
usually guild videos with callback

00:02:59,940 --> 00:03:05,600
signal slots and creating a new thread

00:03:03,030 --> 00:03:09,600
and do the actual work on the thread and

00:03:05,600 --> 00:03:12,690
our code is starts looking really crappy

00:03:09,600 --> 00:03:16,290
instead of having a normal flow of logic

00:03:12,690 --> 00:03:18,840
like the diagram on the left you have

00:03:16,290 --> 00:03:21,269
actually to split every single thing

00:03:18,840 --> 00:03:23,190
that you do into a call and call back

00:03:21,269 --> 00:03:25,799
call and call back and then you end up

00:03:23,190 --> 00:03:30,780
with something that looks like one of my

00:03:25,799 --> 00:03:34,350
favorite things this is a spaghetti code

00:03:30,780 --> 00:03:37,260
by George Hut and this is actually how a

00:03:34,350 --> 00:03:41,549
lot of cute projects really look like

00:03:37,260 --> 00:03:44,280
and although this is a really nice as

00:03:41,549 --> 00:03:49,049
art it's not it wouldn't be really nice

00:03:44,280 --> 00:03:51,870
is a project design so instead of having

00:03:49,049 --> 00:03:54,810
calls callbacks and directly calling

00:03:51,870 --> 00:03:57,900
functions that return values we want to

00:03:54,810 --> 00:04:00,030
have some an advanced simple but

00:03:57,900 --> 00:04:02,220
advanced concept called the future what

00:04:00,030 --> 00:04:05,400
is the future it's a handle that will

00:04:02,220 --> 00:04:09,000
eventually get a value so you're getting

00:04:05,400 --> 00:04:10,980
a handle like a small box in which

00:04:09,000 --> 00:04:14,459
somebody will at some point in the

00:04:10,980 --> 00:04:17,880
future put the actual value and that's a

00:04:14,459 --> 00:04:20,880
really really simple concept now how do

00:04:17,880 --> 00:04:23,700
you get the value from the future the

00:04:20,880 --> 00:04:27,419
most obvious way when you see the API is

00:04:23,700 --> 00:04:27,760
the code but get who can see the problem

00:04:27,419 --> 00:04:32,850
in

00:04:27,760 --> 00:04:35,890
this pattern yet is going to block

00:04:32,850 --> 00:04:38,860
essentially somebody gave you a future

00:04:35,890 --> 00:04:43,720
for a reason it's an expensive operation

00:04:38,860 --> 00:04:45,940
which will yield its result much later

00:04:43,720 --> 00:04:48,760
and then you call it out yet and you're

00:04:45,940 --> 00:04:51,160
making a synchronous call like a normal

00:04:48,760 --> 00:04:54,000
function you're blocking your main code

00:04:51,160 --> 00:04:59,110
so this is something that you absolutely

00:04:54,000 --> 00:05:01,750
should never do there are use cases for

00:04:59,110 --> 00:05:04,510
Doug get but you're not going to to go

00:05:01,750 --> 00:05:06,430
into those some of the libraries that

00:05:04,510 --> 00:05:08,950
you will I be able to use with futures

00:05:06,430 --> 00:05:11,050
don't actually allow you to call that

00:05:08,950 --> 00:05:13,930
get on the future that is not completed

00:05:11,050 --> 00:05:16,330
you will get a segmentation fault or an

00:05:13,930 --> 00:05:20,770
exception or something unfortunately

00:05:16,330 --> 00:05:24,970
both cute and SED central library block

00:05:20,770 --> 00:05:27,010
when the dog get is being called so what

00:05:24,970 --> 00:05:29,980
you should do instead instead of calling

00:05:27,010 --> 00:05:32,890
dot yet you should when you get the

00:05:29,980 --> 00:05:36,250
handle you don't care about the result

00:05:32,890 --> 00:05:39,160
you just want to tell okay this is my

00:05:36,250 --> 00:05:42,070
box which will eventually get a value

00:05:39,160 --> 00:05:44,650
and you dead box you should explain to

00:05:42,070 --> 00:05:47,620
date box but it should do with the value

00:05:44,650 --> 00:05:50,200
of then it gets it so you don't anymore

00:05:47,620 --> 00:05:53,110
you don't care about the value that you

00:05:50,200 --> 00:05:55,270
will get your just explaining the future

00:05:53,110 --> 00:05:59,880
what it should do with the value once

00:05:55,270 --> 00:06:02,890
the value is available so in this case

00:05:59,880 --> 00:06:06,220
some so the code we have a handler and

00:06:02,890 --> 00:06:11,170
we want to vent the future eyes we want

00:06:06,220 --> 00:06:15,490
to call a lambda on that value but you

00:06:11,170 --> 00:06:20,070
it will look like this in C++ 17 the the

00:06:15,490 --> 00:06:23,410
middle line handle dot then you can pass

00:06:20,070 --> 00:06:26,290
similar to this not exactly you can pass

00:06:23,410 --> 00:06:29,320
a lambda that you'll be able to use the

00:06:26,290 --> 00:06:32,710
value once it's completed unfortunately

00:06:29,320 --> 00:06:36,820
in C++ 20 something we will hate we will

00:06:32,710 --> 00:06:38,830
have a weight which will be a magical

00:06:36,820 --> 00:06:39,689
thing and if you've inspired by monads

00:06:38,830 --> 00:06:41,729
and

00:06:39,689 --> 00:06:43,499
stuff like that serve evil we are going

00:06:41,729 --> 00:06:47,909
to skip that unless somebody's

00:06:43,499 --> 00:06:50,549
interested if somebody is interested you

00:06:47,909 --> 00:06:54,749
can ask at the end of the talk no but

00:06:50,549 --> 00:07:00,569
the Irate will be like okay 14 turbo

00:06:54,749 --> 00:07:05,339
from John karma if we don't care so okay

00:07:00,569 --> 00:07:08,699
so in his blog post about functional

00:07:05,339 --> 00:07:10,949
programming in C++ he said that usually

00:07:08,699 --> 00:07:13,949
most of our bugs are because we don't

00:07:10,949 --> 00:07:16,259
understand the state of our program and

00:07:13,949 --> 00:07:18,929
in which different states or program can

00:07:16,259 --> 00:07:20,939
beam and when you actually add threading

00:07:18,929 --> 00:07:23,039
and the synchronous computations like

00:07:20,939 --> 00:07:27,679
you choose and everything else you just

00:07:23,039 --> 00:07:31,139
create much worse problems for yourself

00:07:27,679 --> 00:07:33,739
so in C++ we have a couple of libraries

00:07:31,139 --> 00:07:38,369
that provides us provide us with futures

00:07:33,739 --> 00:07:41,369
one is the STD future which is not so

00:07:38,369 --> 00:07:45,569
great at this point in C++ 17 it will be

00:07:41,369 --> 00:07:48,300
nice both future which is what STD

00:07:45,569 --> 00:07:49,829
future will be so it has dot dan it has

00:07:48,300 --> 00:07:53,309
everything that you wanted to have to do

00:07:49,829 --> 00:07:56,129
to here and we have poly future which is

00:07:53,309 --> 00:07:59,759
a facebook library fall if your tree is

00:07:56,129 --> 00:08:01,709
designed after the same class since the

00:07:59,759 --> 00:08:03,809
scholar programming language and this is

00:08:01,709 --> 00:08:06,300
the one that will throw an exception if

00:08:03,809 --> 00:08:08,939
you call it get on an unfinished future

00:08:06,300 --> 00:08:11,809
which is a beautiful design because it

00:08:08,939 --> 00:08:15,659
will force you not to use that get and

00:08:11,809 --> 00:08:22,139
obviously have the Q future and here

00:08:15,659 --> 00:08:24,569
begins the rent so Q future started its

00:08:22,139 --> 00:08:27,809
life as a part of the cute concurrent

00:08:24,569 --> 00:08:29,519
and the idea was if you need to process

00:08:27,809 --> 00:08:33,240
a large collection of data for example

00:08:29,519 --> 00:08:35,990
some a huge list of numbers cute is

00:08:33,240 --> 00:08:39,329
helpful enough to spin a few threads

00:08:35,990 --> 00:08:41,099
give a part of that collection to each

00:08:39,329 --> 00:08:44,250
of the threads each of the threads

00:08:41,099 --> 00:08:46,470
calculates its part and then it returns

00:08:44,250 --> 00:08:49,309
the final value for example if you want

00:08:46,470 --> 00:08:53,520
to get a sum of a collection of numbers

00:08:49,309 --> 00:08:55,890
so you had operations like filtering map

00:08:53,520 --> 00:08:59,670
being so mapreduce and everything else

00:08:55,890 --> 00:09:01,920
and the main use case especially with

00:08:59,670 --> 00:09:05,190
the dot get method was the whole joint

00:09:01,920 --> 00:09:07,590
pattern so you fork your process into

00:09:05,190 --> 00:09:10,260
Mosul a few threads when all the threads

00:09:07,590 --> 00:09:13,710
finish you join them and you get back

00:09:10,260 --> 00:09:18,020
the result and it works really well for

00:09:13,710 --> 00:09:22,140
the use cases that cute concurrent does

00:09:18,020 --> 00:09:25,070
unfortunately in cute five the idea was

00:09:22,140 --> 00:09:30,000
to make the Cure future much more useful

00:09:25,070 --> 00:09:32,160
so mark from k-dub argued that q future

00:09:30,000 --> 00:09:33,690
should not be in cute concurrent that it

00:09:32,160 --> 00:09:36,510
should be moved to cute core because

00:09:33,690 --> 00:09:39,180
it's a really useful concept and it can

00:09:36,510 --> 00:09:42,900
be used outside of the cute concurrent

00:09:39,180 --> 00:09:47,220
so on the road to cute five this is one

00:09:42,900 --> 00:09:49,620
of the male's mark road and finally we

00:09:47,220 --> 00:09:53,100
have the q future as a part of cute core

00:09:49,620 --> 00:09:56,070
and all is well at least that was the

00:09:53,100 --> 00:09:59,370
idea the problem is that q future is

00:09:56,070 --> 00:10:03,750
still meant to handle only thread bathe

00:09:59,370 --> 00:10:06,420
a synchronous operations so for example

00:10:03,750 --> 00:10:08,250
you need to have a thread pool in order

00:10:06,420 --> 00:10:12,630
for it to work correctly and everything

00:10:08,250 --> 00:10:16,170
else and still cute has a lot of class

00:10:12,630 --> 00:10:18,210
is inside or a lot of methods that could

00:10:16,170 --> 00:10:20,880
have used q future but they are not

00:10:18,210 --> 00:10:24,210
because Q future is actually not meant

00:10:20,880 --> 00:10:25,890
to be used as a proper future we have a

00:10:24,210 --> 00:10:29,090
queue matter of the king wok method

00:10:25,890 --> 00:10:33,570
which is something that can invoke cutes

00:10:29,090 --> 00:10:35,730
meta methods and from the documentation

00:10:33,570 --> 00:10:37,920
you can see if you know invocation is a

00:10:35,730 --> 00:10:40,740
synchronous so you pass the dekyon

00:10:37,920 --> 00:10:44,820
location argument the return value

00:10:40,740 --> 00:10:48,240
cannot be evaluated why why doesn't

00:10:44,820 --> 00:10:50,700
evoke method return a queue future the

00:10:48,240 --> 00:10:53,780
second thing we have at least one class

00:10:50,700 --> 00:11:00,000
that is similar to QD buzz pending reply

00:10:53,780 --> 00:11:03,450
which is a who knows the bus okay so

00:11:00,000 --> 00:11:05,940
give us is IPC protocol on Linux you

00:11:03,450 --> 00:11:07,320
call something then you get the result

00:11:05,940 --> 00:11:09,720
and because it can

00:11:07,320 --> 00:11:12,780
expensive operation you can take some

00:11:09,720 --> 00:11:15,390
time depending reply is something that

00:11:12,780 --> 00:11:18,420
will allow you to register and know when

00:11:15,390 --> 00:11:20,220
the reply actually arrived what is the

00:11:18,420 --> 00:11:23,220
difference between QD buzz pending reply

00:11:20,220 --> 00:11:26,010
and concept of futures absolutely

00:11:23,220 --> 00:11:29,040
nothing it's again it's something it's a

00:11:26,010 --> 00:11:32,220
handler to a value that will appear

00:11:29,040 --> 00:11:35,310
sometime in the future then we have to

00:11:32,220 --> 00:11:37,680
network reply again you're asking for

00:11:35,310 --> 00:11:41,190
something you're getting a value at some

00:11:37,680 --> 00:11:43,860
point in the future back and that thing

00:11:41,190 --> 00:11:47,730
also is not a cure future so we here at

00:11:43,860 --> 00:11:50,730
least I've listed at least three items

00:11:47,730 --> 00:11:54,810
from cute one item from Katie frameworks

00:11:50,730 --> 00:11:57,150
and all of those essentially our futures

00:11:54,810 --> 00:11:59,250
but we cannot use them as fusions

00:11:57,150 --> 00:12:04,650
because Q future was not meant to be

00:11:59,250 --> 00:12:07,290
used like that so why it would be a

00:12:04,650 --> 00:12:10,710
really a nice thing to have a normal

00:12:07,290 --> 00:12:14,400
future that can model everything that we

00:12:10,710 --> 00:12:17,940
already have seen sometimes you want

00:12:14,400 --> 00:12:20,160
just to implement your own stuff and you

00:12:17,940 --> 00:12:22,080
don't care whether your process result

00:12:20,160 --> 00:12:26,070
function will be called on a network

00:12:22,080 --> 00:12:28,830
reply on a d-bus reply on a user input

00:12:26,070 --> 00:12:31,740
or anything else you just need to pass

00:12:28,830 --> 00:12:34,020
it and tell it this value will appear

00:12:31,740 --> 00:12:36,180
sometime in the future you can't do it

00:12:34,020 --> 00:12:39,330
you have to write process result for

00:12:36,180 --> 00:12:41,910
each and every of the cute classes that

00:12:39,330 --> 00:12:44,160
can return you value something in the

00:12:41,910 --> 00:12:46,950
future because Q future is not the

00:12:44,160 --> 00:12:50,730
superclass of all of those and Q future

00:12:46,950 --> 00:12:54,930
cannot be legally used to model all of

00:12:50,730 --> 00:12:57,060
those so it feel it would be really

00:12:54,930 --> 00:13:01,260
really beneficial if we could use Q

00:12:57,060 --> 00:13:05,820
futures in a normal way so the next

00:13:01,260 --> 00:13:08,940
thing if we kinda seed for what we can

00:13:05,820 --> 00:13:11,850
use your futures and we told it it's now

00:13:08,940 --> 00:13:15,170
cute core and not cute concurrent how

00:13:11,850 --> 00:13:19,350
can we create a future an instance of it

00:13:15,170 --> 00:13:20,370
first thing you open the dapi you see

00:13:19,350 --> 00:13:24,210
there is there are two

00:13:20,370 --> 00:13:26,040
constructors one constructor is the

00:13:24,210 --> 00:13:28,470
default one and one is the copy

00:13:26,040 --> 00:13:31,320
constructor the default one creates an

00:13:28,470 --> 00:13:35,279
invalid future and the copy constructor

00:13:31,320 --> 00:13:38,040
obviously copies the future so from the

00:13:35,279 --> 00:13:40,350
normal part of the API at least as far

00:13:38,040 --> 00:13:43,080
as the cute core is concerned the only

00:13:40,350 --> 00:13:45,870
future that you've ever ever going to be

00:13:43,080 --> 00:13:48,630
able to create is an invalid future and

00:13:45,870 --> 00:13:51,750
copy copy it around which is again

00:13:48,630 --> 00:13:56,010
completely users right then you open the

00:13:51,750 --> 00:13:58,290
API documentation and what what do you

00:13:56,010 --> 00:14:00,810
get from the dogs to start the

00:13:58,290 --> 00:14:04,980
computation use one of the API is in the

00:14:00,810 --> 00:14:08,130
concurrent framework so in a class that

00:14:04,980 --> 00:14:11,670
is in the cute core the only way to

00:14:08,130 --> 00:14:14,040
construct it is by going through cute

00:14:11,670 --> 00:14:19,200
concurrent so it's not really separate

00:14:14,040 --> 00:14:22,020
right and that's one of my favorite that

00:14:19,200 --> 00:14:24,690
gives bid with a cute future how do you

00:14:22,020 --> 00:14:27,060
get the value you can call that get

00:14:24,690 --> 00:14:31,380
which we already said it's a bad thing

00:14:27,060 --> 00:14:33,360
to do alternatively if you want to chain

00:14:31,380 --> 00:14:35,730
a continuing continuation to the future

00:14:33,360 --> 00:14:38,670
instead of calling dots down which we

00:14:35,730 --> 00:14:42,120
don't have in cute we need to get this

00:14:38,670 --> 00:14:44,490
snippet of code because Q future is not

00:14:42,120 --> 00:14:49,890
meant to be used like this it's meant

00:14:44,490 --> 00:14:55,490
for the fort drum pattern so let's

00:14:49,890 --> 00:14:59,370
continue there is there are quite a few

00:14:55,490 --> 00:15:02,190
varieties regarding future usually when

00:14:59,370 --> 00:15:05,430
you say this is a future of integer you

00:15:02,190 --> 00:15:08,910
mean after a while of an integer will

00:15:05,430 --> 00:15:11,850
pop up right will Q future it's not

00:15:08,910 --> 00:15:15,300
really a single integer you can get a

00:15:11,850 --> 00:15:18,150
list of integers a single future

00:15:15,300 --> 00:15:23,120
orphaned is not a single future value of

00:15:18,150 --> 00:15:26,070
paint but a series of values of integer

00:15:23,120 --> 00:15:29,430
again why because good it was useful for

00:15:26,070 --> 00:15:32,970
cute concurrent so whenever you see Q

00:15:29,430 --> 00:15:33,160
future of tea you should just think of

00:15:32,970 --> 00:15:35,500
you

00:15:33,160 --> 00:15:40,930
or for yourself in your head it's a

00:15:35,500 --> 00:15:43,690
queue future of a list of keys okay the

00:15:40,930 --> 00:15:47,139
second thing is that it can start an

00:15:43,690 --> 00:15:50,079
exception so for example you called the

00:15:47,139 --> 00:15:52,180
cute concurrent run and the function

00:15:50,079 --> 00:15:54,279
that was run as synchronously throws an

00:15:52,180 --> 00:15:56,620
exception it will be stored in the

00:15:54,279 --> 00:15:58,870
future so that you can access it somehow

00:15:56,620 --> 00:16:01,389
the problem is that you don't have the

00:15:58,870 --> 00:16:04,180
API to access it the only way to access

00:16:01,389 --> 00:16:05,980
the stored error inside the cube few

00:16:04,180 --> 00:16:09,040
trees were actually called but get to

00:16:05,980 --> 00:16:12,220
force the c++ runtime to actually throw

00:16:09,040 --> 00:16:15,069
that the exception again and then to

00:16:12,220 --> 00:16:18,819
catch it to the tricare block which is

00:16:15,069 --> 00:16:21,339
everything but efficient and that's

00:16:18,819 --> 00:16:23,290
something that I actually tried to do

00:16:21,339 --> 00:16:26,439
push a patch to cute and get rejected

00:16:23,290 --> 00:16:28,360
because who would ever need to actually

00:16:26,439 --> 00:16:33,189
check for an error inside the cube

00:16:28,360 --> 00:16:37,029
future but who cares the SEC and the

00:16:33,189 --> 00:16:39,579
last strange thing is that when I tell

00:16:37,029 --> 00:16:41,620
you I'll you ask me for the time and I

00:16:39,579 --> 00:16:44,410
ok I'll tell you later I'm just doing

00:16:41,620 --> 00:16:47,019
something else is it normal for you to

00:16:44,410 --> 00:16:50,230
in the middle of my work to tell me ok

00:16:47,019 --> 00:16:53,290
pause that know when you say I want a

00:16:50,230 --> 00:16:55,899
queue future it's not something that you

00:16:53,290 --> 00:16:58,269
should be able to pause it's not a job

00:16:55,899 --> 00:17:01,600
it's not a task it's not called Q job

00:16:58,269 --> 00:17:04,839
it's called Q future but Q future has

00:17:01,600 --> 00:17:07,240
said Paul it has canceled it has a lot

00:17:04,839 --> 00:17:11,409
of methods that are just not meant for

00:17:07,240 --> 00:17:16,959
futures and I think this is the end of

00:17:11,409 --> 00:17:21,010
the rent so since the Cure future is a

00:17:16,959 --> 00:17:23,470
really nice concept and it's a bi-stable

00:17:21,010 --> 00:17:26,049
so you can use it in your api's and

00:17:23,470 --> 00:17:30,809
everything else it's really a shame that

00:17:26,049 --> 00:17:34,630
you can't really use it so I decided to

00:17:30,809 --> 00:17:36,880
take take a dive into the code and see

00:17:34,630 --> 00:17:39,730
how the Q future is actually implemented

00:17:36,880 --> 00:17:42,480
and whether i can count on the internal

00:17:39,730 --> 00:17:47,390
of the implementation to be api and api

00:17:42,480 --> 00:17:52,610
compatible so every q future that you

00:17:47,390 --> 00:17:55,550
up is instantiated by a class called q

00:17:52,610 --> 00:17:58,880
future interface which you can implement

00:17:55,550 --> 00:18:02,540
for yourself so we are going now going

00:17:58,880 --> 00:18:04,490
to see a couple of examples obviously if

00:18:02,540 --> 00:18:06,290
you read the first paragraph we are

00:18:04,490 --> 00:18:08,150
going to pretend that we are legal

00:18:06,290 --> 00:18:10,670
programmers we are not going to subvert

00:18:08,150 --> 00:18:13,610
C++ actually access private parts of

00:18:10,670 --> 00:18:16,520
your future we are going to do judge the

00:18:13,610 --> 00:18:24,140
things that C++ allows us to do legally

00:18:16,520 --> 00:18:26,480
and legally I say the I ok so what is

00:18:24,140 --> 00:18:29,660
the simplest way to create a future with

00:18:26,480 --> 00:18:32,890
predefined value you create a new Q

00:18:29,660 --> 00:18:38,390
future interface create a future from it

00:18:32,890 --> 00:18:41,570
then say ok this future the thing that

00:18:38,390 --> 00:18:45,770
calculates it has started it report to

00:18:41,570 --> 00:18:48,620
the result which is specified by the

00:18:45,770 --> 00:18:52,130
value of variable and your report that

00:18:48,620 --> 00:18:56,720
you have finished now you have created a

00:18:52,130 --> 00:18:59,300
future which already has a value unlike

00:18:56,720 --> 00:19:01,760
the default API which only allows you to

00:18:59,300 --> 00:19:03,500
create a canceled future now you can

00:19:01,760 --> 00:19:07,400
even create a future that already has a

00:19:03,500 --> 00:19:11,060
value not much use for that but it's a

00:19:07,400 --> 00:19:13,370
start if you want to create a future

00:19:11,060 --> 00:19:15,050
that has an error it's almost the same

00:19:13,370 --> 00:19:21,230
jars instead of reporting the value

00:19:15,050 --> 00:19:23,420
report an exception ok what if you want

00:19:21,230 --> 00:19:25,790
to create actually something a little

00:19:23,420 --> 00:19:28,730
bit more advanced for example you want

00:19:25,790 --> 00:19:31,880
to create a delayed future which will be

00:19:28,730 --> 00:19:35,270
able to return you a specified value

00:19:31,880 --> 00:19:38,330
after some amount of time for example

00:19:35,270 --> 00:19:40,400
you want to get into your contacting a

00:19:38,330 --> 00:19:43,400
server and you want to get to default

00:19:40,400 --> 00:19:44,840
value after a minute if the the

00:19:43,400 --> 00:19:47,710
connection broke or something like that

00:19:44,840 --> 00:19:51,830
you want to have a delay if you to read

00:19:47,710 --> 00:19:54,020
default value you would inherit from pal

00:19:51,830 --> 00:19:58,190
from key object in order to be able to

00:19:54,020 --> 00:20:02,369
use Q timers properly and then you'll

00:19:58,190 --> 00:20:05,379
inherit the QQ interface of

00:20:02,369 --> 00:20:07,149
how do you implement the method that

00:20:05,379 --> 00:20:11,259
actually returns in your future hold

00:20:07,149 --> 00:20:14,519
start simply the same code that we

00:20:11,259 --> 00:20:19,149
already had you say report started and

00:20:14,519 --> 00:20:21,849
when the timer hits off you report the

00:20:19,149 --> 00:20:27,789
result you report it is finished and you

00:20:21,849 --> 00:20:31,749
delete later the you dis the delayed

00:20:27,789 --> 00:20:34,419
future interface so now we have a little

00:20:31,749 --> 00:20:37,329
bit more advanced walk instead of just

00:20:34,419 --> 00:20:39,879
having the the rudimentary we already

00:20:37,329 --> 00:20:41,979
have a value you're now able to create a

00:20:39,879 --> 00:20:43,929
future that will actually return as the

00:20:41,979 --> 00:20:51,129
value of artists be specified amount of

00:20:43,929 --> 00:20:53,950
time and because i was bored at some

00:20:51,129 --> 00:20:57,700
point in my life i decided to start

00:20:53,950 --> 00:21:02,799
writing a better library just as a

00:20:57,700 --> 00:21:05,649
playground thingy that that kind of digs

00:21:02,799 --> 00:21:08,200
through all of the q future back stuff

00:21:05,649 --> 00:21:12,729
in order to provide an API that could

00:21:08,200 --> 00:21:17,829
actually be used so how do i create a

00:21:12,729 --> 00:21:20,529
cue future then you have represented

00:21:17,829 --> 00:21:24,539
that is already here you just write make

00:21:20,529 --> 00:21:27,929
ready future this is a pendant for the

00:21:24,539 --> 00:21:31,149
make ready future that will be in STD

00:21:27,929 --> 00:21:33,700
the standard template library for the

00:21:31,149 --> 00:21:36,549
STD future if you want to create a

00:21:33,700 --> 00:21:38,859
canceled future you can create the void

00:21:36,549 --> 00:21:42,339
one or the integer one or whatever you

00:21:38,859 --> 00:21:45,039
want you can create instantiate the

00:21:42,339 --> 00:21:48,099
thing that we so earlier make delayed

00:21:45,039 --> 00:21:51,570
future it will return the value 42 after

00:21:48,099 --> 00:21:54,429
an hour and 30 minutes is this bus and

00:21:51,570 --> 00:22:01,119
by the way this works obviously only in

00:21:54,429 --> 00:22:04,389
c++ 14 now these futures might have not

00:22:01,119 --> 00:22:08,859
been that my debt debt useful you can

00:22:04,389 --> 00:22:11,589
create represent things for example d

00:22:08,859 --> 00:22:13,549
bus a sinkhole instead of returning a

00:22:11,589 --> 00:22:15,529
divorce pending reply to your written

00:22:13,549 --> 00:22:19,159
proper future which you can pass on to

00:22:15,529 --> 00:22:22,159
napi that requires futures then you have

00:22:19,159 --> 00:22:24,980
process get output it will wait for all

00:22:22,159 --> 00:22:29,049
the whole process to finish and it will

00:22:24,980 --> 00:22:31,460
return your result again exok and

00:22:29,049 --> 00:22:33,649
similar stuff for everything that you

00:22:31,460 --> 00:22:38,389
actually need you will be able to create

00:22:33,649 --> 00:22:43,419
a rapper that in as efficient as

00:22:38,389 --> 00:22:43,419
possible way creates a new cube future

00:22:43,539 --> 00:22:49,429
how do you get a value from a cue future

00:22:46,609 --> 00:22:51,649
you don't one of the benefits of the

00:22:49,429 --> 00:22:54,909
strange implementation of the q future

00:22:51,649 --> 00:22:58,759
proper is that if you don't base it on

00:22:54,909 --> 00:23:01,190
threads and thread pulls when somebody

00:22:58,759 --> 00:23:04,669
calls dot get on your customer made

00:23:01,190 --> 00:23:06,109
future he will get a segfault and that's

00:23:04,669 --> 00:23:10,970
one of the things that i actually like

00:23:06,109 --> 00:23:13,669
and because that way anybody who

00:23:10,970 --> 00:23:16,489
actually uses my library that returns

00:23:13,669 --> 00:23:20,080
him a future will have to avoid calling

00:23:16,489 --> 00:23:22,309
Doggett which is so freaking cool and

00:23:20,080 --> 00:23:25,460
some people actually thought it was a

00:23:22,309 --> 00:23:29,509
bug but AG head I took an hour to

00:23:25,460 --> 00:23:32,359
explain that it's a feature so you never

00:23:29,509 --> 00:23:35,090
should call dot yet on a future what you

00:23:32,359 --> 00:23:40,090
should do is pass it on to something

00:23:35,090 --> 00:23:43,700
else so what have I started implementing

00:23:40,090 --> 00:23:47,059
most of these things are functioning

00:23:43,700 --> 00:23:50,720
properly some of the things need to do

00:23:47,059 --> 00:23:53,419
to be continued so one of the things

00:23:50,720 --> 00:23:55,759
that you can do on a future is partly

00:23:53,419 --> 00:24:00,679
through transformation so for example

00:23:55,759 --> 00:24:05,629
you want to get a user input some block

00:24:00,679 --> 00:24:08,269
of text and you want to have length of

00:24:05,629 --> 00:24:11,980
death text when the text appears you

00:24:08,269 --> 00:24:14,869
just need to to do input pipe transform

00:24:11,980 --> 00:24:18,169
transform with what function with you

00:24:14,869 --> 00:24:21,169
string count column length who has

00:24:18,169 --> 00:24:25,850
seemed both strange or the range

00:24:21,169 --> 00:24:26,870
proposal for c++ know 20-something ok so

00:24:25,850 --> 00:24:29,480
the

00:24:26,870 --> 00:24:31,790
the approach is the same you share a

00:24:29,480 --> 00:24:34,070
collection and you pass it through a

00:24:31,790 --> 00:24:37,220
series of transformations something like

00:24:34,070 --> 00:24:40,040
SQL something like shell programming and

00:24:37,220 --> 00:24:42,559
stuff like that and a few trees again

00:24:40,040 --> 00:24:44,480
it's a kind of a collection it's not a

00:24:42,559 --> 00:24:46,940
collection that immediately immediately

00:24:44,480 --> 00:24:49,220
has all the data but it's a collection

00:24:46,940 --> 00:24:51,950
that will some time at some point in the

00:24:49,220 --> 00:24:54,830
future have data so it's kind of obvious

00:24:51,950 --> 00:24:58,309
that we should be able to use it as if

00:24:54,830 --> 00:25:01,700
it were a collection alternatively you

00:24:58,309 --> 00:25:05,150
can pile the input through a filter you

00:25:01,700 --> 00:25:08,150
got a an array of lines from the user

00:25:05,150 --> 00:25:11,030
you want to validate and remove all the

00:25:08,150 --> 00:25:15,020
invalid ones you just pipe through a

00:25:11,030 --> 00:25:17,690
filter function okay and just remember

00:25:15,020 --> 00:25:20,960
your future string is essentially q

00:25:17,690 --> 00:25:24,670
future of list of strings so the filter

00:25:20,960 --> 00:25:29,780
here will get Elizabeth strings and just

00:25:24,670 --> 00:25:32,780
remove all those that are not valid now

00:25:29,780 --> 00:25:36,020
the next thing both you string length

00:25:32,780 --> 00:25:38,360
and input validation functions are fast

00:25:36,020 --> 00:25:41,720
functions they are not functions that

00:25:38,360 --> 00:25:44,360
will block your your main thread or

00:25:41,720 --> 00:25:46,400
anything else but what should you do if

00:25:44,360 --> 00:25:49,220
you actually have a couple of functions

00:25:46,400 --> 00:25:52,130
that you want to chain and all of those

00:25:49,220 --> 00:25:53,929
functions should be a synchronous so all

00:25:52,130 --> 00:25:57,890
of those functions should return a queue

00:25:53,929 --> 00:26:00,890
future for example I want to send a

00:25:57,890 --> 00:26:03,500
request to a web page that web page will

00:26:00,890 --> 00:26:06,980
return HTML code to me to me I will

00:26:03,500 --> 00:26:08,990
parse the HTML code and then send a

00:26:06,980 --> 00:26:12,559
synchronous request for all the images

00:26:08,990 --> 00:26:14,630
that are inside that web page so all of

00:26:12,559 --> 00:26:17,390
those are kind of a synchronous

00:26:14,630 --> 00:26:20,650
functions you can't do anything apart

00:26:17,390 --> 00:26:23,420
maybe from parsing and extracting images

00:26:20,650 --> 00:26:25,130
everything else needs to be done as

00:26:23,420 --> 00:26:28,970
synchronously in order not to block the

00:26:25,130 --> 00:26:32,390
main thread so what can you do you can

00:26:28,970 --> 00:26:35,240
just type it directly to something else

00:26:32,390 --> 00:26:37,010
and this is something that in functional

00:26:35,240 --> 00:26:40,600
programming is called the magnetic bind

00:26:37,010 --> 00:26:43,420
so you have two functions

00:26:40,600 --> 00:26:46,420
that return a cue future they asked for

00:26:43,420 --> 00:26:50,050
a value and return a cute future and you

00:26:46,420 --> 00:26:52,540
want to compose them so that when the

00:26:50,050 --> 00:26:56,230
result of the first one the future

00:26:52,540 --> 00:26:59,890
arrives it automatically passes to the

00:26:56,230 --> 00:27:04,600
second one if use the transform like in

00:26:59,890 --> 00:27:08,200
the previous slide know what would

00:27:04,600 --> 00:27:10,630
happen input transform some function

00:27:08,200 --> 00:27:14,760
that returns a cue future the whole type

00:27:10,630 --> 00:27:23,230
will be Q future / q future other value

00:27:14,760 --> 00:27:28,720
okay let me repeat so is is it obvious

00:27:23,230 --> 00:27:32,890
what transponders okay so you have a cue

00:27:28,720 --> 00:27:36,010
future of some type some type T t1 and

00:27:32,890 --> 00:27:39,550
you have a function that takes a t1 and

00:27:36,010 --> 00:27:43,090
returns d2 okay then you call transform

00:27:39,550 --> 00:27:47,650
on a cue future of t1 it will return a

00:27:43,090 --> 00:27:51,400
queue of your chav t2 okay but if that

00:27:47,650 --> 00:27:54,010
function actually doesn't take a t1 and

00:27:51,400 --> 00:27:58,120
returns the t2 but takes a t1 and

00:27:54,010 --> 00:28:00,910
returns the queue futurity to transform

00:27:58,120 --> 00:28:05,760
would transform from the queue view 31

00:28:00,910 --> 00:28:09,250
to a queue puter queue of your 32 okay

00:28:05,760 --> 00:28:13,120
it's a little bit thick but bear with me

00:28:09,250 --> 00:28:15,400
and cue futures or futures are real

00:28:13,120 --> 00:28:18,820
useless so there is a method called

00:28:15,400 --> 00:28:20,800
flatten which would get an array of

00:28:18,820 --> 00:28:23,800
nested futures and judge give your

00:28:20,800 --> 00:28:29,080
proper futurity instead of always

00:28:23,800 --> 00:28:32,290
chaining transform and flatten dapi just

00:28:29,080 --> 00:28:36,990
provides the ability this drone flight

00:28:32,290 --> 00:28:41,020
sir the ability to directly pipe through

00:28:36,990 --> 00:28:43,780
some q future returning function and it

00:28:41,020 --> 00:28:51,539
will automatically do the transform and

00:28:43,780 --> 00:29:01,259
the flattening ok no

00:28:51,539 --> 00:29:05,100
questions yeah that's why I said the

00:29:01,259 --> 00:29:12,960
magnetic bind and usually I do talk

00:29:05,100 --> 00:29:14,820
about on Ed's okay apparently she was

00:29:12,960 --> 00:29:16,710
that in the microwave I'm recognizing

00:29:14,820 --> 00:29:20,009
bullets all over the place okay so a

00:29:16,710 --> 00:29:22,789
member of the audience said that he was

00:29:20,009 --> 00:29:25,460
recognizing my lads and I said that yeah

00:29:22,789 --> 00:29:30,090
this is all Mahna Mahna Mahna debate

00:29:25,460 --> 00:29:33,239
essentially q future is general concept

00:29:30,090 --> 00:29:36,330
of futures is one of aspect one of the

00:29:33,239 --> 00:29:38,159
different types of Monet's button I

00:29:36,330 --> 00:29:42,419
didn't want to actually talk about when

00:29:38,159 --> 00:29:45,659
it's this time as well okay so the idea

00:29:42,419 --> 00:29:47,879
here is that you should be able to use

00:29:45,659 --> 00:29:50,399
the Q future and compose as many

00:29:47,879 --> 00:29:52,619
functions as you want to it until you

00:29:50,399 --> 00:29:55,710
get the result that you actually want to

00:29:52,619 --> 00:29:58,229
have and when that result arrives you

00:29:55,710 --> 00:30:01,049
just process it and pass it to to the

00:29:58,229 --> 00:30:04,769
handler unlike the normal cute signal

00:30:01,049 --> 00:30:07,590
slot stuff in signals and slots you have

00:30:04,769 --> 00:30:09,450
a signal and you connected directly to a

00:30:07,590 --> 00:30:12,179
function that will process the result

00:30:09,450 --> 00:30:15,239
here you can chain as many things as you

00:30:12,179 --> 00:30:22,470
want before actually connecting to to

00:30:15,239 --> 00:30:24,659
the handler okay and the usual things

00:30:22,470 --> 00:30:27,210
that you should always have in all

00:30:24,659 --> 00:30:30,179
libraries like these if you have a

00:30:27,210 --> 00:30:33,149
collection of multiple futures it would

00:30:30,179 --> 00:30:35,549
be nice that you have the API that will

00:30:33,149 --> 00:30:41,070
return you a future of the collection

00:30:35,549 --> 00:30:44,479
and others I think this view should be

00:30:41,070 --> 00:30:47,700
quite quite obvious but they're doing

00:30:44,479 --> 00:30:51,499
okay so this was really fast i thought

00:30:47,700 --> 00:30:54,570
today i'll have half an hour format work

00:30:51,499 --> 00:30:56,909
now what are the limitations even with

00:30:54,570 --> 00:30:59,639
this idea that you can compose futures

00:30:56,909 --> 00:31:03,179
as much as you want the limitations are

00:30:59,639 --> 00:31:04,960
that although the future of t is a

00:31:03,179 --> 00:31:08,880
future of list of tea

00:31:04,960 --> 00:31:11,980
you can't really use it in a normal

00:31:08,880 --> 00:31:14,710
reactive stream kind of stuff for

00:31:11,980 --> 00:31:18,820
example one of the useful things we have

00:31:14,710 --> 00:31:22,390
then is to map all the user input as a

00:31:18,820 --> 00:31:25,809
stream of events right so you have every

00:31:22,390 --> 00:31:27,610
time that the user moves the mouse you

00:31:25,809 --> 00:31:29,409
want to have a stream that returns your

00:31:27,610 --> 00:31:33,520
coordinate coordinate coordinate

00:31:29,409 --> 00:31:35,350
coordinate ok and for the first

00:31:33,520 --> 00:31:38,080
coordinate you can use the cue future

00:31:35,350 --> 00:31:40,899
because the first time the user moves

00:31:38,080 --> 00:31:43,330
the mouse you'll get the value for the

00:31:40,899 --> 00:31:45,960
future that you created the problem is

00:31:43,330 --> 00:31:50,590
that you cannot model the whole stream

00:31:45,960 --> 00:31:53,770
with Q futures why is that because your

00:31:50,590 --> 00:31:56,350
future keeps everything in memory every

00:31:53,770 --> 00:31:59,409
single value that you have in the list

00:31:56,350 --> 00:32:02,020
will always be in that future so it's

00:31:59,409 --> 00:32:05,740
completely unlike for example standard

00:32:02,020 --> 00:32:08,320
input streams just imagine if the

00:32:05,740 --> 00:32:10,899
standard input stream remembered all the

00:32:08,320 --> 00:32:13,750
lines that you read before the line that

00:32:10,899 --> 00:32:17,230
you currently reading which will be

00:32:13,750 --> 00:32:19,360
completely useless right the Q future

00:32:17,230 --> 00:32:23,260
unfortunately doesn't have the ability

00:32:19,360 --> 00:32:26,490
to forget some of the previous values so

00:32:23,260 --> 00:32:30,220
you can't model a lot of advanced stuff

00:32:26,490 --> 00:32:33,130
with you to purchase you can essentially

00:32:30,220 --> 00:32:37,179
model just the simplest ones like I have

00:32:33,130 --> 00:32:44,260
a single value or a couple of them okay

00:32:37,179 --> 00:32:49,240
indeed I I don't think that anything

00:32:44,260 --> 00:32:55,870
else is worth mentioning so now

00:32:49,240 --> 00:33:00,159
questions I get before the questions one

00:32:55,870 --> 00:33:02,649
thing that they didn't talk about is how

00:33:00,159 --> 00:33:05,529
would you design your software so that

00:33:02,649 --> 00:33:07,870
you do these transformations filtering

00:33:05,529 --> 00:33:10,809
and everything else and to design huge

00:33:07,870 --> 00:33:13,270
programs with it I didn't talk about it

00:33:10,809 --> 00:33:16,779
mainly because I talked about it the PD

00:33:13,270 --> 00:33:18,580
in the previous year and because you

00:33:16,779 --> 00:33:20,890
can't use Q futures for that

00:33:18,580 --> 00:33:23,279
one of the great ideas of functional

00:33:20,890 --> 00:33:25,870
programming is that you have some input

00:33:23,279 --> 00:33:27,909
you transform it to transform it to do

00:33:25,870 --> 00:33:30,390
whatever you want with it and then you

00:33:27,909 --> 00:33:33,429
hear the values that you want to use and

00:33:30,390 --> 00:33:35,460
that's something that I was hoping I'll

00:33:33,429 --> 00:33:37,950
be able to do with Q futures

00:33:35,460 --> 00:33:41,080
unfortunately because of the simple

00:33:37,950 --> 00:33:43,350
limitation that for example this thing

00:33:41,080 --> 00:33:45,789
with the memory you can do a little

00:33:43,350 --> 00:33:51,279
really really rudimentary stuff with

00:33:45,789 --> 00:33:56,230
acute future but the idea of sharing

00:33:51,279 --> 00:33:58,149
something like a cue future that you can

00:33:56,230 --> 00:34:00,100
pipe the transformation that you can

00:33:58,149 --> 00:34:02,409
change that you can do whatever you want

00:34:00,100 --> 00:34:05,409
that is a really really powerful and

00:34:02,409 --> 00:34:11,879
useful thing unfortunately q future will

00:34:05,409 --> 00:34:11,879
not help you with it and our questions

00:34:25,460 --> 00:34:32,119
actually why you waste it on to future

00:34:28,639 --> 00:34:39,950
not on the next standard future I don't

00:34:32,119 --> 00:34:42,909
see 70 the reason why is that I had I I

00:34:39,950 --> 00:34:47,060
maintain one of the pen works in KD and

00:34:42,909 --> 00:34:50,240
it is really the bus Harry and the first

00:34:47,060 --> 00:34:51,770
version was synchronous and it blocked

00:34:50,240 --> 00:34:55,070
everywhere because the bus is freaking

00:34:51,770 --> 00:34:57,500
slow and I decided okay I need something

00:34:55,070 --> 00:35:00,650
like a cue future should i create my own

00:34:57,500 --> 00:35:02,450
which will be a bi-stable probably not

00:35:00,650 --> 00:35:06,020
because that framework is not for

00:35:02,450 --> 00:35:09,040
creating a futures then I considered STD

00:35:06,020 --> 00:35:12,500
future unfortunately it's not ready and

00:35:09,040 --> 00:35:15,710
unfortunately KD frameworks are steel

00:35:12,500 --> 00:35:17,800
pre c++ c 11 we need to remain

00:35:15,710 --> 00:35:20,030
compatible and everything else and

00:35:17,800 --> 00:35:24,670
suggest any future doesn't really

00:35:20,030 --> 00:35:28,000
guarantee ABI at least the GCC's

00:35:24,670 --> 00:35:30,770
implementations sometimes break ABI from

00:35:28,000 --> 00:35:33,410
major versions and stuff like that and

00:35:30,770 --> 00:35:36,470
the reason is that i use q future

00:35:33,410 --> 00:35:38,540
because it was in cute i was able to

00:35:36,470 --> 00:35:41,060
hack through it to it to actually

00:35:38,540 --> 00:35:43,130
achieve what i wanted to without much

00:35:41,060 --> 00:35:51,109
overhead like spinning or threads on s3

00:35:43,130 --> 00:35:53,320
and keeping the ABA but yes i would have

00:35:51,109 --> 00:35:57,589
probably gone for the facebooks one

00:35:53,320 --> 00:36:01,390
first then boost and then in the future

00:35:57,589 --> 00:36:01,390
I would choose the sed future

00:36:09,099 --> 00:36:17,680
I'm sorry to each routes supported and

00:36:12,650 --> 00:36:24,980
sorry our solid future supported sorry

00:36:17,680 --> 00:36:28,900
so honestly I hate anything that that

00:36:24,980 --> 00:36:33,619
has the shared name inside essentially

00:36:28,900 --> 00:36:37,190
okay not in the real world I'm after all

00:36:33,619 --> 00:36:39,640
a free software guy right but any time

00:36:37,190 --> 00:36:42,950
that you have a concurrent stuff

00:36:39,640 --> 00:36:45,290
anything that is shared is bad so you

00:36:42,950 --> 00:36:47,510
should either not share and keep things

00:36:45,290 --> 00:36:52,190
for yourself or you should not have

00:36:47,510 --> 00:36:54,770
concurrence anytime you try to mix those

00:36:52,190 --> 00:36:56,690
you need to work you need new Texas you

00:36:54,770 --> 00:37:00,320
need all of the things that you just

00:36:56,690 --> 00:37:02,390
slow your new software down and you

00:37:00,320 --> 00:37:06,760
should all if possible you should always

00:37:02,390 --> 00:37:06,760
avoid it in your design software design

00:37:07,240 --> 00:37:10,240
next

00:37:13,240 --> 00:37:16,270
just a quick one could you do me a

00:37:15,010 --> 00:37:19,950
little favor and just show the

00:37:16,270 --> 00:37:19,950
presentation place if possible

00:37:26,990 --> 00:37:31,610
how much but what I want to say it's

00:37:29,210 --> 00:37:40,570
share the presentation the file I'm

00:37:31,610 --> 00:37:48,050
sorry I think Lucky's sorry I heard you

00:37:40,570 --> 00:37:55,100
could you show ok ok ok there was a

00:37:48,050 --> 00:37:58,670
question in the back yeah although i

00:37:55,100 --> 00:38:02,150
would recommend not leave a looking at

00:37:58,670 --> 00:38:08,180
this one in the past year i was talking

00:38:02,150 --> 00:38:10,070
about reactive cute and this year at

00:38:08,180 --> 00:38:12,410
meeting c++ that will be talking a

00:38:10,070 --> 00:38:15,380
little bit continuing on the reactive

00:38:12,410 --> 00:38:17,560
stuff and usually i talk about these

00:38:15,380 --> 00:38:23,330
things but in a more useful way than

00:38:17,560 --> 00:38:26,360
just talking how bad cure trades but i

00:38:23,330 --> 00:38:29,900
will post it i have a question regarding

00:38:26,360 --> 00:38:32,480
this get and how you hate it so much

00:38:29,900 --> 00:38:35,270
because i think get gives you

00:38:32,480 --> 00:38:40,340
synchronization and that's sometimes

00:38:35,270 --> 00:38:44,710
good think I guess synchronization is

00:38:40,340 --> 00:38:49,790
sometimes necessary I wouldn't say it is

00:38:44,710 --> 00:38:52,880
it is good at any point there is one of

00:38:49,790 --> 00:38:56,330
one really nice comment about about new

00:38:52,880 --> 00:38:59,330
texts in general by David Buddhahood he

00:38:56,330 --> 00:39:01,970
said that in one of the mailing lists he

00:38:59,330 --> 00:39:05,390
said that we shouldn't have called the

00:39:01,970 --> 00:39:07,340
mutex mutex because it's a cute name and

00:39:05,390 --> 00:39:10,250
everybody likes it we should have called

00:39:07,340 --> 00:39:13,640
it the bottleneck so bottlenecks are

00:39:10,250 --> 00:39:15,380
sometimes necessary they're useful but

00:39:13,640 --> 00:39:17,960
you should never put them in your code

00:39:15,380 --> 00:39:21,080
if you don't actually need to if you

00:39:17,960 --> 00:39:25,130
design your software in a proper way you

00:39:21,080 --> 00:39:28,690
should never be you should never need to

00:39:25,130 --> 00:39:32,570
do exit synchronization on a top level

00:39:28,690 --> 00:39:35,540
in the libraries ok did build to

00:39:32,570 --> 00:39:37,220
something but I would say that most of

00:39:35,540 --> 00:39:39,560
the time unless you're doing parallel

00:39:37,220 --> 00:39:41,050
processing graphics and stuff like that

00:39:39,560 --> 00:39:46,660
which is the fork

00:39:41,050 --> 00:39:52,180
pattern what is made for I would say dot

00:39:46,660 --> 00:39:54,760
get should be destroyed essentially if

00:39:52,180 --> 00:39:57,670
you want to hear your system as

00:39:54,760 --> 00:40:01,000
synchronous and as soon as you call that

00:39:57,670 --> 00:40:03,040
get it's not and that destroys the idea

00:40:01,000 --> 00:40:06,790
of hearing the asynchronous system in

00:40:03,040 --> 00:40:09,630
the first place so useful yes sometimes

00:40:06,790 --> 00:40:09,630
good never

00:40:17,640 --> 00:40:23,890
it should work in a reason in a

00:40:20,410 --> 00:40:25,960
reasonable predictable way for me the

00:40:23,890 --> 00:40:29,980
reasonable way for that get is to crash

00:40:25,960 --> 00:40:32,650
for example you have a pointer that is

00:40:29,980 --> 00:40:35,980
invalid when you try to dereference it

00:40:32,650 --> 00:40:39,010
what does it do it's a segfault then you

00:40:35,980 --> 00:40:42,070
try to dereference a future it's not yet

00:40:39,010 --> 00:40:44,260
here it should be a sec bold I'm not

00:40:42,070 --> 00:40:46,720
saying that this is the only that this

00:40:44,260 --> 00:40:49,660
is the only way to think about it but

00:40:46,720 --> 00:40:51,760
it's it is as valid or more valid then

00:40:49,660 --> 00:40:57,130
let's block our program until the

00:40:51,760 --> 00:40:59,800
pointer gets valid in this way yes but

00:40:57,130 --> 00:41:02,830
if we treat and get us a synchronization

00:40:59,800 --> 00:41:06,640
point then it's different i do agree I

00:41:02,830 --> 00:41:12,130
do agree but as I said I don't want to

00:41:06,640 --> 00:41:15,760
treat it as a synchronization break the

00:41:12,130 --> 00:41:17,710
last question but even if you don't use

00:41:15,760 --> 00:41:20,770
the synchronization point gives you

00:41:17,710 --> 00:41:23,140
access to the exception how would you

00:41:20,770 --> 00:41:26,140
handle the exception in another way if

00:41:23,140 --> 00:41:29,410
you only pass the value to the receiving

00:41:26,140 --> 00:41:32,680
function to the handler function you you

00:41:29,410 --> 00:41:34,840
wouldn't in this way so for example then

00:41:32,680 --> 00:41:38,380
you hear a queue future and you do a

00:41:34,840 --> 00:41:41,380
transform something if it's a value it

00:41:38,380 --> 00:41:43,180
will get transformed if it's an error it

00:41:41,380 --> 00:41:47,250
will produce a cute future that returns

00:41:43,180 --> 00:41:51,070
an error so that's one of the things

00:41:47,250 --> 00:41:54,580
again didn't want to mention walnuts but

00:41:51,070 --> 00:41:57,400
the idea is you have a box if you have a

00:41:54,580 --> 00:42:00,070
value do whatever you want with it if

00:41:57,400 --> 00:42:03,160
you don't hear a value the new box will

00:42:00,070 --> 00:42:05,710
inherit all the backlog from this letter

00:42:03,160 --> 00:42:10,270
from this box so whether it's an error

00:42:05,710 --> 00:42:13,090
whether it's an O log how that fairly

00:42:10,270 --> 00:42:15,910
was produced or anything else so you

00:42:13,090 --> 00:42:20,380
would handle the errors in that way

00:42:15,910 --> 00:42:27,780
thank you thank you thank you for this

00:42:20,380 --> 00:42:30,560
talk some sense to even we will have

00:42:27,780 --> 00:42:33,130
sunny right what you don't

00:42:30,560 --> 00:42:37,730
to try to pronounce my surname oh I

00:42:33,130 --> 00:42:40,010
avoided we have 15 minutes pass and

00:42:37,730 --> 00:42:44,140
afterwards this is going to be the talk

00:42:40,010 --> 00:42:47,350
from last in this room so come back

00:42:44,140 --> 00:42:47,350
thank you

00:42:50,510 --> 00:42:52,570

YouTube URL: https://www.youtube.com/watch?v=rK7dCN1vnnw


