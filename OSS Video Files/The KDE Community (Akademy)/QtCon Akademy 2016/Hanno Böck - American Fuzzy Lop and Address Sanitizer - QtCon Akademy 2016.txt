Title: Hanno Böck - American Fuzzy Lop and Address Sanitizer - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	We have powerful and easy to use tools that can vastly improve the quality and security of the code we use everyday. The session will give an introduction to fuzzing, the tool american fuzzy lop and the compiler feature Address Sanitizer.

Hanno Böck
Captions: 
	00:00:04,640 --> 00:00:08,189
hello

00:00:05,910 --> 00:00:10,530
so asset I'm gonna work and I want to

00:00:08,189 --> 00:00:12,900
talk a bit today about how you can find

00:00:10,530 --> 00:00:16,500
packs in your software especially if

00:00:12,900 --> 00:00:19,230
it's written in C or C++ yeah and some

00:00:16,500 --> 00:00:22,830
very powerful tools that I think not

00:00:19,230 --> 00:00:25,410
enough people know about yet but first a

00:00:22,830 --> 00:00:27,779
quick introduction about me so I once

00:00:25,410 --> 00:00:31,439
worked as a freelance journalist and I

00:00:27,779 --> 00:00:36,180
often write for the drum online magazine

00:00:31,439 --> 00:00:40,980
gollum I also write a monthly TLS

00:00:36,180 --> 00:00:51,660
newsletter and and now you can see that

00:00:40,980 --> 00:00:53,460
I sorry these are the wrong slides I did

00:00:51,660 --> 00:00:59,280
almost the same talk a couple of days

00:00:53,460 --> 00:01:02,850
ago so yeah I write a monthly TLS

00:00:59,280 --> 00:01:07,530
newsletter and i run the fuzzing project

00:01:02,850 --> 00:01:09,659
which is something i founded like about

00:01:07,530 --> 00:01:11,700
two years ago and which is funded by the

00:01:09,659 --> 00:01:13,979
Linux Foundation score infrastructure

00:01:11,700 --> 00:01:15,509
initiative where I try to reduce the

00:01:13,979 --> 00:01:17,520
number of parks and security

00:01:15,509 --> 00:01:22,200
vulnerabilities in free and open source

00:01:17,520 --> 00:01:28,680
software so here's an example and it's

00:01:22,200 --> 00:01:31,290
from QT so there's a problem with this

00:01:28,680 --> 00:01:33,780
code and so what's actually happening

00:01:31,290 --> 00:01:36,390
here is we have some kind of array

00:01:33,780 --> 00:01:38,850
structure and we have an iterator

00:01:36,390 --> 00:01:43,380
pointing on it and there's a check here

00:01:38,850 --> 00:01:47,430
that if we're if we're at the last

00:01:43,380 --> 00:01:50,009
element of this array then it reduces

00:01:47,430 --> 00:01:53,100
the pointer by one and therefore like we

00:01:50,009 --> 00:01:56,549
are pointing to one element earlier now

00:01:53,100 --> 00:01:59,100
the problem here is if we have an area

00:01:56,549 --> 00:02:00,990
with only one element then we're trying

00:01:59,100 --> 00:02:03,270
to get to the previous element and then

00:02:00,990 --> 00:02:06,210
we're in invalid memory that's not

00:02:03,270 --> 00:02:08,250
allocated so what happens here is like

00:02:06,210 --> 00:02:08,759
the the code reads some invalid memory

00:02:08,250 --> 00:02:11,189
and

00:02:08,759 --> 00:02:13,439
something weird may happen this is a

00:02:11,189 --> 00:02:16,049
real buck in QT I have actually not

00:02:13,439 --> 00:02:17,879
reported it yet because I discovered it

00:02:16,049 --> 00:02:20,610
yesterday while I was on a ship without

00:02:17,879 --> 00:02:25,010
Wi-Fi so sorry I have not been able to

00:02:20,610 --> 00:02:30,390
report it yet but I will report you and

00:02:25,010 --> 00:02:33,720
I found plenty of packs in QT and KDE so

00:02:30,390 --> 00:02:36,030
I found a use after free back in queue

00:02:33,720 --> 00:02:38,519
make which is the build system tool from

00:02:36,030 --> 00:02:40,739
qt I found this bag I just showed you

00:02:38,519 --> 00:02:44,909
when I found several out of bounds for

00:02:40,739 --> 00:02:48,750
its of similar kind in QT e GUI and also

00:02:44,909 --> 00:02:50,819
in Kalyan for the last true I'm not

00:02:48,750 --> 00:02:53,670
entirely sure who I should blame because

00:02:50,819 --> 00:02:56,459
I mean the the code is using the X IPA

00:02:53,670 --> 00:02:58,920
in a wrong way but I think the X API is

00:02:56,459 --> 00:03:01,889
it's really strange how it behaves

00:02:58,920 --> 00:03:04,079
because you like it asks you to use a

00:03:01,889 --> 00:03:06,060
strap that's but then you need to

00:03:04,079 --> 00:03:07,739
allocate more memory for the struct than

00:03:06,060 --> 00:03:10,019
the size of the struct because it tries

00:03:07,739 --> 00:03:11,700
to read a certain size from it so I'm

00:03:10,019 --> 00:03:13,949
not entirely sure maybe there's a way to

00:03:11,700 --> 00:03:17,970
fix this in the xip I have to look into

00:03:13,949 --> 00:03:21,060
this and to be fair I also have to

00:03:17,970 --> 00:03:23,519
mention Chrome I found a bunch of very

00:03:21,060 --> 00:03:25,019
similar bugs in Nome for example two

00:03:23,519 --> 00:03:28,650
bucks in G lab which were out of bounds

00:03:25,019 --> 00:03:30,510
reads heap overflow in in chrome session

00:03:28,650 --> 00:03:33,510
which is triggered actually every time

00:03:30,510 --> 00:03:37,049
you start gnome and out of bounds read

00:03:33,510 --> 00:03:40,799
in pango here's this heap overflow in

00:03:37,049 --> 00:03:44,340
genome session so what what's happening

00:03:40,799 --> 00:03:47,250
here is that there's just an allocation

00:03:44,340 --> 00:03:49,949
for a buffer that contains a list of

00:03:47,250 --> 00:03:53,609
pointers and it contains all the

00:03:49,949 --> 00:03:57,000
pointers from arc V plus three more

00:03:53,609 --> 00:04:01,169
pointers so can you see the problem with

00:03:57,000 --> 00:04:03,900
this who sees the problem with this one

00:04:01,169 --> 00:04:07,169
person that's nice so the problem here

00:04:03,900 --> 00:04:10,500
is like we at arc c plus three and then

00:04:07,169 --> 00:04:12,449
times the size of the pointer but there

00:04:10,500 --> 00:04:14,790
are brackets missing around arc c plus

00:04:12,449 --> 00:04:16,950
three so what we're actually doing is

00:04:14,790 --> 00:04:20,130
doing three times the size of the

00:04:16,950 --> 00:04:22,280
pointer plus arc C instead of the other

00:04:20,130 --> 00:04:25,490
way around so a 10 we have

00:04:22,280 --> 00:04:28,670
a location that is too small and it's a

00:04:25,490 --> 00:04:30,680
very classic buffer overflow and like as

00:04:28,670 --> 00:04:35,810
I said this buffer overflow happens

00:04:30,680 --> 00:04:37,370
every time you start gnome so why are

00:04:35,810 --> 00:04:40,820
there all these bugs and why don't

00:04:37,370 --> 00:04:44,780
people seem to find them there's a tool

00:04:40,820 --> 00:04:47,240
that I want to suggest that you all

00:04:44,780 --> 00:04:49,669
should use if you write code which is

00:04:47,240 --> 00:04:52,730
called address sanitizer because all of

00:04:49,669 --> 00:04:55,220
the bugs I just showed you and mentioned

00:04:52,730 --> 00:04:58,580
can be trivially found with address

00:04:55,220 --> 00:05:02,660
sanitizer and this is a feature which is

00:04:58,580 --> 00:05:05,990
part of the GCC and LLVM compiler Suites

00:05:02,660 --> 00:05:07,430
so it's basically just a flag you add

00:05:05,990 --> 00:05:10,130
during compilations

00:05:07,430 --> 00:05:12,440
so you add F sanitized address to your

00:05:10,130 --> 00:05:15,290
compiler flags and then you get this

00:05:12,440 --> 00:05:20,660
feature that will analyze these kinds of

00:05:15,290 --> 00:05:23,360
bugs for you so this is how if you have

00:05:20,660 --> 00:05:25,970
a project that's written with Auto Tools

00:05:23,360 --> 00:05:30,169
this is how and if you have a test suite

00:05:25,970 --> 00:05:32,270
which some people have and then this is

00:05:30,169 --> 00:05:35,300
how you would run your test suite with

00:05:32,270 --> 00:05:38,300
address sanitizer enabled so it's

00:05:35,300 --> 00:05:41,210
basically you you pass some C flags to

00:05:38,300 --> 00:05:44,060
your configure flag to your configure

00:05:41,210 --> 00:05:47,180
script and some C++ flags and some

00:05:44,060 --> 00:05:49,400
linker flags and then you compile as you

00:05:47,180 --> 00:05:52,600
usually do and then you run your test

00:05:49,400 --> 00:05:56,330
suite so III think we can agree that

00:05:52,600 --> 00:05:59,000
this is not too hard like if you're

00:05:56,330 --> 00:06:02,900
developing code like typing in these

00:05:59,000 --> 00:06:05,240
free lines it shouldn't be too hard but

00:06:02,900 --> 00:06:07,220
apparently it seems like several people

00:06:05,240 --> 00:06:09,640
have never done this before there's a

00:06:07,220 --> 00:06:09,640
question

00:06:14,560 --> 00:06:22,650
I just wanted to say that in KDE

00:06:19,870 --> 00:06:25,780
our CI does use those flags so we

00:06:22,650 --> 00:06:28,150
sometimes find some of the mistakes okay

00:06:25,780 --> 00:06:31,660
so so the thing is that we're missing

00:06:28,150 --> 00:06:34,750
more tests so that hurt us that KDE is

00:06:31,660 --> 00:06:37,510
already doing this in the CI system but

00:06:34,750 --> 00:06:39,790
it's you probably never start KDE with

00:06:37,510 --> 00:06:41,290
these flags because as you would have

00:06:39,790 --> 00:06:43,780
found all the bugs I told you earlier

00:06:41,290 --> 00:06:48,360
about these were all fine found by just

00:06:43,780 --> 00:06:51,310
starting KDE with these flags so yeah

00:06:48,360 --> 00:06:54,400
but it's it's good if you do this that's

00:06:51,310 --> 00:06:59,740
great thanks genome doesn't do it so

00:06:54,400 --> 00:07:03,250
good so so how does it same thing work

00:06:59,740 --> 00:07:05,500
so what addressing it has a does is it

00:07:03,250 --> 00:07:08,470
reserves mount of a so-called shadow

00:07:05,500 --> 00:07:12,210
memory where tracks for each bite

00:07:08,470 --> 00:07:16,570
whether that's allocated memory or not

00:07:12,210 --> 00:07:19,060
so if you do a memory allocation it max

00:07:16,570 --> 00:07:22,300
this is valid or if you create a stack

00:07:19,060 --> 00:07:24,520
with a function call then and but it

00:07:22,300 --> 00:07:26,200
also makes sure that between the

00:07:24,520 --> 00:07:29,229
allocated space there's always some

00:07:26,200 --> 00:07:31,150
so-called poisoned space so if it

00:07:29,229 --> 00:07:33,130
changes the stack layout that between

00:07:31,150 --> 00:07:37,210
variables there's always some poison

00:07:33,130 --> 00:07:39,729
space so it can detect when you overrun

00:07:37,210 --> 00:07:43,150
a buffer no matter if on the stack or on

00:07:39,729 --> 00:07:45,039
the heap and the most common box you can

00:07:43,150 --> 00:07:47,680
find with this are out of bounds and use

00:07:45,039 --> 00:07:49,210
after free there are other kinds of bugs

00:07:47,680 --> 00:07:51,810
it finds but these are the most

00:07:49,210 --> 00:07:54,970
interesting because they are very common

00:07:51,810 --> 00:07:57,760
and also that use after free bugs are

00:07:54,970 --> 00:08:00,130
the most common security bugs in complex

00:07:57,760 --> 00:08:01,360
pieces of software today so especially

00:08:00,130 --> 00:08:04,120
if you have something like a browser

00:08:01,360 --> 00:08:08,770
then usually the memory corruption

00:08:04,120 --> 00:08:12,030
issues there will be used after free so

00:08:08,770 --> 00:08:14,380
this is an out-of-bounds read access

00:08:12,030 --> 00:08:17,440
relatively simple code so we have an

00:08:14,380 --> 00:08:20,020
array with two elements then we create

00:08:17,440 --> 00:08:22,240
an integer which we assign to and then

00:08:20,020 --> 00:08:24,330
we try to access element with the index

00:08:22,240 --> 00:08:27,210
to of that array

00:08:24,330 --> 00:08:29,370
and s eries started counting by zero to

00:08:27,210 --> 00:08:33,599
is invalid we only have an element zero

00:08:29,370 --> 00:08:37,289
and an element one so I have this code

00:08:33,599 --> 00:08:40,440
here and now if I compile this without

00:08:37,289 --> 00:08:44,640
anything special then I just see some

00:08:40,440 --> 00:08:47,010
garbage number printed out because okay

00:08:44,640 --> 00:08:49,200
it's reading some invalid memory and

00:08:47,010 --> 00:08:52,170
there's something in that invalid memory

00:08:49,200 --> 00:08:56,970
and it just prints that out okay now we

00:08:52,170 --> 00:08:58,829
add address sanitizer and we add G

00:08:56,970 --> 00:09:00,420
because then we have debugging

00:08:58,829 --> 00:09:02,490
information and that gives us a better

00:09:00,420 --> 00:09:06,300
stack trace that's just the reason for

00:09:02,490 --> 00:09:09,480
it and then we run this and then I have

00:09:06,300 --> 00:09:13,290
to unset this variable and then we run

00:09:09,480 --> 00:09:16,170
it again and then we get this very nice

00:09:13,290 --> 00:09:18,329
error message so it says read of size

00:09:16,170 --> 00:09:25,829
four because it's an integer it's four

00:09:18,329 --> 00:09:29,339
bytes in line five column 17 and it also

00:09:25,829 --> 00:09:31,470
here says that okay the address is

00:09:29,339 --> 00:09:33,600
located in the stack of the thread

00:09:31,470 --> 00:09:36,930
that's generated here which is our main

00:09:33,600 --> 00:09:37,890
function so so you run this code with

00:09:36,930 --> 00:09:40,740
address any Tizer

00:09:37,890 --> 00:09:42,420
you hit this back and you it the program

00:09:40,740 --> 00:09:45,360
terminates and you get a very very

00:09:42,420 --> 00:09:47,220
detailed error message so if you know

00:09:45,360 --> 00:09:49,019
your code you should be able by reading

00:09:47,220 --> 00:09:54,930
this error message to figure out what's

00:09:49,019 --> 00:09:57,630
wrong and this is a user of the free

00:09:54,930 --> 00:09:59,850
back a very simple example we're

00:09:57,630 --> 00:10:02,790
allocating some space with Thea log so

00:09:59,850 --> 00:10:04,680
it's initialized by zero then we print

00:10:02,790 --> 00:10:07,199
some element of this array and then we

00:10:04,680 --> 00:10:10,050
free that and then we try again to print

00:10:07,199 --> 00:10:12,899
something so that's now invalid because

00:10:10,050 --> 00:10:15,620
we just freed this buffer so we should

00:10:12,899 --> 00:10:21,930
not read from it anymore but we still do

00:10:15,620 --> 00:10:24,240
so I have this code here and the same if

00:10:21,930 --> 00:10:26,310
I run this with address sanitizer and

00:10:24,240 --> 00:10:28,320
for use after free the very nice thing

00:10:26,310 --> 00:10:31,290
is it tells me better you three

00:10:28,320 --> 00:10:34,620
important things the first is okay here

00:10:31,290 --> 00:10:37,050
is the use after free access then here

00:10:34,620 --> 00:10:40,140
is where this stuff got

00:10:37,050 --> 00:10:42,180
a located and here's where it got freed

00:10:40,140 --> 00:10:45,000
because like these are the three pieces

00:10:42,180 --> 00:10:49,200
of information you need to analyze this

00:10:45,000 --> 00:10:50,610
to analyze use after free back so yeah

00:10:49,200 --> 00:10:52,649
also very nice of course these are

00:10:50,610 --> 00:10:54,360
extremely simplified examples you will

00:10:52,649 --> 00:10:57,060
have much more complex examples in your

00:10:54,360 --> 00:10:58,910
code but that's the basic ideas always

00:10:57,060 --> 00:11:03,240
the same what they use after three years

00:10:58,910 --> 00:11:04,829
so I kind of got this I saw okay there

00:11:03,240 --> 00:11:06,600
are these many bucks you can find with

00:11:04,829 --> 00:11:09,060
address sanitizer and I made it kind of

00:11:06,600 --> 00:11:11,190
my mission to like test everything with

00:11:09,060 --> 00:11:15,510
address sanitizer and fix all these bugs

00:11:11,190 --> 00:11:17,459
so what I did was actually I started

00:11:15,510 --> 00:11:20,339
building a Linux system with a dress on

00:11:17,459 --> 00:11:22,709
you Taizo like with everything except a

00:11:20,339 --> 00:11:24,480
very few co-op packages where it's more

00:11:22,709 --> 00:11:29,130
difficult build with the dress on it

00:11:24,480 --> 00:11:31,399
either and it runs I can run it in a VM

00:11:29,130 --> 00:11:36,089
or I even have a server where it runs

00:11:31,399 --> 00:11:38,370
and just by doing that just by trying to

00:11:36,089 --> 00:11:40,470
create a Linux system with a dress on a

00:11:38,370 --> 00:11:44,160
tazer enabled I found packs in things

00:11:40,470 --> 00:11:46,950
like bash core utils man pitch in OTR

00:11:44,160 --> 00:11:50,120
patron OTR is kind of security sensitive

00:11:46,950 --> 00:11:54,360
I don't know maybe this is important

00:11:50,120 --> 00:11:59,430
yeah and also a cutie in KDE so we're at

00:11:54,360 --> 00:12:01,950
cutie con here and many other things so

00:11:59,430 --> 00:12:03,870
basically just by compiling stuff with

00:12:01,950 --> 00:12:11,190
address sanitizer and then trying to use

00:12:03,870 --> 00:12:13,680
it yeah yeah one more thing when I did

00:12:11,190 --> 00:12:15,779
this I thought this may be something I

00:12:13,680 --> 00:12:17,790
would recommend as a kind of special

00:12:15,779 --> 00:12:20,970
hardened system for very security

00:12:17,790 --> 00:12:22,829
sensitive things but it turns out this

00:12:20,970 --> 00:12:24,810
is not a good idea because address

00:12:22,829 --> 00:12:27,209
sanitizer is not designed to be a

00:12:24,810 --> 00:12:30,149
security tool it's designed as a testing

00:12:27,209 --> 00:12:32,279
tool and if you do this you end up

00:12:30,149 --> 00:12:34,769
having security vulnerabilities

00:12:32,279 --> 00:12:36,570
introduced by addressing tiser for

00:12:34,769 --> 00:12:37,949
example if you have suet binaries with

00:12:36,570 --> 00:12:40,980
addressing utilizer you can basically

00:12:37,949 --> 00:12:42,990
use the the error message functionality

00:12:40,980 --> 00:12:44,519
and let it dump files with root

00:12:42,990 --> 00:12:47,130
permissions and then you can get root

00:12:44,519 --> 00:12:50,840
with that so it's a good thing to find

00:12:47,130 --> 00:12:53,150
bugs great to test things but it's

00:12:50,840 --> 00:12:54,740
not good for production use at least not

00:12:53,150 --> 00:12:57,380
in the way it's implemented right now

00:12:54,740 --> 00:13:00,140
maybe there can be some future address

00:12:57,380 --> 00:13:02,000
sanitizer class plus that's usable for

00:13:00,140 --> 00:13:04,520
production but not the current version

00:13:02,000 --> 00:13:08,270
it's testing tool and like the overhead

00:13:04,520 --> 00:13:10,340
is you have like 50% CPU overhead and

00:13:08,270 --> 00:13:12,050
but and quite some memory overhead

00:13:10,340 --> 00:13:17,030
because this shadow memory takes quite

00:13:12,050 --> 00:13:19,580
some space so yeah and now I want to get

00:13:17,030 --> 00:13:22,970
into the next topic which is fuzzing so

00:13:19,580 --> 00:13:26,360
fuzzing the idea is very simple it is

00:13:22,970 --> 00:13:28,040
you you take some invalid input and test

00:13:26,360 --> 00:13:30,560
the software with it so the various

00:13:28,040 --> 00:13:33,110
torching a thing I'd like to phrase this

00:13:30,560 --> 00:13:37,040
is you throw garbage at software and see

00:13:33,110 --> 00:13:39,050
what happens so in practice if we take a

00:13:37,040 --> 00:13:41,690
simple example like we have an image

00:13:39,050 --> 00:13:44,060
parser and we want to test it then we

00:13:41,690 --> 00:13:46,730
take a valid image like a JPEG or PNG

00:13:44,060 --> 00:13:49,340
and then we just add random arrows to it

00:13:46,730 --> 00:13:51,850
like we just add in some characters

00:13:49,340 --> 00:13:56,150
flips and bits delete something whatever

00:13:51,850 --> 00:13:58,820
swap parts of it around and then we test

00:13:56,150 --> 00:14:04,190
if that crashes the code we're trying to

00:13:58,820 --> 00:14:08,030
test and who of you has heard of the

00:14:04,190 --> 00:14:11,750
DARPA cyber Grand Challenge recently so

00:14:08,030 --> 00:14:14,780
quite a few so here a bunch of press

00:14:11,750 --> 00:14:17,540
articles about it so watch DARPA watch

00:14:14,780 --> 00:14:19,970
AI hack into a a at DARPA cyber Grand

00:14:17,540 --> 00:14:22,700
Challenge hey hackers will make the

00:14:19,970 --> 00:14:25,280
world a safer place and also even

00:14:22,700 --> 00:14:26,480
Marxist DARPA a is hacking challenge

00:14:25,280 --> 00:14:29,660
will lead to Skynet

00:14:26,480 --> 00:14:32,990
so the general theme of this article was

00:14:29,660 --> 00:14:37,910
ok there are now some some AI bots in

00:14:32,990 --> 00:14:39,890
computers in some shiny glowing boxes

00:14:37,910 --> 00:14:42,380
like on the lower left that's a picture

00:14:39,890 --> 00:14:44,870
from Def Con where these boxes were like

00:14:42,380 --> 00:14:47,330
on the stage and and they are hacking

00:14:44,870 --> 00:14:49,010
each other and automatically finding

00:14:47,330 --> 00:14:51,920
vulnerabilities patching them and

00:14:49,010 --> 00:14:54,950
exploiting them and then by that they

00:14:51,920 --> 00:14:57,860
are basically trying to replace security

00:14:54,950 --> 00:15:00,410
professionals with AI bots so they want

00:14:57,860 --> 00:15:02,900
to replace people like me with an AI

00:15:00,410 --> 00:15:03,940
bots and then these AI bots at some

00:15:02,900 --> 00:15:06,250
point of course

00:15:03,940 --> 00:15:08,440
we'll create some Skynet and suppress

00:15:06,250 --> 00:15:13,390
humanity and we will have some matrix

00:15:08,440 --> 00:15:15,820
kind scenario so if someone wants to

00:15:13,390 --> 00:15:16,570
replace me with an AI what I mean I'm

00:15:15,820 --> 00:15:19,030
cool with that

00:15:16,570 --> 00:15:21,190
that that's totally fine I will find

00:15:19,030 --> 00:15:23,010
something else to do but I would like to

00:15:21,190 --> 00:15:25,240
understand what's going on here right so

00:15:23,010 --> 00:15:26,560
I'd really like to understand this and

00:15:25,240 --> 00:15:28,570
all these articles were like very

00:15:26,560 --> 00:15:32,010
shallow I didn't get any technical

00:15:28,570 --> 00:15:37,420
details of what's going on here and

00:15:32,010 --> 00:15:39,070
here's a our video I have I not show the

00:15:37,420 --> 00:15:42,130
whole video but like some parts of it

00:15:39,070 --> 00:15:45,940
there you can see the the fancy colorful

00:15:42,130 --> 00:15:47,770
ready things in the DEF CON stage game

00:15:45,940 --> 00:15:50,290
started at Oh nine hundred and

00:15:47,770 --> 00:15:52,210
forty-five seconds Pacific welcome

00:15:50,290 --> 00:15:54,880
everyone to the first ever fully

00:15:52,210 --> 00:15:57,190
automated cyber security automated

00:15:54,880 --> 00:15:59,350
competition Sandra managed to discover

00:15:57,190 --> 00:16:01,270
and prove a vulnerability in one of the

00:15:59,350 --> 00:16:02,800
services that we call ops him but this

00:16:01,270 --> 00:16:04,720
is a unique situation and it's something

00:16:02,800 --> 00:16:06,160
we were kind of hoping to see they

00:16:04,720 --> 00:16:08,800
actually managed to discover an

00:16:06,160 --> 00:16:10,270
unintended vulnerability so each of

00:16:08,800 --> 00:16:11,950
these each of these services that's

00:16:10,270 --> 00:16:13,570
written just like real-world software

00:16:11,950 --> 00:16:15,070
it's impossible for us to have made

00:16:13,570 --> 00:16:16,840
absolutely certain that the one

00:16:15,070 --> 00:16:19,210
vulnerability that we intended is the

00:16:16,840 --> 00:16:21,700
only one that's present so the discover

00:16:19,210 --> 00:16:28,420
this vulnerability and actually believe

00:16:21,700 --> 00:16:30,460
that vulnerability again stress to have

00:16:28,420 --> 00:16:31,900
to what we have going on here because in

00:16:30,460 --> 00:16:33,490
that five minute window that Deb

00:16:31,900 --> 00:16:35,830
mentioned that she was hoping for that

00:16:33,490 --> 00:16:38,680
actually managed and proven and patched

00:16:35,830 --> 00:16:41,680
by several of basically represents but a

00:16:38,680 --> 00:16:43,120
leap forward in program and I mean all

00:16:41,680 --> 00:16:44,380
the talk about state machines and all

00:16:43,120 --> 00:16:45,580
the possibility in state machine really

00:16:44,380 --> 00:16:47,440
reminds me of one of the papers that we

00:16:45,580 --> 00:16:49,110
published recently we published paper

00:16:47,440 --> 00:16:53,230
driller which is supposed to augment

00:16:49,110 --> 00:16:56,680
fuzzing with symbolic execution and did

00:16:53,230 --> 00:16:58,360
you hear he said fuzzing so okay at this

00:16:56,680 --> 00:17:01,930
point I thought okay this is something I

00:16:58,360 --> 00:17:04,810
know something about so yeah okay so

00:17:01,930 --> 00:17:06,730
maybe yeah because you know if people

00:17:04,810 --> 00:17:09,190
talk about artificial intelligence these

00:17:06,730 --> 00:17:11,740
days I don't know how you feel but I get

00:17:09,190 --> 00:17:13,570
extremely skeptical I think a lot of

00:17:11,740 --> 00:17:15,990
stuff is called artificial intelligence

00:17:13,570 --> 00:17:19,049
which isn't really anything about that

00:17:15,990 --> 00:17:23,189
and well okay so this seems to be about

00:17:19,049 --> 00:17:25,470
something about fuzzy and I I talked to

00:17:23,189 --> 00:17:27,630
the the leader of the winning team

00:17:25,470 --> 00:17:29,970
David Bromley and he told me okay they

00:17:27,630 --> 00:17:32,610
are using a tool called AFL American

00:17:29,970 --> 00:17:34,289
fuzzy blob and immediately this became

00:17:32,610 --> 00:17:37,020
something I'm very familiar with because

00:17:34,289 --> 00:17:39,149
I use it all the time and then I learned

00:17:37,020 --> 00:17:41,159
not only the winning team but basically

00:17:39,149 --> 00:17:44,070
most of the teams were using American

00:17:41,159 --> 00:17:45,510
fuzzy blob the first place the second

00:17:44,070 --> 00:17:47,580
place and the third place all were using

00:17:45,510 --> 00:17:57,419
American fuzzy blob so basically that's

00:17:47,580 --> 00:18:00,120
the real winner of this competition we

00:17:57,419 --> 00:18:04,230
can I heard the question was is ever I

00:18:00,120 --> 00:18:09,299
can finally love this AI I don't know I

00:18:04,230 --> 00:18:11,490
don't think a AFL is the skynet but it's

00:18:09,299 --> 00:18:16,679
pretty smart so maybe it's some kind of

00:18:11,490 --> 00:18:20,000
AI yeah so this rabbit is an American

00:18:16,679 --> 00:18:23,130
fazil op but it's also name of a tool

00:18:20,000 --> 00:18:25,590
and to understand what American fuzzy

00:18:23,130 --> 00:18:28,049
loved us I want to go a bit into like

00:18:25,590 --> 00:18:31,620
how what different strategies there

00:18:28,049 --> 00:18:34,289
exists for phrasing so the very original

00:18:31,620 --> 00:18:37,950
idea is what I would call dump fuzzing

00:18:34,289 --> 00:18:42,240
where you only add errors at random to

00:18:37,950 --> 00:18:42,659
an input and test it so that's easy it

00:18:42,240 --> 00:18:44,580
also

00:18:42,659 --> 00:18:46,679
I mean it's surprisingly effective

00:18:44,580 --> 00:18:49,500
already so you already can find a lot of

00:18:46,679 --> 00:18:51,659
quirks with it but it's not going very

00:18:49,500 --> 00:18:53,850
deep into your code so if you have some

00:18:51,659 --> 00:18:56,279
complex issues it won't find them and

00:18:53,850 --> 00:18:59,460
then you can do something which I call

00:18:56,279 --> 00:19:01,890
template based fuzzing where you to Sun

00:18:59,460 --> 00:19:04,590
where you write a father that's specific

00:19:01,890 --> 00:19:06,360
for a certain data structure so you

00:19:04,590 --> 00:19:08,340
could do something like you want to fast

00:19:06,360 --> 00:19:11,250
an image puzzle and then you try things

00:19:08,340 --> 00:19:13,080
like what happens if I put a 0 into the

00:19:11,250 --> 00:19:15,090
width because that doesn't make any

00:19:13,080 --> 00:19:17,669
sense so let's see if the powers are

00:19:15,090 --> 00:19:19,830
correctly handles that the problem with

00:19:17,669 --> 00:19:22,049
this is it's a lot of work because you

00:19:19,830 --> 00:19:24,600
have to do it for every data structure

00:19:22,049 --> 00:19:26,820
you're fuzzing and therefore I say it

00:19:24,600 --> 00:19:28,420
doesn't scale if I want to fast all the

00:19:26,820 --> 00:19:31,750
software out there

00:19:28,420 --> 00:19:33,880
I will never be finished and this new

00:19:31,750 --> 00:19:36,190
thing that came up with AFL is what's

00:19:33,880 --> 00:19:39,250
called coverage based fuzzing and what

00:19:36,190 --> 00:19:42,040
this is doing is that it you're adding

00:19:39,250 --> 00:19:45,550
some extra assembly instructions during

00:19:42,040 --> 00:19:47,410
the compile step and these allow the

00:19:45,550 --> 00:19:51,310
father to learn something about your

00:19:47,410 --> 00:19:53,590
code paths and when you have an input to

00:19:51,310 --> 00:19:56,170
the to the tool that general that

00:19:53,590 --> 00:19:57,850
triggers a new code path then the father

00:19:56,170 --> 00:20:00,160
sees okay this is generating something

00:19:57,850 --> 00:20:02,320
interesting because now we trigger a new

00:20:00,160 --> 00:20:04,390
code and therefore we should continue

00:20:02,320 --> 00:20:06,520
fuzzing with this as a starting point

00:20:04,390 --> 00:20:09,340
and this leads to some pretty impressive

00:20:06,520 --> 00:20:12,160
results so there's a blog post by the by

00:20:09,340 --> 00:20:14,980
Mahadev ski the author of AFL where he

00:20:12,160 --> 00:20:18,040
started to face a JPG parser with

00:20:14,980 --> 00:20:22,930
garbage input and after some hours

00:20:18,040 --> 00:20:24,880
it created valid JPEG files so maybe

00:20:22,930 --> 00:20:31,570
that's already kind of Skynet thing I

00:20:24,880 --> 00:20:33,700
have it is pretty impressive so yeah so

00:20:31,570 --> 00:20:36,670
AFL made this idea of coverage wastes

00:20:33,700 --> 00:20:38,950
following possible and you're working

00:20:36,670 --> 00:20:42,040
two steps first you compile it with the

00:20:38,950 --> 00:20:44,560
AFL wrapper compiler thing and then you

00:20:42,040 --> 00:20:48,490
set the further so and to show you also

00:20:44,560 --> 00:20:51,460
that this is really easy yeah you run

00:20:48,490 --> 00:20:55,270
like the auto tool space but you one

00:20:51,460 --> 00:20:57,580
configure you pass CC and cxx so that

00:20:55,270 --> 00:21:00,130
you run it with this compiler wrapper

00:20:57,580 --> 00:21:02,740
then it's always a good idea to disable

00:21:00,130 --> 00:21:04,900
shared libraries because then you don't

00:21:02,740 --> 00:21:08,170
have to fiddle around with Eddy preload

00:21:04,900 --> 00:21:10,630
and anything then you build it and then

00:21:08,170 --> 00:21:13,030
you need some kind of sample file that

00:21:10,630 --> 00:21:15,130
you want to first put it into a

00:21:13,030 --> 00:21:18,220
directory which I always call in but

00:21:15,130 --> 00:21:20,230
it's just a arbitrary name and then you

00:21:18,220 --> 00:21:22,960
run this fuzzing process which where you

00:21:20,230 --> 00:21:24,640
put the input directory output directory

00:21:22,960 --> 00:21:27,160
and the path to the thing you want to

00:21:24,640 --> 00:21:28,540
first and then you add this edit and

00:21:27,160 --> 00:21:31,930
then the father will call this

00:21:28,540 --> 00:21:36,430
executable with and pass the file that's

00:21:31,930 --> 00:21:40,060
currently tested at this at position and

00:21:36,430 --> 00:21:41,520
this is how it looks so nice ASCII art

00:21:40,060 --> 00:21:44,190
interface

00:21:41,520 --> 00:21:45,990
the most interesting part is the upper

00:21:44,190 --> 00:21:48,870
right corner because they are chose use

00:21:45,990 --> 00:21:51,510
a number of unique crashes that's a bit

00:21:48,870 --> 00:21:54,570
of a lie because you will have the

00:21:51,510 --> 00:21:56,520
applicators there the detection of

00:21:54,570 --> 00:21:58,409
unique crashes doesn't really work but

00:21:56,520 --> 00:22:01,590
it tries to err on the side of caution

00:21:58,409 --> 00:22:03,990
so and it also detects like hangs if

00:22:01,590 --> 00:22:06,929
you're stuck in an endless loop or

00:22:03,990 --> 00:22:08,549
something and the number of paths it

00:22:06,929 --> 00:22:11,490
detected and that's also important

00:22:08,549 --> 00:22:14,100
because if that number doesn't change if

00:22:11,490 --> 00:22:15,630
it stays at 1 or 2 then probably

00:22:14,100 --> 00:22:21,539
something is wrong with your setup and

00:22:15,630 --> 00:22:23,909
you should check that and I'm trying to

00:22:21,539 --> 00:22:25,620
say al probably found bugs in every

00:22:23,909 --> 00:22:30,510
single important piece of software

00:22:25,620 --> 00:22:34,500
that's written in C so in open SSL up

00:22:30,510 --> 00:22:37,350
messes a JPEG or PNG SQLite new PG bash

00:22:34,500 --> 00:22:40,010
state right state Freud was the Android

00:22:37,350 --> 00:22:43,440
thing that made some headlines last year

00:22:40,010 --> 00:22:45,149
yeah so really a lot of parts found with

00:22:43,440 --> 00:22:46,710
AF l there's a list on the webpage

00:22:45,149 --> 00:22:49,620
that's quite impressive

00:22:46,710 --> 00:22:54,380
so it made a huge impact like on on bug

00:22:49,620 --> 00:22:54,380
finding in in the free software world

00:22:55,190 --> 00:23:00,840
and so I I now told you about AFL and

00:22:58,380 --> 00:23:02,909
address sanitizer and there's a very

00:23:00,840 --> 00:23:05,880
obvious thing to do and that is to use

00:23:02,909 --> 00:23:08,130
both at once because address sanitizer

00:23:05,880 --> 00:23:12,090
finds these additional classes of wax

00:23:08,130 --> 00:23:14,340
that are hard to find otherwise and AFL

00:23:12,090 --> 00:23:16,919
is a very good fuzzing tool so you can

00:23:14,340 --> 00:23:19,529
just use both at once what you have to

00:23:16,919 --> 00:23:21,480
do is the AFL already has a feature

00:23:19,529 --> 00:23:23,820
built in for that which you can enable

00:23:21,480 --> 00:23:27,809
with an environment variable if I'll use

00:23:23,820 --> 00:23:31,830
Aysen you then need to disable the

00:23:27,809 --> 00:23:33,539
memory limit from AFL because address

00:23:31,830 --> 00:23:36,179
sanitizer has this thing that it

00:23:33,539 --> 00:23:38,190
allocates the shadow memory and it is

00:23:36,179 --> 00:23:41,909
only a virtual allocation but it's

00:23:38,190 --> 00:23:44,159
several terabytes so it's only virtual

00:23:41,909 --> 00:23:47,250
memory so it doesn't really use that

00:23:44,159 --> 00:23:49,649
memory but if you put a memory limit on

00:23:47,250 --> 00:23:51,899
it it won't work therefore you just need

00:23:49,649 --> 00:23:54,230
to disable the memory limit this can of

00:23:51,899 --> 00:23:55,970
course cause the situation where you

00:23:54,230 --> 00:23:57,620
an application that uses a lot of memory

00:23:55,970 --> 00:24:00,770
and everything will crash

00:23:57,620 --> 00:24:03,710
but in my experience that that almost

00:24:00,770 --> 00:24:05,660
never happens but that's the reason why

00:24:03,710 --> 00:24:08,750
I fell has a memory limit in the first

00:24:05,660 --> 00:24:11,870
place so simple solution just disable

00:24:08,750 --> 00:24:15,970
the memory limit and you're done okay

00:24:11,870 --> 00:24:18,799
who remembers this logo I hope everyone

00:24:15,970 --> 00:24:21,440
this was the heart playback probably the

00:24:18,799 --> 00:24:28,970
most famous back in any piece of code

00:24:21,440 --> 00:24:31,580
ever made headlines everywhere so at

00:24:28,970 --> 00:24:33,679
some point I was asking myself ok could

00:24:31,580 --> 00:24:37,309
we have used fuzzing to find a bug like

00:24:33,679 --> 00:24:39,169
hot lead and I have to say here ok one

00:24:37,309 --> 00:24:41,179
of the people found heartbleed actually

00:24:39,169 --> 00:24:44,690
used a father but it's a proprietary

00:24:41,179 --> 00:24:46,610
tool that's specifically targeted to

00:24:44,690 --> 00:24:49,160
tear s so it's not kind of a generic

00:24:46,610 --> 00:24:51,320
father it is what I call templates based

00:24:49,160 --> 00:24:54,770
fuzzing and it's not free so I cannot

00:24:51,320 --> 00:24:56,630
test it so but I wanted to know like can

00:24:54,770 --> 00:24:58,840
I use the tools that I use for

00:24:56,630 --> 00:25:02,240
furthering to find a heartbeat back and

00:24:58,840 --> 00:25:05,059
ok one problem is that American fazil op

00:25:02,240 --> 00:25:09,140
is file based and this is kind of

00:25:05,059 --> 00:25:13,220
networking so but the open SSL API has a

00:25:09,140 --> 00:25:16,340
nice feature that I can basically do a

00:25:13,220 --> 00:25:19,160
TLS handshake without really doing a

00:25:16,340 --> 00:25:21,799
handshake I'm just passing buffers back

00:25:19,160 --> 00:25:25,330
and forth so I have two instances of

00:25:21,799 --> 00:25:28,549
open SSL and let them talk to each other

00:25:25,330 --> 00:25:31,820
but without any real networking involved

00:25:28,549 --> 00:25:34,190
and then I could write something that is

00:25:31,820 --> 00:25:36,140
just swapped one of these handshake

00:25:34,190 --> 00:25:40,160
messages with a file that I passed on

00:25:36,140 --> 00:25:42,410
the common time and doing this after six

00:25:40,160 --> 00:25:44,960
hours I was able to rediscover the

00:25:42,410 --> 00:25:47,510
heartbleed bug and then I got an email

00:25:44,960 --> 00:25:49,520
from Costas Eric Lonnie who is the

00:25:47,510 --> 00:25:51,890
developer of address sanitizer and a

00:25:49,520 --> 00:25:54,559
couple of other things and he said he

00:25:51,890 --> 00:25:56,360
has this tool called Lib father and it's

00:25:54,559 --> 00:26:00,850
able to do the same thing but in five

00:25:56,360 --> 00:26:05,450
minutes so that's also quite impressive

00:26:00,850 --> 00:26:07,430
and Lib father is it's modeled after AFL

00:26:05,450 --> 00:26:10,700
but it works a bit different

00:26:07,430 --> 00:26:14,030
so what AFL is working on executables

00:26:10,700 --> 00:26:16,550
Lib father is working on functions and

00:26:14,030 --> 00:26:18,320
that's much faster because it's faster

00:26:16,550 --> 00:26:22,400
to call a function than to run an

00:26:18,320 --> 00:26:24,710
executable but there's a downside to it

00:26:22,400 --> 00:26:29,420
and that is you have to write code to

00:26:24,710 --> 00:26:31,910
actually use this and because the big

00:26:29,420 --> 00:26:35,059
advantage of a FLSA is just so simple

00:26:31,910 --> 00:26:39,140
and with Lib father you need to write

00:26:35,059 --> 00:26:41,390
code this is an example from fuzzing an

00:26:39,140 --> 00:26:42,710
open SSL function with Lib Fraser's so

00:26:41,390 --> 00:26:46,220
we're basically writing a wrapper

00:26:42,710 --> 00:26:49,520
function here that gets a buffer passed

00:26:46,220 --> 00:26:52,250
and the size of the buffer and then I'm

00:26:49,520 --> 00:26:54,460
just calling this open SSL function

00:26:52,250 --> 00:27:00,380
which is called a is 1 and B string copy

00:26:54,460 --> 00:27:02,570
I pass this this buffer and then very

00:27:00,380 --> 00:27:04,880
important here is that I check if it's

00:27:02,570 --> 00:27:08,090
exceeded and if it succeeds then I free

00:27:04,880 --> 00:27:10,400
the structure it generated again because

00:27:08,090 --> 00:27:12,710
if I don't do this then I have a memory

00:27:10,400 --> 00:27:15,470
leak and as it's running this like

00:27:12,710 --> 00:27:17,780
millions of times the memory leak will

00:27:15,470 --> 00:27:19,730
add up and at some point I will run out

00:27:17,780 --> 00:27:22,400
of memory and my father crashes

00:27:19,730 --> 00:27:24,590
therefore if you you slip further keep

00:27:22,400 --> 00:27:32,210
in mind you have to write a wrapper

00:27:24,590 --> 00:27:35,510
that's free of memory leaks yeah then

00:27:32,210 --> 00:27:38,090
something what's also interesting method

00:27:35,510 --> 00:27:41,059
is what's called differential testing so

00:27:38,090 --> 00:27:43,370
the typical fuzzing scenario is to look

00:27:41,059 --> 00:27:46,820
for these kind of memory safety issues

00:27:43,370 --> 00:27:48,950
and crashes but you can also do other

00:27:46,820 --> 00:27:52,100
things and if you have a function that

00:27:48,950 --> 00:27:53,360
has a clearly defined output then what

00:27:52,100 --> 00:27:55,460
you can do is take two different

00:27:53,360 --> 00:28:00,559
implementations of the same thing and

00:27:55,460 --> 00:28:02,260
then compare the result and some area

00:28:00,559 --> 00:28:05,240
where this works really well is

00:28:02,260 --> 00:28:07,400
mathematics because if you have

00:28:05,240 --> 00:28:10,190
something like an exponentiation or a

00:28:07,400 --> 00:28:11,840
division or then we can agree that this

00:28:10,190 --> 00:28:14,420
has a clear result I mean there's no

00:28:11,840 --> 00:28:16,730
discussion like two times two is four

00:28:14,420 --> 00:28:21,180
and not something else

00:28:16,730 --> 00:28:23,970
so if two implementations disagree on

00:28:21,180 --> 00:28:25,140
some mathematical calculations then one

00:28:23,970 --> 00:28:28,530
of them must be wrong

00:28:25,140 --> 00:28:31,980
yeah at least one of them must be Runa

00:28:28,530 --> 00:28:33,750
yeah I didn't run into a situation where

00:28:31,980 --> 00:28:37,440
- were wrong in a different way at the

00:28:33,750 --> 00:28:40,530
same time but maybe this happens and

00:28:37,440 --> 00:28:42,090
there was a bug in of message L in a

00:28:40,530 --> 00:28:45,120
function called P n square which is

00:28:42,090 --> 00:28:49,560
squaring so you multiply a number by

00:28:45,120 --> 00:28:51,900
itself and in very rare cases this

00:28:49,560 --> 00:28:54,390
function would produce wrong results and

00:28:51,900 --> 00:28:57,840
these were so rare that it was in 1 out

00:28:54,390 --> 00:29:01,050
of 2 to the power of 128 and this number

00:28:57,840 --> 00:29:03,510
is so large that if you use this

00:29:01,050 --> 00:29:05,430
function with random input you can do

00:29:03,510 --> 00:29:07,800
this for your whole life and it will

00:29:05,430 --> 00:29:10,670
never hit this back so it's very rare

00:29:07,800 --> 00:29:13,680
back but the surprising thing was

00:29:10,670 --> 00:29:16,230
American fuzzy lab was able to find this

00:29:13,680 --> 00:29:18,270
bug so maybe this is another indication

00:29:16,230 --> 00:29:22,260
that just some Skynet thing going on I

00:29:18,270 --> 00:29:24,060
know the first person who showed this

00:29:22,260 --> 00:29:26,370
was arrived with a blind man he had a

00:29:24,060 --> 00:29:28,620
talk about big number abilities at

00:29:26,370 --> 00:29:30,270
blackhat last year it's on YouTube and I

00:29:28,620 --> 00:29:34,100
recommend watching it it's very

00:29:30,270 --> 00:29:36,150
interesting and then I tried this and

00:29:34,100 --> 00:29:38,790
AFL is really good at this

00:29:36,150 --> 00:29:41,310
so I found a bug in optimizes L in the

00:29:38,790 --> 00:29:43,560
modular exponentiation this is the

00:29:41,310 --> 00:29:46,380
function that's basically RS 8 and

00:29:43,560 --> 00:29:48,150
diffie-hellman so kind of important

00:29:46,380 --> 00:29:50,900
unfortunately nobody found a way to

00:29:48,150 --> 00:29:53,250
exploit this but it's still I think it's

00:29:50,900 --> 00:29:55,650
something where you should look into

00:29:53,250 --> 00:29:57,570
that it's correct then in the elliptic

00:29:55,650 --> 00:30:00,090
curve code from nettle which was used by

00:29:57,570 --> 00:30:04,260
new TLS also in the multiplex

00:30:00,090 --> 00:30:06,690
pronunciation of NSS in the poorest 1305

00:30:04,260 --> 00:30:10,350
Authenticator and open SSL this has no

00:30:06,690 --> 00:30:12,030
CVE because this was never released in I

00:30:10,350 --> 00:30:17,150
found the back before they released the

00:30:12,030 --> 00:30:19,680
code so yeah and in in matrix SSL which

00:30:17,150 --> 00:30:22,140
have the interesting property if you had

00:30:19,680 --> 00:30:25,350
a zero to the power of something it

00:30:22,140 --> 00:30:26,910
would crash and then I thought ok I can

00:30:25,350 --> 00:30:28,800
do this over the network I just sent

00:30:26,910 --> 00:30:30,900
them an RSA signature that's zero

00:30:28,800 --> 00:30:32,850
because then it will try to exponentiate

00:30:30,900 --> 00:30:36,000
it in crashing that worked so

00:30:32,850 --> 00:30:37,980
yeah and also like there were situations

00:30:36,000 --> 00:30:39,809
where just wrong result and they were

00:30:37,980 --> 00:30:43,080
not really they haven't really fixed all

00:30:39,809 --> 00:30:50,130
of that yeah I wouldn't recommend using

00:30:43,080 --> 00:30:52,350
matrix SSL yeah so one of the things I

00:30:50,130 --> 00:30:54,299
run into when I do these things is the

00:30:52,350 --> 00:30:55,920
vast majority of blacks I mean with

00:30:54,299 --> 00:30:58,440
these parks there's no discussion these

00:30:55,920 --> 00:31:00,540
are bugs and also usually people agree

00:30:58,440 --> 00:31:03,630
that this is a security vulnerability

00:31:00,540 --> 00:31:06,330
but if I found something like an invalid

00:31:03,630 --> 00:31:08,990
read access on the heap for one bite

00:31:06,330 --> 00:31:12,059
which happens extremely often then

00:31:08,990 --> 00:31:15,000
people tend to argue is this a is this a

00:31:12,059 --> 00:31:16,770
security vulnerability or not and and I

00:31:15,000 --> 00:31:19,799
find these discussions a bit pointless

00:31:16,770 --> 00:31:22,440
because I say okay it's clearly a back

00:31:19,799 --> 00:31:26,669
and the you're reading invalid memory

00:31:22,440 --> 00:31:28,620
you cannot do this so I say okay can we

00:31:26,669 --> 00:31:30,360
just like skip the discussion whether we

00:31:28,620 --> 00:31:32,760
call this a vulnerability or not I

00:31:30,360 --> 00:31:35,460
simply don't care I want you to fix this

00:31:32,760 --> 00:31:37,590
and we're done with it so I think in

00:31:35,460 --> 00:31:39,660
many situations it's just easier to fix

00:31:37,590 --> 00:31:46,860
the back then to have the discussion on

00:31:39,660 --> 00:31:49,860
how severe this is yeah then I want to

00:31:46,860 --> 00:31:52,440
mention a couple of more tools so this

00:31:49,860 --> 00:31:54,240
address sanitizers there are a couple of

00:31:52,440 --> 00:31:55,980
other sanitizer tools

00:31:54,240 --> 00:31:58,740
I just think address sanitizer is the

00:31:55,980 --> 00:32:02,400
most interesting this undefined behavior

00:31:58,740 --> 00:32:05,520
sanitizer which finds many small things

00:32:02,400 --> 00:32:07,799
that the C standard says are undefined

00:32:05,520 --> 00:32:10,830
and that essentially means if you do

00:32:07,799 --> 00:32:12,270
these you cannot have any expectation of

00:32:10,830 --> 00:32:14,460
your code that it does anything

00:32:12,270 --> 00:32:16,350
reasonable it can just do whatever it

00:32:14,460 --> 00:32:18,750
wants the compiler can optimize it in a

00:32:16,350 --> 00:32:20,480
way that if you do this you cannot

00:32:18,750 --> 00:32:24,049
expect it to do anything sensible

00:32:20,480 --> 00:32:26,669
there's memory sanitizer which finds a

00:32:24,049 --> 00:32:29,340
uninitialized memory problem with that

00:32:26,669 --> 00:32:31,380
is it's nice but it's tricky to use

00:32:29,340 --> 00:32:33,960
because you need to compile all the

00:32:31,380 --> 00:32:37,080
libraries you use with memory sanitizer

00:32:33,960 --> 00:32:40,110
and if you do C++ even the dip standard

00:32:37,080 --> 00:32:42,300
C++ so that's a bit of annoying to use

00:32:40,110 --> 00:32:45,620
and their threat sanitizer which is

00:32:42,300 --> 00:32:45,620
mostly just question

00:32:46,080 --> 00:32:49,470
same thing you just said is valid for

00:32:47,970 --> 00:32:51,840
address sanitizer as well so if you

00:32:49,470 --> 00:32:53,400
don't compile a lip C++ with AC and you

00:32:51,840 --> 00:32:56,460
won't be able to find bugs that are

00:32:53,400 --> 00:32:58,710
triggered within lip C++ by your code

00:32:56,460 --> 00:33:01,380
and it's the same for while that is true

00:32:58,710 --> 00:33:03,030
that is true but you can still use

00:33:01,380 --> 00:33:05,039
address sanitizer to find bugs in your

00:33:03,030 --> 00:33:07,710
own code and not in the standard c

00:33:05,039 --> 00:33:10,380
library while if you try to do this with

00:33:07,710 --> 00:33:13,549
the msn you will just get random false

00:33:10,380 --> 00:33:16,860
positives that make no sense at all so

00:33:13,549 --> 00:33:18,510
the difference there is you you get

00:33:16,860 --> 00:33:20,280
better results with ace and if you

00:33:18,510 --> 00:33:23,220
compile everything down to the last

00:33:20,280 --> 00:33:25,730
library with it but you can still use it

00:33:23,220 --> 00:33:28,440
if you only compile one thing with it

00:33:25,730 --> 00:33:30,450
yeah and there's also a threat sanitizer

00:33:28,440 --> 00:33:33,150
which is like mostly interesting for

00:33:30,450 --> 00:33:38,150
large projects like browser fork IDE

00:33:33,150 --> 00:33:41,450
it's probably also interesting but yeah

00:33:38,150 --> 00:33:43,380
so here's an example for you beasts on

00:33:41,450 --> 00:33:48,510
what we are doing here is we are

00:33:43,380 --> 00:33:51,630
shifting the variable by J and J is

00:33:48,510 --> 00:33:53,640
minus 1 and that's invalid you cannot do

00:33:51,630 --> 00:33:55,860
a shift with a negative value that's

00:33:53,640 --> 00:33:58,460
undefined and the next thing here is a

00:33:55,860 --> 00:34:06,080
integer overflow which is also undefined

00:33:58,460 --> 00:34:09,030
and I have this code here as well and

00:34:06,080 --> 00:34:10,830
the difference here is that UB Sun

00:34:09,030 --> 00:34:13,109
doesn't terminate your application so

00:34:10,830 --> 00:34:15,030
you can find multiple bucks at once and

00:34:13,109 --> 00:34:17,010
the latest version of essence also able

00:34:15,030 --> 00:34:19,619
to do this but you see here shift

00:34:17,010 --> 00:34:24,899
exponent minus 1 is negative signed

00:34:19,619 --> 00:34:28,109
integer overflow and here's an example

00:34:24,899 --> 00:34:30,510
for memory sanitizer so we have an an

00:34:28,109 --> 00:34:33,929
error here and then we set element 1 and

00:34:30,510 --> 00:34:36,330
then we access element number of Arc's c

00:34:33,929 --> 00:34:44,850
which is by default 1 but if we pass a

00:34:36,330 --> 00:34:47,340
parameter it's more so so if I run this

00:34:44,850 --> 00:34:49,530
I don't get an error but if I pass any

00:34:47,340 --> 00:34:55,780
random parameter I will get this yeah

00:34:49,530 --> 00:34:57,790
use of an initialized value ok then

00:34:55,780 --> 00:35:00,340
there are a number of these tools also

00:34:57,790 --> 00:35:02,740
available in the kernel so there's a

00:35:00,340 --> 00:35:05,290
kernel address sanitizer kernel UV Sun

00:35:02,740 --> 00:35:07,270
County Sun and there's a fuzzing tool

00:35:05,290 --> 00:35:10,030
called Zeus collar we're just trying to

00:35:07,270 --> 00:35:12,820
adapt this coverage based fuzzing to the

00:35:10,030 --> 00:35:15,700
kernel space was just called

00:35:12,820 --> 00:35:19,150
yeah I'm not super familiar with those I

00:35:15,700 --> 00:35:23,440
just once tested ka Sun and it found a

00:35:19,150 --> 00:35:29,770
bunch of stuff in my GPU driver yeah but

00:35:23,440 --> 00:35:32,230
yeah then one kind of biggie is network

00:35:29,770 --> 00:35:35,500
fuzzing because nobody really found a

00:35:32,230 --> 00:35:37,390
very good solution for that yet so you

00:35:35,500 --> 00:35:39,160
run into a lot of trouble like trying to

00:35:37,390 --> 00:35:41,410
do this because you kind of need to

00:35:39,160 --> 00:35:43,060
define like when you have basically you

00:35:41,410 --> 00:35:46,030
need an application that terminates

00:35:43,060 --> 00:35:47,710
after one connection attempt and things

00:35:46,030 --> 00:35:51,190
like that and there's a tool called

00:35:47,710 --> 00:35:53,170
preemie which is trying to put a file

00:35:51,190 --> 00:35:56,320
and and then simulate the networking

00:35:53,170 --> 00:35:59,080
calls and like let the file look like

00:35:56,320 --> 00:36:01,000
it's a TCP stream and there's a patch to

00:35:59,080 --> 00:36:03,400
AFL which tries the same but all of that

00:36:01,000 --> 00:36:07,390
is pretty fragile and doesn't work very

00:36:03,400 --> 00:36:09,280
well so I haven't seen anything there at

00:36:07,390 --> 00:36:12,340
that that works as flawlessly as the

00:36:09,280 --> 00:36:14,410
firebase things and that's something I

00:36:12,340 --> 00:36:17,700
would like to see yeah

00:36:14,410 --> 00:36:17,700
but yeah we're not there yet

00:36:17,910 --> 00:36:24,130
then there currently seems to be some

00:36:21,100 --> 00:36:25,840
research interest in combining fuzzing

00:36:24,130 --> 00:36:29,800
and something that's called symbolic

00:36:25,840 --> 00:36:31,810
execution so symbolic execution is

00:36:29,800 --> 00:36:33,910
basically comes from formal software

00:36:31,810 --> 00:36:37,510
verification and the idea is that you

00:36:33,910 --> 00:36:40,480
trying to analyze a piece of software

00:36:37,510 --> 00:36:42,880
and analyze all kinds of states this

00:36:40,480 --> 00:36:45,550
software can get into for all kinds of

00:36:42,880 --> 00:36:48,310
inputs and the problem with that is if

00:36:45,550 --> 00:36:50,860
you try this on any real software it

00:36:48,310 --> 00:36:53,320
will just have so many states that it

00:36:50,860 --> 00:36:56,380
will never finish running this analysis

00:36:53,320 --> 00:36:58,780
so what people are trying to do is to

00:36:56,380 --> 00:37:01,120
use fuzzing and if the father is stack

00:36:58,780 --> 00:37:03,130
that it cannot reach a certain part of

00:37:01,120 --> 00:37:06,150
the code then they try to use symbolic

00:37:03,130 --> 00:37:06,150
execution for it

00:37:06,240 --> 00:37:12,360
I'm kind of looking forward to see

00:37:09,119 --> 00:37:14,040
whether this will work or not so some

00:37:12,360 --> 00:37:17,369
people in the DARPA challenge have done

00:37:14,040 --> 00:37:20,190
this but there's nothing there yet that

00:37:17,369 --> 00:37:21,869
you can just use and try out so this one

00:37:20,190 --> 00:37:24,210
thing has been published produced called

00:37:21,869 --> 00:37:26,850
driller which the guy you saw earlier in

00:37:24,210 --> 00:37:30,000
the video was talking about but it is

00:37:26,850 --> 00:37:31,710
like for a artificial operating system

00:37:30,000 --> 00:37:33,240
that was used in the DARPA challenge and

00:37:31,710 --> 00:37:35,070
not for a real operating system

00:37:33,240 --> 00:37:37,619
therefore it's kind of questioned about

00:37:35,070 --> 00:37:39,750
how this translates to real so this is

00:37:37,619 --> 00:37:42,540
like open research and we will see but I

00:37:39,750 --> 00:37:43,950
must say I'm a bit skeptical if this is

00:37:42,540 --> 00:37:48,410
really something that will lead to

00:37:43,950 --> 00:37:51,540
significant interesting results yeah

00:37:48,410 --> 00:37:53,600
what I want to say like all of the tools

00:37:51,540 --> 00:37:55,740
I presented to you are free

00:37:53,600 --> 00:37:57,450
unfortunately not everything that the

00:37:55,740 --> 00:38:01,020
DARPA challenge made is free which is

00:37:57,450 --> 00:38:02,250
kind of a pity but like AFL lipfird's or

00:38:01,020 --> 00:38:05,250
address any ties or all the other

00:38:02,250 --> 00:38:07,530
sanitizers it's all free software so

00:38:05,250 --> 00:38:11,070
there's essentially no reason not to use

00:38:07,530 --> 00:38:16,770
it so just use it and fix your software

00:38:11,070 --> 00:38:18,690
with it and now this is something that

00:38:16,770 --> 00:38:21,960
kind of came up in the past couple of

00:38:18,690 --> 00:38:24,420
years what I'm doing here is mostly

00:38:21,960 --> 00:38:27,720
fixing bugs in C software which are

00:38:24,420 --> 00:38:29,130
typical C problems and you know there

00:38:27,720 --> 00:38:30,780
are these people who have been saying

00:38:29,130 --> 00:38:32,580
since forever that we should just

00:38:30,780 --> 00:38:34,770
rewrite everything in some safe or

00:38:32,580 --> 00:38:37,230
programming language and this debate has

00:38:34,770 --> 00:38:40,380
now accelerated because there's rust and

00:38:37,230 --> 00:38:42,900
a lot of people like rust and I think

00:38:40,380 --> 00:38:44,940
this is a me I'm not joking here I think

00:38:42,900 --> 00:38:47,340
this is a serious debate we should have

00:38:44,940 --> 00:38:49,920
whether this is really the way to go to

00:38:47,340 --> 00:38:51,960
try to fix all these see bugs which pop

00:38:49,920 --> 00:38:57,090
up again and again or if we shouldn't

00:38:51,960 --> 00:38:58,800
like move to some something safer so but

00:38:57,090 --> 00:39:00,690
I mean this is also kind of questioning

00:38:58,800 --> 00:39:03,720
of if what I do is the right thing to do

00:39:00,690 --> 00:39:05,940
so yeah well I wanted to have it

00:39:03,720 --> 00:39:10,190
mentioned and yeah maybe someone wants

00:39:05,940 --> 00:39:10,190
to rewrite QT in rust that would be cool

00:39:10,340 --> 00:39:17,430
okay so and and finally something is

00:39:13,170 --> 00:39:19,740
anyone here working for redhead no and

00:39:17,430 --> 00:39:23,520
that's that anyone working for Debbie

00:39:19,740 --> 00:39:27,420
or like involved with Debian okay so you

00:39:23,520 --> 00:39:29,970
will be happy so I thought okay I will

00:39:27,420 --> 00:39:33,270
fast package managers because like why

00:39:29,970 --> 00:39:35,580
not they pass stuff and then that's good

00:39:33,270 --> 00:39:40,920
for fuzzing and I can test if they are

00:39:35,580 --> 00:39:43,530
have same code so I first dpkg and I was

00:39:40,920 --> 00:39:46,140
impressed so I reported two bucks to the

00:39:43,530 --> 00:39:48,119
Debian security team and eight days

00:39:46,140 --> 00:39:50,310
later there was an update and the

00:39:48,119 --> 00:39:52,800
security advisory with these Box fixed

00:39:50,310 --> 00:39:54,839
for both from Debian and Ubuntu so

00:39:52,800 --> 00:39:56,460
that's pretty good right I mean if you

00:39:54,839 --> 00:40:04,290
have a vendor reaction like that that

00:39:56,460 --> 00:40:07,410
that's cool then I first rpm so in

00:40:04,290 --> 00:40:09,630
November last year I reported free box

00:40:07,410 --> 00:40:12,119
in rpm pausing to the redhead security

00:40:09,630 --> 00:40:14,609
team and got an answer yeah we just got

00:40:12,119 --> 00:40:17,599
thirty crash reports for rpm it may take

00:40:14,609 --> 00:40:22,260
some time to leave Tyco loose

00:40:17,599 --> 00:40:24,300
okay a bit about rpm and rpm is it was

00:40:22,260 --> 00:40:26,910
originally the redhead package manager

00:40:24,300 --> 00:40:29,099
but in 2007 they decided to make it an

00:40:26,910 --> 00:40:31,050
independent project it's now the RPM

00:40:29,099 --> 00:40:34,260
package manager it's used by redhead and

00:40:31,050 --> 00:40:36,900
salsa and some others so it's kind of

00:40:34,260 --> 00:40:39,839
independent although I mean RPM dot org

00:40:36,900 --> 00:40:42,089
still belongs to red hurt so but the

00:40:39,839 --> 00:40:44,280
redhead security team says however we

00:40:42,089 --> 00:40:45,839
don't own a PM dog domain so they

00:40:44,280 --> 00:40:52,080
disagree with the Whois data

00:40:45,839 --> 00:40:55,080
I'm not true RPM dog is a track

00:40:52,080 --> 00:40:56,839
installation track has a bug tracker so

00:40:55,080 --> 00:40:59,160
I could report back there that's great

00:40:56,839 --> 00:41:01,109
but then I tried to register an account

00:40:59,160 --> 00:41:03,630
and I got a certificate error it was

00:41:01,109 --> 00:41:08,609
expired in 2012 and it didn't match the

00:41:03,630 --> 00:41:11,130
- my name but then I ignored the

00:41:08,609 --> 00:41:13,950
certificate error and created a bag an

00:41:11,130 --> 00:41:15,839
account anyway and then I find out ok I

00:41:13,950 --> 00:41:18,359
still cannot create a bag it tells me I

00:41:15,839 --> 00:41:21,950
should ask on the mailing list or on IRC

00:41:18,359 --> 00:41:21,950
whether I am allowed to create a bug

00:41:22,920 --> 00:41:28,630
and then in the communication with

00:41:27,040 --> 00:41:31,180
redhead I found out okay there's a

00:41:28,630 --> 00:41:33,030
github repository but there's no link on

00:41:31,180 --> 00:41:37,900
the webpage to the github repository

00:41:33,030 --> 00:41:39,400
which is yeah I don't know and then okay

00:41:37,900 --> 00:41:42,160
maybe you want to find out what's the

00:41:39,400 --> 00:41:45,010
latest version of RPM there's some

00:41:42,160 --> 00:41:47,980
disagreement so if you go to rpm Oxley

00:41:45,010 --> 00:41:50,440
release it exists for 12:01 in the

00:41:47,980 --> 00:41:54,670
github repository to process for 12-0

00:41:50,440 --> 00:41:56,800
and Fedora is using 413 0 which yes

00:41:54,670 --> 00:42:03,369
doesn't seem to be an upstream release

00:41:56,800 --> 00:42:05,619
for it yeah so status right now is a one

00:42:03,369 --> 00:42:08,200
stack buffer overflow that I report it

00:42:05,619 --> 00:42:10,060
is still unfixed in the gate code and in

00:42:08,200 --> 00:42:11,290
the release you can find at least once

00:42:10,060 --> 00:42:13,240
you can find maybe there's a secret

00:42:11,290 --> 00:42:15,130
released somewhere I didn't find that it

00:42:13,240 --> 00:42:17,800
the release you can find all these packs

00:42:15,130 --> 00:42:20,830
are unfixed and there are more and then

00:42:17,800 --> 00:42:22,420
some people have there was a discussion

00:42:20,830 --> 00:42:25,119
on reddit where someone said that this

00:42:22,420 --> 00:42:27,010
is all boring because this is all after

00:42:25,119 --> 00:42:28,990
the signature check so I tried it again

00:42:27,010 --> 00:42:31,240
with pre signature dragon still found

00:42:28,990 --> 00:42:34,030
some things I'm not really sure what to

00:42:31,240 --> 00:42:35,590
do about it right now because they seem

00:42:34,030 --> 00:42:38,800
not to be willing to fix the situation

00:42:35,590 --> 00:42:41,260
so the thing here is these packs are not

00:42:38,800 --> 00:42:43,450
that interesting but what's interesting

00:42:41,260 --> 00:42:46,240
here is that the development process of

00:42:43,450 --> 00:42:47,710
rpm seems to be completely broken like I

00:42:46,240 --> 00:42:51,400
mean that's not how you do things

00:42:47,710 --> 00:42:56,040
yeah we hopefully can agree on that yeah

00:42:51,400 --> 00:43:00,010
and a small announcement here there's

00:42:56,040 --> 00:43:01,720
Berlin security meetup and the next

00:43:00,010 --> 00:43:03,540
meeting is tomorrow so if you're

00:43:01,720 --> 00:43:06,340
interested in security and cryptography

00:43:03,540 --> 00:43:10,840
you may want to come it's at the Mozilla

00:43:06,340 --> 00:43:13,810
building community space and that was my

00:43:10,840 --> 00:43:15,940
talk thanks for listening please test

00:43:13,810 --> 00:43:18,520
with a Dracaena tiser and please use

00:43:15,940 --> 00:43:21,150
fathering to test your software and now

00:43:18,520 --> 00:43:21,150
I'm open for questions

00:43:31,890 --> 00:43:37,150
Marco come in again then a question I'm

00:43:35,079 --> 00:43:40,420
one of the developers of popular the PDF

00:43:37,150 --> 00:43:44,170
library oh great I want to try you I get

00:43:40,420 --> 00:43:45,789
I randomly get people saying yeah I have

00:43:44,170 --> 00:43:48,579
this PDF that crashes the thing is like

00:43:45,789 --> 00:43:49,809
yeah yeah yeah maybe it's that then I

00:43:48,579 --> 00:43:51,279
say can you report the back and then

00:43:49,809 --> 00:43:53,259
like no because it's a security and then

00:43:51,279 --> 00:43:54,880
we end up in the same situations you

00:43:53,259 --> 00:43:56,049
mentioned like they don't want to report

00:43:54,880 --> 00:43:58,450
the back because it says it's a

00:43:56,049 --> 00:43:59,890
vulnerability but I want them to report

00:43:58,450 --> 00:44:02,650
the back because it's much easier to

00:43:59,890 --> 00:44:05,170
track if it's in a back tracker so yeah

00:44:02,650 --> 00:44:07,119
I understand the thing you said let's

00:44:05,170 --> 00:44:09,069
not discuss about it let's just fix it

00:44:07,119 --> 00:44:10,359
but sometimes it's like they don't even

00:44:09,069 --> 00:44:13,470
want to give me the file to fix it

00:44:10,359 --> 00:44:16,119
because they think they deserve more

00:44:13,470 --> 00:44:18,970
things than using a back tracker I know

00:44:16,119 --> 00:44:20,319
so I recorded a number of things in the

00:44:18,970 --> 00:44:22,089
back tracker and they have not been

00:44:20,319 --> 00:44:24,539
fixed and it's more than a year ago oh

00:44:22,089 --> 00:44:24,539
really

00:44:29,400 --> 00:44:36,849
and the genome bug tracker has no option

00:44:34,690 --> 00:44:39,880
that I as a back creator can create a

00:44:36,849 --> 00:44:42,069
security bug that's kept secret the back

00:44:39,880 --> 00:44:44,279
tracker has this ability but I cannot

00:44:42,069 --> 00:44:46,359
trigger it so maybe that's something so

00:44:44,279 --> 00:44:49,749
maybe we should talk later

00:44:46,359 --> 00:44:53,700
because I have yeah yeah I think there

00:44:49,749 --> 00:44:53,700
are stuff that can be improved and yeah

00:44:55,470 --> 00:45:02,410
one thing that I would ask you is do you

00:44:59,829 --> 00:45:04,989
know if anything for actually fussing

00:45:02,410 --> 00:45:07,989
user interfaces because I mean fuzzing

00:45:04,989 --> 00:45:11,319
file file based things is one thing but

00:45:07,989 --> 00:45:12,519
user interfaces are also prone to well

00:45:11,319 --> 00:45:14,200
invalid yeah

00:45:12,519 --> 00:45:17,890
missing input validation let's put it

00:45:14,200 --> 00:45:24,339
that yeah okay so first of all you can

00:45:17,890 --> 00:45:26,829
just like use them or start them like as

00:45:24,339 --> 00:45:30,599
I said I started KDE and I think four or

00:45:26,829 --> 00:45:30,599
five different parks just by stirring it

00:45:30,809 --> 00:45:35,940
what I did for a while was run my email

00:45:33,819 --> 00:45:38,559
client with that resin it has enabled

00:45:35,940 --> 00:45:40,030
the problem now is I know there's a use

00:45:38,559 --> 00:45:42,130
of the free bug and I don't

00:45:40,030 --> 00:45:44,410
managed to fix it because it's like

00:45:42,130 --> 00:45:46,270
complicated and now it's a bit scary

00:45:44,410 --> 00:45:50,050
because I know there's this pocket maybe

00:45:46,270 --> 00:45:52,060
a security bug and but so that's

00:45:50,050 --> 00:45:53,800
actually but I think that's a good way

00:45:52,060 --> 00:45:55,990
to do it like if you're the developer

00:45:53,800 --> 00:45:57,940
just occasionally you run your

00:45:55,990 --> 00:46:00,370
application with address any ties are

00:45:57,940 --> 00:46:02,260
enabled and there has been some work

00:46:00,370 --> 00:46:04,870
done by the parole office where they

00:46:02,260 --> 00:46:07,030
simulate user interactions with the

00:46:04,870 --> 00:46:18,900
father but I have not looked closely

00:46:07,030 --> 00:46:22,090
into this but yeah so can any of these

00:46:18,900 --> 00:46:25,120
principles also be applied to let's say

00:46:22,090 --> 00:46:30,400
say for languages just like rust or okay

00:46:25,120 --> 00:46:32,200
man yeah so I mean it it entirely

00:46:30,400 --> 00:46:33,640
depends on the language so what you can

00:46:32,200 --> 00:46:35,440
always do is these things like

00:46:33,640 --> 00:46:38,260
differential testing where you're just

00:46:35,440 --> 00:46:40,480
doing some correctness tests that is

00:46:38,260 --> 00:46:42,190
like independent of any language if you

00:46:40,480 --> 00:46:45,700
have a function that produces wrong

00:46:42,190 --> 00:46:48,430
output and there are all kinds of things

00:46:45,700 --> 00:46:50,770
to adapt AFL or similar tools to other

00:46:48,430 --> 00:46:53,860
languages so they I think there's an AFL

00:46:50,770 --> 00:46:56,950
rust and the Oh camel people are also

00:46:53,860 --> 00:46:59,200
using it I'm not sure how how exactly

00:46:56,950 --> 00:47:02,740
but I've been told so and there's a go

00:46:59,200 --> 00:47:05,020
further the thing the the question there

00:47:02,740 --> 00:47:08,650
is what are you looking for so some of

00:47:05,020 --> 00:47:10,770
these safer languages can crash like

00:47:08,650 --> 00:47:13,810
they crash if you have a buffer overflow

00:47:10,770 --> 00:47:15,910
some of them just like try we're

00:47:13,810 --> 00:47:17,680
crashing is not really a valid thing I

00:47:15,910 --> 00:47:20,470
mean they can still crash Vanessa back

00:47:17,680 --> 00:47:24,880
but there are all kinds of ways to adapt

00:47:20,470 --> 00:47:28,240
this to say for languages but the I

00:47:24,880 --> 00:47:30,400
think the the thing is that the C has

00:47:28,240 --> 00:47:33,040
most of these crashing backs therefore

00:47:30,400 --> 00:47:37,810
they're it's the they you get most of

00:47:33,040 --> 00:47:40,030
the output you mentioned that you run

00:47:37,810 --> 00:47:46,260
the address sanitizer uncute did you

00:47:40,030 --> 00:47:46,260
also try fuzzing cute and no not yet I

00:47:46,440 --> 00:47:49,600
just

00:47:47,650 --> 00:47:53,190
this in the past couple of days because

00:47:49,600 --> 00:47:53,190
I thought I have to do it for this talk

00:47:53,520 --> 00:47:58,150
one question you mentioned these rare

00:47:56,050 --> 00:48:00,850
back bucks and mathematical code which

00:47:58,150 --> 00:48:02,440
is actually pretty typical how does the

00:48:00,850 --> 00:48:05,230
father find that I mean if it's so

00:48:02,440 --> 00:48:08,380
unlikely that you really get the right

00:48:05,230 --> 00:48:11,770
book that's a very good question and I

00:48:08,380 --> 00:48:15,580
hope I wished I knew the answer so there

00:48:11,770 --> 00:48:17,620
are people kind of so it would probably

00:48:15,580 --> 00:48:19,980
require some very detailed analysis of

00:48:17,620 --> 00:48:23,140
what's going on my guess here is that

00:48:19,980 --> 00:48:26,560
AFL has a tendency to create repeating

00:48:23,140 --> 00:48:28,890
patterns and that seems to be more

00:48:26,560 --> 00:48:31,900
likely to trigger these kinds of bugs

00:48:28,890 --> 00:48:33,520
but there was for example at discussion

00:48:31,900 --> 00:48:35,590
I had with the developer of Lib father

00:48:33,520 --> 00:48:37,930
because he was very angry that there was

00:48:35,590 --> 00:48:40,360
one bark that AVL could find and Lib

00:48:37,930 --> 00:48:42,460
father could not find anywhere that

00:48:40,360 --> 00:48:45,340
cannot be hand lived father is the

00:48:42,460 --> 00:48:48,160
better tool and he fixed it now and he

00:48:45,340 --> 00:49:05,080
fixed it by adapting this pattern

00:48:48,160 --> 00:49:06,610
generation thing that AFL does so I had

00:49:05,080 --> 00:49:08,830
a session with people who are doing

00:49:06,610 --> 00:49:11,500
formal analysis and symbolic execution

00:49:08,830 --> 00:49:13,450
and they said yeah this is our thing is

00:49:11,500 --> 00:49:14,950
good for finding these bugs and asks and

00:49:13,450 --> 00:49:19,030
how many bugs he has found with it and

00:49:14,950 --> 00:49:21,660
he had one and I had like five so I'm

00:49:19,030 --> 00:49:24,610
not sure if this maybe maybe there's a

00:49:21,660 --> 00:49:31,660
but I feel right now that fathering is

00:49:24,610 --> 00:49:33,160
at least produces more results but like

00:49:31,660 --> 00:49:35,770
it just checks new code paths

00:49:33,160 --> 00:49:44,440
yeah that's its analysis it's doing it's

00:49:35,770 --> 00:49:45,880
fine so yeah so I mean this yeah maybe

00:49:44,440 --> 00:49:47,950
we can later have a discussion but the

00:49:45,880 --> 00:49:50,790
all this form of verification stuff it

00:49:47,950 --> 00:49:54,430
always sounds very interesting but then

00:49:50,790 --> 00:49:56,290
the then you're not so impressed by the

00:49:54,430 --> 00:49:58,760
real results that are produced by this

00:49:56,290 --> 00:50:02,330
okay thank you

00:49:58,760 --> 00:50:04,490
I have one comment Leggett I'm one of

00:50:02,330 --> 00:50:06,680
the guys who actually tried to build all

00:50:04,490 --> 00:50:09,800
of the KDE and cute applications with a

00:50:06,680 --> 00:50:11,330
sin and I haven't seen your bug so I was

00:50:09,800 --> 00:50:14,480
wondering whether that could maybe be

00:50:11,330 --> 00:50:16,220
due to me not compiling lip x kc b or

00:50:14,480 --> 00:50:18,680
stuff like that with Aysen enabled

00:50:16,220 --> 00:50:20,510
because like i i'm not using Gentle

00:50:18,680 --> 00:50:24,710
right i didn't rebuild all off my system

00:50:20,510 --> 00:50:26,630
so so I think if you build QT and KDE on

00:50:24,710 --> 00:50:36,470
top of it with ace and you should find

00:50:26,630 --> 00:50:41,660
them maybe it's new hi hmm I have a

00:50:36,470 --> 00:50:46,119
comment from from my practice my job we

00:50:41,660 --> 00:50:48,920
have soft commercial software based on

00:50:46,119 --> 00:50:52,580
open source components so then we use

00:50:48,920 --> 00:50:58,550
cute we are still at four point four

00:50:52,580 --> 00:51:01,490
point eight and I'm using red line and

00:50:58,550 --> 00:51:04,369
address analyzer four years at the

00:51:01,490 --> 00:51:07,340
beginning as we started using these

00:51:04,369 --> 00:51:12,560
tools it took us a year or two to

00:51:07,340 --> 00:51:15,140
eliminate bugs from our software and at

00:51:12,560 --> 00:51:21,520
the moment the last I would say four

00:51:15,140 --> 00:51:28,310
years I'm hunting jobs backs in in

00:51:21,520 --> 00:51:31,240
libraries like leap fund config or G

00:51:28,310 --> 00:51:34,880
leap or something like this and I'm not

00:51:31,240 --> 00:51:37,190
sure should I really report all these

00:51:34,880 --> 00:51:38,600
box where I actually have on the stack

00:51:37,190 --> 00:51:41,869
trace and the place where it happened

00:51:38,600 --> 00:51:46,730
and I don't really have time for my

00:51:41,869 --> 00:51:49,880
manager to to look deeper into it and so

00:51:46,730 --> 00:51:56,410
my job is limited to putting all these

00:51:49,880 --> 00:51:58,310
tech traces on to suppression list so

00:51:56,410 --> 00:52:00,470
Christians

00:51:58,310 --> 00:52:02,630
I don't have a good answer today I mean

00:52:00,470 --> 00:52:04,970
the the that's basically something you

00:52:02,630 --> 00:52:07,940
have to deal with the upstream projects

00:52:04,970 --> 00:52:10,250
if they kind of accept low quality back

00:52:07,940 --> 00:52:13,040
report I have a similar situation that I

00:52:10,250 --> 00:52:14,810
can run this Gentoo and try to compile

00:52:13,040 --> 00:52:17,090
all the packages with address sanitizer

00:52:14,810 --> 00:52:20,060
and then have a bunch of log files with

00:52:17,090 --> 00:52:23,840
addressing advisor arrows but like I

00:52:20,060 --> 00:52:25,550
won't ever like look into all of them so

00:52:23,840 --> 00:52:27,860
I'm wondering if I should just put this

00:52:25,550 --> 00:52:29,900
online somewhere and have some quota so

00:52:27,860 --> 00:52:32,630
I don't have a good answer to you sorry

00:52:29,900 --> 00:52:35,690
but I mean ideally the these projects

00:52:32,630 --> 00:52:47,420
should at least all use some kind of

00:52:35,690 --> 00:52:49,040
address sanitizer testing themselves if

00:52:47,420 --> 00:52:52,690
there are no more questions then please

00:52:49,040 --> 00:52:52,690

YouTube URL: https://www.youtube.com/watch?v=mKVHuXQTZu0


