Title: Arno Schoedl - From Iterators To Ranges - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	Pairs of iterators are ubiquitous throughout the C++ library. It is generally accepted that combining such a pair into a single entity usually termed Range delivers more concise and readable code. Defining the precise semantics of such Range concept proves surprisingly tricky, however. Theoretical considerations conflict with practical ones. Some design goals are mutually incompatible altogether. We will discuss existing proposals regarding ranges and their design choices, and discuss possible alternatives. With this talk, we enable you to be an informed participant in the upcoming standardization discussion on Ranges.
Captions: 
	00:00:05,270 --> 00:00:11,759
welcome everybody here i'm presenting

00:00:09,000 --> 00:00:15,210
although show from head of development

00:00:11,759 --> 00:00:18,060
for thing cell and he's going to have a

00:00:15,210 --> 00:00:22,560
presentation that is titled from

00:00:18,060 --> 00:00:26,420
iterators two ranges all right thank you

00:00:22,560 --> 00:00:28,740
very much and thank you for coming so

00:00:26,420 --> 00:00:31,500
i'm going to talk about from iterators

00:00:28,740 --> 00:00:35,840
two ranges what's going on currently in

00:00:31,500 --> 00:00:35,840
the standard in the standard library em

00:00:38,750 --> 00:00:43,290
okay so we got to talk about from

00:00:41,579 --> 00:00:46,950
iterators to rangers the first thing is

00:00:43,290 --> 00:00:52,680
who is familiar with ranges who is who

00:00:46,950 --> 00:00:55,680
knows the boost range library ok i guess

00:00:52,680 --> 00:01:00,390
very few now who knows the eric needless

00:00:55,680 --> 00:01:02,160
rangeview three library ok no one and I

00:01:00,390 --> 00:01:04,140
guess that's kind of superfluous to ask

00:01:02,160 --> 00:01:08,460
no one is using range as an everyday

00:01:04,140 --> 00:01:10,500
programming I think you should so what

00:01:08,460 --> 00:01:13,080
I'm i think what i want you to what i

00:01:10,500 --> 00:01:15,090
want you to take away from today is talk

00:01:13,080 --> 00:01:18,600
that you can do your C++ programming

00:01:15,090 --> 00:01:20,640
much in a much more productive much more

00:01:18,600 --> 00:01:26,610
efficient way if you make good use of

00:01:20,640 --> 00:01:28,439
ranges well what are ranges well when

00:01:26,610 --> 00:01:31,470
you're using C++ in the old-fashioned

00:01:28,439 --> 00:01:35,700
way you would write code like this you

00:01:31,470 --> 00:01:37,350
have the state vector and then when you

00:01:35,700 --> 00:01:39,420
want to sort the vector you pull the

00:01:37,350 --> 00:01:44,640
begin and end iterators out of that

00:01:39,420 --> 00:01:46,619
vector and call stood sort and then if

00:01:44,640 --> 00:01:50,310
you want to remove the duplicate

00:01:46,619 --> 00:01:53,369
elements cost is unique again with begin

00:01:50,310 --> 00:01:56,750
and end and then you call that not erase

00:01:53,369 --> 00:02:02,070
of this thing again that don't end

00:01:56,750 --> 00:02:04,140
that's a lot of mentioning of vac pairs

00:02:02,070 --> 00:02:06,840
of iterators really belong together they

00:02:04,140 --> 00:02:07,979
should be one object so it would be much

00:02:06,840 --> 00:02:11,810
nicer if you could write something like

00:02:07,979 --> 00:02:13,960
unique in place of sort of vector we're

00:02:11,810 --> 00:02:15,160
sort is doing the sorting

00:02:13,960 --> 00:02:20,280
the vector and unique in place is

00:02:15,160 --> 00:02:24,180
throwing away the duplicate elements now

00:02:20,280 --> 00:02:27,880
before we go on there is a bug in this

00:02:24,180 --> 00:02:31,420
piece of short piece of code at least

00:02:27,880 --> 00:02:38,890
it's not entirely generic and I want you

00:02:31,420 --> 00:02:41,260
to tell me what is that body which

00:02:38,890 --> 00:02:49,030
operated a standard sort use to sort the

00:02:41,260 --> 00:02:52,660
range operator less what does the unique

00:02:49,030 --> 00:02:55,030
use to throw away elements equality

00:02:52,660 --> 00:02:58,720
operator okay and if these two are not

00:02:55,030 --> 00:03:01,000
consistently implemented on the T the

00:02:58,720 --> 00:03:03,490
whole code is not going to work and this

00:03:01,000 --> 00:03:04,990
is also something that range the good

00:03:03,490 --> 00:03:06,640
range library will give you our range

00:03:04,990 --> 00:03:10,120
library certainly gives you that that

00:03:06,640 --> 00:03:12,550
you use these these operators more

00:03:10,120 --> 00:03:14,800
consistently because you have functions

00:03:12,550 --> 00:03:21,520
that package everything together into

00:03:14,800 --> 00:03:23,200
range functions okay why do I think that

00:03:21,520 --> 00:03:25,840
we in particular knows something about

00:03:23,200 --> 00:03:29,040
ranges thinks that has its own range

00:03:25,840 --> 00:03:31,240
library it grew out of booze range and

00:03:29,040 --> 00:03:33,310
we have about 1 million lines of

00:03:31,240 --> 00:03:36,640
production codes that use that library

00:03:33,310 --> 00:03:39,810
and we have the freedom to change both

00:03:36,640 --> 00:03:45,100
the library and our code as we like and

00:03:39,810 --> 00:03:46,960
the the library grew out of this

00:03:45,100 --> 00:03:49,300
collaboration between the our code and

00:03:46,960 --> 00:03:51,550
the library and I think that's the only

00:03:49,300 --> 00:03:54,340
way to come up with a good library

00:03:51,550 --> 00:03:57,310
design you need a heavy user of that

00:03:54,340 --> 00:04:00,280
library you need a large code base to

00:03:57,310 --> 00:04:03,340
try out your ideas and that's what we

00:04:00,280 --> 00:04:04,480
did we iterated our design until we came

00:04:03,340 --> 00:04:06,910
up with something that was really

00:04:04,480 --> 00:04:10,020
practical and I want to share with you

00:04:06,910 --> 00:04:14,890
today some of the insights that we got

00:04:10,020 --> 00:04:19,750
before well there are ranges kind of in

00:04:14,890 --> 00:04:21,910
C++ 11 already there is the range based

00:04:19,750 --> 00:04:25,060
for loop and who is familiar with the

00:04:21,910 --> 00:04:27,360
range based for loop okay most of you

00:04:25,060 --> 00:04:30,070
all right

00:04:27,360 --> 00:04:32,950
then there is actually universal access

00:04:30,070 --> 00:04:35,230
for the stiff begin stood with sip

00:04:32,950 --> 00:04:36,820
against it end so you don't have to call

00:04:35,230 --> 00:04:38,920
the member function it will actually

00:04:36,820 --> 00:04:41,920
this trip begins to end will also work

00:04:38,920 --> 00:04:44,140
on something like arrays so you can use

00:04:41,920 --> 00:04:49,120
always step against it and universally

00:04:44,140 --> 00:04:51,790
in in generic code and well no there's

00:04:49,120 --> 00:04:55,690
no end that's all you have in terms of

00:04:51,790 --> 00:04:59,800
ranges in the standard C++ 11 c plus 14

00:04:55,690 --> 00:05:02,500
didn't change much in that regard the

00:04:59,800 --> 00:05:05,950
future is going to be the current pet

00:05:02,500 --> 00:05:08,140
project of irregular he has a ranges

00:05:05,950 --> 00:05:11,470
technical specification in the standard

00:05:08,140 --> 00:05:14,020
committee and the first or the the thing

00:05:11,470 --> 00:05:16,090
that this the this specification the

00:05:14,020 --> 00:05:18,910
technical specification does is to lay

00:05:16,090 --> 00:05:21,220
some groundwork for ranges and to make

00:05:18,910 --> 00:05:23,950
basically algorithm the algorithm header

00:05:21,220 --> 00:05:26,380
support ranges so you have for example a

00:05:23,950 --> 00:05:28,390
function find that doesn't work on to

00:05:26,380 --> 00:05:31,840
iterators anymore instead it takes a

00:05:28,390 --> 00:05:34,630
range and internally it will then just

00:05:31,840 --> 00:05:35,980
dispatch to state find pulling the

00:05:34,630 --> 00:05:39,070
iterators out of the range that you

00:05:35,980 --> 00:05:42,370
passed in and then he has a bit more

00:05:39,070 --> 00:05:45,460
advanced a range of version 3 code base

00:05:42,370 --> 00:05:47,740
on the web and this is basically what

00:05:45,460 --> 00:05:50,590
eric envisions to standardize eventually

00:05:47,740 --> 00:05:52,390
it contains more functionality than just

00:05:50,590 --> 00:05:54,310
basically packaging to iterators

00:05:52,390 --> 00:05:57,670
together into a range object and we will

00:05:54,310 --> 00:06:00,460
see what this functionality is now first

00:05:57,670 --> 00:06:03,910
of all what are ranges first of all

00:06:00,460 --> 00:06:08,140
ranges are the familiar containers you

00:06:03,910 --> 00:06:09,820
can call begin and end on them and that

00:06:08,140 --> 00:06:12,910
makes them really ranges that they have

00:06:09,820 --> 00:06:15,610
a begin and end and they own their

00:06:12,910 --> 00:06:18,850
elements when you copy them you will

00:06:15,610 --> 00:06:21,130
copy the elements along with the object

00:06:18,850 --> 00:06:23,650
and you have deep consonants if you have

00:06:21,130 --> 00:06:28,210
a constant vector you can't mutate its

00:06:23,650 --> 00:06:30,040
elements in addition to containers there

00:06:28,210 --> 00:06:32,290
is this second thing which are also

00:06:30,040 --> 00:06:37,390
ranges the standard committee calls

00:06:32,290 --> 00:06:39,430
views and ranges are really containers

00:06:37,390 --> 00:06:39,969
and views taken together so what's the

00:06:39,430 --> 00:06:43,989
view

00:06:39,969 --> 00:06:46,739
well a view is basically your old

00:06:43,989 --> 00:06:49,659
iterator pair packaged into one object

00:06:46,739 --> 00:06:51,159
it instead of owning elements it will

00:06:49,659 --> 00:06:53,439
actually reference elements just like

00:06:51,159 --> 00:06:55,749
iterators do and you have shallow

00:06:53,439 --> 00:06:58,079
copying again just like iterators you

00:06:55,749 --> 00:07:01,449
can copy the reference in awe of one and

00:06:58,079 --> 00:07:03,099
you have shallow consciousness so when

00:07:01,449 --> 00:07:04,299
you your object is cons that doesn't

00:07:03,099 --> 00:07:06,459
necessarily mean you can't you take the

00:07:04,299 --> 00:07:09,419
elements just like with an iterator its

00:07:06,459 --> 00:07:12,519
constituent versus iterator and the

00:07:09,419 --> 00:07:17,289
constants of the iterator itself doesn't

00:07:12,519 --> 00:07:19,659
really matter now what I showed you was

00:07:17,289 --> 00:07:22,360
these just packaged pair of iterators

00:07:19,659 --> 00:07:26,529
and that's pretty boring there are more

00:07:22,360 --> 00:07:29,499
interesting ranges that make these these

00:07:26,529 --> 00:07:31,149
ranges an actual practical concept and

00:07:29,499 --> 00:07:32,649
and that's really driving the

00:07:31,149 --> 00:07:37,029
productivity gain you'll get from them

00:07:32,649 --> 00:07:38,979
so when you have say a find okay if you

00:07:37,029 --> 00:07:43,869
have a vector events you have a find and

00:07:38,979 --> 00:07:46,769
you find an element yeah so you have a

00:07:43,869 --> 00:07:49,749
find and you're finding an element for

00:07:46,769 --> 00:07:51,759
then well that's that simple call you

00:07:49,749 --> 00:07:54,159
get an iterator back now let's say you

00:07:51,759 --> 00:07:57,219
want to do the same thing on a structure

00:07:54,159 --> 00:07:59,050
and the ins are no longer just plain in

00:07:57,219 --> 00:08:03,039
there in that vector but they are

00:07:59,050 --> 00:08:07,439
packaged as an ID instructor a any other

00:08:03,039 --> 00:08:10,509
vector of a's you would like to kind of

00:08:07,439 --> 00:08:11,739
this code to be somewhat similar to that

00:08:10,509 --> 00:08:13,539
code because you are I mean you're

00:08:11,739 --> 00:08:15,639
looking for fours at the end right so

00:08:13,539 --> 00:08:17,259
how different can it be well in fact as

00:08:15,639 --> 00:08:19,479
you if you write it like you write it

00:08:17,259 --> 00:08:20,589
today it's quite different because you

00:08:19,479 --> 00:08:23,649
are using a different function you're

00:08:20,589 --> 00:08:26,049
using fine if and that functor that you

00:08:23,649 --> 00:08:29,469
plug into the find if does basically the

00:08:26,049 --> 00:08:32,050
extraction of the end a dot ID and the

00:08:29,469 --> 00:08:35,620
equality comparison together in one

00:08:32,050 --> 00:08:37,059
operand in one predicate so there are

00:08:35,620 --> 00:08:38,800
similar in semantics these two things

00:08:37,059 --> 00:08:40,800
but they are not really similar in

00:08:38,800 --> 00:08:44,680
syntax well how can we change that

00:08:40,800 --> 00:08:47,230
enters the transform adapter so down

00:08:44,680 --> 00:08:51,279
here what we do is we take the vector

00:08:47,230 --> 00:08:53,070
and wrap it into a tea into a transform

00:08:51,279 --> 00:08:56,700
that you

00:08:53,070 --> 00:08:58,440
pass in an extractor function so what

00:08:56,700 --> 00:08:59,820
does he see transform does is it returns

00:08:58,440 --> 00:09:01,970
an object first of all it doesn't do

00:08:59,820 --> 00:09:05,250
much it just generates an object that

00:09:01,970 --> 00:09:07,200
reference this is a vector and holds on

00:09:05,250 --> 00:09:09,840
to that to that function to execute and

00:09:07,200 --> 00:09:12,030
when do you then iterate it's it's a

00:09:09,840 --> 00:09:15,810
it's arranged when you iterate over that

00:09:12,030 --> 00:09:18,540
range with begin to end then the

00:09:15,810 --> 00:09:21,090
function listed memsen will be on the

00:09:18,540 --> 00:09:22,830
fly executed on every one of the

00:09:21,090 --> 00:09:24,510
elements so when you're extracting you

00:09:22,830 --> 00:09:32,370
will be a bit effectively extracting the

00:09:24,510 --> 00:09:34,920
ids from the vector and on this on this

00:09:32,370 --> 00:09:37,200
extract or these extracted ids you will

00:09:34,920 --> 00:09:39,060
then run your regular ranges find

00:09:37,200 --> 00:09:43,230
function with four and you get the

00:09:39,060 --> 00:09:44,970
iterator back now to further your

00:09:43,230 --> 00:09:46,980
understanding of the whole thing now

00:09:44,970 --> 00:09:53,670
what is it pointing to when you're

00:09:46,980 --> 00:09:56,060
running this anyone well it's pointing

00:09:53,670 --> 00:09:59,220
to int right so it's not pointing to a

00:09:56,060 --> 00:10:02,100
because basically when you ran the sushi

00:09:59,220 --> 00:10:05,730
to transform you turned your vector of

00:10:02,100 --> 00:10:08,400
a's into a range of ins and so the

00:10:05,730 --> 00:10:11,580
iterator is now pointing to int if you

00:10:08,400 --> 00:10:15,120
want the iterator to the a's back there

00:10:11,580 --> 00:10:17,310
is a function where you can call base on

00:10:15,120 --> 00:10:19,830
the iterator and it will actually go

00:10:17,310 --> 00:10:21,210
back it will unwrap your transform that

00:10:19,830 --> 00:10:26,220
you did and give you the original

00:10:21,210 --> 00:10:29,130
iterator maybe to remove some of the

00:10:26,220 --> 00:10:32,190
magic here is the implementation of such

00:10:29,130 --> 00:10:34,950
a transformative after the transform

00:10:32,190 --> 00:10:37,860
function will give you back an object of

00:10:34,950 --> 00:10:41,010
type transform range and it will have

00:10:37,860 --> 00:10:45,570
iterators and these iterators contain

00:10:41,010 --> 00:10:47,910
the functor and they will contain also

00:10:45,570 --> 00:10:49,620
the underlying iterator that is

00:10:47,910 --> 00:10:54,120
iterating over your vector your original

00:10:49,620 --> 00:10:56,550
vector of eight and whenever you are

00:10:54,120 --> 00:10:58,980
calling the dereference operator it will

00:10:56,550 --> 00:11:00,560
actually execute the function on the

00:10:58,980 --> 00:11:02,720
dereference value

00:11:00,560 --> 00:11:06,710
return that okay and that really does

00:11:02,720 --> 00:11:09,140
the unpacking off of the ID and here

00:11:06,710 --> 00:11:15,529
well the base function easy enough you

00:11:09,140 --> 00:11:17,210
just returned your iterator okay let's

00:11:15,529 --> 00:11:19,310
talk about a different adapter and and

00:11:17,210 --> 00:11:21,980
that transform of the filter adapter are

00:11:19,310 --> 00:11:24,860
really the bread and butter of using

00:11:21,980 --> 00:11:26,690
Rangers they will already get you if you

00:11:24,860 --> 00:11:28,730
if you nest them they will already get

00:11:26,690 --> 00:11:32,089
you quite far in your code these are by

00:11:28,730 --> 00:11:33,500
far the most used adapters for ranges so

00:11:32,089 --> 00:11:38,240
here's the filter adapter what does it

00:11:33,500 --> 00:11:40,220
do it takes a vector again and it will

00:11:38,240 --> 00:11:41,900
filter with that predicate it will

00:11:40,220 --> 00:11:45,410
filter all the elements out of that

00:11:41,900 --> 00:11:49,010
vector where the ID equals 4 and it will

00:11:45,410 --> 00:11:50,630
only return these and again it's lazy so

00:11:49,010 --> 00:11:52,790
when you create this thing it doesn't do

00:11:50,630 --> 00:11:55,160
anything and when you start iterating it

00:11:52,790 --> 00:11:57,740
will look at the individual elements and

00:11:55,160 --> 00:11:59,839
decide whether to pass them on to you or

00:11:57,740 --> 00:12:02,750
whether to skip them and just just go on

00:11:59,839 --> 00:12:05,450
and give you back the next one here's

00:12:02,750 --> 00:12:08,540
the implementation you have a function

00:12:05,450 --> 00:12:10,130
that is the one that basically decides

00:12:08,540 --> 00:12:12,920
whether that's the filter function

00:12:10,130 --> 00:12:15,020
whether you pass or not and you have an

00:12:12,920 --> 00:12:16,580
iterator and you have the end iterator

00:12:15,020 --> 00:12:17,810
why do you have the end iterator let's

00:12:16,580 --> 00:12:19,930
look at the implementation of the

00:12:17,810 --> 00:12:23,770
increment operator so what does it do it

00:12:19,930 --> 00:12:26,930
increments the it goes one further and

00:12:23,770 --> 00:12:29,180
then until if you don't hit the end and

00:12:26,930 --> 00:12:31,100
there you need the nth iterate ER it

00:12:29,180 --> 00:12:33,620
will basically keep filtering until you

00:12:31,100 --> 00:12:36,290
find something that actually passes your

00:12:33,620 --> 00:12:38,960
filter and that's the one where the

00:12:36,290 --> 00:12:40,730
interrater is going to stop okay so it's

00:12:38,960 --> 00:12:42,530
it's just going to skip the elements

00:12:40,730 --> 00:12:44,420
that you don't want basically but in

00:12:42,530 --> 00:12:46,400
order for you to ensure that you don't

00:12:44,420 --> 00:12:52,310
run past the end you need that end

00:12:46,400 --> 00:12:55,010
iterator okay pretty good so now we have

00:12:52,310 --> 00:12:58,880
two pretty useful components of our

00:12:55,010 --> 00:13:01,790
range library let's see how does the TC

00:12:58,880 --> 00:13:07,089
filter of the filter of a filter look

00:13:01,790 --> 00:13:10,760
like okay second look looks like this

00:13:07,089 --> 00:13:12,600
you get a huge iterator when you're

00:13:10,760 --> 00:13:14,399
using this in your code

00:13:12,600 --> 00:13:17,519
and this is actually what boost range

00:13:14,399 --> 00:13:19,980
does you are getting iterators which are

00:13:17,519 --> 00:13:23,970
one kilobyte in size if you copy them

00:13:19,980 --> 00:13:26,459
around things get terrible why is that

00:13:23,970 --> 00:13:29,370
well you have a function that's a

00:13:26,459 --> 00:13:31,949
functor three here okay fine then you

00:13:29,370 --> 00:13:34,259
have an iterator well the iterator the

00:13:31,949 --> 00:13:36,389
the inner iterator itself is a filter

00:13:34,259 --> 00:13:39,990
iterator so it will return contain a

00:13:36,389 --> 00:13:41,610
function and an iterator and it's again

00:13:39,990 --> 00:13:43,380
a filter well it we're trying to fight

00:13:41,610 --> 00:13:46,019
it in contain a function and an iterator

00:13:43,380 --> 00:13:48,810
and you try to act and then this guy

00:13:46,019 --> 00:13:50,670
will again return the iterator end which

00:13:48,810 --> 00:13:52,769
again looks like this and then that and

00:13:50,670 --> 00:13:56,250
so on until you get exponential growth

00:13:52,769 --> 00:14:00,959
in your ATAR exercise obviously that's

00:13:56,250 --> 00:14:02,759
not what we want so the idea is you have

00:14:00,959 --> 00:14:05,220
to keep your iterator small iterators

00:14:02,759 --> 00:14:07,110
are copied frequently there are there

00:14:05,220 --> 00:14:10,040
moved around in your code you can't have

00:14:07,110 --> 00:14:14,220
them one kilobyte in size obviously okay

00:14:10,040 --> 00:14:16,139
so one idea is to say okay we have this

00:14:14,220 --> 00:14:18,060
adapter object and you notice that the

00:14:16,139 --> 00:14:19,800
filter and the transform adapter objects

00:14:18,060 --> 00:14:22,290
they were all empty or just define the

00:14:19,800 --> 00:14:24,930
iterator inside but they can carry data

00:14:22,290 --> 00:14:27,750
so why don't we put the data that is

00:14:24,930 --> 00:14:30,360
common to all these adapters the

00:14:27,750 --> 00:14:33,810
function and the end into this adapter

00:14:30,360 --> 00:14:36,149
object and then our iterators they just

00:14:33,810 --> 00:14:39,180
reference the range the adapter object

00:14:36,149 --> 00:14:43,319
and they carry around the inner iterator

00:14:39,180 --> 00:14:45,720
this is now for the filter range and as

00:14:43,319 --> 00:14:48,209
you can see well your iterators get

00:14:45,720 --> 00:14:50,279
quite a bit smaller there is a

00:14:48,209 --> 00:14:53,009
limitation since the iterator is now

00:14:50,279 --> 00:14:56,430
pointing at the the adapter object the

00:14:53,009 --> 00:14:58,560
iterators must not outlive the arrange

00:14:56,430 --> 00:15:01,829
object their adapter object and that's

00:14:58,560 --> 00:15:04,319
actually a requirement that is in the

00:15:01,829 --> 00:15:05,819
range TS so this standard that you will

00:15:04,319 --> 00:15:08,819
the thing that you will get in the c++

00:15:05,819 --> 00:15:10,709
standard tells you if you pull an

00:15:08,819 --> 00:15:13,139
iterator out of a range object you must

00:15:10,709 --> 00:15:15,480
not use this iterator object once a

00:15:13,139 --> 00:15:17,160
range object is dead and this is this

00:15:15,480 --> 00:15:19,680
requirement is essential to get

00:15:17,160 --> 00:15:21,839
reasonable performance in particular to

00:15:19,680 --> 00:15:23,639
reduce the size of the iterator and

00:15:21,839 --> 00:15:25,379
that's something that we actually that

00:15:23,639 --> 00:15:30,149
they actually put into the standard

00:15:25,379 --> 00:15:34,169
once we notice this problem okay so here

00:15:30,149 --> 00:15:36,389
is now the iterator of filter or filter

00:15:34,169 --> 00:15:38,189
and filter well you have a range if an

00:15:36,389 --> 00:15:40,679
iterator well that iterator still

00:15:38,189 --> 00:15:42,659
contains a point until its range and the

00:15:40,679 --> 00:15:45,179
iterator and it's contains arrange to

00:15:42,659 --> 00:15:47,759
this with Ray up well that's not great

00:15:45,179 --> 00:15:49,319
right it's actually what range we three

00:15:47,759 --> 00:15:52,409
does this is the state of the art of the

00:15:49,319 --> 00:15:58,109
standard committee but it is not

00:15:52,409 --> 00:16:01,019
insanely great we want to do better how

00:15:58,109 --> 00:16:04,889
can we do better well let's introduce a

00:16:01,019 --> 00:16:07,019
new concept you call it index it's kind

00:16:04,889 --> 00:16:10,649
of like an iterator except that the

00:16:07,019 --> 00:16:13,470
operations require that you pass in the

00:16:10,649 --> 00:16:17,609
range object that this is this that this

00:16:13,470 --> 00:16:19,649
iterator is off okay so and then the

00:16:17,609 --> 00:16:22,349
operations only on the index are

00:16:19,649 --> 00:16:25,769
actually defined by convention on the

00:16:22,349 --> 00:16:27,149
range object so when you have this index

00:16:25,769 --> 00:16:31,259
range which is which is arranged

00:16:27,149 --> 00:16:32,999
implemented via these index concept then

00:16:31,259 --> 00:16:35,519
you have beginning next and index which

00:16:32,999 --> 00:16:37,350
is kind of like begin and end and you

00:16:35,519 --> 00:16:38,970
have an increment index that takes the

00:16:37,350 --> 00:16:40,649
index which will increment this index

00:16:38,970 --> 00:16:42,959
you have a decrement index which

00:16:40,649 --> 00:16:44,549
decrements the index energy reference so

00:16:42,959 --> 00:16:47,669
every time you are implementing these

00:16:44,549 --> 00:16:53,129
operations you have the index object as

00:16:47,669 --> 00:16:55,529
well as the range hmm well first of all

00:16:53,129 --> 00:16:57,959
well that's great idea but you know the

00:16:55,529 --> 00:16:59,100
world is running on iterators so if

00:16:57,959 --> 00:17:00,720
someone comes up and saying well we're

00:16:59,100 --> 00:17:02,279
going to throw away the iterate as we

00:17:00,720 --> 00:17:03,389
now need this new index concept you're

00:17:02,279 --> 00:17:07,009
going to rewrite your code all with

00:17:03,389 --> 00:17:14,370
indices that's unlikely to fly right

00:17:07,009 --> 00:17:16,980
well luckily the index if you have

00:17:14,370 --> 00:17:21,089
implemented this index range you can

00:17:16,980 --> 00:17:23,399
easily implement a generic iterator for

00:17:21,089 --> 00:17:25,439
index wrapper that turns that index

00:17:23,399 --> 00:17:28,259
concept back into an iterator concept

00:17:25,439 --> 00:17:30,149
and so whenever you have an index range

00:17:28,259 --> 00:17:32,850
its kind of trivial to implement

00:17:30,149 --> 00:17:35,129
iterators for them you qualified you can

00:17:32,850 --> 00:17:36,809
do it automatically so you have iterator

00:17:35,129 --> 00:17:37,510
for index it just has a pointer to the

00:17:36,809 --> 00:17:40,450
range

00:17:37,510 --> 00:17:43,270
and it stores the index type of that

00:17:40,450 --> 00:17:45,220
range and if you have something like an

00:17:43,270 --> 00:17:46,840
increment operator it just calls the

00:17:45,220 --> 00:17:49,990
range with increment index of that index

00:17:46,840 --> 00:17:51,670
okay so easy enough so that's not a

00:17:49,990 --> 00:17:55,090
problem whenever you are we are now

00:17:51,670 --> 00:17:58,330
doing index ranges we you can use them

00:17:55,090 --> 00:18:01,230
with iterators no problem okay so how

00:17:58,330 --> 00:18:03,720
does that help us to solve our problem

00:18:01,230 --> 00:18:07,420
here's an example of a filter range

00:18:03,720 --> 00:18:09,700
implemented using this concept so you

00:18:07,420 --> 00:18:13,240
have the filter range with a function of

00:18:09,700 --> 00:18:17,170
the filter funk function and a reference

00:18:13,240 --> 00:18:18,580
to the base range you don't have it reg

00:18:17,170 --> 00:18:19,930
you don't store directly begin and

00:18:18,580 --> 00:18:23,170
iterators anymore but you could store a

00:18:19,930 --> 00:18:25,900
reference to the base range and you say

00:18:23,170 --> 00:18:27,700
okay my in next type is actually the

00:18:25,900 --> 00:18:31,390
base in next time there's no difference

00:18:27,700 --> 00:18:34,210
in types so it's kind of like well the

00:18:31,390 --> 00:18:37,060
filter needs the underlying vector

00:18:34,210 --> 00:18:38,560
iterator to increment but it doesn't

00:18:37,060 --> 00:18:41,200
need much else that's the essential

00:18:38,560 --> 00:18:44,350
piece of information now if you

00:18:41,200 --> 00:18:46,240
increment the index it you can ask the

00:18:44,350 --> 00:18:49,030
base because you stored it to increment

00:18:46,240 --> 00:18:51,880
your index and you do this until you hit

00:18:49,030 --> 00:18:54,490
the end or until something passes your

00:18:51,880 --> 00:18:56,140
functor and every time for for increment

00:18:54,490 --> 00:18:58,150
for end for your reference you can

00:18:56,140 --> 00:19:02,590
always refer to the base which we store

00:18:58,150 --> 00:19:04,750
here okay so together with this iterator

00:19:02,590 --> 00:19:08,020
for index you can now build stacks

00:19:04,750 --> 00:19:09,970
remember that the filter index is no

00:19:08,020 --> 00:19:11,490
matter how large your stack is is go

00:19:09,970 --> 00:19:14,350
always going to be the underlying in

00:19:11,490 --> 00:19:16,240
underlying iterator so if you have a

00:19:14,350 --> 00:19:18,820
filter of a filter of a photographer or

00:19:16,240 --> 00:19:22,030
filter of a vector the outermost filter

00:19:18,820 --> 00:19:26,440
will still have as its index the iterate

00:19:22,030 --> 00:19:28,090
iterator type of the vector and then you

00:19:26,440 --> 00:19:30,370
use our own wrapper iterator for index

00:19:28,090 --> 00:19:32,170
and now all the iterators you build on

00:19:30,370 --> 00:19:35,080
these huge stacks they're all just two

00:19:32,170 --> 00:19:38,380
pointers basically the iterator of the

00:19:35,080 --> 00:19:43,060
vector and a pointer to the range object

00:19:38,380 --> 00:19:46,150
the outermost strange object okay that's

00:19:43,060 --> 00:19:48,340
quite nice let's go to another

00:19:46,150 --> 00:19:50,750
difference between what's basically

00:19:48,340 --> 00:19:54,760
proposed for standardization and

00:19:50,750 --> 00:19:57,500
we are doing the if the adapter input

00:19:54,760 --> 00:20:04,160
who is familiar with L value versus our

00:19:57,500 --> 00:20:07,570
value okay if the adapter input is an

00:20:04,160 --> 00:20:10,400
lvalue container and so it's basically a

00:20:07,570 --> 00:20:13,160
vector that has been has been declared

00:20:10,400 --> 00:20:15,200
elsewhere and here you are just

00:20:13,160 --> 00:20:18,890
generating a filter object on that

00:20:15,200 --> 00:20:21,650
vector with some predicate then there's

00:20:18,890 --> 00:20:23,810
obviously work but what happens if you

00:20:21,650 --> 00:20:26,000
turn this into an r-value you're

00:20:23,810 --> 00:20:29,000
basically inside your filter you are

00:20:26,000 --> 00:20:30,650
creating the vector and directly passes

00:20:29,000 --> 00:20:34,160
into the filter and this is a quite

00:20:30,650 --> 00:20:35,330
quite frequent in your in encode that

00:20:34,160 --> 00:20:40,310
that you want to do this kind of stuff

00:20:35,330 --> 00:20:41,840
I'm talking out of experience well the

00:20:40,310 --> 00:20:45,080
thing is it doesn't compile why does it

00:20:41,840 --> 00:20:48,230
compile well the view is referencing its

00:20:45,080 --> 00:20:50,870
base range is based range or container

00:20:48,230 --> 00:20:53,000
whatever it is and in this case the

00:20:50,870 --> 00:20:56,930
vector will actually go out of scope as

00:20:53,000 --> 00:20:59,990
soon as you you go past the semicolon

00:20:56,930 --> 00:21:01,310
here and so when this is an r-value you

00:20:59,990 --> 00:21:04,850
suddenly have a dining reference

00:21:01,310 --> 00:21:07,010
certainly not a good idea and so what

00:21:04,850 --> 00:21:08,900
the range we three library says is it

00:21:07,010 --> 00:21:12,710
doesn't compile we're not going to deal

00:21:08,900 --> 00:21:15,740
with this well the thing is there is an

00:21:12,710 --> 00:21:18,650
alternative in that library to call

00:21:15,740 --> 00:21:20,960
action filter instead of view filter and

00:21:18,650 --> 00:21:26,900
what will it will it will actually

00:21:20,960 --> 00:21:29,660
compile but what it does is that instead

00:21:26,900 --> 00:21:32,630
of generating a lazy range it will

00:21:29,660 --> 00:21:36,170
directly execute that filter operation

00:21:32,630 --> 00:21:39,620
on the underlying vector and basically

00:21:36,170 --> 00:21:44,180
take the vector filter it eagerly right

00:21:39,620 --> 00:21:47,210
away and pass out the vector hmm the

00:21:44,180 --> 00:21:49,070
thing is I mean I'm afraid programmers

00:21:47,210 --> 00:21:51,110
are going to try or view filter doesn't

00:21:49,070 --> 00:21:52,850
work well them use action filter oh this

00:21:51,110 --> 00:21:55,490
works that's that's great so let's use

00:21:52,850 --> 00:21:58,100
that well you suddenly pesum eyes your

00:21:55,490 --> 00:22:00,110
code because you really need to you it

00:21:58,100 --> 00:22:01,700
will eagerly filter that whole vector

00:22:00,110 --> 00:22:02,960
and even if you only need the first

00:22:01,700 --> 00:22:04,679
element and then throw away everything

00:22:02,960 --> 00:22:06,749
else well you you

00:22:04,679 --> 00:22:11,549
just force yourself to spend the off n

00:22:06,749 --> 00:22:17,119
time to filter the vector so what do we

00:22:11,549 --> 00:22:19,499
do instead yeah so it's not lazy anymore

00:22:17,119 --> 00:22:21,240
so what we are doing in our library is

00:22:19,499 --> 00:22:22,740
if the adapter is an lvalue container

00:22:21,240 --> 00:22:25,019
there's just no problem the filter is

00:22:22,740 --> 00:22:28,139
going to create a view its reference all

00:22:25,019 --> 00:22:30,269
of one copy shallow Constance now if the

00:22:28,139 --> 00:22:33,600
adapter input is an r-value container

00:22:30,269 --> 00:22:36,389
what filter does is it creates a

00:22:33,600 --> 00:22:38,549
container it actually aggregates the

00:22:36,389 --> 00:22:41,279
r-value it moves the r-value into an

00:22:38,549 --> 00:22:44,220
internal variable in an internal member

00:22:41,279 --> 00:22:45,779
and and then it's a deep copy it has

00:22:44,220 --> 00:22:49,289
deep constants it's just like a

00:22:45,779 --> 00:22:52,860
container but it's always lazy because

00:22:49,289 --> 00:22:54,779
in our mind on the laziness concept and

00:22:52,860 --> 00:22:57,360
this container nests are really

00:22:54,779 --> 00:23:01,679
orthogonal you can be a container but

00:22:57,360 --> 00:23:03,450
still be lazy and we hope that that

00:23:01,679 --> 00:23:06,809
avoids these kind of traps that you will

00:23:03,450 --> 00:23:08,639
get into when you when you follow this

00:23:06,809 --> 00:23:11,279
previous approach and at the same time

00:23:08,639 --> 00:23:13,950
like it allows you to write compact code

00:23:11,279 --> 00:23:15,720
because you can you can nest all these

00:23:13,950 --> 00:23:20,809
these things the things that create the

00:23:15,720 --> 00:23:23,700
vector and the filtering and so on ok

00:23:20,809 --> 00:23:25,019
there's one more thing that we have it's

00:23:23,700 --> 00:23:26,279
a bit stolen from the from the blue

00:23:25,019 --> 00:23:30,330
range library they have something

00:23:26,279 --> 00:23:32,580
similar the more flexible algorithm

00:23:30,330 --> 00:23:35,309
returns so when you have a find usually

00:23:32,580 --> 00:23:38,070
you return an iterator to the element

00:23:35,309 --> 00:23:42,240
that you actually found or end if you

00:23:38,070 --> 00:23:46,289
didn't find anything hmm sometimes it

00:23:42,240 --> 00:23:49,470
may be nice to do something like like

00:23:46,289 --> 00:23:52,320
this where you have so this is an

00:23:49,470 --> 00:23:55,289
extension where it gets an extra type

00:23:52,320 --> 00:23:58,289
pack that kind of lets you customize

00:23:55,289 --> 00:24:01,139
what happens when you found something or

00:23:58,289 --> 00:24:03,509
when you did not find something ok what

00:24:01,139 --> 00:24:06,210
pack actually does gets is an iterator

00:24:03,509 --> 00:24:08,159
and a range and there is this special

00:24:06,210 --> 00:24:10,830
thing pack singleton which says we might

00:24:08,159 --> 00:24:12,779
didn't find anything what shall I do and

00:24:10,830 --> 00:24:14,039
that is only past the range and the

00:24:12,779 --> 00:24:14,909
standard implementation would look like

00:24:14,039 --> 00:24:16,799
this

00:24:14,909 --> 00:24:18,899
the regular pack just returns the

00:24:16,799 --> 00:24:21,989
iterator pack single group returns the

00:24:18,899 --> 00:24:24,749
end of the range okay so what you now

00:24:21,989 --> 00:24:27,840
can do is document for example in your

00:24:24,749 --> 00:24:30,330
code if you don't expect to find to ever

00:24:27,840 --> 00:24:31,830
fail if you know that something is or

00:24:30,330 --> 00:24:36,570
that what you what you are looking for

00:24:31,830 --> 00:24:38,909
is in the range then the then you can

00:24:36,570 --> 00:24:41,669
actually document I'm not expecting and

00:24:38,909 --> 00:24:44,429
to be ever returned and that's that

00:24:41,669 --> 00:24:46,710
usually requires this extra assert and

00:24:44,429 --> 00:24:48,359
it's kind of lengthy to write but here

00:24:46,710 --> 00:24:50,639
you can simply say okay I'm going to

00:24:48,359 --> 00:24:53,759
declare this should actually return

00:24:50,639 --> 00:24:57,570
something you can do more you can say

00:24:53,759 --> 00:25:00,149
hey return me everything that is before

00:24:57,570 --> 00:25:02,940
the thing that I was looking for we turn

00:25:00,149 --> 00:25:07,200
the head okay so this will do something

00:25:02,940 --> 00:25:11,009
like it takes these take is generating a

00:25:07,200 --> 00:25:13,379
range that goes from from begin to the

00:25:11,009 --> 00:25:14,759
iterator that you passed in okay so it

00:25:13,379 --> 00:25:16,440
will basically up to the point where you

00:25:14,759 --> 00:25:20,820
where you found something it will give

00:25:16,440 --> 00:25:23,129
you a range of values and yeah plan is

00:25:20,820 --> 00:25:24,450
being still have this the sort faults we

00:25:23,129 --> 00:25:31,999
still expect some of it to find

00:25:24,450 --> 00:25:31,999
something okay let me get to a

00:25:32,269 --> 00:25:37,919
generalization of ranges so far ranges

00:25:34,559 --> 00:25:39,059
we're always using iterators in our mind

00:25:37,919 --> 00:25:41,749
that doesn't need to be the case

00:25:39,059 --> 00:25:45,210
sometimes you have some code like this

00:25:41,749 --> 00:25:48,679
where you are traversing widgets and you

00:25:45,210 --> 00:25:51,330
pass in a function that using

00:25:48,679 --> 00:25:54,539
essentially the big old visitor pattern

00:25:51,330 --> 00:25:57,659
where every widget that you have gets

00:25:54,539 --> 00:26:00,090
passed in to this function so here you

00:25:57,659 --> 00:26:01,499
you may have a nesting traversal where

00:26:00,090 --> 00:26:02,999
you pass in the function by reference

00:26:01,499 --> 00:26:05,369
and otherwise the function gets called

00:26:02,999 --> 00:26:09,869
with every single element that you have

00:26:05,369 --> 00:26:12,869
and it's a bit like a range except that

00:26:09,869 --> 00:26:17,159
well you iterate in kind of a different

00:26:12,869 --> 00:26:18,840
way there are no it directors and but

00:26:17,159 --> 00:26:22,049
still it make might make sense to write

00:26:18,840 --> 00:26:24,210
something like this you say okay did my

00:26:22,049 --> 00:26:25,650
mouse hit anything well the first thing

00:26:24,210 --> 00:26:28,050
is

00:26:25,650 --> 00:26:31,530
I love arranged you pass in a function

00:26:28,050 --> 00:26:33,480
and interest reverse the ridges and this

00:26:31,530 --> 00:26:35,850
thing is a little bit like the test

00:26:33,480 --> 00:26:37,770
function of a normal any off where you

00:26:35,850 --> 00:26:38,760
say okay get me a widget and I just

00:26:37,770 --> 00:26:41,190
going to check whether the Masters

00:26:38,760 --> 00:26:43,890
whether that we just got hit by the

00:26:41,190 --> 00:26:46,410
mouse okay so it's this is very range

00:26:43,890 --> 00:26:49,140
like although what you're what you're

00:26:46,410 --> 00:26:51,600
iterating over is not an iterator based

00:26:49,140 --> 00:26:55,160
range so how can we fold these concepts

00:26:51,600 --> 00:26:58,620
together what we're really doing here is

00:26:55,160 --> 00:27:00,390
replacing or integrating two concepts of

00:26:58,620 --> 00:27:02,940
iteration and I want to want to point

00:27:00,390 --> 00:27:05,280
them out to you there is something

00:27:02,940 --> 00:27:08,670
called external iteration and it's basic

00:27:05,280 --> 00:27:11,040
computer science the consumer that's

00:27:08,670 --> 00:27:12,930
consuming the data calls the producer to

00:27:11,040 --> 00:27:15,410
get the new element this is what we are

00:27:12,930 --> 00:27:17,400
used to with iterations so you are

00:27:15,410 --> 00:27:18,450
consumers sitting down here and whenever

00:27:17,400 --> 00:27:20,670
you're saying I don't want another

00:27:18,450 --> 00:27:21,900
element I say start it and it produces

00:27:20,670 --> 00:27:23,490
an element and returns it to the

00:27:21,900 --> 00:27:25,740
consumer and then it may say plus plus

00:27:23,490 --> 00:27:27,210
it and then again soccer star it and I

00:27:25,740 --> 00:27:29,430
go into the producer improves an element

00:27:27,210 --> 00:27:30,690
it goes back to the consumer so the

00:27:29,430 --> 00:27:34,140
consumer is at the bottom of the stack

00:27:30,690 --> 00:27:35,790
is how the stack grows and the bruiser

00:27:34,140 --> 00:27:38,040
is at the top of the stack and whenever

00:27:35,790 --> 00:27:39,330
you want an element you call up into a

00:27:38,040 --> 00:27:43,320
function and the function to come back

00:27:39,330 --> 00:27:47,760
with a new element you could turn the

00:27:43,320 --> 00:27:50,790
whole thing around see I have it interim

00:27:47,760 --> 00:27:52,290
operation right so first of all the

00:27:50,790 --> 00:27:55,470
advantages and disadvantages of external

00:27:52,290 --> 00:27:57,510
iteration the consumer as i said is at

00:27:55,470 --> 00:28:00,210
the bottom of the stack and you can

00:27:57,510 --> 00:28:04,110
write contiguous code for this consumer

00:28:00,210 --> 00:28:06,150
you can do any kind of logic and you

00:28:04,110 --> 00:28:07,290
have one contiguous code path and

00:28:06,150 --> 00:28:08,700
whenever you want an element you say

00:28:07,290 --> 00:28:11,220
give me an element given element given

00:28:08,700 --> 00:28:14,870
element that's easier to write obviously

00:28:11,220 --> 00:28:18,300
and it also has better performance

00:28:14,870 --> 00:28:19,950
because for for the consumer because the

00:28:18,300 --> 00:28:23,640
state in which the consumer is currently

00:28:19,950 --> 00:28:25,110
in is encoded in your program flow you

00:28:23,640 --> 00:28:26,550
don't have to restore the state you

00:28:25,110 --> 00:28:29,010
don't have you don't get called at one

00:28:26,550 --> 00:28:31,650
point and say well where were I where am

00:28:29,010 --> 00:28:33,210
i what what which state I'm are in you

00:28:31,650 --> 00:28:35,820
are in the state that you are while you

00:28:33,210 --> 00:28:37,620
are executing your program and you have

00:28:35,820 --> 00:28:38,620
no limit for stack memory whenever you

00:28:37,620 --> 00:28:40,420
need memory you just can

00:28:38,620 --> 00:28:41,710
get it get as much stat memory as one

00:28:40,420 --> 00:28:44,530
you can recur s'what do whatever you

00:28:41,710 --> 00:28:48,220
like there's no limit now the producer

00:28:44,530 --> 00:28:51,640
is in a more difficult situation it

00:28:48,220 --> 00:28:53,890
doesn't have the contiguous code path

00:28:51,640 --> 00:28:55,870
for the whole sequence it only has a

00:28:53,890 --> 00:28:58,990
continuous code to generate one single

00:28:55,870 --> 00:29:01,150
item and every time it gets called again

00:28:58,990 --> 00:29:03,040
for the next item it has to restore its

00:29:01,150 --> 00:29:06,250
state and decide where am I for example

00:29:03,040 --> 00:29:08,860
in the in the tree that I'm iterating

00:29:06,250 --> 00:29:11,200
over or so that makes it a bit harder to

00:29:08,860 --> 00:29:13,000
write and it also makes the performance

00:29:11,200 --> 00:29:14,290
a little bit worse you only have a

00:29:13,000 --> 00:29:16,420
single entry point to you kind of have

00:29:14,290 --> 00:29:17,920
this dynamic dispatch at that single

00:29:16,420 --> 00:29:21,570
entry point we are going to continue

00:29:17,920 --> 00:29:23,380
within my conf low and there is

00:29:21,570 --> 00:29:26,830
basically when you when you want to

00:29:23,380 --> 00:29:28,690
carry around state for one part of the

00:29:26,830 --> 00:29:30,700
EO from from producing one element to

00:29:28,690 --> 00:29:33,400
producing the next element so for one

00:29:30,700 --> 00:29:35,110
call to the next call the only place you

00:29:33,400 --> 00:29:37,240
really have you could really can do this

00:29:35,110 --> 00:29:38,950
is inside your iterator so insider

00:29:37,240 --> 00:29:41,200
iterator you only have limited space you

00:29:38,950 --> 00:29:43,750
can't use arbitrary lots of love stacks

00:29:41,200 --> 00:29:46,900
face that gets carried between any and

00:29:43,750 --> 00:29:48,250
the iterator calls or you have to go to

00:29:46,900 --> 00:29:51,690
the heap and allocate the memory there

00:29:48,250 --> 00:29:55,120
but that's certainly not very efficient

00:29:51,690 --> 00:29:58,179
contrast that with internal iteration so

00:29:55,120 --> 00:30:00,670
the year here the producer calls the

00:29:58,179 --> 00:30:02,410
consumer with and two with with a new

00:30:00,670 --> 00:30:07,510
element this is what we saw with the

00:30:02,410 --> 00:30:10,510
Traverse widgets so here the widgets are

00:30:07,510 --> 00:30:12,790
being traversed and whenever you are you

00:30:10,510 --> 00:30:15,490
whenever the producer has a new element

00:30:12,790 --> 00:30:17,260
it will consume call the consumer so it

00:30:15,490 --> 00:30:18,490
really turns things upside down the

00:30:17,260 --> 00:30:20,200
producer is again at the bottom of the

00:30:18,490 --> 00:30:21,610
stack and being on the bottom of the

00:30:20,200 --> 00:30:23,860
stack is great and all the advantages

00:30:21,610 --> 00:30:25,450
that I already talked about the consumer

00:30:23,860 --> 00:30:27,460
is now at the top and it has all the

00:30:25,450 --> 00:30:29,740
problems that the consumer would have if

00:30:27,460 --> 00:30:31,960
it's being at the cop there are the

00:30:29,740 --> 00:30:37,000
problems of being at the top of the

00:30:31,960 --> 00:30:40,300
stack now how can we integrate these two

00:30:37,000 --> 00:30:41,980
well it would be nice to have both right

00:30:40,300 --> 00:30:47,550
that both are actually at the bottom of

00:30:41,980 --> 00:30:49,990
the stack and yes you can do this with

00:30:47,550 --> 00:30:53,290
co routines these are really what Co

00:30:49,990 --> 00:30:55,570
routines are all about you whenever you

00:30:53,290 --> 00:30:57,700
are you are hitting something that you

00:30:55,570 --> 00:31:00,760
want to pass on to your to your consumer

00:30:57,700 --> 00:31:02,830
you say yield and the other guy was

00:31:00,760 --> 00:31:04,720
waiting in its control flow and picks up

00:31:02,830 --> 00:31:06,880
the item and quite a few programming

00:31:04,720 --> 00:31:09,429
languages already have that sequence

00:31:06,880 --> 00:31:13,390
person doesn't have it yet but there are

00:31:09,429 --> 00:31:15,610
actually proposals to do that there are

00:31:13,390 --> 00:31:18,760
basically two ways to do it one is

00:31:15,610 --> 00:31:21,340
stacked full you have in both have in an

00:31:18,760 --> 00:31:23,110
arbitrary amount of stack they're

00:31:21,340 --> 00:31:25,510
usually implemented as operating system

00:31:23,110 --> 00:31:27,910
fibers and that's very expensive so if

00:31:25,510 --> 00:31:29,500
you want to write a tight loop this is

00:31:27,910 --> 00:31:30,730
not going to be feasible this is not

00:31:29,500 --> 00:31:32,679
going to be efficient because every time

00:31:30,730 --> 00:31:35,590
you are basically yielding to your other

00:31:32,679 --> 00:31:37,540
fiber you have to restore it state you

00:31:35,590 --> 00:31:40,570
have to switch stack and and that's

00:31:37,540 --> 00:31:43,120
that's expensive every fiber is going to

00:31:40,570 --> 00:31:46,840
take one megabyte usually on windows 32

00:31:43,120 --> 00:31:49,600
I think of virtual memory because you

00:31:46,840 --> 00:31:51,190
work for this quarter team so it's not

00:31:49,600 --> 00:31:55,060
nothing yet you want to do to iterate

00:31:51,190 --> 00:31:58,030
over a bunch of integers the second

00:31:55,060 --> 00:31:59,410
alternative is stateless con routines

00:31:58,030 --> 00:32:00,700
and because of the performance benefits

00:31:59,410 --> 00:32:03,460
that there is actually a proposal

00:32:00,700 --> 00:32:06,640
there's no proposal for sexual technical

00:32:03,460 --> 00:32:08,530
routines but there you can only yield in

00:32:06,640 --> 00:32:11,320
the topmost function they kind of go

00:32:08,530 --> 00:32:13,480
around this problem of having a limited

00:32:11,320 --> 00:32:16,240
snack space by saying well whenever you

00:32:13,480 --> 00:32:17,620
were yielding I know that I will analyze

00:32:16,240 --> 00:32:21,310
the amount of stack that I have to

00:32:17,620 --> 00:32:23,679
allocate for that Cora Jean by yielding

00:32:21,310 --> 00:32:25,660
only in the topmost function and but

00:32:23,679 --> 00:32:28,750
that limits quite a bit what you can do

00:32:25,660 --> 00:32:30,820
because if you one reason that you want

00:32:28,750 --> 00:32:34,330
this kind of thing is that you are going

00:32:30,820 --> 00:32:36,820
into you that you up that you are

00:32:34,330 --> 00:32:38,890
recursing and they are naturally you

00:32:36,820 --> 00:32:44,440
want to yield inside these recursive

00:32:38,890 --> 00:32:47,530
functions so and it's also still a bit

00:32:44,440 --> 00:32:51,220
expensive because every time you yield

00:32:47,530 --> 00:32:55,120
to the other to the other other other

00:32:51,220 --> 00:32:56,890
fiber you have to find your resume point

00:32:55,120 --> 00:32:58,720
so you got kind of going to have

00:32:56,890 --> 00:33:00,520
something like a dynamic jump kind of

00:32:58,720 --> 00:33:02,800
like a virtual function call every time

00:33:00,520 --> 00:33:03,980
you're doing it again if you are if you

00:33:02,800 --> 00:33:05,660
are in a very tight loop and you

00:33:03,980 --> 00:33:07,580
want to aggressively in line your loops

00:33:05,660 --> 00:33:11,890
and aggressively optimize the code

00:33:07,580 --> 00:33:16,040
that's not something you want to use

00:33:11,890 --> 00:33:18,440
okay but it turns out internal iteration

00:33:16,040 --> 00:33:22,490
is why do quite often is good enough for

00:33:18,440 --> 00:33:24,410
many algorithms so I like here find or

00:33:22,490 --> 00:33:25,610
binary search will find you want an

00:33:24,410 --> 00:33:26,929
iterator out so it's going to be

00:33:25,610 --> 00:33:29,120
difficult because with internal

00:33:26,929 --> 00:33:33,320
interation you don't have any iterators

00:33:29,120 --> 00:33:34,340
but for each that just works okay and

00:33:33,320 --> 00:33:36,230
most of the time when you're doing with

00:33:34,340 --> 00:33:37,850
rangers is for each you can do a

00:33:36,230 --> 00:33:40,010
cumulative you'll have any of none of

00:33:37,850 --> 00:33:41,630
all these things they all work with

00:33:40,010 --> 00:33:43,490
internal iteration and there's basically

00:33:41,630 --> 00:33:45,500
no reason why your range library

00:33:43,490 --> 00:33:47,900
shouldn't support these algorithms that

00:33:45,500 --> 00:33:50,929
the regular library is supporting with

00:33:47,900 --> 00:33:52,910
iterators why it should not support this

00:33:50,929 --> 00:33:56,750
with internal iteration in our library

00:33:52,910 --> 00:33:58,940
does that and the adapters I talked

00:33:56,750 --> 00:34:00,890
about the filter and the transform also

00:33:58,940 --> 00:34:02,270
they actually are implementable with

00:34:00,890 --> 00:34:04,070
internal iteration basically when you're

00:34:02,270 --> 00:34:05,390
filtering you are being called with a

00:34:04,070 --> 00:34:07,250
new element and what if you don't like

00:34:05,390 --> 00:34:09,169
that new element you simply return wait

00:34:07,250 --> 00:34:10,639
for the next one to come with a

00:34:09,169 --> 00:34:13,070
transform you just pick up the element

00:34:10,639 --> 00:34:14,810
transform it and pass it on so that's

00:34:13,070 --> 00:34:17,210
easy to implement also with internal

00:34:14,810 --> 00:34:20,149
iteration so we allow ranges that

00:34:17,210 --> 00:34:22,010
support only internal iteration and then

00:34:20,149 --> 00:34:24,350
the any of implementation for example

00:34:22,010 --> 00:34:25,669
looks like this so you get a range and

00:34:24,350 --> 00:34:29,060
again this range doesn't have any

00:34:25,669 --> 00:34:31,460
iterators okay it you have this helper

00:34:29,060 --> 00:34:33,710
function enumerate that basically takes

00:34:31,460 --> 00:34:35,780
the range and hides the fact whether

00:34:33,710 --> 00:34:37,820
that range has iterators or not if it

00:34:35,780 --> 00:34:39,320
has iterators it will iterate using

00:34:37,820 --> 00:34:42,169
iterators if it doesn't have any

00:34:39,320 --> 00:34:44,300
iterators it will call this this this

00:34:42,169 --> 00:34:47,119
for each function inside the range which

00:34:44,300 --> 00:34:50,179
will pass out all the elements and then

00:34:47,119 --> 00:34:52,429
you have the functor hear that you are

00:34:50,179 --> 00:34:54,980
passing into this enumerate and it will

00:34:52,429 --> 00:34:58,840
actually do the work of vienna off just

00:34:54,980 --> 00:35:03,369
orient the results now is that all good

00:34:58,840 --> 00:35:06,080
well not quite there's something missing

00:35:03,369 --> 00:35:09,530
regular any office lazy right it will

00:35:06,080 --> 00:35:15,530
stop as soon as it decided that it's

00:35:09,530 --> 00:35:17,660
true so how do we do that huh first temp

00:35:15,530 --> 00:35:19,549
was an exception

00:35:17,660 --> 00:35:21,559
right whenever you are your true you

00:35:19,549 --> 00:35:23,270
throw an exception well that's not a

00:35:21,559 --> 00:35:25,369
good idea it's too slow throwing

00:35:23,270 --> 00:35:28,220
exceptions is expensive is not meant to

00:35:25,369 --> 00:35:30,650
be for regular control flow okay so

00:35:28,220 --> 00:35:33,020
second idea was a simple you know so

00:35:30,650 --> 00:35:35,569
what we say in our library is when you

00:35:33,020 --> 00:35:38,569
are when your your your filter function

00:35:35,569 --> 00:35:41,900
here returns an enum of that special

00:35:38,569 --> 00:35:43,849
type break or continue he wants to tell

00:35:41,900 --> 00:35:46,609
you something he wants to tell you hey

00:35:43,849 --> 00:35:49,730
either continue or break the nice thing

00:35:46,609 --> 00:35:53,059
about returning this special type is you

00:35:49,730 --> 00:35:55,069
can actually check at compile-time to

00:35:53,059 --> 00:35:56,780
eliminate this brake check if the funky

00:35:55,069 --> 00:35:59,240
we function returns break or continue

00:35:56,780 --> 00:36:00,890
then you have to do the check and you

00:35:59,240 --> 00:36:02,480
have to break when break is returned by

00:36:00,890 --> 00:36:04,220
this new rep no returns anything else

00:36:02,480 --> 00:36:06,289
there's nothing to check you know he's

00:36:04,220 --> 00:36:07,940
going to continue okay he doesn't try to

00:36:06,289 --> 00:36:09,500
tell you anything so you can just loop

00:36:07,940 --> 00:36:15,200
like you ever before and you don't have

00:36:09,500 --> 00:36:18,190
to check now actually it's interesting

00:36:15,200 --> 00:36:21,859
that this concept is practical for

00:36:18,190 --> 00:36:24,380
things other than places where you need

00:36:21,859 --> 00:36:27,230
internal iteration for example when you

00:36:24,380 --> 00:36:29,299
want to come cat to get your genius

00:36:27,230 --> 00:36:31,430
container so you have a list and you

00:36:29,299 --> 00:36:33,829
have a vector and you want to end the

00:36:31,430 --> 00:36:35,569
list the vector to the list ok so the

00:36:33,829 --> 00:36:38,230
way write it in our program is like this

00:36:35,569 --> 00:36:42,920
on catalyst back and here you are now

00:36:38,230 --> 00:36:44,599
getting the the contents of both well

00:36:42,920 --> 00:36:46,700
usually when you want to write this with

00:36:44,599 --> 00:36:49,069
indices you would have to do something

00:36:46,700 --> 00:36:53,210
like a concat range that incorporates

00:36:49,069 --> 00:36:56,000
these two ranges and it also has to

00:36:53,210 --> 00:36:58,880
store in index that is either of the

00:36:56,000 --> 00:37:00,950
type of one range or of the type of the

00:36:58,880 --> 00:37:02,809
other range so you first have an

00:37:00,950 --> 00:37:05,210
iterator that iterates over the first

00:37:02,809 --> 00:37:06,740
range and once hits the end it will

00:37:05,210 --> 00:37:08,809
switch over to the second range in

00:37:06,740 --> 00:37:10,849
iterate through that one so that that

00:37:08,809 --> 00:37:12,859
index has to be either that kind of

00:37:10,849 --> 00:37:15,260
iterator or that kind of iterator either

00:37:12,859 --> 00:37:18,650
of iterator of vectors of iterator of

00:37:15,260 --> 00:37:20,210
lists in our case the thing is that an

00:37:18,650 --> 00:37:21,890
increment index then is quite

00:37:20,210 --> 00:37:25,339
complicated you basically have to switch

00:37:21,890 --> 00:37:27,500
on that variant if the variant is of one

00:37:25,339 --> 00:37:30,140
type you have to increment it for the

00:37:27,500 --> 00:37:30,660
first range and check whether you hit

00:37:30,140 --> 00:37:32,550
the end

00:37:30,660 --> 00:37:35,520
and if you hit the end you have to

00:37:32,550 --> 00:37:36,990
reassign that index with the beginning

00:37:35,520 --> 00:37:39,030
of the second range so you have to kind

00:37:36,990 --> 00:37:40,980
of through the skip over and can

00:37:39,030 --> 00:37:42,300
concatenate it two together and you have

00:37:40,980 --> 00:37:43,620
to do this every time you are

00:37:42,300 --> 00:37:47,190
incrementing your index you have quite a

00:37:43,620 --> 00:37:50,100
few checks that you have to do and it

00:37:47,190 --> 00:37:51,900
would be nice to avoid dereference

00:37:50,100 --> 00:37:54,660
actually a similar years also the switch

00:37:51,900 --> 00:37:56,310
on the index and and again you have a

00:37:54,660 --> 00:37:59,460
branch with every time you are actually

00:37:56,310 --> 00:38:01,050
to referencing you're a traitor hmm well

00:37:59,460 --> 00:38:02,610
with generator ranges you can actually

00:38:01,050 --> 00:38:05,340
do this very efficiently I mean that's

00:38:02,610 --> 00:38:08,240
pretty obvious in our case these

00:38:05,340 --> 00:38:11,640
operator parentheses here is the

00:38:08,240 --> 00:38:13,230
operator that enumerates the elements so

00:38:11,640 --> 00:38:15,720
that conquered range on top of having

00:38:13,230 --> 00:38:18,510
this iterator functionality which it

00:38:15,720 --> 00:38:21,360
also has if you want to use it it for

00:38:18,510 --> 00:38:23,730
efficiency this time it actually has

00:38:21,360 --> 00:38:26,190
that generator interface this this

00:38:23,730 --> 00:38:29,220
internal iteration interface that we'll

00:38:26,190 --> 00:38:30,650
just plug the elements into this

00:38:29,220 --> 00:38:34,230
function object and it does that by

00:38:30,650 --> 00:38:36,870
again calling the internal iteration of

00:38:34,230 --> 00:38:39,240
these two ranges that incorporates one

00:38:36,870 --> 00:38:41,520
and then the other and there you don't

00:38:39,240 --> 00:38:44,970
need any checks for for end it's very

00:38:41,520 --> 00:38:47,010
efficient and so so algorithms that are

00:38:44,970 --> 00:38:48,660
actually capable of dealing with

00:38:47,010 --> 00:38:50,940
internal iteration like this any off

00:38:48,660 --> 00:38:53,250
would actually use this form of

00:38:50,940 --> 00:38:56,870
iterating over ranges because it's

00:38:53,250 --> 00:39:00,810
because it's more efficient all right

00:38:56,870 --> 00:39:05,880
that was it thank you very much we do

00:39:00,810 --> 00:39:08,400
have that range library public on github

00:39:05,880 --> 00:39:11,150
if you want to play with it this is a

00:39:08,400 --> 00:39:15,570
URL you also find it on our website and

00:39:11,150 --> 00:39:18,660
to wrap up I want to say this i hate the

00:39:15,570 --> 00:39:24,990
range based for loop it's forbidden add

00:39:18,660 --> 00:39:29,760
think so why because instead people then

00:39:24,990 --> 00:39:33,300
write this the good old for loop instead

00:39:29,760 --> 00:39:36,720
of using algorithms and writing it nice

00:39:33,300 --> 00:39:38,130
and compactly like this so get away from

00:39:36,720 --> 00:39:40,020
the range based for loop i don't know

00:39:38,130 --> 00:39:42,290
why they got this thing in there thank

00:39:40,020 --> 00:39:42,290
you very much

00:39:47,640 --> 00:39:53,739
okay thank you or no so we have some

00:39:51,519 --> 00:40:00,160
time for questions so raise your hands

00:39:53,739 --> 00:40:02,769
and I will run to you so high I think

00:40:00,160 --> 00:40:04,809
question since your library is seems to

00:40:02,769 --> 00:40:06,880
be quite a bit more powerful and better

00:40:04,809 --> 00:40:09,279
than the boost version or the i know

00:40:06,880 --> 00:40:10,839
sydney's ation version is your company

00:40:09,279 --> 00:40:13,749
involved in sanitation efforts to push

00:40:10,839 --> 00:40:16,950
that upstream yes we know well we are we

00:40:13,749 --> 00:40:19,690
are actually the sponsors of the C++

00:40:16,950 --> 00:40:21,400
committee in Germany because there was

00:40:19,690 --> 00:40:23,859
no one else and Siemens didn't want to

00:40:21,400 --> 00:40:25,989
do it and we did it so we are sponsoring

00:40:23,859 --> 00:40:27,700
the participation of the Germans and the

00:40:25,989 --> 00:40:29,890
successful standard committee we didn't

00:40:27,700 --> 00:40:32,710
push this as a standardization effort

00:40:29,890 --> 00:40:34,989
why well if you have ever been to a

00:40:32,710 --> 00:40:37,059
standardization committee meeting it is

00:40:34,989 --> 00:40:42,339
a very political and very long-winded

00:40:37,059 --> 00:40:44,650
process and so far we've been we spend

00:40:42,339 --> 00:40:46,509
our time rather on improving the code

00:40:44,650 --> 00:40:49,269
then then pushing it into

00:40:46,509 --> 00:40:51,219
standardization so it's it's simply a

00:40:49,269 --> 00:40:53,829
matter of spending the time making the

00:40:51,219 --> 00:40:55,049
effort and certainly what what's going

00:40:53,829 --> 00:40:57,029
to come out of the current space

00:40:55,049 --> 00:41:00,460
implementation or the the current

00:40:57,029 --> 00:41:03,579
standardization effort the ranges is not

00:41:00,460 --> 00:41:06,880
bad and in particular it doesn't do

00:41:03,579 --> 00:41:10,089
anything that would preclude later

00:41:06,880 --> 00:41:11,920
improvement so that's that's basically

00:41:10,089 --> 00:41:14,079
what we did as a gatekeeper this was one

00:41:11,920 --> 00:41:16,479
there's one thing with the lifetime of

00:41:14,079 --> 00:41:17,769
iterators and Rangers I mean if that

00:41:16,479 --> 00:41:19,599
would have been voted the other way

00:41:17,769 --> 00:41:21,269
around we say okay you can keep using

00:41:19,599 --> 00:41:23,739
you iterators even if your range is gone

00:41:21,269 --> 00:41:26,140
then basically the the door would have

00:41:23,739 --> 00:41:28,140
been slammed shot to ever make something

00:41:26,140 --> 00:41:31,420
that actually works you would have been

00:41:28,140 --> 00:41:33,910
in a dead end and that we actually

00:41:31,420 --> 00:41:35,859
prevent it so so that was kind of like

00:41:33,910 --> 00:41:37,779
the scope of our effort other than that

00:41:35,859 --> 00:41:41,890
I'd rather write code than doing

00:41:37,779 --> 00:41:49,650
political work I'm sorry any more

00:41:41,890 --> 00:41:49,650
questions none

00:41:49,940 --> 00:41:55,579
okay then big thanks to our know again

00:41:53,150 --> 00:41:57,020
thank you very much and there is

00:41:55,579 --> 00:41:59,630
actually if people have noticed there's

00:41:57,020 --> 00:42:02,810
ice cream outside and I'm gonna be in

00:41:59,630 --> 00:42:05,750
the near our booth for the next half

00:42:02,810 --> 00:42:07,930
hour and and yes we are hiring thank you

00:42:05,750 --> 00:42:07,930
very much

00:42:13,230 --> 00:42:15,290

YouTube URL: https://www.youtube.com/watch?v=Ocp3dJX8bRc


