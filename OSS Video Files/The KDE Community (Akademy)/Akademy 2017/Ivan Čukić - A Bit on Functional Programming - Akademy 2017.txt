Title: Ivan Čukić - A Bit on Functional Programming - Akademy 2017
Publication date: 2017-11-20
Playlist: Akademy 2017
Description: 
	Functional programming is often said to be necessary in multi-threaded environments, but that is only one part of the story. Avoiding mutation helps avoid explicit synchronization of concurrent processes, but it can also be helpful in other circumstances.

This talk will cover a selection of topics related to functional programming, and how it can improve our day-to-day work, make our code safer, cleaner and more correct.

https://conf.kde.org/en/akademy2017/public/events/331
Captions: 
	00:00:07,340 --> 00:00:15,330
that could be a more serious but usually

00:00:13,020 --> 00:00:19,679
I have more specifically so that they

00:00:15,330 --> 00:00:22,330
want to talk on this one's time delay

00:00:19,679 --> 00:00:24,310
we will return over here it's not likely

00:00:22,330 --> 00:00:27,279
to do super functional programming but

00:00:24,310 --> 00:00:32,880
it is black to introduce a concepts that

00:00:27,279 --> 00:00:32,880
might be interesting enough for you

00:00:36,059 --> 00:00:41,140
usually before I started first

00:00:38,110 --> 00:00:45,010
walkthrough above the spammers the first

00:00:41,140 --> 00:00:47,050
disclaimer is my favorite use native

00:00:45,010 --> 00:00:48,879
code readable because the people were

00:00:47,050 --> 00:00:50,710
going to wrap in your project might know

00:00:48,879 --> 00:00:53,439
where you live and then probably side

00:00:50,710 --> 00:00:59,559
effects and since hearing kata community

00:00:53,439 --> 00:01:02,589
is not most likely because this the

00:00:59,559 --> 00:01:04,600
second is memory is the high temp yes

00:01:02,589 --> 00:01:08,590
we're special

00:01:04,600 --> 00:01:14,250
I tend to omit some stuff in the slide

00:01:08,590 --> 00:01:14,250
because it makes like too big too

00:01:15,530 --> 00:01:29,400
so to demonstrate complaints so there

00:01:27,300 --> 00:01:33,000
are a lot of things that we can learn

00:01:29,400 --> 00:01:36,690
from and my team signals class obviously

00:01:33,000 --> 00:01:39,570
and usually a Saturday but as a

00:01:36,690 --> 00:01:42,480
functional programming best to give you

00:01:39,570 --> 00:01:45,270
their own definitions the problem is

00:01:42,480 --> 00:01:46,620
that to us to functional developers less

00:01:45,270 --> 00:01:49,620
functional programming you're going to

00:01:46,620 --> 00:01:53,100
get three different answers and from my

00:01:49,620 --> 00:01:55,440
point of view my answer is just the

00:01:53,100 --> 00:01:58,110
first part higher order functions so

00:01:55,440 --> 00:02:06,510
options that can accept other functions

00:01:58,110 --> 00:02:12,360
articles for partial derivative I guess

00:02:06,510 --> 00:02:16,250
we own activities and Utah State but its

00:02:12,360 --> 00:02:16,250
activity if you've never change anything

00:02:17,540 --> 00:02:31,739
but I don't really enjoy teaching so an

00:02:26,900 --> 00:02:37,709
hour and the reason I got into fashion

00:02:31,739 --> 00:02:41,930
programming is an evil ended a long time

00:02:37,709 --> 00:02:41,930
ago I had to write software for

00:02:42,340 --> 00:02:52,040
and I was a kid I didn't notice it was

00:02:45,139 --> 00:02:54,260
blasting because some pilots have to use

00:02:52,040 --> 00:02:57,829
a really strange language that I'm not

00:02:54,260 --> 00:03:01,159
even going to mention to me at some

00:02:57,829 --> 00:03:06,919
point that's when the legal language got

00:03:01,159 --> 00:03:10,069
a huge new version 5.0 and huge because

00:03:06,919 --> 00:03:15,290
it really is so many of things like or

00:03:10,069 --> 00:03:24,980
laws that do it but range for us then

00:03:15,290 --> 00:03:29,120
you get it because the promise was that

00:03:24,980 --> 00:03:31,819
most of these things this really needs

00:03:29,120 --> 00:03:34,519
to be the compiler itself so they needed

00:03:31,819 --> 00:03:36,139
to get a new version of the language in

00:03:34,519 --> 00:03:38,599
the version of the standard to implement

00:03:36,139 --> 00:03:46,209
a compiler or something functional

00:03:38,599 --> 00:03:50,329
programming could be done just in C++ we

00:03:46,209 --> 00:03:53,329
cared higher-order functions in some

00:03:50,329 --> 00:03:56,599
sense within calendars but we canít see

00:03:53,329 --> 00:03:59,419
cygnus puzzles initially standard since

00:03:56,599 --> 00:04:02,150
it was passed 98 which tell the Africans

00:03:59,419 --> 00:04:04,310
all the algorithms that most guarantees

00:04:02,150 --> 00:04:04,879
accept functional spirit gates or

00:04:04,310 --> 00:04:07,280
something

00:04:04,879 --> 00:04:11,580
and some wouldn't even return a function

00:04:07,280 --> 00:04:15,700
like as we divide four as equals

00:04:11,580 --> 00:04:19,359
my second tier 1 Club cold environments

00:04:15,700 --> 00:04:22,510
and ceilings and instead of the range

00:04:19,359 --> 00:04:26,080
for record of do is adjust for each or

00:04:22,510 --> 00:04:28,660
whose courage and he just implemented

00:04:26,080 --> 00:04:31,900
the same thing as the evil language meet

00:04:28,660 --> 00:04:34,390
but on the light level so we got a

00:04:31,900 --> 00:04:38,320
single chamber to come back and that's

00:04:34,390 --> 00:04:40,600
why I started investigating functional

00:04:38,320 --> 00:04:43,210
programming because things like things I

00:04:40,600 --> 00:04:56,290
love to extend the language of their

00:04:43,210 --> 00:05:01,900
direction and obviously the cooperator

00:04:56,290 --> 00:05:04,840
it can be cold so if it works like a

00:05:01,900 --> 00:05:07,450
darkened most likely that means that if

00:05:04,840 --> 00:05:10,440
you can close something like in the same

00:05:07,450 --> 00:05:14,080
way to call a function it's a function

00:05:10,440 --> 00:05:16,450
so the first level in the evolution of

00:05:14,080 --> 00:05:21,669
functional programming programmer is

00:05:16,450 --> 00:05:23,669
near use so just use the tools that

00:05:21,669 --> 00:05:28,210
you're given in a completely

00:05:23,669 --> 00:05:32,560
understandable way so the first thing

00:05:28,210 --> 00:05:37,220
that I started playing around is the

00:05:32,560 --> 00:05:40,220
laser ablation so suppose for 34,000

00:05:37,220 --> 00:05:42,610
the idea is example just imagine you

00:05:40,220 --> 00:05:45,620
hear that it's really expensive to

00:05:42,610 --> 00:05:48,830
calculate like the answer to the meaning

00:05:45,620 --> 00:05:51,410
of life and everything and you don't

00:05:48,830 --> 00:05:53,150
always need the answer in some branches

00:05:51,410 --> 00:05:56,300
you know maybe it is some grantees you

00:05:53,150 --> 00:05:58,520
don't and you can create a chain of if

00:05:56,300 --> 00:06:00,050
else statements that you can create a

00:05:58,520 --> 00:06:03,289
function of something else you could

00:06:00,050 --> 00:06:05,210
look other instead you can just extend

00:06:03,289 --> 00:06:08,120
the language to support a new keyword

00:06:05,210 --> 00:06:11,419
called lazy open brackets both brackets

00:06:08,120 --> 00:06:13,400
and you just define how the value should

00:06:11,419 --> 00:06:16,789
be calculated easiest needs to be

00:06:13,400 --> 00:06:20,960
accomplished and this is compatibility

00:06:16,789 --> 00:06:23,539
with us this comparison works back up so

00:06:20,960 --> 00:06:26,270
the first step is your Creator is there

00:06:23,539 --> 00:06:29,180
a function of it it's called lazy well

00:06:26,270 --> 00:06:30,979
as an implementation it is going to get

00:06:29,180 --> 00:06:33,470
the function of the clip the template

00:06:30,979 --> 00:06:37,210
parameter and it is going to store that

00:06:33,470 --> 00:06:37,210
function project as

00:06:39,780 --> 00:06:46,380
in taxes because needs to be defined a

00:06:43,530 --> 00:06:50,460
cast operator to the result type of the

00:06:46,380 --> 00:06:53,340
function that we got so if you define

00:06:50,460 --> 00:06:55,200
the lazy well and pass it a function it

00:06:53,340 --> 00:06:57,720
will extract the return type of that

00:06:55,200 --> 00:07:00,360
function and it will create a casting

00:06:57,720 --> 00:07:03,180
operator to the stack as soon as you

00:07:00,360 --> 00:07:06,030
want to get this value their trade it

00:07:03,180 --> 00:07:14,930
will be calculated cash inside plays

00:07:06,030 --> 00:07:17,430
well and since okay before C++ seventy

00:07:14,930 --> 00:07:20,550
every time we care the templates class

00:07:17,430 --> 00:07:24,030
we need to create to me blah blahs

00:07:20,550 --> 00:07:26,820
function because the template recommends

00:07:24,030 --> 00:07:29,400
deduction for classes fortunately Lisa

00:07:26,820 --> 00:07:33,150
speaks games it was plus 70 but we could

00:07:29,400 --> 00:07:35,280
have created email a civil action and we

00:07:33,150 --> 00:07:37,890
could call its legs but this is you

00:07:35,280 --> 00:07:41,880
fight on the first slide that I showed

00:07:37,890 --> 00:07:43,850
us we were lazy and when we want to

00:07:41,880 --> 00:07:49,100
define nuclear arsenal

00:07:43,850 --> 00:07:53,000
we use metrics just like you to does

00:07:49,100 --> 00:07:55,400
everything impurities macro so here it

00:07:53,000 --> 00:07:59,810
can you find a really really simple

00:07:55,400 --> 00:08:02,570
macro so a structure called me lazy lot

00:07:59,810 --> 00:08:07,760
number that will just define the

00:08:02,570 --> 00:08:13,520
operator - does anybody have problems

00:08:07,760 --> 00:08:15,410
with this code this is really evil so in

00:08:13,520 --> 00:08:17,540
the previous slide we can make lazy

00:08:15,410 --> 00:08:21,110
valid we can cut too many friends

00:08:17,540 --> 00:08:23,800
immediate records how can we remove a

00:08:21,110 --> 00:08:26,120
single parenthesis from a function call

00:08:23,800 --> 00:08:28,700
very placing that function with an

00:08:26,120 --> 00:08:31,040
operator because then you call an

00:08:28,700 --> 00:08:35,030
operator you don't actually need to open

00:08:31,040 --> 00:08:40,310
break it right so we're going to replace

00:08:35,030 --> 00:08:41,270
the function ago it reminds because so

00:08:40,310 --> 00:08:45,080
for some reason

00:08:41,270 --> 00:08:49,220
operator - is his favorite I decided to

00:08:45,080 --> 00:08:52,970
concert so what is the idea we share the

00:08:49,220 --> 00:08:55,760
lazy object and we share the operator -

00:08:52,970 --> 00:08:59,240
so there we pass to the operator - will

00:08:55,760 --> 00:09:03,470
be the function the lazy calculation

00:08:59,240 --> 00:09:09,830
right and we just need to create a macro

00:09:03,470 --> 00:09:17,390
that expense - - and so on and after

00:09:09,830 --> 00:09:20,510
that we can normally just what can you

00:09:17,390 --> 00:09:25,510
do it will create a helper instance

00:09:20,510 --> 00:09:25,510
damage kill right - create one together

00:09:26,700 --> 00:09:33,370
and this is the abuse part and I guess

00:09:31,000 --> 00:09:35,830
it's like Oh miss lights yes use your

00:09:33,370 --> 00:09:40,300
using the language for something that is

00:09:35,830 --> 00:09:40,960
focusing not initially münster too

00:09:40,300 --> 00:09:43,840
beautiful

00:09:40,960 --> 00:09:47,410
but fortunately we share the evil macros

00:09:43,840 --> 00:09:52,150
and he kept the operating table using as

00:09:47,410 --> 00:09:54,700
much as we wanted and apart from the

00:09:52,150 --> 00:09:57,720
fact that this is really an evil thing

00:09:54,700 --> 00:10:07,120
to implement in this way it's really

00:09:57,720 --> 00:10:10,870
just like for each library feature so

00:10:07,120 --> 00:10:15,550
the next step was again so I can improve

00:10:10,870 --> 00:10:19,420
my moment but it's still not functional

00:10:15,550 --> 00:10:23,490
program okay active lazy but that's just

00:10:19,420 --> 00:10:23,490
one single part of gospel

00:10:26,560 --> 00:10:33,550
the main benefit from our program is

00:10:30,370 --> 00:10:43,029
that it's people who love that he

00:10:33,550 --> 00:10:47,949
claimed to be right so it seeks this

00:10:43,029 --> 00:10:50,560
moment very simple was asked to write

00:10:47,949 --> 00:10:54,579
the program directly the frequencies of

00:10:50,560 --> 00:11:00,880
births and rights of animals human

00:10:54,579 --> 00:11:01,660
subjects and the guy wrote a solution 10

00:11:00,880 --> 00:11:03,850
pages long

00:11:01,660 --> 00:11:07,630
it was extremely well documented

00:11:03,850 --> 00:11:13,569
beautiful code with no data structure

00:11:07,630 --> 00:11:18,149
this key created just for and after that

00:11:13,569 --> 00:11:21,370
the ASEAN Journal used to ask somebody

00:11:18,149 --> 00:11:29,290
from the audience against some really

00:11:21,370 --> 00:11:32,410
famous decided to give a critique of and

00:11:29,290 --> 00:11:40,750
obviously when you get too big documents

00:11:32,410 --> 00:11:43,689
what you need to do and that material

00:11:40,750 --> 00:11:49,000
just sent the response with six lines of

00:11:43,689 --> 00:11:52,290
UNIX shell scripts so ten pages of unit

00:11:49,000 --> 00:11:55,689
with documented possible addresses six

00:11:52,290 --> 00:12:02,980
lines or clinics trusted honestly this

00:11:55,689 --> 00:12:05,980
wasn't as efficient as just it fits on

00:12:02,980 --> 00:12:08,220
one slide and it's almost 3w marketing

00:12:05,980 --> 00:12:08,220
show

00:12:08,950 --> 00:12:15,459
during shell and the pipes are really

00:12:12,670 --> 00:12:17,320
the functional concept you share input

00:12:15,459 --> 00:12:19,690
then you define a series of

00:12:17,320 --> 00:12:22,180
transformations which you want to apply

00:12:19,690 --> 00:12:24,610
to the input and you get the result so

00:12:22,180 --> 00:12:27,370
the function apply a function by

00:12:24,610 --> 00:12:30,010
function you get result no teaching

00:12:27,370 --> 00:12:33,820
about for loops where should I store the

00:12:30,010 --> 00:12:35,680
variables or anything else in C++ this

00:12:33,820 --> 00:12:44,840
is obviously not going to be else

00:12:35,680 --> 00:12:47,929
shortages this example that is because

00:12:44,840 --> 00:12:47,929
[Music]

00:12:54,120 --> 00:13:01,779
there is a huge problem with standard

00:12:57,370 --> 00:13:04,089
algorithms and the problem is that all

00:13:01,779 --> 00:13:06,880
the algorithms receive iterator pairs

00:13:04,089 --> 00:13:11,139
return one iterator which is not really

00:13:06,880 --> 00:13:15,010
composable or possibly a little bit

00:13:11,139 --> 00:13:17,860
different way than what you do so for

00:13:15,010 --> 00:13:20,920
example if you wanted to filter out the

00:13:17,860 --> 00:13:23,740
collection and then sort the remaining

00:13:20,920 --> 00:13:26,380
items you need to create a temporary

00:13:23,740 --> 00:13:28,660
fracture to watch the filtered items

00:13:26,380 --> 00:13:31,930
then we're going to sort it dangle going

00:13:28,660 --> 00:13:35,199
to return and that's not on some program

00:13:31,930 --> 00:13:36,770
works you should never be forced to

00:13:35,199 --> 00:13:40,070
create a penguin

00:13:36,770 --> 00:13:41,690
we don't need to force the compiler and

00:13:40,070 --> 00:13:45,800
explain what the enemy the traffic

00:13:41,690 --> 00:13:48,170
manually so the ranges should solve the

00:13:45,800 --> 00:13:51,170
problem with algorithms by just

00:13:48,170 --> 00:13:53,720
essentially joining two iterators into a

00:13:51,170 --> 00:13:56,620
single magnetic motor range this is a

00:13:53,720 --> 00:14:00,740
little bit of Hawaiian word trust

00:13:56,620 --> 00:14:02,570
so the idea is that if you have a range

00:14:00,740 --> 00:14:05,570
you can pass it through a transformation

00:14:02,570 --> 00:14:07,100
it will return the range then you can

00:14:05,570 --> 00:14:08,779
pass it to something else then you can

00:14:07,100 --> 00:14:13,700
pass it to something else you don't meet

00:14:08,779 --> 00:14:19,580
always to keep iterating and how would

00:14:13,700 --> 00:14:23,779
you deal with the problem you can add X

00:14:19,580 --> 00:14:27,440
it's a range of characters so it's some

00:14:23,779 --> 00:14:29,390
beta what can you do with it you can

00:14:27,440 --> 00:14:32,420
replace all the special characters

00:14:29,390 --> 00:14:36,709
common spaces and also a better chance

00:14:32,420 --> 00:14:39,709
to denote in the world and you can do it

00:14:36,709 --> 00:14:42,920
we all know the standard algorithm of

00:14:39,709 --> 00:14:46,370
transform the other c'mon ranges does

00:14:42,920 --> 00:14:48,649
essentially the same part amazing and

00:14:46,370 --> 00:14:51,440
just provides of you it doesn't actually

00:14:48,649 --> 00:14:54,500
transforming it's just a few or the

00:14:51,440 --> 00:14:56,990
original data when you progress through

00:14:54,500 --> 00:15:02,779
the route of you each will calculate

00:14:56,990 --> 00:15:04,790
each item in the next step because we

00:15:02,779 --> 00:15:09,700
want to count friends we don't want to

00:15:04,790 --> 00:15:12,589
be dealing with Explorer is so American

00:15:09,700 --> 00:15:14,400
again this stuff doesn't do anything

00:15:12,589 --> 00:15:16,890
it's just reading and

00:15:14,400 --> 00:15:21,870
you or the old view or the data

00:15:16,890 --> 00:15:25,400
something that I do realize anybody cool

00:15:21,870 --> 00:15:33,840
who wants the devil kicker and who likes

00:15:25,400 --> 00:15:36,120
excellence the next step we cleaned out

00:15:33,840 --> 00:15:38,610
the data so now we need to exit the

00:15:36,120 --> 00:15:42,570
roads we can just speak the original

00:15:38,610 --> 00:15:45,540
collection over the exercise and you get

00:15:42,570 --> 00:15:47,610
a range of words again still notice

00:15:45,540 --> 00:15:50,610
relational tablets this is again just

00:15:47,610 --> 00:15:53,760
the view you still have the original

00:15:50,610 --> 00:15:59,070
data structure very original collection

00:15:53,760 --> 00:16:02,430
and a couple of unique minds of it after

00:15:59,070 --> 00:16:06,600
that we want to sort it grouped all the

00:16:02,430 --> 00:16:09,360
same birds after sorting grouping just

00:16:06,600 --> 00:16:12,980
transform keep the world any stopped

00:16:09,360 --> 00:16:12,980
keep the world in except

00:16:17,720 --> 00:16:24,079
and then again sort so that we sort of

00:16:20,689 --> 00:16:27,139
like frequencies reversely the sort will

00:16:24,079 --> 00:16:29,839
so from one to the maximum instead of

00:16:27,139 --> 00:16:32,620
maximum one and then take as many

00:16:29,839 --> 00:16:36,379
results as we want

00:16:32,620 --> 00:16:40,790
most of these transformations are just

00:16:36,379 --> 00:16:43,310
music so if you don't actually evaluate

00:16:40,790 --> 00:16:44,569
anything from them they will never

00:16:43,310 --> 00:16:47,060
execute any code

00:16:44,569 --> 00:16:49,279
the only difference affirmation is

00:16:47,060 --> 00:16:51,079
sorting because if you want to tell a

00:16:49,279 --> 00:16:53,660
certain collection you actually have to

00:16:51,079 --> 00:16:59,810
access of the other feature which is the

00:16:53,660 --> 00:17:05,510
minimum and so if their business library

00:16:59,810 --> 00:17:10,390
wasn't a little bit designed this would

00:17:05,510 --> 00:17:14,839
be impossible

00:17:10,390 --> 00:17:18,079
so to recap we can the data we came up

00:17:14,839 --> 00:17:22,579
the data with separates all the words

00:17:18,079 --> 00:17:25,699
sort the words then group by group all

00:17:22,579 --> 00:17:28,309
the same words into range of ranges and

00:17:25,699 --> 00:17:34,700
then comes through each of the words how

00:17:28,309 --> 00:17:36,950
many times it appears now this is less

00:17:34,700 --> 00:17:38,049
efficient when it can be we could use a

00:17:36,950 --> 00:17:49,619
hash map

00:17:38,049 --> 00:18:05,710
by bucks and this is the source of this

00:17:49,619 --> 00:18:07,899
on you and so the next step obviously

00:18:05,710 --> 00:18:11,200
when you start shortening out your ghost

00:18:07,899 --> 00:18:14,590
then you clear about his people purity

00:18:11,200 --> 00:18:17,679
or Univision and then you try to think

00:18:14,590 --> 00:18:20,019
of okay if like cannot change a single

00:18:17,679 --> 00:18:22,480
value in my program of immigration and

00:18:20,019 --> 00:18:25,570
useful then it's something that is

00:18:22,480 --> 00:18:28,539
really hard to record at around the

00:18:25,570 --> 00:18:31,720
first time you see it and I'm probably

00:18:28,539 --> 00:18:40,289
not going to help you but maybe to be

00:18:31,720 --> 00:18:40,289
interesting enough for you to so if you

00:18:41,149 --> 00:18:47,989
fancy but the problem with probe instead

00:18:44,349 --> 00:18:53,749
there's a real nice quote by John

00:18:47,989 --> 00:18:56,029
conical don't think he said that it's

00:18:53,749 --> 00:18:58,549
really difficult for us to think of all

00:18:56,029 --> 00:19:01,039
the states that are cotton candy and

00:18:58,549 --> 00:19:01,479
it's especially difficult when dinner's

00:19:01,039 --> 00:19:04,849
ready

00:19:01,479 --> 00:19:07,639
so the fact that we have a mutable state

00:19:04,849 --> 00:19:10,700
which can can be invalid in some cases

00:19:07,639 --> 00:19:14,989
village we need to control what locks

00:19:10,700 --> 00:19:19,009
button but it's if you don't want to

00:19:14,989 --> 00:19:22,159
care about locking the mutexes which

00:19:19,009 --> 00:19:24,619
have to have immutable data if you can

00:19:22,159 --> 00:19:26,839
exchange data we don't care if ten

00:19:24,619 --> 00:19:31,969
different people accessing at the same

00:19:26,839 --> 00:19:35,779
time so just a simple function like this

00:19:31,969 --> 00:19:39,019
one just a lot of side effects so when

00:19:35,779 --> 00:19:43,059
the user clicks or something what

00:19:39,019 --> 00:19:47,649
happens visible form becomes visible

00:19:43,059 --> 00:19:51,710
after that the data needs to be loaded

00:19:47,649 --> 00:19:54,979
then we are connected to the database to

00:19:51,710 --> 00:19:58,129
be able to show in the in the form and

00:19:54,979 --> 00:20:01,279
then when the user clicks something or

00:19:58,129 --> 00:20:05,629
changes starting in the fall in

00:20:01,279 --> 00:20:21,899
and this is becoming a little bit over

00:20:05,629 --> 00:20:58,109
complex for example if you want

00:20:21,899 --> 00:21:03,599
something you should ask this is this is

00:20:58,109 --> 00:21:06,599
the thing it is from the best clothes

00:21:03,599 --> 00:21:12,149
all of us who write for loops and the

00:21:06,599 --> 00:21:14,159
usual usual programs to be procedural

00:21:12,149 --> 00:21:16,079
developers the fact that we are using

00:21:14,159 --> 00:21:18,839
classes and everything we are the most

00:21:16,079 --> 00:21:22,320
using classes for data is a data

00:21:18,839 --> 00:21:24,209
container with some validation we still

00:21:22,320 --> 00:21:31,499
are not speaking them in the same way

00:21:24,209 --> 00:21:35,129
that object-oriented for example if we

00:21:31,499 --> 00:21:38,669
want to create a class for the dog we

00:21:35,129 --> 00:21:41,729
would first create getter what is the

00:21:38,669 --> 00:21:43,390
height of a dog we would create a setter

00:21:41,729 --> 00:21:45,940
but

00:21:43,390 --> 00:21:48,940
then we will create butter the power set

00:21:45,940 --> 00:21:52,750
what is the color and single stuff if

00:21:48,940 --> 00:21:56,290
you give a real low-key metallics okay

00:21:52,750 --> 00:21:59,170
your height is now 12 centimeters your

00:21:56,290 --> 00:22:00,400
fight is non zero height is now I don't

00:21:59,170 --> 00:22:03,400
know two meters

00:22:00,400 --> 00:22:06,910
no you have to change something that is

00:22:03,400 --> 00:22:08,950
incorporated into the goal you can feel

00:22:06,910 --> 00:22:12,070
it you can feel it you can feel okay it

00:22:08,950 --> 00:22:15,610
will grow up but you can't tell and now

00:22:12,070 --> 00:22:18,490
your tower is a very it's actually the

00:22:15,610 --> 00:22:21,240
objects if you want object thinking you

00:22:18,490 --> 00:22:25,210
shouldn't be designed them too simple

00:22:21,240 --> 00:22:27,640
and that's something that really goes

00:22:25,210 --> 00:22:29,620
well the function programming and all

00:22:27,640 --> 00:22:33,520
these words are actually from motoring

00:22:29,620 --> 00:22:36,390
people not from ft so besides that

00:22:33,520 --> 00:22:39,790
everything you believe directly together

00:22:36,390 --> 00:22:42,570
so even articulate in development will

00:22:39,790 --> 00:22:42,570
read at some

00:22:44,320 --> 00:22:49,970
this is the way we usually think about

00:22:47,419 --> 00:22:55,970
the world if you want to change

00:22:49,970 --> 00:22:58,549
something change if you want to declare

00:22:55,970 --> 00:23:02,029
the world immutable you cannot change

00:22:58,549 --> 00:23:09,019
distances on the road and this is

00:23:02,029 --> 00:23:13,120
something that will be covered in every

00:23:09,019 --> 00:23:13,120
action that we take doesn't change

00:23:15,840 --> 00:23:21,289
[Music]

00:23:19,179 --> 00:23:24,110
whenever you want to change something

00:23:21,289 --> 00:23:25,970
you shouldn't change this world but you

00:23:24,110 --> 00:23:29,620
should create a new world with depth

00:23:25,970 --> 00:23:33,470
change the void in that way if somebody

00:23:29,620 --> 00:23:36,470
still has if some of the students in the

00:23:33,470 --> 00:23:39,230
old world it can continue living in yoga

00:23:36,470 --> 00:23:41,659
nothing else has changed no new Texan is

00:23:39,230 --> 00:23:45,019
no data mutable data sharing not nothing

00:23:41,659 --> 00:23:47,149
if you create a new mutable variant each

00:23:45,019 --> 00:23:50,179
will again never be changed after that

00:23:47,149 --> 00:23:52,000
everybody who uses that one will always

00:23:50,179 --> 00:23:55,759
see the persistent age

00:23:52,000 --> 00:23:59,210
ok so you can imagine something that

00:23:55,759 --> 00:24:04,399
begins all the previous revisions in

00:23:59,210 --> 00:24:07,250
give high radon and the new revision the

00:24:04,399 --> 00:24:12,429
to create is the new world if somebody

00:24:07,250 --> 00:24:12,429
still use with your master changes

00:24:14,970 --> 00:24:20,370
but the problem is that creating the

00:24:17,340 --> 00:24:22,620
world's is expensive both always go up

00:24:20,370 --> 00:24:24,630
in the data the copying copying the

00:24:22,620 --> 00:24:27,000
Cobra adjust the change mom we would

00:24:24,630 --> 00:24:28,830
think it is going to be really

00:24:27,000 --> 00:24:32,070
inefficient if you are using the normal

00:24:28,830 --> 00:24:35,850
data structures the first thing that you

00:24:32,070 --> 00:24:38,160
can do is just to this allow copy then

00:24:35,850 --> 00:24:42,180
for the compiler to force adjust the use

00:24:38,160 --> 00:24:44,820
moves it will be legal because when you

00:24:42,180 --> 00:24:48,540
move from a command object if you are

00:24:44,820 --> 00:24:53,270
using it after that is undefended

00:24:48,540 --> 00:24:53,270
so again there will be no data sharing

00:24:53,300 --> 00:25:00,270
but again this is just the syntax how do

00:24:58,230 --> 00:25:07,080
you forbid somebody from talking the

00:25:00,270 --> 00:25:08,420
other and what is right but again this

00:25:07,080 --> 00:25:12,150
is not the point

00:25:08,420 --> 00:25:14,940
this is something that would force your

00:25:12,150 --> 00:25:18,030
compiler to essentially force you to

00:25:14,940 --> 00:25:20,930
think about changing the world but it's

00:25:18,030 --> 00:25:23,670
not what is usually done in acting

00:25:20,930 --> 00:25:26,190
instead of using normal data collections

00:25:23,670 --> 00:25:28,230
you want to use persistent medical

00:25:26,190 --> 00:25:32,190
collections so collections that are

00:25:28,230 --> 00:25:35,330
really extremely cheap to copy extremely

00:25:32,190 --> 00:25:39,420
cheap to copy be the notification and

00:25:35,330 --> 00:25:41,600
mountain I guess most importantly which

00:25:39,420 --> 00:25:41,600
is

00:25:42,620 --> 00:25:49,730
is that at some point the the older

00:25:46,669 --> 00:25:52,070
bottle said this he doesn't see any

00:25:49,730 --> 00:25:55,480
point in comes on trend because how can

00:25:52,070 --> 00:25:59,270
I do anything if I can exchange a single

00:25:55,480 --> 00:26:01,429
single value and he's working on Twitter

00:25:59,270 --> 00:26:04,429
the direction vector to function and

00:26:01,429 --> 00:26:11,779
then the reason why I like to mention is

00:26:04,429 --> 00:26:16,120
the example because a similar problem so

00:26:11,779 --> 00:26:18,620
how do the system data structures work

00:26:16,120 --> 00:26:20,270
first we will start with the list which

00:26:18,620 --> 00:26:22,220
is the world data structure that there

00:26:20,270 --> 00:26:25,250
are two can imagine but is the simplest

00:26:22,220 --> 00:26:27,500
one to explain it which level is and you

00:26:25,250 --> 00:26:30,649
promise never to change this instance of

00:26:27,500 --> 00:26:36,890
it what is all this when you abandon

00:26:30,649 --> 00:26:40,820
items you can see always you get a

00:26:36,890 --> 00:26:44,059
pointer to just the newel element which

00:26:40,820 --> 00:26:46,610
points for the always so the cop is

00:26:44,059 --> 00:26:51,279
extremely cheap the program still can

00:26:46,610 --> 00:26:51,279
join the program scale is the new

00:27:02,420 --> 00:27:13,110
if she wants to remove it again to the

00:27:10,290 --> 00:27:16,460
second element in Arizona again the date

00:27:13,110 --> 00:27:18,510
is being shared really good efficient

00:27:16,460 --> 00:27:21,570
appending is the problem

00:27:18,510 --> 00:27:23,430
you can't just a fantasy single item

00:27:21,570 --> 00:27:25,110
because it would change all the previous

00:27:23,430 --> 00:27:27,060
visits and we promised never to change

00:27:25,110 --> 00:27:30,750
and your phone

00:27:27,060 --> 00:27:33,840
so instead if you want to append to list

00:27:30,750 --> 00:27:37,470
we will need to actually copy of the

00:27:33,840 --> 00:27:40,620
data and this is what the reasons why

00:27:37,470 --> 00:27:43,730
lists are real clear that the obviously

00:27:40,620 --> 00:27:51,840
the first is the test authorization

00:27:43,730 --> 00:27:55,020
lists are validation and the problem is

00:27:51,840 --> 00:27:58,170
that most of the useful functions for

00:27:55,020 --> 00:28:01,680
this are just totally imitation just

00:27:58,170 --> 00:28:09,750
tree bending and removing from the start

00:28:01,680 --> 00:28:11,190
irradiation everything else is so a lot

00:28:09,750 --> 00:28:13,110
of functional programming programming

00:28:11,190 --> 00:28:15,990
languages are based on bases and

00:28:13,110 --> 00:28:21,930
obviously there are little bit slower

00:28:15,990 --> 00:28:24,120
because something studies desiccating no

00:28:21,930 --> 00:28:28,800
data structures and one of the data

00:28:24,120 --> 00:28:33,780
structures which are going to give

00:28:28,800 --> 00:28:36,530
yourself about big map directory is we

00:28:33,780 --> 00:28:36,530
want to create

00:28:36,750 --> 00:28:43,890
[Music]

00:28:46,070 --> 00:28:51,019
[Music]

00:29:07,470 --> 00:29:10,950
[Music]

00:29:13,390 --> 00:29:16,499
[Music]

00:29:26,490 --> 00:29:33,340
[Music]

00:29:29,070 --> 00:29:35,380
you will create a new budget again when

00:29:33,340 --> 00:29:38,410
you assess the first element the whole

00:29:35,380 --> 00:29:40,800
budget will go into the cash so it still

00:29:38,410 --> 00:29:44,050
just friendly even if we have two bodies

00:29:40,800 --> 00:29:47,230
but not two packets we need to be able

00:29:44,050 --> 00:29:51,520
to actually charge so we are going to

00:29:47,230 --> 00:29:56,050
create another level on top which points

00:29:51,520 --> 00:30:00,340
to the balance again the level above

00:29:56,050 --> 00:30:02,500
will also be a positive collection so

00:30:00,340 --> 00:30:05,590
it's not an infinite collection in the

00:30:02,500 --> 00:30:06,290
top level as well again each other

00:30:05,590 --> 00:30:09,510
it's

00:30:06,290 --> 00:30:09,510
[Music]

00:30:11,120 --> 00:30:23,880
then if you just keep any ma you're just

00:30:15,030 --> 00:30:26,490
going to get in this like all buckets

00:30:23,880 --> 00:30:27,960
share the xylophone which is definitely

00:30:26,490 --> 00:30:30,690
not to say that you weren't using

00:30:27,960 --> 00:30:35,040
production usually if you're the size of

00:30:30,690 --> 00:30:41,490
32 which makes the tallest tree will be

00:30:35,040 --> 00:30:44,250
around six or seven seven eight and a

00:30:41,490 --> 00:30:47,910
lot of scientists consider this to be

00:30:44,250 --> 00:30:49,650
not only effectively of something

00:30:47,910 --> 00:30:52,830
because it's a constant

00:30:49,650 --> 00:30:58,590
you never go above seven times or

00:30:52,830 --> 00:31:01,770
something it's just something so what

00:30:58,590 --> 00:31:04,100
the expense of appending an item to this

00:31:01,770 --> 00:31:04,100
collection

00:31:16,950 --> 00:31:22,310
so the number of layers meant

00:31:23,990 --> 00:31:34,620
which is of opinion to this collection

00:31:28,980 --> 00:31:37,290
is the same as appending to director not

00:31:34,620 --> 00:31:40,350
the question is we want to share with

00:31:37,290 --> 00:31:42,960
issues indexing as well because lectures

00:31:40,350 --> 00:31:45,120
if you should be indexing how can we

00:31:42,960 --> 00:31:47,910
index all the items in the collection

00:31:45,120 --> 00:31:51,420
because the buckets kept the size that

00:31:47,910 --> 00:31:54,660
is power of two we can use the bitmap

00:31:51,420 --> 00:31:58,410
representation or the illness is the key

00:31:54,660 --> 00:32:02,070
which item individual level recipe so

00:31:58,410 --> 00:32:07,470
for example we have the number 40 which

00:32:02,070 --> 00:32:12,630
is 0 0 1 1 0 in detail 3 layers of our

00:32:07,470 --> 00:32:16,320
sewage leaking chunk the pavement with

00:32:12,630 --> 00:32:19,800
representation beyond 0 0 it will be the

00:32:16,320 --> 00:32:22,050
index in the first in the top level then

00:32:19,800 --> 00:32:29,130
we have 1 bar which we have which is the

00:32:22,050 --> 00:32:32,460
index in the the third element then

00:32:29,130 --> 00:32:34,890
going to the last one the Venus is 1 0

00:32:32,460 --> 00:32:38,460
then we have access to the challenge

00:32:34,890 --> 00:32:42,540
within export 13 ok what is the

00:32:38,460 --> 00:32:59,580
complexity the complexity is

00:32:42,540 --> 00:33:02,310
never the next step is so far we have

00:32:59,580 --> 00:33:04,830
considered on the mutating the original

00:33:02,310 --> 00:33:07,800
structure we didn't talk about how to

00:33:04,830 --> 00:33:14,970
make them resistant so all the previous

00:33:07,800 --> 00:33:18,150
versions if you look at this picture and

00:33:14,970 --> 00:33:23,600
we have appended P what are the loads

00:33:18,150 --> 00:33:23,600
that have changed in the original tree

00:33:27,410 --> 00:33:35,130
to us just the path to the item that we

00:33:31,770 --> 00:33:37,800
appended in the last one as well even if

00:33:35,130 --> 00:33:41,070
we create the new route the only items

00:33:37,800 --> 00:33:45,270
descriptions are the nodes in the bus or

00:33:41,070 --> 00:33:50,370
the meter inside which means that all

00:33:45,270 --> 00:33:52,380
the other items can be any shape so

00:33:50,370 --> 00:33:55,800
every time that you have been something

00:33:52,380 --> 00:33:59,770
you just need to create a new path but

00:33:55,800 --> 00:34:02,420
yeah what is the complexity of because

00:33:59,770 --> 00:34:08,810
[Music]

00:34:02,420 --> 00:34:08,810
and similar for offending pretending

00:34:17,600 --> 00:34:21,010
it's not fun in the picture

00:34:28,679 --> 00:34:33,419
what it doesn't matter because if you

00:34:31,770 --> 00:34:35,639
wants to pretend something you're going

00:34:33,419 --> 00:34:37,850
to depend a full budget and then you'll

00:34:35,639 --> 00:34:43,110
screw up all the indexes

00:34:37,850 --> 00:34:47,639
43:32 Orgrimmar the optimizations which

00:34:43,110 --> 00:34:49,679
do things that but in initial initial

00:34:47,639 --> 00:34:53,520
state you are showing if you want to

00:34:49,679 --> 00:34:55,800
insert and elements to the front you

00:34:53,520 --> 00:34:58,470
have the same complexity like that is

00:34:55,800 --> 00:35:01,050
the director so if you'll be all you

00:34:58,470 --> 00:35:08,460
need to create a new one with all the

00:35:01,050 --> 00:35:11,000
data mode yeah

00:35:08,460 --> 00:35:14,760
there are different approaches to

00:35:11,000 --> 00:35:18,300
creating efficient insertions in the

00:35:14,760 --> 00:35:24,690
middle to the top combinations and

00:35:18,300 --> 00:35:27,660
everything else which essentially the

00:35:24,690 --> 00:35:30,180
structure is strong is completely blank

00:35:27,660 --> 00:35:32,880
by one there's complexities conservative

00:35:30,180 --> 00:35:35,910
estimate if you want to transition

00:35:32,880 --> 00:35:38,220
concatenation you can either add the

00:35:35,910 --> 00:35:39,630
offset for the first element there's

00:35:38,220 --> 00:35:43,050
also something that is called the

00:35:39,630 --> 00:35:45,990
relaxed that did not factor 3 which is

00:35:43,050 --> 00:35:48,450
the evil structure that's really cool is

00:35:45,990 --> 00:35:51,270
that not sharing a packet containing

00:35:48,450 --> 00:35:52,950
just the elements the first time it can

00:35:51,270 --> 00:35:55,560
be a special one that does something

00:35:52,950 --> 00:35:59,700
special but this the more that

00:35:55,560 --> 00:36:03,030
recommended to say anytime essentially

00:35:59,700 --> 00:36:05,130
the first icon should point Joe index is

00:36:03,030 --> 00:36:07,920
starting indexes of all the packets

00:36:05,130 --> 00:36:13,680
child bands and that's something that

00:36:07,920 --> 00:36:17,840
currently so how encoder USB sync with

00:36:13,680 --> 00:36:32,000
the stock offset they Scout should

00:36:17,840 --> 00:36:35,840
the relaxed version so if we compare

00:36:32,000 --> 00:36:40,640
this to a vector the nice indexes of

00:36:35,840 --> 00:36:45,860
fantastic vector appending is for fun

00:36:40,640 --> 00:36:48,890
just like updating values since we have

00:36:45,860 --> 00:36:52,760
the direct line so any index we can

00:36:48,890 --> 00:36:55,810
efficiently so it's also given in the

00:36:52,760 --> 00:37:02,620
unit of a personal prepending

00:36:55,810 --> 00:37:02,620
concatenation and obviously if you don't

00:37:05,230 --> 00:37:12,950
focus it for more information about

00:37:08,570 --> 00:37:16,030
getting started one of the best it's a

00:37:12,950 --> 00:37:21,860
really colorful but is still the book

00:37:16,030 --> 00:37:24,819
this is written by it was his this is at

00:37:21,860 --> 00:37:29,900
some point and expenditure

00:37:24,819 --> 00:37:33,230
so let's just return to this for a bit

00:37:29,900 --> 00:37:35,630
most of the data is look light so it's

00:37:33,230 --> 00:37:37,430
definitely it's a vector like structure

00:37:35,630 --> 00:37:40,970
that it does the same thing as the

00:37:37,430 --> 00:37:46,480
vector Vasquez green coffee bean

00:37:40,970 --> 00:37:46,480
pigmentation so it's even better than

00:37:53,170 --> 00:38:01,579
essentially the problem with it is that

00:37:56,470 --> 00:38:23,539
even if it's one it's seven times so you

00:38:01,579 --> 00:38:33,400
are going to get access but the

00:38:23,539 --> 00:38:33,400
benchmark against the four same amount

00:38:33,610 --> 00:38:41,350
the bars were really really rude so it

00:38:38,230 --> 00:38:45,430
wasn't it's really it's implemented in a

00:38:41,350 --> 00:38:53,560
really nice trade and organization of

00:38:45,430 --> 00:38:56,200
the day and that's it the last time is

00:38:53,560 --> 00:38:58,440
obviously shame accept self-promotion

00:38:56,200 --> 00:38:58,440

YouTube URL: https://www.youtube.com/watch?v=NIwc5xORHew


