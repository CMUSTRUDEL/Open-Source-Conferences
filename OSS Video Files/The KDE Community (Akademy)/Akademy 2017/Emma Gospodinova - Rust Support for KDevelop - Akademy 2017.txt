Title: Emma Gospodinova - Rust Support for KDevelop - Akademy 2017
Publication date: 2017-11-20
Playlist: Akademy 2017
Description: 
	Rust is a rather new programming language, but it has already gained a lot of traction. It was voted “most loved” language by developers for the second year in a row in the StackOverflow developer survey. There have been projects made using Rust on everything from operating systems to game engines for Minecraft-like games. Despite this, IDE support is still lacking. KDevelop currently does not support Rust at all. The goal of this Google Summer of Code project is to add the standard features an IDE should support for a language such as semantic highlighting, code completion, refactoring, debugging and project management.

https://conf.kde.org/en/akademy2017/public/events/394
Captions: 
	00:00:21,900 --> 00:00:26,320
[Applause]

00:00:22,970 --> 00:00:26,320
[Music]

00:00:31,529 --> 00:00:39,730
right so cool words about me I am a

00:00:35,740 --> 00:00:42,489
student at Imperial College London I am

00:00:39,730 --> 00:00:47,640
going to my third year now I've been

00:00:42,489 --> 00:00:47,640
programming for about 10 years now I

00:00:48,930 --> 00:00:54,910
have a lot of different interests in in

00:00:52,539 --> 00:01:00,519
all different fields of computer science

00:00:54,910 --> 00:01:03,309
like a computer vision and lately I've

00:01:00,519 --> 00:01:06,630
been more and more interested and stuff

00:01:03,309 --> 00:01:11,230
like operating systems type systems

00:01:06,630 --> 00:01:13,300
stuff like that I did an internship

00:01:11,230 --> 00:01:16,300
except research last summer doing some

00:01:13,300 --> 00:01:20,080
computer vision stuff and I've also done

00:01:16,300 --> 00:01:23,110
some hacking on Kitty stuff and a bunch

00:01:20,080 --> 00:01:26,560
of other food products like doing a

00:01:23,110 --> 00:01:31,330
bare-metal our assembly code of Mario

00:01:26,560 --> 00:01:33,610
Kart so I want to start with them over

00:01:31,330 --> 00:01:40,510
to us because Russ is an amazing

00:01:33,610 --> 00:01:42,430
language so I think that rust is a

00:01:40,510 --> 00:01:47,830
really great language because it's sort

00:01:42,430 --> 00:01:50,110
of CAP it's sort of learns from a lot of

00:01:47,830 --> 00:01:53,920
the mistakes that other programming

00:01:50,110 --> 00:01:55,900
languages like C++ made and it sort of

00:01:53,920 --> 00:02:00,610
tries to take the best elements of those

00:01:55,900 --> 00:02:07,810
languages but it also gifts but it also

00:02:00,610 --> 00:02:10,240
gives the sort of low-level access to -

00:02:07,810 --> 00:02:10,720
well it gives the access to a lot of the

00:02:10,240 --> 00:02:13,390
low-level

00:02:10,720 --> 00:02:17,050
elements and the performance benefits

00:02:13,390 --> 00:02:20,980
that come from that so to quote BR mr.

00:02:17,050 --> 00:02:22,840
Ostrow I hope I don't manual the name C

00:02:20,980 --> 00:02:25,810
makes it easy to shoot yourself in the

00:02:22,840 --> 00:02:29,670
foot C++ makes it harder when you do it

00:02:25,810 --> 00:02:32,050
it blows your whole leg off so in rust

00:02:29,670 --> 00:02:36,850
you can still pull your whole leg off

00:02:32,050 --> 00:02:41,110
without your thing but the compiler is

00:02:36,850 --> 00:02:48,790
there to sort of very very politely

00:02:41,110 --> 00:02:51,610
encourage you not to so give a few

00:02:48,790 --> 00:02:56,870
examples of rust so it's quite similar

00:02:51,610 --> 00:03:00,200
to C++ code you probably can't see

00:02:56,870 --> 00:03:05,140
the back but it hopefully looks somewhat

00:03:00,200 --> 00:03:08,510
familiar like there's all the standard

00:03:05,140 --> 00:03:13,599
imperative style and imperative language

00:03:08,510 --> 00:03:19,430
features you have destruct sonam's

00:03:13,599 --> 00:03:22,760
functions methods etc but Russ adds a

00:03:19,430 --> 00:03:27,069
couple more interesting features for

00:03:22,760 --> 00:03:32,569
example black tights so lifetimes

00:03:27,069 --> 00:03:36,349
they're not really a new idea a lifetime

00:03:32,569 --> 00:03:38,030
of variable is essentially from the it

00:03:36,349 --> 00:03:40,549
starts to the moment when that variable

00:03:38,030 --> 00:03:44,510
is created and ends when the variable is

00:03:40,549 --> 00:03:46,670
destroyed but Ross takes that idea one

00:03:44,510 --> 00:03:49,220
step further and add some features in

00:03:46,670 --> 00:03:54,829
the compiler that help you make sure

00:03:49,220 --> 00:03:57,799
that you don't use variables that are no

00:03:54,829 --> 00:04:06,350
longer alive so for example if you have

00:03:57,799 --> 00:04:10,370
a scope law of a given your tax in C++

00:04:06,350 --> 00:04:12,590
the way you do that is you acquire long

00:04:10,370 --> 00:04:14,900
and the constructor you drop belong in

00:04:12,590 --> 00:04:17,329
the destructor everything's great in the

00:04:14,900 --> 00:04:19,609
mutex somehow gets destroyed while

00:04:17,329 --> 00:04:22,940
you're putting the waffle you get to

00:04:19,609 --> 00:04:28,550
spend a few hours debugging in rust

00:04:22,940 --> 00:04:35,360
that can't happen because any reference

00:04:28,550 --> 00:04:38,360
to a value must must must be tagged with

00:04:35,360 --> 00:04:41,030
the lifetime and that lifetime basically

00:04:38,360 --> 00:04:45,500
allows the compiler to verify that that

00:04:41,030 --> 00:04:49,420
reference outlives or the value that

00:04:45,500 --> 00:04:54,710
points to a lose the reference itself

00:04:49,420 --> 00:05:00,010
and these kinds of checks help like help

00:04:54,710 --> 00:05:03,470
you the compiler helps you basically

00:05:00,010 --> 00:05:07,280
well it stops you from from making a lot

00:05:03,470 --> 00:05:09,560
of errors that occur with dynamic

00:05:07,280 --> 00:05:15,800
pointers and a criticism in the CSV file

00:05:09,560 --> 00:05:19,610
plus rust also has traits traits in rust

00:05:15,800 --> 00:05:21,350
are essentially concepts in C++ if and

00:05:19,610 --> 00:05:25,250
when concepts finally make it into the

00:05:21,350 --> 00:05:31,760
language standard essentially they give

00:05:25,250 --> 00:05:34,250
you static or morphism without having to

00:05:31,760 --> 00:05:35,510
scroll through hundreds of lines of

00:05:34,250 --> 00:05:40,690
error messages from your template

00:05:35,510 --> 00:05:40,690
forever doesn't satisfy some requirement

00:05:41,380 --> 00:05:48,070
russell's it has rust announcer

00:05:44,620 --> 00:05:52,870
algebraic data types if you've done

00:05:48,070 --> 00:05:55,870
Haskell or another functional program

00:05:52,870 --> 00:06:00,720
this algebraic data types are

00:05:55,870 --> 00:06:07,140
essentially tank unions so a variable of

00:06:00,720 --> 00:06:12,040
this type can only hold one of the given

00:06:07,140 --> 00:06:16,680
one of the different variants and it

00:06:12,040 --> 00:06:20,980
must pull all the data that is needed to

00:06:16,680 --> 00:06:25,600
construct that variant and luckily

00:06:20,980 --> 00:06:30,540
patterns patterns are a cool feature

00:06:25,600 --> 00:06:33,490
that essentially lets you destructor

00:06:30,540 --> 00:06:35,920
certain types of values so for example

00:06:33,490 --> 00:06:38,380
if you know that a function returns the

00:06:35,920 --> 00:06:40,090
tupple you can extract the different

00:06:38,380 --> 00:06:46,530
elements of the top line find them two

00:06:40,090 --> 00:06:50,890
variables or alternatively you can make

00:06:46,530 --> 00:06:53,350
you can have conditional conditional

00:06:50,890 --> 00:06:58,120
filings so piece of code that only

00:06:53,350 --> 00:07:03,070
executes if some if if some pattern

00:06:58,120 --> 00:07:06,100
matches so for example a is an optional

00:07:03,070 --> 00:07:10,060
type that can either contain some value

00:07:06,100 --> 00:07:13,450
next or no value at all so you can match

00:07:10,060 --> 00:07:19,900
on that pattern and say if it contains

00:07:13,450 --> 00:07:22,450
some some variable pull it be then do

00:07:19,900 --> 00:07:23,300
something else and there's also the

00:07:22,450 --> 00:07:28,069
match

00:07:23,300 --> 00:07:36,199
which is similar to this the rucks

00:07:28,069 --> 00:07:41,360
tax system is is this has a static and

00:07:36,199 --> 00:07:45,590
something type type system it does allow

00:07:41,360 --> 00:07:48,220
for local type inference meaning type

00:07:45,590 --> 00:07:52,220
inference within function bodies which

00:07:48,220 --> 00:07:56,710
saves a lot of typing and repetitive

00:07:52,220 --> 00:08:00,289
typing places it has the concept of

00:07:56,710 --> 00:08:02,509
owned and our values so these are

00:08:00,289 --> 00:08:06,940
essentially values on the stack and

00:08:02,509 --> 00:08:09,500
references and C++ with some additional

00:08:06,940 --> 00:08:12,500
compile time tracks to make sure that

00:08:09,500 --> 00:08:16,569
these values stay alive for as long as

00:08:12,500 --> 00:08:22,639
they have to and it does some other

00:08:16,569 --> 00:08:28,520
safety mechanisms to make sure that for

00:08:22,639 --> 00:08:31,729
example values that can not be used by

00:08:28,520 --> 00:08:36,039
two threads simultaneously don't get

00:08:31,729 --> 00:08:36,039
used mic to world war threads

00:08:37,149 --> 00:08:43,010
essentially for example things like the

00:08:41,390 --> 00:08:48,079
mutex can be passed around between

00:08:43,010 --> 00:08:49,160
tracks but any random variable or

00:08:48,079 --> 00:08:55,310
reference

00:08:49,160 --> 00:08:58,180
pass because all sorts of bugs can

00:08:55,310 --> 00:09:06,459
happen with that

00:08:58,180 --> 00:09:11,689
so right let's let's get on to what I so

00:09:06,459 --> 00:09:17,110
I've been working on the Russell Birk

00:09:11,689 --> 00:09:21,829
plugin for the past month and a half now

00:09:17,110 --> 00:09:24,920
initially there was the idea to use the

00:09:21,829 --> 00:09:29,120
Russ language server which is developed

00:09:24,920 --> 00:09:31,339
by Russ community it's it's actually

00:09:29,120 --> 00:09:33,980
being developed but it's still quite

00:09:31,339 --> 00:09:37,660
early stages and it's based on the

00:09:33,980 --> 00:09:41,569
language server protocol which is

00:09:37,660 --> 00:09:43,790
developed by Microsoft or originaly for

00:09:41,569 --> 00:09:47,079
Visual Studio code but they open sourced

00:09:43,790 --> 00:09:49,970
it and made it serve a community after

00:09:47,079 --> 00:09:52,699
the language server protocol is great

00:09:49,970 --> 00:09:57,470
for editors lightweight editors like

00:09:52,699 --> 00:09:58,970
cake and Visual Studio code but in my

00:09:57,470 --> 00:10:00,680
opinion that's not really good for

00:09:58,970 --> 00:10:03,050
something like a develop because it

00:10:00,680 --> 00:10:06,110
doesn't really expose enough information

00:10:03,050 --> 00:10:11,000
to build kay develops internal

00:10:06,110 --> 00:10:13,730
structures when I first wrote about this

00:10:11,000 --> 00:10:18,459
and blog posts that sparked quite a bit

00:10:13,730 --> 00:10:18,459
of discussion with Russ community and

00:10:21,279 --> 00:10:27,670
the things I pointed out worry about in

00:10:24,410 --> 00:10:31,060
Kate about for example a lot of feature

00:10:27,670 --> 00:10:34,530
such as highlighting and renaming

00:10:31,060 --> 00:10:39,250
declarations are done automatically by

00:10:34,530 --> 00:10:41,950
the cater Bell platform as long as you

00:10:39,250 --> 00:10:47,740
can build the internal structures that

00:10:41,950 --> 00:10:50,320
is the D the declaration use chain the

00:10:47,740 --> 00:10:53,050
thing is the Russell an observer doesn't

00:10:50,320 --> 00:10:55,840
really provide the information necessary

00:10:53,050 --> 00:11:01,090
to build those internal structures

00:10:55,840 --> 00:11:04,210
so essentially yeah you would not you

00:11:01,090 --> 00:11:06,460
wouldn't have to parse the language and

00:11:04,210 --> 00:11:08,230
know anything about the language but

00:11:06,460 --> 00:11:11,790
then you would need to implement all of

00:11:08,230 --> 00:11:15,370
these different parts of kata ball that

00:11:11,790 --> 00:11:18,040
highlight the code and given completions

00:11:15,370 --> 00:11:23,710
and so on and so forth based on language

00:11:18,040 --> 00:11:29,770
server protocol client so in the end I

00:11:23,710 --> 00:11:35,580
decided against it and decided to do the

00:11:29,770 --> 00:11:39,000
language plugin standard wink thing is

00:11:35,580 --> 00:11:42,340
the wrost is a nightmare to parse now

00:11:39,000 --> 00:11:46,900
C++ is a nightmare to parse but rust is

00:11:42,340 --> 00:11:50,200
pretty much just as bad so what I did

00:11:46,900 --> 00:11:54,520
was use the compilers parsing winery

00:11:50,200 --> 00:11:59,290
because compiler it's always going to be

00:11:54,520 --> 00:12:01,650
upstate the thing isn't powders written

00:11:59,290 --> 00:12:01,650
in rust

00:12:02,580 --> 00:12:15,149
so what I got to do was I exposed a

00:12:09,140 --> 00:12:20,390
library and rust and rust has a pretty

00:12:15,149 --> 00:12:23,610
good fi interface to see we basically

00:12:20,390 --> 00:12:26,279
specify that the functions are external

00:12:23,610 --> 00:12:32,209
see linkage and disable name mangling

00:12:26,279 --> 00:12:37,260
and everything just works expose an API

00:12:32,209 --> 00:12:40,910
to see to allow traversing the abstract

00:12:37,260 --> 00:12:45,500
syntax tree that I get from the compiler

00:12:40,910 --> 00:12:49,769
this is sort of similar approach to what

00:12:45,500 --> 00:12:54,120
Lipsy Lang and C and C Python legacy

00:12:49,769 --> 00:12:57,740
library do and these are also the things

00:12:54,120 --> 00:12:59,480
used for the C++ and Python

00:12:57,740 --> 00:13:04,950
perspectively

00:12:59,480 --> 00:13:08,550
and essentially what I did was exposed

00:13:04,950 --> 00:13:12,120
the exposed CA the C API

00:13:08,550 --> 00:13:17,820
I called ferment I called to it from the

00:13:12,120 --> 00:13:19,890
KML source code and the basically a

00:13:17,820 --> 00:13:24,149
LESBIAN gather all the declarations and

00:13:19,890 --> 00:13:27,899
uses and do some magic and voila syntax

00:13:24,149 --> 00:13:29,580
highlighting automatically so that was

00:13:27,899 --> 00:13:33,540
cool I was like

00:13:29,580 --> 00:13:40,500
those spots - right now I'm working on

00:13:33,540 --> 00:13:42,780
code completion and that's also quite

00:13:40,500 --> 00:13:44,220
interesting because for a lot of things

00:13:42,780 --> 00:13:46,290
in code completion you need to know

00:13:44,220 --> 00:13:50,280
about plates and as I mentioned earlier

00:13:46,290 --> 00:13:54,390
rust has local time expressed within

00:13:50,280 --> 00:13:57,960
function bodies so that requires type

00:13:54,390 --> 00:14:00,870
inference the problem is in the Ross

00:13:57,960 --> 00:14:07,290
compiler that happens after the parsing

00:14:00,870 --> 00:14:12,180
stage I think after like in in between

00:14:07,290 --> 00:14:18,240
the high level to make mid level

00:14:12,180 --> 00:14:27,210
representation transplant so it's not

00:14:18,240 --> 00:14:30,570
really useful to use that so writing our

00:14:27,210 --> 00:14:32,610
own amazing it is actually quite fun

00:14:30,570 --> 00:14:34,560
time of appearances is quite a new

00:14:32,610 --> 00:14:38,810
problem rust has a really good type

00:14:34,560 --> 00:14:42,200
system that allows doing type inference

00:14:38,810 --> 00:14:46,200
it's based on the hindley-milner

00:14:42,200 --> 00:14:51,150
algorithm so that is quite fun

00:14:46,200 --> 00:14:53,880
implementing so good position of the

00:14:51,150 --> 00:14:56,460
moment works for local declarations so

00:14:53,880 --> 00:14:58,260
you can autocomplete the variable

00:14:56,460 --> 00:15:03,330
declared

00:14:58,260 --> 00:15:07,950
in closing so I'm currently working on

00:15:03,330 --> 00:15:10,140
getting it to run for imported libraries

00:15:07,950 --> 00:15:15,720
so I have been able to successfully

00:15:10,140 --> 00:15:21,060
parse the rest enter library and the

00:15:15,720 --> 00:15:25,320
rest for library these are quite huge

00:15:21,060 --> 00:15:31,860
after a macro expansion so that was that

00:15:25,320 --> 00:15:34,950
was quite quite cool and afterwards I'm

00:15:31,860 --> 00:15:38,130
like what was this works then basically

00:15:34,950 --> 00:15:43,880
applying the same method should work for

00:15:38,130 --> 00:15:46,440
any other library as well and rusts

00:15:43,880 --> 00:15:51,510
package manager which I'll talk about in

00:15:46,440 --> 00:15:54,360
a sec as well and it basically builds

00:15:51,510 --> 00:15:56,550
everything so any dependent libraries

00:15:54,360 --> 00:15:58,770
have done those women built them and it

00:15:56,550 --> 00:16:02,880
exposes the metadata about whether we're

00:15:58,770 --> 00:16:07,410
in their store so essentially I can just

00:16:02,880 --> 00:16:09,990
look at the source code of those and it

00:16:07,410 --> 00:16:16,680
should it should work just the same as

00:16:09,990 --> 00:16:20,070
with the standard libraries in rust I'm

00:16:16,680 --> 00:16:25,140
also working on Rebecca at the moment

00:16:20,070 --> 00:16:27,330
like I said renamed decorations is one

00:16:25,140 --> 00:16:28,620
of the things that k12 provides out of

00:16:27,330 --> 00:16:34,200
the box and see how

00:16:28,620 --> 00:16:38,400
duration news chane so that's done that

00:16:34,200 --> 00:16:41,450
works quick fixes are something I'd like

00:16:38,400 --> 00:16:45,060
to do and something I'm looking into so

00:16:41,450 --> 00:16:49,530
rustic powder has really really good

00:16:45,060 --> 00:16:54,140
error messages it gives you suggestions

00:16:49,530 --> 00:16:57,750
about for example missing imports or

00:16:54,140 --> 00:17:00,950
different sorts of tigers it tells you

00:16:57,750 --> 00:17:03,990
over to doing this so I'm looking into

00:17:00,950 --> 00:17:06,300
parsing those and trying to explore but

00:17:03,990 --> 00:17:08,250
exposed to that's quick fixes within a

00:17:06,300 --> 00:17:12,360
bell

00:17:08,250 --> 00:17:17,090
I'm also looking into auto generating

00:17:12,360 --> 00:17:28,550
stuff like trade implementations and

00:17:17,090 --> 00:17:28,550
matches basically anything always nicely

00:17:29,330 --> 00:17:38,400
the puppy the buck his should both be

00:17:34,730 --> 00:17:42,630
quite straightforward Russ uses GDP and

00:17:38,400 --> 00:17:46,170
lltv both of those are already supported

00:17:42,630 --> 00:17:49,200
in can develop the only thing that's

00:17:46,170 --> 00:17:52,560
needed is to integrate with rustic to

00:17:49,200 --> 00:17:55,410
integrate that with rust executables and

00:17:52,560 --> 00:18:00,200
I say that is because as I have been

00:17:55,410 --> 00:18:02,760
debugging he develop like I said I

00:18:00,200 --> 00:18:07,310
Russell I with it as well so any time

00:18:02,760 --> 00:18:10,670
that I've been to bugging with GB and

00:18:07,310 --> 00:18:13,800
the code crosses over into Russ code

00:18:10,670 --> 00:18:18,450
there's no problem at all the call stack

00:18:13,800 --> 00:18:19,870
is visible all the variables like all

00:18:18,450 --> 00:18:24,190
the locals

00:18:19,870 --> 00:18:26,860
stuff like that are visible it works

00:18:24,190 --> 00:18:31,799
perfectly well so I'm hoping that the

00:18:26,860 --> 00:18:38,710
same should be just as easily applied in

00:18:31,799 --> 00:18:44,610
a kata belt as well and I'm a project

00:18:38,710 --> 00:18:47,890
management so carbon is great as I said

00:18:44,610 --> 00:18:51,789
it provides dependency it provides

00:18:47,890 --> 00:18:53,110
metadata for different dependencies like

00:18:51,789 --> 00:18:57,309
where they're located

00:18:53,110 --> 00:19:00,279
what other things they depend on etc etc

00:18:57,309 --> 00:19:04,029
and rough products in general have very

00:19:00,279 --> 00:19:09,520
consistent structures so for example the

00:19:04,029 --> 00:19:11,500
default the poplar an executable like

00:19:09,520 --> 00:19:17,289
the main the main file of an executable

00:19:11,500 --> 00:19:23,080
is SRC main and respectively for a

00:19:17,289 --> 00:19:25,270
library is source live it has to be this

00:19:23,080 --> 00:19:27,750
very consistent structure which of

00:19:25,270 --> 00:19:30,640
course can be overridden and cargo but

00:19:27,750 --> 00:19:39,399
the default structure is very nice and

00:19:30,640 --> 00:19:48,820
it would allow very easy basically to to

00:19:39,399 --> 00:19:50,470
parse everything so to recap rust is an

00:19:48,820 --> 00:19:51,399
amazing language we should definitely

00:19:50,470 --> 00:19:57,490
check it out

00:19:51,399 --> 00:20:00,580
I been blogging about all of my work so

00:19:57,490 --> 00:20:06,580
you should follow me on my blog if you

00:20:00,580 --> 00:20:09,390
like to follow my work as the code the

00:20:06,580 --> 00:20:15,000
rest plugin is available online it

00:20:09,390 --> 00:20:16,920
in the k-t repositories so if you'd like

00:20:15,000 --> 00:20:19,620
to try it out please do it's a bit of a

00:20:16,920 --> 00:20:21,900
hassle to build at the moment but I

00:20:19,620 --> 00:20:29,309
promise that I'll improve in the next

00:20:21,900 --> 00:20:31,140
month or so so yeah all right we have a

00:20:29,309 --> 00:20:34,219
couple minutes for some questions

00:20:31,140 --> 00:20:34,219

YouTube URL: https://www.youtube.com/watch?v=wPiHvgXAGuE


