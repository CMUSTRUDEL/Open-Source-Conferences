Title: Ivan Čukić - C++17 and 20 - Akademy 2017
Publication date: 2017-11-20
Playlist: Akademy 2017
Description: 
	C++ was asleep for a long time, but as Jon Kalb put it "the beast is back". We are getting a new version of the standard every few years.

Also, the compiler support is getting better with each day, with GCC and Clang leading the bunch.

C++17 included a few interesting features and many technical specifications of the features planned for C++20.

We will cover quite a few of them - from ranges, through concepts, to coroutines.

https://conf.kde.org/en/akademy2017/public/events/356
Captions: 
	00:00:12,050 --> 00:00:20,840
the wild to start with even two kids

00:00:16,160 --> 00:00:24,110
will I got it we will talk about new

00:00:20,840 --> 00:00:25,460
features in C++ 17 and 20 and then we

00:00:24,110 --> 00:00:27,800
will have a talk by the sponsor is

00:00:25,460 --> 00:00:30,650
followed by the Oscars or the Academy

00:00:27,800 --> 00:00:38,690
Awards so it's a pretty good lineup

00:00:30,650 --> 00:00:40,790
let's begin okay this was a real really

00:00:38,690 --> 00:00:43,120
enthusiastic introduction it will be

00:00:40,790 --> 00:00:43,120
over soon

00:00:43,780 --> 00:00:49,640
let's the reason for me giving this talk

00:00:47,540 --> 00:00:52,850
I usually don't give over review talks

00:00:49,640 --> 00:00:55,699
because I find them boring but the main

00:00:52,850 --> 00:00:58,159
reason is that in KD especially KD

00:00:55,699 --> 00:01:04,570
frameworks we don't even depend on K on

00:00:58,159 --> 00:01:08,600
C++ 11 so this is my attempt to try to a

00:01:04,570 --> 00:01:11,750
little bit inspire you to force people

00:01:08,600 --> 00:01:15,409
like David for now called David 5 to

00:01:11,750 --> 00:01:17,179
actually propose Russ to increase the

00:01:15,409 --> 00:01:22,700
compiler requirements for most of the

00:01:17,179 --> 00:01:25,240
things that we are doing so the usual

00:01:22,700 --> 00:01:29,090
disclaimers blah blah blah

00:01:25,240 --> 00:01:31,280
the history of C++ was really slow first

00:01:29,090 --> 00:01:34,340
it was silly the classes and we all know

00:01:31,280 --> 00:01:36,890
that it was standardized in 98 and since

00:01:34,340 --> 00:01:37,640
then until she was passed 11 and nothing

00:01:36,890 --> 00:01:41,359
major change

00:01:37,640 --> 00:01:44,149
we got an intermediary new standard

00:01:41,359 --> 00:01:48,590
which was just a bug fix release of the

00:01:44,149 --> 00:01:51,020
previous C++ 98 so for the most part the

00:01:48,590 --> 00:01:53,210
language was really stagnating a couple

00:01:51,020 --> 00:02:00,079
of things were published under the

00:01:53,210 --> 00:02:03,139
technical or whatever one which had a

00:02:00,079 --> 00:02:05,509
couple of interesting experimental

00:02:03,139 --> 00:02:07,939
library features and stuff that you

00:02:05,509 --> 00:02:09,920
could access through STD column column

00:02:07,939 --> 00:02:14,120
Tier one column column something like

00:02:09,920 --> 00:02:15,610
bind or similar stuff but nothing

00:02:14,120 --> 00:02:17,930
actually happened

00:02:15,610 --> 00:02:21,530
nothing important and tells it was

00:02:17,930 --> 00:02:23,740
possible now C++ is split into two parts

00:02:21,530 --> 00:02:25,210
the core language and the libraries and

00:02:23,740 --> 00:02:28,690
usually when we

00:02:25,210 --> 00:02:30,460
say a new version of the language most

00:02:28,690 --> 00:02:33,010
of the people think only about the core

00:02:30,460 --> 00:02:35,350
language and what new syntax we are

00:02:33,010 --> 00:02:37,330
getting most of the people just somehow

00:02:35,350 --> 00:02:40,540
ignore the standard library especially

00:02:37,330 --> 00:02:43,270
in cute community some people even claim

00:02:40,540 --> 00:02:45,610
that they never needed anything in

00:02:43,270 --> 00:02:47,410
standard library some of the cute

00:02:45,610 --> 00:02:54,340
maintained errs which I'm not going to

00:02:47,410 --> 00:02:56,800
mention so in C++ 11 we got in the core

00:02:54,340 --> 00:02:59,440
language we got lambdas or to arrange

00:02:56,800 --> 00:03:02,250
base for loop and in the library we got

00:02:59,440 --> 00:03:06,220
a lot of things including smart pointers

00:03:02,250 --> 00:03:08,320
in C++ 14 we didn't didn't get that many

00:03:06,220 --> 00:03:10,540
new things just again a Polish of the

00:03:08,320 --> 00:03:17,410
previous release we had a lot of bug

00:03:10,540 --> 00:03:19,120
fixes now C++ 17 has landed or almost

00:03:17,410 --> 00:03:22,450
landed I'm not sure whether it actually

00:03:19,120 --> 00:03:25,330
is published by ease or not but all the

00:03:22,450 --> 00:03:28,120
features are already known and and voted

00:03:25,330 --> 00:03:31,810
in so we kind of know what we are going

00:03:28,120 --> 00:03:33,640
to get one of the first things that we

00:03:31,810 --> 00:03:36,670
are going to get are structured bindings

00:03:33,640 --> 00:03:39,580
so we have a lot of things in standard

00:03:36,670 --> 00:03:41,890
library which return STD pair for

00:03:39,580 --> 00:03:45,130
example when you want to insert a value

00:03:41,890 --> 00:03:47,410
in a map you're going to get an STD pair

00:03:45,130 --> 00:03:49,990
of an iterator and a boolean whether the

00:03:47,410 --> 00:03:52,840
insert was successful or not and if you

00:03:49,990 --> 00:03:54,190
wanted to use it in the old C++ you

00:03:52,840 --> 00:03:57,610
would have to write something like if

00:03:54,190 --> 00:03:59,560
we're dot second and if you just look at

00:03:57,610 --> 00:04:02,500
the line if where that second

00:03:59,560 --> 00:04:04,390
it doesn't mean absolutely anything it

00:04:02,500 --> 00:04:08,590
doesn't tell you a single thing about

00:04:04,390 --> 00:04:12,280
what you're doing there so the thing

00:04:08,590 --> 00:04:15,400
that we were able to do since C++ 11 is

00:04:12,280 --> 00:04:18,690
to declare iterator IT and a boolean

00:04:15,400 --> 00:04:22,510
value called success then called STD tie

00:04:18,690 --> 00:04:24,730
estimate I will create a tuple of doors

00:04:22,510 --> 00:04:26,620
element references to the elements that

00:04:24,730 --> 00:04:28,780
you passed it and then you could write

00:04:26,620 --> 00:04:32,890
as the date I equals to something that

00:04:28,780 --> 00:04:35,350
returns a pair or a topple and the

00:04:32,890 --> 00:04:38,860
result will be decomposed into the

00:04:35,350 --> 00:04:41,500
variables that you tied now this is

00:04:38,860 --> 00:04:43,750
much more readable you can just write if

00:04:41,500 --> 00:04:45,900
success and you know that something

00:04:43,750 --> 00:04:49,030
succeeded it's not called the dot second

00:04:45,900 --> 00:04:50,949
but the problem is that we still have to

00:04:49,030 --> 00:04:54,370
declare the variables completely

00:04:50,949 --> 00:04:56,830
separately from the tying and value

00:04:54,370 --> 00:04:58,810
assignment the problem is not only that

00:04:56,830 --> 00:05:01,569
it's tedious to write but we can't

00:04:58,810 --> 00:05:03,669
declare these variables as Const and we

00:05:01,569 --> 00:05:05,379
are advised by the Scott Myers and a lot

00:05:03,669 --> 00:05:07,240
of smart C++ people that we should

00:05:05,379 --> 00:05:09,460
always declare everything as constant

00:05:07,240 --> 00:05:13,210
unless we actually intend to change it

00:05:09,460 --> 00:05:15,310
so this is again not an ideal solution

00:05:13,210 --> 00:05:17,500
it's better than the original one a

00:05:15,310 --> 00:05:22,449
little bit more readable but it has a

00:05:17,500 --> 00:05:25,900
lot of boilerplate around it so C++ 17

00:05:22,449 --> 00:05:30,190
is going to abuse yet another set of

00:05:25,900 --> 00:05:34,449
brackets so instead of using Curly's or

00:05:30,190 --> 00:05:37,840
normal parentheses there for this the

00:05:34,449 --> 00:05:41,500
angle ones are used what does this mean

00:05:37,840 --> 00:05:44,380
we are creating two variables that will

00:05:41,500 --> 00:05:49,029
have their types deduced by the compiler

00:05:44,380 --> 00:05:51,460
and the types of them will be the same

00:05:49,029 --> 00:05:55,539
as the types that are in the to play

00:05:51,460 --> 00:05:57,819
written by insert okay so this way we

00:05:55,539 --> 00:05:59,560
don't need we can immediately declare

00:05:57,819 --> 00:06:01,750
them as Const they will get the

00:05:59,560 --> 00:06:04,860
automatic automatic types and we kind of

00:06:01,750 --> 00:06:07,000
get something that that was always

00:06:04,860 --> 00:06:10,389
possible in many functional programming

00:06:07,000 --> 00:06:13,990
languages things to be composing

00:06:10,389 --> 00:06:17,770
structures like this and this is one of

00:06:13,990 --> 00:06:20,860
the let's say biggies in C++ 17 which

00:06:17,770 --> 00:06:23,800
kind of gives you the idea that C++ 17

00:06:20,860 --> 00:06:27,219
wasn't really a big big step forward

00:06:23,800 --> 00:06:31,750
compared to the C++ 14 but we will

00:06:27,219 --> 00:06:34,840
return to that later the next thing that

00:06:31,750 --> 00:06:38,020
was introduced this is probably the code

00:06:34,840 --> 00:06:40,840
that you all wrote at some point when

00:06:38,020 --> 00:06:42,969
you want to lock a mutex obviously

00:06:40,840 --> 00:06:45,069
you're going to use array I with some

00:06:42,969 --> 00:06:48,310
local guard or something and then you're

00:06:45,069 --> 00:06:50,199
going to create a block so that you

00:06:48,310 --> 00:06:51,870
minimize the portion of your code where

00:06:50,199 --> 00:06:53,970
the mutex is locked

00:06:51,870 --> 00:06:56,760
and again this block exists without an

00:06:53,970 --> 00:06:59,280
if without a while without anything it's

00:06:56,760 --> 00:07:05,030
just there so that we can invoke area

00:06:59,280 --> 00:07:07,979
when the block exits instead of this now

00:07:05,030 --> 00:07:11,790
the if statement and a switch statement

00:07:07,979 --> 00:07:14,880
support initializer then semicolon and

00:07:11,790 --> 00:07:16,320
then the value that is going to be

00:07:14,880 --> 00:07:21,900
checked against or false

00:07:16,320 --> 00:07:25,770
just like the for loop okay so now we

00:07:21,900 --> 00:07:28,320
actually have just a single block the

00:07:25,770 --> 00:07:30,570
lifetime of this lock guard will be only

00:07:28,320 --> 00:07:32,400
in this if and obviously in the else

00:07:30,570 --> 00:07:35,460
branch but since we don't have the other

00:07:32,400 --> 00:07:37,560
branch we don't care about it this

00:07:35,460 --> 00:07:42,270
variable doesn't even exist outside of

00:07:37,560 --> 00:07:44,789
this block okay and this is again

00:07:42,270 --> 00:07:47,280
something that makes the code a little

00:07:44,789 --> 00:07:50,310
bit shorter and much safer because you

00:07:47,280 --> 00:07:54,830
cannot if even if you try you cannot

00:07:50,310 --> 00:07:58,620
leave that mutex on unlock yet X locked

00:07:54,830 --> 00:08:01,410
and then if you want to combine the

00:07:58,620 --> 00:08:04,889
previous two features because we had the

00:08:01,410 --> 00:08:07,800
code that did an insert and then check

00:08:04,889 --> 00:08:10,680
for success you can combine okay this

00:08:07,800 --> 00:08:14,220
structure despair into IT and success

00:08:10,680 --> 00:08:18,810
and then the condition for the if will

00:08:14,220 --> 00:08:21,180
be judged success so while this might

00:08:18,810 --> 00:08:24,000
seem like a really useless feature to

00:08:21,180 --> 00:08:26,130
add to a programming language into the

00:08:24,000 --> 00:08:27,900
major programming language and major

00:08:26,130 --> 00:08:32,159
version of a major programming language

00:08:27,900 --> 00:08:34,709
this is quite useful and in a couple of

00:08:32,159 --> 00:08:38,580
things that I actually could use C++ 17

00:08:34,709 --> 00:08:41,070
in I abuse this as much as as possible

00:08:38,580 --> 00:08:47,120
it makes the code much shorter in a

00:08:41,070 --> 00:08:51,770
couple of really important situations so

00:08:47,120 --> 00:08:56,010
that's essentially it for the part about

00:08:51,770 --> 00:08:58,350
major new language features which I can

00:08:56,010 --> 00:09:02,850
see that least important one of the

00:08:58,350 --> 00:09:04,900
things more that was inserted is to help

00:09:02,850 --> 00:09:09,250
meta programming not regular program

00:09:04,900 --> 00:09:13,240
so imagine we have a function f and it

00:09:09,250 --> 00:09:14,860
needs to access accept a value and we

00:09:13,240 --> 00:09:17,230
need to have different implementations

00:09:14,860 --> 00:09:20,410
for F depending on whether that values

00:09:17,230 --> 00:09:23,050
integral value or anything else so for

00:09:20,410 --> 00:09:25,830
example int conch R or whatever

00:09:23,050 --> 00:09:32,770
compared to strings or everything else

00:09:25,830 --> 00:09:35,400
in all C++ we would need to create two

00:09:32,770 --> 00:09:39,100
different implementations so F in pull

00:09:35,400 --> 00:09:42,250
which accepts a value and accepts STD

00:09:39,100 --> 00:09:45,060
true type and the other F in pull

00:09:42,250 --> 00:09:49,089
accepts a value and STD false type and

00:09:45,060 --> 00:09:52,150
then what would F do F would call F in

00:09:49,089 --> 00:09:55,360
pull for a value and then it would a

00:09:52,150 --> 00:09:59,380
pass a compile-time type or a compile

00:09:55,360 --> 00:10:02,529
time integral constant is integral of T

00:09:59,380 --> 00:10:04,390
will return either an instance of true

00:10:02,529 --> 00:10:07,240
type or an instance of false type and

00:10:04,390 --> 00:10:08,740
the correct one will be called and this

00:10:07,240 --> 00:10:10,839
is something that is usually called tie

00:10:08,740 --> 00:10:13,180
tack dispatching because this true type

00:10:10,839 --> 00:10:15,400
and false type are essentially tags that

00:10:13,180 --> 00:10:17,020
we are attaching to a function in order

00:10:15,400 --> 00:10:21,730
for the compiler to know exactly which

00:10:17,020 --> 00:10:25,750
one to call in C++ 17 we are going well

00:10:21,730 --> 00:10:30,010
we got something called expression if

00:10:25,750 --> 00:10:33,580
the difference is that normal if the

00:10:30,010 --> 00:10:36,339
thing that you pass as the condition is

00:10:33,580 --> 00:10:40,120
evaluated at runtime vidcon stack spray

00:10:36,339 --> 00:10:41,830
if it's evaluated at compile time and if

00:10:40,120 --> 00:10:45,160
it's true then the else branch is

00:10:41,830 --> 00:10:47,290
discarded completely if it's false then

00:10:45,160 --> 00:10:49,900
the if branch is discarded completely

00:10:47,290 --> 00:10:53,320
this means that both branches obviously

00:10:49,900 --> 00:10:57,339
have to have correct syntax but they can

00:10:53,320 --> 00:11:02,170
use things for example if we got the

00:10:57,339 --> 00:11:04,270
else we could call for example else if

00:11:02,170 --> 00:11:08,680
the type is a string we could call

00:11:04,270 --> 00:11:11,290
methods of a string the compiler if this

00:11:08,680 --> 00:11:14,020
was an ordinary if would complain that

00:11:11,290 --> 00:11:17,620
for integers that member function

00:11:14,020 --> 00:11:18,460
doesn't exist and this way dead branch

00:11:17,620 --> 00:11:20,620
will just

00:11:18,460 --> 00:11:23,740
thrown away and it will never be called

00:11:20,620 --> 00:11:26,440
so we can write things that are

00:11:23,740 --> 00:11:28,990
syntactically valid but our would be

00:11:26,440 --> 00:11:33,460
invalid in the context 20 is some

00:11:28,990 --> 00:11:36,330
specific value some specific type so the

00:11:33,460 --> 00:11:38,920
if Const exper is something that was

00:11:36,330 --> 00:11:41,920
there was a more powerful proposal

00:11:38,920 --> 00:11:44,770
called static if by Alex and rescue it

00:11:41,920 --> 00:11:47,560
the idea was to allow if contacts were

00:11:44,770 --> 00:11:50,440
to be anywhere in the scope so that you

00:11:47,560 --> 00:11:54,430
can enable/disable functions and similar

00:11:50,440 --> 00:11:56,500
things but because of concepts and a

00:11:54,430 --> 00:12:00,190
little bit of a clash between concepts

00:11:56,500 --> 00:12:03,490
and that static if was abandoned and

00:12:00,190 --> 00:12:05,190
contacts brief was added just for the

00:12:03,490 --> 00:12:10,960
intermediary period until we get

00:12:05,190 --> 00:12:14,440
concepts okay the next thing that I

00:12:10,960 --> 00:12:17,440
really really really love again about

00:12:14,440 --> 00:12:19,570
generic programming until now if we

00:12:17,440 --> 00:12:22,750
declared the template function we could

00:12:19,570 --> 00:12:24,910
call it just with F of 42 the compare

00:12:22,750 --> 00:12:28,420
would automatically deduce the type of

00:12:24,910 --> 00:12:33,610
the argument so we wouldn't have to

00:12:28,420 --> 00:12:36,070
write F of T of int clothes and 42 but

00:12:33,610 --> 00:12:38,500
for classes we didn't have automatic

00:12:36,070 --> 00:12:42,040
type deduction so if we tried to write C

00:12:38,500 --> 00:12:45,190
of 42 where C's a template class we

00:12:42,040 --> 00:12:48,040
would get an error and for this reason

00:12:45,190 --> 00:12:50,980
for example in the standard library we

00:12:48,040 --> 00:12:53,110
have a sturdy pair STD pair if we want

00:12:50,980 --> 00:12:55,960
to instantiate we either have to write a

00:12:53,110 --> 00:12:58,510
CD pair of int char something something

00:12:55,960 --> 00:13:01,620
or we need to use to make pair function

00:12:58,510 --> 00:13:05,320
because the function can invoke the

00:13:01,620 --> 00:13:08,110
automatic type deduction and the class

00:13:05,320 --> 00:13:10,240
cannot so for most of the template

00:13:08,110 --> 00:13:12,640
classes that we created we always needed

00:13:10,240 --> 00:13:14,860
to create and make that class function

00:13:12,640 --> 00:13:19,030
to trigger the automatic type deduction

00:13:14,860 --> 00:13:22,660
with C++ 17 the compiler became much

00:13:19,030 --> 00:13:24,010
smarter it now allows the compiler that

00:13:22,660 --> 00:13:26,860
the standard allows the compiler to

00:13:24,010 --> 00:13:29,560
check for the constructors and to see

00:13:26,860 --> 00:13:33,250
whether it can deduce the types from the

00:13:29,560 --> 00:13:35,920
Constructors themselves so for example

00:13:33,250 --> 00:13:38,370
for the pair we don't we will not no

00:13:35,920 --> 00:13:40,990
longer need to specify the types the

00:13:38,370 --> 00:13:43,660
compiler will check all the constructors

00:13:40,990 --> 00:13:45,970
for STD pair it will see ok I've got

00:13:43,660 --> 00:13:49,210
something that's called t1 t2 I can

00:13:45,970 --> 00:13:51,940
match Davonte to 2 Intendant in this

00:13:49,210 --> 00:13:53,890
case and this is something that is

00:13:51,940 --> 00:13:55,600
really really removing the boilerplate

00:13:53,890 --> 00:13:58,770
for writing make something makes

00:13:55,600 --> 00:13:58,770
something make something make something

00:13:59,850 --> 00:14:04,540
apart from these there are a couple of

00:14:02,530 --> 00:14:05,710
other core language features that we did

00:14:04,540 --> 00:14:09,490
have been that edit

00:14:05,710 --> 00:14:15,220
for example guaranteed copy illusion who

00:14:09,490 --> 00:14:17,410
knows what the copulation is then ok I

00:14:15,220 --> 00:14:20,170
don't have really enough time but if you

00:14:17,410 --> 00:14:22,420
are returning of some complex I don't

00:14:20,170 --> 00:14:24,760
know a string from a function and you

00:14:22,420 --> 00:14:27,250
have a string in you in the caller and

00:14:24,760 --> 00:14:31,330
you're just assigning it the compiler

00:14:27,250 --> 00:14:34,330
will move not move will alight the copy

00:14:31,330 --> 00:14:37,590
of the result into this one but it will

00:14:34,330 --> 00:14:41,350
directly construct the result into the

00:14:37,590 --> 00:14:43,750
caller and this is a this is an on the

00:14:41,350 --> 00:14:47,320
optimization that was always defined by

00:14:43,750 --> 00:14:49,420
the standard as optional for a lot of

00:14:47,320 --> 00:14:53,740
cases now it's a compilers are

00:14:49,420 --> 00:14:56,800
guaranteed to make it so you can start

00:14:53,740 --> 00:15:00,310
to rely on it more heavily then we help

00:14:56,800 --> 00:15:02,680
template author which is in among

00:15:00,310 --> 00:15:07,990
variables like cables give that as well

00:15:02,680 --> 00:15:11,470
attributes there have been two important

00:15:07,990 --> 00:15:13,480
attributes as far as I'm concerned fall

00:15:11,470 --> 00:15:15,100
through is the attribute for example if

00:15:13,480 --> 00:15:18,580
you're writing a switch statement and

00:15:15,100 --> 00:15:22,240
you forget to write somewhere return a

00:15:18,580 --> 00:15:25,090
value or break the compile will now

00:15:22,240 --> 00:15:27,490
report the warning unless if you

00:15:25,090 --> 00:15:30,340
explicitly say that you want a fall

00:15:27,490 --> 00:15:34,390
through to the next case and since I've

00:15:30,340 --> 00:15:37,840
seen so many bugs for people forgetting

00:15:34,390 --> 00:15:40,360
the break or a return this is one of the

00:15:37,840 --> 00:15:44,150
really really really good features the

00:15:40,360 --> 00:15:46,820
other one is no discard you can declare

00:15:44,150 --> 00:15:50,060
for example a function like STD I think

00:15:46,820 --> 00:15:52,990
which returns the future do you know

00:15:50,060 --> 00:15:55,190
what happens if you call STD a sync with

00:15:52,990 --> 00:15:56,990
for example eyes did you think this

00:15:55,190 --> 00:15:59,480
function as the distinct this function

00:15:56,990 --> 00:16:01,750
as the distinct dysfunction and all of

00:15:59,480 --> 00:16:06,950
those functions should write hello world

00:16:01,750 --> 00:16:13,850
character by character what is going to

00:16:06,950 --> 00:16:15,940
be written on the on the screen that's

00:16:13,850 --> 00:16:32,480
what normal people would expect yes

00:16:15,940 --> 00:16:36,350
unfortunately Walter yes so as to be a

00:16:32,480 --> 00:16:39,710
sync returns the STD future a special

00:16:36,350 --> 00:16:42,620
variant of STD future Veatch blocks on

00:16:39,710 --> 00:16:45,500
destruction and since we didn't assign

00:16:42,620 --> 00:16:48,320
anything to have variable after each STD

00:16:45,500 --> 00:16:50,960
a sink call the temporary future will be

00:16:48,320 --> 00:16:53,390
destroyed it will call a dog cat and it

00:16:50,960 --> 00:16:56,090
will block so even if you write a

00:16:53,390 --> 00:16:59,450
thousand of things everything is still

00:16:56,090 --> 00:17:01,670
synchronous for functions like those you

00:16:59,450 --> 00:17:04,220
can just write no discard and then

00:17:01,670 --> 00:17:06,380
compiler will complain if you actually

00:17:04,220 --> 00:17:09,140
discarded the value instead of storing

00:17:06,380 --> 00:17:12,830
it into instead of naming it somewhere

00:17:09,140 --> 00:17:15,650
or passing it to another function we

00:17:12,830 --> 00:17:18,410
have nested namespaces which is one of

00:17:15,650 --> 00:17:20,360
the reasons why original EQ didn't want

00:17:18,410 --> 00:17:23,480
to use namespaces so that they don't

00:17:20,360 --> 00:17:26,089
need to deal with namespace a main space

00:17:23,480 --> 00:17:28,430
being in space C and stuff now it's much

00:17:26,089 --> 00:17:31,880
much easier to write a column column B

00:17:28,430 --> 00:17:36,230
and we have a little bit relaxed range

00:17:31,880 --> 00:17:40,340
for loop range base for loop in C++ 11

00:17:36,230 --> 00:17:42,500
and 14 for both begin and end of a

00:17:40,340 --> 00:17:46,400
collection you have to have the same

00:17:42,500 --> 00:17:48,620
type now this this restriction has been

00:17:46,400 --> 00:17:51,950
lifted so that we can support special

00:17:48,620 --> 00:17:54,200
types for the end called sentinels which

00:17:51,950 --> 00:17:56,930
is really useful with ranges and stuff

00:17:54,200 --> 00:17:57,590
to actually use sentinels but for normal

00:17:56,930 --> 00:18:00,309
collection

00:17:57,590 --> 00:18:00,309
maybe maybe not

00:18:01,279 --> 00:18:08,390
if you if I have the time in the end to

00:18:04,250 --> 00:18:14,029
explain what Sentinels mean in this

00:18:08,390 --> 00:18:17,360
specific case you can just remind me now

00:18:14,029 --> 00:18:21,049
we are moving to the library part we

00:18:17,360 --> 00:18:23,510
have been added a couple of algebraic

00:18:21,049 --> 00:18:26,630
data types more specifically some types

00:18:23,510 --> 00:18:30,250
got into the standard library the first

00:18:26,630 --> 00:18:32,870
sum type is optional of T which is

00:18:30,250 --> 00:18:36,409
something - like a container that can

00:18:32,870 --> 00:18:40,279
either be empty or have a single value

00:18:36,409 --> 00:18:43,549
inside so in our original example names

00:18:40,279 --> 00:18:46,789
dot insert just imagine that if insert

00:18:43,549 --> 00:18:49,880
fails it returns a false and an invalid

00:18:46,789 --> 00:18:53,320
iterator which is a lie but imagine and

00:18:49,880 --> 00:18:56,149
we are only considering the case where

00:18:53,320 --> 00:18:58,789
we are going to access the iterator only

00:18:56,149 --> 00:19:01,279
if the second thing is is true and this

00:18:58,789 --> 00:19:03,950
is something that is really really often

00:19:01,279 --> 00:19:06,919
done if we wanted to have an optional

00:19:03,950 --> 00:19:11,149
value in C++ we either created a pair of

00:19:06,919 --> 00:19:14,059
wool and something else or we created an

00:19:11,149 --> 00:19:16,429
iterator sorry pointer to something

00:19:14,059 --> 00:19:20,240
which could be now or points to a real

00:19:16,429 --> 00:19:23,270
value or some really demented people

00:19:20,240 --> 00:19:25,190
used lists because lists can have zero

00:19:23,270 --> 00:19:27,110
or one item and we are going to ignore

00:19:25,190 --> 00:19:30,649
that they can have much more than one

00:19:27,110 --> 00:19:33,020
item so in order to model something

00:19:30,649 --> 00:19:35,659
really trivial I don't have a value I

00:19:33,020 --> 00:19:38,539
have a value we used really really

00:19:35,659 --> 00:19:41,000
strange hacks the problem I think the

00:19:38,539 --> 00:19:43,370
most common was with the pointers and

00:19:41,000 --> 00:19:45,679
with the pointers you don't know who is

00:19:43,370 --> 00:19:47,630
the owner do you need to delete it when

00:19:45,679 --> 00:19:50,149
somebody returns your pointer or not or

00:19:47,630 --> 00:19:54,529
it's just an optional value debt offered

00:19:50,149 --> 00:19:58,309
all of that ok I don't have the time so

00:19:54,529 --> 00:20:00,860
we got the optional you say option of

00:19:58,309 --> 00:20:05,419
iterator it can be empty or it can have

00:20:00,860 --> 00:20:08,419
an iterator and if it's true

00:20:05,419 --> 00:20:11,500
so optional costs to a boolean which is

00:20:08,419 --> 00:20:11,500
true if it has a value

00:20:11,510 --> 00:20:16,980
as an extension we have a variant

00:20:14,420 --> 00:20:20,370
instead of not having the value or

00:20:16,980 --> 00:20:23,280
having some value we now can have any of

00:20:20,370 --> 00:20:27,540
the specified values inside so like a

00:20:23,280 --> 00:20:31,110
type say if they attacked Union where

00:20:27,540 --> 00:20:33,390
this is quite useful for for example in

00:20:31,110 --> 00:20:36,240
optional we just know that that value

00:20:33,390 --> 00:20:38,550
doesn't exist but we don't know the

00:20:36,240 --> 00:20:41,490
reason why it doesn't exist so one of

00:20:38,550 --> 00:20:43,680
the really common use cases for variant

00:20:41,490 --> 00:20:45,840
is to say okay we have a value or we

00:20:43,680 --> 00:20:48,780
have an error message so whether it's

00:20:45,840 --> 00:20:51,450
error code error message or pointer to

00:20:48,780 --> 00:20:54,270
Excel to an exception it's quite useful

00:20:51,450 --> 00:20:56,850
and if you want more about this you

00:20:54,270 --> 00:20:59,850
should check out Alex and rescues talk

00:20:56,850 --> 00:21:01,530
on effective error handling or something

00:20:59,850 --> 00:21:08,400
like that from City pick on a couple of

00:21:01,530 --> 00:21:11,220
decades years ago in order to access the

00:21:08,400 --> 00:21:14,850
values inside of a variant you can if

00:21:11,220 --> 00:21:17,610
you're sure that some some type is

00:21:14,850 --> 00:21:21,600
currently in a in a variant you can call

00:21:17,610 --> 00:21:24,420
STD yet if it's not there it will throw

00:21:21,600 --> 00:21:26,310
an exception and you can call if you

00:21:24,420 --> 00:21:29,610
just want to check whether the type is

00:21:26,310 --> 00:21:32,940
there and without any exceptions you can

00:21:29,610 --> 00:21:36,990
call get if it will return a null

00:21:32,940 --> 00:21:42,740
pointer yes instead of an option it

00:21:36,990 --> 00:21:42,740
returns are now pointed to but who cares

00:21:43,280 --> 00:21:50,880
now STD gate is the biggie atif are not

00:21:47,130 --> 00:21:53,250
really the best way to to check what

00:21:50,880 --> 00:21:57,630
what is inside of a variant you should

00:21:53,250 --> 00:22:00,180
always use the STD visit and with C++ 17

00:21:57,630 --> 00:22:04,500
we can easily create overloaded lambdas

00:22:00,180 --> 00:22:07,080
so you have a rudimentary way to do

00:22:04,500 --> 00:22:11,220
pattern matching you say visit

00:22:07,080 --> 00:22:13,440
overloaded for if we have an iterator

00:22:11,220 --> 00:22:16,980
call this lambda if we have exception

00:22:13,440 --> 00:22:19,050
pointer call this lambda and this looks

00:22:16,980 --> 00:22:21,150
and works really nice a visit will

00:22:19,050 --> 00:22:24,750
return the value returned by the land

00:22:21,150 --> 00:22:27,540
that has been called so it's not void

00:22:24,750 --> 00:22:32,430
it can you can really nicely chain all

00:22:27,540 --> 00:22:34,560
the holding locations again if somebody

00:22:32,430 --> 00:22:40,590
wants the explanation of the grayed out

00:22:34,560 --> 00:22:44,690
part I could rewind a bit later and we

00:22:40,590 --> 00:22:50,010
have as the DME which is not to be used

00:22:44,690 --> 00:22:53,100
then we have instead of using constant

00:22:50,010 --> 00:22:55,080
string graph and similar things in all

00:22:53,100 --> 00:22:57,360
of the places we should obviously use

00:22:55,080 --> 00:22:59,340
string view which is able to abstract

00:22:57,360 --> 00:23:02,940
over blah blah blah I think we had a

00:22:59,340 --> 00:23:04,920
talk at academy about truing views if

00:23:02,940 --> 00:23:08,610
not it will be at cute

00:23:04,920 --> 00:23:12,450
developer summit or whatever so you can

00:23:08,610 --> 00:23:16,620
check that talk instead and we had a

00:23:12,450 --> 00:23:18,720
couple of really amazing features again

00:23:16,620 --> 00:23:21,300
library features for people who write

00:23:18,720 --> 00:23:23,510
generic code and for example you're

00:23:21,300 --> 00:23:25,920
writing your own algorithm like copy if

00:23:23,510 --> 00:23:28,770
one of the argument arguments that

00:23:25,920 --> 00:23:30,480
you're going to get is a function now it

00:23:28,770 --> 00:23:32,670
can be a function it can be a function

00:23:30,480 --> 00:23:34,740
object it can be a pointer to a member

00:23:32,670 --> 00:23:37,740
function pointer to a member variable it

00:23:34,740 --> 00:23:41,010
can be an object castable to a function

00:23:37,740 --> 00:23:46,230
pointer or something like that and yeah

00:23:41,010 --> 00:23:49,770
I think so for the most part you can

00:23:46,230 --> 00:23:53,160
call them as f of open parenthesis

00:23:49,770 --> 00:23:55,050
argument close parenthesis but pointers

00:23:53,160 --> 00:23:56,940
to member functions and pointers to

00:23:55,050 --> 00:23:58,760
member variables you cannot call with

00:23:56,940 --> 00:24:01,230
the normal function call syntax and

00:23:58,760 --> 00:24:04,290
because obviously the language wasn't

00:24:01,230 --> 00:24:06,030
extended to support it the library guys

00:24:04,290 --> 00:24:08,790
decided okay we are going to do it

00:24:06,030 --> 00:24:12,270
because these lower level guys have just

00:24:08,790 --> 00:24:16,290
done so they implemented a function

00:24:12,270 --> 00:24:18,330
called STD invoke it gets any kind of

00:24:16,290 --> 00:24:21,090
callable so anything that I just

00:24:18,330 --> 00:24:23,370
enlisted and a list of arguments that

00:24:21,090 --> 00:24:25,260
you can pass to it so if you're writing

00:24:23,370 --> 00:24:29,250
generic code this is the way you should

00:24:25,260 --> 00:24:31,920
invoke your functions it looks ugly but

00:24:29,250 --> 00:24:35,040
it works for much more than normal

00:24:31,920 --> 00:24:38,010
function called syntax then we have STD

00:24:35,040 --> 00:24:38,850
apply which does almost the same but it

00:24:38,010 --> 00:24:40,680
doesn't get

00:24:38,850 --> 00:24:43,980
the arguments one by one but inside the

00:24:40,680 --> 00:24:46,890
tuple and we have a type trait is in

00:24:43,980 --> 00:24:48,540
vocal if you want to write meta programs

00:24:46,890 --> 00:24:54,090
and check for whether something is

00:24:48,540 --> 00:24:54,950
involve or not we got a really cool

00:24:54,090 --> 00:24:57,900
thing

00:24:54,950 --> 00:24:59,400
C++ seventeen introduced a lot of cool

00:24:57,900 --> 00:25:02,820
things into the library in the core

00:24:59,400 --> 00:25:11,310
language not as many five minutes okay

00:25:02,820 --> 00:25:13,230
so the Academy Awards is canceled so if

00:25:11,310 --> 00:25:15,810
you want to do a static introspection in

00:25:13,230 --> 00:25:18,330
old C++ it would be really really long

00:25:15,810 --> 00:25:19,620
and not understandable and now it's a

00:25:18,330 --> 00:25:22,950
little bit shorter and still not

00:25:19,620 --> 00:25:25,770
understandable so we have we can create

00:25:22,950 --> 00:25:28,020
a type trait that checks whether some

00:25:25,770 --> 00:25:30,540
type has a common column value type

00:25:28,020 --> 00:25:32,790
nasty type so most of the collections in

00:25:30,540 --> 00:25:35,220
standard library and cute has it so that

00:25:32,790 --> 00:25:39,600
you know queue list of T that it

00:25:35,220 --> 00:25:42,570
contains T and we can check with void T

00:25:39,600 --> 00:25:45,930
we can check whether some type actually

00:25:42,570 --> 00:25:47,760
exists if it doesn't exist then the

00:25:45,930 --> 00:25:50,850
thing where you used white t will be

00:25:47,760 --> 00:25:54,450
removed from the overload set so if we

00:25:50,850 --> 00:25:56,490
are going to pass T is an int the first

00:25:54,450 --> 00:26:00,740
one will pass because white t is empty

00:25:56,490 --> 00:26:04,230
so by default it will be false type if

00:26:00,740 --> 00:26:07,020
it goes to the next one it will check do

00:26:04,230 --> 00:26:09,240
i have int colon colon value type no i

00:26:07,020 --> 00:26:11,220
don't it will remove that from the

00:26:09,240 --> 00:26:13,770
overload set it's not a compiler error

00:26:11,220 --> 00:26:16,680
or anything else it's sub substitution

00:26:13,770 --> 00:26:19,110
failure is not nervous Vienna and then

00:26:16,680 --> 00:26:21,690
you will be able to use it has value

00:26:19,110 --> 00:26:23,330
type as an any type trait from the

00:26:21,690 --> 00:26:27,690
standard library

00:26:23,330 --> 00:26:30,420
what's more void T can even be used to

00:26:27,690 --> 00:26:34,920
check whether expression can be

00:26:30,420 --> 00:26:36,540
evaluated on a certain type so if this

00:26:34,920 --> 00:26:39,420
worked for collections that are well

00:26:36,540 --> 00:26:42,300
behaved and defined value type this

00:26:39,420 --> 00:26:44,970
would work on any eatable object so we

00:26:42,300 --> 00:26:47,460
need to have a begin that we call can

00:26:44,970 --> 00:26:50,070
call on the function we need to be able

00:26:47,460 --> 00:26:52,690
to dereference begin and that's the star

00:26:50,070 --> 00:26:55,330
begin off deck level of tea

00:26:52,690 --> 00:26:57,970
and we need to have the end iterator

00:26:55,330 --> 00:26:59,680
which will never be the referenced so we

00:26:57,970 --> 00:27:00,790
don't need to a store it and we don't

00:26:59,680 --> 00:27:03,940
need to check whether it can be

00:27:00,790 --> 00:27:08,350
dereferenced so we here we check for a

00:27:03,940 --> 00:27:12,280
TTIP T is star beginning of of a value

00:27:08,350 --> 00:27:14,770
of correct and is end of star of that

00:27:12,280 --> 00:27:20,020
value correct and again you can call it

00:27:14,770 --> 00:27:23,590
as any ordinary type trade and now in

00:27:20,020 --> 00:27:28,090
C++ now in C++ 20 we are going to get

00:27:23,590 --> 00:27:30,040
ranges algorithms have their problems

00:27:28,090 --> 00:27:32,410
with compressibility I'm now speeding up

00:27:30,040 --> 00:27:36,400
because I have only three minutes for

00:27:32,410 --> 00:27:38,350
three huge features so algorithms are

00:27:36,400 --> 00:27:41,050
cool to compose in a completely wrong

00:27:38,350 --> 00:27:44,530
way not in the right way so we are going

00:27:41,050 --> 00:27:47,230
to get ranges and instead of having

00:27:44,530 --> 00:27:49,630
temporaries and stuff you can just say

00:27:47,230 --> 00:27:52,990
copy items remove all the items that are

00:27:49,630 --> 00:27:55,180
selected and put them to output stream

00:27:52,990 --> 00:27:57,550
iterator to print them out and you can

00:27:55,180 --> 00:27:59,530
change these transformations just like

00:27:57,550 --> 00:28:01,780
you are in a normal functional

00:27:59,530 --> 00:28:06,160
programming language and with a much

00:28:01,780 --> 00:28:14,800
nicer syntax than SQL what's the problem

00:28:06,160 --> 00:28:17,890
here yeah although the compiler will not

00:28:14,800 --> 00:28:20,620
really say that it will say a lot a lot

00:28:17,890 --> 00:28:23,980
a lot a lot of a lot of our messages and

00:28:20,620 --> 00:28:25,960
one of them will be that you can't that

00:28:23,980 --> 00:28:28,120
there is no operator - on Lister

00:28:25,960 --> 00:28:29,710
iterator because it's not random access

00:28:28,120 --> 00:28:31,420
but that's something that you need to

00:28:29,710 --> 00:28:34,990
know that's not something that the

00:28:31,420 --> 00:28:37,240
compiler is going to tell you concepts

00:28:34,990 --> 00:28:40,270
which are implemented in GCC trunk and

00:28:37,240 --> 00:28:41,230
you can play around with them instead of

00:28:40,270 --> 00:28:43,360
writing templates

00:28:41,230 --> 00:28:46,960
typing something you write template

00:28:43,360 --> 00:28:49,420
concept name see and then when you try

00:28:46,960 --> 00:28:51,490
to call the function it will at compile

00:28:49,420 --> 00:28:58,630
time track where the data type satisfies

00:28:51,490 --> 00:29:03,280
the concept in front of it ok I'm going

00:28:58,630 --> 00:29:06,070
to skip this a bit you could write your

00:29:03,280 --> 00:29:06,550
own concept for example this concept

00:29:06,070 --> 00:29:08,440
checks

00:29:06,550 --> 00:29:10,540
something is call abou so that you don't

00:29:08,440 --> 00:29:12,730
need to accept functions as ordinary

00:29:10,540 --> 00:29:14,230
templates but you can communicate which

00:29:12,730 --> 00:29:17,620
is which are the arguments that you

00:29:14,230 --> 00:29:20,770
require and you can just say concept

00:29:17,620 --> 00:29:24,670
bull callable will be defined as in

00:29:20,770 --> 00:29:26,680
vocable of RF are X dot dot value and

00:29:24,670 --> 00:29:30,700
blah blah blah you all know what this

00:29:26,680 --> 00:29:33,220
means and when you define a function you

00:29:30,700 --> 00:29:37,330
can just write callable of bull comma

00:29:33,220 --> 00:29:40,450
int P and this is still a template

00:29:37,330 --> 00:29:42,460
that's one of the problems template is

00:29:40,450 --> 00:29:45,010
not written so it's implicitly template

00:29:42,460 --> 00:29:47,860
which can lead to problems for people

00:29:45,010 --> 00:29:49,780
who are writing libraries but it's a

00:29:47,860 --> 00:29:52,150
template it's not a steady function this

00:29:49,780 --> 00:29:54,640
is not going to be any slower than

00:29:52,150 --> 00:29:56,680
executing the code it's a normal

00:29:54,640 --> 00:30:00,100
template it's just that it's checked for

00:29:56,680 --> 00:30:04,330
P to be exactly something to satisfy

00:30:00,100 --> 00:30:07,060
some condition and then you all know

00:30:04,330 --> 00:30:09,160
what futures are you all know that it's

00:30:07,060 --> 00:30:13,720
a real problem to call dot get because

00:30:09,160 --> 00:30:16,120
it will block your system some futures

00:30:13,720 --> 00:30:19,920
have a dot then to chain the

00:30:16,120 --> 00:30:23,110
continuations which is cool but ugly and

00:30:19,920 --> 00:30:26,290
cute has the most ugly solution of them

00:30:23,110 --> 00:30:28,900
all creating a future watcher that you

00:30:26,290 --> 00:30:30,790
can connect to and the last line is

00:30:28,900 --> 00:30:33,040
missing you need to set watch a set

00:30:30,790 --> 00:30:34,660
future this one and this is how you

00:30:33,040 --> 00:30:40,510
change continuations in queue it which

00:30:34,660 --> 00:30:44,560
is so one of the proposal that is most

00:30:40,510 --> 00:30:47,650
likely to get into C++ 20ms to introduce

00:30:44,560 --> 00:30:49,870
two new ugly keywords one is called call

00:30:47,650 --> 00:30:54,220
await and the other is called curry turn

00:30:49,870 --> 00:30:57,370
what this is doing for example if V is a

00:30:54,220 --> 00:31:00,790
future value it will suspend the current

00:30:57,370 --> 00:31:03,520
function until that value arise it will

00:31:00,790 --> 00:31:05,290
not suspend your main program so just

00:31:03,520 --> 00:31:07,650
temporary pause the function and

00:31:05,290 --> 00:31:11,560
continue working on and everything else

00:31:07,650 --> 00:31:14,680
and then you can have a couple of

00:31:11,560 --> 00:31:16,930
cooperates for each of them it will be

00:31:14,680 --> 00:31:18,700
suspended at tilt until the value arise

00:31:16,930 --> 00:31:19,940
until the value arise until the value

00:31:18,700 --> 00:31:24,830
arise and

00:31:19,940 --> 00:31:26,809
yes a couple of sentences more the thing

00:31:24,830 --> 00:31:29,120
to notice here is that we are returning

00:31:26,809 --> 00:31:31,250
a future since we have a function that

00:31:29,120 --> 00:31:33,590
is going to be suspended and it's call

00:31:31,250 --> 00:31:35,659
are expected to finish immediately it

00:31:33,590 --> 00:31:38,509
cannot actually wait it needs again to

00:31:35,659 --> 00:31:41,840
return a future so Cove 8 & Co return

00:31:38,509 --> 00:31:43,970
need to can be used to chain stuff you

00:31:41,840 --> 00:31:46,779
cannot ever actually return on your

00:31:43,970 --> 00:31:48,980
normal value and till you call a target

00:31:46,779 --> 00:31:52,220
but most of the time you don't need it

00:31:48,980 --> 00:31:54,740
and it doesn't need to be used on a

00:31:52,220 --> 00:31:59,350
synchronous stuff only you can use it on

00:31:54,740 --> 00:32:03,370
any I'm not I'm going to say more ads

00:31:59,350 --> 00:32:07,399
like optionals so instead of checking if

00:32:03,370 --> 00:32:10,639
not value return you can just say call

00:32:07,399 --> 00:32:13,039
await optional value if the optional

00:32:10,639 --> 00:32:15,620
value is not there it will just jump to

00:32:13,039 --> 00:32:18,919
the exit and return and not an empty

00:32:15,620 --> 00:32:21,409
optional otherwise value will get that

00:32:18,919 --> 00:32:25,970
value process it and return an optional

00:32:21,409 --> 00:32:28,850
that has a result in it and with just

00:32:25,970 --> 00:32:30,820
two minutes over the over the limit I'm

00:32:28,850 --> 00:32:37,140
finished

00:32:30,820 --> 00:32:37,140

YouTube URL: https://www.youtube.com/watch?v=ewkcfg-88-g


