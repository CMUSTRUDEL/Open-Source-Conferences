Title: Akademy 2021 - ARM Memory Tagging Extension Fighting Memory Unsafety with Hardware
Publication date: 2021-06-28
Playlist: Akademy 2021
Description: 
	By Alexander Saoutkin
Qt and by extension C++ is the technical pillar of the KDE community that has served us well since our inception. However, there is no such thing as a free lunch; the performance and expressive power of C++ comes at a hefty price - it is memory unsafe. In turn, users experience crashes, odd behaviour and often ample opportunity for attackers to turn memory unsafety into powerful exploits.
A variety of tools and techniques have been introduced to eliminate (but mostly to prevent and mitigate) the drawbacks of memory unsafe languages, but a lot of these tools are difficult to use and often have prohibitive overheads. The ARM Memory Tagging Extension (MTE) is a new hardware feature expected in ARMv8.5+ processors that allows metadata (i.e. tags) to be attributed to both memory and pointers. As will be seen in the talk, this can be used to prevent a wide variety of common memory related bugs with overheads low enough that one can use it as a security mitigation in production as well as a debugging tool.
In addition, this feature opens up the possibility of other non-conventional use cases, such as being able to set infinite watchpoints, which in addition can be enhanced to create a race detector. These will be briefly discussed as well and hopefully will inspire future interesting use cases for this new versatile extension.
Captions: 
	00:00:01,110 --> 00:00:08,580
[Music]

00:00:12,080 --> 00:00:18,160
hi everybody and welcome back

00:00:14,559 --> 00:00:20,800
uh the next talk will be quite hardcore

00:00:18,160 --> 00:00:21,600
it will be by alex uh our memory tagging

00:00:20,800 --> 00:00:23,279
extension

00:00:21,600 --> 00:00:25,359
fighting memory uncertainty with

00:00:23,279 --> 00:00:30,240
hardware awesome

00:00:25,359 --> 00:00:32,480
so give a warm welcome to alex

00:00:30,240 --> 00:00:33,440
thank everyone thank you evan for the uh

00:00:32,480 --> 00:00:37,520
um

00:00:33,440 --> 00:00:39,760
introduction um let me just see so

00:00:37,520 --> 00:00:41,360
today my talk is on the r memory tagging

00:00:39,760 --> 00:00:43,870
extension of course

00:00:41,360 --> 00:00:44,960
um so my name is alex

00:00:43,870 --> 00:00:47,280
[Music]

00:00:44,960 --> 00:00:48,640
i've been the developer for about two

00:00:47,280 --> 00:00:51,440
years i think now

00:00:48,640 --> 00:00:52,079
i'm working mostly on carrier fuse but

00:00:51,440 --> 00:00:53,920
this

00:00:52,079 --> 00:00:57,280
talk is quite different something i've

00:00:53,920 --> 00:00:59,199
been working on recently

00:00:57,280 --> 00:01:00,320
and studying and i thought might be

00:00:59,199 --> 00:01:00,879
interesting for the rest of you as well

00:01:00,320 --> 00:01:03,440
uh

00:01:00,879 --> 00:01:05,040
in the kd community um just one quick

00:01:03,440 --> 00:01:09,920
thing i definitely have control

00:01:05,040 --> 00:01:09,920
of the stuff in the in the presentation

00:01:10,159 --> 00:01:14,640
so i definitely can change the slides at

00:01:12,320 --> 00:01:14,640
the moment

00:01:16,720 --> 00:01:19,520
okay we're back in

00:01:20,640 --> 00:01:25,680
okay so on to the next slide

00:01:24,000 --> 00:01:27,920
so before we go into the r memory

00:01:25,680 --> 00:01:30,159
tagging extension full on

00:01:27,920 --> 00:01:31,040
i want to go into the motivation behind

00:01:30,159 --> 00:01:32,720
this or

00:01:31,040 --> 00:01:34,720
why would we need this new hardware

00:01:32,720 --> 00:01:38,000
feature

00:01:34,720 --> 00:01:41,280
so the reason why we need it is because

00:01:38,000 --> 00:01:43,520
we use c and c plus plus sync

00:01:41,280 --> 00:01:44,880
and when you use cnc plus first you're

00:01:43,520 --> 00:01:48,640
going to it is a memory

00:01:44,880 --> 00:01:48,640
unsafe language um

00:01:49,360 --> 00:01:53,280
and it has positives but it also has

00:01:51,920 --> 00:01:55,280
negatives

00:01:53,280 --> 00:01:56,560
so first of all what does it mean for a

00:01:55,280 --> 00:02:00,079
language to remember unsafe

00:01:56,560 --> 00:02:02,079
well first and foremost you have access

00:02:00,079 --> 00:02:03,600
to pointers and you're able to

00:02:02,079 --> 00:02:06,240
manipulate them as you wish you're able

00:02:03,600 --> 00:02:08,080
to do arbitrary point of arithmetic

00:02:06,240 --> 00:02:10,080
not just indexing to an array but a lot

00:02:08,080 --> 00:02:14,239
more pretty much anything goes

00:02:10,080 --> 00:02:17,440
as long as you do it correctly and

00:02:14,239 --> 00:02:21,280
this provides some advantages so

00:02:17,440 --> 00:02:22,959
you know you manage memory by yourself

00:02:21,280 --> 00:02:24,640
you decide when it's when you allocate

00:02:22,959 --> 00:02:26,400
from the heap when you de-allocate from

00:02:24,640 --> 00:02:28,560
the heap

00:02:26,400 --> 00:02:28,560
and

00:02:29,440 --> 00:02:33,599
this can be quite useful if you don't

00:02:30,800 --> 00:02:35,519
use like a a language that has automatic

00:02:33,599 --> 00:02:36,800
memory management so java has a garbage

00:02:35,519 --> 00:02:40,239
collector that you can use uh

00:02:36,800 --> 00:02:40,720
python similarly and in many cases you

00:02:40,239 --> 00:02:43,200
do want

00:02:40,720 --> 00:02:44,160
fine grain control so for example if

00:02:43,200 --> 00:02:46,080
you're

00:02:44,160 --> 00:02:47,519
writing a game you might know beforehand

00:02:46,080 --> 00:02:50,800
how much memory you need

00:02:47,519 --> 00:02:53,599
and dynamically allocating memory

00:02:50,800 --> 00:02:55,280
um concern times especially in games can

00:02:53,599 --> 00:02:56,640
be performance and sensitive

00:02:55,280 --> 00:02:58,640
so if you know how much memory you need

00:02:56,640 --> 00:03:00,959
you can just allocate it in one chunk

00:02:58,640 --> 00:03:02,159
ready to go once the round is over for

00:03:00,959 --> 00:03:04,080
example

00:03:02,159 --> 00:03:06,560
you beat the boss you can de-allocate

00:03:04,080 --> 00:03:07,840
the memory and go to the next one

00:03:06,560 --> 00:03:10,959
um but you know there's no such thing as

00:03:07,840 --> 00:03:14,400
a free lunch so what do i mean by this

00:03:10,959 --> 00:03:16,239
well managing memory yourself is hard

00:03:14,400 --> 00:03:19,200
you have to think about the lifetime of

00:03:16,239 --> 00:03:20,720
your memory um who owns this memory when

00:03:19,200 --> 00:03:21,920
should be free and who's responsible for

00:03:20,720 --> 00:03:24,239
freeing it

00:03:21,920 --> 00:03:25,200
um you know and the text needs to solve

00:03:24,239 --> 00:03:27,440
it and you know

00:03:25,200 --> 00:03:28,720
a lot of time we do it correctly but a

00:03:27,440 --> 00:03:30,159
lot of the time we don't

00:03:28,720 --> 00:03:33,680
and this is where the real stinger comes

00:03:30,159 --> 00:03:36,000
in so you know if you do it incorrectly

00:03:33,680 --> 00:03:37,120
um you invoke you know undefined

00:03:36,000 --> 00:03:39,280
behavior

00:03:37,120 --> 00:03:41,200
once you do something um incorrectly

00:03:39,280 --> 00:03:43,519
related to memory

00:03:41,200 --> 00:03:44,959
uh you know for example double free i'll

00:03:43,519 --> 00:03:48,480
go into into more detail

00:03:44,959 --> 00:03:50,959
even invoked undefined behavior so but

00:03:48,480 --> 00:03:52,640
what does that mean well let's define

00:03:50,959 --> 00:03:53,439
under behavior first undefined behavior

00:03:52,640 --> 00:03:54,720
first

00:03:53,439 --> 00:03:56,560
so i'll write out the definition

00:03:54,720 --> 00:03:58,720
straight from the standard

00:03:56,560 --> 00:04:00,720
underlying behavior as behavior upon use

00:03:58,720 --> 00:04:01,760
of a non-portable or erroneous program

00:04:00,720 --> 00:04:04,319
construct

00:04:01,760 --> 00:04:06,159
or of erroneous data for which this

00:04:04,319 --> 00:04:09,439
international standard imposes

00:04:06,159 --> 00:04:13,120
no requirements what does this mean

00:04:09,439 --> 00:04:16,160
a person implementing this the language

00:04:13,120 --> 00:04:16,799
has no requirement they don't have to do

00:04:16,160 --> 00:04:20,079
anything

00:04:16,799 --> 00:04:23,040
in response to this behavior so

00:04:20,079 --> 00:04:24,320
they could ignore it um they could you

00:04:23,040 --> 00:04:24,800
know print something out if they wanted

00:04:24,320 --> 00:04:27,680
to

00:04:24,800 --> 00:04:28,800
no one could complain really um they

00:04:27,680 --> 00:04:29,520
just point to the standard and be like

00:04:28,800 --> 00:04:34,160
okay that's

00:04:29,520 --> 00:04:34,160
not my problem anymore um and so

00:04:34,320 --> 00:04:38,000
you know what a user for example you

00:04:36,400 --> 00:04:38,639
know might commonly see a segmentation

00:04:38,000 --> 00:04:40,080
fault

00:04:38,639 --> 00:04:42,400
and you might experience some logical

00:04:40,080 --> 00:04:45,600
bug um which might be

00:04:42,400 --> 00:04:46,639
crazy who knows um so why have we

00:04:45,600 --> 00:04:48,479
allowed you know

00:04:46,639 --> 00:04:49,840
undefined behavior to be a thing why

00:04:48,479 --> 00:04:51,759
don't we define the behavior why don't

00:04:49,840 --> 00:04:53,280
we do something like in java where

00:04:51,759 --> 00:04:55,280
if there's an off by one error we just

00:04:53,280 --> 00:04:57,280
raise a array index out of bounds

00:04:55,280 --> 00:05:00,080
exception for example

00:04:57,280 --> 00:05:02,160
well these checks aren't free um they

00:05:00,080 --> 00:05:03,120
have a runtime cost which you might not

00:05:02,160 --> 00:05:06,160
want to pay

00:05:03,120 --> 00:05:06,960
in certain scenarios the compiler writer

00:05:06,160 --> 00:05:08,560
also

00:05:06,960 --> 00:05:10,479
would like an easier time i mean cbs

00:05:08,560 --> 00:05:12,240
plus is hard enough to implement bytes

00:05:10,479 --> 00:05:13,759
as it is and you know thinking about

00:05:12,240 --> 00:05:16,800
runtime checks

00:05:13,759 --> 00:05:18,560
um you know can be annoying um

00:05:16,800 --> 00:05:20,320
also assuming a program doesn't have

00:05:18,560 --> 00:05:22,400
undefined behavior allows you to do some

00:05:20,320 --> 00:05:24,720
optimizations which again if your

00:05:22,400 --> 00:05:26,960
program does have undefined behavior

00:05:24,720 --> 00:05:29,199
can result in some weirdly generated

00:05:26,960 --> 00:05:29,199
code

00:05:29,520 --> 00:05:33,440
so okay well okay you know you might get

00:05:31,919 --> 00:05:36,080
some memory safety bugs

00:05:33,440 --> 00:05:38,400
um are they common is there even a

00:05:36,080 --> 00:05:41,919
problem can we just shrug it off

00:05:38,400 --> 00:05:42,240
well they cause countless bugs um you

00:05:41,919 --> 00:05:45,120
know

00:05:42,240 --> 00:05:46,320
just from singapore crashes um to

00:05:45,120 --> 00:05:48,000
security bugs so

00:05:46,320 --> 00:05:49,199
you know all the way back into actually

00:05:48,000 --> 00:05:50,960
that's how i was wrong i wasn't 98 it

00:05:49,199 --> 00:05:53,840
was 1988

00:05:50,960 --> 00:05:55,120
so this was more than 30 years ago the

00:05:53,840 --> 00:05:57,039
morris worm

00:05:55,120 --> 00:05:58,800
um i think it took advantage of a simple

00:05:57,039 --> 00:06:00,319
buffer overflow and took down large

00:05:58,800 --> 00:06:02,000
chunks of the internet at the time

00:06:00,319 --> 00:06:03,360
which was quite small but still managed

00:06:02,000 --> 00:06:04,960
to cause

00:06:03,360 --> 00:06:06,639
an estimated 10 million dollars in

00:06:04,960 --> 00:06:08,639
damage and

00:06:06,639 --> 00:06:10,720
morris the one who created the um the

00:06:08,639 --> 00:06:13,280
worm was put in prison

00:06:10,720 --> 00:06:14,560
so damage can seriously be done and more

00:06:13,280 --> 00:06:16,880
recently we can see for example

00:06:14,560 --> 00:06:18,960
heartbleed which in 2014

00:06:16,880 --> 00:06:20,080
was an open ssl bug i believe also

00:06:18,960 --> 00:06:23,600
simple above overflow

00:06:20,080 --> 00:06:26,560
very simple to catch um

00:06:23,600 --> 00:06:27,600
it affected you know pretty much half

00:06:26,560 --> 00:06:30,960
the internet um

00:06:27,600 --> 00:06:32,319
half of https sites which basically

00:06:30,960 --> 00:06:34,560
rendered them useless because you know

00:06:32,319 --> 00:06:37,600
you could read out private keys

00:06:34,560 --> 00:06:37,919
um and then so and https wasn't really a

00:06:37,600 --> 00:06:41,280
thing

00:06:37,919 --> 00:06:42,880
until you patched it um and chromium

00:06:41,280 --> 00:06:45,759
have done you know their research and

00:06:42,880 --> 00:06:47,120
you know they've looked at their bugs

00:06:45,759 --> 00:06:48,080
their serious security bugs high

00:06:47,120 --> 00:06:50,240
severity

00:06:48,080 --> 00:06:51,840
and 70 of them can be attributed to

00:06:50,240 --> 00:06:54,160
memory safety problems so

00:06:51,840 --> 00:06:57,360
the bigger security bugs fundamentally

00:06:54,160 --> 00:07:00,319
come because of memory safety

00:06:57,360 --> 00:07:01,039
now again okay well another thing is

00:07:00,319 --> 00:07:03,280
that

00:07:01,039 --> 00:07:04,800
c and c plus plus programs are very

00:07:03,280 --> 00:07:07,360
common

00:07:04,800 --> 00:07:09,199
um you know so we can see all the stats

00:07:07,360 --> 00:07:10,560
here you know apache and n jinx have

00:07:09,199 --> 00:07:12,880
quite a large share of the web server

00:07:10,560 --> 00:07:14,479
market google chrome is 64

00:07:12,880 --> 00:07:16,000
of the web browser market windows a

00:07:14,479 --> 00:07:18,240
large chunk of the desktop market

00:07:16,000 --> 00:07:19,919
android similarly and you know some of

00:07:18,240 --> 00:07:21,919
your notices being like well okay google

00:07:19,919 --> 00:07:24,400
chrome sixty four percent but i mean

00:07:21,919 --> 00:07:27,440
firefox or perhaps they're also all

00:07:24,400 --> 00:07:28,880
pretty much written in c and c plus plus

00:07:27,440 --> 00:07:30,639
why are we singling this out so you're

00:07:28,880 --> 00:07:32,319
correct to note that pretty much all

00:07:30,639 --> 00:07:33,680
critical you know infrastructure that we

00:07:32,319 --> 00:07:36,160
use today

00:07:33,680 --> 00:07:37,680
from kernels to browsers and stuff like

00:07:36,160 --> 00:07:39,919
this are written cnc

00:07:37,680 --> 00:07:40,880
plus but what makes it really bad is

00:07:39,919 --> 00:07:42,080
that

00:07:40,880 --> 00:07:44,319
a lot of the software has pretty much

00:07:42,080 --> 00:07:46,240
monopoly status so if you're looking at

00:07:44,319 --> 00:07:48,400
a nation-state attacker or

00:07:46,240 --> 00:07:50,960
just somebody who wants to make money

00:07:48,400 --> 00:07:50,960
from hacking

00:07:51,599 --> 00:07:55,360
finding a vulnerability in google chrome

00:07:56,160 --> 00:08:00,560
if you can easily exploit it and you can

00:07:58,160 --> 00:08:01,599
reach 64 of the web browsers or of web

00:08:00,560 --> 00:08:03,360
users

00:08:01,599 --> 00:08:04,479
um the math checks out you want to

00:08:03,360 --> 00:08:04,960
exploit it you want to look for these

00:08:04,479 --> 00:08:06,240
bugs

00:08:04,960 --> 00:08:08,160
you don't just come across them you want

00:08:06,240 --> 00:08:11,840
to hunt for them so this kind of

00:08:08,160 --> 00:08:12,879
monopoly status also has a big effect

00:08:11,840 --> 00:08:14,720
well okay well i mean you know i've

00:08:12,879 --> 00:08:18,560
talked about google chrome

00:08:14,720 --> 00:08:21,199
uh apache engine x why should kid eca

00:08:18,560 --> 00:08:23,280
well i mean we a lot of our software's

00:08:21,199 --> 00:08:25,599
written you know

00:08:23,280 --> 00:08:27,280
on top of the linux kernel in user space

00:08:25,599 --> 00:08:29,840
um there's also a lot of user say

00:08:27,280 --> 00:08:30,639
space uh software that we use you know

00:08:29,840 --> 00:08:32,959
so maybe

00:08:30,639 --> 00:08:34,159
weyland is also written in c stuff like

00:08:32,959 --> 00:08:35,760
this

00:08:34,159 --> 00:08:37,200
and obviously we write most of our

00:08:35,760 --> 00:08:40,080
software in c

00:08:37,200 --> 00:08:40,959
or in c plus and sometimes in c here and

00:08:40,080 --> 00:08:43,120
there

00:08:40,959 --> 00:08:44,800
and you know and our biggest libraries

00:08:43,120 --> 00:08:48,240
that we use you know q

00:08:44,800 --> 00:08:49,440
again c plus plus so you know we're also

00:08:48,240 --> 00:08:52,640
part of this problem well

00:08:49,440 --> 00:08:55,519
experiencing this problem and

00:08:52,640 --> 00:08:56,720
you know all you developers you bound to

00:08:55,519 --> 00:08:58,240
deal with crash reports and

00:08:56,720 --> 00:09:00,160
a lot of these are probably triages very

00:08:58,240 --> 00:09:00,720
high importance if i go through next

00:09:00,160 --> 00:09:02,560
blog

00:09:00,720 --> 00:09:04,720
quite a few crashes so guys we're not

00:09:02,560 --> 00:09:07,760
perfect um so

00:09:04,720 --> 00:09:08,480
we've got a lot of work to do and you

00:09:07,760 --> 00:09:11,279
know

00:09:08,480 --> 00:09:13,760
crashes you know security bugs um weird

00:09:11,279 --> 00:09:15,200
behavior caused by memory safety bugs

00:09:13,760 --> 00:09:18,000
and turns our users away and we want

00:09:15,200 --> 00:09:21,839
people to use our software

00:09:18,000 --> 00:09:23,120
so before i go further i want to just uh

00:09:21,839 --> 00:09:24,480
kind of refresh ourselves a bit

00:09:23,120 --> 00:09:26,800
so this is the virtual address space

00:09:24,480 --> 00:09:27,440
layout for a single process um so you

00:09:26,800 --> 00:09:28,959
can see

00:09:27,440 --> 00:09:30,880
the the bottom of the address space is

00:09:28,959 --> 00:09:31,839
at the bottom of the slide and at the

00:09:30,880 --> 00:09:36,000
top of the address

00:09:31,839 --> 00:09:37,200
space um we have the stack for example

00:09:36,000 --> 00:09:38,560
and the stack starts at the top of the

00:09:37,200 --> 00:09:40,240
address space and goes downwards on

00:09:38,560 --> 00:09:41,600
linux at least

00:09:40,240 --> 00:09:43,279
and at the bottom you can see the text

00:09:41,600 --> 00:09:45,360
segment which is just um

00:09:43,279 --> 00:09:46,399
the instructions of the program you're

00:09:45,360 --> 00:09:47,839
running

00:09:46,399 --> 00:09:50,959
the data is you know some initialized

00:09:47,839 --> 00:09:53,600
data at the beginning of the startup

00:09:50,959 --> 00:09:55,120
and the heap has dynamically allocated

00:09:53,600 --> 00:09:55,680
memory that you can get from you know

00:09:55,120 --> 00:09:58,640
malloc

00:09:55,680 --> 00:09:59,360
or new or you know make unique make

00:09:58,640 --> 00:10:02,959
shared

00:09:59,360 --> 00:10:07,279
etc and the heap similarly grows

00:10:02,959 --> 00:10:07,279
upwards starting from lower addresses

00:10:07,920 --> 00:10:12,079
and to know that the shared libraries

00:10:10,480 --> 00:10:15,200
are stuff like you know well for example

00:10:12,079 --> 00:10:16,480
q q is uh maybe dynamically linked and

00:10:15,200 --> 00:10:18,480
so

00:10:16,480 --> 00:10:20,720
the process will start up and put the

00:10:18,480 --> 00:10:22,000
shared libraries in the correct space

00:10:20,720 --> 00:10:24,079
so that you can call into it and it's

00:10:22,000 --> 00:10:25,600
all good and

00:10:24,079 --> 00:10:28,800
knowing that is useful for later so keep

00:10:25,600 --> 00:10:31,120
that in mind um the stack is managed by

00:10:28,800 --> 00:10:32,000
well at runtime with you know

00:10:31,120 --> 00:10:34,640
instructions

00:10:32,000 --> 00:10:35,600
um the way the stack is used is managed

00:10:34,640 --> 00:10:37,360
by the compiler

00:10:35,600 --> 00:10:39,040
in the code generation so during compile

00:10:37,360 --> 00:10:41,440
time um

00:10:39,040 --> 00:10:42,079
and the way the heap looks is managed by

00:10:41,440 --> 00:10:44,720
the um

00:10:42,079 --> 00:10:45,360
memory allocator code so usually jlipsy

00:10:44,720 --> 00:10:49,200
at least on

00:10:45,360 --> 00:10:49,680
linux okay so let's look at our first

00:10:49,200 --> 00:10:51,839
kind of

00:10:49,680 --> 00:10:54,240
um type of memory safety bug that you

00:10:51,839 --> 00:10:56,079
can run into

00:10:54,240 --> 00:10:58,000
so we have a simple function here that's

00:10:56,079 --> 00:11:00,079
vulnerable to a stack overflow

00:10:58,000 --> 00:11:01,680
why well this function takes in two

00:11:00,079 --> 00:11:02,880
arguments that it doesn't use but you'll

00:11:01,680 --> 00:11:06,079
see the next slide why i

00:11:02,880 --> 00:11:06,079
wanted to put them there

00:11:06,320 --> 00:11:13,760
and we allocate a buffer of 100 bytes

00:11:10,560 --> 00:11:15,920
and then we take an user input and put

00:11:13,760 --> 00:11:18,000
it into this buffer

00:11:15,920 --> 00:11:19,760
now scanf does not does not do any

00:11:18,000 --> 00:11:21,120
bounce checking of the input

00:11:19,760 --> 00:11:23,920
it just assumes that you know you're not

00:11:21,120 --> 00:11:27,920
going to use any more than 100 bytes

00:11:23,920 --> 00:11:29,600
and that is not an okay assumption

00:11:27,920 --> 00:11:31,680
especially if somebody malicious

00:11:29,600 --> 00:11:32,720
uh has an opportunity to put some stuff

00:11:31,680 --> 00:11:34,880
there

00:11:32,720 --> 00:11:36,160
so if it is overrun either on purpose or

00:11:34,880 --> 00:11:38,800
by accident

00:11:36,160 --> 00:11:40,640
um you have a stack overflow so what's

00:11:38,800 --> 00:11:43,680
the problem here

00:11:40,640 --> 00:11:46,880
well not only can i crash a program

00:11:43,680 --> 00:11:48,000
um they can also be used um as an

00:11:46,880 --> 00:11:51,040
exploit

00:11:48,000 --> 00:11:53,040
so let's get ourselves into the minds of

00:11:51,040 --> 00:11:56,720
an attacker

00:11:53,040 --> 00:11:57,120
so the attacker will want to insert

00:11:56,720 --> 00:11:59,760
input

00:11:57,120 --> 00:12:00,560
sometimes called shell code that allow

00:11:59,760 --> 00:12:02,560
the attacker

00:12:00,560 --> 00:12:05,040
to take control of the program to take

00:12:02,560 --> 00:12:07,519
control of the execution flow

00:12:05,040 --> 00:12:08,880
so what does this mean well let's take a

00:12:07,519 --> 00:12:12,320
look at the um

00:12:08,880 --> 00:12:14,560
at an example stack frame so we have the

00:12:12,320 --> 00:12:17,440
local variable buff at the bottom here

00:12:14,560 --> 00:12:19,120
um near the bottom of the stack and when

00:12:17,440 --> 00:12:21,360
you fill your data in

00:12:19,120 --> 00:12:22,399
in in the buffer it will kind of climb

00:12:21,360 --> 00:12:25,200
upwards

00:12:22,399 --> 00:12:25,600
so if you if you fill up the buffer if

00:12:25,200 --> 00:12:27,839
you go

00:12:25,600 --> 00:12:28,959
if you start to overflow the buffer

00:12:27,839 --> 00:12:32,800
you're going to overwrite

00:12:28,959 --> 00:12:34,079
you know kind of the bookkeeping needed

00:12:32,800 --> 00:12:35,440
um to actually run your program

00:12:34,079 --> 00:12:36,160
correctly to set up the stack frames

00:12:35,440 --> 00:12:38,480
correctly

00:12:36,160 --> 00:12:40,480
so in this case you know you need a you

00:12:38,480 --> 00:12:42,639
might need a save frame pointer if

00:12:40,480 --> 00:12:44,079
a framework is generated you'll need a

00:12:42,639 --> 00:12:45,600
return address to know

00:12:44,079 --> 00:12:47,680
what function to go back to once you're

00:12:45,600 --> 00:12:50,720
done in this function

00:12:47,680 --> 00:12:52,720
and you also might have um

00:12:50,720 --> 00:12:54,639
some inputs on the stack sometimes not

00:12:52,720 --> 00:12:59,200
sometimes there is

00:12:54,639 --> 00:12:59,200
in this case i assume it is so

00:12:59,680 --> 00:13:02,880
what an attacker will want to do is

00:13:01,920 --> 00:13:05,680
they'll want to

00:13:02,880 --> 00:13:07,360
put in code so the show code is stuff

00:13:05,680 --> 00:13:08,720
that they want to execute

00:13:07,360 --> 00:13:11,279
and they want to overwrite their return

00:13:08,720 --> 00:13:12,160
address such that it points back into

00:13:11,279 --> 00:13:14,320
the shell code

00:13:12,160 --> 00:13:16,000
so it points into code that they

00:13:14,320 --> 00:13:17,600
themselves have inputted

00:13:16,000 --> 00:13:20,399
and so the show code might for example

00:13:17,600 --> 00:13:22,000
if we're exploiting apache we might want

00:13:20,399 --> 00:13:24,800
to open a root shell

00:13:22,000 --> 00:13:26,240
because apache commonly runs its route

00:13:24,800 --> 00:13:27,680
and wants it to be accessible over the

00:13:26,240 --> 00:13:29,839
internet

00:13:27,680 --> 00:13:31,440
great um i mean you have a root shell of

00:13:29,839 --> 00:13:35,440
a server

00:13:31,440 --> 00:13:38,720
game over so you might know something

00:13:35,440 --> 00:13:40,480
well how do i know exactly where the

00:13:38,720 --> 00:13:42,560
return address is

00:13:40,480 --> 00:13:43,839
but sometimes it's an obvious if you

00:13:42,560 --> 00:13:45,360
have access to the source code maybe you

00:13:43,839 --> 00:13:47,440
could figure it out you can compile the

00:13:45,360 --> 00:13:50,720
program play with it locally

00:13:47,440 --> 00:13:54,959
sometimes you might not be so lucky

00:13:50,720 --> 00:13:56,320
um so the first question is do i need to

00:13:54,959 --> 00:13:58,399
guess exactly where the return address

00:13:56,320 --> 00:14:01,199
is when i'm designing my shell code

00:13:58,399 --> 00:14:02,320
no just write it many times as a suffix

00:14:01,199 --> 00:14:05,519
if you can

00:14:02,320 --> 00:14:07,440
and then one normal hit

00:14:05,519 --> 00:14:09,279
okay well what should my return address

00:14:07,440 --> 00:14:10,639
be well

00:14:09,279 --> 00:14:13,440
it should point into the shell code

00:14:10,639 --> 00:14:14,720
somewhere but if we're off by a bit

00:14:13,440 --> 00:14:16,720
we might just crash the program we won't

00:14:14,720 --> 00:14:20,160
execute the shell code we want

00:14:16,720 --> 00:14:21,839
well we're in luck um we can use certain

00:14:20,160 --> 00:14:23,440
knock instructions so no operation it

00:14:21,839 --> 00:14:25,920
doesn't do anything

00:14:23,440 --> 00:14:29,199
and we can prefix our show code with it

00:14:25,920 --> 00:14:31,600
and then hopefully our return address

00:14:29,199 --> 00:14:33,279
we'll pop back in and it'll hit if it

00:14:31,600 --> 00:14:34,959
hits any of the knock instructions

00:14:33,279 --> 00:14:36,399
it's just going to call not not not

00:14:34,959 --> 00:14:39,600
until it starts onto our real

00:14:36,399 --> 00:14:42,880
shell code and then hopefully

00:14:39,600 --> 00:14:44,079
we're good now obviously you hope that

00:14:42,880 --> 00:14:45,519
the buff is large enough for you to kind

00:14:44,079 --> 00:14:49,440
of pull this off so

00:14:45,519 --> 00:14:50,959
if you've overflowed a four byte buffer

00:14:49,440 --> 00:14:53,040
i mean good luck getting any decent

00:14:50,959 --> 00:14:54,480
amount of shock hood um but if it's

00:14:53,040 --> 00:14:56,800
bigger like 100 bytes you could probably

00:14:54,480 --> 00:14:58,000
pull something off

00:14:56,800 --> 00:15:01,040
and these are quite common because you

00:14:58,000 --> 00:15:02,639
have access to change the return address

00:15:01,040 --> 00:15:04,079
so this has been around for you know

00:15:02,639 --> 00:15:04,959
well since the inception of c since the

00:15:04,079 --> 00:15:08,480
exception of c

00:15:04,959 --> 00:15:13,360
plus have we just been sitting there no

00:15:08,480 --> 00:15:16,079
so the first mitigation for this type of

00:15:13,360 --> 00:15:17,519
potential exploit is write or execute

00:15:16,079 --> 00:15:22,240
pages

00:15:17,519 --> 00:15:22,240
so um

00:15:23,360 --> 00:15:26,959
usually i am trying to allocate pages

00:15:25,680 --> 00:15:29,440
and

00:15:26,959 --> 00:15:30,560
at the time there was no requirement if

00:15:29,440 --> 00:15:33,759
you know if you could do

00:15:30,560 --> 00:15:35,040
write execute or read pages but

00:15:33,759 --> 00:15:37,680
the question is why is the stack

00:15:35,040 --> 00:15:37,680
executable

00:15:38,480 --> 00:15:42,079
it shouldn't really be executable we

00:15:40,160 --> 00:15:43,440
shouldn't want to execute code that the

00:15:42,079 --> 00:15:45,519
user has put in that doesn't really make

00:15:43,440 --> 00:15:46,959
too much sense

00:15:45,519 --> 00:15:48,880
so why don't do we establish a

00:15:46,959 --> 00:15:50,399
requirement and say

00:15:48,880 --> 00:15:52,880
you can have a page and you can either

00:15:50,399 --> 00:15:56,480
write to it or you can execute it

00:15:52,880 --> 00:15:57,680
but not both and so how will this stop

00:15:56,480 --> 00:15:59,199
our previous attack

00:15:57,680 --> 00:16:00,720
well if the return address leads back

00:15:59,199 --> 00:16:03,120
into code

00:16:00,720 --> 00:16:04,079
that we just inputted we make sure that

00:16:03,120 --> 00:16:05,920
it's only given

00:16:04,079 --> 00:16:08,320
right access so we can only write to

00:16:05,920 --> 00:16:10,160
this page and so when we try to execute

00:16:08,320 --> 00:16:11,680
instructions in that page

00:16:10,160 --> 00:16:15,040
we'll generate a fault because we're not

00:16:11,680 --> 00:16:19,360
allowed to execute that shellcode

00:16:15,040 --> 00:16:19,360
okay so i mean are we done here no

00:16:19,680 --> 00:16:23,199
we can work around it so if you if you

00:16:21,279 --> 00:16:27,680
remember earlier um

00:16:23,199 --> 00:16:29,360
there are some shared libraries that um

00:16:27,680 --> 00:16:30,959
that have code you know like the c

00:16:29,360 --> 00:16:31,440
standard library super standard library

00:16:30,959 --> 00:16:34,959
maybe

00:16:31,440 --> 00:16:36,240
q whatever and so the work around is

00:16:34,959 --> 00:16:37,680
well why don't we just set the return

00:16:36,240 --> 00:16:41,040
address

00:16:37,680 --> 00:16:42,079
to a commonly known um

00:16:41,040 --> 00:16:45,199
function that we might want to use in

00:16:42,079 --> 00:16:48,720
the c in the c library so for example

00:16:45,199 --> 00:16:50,160
we might call system bin sh

00:16:48,720 --> 00:16:52,079
so we'll set up we'll set up the

00:16:50,160 --> 00:16:55,199
alternative check correctly

00:16:52,079 --> 00:16:56,720
we'll set up correctly um

00:16:55,199 --> 00:16:58,639
we'll put in the argument to the string

00:16:56,720 --> 00:16:59,440
that we want or the arguments that we

00:16:58,639 --> 00:17:02,240
want

00:16:59,440 --> 00:17:04,319
and then we'll call it and then we've

00:17:02,240 --> 00:17:07,760
we've got ourselves a root shell again

00:17:04,319 --> 00:17:11,199
so while this work well lipsy will be

00:17:07,760 --> 00:17:14,240
um mapped in with execute permission so

00:17:11,199 --> 00:17:14,240
we've just worked around it

00:17:14,640 --> 00:17:18,480
okay have we just been sitting again no

00:17:17,520 --> 00:17:21,280
so

00:17:18,480 --> 00:17:24,799
another concept is or another tool is

00:17:21,280 --> 00:17:28,240
address space layout randomization aslr

00:17:24,799 --> 00:17:31,520
the idea is randomize the address space

00:17:28,240 --> 00:17:33,919
um which means that it's hard to guess

00:17:31,520 --> 00:17:35,120
you know um what the location of this

00:17:33,919 --> 00:17:36,720
lipstick function is

00:17:35,120 --> 00:17:38,480
because without aslr i can just be on my

00:17:36,720 --> 00:17:40,000
local laptop have a look what lipsy is

00:17:38,480 --> 00:17:41,120
on my lack of laptop

00:17:40,000 --> 00:17:43,280
and i'll probably map to what i was

00:17:41,120 --> 00:17:46,559
going on the server for example um

00:17:43,280 --> 00:17:48,240
aslr it'll be random each time so

00:17:46,559 --> 00:17:49,760
again for 32 bit it doesn't really work

00:17:48,240 --> 00:17:52,000
out it's on enough entropy um you can

00:17:49,760 --> 00:17:56,000
get around it as a paper on it

00:17:52,000 --> 00:17:57,280
and it still isn't perfect on 64-bit but

00:17:56,000 --> 00:17:59,360
it's still kind of useful to still have

00:17:57,280 --> 00:18:00,480
so distributions will still use it

00:17:59,360 --> 00:18:02,640
and if you're interested to see how to

00:18:00,480 --> 00:18:05,679
break it on 64 bit hacking blind paper

00:18:02,640 --> 00:18:06,480
um we'll show you although it's kind of

00:18:05,679 --> 00:18:09,679
complicated

00:18:06,480 --> 00:18:10,960
it's a talk in itself so

00:18:09,679 --> 00:18:12,400
what you're seeing here is kind of like

00:18:10,960 --> 00:18:12,880
a cat and mouse game but we haven't

00:18:12,400 --> 00:18:15,120
really

00:18:12,880 --> 00:18:18,000
stopped the problem at its core yet and

00:18:15,120 --> 00:18:18,000
maybe we will

00:18:20,160 --> 00:18:25,600
sorry uh okay yep so

00:18:23,280 --> 00:18:28,320
okay well that's on the stack but we can

00:18:25,600 --> 00:18:31,280
also heap overflows

00:18:28,320 --> 00:18:32,720
so we're gonna have two structs here um

00:18:31,280 --> 00:18:35,919
one just stores a

00:18:32,720 --> 00:18:38,640
character or an array

00:18:35,919 --> 00:18:39,280
and the other has a function pointer now

00:18:38,640 --> 00:18:41,840
we're gonna

00:18:39,280 --> 00:18:43,280
allocate these two on the heap and maybe

00:18:41,840 --> 00:18:45,520
they might be basically adjacent to each

00:18:43,280 --> 00:18:45,520
other

00:18:45,760 --> 00:18:48,880
and we're going to assign the function

00:18:48,000 --> 00:18:51,919
pointer

00:18:48,880 --> 00:18:52,880
you know just to the exit function but

00:18:51,919 --> 00:18:55,440
at the same time

00:18:52,880 --> 00:18:56,559
we're going to accept a user argument

00:18:55,440 --> 00:18:58,640
and we're going to write it into the

00:18:56,559 --> 00:19:01,039
name array

00:18:58,640 --> 00:19:02,480
now what could happen here is that if i

00:19:01,039 --> 00:19:05,120
overwrite it

00:19:02,480 --> 00:19:05,760
i might be lucky enough and find that i

00:19:05,120 --> 00:19:08,000
because

00:19:05,760 --> 00:19:11,360
d and f are adjacent to each other or

00:19:08,000 --> 00:19:15,280
adjacent to each other we hope

00:19:11,360 --> 00:19:17,120
i can actually overwrite it such that

00:19:15,280 --> 00:19:19,840
the function pointer is not exit but a

00:19:17,120 --> 00:19:21,520
function of my choice

00:19:19,840 --> 00:19:23,440
again if i set up the arguments

00:19:21,520 --> 00:19:27,440
correctly i could do something similar

00:19:23,440 --> 00:19:27,440
to you know a return to libsy attack

00:19:27,760 --> 00:19:30,960
or even to my own shell code similarly

00:19:29,840 --> 00:19:33,760
again

00:19:30,960 --> 00:19:35,360
um but the same workarounds apply sorry

00:19:33,760 --> 00:19:36,880
the same mitigation supply

00:19:35,360 --> 00:19:38,400
but as we can see the heap is still

00:19:36,880 --> 00:19:40,320
exploitable despite

00:19:38,400 --> 00:19:42,960
the fact that the heap doesn't really

00:19:40,320 --> 00:19:45,360
contain a return address per se

00:19:42,960 --> 00:19:46,720
um there's only kind of like internal

00:19:45,360 --> 00:19:49,360
bookkeeping

00:19:46,720 --> 00:19:50,640
we've still managed that in this case

00:19:49,360 --> 00:19:52,320
we've still managed to find a return

00:19:50,640 --> 00:19:54,240
address and change the control flow of

00:19:52,320 --> 00:19:57,120
the program

00:19:54,240 --> 00:19:59,280
again if if right execute exists then

00:19:57,120 --> 00:20:01,280
this doesn't work out straight away

00:19:59,280 --> 00:20:03,600
but what i'm trying to illustrate is

00:20:01,280 --> 00:20:04,960
that you can do

00:20:03,600 --> 00:20:07,840
on the heap what you can do on the stack

00:20:04,960 --> 00:20:07,840
although it is a bit harder

00:20:08,400 --> 00:20:12,400
okay so so those two the heat and stack

00:20:11,200 --> 00:20:14,720
overflows are kind of what we call

00:20:12,400 --> 00:20:17,760
spatial memory safety bugs

00:20:14,720 --> 00:20:20,000
um so those are like when we manage

00:20:17,760 --> 00:20:21,600
memory incorrectly and start of starts

00:20:20,000 --> 00:20:22,799
stuff starts overwriting each other over

00:20:21,600 --> 00:20:25,280
time

00:20:22,799 --> 00:20:26,480
what about temporal memory safety books

00:20:25,280 --> 00:20:29,200
so this is when we

00:20:26,480 --> 00:20:30,799
incorrectly manage the lifetime of

00:20:29,200 --> 00:20:32,720
memory that we allocate

00:20:30,799 --> 00:20:35,280
so here's the use of the free function

00:20:32,720 --> 00:20:38,159
so we declare a pointer

00:20:35,280 --> 00:20:38,880
to an integer um we allocate some memory

00:20:38,159 --> 00:20:40,880
to it

00:20:38,880 --> 00:20:42,960
we assign that value we free it and then

00:20:40,880 --> 00:20:45,120
assign a value to it again

00:20:42,960 --> 00:20:46,960
now this example by itself isn't you

00:20:45,120 --> 00:20:48,720
know exploitable

00:20:46,960 --> 00:20:50,640
um but the vulnerability is that we've

00:20:48,720 --> 00:20:52,480
used something after we freed it so

00:20:50,640 --> 00:20:54,880
we have no claim to this memory and so

00:20:52,480 --> 00:20:56,240
this could easily be a crash

00:20:54,880 --> 00:20:58,960
although against undefined behavior so

00:20:56,240 --> 00:20:58,960
it might not crash at all

00:21:00,480 --> 00:21:06,240
okay so let's imagine a scenario where

00:21:03,679 --> 00:21:08,720
we could exploit use after free

00:21:06,240 --> 00:21:10,159
so you know as in the previous case we

00:21:08,720 --> 00:21:12,480
freed the memory but we started dangling

00:21:10,159 --> 00:21:15,600
pointer to it so

00:21:12,480 --> 00:21:18,720
let's assume that the program um assumes

00:21:15,600 --> 00:21:20,799
the data contains a function pointer

00:21:18,720 --> 00:21:22,159
um so the binding pointer points to the

00:21:20,799 --> 00:21:23,440
function pointer and let's say the

00:21:22,159 --> 00:21:25,200
attacker is

00:21:23,440 --> 00:21:27,760
able to input a return address of his

00:21:25,200 --> 00:21:29,200
choice into a new allocation so maybe

00:21:27,760 --> 00:21:31,200
there's a malloc call or a new call

00:21:29,200 --> 00:21:33,039
later and the attacker can put in some

00:21:31,200 --> 00:21:34,480
input

00:21:33,039 --> 00:21:36,320
but if the program uses that dangling

00:21:34,480 --> 00:21:37,679
pointer and the attacker successfully

00:21:36,320 --> 00:21:38,159
puts a return address of his choice

00:21:37,679 --> 00:21:41,520
there

00:21:38,159 --> 00:21:45,360
again you've taken over the control flow

00:21:41,520 --> 00:21:48,480
so again a lot of assumptions here

00:21:45,360 --> 00:21:49,919
is this likely well i mean yeah um so

00:21:48,480 --> 00:21:53,280
half of the 70

00:21:49,919 --> 00:21:56,880
of high severity bugs can be

00:21:53,280 --> 00:21:59,360
attributed to use half the free so

00:21:56,880 --> 00:22:02,080
quite a lot so it's definitely something

00:21:59,360 --> 00:22:02,080
we should look out for

00:22:02,240 --> 00:22:06,320
um i mean to avoid dangling pointers

00:22:05,039 --> 00:22:08,080
when programming please

00:22:06,320 --> 00:22:09,600
once you've freed something set a

00:22:08,080 --> 00:22:11,280
pointer to now

00:22:09,600 --> 00:22:14,480
um that will help to prevent this

00:22:11,280 --> 00:22:14,480
particular scenario here

00:22:16,320 --> 00:22:19,440
again we can do so many stuff on the

00:22:17,520 --> 00:22:21,840
stack so

00:22:19,440 --> 00:22:23,679
we have a use after return here so if

00:22:21,840 --> 00:22:25,760
you see

00:22:23,679 --> 00:22:27,280
the func function here returns a pointer

00:22:25,760 --> 00:22:27,840
to an integer so we allocate one on the

00:22:27,280 --> 00:22:30,240
stack

00:22:27,840 --> 00:22:31,840
and return a pointer to it but obviously

00:22:30,240 --> 00:22:33,760
after it's returned

00:22:31,840 --> 00:22:35,280
um we have no claim to this memory uh

00:22:33,760 --> 00:22:37,280
it's a use after return

00:22:35,280 --> 00:22:39,120
and we try to use the main function

00:22:37,280 --> 00:22:41,840
again undefined behavior we have no

00:22:39,120 --> 00:22:41,840
claim to that memory anymore

00:22:42,159 --> 00:22:45,120
we also have use of the scope so if

00:22:43,679 --> 00:22:47,679
you're in a scope the same applies

00:22:45,120 --> 00:22:49,679
similar to a return

00:22:47,679 --> 00:22:51,120
so an attacker exploits this in the same

00:22:49,679 --> 00:22:55,840
way as the use of the three that we

00:22:51,120 --> 00:22:55,840
talked about earlier

00:22:58,080 --> 00:23:03,039
now let's look at some other tools that

00:23:01,120 --> 00:23:04,640
um

00:23:03,039 --> 00:23:05,919
that have been used to help prevent

00:23:04,640 --> 00:23:07,600
these type of things happening in the

00:23:05,919 --> 00:23:10,720
first place so we looked at mitigations

00:23:07,600 --> 00:23:12,000
already but let's talk about how can we

00:23:10,720 --> 00:23:12,640
even prevent these coming into our

00:23:12,000 --> 00:23:14,400
programs

00:23:12,640 --> 00:23:15,600
so we would even we could be in a

00:23:14,400 --> 00:23:18,320
scenario where we don't even need these

00:23:15,600 --> 00:23:18,320
mitigations

00:23:21,600 --> 00:23:25,039
so again so you know prevention is

00:23:23,600 --> 00:23:28,320
better than the cure

00:23:25,039 --> 00:23:29,520
um so in this section

00:23:28,320 --> 00:23:37,840
i'm going to go through some tools and

00:23:29,520 --> 00:23:37,840
we'll build up to you know mte

00:23:38,559 --> 00:23:41,679
let's do some mentor opportunities okay

00:23:40,159 --> 00:23:43,360
the time is good okay right

00:23:41,679 --> 00:23:46,559
so let's talk about address sanitizer

00:23:43,360 --> 00:23:48,880
first so basically address sanitizer is

00:23:46,559 --> 00:23:51,039
some compiled instrumentation so and a

00:23:48,880 --> 00:23:51,760
runtime library and it takes quite a few

00:23:51,039 --> 00:23:53,039
of the

00:23:51,760 --> 00:23:54,799
classes of bugs that we've talked about

00:23:53,039 --> 00:23:56,400
earlier

00:23:54,799 --> 00:23:57,679
um it's easy to use you can use it now

00:23:56,400 --> 00:23:59,039
in your programs please do when you're

00:23:57,679 --> 00:24:01,120
developing

00:23:59,039 --> 00:24:04,720
luckily if you use extra cmake modules

00:24:01,120 --> 00:24:06,080
and the kde frameworks um as you can see

00:24:04,720 --> 00:24:09,600
with that line the snippet

00:24:06,080 --> 00:24:10,559
you'll get the right compiled compiler

00:24:09,600 --> 00:24:13,279
and link of flags

00:24:10,559 --> 00:24:13,279
set up for you

00:24:13,679 --> 00:24:16,880
so it's more of a debugging tool more

00:24:16,080 --> 00:24:19,440
than a

00:24:16,880 --> 00:24:20,720
mitigation but the idea is that it kind

00:24:19,440 --> 00:24:22,320
of

00:24:20,720 --> 00:24:23,679
upon detecting these types of bugs it

00:24:22,320 --> 00:24:25,440
will quit the program and give you good

00:24:23,679 --> 00:24:28,400
debugging information such that you can

00:24:25,440 --> 00:24:29,520
fix the issue so how does it work what

00:24:28,400 --> 00:24:31,679
does it use

00:24:29,520 --> 00:24:33,520
so to detect special memory bugs they

00:24:31,679 --> 00:24:35,360
use a concept called the red zone

00:24:33,520 --> 00:24:37,679
so each allocation both on the stack and

00:24:35,360 --> 00:24:41,360
on the heap and even in globals

00:24:37,679 --> 00:24:43,760
has a red zone on the other side

00:24:41,360 --> 00:24:45,679
and basically it means that if you

00:24:43,760 --> 00:24:48,480
overflow for example by one

00:24:45,679 --> 00:24:51,200
you'll find yourself in the red zone

00:24:48,480 --> 00:24:53,039
finding yourself in the red zone means

00:24:51,200 --> 00:24:54,320
bought the program you've done something

00:24:53,039 --> 00:24:57,120
wrong

00:24:54,320 --> 00:24:58,320
so as you can see there's an overhead

00:24:57,120 --> 00:25:00,000
there because

00:24:58,320 --> 00:25:01,440
the red zone stuff is just empty kind of

00:25:00,000 --> 00:25:04,640
space basically

00:25:01,440 --> 00:25:05,200
designed to catch your mistakes and to

00:25:04,640 --> 00:25:07,520
detect

00:25:05,200 --> 00:25:08,640
some poor memory bug so you know um

00:25:07,520 --> 00:25:09,520
freeing and then using a dangling

00:25:08,640 --> 00:25:10,799
pointer

00:25:09,520 --> 00:25:12,640
we use something called the quarantine

00:25:10,799 --> 00:25:15,120
around allocations

00:25:12,640 --> 00:25:17,120
so basically it consists of a queue such

00:25:15,120 --> 00:25:19,039
that when you free

00:25:17,120 --> 00:25:22,240
um the allocator tries its best not to

00:25:19,039 --> 00:25:25,520
reallocate that memory very soon

00:25:22,240 --> 00:25:28,559
and it keeps track of the fact

00:25:25,520 --> 00:25:29,600
that um that it was freed recently such

00:25:28,559 --> 00:25:31,520
that if you

00:25:29,600 --> 00:25:32,960
do use them game pointer again you will

00:25:31,520 --> 00:25:35,520
crash so

00:25:32,960 --> 00:25:36,799
how is this done well there's something

00:25:35,520 --> 00:25:38,559
called shadow memory which you can see a

00:25:36,799 --> 00:25:41,279
table of here

00:25:38,559 --> 00:25:42,400
um so it's quite clever in the compile

00:25:41,279 --> 00:25:46,080
instrumentation

00:25:42,400 --> 00:25:47,760
on every load and store um

00:25:46,080 --> 00:25:49,440
it does a quick check to see what type

00:25:47,760 --> 00:25:52,159
of memory is it

00:25:49,440 --> 00:25:53,440
so as you can see memory points to with

00:25:52,159 --> 00:25:54,400
a simple offset you can point to the

00:25:53,440 --> 00:25:57,120
shadow memory

00:25:54,400 --> 00:25:59,279
um it's very simple math basically i

00:25:57,120 --> 00:26:01,840
think one or two instructions

00:25:59,279 --> 00:26:02,720
um so to keep the overhead low and the

00:26:01,840 --> 00:26:05,919
shadow memory

00:26:02,720 --> 00:26:08,159
stores metadata in one byte um talking

00:26:05,919 --> 00:26:09,679
about eight bytes of addressable memory

00:26:08,159 --> 00:26:11,440
and then it says well how much of this

00:26:09,679 --> 00:26:15,440
memory is addressable

00:26:11,440 --> 00:26:17,760
and and for the parts that are

00:26:15,440 --> 00:26:19,760
unaddressable what type are they you

00:26:17,760 --> 00:26:23,600
know is it a red zone is it a quarantine

00:26:19,760 --> 00:26:25,440
etc and so using this it can determine

00:26:23,600 --> 00:26:26,640
if you've gone into the red zone

00:26:25,440 --> 00:26:29,200
if you've gone into something that's in

00:26:26,640 --> 00:26:31,520
quarantine so it's quite nifty quite

00:26:29,200 --> 00:26:31,520
smart

00:26:33,440 --> 00:26:36,480
so it was released probably about 10

00:26:35,679 --> 00:26:39,520
years well

00:26:36,480 --> 00:26:40,880
it was released 10 years ago and it

00:26:39,520 --> 00:26:41,360
reduced overheads quite considerably

00:26:40,880 --> 00:26:43,440
compared to

00:26:41,360 --> 00:26:44,400
valgrind so if you've ever used valgrind

00:26:43,440 --> 00:26:47,600
the overhead was

00:26:44,400 --> 00:26:49,840
quite excessive um people still use

00:26:47,600 --> 00:26:51,600
five grain now um it does detect some

00:26:49,840 --> 00:26:53,760
things that asana doesn't

00:26:51,600 --> 00:26:55,760
but asean had much better cpu overhead

00:26:53,760 --> 00:26:59,120
73 so

00:26:55,760 --> 00:27:02,559
10 10 uh less sorry not 10

00:26:59,120 --> 00:27:05,120
10 times less order magnitude and

00:27:02,559 --> 00:27:06,559
the memory usage increased by three

00:27:05,120 --> 00:27:08,880
times are quite a lot

00:27:06,559 --> 00:27:10,320
um but still probably more manageable

00:27:08,880 --> 00:27:11,520
than valgrind

00:27:10,320 --> 00:27:13,120
and so you could use this easily for

00:27:11,520 --> 00:27:15,679
debugging for most programs but

00:27:13,120 --> 00:27:17,600
production use probably not

00:27:15,679 --> 00:27:19,440
and you know chrome and mozilla and i

00:27:17,600 --> 00:27:21,039
guess us having a good time you know

00:27:19,440 --> 00:27:22,640
finding bugs with this so

00:27:21,039 --> 00:27:25,600
when they used it they found 300 bugs in

00:27:22,640 --> 00:27:27,520
a chromium cobas in the first 10 months

00:27:25,600 --> 00:27:28,960
but it is a dynamic analysis tool so a

00:27:27,520 --> 00:27:30,000
static analysis tool just looks at a

00:27:28,960 --> 00:27:31,360
source code

00:27:30,000 --> 00:27:33,679
and decides if there's you know any

00:27:31,360 --> 00:27:35,360
problems i can it knows about

00:27:33,679 --> 00:27:36,960
but the dynamic analysis tool only does

00:27:35,360 --> 00:27:38,799
its work when it's running

00:27:36,960 --> 00:27:40,640
and so you know your analysis is only

00:27:38,799 --> 00:27:44,399
good as the test suite you're using

00:27:40,640 --> 00:27:46,399
no tests as effectively useless

00:27:44,399 --> 00:27:48,799
but recently we've seen the trend of

00:27:46,399 --> 00:27:49,200
fuzzing um kde does use fuzzing i think

00:27:48,799 --> 00:27:50,320
with

00:27:49,200 --> 00:27:52,720
uh somebody's manager i think it's

00:27:50,320 --> 00:27:56,159
albert who manages oss

00:27:52,720 --> 00:27:58,559
oss fuzz which uses assam so fuzzing

00:27:56,159 --> 00:28:00,720
is basically just using random inputs

00:27:58,559 --> 00:28:02,720
and if it crashes like okay i'll try

00:28:00,720 --> 00:28:04,640
more inputs that are like this that's

00:28:02,720 --> 00:28:08,799
the whole field in itself

00:28:04,640 --> 00:28:08,799
but aside and fuzzing up amazing tool

00:28:10,159 --> 00:28:13,279
okay so what's the next iteration what

00:28:11,760 --> 00:28:15,679
we're going for next so

00:28:13,279 --> 00:28:17,200
now we have hardware address sanitizer

00:28:15,679 --> 00:28:18,559
so that consists of compiler

00:28:17,200 --> 00:28:21,520
instrumentation

00:28:18,559 --> 00:28:23,120
and a runtime library similar to asan

00:28:21,520 --> 00:28:24,000
and it detects a similar class of bugs

00:28:23,120 --> 00:28:25,440
to asset

00:28:24,000 --> 00:28:28,559
but it uses completely different

00:28:25,440 --> 00:28:30,159
technique of doing its work

00:28:28,559 --> 00:28:32,000
so firstly it relies on a feature called

00:28:30,159 --> 00:28:35,600
arm tbi

00:28:32,000 --> 00:28:38,080
um to store something called tags um

00:28:35,600 --> 00:28:38,640
and the technique is used it uses is

00:28:38,080 --> 00:28:41,440
called

00:28:38,640 --> 00:28:44,559
memory tagging so i'll talk about that

00:28:41,440 --> 00:28:46,960
more in a moment again

00:28:44,559 --> 00:28:48,960
pretty much as easy to use as asan um

00:28:46,960 --> 00:28:51,120
just provide the correct compiler flags

00:28:48,960 --> 00:28:52,880
uh we don't support any extra cmake

00:28:51,120 --> 00:28:55,760
modules yet i believe

00:28:52,880 --> 00:28:58,480
currently if i'm wrong um it's only

00:28:55,760 --> 00:29:00,880
supported in clang i think as well um

00:28:58,480 --> 00:29:01,679
i only supported an arm for now intel's

00:29:00,880 --> 00:29:03,520
releasing something called

00:29:01,679 --> 00:29:05,440
uh linear dress masking which might mean

00:29:03,520 --> 00:29:06,559
the croissant might actually work on

00:29:05,440 --> 00:29:09,679
intel soon

00:29:06,559 --> 00:29:09,679
so keep your eyes peeled

00:29:09,760 --> 00:29:12,960
okay so i mentioned on tbi but what is

00:29:11,840 --> 00:29:16,720
it

00:29:12,960 --> 00:29:18,320
so registers at least on arc 64 are 64

00:29:16,720 --> 00:29:22,240
bits wide

00:29:18,320 --> 00:29:23,840
but virtual addresses are only 48 bits

00:29:22,240 --> 00:29:26,399
so there's only 48 bits of addressable

00:29:23,840 --> 00:29:28,720
memory or 2 to the 48 bits

00:29:26,399 --> 00:29:30,159
um and so the other 16 bits are just set

00:29:28,720 --> 00:29:32,799
to zero or all ones

00:29:30,159 --> 00:29:33,600
um and it has to be that otherwise you

00:29:32,799 --> 00:29:36,320
know

00:29:33,600 --> 00:29:37,279
bad times for you but arm tbi is a new

00:29:36,320 --> 00:29:39,440
feature

00:29:37,279 --> 00:29:41,520
um well not new but the hardware feature

00:29:39,440 --> 00:29:43,440
that relaxes this requirement

00:29:41,520 --> 00:29:46,159
and so in that top top bite you can

00:29:43,440 --> 00:29:47,919
store any value that you want so

00:29:46,159 --> 00:29:49,679
um just the eight just the eight bytes

00:29:47,919 --> 00:29:53,120
not the sorry

00:29:49,679 --> 00:29:55,600
just the byte um the other byte

00:29:53,120 --> 00:29:56,640
under it um still has to have a certain

00:29:55,600 --> 00:29:59,679
value but it's top by

00:29:56,640 --> 00:30:01,039
you can put any value you want and so in

00:29:59,679 --> 00:30:03,919
this case question will use it to store

00:30:01,039 --> 00:30:06,159
a tag associated with a pointer

00:30:03,919 --> 00:30:07,360
now some of you may have thought but you

00:30:06,159 --> 00:30:08,960
know is this a good idea like

00:30:07,360 --> 00:30:11,919
is it always the case that we're not

00:30:08,960 --> 00:30:12,559
going to use all 64 bits i mean you know

00:30:11,919 --> 00:30:14,399
intel

00:30:12,559 --> 00:30:16,080
is going to introduce or might have

00:30:14,399 --> 00:30:17,760
already introduced

00:30:16,080 --> 00:30:19,600
five level paging which means that

00:30:17,760 --> 00:30:22,480
actually they've opened the fact that we

00:30:19,600 --> 00:30:26,640
might have a 257-bit address space

00:30:22,480 --> 00:30:28,720
so could it be 64 soon could this

00:30:26,640 --> 00:30:31,279
not work out i'll leave it to you to

00:30:28,720 --> 00:30:31,279
think about that

00:30:31,600 --> 00:30:34,720
so let's talk about the concept of

00:30:32,880 --> 00:30:36,000
memory tagging as a general concept it's

00:30:34,720 --> 00:30:37,520
not related to imt by

00:30:36,000 --> 00:30:40,640
itself you can just think of it

00:30:37,520 --> 00:30:42,080
independently of the hardware

00:30:40,640 --> 00:30:44,000
so let's first define two keywords

00:30:42,080 --> 00:30:45,840
before we could uh carry on

00:30:44,000 --> 00:30:47,360
so first we have the tagging granularity

00:30:45,840 --> 00:30:48,320
the amount of memory associated with any

00:30:47,360 --> 00:30:51,679
given tag so

00:30:48,320 --> 00:30:52,960
16 bytes um

00:30:51,679 --> 00:30:55,279
and then we have the tagging size so

00:30:52,960 --> 00:30:57,519
it's the possible size of a given tan

00:30:55,279 --> 00:30:59,440
how many tag values are there so if it's

00:30:57,519 --> 00:31:05,039
one byte you can have 256 different

00:30:59,440 --> 00:31:07,039
tag values and so each granule of memory

00:31:05,039 --> 00:31:08,960
is associated with a tag and then all

00:31:07,039 --> 00:31:11,440
pointers that same location memory

00:31:08,960 --> 00:31:12,799
should have the same tag and so upon

00:31:11,440 --> 00:31:14,399
each memory access you want to make sure

00:31:12,799 --> 00:31:16,320
that

00:31:14,399 --> 00:31:20,000
you you compare the tag of the pointer

00:31:16,320 --> 00:31:22,799
with the tag of the memory it points to

00:31:20,000 --> 00:31:23,279
and if they don't match um you have

00:31:22,799 --> 00:31:26,240
bought

00:31:23,279 --> 00:31:26,880
you say there's an issue okay so that's

00:31:26,240 --> 00:31:32,159
quite general

00:31:26,880 --> 00:31:36,320
um why for memory safety

00:31:32,159 --> 00:31:38,159
well the user compiled instrumentation

00:31:36,320 --> 00:31:38,720
and the runtime library and it uses this

00:31:38,159 --> 00:31:40,799
concept

00:31:38,720 --> 00:31:42,880
to basically do its magic so what does

00:31:40,799 --> 00:31:47,120
it do so the memory allocator

00:31:42,880 --> 00:31:49,600
is modified to the heat tagging so

00:31:47,120 --> 00:31:51,679
on allocation you have to align to the

00:31:49,600 --> 00:31:54,080
tagging granularity

00:31:51,679 --> 00:31:55,120
and you randomly assign a tag to the

00:31:54,080 --> 00:31:57,600
memory and the pointer and they should

00:31:55,120 --> 00:31:57,600
be the same

00:31:58,399 --> 00:32:05,440
on the allocation um free for example

00:32:01,440 --> 00:32:05,440
you assign a new random tag to memory

00:32:06,480 --> 00:32:13,360
um so why does this work

00:32:10,159 --> 00:32:17,039
well it works because

00:32:13,360 --> 00:32:19,440
let's say you allocate a value x

00:32:17,039 --> 00:32:21,440
and then you say if you're printing use

00:32:19,440 --> 00:32:23,200
off the three if you de-allocate and

00:32:21,440 --> 00:32:24,720
get a new value chances are it's not

00:32:23,200 --> 00:32:26,080
going to be x is going to be some other

00:32:24,720 --> 00:32:27,440
value y

00:32:26,080 --> 00:32:28,720
so if you use that pointer again if you

00:32:27,440 --> 00:32:31,600
use a dangling pointer again there's

00:32:28,720 --> 00:32:33,360
going to be a tag mismatch

00:32:31,600 --> 00:32:35,039
um similarly for us for a series of

00:32:33,360 --> 00:32:36,159
allocations they're likely

00:32:35,039 --> 00:32:38,799
because they're independent have

00:32:36,159 --> 00:32:39,600
different tags and so if you overflow

00:32:38,799 --> 00:32:41,600
into a different

00:32:39,600 --> 00:32:42,640
allocation they're likely to have

00:32:41,600 --> 00:32:44,320
different tags

00:32:42,640 --> 00:32:46,080
um you still have a one over two five

00:32:44,320 --> 00:32:49,120
six probability of missing

00:32:46,080 --> 00:32:50,240
um some um so sometimes they might match

00:32:49,120 --> 00:32:52,399
when they shouldn't

00:32:50,240 --> 00:32:53,919
but i mean this is more than 99 so this

00:32:52,399 --> 00:32:56,480
is pretty good

00:32:53,919 --> 00:32:57,200
um the compiler also needs to be changed

00:32:56,480 --> 00:32:58,960
um so

00:32:57,200 --> 00:33:00,559
all local variables need to be aligned

00:32:58,960 --> 00:33:02,159
to the tagging granularity

00:33:00,559 --> 00:33:02,960
and again you assign attack to the

00:33:02,159 --> 00:33:04,080
memory and pointer

00:33:02,960 --> 00:33:05,600
[Music]

00:33:04,080 --> 00:33:09,200
so instead of the allocation you change

00:33:05,600 --> 00:33:12,640
the tag again on function exit

00:33:09,200 --> 00:33:12,640
so when you get rid of the stack frame

00:33:13,120 --> 00:33:17,039
um for the stack a single base tag is

00:33:16,480 --> 00:33:18,720
used

00:33:17,039 --> 00:33:20,799
and all other tags derive from it so

00:33:18,720 --> 00:33:22,320
basically it's a bit too expensive to do

00:33:20,799 --> 00:33:25,679
a separate

00:33:22,320 --> 00:33:27,760
um allocation sorry

00:33:25,679 --> 00:33:29,120
to generate a random tag for each

00:33:27,760 --> 00:33:30,320
allocation on the stack

00:33:29,120 --> 00:33:31,919
so you just use a paste tag and you

00:33:30,320 --> 00:33:33,519
might increment on top of it and just go

00:33:31,919 --> 00:33:34,559
in circles for example so add one to the

00:33:33,519 --> 00:33:36,000
next application

00:33:34,559 --> 00:33:38,320
add to the next allocation and stuff

00:33:36,000 --> 00:33:40,080
like that

00:33:38,320 --> 00:33:41,360
okay so is it better than a sound well

00:33:40,080 --> 00:33:42,480
it has a smaller ram overhead because

00:33:41,360 --> 00:33:44,320
you don't need the red zone

00:33:42,480 --> 00:33:46,000
you don't need quarantine you just need

00:33:44,320 --> 00:33:46,799
the storage for the tags itself and you

00:33:46,000 --> 00:33:49,679
need to align

00:33:46,799 --> 00:33:50,799
uh both the stack and heat variables um

00:33:49,679 --> 00:33:52,480
it's also better at dictating

00:33:50,799 --> 00:33:53,840
non-adjacent outbound access so the

00:33:52,480 --> 00:33:55,840
renzo doesn't really help you

00:33:53,840 --> 00:33:57,440
if the access is not json it's like all

00:33:55,840 --> 00:33:59,279
over the place

00:33:57,440 --> 00:34:00,799
um it's also back to other testing use

00:33:59,279 --> 00:34:02,960
after three over time again

00:34:00,799 --> 00:34:05,200
because the quarantine is only good as

00:34:02,960 --> 00:34:08,159
the size of the queue

00:34:05,200 --> 00:34:09,599
um but asante still does have some kind

00:34:08,159 --> 00:34:11,359
of advantages so

00:34:09,599 --> 00:34:14,079
the body detection is deterministic for

00:34:11,359 --> 00:34:15,119
asan but huasan still has a chance to

00:34:14,079 --> 00:34:17,679
miss it even though

00:34:15,119 --> 00:34:19,760
it had you know there's one over 256

00:34:17,679 --> 00:34:22,079
probability of missing it

00:34:19,760 --> 00:34:23,200
also because of the granule if you if

00:34:22,079 --> 00:34:26,079
you for example have an eight by

00:34:23,200 --> 00:34:27,200
allocation and you overflow 12 bytes

00:34:26,079 --> 00:34:28,879
it's going to look like it's the same

00:34:27,200 --> 00:34:31,839
tag or they will have the same tag and

00:34:28,879 --> 00:34:31,839
so you won't catch that

00:34:32,399 --> 00:34:36,960
okay so let's motivate arm mte so on

00:34:35,280 --> 00:34:38,320
mt's new hardware feature

00:34:36,960 --> 00:34:39,359
um it's not available yet but it's

00:34:38,320 --> 00:34:40,560
available on camera if you want to play

00:34:39,359 --> 00:34:41,839
around with it

00:34:40,560 --> 00:34:43,919
um so it's an implementation of the

00:34:41,839 --> 00:34:46,000
memory tagging concept um

00:34:43,919 --> 00:34:47,040
with the same dragon tagging granularity

00:34:46,000 --> 00:34:48,560
of 16 bytes

00:34:47,040 --> 00:34:51,280
but the tagging size is four bits so

00:34:48,560 --> 00:34:54,560
it's less than hwasan

00:34:51,280 --> 00:34:57,920
again it uses on tbi to stick it in

00:34:54,560 --> 00:35:00,560
to give space for a tag in the pointer

00:34:57,920 --> 00:35:02,400
the mapping of granules to tag values is

00:35:00,560 --> 00:35:03,680
stored in main memory so it's reserved

00:35:02,400 --> 00:35:05,520
that boot so this is a memory that you

00:35:03,680 --> 00:35:07,040
can't use it for any other purpose after

00:35:05,520 --> 00:35:08,240
it's booted so

00:35:07,040 --> 00:35:10,320
that's roughly three percent of your

00:35:08,240 --> 00:35:11,760
memory gone

00:35:10,320 --> 00:35:13,920
so keep that in mind that's a cost

00:35:11,760 --> 00:35:15,440
that's an overhead and there's also some

00:35:13,920 --> 00:35:17,839
instructions to generate molecular and

00:35:15,440 --> 00:35:17,839
view tags

00:35:20,240 --> 00:35:23,440
and there's two modes of usage um so

00:35:22,640 --> 00:35:26,240
assuming you've

00:35:23,440 --> 00:35:27,680
mapped the memory with mt enabled so

00:35:26,240 --> 00:35:28,720
there's a flag for that

00:35:27,680 --> 00:35:30,880
you don't have to think about it as

00:35:28,720 --> 00:35:32,720
application user but there's two types

00:35:30,880 --> 00:35:35,119
the synchronous so a tag is checked on

00:35:32,720 --> 00:35:38,640
each load and store instruction

00:35:35,119 --> 00:35:41,280
um straight away and the segmentation

00:35:38,640 --> 00:35:42,720
fault is generated with faulting address

00:35:41,280 --> 00:35:44,400
this is slower but again you get more

00:35:42,720 --> 00:35:46,320
useful information for debugging

00:35:44,400 --> 00:35:48,720
but asynchronous tag checking is delayed

00:35:46,320 --> 00:35:51,839
until the next context switch

00:35:48,720 --> 00:35:53,280
um so a segmentation fault generated

00:35:51,839 --> 00:35:55,440
is generated without a faulting address

00:35:53,280 --> 00:35:57,040
so it's quicker so it might be good as a

00:35:55,440 --> 00:36:00,079
mitigation for these types of bugs but

00:35:57,040 --> 00:36:02,640
it's not good for debugging

00:36:00,079 --> 00:36:04,240
okay so you can have um so again keep

00:36:02,640 --> 00:36:07,520
tagging it there's an implementation

00:36:04,240 --> 00:36:08,720
for g libsy um a certain tag is reserved

00:36:07,520 --> 00:36:10,079
for internal data structures like

00:36:08,720 --> 00:36:10,880
bookkeeping and headers and stuff like

00:36:10,079 --> 00:36:12,320
that

00:36:10,880 --> 00:36:15,280
but fortunately the taking granularity

00:36:12,320 --> 00:36:16,720
is the same so the current

00:36:15,280 --> 00:36:18,640
so keep tagging doesn't have much of an

00:36:16,720 --> 00:36:20,960
alignment issue um

00:36:18,640 --> 00:36:21,920
again a similar allocate algorithm to

00:36:20,960 --> 00:36:23,760
hwasan

00:36:21,920 --> 00:36:25,280
but to note here the difference is that

00:36:23,760 --> 00:36:26,720
um kellogg is actually no more expensive

00:36:25,280 --> 00:36:31,280
than malloc because there's a special

00:36:26,720 --> 00:36:34,000
instruction to um set the value to zero

00:36:31,280 --> 00:36:34,640
um so it doesn't cost anything extra and

00:36:34,000 --> 00:36:36,160
really

00:36:34,640 --> 00:36:38,160
always re-tags no matter if you have to

00:36:36,160 --> 00:36:42,079
move the memory or if it doesn't move

00:36:38,160 --> 00:36:44,320
you always just re-tag so that's useful

00:36:42,079 --> 00:36:45,119
um stack tagging is done with clang so

00:36:44,320 --> 00:36:47,520
there's no sorry there's an

00:36:45,119 --> 00:36:49,599
implementation for that

00:36:47,520 --> 00:36:51,200
sorry uh interrupting you alex uh you

00:36:49,599 --> 00:36:55,280
have three minutes left

00:36:51,200 --> 00:36:55,680
okay okay so again similarly to hassan

00:36:55,280 --> 00:36:58,800
this and

00:36:55,680 --> 00:37:00,560
stack tagging um is implemented as a

00:36:58,800 --> 00:37:03,440
simple function pass

00:37:00,560 --> 00:37:04,640
um but but the um the alignment is much

00:37:03,440 --> 00:37:06,640
of a bigger problem there so

00:37:04,640 --> 00:37:08,560
you need to do a 60 minute alignment and

00:37:06,640 --> 00:37:11,280
that can be quite annoying

00:37:08,560 --> 00:37:13,119
and but stack safety analysis can be

00:37:11,280 --> 00:37:13,440
used to basically it's basically a tool

00:37:13,119 --> 00:37:15,440
that

00:37:13,440 --> 00:37:16,880
decides if there's a chance of memory

00:37:15,440 --> 00:37:18,320
safety issues occurring

00:37:16,880 --> 00:37:20,320
if there's no chance of this occurring

00:37:18,320 --> 00:37:21,680
in a function or a scope

00:37:20,320 --> 00:37:23,520
don't bother tagging it and you'll be

00:37:21,680 --> 00:37:25,359
fine so that can help

00:37:23,520 --> 00:37:27,839
reduce the code size overhead and just a

00:37:25,359 --> 00:37:29,520
runtime over here

00:37:27,839 --> 00:37:30,800
um so here's an example i think we'll

00:37:29,520 --> 00:37:32,160
have to skip over this just to the time

00:37:30,800 --> 00:37:34,320
issues

00:37:32,160 --> 00:37:36,160
um but you can see there's some extra

00:37:34,320 --> 00:37:38,960
instructions there

00:37:36,160 --> 00:37:40,400
but what arm mte offers is offers it

00:37:38,960 --> 00:37:42,000
should offer smaller cpu overhead

00:37:40,400 --> 00:37:43,040
because you don't need to

00:37:42,000 --> 00:37:44,640
you don't need to do carpine

00:37:43,040 --> 00:37:46,720
instrumentation for each access that's

00:37:44,640 --> 00:37:48,480
handled in the hardware for you

00:37:46,720 --> 00:37:50,240
um obviously the hardware isn't released

00:37:48,480 --> 00:37:53,280
yet so we don't know what that is

00:37:50,240 --> 00:37:54,560
but hopefully it's quite low the ram

00:37:53,280 --> 00:37:58,160
overhead is also

00:37:54,560 --> 00:38:00,800
um kind of a tiny bit smaller

00:37:58,160 --> 00:38:01,440
um well you can't really see it in user

00:38:00,800 --> 00:38:02,800
space but

00:38:01,440 --> 00:38:04,400
there is storage so there's three

00:38:02,800 --> 00:38:06,000
percent already gone and then there's

00:38:04,400 --> 00:38:09,119
like the alignment

00:38:06,000 --> 00:38:10,640
um that you need to deal with as well

00:38:09,119 --> 00:38:11,440
and the code size also should be smaller

00:38:10,640 --> 00:38:12,560
because you don't need the compiler

00:38:11,440 --> 00:38:13,760
instrument a lot of the compiler

00:38:12,560 --> 00:38:15,359
instrumentation

00:38:13,760 --> 00:38:18,000
um and from my measurements it's less

00:38:15,359 --> 00:38:19,599
than five percent as claimed

00:38:18,000 --> 00:38:20,560
and for heat tagging a good thing is

00:38:19,599 --> 00:38:22,240
that you don't need to recompile

00:38:20,560 --> 00:38:24,400
programs um so long as you've got g

00:38:22,240 --> 00:38:26,000
lipstick you're in good shape

00:38:24,400 --> 00:38:28,320
um the high side is still better because

00:38:26,000 --> 00:38:30,560
the tag in size is bigger so

00:38:28,320 --> 00:38:32,240
with with only four bits then we have a

00:38:30,560 --> 00:38:34,800
7 chance of missing out on the bug so

00:38:32,240 --> 00:38:37,359
that can be a big issue

00:38:34,800 --> 00:38:38,880
um so those are unconventional use cases

00:38:37,359 --> 00:38:41,040
um there's only one minute left so

00:38:38,880 --> 00:38:43,200
i can't really talk much about it but i

00:38:41,040 --> 00:38:45,760
think the slides are clear just from

00:38:43,200 --> 00:38:47,040
reading it so i'm going to leave it to

00:38:45,760 --> 00:38:48,560
half a minute of questions i think

00:38:47,040 --> 00:38:51,200
unfortunately i wanted to go for these

00:38:48,560 --> 00:38:54,000
slides but um i think i can

00:38:51,200 --> 00:38:54,000
are there any questions

00:38:56,640 --> 00:39:00,240
okay first thank you for the awesome

00:38:58,880 --> 00:39:02,320
talk

00:39:00,240 --> 00:39:04,480
i would really really really really

00:39:02,320 --> 00:39:07,920
advise you to split into

00:39:04,480 --> 00:39:11,200
three talks for the next academy so

00:39:07,920 --> 00:39:13,119
because this is something that we should

00:39:11,200 --> 00:39:16,960
all learn and

00:39:13,119 --> 00:39:18,240
i guess no by heart uh a question that i

00:39:16,960 --> 00:39:21,520
would like to ask

00:39:18,240 --> 00:39:23,920
uh so most of these tools

00:39:21,520 --> 00:39:25,599
are something that mitigates already

00:39:23,920 --> 00:39:28,480
made bugs or detects

00:39:25,599 --> 00:39:29,280
the already made bugs do you see a world

00:39:28,480 --> 00:39:32,960
where

00:39:29,280 --> 00:39:35,520
we could avoid making those bugs in the

00:39:32,960 --> 00:39:35,520
first place

00:39:39,119 --> 00:39:42,320
i think the world is always trade-offs

00:39:40,480 --> 00:39:43,200
right so in many cases we can avoid

00:39:42,320 --> 00:39:45,359
quite a lot of them

00:39:43,200 --> 00:39:48,000
by using just a different language the

00:39:45,359 --> 00:39:50,880
real question is can we do it

00:39:48,000 --> 00:39:51,920
can we have it like a free lunch um so i

00:39:50,880 --> 00:39:53,520
guess we've seen for us

00:39:51,920 --> 00:39:54,960
there's some improvement in certain

00:39:53,520 --> 00:39:56,880
areas

00:39:54,960 --> 00:39:58,640
again a lot of free lunches in some ways

00:39:56,880 --> 00:40:01,839
a harder language

00:39:58,640 --> 00:40:02,960
so i don't think we'll kind of reach

00:40:01,839 --> 00:40:06,319
that kind of 100

00:40:02,960 --> 00:40:08,079
stage um but hopefully the trade-offs

00:40:06,319 --> 00:40:09,680
will fall more in our favor over time

00:40:08,079 --> 00:40:11,359
so i think rmt is one of those for

00:40:09,680 --> 00:40:15,200
example

00:40:11,359 --> 00:40:17,040
cool uh i think that's

00:40:15,200 --> 00:40:18,480
that's the all the time that we have

00:40:17,040 --> 00:40:22,000
thank you yet again

00:40:18,480 --> 00:40:23,760
and enjoy all the claps in the chat uh

00:40:22,000 --> 00:40:26,000
people are clapping clapping clapping

00:40:23,760 --> 00:40:27,200
i'm not going to to count all the claps

00:40:26,000 --> 00:40:30,240
that you got okay thank you

00:40:27,200 --> 00:40:32,160
so thank you yet again yep um yeah but

00:40:30,240 --> 00:40:35,280
if any questions feel free to email me

00:40:32,160 --> 00:40:37,200
or just i'll be i'm commonly in my

00:40:35,280 --> 00:40:38,480
nickname is feed with you so

00:40:37,200 --> 00:40:50,240
and you have questions please let me

00:40:38,480 --> 00:40:50,240

YouTube URL: https://www.youtube.com/watch?v=yB2ziEnTFOY


