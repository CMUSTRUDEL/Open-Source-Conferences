Title: Albert Astals Cid - Testing Your Code for Security Issues with Automated Fuzzing - Akademy 2019
Publication date: 2020-05-25
Playlist: Akademy 2019
Description: 
	Writing secure code that deals with potentially untrusted data (parsers, importers, etc) is always hard since there are many potential cases to take into account.

One of the techniques used to improve the security of such code is fuzzing.

Fuzzing involves providing invalid or random data to a given piece of code to test its behaviour.

Modern fuzzers are smart enough to understand what needs to be changed in the input to make the code go through a different code path making testing faster and more complete.

oss-fuzz is a Free set of tools to make fuzzing of C/C++ code easier.
It is comprised of various scripts and docker images, which, for example, have the base system libraries already compiled with the sanitizers.

Coupling a fuzzer with the compiler sanitizers (asan, ubsan, msan) gives even better results since these sanitizers will make sure the code is run more strictly.

In this session we'll show how to fuzz a C++ codebase, as well as give you an update on how we're using these tools.
Captions: 
	00:00:00,030 --> 00:00:05,270
first Who am I so I've been with KD for

00:00:03,720 --> 00:00:08,400
a long time

00:00:05,270 --> 00:00:10,469
yeah the KPD F which you probably don't

00:00:08,400 --> 00:00:13,049
know anymore because that's how we used

00:00:10,469 --> 00:00:15,830
to call ocular twenty years ago I've

00:00:13,049 --> 00:00:19,199
been doing translations release releases

00:00:15,830 --> 00:00:23,850
working KD games in KD who I was the

00:00:19,199 --> 00:00:27,689
founding president of cÃ¡diz pain I was

00:00:23,850 --> 00:00:30,390
part of the KD or I'd done a little bit

00:00:27,689 --> 00:00:32,130
of everything and the most important

00:00:30,390 --> 00:00:34,140
part of this is light is it I'm not a

00:00:32,130 --> 00:00:35,460
security expert so I'm gonna talk to you

00:00:34,140 --> 00:00:38,280
about something which is security

00:00:35,460 --> 00:00:41,309
related but it's just something I've

00:00:38,280 --> 00:00:43,710
been doing lately so if you have

00:00:41,309 --> 00:00:47,210
questions I might have not have answers

00:00:43,710 --> 00:00:51,120
for you questions so just be aware of it

00:00:47,210 --> 00:00:53,670
right so which kind of security issues

00:00:51,120 --> 00:00:58,230
am I going to be talking about right so

00:00:53,670 --> 00:01:02,160
it's gonna be mainly related to wrong

00:00:58,230 --> 00:01:05,610
use of memory right so like using any

00:01:02,160 --> 00:01:07,170
device memory or using memory that was a

00:01:05,610 --> 00:01:11,390
really freed right

00:01:07,170 --> 00:01:13,799
this means the application will either

00:01:11,390 --> 00:01:15,659
crash because you're doing something

00:01:13,799 --> 00:01:18,270
with memory that's not yours or that

00:01:15,659 --> 00:01:20,520
wasn't anymore or whatever or that will

00:01:18,270 --> 00:01:23,210
behave unexpectedly because your

00:01:20,520 --> 00:01:25,500
variable is not initialized and then

00:01:23,210 --> 00:01:30,540
things happen that you don't expect them

00:01:25,500 --> 00:01:34,259
to happen right people that are more

00:01:30,540 --> 00:01:37,979
experienced than me in security say that

00:01:34,259 --> 00:01:41,759
any memory related crash can be turned

00:01:37,979 --> 00:01:44,700
into a code execution exploit right I've

00:01:41,759 --> 00:01:47,159
never seen this happening I even have a

00:01:44,700 --> 00:01:48,840
clue how this happens but that's one of

00:01:47,159 --> 00:01:50,759
the mantras there isn't the security

00:01:48,840 --> 00:01:52,920
community right if you're crashing

00:01:50,759 --> 00:01:57,689
because you're using an initialized

00:01:52,920 --> 00:02:00,509
memory that means someone can put code

00:01:57,689 --> 00:02:04,020
there and make it do things they want

00:02:00,509 --> 00:02:06,020
and not what you want right so it's very

00:02:04,020 --> 00:02:08,399
important to fix this kind of bugs

00:02:06,020 --> 00:02:10,140
because it can basically be code

00:02:08,399 --> 00:02:11,730
execution and we don't want to be doing

00:02:10,140 --> 00:02:15,690
code evolution right

00:02:11,730 --> 00:02:18,000
so which tools do we have to do that

00:02:15,690 --> 00:02:20,550
type that you've doing either wrong

00:02:18,000 --> 00:02:22,650
memory use or using your memory after

00:02:20,550 --> 00:02:24,780
it's been freed or whatever right so the

00:02:22,650 --> 00:02:28,170
first and very basic tool is the

00:02:24,780 --> 00:02:30,330
operating system your application might

00:02:28,170 --> 00:02:32,459
crash if you're using the memory wrong

00:02:30,330 --> 00:02:35,160
right it doesn't happen all the time

00:02:32,459 --> 00:02:36,900
because the the the operating system and

00:02:35,160 --> 00:02:40,110
the C library and whatever it's

00:02:36,900 --> 00:02:41,640
sometimes a bit too lazy doing things

00:02:40,110 --> 00:02:43,410
and it will give you more memory than

00:02:41,640 --> 00:02:46,290
you need and then if you use that memory

00:02:43,410 --> 00:02:48,150
that's it's not really yours but the

00:02:46,290 --> 00:02:53,010
erasing gave it to you because whatever

00:02:48,150 --> 00:02:55,230
it will not crash but yeah so yeah then

00:02:53,010 --> 00:02:57,810
we have BA grind right so bar grind will

00:02:55,230 --> 00:02:58,709
find those will help us find these kind

00:02:57,810 --> 00:03:01,019
of memory errors

00:02:58,709 --> 00:03:03,870
the problem with by grind is that it

00:03:01,019 --> 00:03:05,040
will take ten days to run your

00:03:03,870 --> 00:03:07,380
application if it's a bit complicated

00:03:05,040 --> 00:03:10,500
right I've tried that with with ocular

00:03:07,380 --> 00:03:12,420
and PDF parsing sometimes and I got

00:03:10,500 --> 00:03:14,310
bored after a day of having it running

00:03:12,420 --> 00:03:15,750
on my computer I did for some things

00:03:14,310 --> 00:03:19,440
that are very long it's just not

00:03:15,750 --> 00:03:21,989
feasible to do and then one of the

00:03:19,440 --> 00:03:24,329
modern tools which is similar to but

00:03:21,989 --> 00:03:27,900
valgrind us but it's just so much faster

00:03:24,329 --> 00:03:30,030
is the compiler sanitizers right so

00:03:27,900 --> 00:03:31,829
that's something that as far as I

00:03:30,030 --> 00:03:34,319
understand google has been working on

00:03:31,829 --> 00:03:36,810
and there's the other sanitizer the

00:03:34,319 --> 00:03:39,359
memory sanitizer and you define behavior

00:03:36,810 --> 00:03:43,019
Iser and basically what they do is they

00:03:39,359 --> 00:03:46,170
add code to your application that checks

00:03:43,019 --> 00:03:48,180
for all the things that can go wrong but

00:03:46,170 --> 00:03:50,609
since it's inside your code is much

00:03:48,180 --> 00:03:53,459
faster than by grind Vogon pretends to

00:03:50,609 --> 00:03:54,720
be a beautiful cpu kind of thing so

00:03:53,459 --> 00:03:59,010
everything is so much slower because

00:03:54,720 --> 00:04:00,959
things don't like they are intercepted

00:03:59,010 --> 00:04:03,329
by going right so that's one of the

00:04:00,959 --> 00:04:05,810
things that makes the memory size it

00:04:03,329 --> 00:04:08,970
like the compiler sizer story much

00:04:05,810 --> 00:04:10,859
faster it's also a bit harder to use

00:04:08,970 --> 00:04:13,139
because you actually have to link to

00:04:10,859 --> 00:04:15,660
them and you know how you need to know

00:04:13,139 --> 00:04:18,239
how to do that right valgrind can use

00:04:15,660 --> 00:04:20,539
run your binary but let's assume you

00:04:18,239 --> 00:04:25,110
know how to do that so what is passing

00:04:20,539 --> 00:04:27,210
it's it's a technique in which

00:04:25,110 --> 00:04:31,620
you basically send garbage to your

00:04:27,210 --> 00:04:34,860
application and try to make it crash or

00:04:31,620 --> 00:04:37,379
not crash right so that way you make

00:04:34,860 --> 00:04:40,469
sure that whatever the input is your

00:04:37,379 --> 00:04:42,900
application will not crash so one could

00:04:40,469 --> 00:04:46,259
do fuzzing by hand right you could use

00:04:42,900 --> 00:04:48,300
start with PDF info for example which is

00:04:46,259 --> 00:04:50,819
a binary that will if you give it a PDF

00:04:48,300 --> 00:04:53,069
it will tell you the title and the outer

00:04:50,819 --> 00:04:57,210
and what not and you could use starting

00:04:53,069 --> 00:04:59,460
echo a echo B equals C and D an E and

00:04:57,210 --> 00:05:01,680
just like try all the possible input

00:04:59,460 --> 00:05:03,270
write that this is very basic nobody

00:05:01,680 --> 00:05:05,219
does that but it's one of the ways you

00:05:03,270 --> 00:05:07,830
could do it right it's just like do a

00:05:05,219 --> 00:05:12,419
for loop forever and you send it random

00:05:07,830 --> 00:05:16,379
 and see if it crashes so what is us

00:05:12,419 --> 00:05:20,310
food us foods is the main topic of this

00:05:16,379 --> 00:05:22,889
talk as food is a is a fuzzing engine

00:05:20,310 --> 00:05:24,569
developed by Google actually fasting

00:05:22,889 --> 00:05:26,250
engines not called oz foods it's called

00:05:24,569 --> 00:05:28,860
if the user

00:05:26,250 --> 00:05:31,319
but what food is like the bigger term

00:05:28,860 --> 00:05:34,710
they're using everywhere so so I'm using

00:05:31,319 --> 00:05:38,120
that too so basically it's it's a very

00:05:34,710 --> 00:05:43,319
very smart fuzzing tool right it's

00:05:38,120 --> 00:05:46,620
coverage based which means it knows it

00:05:43,319 --> 00:05:50,159
understands your code and will minimize

00:05:46,620 --> 00:05:52,139
the randomness of losing right so if you

00:05:50,159 --> 00:05:54,060
have a function where there is an

00:05:52,139 --> 00:05:56,789
integral that has an X and then you

00:05:54,060 --> 00:06:01,620
check for X being bigger or smaller than

00:05:56,789 --> 00:06:04,199
50 it will not try 51 51 53 right

00:06:01,620 --> 00:06:06,779
because like it knows that 51 52 and 53

00:06:04,199 --> 00:06:08,699
it's just it will execute the same code

00:06:06,779 --> 00:06:11,879
so while right

00:06:08,699 --> 00:06:13,740
although right so it is really really

00:06:11,879 --> 00:06:18,509
advanced I don't know how they actually

00:06:13,740 --> 00:06:20,279
do that because when I think how to do

00:06:18,509 --> 00:06:22,759
it I don't have no idea how I do it but

00:06:20,279 --> 00:06:29,009
but they doing it and it works I mean

00:06:22,759 --> 00:06:33,180
it's really amazing so what is ours

00:06:29,009 --> 00:06:36,060
first number two so the problem with for

00:06:33,180 --> 00:06:39,060
example these sanitizers and clang but

00:06:36,060 --> 00:06:41,460
and whatever is that you really need the

00:06:39,060 --> 00:06:43,770
dispersion because they are constantly

00:06:41,460 --> 00:06:45,120
improving so sometimes if you want to

00:06:43,770 --> 00:06:47,250
run these in your distribution

00:06:45,120 --> 00:06:49,440
it will either not work or it will be

00:06:47,250 --> 00:06:52,950
hard to set up or stuff like that right

00:06:49,440 --> 00:06:55,880
so they basically have a set of docker

00:06:52,950 --> 00:06:58,880
images which are updated to the latest

00:06:55,880 --> 00:07:03,090
everything right so this way you just

00:06:58,880 --> 00:07:05,250
run download the docker images run a

00:07:03,090 --> 00:07:09,630
command and it will start fuzzing the

00:07:05,250 --> 00:07:13,590
project and it's like almost effortless

00:07:09,630 --> 00:07:15,300
right it's like so at this point they're

00:07:13,590 --> 00:07:20,880
like two hundred and forty projects in

00:07:15,300 --> 00:07:24,090
the O's Fu's github repo if we and see

00:07:20,880 --> 00:07:26,510
them here so yeah there's like lots of

00:07:24,090 --> 00:07:30,270
things right like there's BC there's

00:07:26,510 --> 00:07:34,370
some up the antivirus thingy it's cool

00:07:30,270 --> 00:07:36,150
David which is like the new video stuff

00:07:34,370 --> 00:07:39,389
F&B impact

00:07:36,150 --> 00:07:42,030
there's file there's Firefox freetype

00:07:39,389 --> 00:07:50,400
course cryptic lots of lots of projects

00:07:42,030 --> 00:07:52,080
are are in others force what is also is

00:07:50,400 --> 00:07:55,470
number three

00:07:52,080 --> 00:07:59,010
it's also a software-as-a-service thing

00:07:55,470 --> 00:08:01,830
right so they have Google has lots of

00:07:59,010 --> 00:08:04,710
servers right so they basically give you

00:08:01,830 --> 00:08:07,169
a thing that will run everything for you

00:08:04,710 --> 00:08:09,919
right so it will get the docker images

00:08:07,169 --> 00:08:12,930
that you created run them for a while

00:08:09,919 --> 00:08:16,950
find the back tell you if you found the

00:08:12,930 --> 00:08:21,870
back right they are very strict on the

00:08:16,950 --> 00:08:23,789
back policy so when it finds the back it

00:08:21,870 --> 00:08:26,430
will send you an email saying I found a

00:08:23,789 --> 00:08:27,770
bug this is the back trace and the file

00:08:26,430 --> 00:08:31,020
you can use to reproduce it and whatnot

00:08:27,770 --> 00:08:33,060
you have 30 days to fix it if you don't

00:08:31,020 --> 00:08:37,050
fix it in 30 days they will make the

00:08:33,060 --> 00:08:39,240
issue public right some people say

00:08:37,050 --> 00:08:42,240
that's very extreme but I mean it's a

00:08:39,240 --> 00:08:45,240
way to force people to just get their

00:08:42,240 --> 00:08:47,970
ass and fix things right the good thing

00:08:45,240 --> 00:08:49,920
about this is that all these software

00:08:47,970 --> 00:08:52,410
needed to run this thing is free

00:08:49,920 --> 00:08:52,900
software so if you really wanted to do

00:08:52,410 --> 00:08:55,150
that

00:08:52,900 --> 00:08:56,320
your project because you're crazy you

00:08:55,150 --> 00:08:57,940
could do it

00:08:56,320 --> 00:08:59,920
you will need lots of processing power

00:08:57,940 --> 00:09:02,080
right I mean like doing fuzzing

00:08:59,920 --> 00:09:04,360
basically means running the software for

00:09:02,080 --> 00:09:05,170
a long time so I mean if Google is doing

00:09:04,360 --> 00:09:09,420
it for free

00:09:05,170 --> 00:09:13,480
why would you not let them do it right

00:09:09,420 --> 00:09:15,910
and that's what OSS Fu's number four

00:09:13,480 --> 00:09:19,150
right so basically that's an image they

00:09:15,910 --> 00:09:22,810
happen on their web so how it works is

00:09:19,150 --> 00:09:24,400
that you write the fuzzer we'll see some

00:09:22,810 --> 00:09:27,400
example fuzzers I've written for KD

00:09:24,400 --> 00:09:29,320
stuff recently it's not very hard at

00:09:27,400 --> 00:09:33,360
least the ones I wrote I guess you could

00:09:29,320 --> 00:09:36,760
go into more detail you buy the faster

00:09:33,360 --> 00:09:40,750
you commit it builds in jenkins

00:09:36,760 --> 00:09:43,120
blah blah blah finds baxter and it tells

00:09:40,750 --> 00:09:46,480
you right so it's it's basically that

00:09:43,120 --> 00:09:52,180
it's like they they run the phaser

00:09:46,480 --> 00:09:56,350
itself they put it on lots of people

00:09:52,180 --> 00:09:59,200
you're all late you put it on the on the

00:09:56,350 --> 00:10:05,580
web run for a while tell you and then

00:09:59,200 --> 00:10:11,230
you have 30 days to fix it right so what

00:10:05,580 --> 00:10:17,620
do we have in KDE and OSS fuss right we

00:10:11,230 --> 00:10:21,520
are actually running OS as fast 4k image

00:10:17,620 --> 00:10:27,730
formats since january 4k codecs since

00:10:21,520 --> 00:10:31,800
February and K archives since April kind

00:10:27,730 --> 00:10:34,870
of how related KD we are also facing

00:10:31,800 --> 00:10:39,340
poplar which is the PDF library we use

00:10:34,870 --> 00:10:44,010
since May last year and lip pickle which

00:10:39,340 --> 00:10:48,550
is for the calendaring stuff since April

00:10:44,010 --> 00:10:51,850
what all these have in common is that

00:10:48,550 --> 00:10:54,760
they may they will be probably used

00:10:51,850 --> 00:10:57,010
without you having but we will do one

00:10:54,760 --> 00:10:59,680
thing to use them right the typical

00:10:57,010 --> 00:11:02,080
example is Kay image formats right

00:10:59,680 --> 00:11:05,650
somebody will send you an email with an

00:11:02,080 --> 00:11:06,860
image and it will run code because you

00:11:05,650 --> 00:11:09,500
will preview the image

00:11:06,860 --> 00:11:11,990
in K mail and and if you have a back

00:11:09,500 --> 00:11:15,350
there it will crash KML just because

00:11:11,990 --> 00:11:18,110
somebody sent you an image with a

00:11:15,350 --> 00:11:21,380
malformed in an email with a malformed

00:11:18,110 --> 00:11:25,700
image alright so the idea here is that

00:11:21,380 --> 00:11:29,080
we have to be very very cautious about

00:11:25,700 --> 00:11:34,040
things that run without the user

00:11:29,080 --> 00:11:38,090
pressing any button right so I'm gonna

00:11:34,040 --> 00:11:39,620
show you now how the K archived all

00:11:38,090 --> 00:11:41,420
right that's something in Spanish there

00:11:39,620 --> 00:11:42,770
I give this talk in Spanish first so

00:11:41,420 --> 00:11:45,110
there's like one line in Spanish where

00:11:42,770 --> 00:11:48,100
ever do you see this it's it's big

00:11:45,110 --> 00:11:53,930
enough right I guess right so this is

00:11:48,100 --> 00:11:58,610
what we have in the USS fast github 4k

00:11:53,930 --> 00:12:08,210
archive it's very easy let me open the

00:11:58,610 --> 00:12:11,600
few files right so first the docker file

00:12:08,210 --> 00:12:14,150
it's relatively easy we have to check

00:12:11,600 --> 00:12:20,600
out everything we need right so we get

00:12:14,150 --> 00:12:24,230
lip zip sorry subtly lib zip busy exit

00:12:20,600 --> 00:12:26,300
lip and then we get cute easy M and K

00:12:24,230 --> 00:12:28,660
archive itself right that that's the

00:12:26,300 --> 00:12:32,870
things we need to to be able to fast

00:12:28,660 --> 00:12:34,730
karaka itself then we build it right

00:12:32,870 --> 00:12:36,200
it's not very hard you have to build

00:12:34,730 --> 00:12:40,190
everything but like configure make

00:12:36,200 --> 00:12:42,500
configure make configure make computer

00:12:40,190 --> 00:12:45,440
Bank cute it a bit harder yeah it

00:12:42,500 --> 00:12:48,140
doesn't like so I I do some there

00:12:45,440 --> 00:12:50,630
from cute but like ignore cute 4k a

00:12:48,140 --> 00:12:54,110
graph with the Simek make and that's it

00:12:50,630 --> 00:12:57,410
it's it's not rocket science

00:12:54,110 --> 00:12:59,030
and then the faster itself so how it

00:12:57,410 --> 00:13:02,720
works if you have to write you have to

00:12:59,030 --> 00:13:05,470
write a function whose sorry input is

00:13:02,720 --> 00:13:09,530
basically a a byte array right a

00:13:05,470 --> 00:13:14,920
carpenter and size so what we do there

00:13:09,530 --> 00:13:17,900
is basically I create all the possible

00:13:14,920 --> 00:13:20,430
archive files that character could be

00:13:17,900 --> 00:13:23,640
right so 7-zip tar tar

00:13:20,430 --> 00:13:27,000
gzip tar would be zip tie with exit zip

00:13:23,640 --> 00:13:27,839
and an R and I just like run all those

00:13:27,000 --> 00:13:32,790
codes right

00:13:27,839 --> 00:13:44,160
and these found quite a few things right

00:13:32,790 --> 00:13:49,920
if we go to the K archive log okay

00:13:44,160 --> 00:13:52,440
archive doc right so you see my name is

00:13:49,920 --> 00:13:54,149
here don't desire don't desire don't

00:13:52,440 --> 00:13:56,730
desert don't crash blah blah blah right

00:13:54,149 --> 00:13:58,890
so it found a few things more here yeah

00:13:56,730 --> 00:14:03,149
I mean it'll eyes memory memory leak in

00:13:58,890 --> 00:14:04,649
bad memory right so k archive which I'm

00:14:03,149 --> 00:14:07,050
sure it's something that people have

00:14:04,649 --> 00:14:11,220
look at the code very closely and it was

00:14:07,050 --> 00:14:15,350
written carefully still had a few bugs

00:14:11,220 --> 00:14:18,450
right one of the random box we found

00:14:15,350 --> 00:14:23,910
which is kind of interesting and fine

00:14:18,450 --> 00:14:26,459
here is K archive and very long file

00:14:23,910 --> 00:14:28,890
writes okay archive has a recursive

00:14:26,459 --> 00:14:31,260
function in which it will try to if you

00:14:28,890 --> 00:14:33,930
give it a path it was trying to find to

00:14:31,260 --> 00:14:36,779
which folder it belongs right so it will

00:14:33,930 --> 00:14:40,800
go up up up up trying to find the folder

00:14:36,779 --> 00:14:48,680
it belongs if you get a path which is

00:14:40,800 --> 00:14:48,680
longer than for like five thousand

00:14:48,709 --> 00:14:54,630
characters and basically being a be a

00:14:52,020 --> 00:14:57,800
slash a slash a slash right so it's like

00:14:54,630 --> 00:15:00,660
very short name directory names and just

00:14:57,800 --> 00:15:03,870
when inside the other this thing will

00:15:00,660 --> 00:15:05,880
recur so much it will end up exhausting

00:15:03,870 --> 00:15:08,610
your stack right so basically the the

00:15:05,880 --> 00:15:11,550
the stack will just grow to my angle

00:15:08,610 --> 00:15:14,700
crash so we did a very poor man solution

00:15:11,550 --> 00:15:17,100
which is just don't recourse too much

00:15:14,700 --> 00:15:21,329
which in this case it should work

00:15:17,100 --> 00:15:24,450
because I found out that only like even

00:15:21,329 --> 00:15:26,760
with a small stack it will crash after

00:15:24,450 --> 00:15:30,209
two thousand and five hundred recursions

00:15:26,760 --> 00:15:32,400
which is like a very long path so I

00:15:30,209 --> 00:15:34,019
think like Linux actually doesn't let

00:15:32,400 --> 00:15:38,999
you have a long about that

00:15:34,019 --> 00:15:42,569
between like the path max is 4,000

00:15:38,999 --> 00:15:46,069
characters so you if you even if you do

00:15:42,569 --> 00:15:48,929
like one directories of one character

00:15:46,069 --> 00:15:50,879
you still need another one for the slash

00:15:48,929 --> 00:15:52,709
so that should be fine

00:15:50,879 --> 00:15:54,360
hopefully otherwise somebody has to

00:15:52,709 --> 00:15:57,829
rewrite this to not be recursive right

00:15:54,360 --> 00:16:02,939
which is appended let's not do that so

00:15:57,829 --> 00:16:07,529
yeah so that was a Archive k image

00:16:02,939 --> 00:16:15,299
formats is basically the same if you see

00:16:07,529 --> 00:16:17,100
the father yep Lou it's the same thing

00:16:15,299 --> 00:16:19,170
you get the data you guide you create an

00:16:17,100 --> 00:16:25,759
image you you read it right it's it's

00:16:19,170 --> 00:16:32,699
not it's nothing very complicated so

00:16:25,759 --> 00:16:36,989
yeah sorry yeah we've found lots of bugs

00:16:32,699 --> 00:16:39,269
in our image formats which are like the

00:16:36,989 --> 00:16:42,920
very random thing this we have so if you

00:16:39,269 --> 00:16:51,360
if you look at our image formats we have

00:16:42,920 --> 00:16:54,389
readers for things like brass and LGB

00:16:51,360 --> 00:16:56,759
and TGA and that's the thingy but

00:16:54,389 --> 00:16:59,429
we only support a very old format

00:16:56,759 --> 00:17:02,399
so yeah it's not very useful right but

00:16:59,429 --> 00:17:05,399
if you look at the log yeah I did fix

00:17:02,399 --> 00:17:07,620
lots of bugs here right it goes after

00:17:05,399 --> 00:17:12,480
the first page and and then I think a

00:17:07,620 --> 00:17:14,730
bit more yeah so basically we were like

00:17:12,480 --> 00:17:16,589
we were vulnerable to people sending us

00:17:14,730 --> 00:17:18,419
random images and crushing everything

00:17:16,589 --> 00:17:20,579
right actually that started because

00:17:18,419 --> 00:17:22,889
somebody sent an email to security at

00:17:20,579 --> 00:17:25,860
Keo torque saying I have this image that

00:17:22,889 --> 00:17:28,199
crashes everything and then I started

00:17:25,860 --> 00:17:31,399
running OS s food and like yeah there's

00:17:28,199 --> 00:17:35,250
a few more images that gosh everything

00:17:31,399 --> 00:17:38,370
what's even more interesting is that it

00:17:35,250 --> 00:17:43,200
found issues in the PNG hundr right so

00:17:38,370 --> 00:17:45,450
what we're fuzzing there for our we're

00:17:43,200 --> 00:17:47,279
only passing our own code right so we

00:17:45,450 --> 00:17:47,820
are we only sending like the inputs we

00:17:47,279 --> 00:17:51,660
have

00:17:47,820 --> 00:17:54,540
is a file or a LGB file or whatever

00:17:51,660 --> 00:17:57,840
but since its coverage based and it also

00:17:54,540 --> 00:18:00,780
saw that it could end up in in the PNG

00:17:57,840 --> 00:18:03,510
it was able to morph the file enough so

00:18:00,780 --> 00:18:06,030
it ended up inside the the PNG file

00:18:03,510 --> 00:18:08,970
handler inside it queued itself right I

00:18:06,030 --> 00:18:11,370
found that in lots of cases this was

00:18:08,970 --> 00:18:13,920
being used in an initialized manner

00:18:11,370 --> 00:18:15,990
which is bad right but that shows how

00:18:13,920 --> 00:18:18,600
powerful the thing is that you start

00:18:15,990 --> 00:18:20,700
giving it a file and it will morph

00:18:18,600 --> 00:18:24,300
the file to be something the PNG

00:18:20,700 --> 00:18:27,420
handler half of understands and then

00:18:24,300 --> 00:18:33,240
fails reading it third so it is really

00:18:27,420 --> 00:18:36,420
really really very powerful so future

00:18:33,240 --> 00:18:42,380
work we should face more things we have

00:18:36,420 --> 00:18:45,600
more things in in KDE that are run

00:18:42,380 --> 00:18:48,450
automatically right Balu is like you put

00:18:45,600 --> 00:18:49,920
a file in your in your file system and

00:18:48,450 --> 00:18:52,130
Balu will go there and like will do all

00:18:49,920 --> 00:18:56,490
random on it right that has to be

00:18:52,130 --> 00:19:00,390
made sure it won't crash that's good

00:18:56,490 --> 00:19:02,850
same thing for K files metadata more

00:19:00,390 --> 00:19:04,770
things pim related like I'm pretty sure

00:19:02,850 --> 00:19:07,620
that when you get an email lots of

00:19:04,770 --> 00:19:12,090
things happen inside PIM that we should

00:19:07,620 --> 00:19:13,350
make sure are not crashing yeah the

00:19:12,090 --> 00:19:15,750
problem is somebody needs to work on

00:19:13,350 --> 00:19:18,210
that right it's not very difficult as I

00:19:15,750 --> 00:19:20,100
showed you but only like it's very easy

00:19:18,210 --> 00:19:21,360
to do if your input is a byte array

00:19:20,100 --> 00:19:23,550
right if you input this right array

00:19:21,360 --> 00:19:25,950
that's easy like you can plug it in the

00:19:23,550 --> 00:19:28,470
function and it will be trivial if your

00:19:25,950 --> 00:19:30,240
input is something else well there's not

00:19:28,470 --> 00:19:34,860
there's more work that that needs to be

00:19:30,240 --> 00:19:38,390
done right yep and that's my talk we

00:19:34,860 --> 00:19:38,390
have some time for questions I think

00:19:40,380 --> 00:19:48,009
[Applause]

00:19:49,670 --> 00:19:54,840
so considering that is not that heavy

00:19:53,010 --> 00:19:56,940
running this fuzzer and you need to run

00:19:54,840 --> 00:19:59,670
anyway it's not possible to actually add

00:19:56,940 --> 00:20:01,110
in this in the unit tests so at the

00:19:59,670 --> 00:20:03,180
point that every function data test and

00:20:01,110 --> 00:20:05,250
we pass the fuser so we already have in

00:20:03,180 --> 00:20:06,750
there incompletely build system you can

00:20:05,250 --> 00:20:13,110
guarantee that all the frameworks by

00:20:06,750 --> 00:20:15,150
Depot been tested so this is not

00:20:13,110 --> 00:20:19,680
possible to put in this in unit tests by

00:20:15,150 --> 00:20:22,230
Devo so well it's it is I mean it will

00:20:19,680 --> 00:20:23,820
image to run for hours sometimes to find

00:20:22,230 --> 00:20:27,180
the back right so that you can't really

00:20:23,820 --> 00:20:28,800
I mean you could add unit tests for

00:20:27,180 --> 00:20:30,210
every single crash you found that's

00:20:28,800 --> 00:20:33,420
something we could do that's something

00:20:30,210 --> 00:20:37,380
table it want me to do for K archive and

00:20:33,420 --> 00:20:39,540
I didn't do it because there's like 20

00:20:37,380 --> 00:20:41,730
or 30 files that make it crash right so

00:20:39,540 --> 00:20:44,520
it's like and the thing and this thing

00:20:41,730 --> 00:20:47,370
just still runs every day so it if you

00:20:44,520 --> 00:20:49,080
regress it will find it right I mean it

00:20:47,370 --> 00:20:51,720
will take a while it will not be part of

00:20:49,080 --> 00:20:54,020
the unit test we could put it as you

00:20:51,720 --> 00:20:56,790
type we could put unit tests for all the

00:20:54,020 --> 00:21:00,270
cases we found so to make sure we don't

00:20:56,790 --> 00:21:02,460
regress we haven't been doing that for

00:21:00,270 --> 00:21:06,230
now but I mean that we'd wanted to do

00:21:02,460 --> 00:21:06,230
that I could be convinced otherwise

00:21:08,830 --> 00:21:12,309
any more questions

00:21:17,650 --> 00:21:22,730
almost I was going to say thank you but

00:21:19,789 --> 00:21:24,049
I waited half a minute I have a seven

00:21:22,730 --> 00:21:26,600
more yeah thanks for that

00:21:24,049 --> 00:21:28,760
and unfortunately I missed the beginning

00:21:26,600 --> 00:21:32,270
I will talk do I understand correctly

00:21:28,760 --> 00:21:34,460
that you you add this code to some

00:21:32,270 --> 00:21:35,900
Google repository and they run the stuff

00:21:34,460 --> 00:21:37,730
yeah right so you have to do is probably

00:21:35,900 --> 00:21:39,980
code and you only run the code you

00:21:37,730 --> 00:21:44,419
uploaded they will run it every day for

00:21:39,980 --> 00:21:46,370
a bit and they they keep the keep the

00:21:44,419 --> 00:21:50,960
state right so like tomorrow they don't

00:21:46,370 --> 00:21:55,490
test the same just continue yeah and you

00:21:50,960 --> 00:21:58,220
get notifications when yeah because the

00:21:55,490 --> 00:21:59,870
it it's related to that question how do

00:21:58,220 --> 00:22:03,080
we ensure no regressions in the wrong

00:21:59,870 --> 00:22:05,690
run so I'm wondering if we can treat it

00:22:03,080 --> 00:22:07,309
as CI as in in two years if we

00:22:05,690 --> 00:22:09,620
reintroduce a big they will find it

00:22:07,309 --> 00:22:12,260
right through the magic of random press

00:22:09,620 --> 00:22:15,770
so somehow try the same fine again right

00:22:12,260 --> 00:22:19,039
right so there is so the public box you

00:22:15,770 --> 00:22:21,590
can see them there's this there's a bug

00:22:19,039 --> 00:22:24,049
tracker somewhere I don't have a link

00:22:21,590 --> 00:22:25,669
here anyway there's tactic so they when

00:22:24,049 --> 00:22:27,409
it finds a back it will give you 30 days

00:22:25,669 --> 00:22:29,900
to fix it and if you don't fix it it

00:22:27,409 --> 00:22:30,620
will be public so the public box you can

00:22:29,900 --> 00:22:32,240
go to a web page

00:22:30,620 --> 00:22:33,380
it's a bug tracker and it's like

00:22:32,240 --> 00:22:37,100
everything this this is everything

00:22:33,380 --> 00:22:41,210
public ok and the ones that you fix I

00:22:37,100 --> 00:22:43,309
think are also public so it one of the

00:22:41,210 --> 00:22:45,440
things we could do is go here make sure

00:22:43,309 --> 00:22:47,809
there is no like as part of release

00:22:45,440 --> 00:22:51,020
process go here make sure there's

00:22:47,809 --> 00:22:53,210
nothing new we can also add more people

00:22:51,020 --> 00:22:55,809
to the emails that iris I received like

00:22:53,210 --> 00:22:58,130
at the moment only I receive the emails

00:22:55,809 --> 00:23:00,850
problem the only the only problem is

00:22:58,130 --> 00:23:05,299
needs to be a Google email it's a bit

00:23:00,850 --> 00:23:06,740
man for that I like the idea of having

00:23:05,299 --> 00:23:09,409
to check your web page before releasing

00:23:06,740 --> 00:23:11,570
I do check already see I and a few lines

00:23:09,409 --> 00:23:14,179
I could check the same thing sounds good

00:23:11,570 --> 00:23:15,520
yeah you send me links yeah and look

00:23:14,179 --> 00:23:19,750
into it

00:23:15,520 --> 00:23:19,750
there was also question back there

00:23:26,519 --> 00:23:34,419
do you have some sort of stats some kind

00:23:29,860 --> 00:23:38,110
of hall of fame or Hall of Shame how how

00:23:34,419 --> 00:23:43,690
do k the libraries compared to other

00:23:38,110 --> 00:23:46,690
open-source projects in terms of number

00:23:43,690 --> 00:23:51,279
of issues or like code coverage things

00:23:46,690 --> 00:23:54,460
like that I don't I mean you can see the

00:23:51,279 --> 00:23:55,960
code coverage but not at which you can

00:23:54,460 --> 00:23:57,820
so you can only see the code coverage

00:23:55,960 --> 00:24:00,009
for your own project so I can see the

00:23:57,820 --> 00:24:02,259
code coverage for K image formats right

00:24:00,009 --> 00:24:04,749
but I can't see it for Firefox so they

00:24:02,259 --> 00:24:08,529
don't have this kind of communication

00:24:04,749 --> 00:24:10,029
thing in which you can do okay I don't

00:24:08,529 --> 00:24:16,389
see it it must be somewhere else I don't

00:24:10,029 --> 00:24:18,490
know what is right maybe they do have it

00:24:16,389 --> 00:24:22,240
internally but I not sure if that's

00:24:18,490 --> 00:24:23,740
public or if it is I will be interested

00:24:22,240 --> 00:24:34,960
to know where it is I don't know what it

00:24:23,740 --> 00:24:36,490
is what you give hi sorry I came late to

00:24:34,960 --> 00:24:38,399
talks maybe you already talked about it

00:24:36,490 --> 00:24:40,840
about it

00:24:38,399 --> 00:24:44,289
the fuzzing is it just a stream of

00:24:40,840 --> 00:24:46,179
random bytes that come on so it is it's

00:24:44,289 --> 00:24:49,450
it's a very smart thingy and it will

00:24:46,179 --> 00:24:51,850
it's basically copy paste so it gives it

00:24:49,450 --> 00:24:54,159
a random random error number right and

00:24:51,850 --> 00:24:57,730
then it leaves one bit and then it tries

00:24:54,159 --> 00:24:59,679
to see which barrel changed because you

00:24:57,730 --> 00:25:04,119
flip that bit and then if you have

00:24:59,679 --> 00:25:06,850
something like this right and also only

00:25:04,119 --> 00:25:09,460
if it knows that the only interesting

00:25:06,850 --> 00:25:12,519
values for X are 49 and 50 right because

00:25:09,460 --> 00:25:15,279
like it's the two values that will run

00:25:12,519 --> 00:25:17,320
the both branches so it will it's not I

00:25:15,279 --> 00:25:20,279
mean it's random at the beginning but

00:25:17,320 --> 00:25:24,039
then it learns about which bit

00:25:20,279 --> 00:25:28,119
influences each variable and it will not

00:25:24,039 --> 00:25:30,310
be random I mean it's how random it's

00:25:28,119 --> 00:25:32,710
smart let's put it this way

00:25:30,310 --> 00:25:34,690
and can you also kind of define what

00:25:32,710 --> 00:25:36,730
kind of inputs come in so for example if

00:25:34,690 --> 00:25:38,800
you have a HTML parser you don't want

00:25:36,730 --> 00:25:41,260
random bytes coming in because what you

00:25:38,800 --> 00:25:44,050
do want around yes there is a way to

00:25:41,260 --> 00:25:46,870
give it a dictionary of kind of like

00:25:44,050 --> 00:25:53,500
those are the keywords that you should

00:25:46,870 --> 00:25:55,330
be flipping or working on right like you

00:25:53,500 --> 00:25:57,100
can give him some direction I really

00:25:55,330 --> 00:26:01,570
haven't done that but I know you can

00:25:57,100 --> 00:26:12,070
kind of instruct him what to focus on

00:26:01,570 --> 00:26:14,120
okay thank you more questions okay thank

00:26:12,070 --> 00:26:20,630
you how about thank you

00:26:14,120 --> 00:26:20,630

YouTube URL: https://www.youtube.com/watch?v=aiMEJwzh2GY


