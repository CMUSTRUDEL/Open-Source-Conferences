Title: Kevin Ottens & Franck Arrecot - Test Doubles: Unleash the Doppelgängers - Akademy 2015
Publication date: 2016-04-02
Playlist: Akademy 2015
Description: 
	Last year, we covered a wide range of Craftsmanship techniques touching architecture, code structure, project management... one of the recurring theme was testing. None of those topics could be covered in depth as we focused on
the big picture, but this year we're back and we will dive deeper in this test thing. In particular we will look at what every craftsman should have in his toolbox: test doubles.

Hopefully, most of you are now convinced that testing can be a good thing... but it can also make your life miserable if you don't have a proper design. To get to this superior level of internal design, you need the proper tools to prepare the scaffolding of your application while applying TDD. Those tools are falling under the broad name of test doubles.

We'll first cover the different type of test doubles: stubs, mocks, spies, fakes and dummies. It is especially important to settle on a common vocabulary as the frontiers between those can be fuzzy. Then, we'll present the different contexts in which you can use them. In particular we'll try to highlight a potential strategy to pick the right type of double depending on the work you're doing on your software and it's level of maturity. In order to present this strategy, we'll try to focus on a small code example and make it grow showing how the design is supported by our doubles and tests.

Of course, we won't conclude this talk before we also covered what a doppelgänger is.

Speaker: Kevin Ottens & Franck Arrecot
License: Creative Commons Attribution 4.0 International License http://creativecommons.org/licenses/by/4.0/
Akademy 2015: https://akademy.kde.org/2015
KDE: https://www.kde.org/
Donate: https://www.kde.org/donate
Captions: 
	00:00:08,400 --> 00:00:14,030
so welcome everyone this year so we'll

00:00:12,370 --> 00:00:17,330
be having a

00:00:14,030 --> 00:00:19,910
tested us and we will be also talking

00:00:17,330 --> 00:00:24,080
about some type of creators around the

00:00:19,910 --> 00:00:27,980
way like doppelgangers for cystic I will

00:00:24,080 --> 00:00:30,050
do it with pump with a former student of

00:00:27,980 --> 00:00:32,840
the poor cemetery University interviews

00:00:30,050 --> 00:00:35,570
and he contributed you to know can k

00:00:32,840 --> 00:00:38,600
people and now nowadays is one of the

00:00:35,570 --> 00:00:41,570
main contributor zone than chin as you

00:00:38,600 --> 00:00:45,170
know this kind of my project and is the

00:00:41,570 --> 00:00:48,079
resident software class man at caleb as

00:00:45,170 --> 00:00:49,460
for me i'm giving utterance i'm also

00:00:48,079 --> 00:00:51,530
from a student of deportability

00:00:49,460 --> 00:00:55,370
university and i keep teaching there

00:00:51,530 --> 00:00:59,269
part time I've been walking for the KD

00:00:55,370 --> 00:01:03,220
community since 2003 so all of my life

00:00:59,269 --> 00:01:06,680
and I got a PhD in addition intelligence

00:01:03,220 --> 00:01:10,790
2007 i'm also a resident software a

00:01:06,680 --> 00:01:12,440
smile and a trainer at caleb so as you

00:01:10,790 --> 00:01:16,310
know for a few years now we've been

00:01:12,440 --> 00:01:19,070
banging a drum of GDG so test driven

00:01:16,310 --> 00:01:22,329
development but really when you say that

00:01:19,070 --> 00:01:25,640
just a labor right that's like a brand

00:01:22,329 --> 00:01:28,430
we're selling soap or something that's

00:01:25,640 --> 00:01:31,310
still as a question of how you write

00:01:28,430 --> 00:01:34,490
this test properly there are several

00:01:31,310 --> 00:01:37,100
challenges with that one of them and

00:01:34,490 --> 00:01:40,729
main one being really how you insulate

00:01:37,100 --> 00:01:43,159
parts of your design during the test and

00:01:40,729 --> 00:01:45,680
so we need solutions for that those

00:01:43,159 --> 00:01:50,030
solutions that what we call test the

00:01:45,680 --> 00:01:52,189
bears the name you have to think about

00:01:50,030 --> 00:01:54,890
movies you know we've sent the birds

00:01:52,189 --> 00:01:56,899
where you have one person looking like

00:01:54,890 --> 00:01:59,600
the real actor what will it take this

00:01:56,899 --> 00:02:04,939
place during a stand whether the same

00:01:59,600 --> 00:02:07,510
here but that would be the develop a

00:02:04,939 --> 00:02:09,820
class which will take its place during

00:02:07,510 --> 00:02:11,860
during a test there are several types of

00:02:09,820 --> 00:02:13,870
tests the birds which exist and that's

00:02:11,860 --> 00:02:16,630
what we are going to explore in the

00:02:13,870 --> 00:02:20,260
store before that without definition

00:02:16,630 --> 00:02:23,200
which I expected from Wikipedia on what

00:02:20,260 --> 00:02:25,000
they are so that says in automated unit

00:02:23,200 --> 00:02:27,840
testing it may be necessary to use

00:02:25,000 --> 00:02:31,570
objects or procedure that look and

00:02:27,840 --> 00:02:33,430
behave like their release internet

00:02:31,570 --> 00:02:35,530
counterparts but are actually simplified

00:02:33,430 --> 00:02:38,320
versions that will use the complexity

00:02:35,530 --> 00:02:40,450
and facilitate the testing the emphasis

00:02:38,320 --> 00:02:43,030
is my own in the definition I think

00:02:40,450 --> 00:02:44,980
that's really three main characteristic

00:02:43,030 --> 00:02:46,330
of test oh god they have to look like

00:02:44,980 --> 00:02:49,300
the original that I have to behave

00:02:46,330 --> 00:02:51,160
almost like the original and then it's a

00:02:49,300 --> 00:02:53,170
question of complexity inside of your

00:02:51,160 --> 00:02:55,860
test which will guide you into picking

00:02:53,170 --> 00:02:59,920
one of the different type of desert

00:02:55,860 --> 00:03:02,380
there's roughly four types of tests

00:02:59,920 --> 00:03:06,430
numbers it's kind of a continuum so you

00:03:02,380 --> 00:03:08,830
can't really categorize them cruelly on

00:03:06,430 --> 00:03:12,280
the frontiers it's kind of fuse evil and

00:03:08,830 --> 00:03:14,380
you get from one to the other type but

00:03:12,280 --> 00:03:20,170
that's roughly so the minister blocks

00:03:14,380 --> 00:03:22,230
and faith and you can solve them on the

00:03:20,170 --> 00:03:24,489
complexity axis because you generally

00:03:22,230 --> 00:03:26,260
pick one depending on the level of

00:03:24,489 --> 00:03:28,120
complexity you are being your test and

00:03:26,260 --> 00:03:30,250
they are basically tool to move that

00:03:28,120 --> 00:03:32,170
complexity outside of your test inside

00:03:30,250 --> 00:03:35,680
of the test the bird okay so it has too

00:03:32,170 --> 00:03:37,540
much match in some way and so all the

00:03:35,680 --> 00:03:39,459
question for picking that which amount

00:03:37,540 --> 00:03:42,430
of complexity I want to move from my

00:03:39,459 --> 00:03:44,530
test which design expect I want to

00:03:42,430 --> 00:03:47,560
validate with my step my test is that

00:03:44,530 --> 00:03:52,330
just verifying the state of my code

00:03:47,560 --> 00:03:53,860
under test or its behavior and so in

00:03:52,330 --> 00:03:56,650
title we've been talking about Google

00:03:53,860 --> 00:03:59,019
beggar girl so she left him carry on

00:03:56,650 --> 00:04:01,030
with that so what r and open young girls

00:03:59,019 --> 00:04:02,980
in fiction and folklore doppelganger is

00:04:01,030 --> 00:04:05,490
a look-alike or number of a living

00:04:02,980 --> 00:04:07,860
person sometimes portrayed as

00:04:05,490 --> 00:04:09,800
phenomenal well test the birds at it

00:04:07,860 --> 00:04:12,930
like that right there are some one the

00:04:09,800 --> 00:04:15,180
vanguard of a leading class instead of

00:04:12,930 --> 00:04:17,760
being the peg angles of living person

00:04:15,180 --> 00:04:19,470
and they can be of different types of a

00:04:17,760 --> 00:04:22,140
llamar phenomenon depending on the

00:04:19,470 --> 00:04:23,790
complexity you have to deal with okay so

00:04:22,140 --> 00:04:27,390
now we are going to see the different

00:04:23,790 --> 00:04:29,460
categories first one being the Miss so

00:04:27,390 --> 00:04:33,240
that the simplest form of testable you

00:04:29,460 --> 00:04:34,890
can add in a test anything that

00:04:33,240 --> 00:04:37,890
basically an idea where anything goes

00:04:34,890 --> 00:04:39,900
right you will pass something it's that

00:04:37,890 --> 00:04:42,330
I passive and lupe and no one really

00:04:39,900 --> 00:04:44,640
uses it that's not satisfy some

00:04:42,330 --> 00:04:46,350
interface so if we look at our

00:04:44,640 --> 00:04:48,180
paranormal phenomena that would be

00:04:46,350 --> 00:04:49,560
something like the wood all right you

00:04:48,180 --> 00:04:52,280
have something which is that a passing

00:04:49,560 --> 00:04:54,330
you can just pin it you can torture it

00:04:52,280 --> 00:04:56,670
because you can't really talk shows the

00:04:54,330 --> 00:04:59,550
original and that won't really have any

00:04:56,670 --> 00:05:03,000
consequence rain well except if you

00:04:59,550 --> 00:05:04,500
actually believes and so on so the

00:05:03,000 --> 00:05:06,960
definition of them is that would be this

00:05:04,500 --> 00:05:09,480
one the ways are used when a parameter

00:05:06,960 --> 00:05:11,520
is needed for the testing method or

00:05:09,480 --> 00:05:13,590
construct all and so on but we found

00:05:11,520 --> 00:05:17,700
actually needing to use the parameter

00:05:13,590 --> 00:05:19,290
okay maybe when you have your test

00:05:17,700 --> 00:05:21,120
running okay you pass a parameter that

00:05:19,290 --> 00:05:23,490
you know that that particular method in

00:05:21,120 --> 00:05:26,550
that particular case is not going to use

00:05:23,490 --> 00:05:30,840
it then you just pass some the me value

00:05:26,550 --> 00:05:33,290
instead and something which will be a

00:05:30,840 --> 00:05:36,450
back and not really react so passive

00:05:33,290 --> 00:05:38,580
that could be a new pointer or something

00:05:36,450 --> 00:05:41,100
equivalent like but the me identifier

00:05:38,580 --> 00:05:42,720
because you know it won't be used so

00:05:41,100 --> 00:05:45,630
I've been talking quite a bit already

00:05:42,720 --> 00:05:48,540
and so I will leaves me Mike to frying

00:05:45,630 --> 00:05:52,730
so that you can show you an example of

00:05:48,540 --> 00:05:56,130
the week so can you hear me when I guess

00:05:52,730 --> 00:05:58,200
okay so I need the pointer okay so I'm

00:05:56,130 --> 00:06:02,100
not gonna show then she let you know is

00:05:58,200 --> 00:06:03,870
it to do application keep it simple so

00:06:02,100 --> 00:06:06,510
we're going to mostly look at code and

00:06:03,870 --> 00:06:07,529
test for basically which is always

00:06:06,510 --> 00:06:10,529
having a

00:06:07,529 --> 00:06:13,019
name and the structure we forgiven which

00:06:10,529 --> 00:06:15,209
is basically an initialization when

00:06:13,019 --> 00:06:16,349
which is the test and then it's the test

00:06:15,209 --> 00:06:19,469
checking making sure everything went

00:06:16,349 --> 00:06:21,929
right okay so in order to see the deme

00:06:19,469 --> 00:06:25,079
we gonna see the should add task because

00:06:21,929 --> 00:06:28,019
we managing task convention so we have a

00:06:25,079 --> 00:06:30,719
given part of initial I stuff in the

00:06:28,019 --> 00:06:32,399
test we're going to basically add task

00:06:30,719 --> 00:06:33,839
here you can see just look at the

00:06:32,399 --> 00:06:35,879
selection I'm doing just don't try to

00:06:33,839 --> 00:06:39,149
reach to read our alignment that would

00:06:35,879 --> 00:06:42,899
not be helpful so in order to do so we

00:06:39,149 --> 00:06:44,189
need to initialize an entity and here

00:06:42,899 --> 00:06:45,869
you can see me as something me because

00:06:44,189 --> 00:06:47,999
in order to create a task we don't need

00:06:45,869 --> 00:06:49,769
note a note entities totally unrelated

00:06:47,999 --> 00:06:52,049
and will not be use it it will be

00:06:49,769 --> 00:06:53,849
passive during the test so instead of

00:06:52,049 --> 00:06:55,709
passing a real object what we do here is

00:06:53,849 --> 00:06:59,279
we created Remy as giving said and

00:06:55,709 --> 00:07:02,219
basically it's a new pointer a crucial

00:06:59,279 --> 00:07:03,749
pointer but initialize as well so this

00:07:02,219 --> 00:07:06,869
example is quite trivial and after it

00:07:03,749 --> 00:07:17,639
will be way more come wed more complex

00:07:06,869 --> 00:07:20,819
and useful so that's a first case so all

00:07:17,639 --> 00:07:24,239
them is they oppose and cons right so

00:07:20,819 --> 00:07:26,339
the good thing about them is extremely

00:07:24,239 --> 00:07:29,759
simple to use right as we've seen while

00:07:26,339 --> 00:07:31,739
basically a pointer acid whether and you

00:07:29,759 --> 00:07:35,489
probably already do that without even

00:07:31,739 --> 00:07:37,079
knowing and that's a mean for in your

00:07:35,489 --> 00:07:38,999
test you avoid creating a lot of

00:07:37,079 --> 00:07:40,709
collaborate or objects for nothing right

00:07:38,999 --> 00:07:45,119
because you know they won't be it won't

00:07:40,709 --> 00:07:47,459
be used on the other end they just get

00:07:45,119 --> 00:07:49,769
dependencies and that's it right they

00:07:47,459 --> 00:07:52,289
won't help you to enforce anything or

00:07:49,769 --> 00:07:54,599
any type of checking in your test and

00:07:52,289 --> 00:07:56,909
your current artist has to be able to

00:07:54,599 --> 00:07:59,009
cope with the fact that they are Islamic

00:07:56,909 --> 00:08:00,720
right it does not die just because you

00:07:59,009 --> 00:08:05,130
passed a new

00:08:00,720 --> 00:08:07,080
so you need to be ready for that so they

00:08:05,130 --> 00:08:11,300
won't go everywhere so that's why we

00:08:07,080 --> 00:08:11,300
have more complex cases like stubs and

00:08:12,890 --> 00:08:18,180
that's because now you indicate where

00:08:15,870 --> 00:08:20,520
for you see with the W basically just

00:08:18,180 --> 00:08:22,650
ignore it ranked you don't you just pass

00:08:20,520 --> 00:08:25,410
it around and that's it now you need

00:08:22,650 --> 00:08:28,260
something that you can beat okay but you

00:08:25,410 --> 00:08:30,780
can written which will react always in

00:08:28,260 --> 00:08:32,580
the same way every time you poke at it

00:08:30,780 --> 00:08:34,830
right so that's a bit like a zombie

00:08:32,580 --> 00:08:36,719
right we can meet head out of it and it

00:08:34,830 --> 00:08:38,310
mean always carry on asking for our

00:08:36,719 --> 00:08:41,909
brains right that's the only thing it

00:08:38,310 --> 00:08:43,349
does it's totally predictable in its in

00:08:41,909 --> 00:08:47,010
its behavior and that's what we are

00:08:43,349 --> 00:08:48,930
after here so steps i use for providing

00:08:47,010 --> 00:08:51,690
the tested code within direct input

00:08:48,930 --> 00:08:53,580
because very often in your testing code

00:08:51,690 --> 00:08:55,560
you will call method and you pass

00:08:53,580 --> 00:08:57,480
parameters to that method okay so that's

00:08:55,560 --> 00:09:00,330
direct input for your code under test

00:08:57,480 --> 00:09:03,120
but generally when you start to have a

00:09:00,330 --> 00:09:05,280
system while some of the input you pass

00:09:03,120 --> 00:09:06,870
directly and some of the input of the

00:09:05,280 --> 00:09:09,660
code under test is actually coming from

00:09:06,870 --> 00:09:11,780
some other collaborator object that

00:09:09,660 --> 00:09:14,970
would be a step that's a way for you to

00:09:11,780 --> 00:09:18,450
inject values inside of your car under

00:09:14,970 --> 00:09:21,780
test that's not a direct arbiter of what

00:09:18,450 --> 00:09:23,580
you're manipulating the soup has caused

00:09:21,780 --> 00:09:25,440
our studies basically you have something

00:09:23,580 --> 00:09:28,470
which returns always the same value that

00:09:25,440 --> 00:09:31,680
can be a bit more refined you could have

00:09:28,470 --> 00:09:34,440
something which returns value a then B

00:09:31,680 --> 00:09:37,980
and C always in the same in the same way

00:09:34,440 --> 00:09:40,440
and predictable order sometimes I might

00:09:37,980 --> 00:09:42,450
record beat you then we get slightly

00:09:40,440 --> 00:09:44,610
into the mocking territories that we see

00:09:42,450 --> 00:09:46,140
later on and they are meant for state

00:09:44,610 --> 00:09:48,800
checking because the idea that you

00:09:46,140 --> 00:09:51,230
create your object which will be your

00:09:48,800 --> 00:09:54,649
when the test you create your stubs

00:09:51,230 --> 00:09:56,420
think everyone together you manipulate

00:09:54,649 --> 00:09:58,459
the code under test and then you check

00:09:56,420 --> 00:10:01,250
the state of that current state of the

00:09:58,459 --> 00:10:04,820
different steps and you declare that was

00:10:01,250 --> 00:10:08,589
fine or not fine okay make that make

00:10:04,820 --> 00:10:08,589
more concrete we have another example

00:10:16,820 --> 00:10:21,660
okay so we're going to look at this

00:10:19,290 --> 00:10:23,400
piece of code so again just follow the

00:10:21,660 --> 00:10:27,900
selection otherwise we're gonna have any

00:10:23,400 --> 00:10:29,820
day okay so then she is using an editor

00:10:27,900 --> 00:10:31,590
basically when you select a task you can

00:10:29,820 --> 00:10:34,320
have the detail of the task like the

00:10:31,590 --> 00:10:38,280
title description and some tests some

00:10:34,320 --> 00:10:40,650
start date is done and everything so the

00:10:38,280 --> 00:10:42,540
editor is basically a widget and II use

00:10:40,650 --> 00:10:45,390
a model so here we're going to try to

00:10:42,540 --> 00:10:47,010
test so editor but you're not gonna use

00:10:45,390 --> 00:10:49,020
a real model so we're going to stop it

00:10:47,010 --> 00:10:52,140
that's why you can see here that the

00:10:49,020 --> 00:10:55,170
reddit AMA registered in order to do so

00:10:52,140 --> 00:10:59,220
with what we want is to set it up so the

00:10:55,170 --> 00:11:00,750
test is about verifying that the task

00:10:59,220 --> 00:11:03,540
which is delegate to someone will

00:11:00,750 --> 00:11:07,530
display a certain level while some text

00:11:03,540 --> 00:11:09,420
basically so get back to the stable in

00:11:07,530 --> 00:11:11,880
the initialization what we do is create

00:11:09,420 --> 00:11:15,750
the stub and this is it up the way we

00:11:11,880 --> 00:11:17,940
want so basically we made the task king

00:11:15,750 --> 00:11:20,370
available we set up the test that we

00:11:17,940 --> 00:11:23,640
need to be display later and after we

00:11:20,370 --> 00:11:26,250
will really do the test by putting

00:11:23,640 --> 00:11:28,350
setting up the modeling tools ready talk

00:11:26,250 --> 00:11:32,340
and we want to make sure after that that

00:11:28,350 --> 00:11:37,290
the text is displayed so is visibly here

00:11:32,340 --> 00:11:39,390
oops the text is visible here so what we

00:11:37,290 --> 00:11:42,270
do basically as Kevin said is we set up

00:11:39,390 --> 00:11:43,740
a really predictable object now canto

00:11:42,270 --> 00:11:47,130
part of a real object which is ready the

00:11:43,740 --> 00:11:50,430
etomidate step we set it up with this

00:11:47,130 --> 00:11:52,230
value we do the right test here we pass

00:11:50,430 --> 00:11:54,480
basically the step not the real object

00:11:52,230 --> 00:11:56,700
and back there we make sure that

00:11:54,480 --> 00:11:58,860
everything went well and it is because

00:11:56,700 --> 00:12:00,810
it's a really simple version of energy

00:11:58,860 --> 00:12:03,330
and existing entity because you made it

00:12:00,810 --> 00:12:04,089
predictable you just set the indirect

00:12:03,330 --> 00:12:06,309
output

00:12:04,089 --> 00:12:16,360
when speaking about jesus estate that's

00:12:06,309 --> 00:12:18,399
all okay so all steps they will allow us

00:12:16,360 --> 00:12:21,509
to factor out some of the test project

00:12:18,399 --> 00:12:24,579
and they will end earth to make the

00:12:21,509 --> 00:12:27,009
setup and steak chicken or four tests

00:12:24,579 --> 00:12:29,589
more readable in general that's

00:12:27,009 --> 00:12:32,259
something here we use our own class

00:12:29,589 --> 00:12:35,199
Costard okay that's something you could

00:12:32,259 --> 00:12:38,410
do by using a marking tool as well you

00:12:35,199 --> 00:12:41,110
use it partially but you're basically I

00:12:38,410 --> 00:12:42,879
mean if you turn to looking to instead

00:12:41,110 --> 00:12:45,939
of making my own class job basically

00:12:42,879 --> 00:12:47,620
trading VW q with the code size okay if

00:12:45,939 --> 00:12:50,499
you use marking tool you have less code

00:12:47,620 --> 00:12:52,389
to write you create your cell but then

00:12:50,499 --> 00:12:55,149
there's much more set up appearing again

00:12:52,389 --> 00:12:57,730
okay so you kind of lose in irritability

00:12:55,149 --> 00:12:59,069
Gennari with your own class that means

00:12:57,730 --> 00:13:01,360
that you will have to maintain this

00:12:59,069 --> 00:13:04,449
subclass if one of your interface

00:13:01,360 --> 00:13:07,959
changes for instance but then that you

00:13:04,449 --> 00:13:12,279
learn way more readable another problem

00:13:07,959 --> 00:13:15,790
you might up with the with the Serbs is

00:13:12,279 --> 00:13:17,649
the fact that you have no clue how you

00:13:15,790 --> 00:13:20,069
go to the result because the only thing

00:13:17,649 --> 00:13:22,480
we know when we use tab is that we

00:13:20,069 --> 00:13:24,399
queries equal on the test to check okay

00:13:22,480 --> 00:13:26,350
what you've stayed now and we will

00:13:24,399 --> 00:13:27,939
verify that the state we expected we

00:13:26,350 --> 00:13:30,189
have no idea how that column that has

00:13:27,939 --> 00:13:32,620
got to the conclusion of that particular

00:13:30,189 --> 00:13:34,870
state which is sometimes what you might

00:13:32,620 --> 00:13:38,860
need if that's what you need then we not

00:13:34,870 --> 00:13:40,449
need to turn to real marks that's when

00:13:38,860 --> 00:13:43,240
you need something something which

00:13:40,449 --> 00:13:45,759
starts to be really more clever and but

00:13:43,240 --> 00:13:47,679
is that small for behavior so we want

00:13:45,759 --> 00:13:48,440
something which will confront you every

00:13:47,679 --> 00:13:50,210
time you have

00:13:48,440 --> 00:13:53,480
on behavior that's a bit like the

00:13:50,210 --> 00:13:55,340
Frankenstein creature it basically will

00:13:53,480 --> 00:13:57,650
follow you until the end of the world

00:13:55,340 --> 00:13:59,960
for you to realize that you'll be able

00:13:57,650 --> 00:14:03,800
only in the past right some-something

00:13:59,960 --> 00:14:06,500
want one in your test so marks are used

00:14:03,800 --> 00:14:09,110
for verifying the indirect output not

00:14:06,500 --> 00:14:11,240
input any more like output of the tested

00:14:09,110 --> 00:14:13,700
code ok with the stirrer bleep a sickly

00:14:11,240 --> 00:14:18,260
injecting value inside of code under

00:14:13,700 --> 00:14:20,570
test with marks we are looking at what

00:14:18,260 --> 00:14:23,300
the code under test is pushing out the

00:14:20,570 --> 00:14:26,480
world collaborator objects okay so

00:14:23,300 --> 00:14:29,570
that's different different direction of

00:14:26,480 --> 00:14:31,280
the data that we are checking and so we

00:14:29,570 --> 00:14:33,740
are checking both the accurate but what

00:14:31,280 --> 00:14:38,180
good card on the collaborator objects

00:14:33,740 --> 00:14:39,830
and that's why posture we don't know how

00:14:38,180 --> 00:14:41,720
we go to the confusion white from locks

00:14:39,830 --> 00:14:46,880
we know because we can examine which

00:14:41,720 --> 00:14:49,220
method got hurt exactly know that in the

00:14:46,880 --> 00:14:51,560
literature there are two type of marks

00:14:49,220 --> 00:14:54,080
there's what's called marks that the one

00:14:51,560 --> 00:14:57,380
where you define the expectations of the

00:14:54,080 --> 00:15:00,590
behavior of your code under test before

00:14:57,380 --> 00:15:03,140
you run the test their spies where you

00:15:00,590 --> 00:15:07,040
set the expectations after the execution

00:15:03,140 --> 00:15:09,260
of the testicle okay nowadays these

00:15:07,040 --> 00:15:11,060
distinctions tend to disappear and

00:15:09,260 --> 00:15:13,220
people just thought about marks that's

00:15:11,060 --> 00:15:15,730
kind more for technicality which is not

00:15:13,220 --> 00:15:18,830
necessarily very relevant Noah days and

00:15:15,730 --> 00:15:20,990
because of that that's today clearly for

00:15:18,830 --> 00:15:23,060
me you're checking and before you fall

00:15:20,990 --> 00:15:26,930
asleep without yet another example which

00:15:23,060 --> 00:15:28,880
box I'm going to try to take a bit of

00:15:26,930 --> 00:15:32,330
time because it's more verbose and we're

00:15:28,880 --> 00:15:33,650
using a framework which basically you

00:15:32,330 --> 00:15:35,960
need to understand a little bit before

00:15:33,650 --> 00:15:42,470
starting when I grew up as well a little

00:15:35,960 --> 00:15:43,590
bit ok so this test is about creating a

00:15:42,470 --> 00:15:46,410
new item

00:15:43,590 --> 00:15:48,090
come into intervention in order to do so

00:15:46,410 --> 00:15:49,680
we use well the only back kind of

00:15:48,090 --> 00:15:51,150
attention is that Canadian soldier you

00:15:49,680 --> 00:15:53,460
see I cannot you're around it's normal

00:15:51,150 --> 00:15:54,780
okay so in order to do so you look at

00:15:53,460 --> 00:15:57,750
the one section what happened we try to

00:15:54,780 --> 00:15:59,490
create a task basically and in order to

00:15:57,750 --> 00:16:00,930
do that we have this whole bunch of

00:15:59,490 --> 00:16:03,090
initialization and I'll go through right

00:16:00,930 --> 00:16:07,050
after and after that give me some

00:16:03,090 --> 00:16:10,020
checking like always okay so let's let's

00:16:07,050 --> 00:16:12,180
have a look at the creative edition part

00:16:10,020 --> 00:16:13,500
okay so the point is to create an item

00:16:12,180 --> 00:16:16,230
and in order to do so we need to

00:16:13,500 --> 00:16:18,660
initialize a repository with a bunch of

00:16:16,230 --> 00:16:20,130
objects and we're not gonna pass real

00:16:18,660 --> 00:16:22,610
object as we said we're gonna pass

00:16:20,130 --> 00:16:25,260
knocks because we want to make some more

00:16:22,610 --> 00:16:27,210
in-depth testing than with the steps

00:16:25,260 --> 00:16:30,300
before so here you can see it smoking

00:16:27,210 --> 00:16:33,870
smoking and some some pointer we don't

00:16:30,300 --> 00:16:36,990
care about ok so we mock convention we

00:16:33,870 --> 00:16:38,730
use makito framework so basically let's

00:16:36,990 --> 00:16:42,930
have a look at the storage mug storage

00:16:38,730 --> 00:16:46,380
lock is basically declared here using

00:16:42,930 --> 00:16:49,140
when some mojito functions and right

00:16:46,380 --> 00:16:52,950
after that what we can define is how it

00:16:49,140 --> 00:16:55,560
gonna be what's impute you you what a

00:16:52,950 --> 00:16:57,720
state of it also not so here what this

00:16:55,560 --> 00:17:01,290
line is meaning i'm gonna try to select

00:16:57,720 --> 00:17:03,840
is when you call the default task

00:17:01,290 --> 00:17:06,750
collection under on the nook which is

00:17:03,840 --> 00:17:09,030
mocking the interface when you call it

00:17:06,750 --> 00:17:11,280
the default task collection function

00:17:09,030 --> 00:17:14,850
with this parameter which is void

00:17:11,280 --> 00:17:16,650
basically then it returned this which is

00:17:14,850 --> 00:17:18,930
something you just prefer right before

00:17:16,650 --> 00:17:21,030
so that's you you set up a state here

00:17:18,930 --> 00:17:23,160
you do the same with another function to

00:17:21,030 --> 00:17:25,080
create a 10 when you pass with this

00:17:23,160 --> 00:17:27,240
parameter and this parameter it supposed

00:17:25,080 --> 00:17:28,350
to give Bugsy's which is made before

00:17:27,240 --> 00:17:30,210
like again everything is faked

00:17:28,350 --> 00:17:32,820
everything is marked so you just have a

00:17:30,210 --> 00:17:37,290
lot of control again so entity your test

00:17:32,820 --> 00:17:38,760
is picking with basically ok so you tell

00:17:37,290 --> 00:17:40,030
me like okay that's like a stab you just

00:17:38,760 --> 00:17:41,890
prefer estate ok

00:17:40,030 --> 00:17:43,900
that's very enough so when you arrive

00:17:41,890 --> 00:17:46,750
here and you make the best to create

00:17:43,900 --> 00:17:48,670
task this is going to call basically all

00:17:46,750 --> 00:17:50,260
this method we just smoke and the

00:17:48,670 --> 00:17:52,930
framework the point of the framework is

00:17:50,260 --> 00:17:55,450
to catch it and just replace with what

00:17:52,930 --> 00:17:56,830
you watch you push before so it's going

00:17:55,450 --> 00:17:59,140
to be really predictable as a step and

00:17:56,830 --> 00:18:01,680
everything is going fine okay so now

00:17:59,140 --> 00:18:04,210
what's the difference with the with the

00:18:01,680 --> 00:18:06,430
missus tabular speaking before is if you

00:18:04,210 --> 00:18:08,110
look at the same section what we're

00:18:06,430 --> 00:18:11,050
going to do is we're going to make sure

00:18:08,110 --> 00:18:13,660
in behave as we wanted which means that

00:18:11,050 --> 00:18:15,160
we want this function okay so in this

00:18:13,660 --> 00:18:18,520
Eliza we are speaking about the storage

00:18:15,160 --> 00:18:20,110
so let's keep it consistent okay so we

00:18:18,520 --> 00:18:23,050
make sure that this function has been

00:18:20,110 --> 00:18:26,050
called with this parameter exactly one

00:18:23,050 --> 00:18:28,150
so we making sure the cut pass under the

00:18:26,050 --> 00:18:30,340
test you know like without not only just

00:18:28,150 --> 00:18:32,740
the result how it has being internally

00:18:30,340 --> 00:18:34,870
and same with create item we make sure

00:18:32,740 --> 00:18:36,460
that it's called with this item exactly

00:18:34,870 --> 00:18:39,820
and we've this collection exactly

00:18:36,460 --> 00:18:43,330
exactly one so that's more in depth

00:18:39,820 --> 00:18:52,210
testing twice more complex and study and

00:18:43,330 --> 00:18:55,000
movable okay so what's nice with that is

00:18:52,210 --> 00:18:59,740
that we can completely simulate also

00:18:55,000 --> 00:19:02,830
collaborator with or code under test and

00:18:59,740 --> 00:19:05,080
that's also a way for us to verify

00:19:02,830 --> 00:19:07,720
hidden photo cards okay because then we

00:19:05,080 --> 00:19:09,670
start to see protocols appear in between

00:19:07,720 --> 00:19:11,440
our collaborator objects and so we make

00:19:09,670 --> 00:19:14,170
sure that we make a central number of

00:19:11,440 --> 00:19:15,880
course of that particular method the end

00:19:14,170 --> 00:19:20,170
of scene with that those particular

00:19:15,880 --> 00:19:22,210
parameters so that allows you really get

00:19:20,170 --> 00:19:24,880
the code under test in the baculum okay

00:19:22,210 --> 00:19:27,490
it's completely in a simulated

00:19:24,880 --> 00:19:30,340
environment which pretends to be the

00:19:27,490 --> 00:19:32,350
real thing but as an addressing is

00:19:30,340 --> 00:19:34,360
generally variables to set up right

00:19:32,350 --> 00:19:36,460
because you have to declare every method

00:19:34,360 --> 00:19:39,250
where you expect a call with particular

00:19:36,460 --> 00:19:41,350
value and then you have to do all the

00:19:39,250 --> 00:19:43,220
checks to say okay that's the number of

00:19:41,350 --> 00:19:47,120
time who was expected to be called

00:19:43,220 --> 00:19:48,799
those parameters and so on the other big

00:19:47,120 --> 00:19:50,870
problem there is that it's making

00:19:48,799 --> 00:19:54,669
refactoring more difficult later on

00:19:50,870 --> 00:19:57,289
because by doing that you're cooking

00:19:54,669 --> 00:19:58,789
you'll test the code of your test with

00:19:57,289 --> 00:20:03,440
the accurate implementation of the class

00:19:58,789 --> 00:20:05,240
right ok so you later down the line you

00:20:03,440 --> 00:20:08,120
will have more political you would be

00:20:05,240 --> 00:20:10,190
less able to react to change because

00:20:08,120 --> 00:20:12,140
then you have to adjust all the testers

00:20:10,190 --> 00:20:14,360
because you have an internal behavior

00:20:12,140 --> 00:20:17,299
will change which may be led you to the

00:20:14,360 --> 00:20:20,000
same result ok just don't different

00:20:17,299 --> 00:20:21,559
things and your test we pray ok so

00:20:20,000 --> 00:20:25,520
sometimes we might be in a situation

00:20:21,559 --> 00:20:27,409
where marks or steps are not enough do

00:20:25,520 --> 00:20:29,630
now is sign of that that's when you

00:20:27,409 --> 00:20:32,570
start work not one luck in your test

00:20:29,630 --> 00:20:34,669
back to Mark's three marks for marks ok

00:20:32,570 --> 00:20:37,429
then we start to have something like 14

00:20:34,669 --> 00:20:39,799
lines of course just to prepare all the

00:20:37,429 --> 00:20:41,720
stage for your marks and also checking

00:20:39,799 --> 00:20:44,000
while basically watch well at that point

00:20:41,720 --> 00:20:46,490
is you trying to simulate a subsystem

00:20:44,000 --> 00:20:50,150
complete subsystem and not just a huge

00:20:46,490 --> 00:20:52,039
rabbit or objects so in that case if you

00:20:50,150 --> 00:20:54,909
want to simulate a subsystem you need to

00:20:52,039 --> 00:20:57,230
create a fake one and so that's

00:20:54,909 --> 00:20:58,880
especially interesting when you have big

00:20:57,230 --> 00:21:01,429
external dependencies and you wish to

00:20:58,880 --> 00:21:03,830
kill them all the time for the time of

00:21:01,429 --> 00:21:06,080
the test so you need something almost

00:21:03,830 --> 00:21:09,650
exactly like the original system but not

00:21:06,080 --> 00:21:11,539
quite so that's where we get a real

00:21:09,650 --> 00:21:13,970
doppelganger right that the idiot win

00:21:11,539 --> 00:21:16,370
that clone so you almost can't tell

00:21:13,970 --> 00:21:18,409
about who is whoo which one is real and

00:21:16,370 --> 00:21:22,850
it's basically running at you trying to

00:21:18,409 --> 00:21:24,570
steal your life ok so fakes are use a

00:21:22,850 --> 00:21:26,639
simple implementation of a

00:21:24,570 --> 00:21:28,620
them so for instance in-memory database

00:21:26,639 --> 00:21:30,990
instead of the real dependency which

00:21:28,620 --> 00:21:32,340
could be fine sense of database you plug

00:21:30,990 --> 00:21:34,919
something else which would be equivalent

00:21:32,340 --> 00:21:38,190
feature wise but you lose something else

00:21:34,919 --> 00:21:39,929
which is not relevant for your test so

00:21:38,190 --> 00:21:41,519
you memory database is my opinion out

00:21:39,929 --> 00:21:44,279
good example here in that definition

00:21:41,519 --> 00:21:47,370
because i find that fake that's very

00:21:44,279 --> 00:21:49,200
often related to storage because if

00:21:47,370 --> 00:21:51,899
you're having something which ended up

00:21:49,200 --> 00:21:54,240
on database and you have to write length

00:21:51,899 --> 00:21:56,850
your test just because of the runtime of

00:21:54,240 --> 00:21:58,980
your tests with the database I mean that

00:21:56,850 --> 00:22:00,570
would be way too expensive and you want

00:21:58,980 --> 00:22:04,980
to cut on that and having it in memory

00:22:00,570 --> 00:22:09,200
with just go faster so that's very often

00:22:04,980 --> 00:22:11,429
linked to that storage or to the

00:22:09,200 --> 00:22:14,009
sustained you're running on so that's

00:22:11,429 --> 00:22:15,870
why I'm lips solid which we brought like

00:22:14,009 --> 00:22:18,240
years ago there is a fake backend which

00:22:15,870 --> 00:22:20,909
allows you if you're a user of lip sorry

00:22:18,240 --> 00:22:23,159
to run your tests on a virtual machine

00:22:20,909 --> 00:22:24,960
right leave Sauron will pretend being on

00:22:23,159 --> 00:22:28,379
the machine with some particular devices

00:22:24,960 --> 00:22:33,149
that's how you can simulate simulate

00:22:28,379 --> 00:22:35,070
that so if you're in pain of having me

00:22:33,149 --> 00:22:45,779
to talk so now we are being a less

00:22:35,070 --> 00:22:52,019
example with Frank so enjoy it ok here

00:22:45,779 --> 00:22:54,720
it goes a fake ok so the nice thing is

00:22:52,019 --> 00:22:57,269
is fresh new fake just being done like

00:22:54,720 --> 00:22:59,490
last week or two weeks ago so we will

00:22:57,269 --> 00:23:00,929
it's not a very old test up in Potter's

00:22:59,490 --> 00:23:03,539
we will be able to compress this one

00:23:00,929 --> 00:23:07,830
with the white 00 test right underneath

00:23:03,539 --> 00:23:09,600
ok so the keep looking at the selection

00:23:07,830 --> 00:23:11,730
the test is about approaching all tasks

00:23:09,600 --> 00:23:13,740
so basically have example if you look at

00:23:11,730 --> 00:23:17,100
how we do that we just have a task query

00:23:13,740 --> 00:23:20,879
entity which is basically doing a fine

00:23:17,100 --> 00:23:21,870
dollars to retry them all and we have we

00:23:20,879 --> 00:23:23,940
going to have a look at

00:23:21,870 --> 00:23:26,100
initialization which is done through a

00:23:23,940 --> 00:23:28,410
fake because in order to initialize a

00:23:26,100 --> 00:23:29,880
query first we pass a lot of thing

00:23:28,410 --> 00:23:33,360
before here it was mocha don't you

00:23:29,880 --> 00:23:36,870
remember and here now it's some faked

00:23:33,360 --> 00:23:40,490
entity we flag can see that is a fake

00:23:36,870 --> 00:23:43,710
and create storage is a fake as well so

00:23:40,490 --> 00:23:45,450
let's go to the installation box okay so

00:23:43,710 --> 00:23:48,210
the whole point here is just to see that

00:23:45,450 --> 00:23:50,340
the call is way simpler than before we

00:23:48,210 --> 00:23:53,700
just initialize the fake create some

00:23:50,340 --> 00:23:55,500
data okay here create two top level

00:23:53,700 --> 00:23:57,390
collection and create a task create

00:23:55,500 --> 00:24:00,210
while just read the comment on you can

00:23:57,390 --> 00:24:02,700
understand it's quite easier to read

00:24:00,210 --> 00:24:05,880
there is no all this framework mockito

00:24:02,700 --> 00:24:07,770
more King stuff that you which is way

00:24:05,880 --> 00:24:09,750
more bubbles so it's basically acting

00:24:07,770 --> 00:24:11,940
like the real code the thing is it's not

00:24:09,750 --> 00:24:17,010
like the real and achieve it it's really

00:24:11,940 --> 00:24:20,280
well imitating it okay so if you compare

00:24:17,010 --> 00:24:23,490
with the this is eration with the white

00:24:20,280 --> 00:24:25,710
the one right under it more less same

00:24:23,490 --> 00:24:28,140
kind of idea well you can see that here

00:24:25,710 --> 00:24:30,360
you have way more insulation when you

00:24:28,140 --> 00:24:32,850
initialize the object in a really

00:24:30,360 --> 00:24:35,429
different manner you still set the mock

00:24:32,850 --> 00:24:38,040
which is really verbose as well you said

00:24:35,429 --> 00:24:39,929
each function of the NOC so you your cut

00:24:38,040 --> 00:24:42,720
gets way more simpler contar part of

00:24:39,929 --> 00:24:45,030
that is when you go into the econo

00:24:42,720 --> 00:24:47,330
defect data you can see it's full of a

00:24:45,030 --> 00:24:52,230
function that need to be implemented to

00:24:47,330 --> 00:24:54,540
mimic the real the real oddity like

00:24:52,230 --> 00:24:57,230
economy storage you you're faking which

00:24:54,540 --> 00:24:57,230
is complex

00:24:59,730 --> 00:25:04,500
okay so just give you an idea about that

00:25:02,430 --> 00:25:05,940
because we see that there's a small

00:25:04,500 --> 00:25:08,190
block of code for the initialization

00:25:05,940 --> 00:25:10,290
will fake a big one with the mug I

00:25:08,190 --> 00:25:12,150
started to put more of the test you use

00:25:10,290 --> 00:25:14,580
your faith is that the most recent stuff

00:25:12,150 --> 00:25:17,250
we are very often that stuff which was

00:25:14,580 --> 00:25:20,010
something like 40 to 60 line of codes to

00:25:17,250 --> 00:25:22,400
initialize all the most me today are

00:25:20,010 --> 00:25:24,810
consistent between themselves as well

00:25:22,400 --> 00:25:29,010
compressing something like alpha globin

00:25:24,810 --> 00:25:31,410
of many 10 lines of burden country so

00:25:29,010 --> 00:25:34,530
that main point of the fake if you

00:25:31,410 --> 00:25:37,710
simplify your test code quite a lot and

00:25:34,530 --> 00:25:39,930
that's because also you closer to actual

00:25:37,710 --> 00:25:41,520
punishment code right just initialize

00:25:39,930 --> 00:25:45,720
the state in a fake and then all the

00:25:41,520 --> 00:25:49,170
rest is that at the same usual code you

00:25:45,720 --> 00:25:51,510
would you would have and often than the

00:25:49,170 --> 00:25:53,760
fake is way faster than the original

00:25:51,510 --> 00:25:55,740
especially their storage but that means

00:25:53,760 --> 00:25:57,870
potentially you have a lot of code to

00:25:55,740 --> 00:26:00,650
write and maintain because that means

00:25:57,870 --> 00:26:03,210
you have to create a fake with the

00:26:00,650 --> 00:26:05,280
relevant features so you have to write a

00:26:03,210 --> 00:26:06,780
test code for your fake and then you can

00:26:05,280 --> 00:26:08,910
use that in test right so that's

00:26:06,780 --> 00:26:11,250
potentially quite some curve balls if

00:26:08,910 --> 00:26:14,750
you fake economy the immemorial Andy

00:26:11,250 --> 00:26:20,670
that we that we are writing zanshin that

00:26:14,750 --> 00:26:23,190
2006 and red line of code of course

00:26:20,670 --> 00:26:24,990
that's something you end up doing if the

00:26:23,190 --> 00:26:27,240
technologies dependency your evening has

00:26:24,990 --> 00:26:29,700
no ready-made equivalent which was the

00:26:27,240 --> 00:26:31,470
case for for something like a

00:26:29,700 --> 00:26:34,560
connectivity if you use database just

00:26:31,470 --> 00:26:37,440
swap I don't know my sequel for

00:26:34,560 --> 00:26:41,310
something in memory and so in those

00:26:37,440 --> 00:26:45,840
cases that's much less work ok so we've

00:26:41,310 --> 00:26:48,390
seen several types of tests the birds

00:26:45,840 --> 00:26:50,310
and now you might be wondering ok which

00:26:48,390 --> 00:26:52,650
one do we pick is as what should peak

00:26:50,310 --> 00:26:54,360
memory cases where we've seen that no

00:26:52,650 --> 00:26:59,340
there's no silver bullet because they

00:26:54,360 --> 00:27:02,700
all they all have was an account

00:26:59,340 --> 00:27:05,160
and none of them are idea so instead we

00:27:02,700 --> 00:27:09,000
leave you with kind of a proposed

00:27:05,160 --> 00:27:11,850
approach and that's blood guideline that

00:27:09,000 --> 00:27:14,370
we are now using when we have to do with

00:27:11,850 --> 00:27:18,720
testable and of course that's a proposal

00:27:14,370 --> 00:27:20,600
and you'll manage my very so nor can you

00:27:18,720 --> 00:27:24,150
only that where you should use those

00:27:20,600 --> 00:27:26,010
whenever you can okay that won't earth

00:27:24,150 --> 00:27:28,440
just make sure you're not killing your

00:27:26,010 --> 00:27:30,720
quadrant test by any exceptions

00:27:28,440 --> 00:27:32,550
everywhere like verifying okay that's a

00:27:30,720 --> 00:27:34,380
new pointer I have to do with it but if

00:27:32,550 --> 00:27:36,180
you feel that's natural for your class

00:27:34,380 --> 00:27:38,100
I've no no that's easy to actually deal

00:27:36,180 --> 00:27:41,250
with the new pointer or something just

00:27:38,100 --> 00:27:44,100
go for it and then use them is so

00:27:41,250 --> 00:27:45,810
whenever you can but in practice they

00:27:44,100 --> 00:27:49,380
have a limited use of the whenever you

00:27:45,810 --> 00:27:51,600
can one with that often so otherwise if

00:27:49,380 --> 00:27:53,930
you can't go for adobe released disturb

00:27:51,600 --> 00:27:56,400
that you should prefer in most cases

00:27:53,930 --> 00:27:58,710
ninety percent of the cases that the

00:27:56,400 --> 00:28:01,860
most common testable you should add in

00:27:58,710 --> 00:28:04,290
your in your test card at the end of the

00:28:01,860 --> 00:28:06,660
day that just small L per class that you

00:28:04,290 --> 00:28:08,670
will you how throughout your test right

00:28:06,660 --> 00:28:10,680
so that's reusable code between your

00:28:08,670 --> 00:28:12,450
test that's generally a good investment

00:28:10,680 --> 00:28:16,710
because that's cheap enough and then you

00:28:12,450 --> 00:28:18,900
get quite an impact if really you want

00:28:16,710 --> 00:28:21,210
to spare one then you can use knocking

00:28:18,900 --> 00:28:24,420
tool to create a step as we've seen you

00:28:21,210 --> 00:28:25,650
just do the state creation and you don't

00:28:24,420 --> 00:28:27,390
do the checking at the end oh that's

00:28:25,650 --> 00:28:29,010
basically using mock tool to make a stir

00:28:27,390 --> 00:28:30,930
but then you have to be very careful

00:28:29,010 --> 00:28:33,930
because it becomes very easy to and

00:28:30,930 --> 00:28:36,150
wittingly move away from that just

00:28:33,930 --> 00:28:39,590
served to you that becoming a mark right

00:28:36,150 --> 00:28:42,419
what matters here that's not the actual

00:28:39,590 --> 00:28:44,789
accurate tool that

00:28:42,419 --> 00:28:48,090
the intent of the code you're writing as

00:28:44,789 --> 00:28:51,029
for marks you have to use them to buy so

00:28:48,090 --> 00:28:53,879
they're really great when you're guiding

00:28:51,029 --> 00:28:56,580
the design getting the distance the

00:28:53,879 --> 00:28:59,309
early design phase of some part of your

00:28:56,580 --> 00:29:02,249
code that's what I call last year

00:28:59,309 --> 00:29:04,259
imagine design because you start working

00:29:02,249 --> 00:29:06,210
on one class which needs collaborators

00:29:04,259 --> 00:29:08,190
which don't exist yet right so you

00:29:06,210 --> 00:29:09,720
create the mark and as you makes a much

00:29:08,190 --> 00:29:11,549
more complete to be able to make your

00:29:09,720 --> 00:29:12,989
test you're basically in the muck what

00:29:11,549 --> 00:29:15,269
your writings at the beginning of the

00:29:12,989 --> 00:29:16,739
sticky the specification of the next

00:29:15,269 --> 00:29:19,919
class you will have to implement right

00:29:16,739 --> 00:29:22,200
so that guides you doing that before you

00:29:19,919 --> 00:29:24,330
have the actual class so that's very

00:29:22,200 --> 00:29:25,649
nice for that but beware of the

00:29:24,330 --> 00:29:27,690
variability and cooking to

00:29:25,649 --> 00:29:29,009
implementation provide that's why you

00:29:27,690 --> 00:29:30,389
should do that so that you get to the

00:29:29,009 --> 00:29:34,019
point of that specification and then

00:29:30,389 --> 00:29:36,899
throw them away when you can then you

00:29:34,019 --> 00:29:38,850
just remove them and favorite ups or

00:29:36,899 --> 00:29:42,389
real objects whenever possible as for

00:29:38,850 --> 00:29:44,970
fakes there clearly are an investment so

00:29:42,389 --> 00:29:47,129
that's 32 for the frontier of your

00:29:44,970 --> 00:29:48,989
system no external dependencies because

00:29:47,129 --> 00:29:50,970
I might get very expensive if you don't

00:29:48,989 --> 00:29:55,080
have a ready-made solution as we've just

00:29:50,970 --> 00:29:57,480
discussed before you jump on them only

00:29:55,080 --> 00:29:59,159
when you actually settle those

00:29:57,480 --> 00:30:02,789
dependencies if you change very often

00:29:59,159 --> 00:30:05,100
but that's wasted wasted time and that's

00:30:02,789 --> 00:30:07,129
most useful for integration tests or

00:30:05,100 --> 00:30:10,440
acceptance tests which are from task to

00:30:07,129 --> 00:30:13,350
stack testing where you want to spin

00:30:10,440 --> 00:30:15,450
them up and simplify and that's it for

00:30:13,350 --> 00:30:18,799
us thank you for your attention and I'm

00:30:15,450 --> 00:30:18,799
not sure we have the time for question

00:31:04,110 --> 00:31:10,090
yeah that might be clear when you see on

00:31:07,240 --> 00:31:13,450
easy using side of the code with a

00:31:10,090 --> 00:31:15,610
kinetic data as n2 method at anything

00:31:13,450 --> 00:31:17,410
that is like having the naked that I

00:31:15,610 --> 00:31:20,590
like you can manipulate and so on so

00:31:17,410 --> 00:31:22,300
that just flapper around ashes and stuff

00:31:20,590 --> 00:31:24,010
like that you set your data okay so it

00:31:22,300 --> 00:31:29,680
doesn't really need to be near it from

00:31:24,010 --> 00:31:31,600
anything but then it has to paducah it

00:31:29,680 --> 00:31:34,290
has two methods one which is create

00:31:31,600 --> 00:31:37,000
storage and one which is create monitor

00:31:34,290 --> 00:31:39,610
okay and that's the one where we return

00:31:37,000 --> 00:31:42,100
an object with the right interface where

00:31:39,610 --> 00:31:45,100
it's all mature and everything okay and

00:31:42,100 --> 00:31:46,720
then in that one the implementation talk

00:31:45,100 --> 00:31:52,170
to you the data that you just set in

00:31:46,720 --> 00:31:52,170
anything data here okay so

00:31:55,780 --> 00:32:09,190
thank you so much you have the same

00:32:05,570 --> 00:32:09,190
panel short memory

00:32:15,149 --> 00:32:17,210

YouTube URL: https://www.youtube.com/watch?v=ZYExVu2-X9Q


