Title: Volker Kause - Packing Structs: Optimizing Memory Layout of C++ Data Structures - Akademy 2015
Publication date: 2016-04-02
Playlist: Akademy 2015
Description: 
	When reducing memory usage we first tend to look at allocating less instances of our classes, but once we reach the limits of that investigating and optimizing the memory layout of our data structures becomes interesting.

The way a C++ compiler puts data fields of an object into memory is based on a number of simple rules. However, the consequences of these are not always apparent when reading or writing C++ code, and even seemingly trivial changes such as reordering member variables can have an impact on the size of the entire object.

In this talk we will look at how the member variables of a C++ class are placed in memory and how to introspect the layout of such data structures. We will also look at easy ways on how to avoid wasteful padding, as well as more advanced approaches to achieve an even more compact memory layout.

These kind of optimizations are generally interesting for anyone dealing with classes with many instances, and thus especially for library developers who need to prepare their code for a wide range of (possibly unexpected) use-cases. 

Speaker: Volker Krause
License: Creative Commons Attribution 4.0 International License http://creativecommons.org/licenses/by/4.0/
Akademy 2015: https://akademy.kde.org/2015
KDE: https://www.kde.org/
Donate: https://www.kde.org/donate
Captions: 
	00:00:12,100 --> 00:00:17,480
right so

00:00:14,150 --> 00:00:21,199
it's not just about a random tool it's

00:00:17,480 --> 00:00:26,480
mainly about optimizing the memory layer

00:00:21,199 --> 00:00:28,579
of C++ data structures that's a bit

00:00:26,480 --> 00:00:31,039
different than what we usually do for

00:00:28,579 --> 00:00:33,470
memory optimizations with stuff like

00:00:31,039 --> 00:00:37,210
massive or keep track when we look at

00:00:33,470 --> 00:00:39,320
how many applications do we have find

00:00:37,210 --> 00:00:45,019
fine tea hot spots there and just

00:00:39,320 --> 00:00:46,790
allocate less this is about how the data

00:00:45,019 --> 00:00:51,830
is put into the memory that we have

00:00:46,790 --> 00:00:55,690
allocated and how we can well layout it

00:00:51,830 --> 00:01:00,170
in a more compact way to squeeze out

00:00:55,690 --> 00:01:06,320
even more quite to make the layout world

00:01:00,170 --> 00:01:11,540
more efficient data structures here

00:01:06,320 --> 00:01:15,430
means stuff like stripes or classes and

00:01:11,540 --> 00:01:19,330
the development bits that actually

00:01:15,430 --> 00:01:22,760
require one time memory for instance is

00:01:19,330 --> 00:01:25,490
primarily they are member variables so

00:01:22,760 --> 00:01:29,870
we don't care about normal methods they

00:01:25,490 --> 00:01:34,010
don't cost per month I'll instead and we

00:01:29,870 --> 00:01:36,740
also don't care about static members so

00:01:34,010 --> 00:01:39,680
it's really basically just about the

00:01:36,740 --> 00:01:42,710
members so for for keeping it easy below

00:01:39,680 --> 00:01:47,240
just look at that simplest strikes here

00:01:42,710 --> 00:01:52,550
it sounds so yeah how is the the memory

00:01:47,240 --> 00:01:54,860
layout actually done here a few what it

00:01:52,550 --> 00:01:58,600
slightly simplified but it's it's close

00:01:54,860 --> 00:01:58,600
enough that that it actually covers

00:01:58,659 --> 00:02:04,760
about 90 or so percent of the use cases

00:02:02,900 --> 00:02:08,810
and and certainly most of the things we

00:02:04,760 --> 00:02:11,330
find in in katy so in general when we

00:02:08,810 --> 00:02:11,770
lay out for those the declaration all

00:02:11,330 --> 00:02:14,050
year

00:02:11,770 --> 00:02:17,200
of the member variables so they are just

00:02:14,050 --> 00:02:20,560
put one after another into the memory of

00:02:17,200 --> 00:02:24,400
the of the structure not we need

00:02:20,560 --> 00:02:28,120
surprising the next one is even more

00:02:24,400 --> 00:02:32,100
surprising it's the size a member

00:02:28,120 --> 00:02:36,040
occupies is the size of the data type

00:02:32,100 --> 00:02:39,510
who would have thought but mrs. third

00:02:36,040 --> 00:02:42,850
one it actually gets gets interesting

00:02:39,510 --> 00:02:46,740
many variables have to be aligned based

00:02:42,850 --> 00:02:51,220
on the alignment to their child fires

00:02:46,740 --> 00:02:53,320
for for primitive types like the

00:02:51,220 --> 00:02:56,230
building types that is usually the same

00:02:53,320 --> 00:02:59,350
as the size so an integer needs for

00:02:56,230 --> 00:03:04,090
wider of space and it needs to be four

00:02:59,350 --> 00:03:08,800
byte aligned in in memory on 64-bit

00:03:04,090 --> 00:03:11,470
platforms the the biggest alignment you

00:03:08,800 --> 00:03:16,570
can find is a pointer at eight by

00:03:11,470 --> 00:03:19,420
delight and if you have complex types

00:03:16,570 --> 00:03:23,970
the alignment of them is the maximum of

00:03:19,420 --> 00:03:23,970
any of the alignments of its members

00:03:24,600 --> 00:03:30,790
right in any the only missing bit for

00:03:27,100 --> 00:03:34,750
C++ is if we inherit from from another

00:03:30,790 --> 00:03:37,000
structure or or class the memory layout

00:03:34,750 --> 00:03:38,680
basically just follows each other so

00:03:37,000 --> 00:03:39,080
first I have to base class and then why

00:03:38,680 --> 00:03:41,930
are

00:03:39,080 --> 00:03:44,870
of my my wife class if I have multiple

00:03:41,930 --> 00:03:48,890
based classes they also just call each

00:03:44,870 --> 00:03:52,040
other that is that is fairly

00:03:48,890 --> 00:03:57,110
straightforward and then you have

00:03:52,040 --> 00:04:00,560
virtual inheritance and that is that

00:03:57,110 --> 00:04:05,380
stuff is just crazy you probably

00:04:00,560 --> 00:04:07,640
remember virtual inheritance is used for

00:04:05,380 --> 00:04:09,650
duplicated based classes in a

00:04:07,640 --> 00:04:14,570
complicated mighty inheritance scenario

00:04:09,650 --> 00:04:16,459
so if you inherit from two classes that

00:04:14,570 --> 00:04:20,989
both have the same base class you will

00:04:16,459 --> 00:04:23,270
end up with applique ting the the actual

00:04:20,989 --> 00:04:25,670
data members for those dedicated based

00:04:23,270 --> 00:04:27,770
classes and all of the void add you use

00:04:25,670 --> 00:04:32,660
virtual intelligence to merge that in 20

00:04:27,770 --> 00:04:34,880
classical diamond pattern most people

00:04:32,660 --> 00:04:38,600
don't use this there's only one

00:04:34,880 --> 00:04:43,070
exception and that is solid I don't see

00:04:38,600 --> 00:04:46,180
the guilty people here yeah solid makes

00:04:43,070 --> 00:04:48,590
any use of that so that's why it's still

00:04:46,180 --> 00:04:50,840
relevant for what you need to look at

00:04:48,590 --> 00:04:53,000
this and the problem is this then is

00:04:50,840 --> 00:04:54,950
that only at one time you actually know

00:04:53,000 --> 00:04:57,260
the final memory layout because the

00:04:54,950 --> 00:05:01,820
mayor of the base class depends on who

00:04:57,260 --> 00:05:06,470
actually inherits from it but in most

00:05:01,820 --> 00:05:08,030
cases we can ignore that part and that's

00:05:06,470 --> 00:05:10,150
just not an inheritance like that has

00:05:08,030 --> 00:05:13,669
nothing to do with virtual methods

00:05:10,150 --> 00:05:17,150
virtual methods also have like a minor

00:05:13,669 --> 00:05:20,480
impact on the memory layout in the sense

00:05:17,150 --> 00:05:22,850
that in the base class that first

00:05:20,480 --> 00:05:24,620
declares virtual method and it's

00:05:22,850 --> 00:05:27,410
basically an invisible member when you

00:05:24,620 --> 00:05:29,960
double edit for the double chawed table

00:05:27,410 --> 00:05:33,260
pointer so you can imagine that as a

00:05:29,960 --> 00:05:33,969
void star member it's always the first

00:05:33,260 --> 00:05:37,829
member that you

00:05:33,969 --> 00:05:40,539
and that the compiler just injects them

00:05:37,829 --> 00:05:44,049
but the way that the layout is done for

00:05:40,539 --> 00:05:50,409
this is otherwise the same as as for

00:05:44,049 --> 00:05:53,769
long remembers so lots of tue let's look

00:05:50,409 --> 00:05:55,569
at an actual example and so the other

00:05:53,769 --> 00:05:58,749
simple structure is an email at one bite

00:05:55,569 --> 00:06:01,059
one bite aligned then we have an integer

00:05:58,749 --> 00:06:09,279
member for bite size or by design meant

00:06:01,059 --> 00:06:12,669
and another pool so total sum of member

00:06:09,279 --> 00:06:23,279
sizes would be six bytes but how big is

00:06:12,669 --> 00:06:26,979
that actually in a memory well right

00:06:23,279 --> 00:06:28,449
because due to the alignment we can't

00:06:26,979 --> 00:06:32,229
actually put stuff next to each other

00:06:28,449 --> 00:06:33,729
and so the first will messes up here the

00:06:32,229 --> 00:06:38,379
alignment for the integer so we have

00:06:33,729 --> 00:06:40,569
three bytes just nothing in there unused

00:06:38,379 --> 00:06:42,429
than the earthly integer and if the pool

00:06:40,569 --> 00:06:44,050
and then because the alignment of the

00:06:42,429 --> 00:06:47,169
whole thing needs to be the maximum

00:06:44,050 --> 00:06:51,309
alignment of of the members we have

00:06:47,169 --> 00:06:54,219
another three by three bytes just unused

00:06:51,309 --> 00:06:57,099
and and there you can already see how to

00:06:54,219 --> 00:07:01,179
improve this right if I just we ordered

00:06:57,099 --> 00:07:03,819
to to minimize the depending I can cut

00:07:01,179 --> 00:07:06,969
it down by like four bytes so if I have

00:07:03,819 --> 00:07:09,610
a single instance of this saving four

00:07:06,969 --> 00:07:13,469
bytes in my application is probably not

00:07:09,610 --> 00:07:16,479
going to make a difference if I have

00:07:13,469 --> 00:07:17,889
200,000 instances of this I'm cutting

00:07:16,479 --> 00:07:21,249
down memory consumption by thirty

00:07:17,889 --> 00:07:31,299
percent I mean that's where it gets gets

00:07:21,249 --> 00:07:34,419
interesting right so in order to find

00:07:31,299 --> 00:07:38,439
this it would be useful if we actually

00:07:34,419 --> 00:07:40,569
have tools that that allows to between

00:07:38,439 --> 00:07:43,220
respect data structures in Taylors okay

00:07:40,569 --> 00:07:46,400
this is where you have heading consider

00:07:43,220 --> 00:07:48,020
moving the stuff around and there's two

00:07:46,400 --> 00:07:52,460
kinds of tools that need to know the

00:07:48,020 --> 00:07:55,030
memory layout the compiler debugger so

00:07:52,460 --> 00:07:59,150
looking in their vicinity reform defined

00:07:55,030 --> 00:08:01,420
find the information for us as well and

00:07:59,150 --> 00:08:04,040
if you GCC actually has a warning switch

00:08:01,420 --> 00:08:07,640
that will warn you about every bit of

00:08:04,040 --> 00:08:11,000
padding you have I mean that's a start

00:08:07,640 --> 00:08:14,180
but is extremely noisy and it would also

00:08:11,000 --> 00:08:16,700
give you the morning for this example

00:08:14,180 --> 00:08:19,370
then we actually can't optimize anything

00:08:16,700 --> 00:08:21,530
anymore right I mean we would need to

00:08:19,370 --> 00:08:24,140
change the data structure but just by

00:08:21,530 --> 00:08:28,070
reordering we can't make this any

00:08:24,140 --> 00:08:34,039
smaller so getting warnings for all of

00:08:28,070 --> 00:08:39,520
that the unavoidable cases for like KDE

00:08:34,039 --> 00:08:44,420
scale code bases not really useful um

00:08:39,520 --> 00:08:47,990
then as a tool from set of tools point

00:08:44,420 --> 00:08:49,790
dwarves that uses the debug information

00:08:47,990 --> 00:08:53,900
so for those who need a floaty back

00:08:49,790 --> 00:08:58,550
world and it extracts the memory layout

00:08:53,900 --> 00:09:01,190
out of that that works fairly okay on C

00:08:58,550 --> 00:09:04,370
code but it fails on inheritance it

00:09:01,190 --> 00:09:08,030
fails in static members and only the C++

00:09:04,370 --> 00:09:13,030
specific stuff and that's what actually

00:09:08,030 --> 00:09:13,030
I got me into writing round two yeah

00:09:19,120 --> 00:09:27,500
yes yeah if you try it on C++ code it

00:09:24,410 --> 00:09:29,510
gets completely confused by by static

00:09:27,500 --> 00:09:33,620
members who have absolutely no impact on

00:09:29,510 --> 00:09:39,310
the memory layout so it's a start but

00:09:33,620 --> 00:09:43,400
it's for our use case not really usable

00:09:39,310 --> 00:09:45,110
that's why as part of other tools in the

00:09:43,400 --> 00:09:48,800
binary area I was already working on

00:09:45,110 --> 00:09:51,800
anyway I implemented it to a cold of act

00:09:48,800 --> 00:09:54,410
check out of the earth dissector git

00:09:51,800 --> 00:09:59,650
repository and KDE and that actually

00:09:54,410 --> 00:10:02,180
also supports most of the C++ scenarios

00:09:59,650 --> 00:10:06,470
the only thing I can't handle yet is

00:10:02,180 --> 00:10:09,500
solid so virtual inheritance there gives

00:10:06,470 --> 00:10:11,960
arbitrarily more results it's it's

00:10:09,500 --> 00:10:13,880
doable but it's a lot of work because

00:10:11,960 --> 00:10:16,670
you basically need to recreate the

00:10:13,880 --> 00:10:18,380
complete memory layout is the four

00:10:16,670 --> 00:10:20,210
different kind of virtual tables and

00:10:18,380 --> 00:10:23,210
virtual table tables involved in

00:10:20,210 --> 00:10:25,160
constructing it and then execute some

00:10:23,210 --> 00:10:29,150
more expressions of their fight divided

00:10:25,160 --> 00:10:32,000
offsets but for the other cases it's

00:10:29,150 --> 00:10:35,450
they're actually producing useful

00:10:32,000 --> 00:10:37,880
results and a couple of months ago nor

00:10:35,450 --> 00:10:40,850
got his hands on it so if you want it

00:10:37,880 --> 00:10:42,830
now under katie code base especially in

00:10:40,850 --> 00:10:46,420
pin and some of the friend knows you

00:10:42,830 --> 00:10:49,460
won't find that many problems anymore

00:10:46,420 --> 00:10:54,170
but in some other areas he might not

00:10:49,460 --> 00:10:59,420
have applied a bit rather then kind of

00:10:54,170 --> 00:11:02,840
also related to the tools you can verify

00:10:59,420 --> 00:11:04,940
this stuff with static research dan's

00:11:02,840 --> 00:11:06,770
useful if you did some careful

00:11:04,940 --> 00:11:09,350
optimization of the memory structure and

00:11:06,770 --> 00:11:12,080
then the next guy comes in and just acts

00:11:09,350 --> 00:11:12,819
as a rule into it and makes it go up by

00:11:12,080 --> 00:11:15,869
foot

00:11:12,819 --> 00:11:17,919
right so you can basically unit test

00:11:15,869 --> 00:11:21,339
certain assumptions about your data

00:11:17,919 --> 00:11:23,139
structure and get a compile error when

00:11:21,339 --> 00:11:24,999
somebody accidentally makes a larger and

00:11:23,139 --> 00:11:27,699
then you can decide okay this is

00:11:24,999 --> 00:11:35,470
unavoidable or ok let's try to squeeze

00:11:27,699 --> 00:11:39,220
it in into something more compact so

00:11:35,470 --> 00:11:42,279
yeah what you can do to to avoid this

00:11:39,220 --> 00:11:46,779
unnecessary padding is basically with

00:11:42,279 --> 00:11:50,949
all the remember variables the the

00:11:46,779 --> 00:11:52,869
general rule of thumb there is salt and

00:11:50,949 --> 00:11:56,529
by alignment sometimes you find the rule

00:11:52,869 --> 00:12:00,809
salt and by size which is not actually

00:11:56,529 --> 00:12:00,809
correct but in practices close enough

00:12:01,679 --> 00:12:06,669
but there's a few supplies is to keep in

00:12:04,149 --> 00:12:12,279
mind especially when when working with

00:12:06,669 --> 00:12:13,869
C++ times looking at the alignment of

00:12:12,279 --> 00:12:16,419
the base class and there is one common

00:12:13,869 --> 00:12:21,609
scenario that we have in acute related

00:12:16,419 --> 00:12:23,649
field that is private classes of copy

00:12:21,609 --> 00:12:26,619
and white classes that inherit q share

00:12:23,649 --> 00:12:31,389
data and huge share data as a 4 by

00:12:26,619 --> 00:12:33,189
divine wind why you most likely will

00:12:31,389 --> 00:12:35,429
have member variables with an 85

00:12:33,189 --> 00:12:38,409
alignment like a hue string or pointer

00:12:35,429 --> 00:12:40,209
which if you follow the the basic rule

00:12:38,409 --> 00:12:42,220
of salt and by alignment you have a 4

00:12:40,209 --> 00:12:44,949
wide gap in in the beginning that you

00:12:42,220 --> 00:12:47,949
are not using from the base class even

00:12:44,949 --> 00:12:48,910
heute at cases of that q daytime still

00:12:47,949 --> 00:12:53,170
has it

00:12:48,910 --> 00:12:55,210
I was allowed to fix that so if you have

00:12:53,170 --> 00:12:56,440
a few billions at the end you can

00:12:55,210 --> 00:12:58,330
basically move down in the beginning

00:12:56,440 --> 00:13:03,400
fill that gap and save big bites in

00:12:58,330 --> 00:13:05,560
total when you do these kinds of

00:13:03,400 --> 00:13:07,180
optimizations keep in mind that the

00:13:05,560 --> 00:13:09,610
number 11 is actually different on

00:13:07,180 --> 00:13:10,720
32-bit and 64-bit because the pointers

00:13:09,610 --> 00:13:14,260
have different sizes and different

00:13:10,720 --> 00:13:16,360
alignments and you of course don't want

00:13:14,260 --> 00:13:19,180
to optimize just for one case and then

00:13:16,360 --> 00:13:22,150
make the other one was so usually if you

00:13:19,180 --> 00:13:27,910
optimize for 64-bit 32-bit movie also

00:13:22,150 --> 00:13:30,400
fine the other way around the case and

00:13:27,910 --> 00:13:34,080
then something that make fixing those

00:13:30,400 --> 00:13:36,310
issues in ok I hope somewhat annoying

00:13:34,080 --> 00:13:39,730
there's lots of member variables that

00:13:36,310 --> 00:13:41,230
are compile-time conditioner and if you

00:13:39,730 --> 00:13:44,020
don't want to totally mess up the code

00:13:41,230 --> 00:13:45,640
or intoxicate it like finding a way to

00:13:44,020 --> 00:13:48,790
reorder it so that it works and all

00:13:45,640 --> 00:13:52,540
possible combinations can be a little

00:13:48,790 --> 00:13:53,650
tricky but then in general you you get

00:13:52,540 --> 00:13:56,980
to the point where it's a trade-off

00:13:53,650 --> 00:14:00,150
between is it's really worth optimizing

00:13:56,980 --> 00:14:04,860
the four bites out of this class

00:14:00,150 --> 00:14:04,860
compared to the negative energy right

00:14:04,920 --> 00:14:13,930
and then we have the really fun stuff

00:14:10,110 --> 00:14:15,130
one class that was showing up where we

00:14:13,930 --> 00:14:19,330
frequently and that is actually very

00:14:15,130 --> 00:14:22,810
high volume is Q hash note that slightly

00:14:19,330 --> 00:14:24,280
simplified has the this layout so you

00:14:22,810 --> 00:14:26,350
have an integer first of the hash value

00:14:24,280 --> 00:14:29,040
down you have to queue and then you have

00:14:26,350 --> 00:14:32,760
the value key and value depend only on

00:14:29,040 --> 00:14:38,740
the template arguments so if you have a

00:14:32,760 --> 00:14:41,980
few hash of int and Q string the hash

00:14:38,740 --> 00:14:48,580
knowledge is sixteen bike has no Pappy

00:14:41,980 --> 00:14:52,120
if you have a cue hash of Q string in so

00:14:48,580 --> 00:14:53,160
just switch key and value you have 24

00:14:52,120 --> 00:14:56,250
bytes and for

00:14:53,160 --> 00:15:02,430
most integral which for such a class is

00:14:56,250 --> 00:15:04,290
actually unfortunate there's ways of

00:15:02,430 --> 00:15:06,569
fixing that with a bit of template

00:15:04,290 --> 00:15:08,610
metaprogramming and based on the

00:15:06,569 --> 00:15:10,769
alignment of the various types have two

00:15:08,610 --> 00:15:15,209
different implementations where you swap

00:15:10,769 --> 00:15:18,060
the members and then maybe with select

00:15:15,209 --> 00:15:22,319
the right one that's unfortunately not

00:15:18,060 --> 00:15:24,779
binary compatible so we can fix 785 but

00:15:22,319 --> 00:15:27,389
if you have such kind of high volume

00:15:24,779 --> 00:15:29,790
template classes there is actually

00:15:27,389 --> 00:15:37,259
raised to a compile-time decide on on

00:15:29,790 --> 00:15:40,800
different memory nails so yes this done

00:15:37,259 --> 00:15:46,379
approach we can reduce the waste false

00:15:40,800 --> 00:15:47,850
by by penning be nude less memory is a

00:15:46,379 --> 00:15:50,939
nice side effect we have better

00:15:47,850 --> 00:15:54,329
utilization of this if you Cassius so in

00:15:50,939 --> 00:15:59,550
general that also helps with his overall

00:15:54,329 --> 00:16:02,639
performance unless you have like totally

00:15:59,550 --> 00:16:04,980
tricky cases like the hashcode case the

00:16:02,639 --> 00:16:06,870
impact on code maintainability is

00:16:04,980 --> 00:16:10,459
actually fairly low but it's just

00:16:06,870 --> 00:16:15,420
walking around if you remember variables

00:16:10,459 --> 00:16:20,490
but yeah it's also and is that we need

00:16:15,420 --> 00:16:22,220
everything we can do is there when is

00:16:20,490 --> 00:16:27,600
there more we can squeeze out of this

00:16:22,220 --> 00:16:30,420
and of course days so what we looked at

00:16:27,600 --> 00:16:35,250
so far is basically just the bite level

00:16:30,420 --> 00:16:39,500
layout that the compiler is but if you

00:16:35,250 --> 00:16:42,000
take a step back and look at the

00:16:39,500 --> 00:16:47,339
information you actually want to store

00:16:42,000 --> 00:16:51,389
there and ignore the actual in memory

00:16:47,339 --> 00:16:53,250
layout for a moment that shows us that

00:16:51,389 --> 00:16:56,809
it's still a whole lot we can get out of

00:16:53,250 --> 00:17:00,120
it we need extreme cases of wood that

00:16:56,809 --> 00:17:02,790
suppose one bit of information but it

00:17:00,120 --> 00:17:03,790
needs 8-bit of storage I mean you can

00:17:02,790 --> 00:17:08,890
hardly make that less

00:17:03,790 --> 00:17:10,750
that's efficient enums is often another

00:17:08,890 --> 00:17:13,690
such example right if you have eight

00:17:10,750 --> 00:17:19,660
different in our values by default that

00:17:13,690 --> 00:17:21,520
looked occupy 32 bits if you don't use

00:17:19,660 --> 00:17:25,720
them in a flag configuration actually

00:17:21,520 --> 00:17:28,060
three bits would be enough even in

00:17:25,720 --> 00:17:30,370
pointers we we have that I can take a

00:17:28,060 --> 00:17:34,240
cube checkpoint on a 64-bit system that

00:17:30,370 --> 00:17:36,940
is 85 aligned which means the three

00:17:34,240 --> 00:17:40,720
lowest its are always zero so

00:17:36,940 --> 00:17:42,430
conceptually there's only 61 bit that is

00:17:40,720 --> 00:17:44,830
actually valuable information of the

00:17:42,430 --> 00:17:46,530
pointer and practice is actually less

00:17:44,830 --> 00:17:53,080
because you don't have that much

00:17:46,530 --> 00:17:54,760
addressable memory but so this looking

00:17:53,080 --> 00:17:57,970
at it like from a theoretical point of

00:17:54,760 --> 00:18:03,810
view there's obviously more space we can

00:17:57,970 --> 00:18:07,540
fit stuff into but for that we need to

00:18:03,810 --> 00:18:13,420
kind of look at a like sub byte or

00:18:07,540 --> 00:18:15,010
bitwise layout of ophtho memory gets

00:18:13,420 --> 00:18:17,650
some support for this in the language

00:18:15,010 --> 00:18:21,610
where's Witt fields where you can

00:18:17,650 --> 00:18:26,160
actually specify after the the variable

00:18:21,610 --> 00:18:28,930
name how many bits should use for this

00:18:26,160 --> 00:18:32,230
so if you know that the integer only

00:18:28,930 --> 00:18:34,000
needs smaller amount of bits because you

00:18:32,230 --> 00:18:40,390
don't have back large numbers you can

00:18:34,000 --> 00:18:42,610
squeeze in some other stuff again if you

00:18:40,390 --> 00:18:44,320
follow huge that I recently have been a

00:18:42,610 --> 00:18:49,510
bunch of changes to actually get rid of

00:18:44,320 --> 00:18:52,990
this as mark found out that GCC

00:18:49,510 --> 00:18:56,620
generates invalid with constructors for

00:18:52,990 --> 00:19:01,360
bit fields another suppose a compiler

00:18:56,620 --> 00:19:07,830
bug but so it's also worth looking at

00:19:01,360 --> 00:19:11,460
and alternatives to that in case it's

00:19:07,830 --> 00:19:14,850
causing problems and the obvious

00:19:11,460 --> 00:19:18,179
alternative is just manually do some

00:19:14,850 --> 00:19:21,419
shifting and masking to find out the bin

00:19:18,179 --> 00:19:25,730
you want that's usually hard to maintain

00:19:21,419 --> 00:19:28,019
and annoying to do but it's it's the

00:19:25,730 --> 00:19:30,320
that's kind of the ultimate option is

00:19:28,019 --> 00:19:35,039
that you can basically arrange it in

00:19:30,320 --> 00:19:38,309
whatever way you want and then we also

00:19:35,039 --> 00:19:41,700
have some higher level classes if you

00:19:38,309 --> 00:19:43,679
think about the bull example I mean one

00:19:41,700 --> 00:19:48,679
bull is already bad but you could have

00:19:43,679 --> 00:19:48,679
an array of words or cue list of words

00:19:49,610 --> 00:19:59,130
then per entry you waste eighty percent

00:19:55,289 --> 00:20:01,529
of your your storage so there is a few

00:19:59,130 --> 00:20:04,380
special case classes in acute like you

00:20:01,529 --> 00:20:08,309
bit array that actually did a bit

00:20:04,380 --> 00:20:10,769
reading and store them in in actual one

00:20:08,309 --> 00:20:14,399
bit entries and standard vector of pool

00:20:10,769 --> 00:20:20,309
is also special case to store this in a

00:20:14,399 --> 00:20:22,500
in a much more compact way yeah for you

00:20:20,309 --> 00:20:25,860
know to the c++ let me have the ability

00:20:22,500 --> 00:20:34,100
to actually change the storage type so

00:20:25,860 --> 00:20:37,980
if you know what you only have yeah 100

00:20:34,100 --> 00:20:39,750
or 250 five different values in most and

00:20:37,980 --> 00:20:42,690
you never want to have more you can

00:20:39,750 --> 00:20:45,330
actually say you know specify that this

00:20:42,690 --> 00:20:47,549
should go into one bite and of course

00:20:45,330 --> 00:20:52,679
you can combine that is as bit fields to

00:20:47,549 --> 00:20:54,919
to make it even more compact unlikely

00:20:52,679 --> 00:21:00,080
the ordering of the memory of us this

00:20:54,919 --> 00:21:04,460
Rena's some cpu crossed usually it's

00:21:00,080 --> 00:21:06,919
just a few bit operation so it's not not

00:21:04,460 --> 00:21:08,350
that big of a deal compared to the

00:21:06,919 --> 00:21:11,450
performance you get is that a

00:21:08,350 --> 00:21:15,049
utilization but then you get to the

00:21:11,450 --> 00:21:17,029
point where it's actually something

00:21:15,049 --> 00:21:20,359
where it might make sense to actually

00:21:17,029 --> 00:21:25,570
measure the impact and it certainly has

00:21:20,359 --> 00:21:30,129
an impact on kokanee technology and

00:21:25,570 --> 00:21:34,779
readability and there's another problem

00:21:30,129 --> 00:21:37,399
pointers and references can only address

00:21:34,779 --> 00:21:39,950
one bite or the one bite is the smallest

00:21:37,399 --> 00:21:42,200
unit you can address as a pointer if you

00:21:39,950 --> 00:21:44,419
now start to for two different variables

00:21:42,200 --> 00:21:47,149
basically into the same bite which you

00:21:44,419 --> 00:21:49,330
can do the speech fields you can't take

00:21:47,149 --> 00:21:52,340
the address of this anymore or you can't

00:21:49,330 --> 00:21:55,159
but you can't pass this point I into any

00:21:52,340 --> 00:21:58,279
function that expects a good point so

00:21:55,159 --> 00:22:03,919
there you always end up copying a bit a

00:21:58,279 --> 00:22:06,320
bit around the fact check utility can

00:22:03,919 --> 00:22:08,239
actually for sometimes I think for

00:22:06,320 --> 00:22:10,700
bullion's and foreigners already measure

00:22:08,239 --> 00:22:14,570
how many bits you actually need and it

00:22:10,700 --> 00:22:17,299
can show you the how many bits of your

00:22:14,570 --> 00:22:20,149
data structure are actually used and so

00:22:17,299 --> 00:22:24,279
this helps me is finding ways where you

00:22:20,149 --> 00:22:24,279
can optimize the zone of this level and

00:22:24,879 --> 00:22:31,389
then there is a few more i would say

00:22:29,149 --> 00:22:37,119
dirty tricks that you shouldn't only

00:22:31,389 --> 00:22:40,759
should only use in in case of emergency

00:22:37,119 --> 00:22:44,090
first of all you can disable the the

00:22:40,759 --> 00:22:48,289
alignment with that works on some

00:22:44,090 --> 00:22:51,289
platforms like x86 it has a certain

00:22:48,289 --> 00:22:54,000
performance impact and then basically

00:22:51,289 --> 00:22:55,470
the compiler doesn't care anymore about

00:22:54,000 --> 00:22:59,850
the alignment and everything is nicely

00:22:55,470 --> 00:23:01,620
packed directly together this gets you

00:22:59,850 --> 00:23:06,560
really interesting one time behavior on

00:23:01,620 --> 00:23:12,750
arm because there is actually crashes

00:23:06,560 --> 00:23:14,190
what triggers a CPU error I found this

00:23:12,750 --> 00:23:20,880
in volatile place in the fictional

00:23:14,190 --> 00:23:26,720
engine but yeah that is kind of the last

00:23:20,880 --> 00:23:30,570
result slightly less dead but also

00:23:26,720 --> 00:23:32,670
somewhat Chaney is actually using this

00:23:30,570 --> 00:23:35,670
point I alignment gap so as I mentioned

00:23:32,670 --> 00:23:37,260
earlier if you have an 8-byte allowing

00:23:35,670 --> 00:23:40,410
pointer you have three bits that are

00:23:37,260 --> 00:23:44,240
actually unused that I always do so

00:23:40,410 --> 00:23:46,530
there's a bit of masking them and always

00:23:44,240 --> 00:23:48,270
resetting them 20 before you dereference

00:23:46,530 --> 00:23:53,370
the pointer you can actually score some

00:23:48,270 --> 00:24:03,750
extra bit of information in there well

00:23:53,370 --> 00:24:05,580
if you're always reset it to zero so

00:24:03,750 --> 00:24:08,400
yeah you need to be really careful with

00:24:05,580 --> 00:24:11,130
using this kind of stuff and at least

00:24:08,400 --> 00:24:14,820
luckily for that cute has some

00:24:11,130 --> 00:24:17,940
non-public classes in the qm l engine to

00:24:14,820 --> 00:24:20,130
flat pointer if you buy pointer that do

00:24:17,940 --> 00:24:21,780
that or maybe as a template class so you

00:24:20,130 --> 00:24:25,260
probably want to steal that rather than

00:24:21,780 --> 00:24:29,100
try to internet it yourself but this is

00:24:25,260 --> 00:24:32,460
also something i would only use if

00:24:29,100 --> 00:24:35,460
absolutely necessary and you have some

00:24:32,460 --> 00:24:37,440
like super high volume classes where you

00:24:35,460 --> 00:24:39,030
would have like eight bad extra costs

00:24:37,440 --> 00:24:41,450
from one bit that you need to store

00:24:39,030 --> 00:24:41,450
somewhere

00:24:47,860 --> 00:24:56,330
yeah yeah I mean this is used in a few

00:24:51,320 --> 00:24:59,870
places in hand cute it's it's tempting

00:24:56,330 --> 00:25:04,580
right if 8-byte overhead for one bit you

00:24:59,870 --> 00:25:09,200
need to squeeze in somewhere but yeah it

00:25:04,580 --> 00:25:11,509
has interesting side effects especially

00:25:09,200 --> 00:25:18,129
if you forget to unmask given some

00:25:11,509 --> 00:25:22,789
someone's right and then this all has

00:25:18,129 --> 00:25:24,980
has a downside as well the memory layout

00:25:22,789 --> 00:25:27,740
is essentially what defines the

00:25:24,980 --> 00:25:30,019
application binary interface so as soon

00:25:27,740 --> 00:25:33,259
as you change anything in there your

00:25:30,019 --> 00:25:35,059
binary incompatible I mean we

00:25:33,259 --> 00:25:36,769
unfortunate situation that most of the

00:25:35,059 --> 00:25:41,149
classes actually having a significant

00:25:36,769 --> 00:25:44,600
role of amount of member variables are

00:25:41,149 --> 00:25:47,809
actually private classes so that we can

00:25:44,600 --> 00:25:50,590
be authorized we see fit and in

00:25:47,809 --> 00:25:53,299
applications it's of course also fine

00:25:50,590 --> 00:25:55,399
but the National example that is

00:25:53,299 --> 00:25:58,730
something you can't actually fix before

00:25:55,399 --> 00:26:00,860
moving to q6 and others I mean that is

00:25:58,730 --> 00:26:02,539
one of the really high volume classes

00:26:00,860 --> 00:26:07,460
where this would actually make a

00:26:02,539 --> 00:26:13,970
difference see if you crossed something

00:26:07,460 --> 00:26:16,000
I already mentioned there's also

00:26:13,970 --> 00:26:20,419
downside to be the improved cash

00:26:16,000 --> 00:26:24,500
utilization utilization so if you have a

00:26:20,419 --> 00:26:28,850
data swatch other is simultaneously used

00:26:24,500 --> 00:26:29,899
for multiple threats and disperse are

00:26:28,850 --> 00:26:32,529
actually running on difference if you

00:26:29,899 --> 00:26:35,419
cross you'll end up there's a cash

00:26:32,529 --> 00:26:36,130
reload ping pong effect that actually

00:26:35,419 --> 00:26:38,470
makes it a lot

00:26:36,130 --> 00:26:40,360
lower so in those cases it can actually

00:26:38,470 --> 00:26:42,780
be beneficial to move things further

00:26:40,360 --> 00:26:45,700
apart so they have different cache lines

00:26:42,780 --> 00:26:50,680
mark has interesting benchmarks to to

00:26:45,700 --> 00:26:53,680
show this that is for most of the stuff

00:26:50,680 --> 00:26:56,380
we see in KDE not the case in this kind

00:26:53,680 --> 00:26:58,840
of heavy much is reading is relatively

00:26:56,380 --> 00:27:01,060
rare but if you work on that kind of

00:26:58,840 --> 00:27:04,590
stuff I mean that is a whole different

00:27:01,060 --> 00:27:08,980
area of problems you might run into you

00:27:04,590 --> 00:27:11,920
where has actually yeah totally other

00:27:08,980 --> 00:27:17,110
effects than that in the single threaded

00:27:11,920 --> 00:27:21,250
case yeah portable tility portability we

00:27:17,110 --> 00:27:24,810
already mentioned on arm stuff is far

00:27:21,250 --> 00:27:28,810
more fragile veneering when you misalign

00:27:24,810 --> 00:27:30,700
memory the more you start was these 30

00:27:28,810 --> 00:27:37,900
next to how are you crowd gets to

00:27:30,700 --> 00:27:39,340
maintain if you reuse the storage size

00:27:37,900 --> 00:27:42,970
of me numb for example you run into

00:27:39,340 --> 00:27:45,010
problems with future extensions might

00:27:42,970 --> 00:27:46,720
say we need 1x or flag but there's no

00:27:45,010 --> 00:27:51,250
space left with because you really

00:27:46,720 --> 00:27:53,890
minimize that that's all all things to

00:27:51,250 --> 00:27:59,860
consider before really going down to

00:27:53,890 --> 00:28:05,140
this down this road so again in

00:27:59,860 --> 00:28:07,650
conclusion it's very easy to avoid the D

00:28:05,140 --> 00:28:10,960
unnecessary heading and just be

00:28:07,650 --> 00:28:15,760
low-hanging fruit on memory ways that

00:28:10,960 --> 00:28:17,470
you might find in a few places once you

00:28:15,760 --> 00:28:21,070
get into a high-volume classes where you

00:28:17,470 --> 00:28:22,750
really have many many instances of it

00:28:21,070 --> 00:28:25,600
starts really interesting to think about

00:28:22,750 --> 00:28:27,550
what is going in there not so much on

00:28:25,600 --> 00:28:29,410
the implementation and technical point

00:28:27,550 --> 00:28:32,020
of view but from there like information

00:28:29,410 --> 00:28:34,510
theory point of view like what is the

00:28:32,020 --> 00:28:38,440
actual content I I need to store here

00:28:34,510 --> 00:28:40,150
and how many bits to a conception you

00:28:38,440 --> 00:28:44,269
need for that and then based on that

00:28:40,150 --> 00:28:49,070
look for a memory layout that price too

00:28:44,269 --> 00:28:52,580
is it and of course none of this is a

00:28:49,070 --> 00:28:55,459
replacement for actual memory profiling

00:28:52,580 --> 00:28:57,919
and what trying to avoid to run a clean

00:28:55,459 --> 00:28:59,679
start in the first place and that's

00:28:57,919 --> 00:29:02,959
always going to save you a little more

00:28:59,679 --> 00:29:05,209
so this is only by the step after you've

00:29:02,959 --> 00:29:08,570
done that and there's really some

00:29:05,209 --> 00:29:13,190
classes where you you need a huge amount

00:29:08,570 --> 00:29:20,679
of and then yeah look on on how this can

00:29:13,190 --> 00:29:20,679
be further confessed yeah that's it

00:29:26,469 --> 00:29:36,950
questions so it's the energy industry

00:29:33,529 --> 00:29:45,230
news you

00:29:36,950 --> 00:29:48,840
I think the the biggest ones we had

00:29:45,230 --> 00:29:51,210
thirty to fifty percent in really small

00:29:48,840 --> 00:29:53,820
I mean the example I had a certain

00:29:51,210 --> 00:29:54,960
percent like that actually your national

00:29:53,820 --> 00:29:57,630
would be one of the cases that you

00:29:54,960 --> 00:29:59,549
actually say thirty percent i think that

00:29:57,630 --> 00:30:02,580
is that is probably as extreme as it

00:29:59,549 --> 00:30:08,700
gets you can never save more than fifty

00:30:02,580 --> 00:30:13,039
percent well yeah unless it's like well

00:30:08,700 --> 00:30:19,350
you can probably construct them can you

00:30:13,039 --> 00:30:23,460
actually yeah if you saw in your

00:30:19,350 --> 00:30:25,620
brilliance in a 64-bit integer in a

00:30:23,460 --> 00:30:36,510
1-bit fear one of them ever show the

00:30:25,620 --> 00:30:39,480
kindness yeah I'm all right anyone in

00:30:36,510 --> 00:30:42,809
like actual real world code in most of

00:30:39,480 --> 00:30:45,990
the high volume classes apart from hash

00:30:42,809 --> 00:30:49,080
note I think it's usually you get a like

00:30:45,990 --> 00:30:52,679
a bite of a mighty hundred pipe

00:30:49,080 --> 00:31:02,210
structure so it's it's not that much so

00:30:52,679 --> 00:31:02,210
it's a few percent one still focused

00:31:06,340 --> 00:31:26,390
it's just very nice to cases where it's

00:31:24,590 --> 00:31:27,800
worth looking at that I don't have an

00:31:26,390 --> 00:31:30,080
application that you know what you know

00:31:27,800 --> 00:31:33,470
high-volume classes are or you are

00:31:30,080 --> 00:31:35,810
working on a framework where you have

00:31:33,470 --> 00:31:40,550
classes that we use them possibly might

00:31:35,810 --> 00:31:42,620
be using in a fairly high ammonia for

00:31:40,550 --> 00:31:46,150
most of the classes you have so little

00:31:42,620 --> 00:31:49,160
instances that like especially knowing

00:31:46,150 --> 00:31:51,710
the more tricky optimization is not

00:31:49,160 --> 00:31:53,570
worth it from from the ethyl point of

00:31:51,710 --> 00:31:56,230
view from the maintainability point of

00:31:53,570 --> 00:31:59,480
view and so on but just be ordering

00:31:56,230 --> 00:32:02,330
members I I think that for me it became

00:31:59,480 --> 00:32:04,580
kind of poverty habit when I just write

00:32:02,330 --> 00:32:07,340
a class I pay attention to put it in the

00:32:04,580 --> 00:32:11,060
right corners you at least avoid the

00:32:07,340 --> 00:32:15,850
unnecessary waste blowing and the rest

00:32:11,060 --> 00:32:15,850
is really for for some high volume cases

00:32:19,499 --> 00:32:22,710
thank you

00:32:31,299 --> 00:32:33,360

YouTube URL: https://www.youtube.com/watch?v=r4jc8phO3CI


