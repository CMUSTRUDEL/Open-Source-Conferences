Title: Akademy 2020 - Ivan Cukic - C++17 and 20 Goodies
Publication date: 2020-11-24
Playlist: Akademy 2020
Description: 
	C++ is evolving rapidly in the past few years and it is hard to keep track of all the new features we are getting.

In this talk, we are going to cover the new features that C++17 and 20 bring and how they can be combined with each other.
Captions: 
	00:00:01,130 --> 00:00:08,600
[Music]

00:00:10,320 --> 00:00:13,519
so

00:00:10,719 --> 00:00:14,160
hello everybody uh this is going to

00:00:13,519 --> 00:00:16,080
be about

00:00:14,160 --> 00:00:17,359
suppose for 17 and simplest plus 20

00:00:16,080 --> 00:00:20,880
goodies

00:00:17,359 --> 00:00:23,920
uh now for yes it's even

00:00:20,880 --> 00:00:26,480
hi jonathan so

00:00:23,920 --> 00:00:28,000
for people who have been to academies

00:00:26,480 --> 00:00:30,320
before

00:00:28,000 --> 00:00:31,679
or who have met me before i'm going to

00:00:30,320 --> 00:00:35,600
skip about me because

00:00:31,679 --> 00:00:37,920
there isn't really that much time uh

00:00:35,600 --> 00:00:39,760
usual disclaimer make your code readable

00:00:37,920 --> 00:00:40,320
pretend the next person who looks at

00:00:39,760 --> 00:00:42,879
your code

00:00:40,320 --> 00:00:44,079
is a psychopath and they know where you

00:00:42,879 --> 00:00:49,039
live

00:00:44,079 --> 00:00:52,320
very very important note i'm going to

00:00:49,039 --> 00:00:53,440
uh i'm not going to explain what the

00:00:52,320 --> 00:00:55,920
quote means

00:00:53,440 --> 00:00:56,879
you should all assign the meaning by

00:00:55,920 --> 00:00:59,760
yourselves

00:00:56,879 --> 00:01:00,719
now the question is when am i giving the

00:00:59,760 --> 00:01:04,879
same talk again

00:01:00,719 --> 00:01:08,159
because in academy 2017

00:01:04,879 --> 00:01:10,560
i already had a talk named asia 17 and

00:01:08,159 --> 00:01:10,560
20.

00:01:10,720 --> 00:01:16,720
that stock was a little bit focused on

00:01:14,479 --> 00:01:18,400
uh let's say bigger features of sequels

00:01:16,720 --> 00:01:20,720
plus 20

00:01:18,400 --> 00:01:21,600
and some smaller features of cpus plus

00:01:20,720 --> 00:01:23,439
17.

00:01:21,600 --> 00:01:25,280
now the things have changed a little bit

00:01:23,439 --> 00:01:29,360
from uh

00:01:25,280 --> 00:01:32,000
from 2017 uh we finally got

00:01:29,360 --> 00:01:34,079
siplus plus 20 ratified so this is a

00:01:32,000 --> 00:01:37,759
photo from the private meeting of

00:01:34,079 --> 00:01:39,119
iso c2p uh where the c plus plus 20 was

00:01:37,759 --> 00:01:42,880
finalized

00:01:39,119 --> 00:01:46,320
and two days ago uh c

00:01:42,880 --> 00:01:46,640
plus 20 was accepted by the iso so it's

00:01:46,320 --> 00:01:49,680
not

00:01:46,640 --> 00:01:51,040
an official proper standard and during

00:01:49,680 --> 00:01:53,680
those three years

00:01:51,040 --> 00:01:54,079
uh all the compilers that we care about

00:01:53,680 --> 00:01:57,200
uh

00:01:54,079 --> 00:02:00,240
now supports equals plus uh 17.

00:01:57,200 --> 00:02:02,479
so i'm going to focus mostly on

00:02:00,240 --> 00:02:03,439
little useful features that squarespace

00:02:02,479 --> 00:02:06,719
00:02:03,439 --> 00:02:08,479
gives us with a couple of cpus plus 20

00:02:06,719 --> 00:02:12,160
features i'm not going to cover

00:02:08,479 --> 00:02:14,959
any of the huge plus 20 things

00:02:12,160 --> 00:02:16,800
for those you can go and watch the video

00:02:14,959 --> 00:02:21,120
from academy 2017

00:02:16,800 --> 00:02:26,000
or you can just find dedicated talks on

00:02:21,120 --> 00:02:26,000
ranges score routines and stuff

00:02:26,640 --> 00:02:30,000
okay so let's begin

00:02:31,040 --> 00:02:35,599
this is a little bit slow uh so in

00:02:34,080 --> 00:02:39,040
zebra's plus 11 we got

00:02:35,599 --> 00:02:41,280
a function called stud to string

00:02:39,040 --> 00:02:42,560
and this function is a little bit

00:02:41,280 --> 00:02:44,959
tedious because

00:02:42,560 --> 00:02:45,760
you can't convert strings to string you

00:02:44,959 --> 00:02:48,319
can convert

00:02:45,760 --> 00:02:50,480
characters to string you can essentially

00:02:48,319 --> 00:02:53,840
you can just convert things like

00:02:50,480 --> 00:02:57,200
integers and floats etc

00:02:53,840 --> 00:03:00,720
so if you wanted to write a function

00:02:57,200 --> 00:03:04,080
that extends the standard to string

00:03:00,720 --> 00:03:06,319
we could do something like this so we

00:03:04,080 --> 00:03:09,599
can create a generic function

00:03:06,319 --> 00:03:10,480
that uh that obviously accepts any type

00:03:09,599 --> 00:03:13,680
t

00:03:10,480 --> 00:03:16,800
and if we if we got

00:03:13,680 --> 00:03:19,040
a proper std string inside as a t

00:03:16,800 --> 00:03:20,000
then we don't really have to call std to

00:03:19,040 --> 00:03:23,760
string

00:03:20,000 --> 00:03:25,599
now in new beautiful sql plus 17

00:03:23,760 --> 00:03:27,920
we can check this at compile time

00:03:25,599 --> 00:03:29,040
whether type t is some specific type

00:03:27,920 --> 00:03:32,000
that we want

00:03:29,040 --> 00:03:32,400
so we can just write if const expert and

00:03:32,000 --> 00:03:36,720
then

00:03:32,400 --> 00:03:39,760
check is same t and sdb string

00:03:36,720 --> 00:03:42,879
now in this particular slide we have two

00:03:39,760 --> 00:03:43,840
features that didn't exist before z plus

00:03:42,879 --> 00:03:47,360
17.

00:03:43,840 --> 00:03:50,400
the first one is that now we have

00:03:47,360 --> 00:03:50,959
prettier type traits so all the type

00:03:50,400 --> 00:03:52,720
traits

00:03:50,959 --> 00:03:54,000
in the standard library in the header

00:03:52,720 --> 00:03:57,200
type traits i

00:03:54,000 --> 00:03:59,519
have the suffix underscore v and

00:03:57,200 --> 00:04:00,560
underscore t so instead of having to

00:03:59,519 --> 00:04:02,560
write is same

00:04:00,560 --> 00:04:03,760
something something called column value

00:04:02,560 --> 00:04:06,400
you can just say

00:04:03,760 --> 00:04:06,959
is same underscore b and it shortens the

00:04:06,400 --> 00:04:09,599
code

00:04:06,959 --> 00:04:10,000
a little bit uh much more important is

00:04:09,599 --> 00:04:11,920
that

00:04:10,000 --> 00:04:14,720
now nowadays you don't need to write

00:04:11,920 --> 00:04:15,680
type name stdk column column type or

00:04:14,720 --> 00:04:19,120
anything like that

00:04:15,680 --> 00:04:22,960
we can just say stdk underscore d

00:04:19,120 --> 00:04:26,160
so these type names we had to sparkle

00:04:22,960 --> 00:04:26,639
over our code almost everywhere apart

00:04:26,160 --> 00:04:29,919
from

00:04:26,639 --> 00:04:31,199
having these suffixes in c plus plus 20

00:04:29,919 --> 00:04:35,040
and expected in c

00:04:31,199 --> 00:04:38,639
plus 23. uh we don't have

00:04:35,040 --> 00:04:39,280
this quite uh even in the cases where

00:04:38,639 --> 00:04:42,080
you still

00:04:39,280 --> 00:04:42,800
need to write type name in plus 17 and

00:04:42,080 --> 00:04:46,080
20.

00:04:42,800 --> 00:04:47,040
in c plus plus 23 it will all be just

00:04:46,080 --> 00:04:50,800
beautiful and

00:04:47,040 --> 00:04:54,080
you you would always be able to assume

00:04:50,800 --> 00:04:55,919
that the compiler knows that you forgot

00:04:54,080 --> 00:04:57,360
to write a type name so you won't need

00:04:55,919 --> 00:05:00,560
to actually write it

00:04:57,360 --> 00:05:03,520
now for people that know what sdk decay

00:05:00,560 --> 00:05:04,479
is i'd say that you can forget about it

00:05:03,520 --> 00:05:06,800
and that

00:05:04,479 --> 00:05:08,160
most of the time in sql plus 20 you will

00:05:06,800 --> 00:05:11,759
be able to use

00:05:08,160 --> 00:05:14,160
sd remove cvr so if you have a type

00:05:11,759 --> 00:05:15,840
and that can be a constant reference

00:05:14,160 --> 00:05:17,520
volatile reference or anything else and

00:05:15,840 --> 00:05:19,680
you want to strip out

00:05:17,520 --> 00:05:20,639
all the reference parts and constants

00:05:19,680 --> 00:05:24,080
and volatile

00:05:20,639 --> 00:05:25,199
you can just say sd remove cv ref

00:05:24,080 --> 00:05:27,520
underscore t

00:05:25,199 --> 00:05:28,240
and pass it to a certain type like const

00:05:27,520 --> 00:05:31,039
string

00:05:28,240 --> 00:05:32,880
uh constrain graph and this field this

00:05:31,039 --> 00:05:34,000
meta function will return you a normal

00:05:32,880 --> 00:05:36,960
string

00:05:34,000 --> 00:05:37,440
so this is one of the things that is new

00:05:36,960 --> 00:05:39,600
small

00:05:37,440 --> 00:05:40,800
thing that will make up your code much

00:05:39,600 --> 00:05:44,639
better

00:05:40,800 --> 00:05:48,080
uh in sql plus 17. the second one is

00:05:44,639 --> 00:05:52,000
the compile time if or if constexpr

00:05:48,080 --> 00:05:53,520
uh if we try to call this same v with

00:05:52,000 --> 00:05:57,199
the normal if

00:05:53,520 --> 00:05:58,560
and then try to put it in a function

00:05:57,199 --> 00:06:00,319
that checks whether something is a

00:05:58,560 --> 00:06:02,720
string if it's a string then

00:06:00,319 --> 00:06:03,520
don't call to string and if it's not a

00:06:02,720 --> 00:06:06,400
string then call

00:06:03,520 --> 00:06:08,400
the string then you would have have a

00:06:06,400 --> 00:06:11,759
compiler error because

00:06:08,400 --> 00:06:14,240
both branches of if need to be valid

00:06:11,759 --> 00:06:15,120
in this case if you're using if const

00:06:14,240 --> 00:06:17,440
expert

00:06:15,120 --> 00:06:19,280
then only one of the branches will

00:06:17,440 --> 00:06:20,000
actually be compiled both of them need

00:06:19,280 --> 00:06:23,120
to be

00:06:20,000 --> 00:06:26,560
valid in syntax but

00:06:23,120 --> 00:06:26,880
the type t that we passed doesn't need

00:06:26,560 --> 00:06:31,120
to

00:06:26,880 --> 00:06:34,639
have a two-string function to work on it

00:06:31,120 --> 00:06:36,560
if uh is saying the returns true

00:06:34,639 --> 00:06:38,160
so if you go to the first branch the

00:06:36,560 --> 00:06:41,759
second branch will not really be

00:06:38,160 --> 00:06:41,759
checked for semantics

00:06:42,000 --> 00:06:48,160
uh also we can instead of just checking

00:06:45,440 --> 00:06:49,120
whether something is is the same we can

00:06:48,160 --> 00:06:52,080
also check

00:06:49,120 --> 00:06:52,560
as the derived from now as the derived

00:06:52,080 --> 00:06:55,440
from

00:06:52,560 --> 00:06:57,680
doesn't have underscore t because it's

00:06:55,440 --> 00:07:00,880
not a type trade it's something that

00:06:57,680 --> 00:07:03,599
is uh available as in silver's plus mt

00:07:00,880 --> 00:07:05,039
and it's called the concept in essence

00:07:03,599 --> 00:07:05,759
for the time being just think of

00:07:05,039 --> 00:07:07,840
concepts

00:07:05,759 --> 00:07:09,440
as compile time functions that return

00:07:07,840 --> 00:07:13,039
true or false just like

00:07:09,440 --> 00:07:16,080
insane did you just

00:07:13,039 --> 00:07:19,680
define with a different syntax

00:07:16,080 --> 00:07:22,400
and if you want instead of supporting uh

00:07:19,680 --> 00:07:23,039
types that are not derived from from a

00:07:22,400 --> 00:07:26,560
string

00:07:23,039 --> 00:07:28,400
we can just call static assert

00:07:26,560 --> 00:07:29,680
in the health branch now this is going

00:07:28,400 --> 00:07:32,160
to lead to a problem

00:07:29,680 --> 00:07:32,960
because as i said both branches are

00:07:32,160 --> 00:07:36,080
going to be

00:07:32,960 --> 00:07:36,800
compiled but not checked semantically in

00:07:36,080 --> 00:07:39,520
this case

00:07:36,800 --> 00:07:40,880
static assert is going to make a

00:07:39,520 --> 00:07:43,520
compiler error

00:07:40,880 --> 00:07:44,800
because else branch even if it's not

00:07:43,520 --> 00:07:48,879
going to be executed

00:07:44,800 --> 00:07:52,160
the else branch is going to be compiled

00:07:48,879 --> 00:07:55,360
if you wanted to do something

00:07:52,160 --> 00:07:55,759
like a static assert of false what you

00:07:55,360 --> 00:07:59,280
should

00:07:55,759 --> 00:08:02,319
do instead is create a meta function

00:07:59,280 --> 00:08:04,000
like the function that that is in the

00:08:02,319 --> 00:08:06,319
slide called always false

00:08:04,000 --> 00:08:08,240
so whatever type you pass to it it will

00:08:06,319 --> 00:08:10,400
return a false

00:08:08,240 --> 00:08:11,360
and then you can use it in the static

00:08:10,400 --> 00:08:15,199
assert so

00:08:11,360 --> 00:08:16,000
if the boolean value that you pass to

00:08:15,199 --> 00:08:19,360
static cert

00:08:16,000 --> 00:08:21,199
depends on t then it's not going to be

00:08:19,360 --> 00:08:24,720
evaluated in the ls branch

00:08:21,199 --> 00:08:27,840
if only the dam branch is going to be

00:08:24,720 --> 00:08:27,840
executed and compiled

00:08:28,960 --> 00:08:34,640
static assert without an explanation

00:08:32,640 --> 00:08:36,719
for the assert so without a second

00:08:34,640 --> 00:08:38,159
argument of the string is also added in

00:08:36,719 --> 00:08:40,080
c plus plus 17.

00:08:38,159 --> 00:08:42,719
so if you are lazy and you don't want to

00:08:40,080 --> 00:08:45,200
write an explanation for your assets

00:08:42,719 --> 00:08:48,880
since the c plus plus 17 you can just

00:08:45,200 --> 00:08:48,880
omit it in the static assert

00:08:50,560 --> 00:08:54,800
now if we wanted to do it a little bit

00:08:53,360 --> 00:08:56,959
more modern

00:08:54,800 --> 00:08:58,160
we can just say okay we are creating a

00:08:56,959 --> 00:08:59,839
template function

00:08:58,160 --> 00:09:02,160
but we are going to restrict we don't

00:08:59,839 --> 00:09:04,560
want it to work for all keys

00:09:02,160 --> 00:09:05,519
we just want to want it to work on

00:09:04,560 --> 00:09:08,399
specific

00:09:05,519 --> 00:09:09,519
set of these and we can just say it's a

00:09:08,399 --> 00:09:12,720
template function

00:09:09,519 --> 00:09:16,000
templated on t and we require that t

00:09:12,720 --> 00:09:17,600
is derived from std string and this is

00:09:16,000 --> 00:09:20,959
the syntax that is available

00:09:17,600 --> 00:09:23,360
since concepts is since c plus plus 20.

00:09:20,959 --> 00:09:25,200
if you want to provide several functions

00:09:23,360 --> 00:09:27,839
one function that we

00:09:25,200 --> 00:09:29,519
works on types derived from string and

00:09:27,839 --> 00:09:30,560
another function that works on other

00:09:29,519 --> 00:09:34,160
types

00:09:30,560 --> 00:09:37,040
you can use this trick to restrict

00:09:34,160 --> 00:09:38,240
one of those functions by default if the

00:09:37,040 --> 00:09:40,720
restriction

00:09:38,240 --> 00:09:41,760
is fulfilled for a certain type that

00:09:40,720 --> 00:09:43,519
function will be called

00:09:41,760 --> 00:09:45,760
otherwise it will fall back to the

00:09:43,519 --> 00:09:50,399
second function the generic version

00:09:45,760 --> 00:09:53,440
without any requires clause

00:09:50,399 --> 00:09:54,800
so this is concepts and constraints in c

00:09:53,440 --> 00:09:57,600
plus plus 20.

00:09:54,800 --> 00:09:58,080
uh also if you don't like the required

00:09:57,600 --> 00:10:00,320
clause

00:09:58,080 --> 00:10:02,560
you can always use the shortest syntax

00:10:00,320 --> 00:10:04,240
instead of saying template type empty

00:10:02,560 --> 00:10:05,600
and then requires you can just say

00:10:04,240 --> 00:10:08,720
template

00:10:05,600 --> 00:10:11,760
derive from string t and then

00:10:08,720 --> 00:10:14,640
implement your function and if this is

00:10:11,760 --> 00:10:15,839
also too much to to type for you you can

00:10:14,640 --> 00:10:19,440
just

00:10:15,839 --> 00:10:20,959
say uh street to string not even

00:10:19,440 --> 00:10:22,560
it doesn't even look like a template

00:10:20,959 --> 00:10:25,120
function even if it is

00:10:22,560 --> 00:10:26,160
and then you can just say derive from

00:10:25,120 --> 00:10:28,480
string

00:10:26,160 --> 00:10:31,040
auto so automatically deduce the type

00:10:28,480 --> 00:10:34,320
that needs to be derived from sdd string

00:10:31,040 --> 00:10:37,279
and you have the value of that type

00:10:34,320 --> 00:10:38,399
so this is the most syntax for defining

00:10:37,279 --> 00:10:41,600
restrictions on

00:10:38,399 --> 00:10:45,120
generic or template functions

00:10:41,600 --> 00:10:46,079
from another example of a couple of new

00:10:45,120 --> 00:10:50,079
things that we have

00:10:46,079 --> 00:10:54,240
in uh modern versions of sequels plus

00:10:50,079 --> 00:10:57,279
is the is this one where we have and if

00:10:54,240 --> 00:10:58,480
we are locking a mutex and we are

00:10:57,279 --> 00:11:03,760
checking whether

00:10:58,480 --> 00:11:03,760
a certain map contains key kde

00:11:04,240 --> 00:11:08,560
also we can do something like this we

00:11:06,320 --> 00:11:12,079
can write a range base for loop again

00:11:08,560 --> 00:11:14,079
lock mutex and then iterate through all

00:11:12,079 --> 00:11:15,920
the items in a map

00:11:14,079 --> 00:11:17,440
since we all know that maps are

00:11:15,920 --> 00:11:19,519
collections of pairs

00:11:17,440 --> 00:11:22,079
this is going to iterate over all the

00:11:19,519 --> 00:11:24,800
key values in a pair

00:11:22,079 --> 00:11:25,519
so what new features do we have here the

00:11:24,800 --> 00:11:29,120
first one

00:11:25,519 --> 00:11:32,240
is that we can add initializers

00:11:29,120 --> 00:11:35,920
to uh if for and switch

00:11:32,240 --> 00:11:36,959
so the old four from dark edges from the

00:11:35,920 --> 00:11:40,079
c

00:11:36,959 --> 00:11:40,640
it already had a couple of clauses

00:11:40,079 --> 00:11:42,480
inside

00:11:40,640 --> 00:11:44,160
so the initializer the condition and the

00:11:42,480 --> 00:11:46,640
increment and

00:11:44,160 --> 00:11:48,640
nowadays in c plus plus 20 we have the

00:11:46,640 --> 00:11:51,519
same initializer for

00:11:48,640 --> 00:11:52,720
the range-based for loop and see in cpl

00:11:51,519 --> 00:11:56,079
17 we have

00:11:52,720 --> 00:11:58,639
the initializers for if and for switches

00:11:56,079 --> 00:11:59,680
so if you want to narrow the scope of a

00:11:58,639 --> 00:12:02,800
variable

00:11:59,680 --> 00:12:04,240
you don't need to declare it in the

00:12:02,800 --> 00:12:08,480
autoscope and then

00:12:04,240 --> 00:12:11,440
just put put it inside of a named block

00:12:08,480 --> 00:12:11,920
you can just put it inside of the if or

00:12:11,440 --> 00:12:16,079
four

00:12:11,920 --> 00:12:18,639
or switch the second thing is that

00:12:16,079 --> 00:12:20,000
uh scope locks we didn't really have

00:12:18,639 --> 00:12:21,440
scope logs before

00:12:20,000 --> 00:12:24,240
we had something that that was called

00:12:21,440 --> 00:12:26,880
the lock guard and it was able to lock a

00:12:24,240 --> 00:12:28,560
single mutex that you passed to it scope

00:12:26,880 --> 00:12:31,279
lock is a little bit more powerful

00:12:28,560 --> 00:12:31,920
you can lock several mutexes at once and

00:12:31,279 --> 00:12:35,200
it uses

00:12:31,920 --> 00:12:37,839
nice algorithms to avoid deadlocks

00:12:35,200 --> 00:12:39,760
etc so if you need to lock several

00:12:37,839 --> 00:12:42,160
mutexes which

00:12:39,760 --> 00:12:44,560
arguably you shouldn't ever have to do

00:12:42,160 --> 00:12:47,040
uh you can use scope lock without

00:12:44,560 --> 00:12:48,320
any consideration of what locks first

00:12:47,040 --> 00:12:50,880
like battle of second

00:12:48,320 --> 00:12:50,880
etc

00:12:51,519 --> 00:12:54,720
the second thing that is shown in in

00:12:53,600 --> 00:12:56,560
this example

00:12:54,720 --> 00:12:58,399
is something that is actually not shown

00:12:56,560 --> 00:13:01,920
because it's missing

00:12:58,399 --> 00:13:03,440
uh lock guard and scope lock are generic

00:13:01,920 --> 00:13:06,880
template classes

00:13:03,440 --> 00:13:11,040
so they need to have template arguments

00:13:06,880 --> 00:13:14,240
in simple spots before simple 17 we had

00:13:11,040 --> 00:13:18,160
automatic type deduction for functions

00:13:14,240 --> 00:13:20,320
so if you call sdd make pair you would

00:13:18,160 --> 00:13:21,519
the compiler would automatically deduce

00:13:20,320 --> 00:13:24,560
the uh

00:13:21,519 --> 00:13:25,440
generic arguments so the template

00:13:24,560 --> 00:13:28,000
arguments for

00:13:25,440 --> 00:13:28,880
that function but it never worked for

00:13:28,000 --> 00:13:32,240
classes

00:13:28,880 --> 00:13:36,000
in this case since it was plus 17

00:13:32,240 --> 00:13:39,279
uh the compiler can deduce that since

00:13:36,000 --> 00:13:41,839
nmap mutex is an sdb mutex that

00:13:39,279 --> 00:13:42,320
this scope lock is actually a scope lock

00:13:41,839 --> 00:13:46,560
of

00:13:42,320 --> 00:13:48,560
std mutex and this works for

00:13:46,560 --> 00:13:49,600
most of the generic classes that you see

00:13:48,560 --> 00:13:51,680
in

00:13:49,600 --> 00:13:52,720
in the standard library and it can work

00:13:51,680 --> 00:13:55,120
obviously on

00:13:52,720 --> 00:13:57,199
your types that you define so you don't

00:13:55,120 --> 00:13:59,920
really you don't need to write anymore

00:13:57,199 --> 00:14:00,560
as the vector of eat when you create a

00:13:59,920 --> 00:14:03,199
vector

00:14:00,560 --> 00:14:04,160
you can just say the vector x's of one

00:14:03,199 --> 00:14:07,279
through three

00:14:04,160 --> 00:14:08,240
again this is still uh the types are

00:14:07,279 --> 00:14:11,199
still

00:14:08,240 --> 00:14:13,360
not dynamic this is not python it's just

00:14:11,199 --> 00:14:15,120
that the compiler can deduce

00:14:13,360 --> 00:14:16,639
from the one two three that this is

00:14:15,120 --> 00:14:18,880
going to be a vector of

00:14:16,639 --> 00:14:18,880
int

00:14:20,480 --> 00:14:23,680
in the cases where you want to implement

00:14:22,240 --> 00:14:25,600
your own types

00:14:23,680 --> 00:14:26,880
the way that the compiler deduces the

00:14:25,600 --> 00:14:29,519
types for

00:14:26,880 --> 00:14:31,680
for the class is either through a

00:14:29,519 --> 00:14:32,720
constructor so if you have a constructor

00:14:31,680 --> 00:14:36,399
that accepts

00:14:32,720 --> 00:14:37,440
a type t and your class is parameterized

00:14:36,399 --> 00:14:39,120
on the type t

00:14:37,440 --> 00:14:41,040
it will automatically reduce from the

00:14:39,120 --> 00:14:41,680
constructor if you called it with an int

00:14:41,040 --> 00:14:44,720
it's going

00:14:41,680 --> 00:14:47,680
t is going to be in it but in some cases

00:14:44,720 --> 00:14:48,079
you would like to help the compiler to

00:14:47,680 --> 00:14:50,720
do

00:14:48,079 --> 00:14:52,639
something a little bit more advanced so

00:14:50,720 --> 00:14:54,160
if you don't have the constructors

00:14:52,639 --> 00:14:56,320
from which the compiler can deduce

00:14:54,160 --> 00:14:58,560
something you can write something that

00:14:56,320 --> 00:15:01,600
is called the deduction guide

00:14:58,560 --> 00:15:04,079
in this case we have defined some

00:15:01,600 --> 00:15:05,760
type that is called my type and which we

00:15:04,079 --> 00:15:09,680
are trying to tell the compiler

00:15:05,760 --> 00:15:13,279
if somebody calls a constructor with

00:15:09,680 --> 00:15:16,160
an integer and a float then what

00:15:13,279 --> 00:15:17,839
it what it should deduce it should

00:15:16,160 --> 00:15:20,560
deduce my type of

00:15:17,839 --> 00:15:21,360
vector of integer and a float and you

00:15:20,560 --> 00:15:23,760
can write

00:15:21,360 --> 00:15:25,199
arbitrary deduction guidelines for for

00:15:23,760 --> 00:15:27,120
your types

00:15:25,199 --> 00:15:28,800
sometimes going the constructors are

00:15:27,120 --> 00:15:32,000
nicer sometimes

00:15:28,800 --> 00:15:32,880
uh the deduction guidelines will be

00:15:32,000 --> 00:15:36,160
prettier and

00:15:32,880 --> 00:15:36,160
they're usually more powerful

00:15:37,120 --> 00:15:41,279
and another thing that that was uh in

00:15:40,160 --> 00:15:44,480
the example

00:15:41,279 --> 00:15:47,600
that is from z 17 is the

00:15:44,480 --> 00:15:48,399
aforementioned structure bindings so we

00:15:47,600 --> 00:15:51,040
have a map

00:15:48,399 --> 00:15:52,720
map is a collection of pair key value

00:15:51,040 --> 00:15:56,639
pairs so as the pair

00:15:52,720 --> 00:15:59,440
of something something and

00:15:56,639 --> 00:16:01,839
usually before c plus plus 17 we would

00:15:59,440 --> 00:16:02,639
iterate from f and then access the keys

00:16:01,839 --> 00:16:04,880
and values as

00:16:02,639 --> 00:16:06,079
dot first and dot second but first and

00:16:04,880 --> 00:16:08,639
dot second don't

00:16:06,079 --> 00:16:10,240
really convey any meaning as the names

00:16:08,639 --> 00:16:13,199
are really generic

00:16:10,240 --> 00:16:14,639
so if you want to assign the names to

00:16:13,199 --> 00:16:16,560
parts of a tuple or

00:16:14,639 --> 00:16:17,680
parts of a pair you can just use

00:16:16,560 --> 00:16:20,720
structure bindings

00:16:17,680 --> 00:16:23,759
with square braces and say

00:16:20,720 --> 00:16:26,079
key and value iterate take

00:16:23,759 --> 00:16:27,680
all the the pairs from the map and

00:16:26,079 --> 00:16:31,759
assign

00:16:27,680 --> 00:16:34,959
dot first to key and dot second to value

00:16:31,759 --> 00:16:38,240
now there is something a little bit

00:16:34,959 --> 00:16:41,440
annoying about the structure bindings uh

00:16:38,240 --> 00:16:42,079
if we try to capture the key and value

00:16:41,440 --> 00:16:45,120
by

00:16:42,079 --> 00:16:47,839
by value so not a constraint or anything

00:16:45,120 --> 00:16:50,480
else we just wrote auto key and value

00:16:47,839 --> 00:16:51,279
from from the map we would expect key

00:16:50,480 --> 00:16:55,040
and value to be

00:16:51,279 --> 00:16:56,959
proper values so we have an instance of

00:16:55,040 --> 00:16:58,240
let's say a string an instance of an

00:16:56,959 --> 00:17:01,839
integer

00:16:58,240 --> 00:17:04,880
uh internally if this is a little bit

00:17:01,839 --> 00:17:07,199
more complex so the pair

00:17:04,880 --> 00:17:08,400
from the map will be stored inside of a

00:17:07,199 --> 00:17:11,439
proper value with

00:17:08,400 --> 00:17:13,679
video type std pair of something

00:17:11,439 --> 00:17:16,079
and key and value from the structured

00:17:13,679 --> 00:17:20,240
binding are going actually to be

00:17:16,079 --> 00:17:22,319
a reference to uh to elements inside of

00:17:20,240 --> 00:17:25,280
the pair

00:17:22,319 --> 00:17:27,520
even if the compiler is going to try its

00:17:25,280 --> 00:17:27,839
hardest to lie to you and to tell you

00:17:27,520 --> 00:17:30,400
that

00:17:27,839 --> 00:17:30,880
it's a proper value even if you try to

00:17:30,400 --> 00:17:32,880
use

00:17:30,880 --> 00:17:34,799
decal type of key and decal type of

00:17:32,880 --> 00:17:37,360
value which will return

00:17:34,799 --> 00:17:38,160
that there are normal values that's not

00:17:37,360 --> 00:17:40,000
true they're

00:17:38,160 --> 00:17:42,480
actually in internally they're going to

00:17:40,000 --> 00:17:43,760
be references to the elements inside of

00:17:42,480 --> 00:17:46,240
the std pair

00:17:43,760 --> 00:17:46,960
so they're not going to be proper values

00:17:46,240 --> 00:17:50,720
this has

00:17:46,960 --> 00:17:53,200
some unfortunate side effects that

00:17:50,720 --> 00:17:54,080
when you want to use more semantics on

00:17:53,200 --> 00:17:56,640
these things

00:17:54,080 --> 00:17:58,320
you can't really say return value and

00:17:56,640 --> 00:17:58,720
expect the compiler to optimize it for

00:17:58,320 --> 00:18:01,919
you

00:17:58,720 --> 00:18:04,720
you will have to do return std move of

00:18:01,919 --> 00:18:04,720
value etc

00:18:05,200 --> 00:18:09,840
uh and the last section i have two

00:18:08,480 --> 00:18:14,000
minutes before the

00:18:09,840 --> 00:18:16,720
the questions time this was really fast

00:18:14,000 --> 00:18:17,840
there's also some new things with uh

00:18:16,720 --> 00:18:21,039
standard audience

00:18:17,840 --> 00:18:22,960
so for example the algorithm has to be

00:18:21,039 --> 00:18:24,400
reduced which kind of behaves like

00:18:22,960 --> 00:18:26,880
accumulate but

00:18:24,400 --> 00:18:28,880
a little bit more generic now if you

00:18:26,880 --> 00:18:31,360
want to parallelize it

00:18:28,880 --> 00:18:32,720
you don't need to deal with threads to

00:18:31,360 --> 00:18:34,160
fire up threads or anything else

00:18:32,720 --> 00:18:37,120
synchronization

00:18:34,160 --> 00:18:37,760
etc you can just say sdd reduce i want

00:18:37,120 --> 00:18:40,240
it to be

00:18:37,760 --> 00:18:41,679
executed in parallel so sdd execution

00:18:40,240 --> 00:18:44,080
policy parallel

00:18:41,679 --> 00:18:45,360
and then just pass the same thing that

00:18:44,080 --> 00:18:48,640
you passed to

00:18:45,360 --> 00:18:51,520
normal std reduce now if you hate

00:18:48,640 --> 00:18:53,360
having to write dot begin dot and

00:18:51,520 --> 00:18:57,120
everywhere in your code

00:18:53,360 --> 00:19:00,640
you can use the second version

00:18:57,120 --> 00:19:04,000
if you just slide our switches uh

00:19:00,640 --> 00:19:07,919
you can uh sorry i have one thing

00:19:04,000 --> 00:19:11,360
uh before so again binary search

00:19:07,919 --> 00:19:13,760
uh the same thing as we used to have

00:19:11,360 --> 00:19:15,600
this binary search can be optimized

00:19:13,760 --> 00:19:16,559
really well if you have constructs for

00:19:15,600 --> 00:19:19,039
data

00:19:16,559 --> 00:19:19,840
so most of the algorithms in cpus plus

00:19:19,039 --> 00:19:23,120
00:19:19,840 --> 00:19:25,360
have the contacts for edits to them so

00:19:23,120 --> 00:19:27,280
if you have data that is known at

00:19:25,360 --> 00:19:30,559
compile time nothing will end up

00:19:27,280 --> 00:19:32,480
in executed dynamically

00:19:30,559 --> 00:19:33,760
the compiler will execute binary

00:19:32,480 --> 00:19:35,840
searches sorts

00:19:33,760 --> 00:19:39,840
accumulates and everything else during

00:19:35,840 --> 00:19:39,840
the compile time

00:19:40,400 --> 00:19:46,080
and to to get back to dot begin dot and

00:19:43,760 --> 00:19:47,520
if you hate writing those then you

00:19:46,080 --> 00:19:50,720
should just

00:19:47,520 --> 00:19:52,480
use sd ranges name space and then

00:19:50,720 --> 00:19:54,000
instead of having to write pairs of

00:19:52,480 --> 00:19:55,760
iterators you can just write the

00:19:54,000 --> 00:19:56,160
collection itself so binary sphere

00:19:55,760 --> 00:19:59,440
search

00:19:56,160 --> 00:20:00,720
i'm trying to search 42 in the array of

00:19:59,440 --> 00:20:04,320
axes

00:20:00,720 --> 00:20:04,320
this is also c plus plus 20.

00:20:04,480 --> 00:20:07,760
and the last thing a little bit related

00:20:07,120 --> 00:20:10,320
to

00:20:07,760 --> 00:20:10,799
reduce and accumulate is something

00:20:10,320 --> 00:20:14,240
called

00:20:10,799 --> 00:20:15,520
fold expressions if you don't have a

00:20:14,240 --> 00:20:18,720
collection of values

00:20:15,520 --> 00:20:22,000
but you have a periodic template where

00:20:18,720 --> 00:20:24,720
you have a function that accepts uh

00:20:22,000 --> 00:20:25,840
numerous uh an arbitrary number of

00:20:24,720 --> 00:20:28,559
values

00:20:25,840 --> 00:20:29,520
you can use fault expressions to do

00:20:28,559 --> 00:20:33,039
accumulation

00:20:29,520 --> 00:20:35,520
or do reduce of all the values so you

00:20:33,039 --> 00:20:36,480
can write zero plus dotted dot plus

00:20:35,520 --> 00:20:38,880
values

00:20:36,480 --> 00:20:40,400
and when you call a sum of one two three

00:20:38,880 --> 00:20:44,799
it will add

00:20:40,400 --> 00:20:47,440
zero plus one plus plus two plus three

00:20:44,799 --> 00:20:48,559
fold expressions come in uh different

00:20:47,440 --> 00:20:50,480
forms so

00:20:48,559 --> 00:20:51,840
depending on whether you want to go from

00:20:50,480 --> 00:20:53,840
the left to right

00:20:51,840 --> 00:20:56,159
with your operator or from the right to

00:20:53,840 --> 00:20:59,440
left

00:20:56,159 --> 00:21:02,720
and they can be used for quite

00:20:59,440 --> 00:21:03,600
quite complex things like if you want to

00:21:02,720 --> 00:21:06,080
invoke

00:21:03,600 --> 00:21:07,840
a certain function on each of the values

00:21:06,080 --> 00:21:10,960
that you pass

00:21:07,840 --> 00:21:12,640
again this is not a collection just uh

00:21:10,960 --> 00:21:15,840
if you want to invoke it on all the

00:21:12,640 --> 00:21:16,240
arguments that the user passed to your

00:21:15,840 --> 00:21:19,440
uh

00:21:16,240 --> 00:21:21,760
function uh you can use the

00:21:19,440 --> 00:21:22,880
fault expressions with the comma

00:21:21,760 --> 00:21:26,559
operator and say

00:21:22,880 --> 00:21:28,400
sdd invoke f on values and it will just

00:21:26,559 --> 00:21:30,640
unwrite into sbd invoke f

00:21:28,400 --> 00:21:31,840
on the first value f on the second value

00:21:30,640 --> 00:21:34,559
f on the third value

00:21:31,840 --> 00:21:34,559
and so on

00:21:36,000 --> 00:21:40,000
another new thing in z 17 is the sdd

00:21:38,960 --> 00:21:43,280
invoke

00:21:40,000 --> 00:21:44,400
and this is a function that allows you

00:21:43,280 --> 00:21:46,960
to call not

00:21:44,400 --> 00:21:48,159
only lambdas ordinary functions on

00:21:46,960 --> 00:21:51,280
specific values

00:21:48,159 --> 00:21:53,039
but also to call pointers to member

00:21:51,280 --> 00:21:54,559
variables and pointers to member

00:21:53,039 --> 00:21:56,799
functions as

00:21:54,559 --> 00:21:58,559
if they were normal functions so you

00:21:56,799 --> 00:22:00,799
would be able to write something like

00:21:58,559 --> 00:22:03,039
for each call delete later from queue

00:22:00,799 --> 00:22:06,080
object on window 1 windows 2

00:22:03,039 --> 00:22:06,080
and window 3.

00:22:06,880 --> 00:22:12,000
and the last thing that i want to

00:22:08,880 --> 00:22:12,559
mention because my time has run out in

00:22:12,000 --> 00:22:16,000
simplest

00:22:12,559 --> 00:22:19,039
20 we also got a new library for

00:22:16,000 --> 00:22:21,840
string formatting which is meant to

00:22:19,039 --> 00:22:23,039
obsolete the ear streams most of uh for

00:22:21,840 --> 00:22:25,280
the most part

00:22:23,039 --> 00:22:27,039
and we can write something like this to

00:22:25,280 --> 00:22:32,000
generate a really nice banner

00:22:27,039 --> 00:22:35,600
welcome to academy 22 2020 sorry

00:22:32,000 --> 00:22:37,120
and i think that's it if there are any

00:22:35,600 --> 00:22:38,880
questions

00:22:37,120 --> 00:22:41,679
thank you so much evan that was super

00:22:38,880 --> 00:22:44,080
interesting and a very beautiful banner

00:22:41,679 --> 00:22:46,000
we have three questions and i think we

00:22:44,080 --> 00:22:48,799
have time for the first one

00:22:46,000 --> 00:22:51,840
which is template functions or function

00:22:48,799 --> 00:22:54,640
template what's your stance

00:22:51,840 --> 00:22:55,679
the official name is a template function

00:22:54,640 --> 00:22:58,799
so

00:22:55,679 --> 00:22:59,520
oh sorry functional template it's usual

00:22:58,799 --> 00:23:02,080
that we

00:22:59,520 --> 00:23:03,919
we call it template function but it's a

00:23:02,080 --> 00:23:05,360
function template it's a class template

00:23:03,919 --> 00:23:06,480
because they are not functions they're

00:23:05,360 --> 00:23:09,520
templates

00:23:06,480 --> 00:23:10,720
but in normal communication

00:23:09,520 --> 00:23:13,440
these two terms are quite

00:23:10,720 --> 00:23:13,440
interchangeable

00:23:13,760 --> 00:23:16,880
cool and then the last one uh do you

00:23:16,480 --> 00:23:19,600
have

00:23:16,880 --> 00:23:20,559
insight why while didn't gain an

00:23:19,600 --> 00:23:24,720
initializer

00:23:20,559 --> 00:23:27,200
seems inconsistent uh so

00:23:24,720 --> 00:23:28,480
that was my first impression as well but

00:23:27,200 --> 00:23:31,520
while

00:23:28,480 --> 00:23:34,799
with the initializer is the old c4

00:23:31,520 --> 00:23:36,880
just without the increment part so

00:23:34,799 --> 00:23:38,480
while bit initializer would be the same

00:23:36,880 --> 00:23:42,159
as just writing for

00:23:38,480 --> 00:23:44,400
the different two clauses filled in

00:23:42,159 --> 00:23:46,720
and then semicolon with an empty third

00:23:44,400 --> 00:23:46,720
clause

00:23:48,400 --> 00:23:52,320
so it is inconsistent but it's not

00:23:56,679 --> 00:23:59,679

YouTube URL: https://www.youtube.com/watch?v=-ev7uvKh_JY


