Title: Akademy 2020 - Rohan Garg - Linux Graphics 101
Publication date: 2020-11-24
Playlist: Akademy 2020
Description: 
	The ever growing popularity of ARM devices has meant a new market for KDE products. However, unlike conventional platforms where we enjoy the stability of a well tested graphics stack, platforms based on the ARM architecture tend to be quirkier.

In this talk, Rohan will be talking about the basics of how the Linux Graphics stack works touching on how technologies such as DRM, DRI, and Mesa interact with each other and the history behind how we've come to the current Gallium design in mesa.
Captions: 
	00:00:01,110 --> 00:00:08,580
[Music]

00:00:10,639 --> 00:00:14,480
hey everyone welcome to

00:00:12,719 --> 00:00:17,119
open source graphics an introduction to

00:00:14,480 --> 00:00:19,439
converting bits to triangles

00:00:17,119 --> 00:00:22,160
i'm going to be talking about 3d

00:00:19,439 --> 00:00:26,080
graphics for the next 30 minutes or so

00:00:22,160 --> 00:00:28,400
and let's get started uh

00:00:26,080 --> 00:00:30,000
first of all i am not yet an experienced

00:00:28,400 --> 00:00:32,320
graphics looper so take my

00:00:30,000 --> 00:00:34,239
words with a grain of salt and please

00:00:32,320 --> 00:00:36,880
correct me if i'm wrong

00:00:34,239 --> 00:00:37,680
i have a lot to cover during the next 30

00:00:36,880 --> 00:00:39,680
minutes so i

00:00:37,680 --> 00:00:42,320
might be a little quick let me know in

00:00:39,680 --> 00:00:45,520
the chat below if i need to go slower

00:00:42,320 --> 00:00:47,920
and i'll try and base myself

00:00:45,520 --> 00:00:50,640
all right so this presentation is going

00:00:47,920 --> 00:00:52,160
to be a brief overview of the linux open

00:00:50,640 --> 00:00:55,680
source graphics stack

00:00:52,160 --> 00:00:57,920
uh i will not be covering

00:00:55,680 --> 00:01:01,039
how to develop a gpu driver or using

00:00:57,920 --> 00:01:04,559
opengl apis or explaining what gpus are

00:01:01,039 --> 00:01:06,479
and how they work uh and i will

00:01:04,559 --> 00:01:09,520
specifically be talking about

00:01:06,479 --> 00:01:13,119
the linux space essentially

00:01:09,520 --> 00:01:14,320
um all right so for the rest of the talk

00:01:13,119 --> 00:01:18,400
i would like you to

00:01:14,320 --> 00:01:21,360
visualize 3d graphics as a pipeline

00:01:18,400 --> 00:01:22,560
uh it really helps to visualize it as a

00:01:21,360 --> 00:01:24,640
pipeline

00:01:22,560 --> 00:01:26,479
because it is essentially a black line

00:01:24,640 --> 00:01:28,080
in the hardware

00:01:26,479 --> 00:01:29,520
and all of the software that's built

00:01:28,080 --> 00:01:32,720
around it

00:01:29,520 --> 00:01:34,240
works like a pipeline

00:01:32,720 --> 00:01:36,400
and i would like you to keep that

00:01:34,240 --> 00:01:37,520
visualization in your head as we go

00:01:36,400 --> 00:01:41,200
along

00:01:37,520 --> 00:01:42,560
in the talk cool so what are the parts

00:01:41,200 --> 00:01:44,880
of our pipeline

00:01:42,560 --> 00:01:45,840
uh we have three big parts of the

00:01:44,880 --> 00:01:47,920
pipeline

00:01:45,840 --> 00:01:48,880
uh the first big part is the graphics

00:01:47,920 --> 00:01:50,640
api

00:01:48,880 --> 00:01:53,280
uh the second big part are the user

00:01:50,640 --> 00:01:56,640
space drivers and the third big part

00:01:53,280 --> 00:01:56,640
are the kernel space drivers

00:01:57,200 --> 00:02:02,399
so the graphics api what are they the

00:02:00,240 --> 00:02:04,560
graphics apis are essentially

00:02:02,399 --> 00:02:05,840
a entry point for graphic applications

00:02:04,560 --> 00:02:07,759
and libraries

00:02:05,840 --> 00:02:09,840
and they abstract the gpu pipeline

00:02:07,759 --> 00:02:12,640
configuration manipulation

00:02:09,840 --> 00:02:13,840
uh parts of the parts of this pipeline

00:02:12,640 --> 00:02:16,400
of the 3d pipeline

00:02:13,840 --> 00:02:18,239
are essentially configurable and some

00:02:16,400 --> 00:02:20,480
parts are programmable

00:02:18,239 --> 00:02:23,440
uh we have a couple of libraries and

00:02:20,480 --> 00:02:25,200
apis that allow you to configure

00:02:23,440 --> 00:02:29,599
and manipulate this pipeline such as

00:02:25,200 --> 00:02:29,599
opengl balkan and direct3d

00:02:30,000 --> 00:02:34,959
uh like that like i said before spots of

00:02:33,200 --> 00:02:37,599
this pipeline are programmable

00:02:34,959 --> 00:02:40,080
through a separate programming language

00:02:37,599 --> 00:02:42,480
such as glsl or hlsl

00:02:40,080 --> 00:02:44,640
these programs are passed as a part of

00:02:42,480 --> 00:02:46,400
the pipeline configuration

00:02:44,640 --> 00:02:48,480
and are compiled by the drivers

00:02:46,400 --> 00:02:49,760
themselves to generate hardware-specific

00:02:48,480 --> 00:02:52,560
bytecode

00:02:49,760 --> 00:02:53,280
this part code is similar to what you

00:02:52,560 --> 00:02:55,920
would see

00:02:53,280 --> 00:02:56,560
on the cpu side but it's specific to the

00:02:55,920 --> 00:03:00,239
to

00:02:56,560 --> 00:03:00,239
every single gpu out there

00:03:01,200 --> 00:03:04,480
we have two philosophies in terms of

00:03:03,040 --> 00:03:06,800
graphics apis which

00:03:04,480 --> 00:03:07,840
are very commonly used these days uh one

00:03:06,800 --> 00:03:10,159
of them is opengl

00:03:07,840 --> 00:03:11,280
and the other one is falcon vulcan is

00:03:10,159 --> 00:03:13,440
the new kid on the block

00:03:11,280 --> 00:03:14,640
whereas whereas opengl is the more

00:03:13,440 --> 00:03:17,519
mature

00:03:14,640 --> 00:03:18,080
api that's been around for a while

00:03:17,519 --> 00:03:20,239
opengl

00:03:18,080 --> 00:03:21,680
tries to hide as much as possible the

00:03:20,239 --> 00:03:23,280
gpu internals

00:03:21,680 --> 00:03:25,760
whereas vulcan allows for much more

00:03:23,280 --> 00:03:29,599
fine-grained control control

00:03:25,760 --> 00:03:30,400
uh vulcan moves a lot of the driver

00:03:29,599 --> 00:03:32,480
complexity

00:03:30,400 --> 00:03:35,120
from moves a lot of the complexity from

00:03:32,480 --> 00:03:37,519
the driver into the vulcan application

00:03:35,120 --> 00:03:39,120
which means more work for you as an

00:03:37,519 --> 00:03:41,360
application developer

00:03:39,120 --> 00:03:43,040
but less work for the cpu which

00:03:41,360 --> 00:03:46,480
essentially leads to improved

00:03:43,040 --> 00:03:48,159
performance on cpu bound workloads

00:03:46,480 --> 00:03:50,879
so if you would like to be a little more

00:03:48,159 --> 00:03:53,200
lazy i would recommend using opengl

00:03:50,879 --> 00:03:54,159
but if you want to really go after every

00:03:53,200 --> 00:03:57,280
single frame

00:03:54,159 --> 00:03:57,280
vulcan is the way to go

00:03:57,599 --> 00:04:01,920
since gpu is a complex base the drivers

00:04:00,080 --> 00:04:04,159
are pretty complex as well

00:04:01,920 --> 00:04:05,760
we do not want all of this complexity

00:04:04,159 --> 00:04:08,799
within the kernel

00:04:05,760 --> 00:04:10,879
and we do not need to run all of this

00:04:08,799 --> 00:04:11,920
complexity in a privileged context which

00:04:10,879 --> 00:04:14,080
is why we

00:04:11,920 --> 00:04:16,160
tend to separate some of the

00:04:14,080 --> 00:04:17,919
responsibilities into user space and go

00:04:16,160 --> 00:04:23,440
in space

00:04:17,919 --> 00:04:23,440
so first of all i am going to be talking

00:04:23,520 --> 00:04:29,120
about kernel drivers uh the gun drivers

00:04:26,160 --> 00:04:30,720
specifically deal with memory management

00:04:29,120 --> 00:04:33,759
command streams submission and

00:04:30,720 --> 00:04:36,160
scheduling interrupts and signaling

00:04:33,759 --> 00:04:36,800
uh current drivers that have a open

00:04:36,160 --> 00:04:40,960
source

00:04:36,800 --> 00:04:44,240
user space driver live in the linux tree

00:04:40,960 --> 00:04:47,440
under driver's gpu drm uh

00:04:44,240 --> 00:04:49,360
whereas other drivers that interact with

00:04:47,440 --> 00:04:51,280
a closed source user space driver

00:04:49,360 --> 00:04:53,280
are out of tree these will never be

00:04:51,280 --> 00:04:54,840
accepted in the gun

00:04:53,280 --> 00:04:57,840
and i'm not going to be talking about

00:04:54,840 --> 00:04:57,840
those

00:04:58,000 --> 00:05:01,520
so one of the first things that i

00:05:00,000 --> 00:05:04,639
mentioned earlier was

00:05:01,520 --> 00:05:06,320
that kernel drivers

00:05:04,639 --> 00:05:08,720
uh one of the responsibilities of those

00:05:06,320 --> 00:05:11,680
corner driver is memory management

00:05:08,720 --> 00:05:13,360
uh you have two frameworks within the

00:05:11,680 --> 00:05:15,039
kernel to allow for this

00:05:13,360 --> 00:05:16,560
one of them is gem and the other one is

00:05:15,039 --> 00:05:20,320
ttm uh

00:05:16,560 --> 00:05:21,759
gem is what all the kernel drivers use

00:05:20,320 --> 00:05:24,880
excepting for vm

00:05:21,759 --> 00:05:27,759
graph vmware which uses ttm

00:05:24,880 --> 00:05:29,199
gpu drivers using gem typically will

00:05:27,759 --> 00:05:32,479
allocate

00:05:29,199 --> 00:05:34,639
buffer objects uh this is the

00:05:32,479 --> 00:05:36,240
what so what but before we go further

00:05:34,639 --> 00:05:38,639
ahead what our buffer objects buffer

00:05:36,240 --> 00:05:41,039
objects are essentially

00:05:38,639 --> 00:05:42,639
memory regions within the gpu that allow

00:05:41,039 --> 00:05:46,400
you to upload

00:05:42,639 --> 00:05:49,360
graphics data such as textures vertexes

00:05:46,400 --> 00:05:49,919
they also allow for a lot of other

00:05:49,360 --> 00:05:52,479
things but

00:05:49,919 --> 00:05:53,840
for the sake of simplicity for this talk

00:05:52,479 --> 00:05:56,479
we

00:05:53,840 --> 00:05:59,759
are just going to imagine these as

00:05:56,479 --> 00:06:02,319
memory regions where you can upload data

00:05:59,759 --> 00:06:03,280
uh releasing these buffer objects is

00:06:02,319 --> 00:06:05,360
done through

00:06:03,280 --> 00:06:06,720
eye options allocating and releasing

00:06:05,360 --> 00:06:08,639
these buffer objects is done through eye

00:06:06,720 --> 00:06:11,680
optimals and iotal is essentially

00:06:08,639 --> 00:06:12,800
a api call into the kernel with multiple

00:06:11,680 --> 00:06:15,759
parameters

00:06:12,800 --> 00:06:17,520
uh which allows interactions with kernel

00:06:15,759 --> 00:06:19,600
space drivers

00:06:17,520 --> 00:06:21,840
uh these iots also provide for

00:06:19,600 --> 00:06:25,039
submission of command streams

00:06:21,840 --> 00:06:25,680
uh command streams are essentially jobs

00:06:25,039 --> 00:06:27,759
that run

00:06:25,680 --> 00:06:30,800
on the gpu they are a full job

00:06:27,759 --> 00:06:33,600
description that get run on the gpu

00:06:30,800 --> 00:06:35,759
and one of the responsibilities of a

00:06:33,600 --> 00:06:37,520
kernel driver is to make sure that the

00:06:35,759 --> 00:06:38,720
buffer objects which contain the data

00:06:37,520 --> 00:06:40,960
required by a job

00:06:38,720 --> 00:06:41,840
are properly mapped during command

00:06:40,960 --> 00:06:44,319
stream

00:06:41,840 --> 00:06:44,319
runtime

00:06:45,840 --> 00:06:49,360
so once you've submitted your job it

00:06:48,400 --> 00:06:52,479
actually doesn't get

00:06:49,360 --> 00:06:54,880
run immediately it actually gets skewed

00:06:52,479 --> 00:06:55,919
to the gpu this is primarily because

00:06:54,880 --> 00:06:58,160
several processors

00:06:55,919 --> 00:07:00,240
might be using the gpu in parallel or

00:06:58,160 --> 00:07:03,440
the gpu resource might be busy when the

00:07:00,240 --> 00:07:06,400
resource when the request comes in

00:07:03,440 --> 00:07:08,000
uh each driver has a ioctal for command

00:07:06,400 --> 00:07:09,840
stream submission

00:07:08,000 --> 00:07:11,840
but before you can submit command

00:07:09,840 --> 00:07:14,400
streams you also need to describe

00:07:11,840 --> 00:07:16,240
their dependencies since command streams

00:07:14,400 --> 00:07:19,199
and jobs uh

00:07:16,240 --> 00:07:20,240
can depend on each other uh the user

00:07:19,199 --> 00:07:21,599
space driver

00:07:20,240 --> 00:07:23,919
knows the inter command stream

00:07:21,599 --> 00:07:25,919
dependencies and the scheduler needs to

00:07:23,919 --> 00:07:28,240
know about these constraints as well

00:07:25,919 --> 00:07:30,639
so drm provides a generic scheduling

00:07:28,240 --> 00:07:31,360
framework called drm shed which allows

00:07:30,639 --> 00:07:33,520
you to

00:07:31,360 --> 00:07:35,280
describe these dependencies in the

00:07:33,520 --> 00:07:38,720
kernel

00:07:35,280 --> 00:07:42,639
and then allows you to schedule the jobs

00:07:38,720 --> 00:07:42,639
onto the gpu in the right order

00:07:43,680 --> 00:07:47,759
so uh the next thing that we're going to

00:07:45,680 --> 00:07:51,599
talk about are user space drivers

00:07:47,759 --> 00:07:53,599
uh the rules of a user space driver are

00:07:51,599 --> 00:07:55,280
exposing one or several graphics api

00:07:53,599 --> 00:07:59,199
like we talked about earlier

00:07:55,280 --> 00:08:02,720
such as opengl opengles and balkan

00:07:59,199 --> 00:08:04,400
uh they'll they maintain the api

00:08:02,720 --> 00:08:07,120
specific state machine

00:08:04,400 --> 00:08:08,319
since as we talked about earlier the

00:08:07,120 --> 00:08:10,639
graphics pipeline

00:08:08,319 --> 00:08:11,599
is configurable we need to maintain this

00:08:10,639 --> 00:08:14,240
configuration

00:08:11,599 --> 00:08:15,759
in memory and that's what that's one of

00:08:14,240 --> 00:08:19,120
the roles of

00:08:15,759 --> 00:08:20,879
the user space driver uh they are also

00:08:19,120 --> 00:08:23,759
responsible for compiling

00:08:20,879 --> 00:08:25,840
shaders into hardware specific bytecode

00:08:23,759 --> 00:08:27,520
as well as creating populating and

00:08:25,840 --> 00:08:29,440
submitting command streams

00:08:27,520 --> 00:08:31,039
uh command streams as we just talked

00:08:29,440 --> 00:08:34,240
about uh

00:08:31,039 --> 00:08:35,680
the jobs that get run on the gpu but in

00:08:34,240 --> 00:08:38,560
their dependencies are actually

00:08:35,680 --> 00:08:41,360
specified in user space

00:08:38,560 --> 00:08:42,320
and one of the other roles of a user

00:08:41,360 --> 00:08:44,720
space driver

00:08:42,320 --> 00:08:47,519
is to interact with the windowing system

00:08:44,720 --> 00:08:50,959
this is exposed through apis such as egl

00:08:47,519 --> 00:08:54,160
as well as glx egl

00:08:50,959 --> 00:08:55,279
is used by weyland and glx is the api

00:08:54,160 --> 00:08:58,480
that's used by

00:08:55,279 --> 00:08:58,480
x11 clients

00:08:58,800 --> 00:09:11,519
everything good so far

00:09:08,240 --> 00:09:12,240
awesome uh we have a couple of

00:09:11,519 --> 00:09:16,399
approaches

00:09:12,240 --> 00:09:18,800
for for for describing graphics apis the

00:09:16,399 --> 00:09:23,600
first one being opengl

00:09:18,800 --> 00:09:26,800
uh these uh the way it works in mesa is

00:09:23,600 --> 00:09:27,519
mesa has a framework that allows you to

00:09:26,800 --> 00:09:30,640
write a

00:09:27,519 --> 00:09:32,160
driver called gallium gallium is a state

00:09:30,640 --> 00:09:35,440
tracker

00:09:32,160 --> 00:09:37,040
the way it works with gallium is that

00:09:35,440 --> 00:09:39,600
it does it takes away all the

00:09:37,040 --> 00:09:41,360
responsibility for state tracking

00:09:39,600 --> 00:09:42,800
and leaves the responsibility to

00:09:41,360 --> 00:09:45,440
interact with the kernel to

00:09:42,800 --> 00:09:47,200
the to the graphics driver uh which

00:09:45,440 --> 00:09:47,920
means that as a graphics developer you

00:09:47,200 --> 00:09:50,399
do not need

00:09:47,920 --> 00:09:51,360
to know anything about state tracking

00:09:50,399 --> 00:09:54,560
usually

00:09:51,360 --> 00:09:56,560
uh whereas with balkan vulcan has uh

00:09:54,560 --> 00:09:58,800
kronos which is the consortium that

00:09:56,560 --> 00:10:01,440
maintains these apis

00:09:58,800 --> 00:10:04,240
uh has its own driver loader and mesa

00:10:01,440 --> 00:10:06,480
just provides the vulcan drivers

00:10:04,240 --> 00:10:07,440
and the vulcan drivers are loaded by

00:10:06,480 --> 00:10:09,760
this kronos

00:10:07,440 --> 00:10:10,640
driver loader and there is no

00:10:09,760 --> 00:10:13,760
abstraction

00:10:10,640 --> 00:10:13,760
for balkan drivers

00:10:14,160 --> 00:10:17,360
uh i'm not going to be talking

00:10:15,920 --> 00:10:19,839
pre-gallium uh

00:10:17,360 --> 00:10:20,480
simply because most modern drivers in

00:10:19,839 --> 00:10:23,920
mesa

00:10:20,480 --> 00:10:26,399
will will be using gallium the gallium

00:10:23,920 --> 00:10:26,399
framework

00:10:26,640 --> 00:10:30,320
all right so let's dive into gallium a

00:10:28,560 --> 00:10:32,000
little bit essentially

00:10:30,320 --> 00:10:34,079
like i said earlier graphic three

00:10:32,000 --> 00:10:37,839
graphics are a pipeline

00:10:34,079 --> 00:10:41,120
uh functionality exposed by the kernel

00:10:37,839 --> 00:10:44,160
through eye opticals is consumed

00:10:41,120 --> 00:10:47,519
by drivers within mesa such as pantros

00:10:44,160 --> 00:10:48,880
nav fridrino intel iris

00:10:47,519 --> 00:10:51,440
uh this function this is the

00:10:48,880 --> 00:10:55,040
functionality this functionality

00:10:51,440 --> 00:10:55,920
is usually things like memory uh memory

00:10:55,040 --> 00:10:58,000
mapping

00:10:55,920 --> 00:10:59,600
as well as figuring out command stream

00:10:58,000 --> 00:11:01,600
dependencies

00:10:59,600 --> 00:11:02,880
and all this functionality is exposed

00:11:01,600 --> 00:11:06,000
through virtual functions

00:11:02,880 --> 00:11:07,920
to gallium 3d gallium 3d will call these

00:11:06,000 --> 00:11:10,800
virtual functions

00:11:07,920 --> 00:11:12,240
if they're implemented properly uh in

00:11:10,800 --> 00:11:14,160
order to

00:11:12,240 --> 00:11:16,000
and leverages these virtual functions to

00:11:14,160 --> 00:11:18,000
provide a framework

00:11:16,000 --> 00:11:19,760
that can allow you to write an opengl

00:11:18,000 --> 00:11:22,000
implementation on drop

00:11:19,760 --> 00:11:23,279
uh so the opengl implementation consumes

00:11:22,000 --> 00:11:25,360
the gallium framework

00:11:23,279 --> 00:11:26,480
which consumes the user space drivers

00:11:25,360 --> 00:11:28,320
beneath it

00:11:26,480 --> 00:11:30,000
and which consumes the kernel space

00:11:28,320 --> 00:11:34,320
driver beneath it

00:11:30,000 --> 00:11:36,320
the the use space drivers as well as the

00:11:34,320 --> 00:11:37,680
gallium framework as well as the opengl

00:11:36,320 --> 00:11:41,040
implementation are all

00:11:37,680 --> 00:11:41,040
part of mesa 3d

00:11:41,120 --> 00:11:44,800
and everything else is part of the

00:11:43,200 --> 00:11:45,279
kernel so those are the only two moving

00:11:44,800 --> 00:11:47,920
parts

00:11:45,279 --> 00:11:50,959
that that you have to keep in mind when

00:11:47,920 --> 00:11:50,959
it comes to the source code

00:11:51,440 --> 00:11:54,800
when it comes to so that was the opengl

00:11:53,760 --> 00:11:57,120
story

00:11:54,800 --> 00:11:58,639
moving on to the vulcan story like i

00:11:57,120 --> 00:12:01,200
said there is no

00:11:58,639 --> 00:12:03,279
common framework and the driver loader

00:12:01,200 --> 00:12:05,120
which will simply call

00:12:03,279 --> 00:12:06,320
the right functions the right virtual

00:12:05,120 --> 00:12:10,880
functions in

00:12:06,320 --> 00:12:14,000
the driver itself and that is it

00:12:10,880 --> 00:12:17,760
there is no state tracking functionality

00:12:14,000 --> 00:12:17,760
exposed on the bulk and side of things

00:12:18,880 --> 00:12:24,399
one of the other crucial aspects of

00:12:22,320 --> 00:12:25,760
of the user base drivers is shared

00:12:24,399 --> 00:12:27,680
recompilation

00:12:25,760 --> 00:12:29,440
uh as i said part of the part of the

00:12:27,680 --> 00:12:31,920
pipeline is programmable

00:12:29,440 --> 00:12:33,839
and compilation of these programs is a

00:12:31,920 --> 00:12:37,519
pretty crucial aspect

00:12:33,839 --> 00:12:39,120
it usually involves transformations and

00:12:37,519 --> 00:12:44,399
optimization passes

00:12:39,120 --> 00:12:46,480
uh what do i mean by that so something

00:12:44,399 --> 00:12:48,800
something like glsl will would be

00:12:46,480 --> 00:12:50,959
transformed to spurvey which is an

00:12:48,800 --> 00:12:52,800
intermediate representation

00:12:50,959 --> 00:12:54,320
which would then go through an

00:12:52,800 --> 00:12:56,800
optimization pass

00:12:54,320 --> 00:12:58,480
and then can be converted to nir which

00:12:56,800 --> 00:13:01,040
is yet another intermediate

00:12:58,480 --> 00:13:01,680
representation which will then be

00:13:01,040 --> 00:13:04,480
optimized

00:13:01,680 --> 00:13:06,240
once again before being consumed by the

00:13:04,480 --> 00:13:08,320
driver compilers

00:13:06,240 --> 00:13:11,680
uh these driver compilers will then

00:13:08,320 --> 00:13:14,399
transform either tgsi or near

00:13:11,680 --> 00:13:14,720
into one of the instructions sets that

00:13:14,399 --> 00:13:18,000
is

00:13:14,720 --> 00:13:19,360
actually understandable by the gpu that

00:13:18,000 --> 00:13:21,680
we're targeting

00:13:19,360 --> 00:13:24,959
and then optimize it once more before

00:13:21,680 --> 00:13:27,040
finally compiling it into bytecode

00:13:24,959 --> 00:13:28,160
and this pipe code is actually what gets

00:13:27,040 --> 00:13:30,639
run on the cpu

00:13:28,160 --> 00:13:32,959
at the end on the gpu at the end i'm

00:13:30,639 --> 00:13:36,399
sorry

00:13:32,959 --> 00:13:36,880
all right um so now we've submitted a

00:13:36,399 --> 00:13:40,320
job

00:13:36,880 --> 00:13:42,560
jobs run what happens next well once the

00:13:40,320 --> 00:13:45,760
job is finished on the gpu

00:13:42,560 --> 00:13:48,160
the hardware reports the job status that

00:13:45,760 --> 00:13:50,160
i'm done through an interrupt

00:13:48,160 --> 00:13:51,920
this information has been propagate has

00:13:50,160 --> 00:13:55,040
to be propagated to user space

00:13:51,920 --> 00:13:57,199
essentially to allow for synchronization

00:13:55,040 --> 00:13:59,680
between the hardware and the actual

00:13:57,199 --> 00:14:01,440
software itself this is done through the

00:13:59,680 --> 00:14:04,079
concept of fences

00:14:01,440 --> 00:14:06,720
fences are exposed as sync objects to

00:14:04,079 --> 00:14:06,720
user space

00:14:07,519 --> 00:14:12,240
and fences can be placed on buffer

00:14:09,839 --> 00:14:13,600
objects as well as command streams

00:14:12,240 --> 00:14:15,279
and the way to look at fences

00:14:13,600 --> 00:14:17,360
essentially

00:14:15,279 --> 00:14:18,959
there are two kinds of fences in fences

00:14:17,360 --> 00:14:22,560
and outfences

00:14:18,959 --> 00:14:26,560
if if my job finishes it can signal

00:14:22,560 --> 00:14:29,040
a outfence and another job can link to

00:14:26,560 --> 00:14:31,519
that arc fence as a invense

00:14:29,040 --> 00:14:34,560
and once this infants is triggered my

00:14:31,519 --> 00:14:34,560
second job can run

00:14:36,079 --> 00:14:40,399
so that's about it really that's kind of

00:14:39,839 --> 00:14:42,010
the big

00:14:40,399 --> 00:14:43,600
big picture when it comes to

00:14:42,010 --> 00:14:46,959
[Music]

00:14:43,600 --> 00:14:50,240
the next open source graphic stack

00:14:46,959 --> 00:14:52,000
the gpu topic although is quite vast if

00:14:50,240 --> 00:14:54,480
you would like to start working on this

00:14:52,000 --> 00:14:56,639
i would recommend finding a driver

00:14:54,480 --> 00:14:57,519
finding a feature that is missing a

00:14:56,639 --> 00:14:59,519
buggy

00:14:57,519 --> 00:15:02,079
and stick with it until you get it

00:14:59,519 --> 00:15:04,720
working it takes a lot of patience

00:15:02,079 --> 00:15:05,120
but fortunately enough mesa has a really

00:15:04,720 --> 00:15:07,519
good

00:15:05,120 --> 00:15:08,720
testing platform it's called piglet and

00:15:07,519 --> 00:15:10,320
dqp

00:15:08,720 --> 00:15:12,079
and if you find a test for some

00:15:10,320 --> 00:15:14,000
functionality you would almost always

00:15:12,079 --> 00:15:15,760
find a test for the functionality that's

00:15:14,000 --> 00:15:19,120
missing um

00:15:15,760 --> 00:15:19,600
and that allows you to basically do test

00:15:19,120 --> 00:15:22,079
driven

00:15:19,600 --> 00:15:22,880
development which makes your life a lot

00:15:22,079 --> 00:15:25,839
more easier

00:15:22,880 --> 00:15:28,639
in order to write new features for a

00:15:25,839 --> 00:15:28,639
photo driver

00:15:29,920 --> 00:15:32,959
i'm going to link some resources in the

00:15:31,519 --> 00:15:34,480
slides

00:15:32,959 --> 00:15:37,519
i would highly recommend you go through

00:15:34,480 --> 00:15:40,399
these and look them up

00:15:37,519 --> 00:15:41,440
and read through them since it is quite

00:15:40,399 --> 00:15:43,360
a vast topic

00:15:41,440 --> 00:15:44,959
it can feel very overwhelming in the

00:15:43,360 --> 00:15:46,639
beginning but just giving it a little

00:15:44,959 --> 00:15:48,240
bit of patience and giving it a little

00:15:46,639 --> 00:15:53,360
bit of prime

00:15:48,240 --> 00:15:53,360
really does help grasp everything

00:15:53,600 --> 00:15:57,759
and that's it does anyone else have

00:15:56,959 --> 00:16:00,000
questions

00:15:57,759 --> 00:16:01,839
uh i guess i'm done a little bit earlier

00:16:00,000 --> 00:16:03,279
than i thought i would be

00:16:01,839 --> 00:16:08,320
but does any i can take questions in the

00:16:03,279 --> 00:16:12,959
next 10 minutes

00:16:08,320 --> 00:16:16,800
thank you so much first of all boss

00:16:12,959 --> 00:16:18,880
thanks ron are there questions um

00:16:16,800 --> 00:16:21,360
i haven't seen any in the shared notes

00:16:18,880 --> 00:16:25,920
uh we can clean up there but i

00:16:21,360 --> 00:16:25,920
bet there's something in the chat um

00:16:27,440 --> 00:16:33,519
so everybody help us

00:16:31,040 --> 00:16:35,120
moderate what's uh what questions do we

00:16:33,519 --> 00:16:39,519
have for on

00:16:35,120 --> 00:16:39,519
are you still living in barcelona yes

00:16:39,600 --> 00:16:43,920
that's where we last met which was

00:16:41,120 --> 00:16:46,720
awesome yeah i'll come over again

00:16:43,920 --> 00:16:46,720
yes please do

00:16:47,040 --> 00:16:51,839
so but are there any real questions from

00:16:49,519 --> 00:16:51,839
the audience

00:16:54,959 --> 00:17:00,000
dear chad everybody has two news no so i

00:16:57,839 --> 00:17:01,680
think jonathan asked where pipefire fits

00:17:00,000 --> 00:17:05,199
into the pipeline

00:17:01,680 --> 00:17:08,799
uh i actually i i believe okay so i

00:17:05,199 --> 00:17:11,839
do not work on screen recording but

00:17:08,799 --> 00:17:14,240
my my understanding is

00:17:11,839 --> 00:17:14,959
that pipefire would interact would be a

00:17:14,240 --> 00:17:16,959
valiant

00:17:14,959 --> 00:17:18,319
protocol or that it would interact with

00:17:16,959 --> 00:17:21,120
wayland in order to do

00:17:18,319 --> 00:17:21,120
frame capture

00:17:22,959 --> 00:17:27,360
all right and uh yeah quick uh

00:17:25,600 --> 00:17:29,840
interruption commercial break

00:17:27,360 --> 00:17:31,760
after this session right away we'll have

00:17:29,840 --> 00:17:32,400
the last two working group presentations

00:17:31,760 --> 00:17:34,880
so

00:17:32,400 --> 00:17:35,440
please don't abandon us stay around it's

00:17:34,880 --> 00:17:37,520
gonna

00:17:35,440 --> 00:17:39,440
stay exciting not as exciting as the

00:17:37,520 --> 00:17:42,480
graphics bits of course

00:17:39,440 --> 00:17:46,400
but a different kind of exciting

00:17:42,480 --> 00:17:48,559
more questions

00:17:46,400 --> 00:17:50,640
feel free to send me an email as well in

00:17:48,559 --> 00:17:53,760
case in case there are questions later

00:17:50,640 --> 00:17:56,640
on or feel free to hit me up on irc

00:17:53,760 --> 00:17:57,679
uh i'd be happy to take questions there

00:17:56,640 --> 00:17:59,679
he doesn't invite

00:17:57,679 --> 00:18:01,120
uh there's something actually in the

00:17:59,679 --> 00:18:05,360
question document now

00:18:01,120 --> 00:18:08,480
what about android is that the same uh

00:18:05,360 --> 00:18:12,640
hopefully in the future yes

00:18:08,480 --> 00:18:13,039
um android has a different graphics

00:18:12,640 --> 00:18:16,799
stack

00:18:13,039 --> 00:18:18,160
overall uh but i believe there are plans

00:18:16,799 --> 00:18:20,080
to bring

00:18:18,160 --> 00:18:21,840
mesa to android in order to be able to

00:18:20,080 --> 00:18:25,039
use something like wayland

00:18:21,840 --> 00:18:25,039
on an android device

00:18:25,120 --> 00:18:29,600
all right and then the second question

00:18:27,520 --> 00:18:30,400
here we yeah we still have five minutes

00:18:29,600 --> 00:18:32,799
almost good

00:18:30,400 --> 00:18:34,799
can we get those end of presentation

00:18:32,799 --> 00:18:37,440
links in the clickable format

00:18:34,799 --> 00:18:39,280
right so that presentation was the

00:18:37,440 --> 00:18:39,679
slides were actually a little different

00:18:39,280 --> 00:18:41,840
but

00:18:39,679 --> 00:18:43,120
i do actually have i've uploaded the new

00:18:41,840 --> 00:18:46,400
slides now

00:18:43,120 --> 00:18:48,000
and at the end yes there you go

00:18:46,400 --> 00:18:51,919
i have i put them in nice clickable

00:18:48,000 --> 00:18:51,919
formats so when we upload the slides

00:18:52,320 --> 00:18:56,400
clicky clicky awesome yes um then

00:18:54,640 --> 00:18:58,240
there's a question

00:18:56,400 --> 00:19:00,559
maybe we'll start with the fourth

00:18:58,240 --> 00:19:01,440
question first uh change order drivers

00:19:00,559 --> 00:19:04,799
are they in c

00:19:01,440 --> 00:19:09,039
or c plus plus uh everything is in

00:19:04,799 --> 00:19:11,039
c all right

00:19:09,039 --> 00:19:12,960
and then uh exciting projects for the

00:19:11,039 --> 00:19:16,160
future that one is maybe

00:19:12,960 --> 00:19:19,760
burning uh longer answer

00:19:16,160 --> 00:19:19,760
maybe not uh

00:19:21,120 --> 00:19:25,440
i can't i can't think of anything that i

00:19:23,200 --> 00:19:29,120
can discuss right now

00:19:25,440 --> 00:19:29,120
the future will be boring or secret

00:19:29,440 --> 00:19:38,960

YouTube URL: https://www.youtube.com/watch?v=UvbhIre5no0


