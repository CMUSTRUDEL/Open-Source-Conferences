Title: State of the Source 2020: How (and Why) to Identify your Critical OSS Dependencies, Julia Ferraioli
Publication date: 2020-09-17
Playlist: State of the Source Summit 2020
Description: 
	How (and Why) to Identify your Critical OSS Dependencies
Julia Ferraioli

Managing open source dependencies is a reality for every company. Too often, we take open source projects for granted, even when they are crucial to our business. In this talk, youâ€™ll learn how to identify your top dependencies and how to judge where you can best deploy your resources to help them be more resilient and sustainable.

Thank you to our Video Recordings Sponsor eng@salesforce!
Full Program: https://eventyay.com/e/8fa7fd14/schedule
Captions: 
	00:00:03,520 --> 00:00:08,559
hello everyone welcome to how to identify your critical

00:00:08,559 --> 00:00:13,759
open source dependencies and why you really should do so

00:00:13,759 --> 00:00:19,840
my name is julia ferraioli and i work at the google open source programs office

00:00:19,840 --> 00:00:24,800
i recently had the occasion to dig into how we use open source software

00:00:24,800 --> 00:00:28,160
and realize that we didn't really have a good way

00:00:28,160 --> 00:00:31,359
of thinking about our open source dependencies

00:00:31,359 --> 00:00:36,559
in an analytical way this talk will share some of the thought processes

00:00:36,559 --> 00:00:41,520
and methodologies that i wound up using so that you can go back to your own

00:00:41,520 --> 00:00:47,360
companies and projects to examine your open source usage

00:00:47,360 --> 00:00:51,760
so hi again this is me i say that i've been

00:00:51,760 --> 00:00:55,440
using open source software as long as i've been using computers

00:00:55,440 --> 00:00:59,039
because well i don't predate the open source

00:00:59,039 --> 00:01:03,199
software movement all of the software i've ever used

00:01:03,199 --> 00:01:09,600
is either open source itself or is built on top of open source software

00:01:09,600 --> 00:01:13,840
i call myself an open source archaeologist

00:01:13,840 --> 00:01:17,280
not only because archaeology was my first love

00:01:17,280 --> 00:01:24,880
but also because i dig around in systems to discover how where and why

00:01:24,880 --> 00:01:30,240
open source is used i even have some digital toothbrushes and combs

00:01:30,240 --> 00:01:36,079
that i've built over the years to detect the minute traces

00:01:37,520 --> 00:01:42,240
we're here or virtually here at state of the source

00:01:42,240 --> 00:01:46,880
a conference dedicated to free and open source software

00:01:46,880 --> 00:01:51,280
some of us are here because we create it some of us use it

00:01:51,280 --> 00:01:56,560
some productionize it and some do all three

00:01:56,560 --> 00:02:02,159
open source has well not one because i don't think of it in terms of

00:02:02,159 --> 00:02:06,240
winning and losing but it's undeniable that it's become a

00:02:06,240 --> 00:02:11,200
fact of life and industry is far and wide

00:02:12,239 --> 00:02:17,200
and that's proven out by the data the new stack ran a study

00:02:17,200 --> 00:02:21,360
on open source programs offices and they came out with some

00:02:21,360 --> 00:02:26,640
interesting numbers as one might expect an overwhelming

00:02:26,640 --> 00:02:30,560
majority use open source software internally and this

00:02:30,560 --> 00:02:34,080
can mean anything from open source business applications

00:02:34,080 --> 00:02:39,280
to web servers to really anything

00:02:40,400 --> 00:02:44,480
up to 83 percent use open source and commercial project

00:02:44,480 --> 00:02:49,200
products this means that they're actively building upon open source

00:02:49,200 --> 00:02:55,040
to create services and applications from which they profit

00:02:55,519 --> 00:02:59,200
another way of looking at it came out of the linux foundation supply chain

00:02:59,200 --> 00:03:03,680
research seventy to ninety percent and that lower

00:03:03,680 --> 00:03:09,200
bound is super important so 70 to 90 percent of code for software

00:03:09,200 --> 00:03:13,680
these days is open source

00:03:13,680 --> 00:03:20,319
that means that only a small percentage of code is pulling it all together with

00:03:20,319 --> 00:03:27,360
proprietary code so yeah technology runs on open source

00:03:27,360 --> 00:03:31,920
i've linked both of the studies by the way at the bottom i highly recommend

00:03:31,920 --> 00:03:35,440
that you check them out uh there's so much more in there than is

00:03:35,440 --> 00:03:38,080
on this slide

00:03:39,280 --> 00:03:46,080
so technology runs on open source this is awesome right

00:03:46,080 --> 00:03:51,680
it's kind of a leading question we are at an open source conference we're

00:03:51,680 --> 00:03:58,720
supposed to say yes but honestly this is only mostly great

00:03:58,720 --> 00:04:02,080
that linux foundation research found that

00:04:02,080 --> 00:04:08,159
yes open source is heavily used in commercial software but they also

00:04:08,159 --> 00:04:10,879
found that companies heavily use outdated

00:04:10,879 --> 00:04:15,160
versions of open source did they use open source that's

00:04:15,160 --> 00:04:20,000
understaffed have known security vulnerabilities and

00:04:20,000 --> 00:04:29,840
other problematic practices and if you ask me that is cause for concern

00:04:31,520 --> 00:04:35,919
it just so happened that xkcd recently published

00:04:35,919 --> 00:04:41,600
in in august a comic that i just had to put into this

00:04:41,600 --> 00:04:45,759
presentation after a number of people sent it to me

00:04:45,759 --> 00:04:51,840
knowing about this presentation but i felt obligated because this

00:04:51,840 --> 00:05:00,320
is basically my open source nightmare the alt text for this comic which is

00:05:00,320 --> 00:05:07,120
a series of blocks precariously placed on top of each other saying all

00:05:07,120 --> 00:05:13,199
modern digital infrastructure says that someday image magic will

00:05:13,199 --> 00:05:16,800
finally break for good and we'll have a long period of

00:05:16,800 --> 00:05:20,400
scrambling as we try to reassemble civilization

00:05:20,400 --> 00:05:27,199
from the rubble uh image magic you power so much

00:05:29,440 --> 00:05:36,000
so when i think about our open source dependencies i really

00:05:36,000 --> 00:05:40,960
feel the need to have it to gain a deep understanding of them

00:05:40,960 --> 00:05:44,479
and i like to think of it in terms of the three

00:05:44,479 --> 00:05:52,080
s's security sustainability and stability all of those

00:05:52,080 --> 00:05:56,880
are interrelated are we picking up the latest fixes

00:05:56,880 --> 00:06:00,400
or are we potentially introducing a security vulnerability

00:06:00,400 --> 00:06:03,840
into our production systems

00:06:04,080 --> 00:06:08,479
do we choose open source software that will be around for a while

00:06:08,479 --> 00:06:12,479
and does it have a broad contributor base to ensure the longevity of the

00:06:12,479 --> 00:06:14,880
project

00:06:14,960 --> 00:06:19,280
and finally are we helping them maintain stability

00:06:19,280 --> 00:06:24,319
by upstreaming fixes as we have them

00:06:27,360 --> 00:06:31,520
but to work to the betterment of security sustainability

00:06:31,520 --> 00:06:36,720
and stability we have to better understand our open source dependencies

00:06:36,720 --> 00:06:43,039
and that's actually quite hard to do many companies perform due diligence to

00:06:43,039 --> 00:06:47,039
satisfy things like license compatibility the reporting

00:06:47,039 --> 00:06:50,479
mandates that open source licenses require

00:06:50,479 --> 00:06:54,800
and doing some variety of security scanning to ensure that we're not

00:06:54,800 --> 00:06:58,639
importing vulnerable code the requirements

00:06:58,639 --> 00:07:02,000
are here are to ensure that our production systems are

00:07:02,000 --> 00:07:08,000
stable that we're building good products and that we're not violating license

00:07:08,000 --> 00:07:14,560
terms aka not opening us up to a lawsuit

00:07:14,560 --> 00:07:22,400
but it's the bare minimum we can do more by digging a little deeper

00:07:23,840 --> 00:07:27,840
so let's take on the harder task of really understanding

00:07:27,840 --> 00:07:33,039
our open source dependencies doing so might seem like a big investment in the

00:07:33,039 --> 00:07:36,639
short term but will help us and the ecosystems that

00:07:36,639 --> 00:07:41,120
power our products over the long term

00:07:43,440 --> 00:07:48,000
the first thought i had when tackling the problem of evaluating our open

00:07:48,000 --> 00:07:52,960
source dependencies was well i'll just compile a list of the

00:07:52,960 --> 00:07:57,120
projects most used by google code

00:07:57,120 --> 00:08:00,560
you can't see me because this is a recording

00:08:00,560 --> 00:08:04,560
but i'm i'm grimacing to myself remembering this

00:08:04,560 --> 00:08:11,680
because i was so naive this is far easier said than done

00:08:11,680 --> 00:08:15,120
luckily a colleague had started down this path

00:08:15,120 --> 00:08:19,759
already and i was able to build on his work

00:08:21,280 --> 00:08:24,400
some metrics that we considered started from the most

00:08:24,400 --> 00:08:28,639
simplistic the binary have we imported the project

00:08:28,639 --> 00:08:35,360
into our internal systems or not to more complex like examining how often

00:08:35,360 --> 00:08:42,159
that project is used by proprietary code or how much cpu time is spent running

00:08:42,159 --> 00:08:47,519
open source code if you're performing this analysis with

00:08:47,519 --> 00:08:51,360
a specific goal in mind that will probably lead you down a

00:08:51,360 --> 00:08:58,959
custom path based on your needs but i did say that i was naive

00:08:58,959 --> 00:09:03,040
there are actually some pretty significant problems

00:09:03,040 --> 00:09:06,160
with these approaches

00:09:06,800 --> 00:09:12,959
the first it's rather lopsided by that i mean that if you choose to

00:09:12,959 --> 00:09:18,399
measure based on cpu usage that'll bias your analysis to projects

00:09:18,399 --> 00:09:22,720
performing heavy computations if you measure based

00:09:22,720 --> 00:09:26,160
on dependencies you'll likely see a lot of javascript

00:09:26,160 --> 00:09:30,560
projects popping up for some reason and

00:09:30,560 --> 00:09:35,200
all of these approaches will give you messy data that are distinctly

00:09:35,200 --> 00:09:38,080
one-dimensional

00:09:38,480 --> 00:09:42,720
so what do we really need we need a much more

00:09:42,720 --> 00:09:48,160
nuanced approach than approaching everything with a hammer and

00:09:48,160 --> 00:09:51,839
hoping we find a nail

00:09:53,760 --> 00:09:59,120
one thing is for certain we can't treat all open source dependencies the same

00:09:59,120 --> 00:10:03,120
or else it's like fitting a square peg in a round hole

00:10:03,120 --> 00:10:09,440
each piece of open source software has a unique shape and we can start thinking

00:10:09,440 --> 00:10:14,000
about them in broad strokes

00:10:15,600 --> 00:10:21,040
and it just so happens that some smart folks have already thought about this

00:10:21,040 --> 00:10:24,399
and i was able to crib some notes from them

00:10:24,399 --> 00:10:27,760
we can loosely categorize open source projects

00:10:27,760 --> 00:10:35,760
into these five buckets frameworks languages libraries databases

00:10:35,760 --> 00:10:41,200
and web and application servers these categories came from the roads and

00:10:41,200 --> 00:10:44,160
bridges report which i've linked at the bottom of this

00:10:44,160 --> 00:10:48,720
slide again a lot more content in there than just

00:10:48,720 --> 00:10:53,440
these categories highly recommend you check it out

00:10:56,000 --> 00:11:02,079
so if we consider these categories as separate buckets to evaluate

00:11:02,079 --> 00:11:05,600
independently then we ensure that we get a

00:11:05,600 --> 00:11:10,320
cross-section of our dependencies instead of getting

00:11:10,320 --> 00:11:16,480
one type of dependency that overshadows all others we could come up

00:11:16,480 --> 00:11:22,720
with a set of criteria that are different for each category that take

00:11:22,720 --> 00:11:25,600
into account their unique characteristics their

00:11:25,600 --> 00:11:32,880
unique shape it can be customized to

00:11:32,880 --> 00:11:38,480
what you want to dig into and once we've ranked our dependencies

00:11:38,480 --> 00:11:42,480
within a category we can keep them separate or combine

00:11:42,480 --> 00:11:47,440
them into one ultimate list i used

00:11:47,440 --> 00:11:51,760
all of these categories but you might find that you are only interested in a

00:11:51,760 --> 00:11:55,920
subset or different categories altogether

00:11:55,920 --> 00:11:59,760
there's just one thing missing now that we have a set

00:11:59,760 --> 00:12:05,519
of categories figuring out how to rank within a

00:12:05,519 --> 00:12:09,760
category so we've kind of just kicked the

00:12:09,760 --> 00:12:14,639
measurement can down the road a little bit and now we

00:12:14,639 --> 00:12:17,360
have to deal with it

00:12:19,279 --> 00:12:22,639
i wanted to work with cold hard usage data

00:12:22,639 --> 00:12:28,560
i was pretty set on that i deal better with the numbers than with

00:12:28,560 --> 00:12:34,560
qualitative factors so this was my comfort zone

00:12:34,560 --> 00:12:38,240
so since i wanted to work with data i explored

00:12:38,240 --> 00:12:41,680
what i could get i settled on a combination

00:12:41,680 --> 00:12:50,720
of cpu load and how much code depended on individual open source libraries

00:12:50,880 --> 00:12:55,200
these we had to separate out because there's code that depends on open source

00:12:55,200 --> 00:12:58,720
projects directly and there's code that depends on

00:12:58,720 --> 00:13:02,880
projects transitively code that depends on code that depends

00:13:02,880 --> 00:13:07,200
on a project you may find that there are other

00:13:07,200 --> 00:13:12,959
factors that you'd like to incorporate into your own analysis heads up

00:13:12,959 --> 00:13:17,440
this is where math comes into play

00:13:19,360 --> 00:13:25,040
i didn't want to count each factor equally

00:13:25,040 --> 00:13:30,079
first in the case of dependencies direct dependencies and indirect

00:13:30,079 --> 00:13:35,120
dependencies one includes the other

00:13:35,120 --> 00:13:40,959
and then again there then again there's also the fact that some factors are just

00:13:40,959 --> 00:13:46,079
more important than others so what i came up with was a weighting factor

00:13:46,079 --> 00:13:50,880
a weighting matrix i would rank projects within a category

00:13:50,880 --> 00:13:54,720
by each factor this would give me an integer

00:13:54,720 --> 00:13:59,199
1 through n then i'd multiply that integer

00:13:59,199 --> 00:14:04,480
by a weight which would give me a score for that factor

00:14:05,839 --> 00:14:11,600
the overall score would sum up all the scores for each factor

00:14:11,600 --> 00:14:17,519
and then we'd get a ranking for each project i'm going to make this

00:14:17,519 --> 00:14:25,040
more concrete with an example it is however an entirely contrived

00:14:25,040 --> 00:14:30,480
example i picked these three libraries

00:14:30,480 --> 00:14:34,480
out of a hat um and all of the numbers you see

00:14:34,480 --> 00:14:37,680
on the screen are completely made up it's

00:14:37,680 --> 00:14:42,839
like who's open source is it anyway the game is made up and the points don't

00:14:42,839 --> 00:14:49,040
matter so i've got four factors cpu cycles

00:14:49,040 --> 00:14:52,639
direct dependencies indirect dependencies

00:14:52,639 --> 00:14:58,880
and a wild factor to stand in for something i don't know yet and i'm going

00:14:58,880 --> 00:15:03,920
to attempt to rank ffmpeg openssl

00:15:03,920 --> 00:15:11,120
in la pac or law pack i've decided that for my analysis cpu

00:15:11,120 --> 00:15:16,480
cycles were the most important and i reflected this by giving it a 0.6

00:15:16,480 --> 00:15:20,399
weight direct dependencies are more important

00:15:20,399 --> 00:15:24,399
to me than indirect ones and the wild factor has

00:15:24,399 --> 00:15:28,320
the same weight as the indirect dependencies

00:15:28,320 --> 00:15:33,519
now we get to apply our weighting matrix to the ranks

00:15:33,600 --> 00:15:38,320
notice that the numbers on the left of the equal sign for each factor

00:15:38,320 --> 00:15:45,279
is either 1 two or three that's the library's rank for the factor

00:15:45,279 --> 00:15:49,920
now there could be ties for a rank but for clarity's sake

00:15:49,920 --> 00:15:53,360
i made it not the case here

00:15:53,600 --> 00:15:57,600
so once we have the rank per factor we multiply

00:15:57,600 --> 00:16:01,920
those numbers by the factor's weight to get its score

00:16:01,920 --> 00:16:06,639
add all of it up per library to get its total score

00:16:06,639 --> 00:16:10,079
so in this example law pack is ranked first

00:16:10,079 --> 00:16:16,399
the lowest number then ffmpeg and finally openssl

00:16:16,399 --> 00:16:22,160
this makes sense because law pack is a library for linear algebra computation

00:16:22,160 --> 00:16:26,639
and we've got a bunch of matrices that we operate on

00:16:26,639 --> 00:16:30,639
therefore it's rank for factors one through three

00:16:30,639 --> 00:16:33,519
word the top

00:16:34,839 --> 00:16:40,480
ffmpeg might look like the underdog here it looks like it's at the bottom right

00:16:40,480 --> 00:16:47,440
only twos and threes for scores but it beat out openssl for cpu cycles

00:16:47,440 --> 00:16:52,639
and we weighted that the most heavily which wound up giving it an edge over

00:16:52,639 --> 00:16:55,440
open ssl

00:16:55,680 --> 00:16:59,199
again these weights are totally customizable for whatever

00:16:59,199 --> 00:17:06,880
you want to prioritize you can make guesses at the outset and iterate

00:17:06,880 --> 00:17:12,880
based on what you see in your results it's a combination of a concrete

00:17:12,880 --> 00:17:18,880
methodology and some hefty magic numbers in there so

00:17:18,880 --> 00:17:23,199
now that we've ranked a category we can bring it all together to form

00:17:23,199 --> 00:17:26,400
a complete story

00:17:26,959 --> 00:17:31,039
if we want to form a single list of ranked dependencies

00:17:31,039 --> 00:17:37,360
we can use the same approach for ranking within a category

00:17:37,360 --> 00:17:41,919
create a new weight matrix for how heavily you want to count projects

00:17:41,919 --> 00:17:48,960
from each category this category specific weight matrix you

00:17:48,960 --> 00:17:53,360
can base it upon how important each category

00:17:53,360 --> 00:17:58,840
is to you or even the distribution of projects amongst the categories at

00:17:58,840 --> 00:18:02,559
large to ensure equal representation in the final

00:18:02,559 --> 00:18:06,400
combined ranking you can incorporate feedback

00:18:06,400 --> 00:18:10,480
at this level as well and adjust your approach over time

00:18:10,480 --> 00:18:15,600
as your priorities and usage of open source change

00:18:15,600 --> 00:18:19,840
what i like about this approach apart from involving cold hard data

00:18:19,840 --> 00:18:23,600
and matrices is that it's entirely customizable

00:18:23,600 --> 00:18:27,440
you can use different categories ones that apply to what you are looking to

00:18:27,440 --> 00:18:30,320
dig into adjust the weights both within a

00:18:30,320 --> 00:18:35,440
category and as a whole and even incorporate qualitative factors

00:18:35,440 --> 00:18:38,640
maybe you pull your product teams to get their views

00:18:38,640 --> 00:18:42,480
on what open source projects are important to them

00:18:42,480 --> 00:18:45,840
regardless of how you tweak this methodology

00:18:45,840 --> 00:18:52,000
what it enables is the best part giving back to open source once you have

00:18:52,000 --> 00:18:55,039
this list you can use it to benefit the projects

00:18:55,039 --> 00:18:58,320
that make your company go

00:19:00,480 --> 00:19:05,600
so you've got your critical open source dependencies what do you do with it

00:19:05,600 --> 00:19:09,600
i go back to the time talent and treasure model

00:19:09,600 --> 00:19:14,720
time can you or someone on your team commit time to helping one of your

00:19:14,720 --> 00:19:20,880
dependencies run smoothly talent how about lending your talents

00:19:20,880 --> 00:19:26,160
toward documentation engineering or community management

00:19:26,160 --> 00:19:31,120
treasure at the end of the day open source projects need resources

00:19:31,120 --> 00:19:37,919
aka money to run if you can give a grant funding for cloud resources

00:19:37,919 --> 00:19:42,880
and services or sponsor development time talent and

00:19:42,880 --> 00:19:46,000
treasure different ways to give back to those

00:19:46,000 --> 00:19:52,559
open source dependencies that make our innovations possible

00:19:52,559 --> 00:19:56,799
so that's the how and why of identifying your open source dependencies

00:19:56,799 --> 00:20:00,559
i highly encourage you to take a look at your own dependencies and either adapt

00:20:00,559 --> 00:20:06,240
this framework or create your own just like there's no one right way to do

00:20:06,240 --> 00:20:10,240
open source there's no one right way to define

00:20:10,240 --> 00:20:13,280
importance and then certainly not one right way to

00:20:13,280 --> 00:20:16,000
give back i hope you weren't looking for more

00:20:16,000 --> 00:20:20,400
prescriptive guidance than that it's a lot more subtle and nuanced but

00:20:20,400 --> 00:20:24,559
it also means it's a lot more customizable to you and

00:20:24,559 --> 00:20:27,200
your goals

00:20:27,520 --> 00:20:32,320
thanks y'all i have to admit this is a little bit odd for me

00:20:32,320 --> 00:20:35,360
watching and listening to my own presentation

00:20:35,360 --> 00:20:42,159
so um so i see kevin's question about

00:20:42,159 --> 00:20:45,360
if you could use this sort of thing in tide lift or

00:20:45,360 --> 00:20:53,120
open collective the weighting is absolutely 100 subjective

00:20:53,120 --> 00:20:59,679
i am going to uh own that um and it

00:20:59,679 --> 00:21:05,679
i am not necessarily sure how um tide lift or open collective

00:21:05,679 --> 00:21:09,600
would would use this i don't know kevin if you want to elaborate on that

00:21:09,600 --> 00:21:13,679
at all if you do have like a if you've automated some

00:21:13,679 --> 00:21:18,640
some sort of framework like this you'd be able to

00:21:18,640 --> 00:21:25,039
to basically generate reports for each consumer of the data

00:21:25,039 --> 00:21:28,559
yes sorry kevin it was jacob who originally asked

00:21:28,559 --> 00:21:33,280
yes and it would be a way for for a company to state these are the

00:21:33,280 --> 00:21:37,840
items that are important to us yeah absolutely um

00:21:37,840 --> 00:21:41,679
dwayne asks can i talk about any specific examples

00:21:41,679 --> 00:21:44,880
of how your methodology is informed choices or decisions

00:21:44,880 --> 00:21:47,919
that we've made within google's open source

00:21:47,919 --> 00:21:55,760
programs office one of the things that has come out of this methodology

00:21:55,760 --> 00:21:59,760
has been you know well we've been able to

00:21:59,760 --> 00:22:04,960
identify critical open source dependencies for us

00:22:04,960 --> 00:22:09,039
at google although uh with everything that google does it

00:22:09,039 --> 00:22:13,840
would benefit us to break it down even further

00:22:13,919 --> 00:22:21,120
but we use this data as a component in deciding like which

00:22:21,120 --> 00:22:29,520
events to fund um development to sponsor etc so it's inactive use and i believe

00:22:29,520 --> 00:22:37,039
um that some variety of this went into the um to how we

00:22:37,039 --> 00:22:40,400
how we tackled COVID in open source as well

00:22:40,400 --> 00:22:44,720
i'm switching back and forth between the chat and the shared notes just to make

00:22:44,720 --> 00:22:49,840
sure i'm not missing anything uh what is the next part of the work

00:22:49,840 --> 00:22:54,240
that i want to dive deeper into well i mean

00:22:54,240 --> 00:23:00,880
i think um a definite weakness in

00:23:00,880 --> 00:23:06,159
my implementation of this methodology is that i did not incorporate any

00:23:06,159 --> 00:23:11,520
qualitative factors so that um

00:23:11,520 --> 00:23:15,760
that is something that i i absolutely want to

00:23:15,760 --> 00:23:22,880
dig into a little bit more again totally out of my comfort zone um

00:23:22,880 --> 00:23:28,480
and we'd have to figure out like what questions to ask people like how do

00:23:28,480 --> 00:23:32,559
you normalize all those fun things so

00:23:32,559 --> 00:23:39,919
that's probably what i'd go to next okay so google has extensive tooling

00:23:39,919 --> 00:23:43,760
around cpu measurements for projects for companies that want to get started

00:23:43,760 --> 00:23:47,360
with that methodology don't have that kind of tooling

00:23:47,360 --> 00:23:50,480
what are some other factors you might encourage them

00:23:50,480 --> 00:23:55,760
to use uh i feel like dwayne this is a little bit of a of a

00:23:55,760 --> 00:24:01,440
leading question um from you but um

00:24:01,440 --> 00:24:09,600
going back to individual teams and and asking them

00:24:09,600 --> 00:24:17,039
what project is if it went away it would be

00:24:17,039 --> 00:24:23,919
the most kind of screwed is probably a good way to figure out

00:24:23,919 --> 00:24:27,600
which which projects are are the most important to your individual product

00:24:27,600 --> 00:24:30,000
teams

00:24:31,200 --> 00:24:36,559
i'm sure others have additional ideas

00:24:37,279 --> 00:24:43,760
so i i am not the feel and all for figuring out those factors um i am

00:24:43,760 --> 00:24:47,760
limited by my own brain so how do you take into account

00:24:47,760 --> 00:24:51,760
dependencies that may take fewer cpu cycles but be

00:24:51,760 --> 00:24:56,880
critical nonetheless um this is where

00:24:56,880 --> 00:25:03,919
how i compensated for for that was with doing

00:25:03,919 --> 00:25:11,760
transitive and direct dependencies um and that was ex expressly because

00:25:11,760 --> 00:25:18,559
of of projects that don't take many cpu cycles um

00:25:18,559 --> 00:25:25,360
but were used by a large portion of projects josh had

00:25:25,360 --> 00:25:29,840
mentioned it feels like replaceability

00:25:30,000 --> 00:25:37,279
to be awake could be a waiting factor yeah i i definitely agree with that

00:25:37,279 --> 00:25:40,080
could um

00:25:40,559 --> 00:25:45,279
and i feel like there are a couple of different angles that one could take

00:25:45,279 --> 00:25:52,080
on the replaceability idea um like could we easily replace this

00:25:52,080 --> 00:25:58,559
with another open source product project um

00:25:58,559 --> 00:26:02,080
with like dare i say the words with proprietary

00:26:02,080 --> 00:26:05,440
code there are all different angles that you could take

00:26:05,440 --> 00:26:12,080
on on that particular factor and i think that puts us

00:26:12,080 --> 00:26:16,159
to time thank you so much julia and thank you everyone for your

00:26:16,159 --> 00:26:20,799
patience and your determination in getting into the session we appreciate

00:26:20,799 --> 00:26:25,840

YouTube URL: https://www.youtube.com/watch?v=gfzWQUDyLAI


