Title: PHP UK Conference 2014 - Julien Pauli - PHP Opcache Explained
Publication date: 2014-03-21
Playlist: PHP UK Conference 2014
Description: 
	OPCache is PHP's default OPCode cache mechanism, which has been introduced with PHP5.5. You can use it for 5.3, 5.4 or 5.5. This talk will detail how OPCache works, what it does to PHP and how to set it up so that you can deal with maximum performance and stability. We'll recall how PHP works, how its engine works, and how OPCache interacts with this complex machine to effectively accelerate it. You'll know everything about OPCache at the end of this talk.
Captions: 
	00:00:05,779 --> 00:00:14,309
okay so hello everybody this talk will

00:00:10,110 --> 00:00:15,660
be about the new ph p 0 p cash you

00:00:14,309 --> 00:00:18,210
should know about this because i guess

00:00:15,660 --> 00:00:22,380
you read the news and your twitter and

00:00:18,210 --> 00:00:25,199
things like that so first of all i'm

00:00:22,380 --> 00:00:28,109
julian i'm working for since your labs

00:00:25,199 --> 00:00:30,869
in Paris I'm French so apologize for my

00:00:28,109 --> 00:00:32,399
English weddings sometimes missing or

00:00:30,869 --> 00:00:34,829
things like that but I guess your

00:00:32,399 --> 00:00:37,620
understand my talk anyway so I've been

00:00:34,829 --> 00:00:40,110
programming in PHP for now more than 10

00:00:37,620 --> 00:00:41,969
years something like that and I wanted

00:00:40,110 --> 00:00:43,530
to give back to open source what open

00:00:41,969 --> 00:00:46,710
source gave to me because I think this

00:00:43,530 --> 00:00:48,660
is the challenge so now I'm PHP internal

00:00:46,710 --> 00:00:51,980
review and developers I'm trying to make

00:00:48,660 --> 00:00:56,699
HP better every day even if it's not

00:00:51,980 --> 00:00:58,890
pretty easy I'm 50 55 and 56 release

00:00:56,699 --> 00:01:00,600
manager and we are talking about PHP 6

00:00:58,890 --> 00:01:05,820
actually on mailing list more to come

00:01:00,600 --> 00:01:09,270
later about this I took I wanted to

00:01:05,820 --> 00:01:11,880
document the the PHP internals code

00:01:09,270 --> 00:01:13,950
because PHP internals code which is C

00:01:11,880 --> 00:01:17,700
code has no documentation at all oh

00:01:13,950 --> 00:01:20,430
pretty tiny one so I'm actually writing

00:01:17,700 --> 00:01:24,090
PHP internals book calm together with

00:01:20,430 --> 00:01:27,030
other PHP contributor to try to make

00:01:24,090 --> 00:01:29,520
people know how PHP works internally and

00:01:27,030 --> 00:01:32,189
things like that so this is a free book

00:01:29,520 --> 00:01:37,250
actually you can go on the URL and fetch

00:01:32,189 --> 00:01:40,979
it if you want what will cover together

00:01:37,250 --> 00:01:43,079
we will remind you how PHP works

00:01:40,979 --> 00:01:46,950
internally so perhaps some of you have

00:01:43,079 --> 00:01:50,430
attended Davis talked this morning just

00:01:46,950 --> 00:01:53,909
before lunch so pretty things in common

00:01:50,430 --> 00:01:56,969
with my talk anyway we're going to talk

00:01:53,909 --> 00:02:00,240
and focus on Appa codes and the need to

00:01:56,969 --> 00:02:03,210
have an Okie code cache what the

00:02:00,240 --> 00:02:06,439
solutions we had before yes a pc and

00:02:03,210 --> 00:02:09,450
things like that what we have now OPH

00:02:06,439 --> 00:02:11,670
what's the difference between them from

00:02:09,450 --> 00:02:13,950
a developer point of view and from

00:02:11,670 --> 00:02:15,240
a system administrator point of view

00:02:13,950 --> 00:02:17,430
what you should do when you put co2

00:02:15,240 --> 00:02:19,980
prediction with application what you

00:02:17,430 --> 00:02:23,010
should not do are proven to do and how

00:02:19,980 --> 00:02:25,590
you can configure it for prediction so

00:02:23,010 --> 00:02:28,489
we will review the configuration

00:02:25,590 --> 00:02:30,660
settings and how to set them up and

00:02:28,489 --> 00:02:34,459
benchmarks I don't have benchmarks

00:02:30,660 --> 00:02:39,390
actually so why is this wording here no

00:02:34,459 --> 00:02:42,269
Appa Cassius has been a zend internal

00:02:39,390 --> 00:02:45,600
project for four years and they recently

00:02:42,269 --> 00:02:48,690
opened sourced it and gave it to the PHP

00:02:45,600 --> 00:02:51,360
community and they give it to PHP so we

00:02:48,690 --> 00:02:55,140
merged it in PHP pfeiffer so it's a very

00:02:51,360 --> 00:02:57,480
very old product which means it's been

00:02:55,140 --> 00:03:00,330
developed with lots of experience so

00:02:57,480 --> 00:03:03,650
it's now adays pretty stable okay it's

00:03:00,330 --> 00:03:06,150
pretty nice product so Zen the HUD

00:03:03,650 --> 00:03:08,549
benchmark they still have benchmarks you

00:03:06,150 --> 00:03:11,910
can find on the web anyway benchmarks

00:03:08,549 --> 00:03:15,390
are just about hero world sometimes so

00:03:11,910 --> 00:03:18,769
it's not really relevant but anyway you

00:03:15,390 --> 00:03:22,350
can you can find some on the web so

00:03:18,769 --> 00:03:25,170
first of all what is PHP so you know PHP

00:03:22,350 --> 00:03:27,209
PHP it's a scripting language so you can

00:03:25,170 --> 00:03:30,720
read this everywhere so what's a

00:03:27,209 --> 00:03:33,660
scripting language first it's a language

00:03:30,720 --> 00:03:37,230
where which does not require you to

00:03:33,660 --> 00:03:39,930
compile it it compiles itself okay it

00:03:37,230 --> 00:03:42,120
compels its own code to an intermediate

00:03:39,930 --> 00:03:44,459
byte code and the byte code is executed

00:03:42,120 --> 00:03:48,540
later but the virtual machine we'll talk

00:03:44,459 --> 00:03:51,900
about this later letter slides highly

00:03:48,540 --> 00:03:54,120
dynamic highly extensible the first term

00:03:51,900 --> 00:03:58,170
is really important is that PHP is

00:03:54,120 --> 00:04:01,200
highly dynamic you can create classes on

00:03:58,170 --> 00:04:04,049
the fly which is something when would

00:04:01,200 --> 00:04:07,579
you try to optimize the opcode down in

00:04:04,049 --> 00:04:11,010
the low level this is pretty hard and

00:04:07,579 --> 00:04:14,160
you have no typing about your variable

00:04:11,010 --> 00:04:17,280
so when we compile the code we cannot

00:04:14,160 --> 00:04:19,410
really guess what type you are using so

00:04:17,280 --> 00:04:20,400
that we can make optimization internally

00:04:19,410 --> 00:04:24,060
so open

00:04:20,400 --> 00:04:26,759
code o P cash is something which tries

00:04:24,060 --> 00:04:30,360
to optimize your code and and it's a it

00:04:26,759 --> 00:04:33,180
gives some trade off its I assume you're

00:04:30,360 --> 00:04:34,800
doing this but I should really be sure

00:04:33,180 --> 00:04:36,990
because if I optimize something wrong

00:04:34,800 --> 00:04:40,050
then your code will just not run and not

00:04:36,990 --> 00:04:42,509
do what you what you want so this is a

00:04:40,050 --> 00:04:44,580
this is nice for PHP to be highly

00:04:42,509 --> 00:04:47,520
dynamic but this is pretty pretty hard

00:04:44,580 --> 00:04:49,169
internally to to handle this in the

00:04:47,520 --> 00:04:51,750
engine because everything can be

00:04:49,169 --> 00:04:55,110
everything at every time so that's

00:04:51,750 --> 00:04:58,169
pretty hard to to optimize a internally

00:04:55,110 --> 00:05:01,860
so how does PHP work you should know now

00:04:58,169 --> 00:05:04,979
that PHP code first comes into a past

00:05:01,860 --> 00:05:09,389
face the past phases can be split up

00:05:04,979 --> 00:05:11,580
into two little phases which is a lexing

00:05:09,389 --> 00:05:15,360
and parsing okay we talk about this

00:05:11,580 --> 00:05:18,930
later then from the parser you you get

00:05:15,360 --> 00:05:23,070
nodes and those nodes are given in

00:05:18,930 --> 00:05:24,990
compiler which generates opie codes and

00:05:23,070 --> 00:05:27,510
the opie codes are then passed to the

00:05:24,990 --> 00:05:29,430
upper layer which is the the virtual

00:05:27,510 --> 00:05:30,810
machine executors and the virtual

00:05:29,430 --> 00:05:33,750
machine executor is going to execute

00:05:30,810 --> 00:05:36,180
these these op codes and give you a

00:05:33,750 --> 00:05:40,320
result which is usually something which

00:05:36,180 --> 00:05:44,159
is printed understand that output this

00:05:40,320 --> 00:05:47,310
is the main the main PHP are how PHP

00:05:44,159 --> 00:05:50,669
works mainly so this is pretty pretty

00:05:47,310 --> 00:05:53,130
long definition of what is a virtual

00:05:50,669 --> 00:05:55,740
machine I'm meaning a software between

00:05:53,130 --> 00:05:57,780
machine okay not what not talking at all

00:05:55,740 --> 00:06:00,539
about virtualization of the hardware

00:05:57,780 --> 00:06:03,630
it's not the point here so a virtual

00:06:00,539 --> 00:06:05,940
machine is just a system over the system

00:06:03,630 --> 00:06:07,919
which tries to run over many many

00:06:05,940 --> 00:06:09,690
different hardware's and many many

00:06:07,919 --> 00:06:11,490
different platforms and operating

00:06:09,690 --> 00:06:14,130
systems because operating systems are

00:06:11,490 --> 00:06:17,190
very different from each other should

00:06:14,130 --> 00:06:19,440
take Microsoft ones and and uniques just

00:06:17,190 --> 00:06:23,159
those two bigs they are very very

00:06:19,440 --> 00:06:26,460
different and PHP has to run the same

00:06:23,159 --> 00:06:29,849
way on those systems which is a day to

00:06:26,460 --> 00:06:31,289
day challenge for us developers into PHP

00:06:29,849 --> 00:06:33,400
because we have to support lots of

00:06:31,289 --> 00:06:37,120
platforms so

00:06:33,400 --> 00:06:41,710
that's exactly the same as every

00:06:37,120 --> 00:06:44,590
scripting language so Python Ruby we can

00:06:41,710 --> 00:06:48,009
even talk about Java they work the same

00:06:44,590 --> 00:06:50,080
way PHP works okay there are little

00:06:48,009 --> 00:06:53,080
things which are different I mean I mean

00:06:50,080 --> 00:06:55,960
in Java you compile yourself your code

00:06:53,080 --> 00:06:58,000
you just don't run code and then Java is

00:06:55,960 --> 00:07:01,410
going to compile it for you but it's

00:06:58,000 --> 00:07:05,410
exactly the same internally they all

00:07:01,410 --> 00:07:09,460
they they only use heavily what is

00:07:05,410 --> 00:07:12,130
called a virtual machine ok so the PHP

00:07:09,460 --> 00:07:14,229
way is compiled execute forget compile

00:07:12,130 --> 00:07:16,210
execute forget you know about this so

00:07:14,229 --> 00:07:18,370
when the request comes in PHP its

00:07:16,210 --> 00:07:20,080
treated so PHP is going to compile

00:07:18,370 --> 00:07:22,990
execute and stuff like that and then

00:07:20,080 --> 00:07:26,830
it's going to forget everything every

00:07:22,990 --> 00:07:29,320
class is it met every variables every

00:07:26,830 --> 00:07:32,380
file you open every resources it's going

00:07:29,320 --> 00:07:35,620
to throw all this away free memory and

00:07:32,380 --> 00:07:37,710
just get ready for the next request so

00:07:35,620 --> 00:07:40,479
the next request does know anything

00:07:37,710 --> 00:07:43,599
about the previous request and this is

00:07:40,479 --> 00:07:47,380
why PHP scales very very nicely because

00:07:43,599 --> 00:07:50,020
you just have to to multiply the PHP

00:07:47,380 --> 00:07:52,000
workers and then there is no context

00:07:50,020 --> 00:07:56,110
there is no server context like in Java

00:07:52,000 --> 00:07:58,330
and this can be a drawback but this can

00:07:56,110 --> 00:08:02,680
be as well an advantage so we take it as

00:07:58,330 --> 00:08:05,560
an advantage here so we pass the code we

00:08:02,680 --> 00:08:09,400
compile the code and then we execute the

00:08:05,560 --> 00:08:12,789
code but what happens and we we throw

00:08:09,400 --> 00:08:14,530
away all we've done so far for the next

00:08:12,789 --> 00:08:19,210
request so what happens when you you

00:08:14,530 --> 00:08:23,260
want to run the same file twice or

00:08:19,210 --> 00:08:26,770
several times where PHP will steal again

00:08:23,260 --> 00:08:29,169
a pass and compile your script before

00:08:26,770 --> 00:08:32,349
executing it so the problem is that if

00:08:29,169 --> 00:08:35,830
your script have not changed between two

00:08:32,349 --> 00:08:39,130
requests which is much likely the

00:08:35,830 --> 00:08:40,450
scenario then you're going to pass and

00:08:39,130 --> 00:08:42,370
you're going to compile your code again

00:08:40,450 --> 00:08:44,169
and again and again and passing and

00:08:42,370 --> 00:08:46,150
compelling can really really take time

00:08:44,169 --> 00:08:50,980
this is why we

00:08:46,150 --> 00:08:53,680
oph so usually I expect I hope that

00:08:50,980 --> 00:08:56,470
executes time is much higher than

00:08:53,680 --> 00:08:59,350
compile time okay but it can happen that

00:08:56,470 --> 00:09:02,410
in compile time can be very very hard

00:08:59,350 --> 00:09:04,690
very very heavy because when we compile

00:09:02,410 --> 00:09:07,360
the code we do lots of things lots of

00:09:04,690 --> 00:09:09,130
big things just don't care about at this

00:09:07,360 --> 00:09:12,490
stage we just don't care about CPU

00:09:09,130 --> 00:09:14,740
cycles and memory we just do all we can

00:09:12,490 --> 00:09:16,750
do so that we will have an execution

00:09:14,740 --> 00:09:19,870
phase which is as Tiny as possible in

00:09:16,750 --> 00:09:23,710
response time okay so when you compile a

00:09:19,870 --> 00:09:25,960
PHP script it actually can take much

00:09:23,710 --> 00:09:29,350
much time this is an example whether I

00:09:25,960 --> 00:09:32,470
dumped the times in the engine and on

00:09:29,350 --> 00:09:35,920
this one while executing a script we can

00:09:32,470 --> 00:09:40,210
see here this is an example like many to

00:09:35,920 --> 00:09:42,460
come it took about a quarter of the time

00:09:40,210 --> 00:09:46,150
to compile the file and the three other

00:09:42,460 --> 00:09:54,040
quarter's to execute it okay so this is

00:09:46,150 --> 00:09:58,690
not a transparent this is not the the

00:09:54,040 --> 00:10:01,330
compile time can really really put your

00:09:58,690 --> 00:10:03,460
server down because you compile many

00:10:01,330 --> 00:10:06,280
files and many things like that and when

00:10:03,460 --> 00:10:09,370
you when you pass the code you execute

00:10:06,280 --> 00:10:13,500
lots of functions in C and things like

00:10:09,370 --> 00:10:16,510
that which can really take much time so

00:10:13,500 --> 00:10:20,230
what you want to do is that you want to

00:10:16,510 --> 00:10:23,380
prevent a PHP from passing again and

00:10:20,230 --> 00:10:26,950
again and again same files okay so you

00:10:23,380 --> 00:10:30,580
will use what we call a no cash and an

00:10:26,950 --> 00:10:34,900
OPA cod cash and when PHP is run with an

00:10:30,580 --> 00:10:37,780
OPA cod cash it is really really really

00:10:34,900 --> 00:10:40,450
similar to java at this time because it

00:10:37,780 --> 00:10:44,320
just does not compile code anymore all

00:10:40,450 --> 00:10:47,470
is in memory or is executed again and

00:10:44,320 --> 00:10:54,410
again which is something very similar

00:10:47,470 --> 00:10:57,630
with with Java so that's the point so

00:10:54,410 --> 00:11:01,230
when classes are are interesting because

00:10:57,630 --> 00:11:04,200
when PHP when you you you you run a file

00:11:01,230 --> 00:11:08,329
which just declares a class you will

00:11:04,200 --> 00:11:11,279
compile a class and you will execute

00:11:08,329 --> 00:11:14,550
nothing because the clear in class if

00:11:11,279 --> 00:11:17,370
you don't create an object or use it you

00:11:14,550 --> 00:11:21,360
will you will have a very high compile

00:11:17,370 --> 00:11:23,970
time but a sero execution time and then

00:11:21,360 --> 00:11:26,100
PHP will flow where all the opcodes from

00:11:23,970 --> 00:11:29,700
the class and then pass it again at the

00:11:26,100 --> 00:11:31,320
net and at the next request so when when

00:11:29,700 --> 00:11:33,470
you don't choose an object code cache so

00:11:31,320 --> 00:11:37,790
that's important and whenever you use

00:11:33,470 --> 00:11:43,769
include require evil or the auto load

00:11:37,790 --> 00:11:47,579
you just defer a compile while executing

00:11:43,769 --> 00:11:50,459
this means that when PHP a pass is a

00:11:47,579 --> 00:11:52,470
file it just passes it it trans sensual

00:11:50,459 --> 00:11:54,480
code and then it executes sit and when

00:11:52,470 --> 00:11:57,660
it has to execute an Opie code which

00:11:54,480 --> 00:12:00,589
says all include this file it just stops

00:11:57,660 --> 00:12:03,630
the current execution and run again

00:12:00,589 --> 00:12:05,880
compiling the file you just included and

00:12:03,630 --> 00:12:08,579
then execute it and this file probably

00:12:05,880 --> 00:12:11,100
has other include inside so throw this

00:12:08,579 --> 00:12:13,709
on the stack away and then get the next

00:12:11,100 --> 00:12:15,720
file compile it executes it no more

00:12:13,709 --> 00:12:18,449
include no more evil normal auto road

00:12:15,720 --> 00:12:20,730
okay let's go back to resuming what we

00:12:18,449 --> 00:12:26,100
were doing before okay this is pretty

00:12:20,730 --> 00:12:28,410
different from a compiled language we're

00:12:26,100 --> 00:12:31,890
at compile time everything is checked

00:12:28,410 --> 00:12:33,930
okay this is not the case with includin

00:12:31,890 --> 00:12:36,269
require for example because if the file

00:12:33,930 --> 00:12:38,910
does not exist to you will hit an error

00:12:36,269 --> 00:12:42,930
at runtime and not a compile-time okay

00:12:38,910 --> 00:12:45,660
this is how PHP has been designed lots

00:12:42,930 --> 00:12:48,660
of years ago now so this is how it

00:12:45,660 --> 00:12:51,690
actually works so what can we do when we

00:12:48,660 --> 00:12:55,470
pass compile and execute is that we can

00:12:51,690 --> 00:12:59,100
actually try to cash the opie codes

00:12:55,470 --> 00:13:01,829
which are given from the passing of a

00:12:59,100 --> 00:13:04,490
single file out of string when you use

00:13:01,829 --> 00:13:07,459
evil and

00:13:04,490 --> 00:13:10,910
we can cash this cash these two shared

00:13:07,459 --> 00:13:13,250
memory okay so that later on when

00:13:10,910 --> 00:13:18,140
another process of the same pool will

00:13:13,250 --> 00:13:21,080
require the same file we just load the

00:13:18,140 --> 00:13:23,089
opcodes from the shared memory if the

00:13:21,080 --> 00:13:24,980
file has not changed and I guess in

00:13:23,089 --> 00:13:28,190
production until you deploy you don't

00:13:24,980 --> 00:13:31,700
change files many often on production

00:13:28,190 --> 00:13:35,300
servers so we just read the opcode back

00:13:31,700 --> 00:13:37,190
from the shared memory and we just feed

00:13:35,300 --> 00:13:39,760
the virtual machine with those Opie

00:13:37,190 --> 00:13:43,490
codes and all the passing time and the

00:13:39,760 --> 00:13:45,950
optimization time has been prevented and

00:13:43,490 --> 00:13:51,170
then you have a PHP which is a pretty

00:13:45,950 --> 00:13:54,200
pretty speedy and you can expect to have

00:13:51,170 --> 00:13:56,899
to be able to handle tons of requests

00:13:54,200 --> 00:13:59,870
per seconds because at least on the

00:13:56,899 --> 00:14:03,140
latest versions of PHP it's pretty

00:13:59,870 --> 00:14:05,600
pretty well optimized and nowadays has

00:14:03,140 --> 00:14:08,660
nothing to do with what we're peach give

00:14:05,600 --> 00:14:13,640
free and PHP for has very very evolved

00:14:08,660 --> 00:14:17,120
in a very nice way okay so what we can

00:14:13,640 --> 00:14:18,860
do as well and this is what application

00:14:17,120 --> 00:14:20,899
does in which this is what is

00:14:18,860 --> 00:14:25,839
interesting and this is what I've been

00:14:20,899 --> 00:14:28,990
working on is you have Appa codes and

00:14:25,839 --> 00:14:31,790
before cashing them what you can do is

00:14:28,990 --> 00:14:35,240
rent functions which will try to

00:14:31,790 --> 00:14:39,140
optimize the tree of the op codes for

00:14:35,240 --> 00:14:42,529
example if you have an if false all the

00:14:39,140 --> 00:14:44,930
OPA codes from the force branch will

00:14:42,529 --> 00:14:48,529
never be run so you can just throw them

00:14:44,930 --> 00:14:50,779
away and have a smaller Oh pickled array

00:14:48,529 --> 00:14:53,839
so you have a smaller memory footprint

00:14:50,779 --> 00:14:57,740
when you run PHP this is an example and

00:14:53,839 --> 00:15:01,190
you have lots of them while using an

00:14:57,740 --> 00:15:04,940
optimizer so opk she comes by default

00:15:01,190 --> 00:15:08,660
you have nothing to do with an optimizer

00:15:04,940 --> 00:15:13,640
and what atc does not actually a pc is

00:15:08,660 --> 00:15:18,620
just this is to be taken care of this is

00:15:13,640 --> 00:15:21,710
just an avocado cash Opie Opie cage is

00:15:18,620 --> 00:15:24,800
together an opioid cash together with an

00:15:21,710 --> 00:15:28,730
optimizer and the optimizer does many

00:15:24,800 --> 00:15:34,540
many nice things for your code I will

00:15:28,730 --> 00:15:37,570
show you later so let's now

00:15:34,540 --> 00:15:42,950
unfortunately if I can say explain what

00:15:37,570 --> 00:15:47,540
opcodes op codes are so again Wikipedia

00:15:42,950 --> 00:15:52,430
is very nice so oh because are just what

00:15:47,540 --> 00:15:56,150
is what is given the virtual machines so

00:15:52,430 --> 00:15:58,880
that it can actually execute them so you

00:15:56,150 --> 00:16:03,140
can have Appa codes like ad which is

00:15:58,880 --> 00:16:05,600
just having an plus an odd function you

00:16:03,140 --> 00:16:07,820
can have Appa code if you use the point

00:16:05,600 --> 00:16:10,850
you it will the compiler will generate

00:16:07,820 --> 00:16:14,780
an apricot which is called concat okay

00:16:10,850 --> 00:16:17,300
which takes to appear and or p1 and p2

00:16:14,780 --> 00:16:20,060
and gives a result which is just that

00:16:17,300 --> 00:16:23,600
the concatenation which is pretty easy

00:16:20,060 --> 00:16:25,520
to do in seeds just a mem copy if you

00:16:23,600 --> 00:16:27,170
have strings if you don't have strings

00:16:25,520 --> 00:16:29,090
then PHP and the better machine is going

00:16:27,170 --> 00:16:31,190
to translate them to strings and then

00:16:29,090 --> 00:16:35,150
just mem copy and then give this raizle

00:16:31,190 --> 00:16:36,980
to the stew to the line after so you

00:16:35,150 --> 00:16:41,240
have lots of opticals actually we have

00:16:36,980 --> 00:16:43,160
more than 100 we have many of them so

00:16:41,240 --> 00:16:45,320
everything you do when you call a

00:16:43,160 --> 00:16:47,839
function when you do any if you generate

00:16:45,320 --> 00:16:50,510
each time you generate an OPA code and

00:16:47,839 --> 00:16:52,850
if is just something which will evaluate

00:16:50,510 --> 00:16:56,330
an expression and if the expression is

00:16:52,850 --> 00:16:59,390
true or false it will generate a jump if

00:16:56,330 --> 00:17:01,640
0 so if the result is 0 it will jump to

00:16:59,390 --> 00:17:03,500
another opcode if it's not 0 it will

00:17:01,640 --> 00:17:06,199
jump to another one and you have an if

00:17:03,500 --> 00:17:10,880
structure which is pretty pretty easy to

00:17:06,199 --> 00:17:16,350
do ok so this is actually a opcodes in

00:17:10,880 --> 00:17:18,689
PHP 5.4 and they are the same in 55

00:17:16,350 --> 00:17:21,740
I don't know about 56 but I think they

00:17:18,689 --> 00:17:25,850
are the same as well and they have been

00:17:21,740 --> 00:17:29,490
many times they have been rewritten and

00:17:25,850 --> 00:17:34,440
you don't know this when you use PHP but

00:17:29,490 --> 00:17:37,350
for example from 5 325 for all this has

00:17:34,440 --> 00:17:41,700
changed this means that those structures

00:17:37,350 --> 00:17:45,120
are absolutely invalid for php5 free and

00:17:41,700 --> 00:17:46,620
less this is starting from 54 this is

00:17:45,120 --> 00:17:48,960
why when you want to use the end

00:17:46,620 --> 00:17:51,809
extensions and extensions which actually

00:17:48,960 --> 00:17:54,360
play with opcodes you have to recompile

00:17:51,809 --> 00:17:57,000
them and you have to patch them to take

00:17:54,360 --> 00:17:59,669
care of the new opiod structures so as

00:17:57,000 --> 00:18:02,010
you can see this is like a calculator

00:17:59,669 --> 00:18:05,610
you know you have 0 p 1 and 0 pee too

00:18:02,010 --> 00:18:08,250
okay you have a handler okay the handler

00:18:05,610 --> 00:18:11,520
is actually the function which will be

00:18:08,250 --> 00:18:15,780
executed with 0 p 1 and 0 pee too and it

00:18:11,520 --> 00:18:18,390
will give a result and probably it could

00:18:15,780 --> 00:18:20,250
need an extended values then it value is

00:18:18,390 --> 00:18:23,100
something like the carry you know when

00:18:20,250 --> 00:18:26,280
you add two numbers you multiply them

00:18:23,100 --> 00:18:29,549
you can have a carry so this will be put

00:18:26,280 --> 00:18:34,640
in actually excellent value and then the

00:18:29,549 --> 00:18:38,250
types and the nodes so actually the

00:18:34,640 --> 00:18:40,890
upper end and the result are nodes and

00:18:38,250 --> 00:18:43,830
nodes can be constant variables numbers

00:18:40,890 --> 00:18:47,730
hashes or jump address which was used

00:18:43,830 --> 00:18:50,280
when you talk about if while switch and

00:18:47,730 --> 00:18:52,620
things like that okay so this is C code

00:18:50,280 --> 00:18:56,909
and that's it that's how it works

00:18:52,620 --> 00:19:00,390
actually so let's see examples of a pea

00:18:56,909 --> 00:19:04,260
coat and let's see how opie cash can

00:19:00,390 --> 00:19:07,049
interact with that and optimize that in

00:19:04,260 --> 00:19:10,110
a pretty nice way so this is a silly

00:19:07,049 --> 00:19:12,840
example like you you you every time you

00:19:10,110 --> 00:19:15,330
see conferences because we have to fit

00:19:12,840 --> 00:19:17,700
the slide okay and you have to

00:19:15,330 --> 00:19:23,280
understand it and actually this

00:19:17,700 --> 00:19:27,600
generates something like Opie opticals

00:19:23,280 --> 00:19:28,390
can be about three times heavier in in

00:19:27,600 --> 00:19:31,090
long the

00:19:28,390 --> 00:19:35,170
the corresponding PHP code okay so I

00:19:31,090 --> 00:19:37,660
have to design my slides to take care of

00:19:35,170 --> 00:19:40,660
this parameter as well so and this is an

00:19:37,660 --> 00:19:44,560
example of a PHP code which when you

00:19:40,660 --> 00:19:49,330
compile it you will have something which

00:19:44,560 --> 00:19:52,420
will look like this this is this has

00:19:49,330 --> 00:19:56,650
been dumped with v LD in console mode

00:19:52,420 --> 00:19:59,560
this is why it's written in it is a

00:19:56,650 --> 00:20:02,440
screenshot of the console we have

00:19:59,560 --> 00:20:04,960
another extension which can represent

00:20:02,440 --> 00:20:07,060
this in pretty nice HTML with Java

00:20:04,960 --> 00:20:10,240
scripts and you can hover with your

00:20:07,060 --> 00:20:13,500
mouse and it will pop up things this is

00:20:10,240 --> 00:20:17,530
called explain if you want to know so I

00:20:13,500 --> 00:20:20,590
under colored the corresponding things

00:20:17,530 --> 00:20:23,880
in Opie okay so if you look at the

00:20:20,590 --> 00:20:26,710
asset's tractor is set is not a function

00:20:23,880 --> 00:20:28,960
okay because if it would have been a

00:20:26,710 --> 00:20:31,420
function it would be something like do

00:20:28,960 --> 00:20:35,440
function call prepare function call is

00:20:31,420 --> 00:20:37,720
set is a special handler okay it gets

00:20:35,440 --> 00:20:41,100
compiled to something which is not

00:20:37,720 --> 00:20:43,990
called the function is set but do this

00:20:41,100 --> 00:20:48,160
specific code which is hidden behind a

00:20:43,990 --> 00:20:50,770
set isn't ed mob so we set a season t so

00:20:48,160 --> 00:20:53,230
you will have guessed that you use empty

00:20:50,770 --> 00:20:56,560
or reset it's exactly the same in the

00:20:53,230 --> 00:20:59,610
under under layer in the engine it leads

00:20:56,560 --> 00:21:01,900
to the same of code so this is actually

00:20:59,610 --> 00:21:04,990
the opcode in the handler which is used

00:21:01,900 --> 00:21:06,910
the parameters the return value and we

00:21:04,990 --> 00:21:09,760
have something which is called extended

00:21:06,910 --> 00:21:13,330
value because is it and is set or an is

00:21:09,760 --> 00:21:15,400
empty how can we know at this time we

00:21:13,330 --> 00:21:17,410
put something which is a flag in

00:21:15,400 --> 00:21:21,220
extended value and we just have an if

00:21:17,410 --> 00:21:25,360
which tells us if it was any meteorite

00:21:21,220 --> 00:21:27,400
is set okay so you have to appearance

00:21:25,360 --> 00:21:29,900
and it gives a result and the result and

00:21:27,400 --> 00:21:33,530
the result usually is you

00:21:29,900 --> 00:21:35,420
as a parameter for the same for the next

00:21:33,530 --> 00:21:40,160
Opie code which is a jump which says

00:21:35,420 --> 00:21:42,890
okay jump if 0 if this variable is 0

00:21:40,160 --> 00:21:45,680
jump to the line which is number seven

00:21:42,890 --> 00:21:48,340
which is fetch constant which is just

00:21:45,680 --> 00:21:51,830
the if structure we have over there okay

00:21:48,340 --> 00:21:56,360
it's not pretty pretty hard to do at the

00:21:51,830 --> 00:21:58,340
stand and this is compliation okay so

00:21:56,360 --> 00:22:00,680
when you compile the code when you rent

00:21:58,340 --> 00:22:03,770
pitch because it just compile and

00:22:00,680 --> 00:22:06,080
execute it will execute all this so the

00:22:03,770 --> 00:22:07,880
more code you have to pass the longer

00:22:06,080 --> 00:22:11,870
the compilation phase will be and the

00:22:07,880 --> 00:22:15,290
more oppa code generated usually it's

00:22:11,870 --> 00:22:17,540
not absolutely right okay usually the

00:22:15,290 --> 00:22:21,200
longer the execution will be okay if you

00:22:17,540 --> 00:22:24,100
have 1000 of opie code yes so if you

00:22:21,200 --> 00:22:28,100
have a jump which says prevent all this

00:22:24,100 --> 00:22:30,380
it's not fair but usually the longer the

00:22:28,100 --> 00:22:32,480
more episodes you have the longer the

00:22:30,380 --> 00:22:37,640
execution will be it's not really very

00:22:32,480 --> 00:22:40,280
true but anyway so the more code to pass

00:22:37,640 --> 00:22:44,510
the longer comparison phase no problem

00:22:40,280 --> 00:22:47,600
Oh peacoat caches the compiled up codes

00:22:44,510 --> 00:22:49,520
in shared memory okay so the first thing

00:22:47,600 --> 00:22:51,290
you do when you deploy code usually is

00:22:49,520 --> 00:22:53,960
you put your culture prediction and you

00:22:51,290 --> 00:22:56,900
you just prevent users from fetching

00:22:53,960 --> 00:22:59,540
your server and you fetch your pages

00:22:56,900 --> 00:23:02,570
with curl or something like this so you

00:22:59,540 --> 00:23:06,500
trigger the compiler and you make HP

00:23:02,570 --> 00:23:09,830
compile all those codes or load PHP

00:23:06,500 --> 00:23:11,630
files into shared memory and then after

00:23:09,830 --> 00:23:14,480
when it's in shared memory after the

00:23:11,630 --> 00:23:17,660
first request on say the index page for

00:23:14,480 --> 00:23:20,330
example after this you can open the

00:23:17,660 --> 00:23:22,100
server and people will come and then

00:23:20,330 --> 00:23:24,140
your server will handle requests and

00:23:22,100 --> 00:23:26,240
then you will not have to pass code any

00:23:24,140 --> 00:23:28,370
anymore you will just have to load the

00:23:26,240 --> 00:23:31,370
opcode from sheer memory which is a

00:23:28,370 --> 00:23:33,320
process actually very very fast okay and

00:23:31,370 --> 00:23:35,750
then you execute execute again again

00:23:33,320 --> 00:23:40,039
again until your files actually change

00:23:35,750 --> 00:23:45,169
so next deployed next

00:23:40,039 --> 00:23:47,359
so the compilation is taken care of okay

00:23:45,169 --> 00:23:49,669
Opie cod cash will just catch the optic

00:23:47,359 --> 00:23:52,489
hood so compilation is not a problem

00:23:49,669 --> 00:23:56,509
anymore for us the second problem is

00:23:52,489 --> 00:23:59,029
execution execution can be long okay it

00:23:56,509 --> 00:24:01,729
can take time so some of codes are

00:23:59,029 --> 00:24:03,950
heavier than others yes sure when you do

00:24:01,729 --> 00:24:06,799
for example when you do a function call

00:24:03,950 --> 00:24:09,679
it's absolutely amazing how heavy a

00:24:06,799 --> 00:24:12,590
function call is for the pH the engine

00:24:09,679 --> 00:24:15,859
even with all the caches we've been

00:24:12,590 --> 00:24:18,830
keeping adding in PHP for years when you

00:24:15,859 --> 00:24:20,690
call a function which and a method is

00:24:18,830 --> 00:24:24,129
exactly the same thing as a function

00:24:20,690 --> 00:24:27,169
okay just get this pointer in it it's

00:24:24,129 --> 00:24:31,190
absolutely amazing how long and how

00:24:27,169 --> 00:24:34,489
heavy this can be for PHP and add the

00:24:31,190 --> 00:24:37,690
opposite when you do a shift you know

00:24:34,489 --> 00:24:41,179
with the bracket signs like this it

00:24:37,690 --> 00:24:43,820
directly leads to a shift in c which is

00:24:41,179 --> 00:24:46,070
compiled by GCC pretty much right

00:24:43,820 --> 00:24:48,499
nowadays so this is a no p code which is

00:24:46,070 --> 00:24:51,529
pretty pretty pretty fast okay so you

00:24:48,499 --> 00:24:56,619
have Appa codes which are heavy long to

00:24:51,529 --> 00:25:01,039
run and others which are faster so

00:24:56,619 --> 00:25:03,590
applique is at extension then you can

00:25:01,039 --> 00:25:07,729
activate which is available starting

00:25:03,590 --> 00:25:11,059
from 55 it's merged into PHP source tree

00:25:07,729 --> 00:25:14,570
as an extension ok so it's bundled with

00:25:11,059 --> 00:25:18,799
PHP have nothing to do and be 455 its

00:25:14,570 --> 00:25:23,659
ranks for 52 53 and 54 I did not put 52

00:25:18,799 --> 00:25:27,139
because 52 is just end-of-life it it

00:25:23,659 --> 00:25:29,989
runs as well for 53 and 54 but don't

00:25:27,139 --> 00:25:32,749
expect it to be as efficient as we five

00:25:29,989 --> 00:25:36,830
five and five point next because when we

00:25:32,749 --> 00:25:40,039
add new optimization nowadays we just

00:25:36,830 --> 00:25:44,509
don't care about all PHP versions sorry

00:25:40,039 --> 00:25:46,399
okay from zen because and are the now

00:25:44,509 --> 00:25:48,259
adays the main contributor to this code

00:25:46,399 --> 00:25:50,960
even if it's open source day they've

00:25:48,259 --> 00:25:52,640
been owning it for 44 years now so they

00:25:50,960 --> 00:25:55,220
pretty much know it

00:25:52,640 --> 00:25:57,080
when I talked to Dimitri which is the

00:25:55,220 --> 00:25:58,690
main developer and say oh yes we could

00:25:57,080 --> 00:26:02,900
optimize arrays and things that Allah

00:25:58,690 --> 00:26:05,210
yes but it will only be for 455 at least

00:26:02,900 --> 00:26:08,210
five four but five five and next because

00:26:05,210 --> 00:26:10,670
the next optimization are very very hard

00:26:08,210 --> 00:26:15,800
sometimes to put in old PHP versions but

00:26:10,670 --> 00:26:18,410
anyway it still runs pretty nicely 5354

00:26:15,800 --> 00:26:21,680
if you want to use it you have to use it

00:26:18,410 --> 00:26:26,390
from from pickle it's buffer cache and

00:26:21,680 --> 00:26:29,930
an optimizer so let's now see how the

00:26:26,390 --> 00:26:33,890
optimizer comes to play and what it does

00:26:29,930 --> 00:26:37,760
actually to your code so the role of the

00:26:33,890 --> 00:26:40,880
optimizer is to optimize the opie codes

00:26:37,760 --> 00:26:44,720
so that when when they will be run lots

00:26:40,880 --> 00:26:51,670
lots lots of time they know that then if

00:26:44,720 --> 00:26:54,470
we can win a little milk micro second as

00:26:51,670 --> 00:26:56,750
we bet your code will be run run run run

00:26:54,470 --> 00:26:59,570
again and again and again this is a web

00:26:56,750 --> 00:27:03,920
server ok this is PHP of hundreds of PHP

00:26:59,570 --> 00:27:06,380
processes this those little optimization

00:27:03,920 --> 00:27:08,720
will get multiplied by the number of

00:27:06,380 --> 00:27:11,690
times the code will be run and then you

00:27:08,720 --> 00:27:14,870
will experience at the end of let's take

00:27:11,690 --> 00:27:17,690
24 hours you will experience sometimes

00:27:14,870 --> 00:27:19,340
lots of improvements when you stick all

00:27:17,690 --> 00:27:21,980
the little improvements together and

00:27:19,340 --> 00:27:25,760
then you run them again and again so

00:27:21,980 --> 00:27:28,400
this can happen to be very tiny things

00:27:25,760 --> 00:27:31,880
are why do you just optimize these

00:27:28,400 --> 00:27:35,390
little things but yes we are we are

00:27:31,880 --> 00:27:38,090
looking at very heavy loaded servers

00:27:35,390 --> 00:27:40,760
with lots of PHP codes frameworks and

00:27:38,090 --> 00:27:43,850
things like that so this is pretty nice

00:27:40,760 --> 00:27:47,990
too to optimize every little thing which

00:27:43,850 --> 00:27:49,760
is with optimizing where we do it so

00:27:47,990 --> 00:27:53,930
examples I don't know if you can really

00:27:49,760 --> 00:27:55,640
read from them I could not just my size

00:27:53,930 --> 00:27:59,210
anyway you you will have those slides

00:27:55,640 --> 00:28:02,030
after the conference in PDF somewhere on

00:27:59,210 --> 00:28:05,040
the web so if I told you this is silly

00:28:02,030 --> 00:28:09,510
code but still we can meet

00:28:05,040 --> 00:28:12,440
it this recode this is a code with any

00:28:09,510 --> 00:28:17,100
false branch which is I know silly but

00:28:12,440 --> 00:28:22,410
if false just generate something like if

00:28:17,100 --> 00:28:25,710
false is false jump to free if not you

00:28:22,410 --> 00:28:28,290
still okay when a peacoat Opie cash

00:28:25,710 --> 00:28:31,530
comes to play with the optimizer it

00:28:28,290 --> 00:28:33,750
optimizes the like this this is just an

00:28:31,530 --> 00:28:37,260
eco statement and that's all and you

00:28:33,750 --> 00:28:41,130
always have a return okay because the

00:28:37,260 --> 00:28:43,290
engine always returns something okay and

00:28:41,130 --> 00:28:45,600
you can change it by default it returns

00:28:43,290 --> 00:28:48,090
one but you know that you can return

00:28:45,600 --> 00:28:50,880
something and then include the file and

00:28:48,090 --> 00:28:53,550
the return in this file will be fed well

00:28:50,880 --> 00:28:55,710
you you met the include statement so by

00:28:53,550 --> 00:28:58,770
default if you do something like don't

00:28:55,710 --> 00:29:02,640
know a equals include something by

00:28:58,770 --> 00:29:05,010
default dollar a will be one except if

00:29:02,640 --> 00:29:10,650
your script has a written statement so

00:29:05,010 --> 00:29:15,150
this is a pretty easy optimization this

00:29:10,650 --> 00:29:18,150
one is pretty nice as well so PHP does

00:29:15,150 --> 00:29:20,850
not do this by default okay if you don't

00:29:18,150 --> 00:29:23,670
use the openers optimizer it will not do

00:29:20,850 --> 00:29:25,950
this so here on classical compile a

00:29:23,670 --> 00:29:30,660
compilation you can see that Dora a is

00:29:25,950 --> 00:29:35,580
four plus the string 33 okay so you have

00:29:30,660 --> 00:29:38,490
to add the string 3333 string to the

00:29:35,580 --> 00:29:40,920
integral for and you put this in a

00:29:38,490 --> 00:29:43,770
temporary variable that you are assigned

00:29:40,920 --> 00:29:45,720
to a real variable which is dollar a and

00:29:43,770 --> 00:29:50,280
then you echo it and your return okay

00:29:45,720 --> 00:29:55,110
what Appa cage does by optimizing this

00:29:50,280 --> 00:29:57,270
it text that 4 + 33 can be resolved at

00:29:55,110 --> 00:29:59,340
compile time and you don't have to

00:29:57,270 --> 00:30:02,310
compute this again and again and again

00:29:59,340 --> 00:30:05,190
at execution time and simplifies this by

00:30:02,310 --> 00:30:08,550
directly putting the computation it

00:30:05,190 --> 00:30:11,430
figured out that for / 43 is yes 57 and

00:30:08,550 --> 00:30:13,620
then it directly assign the ferry 7 the

00:30:11,430 --> 00:30:16,290
result okay so when the virtual machine

00:30:13,620 --> 00:30:18,150
when your script will be run it will

00:30:16,290 --> 00:30:19,860
always assign for this

00:30:18,150 --> 00:30:23,970
of them to your doula a and it will not

00:30:19,860 --> 00:30:27,660
run the addition anymore at every time

00:30:23,970 --> 00:30:32,190
okay this is another optimization this

00:30:27,660 --> 00:30:37,770
one is trickier even if I guess you

00:30:32,190 --> 00:30:41,400
already got it it seems like at the

00:30:37,770 --> 00:30:44,600
number yes not the same number for the

00:30:41,400 --> 00:30:49,950
temporary variables anyway 0 or 1 and

00:30:44,600 --> 00:30:53,220
the difference here is that 42 string

00:30:49,950 --> 00:30:56,460
has been turned to the 42 integer by the

00:30:53,220 --> 00:31:01,620
optimizer and turning a string to an

00:30:56,460 --> 00:31:04,760
integer is not transparent it's it takes

00:31:01,620 --> 00:31:08,670
CPU cycles okay so if you have to turn

00:31:04,760 --> 00:31:13,560
that the 42 string to the 42 integer

00:31:08,670 --> 00:31:15,900
every time at execution time at least

00:31:13,560 --> 00:31:18,240
when you have lots of requests and lots

00:31:15,900 --> 00:31:20,760
of codes everywhere this is once again

00:31:18,240 --> 00:31:24,420
an optimization so you can see that at

00:31:20,760 --> 00:31:29,100
compile time we can only do what we are

00:31:24,420 --> 00:31:32,910
sure it is if you have a if force okay

00:31:29,100 --> 00:31:35,150
if you have a dollar a equals force if

00:31:32,910 --> 00:31:38,580
dollar a we cannot do anything anymore

00:31:35,150 --> 00:31:40,620
because someone can change a by using a

00:31:38,580 --> 00:31:44,000
global variable somewhere I don't know

00:31:40,620 --> 00:31:47,190
when people too tricky things with PHP

00:31:44,000 --> 00:31:49,710
but we allow allowed them to do this so

00:31:47,190 --> 00:31:52,110
that's our fault actually and we cannot

00:31:49,710 --> 00:31:56,910
do the optimization if you have to

00:31:52,110 --> 00:32:01,650
complex code and this one as well it's

00:31:56,910 --> 00:32:06,930
been talked by Davis in his talk this

00:32:01,650 --> 00:32:10,620
morning and having a dollar i equals the

00:32:06,930 --> 00:32:13,290
log i plus something it's turned to an

00:32:10,620 --> 00:32:17,130
assign ID so it's turned to a dollar i

00:32:13,290 --> 00:32:19,920
plus equal 42 which is more optimized

00:32:17,130 --> 00:32:22,560
because when you use an addition you

00:32:19,920 --> 00:32:25,290
have to create a temporary variable and

00:32:22,560 --> 00:32:26,410
add those variables to a temporary one

00:32:25,290 --> 00:32:28,240
and assign it

00:32:26,410 --> 00:32:31,810
back to your variable when you use a

00:32:28,240 --> 00:32:35,020
plus equal it does it no 10 p code which

00:32:31,810 --> 00:32:37,270
is called a sign add okay if you don't

00:32:35,020 --> 00:32:40,990
use this and you have this code it will

00:32:37,270 --> 00:32:43,150
add temporary variable result assign the

00:32:40,990 --> 00:32:45,730
temporary to the real valuable Dora a

00:32:43,150 --> 00:32:48,150
destroy the temporary which is free

00:32:45,730 --> 00:32:50,230
which is freeing memory which is

00:32:48,150 --> 00:32:54,580
touching memory and touching memory

00:32:50,230 --> 00:32:57,160
takes time ok so we prevented this by

00:32:54,580 --> 00:33:00,340
turning the the assigned to assign add

00:32:57,160 --> 00:33:03,040
when we can and this is the same and

00:33:00,340 --> 00:33:05,230
Davis talked about it this morning when

00:33:03,040 --> 00:33:07,000
you have the plus + the post

00:33:05,230 --> 00:33:09,430
incrementation the pre-implementation

00:33:07,000 --> 00:33:11,650
you know the difference in PHP is that

00:33:09,430 --> 00:33:17,080
the post incrementation will create a

00:33:11,650 --> 00:33:20,170
resort ok it will create a resort and if

00:33:17,080 --> 00:33:24,120
you don't use it it has to free it so

00:33:20,170 --> 00:33:28,150
that's a complete waste of time memory

00:33:24,120 --> 00:33:31,990
CPU cycles okay if I put dollar a equals

00:33:28,150 --> 00:33:35,260
dollar J plus plus I get the result of

00:33:31,990 --> 00:33:38,800
the plus + operation to a variable so it

00:33:35,260 --> 00:33:43,690
won't free it it will assign it okay but

00:33:38,800 --> 00:33:45,910
anyway when the engine can turn a dollar

00:33:43,690 --> 00:33:47,830
something plus plus 2ab plus plus doll

00:33:45,910 --> 00:33:50,380
or something and it does not change the

00:33:47,830 --> 00:33:52,990
meaning of the code all right we do this

00:33:50,380 --> 00:33:55,800
okay because when you have a prayer a

00:33:52,990 --> 00:33:58,420
pre incrementation or decrement ation

00:33:55,800 --> 00:34:01,830
exactly the same when the signs are

00:33:58,420 --> 00:34:05,950
placed before your variable the engine

00:34:01,830 --> 00:34:09,970
use a pre incrementation opcode and this

00:34:05,950 --> 00:34:11,890
does not return any any result any value

00:34:09,970 --> 00:34:15,370
so we don't have to create a temporary

00:34:11,890 --> 00:34:18,580
variable in the engine and freed after

00:34:15,370 --> 00:34:22,750
so it's done automatically by the

00:34:18,580 --> 00:34:26,169
optimizer this one is much more tricky

00:34:22,750 --> 00:34:28,210
and it involves you that you know the

00:34:26,169 --> 00:34:34,210
internal structure of the engine well

00:34:28,210 --> 00:34:36,940
what it does here and all the dollar

00:34:34,210 --> 00:34:39,760
dollar something here dolla present

00:34:36,940 --> 00:34:43,120
member temporary variables in the engine

00:34:39,760 --> 00:34:46,899
okay and what it does is that when you

00:34:43,120 --> 00:34:50,220
try to fetch the same array dimension

00:34:46,899 --> 00:34:54,399
and things like that it tries to reuse

00:34:50,220 --> 00:34:56,830
temporary variables from before here you

00:34:54,399 --> 00:34:58,930
can see that you only have a two

00:34:56,830 --> 00:35:02,040
temporary variables which are Dora 0 and

00:34:58,930 --> 00:35:05,290
Dora one and here you have the red 0 1

00:35:02,040 --> 00:35:07,090
45 and after you have a temporary

00:35:05,290 --> 00:35:10,180
another temporary one which is a little

00:35:07,090 --> 00:35:11,920
bit trickier with the tilde and it tries

00:35:10,180 --> 00:35:14,350
to optimize this so that it does not

00:35:11,920 --> 00:35:17,200
have to create temporary slots in memory

00:35:14,350 --> 00:35:20,200
put things inside and free the slot next

00:35:17,200 --> 00:35:22,990
up code temporary slot freedom flood it

00:35:20,200 --> 00:35:25,500
try to reuse slots whenever it can

00:35:22,990 --> 00:35:28,000
because it's pretty much complex

00:35:25,500 --> 00:35:30,240
internally so that's another

00:35:28,000 --> 00:35:33,040
optimization which is done by the engine

00:35:30,240 --> 00:35:36,040
this one as well is classical one which

00:35:33,040 --> 00:35:39,970
is called compiled times constant

00:35:36,040 --> 00:35:42,340
substitution you declare a constant okay

00:35:39,970 --> 00:35:44,530
const foo equals the swinging bar and

00:35:42,340 --> 00:35:47,620
then you echo the constant fool by

00:35:44,530 --> 00:35:50,770
default the PHP compiler we say okay

00:35:47,620 --> 00:35:53,020
declare a constant fetch back this

00:35:50,770 --> 00:35:58,570
constant to something which is temporary

00:35:53,020 --> 00:36:00,970
and echo it okay which is pretty useless

00:35:58,570 --> 00:36:03,070
because what you can do is declare your

00:36:00,970 --> 00:36:06,990
constant yes you still need to declare

00:36:03,070 --> 00:36:10,450
buttocks instead of fetching it back and

00:36:06,990 --> 00:36:13,030
echoing the result just declare it and

00:36:10,450 --> 00:36:17,590
get the result and put it to eco and you

00:36:13,030 --> 00:36:20,560
save one fetch constant opcode this is

00:36:17,590 --> 00:36:23,050
little but as I said if you have lots of

00:36:20,560 --> 00:36:26,080
classes with lots of constants inside

00:36:23,050 --> 00:36:28,930
then lots of code sorry buddies and lots

00:36:26,080 --> 00:36:31,900
of code when you have little micro

00:36:28,930 --> 00:36:35,850
seconds or milliseconds and you add them

00:36:31,900 --> 00:36:40,540
to lots and lots and lots of run

00:36:35,850 --> 00:36:42,790
optimizing the opra is heavy but because

00:36:40,540 --> 00:36:44,710
this has lots of wise and ifs and things

00:36:42,790 --> 00:36:46,540
like that but this is done at compile

00:36:44,710 --> 00:36:52,260
time and you don't care about compile

00:36:46,540 --> 00:36:54,180
time this was stupids of codes

00:36:52,260 --> 00:36:57,150
took from the optimizer which was just

00:36:54,180 --> 00:37:00,330
the visible part we because oph takes

00:36:57,150 --> 00:37:02,850
care of lots of things for you I can't

00:37:00,330 --> 00:37:07,830
tell you because even me I don't mash

00:37:02,850 --> 00:37:10,980
them yet optimizing compilation is

00:37:07,830 --> 00:37:13,590
something which has been written

00:37:10,980 --> 00:37:17,160
articles for 44 years now because we

00:37:13,590 --> 00:37:20,130
don't before compiling PHP code we we

00:37:17,160 --> 00:37:21,840
compiled C code 2222 machine code so we

00:37:20,130 --> 00:37:23,910
know about compilation so you have

00:37:21,840 --> 00:37:26,430
pretty nice article in Wikipedia and I'm

00:37:23,910 --> 00:37:29,460
looking for adding much more

00:37:26,430 --> 00:37:31,880
optimization in loops invariant motion

00:37:29,460 --> 00:37:35,610
for example which is pretty nice thing

00:37:31,880 --> 00:37:38,750
to add but pretty difficult to add as

00:37:35,610 --> 00:37:43,050
well and hope you catch does as well

00:37:38,750 --> 00:37:46,470
very heavy to compute things when you

00:37:43,050 --> 00:37:50,760
have lots of wires if switch break to

00:37:46,470 --> 00:37:53,460
continue one it tries to graph all the

00:37:50,760 --> 00:37:55,410
path or the possible paths and and try

00:37:53,460 --> 00:37:58,950
to merge some part in the virtual

00:37:55,410 --> 00:38:01,620
machines so that you don't you have a

00:37:58,950 --> 00:38:03,480
better code and better jumps in the

00:38:01,620 --> 00:38:05,300
virtual machine all your ifs and wires

00:38:03,480 --> 00:38:08,030
and things like that so it's pretty

00:38:05,300 --> 00:38:12,210
pretty interesting to know as well an

00:38:08,030 --> 00:38:16,260
intern string optimization is also

00:38:12,210 --> 00:38:18,980
something so this is a big text

00:38:16,260 --> 00:38:22,500
shouldn't have put it here but anyway

00:38:18,980 --> 00:38:25,170
now I think you've finished you just

00:38:22,500 --> 00:38:28,800
finished reading it our ten percent more

00:38:25,170 --> 00:38:31,830
and that's it you finished reading in

00:38:28,800 --> 00:38:34,530
turn string is pretty interesting as

00:38:31,830 --> 00:38:38,310
well it's been added to PHP 54 compiler

00:38:34,530 --> 00:38:40,500
it says okay when you compile something

00:38:38,310 --> 00:38:44,130
you meet strings and those strings you

00:38:40,500 --> 00:38:45,990
will need them later the class string we

00:38:44,130 --> 00:38:48,720
just don't care about it but the food is

00:38:45,990 --> 00:38:51,260
the name of the class the bar is the

00:38:48,720 --> 00:38:55,980
name of the function and etc etc etc

00:38:51,260 --> 00:38:59,850
every time PHP meets these before 54 it

00:38:55,980 --> 00:39:02,789
just allocated many many slots in memory

00:38:59,850 --> 00:39:07,169
to put all those

00:39:02,789 --> 00:39:11,609
which are all the same okay why can't we

00:39:07,169 --> 00:39:14,729
optimize these two have all the strings

00:39:11,609 --> 00:39:18,239
still pointing to the same pointers like

00:39:14,729 --> 00:39:21,569
this this is a very nice optimization

00:39:18,239 --> 00:39:24,179
it's been added to 5.4 no application

00:39:21,569 --> 00:39:27,630
you did nothing like this okay so that's

00:39:24,179 --> 00:39:31,650
why that's one part which explains why

00:39:27,630 --> 00:39:35,160
PHP 54 is much has a much less memory

00:39:31,650 --> 00:39:38,789
footprint than 53 52 in this is one of

00:39:35,160 --> 00:39:40,469
the trick if you use lots of classes and

00:39:38,789 --> 00:39:42,419
lots of text and things like that you

00:39:40,469 --> 00:39:48,059
you can expect lots of optimization what

00:39:42,419 --> 00:39:52,380
does oppa code oppa cash do not care but

00:39:48,059 --> 00:39:54,709
this is that when you have lots of PHP

00:39:52,380 --> 00:39:59,160
processes they all have their own

00:39:54,709 --> 00:40:02,369
internet stringbuffer what oph does is

00:39:59,160 --> 00:40:07,019
that it shares it in share memory for

00:40:02,369 --> 00:40:10,019
every you know PHP CGI or php-fpm child

00:40:07,019 --> 00:40:13,679
so that they open all the same shared

00:40:10,019 --> 00:40:16,140
memory hole and they all compile the

00:40:13,679 --> 00:40:18,209
code and read their strings inside so

00:40:16,140 --> 00:40:21,929
this is pretty nice if you have lots of

00:40:18,209 --> 00:40:24,709
PHP workers I guess you have you can

00:40:21,929 --> 00:40:27,059
expect a huge memory saving if you have

00:40:24,709 --> 00:40:29,549
symphonies in framework application with

00:40:27,059 --> 00:40:33,869
lots of classes and functions and things

00:40:29,549 --> 00:40:36,449
like that what's the API of oph well you

00:40:33,869 --> 00:40:40,259
can read it on the documentation okay so

00:40:36,449 --> 00:40:43,039
I want a repeat documentation even if

00:40:40,259 --> 00:40:46,439
it's but what I'm actually doing here

00:40:43,039 --> 00:40:49,319
you know a pc so you can expect the same

00:40:46,439 --> 00:40:52,140
thing we have a pretty nice as well you

00:40:49,319 --> 00:40:54,299
remember at the APC front end which is a

00:40:52,140 --> 00:40:57,479
which was graphical frontentia linear

00:40:54,299 --> 00:41:01,229
memory etc we have the same for a ph you

00:40:57,479 --> 00:41:04,469
can fetch it from a rasmus rasmus end of

00:41:01,229 --> 00:41:08,099
garib repository it has design base with

00:41:04,469 --> 00:41:11,339
JavaScript and things like this so what

00:41:08,099 --> 00:41:12,470
you have to know about up cash is the

00:41:11,339 --> 00:41:15,320
settings

00:41:12,470 --> 00:41:17,540
it's the same for a pc memory

00:41:15,320 --> 00:41:20,810
consumption is the size of the shared

00:41:17,540 --> 00:41:24,380
memory segment you should always have

00:41:20,810 --> 00:41:27,680
enough memory if you don't have PHP will

00:41:24,380 --> 00:41:31,310
just drag and we'll just start crashing

00:41:27,680 --> 00:41:34,700
and things like that so have this huge

00:41:31,310 --> 00:41:37,340
enough max excellerate 85 is the number

00:41:34,700 --> 00:41:40,970
of keys which is not the same as number

00:41:37,340 --> 00:41:43,369
of files to store in the cache a

00:41:40,970 --> 00:41:46,340
classical classical symphony to

00:41:43,369 --> 00:41:48,680
application needs about 3,000 and by

00:41:46,340 --> 00:41:54,290
default it's 2,000 so take care of this

00:41:48,680 --> 00:41:56,570
as well and this is the explanation of

00:41:54,290 --> 00:41:59,060
all the statistics you can expect they

00:41:56,570 --> 00:42:01,070
are not really really hard to explain so

00:41:59,060 --> 00:42:03,310
i will let you read them on the

00:42:01,070 --> 00:42:06,250
documentation or perhaps under under

00:42:03,310 --> 00:42:09,200
directly on the on the front end here

00:42:06,250 --> 00:42:12,130
what is a little bit tricky is number of

00:42:09,200 --> 00:42:15,200
cached keys i have just to explain that

00:42:12,130 --> 00:42:19,250
what are keys because o P cash does not

00:42:15,200 --> 00:42:20,990
cash it caches faiz but josh is them in

00:42:19,250 --> 00:42:23,750
a way which is a little bit tricky you

00:42:20,990 --> 00:42:26,150
have to know about a file few may be

00:42:23,750 --> 00:42:28,760
accessed in your script by several and

00:42:26,150 --> 00:42:31,280
several paths ok you can have relative

00:42:28,760 --> 00:42:35,060
paths absolute paths and things like

00:42:31,280 --> 00:42:37,420
that every single way of accessing a

00:42:35,060 --> 00:42:42,650
file will create a key for this fire

00:42:37,420 --> 00:42:45,950
okay so that's the trick the full script

00:42:42,650 --> 00:42:49,490
actually will be stored once in the cash

00:42:45,950 --> 00:42:52,550
but it will generate here three keys

00:42:49,490 --> 00:42:55,130
okay so don't be mistaken with the

00:42:52,550 --> 00:42:58,880
number of cash scripts and the number of

00:42:55,130 --> 00:43:01,250
cached keys which are all the ways all

00:42:58,880 --> 00:43:04,310
the different ways to access all the

00:43:01,250 --> 00:43:07,280
different cash script and this is the

00:43:04,310 --> 00:43:09,710
cached keys which is bounded limited by

00:43:07,280 --> 00:43:13,790
the anion I settings so you have to take

00:43:09,710 --> 00:43:16,190
care about this not to exhaust it and as

00:43:13,790 --> 00:43:18,530
you can expect validate time stamp

00:43:16,190 --> 00:43:21,290
should I check on the disk every time if

00:43:18,530 --> 00:43:26,030
your file has been modified I did not

00:43:21,290 --> 00:43:27,470
experience lots of slowness when you put

00:43:26,030 --> 00:43:30,410
is too true in prediction because

00:43:27,470 --> 00:43:32,900
nowadays linux kernel are very very nice

00:43:30,410 --> 00:43:38,180
to optimize those accesses as well so

00:43:32,900 --> 00:43:40,730
it's not that bad having this to true in

00:43:38,180 --> 00:43:44,020
production and the wasted percentage i

00:43:40,730 --> 00:43:47,930
will talk to you about this in a minute

00:43:44,020 --> 00:43:52,190
so those are settings you can you can

00:43:47,930 --> 00:43:54,770
read on the php.net documentation so the

00:43:52,190 --> 00:43:57,950
cash there is something which is tricky

00:43:54,770 --> 00:44:01,190
in oph if you compare it to a pcs that

00:43:57,950 --> 00:44:03,440
whenever you have a thigh okay it gets

00:44:01,190 --> 00:44:05,000
cached and then it's going to change in

00:44:03,440 --> 00:44:06,590
production I don't know why it's going

00:44:05,000 --> 00:44:09,890
to change so opener she's going to

00:44:06,590 --> 00:44:13,790
recompile it but it will never free the

00:44:09,890 --> 00:44:19,580
memory of the old fire it will say this

00:44:13,790 --> 00:44:23,510
is wasted memory wasted memory is memory

00:44:19,580 --> 00:44:26,540
allocated for scripts which are not up

00:44:23,510 --> 00:44:29,990
to date on the server actually but the

00:44:26,540 --> 00:44:31,610
old memory is not freed because if we

00:44:29,990 --> 00:44:33,680
have to free it we have to reassemble

00:44:31,610 --> 00:44:37,550
all the blocks and this is to CPU

00:44:33,680 --> 00:44:40,160
intensive ok so when the cash is full

00:44:37,550 --> 00:44:42,320
you have to trigger the max wasted

00:44:40,160 --> 00:44:44,960
percentage and when it's reached the

00:44:42,320 --> 00:44:47,180
cash will be restarted and then it will

00:44:44,960 --> 00:44:48,890
be freedom it will you recompile all

00:44:47,180 --> 00:44:51,470
your fire this is a little bit tricky

00:44:48,890 --> 00:44:53,330
you have to know about so this is

00:44:51,470 --> 00:44:56,900
another example where we we have a cache

00:44:53,330 --> 00:44:59,960
which is actually full full full only 26

00:44:56,900 --> 00:45:05,420
kilobyte free but the wasted percentage

00:44:59,960 --> 00:45:07,400
is actually 5.07 and here it's another

00:45:05,420 --> 00:45:09,680
10 on the fifteen percent in the

00:45:07,400 --> 00:45:12,350
configuration so the cash will never be

00:45:09,680 --> 00:45:15,440
restarted okay so this is pretty bad

00:45:12,350 --> 00:45:17,900
because it's full cash so never have a

00:45:15,440 --> 00:45:23,510
full cash in production is absolutely

00:45:17,900 --> 00:45:26,900
horrible why restart this is why the

00:45:23,510 --> 00:45:30,440
application restarts actually out of

00:45:26,900 --> 00:45:32,780
memory restarts hash results or manual

00:45:30,440 --> 00:45:34,370
results those are explained here so you

00:45:32,780 --> 00:45:36,590
should know the difference between them

00:45:34,370 --> 00:45:38,900
the documentation is not really really

00:45:36,590 --> 00:45:42,410
accurate about this so I explained

00:45:38,900 --> 00:45:46,880
them here so that now you know about

00:45:42,410 --> 00:45:49,339
those numbers I know what happened oki

00:45:46,880 --> 00:45:51,650
catch can have a very nice log as well

00:45:49,339 --> 00:45:53,630
what it does i'm compiling this script

00:45:51,650 --> 00:45:55,609
i'm adding a key for this script I don't

00:45:53,630 --> 00:45:57,440
have a memory enough I'm trying to

00:45:55,609 --> 00:46:00,799
fulfill this table and I don't have

00:45:57,440 --> 00:46:03,289
memory you can actually have a pretty

00:46:00,799 --> 00:46:07,490
nice log as well for 40 p cash which is

00:46:03,289 --> 00:46:11,630
a nice and last settings and actually

00:46:07,490 --> 00:46:14,210
last slide which is about things like

00:46:11,630 --> 00:46:18,520
fast shut down I experienced something

00:46:14,210 --> 00:46:21,559
like one person or two percent maximum

00:46:18,520 --> 00:46:25,579
improvement learning these two true so

00:46:21,559 --> 00:46:28,130
you could do it consistency check is

00:46:25,579 --> 00:46:34,640
just something which will tag compute

00:46:28,130 --> 00:46:36,740
figure out some with crc algorithm to

00:46:34,640 --> 00:46:39,200
know if your has been corrupted on the

00:46:36,740 --> 00:46:42,799
disk just don't use this you know can

00:46:39,200 --> 00:46:46,119
experience very pretty much slow down 58

00:46:42,799 --> 00:46:52,670
doesn't slow down so do then don't

00:46:46,119 --> 00:46:54,970
please have enough memory feeling your

00:46:52,670 --> 00:46:58,670
cash before opening your service to your

00:46:54,970 --> 00:47:01,640
to people because we have too many

00:46:58,670 --> 00:47:05,930
people accessing the same files every

00:47:01,640 --> 00:47:07,880
time every time oph accesses the the

00:47:05,930 --> 00:47:09,740
shared memory segment it locks it so

00:47:07,880 --> 00:47:11,450
every process is going to wait for the

00:47:09,740 --> 00:47:16,069
lock to be released by the other

00:47:11,450 --> 00:47:21,109
processes so try to be smart it's Dunham

00:47:16,069 --> 00:47:23,480
it it's it works like a PC did with

00:47:21,109 --> 00:47:27,140
little bit things which are a little bit

00:47:23,480 --> 00:47:29,210
tricky and it at leasts as well as a

00:47:27,140 --> 00:47:31,510
pretty nice optimizer this is what you

00:47:29,210 --> 00:47:34,279
have to what you have to know about

00:47:31,510 --> 00:47:38,539
application we are planning to merge its

00:47:34,279 --> 00:47:41,900
code to the PHP code in the next PHP

00:47:38,539 --> 00:47:43,369
really should did BP perhaps PHP sex or

00:47:41,900 --> 00:47:45,769
something like that

00:47:43,369 --> 00:47:49,130
so actually it's it's an extension you

00:47:45,769 --> 00:47:52,970
have to set up for please do not set up

00:47:49,130 --> 00:47:57,859
okie cage together with ABC it's not

00:47:52,970 --> 00:48:01,190
that do not as well do not activate a

00:47:57,859 --> 00:48:03,559
package together with XD bug okay

00:48:01,190 --> 00:48:05,749
because they both redefined and execute

00:48:03,559 --> 00:48:07,130
you can expect pretty strange things oh

00:48:05,749 --> 00:48:09,920
because she's something which is

00:48:07,130 --> 00:48:12,499
projection protection and protection XD

00:48:09,920 --> 00:48:15,650
bug is not and you know that must not

00:48:12,499 --> 00:48:18,319
have more than 10 p code cache at the

00:48:15,650 --> 00:48:21,170
same time in PHP based economy hell for

00:48:18,319 --> 00:48:22,970
you and that's it I guess we have

00:48:21,170 --> 00:48:25,759
something like five or ten minutes

00:48:22,970 --> 00:48:29,749
actually 24 questions so it's pretty

00:48:25,759 --> 00:48:34,069
nice thank you for listening I'm taking

00:48:29,749 --> 00:48:42,200
questions if you have questions so yes I

00:48:34,069 --> 00:48:45,309
saw one here you mentioned there's a

00:48:42,200 --> 00:48:47,359
compile-time at sort of the compile time

00:48:45,309 --> 00:48:50,509
so let me get this straight in my head

00:48:47,359 --> 00:48:53,390
is there an overhead the first time that

00:48:50,509 --> 00:48:58,400
is he yeah bout primate what is that

00:48:53,390 --> 00:49:00,230
compared to without the Opie cash so it

00:48:58,400 --> 00:49:04,369
you mention like twenty-five percent is

00:49:00,230 --> 00:49:07,609
compile time versus execution it how

00:49:04,369 --> 00:49:10,009
much does that add to the first hit do

00:49:07,609 --> 00:49:13,519
that make sense but the first time you

00:49:10,009 --> 00:49:15,319
hit the fire it will compile it store in

00:49:13,519 --> 00:49:17,059
shell memory when you use an Opie code

00:49:15,319 --> 00:49:21,829
cache and execute it and the next time

00:49:17,059 --> 00:49:25,940
it will just execute so the twenty

00:49:21,829 --> 00:49:30,849
percent here is just an experience from

00:49:25,940 --> 00:49:30,849
I don't know which fire things like this

00:49:31,059 --> 00:49:37,099
d is it margin all the gas is the is the

00:49:34,579 --> 00:49:40,249
question does because it's optimizing is

00:49:37,099 --> 00:49:42,140
it quite intensive to do it yes time yes

00:49:40,249 --> 00:49:44,900
yes is that why you recommend into

00:49:42,140 --> 00:49:47,150
actually prime oh yes you should you

00:49:44,900 --> 00:49:49,970
should even with a pc nowadays you

00:49:47,150 --> 00:49:54,019
cannot you push new code and then you

00:49:49,970 --> 00:49:56,150
open your server everybody's going to

00:49:54,019 --> 00:49:57,190
hit the compiler it's going to the first

00:49:56,150 --> 00:49:58,990
one which

00:49:57,190 --> 00:50:03,040
lock the shared memory it's going to

00:49:58,990 --> 00:50:06,190
come by and this is quiet long and then

00:50:03,040 --> 00:50:09,280
execute so what you usually do is push

00:50:06,190 --> 00:50:10,990
code and then hit with curl this is an

00:50:09,280 --> 00:50:13,390
example which is pretty much used

00:50:10,990 --> 00:50:15,730
everywhere and very easy you trigger

00:50:13,390 --> 00:50:19,420
when we request to your main page or two

00:50:15,730 --> 00:50:21,849
hour to you to all your pages or lots of

00:50:19,420 --> 00:50:24,430
them so that all the PHP code is

00:50:21,849 --> 00:50:27,280
compiled and you you will you can feel

00:50:24,430 --> 00:50:31,540
it even from a human point of view that

00:50:27,280 --> 00:50:36,760
the first request finally my result and

00:50:31,540 --> 00:50:40,119
the next ones are pretty much they go

00:50:36,760 --> 00:50:44,079
they go and sorry just lastly you

00:50:40,119 --> 00:50:48,550
mention intern strings as camisa in 54

00:50:44,079 --> 00:50:51,400
or 55 54 and you can use LP cash with 53

00:50:48,550 --> 00:50:53,829
yeah you do you get that benefit from

00:50:51,400 --> 00:50:56,530
Opie cash does that do that optimization

00:50:53,829 --> 00:51:02,410
or intern strings or is that only apply

00:50:56,530 --> 00:51:06,310
for 54 no oph detects the version of PHP

00:51:02,410 --> 00:51:08,920
it's actually being run on and if it

00:51:06,310 --> 00:51:11,650
detects its PHP 5 free it will just

00:51:08,920 --> 00:51:13,210
disable all about intern string because

00:51:11,650 --> 00:51:15,190
we you don't have in turn string and 5

00:51:13,210 --> 00:51:16,930
free so you don't have to care about the

00:51:15,190 --> 00:51:19,480
version you just put application it

00:51:16,930 --> 00:51:23,050
detects itself and it activates itself

00:51:19,480 --> 00:51:27,450
what it has to do for the engine thank

00:51:23,050 --> 00:51:27,450
you another question here

00:51:30,910 --> 00:51:37,970
hi actually I have two questions the

00:51:35,120 --> 00:51:43,370
first one is regarding the size of the

00:51:37,970 --> 00:51:47,230
memory you mentioned that Nova an

00:51:43,370 --> 00:51:52,040
average symphony app it had like 2,000

00:51:47,230 --> 00:51:58,970
or 3,000 I was wondering how do you

00:51:52,040 --> 00:52:04,430
calculate those numbers what just have

00:51:58,970 --> 00:52:06,890
stats okay and the function is 0 PK she

00:52:04,430 --> 00:52:09,830
gets status it returns an array with all

00:52:06,890 --> 00:52:12,260
these which are here presented in pretty

00:52:09,830 --> 00:52:14,540
nice front end so you can monitor it in

00:52:12,260 --> 00:52:16,850
run time and again check the number yeah

00:52:14,540 --> 00:52:20,570
you just check it doesn't matter which

00:52:16,850 --> 00:52:22,790
server which think you set up your

00:52:20,570 --> 00:52:25,790
application for prediction and you run

00:52:22,790 --> 00:52:27,860
it let's say for example locally on your

00:52:25,790 --> 00:52:31,220
local machine if it's the same version

00:52:27,860 --> 00:52:34,970
etc and you just see how many files how

00:52:31,220 --> 00:52:39,010
many keys you just tap we usually did

00:52:34,970 --> 00:52:42,740
this when we on the machine when the

00:52:39,010 --> 00:52:45,620
user tests are run you know with be hat

00:52:42,740 --> 00:52:48,920
and testers human testers which test the

00:52:45,620 --> 00:52:51,470
application on the testing machine and

00:52:48,920 --> 00:52:56,870
this machine actually served us for

00:52:51,470 --> 00:53:00,620
statistics for prediction sizings and

00:52:56,870 --> 00:53:03,140
the second question is regarding the the

00:53:00,620 --> 00:53:06,440
change files so you mentioned that when

00:53:03,140 --> 00:53:09,080
a file is change that has an overhead so

00:53:06,440 --> 00:53:12,380
I was asked you what is the best

00:53:09,080 --> 00:53:15,590
practice when you deploy a new version

00:53:12,380 --> 00:53:19,130
of many files you make like a requests

00:53:15,590 --> 00:53:22,880
for those the URLs that's going to use

00:53:19,130 --> 00:53:25,820
those files usually it's it's not one

00:53:22,880 --> 00:53:29,090
fits the whole application that you push

00:53:25,820 --> 00:53:31,910
another version so it's what do you

00:53:29,090 --> 00:53:36,620
chroma can do and what make me what you

00:53:31,910 --> 00:53:40,260
mean it in my experience Wii with trust

00:53:36,620 --> 00:53:43,260
unix so we all do

00:53:40,260 --> 00:53:47,230
we do everything in shell script and

00:53:43,260 --> 00:53:51,670
what we do is when we want to deploy we

00:53:47,230 --> 00:53:55,420
start a new pool of PHP processes which

00:53:51,670 --> 00:53:58,660
was just fresh we push the code in it

00:53:55,420 --> 00:54:02,500
and we use a load balancer for fast CGI

00:53:58,660 --> 00:54:05,740
in the engine X and lightly so we don't

00:54:02,500 --> 00:54:11,050
have to push and to change sim leanings

00:54:05,740 --> 00:54:15,490
and things like a HD htdocs we just

00:54:11,050 --> 00:54:18,840
switch with tell IT ok now the fast cgi

00:54:15,490 --> 00:54:21,760
prolly is not this one it's this one and

00:54:18,840 --> 00:54:24,400
when it's done we kill all the old

00:54:21,760 --> 00:54:28,750
process we all do this with bash shell

00:54:24,400 --> 00:54:31,120
scripts and you know Ella sort of guilty

00:54:28,750 --> 00:54:34,990
dog things like this which has been

00:54:31,120 --> 00:54:39,520
working for 50 years now and we don't

00:54:34,990 --> 00:54:43,030
trust tools we trust what actually works

00:54:39,520 --> 00:54:46,150
and what actually works is Unix you know

00:54:43,030 --> 00:54:49,120
and Linux and new so we use this and we

00:54:46,150 --> 00:54:53,800
we have never experienced anything which

00:54:49,120 --> 00:54:56,530
is wrong we just have several PHP master

00:54:53,800 --> 00:54:58,900
pools with lots of children we have won

00:54:56,530 --> 00:55:01,540
two of three this is the current one

00:54:58,900 --> 00:55:03,700
from prediction we are going to release

00:55:01,540 --> 00:55:05,800
our new version we push code to the

00:55:03,700 --> 00:55:10,900
middle one and we say the web server

00:55:05,800 --> 00:55:15,490
okay now switch so yes you can have and

00:55:10,900 --> 00:55:18,220
we will let the old requests and until

00:55:15,490 --> 00:55:21,820
the PHP process says okay we ended and

00:55:18,220 --> 00:55:24,370
kill each other and we kill with a sick

00:55:21,820 --> 00:55:26,050
kill the last runs we just don't want to

00:55:24,370 --> 00:55:29,290
kill themselves and then we prepare a

00:55:26,050 --> 00:55:32,650
new pool Andrew much like this just

00:55:29,290 --> 00:55:34,990
works it's not very nice we use in okla

00:55:32,650 --> 00:55:36,790
catch any way if you change fires you're

00:55:34,990 --> 00:55:39,790
going to waste waste waste waste more

00:55:36,790 --> 00:55:42,790
and more memory okay until it restarts

00:55:39,790 --> 00:55:46,750
and when it restarts in projection your

00:55:42,790 --> 00:55:48,369
servers down well I guess it's a heavy

00:55:46,750 --> 00:55:51,990
loaded server

00:55:48,369 --> 00:55:58,240
J so that's right yeah another question

00:55:51,990 --> 00:56:00,490
behind you hi um so do you think after

00:55:58,240 --> 00:56:02,349
all those optimizations is there is

00:56:00,490 --> 00:56:05,529
still much room for improvement without

00:56:02,349 --> 00:56:07,599
breaking backwards compatibility after

00:56:05,529 --> 00:56:10,779
having working with all those up cash

00:56:07,599 --> 00:56:14,309
that you have described using that is

00:56:10,779 --> 00:56:17,650
hope to be so much faster or like yes

00:56:14,309 --> 00:56:22,390
there are still many things to do in PHP

00:56:17,650 --> 00:56:24,609
so if there is still scope to optimize

00:56:22,390 --> 00:56:26,680
things yes yes particularly in

00:56:24,609 --> 00:56:29,259
application I have lots of ideas but

00:56:26,680 --> 00:56:31,769
Dmitry told me it's going to be tricky

00:56:29,259 --> 00:56:35,470
you're going to experience lots of

00:56:31,769 --> 00:56:37,690
bizarre things so for example the arrays

00:56:35,470 --> 00:56:39,999
and these static arrays are something

00:56:37,690 --> 00:56:44,009
which is crazy in PHP if you have a

00:56:39,999 --> 00:56:48,730
static array with only statics inside

00:56:44,009 --> 00:56:51,759
only strings mixed with integrals no

00:56:48,730 --> 00:56:56,079
object no other array declare the array

00:56:51,759 --> 00:56:59,319
as static it's a huge optimization for

00:56:56,079 --> 00:57:01,089
the engine and opie cash can turn this

00:56:59,319 --> 00:57:03,940
but actually it's not implementing I'm

00:57:01,089 --> 00:57:07,619
working on this but it's pretty hard to

00:57:03,940 --> 00:57:07,619
do yes another question here

00:57:15,710 --> 00:57:21,030
it's regarding the keys you make why not

00:57:18,869 --> 00:57:28,829
just canonicalize the path and then you

00:57:21,030 --> 00:57:33,480
only have one key you I yes yes if you

00:57:28,829 --> 00:57:36,210
access if if you access a file in always

00:57:33,480 --> 00:57:41,400
the same way you will just have one key

00:57:36,210 --> 00:57:44,160
for this file so it's your it's your

00:57:41,400 --> 00:57:46,470
role to take care of this if you just

00:57:44,160 --> 00:57:50,490
don't want to have many keys but you can

00:57:46,470 --> 00:57:53,400
expect something like ice wolf I expect

00:57:50,490 --> 00:57:55,799
something like free free keys / file

00:57:53,400 --> 00:57:57,839
it's an average churches you mean those

00:57:55,799 --> 00:58:00,539
keys are only generated when you

00:57:57,839 --> 00:58:06,960
actually access the file in a different

00:58:00,539 --> 00:58:09,260
way yep right like this it does it

00:58:06,960 --> 00:58:13,039
doesn't calculate them in advance then

00:58:09,260 --> 00:58:18,089
it doesn't recognize the different keys

00:58:13,039 --> 00:58:21,150
the keys are calculated with the way you

00:58:18,089 --> 00:58:26,130
access the file so if you access require

00:58:21,150 --> 00:58:29,640
a dot PHP require point / a dot PHP

00:58:26,130 --> 00:58:31,529
required porn / porn / poem / a this is

00:58:29,640 --> 00:58:37,859
a third key this yes you can shoot your

00:58:31,529 --> 00:58:41,849
foot no problem man so yes but usually

00:58:37,859 --> 00:58:47,010
for every PHP application which is where

00:58:41,849 --> 00:58:49,289
normally designed not it's it just works

00:58:47,010 --> 00:58:51,539
it just works you see on this example

00:58:49,289 --> 00:58:53,460
which I don't think it's a projection

00:58:51,539 --> 00:58:57,770
example but it should be something like

00:58:53,460 --> 00:59:01,950
a symphony to application we cashed

00:58:57,770 --> 00:59:05,819
101,000 and 800 about script and we have

00:59:01,950 --> 00:59:13,799
about twice the night little bit less

00:59:05,819 --> 00:59:16,849
keys so it's all right another question

00:59:13,799 --> 00:59:16,849
about that and yeah

00:59:17,810 --> 00:59:25,140
last question please last one in one of

00:59:21,960 --> 00:59:28,950
the problems with a PC was that if you

00:59:25,140 --> 00:59:31,340
enabled a PC for CLI as well it didn't

00:59:28,950 --> 00:59:35,880
actually share with your web servers

00:59:31,340 --> 00:59:39,180
cache files does hoo cash actually share

00:59:35,880 --> 00:59:42,390
code the cash code in shared memory so

00:59:39,180 --> 00:59:48,030
that it's available to both CLI and web

00:59:42,390 --> 00:59:52,190
access of pages or of scripts well CLI

00:59:48,030 --> 00:59:56,550
is not the same thing at all than web

00:59:52,190 --> 01:00:00,630
contexts nowadays fpm we use so

00:59:56,550 --> 01:00:04,290
application has the same trick as a pc

01:00:00,630 --> 01:00:07,250
which is 0 pH dot enable CLI equals one

01:00:04,290 --> 01:00:11,460
so it's enabled in CLI but it cannot

01:00:07,250 --> 01:00:13,710
share the same segment it's not the same

01:00:11,460 --> 01:00:16,920
Pete it's not the same process it's not

01:00:13,710 --> 01:00:19,290
the same process 3 you cannot share this

01:00:16,920 --> 01:00:21,510
is anonymous mapping for those that know

01:00:19,290 --> 01:00:26,339
this is a map map and animals so you can

01:00:21,510 --> 01:00:28,859
only share in a parent-child relation

01:00:26,339 --> 01:00:31,710
and are eunuchs process so you have all

01:00:28,859 --> 01:00:37,200
your fb you have you fpm master your FM

01:00:31,710 --> 01:00:39,060
children and then your CLI that can be

01:00:37,200 --> 01:00:42,210
shared if we don't choose a file and we

01:00:39,060 --> 01:00:47,150
won't use file back and map which that

01:00:42,210 --> 01:00:51,080
for security so no that's the answer

01:00:47,150 --> 01:00:51,080

YouTube URL: https://www.youtube.com/watch?v=pxW5WdKmprs


